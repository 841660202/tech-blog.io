{"title":"React V17.0 候选版本：无新功能","uid":"4afe9cca9efcce45bab52ea3fe738dfb","slug":"2022-07-25React-v17","date":"2022-07-25T06:54:43.000Z","updated":"2022-09-16T15:02:55.176Z","comments":true,"path":"api/articles/2022-07-25React-v17.json","keywords":null,"cover":[],"content":"<h2 id=\"无新特性\"><a href=\"#无新特性\" class=\"headerlink\" title=\"无新特性\"></a>无新特性</h2><p>React 17 的版本是非比寻常的，因为它<strong>没有添加任何面向开发人员的新功能</strong>。而主要<strong>侧重于升级简化 React 本身</strong>。</p>\n<p>我们正在积极开发 React 的新功能，但它们并不属于此版本。React 17 是我们进行深度推广战略的关键所在。</p>\n<p>此版本之所以特殊，你可以认为 <code>React 17 是 “垫脚石” 版本</code>，它会使得由<code>一个 React 版本管理的 tree 嵌入到另一个 React 版本管理的 tree 中时会更加安全</code>。</p>\n<h2 id=\"逐步升级\"><a href=\"#逐步升级\" class=\"headerlink\" title=\"逐步升级\"></a>逐步升级</h2><p>在过去 7 年里，React 一直遵循 <code>“all-or-nothing”</code> 的升级策略。你可以继续使用旧版本，也可以将整个应用程序升级至新版本。但没有介于两者之间的情况。</p>\n<p>此方式持续至今，但是我们遇到了 <code>“all-or-nothing” </code>升级策略的局限性。许多 API 的变更，例如，弃用旧版 context API 时，并不能以自动化的方式来完成。至今可能大多数应用程序从未使用过它们，但我们仍然选择在 React 中支持它们。<code>我们必须在无限期支持过时的 API 或针对某些应用仍使用旧版本 React 间进行选择。但这两个方案都不合适</code>。</p>\n<p>因此，我们想提供另一种方案。</p>\n<p>React 17 开始支持逐步升级 React 版本。当从 React 15 升级至 16 时（或者从 React 16 升级至 17 时），通常会一次升级整个应用程序。这适用于大部分应用程序。但是，如果代码库是在几年前编写的，并且并没有得到很好的维护，那么升级它会变得越来越有挑战性。<code>尽管可以在页面上使用两个版本的 React，但是直到 React 17 依旧有事件问题出现</code>。</p>\n<p>我们使用 React 17 解决了许多诸如此类的问题。这将意味着当 React 18 或未来版本问世时，你将有更多选择。首选还是像以前一样，一次升级整个应用程序。但你也可以选择逐步升级你的应用程序。例如，你可能会将大部分应用程序迁移至 React 18，但在 React 17 上保留一些延迟加载的对话框或子路由。</p>\n<p>但这不意味着你必须逐步升级。对于大部分应用程序来说，一次全量升级仍是最好的解决方案。加载两个 React 版本，即使其中一个是按需延迟加载的，仍然不太理想。但是，对于没有积极维护的大型应用来说，可以考虑此种方案，并且 React 17 开始可以保证这些应用程序不落伍。</p>\n<p>为了实现逐步升级，我们需要对 React 事件系统进行一些更改。而这些更改可能会对代码产生影响，这也是 React 17 成为主要版本的原因。实际上，10 万个以上的组件中受影响的组件不超过 20 个，因此，我们<strong>希望大多数应用程序都可以升级到 React 17，而不会产生太多影响</strong>。如果你遇到问题，请联系我们。</p>\n<h2 id=\"更改事件委托\"><a href=\"#更改事件委托\" class=\"headerlink\" title=\"更改事件委托\"></a>更改事件委托</h2><p>从技术上讲，始终可以在应用程序中嵌套不同版本的 React。但是，由于 React 事件系统的工作原理，这很难实现。</p>\n<p>在 React 组件中，通常会内联编写事件处理：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;button onClick&#x3D;&#123;handleClick&#125;&gt;\n</code></pre>\n\n<p>与此代码等效的原生 DOM 操作如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">myButton.addEventListener(&quot;click&quot;, handleClick);</code></pre>\n\n<p>但是，对大多数事件来说，React 实际上并不会将它们附加到 DOM 节点上。相反，React 会直接在 document 节点上为每种事件类型附加一个处理器。这被称为事件委托。除了在大型应用程序上具有性能优势外，它还使添加类似于 <code>replaying events</code> 这样的新特性变得更加容易。</p>\n<p>自从其发布以来，React 一直自动进行事件委托。<code>当 document 上触发 DOM 事件时，React 会找出调用的组件，然后 React 事件会在组件中向上 “冒泡”。但实际上，原生事件已经冒泡出了 document 级别</code>，React 在其中安装了事件处理器。</p>\n<p>但是，这就是逐步升级的困难所在。</p>\n<p><span style=\"color: red\">如果页面上有多个 React 版本，他们都将在顶层注册事件处理器。这会破坏 e.stopPropagation()：如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本 React 嵌套变得困难重重<span>。这种担忧并不是没有根据的 —— 例如，四年前 Atom 编辑器就遇到了相同的问题。</p>\n<p>这也是我们为什么要改变 React 底层附加事件方式的原因。</p>\n<p><strong>在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const rootNode &#x3D; document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App &#x2F;&gt;, rootNode);</code></pre>\n\n<p>在 React 16 或更早版本中，React 会对大多数事件执行 <code>document.addEventListener()</code>。React 17 将会在底层调用 <code>rootNode.addEventListener()</code>。</p>\n<img src=\"https://react.docschina.org/static/bb4b10114882a50090b8ff61b3c4d0fd/1e088/react_17_delegation.png\" />\n\n<p><strong>由于此更改，现在可以更加安全地进行新旧版本 React 树的嵌套</strong>。<span style=\"color: red\">请注意，要使其正常工作，两个版本都必须为 17 或更高版本，这就是为什么强烈建议升级到 React 17 的根本原因</span>。从某种意义上讲，React 17 是一个 “垫脚石” 版本，使逐步升级成为可能。</p>\n<p><strong>此更改还使得将 React 嵌入使用其他技术构建的应用程序变得更加容易</strong>。例如，如果应用程序的“外壳”是用 jQuery 编写的，但其中较新的代码是用 React 编写的，则 React 代码中的 e.stopPropagation() 会阻止它影响 jQuery 的代码 —— 这符合预期。换个角度来说，如果你不再喜欢 React 并想重写应用程序（比如，用 jQuery），则可以从外壳开始将 React 转换为 jQuery，而不会破坏事件冒泡。</p>\n<p>经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，这些问题大多都与将 React 与非 React 代码集成有关。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>你可能想知道这是否会破坏根 DOM 容器之外的 Portals。答案是 React 还会监听 portals 容器上的事件，所以这不是问题。</p>\n</div>\n<p><strong>解决隐患</strong></p>\n<p>与其他重大更改一样，可能需要对代码进行调整。在 Facebook，我们在成千上万个模块中，大约调整了 10 个模块以适应此更改。</p>\n<p>例如，如果模块中使用<code> document.addEventListener(...)</code> 手动添加了 DOM 监听，你可能希望能捕获到所有 React 事件。<span style=\"color: red\">在 React 16 或更早版本中，即使你在 React 事件处理器中调用 <code>e.stopPropagation()</code>，你创建的 DOM 监听仍会触发，这是因为原生事件已经处于 document 级别</span>。使用 React 17 冒泡将被阻止（按需），因此你的 document 级别的事件监听不会触发：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">document.addEventListener(&quot;click&quot;, function () &#123;\n  &#x2F;&#x2F; This custom handler will no longer receive clicks\n  &#x2F;&#x2F; from React components that called e.stopPropagation()\n&#125;);</code></pre>\n\n<p>你可以将监听转换为使用捕获来修复此类代码。为此，你可以将 <code>&#123; capture: true &#125; </code>作为 <code>document.addEventListener </code>的第三个参数传递：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">document.addEventListener(\n  &quot;click&quot;,\n  function () &#123;\n    &#x2F;&#x2F; Now this event handler uses the capture phase,\n    &#x2F;&#x2F; so it receives *all* click events below!\n  &#125;,\n  &#123; capture: true &#125;\n);</code></pre>\n\n<p>请注意，此策略在全局上具有更好的适应性。例如，它可能会修复代码中现有的错误，这些错误在 React 事件处理器外部调用 <code>e.stopPropagation()</code> 发生。换句话说，<strong>React 17 的事件冒泡更接近常规 DOM</strong>。</p>\n<h2 id=\"其他重大更改\"><a href=\"#其他重大更改\" class=\"headerlink\" title=\"其他重大更改\"></a>其他重大更改</h2><p>我们将 React 17 中的重大更改保持在最低水平。例如，它不会删除以前版本中弃用的任务方法。但是，它的确包含一些其他重大更改，根据经验，这些更改会相对安全。总体而言，由于这些因素的存在，在 10 万个以上的组件中受影响的组件不超过 20 个。</p>\n<h3 id=\"对标浏览器\"><a href=\"#对标浏览器\" class=\"headerlink\" title=\"对标浏览器\"></a>对标浏览器</h3><p>我们对事件系统进行了一些较小的更改：</p>\n<ul>\n<li><code>onScroll</code> 事件不再冒泡，以防止出现常见的混淆。</li>\n<li>React 的 <code>onFocus</code> 和 <code>onBlur</code> 事件已在底层切换为原生的 <code>focusin</code> 和 <code>focusout</code> 事件。它们更接近 <code>React</code> 现有行为，有时还会提供额外的信息。</li>\n<li>捕获事件（例如，<code>onClickCapture</code>）现在使用的是实际浏览器中的捕获监听器。</li>\n</ul>\n<p>这些更改会使 React 与浏览器行为更接近，并提高了互操作性。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>注意：</p>\n<p>尽管 React 17 底层已将 onFocus 事件从 focus 切换为 focusin，但请注意，这并未影响冒泡行为。在 React 中，onFocus 事件总是冒泡的，在 React 17 中会继续保持，因为通常它是一个更有用的默认值</p>\n</div>\n<h3 id=\"去除事件池\"><a href=\"#去除事件池\" class=\"headerlink\" title=\"去除事件池\"></a>去除事件池</h3><p>React 17 中移除了 “event pooling（事件池）“。它并不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function handleChange(e) &#123;\n  setData((data) &#x3D;&gt; (&#123;\n    ...data,\n    &#x2F;&#x2F; This crashes in React 16 and earlier:\n    text: e.target.value,\n  &#125;));\n&#125;</code></pre>\n\n<p>这是因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 <code>e.persist()</code> 才能正确的使用该事件，或者正确读取需要的属性。</p>\n<p><strong>在 React 17 中，此代码可以按照预期效果执行。旧的事件池优化操作已被完成删除，因此，使用者可以在需要时读取事件字段。</strong></p>\n<p>这改变了行为，因此我们将其标记为重大更改，但在实践中我们没有看到它在 Facebook 上造成影响。（甚至还修复了一些错误！）请注意，<span style=\"color: red\"><code>e.persist()</code> 在 React 事件对象中仍然可用，只是无效果罢了</span>。</p>\n<h3 id=\"副作用清理时间\"><a href=\"#副作用清理时间\" class=\"headerlink\" title=\"副作用清理时间\"></a>副作用清理时间</h3><p>我们将使 <code>useEffect</code> 和清理函数的时间保持一致。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">useEffect(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; This is the effect itself.\n  return () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; This is its cleanup.\n  &#125;;\n&#125;);</code></pre>\n\n<p>大多数副作用（<code>effect</code>）不需要延迟屏幕更新，因此 React 在屏幕上反映出更新后立即异步执行它们。（在极少数情况下，你需要一种副作用来阻止绘制，例如，如果需要获取尺寸和位置，请使用 <code>useLayoutEffect</code>。）</p>\n<p>然而，<span style=\"color: red\">当组件被卸载时，副作用清理函数（类似于在 class 组件中同步调用 componentWillUnmount）同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）</span>。</p>\n<p><strong>在 React 17 中，副作用清理函数总会异步执行 —— 如果要卸载组件，则清理会在屏幕更新后运行。</strong></p>\n<p>这反映了副作用本身如何更紧密地运行。在极少数情况下，你可能希望依靠同步执行，可以改用 <code>useLayoutEffect</code>。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>注意</p>\n<p>你可能想知道这是否意味着你现在将无法修复有关未挂载组件上的 setState 的警告。不必担心，React 专门处理了这种情况，并且不会在卸载和清理之间短暂间隔内发出 setState 的警告。因此，取消代码的请求或间隔几乎总是可以保存不变的。</p>\n\n</div>\n<p><strong>此外，React 17 将<code>在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）</code>。React 16 只对组件内的 effect 保证这种顺序。</strong></p>\n<h3 id=\"隐患\"><a href=\"#隐患\" class=\"headerlink\" title=\"隐患\"></a>隐患</h3><p>可复用的库可能需要对此情况进行深度测试，但我们只遇到了几个组件会因为这次改变出现问题。有问题的代码的其中一个示例如下所示：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">useEffect(() &#x3D;&gt; &#123;\n  someRef.current.someSetupMethod();\n  return () &#x3D;&gt; &#123;\n    someRef.current.someCleanupMethod();\n  &#125;;\n&#125;);</code></pre>\n\n<p>问题在于 someRef.current 是可变的，因此在运行清除函数时，它可能已经设置为 null。解决方案是在副作用内部存储会发生变化的值：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">useEffect(() &#x3D;&gt; &#123;\n  const instance &#x3D; someRef.current;\n  instance.someSetupMethod();\n  return () &#x3D;&gt; &#123;\n    instance.someCleanupMethod();\n  &#125;;\n&#125;);</code></pre>\n\n<p><strong>我们不希望此问题对大家造成影响，我们提供了 <code>eslint-plugin-react-hooks/exhaustive-deps</code> 的 lint 规则（<span style=\"color: red\">请确保在项目中使用它</span>）会对此情况发出警告。</strong></p>\n<h3 id=\"返回一致的-undefined-错误\"><a href=\"#返回一致的-undefined-错误\" class=\"headerlink\" title=\"返回一致的 undefined 错误\"></a>返回一致的 undefined 错误</h3><p>在 React 16 及更早版本中，返回 undefined 始终是一个错误：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Button() &#123;\n  return; &#x2F;&#x2F; Error: Nothing was returned from render\n&#125;</code></pre>\n\n<p>部分原因是这很容易无意间返回 undefined：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Button() &#123;\n  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.\n  &#x2F;&#x2F; React surfaces this as an error instead of ignoring it.\n  &lt;button &#x2F;&gt;;\n&#125;</code></pre>\n\n<p>以前，<strong>React 只对 class 和函数组件执行此操作，但并不会检查 forwardRef 和 memo 组件的返回值。这是由于编码错误导致</strong>。</p>\n<p>在 React 17 中，<strong>forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致</strong>。在返回 undefined 时会报错</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let Button &#x3D; forwardRef(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.\n  &#x2F;&#x2F; React 17 surfaces this as an error instead of ignoring it.\n  &lt;button &#x2F;&gt;;\n&#125;);\n\nlet Button &#x3D; memo(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.\n  &#x2F;&#x2F; React 17 surfaces this as an error instead of ignoring it.\n  &lt;button &#x2F;&gt;;\n&#125;);</code></pre>\n\n<p><strong>对于不想进行任何渲染的情况，请返回 null。</strong></p>\n<h3 id=\"原生组件栈\"><a href=\"#原生组件栈\" class=\"headerlink\" title=\"原生组件栈\"></a>原生组件栈</h3><p>当你在浏览器中遇到错误时，浏览器会为你提供带有 JavaScript 函数的名称及位置的调用栈信息。然而，JavaScript 调用栈通常不足以诊断问题，因为 React 树的层次结构可能同样重要。你不仅要知道哪个 Button 抛出了错误，而且还想知道 Button 在 React 树中的哪个位置。</p>\n<p>为了解决这个问题，当你遇到错误时，从 React 16 开始会打印 “组件栈” 信息。尽管如此，它们仍然不如原生的 JavaScript 调用栈。特别是，它们在控制台中不可点击，因为 React 不知道函数在源代码中的声明位置。此外，它们在生产中几乎无用。不同于常规压缩后的 JavaScript 调用栈，它们可以通过 sourcemap 的形式自动恢复到原始函数的位置，而使用 React 组件栈，在生产环境下必须在调用栈信息和 bundle 大小间进行选择。</p>\n<p><strong>在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。</strong></p>\n<p>React 实现这一点的方式有点非常规。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。_因此，当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息。这会增加崩溃时的性能损失，但每个组件类型只会发生一次_。</p>\n<p>如果你对此感兴趣，可以在这个 PR 中阅读更多详细信息，但是在大多数情况下，这种机制不会影响你的代码。从使用者的角度来看，新功能就是可以单击组件调用栈（因为它们依赖于本机浏览器调用栈框架），并且可以像常规 JavaScript 错误那样在生产中进行解码。</p>\n<p>构成重大变化的部分是，要使此功能正常工作，React 将在捕获错误后在调用栈中重新执行上面某些函数和某些 class 构造函数的部分。由于渲染函数和 class 构造函数不应具有副作用（这对于 SSR 也很重要），因此这不会造成任何实际问题。</p>\n<h3 id=\"移除私有导出\"><a href=\"#移除私有导出\" class=\"headerlink\" title=\"移除私有导出\"></a>移除私有导出</h3><p>最后，值得注意的重大变化时我们<em>删除了一些以前暴露给其他项目的 React 内部组件</em>。特别是，React Native for Web 过去常常依赖于事件系统的某些内部组件，但这种依赖关系很脆弱且经常被破坏。</p>\n<p>在 React 17 中，这些私有导出已被移除。据我们所知，React Native for Web 是唯一使用它们的项目，它们已经完成了向不依赖那些私有导出函数的其他方法迁移。</p>\n<p><strong>这意味着旧版本的 React Native for Web 不会与 React 17 兼容</strong>，但是新版本可以使用它。实际上，并没有太大的变化，因为 React Native for Web 必须发布新版本以适应其内部 React 的变化。</p>\n<p>另外，我们删除了 ReactTestUtils.SimulateNative 的 helper 方法。他们从未被记录，没有按照他们名字所暗示的那样去做，也没有处理我们对事件系统所做的更改。如果你想要一种简便的方式来触发测试中原生浏览器的事件，请改用 React Testing Library。</p>\n","text":"无新特性React 17 的版本是非比寻常的，因为它没有添加任何面向开发人员的新功能。而主要侧重于升级简化 React 本身。 我们正在积极开发 React 的新功能，但它们并不属于此版本。React 17 是我们进行深度推广战略的关键所在。 此版本之所以特殊，你可以认为 Rea...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"React","slug":"React","count":34,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":28,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A0%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">无新特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%90%E6%AD%A5%E5%8D%87%E7%BA%A7\"><span class=\"toc-text\">逐步升级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%94%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98\"><span class=\"toc-text\">更改事件委托</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%94%B9\"><span class=\"toc-text\">其他重大更改</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%A0%87%E6%B5%8F%E8%A7%88%E5%99%A8\"><span class=\"toc-text\">对标浏览器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E6%B1%A0\"><span class=\"toc-text\">去除事件池</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%AF%E4%BD%9C%E7%94%A8%E6%B8%85%E7%90%86%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">副作用清理时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E6%82%A3\"><span class=\"toc-text\">隐患</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E8%87%B4%E7%9A%84-undefined-%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">返回一致的 undefined 错误</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E6%A0%88\"><span class=\"toc-text\">原生组件栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E9%99%A4%E7%A7%81%E6%9C%89%E5%AF%BC%E5%87%BA\"><span class=\"toc-text\">移除私有导出</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-http CORS","uid":"ed5ec0392ecb18ec3bd3ba76435a94c5","slug":"2022-07-26http-CORS","date":"2022-07-26T06:46:35.000Z","updated":"2023-02-20T21:20:56.468Z","comments":true,"path":"api/articles/2022-07-26http-CORS.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202208011718040.webp","text":"思维导图 跨源资源共享（CORS）CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。 存在的背景同源安全策略...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"React@16、17 杂货","uid":"7914c7b61758cb63e0d9afa98b764a25","slug":"2022-07-23react-杂货","date":"2022-07-22T16:25:08.000Z","updated":"2022-09-16T15:02:50.889Z","comments":true,"path":"api/articles/2022-07-23react-杂货.json","keywords":null,"cover":null,"text":"注意版本哈从前有座山之 react 源码解读之 ReactContext React 源码解析————ReactContext.js,ReactLazy.js React 的 React.createRef()&#x2F;forwardRef()源码解析(三) React 的 R...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"React","slug":"React","count":34,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":28,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}