{"title":"前端基础-js class","uid":"96631ce884e53e339dba9cb51900376e","slug":"2022-10-21js-class","date":"2022-10-21T05:40:31.000Z","updated":"2023-05-15T13:17:32.964Z","comments":true,"path":"api/articles/2022-10-21js-class.json","keywords":null,"cover":null,"content":"<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"什么是类，-有什么作用\"><a href=\"#什么是类，-有什么作用\" class=\"headerlink\" title=\"什么是类， 有什么作用\"></a>什么是类， 有什么作用</h2><p>类是: <code>用于创建对象的模板</code>。用代码封装数据以处理该数据。</p>\n<p>JS 中的类建立在原型上，但与 ES5 类的语法和语义不同</p>\n<p>类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。</p>\n<h2 id=\"与函数区别\"><a href=\"#与函数区别\" class=\"headerlink\" title=\"与函数区别\"></a>与函数区别</h2><p>class 关键字声明一个类。<span style=\"color: red\">函数声明会提升，类声明不会</span></p>\n<p>类表达式是定义类的另一种方法。类表达式可以命名或不命名。命名类表达式的名称是该类体的局部名称。</p>\n<h2 id=\"类体和方法定义\"><a href=\"#类体和方法定义\" class=\"headerlink\" title=\"类体和方法定义\"></a>类体和方法定义</h2><p>一个类的类体: <code>是一对花括号/大括号 &#123;&#125; 中的部分</code>。这是你定义类成员的位置，如方法或构造函数。</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter 和 setter 都在严格模式下执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n  speak() &#123;\n    return this;\n  &#125;\n  static eat() &#123;\n    return this;\n  &#125;\n&#125;\n\nlet obj &#x3D; new Animal();\nobj.speak(); &#x2F;&#x2F; Animal &#123;&#125; &#x2F;&#x2F; 实例化后，指向的是类的实例\nlet speak &#x3D; obj.speak;\nspeak(); &#x2F;&#x2F; undefined &#x2F;&#x2F;严格执行\n\nAnimal.eat(); &#x2F;&#x2F; class Animal &#x2F;&#x2F; 类的静态方法中指向类\nlet eat &#x3D; Animal.eat;\neat(); &#x2F;&#x2F; undefined</code></pre>\n\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><p>constructor 是一种用于 <code>创建和初始化（ class 创建的）对象</code> 的特殊方法</p>\n<p>哪里特殊了？</p>\n<p><strong>构造函数中的 this 指向实例，其他类体中的 this 指向 undefined</strong></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">constructor([arguments]) &#123; ... &#125;\n</code></pre>\n\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>只能出现一次 constructor，出现多次报错</li>\n<li>constructor 内部可以使用 super 调用父类构造方法</li>\n<li>不指定构造方法，会有一个默认构造方法（有两种：非派生、派生类的构造函数）</li>\n<li>setPrototypeOf 只一个类的原型，不改变这个基类的构造函数</li>\n</ul>\n<p><strong>默认构造方法</strong></p>\n<p>如前所述，如果不指定构造方法，则使用默认构造函数。对于基类，默认构造函数是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">constructor() &#123;&#125;</code></pre>\n\n<p>对于派生类，默认构造函数是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">constructor(...args) &#123;\n  super(...args);\n&#125;</code></pre>\n\n<h1 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h1><p><strong>extends</strong>关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nclass ChildClass extends ParentClass &#123; ... &#125;\n</code></pre>\n\n<p>extends 关键字用来创建一个普通类或者内建对象的子类。</p>\n<ul>\n<li>什么是普通类：没有父类，非内置对象的类</li>\n<li>什么是派生类：父类也叫超类、基类，子类也叫派生类。 <a href=\"https://www.jianshu.com/p/5bae725b9902\" target=\"_blank\" >见</a></li>\n<li>什么是内置对象： Date</li>\n<li>扩展 null</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 扩展 null 这是什么骚操作，有什么用？\n&#x2F;&#x2F; 新对象的原型将不会继承 Object.prototype\nclass nullExtends extends null &#123;\n  constructor() &#123;&#125;\n&#125;\n\nObject.getPrototypeOf(nullExtends); &#x2F;&#x2F; Function.prototype\nObject.getPrototypeOf(nullExtends.prototype); &#x2F;&#x2F; null\n\nnew nullExtends(); &#x2F;&#x2F;ReferenceError: this is not defined</code></pre>\n\n<h1 id=\"类私有域\"><a href=\"#类私有域\" class=\"headerlink\" title=\"类私有域\"></a>类私有域</h1><ul>\n<li>类属性在默认情况下是<code>公有的</code></li>\n<li><code>前缀 # </code>的方式来定义<code>私有类字段</code>，这一隐秘封装的类特性由 JavaScript 自身强制执行。</li>\n</ul>\n<h2 id=\"私有字段\"><a href=\"#私有字段\" class=\"headerlink\" title=\"私有字段\"></a>私有字段</h2><p>私有字段包括<code>私有实例字段</code>和<code>私有静态字段</code>。</p>\n<h3 id=\"私有实例字段\"><a href=\"#私有实例字段\" class=\"headerlink\" title=\"私有实例字段\"></a>私有实例字段</h3><ul>\n<li>私有字段在类声明的构造方法中就可被访问。</li>\n<li>类似于公有字段，私有字段在构造（construction）基类或调用子类的 super() 方法时被添加到类实例中</li>\n<li>作用域之外引用、未声明引用、删除都会报错</li>\n</ul>\n<h3 id=\"私有静态字段\"><a href=\"#私有静态字段\" class=\"headerlink\" title=\"私有静态字段\"></a>私有静态字段</h3><ul>\n<li>私有静态字段： 在解析类结构时被添加到类的构造方法（constructor）中。</li>\n<li>静态变量：只能被静态方法调用</li>\n</ul>\n<h2 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h2><h3 id=\"私有实例方法\"><a href=\"#私有实例方法\" class=\"headerlink\" title=\"私有实例方法\"></a>私有实例方法</h3><ul>\n<li><code>私有实例方法</code>是类实例上可用的方法，它们的访问方式与私有实例字段相同。</li>\n<li><code>私有实例方法</code>可以是生成器方法、异步方法或异步生成器方法，也可以是私有的 getter 和 setter。</li>\n</ul>\n<h3 id=\"私有静态方法\"><a href=\"#私有静态方法\" class=\"headerlink\" title=\"私有静态方法\"></a>私有静态方法</h3><p>私有静态方法可以是生成器方法，异步方法或异步生成器方法。</p>\n<p>前面提到的私有静态字段的限制同样适用于私有静态方法。</p>\n<p>同样地，使用 this 可能会出现意想不到的行为。<br>在下方的例子中，<code>this 是 Derived 类（而不是 Base 类）的引用</code>，<br>所以尝试调用 Derived.publicStaticMethod2() 会抛出 TypeError。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Base &#123;\n  static #privateStaticMethod() &#123;\n    return 42;\n  &#125;\n  static publicStaticMethod1() &#123;\n    return Base.#privateStaticMethod();\n  &#125;\n  static publicStaticMethod2() &#123;\n    return this.#privateStaticMethod();\n  &#125;\n&#125;\n\nclass Derived extends Base &#123;&#125;\n\nconsole.log(Derived.publicStaticMethod1());\n&#x2F;&#x2F; 42\nconsole.log(Derived.publicStaticMethod2());\n&#x2F;&#x2F; TypeError: Cannot read private member #privateStaticMethod\n&#x2F;&#x2F; from an object whose class did not declare it</code></pre>\n\n<h1 id=\"公有类字段\"><a href=\"#公有类字段\" class=\"headerlink\" title=\"公有类字段\"></a>公有类字段</h1><p>公有静态字段和公有实例字段都是<code>可编辑</code>、<code>可枚举</code>和<code>可配置</code>的属性。因此，不同于私有对应值（private counterpart）的是，它们参与原型的继承。</p>\n<h2 id=\"公有静态字段\"><a href=\"#公有静态字段\" class=\"headerlink\" title=\"公有静态字段\"></a>公有静态字段</h2><p><span style=\"color: red\">在类里面存数据，只有一份，其他实例不存，可被其他实例共享</span></p>\n<ol>\n<li>公有静态字段是使用关键字 static 声明的。</li>\n<li>我们在声明一个类的时候，使用 Object.defineProperty() 方法<code>将公有静态字段添加到类的构造函数中</code>。</li>\n<li>在类被声明之后，可以从类的构造函数访问公有静态字段。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class ClassWithStaticField &#123;\n  static staticField &#x3D; &#39;static field&#39;; &#x2F;&#x2F; 如果没有初始化，默认是undefined\n&#125;\n\nconsole.log(ClassWithStaticField.staticField);\n&#x2F;&#x2F; 预期输出值：&quot;static field&quot;​</code></pre>\n\n<p>公有静态字段不会在子类中重复初始化，可以通过原型链访问它们。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class ClassWithStaticField &#123;\n  static baseStaticField &#x3D; &#39;base field&#39;;\n&#125;\n\nclass SubClassWithStaticField extends ClassWithStaticField &#123;\n  static subStaticField &#x3D; &#39;sub class field&#39;;\n&#125;\n\nconsole.log(SubClassWithStaticField.subStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;sub class field&quot;\n\nconsole.log(SubClassWithStaticField.baseStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;base field&quot;</code></pre>\n\n<p>在初始化字段时，this 指向的是类的实例 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields#:~:text=%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E6%AE%B5%E6%97%B6%EF%BC%8Cthis%20%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\" target=\"_blank\" >见</a><br>你也可以通过名字引用构造函数，并使用 super 获取到存在的父类的构造函数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class ClassWithStaticField &#123;\n  static baseStaticField &#x3D; &#39;base static field&#39;;\n  &#x2F;&#x2F; 这里可以论证 在初始化字段时，this 指向的是类\n  static anotherBaseStaticField &#x3D; this.baseStaticField;\n\n  static baseStaticMethod() &#123;\n    return &#39;base static method output&#39;;\n  &#125;\n&#125;\n\nclass SubClassWithStaticField extends ClassWithStaticField &#123;\n  static subStaticField &#x3D; super.baseStaticMethod();\n&#125;\n\nconsole.log(ClassWithStaticField.anotherBaseStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;base static field&quot;\n\nconsole.log(SubClassWithStaticField.subStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;base static method output&quot;</code></pre>\n\n<h2 id=\"公有实例字段\"><a href=\"#公有实例字段\" class=\"headerlink\" title=\"公有实例字段\"></a>公有实例字段</h2><p>公有实例字段存在于类的每一个实例中。是对类模型的描述（这个类模型产出的实例对象的特点）</p>\n<p>公有实例字段可以在基类的构造过程中（构造函数主体运行前）使用 Object.defineProperty() 添加，<br>也可以在子类构造函数中的 super() 函数结束后添加。</p>\n<ul>\n<li>公有实例字段默认 undefined。</li>\n<li>公有实例字段名可以由计算得出。</li>\n<li>在初始化字段时，this 指向的是类正在构造中的实例。和公有实例方法相同的是：你可以在子类中使用 super 来访问父类的原型。</li>\n<li>因为类的实例字段是在对应的构造函数运行之前添加的，所以你可以在构造函数中访问字段的值。（现有字段，而后有构造函数）</li>\n<li>因为派生类的实例字段是在 super() 返回之后定义的，所以基类的构造函数无法访问派生类的字段。</li>\n<li>因为类字段是通过 [[Define]] 语义（本质上是 Object.defineProperty()）添加的，所以派生类中的字段声明并不会调用基类中的 setter。此行为不同于在构造函数中使用 this.field &#x3D; …</li>\n</ul>\n<h2 id=\"公有静态方法\"><a href=\"#公有静态方法\" class=\"headerlink\" title=\"公有静态方法\"></a>公有静态方法</h2><p>关键字 static 将为一个类定义一个静态方法。静态方法不是在一个实例之上被调用，而是在类自身之上被调用</p>\n<p>静态方法是在类的声明阶段用 Object.defineProperty() 方法添加到类的构造函数中的。静态方法是可编辑、<strong>不可枚举</strong>和可配置的。</p>\n<h2 id=\"公有实例方法\"><a href=\"#公有实例方法\" class=\"headerlink\" title=\"公有实例方法\"></a>公有实例方法</h2><p>正如其名，公有实例方法是可以在类的实例中使用的。<br>公有实例方法是在类的声明阶段用 Object.defineProperty() 方法添加到类中的。静态方法是可编辑、<strong>不可枚举</strong>和可配置的。<br>实例的方法中，this 指向的是实例本身，你可以使用 super 访问到父类的原型，由此你可以调用父类的方法。<br>getter 和 setter 是和类的属性绑定的特殊方法，分别会在其绑定的属性被取值、赋值时调用。使用 get 和 set 语法定义实例的公有 getter 和 setter。</p>\n<h1 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h1><p>静态方法调用直接在类上进行，不能在类的实例上调用。静态方法通常用于创建实用程序函数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">static methodName() &#123; ... &#125;</code></pre>\n\n<h2 id=\"调用静态方法\"><a href=\"#调用静态方法\" class=\"headerlink\" title=\"调用静态方法\"></a>调用静态方法</h2><ul>\n<li><p><code>从另一个静态方法</code>: 静态方法调用同一个类中的其他静态方法，可使用 this 关键字。</p>\n</li>\n<li><p><code>从类的构造函数和其他方法</code>: 非静态方法中，不能直接使用 this 关键字来访问静态方法。</p>\n<ol>\n<li>要用类名来调用：CLASSNAME.STATIC_METHOD_NAME()</li>\n<li>用构造函数的属性来调用该方法： this.constructor.STATIC_METHOD_NAME().</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class StaticMethodCall &#123;\n  constructor() &#123;\n    console.log(StaticMethodCall.staticMethod());\n    &#x2F;&#x2F; &#39;static method has been called.&#39;\n    console.log(this.constructor.staticMethod());\n    &#x2F;&#x2F; &#39;static method has been called.&#39;\n  &#125;\n  static staticMethod() &#123;\n    return &#39;static method has been called.&#39;;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"为什么要设计-static-方法\"><a href=\"#为什么要设计-static-方法\" class=\"headerlink\" title=\"为什么要设计 static 方法\"></a>为什么要设计 static 方法</h2><p>在 JavaScript 中，<code>class</code> 是 ES6 引入的一种面向对象编程的语法糖，可以方便地定义一个构造函数和一个原型对象，并将它们组合成一个类。在 <code>class</code> 中，我们可以定义实例方法、静态方法和实例属性，而静态方法是在类上定义的方法，而不是在实例上定义的方法。</p>\n<p>静态方法的一个主要用途是为类创建工具函数。它们通常与实例方法配合使用，提供一种在类级别上操作数据的方法。在一些常见的应用场景中，静态方法经常被用来作为工具函数，进行一些通用的数据处理，或者对类的静态属性进行操作。举例来说，对于一些数学计算，我们可以使用静态方法来实现一个数学工具库，如下面的例子：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class MathUtils &#123;\n  static sum(x, y) &#123;\n    return x + y;\n  &#125;\n\n  static subtract(x, y) &#123;\n    return x - y;\n  &#125;\n&#125;\n\nconsole.log(MathUtils.sum(1, 2)); &#x2F;&#x2F; 3\nconsole.log(MathUtils.subtract(3, 2)); &#x2F;&#x2F; 1</code></pre>\n\n<p>上面的代码定义了一个 <code>MathUtils</code> 类，其中包含了两个静态方法 <code>sum</code> 和 <code>subtract</code>，它们可以直接通过类名调用。这样，我们就可以把这个类当做一个工具库来使用了。</p>\n<p>另外，静态方法还有一个好处，就是可以提高类的性能。因为静态方法是在类上定义的，不需要实例化就可以直接访问，这样就可以避免在实例化时多次创建相同的方法，节省内存开销。</p>\n<p>总之，静态方法的出现，使得开发者能够在类级别上操作数据，并且能够有效地提高类的性能，提供更好的代码可读性和可维护性。</p>\n<h1 id=\"类中的-this\"><a href=\"#类中的-this\" class=\"headerlink\" title=\"类中的 this\"></a>类中的 this</h1><p>类声明和类表达式的主体都执行在严格模式下 <strong>同样遵循谁调用指向谁：</strong></p>\n<ol>\n<li>实例调用实例方法，指向实例</li>\n<li>类调用静态方法，指向类</li>\n<li><em>实例方法、类的静态在全局调用，由于是严格模式，所以 this 是 undefined</em></li>\n</ol>\n","text":"类什么是类， 有什么作用类是: 用于创建对象的模板。用代码封装数据以处理该数据。 JS 中的类建立在原型上，但与 ES5 类的语法和语义不同 类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。 与函数区别class 关键字声明一...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%EF%BC%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">什么是类， 有什么作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">与函数区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">类体和方法定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">严格模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#extends\"><span class=\"toc-text\">extends</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%A7%81%E6%9C%89%E5%9F%9F\"><span class=\"toc-text\">类私有域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">私有字段</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">私有实例字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">私有静态字段</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">私有方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">私有实例方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">私有静态方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AC%E6%9C%89%E7%B1%BB%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">公有类字段</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E6%9C%89%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">公有静态字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E6%9C%89%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">公有实例字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E6%9C%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">公有静态方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E6%9C%89%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">公有实例方法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#static\"><span class=\"toc-text\">static</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">调用静态方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1-static-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">为什么要设计 static 方法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%AD%E7%9A%84-this\"><span class=\"toc-text\">类中的 this</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-css q&a","uid":"81556a3598a3ddc6cbb980694cccc8db","slug":"2022-10-23css-qa","date":"2022-10-23T06:39:57.000Z","updated":"2023-05-15T13:17:32.966Z","comments":true,"path":"api/articles/2022-10-23css-qa.json","keywords":null,"cover":[],"text":"1. 获取 CDNS 的 文章标题var list &#x3D; document.getElementsByClassName(&#39;column_article_list&#39;)[0].children; Array.from(list).forEach((item)...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"24 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"gorm migrate 注意点","uid":"1269a76e445b052b3fd7442cae906b92","slug":"2022-10-21gorm-migrate","date":"2022-10-21T02:04:16.000Z","updated":"2022-12-22T13:36:21.792Z","comments":true,"path":"api/articles/2022-10-21gorm-migrate.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202212211225570.webp","text":"等效语句添加、删除会报错 &#x2F;&#x2F; ... type User struct &#123; gorm.Model Name string &#96;gorm:&quot;size:255;index:idx_name,unique&quot;&#96; &#125...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"Go","slug":"Go","count":19,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":19,"path":"api/tags/Go.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}