{"title":"React Refs","uid":"5fabc47ffe883306098d02d0d23becda","slug":"2023-01-28refs","date":"2023-01-28T05:36:24.000Z","updated":"2023-02-20T21:20:56.485Z","comments":true,"path":"api/articles/2023-01-28refs.json","keywords":null,"cover":null,"content":"<h2 id=\"Refs-amp-DOM\"><a href=\"#Refs-amp-DOM\" class=\"headerlink\" title=\"Refs &amp; DOM\"></a>Refs &amp; DOM</h2><ol>\n<li>为 DOM 元素添加 ref</li>\n<li>为 class 组件添加 Ref</li>\n<li>Refs 与函数组件</li>\n</ol>\n<p>默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例</p>\n<p>如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativeHandle 结合使用），或者可以将该组件转化为 class 组件。</p>\n<h3 id=\"将-DOM-Refs-暴露给父元素\"><a href=\"#将-DOM-Refs-暴露给父元素\" class=\"headerlink\" title=\"将 DOM Refs 暴露给父元素\"></a>将 DOM Refs 暴露给父元素</h3><p>有版本限制：16.3 或更高版本的 React</p>\n<p>Refs 转发： Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref</p>\n<h2 id=\"Refs-转发\"><a href=\"#Refs-转发\" class=\"headerlink\" title=\"Refs 转发\"></a>Refs 转发</h2><ol>\n<li><code>refs 将不会透传下去</code>。这是因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。</li>\n<li>可以使用 <code>React.forwardRef</code> API 明确地将 refs 转发到内部的 FancyButton 组件。<code>React.forwardRef</code> 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点</li>\n<li>第二个参数 ref 只在使用 <code>React.forwardRef</code> 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref</li>\n<li>可以设置函数的 <code>displayName 属性来包含被包裹组件的名称</code>, 在 DevTools 中显示自定义名称</li>\n<li>使用 forwardRef 时，你应当将其视为一个破坏性更改，并<code>发布库的一个新的主版本</code></li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zh-hans.reactjs.org/docs/refs-and-the-dom.html\" target=\"_blank\" >Refs and the DOM</a></p>\n<p><a href=\"https://zh-hans.reactjs.org/docs/forwarding-refs.html\" target=\"_blank\" >Refs 转发</a></p>\n","text":"Refs &amp; DOM 为 DOM 元素添加 ref 为 class 组件添加 Ref Refs 与函数组件 默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例 如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativ...","link":"","photos":[],"count_time":{"symbolsCount":704,"symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":36,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":30,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Refs-amp-DOM\"><span class=\"toc-text\">Refs &amp; DOM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86-DOM-Refs-%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%88%B6%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">将 DOM Refs 暴露给父元素</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Refs-%E8%BD%AC%E5%8F%91\"><span class=\"toc-text\">Refs 转发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"组件库UMD产物","uid":"87960c0852e545c2c12901d0c42ef062","slug":"2023-01-29umd","date":"2023-01-29T03:32:23.000Z","updated":"2023-02-20T21:20:56.486Z","comments":true,"path":"api/articles/2023-01-29umd.json","keywords":null,"cover":null,"text":"背景有些组件库（公司 wiki 库）依赖项，非常多，编译速度巨慢，如果能够像 echarts 一样，使用 script 标签引入，这样无需编译，浏览器还有缓存可以利用，开发体验非常可观 一直以来在想打 umd 产物的包，以解决上述问题，没时间～，我今天又揽活了，什么时候能改掉这个...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"React","slug":"React","count":36,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":30,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Map & Set & Object","uid":"4a39cce638cfb347201792d2fa0ff3a8","slug":"2023-01-21map&set","date":"2023-01-21T06:48:19.000Z","updated":"2023-02-20T21:20:56.485Z","comments":true,"path":"api/articles/2023-01-21map&set.json","keywords":null,"cover":null,"text":"MapMap 的特点 有序： Map 对象保存键值对，并且能够记住键的原始插入顺序。 键值随意：任何值（对象或者基本类型）都可以作为一个键或一个值。 Map 对象是键值对的集合。 键唯一：Map 中的一个键只能出现一次；它在 Map 的集合中是独一无二的。 可迭代：Map 对象按...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}