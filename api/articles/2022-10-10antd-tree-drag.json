{"title":"Antd Tree drag","uid":"9635a6b254011f1f62378c1d84830a04","slug":"2022-10-10antd-tree-drag","date":"2022-10-10T01:19:14.000Z","updated":"2022-10-15T02:11:29.159Z","comments":true,"path":"api/articles/2022-10-10antd-tree-drag.json","keywords":null,"cover":[],"content":"<h2 id=\"属性解释\"><a href=\"#属性解释\" class=\"headerlink\" title=\"属性解释\"></a>属性解释</h2><p><strong>dropToGap</strong>：boolean类型，true代表拖拽到节点之间的缝隙中，false代表拖拽到节点上，即节点的内容区。<br><strong>dropPosition</strong>：拖拽的时候，针对一个节点有三种情况，即拖拽到节点之上，拖拽到节点上，拖拽到节点之下。</p>\n<p>三种情况其值有所不同。antd 依赖了 rc-tree，</p>\n<p><strong>rc-tree</strong> </p>\n<p>在 rc-tree 里 dropPosition 是一个相对地址。<br>如果拖到了目标节点的上面则当前元素 -1，下面则是 1（* rc-tree这块不确定具体情况*）。</p>\n<p><strong>antd</strong></p>\n<p> antd里则是相对于目标节点的 index针对拖动情况计算出来。</p>\n<ul>\n<li>拖拽到节点之上(<strong>节点上边缘间隙位置</strong>)： 该节点的 index-1</li>\n<li>拖拽到节点上面(<strong>上边缘与下边缘之间的区域</strong>)：dropPosition 就是该节点的 index。</li>\n<li>拖拽到节点之下(<strong>节点下边缘间隙位置</strong>)：该节点的 index+1</li>\n</ul>\n<p>如下图所示：</p>\n<h2 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h2><img src=\"http://t-blog-images.aijs.top/img/202210101025107.webp\" />\n\n<h2 id=\"官方代码\"><a href=\"#官方代码\" class=\"headerlink\" title=\"官方代码\"></a>官方代码</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"> onDrop &#x3D; info &#x3D;&gt; &#123;\n    console.log(info);\n    const dropKey &#x3D; info.node.props.eventKey;\n    const dragKey &#x3D; info.dragNode.props.eventKey;\n    const dropPos &#x3D; info.node.props.pos.split(&#39;-&#39;);\n   &#x2F;&#x2F; 这里计算的差值 上面分析了info.dropPosition的含义   dropPosition有3种情况 \n   &#x2F;&#x2F; &#x3D;0 表示拖拽到元素上\n  &#x2F;&#x2F; &#x3D;1 表示拖拽到元素下面   那么放置元素的时候  应该放到这个位置+1的位置上\n  &#x2F;&#x2F; &#x3D;-1 表示拖拽到元素上面   那么放置元素的时候 直接放到这个位置即可\n    const dropPosition &#x3D; info.dropPosition - Number(dropPos[dropPos.length - 1]);\n\n&#x2F;&#x2F; 递归查到元素所在树中的位置\n    const loop &#x3D; (data, key, callback) &#x3D;&gt; &#123;\n      data.forEach((item, index, arr) &#x3D;&gt; &#123;\n        if (item.key &#x3D;&#x3D;&#x3D; key) &#123;\n          &#x2F;&#x2F;在回调函数中将此元素，位置，以及元数组都返回\n          return callback(item, index, arr);\n        &#125;\n        if (item.children) &#123;\n          return loop(item.children, key, callback);\n        &#125;\n      &#125;);\n    &#125;;\n    &#x2F;&#x2F; 浅拷贝整个树 此处有疑问  不过不影响功能  因为怕操作data 我觉得应该深拷贝 \n    const data &#x3D; [...this.state.gData];\n\n    &#x2F;&#x2F; Find dragObject 查找获取到拖拽开始的元素对象\n    let dragObj;\n    loop(data, dragKey, (item, index, arr) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 查找到后删除此元素  这里相当于直接操作了data 所以我认为应该深拷贝\n      arr.splice(index, 1);\n      dragObj &#x3D; item;\n    &#125;);\n\n    if (!info.dropToGap) &#123;\n      &#x2F;&#x2F; Drop on the content  拖拽到内容上 \n      loop(data, dropKey, item &#x3D;&gt; &#123;\n        item.children &#x3D; item.children || [];\n        &#x2F;&#x2F; where to insert 示例添加到尾部，可以是随意位置\n        item.children.push(dragObj);\n      &#125;);\n    &#125;\n    &#x2F;&#x2F; 拖拽到元素之下的缝隙中，元素有子节点，并且当前元素子节点展开。此时元素放到了子节点的第一位。（当然可以根据具体情况随意位置） \n    else if (\n      (info.node.props.children || []).length &gt; 0 &amp;&amp; &#x2F;&#x2F; Has children\n      info.node.props.expanded &amp;&amp; &#x2F;&#x2F; Is expanded\n      dropPosition &#x3D;&#x3D;&#x3D; 1 &#x2F;&#x2F; On the bottom gap\n    ) &#123;\n      loop(data, dropKey, item &#x3D;&gt; &#123;\n        item.children &#x3D; item.children || [];\n        &#x2F;&#x2F; where to insert 示例添加到头部，可以是随意位置\n        item.children.unshift(dragObj);\n      &#125;);\n    &#125; else &#123;\n      let ar;\n      let i;\n      loop(data, dropKey, (item, index, arr) &#x3D;&gt; &#123;\n        ar &#x3D; arr;\n        i &#x3D; index;\n      &#125;);\n      if (dropPosition &#x3D;&#x3D;&#x3D; -1) &#123;\n        ar.splice(i, 0, dragObj);\n      &#125; else &#123;\n        ar.splice(i + 1, 0, dragObj);\n      &#125;\n    &#125;\n\n    this.setState(&#123;\n      gData: data,\n    &#125;);\n  &#125;;</code></pre>\n\n<p>作者：黎明的叶子<br>链接：<a href=\"https://www.jianshu.com/p/0e8bf11cd2dc\">https://www.jianshu.com/p/0e8bf11cd2dc</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.jianshu.com/p/0e8bf11cd2dc\" target=\"_blank\" >ant-design拖动属性dropToGap,dropPosition</a></p>\n","text":"属性解释dropToGap：boolean类型，true代表拖拽到节点之间的缝隙中，false代表拖拽到节点上，即节点的内容区。dropPosition：拖拽的时候，针对一个节点有三种情况，即拖拽到节点之上，拖拽到节点上，拖拽到节点之下。 三种情况其值有所不同。antd 依赖了 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">属性解释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E8%A7%A3\"><span class=\"toc-text\">图解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">官方代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React 源码解析收录","uid":"a6739a5e648fed592221272a951b5783","slug":"2022-10-10react-link","date":"2022-10-10T05:39:46.000Z","updated":"2023-03-09T15:11:24.965Z","comments":true,"path":"api/articles/2022-10-10react-link.json","keywords":null,"cover":[],"text":"收录链接 1 React17 源码解析(开篇) —— 搭建 react 源码调试环境 React17 源码解析(1) —— 源码目录及 react 架构 React17 源码解析(2) —— jsx 转换及 React.createElement React17 源码解析(3) ...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"tailwindcss","uid":"853c3aaf44fd16a1c74c495f59970a3a","slug":"2022-10-09tailwindcss","date":"2022-10-09T08:30:51.000Z","updated":"2022-10-25T12:09:37.230Z","comments":true,"path":"api/articles/2022-10-09tailwindcss.json","keywords":null,"cover":[],"text":"https://github.com/tailwindlabs/tailwindcss CSS 发展第一个阶段，原生写法 是类似于编程中面向过程的写法，需要什么样式，自己在 css 中写什么样式。对代码有洁癖的程序员会进行简单的 css 复用。但是也只是简单的复用，大多数时候还是...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":6,"path":"api/tags/前端.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}