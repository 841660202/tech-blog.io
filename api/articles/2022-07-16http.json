{"title":"前端基础-http","uid":"2467747971f59a01619a9d5abd6f99a3","slug":"2022-07-16http","date":"2022-07-16T04:47:18.000Z","updated":"2022-07-16T13:06:23.539Z","comments":true,"path":"api/articles/2022-07-16http.json","keywords":null,"cover":[],"content":"<h2 id=\"HTTP-⽅法\"><a href=\"#HTTP-⽅法\" class=\"headerlink\" title=\"HTTP ⽅法\"></a>HTTP ⽅法</h2><p><code>HTTP1.0</code> 定义了三种请求⽅法： <code>GET</code>, <code>POST</code> 和 <code>HEAD</code> ⽅法<br><code>HTTP1.1</code> 新增了五种请求⽅法：<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code></p>\n<h2 id=\"HTTP-⽅法的理论作⽤\"><a href=\"#HTTP-⽅法的理论作⽤\" class=\"headerlink\" title=\"HTTP ⽅法的理论作⽤\"></a>HTTP ⽅法的理论作⽤</h2><ul>\n<li><code>GET</code>: 通常⽤于请求服务器发送某些资源</li>\n<li><code>HEAD</code>: 请求资源的头部信息, <code>使⽤场景</code>是<code>在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</code></li>\n<li><code>OPTIONS</code>: ⽤于获取⽬的资源所⽀持的通信选项</li>\n<li><code>POST</code>: 发送数据给服务器</li>\n<li><code>PUT</code>: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式</li>\n<li><code>DELETE</code>: ⽤于删除指定的资源</li>\n<li><code>PATCH</code>: ⽤于对资源进⾏部分修改</li>\n<li><code>CONNECT</code>: HTTP&#x2F;1.1 协议中预留给能够将连接改为管道⽅式的代理服务器</li>\n<li><code>TRACE</code>: 回显服务器收到的请求，主要⽤于测试或诊断</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><p>理论上是这么回事，可有些研发并不一定这么操作</p>\n</p>\n</div>\n<h2 id=\"GET-和-POST-有什么区别？\"><a href=\"#GET-和-POST-有什么区别？\" class=\"headerlink\" title=\"GET 和 POST 有什么区别？\"></a>GET 和 POST 有什么区别？</h2><ul>\n<li><code>数据传输⽅式不同</code>：GET 请求通过 URL 传输数据，⽽ POST 的数据通过请求体传输。</li>\n<li><code>安全性不同</code>：POST 的数据因为在请求主体内，所以有⼀定的安全性保证，⽽ GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息。</li>\n<li><code>数据类型不同</code>：GET 只允许 ASCII 字符，⽽ POST ⽆限制 GET ⽆害： 刷新、后退等浏览器操作 GET 请求是⽆害的，POST 可能重复提交表单</li>\n<li><code>特性不同</code>：GET 是安全（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化）且幂等（幂等的 概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同），⽽ POST 是⾮安全⾮幂等</li>\n</ul>\n<h2 id=\"PUT-和-POST-有什么区别？\"><a href=\"#PUT-和-POST-有什么区别？\" class=\"headerlink\" title=\"PUT 和 POST 有什么区别？\"></a>PUT 和 POST 有什么区别？</h2><ul>\n<li><p>PUT ⽅法是<code>幂等</code>的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽ POST ⽅法是⾮幂 等的。</p>\n</li>\n<li><p>PUT 的 <code>URI 指向是具体单⼀资源</code>，⽽ POST 可以指向资源集合。</p>\n</li>\n</ul>\n<p>举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤</p>\n<ul>\n<li><p>POST <a href=\"https://www.jianshu.com/articles\">https://www.jianshu.com/articles</a> ， 这个请求的语义是，在 articles 的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。</p>\n<br/>\n<br/>\n</li>\n<li><p>PUT <a href=\"https://www.jianshu.com/articles/1\">https://www.jianshu.com/articles/1</a> 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI 指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘华』修改成『刘德华』，提交多少次都是修改成『刘德华』</p>\n</li>\n</ul>\n<h2 id=\"PUT-和-PATCH-的区别？\"><a href=\"#PUT-和-PATCH-的区别？\" class=\"headerlink\" title=\"PUT 和 PATCH 的区别？\"></a>PUT 和 PATCH 的区别？</h2><p><code>PUT</code> 和 <code>PATCH</code> 都是更新资源，⽽ <code>PATCH</code> ⽤来对已知资源进⾏局部更新。<code>PATCH</code>可以理解为打补丁<br>⽐如我们有⼀篇⽂章的地址 <a href=\"https://www.jianshu.com/articles/1\">https://www.jianshu.com/articles/1</a> ,这篇⽂章的可以表示为:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">article &#x3D; &#123;\n  author: &quot;dxy&quot;,\n  creationDate: &quot;2019-6-12&quot;,\n  content: &quot;我写⽂章像刘德华&quot;,\n  id: 1,\n&#125;;</code></pre>\n\n<p>当我们要修改⽂章的作者时，我们可以直接发送</p>\n<p><code>PUT https://www.jianshu.com/articles/1</code> ，数据是:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#123;\n  author:&#39;刘德华&#39;,\n  creationDate: &#39;2019-6-12&#39;,\n  content: &#39;我写⽂章像刘德华&#39;,\n  id: 1\n&#125;\n</code></pre>\n\n<p>这种直接覆盖资源的修改⽅式应该⽤ put，但是你觉得每次都带有这么多⽆⽤的信息，那么可以发送</p>\n<p><code>PATCH https://www.jianshu.com/articles/1</code> ，这个时候只需要:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#123; author:&#39;刘德华&#39;, &#125;</code></pre>\n\n<h2 id=\"HTTP-的状态码有哪些？\"><a href=\"#HTTP-的状态码有哪些？\" class=\"headerlink\" title=\"HTTP 的状态码有哪些？\"></a>HTTP 的状态码有哪些？</h2><ul>\n<li><code>101 SwitchingProtocols</code>，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议(<code>h5的websocket使用时，会出现101状态码</code>)</li>\n</ul>\n<p><strong>2XX 成功</strong></p>\n<ul>\n<li><code>200 OK</code>，表示从客户端发来的请求在服务器端被正确处理</li>\n<li><code>201 Created</code> 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴</li>\n<li><code>202 Accepted</code> 请求已接受，但是还没执⾏，不保证完成请求</li>\n<li><code>204 No content</code>，表示请求成功，但响应报⽂不含实体的主体部分 客户端不做更改(<code>浏览器不会刷新页面，也不会导向别的页面。对客户端说好了，你别管了</code>)</li>\n<li><code>206 Partial Content</code>，进⾏范围请求</li>\n</ul>\n<p><strong>3XX 重定向</strong></p>\n<ul>\n<li><code>301 moved permanently</code>，永久性重定向，表示资源已被分配了新的 URL</li>\n<li><code>302 found</code>，临时性重定向，表示资源临时被分配了新的 URL</li>\n<li><code>303 see other</code>，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源</li>\n<li><code>304 not modified</code>，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况</li>\n<li><code>307 temporary redirect</code>，临时重定向，和 302 含义相同</li>\n</ul>\n<p><strong>4XX 客户端错误</strong></p>\n<ul>\n<li><code>400 bad request</code>，请求报⽂存在语法错误</li>\n<li><code>401 unauthorized</code>，表示发送的请求需要有通过 HTTP 认证的认证信息</li>\n<li><code>403 forbidden</code>，表示对请求资源的访问被服务器拒绝</li>\n<li><code>404 not found</code>，表示在服务器上没有找到请求的资源</li>\n<li><code>408 Request timeout</code>, 客户端请求超时</li>\n<li><code>409 Confict</code>, 请求的资源可能引起冲突</li>\n</ul>\n<p><strong>5XX 服务器错误</strong></p>\n<ul>\n<li><code>500 internal sever error</code>，表示服务器端在执⾏请求时发⽣了错误</li>\n<li><code>501 Not Implemented</code> 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务 器不⽀持的某个⽅法</li>\n<li><code>502 BadGateway</code> 网关错误</li>\n<li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</li>\n<li><code>504 Gateway timeout</code> 网关超时</li>\n<li><code>505 http version not supported</code> 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</li>\n</ul>\n<h2 id=\"302-307-303-的区别？\"><a href=\"#302-307-303-的区别？\" class=\"headerlink\" title=\"302,307,303 的区别？\"></a>302,307,303 的区别？</h2><ul>\n<li><code>302</code> 是 http1.0 的协议状态码，在<code>http1.1版本</code>的时候为了细化<code>302</code>状态码⼜出来了两个<code>303</code>和<code>307</code>。</li>\n<li><code>303</code> 明确表示客户端应当<code>采⽤get⽅法获取资源</code>，<code>会把POST请求变为GET请求进⾏重定向</code>。</li>\n<li><code>307</code> 会遵照浏览器标准， 不会从 post 变为 get。</li>\n</ul>\n<h2 id=\"HTTP-的-keep-alive-是⼲什么的？\"><a href=\"#HTTP-的-keep-alive-是⼲什么的？\" class=\"headerlink\" title=\"HTTP 的 keep-alive 是⼲什么的？\"></a>HTTP 的 keep-alive 是⼲什么的？</h2><p>在早期的 HTTP&#x2F;1.0 中，每次 http 请求都要创建⼀个连接，⽽创建连接的过程需要消耗资源和时间，<code>为了减少资源消耗， 缩短响应时间，就需要重⽤连接</code>。<br>在后来的 HTTP&#x2F;1.0 中以及 HTTP&#x2F;1.1 中，引⼊了重⽤连接的机制，就是在 <code>http 请求头中</code>加⼊ <code>Connection: keep-alive</code> 来告诉对⽅这个请求响应完成后不要关闭，下⼀次咱们还⽤这个请求继续交流。</p>\n<p>HTTP&#x2F;1.0 如果想要保持⻓连接，需要在请求头中加上 <code>Connection: keep-alive</code>。</p>\n<h2 id=\"keep-alive-的优点：\"><a href=\"#keep-alive-的优点：\" class=\"headerlink\" title=\"keep-alive 的优点：\"></a>keep-alive 的优点：</h2><ul>\n<li>较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）</li>\n<li>降低拥塞控制 （TCP 连接减少了）</li>\n<li>减少了后续请求的延迟（⽆需再进⾏握⼿）</li>\n<li>报告错误⽆需关闭 TCP 连</li>\n<li>允许请求和应答的 HTTP <code>管线化</code>(将多个 HTTP 请求（request）整批提交的技术，而在发送过程中不需先等待伺服端的回应)</li>\n</ul>\n<h2 id=\"为什么有了-HTTP-为什么还要-HTTPS？\"><a href=\"#为什么有了-HTTP-为什么还要-HTTPS？\" class=\"headerlink\" title=\"为什么有了 HTTP 为什么还要 HTTPS？\"></a>为什么有了 HTTP 为什么还要 HTTPS？</h2><p>https 是安全版的 http，因为 http 协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS 就 是为了解决 HTTP 的不安全⽽⽣的。</p>\n<h2 id=\"HTTPS-是如何保证安全的？\"><a href=\"#HTTPS-是如何保证安全的？\" class=\"headerlink\" title=\"HTTPS 是如何保证安全的？\"></a>HTTPS 是如何保证安全的？</h2><p>过程⽐较复杂: <code>对称加密</code>、<code>非对称加密</code>、<code>中间人</code>、<code>CA证书</code>、<code>数字签名</code></p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。</p>\n<h3 id=\"⾮对称加密\"><a href=\"#⾮对称加密\" class=\"headerlink\" title=\"⾮对称加密\"></a>⾮对称加密</h3><ol>\n<li>私钥 + 公钥&#x3D; 密钥对</li>\n<li>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</li>\n<li>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</li>\n<li>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</li>\n</ol>\n<p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p>\n<p>解决⽅案：</p>\n<p>那么结合两种加密⽅式，将<code>对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去</code>，<code>接收⽅使⽤私钥进⾏解密 得到对称加密的密钥</code>，然后双⽅可以使⽤对称加密来进⾏沟通。</p>\n<h3 id=\"中间⼈\"><a href=\"#中间⼈\" class=\"headerlink\" title=\"中间⼈\"></a>中间⼈</h3><p>此时⼜带来⼀个问题，<code>中间⼈</code>问题：</p>\n<p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。(<code>偷换</code>)</p>\n<h3 id=\"CA-证书\"><a href=\"#CA-证书\" class=\"headerlink\" title=\"CA 证书\"></a>CA 证书</h3><p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。</p>\n<p>证书中包括：<code>签发者</code>、<code>证书⽤途</code>、<code>使⽤者公钥</code>、<code>使⽤者私钥</code>、<code>使⽤者的 HASH 算法</code>、<code>证书到期时间</code>等</p>\n<p>类似一个驾驶证：<code>签发机构</code>、<code>驾驶车辆型号</code>、<code>使用者信息</code>、<code>证件有效期</code></p>\n<h3 id=\"证书篡改\"><a href=\"#证书篡改\" class=\"headerlink\" title=\"证书篡改\"></a>证书篡改</h3><p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，<code>数字签名</code>。</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名: 就是⽤ CA ⾃带的 HASH 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。 这个时候就能最⼤程度保证通信的安全了。</p>\n<h2 id=\"HTTP2-特点？\"><a href=\"#HTTP2-特点？\" class=\"headerlink\" title=\"HTTP2 特点？\"></a>HTTP2 特点？</h2><ul>\n<li><code>二进制分帧</code></li>\n<li><code>头部压缩</code></li>\n<li><code>服务端推送</code></li>\n<li><code>多路复用</code></li>\n</ul>\n<p>:::details 点击查看更多</p>\n<p><strong>⼆进制分帧</strong></p>\n<ul>\n<li><code>帧</code>：HTTP&#x2F;2 数据通信的最⼩单位</li>\n<li><code>消息</code>：指 HTTP&#x2F;2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由⼀个或多个帧 组成。</li>\n<li><code>流</code>：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数 ID HTTP&#x2F;2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，<code>⼆进制协议解析起来更⾼效</code>。</li>\n</ul>\n<p><strong>头部压缩</strong></p>\n<p>HTTP&#x2F;1.x 会在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。 HTTP&#x2F;2 在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 ⾸部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 你可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量</p>\n<p><strong>服务器推送</strong></p>\n<p>服务端可以在发送⻚⾯ HTML 时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。</p>\n<p>场景:</p>\n<p>例如服务端 可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端。</p>\n<p><strong>多路复⽤</strong></p>\n<p>HTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 <code>6-8</code> 个的 TCP 链接请求限制。<br>HTTP2 中： <code>同域名下所有通信都在单个连接上完成</code>。 <code>单个连接可以承载任意数量的双向数据流</code>。 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可以重新组装</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220716210046.png\" />\n:::\n\n<h2 id=\"HTTP3-特点？\"><a href=\"#HTTP3-特点？\" class=\"headerlink\" title=\"HTTP3 特点？\"></a>HTTP3 特点？</h2><ul>\n<li><code>队头阻塞</code>： 有序字节流引出的<code>队头阻塞</code>（Head-of-line blocking），使得 HTTP2 的多路复用能力大打折扣；</li>\n<li><code>握手延迟</code>：<code>TCP 与 TLS 叠加了握手时延</code>，建链时长还有 1 倍的下降空间；</li>\n<li><code>移动成本高</code>：基于 TCP 四元组确定一个连接，这种诞生于有线网络的设计，<code>并不适合移动状态下的无线网络</code>，这意味着 IP 地址的频繁变动会导致 TCP 连接、TLS 会话反复握手，成本高昂。</li>\n</ul>\n<h2 id=\"HTTP3-协议解决了这些问题：\"><a href=\"#HTTP3-协议解决了这些问题：\" class=\"headerlink\" title=\"HTTP3 协议解决了这些问题：\"></a>HTTP3 协议解决了这些问题：</h2><ul>\n<li><code>队头阻塞</code>：HTTP3 基于 UDP 协议重新定义了连接，在 QUIC 层实现了无序、并发字节流的传输，解决了<code>队头阻塞问题</code>（包括基于 QPACK 解决了动态表的队头阻塞）；</li>\n<li><code>握手延迟</code>：HTTP3 重新定义了 TLS 协议加密 QUIC 头部的方式，<code>既提高了网络攻击成本，又降低了建立连接的速度</code>（仅需 1 个 RTT 就可以同时完成建链与密钥协商）；</li>\n<li><code>移动成本高</code>： HTTP3 将 Packet、QUIC Frame、HTTP3 Frame 分离，实现了连接迁移功能，<code>降低了 5G 环境下高速移动设备的连接维护成本</code>。</li>\n</ul>\n<h2 id=\"HTTP-的缓存的过程\"><a href=\"#HTTP-的缓存的过程\" class=\"headerlink\" title=\"HTTP 的缓存的过程\"></a>HTTP 的缓存的过程</h2><p>通常情况下的步骤是:</p>\n<ol>\n<li>客户端向服务器发出请求，请求资源</li>\n<li>服务器返回资源，并通过响应头决定缓存策略</li>\n<li>客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来</li>\n<li>在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断 是直接读取本地缓存还是与服务器协商缓存</li>\n</ol>\n<h2 id=\"强缓存-x2F-协商缓存\"><a href=\"#强缓存-x2F-协商缓存\" class=\"headerlink\" title=\"强缓存&#x2F;协商缓存\"></a>强缓存&#x2F;协商缓存</h2><h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>强缓存离不开两个响应头 <code>Expires</code> 与 <code>Cache-Control</code></p>\n<p><strong>Expires：</strong></p>\n<p>Expires 是 http1.0 提出的⼀个表示资源过期时间的 header，<code>它描述的是⼀个绝对时间</code>，由服务器返回， Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>\n<p>Expires:<code>Wed, 11 May 2018 07:20:00 GMT</code> GMT 时间戳</p>\n<p><strong>Cache-Control:</strong></p>\n<p>Cache-Control 出现于 HTTP &#x2F; 1.1，优先级⾼于 Expires ,<code>表示的是相对时间</code></p>\n<p>Cache-Control: <code>max-age=315360000</code></p>\n<p>⽬前主流的做法使⽤ Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有：</p>\n<p>Cache-Control: <code>public </code>可以被所有⽤户缓存，<code>允许终端和 CDN 等中间代理服务器</code><br>Cache-Control: <code>private</code> 只能被终端浏览器缓存，<code>不允许中继缓存服务器进⾏缓存</code><br>Cache-Control: <code>no-cache</code>,<code>先缓存本地,要验证</code>，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤<br>Cache-Control: <code>no-store</code>，<code>不会产⽣任何缓存</code></p>\n<p>在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商。</p>\n<p>服务器判断缓存是否是新鲜的⽅法就是依靠 HTTP 的另外两组信息</p>\n<h2 id=\"Last-Modified-x2F-If-Modified-Since\"><a href=\"#Last-Modified-x2F-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h2><p>客户端⾸次请求资源时，服务器会把资源的最新修改时间</p>\n<p><code>Last-Modified:Thu, 19 Feb 2019 08:20:55 GMT</code> 通过响应部⾸发送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头</p>\n<p><code>If-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT</code> 发送给服务器，服务器再跟服务器上的对应资源进⾏⽐对，</p>\n<p>如果服务器的资源更新，那么返回最新的资源，此时状态码 200，<br>当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回 304 状态码， 表示客户端直接⽤缓存即可。</p>\n<h2 id=\"ETag-x2F-If-None-Match\"><a href=\"#ETag-x2F-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h2><p>ETag 的流程跟 Last-Modified 是类似的，区别就在于 ETag 是<code>根据资源内容进⾏ hash，⽣成⼀个信息摘要</code>，只要资源内容有变化，这个摘要就会发⽣巨变，通过这个摘要信息⽐对，即可确定客户端的缓存资源是否为最新，<code>⽐ Last-Modified 的精确度要更⾼</code>。 响应头</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220716205210.png\" />\n\n<p>整体的缓存流程图如下：</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220716205325.png\" style=\"max-width:400px\"/>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/431672713\" target=\"_blank\" >深入剖析 HTTP3 协议</a></p>\n","text":"HTTP ⽅法HTTP1.0 定义了三种请求⽅法： GET, POST 和 HEAD ⽅法HTTP1.1 新增了五种请求⽅法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT HTTP ⽅法的理论作⽤ GET: 通常⽤于请求服务器发送某些资源 HEAD:...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":17,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":19,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":14,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E2%BD%85%E6%B3%95\"><span class=\"toc-text\">HTTP ⽅法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E2%BD%85%E6%B3%95%E7%9A%84%E7%90%86%E8%AE%BA%E4%BD%9C%E2%BD%A4\"><span class=\"toc-text\">HTTP ⽅法的理论作⽤</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">GET 和 POST 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PUT-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">PUT 和 POST 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PUT-%E5%92%8C-PATCH-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">PUT 和 PATCH 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">HTTP 的状态码有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#302-307-303-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">302,307,303 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%9A%84-keep-alive-%E6%98%AF%E2%BC%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTP 的 keep-alive 是⼲什么的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#keep-alive-%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">keep-alive 的优点：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86-HTTP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81-HTTPS%EF%BC%9F\"><span class=\"toc-text\">为什么有了 HTTP 为什么还要 HTTPS？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTPS 是如何保证安全的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">对称加密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%BE%AE%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">⾮对称加密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E2%BC%88\"><span class=\"toc-text\">中间⼈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CA-%E8%AF%81%E4%B9%A6\"><span class=\"toc-text\">CA 证书</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%81%E4%B9%A6%E7%AF%A1%E6%94%B9\"><span class=\"toc-text\">证书篡改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">数字签名</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP2-%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">HTTP2 特点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP3-%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">HTTP3 特点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP3-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%86%B3%E4%BA%86%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">HTTP3 协议解决了这些问题：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%9A%84%E7%BC%93%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">HTTP 的缓存的过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E7%BC%93%E5%AD%98-x2F-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">强缓存&#x2F;协商缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">强缓存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Last-Modified-x2F-If-Modified-Since\"><span class=\"toc-text\">Last-Modified&#x2F;If-Modified-Since</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ETag-x2F-If-None-Match\"><span class=\"toc-text\">ETag&#x2F;If-None-Match</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-html","uid":"2854d1d5923e1e62aed568f709662bf4","slug":"2022-07-17html","date":"2022-07-17T01:44:42.000Z","updated":"2022-07-17T07:31:50.506Z","comments":true,"path":"api/articles/2022-07-17html.json","keywords":null,"cover":[],"text":"doctype 的作⽤是什么？DOCTYPE 是 html5 标准⽹⻚声明，且必须声明在 HTML ⽂档的第⼀⾏。 来告知浏览器的解析器⽤什么⽂档标准解析这个⽂档，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析 ⽂档解析类型有： BackCo...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":17,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":19,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":14,"path":"api/tags/面试.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-TCP","uid":"ca603a006bae6531fc585f1adf1fac4c","slug":"2022-07-15TCP","date":"2022-07-15T07:23:46.000Z","updated":"2022-07-16T04:40:46.986Z","comments":true,"path":"api/articles/2022-07-15TCP.json","keywords":null,"cover":[],"text":"TCP 的特性 TCP 提供⼀种⾯向连接的、 可靠的、字节流 服务 在⼀个 TCP 连接中，仅双⽅进⾏彼此通信。⼴播和多播不能⽤于 TCP TCP 使⽤校验、确认和重传机制来保证可靠传输 TCP 给数据分节进⾏排序，并使⽤累积确认保证数据的顺序不变和⾮重复 TCP 使⽤滑动窗⼝机...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":17,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":19,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":14,"path":"api/tags/面试.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}