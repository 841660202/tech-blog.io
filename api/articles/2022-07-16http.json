{"title":"前端基础-http","uid":"2467747971f59a01619a9d5abd6f99a3","slug":"2022-07-16http","date":"2022-07-16T04:47:18.000Z","updated":"2023-08-04T07:58:19.218Z","comments":true,"path":"api/articles/2022-07-16http.json","keywords":null,"cover":[],"content":"<h2 id=\"HTTP-⽅法\"><a href=\"#HTTP-⽅法\" class=\"headerlink\" title=\"HTTP ⽅法\"></a>HTTP ⽅法</h2><p><code>HTTP1.0</code> 定义了三种请求⽅法： <code>GET</code>, <code>POST</code> 和 <code>HEAD</code> ⽅法<br><code>HTTP1.1</code> 新增了五种请求⽅法：<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code></p>\n<h2 id=\"HTTP-⽅法的理论作⽤\"><a href=\"#HTTP-⽅法的理论作⽤\" class=\"headerlink\" title=\"HTTP ⽅法的理论作⽤\"></a>HTTP ⽅法的理论作⽤</h2><ol>\n<li><code>GET</code>: 通常⽤于请求服务器发送某些资源</li>\n<li><code>POST</code>: 发送数据给服务器</li>\n<li><code>PUT</code>: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式</li>\n<li><code>PATCH</code>: ⽤于对资源进⾏部分修改</li>\n<li><code>DELETE</code>: ⽤于删除指定的资源</li>\n<li><code>HEAD</code>: 请求资源的头部信息, <code>使⽤场景</code>是<code>在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</code></li>\n<li><code>OPTIONS</code>: ⽤于获取⽬的资源所⽀持的通信选项 <span style=\"color: red\">（在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。浏览器自动发起）</span></li>\n<li><code>TRACE</code>: 回显服务器收到的请求，主要⽤于测试或诊断</li>\n<li><code>CONNECT</code>: HTTP&#x2F;1.1 协议中预留给能够将连接改为管道⽅式的代理服务器</li>\n</ol>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><p>理论上是这么回事，可有些研发并不一定这么操作</p>\n<p>这些方法是约定</p>\n<p>是的，这些 HTTP 方法都是在 HTTP 协议中约定的，用于表示客户端请求的不同操作。HTTP 协议规定了客户端可以使用哪些方法，以及这些方法在服务器上应该如何处理。例如，GET 方法表示请求获取资源，而 POST 方法表示提交数据到服务器进行处理。<strong>这些方法的约定是为了使客户端和服务器之间的通信更加明确和标准化</strong>。</p>\n</p>\n</div>\n<h2 id=\"GET-和-POST-有什么区别？\"><a href=\"#GET-和-POST-有什么区别？\" class=\"headerlink\" title=\"GET 和 POST 有什么区别？\"></a>GET 和 POST 有什么区别？</h2><p><strong>浏览器</strong></p>\n<ol>\n<li><code>收藏标签</code> GET 请求可以收藏为书签，POST 请求不可以收藏为书签；</li>\n<li><code>重新提交无害</code> GET 请求在浏览器回退和刷新时是无害的，而 POST 请求会告知用户数据会被重新提交；</li>\n<li><code>请求缓存</code> GET 请求可以被缓存，POST 请求不可以被缓存，除非在响应头中包含合适的 Cache-Control&#x2F;Expires 字段，但是不建议缓存 POST 请求，其不满足幂等性，每次调用都会对服务器资源造成影响；</li>\n</ol>\n<p><strong>请求特点</strong></p>\n<ol>\n<li><code>安全性</code>GET 请求的安全性较差，数据被暴露在浏览器的 URL 中，所以不能用来传递敏感信息，POST 请求的安全性较好，数据不会暴露在 URL 中；</li>\n<li><code>幂等性</code> GET 请求具有幂等性(多次请求不会对资源造成影响)，POST 请求不幂等；</li>\n<li><code>长度限制</code>GET 请求因为是向 URL 添加数据，不同的浏览器厂商，代理服务器，web 服务器都可能会有自己的长度限制，而 POST 请求无长度限制；</li>\n<li><code>参数缓存</code>GET 请求的参数可以被保留在浏览器的历史中，POST 请求不会被保留；</li>\n<li><code>数据类型不同</code> GET 请求<code>只允许 ASCII 字符</code>，POST <code>请求无限制，支持二进制数据</code>；</li>\n<li><code>数据传输⽅式不同</code>GET <code>请求一般不具有请求体，因此只能进行 url 编码</code>，而 POST <code>请求支持多种编码方式</code>。</li>\n</ol>\n<h2 id=\"PUT-和-POST-有什么区别？\"><a href=\"#PUT-和-POST-有什么区别？\" class=\"headerlink\" title=\"PUT 和 POST 有什么区别？\"></a>PUT 和 POST 有什么区别？</h2><ol>\n<li><code>幂等</code> PUT ⽅法是<code>幂等</code>的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽ POST ⽅法是⾮幂 等的。</li>\n<li><code>单一资源</code> PUT 的 <code>URI 指向是具体单⼀资源</code>，⽽ POST 可以指向资源集合。</li>\n</ol>\n<p>举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤</p>\n<ol>\n<li>POST <a href=\"https://www.jianshu.com/articles\">https://www.jianshu.com/articles</a> ， 这个请求的语义是，在 articles 的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。</li>\n<li>PUT <a href=\"https://www.jianshu.com/articles/1\">https://www.jianshu.com/articles/1</a> 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI 指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘华』修改成『刘德华』，提交多少次都是修改成『刘德华』</li>\n</ol>\n<h2 id=\"PUT-和-PATCH-的区别？\"><a href=\"#PUT-和-PATCH-的区别？\" class=\"headerlink\" title=\"PUT 和 PATCH 的区别？\"></a>PUT 和 PATCH 的区别？</h2><ol>\n<li><code>PUT</code> 和 <code>PATCH</code> 都是更新资源，</li>\n<li>⽽ <code>PATCH</code> ⽤来对已知资源进⾏局部更新，<code>PATCH</code>可以理解为打补丁</li>\n</ol>\n<p>⽐如我们有⼀篇⽂章的地址 <a href=\"https://www.jianshu.com/articles/1\">https://www.jianshu.com/articles/1</a> ,这篇⽂章的可以表示为:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">article &#x3D; &#123;\n  author: &#39;dxy&#39;,\n  creationDate: &#39;2019-6-12&#39;,\n  content: &#39;我写⽂章像刘德华&#39;,\n  id: 1,\n&#125;;</code></pre>\n\n<p>当我们要修改⽂章的作者时，我们可以直接发送</p>\n<p><code>PUT https://www.jianshu.com/articles/1</code> ，数据是:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;\n  author:&#39;刘德华&#39;,\n  creationDate: &#39;2019-6-12&#39;,\n  content: &#39;我写⽂章像刘德华&#39;,\n  id: 1\n&#125;\n</code></pre>\n\n<p>这种直接覆盖资源的修改⽅式应该⽤ put，但是你觉得每次都带有这么多⽆⽤的信息，那么可以发送</p>\n<p><code>PATCH https://www.jianshu.com/articles/1</code> ，这个时候只需要:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123; author:&#39;刘德华&#39;, &#125;</code></pre>\n\n<h2 id=\"HTTP-的状态码有哪些？\"><a href=\"#HTTP-的状态码有哪些？\" class=\"headerlink\" title=\"HTTP 的状态码有哪些？\"></a>HTTP 的状态码有哪些？</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100\" target=\"_blank\" >Web 开发技术&gt;HTTP&gt;HTTP 响应状态码</a></p>\n<ul>\n<li><code>100 Continue</code>,信息型状态响应码表示目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略</li>\n<li><code>101 SwitchingProtocols</code>，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议(<code>h5的websocket使用时，会出现101状态码</code>)</li>\n<li><code>103 Early Hints</code>,信息状态响应码，一般和 Link header（首部）一起使用，来允许用户在服务器还在准备响应数据的时候预加载一些资源。</li>\n</ul>\n<p><strong>2XX 成功</strong></p>\n<ul>\n<li><code>200 OK</code>，表示从客户端发来的请求在服务器端被正确处理</li>\n<li><code>201 Created</code> 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴</li>\n<li><code>202 Accepted</code> 请求已接受，但是还没执⾏，不保证完成请求</li>\n<li><code>204 No content</code>，表示请求成功，但响应报⽂不含实体的主体部分 客户端不做更改(<code>浏览器不会刷新页面，也不会导向别的页面。对客户端说好了，你别管了</code>)</li>\n<li><code>206 Partial Content</code>，进⾏范围请求 <span style=\"color: red\">B 站视频播放时候会发起请求</span></li>\n</ul>\n<p><strong>3XX 重定向</strong></p>\n<ul>\n<li><code>301 moved permanently</code>，永久性重定向，表示资源已被分配了新的 URL</li>\n<li><code>302 found</code>，临时性重定向，表示资源临时被分配了新的 URL</li>\n<li><code>303 see other</code>，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源</li>\n<li><code>304 not modified</code>，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况</li>\n<li><code>307 temporary redirect</code>，临时重定向，和 302 含义相同</li>\n</ul>\n<p><strong>4XX 客户端错误</strong></p>\n<ul>\n<li><code>400 bad request</code>，请求报⽂存在语法错误</li>\n<li><code>401 unauthorized</code>，表示发送的请求需要有通过 HTTP 认证的认证信息</li>\n<li><code>403 forbidden</code>，表示对请求资源的访问被服务器拒绝</li>\n<li><code>404 not found</code>，表示在服务器上没有找到请求的资源</li>\n<li><code>408 Request timeout</code>, 客户端请求超时</li>\n<li><code>409 Confict</code>, 请求的资源可能引起冲突</li>\n</ul>\n<p><strong>5XX 服务器错误</strong></p>\n<ul>\n<li><code>500 internal sever error</code>，表示服务器端在执⾏请求时发⽣了错误</li>\n<li><code>501 Not Implemented</code> 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务器不⽀持的某个⽅法</li>\n<li><code>502 Bad Gateway</code> 网关错误</li>\n<li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</li>\n<li><code>504 Gateway timeout</code> 网关超时</li>\n<li><code>505 http version not supported</code> 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</li>\n</ul>\n<p>后台一个服务器挂了，重启后正常<br><img src=\"http://t-blog-images.aijs.top/img/20220718135425.webp\" /></p>\n<h2 id=\"302-307-303-的区别？\"><a href=\"#302-307-303-的区别？\" class=\"headerlink\" title=\"302,307,303 的区别？\"></a>302,307,303 的区别？</h2><ul>\n<li><code>302</code> 是 http1.0 的协议状态码，在<code>http1.1版本</code>的时候为了细化<code>302</code>状态码⼜出来了两个<code>303</code>和<code>307</code>。</li>\n<li><code>303</code> 明确表示客户端应当<code>采⽤get⽅法获取资源</code>，<code>会把POST请求变为GET请求进⾏重定向</code>。</li>\n<li><code>307</code> 会遵照浏览器标准， 不会从 post 变为 get。</li>\n</ul>\n<p><span style=\"color: red\">详细内容见下文，HTTP 状态码目录</span></p>\n<h2 id=\"API-网关是什么\"><a href=\"#API-网关是什么\" class=\"headerlink\" title=\"API 网关是什么\"></a>API 网关是什么</h2><p><a href=\"https://www.cnblogs.com/konglxblog/p/15170636.html\" target=\"_blank\" ><code>API 网关</code></a></p>\n<p>是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而 <em>安全、性能、监控</em> 可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性</p>\n<p><a href=\"https://github.com/Kong/kong\" target=\"_blank\" >Kong 网关</a></p>\n<h2 id=\"HTTP-的-keep-alive-是⼲什么的？\"><a href=\"#HTTP-的-keep-alive-是⼲什么的？\" class=\"headerlink\" title=\"HTTP 的 keep-alive 是⼲什么的？\"></a>HTTP 的 keep-alive 是⼲什么的？</h2><p>在早期的 HTTP&#x2F;1.0 中，每次 http 请求都要创建⼀个连接，⽽创建连接的过程需要消耗资源和时间，<code>为了减少资源消耗， 缩短响应时间，需要重⽤连接</code>。</p>\n<p>在后来的 HTTP&#x2F;1.0 中以及 HTTP&#x2F;1.1 中，引⼊了重⽤连接的机制，就是在 <code>http 请求头中</code>加⼊ <code>Connection: keep-alive</code> 来告诉对⽅这个请求响应完成后不要关闭，下⼀次咱们还⽤这个请求继续交流。</p>\n<p>HTTP&#x2F;1.0 如果想要保持⻓连接，需要在请求头中加上 <code>Connection: keep-alive</code>。</p>\n<h2 id=\"keep-alive-是什么，有什么优缺点\"><a href=\"#keep-alive-是什么，有什么优缺点\" class=\"headerlink\" title=\"keep-alive 是什么，有什么优缺点\"></a>keep-alive 是什么，有什么优缺点</h2><p>HTTP Keep-Alive 是一种 HTTP 协议中的连接保持机制，也称为持久连接（persistent connection）或复用连接（reusable connection）。在使用 HTTP Keep-Alive 机制时，客户端和服务器之间的 TCP 连接会保持一段时间不关闭，以便在后续的请求中复用这个连接，从而避免了建立和关闭连接的开销，提高了网络传输的效率。</p>\n<p>HTTP Keep-Alive 机制的优点包括：</p>\n<ol>\n<li><strong>减少连接的建立和关闭开销</strong>，提高传输效率；</li>\n<li>可以在一个 TCP 连接上复用多个 HTTP 请求和响应，<strong>降低网络延迟</strong>；</li>\n<li>可以避免一些负载均衡设备在连接建立和关闭时的干扰；</li>\n<li>支持流式数据传输，可以在响应过程中实时更新数据，提高交互性能。</li>\n</ol>\n<p>HTTP Keep-Alive 机制的缺点包括：</p>\n<ol>\n<li>可能占用服务器的连接资源，如果连接过多可能会导致服务器的负载过高；</li>\n<li>可能会造成一些安全问题，如持久连接的过程中可能会出现未经授权的请求或响应；</li>\n<li>在一些场景下可能会导致一些不稳定性或兼容性问题，如 HTTP Keep-Alive 机制不适用于某些代理服务器或防火墙等网络设备。</li>\n</ol>\n<p>总的来说，HTTP Keep-Alive 机制在网络传输效率和性能方面都具有明显的优势，但在使用时需要考虑到其可能引发的一些安全和兼容性问题。</p>\n<h2 id=\"为什么有了-HTTP-为什么还要-HTTPS？\"><a href=\"#为什么有了-HTTP-为什么还要-HTTPS？\" class=\"headerlink\" title=\"为什么有了 HTTP 为什么还要 HTTPS？\"></a>为什么有了 HTTP 为什么还要 HTTPS？</h2><p>https 是安全版的 http，因为 http 协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS 就 是为了解决 HTTP 的不安全⽽⽣的。</p>\n<h2 id=\"HTTPS-是如何保证安全的？\"><a href=\"#HTTPS-是如何保证安全的？\" class=\"headerlink\" title=\"HTTPS 是如何保证安全的？\"></a>HTTPS 是如何保证安全的？</h2><p>过程⽐较复杂: <code>对称加密</code>、<code>非对称加密</code>、<code>中间人</code>、<code>CA证书</code>、<code>数字签名</code></p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。</p>\n<h3 id=\"⾮对称加密\"><a href=\"#⾮对称加密\" class=\"headerlink\" title=\"⾮对称加密\"></a>⾮对称加密</h3><ol>\n<li>私钥 + 公钥&#x3D; 密钥对</li>\n<li>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</li>\n<li>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</li>\n<li>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</li>\n</ol>\n<p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p>\n<p>解决⽅案：</p>\n<p>那么结合两种加密⽅式，将<code>对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去</code>，<code>接收⽅使⽤私钥进⾏解密 得到对称加密的密钥</code>，然后双⽅可以使⽤对称加密来进⾏沟通。</p>\n<h3 id=\"中间⼈\"><a href=\"#中间⼈\" class=\"headerlink\" title=\"中间⼈\"></a>中间⼈</h3><p>此时⼜带来⼀个问题，<code>中间⼈</code>问题：</p>\n<p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。(<code>偷换</code>)</p>\n<h3 id=\"CA-证书\"><a href=\"#CA-证书\" class=\"headerlink\" title=\"CA 证书\"></a>CA 证书</h3><p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。</p>\n<p>证书中包括：<code>签发者</code>、<code>证书⽤途</code>、<code>使⽤者公钥</code>、<code>使⽤者私钥</code>、<code>使⽤者的 HASH 算法</code>、<code>证书到期时间</code>等</p>\n<p>类似一个驾驶证：<code>签发机构</code>、<code>驾驶车辆型号</code>、<code>使用者信息</code>、<code>证件有效期</code></p>\n<h3 id=\"证书篡改\"><a href=\"#证书篡改\" class=\"headerlink\" title=\"证书篡改\"></a>证书篡改</h3><p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，<code>数字签名</code>。</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名: 就是⽤ CA ⾃带的 HASH 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。 这个时候就能最⼤程度保证通信的安全了。</p>\n<h2 id=\"HTTP2-特点？\"><a href=\"#HTTP2-特点？\" class=\"headerlink\" title=\"HTTP2 特点？\"></a>HTTP2 特点？</h2><ul>\n<li><code>二进制分帧</code>: <code>二进制解析起来更高效</code></li>\n<li><code>头部压缩</code>：<code>在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担</code></li>\n<li><code>服务端推送</code>：<code>不⽤等到浏览器解析到相应位置，发起请求再响应</code></li>\n<li><code>多路复用</code>：<code>同域名下所有通信都在单个连接上完成</code>。 <code>单个连接可以承载任意数量的双向数据流</code></li>\n</ul>\n<details class=\"custom-details\">\n<summary>点击查看更多</summary>\n<p><strong>⼆进制分帧</strong></p>\n<ul>\n<li><code>帧</code>：HTTP&#x2F;2 数据通信的最⼩单位</li>\n<li><code>消息</code>：指 HTTP&#x2F;2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由⼀个或多个帧 组成。</li>\n<li><code>流</code>：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数 ID HTTP&#x2F;2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，<code>⼆进制协议解析起来更⾼效</code>。</li>\n</ul>\n<p><strong>头部压缩</strong></p>\n<p>HTTP&#x2F;1.x 会<code>在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。</code></p>\n<p>HTTP&#x2F;2 在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 ⾸部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</p>\n<p>每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 <code>可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量</code></p>\n<p><strong>服务器推送</strong></p>\n<p>服务端可以在发送⻚⾯ HTML 时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。</p>\n<p>场景:</p>\n<p>例如服务端 可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送 <code>RST_STREAM</code> 帧来拒收。<code>主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端</code>。</p>\n<p><strong>多路复⽤</strong></p>\n<p>HTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 <code>6-8</code> 个的 TCP 链接请求限制。<br>HTTP2 中： <code>同域名下所有通信都在单个连接上完成</code>。 <code>单个连接可以承载任意数量的双向数据流</code>。 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可以重新组装</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220716210046.png\" />\n\n\n</details>\n<h2 id=\"HTTP2-的缺点\"><a href=\"#HTTP2-的缺点\" class=\"headerlink\" title=\"HTTP2 的缺点\"></a>HTTP2 的缺点</h2><p>HTTP2 是 HTTP 协议的新一代版本，相对于 HTTP1.1，它带来了许多优点，如多路复用、服务器推送等。但是，HTTP2 也存在一些缺点，主要包括以下几个方面：</p>\n<ol>\n<li><p><code>首字节延迟</code>：虽然 HTTP2 通过多路复用等技术提高了并发性能，但是由于头部压缩等机制的引入，HTTP2 的首字节延迟（Time to First Byte，TTFB）可能会更长。</p>\n</li>\n<li><p><code>资源消耗</code>：HTTP2 使用了更多的资源来处理请求和响应，例如使用 HPACK 算法进行头部压缩，增加了服务器的计算和内存消耗。此外，HTTP2 使用 TLS 加密，会增加一定的 CPU 和内存消耗。</p>\n</li>\n<li><p><code>服务端推送滥用</code>：HTTP2 支持服务器推送，但是如果滥用这个功能，可能会导致性能下降和资源浪费。</p>\n</li>\n<li><p><code>缓存问题</code>：由于 HTTP2 中的请求和响应使用了二进制协议，使得缓存变得更加复杂。与 HTTP1.1 相比，HTTP2 的缓存不再是简单的文本匹配，而是需要进行二进制匹配，这可能会影响缓存效率。</p>\n</li>\n</ol>\n<p>总的来说，HTTP2 在性能和安全方面有很多优点，但也存在一些缺点，需要在实际应用中进行权衡和优化。</p>\n<details class=\"custom-details\">\n<summary>HPACK 算法</summary>\n<p><p><strong>HPACK 算法</strong></p>\n<p>HPACK 是 HTTP&#x2F;2 协议中的一种压缩算法，用于减少 HTTP 请求头的传输大小，从而提高数据传输的效率。HPACK 算法的具体实现过程如下：</p>\n<ol>\n<li><p>通过静态表和动态表来存储请求头字段，其中静态表包含 HTTP 协议中预定义的请求头字段，动态表则存储请求头字段的变量部分。</p>\n</li>\n<li><p>对于每个请求头字段，HPACK 算法通过哈希算法生成一个整数索引，然后将其与静态表和动态表中的索引进行比较，以确定请求头字段的类型和值。</p>\n</li>\n<li><p>对于动态表中的请求头字段，HPACK 算法可以通过索引号来快速查找和更新，从而实现更高效的压缩和解压缩操作。</p>\n</li>\n</ol>\n<p>通过 HPACK 算法的压缩，HTTP&#x2F;2 协议可以将原始请求头数据大小压缩到原来的 1&#x2F;10 左右，从而提高数据传输的效率。同时，HPACK 算法的压缩和解压缩也是可逆的，不会导致请求头信息的丢失或损坏。</p>\n<p><strong>HPACK 算法 示例</strong></p>\n<p>假设我们有如下 HTTP&#x2F;2 请求头：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">GET &#x2F;index.html HTTP&#x2F;2.0\nHost: www.example.com\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;58.0.3029.81 Safari&#x2F;537.3\nAccept-Language: en-US,en;q&#x3D;0.8</code></pre>\n\n<p>使用 HPACK 算法进行压缩的过程如下：</p>\n<ol>\n<li><p>对于第一个请求头字段 “GET &#x2F;index.html HTTP&#x2F;2.0”，我们可以使用 HTTP&#x2F;2 协议中预定义的索引号 “2” 来表示，因为它是一个请求方法和请求路径的组合。所以，我们可以将 “2” 编码为二进制 “82”。</p>\n</li>\n<li><p>对于第二个请求头字段 “Host: <a href=\"http://www.example.com&quot;,我们可以使用hpack算法的动态表,将该字段插入到动态表的最前面,并为其分配一个索引号,例如/\">www.example.com&quot;，我们可以使用HPACK算法的动态表，将该字段插入到动态表的最前面，并为其分配一个索引号，例如</a> “62”，然后将索引号和该字段的值一起编码为二进制 “BE 81 9D 7D 7F 81 84 61 64 64 72 65 73 73 2E 63 6F 6D”。</p>\n</li>\n<li><p>对于第三个请求头字段 “User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;58.0.3029.81 Safari&#x2F;537.3”，我们可以使用 HPACK 算法的动态表，将该字段插入到动态表的最前面，并为其分配一个索引号，例如 “63”，然后将索引号和该字段的值一起编码为二进制 “BF 84 A1 97 A8 41 A5 0F 44 4C 15 4D B4 4B D4 C4 35 05 D8 D6 27 95 98 50 D4 D7 C9 AB 5C 70 1F”。</p>\n</li>\n<li><p>对于第四个请求头字段 “Accept-Language: en-US,en;q&#x3D;0.8”，我们可以使用 HTTP&#x2F;2 协议中预定义的索引号 “38” 来表示，因为它是一个可接受的自然语言列表。所以，我们可以将 “38” 编码为二进制 “AE”。</p>\n</li>\n</ol>\n<p>最终，经过 HPACK 算法压缩后的请求头数据为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">82 BE 81 9D 7D 7F 81 84 61 64 64 72 65 73 73 2E 63 6F 6D BF 84 A1 97 A8 41 A5 0F 44 4C 15 4D B4 4B D4 C4 35 05 D8 D6 27 95 98 50 D4 D7 C9 AB 5C 70 1F AE</code></pre>\n\n<p>使用 HPACK 算法解压缩的过程与上述过程相反，具体实现可参考 RFC 7541 中的规定。</p>\n</p>\n</details>\n<h2 id=\"HTTP3-解决了-HTTP2-哪些问题\"><a href=\"#HTTP3-解决了-HTTP2-哪些问题\" class=\"headerlink\" title=\"HTTP3 解决了 HTTP2 哪些问题\"></a>HTTP3 解决了 HTTP2 哪些问题</h2><p>HTTP3 是 HTTP 协议的新一代版本，相对于 HTTP2，它解决了一些 HTTP2 存在的问题，包括以下几个方面：</p>\n<ol>\n<li><p><code>首字节延迟</code>：HTTP3 使用了 QUIC 协议作为底层传输协议，<strong>通过将 TLS 加密和传输协议合并到一起，可以减少握手和连接建立的延迟，从而降低首字节延迟。</strong></p>\n</li>\n<li><p><code>多路复用</code>：HTTP3 仍然支持多路复用，但采用了更为先进的方式。HTTP3 中的数据流（Stream）可以独立进行流控和错误恢复，避免了因一个数据流出现问题而影响整个连接的问题。</p>\n</li>\n<li><p><code>服务端推送</code>：HTTP3 中的服务端推送（Server Push）更加高效和灵活，可以动态调整推送的内容和优先级。</p>\n</li>\n<li><p><code>可靠性</code>：HTTP3 中的 <strong>QUIC 协议采用了更加先进的错误恢复机制，可以快速检测和修复错误，从而提高连接的可靠性</strong>。</p>\n</li>\n<li><p><code>安全性</code>：HTTP3 <strong>仍然使用 TLS 加密，但是通过将传输和加密合并在一起，可以提高安全性和隐私保护</strong>。</p>\n</li>\n</ol>\n<p>综上所述，HTTP3 <strong>在延迟、多路复用、服务端推送、可靠性和安全性等方面都有所提升</strong>，可以更好地满足现代网络应用的需求。</p>\n<h2 id=\"QUIC-协议将-TLS-加密和传输协议合并到一起，如何理解\"><a href=\"#QUIC-协议将-TLS-加密和传输协议合并到一起，如何理解\" class=\"headerlink\" title=\"QUIC 协议将 TLS 加密和传输协议合并到一起，如何理解\"></a>QUIC 协议将 TLS 加密和传输协议合并到一起，如何理解</h2><p>QUIC 协议将 TLS（Transport Layer Security）加密和传输协议合并到了一起，具体来说，QUIC 的安全性和传输协议都是基于 TLS 1.3 协议实现的，而且<strong>在 QUIC 协议的实现中，TLS 协议是以数据包为单位进行加密和解密的</strong>，也就是说，<strong>QUIC 协议中传输层的加密和传输过程是同时进行的。</strong></p>\n<p>这种设计使得 QUIC 协议的加密和传输过程更为高效，因为 TLS 协议的握手和密钥交换等过程通常会占用比较长的时间，而 QUIC 协议可以通过 0-RTT 握手等技术实现更快的连接建立和数据传输。此外，将加密和传输协议合并到一起，也可以提高协议的灵活性和可扩展性，使得 QUIC 协议更容易适应不同的应用场景和网络环境。</p>\n<h2 id=\"HTTP2-与-HTTP3-的区别\"><a href=\"#HTTP2-与-HTTP3-的区别\" class=\"headerlink\" title=\"HTTP2 与 HTTP3 的区别\"></a>HTTP2 与 HTTP3 的区别</h2><p>HTTP&#x2F;2 和 HTTP&#x2F;3 是 HTTP 协议的两个版本。它们的主要区别在于底层传输协议的不同。HTTP&#x2F;2 使用的是基于 TCP 的传输协议，而 HTTP&#x2F;3 使用的是基于 QUIC 的传输协议。</p>\n<p>下面是 HTTP&#x2F;2 和 HTTP&#x2F;3 的一些主要区别：</p>\n<ol>\n<li><p><code>底层传输协议</code>：HTTP&#x2F;2 使用的是基于 TCP 的传输协议，而 HTTP&#x2F;3 使用的是基于 QUIC 的传输协议。HTTP&#x2F;3 的底层协议具有更快的连接建立时间和更高的性能，<strong>因为它可以将 TLS 和传输协议合并在一起，同时还具有更好的错误恢复机制</strong>。</p>\n</li>\n<li><p><code>多路复用</code>：HTTP&#x2F;2 和 HTTP&#x2F;3 都支持多路复用，但是它们的实现方式不同。</p>\n<ol>\n<li>HTTP&#x2F;3 的数据流可以独立进行流控和错误恢复，</li>\n<li>而 HTTP&#x2F;2 中一个数据流出现问题可能会影响整个连接的性能。</li>\n</ol>\n</li>\n<li><p><code>服务端推送</code>：HTTP&#x2F;2 和 HTTP&#x2F;3 都支持服务端推送，但是 HTTP&#x2F;3 中的服务端推送更加高效和灵活。HTTP&#x2F;3 的服务端推送可以动态调整推送的内容和优先级。</p>\n</li>\n<li><p><code>首字节延迟</code>：HTTP&#x2F;3 的首字节延迟比 HTTP&#x2F;2 更低。这是因为 HTTP&#x2F;3 使用了 QUIC 协议，可以减少握手和连接建立的延迟，从而降低首字节延迟。</p>\n</li>\n<li><p><code>安全性</code>：HTTP&#x2F;2 和 HTTP&#x2F;3 都使用 TLS 加密协议，但是 HTTP&#x2F;3 通过将 TLS 和传输协议合并在一起，可以提高安全性和隐私保护。</p>\n</li>\n</ol>\n<p>综上所述，HTTP&#x2F;3 相对于 HTTP&#x2F;2 来说，在性能、可靠性和安全性等方面都有所提升，可以更好地满足现代网络应用的需求。</p>\n<h3 id=\"QUIC-协议，为什么可以减少握手和连接建立的延迟\"><a href=\"#QUIC-协议，为什么可以减少握手和连接建立的延迟\" class=\"headerlink\" title=\"QUIC 协议，为什么可以减少握手和连接建立的延迟\"></a>QUIC 协议，为什么可以减少握手和连接建立的延迟</h3><p>QUIC 协议可以减少握手和连接建立的延迟，主要是因为它基于 UDP 协议，支持 0-RTT 握手，使用多路复用技术，以及具有快速恢复机制。这些特性可以降低连接的建立次数，提高数据传输效率和可靠性。</p>\n<p>详细内容：</p>\n<p>QUIC 协议可以减少握手和连接建立的延迟，主要有以下几个原因：</p>\n<ol>\n<li><p>基于 UDP 协议：QUIC 协议是基于 UDP 协议实现的，UDP 协议相比 TCP 协议，<strong>不需要进行握手过程和拥塞控制等复杂的功能，因此可以减少握手和连接建立的延迟</strong>。</p>\n</li>\n<li><p>0-RTT 握手：QUIC 协议支持 0-RTT 握手，<strong>这意味着客户端可以在第一次连接时发送数据，而不需要等待服务器的确认</strong>。这样可以减少握手和连接建立的时间，提高数据传输的效率。</p>\n</li>\n<li><p>多路复用：QUIC 协议使用多路复用技术，可以将多个数据流合并在一个连接中传输，这样可以减少连接的建立次数，降低延迟和网络负载。</p>\n</li>\n<li><p>快速恢复：QUIC 协议中有一个快速恢复机制，可以在数据包丢失时快速恢复数据传输，减少连接的中断时间。</p>\n</li>\n</ol>\n<p>综上所述，QUIC 协议的设计使得它可以减少握手和连接建立的延迟，并且具有更高的数据传输效率和可靠性，因此被广泛应用于 HTTP&#x2F;3 等应用协议的底层传输协议。</p>\n<h3 id=\"QUIC-协议支持-0-RTT-握手-是什么\"><a href=\"#QUIC-协议支持-0-RTT-握手-是什么\" class=\"headerlink\" title=\"QUIC 协议支持 0-RTT 握手 是什么\"></a>QUIC 协议支持 0-RTT 握手 是什么</h3><p>0-RTT 握手是指客户端在第一次连接服务器时就可以发送数据，而不需要等待服务器确认，从而减少握手和连接建立的时间，提高数据传输的效率。<strong>具体实现方式</strong>是客户端<strong>在第一次连接时就将加密后的请求数据发送给服务器，并附带一个已知的密钥</strong>，以便服务器能够快速地解密并验证客户端身份。如果服务器能够验证客户端身份并接受请求，则可以立即发送响应，从而实现了 0-RTT 握手。需要注意的是，0-RTT 握手存在一定的安全风险，因为攻击者可以通过伪造密钥来模拟客户端身份，因此需要谨慎使用。</p>\n<!-- ## HTTP3 特点？\n\nHTTP2 缺点：\n\n- `队头阻塞`： **有序字节流**引出的`队头阻塞`（Head-of-line blocking），使得 HTTP2 的多路复用能力大打折扣；\n- `握手延迟`：`TCP 与 TLS 叠加了握手时延`，建链时长还有 1 倍的下降空间；\n- `移动成本高`：基于 TCP 四元组确定一个连接，这种诞生于有线网络的设计，`并不适合移动状态下的无线网络`，这意味着 IP 地址的频繁变动会导致 TCP 连接、TLS 会话反复握手，成本高昂。\n\nHTTP3 协议解决了这些问题：\n\n- `队头阻塞`：HTTP3 基于 UDP 协议重新定义了连接，在 QUIC 层实现了无序、并发字节流的传输，解决了`队头阻塞问题`（包括基于 QPACK 解决了动态表的队头阻塞）；\n- `握手延迟`：HTTP3 重新定义了 TLS 协议加密 QUIC 头部的方式，`既提高了网络攻击成本，又降低了建立连接的速度`（仅需 1 个 RTT 就可以同时完成建链与密钥协商）；\n- `移动成本高`： HTTP3 将 Packet、QUIC Frame、HTTP3 Frame 分离，实现了连接迁移功能，`降低了 5G 环境下高速移动设备的连接维护成本`。 -->\n\n<h2 id=\"HTTP-的缓存的过程\"><a href=\"#HTTP-的缓存的过程\" class=\"headerlink\" title=\"HTTP 的缓存的过程\"></a>HTTP 的缓存的过程</h2><p>通常情况下的步骤是:</p>\n<ol>\n<li>客户端向服务器发出请求，请求资源</li>\n<li>服务器返回资源，并通过响应头决定缓存策略</li>\n<li>客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来</li>\n<li>在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断 是直接读取本地缓存还是与服务器协商缓存</li>\n</ol>\n<h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>强缓存离不开两个响应头 <code>Expires</code> 与 <code>Cache-Control</code></p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>Expires 是 http1.0 提出的⼀个表示资源过期时间的 header，<code>它描述的是⼀个绝对时间</code>，由服务器返回， Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>\n<p>Expires:<code>Wed, 11 May 2018 07:20:00 GMT</code> GMT 时间戳</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>Cache-Control 出现于 HTTP &#x2F; 1.1，优先级⾼于 Expires ,<code>表示的是相对时间</code></p>\n<p>Cache-Control: <code>max-age=315360000</code></p>\n<p>⽬前主流的做法使⽤ Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有：</p>\n<p>Cache-Control: <code>public </code>可以被所有⽤户缓存，<code>允许终端和 CDN 等中间代理服务器</code><br>Cache-Control: <code>private</code> 只能被终端浏览器缓存，<code>不允许中继缓存服务器进⾏缓存</code><br>Cache-Control: <code>no-cache</code>,<code>先缓存本地,要验证</code>，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤<br>Cache-Control: <code>no-store</code>，<code>不会产⽣任何缓存</code></p>\n<p>在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商。</p>\n<p>服务器判断缓存是否是新鲜的⽅法就是依靠 HTTP 的另外两组信息</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><h4 id=\"Last-Modified-x2F-If-Modified-Since\"><a href=\"#Last-Modified-x2F-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified&#x2F;If-Modified-Since\"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>客户端⾸次请求资源时，服务器会把资源的最新修改时间</p>\n<p><code>Last-Modified:Thu, 19 Feb 2019 08:20:55 GMT</code> 通过响应部⾸发送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头</p>\n<p><code>If-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT</code> 发送给服务器，服务器再跟服务器上的对应资源进⾏⽐对，</p>\n<p>如果服务器的资源更新，那么返回最新的资源，此时状态码 200，<br>当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回 304 状态码， 表示客户端直接⽤缓存即可。</p>\n<h4 id=\"ETag-x2F-If-None-Match\"><a href=\"#ETag-x2F-If-None-Match\" class=\"headerlink\" title=\"ETag&#x2F;If-None-Match\"></a>ETag&#x2F;If-None-Match</h4><p>ETag 的流程跟 Last-Modified 是类似的，区别就在于 ETag 是<code>根据资源内容进⾏ hash，⽣成⼀个信息摘要</code>，只要资源内容有变化，这个摘要就会发⽣巨变，通过这个摘要信息⽐对，即可确定客户端的缓存资源是否为最新，<code>⽐ Last-Modified 的精确度要更⾼</code>。 响应头</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220716205210.png\" />\n\n<p>整体的缓存流程图如下：</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220716205325.png\" />\n\n<h2 id=\"HTTP-状态码目录\"><a href=\"#HTTP-状态码目录\" class=\"headerlink\" title=\"HTTP 状态码目录\"></a>HTTP 状态码目录</h2><ul>\n<li><p>1xx 消息</p>\n</li>\n<li><p>2xx 成功</p>\n</li>\n<li><p>3xx 重定向</p>\n</li>\n<li><p>4xx 客户端错误</p>\n</li>\n<li><p>5xx 服务端错误</p>\n</li>\n</ul>\n<h3 id=\"100-Continue\"><a href=\"#100-Continue\" class=\"headerlink\" title=\"100 Continue\"></a>100 Continue</h3><p>响应状态码<code>100 Continue 信息型状态响应码</code>表示：目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略。</p>\n<p><span style=\"color: red\">为了让服务器检查请求的首部，客户端必须在发送请求实体前，在初始化请求中发送 Expect: 100-continue 首部并接收 100 Continue 响应状态码。</span></p>\n<h4 id=\"101-Switching-Protocol\"><a href=\"#101-Switching-Protocol\" class=\"headerlink\" title=\"101 Switching Protocol\"></a>101 Switching Protocol</h4><p>响应状态码<code>101 Switching Protocol（协议切换）</code>状态码表示服务器应客户端升级协议的请求（Upgrade (en-US)请求头）正在切换协议。</p>\n<p>服务器会发送一个 Upgrade (en-US)响应头来表明其正在切换过去的协议。</p>\n<p>该过程在协议升级机制（Protocol upgrade mechanism）中详细描述。</p>\n<p>在使用 WebSockets 时会用到协议切换。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\n</code></pre>\n\n<h4 id=\"102-Processing\"><a href=\"#102-Processing\" class=\"headerlink\" title=\"102 Processing\"></a>102 Processing</h4><ol>\n<li>请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。</li>\n<li>该代码表示服务器已经收到并正在处理请求，但无响应可用。</li>\n<li>这样可<code>以防止客户端超时</code>，并假设请求丢失。</li>\n</ol>\n<h4 id=\"103-Early-Hints\"><a href=\"#103-Early-Hints\" class=\"headerlink\" title=\"103 Early Hints\"></a>103 Early Hints</h4><p>响应状态码 <code>103 Early Hints 信息状态</code>响应码，一般和 <code>Link header（首部）</code>一起使用，<span style=\"color: red\">来允许用户在服务器还在准备响应数据的时候预加载一些资源</span></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>HTTP 实体报头 Link 提供了序列化 HTTP 头部链接的方法。它在语义上与 HTML 元素 <link> 相等</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; link 头部包含以 ; 分隔的参数，这些参数与 HTML 元素 &lt;link&gt; 的属性一致。\n&#x2F;&#x2F; URI 必须要用 &lt; 和 &gt; 来关闭：\n&#x2F;&#x2F; Link: &lt;https:&#x2F;&#x2F;example.com&gt;; rel&#x3D;&quot;preload&quot;</code></pre>\n\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>HTTP 状态码 103 Early Hints 是一个比较新的状态码，它在 HTTP&#x2F;2 和 HTTP&#x2F;3 协议中被引入。它的作用是在服务器处理请求时，提前向客户端发送一些提示信息，让客户端可以在等待服务器响应时进行一些优化处理。</p>\n<p>103 Early Hints 状态码在服务器处理请求时，可以提前向客户端发送一些提示信息，比如可能要返回的资源类型、缓存控制策略等。客户端可以根据这些提示信息，提前进行一些资源的请求和加载，以优化用户的体验。</p>\n<p>为了使用 103 Early Hints 状态码，服务器需要在响应头中设置 Link 头信息，如下所示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Link: &lt;&#x2F;styles.css&gt;; rel&#x3D;preload; as&#x3D;style,\n      &lt;&#x2F;script.js&gt;; rel&#x3D;preload; as&#x3D;script,\n      &lt;&#x2F;image.png&gt;; rel&#x3D;preload; as&#x3D;image</code></pre>\n\n<p>这个 Link 头信息指定了一些资源，告诉客户端这些资源是要在响应中返回的，可以预先加载。其中，rel&#x3D;preload 表示这是一个预加载的资源，as 指定了资源的类型，比如 style、script 或 image 等。</p>\n<p>客户端收到 103 Early Hints 状态码后，可以根据 Link 头信息提前加载资源，以提高页面的响应速度和用户体验。需要注意的是，客户端在收到 103 Early Hints 状态码时，仍然需要等待服务器返回完整的响应，这只是一个提前的提示信息，不代表响应的完成。</p>\n<p><strong>使用的场景</strong></p>\n<p>103 Early Hints 状态码可以在一些需要优化页面加载速度的项目中使用，比如：</p>\n<ol>\n<li>首页加载优化</li>\n</ol>\n<p>在网站首页中，可以使用 103 Early Hints 状态码来预加载一些重要的资源，如 CSS 样式表、JavaScript 文件和页面头部图片等。这些资源可以在服务器处理请求时，提前使用 Link 头信息告诉客户端需要预加载的资源，以加快页面加载速度和提升用户体验。</p>\n<ol start=\"2\">\n<li>移动端 Web 应用</li>\n</ol>\n<p>移动端 Web 应用对页面加载速度有着很高的要求，使用 103 Early Hints 状态码可以在请求完成前，提前加载页面所需的关键资源，比如核心 JavaScript 文件、CSS 样式表等。这可以让页面在客户端请求完成后，立即呈现给用户，提升用户体验。</p>\n<ol start=\"3\">\n<li>CDN 缓存控制</li>\n</ol>\n<p>使用 103 Early Hints 状态码可以在 CDN 缓存控制中，提前告诉客户端需要缓存的资源和缓存策略。这可以提高客户端对资源的缓存命中率，减少服务器压力，同时提升用户访问体验。</p>\n<p>需要注意的是，103 Early Hints 状态码在 HTTP&#x2F;2 和 HTTP&#x2F;3 协议中才被支持，对于老版本的 HTTP 协议，不支持使用该状态码。在使用该状态码时，也需要注意浏览器和服务器的兼容性，以确保项目的正常运行。</p>\n\n</details>\n<h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>响应状态码 <code>200 OK</code> 表明请求已经成功。默认情况下状态码为 200 的响应可以被缓存。</p>\n<p><span style=\"color: red\">不同请求方式对于请求成功的意义如下：</span></p>\n<ul>\n<li><code>HEAD:</code> 响应的消息体为头部信息。</li>\n<li><code>GET:</code> 已经取得资源，并将资源添加到响应的消息体中。</li>\n<li><code>POST:</code> 响应的消息体中包含此次请求的结果。</li>\n<li><code>TRACE:</code> <span style=\"color: red\">响应的消息体中包含服务器接收到的请求信息</span>。</li>\n<li><code>PUT</code> 和 <code>DELETE</code> 的请求成功通常并不是响应<code>200 OK</code>的状态码, 而是 <code>204 No Content</code> 表示无内容（或者 <code>201 Created</code>表示一个资源首次被创建成功）。</li>\n</ul>\n<img src=\"https://img0.baidu.com/it/u=2485422989,671633180&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500\"  style=\"width: 200px\"/>\n\n<h4 id=\"201-Created\"><a href=\"#201-Created\" class=\"headerlink\" title=\"201 Created\"></a>201 Created</h4><p>响应状态码<code>201 Created</code> 是一个代表成功的应答状态码，<strong>表示请求已经被成功处理，并且创建了新的资源</strong>。<br>新的资源在应答返回之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 Location 首部的值。(TODO：后半句没搞懂)</p>\n<p><strong>使用场景</strong></p>\n<p>这个状态码的常规使用场景是作为 POST 请求的返回值</p>\n<h4 id=\"202-Accepted\"><a href=\"#202-Accepted\" class=\"headerlink\" title=\"202 Accepted\"></a>202 Accepted</h4><p>响应状态码<code>202 Accepted 表示服务器端已经收到请求消息，但是尚未进行处理。</code></p>\n<p>但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。</p>\n<p><strong>使用场景</strong></p>\n<p>这个状态码被设计 <strong>用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</strong></p>\n<h4 id=\"203-Non-Authoritative-Information\"><a href=\"#203-Non-Authoritative-Information\" class=\"headerlink\" title=\"203 Non-Authoritative Information\"></a>203 Non-Authoritative Information</h4><p>响应状态码 <code>203 Non-Authoritative Information</code> 表示请求已经成功被响应，但是获得的负载与源头服务器的状态码为<code>200 (OK)</code>的响应相比，<strong>经过了拥有转换功能的 <code>proxy</code>（代理服务器）的修改</strong>。</p>\n<p><strong>TODO:不懂</strong><br>响应状态码<code> 203 状态码</code>有点类似于 Warning 首部的<code> 214（Transformation Applied）</code>警告码，后者的优势在于可以应用于任何状态码的响应之中。</p>\n<h4 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h4><p>响应状态码<code>204 No Content</code> 成功状态响应码，表示该请求已经成功了，但是<strong>客户端客户不需要离开当前页面</strong>。默认情况下 <code>204</code> 响应是可缓存的。一个 ETag 标头包含在此类响应中。</p>\n<p><strong>使用场景</strong></p>\n<p>使用惯例是: 在<code> PUT 请求</code>中进行资源更新，但是</p>\n<ul>\n<li>不需要改变当前展示给用户的页面，那么返回 <code>204 No Content</code>。</li>\n<li>如果创建了资源，则返回<code> 201 Created</code> 。</li>\n<li>如果应将页面更改为新更新的页面，则应改用 200 。</li>\n</ul>\n<h4 id=\"205-Reset-Content\"><a href=\"#205-Reset-Content\" class=\"headerlink\" title=\"205 Reset Content\"></a>205 Reset Content</h4><p>响应状态码<code>205 Reset Content</code> 用来通知客户端重置文档视图，比如<code>清空表单内容</code>、<code>重置 canvas 状态</code>或者<code>刷新用户界面</code>。</p>\n<h4 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h4><p>响应状态码<code>206 Partial Content</code>成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 <code>Range</code> 首部指定的。</p>\n<ul>\n<li>如果只包含一个数据区间，那么整个响应的 <code>Content-Type</code> 首部的值为所请求的文件的类型，同时包含 <code>Content-Range</code> 首部。</li>\n<li>如果包含多个数据区间，那么整个响应的 <code>Content-Type</code> 首部的值为 <code>multipart/byteranges</code> ，其中一个片段对应一个数据区间，并提供 <code>Content-Range</code> 和 <code>Content-Type</code> 描述信息。</li>\n</ul>\n<p><strong>只包含一个数据区间的响应：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 206 Partial Content\nDate: Wed, 15 Nov 2015 06:25:24 GMT\nLast-Modified: Wed, 15 Nov 2015 04:58:08 GMT\n# 这里\nContent-Range: bytes 21010-47021&#x2F;47022\nContent-Length: 26012\nContent-Type: image&#x2F;gif\n\n... 26012 bytes of partial image data ...</code></pre>\n\n<p><strong>包含多个数据区间的响应：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 206 Partial Content\nDate: Wed, 15 Nov 2015 06:25:24 GMT\nLast-Modified: Wed, 15 Nov 2015 04:58:08 GMT\nContent-Length: 1741\nContent-Type: multipart&#x2F;byteranges; boundary&#x3D;String_separator\n\n--String_separator\nContent-Type: application&#x2F;pdf # 这里\nContent-Range: bytes 234-639&#x2F;8000 # 这里\n\n...the first range...\n--String_separator\nContent-Type: application&#x2F;pdf # 这里\nContent-Range: bytes 4590-7999&#x2F;8000 # 这里\n\n...the second range\n--String_separator--</code></pre>\n\n<h3 id=\"300-Multiple-Choices\"><a href=\"#300-Multiple-Choices\" class=\"headerlink\" title=\"300 Multiple Choices\"></a>300 Multiple Choices</h3><p>响应状态码<code>300 Multiple Choices</code> 是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。由于没有如何进行选择的标准方法，这个状态码极少使用。</p>\n<p>假如服务器可以提供一个优先选择，那么它应该生成一个 <code>Location</code> 首部。</p>\n<h4 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h4><p>响应状态码<code>301 永久重定向 </code>说明请求的资源已经被移动到了由 <code>Location</code> 头部指定的 <code>url</code> 上，是固定的不会再改变。</p>\n<p><span style=\"color: red\">搜索引擎会根据该响应修正。</span></p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>尽管标准要求浏览器在收到该响应并进行重定向时, 不应该修改<code>http method</code> 和 <code>body</code>，但是有一些浏览器可能会有问题。所以最好是在应对 <code>GET</code> 或 <code>HEAD</code> 方法时使用 <code>301</code>，其他情况使用 <code>308</code> 来替代 <code>301</code>。</p>\n</div>\n<h4 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h4><ol>\n<li>响应状态码<code>302 Found 重定向状态码</code>,表明<code>请求的资源被暂时的移动</code>到了由该 <code>HTTP</code> 响应的响应头 <code>Location</code> 指定的 <code>URL</code> 上。</li>\n<li>浏览器会重定向到这个 <code>URL</code>，</li>\n<li>但是搜索引擎不会对该资源的链接进行更新 (In SEO-speak, it is said that the link-juice is not sent to the new URL)。</li>\n</ol>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。</p>\n<p>所以推荐仅在响应 <code>GET</code> 或 <code>HEAD</code> 方法时采用 <code>302</code> 状态码，<br>而在其他时候使用 <code>307 Temporary Redirect</code> 来替代，<span style=\"color: red\">因为在这些场景下方法变换是明确禁止的</span>。</p>\n</div>\n<p>在确实需要将重定向请求的方法转换为 GET 的场景下，可以使用 <code>303 See Other</code>。</p>\n<p><strong>例如:</strong></p>\n<p>在使用 PUT 方法进行文件上传操作时，需要返回确认信息（例如“你已经成功上传了 xyz”）而不是上传的资源本身，就可以使用这个状态码。</p>\n<h4 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h4><p>响应状态码<code>303 See Other 重定向状态码</code>，<code>通常作为 PUT 或 POST 操作的返回结果</code>，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET</p>\n<h4 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h4><p>响应状态码<code>304 未改变说明无需再次传输请求的内容</code>，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如 GET 或 HEAD 或在请求中附带了头部信息： <code>If-None-Match</code> 或 <code>If-Modified-Since</code>。</p>\n<p>如果是 <code>200 OK</code> ，响应会带有头部<code> Cache-Control</code>, <code>Content-Location</code>, <code>Date</code>, <code>ETag</code>, <code>Expires</code>，和 <code>Vary</code>.</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>304 状态码是协商缓存？</p>\n<p>是的，HTTP 状态码 304 Not Modified 通常被称为“协商缓存”（Conditional Cache）。协商缓存是一种缓存机制，客户端和服务器之间通过某些条件进行协商，以决定是否使用缓存的资源。</p>\n<p>客户端在请求资源时，可以使用 If-Modified-Since 或 If-None-Match 等头信息告诉服务器上一次请求中返回的标识符（如资源的修改时间或 ETag），服务器根据这些标识符来判断该资源是否有更新。如果服务器判断资源没有更新，就会返回 304 Not Modified 状态码，客户端可以使用本地缓存中的资源，避免了重复下载和浪费网络带宽，提高了页面加载速度和用户体验。</p>\n<p>需要注意的是，协商缓存是一种高效的缓存机制，但也存在一些限制和注意事项。例如，如果服务器端使用的是 Last-Modified 标识符，那么客户端的本地时间必须与服务器端的时间一致，否则可能会导致缓存失效；另外，某些代理服务器可能会阻止协商缓存机制，从而导致客户端无法使用缓存资源等。</p>\n<p>总之，304 状态码是一种协商缓存机制，用于优化资源加载并减少网络流量，提高用户体验。\n</details>\n<h4 id=\"305-Use-Proxy\"><a href=\"#305-Use-Proxy\" class=\"headerlink\" title=\"305 Use Proxy\"></a>305 Use Proxy</h4><p>被请求的资源必须通过指定的代理才能被访问</p>\n<h4 id=\"306-Switch-Proxy-废弃\"><a href=\"#306-Switch-Proxy-废弃\" class=\"headerlink\" title=\"306 Switch Proxy 废弃\"></a>306 Switch Proxy 废弃</h4><p>306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”</p>\n<h4 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h4><p>响应状态码<code>307 Temporary Redirect，临时重定向响应状态码</code>，表示请求的资源暂时地被移动到了响应的 Location 首部所指向的 URL 上。</p>\n<p>原始请求中的请求方法和消息主体会在重定向请求中被重用。在确实需要将重定向请求的方法转换为 <code>GET</code> 的场景下，可以考虑使用 <code>303 See Other</code> 状态码。例如，在使用 PUT 方法进行文件上传操作时，如果需要返回一条确认信息（例如“你已经成功上传了 XYZ”），而不是返回上传的资源本身，就可以使用这个状态码。</p>\n<h4 id=\"307-302-的区别\"><a href=\"#307-302-的区别\" class=\"headerlink\" title=\"307,302 的区别\"></a>307,302 的区别</h4><p><span style=\"color: red\">当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。</span></p>\n<ul>\n<li>如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET：也就是说，在 Web 中，如果使用了 GET 以外的请求方法，且返回了 302 状态码，则重定向后的请求方法是不可预测的；<br/>\n<br/></li>\n<li>但如果使用 307 状态码，之后的请求方法就是可预测的。对于 GET 请求来说，两种情况没有区别。</li>\n</ul>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p>307 Temporary Redirect 和 302 Found 状态码都表示重定向，但两者之间有一些细微的区别。</p>\n<p>302 Found 状态码表示临时重定向，客户端请求的资源已经被暂时转移到了另一个 URL 地址。使用 302 状态码的情况比较多，例如，当用户登录后需要跳转到个人主页时，可以使用 302 状态码。另外，搜索引擎爬虫也会使用 302 状态码来暂时性重定向一些网页。</p>\n<p>307 Temporary Redirect 状态码表示临时重定向，客户端请求的资源已经被暂时转移到了另一个 URL 地址。307 状态码与 302 状态码的区别在于，307 状态码要求客户端在下一次请求时保持请求方法不变，也就是说，如果客户端使用 POST 方法请求一个 URL 地址，服务器在返回 307 状态码时会要求客户端在下一次请求时继续使用 POST 方法，而不是转换为 GET 方法。</p>\n<p>因此，</p>\n<ol>\n<li>如果客户端请求的资源被临时重定向到另一个 URL 地址，并且需要在下一次请求时继续使用原始的请求方法，可以使用 307 Temporary Redirect 状态码。</li>\n<li>而如果客户端请求的资源被临时重定向到另一个 URL 地址，但请求方法可以变化，可以使用 302 Found 状态码。</li>\n</ol>\n<p>需要注意的是，302 状态码在 HTTP&#x2F;1.0 协议中被定义为“Moved Temporarily”，但在 HTTP&#x2F;1.1 协议中则被重新定义为“Found”，而 307 状态码则在 HTTP&#x2F;1.1 协议中被定义为“Temporary Redirect”。</p>\n</p>\n</details>\n<h4 id=\"301-与-308-状态码的区别\"><a href=\"#301-与-308-状态码的区别\" class=\"headerlink\" title=\"301 与 308 状态码的区别\"></a>301 与 308 状态码的区别</h4><details class=\"custom-details\">\n<summary>Details</summary>\n<p>301 Moved Permanently 和 308 Permanent Redirect 状态码都表示永久重定向，但两者之间也有一些区别。</p>\n<p>301 Moved Permanently 状态码表示请求的资源被永久性地移动到了另一个 URL 地址，客户端应该使用新的 URL 地址访问该资源。使用 301 状态码的情况比较多，例如，当网站的域名发生变化或者网页的 URL 地址发生变化时，可以使用 301 状态码将旧的 URL 地址重定向到新的 URL 地址。</p>\n<p>308 Permanent Redirect 状态码也表示请求的资源被永久性地移动到了另一个 URL 地址，客户端应该使用新的 URL 地址访问该资源。与 301 状态码不同的是，308 状态码要求客户端在下一次请求时保持请求方法不变，也就是说，如果客户端使用 POST 方法请求一个 URL 地址，服务器在返回 308 状态码时会要求客户端在下一次请求时继续使用 POST 方法，而不是转换为 GET 方法。</p>\n<p>因此，</p>\n<ol>\n<li>如果需要将请求的资源永久性地移动到另一个 URL 地址，并且需要在下一次请求时继续使用原始的请求方法，可以使用 308 Permanent Redirect 状态码。</li>\n<li>而如果只需要将请求的资源永久性地移动到另一个 URL 地址，而请求方法可以变化，可以使用 301 Moved Permanently 状态码。</li>\n</ol>\n<p>需要注意的是，301 状态码在 HTTP&#x2F;1.0 协议中被定义为“Moved Permanently”，而在 HTTP&#x2F;1.1 协议中则被重新定义为“Permanent Redirect”，而 308 状态码则是在 HTTP&#x2F;1.1 协议中新增加的状态码。</p>\n\n</details>\n<h4 id=\"308-Permanent-Redirect\"><a href=\"#308-Permanent-Redirect\" class=\"headerlink\" title=\"308 Permanent Redirect\"></a>308 Permanent Redirect</h4><p>在 HTTP 协议中， <code>308 Permanent Redirect（永久重定向）</code>是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是“链接汁”（link juice）被传递到了新的 URL）。</p>\n<p>在重定向过程中，<code>请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法</code>。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><p>一些 Web 应用可能会将 <code>308 Permanent Redirect</code> 以一种非标准的方式使用以及用作其他用途。例如，Google Drive 会使用 308 Resume Incomplete 状态码来告知客户端文件上传终止且不完整</p>\n</div>\n<h4 id=\"301-308-302-307-303-区别\"><a href=\"#301-308-302-307-303-区别\" class=\"headerlink\" title=\"301,308,302,307,303 区别\"></a>301,308,302,307,303 区别</h4><p><code>301,308 永久重定向</code>(有兼容问题)</p>\n<ol>\n<li>请求方法和消息主体不会发生改变，然而在返回<code> 301 状态码</code>的情况下，<code>请求方法有时候会被客户端错误地修改为 GET 方法</code></li>\n<li>Google Drive 会使用 <code>308 Resume Incomplete</code> 状态码来告知客户端文件上传终止且不完整</li>\n</ol>\n<p><code>302,307,303 临时重定向</code>,</p>\n<ol>\n<li>对应 GET 方法，302 和 307 没有区别，</li>\n<li>对于 HEAD，302 不会改变,307 会变</li>\n<li>其他请求方法，302 会改成 GET 请求，303 表示都要变成 GET，307 保持请求方法不变</li>\n</ol>\n<p><strong>变 GET</strong>: <code>302(保留GET,HEAD) &lt; 307(保留HEAD) &lt; 303(全部)</code></p>\n<h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>响应状态码<code>400 Bad Request </code>响应状态码表示: <code>由于语法无效，服务器无法理解该请求</code>。 客户端不应该在未经修改的情况下重复此请求。</p>\n<h4 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h4><p>响应状态码 <code>401 Unauthorized</code> 代表客户端错误，指的是: <code>由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足</code>。</p>\n<p>这个状态码会与 WWW-Authenticate 首部一起发送，其中包含有如何进行验证的信息。</p>\n<p>这个状态类似于 403， 但是在该情况下，依然可以进行身份验证。</p>\n<p><strong>响应样例</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 401 Unauthorized\nDate: Wed, 21 Oct 2015 07:28:00 GMT\nWWW-Authenticate: Basic realm&#x3D;&quot;Access to staging site&quot;\n</code></pre>\n\n<h4 id=\"402-Payment-Required\"><a href=\"#402-Payment-Required\" class=\"headerlink\" title=\"402 Payment Required\"></a>402 Payment Required</h4><p>响应状态码 <code>402 Payment Required</code> 是一个被保留使用的非标准客户端错误状态响应码。</p>\n<p>有时， 这个状态码表明直到客户端付费之后请求才会被处理。<strong>402 状态码被创建最初目的是用于数字现金或微型支付系统， 表明客户端请求的内容只有付费之后才能获取</strong>。目前还不存在标准的使用约定，不同的实体可以在不同的环境下使用。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>Experimental: 这是一个实验中的功能<br>此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</p>\n</div>\n<p><strong>响应样例</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 402 Payment Required\nDate: Wed, 21 Oct 2015 07:28:00 GMT</code></pre>\n\n<h4 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h4><p>响应状态码<code>403 Forbidden</code>，指的是: <span style=\"color: red\">服务器端有能力处理该请求，但是拒绝授权访问</span>。</p>\n<p>这个状态类似于 <code>401</code>，但进入 <code>403</code>状态后, 即使重新验证也不会改变该状态。该访问是长期禁止的，并且与应用逻辑密切相关（例如没有足够的权限访问该资源）。</p>\n<h4 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h4><p>响应状态码 <code>404 Not Found</code> 指的是: 服务器无法找到所请求的资源。返回该响应的链接通常称为<code>坏链（broken link）</code>或<code>死链（dead link）</code>，它们会<code>导向链接出错处理（link rot）</code>页面。</p>\n<p><span style=\"color: red\">404 状态码并不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 410（Gone）而不是 404 。</span></p>\n<h4 id=\"405-Method-Not-Allowed\"><a href=\"#405-Method-Not-Allowed\" class=\"headerlink\" title=\"405 Method Not Allowed\"></a>405 Method Not Allowed</h4><p>响应状态码 <code>405 Method Not Allowed</code> 表明服务器禁止了使用当前 HTTP 方法的请求。</p>\n<p><strong>事例</strong></p>\n<p>restful 风格 API,使用中会出现 <a href=\"https://blog.csdn.net/qq_42704130/article/details/125417805\" target=\"_blank\" >见</a></p>\n<h4 id=\"406-Not-Acceptable\"><a href=\"#406-Not-Acceptable\" class=\"headerlink\" title=\"406 Not Acceptable\"></a>406 Not Acceptable</h4><ol>\n<li>响应状态码 <code>406 Not Acceptable</code>表示: 客户端错误，</li>\n<li>指代服务器端无法提供与 <code>Accept-Charset</code> 以及 <code>Accept-Language</code> 消息头指定的值相匹配的响应。</li>\n</ol>\n<p>在实际应用中，_这个错误状态码极少使用_：不是给用户返回一个晦涩难懂（且难以更正）的错误状态码，而是将相关的消息头忽略，同时给用户提供一个看得见摸得着的页面。这种做法基于这样一个假设：即便是不能达到用户十分满意，也强于返回错误状态码。</p>\n<p>如果服务器返回了这个错误状态码，那么消息体中应该包含所能提供的资源表现形式的列表，允许用户手动进行选择。</p>\n<h4 id=\"407-Proxy-Authentication-Required\"><a href=\"#407-Proxy-Authentication-Required\" class=\"headerlink\" title=\"407 Proxy Authentication Required\"></a>407 Proxy Authentication Required</h4><p>响应状态码 <code>407 Proxy Authentication Required</code> 代表客户端错误，指的是: 由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器（proxy server ）要求的身份验证凭证，发送的请求尚未得到满足。</p>\n<p>这个状态码会与 <code>Proxy-Authenticate</code> 首部一起发送，其中包含有如何进行验证的信息。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 407 Proxy Authentication Required\nDate: Wed, 21 Oct 2015 07:28:00 GMT\nProxy-Authenticate: Basic realm&#x3D;&quot;Access to internal site&quot;</code></pre>\n\n<h4 id=\"408-Request-Timeout\"><a href=\"#408-Request-Timeout\" class=\"headerlink\" title=\"408 Request Timeout\"></a>408 Request Timeout</h4><p>响应状态码 <code>408 Request Timeout</code> 表示: 服务器想要将没有在使用的连接关闭。一些服务器会在空闲连接上发送此信息，即便是在客户端没有发送任何请求的情况下。</p>\n<p>服务器应该在此类响应中将 Connection 首部的值设置为 “close”，因为 <code>408 意味着服务器已经决定将连接关闭，而不是继续等待</code>。</p>\n<p>这类响应出现的比较频繁，源于一些浏览器——例如 Chrome, Firefox 27+, 或者 IE9 等——<code>使用 HTTP 协议中的预连接机制来加速上网体验</code>。<span style=\"color: red\">同时应该注意到，某些服务器会直接关闭连接，而不发送此类消息。</span></p>\n<h4 id=\"409-Conflict\"><a href=\"#409-Conflict\" class=\"headerlink\" title=\"409 Conflict\"></a>409 Conflict</h4><p>响应状态码 <code>409 Conflict</code>表示: 请求与服务器端目标资源的当前状态相冲突。</p>\n<p>冲突最有可能发生在对 <code>PUT</code> 请求的响应中。例如，<strong>当上传文件的版本比服务器上已存在的要旧</strong>，从而导致版本冲突的时候，那么就有可能收到状态码为 <code>409 的响应</code>。</p>\n<h4 id=\"410-Gone\"><a href=\"#410-Gone\" class=\"headerlink\" title=\"410 Gone\"></a>410 Gone</h4><p>响应状态码 <code>410 Gone</code> 说明请求的目标资源在原服务器上不存在了，并且<code>是永久性的丢失</code>。如果不清楚是否为永久或临时的丢失，应该使用 404</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>410 响应默认会被缓存</p>\n</div>\n<h4 id=\"411-Length-Required\"><a href=\"#411-Length-Required\" class=\"headerlink\" title=\"411 Length Required\"></a>411 Length Required</h4><p>响应状态码 <code>411 Length Required</code> 属于客户端错误，表示: 由于缺少确定的 Content-Length 首部字段，服务器拒绝客户端的请求。</p>\n<p>注意，按照规范，<strong>当使用分块模式传输数据的时候</strong>， <code>Content-Length</code> 首部是不存在的，但是<strong>需要在每一个分块的开始添加该分块的长度</strong>，用十六进制数字表示。参见 Transfer-Encoding 获取更多细节信息。</p>\n<h4 id=\"412-Precondition-Failed\"><a href=\"#412-Precondition-Failed\" class=\"headerlink\" title=\"412 Precondition Failed\"></a>412 Precondition Failed</h4><p>响应状态码 <code>412 Precondition Failed（先决条件失败）</code>, 这通常发生于: 采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 <code>If-Unmodified-Since</code> 或 <code>If-None-Match</code> 规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。</p>\n<h4 id=\"413-Payload-Too-Large\"><a href=\"#413-Payload-Too-Large\" class=\"headerlink\" title=\"413 Payload Too Large\"></a>413 Payload Too Large</h4><p>响应状态码 <code>413 Payload Too Large</code> 表示: <code>请求主体的大小超过了服务器的能力处理</code>，<strong>base64 编码会增大数据体积</strong>。</p>\n<p>如果“超出限度”是暂时性的，服务器应该返回 Retry-After 首部字段，说明这是暂时性的，以及客户端可以在什么时间（after what time）后重试。</p>\n<p>这个上传图片的时候也有遇到: <code>client_max_body_size 1024m;</code></p>\n<h4 id=\"414-URI-Too-Long\"><a href=\"#414-URI-Too-Long\" class=\"headerlink\" title=\"414 URI Too Long\"></a>414 URI Too Long</h4><p>响应状态码 <code>414 URI Too Long</code> 表示客户端所请求的 URI 超过了服务器允许的范围。</p>\n<p>以下是造成这种罕见情况的几种可能原因：</p>\n<ol>\n<li>当客户端误将 POST 请求当作 GET 请求时，会带有一个较长的查询字符串 (query)；</li>\n<li>当客户端堕入重定向循环黑洞时，例如，指向自身后缀的重定向 URI 前缀 (a redirected URI prefix that points to a suffix of itself)；</li>\n<li>当客户端对服务器进行攻击，试图寻找潜在的漏洞时。（<code>反射型XSS攻击</code>）</li>\n</ol>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>413 与 414 状态码</p>\n<p>413 Payload Too Large 和 414 URI Too Long 状态码都表示请求过程中出现了某些错误，导致服务器无法处理该请求。</p>\n<p>413 Payload Too Large 状态码表示客户端发送的请求超出了服务器所能处理的范围。这个错误通常发生在客户端发送的请求体过大时，比如上传的文件大小超过了服务器所允许的最大值。服务器在返回 413 状态码时还可以返回一个“Retry-After”头部，指示客户端在多长时间之后重新尝试请求。</p>\n<p>414 URI Too Long 状态码表示请求的 URL 地址过长，超出了服务器所能处理的范围。这个错误通常发生在客户端发送的 URL 地址过长时，比如在使用 GET 方法请求 API 接口时，请求参数过多或者过长，导致 URL 地址过长。服务器在返回 414 状态码时还可以返回一个“Retry-After”头部，指示客户端在多长时间之后重新尝试请求。</p>\n<p>需要注意的是，413 和 414 状态码是在 HTTP&#x2F;1.1 协议中定义的，而在 HTTP&#x2F;1.0 协议中并没有这两个状态码。如果客户端使用的是 HTTP&#x2F;1.0 协议，服务器在遇到 413 或 414 错误时可能会返回其他的状态码，比如 400 Bad Request 或 500 Internal Server Error。</p>\n\n</details>\n<h4 id=\"415-Unsupported-Media-Type\"><a href=\"#415-Unsupported-Media-Type\" class=\"headerlink\" title=\"415 Unsupported Media Type\"></a>415 Unsupported Media Type</h4><p>响应状态码 <code>415 Unsupported Media Type</code> 表示: 服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。</p>\n<p>格式问题的出现有可能源于客户端在 <code>Content-Type</code> 或 <code>Content-Encoding</code> 首部中指定的格式，也可能源于直接对负载数据进行检测的结果</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p>415 Unsupported Media Type 状态码表示客户端发送的请求包含了服务器无法处理的媒体类型。这个错误通常发生在客户端向服务器发送的请求中包含了服务器无法处理的媒体类型，比如客户端发送了一个使用了未知编码的请求体。</p>\n<p>HTTP 协议中规定了一些标准的媒体类型，例如 text&#x2F;plain、text&#x2F;html、application&#x2F;json 等等。服务器在处理请求时会根据请求头部中的 Content-Type 字段来判断客户端发送的请求的媒体类型，如果请求的媒体类型不符合服务器的要求，服务器就会返回 415 状态码。</p>\n<p>需要注意的是，客户端在发送请求时需要指定正确的 Content-Type 字段，以确保请求的媒体类型被正确识别。如果客户端不确定服务器所能处理的媒体类型，可以向服务器发送一个 OPTIONS 请求，服务器会在响应中返回支持的媒体类型。</p>\n<p>另外，服务器也可以在返回 415 状态码时附带一个“Accept”头部，指示客户端可以使用的媒体类型。客户端可以根据服务器返回的“Accept”头部来调整请求的媒体类型，以便服务器可以正确处理请求。</p>\n</p>\n</details>\n<h4 id=\"416-Range-Not-Satisfiable\"><a href=\"#416-Range-Not-Satisfiable\" class=\"headerlink\" title=\"416 Range Not Satisfiable\"></a>416 Range Not Satisfiable</h4><p>响应状态码<code>416 Range Not Satisfiable </code>错误状态码意味着: <strong>服务器无法处理所请求的数据区间</strong>。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。</p>\n<p>416 响应报文包含一个 Content-Range 首部，提示无法满足的数据区间（用星号 _ 表示），后面紧跟着一个“&#x2F;”，再后面是当前资源的长度。例如：<code>Content-Range: */12777</code></p>\n<p>遇到这一错误状态码时，浏览器一般有两种策略：<code>要么终止操作</code>（例如，一项中断的下载操作被认为是不可恢复的），<code>要么再次请求整个文件</code>。</p>\n<h4 id=\"417-Expectation-Failed\"><a href=\"#417-Expectation-Failed\" class=\"headerlink\" title=\"417 Expectation Failed\"></a>417 Expectation Failed</h4><p>响应状态码 <code>417 Expectation Failed</code> 状态码表示客户端错误，意味着: <strong>服务器无法满足 Expect 请求消息头中的期望条件</strong>。</p>\n<p>参考 Expect 消息头获得更多的相关细节信息</p>\n<p><a href=\"https://www.jianshu.com/p/7cb1a7bf0f5d\" target=\"_blank\" >示例</a></p>\n<h4 id=\"418-I’m-a-teapot\"><a href=\"#418-I’m-a-teapot\" class=\"headerlink\" title=\"418 I’m a teapot\"></a>418 I’m a teapot</h4><p>响应状态码 <code>418 I&#39;m a teapot</code> 客户端错误响应代码表示: 服务器拒绝冲泡咖啡，因为它是个茶壶。</p>\n<p>该错误是超文本咖啡壶控制协议的参考，和 1998 年愚人节的玩笑。用作彩蛋</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">出自RFC 2324 Hyper Text Coffee Pot Control Protocol (HTCPCP&#x2F;1.0)文档\n文档中定义的一种返回值，协议定义“如果想用茶壶制作咖啡，就会返回一个错误码418 I&#39;m tea pot”\n2014年4.1发布的恶搞RFC 7168是此协议的扩展，正式支持茶壶\n\n作者：chanyi\n链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;cdefc3afd7ea\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<p>RFC（request for commits） 征求意见修订书</p>\n<p>是一个互联网技术标准文档</p>\n<h4 id=\"422-Unprocessable-Entity\"><a href=\"#422-Unprocessable-Entity\" class=\"headerlink\" title=\"422 Unprocessable Entity\"></a>422 Unprocessable Entity</h4><p>响应状态码 <code>422 状态码</code>表示: 服务器理解请求实体的内容类型，并且<code>请求实体的语法是正确的，但是服务器无法处理所包含的指令</code>。</p>\n<p>例子：<a href=\"https://blog.csdn.net/weixin_30314631/article/details/97219640\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HttpRequest中所带cookie和服务器端接收的 cookie名称不一致 ，导致返回422错误代码。</code></pre>\n\n<h4 id=\"423-Locked\"><a href=\"#423-Locked\" class=\"headerlink\" title=\"423 Locked\"></a>423 Locked</h4><p>当前资源被锁定。（RFC 4918 WebDAV）,网上查到更多是和 SVN 相关</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>423 Locked 状态码表示由于资源被锁定而导致请求失败。这个状态码通常用于 WebDAV 协议中，用来防止多个用户同时对同一个资源进行修改而导致冲突。</p>\n<p>当一个资源被锁定时，其他用户就无法对该资源进行修改操作，这时如果其他用户发起了修改请求，服务器就会返回 423 Locked 状态码。服务器在返回 423 状态码时通常还会在响应中附带一个“Lock-Token”头部，指示当前资源被锁定的令牌。</p>\n<p>423 状态码可以使用 PROPFIND 方法来获取当前资源的锁定状态信息。如果请求的资源没有被锁定，服务器会返回 200 OK 状态码，否则会返回 423 Locked 状态码和锁定信息。</p>\n<p>需要注意的是，423 状态码只适用于被锁定的资源，对于未被锁定的资源应当使用其他的状态码。</p>\n<p><strong>数据库死锁报错什么状态码</strong></p>\n<p><strong>数据库死锁并不是一个 HTTP 协议中定义的错误，因此没有专门的 HTTP 状态码来表示数据库死锁</strong>。数据库死锁是指多个并发的事务同时请求数据库中的资源，并且这些请求形成了一个死循环，导致所有事务都被阻塞无法继续执行。</p>\n<p>在应用程序中可以通过捕获数据库异常来检测到死锁情况，并采取相应的处理措施，比如等待一段时间后重试、回滚事务等等。常见的数据库异常错误码包括 ORA-00060（Deadlock detected）、1213（Deadlock found when trying to get lock）、40001（Serialization failure）等等，不同的数据库系统会有不同的错误码和错误信息来表示死锁情况。\n</details>\n<h4 id=\"424-Failed-Dependency\"><a href=\"#424-Failed-Dependency\" class=\"headerlink\" title=\"424 Failed Dependency\"></a>424 Failed Dependency</h4><p>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p>\n<h4 id=\"425-Too-Early\"><a href=\"#425-Too-Early\" class=\"headerlink\" title=\"425 Too Early\"></a>425 Too Early</h4><p>～～服务器拒绝处理在 Early Data 中的请求，以规避可能的重放攻击, <a href=\"https://zh.wikipedia.org/zh-cn/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB\" target=\"_blank\" >重放攻击- 中间人攻击的一种</a>～～</p>\n<p>～～是一种恶意或欺诈的重复或延迟有效数据的网络攻击形式～～</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p><strong>103 和 425 有什么区别</strong></p>\n<p>103 Early Hints 和 425 Too Early 状态码的作用和含义比较相似，都是用来优化 HTTP 响应速度的，但它们之间有一些区别。</p>\n<p>103 Early Hints 状态码表示服务器已经开始处理客户端的请求，并且已经有一些响应数据可以返回给客户端，但是由于某些原因（比如需要等待某些资源加载完成），服务器无法立即返回完整的响应，因此会在响应头部中附加一些预加载的信息，告诉客户端一些即将到来的响应内容。客户端可以根据这些预加载信息来提前做一些处理，加速页面加载等操作。</p>\n<p>425 Too Early 状态码也是类似的，它表示服务器已经开始处理客户端的请求，但是由于某些原因（比如需要等待某些资源加载完成），服务器无法立即返回完整的响应，因此会返回一个空的响应体，但是在响应头部中附加一些预加载的信息，告诉客户端一些即将到来的响应内容。客户端可以根据这些预加载信息来提前做一些处理，加速页面加载等操作。</p>\n<p>两个状态码之间的区别在于返回的响应体不同。103 状态码返回的响应体中包含了一些预加载的信息，而 425 状态码返回的响应体是空的，只有响应头部中包含了一些预加载的信息。因此，客户端需要根据实际情况来选择使用哪种状态码。</p>\n<p>需要注意的是，这两个状态码目前还比较新，不是所有的 HTTP 客户端和服务器都支持，因此在使用时需要谨慎。</p>\n<p><strong>425 Too Early 不是错误码吗？</strong></p>\n<p>425 Too Early 状态码是 HTTP 协议定义中的一种状态码，它并不一定代表错误，而是表示服务器已经开始处理请求，但是还没有准备好发送完整的响应，需要客户端稍后再次发送请求。</p>\n<p>一般情况下，客户端在发送 HTTP 请求后，服务器会立即返回响应。但是在某些情况下，服务器需要更长的时间来准备完整的响应，例如在处理大量数据、计算密集型任务或等待外部资源时。在这种情况下，服务器可以返回 425 Too Early 状态码，告诉客户端需要稍后再次发送请求来获取完整的响应。</p>\n<p>需要注意的是，425 状态码是 HTTP&#x2F;2 协议中引入的一个新状态码，在旧版本的 HTTP 协议中并不支持。因此，如果您的应用程序需要支持 425 状态码，需要确保您的服务器和客户端都支持 HTTP&#x2F;2 协议。</p>\n</p>\n</details>\n<h4 id=\"426-Upgrade-Required\"><a href=\"#426-Upgrade-Required\" class=\"headerlink\" title=\"426 Upgrade Required\"></a>426 Upgrade Required</h4><p><code>426 Upgrade Required</code> 表示: 服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。</p>\n<p>服务器会在响应中使用 <code>Upgrade (en-US) </code>首部来指定要求的协议。</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><strong>425 Too Early 不是为了响应重放攻击吗？</strong></p>\n<p><strong>您说的是 426 Upgrade Required 状态码，它是为了防止重放攻击而引入的状态码，而不是 425 Too Early 状态码。</strong></p>\n<p>426 Upgrade Required 状态码表示客户端请求的资源需要通过升级协议的方式来访问，比如从 HTTP&#x2F;1.1 协议升级到 HTTP&#x2F;2 协议。这个状态码的主要作用是防止重放攻击，即攻击者通过重复发送相同的请求来消耗服务器资源。</p>\n<p>服务器在返回 426 状态码时，会在响应头部中包含一个 Upgrade 头部字段，告诉客户端应该使用哪种协议来访问资源。客户端在收到 426 状态码后，需要根据 Upgrade 头部字段中的信息升级协议，并重新发送请求来访问资源。</p>\n<p>需要注意的是，425 Too Early 状态码和 426 Upgrade Required 状态码虽然都是比较新的 HTTP 状态码，但是它们的作用和含义是不同的。425 状态码是用来优化 HTTP 响应速度的，而 426 状态码是用来防止重放攻击的。</p>\n\n</details>\n<h4 id=\"428-Precondition-Required\"><a href=\"#428-Precondition-Required\" class=\"headerlink\" title=\"428 Precondition Required\"></a>428 Precondition Required</h4><p>响应状态码 <code>428 Precondition Required</code> 表示: 服务器端要求发送条件请求。</p>\n<p>一般的，这种情况意味着必要的条件首部——如<code>If-Match</code> ——的缺失。</p>\n<p>当一个条件首部的值不能匹配服务器端的状态的时候，应答的状态码应该是 <code>412 Precondition Failed</code>，前置条件验证失败。</p>\n<h4 id=\"412-与-428-区别\"><a href=\"#412-与-428-区别\" class=\"headerlink\" title=\"412 与 428 区别\"></a>412 与 428 区别</h4><ul>\n<li><code>412</code> <code>一个条件首部的值</code>不能匹配服务器端的状态的时候，应答的状态码应该是 <code>412 Precondition Failed</code>，前置条件验证失败。</li>\n<li><code>428</code> <code>必要的条件首部的缺失</code>——如<code>If-Match</code></li>\n</ul>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p>412 Precondition Failed 和 428 Precondition Required 都是 HTTP 协议定义中的状态码，它们都表示客户端请求的资源无法满足服务器的某些先决条件，但是它们的使用场景和含义是不同的。</p>\n<p>具体来说：</p>\n<ul>\n<li>412 Precondition Failed 状态码通常在使用条件请求方法（例如，使用 HTTP 中的 If-Match 或 If-None-Match 头部字段）时返回，表示服务器已经理解了客户端的请求，但是请求中包含的某些条件不满足，导致服务器无法处理请求。例如，如果客户端发送了一个更新资源的请求，但是请求中包含的 ETag 值与服务器上的当前 ETag 值不匹配，服务器就会返回 412 状态码，告诉客户端需要先获取最新的资源版本。</li>\n<li>428 Precondition Required 状态码通常在服务器要求客户端在请求资源时包含某些条件时返回，表示服务器要求客户端在请求资源时必须包含某些特定的请求头部字段，否则服务器无法处理请求。例如，如果服务器要求客户端在更新资源时必须包含 If-Match 头部字段，但是客户端没有发送该请求头部字段，服务器就会返回 428 状态码，告诉客户端需要先包含必要的请求头部字段。</li>\n</ul>\n<p>因此，尽管 412 和 428 状态码都表示请求无法满足服务器的先决条件，但是它们的使用场景和含义是不同的，需要根据具体的场景来选择使用哪种状态码。</p>\n</p>\n</details>\n<h4 id=\"429-Too-Many-Requests\"><a href=\"#429-Too-Many-Requests\" class=\"headerlink\" title=\"429 Too Many Requests\"></a>429 Too Many Requests</h4><p>响应状态码 <code>429 Too Many Requests</code> 表示在一定的时间内用户发送了太多的请求，即<code>超出了“频次限制”</code>。</p>\n<p>在响应中，可以提供一个 <code>Retry-After</code> 首部来提示用户需要等待多长时间之后再发送新的请求。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 429 Too Many Requests\nContent-Type: text&#x2F;html\nRetry-After: 3600\n</code></pre>\n\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>429 Too Many Requests 是 HTTP 协议定义中的状态码，它表示客户端在指定的时间内发送了过多的请求，超出了服务器的处理能力。</p>\n<p>在实际应用中，为了防止客户端发送过多的请求导致服务器负载过重，通常会对客户端的请求频率进行限制。当客户端发送的请求数量超出了服务器允许的范围时，服务器就会返回 429 状态码，告诉客户端暂时无法处理该请求。</p>\n<p>429 状态码通常伴随着 Retry-After 头部字段一起返回，用于告诉客户端需要等待多长时间之后才可以再次发送请求。Retry-After 头部字段可以是一个 HTTP 日期，也可以是一个相对时间（以秒为单位），客户端可以根据该字段来决定何时重新发送请求。</p>\n<p>需要注意的是，429 状态码只是一个暂时的错误码，客户端可以稍后重新发送请求，直到服务器能够正常处理请求为止。但是客户端需要注意调整请求频率，避免再次触发 429 状态码。</p>\n\n</details>\n<h4 id=\"431-Request-Header-Fields-Too-Large\"><a href=\"#431-Request-Header-Fields-Too-Large\" class=\"headerlink\" title=\"431 Request Header Fields Too Large\"></a>431 Request Header Fields Too Large</h4><p>服务器不愿处理请求，因为一个或多个头字段过大</p>\n<p><strong>刚整理完，就收到反馈了，这也太神奇了吧</strong></p>\n<div style=\"display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;\">\n<img src=\"http://t-blog-images.aijs.top/img/202207261508843.webp\" style=\"width:500px;max-width:100%\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202207261521540.webp\" style=\"width:500px;max-width:100%\" />\n\n</div>\n\n<h4 id=\"440-Login-Time-out\"><a href=\"#440-Login-Time-out\" class=\"headerlink\" title=\"440 Login Time-out\"></a>440 Login Time-out</h4><p>客户端 session 超时失效，需要重新登录。</p>\n<h4 id=\"451-Unavailable-For-Legal-Reasons\"><a href=\"#451-Unavailable-For-Legal-Reasons\" class=\"headerlink\" title=\"451 Unavailable For Legal Reasons\"></a>451 Unavailable For Legal Reasons</h4><p>因法律的要求而被拒绝</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p>451 Unavailable For Legal Reasons 是 HTTP 协议定义中的状态码，它表示服务器因为法律原因无法提供请求的资源。</p>\n<p>例如，当一个政府机构需要阻止某些具有敏感性质的内容（如色情内容、侵权内容等）时，就可以使用 451 状态码来提示客户端该资源已被屏蔽。在这种情况下，服务器应该在响应中包含一个可读性强的错误消息，以便客户端了解资源不可用的原因。</p>\n<p>需要注意的是，使用 451 状态码并不是强制要求，具体使用与否要根据实际情况进行判断。如果服务器因为法律原因无法提供请求的资源，那么返回 451 状态码是合理的；但是如果服务器因为其他原因无法提供请求的资源（例如，服务器宕机、网络故障等），那么使用其他适当的状态码（例如 503 Service Unavailable）更为恰当。</p>\n</p>\n</details>\n<h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p><code>500 Internal Server Error</code> 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。</p>\n<p>这个错误代码是一个通用的“万能”响应代码。有时候，对于类似于 500 这样的错误，服务器管理员会更加详细地记录相关的请求信息来防止以后同样错误的出现。</p>\n<h4 id=\"501-Not-Implemented\"><a href=\"#501-Not-Implemented\" class=\"headerlink\" title=\"501 Not Implemented\"></a>501 Not Implemented</h4><p>响应状态码 <code>501 Not Implemented </code>服务器错误响应码表示: 请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。</p>\n<p>请注意，你无法修复 501 错误，需要被访问的 web 服务器去修复该问题。</p>\n<h4 id=\"502-Bad-Gateway\"><a href=\"#502-Bad-Gateway\" class=\"headerlink\" title=\"502 Bad Gateway\"></a>502 Bad Gateway</h4><p>响应状态码 <code>502 Bad Gateway</code> 是一种 HTTP 协议的服务端错误状态代码，它表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>备注： 网关在计算机网络体系中可以指代不同的设备，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。</p>\n\n</div>\n<p>一般会有 <code>链路追踪</code>, 通过<code>trackId</code>可以查询到什么地方出的问题</p>\n<h4 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h4><p>响应状态码<code>503 Service Unavailable</code> 是一种 HTTP 协议的服务器端错误状态代码，它表示服务器尚未处于可以接受请求的状态。</p>\n<p>通常造成这种情况的原因是: 由于服务器停机维护或者已超载。</p>\n<p>注意在发送该响应的时候，应该同时发送一个对用户友好的页面来解释问题发生的原因。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 <code>Retry-After</code> 首部字段中包含服务恢复的预期时间。</p>\n<p>缓存相关的首部在与该响应一同发送时应该小心使用，<code>因为 503 状态码通常应用于临时状况下，而此类响应一般不应该进行缓存</code>。</p>\n<h4 id=\"504-Gateway-Timeout\"><a href=\"#504-Gateway-Timeout\" class=\"headerlink\" title=\"504 Gateway Timeout\"></a>504 Gateway Timeout</h4><p>响应状态码<code>504 Gateway Timeout</code> 是一种 HTTP 协议的服务器端错误状态代码，表示: <strong><code>扮演网关</code>或者<code>代理的服务器</code>无法在规定的时间内获得想要的响应</strong>。</p>\n<p>Gateway（网关）在计算机网络体系中可以指代不同的设备，504 错误通常不是在客户端可以修复的，而是需要由途径的 Web 服务器或者代理服务器对其进行修复。</p>\n<h4 id=\"505-HTTP-Version-Not-Supported\"><a href=\"#505-HTTP-Version-Not-Supported\" class=\"headerlink\" title=\"505 HTTP Version Not Supported\"></a>505 HTTP Version Not Supported</h4><p>响应状态码<code>505 HTTP Version Not Supported </code>是一种 HTTP 协议的服务器端错误状态代码，表示: <strong>服务器不支持请求所使用的 HTTP 版本</strong>。</p>\n<h4 id=\"506-Variant-Also-Negotiates\"><a href=\"#506-Variant-Also-Negotiates\" class=\"headerlink\" title=\"506 Variant Also Negotiates\"></a>506 Variant Also Negotiates</h4><p>506 码表示: <strong>内部服务器配置错误</strong>，其中所选变量&#x2F;变元自身被配置为参与内容协商，因此并不是合适的协商端点。</p>\n<h4 id=\"507-Insufficient-Storage\"><a href=\"#507-Insufficient-Storage\" class=\"headerlink\" title=\"507 Insufficient Storage\"></a>507 Insufficient Storage</h4><p>响应状态码 <code>507 Insufficient Storage</code> 响应状态码 可以在 WebDAV 协议（基于 web 的分布式创作和版本控制，参见 RFC 4918）中给出。</p>\n<p><strong>507 码表示服务器不能存储相关内容</strong>。准确地说，一个方法可能没有被执行，因为服务器不能存储其表达形式，这里的表达形式指：方法所附带的数据，而且其请求必需已经发送成功。</p>\n<details class=\"custom-details\">\n<summary>chatGPT</summary>\n<p><p>507 Insufficient Storage 是 HTTP 协议定义中的状态码，表示服务器无法完成请求，因为它没有足够的存储空间来完成该请求。这通常发生在服务器存储空间已满的情况下。</p>\n<p>在实际应用中，服务器通常会对存储空间进行限制，以防止存储空间被耗尽导致系统崩溃。当服务器存储空间不足时，就会返回 507 状态码，告诉客户端无法完成请求。此时，客户端可以尝试通过删除一些不必要的文件或增加存储空间来解决该问题。</p>\n<p>需要注意的是，507 状态码通常表示服务器无法处理请求，因此客户端不应该重试相同的请求，而是应该尝试其他的解决方法。如果客户端继续发送相同的请求，可能会导致服务器存储空间进一步耗尽，最终导致服务器崩溃。</p>\n</p>\n</details>\n<h4 id=\"508-Loop-Detected\"><a href=\"#508-Loop-Detected\" class=\"headerlink\" title=\"508 Loop Detected\"></a>508 Loop Detected</h4><p>响应状态码 <code>508 Loop Detected</code> 状态码可以在 WebDAV 协议（基于 Web 的分布式创作和版本控制）中给出。</p>\n<p><strong>508 码表示服务器中断一个操作，因为它在处理具有“Depth: infinity”的请求时遇到了一个无限循环。508 码表示整个操作失败</strong>。</p>\n<h4 id=\"510-Not-Extended\"><a href=\"#510-Not-Extended\" class=\"headerlink\" title=\"510 Not Extended\"></a>510 Not Extended</h4><p>响应状态码 <code>510 Not Extended</code> 响应状态码在 HTTP 扩展框架协议（参见 RFC 2774）中发送。</p>\n<p>在 HTTP 扩展框架协议中 ，<strong>一个客户端可以发送一个包含扩展声明的请求，该声明描述了要使用的扩展</strong>。<strong>如果服务器接收到这样的请求，但是请求不支持任何所描述的扩展</strong>，那么服务器将使用 510 状态码进行响应。</p>\n<h4 id=\"511-Network-Authentication-Required\"><a href=\"#511-Network-Authentication-Required\" class=\"headerlink\" title=\"511 Network Authentication Required\"></a>511 Network Authentication Required</h4><p>响应状态码<code>511 Network Authentication Required</code> 表示客户端需要通过验证才能使用该网络。</p>\n<p>该状态码不是由源头服务器生成的，而是由控制网络访问的拦截代理服务器生成的。</p>\n<p><strong>网络运营商们有时候会在准许使用网络之前要求用户进行身份验证、接受某些条款，或者进行其他形式的与用户之间的互动（例如在网络咖啡厅或者机场）</strong>。他们通常用用户设备的 <code>MAC 地址</code>来进行识别。</p>\n<details class=\"custom-details\">\n<summary>chatGPT</summary>\n<p>511 Network Authentication Required 是 HTTP 协议定义中的状态码，表示客户端需要进行身份验证以便继续访问请求的资源，同时需要进行网络认证。</p>\n<p>在实际应用中，当客户端访问某些资源时，服务器可能会要求客户端进行身份验证，以确认客户端的身份。此外，为了保护网络安全，服务器可能还要求客户端进行网络认证，以确保客户端的请求是合法的。</p>\n<p>当服务器返回 511 状态码时，客户端必须提供适当的凭据，以便服务器确认客户端的身份和请求的合法性。例如，客户端可以提供用户名和密码，或者提供数字证书等。</p>\n<p>需要注意的是，</p>\n<p><strong>511 状态码与 401 Unauthorized 状态码的区别在于，</strong></p>\n<ol>\n<li>511 状态码要求客户端进行网络认证，而 401 状态码只要求客户端进行身份验证。</li>\n<li>此外，511 状态码通常与 VPN 等虚拟专用网络相关，用于保护网络安全</li>\n</ol>\n\n</details>\n<h2 id=\"HTTP-状态码什么意思\"><a href=\"#HTTP-状态码什么意思\" class=\"headerlink\" title=\"HTTP 状态码什么意思\"></a>HTTP 状态码什么意思</h2><h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/431672713\" target=\"_blank\" >深入剖析 HTTP3 协议</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100\" target=\"_blank\" >Web 开发技术&gt;HTTP&gt;HTTP 响应状态码</a></p>\n<p><a href=\"https://www.wbolt.com/http-error-431.html\" target=\"_blank\" >HTTP Error 431：修复请求标头字段太大的 3 种方法</a></p>\n<p><a href=\"https://blog.csdn.net/qq_37450814/article/details/114672359\" target=\"_blank\" >HTTP 状态码含义</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" >维基百科 HTTP 状态码</a></p>\n","text":"HTTP ⽅法HTTP1.0 定义了三种请求⽅法： GET, POST 和 HEAD ⽅法HTTP1.1 新增了五种请求⽅法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT HTTP ⽅法的理论作⽤ GET: 通常⽤于请求服务器发送某些资源 POST:...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E2%BD%85%E6%B3%95\"><span class=\"toc-text\">HTTP ⽅法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E2%BD%85%E6%B3%95%E7%9A%84%E7%90%86%E8%AE%BA%E4%BD%9C%E2%BD%A4\"><span class=\"toc-text\">HTTP ⽅法的理论作⽤</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">GET 和 POST 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PUT-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">PUT 和 POST 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PUT-%E5%92%8C-PATCH-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">PUT 和 PATCH 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">HTTP 的状态码有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#302-307-303-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">302,307,303 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#API-%E7%BD%91%E5%85%B3%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">API 网关是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%9A%84-keep-alive-%E6%98%AF%E2%BC%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTP 的 keep-alive 是⼲什么的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#keep-alive-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">keep-alive 是什么，有什么优缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86-HTTP-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81-HTTPS%EF%BC%9F\"><span class=\"toc-text\">为什么有了 HTTP 为什么还要 HTTPS？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTPS 是如何保证安全的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">对称加密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%BE%AE%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">⾮对称加密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E2%BC%88\"><span class=\"toc-text\">中间⼈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CA-%E8%AF%81%E4%B9%A6\"><span class=\"toc-text\">CA 证书</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%81%E4%B9%A6%E7%AF%A1%E6%94%B9\"><span class=\"toc-text\">证书篡改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">数字签名</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP2-%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">HTTP2 特点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP2-%E7%9A%84%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">HTTP2 的缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP3-%E8%A7%A3%E5%86%B3%E4%BA%86-HTTP2-%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">HTTP3 解决了 HTTP2 哪些问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#QUIC-%E5%8D%8F%E8%AE%AE%E5%B0%86-TLS-%E5%8A%A0%E5%AF%86%E5%92%8C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%90%88%E5%B9%B6%E5%88%B0%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">QUIC 协议将 TLS 加密和传输协议合并到一起，如何理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP2-%E4%B8%8E-HTTP3-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">HTTP2 与 HTTP3 的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#QUIC-%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%87%8F%E5%B0%91%E6%8F%A1%E6%89%8B%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E5%BB%B6%E8%BF%9F\"><span class=\"toc-text\">QUIC 协议，为什么可以减少握手和连接建立的延迟</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#QUIC-%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81-0-RTT-%E6%8F%A1%E6%89%8B-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">QUIC 协议支持 0-RTT 握手 是什么</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%9A%84%E7%BC%93%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">HTTP 的缓存的过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">强缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Expires\"><span class=\"toc-text\">Expires</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Cache-Control\"><span class=\"toc-text\">Cache-Control</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">协商缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Last-Modified-x2F-If-Modified-Since\"><span class=\"toc-text\">Last-Modified&#x2F;If-Modified-Since</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ETag-x2F-If-None-Match\"><span class=\"toc-text\">ETag&#x2F;If-None-Match</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">HTTP 状态码目录</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#100-Continue\"><span class=\"toc-text\">100 Continue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#101-Switching-Protocol\"><span class=\"toc-text\">101 Switching Protocol</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#102-Processing\"><span class=\"toc-text\">102 Processing</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#103-Early-Hints\"><span class=\"toc-text\">103 Early Hints</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#200-OK\"><span class=\"toc-text\">200 OK</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#201-Created\"><span class=\"toc-text\">201 Created</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#202-Accepted\"><span class=\"toc-text\">202 Accepted</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#203-Non-Authoritative-Information\"><span class=\"toc-text\">203 Non-Authoritative Information</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#204-No-Content\"><span class=\"toc-text\">204 No Content</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#205-Reset-Content\"><span class=\"toc-text\">205 Reset Content</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#206-Partial-Content\"><span class=\"toc-text\">206 Partial Content</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#300-Multiple-Choices\"><span class=\"toc-text\">300 Multiple Choices</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#301-Moved-Permanently\"><span class=\"toc-text\">301 Moved Permanently</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#302-Found\"><span class=\"toc-text\">302 Found</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#303-See-Other\"><span class=\"toc-text\">303 See Other</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#304-Not-Modified\"><span class=\"toc-text\">304 Not Modified</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#305-Use-Proxy\"><span class=\"toc-text\">305 Use Proxy</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#306-Switch-Proxy-%E5%BA%9F%E5%BC%83\"><span class=\"toc-text\">306 Switch Proxy 废弃</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#307-Temporary-Redirect\"><span class=\"toc-text\">307 Temporary Redirect</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#307-302-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">307,302 的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#301-%E4%B8%8E-308-%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">301 与 308 状态码的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#308-Permanent-Redirect\"><span class=\"toc-text\">308 Permanent Redirect</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#301-308-302-307-303-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">301,308,302,307,303 区别</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#400-Bad-Request\"><span class=\"toc-text\">400 Bad Request</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#401-Unauthorized\"><span class=\"toc-text\">401 Unauthorized</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#402-Payment-Required\"><span class=\"toc-text\">402 Payment Required</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#403-Forbidden\"><span class=\"toc-text\">403 Forbidden</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#404-Not-Found\"><span class=\"toc-text\">404 Not Found</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#405-Method-Not-Allowed\"><span class=\"toc-text\">405 Method Not Allowed</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#406-Not-Acceptable\"><span class=\"toc-text\">406 Not Acceptable</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#407-Proxy-Authentication-Required\"><span class=\"toc-text\">407 Proxy Authentication Required</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#408-Request-Timeout\"><span class=\"toc-text\">408 Request Timeout</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#409-Conflict\"><span class=\"toc-text\">409 Conflict</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#410-Gone\"><span class=\"toc-text\">410 Gone</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#411-Length-Required\"><span class=\"toc-text\">411 Length Required</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#412-Precondition-Failed\"><span class=\"toc-text\">412 Precondition Failed</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#413-Payload-Too-Large\"><span class=\"toc-text\">413 Payload Too Large</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#414-URI-Too-Long\"><span class=\"toc-text\">414 URI Too Long</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#415-Unsupported-Media-Type\"><span class=\"toc-text\">415 Unsupported Media Type</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#416-Range-Not-Satisfiable\"><span class=\"toc-text\">416 Range Not Satisfiable</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#417-Expectation-Failed\"><span class=\"toc-text\">417 Expectation Failed</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#418-I%E2%80%99m-a-teapot\"><span class=\"toc-text\">418 I’m a teapot</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#422-Unprocessable-Entity\"><span class=\"toc-text\">422 Unprocessable Entity</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#423-Locked\"><span class=\"toc-text\">423 Locked</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#424-Failed-Dependency\"><span class=\"toc-text\">424 Failed Dependency</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#425-Too-Early\"><span class=\"toc-text\">425 Too Early</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#426-Upgrade-Required\"><span class=\"toc-text\">426 Upgrade Required</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#428-Precondition-Required\"><span class=\"toc-text\">428 Precondition Required</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#412-%E4%B8%8E-428-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">412 与 428 区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#429-Too-Many-Requests\"><span class=\"toc-text\">429 Too Many Requests</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#431-Request-Header-Fields-Too-Large\"><span class=\"toc-text\">431 Request Header Fields Too Large</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#440-Login-Time-out\"><span class=\"toc-text\">440 Login Time-out</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#451-Unavailable-For-Legal-Reasons\"><span class=\"toc-text\">451 Unavailable For Legal Reasons</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#500-Internal-Server-Error\"><span class=\"toc-text\">500 Internal Server Error</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#501-Not-Implemented\"><span class=\"toc-text\">501 Not Implemented</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#502-Bad-Gateway\"><span class=\"toc-text\">502 Bad Gateway</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#503-Service-Unavailable\"><span class=\"toc-text\">503 Service Unavailable</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#504-Gateway-Timeout\"><span class=\"toc-text\">504 Gateway Timeout</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#505-HTTP-Version-Not-Supported\"><span class=\"toc-text\">505 HTTP Version Not Supported</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#506-Variant-Also-Negotiates\"><span class=\"toc-text\">506 Variant Also Negotiates</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#507-Insufficient-Storage\"><span class=\"toc-text\">507 Insufficient Storage</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#508-Loop-Detected\"><span class=\"toc-text\">508 Loop Detected</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#510-Not-Extended\"><span class=\"toc-text\">510 Not Extended</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#511-Network-Authentication-Required\"><span class=\"toc-text\">511 Network Authentication Required</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">HTTP 状态码什么意思</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-html","uid":"2854d1d5923e1e62aed568f709662bf4","slug":"2022-07-17html","date":"2022-07-17T01:44:42.000Z","updated":"2023-08-03T23:12:09.893Z","comments":true,"path":"api/articles/2022-07-17html.json","keywords":null,"cover":[],"text":"doctype 的作⽤是什么？DOCTYPE 是 html5 标准⽹⻚声明，且必须声明在 HTML ⽂档的第⼀⾏。 来告知浏览器的解析器⽤什么⽂档标准解析这个⽂档，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析 ⽂档解析类型有： BackCo...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-TCP","uid":"ca603a006bae6531fc585f1adf1fac4c","slug":"2022-07-15TCP","date":"2022-07-15T07:23:46.000Z","updated":"2023-08-01T12:36:45.467Z","comments":true,"path":"api/articles/2022-07-15TCP.json","keywords":null,"cover":[],"text":"TCP 的特性 TCP 提供⼀种⾯向连接的、可靠的、字节流 服务 在⼀个 TCP 连接中，仅双⽅进⾏彼此通信。⼴播和多播不能⽤于 TCP TCP 使⽤校验、确认和重传机制来保证可靠传输 TCP 使用分节排序和累积确认，来保证数据的顺序不变, 和⾮重复 TCP 使⽤滑动窗⼝来实现流...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}