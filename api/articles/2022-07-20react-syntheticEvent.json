{"title":"React@16.5.0 syntheticEvent","uid":"8cd3fa1949a115d76dd37b87c1175bed","slug":"2022-07-20react-syntheticEvent","date":"2022-07-20T01:18:53.000Z","updated":"2022-09-16T15:02:19.077Z","comments":true,"path":"api/articles/2022-07-20react-syntheticEvent.json","keywords":null,"cover":[],"content":"<h2 id=\"本文说明\"><a href=\"#本文说明\" class=\"headerlink\" title=\"本文说明\"></a>本文说明</h2><p>本文主要内容是 <a href=\"https://github.com/facebook/react/tree/v16.5.0\" target=\"_blank\" >React v16.5.0</a>, 部分内容会涉及到 React v17+, React v17+合成事件与 React16 有很大差异</p>\n<h2 id=\"React-和事件系统概述\"><a href=\"#React-和事件系统概述\" class=\"headerlink\" title=\"React 和事件系统概述\"></a>React 和事件系统概述</h2><p><a href=\"https://github.com/facebook/react/blob/71c0e05ba79e2e12556980ffbab264b41fdc19cd/packages/react-dom/src/events/ReactBrowserEventEmitter.js#L52\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.---&gt;|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.---&gt;|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter&#x2F;Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n *&#x2F;</code></pre>\n\n<h2 id=\"为什么-React-需要自己实现一套事件系统？\"><a href=\"#为什么-React-需要自己实现一套事件系统？\" class=\"headerlink\" title=\"为什么 React 需要自己实现一套事件系统？\"></a>为什么 React 需要自己实现一套事件系统？</h2><img src=\"http://t-blog-images.aijs.top/img/20220720095157.webp\" style=\"max-width: 100%; width: 600px\" />\n\n<p>这个问题主要是为了<code>性能</code>和<code>复用</code>两个方面来考虑。</p>\n<h3 id=\"首先对于性能来说\"><a href=\"#首先对于性能来说\" class=\"headerlink\" title=\"首先对于性能来说\"></a>首先对于<code>性能</code>来说</h3><p>React 作为一套 View 层面的框架，通过渲染得到 vDOM，再由 diff 算法决定 DOM 树那些结点需要新增、替换或修改，假如直接在 DOM 结点插入原生事件监听，则会导致频繁的调用 addEventListener 和 removeEventListener，造成性能的浪费。所以 React 采用了事件代理的方法，对于大部分事件 1 而言都在 document 上做监听，然后<code>根据Event中的target来判断事件触发的结点</code>。</p>\n<p>其次 React 合成的 SyntheticEvent 采用了<code>池的思想</code>，从而达到节约内存，避免频繁的创建和销毁事件对象的目的。这也是<code>“如果我们需要异步使用一个 syntheticEvent，需要执行 event.persist()才能防止事件对象被释放”</code>的原因。</p>\n<p>最后在 React 源码中随处可见 <code>batch 做批量更新</code>，基本上凡是可以批量处理的事情（最普遍的 setState）React 都会将中间过程保存起来，留到最后面 flush（渲染，并最终提交到 DOM 树上）掉。就如<code>浏览器对 DOM 树进行 Style，Layout，Paint 一样，都不会在操作 ele.style.color=&#39;red&#39;;之后马上执行，只会将这些操作打包起来并最终在需要渲染的时候再做渲染,</code>。<a href=\"https://v.aijs.top/post/2022-07-17css\" target=\"_blank\" >队列机制来批量更新布局 (1000ms&#x2F;60 &#x3D; 16.6ms 进行一次渲染)</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">ele.style.color &#x3D; &quot;red&quot;;\nele.style.color &#x3D; &quot;blue&quot;;\nele.style.color &#x3D; &quot;red&quot;;\n&#x2F;&#x2F; 浏览器只会渲染一次;</code></pre>\n\n<h3 id=\"而对于复用来说\"><a href=\"#而对于复用来说\" class=\"headerlink\" title=\"而对于复用来说\"></a>而对于复用来说</h3><p>React 看到在不同的浏览器和平台上，用户界面上的事件其实非常相似，例如普通的 click，change 等等。React 希望通过封装一层事件系统，将不同平台的原生事件都封装成 <code>SyntheticEvent</code>。</p>\n<ul>\n<li><p>使得<code>不同平台只需要通过加入EventEmitter以及对应的Renderer就能使用相同的一个事件系统</code>，WEB 平台上加入 <code>ReactBrowserEventEmitter</code>，Native 上加入 <code>ReactNativeEventEmitter</code>。如下图，对于不同平台，React 只需要替换掉左边部分，而右边 EventPluginHub 部分可以保持复用。</p>\n</li>\n<li><p>而<code>对于不同的浏览器而言，React帮我们统一了事件，做了浏览器的兼容</code>，例如对于 transitionEnd,webkitTransitionEnd,MozTransitionEnd 和 oTransitionEnd, React 都会集合成 topAnimationEnd，所以我们只用处理这一个标准的事件即可。</p>\n</li>\n</ul>\n<img src=\"http://t-blog-images.aijs.top/img/20220720100225.webp\" />\n\n<h2 id=\"React-的事件系统是怎么运作起来的？\"><a href=\"#React-的事件系统是怎么运作起来的？\" class=\"headerlink\" title=\"React 的事件系统是怎么运作起来的？\"></a>React 的事件系统是怎么运作起来的？</h2><h3 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h3><p>我们来看一下我们在 JSX 中写的 onClickhandler 是怎么被记录到 DOM 结点上，并且在 document 上做监听的。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720100423.webp\" />\n\n<p>React 对于大部分事件的绑定都是使用<code>trapBubbledEvent</code>和<code>trapCapturedEvent</code>这两个函数来注册的。如上图所示，当我们执行了 render 或者 setState 之后，React 的 <code>Fiber</code> 调度系统，<span style=\"text-decoration: underline\">会在最后 commit 到 DOM 树之前, 执行<code>trapBubbledEvent</code>或<code>trapCapturedEvent</code>，在<code>document</code>节点上绑定回调</span>（通过执行<code>addEventListener</code>在 document 结点上绑定对应的<code>dispatch</code>函数,作为回调负责监听类型为<code>topLevelType</code>的事件）。</p>\n<p>这里面的 <code>dispatchInteractiveEvent</code> 和 <code>dispatchEvent</code> 两个回调函数的区别为，React16 开始换掉了原本 <code>Stack Reconciliation</code> 成 <code>Fiber</code> 希望实现异步渲染（React16 仍未默认打开，仍需使用 <code>unstable_</code>开头的 api，此特性与例子 2 有关，将在文章最后配图解释），所以异步渲染的情况下假如我点了两次按钮，那么第二次按钮响应的时候，可能第一次按钮的 handlerA 中调用的 <code>setState</code> 还未最终被 commit 到 DOM 树上，这时需要把第一次按钮的结果先给 flush 掉并 commit 到 DOM 树，才能够保持一致性。这个时候就会用到 <code>dispatchInteractiveEvent</code>。可以理解成 <code>dispatchInteractiveEvent</code> 在执行前都会确保之前所有操作都已最总 commit 到 DOM 树，再开始自己的流程，并最终触发 dispatchEvent。但由于 React16 仍是同步渲染的，所以这两个函数在目前的表现是一致的，React17 默认打开的异步渲染功能。</p>\n<p>到现在我们已经在 document 结点上监听了事件了，现在需要来看如何将我们在 jsx 中写的 handler 存起来对应到相应的结点上。</p>\n<p>在我们每次新建或者更新结点时，React 会调用 <code>createInstance</code> 或者 <code>commitUpdate</code> 这两个函数，而这两个函数都会最终调用 <code>updateFiberProps</code> 这个函数，将 props 也就是我们的 onClick，onChange 等 handler 给存到 DOM 结点上。</p>\n<p>至此，我们我们已经在 document 上监听了事件，并且将 handler 存在对应 DOM 结点。接下来需要看 React 怎么监听并处理浏览器的原生事件，最终触发对应的 handler 了。</p>\n<h3 id=\"事件触发\"><a href=\"#事件触发\" class=\"headerlink\" title=\"事件触发\"></a>事件触发</h3><p>动画见原文 <a href=\"https://www.lzane.com/tech/react-event-system-and-source-code/#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91\" target=\"_blank\" >Hype 动画</a></p>\n<p>动画应该是使用 <a href=\"https://www.hypeapp.cn/\" target=\"_blank\" >Hype 工具</a> 制作的</p>\n<p>以简单的 <code>click</code> 事件为例，通过事件绑定我们已经在 <code>document</code> 上监听了 <code>click</code> 事件，当我们真正点击了这个按钮的时候，原生的事件是如何进入 React 的管辖范围的？如何合成 <code>SyntheticEvent</code> 以及如何模拟捕获和冒泡的？以及最后我们在 jsx 中写的 <code>onClickhandler</code> 是如何被最终触发的？带着这些问题，我们一起来看一下事件触发阶段。</p>\n<p>大概用下图这种方式来解析代码，左边是我点击一个绑定了 <code>handleClick</code> 的按钮后的 js 调用栈，右边是每一步的代码，均已删除部分不影响理解的代码。希望通过这种方式能使大家更易理解 React 的事件触发机制。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720101536.webp\" />\n\n<p>当我们点击一个按钮是，click 事件将会最终冒泡至 document，并触发我们监听在 document 上的 <code>handler dispatchEvent</code>，接着触发 <code>batchedUpdates</code>。<code>batchedUpdates</code> 这个格式的代码在 React 的源码里面会频繁的出现，基本上 React 将所有能够批量处理的事情都会先收集起来，再一次性处理。</p>\n<p>可以看到默认的 <code>isBatching</code> 是 false 的，当调用了一次 <code>batchedUpdates</code>，<code>isBatching</code> 的值将会变成 true，此时如果在接下来的调用中有执行 <code>batchedUpdates</code> 的话，就会直接执行 <code>handleTopLevel</code>,此时的 <code>setState</code> 等不会被更新到 DOM 上。直到调用栈重新回到第一次调用 <code>batchedUpdates</code> 的时候，才会将所有结果一起 <code>flush</code> 掉（更新到 DOM 上）。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720101657.webp\" />\n\n<p><strong>调用栈中的 BatchedUpdates$1 是什么？或者浏览器的 renderer 和 Native 的 renderer 是如果挂在到 React 的事件系统上的?</strong></p>\n<p>其实 React 事件系统里面提供了一个函数 <code>setBatchingImplementation</code>，用来动态挂载不同平台的 renderer，这个也体现了 React 事件系统的复用。（如图右边所示，在 <code>DOM Renderer</code> 里面和 <code>Native Renderer</code> 里面分别调用这个函数动态注入相应的实现）</p>\n<p>这里的 <code>interactiveUpdates 交互式更新是用户交互的结果</code> 和 <code>batchedUpdates</code> 的区别在上文已经解释过，这里就不再赘述。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720102322.webp\" />\n\n<p><code>handleTopLevel</code> 会调用 <code>runExtractedEventsInBatch()</code>，这是 React 事件处理最重要的函数。如上面动画我们看到的，在 EventEmitter 里面做的事，其实主要就是这个函数的两步。</p>\n<ul>\n<li>第一步是根据原生事件合成为合成事件，并且在 vDOM 上模拟捕获冒泡，收集所有需要执行的事件回调构成回调数组。</li>\n<li>第二步是遍历回调数组，触发回调函数。</li>\n</ul>\n<img src=\"http://t-blog-images.aijs.top/img/20220720102726.webp\" />\n\n<p>首先调用 <code>extractEvents</code>，传入原生事件 e，React 事件系统根据可能的事件插件合成合成事件 <code>Synthetic e</code>。 这里我们可以看到调用了 <code>EventConstructor.getPooled()</code>，从事件池中去取一个合成事件对象，如果事件池为空，则新创建一个合成事件对象，这体现了 React 为了性能实现了池的思想。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720102846.webp\" />\n\n<p>然后传入 <code>Propagator</code>，在 vDOM 上模拟捕获和冒泡，并收集所有需要执行的事件回调和对应的结点。<code>traverseTwoPhase</code> 模拟了捕获和冒泡的两个阶段，这里实现很巧妙，简单而言就是<code>正向和反向遍历了一下数组</code>。接着对每一个结点，调用 listenerAtPhase 取出事件绑定时挂载在结点上的回调函数，把它加入回调数组中。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720103038.webp\" />\n\n<p>接着<code>executeDispatchesAndRelease</code>遍历所有合成事件。这里可以看到当一个事件处理完的时候，React 会调用 <code>event.isPersistent()</code>来查看这个合成事件是否需要被持久化，如果不需要就会释放这个合成事件，这也就是为什么当我们需要异步读取操作一个合成事件的时候，需要执行 <code>event.persist()</code>，不然 React 就是在这里释放掉这个事件。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720103344.webp\" />\n\n<p>最后<code>executeDispatchesInOrder</code>这里就是回调函数被真正触发的时候了，取出回调数组 <code>event._dispatchListeners</code>，遍历触发回调函数。并通过 <code>event.isPropagationStopped()</code>这一步来模拟停止冒泡。这里我们可以看到，React 在收集回调数组的时候并不会去管我们是否调用了 <code>stopPropagation</code>，而是会在触发的阶段才会去检查是否需要停止冒泡。</p>\n<p>至此，一个事件回调函数就被触发了，里面如果执行了 setState 等就会等到调用栈弹回到最低部的 interactiveUpdate 中的被最终 flush 掉，构造 vDOM，和好，并最终被 commit 到 DOM 上。</p>\n<p>这就是事件触发的整个过程了，可以回去再看一下 <a href=\"https://www.lzane.com/tech/react-event-system-and-source-code/#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91\" target=\"_blank\" >动画</a>，相信你会更加理解这个过程的。</p>\n<h2 id=\"合成事件与原生事件有怎样的执行顺序？\"><a href=\"#合成事件与原生事件有怎样的执行顺序？\" class=\"headerlink\" title=\"合成事件与原生事件有怎样的执行顺序？\"></a>合成事件与原生事件有怎样的执行顺序？</h2><p><strong>原生事件</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720105851.webp\" style=\"max-width: 100%; width: 600px\" />\n\n<p><strong>原生+合成事件</strong></p>\n<ul>\n<li><p>在 V17 版本前，<code>原生事件的执行时机是恒早于合成事件的执行时机的</code>。</p>\n</li>\n<li><p>V17 版本后，<code>合成事件和原生事件的执行顺序与冒泡/捕获模式相关</code>，</p>\n<ul>\n<li><code>捕获模式，合成事件早于原生事件</code>，</li>\n<li><code>冒泡模式，原生事件早于合成事件</code>。</li>\n</ul>\n</li>\n</ul>\n<img src=\"http://t-blog-images.aijs.top/img/20220720105608.webp\" style=\"max-width: 100%; width: 600px\"/>\n<a href=\"https://www.jianshu.com/p/a68219093f88?u_atoken=96c66af6-4b4a-4701-a859-9a64483aaf89&u_asession=01viVXNjWZraXNpt12w6P6wnowBQUY7pona1ulf4v0L73wrchou90FiDGe5jR2qHfDX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K8qavJ7EhmnVdJXQEmE6OtSPpcarp92QKzyJKyYjREPlmBkFo3NEHBv0PZUm6pbxQU&u_asig=05CjAbRIhQ-YGOcSOjfs7WtQu4QiGw5txoYvhryOA5fFYlLiTzNiJXY_hpLV7WJGud4m5iROx4wQ0h3ZgRAXTxp-H_GUJK2jgttmFqvD-hHIPJWVv2NwOqKBXAP-u08vsfCUr3lwfKUBWx5D2_14AeRY0il1Ll8VBsxPq6mesMKSv9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzbzCM-4012j1JNGnXBVIbaIllXASt-Dgl7eSMGAtA78aWPRPQyB_SKrj-61LB_f61u3h9VXwMyh6PgyDIVSG1W8MY0PcDXuTpF4MGYSjFBSfODK7bhW2M-c7MIitG1svzaDy9TZTqvO1bRJoi-cZx4Wss1heq_Xsfq5Pn8i8a2-MmWspDxyAEEo4kbsryBKb9Q&u_aref=0RPjny1vlRI4nr3ZC63TqSOZUa0%3D#:~:text=%E5%9B%9B%E3%80%81-,React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F,-%E5%9C%A8%20React%20%E4%B8%AD\" target=\"_blank\" >React 合成事件与原生事件执行顺序</a>\n\n<p><a href=\"https://juejin.cn/post/7005129812981317668#:~:text=%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82-,%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F,-%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%AA\" target=\"_blank\" >合成事件和原生事件的执行顺序</a></p>\n<h2 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子 1\"></a>例子 1</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class App extends React.Component &#123;\n  innerClick &#x3D; (e) &#x3D;&gt; &#123;\n    console.log(&quot;A: react inner click.&quot;);\n    &#x2F;&#x2F; e.stopPropagation();\n  &#125;;\n\n  outerClick &#x3D; () &#x3D;&gt; &#123;\n    console.log(&quot;B: react outer click.&quot;);\n  &#125;;\n\n  componentDidMount() &#123;\n    document\n      .getElementById(&quot;outer&quot;)\n      .addEventListener(&quot;click&quot;, () &#x3D;&gt; console.log(&quot;C: native outer click&quot;));\n\n    window.addEventListener(&quot;click&quot;, () &#x3D;&gt;\n      console.log(&quot;D: native window click&quot;)\n    );\n  &#125;\n\n  render() &#123;\n    return (\n      &lt;div id&#x3D;&quot;outer&quot; onClick&#x3D;&#123;this.outerClick&#125;&gt;\n        &lt;button id&#x3D;&quot;inner&quot; onClick&#x3D;&#123;this.innerClick&#125;&gt;\n          BUTTON\n        &lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;</code></pre>\n\n<p>相信看完这篇文章，如果你已经对 React 事件系统有所理解，这道题应该是不难了。</p>\n<ul>\n<li><p>因为 React 事件监听是挂载在 document 上的，所以原生系统在#outer 上监听的回调 C 会最先被输出；接着原生事件冒泡至 <code>document</code> 进入 React 事件系统，React 事件系统模拟捕获冒泡输出 A 和 B；最后 React 事件系统执行完毕回到浏览器继续冒泡到 window，输出 D。</p>\n</li>\n<li><p>浏览器在#outer 上监听原生事件的回调 C 会最先被执行；接着原生事件冒泡至 document 进入 React 事件系统，输出 A，在 React 事件处理中#inner 调用了 stopPropagation，事件被停止冒泡。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 不阻止合成事件冒泡\n&#x2F;&#x2F;     C: native outer click\n&#x2F;&#x2F;     A: react inner click.\n&#x2F;&#x2F;     B: react outer click.\n&#x2F;&#x2F;     D: native window click\n&#x2F;&#x2F; 2. 阻止合成事件冒泡\n&#x2F;&#x2F;     C: native outer click\n&#x2F;&#x2F;     A: react inner click.</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>所以，最好不要混用 React 事件系统和原生事件系统，如果混用了，请保证你清楚知道会发生什么。</p>\n</div>\n<h2 id=\"例子-2\"><a href=\"#例子-2\" class=\"headerlink\" title=\"例子 2\"></a>例子 2</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\n\nclass App extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;\n      editable: false,\n    &#125;;\n  &#125;\n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    console.log(&quot;edit button click!!&quot;);\n    this.setState(&#123; editable: true &#125;);\n  &#125;;\n  handleSubmit &#x3D; (e) &#x3D;&gt; &#123;\n    console.log(&quot;submit event!!&quot;);\n    e.preventDefault();\n  &#125;;\n  render() &#123;\n    return (\n      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;\n        &#123;this.state.editable ? (\n          &lt;button type&#x3D;&quot;submit&quot;&gt;submit&lt;&#x2F;button&gt;\n        ) : (\n          &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;this.handleClick&#125;&gt;\n            edit\n          &lt;&#x2F;button&gt;\n        )&#125;\n      &lt;&#x2F;form&gt;\n    );\n  &#125;\n&#125;\n\nconst rootElement &#x3D; document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App &#x2F;&gt;, rootElement);</code></pre>\n\n<p>首先我们点击 edit 按钮浏览器触发一个 click 事件，冒泡至 document 进入 React 事件系统，React 执行回调调用 setState，此时 React 事件系统对事件的处理执行完毕。由于目前 React 是同步渲染的，所以接着 React 执行 <code>performSyncWork</code> 将该 <code>button 改成 type=&quot;submit&quot;</code>，由于<code>同个位置的结点并且 tag 都为 button</code>，<code>所以 React 复用了这个 button 结点 2</code>，并更新到 DOM 上。此时浏览器对 click 事件执行继续，其发现该结点的 type&#x3D;”submit”，则触发 submit 事件。</p>\n<p><strong>解决的办法就有很多种了</strong>，给 button 加上 key；两个按钮分开写，不要用三元等都可以解决问题。</p>\n<h2 id=\"e-stopPropagation-如何阻止合成事件冒泡？\"><a href=\"#e-stopPropagation-如何阻止合成事件冒泡？\" class=\"headerlink\" title=\"e.stopPropagation() 如何阻止合成事件冒泡？\"></a>e.stopPropagation() 如何阻止合成事件冒泡？</h2><p><code>executeDispatchesInOrder</code>这里就是回调函数被真正触发的时候了，取出回调数组 <code>event._dispatchListeners</code>，遍历触发回调函数。并通过 <code>event.isPropagationStopped()</code>这一步来模拟停止冒泡。这里我们可以看到，React 在收集回调数组的时候并不会去管我们是否调用了 <code>stopPropagation</code>，而是会在触发的阶段才会去检查是否需要停止冒泡。</p>\n<h2 id=\"同级别的两个按钮，使用三元运算符，会出问题？\"><a href=\"#同级别的两个按钮，使用三元运算符，会出问题？\" class=\"headerlink\" title=\"同级别的两个按钮，使用三元运算符，会出问题？\"></a>同级别的两个按钮，使用三元运算符，会出问题？</h2><p>渲染后按钮的事件是否会触发</p>\n<p><strong>React16 例子 2 一定触发 <code>submit</code>, 原因：同步更新</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720104906.webp\" style=\"max-width: 100%; width: 600px\"/>\n\n<p><strong>React17+ 例子 2 不一定触发 <code>submit</code> 原因：异步更新</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720104951.webp\" style=\"max-width: 100%; width: 600px\"/>\n\n<h2 id=\"React-提示-event-persist-，为什么会提示？\"><a href=\"#React-提示-event-persist-，为什么会提示？\" class=\"headerlink\" title=\"React 提示 event.persist() ，为什么会提示？\"></a>React 提示 event.persist() ，为什么会提示？</h2><p>React 在<code>executeDispatchesAndRelease</code>遍历所有合成事件，会调用 <code>event.isPersistent()</code>来查看这个合成事件是否需要被持久化，如果不需要就会释放这个合成事件，这也就是为什么当我们需要异步读取操作一个合成事件的时候，需要执行 <code>event.persist()</code>，不然 React 就是在这里释放掉这个事件。</p>\n<h2 id=\"setState-有时候是异步的，setState-相对于浏览器而言是同步的，如何理解？\"><a href=\"#setState-有时候是异步的，setState-相对于浏览器而言是同步的，如何理解？\" class=\"headerlink\" title=\"setState 有时候是异步的，setState 相对于浏览器而言是同步的，如何理解？\"></a>setState 有时候是异步的，setState 相对于浏览器而言是同步的，如何理解？</h2><p><code>setState</code> 在生命周期以及事件回调中是异步的，也就是会收集起来批量处理。在其它情况下如 <code>promise</code>，<code>setTimeout</code> 中都是同步执行的，也就是调用一次 setState 就会 render 一次并更新到 DOM 上面</p>\n<p>且在 JS 调用栈被弹空时候，必定是已经将结果更新到 DOM 上面了（同步渲染）。这也就是 setState 相对于浏览器是同步的含义。如下图所示</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720104906.webp\" style=\"max-width: 100%; width: 600px\"/>\n\n<p>异步渲染的流程图大概如下图所示，最近一次思考这个问题的时候，发现如果现在是异步渲染的话，那我们的例子二将变成偶现的坑 😂，因为如果 setState 的结果还没被更新到 DOM 上，浏览器就不会触发 submit 事件。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720104951.webp\" style=\"max-width: 100%; width: 600px\"/>\n\n<h2 id=\"异步渲染使用不安全的生命周期会有怎样的现象？\"><a href=\"#异步渲染使用不安全的生命周期会有怎样的现象？\" class=\"headerlink\" title=\"异步渲染使用不安全的生命周期会有怎样的现象？\"></a>异步渲染使用不安全的生命周期会有怎样的现象？</h2><p>例子 2 变成偶现</p>\n<h2 id=\"之前将事件监听挂载到-document-上，现在为何挂载到-root-上？\"><a href=\"#之前将事件监听挂载到-document-上，现在为何挂载到-root-上？\" class=\"headerlink\" title=\"之前将事件监听挂载到 document 上，现在为何挂载到 root 上？\"></a>之前将事件监听挂载到 document 上，现在为何挂载到 root 上？</h2><p>当同个项目里，<code>有多个 React 根节点时</code>（也可能是 React 多版本共存），避免可能的一些操作（如阻止冒泡）会影响到其他 React 节点的正常工作。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220720110733.webp\" style=\"max-width: 700px\"  />\n\n<p><a href=\"https://github.com/facebook/react/releases/tag/v17.0.0\" target=\"_blank\" >Delegate events to roots instead of document</a></p>\n<p><a href=\"https://www.bigbinary.com/blog/react-17-delegates-events-to-root-instead-of-document\" target=\"_blank\" >React 17 delegates events to root instead of document</a></p>\n<p>为了演示其中一个问题，让我们以 select 下拉列表为例。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--Div&#39;s change event contains stopPropagation()--&gt;\n&lt;div id&#x3D;&quot;main&quot;&gt;\n  &lt;!--Div where react component will be rendered --&gt;\n  &lt;div id&#x3D;&quot;react-root&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nclass CountryDropDown extends React.Component &#123;\n  state &#x3D; &#123;\n    country: &#39;&#39;,\n  &#125;\n  const handleChange &#x3D; e &#x3D;&gt; &#123;\n    this.setState(&#123; country: e.target.value &#125;);\n  &#125;\n  render() &#123;\n    return (\n      &lt;table class&#x3D;&quot;table table-striped table-condensed&quot;&gt;\n        &lt;thead&gt;\n          &lt;tr&gt;\n            &lt;th&gt;Country&lt;&#x2F;th&gt;\n            &lt;th&gt;Selected country&lt;&#x2F;th&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;thead&gt;\n        &lt;tbody&gt;\n          &lt;tr&gt;\n            &lt;td&gt;\n              &lt;select value&#x3D;&#123;this.state.country&#125;\n                onChange&#x3D;&#123;this.handleChange&#125;\n              &gt;\n                &lt;option value&#x3D;&quot;&quot;&gt;--Select--&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;India&quot;&gt;India&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;US&quot;&gt;US&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;Dubai&quot;&gt;Dubai&lt;&#x2F;option&gt;\n              &lt;&#x2F;select&gt;\n            &lt;&#x2F;td&gt;\n            &lt;td&gt;\n              &#123;this.state.country&#125;\n            &lt;&#x2F;td&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;tbody&gt;\n      &lt;&#x2F;table&gt;\n    );\n  &#125;\n&#125;\nReactDOM.render(&lt;CountryDropDown &#x2F;&gt;, document.getElementById(&#39;react-root&#39;));\n\n</code></pre>\n\n<p>给<code>main-div</code>增加一个阻止冒泡的事件</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">document.getElementById(&quot;main&quot;).addEventListener(\n  &quot;change&quot;,\n  function (e) &#123;\n    e.stopPropagation();\n  &#125;,\n  false\n);</code></pre>\n\n<p>附加到文档节点的 onChange 下拉事件出现意外行为，原因是：包含 e.stopPropagation（）的主 div 的 change 事件阻止了下拉的 onChange 事件。</p>\n<h2 id=\"合成事件的冒泡捕获机制如何实现？\"><a href=\"#合成事件的冒泡捕获机制如何实现？\" class=\"headerlink\" title=\"合成事件的冒泡捕获机制如何实现？\"></a>合成事件的冒泡捕获机制如何实现？</h2><p><code>traverseTwoPhase</code> 模拟了捕获和冒泡的两个阶段，这里实现很巧妙，简单而言就是<code>正向和反向遍历了一下数组</code></p>\n<h2 id=\"合成事件源码函数调用关系图\"><a href=\"#合成事件源码函数调用关系图\" class=\"headerlink\" title=\"合成事件源码函数调用关系图\"></a>合成事件源码函数调用关系图</h2><img src=\"http://t-blog-images.aijs.top/img/SyntheticEvent-第 2 页.drawio.webp\" />\n\n<h2 id=\"v17-0-1\"><a href=\"#v17-0-1\" class=\"headerlink\" title=\"v17.0.1\"></a>v17.0.1</h2><p>React 中事件分为<code>委托事件（DelegatedEvent）</code>和<code>不需要委托事件（NonDelegatedEvent）</code>，</p>\n<ul>\n<li>委托事件在 fiberRoot 创建的时候，<code>就会在 root 节点的 DOM 元素上绑定几乎所有事件的处理函数</code>，</li>\n<li>而不需要委托事件只<code>会将处理函数绑定在 DOM 元素本身</code>。</li>\n</ul>\n<p>同时，React 将事件分为 3 种类型——discreteEvent(离散事件，对应<code>discreteEventPairsForSimpleEventPlugin</code>)、userBlockingEvent(用户阻止事件，对应<code>userBlockingPairsForSimpleEventPlugin</code>)、continuousEvent(连续事件，对应<code>continuousPairsForSimpleEventPlugin</code>)，它们拥有不同的优先级，在绑定事件处理函数时会使用不同的回调函数。</p>\n<p>React 事件建立在原生基础上，模拟了一套冒泡和捕获的事件机制，当某一个 DOM 元素触发事件后，会冒泡到 React 绑定在 root 节点的处理函数，通过 target 获取触发事件的 DOM 对象和对应的 Fiber 节点，由该 Fiber 节点向上层父级遍历，收集一条事件队列，再遍历该队列触发队列中每个 Fiber 对象对应的事件处理函数，正向遍历模拟冒泡，反向遍历模拟捕获，所以合成事件的触发时机是在原生事件之后的。</p>\n<p>Fiber 对象对应的事件处理函数依旧是储存在 props 里的，收集只是从 props 里取出来，它并没有绑定到任何元素上。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">createRootImpl(委托事件绑定)-&gt;\nlistenToAllSupportedEvents(监听所有支持的事件)-&gt;\nlistenToNativeEvent(冒泡,捕获)-&gt;\ngetEventListenerSet,getListenerSetKey,addTrappedEventListener（函数会通过事件名取得对应优先级的listener函数，再交由下层函数处理事件绑定）-&gt;\ncreateEventListenerWrapperWithPriority(根据优先级取得对应listener)-&gt;\ndispatchDiscreteEvent,dispatchUserBlockingUpdate,dispatchEvent(触发事件)-&gt;\nattemptToDispatchEvent(触发事件)-&gt;\n.....略.....-&gt;\ndispatchEventsForPlugins(函数里会收集触发事件开始各层级的节点对应的处理函数，也就是我们实际传入JSX中的函数，并且执行它们)-&gt;\nextractEvents(针对不同类型的事件创建对应的合成事件，并且将各层级节点的listener收集起来，用来模拟冒泡或者捕获)-&gt;\naccumulateSinglePhaseListeners(函数里就是在向上层遍历来收集一个列表后面会用来模拟冒泡)-&gt;\nprocessDispatchQueue(遍历dispatchQueue,在processDispatchQueueItemsInOrder函数里遍历执行)-&gt;\nprocessDispatchQueueItemsInOrder(根据判断来正向、反向的遍历来模拟冒泡和捕获)-&gt;\nexecuteDispatch(会执行listener)-&gt;</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.lzane.com/tech/react-event-system-and-source-code/\" target=\"_blank\" >动画浅析 REACT 事件系统和源码</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/56531645\" target=\"_blank\" >小前端读源码 - React16.7.0(合成事件)</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_34352005/article/details/85995026\" target=\"_blank\" >React16 的 interactiveUpdates</a></p>\n<p><a src=\"https://blog.51cto.com/u_15127691/4626192\" >React 17 All In One </a></p>\n<p><a href=\"https://segmentfault.com/a/1190000039108951\" target=\"_blank\" >深入 React 合成事件机制原理</a></p>\n<p><a href=\"https://juejin.cn/post/7005129812981317668\" target=\"_blank\" >React 合成事件详解</a></p>\n<p><a href=\"https://www.bigbinary.com/blog/react-17-delegates-events-to-root-instead-of-document\" target=\"_blank\" >React 17 delegates events to root instead of document</a></p>\n<p><a href=\"http://www.zzvips.com/article/227118.html\" target=\"_blank\" >React 事件机制源码解析 17.0.1</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/166625150\" target=\"_blank\" >React 事件 | 4. React 事件监听</a></p>\n<p><a href=\"https://juejin.cn/post/6863266370411298823#heading-0\" target=\"_blank\" >React源码解析-事件系统</a></p>\n","text":"本文说明本文主要内容是 React v16.5.0, 部分内容会涉及到 React v17+, React v17+合成事件与 React16 有很大差异 React 和事件系统概述见 &#x2F;** * * +------------+ . * | DOM | . * +--...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E6%96%87%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">本文说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">React 和事件系统概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-React-%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%A5%97%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9F\"><span class=\"toc-text\">为什么 React 需要自己实现一套事件系统？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A6%96%E5%85%88%E5%AF%B9%E4%BA%8E%E6%80%A7%E8%83%BD%E6%9D%A5%E8%AF%B4\"><span class=\"toc-text\">首先对于性能来说</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%80%8C%E5%AF%B9%E4%BA%8E%E5%A4%8D%E7%94%A8%E6%9D%A5%E8%AF%B4\"><span class=\"toc-text\">而对于复用来说</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E4%BD%9C%E8%B5%B7%E6%9D%A5%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">React 的事件系统是怎么运作起来的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">事件绑定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91\"><span class=\"toc-text\">事件触发</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E6%9C%89%E6%80%8E%E6%A0%B7%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F\"><span class=\"toc-text\">合成事件与原生事件有怎样的执行顺序？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90-1\"><span class=\"toc-text\">例子 1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90-2\"><span class=\"toc-text\">例子 2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#e-stopPropagation-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F\"><span class=\"toc-text\">e.stopPropagation() 如何阻止合成事件冒泡？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8C%89%E9%92%AE%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E4%BC%9A%E5%87%BA%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">同级别的两个按钮，使用三元运算符，会出问题？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E6%8F%90%E7%A4%BA-event-persist-%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8F%90%E7%A4%BA%EF%BC%9F\"><span class=\"toc-text\">React 提示 event.persist() ，为什么会提示？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#setState-%E6%9C%89%E6%97%B6%E5%80%99%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%8CsetState-%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%80%8C%E8%A8%80%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">setState 有时候是异步的，setState 相对于浏览器而言是同步的，如何理解？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BC%9A%E6%9C%89%E6%80%8E%E6%A0%B7%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">异步渲染使用不安全的生命周期会有怎样的现象？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%8B%E5%89%8D%E5%B0%86%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%8C%82%E8%BD%BD%E5%88%B0-document-%E4%B8%8A%EF%BC%8C%E7%8E%B0%E5%9C%A8%E4%B8%BA%E4%BD%95%E6%8C%82%E8%BD%BD%E5%88%B0-root-%E4%B8%8A%EF%BC%9F\"><span class=\"toc-text\">之前将事件监听挂载到 document 上，现在为何挂载到 root 上？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%86%92%E6%B3%A1%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">合成事件的冒泡捕获机制如何实现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E6%BA%90%E7%A0%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE\"><span class=\"toc-text\">合成事件源码函数调用关系图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#v17-0-1\"><span class=\"toc-text\">v17.0.1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React@16.5.0 createElement","uid":"5d9b43eaa4875051b6cba337b4fe23d2","slug":"2022-07-21react-createElement","date":"2022-07-21T03:18:50.000Z","updated":"2022-09-16T15:02:24.977Z","comments":true,"path":"api/articles/2022-07-21react-createElement.json","keywords":null,"cover":null,"text":"项目开发时候书写代码某个页面或者是组件 &#x2F;&#x2F; class ReactComponent extends React.Component &#123; &#x2F;&#x2F; render() &#123; &#x2F;&#x2F; return &lt;p ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"react-native 架构变更","uid":"6f92233bb9cb3976c3ae6f34c3be87e6","slug":"2022-07-19rn-架构变更","date":"2022-07-19T02:33:57.000Z","updated":"2022-09-16T13:54:56.220Z","comments":true,"path":"api/articles/2022-07-19rn-架构变更.json","keywords":null,"cover":[],"text":"Fabric 渲染器Fabric 渲染器 一开始直接看 react-native 官网，对于 Fabric 渲染器的介绍看的我一脸懵逼，在 Google 扒拉下，发现了 2018 年的一个提案。 我觉得从过去来看更符合事物的发展规律。直接拿到结果倒着看，不是很好理解。 这么搜搜到...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"react-native","slug":"react-native","count":2,"path":"api/categories/react-native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":2,"path":"api/tags/react-native.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}