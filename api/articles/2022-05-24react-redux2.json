{"title":"react-redux  源码2","uid":"d512c56f4cbf1792b4d8bab0668985ad","slug":"2022-05-24react-redux2","date":"2022-05-24T13:15:31.000Z","updated":"2022-09-16T14:57:51.357Z","comments":true,"path":"api/articles/2022-05-24react-redux2.json","keywords":null,"cover":[],"content":"<p>源码版本<code>&quot;version&quot;: &quot;8.0.2&quot;,</code></p>\n<h2 id=\"Provider\"><a href=\"#Provider\" class=\"headerlink\" title=\"Provider\"></a>Provider</h2><ul>\n<li>主要作用通过subscription调用redux中store的subscription产生订阅，订阅内容是onStateChange的回调</li>\n<li>通过react的Provider功能，提供传递给根的store和根的subscription给后续使用了connect的组件</li>\n</ul>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;* provider 组件代码 *&#x2F;\nfunction Provider(&#123; store, context, children &#125;) &#123;\n   &#x2F;* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  *&#x2F; \n  const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n      &#x2F;* 创建了一个根 Subscription 订阅器 *&#x2F;\n    const subscription &#x3D; new Subscription(store)\n    &#x2F;* subscription 的 notifyNestedSubs 方法 ，赋值给  onStateChange方法 *&#x2F;\n    &#x2F;&#x2F;onStateChange就是之后触发的listenr\n    subscription.onStateChange &#x3D; subscription.notifyNestedSubs  \n    return &#123;\n      store,\n      subscription\n    &#125; &#x2F;*  store 改变创建新的contextValue *&#x2F;\n  &#125;, [store])\n  &#x2F;*  获取更新之前的state值 ，函数组件里面的上下文要优先于组件更新渲染  *&#x2F;\n  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])\n\n  useEffect(() &#x3D;&gt; &#123;\n    const &#123; subscription &#125; &#x3D; contextValue\n    &#x2F;* 触发trySubscribe方法执行，创建listens *&#x2F;\n    subscription.trySubscribe() &#x2F;&#x2F; 发起订阅\n    if (previousState !&#x3D;&#x3D; store.getState()) &#123;\n        &#x2F;* 组件更新渲染之后，如果此时state发生改变，那么立即触发 subscription.notifyNestedSubs 方法  *&#x2F;\n        &#x2F;&#x2F;触发所有的listener\n      subscription.notifyNestedSubs() \n    &#125;\n    &#x2F;*   *&#x2F;\n    return () &#x3D;&gt; &#123;\n      subscription.tryUnsubscribe()  &#x2F;&#x2F; 卸载订阅\n      subscription.onStateChange &#x3D; null\n    &#125;\n    &#x2F;*  contextValue state 改变出发新的 effect *&#x2F;\n  &#125;, [contextValue, previousState])\n\n  &#x2F;&#x2F;若Provider没有显示传入context，则为使用React.createContext创建的上下文\n  const Context &#x3D; context || ReactReduxContext\n\n  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt;\n&#125;\n</code></pre>\n<h2 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a>Subscription</h2><ul>\n<li>订阅消息、发起更新</li>\n<li>在根的Provider的作用是调用redux中store的订阅方法，将根的onStateChange进行订阅</li>\n<li>在子代中是收集所有被 connect 包裹的组件中的Subscription的更新函数 onstatechange，然后形成一个 callback 链表，再由父级 Subscription 统一派发执行更新，只会往上传递一层，不会一直传递使得每一个上级都有自身的更新函数</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;* 发布订阅者模式 *&#x2F;\nexport default class Subscription &#123;\n  constructor(store, parentSub) &#123;\n    this.store &#x3D; store\n    this.parentSub &#x3D; parentSub\n    this.unsubscribe &#x3D; null\n    this.listeners &#x3D; nullListeners\n\n    this.handleChangeWrapper &#x3D; this.handleChangeWrapper.bind(this)\n  &#125;\n  &#x2F;* 负责检测是否该组件订阅，然后添加订阅者也就是listener *&#x2F;  \n  &#x2F;&#x2F;当父代调用过trySubscribe后，子代再调用，因为this.unsubscribe有值，所以并不会实际执行父代的trySubscribe，而只是将listener放进父代中管理\n  addNestedSub(listener) &#123;\n    this.trySubscribe()\n    return this.listeners.subscribe(listener)\n  &#125;\n  &#x2F;* 向listeners发布通知 *&#x2F;\n  notifyNestedSubs() &#123;\n    this.listeners.notify()\n  &#125;\n  &#x2F;* 对于 Provide onStateChange 就是 notifyNestedSubs 方法，\n  对于 connect 包裹接受更新的组件 ，onStateChange 就是 负责更新组件的函数 。   *&#x2F;\n  handleChangeWrapper() &#123;\n    if (this.onStateChange) &#123;\n      this.onStateChange()\n    &#125;\n  &#125;\n   &#x2F;* 判断有没有开启订阅 *&#x2F;\n  isSubscribed() &#123;\n    return Boolean(this.unsubscribe)\n  &#125;\n  &#x2F;* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 *&#x2F;\n  trySubscribe() &#123;\n    &#x2F;*\n    \tparentSub即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription\n    *&#x2F;\n    &#x2F;&#x2F;当Subscription执行过一次改方法后，再调用因为this.unsubscribe有值\n    &#x2F;&#x2F;所以该方法调用一次后就不会再被调用了\n    &#x2F;&#x2F;意味着addNestedSub中只会添加listener，而不会再调用trySubscribe，使得listener不会往上传递\n    if (!this.unsubscribe) &#123;\n      this.unsubscribe &#x3D; this.parentSub\n        ? this.parentSub.addNestedSub(this.handleChangeWrapper)\n        &#x2F;* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   *&#x2F;\n        : this.store.subscribe(this.handleChangeWrapper)\n      this.listeners &#x3D; createListenerCollection()\n    &#125;\n  &#125;\n  &#x2F;* 取消订阅 *&#x2F;\n  tryUnsubscribe() &#123;\n    if (this.unsubscribe) &#123;\n      this.unsubscribe()\n      this.unsubscribe &#x3D; null\n      this.listeners.clear()\n\n      this.listeners &#x3D; nullListeners\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n\n<ul>\n<li>首先Provider创建 Subscription 时候没有第二个参数，就说明provider 中的Subscription 不存在 parentSub 。</li>\n<li>那么再调用Provider组件中useEffect钩子中trySubscribe的时候,会触发this.store.subscribe , subscribe 就是 redux 的 subscribe ,此时真正发起了订阅</li>\n<li>订阅的内容是notifyNestedSubs，即通知根管理的listeners触发<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">subscription.onStateChange &#x3D; subscription.notifyNestedSubs \n\n&#x2F;* 向listeners发布通知 *&#x2F;\nnotifyNestedSubs() &#123;\n  this.listeners.notify()\n&#125;\n</code></pre></li>\n</ul>\n<h2 id=\"createListenerCollection\"><a href=\"#createListenerCollection\" class=\"headerlink\" title=\"createListenerCollection\"></a>createListenerCollection</h2><p>通过双向链表的结构管理每一个listener<br>以链表的形式收集对应的 listeners (每一个Subscription) 的handleChangeWrapper函数即onStateChange。<br>通过 batch 方法( react-dom 中的 unstable_batchedUpdates ) 来进行批量更新，许将一次事件循环中的所有 React 更新都一起批量处理到一个渲染过程中。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; unstable_batchedUpdates as batch &#125; from &#39;.&#x2F;utils&#x2F;reactBatchedUpdates&#39;\nsetBatch(batch)\n\n\nfunction createListenerCollection() &#123;\n   &#x2F;* batch 由getBatch得到的 unstable_batchedUpdates 方法 *&#x2F;\n  const batch &#x3D; getBatch()\n  let first &#x3D; null\n  let last &#x3D; null\n\n  return &#123;\n    &#x2F;* 清除当前listeners的所有listener *&#x2F;\n    clear() &#123;\n      first &#x3D; null\n      last &#x3D; null\n    &#125;,\n    &#x2F;* 派发更新 *&#x2F;\n    notify() &#123;\n      batch(() &#x3D;&gt; &#123;\n        let listener &#x3D; first\n        while (listener) &#123;\n          listener.callback()\n          listener &#x3D; listener.next\n        &#125;\n      &#125;)\n    &#125;,\n    &#x2F;* 获取listeners的所有listener *&#x2F;\n    get() &#123;\n      let listeners &#x3D; []\n      let listener &#x3D; first\n      while (listener) &#123;\n        listeners.push(listener)\n        listener &#x3D; listener.next\n      &#125;\n      return listeners\n    &#125;,\n     &#x2F;* 接收订阅，将当前的callback（handleChangeWrapper）存到当前的链表中  *&#x2F;\n    subscribe(callback) &#123;\n      let isSubscribed &#x3D; true\n\n      let listener &#x3D; (last &#x3D; &#123;\n        callback,\n        next: null,\n        prev: last &#x2F;&#x2F;首次last为空\n      &#125;)\n\t   \t\n      if (listener.prev) &#123;\n        listener.prev.next &#x3D; listener\n      &#125; else &#123;\n        first &#x3D; listener\n      &#125;\n      &#x2F;* 取消当前 handleChangeWrapper 的订阅*&#x2F;\n      return function unsubscribe() &#123;\n        if (!isSubscribed || first &#x3D;&#x3D;&#x3D; null) return\n        isSubscribed &#x3D; false\n\t\t\n\t\t&#x2F;&#x2F;双向链表删除节点的操作\n        if (listener.next) &#123;\n          listener.next.prev &#x3D; listener.prev\n        &#125; else &#123;\n          last &#x3D; listener.prev\n        &#125;\n        if (listener.prev) &#123;\n          listener.prev.next &#x3D; listener.next\n        &#125; else &#123;\n          first &#x3D; listener.next\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h2><p>基本使用</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)\n\nconst mapStateToProps &#x3D; state &#x3D;&gt; (&#123; todos: state.todos &#125;)\nconst mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;\n  return &#123;\n    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),\n    decrement: () &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;),\n    reset: () &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39; &#125;)\n  &#125;\n&#125;\n&#x2F;*\n* stateProps , state 映射到 props 中的内容\n* dispatchProps， dispatch 映射到 props 中的内容。\n* ownProps 组件本身的 props\n当未传递时，默认的合并规则为\n&#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n\n*&#x2F;\nmergeProps&#x3D;(stateProps, dispatchProps, ownProps) &#x3D;&gt; Object\n\noptions&#x3D;&#123;\n  context?: Object,   &#x2F;&#x2F; 自定义上下文\n  pure?: boolean, &#x2F;&#x2F; 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。\n  areStatesEqual?: Function, &#x2F;&#x2F; 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean\n  areOwnPropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean\n  areStatePropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) &#x3D;&gt; boolean\n  areMergedPropsEqual?: Function, &#x2F;&#x2F; 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) &#x3D;&gt; boolean\n  forwardRef?: boolean, &#x2F;&#x2F;当为true 时候,可以通过ref 获取被connect包裹的组件实例。\n&#125;\n</code></pre>\n<p><img src=\"http://t-blog-images.aijs.top/img/20220525105732.webp\"></p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior &#x2F; props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that&#39;s\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don&#39;t know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user&#39;s responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps A function that extracts values from state\n * @param mapDispatchToProps Setup for dispatching actions\n * @param mergeProps Optional callback to merge state and dispatch props together\n * @param options Options for configuring the connection\n *\n *&#x2F;\nfunction connect&lt;\n  TStateProps &#x3D; &#123;&#125;,\n  TDispatchProps &#x3D; &#123;&#125;,\n  TOwnProps &#x3D; &#123;&#125;,\n  TMergedProps &#x3D; &#123;&#125;,\n  State &#x3D; unknown\n&gt;(\n  mapStateToProps?: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;,\n  mapDispatchToProps?: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;,\n  mergeProps?: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;,\n  &#123;\n    &#x2F;&#x2F; The &#96;pure&#96; option has been removed, so TS doesn&#39;t like us destructuring this to check its existence.\n    &#x2F;&#x2F; @ts-ignore\n    pure,\n    areStatesEqual &#x3D; strictEqual,\n    areOwnPropsEqual &#x3D; shallowEqual,\n    areStatePropsEqual &#x3D; shallowEqual,\n    areMergedPropsEqual &#x3D; shallowEqual,\n\n    &#x2F;&#x2F; use React&#39;s forwardRef to expose a ref of the wrapped component\n    forwardRef &#x3D; false,\n\n    &#x2F;&#x2F; the context consumer to use\n    context &#x3D; ReactReduxContext,\n  &#125;: ConnectOptions&lt;unknown, unknown, unknown, unknown&gt; &#x3D; &#123;&#125;\n): unknown &#123;\n  \n\n  const Context &#x3D; context\n\n  &#x2F;*\n  * stateProps , state 映射到 props 中的内容\n  * dispatchProps， dispatch 映射到 props 中的内容。\n  * ownProps 组件本身的 props\n  当未传递时，默认的合并规则为\n  &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n\n  *&#x2F;\n &#x2F;* 经过代理包装后的 mapStateToProps,完成传入store等操作*&#x2F;\n  const initMapStateToProps &#x3D; mapStateToPropsFactory(mapStateToProps)\n  &#x2F;* 经过代理包装后的 mapDispatchToProps，完成传入store.dispatch等操作*&#x2F;\n  const initMapDispatchToProps &#x3D; mapDispatchToPropsFactory(mapDispatchToProps)\n  &#x2F;* 经过代理包装后的 mergeProps，用于形成真正的 mergeProps函数，合并业务组件的 props , state 映射的 props , dispatch 映射的 props *&#x2F;\n  const initMergeProps &#x3D; mergePropsFactory(mergeProps)\n\n  const shouldHandleStateChanges &#x3D; Boolean(mapStateToProps)\n\n  &#x2F;&#x2F;默认的高阶组件connectAdvanced，实际渲染的组件是其中返回的一个ConnectFunction\n\t&#x2F;&#x2F;selectorFactory为整合connect更新过程中的形成新props的主要函数\n\t&#x2F;&#x2F;selectorFactory为后面的finalPropsSelectorFactory\n  const wrapWithConnect: AdvancedComponentDecorator&lt;\n    TOwnProps,\n    WrappedComponentProps\n  &gt; &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n    ...\n  &#125;\n&#125;\n</code></pre>\n<ul>\n<li>当我们不向connect传递第三个参数mergeProps 的时候，默认的defaultMergeProps如下，作为新的 props 传递给了业务组件</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export function defaultMergeProps(stateProps, dispatchProps, ownProps) &#123;\n  return &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"selectorFactory\"><a href=\"#selectorFactory\" class=\"headerlink\" title=\"selectorFactory\"></a>selectorFactory</h2><p><img src=\"http://t-blog-images.aijs.top/img/20220525101153.webp\"></p>\n<ul>\n<li>首先得到真正connect 经过一层代理函数 mapStateToProps ,mapDispatchToProps ,mergeProps</li>\n<li>然后调用selectorFactory (在pure模式下，selectorFactory 就是 pureFinalPropsSelectorFactory )<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function finalPropsSelectorFactory(\n  dispatch,\n  &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options &#125;\n) &#123;\n  &#x2F;&#x2F; mapStateToProps mapDispatchToProps mergeProps 为真正connect 经过一层代理的 proxy 函数\n  const mapStateToProps &#x3D; initMapStateToProps(dispatch, options)\n  const mapDispatchToProps &#x3D; initMapDispatchToProps(dispatch, options)\n  const mergeProps &#x3D; initMergeProps(dispatch, options)\n\n  &#x2F;&#x2F;默认pure为true，selectorFactory默认为pureFinalPropsSelectorFactory\n  const selectorFactory &#x3D; options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory\n   &#x2F;&#x2F; 返回一个 函数用于生成新的 props \n  return selectorFactory(\n    mapStateToProps,\n    mapDispatchToProps,\n    mergeProps,\n    dispatch,\n    options\n  )\n&#125;\n</code></pre></li>\n</ul>\n<h2 id=\"pureFinalPropsSelectorFactory\"><a href=\"#pureFinalPropsSelectorFactory\" class=\"headerlink\" title=\"pureFinalPropsSelectorFactory\"></a>pureFinalPropsSelectorFactory</h2><p><img src=\"http://t-blog-images.aijs.top/img/20220525100640.webp\"></p>\n<ul>\n<li>如果是第一次，那么直接调用mergeProps合并ownProps,stateProps,dispatchProps 形成最终的props。</li>\n<li>如果不是第一次，那么判断到底是props还是 store.state 发生改变，然后针对那里变化，重新生成对应的props，最终合并到真正的props</li>\n<li>整个 selectorFactory 逻辑就是形成新的props传递给我们的业务组件。</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;** pure组件处理 ， 对比 props 是否发生变化 然后 合并props *&#x2F;\nexport function pureFinalPropsSelectorFactory(\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  dispatch,\n  &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125; &#x2F;&#x2F;判断 state prop 是否相等\n) &#123;\n  let hasRunAtLeastOnce &#x3D; false\n  let state\n  let ownProps\n  let stateProps\n  let dispatchProps\n  let mergedProps\n \n  &#x2F;* 第一次 直接形成 ownProps  stateProps  dispatchProps 合并  形成新的 props *&#x2F;\n  function handleFirstCall(firstState, firstOwnProps) &#123;\n    state &#x3D; firstState\n    ownProps &#x3D; firstOwnProps\n    &#x2F;&#x2F;获取业务组件中mapStateToProps函数的返回值\n    stateProps &#x3D; mapStateToProps(state, ownProps)\n    &#x2F;&#x2F;获取业务组件中mapDispatchToProps函数的返回值\n    dispatchProps &#x3D; mapDispatchToProps(dispatch, ownProps)\n    &#x2F;&#x2F;合并state、dispatch、组件自身的props，形成最终传递给组件的props\n    mergedProps &#x3D; mergeProps(stateProps, dispatchProps, ownProps)\n    hasRunAtLeastOnce &#x3D; true\n    return mergedProps\n  &#125;\n  \n  function handleNewPropsAndNewState() &#123;\n    &#x2F;&#x2F;  props 和 state 都改变  mergeProps \n  &#125;\n\n  function handleNewProps() &#123;\n    &#x2F;&#x2F; props 改变  mergeProps\n  &#125;\n\n  function handleNewState() &#123;\n     &#x2F;&#x2F; state 改变 mergeProps\n  &#125;\n\n  &#x2F;*  不是第一次的情况 props 或者 store.state 发生改变的情况。 *&#x2F;\n  function handleSubsequentCalls(nextState, nextOwnProps) &#123;\n      &#x2F;* 判断两次 props 是否相等 *&#x2F;\n    const propsChanged &#x3D; !areOwnPropsEqual(nextOwnProps, ownProps) \n      &#x2F;* 判断两次 store.state 是否相等 *&#x2F;\n    const stateChanged &#x3D; !areStatesEqual(nextState, state)\n    state &#x3D; nextState\n    ownProps &#x3D; nextOwnProps\n    \n    &#x2F;&#x2F;根据改变的类型不同，返回对应合并策略下的props\n    if (propsChanged &amp;&amp; stateChanged) return handleNewPropsAndNewState()\n    if (propsChanged) return handleNewProps()\n    if (stateChanged) return handleNewState()\n    return mergedProps\n  &#125;\n  \n  &#x2F;&#x2F;根据是否第一次形成props，执行对应方法\n  return function pureFinalPropsSelector(nextState, nextOwnProps) &#123;\n    return hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"connectHOC\"><a href=\"#connectHOC\" class=\"headerlink\" title=\"connectHOC\"></a>connectHOC</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">const mapStateToProp &#x3D; (store) &#x3D;&gt; (&#123; userInfo: store.root.userInfo &#125;)\n\nfunction Index()&#123;\n    &#x2F;* ..... *&#x2F;\n    return &lt;div&gt; &#123; &#x2F;* .... *&#x2F; &#125; &lt;&#x2F;div&gt;\n&#125;\nexport default connect(mapStateToProp)(Index)\n\n</code></pre>\n<ul>\n<li>connect(mapStateToProp)&#x3D;&#x3D;&#x3D;connectAdvanced()</li>\n</ul>\n<details class=\"custom-details\">\n<summary>点击查看更多</summary>\n<ul>\n<li>这部分代码，在8.x.x版本在conncet中直接处理，并没有拆分为单独函数</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function connectAdvanced(\n  selectorFactory, &#x2F;&#x2F; 每次 props,state改变执行 ，用于生成新的 props。\n  &#123;\n    getDisplayName &#x3D; name &#x3D;&gt; &#96;ConnectAdvanced($&#123;name&#125;)&#96;,\n    &#x2F;&#x2F;可能被包装函数（如connect（））重写\n    methodName &#x3D; &#39;connectAdvanced&#39;,\n    &#x2F;&#x2F;如果定义了，则传递给包装元素的属性的名称，指示要呈现的调用。用于监视react devtools中不必要的重新渲染。\n    renderCountProp &#x3D; undefined,\n    shouldHandleStateChanges &#x3D; true,  &#x2F;&#x2F;确定此HOC是否订阅存储更改\n    storeKey &#x3D; &#39;store&#39;,\n    withRef &#x3D; false,\n    forwardRef &#x3D; false, &#x2F;&#x2F; 是否 用 forwarRef 模式\n    context &#x3D; ReactReduxContext,&#x2F;&#x2F; Provider 保存的上下文\n    ...connectOptions\n  &#125; &#x3D; &#123;&#125;\n) &#123;\n  &#x2F;* ReactReduxContext 就是store存在的context *&#x2F;\n  const Context &#x3D; context\n   &#x2F;* WrappedComponent 为connect 包裹的组件本身  *&#x2F;   \n  return  function wrapWithConnect(WrappedComponent)&#123;\n      &#x2F;&#x2F; WrappedComponent 被 connect 的业务组件本身\n  &#125;\n&#125;</code></pre>\n<ul>\n<li>拿到Provider提供的context上下文</li>\n</ul>\n\n</details>\n<h2 id=\"wrapWithConnect\"><a href=\"#wrapWithConnect\" class=\"headerlink\" title=\"wrapWithConnect\"></a>wrapWithConnect</h2><p>wrapWithConnect作为高阶组件，会返回一个组件，这个组件会对原有的业务组件，进行一系列增强等工作<br>判断是否是 pure 纯组件模式，如果是用react.memo包裹,这样做的好处是，会向 pureComponent 一样对 props 进行浅比较<br>如果 connect 有forwardRef配置项，用React.forwardRef处理</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">function wrapWithConnect(WrappedComponent) &#123;\n\t&#x2F;&#x2F;WrappedComponent为实际传递的业务组件\n    const wrappedComponentName &#x3D;\n      WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;\n  \n    const displayName &#x3D; getDisplayName(wrappedComponentName)\n    \n    &#x2F;&#x2F;要合并都内容，connectOptions为上一步闭包拿到的内容\n    const selectorFactoryOptions &#x3D; &#123;\n      ...connectOptions,\n      getDisplayName,\n      methodName,\n      renderCountProp,\n      shouldHandleStateChanges,\n      storeKey,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent\n    &#125;\n    const &#123; pure &#125; &#x3D; connectOptions\n    \n    &#x2F;&#x2F;selectorFactory为finalPropsSelectorFactory\n    function createChildSelector(store) &#123;\n      &#x2F;&#x2F; 合并函数 mergeprops 得到最新的props\n      &#x2F;&#x2F; 及默认返回pureFinalPropsSelectorFactory，会根据是否第一次合并、修改类型等进行不同策略等合并以及返回最终都props\n      return selectorFactory(store.dispatch, selectorFactoryOptions)\n    &#125;\n    &#x2F;&#x2F;判断是否是pure纯组件模式 如果是将用 useMemo 缓存组件提升性能\n    const usePureOnlyMemo &#x3D; pure ? useMemo : callback &#x3D;&gt; callback()\n    &#x2F;&#x2F; 负责更新的容器子组件，可以看作是实际渲染的类组件\n    function ConnectFunction (props)&#123;\n        &#x2F;&#x2F; props 为 业务组件 真正的 props \n    &#125;\n    &#x2F;&#x2F;如果\n    const Connect &#x3D; pure ? React.memo(ConnectFunction) : ConnectFunction\n  \n    Connect.WrappedComponent &#x3D; WrappedComponent\n    Connect.displayName &#x3D; displayName\n    &#x2F;* forwardRef *&#x2F;\n    if (forwardRef) &#123;\n      const forwarded &#x3D; React.forwardRef(function forwardConnectRef(\n        props,\n        ref\n      ) &#123;\n      \t&#x2F;&#x2F;connect中是否传递了forwardRef选项\n        return &lt;Connect &#123;...props&#125; reactReduxForwardedRef&#x3D;&#123;ref&#125; &#x2F;&gt;\n      &#125;)\n  \n      forwarded.displayName &#x3D; displayName\n      forwarded.WrappedComponent &#x3D; WrappedComponent\n      &#x2F;&#x2F;hoistStatics为一个第三方库，负责把一个类中的静态属性拷贝到另一个类中\n      return hoistStatics(forwarded, WrappedComponent)\n    &#125;\n  \n    return hoistStatics(Connect, WrappedComponent)\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"为何要传递forwardRef？\"><a href=\"#为何要传递forwardRef？\" class=\"headerlink\" title=\"为何要传递forwardRef？\"></a>为何要传递forwardRef？</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">connect(mapStateToProp,mapDispatchToProps,mergeProps,&#123; forwardRef:true  &#125;)(Child)</code></pre>\n\n<p>如果不传递，而是在其他组件中直接放ref到使用了connect的组件，则ref实际应用到的是ConncectFunction组件，而非真正的WrappedComponent组件<br>所以react-redux提供forwardRef选项，使用React.forwardRef，将ref实际放到真正的WrappedComponent上</p>\n<h2 id=\"ConnectFunction\"><a href=\"#ConnectFunction\" class=\"headerlink\" title=\"ConnectFunction\"></a>ConnectFunction</h2><ul>\n<li><p>实际渲染的组件</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">function ConnectFunction(props) &#123;\n    &#x2F;* TODO:  第一步 把 context ForwardedRef props 取出来 *&#x2F;\n    &#x2F;&#x2F;取出forwardRef和传递给ConnectFunction的所有除forwardRef的props\n    &#x2F;&#x2F;除了forwardRef以外的props也就是实际业务代码中传递给conncec包裹组件都props\n    const [\n      reactReduxForwardedRef,\n      wrapperProps &#x2F;&#x2F; props 传递的props\n    ] &#x3D; useMemo(() &#x3D;&gt; &#123;\n      const &#123; reactReduxForwardedRef, ...wrapperProps &#125; &#x3D; props\n      return [reactReduxForwardedRef, wrapperProps]\n    &#125;, [props])\n \n\t  &#x2F;&#x2F; 获取上层Provider提供的context，多个Provider只会取最近的Provider\n    &#x2F;&#x2F; 获取 context内容 里面含有  redux 中store 和 subscription\n    const contextValue &#x3D; useContext(Context)\n\n    &#x2F;&#x2F;TODO: 判断 store 是否来自props  didStoreComeFromProps ,正常情况下 ，prop 中是不存在 store 所以  didStoreComeFromProps &#x3D; false\n    const didStoreComeFromProps &#x3D;\n      Boolean(props.store) &amp;&amp;\n      Boolean(props.store.getState) &amp;&amp;\n      Boolean(props.store.dispatch)\n    &#x2F;&#x2F;store是否来自Provider提供的上下文\n    const didStoreComeFromContext &#x3D;\n      Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)\n\n    &#x2F;&#x2F;根据两种情况获取store\n    const store &#x3D; didStoreComeFromProps ? props.store : contextValue.store\n     \n     &#x2F;&#x2F;返回merge函数 用于生成真正传给子组件 props\n    const childPropsSelector &#x3D; useMemo(() &#x3D;&gt; &#123;\n    \t&#x2F;&#x2F;默认情况下pure为true，返回的是pureFinalPropsSelectorFactory\n      return createChildSelector(store)\n    &#125;, [store])\n\n\n    &#x2F;&#x2F; TODO:  第二步  创建connect组件自身的subscription 监听者实例  \n    const [subscription, notifyNestedSubs] &#x3D; useMemo(() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 如果没有订阅更新，那么直接返回，默认情况下开启了订阅\n      if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY\n\t\t&#x2F;&#x2F;为每一个conncet的组件创建订阅器，获取上层Provider提供的contextValue.subscription\n\t\t&#x2F;&#x2F;connct的组件获取的是上层的Provder提供的subscription，有多个Provider，只会取层级最近的一个\n\t\t&#x2F;&#x2F;所以connect中的connect组件，获取到的是离它最近的Provider中的订阅器，通过它来管理自身的listener更新函数\n      const subscription &#x3D; new Subscription(\n        store,\n        didStoreComeFromProps ? null : contextValue.subscription &#x2F;&#x2F; 和 上级 &#96;subscription&#96; 建立起关系。 this.parentSub &#x3D; contextValue.subscription\n      )\n      &#x2F;&#x2F; notifyNestedSubs 触发 noticy 所有子代 listener 监听者 -&gt; 触发batch方法,触发 batchupdate方法 ,批量更新\n      &#x2F;&#x2F;并更新一下this指向\n      const notifyNestedSubs &#x3D; subscription.notifyNestedSubs.bind(\n        subscription\n      )\n\n      return [subscription, notifyNestedSubs]\n    &#125;, [store, didStoreComeFromProps, contextValue])\n\n    &#x2F;*  创建出一个新的contextValue ,把父级的 subscription 换成自己的 subscription   *&#x2F;\n    const overriddenContextValue &#x3D; useMemo(() &#x3D;&gt; &#123;   \n      if (didStoreComeFromProps) &#123; \n        return contextValue\n      &#125;\n      &#x2F;&#x2F;默认情况下，返回自身的订阅器以及redux中的store给自身的子代connect中获取\n      return &#123;\n        ...contextValue,\n        subscription\n      &#125;\n    &#125;, [didStoreComeFromProps, contextValue, subscription])\n    \n    &#x2F;&#x2F;定义了一个useReducer，当actualChildProps变化时，调用dispatch方法forceComponentUpdateDispatch进行组件更新\n    const [\n      [previousStateUpdateResult], &#x2F;&#x2F;调用dispatch更新后的内容\n      forceComponentUpdateDispatch  &#x2F;*  *&#x2F;\n    ] &#x3D; useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)\n\n\n    &#x2F;&#x2F; TODO: 第三步缓存组件本次的props等内容，在下一次组件更新时做比较\n    const lastChildProps &#x3D; useRef() &#x2F;&#x2F;保存上一次 合并过的 props信息（经过 ownprops ,stateProps , dispatchProps 合并过的 ）\n    const lastWrapperProps &#x3D; useRef(wrapperProps) &#x2F;&#x2F;保存本次业务组件的 props \n    const childPropsFromStoreUpdate &#x3D; useRef() &#x2F;&#x2F;用来保存更新后的最新的props\n    const renderIsScheduled &#x3D; useRef(false) &#x2F;&#x2F; 当前组件是否处于渲染阶段\n    \n    &#x2F;&#x2F; actualChildProps 为当前真正处理过后，经过合并的 props\n    const actualChildProps &#x3D; usePureOnlyMemo(() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 调用 mergeProps 进行合并，返回合并后的最新 porps\n        &#x2F;&#x2F;及调用pureFinalPropsSelectorFactory后的合并结果\n      return childPropsSelector(store.getState(), wrapperProps)\n    \n    \t &#x2F;&#x2F;会在store、调用了checkForUpdates、传递给组建的props发生变化后，重新计算获取合并后的props \n    &#125;, [store, previousStateUpdateResult, wrapperProps])\n\n   &#x2F;* 负责更新缓存变量，方便下一次更新的时候比较 *&#x2F;\n    useEffect(()&#x3D;&gt;&#123;\n      captureWrapperProps(...[\n          lastWrapperProps,\n          lastChildProps,\n          renderIsScheduled,\n          wrapperProps,\n          actualChildProps,\n          childPropsFromStoreUpdate,\n          notifyNestedSubs\n       ])\n    &#125;)\n    \n    &#x2F;&#x2F;实际订阅更新组件的地方\n    useEffect(()&#x3D;&gt;&#123;\n        subscribeUpdates(...[\n        shouldHandleStateChanges,\n        store,\n        subscription,\n        childPropsSelector,\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs,\n        forceComponentUpdateDispatch\n       ])\n    &#125;,[store, subscription, childPropsSelector])\n\n\n\n    &#x2F;&#x2F; TODO: 第四步：渲染实际挂载的组件，通过useMemo进行组件的缓存\n    const renderedWrappedComponent &#x3D; useMemo(\n      () &#x3D;&gt; (\n        &lt;WrappedComponent\n          &#123;...actualChildProps&#125;\n          ref&#x3D;&#123;reactReduxForwardedRef&#125;\n        &#x2F;&gt;\n      ),\n      &#x2F;&#x2F;当actualChildProps发生变化的时候重新渲染组件\n      &#x2F;&#x2F;这里就是组件重新渲染的原因：主要通过监听actualChildProps的变化\n      [reactReduxForwardedRef, WrappedComponent, actualChildProps]\n    )\n    &#x2F;&#x2F; 将上一步的renderedWrappedComponent包裹一层Provider\n    &#x2F;&#x2F; 提供该connect组件自身的订阅器、store给子代中的connect组件获取\n    const renderedChild &#x3D; useMemo(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F;shouldHandleStateChanges 来源 connect是否有第一个参数\n      if (shouldHandleStateChanges) &#123;\n        return (\n          &#x2F;&#x2F; ContextToUse 传递 context \n          &lt;ContextToUse.Provider value&#x3D;&#123;overriddenContextValue&#125;&gt;\n            &#123;renderedWrappedComponent&#125;\n          &lt;&#x2F;ContextToUse.Provider&gt;\n        )\n      &#125;\n\n      return renderedWrappedComponent\n    &#125;, [ContextToUse, renderedWrappedComponent, overriddenContextValue])\n\n    return renderedChild\n  &#125;\n\n</code></pre>\n</li>\n<li><p>创建该connect组件自身的subscription, 并使用Provider包裹，层层传递新的context(很重要)</p>\n</li>\n<li><p>所以connect组件的子代connect组件，获取到的都是其上层最近的connect提供的Provider中的订阅器，然后将更新函数checkForUpdates放进其中管理</p>\n</li>\n<li><p>然后通过 useMemo 创建出一个新的 contextValue ,把父级的 subscription 换成自己的 subscription。用于通过 Provider 传递新的 context</p>\n</li>\n<li><p>接下来通过useReducer制造出真正触发更新的forceComponentUpdateDispatch 这个dispatch函数。也就是整个 state 或者是 props改变，触发组件更新的函数，这个函数放进checkForUpdates中执行</p>\n</li>\n</ul>\n<h2 id=\"captureWrapperProps\"><a href=\"#captureWrapperProps\" class=\"headerlink\" title=\"captureWrapperProps\"></a>captureWrapperProps</h2><ul>\n<li>进行内容缓存，为了下次组件更新进行比较<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F;获取包装的props \nfunction captureWrapperProps(\n  lastWrapperProps,\n  lastChildProps,\n  renderIsScheduled,\n  wrapperProps,\n  actualChildProps,\n  childPropsFromStoreUpdate,\n  notifyNestedSubs\n) &#123;\n  lastWrapperProps.current &#x3D; wrapperProps  &#x2F;&#x2F;子props \n  lastChildProps.current &#x3D; actualChildProps &#x2F;&#x2F;经过 megeprops 之后形成的新prop\n  renderIsScheduled.current &#x3D; false  &#x2F;&#x2F; 当前组件渲染完成\n&#125;\n</code></pre></li>\n</ul>\n<h2 id=\"subscribeUpdates\"><a href=\"#subscribeUpdates\" class=\"headerlink\" title=\"subscribeUpdates\"></a>subscribeUpdates</h2><ul>\n<li><p>实际添加更新回调的地方</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function subscribeUpdates(\n  shouldHandleStateChanges,\n  store,\n  subscription,\n  childPropsSelector,\n  lastWrapperProps,  &#x2F;&#x2F;子props \n  lastChildProps, &#x2F;&#x2F;经过 megeprops 之后形成的 prop\n  renderIsScheduled,\n  childPropsFromStoreUpdate,\n  notifyNestedSubs,\n  forceComponentUpdateDispatch\n) &#123;\n  if (!shouldHandleStateChanges) return\n\n   &#x2F;&#x2F; 捕获值以检查此组件是否卸载以及何时卸载\n  let didUnsubscribe &#x3D; false\n  let lastThrownError &#x3D; null\n   &#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调\n  const checkForUpdates &#x3D; ()&#x3D;&gt;&#123;\n      &#x2F;&#x2F;....\n  &#125;\n  &#x2F;&#x2F;将checkForUpdates作为listener\n  subscription.onStateChange &#x3D; checkForUpdates\n  &#x2F;&#x2F;开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中。\n  subscription.trySubscribe()\n  &#x2F;&#x2F;在第一次呈现之后从存储中提取数据，以防存储从我们开始就改变了。\n  &#x2F;&#x2F;确保获取到的最新的store.getState,然后判断是否更新组件\n  checkForUpdates()\n  &#x2F;* 卸载订阅起 *&#x2F;\n  const unsubscribeWrapper &#x3D; () &#x3D;&gt; &#123;\n    didUnsubscribe &#x3D; true\n    subscription.tryUnsubscribe()\n    subscription.onStateChange &#x3D; null\n  &#125;\n\n  return unsubscribeWrapper\n&#125;\n</code></pre>\n</li>\n<li><p>首先声明 store 更新订阅传播到此组件时的回调函数checkForUpdates把它赋值给onStateChange,如果store中的state发生改变，那么在组件订阅了state内容之后，相关联的state改变就会触发当前组件的onStateChange,来合并得到新的props</p>\n</li>\n<li><p>subscription.trySubscribe()把订阅函数onStateChange绑定给父级subscription,进行了层层订阅</p>\n</li>\n<li><p>为了确保拿到的store内容是最新的，所以首先执行了一次checkForUpdates<br><img src=\"https://img-blog.csdnimg.cn/d03af8b00dcd4deaad5bcb09c5cc2903.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5aWH5aSn5Y-U,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n</li>\n</ul>\n<h2 id=\"checkForUpdates\"><a href=\"#checkForUpdates\" class=\"headerlink\" title=\"checkForUpdates\"></a>checkForUpdates</h2><ul>\n<li><p>判断是否需要更新的函数</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调\nconst checkForUpdates &#x3D; () &#x3D;&gt; &#123;\n  if (didUnsubscribe) &#123;\n    &#x2F;&#x2F;如果取消订阅了\n    return\n  &#125;\n   &#x2F;&#x2F; 获取 store 里state\n  const latestStoreState &#x3D; store.getState()q\n  let newChildProps, error\n  try &#123;\n    &#x2F;* 得到最新的 props *&#x2F;\n    newChildProps &#x3D; childPropsSelector(\n      latestStoreState,\n      lastWrapperProps.current\n    )\n  &#125; \n  &#x2F;&#x2F;如果新的合并的 props没有更改，则此处不做任何操作-层叠订阅更新\n  if (newChildProps &#x3D;&#x3D;&#x3D; lastChildProps.current) &#123; \n    if (!renderIsScheduled.current) &#123;  \n      notifyNestedSubs() &#x2F;* 通知子代 subscription 触发 checkForUpdates 来检查是否需要更新。 *&#x2F;\n    &#125;\n  &#125; else &#123;\n    lastChildProps.current &#x3D; newChildProps\n    childPropsFromStoreUpdate.current &#x3D; newChildProps\n    renderIsScheduled.current &#x3D; true\n    &#x2F;&#x2F; 触发useReducer的dispatch来进行更新，该dispatch会改变useReducer返回的previousStateUpdateResult\n    &#x2F;&#x2F; 而previousStateUpdateResult是作为actualChildProps的依赖项引发actualChildProps的改变\n    &#x2F;&#x2F; actualChildProps又是实际渲染组件的依赖性，从而引发组件的重新渲染更新\n    forceComponentUpdateDispatch(&#123;\n      type: &#39;STORE_UPDATED&#39;,\n      payload: &#123;\n        error\n      &#125;\n    &#125;)\n  &#125;\n&#125;</code></pre>\n</li>\n<li><p>checkForUpdates 通过调用 childPropsSelector来形成新的props,然后判断之前的 prop 和当前新的 prop 是否相等。如果相等，证明没有发生变化,无须更新当前组件，那么通过调用notifyNestedSubs来通知子代容器组件，检查是否需要更新。如果不相等证明订阅的store.state发生变化，那么立即执行forceComponentUpdateDispatch来触发组件的更新</p>\n</li>\n</ul>\n<h2 id=\"整个订阅流程\"><a href=\"#整个订阅流程\" class=\"headerlink\" title=\"整个订阅流程\"></a>整个订阅流程</h2><p>整个订阅的流程是，如果被connect包裹，并且具有第一个参数。首先通过context获取最近的 subscription，然后创建一个新的subscription,并且和父级的subscription建立起关联。当第一次hoc容器组件挂在完成后，在useEffect里，进行订阅，将自己的订阅函数checkForUpdates,作为回调函数，通过trySubscribe 和this.parentSub.addNestedSub ,加入到父级subscription的listeners中。由此完成整个订阅流程</p>\n<h2 id=\"整个发布流程\"><a href=\"#整个发布流程\" class=\"headerlink\" title=\"整个发布流程\"></a>整个发布流程</h2><p>整个更新流程是，当组件中调用dispatch触发了redux的state改变和redux的订阅器，从而触发根订阅器的触发listeners.notify ,也就是checkForUpdates函数，然后checkForUpdates函数首先根据mapStoretoprops，mergeprops等操作，验证该组件是否发起订阅，props 是否改变，并更新，如果发生改变，那么触发useReducer的forceComponentUpdateDispatch函数，来更新业务组件，如果没有发生更新，那么通过调用notifyNestedSubs,来通知当前subscription的listeners检查是否更新，然后尽心层层checkForUpdates,逐级向下，借此完成整个更新流程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>connect使用柯里化</li>\n<li>useMemo缓存渲染组件的操作</li>\n<li>发布订阅模式以及通过双向链表来管理</li>\n<li>如何通过Provider进行层层订阅</li>\n<li>react-redux触发更新的依据是actualChildProps是否改变</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/weixin_43294560/article/details/123284317\">react-redux源码解析</a><br><a href=\"https://github.com/841660202/react-redux\">github 源码</a><br><a href=\"https://blog.csdn.net/qq_33715850/article/details/122535984\">React-redux源码解析–准备知识</a><br><a href=\"https://blog.csdn.net/qq_33715850/article/details/122590433\">React-redux源码解析</a></p>\n","text":"源码版本&quot;version&quot;: &quot;8.0.2&quot;, Provider 主要作用通过subscription调用redux中store的subscription产生订阅，订阅内容是onStateChange的回调 通过react的Provider...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"React","slug":"React","count":36,"path":"api/categories/React.json"}],"tags":[{"name":"react-redux","slug":"react-redux","count":2,"path":"api/tags/react-redux.json"},{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":16,"path":"api/tags/源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Provider\"><span class=\"toc-text\">Provider</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Subscription\"><span class=\"toc-text\">Subscription</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createListenerCollection\"><span class=\"toc-text\">createListenerCollection</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#connect\"><span class=\"toc-text\">connect</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#selectorFactory\"><span class=\"toc-text\">selectorFactory</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pureFinalPropsSelectorFactory\"><span class=\"toc-text\">pureFinalPropsSelectorFactory</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#connectHOC\"><span class=\"toc-text\">connectHOC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#wrapWithConnect\"><span class=\"toc-text\">wrapWithConnect</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BC%A0%E9%80%92forwardRef%EF%BC%9F\"><span class=\"toc-text\">为何要传递forwardRef？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ConnectFunction\"><span class=\"toc-text\">ConnectFunction</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#captureWrapperProps\"><span class=\"toc-text\">captureWrapperProps</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#subscribeUpdates\"><span class=\"toc-text\">subscribeUpdates</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#checkForUpdates\"><span class=\"toc-text\">checkForUpdates</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%B8%AA%E8%AE%A2%E9%98%85%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">整个订阅流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%B8%AA%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">整个发布流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"redux 源码 1","uid":"af1b42282a210ca45f834a49b50349c6","slug":"2022-05-25.redux","date":"2022-05-25T05:48:17.000Z","updated":"2022-09-16T14:57:59.791Z","comments":true,"path":"api/articles/2022-05-25.redux.json","keywords":null,"cover":[],"text":"介绍A Predictable State Container for JS Apps package.json&#123; &quot;name&quot;: &quot;redux&quot;, &quot;version&quot;: &quot;5.0.0-alpha.0...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":36,"path":"api/categories/React.json"}],"tags":[{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":16,"path":"api/tags/源码.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"react-redux 源码1","uid":"83401137c3fcd92a859b6d9e289c2c88","slug":"2022-05-24react-redux","date":"2022-05-24T05:58:32.000Z","updated":"2022-09-16T14:57:54.111Z","comments":true,"path":"api/articles/2022-05-24react-redux.json","keywords":null,"cover":null,"text":"react-redux官方介绍 官方UI绑定层。 React Redux is the official React UI bindings layer for Redux. 从redux的store读数据。 It lets your React components read ...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"React","slug":"React","count":36,"path":"api/categories/React.json"}],"tags":[{"name":"react-redux","slug":"react-redux","count":2,"path":"api/tags/react-redux.json"},{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":16,"path":"api/tags/源码.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}