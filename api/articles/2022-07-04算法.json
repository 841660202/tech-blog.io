{"title":"前端基础-js算法","uid":"b6eefb99ab4e0f88e52602483fde65dd","slug":"2022-07-04算法","date":"2022-07-04T07:31:24.000Z","updated":"2023-08-15T02:28:27.803Z","comments":true,"path":"api/articles/2022-07-04算法.json","keywords":null,"cover":[],"content":"<h2 id=\"实现单例\"><a href=\"#实现单例\" class=\"headerlink\" title=\"实现单例\"></a>实现单例</h2><h3 id=\"通过构造函数\"><a href=\"#通过构造函数\" class=\"headerlink\" title=\"通过构造函数\"></a>通过构造函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  constructor() &#123;\n    console.log(&#39;this&#39;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h3 id=\"通过静态方法\"><a href=\"#通过静态方法\" class=\"headerlink\" title=\"通过静态方法\"></a>通过静态方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h2><p><a href=\"/#/post/2022-05-03string\" target=\"_blank\" >见：2022-05-03string</a></p>\n<h2 id=\"实现-JSON-parse\"><a href=\"#实现-JSON-parse\" class=\"headerlink\" title=\"实现 JSON.parse\"></a>实现 JSON.parse</h2><p><code>eval(&#39;(&#39; + sJSON + &#39;)&#39;) </code>, 里面为什么有括号呢</p>\n<p>在 JavaScript 中，<code>eval()</code> 是一个全局函数，它可以将传入的字符串当作 JavaScript 代码来执行。在 <code>eval</code> 函数的参数中，如果传入的字符串以 <code>&#123;</code> 或 <code>[</code> 开头，JavaScript 解释器会将其当作一个块语句或数组字面量来处理，而不是一个对象字面量或数组。</p>\n<p><strong>为了避免将字符串作为块语句或数组字面量处理，我们可以在字符串外面包裹一对括号，将其变成一个表达式，这样 JavaScript 解释器就会将其当作一个对象或数组来处理</strong>。</p>\n<p>具体到你提到的 <code>eval(&#39;(&#39; + sJSON + &#39;)&#39;)</code>，这是为了将 <code>sJSON</code> 这个字符串解析成一个对象或数组。通过在字符串外面添加一对括号，使得 JavaScript 解释器将其作为一个表达式来处理，确保正确地解析成一个对象或数组。这是一种常见的将字符串解析为对象或数组的技巧。</p>\n<h2 id=\"实现-JSON-stringify-考察，有哪些基本数据类型，递归\"><a href=\"#实现-JSON-stringify-考察，有哪些基本数据类型，递归\" class=\"headerlink\" title=\"实现 JSON.stringify (考察，有哪些基本数据类型，递归)\"></a>实现 JSON.stringify (考察，有哪些基本数据类型，递归)</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON#polyfill\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (!window.JSON) &#123;\n  window.JSON &#x3D; &#123;\n    parse: function (sJSON) &#123;\n      return eval(&#39;(&#39; + sJSON + &#39;)&#39;);\n    &#125;,\n    stringify: (function () &#123;\n      var toString &#x3D; Object.prototype.toString;\n      var isArray &#x3D;\n        Array.isArray ||\n        function (a) &#123;\n          return toString.call(a) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;\n        &#125;;\n      var escMap &#x3D; &#123;\n        &#39;&quot;&#39;: &#39;\\\\&quot;&#39;,\n        &#39;\\\\&#39;: &#39;\\\\\\\\&#39;,\n        &#39;\\b&#39;: &#39;\\\\b&#39;,\n        &#39;\\f&#39;: &#39;\\\\f&#39;,\n        &#39;\\n&#39;: &#39;\\\\n&#39;,\n        &#39;\\r&#39;: &#39;\\\\r&#39;,\n        &#39;\\t&#39;: &#39;\\\\t&#39;,\n      &#125;;\n      var escFunc &#x3D; function (m) &#123;\n        return escMap[m] || &#39;\\\\u&#39; + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);\n      &#125;;\n      var escRE &#x3D; &#x2F;[\\\\&quot;\\u0000-\\u001F\\u2028\\u2029]&#x2F;g; &#x2F;&#x2F; \\u2028 行分割符 \\u2029 段分隔符\n      return function stringify(value) &#123;\n        if (value &#x3D;&#x3D; null) &#123;\n          return &#39;null&#39;;\n        &#125; else if (typeof value &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n          return isFinite(value) ? value.toString() : &#39;null&#39;;\n        &#125; else if (typeof value &#x3D;&#x3D;&#x3D; &#39;boolean&#39;) &#123;\n          return value.toString();\n        &#125; else if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n          if (typeof value.toJSON &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n            return stringify(value.toJSON());\n          &#125; else if (isArray(value)) &#123;\n            var res &#x3D; &#39;[&#39;;\n            for (var i &#x3D; 0; i &lt; value.length; i++) res +&#x3D; (i ? &#39;, &#39; : &#39;&#39;) + stringify(value[i]);\n            return res + &#39;]&#39;;\n          &#125; else if (toString.call(value) &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;) &#123;\n            var tmp &#x3D; [];\n            for (var k in value) &#123;\n              if (value.hasOwnProperty(k)) tmp.push(stringify(k) + &#39;: &#39; + stringify(value[k]));\n            &#125;\n            return &#39;&#123;&#39; + tmp.join(&#39;, &#39;) + &#39;&#125;&#39;;\n          &#125;\n        &#125;\n        return &#39;&quot;&#39; + value.toString().replace(escRE, escFunc) + &#39;&quot;&#39;;\n      &#125;;\n    &#125;)(),\n  &#125;;\n&#125;\n&#x2F;&#x2F; 修改\nwindow.j &#x3D; &#123;\n  parse: function (sJSON) &#123;\n    return eval(&#39;(&#39; + sJSON + &#39;)&#39;);\n  &#125;,\n  stringify: (function () &#123;\n    var toString &#x3D; Object.prototype.toString;\n    var isArray &#x3D;\n      Array.isArray ||\n      function (a) &#123;\n        return toString.call(a) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;\n      &#125;;\n    var escMap &#x3D; &#123;\n      &#39;&quot;&#39;: &#39;\\\\&quot;&#39;,\n      &#39;\\\\&#39;: &#39;\\\\\\\\&#39;,\n      &#39;\\b&#39;: &#39;\\\\b&#39;,\n      &#39;\\f&#39;: &#39;\\\\f&#39;,\n      &#39;\\n&#39;: &#39;\\\\n&#39;,\n      &#39;\\r&#39;: &#39;\\\\r&#39;,\n      &#39;\\t&#39;: &#39;\\\\t&#39;,\n    &#125;;\n    var escFunc &#x3D; function (m) &#123;\n      return escMap[m] || &#39;\\\\u&#39; + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);\n    &#125;;\n    var escRE &#x3D; &#x2F;[\\\\&quot;\\u0000-\\u001F\\u2028\\u2029]&#x2F;g; &#x2F;&#x2F; \\u2028 行分割符 \\u2029 段分隔符\n    return function stringify(value) &#123;\n      if (value &#x3D;&#x3D;&#x3D; undefined) &#123;\n        return undefined;\n      &#125; else if (value &#x3D;&#x3D;&#x3D; null) &#123;\n        return &#39;null&#39;;\n      &#125; else if (typeof value &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return isFinite(value) ? value.toString() : &#39;null&#39;;\n      &#125; else if (typeof value &#x3D;&#x3D;&#x3D; &#39;boolean&#39;) &#123;\n        return value.toString();\n      &#125; else if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n        if (typeof value.toJSON &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n          return stringify(value.toJSON());\n        &#125; else if (isArray(value)) &#123;\n          var res &#x3D; &#39;[&#39;;\n          for (var i &#x3D; 0; i &lt; value.length; i++) res +&#x3D; (i ? &#39;, &#39; : &#39;&#39;) + stringify(value[i]);\n          return res + &#39;]&#39;;\n        &#125; else if (toString.call(value) &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;) &#123;\n          var tmp &#x3D; [];\n          for (var k in value) &#123;\n            if (value.hasOwnProperty(k)) tmp.push(stringify(k) + &#39;: &#39; + stringify(value[k]));\n          &#125;\n          return &#39;&#123;&#39; + tmp.join(&#39;, &#39;) + &#39;&#125;&#39;;\n        &#125;\n      &#125;\n      &#x2F;&#x2F; 其他情况\n      return &#39;&quot;&#39; + value.toString().replace(escRE, escFunc) + &#39;&quot;&#39;;\n    &#125;;\n  &#125;)(),\n&#125;;\n\n&#x2F;&#x2F; unicode 转译</code></pre>\n\n<h2 id=\"深度操作\"><a href=\"#深度操作\" class=\"headerlink\" title=\"深度操作\"></a>深度操作</h2><h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><h4 id=\"structuredClone\"><a href=\"#structuredClone\" class=\"headerlink\" title=\"structuredClone\"></a>structuredClone</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/web/api/structuredClone\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Create an object with a value and a circular reference to itself.\nconst original &#x3D; &#123; name: &quot;MDN&quot; , hello: &#123;world: true&#125;&#125;;\noriginal.itself &#x3D; original;\n\n&#x2F;&#x2F; Clone it\nconst clone &#x3D; structuredClone(original);\n\nconsole.log(clone !&#x3D;&#x3D; original); &#x2F;&#x2F;  true  the objects are not the same (not same identity)\nconsole.log(clone.name &#x3D;&#x3D;&#x3D; &quot;MDN&quot;); &#x2F;&#x2F; true  they do have the same values\nconsole.log(clone.itself &#x3D;&#x3D;&#x3D; clone); &#x2F;&#x2F; true and the circular reference is preserved\nconsole.log(clone.hello &#x3D;&#x3D;&#x3D; original.hello) false</code></pre>\n\n<h4 id=\"深度克隆\"><a href=\"#深度克隆\" class=\"headerlink\" title=\"深度克隆\"></a>深度克隆</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function isBase &#x3D; (val) &#x3D;&gt; &#123;\n  return val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &quot;object&quot;\n&#125;\n\nfunction isObject(obj) &#123;\n  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Object]&quot;;\n&#125;\n\nfunction isArray(obj) &#123;\n  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Array]&quot;;\n&#125;\n\nfunction deepClone(obj) &#123;\n  let result;\n  if (isBase(obj)) &#123;\n    &#x2F;&#x2F;基本数据类型，直接赋值\n    result &#x3D; obj;\n  &#125; else &#123;\n    &#x2F;&#x2F; 非基本数据类型，遍历赋值\n    result &#x3D; isArray(obj) ? [] : &#123;&#125;; &#x2F;&#x2F; 空对象接收\n    for (let i in obj) &#123;\n      &#x2F;&#x2F; 非基本数据类型，进行深度拷贝\n      &#x2F;&#x2F; prettier-ignore\n      result[i] &#x3D; isObject(obj[i]) || isArray(obj[i]) ? deepClone(obj[i]) : obj[i];\n    &#125;\n  &#125;\n  return result;\n&#125;</code></pre>\n\n<h4 id=\"深比较\"><a href=\"#深比较\" class=\"headerlink\" title=\"深比较\"></a>深比较</h4><p>实现一个 compare 函数，比较两个对象是否相同<a href=\"https://www.jianshu.com/p/0828ded57b19#:~:text=%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83-,%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A,-//%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 原理：\n * 1. 基本数据类型比较\n * 2. 复合类型，递归每个值依次比较\n **&#x2F;\n&#x2F;&#x2F; 基础类型&#x2F;null的数据类型，可以直接比较\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &#39;object&#39;;\n\nfunction deepCompare(a, b) &#123;\n  &#x2F;&#x2F; 基本数据类型\n  if (isBase(a) || isBase(b)) &#123;\n    return a &#x3D;&#x3D;&#x3D; b || (isNaN(a) &amp;&amp; isNaN(b));\n  &#125;\n  &#x2F;&#x2F; Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。\n  const propsA &#x3D; Object.getOwnPropertyDescriptors(a);\n  const propsB &#x3D; Object.getOwnPropertyDescriptors(b);\n  &#x2F;&#x2F; 键是否长度一致\n  if (Object.keys(propsA).length !&#x3D;&#x3D; Object.keys(propsB).length) &#123;\n    return false;\n  &#125;\n  &#x2F;&#x2F; 键对应相等\n  return Object.keys(propsA).every((key) &#x3D;&gt; deepCompare(a[key], b[key]));\n&#125;</code></pre>\n\n<h4 id=\"深度获取差异化\"><a href=\"#深度获取差异化\" class=\"headerlink\" title=\"深度获取差异化\"></a>深度获取差异化</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 是否为基础数据类型\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &#39;object&#39;;\nconst isNumber &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &#39;[object Number]&#39;;\n&#x2F;&#x2F; 深度比较两个对象的差异\nfunction deepDiffCompare(a, b, diffResult, k &#x3D; &#39;root&#39;) &#123;\n  &#x2F;&#x2F; 基本数据类型\n  if (isBase(a) || isBase(b)) &#123;\n    &#x2F;&#x2F; return a &#x3D;&#x3D;&#x3D; b;\n    if (a !&#x3D;&#x3D; b) &#123;\n      diffResult[k] &#x3D; b;\n    &#125; else &#123;\n      &#x2F;&#x2F; console.log(&quot;数据一致忽略&quot;);\n    &#125;\n  &#125; else &#123;\n    const propsA &#x3D; Object.keys(a);\n    const propsB &#x3D; Object.keys(b);\n    const uukeys &#x3D; new Set([...propsA, ...propsB]);\n    &#x2F;&#x2F; 键对应相等\n    uukeys.forEach((key) &#x3D;&gt; deepDiffCompare(a[key], b[key], diffResult, key));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 必填数据\nconst requireds &#x3D; [&#39;sex&#39;];\n&#x2F;&#x2F; 模拟数据\nconst old &#x3D; &#123; name: 1, age: 2, dog: &#123; name: &#39;小狗&#39;, do: &#39;汪汪叫&#39; &#125; &#125;;\nconst newValue &#x3D; &#123; name: 1, age: 2, sex: 1 &#125;;\n&#x2F;&#x2F; 执行比较测试\nhandleCompare(old, newValue);\n\n&#x2F;&#x2F; 这里涉及到函数声明提升，写在后面不影响使用\nfunction handleCompare(old, newValue, onChange) &#123;\n  let diffResult &#x3D; &#123;&#125;;\n\n  deepDiffCompare(old, newValue, diffResult);\n\n  &#x2F;&#x2F; console.log(&quot;diffResult&quot;, diffResult);\n  &#x2F;&#x2F; 变化的数据，在必填数据中，则hasChange为true, 否则为false\n  const hasChange &#x3D; Object.keys(diffResult).some((k) &#x3D;&gt; requireds.includes(k));\n\n  &#x2F;&#x2F; console.log(&quot;hasChange&quot;, hasChange);\n  hasChange &amp;&amp; onChange?.();\n&#125;\n\n&#x2F;&#x2F; vue中使用\n&#x2F;&#x2F; watch: &#123;\n&#x2F;&#x2F;   &#39;submitForm&#39;: &#123;\n&#x2F;&#x2F;      handler(val, oldVal) &#123;\n&#x2F;&#x2F;       console.log(&#39;c changed&#39;)\n&#x2F;&#x2F;       handleCompare(oldVal, val, ()&#x3D;&gt;&#123;\n&#x2F;&#x2F;         this.clearTableData()\n&#x2F;&#x2F;       &#125;)\n&#x2F;&#x2F;     &#125;,\n&#x2F;&#x2F;     deep: true\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F;  &#125;</code></pre>\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h3 id=\"uuid\"><a href=\"#uuid\" class=\"headerlink\" title=\"uuid\"></a>uuid</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const getUniqueID &#x3D; ((id) &#x3D;&gt; () &#x3D;&gt; &#123;\n  id +&#x3D; 1;\n  return id;\n&#125;)(-1);\n\n&#x2F;&#x2F; getUniqueID\n&#x2F;&#x2F; () &#x3D;&gt; &#123;\n&#x2F;&#x2F;   id +&#x3D; 1;\n&#x2F;&#x2F;   return id;\n&#x2F;&#x2F; &#125;</code></pre>\n\n<h3 id=\"操作后防抖\"><a href=\"#操作后防抖\" class=\"headerlink\" title=\"操作后防抖\"></a>操作后防抖</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 去抖动原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时.\n&#x2F;&#x2F; 方法1\nconst debounce &#x3D; function (fn, delay) &#123;\n  let timer &#x3D; null; &#x2F;&#x2F; 闭包维护一个timer\n  return (...args) &#x3D;&gt; &#123;\n    clearTimeout(timer);\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn?.apply(this, args); &#x2F;&#x2F; this指向window\n    &#125;, delay);\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; 测试\n\nlet biu &#x3D; function () &#123;\n  console.log(&#39;biu biu biu&#39;, new Date().getTime());\n&#125;;\nlet boom &#x3D; function () &#123;\n  console.log(&#39;boom boom boom&#39;, new Date().getTime());\n&#125;;\n\nvar a &#x3D; setInterval(debounce(biu, 500), 1000);\nvar b &#x3D; setInterval(debounce(boom, 2000), 1000);\nsetTimeout(() &#x3D;&gt; &#123;\n  clearInterval(a);\n  clearInterval(b);\n&#125;, 10000);</code></pre>\n\n<h3 id=\"执行一次后防抖\"><a href=\"#执行一次后防抖\" class=\"headerlink\" title=\"执行一次后防抖\"></a>执行一次后防抖</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function debounceStart(fn, delay &#x3D; 0) &#123;\n  let immediate &#x3D; true;\n  let timerId &#x3D; null;\n  return function (...args) &#123;\n    if (immediate) &#123;\n      fn.apply(this, args);\n      immediate &#x3D; false;\n    &#125;\n    clearTimeout(timerId);\n    timerId &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      immediate &#x3D; true;\n    &#125;, delay);\n  &#125;;\n&#125;</code></pre>\n\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const throttle &#x3D; (fn, delay &#x3D; 500) &#x3D;&gt; &#123;\n  let allow &#x3D; true; &#x2F;&#x2F; 守门员，delay秒钟放进去一个球\n\n  return (...args) &#x3D;&gt; &#123;\n    if (!allow) return;\n    allow &#x3D; false;\n\n    setTimeout(() &#x3D;&gt; &#123;\n      fn.apply(this, args);\n      allow &#x3D; true;\n    &#125;, delay);\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"接口数据缓存\"><a href=\"#接口数据缓存\" class=\"headerlink\" title=\"接口数据缓存\"></a>接口数据缓存</h3><h3 id=\"实现-JS-函数记忆\"><a href=\"#实现-JS-函数记忆\" class=\"headerlink\" title=\"实现 JS 函数记忆\"></a>实现 JS 函数记忆</h3><p>函数记忆（Function Memoization）是一种优化技术，用于缓存函数的计算结果，避免在相同输入参数下重复计算。这可以提高函数执行效率，特别是在递归等场景下。</p>\n<p>以下是一个简单的 JavaScript 函数记忆的实现，使用一个缓存对象来保存已计算的结果：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function memoize(func) &#123;\n  const cache &#x3D; new Map();\n  return function (...args) &#123;\n    const key &#x3D; JSON.stringify(args);\n    if (cache.has(key)) &#123;\n      return cache.get(key);\n    &#125; else &#123;\n      const result &#x3D; func(...args);\n      cache.set(key, result);\n      return result;\n    &#125;\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 示例使用\nfunction expensiveOperation(x, y) &#123;\n  console.log(&#96;Calculating $&#123;x&#125; + $&#123;y&#125;&#96;);\n  return x + y;\n&#125;\n\nconst memoizedOperation &#x3D; memoize(expensiveOperation);\n\nconsole.log(memoizedOperation(2, 3)); &#x2F;&#x2F; 第一次计算\nconsole.log(memoizedOperation(2, 3)); &#x2F;&#x2F; 从缓存中取结果\nconsole.log(memoizedOperation(3, 4)); &#x2F;&#x2F; 新的输入参数，再次计算\nconsole.log(memoizedOperation(2, 3)); &#x2F;&#x2F; 从缓存中取结果</code></pre>\n\n<p>在这个示例中，我们定义了一个 <code>memoize</code> 函数，它接受一个需要记忆的函数 <code>func</code> 作为参数，并返回一个新的函数。这个新函数会在计算前检查缓存中是否已经有了相同的输入参数的计算结果。如果有，则直接返回缓存中的结果，否则执行原始函数，将计算结果存入缓存。</p>\n<p>在示例中，我们定义了一个 <code>expensiveOperation</code> 函数，模拟一个耗时的计算操作。然后使用 <code>memoize</code> 包装这个函数，得到 <code>memoizedOperation</code> 函数，用于记忆结果。第一次计算会触发实际的计算操作，后续相同的输入参数会直接从缓存中取结果，避免重复计算。</p>\n<h2 id=\"this-指向\"><a href=\"#this-指向\" class=\"headerlink\" title=\"this 指向\"></a>this 指向</h2><p><a href=\"https://juejin.cn/post/6977563249650696206\" target=\"_blank\" >https://juejin.cn/post/6977563249650696206</a></p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><p><strong>作用： 在指定的上下文中调用函数</strong></p>\n<ul>\n<li>语法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function.call(thisArg, arg1, arg2, ...)\n</code></pre>\n\n<p>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 即：可以改变当前函数的 this 指向；还会让当前函数执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 给函数原型添加mycall方法，创建一个上下文对象context，如果传入的对象不存在时，将指向全局window。\n&#x2F;&#x2F; 2. 通过给context添加fn属性，context的fn引用调用该方法的函数fun，并执行fun。\n&#x2F;&#x2F; 3. 执行完成之后删除该属性fn。\nFunction.prototype.mycall &#x3D; function (context, ...args) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  context &#x3D; context &#x3D;&#x3D; null || context &#x3D;&#x3D; undefined ? window : new Object(context);\n  context.fn &#x3D; this;\n  let r &#x3D; context.fn(...args);\n  delete context.fn;\n  return r;\n&#125;;\n\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123; name: &#39;clying&#39; &#125;;\nfun.mycall(obj, &#39;deng&#39;, &#39;deng&#39;);</code></pre>\n\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p><strong>与 call() 不同的是，apply() 接受一个参数数组作为参数，而不是逐个列出参数</strong></p>\n<ul>\n<li>语法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">apply(thisArg);\napply(thisArg, argsArray);</code></pre>\n\n<ol>\n<li>与 call 方法类似，call 方法接收的是一个参数列表，而 apply 方法接收的是一个包含多个参数的数组。</li>\n<li>用法 将函数中的 this 指向传入的第一个参数，第二个参数为数组</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Function.prototype.myapply &#x3D; function (context, args) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  context &#x3D; context &#x3D;&#x3D; null || context &#x3D;&#x3D; undefined ? window : new Object(context);\n\n  context.fn &#x3D; this;\n\n  if (!args) return context.fn();\n  &#x2F;&#x2F; args 数组被转化成字符串\n  let r &#x3D; eval(&#39;context.fn(&#39; + args + &#39;)&#39;);\n  delete context.fn;\n  return r;\n&#125;;</code></pre>\n\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><p><strong>与 call() 和 apply() 不同，bind() 并不会立即调用函数，而是返回一个新的函数，可以稍后调用。</strong></p>\n<p><strong>更像是数据收集，通过柯里化，减少参数，方便后续调用</strong></p>\n<ol>\n<li>bind() 方法<code>创建一个新的函数，不自动执行，需要手动调用 bind()</code> 。</li>\n<li>这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</li>\n<li>用法将 obj 绑定到 fun 函数的 this 上，函数 fun 可以使用 obj 内部的属性，和传入的变量。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 应用于curry，要理解\nFunction.prototype.mybind &#x3D; function (context) &#123;\n  let that &#x3D; this;\n  let bindargs &#x3D; Array.prototype.slice.call(arguments, 1);\n  &#x2F;&#x2F; 产生闭包\n  function fBind() &#123;\n    let args &#x3D; Array.prototype.slice.call(arguments);\n    &#x2F;&#x2F; 1. 如果使用的是new，那么this会指向fBind实例，this作为当前实例传入\n    &#x2F;&#x2F; 2. 不是new的话，使用context上下文对象\n    &#x2F;&#x2F; prettier-ignore\n    return that.apply(\n      &#x2F;*瞧瞧this的上下文*&#x2F; \n      this instanceof fBind ? this : context, \n      bindargs.concat(args)\n    ) &#x2F;&#x2F; 通过闭包获取更多的参数;\n  &#125;\n\n  return fBind;\n&#125;;\n\n&#x2F;&#x2F; 测试1\n\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123;\n  name: &#39;clying&#39;,\n&#125;;\nlet b &#x3D; fun.mybind(obj, 2);\nb(3);\n&#x2F;&#x2F; clying Arguments(2) [2, 3]\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F; 测试2\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123;\n  name: &#39;clying&#39;,\n&#125;;\nfun.prototype.age &#x3D; 23;\nlet b &#x3D; fun.mybind(obj, 3);\nlet instance &#x3D; new b(4);\nconsole.log(instance.age);\n&#x2F;&#x2F;undefined Arguments(2) [3, 4]\n&#x2F;&#x2F; 23</code></pre>\n\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h3 id=\"实现-sleep-方法\"><a href=\"#实现-sleep-方法\" class=\"headerlink\" title=\"实现 sleep 方法\"></a>实现 sleep 方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function sleep(ms) &#123;\n  return new Promise((resolve) &#x3D;&gt; setTimeout(resolve, ms));\n&#125;\n\n&#x2F;&#x2F; 使用示例\nconsole.log(&#39;Start&#39;);\nsleep(2000).then(() &#x3D;&gt; &#123;\n  console.log(&#39;After 2 seconds&#39;);\n&#125;);</code></pre>\n\n<p><a href=\"https://blog.csdn.net/weixin_45774485/article/details/122462081\" target=\"_blank\" >手写 promise 的方法（all、race、allSettled、any、finally）</a></p>\n<h3 id=\"手写-promise\"><a href=\"#手写-promise\" class=\"headerlink\" title=\"手写 promise\"></a>手写 promise</h3><p><a href=\"https://juejin.cn/post/7194257890893365308\" target=\"_blank\" >5K 字 由浅入深聊聊 Promise 实现原理</a></p>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><ul>\n<li>要么返回全部 resolve 结果，要么返回一个 reject</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myAll &#x3D; function (promises) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    if (!isArray(promises)) &#123;\n      return reject(new TypeError(&#39;arguments must be an array&#39;));\n    &#125;\n\n    let res &#x3D; [];\n    var resolvedCounter &#x3D; 0;\n    var promiseNum &#x3D; promises.length;\n\n    promises.forEach((promise, index) &#x3D;&gt; &#123;\n      Promise.resolve(promise) &#x2F;&#x2F; 防止你不是一个promise\n        &#x2F;&#x2F; 如果参数是一个原始值,或者是一个不具有then方法的对象,则Promise.resolve方法返回一个新的 Promise 对象,状态为resolved\n        &#x2F;&#x2F; @link https:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html\n        .then((data) &#x3D;&gt; &#123;\n          resolvedCounter++;\n          res.push(data);\n          &#x2F;&#x2F; 所有的都没有异常\n          promiseNum &#x3D;&#x3D;&#x3D; resolvedCounter &amp;&amp; resolve(res);\n        &#125;)\n        .catch((err) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 捕获，直接返回\n          reject(err);\n        &#125;);\n    &#125;);\n  &#125;);\n&#125;;</code></pre>\n\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><ul>\n<li>不管 resolve, reject，见到就返回</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myRace &#x3D; (promises) &#x3D;&gt;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    promises?.forEach((promise) &#x3D;&gt; &#123;\n      promise.then(resolve, reject);\n    &#125;);\n  &#125;);</code></pre>\n\n<h3 id=\"Promise-allSettle\"><a href=\"#Promise-allSettle\" class=\"headerlink\" title=\"Promise.allSettle\"></a>Promise.allSettle</h3><ul>\n<li>全部结果，resolve, reject 都要</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myAllSettled &#x3D; function (promises) &#123;\n  let len &#x3D; promises.length;\n  let count &#x3D; 0;\n  let result &#x3D; new Array(len);\n\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    for (let p of promises) &#123;\n      Promise.resolve(p).then(\n        (res) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;成功：加入装状态列表\n          result[count] &#x3D; &#123;\n            &#x2F;&#x2F;记录当前promise信息\n            status: &#39;fullfilled&#39;,\n            result: res,\n          &#125;;\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F;遍历完，走resolve\n            resolve(result);\n          &#125;\n        &#125;,\n        (err) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;失败：加入状态列表\n          result[count] &#x3D; &#123;\n            &#x2F;&#x2F;记录当前promise状态信息\n            status: &#39;rejected&#39;,\n            result: err,\n          &#125;;\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F;遍历完依然走resolve\n            reject(result);\n          &#125;\n        &#125;\n      );\n    &#125;\n  &#125;);\n&#125;;</code></pre>\n\n<h3 id=\"Promise-any\"><a href=\"#Promise-any\" class=\"headerlink\" title=\"Promise.any\"></a>Promise.any</h3><ul>\n<li>要么没有 resolve 的,返回全部 reject 结果，要么有一个 resolve 的返回 resolve 结果(看上去和<code>Promise.all</code>刚好反过来了)</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myAny &#x3D; function (promises) &#123;\n  let res &#x3D; [],\n    count &#x3D; 0,\n    len &#x3D; promises.length;\n\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    for (let p of promises) &#123;\n      Promise.resolve(p).then(\n        (res) &#x3D;&gt; &#123;\n          resolve(res); &#x2F;&#x2F; 只要有一个成功，就走resolve\n        &#125;,\n        (err) &#x3D;&gt; &#123;\n          res[count] &#x3D; err; &#x2F;&#x2F; 遇到错误先不管，继续检查\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F; 直到遇到成功的或检查完\n            reject(res);\n          &#125;\n        &#125;\n      );\n    &#125;\n  &#125;);\n&#125;;</code></pre>\n\n<h3 id=\"Promise-finally\"><a href=\"#Promise-finally\" class=\"headerlink\" title=\"Promise.finally\"></a>Promise.finally</h3><ul>\n<li>无论哪个执行完，回调下</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.prototype.myFinally &#x3D; function (cb) &#123;\n  &#x2F;&#x2F;cb就是要共同执行的逻辑\n  return this.then(\n    &#x2F;&#x2F;谁调用finally，this就是谁\n    (value) &#x3D;&gt; Promise.resolve(cb()), &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb\n    (error) &#x3D;&gt; Promise.resolve(cb()) &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb\n  );\n&#125;;</code></pre>\n\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p><a href=\"https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html\" target=\"_blank\" >见 Promise.resolve（）详解</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.prototype.myResolve &#x3D; function (params) &#123;\n  return new Promise((resolve) &#x3D;&gt; resolve(params));\n&#125;;</code></pre>\n\n<h3 id=\"阻断-resolve-x2F-reject-后面代码还会执行\"><a href=\"#阻断-resolve-x2F-reject-后面代码还会执行\" class=\"headerlink\" title=\"阻断 resolve&#x2F;reject 后面代码还会执行\"></a>阻断 resolve&#x2F;reject 后面代码还会执行</h3><p><a href=\"https://www.freesion.com/article/68121031859/\" target=\"_blank\" >使用 Promise 过程中 resolve 或 reject 后，后面代码还会执行，默认加 return 较妥</a></p>\n<h3 id=\"限制并发数量\"><a href=\"#限制并发数量\" class=\"headerlink\" title=\"限制并发数量\"></a>限制并发数量</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 原理：将在用数量，限制在最大数量内的异步直接发，\n&#x2F;&#x2F; 限制外的现存到数组中，当在用数量减少时一个一个取出来运行\nexport class LimitPromise &#123;\n  private limit: number;        &#x2F;&#x2F; 最大限制数\n  private runningcount: number;        &#x2F;&#x2F; 目前并发的数量\n  private taskQueue: any[];     &#x2F;&#x2F; 如果并发数等于最大限制，则把新加的异步操作用数组存起来\n\n  constructor(limit: number) &#123;\n    this.limit &#x3D; limit;\n    this.runningcount &#x3D; 0;\n    this.taskQueue &#x3D; [];\n  &#125;\n  &#x2F;&#x2F; 出队列\n  private createTask(\n    asyncFn: Function,\n    args: any[],\n    resolve: (value: unknown) &#x3D;&gt; void,\n    reject: (reason?: any) &#x3D;&gt; void,\n  ) &#123;\n    return () &#x3D;&gt; &#123;\n      asyncFn(...args)\n        .then(resolve)\n        .catch(reject)\n        .finally(() &#x3D;&gt; &#123;\n          this.runningcount--; &#x2F;&#x2F; 任务结束后，对任务队列进行出列，执行\n          if (this.taskQueue.length) &#123;\n            let task &#x3D; this.taskQueue.shift();\n            task();\n          &#125;\n        &#125;);\n\n      this.runningcount++; &#x2F;&#x2F; 在执行的数量\n    &#125;;\n  &#125;\n  &#x2F;&#x2F; 入队列\n  public call(asyncFn: Function, ...args: any[]) &#123;\n    &#x2F;&#x2F; 这层promise令人费解，主要是为了提供resolve和reject给 limitP.call，\n    &#x2F;&#x2F; 这样limitP可以做些其他的事情，理论上没有必要\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      const task &#x3D; this.createTask(asyncFn, args, resolve, reject); &#x2F;&#x2F; 创建任务\n      if (this.runningcount &gt;&#x3D; this.limit) &#123; &#x2F;&#x2F; 大于限制的存起来\n        this.taskQueue.push(task);\n      &#125; else &#123; &#x2F;&#x2F; 否则直接执行\n        task();\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n\nlet limitP &#x3D; new LimitPromise(3)\n\n\n\n&#x2F;&#x2F; 测试\nfunction sleep(sec: number) &#123;\n  console.log(&#39;..............&#39;);\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(&#39;等待了&#39; + sec + &#39;秒&#39;);\n      resolve(&#39;&#39;);\n    &#125;, sec * 1000);\n  &#125;);\n&#125;\n\nlimitP.call(sleep, 1);\nlimitP.call(sleep, 2);\nlimitP.call(sleep, 3);\nlimitP.call(sleep, 4);\nlimitP.call(sleep, 5);\nlimitP.call(sleep, 6);\n&#x2F;&#x2F; https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;typescript-sdhev3?file&#x3D;index.ts</code></pre>\n\n<h3 id=\"PromiseQueue\"><a href=\"#PromiseQueue\" class=\"headerlink\" title=\"PromiseQueue\"></a>PromiseQueue</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 入队列\n&#x2F;&#x2F; 出队列\nclass PromiseQueue &#123;\n  constructor(tasks, limit &#x3D; 1) &#123;\n    this.tasks &#x3D; tasks;\n    this.limit &#x3D; limit;\n    this.running &#x3D; [];\n  &#125;\n  next() &#123;\n    return this.running.length &lt; this.limit &amp;&amp; this.tasks.length;\n  &#125;\n\n  run() &#123;\n    while (this.next()) &#123;\n      let promise &#x3D; this.tasks.shift(); &#x2F;&#x2F; 更改tasks数组长度\n\n      promise.then((data) &#x3D;&gt; &#123;\n        this.run();\n      &#125;);\n\n      this.running.push(promise); &#x2F;&#x2F; 更改running数组长度\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 接收一个promise数组，并发限制为3\nconst taskQueue &#x3D; new PromiseQueue(tasks, 3);\ntaskQueue.run();\n\n&#x2F;&#x2F; 清理\n&#x2F;&#x2F; taskQueue &#x3D; undefined</code></pre>\n\n<h3 id=\"async-await-原理实现\"><a href=\"#async-await-原理实现\" class=\"headerlink\" title=\"async await 原理实现\"></a>async await 原理实现</h3><p><a href=\"https://juejin.cn/post/7007031572238958629#heading-15\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://juejin.cn/post/7195358576364224568\" target=\"_blank\" >仅“2k”字就能理解的 async&#x2F;await 原理，摸个鱼的时间搞定它</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，\n&#x2F;&#x2F; 它返回一个 Generator 对象\n&#x2F;&#x2F; generator对象由生成器函数生成\n\n&#x2F;&#x2F;接受一个Generator函数作为参数\nfunction myAsync(gen) &#123;\n  &#x2F;&#x2F; 返回一个函数\n  return function () &#123;\n    &#x2F;&#x2F; 返回一个promise\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 执行Generator函数\n      &#x2F;&#x2F; generator返回什么\n      let g &#x3D; gen();\n\n      const next &#x3D; (context) &#x3D;&gt; &#123;\n        let res;\n        try &#123;\n          res &#x3D; g.next(context);\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n        if (res.done) &#123;\n          &#x2F;&#x2F; 这时候说明已经是完成了，需要返回结果\n          resolve(res.value);\n        &#125; else &#123;\n          &#x2F;&#x2F; 继续执行next函数,传入执行结果\n          return Promise.resolve(res.value).then(\n            (val) &#x3D;&gt; next(val),\n            (err) &#x3D;&gt; next(err)\n          );\n        &#125;\n      &#125;;\n      next();\n    &#125;);\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nconst getFetch &#x3D; (nums) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(nums + 1);\n  &#125;, 1000);\n&#125;);\n\nfunction* gen() &#123;\n  let res1 &#x3D; yield getFetch(1);\n  let res2 &#x3D; yield getFetch(res1);\n  let res3 &#x3D; yield getFetch(res2);\n  return res3;\n&#125;\n\nconst asyncGen &#x3D; myAsync(gen &#x2F;*传入generator *&#x2F;);\n\nasyncGen().then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;); &#x2F;&#x2F; 4</code></pre>\n\n<h3 id=\"实现异步串行和异步并行\"><a href=\"#实现异步串行和异步并行\" class=\"headerlink\" title=\"实现异步串行和异步并行\"></a>实现异步串行和异步并行</h3><p>异步串行和异步并行是 JavaScript 异步编程中常见的两种模式。异步串行是指按照顺序依次执行多个异步任务，前一个任务完成后再执行下一个任务。异步并行是指同时执行多个异步任务，不需要等待前一个任务完成。</p>\n<p>以下是一个简单的示例，展示了如何实现异步串行和异步并行：</p>\n<p><strong>异步串行</strong>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function asyncTask(value, delay) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(value);\n      resolve();\n    &#125;, delay);\n  &#125;);\n&#125;\n\nasync function asyncSerial() &#123;\n  await asyncTask(&#39;Task 1&#39;, 2000);\n  await asyncTask(&#39;Task 2&#39;, 1000);\n  await asyncTask(&#39;Task 3&#39;, 3000);\n  console.log(&#39;All tasks completed&#39;);\n&#125;\n\nasyncSerial();</code></pre>\n\n<p><strong>异步并行</strong>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function asyncTask(value, delay) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(value);\n      resolve();\n    &#125;, delay);\n  &#125;);\n&#125;\n\nasync function asyncParallel() &#123;\n  const promises &#x3D; [asyncTask(&#39;Task 1&#39;, 2000), asyncTask(&#39;Task 2&#39;, 1000), asyncTask(&#39;Task 3&#39;, 3000)];\n  await Promise.all(promises);\n  console.log(&#39;All tasks completed&#39;);\n&#125;\n\nasyncParallel();</code></pre>\n\n<p>在异步串行的示例中，每个任务完成后才会继续执行下一个任务。在异步并行的示例中，所有任务同时开始执行，但在所有任务都完成后才会继续执行后续的代码。</p>\n<p>需要注意的是，在真实的异步并行中，可能需要考虑并行任务的数量和性能等问题，以避免过多的并发导致性能下降。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><p><a href=\"https://blog.csdn.net/weixin_45663702/article/details/123504807\" target=\"_blank\" >常见前端面试题–数组去重</a></p>\n<p>方案 1:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function unique(arr) &#123;\n  return Array.from(new Set(arr));\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [&#39;1&#39;, &#39;true&#39;, true, 15, undefined, null, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]\n&#x2F;&#x2F;无法去掉&#39;&#123;&#125;&#39;空对象</code></pre>\n\n<p>方案 2:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function unique(arr) &#123;\n  return arr.filter(function (item, index, arr) &#123;\n    &#x2F;&#x2F; 当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;\n  &#125;);\n&#125;\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]\n&#x2F;&#x2F; &#123;&#125;不能去重</code></pre>\n\n<p>方案 3:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function unique(arr) &#123;\n  return arr.reduce((prev, cur) &#x3D;&gt; (prev.includes(cur) ? prev : [...prev, cur]), []);\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]</code></pre>\n\n<h3 id=\"将奇数排在前面，偶数排在后面\"><a href=\"#将奇数排在前面，偶数排在后面\" class=\"headerlink\" title=\"将奇数排在前面，偶数排在后面\"></a>将奇数排在前面，偶数排在后面</h3><p>要求时间复杂度 O(n)。空间复杂度 O(1)（不能用 splice）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var testAry &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9];\nvar newAry &#x3D; [];\n\ntestAry.forEach((item, i) &#x3D;&gt; &#123;\n  let n &#x3D; Number(item);\n  if (n % 2 &#x3D;&#x3D; 0) &#123;\n    newAry.push(n);\n  &#125; else &#123;\n    newAry.unshift(n);\n  &#125;\n&#125;);\n\nconsole.log(newAry); &#x2F;&#x2F;[&quot;9&quot;,&quot;7&quot;,&quot;5&quot;,&quot;3&quot;,&quot;1&quot;,&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]</code></pre>\n\n<h3 id=\"数组转树结构\"><a href=\"#数组转树结构\" class=\"headerlink\" title=\"数组转树结构\"></a>数组转树结构</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [\n    &#123; id: 1, pid: 0 &#125;,\n    &#123; id: 2, pid: 1 &#125;,\n    &#123; id: 3, pid: 1 &#125;,\n    &#123; id: 4, pid: 2 &#125;,\n    &#123; id: 5, pid: 2 &#125;,\n    &#123; id: 6, pid: 3 &#125;,\n];\n&#x2F;&#x2F; 要求编写一个函数 arr2tree(arr)，得到输出结果如下：\n\n&#123;\n    &quot;id&quot;: 0,\n    &quot;children&quot;: [\n        &#123;\n            &quot;id&quot;: 1,\n            &quot;children&quot;: [\n                &#123;\n                    &quot;id&quot;: 2,\n                    &quot;children&quot;: [\n                        &#123;\n                            &quot;id&quot;: 4\n                        &#125;,\n                        &#123;\n                            &quot;id&quot;: 5\n                        &#125;\n                    ]\n                &#125;,\n                &#123;\n                    &quot;id&quot;: 3,\n                    &quot;children&quot;: [\n                        &#123;\n                            &quot;id&quot;: 6\n                        &#125;\n                    ]\n                &#125;\n            ]\n        &#125;\n    ]\n&#125;</code></pre>\n\n<p><strong>实现</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function arr2tree(arr) &#123;\n  let hash &#x3D; &#123;&#125;;\n  const result &#x3D; [];\n  &#x2F;&#x2F; 放到对象中\n  for (let item of arr) &#123;\n    hash[item.id] &#x3D; item;\n  &#125;\n\n  for (let item of arr) &#123;\n    const parent &#x3D; hash[item.pid];\n    if (parent) &#123;\n      if (!parent.children) &#123;\n        parent.children &#x3D; [];\n      &#125;\n      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除\n      parent.children.push(item); &#x2F;&#x2F; 之所以能够实现，原因：使用了数组引用\n    &#125; else &#123;\n      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除\n      result.push(item); &#x2F;&#x2F; 只有第一次pid &#x3D; 0的时候，树根节点才走这里\n    &#125;\n  &#125;\n  hash &#x3D; undefined; &#x2F;&#x2F; 这里记得回收\n  return result;\n&#125;\n\nconst res &#x3D; arr2tree(arr);\nconsole.log(&#39;res&#39;, JSON.stringify(res, null, 2));</code></pre>\n\n<h3 id=\"地址数据处理\"><a href=\"#地址数据处理\" class=\"headerlink\" title=\"地址数据处理\"></a>地址数据处理</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; input &#x3D; [\n&#x2F;&#x2F;   &#123;id:1,city:&#39;北京&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:2,city:&#39;河南&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:3,city:&#39;山西&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:4,city:&#39;洛阳&#39;,pid:2&#125;,\n&#x2F;&#x2F;   &#123;id:5,city:&#39;晋中&#39;,pid:3&#125;,\n&#x2F;&#x2F;   &#123;id:6,city:&#39;榆次&#39;,pid:5&#125;,\n&#x2F;&#x2F; ]\n&#x2F;&#x2F; result &#x3D; [\n&#x2F;&#x2F;   &#123;id:1,city:&#39;北京&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:2,city:&#39;河南&#39;,pid:0,\n&#x2F;&#x2F;     children:[&#123;id:4,city:&#39;洛阳&#39;,pid:2&#125;]\n&#x2F;&#x2F;   &#125;,\n&#x2F;&#x2F;   &#123;id:3,city:&#39;山西&#39;,pid:0,\n&#x2F;&#x2F;      children:[\n&#x2F;&#x2F;        &#123;id:5,city:&#39;晋中&#39;,pid:3,\n&#x2F;&#x2F;          children:[&#123;id:6,city:&#39;榆次&#39;,pid:5&#125;]\n&#x2F;&#x2F;       &#125;\n&#x2F;&#x2F;      ]\n&#x2F;&#x2F;   &#125;,\n&#x2F;&#x2F; ]\n&#x2F;&#x2F; 1. 转hash\n&#x2F;&#x2F; 2. 利用引用数据类型的特点，直接在原数据上操作\nfunction toTree(arr) &#123;\n  arr.forEach(function (it) &#123;\n    delete it.children;\n  &#125;);\n  &#x2F;&#x2F; 定义map&#x2F;\n  let map &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 这里可以重构数据类型，放回字段值\n  arr.forEach(function (item) &#123;\n    map[item.id] &#x3D; item;\n  &#125;);\n\n  &#x2F;&#x2F; 定义返回集合\n  let val &#x3D; [];\n  arr.forEach(function (item) &#123;\n    let parent &#x3D; map[item.pid];\n    if (parent) &#123;\n      &#x2F;&#x2F; 有数据说明不是顶级节点，将数据放到该 children 子节点下\n      (parent.children || (parent.children &#x3D; [])).push(item);\n    &#125; else &#123;\n      &#x2F;&#x2F; 没有数据说明是顶级节点放到val中\n      val.push(item);\n    &#125;\n  &#125;);\n  return val;\n&#125;</code></pre>\n\n<h3 id=\"如何找到数组中出现次数最多的字符串\"><a href=\"#如何找到数组中出现次数最多的字符串\" class=\"headerlink\" title=\"如何找到数组中出现次数最多的字符串\"></a>如何找到数组中出现次数最多的字符串</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const findCountMax &#x3D; (arr) &#x3D;&gt; &#123;\n  let obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 转hash\n  arr.forEach((item) &#x3D;&gt; &#123;\n    if (obj[item]) &#123;\n      obj[item]++;\n    &#125; else &#123;\n      obj[item] &#x3D; 1;\n    &#125;\n  &#125;);\n  &#x2F;&#x2F; 遍历找最大值\n  let result &#x3D; &#123; count: 0, str: &#39;&#39; &#125;;\n  for (let item in obj) &#123;\n    if (obj[item] &gt; result.count) &#123;\n      result.count &#x3D; obj[item];\n      result.str &#x3D; item;\n    &#125;\n  &#125;\n  return result.str;\n&#125;;</code></pre>\n\n<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 没有深度控制的，不好\n&#x2F;&#x2F; 1. 对数组进行遍历，元素是数组的，递归遍历\nconst flattenArr &#x3D; (arr) &#x3D;&gt; &#123;\n  let result &#x3D; [];\n  &#x2F;&#x2F; iife ，直接执行，不用下面再写调用了\n  (function helper(arr) &#123;\n    arr.forEach((item) &#x3D;&gt; &#123;\n      if (Array.isArray(item)) &#123;\n        helper(item);\n      &#125; else &#123;\n        result.push(item);\n      &#125;\n    &#125;);\n  &#125;)(arr);\n  return result;\n&#125;;</code></pre>\n\n<h3 id=\"指定展开-N-层\"><a href=\"#指定展开-N-层\" class=\"headerlink\" title=\"指定展开 N 层\"></a>指定展开 N 层</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const flattenArrN &#x3D; (arr, depth &#x3D; 1) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 这里可以看作是闭包，将result进行缓存\n  let result &#x3D; [];\n  &#x2F;&#x2F; iife 立即执行，传入多个参数\n  (function helper(arr, depth) &#123;\n    arr.forEach((item) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 限制在某一层级\n      if (Array.isArray(item) &amp;&amp; depth &gt; 0) &#123;\n        &#x2F;&#x2F; 这里每次depth都会递减\n        helper(item, depth - 1);\n      &#125; else &#123;\n        result.push(item);\n      &#125;\n    &#125;);\n  &#125;)(arr, depth);\n\n  return result;\n&#125;;</code></pre>\n\n<h3 id=\"实现-getValue-和-setValue-来获取-x2F-设置对应-path-的值\"><a href=\"#实现-getValue-和-setValue-来获取-x2F-设置对应-path-的值\" class=\"headerlink\" title=\"实现 getValue 和 setValue 来获取&#x2F;设置对应 path 的值\"></a>实现 getValue 和 setValue 来获取&#x2F;设置对应 path 的值</h3><p>你可以使用递归的方式来实现获取和设置对象中指定路径的值。以下是一个简单的示例，演示如何实现 <code>getValue</code> 和 <code>setValue</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getValue(obj, path) &#123;\n  const keys &#x3D; path.split(&#39;.&#39;);\n  let value &#x3D; obj;\n  for (const key of keys) &#123;\n    &#x2F;&#x2F; 核心是找到位置，返回\n    if (value &amp;&amp; key in value) &#123;\n      value &#x3D; value[key];\n    &#125; else &#123;\n      return undefined;\n    &#125;\n  &#125;\n  return value;\n&#125;\n\nfunction setValue(obj, path, value) &#123;\n  const keys &#x3D; path.split(&#39;.&#39;);\n  let target &#x3D; obj; &#x2F;&#x2F; 核心是找到位置，更新\n  for (let i &#x3D; 0; i &lt; keys.length - 1; i++) &#123;\n    const key &#x3D; keys[i];\n    if (key in target) &#123;\n      target &#x3D; target[key];\n    &#125; else &#123;\n      target[key] &#x3D; &#123;&#125;;\n      target &#x3D; target[key];\n    &#125;\n  &#125;\n  target[keys[keys.length - 1]] &#x3D; value;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nconst data &#x3D; &#123;\n  user: &#123;\n    info: &#123;\n      name: &#39;John&#39;,\n      age: 30,\n    &#125;,\n  &#125;,\n&#125;;\n\nconst name &#x3D; getValue(data, &#39;user.info.name&#39;);\nconsole.log(name); &#x2F;&#x2F; Output: &#39;John&#39;\n\nsetValue(data, &#39;user.info.age&#39;, 31);\nconsole.log(data.user.info.age); &#x2F;&#x2F; Output: 31</code></pre>\n\n<p>这个示例中的 <code>getValue</code> 函数可以获取指定路径下的值，而 <code>setValue</code> 函数可以设置指定路径下的值。请注意，这只是一个简单的演示，实际应用中可能需要处理更复杂的情况，例如数组、不存在的路径等。</p>\n<h3 id=\"实现按指定长度拆分数组（lodash-chunk-方法）\"><a href=\"#实现按指定长度拆分数组（lodash-chunk-方法）\" class=\"headerlink\" title=\"实现按指定长度拆分数组（lodash.chunk 方法）\"></a>实现按指定长度拆分数组（lodash.chunk 方法）</h3><p>可以使用循环和 <code>Array.prototype.slice</code> 方法来实现按指定长度拆分数组，下面是一个示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function chunk(array, size) &#123;\n  const result &#x3D; [];\n  for (let i &#x3D; 0; i &lt; array.length; i +&#x3D; size) &#123;\n    result.push(array.slice(i, i + size));\n  &#125;\n  return result;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nconst array &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst chunkedArray &#x3D; chunk(array, 3);\nconsole.log(chunkedArray); &#x2F;&#x2F; Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code></pre>\n\n<p>这个 <code>chunk</code> 函数会将输入数组按照指定的大小拆分成多个子数组，并返回一个新的数组，其中每个子数组的长度不超过指定的大小。你可以根据需要将这个函数添加到你的工具库中，类似于 <code>lodash</code> 中的 <code>chunk</code> 方法。</p>\n<h3 id=\"实现方法求两个数组的交集\"><a href=\"#实现方法求两个数组的交集\" class=\"headerlink\" title=\"实现方法求两个数组的交集\"></a>实现方法求两个数组的交集</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function intersection(nums1, nums2) &#123;\n  const set1 &#x3D; new Set(nums1);\n  const set2 &#x3D; new Set(nums2);\n  const result &#x3D; [];\n\n  for (const num of set1) &#123;\n    if (set2.has(num)) &#123;\n      result.push(num);\n    &#125;\n  &#125;\n\n  return result;\n&#125;\n\n&#x2F;&#x2F; 示例使用\nconst nums1 &#x3D; [1, 2, 2, 1];\nconst nums2 &#x3D; [2, 2];\nconst result &#x3D; intersection(nums1, nums2);\nconsole.log(result); &#x2F;&#x2F; 输出 [2]</code></pre>\n\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  a: 1,\n  b: [1, 2, &#123; c: true &#125;],\n  c: &#123; e: 2, f: 3 &#125;,\n  g: null,\n&#125;;\n\nconst result &#x3D; &#123;\n  a: 1,\n  &#39;b[0]&#39;: 1,\n  &#39;b[1]&#39;: 2,\n  &#39;b[2].c&#39;: true,\n  &#39;c.e&#39;: 2,\n  &#39;c.f&#39;: 3,\n  g: null,\n&#125;;\n\n&#x2F;&#x2F; 实现\nconst isArray &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;\nconst isObject &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;;\nfunction ObjFlat(obj) &#123;\n  let result &#x3D; &#123;&#125;;\n  (function helper(obj, prekey &#x2F;*利用闭包进行传递 *&#x2F;) &#123;\n    if (!obj) return;\n\n    Object.entries(obj)?.forEach(([key, value]) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 重点是合成key\n      const keyStr &#x3D; isArray(obj) ? &#96;$&#123;prekey&#125;[$&#123;key&#125;]&#96; : &#96;$&#123;prekey&#125;$&#123;key&#125;&#96;;\n\n      if (isArray(value)) &#123;\n        helper(value, keyStr);\n      &#125; else if (isObject(value)) &#123;\n        helper(value, &#96;$&#123;keyStr&#125;.&#96;);\n      &#125; else &#123;\n        &#x2F;&#x2F; 直接给keyStr赋值\n        result[keyStr] &#x3D; value;\n      &#125;\n    &#125;);\n  &#125;)(obj, &#39;&#39;);\n  console.log(&#39;result&#39;, result);\n  return result;\n&#125;\nconst obj &#x3D; &#123;\n  a: 1,\n  b: [1, 2, &#123; c: true &#125;],\n  c: &#123; e: 2, f: 3 &#125;,\n  g: null,\n&#125;;\n\nObjFlat(obj);</code></pre>\n\n<h3 id=\"对象扁平化\"><a href=\"#对象扁平化\" class=\"headerlink\" title=\"对象扁平化\"></a>对象扁平化</h3><h2 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h2><h3 id=\"解析-URL-中所有的部分\"><a href=\"#解析-URL-中所有的部分\" class=\"headerlink\" title=\"解析 URL 中所有的部分\"></a>解析 URL 中所有的部分</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1.  拆分？后面的内容\n&#x2F;&#x2F; 2.  key\n&#x2F;&#x2F;     1.  无 value 转化成 true\n&#x2F;&#x2F;     2.  纯数字的转化成 数值\n&#x2F;&#x2F;     3.  value 是 数组&#x2F;对象\nfunction parseParam(url) &#123;\n  const paramsStr &#x3D; &#x2F;.+\\?(.+)$&#x2F;.exec(url)[1]; &#x2F;&#x2F; ?之后部分截取\n  const paramsArr &#x3D; paramsStr.split(&#39;&amp;&#39;); &#x2F;&#x2F; 拆分kv对\n  let paramsObj &#x3D; &#123;&#125;;\n\n  paramsArr.forEach((param) &#x3D;&gt; &#123;\n    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;\n      let [key, val] &#x3D; param.split(&#39;&#x3D;&#39;);\n\n      val &#x3D; decodeURIComponent(val); &#x2F;&#x2F; 解码\n\n      val &#x3D; &#x2F;^\\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 字符串数值转化\n\n      if (paramsObj.hasOwnProperty(key)) &#123;\n        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 这个没有直接push, 利用concat特性（数组concat,非数组push）\n      &#125; else &#123;\n        paramsObj[key] &#x3D; val;\n      &#125;\n    &#125; else &#123;\n      &#x2F;&#x2F; 有些没有&#x3D;号\n      paramsObj[param] &#x3D; true;\n    &#125;\n  &#125;);\n  return paramsObj;\n&#125;</code></pre>\n\n<!-- ## 使用 es5 实现 es6 的 let 关键字\n\n<a href=\"https://blog.csdn.net/weixin_44242181/article/details/124340622\" target=\"_blank\" >es5 实现 es6+新特性</a> -->\n\n<h3 id=\"中划线转大写\"><a href=\"#中划线转大写\" class=\"headerlink\" title=\"中划线转大写\"></a>中划线转大写</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var str &#x3D; &#39;get-user-by-id&#39;;\n\nvar f &#x3D; function (s) &#123;\n  return s.replace(&#x2F;-\\w&#x2F;g, function (x) &#123;\n    return x.slice(1).toUpperCase();\n  &#125;);\n&#125;;</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#:~:text=%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0-,%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%AF%E4%BB%A5%E6%8F%92%E5%85%A5%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A,-%E5%8F%98%E9%87%8F%E5%90%8D\" target=\"_blank\" >替换字符串可以插入下面的特殊变量名：</a></p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>代表的值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>$$</code></td>\n<td>插入一个 “$”。</td>\n</tr>\n<tr>\n<td><code>$&amp;</code></td>\n<td>插入匹配的子串。</td>\n</tr>\n<tr>\n<td>$&#96;</td>\n<td>插入当前匹配的子串左边的内容。</td>\n</tr>\n<tr>\n<td><code>$&#39;</code></td>\n<td>插入当前匹配的子串右边的内容。</td>\n</tr>\n<tr>\n<td><code>$n</code></td>\n<td>假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。</td>\n</tr>\n<tr>\n<td><code>$&lt;Name&gt;</code></td>\n<td>这里<em>Name</em> 是一个分组名称。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>$n</code> : 提示：索引是从 1 开始。如果不存在第 n 个分组，那么将会把匹配到到内容替换为字面量。比如不存在第 3 个分组，就会用“$3”替换匹配到的内容。</li>\n<li><code>$&lt;Name&gt;</code>: 如果在正则表达式中并不存在分组（或者没有匹配），这个变量将被处理为空字符串。只有在支持命名分组捕获的浏览器中才能使用。</li>\n</ol>\n<h3 id=\"金额千分\"><a href=\"#金额千分\" class=\"headerlink\" title=\"金额千分\"></a>金额千分</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function parseToMoney(num) &#123;\n  num &#x3D; parseFloat(num).toFixed(3);\n\n  let [integer, decimal] &#x3D; String.prototype.split.call(num, &#39;.&#39;);\n\n  integer &#x3D; integer.replace(&#x2F;\\d(?&#x3D;(\\d&#123;3&#125;)+$)&#x2F;g, &#39;$&amp;,&#39;);\n  &#x2F;&#x2F; 从右到左“三个数值一组” ?&#x3D; 尽可能多的去匹配\n\n  return &#96;$&#123;integer&#125;.$&#123;decimal&#125;&#96;;\n&#125;\n\nconsole.log(parseToMoney(10000000.0));\n\n&#x2F;&#x2F; $&amp; 与regexp相匹配的子串。 &#x2F;&#x2F; https:&#x2F;&#x2F;q.cnblogs.com&#x2F;q&#x2F;63769&#x2F;</code></pre>\n\n<p><a href=\"https://regexper.com/#%2F%5Cd%28%3F%3D%28%5Cd%7B3%7D%29%2B%24%29%2Fg\" target=\"_blank\" >&#x2F;\\d(?&#x3D;(\\d{3})+$)&#x2F;g</a></p>\n<h3 id=\"Intl-NumberFormat\"><a href=\"#Intl-NumberFormat\" class=\"headerlink\" title=\"Intl.NumberFormat\"></a>Intl.NumberFormat</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; example1\nconst options &#x3D; &#123;\n  style: &#39;currency&#39;,\n  currency: &#39;CNY&#39;,\n&#125;;\nconsole.log((999999.1212).toLocaleString(&#39;zh-CN&#39;, options)); &#x2F;&#x2F; ¥999,999.12\n\n&#x2F;&#x2F; example2\nvar val &#x3D; Intl.NumberFormat(&#39;zh-CN&#39;, &#123; maximumSignificantDigits: 18 &#125;).format(999999.1212);\n\nconsole.log(&#39;val&#39;, val); &#x2F;&#x2F; val 999,999.1212</code></pre>\n\n<h2 id=\"原理实现\"><a href=\"#原理实现\" class=\"headerlink\" title=\"原理实现\"></a>原理实现</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><p><a href=\"/#/post/2022-06-16interview#:~:text=new%20%E5%92%8C%20Object.create%20%E9%83%BD%E6%98%AF%E5%88%9B%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E6%80%9D%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; @link: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;new\n&#x2F;&#x2F; 1. 创建一个空的简单 JavaScript 对象（即 &#123;&#125;）；\n&#x2F;&#x2F; 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；\n&#x2F;&#x2F; 3. 将步骤 1 新创建的对象, 作为 this 的上下文；\n&#x2F;&#x2F; 4. 如果该函数没有返回对象，则返回 this。\nfunction myNew() &#123;\n  &#x2F;&#x2F; 1. 创建一个空的简单 JavaScript 对象（即 &#123;&#125;）；\n  let obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；\n  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数\n  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型\n  &#x2F;&#x2F; 3. 将步骤 1 新创建的对象, 作为 this 的上下文；\n  const result &#x3D; func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数\n  &#x2F;&#x2F; 4. 如果该函数没有返回对象，则返回 this。\n  return result intanceof Object ? result :  obj;\n&#125;</code></pre>\n\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h3><p><strong>Object.create() 方法不会像 new 关键字一样执行构造函数，而是直接创建一个新对象并指定其原型</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.myCreate &#x3D; function (proto, propertyObj &#x3D; undefined) &#123;\n  &#x2F;&#x2F; propertyObj 不可以时null，因为 Object.Create规定第二参数不可以时undefined和 null\n  if (propertyObj &#x3D;&#x3D;&#x3D; null) throw &quot;TypeError&quot;;\n  &#x2F;&#x2F; 23模式-原型模式，使用寄生继承，用现有对象作为新创建对象的原型\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; proto;\n  let obj &#x3D; new F();\n  &#x2F;&#x2F; 对象的自有可枚举属性，将为新创建的对象添加指定的属性值和对应的属性描述符\n  if (propertyObj !&#x3D;&#x3D; undefined) &#123;\n    Object.defineProperties(obj, propertyObj);\n  &#125;\n  &#x2F;&#x2F; null创建无原型的对象\n  if (proto &#x3D;&#x3D;&#x3D; null) &#123;\n    obj.__proto__ &#x3D; null;\n  &#125;\n  &#x2F;&#x2F; 一个新对象，带着指定的原型对象及其属性\n  return obj;\n&#125;;\n\n\n\n&#x2F;&#x2F; 示例\n&#x2F;&#x2F; 第二个参数为null时，抛出TypeError\n&#x2F;&#x2F; const throwErr &#x3D; Object.myCreate(&#123;a: &#39;aa&#39;&#125;, null)  &#x2F;&#x2F; Uncaught TypeError\n&#x2F;&#x2F; 构建一个以\nconst obj1 &#x3D; Object.myCreate(&#123;a: &#39;aa&#39;&#125;)\nconsole.log(obj1)  &#x2F;&#x2F; &#123;&#125;, obj1的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;\nconst obj2 &#x3D; Object.myCreate(&#123;a: &#39;aa&#39;&#125;, &#123;\n  b: &#123;\n    value: &#39;bb&#39;,\n    enumerable: true\n  &#125;\n&#125;)\nconsole.log(obj2)  &#x2F;&#x2F; &#123;b: &#39;bb&#39;&#125;, obj2的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;\n\n作者：李永宁\n链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904174983872519\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><p>instanceof 运算符用于检测<code>构造函数的 prototype 属性</code>是否出现在某个<code>实例对象的原型链</code>上</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function instance_of(L, R) &#123;\n  var O &#x3D; R.prototype; &#x2F;&#x2F; 取R的显示原型\n  L &#x3D; L.__proto__; &#x2F;&#x2F; 取L的隐式原型\n\n  while (true) &#123;\n    &#x2F;&#x2F; 死循环，结束条件：要么找到，要么没找到\n    if (L &#x3D;&#x3D;&#x3D; null) return false;\n\n    &#x2F;&#x2F; 这里重点：当O严格等于L时，返回true\n    if (O &#x3D;&#x3D;&#x3D; L) return true;\n\n    L &#x3D; L.__proto__;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>本质是一个 hack,利用<code>&lt;script&gt;</code>标签不受同源侧露限制的特性进行跨域操作</p>\n<p><a href=\"https://blog.csdn.net/weixin_42371354/article/details/104651961\" target=\"_blank\" >参考链接</a><br><a href=\"https://blog.csdn.net/qq_38800316/article/details/120440865\" target=\"_blank\" >jsonp 函数封装</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 生成个函数名\n&#x2F;&#x2F; 2. 整理参数，生成请求url\n&#x2F;&#x2F; 3. 动态创建script标签，并挂载\n&#x2F;&#x2F; 4. 加载完成后移除script标签\nfunction jsonP(&#123; url, params, success &#125;) &#123;\n  &#x2F;&#x2F; 在参数里制定callback的名字\n  params &#x3D; params || &#123;&#125;;\n  &#x2F;&#x2F; 预留callback\n  const funcName &#x3D; &#39;func&#39; + Math.random().toString().replace(&#39;.&#39;, &#39;&#39;);\n  &#x2F;&#x2F; 这样依赖，服务器端一个req.query.callback就可以获取到动态的函数名\n  params.callback &#x3D; funcName;\n  window[funcName] &#x3D; success;\n\n  &#x2F;&#x2F; 拼接参数字符串\n  const paramKeys &#x3D; Object.keys(params);\n  const paramString &#x3D; paramKeys.map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;).join(&#39;&amp;&#39;);\n\n  &#x2F;&#x2F; 插入dom元素\n  const script &#x3D; document.createElement(&#39;script&#39;);\n\n  script.setAttribute(&#39;src&#39;, &#96;$&#123;url&#125;?$&#123;paramString&#125;&#96;);\n\n  document.body.appendChild(script);\n  &#x2F;&#x2F; 监听script标签的onload事件，当script标签执行后将其删除，避免代码结构的冗余\n  script.onload &#x3D; function () &#123;\n    &#x2F;&#x2F; 从body的删除掉添加的script标签\n    document.body.removeChild(script);\n    delete window[funcName];\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 使用\n\njsonP(&#123;\n  url: &#39;https:&#x2F;&#x2F;example.com&#x2F;ajax&#x2F;jsonp&#x2F;suggestion&#39;,\n  params: &#123;\n    key: &#39;test&#39;,\n  &#125;,\n  success(result) &#123;\n    console.log(result.data);\n  &#125;,\n&#125;);</code></pre>\n\n<h3 id=\"实现-event-bus\"><a href=\"#实现-event-bus\" class=\"headerlink\" title=\"实现 event bus\"></a>实现 event bus</h3><p>作用：</p>\n<p><strong>1. 简化了应用程序内各个组件之间进行通信的复杂度，尤其是碎片之间进行通信的问题，可以避免由于使用广播通信而带来的诸多不便</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 监听收集（on&#x2F;once）\n&#x2F;&#x2F; 2. 触发监听(emit)\n&#x2F;&#x2F; 3. 解除监听(off)\n&#x2F;&#x2F; 4. 清空监听(clear)\nclass EventBus &#123;\n  constructor() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n  &#x2F;&#x2F; 监听，给对象添加方法\n  on(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    &#x2F;&#x2F; if (!events[name]) &#123;\n    &#x2F;&#x2F;   events[name] &#x3D; [];\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; events[name].push(callback);\n\n    (events[name] || events[name] &#x3D; []).push(callback)\n  &#125;\n  &#x2F;&#x2F; 取出来执行\n  emit(name, ...args) &#123;\n    const handlers &#x3D; this.events[name];\n    handlers?.forEach((fn) &#x3D;&gt; &#123;\n      fn.apply(this, args);\n    &#125;);\n  &#125;\n  &#x2F;&#x2F; 解除\n  off(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) return;\n    events[name] &#x3D; events[name].filter((fn) &#x3D;&gt; fn !&#x3D;&#x3D; callback); &#x2F;&#x2F; 引用，指向对象，直接改kv键值对\n  &#125;\n  &#x2F;&#x2F;  用完立马、解除\n  once(name, callback) &#123;\n    const handler &#x3D; function () &#123;\n      callback.apply(this, arguments); &#x2F;&#x2F; 普通函数参数\n      this.off(name, handler);\n    &#125;;\n    this.on(name, handler);\n  &#125;\n  &#x2F;&#x2F; 事件清空\n  clear() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"event-bus-为什么可以进行通信\"><a href=\"#event-bus-为什么可以进行通信\" class=\"headerlink\" title=\"event bus 为什么可以进行通信\"></a>event bus 为什么可以进行通信</h3><p>Event Bus 是一种用于在应用程序内进行组件间通信的机制。它是一个中央事件管理器，负责接收、处理和分发事件，从而实现不同组件之间的通信。Event Bus 之所以可以进行通信，主要基于以下几个原因：</p>\n<ol>\n<li><p>中央事件管理器：Event Bus 充当了一个中央事件管理器的角色，它集中管理所有组件间的事件，使得组件之间不需要直接引用或依赖彼此，从而实现了解耦。</p>\n</li>\n<li><p>发布&#x2F;订阅模式：Event Bus 使用了发布&#x2F;订阅（Publish&#x2F;Subscribe）模式，组件可以通过订阅感兴趣的事件来接收通知，而不需要知道事件的来源。当某个组件发布一个事件时，所有订阅了该事件的组件都会接收到通知。</p>\n</li>\n<li><p>全局性质：Event Bus 是一个全局对象，所有组件都可以通过它来发布和订阅事件。这使得不同组件之间的通信更加便捷，不需要显式地传递事件对象或回调函数。</p>\n</li>\n<li><p>单一事件源：Event Bus 通常只有一个实例，确保整个应用程序中只有一个事件源。这样可以避免多个事件源之间的混乱和冲突，使得事件的管理和调试更加方便。</p>\n</li>\n</ol>\n<p>通过 Event Bus，组件之间可以进行松耦合的通信，一个组件可以通过发布事件来通知其他组件，其他组件则通过订阅事件来接收通知，从而实现了通信的目的。它在 Vue.js 等前端框架中被广泛使用，用于解决组件通信的问题，使得应用程序的代码更加清晰和可维护。</p>\n<h3 id=\"实现发布订阅\"><a href=\"#实现发布订阅\" class=\"headerlink\" title=\"实现发布订阅\"></a>实现发布订阅</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Observer &#123;\n  caches &#x3D; &#123;&#125;; &#x2F;&#x2F; 事件中心\n\n  &#x2F;&#x2F; eventName事件名-独一无二, fn订阅后执行的自定义行为\n  on(eventName, fn) &#123;\n    this.caches[eventName] &#x3D; this.caches[eventName] || [];\n    this.caches[eventName].push(fn);\n  &#125;\n\n  &#x2F;&#x2F; 发布 &#x3D;&gt; 将订阅的事件进行统一执行\n  emit(eventName, data) &#123;\n    if (this.caches[eventName]) &#123;\n      this.caches[eventName].forEach((fn) &#x3D;&gt; fn(data));\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 取消订阅 &#x3D;&gt; 若fn不传, 直接取消该事件所有订阅信息\n  off(eventName, fn) &#123;\n    if (this.caches[eventName]) &#123;\n      const newCaches &#x3D; fn ? this.caches[eventName].filter((e) &#x3D;&gt; e !&#x3D;&#x3D; fn) : [];\n      this.caches[eventName] &#x3D; newCaches;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"Object-defineProperties-实现原理\"><a href=\"#Object-defineProperties-实现原理\" class=\"headerlink\" title=\"Object.defineProperties 实现原理\"></a>Object.defineProperties 实现原理</h3><p><code>Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象</code><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties#polyfill\" target=\"_blank\" >见</a></p>\n<p><a href=\"/#/post/2023-03-09defineProperty\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2023-03-09defineProperty</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function defineProperties(obj, properties) &#123;\n  function convertToDescriptor(desc) &#123;\n    &#x2F;&#x2F; 是否有这个属性\n    function hasProperty(obj, prop) &#123;\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    &#125;\n    &#x2F;&#x2F; 是否可以被调用\n    function isCallable(v) &#123;\n      &#x2F;&#x2F; NB: modify as necessary if other values than functions are callable.\n      return typeof v &#x3D;&#x3D;&#x3D; &#39;function&#39;;\n    &#125;\n    &#x2F;&#x2F; 基本数据类型\n    if (typeof desc !&#x3D;&#x3D; &#39;object&#39; || desc &#x3D;&#x3D;&#x3D; null) throw new TypeError(&#39;bad desc&#39;);\n\n    var d &#x3D; &#123;&#125;;\n\n    &#x2F;*数据描述：可枚举、可配置、值、可改写*&#x2F;\n    if (hasProperty(desc, &#39;enumerable&#39;)) d.enumerable &#x3D; !!desc.enumerable;\n    if (hasProperty(desc, &#39;configurable&#39;)) d.configurable &#x3D; !!desc.configurable;\n    if (hasProperty(desc, &#39;value&#39;)) d.value &#x3D; desc.value;\n    if (hasProperty(desc, &#39;writable&#39;)) d.writable &#x3D; !!desc.writable;\n\n    &#x2F;*存储描述 *&#x2F;\n    function storeDesc(desc, key) &#123;\n      var g &#x3D; desc[key];\n      if (!isCallable(g) &amp;&amp; typeof g !&#x3D;&#x3D; &#39;undefined&#39;) throw new TypeError(&#96;bad $&#123;key&#125;&#96;);\n      d[key] &#x3D; g;\n    &#125;\n    &#x2F;&#x2F; 不再进一步封装\n    if (hasProperty(desc, &#39;get&#39;)) storeDesc(desc, &#39;get&#39;);\n    if (hasProperty(desc, &#39;set&#39;)) storeDesc(desc, &#39;set&#39;);\n\n    &#x2F;&#x2F; 描述符冲突\n    &#x2F;&#x2F; @link https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;defineProperty#:~:text&#x3D;%E4%B8%BA%20undefined%E3%80%82-,%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%AF%E6%8B%A5%E6%9C%89%E7%9A%84%E9%94%AE%E5%80%BC,-configurable\n    &#x2F;&#x2F; 1. 如果一个描述符不具有 value、writable、get 和 set 中的任意一个键，那么它将被认为是一个数据描述符。\n    &#x2F;&#x2F; 2. 如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常。\n    if ((&#39;get&#39; in d || &#39;set&#39; in d) &amp;&amp; (&#39;value&#39; in d || &#39;writable&#39; in d)) throw new TypeError(&#39;identity-confused descriptor&#39;);\n\n    return d;\n  &#125;\n  &#x2F;&#x2F; 被扩展的必须是对象\n  &#x2F;&#x2F; 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n  if (typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) throw new TypeError(&#39;bad obj&#39;);\n  &#x2F;&#x2F; 转化成对象, Object是一个构造函数\n  properties &#x3D; Object(properties);\n  &#x2F;&#x2F; 遍历key\n  var keys &#x3D; Object.keys(properties);\n  var descs &#x3D; [];\n\n  for (var i &#x3D; 0; i &lt; keys.length; i++) &#123;\n    Object.defineProperty(obj, keys[i], convertToDescriptor(properties[keys[i]]));\n  &#125;\n\n  &#x2F;&#x2F; 返回原对象\n  return obj;\n&#125;</code></pre>\n\n<h2 id=\"实现-JS-的继承\"><a href=\"#实现-JS-的继承\" class=\"headerlink\" title=\"实现 JS 的继承\"></a>实现 JS 的继承</h2><p>在 JavaScript 中，可以通过不同的方式来实现继承。以下是几种常见的继承方式：</p>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><p>这是 JavaScript 中最基本的继承方式，通过将子类的原型指向父类的实例来实现继承。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Parent() &#123;\n  this.name &#x3D; &#39;Parent&#39;;\n&#125;\n\nParent.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, I&#39;m $&#123;this.name&#125;&#96;);\n&#125;;\n\nfunction Child() &#123;&#125;\n\nChild.prototype &#x3D; new Parent();\nChild.prototype.constructor &#x3D; Child;\n\nconst child &#x3D; new Child();\nchild.sayHello(); &#x2F;&#x2F; 输出：Hello, I&#39;m Parent</code></pre>\n\n<h3 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h3><p>在子类构造函数内部调用父类构造函数来实现属性的继承。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Parent() &#123;\n  this.name &#x3D; &#39;Parent&#39;;\n&#125;\n\nfunction Child() &#123;\n  Parent.call(this); &#x2F;&#x2F; 在子类构造函数内调用父类构造函数\n&#125;\n\nconst child &#x3D; new Child();\nconsole.log(child.name); &#x2F;&#x2F; 输出：Parent</code></pre>\n\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>同时使用原型链继承和构造函数继承，克服了原型链继承和构造函数继承各自的缺点。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Parent() &#123;\n  this.name &#x3D; &#39;Parent&#39;;\n&#125;\n\nParent.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, I&#39;m $&#123;this.name&#125;&#96;);\n&#125;;\n\nfunction Child() &#123;\n  Parent.call(this); &#x2F;&#x2F; 在子类构造函数内调用父类构造函数，实现属性的继承\n&#125;\n\nChild.prototype &#x3D; new Parent(); &#x2F;&#x2F; 使用原型链继承，继承父类的方法\nChild.prototype.constructor &#x3D; Child;\n\nconst child &#x3D; new Child();\nchild.sayHello(); &#x2F;&#x2F; 输出：Hello, I&#39;m Parent</code></pre>\n\n<h3 id=\"ES6-类继承\"><a href=\"#ES6-类继承\" class=\"headerlink\" title=\"ES6 类继承\"></a>ES6 类继承</h3><p>ES6 引入了 <code>class</code> 和 <code>extends</code> 关键字，使继承更加简洁。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Parent &#123;\n  constructor() &#123;\n    this.name &#x3D; &#39;Parent&#39;;\n  &#125;\n\n  sayHello() &#123;\n    console.log(&#96;Hello, I&#39;m $&#123;this.name&#125;&#96;);\n  &#125;\n&#125;\n\nclass Child extends Parent &#123;\n  constructor() &#123;\n    super(); &#x2F;&#x2F; 调用父类构造函数\n  &#125;\n&#125;\n\nconst child &#x3D; new Child();\nchild.sayHello(); &#x2F;&#x2F; 输出：Hello, I&#39;m Parent</code></pre>\n\n<p>这些是常见的继承方式，每种方式都有自己的优缺点。根据实际场景和需求，可以选择合适的继承方式。</p>\n<h3 id=\"Child-prototype-x3D-new-Parent-Child-prototype-constructor-x3D-Child-什么意思\"><a href=\"#Child-prototype-x3D-new-Parent-Child-prototype-constructor-x3D-Child-什么意思\" class=\"headerlink\" title=\"Child.prototype &#x3D; new Parent(); Child.prototype.constructor &#x3D; Child; 什么意思\"></a>Child.prototype &#x3D; new Parent(); Child.prototype.constructor &#x3D; Child; 什么意思</h3><p>这两行代码出现在”原型链继承”的实现中：</p>\n<ol>\n<li><p><code>Child.prototype = new Parent();</code>：<br>这一行代码的目的是将 <code>Child</code> 的原型对象指向一个 <code>Parent</code> 类的实例。这样做的效果是让 <code>Child</code> 的原型链上拥有了 <code>Parent</code> 类的属性和方法。当我们在 <code>Child</code> 的实例上访问一个属性或方法时，如果 <code>Child</code> 的原型链上找不到这个属性或方法，就会继续向上查找，最终会在 <code>Parent</code> 的原型对象上找到。</p>\n</li>\n<li><p><code>Child.prototype.constructor = Child;</code>：<br>在上一行代码执行后，<code>Child</code> 的原型对象指向了一个 <code>Parent</code> 的实例，这样 <code>Child.prototype.constructor</code> 实际上指向的是 <code>Parent</code> 构造函数。为了纠正这个问题，我们需要将 <code>Child.prototype.constructor</code> 手动指回 <code>Child</code> 构造函数，以确保后续通过 <code>new Child()</code> 创建的实例的 <code>constructor</code> 属性指向正确的构造函数。</p>\n</li>\n</ol>\n<p>这两行代码的组合可以让 <code>Child</code> 类继承 <code>Parent</code> 类的属性和方法，并且在通过 <code>new Child()</code> 创建的实例上，<code>constructor</code> 属性指向 <code>Child</code> 构造函数。这是原型链继承的基本实现。然而，这种方式存在一些问题，比如可能会引起属性共享和无法向父类构造函数传递参数等。因此，需要根据实际情况综合考虑其他继承方式。</p>\n<h3 id=\"这几种继承的优缺点，及使用场景\"><a href=\"#这几种继承的优缺点，及使用场景\" class=\"headerlink\" title=\"这几种继承的优缺点，及使用场景\"></a>这几种继承的优缺点，及使用场景</h3><p>不同的继承方式各有优缺点，适用于不同的场景。以下是常见的继承方式以及它们的优缺点和适用场景：</p>\n<ol>\n<li><p><strong>原型链继承</strong>：</p>\n<ul>\n<li>优点：<ul>\n<li>简单易实现。</li>\n<li>可以继承父类原型上的方法和属性。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>无法实现多继承。</li>\n<li>所有子类实例共享父类原型，可能会引起属性共享问题。</li>\n</ul>\n</li>\n<li>适用场景：<ul>\n<li>简单的继承需求，不需要考虑多继承和属性共享问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>构造函数继承</strong>：</p>\n<ul>\n<li>优点：<ul>\n<li>可以继承父类构造函数内的属性。</li>\n<li>避免了属性共享问题。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>无法继承父类原型上的方法。</li>\n<li>每个子类实例都会创建一个新的父类属性的副本。</li>\n</ul>\n</li>\n<li>适用场景：<ul>\n<li>需要继承父类构造函数内部的属性，避免属性共享问题。</li>\n<li>不需要继承父类原型上的方法。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>组合继承</strong>：</p>\n<ul>\n<li>优点：<ul>\n<li>同时继承了父类构造函数内的属性和父类原型上的方法。</li>\n<li>避免了属性共享问题。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>在创建子类实例时，会调用两次父类构造函数。</li>\n</ul>\n</li>\n<li>适用场景：<ul>\n<li>需要继承父类构造函数内部的属性和父类原型上的方法。</li>\n<li>考虑避免属性共享问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>ES6 类继承</strong>：</p>\n<ul>\n<li>优点：<ul>\n<li>语法更加清晰，易读性好。</li>\n<li>可以继承父类构造函数内的属性和父类原型上的方法。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>不支持多继承。</li>\n</ul>\n</li>\n<li>适用场景：<ul>\n<li>ES6 语法环境下的继承需求。</li>\n<li>不需要多继承。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>综合考虑以上继承方式的优缺点和适用场景，可以根据实际情况选择合适的继承方式。在一些复杂的情况下，可能需要使用混合继承、原型链继承等方式来满足不同的需求。</p>\n<h2 id=\"实现-ES6-的-extends-运算符功能\"><a href=\"#实现-ES6-的-extends-运算符功能\" class=\"headerlink\" title=\"实现 ES6 的 extends 运算符功能\"></a>实现 ES6 的 extends 运算符功能</h2><p>ES6 中的 <code>extends</code> 关键字用于实现类的继承。我们可以通过创建一个子类，然后使用 <code>extends</code> 关键字来继承父类的属性和方法。下面是一个简单的示例来模拟实现 <code>extends</code> 运算符的功能：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 父类\nclass Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n\n  makeSound() &#123;\n    console.log(&#39;Animal makes a sound&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 子类\nclass Dog &#123;\n  constructor(name, breed) &#123;\n    this.breed &#x3D; breed;\n    this.name &#x3D; name;\n  &#125;\n\n  &#x2F;&#x2F; 子类特有的方法\n  bark() &#123;\n    console.log(&#39;Dog barks&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 实现继承的函数\nfunction extend(subClass, superClass) &#123;\n  subClass.prototype &#x3D; Object.create(superClass.prototype);\n  subClass.prototype.constructor &#x3D; subClass;\n&#125;\n\n&#x2F;&#x2F; 继承 Animal 类的属性和方法到 Dog 类\nextend(Dog, Animal);\n\n&#x2F;&#x2F; 使用继承后的 Dog 类\nconst myDog &#x3D; new Dog(&#39;Buddy&#39;, &#39;Golden Retriever&#39;);\nconsole.log(myDog.name); &#x2F;&#x2F; 输出: Buddy\nmyDog.makeSound(); &#x2F;&#x2F; 输出: Animal makes a sound\nmyDog.bark(); &#x2F;&#x2F; 输出: Dog barks</code></pre>\n\n<p>在这个示例中，我们定义了一个 <code>Animal</code> 父类和一个 <code>Dog</code> 子类。通过实现 <code>extend</code> 函数，我们将父类的原型属性和方法继承到子类中，使得子类可以访问父类的属性和方法。然后我们创建了一个 <code>Dog</code> 类的实例，并测试了继承后的功能。</p>\n<p>需要注意的是，实际的 JavaScript 中已经有内置的 <code>class</code> 关键字和 <code>extends</code> 关键字来实现继承，上述示例只是为了模拟实现这个过程。在实际开发中，我们通常会直接使用 ES6 的 <code>class</code> 和 <code>extends</code> 来定义和继承类。</p>\n<h2 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h2><h3 id=\"柯里化是什么\"><a href=\"#柯里化是什么\" class=\"headerlink\" title=\"柯里化是什么\"></a>柯里化是什么</h3><p><a href=\"https://article.itxueyuan.com/46m5K2\" target=\"_blank\" >见</a><br>在计算机科学中，柯里化（Currying）<code>是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</code>。这个技术以逻辑学家 Haskell Curry 命名的。</p>\n<ol>\n<li>柯里化突出一种重要思想：<code>降低适用范围</code>，<code>提高适用性</code></li>\n<li>柯里化的三个作用和特点：<code>参数复用</code>、<code>提前返回</code>、<code>延迟执行</code></li>\n<li>柯里化是闭包的一个典型应用:<ol>\n<li><code>利用闭包形成了一个保存在内存中的作用域，把接收到的部分参数保存在这个作用域中，等待后续使用</code>。</li>\n<li>并且返回一个新函数接收剩余参数</li>\n</ol>\n</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/6844903814139478030\" target=\"_blank\" >函数柯里化和偏函数应用</a></p>\n<ul>\n<li><p>柯里化和偏函数都是用于将多个参数函数，转化为接受更少参数函数的方法。传入部分参数后，处于中间状态的函数可以作为固定值进行复用。但是其中不同之处在于：</p>\n</li>\n<li><p><code>柯里化</code>是将函数转化为多个嵌套的一元函数，也就是每个函数只接受一个参数。</p>\n</li>\n<li><p><code>偏函数</code>可以接受不只一个参数，它被固定了部分参数作为预设，并可以接受剩余的参数</p>\n</li>\n</ul>\n<p>作者：LanceT<br>链接：<a href=\"https://juejin.cn/post/6844903814139478030\">https://juejin.cn/post/6844903814139478030</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"实现柯里化\"><a href=\"#实现柯里化\" class=\"headerlink\" title=\"实现柯里化\"></a>实现柯里化</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function sum(a, b, c, d, e) &#123;\n  return a + b + c + d + e;\n&#125;\n\nlet resFunc &#x3D; curry(sum);\nconsole.log(resFunc(1, 3, 4)(1)(23));\n&#x2F;&#x2F; 方式2，利用bind的数据积累特性\nfunction curry(fn, ...args) &#123;\n  if (args.length &gt;&#x3D; fn.length) &#123;\n    return fn(...args);\n  &#125; else &#123;\n    &#x2F;&#x2F; bind绑定，不执行，\n    &#x2F;&#x2F; bind返回一个函数\n    &#x2F;&#x2F; bind会将之前的参数和之后的参数进行合并\n    &#x2F;&#x2F; 这里涉及bind和apply的实现原理\n    return curry.bind(null, fn, ...args);\n  &#125;\n  &#x2F;&#x2F; return fn.length &#x3D;&#x3D; args.length ? fn(...args) : curry.bind(null, fn, ...args);\n&#125;</code></pre>\n\n<h3 id=\"洋葱模型\"><a href=\"#洋葱模型\" class=\"headerlink\" title=\"洋葱模型\"></a>洋葱模型</h3><p><a href=\"https://github.com/841660202/redux/blob/2edd0363271af46e327e118f3d92e78e258bf0cd/src/compose.ts#L46\" target=\"_blank\" >redux compose 源码</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 1. 无函数\n&#x2F;&#x2F; 2. 1个函数\n&#x2F;&#x2F; 3. 多个函数\nexport default function compose(...funcs: Function[]) &#123;\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line\n    return &lt;T&gt;(arg: T) &#x3D;&gt; arg;\n  &#125;\n\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0];\n  &#125;\n  &#x2F;&#x2F; prettier-ignore\n  return funcs.reduce((a, b) &#x3D;&gt; (...args: any) &#x3D;&gt; a(b(...args)));\n&#125;</code></pre>\n\n<h2 id=\"数据代理-x2F-劫持\"><a href=\"#数据代理-x2F-劫持\" class=\"headerlink\" title=\"数据代理&#x2F;劫持\"></a>数据代理&#x2F;劫持</h2><p><a href=\"https://www.freesion.com/article/47611264830/\" target=\"_blank\" >数据劫持|数据代理</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" >MDN</a></p>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><p><a href=\"https://blog.csdn.net/xgangzai/article/details/128489924\" target=\"_blank\" >Proxy &amp; Reflect </a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Proxy\n&#x2F;&#x2F;  数据对象\nlet obj &#x3D; &#123;\n  name: &#39;Eason&#39;,\n  age: 30,\n&#125;;\n&#x2F;&#x2F; 处理\nlet handler &#x3D; &#123;\n  get(target, key, receiver) &#123;\n    console.log(&#39;get&#39;, key);\n    return Reflect.get(target, key, receiver);\n  &#125;,\n  set(target, key, value, receiver) &#123;\n    console.log(&#39;set&#39;, key, value);\n    return Reflect.set(target, key, value, receiver);\n  &#125;,\n&#125;;\n\nlet proxy &#x3D; new Proxy(&#123; ...obj &#125;, handler);\n\nproxy.name &#x3D; &#39;Zoe&#39;; &#x2F;&#x2F; set name Zoe\nproxy.age &#x3D; 18; &#x2F;&#x2F; set age 18\n\n&#x2F;&#x2F; defineProperty\n\nlet arr &#x3D; [1, 2, 3];\nlet obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, &#39;arr&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get arr&#39;);\n    return arr;\n  &#125;,\n  set(newVal) &#123;\n    console.log(&#39;set&#39;, newVal);\n    arr &#x3D; newVal;\n  &#125;,\n&#125;);\nobj.arr.push(4); &#x2F;&#x2F; 只会打印 get arr, 不会打印 set\nobj.arr &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; 这个能正常 set</code></pre>\n\n<h3 id=\"defineProperty\"><a href=\"#defineProperty\" class=\"headerlink\" title=\"defineProperty\"></a>defineProperty</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; defineProperty\n\nlet arr &#x3D; [1, 2, 3];\nlet obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, &#39;arr&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get arr&#39;);\n    return arr;\n  &#125;,\n  set(newVal) &#123;\n    console.log(&#39;set&#39;, newVal);\n    arr &#x3D; newVal;\n  &#125;,\n&#125;);\nobj.arr.push(4); &#x2F;&#x2F; 只会打印 get arr, 不会打印 set\nobj.arr &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; 这个能正常 set</code></pre>\n\n<h3 id=\"a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true\"><a href=\"#a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true\" class=\"headerlink\" title=\"(a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true\"></a>(a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true</h3><p><a href=\"https://blog.csdn.net/RedaTao/article/details/107170267\" target=\"_blank\" >a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3</a></p>\n<p>什么样的 a 可以满足 (a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true 呢？(注意是 3 个 &#x3D;，也就是严格相等)???</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let i &#x3D; 1;\nObject.defineProperty(window, &#39;a&#39;, &#123;\n  get: function () &#123;\n    return i++;\n  &#125;,\n&#125;);\n\nconsole.log(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3);</code></pre>\n\n<h3 id=\"实现双向绑定\"><a href=\"#实现双向绑定\" class=\"headerlink\" title=\"实现双向绑定\"></a>实现双向绑定</h3><p>双向绑定是前端框架（如 Vue、Angular 等）提供的一种功能，用于在视图层和数据层之间建立自动的双向更新机制。在原生 JavaScript 中，要实现双向绑定需要一些额外的工作。下面是一个简单的示例，使用 JavaScript 实现一个简单的双向绑定：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;input id&#x3D;&quot;inputField&quot; type&#x3D;&quot;text&quot; &#x2F;&gt;\n&lt;div id&#x3D;&quot;outputField&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n  &#x2F;&#x2F; 数据模型\n  const data &#x3D; &#123; value: &#39;&#39; &#125;;\n\n  &#x2F;&#x2F; 视图更新函数\n  function updateView() &#123;\n    document.getElementById(&#39;outputField&#39;).textContent &#x3D; data.value;\n  &#125;\n\n  &#x2F;&#x2F; 输入框监听输入事件，更新数据和视图\n  document.getElementById(&#39;inputField&#39;).addEventListener(&#39;input&#39;, function (event) &#123;\n    data.value &#x3D; event.target.value;\n    updateView();\n  &#125;);\n\n  &#x2F;&#x2F; 初始化视图\n  updateView();\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>这个简单的示例实现了一个文本输入框和一个输出区域，当在输入框中输入文本时，会自动更新输出区域中的文本，实现了一种简单的双向绑定效果。不过需要注意的是，这个示例只是一个简单的演示，真正的双向绑定涉及更复杂的场景，需要考虑性能、数据同步等问题，而前端框架中的双向绑定机制会处理这些问题。</p>\n<h3 id=\"实现-Vue-的-reactive-功能\"><a href=\"#实现-Vue-的-reactive-功能\" class=\"headerlink\" title=\"实现 Vue 的 reactive 功能\"></a>实现 Vue 的 reactive 功能</h3><p>Vue 的响应式功能是其核心特性之一，通过 <code>Vue.observable</code> 可以将一个对象变为响应式对象。下面是一个简化版本的 Vue 响应式实现示例，展示了如何实现一个简单的 reactive 功能：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function reactive(obj) &#123;\n  const handlers &#x3D; &#123;\n    get(target, key, receiver) &#123;\n      const result &#x3D; Reflect.get(target, key, receiver);\n      console.log(&#96;Get: $&#123;key&#125; &#x3D; $&#123;result&#125;&#96;);\n      return result;\n    &#125;,\n    set(target, key, value, receiver) &#123;\n      const oldValue &#x3D; target[key];\n      const result &#x3D; Reflect.set(target, key, value, receiver);\n      console.log(&#96;Set: $&#123;key&#125; from $&#123;oldValue&#125; to $&#123;value&#125;&#96;);\n      return result;\n    &#125;,\n  &#125;;\n\n  return new Proxy(obj, handlers);\n&#125;\n\n&#x2F;&#x2F; 使用示例\nconst state &#x3D; reactive(&#123;\n  count: 0,\n&#125;);\n\nconsole.log(state.count); &#x2F;&#x2F; 通过响应式访问属性，会触发 get\nstate.count &#x3D; 1; &#x2F;&#x2F; 通过响应式设置属性，会触发 set</code></pre>\n\n<p>这个简单的示例中，我们通过 <code>Proxy</code> 对象创建了一个代理，拦截了对对象属性的访问和修改操作，从而实现了简单的响应式功能。当访问和修改属性时，会触发相应的 <code>get</code> 和 <code>set</code> 操作，从而可以进行一些自定义的处理。</p>\n<p>需要注意的是，Vue 的响应式系统远比这个示例复杂和强大，涉及依赖追踪、派发更新等更多的功能。这个示例只是一个简化版，用来演示基本的响应式思路。</p>\n<h3 id=\"实现-const-运算符\"><a href=\"#实现-const-运算符\" class=\"headerlink\" title=\"实现 const 运算符\"></a>实现 const 运算符</h3><p><code>Proxy</code> 是 JavaScript 提供的元编程能力，可以拦截对象的操作，包括属性的读取、设置、函数的调用等。虽然 <code>Proxy</code> 可以拦截对象的操作，但是它无法完全模拟出真正的 <code>const</code> 行为，因为 JavaScript 中的引用类型数据（如对象、数组等）可以通过引用继续修改，即使使用 <code>Proxy</code> 拦截了操作。</p>\n<p>下面是一个使用 <code>Proxy</code> 拦截来模拟 <code>const</code> 的简单示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const createConst &#x3D; (value) &#x3D;&gt; &#123;\n  const handler &#x3D; &#123;\n    set: function (target, prop, value) &#123;\n      throw new Error(&#39;Cannot modify a constant&#39;);\n    &#125;,\n    defineProperty: function (target, prop, descriptor) &#123;\n      throw new Error(&#39;Cannot define property on a constant&#39;);\n    &#125;,\n    deleteProperty: function (target, prop) &#123;\n      throw new Error(&#39;Cannot delete property of a constant&#39;);\n    &#125;,\n  &#125;;\n\n  return new Proxy(&#123; value &#125;, handler);\n&#125;;\n\nconst myConst &#x3D; createConst(10);\n\nconsole.log(myConst.value); &#x2F;&#x2F; Output: 10\n\ntry &#123;\n  myConst.value &#x3D; 20; &#x2F;&#x2F; 尝试修改值，会抛出异常\n&#125; catch (error) &#123;\n  console.error(error.message); &#x2F;&#x2F; Output: &quot;Cannot modify a constant&quot;\n&#125;\n\ntry &#123;\n  Object.defineProperty(myConst, &#39;newValue&#39;, &#123; value: 30 &#125;); &#x2F;&#x2F; 尝试定义新属性，会抛出异常\n&#125; catch (error) &#123;\n  console.error(error.message); &#x2F;&#x2F; Output: &quot;Cannot define property on a constant&quot;\n&#125;\n\ntry &#123;\n  delete myConst.value; &#x2F;&#x2F; 尝试删除属性，会抛出异常\n&#125; catch (error) &#123;\n  console.error(error.message); &#x2F;&#x2F; Output: &quot;Cannot delete property of a constant&quot;\n&#125;</code></pre>\n\n<p>这个示例使用 <code>Proxy</code> 拦截了对常量的设置、属性定义和属性删除操作，当有操作违反常量约定时，会抛出异常。虽然 <code>Proxy</code> 可以提供一定的约束和保护，但仍然无法完全模拟出真正的 <code>const</code> 行为，因为它无法阻止引用类型数据内部的属性修改。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p><strong>什么是链表</strong></p>\n<p>数据的一种存储结构，一个链表包含若干个节点，每个节点至少包含一个数据域和指针域</p>\n<p><a href=\"https://wenku.baidu.com/view/33d6ed103a68011ca300a6c30c2259010302f35b.html\" target=\"_blank\" >百度文库(收费了，只能看部分)、参考链接</a></p>\n<p><a href=\"https://blog.csdn.net/m0_47109503/article/details/117566907\" target=\"_blank\" >参考链接</a></p>\n<h3 id=\"单向-vs-双向\"><a href=\"#单向-vs-双向\" class=\"headerlink\" title=\"单向 vs 双向\"></a>单向 vs 双向</h3><p>单向链表：只有一个指向下一个节点的指针。</p>\n<ol>\n<li>优点：单向链表增加删除节点简单。遍历时候不会死循环；</li>\n<li>缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。</li>\n</ol>\n<p>适用于节点的增加删除。</p>\n<p>双向链表：有两个指针，一个指向前一个节点，一个后一个节点。</p>\n<ol>\n<li>优点：可以找到前驱和后继，可进可退；</li>\n<li>缺点：增加删除节点复杂，需要多分配一个指针存储空间。</li>\n</ol>\n<p>适用于需要双向查找节点值的情况</p>\n<p><a href=\"https://blog.csdn.net/qq_36553031/article/details/82885804\" target=\"_blank\" >单向链表和双向链表的优缺点及使用场景</a></p>\n<h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><ol>\n<li>链表的节点为「数据 data、指针 next」的数据接口， 节点通过指针串联起来的数据结构：拥有 节点的增、删、改功能，还可以进行遍历<ol>\n<li>链表的最后一个节点的 next&#x3D;null</li>\n<li></li>\n</ol>\n</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员\n    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员\n  &#125;\n&#125;\n&#x2F;&#x2F; 定义一个单向链表类\nclass singleLinked &#123;\n  constructor() &#123;\n    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数\n    this.head &#x3D; new Node(&#39;head&#39;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址\n    this.currentNode &#x3D; &#39;&#39;;\n  &#125;\n  &#x2F;&#x2F; 获取链表的长度\n  getLength() &#123;\n    return this.size;\n  &#125;\n  &#x2F;&#x2F; 判断链表是否为空\n  isEmpty() &#123;\n    return this.size &#x3D;&#x3D;&#x3D; 0;\n  &#125;\n  &#x2F;&#x2F; 遍历链表：不重复访问链表中的每个节点\n  displayList() &#123;\n    var list &#x3D; &#39;&#39;;\n    var currentNode &#x3D; this.head; &#x2F;&#x2F; 指向链表的头指针\n    while (currentNode) &#123;\n      &#x2F;&#x2F; 如果当前节点不为空，则表明当前节点中存在数据\n      list +&#x3D; currentNode.data;\n      &#x2F;&#x2F; 同时让当前节点的指针指向下一个节点\n      currentNode &#x3D; currentNode.next;\n\n      if (currentNode) &#123;\n        &#x2F;&#x2F; 如果当前节点的下一个节点不为空\n        list +&#x3D; &#39;-&gt;&#39;; &#x2F;&#x2F; 拼接后看起来像一个链表\n      &#125;\n    &#125;\n    console.log(list);\n  &#125;\n\n  &#x2F;&#x2F; 获取链表的最后一个节点\n  findLast() &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    return currentNode;\n  &#125;\n\n  &#x2F;&#x2F; 采用尾插法在链表尾部添加元素，即创建一个链表\n  appendNode(element) &#123;\n    var currentNode &#x3D; this.findLast(); &#x2F;&#x2F; 找到链表的最后一个节点\n    var newNode &#x3D; new Node(element); &#x2F;&#x2F; 创建一个新节点\n    currentNode.next &#x3D; newNode; &#x2F;&#x2F; 把新的节点放在链表里去（放在最后一个的后面）\n    &#x2F;&#x2F; newNode.next &#x3D; null; &#x2F;&#x2F; 因为新节点已经是链表最后一个节点\n    this.size++; &#x2F;&#x2F; 因为新插入一个节点，让链表的长度+1\n  &#125;\n  &#x2F;&#x2F; 删除一个节点\n  deleteNode(element) &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    &#x2F;&#x2F; 将链的节点与另一个节点连上\n    currentNode.next &#x3D; currentNode.next.next;\n    this.size--;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 上述链表代码的测试\n&#x2F;&#x2F; 最好使用循环，往里面加数据\nvar slist &#x3D; new singleLinked();\n\nvar arr &#x3D; [1001, 1234, 1006, 7788, 5512, 6129];\nfor (var i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  slist.appendNode(arr[i]);\n&#125;\nslist.displayList();\nslist.deleteNode(1001);\nslist.displayList();</code></pre>\n\n<h3 id=\"双向链表《不是环》\"><a href=\"#双向链表《不是环》\" class=\"headerlink\" title=\"双向链表《不是环》\"></a>双向链表《不是环》</h3><p><a href=\"https://blog.csdn.net/dingshao1114/article/details/105340579\" target=\"_blank\" >js 数据结构之双向链表 doublyLinkedList</a></p>\n<img src=\"https://img-blog.csdnimg.cn/20200406112533896.png#pic_center\" />\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 双向链表节点\n * 包含三个值: 当前节点的值和分别指向前后节点的指针\n *&#x2F;\nclass Node &#123;\n  constructor(element) &#123;\n    this.element &#x3D; element;\n    this.next &#x3D; null;\n    this.prev &#x3D; null;\n  &#125;\n&#125;\n\n&#x2F;** 双向链表 *&#x2F;\nclass DoublyLinkedList &#123;\n  constructor() &#123;\n    this.head &#x3D; null;\n  &#125;\n\n  &#x2F;** 在链表末尾添加一个元素 *&#x2F;\n  add(element) &#123;\n    &#x2F;&#x2F; 链表是否已有节点\n    const node &#x3D; new Node(element);\n    &#x2F;&#x2F; 没有节点\n    if (this.head &#x3D;&#x3D;&#x3D; null) &#123;\n      this.head &#x3D; node;\n      return;\n    &#125;\n    &#x2F;&#x2F; 有节点\n    let current &#x3D; this.head;\n    while (current.next) &#123;\n      current &#x3D; current.next;\n    &#125;\n    current.next &#x3D; node;\n    node.prev &#x3D; current;\n  &#125;\n\n  &#x2F;** 删除 *&#x2F;\n  remove(element) &#123;\n    &#x2F;&#x2F; 链表无数据\n    if (this.head &#x3D;&#x3D;&#x3D; null) &#123;\n      return false;\n    &#125;\n    let current &#x3D; this.head;\n    &#x2F;&#x2F; 链表有数据\n    if (current.element &#x3D;&#x3D;&#x3D; element) &#123;\n      &#x2F;&#x2F; 有2个\n      if (this.head.next) &#123;\n        this.head &#x3D; this.head.next;\n        this.head.prev &#x3D; null;\n      &#x2F;&#x2F; 只有一个\n      &#125; else &#123;\n        this.head &#x3D; null;\n      &#125;\n      return true;\n    &#125;\n\n\n\n    let prev;\n    while (current !&#x3D;&#x3D; null &amp;&amp; current.element !&#x3D;&#x3D; element) &#123;\n      prev &#x3D; current;\n      current &#x3D; current.next;\n    &#125;\n    if (current) &#123;\n      prev.next &#x3D; current.next || null;\n      &#x2F;&#x2F; 与之前的节点建立pre链接\n      if (current.next) &#123;\n        current.next.prev &#x3D; prev;\n      &#125;\n      return true;\n    &#125;\n    return false;\n  &#125;\n\n  &#x2F;** 反向遍历 *&#x2F;\n  reverse() &#123;\n    let current &#x3D; this.head;\n    let prev &#x3D; null;\n    let tail &#x3D; null;\n    &#x2F;&#x2F; step1: 调序重排\n    while (current !&#x3D;&#x3D; null) &#123;\n      prev &#x3D; current.prev;\n      &#x2F;&#x2F; pre 指向后面，next指向前面\n      current.prev &#x3D; current.next;\n      current.next &#x3D; prev;\n\n      tail &#x3D; current;\n      current &#x3D; current.prev;\n    &#125;\n    this.head &#x3D; tail;\n    &#x2F;&#x2F; step2: 正序遍历\n    current &#x3D; this.head;\n    while (current !&#x3D;&#x3D; null) &#123;\n      yield current.element;\n      current &#x3D; current.next;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 示例\nconst list &#x3D; new DoublyLinkedList();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;5&quot;);\nlist.add(&quot;3&quot;);\n\nlist.remove(&quot;5&quot;);\n\nconst reverseList &#x3D; list.reverse();\n\nconsole.log(reverseList.next());\nconsole.log(reverseList.next());\nconsole.log(reverseList.next());</code></pre>\n\n<h3 id=\"链表反转\"><a href=\"#链表反转\" class=\"headerlink\" title=\"链表反转\"></a>链表反转</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function reverseList(head) &#123;\n  &#x2F;&#x2F; 初始化prev&#x2F;cur指针\n  let prev &#x3D; null; &#x2F;&#x2F; pre指针（新链表的头指针）\n  let cur &#x3D; head; &#x2F;&#x2F; cur指针\n  &#x2F;&#x2F; 开始遍历链表\n  while (cur) &#123;\n    let next &#x3D; cur.next; &#x2F;&#x2F; 暂存，之后用于cur指针移动\n    cur.next &#x3D; prev; &#x2F;&#x2F; 建立新的链表关系\n    prev &#x3D; cur; &#x2F;&#x2F; pre 指针移动\n    cur &#x3D; next; &#x2F;&#x2F; cur 指针移动\n  &#125;\n  return prev;\n&#125;</code></pre>\n\n<h3 id=\"链表有环\"><a href=\"#链表有环\" class=\"headerlink\" title=\"链表有环\"></a>链表有环</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 终止条件：\n&#x2F;&#x2F;    有环快慢指针相遇\n&#x2F;&#x2F;    无环遍历结束的时候\nfunction hasCycle(head) &#123;\n  let fast &#x3D; head;\n  let slow &#x3D; head;\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n    &#x2F;&#x2F; 有环终止的条件\n    if (fast &#x3D;&#x3D;&#x3D; slow) return true;\n  &#125;\n  return false;\n&#125;</code></pre>\n\n<h3 id=\"链表中点\"><a href=\"#链表中点\" class=\"headerlink\" title=\"链表中点\"></a>链表中点</h3><p>链表有中点，则链表没有环,快指针式慢指针的两倍速度，快指针到链表尾部时候，慢指针刚好到临近中间位置</p>\n<ol>\n<li>链表<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null</code>, fast &#x3D;&#x3D;&#x3D; null 结束时, 已完成情况：fast:<code>1,3,5,null</code>, slow: <code>1,2,3</code></li>\n<li>链表<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null</code>, fast.next &#x3D;&#x3D;&#x3D; null 结束时,已完成情况： fast: <code>1,3,5,7</code>, slow: <code>1,2,3</code>, 这里慢指针并没有到达中间点，还差一步</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function middleNode(head) &#123;\n  &#x2F;&#x2F; body\n  let fast &#x3D; head;\n  let slow &#x3D; head;\n\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n  &#125;\n  &#x2F;&#x2F; 看是fast结束的还是fast.next结束的\n  &#x2F;&#x2F; 处理链表节点为奇数的情况\n  if (fast) &#123;\n    &#x2F;&#x2F; 也就是fast.next &#x3D;&#x3D;&#x3D; null的情况\n    slow &#x3D; slow.next;\n  &#125;\n  return slow;\n&#125;</code></pre>\n\n<h3 id=\"链表中环的入口节点\"><a href=\"#链表中环的入口节点\" class=\"headerlink\" title=\"链表中环的入口节点\"></a>链表中环的入口节点</h3><ol>\n<li>理解：快慢指针相遇点</li>\n<li>理解：什么是环的入口</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202303071103119.webp\" />\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/103626709\" target=\"_blank\" >链表中环的入口节点</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 阶段1: 快指针走两步，慢指针走一步，找到相遇点\n&#x2F;&#x2F; 阶段2: 快指针从头一步一步走，慢指针从相遇点一步一步走（为什么成立：因为方程式有解）\nfunction detectCycle(head) &#123;\n  let fast &#x3D; head;\n  let slow &#x3D; head;\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n    &#x2F;&#x2F; prettier-ignore\n    if (fast &#x3D;&#x3D; slow) &#123; &#x2F;&#x2F; 相遇点\n      fast &#x3D; head; &#x2F;&#x2F; 快指针从头走\n      while (fast !&#x3D; slow) &#123;\n        fast &#x3D; fast.next;\n        slow &#x3D; slow.next;\n      &#125;\n      return slow;\n    &#125;\n  &#125;\n  return null;\n&#125;</code></pre>\n\n<h3 id=\"判断链表是否相交\"><a href=\"#判断链表是否相交\" class=\"headerlink\" title=\"判断链表是否相交\"></a>判断链表是否相交</h3><p><a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/\" target=\"_blank\" > 相交链表（双指针，清晰图解）</a></p>\n<img src=\"https://pic.leetcode-cn.com/1615224578-EBRtwv-Picture1.png\" />\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function intersectionNode(headA, headB) &#123;\n  let [curA, curB] &#x3D; [headA, headB];\n  while (curA !&#x3D;&#x3D; curB) &#123;\n    curA &#x3D; curA.next &#x3D;&#x3D;&#x3D; null ? headB : curA.next;\n    curB &#x3D; curB.next &#x3D;&#x3D;&#x3D; null ? headA : curB.next;\n  &#125;\n  return curA;\n&#125;\n\n&#x2F;&#x2F; 测试----------------------------------\n\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data;\n    this.next &#x3D; null;\n  &#125;\n&#125;\n\nclass SingleLink &#123;\n  constructor() &#123;\n    this.size &#x3D; 0;\n    this.head &#x3D; new Node(&#39;head&#39;);\n  &#125;\n  &#x2F;&#x2F; 找到链表的最后一个节点\n  findLastNode() &#123;\n    let curNode &#x3D; this.head;\n    while (curNode.next) &#123;\n      curNode &#x3D; curNode.next;\n    &#125;\n    return curNode;\n  &#125;\n  &#x2F;&#x2F; 追加节点\n  appendNode(node) &#123;\n    const lastNode &#x3D; this.findLastNode();\n    lastNode.next &#x3D; node;\n    node.next &#x3D; null; &#x2F;&#x2F; 这个必须加，否则有循环\n    this.size++;\n  &#125;\n&#125;\n\nvar a &#x3D; [1, 11];\n\nvar b &#x3D; [0, 2, 3];\n\nvar common &#x3D; [&#39;a&#39;, &#39;b&#39;];\n&#x2F;&#x2F; 链表A\nconst linka &#x3D; new SingleLink();\nfor (let i &#x3D; 0; i &lt; a.length; i++) &#123;\n  linka.appendNode(new Node(a[i]));\n&#125;\n\n&#x2F;&#x2F; 链表B\nconst linkb &#x3D; new SingleLink();\nfor (let i &#x3D; 0; i &lt; b.length; i++) &#123;\n  linkb.appendNode(new Node(b[i]));\n&#125;\n\n&#x2F;&#x2F; 共节点链表\nfor (let i &#x3D; 0; i &lt; common.length; i++) &#123;\n  const cNode &#x3D; new Node(common[i]);\n  linka.appendNode(cNode);\n  linkb.appendNode(cNode);\n&#125;\n\nconsole.log(&#39;linka&#39;, linka);\n\nvar cNodeLink &#x3D; intersectionNode(linka.head, linkb.head);\nconsole.log(&#39;cNodeLink&#39;, JSON.stringify(cNodeLink, null, 2));\n\n&#x2F;&#x2F; cNodeLink &#123;\n&#x2F;&#x2F;   &quot;data&quot;: &quot;a&quot;,\n&#x2F;&#x2F;   &quot;next&quot;: &#123;\n&#x2F;&#x2F;     &quot;data&quot;: &quot;b&quot;,\n&#x2F;&#x2F;     &quot;next&quot;: null\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F; &#125;</code></pre>\n\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><h3 id=\"最小堆\"><a href=\"#最小堆\" class=\"headerlink\" title=\"最小堆\"></a>最小堆</h3><ol>\n<li><a href=\"https://7kms.github.io/react-illustration-series/algorithm/heapsort\" target=\"_blank\" >见</a></li>\n<li><a href=\"https://juejin.cn/post/6983273957734481933\" target=\"_blank\" >React 的小顶堆排序法</a></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 最小堆\nlet heap &#x3D; [];\n\nfunction push(heap, node) &#123;\n  const index &#x3D; heap.length; &#x2F;&#x2F; 新的数据放置的位置\n  heap.push(node);\n  siftUp(heap, node, index); &#x2F;&#x2F; 增：自下而上\n&#125;\n\nfunction peek(heap) &#123;\n  return heap.length &#x3D;&#x3D;&#x3D; 0 ? null : heap[0];\n&#125;\n\nfunction pop(heap) &#123;\n  if (heap.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return null;\n  &#125;\n  const first &#x3D; heap[0]; &#x2F;&#x2F; 取堆顶\n  const last &#x3D; heap.pop(); &#x2F;&#x2F; 取最后一个元素\n  if (last !&#x3D;&#x3D; first) &#123;\n    &#x2F;&#x2F; 两者不等\n    heap[0] &#x3D; last; &#x2F;&#x2F; 换位\n    siftDown(heap, last, 0); &#x2F;&#x2F; 删：自上而下，对于尾部置换过来的数据，进行下沉处理\n  &#125;\n  return first;\n&#125;\n&#x2F;&#x2F; 上浮处理\nfunction siftUp(heap, node &#x2F;*数据 *&#x2F;, i &#x2F;*数据位置 *&#x2F;) &#123;\n  let index &#x3D; i;\n  while (index &gt; 0) &#123;\n    const parentIndex &#x3D; (index - 1) &gt;&gt;&gt; 1; &#x2F;&#x2F; (index-1)&#x2F;2后取整  等价于 &gt;&gt;&gt;无符号右移\n    const parent &#x3D; heap[parentIndex];\n    if (compare(parent, node) &gt; 0) &#123;\n      &#x2F;&#x2F; 如果parent大，交换\n      heap[parentIndex] &#x3D; node;\n      heap[index] &#x3D; parent;\n      index &#x3D; parentIndex;\n    &#125; else &#123;\n      &#x2F;&#x2F; 如果parent小，退出循环\n      return;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; 下沉处理\nfunction siftDown(heap, node, i) &#123;\n  let index &#x3D; i;\n  const length &#x3D; heap.length; &#x2F;&#x2F; 堆全长\n  const halfLength &#x3D; length &gt;&gt;&gt; 1; &#x2F;&#x2F; 堆半长\n  while (index &lt; halfLength) &#123;\n    const leftIndex &#x3D; (index + 1) * 2 - 1;\n    const left &#x3D; heap[leftIndex];\n    const rightIndex &#x3D; leftIndex + 1;\n    const right &#x3D; heap[rightIndex];\n\n    &#x2F;&#x2F; 如果左侧或右侧节点较小，请使用其中较小的节点进行交换。\n    &#x2F;&#x2F; left &lt; node\n    if (compare(left, node) &lt; 0) &#123;\n      &#x2F;&#x2F; right &lt; left\n      if (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; 0) &#123;\n        heap[index] &#x3D; right;\n        heap[rightIndex] &#x3D; node;\n        index &#x3D; rightIndex;\n        &#x2F;&#x2F; right &gt; left\n      &#125; else &#123;\n        heap[index] &#x3D; left;\n        heap[leftIndex] &#x3D; node;\n        index &#x3D; leftIndex;\n      &#125;\n      &#x2F;&#x2F; left &gt; node &gt; right\n    &#125; else if (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; 0) &#123;\n      heap[index] &#x3D; right;\n      heap[rightIndex] &#x3D; node;\n      index &#x3D; rightIndex;\n    &#125; else &#123;\n      &#x2F;&#x2F; Neither child is smaller. Exit.\n      return;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; a&gt;b\nfunction compare(a, b) &#123;\n  &#x2F;&#x2F; Compare sort index first, then task id.\n  &#x2F;&#x2F; react源码\n  &#x2F;&#x2F; const diff &#x3D; a.sortIndex - b.sortIndex;\n  &#x2F;&#x2F; return diff !&#x3D;&#x3D; 0 ? diff : a.id - b.id;\n  return a - b;\n&#125;\n&#x2F;&#x2F; 循环插入节点\nvar arr &#x3D; [5, 8, 0, 10, 4, 6, 1];\nfor (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  push(heap, arr[i]);\n&#125;\n\nconsole.log(&#39;heap&#39;, heap);\n&#x2F;&#x2F;      0\n&#x2F;&#x2F;   4    1\n&#x2F;&#x2F; 10 8  6 5\n&#x2F;&#x2F; heap [\n&#x2F;&#x2F;   0, 4, 1, 10, 8, 6, 5\n&#x2F;&#x2F; ]\n&#x2F;&#x2F;\n&#x2F;&#x2F; pop(heap);\nconsole.log(&#39;heap&#39;, heap);\n\n&#x2F;&#x2F;      1\n&#x2F;&#x2F;   4    5\n&#x2F;&#x2F; 10 8  6\n\n&#x2F;&#x2F; heap [ 1, 4, 5, 10, 8, 6 ]\n\nfunction printHeap(heap) &#123;\n  if (!heap.length) &#123;\n    console.log(&#39;Heap is empty&#39;);\n  &#125; else &#123;\n    printHeapRecursively(heap, 0, 0);\n  &#125;\n&#125;\nconsole.log(&#39;---------------------------&#39;);\n&#x2F;&#x2F; 这里有个非常重要的点\n&#x2F;&#x2F; 右子树的根节点下标 &#x3D;  index * 2 + 2\n&#x2F;&#x2F; 当前节点的下标 &#x3D; index\n&#x2F;&#x2F; 左子树的根节点下标 &#x3D;  index * 2 + 1\nfunction printHeapRecursively(heap, index, depth) &#123;\n  if (index &lt; heap.length) &#123;\n    printHeapRecursively(heap, index * 2 + 2, depth + 1); &#x2F;&#x2F; 右子树递归\n    console.log(&#96;$&#123;&#39; &#39;.repeat(depth * 4)&#125;[$&#123;heap[index]&#125;]&#96;); &#x2F;&#x2F; 当前节点打印\n    printHeapRecursively(heap, index * 2 + 1, depth + 1); &#x2F;&#x2F; 左子树递归\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"堆打印\"><a href=\"#堆打印\" class=\"headerlink\" title=\"堆打印\"></a>堆打印</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function printHeap(heap) &#123;\n  if (!heap.length) &#123;\n    console.log(&#39;Heap is empty&#39;);\n  &#125; else &#123;\n    printHeapRecursively(heap, 0, 0);\n  &#125;\n&#125;\nconsole.log(&#39;---------------------------&#39;);\n&#x2F;&#x2F; 这里有个非常重要的点\n&#x2F;&#x2F; 右子树的根节点下标 &#x3D;  index * 2 + 2\n&#x2F;&#x2F; 当前节点的下标 &#x3D; index\n&#x2F;&#x2F; 左子树的根节点下标 &#x3D;  index * 2 + 1\nfunction printHeapRecursively(heap, index, depth) &#123;\n  if (index &lt; heap.length) &#123;\n    printHeapRecursively(heap, index * 2 + 2, depth + 1); &#x2F;&#x2F; 右子树递归\n    console.log(&#96;$&#123;&#39; &#39;.repeat(depth * 4)&#125;[$&#123;heap[index]&#125;]&#96;); &#x2F;&#x2F; 当前节点打印\n    printHeapRecursively(heap, index * 2 + 1, depth + 1); &#x2F;&#x2F; 左子树递归\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/afb80e39ce7684d6330fdc66b0873abd.gif\" width=300 />\n\n<p>从图了解到：冒泡路径越来越短: n n-1 n-2 … 2 1</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 解构方式进行赋值\nconst swap &#x3D; (arr, i, j) &#x3D;&gt; ([arr[i], arr[j]] &#x3D; [arr[j], arr[i]]);\n\n&#x2F;&#x2F; 外层遍历负责次数 i&lt;len-1\n&#x2F;&#x2F; 内层遍历处理数据对比 j&#x3D;0 ,j&lt;len-i-1\nfunction BubbleSort(arr) &#123;\n  let len &#x3D; arr.length;\n  if (len &lt; 2) return arr; &#x2F;&#x2F; 没有排序价值\n  for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n    for (let j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n      &#x2F;&#x2F; 是否需要冒泡，这里的冒泡是冒泡到尾部\n      if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1);\n    &#125;\n  &#125;\n  return arr;\n&#125;</code></pre>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/76339a259488423b03370e381ca5edb0.gif\" width=300/>\n\n<p>总图了解到：冒泡路径越来越短: n n-1 n-2 … 2 1</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const swap &#x3D; (arr, i, j) &#x3D;&gt; ([arr[i], arr[j]] &#x3D; [arr[j], arr[i]]);\n\n&#x2F;&#x2F; 同向比较\nconst SelectSort &#x3D; (arr) &#x3D;&gt; &#123;\n  let len &#x3D; arr.length;\n  let i &#x2F;*一重遍历 *&#x2F;, j &#x2F;*二重遍历 *&#x2F;, minIndex &#x2F;*最小元素的下标 *&#x2F;;\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    &#x2F;&#x2F; 每次找最小的进行交换，直至结束\n    minIndex &#x3D; i;\n    for (let j &#x3D; i + 1; j &lt; len; j++) &#123;\n      &#x2F;&#x2F;每次找最小的\n      if (arr[j] &lt; arr[minIndex]) minIndex &#x3D; j;\n    &#125;\n    swap(arr, i, minIndex);\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<h3 id=\"选择排序时间复杂度\"><a href=\"#选择排序时间复杂度\" class=\"headerlink\" title=\"选择排序时间复杂度\"></a>选择排序时间复杂度</h3><p>选择排序（Selection Sort）的时间复杂度为 O(n^2)。</p>\n<p>选择排序是一种简单直观的排序算法，它的基本思想是在未排序部分中选择最小（或最大）的元素，并将其放置在已排序部分的末尾。通过不断选择最小元素，逐步构建有序序列。</p>\n<p>算法步骤：</p>\n<ol>\n<li>在未排序部分找到最小元素。</li>\n<li>将最小元素与未排序部分的第一个元素交换位置，将其放置在已排序部分的末尾。</li>\n<li>不断重复以上步骤，直到整个序列都排好序。</li>\n</ol>\n<p>选择排序的时间复杂度的推导如下：</p>\n<ul>\n<li>对于 n 个元素的序列，需要进行 n-1 轮比较和交换，因为每一轮都会确定一个元素的位置。</li>\n<li>在每一轮中，需要进行 n-i 次比较，其中 i 是当前轮数（从 0 开始计数）。</li>\n<li>所以总的比较次数是：(n-1) + (n-2) + … + 1 &#x3D; n * (n-1) &#x2F; 2。</li>\n<li>近似情况下，时间复杂度为 O(n^2)。</li>\n</ul>\n<p>选择排序的时间复杂度为 O(n^2) 是一种较高的复杂度，因此在大规模数据的排序场景下，选择排序性能较差。然而，选择排序是一种原地排序算法，不需要额外的空间，且排序过程中交换次数相对较少，因此在某些特定情况下，可能会有一定的优势。但通常情况下，更高效的排序算法如快速排序、归并排序等更适合处理大规模数据的排序任务。</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/c894e22dcc48b03559e3087627e3dbb8.gif\" width=300/>\n\n<p>被遍历元素与前面的元素逐个相比较，前面的元素挪位给它</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; sential &#x3D; arr[i] 外层\n&#x2F;&#x2F; 内存循环条件 j&#x3D;i-1\nfunction insertSort(arr) &#123;\n  if (arr.length &lt;&#x3D; 0) return arr;\n  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;\n    let temp &#x3D; arr[i];\n    let j &#x3D; i - 1; &#x2F;&#x2F; 取前一个位置元素\n    &#x2F;&#x2F; prettier-ignore\n    for (; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j--) &#123;   &#x2F;&#x2F; 挪位置\n      arr[j + 1] &#x3D; arr[j];\n    &#125;\n    &#x2F;&#x2F; 将元素放置到这个位置\n    arr[j + 1] &#x3D; temp;\n  &#125;\n\n  return result;\n&#125;</code></pre>\n\n<h3 id=\"插入排序时间复杂度\"><a href=\"#插入排序时间复杂度\" class=\"headerlink\" title=\"插入排序时间复杂度\"></a>插入排序时间复杂度</h3><p>插入排序（Insertion Sort）的时间复杂度为 O(n^2)。</p>\n<p>插入排序是一种简单直观的排序算法，它的基本思想是将未排序部分的元素逐个插入到已排序部分的正确位置，从而逐步构建有序序列。</p>\n<p>算法步骤：</p>\n<ol>\n<li>将第一个元素视为已排序部分，将其余元素视为未排序部分。</li>\n<li>从未排序部分依次取出一个元素，插入到已排序部分的正确位置，使得已排序部分始终保持有序。</li>\n<li>重复以上步骤，直到整个序列都排好序。</li>\n</ol>\n<p>插入排序的时间复杂度的推导如下：</p>\n<ul>\n<li>对于 n 个元素的序列，需要进行 n-1 轮插入操作，因为第一个元素默认是已排序的，无需插入。</li>\n<li>在每一轮插入操作中，最坏情况下需要比较和移动 n-i 次，其中 i 是当前轮数（从 1 开始计数）。</li>\n<li>所以总的比较和移动次数是：(n-1) + (n-2) + … + 1 &#x3D; n * (n-1) &#x2F; 2。</li>\n<li>近似情况下，时间复杂度为 O(n^2)。</li>\n</ul>\n<p>插入排序的时间复杂度为 O(n^2) 是一种较高的复杂度，因此在大规模数据的排序场景下，插入排序性能较差。然而，插入排序在处理部分有序或者小规模数据时可能会有一定的优势，因为它的执行时间与数据的初始排序状态相关。</p>\n<p>对于大规模数据的排序，通常更高效的排序算法如快速排序、归并排序等更适合。但插入排序作为一种原地排序算法，不需要额外的空间，且排序过程中移动次数相对较少，因此在特定场景下仍然是一种有用的排序算法。</p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><img src=\"https://img-blog.csdnimg.cn/956f63eccd75480791c85edd8ce91658.gif\" width=300/>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [2, 44, 1, 0, -22, 56, -78];\n&#x2F;&#x2F; 分-合过程，分：递 、合：归\nfunction mergeSort(arr) &#123;\n  if (arr.length &lt;&#x3D; 1) return arr;\n\n  const middle &#x3D; Math.floor(arr.length &#x2F; 2);\n  const left &#x3D; arr.slice(0, middle);\n  const right &#x3D; arr.slice(middle);\n  &#x2F;&#x2F; 递 拆分\n  return merge(mergeSort(left), mergeSort(right));\n  &#x2F;&#x2F; 归 合并\n  &#x2F;&#x2F; 辅助函数，用于将两个数组合并为一个有序数组，并返回\n  function merge(left, right) &#123;\n    const result &#x3D; [];\n    while (left.length &amp;&amp; right.length) &#123;\n      &#x2F;&#x2F; 放入较小的元素，并从头部移出\n      result.push(left[0] &lt;&#x3D; right[0] ? left.shift() : right.shift());\n    &#125;\n    result.push(...left, ...right); &#x2F;&#x2F; 放入剩余元素\n    return result;\n  &#125;\n&#125;\n\nconsole.log(mergeSort(arr));</code></pre>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><img src=\"http://t-blog-images.aijs.top/img/1940317-acc6c6f16b096794.gif\" />\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/4ad3b539bee9bfe9a6acdba476ceed78.gif\" width=300 />\n\n<img src=\"http://t-blog-images.aijs.top/img/20220704153839.webp\" />\n\n<p>找基点，小于的排左侧，大于的排右侧</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;*\n快排是冒泡的一种改进，基于分治思想\n*&#x2F;\nconst arr2 &#x3D; [2, 44, 1, 0, -22, 56, -78];\n\nfunction quickSort(arr) &#123;\n  if (arr.length &lt;&#x3D; 1) return arr;\n\n  const pivot &#x3D; arr.pop(); &#x2F;&#x2F; 使用最后一个元素当作基准数\n  &#x2F;&#x2F; prettier-ignore\n  const left &#x3D; [], right &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; pivot) &#123;\n      left.push(arr[i]); &#x2F;&#x2F; 小于基准数则放到left\n    &#125; else &#123;\n      right.push(arr[i]); &#x2F;&#x2F; 大于基准数则放到right\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 合并left的快排结果，基准数和右侧的快排结果\n  return quickSort(left).concat(pivot, quickSort(right));\n&#125;\n\nconsole.log(quickSort(arr2));</code></pre>\n\n<h2 id=\"实现管理本地缓存过期的方法\"><a href=\"#实现管理本地缓存过期的方法\" class=\"headerlink\" title=\"实现管理本地缓存过期的方法\"></a>实现管理本地缓存过期的方法</h2><p>在 JavaScript 中，可以使用 <code>localStorage</code> 或 <code>sessionStorage</code> 来存储本地缓存数据。如果需要实现本地缓存过期的管理，可以在存储时额外保存一个过期时间戳，并在读取缓存数据时检查该时间戳来判断是否已过期。以下是一个简单的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function setCacheWithExpiration(key, value, expirationSeconds) &#123;\n  const now &#x3D; new Date().getTime();\n  const expirationTime &#x3D; now + expirationSeconds * 1000;\n  const cacheData &#x3D; &#123; value, expirationTime &#125;;\n  localStorage.setItem(key, JSON.stringify(cacheData));\n&#125;\n\nfunction getCacheWithExpiration(key) &#123;\n  const cacheData &#x3D; localStorage.getItem(key);\n  if (!cacheData) &#123;\n    return null; &#x2F;&#x2F; 缓存不存在\n  &#125;\n\n  const parsedCacheData &#x3D; JSON.parse(cacheData);\n  const now &#x3D; new Date().getTime();\n  if (now &gt; parsedCacheData.expirationTime) &#123;\n    &#x2F;&#x2F; 缓存已过期\n    localStorage.removeItem(key);\n    return null;\n  &#125;\n\n  return parsedCacheData.value;\n&#125;\n\n&#x2F;&#x2F; 示例使用\nsetCacheWithExpiration(&#39;myData&#39;, &#123; name: &#39;John&#39; &#125;, 60); &#x2F;&#x2F; 设置缓存60秒过期\nconst cachedData &#x3D; getCacheWithExpiration(&#39;myData&#39;);\nif (cachedData) &#123;\n  console.log(&#39;Cached data:&#39;, cachedData);\n&#125; else &#123;\n  console.log(&#39;Cache expired or not found.&#39;);\n&#125;</code></pre>\n\n<p>在这个示例中，<code>setCacheWithExpiration</code> 函数用于设置带有过期时间的缓存数据，<code>getCacheWithExpiration</code> 函数用于获取缓存数据并检查是否已过期。如果缓存已过期，<code>getCacheWithExpiration</code> 会移除过期缓存并返回 <code>null</code>。注意，这个示例使用的是 <code>localStorage</code>，也可以根据需要替换成 <code>sessionStorage</code> 或其他本地缓存方式。</p>\n<p>这种方法只是简单的过期时间管理，实际应用中可能需要更复杂的策略，例如自动刷新缓存、异步数据的过期判断等，具体根据业务需求来设计缓存过期管理的逻辑。</p>\n<h2 id=\"闭包缓存过期\"><a href=\"#闭包缓存过期\" class=\"headerlink\" title=\"闭包缓存过期\"></a>闭包缓存过期</h2><p>waiting..</p>\n<h2 id=\"LRU-算法\"><a href=\"#LRU-算法\" class=\"headerlink\" title=\"LRU 算法\"></a>LRU 算法</h2><p><code>LRU 定义</code>： 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择内存中最近最久未使用的页面予以淘汰。</p>\n<p><code>使用场景</code>：正如定义所说，如果我们想要实现缓存机制 – 满足最近最少使用淘汰原则，我们就可以使用 LRU 算法缓存机制。如：vue 中 keep-alive 中就用到了此算法。</p>\n<p><code>实现思路</code>： – 维护一个数组，提供 get 和 put 两个方法，并且限制数组元素数量（及缓存数量）</p>\n<p><code>实现方法</code>：</p>\n<pre><code>1. get 可以标记某个元素是最新使用的，提升到第一项\n2. put 可以加入一个 key-value 元素，但是需要判断是否已存在，是否超出限额\n</code></pre>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 时间复杂度 O(1)，因为 Map 既能保持键值对，还能记住插入顺序。\nvar LRUCache &#x3D; function (capacity) &#123;\n  this.cache &#x3D; new Map();\n  this.capacity &#x3D; capacity;\n&#125;;\n\nLRUCache.prototype.get &#x3D; function (key) &#123;\n  if (this.cache.has(key)) &#123;\n    &#x2F;&#x2F; 存在即更新\n    let temp &#x3D; this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, temp);\n    return temp;\n  &#125;\n  return -1;\n&#125;;\n\nLRUCache.prototype.put &#x3D; function (key, value) &#123;\n  &#x2F;&#x2F; 存在即更新（删除后加入）,这种情况肯定不会溢出\n  if (this.cache.has(key)) &#123;\n    this.cache.delete(key);\n    &#x2F;&#x2F; 不存在即加入\n    &#x2F;&#x2F; 缓存超过最大值，则移除最近没有使用的\n  &#125; else if (this.cache.size &gt;&#x3D; this.capacity) &#123;\n    &#x2F;&#x2F; new Map().keys() 返回一个新的 Iterator 对象\n    this.cache.delete(this.cache.keys().next().value);\n  &#125;\n  this.cache.set(key, value);\n&#125;;\n\n&#x2F;&#x2F; var map &#x3D; new Map()\n&#x2F;&#x2F; map.set(1,1)\n&#x2F;&#x2F; Map(1) &#123;1 &#x3D;&gt; 1&#125;\n&#x2F;&#x2F; map.set(2,2)\n&#x2F;&#x2F; Map(2) &#123;1 &#x3D;&gt; 1, 2 &#x3D;&gt; 2&#125;\n&#x2F;&#x2F; map.set(3,3)\n&#x2F;&#x2F; Map(3) &#123;1 &#x3D;&gt; 1, 2 &#x3D;&gt; 2, 3 &#x3D;&gt; 3&#125;\n\n&#x2F;&#x2F; map.keys().next()\n&#x2F;&#x2F; &#123;value: 1, done: false&#125;\n\n&#x2F;&#x2F; 类实现\n\nclass LRU &#123;\n  constructor(capacity) &#123;\n    this.capacity &#x3D; capacity;\n    this.cache &#x3D; new Map();\n  &#125;\n  &#x2F;&#x2F; 获取\n  get(key) &#123;\n    if (this.cache.has(key)) &#123;\n      &#x2F;&#x2F; 删除后新增\n      const temp &#x3D; this.cache.get(key);\n      this.cache.delete(key);\n      this.cache.set(key, temp);\n      return temp;\n    &#125;\n    return -1;\n  &#125;\n  &#x2F;&#x2F; 设置\n  put(key, value) &#123;\n    if (this.cache.has(key)) &#123;\n      this.cache.delete(key);\n    &#125;else (this.cache.size&gt;&#x3D;this.capacity)&#123;\n      this.cache.delete(this.cache.keys().next().value)\n    &#125;\n\n    this.cache.set(key, value);\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"leecode\"><a href=\"#leecode\" class=\"headerlink\" title=\"leecode\"></a>leecode</h2><h3 id=\"红包算法\"><a href=\"#红包算法\" class=\"headerlink\" title=\"红包算法\"></a>红包算法</h3><h3 id=\"括号匹配\"><a href=\"#括号匹配\" class=\"headerlink\" title=\"括号匹配\"></a>括号匹配</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 左匹配进栈\n&#x2F;&#x2F; 右匹配出栈\n&#x2F;&#x2F; 进栈&#x3D;&#x3D;出栈数量\nfunction isValid(s) &#123;\n  let stack &#x3D; new Stack();\n  &#x2F;&#x2F; 遍历 字符串\n  for (let c of s) &#123;\n    &#x2F;&#x2F; 遇到左括号，将与其匹配的右括号入栈处理\n\n    if (c &#x3D;&#x3D;&#x3D; &#39;(&#39;) &#123;\n      stack.push(&#39;)&#39;);\n    &#125; else if (c &#x3D;&#x3D;&#x3D; &#39;[&#39;) &#123;\n      stack.push(&#39;]&#39;);\n    &#125; else if (c &#x3D;&#x3D;&#x3D; &#39;&#123;&#39;) &#123;\n      stack.push(&#39;&#125;&#39;);\n      &#x2F;&#x2F; 遇到右括号\n      &#x2F;&#x2F; 1. 判断栈内是否有括号，如果没有，那说明此时匹配不了\n      &#x2F;&#x2F; 2. 满足①的情况下，判断此时字符是否和栈顶元素匹配\n    &#125; else if (stack.isEmpty() || stack.pop() !&#x3D;&#x3D; c) &#123;\n      return false;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最后再验证一下，栈是否为空，如果不为空，说明还有未匹配的括号\n  return stack.isEmpty();\n&#125;\n&#x2F;&#x2F; 原理：数组的 push 和 pop\nclass Stack &#123;\n  constructor() &#123;\n    this.items &#x3D; [];\n  &#125;\n  &#x2F;&#x2F; 进栈\n  push(element) &#123;\n    this.items.push(element);\n  &#125;\n  &#x2F;&#x2F; 出栈\n  pop() &#123;\n    return this.items.pop();\n  &#125;\n  &#x2F;&#x2F; 是否为空\n  isEmpty() &#123;\n    return this.items.length &#x3D;&#x3D;&#x3D; 0;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"螺旋矩阵\"><a href=\"#螺旋矩阵\" class=\"headerlink\" title=\"螺旋矩阵\"></a>螺旋矩阵</h3><h3 id=\"大数相加\"><a href=\"#大数相加\" class=\"headerlink\" title=\"大数相加\"></a>大数相加</h3><p><a href=\"https://blog.csdn.net/qq_39816673/article/details/88667505\" target=\"_blank\" >JS 大数相加</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function add(str1, str2) &#123;\n  str1 &#x3D; str1.split(&#39;&#39;); &#x2F;&#x2F; 转化成数组\n  str2 &#x3D; str2.split(&#39;&#39;); &#x2F;&#x2F; 转化成数组\n\n  let result &#x3D; &#39;&#39;; &#x2F;&#x2F; 结果\n  let flag &#x3D; 0; &#x2F;&#x2F; 满10进1标记\n\n  while (str1.length || str2.length || flag) &#123;\n    &#x2F;&#x2F; 计算完\n    const val &#x3D; flag + ~~str1.pop() + ~~str2.pop(); &#x2F;&#x2F; ~~undefined &#x3D; 0, true + 0 &#x3D;1, false + 0 &#x3D; 0\n    &#x2F;&#x2F; 结果\n    result &#x3D; (val % 10) + result; &#x2F;&#x2F; 这里是拼接不是 number 加\n    &#x2F;&#x2F; 是否进位\n    flag &#x3D; val &gt; 9 ? val % 10 : 0;\n  &#125;\n  return result.replace(&#x2F;^0+&#x2F;, &#39;&#39;); &#x2F;&#x2F; 首部有0去除\n&#125;\n\nconsole.log(add(&#39;00125&#39;, &#39;0131231231232132136&#39;));\n\n&#x2F;&#x2F; 这段代码是一个实现两个字符串表示的非负整数的相加函数。函数内部使用数组来模拟竖式相加的过程，并且在计算过程中考虑了进位。最后将相加结果转化为字符串并去除前导的零。\n\n&#x2F;&#x2F; 让我们逐步分析这个函数的实现：\n\n&#x2F;&#x2F; 1. 首先，将输入的两个字符串 &#96;str1&#96; 和 &#96;str2&#96; 转化为数组形式，方便逐位相加。\n\n&#x2F;&#x2F; 2. 初始化结果字符串 &#96;result&#96; 为空字符串，初始化进位标记 &#96;flag&#96; 为0。\n\n&#x2F;&#x2F; 3. 使用 &#96;while&#96; 循环，循环的条件是：&#96;str1&#96; 或 &#96;str2&#96; 还有剩余字符，或者进位标记不为0（说明还有进位未处理）。\n\n&#x2F;&#x2F; 4. 在循环中，每次从 &#96;str1&#96; 和 &#96;str2&#96; 的末尾取出一个字符（使用 &#96;pop()&#96; 方法）并转化为整数。使用位运算 &#96;~~&#96; 来保证字符转整数的操作安全，因为 &#96;~~undefined&#96; 是0。然后将这两个整数与进位标记相加得到 &#96;val&#96;。\n\n&#x2F;&#x2F; 5. 计算 &#96;val&#96; 对10取余的结果并拼接到 &#96;result&#96; 的前面，这是当前位的结果。\n\n&#x2F;&#x2F; 6. 判断 &#96;val&#96; 是否大于9，如果大于9，说明需要进位，将 &#96;val&#96; 对10取余的结果作为新的进位标记，否则将进位标记设为0。\n\n&#x2F;&#x2F; 7. 循环结束后，得到的 &#96;result&#96; 可能会有前导的零，使用 &#96;replace()&#96; 方法将前导零去除。\n\n&#x2F;&#x2F; 这个函数可以用来处理两个字符串表示的大整数相加，它考虑了进位并返回相加结果。</code></pre>\n\n<h3 id=\"找出出现次数最多的英语单词\"><a href=\"#找出出现次数最多的英语单词\" class=\"headerlink\" title=\"找出出现次数最多的英语单词\"></a>找出出现次数最多的英语单词</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var paragraph &#x3D; &#39;Bob hit a ball, the hit BALL flew far after it was hit.&#39;;\n\nfunction findMaxWord(paragraph) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  var p &#x3D; paragraph.replace(&#x2F;[\\W\\s]&#x2F;g, &quot; &quot;).toLowerCase().split(&quot; &quot;);\n  &#x2F;&#x2F; console.log(&quot;p&quot;, p);\n  &#x2F;&#x2F; [&#39;bob&#39;, &#39;hit&#39;, &#39;a&#39;, &#39;ball&#39;, &#39;&#39;, &#39;the&#39;, &#39;hit&#39;, &#39;ball&#39;, &#39;flew&#39;, &#39;far&#39;, &#39;after&#39;, &#39;it&#39;, &#39;was&#39;, &#39;hit&#39;, &#39;&#39;]\n  const obj &#x3D; &#123;&#125;;\n\n  for (const word of p) &#123;\n    if (!word) continue;\n    if (obj[word]) &#123;\n      obj[word]++;\n    &#125; else &#123;\n      obj[word] &#x3D; 1;\n    &#125;\n  &#125;\n\n  let max &#x3D; 0;\n  let word &#x3D; &#39;&#39;;\n  for (const k in obj) &#123;\n    if (obj[k] &gt; max) &#123;\n      max &#x3D; obj[k];\n      word &#x3D; k;\n    &#125;\n  &#125;\n\n  return &#123;\n    count: max,\n    word,\n  &#125;;\n&#125;\n\nconst res &#x3D; findMaxWord(paragraph);\nconsole.log(res);</code></pre>\n\n<h3 id=\"节点倒序（将-ul-id-x3D-list，将-ul-节点下的-10000-个-li-节点倒序。考虑性能。）【待处理】\"><a href=\"#节点倒序（将-ul-id-x3D-list，将-ul-节点下的-10000-个-li-节点倒序。考虑性能。）【待处理】\" class=\"headerlink\" title=\"节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】\"></a>节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】</h3><h3 id=\"实现一个函数计算-“1-12-31-100-93”【待处理】\"><a href=\"#实现一个函数计算-“1-12-31-100-93”【待处理】\" class=\"headerlink\" title=\"实现一个函数计算 “1+12-31+100-93”【待处理】\"></a>实现一个函数计算 “1+12-31+100-93”【待处理】</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function calc(str) &#123;\n  return eval(str);\n&#125;\n\nfunction calcStr(str) &#123;\n  var newStr &#x3D; a.replace(&#x2F;-\\d+&#x2F;g, (x) &#x3D;&gt; &#123;\n    return &#39;+&#39; + x;\n  &#125;);\n  let result &#x3D; newStr.split(&#39;+&#39;).reduce((pre, crt) &#x3D;&gt; pre + parseFloat(crt), 0);\n  console.log(&#39;eval(a)&#39;, eval(str));\n  console.log(&#39;result&#39;, result);\n  return result;\n&#125;\nvar a &#x3D; &#39;1+12-31+100-93&#39;;\n&#x2F;&#x2F; var a &#x3D; &quot;1+12+(-31)+100+(-93)&quot;;\n\ncalcStr(a);</code></pre>\n\n<h3 id=\"判断链表是否有环\"><a href=\"#判断链表是否有环\" class=\"headerlink\" title=\"判断链表是否有环\"></a>判断链表是否有环</h3><ul>\n<li><p>快慢指针</p>\n<p><a href=\"https://www.zhihu.com/question/23208893\" target=\"_blank\" >为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Solution &#123;\n  ...\n  hasCycle() &#123;\n    let fast &#x3D; this.head; &#x2F;&#x2F; 每次走两步\n    let slow &#x3D; this.head; &#x2F;&#x2F; 每次走一步\n    while (fast &amp;&amp; fast.next) &#123;\n      fast &#x3D; fast.next.next\n      &#x2F;&#x2F; 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\n      &#x2F;&#x2F;               fast\n      &#x2F;&#x2F;               slow\n      slow &#x3D; slow.next\n      &#x2F;&#x2F; 如果最终两人相遇了，则有环\n      if(fast &#x3D;&#x3D;&#x3D; slow)&#123;\n        return true\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 如果结束了，说明无环\n    return false\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"爬楼梯【动态规划】\"><a href=\"#爬楼梯【动态规划】\" class=\"headerlink\" title=\"爬楼梯【动态规划】\"></a>爬楼梯【动态规划】</h3><p><a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408\" target=\"_blank\" >百度百科-动态规划</a></p>\n<p><strong>多阶段决策问题</strong></p>\n<ol>\n<li>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题</li>\n<li>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果</li>\n</ol>\n<p><strong>动态规划问题中的术语</strong></p>\n<p><code>阶段</code>：</p>\n<pre><code>1. 把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．\n2. 描述阶段的变量称为阶段变量。\n3. 在多数情况下，阶段变量是离散的，用 k 表示。此外，也有阶段变量是连续的情形。\n4. 如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的\n</code></pre>\n<p><code>状态</code>：</p>\n<pre><code>1. 状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。\n2. 在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点\n</code></pre>\n<p><code>决策</code>：</p>\n<pre><code>1. 一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。\n2. 在最优控制中，也称为控制。\n3. 在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。\n4. 描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史\n</code></pre>\n<p><code>最优化原理</code>：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”<br><code>最优性原理</code>：实际上是要求问题的最优策略的子策略也是最优</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。\n\n&#x2F;&#x2F; 在循环的过程中，不断替换其中的值， 最后的结果，就是所有的方法数\nfunction minCost(cost) &#123;\n  &#x2F;&#x2F; 定义一个变量\n  let len &#x3D; cost.length;\n  &#x2F;&#x2F; 定义两个变量\n  let dp &#x3D; [cost[0], cost[1]];\n\n  for (let i &#x3D; 2; i &lt; len; i++) &#123;\n    &#x2F;&#x2F; 0&#x2F;1 下标数组， 偶数 &amp; 1 &#x3D; 0， 奇数 &amp; 1 &#x3D;1\n    dp[i &amp; 1] &#x3D; Math.min(dp[0], dp[1]) + cost[i];\n    console.log(&#96;dp[$&#123;i &amp; 1&#125;]&#96;, i, dp[i &amp; 1], dp);\n  &#125;\n\n  &#x2F;&#x2F; 循环结束后\n  return Math.min(dp[0], dp[1]);\n&#125;\n\nvar a &#x3D; minCost([1, 2, 3, 4, 5]);\n\nconsole.log(&#39;a&#39;, a);\n\n&#x2F;&#x2F; 作者：前端小魔女\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7206912311562174523\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F; 这段代码实现了一个寻找最小花费的算法。算法基于动态规划的思想，采用了滚动数组的方式进行优化以降低空间复杂度。\n\n&#x2F;&#x2F; 以下是代码的解释：\n\n&#x2F;&#x2F; 1. &#96;cost&#96; 是一个包含每个位置的花费的数组。\n&#x2F;&#x2F; 2. &#96;len&#96; 是 &#96;cost&#96; 数组的长度。\n&#x2F;&#x2F; 3. &#96;dp&#96; 是一个长度为 2 的数组，用于存储当前位置的最小花费。&#96;dp[0]&#96; 表示偶数位置的最小花费，&#96;dp[1]&#96; 表示奇数位置的最小花费。\n&#x2F;&#x2F; 4. 循环遍历 &#96;cost&#96; 数组，从第 2 个位置（索引 1）开始。在每次迭代中，计算当前位置的最小花费并存储在 &#96;dp[i &amp; 1]&#96; 中。\n&#x2F;&#x2F; 5. &#96;dp[i &amp; 1]&#96; 是使用位运算来切换 &#96;dp&#96; 数组的偶数位置和奇数位置，这样可以实现滚动数组的优化。每次迭代，都只需要维护两个位置的最小花费，而不需要保存全部位置的最小花费。\n&#x2F;&#x2F; 6. 返回 &#96;dp[0]&#96; 和 &#96;dp[1]&#96; 中的较小值作为最终结果。\n\n&#x2F;&#x2F; 代码中的 &#96;minCost&#96; 函数可以找到在不相邻位置花费最小的路径。对于输入 &#96;[1, 2, 3, 4, 5]&#96;，该函数将返回 6，表示最小花费为 6，即从第 1 个位置花费 1，跳过第 2 个位置，到达第 3 个位置花费 3，跳过第 4 个位置，到达第 5 个位置花费 2。</code></pre>\n\n<h3 id=\"什么是时间复杂度-amp-计算\"><a href=\"#什么是时间复杂度-amp-计算\" class=\"headerlink\" title=\"什么是时间复杂度&amp;计算\"></a>什么是时间复杂度&amp;计算</h3><h3 id=\"什么是空间复杂度-amp-计算\"><a href=\"#什么是空间复杂度-amp-计算\" class=\"headerlink\" title=\"什么是空间复杂度&amp;计算\"></a>什么是空间复杂度&amp;计算</h3><h3 id=\"删除单向链表中的某个节点\"><a href=\"#删除单向链表中的某个节点\" class=\"headerlink\" title=\"删除单向链表中的某个节点\"></a>删除单向链表中的某个节点</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员\n    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员\n  &#125;\n&#125;\n&#x2F;&#x2F; 定义一个单向链表类\nclass singleLinked &#123;\n  constructor() &#123;\n    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数\n    this.head &#x3D; new Node(&#39;head&#39;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址\n    this.currentNode &#x3D; &#39;&#39;;\n  &#125;\n  &#x2F;&#x2F; 删除一个节点\n  deleteNode(element) &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    if (currentNode.next) &#123;\n      &#x2F;&#x2F; 将链的节点与另一个节点连上\n      currentNode.next &#x3D; currentNode.next.next;\n      this.size--;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"数组中找数之和\"><a href=\"#数组中找数之和\" class=\"headerlink\" title=\"数组中找数之和\"></a>数组中找数之和</h3><h4 id=\"排序数组中的两个数字之和的下标\"><a href=\"#排序数组中的两个数字之和的下标\" class=\"headerlink\" title=\"排序数组中的两个数字之和的下标\"></a>排序数组中的两个数字之和的下标</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 输入一个递增排序的数组和一个值target,在数组中找出两个和为target的数字并返回它们的下标\n&#x2F;&#x2F; 提示：\n&#x2F;&#x2F; 数组中有且只有一对符合要求\n&#x2F;&#x2F; 同时一个数字不能使用两次\n\n&#x2F;&#x2F; 示例：输入数组： [1,2,4,6,10],k的值为8 输出[1,3]\n\nfunction twoSum4SortedArray(nums, target) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  let left &#x3D; 0, right &#x3D; nums.length - 1; &#x2F;&#x2F; 初始化指针left,right\n  while (left &lt; right &amp;&amp; nums[left] + nums[right] !&#x3D; target) &#123;\n    if (nums[left] + nums[right] &lt; target) &#123;\n      left++;\n    &#125; else &#123;\n      right--;\n    &#125;\n  &#125;\n  return [left, right];\n&#125;</code></pre>\n\n<h4 id=\"非排序数组找两数之和\"><a href=\"#非排序数组找两数之和\" class=\"headerlink\" title=\"非排序数组找两数之和\"></a>非排序数组找两数之和</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function twoSum(nums, target) &#123;\n  let map &#x3D; new Map(); &#x2F;&#x2F; 用于，存储[nums[i],i]之间的关系\n  for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;\n    let expectValue &#x3D; target - nums[i];\n    &#x2F;&#x2F; 先从map中找，是否存在指定值\n    if (map.has(expectValue)) &#123;\n      &#x2F;&#x2F; 如果有，直接返回与值相对于的下标\n      return [map.get(expectValue), i];\n    &#125;\n    &#x2F;&#x2F; 存储[nums[i],i]之间的关系\n    &#x2F;&#x2F; 存 值&#x3D;下标\n    map.set(nums[i], i);\n  &#125;\n  return null;\n&#125;</code></pre>\n\n<h4 id=\"数组中和为-target-的-3-个数字【难搞哦】\"><a href=\"#数组中和为-target-的-3-个数字【难搞哦】\" class=\"headerlink\" title=\"数组中和为 target 的 3 个数字【难搞哦】\"></a>数组中和为 target 的 3 个数字【难搞哦】</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 输入一个数组，找出数组中所有和为target的3个数字的三元组\n&#x2F;&#x2F; 提示：\n&#x2F;&#x2F; 返回值不得包含重复的三元组\n\n&#x2F;&#x2F; 示例：输入数组： [-1,0,1,2,-1,-4],target的值为0 输出[[-1,0,1],[-1,-1,2]]\n\nfunction threeSum(nums, target) &#123;\n  let result &#x3D; [];\n  if (nums.length &lt; 3) return [];\n\n  &#x2F;&#x2F; 人工对数据进行排序处理\n  nums.sort((a, b) &#x3D;&gt; a - b);\n\n  let i &#x3D; 0;\n  while (i &lt; nums.length - 2) &#123;\n    twoSum(nums, i, target, result);\n    let temp &#x3D; nums[i];\n    &#x2F;&#x2F; 剔除，重复元祖中第一个数值\n    while (i &lt; nums.length &amp;&amp; nums[i] &#x3D;&#x3D; temp) i++;\n  &#125;\n  return result;\n&#125;\n\nfunction twoSum(nums, i, target, result) &#123;\n  &#x2F;&#x2F; 初始化指针left,right\n  &#x2F;&#x2F; prettier-ignore\n  let left &#x3D; i + 1, right &#x3D; nums.length - 1;\n\n  while (left &lt; right) &#123;\n    &#x2F;&#x2F; 求和\n    let sum &#x3D; nums[i] + nums[left] + nums[right];\n    &#x2F;&#x2F; 指针移动过程 (if&#x2F;else)\n    if (sum &#x3D;&#x3D;&#x3D; target) &#123;\n      result.push([nums[i], num[left], nums[right]]);\n\n      let temp &#x3D; nums[left];\n      &#x2F;&#x2F; 剔除，重复元祖第二个数值\n      while (nums[left] &#x3D;&#x3D;&#x3D; temp &amp;&amp; left &lt; right) left++;\n    &#125; else if (sum &lt; 0) &#123;\n      left++;\n    &#125; else &#123;\n      right--;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"N-进制加法\"><a href=\"#N-进制加法\" class=\"headerlink\" title=\"N 进制加法\"></a>N 进制加法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 二进制加法\n&#x2F;&#x2F; Nsum(&#39;10&#39;,&#39;01&#39;,2)\n&#x2F;&#x2F; 结果为 11\n&#x2F;&#x2F; 十进制加法(十进制大数相加)\n&#x2F;&#x2F; Nsum(&#39;7&#39;,&#39;8&#39;,10)\n&#x2F;&#x2F; 结果为 15\n\n&#x2F;&#x2F; 原理：\n&#x2F;&#x2F; 1. 从数据尾部开始遍历\n&#x2F;&#x2F; 2. 通过字符串减法，获取对应位置的值\n&#x2F;&#x2F; 3. 对应位置数相加，+ 进位\n&#x2F;&#x2F; 4. 当前位置的值，进位的值\n&#x2F;&#x2F; 循环遍历\n&#x2F;&#x2F; 5. 遍历完成后是否还存在进位\nfunction Nsum(a, b, n) &#123;\n  let result &#x3D; &#39;&#39;; &#x2F;&#x2F; 用来存储结果\n  let i &#x3D; a.length - 1; &#x2F;&#x2F; 是为了倒着遍历\n  let j &#x3D; b.length - 1; &#x2F;&#x2F; 是为了倒着遍历\n  let carry &#x3D; 0; &#x2F;&#x2F; 进位\n\n  while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) &#123;\n    &#x2F;*这个减法有意思，会直接计算出来字符串与字符串的差值后的整数 *&#x2F;\n    let digitA &#x3D; i &gt;&#x3D; 0 ? a[i--] - &#39;0&#39; : 0;\n    let digitB &#x3D; j &gt;&#x3D; 0 ? b[j--] - &#39;0&#39; : 0;\n    let sum &#x3D; digitA + digitB + carry; &#x2F;&#x2F; 对应位数之和 + 进位\n    carry &#x3D; sum &gt;&#x3D; n ? 1 : 0; &#x2F;&#x2F; 是否有进位\n    sum &#x3D; sum &gt;&#x3D; n ? sum - n : sum; &#x2F;&#x2F; 去掉进位后该位置的值\n    result &#x3D; sum + result; &#x2F;&#x2F; 这里也是字符串拼接\n  &#125;\n  &#x2F;&#x2F; 最后是否有进位\n  if (carry) &#123;\n    result &#x3D; &#39;1&#39; + result;\n  &#125;\n  return result;\n&#125;\n\nNsum(&#39;10&#39;, &#39;01&#39;, 2);</code></pre>\n\n<h3 id=\"只出现一次的数字\"><a href=\"#只出现一次的数字\" class=\"headerlink\" title=\"只出现一次的数字\"></a>只出现一次的数字</h3><h4 id=\"某个元素仅出现-一次-外，其余每个元素都恰出现-N-次-看不懂\"><a href=\"#某个元素仅出现-一次-外，其余每个元素都恰出现-N-次-看不懂\" class=\"headerlink\" title=\"某个元素仅出现 一次 外，其余每个元素都恰出现 N 次(看不懂)\"></a>某个元素仅出现 一次 外，其余每个元素都恰出现 N 次(看不懂)</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 出现2次，找出现一次的 singleNumber([1,1,2,2,3],2); 结果为 3\n&#x2F;&#x2F; 出现3次，找出现一次的 singleNumber([1,1,1,2,2,2,3],3) 结果为 3\n&#x2F;&#x2F; 同理其他\nfunction singleNumber(nums, n) &#123;\n  &#x2F;&#x2F; 构建一个用于存储数组所有数字位数之和的数组\n  let bitSums &#x3D; new Array(32).fill(0);\n  for (let num of nums) &#123;\n    for (let i &#x3D; 0; i &lt; 32; i++) &#123;\n      &#x2F;&#x2F; 求num在i位置的位数，并将其与指定位置的位数相加\n      bitSums[i] +&#x3D; (num &gt;&gt; (31 - i)) &amp; 1;\n    &#125;\n  &#125;\n  let result &#x3D; 0;\n  for (let i &#x3D; 0; i &lt; 32; i++) &#123;\n    &#x2F;&#x2F;从最地位(0)位开始遍历\n    result &#x3D; (result &lt;&lt; 1) + (bitSums[i] % n);\n  &#125;\n  return result;\n&#125;</code></pre>\n\n<h4 id=\"某个元素仅出现-一次-外，其余每个元素都恰出现-2-次的另外解法\"><a href=\"#某个元素仅出现-一次-外，其余每个元素都恰出现-2-次的另外解法\" class=\"headerlink\" title=\"某个元素仅出现 一次 外，其余每个元素都恰出现 2 次的另外解法\"></a>某个元素仅出现 一次 外，其余每个元素都恰出现 2 次的另外解法</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function singleNumber(nums) &#123;\n  let result &#x3D; 0;\n  for (let i of nums) &#123;\n    result ^&#x3D; i;\n    console.log(i, result);\n  &#125;\n  return result;\n&#125;\n\nsingleNumber([1, 3, 1, 2, 2], 2);\n\n&#x2F;&#x2F; 过程如下：\n&#x2F;&#x2F; 1 001\n&#x2F;&#x2F; 1 001\n&#x2F;&#x2F; 2 011\n&#x2F;&#x2F; 2 011\n&#x2F;&#x2F; 3 111 -&gt; 111</code></pre>\n\n<h3 id=\"fibonic\"><a href=\"#fibonic\" class=\"headerlink\" title=\"fibonic\"></a>fibonic</h3><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……</p>\n<h4 id=\"常规方式\"><a href=\"#常规方式\" class=\"headerlink\" title=\"常规方式\"></a>常规方式</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function fibonacci(n) &#123;\n  if (n &lt;&#x3D; 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n&#125;\n&#x2F;&#x2F; fibonacci(1000) &#x2F;&#x2F;  浏览器卡死</code></pre>\n\n<h4 id=\"尾调用方式\"><a href=\"#尾调用方式\" class=\"headerlink\" title=\"尾调用方式\"></a>尾调用方式</h4><p>原理： 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 执行顺序\n&#x2F;&#x2F; 将 _next的结果作为fibonacci的值\nfunction fibonacci(n, pre &#x3D; 1, next &#x3D; 1) &#123;\n  if (n &lt;&#x3D; 1) return next;\n  &#x2F;&#x2F; const _pre &#x3D; next; &#x2F;&#x2F; 移动位置\n  &#x2F;&#x2F; const _next &#x3D; next + pre;\n  &#x2F;&#x2F; return fibonacci(n - 1, _pre, _next &#x2F;*值放到这里 *&#x2F;);\n  &#x2F;&#x2F; 上面三行等价于下面一行\n  return fibonacci(n - 1, next, next + pre);\n&#125;\n\nfibonacci(4);\n&#x2F;&#x2F; 执行过程分析\n&#x2F;&#x2F; 4 fibonacci(3, 1, 2)\n&#x2F;&#x2F; 3 fibonacci(2, 2, 3)\n&#x2F;&#x2F; 2 fibonacci(1, 3, 5)\n&#x2F;&#x2F; 1 return 5</code></pre>\n\n<h4 id=\"迭代方式\"><a href=\"#迭代方式\" class=\"headerlink\" title=\"迭代方式\"></a>迭代方式</h4><h3 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h3><h4 id=\"普通递归\"><a href=\"#普通递归\" class=\"headerlink\" title=\"普通递归\"></a>普通递归</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function factorial(n) &#123;\n  if (n &#x3D;&#x3D;&#x3D; 1) return 1;\n  return n * factorial(n - 1);\n&#125;\n\nfactorial(5); &#x2F;&#x2F; 120</code></pre>\n\n<h4 id=\"尾调用递归\"><a href=\"#尾调用递归\" class=\"headerlink\" title=\"尾调用递归\"></a>尾调用递归</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 尾调用是倒着处理的\nfunction factorial(n, total) &#123;\n  if (n &#x3D;&#x3D;&#x3D; 1) return total;\n  return factorial(n - 1, n * total &#x2F;*值放到这里，算法在这里 *&#x2F;); &#x2F;&#x2F; 尾部返回函数\n&#125;\n\nfactorial(5, 1); &#x2F;&#x2F; 120</code></pre>\n\n<h2 id=\"五分钟学习算法\"><a href=\"#五分钟学习算法\" class=\"headerlink\" title=\"五分钟学习算法\"></a>五分钟学习算法</h2><p><a href=\"https://www.jianshu.com/p/d13fcada7c2d\" target=\"_blank\" >链接</a></p>\n<h2 id=\"其他算法\"><a href=\"#其他算法\" class=\"headerlink\" title=\"其他算法\"></a>其他算法</h2><p><a href=\"https://juejin.cn/post/7095201687421321224#heading-0\" target=\"_blank\" >待爬取</a></p>\n<h3 id=\"diffTwoDeps\"><a href=\"#diffTwoDeps\" class=\"headerlink\" title=\"diffTwoDeps\"></a>diffTwoDeps</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const diffTwoDeps &#x3D; (deps1?: DependencyList, deps2?: DependencyList) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;Let&#39;s do a reference equality check on 2 dependency list.\n  &#x2F;&#x2F;If deps1 is defined, we iterate over deps1 and do comparison on each element with equivalent element from deps2\n  &#x2F;&#x2F;As this func is used only in this hook, we assume 2 deps always have same length.\n  return deps1\n    ? &#x2F;&#x2F; 相等的返回-1会被过滤掉\n      deps1.map((_ele, idx) &#x3D;&gt; (!Object.is(deps1[idx], deps2?.[idx]) ? idx : -1)).filter((ele) &#x3D;&gt; ele &gt;&#x3D; 0)\n    : &#x2F;&#x2F; prettier-ignore\n    deps2 ? deps2.map((_ele, idx) &#x3D;&gt; idx) : [];\n&#125;;</code></pre>\n\n<h3 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is\"></a>Object.is</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (!Object.is) &#123;\n  Object.defineProperty(Object, &#39;is&#39;, &#123;\n    value: function (x, y) &#123;\n      &#x2F;&#x2F; SameValue algorithm\n      if (x &#x3D;&#x3D;&#x3D; y) &#123;\n        &#x2F;&#x2F; return true if x and y are not 0, OR\n        &#x2F;&#x2F; if x and y are both 0 of the same sign.\n        &#x2F;&#x2F; This checks for cases 1 and 2 above.\n        &#x2F;&#x2F; 相等的情况，需要处理正负零\n        return x !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;\n      &#125; else &#123;\n        &#x2F;&#x2F; return true if both x AND y evaluate to NaN.\n        &#x2F;&#x2F; The only possibility for a variable to not be strictly equal to itself\n        &#x2F;&#x2F; is when that variable evaluates to NaN (example: Number.NaN, 0&#x2F;0, NaN).\n        &#x2F;&#x2F; This checks for case 3.\n        &#x2F;&#x2F; 不相等，排除NaN\n        return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;\n      &#125;\n    &#125;,\n  &#125;);\n&#125;\n\n&#x2F;&#x2F;</code></pre>\n\n<h3 id=\"三点是否共线\"><a href=\"#三点是否共线\" class=\"headerlink\" title=\"三点是否共线\"></a>三点是否共线</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 三点是否共线可以通过判断斜率来判断：\n&#x2F;&#x2F; 设有 p1,p2,q三点，判断三点是否共线:\n&#x2F;&#x2F; 公式：\n\n&#x2F;&#x2F; k1 &#x3D; (p2.y - p1.y)&#x2F;(p2.x - p1.x)\n\n&#x2F;&#x2F; k2 &#x3D; (q.y - p1.y)&#x2F;(q.x - p1.x)\n\n&#x2F;&#x2F; 如果k1 &#x3D;&#x3D;&#x3D; k2就表示三点共线\n\nfunction isOnLine(p1, p2, q) &#123;\n  return (p2.y - p1.y) &#x2F; (p2.x - p1.x) &#x3D;&#x3D;&#x3D; (q.y - p1.y) &#x2F; (q.x - p1.x);\n  &#x2F;&#x2F; 如果，指定q是否在线段内部，还需要判断q的范围大小\n&#125;</code></pre>\n\n<h2 id=\"实现-DomToJson-方法\"><a href=\"#实现-DomToJson-方法\" class=\"headerlink\" title=\"实现 DomToJson 方法\"></a>实现 DomToJson 方法</h2><p>将 DOM 元素转换为 JSON 格式的函数可以通过递归遍历 DOM 树来实现。以下是一个简单的示例，演示如何将 DOM 元素转换为 JSON 格式：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function domToJson(node) &#123;\n  if (!node) &#123;\n    return null;\n  &#125;\n\n  const result &#x3D; &#123;\n    tagName: node.tagName,\n    attributes: &#123;&#125;,\n    children: [],\n  &#125;;\n\n  &#x2F;&#x2F; 提取元素的属性\n  for (const attr of node.attributes) &#123;\n    result.attributes[attr.name] &#x3D; attr.value;\n  &#125;\n\n  &#x2F;&#x2F; 递归遍历子节点\n  for (const childNode of node.childNodes) &#123;\n    if (childNode.nodeType &#x3D;&#x3D;&#x3D; Node.ELEMENT_NODE) &#123;\n      result.children.push(domToJson(childNode));\n    &#125; else if (childNode.nodeType &#x3D;&#x3D;&#x3D; Node.TEXT_NODE) &#123;\n      &#x2F;&#x2F; 对于文本节点，直接添加文本内容\n      result.children.push(childNode.nodeValue);\n    &#125;\n    &#x2F;&#x2F; 可以根据需要处理其他类型的节点\n  &#125;\n\n  return result;\n&#125;\n\n&#x2F;&#x2F; 示例使用\nconst element &#x3D; document.getElementById(&#39;example&#39;); &#x2F;&#x2F; 假设有一个 ID 为 &quot;example&quot; 的 DOM 元素\nconst json &#x3D; domToJson(element);\nconsole.log(json);</code></pre>\n\n<p>在这个示例中，我们定义了一个 <code>domToJson</code> 函数，它将一个 DOM 元素作为输入参数，并返回一个 JSON 格式的对象表示该元素及其子元素的结构。我们遍历 DOM 元素的属性和子节点，并将其信息存储在 JSON 对象中。注意，这个示例只是一个简单的演示，实际中可能需要根据具体的需求对 DOM 的不同属性和节点类型进行更复杂的处理。</p>\n<h2 id=\"洗牌算法（实现-JS-乱序算法）\"><a href=\"#洗牌算法（实现-JS-乱序算法）\" class=\"headerlink\" title=\"洗牌算法（实现 JS 乱序算法）\"></a>洗牌算法（实现 JS 乱序算法）</h2><p>从数组末尾开始，每次随机选择一个索引位置（包括当前位置在内）并将其与当前位置的元素交换，然后递减索引，重复这个过程直到数组被完全乱序</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function shuffleArray(array) &#123;\n  const newArray &#x3D; [...array];\n  for (let i &#x3D; newArray.length - 1; i &gt; 0; i--) &#123;\n    const j &#x3D; Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] &#x3D; [newArray[j], newArray[i]]; &#x2F;&#x2F; 交换位置\n  &#125;\n  return newArray;\n&#125;\n\n&#x2F;&#x2F; 示例使用\nconst originalArray &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst shuffledArray &#x3D; shuffleArray(originalArray);\nconsole.log(shuffledArray);</code></pre>\n\n<h2 id=\"交叉排序算法\"><a href=\"#交叉排序算法\" class=\"headerlink\" title=\"交叉排序算法\"></a>交叉排序算法</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">export function crossSort(arr: any[], key) &#123;\n  &#x2F;&#x2F; 首先对原始数组进行排序\n  arr.sort((a, b) &#x3D;&gt; a[key] - b[key]);\n\n  &#x2F;&#x2F; 创建一个新数组来存储交叉排序后的结果\n  const result: any[] &#x3D; [];\n\n  &#x2F;&#x2F; 使用两个指针，一个从数组头部开始，另一个从数组尾部开始\n  let left &#x3D; 0;\n  let right &#x3D; arr.length - 1;\n\n  while (left &lt;&#x3D; right) &#123;\n    &#x2F;&#x2F; 先将最大值添加到结果数组中\n    result.push(arr[right]);\n\n    &#x2F;&#x2F; 如果左指针等于右指针，说明数组元素为奇数个，直接退出循环\n    if (left &#x3D;&#x3D;&#x3D; right) break;\n\n    &#x2F;&#x2F; 再将最小值添加到结果数组中\n    result.push(arr[left]);\n\n    &#x2F;&#x2F; 更新指针位置\n    left++;\n    right--;\n  &#125;\n\n  return result;\n&#125;</code></pre>\n\n<div style=\"display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;\">\n<img src=\"http://t-blog-images.aijs.top/img/202308062327484.webp\" style=\"width:400px;max-width:100%\"/>\n\n<img src=\"http://t-blog-images.aijs.top/img/202308062328295.webp\" style=\"width:400px;max-width:100%\"/>\n\n</div>\n\n<h2 id=\"实现-lazyMan-方法\"><a href=\"#实现-lazyMan-方法\" class=\"headerlink\" title=\"实现 lazyMan 方法\"></a>实现 lazyMan 方法</h2><p>“LazyMan” 方法可以用于实现链式调用的延迟执行。下面是一个简单的示例，演示了如何实现一个 <code>LazyMan</code> 类来支持链式调用，并在指定时间后输出相关内容：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class LazyMan &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n    this.tasks &#x3D; [];\n    console.log(&#96;Hi, I&#39;m $&#123;this.name&#125;&#96;);\n    &#x2F;&#x2F; 使用 setTimeout 将执行放入任务队列中\n    setTimeout(() &#x3D;&gt; &#123;\n      this.next();\n    &#125;, 0);\n  &#125;\n\n  eat(food) &#123;\n    this.tasks.push(() &#x3D;&gt; &#123;\n      console.log(&#96;Eat $&#123;food&#125;&#96;);\n      this.next();\n    &#125;);\n    return this;\n  &#125;\n\n  sleep(time) &#123;\n    this.tasks.push(() &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        console.log(&#96;Wake up after $&#123;time&#125; seconds&#96;);\n        this.next();\n      &#125;, time * 1000);\n    &#125;);\n    return this;\n  &#125;\n\n  sleepFirst(time) &#123;\n    this.tasks.unshift(() &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        console.log(&#96;Wake up after $&#123;time&#125; seconds&#96;);\n        this.next();\n      &#125;, time * 1000);\n    &#125;);\n    return this;\n  &#125;\n\n  next() &#123;\n    const task &#x3D; this.tasks.shift();\n    if (task) &#123;\n      task();\n    &#125;\n  &#125;\n&#125;\n\nfunction lazyMan(name) &#123;\n  return new LazyMan(name);\n&#125;\n\n&#x2F;&#x2F; 示例使用\nlazyMan(&#39;John&#39;).eat(&#39;breakfast&#39;).sleep(3).eat(&#39;lunch&#39;).sleepFirst(5).eat(&#39;dinner&#39;);</code></pre>\n\n<p>在这个示例中，我们定义了一个 <code>LazyMan</code> 类，它具有 <code>eat</code>、<code>sleep</code> 和 <code>sleepFirst</code> 等方法，这些方法将相关操作添加到任务队列中，通过 <code>next</code> 方法依次执行这些任务。使用 <code>setTimeout</code> 来模拟延迟执行。我们还定义了一个 <code>lazyMan</code> 函数，用于创建 <code>LazyMan</code> 类的实例。</p>\n<p>示例中展示了链式调用的使用，可以按照指定的顺序执行吃饭和睡觉的操作，并在指定的时间后执行相应的操作。这个示例只是一个简单的演示，实际中可以根据需求进行扩展和优化。</p>\n<h2 id=\"实现-setTimeout-模拟-setInterval-方法\"><a href=\"#实现-setTimeout-模拟-setInterval-方法\" class=\"headerlink\" title=\"实现 setTimeout 模拟 setInterval 方法\"></a>实现 setTimeout 模拟 setInterval 方法</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; setTimeout  超时调用；在多少时间 在执行；\n&#x2F;&#x2F; setinterval 每隔多少时间  就调用\n&#x2F;&#x2F; 例如：\n&#x2F;&#x2F;     setTimeout这个的值是1000，也就是说在页面刷新后，1000毫秒之后才调用这个函数体内的东西\n&#x2F;&#x2F;              setTimeout有一个最低的时间限制，400s\n&#x2F;&#x2F;     setinterval的值是1000的话，就是每过1000毫秒执行一次\n\n&#x2F;&#x2F; 1 为什么要模拟 ？ 2 然后模拟是解决了什么  ？\n&#x2F;&#x2F; 3.setinterval  有两个缺点：\n&#x2F;&#x2F;    1、setInterval无视网络延迟，只要达到时间，就会进行下一次调用。\n&#x2F;&#x2F;      假设我们在请求一个http接口，在上一次还未返回结果的情况下，继续发起请求，很有可能的结果就是一次性得到多次同样的结果。\n&#x2F;&#x2F;          当http接口都报错的时候，可能同时出现多次错误提示。或者多次页面刷新的状况。\n&#x2F;&#x2F;      假设每100毫秒执行一次，若上次执行只花了5ms，则下次执行会在95ms以后。时间并不准确。\n&#x2F;&#x2F;    3、即使setInterval调用的方法报错了，他仍然会继续执行。\n\n&#x2F;&#x2F; 定时间隔执行\nconst myInterval &#x3D; function (fn, t) &#123;\n  const obj &#x3D; &#123;\n    timmer: null,\n  &#125;;\n\n  (function inner() &#123;\n    fn();\n    &#x2F;&#x2F;  循环执行\n    obj.timmer &#x3D; setTimeout(inner, t);\n  &#125;)();\n\n  return obj;\n&#125;;\n&#x2F;&#x2F; 清空定时执行\nconst clearMyInterval &#x3D; function (obj) &#123;\n  clearTimeout(obj.timmer);\n&#125;;\n\n&#x2F;&#x2F; 使用示例\nlet tt &#x3D; myInterval(() &#x3D;&gt; &#123;\n  console.log(1);\n&#125;, 1000);\n&#x2F;&#x2F; 清空示例\nsetTimeout(() &#x3D;&gt; &#123;\n  clearMyInterval(tt);\n&#125;, 3000);</code></pre>\n\n<h2 id=\"实现简版图片懒加载\"><a href=\"#实现简版图片懒加载\" class=\"headerlink\" title=\"实现简版图片懒加载\"></a>实现简版图片懒加载</h2><p>图片懒加载是一种优化页面性能的常见方式。以下是一个简单的图片懒加载实现，基于 Intersection Observer API：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- HTML 示例，需要设置图片的 data-src 属性为真实图片 URL --&gt;\n&lt;img data-src&#x3D;&quot;path-to-your-image.jpg&quot; alt&#x3D;&quot;Lazy loaded image&quot; class&#x3D;&quot;lazy-load-image&quot; &#x2F;&gt;\n&lt;!-- ... more content ... --&gt;\n\n&lt;script&gt;\n  &#x2F;&#x2F; JavaScript 部分\n  document.addEventListener(&#39;DOMContentLoaded&#39;, function () &#123;\n    const lazyLoadImages &#x3D; document.querySelectorAll(&#39;.lazy-load-image&#39;);\n\n    const observer &#x3D; new IntersectionObserver(function (entries, observer) &#123;\n      entries.forEach(function (entry) &#123;\n        &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;IntersectionObserverEntry&#x2F;isIntersecting\n        if (entry.isIntersecting) &#123;\n          const img &#x3D; entry.target;\n          const src &#x3D; img.getAttribute(&#39;data-src&#39;);\n          if (src) &#123;\n            img.src &#x3D; src;\n            img.removeAttribute(&#39;data-src&#39;);\n            observer.unobserve(img);\n          &#125;\n        &#125;\n      &#125;);\n    &#125;);\n\n    lazyLoadImages.forEach(function (img) &#123;\n      observer.observe(img);\n    &#125;);\n  &#125;);\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>这个代码片段假定你的图片元素有一个 <code>data-src</code> 属性，用于存放真实的图片 URL。当图片元素进入视口时，它的 <code>src</code> 属性将被设置为 <code>data-src</code> 中的值。这样可以延迟加载图片，提高页面加载速度，只有用户真正滚动到图片位置时才会加载图片。</p>\n<p>你可以将上面的 HTML 和 JavaScript 代码嵌入到你的页面中，以实现简单的图片懒加载。请确保替换 <code>data-src</code> 属性的值为你的图片的真实路径。如果你想要更高级的懒加载功能，可以考虑使用现有的前端库，如 <code>lazysizes</code> 或 <code>lozad.js</code>。这些库提供了更丰富的功能和配置选项。</p>\n<h2 id=\"实现深度对比-isEqual-方法\"><a href=\"#实现深度对比-isEqual-方法\" class=\"headerlink\" title=\"实现深度对比 isEqual 方法\"></a>实现深度对比 isEqual 方法</h2><p>实现一个深度对比的 <code>isEqual</code> 方法可以使用递归来比较两个对象的所有属性和值。下面是一个简单的实现，可以比较对象和嵌套的对象，支持对象、数组、基本类型的深度对比：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function isEqual(a, b) &#123;\n  if (a &#x3D;&#x3D;&#x3D; b) &#123;\n    return true;\n  &#125;\n  &#x2F;&#x2F; 1. typeof a !&#x3D;&#x3D; typeof b: 这个条件判断了 a 和 b 的类型是否相同。如果它们的类型不同，那么它们不可能相等，直接返回 false。\n  &#x2F;&#x2F; 2. typeof a !&#x3D;&#x3D; &#39;object&#39; || a &#x3D;&#x3D;&#x3D; null || b &#x3D;&#x3D;&#x3D; null: 这个条件判断了 a 和 b 是否都是对象类型。如果其中任何一个不是对象类型，或者其中有一个为 null，那么它们不可能相等，直接返回 false\n  if (typeof a !&#x3D;&#x3D; typeof b || typeof a !&#x3D;&#x3D; &#39;object&#39; || a &#x3D;&#x3D;&#x3D; null || b &#x3D;&#x3D;&#x3D; null) &#123;\n    return false;\n  &#125;\n\n  if (Array.isArray(a) !&#x3D;&#x3D; Array.isArray(b)) &#123;\n    return false;\n  &#125;\n\n  if (Object.keys(a).length !&#x3D;&#x3D; Object.keys(b).length) &#123;\n    return false;\n  &#125;\n\n  for (let key in a) &#123;\n    if (!isEqual(a[key], b[key])) &#123;\n      return false;\n    &#125;\n  &#125;\n\n  return true;\n&#125;\n\n&#x2F;&#x2F; 示例使用\nconst obj1 &#x3D; &#123; a: 1, b: &#123; c: 2 &#125;, d: [3, 4] &#125;;\nconst obj2 &#x3D; &#123; a: 1, b: &#123; c: 2 &#125;, d: [3, 4] &#125;;\nconst obj3 &#x3D; &#123; a: 1, b: &#123; c: 3 &#125;, d: [3, 4] &#125;;\n\nconsole.log(isEqual(obj1, obj2)); &#x2F;&#x2F; 输出 true，obj1 与 obj2 深度相等\nconsole.log(isEqual(obj1, obj3)); &#x2F;&#x2F; 输出 false，obj1 与 obj3 深度不相等</code></pre>\n\n<p>这个 <code>isEqual</code> 方法会递归地比较两个对象及其属性，对于数组和嵌套对象也会进行深度对比。请注意，这个实现并没有考虑循环引用的情况，如果要处理循环引用，还需要添加额外的逻辑。此外，该方法不考虑对象的原型链上的属性。如果需要考虑这些特殊情况，还需要进一步完善。</p>\n<h2 id=\"实现-Object-freeze-方法\"><a href=\"#实现-Object-freeze-方法\" class=\"headerlink\" title=\"实现 Object.freeze 方法\"></a>实现 Object.freeze 方法</h2><p><code>Object.freeze()</code> 方法用于冻结一个对象，防止对象被修改。冻结后的对象属性不能被添加、删除或修改。下面是一个简单的 <code>Object.freeze()</code> 方法的实现：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function freezeObject(obj) &#123;\n  if (obj &#x3D;&#x3D;&#x3D; null || typeof obj !&#x3D;&#x3D; &#39;object&#39;) &#123;\n    return obj;\n  &#125;\n\n  &#x2F;&#x2F; 遍历对象的属性\n  Object.keys(obj).forEach((key) &#x3D;&gt; &#123;\n    obj[key] &#x3D; freezeObject(obj[key]); &#x2F;&#x2F; 递归冻结属性值\n  &#125;);\n\n  return Object.freeze(obj);\n&#125;\n\n&#x2F;&#x2F; 示例使用\nconst obj &#x3D; &#123;\n  a: 1,\n  b: &#123; c: 2 &#125;,\n  d: [3, 4],\n&#125;;\n\nconst frozenObj &#x3D; freezeObject(obj);\n\nfrozenObj.a &#x3D; 5; &#x2F;&#x2F; 不会改变，仍然是1\nfrozenObj.b.c &#x3D; 6; &#x2F;&#x2F; 不会改变，仍然是2\nfrozenObj.d.push(5); &#x2F;&#x2F; 不会改变，数组不会新增元素\n\nconsole.log(frozenObj); &#x2F;&#x2F; 输出原始对象</code></pre>\n\n<p>这个 <code>freezeObject</code> 方法实现了递归冻结一个对象及其属性，保证对象及其嵌套属性都被冻结。需要注意的是，<code>Object.freeze()</code> 方法只能冻结对象本身的属性，对于嵌套的对象属性，需要递归冻结。<strong>此外，原始对象不会被修改，<code>freezeObject</code> 方法返回一个新的冻结对象</strong>。实现 Object.freeze 方法</p>\n<h2 id=\"实现对象数组去重\"><a href=\"#实现对象数组去重\" class=\"headerlink\" title=\"实现对象数组去重\"></a>实现对象数组去重</h2><p>你可以使用 <code>Set</code> 数据结构来实现对象数组的去重。<code>Set</code> 是 ES6 中引入的数据结构，它可以存储唯一的值，适合用来去除重复元素。不过需要注意的是，<code>Set</code> 默认是使用 “SameValueZero” 算法来比较元素的唯一性，这对基本数据类型来说是可以的，但对于对象则会比较引用，而不是内容。如果要对对象数组进行去重，需要自定义比较的规则。</p>\n<p>下面是一个基于 <code>Set</code> 的对象数组去重方法，它支持自定义比较规则：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function distinctBy(arr, keyFn) &#123;\n  const set &#x3D; new Set();\n  return arr.filter((item) &#x3D;&gt; &#123;\n    const key &#x3D; keyFn(item);\n    if (set.has(key)) &#123;\n      return false;\n    &#125;\n    set.add(key);\n    return true;\n  &#125;);\n&#125;\n\n&#x2F;&#x2F; 示例使用\nconst users &#x3D; [\n  &#123; id: 1, name: &#39;Alice&#39; &#125;,\n  &#123; id: 2, name: &#39;Bob&#39; &#125;,\n  &#123; id: 1, name: &#39;Alice&#39; &#125;, &#x2F;&#x2F; 重复项\n  &#123; id: 3, name: &#39;Charlie&#39; &#125;,\n];\n\nconst distinctUsers &#x3D; distinctBy(users, (user) &#x3D;&gt; user.id);\n\nconsole.log(distinctUsers);</code></pre>\n\n<p>在这个例子中，<code>distinctBy</code> 函数接受一个对象数组 <code>arr</code> 和一个函数 <code>keyFn</code>，<code>keyFn</code> 用于生成每个对象的键值，比较时以这个键值为准。这样可以根据自定义的规则来判断对象是否重复。请注意，这个方法返回一个新的数组，原始数组不会被修改。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://www.cnblogs.com/pangqianjin/p/14998643.html\" target=\"_blank\" >JavaScript 手写几种常见的排序算法：冒泡、选择、插入、希尔、归并、快排</a></li>\n<li><a href=\"https://blog.csdn.net/qq_44433261/article/details/117235740\" target=\"_blank\" >排序动画</a></li>\n<li><a href=\"https://wenku.baidu.com/view/7f84552a6f85ec3a87c24028915f804d2b16878c.html\" target=\"_blank\" >分治思想——精选推荐</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B3%95/9763353?fr=aladdin\" target=\"_blank\" >归并排序法 百度百科</a></li>\n<li><a href=\"https://blog.csdn.net/Sherlook_Holmes/article/details/120584469\" target=\"_blank\" >（含动画演示）搞懂归并排序 一学就会</a></li>\n<li><a href=\"https://www.jianshu.com/u/c6ad3f2ed2d6\" target=\"_blank\" >五分钟学算法(PPT 做的 gif)</a></li>\n<li><a href=\"https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html\" target=\"_blank\" >Promise.resolve（）详解</a></li>\n<li><a href=\"https://juejin.cn/post/7206912311562174523#heading-79\" target=\"_blank\" >22023 面试真题之手写&amp;代码运行篇</a></li>\n<li><a href=\"/#/post/2023-03-062023js\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2023-03-062023js</a></li>\n<li><a href=\"/#/post/2023-03-07按位操作\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2023-03-07 按位操作</a></li>\n<li><a href=\"/#/post/2023-03-09defineProperty\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2023-03-09defineProperty</a></li>\n</ol>\n","text":"实现单例通过构造函数class Singleton &#123; constructor() &#123; console.log(&#39;this&#39;, this); if (!Singleton.instance) &#123; &#x2F;&#x2F; 将 this...","link":"","photos":[],"count_time":{"symbolsCount":"111k","symbolsTime":"1:41"},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B\"><span class=\"toc-text\">实现单例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">通过构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">字符串相关</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-JSON-parse\"><span class=\"toc-text\">实现 JSON.parse</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-JSON-stringify-%E8%80%83%E5%AF%9F%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%80%92%E5%BD%92\"><span class=\"toc-text\">实现 JSON.stringify (考察，有哪些基本数据类型，递归)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">深度操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">深拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#structuredClone\"><span class=\"toc-text\">structuredClone</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86\"><span class=\"toc-text\">深度克隆</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">深比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%B7%AE%E5%BC%82%E5%8C%96\"><span class=\"toc-text\">深度获取差异化</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#uuid\"><span class=\"toc-text\">uuid</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E5%90%8E%E9%98%B2%E6%8A%96\"><span class=\"toc-text\">操作后防抖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%90%8E%E9%98%B2%E6%8A%96\"><span class=\"toc-text\">执行一次后防抖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E6%B5%81\"><span class=\"toc-text\">节流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">接口数据缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-JS-%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BF%86\"><span class=\"toc-text\">实现 JS 函数记忆</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this-%E6%8C%87%E5%90%91\"><span class=\"toc-text\">this 指向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#apply\"><span class=\"toc-text\">apply</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bind\"><span class=\"toc-text\">bind</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise\"><span class=\"toc-text\">Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-sleep-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">实现 sleep 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%86%99-promise\"><span class=\"toc-text\">手写 promise</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-all\"><span class=\"toc-text\">Promise.all</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-race\"><span class=\"toc-text\">Promise.race</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-allSettle\"><span class=\"toc-text\">Promise.allSettle</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-any\"><span class=\"toc-text\">Promise.any</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-finally\"><span class=\"toc-text\">Promise.finally</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-resolve\"><span class=\"toc-text\">Promise.resolve</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%BB%E6%96%AD-resolve-x2F-reject-%E5%90%8E%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">阻断 resolve&#x2F;reject 后面代码还会执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F\"><span class=\"toc-text\">限制并发数量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PromiseQueue\"><span class=\"toc-text\">PromiseQueue</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-await-%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">async await 原理实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C\"><span class=\"toc-text\">实现异步串行和异步并行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D\"><span class=\"toc-text\">数组去重</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E5%A5%87%E6%95%B0%E6%8E%92%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%8C%E5%81%B6%E6%95%B0%E6%8E%92%E5%9C%A8%E5%90%8E%E9%9D%A2\"><span class=\"toc-text\">将奇数排在前面，偶数排在后面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数组转树结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86\"><span class=\"toc-text\">地址数据处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">如何找到数组中出现次数最多的字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96\"><span class=\"toc-text\">数组扁平化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E5%AE%9A%E5%B1%95%E5%BC%80-N-%E5%B1%82\"><span class=\"toc-text\">指定展开 N 层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-getValue-%E5%92%8C-setValue-%E6%9D%A5%E8%8E%B7%E5%8F%96-x2F-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E5%BA%94-path-%E7%9A%84%E5%80%BC\"><span class=\"toc-text\">实现 getValue 和 setValue 来获取&#x2F;设置对应 path 的值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%8C%89%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%8B%86%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%88lodash-chunk-%E6%96%B9%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">实现按指定长度拆分数组（lodash.chunk 方法）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86\"><span class=\"toc-text\">实现方法求两个数组的交集</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E6%89%81%E5%B9%B3%E5%8C%96\"><span class=\"toc-text\">对象扁平化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%88%99\"><span class=\"toc-text\">正则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%90-URL-%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E9%83%A8%E5%88%86\"><span class=\"toc-text\">解析 URL 中所有的部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%88%92%E7%BA%BF%E8%BD%AC%E5%A4%A7%E5%86%99\"><span class=\"toc-text\">中划线转大写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%91%E9%A2%9D%E5%8D%83%E5%88%86\"><span class=\"toc-text\">金额千分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Intl-NumberFormat\"><span class=\"toc-text\">Intl.NumberFormat</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">原理实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new\"><span class=\"toc-text\">new</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create\"><span class=\"toc-text\">Object.create</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#instanceof\"><span class=\"toc-text\">instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JSONP\"><span class=\"toc-text\">JSONP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-event-bus\"><span class=\"toc-text\">实现 event bus</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#event-bus-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">event bus 为什么可以进行通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85\"><span class=\"toc-text\">实现发布订阅</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-defineProperties-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Object.defineProperties 实现原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-JS-%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">实现 JS 的继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">原型链继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">构造函数继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">组合继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E7%B1%BB%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">ES6 类继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Child-prototype-x3D-new-Parent-Child-prototype-constructor-x3D-Child-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">Child.prototype &#x3D; new Parent(); Child.prototype.constructor &#x3D; Child; 什么意思</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%99%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">这几种继承的优缺点，及使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-ES6-%E7%9A%84-extends-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">实现 ES6 的 extends 运算符功能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">柯里化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">柯里化是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">实现柯里化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">洋葱模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86-x2F-%E5%8A%AB%E6%8C%81\"><span class=\"toc-text\">数据代理&#x2F;劫持</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#proxy\"><span class=\"toc-text\">proxy</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#defineProperty\"><span class=\"toc-text\">defineProperty</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true\"><span class=\"toc-text\">(a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">实现双向绑定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-Vue-%E7%9A%84-reactive-%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">实现 Vue 的 reactive 功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-const-%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">实现 const 运算符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E5%90%91-vs-%E5%8F%8C%E5%90%91\"><span class=\"toc-text\">单向 vs 双向</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%8A%E4%B8%8D%E6%98%AF%E7%8E%AF%E3%80%8B\"><span class=\"toc-text\">双向链表《不是环》</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC\"><span class=\"toc-text\">链表反转</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF\"><span class=\"toc-text\">链表有环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%82%B9\"><span class=\"toc-text\">链表中点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">链表中环的入口节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4\"><span class=\"toc-text\">判断链表是否相交</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E5%A0%86\"><span class=\"toc-text\">最小堆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">堆打印</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">选择排序时间复杂度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">插入排序时间复杂度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">实现管理本地缓存过期的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F\"><span class=\"toc-text\">闭包缓存过期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LRU-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">LRU 算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#leecode\"><span class=\"toc-text\">leecode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">红包算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">括号匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">螺旋矩阵</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0\"><span class=\"toc-text\">大数相加</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%BE%E5%87%BA%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D\"><span class=\"toc-text\">找出出现次数最多的英语单词</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9%E5%80%92%E5%BA%8F%EF%BC%88%E5%B0%86-ul-id-x3D-list%EF%BC%8C%E5%B0%86-ul-%E8%8A%82%E7%82%B9%E4%B8%8B%E7%9A%84-10000-%E4%B8%AA-li-%E8%8A%82%E7%82%B9%E5%80%92%E5%BA%8F%E3%80%82%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E3%80%82%EF%BC%89%E3%80%90%E5%BE%85%E5%A4%84%E7%90%86%E3%80%91\"><span class=\"toc-text\">节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97-%E2%80%9C1-12-31-100-93%E2%80%9D%E3%80%90%E5%BE%85%E5%A4%84%E7%90%86%E3%80%91\"><span class=\"toc-text\">实现一个函数计算 “1+12-31+100-93”【待处理】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF\"><span class=\"toc-text\">判断链表是否有环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%AC%E6%A5%BC%E6%A2%AF%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91\"><span class=\"toc-text\">爬楼梯【动态规划】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-amp-%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">什么是时间复杂度&amp;计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-amp-%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">什么是空间复杂度&amp;计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">删除单向链表中的某个节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">数组中找数之和</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E7%9A%84%E4%B8%8B%E6%A0%87\"><span class=\"toc-text\">排序数组中的两个数字之和的下标</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E6%89%BE%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">非排序数组找两数之和</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA-target-%E7%9A%84-3-%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%90%E9%9A%BE%E6%90%9E%E5%93%A6%E3%80%91\"><span class=\"toc-text\">数组中和为 target 的 3 个数字【难搞哦】</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#N-%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95\"><span class=\"toc-text\">N 进制加法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">只出现一次的数字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%85%E5%87%BA%E7%8E%B0-%E4%B8%80%E6%AC%A1-%E5%A4%96%EF%BC%8C%E5%85%B6%E4%BD%99%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%81%B0%E5%87%BA%E7%8E%B0-N-%E6%AC%A1-%E7%9C%8B%E4%B8%8D%E6%87%82\"><span class=\"toc-text\">某个元素仅出现 一次 外，其余每个元素都恰出现 N 次(看不懂)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%85%E5%87%BA%E7%8E%B0-%E4%B8%80%E6%AC%A1-%E5%A4%96%EF%BC%8C%E5%85%B6%E4%BD%99%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%81%B0%E5%87%BA%E7%8E%B0-2-%E6%AC%A1%E7%9A%84%E5%8F%A6%E5%A4%96%E8%A7%A3%E6%B3%95\"><span class=\"toc-text\">某个元素仅出现 一次 外，其余每个元素都恰出现 2 次的另外解法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fibonic\"><span class=\"toc-text\">fibonic</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">常规方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">尾调用方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">迭代方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%B6%E4%B9%98\"><span class=\"toc-text\">阶乘</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E9%80%92%E5%BD%92\"><span class=\"toc-text\">普通递归</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E8%B0%83%E7%94%A8%E9%80%92%E5%BD%92\"><span class=\"toc-text\">尾调用递归</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E5%88%86%E9%92%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">五分钟学习算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">其他算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diffTwoDeps\"><span class=\"toc-text\">diffTwoDeps</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-is\"><span class=\"toc-text\">Object.is</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%82%B9%E6%98%AF%E5%90%A6%E5%85%B1%E7%BA%BF\"><span class=\"toc-text\">三点是否共线</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-DomToJson-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">实现 DomToJson 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%EF%BC%88%E5%AE%9E%E7%8E%B0-JS-%E4%B9%B1%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">洗牌算法（实现 JS 乱序算法）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E5%8F%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">交叉排序算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-lazyMan-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">实现 lazyMan 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-setTimeout-%E6%A8%A1%E6%8B%9F-setInterval-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">实现 setTimeout 模拟 setInterval 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E7%AE%80%E7%89%88%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">实现简版图片懒加载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94-isEqual-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">实现深度对比 isEqual 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-Object-freeze-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">实现 Object.freeze 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D\"><span class=\"toc-text\">实现对象数组去重</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"企业微信文件预览","uid":"74208bc76768a419347d0ad3e15c33b0","slug":"2022-07-05wxfile","date":"2022-07-05T15:16:30.000Z","updated":"2022-09-16T13:54:56.210Z","comments":true,"path":"api/articles/2022-07-05wxfile.json","keywords":null,"cover":[],"text":"企业微信文件预览试错 1: const fileName &#x3D; &quot;xxxxx.jpeg&quot;; &#x2F;&#x2F; 举个例子 downloadAttachment(downloadUrl).then((res) &#x3D;&gt; &#123; v...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/categories/企业微信.json"}],"tags":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/tags/企业微信.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"授权与校验场景「简聊」","uid":"22d71efeaa5b73e832334cf42551f026","slug":"2022-07-01auth","date":"2022-07-01T09:12:26.000Z","updated":"2022-09-16T13:54:56.205Z","comments":true,"path":"api/articles/2022-07-01auth.json","keywords":null,"cover":null,"text":"最简单用变量，模拟数据 session + cookie每个用户对应一个会话 SSO 1 session + redis + cookie 觉得有点奇葩，第二份核心项目遇到 jwt + redis第二份非核心项目遇到 以下是一般公司常用的方式，面试的时候，大家都在唠这个 SSO ...","link":"","photos":[],"count_time":{"symbolsCount":914,"symbolsTime":"1 mins."},"categories":[{"name":"auth","slug":"auth","count":1,"path":"api/categories/auth.json"}],"tags":[{"name":"auth","slug":"auth","count":1,"path":"api/tags/auth.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}