{"title":"前端工程化","uid":"d24ff20ad1a722248c0f6ba78f471b7d","slug":"2023-02-04工程化","date":"2023-02-04T12:29:26.000Z","updated":"2023-07-31T07:55:27.586Z","comments":true,"path":"api/articles/2023-02-04工程化.json","keywords":null,"cover":[],"content":"<h2 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h2><h3 id=\"Babel-的原理是什么\"><a href=\"#Babel-的原理是什么\" class=\"headerlink\" title=\"Babel 的原理是什么?\"></a>Babel 的原理是什么?</h3><p>babel 的转译过程也分为三个阶段，这三步具体是：</p>\n<ol>\n<li><code>解析 Parse</code>: 将代码解析⽣成抽象语法树( 即 AST )，即词法分析与语法分析的过程</li>\n<li><code>转换 Transform</code>: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在 此过程中进⾏<code>添加</code>、<code>更新</code>、<code>移除</code>等操作</li>\n<li><code>⽣成 Generate</code>: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator</li>\n</ol>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><h3 id=\"为什么要用-webpack\"><a href=\"#为什么要用-webpack\" class=\"headerlink\" title=\"为什么要用 webpack\"></a>为什么要用 webpack</h3><p>为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。</p>\n<p>在浏览器中运行 JavaScript 有两种方法。</p>\n<ol>\n<li>第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。</li>\n<li>第二种方式，使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。</li>\n</ol>\n<h3 id=\"模块化发展过程\"><a href=\"#模块化发展过程\" class=\"headerlink\" title=\"模块化发展过程\"></a>模块化发展过程</h3><p>(都是为了实现模块化)</p>\n<ol>\n<li>立即调用函数表达式(IIFE)</li>\n<li>Node.js，JavaScript 模块诞生</li>\n<li>npm + Node.js + modules - 大规模分发模块</li>\n<li>ESM - ECMAScript 模块</li>\n<li>依赖自动收集</li>\n</ol>\n<h4 id=\"立即调用函数表达式-IIFE\"><a href=\"#立即调用函数表达式-IIFE\" class=\"headerlink\" title=\"立即调用函数表达式(IIFE)\"></a>立即调用函数表达式(IIFE)</h4><p><strong>解决的问题</strong></p>\n<ol>\n<li>IIFE 解决大型项目的作用域问题；</li>\n<li>当脚本文件被封装在 IIFE 内部时，你可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。</li>\n<li>IIFE 使用方式产生出 <code>Gulp, Grunt, Browserify</code> 等工具。这些工具称为任务执行器，它们将所有项目文件拼接在一起。</li>\n</ol>\n<p><strong>存在的问题：</strong></p>\n<ol>\n<li>修改一个文件意味着必须重新构建整个文件。</li>\n<li>拼接可以做到很容易地跨文件重用脚本，但是却使构建结果的优化变得更加困难。</li>\n<li>难以判断代码是否实际被使用</li>\n</ol>\n<h4 id=\"Node-js，JavaScript-模块诞生\"><a href=\"#Node-js，JavaScript-模块诞生\" class=\"headerlink\" title=\"Node.js，JavaScript 模块诞生\"></a>Node.js，JavaScript 模块诞生</h4><ol>\n<li>CommonJS 问世并引入了 require 机制，它允许你在当前文件中加载和使用某个模块。</li>\n<li>导入需要的每个模块，这一开箱即用的功能，帮助我们解决了作用域问题。</li>\n</ol>\n<h4 id=\"npm-Node-js-modules-大规模分发模块\"><a href=\"#npm-Node-js-modules-大规模分发模块\" class=\"headerlink\" title=\"npm + Node.js + modules - 大规模分发模块\"></a>npm + Node.js + modules - 大规模分发模块</h4><ol>\n<li>CommonJS 没有浏览器支持。没有 live binding(实时绑定)。循环引用存在问题。同步执行的模块解析加载器速度很慢</li>\n<li>为了使浏览器支持模块，因而产生了 Browserify, RequireJS 和 SystemJS 等打包工具，允许我们编写能够在浏览器中运行的 CommonJS 模块。</li>\n</ol>\n<h4 id=\"ESM-ECMAScript-模块\"><a href=\"#ESM-ECMAScript-模块\" class=\"headerlink\" title=\"ESM - ECMAScript 模块\"></a>ESM - ECMAScript 模块</h4><p>模块正在成为 ECMAScript 标准的官方功能。然而:</p>\n<ol>\n<li><code>浏览器支持不完整</code>，</li>\n<li><code>版本迭代速度也不够快</code>，</li>\n</ol>\n<p>目前还是推荐上面那些早期模块实现</p>\n<h4 id=\"依赖自动收集\"><a href=\"#依赖自动收集\" class=\"headerlink\" title=\"依赖自动收集\"></a>依赖自动收集</h4><ol>\n<li>传统的任务构建工具基于<code> Google 的 Closure 编译器</code>都<code>要求你手动在顶部声明所有的依赖</code>。</li>\n<li>然而像 webpack 一类的打包工具自动构建并基于你所引用或导出的内容推断出依赖的图谱。这个特性与其它的如插件 and 加载器一道让开发者的体验更好。</li>\n</ol>\n<h4 id=\"webpack-1\"><a href=\"#webpack-1\" class=\"headerlink\" title=\"webpack\"></a>webpack</h4><ol>\n<li>可以让我们编写模块，</li>\n<li>可以支持任何模块格式（至少在我们到达 ESM 之前），</li>\n<li>可以同时处理资源和资产</li>\n<li>关心性能和加载时间；</li>\n<li>它始终在改进或添加新功能，例如：异步地加载 chunk 和预取，以便为你的项目和用户提供最佳体验。</li>\n</ol>\n<h2 id=\"rollup、-Parcel\"><a href=\"#rollup、-Parcel\" class=\"headerlink\" title=\"rollup、 Parcel\"></a>rollup、 Parcel</h2><h3 id=\"什么是-webpack\"><a href=\"#什么是-webpack\" class=\"headerlink\" title=\"什么是 webpack\"></a>什么是 webpack</h3><ol>\n<li>webpack 是一个用于现代 JavaScript 应用程序的 <code>静态模块打包工具</code>。</li>\n<li>当 webpack 处理应用程序时，从一个或多个入口点构建一个 <code>依赖图(dependency graph)</code>，</li>\n<li>然后将你项目中所需的<code>每一个模块组合成一个或多个 bundles</code>，它们均为静态资源，用于展示你的内容</li>\n</ol>\n<h3 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h3><ol>\n<li>入口(entry)</li>\n<li>输出(output)</li>\n<li>loader</li>\n<li>插件(plugin)</li>\n<li>模式(mode)</li>\n<li>浏览器兼容性(browser compatibility)</li>\n<li>环境(environment)</li>\n</ol>\n<h3 id=\"什么是入口\"><a href=\"#什么是入口\" class=\"headerlink\" title=\"什么是入口\"></a>什么是入口</h3><ol>\n<li>入口起点(entry point) <code>指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始</code>。</li>\n<li>进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</li>\n<li>默认值是 <code>./src/index.js</code>，但你可以通过在 webpack configuration 中配置 entry 属性，来指定一个（或多个）不同的入口起点</li>\n</ol>\n<h3 id=\"什么是输出-output\"><a href=\"#什么是输出-output\" class=\"headerlink\" title=\"什么是输出(output)\"></a>什么是输出(output)</h3><ol>\n<li>output 属性<code>告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件</code>。</li>\n<li>主要输出文件的<code>默认值是 ./dist/main.js</code>，其他生成文件</li>\n<li>默认放置在 <code>./dist</code> 文件夹中。</li>\n</ol>\n<h3 id=\"什么是-loader\"><a href=\"#什么是-loader\" class=\"headerlink\" title=\"什么是 loader\"></a>什么是 loader</h3><ol>\n<li><code>webpack 只能理解 JavaScript 和 JSON 文件</code>，这是 webpack 开箱可用的自带能力。(这也就决定了，最终打包出来的 bundle 只能是 js 文件，哈～，对于打包为 library 是很容易的事情)</li>\n<li>loader 让 webpack 能够去<code>处理其他类型的文件，并将它们转换为有效模块</code>，以供应用程序使用，以及被添加到依赖图中。</li>\n</ol>\n<p><strong>在 webpack 的配置中，loader 有两个属性：</strong></p>\n<ol>\n<li><code>test 属性</code>，识别出哪些文件会被转换。</li>\n<li><code>use 属性</code>，定义出在进行转换时，应该使用哪个 loader。</li>\n</ol>\n<h3 id=\"什么是插件-plugin\"><a href=\"#什么是插件-plugin\" class=\"headerlink\" title=\"什么是插件(plugin)\"></a>什么是插件(plugin)</h3><ol>\n<li>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。</li>\n<li>插件执行的任务，包括：<code>打包优化</code>，<code>资源管理</code>，<code>注入环境变量</code>。</li>\n<li>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。</li>\n<li>多数插件可以通过选项(option)自定义。</li>\n<li>你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例</li>\n</ol>\n<h3 id=\"核心原理是什么\"><a href=\"#核心原理是什么\" class=\"headerlink\" title=\"核心原理是什么\"></a>核心原理是什么</h3><h3 id=\"webpack-是如何执行的\"><a href=\"#webpack-是如何执行的\" class=\"headerlink\" title=\"webpack 是如何执行的\"></a>webpack 是如何执行的</h3><p>Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程：</p>\n<ol>\n<li><code>初始化参数</code>：从<code>配置⽂件和 Shell 语句中</code>,<code>读取与合并参数</code>，得出最终的参数；</li>\n<li><code>开始编译</code>：⽤上⼀步得到的参数, 初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法, 开始执⾏编译；</li>\n<li><code>确定⼊⼝</code>：根据配置中的 entry 找出所有的⼊⼝⽂件；</li>\n<li><code>编译模块</code>：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；</li>\n<li><code>完成模块编译</code>：在经过第 4 步使⽤ Loader 翻译完所有模块后，<code>得到了每个模块被翻译后的最终内容，以及它们之间的依赖关系</code>；</li>\n<li><code>输出资源</code>：根据⼊⼝和模块之间的依赖关系，<code>组装成⼀个个包含多个模块的 Chunk</code>，<code>再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表</code>，这步是可以修改输出内容的最后机会；</li>\n<li><code>输出完成</code>：在确定好输出内容后，<code>根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统</code>。</li>\n<li>在以上过程中，<code>Webpack 会在特定的时间点⼴播出特定的事件</code>，<code>插件在监听到感兴趣的事件后会执⾏特定的逻辑</code>，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。</li>\n</ol>\n<h3 id=\"常见的-loader-有哪些\"><a href=\"#常见的-loader-有哪些\" class=\"headerlink\" title=\"常见的 loader 有哪些\"></a>常见的 loader 有哪些</h3><h4 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h4><ol>\n<li><code>html-loader</code>：将 HTML 导出为字符串。当编译器需要时，将压缩 HTML 字符串。</li>\n</ol>\n<h4 id=\"资源文件\"><a href=\"#资源文件\" class=\"headerlink\" title=\"资源文件\"></a>资源文件</h4><ol>\n<li><code>file-loader</code>：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件</li>\n<li><code>url-loader</code>：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去</li>\n<li><code>image-loader</code>：加载并且压缩图⽚⽂件</li>\n</ol>\n<h4 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h4><ol>\n<li><code>less-loader</code>：webpack 将 Less 编译为 CSS 的 loader。</li>\n<li><code>sass-loader</code>：webpack 将 Sass 编译为 CSS 的 loader。</li>\n<li><code>css-loader</code>：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性</li>\n<li><code>style-loader</code>：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。</li>\n</ol>\n<h4 id=\"js-相关\"><a href=\"#js-相关\" class=\"headerlink\" title=\"js 相关\"></a>js 相关</h4><ol>\n<li><code>babel-loader</code>：把 ES6 转换成 ES5</li>\n<li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li>\n<li><code>source-map-loader</code>：加载额外的 Source Map ⽂件，以⽅便断点调试</li>\n<li><code>expose-loader</code>：expose-loader 允许暴露一个模块（整体或者部分）给全局对象（self、window 和 global）</li>\n</ol>\n<h3 id=\"常见的-plugin-有哪些\"><a href=\"#常见的-plugin-有哪些\" class=\"headerlink\" title=\"常见的 plugin 有哪些\"></a>常见的 plugin 有哪些</h3><h4 id=\"编译时\"><a href=\"#编译时\" class=\"headerlink\" title=\"编译时\"></a>编译时</h4><ol>\n<li><code>html-webpack-plugin</code>：简化 html ⽂件创建</li>\n<li><code>define-plugin</code>：定义环境变量</li>\n<li><code>CopyWebpackPlugin</code>：将已存在的单个文件或整个目录复制到生成目录。</li>\n</ol>\n<h4 id=\"性能提升相关的\"><a href=\"#性能提升相关的\" class=\"headerlink\" title=\"性能提升相关的\"></a>性能提升相关的</h4><ol>\n<li><code>WatchIgnorePlugin</code>：在监视模式下忽略指定的文件，即与提供的路径或正则表达式匹配的文件。</li>\n<li><code>DllPlugin</code>：<code>DllPlugin</code> 和 <code>DllReferencePlugin</code>，<code>add-asset-html-webpack-plugin</code> 用某种方法实现了拆分 bundles，同时还大幅度提升了构建的速度</li>\n<li><code>PrefetchPlugin</code>：预先获取模块提高性能</li>\n<li><code>SplitChunksPlugin</code>: chunks（以及内部导入的模块）是通过内部 webpack 图谱中的父子关系关联的。CommonsChunkPlugin 曾被用来避免他们之间的重复依赖，但是不可能再做进一步的优化。<br>从 webpack v4 开始，移除了 CommonsChunkPlugin，取而代之的是 optimization.splitChunks。</li>\n</ol>\n<h4 id=\"压缩相关的\"><a href=\"#压缩相关的\" class=\"headerlink\" title=\"压缩相关的\"></a>压缩相关的</h4><ol>\n<li><code>HtmlMinimizerWebpackPlugin</code>：使用 html 缩小器精简器来优化和缩小 html。</li>\n<li><code>CssMinimizerWebpackPlugin</code>：使用 <code>cssnano</code> 优化和压缩 CSS。</li>\n<li><code>MiniCssExtractPlugin</code>: CSS 提取到单独的⽂件中,⽀持按需加载</li>\n<li><code>JsonMinimizerWebpackPlugin</code>：使用<code>JSON.stringify()</code>缩小 JSON</li>\n<li><code>ImageMinimizerWebpackPlugin</code>：使用 imagemin 优化（压缩）所有图像</li>\n</ol>\n<h4 id=\"工具相关的\"><a href=\"#工具相关的\" class=\"headerlink\" title=\"工具相关的\"></a>工具相关的</h4><ol>\n<li><code>InstallWebpackPlugin</code>：通过使用 Webpack 自动安装和保存依赖项来加快开发。</li>\n<li><code>EslintWebpackPlugin</code>：使用 eslint 来查找和修复 JavaScript 代码中的问题。</li>\n<li><code>StylelintWebpackPlugin</code>：使用 stylelint 帮助你在样式代码中避免错误并强制规范。</li>\n<li><code>ProgressPlugin</code>：ProgressPlugin 提供了一种自定义编译过程 a 中报告进度的方式。</li>\n<li><code>webpack-build-notifier</code>：打包完成通知提醒。</li>\n</ol>\n<h4 id=\"优化工具\"><a href=\"#优化工具\" class=\"headerlink\" title=\"优化工具\"></a>优化工具</h4><ol>\n<li><code>page-skeleton-webpack-plugin</code>: <a href=\"https://github.com/ElemeFE/page-skeleton-webpack-plugin/blob/master/docs/i18n/zh_cn.md\" target=\"_blank\" >见</a> 骨架屏生成工具，根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中</li>\n<li><code>webpack-bundle-analyzer</code>: 可视化 webpack 输出⽂件的体积</li>\n<li><code>speed-measure-webpack-plugin</code>: 测量你的 webpack 构建速度，给出这样的输出</li>\n</ol>\n<h4 id=\"微应用-x2F-组件\"><a href=\"#微应用-x2F-组件\" class=\"headerlink\" title=\"微应用&#x2F;组件\"></a>微应用&#x2F;组件</h4><p><code>ModuleFederationPlugin</code>：在运行时提供或使用具有其他独立构建的模块</p>\n<h3 id=\"自定义-loader\"><a href=\"#自定义-loader\" class=\"headerlink\" title=\"自定义 loader\"></a>自定义 loader</h3><h3 id=\"自定义-plugin\"><a href=\"#自定义-plugin\" class=\"headerlink\" title=\"自定义 plugin\"></a>自定义 plugin</h3><h3 id=\"webpack-钩子\"><a href=\"#webpack-钩子\" class=\"headerlink\" title=\"webpack 钩子\"></a>webpack 钩子</h3><h4 id=\"compiler-钩子\"><a href=\"#compiler-钩子\" class=\"headerlink\" title=\"compiler 钩子\"></a>compiler 钩子</h4><ol>\n<li>Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。</li>\n<li>它扩展（extends）自 Tapable 类，用来注册和调用插件。</li>\n<li><code>大多数面向用户的插件会首先在 Compiler 上注册</code></li>\n</ol>\n<h4 id=\"compilation-钩子\"><a href=\"#compilation-钩子\" class=\"headerlink\" title=\"compilation 钩子\"></a>compilation 钩子</h4><ol>\n<li>Compilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。</li>\n<li>compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。</li>\n<li><code>它会对应用程序的依赖图中所有模块， 进行字面上的编译</code>(literal compilation)。</li>\n<li>在编译阶段，模块会被:<ol>\n<li><code>加载(load)</code>、</li>\n<li><code>封存(seal)</code>、</li>\n<li><code>优化(optimize)</code>、</li>\n<li><code>分块(chunk)</code>、</li>\n<li><code>哈希(hash)</code></li>\n<li><code>重新创建(restore)</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"webpack-的代码分割原理\"><a href=\"#webpack-的代码分割原理\" class=\"headerlink\" title=\"webpack 的代码分割原理\"></a>webpack 的代码分割原理</h3><p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。</p>\n<ol>\n<li>第一种，也是推荐选择的方式是，使用符合 ECMAScript 提案 的 <code>import()</code> 语法 来实现动态导入。</li>\n<li>第二种，使用 webpack 特定的 <code>require.ensure</code></li>\n</ol>\n<h3 id=\"tree-shaking\"><a href=\"#tree-shaking\" class=\"headerlink\" title=\"tree-shaking\"></a>tree-shaking</h3><h4 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h4><ol>\n<li>tree shaking 是一个术语，</li>\n<li>通常<code>用于描述移除 JavaScript 上下文中的未引用代码(dead-code)</code>。它依赖于 ES2015 模块语法的 <code>静态结构</code> 特性，例如 <code>import 和 export</code>。</li>\n<li>这个术语和概念实际上是由 <code>ES2015 模块打包工具 rollup</code> 普及起来的。</li>\n</ol>\n<h4 id=\"注意什么\"><a href=\"#注意什么\" class=\"headerlink\" title=\"注意什么\"></a>注意什么</h4><p>为了利用 tree shaking 的优势， 你必须…</p>\n<ol>\n<li>使用 ES2015 模块语法（即 import 和 export）。</li>\n<li>确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的（顺带一提，这是现在常用的 @babel&#x2F;preset-env 的默认行为，详细信息请参阅文档）。</li>\n<li>在项目的 package.json 文件中，添加 “sideEffects” 属性。</li>\n<li>使用 mode 为 “production” 的配置项以启用更多优化项，包括压缩代码与 tree shaking。</li>\n<li>你可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</li>\n</ol>\n<h3 id=\"webpack-的热更新原理？\"><a href=\"#webpack-的热更新原理？\" class=\"headerlink\" title=\"webpack 的热更新原理？\"></a>webpack 的热更新原理？</h3><img src=\"http://t-blog-images.aijs.top/img/202302042132304.webp\" style=\"width:700px;max-width:100%\" />\n\n<ol>\n<li>第⼀步，在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂ 件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li>\n<li>第⼆步是 webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API 对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。</li>\n<li>第三步是 webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当 我们在配置⽂件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件 的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。</li>\n<li>第四步也是 webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器 端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也 包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递 的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。</li>\n<li>webpack-dev-server&#x2F;client 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了 webpack，webpack&#x2F;hot&#x2F;dev-server 的⼯作就是根据 webpack-dev-server&#x2F;client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。</li>\n<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块 的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步 骤。</li>\n<li>⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是 否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。</li>\n<li>最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。</li>\n</ol>\n<h3 id=\"模块联邦\"><a href=\"#模块联邦\" class=\"headerlink\" title=\"模块联邦\"></a>模块联邦</h3><h4 id=\"什么是联邦\"><a href=\"#什么是联邦\" class=\"headerlink\" title=\"什么是联邦\"></a>什么是联邦</h4><p>联邦：由若干<code>小社会</code>组成的<code>大社会</code>，在保全<code>小社会</code>充分的自由之下，才有条件发展<code>大社会</code></p>\n<h4 id=\"什么是模块联邦\"><a href=\"#什么是模块联邦\" class=\"headerlink\" title=\"什么是模块联邦\"></a>什么是模块联邦</h4><p>是指：由若干<code>小模块</code>组成的<code>大模块</code>，在保全<code>小模块</code>充分的自由之下，才有条件发展<code>大模块</code></p>\n<h4 id=\"模块联邦执行过程\"><a href=\"#模块联邦执行过程\" class=\"headerlink\" title=\"模块联邦执行过程\"></a>模块联邦执行过程</h4><ol>\n<li><p>本地模块和远程模块。</p>\n<ol>\n<li>本地模块即为普通模块，是当前构建的一部分。</li>\n<li>远程模块不属于当前构建，并在运行时从所谓的容器加载</li>\n</ol>\n</li>\n<li><p>加载远程模块被认为是异步操作。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中</p>\n</li>\n<li><p>容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。暴露的访问分为两个步骤：</p>\n<ol>\n<li><p>加载模块（异步的）</p>\n</li>\n<li><p>执行模块（同步的）</p>\n<p>步骤 1 将在 chunk 加载期间完成。步骤 2 将在与其他（本地和远程）的模块交错执行期间完成。这样一来，执行顺序不受模块从本地转换为远程或从远程转为本地的影响。</p>\n</li>\n</ol>\n</li>\n<li><p>容器可以嵌套使用，容器可以使用来自其他容器的模块。容器之间也可以循环依赖。</p>\n</li>\n</ol>\n<h4 id=\"为什么会有模块联邦，解决了什么问题\"><a href=\"#为什么会有模块联邦，解决了什么问题\" class=\"headerlink\" title=\"为什么会有模块联邦，解决了什么问题\"></a>为什么会有模块联邦，解决了什么问题</h4><ol>\n<li><code>微应用</code>： 多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们</li>\n<li><code>组件复用</code>：实现不同应用的组件复用</li>\n</ol>\n<h4 id=\"模块联邦如何暴露，如何引用\"><a href=\"#模块联邦如何暴露，如何引用\" class=\"headerlink\" title=\"模块联邦如何暴露，如何引用\"></a>模块联邦如何暴露，如何引用</h4><img src=\"http://t-blog-images.aijs.top/img/202302042142540.webp\" />\n\n<ol>\n<li><code>引入信息</code>：name、remotes <code>应用名@远程地址@远程入口文件</code></li>\n<li><code>暴露信息</code>：name、filename、exposes <code>组件路径信息</code></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入\nnew ModuleFederationPlugin(&#123;\n  name: &quot;app1&quot;,\n  remotes: &#123;\n    app2: &quot;app2@[app2Url]&#x2F;remoteEntry.js&quot;,\n  &#125;,\n  shared: &#123;react: &#123;singleton: true&#125;, &quot;react-dom&quot;: &#123;singleton: true&#125;&#125;,\n&#125;),\n\n&#x2F;&#x2F; 暴露\nnew ModuleFederationPlugin(&#123;\n  name: &#39;app2&#39;,\n  filename: &#39;remoteEntry.js&#39;,\n  exposes: &#123;\n  &#39;.&#x2F;App&#39;: &#39;.&#x2F;src&#x2F;App&#39;,\n  &#125;,\n  shared: &#123; react: &#123; singleton: true &#125;, &#39;react-dom&#39;: &#123; singleton: true &#125; &#125;,\n&#125;),\n</code></pre>\n\n<h2 id=\"vite\"><a href=\"#vite\" class=\"headerlink\" title=\"vite\"></a>vite</h2><h3 id=\"为什么有-vite\"><a href=\"#为什么有-vite\" class=\"headerlink\" title=\"为什么有 vite\"></a>为什么有 vite</h3><ol>\n<li>在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。</li>\n<li>这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。</li>\n<li>webpack、Rollup 和 Parcel 等工具的变迁，它们极大地改善了前端开发者的开发体验。</li>\n<li>然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈</li>\n</ol>\n<h3 id=\"vite-解决了什么问题\"><a href=\"#vite-解决了什么问题\" class=\"headerlink\" title=\"vite 解决了什么问题\"></a>vite 解决了什么问题</h3><ol>\n<li>启动缓慢</li>\n<li>更新缓慢</li>\n</ol>\n<h3 id=\"vite-的实现原理是怎样的\"><a href=\"#vite-的实现原理是怎样的\" class=\"headerlink\" title=\"vite 的实现原理是怎样的\"></a>vite 的实现原理是怎样的</h3><ol>\n<li>Vite 通过在一开始将应用中的模块区分为 <code>依赖</code> 和 <code>源码</code> 两类，改进了开发服务器启动时间。</li>\n<li><code>依赖</code> 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。</li>\n<li><code>Vite 将会使用 esbuild 预构建依赖</code>。<code>esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</code></li>\n<li><code>源码</code> 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。</li>\n<li><code>Vite 以 原生 ESM 方式提供源码</code>。这实际上是<code>让浏览器接管了打包程序的部分工作</code>, <code>Vite 只需要在浏览器请求源码时进行转换并按需提供源码</code>。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理</li>\n</ol>\n<h3 id=\"vite-为什么比-webpack-快\"><a href=\"#vite-为什么比-webpack-快\" class=\"headerlink\" title=\"vite 为什么比 webpack 快\"></a>vite 为什么比 webpack 快</h3><ol>\n<li><code>在 Vite 中，HMR 是在原生 ESM 上执行的</code>。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活[1]（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。</li>\n<li><code>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）</code>：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</li>\n</ol>\n<h3 id=\"为什么生产环境仍需打包\"><a href=\"#为什么生产环境仍需打包\" class=\"headerlink\" title=\"为什么生产环境仍需打包\"></a>为什么生产环境仍需打包</h3><ol>\n<li>尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，<code>在生产环境中发布未打包的 ESM 仍然效率低下</code>（即使使用 HTTP&#x2F;2）。</li>\n<li>为了在生产环境中获得最佳的加载性能，最好还是<code>将代码进行 tree-shaking</code>、<code>懒加载</code>和 <code>chunk 分割</code>（以获得更好的缓存）。</li>\n</ol>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><h3 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h3><p>marge</p>\n<ol>\n<li>特点：⾃动创建⼀个新的 commit 如果合并的时候遇到冲突，仅需要修改后重新 commit</li>\n<li>优点：记录了真实的 commit 情况，包括每个分⽀的详情</li>\n<li>缺点：因为每次 merge 会⾃动产⽣⼀个 merge commit，所以在使⽤⼀些 git 的 GUI tools，特别是 commit ⽐较频繁时，看到<code>分⽀很杂乱</code>。</li>\n</ol>\n<h3 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a>git rebase</h3><ol>\n<li>rebase 特点：会合并之前的 commit 历史</li>\n<li>优点：得到更简洁的项⽬历史，去掉了 <code>merge commit</code></li>\n<li>缺点：如果合并出现代码问题, 不容易定位，因为 <code>re-write 了 history</code></li>\n</ol>\n<h3 id=\"何时使用-merge-x2F-rebase\"><a href=\"#何时使用-merge-x2F-rebase\" class=\"headerlink\" title=\"何时使用 merge&#x2F;rebase\"></a>何时使用 merge&#x2F;rebase</h3><ol>\n<li>因此,当需要保留详细的合并信息的时候建议使⽤ git merge，特别是需要将分⽀合并进⼊ master 分⽀时；</li>\n<li>当发现⾃⼰修 改某个功能时，频繁进⾏了 git commit 提交时，发现其实过多的提交信息没有必要时，可以尝试 git rebase.</li>\n</ol>\n<h3 id=\"git-rebase-与-git-merge-其他摘录\"><a href=\"#git-rebase-与-git-merge-其他摘录\" class=\"headerlink\" title=\"git rebase 与 git merge(其他摘录)\"></a>git rebase 与 git merge(其他摘录)</h3><p><a href=\"https://blog.csdn.net/small_white_123/article/details/121563248\" target=\"_blank\" >见</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202301281645578.webp\" style=\"width:800px;max-width:100%\" />\n\n<ol>\n<li>merge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）</li>\n<li>rebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，</li>\n<li>变基是将一系列提交按照原有次序依次应用到另一分支上，</li>\n<li>合并是把最终结果合在一起。</li>\n</ol>\n<h3 id=\"变基原理：\"><a href=\"#变基原理：\" class=\"headerlink\" title=\"变基原理：\"></a>变基原理：</h3><ol>\n<li>是首先找到这两个分支的最近共同祖先 C2</li>\n<li>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3</li>\n<li>最后以此将之前另存为临时文件的修改依序应用</li>\n</ol>\n<h3 id=\"什么时候用哪个？\"><a href=\"#什么时候用哪个？\" class=\"headerlink\" title=\"什么时候用哪个？\"></a>什么时候用哪个？</h3><p>这本身存在分歧，主要看团队需要，</p>\n<ol>\n<li>如果团队需要历史记录保留，便于追踪，可以使用 merge ,</li>\n<li>如果不希望保留过多的过程，只关注结果那么可以用 rebase.</li>\n<li>为了避免 rebase 的坑， 需要遵循原则是，<code>只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作</code></li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ git rebase --onto master server client</code></pre>\n\n<p>你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#:~:text=Figure%2039.%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E9%87%8C%E5%86%8D%E5%88%86%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\ngit rebase -i HEAD~4\n# s 命令压缩</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171547417.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171551269.png\" />\n\n<p><a href=\"https://www.cnblogs.com/lookphp/p/5799533.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"git-reset、git-revert-和-git-checkout-有什么区别【不懂哟-】\"><a href=\"#git-reset、git-revert-和-git-checkout-有什么区别【不懂哟-】\" class=\"headerlink\" title=\"git reset、git revert 和 git checkout 有什么区别【不懂哟~】\"></a>git reset、git revert 和 git checkout 有什么区别【不懂哟~】</h3><p>这个问题同样也需要先了解 git 仓库的三个组成部分：<code>⼯作区（Working Directory）</code>、<code>暂存区（Stage）</code>和<code>历史记录区 （History）</code>。</p>\n<ol>\n<li><code>⼯作区</code>：在 git 管理下的正常⽬录都算是⼯作区，我们平时的编辑⼯作都是在⼯作区完成</li>\n<li><code>暂存区</code>：临时区域。⾥⾯存放将要提交⽂件的快照</li>\n<li><code>历史记录区</code>：git commit 后的记录区 三个区的转换关系以及转换所使⽤的命令：</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202302051837550.webp\" style=\"width:500px;max-width:100%\" />\n\n<p>git reset、git revert 和 git checkout 的</p>\n<p><code>共同点：</code>⽤来撤销代码仓库中的某些更改。<br><code>不同点：</code></p>\n<p><strong>从 commit 层⾯来说：</strong></p>\n<ol>\n<li><p>git reset 可以将⼀个分⽀的末端指向之前的⼀个 commit。然后再下次 git 执⾏垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。</p>\n</li>\n<li><p>git reset 还⽀持三种标记，⽤来标记 reset 指令影响的范围：</p>\n<ol>\n<li>–mixed：会影响到暂存区和历史记录区。也是默认选项</li>\n<li>–soft：只影响历史记录区</li>\n<li>–hard：影响⼯作区、暂存区和历史记录区</li>\n</ol>\n</li>\n<li><p>因为 git reset 是直接删除 commit 记录，从⽽会影响到其他开发⼈员的分⽀，所以不要在公共分⽀（⽐如 develop）做这个操作。</p>\n</li>\n<li><p>git checkout 可以将 HEAD 移到⼀个新的分⽀，并更新⼯作⽬录。因为可能会覆盖本地的修改，所以执⾏这个指令之前，<code>需要 stash 或者 commit 暂存区和⼯作区的更改</code>。</p>\n</li>\n<li><p>git revert 和 git reset 的⽬的是⼀样的，但是做法不同，它会以创建新的 commit 的⽅式来撤销 commit，这样能保 留之前的 commit 历史，⽐较安全。同样因为可能会覆盖本地的修改，所以执⾏这个指令之前，<code>需要 stash 或者 commit 暂存区和⼯作区的更改</code>。</p>\n</li>\n</ol>\n<p><strong>从⽂件层⾯来说：</strong></p>\n<ol>\n<li><code>git reset</code> 只是把⽂件从历史记录区拿到暂存区，不影响⼯作区的内容，⽽且不⽀持 –mixed、–soft 和 –hard。</li>\n<li><code>git checkout</code> 则是把⽂件从历史记录拿到⼯作区，不影响暂存区的内容。</li>\n<li><code>git revert</code> 不⽀持⽂件层⾯的操作。</li>\n</ol>\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">👑 $ git push\n# 致命错误：当前分支 hotfix&#x2F;master 没有对应的上游分支。\n# 为推送当前分支并建立与远程上游的跟踪，使用\n\n#  git push --set-upstream origin hotfix&#x2F;master&#96;\n\n# 为了让没有追踪上游的分支自动配置，参见 git help config 中的 push.autoSetupRemote。\n\n# 👑 $ git push --set-upstream origin hotfix&#x2F;master\n# 枚举对象中: 32, 完成.\n# 对象计数中: 100% (32&#x2F;32), 完成.\n# 使用 4 个线程进行压缩\n# 压缩对象中: 100% (17&#x2F;17), 完成.\n# 写入对象中: 100% (20&#x2F;20), 125.66 KiB | 289.00 KiB&#x2F;s, 完成.\n# 总共 20（差异 12），复用 0（差异 0），包复用 0\n# remote: Resolving deltas: 100% (12&#x2F;12), completed with 10 local objects.\n# remote:\n# remote: Create a pull request for hotfix&#x2F;master on GitHub by visiting:\n# remote: https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;page-skeleton-webpack-plugin&#x2F;pull&#x2F;new&#x2F;hotfix&#x2F;master\n# remote:\n# To github.com:841660202&#x2F;page-skeleton-webpack-plugin.git\n\n# - [new branch] hotfix&#x2F;master -&gt; hotfix&#x2F;master\n#   分支 hotfix&#x2F;master 设置为跟踪 origin&#x2F;hotfix&#x2F;master。</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 从 git 2.37.0 开始，现在可以通过 git 配置实现。\n\n# 运行以更新您的配置：\n\ngit config --global --add --bool push.autoSetupRemote true # 在有些机器上不行\ngit config --global push.default current # 每当你在本地创建一个新分支，并运行 git push 时，Git 将自动将该分支推送到与其名称相同的远程分支，并将其设置为上游分支\n\n# 然后git push将自动设置远程分支。\n\n# 注意：该--global标志意味着这将适用于您机器上的所有 git 命令（无论它是哪个 repo），您可以省略该标志以使其特定于您机器上的单个 repo。</code></pre>\n\n<h3 id=\"测试一下\"><a href=\"#测试一下\" class=\"headerlink\" title=\"测试一下\"></a>测试一下</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 👑 $ git checkout -b hotfix&#x2F;master-test\n# 切换到一个新分支 &#39;hotfix&#x2F;master-test&#39;\n# 👑 $ git push\n# 总共 0（差异 0），复用 0（差异 0），包复用 0\n# remote:\n# remote: Create a pull request for &#39;hotfix&#x2F;master-test&#39; on GitHub by visiting:\n# remote:      https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;page-skeleton-webpack-plugin&#x2F;pull&#x2F;new&#x2F;hotfix&#x2F;master-test\n# remote:\n# To github.com:841660202&#x2F;page-skeleton-webpack-plugin.git\n#  * [new branch]      hotfix&#x2F;master-test -&gt; hotfix&#x2F;master-test\n# 分支 &#39;hotfix&#x2F;master-test&#39; 设置为跟踪 &#39;origin&#x2F;hotfix&#x2F;master-test&#39;。</code></pre>\n\n<h2 id=\"git-branch-a-有缓存，已经删除的分支仍然可见\"><a href=\"#git-branch-a-有缓存，已经删除的分支仍然可见\" class=\"headerlink\" title=\"git branch -a 有缓存，已经删除的分支仍然可见\"></a>git branch -a 有缓存，已经删除的分支仍然可见</h2><p>当你运行 <code>git branch -a</code> 命令时，Git 会显示本地和远程仓库中所有的分支，包括已经删除的分支。这是因为 <code>git branch -a</code> 命令显示的是所有分支的列表，包括本地和远程的。</p>\n<p>当你删除一个远程分支时，Git 并不会立即从本地缓存中删除这个分支的信息，而是将其保留在缓存中一段时间。这样做是为了防止在多人协作的项目中，其他团队成员还没有同步到最新状态时就误删了远程分支。删除的远程分支将会在一定时间后被 Git 自动清理掉。</p>\n<p>如果你希望立即清理掉缓存中已经删除的远程分支信息，可以使用 <code>git remote prune origin</code> 命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">git remote prune origin</code></pre>\n\n<p>这个命令会从本地缓存中移除那些在远程仓库已经被删除的分支。注意，这个命令只会清理远程分支的缓存信息，不会影响本地分支。</p>\n<p>另外，如果你只是想查看当前与远程仓库的实际状态，可以使用 <code>git remote show origin</code> 命令。这个命令会显示远程仓库的详细信息，包括当前与远程仓库的分支状态。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://cloud.tencent.com/developer/article/1532923\" target=\"_blank\" >见</a></p>\n","text":"babelBabel 的原理是什么?babel 的转译过程也分为三个阶段，这三步具体是： 解析 Parse: 将代码解析⽣成抽象语法树( 即 AST )，即词法分析与语法分析的过程 转换 Transform: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#babel\"><span class=\"toc-text\">babel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Babel-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">Babel 的原理是什么?</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack\"><span class=\"toc-text\">webpack</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-webpack\"><span class=\"toc-text\">为什么要用 webpack</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">模块化发展过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-IIFE\"><span class=\"toc-text\">立即调用函数表达式(IIFE)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Node-js%EF%BC%8CJavaScript-%E6%A8%A1%E5%9D%97%E8%AF%9E%E7%94%9F\"><span class=\"toc-text\">Node.js，JavaScript 模块诞生</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#npm-Node-js-modules-%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%8F%91%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">npm + Node.js + modules - 大规模分发模块</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ESM-ECMAScript-%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">ESM - ECMAScript 模块</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E8%87%AA%E5%8A%A8%E6%94%B6%E9%9B%86\"><span class=\"toc-text\">依赖自动收集</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#webpack-1\"><span class=\"toc-text\">webpack</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rollup%E3%80%81-Parcel\"><span class=\"toc-text\">rollup、 Parcel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-webpack\"><span class=\"toc-text\">什么是 webpack</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">核心组成部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">什么是入口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BE%93%E5%87%BA-output\"><span class=\"toc-text\">什么是输出(output)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-loader\"><span class=\"toc-text\">什么是 loader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E4%BB%B6-plugin\"><span class=\"toc-text\">什么是插件(plugin)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">核心原理是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#webpack-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84\"><span class=\"toc-text\">webpack 是如何执行的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84-loader-%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">常见的 loader 有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#html\"><span class=\"toc-text\">html</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">资源文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%B7%E5%BC%8F\"><span class=\"toc-text\">样式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#js-%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">js 相关</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84-plugin-%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">常见的 plugin 有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%97%B6\"><span class=\"toc-text\">编译时</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9B%B8%E5%85%B3%E7%9A%84\"><span class=\"toc-text\">性能提升相关的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%8B%E7%BC%A9%E7%9B%B8%E5%85%B3%E7%9A%84\"><span class=\"toc-text\">压缩相关的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E7%9A%84\"><span class=\"toc-text\">工具相关的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">优化工具</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E5%BA%94%E7%94%A8-x2F-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">微应用&#x2F;组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-loader\"><span class=\"toc-text\">自定义 loader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-plugin\"><span class=\"toc-text\">自定义 plugin</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#webpack-%E9%92%A9%E5%AD%90\"><span class=\"toc-text\">webpack 钩子</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#compiler-%E9%92%A9%E5%AD%90\"><span class=\"toc-text\">compiler 钩子</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#compilation-%E9%92%A9%E5%AD%90\"><span class=\"toc-text\">compilation 钩子</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#webpack-%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">webpack 的代码分割原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#tree-shaking\"><span class=\"toc-text\">tree-shaking</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">注意什么</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">webpack 的热更新原理？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6\"><span class=\"toc-text\">模块联邦</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E9%82%A6\"><span class=\"toc-text\">什么是联邦</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6\"><span class=\"toc-text\">什么是模块联邦</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">模块联邦执行过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">为什么会有模块联邦，解决了什么问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6%E5%A6%82%E4%BD%95%E6%9A%B4%E9%9C%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">模块联邦如何暴露，如何引用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vite\"><span class=\"toc-text\">vite</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89-vite\"><span class=\"toc-text\">为什么有 vite</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vite-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">vite 解决了什么问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vite-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">vite 的实现原理是怎样的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vite-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94-webpack-%E5%BF%AB\"><span class=\"toc-text\">vite 为什么比 webpack 快</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BB%8D%E9%9C%80%E6%89%93%E5%8C%85\"><span class=\"toc-text\">为什么生产环境仍需打包</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#git\"><span class=\"toc-text\">git</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-merge\"><span class=\"toc-text\">git merge</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-rebase\"><span class=\"toc-text\">git rebase</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-merge-x2F-rebase\"><span class=\"toc-text\">何时使用 merge&#x2F;rebase</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-rebase-%E4%B8%8E-git-merge-%E5%85%B6%E4%BB%96%E6%91%98%E5%BD%95\"><span class=\"toc-text\">git rebase 与 git merge(其他摘录)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%9F%BA%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">变基原理：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">什么时候用哪个？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-reset%E3%80%81git-revert-%E5%92%8C-git-checkout-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%90%E4%B8%8D%E6%87%82%E5%93%9F-%E3%80%91\"><span class=\"toc-text\">git reset、git revert 和 git checkout 有什么区别【不懂哟~】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-push\"><span class=\"toc-text\">git push</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B\"><span class=\"toc-text\">测试一下</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#git-branch-a-%E6%9C%89%E7%BC%93%E5%AD%98%EF%BC%8C%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84%E5%88%86%E6%94%AF%E4%BB%8D%E7%84%B6%E5%8F%AF%E8%A7%81\"><span class=\"toc-text\">git branch -a 有缓存，已经删除的分支仍然可见</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"immer","uid":"02c9defcec8ead4b797947c1373e1cfd","slug":"2023-02-06不可变","date":"2023-02-06T08:24:33.000Z","updated":"2023-02-20T21:20:56.487Z","comments":true,"path":"api/articles/2023-02-06不可变.json","keywords":null,"cover":[],"text":"什么是不可变数据范式immerjs中文官网 https://github.com/immerjs/immer immer 是什么在于 baseState 将保持不变，但 nextState 将反映对 DraftState 所做的所有更改. 为什么需要 immer 不可变的数据结构...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"前端工具","slug":"前端工具","count":1,"path":"api/categories/前端工具.json"}],"tags":[{"name":"前端工具","slug":"前端工具","count":1,"path":"api/tags/前端工具.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"vscode md 有序列表技巧","uid":"576f5f9f7495f386a7a9eae5a3e0ede8","slug":"2023-02-03vs-md","date":"2023-02-03T08:02:14.000Z","updated":"2023-02-20T21:20:56.486Z","comments":true,"path":"api/articles/2023-02-03vs-md.json","keywords":null,"cover":[],"text":"背景有时候，需要把无序列表改为有序列表，手动一个一个改太麻烦了，曾经一度想写个插件进行自动化处理，今天无意中发现，有个骚操作 操作 将无序列表批量改为有序 将下面段落选中，进行批量后移 再批量前移恢复下 这样序号就自动生成好了 更狠的操作将上述操作的 2 去掉，简化掉一步 将无序...","link":"","photos":[],"count_time":{"symbolsCount":271,"symbolsTime":"1 mins."},"categories":[{"name":"vscode","slug":"vscode","count":8,"path":"api/categories/vscode.json"}],"tags":[{"name":"vscode","slug":"vscode","count":11,"path":"api/tags/vscode.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}