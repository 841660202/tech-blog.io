{"title":"ts","uid":"bde1b6e957dca5aefd70ca7596a58c26","slug":"2023-01-13ts","date":"2023-01-13T02:43:49.000Z","updated":"2023-02-20T21:20:56.482Z","comments":true,"path":"api/articles/2023-01-13ts.json","keywords":null,"cover":null,"content":"<h2 id=\"object-与-Record-的区别\"><a href=\"#object-与-Record-的区别\" class=\"headerlink\" title=\"object 与 Record 的区别\"></a>object 与 Record 的区别</h2><p>object 不能接收原始类型，而 {} 和 Object 都可以，这是它们的区别。<br>object 一般会用 Record 代替，约束索引类型更加语义化。</p>\n<h2 id=\"keyof-any-有何特点\"><a href=\"#keyof-any-有何特点\" class=\"headerlink\" title=\"keyof any 有何特点\"></a>keyof any 有何特点</h2><p>keyof any 可以动态获取 key 支持的类型，根据 keyofStringsOnly 的编译选项，可以用来约束索引。</p>\n<h2 id=\"readonly、\"><a href=\"#readonly、\" class=\"headerlink\" title=\"-readonly、-?\"></a>-readonly、-?</h2><p>映射类型语法可以创建索引类型，并且加上 readonly 或 ? 的修饰，其实也可以用 -readonly、-? 去掉。</p>\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>NOTE</p>\n<p>当希望传 user 参数时，不传 flag，传 para 时，传 flag。就可以这样写：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface User &#123;\n  name: string;\n  age: number;\n&#125;\n\nconst user &#x3D; &#123;\n  name: &quot;Jack&quot;,\n  age: 123,\n&#125;;\n\nclass SomeClass &#123;\n  public test(para: User): number;\n  public test(para: number, flag: boolean): number;\n\n  public test(para: User | number, flag?: boolean): number &#123;\n    &#x2F;&#x2F; 具体实现\n    return 1;\n  &#125;\n&#125;\n\nconst someClass &#x3D; new SomeClass();\n\n&#x2F;&#x2F; ok\nsomeClass.test(user);\nsomeClass.test(123, false);\n\n&#x2F;&#x2F; Error\n&#x2F;&#x2F; someClass.test(123);\n&#x2F;&#x2F;Argument of type &#39;number&#39; is not assignable to parameter of type &#39;User&#39;.\n&#x2F;&#x2F; someClass.test(user, false);\n&#x2F;&#x2F;Argument of type &#39;&#123; name: string; age: number; &#125;&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>\n\n<h2 id=\"Partial-Readonly-Nullable-Required\"><a href=\"#Partial-Readonly-Nullable-Required\" class=\"headerlink\" title=\"Partial, Readonly, Nullable, Required\"></a>Partial, Readonly, Nullable, Required</h2><ol>\n<li>Partial 将每个属性转换为可选属性</li>\n<li>Readonly 将每个属性转换为只读属性</li>\n<li>Nullable 转换为旧类型和 null 的联合类型</li>\n<li>Required 将每个属性转换为必选属性</li>\n</ol>\n<h2 id=\"Pick-Record\"><a href=\"#Pick-Record\" class=\"headerlink\" title=\"Pick, Record\"></a>Pick, Record</h2><ol>\n<li>Pick 选取一组属性指定新类型</li>\n<li>Record 创建一组属性指定新类型，常用来声明普通 Object 对象</li>\n</ol>\n<h2 id=\"Exclude-Omit\"><a href=\"#Exclude-Omit\" class=\"headerlink\" title=\"Exclude, Omit\"></a>Exclude, Omit</h2><ol>\n<li><code>用于联合类型</code> Exclude 去除交集，返回剩余的部分</li>\n<li><code>用于Record&lt;.,.&gt;类型</code> Omit 适用于键值对对象的 Exclude，去除类型中包含的键值对</li>\n</ol>\n<h2 id=\"ReturnType\"><a href=\"#ReturnType\" class=\"headerlink\" title=\"ReturnType\"></a>ReturnType</h2><p>获取返回值类型，一般为函数</p>\n<h2 id=\"infer\"><a href=\"#infer\" class=\"headerlink\" title=\"infer\"></a>infer</h2><p>表示在 extends 条件语句中待推断的类型变量。</p>\n<h2 id=\"interface-key-string-any\"><a href=\"#interface-key-string-any\" class=\"headerlink\" title=\"interface [key:string]: any\"></a>interface [key:string]: any</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">enum AnimalFlags &#123;\n  None &#x3D; 0,\n  HasClaws &#x3D; 1 &lt;&lt; 0,\n  CanFly &#x3D; 1 &lt;&lt; 1,\n  HasClawsOrCanFly &#x3D; HasClaws | CanFly,\n&#125;\n\ninterface Animal &#123;\n  flags: AnimalFlags;\n  &#x2F;&#x2F; name: string 这个会报红\n  [key: string]: any; &#x2F;&#x2F; 次处不允许包含以上部分\n&#125;</code></pre>\n\n<h2 id=\"TS-中-enum-枚举-和-const-enum-常量枚举-有什么区别？\"><a href=\"#TS-中-enum-枚举-和-const-enum-常量枚举-有什么区别？\" class=\"headerlink\" title=\"TS 中 enum(枚举) 和 const enum(常量枚举) 有什么区别？\"></a>TS 中 enum(枚举) 和 const enum(常量枚举) 有什么区别？</h2><h2 id=\"extends-关键字\"><a href=\"#extends-关键字\" class=\"headerlink\" title=\"extends 关键字\"></a>extends 关键字</h2><p>不学 extends，Exclude 和 Extract，很难理解</p>\n<p>extends 关键字在 TS 编程中出现的频率挺高的，而且<code>不同场景下代表的含义不一样</code>，特此总结一下：</p>\n<ul>\n<li><p>表示继承&#x2F;拓展的含义</p>\n</li>\n<li><p>表示约束的含义</p>\n</li>\n<li><p>表示分配的含义</p>\n</li>\n</ul>\n<hr/>\n\n<h3 id=\"表示继承-x2F-拓展\"><a href=\"#表示继承-x2F-拓展\" class=\"headerlink\" title=\"表示继承&#x2F;拓展\"></a>表示继承&#x2F;拓展</h3><p>extends 是 ts 里一个很常见的关键字，同时也是 es6 里引入的一个新的关键字。在 js 里，extends 一般和 class 一起使用</p>\n<ul>\n<li>es6 继承父类的方法和属性</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n  kind &#x3D; &quot;animal&quot;;\n  constructor(kind) &#123;\n    this.kind &#x3D; kind;\n  &#125;\n  sayHello() &#123;\n    console.log(&#96;Hello, I am a $&#123;this.kind&#125;!&#96;);\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  constructor(kind) &#123;\n    super(kind);\n  &#125;\n  bark() &#123;\n    console.log(&quot;wang wang&quot;);\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog(&quot;dog&quot;);\ndog.name; &#x2F;&#x2F;  &#x3D;&gt; &#39;dog&#39;\ndog.sayHello(); &#x2F;&#x2F; &#x3D;&gt; Hello, I am a dog!</code></pre>\n\n<p>这里 Dog 继承了父类的 sayHello 方法，因为可以在 Dog 实例 dog 上调用。</p>\n<ul>\n<li>ts 继承某个类型<br>在 ts 里，extends 除了可以像 js 继承值，还可以继承&#x2F;扩展类型：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  kind: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  bark(): void;\n&#125;\n&#x2F;&#x2F; Dog &#x3D;&gt; &#123; name: string; bark(): void &#125;</code></pre>\n\n<hr/>\n\n<h3 id=\"泛型约束\"><a href=\"#泛型约束\" class=\"headerlink\" title=\"泛型约束\"></a>泛型约束</h3><p>在书写泛型的时候，我们往往需要对类型参数作一定的限制，比如希望传入的参数都有 name 属性的数组我们可以这么写：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCnames&lt;T extends &#123; name: string &#125;&gt;(entities: T[]): string[] &#123;\n  return entities.map((entity) &#x3D;&gt; entity.cname);\n&#125;</code></pre>\n\n<p>这里 extends 对传入的参数作了一个限制，就是 entities 的每一项可以是一个对象，但是必须含有类型为 string 的 cname 属性。</p>\n<p>再比如，redux 里 dispatch 一个 action，必须包含 type 属性：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;redux&#x2F;blob&#x2F;2edd0363271af46e327e118f3d92e78e258bf0cd&#x2F;src&#x2F;types&#x2F;store.ts#L83\n\n&#x2F;&#x2F; Dispatch\nexport interface Dispatch&lt;A extends Action &#x3D; AnyAction&gt; &#123;\n  &lt;T extends A&gt;(action: T, ...extraArgs: any[]): T;\n&#125;\n\n&#x2F;&#x2F; AnyAction\nexport interface AnyAction extends Action &#123;\n  &#x2F;&#x2F; Allows any extra properties to be defined in an action.\n  [extraProps: string]: any;\n&#125;\n&#x2F;&#x2F; Action\nexport interface Action&lt;T &#x3D; any&gt; &#123;\n  type: T;\n&#125;\n\n&#x2F;&#x2F; 上述代码 简化\ninterface Dispatch&lt;T extends &#123; type: string &#125;&gt; &#123;\n  (action: T): T;\n&#125;</code></pre>\n\n<h3 id=\"条件类型与高阶类型\"><a href=\"#条件类型与高阶类型\" class=\"headerlink\" title=\"条件类型与高阶类型\"></a>条件类型与高阶类型</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">SomeType extends OtherType ? TrueType : FalseType;\n</code></pre>\n\n<p>When the type on the left of the extendsis assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).<br><code>当左边的类型可以赋值给右边的类型，那么你就会得到第一个分支的类型，否则你就会得到第二个分支的类型。</code></p>\n<p>extends 还有一大用途就是用来判断一个类型是不是可以分配给另一个类型，这在写高级类型的时候非常有用，举个 ????：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Human &#x3D; &#123;\n  name: string;\n&#125;;\ntype Duck &#x3D; &#123;\n  name: string;\n&#125;;\ntype Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;yes&#39;</code></pre>\n\n<p>在 vscode 里或者 ts playground 里输入这段代码，你会发现 Bool 的类型是’yes’。这是因为 Human 和 Duck 的类型完全相同，或者说 Human 类型的一切约束条件，Duck 都具备；换言之，类型为 Human 的值可以分配给类型为 Duck 的值（分配成功的前提是，Duck 里面得的类型得有一样的），反之亦然。需要理解的是，这里 A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集。稍微扩展下来详细说明这个问题：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Human &#x3D; &#123;\n  name: string;\n  occupation: string;\n&#125;;\ntype Duck &#x3D; &#123;\n  name: string;\n&#125;;\ntype Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;no&#39;</code></pre>\n\n<p>当我们给 Human 加上一个 occupation 属性，发现此时 Bool 是’no’，这是因为 Duck 没有类型为 string 的 occupation 属性，类型 Duck 不满足类型 Human 的类型约束。因此，A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集，理解 extends 在类型三元表达式里的用法非常重要。</p>\n<p>继续看示例</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type A1 &#x3D; &quot;x&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; string\ntype A2 &#x3D; &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; number\n\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; ?</code></pre>\n\n<p>A1 和 A2 是 extends 条件判断的普通用法，和上面的判断方法一样。</p>\n<p>P 是带参数 T 的泛型类型，其表达式和 A1，A2 的形式完全相同，A3 是泛型类型 P 传入参数’x’ | ‘y’得到的类型，如果将’x’ | ‘y’带入泛型类的表达式，可以看到和 A2 类型的形式是完全一样的，那是不是说明，A3 和 A2 的类型就是完全一样的呢？</p>\n<p>有兴趣可以自己试一试，这里就直接给结论了</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre>\n\n<p>是不是很反直觉？这个反直觉结果的原因就是所谓的分配条件类型（Distributive Conditional Types）</p>\n<p>When conditional types act on a generic type, they become distributive when given a union type<br><code>当条件类型作用于泛型类型时，它们变成分配条件类型（Distributive Conditional Types）</code></p>\n<p>这句话翻译过来也还是看不懂，大白话</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于使用 extends 关键字的条件类型（即上面的三元表达式类型），<strong>如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</strong></p></blockquote>\n<p>If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.<br><code>如果将联合类型传入 ToArray，则条件类型将会应用到联合类型的每一个成员。</code></p>\n<p>还是用上面的例子说明</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre>\n\n<p>该例中，extends 的前参为 T，T 是一个泛型参数。在 A3 的定义中，给 T 传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入 P<T></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">P&lt;&#39;x&#39; | &#39;y&#39;&gt; &#x3D;&gt; P&lt;&#39;x&#39;&gt; | P&lt;&#39;y&#39;&gt;\n\n&#x2F;&#x2F; &#39;x&#39;代入得到\n\n&#x2F;&#x2F; &#39;x&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; string\n\n&#x2F;&#x2F; &#39;y&#39;代入得到\n\n&#x2F;&#x2F; &#39;y&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; number\n\n&#x2F;&#x2F; 然后将每一项代入得到的结果联合起来，得到 string | number\n</code></pre>\n\n<p>总之，满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型</p>\n<p>特殊的 never</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; never 是所有类型的子类型\ntype A1 &#x3D; never extends &quot;x&quot; ? string : number; &#x2F;&#x2F; string\n\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; never</code></pre>\n\n<p>上面的示例中，A2 和 A1 的结果竟然不一样，看起来 never 并不是一个联合类型，所以直接代入条件类型的定义即可，获取的结果应该和 A1 一直才对啊？</p>\n<p>实际上，这里还是条件分配类型在起作用。never 被认为是空的联合类型，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以 P<T>的表达式其实根本就没有执行，所以 A2 的定义也就类似于永远没有返回的函数一样，是 never 类型的。</p>\n<p>防止条件判断中的分配</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type P&lt;T&gt; &#x3D; [T] extends [&quot;x&quot;] ? string : number;\ntype A1 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; number\ntype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; string</code></pre>\n\n<p>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p>\n<hr/>\n\n<h2 id=\"extends-与-ts-中型变\"><a href=\"#extends-与-ts-中型变\" class=\"headerlink\" title=\"extends 与 ts 中型变\"></a>extends 与 ts 中型变</h2><h3 id=\"父子类\"><a href=\"#父子类\" class=\"headerlink\" title=\"父子类\"></a>父子类</h3><ol>\n<li>对于索引类型，子类是父类的超集</li>\n<li>对于联合类型，子类是父类的子集</li>\n</ol>\n<p><strong>一句话： 子类比父类更具体</strong></p>\n<h3 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h3><p>B 继承 A,B 是 A 的子类，B 拥有的索引比 A 多，B 更具体</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface A &#123;\n  a: 1;\n&#125;\ninterface B extends A &#123;\n  b: 2;\n&#125;</code></pre>\n\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p>可见联合类型，子类 child 是父类 parent 的子集。但 child 同样比 parent 更具体。举例：选择题 ABCD 排除掉两项后，答案所在的范围就更具体了（比如 A ｜ B）;或者 <code>1 extends number</code>,1 相对于 number 更具体，number 又类似 <code>0｜1｜2｜3...</code>。所以联合类型中子类是父类子集，且更具体</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type child &#x3D; 1 | 2;\ntype parent &#x3D; 1 | 2 | 3;\ntype check&lt;child, parent&gt; &#x3D; child extends parent ? true : false;\ntype res &#x3D; check&lt;child, parent&gt;; &#x2F;&#x2F; type res &#x3D; true</code></pre>\n\n<h3 id=\"判断父子类关系\"><a href=\"#判断父子类关系\" class=\"headerlink\" title=\"判断父子类关系\"></a>判断父子类关系</h3><p>名义类型系统 nominal type</p>\n<p>使用 extends 关键字（其他强类型语言，如 java 就是采用的这个系统）</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface A &#123;\n  a: 1;\n&#125;\ninterface B extends A &#123;\n  b: 2;\n&#125;</code></pre>\n\n<h3 id=\"结构类型系统-structual-type\"><a href=\"#结构类型系统-structual-type\" class=\"headerlink\" title=\"结构类型系统 structual type\"></a>结构类型系统 structual type</h3><p>ts 使用的是结构类型</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type A &#123;\n  a: number\n  b: string;\n  c: boolean\n&#125;\n\ntype B &#123;\n  a: number\n  b: number\n&#125;\n\ntype AisChildOfB&lt;A,B&gt; &#x3D; A extends B ? true : false\n\ntype res &#x3D; AisChildOfB&lt;A,B&gt; &#x2F;&#x2F; type res &#x3D; true\n</code></pre>\n\n<p>虽然 A 和 B 并没有用关键字声明，但是 TS 还是推断出 AB 的父子关系。这样做的好处非常多，可以最大化兼容 JS，毕竟 JS 中创建对象没有约束，利用结构判断能省去很多手动的类型继承声明</p>\n<h3 id=\"协变\"><a href=\"#协变\" class=\"headerlink\" title=\"协变\"></a>协变</h3><p>需要不同类型的值进行赋值，虽然类型不同，但是编译器可以在某些情况下做一些改变（变通，或者是妥协），方便的进行赋值并不出现类型错误，比如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Person &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface Student extends Person &#123;\n  school: string;\n&#125;\n\nlet aPerson: Person &#x3D; &#123; name: &quot;Beyond&quot;, age: 20 &#125;;\nlet aStudent: Student &#x3D; &#123; school: &quot;tju&quot;, name: &quot;Beyond&quot;, age: 20 &#125;;\n\naPerson &#x3D; aStudent; &#x2F;&#x2F; 这里可以执行\naStudent &#x3D; aPerson; &#x2F;&#x2F; 报错，类型“Person”中缺失属性“school”\n\ntype check&lt;T&gt; &#x3D; T extends Student ? true : false;\n\ntype res &#x3D; check&lt;typeof aPerson&gt;; &#x2F;&#x2F; res &#x3D; false\ntype res2 &#x3D; check&lt;typeof aStudent&gt;; &#x2F;&#x2F; res2 &#x3D; true</code></pre>\n\n<p>TS 知道 Student 是 Person 的子类，所以在赋值时，虽然等号左右的类型不一致，但父类有属性，子类都有，所以将子类赋值给父类是安全的，反之，将父类（属性少）赋值给子类（属性多）的操作就会报错。而子类赋值给父类的过程中，子类会（妥协）改变类型以匹配父类再赋值，但是这个改变只是赋值的过程中的，不会改变变量本身的类型。使用 check 类型能看出，赋值操作之后的两个变量，还保持着原来的类型（定义时所约束的类）</p>\n<h3 id=\"逆变\"><a href=\"#逆变\" class=\"headerlink\" title=\"逆变\"></a>逆变</h3><p>在 ts 中，函数的参数类型是逆变的。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Parent &#123;\n  a: 1;\n&#125;\n\ninterface Child extends Parent &#123;\n  b: 2;\n&#125;\n\ntype FunP &#x3D; (arg: Parent) &#x3D;&gt; any;\ntype FunC &#x3D; (arg: Child) &#x3D;&gt; any;\n\nlet funp: FunP &#x3D; () &#x3D;&gt; true;\nlet func: FunC &#x3D; () &#x3D;&gt; 1;\n\nfunc &#x3D; funp;</code></pre>\n\n<p>父函数能赋值给子函数（反过来不可以），这里重点有两个：约束和调用</p>\n<p>先记住，对于索引类型来说，父类索引更少，子类索引更多。使用类型约束父函数时，当函数调用后，函数内部的操作对象是父类。当把这个父类约束放到子类函数去调用，此时约束是子类（提供更多索引项)，但是函数内部始终是对父类（更少索引项）的操作，所以是安全的。</p>\n<p>反之，如果是子类赋给父类，那么就是在约束的时候使用更多的索引项，而在调用时提供了更少的（父类）索引项，这样当然是不安全的。</p>\n<h3 id=\"双向协变\"><a href=\"#双向协变\" class=\"headerlink\" title=\"双向协变\"></a>双向协变</h3><p>既协变又逆变 &#x3D; 双向协变<br>目前 TS 是默认不允许双向协变的，因为这样做类型不安全。但是如果设置了<code>&quot;strictFunctionTypes&quot;:false</code>,TS 就不会去检查，是可以做到双向逆变的，但是不建议这么做。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type UnionToIntersction&lt;U&gt; &#x3D; (U extends U ? (a:U)&#x3D;&gt; any: never) extends (a:inter R)&#x3D;&gt; any ? R : never\n\ntype res &#x3D; UnionToIntersction&lt;&#123;a:1&#125;|&#123;b:3&#125;&gt;</code></pre>\n\n<h3 id=\"不变\"><a href=\"#不变\" class=\"headerlink\" title=\"不变\"></a>不变</h3><p>两个没有父子级关系的类型互相赋值时，会报类型错误，这就是不变。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://www.51cto.com/article/704496.html\" target=\"_blank\" >几个一看就会的 TypeScript 小技巧</a></p>\n<p><a href=\"https://www.jb51.net/article/220869.htm\" target=\"_blank\" >你可能不知道的 typescript 实用小技巧</a></p>\n","text":"object 与 Record 的区别object 不能接收原始类型，而 {} 和 Object 都可以，这是它们的区别。object 一般会用 Record 代替，约束索引类型更加语义化。 keyof any 有何特点keyof any 可以动态获取 key 支持的类型，根据 ...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"typeScript","slug":"typeScript","count":1,"path":"api/categories/typeScript.json"}],"tags":[{"name":"typeScript","slug":"typeScript","count":1,"path":"api/tags/typeScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#object-%E4%B8%8E-Record-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">object 与 Record 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#keyof-any-%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">keyof any 有何特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#readonly%E3%80%81\"><span class=\"toc-text\">-readonly、-?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">函数重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Partial-Readonly-Nullable-Required\"><span class=\"toc-text\">Partial, Readonly, Nullable, Required</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pick-Record\"><span class=\"toc-text\">Pick, Record</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Exclude-Omit\"><span class=\"toc-text\">Exclude, Omit</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReturnType\"><span class=\"toc-text\">ReturnType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#infer\"><span class=\"toc-text\">infer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#interface-key-string-any\"><span class=\"toc-text\">interface [key:string]: any</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TS-%E4%B8%AD-enum-%E6%9E%9A%E4%B8%BE-%E5%92%8C-const-enum-%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">TS 中 enum(枚举) 和 const enum(常量枚举) 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#extends-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">extends 关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E7%A4%BA%E7%BB%A7%E6%89%BF-x2F-%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">表示继承&#x2F;拓展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">泛型约束</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%AB%98%E9%98%B6%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">条件类型与高阶类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#extends-%E4%B8%8E-ts-%E4%B8%AD%E5%9E%8B%E5%8F%98\"><span class=\"toc-text\">extends 与 ts 中型变</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">父子类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">索引类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">联合类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E7%88%B6%E5%AD%90%E7%B1%BB%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">判断父子类关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-structual-type\"><span class=\"toc-text\">结构类型系统 structual type</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%8F%98\"><span class=\"toc-text\">协变</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%86%E5%8F%98\"><span class=\"toc-text\">逆变</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E5%8D%8F%E5%8F%98\"><span class=\"toc-text\">双向协变</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%98\"><span class=\"toc-text\">不变</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">参考文档</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"postwoman","uid":"bb851a23d0dc32b76a55f0e588564791","slug":"2023-01-13postwoman","date":"2023-01-13T07:45:33.000Z","updated":"2023-02-20T21:20:56.481Z","comments":true,"path":"api/articles/2023-01-13postwoman.json","keywords":null,"cover":"https://www.gorilla76.com/wp-content/uploads/2019/02/fast-vs-sustainable-marketing-results.png","text":"postman 与 postwoman相比较而言 postman 功能更强大，交互设计更友好 但是：好用不一定就适用postman 需要安装，脱离浏览器运行，那么如果是 cookie 校验的情况，需要手动操作，而 postwoman 是网页版的，浏览器会自动带上 cookie，省...","link":"","photos":[],"count_time":{"symbolsCount":152,"symbolsTime":"1 mins."},"categories":[{"name":"工具","slug":"工具","count":17,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":11,"path":"api/tags/工具.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"vscode todo-tree","uid":"f529002cad4b9303e53cd56193414670","slug":"2023-01-13todo-tree","date":"2023-01-13T01:37:33.000Z","updated":"2023-02-20T21:20:56.481Z","comments":true,"path":"api/articles/2023-01-13todo-tree.json","keywords":null,"cover":"https://www.gorilla76.com/wp-content/uploads/2019/02/fast-vs-sustainable-marketing-results.png","text":"使用评论 意义 FIXME: 有缺陷的代码。我有强烈的意愿去解决它。 DELETE: 欲删除 IDEA: 这是一个好主意 TODO: 该怎么办。比 FIXME 弱。要修复的功能。 NOTE: 在强调实现的意图以及为什么要这样写的时候写。 HACK: 我想重构。 REVIEW: 需...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"vscode","slug":"vscode","count":8,"path":"api/categories/vscode.json"}],"tags":[{"name":"vscode","slug":"vscode","count":11,"path":"api/tags/vscode.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}