{"title":"React18 四个新hook","uid":"0c4a3dd6ecc4239de48c5ec997a9babe","slug":"2023-04-17useTansition","date":"2023-04-17T06:35:31.000Z","updated":"2023-05-15T13:17:32.992Z","comments":true,"path":"api/articles/2023-04-17useTansition.json","keywords":null,"cover":null,"content":"<h1 id=\"useTransition\"><a href=\"#useTransition\" class=\"headerlink\" title=\"useTransition\"></a>useTransition</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>在不阻塞 UI 的情况下更新状态</p>\n<h2 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h2><ol>\n<li>转换是可中断的，这让用户无需等待重新渲染完成即可单击离开。</li>\n<li>转换可防止不需要的加载指示器，这使用户可以避免导航时出现不和谐的跳转。</li>\n</ol>\n<h2 id=\"场景及替换方案\"><a href=\"#场景及替换方案\" class=\"headerlink\" title=\"场景及替换方案\"></a>场景及替换方案</h2><ol>\n<li>只能在组件中使用</li>\n<li>要开始转换以响应某些 prop 或自定义 Hook 值，使用 <code>DeferredValue</code></li>\n<li>传递给 startTranition 的函数必须是同步的。React 会立即执行此函数，并将其执行时发生的所有状态更新标记为转换。如果您稍后尝试执行更多状态更新（例如，在超时时），它们将不会被标记为转换。</li>\n<li>标记为转换的状态更新将被其他状态更新中断</li>\n<li>转换更新不能用于控制文本输入</li>\n<li>如果有多个正在进行的转换，React 当前会将它们批处理在一起。这是一个限制，可能会在未来的版本中删除。</li>\n</ol>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>更新转换中的输入不起作用</li>\n<li>传递给 startTranition 的函数必须是同步的</li>\n<li>您不能在组件之外调用 useTranition，因为它是一个 Hook。在这种情况下，请改用独立的 startTranition 方法。它的工作方式相同，但不提供 isPending 指示符。</li>\n</ol>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; A simplified version of how React works\n\nlet isInsideTransition &#x3D; false;\n\nfunction startTransition(scope) &#123;\n  isInsideTransition &#x3D; true;\n  scope();\n  isInsideTransition &#x3D; false;\n&#125;\n\nfunction setState() &#123;\n  if (isInsideTransition) &#123;\n    &#x2F;&#x2F; 大概是一个标志，为true执行，isInsideTransition置为false, 后就不会执行了\n    &#x2F;&#x2F; ... schedule a transition state update ...\n  &#125; else &#123;\n    &#x2F;&#x2F; ... schedule an urgent state update ...\n  &#125;\n&#125;</code></pre>\n\n<h1 id=\"useDeferredValue\"><a href=\"#useDeferredValue\" class=\"headerlink\" title=\"useDeferredValue\"></a>useDeferredValue</h1><h2 id=\"作用-1\"><a href=\"#作用-1\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>延迟更新部分 UI</p>\n<h2 id=\"动机-1\"><a href=\"#动机-1\" class=\"headerlink\" title=\"动机\"></a>动机</h2><h2 id=\"场景及替换方案-1\"><a href=\"#场景及替换方案-1\" class=\"headerlink\" title=\"场景及替换方案\"></a>场景及替换方案</h2><ol>\n<li>在加载新内容时显示陈旧内容</li>\n<li>加一些效果表示内容陈旧</li>\n<li>推迟部分 UI 的重新渲染</li>\n</ol>\n<h2 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>您传递给 useDeferredValue 的值应该是原始值（如字符串和数字）或在渲染之外创建的对象。如果您在渲染期间创建一个新对象并立即将其传递给 useDeferredValue，它将在每次渲染时有所不同，从而导致不必要的后台重新渲染。</li>\n<li>当 useDeferredValue 接收到不同的值（与 Object.is 相比）时，除了当前渲染（当它仍然使用以前的值时），它还会在后台使用新值安排重新渲染。后台重新渲染是可中断的：如果该值有另一个更新，React 将从头开始重新启动后台重新渲染。例如，如果用户输入输入的速度比接收其延迟值的图表重新渲染的速度快，则只有在用户停止输入后，图表才会重新渲染。</li>\n<li>useDeferredValue 与<code>&lt;Suspense&gt;</code>集成。如果新值引起的后台更新挂起 UI，用户将看不到回退。他们会看到旧的延迟值，直到数据加载。</li>\n<li>useDeferredValue 本身不会阻止额外的网络请求。</li>\n<li>useDeferredValue 本身没有固定的延迟。一旦 React 完成原始的重新渲染，React 将立即开始使用新的延迟值进行后台重新渲染。由事件（如打字）引起的任何更新都会中断后台重新渲染并优先于它。</li>\n<li>useDeferredValue 导致的后台重新渲染在提交到屏幕之前不会触发效果。如果后台重新渲染暂停，其效果将在数据加载和 UI 更新后运行。</li>\n</ol>\n<h2 id=\"陷阱\"><a href=\"#陷阱\" class=\"headerlink\" title=\"陷阱\"></a>陷阱</h2><p><a href=\"https://react.dev/reference/react/useDeferredValue#deferring-re-rendering-for-a-part-of-the-ui\" target=\"_blank\" >见</a></p>\n<p>这种优化需要将 SlowList 包装在 memo 中。这是因为每当文本发生变化时，React 都需要能够快速重新渲染父组件。<br>在重新渲染期间，deferredText 仍然有其先前的值，因此 SlowList 能够跳过重新渲染（其道具没有改变）。<br><strong>如果没有 memo，它无论如何都必须重新渲染，这违背了优化的要点。</strong></p>\n<h1 id=\"useInsertionEffect\"><a href=\"#useInsertionEffect\" class=\"headerlink\" title=\"useInsertionEffect\"></a>useInsertionEffect</h1><h2 id=\"作用-2\"><a href=\"#作用-2\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>useInsertionEffects 适用于 CSS-in-JS 库作者。除非您正在开发 CSS-in-JS 库并且需要一个地方来注入样式，否则您可能需要 useEffects 或 useLayoutEffects。</p>\n<h2 id=\"动机-2\"><a href=\"#动机-2\" class=\"headerlink\" title=\"动机\"></a>动机</h2><p>用于 CSS-in-JS 库作者</p>\n<h2 id=\"场景及替换方案-2\"><a href=\"#场景及替换方案-2\" class=\"headerlink\" title=\"场景及替换方案\"></a>场景及替换方案</h2><p>如果您使用 CSS-in-JS，我们建议结合前两种方法（静态样式的 CSS 文件，动态样式的内联样式）。我们不推荐运行时<code>&lt;style&gt;</code>标签注入，原因有两个：</p>\n<ol>\n<li>运行时注入迫使浏览器更频繁地重新计算样式。</li>\n<li>如果在 React 生命周期中的错误时间发生，运行时注入可能会非常慢。</li>\n</ol>\n<p>第一个问题是无法解决的，但是 <code>useInsertionEffects</code> 可以帮助您解决第二个问题。</p>\n<h2 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>仅在客户端上运行。它们在服务器渲染期间不运行。</li>\n<li><code>useInsertionEffects</code> 内部不能更新状态。</li>\n<li>到 <code>useInsertionEffects</code> 运行时，还没有添加 ref，并且 DOM 还没有更新。</li>\n</ol>\n<h2 id=\"这比在渲染或-useLayoutEffects-期间注入样式更好吗？\"><a href=\"#这比在渲染或-useLayoutEffects-期间注入样式更好吗？\" class=\"headerlink\" title=\"这比在渲染或 useLayoutEffects 期间注入样式更好吗？\"></a>这比在渲染或 useLayoutEffects 期间注入样式更好吗？</h2><ol>\n<li>如果您在渲染期间插入样式并且 React 正在处理非阻塞更新，浏览器将在渲染组件树时每帧重新计算样式，这可能非常慢。</li>\n<li>因为它确保了当其他效果在你的组件中运行时，<code>&lt;style&gt;</code>标签已经被插入。否则，由于样式过时，常规效果中的布局计算将是错误的。</li>\n</ol>\n<h1 id=\"useSyncExternalStore\"><a href=\"#useSyncExternalStore\" class=\"headerlink\" title=\"useSyncExternalStore\"></a>useSyncExternalStore</h1><h2 id=\"作用-3\"><a href=\"#作用-3\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>订阅外部存储</p>\n<h2 id=\"动机-3\"><a href=\"#动机-3\" class=\"headerlink\" title=\"动机\"></a>动机</h2><p><code>useSyncExternalStore</code> 是一个新的钩子，它允许外部存储通过强制同步对存储的更新来支持并发读取。它在实现对外部数据源的订阅时消除了对 <code>useEffects</code> 的需求，建议用于与 React 外部状态集成的任何库</p>\n<h2 id=\"场景及替换方案-3\"><a href=\"#场景及替换方案-3\" class=\"headerlink\" title=\"场景及替换方案\"></a>场景及替换方案</h2><p>如果可能，我们建议将内置的 React 状态与<code>useState</code>和<code>useReducer</code>一起使用。<br>如果您需要与现有的非 React 代码集成，<code>useSyncExternalStore</code> API 非常有用。</p>\n<h2 id=\"注意事项-3\"><a href=\"#注意事项-3\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>重新渲染问题</strong></p>\n<ol>\n<li>如果 getSnapshot 返回值与上次不同，React 将重新渲染组件。</li>\n<li>如果实际发生了变化，您的 getSnapshot 对象应该只返回不同的对象。如果您的存储包含不可变数据，您可以直接返回该数据</li>\n</ol>\n<p><strong>订阅函数在每次重新渲染后被调用</strong></p>\n<p>此订阅函数是在组件内部定义的，因此每次重新渲染时都不同，如果在重新渲染之间传递不同的订阅功能，React 将重新订阅 store。</p>\n<ol>\n<li>如果这会导致性能问题并且想要避免重新订阅，请将订阅功能移到外部</li>\n<li>或者，将订阅包装到 useCallback 中以仅在某些参数更改时重新订阅：</li>\n</ol>\n<h2 id=\"原理实现\"><a href=\"#原理实现\" class=\"headerlink\" title=\"原理实现\"></a>原理实现</h2><!-- <a href=\"https://juejin.cn/post/7196689993082028091#heading-2\" target=\"_blank\" >见</a> -->\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; prettier-ignore\nexport function useSyncExternalStore&lt;T&gt;(\n  subscribe: (() &#x3D;&gt; void) &#x3D;&gt; () &#x3D;&gt; void, \n  getSnapshot: () &#x3D;&gt; T, \n  getServerSnapshot?: () &#x3D;&gt; T\n): T &#123;\n  const value &#x3D; getSnapshot();\n\n  const [&#123; inst &#125;, forceUpdate] &#x3D; useState(&#123; inst: &#123; value, getSnapshot &#125; &#125;);\n\n  useLayoutEffect(() &#x3D;&gt; &#123;\n    inst.value &#x3D; value;\n    inst.getSnapshot &#x3D; getSnapshot;\n\n    if (checkIfSnapshotChanged(inst)) &#123;\n      &#x2F;&#x2F; Force a re-render.\n      forceUpdate(&#123; inst &#125;);\n    &#125;\n  &#125;, [subscribe, value, getSnapshot]);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (checkIfSnapshotChanged(inst)) &#123;\n      &#x2F;&#x2F; Force a re-render.\n      forceUpdate(&#123; inst &#125;);\n    &#125;\n    const handleStoreChange &#x3D; () &#x3D;&gt; &#123;\n      if (checkIfSnapshotChanged(inst)) &#123;\n        &#x2F;&#x2F; Force a re-render.\n        forceUpdate(&#123; inst &#125;);\n      &#125;\n    &#125;;\n    &#x2F;&#x2F; Subscribe to the store and return a clean-up function.\n    return subscribe(handleStoreChange);\n  &#125;, [subscribe]);\n\n  useDebugValue(value);\n  return value;\n&#125;\n\nfunction checkIfSnapshotChanged&lt;T&gt;(inst: &#123; value: T, getSnapshot: () &#x3D;&gt; T &#125;): boolean &#123;\n  const latestGetSnapshot &#x3D; inst.getSnapshot;\n  const prevValue &#x3D; inst.value;\n  try &#123;\n    const nextValue &#x3D; latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  &#125; catch (error) &#123;\n    return true;\n  &#125;\n&#125;</code></pre>\n\n<p><strong>利用 React 的 useLayoutEffects 和 useEffects 执行时机来实现</strong></p>\n<ol>\n<li>首先 useLayoutEffects 是调用 getSnapshot 初始化 value，并将 value 和 getSnapshot 通过 state 维护起来</li>\n<li>其次是 useEffects 监听 subscribe, value, getSnapshot 的变化，如果有变化，直接更新</li>\n<li>最后是监听 subscribe ，返回 subscribe 的调用，并将 handleStoreChange 作为形参传入，对应 callback，当监听到 online 状态时，触发 handleStoreChange 的调用，从而触发 forceUpdate</li>\n<li>forceUpdate 会触发 useLayoutEffect 和 useEffect 的重新执行，也就可以获取到最新的状态</li>\n</ol>\n<p>事例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">export function useOnlineStatus() &#123;\n  const isOnline &#x3D; useSyncExternalStore(subscribe, getSnapshot);\n  return isOnline;\n&#125;\n\nfunction getSnapshot() &#123;\n  return navigator.onLine;\n&#125;\n\nfunction subscribe(callback &#x2F;*handleStoreChange*&#x2F;) &#123;\n  window.addEventListener(&#39;online&#39;, callback);\n  window.addEventListener(&#39;offline&#39;, callback);\n  return () &#x3D;&gt; &#123;\n    window.removeEventListener(&#39;online&#39;, callback);\n    window.removeEventListener(&#39;offline&#39;, callback);\n  &#125;;\n&#125;\n\nfunction ChatIndicator() &#123;\n  const isOnline &#x3D; useOnlineStatus();\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n","text":"useTransition作用在不阻塞 UI 的情况下更新状态 动机 转换是可中断的，这让用户无需等待重新渲染完成即可单击离开。 转换可防止不需要的加载指示器，这使用户可以避免导航时出现不和谐的跳转。 场景及替换方案 只能在组件中使用 要开始转换以响应某些 prop 或自定义 H...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"React","slug":"React","count":38,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":32,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#useTransition\"><span class=\"toc-text\">useTransition</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%9C%BA\"><span class=\"toc-text\">动机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">场景及替换方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#useDeferredValue\"><span class=\"toc-text\">useDeferredValue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8-1\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%9C%BA-1\"><span class=\"toc-text\">动机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88-1\"><span class=\"toc-text\">场景及替换方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%B7%E9%98%B1\"><span class=\"toc-text\">陷阱</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#useInsertionEffect\"><span class=\"toc-text\">useInsertionEffect</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8-2\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%9C%BA-2\"><span class=\"toc-text\">动机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88-2\"><span class=\"toc-text\">场景及替换方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E6%AF%94%E5%9C%A8%E6%B8%B2%E6%9F%93%E6%88%96-useLayoutEffects-%E6%9C%9F%E9%97%B4%E6%B3%A8%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%9B%B4%E5%A5%BD%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">这比在渲染或 useLayoutEffects 期间注入样式更好吗？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#useSyncExternalStore\"><span class=\"toc-text\">useSyncExternalStore</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8-3\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%9C%BA-3\"><span class=\"toc-text\">动机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88-3\"><span class=\"toc-text\">场景及替换方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">原理实现</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"蓝湖图标 快速转化代码","uid":"477b27802f823769fb08932565755076","slug":"2023-04-18","date":"2023-04-18T08:09:58.000Z","updated":"2023-07-08T01:06:25.353Z","comments":true,"path":"api/articles/2023-04-18.json","keywords":null,"cover":[],"text":"蓝湖规则化下载图标批量解压缩#!&#x2F;bin&#x2F;bash # 创建保存压缩结果的文件夹 mkdir unzipDir # 遍历当前文件夹及其子文件夹中的所有.png文件并进行压缩 find . -name &quot;*.zip&quot; -type f -pri...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"shell","slug":"shell","count":2,"path":"api/categories/shell.json"}],"tags":[{"name":"shell","slug":"shell","count":2,"path":"api/tags/shell.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Module Cheatsheet","uid":"fa1eb907999aa1ab8385490fbee6a85e","slug":"2023-04-11module","date":"2023-04-11T08:08:31.000Z","updated":"2023-07-20T14:58:47.207Z","comments":true,"path":"api/articles/2023-04-11module.json","keywords":null,"cover":[],"text":"动机最近在开发 RN 面板，开发完了，回顾下 react-native 官网，加深印象 组件导出&#x2F;入 &#x2F;&#x2F; Name Export | Name Import 命名导出&#x2F;入 export const name &#x3D; &#39;val...","link":"","photos":[],"count_time":{"symbolsCount":901,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}