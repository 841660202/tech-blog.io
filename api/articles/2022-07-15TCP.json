{"title":"前端基础-TCP","uid":"ca603a006bae6531fc585f1adf1fac4c","slug":"2022-07-15TCP","date":"2022-07-15T07:23:46.000Z","updated":"2023-08-01T12:36:45.467Z","comments":true,"path":"api/articles/2022-07-15TCP.json","keywords":null,"cover":[],"content":"<h2 id=\"TCP-的特性\"><a href=\"#TCP-的特性\" class=\"headerlink\" title=\"TCP 的特性\"></a>TCP 的特性</h2><ol>\n<li>TCP 提供⼀种<code>⾯向连接的</code>、<code>可靠的</code>、<code>字节流 </code>服务</li>\n<li>在⼀个 TCP 连接中，<code>仅双⽅进⾏彼此通信</code>。⼴播和多播不能⽤于 TCP</li>\n<li>TCP 使⽤<code>校验</code>、<code>确认</code>和<code>重传机制</code>来保证可靠传输</li>\n<li>TCP 使用<code>分节排序</code>和<code>累积确认</code>，来保证数据的顺序不变, 和⾮重复</li>\n<li>TCP 使⽤<code>滑动窗⼝</code>来实现流量控制，通过动态改变窗⼝的⼤⼩，进⾏拥塞控制</li>\n</ol>\n<h2 id=\"分节排序-和累积确认是什么？\"><a href=\"#分节排序-和累积确认是什么？\" class=\"headerlink\" title=\"分节排序 和累积确认是什么？\"></a>分节排序 和累积确认是什么？</h2><p>“分节排序”和”累积确认”都是 TCP 协议中用于实现可靠数据传输的重要机制。</p>\n<ol>\n<li>分节排序（Segment Sequencing）：<br>在 TCP 协议中，数据被分割成一个个称为”分节”的小块进行传输。由于数据在传输过程中可能会经过不同的路径和网络设备，这些分节有可能会以不同的顺序到达接收端。分节排序机制用于确保接收端能够按照正确的顺序将分节组装成完整的数据。</li>\n</ol>\n<p>每个分节都带有一个序列号（Sequence Number），接收端根据序列号来判断分节的正确顺序。TCP 协议会对分节进行排序，确保按照序列号的大小来组装数据，从而保证数据的完整性和正确性。</p>\n<ol start=\"2\">\n<li>累积确认（Cumulative Acknowledgment）：<br>累积确认是 TCP 协议中用于确认接收到的数据分节的机制。当接收端成功接收到一个或多个分节后，它会发送一个带有确认序列号（Acknowledgment Number）的确认报文给发送端。这个确认序列号表示接收端期望下一个接收的分节的序列号。</li>\n</ol>\n<p>累积确认是按照期望的下一个分节的序列号进行确认的。例如，如果接收端已经成功接收到序列号为 100 的分节，那么它会发送一个确认序列号为 101 的确认报文。这样发送端就知道接收端已经正确接收了序列号为 100 的分节，并且期望下一个分节的序列号是 101。</p>\n<p>通过累积确认，TCP 协议可以保证发送端只发送接收端尚未确认的分节，避免了数据的重复发送，提高了数据传输的效率和可靠性。</p>\n<p>综合上述两个机制，TCP 协议可以实现可靠的数据传输。发送端按照顺序编号发送数据分节，接收端根据序列号进行排序并发送累积确认，从而确保数据的完整性、正确性和有序性。这些机制使得 TCP 成为一种可靠的传输协议，在网络通信中广泛应用。</p>\n<h2 id=\"为什么要分节排序，直接传有什么问题\"><a href=\"#为什么要分节排序，直接传有什么问题\" class=\"headerlink\" title=\"为什么要分节排序，直接传有什么问题\"></a>为什么要分节排序，直接传有什么问题</h2><p>TCP 采用分节排序（Segment Sequencing）的机制是为了保证数据的可靠传输。直接传送整个数据的确可能会存在一些问题，特别是在网络传输过程中可能会发生以下情况：</p>\n<ol>\n<li><p>数据分包：在网络传输中，数据通常会被切分成小的数据包（分节），以便在网络中传输。这样做有利于提高网络利用率和传输效率。如果直接传送整个数据，可能会超过网络传输的最大数据包大小，导致数据无法发送或发送失败。</p>\n</li>\n<li><p>丢包：在网络传输过程中，数据包可能会因为网络拥塞、错误等原因而丢失。如果直接传输整个数据，一旦发生丢包，整个数据就需要重新传输，增加了传输时间和资源消耗。</p>\n</li>\n<li><p>乱序：在网络中，数据包可能会因为不同路径、不同链路的延迟不同而导致乱序到达接收端。如果直接传送整个数据，可能会导致数据包乱序，接收端无法正确地组装数据。</p>\n</li>\n</ol>\n<p>为了解决上述问题，TCP 将数据拆分成小的数据包（分节）进行传输，并对每个数据包附加一个序列号，接收端根据序列号进行排序和组装，确保数据按照正确的顺序传输。这样做的好处是：</p>\n<ol>\n<li><p>提高可靠性：通过分节排序，TCP 可以对接收到的数据包进行排序和组装，确保数据的完整性和正确性，提高数据传输的可靠性。</p>\n</li>\n<li><p>优化传输：由于分节后的数据包大小较小，减少了丢包时需要重新传输的数据量，从而减少了传输时间和资源消耗。</p>\n</li>\n<li><p>保持有序：通过序列号，TCP 可以保持数据的正确顺序，即使数据包乱序到达，接收端也可以按照序列号重新组装数据。</p>\n</li>\n</ol>\n<p>总的来说，TCP 的分节排序机制是为了保证数据在网络传输过程中的可靠性和有序性，以提高数据传输的效率和可靠性，确保数据能够正确地到达接收端。</p>\n<h2 id=\"TCP-拥塞控制\"><a href=\"#TCP-拥塞控制\" class=\"headerlink\" title=\"TCP 拥塞控制\"></a>TCP 拥塞控制</h2><p>TCP 拥塞控制是一种用于防止网络拥塞的机制。它通过一系列算法和策略来监测网络拥塞状态，自适应地调整数据的传输速率，以保持网络的稳定和性能。TCP 拥塞控制的目标是避免过度拥塞，提高数据传输的效率和可靠性。</p>\n<h2 id=\"为什么网络拥塞会丢包\"><a href=\"#为什么网络拥塞会丢包\" class=\"headerlink\" title=\"为什么网络拥塞会丢包\"></a>为什么网络拥塞会丢包</h2><p>网络拥塞会导致数据包丢失的主要原因是网络设备无法及时处理和转发所有的数据包。当网络中的数据流量超过网络的容量，数据包开始在网络设备（如路由器、交换机）的缓冲区中排队等待处理。如果缓冲区满了，新到达的数据包就无法进入缓冲区，这时就会发生数据包丢失。</p>\n<p><strong>网络设备的缓冲区有限，一旦缓冲区被填满，后续到达的数据包将无法被缓存和转发，只能被丢弃。丢包是网络设备为了保护自身免受过大的数据流量冲击而采取的一种自我保护机制。</strong></p>\n<p>拥塞引起的数据包丢失是网络中的一种正常现象。当网络出现拥塞时，网络设备会对数据包进行丢弃，这样可以降低网络负载，使网络能够恢复到较稳定的状态。</p>\n<p>TCP 协议中的拥塞控制机制是为了尽量避免过度拥塞和数据包丢失。TCP 通过拥塞控制算法，如慢启动、拥塞避免等，动态调整数据传输速率，使数据包在网络中的传输更加平稳和可靠。当网络拥塞时，TCP 会适时地减少发送速率，从而减轻网络负载，降低数据包丢失的可能性。</p>\n<p>虽然拥塞控制可以一定程度上减少数据包丢失，但在极端情况下（如网络严重拥塞或故障），仍然可能会发生数据包丢失。因此，在设计网络应用程序时，需要考虑到数据包丢失的情况，并在应用层进行相应的错误处理和重传机制，以保证数据的完整性和可靠性。</p>\n<h2 id=\"为什么-TCP-比-UDP-传的慢\"><a href=\"#为什么-TCP-比-UDP-传的慢\" class=\"headerlink\" title=\"为什么 TCP 比 UDP 传的慢\"></a>为什么 TCP 比 UDP 传的慢</h2><p>TCP 相对于 UDP 传输可能会被认为较慢，这主要是因为 TCP 在提供可靠性和数据完整性方面做了更多的工作，以保证数据的正确传输。以下是 TCP 相对于 UDP 传输较慢的主要原因：</p>\n<ol>\n<li><p>连接建立：TCP 在数据传输之前需要先建立连接，这涉及到三次握手的过程。连接建立会增加一定的延迟，而 UDP 不需要连接建立，因此 UDP 的传输可以更快开始。</p>\n</li>\n<li><p>拥塞控制：TCP 拥塞控制机制会根据网络状况动态调整传输速率，以避免网络拥塞。这种拥塞控制可能导致数据传输速率在网络中波动，而 UDP 则没有拥塞控制，传输速率更为稳定。</p>\n</li>\n<li><p>数据包排序：TCP 会对接收到的数据包进行排序和组装，以确保数据按照正确的顺序传输，这涉及到更多的处理和等待时间。而 UDP 则不对数据包排序，数据包之间的传输可能更快。</p>\n</li>\n<li><p>确认机制：TCP 采用累积确认机制，需要接收端确认接收到的数据，以确保数据的完整性。这导致了一定的传输延迟，而 UDP 不需要确认机制，传输速度更快。</p>\n</li>\n</ol>\n<p>尽管 TCP 传输可能相对较慢，但它提供了可靠性、数据完整性和拥塞控制等重要特性，适用于对数据可靠性要求较高的应用场景，如文件传输、网页加载等。而 UDP 适用于对实时性要求较高，但对数据可靠性要求相对较低的应用场景，如实时游戏、音频、视频传输等。在选择 TCP 或 UDP 时，需要根据具体的应用需求和网络状况做出合适的选择。</p>\n<h2 id=\"举一个-python-的例子\"><a href=\"#举一个-python-的例子\" class=\"headerlink\" title=\"举一个 python 的例子\"></a>举一个 python 的例子</h2><p>下面是修正后的例子，展示了 TCP 和 UDP 服务器端以及客户端代码：</p>\n<p>TCP 传输的服务器端代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\ndef tcp_server():\n    host &#x3D; &#39;127.0.0.1&#39;\n    port &#x3D; 12345\n\n    tcp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    tcp_socket.bind((host, port))\n    tcp_socket.listen(1)\n\n    print(&quot;TCP Server is listening on &#123;&#125;:&#123;&#125;&quot;.format(host, port))\n\n    conn, addr &#x3D; tcp_socket.accept()\n    print(&quot;Connected to &#123;&#125;:&#123;&#125;&quot;.format(addr[0], addr[1]))\n\n    data &#x3D; conn.recv(1024)\n    print(&quot;Received data:&quot;, data.decode())\n\n    conn.send(&quot;Hello from TCP Server!&quot;.encode())\n\n    conn.close()\n    tcp_socket.close()\n\ntcp_server()</code></pre>\n\n<p>TCP 传输的客户端代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\ndef tcp_client():\n    host &#x3D; &#39;127.0.0.1&#39;\n    port &#x3D; 12345\n\n    tcp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    tcp_socket.connect((host, port)) # connect\n\n    message &#x3D; &quot;Hello TCP Server!&quot;\n    tcp_socket.send(message.encode())\n\n    data &#x3D; tcp_socket.recv(1024)\n    print(&quot;Received from server:&quot;, data.decode())\n\n    tcp_socket.close()\n\ntcp_client()</code></pre>\n\n<p>UDP 传输的服务器端代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\ndef udp_server():\n    host &#x3D; &#39;127.0.0.1&#39;\n    port &#x3D; 12346\n\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    udp_socket.bind((host, port)) # bind？\n\n    print(&quot;UDP Server is listening on &#123;&#125;:&#123;&#125;&quot;.format(host, port))\n\n    data, addr &#x3D; udp_socket.recvfrom(1024)\n    print(&quot;Received data:&quot;, data.decode())\n\n    response &#x3D; &quot;Hello from UDP Server!&quot;\n    udp_socket.sendto(response.encode(), addr)\n\n    udp_socket.close()\n\nudp_server()</code></pre>\n\n<p>UDP 传输的客户端代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\ndef udp_client():\n    host &#x3D; &#39;127.0.0.1&#39;\n    port &#x3D; 12346\n\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    message &#x3D; &quot;Hello UDP Server!&quot;\n    udp_socket.sendto(message.encode(), (host, port))\n\n    data, addr &#x3D; udp_socket.recvfrom(1024)\n    print(&quot;Received from server:&quot;, data.decode())\n\n    udp_socket.close()\n\nudp_client()</code></pre>\n\n<p>现在，您可以看到 TCP 服务器端和 UDP 服务器端以及客户端代码有了明显的区别。TCP 服务器端和客户端之间需要建立连接，而 UDP 服务器端和客户端之间是无连接的传输。此外，TCP 服务器端和客户端的端口号也是不同的，以示区别。</p>\n<h2 id=\"socket-SOCK-DGRAM-与-socket-SOCK-STREAM\"><a href=\"#socket-SOCK-DGRAM-与-socket-SOCK-STREAM\" class=\"headerlink\" title=\"socket.SOCK_DGRAM 与 socket.SOCK_STREAM\"></a>socket.SOCK_DGRAM 与 socket.SOCK_STREAM</h2><p><code>socket.SOCK_DGRAM</code>和<code>socket.SOCK_STREAM</code>是 Python 中 socket 模块中的两个套接字类型，用于指定套接字的传输方式。</p>\n<ol>\n<li><code>socket.SOCK_DGRAM</code>：<br><code>socket.SOCK_DGRAM</code>表示创建一个使用 UDP 协议的数据报套接字（Datagram Socket）。UDP 是一种无连接的、不可靠的传输协议。使用 UDP 套接字时，数据被切分成数据包（数据报），每个数据包都包含了目标地址和端口信息。UDP 套接字发送数据时不需要建立连接，直接发送数据包给目标地址，也不需要等待对方的确认，因此传输速度较快。但 UDP 不保证数据传输的可靠性，可能会导致数据包的丢失或乱序。</li>\n</ol>\n<p>使用示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\nudp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</code></pre>\n\n<ol start=\"2\">\n<li><code>socket.SOCK_STREAM</code>：<br><code>socket.SOCK_STREAM</code>表示创建一个使用 TCP 协议的流式套接字（Stream Socket）。TCP 是一种面向连接的、可靠的传输协议。使用 TCP 套接字时，首先需要建立连接，然后在连接的基础上进行数据传输。TCP 套接字提供了拥塞控制、数据分节排序、确认机制等功能，保证数据传输的可靠性和有序性。但由于需要建立连接和进行确认等操作，传输速度较慢。</li>\n</ol>\n<p>使用示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\ntcp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></pre>\n\n<p>在实际应用中，选择使用<code>socket.SOCK_DGRAM</code>还是<code>socket.SOCK_STREAM</code>取决于应用程序的需求。如果对数据传输的实时性要求较高，而对数据传输的可靠性要求相对较低，可以选择 UDP；如果对数据传输的可靠性要求较高，可以选择 TCP。根据不同的场景和需求，灵活选择适合的套接字类型是很重要的。</p>\n<h2 id=\"如果客户端是-vue，该如何书写-tcp-和-udp\"><a href=\"#如果客户端是-vue，该如何书写-tcp-和-udp\" class=\"headerlink\" title=\"如果客户端是 vue，该如何书写 tcp 和 udp\"></a>如果客户端是 vue，该如何书写 tcp 和 udp</h2><p>在 Web 浏览器中，JavaScript（包括 Vue.js）不能直接访问 TCP 或 UDP 套接字，因为 Web 浏览器的 JavaScript 环境不允许直接进行原始的网络套接字编程。JavaScript 运行在浏览器的沙箱环境中，为了安全性考虑，浏览器限制了对底层网络协议的直接访问。</p>\n<p>要在 Web 客户端中使用 TCP 或 UDP，您可以通过以下几种方式：</p>\n<ol>\n<li><p>使用 HTTP 协议：Web 客户端（如 Vue.js 应用）可以通过浏览器内置的 XMLHttpRequest 或 Fetch API 与服务器进行 HTTP 通信。HTTP 是基于 TCP 协议的应用层协议，可以实现浏览器和服务器之间的双向通信。对于实时性要求不高的应用场景，使用 HTTP 也能满足大部分需求。</p>\n</li>\n<li><p>使用 WebSocket：WebSocket 是一种在 Web 浏览器和服务器之间进行全双工通信的协议。WebSocket 通过 HTTP 建立连接后升级到 WebSocket 协议，可以实现实时的双向通信。Vue.js 应用可以使用 WebSocket API 来与服务器进行 WebSocket 通信。</p>\n</li>\n<li><p>使用 WebRTC：WebRTC 是一种实时通信技术，允许在 Web 浏览器之间直接进行点对点的通信。WebRTC 可以用于实现实时音视频通话、文件传输等功能，也可以通过数据通道实现自定义的数据传输，类似 UDP 的功能。</p>\n</li>\n</ol>\n<p>请注意，上述方法都是基于浏览器提供的高层 API，使用更高层的协议（如 HTTP、WebSocket、WebRTC）来进行通信，而不是直接使用 TCP 或 UDP 套接字。如果您需要在 Web 客户端直接使用 TCP 或 UDP 套接字进行底层网络编程，通常需要借助于浏览器插件或 Native Client（如 Chrome Native Messaging）等技术，这会涉及到浏览器的安全限制和用户的授权问题，且并不推荐这样做。</p>\n<p>因此，通常情况下，在 Vue.js 或其他 Web 客户端应用中，建议使用高层协议（如 HTTP、WebSocket、WebRTC）来实现数据传输和通信，以确保安全性和兼容性。</p>\n<h2 id=\"fetch、WebSocket、WebRTC-各举-TCP-和-UDP-的例子\"><a href=\"#fetch、WebSocket、WebRTC-各举-TCP-和-UDP-的例子\" class=\"headerlink\" title=\"fetch、WebSocket、WebRTC 各举 TCP 和 UDP 的例子\"></a>fetch、WebSocket、WebRTC 各举 TCP 和 UDP 的例子</h2><ol>\n<li>使用 Fetch（基于 TCP）的例子：<br>Fetch API 是用于进行网络请求的现代 JavaScript API，它基于 HTTP 协议，因此使用的是 TCP 连接。下面是一个使用 Fetch 进行 GET 请求的例子：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;)\n  .then((response) &#x3D;&gt; response.json())\n  .then((data) &#x3D;&gt; console.log(data))\n  .catch((error) &#x3D;&gt; console.error(error));</code></pre>\n\n<ol start=\"2\">\n<li>使用 WebSocket（基于 TCP）的例子：<br>WebSocket API 允许在 Web 浏览器和服务器之间建立双向通信的连接，它是基于 TCP 协议的。下面是一个使用 WebSocket 建立连接并发送消息的例子：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const socket &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;echo.websocket.org&#39;);\n\nsocket.onopen &#x3D; () &#x3D;&gt; &#123;\n  console.log(&#39;WebSocket connection is open.&#39;);\n  socket.send(&#39;Hello WebSocket!&#39;);\n&#125;;\n\nsocket.onmessage &#x3D; (event) &#x3D;&gt; &#123;\n  console.log(&#39;Received message:&#39;, event.data);\n&#125;;\n\nsocket.onclose &#x3D; () &#x3D;&gt; &#123;\n  console.log(&#39;WebSocket connection is closed.&#39;);\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li>使用 WebRTC（可以基于 UDP 或 TCP）的例子：<br>WebRTC 是一种实时通信技术，用于在 Web 浏览器之间进行点对点的通信。WebRTC 可以通过数据通道实现自定义的数据传输，类似 UDP 的功能。下面是一个简化的 WebRTC 数据通道的例子：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 在两个浏览器中运行以下代码，彼此之间可以互相发送消息\n\n&#x2F;&#x2F; 发送端\nconst senderPeer &#x3D; new RTCPeerConnection();\nconst dataChannel &#x3D; senderPeer.createDataChannel(&#39;dataChannel&#39;);\n\ndataChannel.onopen &#x3D; () &#x3D;&gt; &#123;\n  console.log(&#39;Data channel is open.&#39;);\n  dataChannel.send(&#39;Hello WebRTC!&#39;);\n&#125;;\n\n&#x2F;&#x2F; 接收端\nconst receiverPeer &#x3D; new RTCPeerConnection();\nreceiverPeer.ondatachannel &#x3D; (event) &#x3D;&gt; &#123;\n  const dataChannel &#x3D; event.channel;\n\n  dataChannel.onmessage &#x3D; (event) &#x3D;&gt; &#123;\n    console.log(&#39;Received message:&#39;, event.data);\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; 然后通过信令服务器建立连接和交换SDP等信息</code></pre>\n\n<p>在 WebRTC 中，数据通道可以通过 TCP 或 UDP 传输，具体取决于网络环境和浏览器支持的传输方式。WebRTC 的底层传输是由浏览器自动决定的，不需要应用程序明确指定使用 TCP 还是 UDP。</p>\n<h2 id=\"TCP、UDP-的区别\"><a href=\"#TCP、UDP-的区别\" class=\"headerlink\" title=\"TCP、UDP 的区别\"></a>TCP、UDP 的区别</h2><!-- <img src=\"http://t-blog-images.aijs.top/img/202302031618179.webp\" style=\"object-fit: cover\" /> -->\n\n<ol>\n<li>TCP 是一种面向连接的单播协议,在 TCP 中,并不存在多播、广播的这种行为，<code>因为 TCP 报文段中能明确发送方和接受方的 IP 地址</code>。</li>\n<li>UDP 是无连接的 ,因为使用 UDP 协议的发送者和接受者之间不必存在任何长期的关系。它们没有建立连接过程，简单来说就是<code>发送即结束</code></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><small>协议</small></th>\n<th align=\"left\"><small>可靠性</small></th>\n<th align=\"left\"><small>双⼯性</small></th>\n<th align=\"left\"><small>连接性</small></th>\n<th align=\"left\"><small>有序性</small></th>\n<th align=\"left\"><small>有界性</small></th>\n<th align=\"left\"><small>拥塞控制</small></th>\n<th align=\"left\"><small>传输速度</small></th>\n<th align=\"left\"><small>量级</small></th>\n<th align=\"left\"><small>头部⼤⼩</small></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><small>TCP</small></td>\n<td align=\"left\"><small>可靠(重传机 制)</small></td>\n<td align=\"left\"><small>全双⼯(1:1)</small></td>\n<td align=\"left\"><small>⾯向连接</small></td>\n<td align=\"left\"><small>有序</br>(通过 SYN 排 序)</small></td>\n<td align=\"left\"><small>⽆,</br> 有粘包情况</small></td>\n<td align=\"left\"><small>有</small></td>\n<td align=\"left\"><small>慢</small></td>\n<td align=\"left\"><small>低</small></td>\n<td align=\"left\"><small>20~60 字节</small></td>\n</tr>\n<tr>\n<td align=\"left\"><small>UDP</small></td>\n<td align=\"left\"><small>不可靠</br>(丢包后 数据丢 失)</small></td>\n<td align=\"left\"><small>n:m</small></td>\n<td align=\"left\"><small>⽆连接</small></td>\n<td align=\"left\"><small>⽆序</small></td>\n<td align=\"left\"><small>有</br> ⽆粘包</small></td>\n<td align=\"left\"><small>⽆</small></td>\n<td align=\"left\"><small>快</small></td>\n<td align=\"left\"><small>⾼</small></td>\n<td align=\"left\"><small>8 字节</small></td>\n</tr>\n</tbody></table>\n<p><strong>意义不同</strong></p>\n<ol>\n<li>TCP: <code>Transmission Control Protocol</code>,传输控制协议</li>\n<li>UDP: <code>User Datagram Protocol</code>,用户数据报协议</li>\n</ol>\n<p><strong>双工、连接、可靠</strong></p>\n<ol>\n<li><code>双⼯性</code>：TCP 全双工（1:1），UDP(n:m)</li>\n<li><code>连接性</code>：TCP 面向连接，UDP 无链接</li>\n<li><code>可靠性</code>：TCP 可靠，有重传机制，UDP 不可靠，丢了就丢了</li>\n</ol>\n<p><strong>有序、有界、有控制</strong></p>\n<ol>\n<li><code>有序性</code>：TCP 有序，通过 SYN 排序，UDP 无序</li>\n<li><code>有界性</code>：TCP 无界，有粘包情况，UDP 有消息边界，无粘包</li>\n<li><code>有控制</code>：TCP 有拥塞控制，UDP 没有拥塞控制</li>\n</ol>\n<p><strong>有内容，也要有速度</strong></p>\n<ol>\n<li><code>头⼤</code>：TCP 头部大小 20-60 字节，UDP 头部大小 8 个字节</li>\n<li><code>量小</code>：TCP 传输量级低于 UDP</li>\n<li><code>传的慢</code>：TCP 相对于 UDP 而言要慢</li>\n</ol>\n<h2 id=\"如何理解-UDP-的“无连接”特性？\"><a href=\"#如何理解-UDP-的“无连接”特性？\" class=\"headerlink\" title=\"如何理解 UDP 的“无连接”特性？\"></a>如何理解 UDP 的“无连接”特性？</h2><p><a href=\"https://www.dandelioncloud.cn/article/details/1505563355480944641\" target=\"_blank\" >如何理解 UDP 的“无连接”特性？</a></p>\n<h2 id=\"TCP-粘包是怎么回事，如何处理\"><a href=\"#TCP-粘包是怎么回事，如何处理\" class=\"headerlink\" title=\"TCP 粘包是怎么回事，如何处理?\"></a>TCP 粘包是怎么回事，如何处理?</h2><h2 id=\"ChatGPT\"><a href=\"#ChatGPT\" class=\"headerlink\" title=\"ChatGPT\"></a>ChatGPT</h2><p>TCP 粘包问题是指在数据传输过程中，发送方发送的多个小数据包在接收方接收时粘在一起，形成一个大的数据包，或者一个大的数据包被拆分成多个小的数据包接收，导致接收方无法正确解析数据。</p>\n<p>这种现象是<strong>由于 TCP 是面向流的协议，在传输过程中会根据网络状况和缓冲区的情况将多个数据包合并成一个或将一个数据包拆分成多个，从而引起粘包问题</strong>。</p>\n<p>TCP 粘包的原因主要有两点：</p>\n<ol>\n<li><p><code>数据传输缓冲区</code>：TCP 为了提高传输效率，会将多个发送的小数据包合并成一个较大的数据包一次性发送，或者将一个较大的数据包拆分成多个小的数据包发送。接收方接收到数据后，可能将这些数据放入缓冲区，待全部接收完毕再进行处理。</p>\n</li>\n<li><p><code>数据传输速率不一致</code>：发送方和接收方的数据传输速率不一致，可能导致接收方连续接收多个数据包而没有及时处理，从而造成粘包。</p>\n</li>\n</ol>\n<p>处理 TCP 粘包问题主要有以下几种方法：</p>\n<ol>\n<li><p><code>固定长度</code>：发送方在发送数据时，将每个数据包固定长度，接收方按照固定长度进行接收和拆分。这样可以保证每次接收到的数据都是固定长度的，避免粘包问题。但如果数据长度不固定，则不适用此方法。</p>\n</li>\n<li><p><code>使用特殊字符作为分隔符</code>：发送方在每个数据包的末尾添加一个特殊字符作为分隔符，接收方通过检测特殊字符来拆分数据包。例如，使用换行符或自定义的特殊字符作为分隔符。</p>\n</li>\n<li><p><code>使用消息头</code>：在发送数据时，将每个数据包的长度作为消息头一起发送，接收方先接收消息头，然后根据消息头中指定的长度来接收和拆分数据包。这样接收方可以准确地知道每个数据包的长度，避免粘包问题。</p>\n</li>\n<li><p><code>使用边界标识</code>：发送方在每个数据包的前后加上边界标识，接收方通过检测边界标识来拆分数据包。例如，使用特定的字符串或字节序列作为边界标识。</p>\n</li>\n<li><p><code>基于应用层协议</code>：在应用层协议中定义数据包的格式和边界，确保发送方和接收方都能正确解析数据包。常见的应用层协议如 HTTP、WebSocket 等都会在协议中定义数据包的格式。</p>\n</li>\n</ol>\n<p>不同的处理方法适用于不同的情况，具体要根据实际应用场景和数据传输需求来选择合适的处理方式。在实际应用中，处理 TCP 粘包问题通常需要考虑数据的格式、传输频率、网络延迟等因素，综合考虑选择最适合的解决方案。</p>\n<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>可以参⻅⽹上流传⽐较⼴的⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:</p>\n<ol>\n<li>先接收到 data1, 然后接收到 data2 .</li>\n<li>先接收到 <code>data1 的部分数据</code>, 然后接收到 <code>data1 余下的部分</code>以及 <code>data2 的全部</code>.</li>\n<li>先接收到了 <code>data1 的全部数据</code>和 <code>data2 的部分数据</code>, 然后接收到了 <code>data2 的余下的数据</code>.</li>\n<li>⼀次性接收到了 data1 和 data2 的全部数据.</li>\n</ol>\n<p><code>其中的 2,3,4 就是我们常⻅的粘包的情况</code>.</p>\n<h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><ol>\n<li>默认情况下, TCP 连接会<code>启⽤延迟传送算法</code> (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有<code>多个数据</code>发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), <code>这样可以减少 IO 消耗提⾼性能</code>.</li>\n<li>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了.</li>\n<li>但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</li>\n</ol>\n<h3 id=\"对于处理粘包的问题-常⻅的解决⽅案有\"><a href=\"#对于处理粘包的问题-常⻅的解决⽅案有\" class=\"headerlink\" title=\"对于处理粘包的问题, 常⻅的解决⽅案有:\"></a>对于处理粘包的问题, 常⻅的解决⽅案有:</h3><ol>\n<li>关闭 Nagle 算法 （<code>场景：数据较大，频率不是特别高的场景</code>）</li>\n<li>多次发送之前间隔⼀个等待时间 （<code>场景：交互频率低的场景</code>）</li>\n<li>进⾏封包&#x2F;拆包（<code>场景：发送特征数据，收到后按特征数据进行分割</code>）</li>\n</ol>\n<h2 id=\"为什么-udp-不会粘包？\"><a href=\"#为什么-udp-不会粘包？\" class=\"headerlink\" title=\"为什么 udp 不会粘包？\"></a>为什么 udp 不会粘包？</h2><p><strong>数据包在发送和接收时是独立的</strong></p>\n<ol>\n<li><code>消息提取位</code> <code>TCP 协议是⾯向流的协议</code>，<code>UDP 是⾯向消息的协议 UDP 段都是⼀条消息</code>，应⽤程序必须<code>以消息为单位提取数据</code>，不能⼀次提取任意字节的数据</li>\n<li><code>消息边界</code> UDP<code>具有保护消息边界</code>，在每个 UDP 包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易 进⾏区分处理了。</li>\n<li><code>数据丢了不管</code> <code>传输协议</code>把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息&#96;。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收</li>\n</ol>\n<h2 id=\"TCP-三次握手\"><a href=\"#TCP-三次握手\" class=\"headerlink\" title=\"TCP 三次握手\"></a>TCP 三次握手</h2><p>所谓三次握⼿(Three-way Handshake)，是指建⽴⼀个 TCP 连接时，<code>需要客户端和服务器总共发送3个包</code>。</p>\n<p>三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信息。</p>\n<ol>\n<li>客户端：<code>SYN标志+序列号</code>,进入<code>SYN_SEND</code>状态</li>\n<li>服务端：<code>SYN标志+序列号+确认标识+确认序号</code>, 进入<code>SYN_RCVD</code>状态</li>\n<li>客户端：<code>确认标识+确认序号</code>，进入<code>ESTABLISHED</code>状态</li>\n</ol>\n<details class=\"custom-details\">\n<summary>点击查看更多</summary>\n<p><p>在 socket 编程中，客户端执⾏ connect() 时。将触发三次握⼿。</p>\n<ol>\n<li><p><code>第⼀次握⼿(SYN=1, seq=x)</code>: 客户端发送⼀个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X,保存在包头 的序列号(Sequence Number)字段⾥。 发送完毕后，客户端进⼊ SYN_SEND 状态。 <code>SYN标志+序列号+SYN_SEND</code></p>\n</li>\n<li><p><code>第⼆次握⼿(SYN=1, ACK=1, seq=y, ACKnum=x+1)</code>: 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域 ⾥，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进⼊ SYN_RCVD 状态。</p>\n</li>\n<li><p><code>第三次握⼿(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确 定字段中发送给对⽅</code>，并且在数据段放写 ISN 的+1 发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿ 结束。 三次握⼿的过程的示意图如下：</p>\n</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/20220715170016.webp\" />\n\n</p>\n</details>\n<h2 id=\"TCP-四次握手\"><a href=\"#TCP-四次握手\" class=\"headerlink\" title=\"TCP 四次握手\"></a>TCP 四次握手</h2><p>✨ TCP 的连接的拆除需要发送四个包，因此称为四次挥⼿(Four-way handshake)，也叫做改进的三次握⼿。<code>客户端或服务器均可主动发起挥⼿动作</code>，在 socket 编程中，任何⼀⽅执⾏ close() 操作即可产⽣挥⼿操作。</p>\n<ol>\n<li>客户端：<code>结束标识+序列号</code>,进⼊ <code>FIN_WAIT_1</code> 状态</li>\n<li>服务端：<code>确认标识+确认序号</code>,进⼊ <code>FIN_WAIT_1</code> 状态</li>\n<li>服务端：<code>结束标识+序列号</code>,进⼊ <code>FIN_WAIT_2</code> 状态</li>\n<li>客户端：<code>确认标识+确认序号</code>,进⼊ <code>TIME_WAIT</code> 状态</li>\n<li>后 续：服务端：进⼊ <code>CLOSED</code> 状态，客户端：<code>两个最⼤段⽣命周期</code>, 进⼊ <code>CLOSED</code> 状态</li>\n</ol>\n<details class=\"custom-details\">\n<summary>点击查看更多</summary>\n<ol>\n<li><code>第⼀次挥⼿(FIN=1，seq=x)</code> 假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为 1 的包，表示⾃⼰已经没有数据可以发送了，但是仍然 可以接受数据。 发送完毕后，客户端进⼊ FIN_WAIT_1 状态。</li>\n<li><code>第⼆次挥⼿(ACK=1，ACKnum=x+1)</code> 服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭 连接。 发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务 器端关闭连接。</li>\n<li><code>第三次挥⼿(FIN=1，seq=y)</code> 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。 TCP ⾯试题 54 发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个 ACK。</li>\n<li><code>第四次挥⼿(ACK=1，ACKnum=y+1)</code> 客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。</li>\n<li>客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。 四次挥⼿的示意图如下：</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/20220715170027.webp\" />\n\n\n</details>\n<h2 id=\"请求连接是三次，断开连接是四次\"><a href=\"#请求连接是三次，断开连接是四次\" class=\"headerlink\" title=\"请求连接是三次，断开连接是四次\"></a>请求连接是三次，断开连接是四次</h2><p><strong>简言之：收到后的确认应答，和结束应答是分开的</strong></p>\n<ol>\n<li>服务端：<code>确认标识+确认序号</code>,进⼊ <code>FIN_WAIT_1</code> 状态</li>\n<li>服务端：<code>结束标识+序列号</code>,进⼊ <code>FIN_WAIT_2</code> 状态</li>\n</ol>\n<p>分为两个，目的是在服务端发送完数据后，然后进行发送关闭信号</p>\n<h2 id=\"三次握手改为两次\"><a href=\"#三次握手改为两次\" class=\"headerlink\" title=\"三次握手改为两次\"></a>三次握手改为两次</h2><p>采用三次握手是为了<code>防止失效的连接请求报文段突然又传送到主机B，因而产生错误</code>。</p>\n<p>失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。</p>\n<p>考虑这样一种特殊情况：<code>主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。</code></p>\n<p>采用两次握手不行，原因就是上面说的<code>失效的连接请求</code>的特殊情况。</p>\n<p><strong>不是很恰当的例子</strong></p>\n<ol>\n<li>例子 1（3 次握手）：朋友：来吃饭 -&gt; 你：好咧，等我哈 -&gt; 朋友：👌。</li>\n<li>例子 2（2 次握手）：朋友：来吃饭 -&gt; 你（第二天你看到了）：好咧，等我哈。 朋友不在家（吃闭门羹）</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/nk298120/article/details/116596086\" target=\"_blank\" >TCP 三次握手如果使用二次握手代替则会出现的问题</a></p>\n","text":"TCP 的特性 TCP 提供⼀种⾯向连接的、可靠的、字节流 服务 在⼀个 TCP 连接中，仅双⽅进⾏彼此通信。⼴播和多播不能⽤于 TCP TCP 使⽤校验、确认和重传机制来保证可靠传输 TCP 使用分节排序和累积确认，来保证数据的顺序不变, 和⾮重复 TCP 使⽤滑动窗⼝来实现流...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-%E7%9A%84%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">TCP 的特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E8%8A%82%E6%8E%92%E5%BA%8F-%E5%92%8C%E7%B4%AF%E7%A7%AF%E7%A1%AE%E8%AE%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">分节排序 和累积确认是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E8%8A%82%E6%8E%92%E5%BA%8F%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BC%A0%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">为什么要分节排序，直接传有什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">TCP 拥塞控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E4%BC%9A%E4%B8%A2%E5%8C%85\"><span class=\"toc-text\">为什么网络拥塞会丢包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E6%AF%94-UDP-%E4%BC%A0%E7%9A%84%E6%85%A2\"><span class=\"toc-text\">为什么 TCP 比 UDP 传的慢</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%B8%80%E4%B8%AA-python-%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">举一个 python 的例子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#socket-SOCK-DGRAM-%E4%B8%8E-socket-SOCK-STREAM\"><span class=\"toc-text\">socket.SOCK_DGRAM 与 socket.SOCK_STREAM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%98%AF-vue%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E4%B9%A6%E5%86%99-tcp-%E5%92%8C-udp\"><span class=\"toc-text\">如果客户端是 vue，该如何书写 tcp 和 udp</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fetch%E3%80%81WebSocket%E3%80%81WebRTC-%E5%90%84%E4%B8%BE-TCP-%E5%92%8C-UDP-%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">fetch、WebSocket、WebRTC 各举 TCP 和 UDP 的例子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E3%80%81UDP-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">TCP、UDP 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-UDP-%E7%9A%84%E2%80%9C%E6%97%A0%E8%BF%9E%E6%8E%A5%E2%80%9D%E7%89%B9%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">如何理解 UDP 的“无连接”特性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86\"><span class=\"toc-text\">TCP 粘包是怎么回事，如何处理?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ChatGPT\"><span class=\"toc-text\">ChatGPT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">为什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%BA%8E%E5%A4%84%E7%90%86%E7%B2%98%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98-%E5%B8%B8%E2%BB%85%E7%9A%84%E8%A7%A3%E5%86%B3%E2%BD%85%E6%A1%88%E6%9C%89\"><span class=\"toc-text\">对于处理粘包的问题, 常⻅的解决⽅案有:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-udp-%E4%B8%8D%E4%BC%9A%E7%B2%98%E5%8C%85%EF%BC%9F\"><span class=\"toc-text\">为什么 udp 不会粘包？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TCP 三次握手</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TCP 四次握手</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%EF%BC%8C%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%9B%9B%E6%AC%A1\"><span class=\"toc-text\">请求连接是三次，断开连接是四次</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%94%B9%E4%B8%BA%E4%B8%A4%E6%AC%A1\"><span class=\"toc-text\">三次握手改为两次</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-http","uid":"2467747971f59a01619a9d5abd6f99a3","slug":"2022-07-16http","date":"2022-07-16T04:47:18.000Z","updated":"2023-08-04T07:58:19.218Z","comments":true,"path":"api/articles/2022-07-16http.json","keywords":null,"cover":[],"text":"HTTP ⽅法HTTP1.0 定义了三种请求⽅法： GET, POST 和 HEAD ⽅法HTTP1.1 新增了五种请求⽅法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT HTTP ⽅法的理论作⽤ GET: 通常⽤于请求服务器发送某些资源 POST:...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-安全","uid":"63e60c5ff1f2bb6bee35b8ec5818fb3b","slug":"2022-07-15安全","date":"2022-07-15T06:32:30.000Z","updated":"2023-02-28T15:57:25.663Z","comments":true,"path":"api/articles/2022-07-15安全.json","keywords":null,"cover":null,"text":"前端安全问题? 跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS. 早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚ ⾯, 其...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}