{"title":"前端基础 - 抽象相等比较","uid":"05496899eea5e85a89886906e98004b9","slug":"2022-11-01抽象相等比较","date":"2022-11-01T07:33:16.000Z","updated":"2022-11-02T12:30:25.273Z","comments":true,"path":"api/articles/2022-11-01抽象相等比较.json","keywords":null,"cover":[],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>本来是当一个很小的知识点来写的，发现越写越多，所以拆出来，单独做一篇文章，文章标题看上去很抽象</p>\n<h2 id=\"js-关于-valueOf-和-toString\"><a href=\"#js-关于-valueOf-和-toString\" class=\"headerlink\" title=\"js 关于 valueOf()和 toString()\"></a>js 关于 valueOf()和 toString()</h2><p><a href=\"https://blog.csdn.net/qq_42960676/article/details/88975442\" target=\"_blank\" >js 关于 valueOf()和 toString()</a></p>\n<p>链接内部有错误，</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; [];\nconsole.log(![]); &#x2F;&#x2F;false\n\n&#x2F;&#x2F; 注意\n\n[] &#x3D;&#x3D; false; &#x2F;&#x2F; true\n![]; &#x2F;&#x2F; false\n\n&#x2F;&#x2F; 上面不能推出：\n[] &#x3D;&#x3D; ![]; &#x2F;&#x2F; true\n[] !&#x3D; []; &#x2F;&#x2F; true\n&#x2F;&#x2F; 费脑子</code></pre>\n\n<p>把下面的看完来分析下：</p>\n<p><code>[] == false;</code>:</p>\n<ol>\n<li>对象与 boolean 比较，会将[]执行 ToPrimitive,</li>\n<li>ToPrimitive 第一参数非 Date 第二参数默认是 number 类型，执行 [].valueOf,返回[]非基本数据类型，执行.toString 返回 <code>&#39;&#39;</code>，</li>\n<li>转化成了：<code>字符串与false比较</code>,</li>\n<li>都要转化成 number， 0 &#x3D;&#x3D; 0， 返回 true</li>\n</ol>\n<p><code>![]</code> 这个怎么理解了按照之前那种理解 !’’,就变成 true 了， 错了错了，，</p>\n<ol>\n<li>根据 Falsy 的规则, []是 true, ![]就是 false</li>\n</ol>\n<p><code>[] == ![];</code>,</p>\n<ol>\n<li>! 优先级高于比较运算符， ![] 转化成 boolean 是 false ,</li>\n<li>对象和 false 比较，[].valueOf().toString() &#x3D;&#x3D; false, 也就是 ‘’ &#x3D;&#x3D;&#x3D; false,</li>\n<li>都要转化成 number 类型 ToNumber(‘’) &#x3D;&#x3D;&#x3D; ToNumber(false),</li>\n<li>0&#x3D;&#x3D;0 最终是 true</li>\n</ol>\n<p><code>[] != [];</code></p>\n<p>满足抽象相等表格对角线比较，转化成 <code>[] !== []</code>,所以是 true</p>\n<h2 id=\"严格等-x3D-x3D-x3D\"><a href=\"#严格等-x3D-x3D-x3D\" class=\"headerlink\" title=\"严格等 &#x3D;&#x3D;&#x3D;\"></a>严格等 &#x3D;&#x3D;&#x3D;</h2><ul>\n<li>对于除了数值之外的值，全等操作符使用明确的语义进行比较：一个值只与自身全等。</li>\n<li>对于数值，全等操作符使用略加修改的语义来处理两个特殊情况：<ul>\n<li>第一个情况是，浮点数 0 是不分正负的。区分 +0 和 -0 在解决一些特定的数学问题时是必要的，但是大部分情况下我们并不用关心。全等操作符认为这两个值是全等的。- 第二个情况是，浮点数包含了 NaN 值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。全等操作符认为 NaN 与其他任何值都不全等，包括它自己</li>\n</ul>\n</li>\n</ul>\n<p><code>（等式 (x !== x) 成立的唯一情况是 x 的值为 NaN）</code> 我想说 MDN 写错了，</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 数值类型比较的才是值，单有NaN这个奇葩存在\nNaN !&#x3D;&#x3D; NaN[] &#x2F;&#x2F; true\n&#x2F;&#x2F; 引用数据类型比较的不是值，而是其引用\n[] !&#x3D;&#x3D; [] &#x2F;&#x2F; true\n&#123;&#125; !&#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; true</code></pre>\n\n<h3 id=\"x3D-x3D-false-为什么是-true\"><a href=\"#x3D-x3D-false-为什么是-true\" class=\"headerlink\" title=\"[]&#x3D;&#x3D;false 为什么是 true?\"></a>[]&#x3D;&#x3D;false 为什么是 true?</h3><ol>\n<li>首先因为 &#x3D;&#x3D; 号有强制转换功能，右边 false 先变为 0，而接下来左边先会执行[].valueOf()返回本身还是[]</li>\n<li>因为执行 valueOf()不返回原始值（Number,String,Boolean,Underfined,Null),[]是个 Object，是引用类型，所以还会执行[].toString()方法返回” “，一个空字符串，最终空字符串在转换为 0，所以[]&#x3D;&#x3D;false，返回的是 true。</li>\n</ol>\n<h3 id=\"为什么会执行-valueOf-和-toString-他们又是什么东西？\"><a href=\"#为什么会执行-valueOf-和-toString-他们又是什么东西？\" class=\"headerlink\" title=\"为什么会执行 valueOf()和 toString(),他们又是什么东西？\"></a>为什么会执行 valueOf()和 toString(),他们又是什么东西？</h3><p>打印 Object 的 prototype 可以发现对象原型里有 valueOf()和 toString()这两个方法，数组也是对象所以说它也能调用这个方法</p>\n<h3 id=\"那为什么会调用这个方法呢？\"><a href=\"#那为什么会调用这个方法呢？\" class=\"headerlink\" title=\"那为什么会调用这个方法呢？\"></a>那为什么会调用这个方法呢？</h3><p>涉及到：抽象相等比较算法</p>\n<h2 id=\"抽象相等比较-x3D-x3D\"><a href=\"#抽象相等比较-x3D-x3D\" class=\"headerlink\" title=\"抽象相等比较 &#x3D;&#x3D;\"></a>抽象相等比较 &#x3D;&#x3D;</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#%E7%90%86%E8%A7%A3%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E7%9A%84%E6%A8%A1%E5%9E%8B\" target=\"_blank\" >表格内容出自 MDN,因为 MDN 有滚动，看着不方便，然后调整了下样式，这个截下来了</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202211011432143.webp\" />\n\n<p>在上面的表格中，</p>\n<ul>\n<li><code>ToNumber</code>(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符 +）的效果相同。</li>\n<li><code>ToPrimitive</code>(A)通过尝试调用 A 的 A.toString() 和 A.valueOf() 方法，将参数 A 转换为原始值（Primitive）。</li>\n<li><code>IsFalsy</code>,充当效仿 undefined 的角色的对象会 <code>等于 undefined/null</code> 对应上文 <code>javascript Falsy</code></li>\n</ul>\n<h2 id=\"表格数据怎么看\"><a href=\"#表格数据怎么看\" class=\"headerlink\" title=\"表格数据怎么看\"></a>表格数据怎么看</h2><ol>\n<li>横着看 图 1，看 undefined,null 两横行</li>\n<li>看对角线 图 2，同类型比较，看严格等 &#x3D;&#x3D;&#x3D;</li>\n<li>看对角线以下，<ul>\n<li>number 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较转化成 number,引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li>\n<li>string 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较转化成 number,引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li>\n<li>boolean 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较转化成 number,引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li>\n<li>引用 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较，boolean 类型会转化成 number，引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li>\n</ul>\n</li>\n<li><strong>（here1）</strong>位置，根据 ToPrimitive 在进行比较 ，ToPrimitive 是 number&#x2F;string 的，按照 number&#x2F;string 进行比较</li>\n</ol>\n<p>注意点:</p>\n<ul>\n<li>number 和 string，在与对象进行比较时候，并不是立即就转化的，要看 ToPrimitive 的执行结果，如果 ToPrimitive 转化结果刚好是同类型不用转化了，如果不是同类型，非 string,boolean 要转化成 number</li>\n<li>这里排除了 Symbol 和 Bigint, 排除的原因 Symbol 在一些转化中，会报错，所以上文限制了 es5 基本数据类型</li>\n</ul>\n<p><strong>图 1 横着看</strong><br><img src=\"http://t-blog-images.aijs.top/img/202211011501993.webp\" /></p>\n<p><strong>图 2 看对角线</strong><br><img src=\"http://t-blog-images.aijs.top/img/202211011502410.webp\" /></p>\n<p><strong>一般而言，根据 ECMAScript 规范，</strong></p>\n<ul>\n<li>所有的对象都与 undefined 和 null 不相等。</li>\n<li>但是大部分浏览器允许非常窄的一类对象（即，所有页面中的 <code>document.all</code> 对象），在某些情况下，<code>充当效仿 undefined 的角色</code>。</li>\n<li>相等操作符就是在这样的一个背景下。因此，<code>IsFalsy(A) 方法的值为 true，当且仅当 A 效仿 undefined。</code></li>\n<li>在其他所有情况下，一个对象都不会等于 undefined 或 null。</li>\n</ul>\n<p><strong>这幅图看上去很多，其实吧，背后的东西更多</strong></p>\n<ol>\n<li>Falsy</li>\n<li>ToNumber</li>\n<li>ToString</li>\n<li>ToPrimitive</li>\n</ol>\n<h2 id=\"Falsy\"><a href=\"#Falsy\" class=\"headerlink\" title=\"Falsy\"></a>Falsy</h2><p>当 JavaScript 期望一个布尔值，并被给与下面值中的一个时，它总是会被当做 false。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">undefined</td>\n<td align=\"left\">undefined - 原始值</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">null</td>\n<td align=\"left\">null - 缺少值</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">0 ,+0,-0, 0n, NaN</td>\n<td align=\"left\">数值 ,Bigint 0</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">“”,’’,&#96;&#96;</td>\n<td align=\"left\">空字符串</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">false</td>\n<td align=\"left\">false 关键字</td>\n</tr>\n</tbody></table>\n<h2 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h2><table>\n<thead>\n<tr>\n<th align=\"left\">input</th>\n<th align=\"left\">result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">undefined</td>\n<td align=\"left\">NaN</td>\n</tr>\n<tr>\n<td align=\"left\">null</td>\n<td align=\"left\">+0</td>\n</tr>\n<tr>\n<td align=\"left\">boolean</td>\n<td align=\"left\">+0 或 1</td>\n</tr>\n<tr>\n<td align=\"left\">number</td>\n<td align=\"left\">不转换</td>\n</tr>\n<tr>\n<td align=\"left\">string</td>\n<td align=\"left\"><a href=\"https://tc39.es/ecma262/#sec-stringtonumber\" target=\"_blank\" >参照§7.1.3.1 </a></td>\n</tr>\n<tr>\n<td align=\"left\">symbol</td>\n<td align=\"left\">TypeError</td>\n</tr>\n<tr>\n<td align=\"left\">Bigint</td>\n<td align=\"left\">TypeError</td>\n</tr>\n<tr>\n<td align=\"left\">object</td>\n<td align=\"left\">ToNumber(ToPrimitive(input,Number))</td>\n</tr>\n</tbody></table>\n<ol>\n<li>把字符串转换成数字，不是简单地“去掉引号”，具体规则参照§7.1.3.1。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Number(&quot;123&quot;); &#x2F;&#x2F;123\nNumber(&quot;&quot;); &#x2F;&#x2F;0\nNumber(&quot; 123 &quot;); &#x2F;&#x2F;123\nNumber(&quot;a123&quot;); &#x2F;&#x2F;NaN</code></pre>\n\n<ol start=\"2\">\n<li>把 symbol 转换成数字，会直接抛出类型错误。</li>\n<li>把对象转换成数字，会先进行 ToPrimitive(input,Number)，然后把得到的值进行转换</li>\n</ol>\n<h2 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString\"></a>ToString</h2><p>注意：要和对象的.toString 方法区分开，这两个完全没关系</p>\n<p><a href=\"https://tc39.es/ecma262/#sec-tostring\" target=\"_blank\" >https://tc39.es/ecma262/#sec-tostring</a></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">input</th>\n<th align=\"left\">result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">null</td>\n<td align=\"left\">‘null’</td>\n</tr>\n<tr>\n<td align=\"left\">undefined</td>\n<td align=\"left\">‘undefined’</td>\n</tr>\n<tr>\n<td align=\"left\">number</td>\n<td align=\"left\">Return Number::toString(argument, 10) 链接就不放了，打击人</td>\n</tr>\n<tr>\n<td align=\"left\">boolean</td>\n<td align=\"left\">‘true’或’false’</td>\n</tr>\n<tr>\n<td align=\"left\">string</td>\n<td align=\"left\">不转换</td>\n</tr>\n<tr>\n<td align=\"left\">symbol</td>\n<td align=\"left\">TypeError</td>\n</tr>\n<tr>\n<td align=\"left\">symbol</td>\n<td align=\"left\">Return BigInt::toString(argument, 10) 链接就不放了，打击人</td>\n</tr>\n<tr>\n<td align=\"left\">object</td>\n<td align=\"left\">ToString(ToPrimitive(input,String))</td>\n</tr>\n</tbody></table>\n<h2 id=\"ToPrimitive\"><a href=\"#ToPrimitive\" class=\"headerlink\" title=\"ToPrimitive\"></a>ToPrimitive</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; ToPrimitive api\nToPrimitive(input [, PreferredType])</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">inputTpye</th>\n<th align=\"left\">result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Null</td>\n<td align=\"left\">不转换，直接返回</td>\n</tr>\n<tr>\n<td align=\"left\">Undefined</td>\n<td align=\"left\">不转换，直接返回</td>\n</tr>\n<tr>\n<td align=\"left\">Number</td>\n<td align=\"left\">不转换，直接返回</td>\n</tr>\n<tr>\n<td align=\"left\">Boolean</td>\n<td align=\"left\">不转换，直接返回</td>\n</tr>\n<tr>\n<td align=\"left\">String</td>\n<td align=\"left\">不转换，直接返回</td>\n</tr>\n<tr>\n<td align=\"left\">Symbol</td>\n<td align=\"left\">不转换，直接返回</td>\n</tr>\n<tr>\n<td align=\"left\">Object</td>\n<td align=\"left\">按照下列步骤进行转换</td>\n</tr>\n</tbody></table>\n<p>在没有改写或自定义@@toPrimitive 方法的条件下，</p>\n<ul>\n<li>如果是 Date 求原值，则 PreferredType 是 String，其他均为 Number。</li>\n<li>PreferredType 是 <code>String</code>，则<code>先调用 toString()</code>，<code>结果不是原始值的话再调用 valueOf()</code>，还不是原始值的话则抛出错误；</li>\n<li>PreferredType 是 <code>Number</code>，则<code> 先调用 valueOf()</code>,<code>结果不是原始值的话再调用 toString() </code>，还不是原始值的话则抛出错误；</li>\n</ul>\n<h2 id=\"一元运算符\"><a href=\"#一元运算符\" class=\"headerlink\" title=\"一元运算符+\"></a>一元运算符+</h2><p>一元运算符“+”是用来把目标转化成数字类型的。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; UnaryExpression: +UnaryExpression;</code></pre>\n\n<ol>\n<li>把 UnaryExpression 的 result 赋值给 expr</li>\n<li>返回 ToNumber(GetValue(expr)).</li>\n</ol>\n<p>在一元“+”运算过程中，把目标直接转化成数字类型。一共涉及了一个方法：ToNumber()。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">+[]; &#x2F;&#x2F; 0\n\n&#x2F;&#x2F; 转化过程\n&#x2F;&#x2F; 1. [] 执行ToPrimitive([], &#39;number&#39;)\n&#x2F;&#x2F; 2. 首先会执行[].valueOf(),返回 []，不是基本数据类型，\n&#x2F;&#x2F; 执行 [].toString() 返回 &#39;&#39;， 是基本数据类型返回 &#39;&#39;\n&#x2F;&#x2F; +&#39;&#39; &#x3D;&gt; 0 ，所以结果为0</code></pre>\n\n<h2 id=\"装箱-x2F-拆箱\"><a href=\"#装箱-x2F-拆箱\" class=\"headerlink\" title=\"装箱&#x2F;拆箱\"></a>装箱&#x2F;拆箱</h2><p><a href=\"https://juejin.cn/post/6844903859765133320\" target=\"_blank\" >见</a></p>\n<h3 id=\"ecma-文档\"><a href=\"#ecma-文档\" class=\"headerlink\" title=\"ecma 文档\"></a>ecma 文档</h3><p>还是别看了吧，不建议去看</p>\n<p><a href=\"https://tc39.es/ecma262/#table-toboolean-conversions\" target=\"_blank\" >抽象操作</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#%E7%90%86%E8%A7%A3%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E7%9A%84%E6%A8%A1%E5%9E%8B\" target=\"_blank\" >JavaScript 中的相等性判断</a></p>\n<p><a href=\"https://sinaad.github.io/xfe/2016/04/15/ToPrimitive/\" target=\"_blank\" >js 隐式装箱-ToPrimitive</a></p>\n","text":"背景本来是当一个很小的知识点来写的，发现越写越多，所以拆出来，单独做一篇文章，文章标题看上去很抽象 js 关于 valueOf()和 toString()js 关于 valueOf()和 toString() 链接内部有错误， var a &#x3D; []; console.l...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":40,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":42,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%85%B3%E4%BA%8E-valueOf-%E5%92%8C-toString\"><span class=\"toc-text\">js 关于 valueOf()和 toString()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A5%E6%A0%BC%E7%AD%89-x3D-x3D-x3D\"><span class=\"toc-text\">严格等 &#x3D;&#x3D;&#x3D;</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D-x3D-false-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-true\"><span class=\"toc-text\">[]&#x3D;&#x3D;false 为什么是 true?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%89%A7%E8%A1%8C-valueOf-%E5%92%8C-toString-%E4%BB%96%E4%BB%AC%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F\"><span class=\"toc-text\">为什么会执行 valueOf()和 toString(),他们又是什么东西？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B0%83%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">那为什么会调用这个方法呢？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83-x3D-x3D\"><span class=\"toc-text\">抽象相等比较 &#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E7%9C%8B\"><span class=\"toc-text\">表格数据怎么看</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Falsy\"><span class=\"toc-text\">Falsy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ToNumber\"><span class=\"toc-text\">ToNumber</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ToString\"><span class=\"toc-text\">ToString</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ToPrimitive\"><span class=\"toc-text\">ToPrimitive</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">一元运算符+</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E7%AE%B1-x2F-%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">装箱&#x2F;拆箱</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ecma-%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">ecma 文档</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"了解elastic","uid":"36fb60db82f6c8fa6459c83e095ca31f","slug":"2022-11-02elastic","date":"2022-11-02T01:57:44.000Z","updated":"2022-11-02T12:30:25.268Z","comments":true,"path":"api/articles/2022-11-02elastic.json","keywords":null,"cover":null,"text":"背景很有意思ElasticSearch 的由来 elasticElasticSearch 实时搜索、分析引擎 ElasticSearch 基础入门篇 Elasticsearch 中文文档 7.3 Elasticsearch Guide: 8.5 在做 wiki 全文检索的时候，用...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"Elastic","slug":"Elastic","count":1,"path":"api/categories/Elastic.json"}],"tags":[{"name":"Elastic","slug":"Elastic","count":1,"path":"api/tags/Elastic.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础 技巧","uid":"97b3539570c7a7e3061d80de5bc34fae","slug":"2022-10-31js技巧","date":"2022-10-31T09:26:36.000Z","updated":"2022-10-31T13:18:24.946Z","comments":true,"path":"api/articles/2022-10-31js技巧.json","keywords":null,"cover":null,"text":"链接2022 年你需要了解的 13 种 JavaScript 代码技巧 如何用一行 CSS 实现 10 种现代布局 https://1linelayouts.glitch.me/ ","link":"","photos":[],"count_time":{"symbolsCount":90,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":40,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":42,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}