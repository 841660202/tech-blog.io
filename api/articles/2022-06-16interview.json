{"title":"面试题汇总","uid":"99460a2013287be2d51642da6dd169f8","slug":"2022-06-16interview","date":"2022-06-16T02:00:46.000Z","updated":"2023-02-20T21:20:56.462Z","comments":true,"path":"api/articles/2022-06-16interview.json","keywords":null,"cover":"https://img1.baidu.com/it/u=2500395055,2979935817&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=282","content":"<img src=\"https://img0.baidu.com/it/u=4204937089,859074527&fm=253&fmt=auto&app=138&f=JPEG?w=255&h=255\" />\n\n<p><a href=\"https://www.nowcoder.com/discuss/763567\" target=\"_blank\" >小红书前端面经</a></p>\n<p><a href=\"https://juejin.cn/post/7013953652578582558?share_token=ad9faad3-d177-4d34-9228-086d1d192112\" target=\"_blank\" >前端两年经验，历时一个月的面经和总结</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1663670\" target=\"_blank\" >【面试题】CSS 知识点整理(附答案)</a></p>\n<h2 id=\"HTTP-与-TCP\"><a href=\"#HTTP-与-TCP\" class=\"headerlink\" title=\"HTTP 与 TCP\"></a>HTTP 与 TCP</h2><p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117303320\" target=\"_blank\" >HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 对 HTTP 的改进</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117248731?spm=1001.2014.3001.5502\" target=\"_blank\" >TCP 三次握手</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117251247?spm=1001.2014.3001.5502\" target=\"_blank\" >TCP 四次挥手</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117257895?spm=1001.2014.3001.5502\" target=\"_blank\" >TCP 重传机制</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117263730?spm=1001.2014.3001.5502\" target=\"_blank\" >流量控制</a></p>\n<p><a href=\"https://www.likecs.com/show-204397172.html\" target=\"_blank\" >HTTP 请求和 TCP 链接的对应关系</a></p>\n<p><a href=\"https://blog.csdn.net/sinat_41696687/article/details/123458338\" target=\"_blank\" >彻底搞懂进程与线程之间的联系</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/420055986\" target=\"_blank\" >TLS&#x2F;SSL</a></p>\n<p><a href=\"https://juejin.cn/post/6871060072936505352\" target=\"_blank\" >TLS&#x2F;SSL</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1633945802472340217&wfr=spider&for=pc\" target=\"_blank\" >CDN</a></p>\n<p><a href=\"https://www.jianshu.com/p/60cc4ea02971/\" target=\"_blank\" >websocket 面试题</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_42674490/article/details/120647995\" target=\"_blank\" >websocket 使用</a></p>\n<p><strong>状态码的含义</strong></p>\n<p><a href=\"\" target=\"_blank\" >101 SwitchingProtocols，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议</a></p>\n<p><a href=\"https://www.bbsmax.com/A/gGdX3AWm54/\" target=\"_blank\" >204 状态码的含义</a></p>\n<p><a href=\"\" target=\"_blank\" >206 partial Content, 进行范围请求，打开 B 站的视频可以看到 206 请求</a></p>\n<h2 id=\"身份信息\"><a href=\"#身份信息\" class=\"headerlink\" title=\"身份信息\"></a>身份信息</h2><!-- <a href=\"https://zhuanlan.zhihu.com/p/482474619\" target=\"_blank\" >JWT 史上最全面试题(大厂常问)</a> -->\n\n<p><a href=\"https://www.php.cn/website-design-ask-484695.html\" target=\"_blank\" >JWT</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/66037342\" target=\"_blank\" >单站点登录</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><p><a href=\"https://blog.csdn.net/Dax1_/article/details/123185260\" target=\"_blank\" >总结 ES6 中 Map 和 Set 的特点与比较</a></p>\n<p><a href=\"https://www.itheima.com/news/20201110/183621.html\" target=\"_blank\" >从 async&#x2F;await 面试题看宏观任务和微观任务</a></p>\n<p><a href=\"https://www.jianshu.com/p/844e293d90a7\" target=\"_blank\" >箭头函数和普通函数的区别</a></p>\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><p><a href=\"https://zhuanlan.zhihu.com/p/142681436?from_voters_page=true\" target=\"_blank\" >js 堆和栈的区别</a><br><a href=\"https://segmentfault.com/a/1190000039042550\" target=\"_blank\" >什么是闭包</a><br><a href=\"https://blog.csdn.net/z591102/article/details/110634593#:~:text=%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%87%8C%EF%BC%8C-,%E5%B0%BE%E8%B0%83%E7%94%A8,-%E6%98%AF%E6%8C%87%E4%B8%80%E4%B8%AA\" target=\"_blank\" >tail 调用:尾调用优化（Tail Call Optimization，TCO）</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000013396601\" target=\"_blank\" >Promise 实现原理</a><br><a href=\"\" target=\"_blank\" >数据劫持 ……^_^</a></p>\n<hr />\n\n<p><strong>new 和 Object.create 都是创造一个对象的意思，二者有啥区别呢？</strong></p>\n<p><a href=\"https://www.jianshu.com/p/5f718f4a9441#:~:text=jack%27))-,Object.create(),-Object.create%E6%98%AF\" target=\"_blank\" >new &#x2F; Object.create()的实现原理</a></p>\n<ol>\n<li>用 Object.create()方法创建新对象,并使用现有对象提供新对象的 proto。</li>\n<li>Object.create() 是 es5 组合继承的 es6 api</li>\n<li>Object.create 克隆的对象也只能实现一级对象的深拷贝</li>\n<li><a href=\"https://blog.csdn.net/qq_48648782/article/details/118498146\" target=\"_blank\" >使用：创建子对象，让子对象继承父对象的同时，为子对象添加自有属性</a></li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function myNew() &#123;\n  let obj &#x3D; &#123;&#125;;\n\n  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数\n\n  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型\n\n  var result &#x3D; func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数\n\n  return  result intanceof Object ? result :  obj;\n&#125;\n\n\n\nfunction myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;</code></pre>\n\n  <hr />\n  \n<p><strong>对着图看</strong></p>\n<!-- ![](http://t-blog-images.aijs.top/img/20220617151244.webp) -->\n\n<img src=\"http://t-blog-images.aijs.top/img/202207271745383.webp\" />\n\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p><a href=\"http://t.zoukankan.com/Zzbj-p-13923489.html\" target=\"_blank\" > 强缓存、协商缓存发生在 8 中的哪些阶段</a></p>\n<h3 id=\"泄漏\"><a href=\"#泄漏\" class=\"headerlink\" title=\"泄漏\"></a>泄漏</h3><p><a href=\"https://mp.weixin.qq.com/s/0w6aWwpR3MAJnmyLwDnAzA\" target=\"_blank\" >JavaScript 内存泄漏防范之道</a></p>\n<ol>\n<li><code>意外的全局变量</code>：全局变量一直处于可访问状态，不会被 GC 回收</li>\n<li><code>闭包</code>：函数作用域变量在函数执行完后会被清理，前提是在函数外部没有引用它</li>\n<li><code>定时器</code>： 在 setTimeout 或 setInterval 的回调函数中引用某些对象</li>\n<li><code>事件监听器</code>：活动的事件监听器会阻止作用域内的变量被 GC 回收</li>\n<li><code>缓存</code>： 持续不断地往缓存里增加数据，没有定时清除无用的对象，也没有限制缓存大小，那么缓存就会像滚雪球一样越来越大</li>\n<li><code>分离的 DOM 元素</code>：如果 DOM 节点被 JavaScript 代码直接引用，即使从 DOM 树分离，也不会被 GC 回收</li>\n</ol>\n<h2 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h2><p><a href=\"https://blog.csdn.net/oscar999/article/details/121044091\" target=\"_blank\" >HTML 如何禁用缓存</a></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;meta\n  http-equiv&#x3D;&quot;Cache-Control&quot;\n  content&#x3D;&quot;no-cache, no-store, must-revalidate&quot;\n&#x2F;&gt;\n&lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot; &#x2F;&gt;\n&lt;meta http-equiv&#x3D;&quot;Expires&quot; content&#x3D;&quot;0&quot; &#x2F;&gt;</code></pre>\n\n<p><a href=\"https://www.jianshu.com/p/50c37351f873\" target=\"_blank\" >onload、DOMContentLoaded 区别</a></p>\n<ol>\n<li><code>onload</code> 事件触发时，页面上<code>所有的 DOM，样式表，脚本，图片</code>都已经加载完成了.</li>\n<li><code>DOMContentLoaded</code> 事件触发时，<code>仅当 DOM 加载完成</code>，不包括样式表，图片(譬如如果有 async 加载的脚本就不一定完成)</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; onload\nwindow.onload &#x3D; function () &#123;\n  var span &#x3D; document.querySelector(&quot;span&quot;);\n  console.log(span, &quot;onload&quot;);\n&#125;;\n&#x2F;&#x2F; DOMConetentLoaded\ndocument.addEventListener(&quot;DOMConetentLoaded&quot;, function () &#123;\n  var span &#x3D; document.querySelector(&quot;span&quot;);\n  console.log(span, &quot;DOMConetentLoaded&quot;);\n&#125;);</code></pre>\n\n<h2 id=\"CSS3\"><a href=\"#CSS3\" class=\"headerlink\" title=\"CSS3\"></a>CSS3</h2><h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><p><a href=\"https://www.jianshu.com/p/274a9b3200b4\" target=\"_blank\" >BFC 与清除浮动</a><br>根节点、浮动、定位[]、display[相关]、表格、网格、多列，总之是把一些子元素圈起来形成封闭的盒子，践行 BFC 的原则[独立、对外不影响（不重叠）]</p>\n<p><a href=\"https://blog.csdn.net/NCZB007/article/details/108440570\" target=\"_blank\" >.clearfix::after(清除浮动)中各个属性及值详细解说</a></p>\n<h3 id=\"单行多行文字截断\"><a href=\"#单行多行文字截断\" class=\"headerlink\" title=\"单行多行文字截断\"></a>单行多行文字截断</h3><p><a href=\"https://blog.csdn.net/weixin_43613849/article/details/116561796\" target=\"_blank\" >css 中实现单行多行文字截断</a></p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* 单行 *&#x2F;\ndiv &#123;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n&#125;\n\ndiv &#123;\n  display: -webkit-box;\n  overflow: hidden;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2; &#x2F;* 最多2行，2行装不下就用...省略 *&#x2F;\n&#125;</code></pre>\n\n<h3 id=\"css-modules\"><a href=\"#css-modules\" class=\"headerlink\" title=\"css-modules\"></a>css-modules</h3><p><a href=\"https://blog.csdn.net/xun__xing/article/details/108253723\" target=\"_blank\" >css module</a></p>\n<p>原理: 开启了 css module 后，css-loader 会将样式中的类名进行转换，转换为一个唯一的 hash 值。</p>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><p><a href=\"/#/post/2022-05-23width0\" target=\"_blank\" >flex 布局</a></p>\n<h3 id=\"0-5px\"><a href=\"#0-5px\" class=\"headerlink\" title=\"0.5px\"></a>0.5px</h3><p><a href=\"https://juejin.cn/post/6844903582370643975\" target=\"_blank\" >怎么画一条 0.5px 的边（更新）</a></p>\n<h3 id=\"总结伪类与伪元素\"><a href=\"#总结伪类与伪元素\" class=\"headerlink\" title=\"总结伪类与伪元素\"></a>总结伪类与伪元素</h3><p><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/\" target=\"_blank\" >总结伪类与伪元素</a></p>\n<div style=\"display: flex;flex-direction: row;flex-wrap: wrap\">\n\n  <img src=\"http://t-blog-images.aijs.top/img/20220625174736.png\" width=400 style=\"margin-right: 4px; margin-bottom: 4px\"/>\n\n  <img src=\"http://t-blog-images.aijs.top/img/20220625174712.png\" style=\"boject-fix: none; height: 200px\"/>\n</div>\n\n<p><code>:first-child</code> <code>:first-of-type</code> <code>:nth-child</code> <code>:nth-of-type</code> 区别</p>\n<ol>\n<li><p><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=2-,%3Afirst%2Dchild,-%E5%8C%B9%E9%85%8D%E5%85%83%E7%B4%A0%E7%9A%84\" target=\"_blank\" >:first-child</a> 匹配元素的第一个子元素。</p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%7D-,4%20first%2Dof%2Dtype,-%E5%8C%B9%E9%85%8D%E5%B1%9E%E4%BA%8E%E5%85%B6\" target=\"_blank\" >:first-of-type</a> 匹配属于其父元素的首个特定类型的子元素的每个元素。</p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%7D-,6%20%3Anth%2Dchild,-%3Anth%2Dchild%20%E6%A0%B9%E6%8D%AE\" target=\"_blank\" >:nth-child </a> 根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素示例如下：<br>1n+0，或 n，匹配每一个子元素。<br>2n+0，或 2n，匹配位置为 2、4、6、8… 的子元素，该表达式与关键字 even 等价。<br>2n+1 匹配位置为 1、3、5、7… 的子元素、该表达式与关键字 odd 等价。<br>3n+4 匹配位置为 4、7、10、13… 的子元素。<br>:nth-of-type</p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%E5%BC%80%E5%A7%8B%E8%AE%A1%E6%95%B0%E7%9A%84%E3%80%82-,8%20%3Anth%2Dof%2Dtype,-%3Anth%2Dof%2Dtype\" target=\"_blank\" >:nth-of-type</a> 与 nth-child 相似，不同之处在于它是只匹配特定类型的元素。</p>\n</li>\n</ol>\n<h2 id=\"position\"><a href=\"#position\" class=\"headerlink\" title=\"position\"></a>position</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" >position 的几个属性和含义</a></p>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top, right, bottom, left 和 z-index</code> 属性无效。</p>\n<h3 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a>relative</h3><ol>\n<li>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。</li>\n<li>position:relative 对 <code>table-*-group, table-row, table-column, table-cell, table-caption</code> 元素无效。</li>\n</ol>\n<h3 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a>absolute</h3><ol>\n<li>元素会被移出正常文档流，并不为元素预留空间，</li>\n<li>通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。</li>\n<li>绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</li>\n</ol>\n<h3 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a>fixed</h3><ol>\n<li>元素会被移出正常文档流，并不为元素预留空间，</li>\n<li>而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。</li>\n<li>打印时，元素会出现在的每页的固定位置。</li>\n<li><code>fixed 属性会创建新的层叠上下文</code>。</li>\n<li><code>并非永远以视口进行定位</code> 当元素祖先的 <code>transform、perspective、filter 或 backdrop-filter 属性非 none 时</code>，容器由视口改为该祖先。</li>\n</ol>\n<h3 id=\"sticky\"><a href=\"#sticky\" class=\"headerlink\" title=\"sticky\"></a>sticky</h3><ol>\n<li>元素根据正常文档流进行定位，然后相对它的<code>最近滚动祖先</code>（nearest scrolling ancestor）和 containing block（<code>最近块级祖先</code> nearest block-level ancestor），包括 <code>table-related</code> 元素，基于 top、right、bottom 和 left 的值进行偏移。</li>\n<li>偏移值不会影响任何其他元素的位置。</li>\n<li><code>该值总是创建一个新的层叠上下文（stacking context）</code>。</li>\n<li>注意，<code>一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上</code>（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），<code>即便这个祖先不是最近的真实可滚动祖先</code>。这有效地抑制了任何“sticky”行为（详情见 Github issue on W3C CSSWG）</li>\n</ol>\n<p><a href=\"\" target=\"_blank\" >说一下盒模型&gt;_&lt;</a></p>\n<p><a href=\"https://www.jianshu.com/p/ce7e4a997a2c\" target=\"_blank\" >vertical-align 到底怎么用</a></p>\n<p><a href=\"https://blog.csdn.net/qq_52340302/article/details/119238781\" target=\"_blank\" >六种常用的 css 三栏布局方法</a></p>\n<h2 id=\"响应式\"><a href=\"#响应式\" class=\"headerlink\" title=\"响应式\"></a>响应式</h2><p><a href=\"https://juejin.cn/post/6844903814332432397\" target=\"_blank\" >前端响应式布局原理与方案（详细版）</a></p>\n<p><a href=\"https://juejin.cn/post/6844903814332432397#:~:text=%E5%AF%B9%E4%BA%8E%E9%9C%80%E8%A6%81%E4%BF%9D%E6%8C%81%E5%AE%BD%E9%AB%98%E6%AF%94%E7%9A%84%E5%9B%BE%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%94%A8padding%2Dtop%E5%AE%9E%E7%8E%B0\" target=\"_blank\" >对于需要保持宽高比的图，应该用 padding-top 实现(一种为了解决，图片未加载出来，高度为 0 加载完后，有了内容发生跳变的现象)</a></p>\n<p><a href=\"https://juejin.cn/post/6844903814332432397#:~:text=1%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0%E7%BA%BF%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%99%AE%E9%80%9A%E5%B1%8F%E5%B9%95%E4%B8%8B1px%2C%E9%AB%98%E6%B8%85%E5%B1%8F%E5%B9%95%E4%B8%8B0.5px%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89%E9%87%87%E7%94%A8transform%E5%B1%9E%E6%80%A7scale%E5%AE%9E%E7%8E%B0\" target=\"_blank\" >1 物理像素线</a></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p><a href=\"https://www.nowcoder.com/exam/oj?tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295\" target=\"_blank\" >刷算法</a></p>\n<p><a href=\"https://juejin.cn/post/6844903846779551751\" target=\"_blank\" >前端面试之手写代码</a></p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><h3 id=\"防盗刷\"><a href=\"#防盗刷\" class=\"headerlink\" title=\"防盗刷\"></a>防盗刷</h3><p><a href=\"http://bigdata.ctocio.com.cn/bigdata/2022/0506/157700.html\" target=\"_blank\" >怎么实现接口防刷</a><br><a href=\"https://blog.csdn.net/liujiango/article/details/107372364\" target=\"_blank\" >怎么实现接口防刷</a></p>\n<p><strong>两种情况</strong></p>\n<ol>\n<li>恶意访问：使用工具进行不停的循环访问，占用系统资源，影响系统正常的对外服务</li>\n<li>支付接口、发短信接口等： 这种接口直接会导致企业的损失，更要注意。</li>\n</ol>\n<p><strong>应对措施：</strong></p>\n<ol>\n<li>限制访问的频率：每访问一次就给这个 IP+1，比如限制 1w 次，加到 1W 次就拒绝访问，直到过期，这种方式简单粗暴，对于恶意攻击、爬虫抓取很有效果，但难免会有误伤，影响正常的访问请求。</li>\n<li>人机校验，验证码</li>\n<li>限制发送频率：验证码发送频率 1 次&#x2F;分钟</li>\n<li>后端逻辑验证：避免重放攻击。如：已处理的订单不重复处理，增加时间戳，对于过期的请求不再进行处理</li>\n<li>接口访问监控：ip 访问频率异常，如果达到一定数量，进行系统报警，通知管理员，以降低损失</li>\n</ol>\n<h2 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h2><p><a href=\"https://blog.csdn.net/weixin_45743636/article/details/118100951\" target=\"_blank\" >computed 与 watch 的区别</a></p>\n<ol>\n<li><strong>功能上</strong>：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。</li>\n<li><strong>是否调用 缓存</strong>：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。</li>\n<li><strong>是否调用 return</strong>：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。</li>\n<li><strong>初次计算</strong> computed 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）</li>\n<li><strong>使用场景</strong>：<ol>\n<li>computed—-当一个属性受多个属性影响的时候，使用 computed—–购物车商品结算。</li>\n<li>watch–当一条数据影响多条数据的时候，使用 watch—–搜索框.</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h2><h3 id=\"React-Router-原理\"><a href=\"#React-Router-原理\" class=\"headerlink\" title=\"React Router 原理\"></a>React Router 原理</h3><p><a href=\"https://blog.csdn.net/weixin_39907713/article/details/111237885\" target=\"_blank\" >React Router 原理</a><br><a href=\"https://blog.csdn.net/qingfeng2020/article/details/121136648\" target=\"_blank\" >浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理</a><br><a href=\"https://blog.csdn.net/Android_boom/article/details/125200222\" target=\"_blank\" >React Router 源码解析</a></p>\n<h3 id=\"合成事件机制\"><a href=\"#合成事件机制\" class=\"headerlink\" title=\"合成事件机制\"></a>合成事件机制</h3><p><a href=\"https://wenku.baidu.com/view/dbc762dc740bf78a6529647d27284b73f342365b.html\" target=\"_blank\" >React 合成事件机制</a><br><a href=\"https://baijiahao.baidu.com/s?id=1727882238371627418&wfr=spider&for=pc\" target=\"_blank\" >web 前端培训 React 合成事件原理解析</a></p>\n<p><a href=\"https://www.jianshu.com/p/a68219093f88\" target=\"_blank\" >React 事件机制 – 合成事件</a></p>\n<ul>\n<li><strong>原生事件</strong><br>当某个元素触发某个事件（如 onclick ），顶层对象 Document 就会发出一个事件流，随着 DOM 树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。</li>\n<li><strong>事件目标</strong><br>当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</li>\n<li><strong>事件冒泡</strong><br>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。</li>\n<li><strong>事件委托&#x2F;事件代理</strong><ul>\n<li>简单理解就是将一个响应事件委托到另一个元素。</li>\n<li>当子节点被点击时，click 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。</li>\n</ul>\n</li>\n<li><strong>合成事件与原生事件区别</strong><ol>\n<li>事件名称命名方式不同</li>\n<li>事件处理函数写法不同</li>\n<li>阻止默认行为方式不同</li>\n</ol>\n</li>\n<li><strong>React 合成事件与原生事件执行顺序</strong><!-- - 类似洋葱，\n  捕获：`document => react 父级 => react 子级 => 父级原生 => 子级原生`\n  冒泡：`document <= react 父级 <= react 子级 <= 父级原生 <= 子级原生` --></li>\n<li><strong>阻止冒泡</strong></li>\n<li><strong>原生:</strong> 使用 <code>e.stopPropagation()</code> 或者 <code>e.cancelBubble=true</code>（IE）来阻止</li>\n<li><strong>react 中，</strong>阻止冒泡的方式有三种：<ol>\n<li>阻止合成事件与非合成事件（除了 document）之间的冒泡，以上两种方式都不适用，需要用到 e.target 判断。</li>\n<li>阻止合成事件与最外层 document 上的事件间的冒泡，用 <code>e.nativeEvent.stopImmediatePropagation()</code>;</li>\n<li>阻止合成事件间的冒泡，用 <code>e.stopPropagation()</code>;</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"阻止事件冒泡\"><a href=\"#阻止事件冒泡\" class=\"headerlink\" title=\"阻止事件冒泡\"></a>阻止事件冒泡</h3><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>react 阻止事件冒泡</p>\n<ol>\n<li><code>e.stopPropagation</code>用来阻止 React 模拟的事件冒泡</li>\n<li><code>e.stopImmediatePropagation</code> 没这个函数</li>\n<li><code>e.nativeEvent.stopPropagation</code> 原生事件对象的用于阻止 DOM 事件的进一步捕获或者冒泡</li>\n<li><code>e.nativeEvent.stopImmediatePropagation</code> 原生事件对象用于阻止 dom 事件的进一步捕获或者冒泡，且该元素的后续绑定相同事件类型的事件，都会被阻止</li>\n</ol>\n\n</div>\n<h3 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h3><p><a href=\"https://zhuanlan.zhihu.com/p/150993869#:~:text=memo%E5%87%BD%E6%95%B0-,2.4.4.%20%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%9B%E9%87%8F,-%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA\" target=\"_blank\" >setState 返回一样的引用，render 会执行吗</a></p>\n<h3 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h3><p><a href=\"https://zh-hans.reactjs.org/docs/hooks-effect.html#:~:text=%E6%89%A7%E8%A1%8C%E5%BD%93%E5%89%8D%20effect%20%E4%B9%8B%E5%89%8D%E5%AF%B9%E4%B8%8A%E4%B8%80%E4%B8%AA%20effect%20%E8%BF%9B%E8%A1%8C%E6%B8%85%E9%99%A4\" target=\"_blank\" >useEffect 的使用方法？useEffect 的 return 会在什么时候执行？useEffect 原理是什么？</a></p>\n<h3 id=\"PureComponent-和-Component-的区别\"><a href=\"#PureComponent-和-Component-的区别\" class=\"headerlink\" title=\"PureComponent 和 Component 的区别\"></a>PureComponent 和 Component 的区别</h3><p><a href=\"https://blog.csdn.net/leelxp/article/details/108218088#:~:text=%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8BPureComponent%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0\" target=\"_blank\" >PureComponent 和 Component 的区别是什么？ </a></p>\n<p><strong>区别</strong></p>\n<p>1、和 Component 的一个最大的区别在于 PureComponent 会自动执行 shouldComponentUpdate 函数，通过 shallowEqual 的浅对比，实现 react 的性能优化。而 Component 必须要通过自己去调用生命周期函数 shouldComponentUpdate 来实现 react 组件的优化。</p>\n<p>2、PureComponent <code>不仅会影响本身，而且会影响子组件，所以 PureComponent 最佳情况是展示组件</code></p>\n<p>（1）父子组件都是继承 Component 那么就是只要有更新，那么都会去重新渲染</p>\n<p>（2）父组件是继承 Component，而子组件是继承 PureComponent 那么就是看各自的 props 和 state</p>\n<p>（3）父子组件均继承 PureComponent，父子组件的更新就会依赖各自的 props 和 state</p>\n<p>（4）父组件继承 PureComponent,子组件是继承 Component，那么如果当父组件的 props 或者是 state 没有变化, 而子组件的 props 或者 state 有变化，那么此时子组件也不会有更新，因为子组件受到父组件的影响，父组件没有更新。</p>\n<p>3、<code>如果是数组和对象等引用类型，则要引用不同，才会渲染</code></p>\n<p>4、<code>如果 prop 和 state 每次都会变，那么 PureComponent 的效率还不如 Component</code>，因为进行浅比较也是需要时间</p>\n<p>5、<code>如果有 shouldComponentUpdate，则执行它，若没有这个方法会判断是不是 PureComponent，若是，进行浅比较</code></p>\n<h3 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h3><p><strong>单节点 Diff</strong><br><a href=\"https://react.iamkasong.com/diff/one.html\" target=\"_blank\" >单节点 diff</a></p>\n<p><strong>多节点 Diff</strong><br><a href=\"https://react.iamkasong.com/diff/multi.html#diff%E7%9A%84%E6%80%9D%E8%B7%AF:~:text=%23-,%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86,-%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D\" target=\"_blank\" >第一轮遍历</a></p>\n<p><a href=\"https://react.iamkasong.com/diff/multi.html#%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86:~:text=%23-,%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86,-%E5%AF%B9%E4%BA%8E%E7%AC%AC%E4%B8%80%E8%BD%AE\" target=\"_blank\" >第二轮遍历</a></p>\n<h3 id=\"手动实现-useEffect\"><a href=\"#手动实现-useEffect\" class=\"headerlink\" title=\"手动实现 useEffect\"></a>手动实现 useEffect</h3><p><a href=\"http://events.jianshu.io/p/21007102ee21\" target=\"_blank\" >React Hook：手动实现 useEffect</a></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 用来存储每次调用useEffect时传入的依赖数组\nlet prevDepsAry &#x3D; [];\n&#x2F;&#x2F; 用索引记录每个回调函数对应的依赖数组\nlet effectIndex &#x3D; 0;\n\nfunction useEffect(callback, depsAry) &#123;\n  &#x2F;&#x2F; 先判断参数类型是否正确\n  &#x2F;&#x2F; 如果callback不是函数类型，直接报错\n  if (Object.prototype.toString.call(callback) !&#x3D;&#x3D; &quot;[object Function]&quot;)\n    throw new Error(&#96;$&#123;callback&#125; 必须是一个函数类型&#96;);\n  &#x2F;&#x2F; 判断依赖数组有没有传入\n  if (depsAry &#x3D;&#x3D;&#x3D; undefined) &#123;\n    &#x2F;&#x2F; 没传入则每次函数重新调用都要执行回调函数\n    callback();\n  &#125; else &#123;\n    &#x2F;&#x2F; 判断depsAry是否是一个数组类型，如果不是，直接报错\n    if (Object.prototype.toString.call(depsAry) !&#x3D;&#x3D; &quot;[object Array]&quot;)\n      throw new Error(&#96;$&#123;depsAry&#125; 必须是一个数组类型&#96;);\n    &#x2F;&#x2F; 是数组类型，则需要获取上一次的依赖数组，逐项对比是否发生改变\n    let prevDeps &#x3D; prevDepsAry[effectIndex];\n    &#x2F;&#x2F; 判断是否发生改变，判断prevDeps是否存在\n    const hasChanged &#x3D; prevDeps\n      ? depsAry.every((dep, index) &#x3D;&gt; dep &#x3D;&#x3D;&#x3D; prevDeps[index]) &#x3D;&#x3D;&#x3D; false\n      : true;\n    if (hasChanged) &#123;\n      &#x2F;&#x2F; 有依赖发生改变，调用callback\n      callback();\n    &#125;\n    &#x2F;&#x2F; 同步本次更改后的依赖数组\n    prevDepsAry[effectIndex] &#x3D; depsAry;\n    effectIndex++;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"手动实现-useState\"><a href=\"#手动实现-useState\" class=\"headerlink\" title=\"手动实现 useState\"></a>手动实现 useState</h3><p><a href=\"http://events.jianshu.io/p/8256f8046066\" target=\"_blank\" >React Hook: 手动实现 useState</a></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 存储状态的数组\nlet state &#x3D; [];\n&#x2F;&#x2F; 存储更改状态方法的数组\nlet setters &#x3D; [];\n&#x2F;&#x2F; 用来记录状态和更改状态方法对应关系的下标\nlet stateIndex &#x3D; 0;\n\nfunction createSetter(index) &#123;\n  return function (newState) &#123;\n    state[index] &#x3D; newState;\n    render();\n  &#125;;\n&#125;\n\nfunction useState(initialState) &#123;\n  state[stateIndex] &#x3D; state[stateIndex] ? state[stateIndex] : initialState;\n  &#x2F;&#x2F; 采用闭包缓存每个state对应的setState\n  setters.push(createSetter(stateIndex));\n  const value &#x3D; state[stateIndex];\n  const setter &#x3D; setters[stateIndex];\n  &#x2F;&#x2F; 每创建完一组都要+1，用来作为下一组状态的索引\n  stateIndex++;\n  return [value, setter];\n&#125;</code></pre>\n\n<h3 id=\"⽣命周期\"><a href=\"#⽣命周期\" class=\"headerlink\" title=\"⽣命周期\"></a>⽣命周期</h3><p><a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" >react 生命周期图谱</a></p>\n<!-- <div>\n\n<iframe src=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" height=600 width='100%'></iframe>\n\n</div> -->\n\n<h3 id=\"Context-原理\"><a href=\"#Context-原理\" class=\"headerlink\" title=\"Context 原理\"></a>Context 原理</h3><p><a href=\"https://blog.csdn.net/weixin_45654582/article/details/122740125#:~:text=dependencies%20%E5%BB%BA%E7%AB%8B%E8%B5%B7%E5%85%B3%E8%81%94%E3%80%82-,Context%20%E5%8E%9F%E7%90%86,-Provider%20%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B\" target=\"_blank\" >Context 原理</a></p>\n<ol>\n<li>Provider 传递流程：Provider 的更新，会 深度遍历子代 fiber，消费 context 的 fiber 和父级链都会 提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。</li>\n<li>Context 订阅流程： contextType ， useContext， Consumer 会内部调用 readContext ，readContext 会把 fiber 上的 dependencies 属性 和 context 对象 建立起关联。</li>\n</ol>\n<h3 id=\"Hooks-的实现原理\"><a href=\"#Hooks-的实现原理\" class=\"headerlink\" title=\"Hooks 的实现原理\"></a>Hooks 的实现原理</h3><p><a href=\"https://blog.csdn.net/github_37759996/article/details/119187241\" target=\"_blank\" >Hooks 的实现原理</a></p>\n<h3 id=\"类组件和纯函数组件的区别\"><a href=\"#类组件和纯函数组件的区别\" class=\"headerlink\" title=\"类组件和纯函数组件的区别\"></a>类组件和纯函数组件的区别</h3><p><a href=\"https://blog.csdn.net/XH_jing/article/details/124188256\" target=\"_blank\" >类组件和纯函数组件的区别</a></p>\n<ol>\n<li>函数式编程，面向对象编程角度来说</li>\n<li>回到组件上，react hook 产生的原因 角度来说<ol>\n<li>组件状态复用艰难，</li>\n<li>让人无奈的 this 问题，</li>\n<li>高阶组件和函数组件的嵌套层次太深，</li>\n<li>复杂组件变得难以理解，</li>\n<li>以及难以记忆的生命周期等问题很让人头大</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"React-dom-绑定事件和原生事件\"><a href=\"#React-dom-绑定事件和原生事件\" class=\"headerlink\" title=\"React dom 绑定事件和原生事件\"></a>React dom 绑定事件和原生事件</h3><p><a href=\"https://www.php.cn/website-design-ask-491123.html\" target=\"_blank\" >React dom 绑定事件和原生事件有什么区别</a></p>\n<h3 id=\"useState-的源码解析\"><a href=\"#useState-的源码解析\" class=\"headerlink\" title=\"useState 的源码解析\"></a>useState 的源码解析</h3><p><a href=\"https://juejin.cn/post/7064444554727915556\" target=\"_blank\" >useState 的源码解析</a></p>\n<h3 id=\"什么是-Virtual-DOM？\"><a href=\"#什么是-Virtual-DOM？\" class=\"headerlink\" title=\"什么是 Virtual DOM？\"></a>什么是 Virtual DOM？</h3><p>Virtual DOM 是一种编程概念。在这个概念里， UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫做协调</p>\n<h3 id=\"什么是-“React-Fiber”？\"><a href=\"#什么是-“React-Fiber”？\" class=\"headerlink\" title=\"什么是 “React Fiber”？\"></a>什么是 “React Fiber”？</h3><p>Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染</p>\n<h2 id=\"稳操胜券\"><a href=\"#稳操胜券\" class=\"headerlink\" title=\"稳操胜券\"></a>稳操胜券</h2><p><a href=\"http://dljz.nicethemes.cn/news/show-13202.html\" target=\"_blank\" >看完这篇文章保你面试稳操胜券 ——（必考题）javaScript 篇</a></p>\n<p><a href=\"https://copyfuture.com/blogs-details/20211119150923474f\" target=\"_blank\" >看完这篇文章保你面试稳操胜券——基础篇（html&#x2F;css)</a></p>\n<p><a href=\"https://www.wangt.cc/2021/11/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%BF%9D%E4%BD%A0%E9%9D%A2%E8%AF%95%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8-vue%E7%AF%87/\" target=\"_blank\" >看完这篇文章保你面试稳操胜券-vue 篇</a></p>\n<p><a href=\"https://copyfuture.com/blogs-details/20211118131747765L\" target=\"_blank\" >读完这篇保你面试稳操胜券——前端面试题“骨灰级”总结</a></p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><a href=\"https://zhuanlan.zhihu.com/p/472733451\" target=\"_blank\" >Webpack | TreeShaking 工作原理</a><br><a href=\"https://juejin.cn/post/7039547628379439135\" target=\"_blank\" >什么是 tree-shaking</a><br><a href=\"https://juejin.cn/post/6844903924806189070\" target=\"_blank\" >Webpack 优化——将你的构建效率提速翻倍</a></p>\n<p><a href=\"https://juejin.cn/post/6844903685407916039\" target=\"_blank\" >Webpack 揭秘——走向高阶前端的必经之路</a></p>\n<p><a href=\"https://www.cnblogs.com/zhilili/p/14721434.html\" target=\"_blank\" >webpack（四）——webpack 里面的 plugin 和 loader 的区别</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/429072485\" target=\"_blank\" >跟着源码了解 Webpack 编译流程</a></p>\n<p><a href=\"https://blog.csdn.net/qq_39207948/article/details/102768659\" target=\"_blank\" >说一下对 tree-shaking 的了解，对 CommonJS 和 ESM 都可以用 tree-shaking 吗</a></p>\n<p><a href=\"https://www.webpackjs.com/contribute/writing-a-loader/\" target=\"_blank\" >编写一个 loader</a></p>\n<p><a href=\"https://www.webpackjs.com/contribute/writing-a-plugin/\" target=\"_blank\" >编写一个插件</a></p>\n<p><a href=\"https://juejin.cn/post/6918998088010956807\" target=\"_blank\" >Webpack5 的事件流和插件机制</a></p>\n<p><a href=\"\" target=\"_blank\" >px2rem-loader[9], 或者 pxrem-loader[10]原理 ^_^</a></p>\n<!-- <a href=\"https://cloud.tencent.com/developer/article/1432511\" target=\"_blank\" >Webpack 4 教程 - 第四部分，使用 SplitChunksPlugin 分离代码</a>\n<a href=\"https://cloud.tencent.com/developer/article/1432714\" target=\"_blank\" >Webpack 4 教程 - 第七部分 减少打包体积与 Tree Shaking</a>\n<a href=\"https://cloud.tencent.com/developer/article/1017015\" target=\"_blank\" >优化 Webpack 构建性能的几点建议</a>\n\n```js\n{\n  体积小： 合适的 source-map、减少代码体积、 webpack-bundle-analyzer进行分析\n  范围小：目录检索范围、检索路径\n  缓存：开启 loader、plugin 缓存\n  不重复打包：DLLPlugin + DLLRefrencePlugin 、 externals\n}\n``` -->\n\n<p><a href=\"https://javajgs.com/archives/36777\" target=\"_blank\" >常见 loader 使用 , 不好看，有乱七八糟图片，img 样式设置 display: none;</a></p>\n<ul>\n<li>文件相关：</li>\n<li>JSON 相关：</li>\n<li>JS&#x2F;TS 转译:</li>\n<li>模版：</li>\n<li>样式：</li>\n<li>lint 校验：</li>\n<li>测试：</li>\n<li>框架：</li>\n</ul>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p><a href=\"https://juejin.cn/post/6844903655330562062\" target=\"_blank\" >网站性能优化实战——从 12.67s 到 1.06s 的故事</a></p>\n<p><a href=\"/#/post/2022-05-12performance\" target=\"_blank\" >浏览器首屏优化-首屏时间获取</a></p>\n<h2 id=\"博客推荐\"><a href=\"#博客推荐\" class=\"headerlink\" title=\"博客推荐\"></a>博客推荐</h2><p><a href=\"https://blog.csdn.net/JHXL_?type=blog\" target=\"_blank\" >几何心凉</a></p>\n","text":" 小红书前端面经 前端两年经验，历时一个月的面经和总结 【面试题】CSS 知识点整理(附答案) HTTP 与 TCPHTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 对 HTTP 的改进 TCP 三次握手 TCP 四次挥手 TCP 重传机制 流量控制 H...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E4%B8%8E-TCP\"><span class=\"toc-text\">HTTP 与 TCP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BA%AB%E4%BB%BD%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">身份信息</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES6\"><span class=\"toc-text\">ES6</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js\"><span class=\"toc-text\">js</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8\"><span class=\"toc-text\">浏览器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">泄漏</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#html\"><span class=\"toc-text\">html</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS3\"><span class=\"toc-text\">CSS3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC\"><span class=\"toc-text\">BFC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E6%88%AA%E6%96%AD\"><span class=\"toc-text\">单行多行文字截断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#css-modules\"><span class=\"toc-text\">css-modules</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#flex\"><span class=\"toc-text\">flex</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#0-5px\"><span class=\"toc-text\">0.5px</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">总结伪类与伪元素</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#position\"><span class=\"toc-text\">position</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#static\"><span class=\"toc-text\">static</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#relative\"><span class=\"toc-text\">relative</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#absolute\"><span class=\"toc-text\">absolute</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fixed\"><span class=\"toc-text\">fixed</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sticky\"><span class=\"toc-text\">sticky</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E5%BC%8F\"><span class=\"toc-text\">响应式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%B2%E7%9B%97%E5%88%B7\"><span class=\"toc-text\">防盗刷</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue\"><span class=\"toc-text\">vue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react\"><span class=\"toc-text\">react</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">React Router 原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">合成事件机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1\"><span class=\"toc-text\">阻止事件冒泡</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setState\"><span class=\"toc-text\">setState</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect\"><span class=\"toc-text\">useEffect</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PureComponent-%E5%92%8C-Component-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">PureComponent 和 Component 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diff\"><span class=\"toc-text\">diff</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0-useEffect\"><span class=\"toc-text\">手动实现 useEffect</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0-useState\"><span class=\"toc-text\">手动实现 useState</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">⽣命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Context 原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hooks-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Hooks 的实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E7%BA%AF%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">类组件和纯函数组件的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-dom-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">React dom 绑定事件和原生事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useState-%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">useState 的源码解析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-Virtual-DOM%EF%BC%9F\"><span class=\"toc-text\">什么是 Virtual DOM？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-%E2%80%9CReact-Fiber%E2%80%9D%EF%BC%9F\"><span class=\"toc-text\">什么是 “React Fiber”？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8\"><span class=\"toc-text\">稳操胜券</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack\"><span class=\"toc-text\">webpack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90\"><span class=\"toc-text\">博客推荐</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"react-router v6.4.0 主要概念","uid":"3d2993e7928f66556e52e3c255cfa133","slug":"2022-06-21react-router","date":"2022-06-21T01:06:50.000Z","updated":"2022-09-16T15:00:54.073Z","comments":true,"path":"api/articles/2022-06-21react-router.json","keywords":null,"cover":[],"text":"官网React Router v6 is Here React Router v6 在客户端路由十年的基础上，采用了以前版本及其姐妹项目 Reach Router 的最佳功能，采用了迄今为止最小和最强大的软件包。 TIP 或许某一天，再见时，已不是 v6 官网分为两块内容 核心概...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"React","slug":"React","count":38,"path":"api/categories/React.json"}],"tags":[{"name":"react-router","slug":"react-router","count":3,"path":"api/tags/react-router.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"http错误信息","uid":"5b104c45df830a680c682d4e4b65c048","slug":"2022-06-15http","date":"2022-06-15T06:27:41.000Z","updated":"2022-09-16T13:54:56.144Z","comments":true,"path":"api/articles/2022-06-15http.json","keywords":null,"cover":null,"text":"http 错误信息Request URL: http:&#x2F;&#x2F;localhost:8888&#x2F;api&#x2F;redline&#x2F;content_management&#x2F;api&#x2F;kbs&#x2F;search&#x2F;conte...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"bug","slug":"bug","count":4,"path":"api/categories/bug.json"}],"tags":[{"name":"bug","slug":"bug","count":6,"path":"api/tags/bug.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}