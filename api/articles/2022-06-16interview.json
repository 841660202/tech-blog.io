{"title":"面试题汇总","uid":"99460a2013287be2d51642da6dd169f8","slug":"2022-06-16interview","date":"2022-06-16T02:00:46.000Z","updated":"2022-09-16T13:54:56.145Z","comments":true,"path":"api/articles/2022-06-16interview.json","keywords":null,"cover":"https://img1.baidu.com/it/u=2500395055,2979935817&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=282","content":"<img src=\"https://img0.baidu.com/it/u=4204937089,859074527&fm=253&fmt=auto&app=138&f=JPEG?w=255&h=255\" />\n\n<p><a href=\"https://www.nowcoder.com/discuss/763567\" target=\"_blank\" >小红书前端面经</a></p>\n<p><a href=\"https://juejin.cn/post/7013953652578582558?share_token=ad9faad3-d177-4d34-9228-086d1d192112\" target=\"_blank\" >前端两年经验，历时一个月的面经和总结</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1663670\" target=\"_blank\" >【面试题】CSS 知识点整理(附答案)</a></p>\n<h2 id=\"HTTP-与-TCP\"><a href=\"#HTTP-与-TCP\" class=\"headerlink\" title=\"HTTP 与 TCP\"></a>HTTP 与 TCP</h2><p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117303320\" target=\"_blank\" >HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 对 HTTP 的改进</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117248731?spm=1001.2014.3001.5502\" target=\"_blank\" >TCP 三次握手</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117251247?spm=1001.2014.3001.5502\" target=\"_blank\" >TCP 四次挥手</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117257895?spm=1001.2014.3001.5502\" target=\"_blank\" >TCP 重传机制</a></p>\n<p><a href=\"https://blog.csdn.net/SuNew_bee/article/details/117263730?spm=1001.2014.3001.5502\" target=\"_blank\" >流量控制</a></p>\n<p><a href=\"https://www.likecs.com/show-204397172.html\" target=\"_blank\" >HTTP 请求和 TCP 链接的对应关系</a></p>\n<p><a href=\"https://blog.csdn.net/sinat_41696687/article/details/123458338\" target=\"_blank\" >彻底搞懂进程与线程之间的联系</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/420055986\" target=\"_blank\" >TLS&#x2F;SSL</a></p>\n<p><a href=\"https://juejin.cn/post/6871060072936505352\" target=\"_blank\" >TLS&#x2F;SSL</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1633945802472340217&wfr=spider&for=pc\" target=\"_blank\" >CDN</a></p>\n<p><a href=\"https://www.jianshu.com/p/60cc4ea02971/\" target=\"_blank\" >websocket 面试题</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_42674490/article/details/120647995\" target=\"_blank\" >websocket 使用</a></p>\n<p><strong>状态码的含义</strong></p>\n<p><a href=\"\" target=\"_blank\" >101 SwitchingProtocols，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议</a></p>\n<p><a href=\"https://www.bbsmax.com/A/gGdX3AWm54/\" target=\"_blank\" >204 状态码的含义</a></p>\n<p><a href=\"\" target=\"_blank\" >206 partial Content, 进行范围请求，打开 B 站的视频可以看到 206 请求</a></p>\n<h2 id=\"身份信息\"><a href=\"#身份信息\" class=\"headerlink\" title=\"身份信息\"></a>身份信息</h2><!-- <a href=\"https://zhuanlan.zhihu.com/p/482474619\" target=\"_blank\" >JWT 史上最全面试题(大厂常问)</a> -->\n\n<p><a href=\"https://www.php.cn/website-design-ask-484695.html\" target=\"_blank\" >JWT</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/66037342\" target=\"_blank\" >单站点登录</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><p><a href=\"https://blog.csdn.net/Dax1_/article/details/123185260\" target=\"_blank\" >总结 ES6 中 Map 和 Set 的特点与比较</a></p>\n<p><a href=\"https://www.itheima.com/news/20201110/183621.html\" target=\"_blank\" >从 async&#x2F;await 面试题看宏观任务和微观任务</a></p>\n<p><a href=\"https://www.jianshu.com/p/844e293d90a7\" target=\"_blank\" >箭头函数和普通函数的区别</a></p>\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><p><a href=\"https://zhuanlan.zhihu.com/p/142681436?from_voters_page=true\" target=\"_blank\" >js 堆和栈的区别</a><br><a href=\"https://segmentfault.com/a/1190000039042550\" target=\"_blank\" >什么是闭包</a><br><a href=\"https://blog.csdn.net/z591102/article/details/110634593#:~:text=%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%87%8C%EF%BC%8C-,%E5%B0%BE%E8%B0%83%E7%94%A8,-%E6%98%AF%E6%8C%87%E4%B8%80%E4%B8%AA\" target=\"_blank\" >tail 调用:尾调用优化（Tail Call Optimization，TCO）</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000013396601\" target=\"_blank\" >Promise 实现原理</a><br><a href=\"\" target=\"_blank\" >数据劫持 ……^_^</a></p>\n<hr />\n\n<p><strong>new 和 Object.create 都是创造一个对象的意思，二者有啥区别呢？</strong></p>\n<p><a href=\"https://www.jianshu.com/p/5f718f4a9441#:~:text=jack%27))-,Object.create(),-Object.create%E6%98%AF\" target=\"_blank\" >new &#x2F; Object.create()的实现原理</a></p>\n<ul>\n<li>用 Object.create()方法创建新对象,并使用现有对象提供新对象的 proto。</li>\n<li>Object.create() 是 es5 组合继承的 es6 api</li>\n<li>Object.create 克隆的对象也只能实现一级对象的深拷贝</li>\n<li><a href=\"https://blog.csdn.net/qq_48648782/article/details/118498146\" target=\"_blank\" >使用：创建子对象，让子对象继承父对象的同时，为子对象添加自有属性</a></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function myNew() &#123;\n  let obj &#x3D; &#123;&#125;\n\n  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数\n  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型\n\n  func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数\n\n  return obj;\n&#125;\nfunction myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;</code></pre>\n\n  <hr />\n  \n<p><strong>对着图看</strong></p>\n<!-- ![](http://t-blog-images.aijs.top/img/20220617151244.webp) -->\n\n<img src=\"http://t-blog-images.aijs.top/img/202207271745383.webp\" />\n\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p><a href=\"http://t.zoukankan.com/Zzbj-p-13923489.html\" target=\"_blank\" > 强缓存、协商缓存发生在 8 中的哪些阶段</a><br><a href=\"https://mp.weixin.qq.com/s/0w6aWwpR3MAJnmyLwDnAzA\" target=\"_blank\" >JavaScript 内存泄漏防范之道</a></p>\n<h2 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h2><p><a href=\"https://blog.csdn.net/oscar999/article/details/121044091\" target=\"_blank\" >HTML 如何禁用缓存</a></p>\n<p><a href=\"https://www.jianshu.com/p/50c37351f873\" target=\"_blank\" >onload、DOMContentLoaded 区别</a></p>\n<h2 id=\"CSS3\"><a href=\"#CSS3\" class=\"headerlink\" title=\"CSS3\"></a>CSS3</h2><p><a href=\"https://www.jianshu.com/p/274a9b3200b4\" target=\"_blank\" >BFC 与清除浮动</a><br>根节点、浮动、定位[]、display[相关]、表格、网格、多列，总之是把一些子元素圈起来形成封闭的盒子，践行 BFC 的原则[独立、对外不影响（不重叠）]</p>\n<p><a href=\"https://blog.csdn.net/NCZB007/article/details/108440570\" target=\"_blank\" >.clearfix::after(清除浮动)中各个属性及值详细解说</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_43613849/article/details/116561796\" target=\"_blank\" >css 中实现单行多行文字截断</a><br><a href=\"https://blog.csdn.net/qq_39221436/article/details/124450355\" target=\"_blank\" > css-modules 来深入理解它的原理</a></p>\n<p><a href=\"https://blog.csdn.net/xun__xing/article/details/108253723\" target=\"_blank\" >css module</a></p>\n<p><a href=\"http://v.aijs.top/post/2022-05-23width0\" target=\"_blank\" >flex 布局</a></p>\n<p><a href=\"https://juejin.cn/post/6844903582370643975\" target=\"_blank\" >怎么画一条 0.5px 的边（更新）</a></p>\n<p><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/\" target=\"_blank\" >总结伪类与伪元素</a></p>\n<div style=\"display: flex;flex-direction: row;flex-wrap: wrap\">\n\n  <img src=\"http://t-blog-images.aijs.top/img/20220625174736.png\" width=400 style=\"margin-right: 4px; margin-bottom: 4px\"/>\n\n  <img src=\"http://t-blog-images.aijs.top/img/20220625174712.png\" style=\"boject-fix: none; height: 200px\"/>\n</div>\n\n<p><code>:first-child</code> <code>:first-of-type</code> <code>:nth-child</code> <code>:nth-of-type</code> 区别</p>\n<ul>\n<li><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=2-,%3Afirst%2Dchild,-%E5%8C%B9%E9%85%8D%E5%85%83%E7%B4%A0%E7%9A%84\" target=\"_blank\" >:first-child</a> 匹配元素的第一个子元素。</li>\n<li><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%7D-,4%20first%2Dof%2Dtype,-%E5%8C%B9%E9%85%8D%E5%B1%9E%E4%BA%8E%E5%85%B6\" target=\"_blank\" >:first-of-type</a> 匹配属于其父元素的首个特定类型的子元素的每个元素。</li>\n<li><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%7D-,6%20%3Anth%2Dchild,-%3Anth%2Dchild%20%E6%A0%B9%E6%8D%AE\" target=\"_blank\" >:nth-child </a> 根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素示例如下：<br>1n+0，或 n，匹配每一个子元素。<br>2n+0，或 2n，匹配位置为 2、4、6、8… 的子元素，该表达式与关键字 even 等价。<br>2n+1 匹配位置为 1、3、5、7… 的子元素、该表达式与关键字 odd 等价。<br>3n+4 匹配位置为 4、7、10、13… 的子元素。<br>:nth-of-type</li>\n<li><a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%E5%BC%80%E5%A7%8B%E8%AE%A1%E6%95%B0%E7%9A%84%E3%80%82-,8%20%3Anth%2Dof%2Dtype,-%3Anth%2Dof%2Dtype\" target=\"_blank\" >:nth-of-type</a> 与 nth-child 相似，不同之处在于它是只匹配特定类型的元素。</li>\n</ul>\n<p><a href=\"https://www.runoob.com/cssref/pr-class-position.html\" target=\"_blank\" >position 的几个属性和含义</a></p>\n<p><a href=\"\" target=\"_blank\" >说一下盒模型&gt;_&lt;</a></p>\n<p><a href=\"https://www.jianshu.com/p/ce7e4a997a2c\" target=\"_blank\" >vertical-align 到底怎么用</a></p>\n<p><a href=\"https://blog.csdn.net/qq_52340302/article/details/119238781\" target=\"_blank\" >六种常用的 css 三栏布局方法</a></p>\n<h2 id=\"响应式\"><a href=\"#响应式\" class=\"headerlink\" title=\"响应式\"></a>响应式</h2><p><a href=\"https://juejin.cn/post/6844903814332432397\" target=\"_blank\" >前端响应式布局原理与方案（详细版）</a></p>\n<p><a href=\"https://juejin.cn/post/6844903814332432397#:~:text=%E5%AF%B9%E4%BA%8E%E9%9C%80%E8%A6%81%E4%BF%9D%E6%8C%81%E5%AE%BD%E9%AB%98%E6%AF%94%E7%9A%84%E5%9B%BE%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%94%A8padding%2Dtop%E5%AE%9E%E7%8E%B0\" target=\"_blank\" >对于需要保持宽高比的图，应该用 padding-top 实现(一种为了解决，图片未加载出来，高度为 0 加载完后，有了内容发生跳变的现象)</a></p>\n<p><a href=\"https://juejin.cn/post/6844903814332432397#:~:text=1%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0%E7%BA%BF%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%99%AE%E9%80%9A%E5%B1%8F%E5%B9%95%E4%B8%8B1px%2C%E9%AB%98%E6%B8%85%E5%B1%8F%E5%B9%95%E4%B8%8B0.5px%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89%E9%87%87%E7%94%A8transform%E5%B1%9E%E6%80%A7scale%E5%AE%9E%E7%8E%B0\" target=\"_blank\" >1 物理像素线</a></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p><a href=\"https://www.nowcoder.com/exam/oj?tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295\" target=\"_blank\" >刷算法</a></p>\n<p><a href=\"https://juejin.cn/post/6844903846779551751\" target=\"_blank\" >前端面试之手写代码</a></p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p><a href=\"http://bigdata.ctocio.com.cn/bigdata/2022/0506/157700.html\" target=\"_blank\" >怎么实现接口防刷</a><br><a href=\"https://blog.csdn.net/liujiango/article/details/107372364\" target=\"_blank\" >怎么实现接口防刷</a></p>\n<h2 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h2><p><a href=\"https://blog.csdn.net/weixin_45743636/article/details/118100951\" target=\"_blank\" >computed 与 watch 的区别</a></p>\n<p>1、<strong>功能上</strong>：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。<br>2、<strong>是否调用 缓存</strong>：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。<br>3、<strong>是否调用 return</strong>：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。<br>4、<strong>computed</strong> 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）<br>5、<strong>使用场景</strong>：computed—-当一个属性受多个属性影响的时候，使用 computed—–购物车商品结算。watch–当一条数据影响多条数据的时候，使用 watch—–搜索框.</p>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h2><p><a href=\"https://blog.csdn.net/weixin_39907713/article/details/111237885\" target=\"_blank\" >React Router 原理</a><br><a href=\"https://blog.csdn.net/qingfeng2020/article/details/121136648\" target=\"_blank\" >浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理</a></p>\n<p><a href=\"https://blog.csdn.net/Android_boom/article/details/125200222\" target=\"_blank\" >React Router 源码解析</a><br><a href=\"https://wenku.baidu.com/view/dbc762dc740bf78a6529647d27284b73f342365b.html\" target=\"_blank\" >React 合成事件机制</a><br><a href=\"https://baijiahao.baidu.com/s?id=1727882238371627418&wfr=spider&for=pc\" target=\"_blank\" >web 前端培训 React 合成事件原理解析</a></p>\n<p><a href=\"https://www.jianshu.com/p/a68219093f88\" target=\"_blank\" >React 事件机制 – 合成事件</a></p>\n<ul>\n<li><strong>原生事件</strong><br>当某个元素触发某个事件（如 onclick ），顶层对象 Document 就会发出一个事件流，随着 DOM 树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。</li>\n<li><strong>事件目标</strong><br>当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</li>\n<li><strong>事件冒泡</strong><br>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。</li>\n<li><strong>事件委托&#x2F;事件代理</strong><ul>\n<li>简单理解就是将一个响应事件委托到另一个元素。</li>\n<li>当子节点被点击时，click 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。</li>\n</ul>\n</li>\n<li><strong>合成事件与原生事件区别</strong><ul>\n<li>事件名称命名方式不同</li>\n<li>事件处理函数写法不同</li>\n<li>阻止默认行为方式不同</li>\n</ul>\n</li>\n<li><strong>React 合成事件与原生事件执行顺序</strong><!-- - 类似洋葱，\n  捕获：`document => react 父级 => react 子级 => 父级原生 => 子级原生`\n  冒泡：`document <= react 父级 <= react 子级 <= 父级原生 <= 子级原生` --></li>\n<li><strong>阻止冒泡</strong></li>\n<li><strong>原生:</strong> 使用 <code>e.stopPropagation()</code> 或者 <code>e.cancelBubble=true</code>（IE）来阻止</li>\n<li><strong>react 中，</strong>阻止冒泡的方式有三种：<ol>\n<li>阻止合成事件与非合成事件（除了 document）之间的冒泡，以上两种方式都不适用，需要用到 e.target 判断。</li>\n<li>阻止合成事件与最外层 document 上的事件间的冒泡，用 <code>e.nativeEvent.stopImmediatePropagation()</code>;</li>\n<li>阻止合成事件间的冒泡，用 <code>e.stopPropagation()</code>;</li>\n</ol>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>react 阻止事件冒泡</p>\n<ul>\n<li><code>e.stopPropagation</code>用来阻止 React 模拟的事件冒泡</li>\n<li><code>e.stopImmediatePropagation</code> 没这个函数</li>\n<li><code>e.nativeEvent.stopPropagation</code> 原生事件对象的用于阻止 DOM 事件的进一步捕获或者冒泡</li>\n<li><code>e.nativeEvent.stopImmediatePropagation</code> 原生事件对象用于阻止 dom 事件的进一步捕获或者冒泡，且该元素的后续绑定相同事件类型的事件，都会被阻止</li>\n</ul>\n\n</div>\n<p><a href=\"https://zhuanlan.zhihu.com/p/150993869#:~:text=memo%E5%87%BD%E6%95%B0-,2.4.4.%20%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%9B%E9%87%8F,-%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA\" target=\"_blank\" >setState 返回一样的引用，render 会执行吗</a></p>\n<p><a href=\"\" target=\"_blank\" >useEffect 的使用方法？useEffect 的 return 会在什么时候执行？useEffect 原理是什么？</a></p>\n<p><a href=\"https://blog.csdn.net/leelxp/article/details/108218088#:~:text=%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8BPureComponent%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0\" target=\"_blank\" >我们来看看 PureComponent 和 Component 的区别是什么？ </a></p>\n<p><strong>单节点 Diff</strong><br><a href=\"https://react.iamkasong.com/diff/one.html\" target=\"_blank\" >单节点 diff</a></p>\n<p><strong>多节点 Diff</strong><br><a href=\"https://react.iamkasong.com/diff/multi.html#diff%E7%9A%84%E6%80%9D%E8%B7%AF:~:text=%23-,%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86,-%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D\" target=\"_blank\" >第一轮遍历</a></p>\n<p><a href=\"https://react.iamkasong.com/diff/multi.html#%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86:~:text=%23-,%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86,-%E5%AF%B9%E4%BA%8E%E7%AC%AC%E4%B8%80%E8%BD%AE\" target=\"_blank\" >第二轮遍历</a></p>\n<p><a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" >react ⽣命周期</a></p>\n<!-- <div>\n\n<iframe src=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" height=600 width='100%'></iframe>\n\n</div> -->\n\n<p><a href=\"https://blog.csdn.net/weixin_45654582/article/details/122740125#:~:text=dependencies%20%E5%BB%BA%E7%AB%8B%E8%B5%B7%E5%85%B3%E8%81%94%E3%80%82-,Context%20%E5%8E%9F%E7%90%86,-Provider%20%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B\" target=\"_blank\" >Context 原理</a></p>\n<ul>\n<li>Provider 传递流程：Provider 的更新，会 深度遍历子代 fiber，消费 context 的 fiber 和父级链都会 提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。</li>\n<li>Context 订阅流程： contextType ， useContext， Consumer 会内部调用 readContext ，readContext 会把 fiber 上的 dependencies 属性 和 context 对象 建立起关联。</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/github_37759996/article/details/119187241\" target=\"_blank\" >Hooks 的实现原理</a><br><a href=\"https://blog.csdn.net/XH_jing/article/details/124188256\" target=\"_blank\" >类组件和纯函数组件的区别</a></p>\n<p><a href=\"https://www.php.cn/website-design-ask-491123.html\" target=\"_blank\" >React dom 绑定事件和原生事件有什么区别</a></p>\n<p><a href=\"https://juejin.cn/post/7064444554727915556\" target=\"_blank\" >useState 的源码解析</a></p>\n<h2 id=\"稳操胜券\"><a href=\"#稳操胜券\" class=\"headerlink\" title=\"稳操胜券\"></a>稳操胜券</h2><p><a href=\"http://dljz.nicethemes.cn/news/show-13202.html\" target=\"_blank\" >看完这篇文章保你面试稳操胜券 ——（必考题）javaScript 篇</a></p>\n<p><a href=\"https://copyfuture.com/blogs-details/20211119150923474f\" target=\"_blank\" >看完这篇文章保你面试稳操胜券——基础篇（html&#x2F;css)</a></p>\n<p><a href=\"https://www.wangt.cc/2021/11/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%BF%9D%E4%BD%A0%E9%9D%A2%E8%AF%95%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8-vue%E7%AF%87/\" target=\"_blank\" >看完这篇文章保你面试稳操胜券-vue 篇</a></p>\n<p><a href=\"https://copyfuture.com/blogs-details/20211118131747765L\" target=\"_blank\" >读完这篇保你面试稳操胜券——前端面试题“骨灰级”总结</a></p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><a href=\"https://zhuanlan.zhihu.com/p/472733451\" target=\"_blank\" >Webpack | TreeShaking 工作原理</a><br><a href=\"https://juejin.cn/post/7039547628379439135\" target=\"_blank\" >什么是 tree-shaking</a></p>\n<p><a href=\"https://juejin.cn/post/6844903924806189070\" target=\"_blank\" >Webpack 优化——将你的构建效率提速翻倍</a></p>\n<p><a href=\"https://juejin.cn/post/6844903685407916039\" target=\"_blank\" >Webpack 揭秘——走向高阶前端的必经之路</a></p>\n<p><a href=\"https://www.cnblogs.com/zhilili/p/14721434.html\" target=\"_blank\" >webpack（四）——webpack 里面的 plugin 和 loader 的区别</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/429072485\" target=\"_blank\" >跟着源码了解 Webpack 编译流程</a></p>\n<p><a href=\"https://blog.csdn.net/qq_39207948/article/details/102768659\" target=\"_blank\" >说一下对 tree-shaking 的了解，对 CommonJS 和 ESM 都可以用 tree-shaking 吗</a></p>\n<p><a href=\"https://www.webpackjs.com/contribute/writing-a-loader/\" target=\"_blank\" >编写一个 loader</a></p>\n<p><a href=\"https://www.webpackjs.com/contribute/writing-a-plugin/\" target=\"_blank\" >编写一个插件</a></p>\n<p><a href=\"https://juejin.cn/post/6918998088010956807\" target=\"_blank\" >Webpack5 的事件流和插件机制</a></p>\n<p><a href=\"\" target=\"_blank\" >px2rem-loader[9], 或者 pxrem-loader[10]原理 ^_^</a></p>\n<!-- <a href=\"https://cloud.tencent.com/developer/article/1432511\" target=\"_blank\" >Webpack 4 教程 - 第四部分，使用 SplitChunksPlugin 分离代码</a>\n<a href=\"https://cloud.tencent.com/developer/article/1432714\" target=\"_blank\" >Webpack 4 教程 - 第七部分 减少打包体积与 Tree Shaking</a>\n<a href=\"https://cloud.tencent.com/developer/article/1017015\" target=\"_blank\" >优化 Webpack 构建性能的几点建议</a>\n\n```js\n{\n  体积小： 合适的 source-map、减少代码体积、 webpack-bundle-analyzer进行分析\n  范围小：目录检索范围、检索路径\n  缓存：开启 loader、plugin 缓存\n  不重复打包：DLLPlugin + DLLRefrencePlugin 、 externals\n}\n``` -->\n\n<p><a href=\"https://javajgs.com/archives/36777\" target=\"_blank\" >常见loader使用 , 不好看，有乱七八糟图片，img 样式设置 display: none;</a></p>\n<ul>\n<li>文件相关：</li>\n<li>JSON相关：</li>\n<li>JS&#x2F;TS转译:</li>\n<li>模版：</li>\n<li>样式：</li>\n<li>lint校验：</li>\n<li>测试：</li>\n<li>框架：</li>\n</ul>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p><a href=\"https://juejin.cn/post/6844903655330562062\" target=\"_blank\" >网站性能优化实战——从 12.67s 到 1.06s 的故事</a></p>\n<p><a href=\"http://v.aijs.top/post/2022-05-12performance\" target=\"_blank\" >浏览器首屏优化-首屏时间获取</a></p>\n<h2 id=\"博客推荐\"><a href=\"#博客推荐\" class=\"headerlink\" title=\"博客推荐\"></a>博客推荐</h2><p><a href=\"https://blog.csdn.net/JHXL_?type=blog\" target=\"_blank\" >几何心凉</a></p>\n","text":" 小红书前端面经 前端两年经验，历时一个月的面经和总结 【面试题】CSS 知识点整理(附答案) HTTP 与 TCPHTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 对 HTTP 的改进 TCP 三次握手 TCP 四次挥手 TCP 重传机制 流量控制 H...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"面试","slug":"面试","count":2,"path":"api/categories/面试.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":17,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E4%B8%8E-TCP\"><span class=\"toc-text\">HTTP 与 TCP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BA%AB%E4%BB%BD%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">身份信息</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES6\"><span class=\"toc-text\">ES6</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js\"><span class=\"toc-text\">js</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8\"><span class=\"toc-text\">浏览器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#html\"><span class=\"toc-text\">html</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS3\"><span class=\"toc-text\">CSS3</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E5%BC%8F\"><span class=\"toc-text\">响应式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">安全</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue\"><span class=\"toc-text\">vue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react\"><span class=\"toc-text\">react</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8\"><span class=\"toc-text\">稳操胜券</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack\"><span class=\"toc-text\">webpack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90\"><span class=\"toc-text\">博客推荐</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"react-router v6.4.0 主要概念","uid":"3d2993e7928f66556e52e3c255cfa133","slug":"2022-06-21react-router","date":"2022-06-21T01:06:50.000Z","updated":"2022-09-16T15:00:54.073Z","comments":true,"path":"api/articles/2022-06-21react-router.json","keywords":null,"cover":[],"text":"官网React Router v6 is Here React Router v6 在客户端路由十年的基础上，采用了以前版本及其姐妹项目 Reach Router 的最佳功能，采用了迄今为止最小和最强大的软件包。 TIP 或许某一天，再见时，已不是 v6 官网分为两块内容 核心概...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"React","slug":"React","count":18,"path":"api/categories/React.json"}],"tags":[{"name":"react-router","slug":"react-router","count":3,"path":"api/tags/react-router.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"http错误信息","uid":"5b104c45df830a680c682d4e4b65c048","slug":"2022-06-15http","date":"2022-06-15T06:27:41.000Z","updated":"2022-09-16T13:54:56.144Z","comments":true,"path":"api/articles/2022-06-15http.json","keywords":null,"cover":null,"text":"http 错误信息Request URL: http:&#x2F;&#x2F;localhost:8888&#x2F;api&#x2F;redline&#x2F;content_management&#x2F;api&#x2F;kbs&#x2F;search&#x2F;conte...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"bug","slug":"bug","count":4,"path":"api/categories/bug.json"}],"tags":[{"name":"bug","slug":"bug","count":6,"path":"api/tags/bug.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}