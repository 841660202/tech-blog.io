{"title":"前端基础-js变量和作用域","uid":"b231170e726e8d41c02587c56363e3ce","slug":"2022-05-08varible","date":"2022-05-08T02:00:00.000Z","updated":"2023-07-31T06:42:49.711Z","comments":true,"path":"api/articles/2022-05-08varible.json","keywords":null,"cover":[],"content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"var-let-const-区别\"><a href=\"#var-let-const-区别\" class=\"headerlink\" title=\"var let const 区别\"></a>var let const 区别</h3><ol>\n<li>使用 var 具有全局<code>或</code>函数作用域，存在变量提升，可以重复声明，变量值可修改。</li>\n<li>使用 let 具有块级作用域，不存在变量提升，不能重复声明，变量值可修改。</li>\n<li>使用 const 具有块级作用域，不存在变量提升，不能重复声明，变量值不可修改（但对象和数组的属性或元素可修改）<!-- 1. `版本`： var 是 es6 之前， const、let es6 之后，</li>\n<li><code>分类</code>： 在 es6 之前只有<code>全局作用域</code>和<code>函数作用域</code>， const、let 块级作用域</li>\n<li><code>提升</code>：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前使用会报错</li>\n<li><code>重复</code>：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值</li>\n<li><code>存储</code>：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li>\n<li><code>默认</code>： 默认情况下是 var 声明</li>\n<li><code>函数</code>：函数声明提升优先于 var</li>\n</ol>\n<p>补充说明： const 和不变性。</p>\n<ol>\n<li>const 创建一个变量名绑定，该绑定在创建后不能重新分配。</li>\n<li>const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。</li>\n</ol>\n<p><a href=\"/#/post/2022-09-19qa\" target=\"_blank\" >见：2022-09-19qa</a> –&gt;</p>\n<h2 id=\"js-作用域\"><a href=\"#js-作用域\" class=\"headerlink\" title=\"js 作用域\"></a>js 作用域</h2><p>JavaScript 的作用域定义了在代码中声明的变量和函数在何处可见或可访问。作用域可以分为全局作用域和局部作用域（也称为块级作用域）。</p>\n<ol>\n<li><p>全局作用域：</p>\n<ul>\n<li>在整个程序中都可访问的作用域。</li>\n<li>可以在任何地方声明的变量和函数都具有全局作用域。</li>\n<li>使用<code>var</code>关键字声明的变量默认具有全局作用域。</li>\n<li>在浏览器环境中，全局作用域可以表示为<code>window</code>对象的属性。</li>\n</ul>\n</li>\n<li><p>局部作用域（块级作用域）：</p>\n<ul>\n<li>限定在特定代码块内部的作用域。</li>\n<li>代码块可以是函数、<code>if</code>语句、<code>for</code>循环等。</li>\n<li>在 ES6 之前，JavaScript 没有块级作用域，只有函数作用域。</li>\n<li>使用<code>let</code>和<code>const</code>关键字声明的变量在对应的块级作用域内可见。</li>\n<li>块级作用域可避免变量污染和冲突问题，提供更好的代码组织和可读性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>作用域链</strong>是在 JavaScript 中实现作用域的一种机制，它表示变量和函数的查找路径。在访问一个变量时，JavaScript 引擎会先从当前作用域开始查找，如果找不到则向上级作用域查找，直到找到该变量或到达全局作用域为止。</p>\n<p><strong>函数作用域和全局作用域</strong>：函数内部创建的变量（使用<code>var</code>或<code>function</code>关键字声明）只在函数内部可见，而全局作用域中声明的变量对整个程序都可见。</p>\n<p><strong>块级作用域</strong>：<code>let</code>和<code>const</code>关键字声明的变量在声明的块级作用域内可见，超出该作用域则不可见。</p>\n<p>JavaScript 作用域的理解对于正确声明和使用变量和函数非常重要，同时还有助于避免变量名冲突和提高代码的可维护性。</p>\n<h2 id=\"js-事件循环\"><a href=\"#js-事件循环\" class=\"headerlink\" title=\"js 事件循环\"></a>js 事件循环</h2><p>JavaScript 的事件循环是一种机制，用于处理异步操作和事件处理。它是 JavaScript 单线程执行模型的关键部分。事件循环确保代码按照预期的顺序执行，并处理异步操作的结果。</p>\n<p>事件循环包括以下几个主要组件：</p>\n<ol>\n<li><p>调用栈（Call Stack）：调用栈是一个跟踪函数调用的数据结构，它保存了当前执行的上下文和函数调用的顺序。当调用一个函数时，它会被添加到调用栈中，当函数执行完成后，它会从栈中弹出。</p>\n</li>\n<li><p>任务队列（Task Queue）：任务队列用于存储待执行的任务。当事件发生时，例如点击事件、定时器到期等，相关的回调函数被推送到任务队列中。</p>\n</li>\n<li><p>事件循环（Event Loop）：事件循环负责将任务队列中的任务逐个放入调用栈中执行，并确保代码按照正确的顺序执行。它会持续监听调用栈和任务队列的状态，一旦调用栈为空，就会检查任务队列是否有待执行的任务，如果有，则将下一个任务推送到调用栈中执行。</p>\n</li>\n<li><p>微任务队列（Microtask Queue）：微任务队列用于存储微任务，微任务是一种更高优先级的任务。在每个事件循环的末尾，在执行下一个任务之前，会检查微任务队列并将其中的任务全部执行完毕。</p>\n</li>\n</ol>\n<p>事件循环的执行顺序如下：</p>\n<ul>\n<li>当代码开始执行时，先执行同步任务，将函数调用压入调用栈中执行。</li>\n<li>当遇到异步操作时，如<code>setTimeout</code>、<code>Promise</code>的<code>then</code>方法等，相关的回调函数将被推送到任务队列中。</li>\n<li>当调用栈为空时，事件循环会从任务队列中取出一个任务，将其推送到调用栈中执行。</li>\n<li>如果任务是微任务，则会先执行微任务队列中的所有微任务。</li>\n<li>循环以上步骤，直到调用栈和任务队列都为空。</li>\n</ul>\n<p>值得注意的是，事件循环是在单线程上运行的，但通过异步操作和事件处理，可以在保持主线程空闲的同时执行并发的任务。</p>\n<h2 id=\"nodejs-事件循环\"><a href=\"#nodejs-事件循环\" class=\"headerlink\" title=\"nodejs 事件循环\"></a>nodejs 事件循环</h2><p>Node.js 的事件循环与浏览器中的事件循环有些不同，因为 Node.js 是基于服务器端的 JavaScript 运行环境。</p>\n<p>Node.js 的事件循环基于 libuv 库，采用了单线程的事件驱动模型。以下是 Node.js 事件循环的主要组件：</p>\n<ol>\n<li><p>调用栈（Call Stack）：与浏览器中的调用栈类似，调用栈跟踪函数的执行顺序。</p>\n</li>\n<li><p>事件循环（Event Loop）：Node.js 的事件循环是基于 libuv 的事件循环机制。它负责监听和处理事件，包括 I&#x2F;O 操作、定时器和回调函数等。事件循环会持续运行，并按照固定顺序处理不同的任务队列。</p>\n</li>\n<li><p>任务队列：</p>\n<ul>\n<li>定时器队列（Timers Queue）：存放定时器相关的回调函数。</li>\n<li>I&#x2F;O 队列（I&#x2F;O Queue）：存放 I&#x2F;O 操作的回调函数。</li>\n<li>空闲观察者队列（Idle Observer Queue）：存放一些由 idle 观察者（Idle Observer）注册的回调函数，这些回调函数会在事件循环空闲时执行。</li>\n<li>非空闲观察者队列（Non-Idle Observer Queue）：存放一些由非 idle 观察者（Non-Idle Observer）注册的回调函数，这些回调函数会在事件循环的各个阶段执行。</li>\n<li>微任务队列（Microtask Queue）：存放微任务，会在每个事件循环的末尾执行。</li>\n</ul>\n</li>\n</ol>\n<p>Node.js 事件循环的执行顺序如下：</p>\n<ol>\n<li><p>执行当前调用栈中的同步代码。</p>\n</li>\n<li><p>检查微任务队列，如果有微任务，则依次执行直到队列为空。</p>\n</li>\n<li><p>执行完微任务后，检查定时器队列，如果有到期的定时器，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完定时器队列后，检查 I&#x2F;O 队列，如果有 I&#x2F;O 操作的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完 I&#x2F;O 队列后，检查空闲观察者队列，如果有空闲观察者注册的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完空闲观察者队列后，检查非空闲观察者队列，如果有非空闲观察者注册的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>重复以上步骤，直到调用栈和所有任务队列都为空。</p>\n</li>\n</ol>\n<p>需要注意的是，Node.js 的事件循环是单线程的，但通过异步 I&#x2F;O 操作和事件驱动机制，可以实现高效的并发处理。</p>\n<h3 id=\"变量分类-amp-执行结果输出\"><a href=\"#变量分类-amp-执行结果输出\" class=\"headerlink\" title=\"变量分类 &amp; 执行结果输出\"></a>变量分类 &amp; 执行结果输出</h3><ul>\n<li>js 中的变量分为两种：</li>\n</ul>\n<ol>\n<li>全局变量和局部变量。</li>\n<li><code>全局变量</code>很好理解，就是在 js 任何地方都能够调用的变量；</li>\n<li>而<code>局部变量</code>就只能在函数的内部才能够调用的变量。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; 10;\nfunction show() &#123;\n  console.log(&#39;a:&#39; + a); &#x2F;&#x2F;a:10\n  var b &#x3D; 2;\n  console.log(&#39;inside b:&#39; + b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&#39;outside b:&#39; + b); &#x2F;&#x2F;b is no defined</code></pre>\n\n<p>在上面的程序中，</p>\n<ol>\n<li>变量 a 就是一个全局变量，在函数的内部能够调用。</li>\n<li>但是这里的变量 b 就是局部变量，</li>\n<li>当函数结束调用后，变量 b 就被回收了，因此在函数外部调用失败。</li>\n</ol>\n<p><em>另外需要特别注意的是：</em></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果在声明局部变量时不用 var 声明，那么这个变量自动“提升”为全局变量。</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; 10;\nfunction show() &#123;\n  console.log(&#39;a:&#39; + a); &#x2F;&#x2F;a:10\n  b &#x3D; 2;\n  console.log(&#39;inside b:&#39; + b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&#39;outside b:&#39; + b); &#x2F;&#x2F;outside b:2</code></pre>\n\n<p>对比两段代码，</p>\n<ol>\n<li>如果你在声明 b&#x3D;2 时没有写 var，那么 b 就隐式地声明为全局变量，在函数外面还是能够被调用到的。</li>\n<li>虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了<em>缺点</em>：<ol>\n<li><code>一直占用内存</code>：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。</li>\n<li><code>影响了函数的独立性</code>：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，</li>\n<li><code>可移植性</code>: 同时也降低了函数的可移植性。</li>\n</ol>\n</li>\n</ol>\n<p><strong>因此我们在定义变量时一般要尽可能少的定义全局变量。</strong></p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>函数声明优先于变量声明 (这句话的意思是：<code>如果有一样的变量标识符，会先进性函数声明，忽略掉变量声明</code>)</p>\n<p>下面我们通过一段代码来说明.</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a;\nfunction a() &#123;&#125;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 或许有人是认为函数声明在后面的原因，那么调换一下位置。</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function a() &#123;&#125;\nvar a;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。\n&#x2F;&#x2F; 因此函数声明优先于变量的声明。\n&#x2F;&#x2F; 但是如果我们在声明的同时给a进行赋值。</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function a() &#123;&#125;\nvar a &#x3D; &#39;xyf&#39;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 我们将其调换一下位置再次进行验证。</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; &#39;xyf&#39;;\nfunction a() &#123;&#125;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function a() &#123;&#125;\nvar a;\na &#x3D; &#39;xyf&#39;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; a最后被赋值为字符串，因此a的类型自然是字符串</code></pre>\n\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p>js 中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><p>js 中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>let const<em>有块级作用域</em>。函数作用域是比较容易理解的，那么什么是块级作用域呢？</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;var a &#x3D; 1&#125;\n\nconsole.log(a)\nVM2355:1 1\n</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;let a &#x3D;1&#125;\n\nconsole.log(a)\nVM2079:1 Uncaught ReferenceError: a is not defined</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>任何一对花括号<code>&#123;&#125;</code>中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p></blockquote>\n<p>理解了块级作用域，来看一下下面的小例子。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(v); &#x2F;&#x2F;undefined\nvar v &#x3D; &#39;world&#39;; &#x2F;&#x2F; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。</code></pre>\n\n<p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p>\n<p>由于 js 作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v;\nconsole.log(v); &#x2F;&#x2F;undefined\nv &#x3D; &#39;world&#39;;\n&#x2F;&#x2F; 这样就能很清晰地理解为什么变量v是undefined的了。\n&#x2F;&#x2F;下面我们把变量v放到一个方法中去：</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  var v &#x3D; &#39;hello&#39;;\n&#125;\nconsole.log(v); &#x2F;&#x2F;hello\n&#x2F;&#x2F; 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，\n&#x2F;&#x2F; 并不能够“阻挡”外面的代码获取里面的变量。</code></pre>\n\n<h3 id=\"函数作用域实例\"><a href=\"#函数作用域实例\" class=\"headerlink\" title=\"函数作用域实例\"></a>函数作用域实例</h3><p>我们再把变量 v 放到函数中去：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function show() &#123;\n  var v &#x3D; &#39;world&#39;;\n&#125;\nshow();\nconsole.log(v); &#x2F;&#x2F;undefined</code></pre>\n\n<p>由于 show 函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量 v。因此证明了 js 中只有函数作用域，没有块级作用域。<br>　　再来看下面的一段代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v &#x3D; &#39;hello&#39;;\nfunction show() &#123;\n  console.log(v); &#x2F;&#x2F;undefined\n  var v &#x3D; &#39;world&#39;;\n&#125;\nshow();</code></pre>\n\n<p><strong>很多人看到这边都会很疑惑，不是说这边 show 函数中能够获取到函数外面的变量的么？</strong></p>\n<p>但是由于这边是一个函数作用域，而<code>函数作用域存在着变量声明的提前</code>，因此，上面的代码相当于下面的代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v &#x3D; &#39;hello&#39;;\nfunction show() &#123;\n  var v;\n  console.log(v); &#x2F;&#x2F;undefined\n  v &#x3D; &#39;world&#39;;\n&#125;\nshow();</code></pre>\n\n<p>这里把变量 v 的声明放到了整个函数作用域的最前面，因此显示为 <code>undefined</code>。理解了上面的代码，相信下面的代码也不难理解了。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v &#x3D; &#39;hello&#39;;\n(function () &#123;\n  console.log(v);\n  var v &#x3D; &#39;world&#39;;\n&#125;)();</code></pre>\n\n<p>在这里自执行函数形成了函数作用域</p>\n<p>需要注意的是</p>\n<p><strong>变量提升只提升函数的声明，并不提升函数的定义</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">show(); &#x2F;&#x2F;show is not a function\nvar show &#x3D; function () &#123;\n  &#x2F;&#x2F;...\n&#125;;\nshow(); &#x2F;&#x2F;成功运行</code></pre>\n\n<p>或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在 js 中是如何进行定义的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>函数有两种定义方式，一种是<code>函数声明</code>，另一种是<code>函数表达式</code>。那么什么是函数声明什么是函数表达式呢？</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;函数声明\nfunction show() &#123;\n  &#x2F;&#x2F;....\n&#125;\n&#x2F;&#x2F;函数表达式\nvar show &#x3D; function () &#123;\n  &#x2F;&#x2F;...\n&#125;;</code></pre>\n\n<p>乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。</p>\n<ol>\n<li>js 的解析器对<code>函数声明</code>和<code>函数表达式</code>并不是一视同仁的对待的，有点“种族歧视”的意思在里面。</li>\n<li><code>函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了</code>，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。</li>\n<li><code>而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，</code>因此，调用函数表达式要在定义后进行使用。</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202209201228344.webp\" />\n\n<p><a href=\"https://blog.csdn.net/weixin_46112649/article/details/126376367\" target=\"_blank\" >见</a></p>\n<h2 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var b &#x3D; 10;\n(function b() &#123;\n  b &#x3D; 20;\n  console.log(b);\n&#125;)();</code></pre>\n\n<ol>\n<li>代码进入预解析状态，将 var b 进行变量提升，此时 b 没有被赋值(b&#x3D;undefined) (这里有人会说这里明明有个函数表达式呀，为什么没有进入变量提升，因为 <code>IIFE 自带有词法作用域</code>(我们常理解得作用域))</li>\n<li>发现没有可以变量提升得时候将 b 赋值为 10，此时会将 b 赋值为 10(b&#x3D;10)</li>\n<li>碰到了立即执行函数，会执行其内边的函数 <code>function b()</code></li>\n<li>IIFE 作用域中定义<code> b = function b()&#123;&#125;</code></li>\n<li>碰到了 b &#x3D; 20，<code>会顺着作用域链寻找是否存在 b，发现 IIFE 作用域中存在 b，将 IIFE 作用域中的 b 赋值为 20(b=20)(因为函数表达式特性，标识符无法被修改，所以这里执行失败)</code></li>\n<li>执行 console.log(b)，此时的 b 会找 IIFE 中的作用域看看是否存在 b，发现其内边存在，将其返回</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/weixin_46112649/article/details/126376367\" target=\"_blank\" >解析 var b &#x3D; 10； (function b(){ b &#x3D; 20 console.log(b) })()</a></p>\n<h2 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h2><p><a href=\"https://juejin.cn/post/6844904019165446158\" target=\"_blank\" >https://juejin.cn/post/6844904019165446158</a></p>\n<p><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/javascript-depth-understanding/function-expression.html\" target=\"_blank\" >见</a></p>\n<h2 id=\"typeof-null\"><a href=\"#typeof-null\" class=\"headerlink\" title=\"typeof null\"></a>typeof null</h2><p><strong>null 作为一个基本数据类型为什么会被 typeof 运算符识别为 object 类型呢？</strong></p>\n<p>这个 bug 是第一版 Javascript 留下来的，javascript 中不同对象在底层都表示为二进制，而 <code>javascript 中会把二进制前三位都为 0 的判断为 object 类型</code>，而 <code> null 的二进制表示全都是 0，自然前三位也是 0</code>，<code>所以执行 typeof 时会返回 ‘object’。 </code></p>\n<p>—-引用自《你不知道的 javascript（上卷）》</p>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function async1() &#123;\n  console.log(&#39;1&#39;);\n  await async2();\n  console.log(&#39;2&#39;);\n&#125;\n\nasync function async2() &#123;\n  console.log(&#39;3&#39;);\n&#125;\n\nconsole.log(&#39;4&#39;);\n\nsetTimeout(function () &#123;\n  console.log(&#39;5&#39;);\n&#125;, 0);\n\nasync1();\n\nnew Promise(function (resolve) &#123;\n  console.log(&#39;6&#39;);\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&#39;7&#39;);\n&#125;);\n\nconsole.log(&#39;8&#39;);</code></pre>\n\n<ol>\n<li>async 内部到 await 之前都是同步执行的</li>\n<li>遇到 await 会转交控制权</li>\n<li>同步任务执行完成后，await 会重新获得执行的控制权，继续执行往下执行</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 4, 1, 3, 6, 8, 2, 7, 5</code></pre>\n\n<h2 id=\"this-指向\"><a href=\"#this-指向\" class=\"headerlink\" title=\"this 指向\"></a>this 指向</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var name &#x3D; &#39;123&#39;;\n\nvar obj &#x3D; &#123;\n  name: &#39;456&#39;,\n  print: function () &#123;\n    function a() &#123;\n      console.log(this.name);\n    &#125;\n    a();\n  &#125;,\n&#125;;\n\nobj.print();</code></pre>\n\n<p><a href=\"https://juejin.cn/post/7142690757722243102\" target=\"_blank\" >见</a></p>\n<h2 id=\"var-变量运行\"><a href=\"#var-变量运行\" class=\"headerlink\" title=\"var 变量运行\"></a>var 变量运行</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(() &#x3D;&gt; console.log(i), 1);\n&#125;\nconsole.log(i); &#x2F;&#x2F; 输出3</code></pre>\n\n<h3 id=\"1-let-方案\"><a href=\"#1-let-方案\" class=\"headerlink\" title=\"1. let 方案\"></a>1. let 方案</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(() &#x3D;&gt; console.log(i), i); &#x2F;&#x2F; 输出0,1,2\n&#125;\nconsole.log(i); &#x2F;&#x2F;报错</code></pre>\n\n<h3 id=\"2-iife-方案\"><a href=\"#2-iife-方案\" class=\"headerlink\" title=\"2. iife 方案\"></a>2. iife 方案</h3><p>原理： 立即执行函数会形成对立的作用域</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(((i) &#x3D;&gt; console.log(i))(i) &#x2F;**输出0,1,2 *&#x2F;, 1);\n&#125;\n\nconsole.log(i); &#x2F;&#x2F; 输出3</code></pre>\n\n<h2 id=\"Promise-运行\"><a href=\"#Promise-运行\" class=\"headerlink\" title=\"Promise 运行\"></a>Promise 运行</h2><p>原理：浏览器事件循环</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&#39;Promise1&#39;);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;setTimeout2&#39;);\n  &#125;, 0);\n&#125;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;setTimeout1&#39;);\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;Promise2&#39;);\n  &#125;);\n&#125;, 0);\n&#x2F;&#x2F; 打印结果为：Promise1 -&gt; setTimeout1 -&gt; Promise2 -&gt;setTimeout2</code></pre>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p><a href=\"/#/post/2022-05-08varible\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2022-05-08varible</a></p>\n","text":"变量var let const 区别 使用 var 具有全局或函数作用域，存在变量提升，可以重复声明，变量值可修改。 使用 let 具有块级作用域，不存在变量提升，不能重复声明，变量值可修改。 使用 const 具有块级作用域，不存在变量提升，不能重复声明，变量值不可修改（但对象...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"结果输出","slug":"结果输出","count":1,"path":"api/tags/结果输出.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">var let const 区别</span></a></li></ol></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"面试题汇总","uid":"99460a2013287be2d51642da6dd169f8","slug":"2022-05-08interview","date":"2022-05-08T08:27:00.000Z","updated":"2023-02-20T21:20:56.456Z","comments":true,"path":"api/articles/2022-05-08interview.json","keywords":null,"cover":null,"text":"值得收藏的链接 码上通天 面试完 50 个人后我写下这篇总结 if 我是前端团队 Leader，怎么制定前端协作规范? 做了一份前端面试复习计划，保熟～ url 解析过程 zoomdong 面经 见 ","link":"","photos":[],"count_time":{"symbolsCount":108,"symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"如何更好的沉淀","uid":"39b06ee79b8fd96256d44a33e065e573","slug":"2022-04-28博客创建","date":"2022-05-06T01:17:27.000Z","updated":"2023-02-20T21:20:56.455Z","comments":true,"path":"api/articles/2022-04-28博客创建.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220428100720.png","text":"背景 工作日常经验性总结放哪？ 存电脑，电脑坏了重做系统没了， 放到电脑备忘录，卧槽，怎么没及时更新 放自己的服务器，没时间打理，服务器到期，嗝屁了，没来的及迁移 hexo hexo 由于有丰富的插件和主题，使用及部署方便，备受欢迎 自己购买服务器部署，服务器到期后续费很贵 放到...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"hexo","slug":"hexo","count":4,"path":"api/tags/hexo.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}