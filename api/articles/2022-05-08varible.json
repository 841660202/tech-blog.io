{"title":"前端基础-js变量和作用域","uid":"b231170e726e8d41c02587c56363e3ce","slug":"2022-05-08varible","date":"2022-05-08T02:00:00.000Z","updated":"2022-07-16T01:27:15.838Z","comments":true,"path":"api/articles/2022-05-08varible.json","keywords":null,"cover":null,"content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"var-let-const区别\"><a href=\"#var-let-const区别\" class=\"headerlink\" title=\"var let const区别\"></a>var let const区别</h3><ul>\n<li><strong>变量提升</strong>：var 存在变量提升，let、const没有（let、const存在暂时性死区）</li>\n<li><strong>作用域的限制</strong>：var不受作用域的限制，而let、const受当前作用域的限制</li>\n<li><strong>重复声明</strong>：var可以重复声明，let、const不可以</li>\n<li><strong>const是常量</strong>，必须有初始值，否则报错，不能更改，但是可以更改对象内部属性</li>\n</ul>\n<h3 id=\"变量分类\"><a href=\"#变量分类\" class=\"headerlink\" title=\"变量分类\"></a>变量分类</h3><ul>\n<li>js中的变量分为两种：<ul>\n<li>全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；</li>\n<li>而局部变量就只能在函数的内部才能够调用的变量。</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var a&#x3D;10;\nfunction show()&#123;\n  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10\n  var b&#x3D;2;\n  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;b is no defined</code></pre>\n<p>　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。</p>\n<p><em>另外需要特别注意的是：</em></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。</p></blockquote>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var a&#x3D;10;\nfunction show()&#123;\n  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10\n  b&#x3D;2;\n  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;outside b:2</code></pre>\n<p>对比两段代码，<em>如果你在声明b&#x3D;2时没有写var，那么b就隐式地声明为全局变量</em>，在函数外面还是能够被调用到的。<br>虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了<em>缺点</em>：</p>\n<ol>\n<li>一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。</li>\n<li>影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，</li>\n<li>可移植性: 同时也降低了函数的可移植性。</li>\n</ol>\n<p><strong>因此我们在定义变量时一般要尽可能少的定义全局变量。</strong></p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>函数声明优先于变量声明</p></blockquote>\n<p>　　下面我们通过一段代码来说明.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var a; \nfunction a()&#123;\n&#125;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 或许有人是认为函数声明在后面的原因，那么调换一下位置。</code></pre>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function a()&#123;\n&#125;\nvar a; \nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。\n&#x2F;&#x2F; 因此函数声明优先于变量的声明。\n&#x2F;&#x2F; 但是如果我们在声明的同时给a进行赋值。</code></pre>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function a()&#123;\n&#125;\nvar a&#x3D;&#39;xyf&#39;; \nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 我们将其调换一下位置再次进行验证。</code></pre>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var a&#x3D;&#39;xyf&#39;; \nfunction a()&#123;\n&#125;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：</code></pre>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function a()&#123;\n&#125;\nvar a;\na&#x3D;&#39;xyf&#39;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; a最后被赋值为字符串，因此a的类型自然是字符串</code></pre>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p>　js中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><p>　js中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>  let const<em>有块级作用域</em>。函数作用域是比较容易理解的，那么什么是块级作用域呢？<br>  <pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#123;var a &#x3D; 1&#125;\n\nconsole.log(a)\nVM2355:1 1\n</code></pre><br>  <pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#123;let a &#x3D;1&#125;\n\nconsole.log(a)\nVM2079:1 Uncaught ReferenceError: a is not defined</code></pre></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p></blockquote>\n<p>　　理解了块级作用域，来看一下下面的小例子。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">console.log(v); &#x2F;&#x2F;undefined\nvar v &#x3D; &quot;world&quot;;\n　　&#x2F;&#x2F; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。</code></pre>\n<p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p>\n<p>由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var v;\nconsole.log(v); &#x2F;&#x2F;undefined\nv &#x3D; &quot;world&quot;;\n&#x2F;&#x2F; 这样就能很清晰地理解为什么变量v是undefined的了。\n&#x2F;&#x2F;下面我们把变量v放到一个方法中去：</code></pre>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">if(true)&#123;\n  var v &#x3D; &quot;hello&quot;;\n&#125;\nconsole.log(v); &#x2F;&#x2F;hello\n&#x2F;&#x2F; 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，\n&#x2F;&#x2F; 并不能够“阻挡”外面的代码获取里面的变量。</code></pre>\n<p>函数作用域<br>　　我们再把变量v放到函数中去：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function show()&#123;\n  var v&#x3D;&#39;world&#39;;\n&#125;\nshow();\nconsole.log(v); &#x2F;&#x2F;undefined</code></pre>\n<p>　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。<br>　　再来看下面的一段代码：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var v&#x3D;&#39;hello&#39;;\nfunction show()&#123;\n  console.log(v); &#x2F;&#x2F;undefined\n  var v&#x3D;&#39;world&#39;;\n&#125;\nshow();</code></pre>\n<p>　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var v&#x3D;&#39;hello&#39;;\nfunction show()&#123;\n\tvar v;\n\tconsole.log(v); &#x2F;&#x2F;undefined\n\tv&#x3D;&#39;world&#39;;\n&#125;\nshow();</code></pre>\n<p>　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var v &#x3D; &quot;hello&quot;;\n(function()&#123;\n  console.log(v);\n  var v &#x3D; &quot;world&quot;;\n&#125;)();\n</code></pre>\n<p>　　在这里自执行函数形成了函数作用域</p>\n<p>需要注意的是<br>变量提升只提升函数的声明，并不提升函数的定义</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">show(); &#x2F;&#x2F;show is not a function\nvar show&#x3D;function()&#123;\n\t&#x2F;&#x2F;...\n&#125;\nshow(); &#x2F;&#x2F;成功运行\n</code></pre>\n<p>　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>函数有两种定义方式，一种是<code>函数声明</code>，另一种是<code>函数表达式</code>。那么什么是函数声明什么是函数表达式呢？</p></blockquote>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F;函数声明\nfunction show()&#123;\n\t&#x2F;&#x2F;....\n&#125;\n&#x2F;&#x2F;函数表达式\nvar show&#x3D;function()&#123;\n\t&#x2F;&#x2F;...\n&#125;</code></pre>\n<p>乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。</p>\n<ul>\n<li>js的解析器对<code>函数声明</code>和<code>函数表达式</code>并不是一视同仁的对待的，有点“种族歧视”的意思在里面。</li>\n<li><code>函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了</code>，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。</li>\n<li><code>而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，</code>因此，调用函数表达式要在定义后进行使用。</li>\n</ul>\n<h2 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h2><p><a href=\"https://juejin.cn/post/6844904019165446158\">https://juejin.cn/post/6844904019165446158</a></p>\n","text":"变量var let const区别 变量提升：var 存在变量提升，let、const没有（let、const存在暂时性死区） 作用域的限制：var不受作用域的限制，而let、const受当前作用域的限制 重复声明：var可以重复声明，let、const不可以 const是常量，...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":26,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":28,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":17,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#var-let-const%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">var let const区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">变量分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">变量声明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">全局作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">函数作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">块级作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#other\"><span class=\"toc-text\">other</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"面试题汇总","uid":"99460a2013287be2d51642da6dd169f8","slug":"2022-05-08interview","date":"2022-05-08T08:27:00.000Z","updated":"2022-07-12T13:28:18.780Z","comments":true,"path":"api/articles/2022-05-08interview.json","keywords":null,"cover":null,"text":"值得收藏的链接 码上通天 面试完 50 个人后我写下这篇总结 if 我是前端团队 Leader，怎么制定前端协作规范? 做了一份前端面试复习计划，保熟～ url解析过程 ","link":"","photos":[],"count_time":{"symbolsCount":91,"symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":2,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":17,"path":"api/tags/面试.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"如何更好的沉淀","uid":"39b06ee79b8fd96256d44a33e065e573","slug":"2022-04-28博客创建","date":"2022-05-06T01:17:27.000Z","updated":"2022-07-16T01:27:15.837Z","comments":true,"path":"api/articles/2022-04-28博客创建.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220428100720.png","text":"背景 工作日常经验性总结放哪？ 存电脑，电脑坏了重做系统没了， 放到电脑备忘录，卧槽，怎么没及时更新 放自己的服务器，没时间打理，服务器到期，嗝屁了，没来的及迁移 hexo hexo 由于有丰富的插件和主题，使用及部署方便，备受欢迎 自己购买服务器部署，服务器到期后续费很贵 放到...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"工具","slug":"工具","count":15,"path":"api/categories/工具.json"}],"tags":[{"name":"hexo","slug":"hexo","count":2,"path":"api/tags/hexo.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}