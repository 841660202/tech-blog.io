{"title":"前端基础-js变量和作用域","uid":"b231170e726e8d41c02587c56363e3ce","slug":"2022-05-08varible","date":"2022-05-08T02:00:00.000Z","updated":"2023-02-20T21:20:56.456Z","comments":true,"path":"api/articles/2022-05-08varible.json","keywords":null,"cover":[],"content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"var-let-const-区别\"><a href=\"#var-let-const-区别\" class=\"headerlink\" title=\"var let const 区别\"></a>var let const 区别</h3><ol>\n<li><code>版本</code>： var 是 es6 之前， const、let es6 之后，</li>\n<li><code>分类</code>： 在 es6 之前只有<code>全局作用域</code>和<code>函数作用域</code>， const、let 块级作用域</li>\n<li><code>提升</code>：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前使用会报错</li>\n<li><code>重复</code>：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值</li>\n<li><code>存储</code>：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li>\n<li><code>默认</code>： 默认情况下是 var 声明</li>\n<li><code>函数</code>：函数声明提升优先于 var</li>\n</ol>\n<p>补充说明： const 和不变性。</p>\n<ol>\n<li>const 创建一个变量名绑定，该绑定在创建后不能重新分配。</li>\n<li>const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。</li>\n</ol>\n<p><a href=\"/#/post/2022-09-19qa\" target=\"_blank\" >见：2022-09-19qa</a></p>\n<h3 id=\"变量分类-amp-执行结果输出\"><a href=\"#变量分类-amp-执行结果输出\" class=\"headerlink\" title=\"变量分类 &amp; 执行结果输出\"></a>变量分类 &amp; 执行结果输出</h3><ul>\n<li>js 中的变量分为两种：</li>\n</ul>\n<ol>\n<li>全局变量和局部变量。</li>\n<li><code>全局变量</code>很好理解，就是在 js 任何地方都能够调用的变量；</li>\n<li>而<code>局部变量</code>就只能在函数的内部才能够调用的变量。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; 10;\nfunction show() &#123;\n  console.log(&quot;a:&quot; + a); &#x2F;&#x2F;a:10\n  var b &#x3D; 2;\n  console.log(&quot;inside b:&quot; + b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&quot;outside b:&quot; + b); &#x2F;&#x2F;b is no defined</code></pre>\n\n<p>在上面的程序中，</p>\n<ol>\n<li>变量 a 就是一个全局变量，在函数的内部能够调用。</li>\n<li>但是这里的变量 b 就是局部变量，</li>\n<li>当函数结束调用后，变量 b 就被回收了，因此在函数外部调用失败。</li>\n</ol>\n<p><em>另外需要特别注意的是：</em></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果在声明局部变量时不用 var 声明，那么这个变量自动“提升”为全局变量。</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; 10;\nfunction show() &#123;\n  console.log(&quot;a:&quot; + a); &#x2F;&#x2F;a:10\n  b &#x3D; 2;\n  console.log(&quot;inside b:&quot; + b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&quot;outside b:&quot; + b); &#x2F;&#x2F;outside b:2</code></pre>\n\n<p>对比两段代码，</p>\n<ol>\n<li>如果你在声明 b&#x3D;2 时没有写 var，那么 b 就隐式地声明为全局变量，在函数外面还是能够被调用到的。</li>\n<li>虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了<em>缺点</em>：<ol>\n<li><code>一直占用内存</code>：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。</li>\n<li><code>影响了函数的独立性</code>：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，</li>\n<li><code>可移植性</code>: 同时也降低了函数的可移植性。</li>\n</ol>\n</li>\n</ol>\n<p><strong>因此我们在定义变量时一般要尽可能少的定义全局变量。</strong></p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>函数声明优先于变量声明 (这句话的意思是：<code>如果有一样的变量标识符，会先进性函数声明，忽略掉变量声明</code>)</p>\n<p>下面我们通过一段代码来说明.</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a;\nfunction a() &#123;&#125;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 或许有人是认为函数声明在后面的原因，那么调换一下位置。</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function a() &#123;&#125;\nvar a;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。\n&#x2F;&#x2F; 因此函数声明优先于变量的声明。\n&#x2F;&#x2F; 但是如果我们在声明的同时给a进行赋值。</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function a() &#123;&#125;\nvar a &#x3D; &quot;xyf&quot;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 我们将其调换一下位置再次进行验证。</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; &quot;xyf&quot;;\nfunction a() &#123;&#125;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function a() &#123;&#125;\nvar a;\na &#x3D; &quot;xyf&quot;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; a最后被赋值为字符串，因此a的类型自然是字符串</code></pre>\n\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p>js 中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><p>js 中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>let const<em>有块级作用域</em>。函数作用域是比较容易理解的，那么什么是块级作用域呢？</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;var a &#x3D; 1&#125;\n\nconsole.log(a)\nVM2355:1 1\n</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;let a &#x3D;1&#125;\n\nconsole.log(a)\nVM2079:1 Uncaught ReferenceError: a is not defined</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>任何一对花括号<code>&#123;&#125;</code>中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p></blockquote>\n<p>理解了块级作用域，来看一下下面的小例子。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(v); &#x2F;&#x2F;undefined\nvar v &#x3D; &quot;world&quot;; &#x2F;&#x2F; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。</code></pre>\n\n<p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p>\n<p>由于 js 作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v;\nconsole.log(v); &#x2F;&#x2F;undefined\nv &#x3D; &quot;world&quot;;\n&#x2F;&#x2F; 这样就能很清晰地理解为什么变量v是undefined的了。\n&#x2F;&#x2F;下面我们把变量v放到一个方法中去：</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  var v &#x3D; &quot;hello&quot;;\n&#125;\nconsole.log(v); &#x2F;&#x2F;hello\n&#x2F;&#x2F; 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，\n&#x2F;&#x2F; 并不能够“阻挡”外面的代码获取里面的变量。</code></pre>\n\n<h3 id=\"函数作用域实例\"><a href=\"#函数作用域实例\" class=\"headerlink\" title=\"函数作用域实例\"></a>函数作用域实例</h3><p>我们再把变量 v 放到函数中去：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function show() &#123;\n  var v &#x3D; &quot;world&quot;;\n&#125;\nshow();\nconsole.log(v); &#x2F;&#x2F;undefined</code></pre>\n\n<p>由于 show 函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量 v。因此证明了 js 中只有函数作用域，没有块级作用域。<br>　　再来看下面的一段代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v &#x3D; &quot;hello&quot;;\nfunction show() &#123;\n  console.log(v); &#x2F;&#x2F;undefined\n  var v &#x3D; &quot;world&quot;;\n&#125;\nshow();</code></pre>\n\n<p><strong>很多人看到这边都会很疑惑，不是说这边 show 函数中能够获取到函数外面的变量的么？</strong></p>\n<p>但是由于这边是一个函数作用域，而<code>函数作用域存在着变量声明的提前</code>，因此，上面的代码相当于下面的代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v &#x3D; &quot;hello&quot;;\nfunction show() &#123;\n  var v;\n  console.log(v); &#x2F;&#x2F;undefined\n  v &#x3D; &quot;world&quot;;\n&#125;\nshow();</code></pre>\n\n<p>这里把变量 v 的声明放到了整个函数作用域的最前面，因此显示为 <code>undefined</code>。理解了上面的代码，相信下面的代码也不难理解了。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var v &#x3D; &quot;hello&quot;;\n(function () &#123;\n  console.log(v);\n  var v &#x3D; &quot;world&quot;;\n&#125;)();</code></pre>\n\n<p>在这里自执行函数形成了函数作用域</p>\n<p>需要注意的是</p>\n<p><strong>变量提升只提升函数的声明，并不提升函数的定义</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">show(); &#x2F;&#x2F;show is not a function\nvar show &#x3D; function () &#123;\n  &#x2F;&#x2F;...\n&#125;;\nshow(); &#x2F;&#x2F;成功运行</code></pre>\n\n<p>或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在 js 中是如何进行定义的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>函数有两种定义方式，一种是<code>函数声明</code>，另一种是<code>函数表达式</code>。那么什么是函数声明什么是函数表达式呢？</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;函数声明\nfunction show() &#123;\n  &#x2F;&#x2F;....\n&#125;\n&#x2F;&#x2F;函数表达式\nvar show &#x3D; function () &#123;\n  &#x2F;&#x2F;...\n&#125;;</code></pre>\n\n<p>乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。</p>\n<ol>\n<li>js 的解析器对<code>函数声明</code>和<code>函数表达式</code>并不是一视同仁的对待的，有点“种族歧视”的意思在里面。</li>\n<li><code>函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了</code>，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。</li>\n<li><code>而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，</code>因此，调用函数表达式要在定义后进行使用。</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202209201228344.webp\" />\n\n<p><a href=\"https://blog.csdn.net/weixin_46112649/article/details/126376367\" target=\"_blank\" >见</a></p>\n<h2 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var b &#x3D; 10;\n(function b() &#123;\n  b &#x3D; 20;\n  console.log(b);\n&#125;)();</code></pre>\n\n<ol>\n<li>代码进入预解析状态，将 var b 进行变量提升，此时 b 没有被赋值(b&#x3D;undefined) (这里有人会说这里明明有个函数表达式呀，为什么没有进入变量提升，因为 <code>IIFE 自带有词法作用域</code>(我们常理解得作用域))</li>\n<li>发现没有可以变量提升得时候将 b 赋值为 10，此时会将 b 赋值为 10(b&#x3D;10)</li>\n<li>碰到了立即执行函数，会执行其内边的函数 <code>function b()</code></li>\n<li>IIFE 作用域中定义<code> b = function b()&#123;&#125;</code></li>\n<li>碰到了 b &#x3D; 20，<code>会顺着作用域链寻找是否存在 b，发现 IIFE 作用域中存在 b，将 IIFE 作用域中的 b 赋值为 20(b=20)(因为函数表达式特性，标识符无法被修改，所以这里执行失败)</code></li>\n<li>执行 console.log(b)，此时的 b 会找 IIFE 中的作用域看看是否存在 b，发现其内边存在，将其返回</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/weixin_46112649/article/details/126376367\" target=\"_blank\" >解析 var b &#x3D; 10； (function b(){ b &#x3D; 20 console.log(b) })()</a></p>\n<h2 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h2><p><a href=\"https://juejin.cn/post/6844904019165446158\" target=\"_blank\" >https://juejin.cn/post/6844904019165446158</a></p>\n<p><a href=\"https://doc.yonyoucloud.com/doc/wiki/project/javascript-depth-understanding/function-expression.html\" target=\"_blank\" >见</a></p>\n<h2 id=\"typeof-null\"><a href=\"#typeof-null\" class=\"headerlink\" title=\"typeof null\"></a>typeof null</h2><p><strong>null 作为一个基本数据类型为什么会被 typeof 运算符识别为 object 类型呢？</strong></p>\n<p>这个 bug 是第一版 Javascript 留下来的，javascript 中不同对象在底层都表示为二进制，而 <code>javascript 中会把二进制前三位都为 0 的判断为 object 类型</code>，而 <code> null 的二进制表示全都是 0，自然前三位也是 0</code>，<code>所以执行 typeof 时会返回 ‘object’。 </code></p>\n<p>—-引用自《你不知道的 javascript（上卷）》</p>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function async1() &#123;\n  console.log(&quot;1&quot;);\n  await async2();\n  console.log(&quot;2&quot;);\n&#125;\n\nasync function async2() &#123;\n  console.log(&quot;3&quot;);\n&#125;\n\nconsole.log(&quot;4&quot;);\n\nsetTimeout(function () &#123;\n  console.log(&quot;5&quot;);\n&#125;, 0);\n\nasync1();\n\nnew Promise(function (resolve) &#123;\n  console.log(&quot;6&quot;);\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;7&quot;);\n&#125;);\n\nconsole.log(&quot;8&quot;);</code></pre>\n\n<ol>\n<li>async 内部到 await 之前都是同步执行的</li>\n<li>遇到 await 会转交控制权</li>\n<li>同步任务执行完成后，await 会重新获得执行的控制权，继续执行往下执行</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 4, 1, 3, 6, 8, 2, 7, 5</code></pre>\n\n<h2 id=\"this-指向\"><a href=\"#this-指向\" class=\"headerlink\" title=\"this 指向\"></a>this 指向</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var name &#x3D; &quot;123&quot;;\n\nvar obj &#x3D; &#123;\n  name: &quot;456&quot;,\n  print: function () &#123;\n    function a() &#123;\n      console.log(this.name);\n    &#125;\n    a();\n  &#125;,\n&#125;;\n\nobj.print();</code></pre>\n\n<p><a href=\"https://juejin.cn/post/7142690757722243102\" target=\"_blank\" >见</a></p>\n","text":"变量var let const 区别 版本： var 是 es6 之前， const、let es6 之后， 分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域 提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"},{"name":"结果输出","slug":"结果输出","count":1,"path":"api/tags/结果输出.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">var let const 区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB-amp-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">变量分类 &amp; 执行结果输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">变量声明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">全局作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">函数作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">块级作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">函数作用域实例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">立即执行函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#other\"><span class=\"toc-text\">other</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typeof-null\"><span class=\"toc-text\">typeof null</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this-%E6%8C%87%E5%90%91\"><span class=\"toc-text\">this 指向</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"面试题汇总","uid":"99460a2013287be2d51642da6dd169f8","slug":"2022-05-08interview","date":"2022-05-08T08:27:00.000Z","updated":"2023-02-20T21:20:56.456Z","comments":true,"path":"api/articles/2022-05-08interview.json","keywords":null,"cover":null,"text":"值得收藏的链接 码上通天 面试完 50 个人后我写下这篇总结 if 我是前端团队 Leader，怎么制定前端协作规范? 做了一份前端面试复习计划，保熟～ url 解析过程 zoomdong 面经 见 ","link":"","photos":[],"count_time":{"symbolsCount":108,"symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":4,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"如何更好的沉淀","uid":"39b06ee79b8fd96256d44a33e065e573","slug":"2022-04-28博客创建","date":"2022-05-06T01:17:27.000Z","updated":"2023-02-20T21:20:56.455Z","comments":true,"path":"api/articles/2022-04-28博客创建.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220428100720.png","text":"背景 工作日常经验性总结放哪？ 存电脑，电脑坏了重做系统没了， 放到电脑备忘录，卧槽，怎么没及时更新 放自己的服务器，没时间打理，服务器到期，嗝屁了，没来的及迁移 hexo hexo 由于有丰富的插件和主题，使用及部署方便，备受欢迎 自己购买服务器部署，服务器到期后续费很贵 放到...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"工具","slug":"工具","count":17,"path":"api/categories/工具.json"}],"tags":[{"name":"hexo","slug":"hexo","count":4,"path":"api/tags/hexo.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}