{"title":"wiki Laser Pen","uid":"2e69f09f2b5424b80304135ea166c436","slug":"2022-05-27wiki-laserPen","date":"2022-05-27T08:07:33.000Z","updated":"2022-09-16T13:54:56.121Z","comments":true,"path":"api/articles/2022-05-27wiki-laserPen.json","keywords":null,"cover":[],"content":"<h2 id=\"Laser-Pen\"><a href=\"#Laser-Pen\" class=\"headerlink\" title=\"Laser Pen\"></a>Laser Pen</h2><p><code>Laser Pen </code>是一套用来在 web canvas 上绘制鼠标轨迹的工具集。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p><code>wiki</code>全屏演示时候，为了便于听众跟随演讲者进度，给鼠标轨迹加上标记。</p>\n<p><img src=\"http://t-blog-images.aijs.top/img/demo.gif\"></p>\n<p>注：公司项目由于版权问题，不便演示</p>\n<h2 id=\"初步上手\"><a href=\"#初步上手\" class=\"headerlink\" title=\"初步上手\"></a>初步上手</h2><p>首先在你的项目中添加对 Laser Pen 的依赖：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add laser-pen</code></pre>\n<p>或者</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm i laser-pen\n</code></pre>\n<p>然后监听鼠标的 move 事件，获取鼠标移动轨迹的坐标，并同时记录 move 事件触发时的时间戳。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 获取 canvas 元素的坐标\nconst canvasDom &#x3D; document.querySelector(&#39;canvas&#39;)\nconst canvasPos &#x3D; canvasDom.getBoundingClientRect()\nconst ctx &#x3D; canvas.getContext(&#39;2d&#39;)\n&#x2F;&#x2F; 用来存储所有鼠标轨迹数据\nlet mouseTrack &#x3D; []\n&#x2F;&#x2F; 监听鼠标事件\ndocument.addEventListener(&#39;mousemove&#39;, (event) &#x3D;&gt; &#123;\n  mouseTrack.push(&#123;\n    x: event.clientX - canvasPos.x,\n    y: event.clientY - canvasPos.y,\n    time: Date.now(),\n  &#125;)\n&#125;)\n</code></pre>\n<p>最后在调用 drawLaserPen 方法绘制鼠标轨迹</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; drainPoints, drawLaserPen &#125; from &#39;laser-pen&#39;\n\nfunction draw() &#123;\n  &#x2F;&#x2F; 过滤掉一些失效的轨迹坐标\n  mouseTrack &#x3D; drainPoints(mouseTrack)\n  if (mouseTrack.length &gt;&#x3D; 3) &#123;\n    &#x2F;&#x2F; 绘制鼠标轨迹\n    drawLaserPen(ctx, mouseTrack)\n  &#125;\n  requestAnimation(draw)\n&#125;\n</code></pre>\n\n<p>到这里，你应该已经可以在 canvas 上实现鼠标轨迹的绘制了。</p>\n<h2 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h2><p>如果默认的轨迹效果不能满足你的要求，Laser Pen 还提供了一些接口让你可以方便的修改鼠标轨迹的样式。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 设置延迟时间，mousemove 事件产生的坐标点在超过延迟时间后就不会被绘制，会直接影响轨迹的长度\nsetDelay: (millisecond: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最大宽度，轨迹是一条由粗变细的曲线，maxWidth 表示粗的那一头的线宽\nsetMaxWidth: (width: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最小宽度，轨迹是一条由粗变细的曲线，minWidth 表示细的那一头的线宽\nsetMinWidth: (width: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置曲线张力大小，张力越大拐点处越平滑，反之越尖锐\nsetTension: (t: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最小透明度，轨迹是一条由不透明变透明的曲线，opacity 表示轨迹末尾的不透明度\nsetOpacity: (o: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的颜色\nsetColor: (r: number, g: number, b: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹头部是否是圆形\nsetRoundCap: (b: boolean) &#x3D;&gt; void;</code></pre>\n\n<p>在任何时候调用上述接口修改鼠标轨迹的样式，都会在紧接着的下一次绘制中生效。所以如果你想实现一个类似 RGB 跑马灯的鼠标轨迹也是可以的。</p>\n<h2 id=\"定制化开发\"><a href=\"#定制化开发\" class=\"headerlink\" title=\"定制化开发\"></a>定制化开发</h2><p>如果上面的接口都不能满足你的要求，那么你就需要做一些定制化的开发了。</p>\n<p>绘制鼠标轨迹的过程大概分为 5 个步骤：</p>\n<p>清洗轨迹坐标数据<br>根据轨迹坐标计算每个坐标的控制点<br>通过坐标点和控制点数据生成 Bezier 曲线<br>将上一步生成的曲线分割为更短的 Bezier 曲线，并计算每条曲线的绘制样式<br>依次绘制每条 Bezier 曲线<br>这 5 个步骤对应下面的第 1 到第 5 个接口，最后的 drawLaserPen 接口是对前面 5 个接口的组合。 如果直接调用 drawLaserPen 不能满足你的要求，你可以在前 5 个接口的基础上自行组合，实现你想要的效果。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 去掉原始鼠标坐标数据中不合理的数据，包括超过延迟时间的坐标，和一些排列不合法的坐标\ndrainPoints: (originalPoints: IOriginalPointData[]) &#x3D;&gt; IOriginalPointData[];\n&#x2F;&#x2F; 根据鼠标坐标数据计算每个坐标点的前后控制点\ncalControlPoints: (points: IPoint[]) &#x3D;&gt; IControlPoint[];\n&#x2F;&#x2F; 将鼠标坐标数据和控制点数据组合为贝塞尔曲线\ntransformPointToBezier: (\n  points: IPoint[],\n  controlPoints: IControlPoint[]\n) &#x3D;&gt; Bezier[];\n&#x2F;&#x2F; 根据原始的贝塞尔曲线数据，计算出用于绘制的数据结构\ncalDrawingData: (\n  bzArray: Bezier[],\n  totalLength: number\n) &#x3D;&gt; IDrawingBezierData[];\n&#x2F;&#x2F; 根据计算出的绘制数据，将曲线绘制到画布上\ndrawDrawingBezierData: (\n  ctx: CanvasRenderingContext2D,\n  data: IDrawingBezierData[]\n) &#x3D;&gt; void;\n&#x2F;&#x2F; 一个方便简单使用的入口方法，直接通过处理好的鼠标坐标数据，绘制鼠标轨迹\ndrawLaserPen: (ctx: CanvasRenderingContext2D, points: IPoint[]) &#x3D;&gt; void;\n</code></pre>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><a href=\"https://github.com/SilentTiger/laser-pen\">laser-pen</a></li>\n<li>突然有个想法：王者荣耀的拖尾效果实现原理，是不是和这个类似？</li>\n</ul>\n","text":"Laser PenLaser Pen 是一套用来在 web canvas 上绘制鼠标轨迹的工具集。 使用场景wiki全屏演示时候，为了便于听众跟随演讲者进度，给鼠标轨迹加上标记。 注：公司项目由于版权问题，不便演示 初步上手首先在你的项目中添加对 Laser Pen 的依赖： y...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"wiki","slug":"wiki","count":3,"path":"api/categories/wiki.json"}],"tags":[{"name":"wiki","slug":"wiki","count":4,"path":"api/tags/wiki.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Laser-Pen\"><span class=\"toc-text\">Laser Pen</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E6%AD%A5%E4%B8%8A%E6%89%8B\"><span class=\"toc-text\">初步上手</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">参数配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E5%88%B6%E5%8C%96%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">定制化开发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-编程范式-函数式编程简单了解","uid":"f35528e9b34223f99b96c0561880d949","slug":"2022-05-28func","date":"2022-05-28T07:25:33.000Z","updated":"2022-09-16T13:54:56.121Z","comments":true,"path":"api/articles/2022-05-28func.json","keywords":null,"cover":null,"text":"背景js 为了实现面向对象的思想，做了很多事情，导致大家在学习 js 的时候，会遇到复杂的原型、原型链、继承，还有对人不友好的 this ；而当我们用这些东西组合起来模拟面向对象的特性的时候，就更加痛苦了。但我们可以使用一种更友好的方式，函数式编程。简单来说就是：面向对象的思想在...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":17,"path":"api/tags/面试.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"redux-logger源码","uid":"8b8288a2a8637d5beee93bb6d37a8ba8","slug":"2022-05-27redux-logger","date":"2022-05-27T05:52:01.000Z","updated":"2022-09-16T14:58:09.031Z","comments":true,"path":"api/articles/2022-05-27redux-logger.json","keywords":null,"cover":[],"text":"redux 日志中间件. ├── core.js ├── defaults.js ├── diff.js ├── helpers.js &#x2F;&#x2F; 一些帮助函数 └── index.js 0 directories, 5 files defaultLoggerv3 ...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"React","slug":"React","count":18,"path":"api/categories/React.json"}],"tags":[{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}