{"title":"前端基础-webpack系列","uid":"1e83d022f4eb1c3b94dc11a21715ce7c","slug":"2022-07-14webpack","date":"2022-07-14T14:19:31.000Z","updated":"2023-08-03T07:16:59.566Z","comments":true,"path":"api/articles/2022-07-14webpack.json","keywords":null,"cover":null,"content":"<h2 id=\"webpack-与-grunt、gulp-的不同？\"><a href=\"#webpack-与-grunt、gulp-的不同？\" class=\"headerlink\" title=\"webpack 与 grunt、gulp 的不同？\"></a>webpack 与 grunt、gulp 的不同？</h2><ul>\n<li><p><code>Grunt、Gulp</code> 是基于任务运⾏的⼯具： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插 件，能⽅便的打造各种⼯作流。</p>\n</li>\n<li><p><code>Webpack</code> 是基于模块化打包的⼯具: ⾃动化处理模块,webpack 把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。 因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤ npm script 代替 Grunt、Gulp,npm script 同样可以打造任务流</p>\n</li>\n</ul>\n<h2 id=\"webpack、rollup、parcel、vite-优劣？\"><a href=\"#webpack、rollup、parcel、vite-优劣？\" class=\"headerlink\" title=\"webpack、rollup、parcel、vite 优劣？\"></a>webpack、rollup、parcel、vite 优劣？</h2><ul>\n<li>webpack 适⽤于⼤型复杂的前端站点构建: webpack 有强⼤的 loader 和插件⽣态,打包后的⽂件实际上就是⼀个⽴即 执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执 ⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发.</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote>\n<ul>\n<li>Rollup</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。</p></blockquote>\n<ul>\n<li>parcel 极速零配置 Web 应用打包工具</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>🚀 <code>极速打包</code>: Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。</p>\n<p>📦 <code>将你所有的资源打包</code>: Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。</p>\n<p>🐠 <code>自动转换</code>: 如若有需要，Babel, PostCSS, 和 PostHTML 甚至 node_modules 包会被用于自动转换代码.</p>\n<p>✂️ <code>零配置代码分拆</code>: 使用动态 import() 语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。</p>\n<p>🔥 <code>热模块替换</code>: Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。</p>\n<p>🚨 <code>友好的错误日志</code>:当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题。</p></blockquote>\n<ul>\n<li>vite 下一代前端开发与构建工具</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>📦 <code>极速的服务启动</code>: 使用原生 ESM 文件，无需打包!</p>\n<p>⚡️ <code>轻量快速的热重载</code>: 无论应用程序大小如何，都始终极快的模块热重载（HMR）</p>\n<p>🛠️ <code>丰富的功能</code>: 对 TypeScript、JSX、CSS 等支持开箱即用。</p>\n<p>📦 <code>优化的构建</code>: 可选 “多页应用” 或 “库” 模式的预配置 Rollup 构建</p>\n<p>🔩 <code>通用的插件</code>: 在开发和构建之间共享 Rollup-superset 插件接口。</p>\n<p>🔑 <code>完全类型化的 API</code>: 灵活的 API 和完整 TypeScript 类型。</p></blockquote>\n<h2 id=\"有哪些常⻅的-Loader？\"><a href=\"#有哪些常⻅的-Loader？\" class=\"headerlink\" title=\"有哪些常⻅的 Loader？\"></a>有哪些常⻅的 Loader？</h2><p><a href=\"https://www.webpackjs.com/loaders/url-loader/\" target=\"_blank\" >更多</a></p>\n<p><strong>文件相关的</strong></p>\n<!-- - `raw-loader`：加载文件原始内容（utf-8） -->\n\n<ul>\n<li><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li>\n<li><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li>\n<li><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</li>\n<li><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</li>\n<li><code>image-loader</code>：加载并且压缩图片文件</li>\n<li><code>json-loader</code> 加载 JSON 文件（默认包含）</li>\n<li><code>handlebars-loader</code>: 将 Handlebars 模版编译成函数并返回</li>\n</ul>\n<p><strong>脚本相关的</strong></p>\n<ul>\n<li><code>babel-loader</code>：把 ES6 转换成 ES5</li>\n<li><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</li>\n<li><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li>\n</ul>\n<p><strong>样式相关的</strong></p>\n<ul>\n<li><code>sass-loader</code>：将 SCSS&#x2F;SASS 代码转换成 CSS</li>\n<li><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</li>\n<li><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li>\n<li><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li>\n</ul>\n<p><strong>校验相关的</strong></p>\n<ul>\n<li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li>\n<li><code>tslint-loader</code>：通过 TSLint 检查 TypeScript 代码</li>\n</ul>\n<p><strong>测试相关的</strong></p>\n<ul>\n<li><code>mocha-loader</code>：加载 Mocha 测试用例的代码</li>\n<li><code>coverjs-loader</code>：计算测试的覆盖率</li>\n</ul>\n<p><strong>框架相关的</strong></p>\n<ul>\n<li><code>vue-loader</code>：加载 Vue.js 单文件组件</li>\n</ul>\n<p><strong>语言相关的</strong></p>\n<ul>\n<li><code>i18n-loader</code>: 国际化</li>\n</ul>\n<p><strong>性能相关的</strong></p>\n<ul>\n<li><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li>\n</ul>\n<p><a href=\"https://webpack.docschina.org/loaders/cache-loader/#getting-started\" target=\"_blank\" >见 webpack cache-loader</a></p>\n<h3 id=\"source-map-loader-是做什么的\"><a href=\"#source-map-loader-是做什么的\" class=\"headerlink\" title=\"source-map-loader 是做什么的\"></a>source-map-loader 是做什么的</h3><p><code>source-map-loader</code>是 Webpack 的一个加载器（loader），它用于加载已经存在的 Source Map 文件，并将其应用于 Webpack 构建过程中的 JavaScript 代码。</p>\n<p>Source Map 是一种文件，它存储了原始源代码和生成的压缩&#x2F;合并后的代码之间的映射关系。在进行前端代码压缩和合并时，由于压缩后的代码难以阅读和调试，Source Map 可以帮助开发者在浏览器的开发者工具中还原压缩后的代码到原始源代码，方便调试和定位问题。</p>\n<p><code>source-map-loader</code>的作用就是将 Source Map 加载进 Webpack 构建过程中，以便在构建时为压缩后的代码生成对应的 Source Map。这样，当代码在浏览器中执行时，开发者在浏览器的开发者工具中可以看到原始的源代码，而不是压缩后的代码。</p>\n<p>通常，当使用 Webpack 进行前端代码的构建和压缩时，开发者会在生成的压缩文件的同时生成对应的 Source Map 文件。然后通过配置<code>source-map-loader</code>，将 Source Map 加载进 Webpack 构建过程，从而实现在浏览器中进行源代码的调试和定位问题。</p>\n<p>示例配置（假设有生成的压缩文件<code>main.js</code>和对应的 Source Map 文件<code>main.js.map</code>）：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,\n  output: &#123;\n    filename: &#39;main.js&#39;,\n  &#125;,\n  devtool: &#39;source-map&#39;, &#x2F;&#x2F; 使用source-map进行代码映射\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;,\n        use: &#39;source-map-loader&#39;, &#x2F;&#x2F; 使用source-map-loader加载Source Map\n        enforce: &#39;pre&#39;, &#x2F;&#x2F; 在其他loader之前应用\n      &#125;,\n    ],\n  &#125;,\n&#125;;</code></pre>\n\n<p>通过配置<code>source-map-loader</code>，当使用<code>devtool: &#39;source-map&#39;</code>时，Webpack 会加载<code>main.js.map</code>文件，并将 Source Map 应用于构建过程中，从而实现在浏览器中进行源代码的调试和定位问题。</p>\n<h3 id=\"浏览器中调试，加载的是-main-js-map-还是-main-js？\"><a href=\"#浏览器中调试，加载的是-main-js-map-还是-main-js？\" class=\"headerlink\" title=\"浏览器中调试，加载的是 main.js.map 还是 main.js？\"></a>浏览器中调试，加载的是 main.js.map 还是 main.js？</h3><p>在浏览器中进行调试时，加载的是<code>main.js.map</code>文件而不是<code>main.js</code>文件。当你开启了 Source Map 选项（通常是通过 Webpack 的<code>devtool</code>配置开启）并加载页面时，浏览器会根据<code>main.js.map</code>文件中的映射关系还原压缩后的<code>main.js</code>源代码，使你在浏览器的开发者工具中看到的是原始的源代码而不是压缩后的代码。</p>\n<p>Source Map 是一种用于调试的辅助工具，它存储了压缩后的代码和原始源代码之间的映射关系。通过 Source Map，开发者可以在浏览器的开发者工具中进行源代码级别的调试，查看原始代码的变量名、行号、列号等信息，从而更方便地进行代码的调试和定位问题。</p>\n<p>当你在浏览器中打开开发者工具（通常是按下 F12 键），浏览器会自动加载对应的 Source Map 文件，并将其应用于已经压缩的 JavaScript 代码，从而还原为原始的源代码，方便你进行调试和查看错误。这使得在生产环境中使用压缩的代码进行调试变得更加方便和高效。</p>\n<h3 id=\"是不是这个时候浏览器执行的是-Source-Map-代码？\"><a href=\"#是不是这个时候浏览器执行的是-Source-Map-代码？\" class=\"headerlink\" title=\"是不是这个时候浏览器执行的是 Source Map 代码？\"></a>是不是这个时候浏览器执行的是 Source Map 代码？</h3><p>不，浏览器在调试时执行的仍然是压缩后的 JavaScript 代码（即<code>main.js</code>文件），而不是 Source Map 代码（<code>main.js.map</code>文件）。Source Map 文件只用于映射压缩后的代码到原始的源代码，它并不会被浏览器直接执行。</p>\n<p>当开启了 Source Map 选项并加载页面时，浏览器会根据<code>main.js.map</code>文件中的映射关系还原压缩后的<code>main.js</code>源代码。这样，在浏览器的开发者工具中，你看到的是还原后的原始源代码，而实际执行的是压缩后的代码。</p>\n<p>Source Map 的主要作用是在调试时提供一个映射关系，帮助开发者在浏览器的开发者工具中对应到原始的源代码，方便进行调试和定位问题。而实际的代码执行仍然是压缩后的代码，以确保生产环境中的性能和资源优化。</p>\n<p>所以，在开启 Source Map 的情况下，浏览器在调试时执行的仍然是压缩后的 JavaScript 代码，而不是 Source Map 代码。Source Map 只是在调试时提供帮助，不会影响实际的代码执行。</p>\n<h3 id=\"那岂不是此时浏览器中有两套代码在运行？一套是纯执行的，一套是纯调试的？\"><a href=\"#那岂不是此时浏览器中有两套代码在运行？一套是纯执行的，一套是纯调试的？\" class=\"headerlink\" title=\"那岂不是此时浏览器中有两套代码在运行？一套是纯执行的，一套是纯调试的？\"></a>那岂不是此时浏览器中有两套代码在运行？一套是纯执行的，一套是纯调试的？</h3><p>实际上，在开启了 Source Map 的情况下，浏览器确实会同时加载两套代码，但不是同时执行两套代码。</p>\n<p>具体的过程如下：</p>\n<ol>\n<li><p>加载压缩后的代码：浏览器首先加载压缩后的 JavaScript 代码（<code>main.js</code>文件），这是实际运行在浏览器中的代码。这些压缩后的代码通常是经过压缩、合并等优化处理的，用于提高页面加载性能。</p>\n</li>\n<li><p>加载 Source Map 文件：同时，浏览器会加载对应的 Source Map 文件（<code>main.js.map</code>文件）。这个文件包含了压缩后的代码和原始源代码之间的映射关系。</p>\n</li>\n<li><p>调试时应用 Source Map：当你在浏览器的开发者工具中进行调试时，浏览器会根据 Source Map 文件中的映射关系，将压缩后的代码还原成原始的源代码，并在开发者工具中显示原始源代码。这样你就可以在开发者工具中进行源代码级别的调试和查看。</p>\n</li>\n</ol>\n<p>所以，在调试时，浏览器确实会加载两套代码，一套是压缩后的代码用于实际执行，另一套是 Source Map 文件用于还原原始源代码进行调试。但在实际执行时，只有压缩后的代码在运行，而 Source Map 文件仅用于调试目的，并不会影响实际的代码执行。这种设计使得在生产环境中能够使用优化后的压缩代码，并在调试时方便地查看和调试原始源代码，从而兼顾了性能和调试的需求。</p>\n<h3 id=\"调试时候如何区分调试的是-Source-Map，而不是压缩合并后的代码？\"><a href=\"#调试时候如何区分调试的是-Source-Map，而不是压缩合并后的代码？\" class=\"headerlink\" title=\"调试时候如何区分调试的是 Source Map，而不是压缩合并后的代码？\"></a>调试时候如何区分调试的是 Source Map，而不是压缩合并后的代码？</h3><p>在浏览器的开发者工具中调试时，可以通过以下几个方面来区分调试的是 Source Map 而不是压缩合并后的代码：</p>\n<ol>\n<li><p>源代码显示：在开发者工具中，当你使用 Source Map 进行调试时，会显示原始的源代码而不是压缩合并后的代码。源代码中会保留变量名、函数名和原始的代码结构，而不是被压缩的简化形式。</p>\n</li>\n<li><p>Source Map 映射：在开发者工具中，Source Map 会提供一个映射关系，显示哪一行原始源代码对应压缩合并后的代码的哪一行。这样你就可以方便地在开发者工具中跟踪源代码在压缩代码中的位置。</p>\n</li>\n<li><p>调试位置提示：当你在开发者工具中打开调试面板时，会显示当前执行的代码位置。如果调试的是 Source Map，会显示原始源代码的位置（文件名和行号），而不是压缩代码的位置。</p>\n</li>\n<li><p>变量名和函数名：在开发者工具的调试面板中，当你查看变量和函数时，如果调试的是 Source Map，会显示原始的变量名和函数名，而不是被压缩的简化形式。</p>\n</li>\n</ol>\n<p>总的来说，通过在开发者工具中观察源代码显示、Source Map 映射、调试位置提示和变量名、函数名等信息，可以清楚地区分调试的是 Source Map 而不是压缩合并后的代码。这样你就可以方便地在浏览器中进行源代码级别的调试和定位问题。</p>\n<h3 id=\"awesome-typescript-loader：将-TypeScript-转换成-JavaScript，性能优于-ts-loader\"><a href=\"#awesome-typescript-loader：将-TypeScript-转换成-JavaScript，性能优于-ts-loader\" class=\"headerlink\" title=\"awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader\"></a>awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</h3><p><code>awesome-typescript-loader</code>和<code>ts-loader</code>都是用于将 TypeScript 代码转换为 JavaScript 代码的 Webpack 加载器。它们在 TypeScript 项目中扮演着类似的角色，但在性能方面有所不同。</p>\n<ol>\n<li><p><code>ts-loader</code>：<br><code>ts-loader</code>是官方维护的 TypeScript 加载器，它是 Webpack 社区最早使用的 TypeScript 加载器之一。它会将 TypeScript 代码转换为 JavaScript 代码，并将结果传递给 Webpack 进行后续处理。由于<code>ts-loader</code>是官方推荐的加载器，因此在一些情况下，它可能会与 Webpack 和 TypeScript 更好地集成。</p>\n</li>\n<li><p><code>awesome-typescript-loader</code>：<br><code>awesome-typescript-loader</code>是由社区维护的 TypeScript 加载器，旨在提供更好的性能和额外的特性。它采用了一些优化措施，如缓存编译结果，从而在重新构建时加快构建速度。与<code>ts-loader</code>相比，<code>awesome-typescript-loader</code>的性能通常更好，尤其是在大型项目中。</p>\n</li>\n</ol>\n<p>选择使用<code>awesome-typescript-loader</code>还是<code>ts-loader</code>取决于您的具体项目需求。如果您的项目较小且性能要求不高，<code>ts-loader</code>可能已经足够满足您的需要。但如果您的项目较大且构建时间较长，那么<code>awesome-typescript-loader</code>可能是一个更好的选择，它可以提供更好的构建性能和额外的优化特性。</p>\n<p>请注意，随着 Webpack 和 TypeScript 的不断更新，加载器的性能和功能可能会发生变化，建议在使用加载器时查阅官方文档以了解最新的信息和推荐。</p>\n<h2 id=\"有哪些常⻅的-Plugin？\"><a href=\"#有哪些常⻅的-Plugin？\" class=\"headerlink\" title=\"有哪些常⻅的 Plugin？\"></a>有哪些常⻅的 Plugin？</h2><p><strong>基本</strong></p>\n<ul>\n<li><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li>\n<li><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</li>\n<li><code>clean-webpack-plugin</code>: 目录清理</li>\n</ul>\n<p><strong>编译范围优化相关</strong></p>\n<ul>\n<li><code>ignore-plugin</code>：忽略部分文件</li>\n<li><code>WatchIgnorePlugin</code></li>\n</ul>\n<p><strong>压缩优化相关</strong></p>\n<ul>\n<li><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</li>\n<li><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</li>\n<li><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</li>\n<li></li>\n<li><code>MinChunkSizePlugin</code>：设置拆分代码块的最小尺寸，优化代码拆分和加载性能。</li>\n<li><code>CssMinimizerWebpackPlugin</code>：压缩 CSS 代码，减小 CSS 文件的大小，优化样式表加载性能。</li>\n<li><code>HtmlMinimizerWebpackPlugin</code>：压缩 HTML 代码，减小 HTML 文件的大小，优化 HTML 文件加载性能。</li>\n<li><code>ImageMinimizerWebpackPlugin</code>：压缩图像文件，减小图像的大小，优化图像加载性能。</li>\n<li><code>JsonMinimizerWebpackPlugin</code>：压缩 JSON 文件，减小 JSON 文件的大小，优化 JSON 文件加载性能。</li>\n<li><code>MiniCssExtractPlugin</code>：将 CSS 代码从 JavaScript 中提取出来，生成单独的 CSS 文件，实现更好的浏览器缓存和加载性能。</li>\n<li><code>TerserWebpackPlugin</code>： 是用于压缩和混淆 JavaScript 代码，减小输出文件的体积，提高加载速度。</li>\n</ul>\n<p><strong>其他优化相关</strong></p>\n<ul>\n<li><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)</li>\n<li><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</li>\n<li><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</li>\n</ul>\n<p><strong>分析相关</strong></p>\n<ul>\n<li><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li>\n<li><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li>\n</ul>\n<h2 id=\"分别介绍-bundle，chunk，module-是什么\"><a href=\"#分别介绍-bundle，chunk，module-是什么\" class=\"headerlink\" title=\"分别介绍 bundle，chunk，module 是什么\"></a>分别介绍 bundle，chunk，module 是什么</h2><ul>\n<li><code>bundle</code>：是由 webpack 打包出来的⽂件</li>\n<li><code>chunk</code>：代码块，⼀个 chunk 由多个模块组合⽽成，⽤于代码的合并和分割</li>\n<li><code>module</code>：是开发中的单个模块，在 webpack 的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack 会从配置的 entry 中递归开始找出所有依赖的模块</li>\n</ul>\n<h2 id=\"压缩插件比较\"><a href=\"#压缩插件比较\" class=\"headerlink\" title=\"压缩插件比较\"></a>压缩插件比较</h2><ul>\n<li>MinChunkSizePlugin</li>\n<li>CssMinimizerWebpackPlugin</li>\n<li>HtmlMinimizerWebpackPlugin</li>\n<li>ImageMinimizerWebpackPlugin</li>\n<li>JsonMinimizerWebpackPlugin</li>\n<li>MiniCssExtractPlugin</li>\n</ul>\n<p>这几个与 - TerserWebpackPlugin 是否重复？</p>\n<p>这些插件的功能和作用如下：</p>\n<ol>\n<li><code>MinChunkSizePlugin</code>：设置拆分代码块的最小尺寸，优化代码拆分和加载性能。</li>\n<li><code>CssMinimizerWebpackPlugin</code>：压缩 CSS 代码，减小 CSS 文件的大小，优化样式表加载性能。</li>\n<li><code>HtmlMinimizerWebpackPlugin</code>：压缩 HTML 代码，减小 HTML 文件的大小，优化 HTML 文件加载性能。</li>\n<li><code>ImageMinimizerWebpackPlugin</code>：压缩图像文件，减小图像的大小，优化图像加载性能。</li>\n<li><code>JsonMinimizerWebpackPlugin</code>：压缩 JSON 文件，减小 JSON 文件的大小，优化 JSON 文件加载性能。</li>\n<li><code>MiniCssExtractPlugin</code>：将 CSS 代码从 JavaScript 中提取出来，生成单独的 CSS 文件，实现更好的浏览器缓存和加载性能。</li>\n</ol>\n<p><code>TerserWebpackPlugin</code>是用于压缩和混淆 JavaScript 代码，减小输出文件的体积，提高加载速度。</p>\n<p>总结：这些插件都是用于优化构建输出的不同方面，包括代码拆分、CSS、HTML、图像、JSON 文件的压缩和优化，以及将 CSS 代码从 JavaScript 中提取出来等。它们的功能和作用互补，可以一起使用来优化整个项目的构建输出。</p>\n<h2 id=\"HtmlWebpackPlugin\"><a href=\"#HtmlWebpackPlugin\" class=\"headerlink\" title=\"HtmlWebpackPlugin\"></a>HtmlWebpackPlugin</h2><p>对于<code>webpack</code>中常用的插件是<code>HtmlWebpackPlugin</code>，它用于生成 HTML 文件，并自动将打包后的 JavaScript 和 CSS 资源文件注入到 HTML 中。以下是<code>HtmlWebpackPlugin</code>的一些常用配置选项：</p>\n<ol>\n<li><p><code>template</code>: 指定 HTML 模板文件的路径，插件会根据该模板文件生成最终的 HTML 文件。</p>\n</li>\n<li><p><code>filename</code>: 指定生成的 HTML 文件的文件名，默认是<code>index.html</code>。</p>\n</li>\n<li><p><code>title</code>: 设置 HTML 文件的标题。</p>\n</li>\n<li><p><code>inject</code>: 控制资源文件的注入方式。可以设置为<code>true</code>、<code>body</code>、<code>head</code>或<code>false</code>。默认为<code>true</code>，表示自动将资源文件注入到 HTML 文件的<code>&lt;body&gt;</code>元素底部。</p>\n</li>\n<li><p><code>minify</code>: 压缩生成的 HTML 文件，可以设置为布尔值或对象来指定压缩选项。</p>\n</li>\n<li><p><code>chunks</code>: 指定要包含的代码块（JavaScript 模块）。</p>\n</li>\n<li><p><code>excludeChunks</code>: 指定要排除的代码块（JavaScript 模块）。</p>\n</li>\n<li><p><code>meta</code>: 设置 HTML 文件的 meta 标签。</p>\n</li>\n<li><p><code>favicon</code>: 设置 HTML 文件的 favicon 图标。</p>\n</li>\n<li><p><code>hash</code>: 将生成的文件名添加 hash 值，用于缓存处理。</p>\n</li>\n<li><p><code>cache</code>: 开启或关闭文件缓存。</p>\n</li>\n<li><p><code>showErrors</code>: 将错误信息显示在 HTML 文件中。</p>\n</li>\n<li><p><code>chunksSortMode</code>: 控制代码块的排序方式。</p>\n</li>\n<li><p><code>xhtml</code>: 是否为 XHTML 模式。</p>\n</li>\n</ol>\n<p>这些配置选项可以根据具体需求进行灵活配置，以满足不同项目的需求。以下是一个示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);\n\nmodule.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,\n  output: &#123;\n    filename: &#39;bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;),\n  &#125;,\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      template: &#39;.&#x2F;src&#x2F;index.html&#39;, &#x2F;&#x2F; 指定HTML模板文件\n      filename: &#39;index.html&#39;, &#x2F;&#x2F; 指定生成的HTML文件名\n      title: &#39;My App&#39;, &#x2F;&#x2F; 设置HTML文件的标题\n      inject: &#39;body&#39;, &#x2F;&#x2F; 将资源文件注入到HTML文件的&lt;body&gt;元素底部\n      minify: &#123;\n        collapseWhitespace: true, &#x2F;&#x2F; 压缩HTML文件\n      &#125;,\n      chunks: [&#39;main&#39;], &#x2F;&#x2F; 指定要包含的代码块\n      favicon: &#39;.&#x2F;src&#x2F;favicon.ico&#39;, &#x2F;&#x2F; 设置HTML文件的favicon图标\n      hash: true, &#x2F;&#x2F; 添加hash值\n    &#125;),\n  ],\n&#125;;</code></pre>\n\n<p>请注意，<code>HtmlWebpackPlugin</code>还有更多的配置选项，详细信息可以参考官方文档：<a href=\"https://github.com/jantimon/html-webpack-plugin#options\">https://github.com/jantimon/html-webpack-plugin#options</a></p>\n<h2 id=\"AutomaticPrefetchPlugin-PrefetchPlugin-是什么\"><a href=\"#AutomaticPrefetchPlugin-PrefetchPlugin-是什么\" class=\"headerlink\" title=\"AutomaticPrefetchPlugin PrefetchPlugin 是什么\"></a>AutomaticPrefetchPlugin PrefetchPlugin 是什么</h2><p>在 Webpack 中，<code>AutomaticPrefetchPlugin</code>和<code>PrefetchPlugin</code>是两个插件，用于优化模块的加载和代码分割。</p>\n<ol>\n<li><code>AutomaticPrefetchPlugin</code>：<br><code>AutomaticPrefetchPlugin</code>是 Webpack 4.6.0 版本及以上引入的插件，它用于自动预取（automatic prefetching）模块。预取是指在加载当前页面时，浏览器会在空闲时间异步加载其他页面可能需要的模块，从而提前获取这些模块，以优化后续页面的加载性能。</li>\n</ol>\n<p><code>AutomaticPrefetchPlugin</code>会根据 Webpack 的运行情况和配置，自动分析代码中的异步模块，并将一些异步模块标记为预取，告诉浏览器在空闲时加载这些模块。这样可以减少后续页面的加载时间，提升用户体验。</p>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const AutomaticPrefetchPlugin &#x3D; require(&#39;webpack&#39;).AutomaticPrefetchPlugin;\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new AutomaticPrefetchPlugin(),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li><code>PrefetchPlugin</code>：<br><code>PrefetchPlugin</code>也是 Webpack 提供的插件，它用于手动预取（manual prefetching）模块。与<code>AutomaticPrefetchPlugin</code>自动预取不同，<code>PrefetchPlugin</code>需要手动指定要预取的模块，而不是由 Webpack 自动进行分析和决定。</li>\n</ol>\n<p>通过<code>PrefetchPlugin</code>，可以在特定情况下手动标记一些模块为预取，以便在空闲时提前加载这些模块。这对于一些特定的场景和页面来说可能是更灵活的优化方式。</p>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new webpack.PrefetchPlugin(&#39;.&#x2F;src&#x2F;async-module.js&#39;),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<p>总结：</p>\n<ul>\n<li><code>AutomaticPrefetchPlugin</code>是 Webpack 自动预取插件，它会自动分析代码中的异步模块，并将一些异步模块标记为预取，以优化后续页面的加载性能。</li>\n<li><code>PrefetchPlugin</code>是手动预取插件，可以手动指定要预取的模块，以实现更灵活的优化。</li>\n</ul>\n<h2 id=\"CommonsChunkPlugin-MinChunkSizePlugin-SplitChunksPlugin-各自作用\"><a href=\"#CommonsChunkPlugin-MinChunkSizePlugin-SplitChunksPlugin-各自作用\" class=\"headerlink\" title=\"CommonsChunkPlugin MinChunkSizePlugin SplitChunksPlugin 各自作用\"></a>CommonsChunkPlugin MinChunkSizePlugin SplitChunksPlugin 各自作用</h2><p>在 Webpack 中，<code>CommonsChunkPlugin</code>、<code>MinChunkSizePlugin</code>和<code>SplitChunksPlugin</code>都是用于代码分割和提取共享模块的插件，但它们在实现上有一些区别和作用。</p>\n<ol>\n<li><code>CommonsChunkPlugin</code>（已弃用）：<br>在 Webpack 4 之前，使用<code>CommonsChunkPlugin</code>来提取共享模块是常见的做法。它的作用是将多个入口（entry）之间共享的模块提取出来，生成一个单独的共享模块（通常称为 vendor 或 common chunk），以避免重复打包这些公共模块。</li>\n</ol>\n<p>然而，自 Webpack 4.0 开始，<code>CommonsChunkPlugin</code>已经被废弃，并推荐使用<code>SplitChunksPlugin</code>来替代它。</p>\n<ol start=\"2\">\n<li><code>MinChunkSizePlugin</code>：<br><code>MinChunkSizePlugin</code>是 Webpack 的内置插件，它的作用是用于设置最小的代码块（chunk）大小。当你使用<code>SplitChunksPlugin</code>进行代码分割时，<code>MinChunkSizePlugin</code>可以帮助你控制生成的代码块的大小，避免生成过小的代码块。</li>\n</ol>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new webpack.optimize.MinChunkSizePlugin(&#123;\n      minChunkSize: 10000, &#x2F;&#x2F; 设置最小的代码块大小为10KB\n    &#125;),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li><code>SplitChunksPlugin</code>：<br><code>SplitChunksPlugin</code>是 Webpack 4 之后引入的代码分割插件，它用于自动分析代码中的共享模块，并将这些共享模块提取成单独的代码块。通过<code>SplitChunksPlugin</code>，你可以根据配置选项来实现灵活的代码分割和提取共享模块的策略。</li>\n</ol>\n<p><code>SplitChunksPlugin</code>通过一些配置选项来控制代码分割的行为，例如<code>chunks</code>、<code>minSize</code>、<code>minChunks</code>、<code>maxAsyncRequests</code>、<code>maxInitialRequests</code>等等。你可以根据项目需求和优化目标，调整这些配置选项来达到最佳的代码分割效果。</p>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  optimization: &#123;\n    splitChunks: &#123;\n      chunks: &#39;all&#39;, &#x2F;&#x2F; 提取所有类型的模块，包括同步和异步的\n      minSize: 30000, &#x2F;&#x2F; 设置最小的模块大小为30KB\n      cacheGroups: &#123;\n        vendor: &#123;\n          test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;,\n          name: &#39;vendor&#39;, &#x2F;&#x2F; 提取出来的共享模块名称\n          chunks: &#39;all&#39;, &#x2F;&#x2F; 同时提取同步和异步模块中的共享模块\n        &#125;,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;;</code></pre>\n\n<p>总结：</p>\n<ul>\n<li><code>CommonsChunkPlugin</code>是 Webpack 4 之前的代码分割插件，用于提取共享模块。</li>\n<li><code>MinChunkSizePlugin</code>是 Webpack 的内置插件，用于设置最小的代码块大小。</li>\n<li><code>SplitChunksPlugin</code>是 Webpack 4 之后的代码分割插件，用于自动分析代码中的共享模块，并根据配置选项来实现代码分割和提取共享模块的策略。推荐使用<code>SplitChunksPlugin</code>来取代<code>CommonsChunkPlugin</code>。</li>\n</ul>\n<h2 id=\"DefinePlugin-EnvironmentPlugin\"><a href=\"#DefinePlugin-EnvironmentPlugin\" class=\"headerlink\" title=\"DefinePlugin EnvironmentPlugin\"></a>DefinePlugin EnvironmentPlugin</h2><p><code>DefinePlugin</code>和<code>EnvironmentPlugin</code>都是 Webpack 的插件，用于在打包过程中定义全局的常量和环境变量。</p>\n<ol>\n<li><code>DefinePlugin</code>：<br><code>DefinePlugin</code>允许你在 Webpack 的编译过程中创建全局的常量，这些常量可以在你的代码中直接使用。在打包时，<code>DefinePlugin</code>会将这些常量替换为对应的值。这对于在代码中设置一些全局的配置项、环境相关的常量或者开关变量非常有用。</li>\n</ol>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new webpack.DefinePlugin(&#123;\n      &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;), &#x2F;&#x2F; 设置环境变量\n      API_URL: JSON.stringify(&#39;https:&#x2F;&#x2F;api.example.com&#39;), &#x2F;&#x2F; 设置全局常量\n      DEBUG: false, &#x2F;&#x2F; 设置开关变量\n    &#125;),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<p>在上面的示例中，<code>DefinePlugin</code>会将<code>process.env.NODE_ENV</code>替换为<code>&quot;production&quot;</code>，将<code>API_URL</code>替换为<code>&quot;https://api.example.com&quot;</code>，将<code>DEBUG</code>替换为<code>false</code>。这些常量可以在你的代码中直接使用，例如通过<code>process.env.NODE_ENV</code>来获取当前的环境。</p>\n<ol start=\"2\">\n<li><code>EnvironmentPlugin</code>：<br><code>EnvironmentPlugin</code>是 Webpack 4.0.0 及以上版本引入的插件，它可以简化设置全局环境变量的过程。它允许你将环境变量直接传递给 Webpack，而不需要手动使用<code>DefinePlugin</code>来进行设置。</li>\n</ol>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new webpack.EnvironmentPlugin(&#123;\n      NODE_ENV: &#39;production&#39;, &#x2F;&#x2F; 设置环境变量\n      API_URL: &#39;https:&#x2F;&#x2F;api.example.com&#39;, &#x2F;&#x2F; 设置全局常量\n      DEBUG: false, &#x2F;&#x2F; 设置开关变量\n    &#125;),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<p><code>EnvironmentPlugin</code>会将指定的环境变量传递给 Webpack，这些环境变量可以在你的代码中直接使用，不需要进行额外的配置。</p>\n<p>总结：</p>\n<ul>\n<li><code>DefinePlugin</code>用于在 Webpack 编译过程中创建全局常量，需要手动配置常量的值。</li>\n<li><code>EnvironmentPlugin</code>用于简化设置全局环境变量的过程，直接传递环境变量给 Webpack。</li>\n</ul>\n<h2 id=\"DllPlugin-和-DllReferencePlugin\"><a href=\"#DllPlugin-和-DllReferencePlugin\" class=\"headerlink\" title=\"DllPlugin 和 DllReferencePlugin\"></a>DllPlugin 和 DllReferencePlugin</h2><p><code>DllPlugin</code>和<code>DllReferencePlugin</code>是 Webpack 的两个插件，用于将第三方依赖库（如 React、Vue、lodash 等）进行预编译，并在后续的构建过程中引用预编译的依赖库，以提高构建速度和性能。</p>\n<ol>\n<li><code>DllPlugin</code>：<br><code>DllPlugin</code>用于将第三方依赖库预编译成单独的动态链接库（DLL）。预编译 DLL 的过程只需要进行一次，并将结果保存在独立的文件中，然后在后续的 Webpack 构建过程中直接引用该 DLL 文件，避免重复构建第三方依赖库，从而提高构建速度。</li>\n</ol>\n<p>使用<code>DllPlugin</code>时，你需要在一个单独的 Webpack 配置中使用该插件，将第三方依赖库预编译成 DLL。</p>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  entry: &#123;\n    vendor: [&#39;react&#39;, &#39;react-dom&#39;, &#39;lodash&#39;], &#x2F;&#x2F; 需要预编译的第三方依赖库\n  &#125;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;[name].dll.js&#39;,\n    library: &#39;[name]&#39;, &#x2F;&#x2F; 与 DllReferencePlugin 中的 name 对应\n  &#125;,\n  plugins: [\n    new webpack.DllPlugin(&#123;\n      name: &#39;[name]&#39;, &#x2F;&#x2F; 与 output.library 对应\n      path: path.resolve(__dirname, &#39;dist&#x2F;[name].manifest.json&#39;), &#x2F;&#x2F; 生成的 manifest 文件\n    &#125;),\n  ],\n&#125;;</code></pre>\n\n<p>在上面的示例中，我们通过<code>DllPlugin</code>将<code>react</code>、<code>react-dom</code>和<code>lodash</code>这三个第三方依赖库预编译成一个名为<code>vendor.dll.js</code>的 DLL 文件，并生成对应的<code>vendor.manifest.json</code>文件。</p>\n<ol start=\"2\">\n<li><code>DllReferencePlugin</code>：<br><code>DllReferencePlugin</code>用于在后续的 Webpack 构建过程中，引用预编译的 DLL 文件。通过引用 DLL 文件，Webpack 在构建过程中会直接使用预编译的依赖库，而不需要重复构建这些依赖库，从而提高构建速度。</li>\n</ol>\n<p>使用<code>DllReferencePlugin</code>时，你需要在主 Webpack 配置中使用该插件，引用之前预编译好的 DLL 文件。</p>\n<p>示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new webpack.DllReferencePlugin(&#123;\n      context: __dirname,\n      manifest: require(&#39;.&#x2F;dist&#x2F;vendor.manifest.json&#39;), &#x2F;&#x2F; 引用预编译的 manifest 文件\n    &#125;),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<p>在上面的示例中，我们通过<code>DllReferencePlugin</code>引用之前预编译好的<code>vendor.manifest.json</code>文件。</p>\n<p>总结：</p>\n<ul>\n<li><code>DllPlugin</code>用于将第三方依赖库预编译成 DLL 文件。</li>\n<li><code>DllReferencePlugin</code>用于在后续的 Webpack 构建过程中引用预编译的 DLL 文件，避免重复构建第三方依赖库，提高构建速度和性能。</li>\n</ul>\n<h2 id=\"预编译-echarts-和-lodash-（单个入口）\"><a href=\"#预编译-echarts-和-lodash-（单个入口）\" class=\"headerlink\" title=\"预编译 echarts 和 lodash （单个入口）\"></a>预编译 echarts 和 lodash （单个入口）</h2><p>预编译 ECharts 和 lodash 的过程和之前提到的预编译 ECharts 的过程类似，我们可以将 ECharts 和 lodash 分别预编译成两个单独的动态链接库（DLL），然后在后续的 Webpack 构建过程中引用这两个预编译好的 DLL 文件，从而优化构建过程。</p>\n<ol>\n<li>使用<code>DllPlugin</code>预编译 ECharts：<br>首先，我们使用<code>DllPlugin</code>将 ECharts 库预编译成一个单独的动态链接库（DLL），类似于下面的示例配置：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  entry: &#123;\n    echarts: [&#39;echarts&#39;], &#x2F;&#x2F; 需要预编译的ECharts库\n  &#125;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;[name].dll.js&#39;,\n    library: &#39;[name]&#39;, &#x2F;&#x2F; 与 DllReferencePlugin 中的 name 对应\n  &#125;,\n  plugins: [\n    new webpack.DllPlugin(&#123;\n      name: &#39;[name]&#39;, &#x2F;&#x2F; 与 output.library 对应\n      path: path.resolve(__dirname, &#39;dist&#x2F;[name].manifest.json&#39;), &#x2F;&#x2F; 生成的 manifest 文件\n    &#125;),\n  ],\n&#125;;</code></pre>\n\n<p>上面的配置会将<code>echarts</code>这个 ECharts 库预编译成一个名为<code>echarts.dll.js</code>的 DLL 文件，并生成对应的<code>echarts.manifest.json</code>文件。</p>\n<ol start=\"2\">\n<li>使用<code>DllPlugin</code>预编译 lodash：<br>类似地，我们使用<code>DllPlugin</code>将 lodash 库预编译成一个单独的动态链接库（DLL），示例配置如下：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  entry: &#123;\n    lodash: [&#39;lodash&#39;], &#x2F;&#x2F; 需要预编译的lodash库\n  &#125;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;[name].dll.js&#39;,\n    library: &#39;[name]&#39;, &#x2F;&#x2F; 与 DllReferencePlugin 中的 name 对应\n  &#125;,\n  plugins: [\n    new webpack.DllPlugin(&#123;\n      name: &#39;[name]&#39;, &#x2F;&#x2F; 与 output.library 对应\n      path: path.resolve(__dirname, &#39;dist&#x2F;[name].manifest.json&#39;), &#x2F;&#x2F; 生成的 manifest 文件\n    &#125;),\n  ],\n&#125;;</code></pre>\n\n<p>上面的配置会将<code>lodash</code>这个库预编译成一个名为<code>lodash.dll.js</code>的 DLL 文件，并生成对应的<code>lodash.manifest.json</code>文件。</p>\n<ol start=\"3\">\n<li>使用<code>DllReferencePlugin</code>引用预编译的 DLL：<br>最后，在主 Webpack 配置中使用<code>DllReferencePlugin</code>来引用预编译好的 ECharts 和 lodash 库，避免重复构建这些库，示例配置如下：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new webpack.DllReferencePlugin(&#123;\n      context: __dirname,\n      manifest: require(&#39;.&#x2F;dist&#x2F;echarts.manifest.json&#39;), &#x2F;&#x2F; 引用预编译的 ECharts 的 manifest 文件\n    &#125;),\n    new webpack.DllReferencePlugin(&#123;\n      context: __dirname,\n      manifest: require(&#39;.&#x2F;dist&#x2F;lodash.manifest.json&#39;), &#x2F;&#x2F; 引用预编译的 lodash 的 manifest 文件\n    &#125;),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<p>在上面的示例中，我们分别引用了预编译好的<code>echarts.manifest.json</code>和<code>lodash.manifest.json</code>文件。</p>\n<p>通过这样的配置，Webpack 在后续的构建过程中会直接使用预编译的 ECharts 和 lodash 库，而不需要重新构建这些库，从而提高构建速度和性能。注意要确保在主 Webpack 配置中引用了预编译的 DLL 文件，以确保这些库被正确地引入到项目中。</p>\n<h2 id=\"预编译-echarts-和-lodash（多入口）\"><a href=\"#预编译-echarts-和-lodash（多入口）\" class=\"headerlink\" title=\"预编译 echarts 和 lodash（多入口）\"></a>预编译 echarts 和 lodash（多入口）</h2><p>是的，你可以将多个库都放在<code>entry</code>中进行配置，每个库对应一个入口点，然后分别使用不同的<code>output.filename</code>和<code>output.library</code>来生成多个 DLL 文件。</p>\n<p>以下是修改后的示例配置：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  entry: &#123;\n    echarts: [&#39;echarts&#39;], &#x2F;&#x2F; 需要预编译的ECharts库\n    lodash: [&#39;lodash&#39;], &#x2F;&#x2F; 需要预编译的lodash库\n  &#125;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;[name].dll.js&#39;,\n    library: &#39;[name]&#39;, &#x2F;&#x2F; 与 DllReferencePlugin 中的 name 对应\n  &#125;,\n  plugins: [\n    new webpack.DllPlugin(&#123;\n      name: &#39;echarts&#39;, &#x2F;&#x2F; 与 output.library 对应\n      path: path.resolve(__dirname, &#39;dist&#x2F;echarts.manifest.json&#39;), &#x2F;&#x2F; 生成的 echarts manifest 文件\n    &#125;),\n    new webpack.DllPlugin(&#123;\n      name: &#39;lodash&#39;, &#x2F;&#x2F; 与 output.library 对应\n      path: path.resolve(__dirname, &#39;dist&#x2F;lodash.manifest.json&#39;), &#x2F;&#x2F; 生成的 lodash manifest 文件\n    &#125;),\n  ],\n&#125;;</code></pre>\n\n<p>在上面的示例中，我们将 ECharts 和 lodash 都放在<code>entry</code>中进行配置，然后使用<code>[name].dll.js</code>和<code>[name]</code>来生成对应的 DLL 文件，其中<code>[name]</code>会根据<code>entry</code>中的键值（即’echarts’和’lodash’）动态生成。这样，Webpack 会根据每个入口点分别生成<code>echarts.dll.js</code>和<code>lodash.dll.js</code>两个 DLL 文件，并分别生成对应的<code>echarts.manifest.json</code>和<code>lodash.manifest.json</code>两个 manifest 文件。</p>\n<p>然后，你需要在主 Webpack 配置中使用<code>DllReferencePlugin</code>来引用这些预编译好的 DLL 文件，示例配置如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const webpack &#x3D; require(&#39;webpack&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...其他配置...\n  plugins: [\n    new webpack.DllReferencePlugin(&#123;\n      context: __dirname,\n      manifest: require(&#39;.&#x2F;dist&#x2F;echarts.manifest.json&#39;), &#x2F;&#x2F; 引用预编译的 ECharts 的 manifest 文件\n    &#125;),\n    new webpack.DllReferencePlugin(&#123;\n      context: __dirname,\n      manifest: require(&#39;.&#x2F;dist&#x2F;lodash.manifest.json&#39;), &#x2F;&#x2F; 引用预编译的 lodash 的 manifest 文件\n    &#125;),\n    &#x2F;&#x2F; ...其他插件...\n  ],\n&#125;;</code></pre>\n\n<p>通过这样的配置，Webpack 在后续的构建过程中会直接使用预编译的 ECharts 和 lodash 库，而不需要重新构建这些库，从而提高构建速度和性能。注意要确保在主 Webpack 配置中引用了预编译的 DLL 文件，以确保这些库被正确地引入到项目中。</p>\n<h2 id=\"HashedModuleIdsPlugin\"><a href=\"#HashedModuleIdsPlugin\" class=\"headerlink\" title=\"HashedModuleIdsPlugin\"></a>HashedModuleIdsPlugin</h2><p><code>HashedModuleIdsPlugin</code>是 Webpack 的插件，用于生成短哈希值作为每个模块的标识符，保持输出文件的稳定性，并解决浏览器缓存的问题。在生产环境中使用它可以提高缓存效率，减少不必要的网络请求。</p>\n<h2 id=\"HashedModuleIdsPlugin-和-Etag\"><a href=\"#HashedModuleIdsPlugin-和-Etag\" class=\"headerlink\" title=\"HashedModuleIdsPlugin 和 Etag\"></a>HashedModuleIdsPlugin 和 Etag</h2><p><code>HashedModuleIdsPlugin</code>和 Etag 是有一些相似之处，但它们是两个不同的概念。</p>\n<ol>\n<li><p><code>HashedModuleIdsPlugin</code>：<br><code>HashedModuleIdsPlugin</code>是 Webpack 的插件，用于生成短哈希值作为每个模块的标识符，而不是生成 Etag。它的主要作用是在构建过程中给每个模块生成唯一的标识符，并保持输出文件的稳定性。这样当模块的内容不变时，它们的标识符也不会变化，从而利用浏览器的缓存来提高加载速度。</p>\n</li>\n<li><p>Etag：<br>Etag 是 HTTP 协议中的一个头部字段，用于标识资源的标识符。服务器可以根据资源的内容生成一个唯一的 Etag 值，并在 HTTP 响应的头部返回给客户端。客户端在后续请求资源时，可以将先前请求中的 Etag 值通过请求头部发送给服务器。服务器可以通过比较先前的 Etag 值与当前资源的 Etag 值来判断资源是否发生了变化。如果 Etag 值相同，则说明资源未发生变化，服务器可以返回 304 Not Modified 状态码，并告知客户端直接使用缓存的资源，从而节省带宽和提高性能。</p>\n</li>\n</ol>\n<p>虽然<code>HashedModuleIdsPlugin</code>和 Etag 都可以用于保持资源的稳定性和利用浏览器缓存来提高性能，但它们的实现和作用机制是不同的。<code>HashedModuleIdsPlugin</code>是在 Webpack 构建过程中生成模块标识符的一种方式，而 Etag 是 HTTP 协议中用于标识资源的一种机制。</p>\n<h2 id=\"Loader-和-Plugin-的不同？\"><a href=\"#Loader-和-Plugin-的不同？\" class=\"headerlink\" title=\"Loader 和 Plugin 的不同？\"></a>Loader 和 Plugin 的不同？</h2><p><strong>作用</strong></p>\n<ul>\n<li><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。<br>因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</li>\n<li><code>Plugin</code> 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li>\n</ul>\n<p><strong>使用</strong></p>\n<ul>\n<li><code>Loader</code> 在 <code>module.rules</code> 中配置，作为模块的解析规则，类型为数组。<code>每一项都是一个 Object</code>，内部包含了 <code>test</code>(类型文件)、<code>loader</code>、<code>options</code> (参数)等属性。</li>\n<li><code>Plugin</code> 在 <code>plugins</code> 中单独配置，类型为数组，<code>每一项是一个 Plugin 的实例</code>，参数都通过构造函数传入。</li>\n</ul>\n<h2 id=\"webpack-的构建流程是什么\"><a href=\"#webpack-的构建流程是什么\" class=\"headerlink\" title=\"webpack 的构建流程是什么?\"></a>webpack 的构建流程是什么?</h2><p>Webpack 的运行流程是一个<code>串行的过程</code>，从启动到结束会依次执行以下流程：</p>\n<ul>\n<li><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>\n<li><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li>\n<li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件</li>\n<li><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>\n<li><code>完成模块编译</code>：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li>\n<li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>\n<li><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>\n</ul>\n<p>在以上过程中，Webpack <code>会在特定的时间点广播出特定的事件</code>，<code>插件</code>在监听到感兴趣的事件后会执行特定的逻辑，并且<code>插件</code>可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。<br>简单说</p>\n<ul>\n<li><code>初始化</code>：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</li>\n<li><code>编译</code>：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>\n<li><code>输出</code>：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li>\n</ul>\n<h2 id=\"描述下编写-loader-的思路\"><a href=\"#描述下编写-loader-的思路\" class=\"headerlink\" title=\"描述下编写 loader 的思路\"></a>描述下编写 loader 的思路</h2><p>Loader 像⼀个”翻译官”把读到的源⽂件内容转义成新的⽂件内容，并且每个 Loader 通过链式操作，将源⽂件⼀步步翻译 成想要的样⼦。 编写 Loader 时要遵循单⼀原则，每个 Loader 只做⼀种”转义”⼯作。 每个 Loader 的拿到的是源⽂件内容（ source ），可 以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给 webpack。 还可以通过 this.async() ⽣成⼀个 callback 函数，再⽤这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了 开发 loader 的⼯具函数集—— loader-utils 。<br><strong>注意</strong></p>\n<ul>\n<li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li>\n<li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li>\n<li>加载本地 Loader 方法<code>Npm link</code></li>\n</ul>\n<p><a href=\"https://www.webpackjs.com/contribute/writing-a-loader/\" target=\"_blank\" >编写一个 loader</a></p>\n<p>loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loader API，并通过 this 上下文访问。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; getOptions &#125; from &#39;loader-utils&#39;;\nimport validateOptions from &#39;schema-utils&#39;;\n\nconst schema &#x3D; &#123;\n  type: &#39;object&#39;,\n  properties: &#123;\n    test: &#123;\n      type: &#39;string&#39;,\n    &#125;,\n  &#125;,\n&#125;;\n\nexport default function (source) &#123;\n  const options &#x3D; getOptions(this);\n\n  validateOptions(schema, options, &#39;Example Loader&#39;);\n\n  &#x2F;&#x2F; 对资源应用一些转换……\n\n  return &#96;export default $&#123;JSON.stringify(source)&#125;&#96;;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;\n  test: &#x2F;\\.js$&#x2F;;\n  use: [\n    &#123;\n      loader: path.resolve(&#39;path&#x2F;to&#x2F;loader.js&#39;), &#x2F;&#x2F;直接使用本地loader\n      options: &#123;\n        &#x2F;* ... *&#x2F;\n      &#125;,\n    &#125;,\n  ];\n&#125;</code></pre>\n\n<h2 id=\"描述下编写-plugin-的思路？\"><a href=\"#描述下编写-plugin-的思路？\" class=\"headerlink\" title=\"描述下编写 plugin 的思路？\"></a>描述下编写 plugin 的思路？</h2><p>插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！</p>\n<p>插件目的在于解决 loader 无法实现的其他事。</p>\n<p>webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; ConsoleLogOnBuildWebpackPlugin.js\nconst pluginName &#x3D; &#39;ConsoleLogOnBuildWebpackPlugin&#39;;\n\nclass ConsoleLogOnBuildWebpackPlugin &#123;\n  apply(compiler) &#123;\n    &#x2F;&#x2F; 注意这个compiler\n    compiler.hooks.run.tap(pluginName, (compilation) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 注意这个compilation\n      console.log(&#39;webpack 构建过程开始！&#39;);\n    &#125;);\n  &#125;\n&#125;</code></pre>\n\n<p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。</p>\n<p><a href=\"https://www.webpackjs.com/concepts/plugins/#%E5%89%96%E6%9E%90\" target=\"_blank\" >见 plugin 剖析</a></p>\n<h2 id=\"webpack-compilation-有哪些-api，各有什么用？\"><a href=\"#webpack-compilation-有哪些-api，各有什么用？\" class=\"headerlink\" title=\"webpack compilation 有哪些 api，各有什么用？\"></a>webpack compilation 有哪些 api，各有什么用？</h2><p>Webpack 的 Compilation 对象是在每次构建过程中创建的，它包含了当前构建的所有信息和资源，是 Webpack 处理构建过程的核心对象。下面列举一些常用的 Webpack Compilation API，并解释它们的用途：</p>\n<ol>\n<li><p><code>compilation.assets</code>:<br>这是一个对象，包含了当前构建生成的所有资源文件。每个资源文件的键是文件名，值是文件内容的 Buffer 对象或字符串。通过<code>compilation.assets</code>可以访问所有构建生成的文件，可以用于自定义输出文件或其他处理。</p>\n</li>\n<li><p><code>compilation.errors</code>:<br>这是一个数组，包含了在构建过程中出现的所有错误。当构建过程中发生错误时，Webpack 会将错误信息添加到<code>compilation.errors</code>数组中。可以通过遍历该数组来处理错误，例如输出错误信息或执行一些特定的操作。</p>\n</li>\n<li><p><code>compilation.warnings</code>:<br>这是一个数组，包含了在构建过程中出现的所有警告。当构建过程中发生警告时，Webpack 会将警告信息添加到<code>compilation.warnings</code>数组中。可以通过遍历该数组来处理警告，例如输出警告信息或执行一些特定的操作。</p>\n</li>\n<li><p><code>compilation.chunks</code>:<br>这是一个数组，包含了当前构建生成的所有代码块（Chunk）。每个代码块都表示一个文件，它是由一组模块组成的。通过<code>compilation.chunks</code>可以访问所有生成的代码块，可以用于自定义代码块的输出或其他处理。</p>\n</li>\n<li><p><code>compilation.modules</code>:<br>这是一个数组，包含了当前构建生成的所有模块。每个模块都代表一个文件或代码片段。通过<code>compilation.modules</code>可以访问所有生成的模块，可以用于自定义模块的处理或其他操作。</p>\n</li>\n<li><p><code>compilation.hooks</code>:<br>这是一个钩子对象，包含了所有 Webpack Compilation 的生命周期钩子。可以使用<code>compilation.hooks</code>来注册和监听 Compilation 生命周期事件，例如在特定阶段执行自定义操作。</p>\n</li>\n<li><p><code>compilation.assetsInfo</code>:<br>这是一个对象，包含了当前构建生成的所有资源文件的信息。每个资源文件的键是文件名，值是包含文件信息的对象。通过<code>compilation.assetsInfo</code>可以访问资源文件的信息，例如文件大小、内容哈希等。</p>\n</li>\n<li><p><code>compilation.compiler</code>:<br>这是一个指向当前 Webpack Compiler 对象的引用。通过<code>compilation.compiler</code>可以访问 Compiler 对象的属性和方法，例如获取配置信息、执行额外的编译等。</p>\n</li>\n<li><p><code>compilation.addModuleDependencies(module, dependencies, bail, cacheGroup)</code>:<br>这是一个方法，用于向 Compilation 添加模块的依赖关系。可以通过调用<code>compilation.addModuleDependencies</code>来手动添加模块的依赖关系，以控制模块的加载和处理顺序。</p>\n</li>\n<li><p><code>compilation.dependencyFactories</code>和<code>compilation.dependencyTemplates</code>:<br>这是两个对象，用于存储 Webpack 的依赖工厂和依赖模板。可以通过<code>compilation.dependencyFactories</code>和<code>compilation.dependencyTemplates</code>来自定义 Webpack 的依赖解析和生成过程。</p>\n</li>\n</ol>\n<p>以上列举的是一些常用的 Webpack Compilation API，它们提供了丰富的信息和功能，用于自定义和控制 Webpack 的构建过程。在开发 Webpack 插件或进行更深入的构建定制时，这些 API 是非常有用的。</p>\n<h2 id=\"webpack-的热更新原理\"><a href=\"#webpack-的热更新原理\" class=\"headerlink\" title=\"webpack 的热更新原理\"></a>webpack 的热更新原理</h2><p>Webpack 的<code>热更新</code>又称<code>热替换</code>（Hot Module Replacement），缩写为 HMR。 这个机制可以做到<code>不用刷新浏览器</code>而将新变更的模块替换掉旧的模块。</p>\n<p>HMR 的核心就是客户端从服务端拉去更新后的文件，准确的说是 <code>chunk diff</code> (chunk 需要更新的部分)，实际上 <code>WDS</code> 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，<code>并带上构建时的 hash</code>，让客户端与上一次资源进行对比。</p>\n<p>客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。</p>\n<p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由<code> HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 <code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/30669007\" target=\"_blank\" >见</a></p>\n<h2 id=\"⽤-webpack-来优化前端性能\"><a href=\"#⽤-webpack-来优化前端性能\" class=\"headerlink\" title=\"⽤ webpack 来优化前端性能\"></a>⽤ webpack 来优化前端性能</h2><p>原则：<code>更小</code>、<code>更少</code>、<code>更近</code></p>\n<p>⽤ webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>\n<p><strong>更小</strong></p>\n<ul>\n<li><code>压缩代码</code>:删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ webpack 的 <code>UglifyJsPlugin</code> 和 <code>ParallelUglifyPlugin</code> 来压缩 JS ⽂件，</li>\n<li><code>利⽤ cssnano</code> （css-loader?minimize）来压缩 css</li>\n<li><code>Tree Shaking</code>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现</li>\n</ul>\n<p><strong>更少</strong></p>\n<ul>\n<li><code>Code Splitting</code>: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li>\n<li><code>提取公共第三⽅库</code>: SplitChunksPlugin 插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的 公共代码</li>\n</ul>\n<p><strong>更近</strong></p>\n<ul>\n<li><code>利⽤ CDN 加速</code>: 在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤ webpack 对 于 output 参数和各 loader 的 publicPath 参数来修改资源路径</li>\n</ul>\n<h2 id=\"提⾼-webpack-的打包速度\"><a href=\"#提⾼-webpack-的打包速度\" class=\"headerlink\" title=\"提⾼ webpack 的打包速度\"></a>提⾼ webpack 的打包速度</h2><p><strong>打个比方：</strong></p>\n<p>一期需求时间紧任务重，领导来了，说要明天上线。<br>如何做到更快上线？（需要：<code>更多的研发资源</code>（并行）；<code>之前有的功能组件直接用</code>（不重复做事）；<code>砍几个需求吧</code>（更小的范围））</p>\n<p><strong>用更厉害的</strong></p>\n<ul>\n<li>高版本<code>node</code>和<code>webpack</code></li>\n</ul>\n<p><strong>并行</strong></p>\n<ul>\n<li><code>happypack</code>: 利⽤进程并⾏编译 loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类 似的替代者是<code>thread-loader</code></li>\n</ul>\n<p><strong>不重复做事</strong></p>\n<ul>\n<li><code>外部扩展(externals)</code>: 将不怎么需要更新的第三⽅库脱离 webpack 打包，不被打⼊ bundle 中，从⽽减少打包时间,⽐ 如 jQuery <code>⽤ script 标签引⼊</code></li>\n<li><code>dll</code>: 采⽤ webpack 的 <code>DllPlugin</code> 和 <code>DllReferencePlugin</code> 引⼊ dll，让⼀些基本不会改动的代码先打包成静态资源,避免 反复编译浪费时间</li>\n<li><code>利⽤缓存</code>: <code>webpack.cache</code> 、<code>babel-loader.cacheDirectory</code>、 <code>HappyPack.cache</code> 都可以利⽤缓存提⾼ rebuild 效率</li>\n</ul>\n<p><strong>更小的范围</strong></p>\n<ul>\n<li><code>缩⼩⽂件搜索范围</code>: ⽐如 babel-loader 插件,如果你的⽂件仅存在于 src 中,那么可以 include: path.resolve(__dirname, ‘src’) ,当然绝⼤多数情况下这种操作的提升有限,除⾮不⼩⼼ build 了 node_modules ⽂件</li>\n</ul>\n<h2 id=\"提⾼-webpack-的构建速度\"><a href=\"#提⾼-webpack-的构建速度\" class=\"headerlink\" title=\"提⾼ webpack 的构建速度\"></a>提⾼ webpack 的构建速度</h2><ul>\n<li>高版本<code>node</code>和<code>webpack</code></li>\n<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li>\n<li>通过 <code>externals</code> 配置来提取常⽤库</li>\n<li>利⽤ <code>DllPlugin</code> 和 <code>DllReferencePlugin</code> 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li>\n<li>使⽤ <code>Happypack</code> 实现多线程加速编译</li>\n<li>使⽤ <code>webpack-uglify-parallel</code> 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏ 压缩来提升压缩速度</li>\n<li>使⽤ <code>Tree-shaking</code> 和 <code>Scope Hoisting</code> 来剔除多余代码</li>\n</ul>\n<h2 id=\"怎么配置单⻚应⽤？怎么配置多⻚应⽤？\"><a href=\"#怎么配置单⻚应⽤？怎么配置多⻚应⽤？\" class=\"headerlink\" title=\"怎么配置单⻚应⽤？怎么配置多⻚应⽤？\"></a>怎么配置单⻚应⽤？怎么配置多⻚应⽤？</h2><ul>\n<li><p><code>单⻚应⽤</code>可以理解为 webpack 的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述</p>\n<br/>\n<br/>\n</li>\n<li><p><code>多⻚应⽤</code>的话，可以使⽤ webpack 的 <code>AutoWebPlugin</code> 来完成简单⾃动化的构建，但是前提是项⽬的<code>⽬录结构必须遵守他预设的规范</code>。</p>\n</li>\n<li><p>多⻚应⽤中要注意的是： <code>每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载</code>。⽐如，每个⻚⾯都引⽤了同⼀套 css 样式表随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让<code>⼊⼝的配置⾜够灵活</code>，避免每次添加新⻚⾯还需要修改构建配置</p>\n</li>\n</ul>\n<h2 id=\"source-map-是什么？生产环境怎么用？\"><a href=\"#source-map-是什么？生产环境怎么用？\" class=\"headerlink\" title=\"source map 是什么？生产环境怎么用？\"></a>source map 是什么？生产环境怎么用？</h2><p><code>source map</code> 是将编译、打包、压缩后的代码映射回源代码的过程。</p>\n<ul>\n<li><code>打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map</code>。</li>\n<li>map 文件只要不打开开发者工具，浏览器是不会加载的。</li>\n</ul>\n<p><strong>线上环境一般有三种处理方案：</strong></p>\n<ul>\n<li><code>hidden-source-map</code>：借助第三方错误监控平台 Sentry 使用</li>\n<li><code>nosources-source-map</code>：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</li>\n<li><code>sourcemap</code>：通过<code>nginx</code> 设置将 <code>.map</code> 文件<code>只对白名单开放</code>(公司内网)</li>\n</ul>\n<p>注意：避免在生产中使用 <code>inline-</code> 和 <code>eval-</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p>\n<p><a href=\"https://juejin.cn/post/6844903450644316174\" target=\"_blank\" >[webpack] devtool 里的 7 种 SourceMap 模式是什么鬼？</a></p>\n<p>sourcemap 关键字如下</p>\n<p><strong>eval</strong></p>\n<p>使用 eval 包裹代码模块（这个代码块是转译后的代码，并未进行打包和压缩）<br>eval 包裹每个代码块时候，会在后面增加”sourceURL”（和 sourcemap 里的”sourceMappingURL”不同）用来定位到原文件。</p>\n<p>eval 模式优势在于，它是将每个模块单独 eval 执行，因此如果配合 source-map 使用，就可以单独缓存每个模块的 sourcemap，这样就可以在重新构建时候实现增量修改 sourcemap，节省时间。</p>\n<p>如果不使用 eval 模式，就是一个文件（chunk）对应一个 sourcemap，重新构建时候需要将整个 chunk 的 sourcemap 重新生成，更耗费时间。</p>\n<p>因此 eval 模式的优势就在于重新构建的速度更快</p>\n<p><strong>source-map</strong></p>\n<p>产生 source map</p>\n<p><strong>cheap</strong></p>\n<p>用来修饰 source-map<br>让 sourcemap 只保存行信息，不保存列信息<br>让 sourcemap 只将打包后的代码映射到转换过的代码，不映射到原始源代码<br>【由于源代码到转译后的代码的映射关系由相应的 loader 提供，因此 cheap 模式应该不需要关心这部分的 sourcemap】</p>\n<p><strong>module</strong></p>\n<p>用来修饰 cheap-source-map<br>让 sourcemap 可以映射到原始源代码<br>【由于源代码到转译后的代码的映射关系由相应的 loader 提供，因此 module 模式应该会处理这部分 sourcemap，以最终得到到原始源代码的映射】</p>\n<p><strong>inline</strong></p>\n<p>用来修饰 source-map<br>将.map 作为 DataURI 嵌入，不单独生成.map 文件</p>\n<p><a href=\"https://www.jianshu.com/p/b2316aab32bb\" target=\"_blank\" >webpack 的 sourcemap 各种参数详解</a></p>\n<table>\n<thead>\n<tr>\n<th>devtool</th>\n<th>构建速度</th>\n<th>重新构建速度</th>\n<th>生产环境</th>\n<th>品质</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(none)</td>\n<td>+++</td>\n<td>+++</td>\n<td>yes</td>\n<td>打包后的代码</td>\n</tr>\n<tr>\n<td>eval</td>\n<td>+++</td>\n<td>+++</td>\n<td>no</td>\n<td>生成后的代码</td>\n</tr>\n<tr>\n<td>source-map</td>\n<td>–</td>\n<td>–</td>\n<td>yes</td>\n<td>原始源代码</td>\n</tr>\n<tr>\n<td>eval-source-map</td>\n<td>–</td>\n<td>+</td>\n<td>no</td>\n<td>原始源代码</td>\n</tr>\n<tr>\n<td>cheap-source-map</td>\n<td>+</td>\n<td>o</td>\n<td>no</td>\n<td>转换过的代码（仅限行）</td>\n</tr>\n<tr>\n<td>cheap-module-source-map</td>\n<td>o</td>\n<td>-</td>\n<td>no</td>\n<td>原始源代码（仅限行）</td>\n</tr>\n<tr>\n<td>cheap-eval-source-map</td>\n<td>+</td>\n<td>++</td>\n<td>no</td>\n<td>转换过的代码（仅限行）</td>\n</tr>\n<tr>\n<td>cheap-module-eval-source-map</td>\n<td>o</td>\n<td>++</td>\n<td>no</td>\n<td>原始源代码（仅限行）</td>\n</tr>\n<tr>\n<td>inline-source-map</td>\n<td>–</td>\n<td>–</td>\n<td>no</td>\n<td>原始源代码</td>\n</tr>\n<tr>\n<td>inline-cheap-source-map</td>\n<td>+</td>\n<td>o</td>\n<td>no</td>\n<td>转换过的代码（仅限行）</td>\n</tr>\n<tr>\n<td>inline-cheap-module-source-map</td>\n<td>o</td>\n<td>-</td>\n<td>no</td>\n<td>原始源代码（仅限行）</td>\n</tr>\n<tr>\n<td>hidden-source-map</td>\n<td>–</td>\n<td>–</td>\n<td>yes</td>\n<td>原始源代码</td>\n</tr>\n<tr>\n<td>nosources-source-map</td>\n<td>–</td>\n<td>–</td>\n<td>yes</td>\n<td>无源代码内容</td>\n</tr>\n</tbody></table>\n<h2 id=\"chatgpt\"><a href=\"#chatgpt\" class=\"headerlink\" title=\"chatgpt\"></a>chatgpt</h2><p>在 Webpack 配置中，<code>sourcemap</code>有多个值可供选择，用于指定生成 Source Map 的方式。以下是常用的<code>sourcemap</code>选项的取值及其含义：</p>\n<ol>\n<li><p><code>false</code>：不生成 Source Map。这是默认值，表示不生成任何 Source Map 文件，适用于生产环境。</p>\n</li>\n<li><p><code>eval</code>：将 Source Map 以 Data URL 的形式包含在每个模块的末尾。生成的 Source Map 是以一种特殊的 eval 函数包裹模块的内容，适用于开发环境，可以提高构建速度。</p>\n</li>\n<li><p><code>cheap-eval-source-map</code>：生成简化的 Source Map。这种 Source Map 只包含行信息，不包含列信息，适用于开发环境，速度较快。</p>\n</li>\n<li><p><code>cheap-source-map</code>：生成简化的 Source Map，包含行信息和部分列信息。适用于开发环境，速度较快。</p>\n</li>\n<li><p><code>eval-source-map</code>：生成完整的 Source Map，但是以 Data URL 的形式包含在每个模块的末尾。适用于开发环境，可以提供准确的调试信息。</p>\n</li>\n<li><p><code>cheap-module-eval-source-map</code>：生成简化的 Source Map，包含行信息和部分列信息，同时包含 module 名称。适用于开发环境，速度较快。</p>\n</li>\n<li><p><code>cheap-module-source-map</code>：生成简化的 Source Map，包含行信息和部分列信息，同时包含 module 名称。适用于开发环境。</p>\n</li>\n<li><p><code>source-map</code>：生成完整的 Source Map，将 Source Map 文件单独生成，适用于生产环境，提供最完整的调试信息。</p>\n</li>\n<li><p><code>inline-source-map</code>：将 Source Map 以 Data URL 的形式包含在输出的 JavaScript 文件中。适用于开发环境。</p>\n</li>\n<li><p><code>hidden-source-map</code>：生成完整的 Source Map，但是不将 Source Map 文件暴露出来，适用于生产环境。</p>\n</li>\n<li><p><code>nosources-source-map</code>：生成完整的 Source Map，但是不包含源代码内容，适用于生产环境。</p>\n</li>\n</ol>\n<p>以上是常用的<code>sourcemap</code>选项的取值及其含义。不同的选项适用于不同的环境和调试需求。在开发环境中，通常使用速度较快的简化 Source Map，而在生产环境中，则可以选择生成完整的 Source Map 或不生成 Source Map，以减小构建输出的体积。</p>\n<h2 id=\"模块打包原理知道吗？\"><a href=\"#模块打包原理知道吗？\" class=\"headerlink\" title=\"模块打包原理知道吗？\"></a>模块打包原理知道吗？</h2><p>Webpack <code>实际上为每个模块创造了一个可以导出和导入的环境</code>，<code>本质上并没有修改 代码的执行逻辑</code>，<code>代码执行顺序与模块加载顺序也完全一致</code>。</p>\n<h2 id=\"文件指纹是什么？怎么用？\"><a href=\"#文件指纹是什么？怎么用？\" class=\"headerlink\" title=\"文件指纹是什么？怎么用？\"></a>文件指纹是什么？怎么用？</h2><p>文件指纹是打包后输出的文件名的后缀。</p>\n<ul>\n<li><code>Hash</code>：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</li>\n<li><code>Chunkhash</code>：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash</li>\n<li><code>Contenthash</code>：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</li>\n</ul>\n<h3 id=\"JS-的文件指纹设置\"><a href=\"#JS-的文件指纹设置\" class=\"headerlink\" title=\"JS 的文件指纹设置\"></a>JS 的文件指纹设置</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  entry: &#123;\n    app: &#39;.&#x2F;scr&#x2F;app.js&#39;,\n    search: &#39;.&#x2F;src&#x2F;search.js&#39;,\n  &#125;,\n  output: &#123;\n    filename: &#39;[name][chunkhash:8].js&#39;,\n    path: __dirname + &#39;&#x2F;dist&#39;,\n  &#125;,\n&#125;;</code></pre>\n\n<h3 id=\"CSS-的文件指纹设置\"><a href=\"#CSS-的文件指纹设置\" class=\"headerlink\" title=\"CSS 的文件指纹设置\"></a>CSS 的文件指纹设置</h3><p>设置 <code>MiniCssExtractPlugin</code> 的 <code>filename</code>，使用 <code>contenthash</code>。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  entry: &#123;\n    app: &#39;.&#x2F;scr&#x2F;app.js&#39;,\n    search: &#39;.&#x2F;src&#x2F;search.js&#39;,\n  &#125;,\n  output: &#123;\n    filename: &#39;[name][chunkhash:8].js&#39;,\n    path: __dirname + &#39;&#x2F;dist&#39;,\n  &#125;,\n  plugins: [\n    new MiniCssExtractPlugin(&#123;\n      filename: &#96;[name][contenthash:8].css&#96;,\n    &#125;),\n  ],\n&#125;;</code></pre>\n\n<h3 id=\"图片的文件指纹设置\"><a href=\"#图片的文件指纹设置\" class=\"headerlink\" title=\"图片的文件指纹设置\"></a>图片的文件指纹设置</h3><p>设置<code>file-loader</code>的<code>name</code>，使用<code>hash</code>。<br>占位符名称及含义</p>\n<ul>\n<li><code>ext</code> 资源后缀名</li>\n<li><code>name</code> 文件名称</li>\n<li><code>path</code> 文件的相对路径</li>\n<li><code>folder</code> 文件所在的文件夹</li>\n<li><code>contenthash</code> 文件的内容 hash，默认是 md5 生成</li>\n<li><code>hash</code> 文件内容的 hash，默认是 md5 生成</li>\n<li><code>emoji</code> 一个随机的指代文件内容的 emoj</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,\n  output: &#123;\n    filename: &#39;bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;),\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.(png|svg|jpg|gif)$&#x2F;,\n        use: [\n          &#123;\n            loader: &#39;file-loader&#39;, &#x2F;&#x2F; 这里\n            options: &#123;\n              name: &#39;img&#x2F;[name][hash:8].[ext]&#39;, &#x2F;&#x2F; 这里\n            &#125;,\n          &#125;,\n        ],\n      &#125;,\n    ],\n  &#125;,\n&#125;;</code></pre>\n\n<h2 id=\"如何对-bundle-体积进行监控和分析？\"><a href=\"#如何对-bundle-体积进行监控和分析？\" class=\"headerlink\" title=\"如何对 bundle 体积进行监控和分析？\"></a>如何对 bundle 体积进行监控和分析？</h2><ul>\n<li>VSCode 中有一个插件 <code>Import Cost</code> 可以帮助我们对引入模块的大小进行实时监测，</li>\n<li>还可以使用 <code>webpack-bundle-analyzer</code> 生成 bundle 的模块组成图，显示所占体积。</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://juejin.cn/post/6844904094281236487\" target=\"_blank\" >吐血整理」再来一打 Webpack 面试题</a></p>\n<p><a href=\"https://juejin.cn/post/7073869980411887652\" target=\"_blank\" >最近两周出去面试遇到的面试题（前端初级、长更）</a></p>\n","text":"webpack 与 grunt、gulp 的不同？ Grunt、Gulp 是基于任务运⾏的⼯具： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插 件，能⽅便的打造各种⼯作流。 Webpack 是基于模块化打包的⼯具: ⾃动...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack-%E4%B8%8E-grunt%E3%80%81gulp-%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">webpack 与 grunt、gulp 的不同？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack%E3%80%81rollup%E3%80%81parcel%E3%80%81vite-%E4%BC%98%E5%8A%A3%EF%BC%9F\"><span class=\"toc-text\">webpack、rollup、parcel、vite 优劣？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84-Loader%EF%BC%9F\"><span class=\"toc-text\">有哪些常⻅的 Loader？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#source-map-loader-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84\"><span class=\"toc-text\">source-map-loader 是做什么的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%B0%83%E8%AF%95%EF%BC%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%98%AF-main-js-map-%E8%BF%98%E6%98%AF-main-js%EF%BC%9F\"><span class=\"toc-text\">浏览器中调试，加载的是 main.js.map 还是 main.js？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%B8%8D%E6%98%AF%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%98%AF-Source-Map-%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">是不是这个时候浏览器执行的是 Source Map 代码？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%82%A3%E5%B2%82%E4%B8%8D%E6%98%AF%E6%AD%A4%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%9C%89%E4%B8%A4%E5%A5%97%E4%BB%A3%E7%A0%81%E5%9C%A8%E8%BF%90%E8%A1%8C%EF%BC%9F%E4%B8%80%E5%A5%97%E6%98%AF%E7%BA%AF%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%8C%E4%B8%80%E5%A5%97%E6%98%AF%E7%BA%AF%E8%B0%83%E8%AF%95%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">那岂不是此时浏览器中有两套代码在运行？一套是纯执行的，一套是纯调试的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95%E6%97%B6%E5%80%99%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E8%B0%83%E8%AF%95%E7%9A%84%E6%98%AF-Source-Map%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8E%8B%E7%BC%A9%E5%90%88%E5%B9%B6%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">调试时候如何区分调试的是 Source Map，而不是压缩合并后的代码？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#awesome-typescript-loader%EF%BC%9A%E5%B0%86-TypeScript-%E8%BD%AC%E6%8D%A2%E6%88%90-JavaScript%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E4%BA%8E-ts-loader\"><span class=\"toc-text\">awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84-Plugin%EF%BC%9F\"><span class=\"toc-text\">有哪些常⻅的 Plugin？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D-bundle%EF%BC%8Cchunk%EF%BC%8Cmodule-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">分别介绍 bundle，chunk，module 是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%8B%E7%BC%A9%E6%8F%92%E4%BB%B6%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">压缩插件比较</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HtmlWebpackPlugin\"><span class=\"toc-text\">HtmlWebpackPlugin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#AutomaticPrefetchPlugin-PrefetchPlugin-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">AutomaticPrefetchPlugin PrefetchPlugin 是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CommonsChunkPlugin-MinChunkSizePlugin-SplitChunksPlugin-%E5%90%84%E8%87%AA%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">CommonsChunkPlugin MinChunkSizePlugin SplitChunksPlugin 各自作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DefinePlugin-EnvironmentPlugin\"><span class=\"toc-text\">DefinePlugin EnvironmentPlugin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DllPlugin-%E5%92%8C-DllReferencePlugin\"><span class=\"toc-text\">DllPlugin 和 DllReferencePlugin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%84%E7%BC%96%E8%AF%91-echarts-%E5%92%8C-lodash-%EF%BC%88%E5%8D%95%E4%B8%AA%E5%85%A5%E5%8F%A3%EF%BC%89\"><span class=\"toc-text\">预编译 echarts 和 lodash （单个入口）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%84%E7%BC%96%E8%AF%91-echarts-%E5%92%8C-lodash%EF%BC%88%E5%A4%9A%E5%85%A5%E5%8F%A3%EF%BC%89\"><span class=\"toc-text\">预编译 echarts 和 lodash（多入口）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashedModuleIdsPlugin\"><span class=\"toc-text\">HashedModuleIdsPlugin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashedModuleIdsPlugin-%E5%92%8C-Etag\"><span class=\"toc-text\">HashedModuleIdsPlugin 和 Etag</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Loader-%E5%92%8C-Plugin-%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">Loader 和 Plugin 的不同？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">webpack 的构建流程是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0%E4%B8%8B%E7%BC%96%E5%86%99-loader-%E7%9A%84%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">描述下编写 loader 的思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0%E4%B8%8B%E7%BC%96%E5%86%99-plugin-%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F\"><span class=\"toc-text\">描述下编写 plugin 的思路？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack-compilation-%E6%9C%89%E5%93%AA%E4%BA%9B-api%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">webpack compilation 有哪些 api，各有什么用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">webpack 的热更新原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%BD%A4-webpack-%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">⽤ webpack 来优化前端性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%90%E2%BE%BC-webpack-%E7%9A%84%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">提⾼ webpack 的打包速度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%90%E2%BE%BC-webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">提⾼ webpack 的构建速度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%8D%95%E2%BB%9A%E5%BA%94%E2%BD%A4%EF%BC%9F%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%A4%9A%E2%BB%9A%E5%BA%94%E2%BD%A4%EF%BC%9F\"><span class=\"toc-text\">怎么配置单⻚应⽤？怎么配置多⻚应⽤？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#source-map-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">source map 是什么？生产环境怎么用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#chatgpt\"><span class=\"toc-text\">chatgpt</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">模块打包原理知道吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">文件指纹是什么？怎么用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">JS 的文件指纹设置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CSS-%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">CSS 的文件指纹设置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">图片的文件指纹设置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AF%B9-bundle-%E4%BD%93%E7%A7%AF%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%E5%92%8C%E5%88%86%E6%9E%90%EF%BC%9F\"><span class=\"toc-text\">如何对 bundle 体积进行监控和分析？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-安全","uid":"63e60c5ff1f2bb6bee35b8ec5818fb3b","slug":"2022-07-15安全","date":"2022-07-15T06:32:30.000Z","updated":"2023-02-28T15:57:25.663Z","comments":true,"path":"api/articles/2022-07-15安全.json","keywords":null,"cover":null,"text":"前端安全问题? 跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS. 早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚ ⾯, 其...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-数组","uid":"12cc7106661c51633c97f9b1ac94a946","slug":"2022-07-14js-arr","date":"2022-07-14T07:40:32.000Z","updated":"2022-09-16T13:54:56.212Z","comments":true,"path":"api/articles/2022-07-14js-arr.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202208022304934.png","text":"思维导图 创建 取值 查找 扁平化 遍历 返回 boolean 返回字符串 增&#x2F;删&#x2F;改&#x2F;拷贝&#x2F;解构 详细内容 查看数组 proto[1, 2, 3]; &#x2F;&#x2F; 将结果展开后，见下图 哎呦 [].__proto__Objec...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}