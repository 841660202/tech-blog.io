{"title":"前端基础- 数组对象方法实现原理","uid":"57a999928e12a5391c5331208745c7af","slug":"2022-06-10js-arr","date":"2022-06-10T07:06:40.000Z","updated":"2022-09-16T13:54:56.138Z","comments":true,"path":"api/articles/2022-06-10js-arr.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fres.cloudinary.com%2Fcitiar%2Fimage%2Fupload%2Fv1611373461%2Fucamc%2Fcommon%2Fthumb_5x_Javascript-O.png&refer=http%3A%2F%2Fres.cloudinary.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1657437058&t=2169b1ec59622a8e20039841292e4d8b","content":"<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p><strong>定义</strong></p>\n<ul>\n<li>map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值</li>\n<li>map()方法按照原始数组元素顺序一次处理元素</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>map()不会对空数组进行检测</li>\n<li>map()方法返回的是一个新数组，而不是原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.proptotype.myMap &#x3D; function (fn) &#123;\n  let arr &#x3D; [];\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    arr.push(fn(this[i], i, this));\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myMap((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item * 2;\n&#125;);\n\n&#x2F;&#x2F; 1 0  [1, 2, 3]\n&#x2F;&#x2F; 2 1  [1, 2, 3]\n&#x2F;&#x2F; 3 2  [1, 2, 3]\n&#x2F;&#x2F; [2, 4, 6]</code></pre>\n\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><p><strong>定义</strong></p>\n<ul>\n<li>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>filter()方法不会对空数组进行遍历</li>\n<li>filter()方法不会改变原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myFilter &#x3D; function (fn) &#123;\n  let arr &#x3D; [];\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (fn(this[i], i, this)) &#123;\n      arr.push(this[i]);\n    &#125;\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myFilter((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);\n&#x2F;&#x2F; 1 0  [1, 2, 3]\n&#x2F;&#x2F; 2 1  [1, 2, 3]\n&#x2F;&#x2F; 3 2  [1, 2, 3]\n&#x2F;&#x2F; [2, 3]</code></pre>\n\n<h2 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h2><p><strong>定义</strong></p>\n<ul>\n<li>some()方法用于检测数组中的元素是否满足指定条件</li>\n<li>some()方法会一次执行数组的每个元素，直到找到符合条件的元素为止<ul>\n<li>如果找到符合条件的元素，some()方法就会立即返回 true，剩余的元素不会再执行</li>\n<li>如果没有找到符合条件的元素，some()方法就会返回 false</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>some()方法不会对空数组进行遍历</li>\n<li>some()方法不会改变原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<ul>\n<li>some 我们知道是如果找到就返回 true，没有返回 false,那么在 filter 上再改造一下，定义一个遍历为 false,当有一次会回调函数执行的时候返回 true,那么就跳出循环，直接返回。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.mySome &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (fn(this[i], i, this)) &#123;\n      return true;\n    &#125;\n  &#125;\n  return false;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].mySome((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);</code></pre>\n\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p><strong>定义</strong></p>\n<ul>\n<li>find()方法返回数组中满足条件的第一个元素</li>\n<li>find()方法会一次执行数组的每个元素，直到找到符合条件的元素为止<ul>\n<li>如果找到符合条件的元素，find()方法就会立即返回该元素，剩余的元素不会再执行</li>\n<li>如果没有找到符合条件的元素，find()方法就会返回 undefined</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>find()方法不会对空数组进行遍历</li>\n<li>find()方法不会改变原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<ul>\n<li>当回调函数有一个返回 ture，则赋值并且返回，否则会返回一个未定义的值，undefined。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myFind &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (fn(this[i], i, this)) &#123;\n      return this[i];\n    &#125;\n  &#125;\n  return undefined;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myFind((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);</code></pre>\n\n<h2 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h2><p><strong>定义</strong></p>\n<ul>\n<li>every()方法用于检测数组中的所有元素是否都满足指定条件</li>\n<li>every()方法会一次执行数组的每个元素，直到找到不符合条件的元素为止<ul>\n<li>如果找到不符合条件的元素，every()方法就会返回 false，剩余的元素不会再执行</li>\n<li>如果没有找到不符合条件的元素，every()方法就会返回 true</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>every()方法不会对空数组进行遍历</li>\n<li>every()方法不会改变原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<ul>\n<li>这个跟 some 其实只是反着来，初始化一个值为 true，只要回调函数有一个值返回 false，那么就会成立从而推出循环并且返回。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myEvery &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (!fn(this[i], i, this)) &#123;\n      return false;\n    &#125;\n  &#125;\n  return true;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myEvery((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);</code></pre>\n\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><p><strong>定义</strong></p>\n<ul>\n<li>forEach()方法用于遍历数组中的所有元素</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>forEach()方法不会对空数组执行回调函数</li>\n</ul>\n<p><strong>原理</strong></p>\n<ul>\n<li>也是利用 for 循环直接遍历循环执行回调函数即可。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myForEach &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    fn(this[i], i, this);\n  &#125;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myForEach((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n&#125;);</code></pre>\n\n<h2 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h2><p><strong>定义</strong></p>\n<ul>\n<li>concat()方法用于连接两个或多个数组</li>\n<li>concat()方法不会改变原始数组</li>\n</ul>\n<p><strong>注意</strong></p>\n<p><strong>原理</strong></p>\n<ul>\n<li>先判断是不是数组，是的话遍历 push，不是的话直接 push，最后返回复制的数组即可。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myConcat &#x3D; function (...args) &#123;\n  let arr &#x3D; [...this];\n  for (let i &#x3D; 0; i &lt; args.length; i++) &#123;\n    if (Array.isArray(args[i])) &#123;\n      arr &#x3D; arr.concat(args[i]);\n    &#125; else &#123;\n      arr.push(args[i]);\n    &#125;\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myConcat([4, 5, 6]);</code></pre>\n\n<h2 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin\"></a>copyWithin</h2><p><strong>定义</strong></p>\n<ul>\n<li>copyWithin()方法用于将一个数组的元素复制到其他位置</li>\n<li>copyWithin()方法会修改原始数组</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>copyWithin()方法会改变原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<ul>\n<li>start、 end 元素拷贝到 target 元素（end - start 有几位，会改变 target 及之后的几位）</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myCopyWithin &#x3D; function (target, start &#x3D; 0, end &#x3D; this.length) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  target &#x3D; target &lt; 0 ? len + target : target;\n  start &#x3D; start &lt; 0 ? len + start : start;\n  end &#x3D; end &lt; 0 ? len + end : end;\n  for (let i &#x3D; start; i &lt; end; i++) &#123;\n    arr[target + i - start] &#x3D; arr[i];\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3, 4, 5].myCopyWithin(0, 3);\n&#x2F;&#x2F; 拷贝 4, 5，从0开始覆盖\n&#x2F;&#x2F; [4, 5, 3, 4, 5]</code></pre>\n\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><p><strong>定义</strong></p>\n<ul>\n<li>reduce()方法用于从一个数组中的元素求和</li>\n<li>reduce()可以作为一个高阶函数使用，用于函数的 compose</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>reduce()方法不会对空数组执行回调函数</li>\n</ul>\n<p><strong>原理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myReduce &#x3D; function (fn, init) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  let i &#x3D; 0;\n  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;\n    init &#x3D; arr[0];\n    i &#x3D; 1;\n  &#125;\n  for (; i &lt; len; i++) &#123;\n    init &#x3D; fn(init, arr[i], i, arr);\n  &#125;\n  return init;\n&#125;;</code></pre>\n\n<p>使用</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myReduce((prev, curr) &#x3D;&gt; &#123;\n  return prev + curr;\n&#125;, 0);</code></pre>\n\n<h2 id=\"reduceRight\"><a href=\"#reduceRight\" class=\"headerlink\" title=\"reduceRight\"></a>reduceRight</h2><p><strong>定义</strong></p>\n<ul>\n<li>reduceRight()方法用于从一个数组中的元素求和</li>\n<li>reduceRight()可以作为一个高阶函数使用，用于函数的 compose<br><strong>注意</strong></li>\n<li>reduceRight()方法不会对空数组执行回调函数<br><strong>原理</strong></li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myReduceRight &#x3D; function (fn, init) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  let i &#x3D; len - 1;\n  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;\n    init &#x3D; arr[len - 1];\n    i &#x3D; len - 2;\n  &#125;\n  for (; i &gt;&#x3D; 0; i--) &#123;\n    init &#x3D; fn(init, arr[i], i, arr);\n  &#125;\n  return init;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3].myReduceRight((prev, curr) &#x3D;&gt; &#123;\n  return prev + curr;\n&#125;, 0);</code></pre>\n\n<h2 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h2><p><strong>定义</strong></p>\n<ul>\n<li>splice()方法用于删除数组中的一段，并用新元素替代原来的元素</li>\n<li>splice()方法会改变原始数组</li>\n<li>splice()方法会返回被删除的元素</li>\n<li>splice()方法会返回被删除的元素，并且返回被删除的元素的数组</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>splice()方法会改变原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.mySplice &#x3D; function (start, deleteCount, ...args) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  &#x2F;&#x2F; 找开始的位置\n  start &#x3D; start &lt; 0 ? len + start : start;\n  &#x2F;&#x2F; 找删除的数量\n  &#x2F;&#x2F; 如果deleteCount，没有值，则从start开始删除，直到数组结束\n  deleteCount &#x3D; deleteCount &#x3D;&#x3D;&#x3D; undefined ? len - start : deleteCount;\n\n  let newArr &#x3D; arr.slice(0, start); &#x2F;&#x2F; 左\n\n  newArr &#x3D; newArr.concat(args); &#x2F;&#x2F; 新\n\n  newArr &#x3D; newArr.concat(arr.slice(start + deleteCount)); &#x2F;&#x2F; 右\n\n  return newArr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3, 4, 5].mySplice(2, 2, 6, 7);</code></pre>\n\n<h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2><p><strong>定义</strong></p>\n<ul>\n<li>slice()方法用于返回一个数组的一段，并且不会改变原始数组</li>\n<li>slice()方法会返回一个新数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.mySlice &#x3D; function (start &#x3D; 0, end &#x3D; this.length) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  &#x2F;&#x2F; 找开始的位置\n  start &#x3D; start &lt; 0 ? len + start : start;\n  &#x2F;&#x2F; 找结束的位置\n  end &#x3D; end &lt; 0 ? len + end : end;\n\n  return arr.slice(start, end);\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; [1, 2, 3, 4, 5];\nvar b &#x3D; a.splice(2, 2, 6, 7);\na;\n&#x2F;&#x2F; [1, 2, 6, 7, 5]\nb;\n&#x2F;&#x2F; [3, 4]</code></pre>\n\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><p><strong>定义</strong></p>\n<ul>\n<li>sort()方法用于对数组进行排序</li>\n<li>sort()方法会改变原始数组</li>\n<li>sort()方法会返回一个新数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.mySort &#x3D; function (fn) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  &#x2F;&#x2F; 冒泡排序\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    for (let j &#x3D; i + 1; j &lt; len; j++) &#123;\n      if (fn(arr[i], arr[j]) &gt; 0) &#123;\n        &#x2F;&#x2F; 使用了解构赋值\n        [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];\n      &#125;\n    &#125;\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3, 4, 5].mySort((a, b) &#x3D;&gt; &#123;\n  return a - b;\n&#125;);</code></pre>\n\n<h2 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h2><p><strong>定义</strong></p>\n<ul>\n<li>reverse()方法用于反转数组</li>\n<li>reverse()方法会改变原始数组</li>\n</ul>\n<p><strong>原理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myReverse &#x3D; function () &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  let i &#x3D; 0;\n  let j &#x3D; len - 1;\n  while (i &lt; j) &#123;\n    &#x2F;&#x2F; 使用了解构赋值\n    [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];\n    i++;\n    j--;\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3, 4, 5].myReverse();</code></pre>\n\n<h2 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes\"></a>includes</h2><p><strong>定义</strong></p>\n<ul>\n<li>includes()方法用于判断数组是否包含某个值</li>\n<li>includes()方法会返回一个布尔值</li>\n<li>includes()方法会返回一个布尔值，如果数组包含某个值，则返回 true，否则返回 false<br><strong>原理</strong></li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myIncludes &#x3D; function (value) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    if (arr[i] &#x3D;&#x3D;&#x3D; value) &#123;\n      return true;\n    &#125;\n  &#125;\n  return false;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3, 4, 5].myIncludes(3);</code></pre>\n\n<h2 id=\"flat\"><a href=\"#flat\" class=\"headerlink\" title=\"flat\"></a>flat</h2><p><strong>定义</strong></p>\n<ul>\n<li>flat()方法用于将一个数组展开为多个数组</li>\n<li>flat()方法会返回一个新数组</li>\n<li>flat()方法会返回一个新数组，如果数组中的元素是数组，则将数组中的元素展开为一个数组<br><strong>原理</strong></li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.myFlat &#x3D; function (depth &#x3D; 1) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n\n  let newArr &#x3D; [];\n\n  if (depth &#x3D;&#x3D; 0) return arr; &#x2F;&#x2F; Copilot 这里写的不对\n\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    if (Array.isArray(arr[i])) &#123;\n      newArr &#x3D; newArr.concat(&#x2F;**&#x2F; arr[i].myFlat(depth - 1) &#x2F;*递归*&#x2F;);\n    &#125; else &#123;\n      newArr.push(arr[i]);\n    &#125;\n  &#125;\n  return newArr;\n&#125;;</code></pre>\n\n<p><strong>使用</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[1, 2, 3, 4, 5].myFlat();</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/lin_fightin/article/details/118885988\" target=\"_blank\" >js 一些数组对象方法原理实现(手撕 map,filter,every,flat 等)</a> <code>当前文章比此链接代码更精简</code></p>\n","text":"map定义 map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值 map()方法按照原始数组元素顺序一次处理元素 注意 map()不会对空数组进行检测 map()方法返回的是一个新数组，而不是原始数组 原理 Array.proptotype.myMap &#...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#filter\"><span class=\"toc-text\">filter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#some\"><span class=\"toc-text\">some</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#find\"><span class=\"toc-text\">find</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#every\"><span class=\"toc-text\">every</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#forEach\"><span class=\"toc-text\">forEach</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#concat\"><span class=\"toc-text\">concat</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#copyWithin\"><span class=\"toc-text\">copyWithin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reduce\"><span class=\"toc-text\">reduce</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reduceRight\"><span class=\"toc-text\">reduceRight</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#splice\"><span class=\"toc-text\">splice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#slice\"><span class=\"toc-text\">slice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sort\"><span class=\"toc-text\">sort</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reverse\"><span class=\"toc-text\">reverse</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#includes\"><span class=\"toc-text\">includes</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flat\"><span class=\"toc-text\">flat</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Vue Pinia","uid":"77d580d0d304de3429cbd4fdc2ebd7c6","slug":"2022-06-10vue-pinia","date":"2022-06-10T09:21:00.000Z","updated":"2022-09-16T13:54:56.140Z","comments":true,"path":"api/articles/2022-06-10vue-pinia.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220610172420.webp","text":"Pinia 特点💡 Intuitive直观的Stores are as familiar as components. API designed to let you write well organized stores.存储和组件是一样的。API设计了让你写好组织的存储。 🔑...","link":"","photos":[],"count_time":{"symbolsCount":"68k","symbolsTime":"1:02"},"categories":[{"name":"vue","slug":"vue","count":13,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":13,"path":"api/tags/vue.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-劫持(函数/数据)","uid":"3cfe5c81c087dc101db23ece3358d249","slug":"2022-06-10js-数据劫持","date":"2022-06-10T07:05:21.000Z","updated":"2022-09-16T13:54:56.139Z","comments":true,"path":"api/articles/2022-06-10js-数据劫持.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fres.cloudinary.com%2Fcitiar%2Fimage%2Fupload%2Fv1611373461%2Fucamc%2Fcommon%2Fthumb_5x_Javascript-O.png&refer=http%3A%2F%2Fres.cloudinary.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1657437058&t=2169b1ec59622a8e20039841292e4d8b","text":"函数劫持函数劫持，在一个函数运行之前就把它劫持下来，添加我们想要的功能。 在函数运行之前，我们可以改变函数的参数，或者改变函数的返回值。 JavaScript 中的函数劫持是一个增强原有函数的技巧，一般我们用来对原有的 JavaScript 全局方法做一些能力的增强。 函数劫持原...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}