{"title":"vue3 vs vue2","uid":"8eccc4e7c50ae11b02bb829241892974","slug":"2023-05-15vuee3","date":"2023-05-15T15:24:09.000Z","updated":"2023-05-15T15:46:08.390Z","comments":true,"path":"api/articles/2023-05-15vuee3.json","keywords":null,"cover":null,"content":"<h2 id=\"vue3-相对于-vue2-有哪些变化\"><a href=\"#vue3-相对于-vue2-有哪些变化\" class=\"headerlink\" title=\"vue3 相对于 vue2 有哪些变化\"></a>vue3 相对于 vue2 有哪些变化</h2><p>Vue 3 相对于 Vue 2 引入了一些重大变化和新功能。以下是 Vue 3 相对于 Vue 2 的一些主要变化：</p>\n<ol>\n<li><p><strong>更好的性能</strong>：Vue 3 经过优化，具有更高的性能表现。它引入了基于 Proxy 的响应式系统，可以更精确地跟踪状态的更改，从而提供更高效的重新渲染和更新。</p>\n</li>\n<li><p><strong>Composition API</strong>：Vue 3 引入了 Composition API，它是一种新的 API 风格，允许开发者根据逻辑功能组织和重用代码。与 Vue 2 的 Options API 相比，Composition API 更灵活、可组合和易于维护。</p>\n</li>\n<li><p><strong>更好的 TypeScript 支持</strong>：Vue 3 对 TypeScript 的支持更加出色。通过类型推断，Vue 3 可以更好地与 TypeScript 集成，并提供更准确的类型定义。</p>\n</li>\n<li><p><strong>Teleport</strong>：Vue 3 引入了 Teleport，这是一种新的组件，可以将组件的内容渲染到 DOM 中的任意位置。Teleport 使得在组件层次结构中的任何地方进行渲染成为可能，这对于实现诸如模态框、弹出菜单等功能非常有用。</p>\n</li>\n<li><p><strong>Fragments</strong>：Vue 3 引入了 Fragments，允许组件返回多个根元素，而不需要将它们包装在单个父元素中。这样可以更灵活地组织组件的结构，使得编写更清晰、简洁的模板变得更容易。</p>\n</li>\n<li><p><strong>更好的 Tree Shaking</strong>：Vue 3 的代码结构经过优化，使得 Tree Shaking（树摇）能够更好地工作，从而减少最终构建文件的大小。</p>\n</li>\n<li><p><strong>更好的递归组件</strong>：Vue 3 对递归组件的支持进行了改进，现在可以使用普通的组件选项来定义递归组件，而不需要使用特殊的<code>name</code>选项。</p>\n</li>\n</ol>\n<p>这些是 Vue 3 相对于 Vue 2 的一些主要变化。虽然这些变化带来了一些新的学习曲线和迁移工作，但也为开发者提供了更强大、高效和灵活的工具和功能。</p>\n<h2 id=\"每个组合式-API-的示例\"><a href=\"#每个组合式-API-的示例\" class=\"headerlink\" title=\"每个组合式 API 的示例\"></a>每个组合式 API 的示例</h2><p>以下是每个组合式 API 的示例：</p>\n<ol>\n<li><strong>setup()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      count: 0,\n    &#125;);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      state.count++;\n    &#125;;\n\n    return &#123; state, increment &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>setup()</code>函数创建了一个响应式数据对象<code>state</code>，并定义了一个<code>increment()</code>函数，用于将<code>count</code>属性的值加 1。最后，<code>setup()</code>函数返回了一个包含<code>state</code>和<code>increment</code>属性的对象，这些属性可以在组件中使用。</p>\n<ol start=\"2\">\n<li><strong>reactive()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      message: &#39;Hello, World!&#39;,\n    &#125;);\n\n    return &#123; state &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>reactive()</code>函数创建了一个响应式数据对象<code>state</code>，该对象包含一个<code>message</code>属性，其初始值为<code>&#39;Hello, World!&#39;</code>。在<code>setup()</code>函数中返回了一个包含<code>state</code>属性的对象，该对象可以在组件中使用。</p>\n<ol start=\"3\">\n<li><strong>ref()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      count.value++;\n    &#125;;\n\n    return &#123; count, increment &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>ref()</code>函数将 0 这个普通值转换成了响应式值，然后定义了一个<code>increment()</code>函数，用于将<code>count</code>的值加 1。最后，<code>setup()</code>函数返回了一个包含<code>count</code>和<code>increment</code>属性的对象，这些属性可以在组件中使用。</p>\n<ol start=\"4\">\n<li><strong>computed()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; ref, computed &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    const doubleCount &#x3D; computed(() &#x3D;&gt; &#123;\n      return count.value * 2;\n    &#125;);\n\n    return &#123; count, doubleCount &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>computed()</code>函数创建了一个计算属性<code>doubleCount</code>，其值是<code>count</code>的值乘以 2。<code>doubleCount</code>会根据<code>count</code>的变化自动更新。</p>\n<ol start=\"5\">\n<li><strong>watch()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; ref, watch &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    watch(count, (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(&#96;count changed from $&#123;oldValue&#125; to $&#123;newValue&#125;&#96;);\n    &#125;);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      count.value++;\n    &#125;;\n\n    return &#123; count, increment &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>watch()</code>函数监视<code>count</code>的变化，并在<code>count</code>的值发生变化时打印日志。</p>\n<ol start=\"6\">\n<li><strong>onMounted() &#x2F; onUpdated() &#x2F; onUnmounted()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; onMounted, onUpdated, onUnmounted &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;Component mounted&#39;);\n    &#125;);\n\n    onUpdated(() &#x3D;&gt; &#123;\n      console.log(&#39;Component updated&#39;);\n    &#125;);\n\n    onUnmounted(() &#x3D;&gt; &#123;\n      console.log(&#39;Component unmounted&#39;);\n    &#125;);\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>onMounted()</code></p>\n<h2 id=\"reactive-与-ref-的区别\"><a href=\"#reactive-与-ref-的区别\" class=\"headerlink\" title=\"reactive 与 ref 的区别\"></a>reactive 与 ref 的区别</h2><p><code>reactive()</code>和<code>ref()</code>是 Vue 3 中用于创建响应式数据的两种不同方式，它们之间有一些区别。</p>\n<ol>\n<li><strong>使用场景</strong>:</li>\n</ol>\n<ul>\n<li><code>ref()</code>通常用于单个值的情况，例如计数器、表单输入等简单场景。</li>\n<li><code>reactive()</code>通常用于对象或复杂数据结构的情况，例如状态管理、组件之间共享的数据等。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>返回值类型</strong>:</li>\n</ol>\n<ul>\n<li><code>ref()</code>返回一个包含<code>value</code>属性的对象，通过修改<code>value</code>属性的值来触发更新。例如：<code>const count = ref(0);</code>，在使用时需要通过<code>count.value</code>来访问和修改值。</li>\n<li><code>reactive()</code>返回一个响应式的代理对象，可以直接访问和修改对象的属性。例如：<code>const state = reactive(&#123; count: 0 &#125;);</code>，可以直接使用<code>state.count</code>来访问和修改值。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>更新触发方式</strong>:</li>\n</ol>\n<ul>\n<li><code>ref()</code>的更新是通过修改<code>value</code>属性的值来触发的，只有修改<code>value</code>的值，才能触发更新。例如：<code>count.value = 10;</code></li>\n<li><code>reactive()</code>的更新是通过修改对象的属性值来触发的。例如：<code>state.count = 10;</code></li>\n</ul>\n<ol start=\"4\">\n<li><strong>引用传递</strong>:</li>\n</ol>\n<ul>\n<li>使用<code>ref()</code>创建的响应式值在不同地方引用时，仍然是同一个引用。这意味着如果将<code>ref()</code>的返回值作为参数传递给其他函数或组件时，传递的是同一个引用。</li>\n<li>使用<code>reactive()</code>创建的响应式对象在不同地方引用时，每个引用都是一个独立的响应式代理对象。这意味着传递给其他函数或组件的是独立的对象。</li>\n</ul>\n<p>总的来说，<code>ref()</code>适用于简单的值类型的响应式数据，而<code>reactive()</code>适用于复杂对象或数据结构的响应式数据。在使用时，可以根据具体情况选择合适的方式来创建响应式数据。</p>\n<h2 id=\"组合式-API-computed-与-watch-的区别\"><a href=\"#组合式-API-computed-与-watch-的区别\" class=\"headerlink\" title=\"组合式 API computed 与 watch 的区别\"></a>组合式 API computed 与 watch 的区别</h2><p><code>computed()</code>和<code>watch()</code>是 Vue 3 中组合式 API 中用于处理数据变化的两种不同方式，它们之间有一些区别。</p>\n<ol>\n<li><strong>用法和语法</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>用于创建计算属性，接受一个计算函数作为参数，并返回一个计算属性对象。计算属性会根据其依赖的响应式数据自动更新。使用时，可以像访问普通属性一样使用计算属性。</li>\n<li><code>watch()</code>用于监视响应式数据的变化，并在数据变化时执行回调函数。它接受两个参数，第一个参数是要监视的数据，第二个参数是回调函数。回调函数会在监视的数据发生变化时被调用。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>用途</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>适用于计算和衍生响应式数据的场景。例如，根据一组响应式数据计算出一个衍生的结果，如根据商品的数量和单价计算总价。</li>\n<li><code>watch()</code>适用于监视数据的变化并执行一些副作用的场景。例如，监听表单输入字段的变化，并在每次变化时发送网络请求。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>触发方式</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>的更新是惰性的，即只有当计算属性的依赖发生变化时，计算属性才会重新计算。在模板中访问计算属性时，会自动触发计算属性的计算过程。</li>\n<li><code>watch()</code>的更新是基于数据的实际变化的。当监视的数据发生变化时，回调函数会立即被调用。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>灵活性</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>在定义时会自动处理依赖关系，并建立起与相关数据的关联。当依赖数据发生变化时，计算属性会自动更新。这种自动管理依赖关系的特性使得计算属性非常方便和易于使用。</li>\n<li><code>watch()</code>在监视数据时，可以手动指定需要监视的数据，也可以通过函数来指定需要监视的多个数据。这种灵活性使得可以在一个回调函数中处理多个相关的数据变化。</li>\n</ul>\n<p>总的来说，<code>computed()</code>适用于计算和衍生响应式数据的场景，而<code>watch()</code>适用于监视数据的变化并执行副作用的场景。在使用时，可以根据具体需求选择合适的方式来处理数据的变化。</p>\n<h2 id=\"组合式-API-computed-与-watch-的区别-1\"><a href=\"#组合式-API-computed-与-watch-的区别-1\" class=\"headerlink\" title=\"组合式 API computed 与 watch 的区别\"></a>组合式 API computed 与 watch 的区别</h2><p><code>computed()</code>和<code>watch()</code>是 Vue 3 中组合式 API 中用于处理数据变化的两种不同方式，它们之间有一些区别。</p>\n<ol>\n<li><strong>用法和语法</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>用于创建计算属性，接受一个计算函数作为参数，并返回一个计算属性对象。计算属性会根据其依赖的响应式数据自动更新。使用时，可以像访问普通属性一样使用计算属性。</li>\n<li><code>watch()</code>用于监视响应式数据的变化，并在数据变化时执行回调函数。它接受两个参数，第一个参数是要监视的数据，第二个参数是回调函数。回调函数会在监视的数据发生变化时被调用。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>用途</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>适用于计算和衍生响应式数据的场景。例如，根据一组响应式数据计算出一个衍生的结果，如根据商品的数量和单价计算总价。</li>\n<li><code>watch()</code>适用于监视数据的变化并执行一些副作用的场景。例如，监听表单输入字段的变化，并在每次变化时发送网络请求。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>触发方式</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>的更新是惰性的，即只有当计算属性的依赖发生变化时，计算属性才会重新计算。在模板中访问计算属性时，会自动触发计算属性的计算过程。</li>\n<li><code>watch()</code>的更新是基于数据的实际变化的。当监视的数据发生变化时，回调函数会立即被调用。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>灵活性</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>在定义时会自动处理依赖关系，并建立起与相关数据的关联。当依赖数据发生变化时，计算属性会自动更新。这种自动管理依赖关系的特性使得计算属性非常方便和易于使用。</li>\n<li><code>watch()</code>在监视数据时，可以手动指定需要监视的数据，也可以通过函数来指定需要监视的多个数据。这种灵活性使得可以在一个回调函数中处理多个相关的数据变化。</li>\n</ul>\n<p>总的来说，<code>computed()</code>适用于计算和衍生响应式数据的场景，而<code>watch()</code>适用于监视数据的变化并执行副作用的场景。在使用时，可以根据具体需求选择合适的方式来处理数据的变化。</p>\n<h2 id=\"vue3-是倾向于函数式变成还是面向对象编程？\"><a href=\"#vue3-是倾向于函数式变成还是面向对象编程？\" class=\"headerlink\" title=\"vue3 是倾向于函数式变成还是面向对象编程？\"></a>vue3 是倾向于函数式变成还是面向对象编程？</h2><p>Vue 3 更倾向于函数式编程而不是面向对象编程。</p>\n<p>Vue 3 引入了组合式 API，其中的核心思想是将组件的逻辑拆分为一组可重用的函数。这种方式更加符合函数式编程的理念，通过函数的组合和抽象来构建复杂的逻辑。</p>\n<p>组合式 API 鼓励开发者将逻辑抽象为纯函数，使得代码更加模块化、可测试和可维护。使用函数可以更好地组织和重用代码，提高代码的可读性和可维护性。</p>\n<p>而面向对象编程通常将逻辑封装在对象中，通过对象之间的交互来实现功能。尽管 Vue 3 仍然支持面向对象编程的方式，可以通过创建类和使用类的实例来编写组件，但推荐的方式是使用组合式 API。</p>\n<p>组合式 API 倡导使用函数来编写逻辑，而不是依赖于类和对象的继承和实例化。这种方式更加简洁、灵活，并且与函数式编程的思想更加契合。</p>\n<p>总的来说，虽然 Vue 3 仍然支持面向对象编程，但更倾向于函数式编程，通过组合式 API 提供了更强大的函数式编程能力，使代码更具可读性、可维护性和可测试性。</p>\n<h2 id=\"Teleport-语法\"><a href=\"#Teleport-语法\" class=\"headerlink\" title=\"Teleport 语法\"></a>Teleport 语法</h2><p>Teleport 是通过 <code>&lt;teleport&gt;</code> 元素和 <code>to</code> 属性来实现的，它的语法如下：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;teleport to&#x3D;&quot;目标选择器&quot;&gt;\n  &lt;!-- 要渲染的内容 --&gt;\n&lt;&#x2F;teleport&gt;</code></pre>\n\n<ul>\n<li><code>&lt;teleport&gt;</code>：用于包裹要渲染的内容的容器元素。它是 Teleport 的根元素。</li>\n<li><code>to</code> 属性：指定要渲染到的目标位置。它可以是选择器字符串，表示要将内容渲染到与选择器匹配的元素内，或者是一个 DOM 元素的引用，表示要将内容渲染到该 DOM 元素内。</li>\n</ul>\n<p>在 <code>&lt;teleport&gt;</code> 元素内部，可以放置要渲染的内容，这可以是任何有效的 HTML 或 Vue 模板代码。</p>\n<p>通过使用 Teleport，你可以在组件树中的任意位置渲染内容。这对于实现全局弹窗、模态框、通知消息等功能非常有用。将内容渲染到 <code>&lt;teleport&gt;</code> 指定的目标位置后，它将脱离组件的父节点，成为目标位置的子节点。</p>\n<p>例如，在上面的示例中，我们使用 <code>&lt;teleport&gt;</code> 将模态框的内容渲染到 <code>&lt;body&gt;</code> 元素中，实现了一个全局的模态框效果。</p>\n<p>需要注意的是，为了确保 Teleport 正常工作，目标位置必须是组件所在的 DOM 树之外的一个位置。这样，Teleport 可以绕过父组件的 CSS 和样式隔离，从而在指定的目标位置渲染内容。</p>\n<p>总的来说，Teleport 提供了一种方便的方式来在组件树之外的位置渲染内容，并能够将其与其他组件进行解耦和灵活组合。</p>\n<h2 id=\"Teleport-示例\"><a href=\"#Teleport-示例\" class=\"headerlink\" title=\"Teleport 示例\"></a>Teleport 示例</h2><p>Teleport 是 Vue 3 中的一个特性，用于在组件树中的任意位置渲染内容。以下是一个 Teleport 的示例：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;showModal &#x3D; true&quot;&gt;Open Modal&lt;&#x2F;button&gt;\n\n    &lt;teleport to&#x3D;&quot;body&quot;&gt;\n      &lt;div v-if&#x3D;&quot;showModal&quot; class&#x3D;&quot;modal&quot;&gt;\n        &lt;h2&gt;Modal Content&lt;&#x2F;h2&gt;\n        &lt;p&gt;This modal is teleported to the body.&lt;&#x2F;p&gt;\n        &lt;button @click&#x3D;&quot;showModal &#x3D; false&quot;&gt;Close&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;teleport&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const showModal &#x3D; ref(false);\n\n    return &#123;\n      showModal,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.modal &#123;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  padding: 1rem;\n&#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p>在上述示例中，我们有一个按钮，点击该按钮会显示一个模态框。模态框的内容位于 <code>&lt;teleport&gt;</code> 元素内，通过设置 <code>to</code> 属性为 “body”，将模态框渲染到 <code>&lt;body&gt;</code> 元素中。</p>\n<p>使用 <code>&lt;teleport&gt;</code>，我们可以在组件的模板中声明要渲染到的位置，然后将内容放置在 <code>&lt;teleport&gt;</code> 内部。这样，我们可以轻松地将内容渲染到组件树之外的位置，例如在全局样式下方、在特定的容器中等。</p>\n<p>注意，Teleport 在 Vue 3 中取代了 Vue 2 中的 <code>&lt;component&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 的功能。</p>\n<h2 id=\"Fragments-语法及示例\"><a href=\"#Fragments-语法及示例\" class=\"headerlink\" title=\"Fragments 语法及示例\"></a>Fragments 语法及示例</h2><p>Fragments（片段）是一种在 Vue 3 中用于包裹多个子元素的语法结构，它允许你在不引入额外 DOM 元素的情况下组织和渲染多个子元素。Fragments 可以通过两种方式来使用：<code>&lt;template&gt;</code> 标签和特殊的短语法。</p>\n<ol>\n<li><strong>使用 <code>&lt;template&gt;</code> 标签</strong>：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;!-- Fragments 使用 &lt;template&gt; 标签包裹多个子元素 --&gt;\n  &lt;template&gt;\n    &lt;h1&gt;Header&lt;&#x2F;h1&gt;\n    &lt;p&gt;Paragraph&lt;&#x2F;p&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;template&gt;</code></pre>\n\n<p>在上述示例中，我们使用了一个外层的 <code>&lt;template&gt;</code> 标签来包裹多个子元素。这个外层的 <code>&lt;template&gt;</code> 标签本身不会在最终的渲染结果中产生任何额外的 DOM 元素，它只是用来作为一个容器，方便地组织和包裹多个子元素。</p>\n<ol start=\"2\">\n<li><strong>使用特殊的短语法</strong>：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;!-- Fragments 使用特殊的短语法 --&gt;\n  &lt;&gt;\n    &lt;h1&gt;Header&lt;&#x2F;h1&gt;\n    &lt;p&gt;Paragraph&lt;&#x2F;p&gt;\n  &lt;&#x2F;&gt;\n&lt;&#x2F;template&gt;</code></pre>\n\n<p>在上述示例中，我们使用了特殊的短语法 <code>&lt;&gt;</code> 和 <code>&lt;/&gt;</code> 来表示一个 Fragment，即片段。它的作用与使用 <code>&lt;template&gt;</code> 标签相同，可以包裹多个子元素，并且在最终的渲染结果中不会生成额外的 DOM 元素。</p>\n<p>使用 Fragments 可以解决在 Vue 2 中遇到的组件模板中只能有一个根元素的限制。现在，你可以使用 <code>&lt;template&gt;</code> 标签或特殊的短语法来方便地组织和渲染多个子元素，而无需引入多余的 DOM 元素。</p>\n<p>需要注意的是，Fragments 只是在编写模板时的一种语法结构，它不会被渲染成实际的 DOM 元素。它的主要作用是帮助你更好地组织和布局模板中的多个子元素。</p>\n<p>总的来说，Fragments 提供了一种在 Vue 3 中组织和渲染多个子元素的方式，可以通过 <code>&lt;template&gt;</code> 标签或特殊的短语法来使用，避免了只能有一个根元素的限制。</p>\n","text":"vue3 相对于 vue2 有哪些变化Vue 3 相对于 Vue 2 引入了一些重大变化和新功能。以下是 Vue 3 相对于 Vue 2 的一些主要变化： 更好的性能：Vue 3 经过优化，具有更高的性能表现。它引入了基于 Proxy 的响应式系统，可以更精确地跟踪状态的更改，从...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"vue","slug":"vue","count":14,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":14,"path":"api/tags/vue.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue3-%E7%9B%B8%E5%AF%B9%E4%BA%8E-vue2-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">vue3 相对于 vue2 有哪些变化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E7%BB%84%E5%90%88%E5%BC%8F-API-%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">每个组合式 API 的示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reactive-%E4%B8%8E-ref-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">reactive 与 ref 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E5%BC%8F-API-computed-%E4%B8%8E-watch-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">组合式 API computed 与 watch 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E5%BC%8F-API-computed-%E4%B8%8E-watch-%E7%9A%84%E5%8C%BA%E5%88%AB-1\"><span class=\"toc-text\">组合式 API computed 与 watch 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue3-%E6%98%AF%E5%80%BE%E5%90%91%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E5%8F%98%E6%88%90%E8%BF%98%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">vue3 是倾向于函数式变成还是面向对象编程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Teleport-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">Teleport 语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Teleport-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Teleport 示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fragments-%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Fragments 语法及示例</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"link","uid":"317fa629ebf2e28e8e30a2ac41c06f40","slug":"link","date":"2024-01-07T08:19:19.000Z","updated":"2023-03-13T13:39:28.236Z","comments":true,"path":"api/articles/link.json","keywords":null,"cover":[],"text":"认知 横向对比 纵向学习 &#x2F;#&#x2F;post&#x2F;2023-02-23 思考 第三方链接 2023 面试真题之框架篇 2023 前端面试真题之 JS 篇 2023 面试真题之 CSS 篇 2023 面试真题之浏览器篇 2023 面试真题之手写&amp;代码运...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"前端","slug":"前端","count":5,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":5,"path":"api/tags/前端.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"knife4j","uid":"acc57bd22d883480671c69c000337b31","slug":"2023-05-15knife4j","date":"2023-05-15T10:38:24.000Z","updated":"2023-05-15T13:17:33.012Z","comments":true,"path":"api/articles/2023-05-15knife4j.json","keywords":null,"cover":[],"text":"上图 😓，人才啊！ ","link":"","photos":[],"count_time":{"symbolsCount":14,"symbolsTime":"1 mins."},"categories":[{"name":"思考","slug":"思考","count":1,"path":"api/categories/思考.json"}],"tags":[{"name":"思考","slug":"思考","count":1,"path":"api/tags/思考.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}