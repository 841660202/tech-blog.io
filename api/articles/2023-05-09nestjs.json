{"title":"NestJS","uid":"87f7fda2bbc28a023cd312e8d321db40","slug":"2023-05-09nestjs","date":"2023-05-09T10:25:51.000Z","updated":"2023-05-15T13:17:33.007Z","comments":true,"path":"api/articles/2023-05-09nestjs.json","keywords":null,"cover":null,"content":"<h1 id=\"开箱即用\"><a href=\"#开箱即用\" class=\"headerlink\" title=\"开箱即用\"></a>开箱即用</h1><ol>\n<li>开箱即用的应用框架就是一个已经预设好基本功能和样式的框架，可以帮助开发者快速地开发应用程序，不需要从零开始构建基础功能和样式。</li>\n<li>通常，这类框架提供了一些预设的组件、工具、库、样式和模板等，也提供了文档、示例和编码规范等辅助开发的资源。</li>\n<li>开箱即用的应用框架可以大大缩短应用程序的开发周期，降低开发成本，提高开发效率。</li>\n</ol>\n<h2 id=\"对比-Koa、Egg-和-NestJS\"><a href=\"#对比-Koa、Egg-和-NestJS\" class=\"headerlink\" title=\"对比 Koa、Egg 和 NestJS\"></a>对比 Koa、Egg 和 NestJS</h2><p>Koa、Egg 和 NestJS 都是 Node.js 后端框架，它们之间的区别主要在以下几个方面：</p>\n<ol>\n<li><p>设计哲学：</p>\n<ol>\n<li>Koa 的设计哲学是尽可能少地对开发者进行限制，给予更多的自由；</li>\n<li>Egg 则是在 Koa 的基础上提供了更多的企业级功能，如插件、中间件、约定等；</li>\n<li>NestJS 则是在传统的后端框架的基础上引入了类似于 Angular 的设计思想，提供了依赖注入、模块化、中间件等功能。</li>\n</ol>\n</li>\n<li><p>开发难度：</p>\n<ol>\n<li>Koa 的学习曲线比较陡峭，需要开发者具备一定的 Node.js 基础；</li>\n<li>Egg 的学习曲线相对较平缓，提供了一些快速开发的工具和约定；</li>\n<li>NestJS 的学习曲线较为平缓，但需要开发者熟悉 Typescript。</li>\n</ol>\n</li>\n<li><p>性能：</p>\n<ol>\n<li>Koa 是最轻量级的框架，性能比 Egg 和 NestJS 更高；</li>\n<li>Egg 的性能较 Koa 稍微低一些，但仍然足以应对大部分应用场景；</li>\n<li>NestJS 的性能较 Egg 低一些，但其提供的功能较为全面。</li>\n</ol>\n</li>\n<li><p>生态系统：</p>\n<ol>\n<li>Koa 的生态系统相对较小，但是其灵活性比较高，可以方便地集成其他库和工具；</li>\n<li>Egg 的生态系统相对较为完善，有大量的插件和中间件可供使用；</li>\n<li>NestJS 的生态系统相对较新，但是也在不断地发展壮大。</li>\n</ol>\n</li>\n</ol>\n<p>综合来看，选择哪个框架主要取决于具体的应用场景和个人偏好。如果是需要快速搭建企业级应用的话，可以考虑使用 Egg；如果是需要灵活性和自由度更高的项目，可以选择 Koa；如果是想要尝试一种新的设计思想，并且愿意接受一定的性能损失，可以尝试 NestJS。</p>\n<h2 id=\"NestJS-重要概念区分\"><a href=\"#NestJS-重要概念区分\" class=\"headerlink\" title=\"NestJS 重要概念区分\"></a>NestJS 重要概念区分</h2><p><strong>区分部件及使用场景</strong></p>\n<p>在 NestJS 中，守卫在所有中间件之后执行，但在任何拦截器或管道之前执行，这是因为守卫的主要目的是在请求到达控制器之前对请求进行验证、授权或其他操作。</p>\n<p><code>中间件</code>是在请求到达控制器之前执行的代码，它们通常用于处理请求的前置操作，例如<strong>身份验证、日志记录</strong>等。中间件的执行顺序是按照它们在应用程序中的注册顺序依次执行的。</p>\n<p><code>拦截器和管道</code>是用于处理控制器中的方法执行前后的操作。拦截器可以在方法执行前后进行一些额外的处理，例如<strong>日志记录、异常处理</strong>等。</p>\n<p><code>管道</code>可以<strong>用于对请求进行转换、验证或其他处理</strong>。</p>\n<p><code>守卫</code>的目的是<strong>在控制器之前对请求进行验证或授权</strong>，因此它们需要在中间件执行之后但在拦截器和管道执行之前执行。这样可以确保在进入控制器之前对请求进行了适当的验证和授权操作，以便控制器中的方法能够处理有效和合法的请求。</p>\n<h2 id=\"Nestjs-与-Spring-Boot\"><a href=\"#Nestjs-与-Spring-Boot\" class=\"headerlink\" title=\"Nestjs 与 Spring Boot\"></a>Nestjs 与 Spring Boot</h2><p>NestJS 和 Spring Boot 都是为了帮助开发者更方便地构建 Web 应用程序的框架，它们有很多相似的地方，比如都提供了基于注解的依赖注入、MVC 架构、ORM 等功能。</p>\n<p>以下是它们的一些区别：</p>\n<ol>\n<li><p>编程语言：NestJS 是基于 TypeScript 的，而 Spring Boot 是基于 Java 的。这意味着使用 NestJS 可以利用 TypeScript 的一些特性，如静态类型检查和装饰器语法糖，而 Spring Boot 则可以利用 Java 的成熟生态系统和广泛的库。</p>\n</li>\n<li><p>构建工具：NestJS 使用的是基于 Node.js 的构建工具，如 npm 和 yarn，而 Spring Boot 使用的是 Maven 或 Gradle。这意味着在构建和依赖管理方面有一些不同。</p>\n</li>\n<li><p>性能：由于 Java 语言和 JVM 的成熟性和优化，Spring Boot 在性能方面可能会略优于 NestJS。但是，这取决于应用程序的特定需求和实现。</p>\n</li>\n<li><p>社区：Spring Boot 拥有一个庞大的社区，这意味着有很多资源、教程和插件可供使用，而 NestJS 的社区相对较小，但正在不断增长。</p>\n</li>\n</ol>\n<p>总的来说，NestJS 和 Spring Boot 都是优秀的框架，可以根据个人喜好和应用程序的需求来选择使用。如果你喜欢 TypeScript 或者想要使用 Node.js，那么 NestJS 是个不错的选择；如果你熟悉 Java 或者已经有一个庞大的 Java 应用程序生态系统，那么 Spring Boot 可能更适合你。</p>\n<h1 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h1><h2 id=\"nextjs-依赖注入-Injectable-是什么意思\"><a href=\"#nextjs-依赖注入-Injectable-是什么意思\" class=\"headerlink\" title=\"nextjs 依赖注入 Injectable 是什么意思\"></a>nextjs 依赖注入 Injectable 是什么意思</h2><p><code>Injectable</code> 是 NestJS 中的一个装饰器，用于标记一个类可以被注入到其他类中。这个类通常会包含一些可重用的逻辑，例如与数据库的交互、第三方服务的调用等等。</p>\n<p>使用 <code>@Injectable()</code> 装饰器后，这个类可以通过构造函数参数或属性注入到其他类中，从而达到依赖注入的效果。例如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@Injectable()\nexport class UserService &#123;\n  constructor(private readonly userRepository: UserRepository) &#123;&#125;\n\n  async findAll(): Promise&lt;User[]&gt; &#123;\n    return this.userRepository.findAll();\n  &#125;\n&#125;</code></pre>\n\n<p>在上面的例子中，<code>UserService</code> 类被标记为可注入的，并且通过构造函数注入了 <code>UserRepository</code> 类。这样，当我们需要在其他地方使用 <code>UserService</code> 时，只需要将它注入到对应的类中即可，而不需要手动创建 <code>UserRepository</code> 实例。</p>\n<p>NestJS 的依赖注入机制是基于 TypeScript 装饰器和反射机制实现的。它可以让我们以更加简洁和优雅的方式来管理应用程序中的依赖关系。</p>\n<h2 id=\"依赖注入设计模式\"><a href=\"#依赖注入设计模式\" class=\"headerlink\" title=\"依赖注入设计模式\"></a>依赖注入设计模式</h2><p>依赖注入（Dependency Injection，简称 DI）是一种软件设计模式，它的主要目的是将对象之间的依赖关系的创建与运行时耦合解耦。通俗地说，就是在程序运行的时候，动态地将对象所需要的其他对象的引用注入到它内部，而不是由对象自己去创建这些依赖关系。这种方式可以降低对象之间的耦合度，从而提高代码的灵活性、可扩展性和可维护性。依赖注入通常是通过构造函数参数、属性或者工厂方法实现的。</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>依赖注入是一种设计模式，它通过将对象之间的依赖关系从硬编码到代码之外的配置文件或者工厂类中，来降低应用程序的耦合度，从而实现了可重用性、灵活性和可维护性。</p>\n<p><strong>通常，依赖注入的过程分为三个步骤：</strong></p>\n<ol>\n<li><p><code>定义依赖</code>：在类中声明需要依赖的对象，通常是通过构造函数、Setter 方法或接口等方式进行声明。</p>\n</li>\n<li><p><code>注入依赖</code>：在应用程序中创建依赖对象，并将它们注入到类中，通常是通过工厂类或配置文件进行注入。</p>\n</li>\n<li><p><code>使用依赖</code>：在类中使用依赖对象，执行业务逻辑。</p>\n</li>\n</ol>\n<p><strong>依赖注入的优点包括：</strong></p>\n<ol>\n<li><p><code>可测试性</code>：通过将依赖关系从代码中抽离出来，可以轻松地将测试替身传递给类，从而实现更好的单元测试和集成测试。</p>\n</li>\n<li><p><code>可重用性</code>：通过将依赖关系从代码中解耦出来，可以更容易地将类组合在一起创建新的对象，从而实现更高的可重用性。</p>\n</li>\n<li><p><code>松耦合</code>：通过依赖注入，对象只依赖于接口而不是具体实现，从而减少了类之间的耦合，使应用程序更加灵活和可维护。</p>\n</li>\n<li><p><code>可扩展性</code>：通过将依赖关系从代码中解耦出来，可以更容易地添加或删除功能，从而实现更高的可扩展性。</p>\n</li>\n</ol>\n\n</details>\n<h2 id=\"注入和实例化看上去没区别？\"><a href=\"#注入和实例化看上去没区别？\" class=\"headerlink\" title=\"注入和实例化看上去没区别？\"></a>注入和实例化看上去没区别？</h2><p>在依赖注入模式中，注入和实例化是不同的概念。<br>注入是指将一个对象传递给另一个对象的过程，而实例化是指创建一个对象的过程。</p>\n<p>在依赖注入中，对象通常是在其依赖项中被注入的，而不是直接实例化它们。这种方法使得应用程序更加松散耦合，因为依赖关系是在运行时确定的，而不是在编译时确定的。</p>\n<h2 id=\"Module-的-imports-和-providers-有什么区别\"><a href=\"#Module-的-imports-和-providers-有什么区别\" class=\"headerlink\" title=\"@Module 的 imports 和 providers 有什么区别\"></a>@Module 的 imports 和 providers 有什么区别</h2><p><code>@Module</code> 的 <code>imports</code> 和 <code>providers</code> 都是用来定义模块的成员的装饰器。</p>\n<p><code>imports</code> 用于导入依赖模块。在 Nest.js 应用程序中，模块之间的依赖关系是通过导入和导出模块来管理的。如果要使用另一个模块的服务或其他提供者，则必须将其导入到当前模块中。<code>imports</code> 数组中可以包含其他模块、共享模块和全局模块。</p>\n<p><code>providers</code> 用于定义当前模块的提供者。提供者是当前模块中可被注入的任何东西，比如服务、工厂、类等。提供者可以是同步或异步的，它们可以被其他提供者或控制器使用。</p>\n<p>简而言之，<code>imports</code> 用于导入依赖模块，<code>providers</code> 用于定义当前模块的提供者。</p>\n<h2 id=\"不导入，直接提供不行吗？\"><a href=\"#不导入，直接提供不行吗？\" class=\"headerlink\" title=\"不导入，直接提供不行吗？\"></a>不导入，直接提供不行吗？</h2><p>在 NestJS 中，我们需要使用 <code>@Module</code> 装饰器来声明一个模块，一个模块可以包含多个 <code>imports</code>、<code>providers</code>、<code>controllers</code> 和 <code>exports</code>。其中，<code>imports</code> 属性用于导入其它模块，<code>providers</code> 属性用于提供可注入的服务。</p>\n<p>如果一个模块没有导入其它模块，而直接提供服务，那么这些服务仍然可以正常使用，但是如果这些服务需要依赖其它服务或模块，就需要将这些依赖项以 <code>providers</code> 的形式进行提供，否则依赖注入时会出现问题。</p>\n<p>因此，虽然在不导入其它模块的情况下，直接提供服务是可行的，但是为了确保依赖注入的正确性，建议还是将所有的服务都以 <code>providers</code> 的形式进行提供。</p>\n<h2 id=\"Module-exports\"><a href=\"#Module-exports\" class=\"headerlink\" title=\"@Module exports\"></a>@Module exports</h2><p>在 NestJS 中，<code>@Module</code> 装饰器还提供了 <code>exports</code> 选项，用于导出在当前模块中定义的 <code>providers</code> 和 <code>controllers</code>，以供其他模块使用。</p>\n<p>如果一个模块中的某个服务在其他模块中也需要使用，可以通过在当前模块的 <code>exports</code> 中导出该服务，让其他模块可以引入并使用该服务。这样的话，如果要修改该服务，只需要在当前模块中修改即可，而不用在多个模块中修改。</p>\n<p>举个例子，如果我们有一个 <code>UserService</code>，它在 <code>UserModule</code> 模块中定义，如下所示：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@Module(&#123;\n  providers: [UserService],\n  exports: [UserService],\n&#125;)\nexport class UserModule &#123;&#125;</code></pre>\n\n<p>在另一个模块中，如果要使用 <code>UserService</code>，可以通过 <code>imports</code> 导入 <code>UserModule</code>，然后通过 <code>providers</code> 获取它，如下所示：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@Module(&#123;\n  imports: [UserModule],\n  providers: [SomeService],\n&#125;)\nexport class SomeModule &#123;\n  constructor(private readonly userService: UserService) &#123;&#125;\n&#125;</code></pre>\n\n<p>通过这种方式，我们可以轻松地在不同的模块中共享同一个服务实例，避免重复定义和管理。</p>\n<h2 id=\"不经过这个-UserModule-，直接用-UserService-不行吗\"><a href=\"#不经过这个-UserModule-，直接用-UserService-不行吗\" class=\"headerlink\" title=\"不经过这个 UserModule ，直接用 UserService 不行吗\"></a>不经过这个 UserModule ，直接用 UserService 不行吗</h2><p>如果您在 UserModule 中将 UserService 注册为提供者 (Provider)，那么在其他模块中可以使用 UserService，但是需要导入 UserModule 才能使用。如果不想在其他模块中导入 UserModule，可以将 UserService 导出 (export) 给其他模块使用。</p>\n<p>例如，在 UserModule 中:</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; UserController &#125; from &#39;.&#x2F;user.controller&#39;;\nimport &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\n\n@Module(&#123;\n  controllers: [UserController],\n  providers: [UserService],\n  exports: [UserService], &#x2F;&#x2F; 导出 UserService\n&#125;)\nexport class UserModule &#123;&#125;</code></pre>\n\n<p>在其他模块中，可以直接使用 UserService，而不需要导入 UserModule：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\n\n@Module(&#123;\n  providers: [SomeOtherService],\n&#125;)\nexport class SomeOtherModule &#123;\n  constructor(private readonly userService: UserService) &#123;&#125;\n&#125;</code></pre>\n\n<p>通过将 UserService 导出 (export) 到其他模块，其他模块可以直接使用 UserService 而无需导入 UserModule。</p>\n<h2 id=\"直接导入到其他模块不行吗\"><a href=\"#直接导入到其他模块不行吗\" class=\"headerlink\" title=\"直接导入到其他模块不行吗\"></a>直接导入到其他模块不行吗</h2><p>直接导入到其他模块也是可以的，不一定非要通过 <code>UserModule</code> 来使用 <code>UserService</code>。但是通过模块化的方式，可以更好地管理依赖关系，让代码更加清晰和易于维护。比如，如果 <code>UserService</code> 依赖了其他模块的服务，我们可以在 <code>UserModule</code> 中导入这些模块并将它们注册为 <code>UserModule</code> 的提供者，这样可以方便地管理所有依赖项，并且确保它们的顺序正确。同时，如果我们需要修改 <code>UserService</code> 的行为，我们只需要修改 <code>UserModule</code> 中的 <code>UserService</code> 提供者即可，而不用去修改其他模块中直接使用 <code>UserService</code> 的代码。这种解耦的方式可以让代码更加灵活和可维护。</p>\n<h2 id=\"这么理解-providers-和-controllers-组成了-UserModule-其他-module-如果想用-UserModule-的东西，先要再-UserModule-导出，然后其他模块导入，接着进行使用，是这样吗\"><a href=\"#这么理解-providers-和-controllers-组成了-UserModule-其他-module-如果想用-UserModule-的东西，先要再-UserModule-导出，然后其他模块导入，接着进行使用，是这样吗\" class=\"headerlink\" title=\"这么理解 providers 和 controllers 组成了 UserModule,其他 module 如果想用 UserModule 的东西，先要再 UserModule 导出，然后其他模块导入，接着进行使用，是这样吗\"></a>这么理解 providers 和 controllers 组成了 UserModule,其他 module 如果想用 UserModule 的东西，先要再 UserModule 导出，然后其他模块导入，接着进行使用，是这样吗</h2><p>是的，您可以这样理解。当一个模块中定义了 <code>providers</code> 和 <code>controllers</code> 后，其他模块需要使用这些模块提供的服务时，需要将该模块导入到其他模块中。在导入后，其他模块就可以通过依赖注入的方式使用该模块中提供的服务。在 NestJS 中，导入模块的过程就是使用 <code>imports</code> 属性，而模块中提供的服务通过 <code>providers</code> 属性进行定义。</p>\n<p><strong>简单来说，以前直接 require 或者 import 的方式，现在不用了，用了 nestjs 的依赖注入的方式实现同样的功能，虽然繁琐了写，但是规范了</strong></p>\n<h1 id=\"异常过滤器\"><a href=\"#异常过滤器\" class=\"headerlink\" title=\"异常过滤器\"></a>异常过滤器</h1><h2 id=\"nestjs-异常全局过滤器有几种方式\"><a href=\"#nestjs-异常全局过滤器有几种方式\" class=\"headerlink\" title=\"nestjs 异常全局过滤器有几种方式\"></a>nestjs 异常全局过滤器有几种方式</h2><p>在 NestJS 中，可以使用全局异常过滤器（Global Exception Filters）来捕获应用程序中的所有异常，并对它们进行处理。</p>\n<h3 id=\"NestJS-中有两种方式来创建全局异常过滤器：\"><a href=\"#NestJS-中有两种方式来创建全局异常过滤器：\" class=\"headerlink\" title=\"NestJS 中有两种方式来创建全局异常过滤器：\"></a>NestJS 中有两种方式来创建全局异常过滤器：</h3><ol>\n<li><p>基于类的全局过滤器：创建一个实现了 <code>ExceptionFilter</code> 接口的类，使用 <code>@Catch()</code> 装饰器指定要捕获的异常类型，然后在应用程序启动时使用 <code>app.useGlobalFilters()</code> 方法将其注册为全局异常过滤器。</p>\n</li>\n<li><p>函数式全局过滤器：创建一个函数，接收一个 <code>Exception</code> 参数，并返回一个处理结果，然后使用 <code>app.useGlobalFilters()</code> 方法将其注册为全局异常过滤器。</p>\n</li>\n</ol>\n<p>下面是两种方式的示例代码：</p>\n<h3 id=\"基于类的全局过滤器：\"><a href=\"#基于类的全局过滤器：\" class=\"headerlink\" title=\"基于类的全局过滤器：\"></a>基于类的全局过滤器：</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; ExceptionFilter, Catch, ArgumentsHost &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; Response &#125; from &#39;express&#39;;\n\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter &#123;\n  catch(exception: unknown, host: ArgumentsHost) &#123;\n    const ctx &#x3D; host.switchToHttp();\n    const response &#x3D; ctx.getResponse&lt;Response&gt;();\n\n    response.status(500).json(&#123;\n      statusCode: 500,\n      message: &#39;Internal server error&#39;,\n    &#125;);\n  &#125;\n&#125;</code></pre>\n\n<p>在 <code>main.ts</code> 文件中注册全局过滤器：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; NestFactory &#125; from &#39;@nestjs&#x2F;core&#39;;\nimport &#123; AppModule &#125; from &#39;.&#x2F;app.module&#39;;\nimport &#123; AllExceptionsFilter &#125; from &#39;.&#x2F;common&#x2F;filters&#x2F;all-exceptions.filter&#39;;\n\nasync function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n\n  app.useGlobalFilters(new AllExceptionsFilter());\n\n  await app.listen(3000);\n&#125;\nbootstrap();</code></pre>\n\n<h3 id=\"函数式全局过滤器：\"><a href=\"#函数式全局过滤器：\" class=\"headerlink\" title=\"函数式全局过滤器：\"></a>函数式全局过滤器：</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; ExceptionFilter, Catch, ArgumentsHost &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; Response &#125; from &#39;express&#39;;\n\nexport const allExceptionsFilter: ExceptionFilter &#x3D; (exception, host) &#x3D;&gt; &#123;\n  const ctx &#x3D; host.switchToHttp();\n  const response &#x3D; ctx.getResponse&lt;Response&gt;();\n\n  response.status(500).json(&#123;\n    statusCode: 500,\n    message: &#39;Internal server error&#39;,\n  &#125;);\n&#125;;</code></pre>\n\n<p>在 <code>main.ts</code> 文件中注册全局过滤器：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; NestFactory &#125; from &#39;@nestjs&#x2F;core&#39;;\nimport &#123; AppModule &#125; from &#39;.&#x2F;app.module&#39;;\nimport &#123; allExceptionsFilter &#125; from &#39;.&#x2F;common&#x2F;filters&#x2F;all-exceptions.filter&#39;;\n\nasync function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n\n  app.useGlobalFilters(allExceptionsFilter);\n\n  await app.listen(3000);\n&#125;\nbootstrap();</code></pre>\n\n<p>注意，无论使用哪种方式创建全局异常过滤器，都应该在应用程序启动时进行注册。</p>\n<h2 id=\"“基于类的全局过滤器”-和-“函数式全局过滤器”-有什么区别\"><a href=\"#“基于类的全局过滤器”-和-“函数式全局过滤器”-有什么区别\" class=\"headerlink\" title=\"“基于类的全局过滤器” 和 “函数式全局过滤器” 有什么区别\"></a>“基于类的全局过滤器” 和 “函数式全局过滤器” 有什么区别</h2><p>在 Nest.js 中，异常全局过滤器可以通过基于类和基于函数两种方式来实现。</p>\n<p>基于类的全局过滤器是一个可注入的类，需要实现 <code>ExceptionFilter</code> 接口，其中包含一个 <code>catch(exception: any, host: ArgumentsHost)</code> 方法，用于处理异常。这种方式可以使用依赖注入来获得其他模块的服务和配置信息，并且还可以轻松地继承、重写和重用已有的过滤器。</p>\n<p>函数式全局过滤器则是一个简单的函数，接受两个参数 <code>exception</code> 和 <code>host</code>，同样用于处理异常。这种方式不依赖于依赖注入，更加轻量级，但缺少了继承和重用已有过滤器的功能。</p>\n<p>总体来说，<strong>基于类的全局过滤器更加灵活、可扩展</strong>，而<strong>函数式全局过滤器则更加轻量、简单</strong>。选择哪种方式，可以根据具体的业务场景和性能要求来决定。</p>\n<h2 id=\"在-NestJS-中，可以在不同的层级上绑定异常过滤器，包括全局、模块、控制器和方法级别。\"><a href=\"#在-NestJS-中，可以在不同的层级上绑定异常过滤器，包括全局、模块、控制器和方法级别。\" class=\"headerlink\" title=\"在 NestJS 中，可以在不同的层级上绑定异常过滤器，包括全局、模块、控制器和方法级别。\"></a>在 NestJS 中，可以在不同的层级上绑定异常过滤器，包括全局、模块、控制器和方法级别。</h2><ul>\n<li>全局层级：可以创建全局的异常过滤器来处理整个应用程序的异常，通过在 main.ts 中使用 <code>app.useGlobalFilters()</code> 方法进行绑定。</li>\n<li>模块层级：在一个模块中可以创建专门的异常过滤器来处理该模块中所有控制器抛出的异常，通过在模块注解中使用 <code>@UseFilters()</code> 进行绑定。</li>\n<li>控制器层级：在一个控制器中可以创建专门的异常过滤器来处理该控制器中所有方法抛出的异常，通过在控制器注解中使用 <code>@UseFilters()</code> 进行绑定。</li>\n<li>方法层级：在一个方法中可以创建专门的异常过滤器来处理该方法抛出的异常，通过在方法注解中使用 <code>@UseFilters()</code> 进行绑定。</li>\n</ul>\n<p>以下是几个示例：</p>\n<h3 id=\"全局层级示例\"><a href=\"#全局层级示例\" class=\"headerlink\" title=\"全局层级示例\"></a>全局层级示例</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">async function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n  app.useGlobalFilters(new HttpExceptionFilter());\n  await app.listen(3000);\n&#125;</code></pre>\n\n<h3 id=\"模块层级示例\"><a href=\"#模块层级示例\" class=\"headerlink\" title=\"模块层级示例\"></a>模块层级示例</h3><p>以下是模块层级的示例：</p>\n<p>假设我们有一个叫做<code>AppModule</code>的根模块，其中包含两个模块：<code>UserModule</code>和<code>ProductModule</code>。我们想要为这两个模块分别设置全局的异常过滤器。</p>\n<p>首先，我们需要创建一个基于类的异常过滤器：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; ExceptionFilter, Catch &#125; from &#39;@nestjs&#x2F;common&#39;;\n\n@Catch()\nexport class GlobalExceptionFilter implements ExceptionFilter &#123;\n  catch(exception: any, host: ArgumentsHost) &#123;\n    &#x2F;&#x2F; 处理异常的逻辑\n  &#125;\n&#125;</code></pre>\n\n<p>然后，在<code>UserModule</code>中，我们可以通过<code>@Module</code>装饰器的<code>providers</code>属性来指定该模块的异常过滤器：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; UserController &#125; from &#39;.&#x2F;user.controller&#39;;\nimport &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\nimport &#123; GlobalExceptionFilter &#125; from &#39;.&#x2F;global-exception.filter&#39;;\n\n@Module(&#123;\n  controllers: [UserController],\n  providers: [\n    UserService,\n    &#123;\n      provide: &#39;APP_FILTER&#39;,\n      useClass: GlobalExceptionFilter,\n    &#125;,\n  ],\n&#125;)\nexport class UserModule &#123;&#125;</code></pre>\n\n<p>在上面的代码中，我们将<code>GlobalExceptionFilter</code>类作为一个提供者提供给了<code>UserModule</code>，并且使用<code>provide</code>属性指定了这是一个全局的异常过滤器。</p>\n<p>同样的，我们也可以在<code>ProductModule</code>中设置该模块的异常过滤器：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ProductController &#125; from &#39;.&#x2F;product.controller&#39;;\nimport &#123; ProductService &#125; from &#39;.&#x2F;product.service&#39;;\nimport &#123; GlobalExceptionFilter &#125; from &#39;.&#x2F;global-exception.filter&#39;;\n\n@Module(&#123;\n  controllers: [ProductController],\n  providers: [\n    ProductService,\n    &#123;\n      provide: &#39;APP_FILTER&#39;,\n      useClass: GlobalExceptionFilter,\n    &#125;,\n  ],\n&#125;)\nexport class ProductModule &#123;&#125;</code></pre>\n\n<p>在上面的代码中，我们将<code>GlobalExceptionFilter</code>类作为一个提供者提供给了<code>ProductModule</code>，并且同样使用<code>provide</code>属性指定了这是一个全局的异常过滤器。</p>\n<p>最后，在<code>AppModule</code>中，我们可以通过<code>@UseFilters</code>装饰器来绑定全局的异常过滤器，这样所有模块中没有单独设置过异常过滤器的请求都会被该全局过滤器捕获：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; UserModule &#125; from &#39;.&#x2F;user&#x2F;user.module&#39;;\nimport &#123; ProductModule &#125; from &#39;.&#x2F;product&#x2F;product.module&#39;;\nimport &#123; APP_FILTER &#125; from &#39;@nestjs&#x2F;core&#39;;\nimport &#123; GlobalExceptionFilter &#125; from &#39;.&#x2F;global-exception.filter&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\n\n@Module(&#123;\n  imports: [UserModule, ProductModule],\n  controllers: [AppController],\n  providers: [\n    &#123;\n      provide: APP_FILTER,\n      useClass: GlobalExceptionFilter,\n    &#125;,\n  ],\n&#125;)\nexport class AppModule &#123;&#125;</code></pre>\n\n<p>在上面的代码中，我们通过提供<code>APP_FILTER</code>的方式，将<code>GlobalExceptionFilter</code>类作为全局异常过滤器提供给了<code>AppModule</code>。这样就完成了全局异常过滤器的设置，即使有些模块没有单独设置过异常过滤器，请求也能被捕获并处理。</p>\n<h3 id=\"绑定到一个控制器上：（控制器层级）\"><a href=\"#绑定到一个控制器上：（控制器层级）\" class=\"headerlink\" title=\"绑定到一个控制器上：（控制器层级）\"></a>绑定到一个控制器上：（控制器层级）</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@UseFilters(HttpExceptionFilter)\nexport class CatsController &#123;&#125;</code></pre>\n\n<p>这将绑定一个基于类的过滤器 <code>HttpExceptionFilter</code> 到 <code>CatsController</code> 控制器上。</p>\n<h3 id=\"绑定到一个自定义路由上：（方法层级）\"><a href=\"#绑定到一个自定义路由上：（方法层级）\" class=\"headerlink\" title=\"绑定到一个自定义路由上：（方法层级）\"></a>绑定到一个自定义路由上：（方法层级）</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@Post()\n@UseFilters(HttpExceptionFilter)\ncreate() &#123;\n  &#x2F;&#x2F; create a cat\n&#125;</code></pre>\n\n<p>这将绑定一个基于类的过滤器 <code>HttpExceptionFilter</code> 到 <code>create</code> 路由上。</p>\n<p>这将绑定一个基于类的过滤器 <code>HttpExceptionFilter</code> 到全局，以处理应用程序中所有的异常。</p>\n<h1 id=\"NestJS-中间件\"><a href=\"#NestJS-中间件\" class=\"headerlink\" title=\"NestJS 中间件\"></a>NestJS 中间件</h1><h2 id=\"为什么要使用中间件？\"><a href=\"#为什么要使用中间件？\" class=\"headerlink\" title=\"为什么要使用中间件？\"></a>为什么要使用中间件？</h2><p>中间件是一个常见的设计模式，它可以用于在应用程序的不同层之间进行消息传递、修改请求&#x2F;响应对象、执行身份验证和授权等操作。在 Nestjs 中，中间件是在 HTTP 请求处理流程中执行的一个函数，它可以对请求进行修改、拦截、记录和转发等操作。</p>\n<p>使用中间件可以帮助我们更好地组织和管理应用程序的代码。例如，可以使用中间件来处理日志记录、请求验证、错误处理等常见任务。这样可以将这些任务从控制器或服务中分离出来，使代码更易于理解、测试和维护。</p>\n<p>另外，使用中间件可以让我们轻松地实现一些通用的功能，例如对请求进行身份验证或对响应进行压缩等操作。这样可以使代码更具可重用性和可维护性。</p>\n<h2 id=\"中间件属于-23-种设计模式中的哪种？\"><a href=\"#中间件属于-23-种设计模式中的哪种？\" class=\"headerlink\" title=\"中间件属于 23 种设计模式中的哪种？\"></a>中间件属于 23 种设计模式中的哪种？</h2><p>中间件属于行为设计模式中的一种，具体来说是责任链模式（Chain of Responsibility Pattern）的一种实现方式。</p>\n<h2 id=\"为什么不是过滤器模式呢？\"><a href=\"#为什么不是过滤器模式呢？\" class=\"headerlink\" title=\"为什么不是过滤器模式呢？\"></a>为什么不是过滤器模式呢？</h2><p>中间件和过滤器都属于软件设计模式中的<strong>行为型模式</strong>，但它们的作用有所不同。</p>\n<p>中间件的作用是在请求处理的过程中，对请求进行拦截和处理，并将控制权传递给下一个中间件或处理程序。中间件通常被设计成链式结构，每个中间件都负责一些特定的功能，且这些功能可以被顺序串起来以完成一系列的任务。Nest.js 中间件就是典型的中间件模式的实现。</p>\n<p>而过滤器的作用是对数据进行过滤和处理，通常是在数据被提交或响应之前或之后进行。过滤器可以是输入过滤器、输出过滤器或两者的结合体。过滤器模式主要是针对数据的过滤和处理，相比之下中间件模式更加通用和灵活。</p>\n<p>因此，虽然中间件和过滤器有些相似之处，但它们的本质不同，因此中间件不属于过滤器模式。</p>\n<h2 id=\"axios-的拦截器也是责任链模式？\"><a href=\"#axios-的拦截器也是责任链模式？\" class=\"headerlink\" title=\"axios 的拦截器也是责任链模式？\"></a>axios 的拦截器也是责任链模式？</h2><p>是的，Axios 的拦截器实现了责任链模式。在 Axios 中，拦截器被分为请求拦截器和响应拦截器。每个拦截器都有一个处理函数，在请求或响应被发送之前或之后执行。多个拦截器可以按照一定的顺序组成一个链，每个拦截器可以选择继续传递请求或响应，或者中断并返回一个错误响应。这就是责任链模式的经典实现方式。</p>\n<h2 id=\"中间件能做什么\"><a href=\"#中间件能做什么\" class=\"headerlink\" title=\"中间件能做什么\"></a>中间件能做什么</h2><ul>\n<li>执行任何代码。</li>\n<li>更改请求和响应对象。</li>\n<li>结束请求-响应循环。</li>\n<li>调用堆栈中的下一个中间件函数。</li>\n<li>如果当前中间件函数没有结束请求-响应循环，它必须调用 next()将控制权传递给下一个中间件函数。否则，请求将被挂起。</li>\n</ul>\n<h2 id=\"中间件分类\"><a href=\"#中间件分类\" class=\"headerlink\" title=\"中间件分类\"></a>中间件分类</h2><p>在 Nestjs 中，中间件（Middleware）是一种在处理 HTTP 请求和响应之前或之后进行拦截和处理的机制。中间件的作用类似于拦截器（Interceptor），但是与拦截器不同的是，中间件可以针对整个应用程序，而不仅仅是某个控制器或者方法。</p>\n<p>在 Nestjs 中，中间件可以是全局的，也可以是局部的。全局中间件会对整个应用程序的请求进行拦截和处理，而局部中间件只会对指定的路由或控制器的请求进行拦截和处理。</p>\n<p>Nestjs 支持使用类和函数两种方式来创建中间件。使用类创建中间件时，需要实现 NestMiddleware 接口。使用函数创建中间件时，需要返回一个函数，该函数接收三个参数：请求对象、响应对象和下一个中间件函数。</p>\n<p>以下是一个使用类创建中间件的示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Injectable, NestMiddleware &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; Request, Response &#125; from &#39;express&#39;;\n\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware &#123;\n  use(req: Request, res: Response, next: Function) &#123;\n    console.log(&#96;Request...&#96;);\n    next();\n  &#125;\n&#125;</code></pre>\n\n<p>该中间件将在每个请求到达应用程序时输出一个日志。</p>\n<p>要将全局中间件添加到应用程序中，需要在应用程序模块中调用 app.use() 方法。以下是一个示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module, NestModule, MiddlewareConsumer &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\nimport &#123; AppService &#125; from &#39;.&#x2F;app.service&#39;;\nimport &#123; LoggerMiddleware &#125; from &#39;.&#x2F;logger.middleware&#39;;\n\n@Module(&#123;\n  imports: [],\n  controllers: [AppController],\n  providers: [AppService],\n&#125;)\nexport class AppModule implements NestModule &#123;\n  configure(consumer: MiddlewareConsumer) &#123;\n    consumer.apply(LoggerMiddleware).forRoutes(&#39;*&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>该中间件将被应用于所有的路由。</p>\n<p>要将局部中间件添加到控制器或者路由中，需要在相应的控制器或者路由上调用 use() 方法。以下是一个示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Get, UseMiddleware &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; LoggerMiddleware &#125; from &#39;.&#x2F;logger.middleware&#39;;\n\n@Controller(&#39;cats&#39;)\n@UseMiddleware(LoggerMiddleware)\nexport class CatsController &#123;\n  @Get()\n  findAll() &#123;\n    return &#39;This action returns all cats&#39;;\n  &#125;\n&#125;</code></pre>\n\n<p>该中间件将仅被应用于 &#x2F;cats 路由。</p>\n<h1 id=\"NestJs-管道\"><a href=\"#NestJs-管道\" class=\"headerlink\" title=\"NestJs 管道\"></a>NestJs 管道</h1><p>在 NestJS 中，管道（Pipes）是<strong>用于对输入数据进行转换和验证的机制</strong>。它们充当了请求和响应数据的过滤器，并可以在数据进入控制器之前或离开控制器之后进行处理。</p>\n<p>管道在数据流中的位置通常是在控制器的参数绑定和请求处理之间。它们可以用于验证和转换请求的参数、验证响应的数据、对输入数据进行预处理等。</p>\n<p>使用管道的好处包括：</p>\n<ol>\n<li><p><code>数据验证</code>：管道可以验证输入数据的有效性，例如验证请求的参数是否符合规定的格式、是否满足自定义的业务规则等。</p>\n</li>\n<li><p><code>数据转换</code>：管道可以将输入数据转换为目标类型或格式，例如将字符串转换为数字、将日期字符串转换为日期对象等。</p>\n</li>\n<li><p><code>数据预处理</code>：管道可以在数据进入控制器之前对其进行预处理，例如清理数据、添加默认值、进行数据格式化等。</p>\n</li>\n<li><p><code>统一的数据处理逻辑</code>：通过管道，可以将数据处理逻辑集中在一个地方，提高代码的可维护性和重用性。</p>\n</li>\n</ol>\n<p>在 NestJS 中，可以使用内置的管道，如 ValidationPipe、ParseIntPipe 等，也可以创建自定义的管道来满足特定的需求。管道可以应用于<code>控制器的方法参数</code>、<code>方法返回值</code>、<code>自定义 DTO 对象</code>等多个地方，<strong>以实现数据的验证和转换</strong>。</p>\n<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><ol>\n<li>绑定到参数上-类方式&#x2F;实例方式</li>\n<li>基于 joi 的 shcema 方式</li>\n<li>class-validator 类方式</li>\n<li>全局方式【前三种可以，这个用不来】</li>\n</ol>\n<h2 id=\"nestjs-管道属于-23-种设计模式中的哪种\"><a href=\"#nestjs-管道属于-23-种设计模式中的哪种\" class=\"headerlink\" title=\"nestjs 管道属于 23 种设计模式中的哪种\"></a>nestjs 管道属于 23 种设计模式中的哪种</h2><p>在设计模式中，NestJS 的管道属于”装饰器模式”。<strong>装饰器模式</strong>是一种结构型设计模式，它允许在不修改现有对象结构的情况下，通过将对象包装在装饰器对象中来动态地添加功能。</p>\n<p>在 NestJS 中，管道充当了装饰器的角色。它们用于包装和处理传入的请求数据，并可以在处理数据之前和之后执行各种操作，例如验证、转换、过滤等。通过使用管道，我们可以将这些处理逻辑与业务逻辑分离，并在需要时轻松地应用它们。</p>\n<p>类似于装饰器模式中的装饰器对象，NestJS 的管道可以应用于控制器的方法参数、方法、类等，以添加额外的功能和验证。它们可以按顺序链接在一起，形成管道链，每个管道都负责一项具体的任务。</p>\n<p>总之，NestJS 的管道采用了装饰器模式的概念和思想，通过在运行时动态地为对象添加功能，实现了代码的可维护性和可扩展性。</p>\n<h1 id=\"守卫-x2F-授权-x2F-鉴权\"><a href=\"#守卫-x2F-授权-x2F-鉴权\" class=\"headerlink\" title=\"守卫&#x2F;授权&#x2F;鉴权\"></a>守卫&#x2F;授权&#x2F;鉴权</h1><h2 id=\"守卫与中间件\"><a href=\"#守卫与中间件\" class=\"headerlink\" title=\"守卫与中间件\"></a>守卫与中间件</h2><ol>\n<li>守卫不是中间件</li>\n<li>因为中间件不知道调用该函数后将执行哪个处理 next()程序</li>\n<li>守卫可以访问实例 ExecutionContext，因此确切地知道接下来要执行什么。</li>\n</ol>\n<h2 id=\"守卫与中间件、过滤器、管道、拦截器\"><a href=\"#守卫与中间件、过滤器、管道、拦截器\" class=\"headerlink\" title=\"守卫与中间件、过滤器、管道、拦截器\"></a>守卫与中间件、过滤器、管道、拦截器</h2><p>它们的设计与异常过滤器、管道和拦截器非常相似，可让您在请求&#x2F;响应周期的正确位置插入处理逻辑，并以声明方式进行。这有助于使您的代码保持干爽和声明式</p>\n<h2 id=\"守卫执行顺序\"><a href=\"#守卫执行顺序\" class=\"headerlink\" title=\"守卫执行顺序\"></a>守卫执行顺序</h2><p><strong>守卫在所有中间件之后执行</strong>，但<strong>在任何拦截器或管道 之前执行</strong>。</p>\n<h2 id=\"nestjs-中-“守卫在所有中间件之后执行，但在任何拦截器或管道-之前执行”，为什么\"><a href=\"#nestjs-中-“守卫在所有中间件之后执行，但在任何拦截器或管道-之前执行”，为什么\" class=\"headerlink\" title=\"nestjs 中 “守卫在所有中间件之后执行，但在任何拦截器或管道 之前执行”，为什么\"></a>nestjs 中 “守卫在所有中间件之后执行，但在任何拦截器或管道 之前执行”，为什么</h2><p>在 NestJS 中，守卫在所有中间件之后执行，但在任何拦截器或管道之前执行，这是因为守卫的主要目的是在请求到达控制器之前对请求进行验证、授权或其他操作。</p>\n<p><code>中间件</code>是在请求到达控制器之前执行的代码，它们通常用于处理请求的前置操作，例如<strong>身份验证、日志记录</strong>等。中间件的执行顺序是按照它们在应用程序中的注册顺序依次执行的。</p>\n<p><code>拦截器和管道</code>是用于处理控制器中的方法执行前后的操作。拦截器可以在方法执行前后进行一些额外的处理，例如<strong>日志记录、异常处理</strong>等。</p>\n<p><code>管道</code>可以<strong>用于对请求进行转换、验证或其他处理</strong>。</p>\n<p><code>守卫</code>的目的是<strong>在控制器之前对请求进行验证或授权</strong>，因此它们需要在中间件执行之后但在拦截器和管道执行之前执行。这样可以确保在进入控制器之前对请求进行了适当的验证和授权操作，以便控制器中的方法能够处理有效和合法的请求。</p>\n<h2 id=\"身份验证的中间件与授权的守卫区别\"><a href=\"#身份验证的中间件与授权的守卫区别\" class=\"headerlink\" title=\"身份验证的中间件与授权的守卫区别\"></a>身份验证的中间件与授权的守卫区别</h2><p><strong>简化：</strong></p>\n<ol>\n<li><p>身份验证中间件用于验证请求中的身份信息，确保请求发起者经过身份验证。</p>\n</li>\n<li><p>授权守卫用于在进入控制器的特定路由或方法之前进行授权验证，确保请求发起者有足够的权限或角色访问受保护的资源。</p>\n</li>\n</ol>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p>身份验证中间件和授权守卫在 NestJS 中具有不同的作用和功能：</p>\n<ol>\n<li><p>身份验证中间件（Authentication Middleware）：</p>\n<ul>\n<li>身份验证中间件用于验证请求中的身份信息，例如用户的凭证、令牌或会话。</li>\n<li>它通常在请求到达控制器之前执行，用于对请求进行身份验证和身份认证。</li>\n<li>身份验证中间件的目的是确保请求发起者是经过身份验证和授权的用户。</li>\n</ul>\n</li>\n<li><p>授权守卫（Authorization Guards）：</p>\n<ul>\n<li>授权守卫用于在进入控制器的特定路由或方法之前进行授权验证。</li>\n<li>它基于用户的身份信息和角色&#x2F;权限规则来决定是否允许请求继续执行。</li>\n<li>授权守卫的目的是确保请求发起者具有足够的权限或角色才能访问受保护的资源。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li>身份验证中间件主要负责验证请求中的身份信息，确保请求发起者经过身份验证。</li>\n<li>授权守卫用于在进入控制器的特定路由或方法之前进行授权验证，决定请求是否具有访问权限。</li>\n</ul>\n<p>这两个概念是互补的，身份验证确保用户的身份可信，授权守卫确保用户有权访问特定资源。通常，身份验证中间件会在授权守卫之前执行，以确保请求发起者经过身份验证后再进行授权验证。</p>\n</p>\n</details>\n<h1 id=\"CASL\"><a href=\"#CASL\" class=\"headerlink\" title=\"CASL\"></a>CASL</h1><h2 id=\"CASL-是什么\"><a href=\"#CASL-是什么\" class=\"headerlink\" title=\"CASL 是什么\"></a>CASL 是什么</h2><p>CASL（Capability-based Security Language）是一个用于在应用程序中实施<strong>基于能力的安全性的库</strong>。它提供了一种声明性的方式来定义和验证用户对资源的访问权限。</p>\n<p>CASL 提供了一个可读性强且易于使用的 DSL（领域特定语言），用于定义资源、操作和角色之间的关系。它基于资源能力列表（ACL）模型，其中每个能力表示用户可以对资源执行的操作。</p>\n<p>使用 CASL，您可以轻松地将访问控制逻辑集成到您的应用程序中。以下是 CASL 的一些主要特点：</p>\n<ol>\n<li><p>声明性语法：CASL 提供了一种声明性的语法，您可以使用它来定义资源、操作和角色之间的关系。这使得代码更易于理解和维护。</p>\n</li>\n<li><p>动态授权：CASL 允许您在运行时动态计算用户的权限，以便根据不同的上下文和条件对资源的访问进行灵活控制。</p>\n</li>\n<li><p>细粒度控制：CASL 支持对每个资源和操作进行细粒度的控制，使您能够以精确的方式定义用户的权限。</p>\n</li>\n<li><p>支持多种框架和库：CASL 不仅适用于 Node.js 和浏览器环境，还提供了与常见框架和库（如 Angular、React、Vue.js 等）的集成。</p>\n</li>\n</ol>\n<p>通过使用 CASL，您可以将安全性作为应用程序的核心设计原则，并以一种直观和灵活的方式实现访问控制。CASL 的目标是帮助您构建安全且易于扩展的应用程序，同时保持代码的清晰和可维护性。</p>\n<h2 id=\"CASL-如何使用\"><a href=\"#CASL-如何使用\" class=\"headerlink\" title=\"CASL 如何使用\"></a>CASL 如何使用</h2><p>CASL 的使用涉及几个主要概念和步骤。下面是一个基本的 CASL 使用示例：</p>\n<ol>\n<li><p>定义资源和操作：首先，您需要定义应用程序中的资源和操作。资源可以是任何您希望进行访问控制的实体，例如用户、文章、订单等。操作表示用户可以对资源执行的操作，例如创建、读取、更新和删除。</p>\n</li>\n<li><p>定义角色和权限：接下来，您需要定义角色和与之关联的权限。角色可以代表用户、用户组或特定角色，而权限表示角色被授予的资源操作能力。</p>\n</li>\n<li><p>创建策略：使用 CASL，您可以创建策略来定义谁可以执行哪些操作。策略基于资源、操作和角色之间的关系来确定用户的访问权限。</p>\n</li>\n<li><p>验证权限：一旦策略定义完毕，您可以使用 CASL 提供的验证方法来验证用户对资源的访问权限。您可以在需要进行访问控制的地方调用这些方法，并根据结果采取相应的操作。</p>\n</li>\n</ol>\n<p>下面是一个简单的示例，展示了如何使用 CASL：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; AbilityBuilder, Ability &#125; from &#39;@casl&#x2F;ability&#39;;\n\n&#x2F;&#x2F; 定义资源和操作\nconst ArticleResource &#x3D; &#39;Article&#39;;\nconst ArticleActions &#x3D; [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;];\n\n&#x2F;&#x2F; 定义角色和权限\nconst roles &#x3D; &#123;\n  guest: [&#39;read&#39;],\n  user: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;],\n  admin: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;],\n&#125;;\n\n&#x2F;&#x2F; 创建策略\nconst ability &#x3D; AbilityBuilder.define((can) &#x3D;&gt; &#123;\n  can(&#39;read&#39;, ArticleResource);\n  can(&#39;create&#39;, ArticleResource);\n  can(&#39;update&#39;, ArticleResource);\n  can(&#39;delete&#39;, ArticleResource);\n&#125;);\n\n&#x2F;&#x2F; 验证权限\nconst userRole &#x3D; &#39;admin&#39;;\nconst userAbility &#x3D; new Ability([ability]);\nconst canCreateArticle &#x3D; userAbility.can(&#39;create&#39;, ArticleResource);\n\nconsole.log(canCreateArticle); &#x2F;&#x2F; 输出：true 或 false，表示用户是否有创建文章的权限</code></pre>\n\n<p>在上述示例中，我们首先定义了一个名为 “Article” 的资源和一组操作。然后，我们定义了不同角色（guest、user、admin）以及与每个角色相关联的权限。接下来，我们使用 <code>AbilityBuilder</code> 创建了一个能力对象，并使用 <code>can</code> 方法定义了策略。最后，我们使用 <code>Ability</code> 类创建了用户的能力对象，并使用 <code>can</code> 方法验证用户是否具有创建文章的权限。</p>\n<p>这只是 CASL 的一个简单示例，您可以根据实际需求扩展和调整它。通过定义资源、操作、角色和策略，并使用 CASL 的验证方法，您可以轻松地实现基于能力的访问控制。详细的 CASL 文档可以在官方网站上找到，供您进一步学习和探索。</p>\n<h2 id=\"使用-CASL-和-React-的完整示例\"><a href=\"#使用-CASL-和-React-的完整示例\" class=\"headerlink\" title=\"使用 CASL 和 React 的完整示例\"></a>使用 CASL 和 React 的完整示例</h2><p>以下是一个使用 CASL 和 React 的完整示例：</p>\n<p>首先，确保您已经安装了 <code>@casl/react</code> 和 <code>@casl/ability</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @casl&#x2F;react @casl&#x2F;ability</code></pre>\n\n<p>接下来，让我们创建一个能力对象和一个简单的组件来演示 CASL 在 React 中的使用：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; App.js\n\nimport React from &#39;react&#39;;\nimport &#123; createContext &#125; from &#39;react&#39;;\nimport &#123; AbilityContext &#125; from &#39;@casl&#x2F;react&#39;;\nimport &#123; Ability, AbilityBuilder &#125; from &#39;@casl&#x2F;ability&#39;;\n\n&#x2F;&#x2F; 创建一个能力上下文\nconst AbilityContext &#x3D; createContext(ability);\n\n&#x2F;&#x2F; 定义资源和操作\nconst ArticleResource &#x3D; &#39;Article&#39;;\nconst ArticleActions &#x3D; [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;];\n\n&#x2F;&#x2F; 定义角色和权限\nconst roles &#x3D; &#123;\n  guest: [&#39;read&#39;],\n  user: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;],\n  admin: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;],\n&#125;;\n\n&#x2F;&#x2F; &#x2F;&#x2F; 创建策略，这个没啥用，下面重写了\n&#x2F;&#x2F; const ability &#x3D; AbilityBuilder.define((can) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   can(&#39;read&#39;, ArticleResource);\n&#x2F;&#x2F;   can(&#39;create&#39;, ArticleResource);\n&#x2F;&#x2F;   can(&#39;update&#39;, ArticleResource);\n&#x2F;&#x2F;   can(&#39;delete&#39;, ArticleResource);\n&#x2F;&#x2F; &#125;);\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [userRole, setUserRole] &#x3D; useState(&#39;guest&#39;); &#x2F;&#x2F; 假设登录用户的角色是 &#39;guest&#39;\n\n  &#x2F;&#x2F; 创建能力对象并关联用户的角色权限\n  const ability &#x3D; new Ability(\n    AbilityBuilder.define((can) &#x3D;&gt; &#123;\n      const rolePermissions &#x3D; roles[userRole]; &#x2F;&#x2F; 角色转权限\n      if (rolePermissions) &#123;\n        rolePermissions.forEach((permission) &#x3D;&gt; &#123;\n          can(permission, &#39;Article&#39;);\n        &#125;);\n      &#125;\n    &#125;)\n  );\n  return (\n    &lt;AbilityContext.Provider value&#x3D;&#123;ability&#125;&gt;\n      &lt;ArticleList &#x2F;&gt;\n    &lt;&#x2F;AbilityContext.Provider&gt;\n  );\n&#125;;\n\nexport default App;</code></pre>\n\n<p>在上面的代码中，我们首先创建了一个能力对象 <code>ability</code>，然后使用 <code>createContext</code> 函数创建了一个能力上下文 <code>AbilityContext</code>。接下来，我们定义了一个资源和一组操作，以及与角色相关联的权限。然后，我们使用 <code>AbilityBuilder</code> 创建了一个策略，定义了资源和操作之间的关系。</p>\n<p>在 <code>App</code> 组件中，我们将能力对象通过能力上下文提供器 <code>&lt;AbilityContext.Provider&gt;</code> 提供给子组件。在本例中，我们将 <code>ArticleList</code> 组件作为子组件。</p>\n<p>现在，让我们创建 <code>ArticleList</code> 组件，它将根据用户的能力显示不同的操作按钮：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; ArticleList.js\n\nimport React, &#123; useContext &#125; from &#39;react&#39;;\nimport &#123; AbilityContext &#125; from &#39;@casl&#x2F;react&#39;;\n\nconst ArticleList &#x3D; () &#x3D;&gt; &#123;\n  const ability &#x3D; useContext(AbilityContext);\n\n  const handleCreate &#x3D; () &#x3D;&gt; &#123;\n    if (ability.can(&#39;create&#39;, &#39;Article&#39;)) &#123;\n      &#x2F;&#x2F; 执行创建文章的逻辑\n      console.log(&#39;Creating article...&#39;);\n    &#125;\n  &#125;;\n\n  const handleDelete &#x3D; () &#x3D;&gt; &#123;\n    if (ability.can(&#39;delete&#39;, &#39;Article&#39;)) &#123;\n      &#x2F;&#x2F; 执行删除文章的逻辑\n      console.log(&#39;Deleting article...&#39;);\n    &#125;\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Article List&lt;&#x2F;h1&gt;\n      &lt;button onClick&#x3D;&#123;handleCreate&#125; disabled&#x3D;&#123;!ability.can(&#39;create&#39;, &#39;Article&#39;)&#125;&gt;\n        Create Article\n      &lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;handleDelete&#125; disabled&#x3D;&#123;!ability.can(&#39;delete&#39;, &#39;Article&#39;)&#125;&gt;\n        Delete Article\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nexport default ArticleList;</code></pre>\n\n<p>在 <code>ArticleList</code> 组件中，我们使用 <code>useContext</code> 钩子从能力上下文中获取能力对象。然后，我们根据用户的能力决定是否显示</p>\n<h2 id=\"看上去并没有比-if-else-优雅\"><a href=\"#看上去并没有比-if-else-优雅\" class=\"headerlink\" title=\"看上去并没有比 if else 优雅\"></a>看上去并没有比 if else 优雅</h2><p><strong>CASL 是一个用于权限控制和访问控制的库，它旨在提供一种更加简洁、可读性更高的方式来定义和检查权限规则</strong>。CASL 的设计目标是让开发人员能够以一种声明式的方式描述权限规则，而不是通过复杂的 if-else 或 switch-case 来手动编写权限检查逻辑。</p>\n<p>CASL 提供了一种 DSL（领域专用语言），它允许您在代码中以自然的方式描述权限规则。这种声明式的语法使得代码更易于理解和维护。您可以定义角色、资源和操作，并使用 CASL 提供的方法进行权限检查。CASL 还提供了一些便利的方法和工具，使得权限控制逻辑更加简洁和灵活。</p>\n<p>相比之下，<strong>使用传统的 if-else 或 switch-case 来实现权限控制可能会导致代码冗长、难以理解和维护</strong>。当权限规则变得复杂时，if-else 或 switch-case 的嵌套会变得非常深，逻辑也会变得混乱。而 CASL 提供的声明式语法可以更好地组织和描述权限规则，使得代码更加清晰和可读。</p>\n<p>综上所述，CASL 通过提供一种声明式的权限控制方式，使得代码更加优雅、清晰和可维护。它简化了权限规则的定义和检查过程，并提供了便利的工具和方法来处理权限控制逻辑。这样，开发人员可以更专注于业务逻辑而不是权限控制的实现细节。</p>\n<h2 id=\"ability-can-和-ability-notcan-用来判断是不是有权限\"><a href=\"#ability-can-和-ability-notcan-用来判断是不是有权限\" class=\"headerlink\" title=\"ability.can 和 ability.notcan 用来判断是不是有权限\"></a>ability.can 和 ability.notcan 用来判断是不是有权限</h2><p>是的，您理解得正确。在 CASL 中，<code>ability.can</code> 和 <code>ability.cannot</code> 是用来判断当前用户是否具有某个权限的方法。</p>\n<p><code>ability.can</code> 方法接受三个参数：<code>action</code>（操作）、<code>subject</code>（资源）和可选的 <code>field</code>（字段）。它返回一个布尔值，表示当前用户是否有执行该操作的权限。</p>\n<p>示例用法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (ability.can(&#39;create&#39;, &#39;Post&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户有创建 Post 的权限\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户没有创建 Post 的权限\n&#125;</code></pre>\n\n<p><code>ability.cannot</code> 方法与 <code>ability.can</code> 相反，用于判断当前用户是否没有某个权限。它也接受三个参数，并返回一个布尔值。</p>\n<p>示例用法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (ability.cannot(&#39;update&#39;, &#39;Post&#39;, &#39;title&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户没有更新 Post 的 title 字段的权限\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户有更新 Post 的 title 字段的权限\n&#125;</code></pre>\n\n<p>通过使用 <code>ability.can</code> 和 <code>ability.cannot</code> 方法，您可以轻松地进行权限检查，并根据用户的权限执行相应的操作。这样，您可以在代码中清晰地表达权限控制逻辑，使代码更加可读和易于维护。</p>\n<h2 id=\"field-字段有什么用\"><a href=\"#field-字段有什么用\" class=\"headerlink\" title=\"field 字段有什么用\"></a>field 字段有什么用</h2><p>在 CASL 中，<code>field</code> 参数用于指定操作所涉及的资源的特定字段。它是可选的，<strong>用于在判断权限时进一步限制操作的范围。</strong></p>\n<p>通过指定 <code>field</code>，您可以对资源的特定字段进行权限检查，而不仅仅是对整个资源的权限进行检查。这在某些场景下很有用，特别是当不同用户对同一资源的不同字段有不同的权限时。</p>\n<p>示例用法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (ability.can(&#39;update&#39;, &#39;Post&#39;, &#39;title&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户有更新 Post 的 title 字段的权限\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户没有更新 Post 的 title 字段的权限\n&#125;</code></pre>\n\n<p>在上述示例中，<code>ability.can</code> 方法检查当前用户是否具有更新 <code>Post</code> 资源的 <code>title</code> 字段的权限。如果用户有该权限，则执行相应的操作；否则，执行其他逻辑。</p>\n<p>通过使用 <code>field</code> 参数，您可以更细粒度地控制权限，并根据不同字段的权限进行相应的处理。这对于需要对资源的不同字段进行不同的权限控制的应用场景非常有用。</p>\n<h2 id=\"关于-field-的完整示例\"><a href=\"#关于-field-的完整示例\" class=\"headerlink\" title=\"关于 field 的完整示例\"></a>关于 field 的完整示例</h2><p>以下是一个使用 CASL 的完整示例，其中涉及到 <code>field</code> 参数的使用：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 导入 CASL 相关模块\nconst &#123; AbilityBuilder, Ability &#125; &#x3D; require(&#39;@casl&#x2F;ability&#39;);\n\n&#x2F;&#x2F; 定义角色权限规则\nconst roles &#x3D; &#123;\n  admin: [&#39;manage&#39;, &#39;read&#39;, &#39;create&#39;, &#39;update&#39;, &#39;delete&#39;],\n  editor: [&#39;read&#39;, &#39;create&#39;, &#39;update&#39;],\n  viewer: [&#39;read&#39;],\n&#125;;\n\n&#x2F;&#x2F; 定义用户权限\nconst userAbilities &#x3D; &#123;\n  admin: [&#39;User&#39;, &#39;Post&#39;],\n  editor: [&#39;Post&#39;],\n  viewer: [&#39;Post&#39;],\n&#125;;\n\n&#x2F;&#x2F; 创建权限实例\nconst ability &#x3D; new Ability();\n\n&#x2F;&#x2F; 构建角色权限规则\nconst &#123; can, rules &#125; &#x3D; AbilityBuilder.extract();\n\n&#x2F;&#x2F; 为不同角色分配权限规则\nfor (const role of Object.keys(roles)) &#123;\n  const permissions &#x3D; roles[role];\n  for (const resource of userAbilities[role]) &#123;\n    can(permissions, resource);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 将规则绑定到权限实例\nability.update(rules);\n\n&#x2F;&#x2F; 示例资源\nconst post &#x3D; &#123;\n  id: 1,\n  title: &#39;Sample Post&#39;,\n  content: &#39;This is a sample post&#39;,\n&#125;;\n\n&#x2F;&#x2F; 检查当前用户是否有更新 post 的 title 字段的权限\nif (ability.can(&#39;update&#39;, &#39;Post&#39;, &#39;title&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户有更新 post 的 title 字段的权限\n  console.log(&#39;User has permission to update the title field of the post&#39;);\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户没有更新 post 的 title 字段的权限\n  console.log(&#39;User does not have permission to update the title field of the post&#39;);\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了不同角色的权限规则和用户的权限。然后，我们根据角色权限规则构建了权限实例，并将其绑定到 <code>ability</code> 变量上。接下来，我们定义了一个示例资源 <code>post</code>，然后使用 <code>ability.can</code> 方法检查当前用户是否有更新 <code>post</code> 的 <code>title</code> 字段的权限。根据权限的结果，我们输出相应的消息。</p>\n<p>通过在 <code>ability.can</code> 方法中使用 <code>field</code> 参数，我们可以对资源的特定字段进行权限检查，从而更精细地控制用户的权限。这使得我们可以根据不同字段的权限执行不同的操作，确保应用程序的安全性和一致性。</p>\n<h2 id=\"没看到-rules-的赋值操作？\"><a href=\"#没看到-rules-的赋值操作？\" class=\"headerlink\" title=\"没看到 rules 的赋值操作？\"></a>没看到 rules 的赋值操作？</h2><p>在上述示例中，<code>AbilityBuilder.extract()</code> 方法返回的对象中的 <code>can</code> 方法会自动更新 <code>rules</code>，而不需要显式的赋值操作。</p>\n<p>这里是示例代码中更新规则的具体部分：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123; can, rules &#125; &#x3D; AbilityBuilder.extract();\n\n&#x2F;&#x2F; ... 角色权限规则的构建 ...\n\nability.update(rules);</code></pre>\n\n<p>在这段代码中，<code>can</code> 方法会自动更新 <code>rules</code>，并将权限规则添加到 <code>rules</code> 中。然后，我们使用 <code>ability.update(rules)</code> 方法将规则绑定到 <code>ability</code> 实例，使其生效。</p>\n<p>所以，通过在循环中多次调用 <code>can</code> 方法，能够动态构建权限规则并自动更新 <code>rules</code>，最后将规则应用到 <code>ability</code> 实例中。</p>\n<h2 id=\"rules-值是怎样的？\"><a href=\"#rules-值是怎样的？\" class=\"headerlink\" title=\"rules 值是怎样的？\"></a>rules 值是怎样的？</h2><p>在 CASL 中，<code>rules</code> 是一个包含所有权限规则的数组。每个权限规则由一个对象表示，该对象定义了资源类型、动作和条件。</p>\n<p>在上述示例中，<code>rules</code> 的值取决于为不同角色分配的权限规则。示例中的权限规则如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[\n  &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n];</code></pre>\n\n<p>这些规则定义了对 “Post” 和 “Comment” 资源的不同动作的访问权限。例如，第一个规则允许用户进行 “Post” 资源的创建、读取和更新操作，而第二个规则则要求用户是 “admin” 角色才能进行 “Post” 资源的删除操作。</p>\n<p>你可以根据实际需求和业务逻辑，添加、修改或删除规则来定义你的权限策略。</p>\n<h2 id=\"rules-中各个字段是什么意思\"><a href=\"#rules-中各个字段是什么意思\" class=\"headerlink\" title=\"rules 中各个字段是什么意思\"></a>rules 中各个字段是什么意思</h2><p>在 CASL 中，<code>rules</code> 数组中的每个对象表示一个权限规则，包含以下字段：</p>\n<ul>\n<li><code>subject</code>：规则适用的资源类型，通常是模型的名称或标识。例如，在示例中，”Post” 和 “Comment” 分别是资源类型。</li>\n<li><code>actions</code>：规则允许的操作或动作。它是一个字符串数组，包含可以执行的操作。在示例中，”create”、”read”、”update” 和 “delete” 是允许的操作。</li>\n<li><code>conditions</code>：规则的条件，用于限制执行操作的特定条件。它是一个对象，定义了对资源的访问限制。在示例中，”author” 字段用于限制只有 “admin” 角色可以执行删除操作。</li>\n</ul>\n<p>通过组合不同的资源类型、操作和条件，你可以定义丰富的权限规则来控制用户对资源的访问。</p>\n<p>需要注意的是，CASL 使用了类似 MongoDB 查询语法的条件语法，如 <code>$in</code> 操作符用于匹配数组中的任意值。你可以根据具体需求在条件中使用不同的操作符和条件逻辑来构建规则。</p>\n<h2 id=\"CASL-是-23-种设计模式-中的哪种\"><a href=\"#CASL-是-23-种设计模式-中的哪种\" class=\"headerlink\" title=\"CASL 是 23 种设计模式 中的哪种\"></a>CASL 是 23 种设计模式 中的哪种</h2><p>CASL（Capability-based Security Language）并不属于经典的 23 种设计模式中的任何一种。它是一种用于实现基于能力的安全性的库和语言。</p>\n<p>设计模式通常是指在软件开发中常见的解决问题的模式或范例，如单例模式、工厂模式、观察者模式等。而 CASL 是一个专注于安全性和权限控制的库，它提供了一种方便的方式来定义和管理访问控制规则。CASL 的设计目标是帮助开发者实现细粒度的访问控制，而不是遵循经典的设计模式。</p>\n<p>尽管 CASL 不是经典的设计模式之一，但它仍然是一个非常有用的工具，可以帮助开发者实现灵活的权限控制策略，并提供清晰的代码结构和语义。</p>\n<h2 id=\"CASL-不是策略模式吗？\"><a href=\"#CASL-不是策略模式吗？\" class=\"headerlink\" title=\"CASL 不是策略模式吗？\"></a>CASL 不是策略模式吗？</h2><p>抱歉，我之前的回答有误。<strong>CASL（Capability-based Security Language）可以被归类为策略模式（Strategy Pattern）的一种实现</strong>。</p>\n<p>策略模式是一种行为型设计模式，它允许在运行时根据不同的情况选择不同的算法或策略。在 CASL 中，你可以定义不同的规则（策略），并根据特定的条件选择要执行的规则。CASL 通过组合不同的资源类型、操作和条件，允许你灵活地定义和管理访问控制规则，实现了策略模式的概念。</p>\n<p><strong>因此，你可以将 CASL 视为策略模式在权限控制领域的一种应用</strong>，它提供了一种优雅的方式来管理和应用不同的访问策略。<strong>通过定义规则和根据情况选择合适的策略，CASL 可以使你的代码更加模块化、可维护，并且具有灵活的权限控制能力</strong>。</p>\n<h2 id=\"Can-组件源码\"><a href=\"#Can-组件源码\" class=\"headerlink\" title=\"Can 组件源码\"></a>Can 组件源码</h2><p>CASL 的 <code>Can</code> 组件是通过 <code>@casl/react</code> 模块提供的，它是一个 React 组件，用于在 JSX 中进行条件渲染。</p>\n<p>由于 CASL 是一个开源项目，你可以在 CASL 的 GitHub 仓库中找到 <code>@casl/react</code> 模块的源代码。以下是 <code>Can</code> 组件的简化版源代码示例：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &#39;react&#39;;\nimport &#123; AbilityContext &#125; from &#39;@casl&#x2F;react&#39;;\nimport &#123; check &#125; from &#39;@casl&#x2F;ability&#39;;\n\nconst Can &#x3D; (&#123; I, a, this: subject, children &#125;) &#x3D;&gt; &#123;\n  const ability &#x3D; React.useContext(AbilityContext);\n  const allowed &#x3D; check(ability, I, a, subject);\n\n  return allowed ? &lt;&gt;&#123;children&#125;&lt;&#x2F;&gt; : null;\n&#125;;\n\nexport default Can;</code></pre>\n\n<p>在上述代码中，<code>Can</code> 组件接受以下参数：</p>\n<ul>\n<li><code>I</code>：表示操作的动作（例如，’read’、’create’、’update’ 等）。</li>\n<li><code>a</code>：表示操作的实体（例如，’Article’、’User’ 等）。</li>\n<li><code>this</code>：表示操作的主体（即需要进行权限判断的对象）。</li>\n</ul>\n<p>在组件内部，我们使用 <code>AbilityContext</code> 来获取当前的权限对象，然后调用 CASL 的 <code>check</code> 方法来检查是否满足给定的权限条件。根据权限的判断结果，我们决定是否渲染 <code>children</code>。</p>\n<p>需要注意的是，上述示例为简化版的源代码，并不包含完整的错误处理和其他细节。实际使用时，你可能需要根据自己的需求进行适当的修改和定制。你可以在 CASL 的 GitHub 仓库中查看完整的 <code>@casl/react</code> 模块源代码：<a href=\"https://github.com/stalniy/casl/tree/master/packages/react\">https://github.com/stalniy/casl/tree/master/packages/react</a></p>\n<p><a href=\"https://github.com/stalniy/casl/blob/a02ff9416ad4a77312f935173154cbddc68d4e8a/packages/casl-react/src/Can.ts#LL74C2-L80C4\" target=\"_blank\" >真正的源码</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">private _canRender(): boolean &#123;\n  const props: any &#x3D; this.props;\n  const subject &#x3D; props.of || props.a || props.an || props.this || props.on;\n  const can &#x3D; props.not ? &#39;cannot&#39; : &#39;can&#39;;\n\n  return props.ability[can](props.I || props.do, subject, props.field); &#x2F;&#x2F; 注意这里props.ability[can]是个函数\n&#125;</code></pre>\n\n<h2 id=\"从源码来看，CASL-Can-组件内部会自动进行鉴权\"><a href=\"#从源码来看，CASL-Can-组件内部会自动进行鉴权\" class=\"headerlink\" title=\"从源码来看，CASL Can 组件内部会自动进行鉴权\"></a>从源码来看，CASL Can 组件内部会自动进行鉴权</h2><p>是的，CASL 的 <code>Can</code> 组件内部会自动进行鉴权。在源码中，<code>Can</code> 组件通过使用 <code>AbilityContext</code> 获取当前的权限对象，并使用 <code>check</code> 方法来判断是否满足给定的权限条件。</p>\n<p>具体而言，<code>Can</code> 组件会将传入的动作（<code>I</code>）、实体（<code>a</code>）和主体（<code>this</code>）作为参数传递给 <code>check</code> 方法，然后检查当前的权限对象是否允许执行该动作对应该实体的操作。如果满足权限条件，<code>Can</code> 组件会渲染其包裹的子组件；否则，它将返回 <code>null</code>，从而实现了在 JSX 中的条件渲染。</p>\n<p>因此，你可以在使用 <code>Can</code> 组件时，将需要进行鉴权的动作、实体和主体作为参数传递给组件，并根据权限的判断结果来决定是否渲染相应的内容。这样，CASL 的 <code>Can</code> 组件可以帮助你简化在 React 应用中的权限控制逻辑。</p>\n<h2 id=\"ability-从哪里传入的？\"><a href=\"#ability-从哪里传入的？\" class=\"headerlink\" title=\"ability 从哪里传入的？\"></a>ability 从哪里传入的？</h2><p>在使用 CASL 的 <code>Can</code> 组件时，你需要将 <code>Ability</code> 对象传入组件中。<code>Ability</code> 对象定义了权限规则和逻辑，它决定了哪些操作可以被执行，哪些实体可以被访问。</p>\n<p>通常情况下，你可以在应用程序的某个地方创建和管理 <code>Ability</code> 对象，并将其传递给需要使用权限验证的组件。这可以在应用程序的根组件或者某个上下文提供者中完成。</p>\n<p>下面是一个示例，展示了如何在 React 中使用 CASL 的 <code>Can</code> 组件，并将 <code>Ability</code> 对象传递给组件：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123; createContext, useContext &#125; from &#39;react&#39;;\nimport &#123; AbilityBuilder, Ability &#125; from &#39;@casl&#x2F;ability&#39;;\n\n&#x2F;&#x2F; 创建 Ability 对象\nconst ability &#x3D; new Ability([], &#123;\n  &#x2F;* ... *&#x2F;\n&#125;);\n\n&#x2F;&#x2F; 创建上下文\nconst AbilityContext &#x3D; createContext(ability);\n\n&#x2F;&#x2F; 创建一个自定义 Hook，用于在组件中获取 Ability 对象\nfunction useAbility() &#123;\n  return useContext(AbilityContext);\n&#125;\n\n&#x2F;&#x2F; 在应用程序的根组件中提供 Ability 对象\nfunction App() &#123;\n  &#x2F;&#x2F; &#x2F;&#x2F; prettier-ignore\n  return (\n    &lt;AbilityContext.Provider value&#x3D;&#123;ability&#125;&gt;\n      &#123;&#x2F;*ability 这里传入的 *&#x2F;&#125;\n\n      &#123;&#x2F;* 应用程序的其他组件 *&#x2F;&#125;\n    &lt;&#x2F;AbilityContext.Provider&gt;\n  );\n&#125;\n\n&#x2F;&#x2F; 在具体的组件中使用 Can 组件\nfunction MyComponent() &#123;\n  const ability &#x3D; useAbility();\n\n  return (\n    &lt;Can I&#x3D;&quot;edit&quot; a&#x3D;&quot;Post&quot; this&#x3D;&#123;post&#125;&gt;\n      &lt;button&gt;Edit Post&lt;&#x2F;button&gt;\n    &lt;&#x2F;Can&gt;\n  );\n&#125;</code></pre>\n\n<p>在上述示例中，我们首先创建了一个 <code>Ability</code> 对象 <code>ability</code>，然后使用 <code>createContext</code> 函数创建了一个上下文 <code>AbilityContext</code>。接下来，我们定义了一个自定义的 Hook <code>useAbility</code>，用于在组件中获取 <code>Ability</code> 对象。在应用程序的根组件 <code>App</code> 中，我们将 <code>ability</code> 对象通过 <code>AbilityContext.Provider</code> 提供给其他组件。最后，在具体的组件 <code>MyComponent</code> 中，我们使用了 <code>Can</code> 组件来进行权限验证，并通过 <code>useAbility</code> Hook 获取了 <code>Ability</code> 对象。</p>\n<p>通过这种方式，你可以在应用程序中的任何组件中使用 <code>Can</code> 组件，并且能够共享同一个 <code>Ability</code> 对象，实现统一的权限验证。</p>\n<h2 id=\"ability-的结果\"><a href=\"#ability-的结果\" class=\"headerlink\" title=\"ability 的结果\"></a>ability 的结果</h2><p><strong>rules 为</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[\n  &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n];</code></pre>\n\n<p>根据你提供的 <code>rules</code> 值和示例代码构建的 <code>ability</code> 对象，其结果如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const ability &#x3D; &#123;\n  rules: [\n    &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  ],\n  can: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否有权限\n    &#x2F;&#x2F; 返回布尔值表示是否具有权限\n  &#125;,\n  cannot: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否没有权限\n    &#x2F;&#x2F; 返回布尔值表示是否不具有权限\n  &#125;,\n&#125;;</code></pre>\n\n<p>上述代码展示了一个简化的 <code>ability</code> 对象，包含了 <code>rules</code>、<code>can</code> 和 <code>cannot</code> 方法。根据提供的 <code>rules</code> 数组，<code>can</code> 方法用于判断用户是否具有指定的操作权限，而 <code>cannot</code> 方法用于判断用户是否没有指定的操作权限。具体的权限判断逻辑需要根据你的应用程序需求进行实现。</p>\n<h2 id=\"上述代码-ability-can-和-ability-cannot-的具体内容\"><a href=\"#上述代码-ability-can-和-ability-cannot-的具体内容\" class=\"headerlink\" title=\"上述代码 ability.can 和 ability.cannot 的具体内容\"></a>上述代码 ability.can 和 ability.cannot 的具体内容</h2><p>根据你提供的 <code>rules</code> 值和示例代码构建的 <code>ability</code> 对象，<code>ability.can</code> 和 <code>ability.cannot</code> 的具体内容如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const ability &#x3D; &#123;\n  rules: [\n    &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  ],\n  can: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否有权限\n    &#x2F;&#x2F; 返回布尔值表示是否具有权限\n    const matchedRule &#x3D; ability.rules.find(\n      (rule) &#x3D;&gt; rule.subject &#x3D;&#x3D;&#x3D; subject &amp;&amp; rule.actions.includes(action) &amp;&amp; ability._matchesConditions(rule.conditions, field)\n    );\n    return !!matchedRule;\n  &#125;,\n  cannot: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否没有权限\n    &#x2F;&#x2F; 返回布尔值表示是否不具有权限\n    return !ability.can(action, subject, field);\n  &#125;,\n  _matchesConditions: (conditions, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 判断条件是否匹配\n    &#x2F;&#x2F; 根据实际情况进行具体实现\n  &#125;,\n&#125;;</code></pre>\n\n<p>在 <code>can</code> 方法中，我们遍历 <code>rules</code> 数组，根据传入的操作 <code>action</code>、主体 <code>subject</code> 和字段 <code>field</code> 进行匹配，同时调用 <code>_matchesConditions</code> 方法判断条件是否满足。如果找到匹配的规则，表示具有权限，返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<p>在 <code>cannot</code> 方法中，我们直接调用 <code>can</code> 方法判断是否具有权限，并返回其相反值，即表示没有权限。</p>\n<p><code>_matchesConditions</code> 方法用于根据实际的条件判断逻辑来判断条件是否满足。这个方法需要根据你的应用程序需求进行具体实现，判断条件是否满足可以涉及字段值的比较、逻辑运算等操作。</p>\n<h1 id=\"代码用设计模式往往比不用设计模式，更难理解\"><a href=\"#代码用设计模式往往比不用设计模式，更难理解\" class=\"headerlink\" title=\"代码用设计模式往往比不用设计模式，更难理解\"></a>代码用设计模式往往比不用设计模式，更难理解</h1><p><strong>确实，在应用设计模式时，代码可能会更加抽象和复杂，因此阅读和理解代码的难度可能会增加</strong>。设计模式的目的是提供一种灵活、可扩展且易于维护的代码结构，以解决特定的问题或满足特定的需求。但是，设计模式并不是适用于所有情况的银弹，有时候简单的解决方案可能更为合适。</p>\n<p>尽管使用设计模式可能增加代码的复杂性，但它们在长期和大型项目中可以带来许多优势。设计模式可以提高代码的可读性、可维护性和可扩展性，并促进团队合作和代码重用。此外，使用设计模式可以帮助开发人员遵循行业标准和最佳实践，从而提高代码质量和可靠性。</p>\n<p>理解和应用设计模式需要一定的学习和实践，一开始可能会感到困惑，但随着经验的积累，你将能够更好地理解和应用它们。此外，编写清晰、注释良好的代码以及提供适当的文档和示例可以帮助其他开发人员更容易地理解和使用设计模式。</p>\n<p>总而言之，设计模式是一种工具，用于解决特定的问题和提高代码质量。使用设计模式时需要权衡其带来的复杂性和优势，并根据具体情况做出适当的选择。在团队合作和大型项目中，良好的代码组织和结构是非常重要的，设计模式可以成为实现这一目标的有力工具之一。</p>\n<h1 id=\"拦截器（AOP）\"><a href=\"#拦截器（AOP）\" class=\"headerlink\" title=\"拦截器（AOP）\"></a>拦截器（AOP）</h1><p><strong>简化后</strong></p>\n<p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，用于将横切关注点与核心业务逻辑分离，提高代码的模块化和可维护性。通过定义切面来封装横切关注点的逻辑，并在特定的连接点上应用切面，实现横切逻辑的自动执行。AOP 可以帮助解决重复代码和耦合问题，提高代码的可重用性和可维护性。</p>\n<p><strong>未简化</strong></p>\n<p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，用于通过将横切关注点（cross-cutting concerns）与核心业务逻辑分离来提高代码的模块化和可维护性。</p>\n<p>在传统的面向对象编程中，核心业务逻辑往往散布在多个类和方法中，同时还存在一些与核心业务逻辑相关但又与之无关的横切关注点，如日志记录、性能监测、事务管理等。这些横切关注点会导致代码的重复和耦合，使得代码难以理解、调试和维护。</p>\n<p>AOP 通过将这些横切关注点抽象为切面（Aspect），并将其与核心业务逻辑分离，实现了横切关注点的模块化。切面定义了在何时、何地以及如何执行横切关注点的逻辑，而核心业务逻辑则可以专注于自身的功能实现。</p>\n<p>在 AOP 中，切面通过特定的方式（如注解或配置）与目标对象的方法进行绑定，当目标对象的方法被调用时，切面的逻辑就会被自动触发。切面可以在方法执行前、执行后或异常抛出时执行特定的逻辑，如记录日志、进行权限验证、进行性能监测等。</p>\n<p>AOP 常用的概念和术语包括：</p>\n<ol>\n<li>切面（Aspect）：封装了与横切关注点相关的逻辑。</li>\n<li>连接点（Join Point）：在程序执行过程中可以插入切面的特定点，如方法调用、方法执行等。</li>\n<li>切点（Pointcut）：指定了在哪些连接点上应用切面逻辑。</li>\n<li>通知（Advice）：切面在连接点上执行的具体逻辑，包括前置通知、后置通知、异常通知等。</li>\n<li>织入（Weaving）：将切面应用到目标对象的过程。</li>\n</ol>\n<p>AOP 可以帮助我们解决一些横切关注点带来的重复代码和耦合问题，提高代码的可重用性和可维护性。它在许多框架和编程语言中得到了广泛应用，如 Spring 框架中的 AOP、AspectJ 等。</p>\n<p>需要注意的是，AOP 并不是适用于所有场景的解决方案，需要根据具体的业务需求和项目特点来决定是否使用 AOP。在某些情况下，使用 AOP 可能会增加代码的复杂性和理解难度，因此需要权衡利弊并合理使用。</p>\n<h2 id=\"切面编程中使用到哪些设计模式\"><a href=\"#切面编程中使用到哪些设计模式\" class=\"headerlink\" title=\"切面编程中使用到哪些设计模式\"></a>切面编程中使用到哪些设计模式</h2><p>在切面编程中，常用的设计模式包括：</p>\n<ol>\n<li>代理模式（Proxy Pattern）：用于创建切面的代理对象，将横切逻辑织入到目标对象中。</li>\n<li>装饰器模式（Decorator Pattern）：用于动态地给对象添加额外的功能或行为，可以在切面中通过装饰器模式来实现横切逻辑的添加。</li>\n<li>观察者模式（Observer Pattern）：用于实现切面和目标对象之间的通信，切面可以观察目标对象的状态变化并做出相应的处理。</li>\n<li>模板方法模式（Template Method Pattern）：用于定义切面的执行流程和顺序，可以在切面中定义模板方法，并由子类实现具体的切面逻辑。</li>\n<li>工厂模式（Factory Pattern）：用于创建切面对象的工厂，可以根据不同的切面类型来创建相应的切面对象。</li>\n</ol>\n<p>这些设计模式可以在切面编程中帮助实现横切逻辑的管理、织入和执行，提供了灵活和可扩展的方式来处理横切关注点。</p>\n<h2 id=\"nestjs-中间件、守卫、过滤器、管道看上去都是切面编程？\"><a href=\"#nestjs-中间件、守卫、过滤器、管道看上去都是切面编程？\" class=\"headerlink\" title=\"nestjs 中间件、守卫、过滤器、管道看上去都是切面编程？\"></a>nestjs 中间件、守卫、过滤器、管道看上去都是切面编程？</h2><p>是的，NestJS 中间件、守卫、过滤器、管道都属于切面编程的范畴。它们都可以在请求处理的不同阶段对请求进行拦截或处理，从而实现各种切面逻辑，如日志记录、权限验证、数据校验等。在 NestJS 中，中间件、守卫、过滤器、管道各自的应用场景和实现方式有所不同，但它们都可以被视为切面编程的实现方式之一。</p>\n<h2 id=\"过滤器和拦截器有什么区别？\"><a href=\"#过滤器和拦截器有什么区别？\" class=\"headerlink\" title=\"过滤器和拦截器有什么区别？\"></a>过滤器和拦截器有什么区别？</h2><p>过滤器（Filters）和拦截器（Interceptors）在 NestJS 中都用于对请求进行拦截和处理，但它们的作用和使用方式有一些区别。</p>\n<p>过滤器（Filters）主要用于在处理请求的不同阶段对请求进行过滤和转换。它可以在请求处理之前、之后或异常处理阶段对请求进行拦截，并对请求的数据进行处理、转换或过滤。过滤器通常用于实现一些与请求相关的全局逻辑，例如日志记录、错误处理、数据转换等。</p>\n<p>拦截器（Interceptors）则更加通用且灵活，它可以在请求处理的各个阶段对请求进行拦截，并对请求进行修改、记录日志、添加额外的功能等。拦截器可以对请求的参数、响应结果、异常进行处理，也可以在请求之前或之后执行额外的逻辑。拦截器可以针对具体的控制器或路由进行设置，也可以应用于全局。</p>\n<p>总体而言，</p>\n<ol>\n<li><strong>过滤器更加关注对请求的预处理和后处理，通常用于实现一些通用的全局逻辑</strong>；</li>\n<li><strong>而拦截器则更加灵活，可用于在请求的各个阶段进行拦截和处理，包括对请求参数、响应结果和异常的处理，也可以应用于具体的控制器或路由</strong>。</li>\n</ol>\n<p>需要根据具体的场景和需求选择使用过滤器还是拦截器，或者两者结合使用。</p>\n<h2 id=\"过滤器通常是通过实现-ExceptionFilter、Interceptor-或-PipeTransform-接口来定义，而拦截器则是通过实现-Interceptor-接口来定义，-那么过滤器和拦截器两个之间有什么关系\"><a href=\"#过滤器通常是通过实现-ExceptionFilter、Interceptor-或-PipeTransform-接口来定义，而拦截器则是通过实现-Interceptor-接口来定义，-那么过滤器和拦截器两个之间有什么关系\" class=\"headerlink\" title=\"过滤器通常是通过实现 ExceptionFilter、Interceptor 或 PipeTransform 接口来定义，而拦截器则是通过实现 Interceptor 接口来定义， 那么过滤器和拦截器两个之间有什么关系\"></a>过滤器通常是通过实现 ExceptionFilter、Interceptor 或 PipeTransform 接口来定义，而拦截器则是通过实现 Interceptor 接口来定义， 那么过滤器和拦截器两个之间有什么关系</h2><p>过滤器（Filters）和拦截器（Interceptors）在 NestJS 中都用于对请求进行拦截和处理，但它们在实现和应用上有一些不同。</p>\n<p>在 NestJS 中，<br><strong>过滤器</strong><br>过滤器通常是通过实现 <code>ExceptionFilter</code>、<code>Interceptor</code> 或 <code>PipeTransform</code> 接口来定义。<br>它们可以用于对请求的参数、响应结果或异常进行过滤、转换和处理。<br>过滤器可以应用于整个请求流程，可以捕获异常、记录日志、处理错误等。<br>过滤器的定义是更为通用的，可以应用于不同的场景和请求处理阶段。<br><strong>拦截器</strong><br>拦截器则是通过实现 <code>Interceptor</code> 接口来定义。<br>它们可以在请求的不同阶段对请求进行拦截，并对请求进行修改、记录日志、添加额外的功能等。<br>拦截器可以应用于整个请求流程，包括请求之前、请求处理过程中和请求之后。<br>拦截器的定义相对<strong>更加专注于对请求的拦截和处理</strong>。</p>\n<p>在关系上，<strong>可以将拦截器视为一种特殊类型的过滤器</strong>。<strong>拦截器提供了更精细的请求拦截和处理能力，而过滤器则更为通用，可以应用于不同的场景和请求处理阶段</strong>。在实践中，可以根据具体的需求和场景选择使用过滤器还是拦截器，或者将它们结合使用以实现更复杂的请求处理逻辑。</p>\n<h1 id=\"模版\"><a href=\"#模版\" class=\"headerlink\" title=\"模版\"></a>模版</h1><h2 id=\"静态模版示例\"><a href=\"#静态模版示例\" class=\"headerlink\" title=\"静态模版示例\"></a>静态模版示例</h2><p>添加注解就可以了</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Get, Controller, Render &#125; from &#39;@nestjs&#x2F;common&#39;;\n\n@Controller()\nexport class AppController &#123;\n  @Get()\n  @Render(&#39;index&#39;)\n  root() &#123;\n    return &#123; message: &#39;Hello world!&#39; &#125;;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"动态模版示例\"><a href=\"#动态模版示例\" class=\"headerlink\" title=\"动态模版示例\"></a>动态模版示例</h2><p>在 NestJS 中，<code>res.render</code> 方法并不直接提供，因为 NestJS 本身并不是一个传统的 Web 框架，它更专注于构建可扩展的服务器应用程序。</p>\n<p>如果你想在 NestJS 中实现类似于传统 Web 框架中的 <code>res.render</code> 的功能，可以使用模板引擎相关的库或模块。常用的模板引擎库包括 Handlebars、EJS、Pug（以前称为 Jade）等。</p>\n<p>以下是使用 Handlebars 模板引擎进行动态模板渲染的示例：</p>\n<ol>\n<li>安装 Handlebars 模板引擎和相关的依赖：</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install handlebars hbs</code></pre>\n\n<ol start=\"2\">\n<li>在模块中导入 Handlebars 模块和相关的服务：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; HbsRenderer &#125; from &#39;.&#x2F;hbs.renderer&#39;;\n\n@Module(&#123;\n  providers: [HbsRenderer],\n  exports: [HbsRenderer],\n&#125;)\nexport class AppModule &#123;&#125;</code></pre>\n\n<ol start=\"3\">\n<li>创建一个名为 <code>hbs.renderer.ts</code> 的文件，定义 <code>HbsRenderer</code> 类，用于处理模板渲染：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport * as handlebars from &#39;handlebars&#39;;\nimport * as fs from &#39;fs&#39;;\n\n@Injectable()\nexport class HbsRenderer &#123;\n  render(template: string, data: any): string &#123;\n    const templateFile &#x3D; fs.readFileSync(&#96;path&#x2F;to&#x2F;templates&#x2F;$&#123;template&#125;.hbs&#96;, &#39;utf-8&#39;);\n    const compiledTemplate &#x3D; handlebars.compile(templateFile);\n    return compiledTemplate(data);\n  &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们使用 <code>handlebars</code> 模块加载模板文件，并编译模板，然后使用提供的数据进行渲染。</p>\n<ol start=\"4\">\n<li>在控制器中使用 <code>HbsRenderer</code> 进行模板渲染：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Get, Render &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; HbsRenderer &#125; from &#39;.&#x2F;hbs.renderer&#39;;\n\n@Controller(&#39;example&#39;)\nexport class ExampleController &#123;\n  constructor(private readonly hbsRenderer: HbsRenderer) &#123;&#125;\n\n  @Get()\n  async example() &#123;\n    const data &#x3D; &#123; title: &#39;NestJS Example&#39;, message: &#39;Hello, World!&#39; &#125;;\n    const renderedTemplate &#x3D; this.hbsRenderer.render(&#39;example&#39;, data);\n    return renderedTemplate;\n  &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们在控制器中注入了 <code>HbsRenderer</code>，然后使用它的 <code>render</code> 方法进行模板渲染。</p>\n<p>需要注意的是，NestJS 的核心概念是处理请求和响应，它不直接提供模板渲染功能。所以在使用模板引擎时，你需要自己创建一个服务或类来处理模板渲染，然后在控制器中使用这个服务来实现模板渲染的功能。</p>\n<h1 id=\"返回值剔除-x2F-增加字段\"><a href=\"#返回值剔除-x2F-增加字段\" class=\"headerlink\" title=\"返回值剔除&#x2F;增加字段\"></a>返回值剔除&#x2F;增加字段</h1><p>拦截<code>ClassSerializerInterceptor</code> + <code>class-transformer</code></p>\n<ol>\n<li><code>@Exclude()</code></li>\n<li><code>@Expose()</code></li>\n<li><code>@Transform</code></li>\n</ol>\n<h2 id=\"class-transformer-Transform-示例\"><a href=\"#class-transformer-Transform-示例\" class=\"headerlink\" title=\"class-transformer @Transform 示例\"></a>class-transformer @Transform 示例</h2><p><code>class-transformer</code> 是一个在 TypeScript 中进行对象转换的库，它提供了 <code>@Transform</code> 装饰器用于对属性进行转换操作。下面是一个使用 <code>class-transformer</code> 的示例：</p>\n<p>首先，确保已安装 <code>class-transformer</code> 和 <code>reflect-metadata</code> 依赖：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install class-transformer reflect-metadata</code></pre>\n\n<p>然后，在要进行转换的类中使用 <code>@Transform</code> 装饰器：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Transform, Type &#125; from &#39;class-transformer&#39;;\n\nclass User &#123;\n  @Transform((value) &#x3D;&gt; value.toUpperCase())\n  username: string;\n\n  @Type(() &#x3D;&gt; Date)\n  @Transform((value) &#x3D;&gt; new Date(value))\n  createdAt: Date;\n&#125;\n\nconst user &#x3D; new User();\nuser.username &#x3D; &#39;john&#39;;\nuser.createdAt &#x3D; &#39;2023-01-01&#39;;\n\nconst transformedUser &#x3D; plainToClass(User, user);\nconsole.log(transformedUser);</code></pre>\n\n<p>在上述示例中，我们定义了一个 <code>User</code> 类，它有两个属性：<code>username</code> 和 <code>createdAt</code>。我们使用 <code>@Transform</code> 装饰器对这两个属性进行转换操作。</p>\n<p>对于 <code>username</code> 属性，我们使用一个转换函数 <code>value =&gt; value.toUpperCase()</code> 将用户名转换为大写。</p>\n<p>对于 <code>createdAt</code> 属性，我们使用 <code>@Type(() =&gt; Date)</code> 声明属性类型为 <code>Date</code>，并使用一个转换函数 <code>value =&gt; new Date(value)</code> 将传入的日期字符串转换为 <code>Date</code> 对象。</p>\n<p>最后，我们使用 <code>plainToClass</code> 函数将普通对象转换为 <code>User</code> 类的实例，并输出转换后的对象。</p>\n<p>注意，在使用 <code>class-transformer</code> 进行转换时，需要确保在项目的入口文件中引入 <code>reflect-metadata</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#39;reflect-metadata&#39;;</code></pre>\n\n<p>这是因为 <code>class-transformer</code> 使用了 TypeScript 的装饰器和元数据机制，需要 <code>reflect-metadata</code> 库的支持。</p>\n<h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><p>用于移动端较多，移动客户端更新不及时</p>\n<ol>\n<li>url 版本<strong>就这个常用</strong></li>\n<li>header 字段</li>\n<li>mediatype</li>\n<li>自定义</li>\n</ol>\n<h1 id=\"调度\"><a href=\"#调度\" class=\"headerlink\" title=\"调度\"></a>调度</h1><h1 id=\"nestjs-axios-示例\"><a href=\"#nestjs-axios-示例\" class=\"headerlink\" title=\"nestjs axios 示例\"></a>nestjs axios 示例</h1><p>在 NestJS 中使用 Axios 可以通过创建一个自定义的 Axios Service 来实现。下面是一个简单的示例：</p>\n<p>首先，确保已安装 <code>axios</code> 和 <code>@nestjs/axios</code> 依赖：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install axios @nestjs&#x2F;axios</code></pre>\n\n<p>然后，创建一个 <code>AxiosService</code> 来封装 Axios 请求：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; HttpService, InjectHttpService &#125; from &#39;@nestjs&#x2F;axios&#39;;\nimport &#123; AxiosRequestConfig &#125; from &#39;axios&#39;;\nimport &#123; Observable &#125; from &#39;rxjs&#39;;\n\n@Injectable()\nexport class AxiosService &#123;\n  constructor(@InjectHttpService() private readonly httpService: HttpService) &#123;&#125;\n\n  get&lt;T&gt;(url: string, config?: AxiosRequestConfig): Observable&lt;T&gt; &#123;\n    return this.httpService.get&lt;T&gt;(url, config).pipe(map((response) &#x3D;&gt; response.data));\n  &#125;\n\n  post&lt;T&gt;(url: string, data?: any, config?: AxiosRequestConfig): Observable&lt;T&gt; &#123;\n    return this.httpService.post&lt;T&gt;(url, data, config).pipe(map((response) &#x3D;&gt; response.data));\n  &#125;\n\n  &#x2F;&#x2F; 添加其他 HTTP 方法的封装，如 put、delete 等\n&#125;</code></pre>\n\n<p>在上述示例中，我们创建了一个 <code>AxiosService</code>，它使用 <code>@nestjs/axios</code> 提供的 <code>HttpService</code> 进行 HTTP 请求。通过在构造函数中注入 <code>HttpService</code>，我们可以在 <code>AxiosService</code> 中使用它来发起请求。</p>\n<p><code>AxiosService</code> 中定义了几个常用的方法，如 <code>get</code> 和 <code>post</code>，它们分别对应 GET 和 POST 请求。这些方法使用了 RxJS 的 <code>Observable</code>，并使用 <code>map</code> 操作符从响应中提取出数据。</p>\n<p>现在，我们可以在其他模块或服务中注入 <code>AxiosService</code> 来使用它发送请求。例如，在一个控制器中：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Get &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; AxiosService &#125; from &#39;.&#x2F;axios.service&#39;;\n\n@Controller(&#39;example&#39;)\nexport class ExampleController &#123;\n  constructor(private readonly axiosService: AxiosService) &#123;&#125;\n\n  @Get()\n  async getExampleData() &#123;\n    const response &#x3D; await this.axiosService.get(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;);\n    return response;\n  &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们在 <code>ExampleController</code> 中注入了 <code>AxiosService</code>，并使用它发送了一个 GET 请求。返回的响应数据将作为 API 的返回值。</p>\n<p>通过封装 Axios 请求的 <code>AxiosService</code>，我们可以更方便地使用 Axios 发起 HTTP 请求，并且可以在 NestJS 中享受到依赖注入和模块化开发的好处。</p>\n<h2 id=\"Observable-与-Promise-是什么关系？\"><a href=\"#Observable-与-Promise-是什么关系？\" class=\"headerlink\" title=\"Observable 与 Promise 是什么关系？\"></a>Observable 与 Promise 是什么关系？</h2><p>Observable 和 Promise 都是用于处理异步操作的概念，但它们在使用方式和功能上有一些区别。</p>\n<p>Promise 是 JavaScript 原生提供的一种处理异步操作的方式。它表示一个异步操作的最终完成或失败，并可以通过链式调用 <code>.then()</code> 和 <code>.catch()</code> 来处理操作的结果。Promise 的特点是只能处理一次异步操作，并且结果是单值的，即成功或失败。</p>\n<p>Observable 是 RxJS 库提供的概念，它也用于处理异步操作，但具有更强大的功能和灵活性。Observable 可以表示一个异步数据流，可以发出多个值，也可以发出错误或完成信号。通过使用 Observable，我们可以对数据流进行各种操作，如映射、过滤、合并等，以及使用操作符来处理异步事件的时间窗口、并发等情况。Observable 提供了一种响应式编程的模型，可以更方便地处理复杂的异步场景。</p>\n<p>虽然 Promise 和 Observable 都可以用于处理异步操作，但它们的使用场景有所不同。Promise 更适合处理单次异步操作，例如获取远程数据或执行一个异步任务，并且对结果只关心成功或失败。Observable 则更适合处理连续的异步数据流，例如实时数据更新、事件流等，以及需要对数据进行多次操作和处理的情况。</p>\n<p>在 NestJS 中，默认使用的是基于 Promise 的异步操作，但也可以通过引入 RxJS 库来使用 Observable 来处理异步数据流。</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"多环境配置文件-示例\"><a href=\"#多环境配置文件-示例\" class=\"headerlink\" title=\"多环境配置文件 示例\"></a>多环境配置文件 示例</h2><p>在 NestJS 中，可以使用不同的配置文件来实现多环境配置。以下是一个示例：</p>\n<ol>\n<li><p>创建配置文件：</p>\n<ul>\n<li><code>development.env</code>: 开发环境配置</li>\n<li><code>production.env</code>: 生产环境配置</li>\n</ul>\n</li>\n<li><p>在每个配置文件中定义相应的配置项。例如，可以定义数据库连接、端口号等配置项。</p>\n</li>\n</ol>\n<p><code>development.env</code> 文件内容：</p>\n<pre class=\"line-numbers language-dotenv\" data-language=\"dotenv\"><code class=\"language-dotenv\">DB_HOST&#x3D;localhost\nDB_PORT&#x3D;5432\nDB_NAME&#x3D;development_db\nPORT&#x3D;3000</code></pre>\n\n<p><code>production.env</code> 文件内容：</p>\n<pre class=\"line-numbers language-dotenv\" data-language=\"dotenv\"><code class=\"language-dotenv\">DB_HOST&#x3D;prod-host\nDB_PORT&#x3D;5432\nDB_NAME&#x3D;production_db\nPORT&#x3D;8080</code></pre>\n\n<ol start=\"3\">\n<li>安装 <code>@nestjs/config</code> 模块：</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @nestjs&#x2F;config</code></pre>\n\n<ol start=\"4\">\n<li>在应用程序的根模块中加载配置：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ConfigModule &#125; from &#39;@nestjs&#x2F;config&#39;;\n\n@Module(&#123;\n  imports: [\n    ConfigModule.forRoot(&#123;\n      isGlobal: true, &#x2F;&#x2F; 将配置模块全局导入\n    &#125;),\n  ],\n&#125;)\nexport class AppModule &#123;&#125;</code></pre>\n\n<ol start=\"5\">\n<li>在需要使用配置的地方，通过 <code>ConfigService</code> 获取配置项的值：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ConfigService &#125; from &#39;@nestjs&#x2F;config&#39;;\n\n@Injectable()\nexport class AppService &#123;\n  constructor(private configService: ConfigService) &#123;&#125;\n\n  getDatabaseConfig(): any &#123;\n    const host &#x3D; this.configService.get&lt;string&gt;(&#39;DB_HOST&#39;);\n    const port &#x3D; this.configService.get&lt;number&gt;(&#39;DB_PORT&#39;);\n    const dbName &#x3D; this.configService.get&lt;string&gt;(&#39;DB_NAME&#39;);\n\n    return &#123; host, port, dbName &#125;;\n  &#125;\n\n  getPort(): number &#123;\n    return this.configService.get&lt;number&gt;(&#39;PORT&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>在开发环境中，NestJS 会自动加载 <code>development.env</code> 配置文件；在生产环境中，会加载 <code>production.env</code> 配置文件。然后，可以通过 <code>ConfigService</code> 来获取配置项的值，并在应用程序的其他地方使用。</p>\n<p>请注意，以上示例是基于 <code>@nestjs/config</code> 模块的配置方式。你也可以使用其他配置模块或自定义方式来加载和管理多环境配置。</p>\n<h2 id=\"YAML-文件来实现多环境配置\"><a href=\"#YAML-文件来实现多环境配置\" class=\"headerlink\" title=\"YAML 文件来实现多环境配置\"></a>YAML 文件来实现多环境配置</h2><p>以下是一个示例，展示了如何使用 YAML 文件来实现多环境配置：</p>\n<ol>\n<li><p>创建不同环境的配置文件：</p>\n<ul>\n<li><code>development.yml</code>: 开发环境配置</li>\n<li><code>production.yml</code>: 生产环境配置</li>\n</ul>\n</li>\n<li><p>在每个配置文件中定义相应的配置项。例如，可以定义数据库连接、端口号等配置项。</p>\n</li>\n</ol>\n<p><code>development.yml</code> 文件内容：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">DB_HOST: localhost\nDB_PORT: 5432\nDB_NAME: development_db\nPORT: 3000</code></pre>\n\n<p><code>production.yml</code> 文件内容：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">DB_HOST: prod-host\nDB_PORT: 5432\nDB_NAME: production_db\nPORT: 8080</code></pre>\n\n<ol start=\"3\">\n<li>安装 <code>js-yaml</code> 模块：</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install js-yaml</code></pre>\n\n<ol start=\"4\">\n<li>创建一个配置服务类，用于加载和解析配置文件：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import * as yaml from &#39;js-yaml&#39;;\nimport * as fs from &#39;fs&#39;;\n\n@Injectable()\nexport class ConfigService &#123;\n  private readonly config: Record&lt;string, any&gt;;\n\n  constructor() &#123;\n    const env &#x3D; process.env.NODE_ENV || &#39;development&#39;;\n    const configFile &#x3D; fs.readFileSync(&#96;$&#123;env&#125;.yml&#96;, &#39;utf8&#39;);\n    this.config &#x3D; yaml.load(configFile);\n  &#125;\n\n  get(key: string): any &#123;\n    return this.config[key];\n  &#125;\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>在需要使用配置的地方，通过 <code>ConfigService</code> 获取配置项的值：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ConfigService &#125; from &#39;.&#x2F;config.service&#39;;\n\n@Injectable()\nexport class AppService &#123;\n  constructor(private configService: ConfigService) &#123;&#125;\n\n  getDatabaseConfig(): any &#123;\n    const host &#x3D; this.configService.get(&#39;DB_HOST&#39;);\n    const port &#x3D; this.configService.get(&#39;DB_PORT&#39;);\n    const dbName &#x3D; this.configService.get(&#39;DB_NAME&#39;);\n\n    return &#123; host, port, dbName &#125;;\n  &#125;\n\n  getPort(): number &#123;\n    return this.configService.get(&#39;PORT&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>在开发环境中，加载的是 <code>development.yml</code> 文件的配置；在生产环境中，加载的是 <code>production.yml</code> 文件的配置。然后，可以通过 <code>ConfigService</code> 来获取配置项的值，并在应用程序的其他地方使用。</p>\n<p>请注意，以上示例是一种自定义的方式来加载和解析 YAML 配置文件。你也可以使用其他 YAML 解析库或配置模块来实现类似的功能。</p>\n<h1 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h1><p><strong>压缩可以大大减小响应主体的大小，从而提高 Web 应用程序的速度。</strong></p>\n<p><strong>对于生产中的高流量网站，强烈建议从应用程序服务器卸载压缩</strong> - <strong>通常在反向代理</strong>（例如 Nginx）中。在那种情况下，您不应该使用压缩中间件</p>\n<h1 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h1><h2 id=\"单文件上传\"><a href=\"#单文件上传\" class=\"headerlink\" title=\"单文件上传\"></a>单文件上传</h2><p>在 NestJS 中实现文件上传可以使用 <code>multer</code> 模块。下面是一个简单的示例：</p>\n<ol>\n<li>安装 <code>multer</code> 模块：</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @nestjs&#x2F;platform-express multer</code></pre>\n\n<ol start=\"2\">\n<li>创建一个上传文件的控制器：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Post, UseInterceptors, UploadedFile &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  uploadFile(@UploadedFile() file: Express.Multer.File) &#123;\n    &#x2F;&#x2F; 处理上传的文件，可以保存到磁盘或执行其他操作\n    console.log(file);\n\n    &#x2F;&#x2F; 返回响应\n    return &#123; message: &#39;File uploaded successfully&#39; &#125;;\n  &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>在模块中引入 <code>FilesController</code>：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesController &#125; from &#39;.&#x2F;files.controller&#39;;\n\n@Module(&#123;\n  controllers: [FilesController],\n&#125;)\nexport class FilesModule &#123;&#125;</code></pre>\n\n<ol start=\"4\">\n<li>在根模块或其他子模块中导入 <code>FilesModule</code>：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesModule &#125; from &#39;.&#x2F;files&#x2F;files.module&#39;;\n\n@Module(&#123;\n  imports: [FilesModule],\n&#125;)\nexport class AppModule &#123;&#125;</code></pre>\n\n<p>现在，你可以使用任何 HTTP 客户端发送带有 <code>file</code> 字段的 <code>multipart/form-data</code> 请求到 <code>POST /files/upload</code> 路由，以上传文件。在控制器的 <code>uploadFile</code> 方法中，你可以处理上传的文件，例如保存到磁盘或执行其他自定义逻辑。</p>\n<p>这只是一个简单的示例，你可以根据实际需求进行更多的自定义配置，例如限制文件大小、允许的文件类型等。请查阅 <code>multer</code> 文档以获取更多详细信息和配置选项。</p>\n<h2 id=\"多文件上传\"><a href=\"#多文件上传\" class=\"headerlink\" title=\"多文件上传\"></a>多文件上传</h2><p>在 NestJS 中实现多文件上传，可以使用 <code>multer</code> 模块结合 <code>@UseInterceptors()</code> 装饰器来处理。</p>\n<p>下面是一个示例，展示如何实现多文件上传：</p>\n<ol>\n<li>安装 <code>multer</code> 模块：</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @nestjs&#x2F;platform-express multer</code></pre>\n\n<ol start=\"2\">\n<li>创建一个上传文件的控制器：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Post, UseInterceptors, UploadedFiles &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FilesInterceptor(&#39;files&#39;))\n  uploadFiles(@UploadedFiles() files: Express.Multer.File[]) &#123;\n    &#x2F;&#x2F; 处理上传的文件，可以保存到磁盘或执行其他操作\n    console.log(files);\n\n    &#x2F;&#x2F; 返回响应\n    return &#123; message: &#39;Files uploaded successfully&#39; &#125;;\n  &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>在模块中引入 <code>FilesController</code>：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesController &#125; from &#39;.&#x2F;files.controller&#39;;\n\n@Module(&#123;\n  controllers: [FilesController],\n&#125;)\nexport class FilesModule &#123;&#125;</code></pre>\n\n<ol start=\"4\">\n<li>在根模块或其他子模块中导入 <code>FilesModule</code>：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesModule &#125; from &#39;.&#x2F;files&#x2F;files.module&#39;;\n\n@Module(&#123;\n  imports: [FilesModule],\n&#125;)\nexport class AppModule &#123;&#125;</code></pre>\n\n<p>现在，你可以使用任何支持多文件上传的 HTTP 客户端发送带有 <code>files</code> 字段的 <code>multipart/form-data</code> 请求到 <code>POST /files/upload</code> 路由，以上传多个文件。在控制器的 <code>uploadFiles</code> 方法中，你可以处理上传的文件数组，例如保存到磁盘或执行其他自定义逻辑。</p>\n<p>请注意，<code>@UseInterceptors(FilesInterceptor(&#39;files&#39;))</code> 中的 <code>&#39;files&#39;</code> 参数指定了接收文件的字段名，你可以根据实际需求进行更改。</p>\n<p>这只是一个简单的示例，你可以根据实际需求进行更多的自定义配置，例如限制文件大小、允许的文件类型等。请查阅 <code>multer</code> 文档以获取更多详细信息和配置选项。</p>\n<h2 id=\"DTO-验证文件大小-x2F-类型\"><a href=\"#DTO-验证文件大小-x2F-类型\" class=\"headerlink\" title=\"DTO 验证文件大小&#x2F;类型\"></a>DTO 验证文件大小&#x2F;类型</h2><p>在 NestJS 中，你可以使用 <code>class-validator</code> 和 <code>class-transformer</code> 模块结合自定义验证器来验证上传文件的大小和类型。</p>\n<p>以下是一个示例，展示如何在 NestJS 中验证上传文件的大小和类型：</p>\n<ol>\n<li>首先，安装所需的依赖模块：</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install class-validator class-transformer</code></pre>\n\n<ol start=\"2\">\n<li>创建一个自定义验证器来验证文件的大小和类型：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments &#125; from &#39;class-validator&#39;;\n\n@ValidatorConstraint(&#123; name: &#39;file&#39;, async: false &#125;)\n@Injectable()\nexport class FileValidator implements ValidatorConstraintInterface &#123;\n  validate(value: Express.Multer.File, args: ValidationArguments) &#123;\n    const &#123; maxSize, allowedTypes &#125; &#x3D; args.constraints[0];\n    if (maxSize &amp;&amp; value.size &gt; maxSize) &#123;\n      return false; &#x2F;&#x2F; 文件大小超过最大限制\n    &#125;\n    if (allowedTypes &amp;&amp; !allowedTypes.includes(value.mimetype)) &#123;\n      return false; &#x2F;&#x2F; 文件类型不被允许\n    &#125;\n    return true;\n  &#125;\n\n  defaultMessage(args: ValidationArguments) &#123;\n    return &#39;Invalid file&#39;; &#x2F;&#x2F; 验证失败时的默认错误消息\n  &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>在上传文件的 DTO 类中应用验证器：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; IsDefined, Validate &#125; from &#39;class-validator&#39;;\nimport &#123; FileValidator &#125; from &#39;.&#x2F;file.validator&#39;;\n\nexport class UploadFileDto &#123;\n  @IsDefined()\n  @Validate(FileValidator, &#123; maxSize: 10 * 1024 * 1024, allowedTypes: [&#39;image&#x2F;jpeg&#39;, &#39;image&#x2F;png&#39;] &#125;)\n  file: Express.Multer.File;\n&#125;</code></pre>\n\n<p>在上述代码中，<code>UploadFileDto</code> 类使用 <code>@Validate()</code> 装饰器来应用自定义的 <code>FileValidator</code> 验证器。你可以通过传递约束选项对象来配置验证器，例如 <code>maxSize</code>（文件大小限制）和 <code>allowedTypes</code>（允许的文件类型）。</p>\n<ol start=\"4\">\n<li>在控制器中使用验证器：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Post, UploadedFile, UseInterceptors &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\nimport &#123; UploadFileDto &#125; from &#39;.&#x2F;upload-file.dto&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  async uploadFile(@UploadedFile() uploadFileDto: UploadFileDto) &#123;\n    &#x2F;&#x2F; 处理上传的文件\n  &#125;\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用 <code>@UseInterceptors()</code> 装饰器将 <code>FileInterceptor</code> 应用于控制器方法。<code>FileInterceptor</code> 会处理文件上传并将文件保存到指定位置。然后，我们可以在方法参数中使用 <code>@UploadedFile()</code> 装饰器来获取上传的文件对象。</p>\n<p>通过在 DTO 类中应用验证器，NestJS 会在控制器方法执行之前自动验证上传的文件，如果验证失败，会抛出异常并返回相应的错误响应。</p>\n<p>示例中，我们将 @UploadedFile() 装饰器应用于 uploadFileDto 参数，该参数的类型是 UploadFileDto。这样，NestJS 将会在控制器方法执行之前自动验证 uploadFileDto 中的文件对象，并抛出相应的异常，如果验证通过，将会将文件对象赋值给 uploadFileDto 参数。</p>\n<p>在 UploadFileDto 类中定义的验证逻辑仍然有效，通过在控制器方法的参数中使用 UploadFileDto 类型，NestJS 将会自动应用验证器来验证上传的文件对象。</p>\n<p>请注意，上述示例只涵盖了文件大小和文件类型的验证，你可以根据实际需求扩展验证逻辑。还可以使用其他验证器装饰器（如 <code>@IsString()</code>、&#96;</p>\n<h2 id=\"不使用-DTO-，无设计模式验证的示例\"><a href=\"#不使用-DTO-，无设计模式验证的示例\" class=\"headerlink\" title=\"不使用 DTO ，无设计模式验证的示例\"></a>不使用 DTO ，无设计模式验证的示例</h2><p>如果你不想使用 DTO 进行验证，你可以直接在控制器方法中使用 <code>@UploadedFile()</code> 装饰器来获取上传的文件对象，并在方法内部进行验证。以下是一个示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Post, UploadedFile, UseInterceptors &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  async uploadFile(@UploadedFile() file: Express.Multer.File) &#123;\n    &#x2F;&#x2F; 验证文件大小和类型\n    const maxSize &#x3D; 1024 * 1024; &#x2F;&#x2F; 1MB\n    const allowedTypes &#x3D; [&#39;image&#x2F;jpeg&#39;, &#39;image&#x2F;png&#39;];\n\n    if (file.size &gt; maxSize) &#123;\n      throw new Error(&#39;File size exceeds the maximum allowed limit&#39;);\n    &#125;\n\n    if (!allowedTypes.includes(file.mimetype)) &#123;\n      throw new Error(&#39;Invalid file type&#39;);\n    &#125;\n\n    &#x2F;&#x2F; 处理上传的文件\n  &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们直接在 <code>uploadFile</code> 方法中使用 <code>@UploadedFile()</code> 装饰器来获取上传的文件对象，并在方法内部进行文件验证。你可以根据自己的需求修改文件大小和类型的验证逻辑。如果验证不通过，可以抛出相应的错误，否则可以继续处理上传的文件。</p>\n<h2 id=\"使用-ParseFilePipe-管道验证的示例\"><a href=\"#使用-ParseFilePipe-管道验证的示例\" class=\"headerlink\" title=\"使用 ParseFilePipe 管道验证的示例\"></a>使用 ParseFilePipe 管道验证的示例</h2><p>如果你想使用管道进行文件验证，可以使用 NestJS 提供的 <code>ParseFilePipe</code> 管道，它可以帮助你验证文件的大小和类型。以下是一个示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Controller, Post, UploadedFile, UseInterceptors &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\nimport &#123; ParseFilePipe &#125; from &#39;nestjs-form-data&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  &#x2F;&#x2F; async uploadFile(\n  &#x2F;&#x2F;   @UploadedFile(new ParseFilePipe(&#123; maxSize: 1024 * 1024, allowedTypes: [&#39;image&#x2F;jpeg&#39;, &#39;image&#x2F;png&#39;] &#125;)) file: Express.Multer.File\n  &#x2F;&#x2F; ) &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F; 处理上传的文件\n  &#x2F;&#x2F; &#125;\n  &#x2F;&#x2F; 这是查看源码后，修改的代码，上面错误代码是chatGPT的代码\n  async uploadFile(\n    @UploadedFile(\n      new ParseFilePipe(&#123;\n        validators: [new MaxFileSizeValidator(&#123; maxSize: 1000 &#125;), new FileTypeValidator(&#123; fileType: &#39;image&#x2F;jpeg&#39; &#125;)],\n      &#125;)\n    )\n    file: Express.Multer.File\n  ) &#123;\n    &#x2F;&#x2F; 处理上传的文件\n  &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们在 <code>@UploadedFile()</code> 装饰器中使用 <code>ParseFilePipe</code> 管道，并传入一个配置对象，指定文件的最大大小和允许的文件类型。如果文件不满足配置的要求，<code>ParseFilePipe</code> 管道会抛出相应的验证错误。你可以根据自己的需求修改配置对象的值。</p>\n<p>使用 <code>ParseFilePipe</code> 管道可以简化文件验证的代码，将验证逻辑从控制器方法中分离出来，使代码更加清晰和可维护。</p>\n<h2 id=\"Nestjs-ParseFilePipe-实现原理\"><a href=\"#Nestjs-ParseFilePipe-实现原理\" class=\"headerlink\" title=\"Nestjs ParseFilePipe 实现原理\"></a>Nestjs ParseFilePipe 实现原理</h2><p><code>ParseFilePipe</code> 是 NestJS 中用于处理文件上传的管道之一。它的实现原理涉及以下几个方面：</p>\n<ol>\n<li><p><strong>多部分表单数据解析：</strong> 当客户端发送一个多部分表单数据请求时，<code>ParseFilePipe</code> 首先会解析请求体，提取出其中的文件数据和其他表单字段数据。</p>\n</li>\n<li><p><strong>文件存储和处理：</strong> <code>ParseFilePipe</code> 会将解析出的文件数据保存到指定的位置，可以是本地磁盘、云存储等。它可能会生成一个唯一的文件名，并将文件相关信息（如文件名、文件类型、文件大小等）与表单字段数据一起返回。</p>\n</li>\n<li><p><strong>验证文件属性：</strong> 在解析文件数据后，<code>ParseFilePipe</code> 会对文件进行验证，例如验证文件大小、文件类型等。如果文件不符合要求，管道可能会抛出验证错误。</p>\n</li>\n<li><p><strong>错误处理：</strong> 如果在解析过程中发生任何错误，<code>ParseFilePipe</code> 会捕获并抛出相应的异常，该异常将被全局异常过滤器捕获并进行处理。</p>\n</li>\n</ol>\n<p>需要注意的是，具体的实现细节可能会根据 NestJS 版本和相关的插件或库而有所不同。你可以查阅 NestJS 的官方文档或相关的代码库来了解更多关于 <code>ParseFilePipe</code> 的实现原理和具体用法。</p>\n<h2 id=\"ParseFilePipe-源码\"><a href=\"#ParseFilePipe-源码\" class=\"headerlink\" title=\"ParseFilePipe 源码\"></a>ParseFilePipe 源码</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Injectable, Optional &#125; from &#39;..&#x2F;..&#x2F;decorators&#x2F;core&#39;;\nimport &#123; HttpStatus &#125; from &#39;..&#x2F;..&#x2F;enums&#39;;\nimport &#123; PipeTransform &#125; from &#39;..&#x2F;..&#x2F;interfaces&#x2F;features&#x2F;pipe-transform.interface&#39;;\nimport &#123; HttpErrorByCode &#125; from &#39;..&#x2F;..&#x2F;utils&#x2F;http-error-by-code.util&#39;;\nimport &#123; isEmpty, isObject, isUndefined &#125; from &#39;..&#x2F;..&#x2F;utils&#x2F;shared.utils&#39;;\nimport &#123; FileValidator &#125; from &#39;.&#x2F;file-validator.interface&#39;;\nimport &#123; ParseFileOptions &#125; from &#39;.&#x2F;parse-file-options.interface&#39;;\n\n&#x2F;**\n * Defines the built-in ParseFile Pipe. This pipe can be used to validate incoming files\n * with &#96;@UploadedFile()&#96; decorator. You can use either other specific built-in validators\n * or provide one of your own, simply implementing it through FileValidator interface\n * and adding it to ParseFilePipe&#39;s constructor.\n *\n * @see [Built-in Pipes](https:&#x2F;&#x2F;docs.nestjs.com&#x2F;pipes#built-in-pipes)\n *\n * @publicApi\n *&#x2F;\n@Injectable()\nexport class ParseFilePipe implements PipeTransform&lt;any&gt; &#123;\n  protected exceptionFactory: (error: string) &#x3D;&gt; any;\n  private readonly validators: FileValidator[];\n  private readonly fileIsRequired: boolean;\n\n  constructor(@Optional() options: ParseFileOptions &#x3D; &#123;&#125;) &#123;\n    const &#123; exceptionFactory, errorHttpStatusCode &#x3D; HttpStatus.BAD_REQUEST, validators &#x3D; [], fileIsRequired &#125; &#x3D; options;\n    &#x2F;&#x2F; 如果使用者提供了 异常工厂使用，否则使用默认\n    this.exceptionFactory &#x3D; exceptionFactory || ((error) &#x3D;&gt; new HttpErrorByCode[errorHttpStatusCode](error));\n\n    this.validators &#x3D; validators;\n    this.fileIsRequired &#x3D; fileIsRequired ?? true;\n  &#125;\n\n  async transform(value: any): Promise&lt;any&gt; &#123;\n    const areThereAnyFilesIn &#x3D; this.thereAreNoFilesIn(value);\n\n    if (areThereAnyFilesIn &amp;&amp; this.fileIsRequired) &#123;\n      throw this.exceptionFactory(&#39;File is required&#39;);\n    &#125;\n    if (!areThereAnyFilesIn &amp;&amp; this.validators.length) &#123;\n      await this.validateFilesOrFile(value);\n    &#125;\n\n    return value;\n  &#125;\n  &#x2F;&#x2F; 校验文件\n  private async validateFilesOrFile(value: any): Promise&lt;void&gt; &#123;\n    if (Array.isArray(value)) &#123;\n      await Promise.all(value.map((f) &#x3D;&gt; this.validate(f)));\n    &#125; else &#123;\n      await this.validate(value);\n    &#125;\n  &#125;\n\n  private thereAreNoFilesIn(value: any): boolean &#123;\n    const isEmptyArray &#x3D; Array.isArray(value) &amp;&amp; isEmpty(value);\n    const isEmptyObject &#x3D; isObject(value) &amp;&amp; isEmpty(Object.keys(value));\n    return isUndefined(value) || isEmptyArray || isEmptyObject;\n  &#125;\n  &#x2F;&#x2F; 对校验器一个一个进行校验\n  protected async validate(file: any): Promise&lt;any&gt; &#123;\n    for (const validator of this.validators) &#123;\n      await this.validateOrThrow(file, validator);\n    &#125;\n    return file;\n  &#125;\n  &#x2F;&#x2F; 无效抛出异常\n  private async validateOrThrow(file: any, validator: FileValidator) &#123;\n    const isValid &#x3D; await validator.isValid(file);\n\n    if (!isValid) &#123;\n      const errorMessage &#x3D; validator.buildErrorMessage(file);\n      throw this.exceptionFactory(errorMessage);\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * @returns list of validators used in this pipe.\n   *&#x2F;\n  getValidators() &#123;\n    return this.validators;\n  &#125;\n&#125;</code></pre>\n\n<p>这是 NestJS 中 <code>ParseFilePipe</code> 的源代码。以下是对代码的解读：</p>\n<ul>\n<li><code>ParseFilePipe</code> 是一个可注入的管道（PipeTransform）类，用于验证传入的文件。</li>\n<li>通过构造函数接收 <code>ParseFileOptions</code> 作为可选参数，可以配置异常工厂、错误的 HTTP 状态码、文件验证器等。</li>\n<li><code>transform</code> 方法用于转换和验证传入的值（文件）。首先，它检查是否有文件存在，如果要求文件必须存在但实际不存在，则抛出异常。接着，如果存在文件，并且定义了文件验证器，则对文件进行验证。</li>\n<li><code>validateFilesOrFile</code> 方法用于验证单个文件或文件数组，根据情况调用 <code>validate</code> 方法。</li>\n<li><code>thereAreNoFilesIn</code> 方法用于判断传入的值是否为空，如果是空值，则认为没有文件。</li>\n<li><code>validate</code> 方法用于遍历所有的文件验证器，并验证文件是否有效，如果不符合验证规则，则抛出异常。</li>\n<li><code>validateOrThrow</code> 方法用于执行单个文件的验证操作，并根据验证结果决定是否抛出异常。</li>\n<li><code>getValidators</code> 方法用于获取当前管道中使用的所有文件验证器。</li>\n</ul>\n<p>总体而言，<code>ParseFilePipe</code> 是一个用于验证文件的管道，可以根据配置的选项和验证器对传入的文件进行验证，并在验证不通过时抛出异常。它提供了灵活的配置和扩展选项，使开发者可以自定义文件验证规则。</p>\n<h2 id=\"chatGPT-小插曲\"><a href=\"#chatGPT-小插曲\" class=\"headerlink\" title=\"chatGPT 小插曲\"></a>chatGPT 小插曲</h2><details class=\"custom-details\">\n<summary>Details</summary>\n<p><strong>new ParseFilePipe({ maxSize: 1024 * 1024, allowedTypes: [‘image&#x2F;jpeg’, ‘image&#x2F;png’] }) 看上去不符合 ParseFilePipe 构造函数的入参</strong></p>\n<p>您是正确的，我对 <code>ParseFilePipe</code> 的构造函数入参进行了错误的解释。我对此表示歉意。</p>\n<p>在实际的源代码中，<code>ParseFilePipe</code> 的构造函数入参应为一个对象，该对象具有以下可选属性：</p>\n<ul>\n<li><code>exceptionFactory</code>: 一个用于创建异常对象的工厂函数。</li>\n<li><code>errorHttpStatusCode</code>: 错误的 HTTP 状态码，默认为 <code>HttpStatus.BAD_REQUEST</code>。</li>\n<li><code>validators</code>: 一个文件验证器的数组。</li>\n<li><code>fileIsRequired</code>: 一个布尔值，指示文件是否是必需的，默认为 <code>true</code>。</li>\n</ul>\n<p>因此，正确的使用方式应该是：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">new ParseFilePipe(&#123;\n  exceptionFactory: (error) &#x3D;&gt; new MyCustomException(error),\n  errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY,\n  validators: [new MyCustomFileValidator()],\n  fileIsRequired: false,\n&#125;);</code></pre>\n\n<p>对于 <code>maxSize</code> 和 <code>allowedTypes</code> 这样的配置，它们不是 <code>ParseFilePipe</code> 自带的选项，您可能需要自定义文件验证器来实现这些验证逻辑。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">上述代码写错了，应该写成 validators: [\n      new MaxFileSizeValidator(&#123; maxSize: 1000 &#125;),\n      new FileTypeValidator(&#123; fileType: &#39;image&#x2F;jpeg&#39; &#125;),\n    ],</code></pre>\n\n<p>非常抱歉，我之前的回答有误。根据您提供的代码，确实可以通过将 <code>MaxFileSizeValidator</code> 和 <code>FileTypeValidator</code> 实例添加到 <code>validators</code> 数组中来配置文件大小和文件类型的验证。这样，<code>ParseFilePipe</code> 的构造函数将如下所示：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">new ParseFilePipe(&#123;\n  validators: [new MaxFileSizeValidator(&#123; maxSize: 1000 &#125;), new FileTypeValidator(&#123; fileType: &#39;image&#x2F;jpeg&#39; &#125;)],\n&#125;);</code></pre>\n\n<p>这将创建一个 <code>ParseFilePipe</code> 实例，并使用 <code>MaxFileSizeValidator</code> 验证文件大小（最大大小为 1000 字节）以及使用 <code>FileTypeValidator</code> 验证文件类型（仅允许 JPEG 图像）。</p>\n\n</details>\n<h2 id=\"源码中-transform-方法什么时候被调用，被谁调用的\"><a href=\"#源码中-transform-方法什么时候被调用，被谁调用的\" class=\"headerlink\" title=\"源码中 transform 方法什么时候被调用，被谁调用的\"></a>源码中 transform 方法什么时候被调用，被谁调用的</h2><p><code>transform</code> 方法是 <code>PipeTransform</code> 接口的一个方法，用于转换输入的值。在 <code>ParseFilePipe</code> 中，它被用作文件验证和转换的主要逻辑。</p>\n<p><code>transform</code> 方法在管道被应用时被调用，通常是在控制器中处理请求时。当使用 <code>@UsePipes()</code> 装饰器将管道应用到一个特定的处理程序方法或控制器类上时，NestJS 会自动调用管道的 <code>transform</code> 方法。</p>\n<p>在 <code>ParseFilePipe</code> 中，<code>transform</code> 方法首先检查输入的值是否包含文件，如果文件为必需且不存在，则抛出异常。然后，它会根据配置的验证器对文件进行验证，如果文件未通过验证，则抛出相应的异常。最后，如果文件通过了验证，它会返回原始的文件值。</p>\n<p>因此，<code>transform</code> 方法在请求到达控制器之前被调用，它可以进行文件验证和转换，确保传入的文件满足指定的条件。</p>\n<h2 id=\"MaxFileSizeValidator-源码\"><a href=\"#MaxFileSizeValidator-源码\" class=\"headerlink\" title=\"MaxFileSizeValidator 源码\"></a>MaxFileSizeValidator 源码</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; FileValidator &#125; from &#39;.&#x2F;file-validator.interface&#39;;\n\nexport type MaxFileSizeValidatorOptions &#x3D; &#123;\n  maxSize: number;\n&#125;;\n\n&#x2F;**\n * Defines the built-in MaxSize File Validator\n *\n * @see [File Validators](https:&#x2F;&#x2F;docs.nestjs.com&#x2F;techniques&#x2F;file-upload#file-validation)\n *\n * @publicApi\n *&#x2F;\nexport class MaxFileSizeValidator extends FileValidator&lt;MaxFileSizeValidatorOptions&gt; &#123;\n  buildErrorMessage(): string &#123;\n    return &#96;Validation failed (expected size is less than $&#123;this.validationOptions.maxSize&#125;)&#96;;\n  &#125;\n\n  public isValid(file: any): boolean &#123;\n    if (!this.validationOptions) &#123;\n      return true;\n    &#125;\n\n    return file.size &lt; this.validationOptions.maxSize;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; packages&#x2F;common&#x2F;pipes&#x2F;file&#x2F;file-validator.interface.ts\n\n&#x2F;**\n * Interface describing FileValidators, which can be added to a ParseFilePipe\n *\n * @see &#123;ParseFilePipe&#125;\n * @publicApi\n *&#x2F;\nexport abstract class FileValidator&lt;TValidationOptions &#x3D; Record&lt;string, any&gt;&gt; &#123;\n  constructor(protected readonly validationOptions: TValidationOptions) &#123;&#125;\n\n  &#x2F;**\n   * Indicates if this file should be considered valid, according to the options passed in the constructor.\n   * @param file the file from the request object\n   *&#x2F;\n  abstract isValid(file?: any): boolean | Promise&lt;boolean&gt;;\n\n  &#x2F;**\n   * Builds an error message in case the validation fails.\n   * @param file the file from the request object\n   *&#x2F;\n  abstract buildErrorMessage(file: any): string;\n&#125;</code></pre>\n\n<h2 id=\"在继承抽象类的时候，需不需要实现-constructor-方法？\"><a href=\"#在继承抽象类的时候，需不需要实现-constructor-方法？\" class=\"headerlink\" title=\"在继承抽象类的时候，需不需要实现 constructor 方法？\"></a>在继承抽象类的时候，需不需要实现 constructor 方法？</h2><p>在继承抽象类时，您不必实现构造函数。当子类继承抽象类时，它会继承父类的构造函数。如果子类自己没有显式声明构造函数，那么它将使用父类的构造函数。</p>\n<p>如果您需要在子类中添加额外的构造逻辑或初始化属性，您可以在子类中声明自己的构造函数，并使用 <code>super()</code> 调用父类的构造函数，以便继承父类的行为。例如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export abstract class BaseClass &#123;\n  protected constructor(public readonly name: string) &#123;\n    &#x2F;&#x2F; 父类的构造函数逻辑\n  &#125;\n\n  abstract someMethod(): void;\n&#125;\n\nexport class DerivedClass extends BaseClass &#123;\n  constructor(name: string, public readonly age: number) &#123;\n    super(name); &#x2F;&#x2F; 调用父类的构造函数\n    &#x2F;&#x2F; 子类的构造逻辑\n  &#125;\n\n  someMethod(): void &#123;\n    &#x2F;&#x2F; 实现抽象方法\n  &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，<code>DerivedClass</code> 继承自 <code>BaseClass</code> 抽象类，并实现了抽象方法 <code>someMethod</code>。它在自己的构造函数中添加了 <code>age</code> 属性，并使用 <code>super(name)</code> 调用了父类的构造函数来初始化 <code>name</code> 属性。</p>\n<p>总结来说，您可以选择是否在子类中声明构造函数，如果声明了，则需要使用 <code>super()</code> 调用父类的构造函数来继承父类的行为。</p>\n<h2 id=\"在继承抽象类的时候，哪些方法必须实现？\"><a href=\"#在继承抽象类的时候，哪些方法必须实现？\" class=\"headerlink\" title=\"在继承抽象类的时候，哪些方法必须实现？\"></a>在继承抽象类的时候，哪些方法必须实现？</h2><p>当一个类继承自一个抽象类时，它必须实现抽象类中定义的所有抽象方法。抽象方法是在抽象类中声明但没有提供具体实现的方法。子类必须提供这些抽象方法的具体实现。</p>\n<p>如果子类没有实现抽象类中的所有抽象方法，那么该子类本身也必须声明为抽象类。换句话说，<strong>一个非抽象的子类继承抽象类时，必须实现所有抽象方法</strong>。</p>\n<p>下面是一个示例，展示了一个抽象类和子类之间的继承关系：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">abstract class AbstractClass &#123;\n  abstract abstractMethod(): void;\n\n  normalMethod(): void &#123;\n    &#x2F;&#x2F; 普通方法的具体实现\n  &#125;\n&#125;\n\nclass ConcreteClass extends AbstractClass &#123;\n  abstractMethod(): void &#123;\n    &#x2F;&#x2F; 抽象方法的具体实现\n  &#125;\n\n  &#x2F;&#x2F; 可选：可以在子类中添加其他方法或属性\n&#125;</code></pre>\n\n<p>在上述示例中，<code>AbstractClass</code> 是一个抽象类，它声明了一个抽象方法 <code>abstractMethod</code> 和一个普通方法 <code>normalMethod</code>。<code>ConcreteClass</code> 继承自 <code>AbstractClass</code>，并提供了对抽象方法 <code>abstractMethod</code> 的具体实现。</p>\n<p>总结来说，子类必须实现抽象类中定义的所有抽象方法，否则子类自身必须声明为抽象类。</p>\n<h2 id=\"其他语言也是-“一个非抽象的子类继承抽象类时，必须实现所有抽象方法”？\"><a href=\"#其他语言也是-“一个非抽象的子类继承抽象类时，必须实现所有抽象方法”？\" class=\"headerlink\" title=\"其他语言也是 “一个非抽象的子类继承抽象类时，必须实现所有抽象方法”？\"></a>其他语言也是 “一个非抽象的子类继承抽象类时，必须实现所有抽象方法”？</h2><p>不是所有的编程语言都强制要求非抽象子类实现抽象类中的所有抽象方法。这样的要求是由具体的编程语言和其对抽象类和接口的定义方式而定。</p>\n<p>例如，在 Java 中，如果一个类继承自一个抽象类，它必须实现所有抽象方法，否则它本身也必须声明为抽象类。这是 Java 语言的要求。</p>\n<p>然而，在其他编程语言中，如<strong>TypeScript 和 C#，子类可以选择性地实现抽象类中的抽象方法。这意味着子类可以是非抽象类，即使它没有实现所有抽象方法</strong>。<strong>在这种情况下，该子类仍然被视为抽象类，不能被实例化，只能被其他类继承并实现剩余的抽象方法</strong>。</p>\n<p>所以，是否要求非抽象子类实现所有抽象方法取决于具体的编程语言和其对抽象类和接口的规定。需要查阅特定编程语言的文档或规范以了解其要求。</p>\n<h1 id=\"NestJS-数据库\"><a href=\"#NestJS-数据库\" class=\"headerlink\" title=\"NestJS 数据库\"></a>NestJS 数据库</h1><h2 id=\"NestJS-Typeorm\"><a href=\"#NestJS-Typeorm\" class=\"headerlink\" title=\"NestJS Typeorm\"></a>NestJS Typeorm</h2><p>NestJS 是一个基于 TypeScript 的开发框架，而 TypeORM 是一个流行的 TypeScript&#x2F;JavaScript 的对象关系映射（ORM）库。TypeORM 提供了与数据库交互的功能，可以轻松地在 NestJS 应用程序中集成和使用。</p>\n<p>NestJS 和 TypeORM 的结合使用可以简化数据库操作和管理，提供强大的数据持久化能力。下面是一些使用 NestJS 和 TypeORM 的示例：</p>\n<ol>\n<li><p>安装 TypeORM：通过运行 <code>npm install typeorm</code> 或 <code>yarn add typeorm</code> 命令来安装 TypeORM。</p>\n</li>\n<li><p>创建实体（Entity）：在 TypeORM 中，实体是映射到数据库表的对象。使用装饰器（如 <code>@Entity</code>、<code>@Column</code>）定义实体类，并指定其属性和关联关系。</p>\n</li>\n<li><p>创建存储库（Repository）：存储库是用于执行数据库操作的对象。通过继承 <code>Repository</code> 类来创建自定义存储库，并使用装饰器（如 <code>@EntityRepository</code>）将其与实体相关联。</p>\n</li>\n<li><p>配置数据库连接：在 NestJS 中，可以在 <code>app.module.ts</code> 文件中使用 <code>TypeOrmModule.forRoot()</code> 方法配置数据库连接，包括数据库类型、主机、端口、用户名、密码等。</p>\n</li>\n<li><p>使用存储库进行数据库操作：在服务或控制器中，可以注入存储库并使用其方法执行数据库操作，如保存实体、查询数据、更新数据等。</p>\n</li>\n</ol>\n<p>通过结合 NestJS 和 TypeORM，可以轻松地实现数据持久化和数据库操作，从而构建可靠的后端应用程序。注意，上述示例只是简单介绍了使用 TypeORM 的一些基本步骤，实际使用时可能还需要配置其他参数和选项，具体操作取决于应用程序的需求和数据库的配置。</p>\n<h2 id=\"NestJS-连接-Typeorm-有哪些方式？\"><a href=\"#NestJS-连接-Typeorm-有哪些方式？\" class=\"headerlink\" title=\"NestJS 连接 Typeorm 有哪些方式？\"></a>NestJS 连接 Typeorm 有哪些方式？</h2><p>在 NestJS 中连接 TypeORM，有以下几种方式：</p>\n<ol>\n<li><p>使用 <code>TypeOrmModule.forRoot()</code> 方法：在 NestJS 的根模块（通常是 <code>app.module.ts</code>）中使用 <code>TypeOrmModule.forRoot()</code> 方法配置数据库连接。这种方式适用于单一的数据库连接。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; TypeOrmModule &#125; from &#39;@nestjs&#x2F;typeorm&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\nimport &#123; AppService &#125; from &#39;.&#x2F;app.service&#39;;\n\n@Module(&#123;\n  imports: [\n    TypeOrmModule.forRoot(&#123;\n      &#x2F;&#x2F; 数据库连接配置\n      type: &#39;mysql&#39;,\n      host: &#39;localhost&#39;,\n      port: 3306,\n      username: &#39;root&#39;,\n      password: &#39;password&#39;,\n      database: &#39;mydb&#39;,\n      entities: [__dirname + &#39;&#x2F;**&#x2F;*.entity&#123;.ts,.js&#125;&#39;],\n      synchronize: true,\n    &#125;),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n&#125;)\nexport class AppModule &#123;&#125;</code></pre>\n</li>\n<li><p>使用 <code>TypeOrmModule.forRootAsync()</code> 方法：如果需要动态配置数据库连接，例如从配置文件或环境变量中获取连接参数，可以使用 <code>TypeOrmModule.forRootAsync()</code> 方法。这种方式可以使用异步配置提供程序，如 <code>useFactory</code>、<code>useClass</code> 或 <code>useExisting</code>。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; TypeOrmModule &#125; from &#39;@nestjs&#x2F;typeorm&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\nimport &#123; AppService &#125; from &#39;.&#x2F;app.service&#39;;\nimport &#123; TypeOrmConfigService &#125; from &#39;.&#x2F;typeorm-config.service&#39;;\n\n@Module(&#123;\n  imports: [\n    TypeOrmModule.forRootAsync(&#123;\n      useClass: TypeOrmConfigService,\n    &#125;),\n  ],\n  controllers: [AppController],\n  providers: [AppService, TypeOrmConfigService],\n&#125;)\nexport class AppModule &#123;&#125;</code></pre>\n\n<p>其中，<code>TypeOrmConfigService</code> 是一个自定义的配置提供程序，用于动态获取数据库连接参数。</p>\n</li>\n<li><p>使用 <code>TypeOrmModule.forFeature()</code> 方法：在需要访问数据库的模块中，可以使用 <code>TypeOrmModule.forFeature()</code> 方法导入实体和存储库。这种方式适用于在特定模块中使用单独的数据库连接。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; TypeOrmModule &#125; from &#39;@nestjs&#x2F;typeorm&#39;;\nimport &#123; UserController &#125; from &#39;.&#x2F;user.controller&#39;;\nimport &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\nimport &#123; UserRepository &#125; from &#39;.&#x2F;user.repository&#39;;\n\n@Module(&#123;\n  imports: [TypeOrmModule.forFeature([UserRepository])],\n  controllers: [UserController],\n  providers: [UserService],\n&#125;)\nexport class UserModule &#123;&#125;</code></pre>\n\n<p>在上述示例中，<code>UserRepository</code> 是一个自定义的存储库，通过 <code>TypeOrmModule.forFeature()</code> 方法将其导入到 <code>UserModule</code> 模块中。</p>\n</li>\n</ol>\n<p>这些方式可以根据具体的需求和项目架构选择使用。第一种方式是最简单直接的方式，适用于单一的数据库连接；第二种方式适用于动态配置数据库连接参数；第三种方式适用于在特定模块中使用单独的数据库连接。根据实际情况选择适合的方式来连接 TypeORM</p>\n<h3 id=\"nestjs-x2F-typeorm-TypeOrmModule-源码\"><a href=\"#nestjs-x2F-typeorm-TypeOrmModule-源码\" class=\"headerlink\" title=\"@nestjs&#x2F;typeorm TypeOrmModule 源码\"></a>@nestjs&#x2F;typeorm TypeOrmModule 源码</h3><p><a href=\"https://github.com/nestjs/typeorm/blob/96bc97c83bd08d26b6b9d8f8c15eb9cc3ab5a271/lib/typeorm.module.ts#LL13C1-L44C2\" target=\"_blank\" >TypeOrmModule</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@Module(&#123;&#125;)\nexport class TypeOrmModule &#123;\n  static forRoot(options?: TypeOrmModuleOptions): DynamicModule &#123;\n    return &#123;\n      module: TypeOrmModule,\n      imports: [TypeOrmCoreModule.forRoot(options)],\n    &#125;;\n  &#125;\n\n  static forFeature(\n    entities: EntityClassOrSchema[] &#x3D; [],\n    dataSource: DataSource | DataSourceOptions | string &#x3D; DEFAULT_DATA_SOURCE_NAME\n  ): DynamicModule &#123;\n    const providers &#x3D; createTypeOrmProviders(entities, dataSource);\n    EntitiesMetadataStorage.addEntitiesByDataSource(dataSource, [...entities]);\n    return &#123;\n      module: TypeOrmModule,\n      providers: providers,\n      exports: providers,\n    &#125;;\n  &#125;\n\n  static forRootAsync(options: TypeOrmModuleAsyncOptions): DynamicModule &#123;\n    return &#123;\n      module: TypeOrmModule,\n      imports: [TypeOrmCoreModule.forRootAsync(options)],\n    &#125;;\n  &#125;\n&#125;</code></pre>\n\n<p>只暴露了 3 个 API,chatGPT2021 有时候会给出 4 个方法，有个是不存在的</p>\n<p>注意：这 3 个方法是静态方法，由之前方法可知，<strong>静态方法作为工具方法使用</strong></p>\n<h3 id=\"TypeOrmModule-forRootAsync-与-useFactory、-useClass、-useExisting-什么关系-【可跳过】\"><a href=\"#TypeOrmModule-forRootAsync-与-useFactory、-useClass、-useExisting-什么关系-【可跳过】\" class=\"headerlink\" title=\"TypeOrmModule.forRootAsync() 与 useFactory、 useClass、 useExisting 什么关系 【可跳过】\"></a>TypeOrmModule.forRootAsync() 与 useFactory、 useClass、 useExisting 什么关系 【可跳过】</h3><p>在 NestJS 中，<code>TypeOrmModule.forRootAsync()</code> 是用于异步配置 TypeORM 模块的方法。它允许你根据需要动态地提供 TypeORM 模块的配置。</p>\n<p><code>forRootAsync()</code> 方法接受一个对象作为参数，该对象包含一个或多个属性来定义异步配置的选项。其中，三个常用的属性是 <code>useFactory</code>、<code>useClass</code> 和 <code>useExisting</code>。</p>\n<ul>\n<li><p><code>useFactory</code> 属性用于指定一个工厂函数，该函数返回一个配置对象。工厂函数可以是异步的，它可以执行任何异步操作，例如从配置文件加载配置、请求远程配置等。通过 <code>useFactory</code>，你可以根据自己的需求动态地生成 TypeORM 模块的配置。</p>\n</li>\n<li><p><code>useClass</code> 属性用于指定一个提供器类，该类实现了 <code>TypeOrmOptionsFactory</code> 接口。这个类可以注入其他依赖，执行复杂的初始化逻辑，并返回配置对象。通过 <code>useClass</code>，你可以将配置的逻辑封装在一个可重用的类中。</p>\n</li>\n<li><p><code>useExisting</code> 属性用于指定一个已经注册的提供器的标记，该提供器实现了 <code>TypeOrmOptionsFactory</code> 接口。通过 <code>useExisting</code>，你可以复用现有的提供器，避免重复定义相同的配置逻辑。</p>\n</li>\n</ul>\n<p>这些属性之间的关系是，你可以根据不同的需求选择其中一个属性来定义异步配置的方式。无论是使用 <code>useFactory</code>、<code>useClass</code> 还是 <code>useExisting</code>，最终都要返回一个包含 TypeORM 配置的对象，供 <code>forRootAsync()</code> 方法使用。</p>\n<p>通过这种方式，你可以根据不同的场景和需求，动态地生成和提供 TypeORM 模块的配置，以适应不同的数据库连接、环境变量等情况。</p>\n<h2 id=\"useFactory、-useClass、-useExisting-有什么区别-【可跳过】\"><a href=\"#useFactory、-useClass、-useExisting-有什么区别-【可跳过】\" class=\"headerlink\" title=\"useFactory、 useClass、 useExisting 有什么区别 【可跳过】\"></a>useFactory、 useClass、 useExisting 有什么区别 【可跳过】</h2><p>在 NestJS 中，<code>useFactory</code>、<code>useClass</code> 和 <code>useExisting</code> 是用于异步配置提供器的属性。</p>\n<ol>\n<li><p><code>useFactory</code>: 使用一个工厂函数来创建提供器的实例。工厂函数可以是同步的或异步的，并且可以执行任意的逻辑来生成提供器的实例。工厂函数可以接受依赖注入，以便在创建实例时使用其他依赖项。该工厂函数必须返回一个实例化的对象作为提供器的值。</p>\n</li>\n<li><p><code>useClass</code>: 使用一个类来创建提供器的实例。该类必须实现相应的接口或装饰器。NestJS 将会自动实例化该类，并将其用作提供器的值。类可以接受依赖注入，并在其构造函数中使用其他依赖项。使用 <code>useClass</code> 属性时，NestJS 将会自动解析类的依赖项并注入它们。</p>\n</li>\n<li><p><code>useExisting</code>: 复用现有的提供器。使用该属性时，你需要提供一个已经在 NestJS 容器中注册的提供器的标记。NestJS 将会从容器中解析该提供器并将其用作提供器的值。这使得你可以复用已经定义的提供器，避免重复定义相同的配置逻辑。</p>\n</li>\n</ol>\n<p>这些属性的区别在于它们用于不同的创建提供器的方式。<code>useFactory</code> 允许你使用自定义的工厂函数来创建提供器实例，<code>useClass</code> 则使用一个类来创建提供器实例，而 <code>useExisting</code> 则复用现有的提供器。</p>\n<p>通过这些属性，你可以选择最适合你需求的方式来定义提供器的创建逻辑。无论是使用工厂函数、类还是已有的提供器，最终都会创建一个实例，并将其用作提供器的值。</p>\n<h2 id=\"这三个各自的使用场景是什么？【可跳过】\"><a href=\"#这三个各自的使用场景是什么？【可跳过】\" class=\"headerlink\" title=\"这三个各自的使用场景是什么？【可跳过】\"></a>这三个各自的使用场景是什么？【可跳过】</h2><p>以下是这三个属性的常见使用场景：</p>\n<ol>\n<li><code>useFactory</code>: 使用工厂函数创建提供器的实例，适用于需要动态配置或自定义实例化逻辑的情况。例如，当你需要根据一些条件决定提供器的配置参数时，可以使用工厂函数来创建实例，并根据条件进行逻辑处理。工厂函数可以包含异步操作，比如从远程服务获取配置参数。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">TypeOrmModule.forRootAsync(&#123;\n  useFactory: () &#x3D;&gt; &#123;\n    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;\n      return &#123;\n        &#x2F;&#x2F; 生产环境的数据库配置\n      &#125;;\n    &#125; else &#123;\n      return &#123;\n        &#x2F;&#x2F; 开发环境的数据库配置\n      &#125;;\n    &#125;\n  &#125;,\n&#125;);</code></pre>\n\n<ol start=\"2\">\n<li><code>useClass</code>: 使用类创建提供器的实例，适用于简单的实例化场景。当你有一个类并且希望将其实例化并用作提供器时，可以使用 <code>useClass</code>。该类可以接受其他依赖项，并在其构造函数中使用它们。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">TypeOrmModule.forRootAsync(&#123;\n  useClass: TypeOrmConfigService,\n&#125;);</code></pre>\n\n<ol start=\"3\">\n<li><code>useExisting</code>: 复用现有的提供器实例，适用于复用已定义的提供器配置的情况。当你已经在 NestJS 容器中注册了一个提供器，并希望将其用作另一个提供器的值时，可以使用 <code>useExisting</code>。这样可以避免重复定义相同的配置逻辑。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">TypeOrmModule.forRootAsync(&#123;\n  useExisting: ConfigService,\n&#125;);</code></pre>\n\n<p>根据你的需求和场景，选择适合的属性来定义提供器的创建方式。使用工厂函数可以提供更高的灵活性和定制性，使用类可以更简单地创建实例，并且使用现有的提供器可以节省重复定义配置的工作。</p>\n<h2 id=\"这么理解：要使用类就用-useClass-，要使用工厂形式-就用-useFactory，-要使用提供器就用-useExisting？\"><a href=\"#这么理解：要使用类就用-useClass-，要使用工厂形式-就用-useFactory，-要使用提供器就用-useExisting？\" class=\"headerlink\" title=\"这么理解：要使用类就用 useClass ，要使用工厂形式 就用 useFactory， 要使用提供器就用 useExisting？\"></a>这么理解：要使用类就用 useClass ，要使用工厂形式 就用 useFactory， 要使用提供器就用 useExisting？</h2><p>基本上你的理解是正确的，这是一种常见的用法：</p>\n<ul>\n<li><p><code>useClass</code>: 当你有一个类并且希望将其实例化并用作提供器时，可以使用 <code>useClass</code>。这适用于简单的实例化场景。</p>\n</li>\n<li><p><code>useFactory</code>: 当你需要根据一些条件动态创建提供器实例时，可以使用 <code>useFactory</code>。工厂函数可以根据需要进行自定义逻辑，并返回提供器实例。这适用于需要更高灵活性和定制性的情况。</p>\n</li>\n<li><p><code>useExisting</code>: 当你已经在 NestJS 容器中注册了一个提供器，并希望将其用作另一个提供器的值时，可以使用 <code>useExisting</code>。这样可以避免重复定义相同的配置逻辑，直接复用现有的提供器实例。</p>\n</li>\n</ul>\n<p>这些属性的选择取决于你的需求和设计，根据场景选择合适的方式来创建和配置提供器。</p>\n<h2 id=\"如果-useFactory、-useClass、-useExisting-同时使用\"><a href=\"#如果-useFactory、-useClass、-useExisting-同时使用\" class=\"headerlink\" title=\"如果 useFactory、 useClass、 useExisting 同时使用\"></a>如果 useFactory、 useClass、 useExisting 同时使用</h2><p><code>useFactory</code>、<code>useClass</code>和<code>useExisting</code>是互斥的选项，不会同时使用。这些选项用于不同的场景和需求，根据具体情况选择其中一个。</p>\n<ul>\n<li>如果你想使用一个工厂函数来动态创建提供器实例，你应该使用<code>useFactory</code>。</li>\n<li>如果你想直接使用一个类的实例作为提供器，你应该使用<code>useClass</code>。</li>\n<li>如果你想复用现有的提供器实例作为另一个提供器的值，你应该使用<code>useExisting</code>。</li>\n</ul>\n<p>根据你的需求，选择合适的选项来配置提供器。不需要同时使用这三个选项。</p>\n<h2 id=\"为什么要给用户这么多选择，直接一个类不能覆盖所有场景吗？\"><a href=\"#为什么要给用户这么多选择，直接一个类不能覆盖所有场景吗？\" class=\"headerlink\" title=\"为什么要给用户这么多选择，直接一个类不能覆盖所有场景吗？\"></a>为什么要给用户这么多选择，直接一个类不能覆盖所有场景吗？</h2><p>给用户多种选择的目的是为了灵活性和可扩展性。不同的场景可能需要不同的配置方式，使用不同的选项可以满足不同的需求。</p>\n<ul>\n<li><p><code>useClass</code>允许你直接指定一个类作为提供器，这对于简单的情况很方便，但可能无法满足复杂的需求，比如需要在创建实例之前执行一些额外的逻辑或从外部获取配置参数。</p>\n</li>\n<li><p><code>useFactory</code>允许你定义一个工厂函数来动态创建提供器实例，这样你可以在函数内部执行一些自定义逻辑，根据需要传递参数，并返回一个实例化后的对象。这提供了更大的灵活性，可以满足复杂的需求。</p>\n</li>\n<li><p><code>useExisting</code>允许你复用现有的提供器实例作为另一个提供器的值。这在需要共享相同实例的情况下很有用，可以避免重复创建实例和共享状态的问题。</p>\n</li>\n</ul>\n<p>通过提供多种选择，NestJS 允许开发者根据具体需求选择最合适的方式，以实现灵活性、可维护性和可扩展性。这样可以更好地满足不同项目和场景的需求。</p>\n<h2 id=\"对于-entities-实体的书写\"><a href=\"#对于-entities-实体的书写\" class=\"headerlink\" title=\"对于 entities 实体的书写\"></a>对于 entities 实体的书写</h2><p><a href=\"https://typeorm.io/entities\" target=\"_blank\" >查看 typeorm 实体相关文档</a></p>\n","text":"开箱即用 开箱即用的应用框架就是一个已经预设好基本功能和样式的框架，可以帮助开发者快速地开发应用程序，不需要从零开始构建基础功能和样式。 通常，这类框架提供了一些预设的组件、工具、库、样式和模板等，也提供了文档、示例和编码规范等辅助开发的资源。 开箱即用的应用框架可以大大缩短应用...","link":"","photos":[],"count_time":{"symbolsCount":"75k","symbolsTime":"1:08"},"categories":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/categories/nodejs.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8\"><span class=\"toc-text\">开箱即用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94-Koa%E3%80%81Egg-%E5%92%8C-NestJS\"><span class=\"toc-text\">对比 Koa、Egg 和 NestJS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NestJS-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86\"><span class=\"toc-text\">NestJS 重要概念区分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nestjs-%E4%B8%8E-Spring-Boot\"><span class=\"toc-text\">Nestjs 与 Spring Boot</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">依赖注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nextjs-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-Injectable-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">nextjs 依赖注入 Injectable 是什么意思</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">依赖注入设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%85%A5%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9C%8B%E4%B8%8A%E5%8E%BB%E6%B2%A1%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">注入和实例化看上去没区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Module-%E7%9A%84-imports-%E5%92%8C-providers-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@Module 的 imports 和 providers 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%AF%BC%E5%85%A5%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8F%90%E4%BE%9B%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">不导入，直接提供不行吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Module-exports\"><span class=\"toc-text\">@Module exports</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E7%BB%8F%E8%BF%87%E8%BF%99%E4%B8%AA-UserModule-%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%94%A8-UserService-%E4%B8%8D%E8%A1%8C%E5%90%97\"><span class=\"toc-text\">不经过这个 UserModule ，直接用 UserService 不行吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AF%BC%E5%85%A5%E5%88%B0%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%B8%8D%E8%A1%8C%E5%90%97\"><span class=\"toc-text\">直接导入到其他模块不行吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B9%88%E7%90%86%E8%A7%A3-providers-%E5%92%8C-controllers-%E7%BB%84%E6%88%90%E4%BA%86-UserModule-%E5%85%B6%E4%BB%96-module-%E5%A6%82%E6%9E%9C%E6%83%B3%E7%94%A8-UserModule-%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E5%85%88%E8%A6%81%E5%86%8D-UserModule-%E5%AF%BC%E5%87%BA%EF%BC%8C%E7%84%B6%E5%90%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%EF%BC%8C%E6%8E%A5%E7%9D%80%E8%BF%9B%E8%A1%8C%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%98%AF%E8%BF%99%E6%A0%B7%E5%90%97\"><span class=\"toc-text\">这么理解 providers 和 controllers 组成了 UserModule,其他 module 如果想用 UserModule 的东西，先要再 UserModule 导出，然后其他模块导入，接着进行使用，是这样吗</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">异常过滤器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nestjs-%E5%BC%82%E5%B8%B8%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">nestjs 异常全局过滤器有几种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NestJS-%E4%B8%AD%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9A\"><span class=\"toc-text\">NestJS 中有两种方式来创建全局异常过滤器：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9A\"><span class=\"toc-text\">基于类的全局过滤器：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9A\"><span class=\"toc-text\">函数式全局过滤器：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%9C%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%E2%80%9D-%E5%92%8C-%E2%80%9C%E5%87%BD%E6%95%B0%E5%BC%8F%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%E2%80%9D-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">“基于类的全局过滤器” 和 “函数式全局过滤器” 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8-NestJS-%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B1%82%E7%BA%A7%E4%B8%8A%E7%BB%91%E5%AE%9A%E5%BC%82%E5%B8%B8%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%85%A8%E5%B1%80%E3%80%81%E6%A8%A1%E5%9D%97%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E3%80%82\"><span class=\"toc-text\">在 NestJS 中，可以在不同的层级上绑定异常过滤器，包括全局、模块、控制器和方法级别。</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%B1%82%E7%BA%A7%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">全局层级示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E5%B1%82%E7%BA%A7%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">模块层级示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%80%E4%B8%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%EF%BC%9A%EF%BC%88%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B1%82%E7%BA%A7%EF%BC%89\"><span class=\"toc-text\">绑定到一个控制器上：（控制器层级）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E4%B8%8A%EF%BC%9A%EF%BC%88%E6%96%B9%E6%B3%95%E5%B1%82%E7%BA%A7%EF%BC%89\"><span class=\"toc-text\">绑定到一个自定义路由上：（方法层级）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NestJS-%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">NestJS 中间件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">为什么要使用中间件？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%B1%9E%E4%BA%8E-23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F\"><span class=\"toc-text\">中间件属于 23 种设计模式中的哪种？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">为什么不是过滤器模式呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#axios-%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%9F%E6%98%AF%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">axios 的拦截器也是责任链模式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">中间件能做什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">中间件分类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NestJs-%E7%AE%A1%E9%81%93\"><span class=\"toc-text\">NestJs 管道</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">主要内容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nestjs-%E7%AE%A1%E9%81%93%E5%B1%9E%E4%BA%8E-23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%93%AA%E7%A7%8D\"><span class=\"toc-text\">nestjs 管道属于 23 种设计模式中的哪种</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%88%E5%8D%AB-x2F-%E6%8E%88%E6%9D%83-x2F-%E9%89%B4%E6%9D%83\"><span class=\"toc-text\">守卫&#x2F;授权&#x2F;鉴权</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%88%E5%8D%AB%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">守卫与中间件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%88%E5%8D%AB%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%AE%A1%E9%81%93%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8\"><span class=\"toc-text\">守卫与中间件、过滤器、管道、拦截器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%88%E5%8D%AB%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">守卫执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nestjs-%E4%B8%AD-%E2%80%9C%E5%AE%88%E5%8D%AB%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%86%E5%9C%A8%E4%BB%BB%E4%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8%E6%88%96%E7%AE%A1%E9%81%93-%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E2%80%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">nestjs 中 “守卫在所有中间件之后执行，但在任何拦截器或管道 之前执行”，为什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%8E%88%E6%9D%83%E7%9A%84%E5%AE%88%E5%8D%AB%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">身份验证的中间件与授权的守卫区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CASL\"><span class=\"toc-text\">CASL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CASL-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">CASL 是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CASL-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">CASL 如何使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-CASL-%E5%92%8C-React-%E7%9A%84%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">使用 CASL 和 React 的完整示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9C%8B%E4%B8%8A%E5%8E%BB%E5%B9%B6%E6%B2%A1%E6%9C%89%E6%AF%94-if-else-%E4%BC%98%E9%9B%85\"><span class=\"toc-text\">看上去并没有比 if else 优雅</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ability-can-%E5%92%8C-ability-notcan-%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E6%9C%89%E6%9D%83%E9%99%90\"><span class=\"toc-text\">ability.can 和 ability.notcan 用来判断是不是有权限</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#field-%E5%AD%97%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">field 字段有什么用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E-field-%E7%9A%84%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">关于 field 的完整示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E7%9C%8B%E5%88%B0-rules-%E7%9A%84%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%EF%BC%9F\"><span class=\"toc-text\">没看到 rules 的赋值操作？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rules-%E5%80%BC%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">rules 值是怎样的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rules-%E4%B8%AD%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">rules 中各个字段是什么意思</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CASL-%E6%98%AF-23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E7%9A%84%E5%93%AA%E7%A7%8D\"><span class=\"toc-text\">CASL 是 23 种设计模式 中的哪种</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CASL-%E4%B8%8D%E6%98%AF%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">CASL 不是策略模式吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Can-%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">Can 组件源码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9D%A5%E7%9C%8B%EF%BC%8CCASL-Can-%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E9%89%B4%E6%9D%83\"><span class=\"toc-text\">从源码来看，CASL Can 组件内部会自动进行鉴权</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ability-%E4%BB%8E%E5%93%AA%E9%87%8C%E4%BC%A0%E5%85%A5%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">ability 从哪里传入的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ability-%E7%9A%84%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">ability 的结果</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81-ability-can-%E5%92%8C-ability-cannot-%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">上述代码 ability.can 和 ability.cannot 的具体内容</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BE%80%E5%BE%80%E6%AF%94%E4%B8%8D%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9B%B4%E9%9A%BE%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">代码用设计模式往往比不用设计模式，更难理解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88AOP%EF%BC%89\"><span class=\"toc-text\">拦截器（AOP）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">切面编程中使用到哪些设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nestjs-%E4%B8%AD%E9%97%B4%E4%BB%B6%E3%80%81%E5%AE%88%E5%8D%AB%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%AE%A1%E9%81%93%E7%9C%8B%E4%B8%8A%E5%8E%BB%E9%83%BD%E6%98%AF%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">nestjs 中间件、守卫、过滤器、管道看上去都是切面编程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">过滤器和拦截器有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%80%9A%E5%B8%B8%E6%98%AF%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0-ExceptionFilter%E3%80%81Interceptor-%E6%88%96-PipeTransform-%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9A%E4%B9%89%EF%BC%8C%E8%80%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%88%99%E6%98%AF%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0-Interceptor-%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9A%E4%B9%89%EF%BC%8C-%E9%82%A3%E4%B9%88%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%A4%E4%B8%AA%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">过滤器通常是通过实现 ExceptionFilter、Interceptor 或 PipeTransform 接口来定义，而拦截器则是通过实现 Interceptor 接口来定义， 那么过滤器和拦截器两个之间有什么关系</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E7%89%88\"><span class=\"toc-text\">模版</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%A8%A1%E7%89%88%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">静态模版示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E6%A8%A1%E7%89%88%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">动态模版示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%89%94%E9%99%A4-x2F-%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">返回值剔除&#x2F;增加字段</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class-transformer-Transform-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">class-transformer @Transform 示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">版本控制</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">调度</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#nestjs-axios-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">nestjs axios 示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Observable-%E4%B8%8E-Promise-%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F\"><span class=\"toc-text\">Observable 与 Promise 是什么关系？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">多环境配置文件 示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#YAML-%E6%96%87%E4%BB%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">YAML 文件来实现多环境配置</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">压缩</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">文件上传</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">单文件上传</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">多文件上传</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DTO-%E9%AA%8C%E8%AF%81%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F-x2F-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">DTO 验证文件大小&#x2F;类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BD%BF%E7%94%A8-DTO-%EF%BC%8C%E6%97%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%AA%8C%E8%AF%81%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">不使用 DTO ，无设计模式验证的示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-ParseFilePipe-%E7%AE%A1%E9%81%93%E9%AA%8C%E8%AF%81%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">使用 ParseFilePipe 管道验证的示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nestjs-ParseFilePipe-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Nestjs ParseFilePipe 实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ParseFilePipe-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">ParseFilePipe 源码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#chatGPT-%E5%B0%8F%E6%8F%92%E6%9B%B2\"><span class=\"toc-text\">chatGPT 小插曲</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E4%B8%AD-transform-%E6%96%B9%E6%B3%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%8C%E8%A2%AB%E8%B0%81%E8%B0%83%E7%94%A8%E7%9A%84\"><span class=\"toc-text\">源码中 transform 方法什么时候被调用，被谁调用的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MaxFileSizeValidator-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">MaxFileSizeValidator 源码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0-constructor-%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">在继承抽象类的时候，需不需要实现 constructor 方法？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">在继承抽象类的时候，哪些方法必须实现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E4%B9%9F%E6%98%AF-%E2%80%9C%E4%B8%80%E4%B8%AA%E9%9D%9E%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E2%80%9D%EF%BC%9F\"><span class=\"toc-text\">其他语言也是 “一个非抽象的子类继承抽象类时，必须实现所有抽象方法”？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NestJS-%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">NestJS 数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NestJS-Typeorm\"><span class=\"toc-text\">NestJS Typeorm</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NestJS-%E8%BF%9E%E6%8E%A5-Typeorm-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">NestJS 连接 Typeorm 有哪些方式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#nestjs-x2F-typeorm-TypeOrmModule-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">@nestjs&#x2F;typeorm TypeOrmModule 源码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TypeOrmModule-forRootAsync-%E4%B8%8E-useFactory%E3%80%81-useClass%E3%80%81-useExisting-%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB-%E3%80%90%E5%8F%AF%E8%B7%B3%E8%BF%87%E3%80%91\"><span class=\"toc-text\">TypeOrmModule.forRootAsync() 与 useFactory、 useClass、 useExisting 什么关系 【可跳过】</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useFactory%E3%80%81-useClass%E3%80%81-useExisting-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E3%80%90%E5%8F%AF%E8%B7%B3%E8%BF%87%E3%80%91\"><span class=\"toc-text\">useFactory、 useClass、 useExisting 有什么区别 【可跳过】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B8%89%E4%B8%AA%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E3%80%90%E5%8F%AF%E8%B7%B3%E8%BF%87%E3%80%91\"><span class=\"toc-text\">这三个各自的使用场景是什么？【可跳过】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%B0%B1%E7%94%A8-useClass-%EF%BC%8C%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E5%BD%A2%E5%BC%8F-%E5%B0%B1%E7%94%A8-useFactory%EF%BC%8C-%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8F%90%E4%BE%9B%E5%99%A8%E5%B0%B1%E7%94%A8-useExisting%EF%BC%9F\"><span class=\"toc-text\">这么理解：要使用类就用 useClass ，要使用工厂形式 就用 useFactory， 要使用提供器就用 useExisting？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C-useFactory%E3%80%81-useClass%E3%80%81-useExisting-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">如果 useFactory、 useClass、 useExisting 同时使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%99%E7%94%A8%E6%88%B7%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%89%E6%8B%A9%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A6%86%E7%9B%96%E6%89%80%E6%9C%89%E5%9C%BA%E6%99%AF%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">为什么要给用户这么多选择，直接一个类不能覆盖所有场景吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%BA%8E-entities-%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B9%A6%E5%86%99\"><span class=\"toc-text\">对于 entities 实体的书写</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MAC应用级别快捷键定制","uid":"7f350638d22d70742cf8b0b4f449ced7","slug":"2023-05-10mac","date":"2023-05-10T03:33:13.000Z","updated":"2023-05-15T13:17:33.008Z","comments":true,"path":"api/articles/2023-05-10mac.json","keywords":null,"cover":null,"text":"参考链接Mac 实用技巧 - 为菜单命令添加快捷键 链接示例是备忘录添加快捷键，其他应用类似","link":"","photos":[],"count_time":{"symbolsCount":46,"symbolsTime":"1 mins."},"categories":[{"name":"Mac","slug":"Mac","count":2,"path":"api/categories/Mac.json"}],"tags":[{"name":"Mac","slug":"Mac","count":2,"path":"api/tags/Mac.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"虚拟列表（没想好怎么写）","uid":"7c8d110856dc8b871f4c54e1b5f1f295","slug":"2023-05-09vr-list","date":"2023-05-09T02:23:25.000Z","updated":"2023-05-15T13:17:33.008Z","comments":true,"path":"api/articles/2023-05-09vr-list.json","keywords":null,"cover":[],"text":"虚拟列表原理虚拟列表实现原理虚拟列表（Virtual List）是一种常见的前端性能优化技术，用于解决渲染大量数据时，DOM 元素过多导致页面卡顿的问题。虚拟列表通过只渲染当前可见区域的 DOM 元素，来减少页面渲染的负担，从而提高页面性能。 虚拟列表的实现原理一般分为以下几步：...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/tags/性能优化.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}