{"title":"React 源码解析收录","uid":"a6739a5e648fed592221272a951b5783","slug":"2022-10-10react-link","date":"2022-10-10T05:39:46.000Z","updated":"2023-03-09T15:11:24.965Z","comments":true,"path":"api/articles/2022-10-10react-link.json","keywords":null,"cover":[],"content":"<h2 id=\"收录链接-1\"><a href=\"#收录链接-1\" class=\"headerlink\" title=\"收录链接 1\"></a>收录链接 1</h2><ol>\n<li><a href=\"https://juejin.cn/post/7014775797596553230\" target=\"_blank\">React17 源码解析(开篇) —— 搭建 react 源码调试环境</a></li>\n<li><a href=\"https://juejin.cn/post/7015853155367780383\" target=\"_blank\">React17 源码解析(1) —— 源码目录及 react 架构</a></li>\n<li><a href=\"https://juejin.cn/post/7015855371847729166\" target=\"_blank\">React17 源码解析(2) —— jsx 转换及 React.createElement</a></li>\n<li><a href=\"https://juejin.cn/post/7016512949330116645\" target=\"_blank\">React17 源码解析(3) —— 深入理解 fiber</a></li>\n<li><a href=\"https://juejin.cn/post/7019254208830373902\" target=\"_blank\">React17 源码解析(4) —— 详解 render 阶段(scheduler 和 reconciler)</a></li>\n<li><a href=\"https://juejin.cn/post/7020595059095666724\" target=\"_blank\">React17 源码解析(5) —— 全面理解 diff 算法</a></li>\n<li><a href=\"https://juejin.cn/post/7022816775188250660\" target=\"_blank\">React17 源码解析(6) —— commit 阶段</a></li>\n<li><a href=\"https://juejin.cn/post/7023568411963686920\" target=\"_blank\">React17 源码解析(7) —— 一文搞懂 hooks 原理</a></li>\n<li><a href=\"https://juejin.cn/post/7030673003583111176\" target=\"_blank\">🚀 万字好文 —— 手把手教你实现史上功能最丰富的简易版 react</a></li>\n</ol>\n<p>从上面了解到：</p>\n<ol>\n<li>几种数据类型之间的关系<code>Fiber</code>、 <code>Effect</code>、 <code>Hook</code>、 <code>Update</code>、 <code>UpdateQueue</code></li>\n<li>“如何触发 React 调度更新”</li>\n<li>“diff 算法”的大概是什么</li>\n<li>“React Fiber 树如何被更新成 DOM 的”</li>\n</ol>\n<h2 id=\"收录链接-2\"><a href=\"#收录链接-2\" class=\"headerlink\" title=\"收录链接 2\"></a>收录链接 2</h2><p><strong>看完上面的文章，会有这个疑惑：</strong></p>\n<p>我们的代码是如何进入 React 调度流程的（例如：写了一个组件，这个组件如何变成 workInProgressFiber 的一部分）</p>\n<p><a href=\"https://juejin.cn/post/7016512949330116645\" target=\"_blank\">React17 源码解析(3) —— 深入理解 fiber</a>仅有一行描述：“每个节点开始创建时，执行 beginWork 流程，直至该节点的所有子孙节点都创建(更新)完成后，执行 completeWork 流程”。 因跳过了太多的细节，即使最后给了下面这么一幅图，也看的云里雾里</p>\n<img src=\"http://t-blog-images.aijs.top/img/202210140926842.webp\" />\n\n<p><strong>下面这两个链接详细阐述了整个过程</strong></p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/525244896\" target=\"_blank\" >React Fiber 架构原理：关于 Fiber 树的一切</a></li>\n<li><a href=\"https://blog.51cto.com/u_15127625/3316937\" target=\"_blank\" >Fiber 树的构建</a></li>\n</ol>\n<p><strong>爬取掘金专栏收录文章脚本</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var data &#x3D; &quot;&quot;;\nconst list &#x3D; document.getElementsByClassName(&quot;title-row&quot;);\n\nArray.from(list)\n  &#x2F;&#x2F; .sort(() &#x3D;&gt; 1) &#x2F;*反向排序 *&#x2F;\n  .forEach((item) &#x3D;&gt; &#123;\n    const linkdom &#x3D; item.children[0];\n    const lk &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;linkdom.href&#125;&quot; target&#x3D;&quot;_blank&quot; &gt;$&#123;linkdom.title&#125;&lt;&#x2F;a&gt;\\n&#96;;\n    data +&#x3D; lk;\n  &#125;);\n\ncopy(data);</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202210101827397.webp\" style=\"max-width:100%; width: 500px\" />\n\n<h2 id=\"收录链接-3\"><a href=\"#收录链接-3\" class=\"headerlink\" title=\"收录链接 3\"></a>收录链接 3</h2><ol>\n<li><a href=\"https://react.jokcy.me/book/api/react-structure.html\" target=\"_blank\" >react-structure</a></li>\n<li><a href=\"https://lilixikun.github.io/blog/\" target=\"_blank\" >lilixikun</a></li>\n</ol>\n<h2 id=\"updateQueue-环形链表\"><a href=\"#updateQueue-环形链表\" class=\"headerlink\" title=\"updateQueue 环形链表\"></a>updateQueue 环形链表</h2><p><strong>为什么使用环形链表：</strong></p>\n<p><strong>普通链表</strong></p>\n<ul>\n<li>如果只保存首节点的指针，则每次插入时需要先进行一次遍历找到尾节点，再进行插入。</li>\n<li>要么就需要保存首尾节点的指针。</li>\n<li><strong>环形链表</strong></li>\n</ul>\n<p>而<em>环形链表的尾节点的下一个节点就是首节点</em>，因此只需要保存一个尾节点就<em>可以做到既方便插入、又方便访问首节点</em></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">UpdateQueue&lt;State&gt; &#x3D; &#123;\n  &#x2F;&#x2F; 这三个baseState是有更新被跳过时候才产生\n  baseState: State, &#x2F;&#x2F; baseState 指向被跳过的首个元素之前的所有 update 计算出的最终状态\n  firstBaseUpdate: Update&lt;State&gt;, &#x2F;&#x2F; firstBaseUpdate 指向被跳过的首个 update\n  lastBaseUpdate: Update&lt;State&gt;, &#x2F;&#x2F; lastBaseUpdate，只要有 update 被跳过，那么它一定指向本次更新的 update 中的最后一个\n\n  shared: SharedQueue&lt;State&gt;, &#x2F;&#x2F; 单环链表 真正存放 update 的链表的属性\n  effects: Array&lt;Update&lt;State&gt;&gt;,\n&#125;;\n\ntype SharedQueue&lt;State&gt; &#x3D; &#123;\n  pending: Update&lt;State&gt; | null;\n&#125;;</code></pre>\n\n<h2 id=\"firstBaseUpdate-以及-lastBaseUpdate-形成的单链表\"><a href=\"#firstBaseUpdate-以及-lastBaseUpdate-形成的单链表\" class=\"headerlink\" title=\"firstBaseUpdate 以及 lastBaseUpdate 形成的单链表\"></a>firstBaseUpdate 以及 lastBaseUpdate 形成的单链表</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let pendingQueue &#x3D; queue.shared.pending; &#x2F;&#x2F;  (取一个节点)\n\n&#x2F;&#x2F; 将 pending 设为空，表示这些 pending 已经处理过\nqueue.shared.pending &#x3D; null;\nconst lastPendingUpdate &#x3D; pendingQueue; &#x2F;&#x2F; pending 的最后一个 udpdate\nconst firstPendingUpdate &#x3D; lastPendingUpdate.next; &#x2F;&#x2F; pending 的第一个 update\n&#x2F;&#x2F; 剪开环，使最后一个 update 不再指向第一个 update\nlastPendingUpdate.next &#x3D; null;\nif (lastBaseUpdate &#x3D;&#x3D;&#x3D; null) &#123;\n  &#x2F;&#x2F;\n  firstBaseUpdate &#x3D; firstPendingUpdate;\n&#125; else &#123;\n  &#x2F;&#x2F; 如果上一次有跳过的 update，那么 baseUpdate 链表不为空\n  &#x2F;&#x2F; 需要将 pending 的第一个 update 接上 baseUpdate\n  lastBaseUpdate.next &#x3D; firstPendingUpdate;\n&#125;\n&#x2F;&#x2F; 将 lastBaseUpdate 赋值为 lastPendingUpdate\n&#x2F;&#x2F; 此时已经形成了 以 firstBaseUpdate 为头以 lastBaseUpdate 为尾的新链表\n&#x2F;&#x2F; 也即为本次需要处理的 update 链表\nlastBaseUpdate &#x3D; lastPendingUpdate;</code></pre>\n\n<h2 id=\"React-总结图\"><a href=\"#React-总结图\" class=\"headerlink\" title=\"React 总结图\"></a>React 总结图</h2><img src=\"http://t-blog-images.aijs.top/img/202303081038554.webp\" />\n\n<p><a href=\"https://github.com/841660202/excalidraw/blob/main/react/reconciler.excalidraw\" target=\"_blank\" >源码文件</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://juejin.cn/post/7093082885363597349\" target=\"_blank\" >React Fiber - updateQueue 原理分析</a></p>\n<p><a href=\"https://juejin.cn/post/7019254208830373902\" target=\"_blank\" >React17 源码解析(4) —— 详解 render 阶段(scheduler 和 reconciler)</a><br><a href=\"https://blog.csdn.net/qq_39583550/article/details/125905341\" target=\"_blank\" >见</a></p>\n<h2 id=\"待学习源码\"><a href=\"#待学习源码\" class=\"headerlink\" title=\"待学习源码\"></a>待学习源码</h2><p><a href=\"https://github.com/baozouai/react-source-study\" target=\"_blank\" >react-source-study, 这老铁掘金文章写跑题了，蹭热度，不晓得，代码如何～，先收着</a></p>\n","text":"收录链接 1 React17 源码解析(开篇) —— 搭建 react 源码调试环境 React17 源码解析(1) —— 源码目录及 react 架构 React17 源码解析(2) —— jsx 转换及 React.createElement React17 源码解析(3) ...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%B6%E5%BD%95%E9%93%BE%E6%8E%A5-1\"><span class=\"toc-text\">收录链接 1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%B6%E5%BD%95%E9%93%BE%E6%8E%A5-2\"><span class=\"toc-text\">收录链接 2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%B6%E5%BD%95%E9%93%BE%E6%8E%A5-3\"><span class=\"toc-text\">收录链接 3</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#updateQueue-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">updateQueue 环形链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#firstBaseUpdate-%E4%BB%A5%E5%8F%8A-lastBaseUpdate-%E5%BD%A2%E6%88%90%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">firstBaseUpdate 以及 lastBaseUpdate 形成的单链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E6%80%BB%E7%BB%93%E5%9B%BE\"><span class=\"toc-text\">React 总结图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%85%E5%AD%A6%E4%B9%A0%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">待学习源码</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"好记性不如“实时笔记”","uid":"2bccffee84b946de8f4dcf6a90a9884c","slug":"2022-10-13record","date":"2022-10-13T03:25:25.000Z","updated":"2023-02-20T21:20:56.477Z","comments":true,"path":"api/articles/2022-10-13record.json","keywords":null,"cover":"https://img.zcool.cn/community/011b955568ef2700000127166e3178.jpg@1280w_1l_2o_100sh.jpg","text":"背景看视频、音频，再发散一点如会议、需求对接、老师授课课堂笔记等，很多场景我们可能遇到做笔记啊。 _上学时候_，做课堂笔记是一件耗费心神的事情，既想要把内容听进去，又想之后能够很快的复习。真的很难。 _现在，累了半辈子，这辈子是不可能再“那么记了”_， 程序员 !&#x3D; &...","link":"","photos":[],"count_time":{"symbolsCount":613,"symbolsTime":"1 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":20,"path":"api/tags/工具.json"},{"name":"增效","slug":"增效","count":7,"path":"api/tags/增效.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Antd Tree drag","uid":"9635a6b254011f1f62378c1d84830a04","slug":"2022-10-10antd-tree-drag","date":"2022-10-10T01:19:14.000Z","updated":"2022-10-15T02:11:29.159Z","comments":true,"path":"api/articles/2022-10-10antd-tree-drag.json","keywords":null,"cover":[],"text":"属性解释dropToGap：boolean类型，true代表拖拽到节点之间的缝隙中，false代表拖拽到节点上，即节点的内容区。dropPosition：拖拽的时候，针对一个节点有三种情况，即拖拽到节点之上，拖拽到节点上，拖拽到节点之下。 三种情况其值有所不同。antd 依赖了 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}