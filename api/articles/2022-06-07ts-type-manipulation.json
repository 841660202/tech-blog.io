{"title":"7.Typescript手册 类型操作","uid":"62218ddca7698d868da0d101af067d2c","slug":"2022-06-07ts-type-manipulation","date":"2022-06-08T03:20:35.000Z","updated":"2022-09-16T14:59:02.672Z","comments":true,"path":"api/articles/2022-06-07ts-type-manipulation.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","content":"<h2 id=\"ts-类型如何调试\"><a href=\"#ts-类型如何调试\" class=\"headerlink\" title=\"ts 类型如何调试\"></a>ts 类型如何调试</h2><ul>\n<li>不是代码逻辑如何调试，没想到</li>\n</ul>\n<h2 id=\"ts-自定义类型如何打印\"><a href=\"#ts-自定义类型如何打印\" class=\"headerlink\" title=\"ts 自定义类型如何打印\"></a>ts 自定义类型如何打印</h2><ul>\n<li>不是 js 的结果如何打印，没想到</li>\n</ul>\n<h2 id=\"Creating-Types-from-Types\"><a href=\"#Creating-Types-from-Types\" class=\"headerlink\" title=\"Creating Types from Types\"></a>Creating Types from Types</h2><p>从已有类型中创建类型</p>\n<p>TypeScript 的类型系统非常强大，因为它允许表达类型的另一种表达方式。<br>最简单的方式是泛型，我们实际上有一大堆的类型操作符可用。还可以表达类型的另一种表达方式，就是把已有的值作为类型。<br>通过合并多种类型操作符，我们可以表达复杂的操作和值，这里我们将介绍以另一个类型或值为基础如何表达一个新类型。</p>\n<p><code>简单来说：使用 范型 或 6种表达式 来创建新类型</code></p>\n<ul>\n<li><p>范型 - 类型需要参数</p>\n</li>\n<li><p>Keyof Type Operator - 用 keyof 操作去创建新类型</p>\n</li>\n<li><p>Typeof Type Operator - 用 typeof 操作去创建新类型</p>\n</li>\n<li><p>Indexed Access Types - 使用 Type[‘a’]语法去访问一个类型的一部分</p>\n</li>\n<li><p>Conditional Types - 类型行为像 if 语句一样</p>\n</li>\n<li><p>Mapped Types - 通过映射已有类型的每个属性来创建新类型</p>\n</li>\n<li><p>Template Literal Types - 通过模板字符串来改变属性的映射类型</p>\n</li>\n</ul>\n<h2 id=\"Keyof-Type-Operator\"><a href=\"#Keyof-Type-Operator\" class=\"headerlink\" title=\"Keyof Type Operator\"></a>Keyof Type Operator</h2><ul>\n<li>这个操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type P1 &#x3D; keyof any; &#x2F;&#x2F; 提示：type P1 &#x3D; string | number | symbol</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Point &#x3D; &#123; x: number; y: number &#125;;\ntype P &#x3D; keyof Point; &#x2F;&#x2F; 提示：type P &#x3D; keyof Point，这个提示等于没提示</code></pre>\n\n<ul>\n<li>如果这个类型有字符串或者数字索引，keyof 就会返回这个类型：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Arrayish &#x3D; &#123; [n: number]: unknown &#125;;\ntype A &#x3D; keyof Arrayish; &#x2F;&#x2F;提示：type A &#x3D; number\n\ntype Mapish &#x3D; &#123; [k: string]: boolean &#125;;\ntype M &#x3D; keyof Mapish; &#x2F;&#x2F; 提示：type M &#x3D; string | number\n\n&#x2F;&#x2F; --------------------------------------------------------------\n&#x2F;&#x2F; 对于Arrayish\n\n&#x2F;&#x2F; 实例1:ok\nvar a: Arrayish &#x3D; &#123;\n  1: &quot;string&quot;,\n  2: false,\n&#125;;\n&#x2F;&#x2F; 实例2: ok\nvar a1: Arrayish &#x3D; [1, 2, 3, 4];\n\n&#x2F;&#x2F; 对于 Mapish\nvar b: Mapish &#x3D; &#123;\n  name: true,\n  age: false,\n&#125;;</code></pre>\n\n<p>注意，这个例子中，M 是 string | number — 这是因为 JavaScript 对象键是总是被强制为字符串，所以 obj[0] 总是和 obj[“0”] 相同。</p>\n<p>keyof 类型操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：</p>\n<h2 id=\"Typeof-type-operator\"><a href=\"#Typeof-type-operator\" class=\"headerlink\" title=\"Typeof type operator\"></a>Typeof type operator</h2><p>JavaScript 也有一个 typeof 操作符，可以用在表达式中：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Prints &quot;string&quot;\nconsole.log(typeof &quot;Hello world&quot;);</code></pre>\n\n<p>TypeScript 增加了一个 typeof 操作符，可以用在类型上：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let s &#x3D; &quot;hello&quot;;\nlet n: typeof s; &#x2F;&#x2F; 提示：let n: string</code></pre>\n\n<h2 id=\"ReturnType\"><a href=\"#ReturnType\" class=\"headerlink\" title=\"ReturnType\"></a>ReturnType</h2><p>对于基本类型，typeof 操作符没有意义，但是与其他类型操作符结合使用，可以用 typeof 操作符来实现一些模式。例如，我们开始用 ReturnType<T> 来表示函数的返回类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Predicate &#x3D; (x: unknown) &#x3D;&gt; boolean;\ntype K &#x3D; ReturnType&lt;Predicate&gt;; &#x2F;&#x2F; 提示 type K &#x3D; boolean</code></pre>\n\n<p>如果我们尝试使用 ReturnType 在函数名上，我们会看到一个指示性的错误：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function f() &#123;\n  return &#123; x: 10, y: 3 &#125;;\n&#125;\ntype P &#x3D; ReturnType&lt;f&gt;;\n&#x2F;&#x2F; 提示：&#39;f&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof f&#39;?\n&#x2F;&#x2F; 提示：&#39;f&#39; 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof f&#39; 来代替 &#39;f&#39;？</code></pre>\n\n<p>记住，值和类型不是一回事。要引用值 f 所拥有的类型，我们使用 typeof：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function f() &#123;\n  return &#123; x: 10, y: 3 &#125;;\n&#125;\ntype P &#x3D; ReturnType&lt;typeof f&gt;;\n\n&#x2F;**\n * 提示\n * type P &#x3D; &#123;\n    x: number;\n    y: number;\n&#125;\n**&#x2F;</code></pre>\n\n<p><strong>限制</strong></p>\n<p>typescript 通常限制了 typeof 的表达式的类型。<br>特殊的，typeof 的表达式<code>只能用于标识符（即变量名）其属性</code>。这个限制是为了避免写一些你认为是执行的代码，但实际上并不是的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Meant to use &#x3D; ReturnType&lt;typeof msgbox&gt;\nlet shouldContinue: typeof msgbox(&quot;Are you sure you want to continue?&quot;);\n&#x2F;&#x2F; &#39;,&#39; expected.</code></pre>\n\n<h2 id=\"Indexed-Access-Types\"><a href=\"#Indexed-Access-Types\" class=\"headerlink\" title=\"Indexed Access Types\"></a>Indexed Access Types</h2><p>我们可以使用索引访问类型来查找一个类型的特定属性：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Person &#x3D; &#123; age: number; name: string; alive: boolean &#125;;\ntype Age &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示：type Age &#x3D; number</code></pre>\n\n<p>这个索引类型本身是一个类型，所以我们可以使用联合，keyof 或者其他类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type I1 &#x3D; Person[&quot;age&quot; | &quot;name&quot;]; &#x2F;&#x2F; 提示：type I1 &#x3D; string | number\n\ntype I2 &#x3D; Person[keyof Person]; &#x2F;&#x2F; 提示：type I2 &#x3D; string | number | boolean\n\ntype AliveOrName &#x3D; &quot;alive&quot; | &quot;name&quot;;\ntype I3 &#x3D; Person[AliveOrName]; &#x2F;&#x2F; 提示：type I3 &#x3D; string | boolean</code></pre>\n\n<p>你会看到一个错误，如果你尝试索引一个不存在的属性：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type I1 &#x3D; Person[&quot;alve&quot;];\nProperty &#39;alve&#39; does not exist on type &#39;Person&#39;.</code></pre>\n\n<p>另一个例子是使用 number 来获取数组的元素类型。我们可以使用 typeof 来方便地捕获数组字面量的元素类型。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const MyArray &#x3D; [\n  &#123; name: &quot;Alice&quot;, age: 15 &#125;,\n  &#123; name: &quot;Bob&quot;, age: 23 &#125;,\n  &#123; name: &quot;Eve&quot;, age: 38 &#125;,\n];\n\ntype Person &#x3D; typeof MyArray[number];\n\n&#x2F;&#x2F; 提示：type Person &#x3D; &#123; name: string; age: number; &#125;\n\ntype Age &#x3D; typeof MyArray[number][&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age &#x3D; number;\n&#x2F;&#x2F; Or\ntype Age2 &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age2 &#x3D; number;</code></pre>\n\n<p>你只能使用类型来索引，意味着你不能使用 const 来创建一个变量引用：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const key &#x3D; &quot;age&quot;;\ntype Age &#x3D; Person[key];\n&#x2F;&#x2F; Type &#39;key&#39; cannot be used as an index type.\n&#x2F;&#x2F; 这个错误是因为 key 是一个字面量，而不是一个变量。\n&#x2F;&#x2F; &#39;key&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof key&#39;?\n&#x2F;&#x2F; 这个错误是因为 key 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof key&#39; 来代替 &#39;key&#39;？</code></pre>\n\n<p>然而，你可以使用一个类型别名来替换相同的风格的重构：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type key &#x3D; &quot;age&quot;;\ntype Age &#x3D; Person[key];</code></pre>\n\n<h2 id=\"Conditional-Types\"><a href=\"#Conditional-Types\" class=\"headerlink\" title=\"Conditional Types\"></a>Conditional Types</h2><p>At the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. Conditional types help describe the relation between the types of inputs and outputs.<br>在最常见的程序中，我们需要根据输入来做决策。 JavaScript 程序是不同的，但是给定了这个事实，那些决策是根据输入的类型来做的。条件类型帮助描述输入和输出类型之间的关系。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  live(): void;\n&#125;\ninterface Dog extends Animal &#123;\n  woof(): void;\n&#125;\n\ntype Example1 &#x3D; Dog extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example1 &#x3D; number\n\ntype Example2 &#x3D; RegExp extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example2 &#x3D; string</code></pre>\n\n<p>条件类型的表达式像 JavaScript 中的条件表达式一样：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">SomeType extends OtherType ? TrueType : FalseType;</code></pre>\n\n<p><strong>此段内容，原文保留</strong><br>When the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).</p>\n<p>当 extends 左边的类型可以赋值给右边的类型时，你会得到第一个分支的类型（“true”分支）；否则你会得到第二个分支的类型（“false”分支）。</p>\n<p>From the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not Dog extends Animal and pick number or string! But the power of conditional types comes from using them with generics.<br>从上面的例子中可以看到条件类型可能不会立即看起来很有用，我们可以告诉自己 Dog 是否继承了 Animal，然后选择 number 或 string！但是条件类型的力量来自于使用它们与泛型。</p>\n<p>For example, let’s take the following createLabel function:<br>例如，我们可以把下面的 createLabel 函数拿来说说：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface IdLabel &#123;\n  id: number &#x2F;* some fields *&#x2F;;\n&#125;\ninterface NameLabel &#123;\n  name: string &#x2F;* other fields *&#x2F;;\n&#125;\n\nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel &#123;\n  throw &quot;unimplemented&quot;;\n&#125;</code></pre>\n\n<p>These overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:<br>这些 createLabel 的重载描述了一个单一的 JavaScript 函数，它根据输入的类型来做决策。请注意一些事情：</p>\n<p>If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.<br>We have to create three overloads: one for each case when we’re sure of the type (one for string and one for number), and one for the most general case (taking a string | number). For every new type createLabel can handle, the number of overloads grows exponentially.<br>如果一个库需要在其 API 中重复使用相同的选择，这就变得非常麻烦。我们需要创建三个重载：一个当我们知道类型时，一个当我们知道类型时，一个当我们不知道类型时。对于每个新的类型 createLabel 可以处理，重载的数量就会指数增长。<br>Instead, we can encode that logic in a conditional type:<br>反之，我们可以使用条件类型来表示逻辑：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type NameOrId&lt;T extends number | string&gt; &#x3D; T extends number\n  ? IdLabel\n  : NameLabel;</code></pre>\n\n<p>We can then use that conditional type to simplify our overloads down to a single function with no overloads.<br>我们可以使用这个条件类型来简化我们的重载，只有一个函数。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; &#123;\n  throw &quot;unimplemented&quot;;\n&#125;\n\nlet a &#x3D; createLabel(&quot;typescript&quot;);\n\n&#x2F;&#x2F; 提示：let a: NameLabel;\n\nlet b &#x3D; createLabel(2.8);\n\n&#x2F;&#x2F; 提示：let b: IdLabel;\n\nlet c &#x3D; createLabel(Math.random() ? &quot;hello&quot; : 42);\n&#x2F;&#x2F; 提示：let c: NameLabel | IdLabel;</code></pre>\n\n<ul>\n<li>Conditional Type Constraints</li>\n</ul>\n<p>条件类型约束</p>\n<p>Often, the checks in a conditional type will provide us with some new information. Just like with narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.<br>通常，在条件类型中的检查会提供我们一些新的信息。像类型检查一样，通过类型约束可以给我们更具体的类型，条件类型的 true 分支将通过我们检查的类型来约束泛型。<br>For example, let’s take the following:<br>例如，我们可以把下面的函数拿来说说：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type MessageOf&lt;T&gt; &#x3D; T[&quot;message&quot;];\n&#x2F;&#x2F; Type &#39;&quot;message&quot;&#39; cannot be used to index type &#39;T&#39;.</code></pre>\n\n<p>In this example, TypeScript errors because T isn’t known to have a property called message. We could constrain T, and TypeScript would no longer complain:</p>\n<p>在这个例子中，TypeScript 错误，因为 T 没有一个属性叫 message。我们可以约束 T，TypeScript 不会再报错了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type MessageOf&lt;T extends &#123; message: unknown &#125;&gt; &#x3D; T[&quot;message&quot;];\n\ninterface Email &#123;\n  message: string;\n&#125;\n\ntype EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;\n\n&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string</code></pre>\n\n<p>However, what if we wanted MessageOf to take any type, and default to something like never if a message property isn’t available? We can do this by moving the constraint out and introducing a conditional type:<br>然而，如果我们想要 MessageOf 取任意类型，并且默认为没有 message 属性的情况，我们可以这样做：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type MessageOf&lt;T&gt; &#x3D; T extends &#123; message: unknown &#125; ? T[&quot;message&quot;] : never;\n\ninterface Email &#123;\n  message: string;\n&#125;\n\ninterface Dog &#123;\n  bark(): void;\n&#125;\n\ntype EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;\n\n&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string;\n\ntype DogMessageContents &#x3D; MessageOf&lt;Dog&gt;;\n\n&#x2F;&#x2F; 提示：type DogMessageContents &#x3D; never;</code></pre>\n\n<p>Within the true branch, TypeScript knows that T will have a message property.<br>在 true 分支中，TypeScript 知道 T 有一个 message 属性。</p>\n<p>As another example, we could also write a type called Flatten that flattens array types to their element types, but leaves them alone otherwise:<br>作为另一个示例，我们还可以编写一个名为 Flatten 的类型，该类型将数组类型展平为其元素类型，但在其他情况下不使用它们：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Flatten&lt;T&gt; &#x3D; T extends any[] ? T[number] : T;\n\n&#x2F;&#x2F; Extracts out the element type. 提取元素类型。\ntype Str &#x3D; Flatten&lt;string[]&gt;;\n\ntype Str &#x3D; string;\n\n&#x2F;&#x2F; Leaves the type alone. 保留该类型。\ntype Num &#x3D; Flatten&lt;number&gt;;\n\ntype Num &#x3D; number;</code></pre>\n\n<p>When Flatten is given an array type, it uses an indexed access with number to fetch out string[]’s element type. Otherwise, it just returns the type it was given.<br>当 Flatten 给定一个数组类型，它使用 number 下标得到 string[]元素类型，否则，仅返回所给类型</p>\n<p>Inferring Within Conditional Types<br>在条件类型内推断</p>\n<p>We just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.</p>\n<p>我们只是发现自己使用条件类型来应用约束，然后提取出类型。这最终是一种常见的操作，条件类型使其更容易实现。</p>\n<p>Conditional types provide us with a way to infer from types we compare against in the true branch using the infer keyword. For example, we could have inferred the element type in Flatten instead of fetching it out “manually” with an indexed access type:</p>\n<p>条件类型为我们提供了一种使用 infer 关键字从 true 分支中比较的类型推断的方法。例如，我们可以在 Flatten 中推断元素类型，而不是使用索引访问类型“手动”提取它：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Flatten&lt;Type&gt; &#x3D; Type extends Array&lt;infer Item&gt; ? Item : Type;</code></pre>\n\n<p>Here, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of T within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.</p>\n<p>在这里，我们使用 infer 关键字声明性地引入一个名为 Item 的新泛型类型变量，而不是指定如何在 true 分支中检索 T 的元素类型。这使我们不必思考如何挖掘和探索我们感兴趣的类型的结构。</p>\n<p>We can write some useful helper type aliases using the infer keyword. For example, for simple cases, we can extract the return type out from function types:</p>\n<p>我们可以使用 infer 关键字编写一些有用的助手类型别名。例如，对于简单的情况，我们可以从函数类型中提取返回类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type GetReturnType&lt;Type&gt; &#x3D; Type extends (...args: never[]) &#x3D;&gt; infer Return\n  ? Return\n  : never;\n\ntype Num &#x3D; GetReturnType&lt;() &#x3D;&gt; number&gt;;\n\n&#x2F;&#x2F; 提示： type Num &#x3D; number\n\ntype Str &#x3D; GetReturnType&lt;(x: string) &#x3D;&gt; string&gt;;\n\n&#x2F;&#x2F; 提示：type Str &#x3D; string\n\ntype Bools &#x3D; GetReturnType&lt;(a: boolean, b: boolean) &#x3D;&gt; boolean[]&gt;;\n\n&#x2F;&#x2F; 提示： type Bools &#x3D; boolean[]</code></pre>\n\n<p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.<br>当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，将从最后一个签名进行推断（这可能是最允许的一网打尽的情况）。无法基于参数类型列表执行重载解析。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">declare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n\ntype T1 &#x3D; ReturnType&lt;typeof stringOrNum&gt;;\n\n&#x2F;&#x2F; 提示：type T1 &#x3D; string | number;</code></pre>\n\n<h2 id=\"Distributive-Conditional-Types\"><a href=\"#Distributive-Conditional-Types\" class=\"headerlink\" title=\"Distributive Conditional Types\"></a>Distributive Conditional Types</h2><p>分布条件类型</p>\n<p>When conditional types act on a generic type, they become distributive when given a union type. For example, take the following:<br>当条件类型作用于泛型类型时，当给定一个联合类型时，它们将成为分布式的。例如，以以下内容为例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;</code></pre>\n\n<p>If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.<br>如果我们将一个联合类型插入 ToArray，那么条件类型将应用于该联合的每个成员。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;\n\ntype StrArrOrNumArr &#x3D; ToArray&lt;string | number&gt;;\n\n&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; string[] | number[];</code></pre>\n\n<p>What happens here is that StrArrOrNumArr distributes on:<br>这里发生了什么？</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">string | number;</code></pre>\n\n<p>and maps over each member type of the union, to what is effectively:<br>并映射到联合类型每个成员类型</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">ToArray&lt;string&gt; | ToArray&lt;number&gt;;</code></pre>\n\n<p>which leaves us with:<br>这给我们留下了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">string[] | number[];</code></pre>\n\n<p>Typically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets.<br>通常情况下，分布式是所需的行为。要避免这种行为，你可以在每边 extends 关键字之前使用方括号。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ToArrayNonDist&lt;Type&gt; &#x3D; [Type] extends [any] ? Type[] : never;\n\n&#x2F;&#x2F; &#39;StrArrOrNumArr&#39; is no longer a union.\ntype StrArrOrNumArr &#x3D; ToArrayNonDist&lt;string | number&gt;;\n&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; (string | number)[];</code></pre>\n\n<h2 id=\"Return\"><a href=\"#Return\" class=\"headerlink\" title=\"Return\"></a>Return</h2><h2 id=\"模板字面量类型（Template-Literal-Types）\"><a href=\"#模板字面量类型（Template-Literal-Types）\" class=\"headerlink\" title=\"模板字面量类型（Template Literal Types）\"></a>模板字面量类型（Template Literal Types）</h2><p>模板字面量类型以字符串字面量类型为基础，可以通过联合类型扩展成多个字符串。</p>\n<p>它们跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。当使用模板字面量类型时，它会替换模板中的变量，返回一个新的字符串字面量：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type World &#x3D; &quot;world&quot;;\n\ntype Greeting &#x3D; &#96;hello $&#123;World&#125;&#96;;\n&#x2F;&#x2F; type Greeting &#x3D; &quot;hello world&quot;</code></pre>\n\n<ul>\n<li>当模板中的变量是一个联合类型时，每一个可能的字符串字面量都会被表示：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type EmailLocaleIDs &#x3D; &quot;welcome_email&quot; | &quot;email_heading&quot;;\ntype FooterLocaleIDs &#x3D; &quot;footer_title&quot; | &quot;footer_sendoff&quot;;\n\ntype AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;\n&#x2F;&#x2F; type AllLocaleIDs &#x3D; &quot;welcome*email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</code></pre>\n\n<ul>\n<li>如果模板字面量里的多个变量都是联合类型，结果会交叉相乘，比如下面的例子就有 2 * 2 _ 3 一共 12 种结果：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;\ntype Lang &#x3D; &quot;en&quot; | &quot;ja&quot; | &quot;pt&quot;;\n\ntype LocaleMessageIDs &#x3D; &#96;$&#123;Lang&#125;_$&#123;AllLocaleIDs&#125;&#96;;\n&#x2F;&#x2F; type LocaleMessageIDs &#x3D; &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot;</code></pre>\n\n<ul>\n<li>如果真的是非常长的字符串联合类型，推荐提前生成，这种还是适用于短一些的情况。</li>\n</ul>\n<h2 id=\"类型中的字符串联合类型（String-Unions-in-Types）\"><a href=\"#类型中的字符串联合类型（String-Unions-in-Types）\" class=\"headerlink\" title=\"类型中的字符串联合类型（String Unions in Types）\"></a>类型中的字符串联合类型（String Unions in Types）</h2><p>模板字面量最有用的地方在于你可以基于一个类型内部的信息，定义一个新的字符串，让我们举个例子：</p>\n<p>有这样一个函数 makeWatchedObject， 它会给传入的对象添加了一个 on 方法。在 JavaScript 中，它的调用看起来是这样：makeWatchedObject(baseObject)，我们假设这个传入对象为：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const passedObject &#x3D; &#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;;</code></pre>\n\n<p>这个 on 方法会被添加到这个传入对象上，该方法接受两个参数，eventName （ string 类型） 和 callBack （function 类型）：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 伪代码\nconst result &#x3D; makeWatchedObject(baseObject);\nresult.on(eventName, callBack);</code></pre>\n\n<p>我们希望 eventName 是这种形式：attributeInThePassedObject + “Changed” ，举个例子，</p>\n<ul>\n<li>passedObject 有一个属性 firstName，对应产生的 eventName 为 firstNameChanged，</li>\n<li>同理，lastName 对应的是 lastNameChanged，</li>\n<li>age 对应的是 ageChanged。</li>\n</ul>\n<p>当这个 callBack 函数被调用的时候：</p>\n<ul>\n<li>应该被传入与 attributeInThePassedObject 相同类型的值。比如 passedObject 中，<ul>\n<li>firstName 的值的类型为 string , 对应 firstNameChanged 事件的回调函数，则接受传入一个 string 类型的值。</li>\n<li>age 的值的类型为 number，对应 ageChanged 事件的回调函数，则接受传入一个 number 类型的值。</li>\n</ul>\n</li>\n<li>返回值类型为 void 类型。<br>on() 方法的签名最一开始是这样的：on(eventName: string, callBack: (newValue: any) &#x3D;&gt; void)。 使用这样的签名，我们是不能实现上面所说的这些约束的，这个时候就可以使用模板字面量：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\n&#x2F;&#x2F; makeWatchedObject has added &#96;on&#96; to the anonymous Object\nperson.on(&quot;firstNameChanged&quot;, (newValue) &#x3D;&gt; &#123;\n  console.log(&#96;firstName was changed to $&#123;newValue&#125;!&#96;);\n&#125;);</code></pre>\n\n<p>注意这个例子里，on 方法添加的事件名为 “firstNameChanged”， 而不仅仅是 “firstName”，而回调函数传入的值 newValue ，我们希望约束为 string 类型。我们先实现第一点。</p>\n<p>在这个例子里，我们希望传入的事件名的类型，是对象属性名的联合，只是每个联合成员都还在最后拼接一个 Changed 字符，在 JavaScript 中，我们可以做这样一个计算：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">Object.keys(passedObject).map(x &#x3D;&gt; $&#123;x&#125;Changed)</code></pre>\n\n<p>模板字面量提供了一个相似的字符串操作：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;string &amp; keyof Type&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n&#x2F;&#x2F;&#x2F; Create a &quot;watched object&quot; with an &#39;on&#39; method\n&#x2F;&#x2F;&#x2F; so that you can watch for changes to properties.\n\ndeclare function makeWatchedObject&lt;Type&gt;(\n  obj: Type\n): Type &amp; PropEventSource&lt;Type&gt;;</code></pre>\n\n<p>注意，我们在这里例子中，模板字面量里我们写的是 string &amp; keyof Type，我们可不可以只写成 keyof Type 呢？如果我们这样写，会报错：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;keyof Type&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n&#x2F;&#x2F; Type &#39;keyof Type&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.\n&#x2F;&#x2F; Type &#39;string | number | symbol&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.\n&#x2F;&#x2F; ...</code></pre>\n\n<p>从报错信息中，我们也可以看出报错原因，在 《TypeScript 系列之 Keyof 操作符》里，我们知道</p>\n<ul>\n<li>keyof 操作符会返回 string | number | symbol 类型，</li>\n<li>但是模板字面量的变量要求的类型却是 string | number | bigint | boolean | null | undefined，</li>\n</ul>\n<p>比较一下，多了一个 symbol 类型，所以其实我们也可以这样写：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;Exclude&lt;keyof Type, symbol&gt;&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;</code></pre>\n\n<p>再或者这样写：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;Extract&lt;keyof Type, string&gt;&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;</code></pre>\n\n<p>使用这种方式，在我们使用错误的事件名时，TypeScript 会给出报错：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\nperson.on(&quot;firstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);\n\n&#x2F;&#x2F; Prevent easy human error (using the key instead of the event name)\nperson.on(&quot;firstName&quot;, () &#x3D;&gt; &#123;&#125;);\n&#x2F;&#x2F; Argument of type &#39;&quot;firstName&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.\n\n&#x2F;&#x2F; It&#39;s typo-resistant\nperson.on(&quot;frstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);\n&#x2F;&#x2F; Argument of type &#39;&quot;frstNameChanged&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.</code></pre>\n\n<h2 id=\"模板字面量的推断（Inference-with-Template-Literals）\"><a href=\"#模板字面量的推断（Inference-with-Template-Literals）\" class=\"headerlink\" title=\"模板字面量的推断（Inference with Template Literals）\"></a>模板字面量的推断（Inference with Template Literals）</h2><p>现在我们来实现第二点，回调函数传入的值的类型与对应的属性值的类型相同。<br>我们现在只是简单的对 callBack 的参数使用 any 类型。实现这个约束的关键在于借助泛型函数：</p>\n<p>捕获泛型函数第一个参数的字面量，生成一个字面量类型</p>\n<ul>\n<li>该字面量类型可以被对象属性构成的联合约束</li>\n<li>对象属性的类型可以通过索引访问获取</li>\n<li>应用此类型，确保回调函数的参数类型与对象属性的类型是同一个类型</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on&lt;Key extends string &amp; keyof Type&gt;(\n    eventName: &#96;$&#123;Key&#125;Changed&#96;,\n    callback: (newValue: Type[Key]) &#x3D;&gt; void\n  ): void;\n&#125;;\n\ndeclare function makeWatchedObject&lt;Type&gt;(\n  obj: Type\n): Type &amp; PropEventSource&lt;Type&gt;;\n\nconst person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\nperson.on(&quot;firstNameChanged&quot;, (newName) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; (parameter) newName: string\n  console.log(&#96;new name is $&#123;newName.toUpperCase()&#125;&#96;);\n&#125;);\n\nperson.on(&quot;ageChanged&quot;, (newAge) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; (parameter) newAge: number\n  if (newAge &lt; 0) &#123;\n    console.warn(&quot;warning! negative age&quot;);\n  &#125;\n&#125;);</code></pre>\n\n<p>这里我们把 on 改成了一个泛型函数。</p>\n<p>当一个用户调用的时候传入 “firstNameChanged”，TypeScript 会尝试着推断 Key 正确的类型。它会匹配 key 和 “Changed” 前的字符串 ，然后推断出字符串 “firstName” ，然后再获取原始对象的 firstName 属性的类型，在这个例子中，就是 string 类型。</p>\n<h2 id=\"内置字符操作类型（Intrinsic-String-Manipulation-Types）\"><a href=\"#内置字符操作类型（Intrinsic-String-Manipulation-Types）\" class=\"headerlink\" title=\"内置字符操作类型（Intrinsic String Manipulation Types）\"></a>内置字符操作类型（Intrinsic String Manipulation Types）</h2><p>TypeScript 的一些类型可以用于字符操作，这些类型处于性能的考虑被内置在编译器中，你不能在 .d.ts 文件里找到它们。</p>\n<h2 id=\"Uppercase\"><a href=\"#Uppercase\" class=\"headerlink\" title=\"Uppercase\"></a>Uppercase</h2><p>把每个字符转为大写形式：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Greeting &#x3D; &quot;Hello, world&quot;;\ntype ShoutyGreeting &#x3D; Uppercase&lt;Greeting&gt;;\n&#x2F;&#x2F; type ShoutyGreeting &#x3D; &quot;HELLO, WORLD&quot;\n\ntype ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;ID-$&#123;Uppercase&lt;Str&gt;&#125;&#96;;\ntype MainID &#x3D; ASCIICacheKey&lt;&quot;my_app&quot;&gt;;\n&#x2F;&#x2F; type MainID &#x3D; &quot;ID-MY_APP&quot;</code></pre>\n\n<h2 id=\"Lowercase\"><a href=\"#Lowercase\" class=\"headerlink\" title=\"Lowercase\"></a>Lowercase</h2><p>把每个字符转为小写形式：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Greeting &#x3D; &quot;Hello, world&quot;;\ntype QuietGreeting &#x3D; Lowercase&lt;Greeting&gt;;\n&#x2F;&#x2F; type QuietGreeting &#x3D; &quot;hello, world&quot;\n\ntype ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;id-$&#123;Lowercase&lt;Str&gt;&#125;&#96;;\ntype MainID &#x3D; ASCIICacheKey&lt;&quot;MY_APP&quot;&gt;;\n&#x2F;&#x2F; type MainID &#x3D; &quot;id-my_app&quot;</code></pre>\n\n<h2 id=\"Capitalize\"><a href=\"#Capitalize\" class=\"headerlink\" title=\"Capitalize\"></a>Capitalize</h2><ul>\n<li>把字符串的第一个字符转为大写形式：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type LowercaseGreeting &#x3D; &quot;hello, world&quot;;\ntype Greeting &#x3D; Capitalize&lt;LowercaseGreeting&gt;;\n&#x2F;&#x2F; type Greeting &#x3D; &quot;Hello, world&quot;</code></pre>\n\n<h2 id=\"Uncapitalize\"><a href=\"#Uncapitalize\" class=\"headerlink\" title=\"Uncapitalize\"></a>Uncapitalize</h2><ul>\n<li>把字符串的第一个字符转换为小写形式：</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type UppercaseGreeting &#x3D; &quot;HELLO WORLD&quot;;\ntype UncomfortableGreeting &#x3D; Uncapitalize&lt;UppercaseGreeting&gt;;\n&#x2F;&#x2F; type UncomfortableGreeting &#x3D; &quot;hELLO WORLD&quot;</code></pre>\n\n<ul>\n<li>字符操作类型的技术细节<br>从 TypeScript 4.1 起，这些内置函数会直接使用 JavaScript 字符串运行时函数，而不是本地化识别 (locale aware)。</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function applyStringMapping(symbol: Symbol, str: string) &#123;\n  switch (intrinsicTypeKinds.get(symbol.escapedName as string)) &#123;\n    case IntrinsicTypeKind.Uppercase:\n      return str.toUpperCase();\n    case IntrinsicTypeKind.Lowercase:\n      return str.toLowerCase();\n    case IntrinsicTypeKind.Capitalize:\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    case IntrinsicTypeKind.Uncapitalize:\n      return str.charAt(0).toLowerCase() + str.slice(1);\n  &#125;\n  return str;\n&#125;</code></pre>\n\n<p>作者：冴羽<br>链接：<a href=\"https://www.imooc.com/article/322215\">https://www.imooc.com/article/322215</a><br>来源：慕课网<br>本文原创发布于慕课网 ，转载请注明出处，谢谢合作</p>\n<h2 id=\"在想一个问题\"><a href=\"#在想一个问题\" class=\"headerlink\" title=\"在想一个问题\"></a>在想一个问题</h2><p>为什么别人可以把文档翻译的那么准确，让读者一看就明白</p>\n","text":"ts 类型如何调试 不是代码逻辑如何调试，没想到 ts 自定义类型如何打印 不是 js 的结果如何打印，没想到 Creating Types from Types从已有类型中创建类型 TypeScript 的类型系统非常强大，因为它允许表达类型的另一种表达方式。最简单的方式是泛型...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"21 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":13,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ts-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">ts 类型如何调试</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ts-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">ts 自定义类型如何打印</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Creating-Types-from-Types\"><span class=\"toc-text\">Creating Types from Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Keyof-Type-Operator\"><span class=\"toc-text\">Keyof Type Operator</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Typeof-type-operator\"><span class=\"toc-text\">Typeof type operator</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReturnType\"><span class=\"toc-text\">ReturnType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Indexed-Access-Types\"><span class=\"toc-text\">Indexed Access Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Conditional-Types\"><span class=\"toc-text\">Conditional Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Distributive-Conditional-Types\"><span class=\"toc-text\">Distributive Conditional Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Return\"><span class=\"toc-text\">Return</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%88Template-Literal-Types%EF%BC%89\"><span class=\"toc-text\">模板字面量类型（Template Literal Types）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88String-Unions-in-Types%EF%BC%89\"><span class=\"toc-text\">类型中的字符串联合类型（String Unions in Types）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%8E%A8%E6%96%AD%EF%BC%88Inference-with-Template-Literals%EF%BC%89\"><span class=\"toc-text\">模板字面量的推断（Inference with Template Literals）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%AE%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%EF%BC%88Intrinsic-String-Manipulation-Types%EF%BC%89\"><span class=\"toc-text\">内置字符操作类型（Intrinsic String Manipulation Types）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Uppercase\"><span class=\"toc-text\">Uppercase</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lowercase\"><span class=\"toc-text\">Lowercase</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Capitalize\"><span class=\"toc-text\">Capitalize</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Uncapitalize\"><span class=\"toc-text\">Uncapitalize</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E6%83%B3%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">在想一个问题</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8.Typescript手册 类","uid":"14464d0b7865c234ecdc15847ed605ff","slug":"2022-06-08ts-classes","date":"2022-06-08T06:21:19.000Z","updated":"2022-09-16T14:58:59.954Z","comments":true,"path":"api/articles/2022-06-08ts-classes.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"Background Reading:背景阅读 Classes (MDN) TypeScript offers full support for the class keyword introduced in ES2015.typescript 支持 ES2015 的 class...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"41 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":13,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"6.Typescript手册 对象类型","uid":"f1faf548c4c61142a49eddcdf4aec1f6","slug":"2022-06-08ts-object-types","date":"2022-06-08T01:21:19.000Z","updated":"2022-09-16T14:59:25.753Z","comments":true,"path":"api/articles/2022-06-08ts-object-types.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object t...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":13,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}