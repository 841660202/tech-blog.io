{"title":"前端基础-js 函数","uid":"d7bd88002098c0649a55dcb4db29ef28","slug":"2022-07-28js-fun","date":"2022-07-28T03:13:15.000Z","updated":"2022-09-17T07:48:05.687Z","comments":true,"path":"api/articles/2022-07-28js-fun.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202208011605439.webp","content":"<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><img src=\"http://t-blog-images.aijs.top/img/202208011605439.webp\" style=\"max-width: 100%; width: 600px\" />\n\n\n<h2 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>arguments 对象不是一个 Array 。它类似于 Array，但除了 length 属性和索引元素之外没有任何 Array 属性</p></blockquote>\n<h3 id=\"使用数组方法\"><a href=\"#使用数组方法\" class=\"headerlink\" title=\"使用数组方法\"></a>使用数组方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Array.prototype.slice.call\nfunction myConcat(separator) &#123;\n  var args &#x3D; Array.prototype.slice.call(arguments, 1);\n  return args.join(separator);\n&#125;</code></pre>\n\n<h3 id=\"转化成真实数组\"><a href=\"#转化成真实数组\" class=\"headerlink\" title=\"转化成真实数组\"></a>转化成真实数组</h3><p>可以使用<code>Array.from()</code>方法或<code>扩展运算符</code>将参数转换为真实数组：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var args &#x3D; Array.from(arguments);\nvar args &#x3D; [...arguments];</code></pre>\n\n<h3 id=\"参数影响\"><a href=\"#参数影响\" class=\"headerlink\" title=\"参数影响\"></a>参数影响</h3><h3 id=\"严格模式下，-无影响\"><a href=\"#严格模式下，-无影响\" class=\"headerlink\" title=\"严格模式下， 无影响\"></a>严格模式下， 无影响</h3><p>在严格模式下，<code>剩余参数</code>、<code>默认参数</code>和<code>解构赋值参数</code>的存在, <strong>不会改变 arguments 对象的行为, 不跟踪</strong>。<br><strong>示例 1</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\nfunction func(a) &#123;\n  arguments[0] &#x3D; 34;\n\n  console.log(a); &#x2F;&#x2F; 1\n  console.log(arguments[0]); &#x2F;&#x2F; 34\n&#125;\n\nfunc(1);</code></pre>\n\n<p><strong>示例 2</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\n\nfunction func(a &#x3D; 2) &#123;\n  arguments[0] &#x3D; 34;\n\n  console.log(arguments[0]); &#x2F;&#x2F;34\n  console.log(a); &#x2F;&#x2F; 3\n&#125;\n\nfunc(3);</code></pre>\n\n<h3 id=\"非严格模式，没有…，跟踪\"><a href=\"#非严格模式，没有…，跟踪\" class=\"headerlink\" title=\"非严格模式，没有…，跟踪\"></a>非严格模式，没有…，跟踪</h3><p><strong>非严格模式中</strong>, 函数 <strong>没有包含</strong> <code>剩余参数</code>、<code>默认参数</code>、<code>解构赋值</code>， <strong>arguments 对象中的值会跟踪参数的值</strong></p>\n<p><strong>示例 1:</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function func(a) &#123;\n  arguments[0] &#x3D; 99; &#x2F;&#x2F; 更新了 arguments[0] 同样更新了 a\n  console.log(a); &#x2F;&#x2F; 99\n  console.log(arguments[0]); &#x2F;&#x2F; 9\n&#125;\nfunc(10);</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function func(a) &#123;\n  a &#x3D; 99; &#x2F;&#x2F; 更新了 a 同样更新了 arguments[0]\n  console.log(a); &#x2F;&#x2F; 99\n  console.log(arguments[0]); &#x2F;&#x2F; 99\n&#125;\nfunc(10);</code></pre>\n\n<h3 id=\"非严格模式，有…，不跟踪\"><a href=\"#非严格模式，有…，不跟踪\" class=\"headerlink\" title=\"非严格模式，有…，不跟踪\"></a>非严格模式，有…，不跟踪</h3><p>当非严格模式中的函数, <strong>有包含</strong> <code>剩余参数</code>、<code>默认参数</code>、<code>解构赋值</code>， <strong>arguments 对象中的值不会跟踪参数的值</strong></p>\n<p><strong>示例 1:</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function func(a &#x3D; 55) &#123;\n  arguments[0] &#x3D; 99; &#x2F;&#x2F; updating arguments[0] does not also update a\n  console.log(a); &#x2F;&#x2F; 10\n  console.log(arguments[0]); &#x2F;&#x2F; 99\n&#125;\nfunc(10);</code></pre>\n\n<p><strong>示例 2:</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function func(a &#x3D; 55) &#123;\n  a &#x3D; 99; &#x2F;&#x2F; updating a does not also update arguments[0]\n  console.log(a); &#x2F;&#x2F; 99\n  console.log(arguments[0]); &#x2F;&#x2F; 10\n&#125;\nfunc(10);</code></pre>\n\n<p><strong>示例 3:</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function func(a &#x3D; 55) &#123;\n  console.log(a); &#x2F;&#x2F; 55\n  console.log(arguments[0]); &#x2F;&#x2F; undefined\n&#125;\nfunc();</code></pre>\n\n<h2 id=\"use-strict\"><a href=\"#use-strict\" class=\"headerlink\" title=\"use strict\"></a>use strict</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的 Javascript 做好铺垫。</li>\n</ul></blockquote>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p><strong>箭头函数表达式</strong>的语法比函数表达式更简洁，并且没有自己的 <code>this</code>，<code>arguments</code>，<code>super</code>, <code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它<code>不能用作构造函数</code>。<code>解析顺序也有区别</code>。</p>\n<h3 id=\"箭头函数与普通函数区别\"><a href=\"#箭头函数与普通函数区别\" class=\"headerlink\" title=\"箭头函数与普通函数区别\"></a>箭头函数与普通函数区别</h3><ul>\n<li>语法比函数表达式更简洁</li>\n<li>没有自己的 <code>this</code>，<code>arguments</code>，<code>super</code>, <code>new.target</code></li>\n<li>不能用 new 操作符号</li>\n<li>不能用作构造函数</li>\n<li>不能用 yield</li>\n<li>无 prototype 属性</li>\n<li>解析顺序也有区别</li>\n</ul>\n<h3 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 多参数\n(param1, param2, …, paramN) &#x3D;&gt; &#123; statements &#125;\n\n(param1, param2, …, paramN) &#x3D;&gt; expression\n&#x2F;&#x2F;相当于：(param1, param2, …, paramN) &#x3D;&gt;&#123; return expression; &#125;\n\n\n&#x2F;&#x2F; 单参数\n\n&#x2F;&#x2F; 当只有一个参数时，圆括号是可选的：\n(singleParam) &#x3D;&gt; &#123; statements &#125;\nsingleParam &#x3D;&gt; &#123; statements &#125;\n\n&#x2F;&#x2F; 无参数\n\n&#x2F;&#x2F; 没有参数的函数应该写成一对圆括号。\n() &#x3D;&gt; &#123; statements &#125;\n</code></pre>\n\n<h3 id=\"高级语法\"><a href=\"#高级语法\" class=\"headerlink\" title=\"高级语法\"></a>高级语法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;加括号的函数体, 返回对象字面量表达式：\nparams &#x3D;&gt; (&#123;foo: bar&#125;) &#x2F;&#x2F; 返回 &#123;foo: bar&#125;， 不加 () 函数默认返回undefine\n\n&#x2F;&#x2F;支持剩余参数、默认参数\n(param1, param2, ...rest) &#x3D;&gt; &#123; statements &#125;\n(param1 &#x3D; defaultValue1, param2, …, paramN &#x3D; defaultValueN) &#x3D;&gt; &#123;statements &#125;\n\n&#x2F;&#x2F;同样支持参数列表解构\nlet f &#x3D; ([a, b] &#x3D; [1, 2], &#123;x: c&#125; &#x3D; &#123;x: a + b&#125;) &#x3D;&gt; a + b + c;\nf();  &#x2F;&#x2F; 6</code></pre>\n\n<h3 id=\"没有单独的-this\"><a href=\"#没有单独的-this\" class=\"headerlink\" title=\"没有单独的 this\"></a>没有单独的 this</h3><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：</p>\n<ul>\n<li>如果该函数是一个构造函数，this 指针指向一个新的对象</li>\n<li>在严格模式下的函数调用下，this 指向 undefined</li>\n<li>如果该函数是一个对象的方法，则它的 this 指针指向这个对象</li>\n<li>等等</li>\n</ul>\n<h3 id=\"不受限严格模式的-this-规则\"><a href=\"#不受限严格模式的-this-规则\" class=\"headerlink\" title=\"不受限严格模式的 this 规则\"></a>不受限严格模式的 this 规则</h3><p>鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。</p>\n<p><span style=\"color: red\">箭头函数中 this 是语法层面的</span></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var f &#x3D; () &#x3D;&gt; &#123;\n  &quot;use strict&quot;;\n  return this;\n&#125;;\nf() &#x3D;&#x3D;&#x3D; window; &#x2F;&#x2F; 或者 global</code></pre>\n\n<h3 id=\"通过-call-或-apply-调用\"><a href=\"#通过-call-或-apply-调用\" class=\"headerlink\" title=\"通过 call 或 apply 调用\"></a>通过 call 或 apply 调用</h3><p>由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this—译者注），他们的<strong>第一个参数会被忽略</strong>。（这种现象对于 bind 方法同样成立 — 译者注）</p>\n<h3 id=\"不绑定-arguments\"><a href=\"#不绑定-arguments\" class=\"headerlink\" title=\"不绑定 arguments\"></a>不绑定 arguments</h3><p>箭头函数不绑定 Arguments 对象。</p>\n<p><strong>可以使用剩余参数</strong></p>\n<h3 id=\"使用箭头函数作为方法\"><a href=\"#使用箭头函数作为方法\" class=\"headerlink\" title=\"使用箭头函数作为方法\"></a>使用箭头函数作为方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\nvar obj &#x3D; &#123;\n  i: 10,\n  b: () &#x3D;&gt; console.log(this.i, this), &#x2F;&#x2F; 并不指向对象\n  c: function () &#123;\n    console.log(this.i, this);\n  &#125;,\n&#125;;\nobj.b();\n&#x2F;&#x2F; undefined, Window&#123;...&#125;\nobj.c();\n&#x2F;&#x2F; 10, Object &#123;...&#125;</code></pre>\n\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\nvar obj &#x3D; &#123;\n  a: 10,\n&#125;;\n\nObject.defineProperty(obj, &quot;b&quot;, &#123;\n  get: () &#x3D;&gt; &#123;\n    console.log(this.a, typeof this.a, this);\n    return this.a + 10;\n    &#x2F;&#x2F; 代表全局对象 &#39;Window&#39;, 因此 &#39;this.a&#39; 返回 &#39;undefined&#39;\n  &#125;,\n&#125;);\n\nobj.b; &#x2F;&#x2F; undefined   &quot;undefined&quot;   Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</code></pre>\n\n<h3 id=\"使用-new-操作符\"><a href=\"#使用-new-操作符\" class=\"headerlink\" title=\"使用 new 操作符\"></a>使用 new 操作符</h3><p>箭头函数不能用作构造器，和 new 一起用会抛出错误。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var Foo &#x3D; () &#x3D;&gt; &#123;&#125;;\nvar foo &#x3D; new Foo(); &#x2F;&#x2F; TypeError: Foo is not a constructor</code></pre>\n\n<h3 id=\"使用-prototype-属性\"><a href=\"#使用-prototype-属性\" class=\"headerlink\" title=\"使用 prototype 属性\"></a>使用 prototype 属性</h3><p>箭头函数没有 prototype 属性。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var Foo &#x3D; () &#x3D;&gt; &#123;&#125;;\nconsole.log(Foo.prototype); &#x2F;&#x2F; undefined</code></pre>\n\n<h3 id=\"使用-yield-关键字\"><a href=\"#使用-yield-关键字\" class=\"headerlink\" title=\"使用 yield 关键字\"></a>使用 yield 关键字</h3><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。</p>\n<h3 id=\"函数体\"><a href=\"#函数体\" class=\"headerlink\" title=\"函数体\"></a>函数体</h3><p>箭头函数可以有一个“简写体”或常见的“块体”。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var func &#x3D; (x) &#x3D;&gt; x * x;\n&#x2F;&#x2F; 简写函数 省略 return\n\nvar func &#x3D; (x, y) &#x3D;&gt; &#123;\n  return x + y;\n&#125;;\n&#x2F;&#x2F;常规编写 明确的返回值</code></pre>\n\n<h3 id=\"返回对象字面量\"><a href=\"#返回对象字面量\" class=\"headerlink\" title=\"返回对象字面量\"></a>返回对象字面量</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var func &#x3D; () &#x3D;&gt; &#123; foo: 1 &#125;;\n&#x2F;&#x2F; Calling func() returns undefined!\n\nvar func &#x3D; () &#x3D;&gt; &#123; foo: function() &#123;&#125; &#125;;\n&#x2F;&#x2F; SyntaxError: function statement requires a name\n</code></pre>\n\n<p>花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var func &#x3D; () &#x3D;&gt; (&#123; foo: 1 &#125;);</code></pre>\n\n<h3 id=\"注意换行\"><a href=\"#注意换行\" class=\"headerlink\" title=\"注意换行\"></a>注意换行</h3><p><span style=\"color: red\">幸运的是：vscode Prettier - Code formatter 插件，自动格式化代码</span></p>\n<p><strong>箭头函数在参数和箭头之间不能换行。</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var func &#x3D; ()\n           &#x3D;&gt; 1;\n&#x2F;&#x2F; SyntaxError: expected expression, got &#39;&#x3D;&gt;&#39;</code></pre>\n\n<p><strong>可以通过在 ‘&#x3D;&gt;’ 之后换行，或者用 ‘( )’、’{ }’来实现换行，如下：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var func &#x3D; (a, b, c) &#x3D;&gt;\n  1;\n\nvar func &#x3D; (a, b, c) &#x3D;&gt; (\n  1\n);\n\nvar func &#x3D; (a, b, c) &#x3D;&gt; &#123;\n  return 1\n&#125;;\n\nvar func &#x3D; (\n  a,\n  b,\n  c\n) &#x3D;&gt; 1;\n\n&#x2F;&#x2F; 不会有语法错误\n</code></pre>\n\n<h3 id=\"不同于普通函数的解析顺序\"><a href=\"#不同于普通函数的解析顺序\" class=\"headerlink\" title=\"不同于普通函数的解析顺序\"></a>不同于普通函数的解析顺序</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let callback;\n\ncallback &#x3D; callback || function() &#123;&#125;; &#x2F;&#x2F; ok\n\ncallback &#x3D; callback || () &#x3D;&gt; &#123;&#125;;\n&#x2F;&#x2F; SyntaxError: invalid arrow-function arguments\n\ncallback &#x3D; callback || (() &#x3D;&gt; &#123;&#125;);    &#x2F;&#x2F; ok</code></pre>\n\n<h3 id=\"箭头函数可以使用条件（三元）运算符\"><a href=\"#箭头函数可以使用条件（三元）运算符\" class=\"headerlink\" title=\"箭头函数可以使用条件（三元）运算符\"></a>箭头函数可以使用条件（三元）运算符</h3><h3 id=\"箭头函数可以使用闭包\"><a href=\"#箭头函数可以使用闭包\" class=\"headerlink\" title=\"箭头函数可以使用闭包\"></a>箭头函数可以使用闭包</h3><h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments\" target=\"_blank\" >Web 开发技术&#x2F;JavaScript&#x2F;JavaScript 参考&#x2F;函数&#x2F;arguments 对象</a></p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html\" target=\"_blank\" >Javascript 严格模式详解</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" >Web 开发技术&#x2F;JavaScript&#x2F;JavaScript 参考&#x2F;函数&#x2F;箭头函数</a></p>\n","text":"思维导图 arguments arguments 对象不是一个 Array 。它类似于 Array，但除了 length 属性和索引元素之外没有任何 Array 属性 使用数组方法&#x2F;&#x2F; Array.prototype.slice.call function m...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":40,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":42,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">思维导图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#arguments\"><span class=\"toc-text\">arguments</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用数组方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E5%8C%96%E6%88%90%E7%9C%9F%E5%AE%9E%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">转化成真实数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">参数影响</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C-%E6%97%A0%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">严格模式下， 无影响</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B2%A1%E6%9C%89%E2%80%A6%EF%BC%8C%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">非严格模式，没有…，跟踪</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9C%89%E2%80%A6%EF%BC%8C%E4%B8%8D%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">非严格模式，有…，不跟踪</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#use-strict\"><span class=\"toc-text\">use strict</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">箭头函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">箭头函数与普通函数区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">基础语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">高级语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E6%9C%89%E5%8D%95%E7%8B%AC%E7%9A%84-this\"><span class=\"toc-text\">没有单独的 this</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%97%E9%99%90%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84-this-%E8%A7%84%E5%88%99\"><span class=\"toc-text\">不受限严格模式的 this 规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87-call-%E6%88%96-apply-%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">通过 call 或 apply 调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E7%BB%91%E5%AE%9A-arguments\"><span class=\"toc-text\">不绑定 arguments</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用箭头函数作为方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-defineProperty\"><span class=\"toc-text\">Object.defineProperty</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-new-%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">使用 new 操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-prototype-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">使用 prototype 属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-yield-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">使用 yield 关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BD%93\"><span class=\"toc-text\">函数体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">返回对象字面量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E6%8D%A2%E8%A1%8C\"><span class=\"toc-text\">注意换行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E4%BA%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">不同于普通函数的解析顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%EF%BC%88%E4%B8%89%E5%85%83%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">箭头函数可以使用条件（三元）运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">箭头函数可以使用闭包</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-js 闭包","uid":"c29bc77697ff47f9bbee179892d7fe85","slug":"2022-07-28js-closures","date":"2022-07-28T10:04:36.000Z","updated":"2022-09-16T13:54:56.229Z","comments":true,"path":"api/articles/2022-07-28js-closures.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202207291656804.webp","text":"思维导图 闭包一个函数 和 对其周围状态（lexical environment，词法环境）的引用, 捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） 也就是说，闭包让你可以在一个内层函数中 访问到 其外层函数的作用域。在形式上体现为函数嵌套，内层函数有外...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":40,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":42,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-性能优化2","uid":"0ba6682e606bc81869a1a00491028270","slug":"2022-07-27性能优化","date":"2022-07-27T05:55:15.000Z","updated":"2022-10-17T11:18:29.856Z","comments":true,"path":"api/articles/2022-07-27性能优化.json","keywords":null,"cover":null,"text":"为什么速度很重要 用户要求变高，爱挑毛病 性能是留住用户的关键 性能意味着提高转化率 性能关乎用户体验 性能影响人们 查看更多 消费者越来越依赖移动设备来访问数字内容和服务，如果您查看自己站点的分析，可能会看到这个故事正在您自己的数据中上演。消费者也比以往任何时候都要求更高，当他...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":40,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":42,"path":"api/tags/前端基础.json"},{"name":"performance","slug":"performance","count":2,"path":"api/tags/performance.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}