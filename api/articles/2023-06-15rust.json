{"title":"Rust","uid":"cbad4469cc24cd0d14f8d940cd23f710","slug":"2023-06-15rust","date":"2023-06-15T08:21:09.000Z","updated":"2023-07-08T01:06:25.362Z","comments":true,"path":"api/articles/2023-06-15rust.json","keywords":null,"cover":[],"content":"<h1 id=\"Rustaceans-是啥\"><a href=\"#Rustaceans-是啥\" class=\"headerlink\" title=\"Rustaceans 是啥\"></a>Rustaceans 是啥</h1><p>Rustaceans 是 Rust 社区的成员，包括 Rust 的开发者、用户、贡献者、爱好者等。这个词来源于 Rust 的 Logo 中的小螃蟹（Crab），因此称 Rust 的使用者为 Rustaceans。</p>\n<p>Rust 社区非常活跃，拥有众多的 Rustaceans，他们积极参与 Rust 编程语言的发展和推广，为 Rust 提供各种贡献，例如：</p>\n<ul>\n<li>提交 Rust 的 Bug 报告，帮助改善 Rust 的质量和性能；</li>\n<li>编写 Rust 的开发文档和教程，帮助新手学习 Rust；</li>\n<li>对 Rust 编程语言进行贡献（例如提交代码、修复 Bug、增加新功能等）；</li>\n<li>使用 Rust 开发自己的项目，推广 Rust 的应用领域；</li>\n<li>参与 Rust 社区的讨论和互动，为 Rust 的未来发展提出建设性的意见和建议等。</li>\n</ul>\n<p>Rustaceans 是 Rust 社区中非常有影响力的力量，他们的活跃和贡献是 Rust 发展的重要动力。</p>\n<h1 id=\"golang-为什么比其他语言快？\"><a href=\"#golang-为什么比其他语言快？\" class=\"headerlink\" title=\"golang 为什么比其他语言快？\"></a>golang 为什么比其他语言快？</h1><p>Golang 相比其他语言在某些情况下可能表现更快的原因如下：</p>\n<p><strong>1. 并发模型：</strong> Golang 的并发模型是通过轻量级的 goroutine 和通信机制（channel）实现的。这种并发模型可以更高效地利用多核处理器，并且对于大规模的并发任务有良好的扩展性。相比之下，一些传统语言如 Java 或 C++ 的线程模型可能引入较大的线程开销。</p>\n<p><strong>2. 自动垃圾回收（Garbage Collection）：</strong> Golang 使用自动垃圾回收机制，能够自动管理内存的分配和释放，避免了手动内存管理所可能带来的错误和复杂性。尽管垃圾回收有一定的运行时开销，但在大多数情况下，Golang 的垃圾回收机制能够以高效的方式运行，不会明显影响性能。</p>\n<p><strong>3. 编译器优化：</strong> Golang 编译器具有强大的优化能力，它可以进行内联、逃逸分析、循环展开等一系列的优化操作。这些优化可以在编译阶段产生更高效的机器代码，提高程序的执行效率。</p>\n<p><strong>4. 高效的标准库：</strong> Golang 的标准库提供了丰富的功能和高性能的实现，使得开发者可以使用更高层次的抽象来完成任务，而无需自己从头构建。这些高效的标准库能够提供性能优化和并发支持，进一步提高应用程序的执行速度。</p>\n<p>需要注意的是，性能的比较是一个复杂的问题，受到多个因素的影响，如应用程序的特性、数据访问模式、编程技巧等。因此，并非在所有方面和所有场景下，Golang 都比其他语言更快。在选择编程语言时，除了性能因素，还需要综合考虑其他因素，如开发效率、语言特性和社区支持等。</p>\n<h1 id=\"rust-为什么比-golang-还快\"><a href=\"#rust-为什么比-golang-还快\" class=\"headerlink\" title=\"rust 为什么比 golang 还快\"></a>rust 为什么比 golang 还快</h1><p>Rust 和 Golang 都是相对高性能的编程语言，但是 Rust 在一些情况下可能会比 Golang 更快。以下是一些原因：</p>\n<p><strong>1. 零成本抽象和系统级控制：</strong> Rust 通过零成本抽象的特性提供了对系统级编程的支持，允许开发者直接控制内存布局和低级别细节。这使得 Rust 在性能敏感的场景下仍能产生高效的代码。</p>\n<p><strong>2. 编译时内存管理：</strong> Rust 的所有权和借用机制使编译器能够在编译时进行静态分析，确保内存管理的安全性，避免了运行时开销和额外的垃圾回收操作。相比之下，Golang 使用垃圾回收机制来管理内存，这可能会引入一定程度的运行时开销。</p>\n<p><strong>3. 高级优化：</strong> Rust 的编译器在优化代码方面非常强大。它可以进行一系列的优化，如内联、循环展开、无用代码消除等。这些优化会导致生成更高效的机器代码，从而提高运行时性能。</p>\n<p><strong>4. 线程和并发：</strong> Rust 的并发模型更加灵活且细粒度，通过所有权和借用机制，Rust 可以在编译时保证线程安全性，避免了数据竞争。这使得 Rust 在高并发场景下更容易编写正确且高效的并发代码。</p>\n<p>需要注意的是，性能的比较实际上取决于具体的应用场景和问题的规模。在某些情况下，Golang 的并发模型和简洁的语法可能更适合特定的应用程序。因此，在选择语言时，除了性能因素，还需要考虑其他因素，如开发效率、内置库的支持和社区生态系统的成熟度。</p>\n<h1 id=\"零成本抽象-是啥\"><a href=\"#零成本抽象-是啥\" class=\"headerlink\" title=\"零成本抽象 是啥\"></a>零成本抽象 是啥</h1><p>零成本抽象（Zero-cost abstraction）是指在编程语言中使用抽象编程概念（如函数、类、接口等）时，不会引入额外的运行时开销或性能损失。换句话说，使用抽象不会让程序变慢或增加额外的资源消耗。</p>\n<p>这个概念在计算机科学中非常重要，因为它允许开发者使用高级的、易于理解和维护的抽象概念来编写代码，而不必担心性能问题。一种好的编程语言或框架应该提供零成本抽象的特性，使得程序员能够以简洁的方式表达复杂的逻辑，而不用过多关注底层细节和性能优化。</p>\n<p>零成本抽象的实现通常依赖于编译器优化和底层的运行时系统。编译器可以在编译阶段对抽象代码进行优化，例如内联函数、消除不必要的抽象层次、循环展开等，以减少运行时的开销。同时，底层的运行时系统可以提供高效的抽象实现，如虚函数表、动态分派等，以保证在运行时的性能。</p>\n<p>通过提供零成本抽象，编程语言可以实现高级抽象和编程模型，同时保持良好的性能特性，提高开发效率和代码可维护性。</p>\n<h1 id=\"rust-上手难度远大于-golang\"><a href=\"#rust-上手难度远大于-golang\" class=\"headerlink\" title=\"rust 上手难度远大于 golang\"></a>rust 上手难度远大于 golang</h1><p>Rust 和 Go 两种语言难度略有不同，具体哪种更难取决于使用者的编程背景和需求。</p>\n<p>相较于 Go，Rust 对编程语言的高级概念和底层机制的理解要求更高。Rust 的语法和类型系统比较复杂，涉及到的知识点比较多，例如所有权模型、借用规则等，在初学阶段会让使用者感到比较困惑。此外，Rust 倡导安全性和并发性，这也加大了初学者的学习难度。</p>\n<p>但是，Rust 同时也提供了很多高级特性和工具，例如闭包和迭代器，使得代码更加简洁有力；线程和异步编程库，使得并发编程更加容易实现和维护。因此，在一些应用场景下，使用 Rust 可以提供比 Go 更好的性能和可靠性。</p>\n<p>总的来说，Rust 的上手难度确实比 Go 稍高，但两种语言都有各自的优势和适用场景，用户应根据自己的需求和经验选择合适的语言。</p>\n<h1 id=\"rust-和-go-各自适用场景\"><a href=\"#rust-和-go-各自适用场景\" class=\"headerlink\" title=\"rust 和 go 各自适用场景\"></a>rust 和 go 各自适用场景</h1><p>Rust 和 Go 两种语言各自有不同的适用场景，下面是它们的主要特点及使用场景：</p>\n<h2 id=\"Rust-的适用场景\"><a href=\"#Rust-的适用场景\" class=\"headerlink\" title=\"Rust 的适用场景\"></a>Rust 的适用场景</h2><ul>\n<li><p><strong>高性能的系统编程</strong>：Rust 以安全和效率为主要目标，内置了语言级别的并发和内存管理机制。因此，Rust 很适合用于编写高效且安全的系统级别程序，如操作系统、网络通信、嵌入式设备等。</p>\n</li>\n<li><p><strong>开发可靠的网络服务</strong>：Rust 的高性能以及丰富的并发和异步编程库，使得它成为一款开发高可用、高并发、而又高效的网络服务的强力工具。例如 Rust 最流行的框架 actix-web 就是用 Rust 写的。</p>\n</li>\n<li><p><strong>加速现有代码</strong>：Rust 提供了 FFI（Foreign Function Interface）特性，使得它可以轻松地调用基于 C&#x2F;C++ 编写的库，从而优化现有的代码。</p>\n</li>\n</ul>\n<h2 id=\"Go-的适用场景\"><a href=\"#Go-的适用场景\" class=\"headerlink\" title=\"Go 的适用场景\"></a>Go 的适用场景</h2><ul>\n<li><p><strong>快速开发网络服务</strong>：Go 的语言设计和生态系统使得它非常适合用于开发各种类型的网络服务。Go 标准库已经提供了很好的 HTTP 和 TCP 实现，同时第三方库如 Gin，Echo 和 Beego 等，可以提供更加丰富的功能。</p>\n</li>\n<li><p><strong>大数据处理和并发编程</strong>：Go 通过 goroutines 和 channel 等原生特性，使并发编程更加简单。同时，Go 计算性能也非常出色，能够高效地处理大数据、高并发的处理任务，这使得它成为一款优秀的数据处理语言。</p>\n</li>\n<li><p><strong>工具开发和脚本编写</strong>：Go 的语法设计简单易懂，同时开发工具非常成熟，因此适合用于编写工具、脚本等。很多知名的工具如 Docker、Kubernetes、Hugo 和 Hugo 等均是使用 Go 语言开发的。</p>\n</li>\n</ul>\n<p>总的来说，Rust 和 Go 各自的适用场景是比较明显的，用户应根据自己的需求和开发经验选择合适的语言。</p>\n<h1 id=\"rust-web-开发框架\"><a href=\"#rust-web-开发框架\" class=\"headerlink\" title=\"rust web 开发框架\"></a>rust web 开发框架</h1><p>以下是 Rust 的一些 Web 开发框架：</p>\n<ol>\n<li><p><strong>Actix-web</strong>：Actix-web 是目前 Rust 生态中最受欢迎的 Web 框架之一，它基于 actor 模型和异步编程，具有高性能、可伸缩等优点。</p>\n</li>\n<li><p><strong>Rocket</strong>：Rocket 是 Rust 中一款非常受欢迎的 Web 框架，通过 Rust 的宏系统和特定的设计模式使得 Web 开发变得很简单。</p>\n</li>\n<li><p><strong>Gotham</strong>：Gotham 是一款基于 Rust 编写的 Web 框架，通过 middleware 和 Rust 的 result 和 error 类型来实现高效、易用的 Web 应用程序开发。</p>\n</li>\n<li><p><strong>Tide</strong>：Tide 是一款高效、易用的 Web 框架，它支持 Rust 的异步运行时，具有高性能和可伸缩性。</p>\n</li>\n<li><p><strong>Warp</strong>：Warp 是一款基于 Rust 编写的 Web 框架，与其它框架相比，它注重开发人员的开发体验。</p>\n</li>\n</ol>\n<p>总的来说，Rust 中的 Web 框架的数量和质量在不断提升，开发人员可以根据自己的需求和技术水平选择合适的框架。</p>\n<h1 id=\"orm\"><a href=\"#orm\" class=\"headerlink\" title=\"orm\"></a>orm</h1><p>Rust 生态中常见的 ORM 框架有如下几个：</p>\n<ul>\n<li>Diesel：一个类型安全的 SQL 查询构建器和对象关系映射器。它使用 Rust 类型系统来避免 SQL 注入攻击，并提供与多个后端数据库 (PostgreSQL、MySQL、SQLite、MSSQL) 的完整集成。截至 2021 年 11 月，其 GitHub 仓库的 star 数量为 13.3k。</li>\n<li>SQLx：一个异步运行时的异构 SQL 数据库框架，可与各种后端数据库 (PostgreSQL、MySQL、SQLite、MSSQL) 一起使用。SQLx 支持编译时检查的 SQL 查询并提供一些有用的功能，如连接池和多行查询支持。截至 2021 年 11 月，其 GitHub 仓库的 star 数量为 8.8k。</li>\n<li>Anyhow：一个用于处理错误链的库，它在与其他 ORM 框架配合使用时非常有用。Anyhow 可以处理多种类型的错误并提供友好的错误信息。截至 2021 年 11 月，其 GitHub 仓库的 star 数量为 4.2k。</li>\n</ul>\n<p>可以看出，Diesel 是 Rust 生态中最受欢迎的 ORM 框架，其 star 数量远超其他框架。</p>\n<h1 id=\"rust-和-go-哪个并发更强\"><a href=\"#rust-和-go-哪个并发更强\" class=\"headerlink\" title=\"rust 和 go 哪个并发更强\"></a>rust 和 go 哪个并发更强</h1><p>Rust 和 Go 都是非常擅长并发编程的编程语言，但它们的并发模型略有不同。因此，需要根据具体情况来判断哪个并发性能更强。</p>\n<p>Go 的并发模型基于 Goroutine 和 Channel。Goroutine 是 Go 中轻量级的线程，可以在同一进程内同时运行成千上万个 Goroutine。Channel 是一种同步通信的机制，用于在 Goroutine 之间传递数据。</p>\n<p>Rust 的并发模型基于 Actor 模式和消息传递，在 Rust 中可以使用诸如 Tokio 或 Actix 等工具进行异步编程。Rust 的并发编程也可以通过使用线程和消息传递的方式来实现。</p>\n<p>由于 Rust 和 Go 都有非常强大的并发相关特性，因此很难直接比较它们的并发性能。实际上，它们在不同的领域中都有其独特的优势和适用性。</p>\n<p>总体而言，Go 的并发性能在网络编程方面相对于 Rust 更加突出，因为它以 Goroutine 和 Channel 为基础，可以非常方便地实现高效的异步并发编程。而 Rust 的并发性能则在可靠性和安全性方面更加优越，因为它提供了类型安全和无数据竞争保证，可以避免很多常见的并发问题。</p>\n<h2 id=\"Rust-程序设计语言-简体中文版\"><a href=\"#Rust-程序设计语言-简体中文版\" class=\"headerlink\" title=\"Rust 程序设计语言 简体中文版\"></a>Rust 程序设计语言 简体中文版</h2><p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html\" target=\"_blank\" >Rust 程序设计语言 简体中文版</a></p>\n<h2 id=\"Rust-安装完命令行需要重启\"><a href=\"#Rust-安装完命令行需要重启\" class=\"headerlink\" title=\"Rust 安装完命令行需要重启\"></a>Rust 安装完命令行需要重启</h2><img src=\"http://t-blog-images.aijs.top/img/202306151621582.webp\" />\n\n<h2 id=\"vscode-没有语法提示\"><a href=\"#vscode-没有语法提示\" class=\"headerlink\" title=\"vscode 没有语法提示\"></a>vscode 没有语法提示</h2><pre class=\"line-numbers language-Rust\" data-language=\"Rust\"><code class=\"language-Rust\">&#x2F;&#x2F; 1. 确保你已经安装了 Rust 工具链：Rustup 和 Cargo\n&#x2F;&#x2F;  rustup --version\n&#x2F;&#x2F;  cargo --version\n\n\n&#x2F;&#x2F; rustup 1.26.0 (5af9b9484 2023-04-05)\n&#x2F;&#x2F; info: This is the version for the rustup toolchain manager, not the rustc compiler.\n&#x2F;&#x2F; info: The currently active &#96;rustc&#96; version is &#96;rustc 1.70.0 (90c541806 2023-05-31)&#96;\n&#x2F;&#x2F; cargo 1.70.0 (ec8a8a0ca 2023-04-25)\n\n&#x2F;&#x2F; 2. 确保你已经安装了 RLS（Rust Language Server）\n&#x2F;&#x2F; rustup component add rls rust-analysis rust-src</code></pre>\n\n<h3 id=\"rust-analyzer-插件报错\"><a href=\"#rust-analyzer-插件报错\" class=\"headerlink\" title=\"rust_analyzer 插件报错\"></a>rust_analyzer 插件报错</h3><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; [ERROR rust_analyzer::config] failed to find any projects in [AbsPathBuf(&quot;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;rust-demo&quot;)]\n&#x2F;&#x2F; [ERROR rust_analyzer::main_loop] FetchWorkspaceError:\n&#x2F;&#x2F; rust-analyzer failed to discover workspace\n</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202306151655399.webp\" />\n\n<h3 id=\"rust-代码自动格式化\"><a href=\"#rust-代码自动格式化\" class=\"headerlink\" title=\"rust 代码自动格式化\"></a>rust 代码自动格式化</h3><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#x2F;&#x2F; settings.json\n &quot;[rust]&quot;: &#123;\n      &quot;editor.defaultFormatter&quot;: &quot;rust-lang.rust-analyzer&quot;,\n      &quot;editor.formatOnSave&quot;: true\n  &#125;</code></pre>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><img src=\"http://t-blog-images.aijs.top/img/202306151700743.webp\" />\n\n<h3 id=\"cargo-new-variables\"><a href=\"#cargo-new-variables\" class=\"headerlink\" title=\"cargo new variables\"></a>cargo new variables</h3><img src=\"http://t-blog-images.aijs.top/img/202306151705038.webp\" />\n\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; let x &#x3D; 5; &#x2F;&#x2F; 不可变量\n&#x2F;&#x2F; let mut x &#x3D; 5; &#x2F;&#x2F; 变量\n&#x2F;&#x2F; const THREE_HOURS_IN_SECONDS: u32 &#x3D; 60 * 60 * 3;\n&#x2F;&#x2F;  1. 声明常量使用 const 关键字而不是 let，并且 必须 注明值的类型\n&#x2F;&#x2F;  2. Rust 对常量的命名约定是在单词之间使用全大写加下划线</code></pre>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ol>\n<li>整型</li>\n<li>浮点型</li>\n<li>布尔型</li>\n<li>字符类型 <code>&#39;&#39;单引号的是字符，双引号的是字符串</code></li>\n<li>元组类型</li>\n<li>数组类型</li>\n</ol>\n<h3 id=\"作用域（隐藏）\"><a href=\"#作用域（隐藏）\" class=\"headerlink\" title=\"作用域（隐藏）\"></a>作用域（隐藏）</h3><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let x &#x3D; 5;\n\n    let x &#x3D; x + 1; &#x2F;&#x2F; 这个与es6的区别， 这里叫隐藏变量\n\n    &#123;\n        let x &#x3D; x * 2;\n        println!(&quot;The value of x in the inner scope is: &#123;x&#125;&quot;);\n    &#125;\n\n    println!(&quot;The value of x is: &#123;x&#125;&quot;); &#x2F;&#x2F; 结果看上去有点奇怪\n&#125;\n\n&#x2F;&#x2F; $ cargo run\n&#x2F;&#x2F;    Compiling variables v0.1.0 (file:&#x2F;&#x2F;&#x2F;projects&#x2F;variables)\n&#x2F;&#x2F;     Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n&#x2F;&#x2F;      Running &#96;target&#x2F;debug&#x2F;variables&#96;\n&#x2F;&#x2F; The value of x in the inner scope is: 12\n&#x2F;&#x2F; The value of x is: 6\n\n</code></pre>\n\n<h3 id=\"隐藏与将变量标记为-mut-是有区别的\"><a href=\"#隐藏与将变量标记为-mut-是有区别的\" class=\"headerlink\" title=\"隐藏与将变量标记为 mut 是有区别的\"></a>隐藏与将变量标记为 mut 是有区别的</h3><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 1. 隐藏 是两个变量，类型可以不同\n&#x2F;&#x2F; 2. mut 是一个变量，类型必须相同</code></pre>\n\n<h3 id=\"表达式与语句\"><a href=\"#表达式与语句\" class=\"headerlink\" title=\"表达式与语句\"></a>表达式与语句</h3><p>表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值<br>一段代码后有<code>;</code> - 是语句 - 无返回值<br>一段代码后无<code>;</code> - 是表达式 - 有返回值</p>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h3><ol>\n<li>在箭头（-&gt;）后声明它的类型</li>\n<li>不对返回值命名</li>\n<li>最后一行默认返回</li>\n<li><code>return</code> 可以提前返回</li>\n<li>有<code>;</code> - 是语句 - 无返回值， 无<code>;</code> - 是表达式 - 有返回值 （可以理解为给分隔了，返回不了）</li>\n</ol>\n<p>备注： 除了是 golang 的 阉割版，尾部的<code>;</code>就是来捣乱的，诡异 “表达式与语句”</p>\n<h3 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h3><h4 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if else\"></a>if else</h4><p>条件 必须 是 bool 值</p>\n<h4 id=\"循环-loop、while-和-for\"><a href=\"#循环-loop、while-和-for\" class=\"headerlink\" title=\"循环 loop、while 和 for\"></a>循环 loop、while 和 for</h4><ol start=\"3\">\n<li>for</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F; for element in a &#123;\n\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; for number in (1..4).rev() &#123;\n\n&#x2F;&#x2F; &#125;</code></pre>\n\n<h2 id=\"所有权\"><a href=\"#所有权\" class=\"headerlink\" title=\"所有权\"></a>所有权</h2><h3 id=\"所有权与变量\"><a href=\"#所有权与变量\" class=\"headerlink\" title=\"所有权与变量\"></a>所有权与变量</h3><p>规则：</p>\n<ol>\n<li>Rust 中的每一个值都有一个 所有者（owner）。</li>\n<li>值在任一时刻有且只有一个所有者。</li>\n<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop）<br><a href=\"https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#:~:text=%E5%BD%93%20s%20%E7%A6%BB%E5%BC%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%97%B6%E5%80%99%E3%80%82%E5%BD%93%E5%8F%98%E9%87%8F%E7%A6%BB%E5%BC%80%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8CRust%20%E4%B8%BA%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%82%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8F%AB%E5%81%9A%20drop\" target=\"_blank\" >见</a></p>\n<p>在更复杂的场景下代码的行为可能是不可预测的(这个坑有点大，稍不注意就被回收了)</p></blockquote>\n<img src=\"http://t-blog-images.aijs.top/img/202306151814103.webp\" />\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F; 移动\n\nlet s1 &#x3D; String::from(&quot;hello&quot;);\nlet s2 &#x3D; s1; &#x2F;&#x2F; 这个搞完之后s1就用不了了\n\n&#x2F;&#x2F; 如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。\n&#x2F;&#x2F; 不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是叫做浅拷贝\n\n\n\n&#x2F;&#x2F; 注意：\n\n&#x2F;&#x2F; 只在栈上的数据：拷贝\n\nfn main() &#123;\n    let x &#x3D; 5;\n    let y &#x3D; x;\n\n    println!(&quot;x &#x3D; &#123;&#125;, y &#x3D; &#123;&#125;&quot;, x, y);\n&#125;\n&#x2F;&#x2F; 这段代码是ok的\n\n\n\n&#x2F;&#x2F; Copy trait 的特殊注解， 拷贝 非 移动</code></pre>\n\n<h3 id=\"所有权与函数\"><a href=\"#所有权与函数\" class=\"headerlink\" title=\"所有权与函数\"></a>所有权与函数</h3><p>非简单数据类型被传入函数后，原变量所有权丢失</p>\n<h3 id=\"引用（references）\"><a href=\"#引用（references）\" class=\"headerlink\" title=\"引用（references）\"></a>引用（references）</h3><p>为了解决 非简单数据类型在被使用后，所有权丢失的问题</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 这..., golang 的指针 &#96;&amp;s1&#96;\n&#x2F;&#x2F; 用一个（新的）calculate_length 函数，它以一个对象的引用作为参数而不是获取值的所有权\n\nfn main() &#123;\n    let s1 &#x3D; String::from(&quot;hello&quot;);\n\n    let len &#x3D; calculate_length(&amp;s1);\n\n    println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s1, len);\n&#125;\n\nfn calculate_length(s: &amp;String) -&gt; usize &#123;\n    s.len()\n&#125;\n\n&#x2F;&#x2F; &amp; 符号就是 引用</code></pre>\n\n<h3 id=\"借用\"><a href=\"#借用\" class=\"headerlink\" title=\"借用\"></a>借用</h3><p>一个函数使用一个变量的地址，用完后，就用完了，这个用叫做：借用</p>\n<h3 id=\"可变引用\"><a href=\"#可变引用\" class=\"headerlink\" title=\"可变引用\"></a>可变引用</h3><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 1. 允许我们修改一个借用的值，这就是 可变引用（mutable reference）\nfn main() &#123;\n    let mut s &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; mut\n\n    change(&amp;mut s); &#x2F;&#x2F; &amp;mut s\n&#125;\n\nfn change(some_string: &amp;mut String) &#123; &#x2F;&#x2F; &amp;mut String\n    some_string.push_str(&quot;, world&quot;);\n&#125;\n\n\n&#x2F;&#x2F; 2. 可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用\n\nfn main() &#123;\n    let mut s &#x3D; String::from(&quot;hello&quot;);\n\n    let r1 &#x3D; &amp;mut s; &#x2F;&#x2F; r1对s有了可变引用\n    let r2 &#x3D; &amp;mut s; &#x2F;&#x2F; 再创建r2对该变量的引用,是不被允许的，可以理解为，一个东西只能借给一个人\n&#x2F;&#x2F; 注意：不能在同一时间多次将 s 作为可变变量借用\n&#x2F;&#x2F; 这个限制的好处是 Rust 可以在编译时就避免数据竞争\n    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);\n&#125;\n</code></pre>\n\n<h3 id=\"数据竞争（data-race）类似于竞态条件，它可由这三个行为造成：\"><a href=\"#数据竞争（data-race）类似于竞态条件，它可由这三个行为造成：\" class=\"headerlink\" title=\"数据竞争（data race）类似于竞态条件，它可由这三个行为造成：\"></a>数据竞争（data race）类似于竞态条件，它可由这三个行为造成：</h3><ol>\n<li>两个或更多指针同时访问同一数据。</li>\n<li>至少有一个指针被用来写入数据。</li>\n<li>没有同步数据访问的机制。</li>\n</ol>\n<p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；<strong>Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</strong></p>\n<p><strong>使用上</strong></p>\n<ol>\n<li>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 同时 拥有</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let mut s &#x3D; String::from(&quot;hello&quot;);\n\n    &#123;\n        let r1 &#x3D; &amp;mut s;\n    &#125; &#x2F;&#x2F; r1 在这里离开了作用域，所以我们完全可以创建一个新的引用\n\n    let r2 &#x3D; &amp;mut s;\n&#125;\n</code></pre>\n\n<ol start=\"2\">\n<li>Rust 在同时<strong>使用可变与不可变引用时</strong>也采用的类似的规则。这些代码会导致一个错误：</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let mut s &#x3D; String::from(&quot;hello&quot;);\n\n    let r1 &#x3D; &amp;s; &#x2F;&#x2F; 没问题\n    let r2 &#x3D; &amp;s; &#x2F;&#x2F; 没问题\n    let r3 &#x3D; &amp;mut s; &#x2F;&#x2F; 大问题\n\n    println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);\n&#125;\n</code></pre>\n\n<ol start=\"3\">\n<li><p>然而，多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。</p>\n</li>\n<li><p>注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。例如，因为最后一次使用不可变引用<code>（println!)</code>，发生在声明可变引用之前，所以如下代码是可以编译的</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let mut s &#x3D; String::from(&quot;hello&quot;);\n\n    let r1 &#x3D; &amp;s; &#x2F;&#x2F; 没问题\n    let r2 &#x3D; &amp;s; &#x2F;&#x2F; 没问题\n    println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2);\n    &#x2F;&#x2F; 此位置之后 r1 和 r2 不再使用\n\n    let r3 &#x3D; &amp;mut s; &#x2F;&#x2F; 没问题\n    println!(&quot;&#123;&#125;&quot;, r3);\n&#125;\n</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202306161350807.webp\" />\n\n<h3 id=\"悬垂引用\"><a href=\"#悬垂引用\" class=\"headerlink\" title=\"悬垂引用\"></a>悬垂引用</h3><img src=\"http://t-blog-images.aijs.top/img/202306161354018.webp\" />\n\n<h3 id=\"引用的规则：\"><a href=\"#引用的规则：\" class=\"headerlink\" title=\"引用的规则：\"></a>引用的规则：</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>让我们概括一下之前对引用的讨论：</p>\n<p>在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。<br>引用必须总是有效的。<br>接下来，我们来看看另一种不同类型的引用：slice。</p></blockquote>\n<h2 id=\"slice-解决了什么问题\"><a href=\"#slice-解决了什么问题\" class=\"headerlink\" title=\"slice 解决了什么问题\"></a>slice 解决了什么问题</h2><p>Slice 是 Rust 的一种数据类型，它允许程序员引用一个数组（array）或者一个字符串（string）的一部分数据，而不需要拷贝整个数组或字符串。Slice 解决了以下两个问题：</p>\n<ol>\n<li><p>Rust 的所有权和借用系统规定了对于一个变量的引用只能有一个可变引用或者多个不可变引用。对于一个数组，如果我们想在程序的不同部分使用它的不同部分，那么我们需要创建多个数组并对它们进行所有权转移，这显然很麻烦。而 Slice 允许我们通过引用数组的一部分来处理这个问题，而不需要创建多个数组。</p>\n</li>\n<li><p>在一些语言中，比如 C 和 C++，为了防止数组越界，需要手动处理数组下标。但是这种处理容易出错，可能会导致程序崩溃或者行为不确定。而 Slice 允许我们只引用数组的一部分，从而避免了这个问题。在 Rust 中，如果我们对 Slice 使用了不存在的下标，编译器会在编译时报错，从而可以在运行时之前发现错误。</p>\n</li>\n</ol>\n<p>因此，Slice 是 Rust 的一个重要特性，它使得代码更加清晰，更加安全。通过使用 Slice，程序员可以更加方便地操作数组，编写出更加正确、高效的代码。</p>\n<h2 id=\"Rust-为了提高性能，牺牲了代码的灵活性？\"><a href=\"#Rust-为了提高性能，牺牲了代码的灵活性？\" class=\"headerlink\" title=\"Rust 为了提高性能，牺牲了代码的灵活性？\"></a>Rust 为了提高性能，牺牲了代码的灵活性？</h2><p>相比某些编程语言，Rust 的确在某些方面会更加重视性能。例如，Rust 的所有权和借用系统可以在编译时进行静态检查，从而避免了运行时的垃圾回收开销，提高了程序的性能；同时，Rust 的所有权和借用系统也可以检查内存访问的合法性，避免了越界、空指针等运行时错误。此外，Rust 还可以通过编写 unsafe 代码来绕过编译器的检查，从而进一步提高性能。</p>\n<p>但是，Rust 并没有牺牲代码的灵活性。与其它系统级编程语言相比，Rust 的语法更为现代化，支持元编程，允许使用宏来生成代码，使得 Rust 的语法更加灵活。同时，Rust 的标准库提供了大量的常用数据结构和算法的实现，这些实现经过优化，性能非常高。这些特点使得 Rust 在处理各种场景下的任务时，既可以保障代码的灵活性，又能够提供出色的性能表现。因此，Rust 在很多领域都有着广泛的应用，例如网络编程、游戏编程、操作系统开发等领域。</p>\n<h2 id=\"引用与借用的区别-chatgpt\"><a href=\"#引用与借用的区别-chatgpt\" class=\"headerlink\" title=\"引用与借用的区别 [chatgpt]\"></a>引用与借用的区别 [chatgpt]</h2><p>Rust 中的引用和借用是两个不同的概念。它们用于暂时地借用数据，以便进行某些操作后，一定要归还数据。这样的设计使得 Rust 能够使用引用和借用来支持所有权模型，从而避免了运行时的垃圾回收开销。</p>\n<p><strong>引用：描述的是变量之间的关系</strong></p>\n<ol>\n<li>引用是一种指向另一个变量的指针类型，因此它可以在无需所有权的情况下引用数据。</li>\n<li>引用分为： <code>可变引用</code>和<code>不可变引用</code>两种类型。<ol>\n<li>不可变引用可以共享访问数据，但不能修改数据；</li>\n<li>可变引用可以修改数据，但不能与其它引用共享访问。</li>\n</ol>\n</li>\n</ol>\n<p><strong>借用：描述的是变量与函数之间的关系</strong></p>\n<p>则是在函数中暂时地引用传递进来的参数，以便读取或修改数据，这样可以避免复制大量的数据。</p>\n<p>借用分为：<code>可变借用</code>和<code>不可变借用</code>两种类型。</p>\n<ol>\n<li>不可变借用可以共享访问所有权者拥有的数据，但只能读取数据；</li>\n<li>可变借用可以修改被借用的数据，但只能拥有唯一的可变借用。</li>\n</ol>\n<p>引用和借用是 Rust 语言中非常重要的两个概念，理解它们的区别十分关键，尤其在 Rust 中处理大量数据时，正确使用它们可以避免不必要的内存开销，提高程序的性能。</p>\n<h2 id=\"什么是所有权-（chatgpt）\"><a href=\"#什么是所有权-（chatgpt）\" class=\"headerlink\" title=\"什么是所有权 （chatgpt）\"></a>什么是所有权 （chatgpt）</h2><p>所有权（Ownership）是 Rust 语言的一个重要概念，它描述了在运行时如何管理计算机内存并确保其安全性。简单来说，<strong>所有权规定了一块内存只能被一个所有者所拥有，一旦所有者离开了其作用域，这块内存就会被自动释放回收</strong>。</p>\n<p>在 Rust 中，变量的所有权由它们的定义方式决定。例如，当一个变量被定义时，它就成为该变量的所有者，它拥有这个变量所占用的内存。当所有者离开了它们的作用域，该变量的内存会被自动释放。这种方式避免了内存泄漏和悬垂指针等常见的内存安全问题，并且使得 Rust 具有内存安全性和高效性的优点。</p>\n<h2 id=\"什么是-悬垂指针（chatgpt）\"><a href=\"#什么是-悬垂指针（chatgpt）\" class=\"headerlink\" title=\"什么是 悬垂指针（chatgpt）\"></a>什么是 悬垂指针（chatgpt）</h2><p>悬垂指针（Dangling Pointer）指的是: <strong>指针变量所指向的内存地址已经被释放或者不再可用，但该指针变量本身仍然保持着原来的值</strong>。当程序试图使用一个悬垂指针时，通常会出现未定义行为或者崩溃等问题。</p>\n<p>常见的悬垂指针问题包括以下几种情况：</p>\n<ol>\n<li><p>指针<strong>指向的堆内存被释放</strong>。在动态内存分配时，如果使用了 <code>free</code> 或者 <code>delete</code> 等函数释放了一个指针所指向的内存，但是该指针变量并没有被置为 <code>NULL</code>，那么这个指针就成为了悬垂指针。</p>\n</li>\n<li><p>指针<strong>指向的栈内存已经被释放</strong>。当一个函数返回并弹出该函数的栈帧时，其中的局部变量所占用的内存也会被自动释放。如果一个指针变量指向的栈上的内存已经被释放，那么这个指针就成为了悬垂指针。</p>\n</li>\n<li><p>指针<strong>指向了某个对象的成员变量，在该对象被销毁之后成为了悬垂指针</strong>。例如，一个类的对象在被销毁之前，指针变量指向了该对象的某个成员变量的地址，但是在对象销毁之后，该指针变量没有及时被更新为 <code>NULL</code>，那么这个指针就会成为悬垂指针。</p>\n</li>\n</ol>\n<p>避免使用悬垂指针是保证程序内存安全性的一个重要方面。在 Rust 中，由于所有权机制的存在，可以有效地避免悬垂指针问题的出现。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>Rust 的核心语言中只有一种字符串类型：字符串 slice str，它通常以被借用的形式出现，&amp;str</p>\n<h3 id=\"新建字符串\"><a href=\"#新建字符串\" class=\"headerlink\" title=\"新建字符串\"></a>新建字符串</h3><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 方式1 新建字符串\nlet mut s &#x3D; String::new();\n\n\n&#x2F;&#x2F; 方式2 .to_string\nlet data &#x3D; &quot;initial contents&quot;;\n\nlet s &#x3D; data.to_string();\n\n&#x2F;&#x2F; 该方法也可直接用于字符串字面值：\nlet s &#x3D; &quot;initial contents&quot;.to_string();\n\n&#x2F;&#x2F; 方式3\nlet s &#x3D; String::from(&quot;initial contents&quot;);</code></pre>\n\n<h3 id=\"更新字符串\"><a href=\"#更新字符串\" class=\"headerlink\" title=\"更新字符串\"></a>更新字符串</h3><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F; 多字符： 更新字符串\nlet mut s &#x3D; String::from(&quot;foo&quot;);\ns.push_str(&quot;bar&quot;); &#x2F;&#x2F; push_str 方法采用字符串 slice，因为我们并不需要获取参数的所有权\n\n\n&#x2F;&#x2F; 单字符； push 方法被定义为获取一个单独的字符作为参数，并附加到 String 中\n\nlet mut s &#x3D; String::from(&quot;lo&quot;);\ns.push(&#39;l&#39;);\n\n&#x2F;&#x2F; 使用 + 运算符\n\nlet s1 &#x3D; String::from(&quot;Hello, &quot;);\nlet s2 &#x3D; String::from(&quot;world!&quot;);\nlet s3 &#x3D; s1 + &amp;s2; &#x2F;&#x2F; 注意 s1 被移动了，不能继续使用\n&#x2F;&#x2F; + 运算符使用了 add 函数\n&#x2F;&#x2F; fn add(self, s: &amp;str) -&gt; String &#123;\n&#x2F;&#x2F; 第二个字符串的 引用 与第一个字符串相加\n&#x2F;&#x2F; add 的第二个参数所指定的，&amp;s2 的类型是 &amp;String 而不是 &amp;str，在 add 调用中使用 &amp;s2 是因为 &amp;String 可以被 强转（coerced）成 &amp;str\n\n&#x2F;&#x2F; format! 宏拼接字符串\n\nlet s1 &#x3D; String::from(&quot;tic&quot;);\nlet s2 &#x3D; String::from(&quot;tac&quot;);\nlet s3 &#x3D; String::from(&quot;toe&quot;);\n\nlet s &#x3D; s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;\n&#x2F;&#x2F; format! 简化\nfn main() &#123;\n  let s1 &#x3D; String::from(&quot;tic&quot;);\n  let s2 &#x3D; String::from(&quot;tac&quot;);\n  let s3 &#x3D; String::from(&quot;toe&quot;);\n\n  let s &#x3D; format!(&quot;&#123;s1&#125;-&#123;s2&#125;-&#123;s3&#125;&quot;);\n  &#x2F;&#x2F; 宏 format! 生成的代码使用引用所以不会获取任何参数的所有权。\n&#125;\n\n\n</code></pre>\n\n<h3 id=\"索引字符串\"><a href=\"#索引字符串\" class=\"headerlink\" title=\"索引字符串\"></a>索引字符串</h3><p>rust 不支持字符串索引</p>\n<ol>\n<li>不支持下标</li>\n<li>字符串 slice，有可能报错</li>\n<li>chars 方法会将其分开并返回两个 char 类型的值，接着就可以遍历其结果来访问每一个元素了</li>\n<li>bytes 方法返回每一个原始字节</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">#![allow(unused)]\nfn main() &#123;\n  for c in &quot;Зд&quot;.chars() &#123;\n      println!(&quot;&#123;c&#125;&quot;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; З\n&#x2F;&#x2F; д\n\n\n#![allow(unused)]\nfn main() &#123;\n  for b in &quot;Зд&quot;.bytes() &#123;\n      println!(&quot;&#123;b&#125;&quot;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 208\n&#x2F;&#x2F; 151\n&#x2F;&#x2F; 208\n&#x2F;&#x2F; 180\n</code></pre>\n\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"引用模块项目的路径：\"><a href=\"#引用模块项目的路径：\" class=\"headerlink\" title=\"引用模块项目的路径：\"></a>引用模块项目的路径：</h3><p>绝对路径（absolute path）是以 crate 根（root）开头的全路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于对于当前 crate 的代码，则以字面值 crate 开头。<br>相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头</p>\n<h3 id=\"使用-pub-关键字暴露路径：\"><a href=\"#使用-pub-关键字暴露路径：\" class=\"headerlink\" title=\"使用 pub 关键字暴露路径：\"></a>使用 pub 关键字暴露路径：</h3><h3 id=\"创建公有的结构体和枚举：\"><a href=\"#创建公有的结构体和枚举：\" class=\"headerlink\" title=\"创建公有的结构体和枚举：\"></a>创建公有的结构体和枚举：</h3><h3 id=\"use-关键字将路径引入作用域\"><a href=\"#use-关键字将路径引入作用域\" class=\"headerlink\" title=\"use 关键字将路径引入作用域\"></a>use 关键字将路径引入作用域</h3><ul>\n<li><strong>使用 as 关键字提供新的名称</strong></li>\n<li><strong>重导出（re-exporting）</strong></li>\n<li><strong>嵌套路径来消除大量的 use 行</strong></li>\n</ul>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 示例1\n&#x2F;&#x2F; --snip--\nuse std::cmp::Ordering;\nuse std::io;\n&#x2F;&#x2F; --snip--\n\n&#x2F;&#x2F; 简化版本\n&#x2F;&#x2F; --snip--\nuse std::&#123;cmp::Ordering, io&#125;;\n&#x2F;&#x2F; --snip--\n\n&#x2F;&#x2F; 示例2\nuse std::io;\nuse std::io::Write;\n\n&#x2F;&#x2F; 简化版本\nuse std::io::&#123;self, Write&#125;;</code></pre>\n\n<ul>\n<li><strong>通过 glob 运算符将所有的公有定义引入作用域</strong></li>\n</ul>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 如果希望将一个路径下 所有 公有项引入作用域，可以指定路径后跟 *，glob 运算符：\n\nuse std::collections::*;\n\n&#x2F;&#x2F; 这个 use 语句将 std::collections 中定义的所有公有项引入当前作用域。使用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。\n\n&#x2F;&#x2F; glob 运算符经常用于测试模块 tests 中，这时会将所有内容引入作用域；</code></pre>\n\n<ul>\n<li><strong>惯用的 use 路径是指定到方法的父模块，而不是直接引入方法，好处：</strong></li>\n</ul>\n<ol>\n<li>是比较明显是从哪个模块倒入的方法，</li>\n<li>避免模块与模块间相同内容的冲突</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\nmod front_of_house &#123;\n    pub mod hosting &#123;\n        pub fn add_to_waitlist() &#123;&#125;\n    &#125;\n&#125;\n&#x2F;&#x2F; 这里\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() &#123;\n    &#x2F;&#x2F; 这里\n    hosting::add_to_waitlist();\n&#125;\n</code></pre>\n\n<h2 id=\"包、Crate、模块的区别-（chatgpt）\"><a href=\"#包、Crate、模块的区别-（chatgpt）\" class=\"headerlink\" title=\"包、Crate、模块的区别 （chatgpt）\"></a>包、Crate、模块的区别 （chatgpt）</h2><p>在 Rust 中，包（Package）、Crate 和模块（Module）是三个不同的概念，它们之间有一定的层次关系。</p>\n<ul>\n<li>Package 是包含一个或多个 Crate 的一个高层次的概念，它可以包含多个 Crate，例如可以包括一个主 Crate 和多个依赖的外部 Crate，这些 Crate 之间可以相互引用，形成一个更为复杂的项目。</li>\n<li>Crate 是 Rust 中构建和共享代码的单元，可以理解为一个二进制库或库（library），一个 Crate 对应一个二进制可执行文件或一个库。</li>\n<li>Module 是 Rust 中命名空间的一种机制，用于组织和管理 Rust 代码。在一个 Crate （或 Package）内部，会根据代码的层次结构自动形成一些模块，其中包含了函数、结构体、枚举等代码。</li>\n</ul>\n<p>可以将它们看作是从大到小的一个层次结构：</p>\n<ul>\n<li>Package 包含一个或多个 Crate。</li>\n<li>Crate 包含一个或多个模块。</li>\n<li>模块包含一些 Rust 代码。</li>\n</ul>\n<p>在 Rust 中，使用 <code>use</code> 关键字引入模块，可以访问自己模块所定义的类型和函数，使用 <code>mod</code> 关键字定义模块，可以组织代码，隔离命名空间。</p>\n<h2 id=\"mod-与-java-package-关键字-看上去和相似（chatgpt）\"><a href=\"#mod-与-java-package-关键字-看上去和相似（chatgpt）\" class=\"headerlink\" title=\"mod 与 java package 关键字 看上去和相似（chatgpt）\"></a>mod 与 java package 关键字 看上去和相似（chatgpt）</h2><p>是的，尽管 Rust 的 module 和 Java 的 package 在实现和作用上有很大的区别，但是它们的关键字（mod 和 package）可能看起来相似。<br>在 Rust 中，mod 关键字用于定义 module，而在 Java 中，package 关键字用于定义 package。</p>\n<p>但是需要注意的是，在 Rust 中，mod 关键字更与 module 相关，而与 package 关系不大。</p>\n<p>因此，尽管这两个关键字在表面上看起来相似，但它们的作用和实现方式都不同。</p>\n<h1 id=\"所有权-（rust-核心）chatgpt\"><a href=\"#所有权-（rust-核心）chatgpt\" class=\"headerlink\" title=\"所有权 （rust 核心）chatgpt\"></a>所有权 （rust 核心）chatgpt</h1><p>在 Rust 中，所有权（ownership）是一种资源管理机制，它确保在程序执行期间对内存的分配和释放进行正确管理。所有权系统是 Rust 的核心特性之一，它避免了一些常见的内存错误，如空指针、悬垂指针和数据竞争等问题。</p>\n<p>在 Rust 中，每个值都有一个唯一的所有者（owner），只有所有者可以自由地访问和修改值。当所有者超出其作用域时，该值将被自动释放并返回给操作系统。</p>\n<p>以下是所有权的一些重要概念：</p>\n<ol>\n<li><code>所有权规则</code>：每个值有且只有一个所有者，值在不同的作用域中进行所有权的转移。</li>\n<li><code>所有权转移</code>：将所有权从一个所有者转移到另一个所有者时，前者将失去对该值的访问权限。</li>\n<li><code>移动（Move）</code>：当值的所有权发生转移时，源所有者将无法再使用该值，以防止出现悬垂指针。</li>\n<li><code>复制（Copy）</code>：对于一些简单且大小固定的类型，例如整数、布尔值等，它们实现了 Copy trait，可以进行复制而不是所有权转移。</li>\n<li><code>借用（Borrowing）</code>：通过借用（或引用）的方式，可以在不获得所有权的情况下访问值。借用允许多个只读访问或单个可变访问者，但不能同时存在可变和不可变的借用。</li>\n</ol>\n<p>掌握所有权概念对于编写安全且高效的 Rust 代码至关重要。它使得编译器能够在编译时检查出潜在的内存安全问题，并通过释放资源的自动化处理，简化了开发者的负担。</p>\n<p>理解： 这个像不像，我们开发阶段，任务会给一个 owner？</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所有权规则</p>\n<ol>\n<li>Rust 中的每一个值都有一个 所有者（owner）。</li>\n<li>值在任一时刻有且只有一个所有者。</li>\n<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>\n</ol></blockquote>\n<h2 id=\"可以理解为项目开发中-owner-的概念吗？chatgpt\"><a href=\"#可以理解为项目开发中-owner-的概念吗？chatgpt\" class=\"headerlink\" title=\"可以理解为项目开发中 owner 的概念吗？chatgpt\"></a>可以理解为项目开发中 owner 的概念吗？chatgpt</h2><p>可以将所有权在 Rust 中的概念类比于项目开发中的所有者（owner）概念，但需要注意的是，它们之间并不是完全相同的。</p>\n<p>在项目开发中，所有者通常是指在团队中拥有对项目的最高权限和责任的人。所有者负责决策、管理资源、分配工作等。他们可能具有对项目中的所有信息、代码和资源的完全控制权。</p>\n<p>在 Rust 中的所有权则是一种资源控制机制，它决定了谁能够访问和修改值。每个值都有唯一的所有者，只有当前所有者可以对值进行操作。这种机制可以防止出现一些常见的内存错误，如悬垂指针、数据竞争等，从而提高代码的安全性和可靠性。</p>\n<p>虽然在概念上可以将这两个概念进行类比，但在具体的实现和操作上存在一些区别。在 Rust 中，所有权是通过编译器静态分析和运行时机制来管理的，而项目开发中的所有者则是由团队成员通过人际关系、协作和组织结构来管理的。</p>\n<p>总之，虽然可以将 Rust 中的所有权概念与项目开发中的所有者概念进行类比，但需要注意它们之间的差异和特点。</p>\n<h2 id=\"rust-中所有权解决了什么问题？\"><a href=\"#rust-中所有权解决了什么问题？\" class=\"headerlink\" title=\"rust 中所有权解决了什么问题？\"></a>rust 中所有权解决了什么问题？</h2><p>它确保在程序执行期间对内存的分配和释放进行正确管理。所有权系统是 Rust 的核心特性之一，它避免了一些常见的内存错误，如空指针、悬垂指针和数据竞争等问题。</p>\n<h2 id=\"rust-为什么会有所有权转移？\"><a href=\"#rust-为什么会有所有权转移？\" class=\"headerlink\" title=\"rust 为什么会有所有权转移？\"></a>rust 为什么会有所有权转移？</h2><p>Rust 引入了所有权转移的概念，是为了解决在系统编程语言中常见的内存安全问题，特别是悬垂指针和数据竞争。</p>\n<p>所有权转移机制确保每个值都有一个唯一的所有者，这个所有者负责值的生命周期和资源的释放。当将值分配给另一个所有者时，原始所有者失去对该值的访问权限。这种转移确保了在任何给定时间只有一个所有者能够访问和修改值，这样就避免了许多常见的内存错误。</p>\n<p>具体来说，所有权转移机制在以下几个方面帮助保证内存安全：</p>\n<ol>\n<li><p>解决了悬垂指针问题：所有权转移确保在值离开作用域之前，其所有者仍然是有效的。如果尝试在没有所有权的情况下访问一个值，Rust 会在编译时检测到这个错误，防止悬垂指针的出现。</p>\n</li>\n<li><p>消除了数据竞争：Rust 的所有权系统通过禁止多个可变引用同时存在，解决了数据竞争问题。在特定的作用域中，只允许有一个可变引用，从而避免了数据竞争的可能性。</p>\n</li>\n<li><p>自动释放资源：所有权转移允许在值超出范围时自动释放资源。当值的所有者离开作用域时，Rust 会自动调用该值的析构函数，释放关联的资源，如内存或文件句柄。</p>\n</li>\n</ol>\n<p>通过引入所有权转移，Rust 在编译时通过静态分析和运行时通过所有权管理机制，提供了更高的内存安全性和线程安全性。这使得 Rust 成为一种可靠且高效的系统编程语言。</p>\n<h2 id=\"rust-中所有权唯一？\"><a href=\"#rust-中所有权唯一？\" class=\"headerlink\" title=\"rust 中所有权唯一？\"></a>rust 中所有权唯一？</h2><p>唯一，只会有一个 owner<br>移动，会给一块内存换个 ower, 之前的 ower 会被回收掉？</p>\n<h2 id=\"之前的-ower-在移动到后一个-ower-后，会被回收掉？\"><a href=\"#之前的-ower-在移动到后一个-ower-后，会被回收掉？\" class=\"headerlink\" title=\"之前的 ower 在移动到后一个 ower 后，会被回收掉？\"></a>之前的 ower 在移动到后一个 ower 后，会被回收掉？</h2><p>不完全正确。在 Rust 中，所有权的转移<strong>不会立即导致前一个所有者被回收</strong>。相反，当所有权转移发生时，前一个所有者不再拥有该值，而是被标记为”无效”（invalidated）。只有当前一个所有者超出其作用域时，该值才会被回收。</p>\n<p>这种延迟回收的机制称为”析构”（Drop）。当一个值的所有者离开其作用域时，Rust 会自动调用该值的析构函数（Drop 函数），以进行必要的清理工作，如释放占用的内存或关闭文件句柄。</p>\n<p>因此，在 Rust 中，直到前一个所有者超出其作用域，该值的内存才会被正确释放。这确保了所有权转移的有效性和内存安全性。</p>\n<h2 id=\"无效不是悬垂引用？\"><a href=\"#无效不是悬垂引用？\" class=\"headerlink\" title=\"无效不是悬垂引用？\"></a>无效不是悬垂引用？</h2><p>是的，你是正确的。我对前一个所有者被标记为”无效”的表述有些不准确。实际上，当所有权转移发生时，前一个所有者的引用将变为”无效引用”，而非被标记为”无效”。</p>\n<p>在 Rust 中，当所有权转移发生后，前一个所有者不再拥有对值的引用。如果前一个所有者继续使用该值的引用，就会导致悬垂引用的问题。悬垂引用是指对于已经被释放或无效的值的引用，这是一种引发安全问题的情况。</p>\n<p>为了防止出现悬垂引用，Rust 在编译时会对所有权转移进行严格的检查。只有当前一个所有者超出其作用域时，该值的内存才会被正确释放，并且在此之前，任何悬垂引用都是不允许的。这确保了内存安全性和避免了悬垂引用的问题。</p>\n<h2 id=\"借用和引用（可以理解为一个东西）\"><a href=\"#借用和引用（可以理解为一个东西）\" class=\"headerlink\" title=\"借用和引用（可以理解为一个东西）\"></a>借用和引用（可以理解为一个东西）</h2><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#引用与借用 target=\"_blank\" >引用与借用</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#可变引用 target=\"_blank\" >可变引用</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#悬垂引用dangling-references target=\"_blank\" >悬垂引用（Dangling References）</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#引用的规则 target=\"_blank\" >引用的规则</a></li>\n</ol>\n</li>\n</ol>\n<p><strong>引用的规则：</strong></p>\n<ol>\n<li>在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。</li>\n<li>引用必须总是有效的</li>\n</ol>\n<p><strong>对于第一点理解</strong></p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 分两步\n\n\n&#x2F;&#x2F; step1:\n\n&#x2F;&#x2F; 1. 可变引用，不可变引用，二选一，你用吧\n\n&#x2F;&#x2F; step2:\n\n&#x2F;&#x2F; 1.  如果选用&#96;可变引用&#96;,只允许创建 1 个\n&#x2F;&#x2F; 2.  如果选用&#96;不可变引用&#96;,可以创建多个</code></pre>\n\n<h2 id=\"rust-如何区分引用和借用\"><a href=\"#rust-如何区分引用和借用\" class=\"headerlink\" title=\"rust 如何区分引用和借用\"></a>rust 如何区分引用和借用</h2><p>在 Rust 中，引用和借用是两个相关但不完全相同的概念，用于在不获取所有权的情况下访问数据。下面是解释如何区分引用和借用的一些重要概念和规则。</p>\n<ol>\n<li><p>引用的分类：</p>\n<ul>\n<li>不可变引用（<code>&amp;T</code>）：允许读取数据，但不允许修改数据。可以有多个不可变引用同时存在，但不能与可变引用同时存在。</li>\n<li>可变引用（<code>&amp;mut T</code>）：允许读取和修改数据，在给定的作用域内只能有一个可变引用。</li>\n</ul>\n</li>\n<li><p>借用的概念：</p>\n<ul>\n<li>借用是一种将数据的引用传递给其他代码的行为。</li>\n<li>引用的借用是临时的，借用者无法改变数据的生命周期或所有权。</li>\n</ul>\n</li>\n<li><p>引用和借用的限制：</p>\n<ul>\n<li>Rust 使用借用检查器来确保在编译时遵守引用和借用规则。</li>\n<li>引用和借用的生命周期必须在数据本身的生命周期内，并且不能超出所有权范围。</li>\n<li>引用和借用的作用域通常受限于创建它们的代码块。</li>\n</ul>\n</li>\n</ol>\n<p>下面是一些在代码中正确使用引用和借用的示例：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let mut data &#x3D; 42;\n\n    &#x2F;&#x2F; 不可变引用\n    let immutable_ref &#x3D; &amp;data;\n    println!(&quot;Immutable reference: &#123;&#125;&quot;, immutable_ref);\n\n    &#x2F;&#x2F; 可变引用\n    let mutable_ref &#x3D; &amp;mut data;\n    *mutable_ref &#x3D; 24;\n    println!(&quot;Mutable reference: &#123;&#125;&quot;, mutable_ref);\n&#125;</code></pre>\n\n<p>在这个示例中，我们创建了一个可变的整数变量 <code>data</code>，然后分别创建了不可变引用 <code>immutable_ref</code> 和可变引用 <code>mutable_ref</code>。通过使用引用，我们可以使用这些引用来读取和修改 <code>data</code> 的值，而不会获取它的所有权。</p>\n<p>需要注意的是，在使用可变引用修改数据时，需要使用解引用操作符 <code>*</code>。这是因为可变引用本身是不允许直接修改数据的。</p>\n<h2 id=\"rust-引用和借用是同一个东西\"><a href=\"#rust-引用和借用是同一个东西\" class=\"headerlink\" title=\"rust 引用和借用是同一个东西\"></a>rust 引用和借用是同一个东西</h2><p>对不起，我的回答存在误导。在 Rust 中，引用和借用是同一个概念，使用可变引用可以修改原所有者的值。</p>\n<p>通过引用和借用的机制，Rust 确保了数据的安全性和避免了悬挂指针等内存错误。当我们使用可变引用时，可以通过借用一个可变引用来修改原所有者的值，而不会转移所有权。</p>\n<p>这种通过可变引用来修改数据的方式，可以避免潜在的所有权转移造成的问题，并提供了更多的灵活性和控制性。请忽略我之前有关”为什么还要通过可变引用来改”的回答。感谢您的纠正。</p>\n<h2 id=\"引用、借用、移动的区别\"><a href=\"#引用、借用、移动的区别\" class=\"headerlink\" title=\"引用、借用、移动的区别\"></a>引用、借用、移动的区别</h2><p>在 Rust 中，引用、借用和移动是对值或数据的使用方式进行描述的术语。</p>\n<ul>\n<li><p>引用（Reference）：引用是对值的别名，可以通过使用<code>&amp;</code>符号来创建。引用允许你借用（borrow）值的所有权，而不会获取所有权。借用引用不会改变所有权关系，可以在引用的生命周期内共享值，并且遵循借用规则，确保不会有悬垂引用或数据竞争的问题。</p>\n</li>\n<li><p>借用（Borrowing）：借用是通过引用来访问值的方式。Rust 中的借用规则确保了借用的安全性，即同一时间内只能存在一个可变引用（mutable reference）或任意数量的不可变引用（immutable reference）。这种限制确保了在编译时防止数据竞争和悬垂引用的问题。</p>\n</li>\n<li><p>移动（Move）：移动是指将值的所有权从一个变量转移给另一个变量。当所有权转移发生时，前一个变量将不再有效，而新的变量将成为新的所有者。这可以通过简单的赋值语句进行，例如<code>let y = x;</code>。移动是 Rust 的核心机制之一，它确保了内存安全性和避免了悬垂引用的问题。</p>\n</li>\n</ul>\n<p>总结来说，引用是对值的别名，允许共享访问而不获取所有权；借用是通过引用来临时访问值并遵循借用规则；移动是从一个变量将所有权转移到另一个变量，使前一个变量无效。这些概念在 Rust 中起到了保证内存安全的重要作用。</p>\n<h2 id=\"还是不清楚引用和借用有什么区别\"><a href=\"#还是不清楚引用和借用有什么区别\" class=\"headerlink\" title=\"还是不清楚引用和借用有什么区别\"></a>还是不清楚引用和借用有什么区别</h2><p>对于很多人来说，引用和借用这两个概念很容易混淆，因为它们都涉及到对值的访问。我将尝试进一步解释这两个概念的区别，希望可以清晰一些：</p>\n<p>引用是对值的别名，它通过使用<code>&amp;</code>符号来创建。引用可以是不可变引用（immutable reference）或可变引用（mutable reference）。引用允许你以只读方式或读写方式来访问值，但是并不获取对值的所有权。</p>\n<p>借用是通过引用来访问值的方式。通过创建引用，我们可以将值借给其他代码来使用。借用可以是不可变借用（immutable borrowing）或可变借用（mutable borrowing）。当一个值被借用时，被借用的代码可以读取它，但不能修改它。</p>\n<p>下面是引用和借用的主要区别：</p>\n<ol>\n<li><p>所有权：引用不获取值的所有权，它只是值的别名。借用也不获取值的所有权，它只是获取对值的访问权限。</p>\n</li>\n<li><p>可变性：引用可以是不可变引用或可变引用。不可变引用可以同时存在多个，但可变引用只能有一个，这是为了防止数据竞争。借用同样遵循这些规则。</p>\n</li>\n<li><p>生命周期：引用的生命周期由创建它的作用域决定。借用的生命周期也由创建它的作用域决定。引用或借用不应该超过它们所引用的值的生命周期，以确保避免悬垂引用的问题。</p>\n</li>\n</ol>\n<p>因此，引用是对值的别名，用于共享访问值而不获取所有权，而借用是通过引用临时获取值的访问权限，使其他代码可以使用值，但不获取所有权。借用规则保证了内存安全性和数据竞争的防止。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们将创建一个引用的行为称为 借用（borrowing）</p>\n<p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#:~:text=%E6%88%91%E4%BB%AC%E5%B0%86%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%A7%B0%E4%B8%BA%20%E5%80%9F%E7%94%A8%EF%BC%88borrowing%EF%BC%89\" target=\"_blank\" >见</a></p></blockquote>\n<h2 id=\"引用与解引用\"><a href=\"#引用与解引用\" class=\"headerlink\" title=\"引用与解引用\"></a>引用与解引用</h2><p>与使用 <code>&amp;</code> 引用相反的操作是 解引用（dereferencing），它使用解引用运算符，<code>*</code></p>\n<h2 id=\"有一个对该变量的可变引用，就不能再创建对该变量的引用-为什么要这么设计，假设又创建了引用会出现什么问题\"><a href=\"#有一个对该变量的可变引用，就不能再创建对该变量的引用-为什么要这么设计，假设又创建了引用会出现什么问题\" class=\"headerlink\" title=\"有一个对该变量的可变引用，就不能再创建对该变量的引用, 为什么要这么设计，假设又创建了引用会出现什么问题\"></a>有一个对该变量的可变引用，就不能再创建对该变量的引用, 为什么要这么设计，假设又创建了引用会出现什么问题</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有一个对该变量的可变引用，你就不能再创建对该变量的引用</p>\n<p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#:~:text=%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%AF%A5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BD%A0%E5%B0%B1%E4%B8%8D%E8%83%BD%E5%86%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%AF%A5%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8\" target=\"_blank\" >见</a></p></blockquote>\n<p>Rust 设计了一套所有权和借用规则，其中之一是“可变引用排他性”（mutable reference exclusivity）。这个规则意味着当有一个可变引用存在时，就不能再创建对同一变量的引用（无论是可变引用还是不可变引用）。这是为了防止数据竞争和保证内存安全。</p>\n<p>数据竞争是指多个线程同时访问同一数据，并且至少有一个线程尝试写入数据。在这种情况下，如果没有适当的同步机制，数据可能会被不同的线程交织修改，导致未定义的行为。为了避免这种情况，Rust 在编译时利用可变引用排他性规则防止同时存在多个可变引用。</p>\n<p><strong>如果允许同时存在多个可变引用，它们可能会引发以下问题</strong>：</p>\n<ol>\n<li><p>竞争条件：多个线程可以同时修改同一变量，导致结果无法预测。</p>\n</li>\n<li><p>数据不一致：如果一个可变引用将值改变为一个不一致的状态，其他可变引用可能会在该状态下继续操作，导致错误的结果。</p>\n</li>\n<li><p>悬垂指针：当一个可变引用被创建后，如果有其他引用指向同一变量且在该变量被修改或释放之后仍然存在，这将导致悬垂引用。悬垂引用是一种不安全的行为，可能导致使用无效的或已释放的内存。</p>\n</li>\n</ol>\n<p>因此，Rust 通过禁止同时存在多个可变引用来确保程序在编译时就遵守数据竞争和内存安全的规则。这是 Rust 强大的内存安全性的一部分，有助于避免常见的并发问题。</p>\n<h2 id=\"我将其可以理解为-js-单线程操作-dom，同一时间不允许多个修改？\"><a href=\"#我将其可以理解为-js-单线程操作-dom，同一时间不允许多个修改？\" class=\"headerlink\" title=\"我将其可以理解为 js 单线程操作 dom，同一时间不允许多个修改？\"></a>我将其可以理解为 js 单线程操作 dom，同一时间不允许多个修改？</h2><p>不完全正确。虽然 Rust 的引用限制在某种程度上与 JavaScript 中的 DOM 操作的单线程特性相似，但它们具有不同的目的和实现方式。</p>\n<p>在 JavaScript 中，DOM 操作通常是在一个单线程环境中进行的。这意味着同一时间只能有一个执行线程对 DOM 进行修改，以避免竞争条件。这种限制是由浏览器实现的，并且是基于 JavaScript 的运行时环境的特性。</p>\n<p>在 Rust 中，可变引用排他性的规则不仅适用于多线程环境，也适用于单线程环境。它的目的是避免数据竞争和确保内存安全，无论是在单线程还是多线程环境中。Rust 编译器在编译时通过静态检查来验证引用的有效性，以防止不安全行为的发生。</p>\n<p>因此，尽管两者都限制了并发修改，但 Rust 的引用规则更加严格，因为它通过编译时的静态安全性检查来防止错误的出现，而不是依赖于运行时环境的特性。这使得 Rust 能够提供更强大的内存安全保证，并允许开发人员在编译时捕获潜在的错误。</p>\n<h2 id=\"rust-为什么单线程也要限制唯一可变引用\"><a href=\"#rust-为什么单线程也要限制唯一可变引用\" class=\"headerlink\" title=\"rust 为什么单线程也要限制唯一可变引用\"></a>rust 为什么单线程也要限制唯一可变引用</h2><p>Rust 在单线程环境中同样限制唯一可变引用是出于内存安全和<strong>数据竞争</strong>（？）的考虑。</p>\n<p>在 Rust 中，可变引用的唯一性限制是为了防止数据竞争。数据竞争指的是两个或多个指针同时访问相同的内存位置，并且至少一个指针正在尝试写入该位置。这种情况下，由于没有同步机制来协调对相同内存位置的访问，可能会导致未定义行为。</p>\n<p>为了确保内存安全，Rust 使用了“借用检查器”来静态分析代码，以确保不会发生数据竞争。在单线程环境中，虽然不存在两个线程同时修改相同数据的情况，但仍然有可能在代码中创建多个可变引用，并尝试同时对该可变引用进行写入。这可能导致数据竞争，因此 Rust 在编译时执行限制，即保证在给定的作用域内，只能有一个可变引用存在。</p>\n<p>限制唯一可变引用可以防止程序中发生数据竞争，并确保内存安全。这是 Rust 设计的核心原则之一，以在编译时强制执行内存安全，并减少运行时错误的潜在风险。</p>\n<h2 id=\"rust-单线程也会有数据竞争的？\"><a href=\"#rust-单线程也会有数据竞争的？\" class=\"headerlink\" title=\"rust 单线程也会有数据竞争的？\"></a>rust 单线程也会有数据竞争的？</h2><p>对不起，我先前的回答有误。我犯了一个错误。在单线程环境中，Rust 并不会出现数据竞争。</p>\n<p>Rust 的数据竞争是指多个线程同时访问同一数据，并且至少有一个线程试图修改该数据，而且没有适当的同步机制来保证并发访问的正确性。在单线程环境中，不存在多个线程并发执行的情况，因此数据竞争也就不可能发生。</p>\n<p>因此，在 Rust 的单线程环境中，限制唯一可变引用的原因<strong>主要是为了实现内存安全和避免在多线程环境下可能出现的数据竞争</strong>。在单线程中，您可以拥有多个不可变引用，以方便并发读取，但只允许同时存在一个可变引用，以避免潜在的竞争条件。</p>\n<p>非常抱歉先前给您带来的困惑。感谢您的指出，并让我有机会更正错误。请随时提出更多问题。</p>\n<h2 id=\"我觉得单线程不需要限制唯一可变引用\"><a href=\"#我觉得单线程不需要限制唯一可变引用\" class=\"headerlink\" title=\"我觉得单线程不需要限制唯一可变引用\"></a>我觉得单线程不需要限制唯一可变引用</h2><p>在某些特定场景下，单线程环境可能不需要限制唯一可变引用。然而，Rust 选择在单线程环境中保持相同的限制，是为了保持一致性和简化代码。</p>\n<p>Rust 的设计哲学之一是在不同环境下提供一致的内存安全保证。通过在单线程环境中使用相同的所有权系统和借用规则，Rust 代码可以更轻松地在多线程环境中进行迁移，因为已经通过编译时的静态检查来防止数据竞争和内存安全问题。</p>\n<p>此外，限制唯一可变引用的存在可以促使开发者采用更清晰的代码设计，强制在逻辑上限制对数据的修改。这种限制在代码的可维护性和可读性方面是有益的，尤其在复杂的代码库中。</p>\n<p>虽然可能会有一些特殊情况下不需要这种限制，但 <strong>Rust 通过在整个语言中保持一致性，提供了一种更可靠和一致的编程体验</strong>，并防止潜在的错误。这种设计决策使 Rust 成为一种强大的编程语言，既适用于单线程环境，也适用于多线程和并发环境。</p>\n<h2 id=\"不能在拥有不可变引用的同时拥有可变引用\"><a href=\"#不能在拥有不可变引用的同时拥有可变引用\" class=\"headerlink\" title=\"不能在拥有不可变引用的同时拥有可变引用\"></a>不能在拥有不可变引用的同时拥有可变引用</h2><p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#:~:text=%E5%93%A6%EF%BC%81%E6%88%91%E4%BB%AC%20%E4%B9%9F-,%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E7%9A%84%E5%90%8C%E6%97%B6%E6%8B%A5%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8,-%E3%80%82\" target=\"_blank\" >见</a></p>\n<h2 id=\"为什么可以同时创建多个不可变引用，一个不够用的吗？\"><a href=\"#为什么可以同时创建多个不可变引用，一个不够用的吗？\" class=\"headerlink\" title=\"为什么可以同时创建多个不可变引用，一个不够用的吗？\"></a>为什么可以同时创建多个不可变引用，一个不够用的吗？</h2><p>一个够用，可以起花里胡哨的称呼（爸比、儿子、孙子、小王，都是同一个人）</p>\n<p>在 Rust 中，允许同时创建多个不可变引用的原因是因为不可变引用本身是具有共享性质的。多个不可变引用可以同时引用相同的数据，而不会产生竞争条件或引起内存安全问题。</p>\n<p><strong>允许多个不可变引用的好处是提高了代码的灵活性和可读性</strong>。在编写复杂的程序时，允许同时使用多个不可变引用可以让代码更加清晰，方便对数据进行多个观察或访问。</p>\n<p>与不可变引用不同，可变引用具有独占访问权。在同一作用域中，只能有一个可变引用同时存在。这是为了防止数据的并发修改，避免数据竞争和未定义行为。</p>\n<p>限制可变引用数量有助于确保程序的安全性，但限制不可变引用数量并没有这种需求，因为并发读取是安全的。</p>\n<p>总的来说，Rust 的借用规则旨在提供一种方便、可读性强且保证内存安全的编程体验。不可变引用的共享性质允许同时创建多个不可变引用，而独占性质的可变引用的数量则有限制，以确保代码的正确性和数据的安全性。</p>\n<h2 id=\"就创建一个不可变引用，然后使用多次\"><a href=\"#就创建一个不可变引用，然后使用多次\" class=\"headerlink\" title=\"就创建一个不可变引用，然后使用多次\"></a>就创建一个不可变引用，然后使用多次</h2><p>在 Rust 中，你可以创建一个不可变引用并使用多次，因为不可变引用具有共享性质。这意味着多个不可变引用可以同时引用相同的数据，而不会引起竞争条件或内存安全问题。</p>\n<p>以下是一个简单的示例，演示如何创建一个不可变引用并多次使用它：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let data &#x3D; vec![1, 2, 3, 4, 5]; &#x2F;&#x2F; 假设我们有一个数据集合\n\n    let immutable_ref &#x3D; &amp;data; &#x2F;&#x2F; 创建一个不可变引用\n\n    &#x2F;&#x2F; 使用不可变引用多次\n    println!(&quot;数据的长度：&#123;&#125;&quot;, immutable_ref.len());\n    for num in immutable_ref.iter() &#123;\n        println!(&quot;数字：&#123;&#125;&quot;, num);\n    &#125;\n    println!(&quot;第一个元素：&#123;&#125;&quot;, immutable_ref[0]);\n&#125;</code></pre>\n\n<p>在上述示例中，我们创建了一个不可变引用 <code>immutable_ref</code> 来引用 <code>data</code> 数据集合。然后我们可以多次使用该引用，例如获取数据的长度、迭代数据元素、访问索引等操作，而不会有任何问题。</p>\n<p>不可变引用的共享性质使其适用于数据的观察和读取，不会引发并发访问的冲突。这也是为什么 Rust 允许同时存在多个不可变引用的原因。</p>\n<h2 id=\"举个创建多个不可变引用的例子\"><a href=\"#举个创建多个不可变引用的例子\" class=\"headerlink\" title=\"举个创建多个不可变引用的例子\"></a>举个创建多个不可变引用的例子</h2><p>当你创建多个不可变引用时，这些引用可以同时访问相同的数据，但不能对数据进行可变更的操作。以下是一个示例，演示如何创建多个不可变引用：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let data &#x3D; vec![1, 2, 3, 4, 5]; &#x2F;&#x2F; 假设我们有一个数据集合\n\n    let ref1 &#x3D; &amp;data; &#x2F;&#x2F; 创建第一个不可变引用\n    let ref2 &#x3D; &amp;data; &#x2F;&#x2F; 创建第二个不可变引用\n\n    &#x2F;&#x2F; 使用第一个不可变引用\n    println!(&quot;数据的长度：&#123;&#125;&quot;, ref1.len());\n    for num in ref1.iter() &#123;\n        println!(&quot;数字：&#123;&#125;&quot;, num);\n    &#125;\n\n    &#x2F;&#x2F; 使用第二个不可变引用\n    println!(&quot;数据的长度：&#123;&#125;&quot;, ref2.len());\n    for num in ref2.iter() &#123;\n        println!(&quot;数字：&#123;&#125;&quot;, num);\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们创建了两个不可变引用 <code>ref1</code> 和 <code>ref2</code> 来引用 <code>data</code> 数据集合。然后我们可以使用这两个引用分别访问相同的数据，例如获取数据的长度、迭代数据元素等操作。</p>\n<p>这两个不可变引用共享相同的数据，并且在没有可变引用的情况下可以同时存在。这允许你以并发安全的方式访问数据，而不会引发数据竞争或内存安全问题。</p>\n<h2 id=\"可变引用能改变原所有者的值？\"><a href=\"#可变引用能改变原所有者的值？\" class=\"headerlink\" title=\"可变引用能改变原所有者的值？\"></a>可变引用能改变原所有者的值？</h2><p>是的，可变引用可以修改原所有者的值。Rust 的可变引用（mutable reference）允许对数据进行修改操作。当你创建一个可变引用时，你可以通过引用来改变原来的值。以下是一个示例：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn main() &#123;\n    let mut data &#x3D; vec![1, 2, 3, 4, 5]; &#x2F;&#x2F; 假设我们有一个可变的数据集合\n\n    let ref_mut &#x3D; &amp;mut data; &#x2F;&#x2F; 创建一个可变引用\n\n    &#x2F;&#x2F; 通过可变引用修改原始数据\n    ref_mut.push(6);\n    ref_mut.push(7);\n    ref_mut.push(8);\n\n    &#x2F;&#x2F; 打印修改后的数据\n    println!(&quot;&#123;:?&#125;&quot;, data);\n&#125;</code></pre>\n\n<p>在上述示例中，我们创建了一个可变的数据集合 <code>data</code>，然后通过 <code>&amp;mut</code> 创建了一个可变引用 <code>ref_mut</code>。接着，我们通过可变引用 <code>ref_mut</code> 对原始数据进行了修改，调用了 <code>push</code> 方法来添加三个新的元素。最后，我们打印整个修改后的数据集合。</p>\n<p>这证明了可变引用是一种允许修改原始数据的强大机制。需要注意的是，在 Rust 中，可变引用的创建和使用是受到借用规则（borrowing rules）的限制，以确保引用的有效性和数据的安全性。</p>\n<h2 id=\"直接改不就得了，为什么还要通过可变引用来改\"><a href=\"#直接改不就得了，为什么还要通过可变引用来改\" class=\"headerlink\" title=\"直接改不就得了，为什么还要通过可变引用来改\"></a>直接改不就得了，为什么还要通过可变引用来改</h2><p>在 Rust 中，可变引用是<code>为了解决借用规则和所有权转移的限制而引入的机制</code>。如果我们直接修改原所有者的值，这将导致所有权的转移，原所有者将无法再继续使用该值。这可能会导致一些潜在的问题，例如：</p>\n<ol>\n<li><p><code>所有权过早转移</code>：如果我们直接修改原所有者的值，那么在修改后，我们将无法再直接访问原所有者。这可能导致在修改后无法执行其他操作，或者导致代码的复杂性增加。</p>\n</li>\n<li><p><code>并发安全性</code>：Rust 的可变引用规则确保了在同一时间只能有一个可变引用存在。这可以防止数据竞争和并发错误。如果允许直接修改原所有者的值，就无法提供这种安全性保证。</p>\n</li>\n<li><p><code>条件约束</code>：有时候，我们可能只能通过一些条件来确定是否可以修改数据。通过使用可变引用，我们可以在满足特定条件时修改数据，而不会将修改权交给其他代码。</p>\n</li>\n</ol>\n<p>因此，通过可变引用来修改原所有者的值可以提供更灵活、可控的操作方式，并在保持代码的安全性和可读性方面提供更好的支持。这是 Rust 中借用和所有权的核心概念之一。</p>\n<h2 id=\"函数返回只能返回值，不能返回引用？\"><a href=\"#函数返回只能返回值，不能返回引用？\" class=\"headerlink\" title=\"函数返回只能返回值，不能返回引用？\"></a>函数返回只能返回值，不能返回引用？</h2><p>在 Rust 中，函数的返回值类型可以是值类型或者引用类型。注意，要确保返回的引用类型具有有效的生命周期。</p>\n<p>对于返回值为引用类型的函数，需要使用生命周期参数来明确指定返回引用的生命周期，并保证返回的引用仍然有效。这样可以确保返回的引用在函数调用结束后仍然有效，而不会指向已经被释放的内存。</p>\n<p>下面是一个简单的例子，演示了如何返回一个引用类型的函数：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn get_str_len(s: &amp;str) -&gt; &amp;usize &#123;\n    &amp;s.len()\n&#125;\n\nfn main() &#123;\n    let my_string &#x3D; String::from(&quot;Hello, World!&quot;);\n    let len &#x3D; get_str_len(&amp;my_string);\n    println!(&quot;Length of string: &#123;&#125;&quot;, len);\n&#125;</code></pre>\n\n<p>在上面的例子中，<code>get_str_len</code> 函数接收一个字符串引用 <code>s</code>，并返回 <code>s.len()</code> 的引用。在主函数中，我们通过传递一个 <code>String</code> 类型的引用给 <code>get_str_len</code> 函数并打印返回的引用类型的值。</p>\n<p>请注意，<strong>返回引用的函数具有与参数相关的生命周期，这是为了确保引用在函数调用结束后仍然有效</strong>。</p>\n<h2 id=\"Slice-类型\"><a href=\"#Slice-类型\" class=\"headerlink\" title=\"Slice 类型\"></a>Slice 类型</h2><p>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权</p>\n<ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#slice-类型 target=\"_blank\" >Slice 类型</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#字符串-slice target=\"_blank\" >字符串 slice</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#字符串字面值就是-slice target=\"_blank\" >字符串字面值就是 slice</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#字符串-slice-作为参数 target=\"_blank\" >字符串 slice 作为参数</a></li>\n</ol>\n</li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#其他类型的-slice target=\"_blank\" >其他类型的 slice</a></li>\n</ol>\n</li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#总结 target=\"_blank\" >总结</a></li>\n</ol>\n<h2 id=\"rust-中-Slice-解决了什么问题\"><a href=\"#rust-中-Slice-解决了什么问题\" class=\"headerlink\" title=\"rust 中 Slice 解决了什么问题\"></a>rust 中 Slice 解决了什么问题</h2><p>在 Rust 中，Slice（切片）是一种数据类型，用于引用<strong>数组</strong>、<strong>字符串</strong>或者其他实现了 <code>Deref</code> trait 的类型的连续部分。Slice 提供了一种比完整数据结构更灵活的方式来访问和操作数据。</p>\n<p>Slice 解决了以下几个问题：</p>\n<ol>\n<li><p><strong>避免拷贝大量数据</strong>：当我们只需要操作一部分数据时，使用 Slice 可以避免拷贝整个数据集，节省了时间和空间。</p>\n</li>\n<li><p><strong>安全和可变性</strong>：Slice 在 Rust 中是零成本抽象，可以用于引用可变数据或不可变数据。通过 Slice，我们可以在不改变数据结构本身的情况下，对数据进行读取和修改。</p>\n</li>\n<li><p><strong>遍历和操作集合</strong>：Slice 使得遍历和操作数组或其他集合类型变得更加方便。我们可以使用迭代器的方法或者简单的索引语法来获取 Slice 中的元素。</p>\n</li>\n<li><p><strong>动态大小数据结构</strong>：Slice 提供了对动态大小数据结构（如动态分配的字符串）的引用和操作方式。通过 Slice，我们可以获取字符串的子串或者修改字符串的一部分。</p>\n</li>\n</ol>\n<p>综上所述，<strong>Slice 在 Rust 中提供了一种轻量级而强大的引用机制，使我们能够高效地操作和处理数据的一部分，同时保持代码的安全性和性能优势。</strong></p>\n<h2 id=\"“字符串-slice”-的类型声明写作-amp-str\"><a href=\"#“字符串-slice”-的类型声明写作-amp-str\" class=\"headerlink\" title=\"“字符串 slice” 的类型声明写作 &amp;str\"></a>“字符串 slice” 的类型声明写作 &amp;str</h2><p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#:~:text=%E2%80%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%20slice%E2%80%9D%20%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%86%99%E4%BD%9C%20%26str\" target=\"_blank\" >见</a></p>\n<h2 id=\"slice-不是避免错误，只是将错误提前暴露出来\"><a href=\"#slice-不是避免错误，只是将错误提前暴露出来\" class=\"headerlink\" title=\"slice 不是避免错误，只是将错误提前暴露出来\"></a>slice 不是避免错误，只是将错误提前暴露出来</h2><p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#:~:text=slice%20%E5%B0%B1%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E8%BF%99%E7%A7%8D%20bug%20%E5%B9%B6%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9B%B4%E6%97%A9%E7%9A%84%E7%9F%A5%E9%81%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86\" target=\"_blank\" >见</a></p>\n<h2 id=\"slice-为什么可以暴露\"><a href=\"#slice-为什么可以暴露\" class=\"headerlink\" title=\"slice 为什么可以暴露\"></a>slice 为什么可以暴露</h2><p>借用规则：slice 是不可变引用，更改操作需要是可变引用，因为存在了不可变引用，就不能再创建可变引用，所以 rust 可以在使用 slice，在编译阶段暴露出有问题的</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#结构体的定义和实例化 target=\"_blank\" >结构体的定义和实例化</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#使用字段初始化简写语法 target=\"_blank\" >使用字段初始化简写语法</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#使用结构体更新语法从其他实例创建实例 target=\"_blank\" >使用结构体更新语法从其他实例创建实例</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#使用没有命名字段的元组结构体来创建不同的类型 target=\"_blank\" >使用没有命名字段的元组结构体来创建不同的类型</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#没有任何字段的类单元结构体 target=\"_blank\" >没有任何字段的类单元结构体</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#结构体数据的所有权 target=\"_blank\" >结构体数据的所有权</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"结构体与元组的区别\"><a href=\"#结构体与元组的区别\" class=\"headerlink\" title=\"结构体与元组的区别\"></a>结构体与元组的区别</h2><p>结构体和我们在“元组类型”部分论过的元组类似，它们都包含多个相关的值。和元组一样，结构体的每一部分可以是不同类型。但不同于元组，结构体需要命名各部分数据以便能清楚的表明其值的意义。由于有了这些名字，结构体比元组更灵活：不需要依赖顺序来指定或访问实例中的值。</p>\n<h2 id=\"结构体是什么，与类有什么区别，与-OC、Golang-有什么区别？\"><a href=\"#结构体是什么，与类有什么区别，与-OC、Golang-有什么区别？\" class=\"headerlink\" title=\"结构体是什么，与类有什么区别，与 OC、Golang 有什么区别？\"></a>结构体是什么，与类有什么区别，与 OC、Golang 有什么区别？</h2><p>struct，或者 structure，是一个自定义数据类型，允许你包装和命名多个相关的值，从而形成一个有意义的组合</p>\n<p>在 Rust 中，结构体（Struct）是一种用户定义的自定义数据类型，用于组合多个不同类型的值，并将它们打包在一起。通过结构体，我们可以创建具有自定义属性和方法的对象。</p>\n<p>以下是 Rust 中的结构体与类和其他语言（如 OC 和 Golang）的区别：</p>\n<p><strong>1. 继承和多态性：</strong></p>\n<ul>\n<li>Rust 中的结构体不支持类继承，而是通过 trait 和 trait 实现来实现多态性。这意味着结构体不能直接继承其他结构体的属性和方法，但可以实现共享的行为约定。</li>\n<li>在类似于 OC 和 Golang 的对象导向语言中，类是继承和多态性的基本构建块，可以通过继承一个类来重用和扩展它的属性和方法。</li>\n</ul>\n<p><strong>2. 所有权和生命周期：</strong></p>\n<ul>\n<li>在 Rust 中，结构体可以包含拥有所有权的成员，这意味着对结构体进行传递时可能需要进行所有权转移。Rust 的所有权系统确保了内存安全和避免了数据竞争。</li>\n<li>在 OC 和 Golang 中，没有类似的所有权系统，可以更自由地传递和共享对象。</li>\n</ul>\n<p><strong>3. 内存管理：</strong></p>\n<ul>\n<li>Rust 使用所有权和借用机制来管理动态内存，结构体在创建时负责分配和释放其成员的内存。这种方式避免了常见的内存分配和释放错误，如使用未初始化的变量或内存泄漏。</li>\n<li>OC 和 Golang 使用垃圾回收（Garbage Collection）来自动管理内存，这意味着开发者更专注于编写代码逻辑而不是手动管理内存。</li>\n</ul>\n<p><strong>4. 零成本抽象：</strong></p>\n<ul>\n<li>在 Rust 中，结构体支持零成本抽象，不会引入运行时开销。结构体的布局是可预测的，并且可以按照需要进行优化。这使得 Rust 能够提供高性能和低级别的控制。</li>\n<li>在 OC 和 Golang 中，对象和类的实现可能涉及一些运行时开销，如虚函数表和动态派发。这些开销可能会对性能产生一定的影响。</li>\n</ul>\n<p>总的来说，Rust 的结构体与类似 OC 和 Golang 的语言中的类有一些区别。Rust 通过所有权和生命周期管理、零成本抽象和 trait 实现来提供安全性和性能。这使得 Rust 的结构体在资源管理和运行时开销等方面与其他语言有所不同。</p>\n<h2 id=\"结构体解决了什么问题？\"><a href=\"#结构体解决了什么问题？\" class=\"headerlink\" title=\"结构体解决了什么问题？\"></a>结构体解决了什么问题？</h2><h2 id=\"结构体不能解决什么问题\"><a href=\"#结构体不能解决什么问题\" class=\"headerlink\" title=\"结构体不能解决什么问题\"></a>结构体不能解决什么问题</h2><h2 id=\"结构体使用的是引用？\"><a href=\"#结构体使用的是引用？\" class=\"headerlink\" title=\"结构体使用的是引用？\"></a>结构体使用的是引用？</h2><h2 id=\"结构体是否分可变和不可变？\"><a href=\"#结构体是否分可变和不可变？\" class=\"headerlink\" title=\"结构体是否分可变和不可变？\"></a>结构体是否分可变和不可变？</h2><p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#:~:text=%E6%B3%A8%E6%84%8F%E6%95%B4%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%BF%85%E9%A1%BB%E6%98%AF%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9BRust%20%E5%B9%B6%E4%B8%8D%E5%85%81%E8%AE%B8%E5%8F%AA%E5%B0%86%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%A0%87%E8%AE%B0%E4%B8%BA%E5%8F%AF%E5%8F%98%E3%80%82%E5%8F%A6%E5%A4%96%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%90%8C%E5%85%B6%E4%BB%96%E4%BB%BB%E4%BD%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E6%A0%B7%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BD%93%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B0%E5%AE%9E%E4%BE%8B%EF%BC%8C%E6%9D%A5%E9%9A%90%E5%BC%8F%E5%9C%B0%E8%BF%94%E5%9B%9E%E8%BF%99%E4%B8%AA%E5%AE%9E%E4%BE%8B\" target=\"_blank\" >注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。另外需要注意同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例</a></p>\n<h2 id=\"结构体如何实例化\"><a href=\"#结构体如何实例化\" class=\"headerlink\" title=\"结构体如何实例化\"></a>结构体如何实例化</h2><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; struct User &#123;\n&#x2F;&#x2F;     active: bool,\n&#x2F;&#x2F;     username: String,\n&#x2F;&#x2F;     email: String,\n&#x2F;&#x2F;     sign_in_count: u64,\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; fn main() &#123;\n\n&#x2F;&#x2F; 方式1： 直接初始化，类似js对象\n&#x2F;&#x2F;     let mut user1 &#x3D; User &#123;\n&#x2F;&#x2F;         active: true,\n&#x2F;&#x2F;         username: String::from(&quot;someusername123&quot;),\n&#x2F;&#x2F;         email: String::from(&quot;someone@example.com&quot;),\n&#x2F;&#x2F;         sign_in_count: 1,\n&#x2F;&#x2F;     &#125;;\n\n&#x2F;&#x2F;     user1.email &#x3D; String::from(&quot;anotheremail@example.com&quot;);\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; 方式2: 类似构造函数\n&#x2F;&#x2F; fn build_user(email: String, username: String) -&gt; User &#123;\n&#x2F;&#x2F;     User &#123;\n&#x2F;&#x2F;         active: true,\n&#x2F;&#x2F;         username: username,\n&#x2F;&#x2F;         email: email,\n&#x2F;&#x2F;         sign_in_count: 1,\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;\n\n\n&#x2F;&#x2F; struct User &#123;\n&#x2F;&#x2F;     active: bool,\n&#x2F;&#x2F;     username: String,\n&#x2F;&#x2F;     email: String,\n&#x2F;&#x2F;     sign_in_count: u64,\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; 方式3: 简写\n&#x2F;&#x2F; fn build_user(email: String, username: String) -&gt; User &#123;\n&#x2F;&#x2F;     User &#123;\n&#x2F;&#x2F;         active: true,\n&#x2F;&#x2F;         username, &#x2F;&#x2F; 这里\n&#x2F;&#x2F;         email,\n&#x2F;&#x2F;         sign_in_count: 1,\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; fn main() &#123;\n&#x2F;&#x2F;     let user1 &#x3D; build_user(\n&#x2F;&#x2F;         String::from(&quot;someone@example.com&quot;),\n&#x2F;&#x2F;         String::from(&quot;someusername123&quot;),\n&#x2F;&#x2F;     );\n&#x2F;&#x2F; &#125;\n\n\n\n\n&#x2F;&#x2F; struct User &#123;\n&#x2F;&#x2F;     active: bool,\n&#x2F;&#x2F;     username: String, &#x2F;&#x2F; 这里不是&amp;str\n&#x2F;&#x2F;     email: String,\n&#x2F;&#x2F;     sign_in_count: u64,\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; fn main() &#123;\n&#x2F;&#x2F;     &#x2F;&#x2F; --snip--\n\n&#x2F;&#x2F;     let user1 &#x3D; User &#123;\n&#x2F;&#x2F;         email: String::from(&quot;someone@example.com&quot;),\n&#x2F;&#x2F;         使用了自身拥有所有权的 String 类型而不是 &amp;str 字符串 slice 类型\n&#x2F;&#x2F;         username: String::from(&quot;someusername123&quot;),\n&#x2F;&#x2F;         active: true,\n&#x2F;&#x2F;         sign_in_count: 1,\n&#x2F;&#x2F;     &#125;;\n\n&#x2F;&#x2F; 方式4: .. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。\n&#x2F;&#x2F;     let user2 &#x3D; User &#123;\n&#x2F;&#x2F;         email: String::from(&quot;another@example.com&quot;),\n&#x2F;&#x2F;         ..user1 &#x2F;&#x2F; 结构更新语法就像带有 &#x3D; 的赋值， 在创建 user2 后不能就再使用 user1 了\n&#x2F;&#x2F;     &#125;;\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; 方式4，补充说明\n&#x2F;&#x2F; 如果我们给 user2 的 email 和 username 都赋予新的 String 值，从而只使用 user1 的 active 和 sign_in_count 值，那么 user1 在创建 user2 后仍然有效。active 和 sign_in_count 的类型是实现 Copy trait 的类型\n</code></pre>\n\n<h2 id=\"结构体的属性和方法如何调用\"><a href=\"#结构体的属性和方法如何调用\" class=\"headerlink\" title=\"结构体的属性和方法如何调用\"></a>结构体的属性和方法如何调用</h2><h2 id=\"结构体示例\"><a href=\"#结构体示例\" class=\"headerlink\" title=\"结构体示例\"></a>结构体示例</h2><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-02-example-structs.html#结构体示例程序 target=\"_blank\" >结构体示例程序</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-02-example-structs.html#使用元组重构 target=\"_blank\" >使用元组重构</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-02-example-structs.html#使用结构体重构赋予更多意义 target=\"_blank\" >使用结构体重构：赋予更多意义</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch05-02-example-structs.html#通过派生-trait-增加实用功能 target=\"_blank\" >通过派生 trait 增加实用功能</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"结构体打印\"><a href=\"#结构体打印\" class=\"headerlink\" title=\"结构体打印\"></a>结构体打印</h2><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; step1: 需要加入 #[derive(Debug)]\n#[derive(Debug)]\nstruct Rectangle &#123;\n    width: u32,\n    height: u32,\n&#125;\n\nfn main() &#123;\n    let rect1 &#x3D; Rectangle &#123;\n        width: 30,\n        height: 50,\n    &#125;;\n    &#x2F;&#x2F; step2: &#123;:?&#125;\n    println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);\n&#125;\n</code></pre>\n\n<h2 id=\"rust-中为什么要-在结构体定义之前加上外部属性-derive-Debug\"><a href=\"#rust-中为什么要-在结构体定义之前加上外部属性-derive-Debug\" class=\"headerlink\" title=\"rust 中为什么要 在结构体定义之前加上外部属性#[derive(Debug)]\"></a>rust 中为什么要 在结构体定义之前加上外部属性<code>#[derive(Debug)]</code></h2><p>在 Rust 中，结构体可以通过添加外部属性（attribute）<code>#[derive(Debug)]</code>来自动实现<code>Debug</code> trait。<code>Debug</code> trait 允许打印出结构体的调试信息，便于开发者进行调试。</p>\n<p>添加<code>#[derive(Debug)]</code>属性的作用是告诉编译器自动生成实现<code>Debug</code> trait 所需的代码，而无需手动编写。这样的自动实现能够生成一个默认的调试输出，它会以一种格式化的方式打印出结构体的所有字段的值。这包括在调试输出中显示结构体的字段名称和对应的值，方便开发者进行调试和排错。</p>\n<p>使用<code>#[derive(Debug)]</code>这样的派生属性，可以大大简化开发者的工作，减少了手动编写和维护调试输出代码的麻烦。此外，Rust 还支持自定义实现<code>Debug</code> trait，以便更灵活地控制结构体的调试输出方式。</p>\n<p>总结来说，通过在结构体定义之前添加外部属性<code>#[derive(Debug)]</code>，可以自动为结构体实现<code>Debug</code> trait，从而方便地打印出结构体的调试信息。</p>\n<h2 id=\"rust-为什么不默认-derive-Debug-？\"><a href=\"#rust-为什么不默认-derive-Debug-？\" class=\"headerlink\" title=\"rust 为什么不默认#[derive(Debug)] ？\"></a>rust 为什么不默认<code>#[derive(Debug)]</code> ？</h2><p>Rust 不默认添加 <code>#[derive(Debug)]</code> 的原因是<strong>为了避免在编译时生成不必要的调试信息，从而减小生成的可执行文件的大小</strong>。Rust 的设计哲学之一是尽量减少不必要的开销和默认行为，以提供更高效和更可控的代码。因此，如果每个结构体都默认添加了 <code>#[derive(Debug)]</code>，那么会导致编译器生成大量的调试信息，增加最终可执行文件的大小。</p>\n<p>此外，Rust 更重视开发者的主动选择和控制。默认不添加 <code>#[derive(Debug)]</code>，使得开发者可以根据自己的需要选择是否添加该属性。如果结构体的调试输出对于特定项目或特定的上下文不重要，或者考虑到优化可执行文件大小的需求，开发者可以选择不添加 <code>#[derive(Debug)]</code>。</p>\n<p>虽然默认不添加 <code>#[derive(Debug)]</code>，但是在需要的时候，开发者仍然可以在结构体上手动添加该属性来实现调试输出功能。这种显式的选择机制允许开发者根据具体情况进行灵活地配置，并避免了不必要的开销。</p>\n<p>总结来说，Rust 默认不添加 <code>#[derive(Debug)]</code> 是为了避免编译时生成不必要的调试信息和控制生成的可执行文件大小，同时也是为了重视开发者的主动选择和控制。开发者可以根据自己的需求决定是否添加 <code>#[derive(Debug)]</code>。</p>\n<h2 id=\"官网文档-描述了为什么不能直接打印\"><a href=\"#官网文档-描述了为什么不能直接打印\" class=\"headerlink\" title=\"官网文档 描述了为什么不能直接打印\"></a>官网文档 描述了为什么不能直接打印</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>println! 宏能处理很多类型的格式，不过，{} 默认告诉 println! 使用被称为 Display 的格式：意在提供给直接终端用户查看的输出。目前为止见过的基本类型都默认实现了 Display，因为它就是向用户展示 1 或其他任何基本类型的唯一方式。</p>\n<p>不过对于结构体，println! 应该用来输出的格式是不明确的，因为这有更多显示的可能性：是否需要逗号？需要打印出大括号吗？所有字段都应该显示吗？</p>\n<p>由于这种不确定性，Rust 不会尝试猜测我们的意图，所以结构体并没有提供一个 Display 实现来使用 println! 与 {} 占位符</p></blockquote>\n<h2 id=\"其他语言，自己转化后格式后，直接给输出-api-进行输出\"><a href=\"#其他语言，自己转化后格式后，直接给输出-api-进行输出\" class=\"headerlink\" title=\"其他语言，自己转化后格式后，直接给输出 api 进行输出\"></a>其他语言，自己转化后格式后，直接给输出 api 进行输出</h2><p>在其他语言中，你可能需要自己编写代码来格式化数据并将其传递给输出 API 进行输出。这通常涉及以下几个步骤：</p>\n<ol>\n<li><p>数据格式化：将数据转换为所需的格式。这可能包括文本拼接、字符串格式化、日期格式化等，具体取决于你的需求和编程语言的特性。</p>\n</li>\n<li><p>构建输出：根据输出的要求，将格式化的数据包装到适当的数据结构或对象中。例如，将数据放入一个 HTTP 请求体、一个文件对象、一个消息队列等。</p>\n</li>\n<li><p>调用输出 API：使用适当的方法或函数调用输出 API，并将格式化的数据作为参数传递给它。这可能涉及网络请求、文件写入、消息发布等操作，具体取决于你的需求和所使用的 API。</p>\n</li>\n</ol>\n<p>以下是一些示例，展示了不同编程语言中的输出格式化和输出 API 调用的常见方式：</p>\n<h4 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import requests\n\ndata &#x3D; &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;\nformatted_data &#x3D; &quot;Name: &#123;0&#125;, Age: &#123;1&#125;&quot;.format(data[&quot;name&quot;], data[&quot;age&quot;])\n\nresponse &#x3D; requests.post(&quot;https:&#x2F;&#x2F;example.com&#x2F;api&quot;, data&#x3D;formatted_data)</code></pre>\n\n<h4 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const axios &#x3D; require(&#39;axios&#39;);\n\nconst data &#x3D; &#123; name: &#39;John&#39;, age: 30 &#125;;\nconst formattedData &#x3D; &#96;Name: $&#123;data.name&#125;, Age: $&#123;data.age&#125;&#96;;\n\naxios\n  .post(&#39;https:&#x2F;&#x2F;example.com&#x2F;api&#39;, formattedData)\n  .then((response) &#x3D;&gt; &#123;\n    console.log(response.data);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error);\n  &#125;);</code></pre>\n\n<h4 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main &#123;\n    public static void main(String[] args) throws IOException &#123;\n        String data &#x3D; &quot;&#123;\\&quot;name\\&quot;:\\&quot;John\\&quot;, \\&quot;age\\&quot;:30&#125;&quot;;\n        String formattedData &#x3D; &quot;Name: &quot; + data.name + &quot;, Age: &quot; + data.age;\n\n        URL url &#x3D; new URL(&quot;https:&#x2F;&#x2F;example.com&#x2F;api&quot;);\n        HttpURLConnection connection &#x3D; (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(&quot;POST&quot;);\n        connection.setDoOutput(true);\n\n        try (OutputStream outputStream &#x3D; connection.getOutputStream()) &#123;\n            byte[] input &#x3D; formattedData.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n        &#125;\n\n        int responseCode &#x3D; connection.getResponseCode();\n        System.out.println(&quot;Response Code: &quot; + responseCode);\n    &#125;\n&#125;</code></pre>\n\n<p>请注意，以上代码示例仅为演示目的，并未处理所有可能的异常或错误检查。根据你的实际情况，你可能需要添加适当的错误处理和异常处理机制。</p>\n<h2 id=\"为什么-rust-不这么做？\"><a href=\"#为什么-rust-不这么做？\" class=\"headerlink\" title=\"为什么 rust 不这么做？\"></a>为什么 rust 不这么做？</h2><p>Rust 是一种系统级编程语言，注重内存安全、并发性和性能。它提供了强大的静态类型系统和所有权模型，以确保程序的安全性和性能。与其他高级语言相比，Rust 更加注重编译时的错误检查和安全性保证。</p>\n<p>在 Rust 中，与其他语言不同，Rust 社区通常倾向于编写更安全、更可靠的代码，而不是提供直接的输出 API。Rust 鼓励使用底层的组件和库，以便开发人员可以根据自己的需求进行自定义和优化。</p>\n<p>当需要转化和格式化数据后输出时，Rust 提供了许多工具、库和宏来实现这一目的。你可以使用标准库中的格式化宏（如<code>format!</code>和<code>println!</code>）或其他第三方库，例如<code>serde</code>和<code>serde_json</code>来序列化和反序列化数据。</p>\n<p>一般情况下，Rust 开发者会根据他们的具体需求使用这些工具和库，可能会编写一些自定义的代码来管理数据、格式化和传递给输出 API。这样可以使开发者有更多的灵活性和控制权，以获得更高的性能和更好的安全性保证。</p>\n<p>总而言之，Rust 的设计理念是保证代码的安全性和性能，同时提供了丰富的工具、库和宏，以便开发人员根据自己的需求进行自定义和优化。这种设计方式使得 Rust 可以提供高效且安全的系统级编程体验。</p>\n<h2 id=\"我想问的是：结构体为什么转化后直接输出，需要加个-derive-Debug-标记\"><a href=\"#我想问的是：结构体为什么转化后直接输出，需要加个-derive-Debug-标记\" class=\"headerlink\" title=\"我想问的是：结构体为什么转化后直接输出，需要加个 #[derive(Debug)] 标记\"></a>我想问的是：结构体为什么转化后直接输出，需要加个 <code>#[derive(Debug)]</code> 标记</h2><p>在 Rust 中，结构体是一种用户自定义的数据类型，用于存储和组织相关数据。当我们想要打印（输出）一个结构体的实例时，我们需要告诉编译器如何格式化结构体的输出。</p>\n<p><code>#[derive(Debug)]</code> 是一个派生属性宏（attribute macro），它可以自动为结构体或枚举类型实现 <code>Debug</code> trait，该 trait 提供了一个默认的格式化输出方式。通过在结构体上应用这个派生属性宏，编译器可以自动生成实现 <code>Debug</code> trait 的代码，这样我们就可以使用 <code>println!</code> 宏或其他需要 <code>Debug</code> trait 的输出函数来打印结构体的实例。</p>\n<p><code>Debug</code> trait 的打印格式通常是比较重量级和详细的，适合用于调试目的。它会以一种可读性较高、冗长的方式打印结构体的字段和值，方便我们在开发和调试过程中观察结构体的内容。</p>\n<p>然而，如果我们希望以不同的方式格式化输出结构体实例，可以手动实现 <code>std::fmt::Display</code> trait 或自定义一个输出格式的方法。这样可以根据具体需求进行格式化，并在需要的时候以所需的格式输出结构体。</p>\n<p>总结来说，加上 <code>#[derive(Debug)]</code> 标记，可以为结构体自动生成实现 <code>Debug</code> trait 的代码，方便我们以默认的打印格式输出结构体实例。此外，如果我们需要更精确或自定义的输出格式，可以手动实现 <code>Display</code> trait 或使用其他方法来控制结构体的输出。</p>\n<h2 id=\"这比-golang-中的-marshal-后在进行-print-有什么优势？\"><a href=\"#这比-golang-中的-marshal-后在进行-print-有什么优势？\" class=\"headerlink\" title=\"这比 golang 中的 marshal 后在进行 print 有什么优势？\"></a>这比 golang 中的 marshal 后在进行 print 有什么优势？</h2><p>将结构体转换为字符串进行打印的过程在 Rust 和 Go 中有一些区别。下面是与 Rust 中的 <code>#[derive(Debug)]</code> 相比，Go 中的 <code>marshal</code> 结合打印所具有的一些优势：</p>\n<ol>\n<li><p><strong>自定义输出格式：</strong> 在 Go 中，你可以使用 Marshal 函数将结构体转换为字节切片或字符串，然后按照需要进行自定义格式化输出。你可以使用 Marshal 函数的选项来控制缩进、字段顺序等。这样你可以根据自己的需求轻松地控制输出的格式。</p>\n</li>\n<li><p><strong>支持不同的编码格式：</strong> Go 的 Marshal 函数可以将结构体序列化为多种不同的数据格式，例如 JSON、XML 或 Protocol Buffers。你可以轻松选择合适的格式，并使用相应的工具进行解析和处理。</p>\n</li>\n<li><p><strong>更好的兼容性：</strong> Go 的 Marshal 函数生成的输出是机器可读的，可以很容易地被其他程序解析和处理。这在系统间的数据交换和通信中非常有用。</p>\n</li>\n<li><p><strong>灵活性：</strong> Go 的 Marshal 函数返回的是字节切片或字符串，你可以自由选择将其打印输出或以其他方式使用。这种灵活性允许你将结构体的数据用于不同的场景，而不仅仅局限于打印输出。</p>\n</li>\n</ol>\n<p>相比之下，Rust 的 <code>#[derive(Debug)]</code> 机制主要用于调试目的，它提供了一种默认的格式化输出方式。虽然你也可以通过手动实现 <code>std::fmt::Display</code> trait 或使用其他方式进行自定义输出，但与 Go 相比，Rust 的格式化输出选项相对较少。当需要进行复杂的格式化、特定的编码格式或更高的灵活性时，Go 的 Marshal 函数提供了更多的优势。</p>\n<h2 id=\"derive-Debug-是不是-装饰器？\"><a href=\"#derive-Debug-是不是-装饰器？\" class=\"headerlink\" title=\"#[derive(Debug)] 是不是 装饰器？\"></a><code>#[derive(Debug)]</code> 是不是 装饰器？</h2><p>在 Rust 中，<code>#[derive(Debug)]</code> 并不是装饰器，而是一个属性宏（Attribute Macro）。属性宏是一种用于修改、扩展或自定义代码的注解形式。<code>#[derive(Debug)]</code> 是一个特殊的属性宏，它用于自动生成实现 <code>std::fmt::Debug</code> trait 的代码。</p>\n<p><code>#[derive(Debug)]</code> 将会根据结构体的定义自动生成打印调试信息的代码。它会为结构体的每个字段实现 <code>std::fmt::Debug</code> trait，以支持通过 <code>println!</code> 宏等打印结构体时的格式化输出。这种自动实现的方式非常方便，因为你无需手动编写打印调试信息的代码，而是通过简单地在结构体上添加 <code>#[derive(Debug)]</code> 属性来实现。</p>\n<p>使用 <code>#[derive(Debug)]</code> 属性宏可以快速为结构体、枚举或联合类型实现 <code>Debug</code> trait 的打印功能，它是 Rust 语言提供的一种便捷的机制。</p>\n<h2 id=\"注解不是装饰器模式？\"><a href=\"#注解不是装饰器模式？\" class=\"headerlink\" title=\"注解不是装饰器模式？\"></a>注解不是装饰器模式？</h2><p>在 Rust 中，虽然属性宏（Attribute Macro）与装饰器模式有些相似，但它们不是完全相同的概念。</p>\n<p>装饰器模式是一种设计模式，用于动态地给对象添加额外的行为或功能，而不需要修改原始对象的结构。装饰器模式通过将对象包装在一个或多个装饰器类中来实现，这些装饰器类实现了相同的接口，以使其具有统一的行为。</p>\n<p>在 Rust 中，属性宏（Attribute Macro）是一种元编程的机制，允许开发者在编写代码时向 Rust 编译器提供附加信息或指令。属性宏用于修改、扩展或自定义代码，但并没有像装饰器模式那样在运行时动态地添加功能或行为。</p>\n<p>尽管属性宏在某种程度上使得代码的逻辑与注解代码更加分离和清晰，并可以用于为结构体或函数自动生成代码，但在语义上它们与装饰器模式不同。在 Rust 中，一般通过属性宏来实现元编程，而没有直接实现装饰器模式。</p>\n<h2 id=\"golang-和-rust-结构体方法都设计到结构体之外\"><a href=\"#golang-和-rust-结构体方法都设计到结构体之外\" class=\"headerlink\" title=\"golang 和 rust 结构体方法都设计到结构体之外\"></a>golang 和 rust 结构体方法都设计到结构体之外</h2><p>在 Go 和 Rust 中，结构体的方法都可以定义在结构体之外，以实现对结构体的功能扩展。然而，它们在语法和实现细节上有所不同。</p>\n<p>在 Go 中，结构体的方法被定义在与结构体不同的区块中，但在同一个包内。这意味着方法并不是直接属于结构体，而是与结构体相关联的包级函数。在方法定义中，需要使用一个特殊的接收者类型来标识该方法属于哪个结构体。例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type MyStruct struct &#123;\n    &#x2F;&#x2F; 结构体字段\n&#125;\n\n&#x2F;&#x2F; 方法定义\nfunc (s *MyStruct) MyMethod() &#123;\n    &#x2F;&#x2F; 方法实现\n&#125;</code></pre>\n\n<p>在 Rust 中，结构体的方法定义在结构体的上下文内，并使用 <code>impl</code> 块来指定它们。方法可以通过 <code>self</code> 或 <code>&amp;self</code> 参数来引用结构体实例，以及其他关键字（如 <code>mut</code>）来指定是否允许方法修改结构体的内容。例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">struct MyStruct &#123;\n    &#x2F;&#x2F; 结构体字段\n&#125;\n\n&#x2F;&#x2F; 方法定义\nimpl MyStruct &#123;\n    &#x2F;&#x2F; 不可变引用\n    fn my_method(&amp;self) &#123;\n        &#x2F;&#x2F; 方法实现\n    &#125;\n\n    &#x2F;&#x2F; 可变引用\n    fn another_method(&amp;mut self) &#123;\n        &#x2F;&#x2F; 方法实现\n    &#125;\n&#125;</code></pre>\n\n<p>需要注意的是，虽然 Go 和 Rust 都允许在结构体之外定义方法，但它们的语法和用法有所不同，因此在进行跨语言开发时需要注意这些细节和差异。</p>\n<h2 id=\"为什么不设计到结构体内部，像-class-类那样\"><a href=\"#为什么不设计到结构体内部，像-class-类那样\" class=\"headerlink\" title=\"为什么不设计到结构体内部，像 class 类那样\"></a>为什么不设计到结构体内部，像 class 类那样</h2><p>Go 和 Rust 是不同的编程语言，它们的设计哲学和语法都各自独立，没有直接的类似于面向对象编程中的 class 概念。</p>\n<p>在 Go 中，为了保持简洁和一致性，它采用了一种类似于 C 的结构体定义和函数式编程的方法，没有提供类似于 class 的语法。相反，Go 强调使用结构体和相关的方法来组织代码。这种设计使得结构体与方法之间的关系更加清晰，更易于维护和理解。</p>\n<p>在 Rust 中，同样也没有类似于传统面向对象编程中的 class 概念。Rust 更加强调所有权和借用规则，并且通过结构体和实现块 (impl blocks) 来实现方法。这种设计符合 Rust 的所有权模型，也更加贴合其资源管理和线程安全的理念。</p>\n<p>虽然 Go 和 Rust 的设计在某种程度上不同于传统的面向对象编程语言，但它们的目标是提供一种简洁而强大的基于结构体的编程模型，以满足不同的编程需求。这种设计也使得它们在并发编程和系统级编程方面具有优势。</p>\n<h2 id=\"amp-self\"><a href=\"#amp-self\" class=\"headerlink\" title=\"&amp;self\"></a>&amp;self</h2><p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#:~:text=%E5%9C%A8%20area%20%E7%9A%84%E7%AD%BE%E5%90%8D%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%20%26self%20%E6%9D%A5%E6%9B%BF%E4%BB%A3%20rectangle%3A%20%26Rectangle%EF%BC%8C%26self%20%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%20self%3A%20%26Self%20%E7%9A%84%E7%BC%A9%E5%86%99%E3%80%82%E5%9C%A8%E4%B8%80%E4%B8%AA%20impl%20%E5%9D%97%E4%B8%AD%EF%BC%8CSelf%20%E7%B1%BB%E5%9E%8B%E6%98%AF%20impl%20%E5%9D%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%AB%E5%90%8D%E3%80%82%E6%96%B9%E6%B3%95%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA%20self%20%E7%9A%84Self%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E6%89%80%E4%BB%A5%20Rust%20%E8%AE%A9%E4%BD%A0%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E5%8F%AA%E7%94%A8%20self%20%E8%BF%99%E4%B8%AA%E5%90%8D%E5%AD%97%E6%9D%A5%E7%BC%A9%E5%86%99\" target=\"_blank\" >&amp;self 是缩写</a></p>\n<h2 id=\"自动引用和解引用\"><a href=\"#自动引用和解引用\" class=\"headerlink\" title=\"自动引用和解引用\"></a>自动引用和解引用</h2><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">\n&#x2F;&#x2F; 在 C&#x2F;C++ 语言中，有两个不同的运算符来调用方法：\n&#x2F;&#x2F; . 直接在对象上调用方法，\n&#x2F;&#x2F; 而 -&gt; 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。\n&#x2F;&#x2F; 换句话说，如果 object 是一个指针，那么 object-&gt;something() 就像 (*object).something() 一样。\n\n&#x2F;&#x2F; Rust 并没有一个与 -&gt; 等效的运算符；\n&#x2F;&#x2F; 相反，Rust 有一个叫 自动引用和解引用（automatic referencing and dereferencing）的功能。\n&#x2F;&#x2F; 方法调用是 Rust 中少数几个拥有这种行为的地方。\n\n&#x2F;&#x2F; 它是这样工作的：\n&#x2F;&#x2F; 当使用 object.something() 调用方法时，\n&#x2F;&#x2F; Rust 会自动为 object 添加 &amp;、&amp;mut 或 * 以便使 object 与方法签名匹配。\n&#x2F;&#x2F; 也就是说，这些代码是等价的：\n\n#![allow(unused)]\nfn main() &#123;\n#[derive(Debug,Copy,Clone)]\nstruct Point &#123;\n    x: f64,\n    y: f64,\n&#125;\n\nimpl Point &#123;\n   fn distance(&amp;self, other: &amp;Point) -&gt; f64 &#123;\n       let x_squared &#x3D; f64::powi(other.x - self.x, 2);\n       let y_squared &#x3D; f64::powi(other.y - self.y, 2);\n\n       f64::sqrt(x_squared + y_squared)\n   &#125;\n&#125;\nlet p1 &#x3D; Point &#123; x: 0.0, y: 0.0 &#125;;\nlet p2 &#x3D; Point &#123; x: 5.0, y: 6.5 &#125;;\n\n&#x2F;&#x2F; 下面两个等效\np1.distance(&amp;p2);\n(&amp;p1).distance(&amp;p2);\n&#125;\n&#x2F;&#x2F; 第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— self 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（&amp;self），做出修改（&amp;mut self）或者是获取所有权（self）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</code></pre>\n\n<h2 id=\"结构体的方法-在-Rust-中叫-“关联函数”\"><a href=\"#结构体的方法-在-Rust-中叫-“关联函数”\" class=\"headerlink\" title=\"结构体的方法 在 Rust 中叫 “关联函数”\"></a>结构体的方法 在 Rust 中叫 “关联函数”</h2><ol>\n<li>一个关联块中，关联多个函数</li>\n<li>多个关联块中，各关联一个函数</li>\n</ol>\n<p>二者等效，在这一点上，有点类似 <code>typescipt</code> 中的 <code>interface</code></p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch06-01-defining-an-enum.html#枚举的定义 target=\"_blank\" >枚举的定义</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch06-01-defining-an-enum.html#枚举值 target=\"_blank\" >枚举值</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch06-01-defining-an-enum.html#option-枚举和其相对于空值的优势 target=\"_blank\" >Option 枚举和其相对于空值的优势</a></li>\n</ol>\n</li>\n</ol>\n<h1 id=\"范型\"><a href=\"#范型\" class=\"headerlink\" title=\"范型\"></a>范型</h1><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#泛型数据类型 target=\"_blank\" >泛型数据类型</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#在函数定义中使用泛型 target=\"_blank\" >在函数定义中使用泛型</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#结构体定义中的泛型 target=\"_blank\" >结构体定义中的泛型</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#枚举定义中的泛型 target=\"_blank\" >枚举定义中的泛型</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#方法定义中的泛型 target=\"_blank\" >方法定义中的泛型</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#泛型代码的性能 target=\"_blank\" >泛型代码的性能</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"单态化\"><a href=\"#单态化\" class=\"headerlink\" title=\"单态化\"></a>单态化</h2><p>Rust 通过在编译时进行泛型代码的<code>单态化</code>（monomorphization）来保证效率。<br><code>单态化</code>是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202306292302376.webp\" />\n\n<h1 id=\"trait\"><a href=\"#trait\" class=\"headerlink\" title=\"trait\"></a>trait</h1><h2 id=\"为什么引入-trait，它解决了什么问题？\"><a href=\"#为什么引入-trait，它解决了什么问题？\" class=\"headerlink\" title=\"为什么引入 trait，它解决了什么问题？\"></a>为什么引入 trait，它解决了什么问题？</h2><p>引入 trait 的目的是为了解决在静态类型语言中灵活地为类型添加共享行为的问题。在这里，我们讨论的是 Rust 中的 trait。</p>\n<p>Trait 提供了一种抽象的方式来定义共享的行为，并使不同类型能够以相同或类似的方式使用这些行为。它们可以被用于实现多态、代码复用和抽象化，从而提高代码的可维护性、可扩展性和灵活性。</p>\n<p>Trait 的引入解决了以下几个问题：</p>\n<p><strong>1. 代码复用和抽象化</strong>：Trait 允许定义一组方法的契约，将这些契约应用于多个不同的类型。通过实现这些 trait，我们可以为不同的类型提供共享的行为，而无需重复编写相同的代码。</p>\n<p><strong>2. 多态性</strong>：Trait 允许我们在不同的类型上调用相同的方法。这使得我们可以以一致的方式处理不同类型的对象，并实现运行时的多态性。这对于编写可扩展的代码非常有用。</p>\n<p><strong>3. 接口隔离</strong>：Trait 让我们能够定义只关注特定行为的接口，并使具体类型能够选择性地实现这些接口。这种接口隔离的能力使得我们可以更好地组织和设计代码。</p>\n<p><strong>4. 扩展性</strong>：Trait 可以用于进行功能扩展。通过实现新的 trait，我们可以为现有的类型添加新的行为，而无需修改原始类型的定义。这种扩展性使得代码更容易维护和扩展。</p>\n<p>因此，引入 trait 使得 Rust 程序能够更好地进行代码复用、抽象化和多态性实现，从而提高代码的灵活性和可维护性。它是 Rust 语言中的一个重要特性，推动了优秀的软件工程实践。</p>\n<h2 id=\"trait-与接口有何异同？\"><a href=\"#trait-与接口有何异同？\" class=\"headerlink\" title=\"trait 与接口有何异同？\"></a>trait 与接口有何异同？</h2><p>Trait 和接口在某种程度上是类似的概念，但也存在一些区别。以下是 trait 和接口的异同之处：</p>\n<p><strong>相似之处：</strong></p>\n<ul>\n<li>Trait 和接口都用于定义共享的行为或契约。</li>\n<li>它们都可以被类型实现，以提供具体的行为。</li>\n<li>Trait 和接口都支持多态性，即可以以一致的方式处理不同类型的对象。</li>\n</ul>\n<p><strong>不同之处：</strong></p>\n<ul>\n<li>Trait 是 Rust 语言中的概念，而接口是一种更为通用的概念，在许多面向对象的编程语言中都存在。</li>\n<li>Trait 可以包含默认的方法实现，这使得实现 trait 的类型只需要提供部分方法的实现。而接口通常只定义方法签名，要求实现的类型必须实现所有的方法。</li>\n<li>Trait 支持多重实现，即一个类型可以实现多个 trait。而一些语言中的接口通常只支持单一实现，一个类型只能实现一个接口。</li>\n<li>在 Rust 中，trait 可以包含关联类型和关联常量，从而允许类型在实现 trait 时指定具体的类型或常量值。</li>\n</ul>\n<p>总的来说，Trait 是 Rust 特有的概念，相对于一些其他语言中的接口，它提供了更丰富的特性，例如默认方法、多重实现、关联类型等。Trait 在 Rust 中被广泛用于抽象行为和类型多态性的实现，而接口是一种更通用的概念，可以在多种编程语言中找到。</p>\n<h1 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h1><h2 id=\"println-字符串占位符有哪些\"><a href=\"#println-字符串占位符有哪些\" class=\"headerlink\" title=\"println! 字符串占位符有哪些\"></a>println! 字符串占位符有哪些</h2><p>在 Rust 中，println! 宏是一种用于输出文本到标准输出流的方式。它的基本语法是：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">println!(“format string”, value1, value2, …);</code></pre>\n\n<p>format string 是一段包含占位符的文本，用于指定输出格式，value1, value2, … 是要输出的值，它们将按照 format string 中的占位符进行格式化输出。</p>\n<p>以下是常用的 println! 字符串占位符：</p>\n<table>\n<thead>\n<tr>\n<th>占位符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>{}</td>\n<td>普通占位符，用于输出默认格式</td>\n</tr>\n<tr>\n<td>{:?}</td>\n<td>调试占位符，用于输出调试信息</td>\n</tr>\n<tr>\n<td>{:#?}</td>\n<td>带有 # 的调试占位符，用于输出带有标识符的调试信息</td>\n</tr>\n<tr>\n<td>{:b}</td>\n<td>二进制占位符，用于输出二进制数值</td>\n</tr>\n<tr>\n<td>{:o}</td>\n<td>八进制占位符，用于输出八进制数值</td>\n</tr>\n<tr>\n<td>{:x}</td>\n<td>小写十六进制占位符，用于输出小写十六进制数值</td>\n</tr>\n<tr>\n<td>{:X}</td>\n<td>大写十六进制占位符，用于输出大写十六进制数值</td>\n</tr>\n</tbody></table>\n<p>需要注意的是，在使用 println! 宏时，Rust 要求占位符必须与相应的值类型匹配，否则程序将无法编译通过。</p>\n<h2 id=\"匹配嵌套\"><a href=\"#匹配嵌套\" class=\"headerlink\" title=\"匹配嵌套\"></a>匹配嵌套</h2><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">use std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() &#123;\n    let greeting_file_result &#x3D; File::open(&quot;hello.txt&quot;);\n\n    let greeting_file &#x3D; match greeting_file_result &#123;\n        Ok(file) &#x3D;&gt; file,\n        Err(error) &#x3D;&gt; match error.kind() &#123;\n            ErrorKind::NotFound &#x3D;&gt; match File::create(&quot;hello.txt&quot;) &#123;\n                Ok(fc) &#x3D;&gt; fc,\n                Err(e) &#x3D;&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e),\n            &#125;,\n            other_error &#x3D;&gt; &#123;\n                panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error);\n            &#125;\n        &#125;,\n    &#125;;\n&#125;\n</code></pre>\n\n<h2 id=\"传递错误\"><a href=\"#传递错误\" class=\"headerlink\" title=\"传递错误\"></a>传递错误</h2><p>除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误，</p>\n<p>这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">#![allow(unused)]\nfn main() &#123;\n  &#x2F;&#x2F; 这里搞的有点像动态es6 require和import混合体了\n  use std::fs::File;\n  use std::io::&#123;self, Read&#125;;\n\n  fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;\n      let username_file_result &#x3D; File::open(&quot;hello.txt&quot;);\n\n      let mut username_file &#x3D; match username_file_result &#123;\n          Ok(file) &#x3D;&gt; file,\n          Err(e) &#x3D;&gt; return Err(e),\n      &#125;;\n\n      let mut username &#x3D; String::new();\n\n      match username_file.read_to_string(&amp;mut username) &#123;\n          Ok(_) &#x3D;&gt; Ok(username),\n          Err(e) &#x3D;&gt; Err(e),\n      &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 调用这个函数的代码最终会得到一个包含用户名的 Ok 值，或者一个包含 io::Error 的 Err 值。\n&#x2F;&#x2F; 我们无从得知调用者会如何处理这些值。\n&#x2F;&#x2F; 例如，如果他们得到了一个 Err 值，他们可能会选择 panic! 并使程序崩溃、使用一个默认的用户名或者从文件之外的地方寻找用户名。\n&#x2F;&#x2F; 我们没有足够的信息知晓调用者具体会如何尝试，所以将所有的成功或失败信息向上传播，让他们选择合适的处理方法。\n\n\n</code></pre>\n\n<ol>\n<li>? 运算符消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 ? 之后直接使用链式方法调用来进一步缩短代码</li>\n<li>? 运算符只能被用于返回值与 ? 作用的值相兼容的函数</li>\n</ol>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 示例1\n#![allow(unused)]\nfn main() &#123;\n  use std::fs::File;\n  use std::io::&#123;self, Read&#125;;\n\n  fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;\n      let mut username_file &#x3D; File::open(&quot;hello.txt&quot;)?; &#x2F;&#x2F; ？有panic不处理，继续上抛\n      let mut username &#x3D; String::new();\n      username_file.read_to_string(&amp;mut username)?; &#x2F;&#x2F;  ？有panic不处理，继续上抛\n      Ok(username)\n  &#125;\n&#125;\n&#x2F;&#x2F; 示例2\n&#x2F;&#x2F; 进一步简化，使用了链式调用\nuse std::fs::File;\nuse std::io::&#123;self, Read&#125;;\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;\n    let mut username &#x3D; String::new();\n\n    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;\n    &#x2F;&#x2F; 可以在 ? 之后直接使用链式方法调用来进一步缩短代码\n    &#x2F;&#x2F; 更符合工程学（ergonomic）的写法\n\n    Ok(username)\n&#125;\n</code></pre>\n\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 示例3\n#![allow(unused)]\nfn main() &#123; &#x2F;&#x2F; 所使用的所有 main 函数都返回 ()\n  use std::fs;\n  use std::io;\n\n  fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;\n      fs::read_to_string(&quot;hello.txt&quot;)\n      &#x2F;&#x2F; 这里的代码不会在中间过程中处理错误，上面的一些示例代码，及简化过程，只是为了介绍知识点\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 将文件读取到一个字符串是相当常见的操作，\n&#x2F;&#x2F; 所以 Rust 提供了名为 fs::read_to_string 的函数，它会打开文件、新建一个 String、读取文件的内容，并将内容放入 String，接着返回它。\n&#x2F;&#x2F; 当然，这样做就没有展示所有这些错误处理的机会了，所以我们最初就选择了艰苦的道路。\n</code></pre>\n\n<p><strong>? 运算符只能被用于返回值与 ? 作用的值相兼容的函数</strong></p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">use std::fs::File;\n&#x2F;&#x2F; 所使用的所有 main 函数都返回 ()\nfn main() &#123; &#x2F;&#x2F; 这里的mian函数指定了返回值是()， 所以下面的这行代码返回Result是不符合Rust规则\n    let greeting_file &#x3D; File::open(&quot;hello.txt&quot;)?;\n&#125;\n</code></pre>\n\n<h2 id=\"Option-x2F-Result\"><a href=\"#Option-x2F-Result\" class=\"headerlink\" title=\"Option&#x2F; Result\"></a>Option&#x2F; Result</h2><p>注意:</p>\n<ol>\n<li>你可以在返回 Result 的函数中对 Result 使用 ? 运算符，</li>\n<li>可以在返回 Option 的函数中对 Option 使用 ? 运算符，</li>\n<li>但是不可以混合搭配。? 运算符不会自动将 Result 转化为 Option，反之亦然；</li>\n<li>在这些情况下，可以使用类似 Result 的 ok 方法或者 Option 的 ok_or 方法来显式转换。</li>\n</ol>\n<h1 id=\"迭代器和闭包\"><a href=\"#迭代器和闭包\" class=\"headerlink\" title=\"迭代器和闭包\"></a>迭代器和闭包</h1><p><code>闭包（Closures）</code>，一个可以储存在变量里的类似函数的结构<br><code>迭代器（Iterators）</code>，一种处理元素序列的方式<br>如何使用闭包和迭代器来改进第十二章的 I&#x2F;O 项目。<br><code>闭包和迭代器的性能</code>。（剧透警告： 他们的速度超乎你的想象！）</p>\n<h1 id=\"match-语法\"><a href=\"#match-语法\" class=\"headerlink\" title=\"match 语法\"></a>match 语法</h1><p><code>match</code> 是 Rust 中的一种控制流程语句，通常与枚举类型或匹配模式一起使用，用于根据某个变量的不同取值执行不同的代码分支。</p>\n<p><code>match</code> 语法通常采用如下形式：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">match &lt;expression&gt; &#123;\n    &lt;pattern1&gt; &#x3D;&gt; &#123; &#x2F;* 执行代码块1 *&#x2F; &#125;,\n    &lt;pattern2&gt; &#x3D;&gt; &#123; &#x2F;* 执行代码块2 *&#x2F; &#125;,\n    &lt;pattern3&gt; &#x3D;&gt; &#123; &#x2F;* 执行代码块3 *&#x2F; &#125;,\n    &#x2F;&#x2F; ... 其他模式\n    _ &#x3D;&gt; &#123; &#x2F;* 默认执行代码块 *&#x2F; &#125;,\n&#125;</code></pre>\n\n<p>在上述语法中，</p>\n<p><code>&lt;expression&gt;</code> 是需要匹配的表达式，<br><code>&lt;pattern&gt;</code> 是一个模式匹配语句，用于匹配 <code>&lt;expression&gt;</code> 的值。<br>当匹配成功时，将执行对应的代码块，否则将执行默认的 <code>_</code> 代码块。</p>\n<p>为了更好地理解 <code>match</code> 的使用方法，下面给出一个例子：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">enum Coin &#123;\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n&#125;\n\nfn value_in_cents(coin: Coin) -&gt; u8 &#123;\n    match coin &#123;\n        Coin::Penny &#x3D;&gt; 1,\n        Coin::Nickel &#x3D;&gt; 5,\n        Coin::Dime &#x3D;&gt; 10,\n        Coin::Quarter &#x3D;&gt; 25,\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 测试函数：输出 Dime 的价值（10）\nfn main() &#123;\n    let my_coin &#x3D; Coin::Dime;\n    println!(&quot;The value of my coin is &#123;&#125; cents.&quot;, value_in_cents(my_coin));\n&#125;</code></pre>\n\n<p>在上述代码中，我们定义了一个 <code>Coin</code> 枚举类型，其中包含四种不同的硬币类型。接着，我们定义了一个函数 <code>value_in_cents</code>，用于根据给定的硬币类型计算其价值。在 <code>match</code> 语句中，我们从四种不同的硬币类型中进行选择，并返回对应的价值。最后，我们在 <code>main</code> 函数中测试了它的运行结果，成功输出了 <code>Dime</code> 的价值为 <code>10</code> 美分。</p>\n<p>需要注意的是，<code>match</code> 语句中的所有分支必须全是有返回值的，或者返回值为 <code>()</code>，否则会编译失败。同时，如果有多个分支的代码块逻辑较为复杂，可以将代码块写成函数调用的形式，在匹配成功后直接调用相应的函数来执行后续操作。</p>\n<h2 id=\"vs\"><a href=\"#vs\" class=\"headerlink\" title=\":: vs .\"></a>:: vs .</h2><h3 id=\"枚举可以用-吗\"><a href=\"#枚举可以用-吗\" class=\"headerlink\" title=\"枚举可以用.吗\"></a>枚举可以用.吗</h3><p>在 Rust 中，枚举的成员只能使用 <code>::</code> 运算符来访问。不能使用 <code>.</code> 运算符，因为 <code>.</code> 运算符在 Rust 中被用来访问具体类型的实例中的字段或方法，与枚举成员无关。</p>\n<p>例如，如果我们有一个结构体类型和一个函数实现该类型的方法：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">struct Person &#123;\n    name: String,\n    age: u8,\n&#125;\n\nimpl Person &#123;\n    fn say_hello(&amp;self) &#123;\n        println!(&quot;&#123;&#125; says hello!&quot;, self.name);\n    &#125;\n&#125;\n\nlet john &#x3D; Person &#123; name: String::from(&quot;John&quot;), age: 25 &#125;;\njohn.say_hello(); &#x2F;&#x2F; 调用 say_hello 方法</code></pre>\n\n<p>可以看到，在上面的例子中，我们使用 <code>.</code> 运算符来访问结构体中的字段和方法，但是枚举并没有类似的实例，因此不能使用 <code>.</code> 运算符来访问枚举成员。</p>\n<p>因此，Rust 使用 <code>::</code> 运算符来访问枚举成员，这也符合其它面向对象语言中枚举的访问方式。</p>\n<h3 id=\"rust-中什么时候用-什么时候用\"><a href=\"#rust-中什么时候用-什么时候用\" class=\"headerlink\" title=\"rust 中什么时候用:: 什么时候用.\"></a>rust 中什么时候用:: 什么时候用.</h3><p>在 Rust 中使用 <code>::</code> 与使用 <code>.</code> 的情况有所不同，它们有着不同的含义和用法。</p>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"::\"></a><code>::</code></h3><p>在 Rust 中，<code>::</code> <strong>表示命名空间限定符或静态方法调用操作符</strong>。具体用法如下：</p>\n<ul>\n<li><p>命名空间限定符：用于表示某些类型或模块的命名空间。例如在 <code>std::vec::Vec</code> 中，<code>std</code> 是模块，<code>vec</code> 是模块中的类型，而 <code>Vec</code> 则是类型中的具体成员。通过使用 <code>::</code>，我们可以方便地访问和引用各种类型、函数和变量。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">use std::io::Write;\n\nlet mut buf &#x3D; Vec::new();\nbuf.write_all(b&quot;Hello, world!&quot;).unwrap();</code></pre>\n\n<p>在上面的代码中，通过 <code>use</code> 关键字引入了 <code>std::io::Write</code> 模块，然后可以在后面直接使用 <code>write_all</code> 方法，而不需要写成 <code>std::io::Write::write_all</code> 或者 <code>use std::io::Write; buf.Write::write_all(b&quot;Hello, world!&quot;)</code> 的形式。</p>\n</li>\n<li><p>静态方法调用操作符：用于调用类型的静态方法。在 Rust 中，有一些类型拥有静态方法，这些方法可以在不创建实例的情况下直接调用。在调用这些方法时，需要使用 <code>::</code> 操作符。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let now &#x3D; std::time::Instant::now();\nstd::thread::sleep(std::time::Duration::from_secs(1));\nlet elapsed &#x3D; now.elapsed();\nprintln!(&quot;Elapsed: &#123;:?&#125;&quot;, elapsed);</code></pre>\n\n<p>在上面的代码中，使用 <code>std::time::Instant::now()</code> 方法获取当前时间，然后使用 <code>std::thread::sleep()</code> 方法休眠 1 秒钟，最后使用 <code>elapsed()</code> 方法计算时间差值并输出。</p>\n</li>\n</ul>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\".\"></a><code>.</code></h3><p>在 Rust 中，<code>.</code> <strong>主要用于成员访问运算符，用于访问结构体、trait 对象等类型中的成员</strong>。具体用法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct Person &#123;\n    name: String,\n    age: u32,\n&#125;\n\nlet p &#x3D; Person &#123;\n    name: &quot;Alice&quot;.to_string(),\n    age: 30,\n&#125;;\n\nprintln!(&quot;&#123;&#125; is &#123;&#125; years old&quot;, p.name, p.age);</code></pre>\n\n<p>在上面的例子中，使用 <code>.</code> 访问 <code>Person</code> 结构体中的 <code>name</code> 和 <code>age</code> 字段。</p>\n<h3 id=\"这里有个坑，是：访问的是枚举值的成员\"><a href=\"#这里有个坑，是：访问的是枚举值的成员\" class=\"headerlink\" title=\"这里有个坑，是：访问的是枚举值的成员\"></a>这里有个坑，是：访问的是枚举值的成员</h3><p>对于枚举，也可以使用 <code>.</code> 访问其成员：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">enum Coin &#123;\n    Penny,\n    Nickel,\n    Dime,\n    Quarter &#123; state: String &#125;,\n&#125;\n\nlet coin &#x3D; Coin::Quarter &#123; state: &quot;New York&quot;.to_string() &#125;;\nmatch coin &#123;\n    Coin::Quarter &#123; state &#125; &#x3D;&gt; println!(&quot;State quarter from &#123;&#125;&quot;, state),\n    _ &#x3D;&gt; (),\n&#125;</code></pre>\n\n<p>在上面的例子中，使用 <code>.</code> 访问 <code>Coin</code> 枚举类型中的 <code>Quarter</code> 变体中的 <code>state</code> 字段。</p>\n<p>对于 trait 对象，也可以使用 <code>.</code> 访问其方法：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">trait Animal &#123;\n    fn name(&amp;self) -&gt; &amp;&#39;static str;\n    fn talk(&amp;self) &#123;\n        println!(&quot;&#123;&#125; cannot talk&quot;, self.name());\n    &#125;\n&#125;\n\nstruct Cat &#123;\n    name: &amp;&#39;static str,\n&#125;\n\nimpl Animal for Cat &#123;\n    fn name(&amp;self) -&gt; &amp;&#39;static str &#123;\n        self.name\n    &#125;\n    fn talk(&amp;self) &#123;\n        println!(&quot;&#123;&#125; meows&quot;, self.name());\n    &#125;\n&#125;\n\nlet animal: Box&lt;dyn Animal&gt; &#x3D; Box::new(Cat &#123; name: &quot;Whiskers&quot; &#125;);\nanimal.talk();</code></pre>\n\n<p>在上面的例子中，定义了一个 <code>Animal</code> trait，其中包含 <code>name()</code> 和 <code>talk()</code> 两个方法。然后定义了一个 <code>Cat</code> 类型，实现了 <code>Animal</code> trait，覆盖了 <code>talk()</code> 方法。最后使用 <code>Box&lt;dyn Animal&gt;</code> 定义了一个 trait 对象，可以使用 <code>.</code> 访问其中的方法。</p>\n<h1 id=\"模式与模式匹配-不可反驳模式与可反驳模式的区别\"><a href=\"#模式与模式匹配-不可反驳模式与可反驳模式的区别\" class=\"headerlink\" title=\"模式与模式匹配 不可反驳模式与可反驳模式的区别\"></a>模式与模式匹配 不可反驳模式与可反驳模式的区别</h1><p>在 Rust 中，模式是一个用于解构和匹配数据结构的语法。模式匹配是一种控制流语句，它允许您根据值的类型和结构来执行不同的操作。Rust 中有两种模式：可反驳（refutable）模式和不可反驳（irrefutable）模式。</p>\n<p>不可反驳模式是一种至少有一个解决方案的模式。编译器可以保证在程序运行时模式匹配始终成功。这意味着当使用不可反驳模式进行匹配时，编译器不会因为无法确定哪个匹配模式合适而引发编译时错误。</p>\n<p>以下是不可反驳模式的示例：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let x &#x3D; 1;\nlet (a, b) &#x3D; (2, 3);  &#x2F;&#x2F; 右侧的模式构成了不可反驳模式，因为它始终有效</code></pre>\n\n<p>可反驳模式是一种可能没有解决方案的模式。编译器不能保证在程序运行时模式匹配始终成功。因此，在使用可反驳模式进行匹配时，您必须考虑到无法确定哪个匹配模式适合所述的情况，并处理未匹配到的情况以确保程序不会引发运行时错误。</p>\n<p>以下是可反驳模式的示例：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let x: Option&lt;i32&gt; &#x3D; Some(5);\nif let Some(y) &#x3D; x &#123;  &#x2F;&#x2F; 这是一个可反驳模式，因为 x 可能是 None\n    println!(&quot;&#123;&#125;&quot;, y);\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>x</code> 是一个 <code>Option&lt;i32&gt;</code> 类型的值，该类型可以是 <code>Some</code> 或 <code>None</code>。使用 <code>if let</code> 语法对 <code>x</code> 进行模式匹配。<code>if let</code> 语句的模式是可反驳的，因为 <code>x</code> 可能是 <code>None</code>。如果 <code>x</code> 是 <code>Some</code>，则将其解构并将值绑定到变量 <code>y</code> 中，并打印 <code>y</code> 的值。</p>\n<h3 id=\"rust-模式语法的应用场景有哪些？\"><a href=\"#rust-模式语法的应用场景有哪些？\" class=\"headerlink\" title=\"rust 模式语法的应用场景有哪些？\"></a>rust 模式语法的应用场景有哪些？</h3><p>Rust 中的模式语法是一种广泛使用的语法，可以在许多场景中使用。以下是 Rust 模式语法的几个应用场景：</p>\n<ol>\n<li>匹配语句块中的变量</li>\n</ol>\n<p>可以使用模式语法匹配并解构变量。例如，在使用 <code>let</code> 绑定变量时，可以使用包含模式语法的赋值语句来匹配值。</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let x &#x3D; 1;\nlet (a, b) &#x3D; (2, 3);\nlet Some(y) &#x3D; Some(5);</code></pre>\n\n<ol start=\"2\">\n<li>匹配枚举类型</li>\n</ol>\n<p>枚举类型经常与模式语法一起使用。可以使用枚举变量对每种可能的变量状态进行匹配。</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">enum Message &#123;\n    Quit,\n    Move &#123; x: i32, y: i32 &#125;,\n    Write(String),\n    ChangeColor(i32, i32, i32),\n&#125;\n\nfn process_message(msg: Message) &#123;\n    match msg &#123;\n        Message::Quit &#x3D;&gt; println!(&quot;Quit&quot;),\n        Message::Move &#123; x, y &#125; &#x3D;&gt; println!(&quot;Move to (&#123;&#125;, &#123;&#125;)&quot;, x, y),\n        Message::Write(text) &#x3D;&gt; println!(&quot;Write: &#123;&#125;&quot;, text),\n        Message::ChangeColor(r, g, b) &#x3D;&gt; println!(&quot;Change color to RGB (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;, r, g, b),\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>匹配结构体</li>\n</ol>\n<p>使用模式语法，可以对结构体的字段进行匹配。</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">struct Point &#123;\n    x: i32,\n    y: i32,\n&#125;\n\nlet p &#x3D; Point &#123; x: 0, y: 7 &#125;;\nlet Point &#123; x, y &#125; &#x3D; p;</code></pre>\n\n<ol start=\"4\">\n<li>匹配数组和向量</li>\n</ol>\n<p>使用模式语法可以解构数组和向量。</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let a &#x3D; [1, 2, 3];\nlet [x, y, z] &#x3D; a;\n\nlet v &#x3D; vec![1, 2, 3];\nlet [x, y, z] &#x3D; v[..];</code></pre>\n\n<ol start=\"5\">\n<li>匹配函数参数</li>\n</ol>\n<p>在定义函数时，可以使用模式语法使函数参数更简单，加强代码的可读性。</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) &#123;\n    println!(&quot;Current location: (&#123;&#125;, &#123;&#125;)&quot;, x, y);\n&#125;</code></pre>\n\n<p>总的来说，Rust 的模式语法是一种强大的工具，可以在许多场景中使用，并使代码更加简洁，易于理解和维护。</p>\n<h2 id=\"用到模式匹配的位置\"><a href=\"#用到模式匹配的位置\" class=\"headerlink\" title=\"用到模式匹配的位置\"></a>用到模式匹配的位置</h2><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html#所有可能会用到模式的位置 target=\"_blank\" >所有可能会用到模式的位置</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html#match-分支 target=\"_blank\" >match 分支</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html#if-let-条件表达式 target=\"_blank\" >if let 条件表达式</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html#while-let-条件循环 target=\"_blank\" >while let 条件循环</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html#for-循环 target=\"_blank\" >for 循环</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html#let-语句 target=\"_blank\" >let 语句</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-01-all-the-places-for-patterns.html#函数参数 target=\"_blank\" >函数参数</a></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"示例-chatgpt\"><a href=\"#示例-chatgpt\" class=\"headerlink\" title=\"示例 chatgpt\"></a>示例 chatgpt</h3><p>模式在以下位置可能会被用到：</p>\n<ol>\n<li>match 分支</li>\n</ol>\n<p>在 <code>match</code> 表达式中，每个分支都可以使用模式来匹配不同的值。例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">match num &#123;\n    0 &#x3D;&gt; println!(&quot;zero&quot;),\n    1 &#x3D;&gt; println!(&quot;one&quot;),\n    2 &#x3D;&gt; println!(&quot;two&quot;),\n    _ &#x3D;&gt; println!(&quot;many&quot;), &#x2F;&#x2F; 使用通配符 &#39;_&#39; 匹配所有其他值\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>if let 条件表达式</li>\n</ol>\n<p><code>if let</code> 表达式可以将一个可选的值与一个模式进行匹配，来判断是否存在并且与匹配模式相同，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let some_number &#x3D; Some(7);\nif let Some(num) &#x3D; some_number &#123;\n    println!(&quot;Matched: &#123;&#125;&quot;, num);\n&#125; else &#123;\n    println!(&quot;Didn&#39;t match a number&quot;);\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>while let 条件循环</li>\n</ol>\n<p>与 <code>if let</code> 类似，<code>while let</code> 条件循环也可以将一个可选的值与一个模式进行匹配，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let mut v &#x3D; vec![1, 3, 5, 7, 11];\nwhile let Some(i) &#x3D; v.pop() &#123;\n    println!(&quot;&#123;&#125;&quot;, i);\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>for 循环</li>\n</ol>\n<p>在 <code>for</code> 循环中，使用模式可以获取集合中的每个元素，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let v &#x3D; vec![1, 3, 5, 7, 11];\nfor i in v &#123;\n    println!(&quot;&#123;&#125;&quot;, i);\n&#125;\n\n&#x2F;&#x2F; 可以使用元组分解来获取元素中的多个值\nlet v &#x3D; vec![(1, &quot;one&quot;), (2, &quot;two&quot;), (3, &quot;three&quot;)];\nfor (num, name) in v &#123;\n    println!(&quot;&#123;&#125; is &#123;&#125;&quot;, num, name);\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>let 语句</li>\n</ol>\n<p>使用 <code>let</code> 语句可以将一个值绑定到一个变量上，并且可以使用模式来匹配值的结构，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let (x, y) &#x3D; (1, 2);\nprintln!(&quot;x &#x3D; &#123;&#125;, y &#x3D; &#123;&#125;&quot;, x, y);\n\n&#x2F;&#x2F; 也可以使用模式来展开元组\nlet tup &#x3D; (3, 4, 5);\nlet (a, _, b) &#x3D; tup;\nprintln!(&quot;a &#x3D; &#123;&#125;, b &#x3D; &#123;&#125;&quot;, a, b);</code></pre>\n\n<ol start=\"6\">\n<li>函数参数</li>\n</ol>\n<p>在函数定义中，可以使用模式来指定参数的类型和结构，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">fn print_point((x, y): (i32, i32)) &#123;\n    println!(&quot;(&#123;&#125;, &#123;&#125;)&quot;, x, y);\n&#125;\nlet point &#x3D; (3, 7);\nprint_point(point);</code></pre>\n\n<p>以上是 Rust 中可以使用模式的位置，使用模式可以让代码更加清晰和简洁。</p>\n<h2 id=\"Refutability（可反驳性）-模式是否会匹配失效\"><a href=\"#Refutability（可反驳性）-模式是否会匹配失效\" class=\"headerlink\" title=\"Refutability（可反驳性）: 模式是否会匹配失效\"></a>Refutability（可反驳性）: 模式是否会匹配失效</h2><p>模式有两种形式：<code>refutable（可反驳的）</code>和<code> irrefutable（不可反驳的）</code>。</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">&#x2F;&#x2F; 能匹配任何传递的可能值的模式被称为是 **不可反驳的（irrefutable）**。\n\nlet x &#x3D; 5; &#x2F;&#x2F; 语句中的 x，因为 x 可以匹配任何值所以不可能会失败。\n&#x2F;&#x2F; 对某些可能的值进行匹配会失败的模式被称为是 **可反驳的（refutable）**。\n\n if let Some(x) &#x3D; a_value &#x2F;&#x2F; 表达式中的 Some(x)；\n&#x2F;&#x2F; 如果变量 a_value 中的值是 None 而不是 Some，那么 Some(x) 模式不能匹配。</code></pre>\n\n<h2 id=\"模式匹配语法-（官方文档）\"><a href=\"#模式匹配语法-（官方文档）\" class=\"headerlink\" title=\"模式匹配语法 （官方文档）\"></a>模式匹配语法 （官方文档）</h2><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#所有的模式语法 target=\"_blank\" >所有的模式语法</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#匹配字面值 target=\"_blank\" >匹配字面值</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#匹配命名变量 target=\"_blank\" >匹配命名变量</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#多个模式 target=\"_blank\" >多个模式</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#通过--匹配值的范围 target=\"_blank\" >通过 ..&#x3D; 匹配值的范围</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#解构并分解值 target=\"_blank\" >解构并分解值</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#解构结构体 target=\"_blank\" >解构结构体</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#解构枚举 target=\"_blank\" >解构枚举</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#解构嵌套的结构体和枚举 target=\"_blank\" >解构嵌套的结构体和枚举</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#解构结构体和元组 target=\"_blank\" >解构结构体和元组</a></li>\n</ol>\n</li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#忽略模式中的值 target=\"_blank\" >忽略模式中的值</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#使用-_-忽略整个值 target=\"_blank\" >使用 _ 忽略整个值</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#使用嵌套的-_-忽略部分值 target=\"_blank\" >使用嵌套的 _ 忽略部分值</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#通过在名字前以一个-_-开头来忽略未使用的变量 target=\"_blank\" >通过在名字前以一个 _ 开头来忽略未使用的变量</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#用--忽略剩余值 target=\"_blank\" >用 .. 忽略剩余值</a></li>\n</ol>\n</li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#匹配守卫提供的额外条件 target=\"_blank\" >匹配守卫提供的额外条件</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#-绑定 target=\"_blank\" >@ 绑定</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#总结 target=\"_blank\" >总结</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>Rust 中的模式可用于各种情况中，以下是 Rust 中所有可用的模式语法：</p>\n<ol>\n<li><strong>匹配字面值</strong></li>\n</ol>\n<p>可以使用字面值来匹配常量或字面量，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let item &#x3D; &quot;apple&quot;;\nmatch item &#123;\n    &quot;apple&quot; &#x3D;&gt; println!(&quot;It&#39;s an apple&quot;),\n    &quot;banana&quot; &#x3D;&gt; println!(&quot;It&#39;s a banana&quot;),\n    _ &#x3D;&gt; println!(&quot;I don&#39;t know what it is&quot;),\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li><strong>匹配命名变量</strong></li>\n</ol>\n<p>可以使用命名变量来绑定和匹配特定的值，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let x &#x3D; Some(5);\nmatch x &#123;\n    Some(val) &#x3D;&gt; println!(&quot;Value is &#123;&#125;&quot;, val),\n    None &#x3D;&gt; println!(&quot;It&#39;s None&quot;)\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li><strong>多个模式</strong></li>\n</ol>\n<p>可以将多个模式组合在一起来匹配多种情况，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let value &#x3D; 5;\nmatch value &#123;\n    1 | 2 &#x3D;&gt; println!(&quot;One or two&quot;),\n    3..&#x3D;5 &#x3D;&gt; println!(&quot;Three to five&quot;),\n    _ &#x3D;&gt; println!(&quot;Something else&quot;),\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li><strong>通过 <code>..=</code> 匹配值的范围</strong></li>\n</ol>\n<p>可以通过使用 <code>..=</code> 来指定一个值的范围，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let value &#x3D; 50;\nmatch value &#123;\n    1..&#x3D;50 &#x3D;&gt; println!(&quot;Between 1 and 50&quot;),\n    _ &#x3D;&gt; println!(&quot;Something else&quot;),\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li><strong>解构并分解值</strong></li>\n</ol>\n<p>可以将一个值分解为多个组成部分，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let tup &#x3D; (3, &quot;hello&quot;, true);\nlet (x, y, z) &#x3D; tup;</code></pre>\n\n<ol start=\"6\">\n<li><strong>解构结构体</strong></li>\n</ol>\n<p>可以通过模式获取结构体中的字段值，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">struct Point &#123;\n    x: i32,\n    y: i32,\n&#125;\nlet point &#x3D; Point &#123; x: 3, y: 7 &#125;;\nmatch point &#123;\n    Point &#123; x, y &#125; &#x3D;&gt; println!(&quot;(&#123;&#125;, &#123;&#125;)&quot;, x, y),\n&#125;</code></pre>\n\n<ol start=\"7\">\n<li><strong>解构枚举</strong></li>\n</ol>\n<p>枚举类型可以有不同的成员，每个成员可以有不同的属性。在 match 表达式中使用模式匹配不同的成员时，可以对不同的成员进行解构。例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">enum Message &#123;\n    Quit,\n    Move &#123; x: i32, y: i32 &#125;,\n    Write(String),\n    ChangeColor(i32, i32, i32),\n&#125;\n\nlet msg &#x3D; Message::Move &#123; x: 3, y: 7 &#125;;\nmatch msg &#123;\n    Message::Quit &#x3D;&gt; println!(&quot;Quit&quot;),\n    Message::Move &#123; x, y &#125; &#x3D;&gt; println!(&quot;Move to (&#123;&#125;, &#123;&#125;)&quot;, x, y),\n    Message::Write(text) &#x3D;&gt; println!(&quot;Write: &#123;&#125;&quot;, text),\n    Message::ChangeColor(r, g, b) &#x3D;&gt; println!(&quot;Color: (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;, r, g, b),\n&#125;</code></pre>\n\n<ol start=\"8\">\n<li><strong>解构嵌套的结构体和枚举</strong></li>\n</ol>\n<p>可以使用模式分解嵌套的结构体和枚举。例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">struct Point3d &#123;\n    x: i32,\n    y: i32,\n    z: i32,\n&#125;\nenum Color &#123;\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n&#125;\n\nlet point &#x3D; Point3d &#123; x: 3, y: 7, z: -2 &#125;;\nlet message &#x3D; Message::ChangeColor(255, 0, 0);\nlet color &#x3D; Color::Rgb(255, 255, 0);\nmatch (point, message, color) &#123;\n    (Point3d &#123; x, .. &#125;, Message::ChangeColor(r, g, b), Color::Rgb(r1, g1, b1)) &#x3D;&gt; &#123;\n        println!(&quot;x is &#123;&#125;, r is &#123;&#125;, g is &#123;&#125;, b is &#123;&#125;, r1 is &#123;&#125;, g1 is &#123;&#125;, b1 is &#123;&#125;&quot;, x, r, g, b, r1, g1, b1)\n    &#125;,\n    _ &#x3D;&gt; (),\n&#125;</code></pre>\n\n<ol start=\"9\">\n<li><strong>解构结构体和元组</strong></li>\n</ol>\n<p>可以使用解构结构体和元组混合使用的模式。例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let ((feet, inches), Point &#123; x, y &#125;) &#x3D; ((3, 10), Point &#123; x: 3, y: -10 &#125;);\nprintln!(&quot;Feet &#123;&#125; Inches &#123;&#125; X &#123;&#125; Y &#123;&#125;&quot;, feet, inches, x, y);</code></pre>\n\n<ol start=\"10\">\n<li><strong>忽略模式中的值</strong></li>\n</ol>\n<p>可以使用 <code>_</code> 来匹配或忽略值，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let value &#x3D; Some(5);\nmatch value &#123;\n    Some(_) &#x3D;&gt; println!(&quot;It&#39;s something&quot;),\n    None &#x3D;&gt; println!(&quot;It&#39;s None&quot;),\n&#125;</code></pre>\n\n<ol start=\"11\">\n<li><strong>使用 <code>_</code> 忽略整个值</strong></li>\n</ol>\n<p>可以使用 <code>_</code> 来忽略整个值，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let value: Option&lt;i32&gt; &#x3D; None;\nmatch value &#123;\n    Some(_) &#x3D;&gt; println!(&quot;It&#39;s something&quot;),\n    None &#x3D;&gt; println!(&quot;It&#39;s None&quot;),\n&#125;</code></pre>\n\n<ol start=\"12\">\n<li><strong>使用嵌套的 <code>_</code> 忽略部分值</strong></li>\n</ol>\n<p>可以使用嵌套的 <code>_</code> 来忽略部分值，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let tup &#x3D; (3, 7, 0);\nmatch tup &#123;\n    (x, _, _) &#x3D;&gt; println!(&quot;The value of x is &#123;&#125;&quot;, x),\n&#125;</code></pre>\n\n<ol start=\"13\">\n<li><strong>通过在名字前以一个 <code>_</code> 开头来忽略未使用的变量</strong></li>\n</ol>\n<p>可以使用 <code>_</code> 来忽略未使用的变量，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let x &#x3D; 5;\nlet _y &#x3D; 10; &#x2F;&#x2F; 这个值不会被使用\nprintln!(&quot;The value of x is &#123;&#125;&quot;, x);</code></pre>\n\n<ol start=\"14\">\n<li><strong>用 <code>..</code> 忽略剩余值</strong></li>\n</ol>\n<p>可以使用 <code>..</code> 来忽略剩余的值，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let tuple &#x3D; (0, 1, 2, 3);\nmatch tuple &#123;\n    (0, .., 3) &#x3D;&gt; println!(&quot;0 and 3 are at the ends&quot;),\n    _ &#x3D;&gt; println!(&quot;Something else&quot;),\n&#125;</code></pre>\n\n<ol start=\"15\">\n<li><strong>匹配守卫提供的额外条件</strong></li>\n</ol>\n<p>可以使用 <code>if</code> 关键字来提供额外的匹配条件，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let value &#x3D; 12;\nmatch value &#123;\n    x if x &lt; 10 &#x3D;&gt; println!(&quot;Less than 10&quot;),\n    x if x &gt; 10 &#x3D;&gt; println!(&quot;Greater than 10&quot;),\n    _ &#x3D;&gt; println!(&quot;It&#39;s 10&quot;),\n&#125;</code></pre>\n\n<ol start=\"16\">\n<li><strong><code>@</code> 绑定</strong></li>\n</ol>\n<p>可以使用 <code>@</code> 即可匹配到模式的值，同时将其绑定到一个变量上，例如：</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">let x &#x3D; 5;\nmatch x &#123;\n    1..&#x3D;10 &#x3D;&gt; println!(&quot;It&#39;s between 1 and 10&quot;),\n    val @ 11..&#x3D;20 &#x3D;&gt; println!(&quot;It&#39;s between 11 and 20, value is &#123;&#125;&quot;, val),\n    _ &#x3D;&gt; println!(&quot;It&#39;s something else&quot;),\n&#125;</code></pre>\n\n<p>以上是 Rust 中所有可用的模式语法，您可以通过多种方式使用这些模式，从而使您的代码更具有表现力和可读性。</p>\n<h2 id=\"模式匹配用到了-23-种设计模式的哪种？【确认下】\"><a href=\"#模式匹配用到了-23-种设计模式的哪种？【确认下】\" class=\"headerlink\" title=\"模式匹配用到了 23 种设计模式的哪种？【确认下】\"></a>模式匹配用到了 23 种设计模式的哪种？【确认下】</h2><p>Rust 的模式匹配虽然与 23 种经典设计模式没有直接的联系，但它也体现了一些面向对象中常见的设计原则，例如：</p>\n<ol>\n<li>单一职责原则：模式匹配通过自己的方式处理特定类型的值，保持简单、明确和专一。</li>\n<li>开闭原则：通过模式匹配，您可以轻松地添加新的模式或更改现有模式，而无需影响其他部分的代码。</li>\n<li>里氏替换原则：对于给定的类型，您可以编写多种模式，这些模式可以在需要前进行替换，而不会影响其他部分的代码。</li>\n<li>依赖倒置原则：模式匹配使用抽象类型和 trait 来执行功能，这使得代码易于测试和维护。</li>\n<li>接口隔离原则：模式匹配的 trait 非常小巧并专注于单一的任务，沿用了这一原则将接口隔离成小的、易于管理的部分。</li>\n</ol>\n<p>虽然模式匹配与 23 种经典设计模式并不直接相关，但是它在很多场景下可以替代经典的 if&#x2F;else、switch&#x2F;case 等类型判断语句，并且更有表现力、易于扩展和维护。</p>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-01-threads.html#使用线程同时运行代码 target=\"_blank\" >使用线程同时运行代码</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-01-threads.html#使用-spawn-创建新线程 target=\"_blank\" >使用 spawn 创建新线程</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-01-threads.html#使用-join-等待所有线程结束 target=\"_blank\" >使用 join 等待所有线程结束</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-01-threads.html#线程与-move-闭包 target=\"_blank\" >线程与 move 闭包</a></li>\n</ol>\n<h2 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h2><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-02-message-passing.html#使用消息传递在线程间传送数据 target=\"_blank\" >使用消息传递在线程间传送数据</a><ol>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-02-message-passing.html#信道与所有权转移 target=\"_blank\" >信道与所有权转移</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-02-message-passing.html#发送多个值并观察接收者的等待 target=\"_blank\" >发送多个值并观察接收者的等待</a></li>\n<li><a href=https://kaisery.github.io/trpl-zh-cn/ch16-02-message-passing.html#通过克隆发送者来创建多个生产者 target=\"_blank\" >通过克隆发送者来创建多个生产者</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"线程共享数据\"><a href=\"#线程共享数据\" class=\"headerlink\" title=\"线程共享数据\"></a>线程共享数据</h2><h2 id=\"std-sync-Mutex-与-std-sync-mpsc-区别\"><a href=\"#std-sync-Mutex-与-std-sync-mpsc-区别\" class=\"headerlink\" title=\"std::sync::Mutex 与 std::sync::mpsc 区别\"></a>std::sync::Mutex 与 std::sync::mpsc 区别</h2><p><code>std::sync::Mutex</code> 和 <code>std::sync::mpsc</code> 都是 Rust 标准库中用于线程间通讯的机制，但是它们的使用场景和实现机制存在一些不同。</p>\n<p><code>std::sync::Mutex</code> 是一种基于互斥锁的同步机制，它允许多个线程互斥地访问共享的状态。在 Rust 中，可以使用 <code>Mutex</code> 来保护共享变量，以避免竞态条件。使用 <code>Mutex</code> 时需要注意的是，对于需要长时间占用锁的操作应该采取合适的并发方案，避免长时间的阻塞和性能瓶颈。</p>\n<p><code>std::sync::mpsc</code> 是一种线程间消息传递的机制，它允许一个线程向另一个线程发送消息，并保证线程安全。在 Rust 中，可以使用 <code>mpsc::channel</code> 函数创建一个通道，用于在线程之间传递消息。通道由两个端点组成，分别是发送者和接收者。发送者通过通道向接收者发送消息，并阻塞等待接收者进行处理。使用 <code>mpsc</code> 时需要注意的是，如果通道满了，发送者可能会阻塞，直到有足够的空间放置新消息。</p>\n<p>总体来说，<code>std::sync::Mutex</code> 和 <code>std::sync::mpsc</code> 都是 Rust 中非常有用的线程同步机制，但是它们的使用场景存在一定的不同。如果需要多个线程对共享变量进行操作，应该使用 <code>Mutex</code>。如果需要在线程之间传递消息，则可以使用 <code>mpsc</code>。</p>\n<h1 id=\"Rust-官网爬取脚本\"><a href=\"#Rust-官网爬取脚本\" class=\"headerlink\" title=\"Rust 官网爬取脚本\"></a>Rust 官网爬取脚本</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 爬取脚本\n\nvar url &#x3D; location.href;\nvar headings &#x3D; document.getElementsByTagName(&#39;main&#39;)[0].querySelectorAll(&#39;h2, h3, h4&#39;);\nvar alist &#x3D; &#39;&#39;;\nheadings.forEach((heading) &#x3D;&gt; &#123;\n  const level &#x3D; parseInt(heading.tagName.substr(1));\n  const text &#x3D; heading.textContent;\n  const anchor &#x3D; heading.querySelector(&#39;a&#39;);\n  if (anchor) &#123;\n    const href &#x3D; anchor.getAttribute(&#39;href&#39;);\n    &#x2F;&#x2F;  console.log(&#96;$&#123;&#39;#&#39;.repeat(level)&#125; [$&#123;text&#125;]($&#123;href&#125;)&#96;);\n    alist +&#x3D; &#96;$&#123;&#39; &#39;.repeat(level)&#125; 1. &lt;a href&#x3D;$&#123;url + href&#125; target&#x3D;&quot;_blank&quot; &gt;$&#123;text&#125;&lt;&#x2F;a&gt;\\n&#96;;\n  &#125; else &#123;\n    console.log(&#96;$&#123;&#39; &#39;.repeat(level)&#125; 1. $&#123;text&#125;&#96;);\n  &#125;\n&#125;);\n\ncopy(alist);</code></pre>\n","text":"Rustaceans 是啥Rustaceans 是 Rust 社区的成员，包括 Rust 的开发者、用户、贡献者、爱好者等。这个词来源于 Rust 的 Logo 中的小螃蟹（Crab），因此称 Rust 的使用者为 Rustaceans。 Rust 社区非常活跃，拥有众多的 Ru...","link":"","photos":[],"count_time":{"symbolsCount":"64k","symbolsTime":"58 mins."},"categories":[{"name":"Rust","slug":"Rust","count":1,"path":"api/categories/Rust.json"}],"tags":[{"name":"Rust","slug":"Rust","count":1,"path":"api/tags/Rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Rustaceans-%E6%98%AF%E5%95%A5\"><span class=\"toc-text\">Rustaceans 是啥</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#golang-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E5%BF%AB%EF%BC%9F\"><span class=\"toc-text\">golang 为什么比其他语言快？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rust-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94-golang-%E8%BF%98%E5%BF%AB\"><span class=\"toc-text\">rust 为什么比 golang 还快</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E6%88%90%E6%9C%AC%E6%8A%BD%E8%B1%A1-%E6%98%AF%E5%95%A5\"><span class=\"toc-text\">零成本抽象 是啥</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rust-%E4%B8%8A%E6%89%8B%E9%9A%BE%E5%BA%A6%E8%BF%9C%E5%A4%A7%E4%BA%8E-golang\"><span class=\"toc-text\">rust 上手难度远大于 golang</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rust-%E5%92%8C-go-%E5%90%84%E8%87%AA%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">rust 和 go 各自适用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Rust-%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">Rust 的适用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Go-%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">Go 的适用场景</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rust-web-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">rust web 开发框架</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#orm\"><span class=\"toc-text\">orm</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#rust-%E5%92%8C-go-%E5%93%AA%E4%B8%AA%E5%B9%B6%E5%8F%91%E6%9B%B4%E5%BC%BA\"><span class=\"toc-text\">rust 和 go 哪个并发更强</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88\"><span class=\"toc-text\">Rust 程序设计语言 简体中文版</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Rust-%E5%AE%89%E8%A3%85%E5%AE%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%9C%80%E8%A6%81%E9%87%8D%E5%90%AF\"><span class=\"toc-text\">Rust 安装完命令行需要重启</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vscode-%E6%B2%A1%E6%9C%89%E8%AF%AD%E6%B3%95%E6%8F%90%E7%A4%BA\"><span class=\"toc-text\">vscode 没有语法提示</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rust-analyzer-%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99\"><span class=\"toc-text\">rust_analyzer 插件报错</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rust-%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96\"><span class=\"toc-text\">rust 代码自动格式化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cargo-new-variables\"><span class=\"toc-text\">cargo new variables</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">变量声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88%E9%9A%90%E8%97%8F%EF%BC%89\"><span class=\"toc-text\">作用域（隐藏）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E8%97%8F%E4%B8%8E%E5%B0%86%E5%8F%98%E9%87%8F%E6%A0%87%E8%AE%B0%E4%B8%BA-mut-%E6%98%AF%E6%9C%89%E5%8C%BA%E5%88%AB%E7%9A%84\"><span class=\"toc-text\">隐藏与将变量标记为 mut 是有区别的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">表达式与语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">函数返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E6%B5%81\"><span class=\"toc-text\">控制流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#if-else\"><span class=\"toc-text\">if else</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF-loop%E3%80%81while-%E5%92%8C-for\"><span class=\"toc-text\">循环 loop、while 和 for</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E6%9D%83\"><span class=\"toc-text\">所有权</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">所有权与变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">所有权与函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%EF%BC%88references%EF%BC%89\"><span class=\"toc-text\">引用（references）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%80%9F%E7%94%A8\"><span class=\"toc-text\">借用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">可变引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%EF%BC%88data-race%EF%BC%89%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E7%94%B1%E8%BF%99%E4%B8%89%E4%B8%AA%E8%A1%8C%E4%B8%BA%E9%80%A0%E6%88%90%EF%BC%9A\"><span class=\"toc-text\">数据竞争（data race）类似于竞态条件，它可由这三个行为造成：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">悬垂引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9A\"><span class=\"toc-text\">引用的规则：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#slice-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">slice 解决了什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Rust-%E4%B8%BA%E4%BA%86%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%8C%E7%89%BA%E7%89%B2%E4%BA%86%E4%BB%A3%E7%A0%81%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">Rust 为了提高性能，牺牲了代码的灵活性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB-chatgpt\"><span class=\"toc-text\">引用与借用的区别 [chatgpt]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83-%EF%BC%88chatgpt%EF%BC%89\"><span class=\"toc-text\">什么是所有权 （chatgpt）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-%E6%82%AC%E5%9E%82%E6%8C%87%E9%92%88%EF%BC%88chatgpt%EF%BC%89\"><span class=\"toc-text\">什么是 悬垂指针（chatgpt）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">新建字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">更新字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">索引字符串</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%9A\"><span class=\"toc-text\">引用模块项目的路径：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-pub-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9A%B4%E9%9C%B2%E8%B7%AF%E5%BE%84%EF%BC%9A\"><span class=\"toc-text\">使用 pub 关键字暴露路径：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE%EF%BC%9A\"><span class=\"toc-text\">创建公有的结构体和枚举：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#use-%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E8%B7%AF%E5%BE%84%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">use 关键字将路径引入作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E3%80%81Crate%E3%80%81%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%88chatgpt%EF%BC%89\"><span class=\"toc-text\">包、Crate、模块的区别 （chatgpt）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mod-%E4%B8%8E-java-package-%E5%85%B3%E9%94%AE%E5%AD%97-%E7%9C%8B%E4%B8%8A%E5%8E%BB%E5%92%8C%E7%9B%B8%E4%BC%BC%EF%BC%88chatgpt%EF%BC%89\"><span class=\"toc-text\">mod 与 java package 关键字 看上去和相似（chatgpt）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E6%9D%83-%EF%BC%88rust-%E6%A0%B8%E5%BF%83%EF%BC%89chatgpt\"><span class=\"toc-text\">所有权 （rust 核心）chatgpt</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD-owner-%E7%9A%84%E6%A6%82%E5%BF%B5%E5%90%97%EF%BC%9Fchatgpt\"><span class=\"toc-text\">可以理解为项目开发中 owner 的概念吗？chatgpt</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E4%B8%AD%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">rust 中所有权解决了什么问题？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB%EF%BC%9F\"><span class=\"toc-text\">rust 为什么会有所有权转移？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E4%B8%AD%E6%89%80%E6%9C%89%E6%9D%83%E5%94%AF%E4%B8%80%EF%BC%9F\"><span class=\"toc-text\">rust 中所有权唯一？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%8B%E5%89%8D%E7%9A%84-ower-%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%90%8E%E4%B8%80%E4%B8%AA-ower-%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E6%8E%89%EF%BC%9F\"><span class=\"toc-text\">之前的 ower 在移动到后一个 ower 后，会被回收掉？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A0%E6%95%88%E4%B8%8D%E6%98%AF%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">无效不是悬垂引用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%9F%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%89\"><span class=\"toc-text\">借用和引用（可以理解为一个东西）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8\"><span class=\"toc-text\">rust 如何区分引用和借用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF\"><span class=\"toc-text\">rust 引用和借用是同一个东西</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E3%80%81%E5%80%9F%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">引用、借用、移动的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%98%E6%98%AF%E4%B8%8D%E6%B8%85%E6%A5%9A%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">还是不清楚引用和借用有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E4%B8%8E%E8%A7%A3%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">引用与解引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%AF%A5%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%EF%BC%8C%E5%B0%B1%E4%B8%8D%E8%83%BD%E5%86%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%AF%A5%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%81%87%E8%AE%BE%E5%8F%88%E5%88%9B%E5%BB%BA%E4%BA%86%E5%BC%95%E7%94%A8%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">有一个对该变量的可变引用，就不能再创建对该变量的引用, 为什么要这么设计，假设又创建了引用会出现什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E5%B0%86%E5%85%B6%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA-js-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C-dom%EF%BC%8C%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E4%B8%8D%E5%85%81%E8%AE%B8%E5%A4%9A%E4%B8%AA%E4%BF%AE%E6%94%B9%EF%BC%9F\"><span class=\"toc-text\">我将其可以理解为 js 单线程操作 dom，同一时间不允许多个修改？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B9%9F%E8%A6%81%E9%99%90%E5%88%B6%E5%94%AF%E4%B8%80%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">rust 为什么单线程也要限制唯一可变引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B9%9F%E4%BC%9A%E6%9C%89%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">rust 单线程也会有数据竞争的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E8%A7%89%E5%BE%97%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8D%E9%9C%80%E8%A6%81%E9%99%90%E5%88%B6%E5%94%AF%E4%B8%80%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">我觉得单线程不需要限制唯一可变引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E7%9A%84%E5%90%8C%E6%97%B6%E6%8B%A5%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">不能在拥有不可变引用的同时拥有可变引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%EF%BC%8C%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%A4%9F%E7%94%A8%E7%9A%84%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">为什么可以同时创建多个不可变引用，一个不够用的吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%B1%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%AC%A1\"><span class=\"toc-text\">就创建一个不可变引用，然后使用多次</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%B8%AA%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">举个创建多个不可变引用的例子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E8%83%BD%E6%94%B9%E5%8F%98%E5%8E%9F%E6%89%80%E6%9C%89%E8%80%85%E7%9A%84%E5%80%BC%EF%BC%9F\"><span class=\"toc-text\">可变引用能改变原所有者的值？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E6%94%B9%E4%B8%8D%E5%B0%B1%E5%BE%97%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E9%80%9A%E8%BF%87%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E6%9D%A5%E6%94%B9\"><span class=\"toc-text\">直接改不就得了，为什么还要通过可变引用来改</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%8F%AA%E8%83%BD%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">函数返回只能返回值，不能返回引用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Slice-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Slice 类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E4%B8%AD-Slice-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">rust 中 Slice 解决了什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%9C%E5%AD%97%E7%AC%A6%E4%B8%B2-slice%E2%80%9D-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%86%99%E4%BD%9C-amp-str\"><span class=\"toc-text\">“字符串 slice” 的类型声明写作 &amp;str</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#slice-%E4%B8%8D%E6%98%AF%E9%81%BF%E5%85%8D%E9%94%99%E8%AF%AF%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%B0%86%E9%94%99%E8%AF%AF%E6%8F%90%E5%89%8D%E6%9A%B4%E9%9C%B2%E5%87%BA%E6%9D%A5\"><span class=\"toc-text\">slice 不是避免错误，只是将错误提前暴露出来</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#slice-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%9A%B4%E9%9C%B2\"><span class=\"toc-text\">slice 为什么可以暴露</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">结构体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%83%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">结构体与元组的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%8E%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%8E-OC%E3%80%81Golang-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">结构体是什么，与类有什么区别，与 OC、Golang 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">结构体解决了什么问题？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">结构体不能解决什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%BC%95%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">结构体使用的是引用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E5%90%A6%E5%88%86%E5%8F%AF%E5%8F%98%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9F\"><span class=\"toc-text\">结构体是否分可变和不可变？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%A6%82%E4%BD%95%E5%AE%9E%E4%BE%8B%E5%8C%96\"><span class=\"toc-text\">结构体如何实例化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">结构体的属性和方法如何调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">结构体示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">结构体打印</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81-%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B9%8B%E5%89%8D%E5%8A%A0%E4%B8%8A%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7-derive-Debug\"><span class=\"toc-text\">rust 中为什么要 在结构体定义之前加上外部属性#[derive(Debug)]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rust-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%BB%98%E8%AE%A4-derive-Debug-%EF%BC%9F\"><span class=\"toc-text\">rust 为什么不默认#[derive(Debug)] ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3-%E6%8F%8F%E8%BF%B0%E4%BA%86%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">官网文档 描述了为什么不能直接打印</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%EF%BC%8C%E8%87%AA%E5%B7%B1%E8%BD%AC%E5%8C%96%E5%90%8E%E6%A0%BC%E5%BC%8F%E5%90%8E%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%BB%99%E8%BE%93%E5%87%BA-api-%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">其他语言，自己转化后格式后，直接给输出 api 进行输出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Python\"><span class=\"toc-text\">Python</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JavaScript\"><span class=\"toc-text\">JavaScript</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Java\"><span class=\"toc-text\">Java</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-rust-%E4%B8%8D%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%9F\"><span class=\"toc-text\">为什么 rust 不这么做？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E6%83%B3%E9%97%AE%E7%9A%84%E6%98%AF%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BD%AC%E5%8C%96%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%EF%BC%8C%E9%9C%80%E8%A6%81%E5%8A%A0%E4%B8%AA-derive-Debug-%E6%A0%87%E8%AE%B0\"><span class=\"toc-text\">我想问的是：结构体为什么转化后直接输出，需要加个 #[derive(Debug)] 标记</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E6%AF%94-golang-%E4%B8%AD%E7%9A%84-marshal-%E5%90%8E%E5%9C%A8%E8%BF%9B%E8%A1%8C-print-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F\"><span class=\"toc-text\">这比 golang 中的 marshal 后在进行 print 有什么优势？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#derive-Debug-%E6%98%AF%E4%B8%8D%E6%98%AF-%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">#[derive(Debug)] 是不是 装饰器？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3%E4%B8%8D%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">注解不是装饰器模式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#golang-%E5%92%8C-rust-%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95%E9%83%BD%E8%AE%BE%E8%AE%A1%E5%88%B0%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E5%A4%96\"><span class=\"toc-text\">golang 和 rust 结构体方法都设计到结构体之外</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%AE%BE%E8%AE%A1%E5%88%B0%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E9%83%A8%EF%BC%8C%E5%83%8F-class-%E7%B1%BB%E9%82%A3%E6%A0%B7\"><span class=\"toc-text\">为什么不设计到结构体内部，像 class 类那样</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#amp-self\"><span class=\"toc-text\">&amp;self</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">自动引用和解引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95-%E5%9C%A8-Rust-%E4%B8%AD%E5%8F%AB-%E2%80%9C%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0%E2%80%9D\"><span class=\"toc-text\">结构体的方法 在 Rust 中叫 “关联函数”</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">枚举</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9E%8B\"><span class=\"toc-text\">范型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%80%81%E5%8C%96\"><span class=\"toc-text\">单态化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#trait\"><span class=\"toc-text\">trait</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5-trait%EF%BC%8C%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">为什么引入 trait，它解决了什么问题？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#trait-%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">trait 与接口有何异同？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">错误处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#println-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">println! 字符串占位符有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%B9%E9%85%8D%E5%B5%8C%E5%A5%97\"><span class=\"toc-text\">匹配嵌套</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E9%80%92%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">传递错误</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Option-x2F-Result\"><span class=\"toc-text\">Option&#x2F; Result</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">迭代器和闭包</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#match-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">match 语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vs\"><span class=\"toc-text\">:: vs .</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E7%94%A8-%E5%90%97\"><span class=\"toc-text\">枚举可以用.吗</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rust-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8\"><span class=\"toc-text\">rust 中什么时候用:: 什么时候用.</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-1\"><span class=\"toc-text\">::</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-2\"><span class=\"toc-text\">.</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%AA%E5%9D%91%EF%BC%8C%E6%98%AF%EF%BC%9A%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF%E6%9E%9A%E4%B8%BE%E5%80%BC%E7%9A%84%E6%88%90%E5%91%98\"><span class=\"toc-text\">这里有个坑，是：访问的是枚举值的成员</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E4%B8%8D%E5%8F%AF%E5%8F%8D%E9%A9%B3%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%AF%E5%8F%8D%E9%A9%B3%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">模式与模式匹配 不可反驳模式与可反驳模式的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rust-%E6%A8%A1%E5%BC%8F%E8%AF%AD%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">rust 模式语法的应用场景有哪些？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E5%88%B0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">用到模式匹配的位置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-chatgpt\"><span class=\"toc-text\">示例 chatgpt</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Refutability%EF%BC%88%E5%8F%AF%E5%8F%8D%E9%A9%B3%E6%80%A7%EF%BC%89-%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">Refutability（可反驳性）: 模式是否会匹配失效</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95-%EF%BC%88%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%89\"><span class=\"toc-text\">模式匹配语法 （官方文档）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%94%A8%E5%88%B0%E4%BA%86-23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F%E3%80%90%E7%A1%AE%E8%AE%A4%E4%B8%8B%E3%80%91\"><span class=\"toc-text\">模式匹配用到了 23 种设计模式的哪种？【确认下】</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">创建线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">线程通信</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">线程共享数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#std-sync-Mutex-%E4%B8%8E-std-sync-mpsc-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">std::sync::Mutex 与 std::sync::mpsc 区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Rust-%E5%AE%98%E7%BD%91%E7%88%AC%E5%8F%96%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">Rust 官网爬取脚本</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"python 处理excel接口文档","uid":"381db769bebbedcb74ac2aee649ff3c8","slug":"2023-06-20tool","date":"2023-06-20T10:35:27.000Z","updated":"2023-07-08T01:06:25.363Z","comments":true,"path":"api/articles/2023-06-20tool.json","keywords":null,"cover":null,"text":"脚本工具# 需要安装 openpyxl # import xlrd # workbook &#x3D; xlrd.open_workbook(&#39;mit接口文档.xlsx&#39;) # sheet &#x3D; workbook.sheet_by_index(0) # f...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":20,"path":"api/tags/工具.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"uTools vs Alfred","uid":"e4b85ee02975572057e59b823f6da301","slug":"2023-06-15utools","date":"2023-06-15T07:54:43.000Z","updated":"2023-07-16T02:13:26.427Z","comments":true,"path":"api/articles/2023-06-15utools.json","keywords":null,"cover":[],"text":" Alfred 有点糙 uTools 官网 使用教程 最终还是选择了 Alfred uTools 功能太少 uTools 广告多 ","link":"","photos":[],"count_time":{"symbolsCount":69,"symbolsTime":"1 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":20,"path":"api/tags/工具.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}