{"title":"简单了解Jest","uid":"d38ec567dd1420f161a414e047d4332c","slug":"2023-05-05jest","date":"2023-05-05T06:25:39.000Z","updated":"2023-05-15T13:17:33.003Z","comments":true,"path":"api/articles/2023-05-05jest.json","keywords":null,"cover":[],"content":"<h2 id=\"toBeFalsy-是什么意思\"><a href=\"#toBeFalsy-是什么意思\" class=\"headerlink\" title=\"toBeFalsy 是什么意思\"></a>toBeFalsy 是什么意思</h2><p><code>toBeFalsy</code> 是 Jest 和 Jasmine 中的一个匹配器（Matcher），用于判断一个值是否为假值。如果一个值可以被强制转换为 <code>false</code>，则该值被视为假值。</p>\n<p>例如，以下值被视为假值：</p>\n<ul>\n<li><code>false</code></li>\n<li><code>0</code></li>\n<li><code>-0</code></li>\n<li><code>0n</code> (BigInt 0)</li>\n<li><code>&quot;&quot;</code> (空字符串)</li>\n<li><code>null</code></li>\n<li><code>undefined</code></li>\n<li><code>NaN</code></li>\n</ul>\n<p>使用 <code>toBeFalsy</code> 匹配器可以将值与假值进行比较，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">expect(false).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(0).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(&#39;&#39;).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(null).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(undefined).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(NaN).toBeFalsy(); &#x2F;&#x2F; 通过测试\n\nexpect(true).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(1).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(&#39;hello&#39;).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(&#123;&#125;).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect([]).not.toBeFalsy(); &#x2F;&#x2F; 通过测试</code></pre>\n\n<p>注意，<code>toBeFalsy</code> 会将一些本来是真值的数据类型（如字符串、对象、数组等）视为假值，因此在使用时要特别小心。</p>\n<h2 id=\"jest-匹配器有哪些\"><a href=\"#jest-匹配器有哪些\" class=\"headerlink\" title=\"jest 匹配器有哪些\"></a>jest 匹配器有哪些</h2><p>Jest 是一款流行的 JavaScript 测试框架，内置了许多强大的匹配器（Matcher），可以用于编写各种类型的测试用例。下面列举了一些常用的 Jest 匹配器：</p>\n<ol>\n<li><p><code>toBe</code>：比较两个值是否严格相等，即使用 <code>Object.is</code> 进行比较。</p>\n</li>\n<li><p><code>toEqual</code>：比较两个值是否相等，即递归地检查对象和数组的每个字段是否相等。</p>\n</li>\n<li><p><code>toBeGreaterThan</code>：判断一个数值是否大于另一个数值。</p>\n</li>\n<li><p><code>toBeGreaterThanOrEqual</code>：判断一个数值是否大于或等于另一个数值。</p>\n</li>\n<li><p><code>toBeLessThan</code>：判断一个数值是否小于另一个数值。</p>\n</li>\n<li><p><code>toBeLessThanOrEqual</code>：判断一个数值是否小于或等于另一个数值。</p>\n</li>\n<li><p><code>toContain</code>：判断一个数组或字符串是否包含某个元素或子串。</p>\n</li>\n<li><p><code>toMatch</code>：判断一个字符串是否匹配某个正则表达式。</p>\n</li>\n<li><p><code>toThrow</code>：判断一个函数是否抛出了某个异常。</p>\n</li>\n<li><p><code>not</code>：将一个匹配器的结果取反。</p>\n</li>\n<li><p><code>toBeNull</code>：判断一个值是否为 <code>null</code>。</p>\n</li>\n<li><p><code>toBeDefined</code>：判断一个值是否已定义。</p>\n</li>\n<li><p><code>toBeUndefined</code>：判断一个值是否为 <code>undefined</code>。</p>\n</li>\n<li><p><code>toBeTruthy</code>：判断一个值是否为真值。</p>\n</li>\n<li><p><code>toBeFalsy</code>：判断一个值是否为假值。</p>\n</li>\n<li><p><code>toHaveLength</code>：判断一个对象的 <code>length</code> 属性是否等于某个值。</p>\n</li>\n<li><p><code>toHaveProperty</code>：判断一个对象是否包含某个属性。</p>\n</li>\n<li><p><code>toHaveReturned</code>：判断一个函数是否有返回值。</p>\n</li>\n<li><p><code>toHaveReturnedWith</code>：判断一个函数的返回值是否等于某个值。</p>\n</li>\n<li><p><code>toHaveBeenLastCalledWith</code>：判断一个函数最后一次调用时的参数是否符合预期。</p>\n</li>\n</ol>\n<p>还有许多其他的匹配器可以用于不同的测试场景，可以在 Jest 的官方文档中查看更多详细信息。</p>\n<h2 id=\"toBeCloseTo-与-toEqual-区别\"><a href=\"#toBeCloseTo-与-toEqual-区别\" class=\"headerlink\" title=\"toBeCloseTo 与 toEqual 区别\"></a>toBeCloseTo 与 toEqual 区别</h2><p><code>toBeCloseTo</code> 和 <code>toEqual</code> 都是 Jest 中常用的匹配器，用于比较两个值是否相等。它们之间的区别在于，<code>toBeCloseTo</code> 用于比较浮点数是否相等，而 <code>toEqual</code> 则用于比较两个值是否在递归地检查对象和数组的每个字段是否相等的情况下相等。</p>\n<p>具体来说，<code>toBeCloseTo</code> 可以在比较两个浮点数时避免由于浮点数精度问题导致的误差。例如，如果你想要比较 <code>0.1 + 0.2</code> 和 <code>0.3</code> 是否相等，使用 <code>toBeCloseTo</code> 匹配器可以避免精度误差导致的测试失败，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">test(&#39;0.1 + 0.2 should be close to 0.3&#39;, () &#x3D;&gt; &#123;\n  expect(0.1 + 0.2).toBeCloseTo(0.3);\n&#125;);</code></pre>\n\n<p>相比之下，如果你使用 <code>toEqual</code> 匹配器进行比较，则测试可能会失败，因为 <code>0.1 + 0.2</code> 的实际结果可能会有小数精度误差，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">test(&#39;0.1 + 0.2 should equal to 0.3&#39;, () &#x3D;&gt; &#123;\n  expect(0.1 + 0.2).toEqual(0.3); &#x2F;&#x2F; This test may fail due to floating point precision error\n&#125;);</code></pre>\n\n<p>总之，<code>toBeCloseTo</code> 匹配器用于比较浮点数是否相等，而 <code>toEqual</code> 匹配器用于比较两个值是否在递归地检查对象和数组的每个字段是否相等的情况下相等。</p>\n<h2 id=\"jest-beforeEach-和-afterEach-执行特点\"><a href=\"#jest-beforeEach-和-afterEach-执行特点\" class=\"headerlink\" title=\"jest beforeEach 和 afterEach 执行特点\"></a>jest beforeEach 和 afterEach 执行特点</h2><p><code>beforeEach</code> 和 <code>afterEach</code> 是 Jest 中用于在每个测试用例执行前和执行后执行代码的函数。<code>beforeEach</code> 用于初始化测试用例的状态，<code>afterEach</code> 用于清理测试用例的状态。它们可以在全局或局部范围内使用，支持嵌套使用和异步操作。在使用时需要注意它们的执行顺序和异常处理。</p>\n<p><a href=\"https://jestjs.io/zh-Hans/docs/setup-teardown#%E4%BD%9C%E7%94%A8%E5%9F%9F\" target=\"_blank\" >见</a></p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p><code>beforeEach</code> 和 <code>afterEach</code> 是 Jest 中用于在每个测试用例执行之前和之后执行一些代码的函数。它们的执行特点如下：</p>\n<ul>\n<li><p><code>beforeEach</code> 函数会在每个测试用例执行之前执行一次，用于设置测试用例执行前的状态或进行一些共同的初始化操作。多个测试用例可以共享同一个 <code>beforeEach</code> 函数。</p>\n</li>\n<li><p><code>afterEach</code> 函数会在每个测试用例执行之后执行一次，用于清理测试用例执行后的状态或进行一些共同的清理操作。多个测试用例可以共享同一个 <code>afterEach</code> 函数。</p>\n</li>\n</ul>\n<p>这些函数的作用类似于测试用例中的 <code>setup</code> 和 <code>teardown</code>，但是它们更加灵活，可以在全局或局部范围内使用，并且可以在多个测试用例之间共享代码。</p>\n<p>在使用 <code>beforeEach</code> 和 <code>afterEach</code> 函数时，需要注意以下几点：</p>\n<ul>\n<li><p><code>beforeEach</code> 和 <code>afterEach</code> 函数可以嵌套使用，形成多级的设置和清理操作。</p>\n</li>\n<li><p>如果多个 <code>beforeEach</code> 或 <code>afterEach</code> 函数在同一个作用域中定义，它们的执行顺序是按照定义顺序从上到下执行的。</p>\n</li>\n<li><p>如果在一个测试用例中使用了异步操作，可以在 <code>beforeEach</code> 或 <code>afterEach</code> 函数中使用 <code>async/await</code> 或者 <code>return Promise</code> 来处理异步操作。</p>\n</li>\n<li><p>如果在 <code>beforeEach</code> 或 <code>afterEach</code> 函数中抛出了异常，会导致该测试用例的执行失败，而不会影响其他测试用例的执行。</p>\n</li>\n</ul>\n<p>总之，<code>beforeEach</code> 和 <code>afterEach</code> 函数是 Jest 中非常实用的函数，可以用于在测试用例执行前和执行后进行初始化和清理操作，提高测试用例的可维护性和可重复性。</p>\n</p>\n</details>\n<h2 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h2><p>默认情况下，Jest 会按照收集阶段遇到的顺序连续运行所有测试，等待每个测试完成并在继续之前进行整理</p>\n<p>简单来说：就是一层一层扒皮，逐层深入进行测试</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">describe(&#39;describe outer&#39;, () &#x3D;&gt; &#123;\n  console.log(&#39;describe outer-a&#39;);\n\n  describe(&#39;describe inner 1&#39;, () &#x3D;&gt; &#123;\n    console.log(&#39;describe inner 1&#39;);\n\n    test(&#39;test 1&#39;, () &#x3D;&gt; console.log(&#39;test 1&#39;));\n  &#125;);\n\n  console.log(&#39;describe outer-b&#39;);\n\n  test(&#39;test 2&#39;, () &#x3D;&gt; console.log(&#39;test 2&#39;));\n\n  describe(&#39;describe inner 2&#39;, () &#x3D;&gt; &#123;\n    console.log(&#39;describe inner 2&#39;);\n\n    test(&#39;test 3&#39;, () &#x3D;&gt; console.log(&#39;test 3&#39;));\n  &#125;);\n\n  console.log(&#39;describe outer-c&#39;);\n&#125;);\n\n&#x2F;&#x2F; describe outer-a\n&#x2F;&#x2F; describe inner 1\n&#x2F;&#x2F; describe outer-b\n&#x2F;&#x2F; describe inner 2\n&#x2F;&#x2F; describe outer-c\n&#x2F;&#x2F; test 1\n&#x2F;&#x2F; test 2\n&#x2F;&#x2F; test 3</code></pre>\n\n<h2 id=\"执行整个测试-x2F-执行一个测试\"><a href=\"#执行整个测试-x2F-执行一个测试\" class=\"headerlink\" title=\"执行整个测试&#x2F;执行一个测试\"></a>执行整个测试&#x2F;执行一个测试</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">test.only(&#39;this will be the only test that runs&#39;, () &#x3D;&gt; &#123;\n  expect(true).toBe(false);\n&#125;);\n\ntest(&#39;this test will not run&#39;, () &#x3D;&gt; &#123;\n  expect(&#39;A&#39;).toBe(&#39;A&#39;);\n&#125;);</code></pre>\n\n<p>test.only 执行单个测试，未使用 test.only 的将会被 skip</p>\n<img src=\"http://t-blog-images.aijs.top/img/202305051504014.webp\" />\n","text":"toBeFalsy 是什么意思toBeFalsy 是 Jest 和 Jasmine 中的一个匹配器（Matcher），用于判断一个值是否为假值。如果一个值可以被强制转换为 false，则该值被视为假值。 例如，以下值被视为假值： false 0 -0 0n (BigInt 0) ...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"Jest","slug":"Jest","count":1,"path":"api/categories/Jest.json"}],"tags":[{"name":"Jest","slug":"Jest","count":1,"path":"api/tags/Jest.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#toBeFalsy-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">toBeFalsy 是什么意思</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jest-%E5%8C%B9%E9%85%8D%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">jest 匹配器有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#toBeCloseTo-%E4%B8%8E-toEqual-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">toBeCloseTo 与 toEqual 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jest-beforeEach-%E5%92%8C-afterEach-%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">jest beforeEach 和 afterEach 执行特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%95%B4%E4%B8%AA%E6%B5%8B%E8%AF%95-x2F-%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">执行整个测试&#x2F;执行一个测试</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Python 编程语言的基本语法","uid":"63b21671e504fbf555fa8354eb1a75b6","slug":"2023-05-06python","date":"2023-05-06T09:44:08.000Z","updated":"2023-05-29T00:41:07.264Z","comments":true,"path":"api/articles/2023-05-06python.json","keywords":null,"cover":null,"text":"动机用不用的着我就想学，咋滴～，距去年国庆学的 Python 和 Django 有半年了，原计划五一劳动节再学一遍 Python 的，结果呢–看“仙侠剧”、搓饭、遛猫（真的是遛猫不是遛狗），五一就没了，😅 理解 python 特性Python 是一个高层次的结合了解释性、编译性、...","link":"","photos":[],"count_time":{"symbolsCount":"71k","symbolsTime":"1:04"},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Gorm的一些疑问","uid":"0a2a2b57038aa5719495ef60739019cc","slug":"2023-05-04gorm","date":"2023-05-04T01:31:34.000Z","updated":"2023-05-15T13:17:33.002Z","comments":true,"path":"api/articles/2023-05-04gorm.json","keywords":null,"cover":null,"text":"gormgorm 中文文档 golang gorm 有哪些 APIGolang 的 ORM 库 GORM 是一个流行的数据库操作库，提供了丰富的 API 用于进行数据库操作。以下是 GORM 库的一些常用 API： 创建连接： db, err :&#x3D; gorm.Open(...","link":"","photos":[],"count_time":{"symbolsCount":"120k","symbolsTime":"1:49"},"categories":[{"name":"Gorm","slug":"Gorm","count":1,"path":"api/categories/Gorm.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"},{"name":"Gorm","slug":"Gorm","count":1,"path":"api/tags/Gorm.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}