{"title":"Map & Set & Object","uid":"4a39cce638cfb347201792d2fa0ff3a8","slug":"2023-01-21map&set","date":"2023-01-21T06:48:19.000Z","updated":"2023-02-20T21:20:56.485Z","comments":true,"path":"api/articles/2023-01-21map&set.json","keywords":null,"cover":null,"content":"<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"Map-的特点\"><a href=\"#Map-的特点\" class=\"headerlink\" title=\"Map 的特点\"></a>Map 的特点</h3><ol>\n<li><code>有序</code>： Map 对象保存键值对，并且<code>能够记住键的原始插入顺序</code>。</li>\n<li><code>键值随意</code>：任何值（对象或者基本类型）都可以作为一个键或一个值。</li>\n<li>Map 对象是键值对的集合。</li>\n<li><code>键唯一</code>：Map 中的一个键只能出现一次；它在 Map 的集合中是独一无二的。</li>\n<li><code>可迭代</code>：Map 对象按键值对迭代——一个 for…of 循环在每次迭代后会返回一个形式为 [key，value] 的数组。</li>\n<li>迭代按插入顺序进行，即键值对按 set() 方法首次插入到集合中的顺序（也就是说，当调用 set() 时，map 中没有具有相同值的键）进行迭代。</li>\n<li><code>线性关系</code>：平均访问时间与集合中的元素数量呈次线性关系</li>\n<li>可与二维数组互转</li>\n</ol>\n<h3 id=\"二维数组转化\"><a href=\"#二维数组转化\" class=\"headerlink\" title=\"二维数组转化\"></a>二维数组转化</h3><ol>\n<li>将 <code>NaN</code> 作为 Map 的键, <code>所有 NAN 键相同</code></li>\n<li>使用 <code>for...of</code> 方法迭代 Map， 使用 <code>forEach()</code> 方法迭代 Map</li>\n<li>Map 与数组的关系<code>(二维键值对数组 / Map 对象 使用 Array.from  -&gt; 二维键值对数组 )</code></li>\n<li>合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的。(展开语法本质上是将 Map 对象转换成数组)</li>\n</ol>\n<h3 id=\"键的相等\"><a href=\"#键的相等\" class=\"headerlink\" title=\"键的相等\"></a>键的相等</h3><p>键的比较基于<code>零值相等算法</code>。（它曾经使用<code>同值相等</code>，将 0 和 -0 视为不同。检查浏览器兼容性。）这意味着 NaN 是与 NaN 相等的（虽然 NaN !&#x3D;&#x3D; NaN），剩下所有其它的值是根据 &#x3D;&#x3D;&#x3D; 运算符的结果判断是否相等。</p>\n<h2 id=\"Object-和-Map-的比较\"><a href=\"#Object-和-Map-的比较\" class=\"headerlink\" title=\"Object 和 Map 的比较\"></a>Object 和 Map 的比较</h2><h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><p>Object 和 Map 类似的是，<code>按键存取一个值、删除键、检测一个键是否绑定了值</code>。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Map 使用</p>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">Map</th>\n<th align=\"left\">Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">意外的键</td>\n<td align=\"left\">Map 默认情况不包含任何键。只包含显式插入的键。</td>\n<td align=\"left\">一个 Object 有一个原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</td>\n</tr>\n<tr>\n<td align=\"left\">键的类型</td>\n<td align=\"left\">一个 Map 的键可以是任意值，包括函数、对象或任意基本类型。</td>\n<td align=\"left\">一个 Object 的键必须是一个 String 或是 Symbol。</td>\n</tr>\n<tr>\n<td align=\"left\">键的顺序</td>\n<td align=\"left\">Map 中的键是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。</td>\n<td align=\"left\">虽然 Object 的键目前是有序的，但并不总是这样，而且这个顺序是复杂的。因此，最好不要依赖属性的顺序。</td>\n</tr>\n<tr>\n<td align=\"left\">Size</td>\n<td align=\"left\">Map 的键值对个数可以轻易地通过 size 属性获取。</td>\n<td align=\"left\">Object 的键值对个数只能手动计算。</td>\n</tr>\n<tr>\n<td align=\"left\">迭代</td>\n<td align=\"left\">Map 是 可迭代的 的，所以可以直接被迭代。</td>\n<td align=\"left\">Object 没有实现 迭代协议，所以使用 JavaSctipt 的 for…of 表达式并不能直接迭代对象。</td>\n</tr>\n<tr>\n<td align=\"left\">性能</td>\n<td align=\"left\">在频繁增删键值对的场景下表现更好。</td>\n<td align=\"left\">在频繁添加和删除键值对的场景下未作出优化。</td>\n</tr>\n<tr>\n<td align=\"left\">序列化和解析</td>\n<td align=\"left\">没有元素的序列化和解析的支持。</td>\n<td align=\"left\">原生的由 Object 到 JSON 的序列化支持，使用 JSON.stringify()。</td>\n</tr>\n</tbody></table>\n<h2 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h2><ol>\n<li>WeakMap <code>是一组键值对的集合，其中的键是弱引用对象，而值可以是任意</code>。</li>\n<li>WeakMap <code>弱引用的只是键名</code>，而不是键值，键值依然是正常使用的。</li>\n</ol>\n<h2 id=\"WeakMap-特点\"><a href=\"#WeakMap-特点\" class=\"headerlink\" title=\"WeakMap 特点\"></a>WeakMap 特点</h2><ol>\n<li>只接受对象作为键名</li>\n<li>键名是弱引用，可以被垃圾回收</li>\n<li>不可遍历</li>\n<li>API 和 Map 相同</li>\n</ol>\n<h2 id=\"Map-api\"><a href=\"#Map-api\" class=\"headerlink\" title=\"Map api\"></a>Map api</h2><ol>\n<li><code>new Map()</code>—— 创建 map。</li>\n<li><code>map.set(key, value)</code>—— 根据键存储值。</li>\n<li><code>map.get(key)</code>—— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。</li>\n<li><code>map.has(key)</code>—— 如果 key 存在则返回 true，否则返回 false。</li>\n<li><code>map.delete(key)</code>—— 删除指定键的值。</li>\n<li><code>map.clear()</code>—— 清空 map。</li>\n<li><code>map.size</code>—— 返回当前元素个数。</li>\n<li><code>keys</code> <code>values</code> <code>entries</code> <code>forEach</code></li>\n</ol>\n<h2 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h2><p>Set 与 Map 类似，<code>是一组 Key 的集合，但不存储 Value，由于 Key 不能重复，因此他最大的特点是所有的元素都是唯一的</code>。</p>\n<ol>\n<li><code>new Set(iterable)</code> —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里- 面复制值到 set 中。</li>\n<li><code>set.add(value)</code> —— 添加一个值，返回 set 本身</li>\n<li><code>set.delete(value)</code> —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。</li>\n<li><code>set.clear()</code> —— 清空 set。</li>\n<li><code>set.has(value)</code> —— 如果 value 在 set 中，返回 true，否则返回 false。</li>\n<li><code>set.size</code> —— 返回元素个数。</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/Dax1_/article/details/123185260\" target=\"_blank\" >总结 ES6 中 Map 和 Set 的特点与比较</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" >Map</a></p>\n","text":"MapMap 的特点 有序： Map 对象保存键值对，并且能够记住键的原始插入顺序。 键值随意：任何值（对象或者基本类型）都可以作为一个键或一个值。 Map 对象是键值对的集合。 键唯一：Map 中的一个键只能出现一次；它在 Map 的集合中是独一无二的。 可迭代：Map 对象按...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Map-%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">Map 的特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96\"><span class=\"toc-text\">二维数组转化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%AE%E7%9A%84%E7%9B%B8%E7%AD%89\"><span class=\"toc-text\">键的相等</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-%E5%92%8C-Map-%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">Object 和 Map 的比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">相同点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">不同点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WeakMap\"><span class=\"toc-text\">WeakMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WeakMap-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">WeakMap 特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map-api\"><span class=\"toc-text\">Map api</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89\"><span class=\"toc-text\">Set（集合）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React Refs","uid":"5fabc47ffe883306098d02d0d23becda","slug":"2023-01-28refs","date":"2023-01-28T05:36:24.000Z","updated":"2023-02-20T21:20:56.485Z","comments":true,"path":"api/articles/2023-01-28refs.json","keywords":null,"cover":null,"text":"Refs &amp; DOM 为 DOM 元素添加 ref 为 class 组件添加 Ref Refs 与函数组件 默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例 如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativ...","link":"","photos":[],"count_time":{"symbolsCount":704,"symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":36,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":30,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"position sticky 失效了","uid":"8a2b4fbe9c65dfb47fc690fa692de0b8","slug":"2023-01-19sticky","date":"2023-01-19T09:22:16.000Z","updated":"2023-02-20T21:20:56.485Z","comments":true,"path":"api/articles/2023-01-19sticky.json","keywords":null,"cover":[],"text":"原理sticky 元素根据正常文档流进行定位， 然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block（最近块级祖先 nearest block-level ancestor），包括 table-related 元素，...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"CSS","slug":"CSS","count":4,"path":"api/categories/CSS.json"}],"tags":[{"name":"CSS","slug":"CSS","count":4,"path":"api/tags/CSS.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}