{"title":"esbuild【未完】","uid":"5d9cafec7c25eb56320f408e07855150","slug":"2023-07-03esbuild","date":"2023-07-03T01:47:30.000Z","updated":"2023-07-08T01:06:25.366Z","comments":true,"path":"api/articles/2023-07-03esbuild.json","keywords":null,"cover":null,"content":"<h2 id=\"esbuild-为什么叫-esbuild-名字的由来\"><a href=\"#esbuild-为什么叫-esbuild-名字的由来\" class=\"headerlink\" title=\"esbuild 为什么叫 esbuild, 名字的由来\"></a>esbuild 为什么叫 esbuild, 名字的由来</h2><p>esbuild 的名字源自于两个关键因素：ES（ECMAScript）和构建（build）。</p>\n<ol>\n<li><p>ES：ESbuild 是专为 ECMAScript（即 JavaScript）设计的构建工具。ECMAScript 是一种标准化的脚本语言，JavaScript 是 ECMAScript 的一种实现。因此，ESbuild 强调了它是专为 JavaScript 代码进行构建、优化和打包而生的工具。</p>\n</li>\n<li><p>构建：构建是指将开发者编写的源代码转换、优化和打包成可在浏览器中或其他环境中运行的形式。ESbuild 提供了快速的构建能力，能够快速处理 JavaScript 代码并生成高性能的结果。因此，构建（build）这个词也被包含在工具的名字中。</p>\n</li>\n</ol>\n<p>因此，ESbuild 的名字展示了它是一个面向 JavaScript 构建的工具，旨在为开发者提供快速、高效的构建能力。</p>\n<h2 id=\"esbuild-有什么优点和缺点\"><a href=\"#esbuild-有什么优点和缺点\" class=\"headerlink\" title=\"esbuild 有什么优点和缺点\"></a>esbuild 有什么优点和缺点</h2><p>esbuild 是一个快速的 JavaScript 构建工具，具有以下优点和缺点：</p>\n<p>优点：</p>\n<ol>\n<li>极速构建：esbuild 使用 Go 语言编写，采用高效的算法和并行处理，因此在构建速度方面非常出色。它能够快速地将 JavaScript 代码转换成高性能的结果，使得开发者能够更快地进行开发和调试。</li>\n<li>低启动时间：esbuild 的启动时间非常短，可以快速加载和处理大型项目，这对于大型应用程序是非常有益的。</li>\n<li>小巧的体积：esbuild 的二进制文件体积很小，使得安装和使用都非常方便。</li>\n<li>支持广泛：esbuild 支持各种 JavaScript 语法和特性，包括 TypeScript、JSX 等。它还支持处理 CSS 和 JSON 等其他类型的文件，并且可以通过插件进行扩展。</li>\n<li>易于使用：esbuild 提供简单易用的命令行界面和配置选项，使得配置和构建过程变得简单和直观。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>相对年轻：esbuild 是一个相对较新的构建工具，相对于其他成熟的构建工具（如 Webpack、Rollup），它的生态系统和社区支持可能还不够完善。</li>\n<li>功能有限：虽然 esbuild 提供了基本的构建功能，但是一些复杂的功能（如代码拆分、跨浏览器兼容性和多页应用等）可能需要额外的配置和插件支持。</li>\n<li>不适合所有场景：由于其设计目标是快速构建，所以在某些特定场景下（例如需要复杂优化和定制的项目）可能会存在一些限制。</li>\n</ol>\n<p>总体来说，esbuild 的优点在于其快速的构建速度和高性能，使得它成为处理大型 JavaScript 项目或需要快速迭代的项目的理想选择。但同时，也要注意其相对较新且功能有限的特点，在某些场景下可能并不适用。</p>\n<h2 id=\"esbuild-Content-Types\"><a href=\"#esbuild-Content-Types\" class=\"headerlink\" title=\"esbuild Content Types\"></a>esbuild Content Types</h2><p>esbuild 支持多种内容类型，可以将其作为输入或输出。</p>\n<p>以下是一些常见的 esbuild 内容类型：</p>\n<ul>\n<li><p>JavaScript (application&#x2F;javascript): 这是 esbuild 最常用的内容类型，用于处理 JavaScript 文件。它可以是标准的 ECMAScript 代码或模块。</p>\n</li>\n<li><p>JSX (text&#x2F;jsx): JSX 是一种 JavaScript 的扩展语法，用于编写 React 组件。ESbuild 可以处理包含 JSX 的文件，并将其转换为标准的 JavaScript 代码。</p>\n</li>\n<li><p>TypeScript (application&#x2F;typescript): TypeScript 是一种静态类型的 JavaScript 扩展，具有类型检查和编译选项。ESbuild 可以直接处理 TypeScript 代码，将其转换为 JavaScript。</p>\n</li>\n<li><p>JSON (application&#x2F;json): ESbuild 可以处理包含 JSON 数据的文件，例如配置文件、数据文件等。</p>\n</li>\n<li><p>CSS (text&#x2F;css): ESbuild 可以处理 CSS 文件，并进行必要的转换、优化和提取。</p>\n</li>\n<li><p>HTML (text&#x2F;html): ESbuild 可以处理包含 HTML 内容的文件，将其视为字符串进行处理。</p>\n</li>\n<li><p>WebAssembly (application&#x2F;wasm): ESbuild 支持 WebAssembly 文件的处理。</p>\n</li>\n</ul>\n<p>这只是 esbuild 支持的一些常见内容类型的示例。除了这些类型，还可以通过插件和自定义 loader 来处理其他类型的内容。</p>\n<h2 id=\"开发-esbuild-的插件\"><a href=\"#开发-esbuild-的插件\" class=\"headerlink\" title=\"开发 esbuild 的插件\"></a>开发 esbuild 的插件</h2><p>要开发 esbuild 插件，可以按照以下步骤进行：</p>\n<ol>\n<li><p>安装 esbuild：首先，确保已经安装了 esbuild。可以使用以下命令进行全局安装：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install -g esbuild</code></pre>\n</li>\n<li><p>创建插件项目：创建一个新的目录并初始化一个新的 npm 项目。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mkdir my-esbuild-plugin\ncd my-esbuild-plugin\nnpm init -y</code></pre>\n</li>\n<li><p>安装插件开发依赖项：安装用于插件开发的相关依赖项。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install --save-dev esbuild</code></pre>\n</li>\n<li><p>创建插件文件：在项目目录下创建一个名为 <code>my-plugin.js</code> 的文件，并编写插件代码。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; my-plugin.js\n&#x2F;&#x2F; 导出一个函数作为插件\nmodule.exports &#x3D; (options) &#x3D;&gt; (&#123;\n  name: &#39;my-plugin&#39;, &#x2F;&#x2F; 插件的名称，用于标识\n  setup(build) &#123;\n    &#x2F;&#x2F; 在 build 阶段进行插件处理\n    build.onLoad(&#123; filter: &#x2F;\\.txt$&#x2F; &#125;, async (args) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 根据文件扩展名过滤需要处理的文件\n      &#x2F;&#x2F; 此处以处理 .txt 文件为例\n      const contents &#x3D; await fs.promises.readFile(args.path, &#39;utf8&#39;);\n      const transformedContents &#x3D; doSomethingWithContents(contents);\n      return &#123;\n        contents: transformedContents,\n        loader: &#39;text&#39;, &#x2F;&#x2F; 加载器类型，返回值必须与该类型兼容\n      &#125;;\n    &#125;);\n  &#125;,\n&#125;);</code></pre>\n\n<p>在这个示例中，插件会对以 <code>.txt</code> 结尾的文件进行特定处理，并返回转换后的内容。</p>\n</li>\n<li><p>在构建脚本中使用插件：在项目的 <code>package.json</code> 文件中，添加一个自定义的构建脚本，可以使用 esbuild 命令来使用你的插件。</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#x2F;&#x2F; package.json\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;build&quot;: &quot;esbuild --plugins&#x3D;.&#x2F;my-plugin.js&quot;\n  &#125;\n&#125;</code></pre>\n\n<p>这个示例将插件文件作为参数传递给 esbuild 命令。</p>\n</li>\n<li><p>运行插件：使用以下命令运行构建脚本。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm run build</code></pre>\n\n<p>这将执行构建命令，并使用你的插件进行特定处理。</p>\n</li>\n</ol>\n<p>这只是插件开发的基本步骤。你可以根据需要进行更复杂的操作，比如对不同类型的文件进行处理、添加更多的阶段钩子等。插件开发的更多细节可以参考 <a href=\"https://esbuild.github.io/plugins/\">esbuild 插件文档</a>。</p>\n<h2 id=\"esbuild-插件命名空间\"><a href=\"#esbuild-插件命名空间\" class=\"headerlink\" title=\"esbuild 插件命名空间\"></a>esbuild 插件命名空间</h2><p>esbuild 插件使用命名空间来标识插件，确保插件的名称不会与其他插件冲突。命名空间在插件的 <code>name</code> 属性中指定。</p>\n<p>以下是一个使用命名空间的示例插件：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; my-plugin.js\nmodule.exports &#x3D; (options) &#x3D;&gt; (&#123;\n  name: &#39;my-namespace&#x2F;my-plugin&#39;,\n  setup(build) &#123;\n    &#x2F;&#x2F; 插件逻辑\n  &#125;,\n&#125;);</code></pre>\n\n<p>在上面的示例中，插件的命名空间是 <code>my-namespace</code>，插件名称是 <code>my-plugin</code>。命名空间和插件名称用 <code>/</code> 分隔。</p>\n<p>建议在插件名称中使用命名空间，以便区分不同的插件。这样可以确保插件的唯一性，并且方便其他开发者理解和使用插件。</p>\n<p>使用命名空间后，将插件文件路径添加到 <code>--plugins</code> 选项中时，<strong>不需要包含命名空间</strong>。例如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">esbuild --plugins&#x3D;.&#x2F;my-plugin.js</code></pre>\n\n<p>在引入插件时，也需要包含命名空间：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myPlugin &#x3D; require(&#39;my-namespace&#x2F;my-plugin&#39;);</code></pre>\n\n<p>使用命名空间可以避免插件冲突，确保插件系统的可扩展性和互操作性。</p>\n<h2 id=\"esbuild-插件-过滤器\"><a href=\"#esbuild-插件-过滤器\" class=\"headerlink\" title=\"esbuild 插件 过滤器\"></a>esbuild 插件 过滤器</h2><p>在 esbuild 中，插件过滤器用于选择性地为特定的模块或资源应用插件。通过过滤器，您可以对插件的应用进行精确控制。以下是插件过滤器的使用示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const esbuild &#x3D; require(&#39;esbuild&#39;);\nconst myPlugin &#x3D; require(&#39;my-plugin&#39;);\n\nesbuild\n  .build(&#123;\n    entryPoints: [&#39;src&#x2F;index.js&#39;],\n    outfile: &#39;dist&#x2F;bundle.js&#39;,\n    plugins: [\n      &#123;\n        name: &#39;my-plugin&#39;,\n        setup(build) &#123;\n          &#x2F;&#x2F; 使用过滤器指定应用插件的条件\n          build.onLoad(&#123; filter: &#x2F;index\\.js$&#x2F; &#125;, async (args) &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 在匹配的模块上应用插件逻辑\n            return &#123;\n              contents: &#39;console.log(&quot;Hello, esbuild!&quot;)&#39;,\n              loader: &#39;js&#39;,\n            &#125;;\n          &#125;);\n        &#125;,\n      &#125;,\n    ],\n  &#125;)\n  .catch(() &#x3D;&gt; process.exit(1));</code></pre>\n\n<p>在这个示例中，我们定义了一个名为 <code>my-plugin</code> 的插件，并使用 <code>build.onLoad</code> 方法为匹配的模块应用插件逻辑。<code>filter</code> 参数是一个正则表达式，用于选择要应用插件的模块。在这个示例中，只有满足名称为 <code>index.js</code> 的模块才会应用 <code>my-plugin</code> 插件。</p>\n<p>您可以按需定义插件过滤器，根据您的需求来决定要应用插件的模块。这样，您就可以更灵活地控制插件的使用。请注意，插件过滤器是可选的，如果不需要过滤，则可以在整个构建过程中应用插件。</p>\n<h2 id=\"这个可以理解为-webpack-loader-的-test\"><a href=\"#这个可以理解为-webpack-loader-的-test\" class=\"headerlink\" title=\"这个可以理解为 webpack loader 的 test?\"></a>这个可以理解为 webpack loader 的 test?</h2><p>是的，可以将 esbuild 中的插件过滤器类比为 webpack 中的 loader 的 test 属性。它们都用于指定要应用插件或 loader 的条件。</p>\n<p>在 webpack 中，loader 的 <code>test</code> 属性是一个正则表达式或正则表达式数组，用于匹配要应用 loader 的模块。类似地，在 esbuild 中，插件过滤器的 <code>filter</code> 参数也是一个正则表达式，用于选择要应用插件的模块。</p>\n<p>通过指定匹配条件，您可以根据模块的特征来有选择性地应用插件或 loader，以实现更精确的构建控制。这使得您可以与构建工具集成并针对特定的模块或资源进行自定义处理。</p>\n<h2 id=\"开发-esbuild-插件时候用到的生命钩子-x2F-回调\"><a href=\"#开发-esbuild-插件时候用到的生命钩子-x2F-回调\" class=\"headerlink\" title=\"开发 esbuild 插件时候用到的生命钩子&#x2F;回调\"></a>开发 esbuild 插件时候用到的生命钩子&#x2F;回调</h2><p>在开发 esbuild 插件时，可以使用以下生命周期钩子&#x2F;回调来实现不同的功能和行为：</p>\n<ol>\n<li><p><code>setup(build)</code>：在构建开始之前调用，用于设置插件。可以注册其他的生命周期钩子和自定义行为。</p>\n</li>\n<li><p><code>resolveId(source, importer)</code>：在解析模块标识符时调用，用于查找模块的路径或 URL。可以返回一个解析后的标识符。</p>\n</li>\n<li><p><code>load(id)</code>：在加载模块时调用，用于获取模块的内容。可以返回一个包含模块内容的字符串。</p>\n</li>\n<li><p><code>transform(source, importer)</code>：在转换模块时调用，用于对模块内容进行转换。可以返回一个修改后的模块内容。</p>\n</li>\n<li><p><code>onLoad(&#123; filter, namespace &#125;, onLoad)</code>：在根据模块的 URL 加载模块时调用。可以使用 <code>onLoad</code> 回调函数来提供模块的内容或路径。</p>\n</li>\n<li><p><code>onResolve(&#123; filter, namespace &#125;, onResolve)</code>：在解析模块标识符时调用。可以使用 <code>onResolve</code> 回调函数来解析模块的路径或 URL。</p>\n</li>\n<li><p><code>onStart(&#123; filter, namespace &#125;)</code>：在构建每个入口点（entry）之前调用。可以在此处执行一些准备工作或清理操作。</p>\n</li>\n<li><p><code>onEnd(result)</code>：在构建完成后调用，用于执行最终的操作或清理。参数 <code>result</code> 是构建完成后的结果对象，包含构建的输出信息。</p>\n</li>\n</ol>\n<p>以上是常用的生命周期钩子&#x2F;回调，具体根据需求选择合适的钩子&#x2F;回调来实现插件的功能。在插件的开发中，可以参考 esbuild 的插件文档以及相关示例来了解每个钩子的使用方式和参数。</p>\n<h2 id=\"esbuild-的作用类似有抽象语法树？是对-IO-的读取-、转化-、输出？\"><a href=\"#esbuild-的作用类似有抽象语法树？是对-IO-的读取-、转化-、输出？\" class=\"headerlink\" title=\"esbuild 的作用类似有抽象语法树？是对 IO 的读取 、转化 、输出？\"></a>esbuild 的作用类似有抽象语法树？是对 IO 的读取 、转化 、输出？</h2><p>esbuild 是一个快速、低配置且易于使用的 JavaScript 打包器和压缩工具，其主要功能是将 JavaScript、CSS 和 TypeScript 代码进行转换、压缩和打包。尽管它与抽象语法树（Abstract Syntax Tree，简称 AST）和在编译器中进行的词法分析和语法分析相关，但它的功能更为广泛。</p>\n<p>esbuild 的主要作用可以总结如下：</p>\n<ol>\n<li><p>转换：esbuild 可以将不同类型的代码（如 JavaScript、CSS、TypeScript）转换为符合目标环境要求的代码，例如将 ECMAScript 2015+ 的代码转换为 ES5 兼容的代码，或者将 JSX 转换为普通的 JavaScript。</p>\n</li>\n<li><p>压缩：esbuild 还提供了代码压缩的功能，可以通过消除不必要的空格、删除注释、重命名变量等方式来减小代码的体积。</p>\n</li>\n<li><p>模块化打包：esbuild 可以将多个模块打包为单个文件，以提高代码的加载性能和执行效率。它支持常见的模块化系统（如 CommonJS、ES Modules）以及第三方库的导入（如 npm 包）。</p>\n</li>\n<li><p>快速构建：esbuild 被设计为非常快速的打包工具，通过并行处理、缓存和优化算法等方法来提升构建速度，适用于大型项目和快速的开发迭代。</p>\n</li>\n</ol>\n<p>虽然 esbuild 在转换和打包过程中可能涉及读取、转换和输出文件，但它更注重于在内存中进行转换和处理，以获得更快的构建速度。相比之下，抽象语法树更着重于对代码结构进行解析和分析，以便于在编译器中进行各种优化、转换和静态分析的操作。因此，虽然两者都处理代码，但它们的功能和重点略有不同。</p>\n<h2 id=\"onResolve-的示例\"><a href=\"#onResolve-的示例\" class=\"headerlink\" title=\"onResolve 的示例\"></a>onResolve 的示例</h2><p>下面是一个使用 <code>onResolve</code> 的示例，展示了如何在 <code>esbuild</code> 的构建过程中对导入的模块进行自定义处理：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const esbuild &#x3D; require(&#39;esbuild&#39;);\n\nesbuild\n  .build(&#123;\n    entryPoints: [&#39;src&#x2F;main.js&#39;],\n    bundle: true,\n    outfile: &#39;dist&#x2F;bundle.js&#39;,\n    platform: &#39;browser&#39;,\n    format: &#39;esm&#39;,\n    onResolve: (&#123; importer, path &#125;) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 在这里可以自定义处理模块导入\n      if (path &#x3D;&#x3D;&#x3D; &#39;package-name&#39;) &#123;\n        &#x2F;&#x2F; 返回一个新的解析路径，替换原始导入路径\n        return &#123; path: &#39;path&#x2F;to&#x2F;custom&#x2F;package.js&#39; &#125;;\n      &#125;\n    &#125;,\n  &#125;)\n  .catch((err) &#x3D;&gt; &#123;\n    console.error(err);\n    process.exit(1);\n  &#125;);</code></pre>\n\n<p>在这个示例中，我们使用 <code>esbuild</code> 的 <code>build</code> 函数来进行构建。在 <code>build</code> 函数的配置中，我们指定了入口点、输出文件位置、平台和格式等参数。</p>\n<p>然后，我们使用 <code>onResolve</code> 配置项来定义一个回调函数，在模块解析的过程中进行自定义的解析逻辑。当有模块被导入时，<code>onResolve</code> 回调函数会被触发，并传入一个包含 <code>importer</code>（导入该模块的文件路径）和 <code>path</code>（被导入的模块路径）属性的对象。</p>\n<p>在回调函数中，我们可以根据 <code>importer</code> 和 <code>path</code> 的值来进行判断和处理。在上述示例中，如果导入的模块路径为 <code>&#39;package-name&#39;</code>，我们可以返回一个新的解析路径，例如 <code>&#39;path/to/custom/package.js&#39;</code>，以替换原始的导入路径。</p>\n<p>通过这种方式，我们可以使用 <code>onResolve</code> 来自定义处理模块的解析过程，例如修改或替换导入的模块路径，或者在特定条件下使用不同的模块实现。这为开发者提供了更灵活的配置和控制，以满足项目的特殊需求。</p>\n","text":"esbuild 为什么叫 esbuild, 名字的由来esbuild 的名字源自于两个关键因素：ES（ECMAScript）和构建（build）。 ES：ESbuild 是专为 ECMAScript（即 JavaScript）设计的构建工具。ECMAScript 是一种标准化的脚...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"构建工具","slug":"构建工具","count":1,"path":"api/categories/构建工具.json"}],"tags":[{"name":"构建工具","slug":"构建工具","count":1,"path":"api/tags/构建工具.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#esbuild-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB-esbuild-%E5%90%8D%E5%AD%97%E7%9A%84%E7%94%B1%E6%9D%A5\"><span class=\"toc-text\">esbuild 为什么叫 esbuild, 名字的由来</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#esbuild-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">esbuild 有什么优点和缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#esbuild-Content-Types\"><span class=\"toc-text\">esbuild Content Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%8F%91-esbuild-%E7%9A%84%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">开发 esbuild 的插件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#esbuild-%E6%8F%92%E4%BB%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">esbuild 插件命名空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#esbuild-%E6%8F%92%E4%BB%B6-%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">esbuild 插件 过滤器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA-webpack-loader-%E7%9A%84-test\"><span class=\"toc-text\">这个可以理解为 webpack loader 的 test?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%8F%91-esbuild-%E6%8F%92%E4%BB%B6%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%E7%9A%84%E7%94%9F%E5%91%BD%E9%92%A9%E5%AD%90-x2F-%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">开发 esbuild 插件时候用到的生命钩子&#x2F;回调</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#esbuild-%E7%9A%84%E4%BD%9C%E7%94%A8%E7%B1%BB%E4%BC%BC%E6%9C%89%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%9F%E6%98%AF%E5%AF%B9-IO-%E7%9A%84%E8%AF%BB%E5%8F%96-%E3%80%81%E8%BD%AC%E5%8C%96-%E3%80%81%E8%BE%93%E5%87%BA%EF%BC%9F\"><span class=\"toc-text\">esbuild 的作用类似有抽象语法树？是对 IO 的读取 、转化 、输出？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#onResolve-%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">onResolve 的示例</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"获取开发大概时间","uid":"f294c5e88fbdfee2c3ec39e3af3f094c","slug":"2023-07-04git-py","date":"2023-07-04T00:36:43.000Z","updated":"2023-07-20T14:58:47.209Z","comments":true,"path":"api/articles/2023-07-04git-py.json","keywords":null,"cover":[],"text":"背景赚点小钱，看看划不划算，作为以后评估工作量的参考 脚本import subprocess from datetime import datetime def get_user_commits(username): git_log &#x3D; subprocess.check...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"chrome编辑完代码同步","uid":"05790e6bbac5752b4d540adbd8fcf137","slug":"2023-06-30chrome","date":"2023-06-30T01:44:47.000Z","updated":"2023-07-08T01:06:25.365Z","comments":true,"path":"api/articles/2023-06-30chrome.json","keywords":null,"cover":[],"text":"动机调试完代码直接保存到本地，避免 CV 操作 编辑完代码保存提示 Changes to this file were not saved to file system. 授权 workspace 授权后的配置 再次保存 ","link":"","photos":[],"count_time":{"symbolsCount":114,"symbolsTime":"1 mins."},"categories":[{"name":"Chrome","slug":"Chrome","count":2,"path":"api/categories/Chrome.json"}],"tags":[{"name":"Chrome","slug":"Chrome","count":3,"path":"api/tags/Chrome.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}