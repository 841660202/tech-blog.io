{"title":"前端基础-设计模式","uid":"21c81236c6b792525b47c142ae6ad187","slug":"2022-10-27设计模式","date":"2022-10-27T05:59:49.000Z","updated":"2023-02-20T21:20:56.478Z","comments":true,"path":"api/articles/2022-10-27设计模式.json","keywords":null,"cover":null,"content":"<h2 id=\"旧文章链接\"><a href=\"#旧文章链接\" class=\"headerlink\" title=\"旧文章链接\"></a>旧文章链接</h2><p><a href=\"post/2022-07-18设计模式\" target=\"_blank\" >post&#x2F;2022-07-18 设计模式</a></p>\n<h2 id=\"《JavaScript-设计模式与开发实践》\"><a href=\"#《JavaScript-设计模式与开发实践》\" class=\"headerlink\" title=\"《JavaScript 设计模式与开发实践》\"></a>《JavaScript 设计模式与开发实践》</h2><h3 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用</p>\n<p>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性</p>\n<h3 id=\"为什么要学习设计模式\"><a href=\"#为什么要学习设计模式\" class=\"headerlink\" title=\"为什么要学习设计模式\"></a>为什么要学习设计模式</h3><p>学习设计模式，有助于写出<code>可复用和可维护性高</code>的程序</p>\n<h3 id=\"设计模式原则\"><a href=\"#设计模式原则\" class=\"headerlink\" title=\"设计模式原则\"></a>设计模式原则</h3><p>设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构</p>\n<h2 id=\"创建型模式-5\"><a href=\"#创建型模式-5\" class=\"headerlink\" title=\"创建型模式 5\"></a>创建型模式 5</h2><h3 id=\"一、工厂模式\"><a href=\"#一、工厂模式\" class=\"headerlink\" title=\"一、工厂模式\"></a>一、工厂模式</h3><ul>\n<li><p>工厂模式：将创建对象的过程单独封装</p>\n</li>\n<li><p>使用场景：有构造函数的地方、写了大量构造函数、调用了大量的 new 的情况下</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/93291550\" target=\"_blank\" >见</a></p>\n</li>\n</ul>\n<h3 id=\"二、抽象工厂模式\"><a href=\"#二、抽象工厂模式\" class=\"headerlink\" title=\"二、抽象工厂模式\"></a>二、抽象工厂模式</h3><h4 id=\"工厂模式与抽象工厂模式区别\"><a href=\"#工厂模式与抽象工厂模式区别\" class=\"headerlink\" title=\"工厂模式与抽象工厂模式区别\"></a>工厂模式与抽象工厂模式区别</h4><p>抽象工厂（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性<br>具体工厂（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/93416391\" target=\"_blank\" >见</a></p>\n<h3 id=\"三、单例模式\"><a href=\"#三、单例模式\" class=\"headerlink\" title=\"三、单例模式\"></a>三、单例模式</h3><ul>\n<li><em>定义：</em>保证一个类仅有一个实例，并提供一个访问它的全局访问点</li>\n<li><em>核心：</em>确保只有一个实例，并提供全局访问</li>\n<li>实现单例的方式：<code>单例函数</code>, <code>类的构造方法</code> ,<code>类的静态方法</code></li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 提取出通用的单例\nfunction getSingleton(fn) &#123;\n  var instance &#x3D; null;\n\n  return function () &#123;\n    if (!instance) &#123;\n      instance &#x3D; fn.apply(this, arguments);\n    &#125;\n\n    return instance;\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 通过构造函数\nclass Singleton &#123;\n  &#x2F;&#x2F; static instance; 加不加都可，类中可以直接赋值和获取静态属性\n  constructor() &#123;\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this; &#x2F;&#x2F; this，是新创建的对象，new关键字原理中，this指向new出的对象\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n&#x2F;&#x2F;  通过静态方法\nclass Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<p><a href=\"/#/post/2022-09-19qa\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2022-09-19qa</a></p>\n<h3 id=\"四、建造者模式\"><a href=\"#四、建造者模式\" class=\"headerlink\" title=\"四、建造者模式\"></a>四、建造者模式</h3><h3 id=\"五、原型模式\"><a href=\"#五、原型模式\" class=\"headerlink\" title=\"五、原型模式\"></a>五、原型模式</h3><p><a href=\"https://zhuanlan.zhihu.com/p/94104346\" target=\"_blank\" >见</a> <a href=\"https://www.runoob.com/design-pattern/prototype-pattern.html\" target=\"_blank\" >见</a></p>\n<ul>\n<li>为什么出现：直接创建对象代价较大，所以采用这种模式</li>\n<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 - <code>对象会记住它的原型</code>。</li>\n<li>原型模式是用于创建对象的一种模式。我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象</li>\n<li>注意：使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据&#x2F;方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的</li>\n<li>JavaScript <code>本身是一门基于原型的面向对象语言</code>，<code>Object.create</code> 方法就是原型模式的天然实现—––准确地说，只要我们还在借助 Prototype 来实现对象的创建和原型的继承，那么我们就是在应用原型模式</li>\n<li>当对象 a 需 要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的 效果，<code>Object.create</code>的原理体现</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var obj &#x3D; &#123; name: &quot;zyy&quot; &#125;;\n\nvar A &#x3D; function () &#123;&#125;;\nA.prototype &#x3D; obj;\n\nvar a &#x3D; new A();\n\n&#x2F;&#x2F;a.name &#x3D; zyy\n\n&#x2F;&#x2F; 执行这段代码的时候，引擎做的事：\n\n&#x2F;&#x2F; 1. 尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。\n\n&#x2F;&#x2F; 2. 查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.proto 记录着并且指向 A.prototype，而 A.prototype 被设置为对象 obj。\n\n&#x2F;&#x2F; 3. 在对象 obj 中找到了 name 属性，并返回它的值。\n\n&#x2F;&#x2F; 提问自测\n\n&#x2F;&#x2F; 1、为什么说 ES6 的 Class 只是语法糖\n\n&#x2F;&#x2F; 起源上说，JavaScript是基于原型的面向对象系统。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来， 一个对象是通过克隆另外一个对象所得到的。\n\n&#x2F;&#x2F; ES6的 Class 语法,让 JavaScript 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。\n\n&#x2F;&#x2F; 2、上面使用了new A() ，所以A属于类吗？\n\n&#x2F;&#x2F; 在这里 A 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。\n\n&#x2F;&#x2F; 3、存在没有原型的对象吗？\n\n&#x2F;&#x2F; 通过设置构造器的 prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个 原型。而通过 Object.create( null )可以创建出没有原型的对象。</code></pre>\n\n<h2 id=\"结构型模式-8\"><a href=\"#结构型模式-8\" class=\"headerlink\" title=\"结构型模式 8\"></a>结构型模式 8</h2><h3 id=\"适配器模式-“包装模式”\"><a href=\"#适配器模式-“包装模式”\" class=\"headerlink\" title=\"适配器模式 “包装模式”\"></a>适配器模式 “包装模式”</h3><p>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够 使它们协同作用。</p>\n<p>个人总结场景：之前一种设计，后来想到了一种更好的设计，要让现在的兼容之前的，并且只保留一份同等功能的代码，就需要在两种设计之间增加适配器</p>\n<p><a href=\"https://juejin.cn/post/6962470884527308836\" target=\"_blank\" >javascript 设计模式之适配器模式</a></p>\n<h3 id=\"装饰器模式-“包装模式”\"><a href=\"#装饰器模式-“包装模式”\" class=\"headerlink\" title=\"装饰器模式 “包装模式”\"></a>装饰器模式 “包装模式”</h3><ul>\n<li>解决问题：继承会破坏封装性，装饰器模式，比起继承，更具有封装型</li>\n<li>ES7 中的 decorator 同样借鉴了这个语法糖，不过依赖于 ES5 的 Object.defineProperty 方法</li>\n<li>装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给对象动态地增加职责的方式称为装 饰器(decorator)模式。装饰器模式能够在不改 变对象自身的基础上，在程序运行期间给对象 动态地添加职责。</p></blockquote>\n<p>ES7 为我们提供了语法糖可以给一个类装上装饰器，继续改造上面的代码</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 装饰器函数，它的第一个参数是目标类\nfunction Decorator(target) &#123;\n    target.control &#x3D; function() &#123;\n        console.log(&#39;我是新的逻辑&#39;)\n    &#125;\n    return target\n&#125;\n\n\n&#x2F;&#x2F; 将装饰器“安装” 到HorribleCode上\n@Decorator\nclass HorribleCode () &#123;\n    &#x2F;&#x2F;老代码逻辑\n&#125;\n\n\nHorribleCode.control()</code></pre>\n\n<h3 id=\"过滤器模式-x2F-标准模式-x2F-挑三拣四\"><a href=\"#过滤器模式-x2F-标准模式-x2F-挑三拣四\" class=\"headerlink\" title=\"过滤器模式&#x2F;标准模式&#x2F;挑三拣四\"></a>过滤器模式&#x2F;标准模式&#x2F;挑三拣四</h3><p>目的：使用不同标准来过滤一组对象<br>实现：制定不同的规则来实现过滤，然后对过滤结果进行分组<br><a href=\"https://cloud.tencent.com/developer/article/1663903\" target=\"_blank\" >见</a></p>\n<h3 id=\"代理模式-“包装模式”\"><a href=\"#代理模式-“包装模式”\" class=\"headerlink\" title=\"代理模式 “包装模式”\"></a>代理模式 “包装模式”</h3><ul>\n<li>作用：实现访问主体的控制，简单来说就是增加了一层，进行访问控制</li>\n<li>三种：<code>保护代理</code>,<code>虚拟代理</code>,<code>缓存代理</code></li>\n</ul>\n<h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><p>抽象部分与实现部分的分离，使得二者可以独立的变化，而不必拘泥于形式</p>\n<p>在封装开源库的组件时候，经常会用到这种设计模式。</p>\n<p>例如，对外提供暴露一个 complete 函数,<br>如果用户有传入此函数, 那么就会在某一段代码逻辑中调用。</p>\n<p>这个过程中，组件起到了“桥”的作用，而具体实现是用户自定义。</p>\n<p>JavaScript 中桥接模式的典型应用是：Array 对象上的 forEach 函数。</p>\n<p>使用场景：</p>\n<ol>\n<li>最简单模拟 forEach 方法：</li>\n<li>桥接模式在事件监听中的应用 <code>elem.addEventListener(&#39;click&#39;, getBeerByIdBridge, false);</code></li>\n<li>桥接模式用于组件开发</li>\n</ol>\n<p>作者：Sky 飞羽<br>链接：<a href=\"https://www.jianshu.com/p/ceb82afe828d\">https://www.jianshu.com/p/ceb82afe828d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><ul>\n<li>一种用于性能优化的模式，它的目标是尽量减少共享对象的数量</li>\n<li>内部共享，外部剥离(能够共用的封装在能不，不能够共用的封装在外部)</li>\n</ul>\n<p><a href=\"https://www.yisu.com/zixun/186653.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"外观模式（模块化开发）\"><a href=\"#外观模式（模块化开发）\" class=\"headerlink\" title=\"外观模式（模块化开发）\"></a>外观模式（模块化开发）</h3><ul>\n<li>增加一层，让从外部看来，像是一个（一致对外）</li>\n<li>使用：模块汇总后统一导出</li>\n</ul>\n<p><a href=\"https://segmentfault.com/a/1190000014132789\" target=\"_blank\" >见</a></p>\n<h3 id=\"组合模式-x2F-部分整体模式\"><a href=\"#组合模式-x2F-部分整体模式\" class=\"headerlink\" title=\"组合模式&#x2F;部分整体模式\"></a>组合模式&#x2F;部分整体模式</h3><ul>\n<li>用相同的方式处理一组相似对象 例如： 文件目录显示，多级目录呈现等树形结构数据的操作</li>\n</ul>\n<p><a href=\"https://segmentfault.com/a/1190000019773556\" target=\"_blank\" >见</a></p>\n<h2 id=\"行为型模式-10-CF-MD-ZB-MZ\"><a href=\"#行为型模式-10-CF-MD-ZB-MZ\" class=\"headerlink\" title=\"行为型模式 10 CF MD ZB MZ\"></a>行为型模式 10 CF MD ZB MZ</h2><h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><ul>\n<li>策略模式的出现是为了解决多重判断的问题</li>\n<li>组成：组策略，组策略的实现</li>\n<li>可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护</li>\n</ul>\n<p>使用场景：<code>规则校验</code>,<code>权限操作</code></p>\n<h3 id=\"观察者模式-x2F-发布订阅模式\"><a href=\"#观察者模式-x2F-发布订阅模式\" class=\"headerlink\" title=\"观察者模式&#x2F;发布订阅模式\"></a>观察者模式&#x2F;发布订阅模式</h3><ul>\n<li>也叫观察者模式</li>\n<li>解耦：1. 时间上的解耦，2. 为对象之间的解耦</li>\n</ul>\n<h3 id=\"模板模式\"><a href=\"#模板模式\" class=\"headerlink\" title=\"模板模式\"></a>模板模式</h3><ul>\n<li>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。</li>\n<li>简单理解为：规划好了蓝图，照着蓝图去具体实现</li>\n</ul>\n<h3 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h3><ul>\n<li>在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素</li>\n<li>在 javascript 中，实现了<code>[Symbol.iterator]属性的类数组，返回一个函数，就可以使用迭代器</code></li>\n</ul>\n<p><a href=\"https://zhuanlan.zhihu.com/p/97025000\" target=\"_blank\" >JavaScript 设计模式（九）-迭代器模式</a><br><a href=\"https://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" >Iterator 和 for…of 循环</a></p>\n<h3 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h3><ul>\n<li>为请求创建了一个接收者对象的链。多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。</li>\n<li>这些对象连接成为“链式结构”，每个节点转发请求，直到有对象处理请求为止</li>\n<li>使用场景：不同日志输出&#x2F;记录</li>\n<li>区别于过滤模式，过滤是满足就执行，责任链模式：满足执行并终止</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/53b0e70f6cd2\" target=\"_blank\" >见</a></p>\n<h3 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h3><ul>\n<li>保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</li>\n<li>历史记录这玩意就是备忘录模式</li>\n</ul>\n<h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><ul>\n<li>用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系</li>\n</ul>\n<h3 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h3><ul>\n<li>中介者模式的作用：就是解除对象与对象之间的紧耦合关系。</li>\n<li>增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可</li>\n<li>如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</li>\n</ul>\n<p><a href=\"https://juejin.cn/post/6844903848155283463\" target=\"_blank\" >见</a></p>\n<h3 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h3><ul>\n<li>意图：主要将数据结构与数据操作分离。</li>\n<li>主要解决：稳定的数据结构和易变的操作耦合问题。</li>\n<li>何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中<br><a href=\"https://www.runoob.com/design-pattern/visitor-pattern.html\" target=\"_blank\" >菜鸟教程-设计模式-访问者模式</a><br><a href=\"https://juejin.cn/post/7012599751527006239\" target=\"_blank\" >见</a></li>\n</ul>\n<h3 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h3><ul>\n<li>发布—订阅模式的优点： 时间上的解耦，对象之间的解耦</li>\n<li>避免了 Context 无限膨胀，状态切换的逻辑分布在状态类中，也避免了大量的 if-else 语句。</li>\n<li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</li>\n<li>Context 中的请求动作和状态类中封装的行为相互独立切互不影响，也使得修改更加容易。</li>\n</ul>\n<p>实现方式：</p>\n<ol>\n<li>类似 java 中一个 State 抽象类，其他状态类继承并重写其方法，实现自己的状态类方法</li>\n<li>JavaScript 可以非常方便利用委托技术， 通过 Function.prototype.call 方法直接把请求委托给某个对象字面来执行</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/6844903862013280269#heading-7\" target=\"_blank\" >JavaScript 版本的状态机</a></p>\n<h3 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h3><ul>\n<li>这个比较难理解</li>\n</ul>\n<h3 id=\"空对象模式\"><a href=\"#空对象模式\" class=\"headerlink\" title=\"空对象模式\"></a>空对象模式</h3><p>未对该类做任何实现的空对象类</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><h3 id=\"创建型模式-原建工抽单\"><a href=\"#创建型模式-原建工抽单\" class=\"headerlink\" title=\"创建型模式 原建工抽单\"></a>创建型模式 原建工抽单</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 原型模式、建造者模式、工厂模式、抽象工厂模式、单例模式、\n&#x2F;&#x2F; 记忆口诀：原建工抽单（原来建工立业的人要抽单【交税】）</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">简</th>\n<th>原</th>\n<th>建</th>\n<th>工</th>\n<th>抽</th>\n<th>单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">全</td>\n<td>原型模式</td>\n<td>建造者模式</td>\n<td>工厂模式</td>\n<td>抽象工厂模式</td>\n<td>单例模式</td>\n</tr>\n</tbody></table>\n<h3 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 享元模式、桥接模式、外观模式、适配器模式、组合模式、装饰者模式、代理模式、\n&#x2F;&#x2F; 记忆口诀（7）：享桥外适组装代【想桥外试、租装戴】</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">简</th>\n<th>享</th>\n<th>桥</th>\n<th>外</th>\n<th>适</th>\n<th>组</th>\n<th>装</th>\n<th>代</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">全</td>\n<td>享元模式</td>\n<td>桥接模式</td>\n<td>外观模式</td>\n<td>适配器模式</td>\n<td>组合模式</td>\n<td>装饰者模式</td>\n<td>代理模式</td>\n</tr>\n</tbody></table>\n<h3 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式\n&#x2F;&#x2F; 记忆口诀（11）：观察者、访问者、中介者；命令、解释、模版、状态；策略、责任、迭代、备忘</code></pre>\n\n<h2 id=\"记忆口诀\"><a href=\"#记忆口诀\" class=\"headerlink\" title=\"记忆口诀\"></a>记忆口诀</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）\n</code></pre>\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ul>\n<li>中间件是什么设计模式？（1. 中间人？不像 2. 过滤器？像又不像 3.代理模式，像又不像）</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.runoob.com/design-pattern/design-pattern-intro.html\" target=\"_blank\" >设计模式简介</a></p>\n","text":"旧文章链接post&#x2F;2022-07-18 设计模式 《JavaScript 设计模式与开发实践》什么是设计模式设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用 使用设计模式是为了重用代码、让代码更容易被他人理解、保证代...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A7%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">旧文章链接</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E3%80%8AJavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E3%80%8B\"><span class=\"toc-text\">《JavaScript 设计模式与开发实践》</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">什么是设计模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">为什么要学习设计模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">设计模式原则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5\"><span class=\"toc-text\">创建型模式 5</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">一、工厂模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">二、抽象工厂模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">工厂模式与抽象工厂模式区别</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">三、单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">四、建造者模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">五、原型模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-8\"><span class=\"toc-text\">结构型模式 8</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E2%80%9C%E5%8C%85%E8%A3%85%E6%A8%A1%E5%BC%8F%E2%80%9D\"><span class=\"toc-text\">适配器模式 “包装模式”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-%E2%80%9C%E5%8C%85%E8%A3%85%E6%A8%A1%E5%BC%8F%E2%80%9D\"><span class=\"toc-text\">装饰器模式 “包装模式”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F-x2F-%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F-x2F-%E6%8C%91%E4%B8%89%E6%8B%A3%E5%9B%9B\"><span class=\"toc-text\">过滤器模式&#x2F;标准模式&#x2F;挑三拣四</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E2%80%9C%E5%8C%85%E8%A3%85%E6%A8%A1%E5%BC%8F%E2%80%9D\"><span class=\"toc-text\">代理模式 “包装模式”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">桥接模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">享元模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%89\"><span class=\"toc-text\">外观模式（模块化开发）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-x2F-%E9%83%A8%E5%88%86%E6%95%B4%E4%BD%93%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">组合模式&#x2F;部分整体模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-10-CF-MD-ZB-MZ\"><span class=\"toc-text\">行为型模式 10 CF MD ZB MZ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">策略模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-x2F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">观察者模式&#x2F;发布订阅模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">模板模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">迭代器模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">责任链模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">备忘录模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">命令模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">中介者模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">访问者模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">状态模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">解释器模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">空对象模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%BB%BA%E5%B7%A5%E6%8A%BD%E5%8D%95\"><span class=\"toc-text\">创建型模式 原建工抽单</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">结构型模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">行为型模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BF%86%E5%8F%A3%E8%AF%80\"><span class=\"toc-text\">记忆口诀</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-移动端适配","uid":"ae7214e6b6b6dc80cfe5f43a5613e628","slug":"2022-10-28移动适配","date":"2022-10-28T02:03:07.000Z","updated":"2023-02-20T21:20:56.479Z","comments":true,"path":"api/articles/2022-10-28移动适配.json","keywords":null,"cover":null,"text":"网易精品课移动端适配方案 小红书网页代码&lt;script&gt; function setPixel() &#123; var e &#x3D; parseFloat( window .getComputedStyle(document.documentElement, nu...","link":"","photos":[],"count_time":{"symbolsCount":877,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"css theme","uid":"03a0cd201b7e39fe38e7f2e815b3009b","slug":"2022-10-26theme","date":"2022-10-26T07:58:01.000Z","updated":"2022-11-01T12:57:51.477Z","comments":true,"path":"api/articles/2022-10-26theme.json","keywords":null,"cover":[],"text":"mdn 主题切换 light&#x2F;dark&#x2F;os-default_theme.scss&#x2F;&#x2F; _theme.scss @use &quot;sass:color&quot;; @use &quot;..&#x2F;vars.scss&quot; ...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"27 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}