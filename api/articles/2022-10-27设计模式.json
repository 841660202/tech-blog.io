{"title":"前端基础-设计模式","uid":"21c81236c6b792525b47c142ae6ad187","slug":"2022-10-27设计模式","date":"2022-10-27T05:59:49.000Z","updated":"2023-08-04T00:41:46.581Z","comments":true,"path":"api/articles/2022-10-27设计模式.json","keywords":null,"cover":null,"content":"<h1 id=\"旧文章链接\"><a href=\"#旧文章链接\" class=\"headerlink\" title=\"旧文章链接\"></a>旧文章链接</h1><p><a href=\"post/2022-07-18设计模式\" target=\"_blank\" >post&#x2F;2022-07-18 设计模式</a></p>\n<h1 id=\"《JavaScript-设计模式与开发实践》\"><a href=\"#《JavaScript-设计模式与开发实践》\" class=\"headerlink\" title=\"《JavaScript 设计模式与开发实践》\"></a>《JavaScript 设计模式与开发实践》</h1><h1 id=\"chatGPT\"><a href=\"#chatGPT\" class=\"headerlink\" title=\"chatGPT\"></a>chatGPT</h1><h2 id=\"误区：为何使用设计模式后，会感觉将代码复杂化了\"><a href=\"#误区：为何使用设计模式后，会感觉将代码复杂化了\" class=\"headerlink\" title=\"误区：为何使用设计模式后，会感觉将代码复杂化了\"></a>误区：为何使用设计模式后，会感觉将代码复杂化了</h2><p>使用设计模式是为了提高代码的<code>可维护性</code>、<code>可扩展性</code>、<code>可读性</code>、<code>可测试性</code>等方面的优点，但这并不代表使用设计模式后代码一定会变得简单。</p>\n<p>设计模式的使用通常需要引入额外的类和对象，从而增加代码的复杂度。另外，设计模式并不是万能的，不同的场景需要选择不同的设计模式，正确地选择和应用设计模式也需要一定的经验和技巧。</p>\n<p>因此，在使用设计模式时需要权衡利弊，根据实际情况选择合适的设计模式，以提高代码的质量和可维护性。</p>\n<h2 id=\"JavaScript-设计模式\"><a href=\"#JavaScript-设计模式\" class=\"headerlink\" title=\"JavaScript 设计模式\"></a>JavaScript 设计模式</h2><p>JavaScript 设计模式是<strong>一种解决软件设计问题的通用方法，这些问题可能涉及代码复杂性、可维护性、可扩展性等等</strong>。下面是一些常见的 JavaScript 设计模式：</p>\n<ol>\n<li>工厂模式（Factory Pattern）：用于创建对象的模式，通过调用工厂方法或者构造函数来创建对象。</li>\n<li>单例模式（Singleton Pattern）：确保一个类只有一个实例，提供一个全局访问点。</li>\n<li>原型模式（Prototype Pattern）：用于创建对象的一种模式，通过复制一个已经存在的对象来创建新的对象。</li>\n<li>观察者模式（Observer Pattern）：定义了对象之间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知。</li>\n<li>订阅发布模式（Publish-Subscribe Pattern）：类似于观察者模式，但是不同的是，订阅者需要明确地向发布者订阅通知，而不是被动地接收通知。</li>\n<li>装饰者模式（Decorator Pattern）：允许向一个现有的对象添加新的功能，同时又不改变其结构。</li>\n<li>策略模式（Strategy Pattern）：定义了一系列算法，将每个算法封装起来，并使它们可以相互替换，使得算法可以独立于使用它的客户而变化。</li>\n<li>代理模式（Proxy Pattern）：提供了一个代理对象来控制对另一个对象的访问，可以用于实现延迟加载、权限控制等功能。</li>\n</ol>\n<p>这些模式是设计模式中最常见的几种，但是并不是全部。在实际应用中，可能会涉及到更多的模式。</p>\n<h2 id=\"js-工厂模式\"><a href=\"#js-工厂模式\" class=\"headerlink\" title=\"js 工厂模式\"></a>js 工厂模式</h2><p>工厂模式（Factory Pattern）是一种创建对象的设计模式，它提供了一种通过调用工厂方法或者构造函数来创建对象的方式，而不需要在代码中直接实例化对象。</p>\n<p>工厂模式的主要思想是将对象的创建过程抽象出来，将其封装在一个工厂类中。这个工厂类负责根据不同的条件来创建不同的对象，而客户端代码只需要通过调用工厂类的方法来获得所需要的对象，而不需要关心对象的创建过程。</p>\n<p>工厂模式的优点是可以将对象的创建过程与客户端代码分离开来，这样可以降低代码的耦合度，使代码更易于维护和扩展。另外，工厂模式还可以隐藏对象的实现细节，提高代码的安全性。</p>\n<p>常见的工厂模式包括<code>简单工厂模式</code>、<code>工厂方法模式</code>和<code>抽象工厂模式</code>。其中，</p>\n<ul>\n<li><code>简单工厂模式</code>是最基础的工厂模式，它通过一个工厂类来创建所有需要的对象，客户端只需要传递相应的参数即可；</li>\n<li><code>工厂方法模式</code>将对象的创建过程交给不同的子工厂来完成，每个子工厂负责创建一类对象；</li>\n<li><code>抽象工厂模式</code>则是针对不同产品族的对象进行创建，每个工厂可以创建一组相互依赖的对象。</li>\n</ul>\n<h3 id=\"js-简单工厂模式-代码示例\"><a href=\"#js-简单工厂模式-代码示例\" class=\"headerlink\" title=\"js 简单工厂模式 代码示例\"></a>js 简单工厂模式 代码示例</h3><p>以下是一个简单的 JavaScript 工厂模式的代码示例，用于创建不同类型的汽车对象：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个 Car 工厂类\nclass CarFactory &#123;\n  createCar(type) &#123;\n    let car;\n    switch (type) &#123;\n      case &#39;suv&#39;:\n        car &#x3D; new SuvCar();\n        break;\n      case &#39;sedan&#39;:\n        car &#x3D; new SedanCar();\n        break;\n      case &#39;hatchback&#39;:\n        car &#x3D; new HatchbackCar();\n        break;\n      default:\n        throw new Error(&#96;Invalid car type: $&#123;type&#125;&#96;);\n    &#125;\n    return car;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义不同类型的汽车类\nclass SuvCar &#123;\n  constructor() &#123;\n    this.type &#x3D; &#39;SUV&#39;;\n    this.price &#x3D; 30000;\n  &#125;\n&#125;\n\nclass SedanCar &#123;\n  constructor() &#123;\n    this.type &#x3D; &#39;Sedan&#39;;\n    this.price &#x3D; 25000;\n  &#125;\n&#125;\n\nclass HatchbackCar &#123;\n  constructor() &#123;\n    this.type &#x3D; &#39;Hatchback&#39;;\n    this.price &#x3D; 20000;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用 Car 工厂类创建不同类型的汽车对象\nconst carFactory &#x3D; new CarFactory();\nconst suvCar &#x3D; carFactory.createCar(&#39;suv&#39;);\nconst sedanCar &#x3D; carFactory.createCar(&#39;sedan&#39;);\nconst hatchbackCar &#x3D; carFactory.createCar(&#39;hatchback&#39;);\n\nconsole.log(suvCar); &#x2F;&#x2F; SuvCar &#123; type: &#39;SUV&#39;, price: 30000 &#125;\nconsole.log(sedanCar); &#x2F;&#x2F; SedanCar &#123; type: &#39;Sedan&#39;, price: 25000 &#125;\nconsole.log(hatchbackCar); &#x2F;&#x2F; HatchbackCar &#123; type: &#39;Hatchback&#39;, price: 20000 &#125;</code></pre>\n\n<p>在这个例子中，CarFactory 是一个工厂类，它提供了一个 createCar 方法，根据传入的参数来创建不同类型的汽车对象。SuvCar、SedanCar 和 HatchbackCar 是不同类型的汽车类，它们的构造函数分别设置了 type 和 price 属性。客户端代码只需要通过 CarFactory 类的 createCar 方法来获得所需要的汽车对象，而不需要关心具体的对象创建过程。</p>\n<h3 id=\"js-方法工厂代码示例\"><a href=\"#js-方法工厂代码示例\" class=\"headerlink\" title=\"js 方法工厂代码示例\"></a>js 方法工厂代码示例</h3><p>以下是一个简单的 JavaScript 方法工厂模式的代码示例，用于创建不同类型的运算方法：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个方法工厂类\nclass OperationFactory &#123;\n  static createOperation(operator) &#123;\n    switch (operator) &#123;\n      case &#39;+&#39;:\n        return new AddOperation();\n      case &#39;-&#39;:\n        return new SubtractOperation();\n      case &#39;*&#39;:\n        return new MultiplyOperation();\n      case &#39;&#x2F;&#39;:\n        return new DivideOperation();\n      default:\n        throw new Error(&#39;Unsupported operator!&#39;);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义不同类型的运算方法类\nclass AddOperation &#123;\n  operate(num1, num2) &#123;\n    return num1 + num2;\n  &#125;\n&#125;\n\nclass SubtractOperation &#123;\n  operate(num1, num2) &#123;\n    return num1 - num2;\n  &#125;\n&#125;\n\nclass MultiplyOperation &#123;\n  operate(num1, num2) &#123;\n    return num1 * num2;\n  &#125;\n&#125;\n\nclass DivideOperation &#123;\n  operate(num1, num2) &#123;\n    if (num2 &#x3D;&#x3D;&#x3D; 0) &#123;\n      throw new Error(&#39;Divisor can not be 0!&#39;);\n    &#125;\n    return num1 &#x2F; num2;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用方法工厂类创建不同类型的运算方法对象\nconst add &#x3D; OperationFactory.createOperation(&#39;+&#39;);\nconst subtract &#x3D; OperationFactory.createOperation(&#39;-&#39;);\nconst multiply &#x3D; OperationFactory.createOperation(&#39;*&#39;);\nconst divide &#x3D; OperationFactory.createOperation(&#39;&#x2F;&#39;);\n\nconsole.log(add.operate(1, 2)); &#x2F;&#x2F; 3\nconsole.log(subtract.operate(5, 3)); &#x2F;&#x2F; 2\nconsole.log(multiply.operate(2, 3)); &#x2F;&#x2F; 6\nconsole.log(divide.operate(10, 2)); &#x2F;&#x2F; 5</code></pre>\n\n<p>在这个例子中，OperationFactory 是一个方法工厂类，它定义了一个静态方法 createOperation，根据传入的 operator 参数来创建不同类型的运算方法对象。AddOperation、SubtractOperation、MultiplyOperation 和 DivideOperation 是具体的运算方法类，它们的 operate 方法分别实现了加法、减法、乘法和除法运算。客户端代码只需要通过方法工厂类来创建所需要的运算方法对象，而不需要关心具体的对象创建过程。</p>\n<h3 id=\"js-抽象工厂代码示例\"><a href=\"#js-抽象工厂代码示例\" class=\"headerlink\" title=\"js 抽象工厂代码示例\"></a>js 抽象工厂代码示例</h3><p>以下是一个简单的 JavaScript 抽象工厂模式的代码示例，用于创建不同类型的电子产品：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个抽象工厂类\nclass ElectronicFactory &#123;\n  createPhone() &#123;&#125;\n  createComputer() &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个具体的工厂类，用于创建华为品牌的电子产品\nclass HuaweiFactory extends ElectronicFactory &#123;\n  createPhone() &#123;\n    return new HuaweiPhone();\n  &#125;\n  createComputer() &#123;\n    return new HuaweiComputer();\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个具体的工厂类，用于创建苹果品牌的电子产品\nclass AppleFactory extends ElectronicFactory &#123;\n  createPhone() &#123;\n    return new iPhone();\n  &#125;\n  createComputer() &#123;\n    return new MacBook();\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义不同类型的电子产品类\nclass HuaweiPhone &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Huawei&#39;;\n    this.type &#x3D; &#39;Phone&#39;;\n    this.price &#x3D; 5000;\n  &#125;\n&#125;\n\nclass HuaweiComputer &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Huawei&#39;;\n    this.type &#x3D; &#39;Computer&#39;;\n    this.price &#x3D; 8000;\n  &#125;\n&#125;\n\nclass iPhone &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Apple&#39;;\n    this.type &#x3D; &#39;Phone&#39;;\n    this.price &#x3D; 8000;\n  &#125;\n&#125;\n\nclass MacBook &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Apple&#39;;\n    this.type &#x3D; &#39;Computer&#39;;\n    this.price &#x3D; 12000;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用抽象工厂类创建不同品牌的电子产品对象\nconst huaweiFactory &#x3D; new HuaweiFactory();\nconst appleFactory &#x3D; new AppleFactory();\n\nconst huaweiPhone &#x3D; huaweiFactory.createPhone();\nconst huaweiComputer &#x3D; huaweiFactory.createComputer();\nconst iPhone &#x3D; appleFactory.createPhone();\nconst macBook &#x3D; appleFactory.createComputer();\n\nconsole.log(huaweiPhone); &#x2F;&#x2F; HuaweiPhone &#123; brand: &#39;Huawei&#39;, type: &#39;Phone&#39;, price: 5000 &#125;\nconsole.log(huaweiComputer); &#x2F;&#x2F; HuaweiComputer &#123; brand: &#39;Huawei&#39;, type: &#39;Computer&#39;, price: 8000 &#125;\nconsole.log(iPhone); &#x2F;&#x2F; iPhone &#123; brand: &#39;Apple&#39;, type: &#39;Phone&#39;, price: 8000 &#125;\nconsole.log(macBook); &#x2F;&#x2F; MacBook &#123; brand: &#39;Apple&#39;, type: &#39;Computer&#39;, price: 12000 &#125;</code></pre>\n\n<p>在这个例子中，ElectronicFactory 是一个抽象工厂类，它定义了两个抽象方法 createPhone 和 createComputer，用于创建不同类型的电子产品。HuaweiFactory 和 AppleFactory 是具体的工厂类，它们分别继承了 ElectronicFactory 类，并实现了这两个抽象方法来创建不同品牌的电子产品。HuaweiPhone、HuaweiComputer、iPhone 和 MacBook 是具体的电子产品类，它们的构造函数分别设置了 brand、type 和 price 属性。客户端代码只需要通过具体的工厂类来创建所需要的电子产品对象，而不需要关心具体的对象创建过程。</p>\n<h2 id=\"js-单例模式\"><a href=\"#js-单例模式\" class=\"headerlink\" title=\"js 单例模式\"></a>js 单例模式</h2><h3 id=\"构造函数实现单例模式\"><a href=\"#构造函数实现单例模式\" class=\"headerlink\" title=\"构造函数实现单例模式\"></a>构造函数实现单例模式</h3><p>以下是一个简单的 JavaScript 单例模式的代码示例，用于创建唯一的日志记录器对象：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个日志记录器类\nclass Logger &#123;\n  constructor() &#123;\n    if (Logger.instance) &#123;\n      return Logger.instance;\n    &#125;\n\n    this.logs &#x3D; [];\n    Logger.instance &#x3D; this;\n  &#125;\n\n  log(message) &#123;\n    this.logs.push(message);\n    console.log(&#96;[INFO] $&#123;message&#125;&#96;);\n  &#125;\n\n  printLogs() &#123;\n    console.log(&#39;Logs:&#39;);\n    this.logs.forEach((log) &#x3D;&gt; console.log(log));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用单例模式创建日志记录器对象\nconst logger1 &#x3D; new Logger();\nconst logger2 &#x3D; new Logger();\n\nlogger1.log(&#39;Message 1&#39;);\nlogger2.log(&#39;Message 2&#39;);\n\nlogger1.printLogs();\nlogger2.printLogs();</code></pre>\n\n<p>在这个例子中，Logger 是一个日志记录器类，它使用单例模式来保证只创建一个日志记录器对象。在 Logger 的构造函数中，如果已经存在 Logger 的实例对象，那么就直接返回该实例对象，否则就创建一个新的实例对象。同时，也使用静态属性 Logger.instance 来存储日志记录器的唯一实例对象。客户端代码只需要创建日志记录器对象，并调用其 log 和 printLogs 方法来记录和输出日志，而不需要关心实例对象的创建和管理。</p>\n<h3 id=\"静态方法实现单例模式\"><a href=\"#静态方法实现单例模式\" class=\"headerlink\" title=\"静态方法实现单例模式\"></a>静态方法实现单例模式</h3><p>以下是使用静态方法实现的 JavaScript 单例模式的代码示例，仍然用于创建唯一的日志记录器对象：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个日志记录器类\nclass Logger &#123;\n  constructor() &#123;\n    this.logs &#x3D; [];\n  &#125;\n\n  log(message) &#123;\n    this.logs.push(message);\n    console.log(&#96;[INFO] $&#123;message&#125;&#96;);\n  &#125;\n\n  printLogs() &#123;\n    console.log(&#39;Logs:&#39;);\n    this.logs.forEach((log) &#x3D;&gt; console.log(log));\n  &#125;\n\n  static getInstance() &#123;\n    if (!Logger.instance) &#123;\n      Logger.instance &#x3D; new Logger();\n    &#125;\n\n    return Logger.instance;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用单例模式创建日志记录器对象\nconst logger1 &#x3D; Logger.getInstance();\nconst logger2 &#x3D; Logger.getInstance();\n\nlogger1.log(&#39;Message 1&#39;);\nlogger2.log(&#39;Message 2&#39;);\n\nlogger1.printLogs();\nlogger2.printLogs();</code></pre>\n\n<p>在这个例子中，Logger 类中新增了一个静态方法 getInstance，用于获取日志记录器的唯一实例对象。在 getInstance 方法中，如果不存在 Logger 的实例对象，就创建一个新的实例对象并存储在静态属性 Logger.instance 中，否则就直接返回 Logger.instance。客户端代码只需要调用 Logger 的静态方法 getInstance 来获取日志记录器对象，并调用其 log 和 printLogs 方法来记录和输出日志，而不需要直接创建日志记录器对象或关心实例对象的管理。</p>\n<h3 id=\"类的静态方法中，为什么可以直接-new-类\"><a href=\"#类的静态方法中，为什么可以直接-new-类\" class=\"headerlink\" title=\"类的静态方法中，为什么可以直接 new 类\"></a>类的静态方法中，为什么可以直接 new 类</h3><p>在 JavaScript 中，类的静态方法中可以直接使用 <code>new</code> 关键字创建类的实例对象，<strong>因为静态方法和实例对象方法的作用域是不同的</strong>。静态方法属于类本身而不是类的实例对象，因此在静态方法中无法访问实例对象的属性和方法，同时也不能使用 <code>this</code> 关键字来引用实例对象。相反，静态方法可以访问类的静态属性和方法，而且可以通过 <code>new</code> 关键字来创建类的实例对象。</p>\n<p>在静态方法中使用 <code>new</code> 关键字创建类的实例对象时，实际上是在静态方法的作用域内创建了一个新的实例对象，并将其返回。这个新的实例对象与通过普通的实例化方式创建的实例对象是不同的，因为它没有被存储在类的实例属性中，也没有被绑定到类的原型链上。因此，在静态方法中使用 <code>new</code> 关键字创建实例对象时，需要将创建的实例对象返回给调用者，以便进行进一步的操作。</p>\n<h3 id=\"ES5-实现-class\"><a href=\"#ES5-实现-class\" class=\"headerlink\" title=\"ES5 实现 class\"></a>ES5 实现 class</h3><p>在 ES5 中，可以通过构造函数和原型对象的组合来实现类的功能，以下是一个简单的 ES5 实现类的代码示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个 Person 类\nfunction Person(name, age) &#123;\n  &#x2F;&#x2F; 构造函数中定义实例属性\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 在原型对象中定义实例方法\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;, and I am $&#123;this.age&#125; years old.&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建 Person 的实例对象\nvar person &#x3D; new Person(&#39;Tom&#39;, 20);\n\n&#x2F;&#x2F; 调用实例方法\nperson.sayHello();</code></pre>\n\n<p>在这个例子中，Person 是一个构造函数，它接受两个参数 name 和 age，并使用 this 关键字来定义实例属性。同时，在 Person 的原型对象中定义实例方法 sayHello，该方法可以通过 this 关键字访问实例属性。通过 new 关键字调用构造函数 Person 可以创建 Person 的实例对象 person，然后可以调用实例方法 sayHello 输出实例对象的属性值。</p>\n<p>需要注意的是，ES5 实现类时存在一些限制和问题，例如无法继承静态属性和方法、不能使用 super 关键字、原型链继承可能会出现问题等，因此在 ES6 中引入了 class 关键字来简化和统一类的定义和使用。</p>\n<h2 id=\"js-原型模式\"><a href=\"#js-原型模式\" class=\"headerlink\" title=\"js 原型模式\"></a>js 原型模式</h2><h3 id=\"原型模式示例示例\"><a href=\"#原型模式示例示例\" class=\"headerlink\" title=\"原型模式示例示例\"></a>原型模式示例示例</h3><p>以下是使用 JavaScript 原型模式创建对象的代码示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个人类构造函数\nfunction Person(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 在原型对象中定义方法\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;, and I am $&#123;this.age&#125; years old.&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建 Person 的实例对象\nvar person1 &#x3D; new Person(&#39;Tom&#39;, 20);\nvar person2 &#x3D; new Person(&#39;Jerry&#39;, 25);\n\n&#x2F;&#x2F; 调用实例方法\nperson1.sayHello();\nperson2.sayHello();</code></pre>\n\n<p>在这个例子中，我们使用构造函数 Person 定义了一个人类，构造函数中定义了实例属性 name 和 age，然后在 Person 的原型对象中定义了方法 sayHello，该方法可以通过 this 关键字访问实例属性。通过使用 new 关键字调用构造函数 Person 可以创建 Person 的实例对象 person1 和 person2，并分别调用实例方法 sayHello 来输出实例对象的属性值。</p>\n<p>使用原型模式创建对象的优点是可以避免在每个实例对象中重复定义方法，从而节省内存空间和提高代码的复用性。同时，修改原型对象中的方法会对所有的实例对象生效，使得程序更加简洁和易于维护。</p>\n<h3 id=\"ES6-实现原型模式\"><a href=\"#ES6-实现原型模式\" class=\"headerlink\" title=\"ES6 实现原型模式\"></a>ES6 实现原型模式</h3><p>ES6 中的类可以看作是一种基于原型的面向对象编程范式，因此实际上我们在使用 ES6 的类时，就是在使用原型模式。</p>\n<p>下面是一个使用 ES6 实现原型模式的代码示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个 Animal 类\nclass Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n\n  &#x2F;&#x2F; 定义 Animal 的方法\n  eat() &#123;\n    console.log(&#96;$&#123;this.name&#125; is eating.&#96;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个 Cat 类，继承自 Animal 类\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n\n  &#x2F;&#x2F; 定义 Cat 的方法\n  meow() &#123;\n    console.log(&#96;$&#123;this.name&#125; is meowing.&#96;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建一个 Cat 实例\nconst cat &#x3D; new Cat(&#39;Tom&#39;);\n\n&#x2F;&#x2F; 调用 Cat 的方法\ncat.eat(); &#x2F;&#x2F; Tom is eating.\ncat.meow(); &#x2F;&#x2F; Tom is meowing.</code></pre>\n\n<p>在这个例子中，我们定义了一个 Animal 类，它有一个属性 name 和一个方法 eat。然后我们又定义了一个 Cat 类，它继承自 Animal 类，并且还有一个方法 meow。最后我们创建了一个 Cat 实例 cat，并且调用了它的 eat 和 meow 方法。</p>\n<p>在使用 ES6 实现原型模式时，我们可以直接使用 class 和 extends 关键字来定义类和继承关系，而不必使用构造函数和原型链。此外，我们还可以使用 super 关键字来调用父类的构造函数和方法，从而更方便地实现面向对象编程。</p>\n<h2 id=\"js-观察者模式示例\"><a href=\"#js-观察者模式示例\" class=\"headerlink\" title=\"js 观察者模式示例\"></a>js 观察者模式示例</h2><h3 id=\"原型方式示例\"><a href=\"#原型方式示例\" class=\"headerlink\" title=\"原型方式示例\"></a>原型方式示例</h3><p>以下是使用 JavaScript 观察者模式实现一个简单的例子：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个主题对象\nfunction Subject() &#123;\n  &#x2F;&#x2F; 存储观察者列表\n  this.observers &#x3D; [];\n&#125;\n\n&#x2F;&#x2F; 定义添加观察者方法\nSubject.prototype.addObserver &#x3D; function (observer) &#123;\n  this.observers.push(observer);\n&#125;;\n\n&#x2F;&#x2F; 定义通知观察者方法\nSubject.prototype.notifyObservers &#x3D; function (data) &#123;\n  &#x2F;&#x2F; 遍历观察者列表，调用观察者的 update 方法\n  this.observers.forEach(function (observer) &#123;\n    observer.update(data);\n  &#125;);\n&#125;;\n\n&#x2F;&#x2F; 定义一个观察者对象\nfunction Observer(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\n&#x2F;&#x2F; 定义观察者的 update 方法\nObserver.prototype.update &#x3D; function (data) &#123;\n  console.log(&#96;$&#123;this.name&#125; received the data: $&#123;data&#125;&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建主题对象\nvar subject &#x3D; new Subject();\n\n&#x2F;&#x2F; 创建观察者对象\nvar observer1 &#x3D; new Observer(&#39;Observer 1&#39;);\nvar observer2 &#x3D; new Observer(&#39;Observer 2&#39;);\n\n&#x2F;&#x2F; 添加观察者到主题对象中\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\n&#x2F;&#x2F; 通知观察者\nsubject.notifyObservers(&#39;Hello World&#39;);</code></pre>\n\n<p>在这个例子中，我们定义了一个主题对象 Subject 和一个观察者对象 Observer。Subject 对象包含了一个 observers 数组，用于存储所有注册的观察者。Subject 对象有一个 addObserver 方法，用于添加观察者到 observers 数组中；还有一个 notifyObservers 方法，用于遍历 observers 数组并调用每个观察者的 update 方法来通知观察者。</p>\n<p>Observer 对象包含一个名为 name 的属性，和一个 update 方法，当主题对象调用 notifyObservers 方法时，Observer 对象的 update 方法将被调用，输出接收到的数据。</p>\n<p>在例子的最后，我们创建了一个主题对象 subject，和两个观察者对象 observer1 和 observer2，将观察者添加到主题对象中，然后通过调用主题对象的 notifyObservers 方法来通知所有的观察者。在控制台输出的信息中可以看到，两个观察者都成功接收到了通知。</p>\n<h3 id=\"ES6-类方式示例\"><a href=\"#ES6-类方式示例\" class=\"headerlink\" title=\"ES6 类方式示例\"></a>ES6 类方式示例</h3><p>使用 ES6 可以更简洁地实现观察者模式，以下是一个使用 ES6 实现的代码示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个主题对象\nclass Subject &#123;\n  constructor() &#123;\n    &#x2F;&#x2F; 存储观察者列表\n    this.observers &#x3D; [];\n  &#125;\n\n  &#x2F;&#x2F; 添加观察者方法\n  addObserver(observer) &#123;\n    this.observers.push(observer);\n  &#125;\n\n  &#x2F;&#x2F; 通知观察者方法\n  notifyObservers(data) &#123;\n    &#x2F;&#x2F; 遍历观察者列表，调用观察者的 update 方法\n    this.observers.forEach((observer) &#x3D;&gt; observer.update(data));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个观察者对象\nclass Observer &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n\n  &#x2F;&#x2F; 定义观察者的 update 方法\n  update(data) &#123;\n    console.log(&#96;$&#123;this.name&#125; received the data: $&#123;data&#125;&#96;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建主题对象\nconst subject &#x3D; new Subject();\n\n&#x2F;&#x2F; 创建观察者对象\nconst observer1 &#x3D; new Observer(&#39;Observer 1&#39;);\nconst observer2 &#x3D; new Observer(&#39;Observer 2&#39;);\n\n&#x2F;&#x2F; 添加观察者到主题对象中\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\n&#x2F;&#x2F; 通知观察者\nsubject.notifyObservers(&#39;Hello World&#39;);</code></pre>\n\n<p>在这个例子中，我们使用了 ES6 的 class 和箭头函数来实现观察者模式。与 ES5 中的代码相比，ES6 中使用 class 定义类的语法更加简洁明了，使用箭头函数也可以避免 this 关键字指向的问题。</p>\n<p>在例子的最后，我们创建了一个主题对象 subject，和两个观察者对象 observer1 和 observer2，将观察者添加到主题对象中，然后通过调用主题对象的 notifyObservers 方法来通知所有的观察者。在控制台输出的信息中可以看到，两个观察者都成功接收到了通知。</p>\n<h2 id=\"js-订阅发布模式\"><a href=\"#js-订阅发布模式\" class=\"headerlink\" title=\"js 订阅发布模式\"></a>js 订阅发布模式</h2><h3 id=\"ES5-代码实现\"><a href=\"#ES5-代码实现\" class=\"headerlink\" title=\"ES5 代码实现\"></a>ES5 代码实现</h3><p>订阅发布模式又称为观察者模式，可以通过一种松散的耦合方式来构建对象间的一对多关系。在 ES5 中可以使用原型和构造函数来实现订阅发布模式。</p>\n<p>下面是一个使用 ES5 实现订阅发布模式的代码示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个主题对象\nfunction Subject() &#123;\n  &#x2F;&#x2F; 存储观察者列表\n  this.observers &#x3D; [];\n&#125;\n\n&#x2F;&#x2F; 添加观察者方法\nSubject.prototype.addObserver &#x3D; function (observer) &#123;\n  this.observers.push(observer);\n&#125;;\n\n&#x2F;&#x2F; 通知观察者方法\nSubject.prototype.notifyObservers &#x3D; function (data) &#123;\n  &#x2F;&#x2F; 遍历观察者列表，调用观察者的 update 方法\n  this.observers.forEach(function (observer) &#123;\n    observer.update(data);\n  &#125;);\n&#125;;\n\n&#x2F;&#x2F; 定义一个观察者对象\nfunction Observer(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\n&#x2F;&#x2F; 定义观察者的 update 方法\nObserver.prototype.update &#x3D; function (data) &#123;\n  console.log(this.name + &#39; received the data: &#39; + data);\n&#125;;\n\n&#x2F;&#x2F; 创建主题对象\nvar subject &#x3D; new Subject();\n\n&#x2F;&#x2F; 创建观察者对象\nvar observer1 &#x3D; new Observer(&#39;Observer 1&#39;);\nvar observer2 &#x3D; new Observer(&#39;Observer 2&#39;);\n\n&#x2F;&#x2F; 添加观察者到主题对象中\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\n&#x2F;&#x2F; 通知观察者\nsubject.notifyObservers(&#39;Hello World&#39;);</code></pre>\n\n<p>在这个例子中，我们定义了一个 Subject 对象，它有一个 observers 属性来存储观察者列表，并且有一个 addObserver 方法用来添加观察者，有一个 notifyObservers 方法用来通知所有的观察者。然后我们定义了一个 Observer 对象，它有一个 name 属性和一个 update 方法用来接收通知。最后我们创建了一个 Subject 实例 subject 和两个 Observer 实例 observer1 和 observer2，将观察者添加到主题对象中，并且通过调用主题对象的 notifyObservers 方法来通知所有的观察者。在控制台输出的信息中可以看到，两个观察者都成功接收到了通知。</p>\n<p>需要注意的是，在 ES5 中实现订阅发布模式时，我们需要手动维护观察者列表，并且要使用原型和构造函数来定义对象。与 ES6 中的代码相比，ES5 中的代码更为冗长，但是在一些特定的情况下，ES5 中的实现方式可能更加灵活和方便。</p>\n<h3 id=\"观察者模式与订阅发布模式有何区别\"><a href=\"#观察者模式与订阅发布模式有何区别\" class=\"headerlink\" title=\"观察者模式与订阅发布模式有何区别\"></a>观察者模式与订阅发布模式有何区别</h3><p>观察者模式和订阅发布模式都是用来构建对象间的一对多关系，它们之间的主要区别在于实现的方式和使用的场景。</p>\n<p>观察者模式的核心是一个被观察者对象和若干个观察者对象，当被观察者对象的状态发生变化时，所有的观察者对象都会接收到通知并且做出相应的响应。观察者模式通常使用事件来实现，被观察者对象会触发一个事件，观察者对象会监听这个事件并且在事件发生时做出响应。</p>\n<p>订阅发布模式的核心是一个事件中心对象和若干个订阅者对象，订阅者对象可以向事件中心对象订阅某个事件，并且在事件发生时做出响应。事件中心对象在事件发生时会向所有订阅者对象发送通知。订阅发布模式通常使用回调函数来实现，订阅者对象会向事件中心对象注册一个回调函数，并且在事件发生时事件中心对象会调用所有注册的回调函数。</p>\n<p>观察者模式和订阅发布模式在实现上有一些区别，但是<strong>它们都可以用来构建对象间的一对多关系</strong>。<br>在使用时，</p>\n<ol>\n<li>观察者模式更适用于一些状态变化较为频繁的场景，</li>\n<li>订阅发布模式则更适用于一些事件驱动的场景。</li>\n</ol>\n<h3 id=\"redux-是订阅发布模式还是观察者模式\"><a href=\"#redux-是订阅发布模式还是观察者模式\" class=\"headerlink\" title=\"redux 是订阅发布模式还是观察者模式\"></a>redux 是订阅发布模式还是观察者模式</h3><p>Redux 是一个状态管理库，它是基于订阅发布模式实现的。</p>\n<p>在 Redux 中，应用的状态被存储在一个称为”Store”的对象中，这个对象允许开发者通过”dispatch”方法来触发状态的变化。当状态发生变化时，Redux 会调用所有已经注册的回调函数，并且将新的状态传递给它们。这个过程类似于订阅发布模式中的事件中心向所有订阅者对象发送通知。</p>\n<p>因此，Redux 可以被看作是基于订阅发布模式实现的状态管理库，它将应用的状态和状态变化的处理逻辑进行了封装，并且提供了一些 API 来方便开发者使用。</p>\n<h2 id=\"js-装饰者模式\"><a href=\"#js-装饰者模式\" class=\"headerlink\" title=\"js 装饰者模式\"></a>js 装饰者模式</h2><p>装饰者模式（Decorator Pattern）是一种结构型设计模式，它允许我们<strong>动态地向一个对象添加新的行为，而不需要使用子类来扩展对象的功能</strong>。</p>\n<p><strong>具体表现为：</strong>在装饰者模式中，我们将对象包装在一个装饰器中，并且将新的行为添加到装饰器中，从而实现了动态地扩展对象的功能。</p>\n<p>装饰者模式的核心是装饰器类和被装饰对象，装饰器类包含了一个指向被装饰对象的引用，并且实现了与被装饰对象相同的接口。装饰器类可以动态地向被装饰对象添加新的行为，而不需要直接修改被装饰对象的代码。</p>\n<p>在 JavaScript 中，装饰者模式通常通过函数来实现。我们可以将被装饰对象作为参数传递给装饰器函数，装饰器函数会返回一个新的函数或对象，这个新的函数或对象包含了被装饰对象的所有行为，并且添加了新的行为。</p>\n<h3 id=\"装饰者模式代码示例\"><a href=\"#装饰者模式代码示例\" class=\"headerlink\" title=\"装饰者模式代码示例\"></a>装饰者模式代码示例</h3><p>以下是一个使用装饰者模式实现日志功能的示例代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 被装饰对象\nclass Foo &#123;\n  doSomething() &#123;\n    console.log(&#39;doing something&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器函数\nfunction withLogging(target) &#123;\n  const originalMethod &#x3D; target.doSomething;\n\n  target.doSomething &#x3D; function () &#123;\n    console.log(&#39;before doSomething&#39;);\n    originalMethod.call(this);\n    console.log(&#39;after doSomething&#39;);\n  &#125;;\n\n  return target;\n&#125;\n\n&#x2F;&#x2F; 使用装饰器扩展对象功能\nconst decoratedFoo &#x3D; withLogging(new Foo());\n\n&#x2F;&#x2F; 调用扩展后的对象方法\ndecoratedFoo.doSomething();</code></pre>\n\n<p>在上面的示例中，我们定义了一个被装饰对象<code>Foo</code>和一个装饰器函数<code>withLogging</code>。<code>withLogging</code>函数接受一个<code>target</code>参数，这个参数是一个被装饰对象。在<code>withLogging</code>函数中，我们将<code>target</code>对象的<code>doSomething</code>方法保存到<code>originalMethod</code>变量中，并且将一个新的函数赋值给<code>target.doSomething</code>，这个新的函数在调用<code>originalMethod</code>之前和之后都会打印一些日志。最后，<code>withLogging</code>函数返回被装饰后的<code>target</code>对象。</p>\n<p>我们可以通过调用<code>withLogging(new Foo())</code>来获得一个新的对象<code>decoratedFoo</code>，这个对象包含了被装饰对象<code>Foo</code>的所有行为，并且添加了打印日志的新行为。最后，我们调用<code>decoratedFoo.doSomething()</code>来触发新的函数，这个函数会先打印一些日志，然后调用原始的<code>doSomething</code>方法，最后再打印一些日志。</p>\n<h2 id=\"js-代理模式\"><a href=\"#js-代理模式\" class=\"headerlink\" title=\"js 代理模式\"></a>js 代理模式</h2><p>代理模式（Proxy Pattern）是一种结构型设计模式，它允许我们<strong>在不改变对象原始接口的情况下，为对象提供一个代理，用于控制对对象的访问</strong>。代理模式通常用于延迟对象的创建、远程访问、权限控制等场景。</p>\n<p>在代理模式中，我们定义一个代理对象，它与原始对象具有相同的接口，并且维护一个对原始对象的引用。代理对象可以接受对原始对象的请求，并且可以对请求进行处理，也可以将请求转发给原始对象进行处理。通过代理对象，我们可以对原始对象的访问进行控制，例如可以限制对某些方法的访问、记录日志、缓存结果等。</p>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><p>在 JavaScript 中，代理模式通常使用 ES6 的 Proxy 对象来实现。Proxy 对象可以用来代理 JavaScript 中的任何对象，并且可以重载访问对象的属性和方法，从而实现对对象的控制和定制。以下是一个使用代理模式实现缓存功能的示例代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 原始对象\nclass Calculator &#123;\n  constructor() &#123;\n    this.cache &#x3D; &#123;&#125;;\n  &#125;\n\n  add(x, y) &#123;\n    const key &#x3D; &#96;$&#123;x&#125;+$&#123;y&#125;&#96;;\n    if (key in this.cache) &#123;\n      console.log(&#39;cache hit&#39;);\n      return this.cache[key];\n    &#125; else &#123;\n      console.log(&#39;cache miss&#39;);\n      const result &#x3D; x + y;\n      this.cache[key] &#x3D; result;\n      return result;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 代理对象\nclass CachedCalculator &#123;\n  constructor() &#123;\n    this.calculator &#x3D; new Calculator();\n  &#125;\n\n  add(x, y) &#123;\n    return this.calculator.add(x, y);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用代理对象\nconst calculator &#x3D; new CachedCalculator();\nconsole.log(calculator.add(1, 2));\nconsole.log(calculator.add(1, 2));</code></pre>\n\n<p>在上面的示例中，我们定义了一个原始对象<code>Calculator</code>和一个代理对象<code>CachedCalculator</code>。</p>\n<ul>\n<li><code>Calculator</code>对象实现了一个简单的加法方法，并且使用一个缓存对象来缓存计算结果。</li>\n<li><code>CachedCalculator</code>对象代理了<code>Calculator</code>对象，并且使用<code>Calculator</code>对象来实现自己的<code>add</code>方法。</li>\n</ul>\n<p>我们可以通过创建一个<code>CachedCalculator</code>对象来使用代理对象，例如可以使用<code>calculator.add(1, 2)</code>来计算 1+2 的结果。当第一次调用<code>add</code>方法时，<code>Calculator</code>对象会执行计算操作并将结果缓存到内存中，当第二次调用<code>add</code>方法时，代理对象会从缓存中获取计算结果，并且不会再次执行计算操作。</p>\n<p>代理模式可以用于许多场景，例如<strong>控制对对象的访问、实现远程调用、记录日志、实现延迟初始化</strong>等。通过使用代理对象，我们可以实现更加灵活和可控的对象访问方式。</p>\n<h3 id=\"ES6-proxy-实现代理模式\"><a href=\"#ES6-proxy-实现代理模式\" class=\"headerlink\" title=\"ES6 proxy 实现代理模式\"></a>ES6 proxy 实现代理模式</h3><p>ES6 中的<code>Proxy</code>对象是一种通用的代理对象，可以用来代理任何 JavaScript 对象，并且可以通过重载对象的属性和方法来实现对对象的控制和定制。以下是一个使用<code>Proxy</code>对象实现代理模式的示例代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 原始对象\nclass Calculator &#123;\n  add(x, y) &#123;\n    return x + y;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 代理对象\nclass CachedCalculator &#123;\n  constructor() &#123;\n    this.cache &#x3D; &#123;&#125;;\n    this.calculator &#x3D; new Calculator();\n  &#125;\n\n  add(x, y) &#123;\n    const key &#x3D; &#96;$&#123;x&#125;+$&#123;y&#125;&#96;;\n    if (key in this.cache) &#123;\n      console.log(&#39;cache hit&#39;);\n      return this.cache[key];\n    &#125; else &#123;\n      console.log(&#39;cache miss&#39;);\n      const result &#x3D; this.calculator.add(x, y);\n      this.cache[key] &#x3D; result;\n      return result;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用代理对象\nconst calculator &#x3D; new CachedCalculator();\nconst proxy &#x3D; new Proxy(calculator, &#123;\n  get: function (target, name) &#123;\n    if (name in target) &#123;\n      return target[name];\n    &#125; else &#123;\n      throw new Error(&#96;Undefined property: $&#123;name&#125;&#96;);\n    &#125;\n  &#125;,\n&#125;);\n\nconsole.log(proxy.add(1, 2));\nconsole.log(proxy.add(1, 2));\nconsole.log(proxy.sub(1, 2));</code></pre>\n\n<p>在上面的示例中，我们定义了一个原始对象<code>Calculator</code>和一个代理对象<code>CachedCalculator</code>。<code>Calculator</code>对象实现了一个简单的加法方法，而<code>CachedCalculator</code>对象代理了<code>Calculator</code>对象，并且实现了一个缓存功能。我们使用<code>Proxy</code>对象来创建一个代理对象<code>proxy</code>，并且通过<code>get</code>方法重载了代理对象的属性访问，当访问一个不存在的属性时，代理对象会抛出一个错误。</p>\n<p>我们可以通过调用代理对象的<code>add</code>方法来实现加法运算，并且该方法会被代理对象拦截并且实现缓存功能。当第一次调用<code>add</code>方法时，代理对象会执行计算操作并将结果缓存到内存中，当第二次调用<code>add</code>方法时，代理对象会从缓存中获取计算结果，并且不会再次执行计算操作。当调用<code>sub</code>方法时，由于该方法不存在于代理对象中，代理对象会抛出一个错误。</p>\n<p>通过使用<code>Proxy</code>对象，我们可以实现更加灵活和可控的对象访问方式，从而实现代理模式的功能。</p>\n<h2 id=\"装饰器模式与代理模式的区别\"><a href=\"#装饰器模式与代理模式的区别\" class=\"headerlink\" title=\"装饰器模式与代理模式的区别\"></a>装饰器模式与代理模式的区别</h2><p>装饰器模式和代理模式在某些场景下可以实现相似的功能，但它们有不同的用途和目的。</p>\n<p>装饰器模式是一种结构型设计模式，它允许你在不修改对象自身的基础上，动态地添加行为或修改行为。它是为了给对象添加功能而设计的，即扩展一个类的功能，而不是改变它。通常情况下，装饰器模式用于处理对象的行为和责任分离问题，它使得在不影响到其他对象的情况下，能够动态地给一个对象添加新的功能。装饰器模式是一种基于对象组合的设计模式，它使用了对象的组合关系来达到其目的。</p>\n<p>代理模式也是一种结构型设计模式，它在不改变对象的情况下，为其他对象提供一种代理以控制对这个对象的访问。代理模式用于控制访问，而不是扩展对象的功能。代理模式通过在对象之间引入一个代理对象来间接访问对象，从而保证了对象的访问控制和权限管理。</p>\n<p><strong>简而言之，装饰器模式用于添加对象的功能，而代理模式则用于控制对象的访问。</strong></p>\n<h2 id=\"js-建造者模式（有点像我最讨厌的-JAVA-样子）\"><a href=\"#js-建造者模式（有点像我最讨厌的-JAVA-样子）\" class=\"headerlink\" title=\"js 建造者模式（有点像我最讨厌的 JAVA 样子）\"></a>js 建造者模式（有点像我最讨厌的 JAVA 样子）</h2><p>建造者模式是一种创建型设计模式，用于将复杂对象的构建过程和其表示相分离，以便可以使用相同的构建过程来创建不同的表示。</p>\n<p>在 JavaScript 中，建造者模式可以用于创建复杂的对象，例如包含多个属性和方法的组合对象。以下是一个使用建造者模式创建复杂对象的示例代码：</p>\n<h3 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Car &#123;\n  constructor() &#123;\n    this.color &#x3D; null;\n    this.wheels &#x3D; null;\n    this.engine &#x3D; null;\n    this.seats &#x3D; null;\n  &#125;\n\n  setColor(color) &#123;\n    this.color &#x3D; color;\n    return this;\n  &#125;\n\n  setWheels(wheels) &#123;\n    this.wheels &#x3D; wheels;\n    return this;\n  &#125;\n\n  setEngine(engine) &#123;\n    this.engine &#x3D; engine;\n    return this;\n  &#125;\n\n  setSeats(seats) &#123;\n    this.seats &#x3D; seats;\n    return this;\n  &#125;\n\n  build() &#123;\n    return &#123;\n      color: this.color,\n      wheels: this.wheels,\n      engine: this.engine,\n      seats: this.seats,\n    &#125;;\n  &#125;\n&#125;\n\nconst carBuilder &#x3D; new Car();\nconst car &#x3D; carBuilder.setColor(&#39;blue&#39;).setWheels(4).setEngine(&#39;V8&#39;).setSeats(5).build();\n\nconsole.log(car);</code></pre>\n\n<p>在上面的示例中，我们定义了一个<code>Car</code>类，该类包含了多个属性和方法来创建一个复杂的汽车对象。其中，<code>setColor</code>、<code>setWheels</code>、<code>setEngine</code>和<code>setSeats</code>方法用于设置汽车对象的不同属性，而<code>build</code>方法用于返回最终创建的汽车对象。我们使用建造者模式来创建一个<code>Car</code>对象，首先创建一个<code>Car</code>对象实例，然后使用链式调用来设置汽车的属性，最后调用<code>build</code>方法来返回最终创建的汽车对象。</p>\n<p>使用建造者模式可以将复杂对象的构建过程与其表示相分离，从而实现更加灵活和可扩展的对象创建方式。建造者模式还可以简化代码，提高代码的可读性和可维护性。</p>\n<h3 id=\"其他场景\"><a href=\"#其他场景\" class=\"headerlink\" title=\"其他场景\"></a>其他场景</h3><p><a href=\"https://docs.nestjs.com/techniques/file-upload#file-validation:~:text=UploadedFile(%0A%20%20new-,ParseFilePipeBuilder,-()%0A%20%20%20%20.\" target=\"_blank\" >Nestjs 中的建造者</a>除此之外，在 fultter、java 中也很常见</p>\n<h3 id=\"如何理解“将复杂对象的构建过程与其表示相分离”\"><a href=\"#如何理解“将复杂对象的构建过程与其表示相分离”\" class=\"headerlink\" title=\"如何理解“将复杂对象的构建过程与其表示相分离”\"></a>如何理解“将复杂对象的构建过程与其表示相分离”</h3><p>“将复杂对象的构建过程与其表示相分离”是建造者模式的核心思想之一。</p>\n<p><strong>它的意思是将对象的构建过程和最终对象的表示分离开来，也就是说，将对象的构建过程交给一个专门的”建造者”来负责，而最终的表示由客户端决定。</strong></p>\n<p>具体来说，</p>\n<ul>\n<li>“构建过程”包括对象属性的初始化、赋值、检验等操作，以及对象方法的调用等操作；</li>\n<li>而”表示”指的是最终的对象形态，包括属性的值和对象方法的实现等。</li>\n</ul>\n<p>在建造者模式中，通过将对象的构建过程和最终的表示分离，可以使得对象的创建更加灵活和可扩展。因为可以在不改变对象表示的前提下，通过改变构建过程来创建不同的对象。</p>\n<p>举个例子，假设有一个复杂的汽车对象，它包括多个属性（比如颜色、型号、座位数等）和多个方法（比如加速、刹车、转弯等）。<br>如果不使用建造者模式，那么我们可能需要在客户端中直接构建这个复杂的对象，这样就会让客户端代码变得非常复杂和难以维护。<br>而使用建造者模式，我们可以将构建过程交给专门的”建造者”来负责，客户端只需要调用建造者提供的方法来设置属性和方法即可，这样就能够使得客户端代码更加简洁和易于维护。<br>同时，由于建造者可以自由地改变构建过程，因此可以轻松地创建不同的汽车对象，比如不同颜色、不同型号、不同座位数等等。</p>\n<h3 id=\"建造者模式-怎么看上去像是-JAVA-的-set-方法和-get-方法呢\"><a href=\"#建造者模式-怎么看上去像是-JAVA-的-set-方法和-get-方法呢\" class=\"headerlink\" title=\"建造者模式 怎么看上去像是 JAVA 的 set 方法和 get 方法呢\"></a>建造者模式 怎么看上去像是 JAVA 的 set 方法和 get 方法呢</h3><p>建造者模式中的属性设置方法更加专注于对象的构建过程，而 Java 中的 get 和 set 方法通常只是简单地用于获取和设置属性的值。虽然它们有一些相似之处，但建造者模式的属性设置方法还提供了一些额外的特性，比如链式调用。</p>\n<details class=\"custom-details\">\n<summary>详细内容</summary>\n<p><p>你提到的 Java 中的 set 和 get 方法，确实有一些类似建造者模式中的属性设置方法。</p>\n<p>在 Java 中，通常将属性设置为私有的，然后通过 public 的 get 和 set 方法来设置和获取属性的值。这种方式可以保证属性的访问控制和封装性，并且可以在设置属性值时进行一些额外的检验和逻辑处理。</p>\n<p>而<strong>在建造者模式中</strong>，也是通过一些方法来设置属性值，但它们通常都是专门为对象的构建而设计的，而不仅仅是为了简单地设置属性。</p>\n<p>不过，建造者模式和 Java 中的 get 和 set 方法还是有一些不同之处的。</p>\n<p>建造者模式</p>\n<ol>\n<li>通常将构建过程抽象出来，用一个专门的类来负责构建对象，并提供一些方法来设置属性和方法。这些方法通常都是和对象的构建过程相关的，而不仅仅是为了设置属性。此外，</li>\n<li>建造者模式还<strong>可以通过链式调用来设置属性</strong>，这样可以让代码更加简洁和易于使用。</li>\n</ol>\n<p>而在 Java 中，get 和 set 方法通常只是简单的用于获取和设置属性的值，<strong>并且不具备链式调用的特点</strong>。</p>\n<p>因此，虽然 Java 中的 get 和 set 方法有一些类似建造者模式中的属性设置方法，但它们还是存在一些区别的。建造者模式的属性设置方法更加专注于对象的构建过程，并且提供了一些额外的特性，<strong>比如链式调用。</strong></p>\n</p>\n</details>\n<h2 id=\"js-适配器模式\"><a href=\"#js-适配器模式\" class=\"headerlink\" title=\"js 适配器模式\"></a>js 适配器模式</h2><p>在 JavaScript 中，适配器模式<strong>可以用来将一个不兼容的接口转换成另一个接口</strong>，以便我们可以在不修改原始代码的情况下重用已有的代码。</p>\n<p>适配器模式通常包含三个角色：客户端、适配器和适配者。其中，客户端使用适配器来调用适配者提供的方法。适配器则负责将适配者的方法转换成客户端期望的接口形式。</p>\n<h3 id=\"适配器代码示例\"><a href=\"#适配器代码示例\" class=\"headerlink\" title=\"适配器代码示例\"></a>适配器代码示例</h3><p>下面是一个简单的 JavaScript 适配器模式的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义适配者\nclass Adaptee &#123;\n  specificRequest() &#123;\n    return &#39;适配者中的业务代码被调用&#39;;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义适配器\nclass Adapter &#123;\n  constructor() &#123;\n    this.adaptee &#x3D; new Adaptee();\n  &#125;\n\n  request() &#123;\n    let result &#x3D; this.adaptee.specificRequest();\n    result &#x3D; &#96;适配器：$&#123;result&#125;，已经被适配成客户端所需要的接口形式&#96;;\n    return result;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义客户端\nclass Client &#123;\n  constructor(adapter) &#123;\n    this.adapter &#x3D; adapter;\n  &#125;\n\n  execute() &#123;\n    console.log(this.adapter.request());\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 测试代码\nconst adapter &#x3D; new Adapter();\nconst client &#x3D; new Client(adapter);\nclient.execute();</code></pre>\n\n<p>在上面的示例中，我们定义了一个适配者 <code>Adaptee</code>，它提供了一个不兼容的接口 <code>specificRequest</code>。然后我们定义了一个适配器 <code>Adapter</code>，它包含一个适配者的实例，并将其转换成客户端需要的接口形式。最后，我们定义了一个客户端 <code>Client</code>，它使用适配器来调用适配者的方法。</p>\n<p>当我们执行测试代码时，会输出一段字符串，其中包含了适配者的业务代码和适配器转换后的接口形式。这说明适配器模式已经成功地将不兼容的接口转换成了客户端需要的接口形式。</p>\n<h3 id=\"适配器使用场景\"><a href=\"#适配器使用场景\" class=\"headerlink\" title=\"适配器使用场景\"></a>适配器使用场景</h3><p>适配器模式可以将不兼容的接口转换成我们需要的接口形式，使得我们可以重用已有的代码，并提高代码的可重用性和灵活性。它通常应用于需要集成<strong>已有的代码库</strong>或<strong>第三方库</strong>，或者<strong>需要使用不兼容接口</strong>的情况。</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>适配器模式通常在以下两种场景中使用：</p>\n<ol>\n<li><p>在使用一些已有的代码库或第三方库时，这些库的接口可能与我们当前的代码不兼容。这时可以使用适配器模式，将这些不兼容的接口转换成我们需要的接口形式，以便我们可以在不修改原始代码的情况下重用已有的代码。</p>\n</li>\n<li><p>当我们需要使用一些已有的类，但它们的接口不符合我们的需求时，也可以使用适配器模式。我们可以定义一个适配器类，实现我们所需要的接口，并在适配器类中包含一个已有的类的实例。这样，我们就可以通过适配器来调用已有的类的方法，并将它们转换成我们需要的接口形式。</p>\n</li>\n</ol>\n<p>具体来说，适配器模式在以下情况中可能会特别有用：</p>\n<ul>\n<li><p>当我们需要将一个已有的代码库或第三方库集成到我们的应用程序中，并且它们的接口与我们的应用程序不兼容时。</p>\n</li>\n<li><p>当我们需要使用一些已有的类或对象，并且它们的接口不符合我们的需求时。</p>\n</li>\n<li><p>当我们需要将一些不同的接口统一成一个共同的接口时，可以使用适配器模式来将这些不同的接口转换成我们需要的接口形式。</p>\n</li>\n</ul>\n<p>总之，适配器模式可以帮助我们在不修改原始代码的情况下重用已有的代码，并将不兼容的接口转换成我们需要的接口形式，从而提高代码的可重用性和灵活性。</p>\n\n</details>\n<h2 id=\"js-过滤器模式【缓存】\"><a href=\"#js-过滤器模式【缓存】\" class=\"headerlink\" title=\"js 过滤器模式【缓存】\"></a>js 过滤器模式【缓存】</h2><p>过滤器模式（Filter Pattern）是一种结构型设计模式，它可以通过定义一系列过滤器来筛选出符合条件的数据。在 JavaScript 中，过滤器模式通常应用于处理大量数据时的数据筛选和过滤。</p>\n<p>过滤器模式通常包含以下角色：</p>\n<ul>\n<li><p>Filter：定义一个过滤器接口，提供一个过滤方法，用于对数据进行筛选和过滤。</p>\n</li>\n<li><p>ConcreteFilter：实现具体的过滤器，对数据进行具体的筛选和过滤。</p>\n</li>\n<li><p>FilterChain：定义一个过滤器链，将多个过滤器组合成一个过滤器链，并提供一个过滤方法，用于对数据进行链式过滤。</p>\n</li>\n<li><p>Client：使用过滤器模式的客户端，在客户端中创建一个过滤器链，并使用过滤器链对数据进行筛选和过滤。</p>\n</li>\n</ul>\n<h3 id=\"代码示例-2\"><a href=\"#代码示例-2\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><p>以下是一个 JavaScript 过滤器模式的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个过滤器接口\nclass Filter &#123;\n  filter(data) &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; 实现具体的过滤器\nclass AgeFilter extends Filter &#123;\n  constructor(minAge, maxAge) &#123;\n    super();\n    this.minAge &#x3D; minAge;\n    this.maxAge &#x3D; maxAge;\n  &#125;\n  filter(data) &#123;\n    return data.filter((item) &#x3D;&gt; item.age &gt;&#x3D; this.minAge &amp;&amp; item.age &lt;&#x3D; this.maxAge);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个过滤器链\nclass FilterChain &#123;\n  constructor() &#123;\n    this.filters &#x3D; [];\n  &#125;\n  addFilter(filter) &#123;\n    this.filters.push(filter);\n  &#125;\n  filter(data) &#123;\n    return this.filters.reduce((result, filter) &#x3D;&gt; filter.filter(result), data);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用过滤器模式的客户端\nconst data &#x3D; [\n  &#123; name: &#39;Tom&#39;, age: 20 &#125;,\n  &#123; name: &#39;Jack&#39;, age: 30 &#125;,\n  &#123; name: &#39;Mike&#39;, age: 25 &#125;,\n  &#123; name: &#39;Lucy&#39;, age: 18 &#125;,\n  &#123; name: &#39;Jane&#39;, age: 35 &#125;,\n];\n\nconst ageFilter &#x3D; new AgeFilter(20, 30);\nconst filterChain &#x3D; new FilterChain();\nfilterChain.addFilter(ageFilter);\n\nconst result &#x3D; filterChain.filter(data);\nconsole.log(result);\n&#x2F;&#x2F; Output: [&#123; name: &#39;Tom&#39;, age: 20 &#125;, &#123; name: &#39;Mike&#39;, age: 25 &#125;]</code></pre>\n\n<p>在这个例子中，</p>\n<ol>\n<li>我们首先定义了一个过滤器接口 Filter，</li>\n<li>然后实现了一个具体的过滤器 AgeFilter，用于筛选出年龄在[minAge, maxAge]范围内的数据。</li>\n<li>接下来，我们定义了一个过滤器链 FilterChain，它可以将多个过滤器组合成一个过滤器链，并提供一个过滤方法，用于对数据进行链式过滤。</li>\n<li>最后，我们使用客户端创建了一个过滤器链，并使用过滤器链对数据进行筛选和过滤，得到了符合条件的数据。</li>\n</ol>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>过滤器模式通常用于从一个大的数据集合中选择符合特定条件的数据，或者将数据按照一定的规则进行分类或聚合。它可以帮助我们将数据处理逻辑与业务逻辑分离，提高代码的可复用性和可维护性。常见的应用场景包括<code>数据筛选</code>、<code>分页</code>、<code>聚合</code>等，同时也可以用于<code>实现缓存</code>或者<code>数据预处理</code>等。</p>\n<h3 id=\"过滤器实现缓存的示例\"><a href=\"#过滤器实现缓存的示例\" class=\"headerlink\" title=\"过滤器实现缓存的示例\"></a>过滤器实现缓存的示例</h3><p>以下是一个使用过滤器模式实现缓存的简单示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个数据过滤器类\nclass Filter &#123;\n  constructor(data, rules) &#123;\n    this.data &#x3D; data;\n    this.rules &#x3D; rules;\n  &#125;\n\n  filterData() &#123;\n    &#x2F;&#x2F; 检查缓存是否命中\n    const cacheKey &#x3D; JSON.stringify(this.rules);\n    if (Filter.cache[cacheKey]) &#123;\n      console.log(&#39;从缓存中读取数据&#39;);\n      return Filter.cache[cacheKey];\n    &#125;\n\n    &#x2F;&#x2F; 进行数据筛选\n    let result &#x3D; this.data.filter((item) &#x3D;&gt; &#123;\n      for (let rule of this.rules) &#123;\n        if (!rule(item)) &#123;\n          return false;\n        &#125;\n      &#125;\n      return true;\n    &#125;);\n\n    &#x2F;&#x2F; 将结果缓存起来\n    Filter.cache[cacheKey] &#x3D; result;\n    console.log(&#39;数据已缓存&#39;);\n    return result;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 静态属性用于存储缓存数据\nFilter.cache &#x3D; &#123;&#125;;\n\n&#x2F;&#x2F; 示例代码\nconst data &#x3D; [\n  &#123; name: &#39;Alice&#39;, age: 20, gender: &#39;F&#39; &#125;,\n  &#123; name: &#39;Bob&#39;, age: 30, gender: &#39;M&#39; &#125;,\n  &#123; name: &#39;Charlie&#39;, age: 25, gender: &#39;M&#39; &#125;,\n  &#123; name: &#39;David&#39;, age: 28, gender: &#39;M&#39; &#125;,\n  &#123; name: &#39;Eve&#39;, age: 22, gender: &#39;F&#39; &#125;,\n];\n\nconst filter &#x3D; new Filter(data, [(item) &#x3D;&gt; item.age &gt;&#x3D; 25, (item) &#x3D;&gt; item.gender &#x3D;&#x3D;&#x3D; &#39;M&#39;]);\n\nconsole.log(filter.filterData());\nconsole.log(filter.filterData());</code></pre>\n\n<p>在上述示例中，我们定义了一个 <code>Filter</code> 类来实现数据过滤的功能。其中，构造函数接收一个数据集合和一组筛选规则，并将它们保存在实例属性中。<code>filterData</code> 方法则负责进行数据筛选，并且在命中缓存的情况下直接从缓存中读取结果，否则就进行数据筛选并将结果缓存起来。通过这种方式，我们可以避免对相同的数据集合和筛选规则进行重复的计算和查询，提高代码的执行效率。</p>\n<h3 id=\"过滤器聚合场景示例\"><a href=\"#过滤器聚合场景示例\" class=\"headerlink\" title=\"过滤器聚合场景示例\"></a>过滤器聚合场景示例</h3><p>过滤器模式可以和聚合模式结合使用，用于对聚合对象进行筛选或过滤，只返回符合条件的子集合。</p>\n<p>以下是一个使用 JavaScript 实现过滤器和聚合模式结合的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Product &#123;\n  constructor(name, price) &#123;\n    this.name &#x3D; name;\n    this.price &#x3D; price;\n  &#125;\n&#125;\n\nclass Cart &#123;\n  constructor() &#123;\n    this.products &#x3D; [];\n  &#125;\n\n  addProduct(product) &#123;\n    this.products.push(product);\n  &#125;\n\n  filterProducts(filter) &#123;\n    return this.products.filter(filter);\n  &#125;\n\n  getTotalPrice() &#123;\n    return this.products.reduce((total, product) &#x3D;&gt; total + product.price, 0);\n  &#125;\n&#125;\n\nclass Order &#123;\n  constructor(customer) &#123;\n    this.customer &#x3D; customer;\n    this.cart &#x3D; new Cart(); &#x2F;&#x2F; 对象内部有products\n  &#125;\n\n  addProductToCart(product) &#123;\n    &#x2F;&#x2F; 将商品加入购物车的products中\n    this.cart.addProduct(product);\n  &#125;\n\n  filterProducts(filter) &#123;\n    &#x2F;&#x2F; 购物车的过滤方法\n    return this.cart.filterProducts(filter);\n  &#125;\n\n  getTotalPrice() &#123;\n    &#x2F;&#x2F; 购物车总价\n    return this.cart.getTotalPrice();\n  &#125;\n&#125;\n\nconst customer &#x3D; &#39;John&#39;;\nconst order &#x3D; new Order(customer);\n\nconst product1 &#x3D; new Product(&#39;Laptop&#39;, 1000);\norder.addProductToCart(product1);\n\nconst product2 &#x3D; new Product(&#39;Phone&#39;, 500);\norder.addProductToCart(product2);\n\nconst expensiveFilter &#x3D; (product) &#x3D;&gt; product.price &gt; 600;\n&#x2F;&#x2F; 订单中大于N的商品，内部调用的是购物车的方法\nconst expensiveProducts &#x3D; order.filterProducts(expensiveFilter);\n\nconsole.log(&#96;Expensive products for $&#123;customer&#125;:&#96;);\nexpensiveProducts.forEach((product) &#x3D;&gt; &#123;\n  console.log(&#96;$&#123;product.name&#125; ($&#123;product.price&#125;)&#96;);\n&#125;);\n\nconsole.log(&#96;Total price for $&#123;customer&#125; is $&#123;order.getTotalPrice()&#125;&#96;);</code></pre>\n\n<p>在这个示例中，</p>\n<ol>\n<li>我们新增了 <code>filterProducts</code> 方法，用于过滤购物车中的产品。</li>\n<li>在 <code>Order</code> 类中也新增了 <code>filterProducts</code> 方法，用于从购物车中获取符合条件的产品子集。</li>\n<li>主程序中，我们定义了一个只选取价格超过 600 的产品过滤器，并获取了符合条件的产品。</li>\n<li>最后，输出了选中产品的名称和价格，以及订单总价。</li>\n</ol>\n<p>这个设计有点麻烦啊：看上去 Order 没什么太大的用的样子，可又不得不存在的样子</p>\n<h2 id=\"js-桥接模式\"><a href=\"#js-桥接模式\" class=\"headerlink\" title=\"js 桥接模式\"></a>js 桥接模式</h2><p>桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与实现部分分离开来，以便它们可以独立地变化。</p>\n<p><strong>在桥接模式中，有两个独立的类层次结构，一个是抽象部分，另一个是实现部分。抽象部分包含高层次的业务逻辑，而实现部分负责具体的实现</strong>。</p>\n<p>桥接模式的核心思想是抽象部分与实现部分分离，通过将抽象部分与实现部分解耦，可以灵活地组合它们，从而达到扩展和复用的目的。</p>\n<h3 id=\"代码示例-3\"><a href=\"#代码示例-3\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><p>下面是一个简单的 JavaScript 桥接模式的示例，假设有一个形状类 Shape 和一个颜色类 Color，我们可以使用桥接模式将它们分离，实现一个可以随意组合形状和颜色的对象。代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Shape &#123;\n  constructor(color) &#123;\n    this.color &#x3D; color;\n  &#125;\n  draw() &#123;\n    console.log(&#96;Drawing $&#123;this.color&#125; $&#123;this.name&#125;&#96;);\n  &#125;\n&#125;\n\nclass Circle extends Shape &#123;\n  constructor(color) &#123;\n    super(color);\n    this.name &#x3D; &#39;Circle&#39;;\n  &#125;\n&#125;\n\nclass Square extends Shape &#123;\n  constructor(color) &#123;\n    super(color);\n    this.name &#x3D; &#39;Square&#39;;\n  &#125;\n&#125;\n\nclass Color &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nclass Red extends Color &#123;\n  constructor() &#123;\n    super(&#39;Red&#39;);\n  &#125;\n&#125;\n\nclass Blue extends Color &#123;\n  constructor() &#123;\n    super(&#39;Blue&#39;);\n  &#125;\n&#125;\n\nclass ShapeWithColor &#123;\n  constructor(shape, color) &#123;\n    this.shape &#x3D; shape;\n    this.color &#x3D; color;\n  &#125;\n  draw() &#123;\n    console.log(&#96;Drawing $&#123;this.color.name&#125; $&#123;this.shape.name&#125;&#96;);\n  &#125;\n&#125;\n\nconst redCircle &#x3D; new ShapeWithColor(new Circle(), new Red());\nredCircle.draw(); &#x2F;&#x2F; Drawing Red Circle\n\nconst blueSquare &#x3D; new ShapeWithColor(new Square(), new Blue());\nblueSquare.draw(); &#x2F;&#x2F; Drawing Blue Square</code></pre>\n\n<p>在上面的示例中，我们<strong>将 Shape 和 Color 类分别作为抽象部分和实现部分，然后使用 ShapeWithColor 类将它们组合起来</strong>，从而实现了可以随意组合形状和颜色的对象。</p>\n<h3 id=\"简化后\"><a href=\"#简化后\" class=\"headerlink\" title=\"简化后\"></a>简化后</h3><p>桥接模式（Bridge Pattern）是一种结构型设计模式，它可以将一个大类或者一系列紧密相关的类拆分成抽象和实现两个独立的层次，从而能在开发过程中分别使用它们。</p>\n<p>桥接模式主要用于分离抽象与实现，以便两者可以独立地变化。它通过使用聚合关系（而不是继承关系）将两个独立变化的维度分离出来，使它们可以独立地扩展，提高了系统的灵活性和可维护性。</p>\n<p>在桥接模式中，抽象部分定义了一个接口，它包含一个指向实现部分的引用。抽象部分中的方法将调用实现部分的方法，从而完成具体的业务逻辑。</p>\n<p>常见的桥接模式应用场景包括图形用户界面设计中的窗口管理器，以及多媒体应用程序中的播放器控制器等。</p>\n<h3 id=\"没理解\"><a href=\"#没理解\" class=\"headerlink\" title=\"没理解\"></a>没理解</h3><p><strong>桥接模式的目的是分离抽象和实现，通过这种方式可以使它们各自独立变化，从而提高系统的灵活性和可维护性。</strong></p>\n<p>举个例子，我们可以把一个程序分为抽象部分和实现部分，其中抽象部分定义了一个接口，并包含一个指向实现部分的引用。抽象部分中的方法将调用实现部分的方法，从而完成具体的业务逻辑。这样，当我们需要扩展系统时，只需要修改实现部分而不用修改抽象部分，从而减少了对系统的影响范围。</p>\n<p>在实际应用中，<strong>桥接模式经常用于图形用户界面设计中的窗口管理器和多媒体应用程序中的播放器控制器等</strong>。例如，在窗口管理器中，我们可以将窗口的抽象部分定义为一个接口，包含打开、关闭、最小化等方法，然后通过实现部分来实现这些方法。在实现部分中，我们可以使用不同的技术来实现这些方法，比如使用 Win32 API、Qt 或者 Java Swing 等不同的 GUI 工具包。</p>\n<p>总之，桥接模式可以帮助我们将一个复杂的系统分解成简单的部分，从而降低系统的复杂性和耦合度，提高系统的可维护性和可扩展性。</p>\n<h2 id=\"桥接模式和组合模式的区别\"><a href=\"#桥接模式和组合模式的区别\" class=\"headerlink\" title=\"桥接模式和组合模式的区别\"></a>桥接模式和组合模式的区别</h2><p>桥接模式是为了解决抽象和实现之间的耦合问题，而组合模式是为了表示部分-整体的层次结构。</p>\n<h2 id=\"js-享元模式【缓存】\"><a href=\"#js-享元模式【缓存】\" class=\"headerlink\" title=\"js 享元模式【缓存】\"></a>js 享元模式【缓存】</h2><p>享元模式（Flyweight Pattern）是一种<strong>结构型设计模式，它主要是用来优化性能和内存占用</strong>。它通过共享对象的方式来减少内存中对象的数量，从而提高程序的性能和效率。</p>\n<p>该模式的核心思想是将一个类中的一些属性和方法拆分成多个可复用的对象，这些可复用的对象可以被多个不同的对象所共享使用，从而减少内存中的重复对象的数量。</p>\n<p>在 JavaScript 中，享元模式的一个常见应用场景是通过共享对象来优化性能，例如在 DOM 操作中使用对象池，或者在游戏开发中使用纹理缓存等。</p>\n<p>好的，以下是一个简单的示例：</p>\n<p>假设有一个网站需要展示多张图片，并且每张图片都有相同的一些属性，例如宽度、高度和类型等。我们可以使用享元模式来避免创建大量相同的图片对象。</p>\n<p>首先，我们定义一个 Image 类，它包含宽度、高度和类型等属性：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Image &#123;\n  constructor(width, height, type) &#123;\n    this.width &#x3D; width;\n    this.height &#x3D; height;\n    this.type &#x3D; type;\n  &#125;\n  display(x, y) &#123;\n    console.log(&#96;Displaying $&#123;this.type&#125; image ($&#123;this.width&#125; x $&#123;this.height&#125;) at ($&#123;x&#125;, $&#123;y&#125;)&#96;);\n  &#125;\n&#125;</code></pre>\n\n<p>接下来，我们定义一个 ImageFactory 工厂类，它可以创建并管理图片对象。这个工厂类包含一个 images 对象，用于缓存已创建的图片对象。如果请求创建的图片已存在，则直接返回缓存中的图片对象，否则创建一个新的图片对象并加入缓存：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class ImageFactory &#123;\n  constructor() &#123;\n    this.images &#x3D; &#123;&#125;;\n  &#125;\n  getImage(width, height, type) &#123;\n    const key &#x3D; &#96;$&#123;width&#125;x$&#123;height&#125;_$&#123;type&#125;&#96;;\n    if (!this.images[key]) &#123;\n      this.images[key] &#x3D; new Image(width, height, type);\n    &#125;\n    return this.images[key];\n  &#125;\n&#125;</code></pre>\n\n<p>最后，我们可以使用 ImageFactory 工厂类来创建并展示多张图片。由于相同属性的图片对象被缓存起来了，因此我们只需要创建一次即可，可以大大减少创建对象的数量：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const factory &#x3D; new ImageFactory();\nconst image1 &#x3D; factory.getImage(100, 100, &#39;png&#39;);\nimage1.display(0, 0);\n\nconst image2 &#x3D; factory.getImage(100, 100, &#39;png&#39;);\nimage2.display(100, 0);\n\nconst image3 &#x3D; factory.getImage(200, 200, &#39;jpg&#39;);\nimage3.display(0, 100);\n\nconst image4 &#x3D; factory.getImage(200, 200, &#39;jpg&#39;);\nimage4.display(200, 100);</code></pre>\n\n<p>输出结果为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Displaying png image (100 x 100) at (0, 0)\nDisplaying png image (100 x 100) at (100, 0)\nDisplaying jpg image (200 x 200) at (0, 100)\nDisplaying jpg image (200 x 200) at (200, 100)</code></pre>\n\n<p>可以看到，虽然我们创建了 4 张图片，但实际上只有 2 个不同的图片对象被创建并缓存，可以减少内存的使用。</p>\n<h2 id=\"js-外观模式\"><a href=\"#js-外观模式\" class=\"headerlink\" title=\"js 外观模式\"></a>js 外观模式</h2><p>JavaScript 外观模式（Facade Pattern）是一种结构型设计模式，<strong>用于为复杂系统提供简化的界面。它通过隐藏系统的复杂性，并提供一个易于使用的接口，使得客户端更容易使用系统</strong>。</p>\n<p>在外观模式中，我们定义一个简单的接口，该接口隐藏了复杂的系统，并将其暴露给客户端。这使得客户端可以使用一个简单的接口来与系统交互，而不需要了解系统内部的复杂性。</p>\n<h3 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例 1\"></a>代码示例 1</h3><p>以下是一个简单的 JavaScript 外观模式的示例，它封装了一个音频播放器的复杂性，为客户端提供了一个简单的接口来控制音频播放。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class AudioPlayer &#123;\n  constructor() &#123;\n    this.audio &#x3D; new Audio();\n  &#125;\n\n  play() &#123;\n    this.audio.play();\n  &#125;\n\n  pause() &#123;\n    this.audio.pause();\n  &#125;\n\n  setVolume(volume) &#123;\n    this.audio.volume &#x3D; volume;\n  &#125;\n\n  setSource(source) &#123;\n    this.audio.src &#x3D; source;\n  &#125;\n&#125;\n\nclass AudioPlayerFacade &#123;\n  constructor() &#123;\n    this.audioPlayer &#x3D; new AudioPlayer();\n  &#125;\n\n  play(source, volume) &#123;\n    this.audioPlayer.setSource(source);\n    this.audioPlayer.setVolume(volume);\n    this.audioPlayer.play();\n  &#125;\n\n  pause() &#123;\n    this.audioPlayer.pause();\n  &#125;\n\n  stop() &#123;\n    this.audioPlayer.pause();\n    this.audioPlayer.setSource(&#39;&#39;);\n  &#125;\n\n  setVolume(volume) &#123;\n    this.audioPlayer.setVolume(volume);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nconst audioPlayerFacade &#x3D; new AudioPlayerFacade();\naudioPlayerFacade.play(&#39;audio.mp3&#39;, 0.5);</code></pre>\n\n<p>在上面的示例中，我们创建了一个 <code>AudioPlayer</code> 类，它封装了 HTML5 <code>audio</code> 元素的复杂性，提供了 <code>play</code>、<code>pause</code>、<code>setVolume</code> 和 <code>setSource</code> 等方法。</p>\n<p>然后我们创建了一个 <code>AudioPlayerFacade</code> 类，它使用 <code>AudioPlayer</code> 类的实例作为其内部对象，并提供了一个简单的接口来控制音频播放。<code>AudioPlayerFacade</code> 类的 <code>play</code> 方法调用 <code>AudioPlayer</code> 类的 <code>setSource</code> 和 <code>setVolume</code> 方法，并调用 <code>play</code> 方法来开始播放音频。</p>\n<p>最后，我们创建了一个 <code>AudioPlayerFacade</code> 的实例，并调用其 <code>play</code> 方法，这个方法接受音频源和音量作为参数，然后开始播放音频。由于 <code>AudioPlayerFacade</code> 封装了 <code>AudioPlayer</code> 类的复杂性，因此客户端不需要了解内部的实现细节，只需要调用 <code>play</code> 方法并传递参数即可。</p>\n<h3 id=\"代码示例-2\"><a href=\"#代码示例-2\" class=\"headerlink\" title=\"代码示例 2\"></a>代码示例 2</h3><p>下面是一个简单的外观模式示例：</p>\n<p>假设我们有一个计算器对象，可以进行加减乘除等运算，但是每种运算都需要调用不同的方法，代码可能会比较复杂。这时我们可以使用外观模式，创建一个外观对象，封装这些方法，使得客户端可以简单地使用这些方法进行计算。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 计算器对象\nconst Calculator &#x3D; &#123;\n  add: function (num1, num2) &#123;\n    return num1 + num2;\n  &#125;,\n  subtract: function (num1, num2) &#123;\n    return num1 - num2;\n  &#125;,\n  multiply: function (num1, num2) &#123;\n    return num1 * num2;\n  &#125;,\n  divide: function (num1, num2) &#123;\n    return num1 &#x2F; num2;\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 外观对象，封装计算器对象的方法\nconst CalculatorFacade &#x3D; &#123;\n  add: function (num1, num2) &#123;\n    return Calculator.add(num1, num2);\n  &#125;,\n  subtract: function (num1, num2) &#123;\n    return Calculator.subtract(num1, num2);\n  &#125;,\n  multiply: function (num1, num2) &#123;\n    return Calculator.multiply(num1, num2);\n  &#125;,\n  divide: function (num1, num2) &#123;\n    return Calculator.divide(num1, num2);\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 客户端代码，可以直接使用外观对象提供的简单方法进行计算\nconsole.log(CalculatorFacade.add(2, 3)); &#x2F;&#x2F; 输出 5\nconsole.log(CalculatorFacade.multiply(2, 3)); &#x2F;&#x2F; 输出 6</code></pre>\n\n<p>在上面的例子中，<code>Calculator</code>对象是具体的计算器实现，包含了加减乘除等方法。<code>CalculatorFacade</code>对象是外观对象，封装了<code>Calculator</code>对象的方法，客户端代码可以直接使用外观对象提供的简单方法进行计算。</p>\n<p>这样，客户端代码就不需要直接与具体的计算器实现打交道，而是通过外观对象来简单地使用计算器功能。这就是外观模式的作用。</p>\n<h3 id=\"ES6-export-也是外观模式？\"><a href=\"#ES6-export-也是外观模式？\" class=\"headerlink\" title=\"ES6 export 也是外观模式？\"></a>ES6 export 也是外观模式？</h3><p>在 ES6 中，export 并不是外观模式。export 用于将模块内的内容导出，使得其他模块可以引用这些内容。它并没有对模块内的实现进行封装，也没有提供简化接口的功能。</p>\n<p>而外观模式的主要作用是对复杂的子系统进行封装，提供简单的接口给客户端使用，隐藏子系统的复杂性和实现细节，让客户端更加方便地使用子系统。</p>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><p>策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，将它们封装起来，并且使它们可以相互替换。策略模式让算法的变化独立于使用它们的客户端。</p>\n<p>在策略模式中，一般会有一个 Context（上下文）类，它包含一个 Strategy（策略）接口的引用，这个引用指向具体的算法实现类。客户端可以通过 Context 来使用这些算法，而不需要直接与算法实现类进行交互。</p>\n<h3 id=\"策略模式示例-1\"><a href=\"#策略模式示例-1\" class=\"headerlink\" title=\"策略模式示例 1\"></a>策略模式示例 1</h3><p>下面是一个 JavaScript 的策略模式示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 策略接口\nclass Strategy &#123;\n  doOperation(num1, num2) &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; 具体策略类\nclass OperationAdd extends Strategy &#123;\n  doOperation(num1, num2) &#123;\n    return num1 + num2;\n  &#125;\n&#125;\n\nclass OperationSubtract extends Strategy &#123;\n  doOperation(num1, num2) &#123;\n    return num1 - num2;\n  &#125;\n&#125;\n\nclass OperationMultiply extends Strategy &#123;\n  doOperation(num1, num2) &#123;\n    return num1 * num2;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 上下文类\nclass Context &#123;\n  constructor(strategy) &#123;\n    this.strategy &#x3D; strategy;\n  &#125;\n\n  executeStrategy(num1, num2) &#123;\n    return this.strategy.doOperation(num1, num2);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用\nconst contextAdd &#x3D; new Context(new OperationAdd());\nconsole.log(contextAdd.executeStrategy(1, 2)); &#x2F;&#x2F; 输出 3\n\nconst contextSubtract &#x3D; new Context(new OperationSubtract());\nconsole.log(contextSubtract.executeStrategy(1, 2)); &#x2F;&#x2F; 输出 -1\n\nconst contextMultiply &#x3D; new Context(new OperationMultiply());\nconsole.log(contextMultiply.executeStrategy(2, 3)); &#x2F;&#x2F; 输出 6</code></pre>\n\n<p>在上面的示例中，<code>Strategy</code>是策略接口，定义了一个<code>doOperation</code>方法。具体的算法实现类（如<code>OperationAdd</code>）继承自<code>Strategy</code>并实现了<code>doOperation</code>方法。<code>Context</code>是上下文类，它包含一个对<code>Strategy</code>接口的引用，这个引用可以指向任何实现了<code>Strategy</code>接口的具体类。<code>Context</code>类中有一个<code>executeStrategy</code>方法，它调用了<code>Strategy</code>接口的方法，实现了不同算法之间的相互替换。</p>\n<h3 id=\"策略模式和桥接模式的区别\"><a href=\"#策略模式和桥接模式的区别\" class=\"headerlink\" title=\"策略模式和桥接模式的区别\"></a>策略模式和桥接模式的区别</h3><p>虽然策略模式和桥接模式都涉及到对象的组合和分离，但它们的主要区别在于解决的问题不同。</p>\n<p><strong>桥接模式主要用于解决多维度变化的情况</strong>，例如一个类的多个维度（例如颜色、大小、形状等）都可能变化，这些维度之间可以互相组合，而桥接模式可以将这些维度分离出来，使得它们可以独立变化，而不影响其他维度。</p>\n<p><strong>策略模式主要用于解决算法的多样性问题</strong>，例如需要根据不同的场景或条件选择不同的算法来实现相同的功能，策略模式可以将算法封装成不同的策略类，通过切换不同的策略类来改变算法的行为。</p>\n<p>因此，虽然策略模式和桥接模式都涉及到组合和分离，但它们的目的和解决的问题不同。</p>\n<h3 id=\"策略模式例子-2\"><a href=\"#策略模式例子-2\" class=\"headerlink\" title=\"策略模式例子 2\"></a>策略模式例子 2</h3><p>一个简单的策略模式的例子是实现一个排序函数，可以根据不同的排序算法进行排序。</p>\n<p>首先，我们定义一个 Sort 类，该类将包含一组排序算法的策略：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Sort &#123;\n  constructor(strategy) &#123;\n    this.strategy &#x3D; strategy;\n  &#125;\n\n  setStrategy(strategy) &#123;\n    this.strategy &#x3D; strategy;\n  &#125;\n\n  sort(data) &#123;\n    return this.strategy.sort(data);\n  &#125;\n&#125;</code></pre>\n\n<p>然后，我们可以定义一组排序策略，比如<code>插入排序</code>、<code>冒泡排序</code>和<code>快速排序</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class InsertionSort &#123;\n  sort(data) &#123;\n    console.log(&#39;Sorting using insertion sort&#39;);\n    &#x2F;&#x2F; 插入排序实现代码\n    return data;\n  &#125;\n&#125;\n\nclass BubbleSort &#123;\n  sort(data) &#123;\n    console.log(&#39;Sorting using bubble sort&#39;);\n    &#x2F;&#x2F; 冒泡排序实现代码\n    return data;\n  &#125;\n&#125;\n\nclass QuickSort &#123;\n  sort(data) &#123;\n    console.log(&#39;Sorting using quick sort&#39;);\n    &#x2F;&#x2F; 快速排序实现代码\n    return data;\n  &#125;\n&#125;</code></pre>\n\n<p>现在，我们可以使用 Sort 类来排序一个数组。例如，我们可以使用插入排序策略来对数组进行排序：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const data &#x3D; [3, 1, 4, 2];\nconst sort &#x3D; new Sort(new InsertionSort());\nconsole.log(sort.sort(data)); &#x2F;&#x2F; 输出 [1, 2, 3, 4]</code></pre>\n\n<p>也可以在运行时更改策略，比如我们在排序后决定使用快速排序：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">sort.setStrategy(new QuickSort());\nconsole.log(sort.sort(data)); &#x2F;&#x2F; 输出 [1, 2, 3, 4]</code></pre>\n\n<p>这里的关键是将不同的排序算法封装为不同的策略类，使得它们可以相互替换，同时使用 Sort 类来调用不同的策略类实现不同的排序算法。</p>\n<h3 id=\"策略模式例子-3\"><a href=\"#策略模式例子-3\" class=\"headerlink\" title=\"策略模式例子 3\"></a>策略模式例子 3</h3><p>好的，以下是另一个策略模式的例子：</p>\n<p>假设你正在开发一个电商网站，需要计算商品的价格。每个商品的价格计算方式可能不同，比如有些商品是按照重量计算价格，有些商品是按照数量计算价格，还有些商品可能是按照尺寸、颜色等多种因素计算价格。这就可以使用策略模式来实现。</p>\n<p>首先，定义一个价格计算策略的接口 <code>PriceStrategy</code>，该接口有一个方法 <code>calculatePrice</code>，用于计算商品的价格：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 价格计算策略接口\nclass PriceStrategy &#123;\n  calculatePrice(product) &#123;\n    throw new Error(&#39;calculatePrice method must be implemented&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>然后，定义不同的价格计算策略，比如按照重量计算价格的策略 <code>WeightPriceStrategy</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 按照重量计算价格的策略\nclass WeightPriceStrategy extends PriceStrategy &#123;\n  calculatePrice(product) &#123;\n    return product.weight * product.pricePerKg;\n  &#125;\n&#125;</code></pre>\n\n<p>还可以定义按照数量计算价格的策略 <code>QuantityPriceStrategy</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 按照数量计算价格的策略\nclass QuantityPriceStrategy extends PriceStrategy &#123;\n  calculatePrice(product) &#123;\n    return product.quantity * product.pricePerUnit;\n  &#125;\n&#125;</code></pre>\n\n<p>最后，定义一个 <code>Product</code> 类，它包含商品的信息和使用的价格计算策略：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Product &#123;\n  constructor(name, pricePerUnit, pricePerKg, weight, quantity, priceStrategy) &#123;\n    this.name &#x3D; name;\n    this.pricePerUnit &#x3D; pricePerUnit;\n    this.pricePerKg &#x3D; pricePerKg;\n    this.weight &#x3D; weight;\n    this.quantity &#x3D; quantity;\n    this.priceStrategy &#x3D; priceStrategy;\n  &#125;\n\n  getPrice() &#123;\n    return this.priceStrategy.calculatePrice(this);\n  &#125;\n&#125;</code></pre>\n\n<p>使用策略模式的好处在于，你可以很方便地添加新的价格计算策略，只需要定义一个新的策略类，实现 <code>PriceStrategy</code> 接口即可。同时，每个商品对象都可以使用不同的价格计算策略，方便灵活地处理各种计价方式。</p>\n<h2 id=\"js-模版模式\"><a href=\"#js-模版模式\" class=\"headerlink\" title=\"js 模版模式\"></a>js 模版模式</h2><p>模板模式是一种行为设计模式，<strong>它定义了一个算法的骨架，将一些步骤的实现留给子类来完成</strong>。<strong>这样可以在不改变算法结构的前提下，通过子类的实现来定制算法的具体实现</strong>。</p>\n<p>下面是一个简单的 JavaScript 示例，展示了如何使用模板模式：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class AbstractClass &#123;\n  templateMethod() &#123;\n    this.doStep1();\n    this.doStep2();\n    this.doStep3();\n  &#125;\n&#125;\n\nclass ConcreteClass extends AbstractClass &#123;\n  doStep1() &#123;\n    console.log(&#39;ConcreteClass doStep1&#39;);\n  &#125;\n\n  doStep2() &#123;\n    console.log(&#39;ConcreteClass doStep2&#39;);\n  &#125;\n\n  doStep3() &#123;\n    console.log(&#39;ConcreteClass doStep3&#39;);\n  &#125;\n&#125;\n\nconst concrete &#x3D; new ConcreteClass();\nconcrete.templateMethod();</code></pre>\n\n<p>在上面的示例中，<code>AbstractClass</code> 是一个抽象类，其中 <code>templateMethod</code> 是模板方法，它定义了算法的基本骨架，<code>ConcreteClass</code> 是一个具体子类，它通过实现 <code>AbstractClass</code> 中定义的抽象方法来完成算法中的具体步骤。在 <code>ConcreteClass</code> 中实现的具体步骤会被模板方法按照预定的顺序调用，从而完成整个算法的执行。最后，我们通过创建一个 <code>ConcreteClass</code> 对象来调用算法。</p>\n<p>需要注意的是，在模板模式中，模板方法应该是不可被子类修改的，只有抽象方法才应该由子类来实现，以保证算法的整体结构不被破坏。</p>\n<h3 id=\"在抽象类方法中-为什么可以通过-this-调用到子类的方法\"><a href=\"#在抽象类方法中-为什么可以通过-this-调用到子类的方法\" class=\"headerlink\" title=\"在抽象类方法中, 为什么可以通过 this 调用到子类的方法\"></a>在抽象类方法中, 为什么可以通过 this 调用到子类的方法</h3><p>在 JavaScript 中并不存在抽象类，但是可以通过使用函数、对象、类等方式来实现类似于抽象类的效果。</p>\n<p>在模板方法模式中，我们定义了一个抽象基类，它提供了一个模板方法，该方法定义了一系列抽象操作的执行顺序，并在其中调用了一些具体的操作方法，这些具体的操作方法由子类去实现。在 JavaScript 中，我们可以使用函数来实现这样的模板方法。</p>\n<p><strong>在 JavaScript 中，函数的 this 指向调用该函数的对象。</strong></p>\n<p><strong>在模板方法模式中，模板方法定义在抽象基类中，而具体的操作方法则在子类中实现。当我们调用抽象基类中的模板方法时，其实是通过子类对象去调用的，此时的 this 指向的就是子类对象</strong>，因此可以通过 this 调用子类实现的方法。</p>\n<h3 id=\"子类对象为什么可以调用到抽象基类的方法？\"><a href=\"#子类对象为什么可以调用到抽象基类的方法？\" class=\"headerlink\" title=\"子类对象为什么可以调用到抽象基类的方法？\"></a>子类对象为什么可以调用到抽象基类的方法？</h3><p>子类对象之所以可以调用到抽象基类的方法，是因为子类通过继承了抽象基类，获得了基类的所有成员，包括方法。在 JavaScript 中，子类可以使用 <code>extends</code> 关键字继承父类，这样子类就可以访问父类的方法和属性。</p>\n<p>在抽象基类中，可以定义抽象方法，即只有方法名称、参数和返回类型，没有具体的实现代码。子类必须实现抽象方法，否则会在编译期间报错。当子类调用基类中的抽象方法时，会自动调用子类中实现的具体方法，这也是实现多态的一种方式。</p>\n<p>总之，子类通过继承抽象基类获得了基类的方法和属性，也可以在子类中实现基类中定义的抽象方法，从而实现多态。</p>\n<h3 id=\"extends-关键字-有哪些作用\"><a href=\"#extends-关键字-有哪些作用\" class=\"headerlink\" title=\"extends 关键字 有哪些作用\"></a>extends 关键字 有哪些作用</h3><p>在 JavaScript 中，<code>extends</code> 是一个用于创建子类的关键字，它有以下几个作用：</p>\n<ol>\n<li><p>实现继承：使用 <code>extends</code> 关键字可以让一个类继承另一个类的所有属性和方法，从而避免了重复编写相同的代码。</p>\n</li>\n<li><p>父类调用：在子类的构造函数中，可以使用 <code>super</code> 关键字来调用父类的构造函数，从而初始化父类中的属性。</p>\n</li>\n<li><p>方法重写：子类可以重写父类中的方法，从而实现自己的业务逻辑。</p>\n</li>\n<li><p>父类访问限制：通过 <code>super</code> 关键字，子类可以访问到父类中的 <code>public</code> 和 <code>protected</code> 属性和方法，但无法访问 <code>private</code> 属性和方法。</p>\n</li>\n</ol>\n<p>使用 <code>extends</code> 关键字可以让我们更加方便地实现面向对象编程中的继承和多态。</p>\n<h2 id=\"js-责任链模式\"><a href=\"#js-责任链模式\" class=\"headerlink\" title=\"js 责任链模式\"></a>js 责任链模式</h2><p>责任链模式是一种行为设计模式，它允许你将请求沿着处理者链进行发送，直到其中一个处理者对其进行处理为止。责任链模式中的处理者对象组成一条链，请求在这条链上传递，直到有一个处理者处理该请求。如果当前处理者不能处理请求，则将请求传递给下一个处理者进行处理，直到请求被处理或者所有处理者都无法处理为止。</p>\n<h3 id=\"代码示例-4\"><a href=\"#代码示例-4\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><p>在 JavaScript 中，可以通过构造函数和原型链的方式来实现责任链模式。具体实现方式如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 抽象处理者\nclass Handler &#123;\n  constructor() &#123;\n    this.nextHandler &#x3D; null;\n  &#125;\n  setNext(handler) &#123;\n    this.nextHandler &#x3D; handler;\n    return handler;\n  &#125;\n  handle(request) &#123;\n    if (this.nextHandler) &#123;\n      return this.nextHandler.handle(request);\n    &#125;\n    return null;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 具体处理者A\nclass ConcreteHandlerA extends Handler &#123;\n  handle(request) &#123;\n    if (request &#x3D;&#x3D;&#x3D; &#39;A&#39;) &#123;\n      return &#96;Request $&#123;request&#125; handled by ConcreteHandlerA&#96;;\n    &#125; else &#123;\n      return super.handle(request);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 具体处理者B\nclass ConcreteHandlerB extends Handler &#123;\n  handle(request) &#123;\n    if (request &#x3D;&#x3D;&#x3D; &#39;B&#39;) &#123;\n      return &#96;Request $&#123;request&#125; handled by ConcreteHandlerB&#96;;\n    &#125; else &#123;\n      return super.handle(request);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 具体处理者C\nclass ConcreteHandlerC extends Handler &#123;\n  handle(request) &#123;\n    if (request &#x3D;&#x3D;&#x3D; &#39;C&#39;) &#123;\n      return &#96;Request $&#123;request&#125; handled by ConcreteHandlerC&#96;;\n    &#125; else &#123;\n      return super.handle(request);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 客户端代码\nconst handlerA &#x3D; new ConcreteHandlerA();\nconst handlerB &#x3D; new ConcreteHandlerB();\nconst handlerC &#x3D; new ConcreteHandlerC();\n\nhandlerA.setNext(handlerB).setNext(handlerC);\n\nconsole.log(handlerA.handle(&#39;B&#39;)); &#x2F;&#x2F; 输出: Request B handled by ConcreteHandlerB\nconsole.log(handlerA.handle(&#39;D&#39;)); &#x2F;&#x2F; 输出: null</code></pre>\n\n<p>在上面的示例中，我们定义了抽象处理者 <code>Handler</code> 和具体处理者 <code>ConcreteHandlerA</code>、<code>ConcreteHandlerB</code>、<code>ConcreteHandlerC</code>。每个具体处理者都可以处理特定的请求，如果无法处理则将请求传递给下一个处理者进行处理，最终如果所有的处理者都无法处理该请求，则返回 null。</p>\n<p>客户端代码中，我们创建了具体处理者的实例，并将它们组成责任链。当请求传递到责任链上时，责任链中的处理者依次尝试处理该请求，直到有一个处理者能够处理该请求或者所有的处理者都无法处理该请求。</p>\n<h3 id=\"上述代码-nextHandler-是链的指针？\"><a href=\"#上述代码-nextHandler-是链的指针？\" class=\"headerlink\" title=\"上述代码 nextHandler 是链的指针？\"></a>上述代码 nextHandler 是链的指针？</h3><p>是的，<code>nextHandler</code> 变量指向下一个处理请求的对象，通过链式调用，实现请求在链上传递的效果。<br>当一个处理者处理完请求后，会将请求传递给 <code>nextHandler</code> 处理，如果当前处理者没有后继者，则直接结束请求。</p>\n<h3 id=\"注意-this\"><a href=\"#注意-this\" class=\"headerlink\" title=\"注意 this\"></a>注意 this</h3><h2 id=\"js-备忘录模式\"><a href=\"#js-备忘录模式\" class=\"headerlink\" title=\"js 备忘录模式\"></a>js 备忘录模式</h2><p>假设我们正在开发一个记事本应用程序，我们想要实现一个可以撤销和重做操作的功能。这时候就可以使用备忘录模式。</p>\n<p>下面是一个简单的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class TextEditor &#123;\n  constructor() &#123;\n    this.text &#x3D; &#39;&#39;;\n    this.history &#x3D; [];\n    this.historyIndex &#x3D; -1;\n  &#125;\n\n  write(text) &#123;\n    this.text +&#x3D; text;\n  &#125;\n\n  undo() &#123;\n    if (this.historyIndex &gt; 0) &#123;\n      this.historyIndex--;\n      this.text &#x3D; this.history[this.historyIndex];\n    &#125;\n  &#125;\n\n  redo() &#123;\n    if (this.historyIndex &lt; this.history.length - 1) &#123;\n      this.historyIndex++;\n      this.text &#x3D; this.history[this.historyIndex];\n    &#125;\n  &#125;\n\n  save() &#123;\n    this.historyIndex++;\n    this.history[this.historyIndex] &#x3D; this.text;\n  &#125;\n&#125;\n\nconst editor &#x3D; new TextEditor();\neditor.write(&#39;Hello, &#39;);\neditor.write(&#39;world!&#39;);\neditor.save();\nconsole.log(editor.text); &#x2F;&#x2F; &#39;Hello, world!&#39;\neditor.undo();\nconsole.log(editor.text); &#x2F;&#x2F; &#39;Hello, &#39;\neditor.redo();\nconsole.log(editor.text); &#x2F;&#x2F; &#39;Hello, world!&#39;</code></pre>\n\n<p>在上面的示例中，<code>TextEditor</code> 类表示一个文本编辑器，它有 <code>write</code> 方法可以向编辑器中添加文本，<code>undo</code> 和 <code>redo</code> 方法可以撤销和重做操作，<code>save</code> 方法可以保存当前状态到历史记录中。</p>\n<p>每次调用 <code>save</code> 方法时，都会将当前文本的状态保存到历史记录中。当调用 <code>undo</code> 方法时，会将当前文本的状态恢复到上一个历史记录中保存的状态；当调用 <code>redo</code> 方法时，会将当前文本的状态恢复到下一个历史记录中保存的状态。</p>\n<p>在这个示例中，历史记录的状态就是备忘录对象，<code>TextEditor</code> 类就是负责管理备忘录对象的负责人。</p>\n<h2 id=\"js-命令模式\"><a href=\"#js-命令模式\" class=\"headerlink\" title=\"js 命令模式\"></a>js 命令模式</h2><p>好的，以下是一个更简单的示例：</p>\n<p>假设我们有一个遥控器，可以控制一盏灯的开关，同时遥控器还有一个撤销按钮，可以撤销最近一次的操作。</p>\n<p>我们可以使用命令模式来实现这个遥控器，具体实现如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Light &#123;\n  turnOn() &#123;\n    console.log(&#39;Light is on&#39;);\n  &#125;\n\n  turnOff() &#123;\n    console.log(&#39;Light is off&#39;);\n  &#125;\n&#125;\n\nclass LightOnCommand &#123;\n  constructor(light) &#123;\n    this.light &#x3D; light;\n  &#125;\n\n  execute() &#123;\n    this.light.turnOn();\n  &#125;\n\n  undo() &#123;\n    this.light.turnOff();\n  &#125;\n&#125;\n\nclass LightOffCommand &#123;\n  constructor(light) &#123;\n    this.light &#x3D; light;\n  &#125;\n\n  execute() &#123;\n    this.light.turnOff();\n  &#125;\n\n  undo() &#123;\n    this.light.turnOn();\n  &#125;\n&#125;\n\nclass RemoteControl &#123;\n  constructor() &#123;\n    this.commands &#x3D; [];\n    this.undoCommand &#x3D; null;\n  &#125;\n\n  setCommand(command) &#123;\n    this.commands.push(command);\n  &#125;\n\n  pressButton() &#123;\n    if (this.commands.length &gt; 0) &#123;\n      const command &#x3D; this.commands[this.commands.length - 1];\n      command.execute();\n      this.undoCommand &#x3D; command;\n      this.commands.pop();\n    &#125; else &#123;\n      console.log(&#39;No commands to execute&#39;);\n    &#125;\n  &#125;\n\n  pressUndo() &#123;\n    if (this.undoCommand) &#123;\n      this.undoCommand.undo();\n    &#125; else &#123;\n      console.log(&#39;No command to undo&#39;);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; usage\nconst light &#x3D; new Light();\nconst lightOnCommand &#x3D; new LightOnCommand(light);\nconst lightOffCommand &#x3D; new LightOffCommand(light);\n\nconst remoteControl &#x3D; new RemoteControl();\n\nremoteControl.setCommand(lightOnCommand);\nremoteControl.pressButton(); &#x2F;&#x2F; &quot;Light is on&quot;\nremoteControl.pressUndo(); &#x2F;&#x2F; &quot;Light is off&quot;\n\nremoteControl.setCommand(lightOffCommand);\nremoteControl.pressButton(); &#x2F;&#x2F; &quot;Light is off&quot;\nremoteControl.pressUndo(); &#x2F;&#x2F; &quot;Light is on&quot;</code></pre>\n\n<p>在上述示例中，<code>Light</code> 表示灯的类，<code>LightOnCommand</code> 和 <code>LightOffCommand</code> 分别表示灯的开和关的命令，<code>RemoteControl</code> 表示遥控器类。</p>\n<p>我们可以通过遥控器的 <code>setCommand</code> 方法来设置要执行的命令，然后通过 <code>pressButton</code> 方法执行最近的命令，同时也可以通过 <code>pressUndo</code> 方法撤销最近的一次操作。</p>\n<h2 id=\"js-中介者模式\"><a href=\"#js-中介者模式\" class=\"headerlink\" title=\"js 中介者模式\"></a>js 中介者模式</h2><p>中介者模式是一种行为型设计模式，<strong>它可以让对象之间不直接相互交互，而是通过一个中介对象进行沟通</strong>。在这种模式下，对象之间不需要知道彼此的存在，只需要和中介者对象进行通信即可。</p>\n<p>举个简单的例子，假设我们有一个聊天室，里面有多个用户，这些用户都可以相互发送消息。当一个用户发送消息时，它需要将这个消息发送给聊天室中的所有其他用户，这时候就可以使用中介者模式。</p>\n<p>在这个例子中，聊天室就是中介者对象，用户之间不直接进行通信，而是通过聊天室进行消息的发送和接收。这样可以将聊天室作为一个单独的模块进行维护，避免了多个用户之间直接交互所带来的复杂性。</p>\n<p>以下是一个简单的 JavaScript 中介者模式的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class ChatRoom &#123;\n  showMessage(user, message) &#123;\n    console.log(&#96;[$&#123;user.getName()&#125;]: $&#123;message&#125;&#96;);\n  &#125;\n&#125;\n\nclass User &#123;\n  constructor(name, chatRoom) &#123;\n    this.name &#x3D; name;\n    this.chatRoom &#x3D; chatRoom;\n  &#125;\n\n  getName() &#123;\n    return this.name;\n  &#125;\n\n  sendMessage(message) &#123;\n    this.chatRoom.showMessage(this, message);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建一个聊天室\nconst chatRoom &#x3D; new ChatRoom();\n\n&#x2F;&#x2F; 创建多个用户，并将它们加入到聊天室中\nconst user1 &#x3D; new User(&#39;Alice&#39;, chatRoom);\nconst user2 &#x3D; new User(&#39;Bob&#39;, chatRoom);\nconst user3 &#x3D; new User(&#39;Charlie&#39;, chatRoom);\n\n&#x2F;&#x2F; 用户发送消息\nuser1.sendMessage(&#39;Hello, Bob!&#39;);\nuser2.sendMessage(&#39;Hi, Alice!&#39;);\nuser3.sendMessage(&#39;What are you guys doing?&#39;);</code></pre>\n\n<p>在这个例子中，<code>ChatRoom</code> 是中介者对象，<code>User</code> 是具体的同事对象。当一个用户发送消息时，它会将消息发送给 <code>ChatRoom</code> 对象，由 <code>ChatRoom</code> 对象将消息广播给其他用户。</p>\n<p>需要注意的是，在这个例子中，每个用户都持有一个对中介者对象的引用。这是因为它们需要将消息发送给中介者对象，而中介者对象则需要知道所有同事对象的存在。</p>\n<h2 id=\"js-迭代器模式\"><a href=\"#js-迭代器模式\" class=\"headerlink\" title=\"js 迭代器模式\"></a>js 迭代器模式</h2><p>迭代器模式是一种行为设计模式，它<strong>提供了一种方法来遍历复杂数据结构中的每个元素，而不必暴露其内部实现</strong>。它允许我们在不了解数据结构的底层细节的情况下进行迭代操作。</p>\n<p>在 JavaScript 中，迭代器模式通常通过 Symbol.iterator 接口实现。Symbol.iterator 是一个内置的符号，表示一个可迭代对象的迭代器方法。实现了 Symbol.iterator 方法的对象可以使用 for…of 循环或者使用内置的迭代器方法来进行遍历。</p>\n<p>下面是一个使用迭代器模式遍历数组的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const numbers &#x3D; [1, 2, 3, 4, 5];\nconst iterator &#x3D; numbers[Symbol.iterator]();\n\nfor (const number of iterator) &#123;\n  console.log(number);\n&#125;</code></pre>\n\n<p>在这个示例中，我们通过获取数组的内置迭代器方法（通过 Symbol.iterator）来创建一个迭代器对象。然后，我们使用 for…of 循环来遍历这个迭代器对象，输出数组中的每个元素。</p>\n<p>在 JavaScript 中，除了数组，还有很多其他的内置可迭代对象，例如字符串、Set、Map、NodeList 等。我们也可以自己实现可迭代对象，并在其中实现 Symbol.iterator 方法来支持迭代器模式的使用。</p>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>假设有一个数组对象，我们需要编写一个迭代器来遍历该数组并执行一些操作。可以使用以下代码实现一个简单的迭代器：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Iterator &#123;\n  constructor(items) &#123;\n    this.items &#x3D; items;\n    this.index &#x3D; 0;\n  &#125;\n  &#x2F;&#x2F; 是否有下一个\n  hasNext() &#123;\n    return this.index &lt; this.items.length;\n  &#125;\n  &#x2F;&#x2F; 获取下一个\n  next() &#123;\n    return this.items[this.index++];\n  &#125;\n&#125;\n\nconst colors &#x3D; new Iterator([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);\n\nwhile (colors.hasNext()) &#123;\n  console.log(colors.next());\n&#125;</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#39;red&#39;\n&#39;green&#39;\n&#39;blue&#39;</code></pre>\n\n<p>在此示例中，</p>\n<ol>\n<li>我们定义了一个<code>Iterator</code>类，该类将数组对象作为构造函数的参数。</li>\n<li><code>hasNext</code>方法检查是否还有下一个元素，</li>\n<li>而<code>next</code>方法返回下一个元素，并将索引增加 1。</li>\n<li>我们可以使用<code>while</code>循环遍历数组并打印每个元素。</li>\n</ol>\n<h1 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h1><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用</p>\n<p>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性</p>\n<h1 id=\"为什么要学习设计模式\"><a href=\"#为什么要学习设计模式\" class=\"headerlink\" title=\"为什么要学习设计模式\"></a>为什么要学习设计模式</h1><p>学习设计模式，有助于写出<code>可复用和可维护性高</code>的程序</p>\n<h1 id=\"设计模式原则\"><a href=\"#设计模式原则\" class=\"headerlink\" title=\"设计模式原则\"></a>设计模式原则</h1><p>设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构</p>\n<h1 id=\"创建型模式-5\"><a href=\"#创建型模式-5\" class=\"headerlink\" title=\"创建型模式 5\"></a>创建型模式 5</h1><h2 id=\"一、工厂模式\"><a href=\"#一、工厂模式\" class=\"headerlink\" title=\"一、工厂模式\"></a>一、工厂模式</h2><ul>\n<li><p>工厂模式：将创建对象的过程单独封装</p>\n</li>\n<li><p>使用场景：有构造函数的地方、写了大量构造函数、调用了大量的 new 的情况下</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/93291550\" target=\"_blank\" >见</a></p>\n</li>\n</ul>\n<h2 id=\"二、抽象工厂模式\"><a href=\"#二、抽象工厂模式\" class=\"headerlink\" title=\"二、抽象工厂模式\"></a>二、抽象工厂模式</h2><h2 id=\"工厂模式与抽象工厂模式区别\"><a href=\"#工厂模式与抽象工厂模式区别\" class=\"headerlink\" title=\"工厂模式与抽象工厂模式区别\"></a>工厂模式与抽象工厂模式区别</h2><p>抽象工厂（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性<br>具体工厂（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/93416391\" target=\"_blank\" >见</a></p>\n<h2 id=\"三、单例模式\"><a href=\"#三、单例模式\" class=\"headerlink\" title=\"三、单例模式\"></a>三、单例模式</h2><ul>\n<li><em>定义：</em>保证一个类仅有一个实例，并提供一个访问它的全局访问点</li>\n<li><em>核心：</em>确保只有一个实例，并提供全局访问</li>\n<li>实现单例的方式：<code>单例函数</code>, <code>类的构造方法</code> ,<code>类的静态方法</code></li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 提取出通用的单例\nfunction getSingleton(fn) &#123;\n  var instance &#x3D; null;\n\n  return function () &#123;\n    if (!instance) &#123;\n      instance &#x3D; fn.apply(this, arguments);\n    &#125;\n\n    return instance;\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 通过构造函数\nclass Singleton &#123;\n  &#x2F;&#x2F; static instance; 加不加都可，类中可以直接赋值和获取静态属性\n  constructor() &#123;\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this; &#x2F;&#x2F; this，是新创建的对象，new关键字原理中，this指向new出的对象\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n&#x2F;&#x2F;  通过静态方法\nclass Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<p><a href=\"/#/post/2022-09-19qa\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2022-09-19qa</a></p>\n<h2 id=\"四、建造者模式\"><a href=\"#四、建造者模式\" class=\"headerlink\" title=\"四、建造者模式\"></a>四、建造者模式</h2><h2 id=\"五、原型模式\"><a href=\"#五、原型模式\" class=\"headerlink\" title=\"五、原型模式\"></a>五、原型模式</h2><p><a href=\"https://zhuanlan.zhihu.com/p/94104346\" target=\"_blank\" >见</a> <a href=\"https://www.runoob.com/design-pattern/prototype-pattern.html\" target=\"_blank\" >见</a></p>\n<ul>\n<li>为什么出现：直接创建对象代价较大，所以采用这种模式</li>\n<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。</li>\n<li><code>对象会记住它的原型</code>。</li>\n<li>原型模式是用于创建对象的一种模式。我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象</li>\n<li>注意：使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据&#x2F;方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的</li>\n<li>JavaScript <code>本身是一门基于原型的面向对象语言</code>，<code>Object.create</code> 方法就是原型模式的天然实现—––准确地说，只要我们还在借助 Prototype 来实现对象的创建和原型的继承，那么我们就是在应用原型模式</li>\n<li>当对象 a 需 要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的 效果，<code>Object.create</code>的原理体现</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var obj &#x3D; &#123; name: &#39;zyy&#39; &#125;;\n\nvar A &#x3D; function () &#123;&#125;;\nA.prototype &#x3D; obj;\n\nvar a &#x3D; new A();\n\n&#x2F;&#x2F;a.name &#x3D; zyy\n\n&#x2F;&#x2F; 执行这段代码的时候，引擎做的事：\n\n&#x2F;&#x2F; 1. 尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。\n\n&#x2F;&#x2F; 2. 查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.proto 记录着并且指向 A.prototype，而 A.prototype 被设置为对象 obj。\n\n&#x2F;&#x2F; 3. 在对象 obj 中找到了 name 属性，并返回它的值。\n\n&#x2F;&#x2F; 提问自测\n\n&#x2F;&#x2F; 1、为什么说 ES6 的 Class 只是语法糖\n\n&#x2F;&#x2F; 起源上说，JavaScript是基于原型的面向对象系统。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来， 一个对象是通过克隆另外一个对象所得到的。\n\n&#x2F;&#x2F; ES6的 Class 语法,让 JavaScript 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。\n\n&#x2F;&#x2F; 2、上面使用了new A() ，所以A属于类吗？\n\n&#x2F;&#x2F; 在这里 A 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。\n\n&#x2F;&#x2F; 3、存在没有原型的对象吗？\n\n&#x2F;&#x2F; 通过设置构造器的 prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个 原型。而通过 Object.create( null )可以创建出没有原型的对象。</code></pre>\n\n<h1 id=\"结构型模式-8\"><a href=\"#结构型模式-8\" class=\"headerlink\" title=\"结构型模式 8\"></a>结构型模式 8</h1><h2 id=\"适配器模式-“包装模式”\"><a href=\"#适配器模式-“包装模式”\" class=\"headerlink\" title=\"适配器模式 “包装模式”\"></a>适配器模式 “包装模式”</h2><p>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够 使它们协同作用。</p>\n<p>个人总结场景：之前一种设计，后来想到了一种更好的设计，要让现在的兼容之前的，并且只保留一份同等功能的代码，就需要在两种设计之间增加适配器</p>\n<p><a href=\"https://juejin.cn/post/6962470884527308836\" target=\"_blank\" >javascript 设计模式之适配器模式</a></p>\n<h2 id=\"装饰器模式-“包装模式”\"><a href=\"#装饰器模式-“包装模式”\" class=\"headerlink\" title=\"装饰器模式 “包装模式”\"></a>装饰器模式 “包装模式”</h2><ul>\n<li>解决问题：继承会破坏封装性，装饰器模式，比起继承，更具有封装型</li>\n<li>ES7 中的 decorator 同样借鉴了这个语法糖，不过依赖于 ES5 的 Object.defineProperty 方法</li>\n<li>装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给对象动态地增加职责的方式称为装 饰器(decorator)模式。装饰器模式能够在不改 变对象自身的基础上，在程序运行期间给对象 动态地添加职责。</p></blockquote>\n<p>ES7 为我们提供了语法糖可以给一个类装上装饰器，继续改造上面的代码</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 装饰器函数，它的第一个参数是目标类\nfunction Decorator(target) &#123;\n    target.control &#x3D; function() &#123;\n        console.log(&#39;我是新的逻辑&#39;)\n    &#125;\n    return target\n&#125;\n\n\n&#x2F;&#x2F; 将装饰器“安装” 到HorribleCode上\n@Decorator\nclass HorribleCode () &#123;\n    &#x2F;&#x2F;老代码逻辑\n&#125;\n\n\nHorribleCode.control()</code></pre>\n\n<h2 id=\"过滤器模式-x2F-标准模式-x2F-挑三拣四\"><a href=\"#过滤器模式-x2F-标准模式-x2F-挑三拣四\" class=\"headerlink\" title=\"过滤器模式&#x2F;标准模式&#x2F;挑三拣四\"></a>过滤器模式&#x2F;标准模式&#x2F;挑三拣四</h2><p>目的：使用不同标准来过滤一组对象<br>实现：制定不同的规则来实现过滤，然后对过滤结果进行分组<br><a href=\"https://cloud.tencent.com/developer/article/1663903\" target=\"_blank\" >见</a></p>\n<h2 id=\"代理模式-“包装模式”\"><a href=\"#代理模式-“包装模式”\" class=\"headerlink\" title=\"代理模式 “包装模式”\"></a>代理模式 “包装模式”</h2><ul>\n<li>作用：实现访问主体的控制，简单来说就是增加了一层，进行访问控制</li>\n<li>三种：<code>保护代理</code>,<code>虚拟代理</code>,<code>缓存代理</code></li>\n</ul>\n<h2 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h2><p>抽象部分与实现部分的分离，使得二者可以独立的变化，而不必拘泥于形式</p>\n<p>在封装开源库的组件时候，经常会用到这种设计模式。</p>\n<p>例如，对外提供暴露一个 complete 函数,<br>如果用户有传入此函数, 那么就会在某一段代码逻辑中调用。</p>\n<p>这个过程中，组件起到了“桥”的作用，而具体实现是用户自定义。</p>\n<p>JavaScript 中桥接模式的典型应用是：Array 对象上的 forEach 函数。</p>\n<p>使用场景：</p>\n<ol>\n<li>最简单模拟 forEach 方法：</li>\n<li>桥接模式在事件监听中的应用 <code>elem.addEventListener(&#39;click&#39;, getBeerByIdBridge, false);</code></li>\n<li>桥接模式用于组件开发</li>\n</ol>\n<p>作者：Sky 飞羽<br>链接：<a href=\"https://www.jianshu.com/p/ceb82afe828d\">https://www.jianshu.com/p/ceb82afe828d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p><strong>桥接模式是不是面向接口编程？</strong></p>\n<p>是的，桥接模式是一种面向接口编程（Interface-Oriented Programming）的设计模式。在桥接模式中，抽象部分和实现部分通过接口（或抽象类）来进行连接，而不是通过具体的实现类。</p>\n<p>具体来说，桥接模式中的抽象部分（Abstraction）定义了一组抽象方法或接口，用于描述它的行为和功能。实现部分（Implementor）也是一组接口或抽象类，用于表示一组相关的操作或功能。抽象部分包含一个指向实现部分的引用，通过调用实现部分的接口来实现自己的功能。</p>\n<p>通过接口的连接，抽象部分和实现部分可以独立地变化，相互之间没有紧耦合关系。这种面向接口的设计方式有助于提高代码的灵活性和可扩展性，使得系统更易于维护和升级。</p>\n<p>在桥接模式中，抽象部分和实现部分之间的关系是一种“桥梁”，它们通过接口来连接。这种设计思想符合面向接口编程的原则，强调抽象和实现的分离，便于代码的组织和管理。</p>\n<p>总的来说，桥接模式是一种典型的面向接口编程的设计模式，它强调通过接口来连接抽象部分和实现部分，从而实现它们之间的解耦和独立变化。这种设计方式有助于提高代码的灵活性、可扩展性和可维护性。</p>\n<h2 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h2><ul>\n<li>一种用于性能优化的模式，它的目标是尽量减少共享对象的数量</li>\n<li>内部共享，外部剥离(能够共用的封装在能不，不能够共用的封装在外部)</li>\n</ul>\n<p><a href=\"https://www.yisu.com/zixun/186653.html\" target=\"_blank\" >见</a></p>\n<h2 id=\"外观模式（模块化开发）\"><a href=\"#外观模式（模块化开发）\" class=\"headerlink\" title=\"外观模式（模块化开发）\"></a>外观模式（模块化开发）</h2><ul>\n<li>增加一层，让从外部看来，像是一个（一致对外）</li>\n<li>使用：模块汇总后统一导出</li>\n</ul>\n<p><a href=\"https://segmentfault.com/a/1190000014132789\" target=\"_blank\" >见</a></p>\n<h2 id=\"部分整体模式\"><a href=\"#部分整体模式\" class=\"headerlink\" title=\"部分整体模式\"></a>部分整体模式</h2><ul>\n<li>用相同的方式处理一组相似对象 例如： 文件目录显示，多级目录呈现等树形结构数据的操作</li>\n</ul>\n<p><a href=\"https://segmentfault.com/a/1190000019773556\" target=\"_blank\" >见</a></p>\n<p><strong>部分整体模式是不是分治的思想</strong><br>是的，部分整体模式（Divide and Conquer）是一种分治思想的应用。分治是一种解决问题的思想和方法，将一个大问题分解为多个相同或类似的子问题，然后分别解决这些子问题，最后将子问题的解合并成原问题的解。</p>\n<p>部分整体模式在分治思想的基础上，将问题分解为多个部分，并对每个部分进行处理。每个部分的处理过程可能是相同的或类似的，然后将各个部分的结果合并得到最终的解。这种模式通常用于解决一些复杂的问题，可以有效地降低问题的复杂性，提高问题的解决效率。</p>\n<p>在算法和计算机科学领域，部分整体模式常常应用于一些需要递归求解的问题，例如归并排序、快速排序、二分查找等。在这些算法中，问题被分解成多个小问题，然后通过递归的方式分别解决这些小问题，最后将小问题的解合并成整体的解。</p>\n<p>总的来说，部分整体模式是一种分治思想的具体应用，它可以帮助我们有效地解决复杂的问题，提高算法的效率和性能。</p>\n<h1 id=\"行为型模式-10-CG-MD-ZB-MZ\"><a href=\"#行为型模式-10-CG-MD-ZB-MZ\" class=\"headerlink\" title=\"行为型模式 10 CG MD ZB MZ\"></a>行为型模式 10 CG MD ZB MZ</h1><h2 id=\"策略模式-1\"><a href=\"#策略模式-1\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><ul>\n<li>策略模式的出现是为了解决多重判断的问题</li>\n<li>组成：组策略，组策略的实现</li>\n<li>可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护</li>\n</ul>\n<p>使用场景：<code>规则校验</code>,<code>权限操作</code></p>\n<h2 id=\"观察者模式-x2F-发布订阅模式\"><a href=\"#观察者模式-x2F-发布订阅模式\" class=\"headerlink\" title=\"观察者模式&#x2F;发布订阅模式\"></a>观察者模式&#x2F;发布订阅模式</h2><ul>\n<li>也叫观察者模式</li>\n<li>解耦：1. 时间上的解耦，2. 为对象之间的解耦</li>\n</ul>\n<h2 id=\"模板模式\"><a href=\"#模板模式\" class=\"headerlink\" title=\"模板模式\"></a>模板模式</h2><ul>\n<li>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。</li>\n<li>简单理解为：规划好了蓝图，照着蓝图去具体实现</li>\n</ul>\n<h2 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h2><ul>\n<li>在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素</li>\n<li>在 javascript 中，实现了<code>[Symbol.iterator]属性的类数组，返回一个函数，就可以使用迭代器</code></li>\n</ul>\n<p><a href=\"https://zhuanlan.zhihu.com/p/97025000\" target=\"_blank\" >JavaScript 设计模式（九）-迭代器模式</a><br><a href=\"https://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" >Iterator 和 for…of 循环</a></p>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><ul>\n<li>为请求创建了一个接收者对象的链。多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。</li>\n<li>这些对象连接成为“链式结构”，每个节点转发请求，直到有对象处理请求为止</li>\n<li>使用场景：不同日志输出&#x2F;记录</li>\n<li>区别于过滤模式，过滤是满足就执行，责任链模式：满足执行并终止</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/53b0e70f6cd2\" target=\"_blank\" >见</a></p>\n<h2 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h2><ul>\n<li>保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</li>\n<li>历史记录这玩意就是备忘录模式</li>\n</ul>\n<h2 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h2><ul>\n<li>用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系</li>\n</ul>\n<h2 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h2><ul>\n<li>中介者模式的作用：就是解除对象与对象之间的紧耦合关系。</li>\n<li>增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可</li>\n<li>如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</li>\n</ul>\n<p><a href=\"https://juejin.cn/post/6844903848155283463\" target=\"_blank\" >见</a></p>\n<h2 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h2><ul>\n<li>意图：主要将数据结构与数据操作分离。</li>\n<li>主要解决：稳定的数据结构和易变的操作耦合问题。</li>\n<li>何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中<br><a href=\"https://www.runoob.com/design-pattern/visitor-pattern.html\" target=\"_blank\" >菜鸟教程-设计模式-访问者模式</a><br><a href=\"https://juejin.cn/post/7012599751527006239\" target=\"_blank\" >见</a></li>\n</ul>\n<h2 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h2><ul>\n<li>发布—订阅模式的优点： 时间上的解耦，对象之间的解耦</li>\n<li>避免了 Context 无限膨胀，状态切换的逻辑分布在状态类中，也避免了大量的 if-else 语句。</li>\n<li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</li>\n<li>Context 中的请求动作和状态类中封装的行为相互独立切互不影响，也使得修改更加容易。</li>\n</ul>\n<p>实现方式：</p>\n<ol>\n<li>类似 java 中一个 State 抽象类，其他状态类继承并重写其方法，实现自己的状态类方法</li>\n<li>JavaScript 可以非常方便利用委托技术， 通过 Function.prototype.call 方法直接把请求委托给某个对象字面来执行</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/6844903862013280269#heading-7\" target=\"_blank\" >JavaScript 版本的状态机</a></p>\n<h2 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h2><ul>\n<li>这个比较难理解</li>\n</ul>\n<h2 id=\"空对象模式\"><a href=\"#空对象模式\" class=\"headerlink\" title=\"空对象模式\"></a>空对象模式</h2><p>未对该类做任何实现的空对象类</p>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><h2 id=\"创建型模式-原建工抽单\"><a href=\"#创建型模式-原建工抽单\" class=\"headerlink\" title=\"创建型模式 原建工抽单\"></a>创建型模式 原建工抽单</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 原型模式、建造者模式、工厂模式、抽象工厂模式、单例模式、\n&#x2F;&#x2F; 记忆口诀：原建工抽单（原来建工立业的人要抽单【交税】）</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">简</th>\n<th>原</th>\n<th>建</th>\n<th>工</th>\n<th>抽</th>\n<th>单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">全</td>\n<td>原型模式</td>\n<td>建造者模式</td>\n<td>工厂模式</td>\n<td>抽象工厂模式</td>\n<td>单例模式</td>\n</tr>\n</tbody></table>\n<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 享元模式、桥接模式、外观模式、适配器模式、组合模式、装饰者模式、代理模式、\n&#x2F;&#x2F; 记忆口诀（7）：享桥外适组装代【想桥外试、租装戴】</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">简</th>\n<th>享</th>\n<th>桥</th>\n<th>外</th>\n<th>适</th>\n<th>组</th>\n<th>装</th>\n<th>代</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">全</td>\n<td>享元模式</td>\n<td>桥接模式</td>\n<td>外观模式</td>\n<td>适配器模式</td>\n<td>组合模式</td>\n<td>装饰者模式</td>\n<td>代理模式</td>\n</tr>\n</tbody></table>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式\n&#x2F;&#x2F; 记忆口诀（11）：观察者、访问者、中介者；命令、解释、模版、状态；策略、责任、迭代、备忘</code></pre>\n\n<h1 id=\"记忆口诀\"><a href=\"#记忆口诀\" class=\"headerlink\" title=\"记忆口诀\"></a>记忆口诀</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）\n</code></pre>\n\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ul>\n<li>中间件是什么设计模式？（1. 中间人？不像 2. 过滤器？像又不像 3.代理模式，像又不像）</li>\n</ul>\n<h1 id=\"代码用设计模式往往比不用设计模式，更难理解\"><a href=\"#代码用设计模式往往比不用设计模式，更难理解\" class=\"headerlink\" title=\"代码用设计模式往往比不用设计模式，更难理解\"></a>代码用设计模式往往比不用设计模式，更难理解</h1><p><strong>确实，在应用设计模式时，代码可能会更加抽象和复杂，因此阅读和理解代码的难度可能会增加</strong>。设计模式的目的是提供一种灵活、可扩展且易于维护的代码结构，以解决特定的问题或满足特定的需求。但是，设计模式并不是适用于所有情况的银弹，有时候简单的解决方案可能更为合适。</p>\n<p>尽管使用设计模式可能增加代码的复杂性，但它们在长期和大型项目中可以带来许多优势。设计模式可以提高代码的可读性、可维护性和可扩展性，并促进团队合作和代码重用。此外，使用设计模式可以帮助开发人员遵循行业标准和最佳实践，从而提高代码质量和可靠性。</p>\n<p>理解和应用设计模式需要一定的学习和实践，一开始可能会感到困惑，但随着经验的积累，你将能够更好地理解和应用它们。此外，编写清晰、注释良好的代码以及提供适当的文档和示例可以帮助其他开发人员更容易地理解和使用设计模式。</p>\n<p>总而言之，设计模式是一种工具，用于解决特定的问题和提高代码质量。使用设计模式时需要权衡其带来的复杂性和优势，并根据具体情况做出适当的选择。在团队合作和大型项目中，良好的代码组织和结构是非常重要的，设计模式可以成为实现这一目标的有力工具之一。</p>\n<h1 id=\"React-hook-属于-23-种设计模式中的哪种\"><a href=\"#React-hook-属于-23-种设计模式中的哪种\" class=\"headerlink\" title=\"React hook 属于 23 种设计模式中的哪种\"></a>React hook 属于 23 种设计模式中的哪种</h1><p>React Hook 不属于传统的 23 种设计模式中的任何一种。它是一种特定于 React 的编程模式，用于在函数组件中引入和管理状态、副作用等功能。</p>\n<p>传统的设计模式是一种通用的设计思想和解决方案，用于解决软件开发中的常见问题。这些设计模式包括单例模式、工厂模式、观察者模式、策略模式等等，它们在面向对象编程中起到了重要的作用。</p>\n<p>React Hook 的出现改变了 React 组件开发的方式，它提供了一种函数式的方式来处理状态和副作用，使得组件逻辑更加简洁和可复用。<strong>它并不是传统意义上的设计模式，而是一种新的编程模式，更准确地说是一种函数组件的编程范式</strong>。</p>\n<p>虽然 React Hook 不属于传统的设计模式，但它在 React 社区中获得了广泛的认可和应用，成为了 React 开发中的重要工具和范式。它使得 React 组件更易于编写、测试和维护，并带来了许多性能优化和开发效率上的改进。</p>\n<h1 id=\"设计模式更适用于面向对象编程，而不适用于函数式编程？\"><a href=\"#设计模式更适用于面向对象编程，而不适用于函数式编程？\" class=\"headerlink\" title=\"设计模式更适用于面向对象编程，而不适用于函数式编程？\"></a>设计模式更适用于面向对象编程，而不适用于函数式编程？</h1><p><strong>设计模式的概念确实最初是在面向对象编程中引入的</strong>，<strong>并且设计模式的一些原则和概念更直接适用于面向对象编程</strong>。然而，设计模式的一些基本原则和思想也可以在函数式编程中得到应用。</p>\n<p>虽然函数式编程和面向对象编程有一些不同的特点和思想，但设计模式的目的是解决通用的软件设计问题，无论是哪种编程范式。设计模式的一些原则，如单一职责原则、开放封闭原则、依赖倒置原则等，仍然适用于函数式编程。</p>\n<p>在函数式编程中，设计模式的应用可能会有所不同，因为函数式编程更强调纯函数、不可变性和无副作用。函数式编程中更常见的是一些特定的函数式编程模式，如<code>高阶函数</code>、<code>纯函数组合</code>、<code>函数柯里化</code>等。</p>\n<p>虽然设计模式在函数式编程中的应用可能会有所不同，但仍然可以从设计模式的一些原则和思想中获益，帮助解决函数式编程中的设计问题和优化代码结构。</p>\n<p>因此，虽然设计模式的概念最初是在面向对象编程中引入的，但一些设计模式的基本原则和思想仍然可以在函数式编程中得到应用，并且可以帮助解决通用的软件设计问题。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.runoob.com/design-pattern/design-pattern-intro.html\" target=\"_blank\" >设计模式简介</a></p>\n<p><a href=\"https://juejin.cn/post/7072175210874535967\" target=\"_blank\" >javascript 的 23 种设计模式</a></p>\n","text":"旧文章链接post&#x2F;2022-07-18 设计模式 《JavaScript 设计模式与开发实践》chatGPT误区：为何使用设计模式后，会感觉将代码复杂化了使用设计模式是为了提高代码的可维护性、可扩展性、可读性、可测试性等方面的优点，但这并不代表使用设计模式后代码一定会...","link":"","photos":[],"count_time":{"symbolsCount":"63k","symbolsTime":"57 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%97%A7%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">旧文章链接</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8AJavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E3%80%8B\"><span class=\"toc-text\">《JavaScript 设计模式与开发实践》</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#chatGPT\"><span class=\"toc-text\">chatGPT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AF%E5%8C%BA%EF%BC%9A%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%90%8E%EF%BC%8C%E4%BC%9A%E6%84%9F%E8%A7%89%E5%B0%86%E4%BB%A3%E7%A0%81%E5%A4%8D%E6%9D%82%E5%8C%96%E4%BA%86\"><span class=\"toc-text\">误区：为何使用设计模式后，会感觉将代码复杂化了</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">JavaScript 设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 工厂模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#js-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">js 简单工厂模式 代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#js-%E6%96%B9%E6%B3%95%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">js 方法工厂代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#js-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">js 抽象工厂代码示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">构造函数实现单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">静态方法实现单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5-new-%E7%B1%BB\"><span class=\"toc-text\">类的静态方法中，为什么可以直接 new 类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES5-%E5%AE%9E%E7%8E%B0-class\"><span class=\"toc-text\">ES5 实现 class</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 原型模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">原型模式示例示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">ES6 实现原型模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">js 观察者模式示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E6%96%B9%E5%BC%8F%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">原型方式示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E7%B1%BB%E6%96%B9%E5%BC%8F%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">ES6 类方式示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 订阅发布模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">ES5 代码实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">观察者模式与订阅发布模式有何区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#redux-%E6%98%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E8%BF%98%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">redux 是订阅发布模式还是观察者模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 装饰者模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">装饰者模式代码示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 代理模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-proxy-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">ES6 proxy 实现代理模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">装饰器模式与代理模式的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%89%E7%82%B9%E5%83%8F%E6%88%91%E6%9C%80%E8%AE%A8%E5%8E%8C%E7%9A%84-JAVA-%E6%A0%B7%E5%AD%90%EF%BC%89\"><span class=\"toc-text\">js 建造者模式（有点像我最讨厌的 JAVA 样子）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">其他场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9C%E5%B0%86%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%85%B6%E8%A1%A8%E7%A4%BA%E7%9B%B8%E5%88%86%E7%A6%BB%E2%80%9D\"><span class=\"toc-text\">如何理解“将复杂对象的构建过程与其表示相分离”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-%E6%80%8E%E4%B9%88%E7%9C%8B%E4%B8%8A%E5%8E%BB%E5%83%8F%E6%98%AF-JAVA-%E7%9A%84-set-%E6%96%B9%E6%B3%95%E5%92%8C-get-%E6%96%B9%E6%B3%95%E5%91%A2\"><span class=\"toc-text\">建造者模式 怎么看上去像是 JAVA 的 set 方法和 get 方法呢</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 适配器模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%82%E9%85%8D%E5%99%A8%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">适配器代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%82%E9%85%8D%E5%99%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">适配器使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%90%E7%BC%93%E5%AD%98%E3%80%91\"><span class=\"toc-text\">js 过滤器模式【缓存】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">过滤器实现缓存的示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E8%81%9A%E5%90%88%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">过滤器聚合场景示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 桥接模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8C%96%E5%90%8E\"><span class=\"toc-text\">简化后</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">没理解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">桥接模式和组合模式的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E3%80%90%E7%BC%93%E5%AD%98%E3%80%91\"><span class=\"toc-text\">js 享元模式【缓存】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 外观模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">代码示例 1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2\"><span class=\"toc-text\">代码示例 2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-export-%E4%B9%9F%E6%98%AF%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">ES6 export 也是外观模式？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">策略模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">策略模式示例 1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">策略模式和桥接模式的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BE%8B%E5%AD%90-2\"><span class=\"toc-text\">策略模式例子 2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BE%8B%E5%AD%90-3\"><span class=\"toc-text\">策略模式例子 3</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 模版模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-this-%E8%B0%83%E7%94%A8%E5%88%B0%E5%AD%90%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">在抽象类方法中, 为什么可以通过 this 调用到子类的方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E5%88%B0%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">子类对象为什么可以调用到抽象基类的方法？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#extends-%E5%85%B3%E9%94%AE%E5%AD%97-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">extends 关键字 有哪些作用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 责任链模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-4\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81-nextHandler-%E6%98%AF%E9%93%BE%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%9F\"><span class=\"toc-text\">上述代码 nextHandler 是链的指针？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F-this\"><span class=\"toc-text\">注意 this</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 备忘录模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 命令模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 中介者模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">js 迭代器模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">示例代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">什么是设计模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">为什么要学习设计模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">设计模式原则</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5\"><span class=\"toc-text\">创建型模式 5</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">一、工厂模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">二、抽象工厂模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">工厂模式与抽象工厂模式区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">三、单例模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">四、建造者模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">五、原型模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-8\"><span class=\"toc-text\">结构型模式 8</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E2%80%9C%E5%8C%85%E8%A3%85%E6%A8%A1%E5%BC%8F%E2%80%9D\"><span class=\"toc-text\">适配器模式 “包装模式”</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-%E2%80%9C%E5%8C%85%E8%A3%85%E6%A8%A1%E5%BC%8F%E2%80%9D\"><span class=\"toc-text\">装饰器模式 “包装模式”</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F-x2F-%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F-x2F-%E6%8C%91%E4%B8%89%E6%8B%A3%E5%9B%9B\"><span class=\"toc-text\">过滤器模式&#x2F;标准模式&#x2F;挑三拣四</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E2%80%9C%E5%8C%85%E8%A3%85%E6%A8%A1%E5%BC%8F%E2%80%9D\"><span class=\"toc-text\">代理模式 “包装模式”</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">桥接模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">享元模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%89\"><span class=\"toc-text\">外观模式（模块化开发）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%83%A8%E5%88%86%E6%95%B4%E4%BD%93%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">部分整体模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-10-CG-MD-ZB-MZ\"><span class=\"toc-text\">行为型模式 10 CG MD ZB MZ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-1\"><span class=\"toc-text\">策略模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-x2F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">观察者模式&#x2F;发布订阅模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">模板模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">迭代器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">责任链模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">备忘录模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">命令模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">中介者模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">访问者模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">状态模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">解释器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">空对象模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%BB%BA%E5%B7%A5%E6%8A%BD%E5%8D%95\"><span class=\"toc-text\">创建型模式 原建工抽单</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">结构型模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">行为型模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BF%86%E5%8F%A3%E8%AF%80\"><span class=\"toc-text\">记忆口诀</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BE%80%E5%BE%80%E6%AF%94%E4%B8%8D%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9B%B4%E9%9A%BE%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">代码用设计模式往往比不用设计模式，更难理解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#React-hook-%E5%B1%9E%E4%BA%8E-23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%93%AA%E7%A7%8D\"><span class=\"toc-text\">React hook 属于 23 种设计模式中的哪种</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9B%B4%E9%80%82%E7%94%A8%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">设计模式更适用于面向对象编程，而不适用于函数式编程？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-移动端适配","uid":"ae7214e6b6b6dc80cfe5f43a5613e628","slug":"2022-10-28移动适配","date":"2022-10-28T02:03:07.000Z","updated":"2023-02-20T21:20:56.479Z","comments":true,"path":"api/articles/2022-10-28移动适配.json","keywords":null,"cover":null,"text":"网易精品课移动端适配方案 小红书网页代码&lt;script&gt; function setPixel() &#123; var e &#x3D; parseFloat( window .getComputedStyle(document.documentElement, nu...","link":"","photos":[],"count_time":{"symbolsCount":877,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"css theme","uid":"03a0cd201b7e39fe38e7f2e815b3009b","slug":"2022-10-26theme","date":"2022-10-26T07:58:01.000Z","updated":"2022-11-01T12:57:51.477Z","comments":true,"path":"api/articles/2022-10-26theme.json","keywords":null,"cover":[],"text":"mdn 主题切换 light&#x2F;dark&#x2F;os-default_theme.scss&#x2F;&#x2F; _theme.scss @use &quot;sass:color&quot;; @use &quot;..&#x2F;vars.scss&quot; ...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"27 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}