{"title":"react-native 架构变更","uid":"6f92233bb9cb3976c3ae6f34c3be87e6","slug":"2022-07-19rn-架构变更","date":"2022-07-19T02:33:57.000Z","updated":"2023-02-20T21:20:56.468Z","comments":true,"path":"api/articles/2022-07-19rn-架构变更.json","keywords":null,"cover":[],"content":"<h2 id=\"Fabric-渲染器\"><a href=\"#Fabric-渲染器\" class=\"headerlink\" title=\"Fabric 渲染器\"></a>Fabric 渲染器</h2><p><a href=\"https://www.react-native.cn/docs/fabric-renderer\" target=\"_blank\" >Fabric 渲染器</a></p>\n<details class=\"custom-details\">\n<summary>发展历程</summary>\n<p>一开始直接看 react-native 官网，对于 Fabric 渲染器的介绍看的我一脸懵逼，在 Google 扒拉下，发现了 2018 年的一个提案。</p>\n<p>我觉得从过去来看更符合事物的发展规律。直接拿到结果倒着看，不是很好理解。</p>\n<h3 id=\"这么搜搜到的\"><a href=\"#这么搜搜到的\" class=\"headerlink\" title=\"这么搜搜到的\"></a>这么搜搜到的</h3><img src=\"http://t-blog-images.aijs.top/img/20220719151559.webp\" style=\"max-width: 100%; width: 800px\" />\n\n<h3 id=\"2018-年提案\"><a href=\"#2018-年提案\" class=\"headerlink\" title=\"2018 年提案\"></a>2018 年提案</h3><p><a href=\"https://github.com/react-native-community/discussions-and-proposals/issues/4#:~:text=dedicated%20issue)-,TL%3BDR,-From%20%40axe%2Dfb\" target=\"_blank\" >React Native Fabric (UI-Layer Re-architecture) #4</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>In the current architecture, all UI operations (like creating native views, managing children, etc). are handled by a native module called UIManagerModule. The React Reconciller sends UI commands over the bridge, which are eventually handled by this module and delegated to UIImplementation. This in turn creates shadow nodes that represent the layout tree and are passed to Yoga to determine the relative co-ordinates based on the Flex box styles that are passed in from JS.</p>\n<p>In the new system, the UI operations are directly exposed to JavaScript as functions using the JSI interface described above. The new UI manager can then create ComponentDescriptors and the Shadow Nodes for specific view types (like Text, View or Images), and then communicate with Java&#x2F;ObjC to draw platform specific UI.</p></blockquote>\n<p>大概意思是：回到 2018 年 7 月 31 日 年，当时的 fabric，在 react-native-community 中还只是个讨论和提案，</p>\n<p><strong>站在 2018 年 7 月 31 日这个时间点,看待这个提案：</strong></p>\n<p>在当前架构中，</p>\n<ol>\n<li>所有的 UI 操作（像创建原生视图，管理子组件），被一个叫作<code>UIManagerModule</code>原生模块所处理，</li>\n<li>React 协调器通过网桥发送 UI 命令，这些命令最终由该模块处理并委托给<code>UIImplementation</code>。</li>\n<li>这反过来会创建表示布局树的影子节点，并将其传递给 Yoga，以根据从 JS 传递的 Flex box 样式确定相对坐标。</li>\n</ol>\n<p>在新系统中，</p>\n<ol>\n<li>用户界面操作<code>作为函数使用上述 JSI 接口</code>直接暴露给 JavaScript。</li>\n<li>然后，<code>新的 UI 管理器</code>可以为特定的视图类型（如文本、视图或图像）创建组件描述符和影子节点，</li>\n<li>然后<code>与 Java/ObjC 通信</code>以绘制特定于平台的 UI</li>\n</ol>\n\n</details>\n<h2 id=\"fabric-是什么\"><a href=\"#fabric-是什么\" class=\"headerlink\" title=\"fabric 是什么\"></a>fabric 是什么</h2><p>为了更好的用户体验，而这种新体验是在老架构上是不可能实现的,所以开发了新的渲染架构 fabric</p>\n<img src=\"http://t-blog-images.aijs.top/img/202302182122000.webp\" />\n\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>设计的初忠</p>\n<p>开发新的渲染架构的初衷是为了更好的用户体验，而这种新体验是在老架构上是不可能实现的</p>\n<ol>\n<li><code>提升宿主视图（host views）和 React 视图（React views）的互操作性</code>，渲染器必须有能力同步地测量和渲染 React 界面。在老架构中，React Native 布局是异步的，这导致在宿主视图中渲染嵌套的 React Native 视图，会有布局“抖动”的问题。</li>\n<li><code>多优先级&amp;同步事件</code> 借助多优先级和同步事件的能力，渲染器可以提高用户交互的优先级，来确保他们的操作得到及时的处理(React schedule 调度，lan 模型)</li>\n<li><code>React Suspense</code> React Suspense 的集成，允许你在 React 中更符合直觉地写请求数据代码。</li>\n<li><code>可中断</code> 允许你在 React Native 使用 React Concurrent 模式 可中断渲染功能。 <a href=\"https://zhuanlan.zhihu.com/p/60307571#:~:text=%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%E3%80%82-,Concurrent%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F,-Concurrent%20%E5%B9%B6%E4%B8%8D%E6%98%AF\" target=\"_blank\" >Concurrent 究竟是什么？</a> 异步可中断</li>\n<li>更容易实现 React Native 的服务端渲染。？打个问号，是不是 RN 代码可以部署在云端？进行 SSR?</li>\n</ol>\n<p>设计的收益</p>\n<ol>\n<li><code>类型安全</code>：代码生成工具（code generation）确保了 JS 和宿主平台两方面的类型安全。<ol>\n<li>代码生成工具使用 JavaScript 组件声明作为唯一事实源，生成 C++ 结构体来持有 props 属性。</li>\n<li>不会因为 JavaScript 和原生组件 props 属性不匹配而出现构建错误。</li>\n</ol>\n</li>\n<li><code>共享 C++</code>：渲染器是用 C++ 实现的，其核心 core 在平台之间是共享的。这增加了一致性并且使得新的平台能够更容易采用 React Native。（译注：例如 VR 新平台）</li>\n<li><code>更好的宿主平台互操作性</code>：当宿主组件集成到 React Native 时，<ol>\n<li>同步和线程安全的布局计算提升了用户体验（译注：没有异步的抖动）。</li>\n<li>对于需要同步 API 的宿主平台库，变得更容易集成了。</li>\n</ol>\n</li>\n<li><code>一致性</code>：新的渲染系统的实现是跨平台的，不同平台之间更容易保持一致。以前是在 yoga 中计算的，现在是在 fabric 中进行计算</li>\n<li><code>性能提升</code>：新的渲染系统的实现是跨平台的，每个平台都从那些原本只在某个特定平台的实现的性能优化中，得到了收益。比如拍平视图层级，原本只是 Android 上的性能优化方案，现在 Android 和 iOS 都直接有了。</li>\n<li><code>更快的启动速度</code>：默认情况下，宿主组件的初始化是<code>懒执行的</code>。？以前不是</li>\n<li><code>JS 和宿主平台之间的数据序列化更少</code>：&#96;<ol>\n<li>以前&#96;：React 使用序列化 JSON 在 JavaScript 和宿主平台之间传递数据。</li>\n<li><code>现在</code>：新的渲染器用 JSI（JavaScript Interface）直接获取 JavaScript 数据。</li>\n</ol>\n</li>\n</ol>\n</p>\n</details>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>nodejs 是什么语言写的<br>“ Node.js 是用 C ++编写、开发的。 Node.js 底层是 C++(V8 也是 C++写的)</p>\n</div>\n<h3 id=\"术语表\"><a href=\"#术语表\" class=\"headerlink\" title=\"术语表\"></a>术语表</h3><p><a href=\"https://www.react-native.cn/architecture/glossary\" target=\"_blank\" >术语表</a></p>\n<p><strong>宿主平台（Host platform）</strong></p>\n<p>React Native 嵌入的平台，比如 Android、iOS、Windows、macOS。</p>\n<p><strong>宿主视图树（Host View Tree）</strong></p>\n<ol>\n<li><code>宿主视图树</code>就是一系列的宿主视图。宿主平台有 Android 平台、iOS 平台等等。在 Android 上，</li>\n<li><code>宿主视图</code>就是 android.view.ViewGroup 实例、 android.widget.TextView 实例等等。</li>\n<li>宿主视图就像积木一样地构成了宿主视图树。</li>\n<li><code>每个宿主视图的大小和坐标位置</code>基于的是 LayoutMetrics，而 LayoutMetrics 是通过布局引擎 Yoga 计算出来的。</li>\n<li><code>宿主视图的样式和内容信息</code>，是从 React 影子树中得到的。</li>\n</ol>\n<p><strong>一句话概括</strong>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;  react 组件 -&gt; react 影子树  -&gt;   Yoga 布局计算到宿主视图   -&gt;  宿主视图树</code></pre>\n\n<h4 id=\"JavaScript-Interfaces-JSI\"><a href=\"#JavaScript-Interfaces-JSI\" class=\"headerlink\" title=\"JavaScript Interfaces (JSI)\"></a>JavaScript Interfaces (JSI)</h4><p><code>一个轻量级的 API，给在 C++ 应用中嵌入的 JavaScript 引擎用的。Fabric 使用它在 Fabric 的 C++ 核心和 React 之间进行通信。</code></p>\n<h4 id=\"Java-Native-Interface-JNI\"><a href=\"#Java-Native-Interface-JNI\" class=\"headerlink\" title=\"Java Native Interface (JNI)\"></a>Java Native Interface (JNI)</h4><p><code>Java Native Interface (JNI)：一个用于在 Java 中写 原生(译注：指调用 C++) 方法的 API。作用是实现 Fabric 的 C++ 核心和 Android 的通信。</code></p>\n<p><code>怎么没有提IOS的ObjC ? ObjC可以直接调用C++ ?</code></p>\n<h4 id=\"React-组件（React-Component\"><a href=\"#React-组件（React-Component\" class=\"headerlink\" title=\"React 组件（React Component)\"></a>React 组件（React Component)</h4><p>React 组件就是 JavaScript 函数或者类，描述如何创建 React 元素。这篇博文中有更多介绍。</p>\n<h4 id=\"React-复合组件（React-Composite-Components\"><a href=\"#React-复合组件（React-Composite-Components\" class=\"headerlink\" title=\"React 复合组件（React Composite Components)\"></a>React 复合组件（React Composite Components)</h4><p>React 组件的 render 方法中，包括其他 React 复合组件和 React 宿主组件。</p>\n<h4 id=\"React-宿主组件（React-Host-Components-or-Host-Components\"><a href=\"#React-宿主组件（React-Host-Components-or-Host-Components\" class=\"headerlink\" title=\"React 宿主组件（React Host Components or Host Components)\"></a>React 宿主组件（React Host Components or Host Components)</h4><p>React 组件的视图是通过宿主视图，比如 <code>&lt;View&gt;、&lt;Text&gt;</code>实现的。在 Web 中，ReactDOM 的宿主组件就是 <code>&lt;p&gt;标签</code>、<code>&lt;div&gt;标签</code>代表的组件。</p>\n<h4 id=\"React-元素树（React-Element-Trees\"><a href=\"#React-元素树（React-Element-Trees\" class=\"headerlink\" title=\"React 元素树（React Element Trees)\"></a>React 元素树（React Element Trees)</h4><p>React 元素树是通过 JavaScript 中的 React 创建的，该树由一系类 React 元素组成。一个 React 元素就是一个普通的 JavaScript 对象，它描述了应该在屏幕中展示什么。一个元素包括属性 props、样式 styles、子元素 children。React 元素分为两类：React 复合组件实例（React Composite Components）和 React 宿主组件（React Host Components）实例，并且它只存在于 JavaScript 中。</p>\n<h4 id=\"React-影子树（React-Shadow-Tree-and-React-Shadow-Node\"><a href=\"#React-影子树（React-Shadow-Tree-and-React-Shadow-Node\" class=\"headerlink\" title=\"React 影子树（React Shadow Tree and React Shadow Node)\"></a>React 影子树（React Shadow Tree and React Shadow Node)</h4><p>React 影子树是通过 Fabric 渲染器创建的，树由一系列 React 影子节点组成。一个 React 影子节点是一个对象，代表一个已经挂载的 React 宿主组件，其包含的属性 props 来自 JavaScript。它也包括布局信息，比如坐标系 x、y，宽高 width、height。</p>\n<ol>\n<li>在新渲染器 Fabric 中，React 影子节点对象只存在于 C++ 中。</li>\n<li>而在老架构中，它存在于手机运行时的堆栈中，比如 Android 的 JVM。</li>\n</ol>\n<h4 id=\"Fabric-渲染器（Fabric-Renderer）：\"><a href=\"#Fabric-渲染器（Fabric-Renderer）：\" class=\"headerlink\" title=\"Fabric 渲染器（Fabric Renderer）：\"></a><code>Fabric 渲染器（Fabric Renderer）</code>：</h4><ol>\n<li>React Native 执行的 React 框架代码，和 React 在 Web 中执行代码是同一份。</li>\n<li>React Native 渲染的是通用平台视图（宿主视图）而不是 DOM 节点（可以认为 DOM 是 Web 的宿主视图）。</li>\n</ol>\n<p>Fabric 渲染器使得渲染宿主视图变得可行。</p>\n<ol>\n<li>Fabric 让 React <code>与各个平台直接通信</code>并<code>直接管理其宿主视图实例</code>。</li>\n<li>Fabric <code>渲染器存在于 JavaScript 中</code>，并且它调用的是由 C++ 代码暴露的接口。<a href=\"https://www.react-native.cn/architecture/fabric-renderer\" target=\"_blank\" >在这篇文章中有更多关于 React 渲染器的信息。</a></li>\n</ol>\n<h3 id=\"React-源码目录\"><a href=\"#React-源码目录\" class=\"headerlink\" title=\"React 源码目录\"></a>React 源码目录</h3><p>Renderer 相关的文件夹<br>如下几个文件夹为对应的 Renderer</p>\n<ul>\n<li>react-art</li>\n<li>react-dom # 注意这同时是 DOM 和 SSR（服务端渲染）的入口</li>\n<li>react-native-renderer</li>\n<li>react-noop-renderer # 用于 debug fiber（后面会介绍 fiber）</li>\n<li>react-test-renderer</li>\n</ul>\n<p>react-dom 与 react-native-renderer 属于同一级别,<code>Fabric</code> 取代了 <code>react-native-renderer</code>, 可以理解为<code>Fabric</code>是 <code>react-dom</code>级别的渲染器</p>\n<p><a href=\"https://github.com/facebook/react-native/blob/089c9a5c9c9a60b6bbff6dda0c9eefa9d501a092/Libraries/ReactNative/renderApplication.js#L72\" target=\"_blank\" >源码</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Libaries&#x2F;ReactNative&#x2F;renderApplication.js\n\nif (fabric) &#123;\n  require(&quot;..&#x2F;Renderer&#x2F;shims&#x2F;ReactFabric&quot;).render(\n    renderable,\n    rootTag,\n    null,\n    useConcurrentRoot\n  );\n&#125; else &#123;\n  require(&quot;..&#x2F;Renderer&#x2F;shims&#x2F;ReactNative&quot;).render(renderable, rootTag);\n&#125;</code></pre>\n\n<h3 id=\"fabric\"><a href=\"#fabric\" class=\"headerlink\" title=\"fabric\"></a>fabric</h3><p><a href=\"https://www.nptech.de/fabric/\" target=\"_blank\" >Fabric is an all-embracing code generation framework for Java, C and C++.</a></p>\n<img src=\"https://www.nptech.de/fabric/images/software_architecture.png\" style=\"width:500px;max-width:100%\" />\n\n<p>Fabric 是一个适用于 Java、C 和 C++的包罗万象的代码生成框架。</p>\n<h3 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 以前 jsx -&gt; 原生\n\n&#x2F;&#x2F; 现在 jsx -&gt; JSI C++ -&gt; 原生</code></pre>\n\n<p>多了一层，竟然不慢反快? 我猜应该在 <code>JSI C++ -&gt; 原生</code></p>\n<p><a href=\"https://www.react-native.cn/architecture/xplat-implementation#:~:text=%E4%BD%BF%E7%94%A8%20C%2B%2B%20%E4%BD%9C%E4%B8%BA%E6%A0%B8%E5%BF%83%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E6%9C%89%E5%87%A0%E4%B8%AA%E6%9C%89%E7%82%B9\" target=\"_blank\" >跨平台实现中有对此说明</a></p>\n<ol>\n<li>在上一代 React Native 渲染器中，React 影子树、布局逻辑、视图拍平算法是在各个平台单独实现的。</li>\n<li>当前的渲染器的设计上采用的是跨平台的解决方案，共享了核心的 C++ 实现。</li>\n</ol>\n<p>使用 C++ 作为核心渲染系统有几个优点</p>\n<ol>\n<li><code>降低成本</code>单一实现降低了开发和维护成本</li>\n<li><code>影子树的性能</code>它提升了创建 React <code>影子树的性能</code></li>\n<li><code>渲染性能</code>在 Android 上，也因为不再使用 JNI for Yoga，降低了 Yoga 渲染引擎的开销，布局计算的性能也有所提升</li>\n<li><code>内存占用小</code>每个 React 影子节点在 C++ 中占用的内存，比在 Kotlin 或 Swift 中占用的要小。</li>\n<li><code>并发安全</code>强制不可变的 C++ 特性，来确保并发访问时共享资源即便不加锁保护，也不会有问题。</li>\n</ol>\n<p>在 Android 端还有两种例外，渲染器依然会有 JNI 的开销：</p>\n<ol>\n<li>复杂视图，比如 Text、TextInput 等，依然会使用 JNI 来传输属性 props。</li>\n<li>在挂载阶段依然会使用 JNI 来发送变更操作。</li>\n</ol>\n<p>React Native 团队在探索使用 ByteBuffer 序列化数据这种新的机制，来替换 ReadableMap，减少 JNI 的开销。目标是将 JNI 的开销减少 35~50%。</p>\n<h3 id=\"fabric-提供了-C-与两边通信的-API\"><a href=\"#fabric-提供了-C-与两边通信的-API\" class=\"headerlink\" title=\"fabric 提供了 C++ 与两边通信的 API\"></a>fabric 提供了 C++ 与两边通信的 API</h3><img src=\"https://www.react-native.cn/assets/images/xplat-implementation-diagram-7611cf9dfb6d15667365630147d83ca5.png\" style=\"width:500px;max-width:100%\" />\n\n<ol>\n<li>React 与渲染器的通信，<ol>\n<li>包括<code>渲染（render） React 树</code></li>\n<li><code>监听事件（event）</code>，比如 <code>onLayout</code>、<code>onKeyPress</code>、<code>touch</code> 等。</li>\n</ol>\n</li>\n<li>React Native 渲染器与宿主平台的通信，<ol>\n<li>包括<code>在屏幕上挂载（mount）宿主视图</code>，包括 <code>create</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 宿主视图，</li>\n<li><code>监听用户在宿主平台产生的事件</code>。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"视图拍平\"><a href=\"#视图拍平\" class=\"headerlink\" title=\"视图拍平\"></a>视图拍平</h2><p><strong>视图拍平（View Flattening）是 React Native 渲染器避免布局嵌套太深的优化手段</strong></p>\n<p>React API 在设计上希望通过组合的方式，<code>实现组件声明和重用</code>，这为更简单的开发提供了一个很好的模型。但是在实现中，API 的这些特性会导致一些 React 元素会嵌套地很深，而其中大部分 React 元素节点只会影响视图布局，并不会在屏幕中渲染任何内容。这就是所谓的“只参与布局”类型节点。</p>\n<p>从概念上讲，React 元素树的节点数量和屏幕上的视图数量应该是 1:1 的关系。但是，渲染一个很深的“只参与布局”的 React 元素会导致性能变慢。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>大概意思：因为 React 组合设计实现组件复用。 组件复用嵌套多了，会出现很多无内容的布局节点，这些布局节点没啥用，多个连续嵌套的节点，在 fabric 中被一巴掌拍死打成一个肉饼，嗯～</p></blockquote>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>举个很常见的例子，例子中“只参与布局”视图导致了性能损耗。</p>\n<p>想象一下，你要渲染一个标题。你有一个应用，应用中拥有外边距 ContainerComponent 的容器组件，容器组件的子组件是 TitleComponent 标题组件，标题组件包括一个图片和一行文字。React 代码示例如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">function MyComponent() &#123;\n  return (\n    &lt;View&gt;                          &#x2F;&#x2F; ReactAppComponent\n      &lt;View style&#x3D;&#123;&#123;margin: 10&#125;&#125; &#x2F;&gt; &#x2F;&#x2F; ContainerComponent\n        &lt;View style&#x3D;&#123;&#123;margin: 10&#125;&#125;&gt; &#x2F;&#x2F; TitleComponent\n          &lt;Image &#123;...&#125; &#x2F;&gt;\n          &lt;Text &#123;...&#125;&gt;This is a title&lt;&#x2F;Text&gt;\n        &lt;&#x2F;View&gt;\n      &lt;&#x2F;View&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;</code></pre>\n\n<h3 id=\"拍平前\"><a href=\"#拍平前\" class=\"headerlink\" title=\"拍平前\"></a>拍平前</h3><p>React Native 在渲染时，会生成以下三棵树：</p>\n<img src=\"https://www.react-native.cn/assets/images/diagram-one-3f2f9d7a2fa9d97b6b86fa3bd9b886d1.png\" />\n\n<p>为了提升 React 元素树中“只参与布局”类型的性能，渲染器实现了一种视图拍平的机制来合并或拍平这类节点，减少屏幕中宿主视图的层级深度。该算法考虑到了如下属性，比如 margin, padding, backgroundColor, opacity 等等。</p>\n<p><code>视图拍平算法</code>是渲<code>染器的对比（diffing）阶段的一部分</code>，这样设计的好处是我们<code>不需要额外的 CPU 耗时</code>(不需要再遍历了，但是绝对是有 CPU 损耗的)，来<code>拍平 React 元素树中“只参与布局”的视图</code>。此外，作为 C++ 核心的一部分，<code>视图拍平算法默认是全平台共用的</code>。</p>\n<p>在前面的例子中，视图 2 和视图 3 会作为“对比算法”（diffing algorithm）的一部分被拍平，而它们的样式结果会被合并到视图 1 中。</p>\n<img src=\"https://www.react-native.cn/assets/images/diagram-two-b87959980d29e4a303465a3d0ac82c73.png\" />\n\n<p>虽然，这种<code>优化让渲染器少创建和渲染两个宿主视图</code>，但<code>从用户的角度看屏幕内容没有任何区别</code>。</p>\n<h3 id=\"拍平\"><a href=\"#拍平\" class=\"headerlink\" title=\"拍平\"></a>拍平</h3><h3 id=\"拍平后\"><a href=\"#拍平后\" class=\"headerlink\" title=\"拍平后\"></a>拍平后</h3><h2 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h2><p>React Native 渲染器在多个线程之间分配 <a href=\"https://www.react-native.cn/architecture/render-pipeline\" target=\"_blank\" >渲染流水线（render pipeline）任务</a>。<br>接下来我们会给线程模型下定义，并提供一些示例来说明渲染流水线的线程用法。</p>\n<p>React Native 渲染器是<code>线程安全</code>的。</p>\n<p>从更高的视角看，在框架内部线程安全是<code>通过不可变的数据结果保障</code>的，其使用的是 C++ 的 const correctness 特性。这意味着，在渲染器中 React 的<code>每次更新都会重新创建或复制新对象，而不是更新原有的数据结构</code>。这是框架把线程安全和同步 API 暴露给 React 的前提。</p>\n<p>渲染器使用三个不同的线程：</p>\n<ol>\n<li>UI 线程（主线程）：唯一可以操作宿主视图的线程。</li>\n<li>JavaScript 线程：这是执行 React 渲染阶段的地方。</li>\n<li>后台线程：专门用于布局的线程。</li>\n</ol>\n<h2 id=\"渲染场景\"><a href=\"#渲染场景\" class=\"headerlink\" title=\"渲染场景\"></a>渲染场景</h2><h3 id=\"在后台线程中渲染\"><a href=\"#在后台线程中渲染\" class=\"headerlink\" title=\"在后台线程中渲染\"></a>在后台线程中渲染</h3><p>这是最常见的场景，大多数的渲染流水线发生在 JavaScript 线程和后台线程。</p>\n<img src=\"http://t-blog-images.aijs.top/img/case-1.webp\" />\n\n<h3 id=\"在主线程中渲染\"><a href=\"#在主线程中渲染\" class=\"headerlink\" title=\"在主线程中渲染\"></a>在主线程中渲染</h3><p>当 UI 线程上有高优先级事件时，渲染器能够在 UI 线程上同步执行所有渲染流水线。</p>\n<img src=\"http://t-blog-images.aijs.top/img/case-2.webp\" />\n\n<h3 id=\"默认或连续事件中断\"><a href=\"#默认或连续事件中断\" class=\"headerlink\" title=\"默认或连续事件中断\"></a>默认或连续事件中断</h3><p>在这个场景中，UI 线程的低优先级事件中断了渲染步骤。React 和 React Native 渲染器能够中断渲染步骤，并把它的状态和一个在 UI 线程执行的低优先级事件合并。在这个例子中渲染过程会继续在后台线程中执行。</p>\n<img src=\"http://t-blog-images.aijs.top/img/case-3.webp\" />\n\n<h3 id=\"不相干的事件中断\"><a href=\"#不相干的事件中断\" class=\"headerlink\" title=\"不相干的事件中断\"></a>不相干的事件中断</h3><p>渲染步骤是可中断的。在这个场景中， <code>UI 线程的高优先级事件中断了渲染步骤</code>。React 和渲染器是能够打断渲染步骤的，并把它的状态和 UI 线程执行的高优先级事件合并。在 UI 线程渲染步骤是同步执行的。</p>\n<img src=\"http://t-blog-images.aijs.top/img/case-4.webp\" />\n\n<h3 id=\"来自-JavaScript-线程的后台线程批量更新\"><a href=\"#来自-JavaScript-线程的后台线程批量更新\" class=\"headerlink\" title=\"来自 JavaScript 线程的后台线程批量更新\"></a>来自 JavaScript 线程的后台线程批量更新</h3><p>在后台线程将更新分派给 UI 线程之前，它会检查是否有新的更新来自 JavaScript。 这样，当渲染器知道新的状态要到来时，它就不会直接渲染旧的状态。</p>\n<img src=\"http://t-blog-images.aijs.top/img/case-5.webp\" />\n\n<h3 id=\"C-状态更新\"><a href=\"#C-状态更新\" class=\"headerlink\" title=\"C++ 状态更新\"></a>C++ 状态更新</h3><p>更新来自 UI 线程，并会跳过渲染步骤。更多细节请参考 React Native 渲染器状态更新。</p>\n<img src=\"http://t-blog-images.aijs.top/img/case-6.webp\" />\n\n<h3 id=\"Turbo-Modules\"><a href=\"#Turbo-Modules\" class=\"headerlink\" title=\"Turbo Modules\"></a>Turbo Modules</h3><ol>\n<li>Turbo Modules 基本上是对这些旧的 Native 模块的增强</li>\n<li>现在 JS 将能够持有这些模块的引用，所以 JS 代码可以仅在需要时才加载对应模块，这样可以将显着缩短 RN 应用的启动时间</li>\n</ol>\n<h3 id=\"Codegen\"><a href=\"#Codegen\" class=\"headerlink\" title=\"Codegen\"></a>Codegen</h3><p>JavaScript 是一门动态语言，而 JSI 是用 C++写的，C++是一门静态语言，因此需要保证两者间的顺利通信。</p>\n<p>这就是新架构还包括一个名为 CodeGen 的静态类型检查器的原因。</p>\n<p>CodeGen 使用类型确定后的 JavaScript 来为 Turbo Modules 和 Fabric 定义供他们使用的接口元素，<br><code>它会在构建时生成更多的 native 代码，而非运行时</code>。</p>\n<p>————————————————<br>版权声明：本文为 CSDN 博主「Lvan 的前端笔记」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_43972437/article/details/122901903\">https://blog.csdn.net/weixin_43972437/article/details/122901903</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://github.com/react-native-community/discussions-and-proposals/issues/4\" target=\"_blank\" >React Native Fabric (UI-Layer Re-architecture) #4</a></p>\n<p><a href=\"https://www.react-native.cn/docs/fabric-renderer\" target=\"_blank\" >Fabric 渲染器</a></p>\n<p><a href=\"https://juejin.cn/post/7099885746697273357\" target=\"_blank\" >React Native 架构解析 - 一张图了解 Fabric</a></p>\n<p><a href=\"https://react.iamkasong.com/preparation/file.html#packages%E7%9B%AE%E5%BD%95\" target=\"_blank\" >React 技术揭秘</a></p>\n","text":"Fabric 渲染器Fabric 渲染器 发展历程 一开始直接看 react-native 官网，对于 Fabric 渲染器的介绍看的我一脸懵逼，在 Google 扒拉下，发现了 2018 年的一个提案。 我觉得从过去来看更符合事物的发展规律。直接拿到结果倒着看，不是很好理解。 ...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"react-native","slug":"react-native","count":8,"path":"api/categories/react-native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":8,"path":"api/tags/react-native.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fabric-%E6%B8%B2%E6%9F%93%E5%99%A8\"><span class=\"toc-text\">Fabric 渲染器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B9%88%E6%90%9C%E6%90%9C%E5%88%B0%E7%9A%84\"><span class=\"toc-text\">这么搜搜到的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2018-%E5%B9%B4%E6%8F%90%E6%A1%88\"><span class=\"toc-text\">2018 年提案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fabric-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">fabric 是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AF%E8%AF%AD%E8%A1%A8\"><span class=\"toc-text\">术语表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JavaScript-Interfaces-JSI\"><span class=\"toc-text\">JavaScript Interfaces (JSI)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Java-Native-Interface-JNI\"><span class=\"toc-text\">Java Native Interface (JNI)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#React-%E7%BB%84%E4%BB%B6%EF%BC%88React-Component\"><span class=\"toc-text\">React 组件（React Component)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#React-%E5%A4%8D%E5%90%88%E7%BB%84%E4%BB%B6%EF%BC%88React-Composite-Components\"><span class=\"toc-text\">React 复合组件（React Composite Components)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#React-%E5%AE%BF%E4%B8%BB%E7%BB%84%E4%BB%B6%EF%BC%88React-Host-Components-or-Host-Components\"><span class=\"toc-text\">React 宿主组件（React Host Components or Host Components)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#React-%E5%85%83%E7%B4%A0%E6%A0%91%EF%BC%88React-Element-Trees\"><span class=\"toc-text\">React 元素树（React Element Trees)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#React-%E5%BD%B1%E5%AD%90%E6%A0%91%EF%BC%88React-Shadow-Tree-and-React-Shadow-Node\"><span class=\"toc-text\">React 影子树（React Shadow Tree and React Shadow Node)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Fabric-%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%88Fabric-Renderer%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">Fabric 渲染器（Fabric Renderer）：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">React 源码目录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fabric\"><span class=\"toc-text\">fabric</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%9D%A5%E4%BA%86\"><span class=\"toc-text\">问题来了</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fabric-%E6%8F%90%E4%BE%9B%E4%BA%86-C-%E4%B8%8E%E4%B8%A4%E8%BE%B9%E9%80%9A%E4%BF%A1%E7%9A%84-API\"><span class=\"toc-text\">fabric 提供了 C++ 与两边通信的 API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%86%E5%9B%BE%E6%8B%8D%E5%B9%B3\"><span class=\"toc-text\">视图拍平</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%8D%E5%B9%B3%E5%89%8D\"><span class=\"toc-text\">拍平前</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%8D%E5%B9%B3\"><span class=\"toc-text\">拍平</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%8D%E5%B9%B3%E5%90%8E\"><span class=\"toc-text\">拍平后</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">线程模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">渲染场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">在后台线程中渲染</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">在主线程中渲染</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E6%88%96%E8%BF%9E%E7%BB%AD%E4%BA%8B%E4%BB%B6%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">默认或连续事件中断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E7%9B%B8%E5%B9%B2%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">不相干的事件中断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A5%E8%87%AA-JavaScript-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">来自 JavaScript 线程的后台线程批量更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C-%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">C++ 状态更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Turbo-Modules\"><span class=\"toc-text\">Turbo Modules</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Codegen\"><span class=\"toc-text\">Codegen</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React@16.5.0 syntheticEvent","uid":"8cd3fa1949a115d76dd37b87c1175bed","slug":"2022-07-20react-syntheticEvent","date":"2022-07-20T01:18:53.000Z","updated":"2022-11-21T13:08:33.112Z","comments":true,"path":"api/articles/2022-07-20react-syntheticEvent.json","keywords":null,"cover":[],"text":"本文说明本文主要内容是 React v16.5.0, 部分内容会涉及到 React v17+, React v17+合成事件与 React16 有很大差异 React 和事件系统概述见 &#x2F;** * * +------------+ . * | DOM | . * +--...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-设计模式","uid":"21c81236c6b792525b47c142ae6ad187","slug":"2022-07-18设计模式","date":"2022-07-18T06:53:04.000Z","updated":"2022-10-31T13:18:24.941Z","comments":true,"path":"api/articles/2022-07-18设计模式.json","keywords":null,"cover":null,"text":"为什么需要设计模式 有助于写出可复用&#x2F;可维护性更高的程序 原则：找出程序中变化的地方，并将变化封装起来，它的关键是意图，而不是结构 SOLID 设计原则S: Single Responsibility Principle 单一职责原则 对象应该仅具有一种单一功能 O: ...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}