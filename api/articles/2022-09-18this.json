{"title":"前端基础-this","uid":"f0c189916a4d9ce9f34f51ecbf84a8dc","slug":"2022-09-18this","date":"2022-09-18T04:09:38.000Z","updated":"2022-09-18T08:44:46.706Z","comments":true,"path":"api/articles/2022-09-18this.json","keywords":null,"cover":null,"content":"<h2 id=\"注意啦，注意啦\"><a href=\"#注意啦，注意啦\" class=\"headerlink\" title=\"注意啦，注意啦\"></a>注意啦，注意啦</h2><p>以下皆对普通函数而言，箭头函数可不是这么玩的</p>\n<h2 id=\"为什要有-this\"><a href=\"#为什要有-this\" class=\"headerlink\" title=\"为什要有 this\"></a>为什要有 this</h2><p>this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。</p>\n<p>简单来说：this，被放到作用域中， 为了简化代码</p>\n<h2 id=\"this-是如何定义的\"><a href=\"#this-是如何定义的\" class=\"headerlink\" title=\"this 是如何定义的\"></a>this 是如何定义的</h2><p>简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的</p>\n<p>我们简单总结一下 this 的特点：</p>\n<ul>\n<li>this 是在运行时绑定的，不是在编写时绑定</li>\n<li>this 的绑定与函数的声明和位置没有任何关系</li>\n<li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</li>\n</ul>\n<p>简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>\n<h2 id=\"this-绑定规则\"><a href=\"#this-绑定规则\" class=\"headerlink\" title=\"this 绑定规则\"></a>this 绑定规则</h2><ul>\n<li>判断函数调用时是否使用了 new，即 new 绑定，如果使用了，则 this 绑定的是新创建的对象。</li>\n<li>函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。</li>\n<li>函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。</li>\n<li>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，在<code>严格模式下</code>，默认绑定的 this 是 undefined，<code>非严格模式</code>下绑定到全局对象。</li>\n</ul>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7115390077353590792\">https://juejin.cn/post/7115390077353590792</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"this-绑定的优先级\"><a href=\"#this-绑定的优先级\" class=\"headerlink\" title=\"this 绑定的优先级\"></a>this 绑定的优先级</h2><p>默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new(牛) 绑定</p>\n","text":"注意啦，注意啦以下皆对普通函数而言，箭头函数可不是这么玩的 为什要有 thisthis 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。 简单来说：this，被放到作用域中， 为了...","link":"","photos":[],"count_time":{"symbolsCount":838,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E5%95%A6%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%95%A6\"><span class=\"toc-text\">注意啦，注意啦</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E8%A6%81%E6%9C%89-this\"><span class=\"toc-text\">为什要有 this</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84\"><span class=\"toc-text\">this 是如何定义的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99\"><span class=\"toc-text\">this 绑定规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">this 绑定的优先级</span></a></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-qa","uid":"d55ac1d91034293bfc294fd694ca97c4","slug":"2022-09-19qa","date":"2022-09-18T09:13:05.000Z","updated":"2022-09-18T12:00:59.094Z","comments":true,"path":"api/articles/2022-09-19qa.json","keywords":null,"cover":[],"text":"var let const 区别： 版本： var 是 es6 之前， const、let es6 之后， 分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域 提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"vscode 常用快捷键（持续更新...）","uid":"5380d0b3be253a4f070c3aa29aef0cf7","slug":"2022-09-17vscode-shortcuts","date":"2022-09-17T13:55:58.000Z","updated":"2022-09-18T12:10:11.372Z","comments":true,"path":"api/articles/2022-09-17vscode-shortcuts.json","keywords":null,"cover":[],"text":"选中多个相同的元素cmd + d; &#x2F;&#x2F; 每次向后多选一个相同的 选中相同内容cmd + shift + L; &#x2F;&#x2F; 全文，选相同内容 多位置同时编辑cmd + 点击; 选择一块内容cmd + shift + 上; &#x2F;&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"vscode","slug":"vscode","count":3,"path":"api/categories/vscode.json"}],"tags":[{"name":"vscode","slug":"vscode","count":7,"path":"api/tags/vscode.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}