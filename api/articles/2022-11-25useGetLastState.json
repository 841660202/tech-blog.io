{"title":"useGetLastState","uid":"9322ab91805d186b28cb967a708e37ed","slug":"2022-11-25useGetLastState","date":"2022-11-25T05:49:23.000Z","updated":"2022-11-26T07:05:03.119Z","comments":true,"path":"api/articles/2022-11-25useGetLastState.json","keywords":null,"cover":null,"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>有时候，我们想要利用 useState 来更新数据，并且有时候，我们需要不断的拿到最新的值，来继续进行数据更新，频率很高～</p>\n<p><code>简单场景</code>：同时我们晓得用<code>setState(preState=&gt; newState)</code>，来继续更新最新的值，这种用法在简单业务中使用没问题，复杂业务场景，无法应对<br><code>复杂场景：</code>比如我们需要用 <code>preState</code> 进行复杂的逻辑运算, 这时候我们可能将<code>setState</code>进行函数剥离，如果在这个函数中我们还要进行其他 state 计算，&#x3D;&#x3D;</p>\n<h2 id=\"之前处理\"><a href=\"#之前处理\" class=\"headerlink\" title=\"之前处理\"></a>之前处理</h2><p>在组件中使用<code>useRef</code>存一份数据，计算时候使用<code>useRef</code>数据，渲染时候使用<code>useState</code>,之前没有封装，用起来存在维护多条数据的情况</p>\n<h2 id=\"useGetState\"><a href=\"#useGetState\" class=\"headerlink\" title=\"useGetState\"></a>useGetState</h2><p>setState 使用的是 useState 的第二解构，那么 stateRef，后面也就没维护，因此：useGetState 并不满足需要，我想，这应该是此勾子设计缺陷，可能作者没考虑到上面的背景</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;\n\ntype GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;\n\nfunction useGetState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];\nfunction useGetState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,\n  GetStateAction&lt;S | undefined&gt;\n];\nfunction useGetState&lt;S&gt;(initialState?: S) &#123;\n  const [state, setState] &#x3D; useState(initialState);\n  const stateRef &#x3D; useRef(state);\n  stateRef.current &#x3D; state;\n\n  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);\n  &#x2F;&#x2F; setState使用的是useState的第二解构，那么stateRef，后面也就没维护\n  return [state, setState, getState];\n&#125;\n\nexport default useGetState;</code></pre>\n\n<h2 id=\"useGetLastState\"><a href=\"#useGetLastState\" class=\"headerlink\" title=\"useGetLastState\"></a>useGetLastState</h2><p>这里，将<code>_setState</code> 设置为私有，对外提供 setState，更新 useRef 和 useState 的值</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;\n\ntype GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;\n\nfunction useGetLastState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];\nfunction useGetLastState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,\n  GetStateAction&lt;S | undefined&gt;\n];\nfunction useGetLastState&lt;S&gt;(initialState?: S) &#123;\n  const [state, _setState] &#x3D; useState(initialState);\n  const stateRef &#x3D; useRef(state);\n  stateRef.current &#x3D; state;\n\n  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);\n  &#x2F;&#x2F; 这里，将_setState设置为私有，对外提供setState，更新useRef和useState的值\n  const setState &#x3D; useCallback((value) &#x3D;&gt; &#123;\n    stateRef.current &#x3D; value;\n    _setState(stateRef.current);\n  &#125;, []);\n\n  return [state, setState, getState];\n&#125;\n\nexport default useGetLastState;</code></pre>\n\n<h2 id=\"贡献代码？\"><a href=\"#贡献代码？\" class=\"headerlink\" title=\"贡献代码？\"></a>贡献代码？</h2><p>想了下，又要提 pre，又要测试…</p>\n<p>嗯～，哈～，一个字总结：懒</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://ahooks.js.org/zh-CN/hooks/use-get-state\" target=\"_blank\" >https://ahooks.js.org/zh-CN/hooks/use-get-state</a></p>\n<p><a href=\"https://github.com/alibaba/hooks/blob/e78af708e2bd44affc44f195e310ac84b6e91f4c/packages/hooks/src/useGetState/index.ts#L14\" target=\"_blank\" >useGetState 源码</a></p>\n","text":"背景有时候，我们想要利用 useState 来更新数据，并且有时候，我们需要不断的拿到最新的值，来继续进行数据更新，频率很高～ 简单场景：同时我们晓得用setState(preState=&gt; newState)，来继续更新最新的值，这种用法在简单业务中使用没问题，复杂业务场...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"React","slug":"React","count":28,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":22,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%8B%E5%89%8D%E5%A4%84%E7%90%86\"><span class=\"toc-text\">之前处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useGetState\"><span class=\"toc-text\">useGetState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useGetLastState\"><span class=\"toc-text\">useGetLastState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">贡献代码？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"1.系统学习 mysql 操作","uid":"2dc569547b91ee92b16da7ef33c8ec1b","slug":"2022-11-26mysql-操作","date":"2022-11-26T01:00:20.000Z","updated":"2022-12-02T14:12:17.833Z","comments":true,"path":"api/articles/2022-11-26mysql-操作.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","text":"库操作-- 创建 CREATE DATABASE [IF NOT EXISTS] database_name [CHARACTER SET charset_name] [COLLATE collation_name] -- 查看建库语句 SHOW CREATE DATABASE ...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"组件库开发 Storybook(待补)","uid":"2f2a1dbb480f2860f9722fc87c8a2adf","slug":"2022-11-24storybook","date":"2022-11-24T01:37:43.000Z","updated":"2022-12-02T13:20:57.186Z","comments":true,"path":"api/articles/2022-11-24storybook.json","keywords":null,"cover":[],"text":"背景最近维护一个项目，项目中的业务组件是单独维护的，至于为什么，不是很清楚。 疑问优点 难道只是为了开发方便，项目用的公司内定的 nextjs 3.x.x 的版本？webpack 编译速度太慢？ 缺点 难复用：因为接口是写到业务组件中的，其他项目要想复，有一定的难度（虽然公司应用...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Npm","slug":"Npm","count":2,"path":"api/categories/Npm.json"}],"tags":[{"name":"Npm","slug":"Npm","count":2,"path":"api/tags/Npm.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}