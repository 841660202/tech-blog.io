{"title":"Pinia","uid":"6a13b89bc1d9db16e3bd75ad19728f7b","slug":"2023-05-17pinia","date":"2023-05-17T13:08:07.000Z","updated":"2023-07-08T01:06:25.354Z","comments":true,"path":"api/articles/2023-05-17pinia.json","keywords":null,"cover":null,"content":"<h1 id=\"pinia\"><a href=\"#pinia\" class=\"headerlink\" title=\"pinia\"></a>pinia</h1><p>Pinia 是一个为 Vue 3 开发的状态管理库，它提供了一种简单、直观的方式来管理 Vue 3 应用程序的状态。与 Vue 2 的 Vuex 不同，Pinia 不依赖于任何全局状态，而是将所有状态都存储在本地的 Store 实例中，这使得 Pinia 更加模块化和灵活。</p>\n<p>Pinia 提供了以下几个主要的特点：</p>\n<ol>\n<li><p><strong>类型安全</strong>：Pinia 使用 TypeScript 实现，可以在编译时捕获类型错误，从而减少运行时的错误。开发者可以使用 TypeScript 的类型定义来管理 Store 的状态和操作，让代码更加清晰、直观。</p>\n</li>\n<li><p><strong>插件化</strong>：Pinia 可以轻松地集成第三方插件，如 Devtools 插件、Persisted State 插件等，从而扩展 Pinia 的功能。</p>\n</li>\n<li><p><strong>更好的可测试性</strong>：Pinia 的 Store 是一个普通的类，因此可以像测试普通的类一样测试 Store 的状态和操作。同时，Pinia 还提供了一些工具函数来方便测试。</p>\n</li>\n<li><p><strong>更好的 TypeScript 支持</strong>：Pinia 提供了完整的 TypeScript 类型定义，从而提供更好的 TypeScript 支持。</p>\n</li>\n</ol>\n<p>Pinia 的核心是 Store，一个包含应用程序状态和操作的对象。Store 可以通过创建一个带有状态和操作的类来定义。然后，Store 实例可以在组件中使用，从而实现状态的共享和管理。</p>\n<p>总的来说，Pinia 是一个简单、直观、灵活、类型安全的状态管理库，为 Vue 3 应用程序提供了更好的状态管理方案，同时提供了更好的 TypeScript 支持、插件化、可测试性等优点。</p>\n<h1 id=\"pinia-有哪些-API\"><a href=\"#pinia-有哪些-API\" class=\"headerlink\" title=\"pinia 有哪些 API\"></a>pinia 有哪些 API</h1><p>Pinia 提供了一组 API 来创建和管理 Vuex 风格的 Store。下面是 Pinia 的一些核心 API：</p>\n<ol>\n<li><p><code>defineStore</code>: 用于定义一个新的 Store。它接受一个标识符和一个包含状态、操作、获取器和变更的对象，并返回一个 Store 类。</p>\n</li>\n<li><p><code>createPinia</code>: 创建一个 Pinia 实例。你可以通过它来创建和管理多个 Store。</p>\n</li>\n<li><p><code>useStore</code>: 在组件中使用 Store。它接受一个 Store 类或标识符，并返回一个与该 Store 关联的实例。在组件的 <code>setup</code> 函数中使用它来访问 Store 中的状态和方法。</p>\n</li>\n<li><p><code>provide</code> 和 <code>inject</code>: 在应用程序中提供和注入 Pinia 实例。通过在应用程序的根组件中使用 <code>provide</code>，可以将 Pinia 实例注入到整个应用程序中，然后在子组件中使用 <code>inject</code> 来获取该实例。</p>\n</li>\n<li><p><code>pinia.use</code>: 注册 Pinia 插件。可以使用它来添加全局的中间件、插件或钩子函数。</p>\n</li>\n<li><p><code>pinia.$state</code>: 访问当前应用程序中所有 Store 的状态。它返回一个包含所有 Store 状态的对象。</p>\n</li>\n</ol>\n<p>这些是 Pinia 的一些核心 API，用于创建、管理和使用 Store。通过使用这些 API，你可以构建强大的状态管理系统，使你的 Vue 3 应用程序更加灵活和可维护。更多关于 Pinia 的详细信息和其他 API，请查阅 Pinia 的官方文档。</p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><p>要使用 Pinia，你需要按照以下步骤进行设置和配置：</p>\n<ol>\n<li><p>安装 Pinia：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install pinia</code></pre>\n</li>\n<li><p>在应用程序的入口文件中创建 Pinia 实例并安装插件（可选）：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createApp &#125; from &#39;vue&#39;;\nimport &#123; createPinia &#125; from &#39;pinia&#39;;\nimport App from &#39;.&#x2F;App.vue&#39;;\n\nconst app &#x3D; createApp(App);\nconst pinia &#x3D; createPinia();\n\n&#x2F;&#x2F; 安装插件（可选）\n&#x2F;&#x2F; pinia.use(...)\n\napp.use(pinia);\napp.mount(&#39;#app&#39;);</code></pre>\n</li>\n<li><p>创建一个 Store：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore &#x3D; defineStore(&#39;counter&#39;, &#123;\n  state() &#123;\n    return &#123;\n      count: 0,\n    &#125;;\n  &#125;,\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    decrement() &#123;\n      this.count--;\n    &#125;,\n  &#125;,\n  getters: &#123;\n    doubleCount() &#123;\n      return this.count * 2;\n    &#125;,\n  &#125;,\n&#125;);</code></pre>\n</li>\n<li><p>在组件中使用 Store：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;Count: &#123;&#123; counter.count &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;p&gt;Double Count: &#123;&#123; counter.doubleCount &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;button @click&#x3D;&quot;counter.increment()&quot;&gt;Increment&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;counter.decrement()&quot;&gt;Decrement&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; useCounterStore &#125; from &#39;.&#x2F;store&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const counter &#x3D; useCounterStore();\n\n    return &#123; counter &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;</code></pre></li>\n</ol>\n<p>在这个示例中，我们首先通过 <code>defineStore</code> 定义了一个名为 <code>useCounterStore</code> 的 Store，其中包含了状态 <code>count</code>、操作 <code>increment</code> 和 <code>decrement</code>，以及 getter <code>doubleCount</code>。然后，在组件中使用 <code>useCounterStore</code> 创建了一个 <code>counter</code> 实例，通过 <code>counter</code> 实例可以访问和操作 Store 中的状态和方法。</p>\n<p>你可以根据自己的需求定义更多的 Store，并在组件中使用它们。通过这种方式，你可以更好地管理应用程序的状态，并实现状态在组件之间的共享和交互。</p>\n<p>除了基本的状态管理功能外，Pinia 还提供了其他功能，如插件、严格模式、Devtools 等，你可以根据需要使用它们来扩展和优化你的应用程序。</p>\n<h1 id=\"多-store\"><a href=\"#多-store\" class=\"headerlink\" title=\"多 store\"></a>多 store</h1><p>使用 Pinia，你可以轻松地创建和使用多个 Store。以下是在一个 Vue 3 应用程序中使用多个 Store 的示例：</p>\n<ol>\n<li>创建多个 Store：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; counter.js\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore &#x3D; defineStore(&#39;counter&#39;, &#123;\n  state() &#123;\n    return &#123;\n      count: 0,\n    &#125;;\n  &#125;,\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    decrement() &#123;\n      this.count--;\n    &#125;,\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; user.js\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useUserStore &#x3D; defineStore(&#39;user&#39;, &#123;\n  state() &#123;\n    return &#123;\n      name: &#39;John Doe&#39;,\n      age: 30,\n    &#125;;\n  &#125;,\n  actions: &#123;\n    updateName(newName) &#123;\n      this.name &#x3D; newName;\n    &#125;,\n    updateAge(newAge) &#123;\n      this.age &#x3D; newAge;\n    &#125;,\n  &#125;,\n  getters: &#123;\n    isAdult() &#123;\n      return this.age &gt;&#x3D; 18;\n    &#125;,\n  &#125;,\n&#125;);</code></pre>\n\n<ol start=\"2\">\n<li>在组件中使用多个 Store：</li>\n</ol>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;Counter: &#123;&#123; counter.count &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;p&gt;User: &#123;&#123; user.name &#125;&#125;, Age: &#123;&#123; user.age &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;p&gt;Is Adult: &#123;&#123; user.isAdult &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;button @click&#x3D;&quot;counter.increment()&quot;&gt;Increment&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;counter.decrement()&quot;&gt;Decrement&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;user.updateName(&#39;Alice&#39;)&quot;&gt;Update Name&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;user.updateAge(25)&quot;&gt;Update Age&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; useCounterStore &#125; from &#39;.&#x2F;counter&#39;;\nimport &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const counter &#x3D; useCounterStore();\n    const user &#x3D; useUserStore();\n\n    return &#123; counter, user &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>在这个示例中，我们创建了两个 Store：<code>useCounterStore</code> 和 <code>useUserStore</code>，分别用于管理计数器和用户信息。在组件中，我们通过 <code>useCounterStore</code> 和 <code>useUserStore</code> 创建了 <code>counter</code> 和 <code>user</code> 实例，分别代表两个 Store 的实例。通过这些实例，我们可以访问和操作各自 Store 中的状态和方法。</p>\n<p>使用多个 Store 可以让你更好地组织和管理应用程序的状态。你可以按照需要创建更多的 Store，并在组件中使用它们。每个 Store 都是相互独立的，具有自己的状态和操作，但它们可以在组件中共享和交互，使得状态管理更加灵活和可扩展。</p>\n<h1 id=\"pinia-的多-store-有点像-react-useReducer\"><a href=\"#pinia-的多-store-有点像-react-useReducer\" class=\"headerlink\" title=\"pinia 的多 store 有点像 react useReducer\"></a>pinia 的多 store 有点像 react useReducer</h1><p>是的，Pinia 的多个 Store 的概念与 React 中的 useReducer 类似。它们都提供了一种在应用程序中组织和管理状态的方式，但在实现和使用上有一些区别。</p>\n<p>Pinia 的多个 Store 是基于 Vue 3 的状态管理库，每个 Store 都是一个独立的实例，包含了状态和操作。通过创建多个 Store，你可以更好地组织和管理应用程序的状态，并在组件中使用它们。每个 Store 都可以单独访问和修改自己的状态，而且可以在组件中共享和交互，通过 Store 实例进行通信和状态更新。</p>\n<p>React 中的 useReducer 是一个 Hook，它提供了状态管理和更新的功能，通过定义 reducer 函数和初始状态，可以在组件中使用 useReducer 来管理状态。使用 useReducer，你可以将状态和相关操作封装在一起，以便在组件中进行更新和使用。</p>\n<p>虽然 Pinia 的多个 Store 和 React 的 useReducer 都用于状态管理，但它们的实现方式和使用方法略有不同。Pinia 的多个 Store 是基于 Vue 3 的状态管理库，提供了更多的特性和工具，如插件、严格模式、类型安全等。而 React 的 useReducer 是 React 提供的一个 Hook，更加简洁和轻量。</p>\n<p>综上所述，Pinia 的多个 Store 和 React 的 useReducer 在目的上相似，但在实现和使用上有一些差异。你可以根据具体的框架和需求选择适合的状态管理方式。</p>\n<h1 id=\"useStore-完整代码示例\"><a href=\"#useStore-完整代码示例\" class=\"headerlink\" title=\"useStore 完整代码示例\"></a>useStore 完整代码示例</h1><p>以下是一个完整的代码示例，演示了如何使用 Pinia 创建多个 Store 并在组件中使用它们：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;Counter: &#123;&#123; counter.count &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;p&gt;User: &#123;&#123; user.name &#125;&#125;, Age: &#123;&#123; user.age &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;button @click&#x3D;&quot;counter.increment()&quot;&gt;Increment&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;counter.decrement()&quot;&gt;Decrement&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;user.updateName(&#39;Alice&#39;)&quot;&gt;Update Name&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;user.updateAge(25)&quot;&gt;Update Age&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; defineStore, useStore &#125; from &#39;pinia&#39;;\n\n&#x2F;&#x2F; 定义 CounterStore\nconst counterStore &#x3D; defineStore(&#39;counter&#39;, &#123;\n  state() &#123;\n    return &#123;\n      count: 0,\n    &#125;;\n  &#125;,\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    decrement() &#123;\n      this.count--;\n    &#125;,\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; 定义 UserStore\nconst userStore &#x3D; defineStore(&#39;user&#39;, &#123;\n  state() &#123;\n    return &#123;\n      name: &#39;John Doe&#39;,\n      age: 30,\n    &#125;;\n  &#125;,\n  actions: &#123;\n    updateName(newName) &#123;\n      this.name &#x3D; newName;\n    &#125;,\n    updateAge(newAge) &#123;\n      this.age &#x3D; newAge;\n    &#125;,\n  &#125;,\n&#125;);\n\nexport default &#123;\n  setup() &#123;\n    &#x2F;&#x2F; 使用 useStore 获取 CounterStore 和 UserStore 的实例\n    const counter &#x3D; useStore(counterStore);\n    const user &#x3D; useStore(userStore);\n\n    return &#123;\n      counter,\n      user,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>在这个示例中，我们首先使用 <code>defineStore</code> 函数分别定义了名为 <code>&#39;counter&#39;</code> 的 CounterStore 和名为 <code>&#39;user&#39;</code> 的 UserStore，它们分别管理计数器和用户信息的状态和操作。</p>\n<p>在组件的 <code>setup</code> 函数中，我们使用 <code>useStore</code> 函数获取 CounterStore 和 UserStore 的实例。通过 <code>counter</code> 和 <code>user</code> 实例，我们可以在组件中访问和操作对应 Store 中的状态和方法。</p>\n<p>在模板中，我们展示了 CounterStore 中的计数器值和 UserStore 中的用户名和年龄，并通过按钮点击事件调用相应的方法来更新状态。</p>\n<p>这个示例演示了如何使用 Pinia 创建多个 Store，并在组件中使用它们。通过这种方式，你可以更好地组织和管理应用程序的状态，并在组件之间共享和交互数据。</p>\n<h1 id=\"provide-inject-有点像-react-context\"><a href=\"#provide-inject-有点像-react-context\" class=\"headerlink\" title=\"provide inject 有点像 react context\"></a>provide inject 有点像 react context</h1><p>是的，<code>provide</code> 和 <code>inject</code> 在一定程度上类似于 React 中的 Context API。它们都提供了一种在组件之间共享数据的方式，而不需要通过逐层传递 props 来传递数据。</p>\n<p>在 Vue 3 中，<code>provide</code> 和 <code>inject</code> 是一对配套的 API，用于在组件树中提供和注入数据。通过在父组件中使用 <code>provide</code> 来提供数据，然后在子组件中使用 <code>inject</code> 来注入该数据，子组件就可以访问到提供的数据，而不论组件之间的嵌套层级有多深。</p>\n<p>与 React 的 Context API 类似，<code>provide</code> 和 <code>inject</code> 的目的是为了解决跨组件的数据共享问题。它们提供了一种更简便的方式来共享数据，避免了逐层传递 props 的麻烦，并且在需要访问共享数据的组件中可以更方便地获取数据。</p>\n<p>然而，需要注意的是，Vue 3 中的 <code>provide</code> 和 <code>inject</code> 是基于响应式系统的。这意味着当提供的数据发生变化时，使用 <code>inject</code> 注入的组件也会响应式地更新。这与 React 的 Context API 在更新时需要手动管理更新的方式有所不同。</p>\n<p>总而言之，<code>provide</code> 和 <code>inject</code> 在 Vue 3 中提供了一种方便的方式来实现组件之间的数据共享，类似于 React 中的 Context API，但在一些实现细节和用法上有所区别。</p>\n<h1 id=\"provide-inject-完整示例\"><a href=\"#provide-inject-完整示例\" class=\"headerlink\" title=\"provide inject 完整示例\"></a>provide inject 完整示例</h1><p>以下是一个完整的示例，展示了如何使用 <code>provide</code> 和 <code>inject</code> 在 Vue 3 中提供和注入 Pinia 实例：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;!-- App.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Pinia Provide&#x2F;Inject Example&lt;&#x2F;h1&gt;\n    &lt;ChildComponent &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; createApp, provide &#125; from &#39;vue&#39;;\nimport &#123; createPinia &#125; from &#39;pinia&#39;;\nimport &#123; counterStore &#125; from &#39;.&#x2F;stores&#39;;\nimport ChildComponent from &#39;.&#x2F;ChildComponent.vue&#39;;\n\nconst pinia &#x3D; createPinia();\n\nprovide(piniaSymbol, pinia); &#x2F;&#x2F; 提供 Pinia 实例\n\ncreateApp(&#123;\n  components: &#123;\n    ChildComponent,\n  &#125;,\n&#125;).mount(&#39;#app&#39;);\n&lt;&#x2F;script&gt;</code></pre>\n\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;!-- ChildComponent.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;Child Component&lt;&#x2F;h2&gt;\n    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;button @click&#x3D;&quot;increment&quot;&gt;Increment&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; inject &#125; from &#39;vue&#39;;\nimport &#123; piniaSymbol &#125; from &#39;.&#x2F;stores&#39;;\nimport &#123; useStore &#125; from &#39;pinia&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const pinia &#x3D; inject(piniaSymbol); &#x2F;&#x2F; 注入 Pinia 实例\n    const counter &#x3D; useStore(counterStore); &#x2F;&#x2F; 使用 useStore 获取 Store 实例\n\n    return &#123;\n      count: counter.count,\n      increment: counter.increment,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>在这个示例中，我们首先在根组件的 <code>provide</code> 中提供了 Pinia 实例。我们使用 <code>createPinia</code> 创建了 Pinia 实例 <code>pinia</code>，并使用 <code>piniaSymbol</code> 作为提供的键。</p>\n<p>然后，在子组件中，我们使用 <code>inject</code> 注入了 Pinia 实例，并通过 <code>useStore</code> 函数获取了 CounterStore 的实例。在组件的 <code>setup</code> 函数中，我们可以直接访问 CounterStore 实例的状态和方法，并将它们绑定到模板中。</p>\n<p>通过使用 <code>provide</code> 和 <code>inject</code>，我们可以在整个应用程序中共享和访问 Pinia 实例和 Store 实例，从而实现全局的状态管理。请确保在使用 <code>inject</code> 时提供正确的键，以便获取正确的 Pinia 实例。</p>\n<h2 id=\"pinia-use\"><a href=\"#pinia-use\" class=\"headerlink\" title=\"pinia.use\"></a>pinia.use</h2><p><code>pinia.use</code> 是 Pinia 提供的一个方法，用于注册 Pinia 插件。通过注册插件，可以扩展和定制 Pinia 的功能。以下是一个示例，展示了如何使用 <code>pinia.use</code> 注册一个插件：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createPinia, piniaPlugin &#125; from &#39;pinia&#39;;\n\n&#x2F;&#x2F; 定义插件\nconst myPlugin &#x3D; &#123;\n  &#x2F;&#x2F; 在插件中可以定义各种钩子函数和功能\n  &#x2F;&#x2F; 在这个示例中，我们简单地在安装插件时输出一条消息\n  install(pinia) &#123;\n    console.log(&#39;My Plugin is installed!&#39;);\n  &#125;,\n&#125;;\n\nconst pinia &#x3D; createPinia();\n\n&#x2F;&#x2F; 注册插件\npinia.use(myPlugin);\npinia.use(piniaPlugin); &#x2F;&#x2F; 可选：也可以注册 Pinia 自带的插件\n\n&#x2F;&#x2F; 创建 App 实例并挂载\ncreateApp(App).use(pinia).mount(&#39;#app&#39;);</code></pre>\n\n<p>在这个示例中，我们首先创建了一个 Pinia 实例 <code>pinia</code>。然后，我们使用 <code>pinia.use</code> 方法注册了一个自定义插件 <code>myPlugin</code> 和 Pinia 自带的插件 <code>piniaPlugin</code>。</p>\n<p>在插件的 <code>install</code> 方法中，我们可以添加各种自定义的逻辑和功能。在这个示例中，我们只是简单地在安装插件时输出一条消息。</p>\n<p>最后，我们将 <code>pinia</code> 实例作为插件使用 <code>createApp</code> 创建的 Vue 应用程序的插件，并将其挂载到应用程序的根节点上。</p>\n<p>通过使用 <code>pinia.use</code> 方法，我们可以注册和使用各种插件来扩展 Pinia 的功能，并根据应用程序的需要进行定制。</p>\n<h2 id=\"storeToRefs\"><a href=\"#storeToRefs\" class=\"headerlink\" title=\"storeToRefs\"></a>storeToRefs</h2><p>store 是一个用 reactive 包装的对象，这意味着不需要在 getters 后面写 .value，就像 setup 中的 props 一样</p>\n<p>为了从 store 中提取属性时保持其响应性，你需要使用 storeToRefs()。它将为每一个响应式属性创建引用。当你只使用 store 的状态而不调用任何 action 时，它会非常有用。请注意，你可以直接从 store 中解构 action，因为它们也被绑定到 store 上</p>\n<p><a href=\"https://pinia.vuejs.org/zh/core-concepts/#:~:text=%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-,storeToRefs,-()%E3%80%82%E5%AE%83%E5%B0%86\" target=\"_blank\" >storeToRefs</a></p>\n<h1 id=\"pinia-State-为什么是函数\"><a href=\"#pinia-State-为什么是函数\" class=\"headerlink\" title=\"pinia State 为什么是函数\"></a>pinia State 为什么是函数</h1><p>在 Pinia 中，<code>State</code> 是一个函数的原因是为了实现状态的惰性初始化和独立性。</p>\n<p>通过将状态定义为函数，可以确保每个组件实例都有自己独立的状态，并且在需要时进行初始化。</p>\n<p>以下是一个示例，展示了如何使用函数定义状态：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const counterStore &#x3D; defineStore(&#39;counter&#39;, () &#x3D;&gt; (&#123;\n  count: 0,\n&#125;));</code></pre>\n\n<p>在这个示例中，我们使用函数来定义 <code>counterStore</code> 的状态。通过直接将函数作为参数传递给 <code>defineStore</code>，函数会在每个组件实例化时被调用，并返回初始状态的对象。</p>\n<p>这样，每个组件实例都会有自己的独立状态，并且在第一次访问时进行初始化。</p>\n<p>通过将状态定义为函数，Pinia 提供了更简化的方式来管理状态，同时确保每个组件实例都有独立的状态。这样可以避免状态之间的干扰，并实现状态的惰性初始化。</p>\n<h1 id=\"每个组件实例都会有自己的独立状态\"><a href=\"#每个组件实例都会有自己的独立状态\" class=\"headerlink\" title=\"每个组件实例都会有自己的独立状态\"></a>每个组件实例都会有自己的独立状态</h1><p>如果你希望每个组件实例都有自己的独立状态，可以使用 <code>defineStore</code> 定义一个独立的 Store，并在组件中使用 <code>useStore</code> 辅助函数获取该独立的 Store 实例。</p>\n<p>以下是一个示例，展示了如何让每个组件实例都有自己的独立状态：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineComponent &#125; from &#39;vue&#39;;\nimport &#123; useStore &#125; from &#39;pinia&#39;;\nimport &#123; counterStore &#125; from &#39;.&#x2F;counterStore&#39;;\n\nexport default defineComponent(&#123;\n  setup() &#123;\n    &#x2F;&#x2F; 获取独立的 Store 实例\n    const store &#x3D; useStore(counterStore);\n\n    &#x2F;&#x2F; 使用独立的状态\n    const count &#x3D; store.count;\n\n    &#x2F;&#x2F; 修改独立的状态\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      store.count++;\n    &#125;;\n\n    return &#123; count, increment &#125;;\n  &#125;,\n&#125;);</code></pre>\n\n<p>在这个示例中，我们使用 <code>useStore</code> 辅助函数来获取一个独立的 Store 实例 <code>counterStore</code>，而不是全局的 Store 实例。每个组件实例都会有自己独立的 <code>count</code> 状态，并且对状态的修改不会影响其他组件。</p>\n<p>总结起来，如果你想让组件之间共享状态，可以使用全局的 Store 实例。如果你想让每个组件实例都有自己的独立状态，可以使用独立的 Store 实例。具体使用哪种方式取决于你的应用程序需求和设计。</p>\n<h1 id=\"pinia-State-不是函数\"><a href=\"#pinia-State-不是函数\" class=\"headerlink\" title=\"pinia State 不是函数\"></a>pinia State 不是函数</h1><p>抱歉之前的回答有误，Pinia 中的 State 不是函数。</p>\n<p>在 Pinia 中，State 是通过对象字面量或类来定义的。它不是函数，而是一个对象或类的实例，用于表示状态的初始值。</p>\n<p>以下是一个示例，展示了如何在 Pinia 中定义 State：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const counterStore &#x3D; defineStore(&#123;\n  id: &#39;counter&#39;,\n  state: () &#x3D;&gt; (&#123;\n    count: 0,\n  &#125;),\n&#125;);</code></pre>\n\n<p>在这个示例中，我们使用 <code>defineStore</code> 方法来定义一个名为 <code>counterStore</code> 的 Store。在 <code>state</code> 选项中，我们通过函数返回一个对象，该对象包含状态的初始值。在这种情况下，<code>count</code> 初始值为 0。</p>\n<p>每当创建 <code>counterStore</code> 的实例时，Pinia 会为该实例分配一个独立的状态对象。这意味着每个组件实例化时都会有自己的独立状态。</p>\n<p>所以，正确的说法是 Pinia 中的 State 是一个对象或类的实例，用于表示状态的初始值，并且每个组件实例化时都会有自己的独立状态。</p>\n<h1 id=\"代码简化\"><a href=\"#代码简化\" class=\"headerlink\" title=\"代码简化\"></a>代码简化</h1><p>在 Pinia 中，State 可以通过对象字面量直接定义，而不需要使用函数。</p>\n<p>以下是一个简化的示例，展示了如何在 Pinia 中定义 State：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const counterStore &#x3D; defineStore(&#123;\n  id: &#39;counter&#39;,\n  state: &#123;\n    count: 0,\n  &#125;,\n&#125;);</code></pre>\n\n<p>在这个示例中，我们使用对象字面量的方式直接定义 <code>counterStore</code> 的 State。<code>state</code> 选项接受一个对象，该对象包含状态的初始值。在这种情况下，<code>count</code> 的初始值为 0。</p>\n<p>这样，每当创建 <code>counterStore</code> 的实例时，Pinia 会为该实例分配一个独立的状态对象。每个组件实例化时都会有自己的独立状态。</p>\n<p>通过简化定义 State 的方式，可以更清晰地表示状态的初始值，并提供更简洁的代码。</p>\n<h1 id=\"重置-state\"><a href=\"#重置-state\" class=\"headerlink\" title=\"重置 state\"></a>重置 state</h1><p>你可以通过调用 store 的 $reset() 方法将 state 重置为初始值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const store &#x3D; useStore();\n\nstore.$reset();</code></pre>\n\n<p><a href=\"https://pinia.vuejs.org/zh/core-concepts/state.html#mutating-the-state\" target=\"_blank\" >到这里了</a></p>\n","text":"piniaPinia 是一个为 Vue 3 开发的状态管理库，它提供了一种简单、直观的方式来管理 Vue 3 应用程序的状态。与 Vue 2 的 Vuex 不同，Pinia 不依赖于任何全局状态，而是将所有状态都存储在本地的 Store 实例中，这使得 Pinia 更加模块化和灵...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"vue3","slug":"vue3","count":1,"path":"api/categories/vue3.json"}],"tags":[{"name":"vue3","slug":"vue3","count":1,"path":"api/tags/vue3.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pinia\"><span class=\"toc-text\">pinia</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pinia-%E6%9C%89%E5%93%AA%E4%BA%9B-API\"><span class=\"toc-text\">pinia 有哪些 API</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">如何使用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A-store\"><span class=\"toc-text\">多 store</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pinia-%E7%9A%84%E5%A4%9A-store-%E6%9C%89%E7%82%B9%E5%83%8F-react-useReducer\"><span class=\"toc-text\">pinia 的多 store 有点像 react useReducer</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#useStore-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">useStore 完整代码示例</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#provide-inject-%E6%9C%89%E7%82%B9%E5%83%8F-react-context\"><span class=\"toc-text\">provide inject 有点像 react context</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#provide-inject-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">provide inject 完整示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pinia-use\"><span class=\"toc-text\">pinia.use</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#storeToRefs\"><span class=\"toc-text\">storeToRefs</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pinia-State-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pinia State 为什么是函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E9%83%BD%E4%BC%9A%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%AC%E7%AB%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">每个组件实例都会有自己的独立状态</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pinia-State-%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pinia State 不是函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8C%96\"><span class=\"toc-text\">代码简化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%87%8D%E7%BD%AE-state\"><span class=\"toc-text\">重置 state</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"部署后，无法运行","uid":"16c06075633c447ebc480ad4e752e204","slug":"2023-05-18bug","date":"2023-05-18T03:03:01.000Z","updated":"2023-07-08T01:06:25.355Z","comments":true,"path":"api/articles/2023-05-18bug.json","keywords":null,"cover":[],"text":"日志2023-05-18T01:29:15.077Z ERROR next 63acefd419084df6 socrates &#123;&quot;stack&quot;:&quot;ReferenceError: Cannot access &#39;detail&#39;...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"next","slug":"next","count":1,"path":"api/categories/next.json"}],"tags":[{"name":"next","slug":"next","count":1,"path":"api/tags/next.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"组件库","uid":"c8e5bf059ccb884e44e277a41905094a","slug":"2023-05-16components","date":"2023-05-16T06:31:32.000Z","updated":"2023-05-29T00:41:07.269Z","comments":true,"path":"api/articles/2023-05-16components.json","keywords":null,"cover":[],"text":"目前用公司项目的几个问题组件库 组件库混乱 组件库封装的过大，依赖库过多，更有甚者，框架打包进去 组件库内部的使用的静态资源（如：字体），组件库没有引入 组件库更新不及时，项目中有用大版本依赖，组件库，大版本的低版本，ahooks 2,3 组件封装出来，没有人会用，找个组件的使用...","link":"","photos":[],"count_time":{"symbolsCount":686,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}