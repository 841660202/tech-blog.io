{"title":"7.系统学习 mysql 索引","uid":"156cde27ff1fb560c12a994aea6ee11c","slug":"2022-12-01mysql-索引","date":"2022-12-01T01:55:23.000Z","updated":"2022-12-02T13:20:57.188Z","comments":true,"path":"api/articles/2022-12-01mysql-索引.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","content":"<h2 id=\"索引的作用\"><a href=\"#索引的作用\" class=\"headerlink\" title=\"索引的作用\"></a>索引的作用</h2><p>使用索引快速查找具有特定列值的行</p>\n<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><ul>\n<li>使用主键或唯一键创建表时，MySQL 会自动创建一个名为 PRIMARY 的特殊索引。索引称为<code>聚簇索引</code></li>\n<li>PRIMARY 索引是特殊的，因为索引本身与数据一起存储在同一个表中。 <code>聚簇索引</code>强制执行表中的行顺序。</li>\n</ul>\n<pre class=\"line-numbers language-SQL\" data-language=\"SQL\"><code class=\"language-SQL\">-- 要为列或一组列添加索引，请使用以下CREATE INDEX语句：\n\nCREATE INDEX index_name ON table_name (column_list)\n\n-- 要为列或列列表创建索引，请指定索引名称，索引所属的表以及列列表。\n\n-- 例如，要为列c4添加新索引，请使用以下语句：\nCREATE INDEX idx_c4 ON t(c4);\n-- 默认情况下，如果未指定索引类型，MySQL将创建B-Tree索引</code></pre>\n\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><pre class=\"line-numbers language-SQL\" data-language=\"SQL\"><code class=\"language-SQL\">-- 要从表中删除现有索引，请使用以下DROP INDEX语句：\n\nDROP INDEX index_name ON table_name\n[algorithm_option | lock_option];\n\n-- DROP PRIMARY KEY索引\n\n-- 要删除PRIMARY主键的索引，请使用以下语句：\n\nDROP INDEX &#96;PRIMARY&#96; ON table_name;</code></pre>\n\n<p><strong>原理：</strong></p>\n<ul>\n<li>COPY：表逐行复制到新表，DROP INDEX 然后在原始表的副本上执行。并发数据操作语句例如 INSERT 和 UPDATE 不允许。</li>\n<li>INPLACE：表被重建到位而不是复制到新表。MySQL 在索引删除操作的准备和执行阶段期间在表上发出独占元数据锁。算法允许并发数据操作语句。</li>\n<li>DEFAULT 与省略 ALGORITHM 子句具有相同的效果</li>\n</ul>\n<h2 id=\"打印\"><a href=\"#打印\" class=\"headerlink\" title=\"打印\"></a>打印</h2><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 方式1\nSHOW INDEXES FROM table_name;\n\n-- 方式2\nSHOW INDEXES FROM table_name\nIN database_name;\n-- 方式3\nSHOW INDEXES FROM database_name.table_name;\n\n-- INDEX和KEY是INDEXES同义词，IN是FROM同义词，因此，您可以在SHOW INDEXES列中使用这些同义词。例如：\n\nSHOW INDEX IN table_name\nFROM database_name;\n\n-- 或者\nSHOW KEY FROM tablename\nIN databasename;\n</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202212011142162.webp\" />\n\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><h3 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h3><h4 id=\"为什么存在\"><a href=\"#为什么存在\" class=\"headerlink\" title=\"为什么存在\"></a>为什么存在</h4><p><strong>因为主键索引只能有一个，为了能有更多类似主键索引效果的索引</strong></p>\n<p>要强制执行一列或多列的唯一性值，通常使用 PRIMARY KEY 约束。但是，每个表只能有一个主键。</p>\n<p>因此，如果要包含多个列或一组具有唯一值的列，则不能使用主键约束。</p>\n<p>幸运的是，MySQL 提供了另一种指标叫做 UNIQUE 索引，使您可以强制执行值的唯一的一列或多列。与 PRIMARY KEY 索引不同，UNIQUE 每个表可以有多个索引。</p>\n<p>要创建 UNIQUE 索引，请使用以下 CREATE UNIQUE INDEX 语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 在一列或多列中强制执行值唯一性的另一种方法是使用 UNIQUE 约束。\n\n-- 方式1: 建表时增\nCREATE TABLE table_name(\n...\n   UNIQUE KEY(index_column_,index_column_2,...)\n);\n-- 方式2: 建表后增\nCREATE UNIQUE INDEX index_name\nON table_name(index_column_1,index_column_2,...);\n\n-- 方式3: 建表修改\n\nALTER TABLE table_name\nADD CONSTRAINT constraint_name UNIQUE KEY(column_1,column_2,...);</code></pre>\n\n<h3 id=\"前缀索引\"><a href=\"#前缀索引\" class=\"headerlink\" title=\"前缀索引\"></a>前缀索引</h3><h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><p>如果列是字符串列，则索引将占用大量磁盘空间并可能减慢 INSERT 操作速度。</p>\n<p>为解决此问题，MySQL 允许您使用以下语法为字符串列的列值的前导部分创建索引：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 在创建表时创建列前缀键部分\nCREATE TABLE table_name(\n    column_list,\n    INDEX(column_name(length))\n);\n\n-- 向现有表添加索引\nCREATE INDEX index_name\nON table_name(column_name(length));\n\n-- 使用\nSELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;\n</code></pre>\n\n<h4 id=\"优化前\"><a href=\"#优化前\" class=\"headerlink\" title=\"优化前\"></a>优化前</h4><img src=\"http://t-blog-images.aijs.top/img/202212011343544.webp\" />\n\n<h4 id=\"优化后\"><a href=\"#优化后\" class=\"headerlink\" title=\"优化后\"></a>优化后</h4><img src=\"http://t-blog-images.aijs.top/img/202212011344014.webp\" />\n\n<h4 id=\"评估优化-长度如何定，试出来的\"><a href=\"#评估优化-长度如何定，试出来的\" class=\"headerlink\" title=\"评估优化(长度如何定，试出来的)\"></a>评估优化(长度如何定，试出来的)</h4><p>我们将使用示例数据库中的 products 表进行演示。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">+--------------------+\n| products |\n+--------------------+\n| productCode |\n| productName |\n| productLine |\n| productScale |\n| productVendor |\n| productDescription |\n| quantityInStock |\n| buyPrice |\n| MSRP |\n+--------------------+\n9 rows in set (0.02 sec)\n</code></pre>\n\n<p>以下查询查找名称以字符串 1970 开头的产品：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;\n</code></pre>\n\n<p>由于 productName 列没有索引 ，查询优化器必须扫描所有行以返回结果，如 EXPLAIN 下面语句的输出所示：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">EXPLAIN SELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;</code></pre>\n\n<p>这是输出：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | products | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  110 |    11.11 | Using where |\n+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.02 sec)</code></pre>\n\n<p>如果您经常按产品名称找到产品，那么您应为此列创建索引，因为它对搜索更有效。</p>\n<p>产品名称列的大小为 70 个字符。我们可以使用列前缀关键部分。</p>\n<p><strong>接下来的问题是你如何选择前缀的长度？为此，您可以调查现有数据。目标是在使用前缀时最大化列中值的唯一性。</strong></p>\n<p>为此，请按照下列步骤操作：</p>\n<p>步骤 1.找到表中的行数：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT\n   COUNT(*)\nFROM\n   products;</code></pre>\n\n<p>第 2 步。评估不同的前缀长度，直到您可以实现行的合理唯一性：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT\n   COUNT(DISTINCT LEFT(productName, 20)) unique_rows\nFROM\n   products;\n+-------------+\n| unique_rows |\n+-------------+\n|         110 |\n+-------------+\n1 row in set (0.30 sec)</code></pre>\n\n<p>如输出中所示，在这种情况下，20 是一个良好的前缀长度，因为如果我们使用产品名称的前 20 个字符作为索引，则所有产品名称都是唯一的。</p>\n<p>让我们为 productName 列创建一个前缀长度为 20 的索引：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE INDEX idx_productname\nON products(productName(20));\n</code></pre>\n\n<p>并执行查询，查找名称以字符串 1970 开头的产品：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">EXPLAIN SELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;\n</code></pre>\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">+----+-------------+----------+------------+-------+-----------------+-----------------+---------+------+------+----------+-------------+\n| id | select_type | table    | partitions | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+----------+------------+-------+-----------------+-----------------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | products | NULL       | range | idx_productname | idx_productname | 62      | NULL |    4 |   100.00 | Using where |\n+----+-------------+----------+------------+-------+-----------------+-----------------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.02 sec)</code></pre>\n\n<p>现在，查询优化器使用新创建的索引，索引比以前更快，更高效。</p>\n<h3 id=\"隐形索引（就当-disabled-吧）\"><a href=\"#隐形索引（就当-disabled-吧）\" class=\"headerlink\" title=\"隐形索引（就当 disabled 吧）\"></a>隐形索引（就当 disabled 吧）</h3><h4 id=\"为什么存在-1\"><a href=\"#为什么存在-1\" class=\"headerlink\" title=\"为什么存在\"></a>为什么存在</h4><p><strong>为了将某些索引停用，来看这个索引是否对性能有影响</strong></p>\n<p>不可见索引允许您将索引标记为查询优化器不可用</p>\n<ul>\n<li>默认可见的。</li>\n<li>使不可见，您必须<code>在创建时或使用ALTER TABLE命令显式声明其可见性</code>。MySQL 为我们提供了维护索引可见性的关键字<code>VISIBLE</code>和<code>INVISIBLE</code>关键字。</li>\n</ul>\n<p>要创建不可见索引，请使用以下语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE INDEX index_name\nON table_name( c1, c2, ...) INVISIBLE;\n\n\n-- 在这个语法中：\n\n-- 首先，在CREATE INDEX子句后指定索引的名称。\n-- 其次，列出要添加到索引的表名和列列表。INVISIBLE关键字表明您正在创建的索引是不可见的。\n-- 例如，以下语句在示例数据库extension中的employees表的列上创建索引，并将其标记为不可见索引：\n\nCREATE INDEX extension\nON employees(extension) INVISIBLE;\n\n-- 要更改现有索引的可见性，请使用以下语句：\n\nALTER TABLE table_name\nALTER INDEX index_name [VISIBLE | INVISIBLE];\n\n-- 例如，要使extension索引可见，请使用以下语句：\nALTER TABLE employees\nALTER INDEX extension VISIBLE;\n-- 您可以通过查询information_schema数据库中的statistics表来查找索引及其可见性：\n\nSELECT\n    index_name,\n    is_visible\nFROM\n    information_schema.statistics\nWHERE\n    table_schema &#x3D; &#39;mysqldemo&#39;\n        AND table_name &#x3D; &#39;employees&#39;;\n\n</code></pre>\n\n<p>此外，您可以使用 SHOW INDEXES 命令显示表的所有索引：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SHOW INDEXES FROM employees;\n</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202212011414510.webp\" />\n\n<p>如前所述，查询优化器不使用不可见索引，那么为什么首先使用不可见索引？实际上，隐形索引有许多应用程序。</p>\n<p>例如，您可以使索引不可见，以查看它是否对性能产生影响，并将索引再次标记为可见。</p>\n<h4 id=\"主键索引不可隐藏\"><a href=\"#主键索引不可隐藏\" class=\"headerlink\" title=\"主键索引不可隐藏\"></a>主键索引不可隐藏</h4><h3 id=\"降序索引\"><a href=\"#降序索引\" class=\"headerlink\" title=\"降序索引\"></a>降序索引</h3><ul>\n<li>为了对<code>ORDER BY a DESC</code>进行优化</li>\n<li>降序索引是以降序存储键值的索引。</li>\n<li>在 MySQL 8.0 之前，您可以 DESC 在索引定义中指定。但是，MySQL 忽略了它。</li>\n<li>与此同时，MySQL 可以以相反的顺序扫描索引，但成本很高。</li>\n</ul>\n<h3 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h3><ul>\n<li>复合索引是多列的索引。MySQL 允许您创建一个<code>最多包含 16 列的复合索引</code>。</li>\n<li>复合索引也称为多列索引。</li>\n<li>查询优化器将复合索引用于测试索引中所有列的查询，或者测试第一列，前两列等的查询。</li>\n<li>如果在索引定义中以正确的顺序指定列，则单个复合索引可以在同一个表上加速这些类型的查询</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 要在创建表时创建复合索引，请使用以下语句：\n\nCREATE TABLE table_name (\n    c1 data_type PRIMARY KEY,\n    c2 data_type,\n    c3 data_type,\n    c4 data_type,\n    INDEX index_name (c2,c3,c4)\n);\n-- 在此语法中，复合索引由三列c2，c3和c4组成。\n\n-- 或者，您可以使用以下CREATE INDEX语句将复合索引添加到现有表：\n\nCREATE INDEX index_name\nON table_name(c2,c3,c4);\n-- 请注意，如果您在（c1，c2，c3）上有复合索引，则您将在以下列组合之一上建立索引搜索功能：\n\n(c1)\n(c1,c2)\n(c1,c2,c3)\n</code></pre>\n\n<h3 id=\"聚集索引\"><a href=\"#聚集索引\" class=\"headerlink\" title=\"聚集索引\"></a>聚集索引</h3><ul>\n<li>每个 InnoDB 表始终只有一个聚簇索引</li>\n<li>有主键 MySQL 使用主键作为聚簇索引。</li>\n<li>无主键，MySQL 将搜索 UNIQUE 所有键列所在的第一个索引，NOT NULL 并将此 UNIQUE 索引用作聚簇索引</li>\n<li>无主键，没唯一，自动生成隐藏聚簇索引<code>GEN_CLUST_INDEX</code>,索引在包含行 <code>ID</code> 值的合成列上命名。</li>\n<li>除聚簇索引之外的所有索引都是非聚簇索引或二级索引</li>\n</ul>\n<h2 id=\"索引基数（Cardinality）\"><a href=\"#索引基数（Cardinality）\" class=\"headerlink\" title=\"索引基数（Cardinality）\"></a>索引基数（Cardinality）</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>索引基数是指存储在索引中指定列中的值的唯一性。</p>\n<p>MySQL 基于存储为整数的统计信息生成索引基数，因此，值可能不一定精确。</p>\n<p>查询优化器使用索引基数为给定查询生成最佳查询计划。它还使用索引基数来决定是否在连接操作中使用索引。</p>\n<p><strong>如果查询优化器选择具有低基数的索引，则它可能比不使用索引扫描行更有效。</strong> <em>Cardinality 越低越好</em></p>\n<img src=\"http://t-blog-images.aijs.top/img/202212021008601.webp\" />\n\n<p>索引统计信息仅是近似值，可能不代表表中行的实际大小。要生成更准确的统计信息，请使用 ANALYZE TABLE 命令。</p>\n<h2 id=\"USE-INDEX\"><a href=\"#USE-INDEX\" class=\"headerlink\" title=\"USE INDEX\"></a>USE INDEX</h2><p>指定索引，mysql 默认会自动选择索引使用，自己也可以指定自己认为的最优索引，当然也不一定就真的最优</p>\n<h3 id=\"作用-1\"><a href=\"#作用-1\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>为了确定最佳可能的计划，查询优化器使用了许多参数。选择使用哪个索引的最重要参数之一是存储密钥分发，也称为基数。</p>\n<p>但是，基数可能不准确，例如，如果表已经被许多插入或删除严重修改。</p>\n<p>要解决此问题，应 ANALYZE TABLE 定期运行语句以更新基数。</p>\n<p>此外，MySQL 提供了一种替代方法，允许您通过使用调用的索引提示来推荐查询优化器应使用的索引 USE INDEX。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 以下说明了MySQL USE INDEX提示的语法：\n\nSELECT select_list\nFROM table_name USE INDEX(index_list)\nWHERE condition;\n\n-- 在此语法中，USE INDEX指示查询优化器使用其中一个命名索引来查找表中的行。</code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>注意：当您建议使用索引时，查询优化器可能会决定是否使用它们，具体取决于它所提供的查询计划。</p>\n</p>\n</div>\n<p><a href=\"https://www.begtut.com/mysql/mysql-use-index.html\" target=\"_blank\" >USE INDEX</a></p>\n<h2 id=\"FORCE-INDEX\"><a href=\"#FORCE-INDEX\" class=\"headerlink\" title=\"FORCE INDEX\"></a>FORCE INDEX</h2><p>如果查询优化器忽略索引，您可以使用 FORCE INDEX 提示来指示它使用索引。</p>\n<h3 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>查询可能会请求价格在 10 到 80 之间的产品。如果统计数据显示 80％的产品具有这些价 ​​ 格范围，那么它可能会认为全表扫描效率最高。但是，如果统计数据显示很少有产品具有这些价 ​​ 格范围，那么读取索引后跟表访问可能比全表扫描更快，更有效</p>\n<p><strong>近似全表查询，mysql 会直接进行全表扫描</strong></p>\n<p>可能查询优化器忽略索引，不让其忽略，需要强制指定索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM table_name\nFORCE INDEX (index_list)\nWHERE condition;</code></pre>\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SHOW INDEXES FROM products;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202212021025077.webp\" />\n\n<p>要查找价格在 10 到 80 之间的产品，请使用以下语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">\nSELECT\n    productName,\n    buyPrice\nFROM\n    products\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;</code></pre>\n\n<p>您可以猜测，要返回产品，查询优化器必须扫描整个表，因为 buyPrice 列没有可用的索引：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">EXPLAIN SELECT\n    productName,\n    buyPrice\nFROM\n    products\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202212021026858.webp\" />\n\n<p>让我们为 buyPrice 列创建一个索引：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">\nCREATE INDEX idx_buyprice ON products(buyPrice);\n</code></pre>\n\n<p>然后再次执行查询：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">\nEXPLAIN SELECT\n    productName,\n    buyPrice\nFROM\n    products\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;</code></pre>\n\n<p>buyPrice 即使索引存在，查询优化也不使用列的索引。原因是查询返回 products 表中 110 行中的 94 行，因此，查询优化器决定执行全表扫描。<br>要强制查询优化器使用 idx_buyprice 索引，请使用以下查询：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT\n    productName, buyPrice\nFROM\n    products\nFORCE INDEX (idx_buyPrice)\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;</code></pre>\n\n<p>这次，索引用于查找产品，如下面的 EXPLAIN 语句所示：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">EXPLAIN SELECT\n    productName, buyPrice\nFROM\n    products\nFORCE INDEX (idx_buyprice)\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202212021028962.webp\" />\n\n<h2 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h2><ul>\n<li>like 语句中，复合索引可能失效</li>\n<li>where 语句中，查部分数据，索引失效（原因：mysql，查询优化器搞的鬼，自定执行全表扫描，需要使用 force index）</li>\n<li>查询优化器自动优化，不一定是最优的查询计划，如需指定需要使用 use index</li>\n</ul>\n","text":"索引的作用使用索引快速查找具有特定列值的行 创建 使用主键或唯一键创建表时，MySQL 会自动创建一个名为 PRIMARY 的特殊索引。索引称为聚簇索引 PRIMARY 索引是特殊的，因为索引本身与数据一起存储在同一个表中。 聚簇索引强制执行表中的行顺序。 -- 要为列或一组列添...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">索引的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">删除</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">打印</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">唯一索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">为什么存在</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">前缀索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">原因</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%89%8D\"><span class=\"toc-text\">优化前</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%90%8E\"><span class=\"toc-text\">优化后</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%84%E4%BC%B0%E4%BC%98%E5%8C%96-%E9%95%BF%E5%BA%A6%E5%A6%82%E4%BD%95%E5%AE%9A%EF%BC%8C%E8%AF%95%E5%87%BA%E6%9D%A5%E7%9A%84\"><span class=\"toc-text\">评估优化(长度如何定，试出来的)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BD%A2%E7%B4%A2%E5%BC%95%EF%BC%88%E5%B0%B1%E5%BD%93-disabled-%E5%90%A7%EF%BC%89\"><span class=\"toc-text\">隐形索引（就当 disabled 吧）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8-1\"><span class=\"toc-text\">为什么存在</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8D%E5%8F%AF%E9%9A%90%E8%97%8F\"><span class=\"toc-text\">主键索引不可隐藏</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">降序索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">复合索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">聚集索引</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%95%B0%EF%BC%88Cardinality%EF%BC%89\"><span class=\"toc-text\">索引基数（Cardinality）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#USE-INDEX\"><span class=\"toc-text\">USE INDEX</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8-1\"><span class=\"toc-text\">作用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FORCE-INDEX\"><span class=\"toc-text\">FORCE INDEX</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0-1\"><span class=\"toc-text\">原因</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">索引失效</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"8.系统学习 mysql 函数","uid":"b97ebb9e0de07448d25c52574eb10e17","slug":"2022-12-02mysql-函数","date":"2022-12-02T02:40:20.000Z","updated":"2022-12-02T13:57:33.687Z","comments":true,"path":"api/articles/2022-12-02mysql-函数.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","text":"MySQL 聚合函数聚合函数与组连用 默认情况是一组 GROUP BY 进行分组 +-------------+------------------+----------+ | productCode | productLine | buyPrice | +-----------...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"6.系统学习 mysql 集合","uid":"e534e8fd944f5586c5ed602b0ca27489","slug":"2022-11-30mysql-set","date":"2022-11-30T13:28:00.000Z","updated":"2022-11-30T13:38:44.192Z","comments":true,"path":"api/articles/2022-11-30mysql-set.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","text":"并集 UNIONMySQL UNION 运算符允许您将两个或多个查询结果集合并到一个结果集中要使用 UNION 运算符组合两个或多个查询的结果集，必须遵循以下基本规则： 首先，所有 SELECT 语句中出现的列的数量和顺序 必须相同。 其次，列的数据类型必须相同或可转换。 默认情...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}