{"title":"react-router v6.4.0 源码","uid":"72ce6d94dd6a62c447ee1fdb4516d01c","slug":"2022-06-21react-router-code","date":"2022-06-21T01:06:50.000Z","updated":"2022-09-16T15:00:58.103Z","comments":true,"path":"api/articles/2022-06-21react-router-code.json","keywords":null,"cover":[],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>整了半天上一篇看的竟然是概念，我还以为是原理呢</p>\n<p>最近看到了，面试题 react-router 原理，查了下答案，内容不是很多</p>\n<p><a href=\"https://blog.csdn.net/weixin_39907713/article/details/111237885\" target=\"_blank\" >React Router 原理</a><br><a href=\"https://blog.csdn.net/qingfeng2020/article/details/121136648\" target=\"_blank\" >浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理</a></p>\n<p><a href=\"https://blog.csdn.net/Android_boom/article/details/125200222\" target=\"_blank\" >React Router 源码解析</a></p>\n<p>之前没看过实现原理，现在看到也没那么难 <code>从小被吓大的</code>， 带着好奇心看下仓库代码：<code>4+1（index.ts）个文件</code>没看错</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220621091016.webp\" width=300 />\n\n<h2 id=\"index-ts\"><a href=\"#index-ts\" class=\"headerlink\" title=\"index.ts\"></a>index.ts</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 暴露出的api\nexport &#123;\n  MemoryRouter,\n  Navigate,\n  NavigationType,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  createPath,\n  createRoutesFromChildren,\n  generatePath,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  renderMatches,\n  resolvePath,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigate,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n&#125;;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; DANGER! PLEASE READ ME! 危险！请读这个！\n&#x2F;&#x2F; We provide these exports as an escape hatch in the event that you need any\n&#x2F;&#x2F; routing data that we don&#39;t provide an explicit API for. With that said, we\n&#x2F;&#x2F; want to cover your use case if we can, so if you feel the need to use these\n&#x2F;&#x2F; we want to hear from you. Let us know what you&#39;re building and we&#39;ll do our\n&#x2F;&#x2F; best to make sure we can support you!\n&#x2F;&#x2F; 我们提供这些导出作为一个逃逸引用，以防你需要我们没有提供明确 API 的任何路由数据。也就是说，\n&#x2F;&#x2F; 如果你需要这些，我们希望能够为你提供支持，所以如果你有需要，请告诉我们你的需求，我们会尽可能地为你提供支持。\n&#x2F;&#x2F; We consider these exports an implementation detail and do not guarantee\n&#x2F;&#x2F; against any breaking changes, regardless of the semver release. Use with\n&#x2F;&#x2F; extreme caution and only if you understand the consequences. Godspeed.\n&#x2F;&#x2F; 我们考虑这些导出是一个实现细节，并且不保证对任何变更不会有任何影响，无论是在 semver 版本发布前或者后。\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</code></pre>\n\n<h2 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h2><p>源码中使用了一个 <a href=\"https://github.com/remix-run/history\" target=\"_blank\" >history 库</a></p>\n<p>The history library lets you easily manage session history anywhere JavaScript runs. A history object abstracts away the differences in various environments and provides a minimal API that lets you manage the history stack, navigate, and persist state between sessions.<br><em>这个库让你在任何 JavaScript 运行的地方都能方便地管理会话历史记录。一个历史对象抽象了不同环境的差异，并提供了一个最小的 API，让你管理历史堆栈，导航，并在会话间保持状态。</em></p>\n<h2 id=\"react-router-dom\"><a href=\"#react-router-dom\" class=\"headerlink\" title=\"react-router-dom\"></a>react-router-dom</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对<code>react-router</code>进行了扩展，</p></blockquote>\n<p><code>react-router-dom</code>,在<code>react-router</code>的核心基础上，添加了用于跳转的<code>Link</code>组件，和<code>histoy</code>模式下的<code>BrowserRouter</code>和 hash 模式下的<code>HashRouter</code>组件等。所谓 B<code>rowserRouter</code>和<code>HashRouter</code>，也只不过用了<code>history</code>库中<code>createBrowserHistory</code>和<code>createHashHistory</code>方法</p>\n<h2 id=\"找个-demo-从头看\"><a href=\"#找个-demo-从头看\" class=\"headerlink\" title=\"找个 demo 从头看\"></a>找个 demo 从头看</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;\n\nimport &quot;.&#x2F;index.css&quot;;\nimport App from &quot;.&#x2F;App&quot;;\n\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &lt;BrowserRouter&gt; &#x2F;&#x2F; react-router-dom\n      &lt;App &#x2F;&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  &lt;&#x2F;React.StrictMode&gt;,\n  document.getElementById(&quot;root&quot;)</code></pre>\n\n<h2 id=\"BrowserRouter\"><a href=\"#BrowserRouter\" class=\"headerlink\" title=\"BrowserRouter\"></a>BrowserRouter</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">export function BrowserRouter(&#123;\n  basename,\n  children,\n  window,\n&#125;: BrowserRouterProps) &#123;\n  let historyRef &#x3D; React.useRef&lt;BrowserHistory&gt;();\n  if (historyRef.current &#x3D;&#x3D; null) &#123;\n    historyRef.current &#x3D; createBrowserHistory(&#123; window &#125;);\n  &#125;\n\n  let history &#x3D; historyRef.current;\n  let [state, setState] &#x3D; React.useState(&#123;\n    action: history.action,\n    location: history.location,\n  &#125;);\n  &#x2F;&#x2F; 监听url变化， 改变state，更新Router的location，location更新后会触发Router内部重新渲染\n  React.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);\n\n  return (\n    &lt;Router &#x2F;&#x2F; react-router &quot;.&#x2F;lib&#x2F;components&quot;\n      basename&#x3D;&#123;basename&#125;\n      children&#x3D;&#123;children&#125;\n      location&#x3D;&#123;state.location&#125;\n      navigationType&#x3D;&#123;state.action&#125;\n      navigator&#x3D;&#123;history&#125;\n    &#x2F;&gt;\n  );\n&#125;</code></pre>\n\n<p><strong>react-router “.&#x2F;lib&#x2F;components”</strong></p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Provides location context for the rest of the app.\n * 为应用程序的其余部分提供位置上下文。\n * Note: You usually won&#39;t render a &lt;Router&gt; directly. Instead, you&#39;ll render a\n * router that is more specific to your environment such as a &lt;BrowserRouter&gt;\n * in web browsers or a &lt;StaticRouter&gt; for server rendering.\n * 注意：通常不会直接渲染&lt;Router&gt;。相反，您将渲染\n * 更特定于您的环境的路由器，如&lt;BrowserRouter&gt;\n * 在web浏览器中或用于服务器渲染的&lt;StaticRouter&gt;。\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;routers&#x2F;router\n *&#x2F;\nexport function Router(&#123;\n  basename: basenameProp &#x3D; &quot;&#x2F;&quot;,\n  children &#x3D; null,\n  location: locationProp, &#x2F;&#x2F; Location\n  navigationType &#x3D; NavigationType.Pop,\n  navigator,\n  static: staticProp &#x3D; false,\n&#125;: RouterProps): React.ReactElement | null &#123;\n  invariant(\n    !useInRouterContext(),\n    &#96;You cannot render a &lt;Router&gt; inside another &lt;Router&gt;.&#96; +\n      &#96; You should never have more than one in your app.&#96;\n  );\n\n  let basename &#x3D; normalizePathname(basenameProp);\n  let navigationContext &#x3D; React.useMemo(\n    () &#x3D;&gt; (&#123; basename, navigator, static: staticProp &#125;),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    locationProp &#x3D; parsePath(locationProp);\n  &#125;\n\n  let &#123;\n    pathname &#x3D; &quot;&#x2F;&quot;,\n    search &#x3D; &quot;&quot;,\n    hash &#x3D; &quot;&quot;,\n    state &#x3D; null,\n    key &#x3D; &quot;default&quot;,\n  &#125; &#x3D; locationProp;\n\n  let location &#x3D; React.useMemo(() &#x3D;&gt; &#123;\n    let trailingPathname &#x3D; stripBasename(pathname, basename);\n\n    if (trailingPathname &#x3D;&#x3D; null) &#123;\n      return null;\n    &#125;\n\n    return &#123;\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    &#125;;\n  &#125;, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location !&#x3D; null,\n    &#96;&lt;Router basename&#x3D;&quot;$&#123;basename&#125;&quot;&gt; is not able to match the URL &#96; +\n      &#96;&quot;$&#123;pathname&#125;$&#123;search&#125;$&#123;hash&#125;&quot; because it does not start with the &#96; +\n      &#96;basename, so the &lt;Router&gt; won&#39;t render anything.&#96;\n  );\n\n  if (location &#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n\n  return (\n    &lt;NavigationContext.Provider value&#x3D;&#123;navigationContext&#125;&gt;\n      &#123;&quot; &quot;&#125;\n      &#x2F;&#x2F; React.createContext使用， 一般情况这里会单独抽取 NavigationContext， 并写成useNavigationContext\n      &lt;LocationContext.Provider &#x2F;&#x2F; 一般情况这里会单独抽取 LocationContext, 并写成useLocationContext\n        children&#x3D;&#123;children&#125; &#x2F;&#x2F; 是这种以属性形式写入的，不是在标签中包裹的， 即example&#x2F;basic &lt;App &#x2F;&gt;\n        value&#x3D;&#123;&#123; location, navigationType &#125;&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;NavigationContext.Provider&gt;\n  );\n&#125;</code></pre>\n\n<p><strong>NavigationContext</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * A Navigator is a &quot;location changer&quot;; it&#39;s how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level &lt;Router&gt; API\n * where both the location and a navigator must be provided separately in order\n * to avoid &quot;tearing&quot; that may occur in a suspense-enabled app if the action\n * and&#x2F;or location were to be read directly from the history instance.\n *&#x2F;\nexport type Navigator &#x3D; Pick&lt;History, &quot;go&quot; | &quot;push&quot; | &quot;replace&quot; | &quot;createHref&quot;&gt;;\n\ninterface NavigationContextObject &#123;\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n&#125;\n\nexport const NavigationContext &#x3D; React.createContext&lt;NavigationContextObject&gt;(\n  null!\n);</code></pre>\n\n<p><strong>LocationContext</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface LocationContextObject &#123;\n  location: Location;\n  navigationType: NavigationType;\n&#125;\n\nexport const LocationContext &#x3D; React.createContext&lt;LocationContextObject&gt;(\n  null!\n);</code></pre>\n\n<p><strong>App.tsx</strong></p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import * as React from &quot;react&quot;;\nimport &#123; Routes, Route, Outlet, Link &#125; from &quot;react-router-dom&quot;;\n\nexport default function App() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Basic Example&lt;&#x2F;h1&gt;\n\n      &lt;p&gt;\n        This example demonstrates some of the core features of React Router\n        including nested &lt;code&gt;&lt;Route&gt;&lt;&#x2F;code&gt;s,&#123;&quot; &quot;&#125;\n        &lt;code&gt;&lt;Outlet&gt;&lt;&#x2F;code&gt;s, &lt;code&gt;&lt;Link&gt;&lt;&#x2F;code&gt;s, and using a\n        &quot;*&quot; route (aka &quot;splat route&quot;) to render a &quot;not found&quot; page when someone\n        visits an unrecognized URL.\n      &lt;&#x2F;p&gt;\n\n      &#123;&#x2F;* Routes nest inside one another. Nested route paths build upon\n            parent route paths, and nested route elements render inside\n            parent route elements. See the note about &lt;Outlet&gt; below. *&#x2F;&#125;\n      &#123;&#x2F;* 管线相互嵌套。嵌套布线路径基于\n      线路径和嵌套管线元素在内部渲染\n      父管线元素。请参见下面关于&lt;Outlet&gt;的注释。*&#x2F;&#125;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n          &#123;&quot; &quot;&#125;\n          &#x2F;&#x2F; Route在createRoutesFromChildren中进行处理 element.type &#x3D;&#x3D;&#x3D; Route\n          &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;dashboard&quot; element&#x3D;&#123;&lt;Dashboard &#x2F;&gt;&#125; &#x2F;&gt;\n          &#123;&#x2F;* Using path&#x3D;&quot;*&quot;&quot; means &quot;match anything&quot;, so this route\n                acts like a catch-all for URLs that we don&#39;t have explicit\n                routes for. *&#x2F;&#125;\n          &#123;&#x2F;* 啥都没捞着，走匹配*&#x2F;&#125;\n          &lt;Route path&#x3D;&quot;*&quot; element&#x3D;&#123;&lt;NoMatch &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;&#x2F;Route&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Layout() &#123;\n  return (\n    &lt;div&gt;\n      &#123;&#x2F;* A &quot;layout route&quot; is a good place to put markup you want to\n          share across all the pages on your site, like navigation. *&#x2F;&#125;\n      &lt;nav&gt;\n        &lt;ul&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;dashboard&quot;&gt;Dashboard&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;nothing-here&quot;&gt;Nothing Here&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;nav&gt;\n\n      &lt;hr &#x2F;&gt;\n\n      &#123;&#x2F;* An &lt;Outlet&gt; renders whatever child route is currently active,\n          so you can think about this &lt;Outlet&gt; as a placeholder for\n          the child routes we defined above. *&#x2F;&#125;\n      &lt;Outlet &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Home() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Home&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction About() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;About&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Dashboard() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Dashboard&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction NoMatch() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Nothing to see here!&lt;&#x2F;h2&gt;\n      &lt;p&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Go to the home page&lt;&#x2F;Link&gt;\n      &lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<p><strong><code>import &#123; Routes, Route, Outlet, Link &#125; from &quot;react-router-dom&quot;;</code></strong></p>\n<h2 id=\"Routes\"><a href=\"#Routes\" class=\"headerlink\" title=\"Routes\"></a>Routes</h2><p>传入一个路由的数组，返回对应要展示的组件，有点类似于 vue 的路由的配置，可以在别的文件夹配置好路由，然后传入 APP.tsx 中</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * A container for a nested tree of &lt;Route&gt; elements that renders the branch\n * that best matches the current location.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;routes\n *&#x2F;\nexport function Routes(&#123;\n  children,\n  location,\n&#125;: RoutesProps): React.ReactElement | null &#123;\n  return useRoutes(createRoutesFromChildren(children), location);\n&#125;</code></pre>\n\n<h3 id=\"createRoutesFromChildren\"><a href=\"#createRoutesFromChildren\" class=\"headerlink\" title=\"createRoutesFromChildren\"></a>createRoutesFromChildren</h3><p>看大概意思，怎么实现不管</p>\n<p>大意是从 Children 中创建路由</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Creates a route config from a React &quot;children&quot; object, which is usually\n * either a &#96;&lt;Route&gt;&#96; element or an array of them. Used internally by\n * &#96;&lt;Routes&gt;&#96; to create a route config from its children.\n * 从React“children”对象创建路由配置，通常\n * 一个&#96;&lt;路由&gt;&#96;元素或它们的数组。内部使用人\n * &#96;&lt;路由&gt;&#96;从其子级创建路由配置。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;create-routes-from-children\n *&#x2F;\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] &#123;\n  let routes: RouteObject[] &#x3D; [];\n\n  React.Children.forEach(children, (element) &#x3D;&gt; &#123;\n    if (!React.isValidElement(element)) &#123;\n      &#x2F;&#x2F; Ignore non-elements. This allows people to more easily inline\n      &#x2F;&#x2F; conditionals in their route config.\n      return;\n    &#125;\n\n    if (element.type &#x3D;&#x3D;&#x3D; React.Fragment) &#123;\n      &#x2F;&#x2F; Transparently support React.Fragment and its children.\n      &#x2F;&#x2F; 递归\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    &#125;\n\n    invariant(\n      element.type &#x3D;&#x3D;&#x3D; Route,\n      &#96;[$&#123;\n        typeof element.type &#x3D;&#x3D;&#x3D; &quot;string&quot; ? element.type : element.type.name\n      &#125;] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;&#96;\n    );\n\n    let route: RouteObject &#x3D; &#123;\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n    &#125;;\n\n    if (element.props.children) &#123;\n      &#x2F;&#x2F; 递归\n      route.children &#x3D; createRoutesFromChildren(element.props.children);\n    &#125;\n\n    routes.push(route);\n  &#125;);\n\n  return routes;\n&#125;</code></pre>\n\n<h3 id=\"useRoutes\"><a href=\"#useRoutes\" class=\"headerlink\" title=\"useRoutes\"></a>useRoutes</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an &lt;Outlet&gt; to render their child route&#39;s\n * element.\n * 返回与当前位置匹配的路由元素，已准备就绪\n * 使用正确的上下文渲染路由树的其余部分。路线\n * 树中的元素必须渲染一个&lt;Outlet&gt;，才能渲染其子路由的\n * 元素。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-routes\n *&#x2F;\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial&lt;Location&gt; | string\n): React.ReactElement | null &#123;\n  &#x2F;&#x2F; invariant(\n  &#x2F;&#x2F;   useInRouterContext(),\n  &#x2F;&#x2F;   &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n  &#x2F;&#x2F;   &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n  &#x2F;&#x2F;   &#96;useRoutes() may be used only in the context of a &lt;Router&gt; component.&#96;\n  &#x2F;&#x2F; );\n\n  let &#123; matches: parentMatches &#125; &#x3D; React.useContext(RouteContext);\n  let routeMatch &#x3D; parentMatches[parentMatches.length - 1];\n  let parentParams &#x3D; routeMatch ? routeMatch.params : &#123;&#125;;\n  let parentPathname &#x3D; routeMatch ? routeMatch.pathname : &quot;&#x2F;&quot;;\n  let parentPathnameBase &#x3D; routeMatch ? routeMatch.pathnameBase : &quot;&#x2F;&quot;;\n  let parentRoute &#x3D; routeMatch &amp;&amp; routeMatch.route;\n\n  &#x2F;&#x2F; if (__DEV__) &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F; You won&#39;t get a warning about 2 different &lt;Routes&gt; under a &lt;Route&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F; without a trailing *, but this is a best-effort warning anyway since we\n  &#x2F;&#x2F;   &#x2F;&#x2F; cannot even give the warning unless they land at the parent route.\n  &#x2F;&#x2F;   &#x2F;&#x2F;\n  &#x2F;&#x2F;   &#x2F;&#x2F; Example:\n  &#x2F;&#x2F;   &#x2F;&#x2F;\n  &#x2F;&#x2F;   &#x2F;&#x2F; &lt;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   &#123;&#x2F;* This route path MUST end with &#x2F;* because otherwise\n  &#x2F;&#x2F;   &#x2F;&#x2F;       it will never match &#x2F;blog&#x2F;post&#x2F;123 *&#x2F;&#125;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   &lt;Route path&#x3D;&quot;blog&quot; element&#x3D;&#123;&lt;Blog &#x2F;&gt;&#125; &#x2F;&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   &lt;Route path&#x3D;&quot;blog&#x2F;feed&quot; element&#x3D;&#123;&lt;BlogFeed &#x2F;&gt;&#125; &#x2F;&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F; &lt;&#x2F;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;\n  &#x2F;&#x2F;   &#x2F;&#x2F; function Blog() &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   return (\n  &#x2F;&#x2F;   &#x2F;&#x2F;     &lt;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;       &lt;Route path&#x3D;&quot;post&#x2F;:id&quot; element&#x3D;&#123;&lt;Post &#x2F;&gt;&#125; &#x2F;&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;     &lt;&#x2F;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   );\n  &#x2F;&#x2F;   &#x2F;&#x2F; &#125;\n  &#x2F;&#x2F;   let parentPath &#x3D; (parentRoute &amp;&amp; parentRoute.path) || &quot;&quot;;\n  &#x2F;&#x2F;   warningOnce(\n  &#x2F;&#x2F;     parentPathname,\n  &#x2F;&#x2F;     !parentRoute || parentPath.endsWith(&quot;*&quot;),\n  &#x2F;&#x2F;     &#96;You rendered descendant &lt;Routes&gt; (or called \\&#96;useRoutes()\\&#96;) at &#96; +\n  &#x2F;&#x2F;       &#96;&quot;$&#123;parentPathname&#125;&quot; (under &lt;Route path&#x3D;&quot;$&#123;parentPath&#125;&quot;&gt;) but the &#96; +\n  &#x2F;&#x2F;       &#96;parent route path has no trailing &quot;*&quot;. This means if you navigate &#96; +\n  &#x2F;&#x2F;       &#96;deeper, the parent won&#39;t match anymore and therefore the child &#96; +\n  &#x2F;&#x2F;       &#96;routes will never render.\\n\\n&#96; +\n  &#x2F;&#x2F;       &#96;Please change the parent &lt;Route path&#x3D;&quot;$&#123;parentPath&#125;&quot;&gt; to &lt;Route &#96; +\n  &#x2F;&#x2F;       &#96;path&#x3D;&quot;$&#123;parentPath &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ? &quot;*&quot; : &#96;$&#123;parentPath&#125;&#x2F;*&#96;&#125;&quot;&gt;.&#96;\n  &#x2F;&#x2F;   );\n  &#x2F;&#x2F; &#125;\n\n  let locationFromContext &#x3D; useLocation();\n\n  let location;\n  if (locationArg) &#123;\n    let parsedLocationArg &#x3D;\n      typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;\n\n    &#x2F;&#x2F; invariant(\n    &#x2F;&#x2F;   parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ||\n    &#x2F;&#x2F;     parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n    &#x2F;&#x2F;   &#96;When overriding the location using \\&#96;&lt;Routes location&gt;\\&#96; or \\&#96;useRoutes(routes, location)\\&#96;, &#96; +\n    &#x2F;&#x2F;     &#96;the location pathname must begin with the portion of the URL pathname that was &#96; +\n    &#x2F;&#x2F;     &#96;matched by all parent routes. The current pathname base is &quot;$&#123;parentPathnameBase&#125;&quot; &#96; +\n    &#x2F;&#x2F;     &#96;but pathname &quot;$&#123;parsedLocationArg.pathname&#125;&quot; was given in the \\&#96;location\\&#96; prop.&#96;\n    &#x2F;&#x2F; );\n\n    location &#x3D; parsedLocationArg;\n  &#125; else &#123;\n    location &#x3D; locationFromContext;\n  &#125;\n\n  let pathname &#x3D; location.pathname || &quot;&#x2F;&quot;;\n  let remainingPathname &#x3D;\n    parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || &quot;&#x2F;&quot;;\n  let matches &#x3D; matchRoutes(routes, &#123; pathname: remainingPathname &#125;);\n\n  &#x2F;&#x2F; if (__DEV__) &#123;\n  &#x2F;&#x2F;   warning(\n  &#x2F;&#x2F;     parentRoute || matches !&#x3D; null,\n  &#x2F;&#x2F;     &#96;No routes matched location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; &#96;\n  &#x2F;&#x2F;   );\n\n  &#x2F;&#x2F;   warning(\n  &#x2F;&#x2F;     matches &#x3D;&#x3D; null ||\n  &#x2F;&#x2F;       matches[matches.length - 1].route.element !&#x3D;&#x3D; undefined,\n  &#x2F;&#x2F;     &#96;Matched leaf route at location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; does not have an element. &#96; +\n  &#x2F;&#x2F;       &#96;This means it will render an &lt;Outlet &#x2F;&gt; with a null value by default resulting in an &quot;empty&quot; page.&#96;\n  &#x2F;&#x2F;   );\n  &#x2F;&#x2F; &#125;\n\n  return _renderMatches(\n    matches &amp;&amp;\n      matches.map((match) &#x3D;&gt;\n        Object.assign(&#123;&#125;, match, &#123;\n          params: Object.assign(&#123;&#125;, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        &#125;)\n      ),\n    parentMatches\n  );\n&#125;</code></pre>\n\n<h3 id=\"matchRoutes\"><a href=\"#matchRoutes\" class=\"headerlink\" title=\"matchRoutes\"></a>matchRoutes</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Matches the given routes to a location and returns the match data.\n * 将给定路由匹配到某个位置并返回匹配数据。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;match-routes\n *&#x2F;\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial&lt;Location&gt; | string,\n  basename &#x3D; &quot;&#x2F;&quot;\n): RouteMatch[] | null &#123;\n  let location &#x3D;\n    typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;\n\n  let pathname &#x3D; stripBasename(location.pathname || &quot;&#x2F;&quot;, basename);\n\n  if (pathname &#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n\n  let branches &#x3D; flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches &#x3D; null;\n  for (let i &#x3D; 0; matches &#x3D;&#x3D; null &amp;&amp; i &lt; branches.length; ++i) &#123;\n    matches &#x3D; matchRouteBranch(branches[i], pathname);\n  &#125;\n\n  return matches;\n&#125;</code></pre>\n\n<h3 id=\"renderMatches\"><a href=\"#renderMatches\" class=\"headerlink\" title=\"_renderMatches\"></a>_renderMatches</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] &#x3D; []\n): React.ReactElement | null &#123;\n  if (matches &#x3D;&#x3D; null) return null;\n\n  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;\n    return (\n      &lt;RouteContext.Provider\n        children&#x3D;&#123;\n          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet\n        &#125;\n        value&#x3D;&#123;&#123;\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        &#125;&#125;\n      &#x2F;&gt;\n    );\n  &#125;, null as React.ReactElement | null);\n&#125;</code></pre>\n\n<h3 id=\"RouteContext\"><a href=\"#RouteContext\" class=\"headerlink\" title=\"RouteContext\"></a>RouteContext</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface RouteContextObject &#123;\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n&#125;\n\nexport const RouteContext &#x3D; React.createContext&lt;RouteContextObject&gt;(&#123;\n  outlet: null,\n  matches: [],\n&#125;);\n\nif (__DEV__) &#123;\n  RouteContext.displayName &#x3D; &quot;Route&quot;;\n&#125;</code></pre>\n\n<h2 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">export interface LinkProps\n  extends Omit&lt;React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt;, &quot;href&quot;&gt; &#123;\n  &#x2F;&#x2F; 剔除 href 属性，代码中内部使用useHref(to)生成\n  reloadDocument?: boolean;\n  replace?: boolean;\n  state?: any;\n  to: To;\n&#125;\n\n&#x2F;**\n * The public API for rendering a history-aware &lt;a&gt;.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;link\n *&#x2F;\nexport const Link &#x3D; React.forwardRef&lt;HTMLAnchorElement, LinkProps&gt;(\n  function LinkWithRef(\n    &#123; onClick, reloadDocument, replace &#x3D; false, state, target, to, ...rest &#125;,\n    ref\n  ) &#123;\n    let href &#x3D; useHref(to);\n    let internalOnClick &#x3D; useLinkClickHandler(to, &#123; replace, state, target &#125;);\n    function handleClick(\n      event: React.MouseEvent&lt;HTMLAnchorElement, MouseEvent&gt;\n    ) &#123;\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented &amp;&amp; !reloadDocument) &#123;\n        internalOnClick(event);\n      &#125;\n    &#125;\n\n    return (\n      &#x2F;&#x2F; eslint-disable-next-line jsx-a11y&#x2F;anchor-has-content\n      &lt;a\n        &#123;...rest&#125;\n        href&#x3D;&#123;href&#125;\n        onClick&#x3D;&#123;handleClick&#125;\n        ref&#x3D;&#123;ref&#125;\n        target&#x3D;&#123;target&#125;\n      &#x2F;&gt;\n    );\n  &#125;\n);</code></pre>\n\n<h3 id=\"useHref\"><a href=\"#useHref\" class=\"headerlink\" title=\"useHref\"></a>useHref</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Returns the full href for the given &quot;to&quot; value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n * 返回给定“to”值的完整href。这对于构建也可访问并保留右键单击行为的自定义链接非常有用。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-href\n *&#x2F;\nexport function useHref(to: To): string &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useHref() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; hash, pathname, search &#125; &#x3D; useResolvedPath(to);\n\n  let joinedPathname &#x3D; pathname;\n  if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n    let toPathname &#x3D; getToPathname(to);\n    let endsWithSlash &#x3D; toPathname !&#x3D; null &amp;&amp; toPathname.endsWith(&quot;&#x2F;&quot;);\n    joinedPathname &#x3D;\n      pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n        ? basename + (endsWithSlash ? &quot;&#x2F;&quot; : &quot;&quot;)\n        : joinPaths([basename, pathname]);\n  &#125;\n\n  return navigator.createHref(&#123; pathname: joinedPathname, search, hash &#125;);\n&#125;</code></pre>\n\n<h3 id=\"useLinkClickHandler\"><a href=\"#useLinkClickHandler\" class=\"headerlink\" title=\"useLinkClickHandler\"></a>useLinkClickHandler</h3><p><a href=\"https://blog.csdn.net/m0_52537576/article/details/124901230#:~:text=5-,useLinkClickHandler,-%E8%BF%99%E4%B8%AAhooks%E8%BF%94%E5%9B%9E\" target=\"_blank\" >useLinkClickHandler</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Handles the click behavior for router &#96;&lt;Link&gt;&#96; components. This is useful if\n * you need to create custom &#96;&lt;Link&gt;&#96; components with the same click behavior we\n * use in our exported &#96;&lt;Link&gt;&#96;.\n * 处理&#96;&lt;Link&gt;&#96;组件的单击行为。如果\n * 您需要创建具有与我们相同的单击行为的自定义&#96;&lt;Link&gt;&#96;组件\n * 在导出的&#96;&lt;Link&gt;&#96;中使用。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-link-click-handler\n *&#x2F;\nexport function useLinkClickHandler&lt;E extends Element &#x3D; HTMLAnchorElement&gt;(\n  to: To,\n  &#123;\n    target,\n    replace: replaceProp,\n    state,\n  &#125;: &#123;\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n  &#125; &#x3D; &#123;&#125;\n): (event: React.MouseEvent&lt;E, MouseEvent&gt;) &#x3D;&gt; void &#123;\n  let navigate &#x3D; useNavigate();\n  let location &#x3D; useLocation();\n  let path &#x3D; useResolvedPath(to);\n\n  return React.useCallback(\n    (event: React.MouseEvent&lt;E, MouseEvent&gt;) &#x3D;&gt; &#123;\n      if (\n        event.button &#x3D;&#x3D;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; Ignore everything but left clicks\n        (!target || target &#x3D;&#x3D;&#x3D; &quot;_self&quot;) &amp;&amp; &#x2F;&#x2F; Let browser handle &quot;target&#x3D;_blank&quot; etc.\n        !isModifiedEvent(event) &#x2F;&#x2F; Ignore clicks with modifier keys\n      ) &#123;\n        event.preventDefault();\n\n        &#x2F;&#x2F; If the URL hasn&#39;t changed, a regular &lt;a&gt; will do a replace instead of\n        &#x2F;&#x2F; a push, so do the same here.\n        &#x2F;&#x2F; url没有改变，做replace操作，而不是push操作\n        let replace &#x3D;\n          !!replaceProp || createPath(location) &#x3D;&#x3D;&#x3D; createPath(path);\n\n        navigate(to, &#123; replace, state &#125;);\n      &#125;\n    &#125;,\n    [location, navigate, path, replaceProp, state, target, to]\n  );\n&#125;</code></pre>\n\n<h3 id=\"useNavigate\"><a href=\"#useNavigate\" class=\"headerlink\" title=\"useNavigate\"></a>useNavigate</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but\n * may also be used by other elements to change the location.\n * 返回更改位置的命令式方法。由s使用，但\n * 也可由其他元素用于更改位置。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate\n *&#x2F;\nexport function useNavigate(): NavigateFunction &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  let activeRef &#x3D; React.useRef(false);\n  React.useEffect(() &#x3D;&gt; &#123;\n    activeRef.current &#x3D; true;\n  &#125;);\n\n  let navigate: NavigateFunction &#x3D; React.useCallback(\n    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n      warning(\n        activeRef.current,\n        &#96;You should call navigate() in a React.useEffect(), not when &#96; +\n          &#96;your component is first rendered.&#96;\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n        navigator.go(to);\n        return;\n      &#125;\n\n      let path &#x3D; resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        path.pathname &#x3D; joinPaths([basename, path.pathname]);\n      &#125;\n      &#x2F;&#x2F; 这行代码写法，没见过，函数执行\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    &#125;,\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n&#125;</code></pre>\n\n<h3 id=\"resolveTo\"><a href=\"#resolveTo\" class=\"headerlink\" title=\"resolveTo\"></a>resolveTo</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path &#123;\n  let to &#x3D; typeof toArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(toArg) : toArg;\n  let toPathname &#x3D; toArg &#x3D;&#x3D;&#x3D; &quot;&quot; || to.pathname &#x3D;&#x3D;&#x3D; &quot;&quot; ? &quot;&#x2F;&quot; : to.pathname;\n\n  &#x2F;&#x2F; If a pathname is explicitly provided in &#96;to&#96;, it should be relative to the\n  &#x2F;&#x2F; route context. This is explained in &#96;Note on &#96;&lt;Link to&gt;&#96; values&#96; in our\n  &#x2F;&#x2F; migration guide from v5 as a means of disambiguation between &#96;to&#96; values\n  &#x2F;&#x2F; that begin with &#96;&#x2F;&#96; and those that do not. However, this is problematic for\n  &#x2F;&#x2F; &#96;to&#96; values that do not provide a pathname. &#96;to&#96; can simply be a search or\n  &#x2F;&#x2F; hash string, in which case we should assume that the navigation is relative\n  &#x2F;&#x2F; to the current location&#39;s pathname and *not* the route pathname.\n  &#x2F;&#x2F; 如果在“to”中显式提供了路径名，则它应该相对于路由上下文。这在我们的v5迁移指南中的“关于&#96;&lt;Link&gt;&#96;值&#39;的注释”中有解释，\n  &#x2F;&#x2F; 作为消除以&#96;&#x2F;&#96;开头的&#96;到&#96;值与不以&#96;&#x2F;&#96;开头的&#96;到&#96;值之间歧义的一种方法。但是，对于不提供路径名的“to”值来说，\n  &#x2F;&#x2F; 这是有问题的&#96;to &#96;可以是一个搜索或哈希字符串，在这种情况下，我们应该假设导航相对于当前位置的路径名，而不是路径名。\n\n  let from: string;\n  if (toPathname &#x3D;&#x3D; null) &#123;\n    from &#x3D; locationPathname;\n  &#125; else &#123;\n    let routePathnameIndex &#x3D; routePathnames.length - 1;\n\n    if (toPathname.startsWith(&quot;..&quot;)) &#123;\n      let toSegments &#x3D; toPathname.split(&quot;&#x2F;&quot;);\n\n      &#x2F;&#x2F; Each leading .. segment means &quot;go up one route&quot; instead of &quot;go up one\n      &#x2F;&#x2F; URL segment&quot;.  This is a key difference from how &lt;a href&gt; works and a\n      &#x2F;&#x2F; major reason we call this a &quot;to&quot; value instead of a &quot;href&quot;.\n      while (toSegments[0] &#x3D;&#x3D;&#x3D; &quot;..&quot;) &#123;\n        toSegments.shift();\n        routePathnameIndex -&#x3D; 1;\n      &#125;\n\n      to.pathname &#x3D; toSegments.join(&quot;&#x2F;&quot;);\n    &#125;\n\n    &#x2F;&#x2F; If there are more &quot;..&quot; segments than parent routes, resolve relative to\n    &#x2F;&#x2F; the root &#x2F; URL.\n    from &#x3D; routePathnameIndex &gt;&#x3D; 0 ? routePathnames[routePathnameIndex] : &quot;&#x2F;&quot;;\n  &#125;\n\n  let path &#x3D; resolvePath(to, from);\n\n  &#x2F;&#x2F; Ensure the pathname has a trailing slash if the original to value had one.\n  &#x2F;&#x2F; 如果原始to值有斜杠，请确保路径名后面有斜杠。\n  if (\n    toPathname &amp;&amp;\n    toPathname !&#x3D;&#x3D; &quot;&#x2F;&quot; &amp;&amp;\n    toPathname.endsWith(&quot;&#x2F;&quot;) &amp;&amp;\n    !path.pathname.endsWith(&quot;&#x2F;&quot;)\n  ) &#123;\n    path.pathname +&#x3D; &quot;&#x2F;&quot;;\n  &#125;\n\n  return path;\n&#125;</code></pre>\n\n<h3 id=\"useInRouterContext\"><a href=\"#useInRouterContext\" class=\"headerlink\" title=\"useInRouterContext\"></a>useInRouterContext</h3><p>判断是否在某个 React.createContext 的上下文</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export function useInRouterContext(): boolean &#123;\n  return React.useContext(LocationContext) !&#x3D; null;\n&#125;\n\n&#x2F;&#x2F; invariant(\n&#x2F;&#x2F;   useInRouterContext(),\n&#x2F;&#x2F;   &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n&#x2F;&#x2F;   &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n&#x2F;&#x2F;   &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n&#x2F;&#x2F; );</code></pre>\n\n<hr />\n\n<p>以上部分，是如何生成路由的源码部分。有个问题，路由生成出来了，如何进行配对渲染？走的太快了，回去看下</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;&#x2F; 这块代码我们上面有看过的\n\n&#x2F;&#x2F; BrowserRouter\nReact.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);\n&#x2F;&#x2F;  history.listen(setState) 去找下history的api\n&#x2F;&#x2F; @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;blob&#x2F;dev&#x2F;docs&#x2F;api-reference.md#historylistenlistener-listener\nreturn (\n  &lt;Router &#x2F;&#x2F; react-router &quot;.&#x2F;lib&#x2F;components&quot;\n    basename&#x3D;&#123;basename&#125;\n    children&#x3D;&#123;children&#125;\n    location&#x3D;&#123;state.location&#125;\n    navigationType&#x3D;&#123;state.action&#125;\n    navigator&#x3D;&#123;history&#125;\n  &#x2F;&gt;\n);\n\n&#x2F;&#x2F; 直接在这里堆积下，上文是有的\n\nlet &#123;\n  pathname &#x3D; &quot;&#x2F;&quot;,\n  search &#x3D; &quot;&quot;,\n  hash &#x3D; &quot;&quot;,\n  state &#x3D; null,\n  key &#x3D; &quot;default&quot;,\n&#125; &#x3D; locationProp;\n\n&lt;LocationContext.Provider &#x2F;&#x2F; 一般情况这里会单独抽取 LocationContext, 并写成useLocationContext\n  children&#x3D;&#123;children&#125; &#x2F;&#x2F; 是这种以属性形式写入的，不是在标签中包裹的， 即example&#x2F;basic &lt;App &#x2F;&gt;\n  value&#x3D;&#123;&#123; location, navigationType &#125;&#125;\n&#x2F;&gt;;</code></pre>\n\n<p>文档内容</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Listener &#123;\n  (update: Update): void;\n&#125;\n\ninterface Update &#123;\n  action: Action;\n  location: Location; &#x2F;&#x2F; 由 Location,结合Router\n&#125;</code></pre>\n\n<h2 id=\"Location-类型\"><a href=\"#Location-类型\" class=\"headerlink\" title=\"Location 类型\"></a>Location 类型</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * A URL pathname, beginning with a &#x2F;.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n *&#x2F;\nexport type Pathname &#x3D; string;\n\n&#x2F;**\n * A URL search string, beginning with a ?.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n *&#x2F;\nexport type Search &#x3D; string;\n\n&#x2F;**\n * The pathname, search, and hash values of a URL.\n *&#x2F;\nexport interface Path &#123;\n  &#x2F;**\n   * A URL pathname, beginning with a &#x2F;.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n   *&#x2F;\n  pathname: Pathname;\n\n  &#x2F;**\n   * A URL search string, beginning with a ?.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n   *&#x2F;\n  search: Search;\n\n  &#x2F;**\n   * A URL fragment identifier, beginning with a #.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash\n   *&#x2F;\n  hash: Hash;\n&#125;\n\n&#x2F;**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location\n *&#x2F;\nexport interface Location extends Path &#123;\n  &#x2F;**\n   * A value of arbitrary data associated with this location.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.state\n   *&#x2F;\n  state: unknown;\n\n  &#x2F;**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like &#96;localStorage&#96;.\n   *\n   * Note: This value is always &quot;default&quot; on the initial location.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.key\n   *&#x2F;\n  key: Key;\n&#125;</code></pre>\n\n<h2 id=\"history-x2F-index-ts-源码\"><a href=\"#history-x2F-index-ts-源码\" class=\"headerlink\" title=\"history&#x2F;index.ts 源码\"></a>history&#x2F;index.ts 源码</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * A function that receives notifications about location changes.\n *&#x2F;\nexport interface Listener &#123;\n  (update: Update): void;\n&#125;</code></pre>\n\n<p>Starts listening for location changes and calls the given callback with an Update when it does.<br>开始侦听位置更改，并在更改时使用更新调用给定回调。</p>\n<h2 id=\"阶段性总结\"><a href=\"#阶段性总结\" class=\"headerlink\" title=\"阶段性总结\"></a>阶段性总结</h2><p>BrowserRouter + App.tsx（Routes、Route 生成路由组件关系）</p>\n<p>BrowserRouter：内部 history 监听路由变化，将 location 进行结构，并使用 useMemo 进行环境，传递给 LocationContext.Provider 的 value，驱动子组件 children 渲染，<strong>代码 1</strong></p>\n<p>LocationContext.Provider 子组件 &#x3D; 也就是 BrowserRouter 的子组件 &#x3D; App.tsx， 内部，获取 locationFromContext，进行匹配渲染 <strong>代码 2</strong>（见下述堆积代码<code>「上文以贴过源码，再贴一遍」</code>）</p>\n<p>这里要注意下：useRoutes TOC 写法，最终应该是</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码 2\"></a>代码 2</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you&#39;re using this it may mean you&#39;re doing some of your own\n * &quot;routing&quot; in your app, and we&#39;d like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-location\n *&#x2F;\nexport function useLocation(): Location &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useLocation() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  return React.useContext(LocationContext).location;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;&#x2F; hooks.ts useRoutes中\n\nlet locationFromContext &#x3D; useLocation(); &#x2F;&#x2F; 这里\n\nlet location;\nif (locationArg) &#123;\n  let parsedLocationArg &#x3D;\n    typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;\n\n  invariant(\n    parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ||\n      parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n    &#96;When overriding the location using \\&#96;&lt;Routes location&gt;\\&#96; or \\&#96;useRoutes(routes, location)\\&#96;, &#96; +\n      &#96;the location pathname must begin with the portion of the URL pathname that was &#96; +\n      &#96;matched by all parent routes. The current pathname base is &quot;$&#123;parentPathnameBase&#125;&quot; &#96; +\n      &#96;but pathname &quot;$&#123;parsedLocationArg.pathname&#125;&quot; was given in the \\&#96;location\\&#96; prop.&#96;\n  );\n\n  location &#x3D; parsedLocationArg;\n&#125; else &#123;\n  location &#x3D; locationFromContext; &#x2F;&#x2F; 这里\n&#125;\n\nlet pathname &#x3D; location.pathname || &quot;&#x2F;&quot;;\nlet remainingPathname &#x3D;\n  parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n    ? pathname\n    : pathname.slice(parentPathnameBase.length) || &quot;&#x2F;&quot;;\nlet matches &#x3D; matchRoutes(routes, &#123; pathname: remainingPathname &#125;);\n&#x2F;&#x2F; 开发提醒 跳过\n&#x2F;&#x2F; if (__DEV__) &#123;\n&#x2F;&#x2F;   warning(\n&#x2F;&#x2F;     parentRoute || matches !&#x3D; null,\n&#x2F;&#x2F;     &#96;No routes matched location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; &#96;\n&#x2F;&#x2F;   );\n\n&#x2F;&#x2F;   warning(\n&#x2F;&#x2F;     matches &#x3D;&#x3D; null || matches[matches.length - 1].route.element !&#x3D;&#x3D; undefined,\n&#x2F;&#x2F;     &#96;Matched leaf route at location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; does not have an element. &#96; +\n&#x2F;&#x2F;       &#96;This means it will render an &lt;Outlet &#x2F;&gt; with a null value by default resulting in an &quot;empty&quot; page.&#96;\n&#x2F;&#x2F;   );\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; 渲染\nreturn _renderMatches(\n  matches &amp;&amp;\n    matches.map((match) &#x3D;&gt;\n      Object.assign(&#123;&#125;, match, &#123;\n        params: Object.assign(&#123;&#125;, parentParams, match.params),\n        pathname: joinPaths([parentPathnameBase, match.pathname]),\n        pathnameBase:\n          match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n            ? parentPathnameBase\n            : joinPaths([parentPathnameBase, match.pathnameBase]),\n      &#125;)\n    ),\n  parentMatches\n);\n\n&#x2F;&#x2F; _renderMatches\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] &#x3D; []\n): React.ReactElement | null &#123;\n  if (matches &#x3D;&#x3D; null) return null;\n  &#x2F;&#x2F; 这是一个递归 reduceRight，与reduce类似，不过reduceRight是从右到左\n  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;\n    return (\n      &lt;RouteContext.Provider &#x2F;&#x2F; 需要看下 RouteContext在什么地方使用的，为什要看它，因为这个Context距离渲染组件的chilren最近，看他是如何驱动组件更新的【element、outlet】\n        children&#x3D;&#123;\n          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet\n        &#125;\n        value&#x3D;&#123;&#123;\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        &#125;&#125;\n      &#x2F;&gt;\n    );\n  &#125;, null as React.ReactElement | null);\n&#125;</code></pre>\n\n<h2 id=\"RouteContext-在源码中的使用\"><a href=\"#RouteContext-在源码中的使用\" class=\"headerlink\" title=\"RouteContext 在源码中的使用\"></a>RouteContext 在源码中的使用</h2><ul>\n<li>useNavigate</li>\n<li>useOutlet</li>\n<li>useParams</li>\n<li>useResolvedPath</li>\n<li>useRoutes</li>\n</ul>\n<h3 id=\"useNavigate-1\"><a href=\"#useNavigate-1\" class=\"headerlink\" title=\"useNavigate\"></a>useNavigate</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but\n * may also be used by other elements to change the location.\n * 返回更改位置的命令式方法。由&lt;Link&gt;s使用，但也可由其他元素用于更改位置。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate\n *&#x2F;\nexport function useNavigate(): NavigateFunction &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  let activeRef &#x3D; React.useRef(false);\n  React.useEffect(() &#x3D;&gt; &#123;\n    activeRef.current &#x3D; true;\n  &#125;);\n\n  let navigate: NavigateFunction &#x3D; React.useCallback(\n    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n      warning(\n        activeRef.current,\n        &#96;You should call navigate() in a React.useEffect(), not when &#96; +\n          &#96;your component is first rendered.&#96;\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n        navigator.go(to);\n        return;\n      &#125;\n\n      let path &#x3D; resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        path.pathname &#x3D; joinPaths([basename, path.pathname]);\n      &#125;\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    &#125;,\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n&#125;\n\n&#x2F;**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by &lt;Outlet&gt; to render child routes.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-outlet\n *&#x2F;\nexport function useOutlet(context?: unknown): React.ReactElement | null &#123;\n  let outlet &#x3D; React.useContext(RouteContext).outlet; &#x2F;&#x2F; 这里\n  if (outlet) &#123;\n    return (\n      &lt;OutletContext.Provider value&#x3D;&#123;context&#125;&gt;&#123;outlet&#125;&lt;&#x2F;OutletContext.Provider&gt;\n    );\n  &#125;\n  return outlet;\n&#125;\n\nexport function useParams&lt;\n  ParamsOrKey extends string | Record&lt;string, string | undefined&gt; &#x3D; string\n&gt;(): Readonly&lt;\n  [ParamsOrKey] extends [string] ? Params&lt;ParamsOrKey&gt; : Partial&lt;ParamsOrKey&gt;\n&gt; &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);&#x2F;&#x2F; 这里\n  let routeMatch &#x3D; matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : &#123;&#125;;\n&#125;\n\n&#x2F;**\n * Resolves the pathname of the given &#96;to&#96; value against the current location.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;api#useresolvedpath\n *&#x2F;\nexport function useResolvedPath(to: To): Path &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () &#x3D;&gt; resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n&#125;\n\n&#x2F;**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an &lt;Outlet&gt; to render their child route&#39;s\n * element.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-routes\n *&#x2F;\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial&lt;Location&gt; | string\n): React.ReactElement | null &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useRoutes() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; matches: parentMatches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里\n  let routeMatch &#x3D; parentMatches[parentMatches.length - 1];\n  let parentParams &#x3D; routeMatch ? routeMatch.params : &#123;&#125;;\n  let parentPathname &#x3D; routeMatch ? routeMatch.pathname : &quot;&#x2F;&quot;;\n  let parentPathnameBase &#x3D; routeMatch ? routeMatch.pathnameBase : &quot;&#x2F;&quot;;\n  let parentRoute &#x3D; routeMatch &amp;&amp; routeMatch.route;\n</code></pre>\n\n<p>最终发现，又回到 useRoutes，也确实是在尾部调用 TOC,如下抽取部分代码片段</p>\n<h2 id=\"代码-2-1\"><a href=\"#代码-2-1\" class=\"headerlink\" title=\"代码 2\"></a>代码 2</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;&#x2F; 1 useRoutes尾部调用\nlet locationFromContext &#x3D; useLocation(); &#x2F;&#x2F; 这里\nreturn _renderMatches(\n  matches &amp;&amp;\n    matches.map((match) &#x3D;&gt;\n      Object.assign(&#123;&#125;, match, &#123;\n        params: Object.assign(&#123;&#125;, parentParams, match.params),\n        pathname: joinPaths([parentPathnameBase, match.pathname]),\n        pathnameBase:\n          match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n            ? parentPathnameBase\n            : joinPaths([parentPathnameBase, match.pathnameBase]),\n      &#125;)\n    ),\n  parentMatches\n);\n\n&#x2F;&#x2F; 2\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] &#x3D; []\n): React.ReactElement | null &#123;\n  if (matches &#x3D;&#x3D; null) return null;\n  &#x2F;&#x2F; 这是一个递归 reduceRight，与reduce类似，不过reduceRight是从右到左\n  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;\n    return (\n      &lt;RouteContext.Provider &#x2F;&#x2F; 需要看下 RouteContext在什么地方使用的，为什要看它，因为这个Context距离渲染组件的chilren最近，看他是如何驱动组件更新的【element、outlet】\n        children&#x3D;&#123;\n          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet &#x2F;&#x2F; 这里的return相当于将 上述1的代码全部塞在RouteContext.Provider中  注意：因为react.context只能在对应的provider中使用\n          &#x2F;&#x2F; 这里拿了 Route的element的属性（组件渲染）据说，Route的形式有好多种，下面看看去\n        &#125;\n        value&#x3D;&#123;&#123;\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        &#125;&#125;\n      &#x2F;&gt;\n    );\n  &#125;, null as React.ReactElement | null);\n&#125;</code></pre>\n\n<h2 id=\"Route\"><a href=\"#Route\" class=\"headerlink\" title=\"Route\"></a>Route</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Declares an element that should be rendered at a certain URL path.\n * 声明在某个URL路径渲染的元素\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;route\n *&#x2F;\nexport function Route( &#x2F;&#x2F; 这个看上去就一个函数声明，啥都没有\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null &#123;\n  invariant(\n    false,\n    &#96;A &lt;Route&gt; is only ever to be used as the child of &lt;Routes&gt; element, &#96; +\n      &#96;never rendered directly. Please wrap your &lt;Route&gt; in a &lt;Routes&gt;.&#96;\n  );\n&#125;</code></pre>\n\n<h2 id=\"createRoutesFromChildren-1\"><a href=\"#createRoutesFromChildren-1\" class=\"headerlink\" title=\"createRoutesFromChildren\"></a>createRoutesFromChildren</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Creates a route config from a React &quot;children&quot; object, which is usually\n * either a &#96;&lt;Route&gt;&#96; element or an array of them. Used internally by\n * &#96;&lt;Routes&gt;&#96; to create a route config from its children.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;create-routes-from-children\n *&#x2F;\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] &#123;\n  let routes: RouteObject[] &#x3D; [];\n\n  React.Children.forEach(children, (element) &#x3D;&gt; &#123;\n    if (!React.isValidElement(element)) &#123;\n      &#x2F;&#x2F; 不是react组件返回undefined,结束\n      &#x2F;&#x2F; Ignore non-elements. This allows people to more easily inline\n      &#x2F;&#x2F; conditionals in their route config.\n      return;\n    &#125;\n\n    if (element.type &#x3D;&#x3D;&#x3D; React.Fragment) &#123;\n      &#x2F;&#x2F; React.Fragment\n      &#x2F;&#x2F; Transparently support React.Fragment and its children.\n      &#x2F;&#x2F; 支持React.Fragment及其子级。\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    &#125;\n\n    invariant(\n      element.type &#x3D;&#x3D;&#x3D; Route,\n      &#96;[$&#123;\n        typeof element.type &#x3D;&#x3D;&#x3D; &quot;string&quot; ? element.type : element.type.name\n      &#125;] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;&#96;\n    );\n\n    let route: RouteObject &#x3D; &#123;\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element, &#x2F;&#x2F; 这里直接把组件给了route，上面   match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet  渲染时候渲染就是它\n      index: element.props.index,\n      path: element.props.path,\n    &#125;;\n\n    if (element.props.children) &#123;\n      &#x2F;&#x2F; 有children\n      route.children &#x3D; createRoutesFromChildren(element.props.children);\n    &#125;\n\n    routes.push(route);\n  &#125;);\n\n  return routes;\n&#125;</code></pre>\n\n<h2 id=\"至此\"><a href=\"#至此\" class=\"headerlink\" title=\"至此\"></a>至此</h2><p>我们了解到了，react-router 监听，渲染整个过程</p>\n<h2 id=\"余下的勾子\"><a href=\"#余下的勾子\" class=\"headerlink\" title=\"余下的勾子\"></a>余下的勾子</h2><ul>\n<li>useNavigate</li>\n<li>useOutlet</li>\n<li>useParams</li>\n<li>useResolvedPath</li>\n</ul>\n<h3 id=\"useNavigate-2\"><a href=\"#useNavigate-2\" class=\"headerlink\" title=\"useNavigate\"></a>useNavigate</h3><p>独立功能块，提供 navigate 用于跳转两个参数，第一个参数接受数字和路径</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but\n * may also be used by other elements to change the location.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate\n *&#x2F;\nexport function useNavigate(): NavigateFunction &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  let activeRef &#x3D; React.useRef(false);\n  React.useEffect(() &#x3D;&gt; &#123;\n    activeRef.current &#x3D; true;\n  &#125;);\n\n  &#x2F;&#x2F; 声明一个函数\n  let navigate: NavigateFunction &#x3D; React.useCallback(\n    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n      warning(\n        activeRef.current,\n        &#96;You should call navigate() in a React.useEffect(), not when &#96; +\n          &#96;your component is first rendered.&#96;\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n        &#x2F;&#x2F; 支持数字\n        navigator.go(to);\n        return;\n      &#125;\n\n      let path &#x3D; resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        path.pathname &#x3D; joinPaths([basename, path.pathname]);\n      &#125;\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path, &#x2F;&#x2F; 支持路径跳转\n        options.state\n      );\n    &#125;,\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n  &#x2F;&#x2F; 返回这个函数\n  return navigate;\n&#125;</code></pre>\n\n<h3 id=\"useOutlet\"><a href=\"#useOutlet\" class=\"headerlink\" title=\"useOutlet\"></a>useOutlet</h3><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by &lt;Outlet&gt; to render child routes.\n * 返回路由层次结构此级别的子路由的元素。由&lt;Outlet&gt;内部使用以渲染子路由。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-outlet\n *&#x2F;\nexport function useOutlet(context?: unknown): React.ReactElement | null &#123;\n  let outlet &#x3D; React.useContext(RouteContext).outlet;\n  if (outlet) &#123;\n    return (\n      &lt;OutletContext.Provider value&#x3D;&#123;context&#125;&gt;&#123;outlet&#125;&lt;&#x2F;OutletContext.Provider&gt;\n    );\n  &#125;\n  return outlet;\n&#125;\n\n&#x2F;&#x2F; 使用\n\n&#x2F;**\n * Renders the child route&#39;s element, if there is one.\n * 渲染子路由的元素（如果有）。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;outlet\n *&#x2F;\nexport function Outlet(props: OutletProps): React.ReactElement | null &#123;\n  return useOutlet(props.context);\n&#125;</code></pre>\n\n<h3 id=\"useParams\"><a href=\"#useParams\" class=\"headerlink\" title=\"useParams\"></a>useParams</h3><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Returns an object of key&#x2F;value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n * 返回由路由路径匹配的当前URL中的动态参数的键&#x2F;值对组成的对象。\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-params\n *&#x2F;\nexport function useParams&lt;\n  ParamsOrKey extends string | Record&lt;string, string | undefined&gt; &#x3D; string\n&gt;(): Readonly&lt;\n  [ParamsOrKey] extends [string] ? Params&lt;ParamsOrKey&gt; : Partial&lt;ParamsOrKey&gt;\n&gt; &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let routeMatch &#x3D; matches[matches.length - 1];\n  &#x2F;&#x2F; 最后一个就是当前页面对应参数：怎么理解\n  &#x2F;&#x2F; 1. push情况，最后一个是当前页面\n  &#x2F;&#x2F; 2. replace情况，最后一个是当前页面\n  &#x2F;&#x2F; 3. pop 返回情况，最后一个是当前页面\n\n  &#x2F;&#x2F; 所以最后一个就是当前页面\n  return routeMatch ? (routeMatch.params as any) : &#123;&#125;;\n&#125;</code></pre>\n\n<h3 id=\"useResolvedPath\"><a href=\"#useResolvedPath\" class=\"headerlink\" title=\"useResolvedPath\"></a>useResolvedPath</h3><p><a href=\"https://github.com/841660202/react-router/blob/854f4a41780089ad114fecef1a25111830f5cc0b/examples/custom-link/src/App.tsx#L36\">具体使用见</a></p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;**\n * Resolves the pathname of the given &#96;to&#96; value against the current location.\n * 根据当前位置解析给定“to”值的路径名。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;api#useresolvedpath\n *&#x2F;\nexport function useResolvedPath(to: To): Path &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () &#x3D;&gt; resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n&#125;\n\n&#x2F;&#x2F; Path\n\nexport interface Path &#123;\n  &#x2F;**\n   * A URL pathname, beginning with a &#x2F;.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n   *&#x2F;\n  pathname: Pathname;\n\n  &#x2F;**\n   * A URL search string, beginning with a ?.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n   *&#x2F;\n  search: Search;\n\n  &#x2F;**\n   * A URL fragment identifier, beginning with a #.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash\n   *&#x2F;\n  hash: Hash;\n&#125;\n\n&#x2F;**\n * A URL pathname, beginning with a &#x2F;.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n *&#x2F;\nexport type Pathname &#x3D; string;\n\n&#x2F;**\n * A URL search string, beginning with a ?.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n *&#x2F;\nexport type Search &#x3D; string;\n\n&#x2F;**\n * A URL fragment identifier, beginning with a #.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash\n *&#x2F;\nexport type Hash &#x3D; string;</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://github.com/841660202/react-router\">fork 的 react-router 代码</a><br><a href=\"https://juejin.cn/post/6886290490640039943\">「源码解析 」这一次彻底弄懂 react-router 路由原理</a><br><a href=\"https://www.lmlphp.com/user/60155/article/item/1561048/\">React Router 教程</a></p>\n","text":"背景整了半天上一篇看的竟然是概念，我还以为是原理呢 最近看到了，面试题 react-router 原理，查了下答案，内容不是很多 React Router 原理浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理 React Router 源码解析 之前没看...","link":"","photos":[],"count_time":{"symbolsCount":"59k","symbolsTime":"53 mins."},"categories":[{"name":"React","slug":"React","count":19,"path":"api/categories/React.json"}],"tags":[{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"},{"name":"react-router","slug":"react-router","count":3,"path":"api/tags/react-router.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#index-ts\"><span class=\"toc-text\">index.ts</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#history\"><span class=\"toc-text\">history</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-router-dom\"><span class=\"toc-text\">react-router-dom</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%BE%E4%B8%AA-demo-%E4%BB%8E%E5%A4%B4%E7%9C%8B\"><span class=\"toc-text\">找个 demo 从头看</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BrowserRouter\"><span class=\"toc-text\">BrowserRouter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Routes\"><span class=\"toc-text\">Routes</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#createRoutesFromChildren\"><span class=\"toc-text\">createRoutesFromChildren</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useRoutes\"><span class=\"toc-text\">useRoutes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#matchRoutes\"><span class=\"toc-text\">matchRoutes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#renderMatches\"><span class=\"toc-text\">_renderMatches</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RouteContext\"><span class=\"toc-text\">RouteContext</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Link\"><span class=\"toc-text\">Link</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useHref\"><span class=\"toc-text\">useHref</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useLinkClickHandler\"><span class=\"toc-text\">useLinkClickHandler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useNavigate\"><span class=\"toc-text\">useNavigate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#resolveTo\"><span class=\"toc-text\">resolveTo</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useInRouterContext\"><span class=\"toc-text\">useInRouterContext</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Location-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Location 类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#history-x2F-index-ts-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">history&#x2F;index.ts 源码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">阶段性总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81-2\"><span class=\"toc-text\">代码 2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RouteContext-%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">RouteContext 在源码中的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useNavigate-1\"><span class=\"toc-text\">useNavigate</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81-2-1\"><span class=\"toc-text\">代码 2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Route\"><span class=\"toc-text\">Route</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createRoutesFromChildren-1\"><span class=\"toc-text\">createRoutesFromChildren</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%B3%E6%AD%A4\"><span class=\"toc-text\">至此</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%99%E4%B8%8B%E7%9A%84%E5%8B%BE%E5%AD%90\"><span class=\"toc-text\">余下的勾子</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useNavigate-2\"><span class=\"toc-text\">useNavigate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useOutlet\"><span class=\"toc-text\">useOutlet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useParams\"><span class=\"toc-text\">useParams</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useResolvedPath\"><span class=\"toc-text\">useResolvedPath</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"腾讯云COS,docx无法在浏览器预览","uid":"229017905bfbb779fea0f9efffb5a64c","slug":"2022-06-22cos","date":"2022-06-22T01:21:46.000Z","updated":"2022-09-16T13:54:56.151Z","comments":true,"path":"api/articles/2022-06-22cos.json","keywords":null,"cover":[],"text":"背景其他部门项目接入我们部门 wfc 审批流，有附件需要预览，附件种类非常多：图片、office(doc、ppt…)、代码文件（css、html、js…） 图片预览：使用第三方插件&#x2F;自己开发 pdf: 使用第三方插件&#x2F;iframe 具备浏览器预览 pdf 功能...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"对象存储","slug":"对象存储","count":1,"path":"api/categories/对象存储.json"}],"tags":[{"name":"对象存储","slug":"对象存储","count":1,"path":"api/tags/对象存储.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"react-router v6.4.0 主要概念","uid":"3d2993e7928f66556e52e3c255cfa133","slug":"2022-06-21react-router","date":"2022-06-21T01:06:50.000Z","updated":"2022-09-16T15:00:54.073Z","comments":true,"path":"api/articles/2022-06-21react-router.json","keywords":null,"cover":[],"text":"官网React Router v6 is Here React Router v6 在客户端路由十年的基础上，采用了以前版本及其姐妹项目 Reach Router 的最佳功能，采用了迄今为止最小和最强大的软件包。 TIP 或许某一天，再见时，已不是 v6 官网分为两块内容 核心概...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"React","slug":"React","count":19,"path":"api/categories/React.json"}],"tags":[{"name":"react-router","slug":"react-router","count":3,"path":"api/tags/react-router.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}