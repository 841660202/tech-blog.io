{"title":"前端基础-js表达式","uid":"5920bc0e327b10c465c146c4b5f81619","slug":"2022-10-19js表达式","date":"2022-10-19T10:00:07.000Z","updated":"2022-12-22T13:36:21.809Z","comments":true,"path":"api/articles/2022-10-19js表达式.json","keywords":null,"cover":[],"content":"<h2 id=\"1-逗号操作符-没你想象的那么简单\"><a href=\"#1-逗号操作符-没你想象的那么简单\" class=\"headerlink\" title=\"1. 逗号操作符, 没你想象的那么简单\"></a>1. 逗号操作符, 没你想象的那么简单</h2><p>对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let x &#x3D; 1;\n\nx &#x3D; (x++, x);\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 2\n\nx &#x3D; (2, 3);\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 3</code></pre>\n\n<p>这也太难了吧</p>\n<h2 id=\"2-super\"><a href=\"#2-super\" class=\"headerlink\" title=\"2. super\"></a>2. super</h2><ul>\n<li>在类中使用 super<ul>\n<li>调用父类上的静态方法</li>\n<li>删除 super 上的属性将抛出异常</li>\n<li>super.prop 不能覆写不可写属性</li>\n</ul>\n</li>\n<li>在对象字面量中使用 super.prop (先用 Object.setPrototypeOf() 建立关系)</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super\" target=\"_blank\" >见</a></p>\n<h2 id=\"3-void\"><a href=\"#3-void\" class=\"headerlink\" title=\"3. void\"></a>3. void</h2><h3 id=\"void-运算符对给定的表达式进行求值，然后返回-undefined。\"><a href=\"#void-运算符对给定的表达式进行求值，然后返回-undefined。\" class=\"headerlink\" title=\"void 运算符对给定的表达式进行求值，然后返回 undefined。\"></a>void 运算符对给定的表达式进行求值，然后返回 undefined。</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const output &#x3D; void 1;\nconsole.log(output);\n&#x2F;&#x2F; expected output: undefined\n\nvoid console.log(&quot;expression evaluated&quot;);\n&#x2F;&#x2F; expected output: &quot;expression evaluated&quot;\n\nvoid (function iife() &#123;\n  console.log(&quot;iife is executed&quot;);\n&#125;)();\n&#x2F;&#x2F; expected output: iife is executed\n\nvoid function test() &#123;\n  console.log(&quot;test function executed&quot;);\n&#125;;\ntry &#123;\n  test();\n&#125; catch (e) &#123;\n  console.log(&quot;test function is not defined&quot;);\n  &#x2F;&#x2F; expected output: &quot;test function is not defined&quot;\n&#125;\n\n&#x2F;&#x2F; &gt; undefined\n&#x2F;&#x2F; &gt; &quot;expression evaluated&quot;\n&#x2F;&#x2F; &gt; &quot;iife is executed&quot;\n&#x2F;&#x2F; &gt; &quot;test function is not defined&quot;</code></pre>\n\n<h3 id=\"优先级高于比较运算符\"><a href=\"#优先级高于比较运算符\" class=\"headerlink\" title=\"优先级高于比较运算符\"></a>优先级高于比较运算符</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">void 2 &#x3D;&#x3D;&#x3D; &quot;2&quot;; &#x2F;&#x2F; (void 2) &#x3D;&#x3D;&#x3D; &#39;2&#39;，返回 false\nvoid (2 &#x3D;&#x3D;&#x3D; &quot;2&quot;); &#x2F;&#x2F; void (2 &#x3D;&#x3D;&#x3D; &#39;2&#39;)，返回 undefined</code></pre>\n\n<h3 id=\"立即调用的函数表达式\"><a href=\"#立即调用的函数表达式\" class=\"headerlink\" title=\"立即调用的函数表达式\"></a>立即调用的函数表达式</h3><ul>\n<li>在所有的一元运算符中，void 提供了最好的语义，因为它明确表示函数调用的返回值应该被丢弃</li>\n<li>比用圆括号包裹函数表达式要长一些，圆括号的作用是强迫 function 关键字被解析为表达式的开始，而不是语句</li>\n</ul>\n<h3 id=\"javascript-url\"><a href=\"#javascript-url\" class=\"headerlink\" title=\"javascript url\"></a>javascript url</h3><p>当用户点击<code>一个以 javascript: 开头的 URI 时，它会执行 URI 中的代码，然后用返回的值替换页面内容，除非返回的值是 undefined</code>。void 运算符可用于返回 undefined</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;a href&#x3D;&quot;javascript:void(0);&quot;&gt; 这个链接点击之后不会做任何事情 &lt;&#x2F;a&gt;\n\n&lt;a href&#x3D;&quot;javascript:void(document.body.style.backgroundColor&#x3D;&#39;green&#39;);&quot;&gt;\n  点击这个链接会让页面背景变成绿色。\n&lt;&#x2F;a&gt;</code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>利用 javascript: 伪协议来执行 JavaScript 代码是不推荐的，推荐的做法是为链接元素绑定事件</p>\n</div>\n<h3 id=\"在箭头函数中避免泄漏\"><a href=\"#在箭头函数中避免泄漏\" class=\"headerlink\" title=\"在箭头函数中避免泄漏\"></a>在箭头函数中避免泄漏</h3><p>箭头函数标准中，允许在函数体不使用括号来直接返回值。如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用。安全起见，当函数返回值不会被使用到的时候，应该使用 void 运算符，来确保 API 改变时，并不会改变箭头函数的行为。</p>\n<pre class=\"line-numbers language-JS\" data-language=\"JS\"><code class=\"language-JS\">button.onclick &#x3D; () &#x3D;&gt; void doSomething();\n&#x2F;&#x2F; 这确保了当 doSomething 的返回值从 undefined 变为 true 的时候，不会改变代码的行为。</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void\" target=\"_blank\" >void 运算符</a></p>\n<h2 id=\"4-await\"><a href=\"#4-await\" class=\"headerlink\" title=\"4. await\"></a>4. await</h2><ul>\n<li><p>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。</p>\n</li>\n<li><p>若 Promise 正常处理 (fulfilled)，其回调的 resolve 函数参数作为 await 表达式的值，继续执行 async function。</p>\n</li>\n<li><p><code>若 Promise 处理异常 (rejected)，await 表达式会把 Promise 的异常原因抛出</code></p>\n</li>\n<li><p><code>若 await 操作符后的表达式的值不是一个 Promise，则返回该值本身</code></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 例1\nasync function f3() &#123;\n  var z &#x3D; await Promise.reject(30);\n&#125;\nf3(); &#x2F;&#x2F; 报错  Uncaught (in promise)\n\n&#x2F;&#x2F; 例2 try catch\nasync function f3() &#123;\n  try &#123;\n    var z &#x3D; await Promise.reject(30);\n  &#125; catch (e) &#123;\n    console.log(e); &#x2F;&#x2F; 30\n  &#125;\n&#125;\nf3(); &#x2F;&#x2F; 报错  Uncaught (in promise)\n\n&#x2F;&#x2F; 例3 .catch捕获\nasync function f3() &#123;\n  var z &#x3D; await Promise.reject(30);\n&#125;\nf3().catch((e) &#x3D;&gt; &#123;\n  console.log(&quot;e&quot;, e); &#x2F;&#x2F; e 30\n&#125;);</code></pre>\n\n<h2 id=\"5-解构赋值\"><a href=\"#5-解构赋值\" class=\"headerlink\" title=\"5. 解构赋值\"></a>5. 解构赋值</h2><p>解构赋值语法是一种 Javascript 表达式。通过解构赋值，可以将“属性&#x2F;值”从对“象&#x2F;数组”中取出，赋值给其他变量。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ul>\n<li>变量声明并赋值时的解构</li>\n<li>变量先声明后赋值时的解构</li>\n<li>默认值 （为了防止从数组中取出一个值为 undefined 的对象，可以在表达式左边的数组中为任意对象预设默认值。）</li>\n<li>交换变量</li>\n<li>解析一个从函数返回的数组</li>\n<li>忽略某些返回值 <code>[,,] = f();</code></li>\n<li>将剩余数组赋值给一个变量</li>\n<li>用正则表达式匹配提取值</li>\n</ul>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><ul>\n<li>基本赋值</li>\n<li>无声明赋值 <code>var a, b; (&#123;a, b&#125; = &#123;a: 1, b: 2&#125;);</code> 括号必须</li>\n<li>给新的变量名赋值</li>\n<li>默认值</li>\n<li>给新的变量命名并提供默认值 <code>var &#123;a:aa = 10, b:bb = 5&#125; = &#123;a: 3&#125;;</code></li>\n<li>对象属性计算名和解构<code>let key = &quot;z&quot;;let &#123; [key]: foo &#125; = &#123; z: &quot;bar&quot; &#125;;</code></li>\n<li>对象解构中的 Rest</li>\n<li>解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 声明对象 和 自身 self 属性\nvar obj &#x3D; &#123; self: &quot;123&quot; &#125;;\n&#x2F;&#x2F; 在原型链中定义一个属性 prot\nobj.__proto__.prot &#x3D; &quot;456&quot;;\n&#x2F;&#x2F; test\nconst &#123; self, prot &#125; &#x3D; obj;\n&#x2F;&#x2F; self &quot;123&quot;\n&#x2F;&#x2F; prot &quot;456&quot;（访问到了原型链）</code></pre>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><ul>\n<li>函数参数默认值</li>\n<li>从作为函数实参的对象中提取数据</li>\n</ul>\n<h3 id=\"解构嵌套对象和数组\"><a href=\"#解构嵌套对象和数组\" class=\"headerlink\" title=\"解构嵌套对象和数组\"></a>解构嵌套对象和数组</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let &#123;\n  title: englishTitle, &#x2F;&#x2F; rename\n  translations: [\n    &#123;\n      title: localeTitle, &#x2F;&#x2F; rename\n    &#125;,\n  ],\n&#125; &#x3D; metadata;</code></pre>\n\n<h3 id=\"For-of-迭代和解构\"><a href=\"#For-of-迭代和解构\" class=\"headerlink\" title=\"For of 迭代和解构\"></a>For of 迭代和解构</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (var &#123;\n  name: n,\n  family: &#123; father: f &#125;,\n&#125; of people) &#123;\n  console.log(&quot;Name: &quot; + n + &quot;, Father: &quot; + f);\n&#125;</code></pre>\n\n<h2 id=\"6-null\"><a href=\"#6-null\" class=\"headerlink\" title=\"6. null\"></a>6. null</h2><h3 id=\"null-的作用\"><a href=\"#null-的作用\" class=\"headerlink\" title=\"null 的作用\"></a>null 的作用</h3><ul>\n<li>值 null 是一个字面量，不像 undefined，它不是全局对象的一个属性。</li>\n<li><strong>null 表示缺少的标识，表示变量未指向任何对象。</strong></li>\n<li>把 null 作为尚未创建的对象，也许更好理解。</li>\n<li>在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。</li>\n</ul>\n<h3 id=\"null-与-undefined-的不同点：\"><a href=\"#null-与-undefined-的不同点：\" class=\"headerlink\" title=\"null 与 undefined 的不同点：\"></a>null 与 undefined 的不同点：</h3><p>当检测 null 或 undefined 时</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">typeof null; &#x2F;&#x2F; &quot;object&quot; (因为一些以前的原因而不是&#39;null&#39;)\ntypeof undefined; &#x2F;&#x2F; &quot;undefined&quot;\n\nnull &#x3D;&#x3D;&#x3D; undefined; &#x2F;&#x2F; false\n\n&#x2F;&#x2F; 1 + null &#x3D; 1\n&#x2F;&#x2F; 1 + undefined &#x3D; NaN\n\nisNaN(1 + null); &#x2F;&#x2F; false\nisNaN(1 + undefined); &#x2F;&#x2F; true\n\nNumber.isNaN(1 + null); &#x2F;&#x2F; false\nNumber.isNaN(1 + undefined); &#x2F;&#x2F; true</code></pre>\n\n<h2 id=\"7-new\"><a href=\"#7-new\" class=\"headerlink\" title=\"7. new\"></a>7. new</h2><h3 id=\"new-关键字做了什么\"><a href=\"#new-关键字做了什么\" class=\"headerlink\" title=\"new 关键字做了什么\"></a>new 关键字做了什么</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new#:~:text=%E6%8F%8F%E8%BF%B0-,new%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%A6%82%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C,-%EF%BC%9A\" target=\"_blank\" >见</a></p>\n<ol>\n<li>创建一个空的简单 JavaScript 对象（即 <strong>{}</strong> ）；</li>\n<li>新创建的对象添加属性<strong>proto</strong> ，将该属性链接至构造函数的原型对象；</li>\n<li>新创建的对象作为 this 的上下文；</li>\n<li>如果该函数没有返回对象，则返回<strong>this</strong></li>\n</ol>\n<h3 id=\"自定义对象\"><a href=\"#自定义对象\" class=\"headerlink\" title=\"自定义对象\"></a>自定义对象</h3><p><strong>创建一个用户自定义的对象需要两步：</strong></p>\n<ul>\n<li>通过编写函数来定义对象类型。（创建一个指定其名称和属性的函数）</li>\n<li>通过 new 来创建对象实例。</li>\n</ul>\n<h2 id=\"8-new-target\"><a href=\"#8-new-target\" class=\"headerlink\" title=\"8. new.target\"></a>8. new.target</h2><h3 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h3><p>new.target 语法由一个关键字”new”，一个点，和一个属性名”target”组成。</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>通常”new.”的作用: <code>是提供属性访问的上下文</code>，但这里<code>&quot;new.&quot;其实不是一个真正的对象</code>。</p>\n<p><strong>new.target</strong>属性允许你<code>检测函数或构造方法是否是通过 new 运算符被调用的</code>。<br>在通过 new 运算符被初始化的函数或构造方法中，<code>new.target</code> 返回一个指向构造方法或函数的引用。</p>\n<h3 id=\"不同函数中的区别\"><a href=\"#不同函数中的区别\" class=\"headerlink\" title=\"不同函数中的区别\"></a>不同函数中的区别</h3><p><em>不过在构造方法调用中，new.target 指向被 new 调用的构造函数，所以”new.”成为了一个虚拟上下文。</em></p>\n<p><em>在普通的函数调用中，</em> <code>new.target</code> 的值是 <code>undefined</code>。</p>\n<p><em>在 arrow functions 中，new.target 指向最近的外层函数的 new.target</em></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target\" target=\"_blank\" >见</a></p>\n<h2 id=\"9-window\"><a href=\"#9-window\" class=\"headerlink\" title=\"9. window\"></a>9. window</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 这个恒成立\nwindow.window.window.(无论多少个.window).window &#x3D;&#x3D;&#x3D; window\n&#x2F;&#x2F; 全局\n&#x2F;&#x2F; this.window &#x3D;&#x3D;&#x3D; window\n&#x2F;&#x2F; this &#x3D;&#x3D;&#x3D; window</code></pre>\n\n<h3 id=\"为什么-window-window-x3D-x3D-x3D-window\"><a href=\"#为什么-window-window-x3D-x3D-x3D-window\" class=\"headerlink\" title=\"为什么 window.window &#x3D;&#x3D;&#x3D; window\"></a>为什么 window.window &#x3D;&#x3D;&#x3D; window</h3><ul>\n<li>将 window 属性指向该 window 对象本身的目的，是为了更容易引用全局对象</li>\n</ul>\n<h2 id=\"10-this\"><a href=\"#10-this\" class=\"headerlink\" title=\"10. this\"></a>10. this</h2><p><em>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）</em><br><em>this 不能在执行期间被赋值,</em> 并且在每次函数被调用时 this 的值也可能会不同。</p>\n<p><em>ES5</em> 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。<br><em>ES2015</em> 引入了箭头函数，箭头函数不提供自身的 this 绑定（this 的值将保持为闭合词法上下文的值）。</p>\n<h3 id=\"全局上下文\"><a href=\"#全局上下文\" class=\"headerlink\" title=\"全局上下文\"></a>全局上下文</h3><h3 id=\"函数上下文\"><a href=\"#函数上下文\" class=\"headerlink\" title=\"函数上下文\"></a>函数上下文</h3><h3 id=\"eval-上下文-中执行同普通函数\"><a href=\"#eval-上下文-中执行同普通函数\" class=\"headerlink\" title=\"eval 上下文 中执行同普通函数\"></a>eval 上下文 中执行同普通函数</h3><h3 id=\"几种情况\"><a href=\"#几种情况\" class=\"headerlink\" title=\"几种情况\"></a>几种情况</h3><h4 id=\"函数上下文中的-this\"><a href=\"#函数上下文中的-this\" class=\"headerlink\" title=\"函数上下文中的 this\"></a>函数上下文中的 this</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var obj &#x3D; &#123;\n  bar: function () &#123;\n    var x &#x3D; () &#x3D;&gt; this;\n    return x;\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 作为 obj 对象的一个方法来调用 bar，把它的 this 绑定到 obj。\n&#x2F;&#x2F; 将返回的函数的引用赋值给 fn。\nvar fn &#x3D; obj.bar();\n\n&#x2F;&#x2F; 直接调用 fn 而不设置 this，\n&#x2F;&#x2F; 通常 (即不使用箭头函数的情况) 默认为全局对象\n&#x2F;&#x2F; 若在严格模式则为 undefined\nconsole.log(fn() &#x3D;&#x3D;&#x3D; obj); &#x2F;&#x2F; true</code></pre>\n\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><h4 id=\"作为构造函数\"><a href=\"#作为构造函数\" class=\"headerlink\" title=\"作为构造函数\"></a>作为构造函数</h4><p>当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。</p>\n<h4 id=\"派生类\"><a href=\"#派生类\" class=\"headerlink\" title=\"派生类\"></a>派生类</h4><p><code>在调用 super() 之前引用 this 会抛出错误。</code></p>\n<p><em>原因：</em></p>\n<p>派生类的构造函数没有初始的 this 绑定。在构造函数中调用 super() 会生成一个 this 绑定，并相当于执行如下代码，Base 为基类：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">this &#x3D; new Base();</code></pre>\n\n<h4 id=\"this-和对象转换-call-x2F-apply\"><a href=\"#this-和对象转换-call-x2F-apply\" class=\"headerlink\" title=\"this 和对象转换 call&#x2F;apply\"></a>this 和对象转换 call&#x2F;apply</h4><h4 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h4><h4 id=\"作为对象的方法\"><a href=\"#作为对象的方法\" class=\"headerlink\" title=\"作为对象的方法\"></a>作为对象的方法</h4><p>当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象。</p>\n<h4 id=\"原型链中的-this\"><a href=\"#原型链中的-this\" class=\"headerlink\" title=\"原型链中的 this\"></a>原型链中的 this</h4><p>如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样</p>\n<h4 id=\"getter-与-setter-中的-this\"><a href=\"#getter-与-setter-中的-this\" class=\"headerlink\" title=\"getter 与 setter 中的 this\"></a>getter 与 setter 中的 this</h4><p>用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.defineProperty(o, &quot;sum&quot;, &#123;\n  get: sum,\n  enumerable: true,\n  configurable: true,\n&#125;);</code></pre>\n\n<h4 id=\"作为一个-DOM-事件处理函数\"><a href=\"#作为一个-DOM-事件处理函数\" class=\"headerlink\" title=\"作为一个 DOM 事件处理函数\"></a>作为一个 DOM 事件处理函数</h4><p>当函数被用作事件处理函数时，它的 this <code>指向触发事件的元素</code></p>\n<p>（一些浏览器在使用<code>非addEventListener 的函数动态地添加监听函数时不遵守这个约定</code>）</p>\n<h4 id=\"作为一个内联事件处理函数\"><a href=\"#作为一个内联事件处理函数\" class=\"headerlink\" title=\"作为一个内联事件处理函数\"></a>作为一个内联事件处理函数</h4><p>当代码被内联 on-event 处理函数 (en-US) 调用时，它的 this <code>指向监听器所在的 DOM 元素</code>：</p>\n<h4 id=\"类中的-this-补充\"><a href=\"#类中的-this-补充\" class=\"headerlink\" title=\"类中的 this(补充)\"></a>类中的 this(补充)</h4><p>类声明和类表达式的主体都执行在严格模式下 <strong>同样遵循谁调用指向谁：</strong></p>\n<ol>\n<li>实例调用实例方法，指向实例</li>\n<li>类调用静态方法，指向类</li>\n<li><code>实例方法</code>、<code>类的静态方法</code>， 在全局调用，由于是严格模式，所以 this 是 undefined</li>\n</ol>\n<h3 id=\"综上总结如下：\"><a href=\"#综上总结如下：\" class=\"headerlink\" title=\"综上总结如下：\"></a>综上总结如下：</h3><img src=\"http://t-blog-images.aijs.top/img/202210192313834.svg\" style=\"max-width:100%; width: 500px\" />\n\n<h2 id=\"11-Error\"><a href=\"#11-Error\" class=\"headerlink\" title=\"11. Error\"></a>11. Error</h2><p>当运行时错误产生时，Error 对象会被抛出。Error 对象也可用于用户自定义的异常的基础对象</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><code>Error</code>创建一个新的 Error 对象</p>\n<h3 id=\"错误类型\"><a href=\"#错误类型\" class=\"headerlink\" title=\"错误类型\"></a>错误类型</h3><ul>\n<li><code>TypeError</code> 变量或参数不属于有效类型</li>\n<li><code>RangeError</code> 数值变量或参数超出其有效范围</li>\n<li><code>ReferenceError</code> 无效引用</li>\n<li><code>SyntaxError</code> 语法错误<div style=\"height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px\"></div></li>\n<li><code>EvalError</code> 与 eval() 有关</li>\n<li><code>URLError</code> 给 encodeURI() 或 decodeURI() 传递的参数无效。</li>\n<li><code>InternalError</code> 代表 Javascript 引擎内部错误的异常抛出的实例。如：递归太多<div style=\"height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px\"></div></li>\n<li><code>AggregateError</code> 包裹了由一个操作产生且需要报告的多个错误 如：Promise.any() 产生的错误</li>\n</ul>\n<p>可使用 instanceof 关键字，处理特定错误</p>\n<h3 id=\"组成部分\"><a href=\"#组成部分\" class=\"headerlink\" title=\"组成部分\"></a>组成部分</h3><ul>\n<li>错误文件路径 <code>Error.prototype.fileName</code></li>\n<li>错误行号 <code>Error.prototype.lineNumber</code></li>\n<li>错误列号 <code>Error.prototype.columnNumber</code></li>\n<li>错误原因 <code>Error.prototype.cause</code></li>\n<li>错误名 <code>Error.prototype.name</code></li>\n<li>错误消息 <code>Error.prototype.message</code></li>\n<li>错误堆栈跟踪 <code>Error.prototype.stack</code></li>\n</ul>\n<p><strong>助记忆</strong></p>\n<ol>\n<li>在哪里产生的错误： filename、lineNumber、columnNumber</li>\n<li>错误栈是什么：stack</li>\n<li>错误信息有哪些：name、message、cause</li>\n</ol>\n","text":"1. 逗号操作符, 没你想象的那么简单对它的每个操作数求值（从左到右），并返回最后一个操作数的值。 let x &#x3D; 1; x &#x3D; (x++, x); console.log(x); &#x2F;&#x2F; expected output: 2 x &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6-%E6%B2%A1%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95\"><span class=\"toc-text\">1. 逗号操作符, 没你想象的那么简单</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-super\"><span class=\"toc-text\">2. super</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-void\"><span class=\"toc-text\">3. void</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#void-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AF%B9%E7%BB%99%E5%AE%9A%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%B1%82%E5%80%BC%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E-undefined%E3%80%82\"><span class=\"toc-text\">void 运算符对给定的表达式进行求值，然后返回 undefined。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E4%BA%8E%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">优先级高于比较运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">立即调用的函数表达式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#javascript-url\"><span class=\"toc-text\">javascript url</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E9%81%BF%E5%85%8D%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">在箭头函数中避免泄漏</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-await\"><span class=\"toc-text\">4. await</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">5. 解构赋值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">解构嵌套对象和数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#For-of-%E8%BF%AD%E4%BB%A3%E5%92%8C%E8%A7%A3%E6%9E%84\"><span class=\"toc-text\">For of 迭代和解构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-null\"><span class=\"toc-text\">6. null</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#null-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">null 的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#null-%E4%B8%8E-undefined-%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">null 与 undefined 的不同点：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-new\"><span class=\"toc-text\">7. new</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new-%E5%85%B3%E9%94%AE%E5%AD%97%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">new 关键字做了什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">自定义对象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-new-target\"><span class=\"toc-text\">8. new.target</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E6%88%90\"><span class=\"toc-text\">组成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">不同函数中的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-window\"><span class=\"toc-text\">9. window</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-window-window-x3D-x3D-x3D-window\"><span class=\"toc-text\">为什么 window.window &#x3D;&#x3D;&#x3D; window</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-this\"><span class=\"toc-text\">10. this</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">全局上下文</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">函数上下文</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#eval-%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%90%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">eval 上下文 中执行同普通函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5\"><span class=\"toc-text\">几种情况</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84-this\"><span class=\"toc-text\">函数上下文中的 this</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">箭头函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">作为构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B4%BE%E7%94%9F%E7%B1%BB\"><span class=\"toc-text\">派生类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#this-%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2-call-x2F-apply\"><span class=\"toc-text\">this 和对象转换 call&#x2F;apply</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bind-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">bind 方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">作为对象的方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%AD%E7%9A%84-this\"><span class=\"toc-text\">原型链中的 this</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#getter-%E4%B8%8E-setter-%E4%B8%AD%E7%9A%84-this\"><span class=\"toc-text\">getter 与 setter 中的 this</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA-DOM-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">作为一个 DOM 事件处理函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%86%85%E8%81%94%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">作为一个内联事件处理函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%AD%E7%9A%84-this-%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">类中的 this(补充)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%BC%E4%B8%8A%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">综上总结如下：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-Error\"><span class=\"toc-text\">11. Error</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">错误类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">组成部分</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"gorm 关联","uid":"1e93951633e1850ed62331ad3c63ff79","slug":"2022-10-20gorm关联","date":"2022-10-20T08:46:50.000Z","updated":"2022-12-22T13:36:21.791Z","comments":true,"path":"api/articles/2022-10-20gorm关联.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202212211225570.webp","text":"打开认知belong to 属于 has one 拥有 belong to vs has one B belong to A : B 结构体和 B 的 ID 都 A 在结构体中 A has one B: A 的 id 在 B 结构体中，B 的结构体在 A 结构体中 Has man...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Go","slug":"Go","count":15,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":15,"path":"api/tags/Go.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Mysql 刚好遇到","uid":"42065b7e430b2dd22177e0c97bc4c0bd","slug":"2022-10-19mysql","date":"2022-10-19T01:13:08.000Z","updated":"2022-12-02T13:20:57.185Z","comments":true,"path":"api/articles/2022-10-19mysql.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","text":"数据库密码修改# 登陆 原密码 12345678,为了保证同一份代码可以在两台电脑上，无差别运行，密码改成一致的123456 👑 ~ $ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}