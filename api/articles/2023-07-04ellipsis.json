{"title":"ellipsis检测","uid":"0f92e5beba8a19456370cfbf5ca7de88","slug":"2023-07-04ellipsis","date":"2023-07-04T02:06:40.000Z","updated":"2023-07-16T02:13:26.428Z","comments":true,"path":"api/articles/2023-07-04ellipsis.json","keywords":null,"cover":[],"content":"<h1 id=\"ellipsis\"><a href=\"#ellipsis\" class=\"headerlink\" title=\"ellipsis\"></a>ellipsis</h1><ol>\n<li>字符串长度不够准确</li>\n<li>如何不用字符串长度更好的实现</li>\n</ol>\n<h2 id=\"html-前端如何检测-触发了-ellipsis\"><a href=\"#html-前端如何检测-触发了-ellipsis\" class=\"headerlink\" title=\"html 前端如何检测 触发了 ellipsis\"></a>html 前端如何检测 触发了 ellipsis</h2><p>要检测 HTML 前端中是否触发了文本省略（ellipsis），可以使用以下方法：</p>\n<ol>\n<li><strong>使用 JavaScript 和 DOM 操作：</strong> 在元素的父容器上使用 <code>offsetWidth</code>、<code>scrollWidth</code> 和 <code>clientWidth</code> 属性来检测省略。这些属性可以帮助确定元素是否溢出容器，因为触发了省略。比较 <code>scrollWidth</code> 和 <code>clientWidth</code> 可以判断是否溢出，然后可以将其与 <code>offsetWidth</code> 进行比较。如果它们的值不同，就表示触发了省略。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var element &#x3D; document.getElementById(&#39;yourElement&#39;);\nif (element.scrollWidth &gt; element.clientWidth) &#123;\n  &#x2F;&#x2F; 触发了省略\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li><strong>使用 CSS 选择器和伪类：</strong> 利用 CSS 的伪类 <code>:after</code>，结合一些特殊的样式来检测省略。通过设置一个与元素相同的宽度，并将其内容设置为省略号，然后检查伪类的样式是否应用到了省略号上。</li>\n</ol>\n<p>CSS 代码示例：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* 设置伪类的样式 *&#x2F;\n.ellipsis::after &#123;\n  content: &#39;...&#39;;\n  visibility: hidden;\n  position: absolute;\n&#125;\n\n&#x2F;* 检测是否触发省略 *&#x2F;\n.ellipsis.detect-ellipsis::after &#123;\n  visibility: visible;\n&#125;</code></pre>\n\n<p>HTML 代码示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;div class&#x3D;&quot;ellipsis detect-ellipsis&quot;&gt;Very long text that may be truncated by ellipsis.&lt;&#x2F;div&gt;</code></pre>\n\n<p>使用上述方法之一，可以在 HTML 前端中检测到是否触发了 ellipsis。</p>\n<h2 id=\"真实示例图\"><a href=\"#真实示例图\" class=\"headerlink\" title=\"真实示例图\"></a>真实示例图</h2><img src=\"http://t-blog-images.aijs.top/img/202307041007549.webp\" style=\"width:800px;max-width:100%\" />\n\n<h1 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h1><h2 id=\"记录以前的问题\"><a href=\"#记录以前的问题\" class=\"headerlink\" title=\"记录以前的问题\"></a>记录以前的问题</h2><p>下面仅仅为了，对于有经验的 React 开发，可以直接跳到修改后的源码</p>\n<h2 id=\"演示类型错误及解决方案\"><a href=\"#演示类型错误及解决方案\" class=\"headerlink\" title=\"演示类型错误及解决方案\"></a>演示类型错误及解决方案</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; Tooltip &#125; from &#39;antd&#39;;\nimport type &#123; TooltipProps &#125; from &#39;antd&#x2F;dist&#x2F;tooltip&#39;;\nimport React, &#123; useEffect, useRef, useState &#125; from &#39;react&#39;;\n\ninterface IProps &#123;\n  tooltipProps?: TooltipProps;\n  text: string;\n&#125;\nconst EllipsisTooltip: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; text, tooltipProps &#125; &#x3D; props;\n  const [title, setTitle] &#x3D; useState(null);\n  const refDom &#x3D; useRef();\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (refDom.current) &#123;\n      setTitle(refDom.current.scrollWidth &gt; refDom.current.clientWidth ? text : null);\n    &#125;\n  &#125;, [refDom.current, text]);\n  return (\n    &lt;Tooltip\n      overlayClassName&#x3D;&quot;collection-custom-tooltip&quot;\n      placement&#x3D;&quot;bottom&quot;\n      overlayInnerStyle&#x3D;&#123;&#123; borderRadius: 8 &#125;&#125;\n      title&#x3D;&#123;title&#125;\n      &#123;...tooltipProps&#125;\n    &gt;\n      &lt;span\n        style&#x3D;&#123;&#123;\n          wordBreak: &#39;break-all&#39;,\n          display: &#39;block&#39;,\n          overflow: &#39;hidden&#39;,\n          textOverflow: &#39;ellipsis&#39;,\n          flex: 1,\n          whiteSpace: &#39;nowrap&#39;,\n        &#125;&#125;\n        ref&#x3D;&#123;refDom&#125;\n      &gt;\n        &#123;text&#125;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;Tooltip&gt;\n  );\n&#125;;\n\nexport default EllipsisTooltip;</code></pre>\n\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202307041022979.webp\" /> -->\n\n<h2 id=\"react-span-useRef-的类型\"><a href=\"#react-span-useRef-的类型\" class=\"headerlink\" title=\"react span useRef 的类型\"></a>react span useRef 的类型</h2><p>在 React 中，您可以使用<code>useRef</code>钩子来创建一个引用。引用可以用于获取 DOM 元素或跟踪组件内的特定值。</p>\n<p>当您使用<code>useRef</code>创建一个引用时，引用的类型是<code>React.RefObject</code>。这是一个泛型类型，可以指定引用所引用的 DOM 元素或组件的类型。</p>\n<p>示例代码如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React, &#123; useRef &#125; from &#39;react&#39;;\n\nfunction MyComponent() &#123;\n  &#x2F;&#x2F; 创建一个引用，引用的类型为 HTMLSpanElement\n  const spanRef &#x3D; useRef &lt; HTMLSpanElement &gt; null;\n\n  &#x2F;&#x2F; 在组件渲染后，可以使用引用来操作DOM元素\n  const handleButtonClick &#x3D; () &#x3D;&gt; &#123;\n    if (spanRef.current) &#123;\n      &#x2F;&#x2F; 操作DOM元素\n      spanRef.current.style.color &#x3D; &#39;red&#39;;\n    &#125;\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;handleButtonClick&#125;&gt;改变颜色&lt;&#x2F;button&gt;\n      &lt;span ref&#x3D;&#123;spanRef&#125;&gt;Hello World&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<p>在上面的示例中，我们通过<code>useRef</code>创建了一个名为<code>spanRef</code>的引用，并指定它引用的类型为<code>HTMLSpanElement</code>。在组件渲染后，我们可以通过<code>spanRef.current</code>来访问 DOM 元素，并对其进行操作。</p>\n<p>请注意，使用<code>useRef</code>创建的引用在组件重新渲染时保持不变。这使得我们可以在组件重新渲染后仍然能够访问到之前引用的元素或值。</p>\n<h2 id=\"过程截图\"><a href=\"#过程截图\" class=\"headerlink\" title=\"过程截图\"></a>过程截图</h2><img src=\"http://t-blog-images.aijs.top/img/202307041030832.webp\" />\n\n<h2 id=\"修改后的代码\"><a href=\"#修改后的代码\" class=\"headerlink\" title=\"修改后的代码\"></a>修改后的代码</h2><pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; Tooltip &#125; from &#39;@ty-fe&#x2F;sun&#39;;\nimport type &#123; TooltipProps &#125; from &#39;@ty-fe&#x2F;sun&#x2F;dist&#x2F;tooltip&#39;;\nimport React, &#123; useEffect, useRef, useState &#125; from &#39;react&#39;;\n\ninterface IProps &#123;\n  tooltipProps?: TooltipProps;\n  text: string;\n&#125;\nconst EllipsisTooltip: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; text, tooltipProps &#125; &#x3D; props;\n  const [title, setTitle] &#x3D; useState&lt;string | null&gt;(null);\n  const refDom &#x3D; useRef&lt;HTMLSpanElement&gt;(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (refDom.current) &#123;\n      setTitle(refDom.current.scrollWidth &gt; refDom.current.clientWidth ? text : null);\n    &#125;\n  &#125;, [refDom.current, text]); &#x2F;&#x2F; 为了重新计算\n  return (\n    &lt;Tooltip\n      overlayClassName&#x3D;&quot;collection-custom-tooltip&quot;\n      placement&#x3D;&quot;bottom&quot;\n      overlayInnerStyle&#x3D;&#123;&#123; borderRadius: 8 &#125;&#125;\n      title&#x3D;&#123;title&#125;\n      &#123;...tooltipProps&#125;\n    &gt;\n      &lt;span\n        style&#x3D;&#123;&#123;\n          wordBreak: &#39;break-all&#39;,\n          display: &#39;block&#39;,\n          overflow: &#39;hidden&#39;,\n          textOverflow: &#39;ellipsis&#39;,\n          flex: 1,\n          whiteSpace: &#39;nowrap&#39;,\n        &#125;&#125;\n        ref&#x3D;&#123;refDom&#125;\n      &gt;\n        &#123;text&#125;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;Tooltip&gt;\n  );\n&#125;;\n\nexport default EllipsisTooltip;</code></pre>\n","text":"ellipsis 字符串长度不够准确 如何不用字符串长度更好的实现 html 前端如何检测 触发了 ellipsis要检测 HTML 前端中是否触发了文本省略（ellipsis），可以使用以下方法： 使用 JavaScript 和 DOM 操作： 在元素的父容器上使用 offse...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"前端","slug":"前端","count":5,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":5,"path":"api/tags/前端.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ellipsis\"><span class=\"toc-text\">ellipsis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#html-%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B-%E8%A7%A6%E5%8F%91%E4%BA%86-ellipsis\"><span class=\"toc-text\">html 前端如何检测 触发了 ellipsis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9C%9F%E5%AE%9E%E7%A4%BA%E4%BE%8B%E5%9B%BE\"><span class=\"toc-text\">真实示例图</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#react\"><span class=\"toc-text\">react</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BD%95%E4%BB%A5%E5%89%8D%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">记录以前的问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">演示类型错误及解决方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-span-useRef-%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">react span useRef 的类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E7%A8%8B%E6%88%AA%E5%9B%BE\"><span class=\"toc-text\">过程截图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">修改后的代码</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React ts","uid":"6ab3589fb705488879a93d4f18abc3a2","slug":"2023-07-04react-ts","date":"2023-07-04T08:28:12.000Z","updated":"2023-07-08T01:06:25.368Z","comments":true,"path":"api/articles/2023-07-04react-ts.json","keywords":null,"cover":null,"text":"useImperativeHandle 如何使用 typescript 类型在 TypeScript 中使用 useImperativeHandle 需要定义一个合适的类型以确保类型安全性。以下是使用 useImperativeHandle 的示例代码，包括 TypeScript...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"获取开发大概时间","uid":"f294c5e88fbdfee2c3ec39e3af3f094c","slug":"2023-07-04git-py","date":"2023-07-04T00:36:43.000Z","updated":"2023-07-20T14:58:47.209Z","comments":true,"path":"api/articles/2023-07-04git-py.json","keywords":null,"cover":[],"text":"背景赚点小钱，看看划不划算，作为以后评估工作量的参考 脚本import subprocess from datetime import datetime def get_user_commits(username): git_log &#x3D; subprocess.check...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}