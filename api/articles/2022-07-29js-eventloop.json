{"title":"前端基础-js eventloop","uid":"2f158976ef1fb5c7b879b46326b6f72a","slug":"2022-07-29js-eventloop","date":"2022-07-29T10:04:52.000Z","updated":"2023-05-15T13:17:32.953Z","comments":true,"path":"api/articles/2022-07-29js-eventloop.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/事件循环.png","content":"<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><img src=\"http://t-blog-images.aijs.top/img/事件循环.png\" style=\"max-width: 100%; width: 500px\"/>\n\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p>\n<p>为什么要这么设计，跟 JavaScript 的应用场景有关</p>\n<p>JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？</p>\n<p>为了解决单线程运行阻塞问题，JavaScript 用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p>\n<h2 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h2><p>js 运行的环境,被称为<code>宿主环境</code>，目前有三种运行环境，</p>\n<ul>\n<li>一种运行在<code>浏览器(javaScript)</code></li>\n<li>一种运行在<code>服务端(nodejs)</code></li>\n<li>另一种是运行在我们的<code>客户端(比如 Vscode 客户端就是使用 js 写的)</code></li>\n</ul>\n<p>其他的比如：IOS 中<code>jscore</code>，Android <code>JavascriptInterace</code>, C++ <code>JSI</code></p>\n<p><strong>因此只要给 js 配备的相应的执行引擎，js 可以运行在任何环境</strong></p>\n<h2 id=\"浏览器宿主环境\"><a href=\"#浏览器宿主环境\" class=\"headerlink\" title=\"浏览器宿主环境\"></a>浏览器宿主环境</h2><img src=\"http://t-blog-images.aijs.top/img/20220729223730.png\"  style=\"height: 60px\"/>\n\n<h3 id=\"JS-线程\"><a href=\"#JS-线程\" class=\"headerlink\" title=\"JS 线程\"></a>JS 线程</h3><p>负责执行执行栈的最顶层 JS 代码<br>和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。</p>\n<h3 id=\"GUI-线程\"><a href=\"#GUI-线程\" class=\"headerlink\" title=\"GUI 线程\"></a>GUI 线程</h3><p>负责渲染页面,解析 HTML、CSS 构成 渲染树等，当页面重绘或者由于某种操作引起回流都会调起该线程。<br>和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。</p>\n<h3 id=\"事件监听线程\"><a href=\"#事件监听线程\" class=\"headerlink\" title=\"事件监听线程\"></a>事件监听线程</h3><p>(DOM 事件，window 窗口事件等等)</p>\n<p>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到事件队列的队尾，等待 JS 引擎处理。</p>\n<h3 id=\"计时线程\"><a href=\"#计时线程\" class=\"headerlink\" title=\"计时线程\"></a>计时线程</h3><p>（SetTimeout、setInterval 计时器）</p>\n<p>开启定时器触发线程来计时并触发计时，计时完毕后，将计时器结束的回调函数添加到事件队列中，等待 JS 引擎空闲后执行，等待 JS 引擎处理。<br>浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。</p>\n<h3 id=\"网络线程\"><a href=\"#网络线程\" class=\"headerlink\" title=\"网络线程\"></a>网络线程</h3><p>（ajax 网络请求）</p>\n<p>http 请求的时候会开启一条请求线程。<br>请求完成有结果了之后，将请求的 http 回调函数添加到任务队列中，等待 JS 引擎处理。</p>\n<h2 id=\"两个概念\"><a href=\"#两个概念\" class=\"headerlink\" title=\"两个概念\"></a>两个概念</h2><ul>\n<li><p>栈是先进后出</p>\n</li>\n<li><p>队列先进先出</p>\n</li>\n</ul>\n<h2 id=\"事件队列\"><a href=\"#事件队列\" class=\"headerlink\" title=\"事件队列\"></a>事件队列</h2><p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</p>\n<p><code>宏任务（队列）macroTack</code>：计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列<br><code>微任务（队列）microTack</code>：<code>MutationObserver</code>,<code>Promise 产生的回调</code>进入微队列</p>\n<p>当执行栈清空时、JS 引擎首<code>先会将微任务中的所有任务依次执行结束</code>，如果没有微任务，执行宏任务</p>\n<h2 id=\"事件循环-Event-Loop\"><a href=\"#事件循环-Event-Loop\" class=\"headerlink\" title=\"事件循环(Event Loop)\"></a>事件循环(Event Loop)</h2><p><strong>JavaScript 事件循环（Event Loop）是 JavaScript 运行时的一种机制，用于处理异步事件和回调函数</strong>。在 JavaScript 中，很多操作都是异步执行的，比如网络请求、定时器等等。这些异步操作会被放置到任务队列中，而不会立即执行。当主线程执行完同步任务后，会进入事件循环，从任务队列中取出待执行的任务，并按照顺序执行。执行完一个任务后，JavaScript 引擎会重新进入事件循环，继续取出待执行的任务并执行，直到所有任务都执行完成。</p>\n<p>JavaScript 事件循环的基本流程如下：</p>\n<ol>\n<li>执行同步任务。</li>\n<li>查看任务队列中是否有任务，如果有则取出最先进入队列的任务。</li>\n<li>执行任务。</li>\n<li>重复步骤 2 和步骤 3，直到任务队列为空。</li>\n</ol>\n<p>在事件循环中，任务队列被分为两种：宏任务（Macro Task）和微任务（Micro Task）。宏任务包括 setTimeout、setInterval、ajax 等等，而微任务包括 Promise、process.nextTick 等等。<strong>浏览器环境：在事件循环中，每个宏任务执行完成后，都会执行所有的微任务，然后才会执行下一个宏任务</strong>。</p>\n<p>JavaScript 事件循环的概念对于理解 JavaScript 的异步编程非常重要。同时，也需要注意避免事件循环中可能出现的一些问题，比如过度使用异步操作、回调函数嵌套等等，以免导致程序出现性能问题或难以维护。</p>\n<h2 id=\"执行栈\"><a href=\"#执行栈\" class=\"headerlink\" title=\"执行栈\"></a>执行栈</h2><!-- 由于 JavaScript 引擎是单线程，同一时间只能执行一个任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务，因此这些任务被排队在一个单独的地方。这个地方被称为执行栈\n\n`执行栈是一个后进先出数据结构`，用于存放各种函数的执行环境，\n每一个函数执行之前，它的相关信息会加入到执行栈，\n函数调用之前，创建执行环境，然后 push 到执行栈；\n函数调用之后，销毁执行环境，并从执行栈顶部推（pop）出去 -->\n\n<p><strong>JavaScript 执行栈是一种数据结构，用于存储执行上下文（Execution Context）的堆栈</strong>。执行上下文是 JavaScript 代码执行时创建的一个内部数据结构，其中包含变量、函数、对象以及代码执行的环境信息。</p>\n<ul>\n<li>当 JavaScript 引擎开始执行代码时，它会首先创建一个全局执行上下文，并将其推入执行栈的顶部。</li>\n<li>然后，当 JavaScript 引擎执行函数时，它会创建一个新的执行上下文，并将其推入执行栈的顶部。</li>\n<li>当函数执行完成后，执行上下文将从栈中弹出，JavaScript 引擎将继续执行上一个执行上下文，直到最终弹出全局执行上下文。</li>\n</ul>\n<p><strong>执行栈是一个重要的概念，因为它决定了 JavaScript 代码的执行顺序。</strong></p>\n<ul>\n<li>如果执行栈中有多个执行上下文，那么 JavaScript 引擎将按照它们的顺序依次执行，直到栈中没有剩余的执行上下文为止。</li>\n<li>如果执行栈中有太多的执行上下文，可能会导致栈溢出错误，这通常是由于无限递归调用函数造成的。</li>\n<li>因此，在编写 JavaScript 代码时，需要注意避免出现无限递归和过度嵌套函数等问题，以确保执行栈能够正常工作。</li>\n</ul>\n<h3 id=\"什么是全局上执行下文，什么是函数执行上下文\"><a href=\"#什么是全局上执行下文，什么是函数执行上下文\" class=\"headerlink\" title=\"什么是全局上执行下文，什么是函数执行上下文\"></a>什么是全局上执行下文，什么是函数执行上下文</h3><p>在 JavaScript 中，每当代码开始执行时，都会创建一个执行上下文（Execution Context）。执行上下文是一个内部数据结构，它包含了代码执行所需要的环境信息，包括变量、函数、对象等等。</p>\n<p>全局执行上下文是在 JavaScript 代码开始执行时创建的第一个执行上下文。它是整个程序的最外层作用域，包含了全局变量、函数、对象等等。全局执行上下文只有一个，直到程序运行结束都不会被销毁。</p>\n<p>函数执行上下文是在函数被调用时创建的执行上下文。每次函数被调用时，都会创建一个新的执行上下文，并将其推入执行栈的顶部。函数执行上下文包含了函数的参数、局部变量、内部函数等等。</p>\n<p>全局执行上下文和函数执行上下文的主要区别在于它们的作用域和生命周期。全局执行上下文是整个程序的最外层作用域，其生命周期贯穿整个程序的执行过程。而函数执行上下文只在函数被调用时创建，当函数执行完成后就会被销毁。在函数执行上下文中，作用域链会包含外部函数的执行上下文和全局执行上下文，可以访问它们中定义的变量、函数等等。</p>\n<p><strong>理解全局执行上下文和函数执行上下文的概念对于理解 JavaScript 的作用域、闭包、作用域链等概念非常重要。同时，在编写 JavaScript 代码时，需要注意避免出现变量命名冲突等问题，以确保执行上下文能够正常工作。</strong></p>\n<h2 id=\"Event-Loop-在浏览器与-node-环境中的区别：\"><a href=\"#Event-Loop-在浏览器与-node-环境中的区别：\" class=\"headerlink\" title=\"Event Loop 在浏览器与 node 环境中的区别：\"></a>Event Loop 在浏览器与 node 环境中的区别：</h2><p>浏览器环境每次执行一个宏任务，再去检查微任务<br>node 会清空当前所处阶段的队列，即执行所有 task，再去检查微任务</p>\n<h2 id=\"浏览器环境-事例\"><a href=\"#浏览器环境-事例\" class=\"headerlink\" title=\"浏览器环境 事例\"></a>浏览器环境 事例</h2><h3 id=\"事例-1\"><a href=\"#事例-1\" class=\"headerlink\" title=\"事例 1\"></a>事例 1</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n    function a() &#123;\n        console.log(&quot;a&quot;)\n        b();\n    &#125;\n\n    function b() &#123;\n        console.log(&quot;b&quot;);\n        c();\n    &#125;\n\n    function c() &#123;\n        console.log(&quot;c&quot;)\n    &#125;\n\n    console.log(&quot;global&quot;);\n    a();\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<h3 id=\"事例-2\"><a href=\"#事例-2\" class=\"headerlink\" title=\"事例 2\"></a>事例 2</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(1);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(2);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(3);\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(4);\n    &#125;, 0);\n  &#125;, 0);\n&#125;, 0);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(5);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(6);\n  &#125;, 0);\n&#125;, 0);\n\nconsole.log(&#39;ok&#39;);</code></pre>\n\n<h3 id=\"事例-3\"><a href=\"#事例-3\" class=\"headerlink\" title=\"事例 3\"></a>事例 3</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(1);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;setTimeout&#39;);\n&#125;, 0);\n\nlet promise &#x3D; new Promise((resolve) &#x3D;&gt; &#123;\n  console.log(3);\n  resolve();\n&#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(100);\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(200);\n  &#125;);\n\nconsole.log(2);</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/41543963\" target=\"_blank\" >Event Loop 这个循环你晓得么？(附 GIF 详解)</a></p>\n<p><a href=\"https://juejin.cn/post/6844904008134426638\" target=\"_blank\" >[回顾]事件循环机制 (Event-loop)</a></p>\n","text":"思维导图 背景JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟 JavaScript 的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">思维导图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">运行环境</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">浏览器宿主环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">JS 线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GUI-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">GUI 线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">事件监听线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E6%97%B6%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">计时线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">网络线程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">两个概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97\"><span class=\"toc-text\">事件队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop\"><span class=\"toc-text\">事件循环(Event Loop)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%A0%88\"><span class=\"toc-text\">执行栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E5%B1%80%E4%B8%8A%E6%89%A7%E8%A1%8C%E4%B8%8B%E6%96%87%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">什么是全局上执行下文，什么是函数执行上下文</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Event-Loop-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">Event Loop 在浏览器与 node 环境中的区别：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83-%E4%BA%8B%E4%BE%8B\"><span class=\"toc-text\">浏览器环境 事例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BE%8B-1\"><span class=\"toc-text\">事例 1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BE%8B-2\"><span class=\"toc-text\">事例 2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BE%8B-3\"><span class=\"toc-text\">事例 3</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-js 作用域","uid":"991fb01358aaac1abfe173de529db251","slug":"2022-07-30js-scope","date":"2022-07-30T15:52:03.000Z","updated":"2023-05-15T13:17:32.954Z","comments":true,"path":"api/articles/2022-07-30js-scope.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/作用域.png","text":"问题var let const 区别： 在 JavaScript 中，var、let 和 const 是用于声明变量的关键字，它们之间有以下几点区别：sckzb 重复声明： var：可以重复声明同名变量，后面的声明会覆盖前面的声明。 let 和 const：不能重复声明同名变量，...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-js 闭包","uid":"c29bc77697ff47f9bbee179892d7fe85","slug":"2022-07-28js-closures","date":"2022-07-28T10:04:36.000Z","updated":"2023-02-20T21:20:56.469Z","comments":true,"path":"api/articles/2022-07-28js-closures.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202207291656804.webp","text":"思维导图 闭包一个函数 和 对其周围状态（lexical environment，词法环境）的引用, 捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） 闭包让你可以在一个内层函数中 访问到 其外层函数的作用域。 在形式上体现为函数嵌套，内层函数有外层函数的...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}