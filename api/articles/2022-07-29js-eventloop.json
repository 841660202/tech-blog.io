{"title":"前端基础-js eventloop","uid":"2f158976ef1fb5c7b879b46326b6f72a","slug":"2022-07-29js-eventloop","date":"2022-07-29T10:04:52.000Z","updated":"2022-08-01T12:46:55.449Z","comments":true,"path":"api/articles/2022-07-29js-eventloop.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/事件循环.png","content":"<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><img src=\"http://t-blog-images.aijs.top/img/事件循环.png\" style=\"max-width: 100%; width: 500px\"/>\n\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p>\n<p>为什么要这么设计，跟 JavaScript 的应用场景有关</p>\n<p>JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？</p>\n<p>为了解决单线程运行阻塞问题，JavaScript 用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p>\n<h2 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h2><p>js 运行的环境,被称为<code>宿主环境</code>，目前有三种运行环境，</p>\n<ul>\n<li>一种运行在<code>浏览器(javaScript)</code></li>\n<li>一种运行在<code>服务端(nodejs)</code></li>\n<li>另一种是运行在我们的<code>客户端(比如 Vscode 客户端就是使用 js 写的)</code></li>\n</ul>\n<p>其他的比如：IOS 中<code>jscore</code>，Android <code>JavascriptInterace</code>, C++ <code>JSI</code></p>\n<p><strong>因此只要给 js 配备的相应的执行引擎，js 可以运行在任何环境</strong></p>\n<h2 id=\"浏览器宿主环境\"><a href=\"#浏览器宿主环境\" class=\"headerlink\" title=\"浏览器宿主环境\"></a>浏览器宿主环境</h2><img src=\"http://t-blog-images.aijs.top/img/20220729223730.png\"  style=\"height: 60px\"/>\n\n<h3 id=\"JS-线程\"><a href=\"#JS-线程\" class=\"headerlink\" title=\"JS 线程\"></a>JS 线程</h3><p>负责执行执行栈的最顶层 JS 代码<br>和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。</p>\n<h3 id=\"GUI-线程\"><a href=\"#GUI-线程\" class=\"headerlink\" title=\"GUI 线程\"></a>GUI 线程</h3><p>负责渲染页面,解析 HTML、CSS 构成 渲染树等，当页面重绘或者由于某种操作引起回流都会调起该线程。<br>和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。</p>\n<h3 id=\"事件监听线程\"><a href=\"#事件监听线程\" class=\"headerlink\" title=\"事件监听线程\"></a>事件监听线程</h3><p>(DOM 事件，window 窗口事件等等)</p>\n<p>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到事件队列的队尾，等待 JS 引擎处理。</p>\n<h3 id=\"计时线程\"><a href=\"#计时线程\" class=\"headerlink\" title=\"计时线程\"></a>计时线程</h3><p>（SetTimeout、setInterval 计时器）</p>\n<p>开启定时器触发线程来计时并触发计时，计时完毕后，将计时器结束的回调函数添加到事件队列中，等待 JS 引擎空闲后执行，等待 JS 引擎处理。<br>浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。</p>\n<h3 id=\"网络线程\"><a href=\"#网络线程\" class=\"headerlink\" title=\"网络线程\"></a>网络线程</h3><p>（ajax 网络请求）</p>\n<p>http 请求的时候会开启一条请求线程。<br>请求完成有结果了之后，将请求的 http 回调函数添加到任务队列中，等待 JS 引擎处理。</p>\n<h2 id=\"两个概念\"><a href=\"#两个概念\" class=\"headerlink\" title=\"两个概念\"></a>两个概念</h2><ul>\n<li><p>栈是先进后出</p>\n</li>\n<li><p>队列先进先出</p>\n</li>\n</ul>\n<h2 id=\"事件队列\"><a href=\"#事件队列\" class=\"headerlink\" title=\"事件队列\"></a>事件队列</h2><p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</p>\n<p><code>宏任务（队列）macroTack</code>：计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列<br><code>微任务（队列）microTack</code>：<code>MutationObserver</code>,<code>Promise 产生的回调</code>进入微队列</p>\n<p>当执行栈清空时、JS 引擎首<code>先会将微任务中的所有任务依次执行结束</code>，如果没有微任务，执行宏任务</p>\n<h2 id=\"事件循环-Event-Loop\"><a href=\"#事件循环-Event-Loop\" class=\"headerlink\" title=\"事件循环(Event Loop)\"></a>事件循环(Event Loop)</h2><p>事件循环分为三个部分，分别由 <code>浏览器宿主</code>，<code>web api</code> 与 <code>事件队列（也称任务队列）</code>组成</p>\n<h2 id=\"执行栈\"><a href=\"#执行栈\" class=\"headerlink\" title=\"执行栈\"></a>执行栈</h2><p>由于 JavaScript 引擎是单线程，同一时间只能执行一个任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务，因此这些任务被排队在一个单独的地方。这个地方被称为执行栈</p>\n<p><code>执行栈是一个后进先出数据结构</code>，用于存放各种函数的执行环境，<br>每一个函数执行之前，它的相关信息会加入到执行栈，<br>函数调用之前，创建执行环境，然后 push 到执行栈；<br>函数调用之后，销毁执行环境，并从执行栈顶部推（pop）出去</p>\n<h2 id=\"Event-Loop-在浏览器与-node-环境中的区别：\"><a href=\"#Event-Loop-在浏览器与-node-环境中的区别：\" class=\"headerlink\" title=\"Event Loop 在浏览器与 node 环境中的区别：\"></a>Event Loop 在浏览器与 node 环境中的区别：</h2><p>浏览器环境每次执行一个宏任务，再去检查微任务<br>node 会清空当前所处阶段的队列，即执行所有 task，再去检查微任务</p>\n<h2 id=\"浏览器环境-事例\"><a href=\"#浏览器环境-事例\" class=\"headerlink\" title=\"浏览器环境 事例\"></a>浏览器环境 事例</h2><h3 id=\"事例-1\"><a href=\"#事例-1\" class=\"headerlink\" title=\"事例 1\"></a>事例 1</h3><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&lt;script&gt;\n    function a() &#123;\n        console.log(&quot;a&quot;)\n        b();\n    &#125;\n\n    function b() &#123;\n        console.log(&quot;b&quot;);\n        c();\n    &#125;\n\n    function c() &#123;\n        console.log(&quot;c&quot;)\n    &#125;\n\n    console.log(&quot;global&quot;);\n    a();\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<h3 id=\"事例-2\"><a href=\"#事例-2\" class=\"headerlink\" title=\"事例 2\"></a>事例 2</h3><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">console.log(1);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(2);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(3);\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(4);\n    &#125;, 0);\n  &#125;, 0);\n&#125;, 0);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(5);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(6);\n  &#125;, 0);\n&#125;, 0);\n\nconsole.log(&quot;ok&quot;);</code></pre>\n\n<h3 id=\"事例-3\"><a href=\"#事例-3\" class=\"headerlink\" title=\"事例 3\"></a>事例 3</h3><pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">console.log(1);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 0);\n\nlet promise &#x3D; new Promise((resolve) &#x3D;&gt; &#123;\n  console.log(3);\n  resolve();\n&#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(100);\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(200);\n  &#125;);\n\nconsole.log(2);</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/41543963\" target=\"_blank\" >Event Loop 这个循环你晓得么？(附 GIF 详解)</a></p>\n<p><a href=\"https://juejin.cn/post/6844904008134426638\" target=\"_blank\" >[回顾]事件循环机制 (Event-loop)</a></p>\n","text":"思维导图 背景JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟 JavaScript 的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":27,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">思维导图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">运行环境</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">浏览器宿主环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">JS 线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GUI-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">GUI 线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">事件监听线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E6%97%B6%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">计时线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">网络线程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">两个概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97\"><span class=\"toc-text\">事件队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop\"><span class=\"toc-text\">事件循环(Event Loop)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%A0%88\"><span class=\"toc-text\">执行栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Event-Loop-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">Event Loop 在浏览器与 node 环境中的区别：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83-%E4%BA%8B%E4%BE%8B\"><span class=\"toc-text\">浏览器环境 事例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BE%8B-1\"><span class=\"toc-text\">事例 1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BE%8B-2\"><span class=\"toc-text\">事例 2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BE%8B-3\"><span class=\"toc-text\">事例 3</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-js 作用域","uid":"991fb01358aaac1abfe173de529db251","slug":"2022-07-30js-scope","date":"2022-07-30T15:52:03.000Z","updated":"2022-08-15T13:56:15.206Z","comments":true,"path":"api/articles/2022-07-30js-scope.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/作用域.png","text":"思维导图 作用域MDN: 在当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。 如果一个变量或者其他表达式,不 “在当前的作用域中”，那么它就是不可用的。 作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":27,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/tags/前端基础.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-js 闭包","uid":"c29bc77697ff47f9bbee179892d7fe85","slug":"2022-07-28js-closures","date":"2022-07-28T10:04:36.000Z","updated":"2022-08-01T12:46:55.448Z","comments":true,"path":"api/articles/2022-07-28js-closures.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202207291656804.webp","text":"思维导图 闭包一个函数 和 对其周围状态（lexical environment，词法环境）的引用, 捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） 也就是说，闭包让你可以在一个内层函数中 访问到 其外层函数的作用域。在形式上体现为函数嵌套，内层函数有外...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":27,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/tags/前端基础.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}