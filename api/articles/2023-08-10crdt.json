{"title":"Conflict-free Replicated Data Types","uid":"394bb45c1e16d8019d34eec70cf2892e","slug":"2023-08-10crdt","date":"2023-08-10T02:11:51.000Z","updated":"2023-08-10T08:11:58.244Z","comments":true,"path":"api/articles/2023-08-10crdt.json","keywords":null,"cover":null,"content":"<h2 id=\"什么是-CRDT\"><a href=\"#什么是-CRDT\" class=\"headerlink\" title=\"什么是 CRDT\"></a>什么是 CRDT</h2><p>Conflict-free Replicated Data Type (CRDT)</p>\n<p>无冲突复制数据类型（CRDT）是一种简化分布式数据存储系统和多用户应用程序的数据结构。</p>\n<h2 id=\"为什么是-CRDT\"><a href=\"#为什么是-CRDT\" class=\"headerlink\" title=\"为什么是 CRDT\"></a>为什么是 CRDT</h2><p>在许多系统中，某些数据的副本需要存储在多台计算机上（称为副本）。此类系统的示例包括：</p>\n<ul>\n<li>在本地设备上存储数据并需要将该数据同步到属于同一用户的其他设备（例如日历、笔记、联系人或提醒）的移动应用程序；</li>\n<li>分布式数据库，维护数据的多个副本（在同一数据中心或不同位置），以便在某些副本离线时系统继续正常工作；</li>\n<li>协作软件，例如 Google Docs、Trello、FIGMA 或许多其他软件，其中多个用户可以同时更改同一文件或数据；</li>\n<li>大规模数据存储和处理系统，复制数据以实现全局可扩展性。</li>\n</ul>\n<p>所有此类系统都需要处理数据可能在不同副本上同时修改的事实。从广义上讲，有两种可能的方法来处理此类数据修改：</p>\n<h2 id=\"广义数据一致\"><a href=\"#广义数据一致\" class=\"headerlink\" title=\"广义数据一致\"></a>广义数据一致</h2><p>强一致性复制：</p>\n<p>在此模型中，副本相互协调以决定何时以及如何应用修改。这种方法支持强一致性模型，例如可序列化事务和线性化。然而，</p>\n<ul>\n<li>等待这种协调会降低这些系统的性能；</li>\n<li>此外，CAP 定理告诉我们，在副本与系统的其余部分断开连接时（例如，由于网络分区，或者因为它是具有间歇性连接的移动设备），不可能对副本进行任何数据更改。</li>\n</ul>\n<p>乐观复制：</p>\n<p>在此模型中，用户可以独立于任何其他副本修改任何副本上的数据，</p>\n<ul>\n<li>即使副本脱机或与其他副本断开连接。这种方法可以实现最大的性能和可用性，</li>\n<li>但当多个客户端或用户同时修改同一数据时，它可能会导致冲突。当副本相互通信时，这些冲突需要解决。</li>\n</ul>\n<h2 id=\"CRDT-解决了什么问题\"><a href=\"#CRDT-解决了什么问题\" class=\"headerlink\" title=\"CRDT 解决了什么问题\"></a>CRDT 解决了什么问题</h2><ul>\n<li><p>无冲突复制数据类型（CRDT）用于具有乐观复制的系统中，它们负责冲突解决。</p>\n</li>\n<li><p>CRDT 确保无论对不同副本进行什么数据修改，数据始终可以合并到一致的状态。</p>\n</li>\n<li><p>这种合并由 CRDT 自动执行，不需要任何特殊的冲突解决代码或用户干预。</p>\n</li>\n<li><p>CRDT 的一个重要特点是它们支持去中心化操作：它们不假设使用单个服务器，因此它们可以用于点对点网络和其他去中心化设置。在这方面，CRDT 不同于 Google Docs, Trello, and Figma 使用的算法，后者要求用户之间的所有通信都通过服务器进行。</p>\n</li>\n</ul>\n<h2 id=\"CRDT-库对比\"><a href=\"#CRDT-库对比\" class=\"headerlink\" title=\"CRDT 库对比\"></a>CRDT 库对比</h2><p>有几个开源 CRDT 库可用于构建协作应用程序和复制存储系统：</p>\n<ul>\n<li><code>Automerge</code>是一个带有 JSON 数据模型的 CRDT 实现。它用 Rust 实现，绑定到 JavaScript（通过 WebAssembly）和各种其他语言。网络通信和存储由一个单独的层处理，称为自动存储库。</li>\n<li><code>GUN（GitHub</code>）是一个用 JavaScript 实现的图形 CRDT，使用 WebRTC 网络。它包括基于公钥的用户身份验证和加密。</li>\n<li><code>kappa-db</code>是一个 JavaScript 库，用于在仅追加日志架构上构建您自己的 CRDT，并为 Dat 的超核心数据结构提供参考实现。有点像“构建您自己的”Automerge 库。</li>\n<li><code>Replicated Object Notation</code> 复制对象表示法（RON）是一种用于编码 CRDT 操作的数据格式，以多种语言实现。它支持寄存器、列表、文本、集合和计数器数据类型。SwalDB 是一个基于 RON 的数据库，用 JavaScript 实现。</li>\n<li><code>Yjs</code> 是一个用于在 Web 上构建协作应用程序的模块化框架，它包括几个常见的 CRDT 和模块，这些模块将它们与不同的编辑器、通信协议和数据库集成在一起。</li>\n<li><code>Legion</code>（GitHub）提供了计数器、集合、映射和列表 CRDT 的 JavaScript 实现，以及基于 WebRTC 的网络层。</li>\n<li><code>Yorkie</code>（GitHub）是一种用于构建协作应用程序的同步解决方案，使用 MongoDB 进行数据存储。</li>\n</ul>\n<h2 id=\"专业术语\"><a href=\"#专业术语\" class=\"headerlink\" title=\"专业术语\"></a>专业术语</h2><p>CRDT（Conflict-Free Replicated Data Type，无冲突复制数据类型）术语表：</p>\n<ol>\n<li><p><strong>复制数据类型（Replicated Data Type，RDT）：</strong> 一种数据结构，可以在多个节点之间进行复制和同步，而无需中央协调器来处理冲突。</p>\n</li>\n<li><p><strong>无冲突（Conflict-Free）：</strong> CRDT 的设计目标之一是在分布式环境中消除冲突，即使在多个节点同时进行修改，最终状态也是一致的。</p>\n</li>\n<li><p><strong>标识（Identifier）：</strong> 用于标识 CRDT 中的数据项或元素的唯一标识符，以便在不同节点之间识别和比较。</p>\n</li>\n<li><p><strong>状态（State）：</strong> 数据类型的当前状态，由多个元素和其对应标识组成。</p>\n</li>\n<li><p><strong>操作（Operation）：</strong> 在 CRDT 中指的是对数据项的更改，可以是插入、删除、修改等。</p>\n</li>\n<li><p><strong>局部操作（Local Operation）：</strong> 单个节点上的操作，不需要与其他节点同步。</p>\n</li>\n<li><p><strong>合并（Merge）：</strong> 将两个或多个节点的操作组合在一起，以确保数据的最终一致性。</p>\n</li>\n<li><p><strong>同步（Synchronization）：</strong> 将分布式系统中的节点的状态进行比较和更新，以使它们保持一致。</p>\n</li>\n<li><p><strong>收敛（Convergence）：</strong> CRDT 确保所有节点在进行一系列操作后，最终达到相同的状态。</p>\n</li>\n<li><p><strong>可见性（Visibility）：</strong> CRDT 数据项的可见性指的是节点何时能够看到其他节点所做的操作。</p>\n</li>\n<li><p><strong>增量更新（Incremental Update）：</strong> 将单个操作或一组操作应用于 CRDT，而不需要重新传输整个数据集。</p>\n</li>\n<li><p><strong>准确度（Accuracy）：</strong> CRDT 确保在最终收敛后，每个节点上的数据都是正确和一致的。</p>\n</li>\n<li><p><strong>下界（Lower Bound）：</strong> CRDT 的一个属性，确保在合并时不会丢失任何信息。</p>\n</li>\n<li><p><strong>上界（Upper Bound）：</strong> CRDT 的一个属性，确保合并过程不会产生重复的信息。</p>\n</li>\n<li><p><strong>优化（Optimization）：</strong> 通过减少通信或操作的数量来提高 CRDT 性能的方法。</p>\n</li>\n<li><p><strong>标记（Marker）：</strong> 在 CRDT 中用于标记一组操作的状态，以便在合并时处理这些操作。</p>\n</li>\n</ol>\n<p>这些术语涵盖了 CRDT 概念的关键方面，帮助解释了 CRDT 在分布式系统中的工作原理以及如何确保数据的一致性和可靠性。</p>\n<h2 id=\"CRDT-实现原理\"><a href=\"#CRDT-实现原理\" class=\"headerlink\" title=\"CRDT 实现原理\"></a>CRDT 实现原理</h2><p>CRDT（Conflict-Free Replicated Data Type，无冲突复制数据类型）的实现原理基于一些核心概念，其中包括分布式数据结构、局部操作、合并策略等。CRDT 旨在在分布式系统中实现数据的一致性，即使在多个节点同时进行修改时也能避免冲突。</p>\n<p>以下是 CRDT 实现的基本原理：</p>\n<ol>\n<li><p><strong>数据结构的设计：</strong> CRDT 根据应用需求设计数据结构，例如集合、映射、计数器等。这些数据结构被扩展以支持分布式环境中的局部操作和合并。</p>\n</li>\n<li><p><strong>局部操作：</strong> 每个节点都可以在本地执行局部操作，如插入、删除、修改等。这些操作会在数据结构中生成标记，用于记录操作的效果和影响。</p>\n</li>\n<li><p><strong>标识符分配：</strong> 每个元素或操作都有一个唯一的标识符，通常是一个版本向量或时间戳。这些标识符用于识别和比较元素的状态。</p>\n</li>\n<li><p><strong>合并策略：</strong> 当节点之间需要同步数据时，合并策略会被应用来决定如何合并不同节点的操作。合并策略的目标是确保所有节点达到相同的最终状态，而无需解决冲突。</p>\n</li>\n<li><p><strong>收敛：</strong> 合并操作的重要目标是使所有节点最终达到相同的状态。这种状态一致性被称为“收敛”，意味着节点之间的操作最终会达成一致。</p>\n</li>\n<li><p><strong>通信和同步：</strong> 节点之间需要相互通信来传输操作、状态更新或元数据。这种通信是实现数据同步和合并的关键。</p>\n</li>\n<li><p><strong>可见性和操作顺序：</strong> CRDT 确保节点之间的操作顺序是可见的，以便在合并时正确地应用操作。这可以通过版本向量、时间戳等机制来实现。</p>\n</li>\n<li><p><strong>下界和上界：</strong> CRDT 的实现应确保操作的合并过程不会产生重复数据或丢失数据。这些特性被称为“下界”和“上界”。</p>\n</li>\n</ol>\n<p>总的来说，CRDT 的实现原理是基于分布式数据结构的设计、局部操作的执行、合并策略的应用以及数据同步的通信过程。CRDT 通过这些机制确保分布式系统中的数据一致性，而无需中央服务器来解决冲突。不同类型的 CRDT（如增量型、状态型等）在实现细节上可能会有所不同，但核心目标都是实现数据的一致性和可靠性。</p>\n<h2 id=\"分布式数据结构\"><a href=\"#分布式数据结构\" class=\"headerlink\" title=\"分布式数据结构\"></a>分布式数据结构</h2><p>分布式数据结构是一种适用于多台计算机或节点的数据组织方式。在分布式系统中，数据被分散存储在不同节点上，需要考虑数据同步、节点故障等问题。这种数据结构需要能够在节点间同步数据、处理操作冲突，并保证数据一致性。</p>\n<p>关键特点包括：</p>\n<ol>\n<li><p><strong>复制与同步：</strong> 数据在多节点之间复制和同步，确保可用性和容错性。</p>\n</li>\n<li><p><strong>局部操作：</strong> 节点能够在本地执行操作，减少网络开销。</p>\n</li>\n<li><p><strong>合并策略：</strong> 多节点修改数据时，需要决定如何合并变更，以保持一致性。</p>\n</li>\n<li><p><strong>可见性：</strong> 确保操作顺序和可见性，以正确应用操作。</p>\n</li>\n<li><p><strong>分区：</strong> 数据被分成部分存储在不同节点上，需要考虑数据分区和路由。</p>\n</li>\n</ol>\n<p>常见的分布式数据结构有分布式哈希表、分布式队列、分布式集合等。选用合适的结构能够确保数据一致性和性能。</p>\n<h2 id=\"slate\"><a href=\"#slate\" class=\"headerlink\" title=\"slate\"></a>slate</h2><p><code>明确的【核心】边界划分</code>。 通过插件优先的架构与精简 Schema 的内核，Slate 对于【核心】和【自定义】有着明确得多的划分，从而保证核心的编辑体验不会为各种边缘情况所困扰。</p>\n<p><code>支持嵌套的文档模型</code>。 Slate 所使用的文档模型是一棵嵌套的、递归的树，和 DOM 本身十分接近。这使得构建表格和嵌套引用等能够满足进阶需求的复杂组件成为了可能。当然，你同样可以使用单一的层级关系以保证简单性。</p>\n<p><code>无状态、不可变的数据</code>。 通过使用 React 和 Immutable.js，我们是基于不可变数据结构，以无状态的方式构建 Slate 编辑器的。这大大降低了理解代码的难度，也节约了大量开发插件的时间。</p>\n<p><code>直观的 changes</code>。 Slate 中的内容是通过 “change” 来编辑的，这是一种被设计为支持高阶使用，且极其符合直觉的概念。这样，我们就能够通过它来尽可能简单地编写插件和自定义功能了。</p>\n<p><code>为协同编辑准备的数据模型</code>。 Slate 使用的数据模型——尤其是由 change 更改文档的方式——在设计时就已考虑到对协同编辑的支持。所以，如果你决定为编辑器添加协作功能，你不需要进行彻底的重构。（当然，这还需要你投入更多的努力！）</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://crdt.tech/\" target=\"_blank\" >About CRDTs</a></li>\n<li><a href=\"https://crdt.tech/implementations\" target=\"_blank\" >General-purpose CRDT libraries¶</a></li>\n<li><a href=\"https://doodlewind.github.io/slate-doc-cn/\" target=\"_blank\" >slate-doc-cn</a></li>\n</ol>\n","text":"什么是 CRDTConflict-free Replicated Data Type (CRDT) 无冲突复制数据类型（CRDT）是一种简化分布式数据存储系统和多用户应用程序的数据结构。 为什么是 CRDT在许多系统中，某些数据的副本需要存储在多台计算机上（称为副本）。此类系统的...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"OA","slug":"OA","count":1,"path":"api/categories/OA.json"}],"tags":[{"name":"OA","slug":"OA","count":1,"path":"api/tags/OA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-CRDT\"><span class=\"toc-text\">什么是 CRDT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-CRDT\"><span class=\"toc-text\">为什么是 CRDT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%BF%E4%B9%89%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4\"><span class=\"toc-text\">广义数据一致</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CRDT-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">CRDT 解决了什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CRDT-%E5%BA%93%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">CRDT 库对比</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">专业术语</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CRDT-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">CRDT 实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">分布式数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#slate\"><span class=\"toc-text\">slate</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"codegeex","uid":"a3d4fc61c24b41eefededa001ecd952e","slug":"2023-08-12codegeex","date":"2023-08-12T08:17:50.000Z","updated":"2023-08-12T08:58:51.873Z","comments":true,"path":"api/articles/2023-08-12codegeex.json","keywords":null,"cover":[],"text":" 见 没有 chartgpt 好用，说不定哪天还可能收费 login 多次不成功 开发梯子了 没有信赖域名 ","link":"","photos":[],"count_time":{"symbolsCount":57,"symbolsTime":"1 mins."},"categories":[{"name":"GML","slug":"GML","count":1,"path":"api/categories/GML.json"}],"tags":[{"name":"GML","slug":"GML","count":1,"path":"api/tags/GML.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"shp 转化成svg","uid":"678ea4635fbf5da941ca04bd2df09797","slug":"2023-08-05shp","date":"2023-08-05T11:21:49.000Z","updated":"2023-08-05T11:33:49.629Z","comments":true,"path":"api/articles/2023-08-05shp.json","keywords":null,"cover":null,"text":"绘制城市环路图实现过程 shp 数据 shp 转化成 svg mapshaper sketch 调整 svg 大小 d3js 绘制 svg 增加交互 参考链接基于 shp 完成 echarts map 的显示 ","link":"","photos":[],"count_time":{"symbolsCount":106,"symbolsTime":"1 mins."},"categories":[{"name":"可视化","slug":"可视化","count":1,"path":"api/categories/可视化.json"}],"tags":[{"name":"可视化","slug":"可视化","count":1,"path":"api/tags/可视化.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}