{"title":"Go 语言 特殊语法","uid":"cc6337a39cba986d99843e70d56686e5","slug":"2022-10-15go","date":"2022-10-15T01:54:03.000Z","updated":"2022-10-18T12:24:12.487Z","comments":true,"path":"api/articles/2022-10-15go.json","keywords":null,"cover":[],"content":"<h2 id=\"走心\"><a href=\"#走心\" class=\"headerlink\" title=\"走心\"></a>走心</h2><p>建议尽量早一点的进入这些新技术，而不是等待这些技术成熟之后再进入。原因有这么几个:</p>\n<ul>\n<li><strong>技术的发展过程非常重要</strong>。因为你可以清楚地看到这些新技术的生态圈发展过程，让我们收获最大的往往不是这些技术本身，而是一个技术的变现和行业的发展</li>\n<li><strong>从中我们可以看到非常具体的各种思潮和思路，这些东西比起技术本身来说更有价值</strong>。因为这不但让我们重新思考已经掌握的技术，以及如何更好地解决已有的问题.而且还让我们看到了未来, 不但有了技术优势，而且这些知识还让我们的技术生涯多了很多的可能性</li>\n<li><strong>这些关键技术可以让你拿到技术的先机</strong>，这些对一个需要技术领导力的个人或者公司来说都是非常重要的。一个公司或使个人能够占有技术先机，就会比其他公司或个人有更大的影响力。一旦未来行业需要引爆，那么这个公司或使个人的影响力就会成为一个比较大的护城河。</li>\n</ul>\n<h2 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h2><p>“人生苦短，我用 python”. 余生太贵，要不换 Go</p>\n<h2 id=\"下载安装-go\"><a href=\"#下载安装-go\" class=\"headerlink\" title=\"下载安装 go\"></a>下载安装 go</h2><p><a href=\"https://golang.google.cn/doc/install\" target=\"_blank\" >官方安装包地址</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ go version\ngo version go1.19.2 darwin&#x2F;amd64\n</code></pre>\n\n<h2 id=\"Tour-教程\"><a href=\"#Tour-教程\" class=\"headerlink\" title=\"Tour 教程\"></a>Tour 教程</h2><p>之前没找到到这文档，看了菜鸟教程的 go，傻白白地以为没教程</p>\n<p><a href=\"https://tour.go-zh.org/welcome/1\" target=\"_blank\" >https://tour.go-zh.org/welcome/1</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202210180958616.webp\" />\n \n<h3 id=\"命名返回\"><a href=\"#命名返回\" class=\"headerlink\" title=\"命名返回\"></a>命名返回</h3><p><a href=\"https://tour.go-zh.org/basics/7\" target=\"_blank\" >见</a></p>\n<p><strong>实现</strong></p>\n<ul>\n<li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</li>\n<li>没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。</li>\n</ul>\n<p><strong>功能</strong></p>\n<ul>\n<li>返回值的名称应当具有一定的意义，它可以作为文档使用。</li>\n</ul>\n<p><strong>优缺点：</strong><br>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>\n<h2 id=\"If\"><a href=\"#If\" class=\"headerlink\" title=\"If\"></a>If</h2><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">if initialization; condition &#123;\n    &#x2F;&#x2F; do something\n&#125;\n\n&#x2F;&#x2F; 例如:\n\nval :&#x3D; 10\nif val &gt; max &#123;\n    &#x2F;&#x2F; do something\n&#125;\n&#x2F;&#x2F; 你也可以这样写:\n\nif val :&#x3D; 10; val &gt; max &#123;\n    &#x2F;&#x2F; do something\n&#125;\n\n&#x2F;&#x2F; ————————————————\n&#x2F;&#x2F; 原文作者：Go 技术论坛文档：《Go 入门指南（）》\n&#x2F;&#x2F; 转自链接：https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;the-way-to-go&#x2F;if-else-structure&#x2F;3592\n&#x2F;&#x2F; 版权声明：翻译文档著作权归译者和 LearnKu 社区所有。转载请保留原文链接\n</code></pre>\n\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>数组是<code>具有相同唯一类型</code>的一组<code>已编号且长度固定</code>的数据项序列，这种类型可以是任意的<code>原始类型</code>例如整型、字符串或者<code>自定义类型</code></p>\n<p>语法：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var variable_name [SIZE] variable_type</code></pre>\n\n<p><strong>数组初始化</strong></p>\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; [] 被用于限定大小，&#123;&#125; 用于内容，与其他语言不同\nvar balance &#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></pre>\n\n<h3 id=\"x3D\"><a href=\"#x3D\" class=\"headerlink\" title=\":&#x3D;\"></a>:&#x3D;</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 我们也可以通过字面量在声明数组的同时快速初始化数组：\nbalance :&#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; &#x2F;&#x2F; :&#x3D; 声明赋值运算符</code></pre>\n\n<h3 id=\"长度不定\"><a href=\"#长度不定\" class=\"headerlink\" title=\"长度不定\"></a>长度不定</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 如果数组长度不确定，可以使用 ... 代替数组的长度，\n&#x2F;&#x2F; 编译器会根据元素个数自行推断数组的长度：\nvar balance &#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F; 或\nbalance :&#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F; 如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</code></pre>\n\n<h3 id=\"指定索引赋值\"><a href=\"#指定索引赋值\" class=\"headerlink\" title=\"指定索引赋值\"></a>指定索引赋值</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 将索引为 1 和 3 的元素初始化\nbalance :&#x3D; [5]float32&#123;1:2.0,3:7.0&#125;\n&#x2F;&#x2F; 初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。</code></pre>\n\n<h3 id=\"自动推断\"><a href=\"#自动推断\" class=\"headerlink\" title=\"自动推断\"></a>自动推断</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：\n\nbalance[4] &#x3D; 50.0\n</code></pre>\n\n<h3 id=\"多维数组语法\"><a href=\"#多维数组语法\" class=\"headerlink\" title=\"多维数组语法\"></a>多维数组语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    &#x2F;&#x2F; Step 1: 创建数组\n    values :&#x3D; [][]int&#123;&#125; &#x2F;&#x2F; 这里要注意下，目前见到的例子都是空值初始化\n\n    &#x2F;&#x2F; Step 2: 使用 append() 函数向空的二维数组添加两行一维数组\n    row1 :&#x3D; []int&#123;1, 2, 3&#125;\n    row2 :&#x3D; []int&#123;4, 5, 6&#125;\n    values &#x3D; append(values, row1)\n    values &#x3D; append(values, row2)\n\n    &#x2F;&#x2F; Step 3: 显示两行数据\n    fmt.Println(&quot;Row 1&quot;)\n    fmt.Println(values[0])\n    fmt.Println(&quot;Row 2&quot;)\n    fmt.Println(values[1])\n\n    &#x2F;&#x2F; Step 4: 访问第一个元素\n    fmt.Println(&quot;第一个元素为：&quot;)\n    fmt.Println(values[0][0])\n&#125;\n</code></pre>\n\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><h3 id=\"指针的指针\"><a href=\"#指针的指针\" class=\"headerlink\" title=\"指针的指针\"></a>指针的指针</h3><p><strong>指向指针的指针</strong><br>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p>\n<p>当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</p>\n<p>指向指针的指针变量声明格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var ptr **int;\n</code></pre>\n\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\n   var a int\n   var ptr *int\n   var pptr **int\n\n   a &#x3D; 3000\n\n   &#x2F;* 指针 ptr 地址 *&#x2F;\n   ptr &#x3D; &amp;a\n\n   &#x2F;* 指向指针 ptr 地址 *&#x2F;\n   pptr &#x3D; &amp;ptr\n\n   &#x2F;* 获取 pptr 的值 *&#x2F;\n   fmt.Printf(&quot;变量 a &#x3D; %d\\n&quot;, a )\n   fmt.Printf(&quot;指针变量 *ptr &#x3D; %d\\n&quot;, *ptr )\n   fmt.Printf(&quot;指向指针的指针变量 **pptr &#x3D; %d\\n&quot;, **pptr)\n&#125;\n</code></pre>\n\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><ul>\n<li><p>其他语言对比：go 语言保留了，OC 中的结构体？可以理解为类的另一种写法</p>\n</li>\n<li><p>自身数组区别：Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>\n</li>\n<li><p>构造函数有没有联系：我在想：结构体里的<code>构</code>是不是，构造函数的 <code>构</code></p>\n</li>\n</ul>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 结构体定义需要使用 type 和 struct 语句。\n&#x2F;&#x2F; struct 语句定义一个新的数据类型，结构体中有一个或多个成员。\n&#x2F;&#x2F; type 语句设定了结构体的名称。结构体的格式如下：\n\ntype struct_variable_type struct &#123;\n   member definition\n   member definition\n   ...\n   member definition\n&#125;</code></pre>\n\n<p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">variable_name :&#x3D; structure_variable_type &#123;value1, value2...valuen&#125;\n或\nvariable_name :&#x3D; structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</code></pre>\n\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n\n    &#x2F;&#x2F; 创建一个新的结构体\n    fmt.Println(Books&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)\n\n    &#x2F;&#x2F; 也可以使用 key &#x3D;&gt; value 格式\n    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;, subject: &quot;Go 语言教程&quot;, book_id: 6495407&#125;)\n\n    &#x2F;&#x2F; 忽略的字段为 0 或 空\n   fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;&#125;)\n&#125;</code></pre>\n\n<h3 id=\"结构体指针\"><a href=\"#结构体指针\" class=\"headerlink\" title=\"结构体指针\"></a>结构体指针</h3><p>你可以定义<code>指向结构体的指针类似于其他指针变量</code>，格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var struct_pointer *Books\n\n&#x2F;&#x2F; 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：\nstruct_pointer &#x3D; &amp;Book1\n\n&#x2F;&#x2F; 使用结构体指针访问结构体成员，使用 &quot;.&quot; 操作符：\nstruct_pointer.title</code></pre>\n\n<h3 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">\npackage main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n   var Book1 Books        &#x2F;* 声明 Book1 为 Books 类型 *&#x2F;\n   var Book2 Books        &#x2F;* 声明 Book2 为 Books 类型 *&#x2F;\n\n   &#x2F;* book 1 描述 *&#x2F;\n   Book1.title &#x3D; &quot;Go 语言&quot;\n   Book1.author &#x3D; &quot;www.runoob.com&quot;\n   Book1.subject &#x3D; &quot;Go 语言教程&quot;\n   Book1.book_id &#x3D; 6495407\n\n   &#x2F;* book 2 描述 *&#x2F;\n   Book2.title &#x3D; &quot;Python 教程&quot;\n   Book2.author &#x3D; &quot;www.runoob.com&quot;\n   Book2.subject &#x3D; &quot;Python 语言教程&quot;\n   Book2.book_id &#x3D; 6495700\n\n   &#x2F;* 打印 Book1 信息 *&#x2F;\n   printBook(&amp;Book1)\n\n   &#x2F;* 打印 Book2 信息 *&#x2F;\n   printBook(&amp;Book2)\n&#125;\nfunc printBook( book *Books ) &#123;\n   fmt.Printf( &quot;Book title : %s\\n&quot;, book.title)\n   fmt.Printf( &quot;Book author : %s\\n&quot;, book.author)\n   fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject)\n   fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id)\n&#125;</code></pre>\n\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><ul>\n<li>python 中也有切片，与 go 很像，又与 python 区别很大</li>\n</ul>\n<p>Go 语言切片是<code>对数组的抽象</code>。</p>\n<p>切片出现的原因：go 数组长度固定，不够灵活</p>\n<p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，<br>Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，<code>可以追加元素，在追加时可能使切片的容量增大</code>。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 方式1\nvar identifier []type\n&#x2F;&#x2F; 方式2 使用 make() 函数来创建切片\nvar slice1 []type &#x3D; make([]type, len)\n&#x2F;&#x2F; 方式3 也可以简写为\nslice1 :&#x3D; make([]type, len)</code></pre>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类 python</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 直接初始化切片，[] 表示是切片类型，&#123;1,2,3&#125; 初始化值依次是 1,2,3，其 cap&#x3D;len&#x3D;3。\ns :&#x3D;[] int &#123;1,2,3 &#125;\n\n&#x2F;&#x2F; 初始化切片 s，是数组 arr 的引用。\ns :&#x3D; arr[:]\n\n&#x2F;&#x2F; 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。\ns :&#x3D; arr[startIndex:endIndex] &#x2F;&#x2F; 左闭右开\n\n&#x2F;&#x2F; 默认 endIndex 时将表示一直到arr的最后一个元素。\ns :&#x3D; arr[startIndex:]\n\n&#x2F;&#x2F; 默认 startIndex 时将表示从 arr 的第一个元素开始。\ns :&#x3D; arr[:endIndex]\n\n&#x2F;&#x2F; 通过切片 s 初始化切片 s1。\ns1 :&#x3D; s[startIndex:endIndex]\n\n&#x2F;&#x2F; 通过内置函数 make() 初始化切片s，[]int 标识为其元素类型为 int 的切片。\ns :&#x3D;make([]int,len,cap)</code></pre>\n\n<h3 id=\"len-和-cap-函数\"><a href=\"#len-和-cap-函数\" class=\"headerlink\" title=\"len() 和 cap() 函数\"></a>len() 和 cap() 函数</h3><p><code>make([]T, length, capacity/*可选参数，容量*/)</code></p>\n<p>切片是可索引的，并且可以由 len() 方法获取长度。</p>\n<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 以下为具体实例：\n&#x2F;&#x2F; 实例\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var numbers &#x3D; make([]int,3&#x2F;**长度 *&#x2F;,5&#x2F;**容量 *&#x2F;)\n\n   printSlice(numbers)\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;\n&#x2F;&#x2F; 以上实例运行输出结果为:\n\nlen&#x3D;3 cap&#x3D;5 slice&#x3D;[0 0 0]</code></pre>\n\n<h3 id=\"空-nil-切片\"><a href=\"#空-nil-切片\" class=\"headerlink\" title=\"空(nil)切片\"></a>空(nil)切片</h3><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>\n<h3 id=\"切片截取\"><a href=\"#切片截取\" class=\"headerlink\" title=\"切片截取\"></a>切片截取</h3><p>注意点：切片声明时候赋值用<code>&#123;&#125;</code>，在切片赋值和打印时候都是数组<code>[item1,item2, ...]</code></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   &#x2F;* 创建切片 *&#x2F;\n   numbers :&#x3D; []int&#123;0,1,2,3,4,5,6,7,8&#125;\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;9 cap&#x3D;9 slice&#x3D;[0 1 2 3 4 5 6 7 8]\n\n   &#x2F;* 打印原始切片 *&#x2F;\n   fmt.Println(&quot;numbers &#x3D;&#x3D;&quot;, numbers) &#x2F;&#x2F; numbers &#x3D;&#x3D; [0 1 2 3 4 5 6 7 8]\n\n   &#x2F;* 打印子切片从索引1(包含) 到索引4(不包含)*&#x2F;\n   fmt.Println(&quot;numbers[1:4] &#x3D;&#x3D;&quot;, numbers[1:4]) &#x2F;&#x2F; numbers[1:4] &#x3D;&#x3D; [1 2 3]\n\n   &#x2F;* 默认下限为 0*&#x2F;\n   fmt.Println(&quot;numbers[:3] &#x3D;&#x3D;&quot;, numbers[:3]) &#x2F;&#x2F; numbers[:3] &#x3D;&#x3D; [0 1 2]\n\n   &#x2F;* 默认上限为 len(s)*&#x2F;\n   fmt.Println(&quot;numbers[4:] &#x3D;&#x3D;&quot;, numbers[4:]) &#x2F;&#x2F; numbers[4:] &#x3D;&#x3D; [4 5 6 7 8]\n\n   numbers1 :&#x3D; make([]int,0,5)\n   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;5 slice&#x3D;[]\n\n   &#x2F;* 打印子切片从索引  0(包含) 到索引 2(不包含) *&#x2F;\n   number2 :&#x3D; numbers[:2]\n   printSlice(number2) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;9 slice&#x3D;[0 1]\n\n   &#x2F;* 打印子切片从索引 2(包含) 到索引 5(不包含) *&#x2F;\n   number3 :&#x3D; numbers[2:5]\n   printSlice(number3) &#x2F;&#x2F; len&#x3D;3 cap&#x3D;7 slice&#x3D;[2 3 4]\n\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;</code></pre>\n\n<h3 id=\"append-和-copy-函数\"><a href=\"#append-和-copy-函数\" class=\"headerlink\" title=\"append() 和 copy() 函数\"></a>append() 和 copy() 函数</h3><p><strong>这个又何 python</strong>很像，python 中，有些申请的变量是不能更改的，更改操作是对原来的拷贝再处理过程</p>\n<p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>\n<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var numbers []int\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;0 slice&#x3D;[]\n\n   &#x2F;* 允许追加空切片 *&#x2F;\n   numbers &#x3D; append(numbers, 0)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;1 cap&#x3D;1 slice&#x3D;[0]\n\n   &#x2F;* 向切片添加一个元素 *&#x2F;\n   numbers &#x3D; append(numbers, 1)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;2 slice&#x3D;[0 1]\n\n   &#x2F;* 同时添加多个元素 *&#x2F;\n   numbers &#x3D; append(numbers, 2,3,4)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;6 slice&#x3D;[0 1 2 3 4]\n\n   &#x2F;* 创建切片 numbers1 是之前切片的两倍容量*&#x2F;\n   numbers1 :&#x3D; make([]int, len(numbers), (cap(numbers))*2)\n\n   &#x2F;* 拷贝 numbers 的内容到 numbers1 *&#x2F;\n   copy(numbers1,numbers)\n   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;12 slice&#x3D;[0 1 2 3 4]\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;\n</code></pre>\n\n<h2 id=\"Range\"><a href=\"#Range\" class=\"headerlink\" title=\"Range\"></a>Range</h2><p>注意： 这玩意和 python 很不一样，这个是标识符， python 的 range 是个函数</p>\n<p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素</p>\n<ul>\n<li><code>数组</code>和<code>切片</code>中它返回元素的索引和索引对应的值</li>\n<li>集合中返回 key-value 对</li>\n</ul>\n<h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>for 循环的 range 格式可以对 <code>slice</code>、<code>map</code>、<code>数组</code>、<code>字符串</code>等进行迭代循环。格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 语法1\nfor key, value :&#x3D; range oldMap &#123;\n    newMap[key] &#x3D; value\n&#125;\n&#x2F;&#x2F; 语法2\nfor key :&#x3D; range oldMap\n\n&#x2F;&#x2F; 语法3\nfor key, _ :&#x3D; range oldMap\n\n&#x2F;&#x2F; 语法4\nfor _, value :&#x3D; range oldMap</code></pre>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>go map 没有 javascript 那么多 api,简单来说就一个，那就是像对象一样赋值</p>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;* 声明变量，默认 map 是 nil *&#x2F;\nvar map_variable map[key_data_type]value_data_type\n\n&#x2F;* 使用 make 函数 *&#x2F;\nmap_variable :&#x3D; make(map[key_data_type]value_data_type)</code></pre>\n\n<h3 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    var countryCapitalMap map[string]string &#x2F;*创建集合 *&#x2F;\n    countryCapitalMap &#x3D; make(map[string]string)\n\n    &#x2F;* map插入key - value对,各个国家对应的首都 *&#x2F;\n    countryCapitalMap [ &quot;France&quot; ] &#x3D; &quot;巴黎&quot;\n    countryCapitalMap [ &quot;Italy&quot; ] &#x3D; &quot;罗马&quot;\n    countryCapitalMap [ &quot;Japan&quot; ] &#x3D; &quot;东京&quot;\n    countryCapitalMap [ &quot;India &quot; ] &#x3D; &quot;新德里&quot;\n\n    &#x2F;*使用键输出地图值 *&#x2F;\n    for country :&#x3D; range countryCapitalMap &#123;\n        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])\n    &#125;\n\n    &#x2F;*查看元素在集合中是否存在 *&#x2F;\n    capital, ok :&#x3D; countryCapitalMap [ &quot;American&quot; ] &#x2F;*如果确定是真实的,则存在,否则不存在 *&#x2F;\n    &#x2F;*fmt.Println(capital) *&#x2F;\n    &#x2F;*fmt.Println(ok) *&#x2F;\n    if (ok) &#123;\n        fmt.Println(&quot;American 的首都是&quot;, capital)\n    &#125; else &#123;\n        fmt.Println(&quot;American 的首都不存在&quot;)\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><p>go map 删除元素用的是 delete 方法</p>\n<p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">delete(countryCapitalMap, &quot;France&quot;)</code></pre>\n\n<h3 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n        &#x2F;* 创建map *&#x2F;\n        countryCapitalMap :&#x3D; map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;\n\n        fmt.Println(&quot;原始地图&quot;)\n\n        &#x2F;* 打印地图 *&#x2F;\n        for country :&#x3D; range countryCapitalMap &#123;\n                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])\n        &#125;\n\n        &#x2F;*删除元素*&#x2F; delete(countryCapitalMap, &quot;France&quot;)\n        fmt.Println(&quot;法国条目被删除&quot;)\n\n        fmt.Println(&quot;删除元素后地图&quot;)\n\n        &#x2F;*打印地图*&#x2F;\n        for country :&#x3D; range countryCapitalMap &#123;\n                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])\n        &#125;\n&#125;</code></pre>\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type_name(expression) &#x2F;&#x2F; type_name 为类型，expression 为表达式。</code></pre>\n\n<h3 id=\"example-4\"><a href=\"#example-4\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var sum int &#x3D; 17\n   var count int &#x3D; 5\n   var mean float32\n\n   mean &#x3D; float32(sum)&#x2F;float32(count) &#x2F;&#x2F; 这里\n   fmt.Printf(&quot;mean 的值为: %f\\n&quot;,mean)\n&#125;</code></pre>\n\n<h2 id=\"接口-interface\"><a href=\"#接口-interface\" class=\"headerlink\" title=\"接口 interface\"></a>接口 interface</h2><p>Go 语言提供了另外一种数据类型即接口，它<strong>把所有的具有共性的方法定义在一起</strong>，任何<strong>其他类型只要实现了这些方法就是实现了这个接口</strong>。</p>\n<h3 id=\"语法-5\"><a href=\"#语法-5\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;* 定义接口 *&#x2F;\ntype interface_name interface &#123;\n   method_name1 [return_type]\n   method_name2 [return_type]\n   method_name3 [return_type]\n   ...\n   method_namen [return_type]\n&#125;\n\n&#x2F;* 定义结构体 *&#x2F;\ntype struct_name struct &#123;\n   &#x2F;* variables *&#x2F;\n&#125;\n\n&#x2F;* 实现接口方法 *&#x2F;\nfunc (struct_name_variable struct_name) method_name1() [return_type] &#123;\n   &#x2F;* 方法实现 *&#x2F;\n&#125;\n...\nfunc (struct_name_variable struct_name) method_namen() [return_type] &#123;\n   &#x2F;* 方法实现*&#x2F;\n&#125;</code></pre>\n\n<h3 id=\"example-5\"><a href=\"#example-5\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n)\n\ntype Phone interface &#123;\n    call()\n&#125;\n\ntype NokiaPhone struct &#123;\n&#125;\n\nfunc (nokiaPhone NokiaPhone) &#x2F;**前面这块 *&#x2F;call() &#123;\n    fmt.Println(&quot;I am Nokia, I can call you!&quot;)\n&#125;\n\ntype IPhone struct &#123;\n&#125;\n\nfunc (iPhone IPhone)&#x2F;**前面这块 *&#x2F; call() &#123;\n    fmt.Println(&quot;I am iPhone, I can call you!&quot;)\n&#125;\n\nfunc main() &#123;\n    var phone Phone &#x2F;&#x2F; interface 类型变量\n    &#x2F;&#x2F; 我本以为没有new 关键字，原来有啊\n    &#x2F;&#x2F; 不明白这里为什么 NokiaPhone的实例可以赋值给 phone，原因：**其他类型只要实现了这些方法就是实现了这个接口**\n    phone &#x3D; new(NokiaPhone)\n    phone.call()\n\n    phone &#x3D; new(IPhone)\n    phone.call()\n\n&#125;\n</code></pre>\n\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p><strong>通过内置的错误接口提供了非常简单的错误处理机制。</strong></p>\n<h3 id=\"语法-6\"><a href=\"#语法-6\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>error 类型是一个接口类型，这是它的定义：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type error interface &#123;\n  Error() string\n&#125;\n</code></pre>\n\n<p>我们可以在编码中<strong>通过实现 error 接口类型来生成错误信息</strong>。</p>\n<p>函数通常在最后的返回值中返回错误信息。<strong>使用 errors.New 可返回一个错误信息</strong>：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func Sqrt(f float64) (float64, error) &#123;\n    if f &lt; 0 &#123;\n        return 0, errors.New(&quot;math: square root of negative number&quot;)\n    &#125;\n    &#x2F;&#x2F; 实现\n&#125;</code></pre>\n\n<h3 id=\"example-6\"><a href=\"#example-6\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n)\n\n&#x2F;&#x2F; 定义一个 DivideError 结构\n&#x2F;&#x2F; 定义 xxx 结构体\ntype DivideError struct &#123;\n    dividee int\n    divider int\n&#125;\n\n&#x2F;&#x2F; 实现 &#96;error&#96; 接口\nfunc (de *DivideError&#x2F;**指针 *&#x2F;) Error() string &#123;\n    strFormat :&#x3D; &#96;\n    Cannot proceed, the divider is zero.\n    dividee: %d\n    divider: 0\n&#96;\n&#x2F;&#x2F; fmt.Sprintf这个api, 有点面熟，先定义模版，再替换模版中的变量值\n    return fmt.Sprintf(strFormat, de.dividee)\n&#125;\n\n&#x2F;&#x2F; 定义 &#96;int&#96; 类型除法运算的函数\nfunc Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;\n    if varDivider &#x3D;&#x3D; 0 &#123;\n        &#x2F;&#x2F; 结构体\n        dData :&#x3D; DivideError &#123;\n                dividee: varDividee,\n                divider: varDivider,\n        &#125;\n        &#x2F;&#x2F; 定义了一个结构体，直接调用结构体的方法，这也太直接了吧？\n        errorMsg &#x3D; dData.Error()\n        return\n    &#125; else &#123;\n        return varDividee &#x2F; varDivider, &quot;&quot;\n    &#125;\n\n&#125;\n\nfunc main() &#123;\n\n    &#x2F;&#x2F; 正常情况\n    &#x2F;** :&#x3D; 前面两个、后面两个，分别赋值 *&#x2F;\n    &#x2F;&#x2F; result 有值，执行if内容\n    if result, errorMsg :&#x3D; Divide(100, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;\n            fmt.Println(&quot;100&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 100&#x2F;10 &#x3D;  10\n    &#125;\n    &#x2F;&#x2F; result 为 0 ,执行if内容打印了\n    if result, errorMsg :&#x3D; Divide(0, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;\n      fmt.Println(&quot;0&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 0&#x2F;10 &#x3D;  0\n    &#125;\n\n    &#x2F;&#x2F; 当除数为零的时候会返回错误信息\n    &#x2F;&#x2F; errorMsg 有值，执行if内容\n    if _, errorMsg :&#x3D; Divide(100, 0); errorMsg !&#x3D; &quot;&quot; &#123;\n            fmt.Println(&quot;errorMsg is: &quot;, errorMsg)\n    &#x2F;&#x2F; errorMsg is:\n    &#x2F;&#x2F;   Cannot proceed, the divider is zero.\n    &#x2F;&#x2F;   dividee: 100\n    &#x2F;&#x2F;   divider: 0\n    &#x2F;&#x2F; 这个返回有点意思，前面格式化错误打印，第一个变量是通过 &#96;&#96;运算得来的，和javascript 有点类似，原样的格式输出\n    &#125;\n\n&#125;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202210151324359.png\" />\n\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><p>go 支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>\n<p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>\n<h3 id=\"语法-7\"><a href=\"#语法-7\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">go 函数名( 参数列表 )</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 例如：\n\ngo f(x, y, z)\n&#x2F;&#x2F; 开启一个新的 goroutine:f(x, y, z)\n</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，\n&#x2F;&#x2F; 以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。\n\npackage main\n\nimport (\n        &quot;fmt&quot;\n        &quot;time&quot;\n)\n\nfunc say(s string) &#123;\n        for i :&#x3D; 0; i &lt; 5; i++ &#123;\n                time.Sleep(100 * time.Millisecond)\n                fmt.Println(s)\n        &#125;\n&#125;\n\nfunc main() &#123;\n        go say(&quot;world&quot;)\n        say(&quot;hello&quot;)\n&#125;\n\n&#x2F;&#x2F; 执行以上代码，你会看到输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行：\n\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello</code></pre>\n\n<h3 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h3><p>用来：打通 goroutine，进行数据传输的</p>\n<p>通道（channel）<strong>是用来传递数据的一个数据结构</strong>。</p>\n<p>通道可用于<strong>两个 goroutine 之间</strong>通过传递一个指定类型的值来<strong>同步运行和通讯</strong>。操作符<code>&lt;-</code> 用于指定通道的方向，发送或接收。</p>\n<p><strong>如果未指定方向，则为双向通道。</strong></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch\nv :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据\n           &#x2F;&#x2F; 并把值赋给 v\n&#x2F;&#x2F; 声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：\n\nch :&#x3D; make(chan int)</code></pre>\n\n<p>注意：默认情况下，<strong>通道是不带缓冲区的</strong>。发送端发送数据，同时<strong>必须有接收端</strong>相应的接收数据。</p>\n<p>以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：</p>\n<h3 id=\"example-7\"><a href=\"#example-7\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc sum(s []int, c chan int) &#123;\n        sum :&#x3D; 0\n        for _, v :&#x3D; range s &#123;\n                sum +&#x3D; v\n        &#125;\n        c &lt;- sum &#x2F;&#x2F; 把 sum 发送到通道 c\n&#125;\n\nfunc main() &#123;\n        s :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;\n\n        c :&#x3D; make(chan int)\n        go sum(s[:len(s)&#x2F;2], c) &#x2F;&#x2F; s[:len(s)&#x2F;2] [ -9, 4, 0]\n        go sum(s[len(s)&#x2F;2:], c) &#x2F;&#x2F; s[len(s)&#x2F;2:] [7, 2, 8]\n        x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收\n\n        fmt.Println(x, y, x+y)\n\n        &#x2F;&#x2F; -5 17 12\n&#125;\n\n</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202210151346664.png\" />\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 小改下\nfunc main() &#123;\n\ts :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;\n\n    c :&#x3D; make(chan int)\n    go sum(s[:len(s)&#x2F;2], c)\n    go sum(s[len(s)&#x2F;2:], c)\n\n    &#x2F;&#x2F; 下面这两个比goroutine先执行\n    fmt.Println(&quot;c&quot;)\n    fmt.Println(c)\n\n    x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收\n\n    a :&#x3D; &lt;-c &#x2F;&#x2F; 这里会报错\n\n    fmt.Println(a)\n\n    fmt.Println(x, y, x+y)\n\n&#125;\n\n&#x2F;&#x2F; c\n&#x2F;&#x2F; 0xc00006e060\n&#x2F;&#x2F; [-9 4 0]\n&#x2F;&#x2F; [7 2 8]\n&#x2F;&#x2F; fatal error: all goroutines are asleep - deadlock!\n\n&#x2F;&#x2F; goroutine 1 [chan receive]:\n&#x2F;&#x2F; main.main()\n&#x2F;&#x2F; &#x2F;tmp&#x2F;sandbox2040469662&#x2F;prog.go:26 +0x249\n\n&#x2F;&#x2F; Program exited.\n</code></pre>\n\n<h3 id=\"通道缓冲区\"><a href=\"#通道缓冲区\" class=\"headerlink\" title=\"通道缓冲区\"></a>通道缓冲区</h3><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">ch :&#x3D; make(chan int, 100)</code></pre>\n\n<p><strong>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态</strong>，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>\n<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则<strong>缓冲区一满，数据发送端就无法再发送数据了</strong>。</p>\n<p>注意：</p>\n<ul>\n<li>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。</li>\n<li>如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；</li>\n<li>如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n&#x2F;&#x2F; 这里我们定义了一个可以存储整数类型的带缓冲通道\n&#x2F;&#x2F; 缓冲区大小为2\n  ch :&#x3D; make(chan int, 2)\n\n  &#x2F;&#x2F; 因为 ch 是带缓冲的通道，我们可以同时发送两个数据\n  &#x2F;&#x2F; 而不用立刻需要去同步读取数据\n  ch &lt;- 1\n  ch &lt;- 2\n\n  &#x2F;&#x2F; 获取这两个数据\n  fmt.Println(&lt;-ch)\n  fmt.Println(&lt;-ch)\n\n&#x2F;&#x2F; 执行输出结果为：\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#125;\n</code></pre>\n\n<h2 id=\"Go-遍历通道与关闭通道\"><a href=\"#Go-遍历通道与关闭通道\" class=\"headerlink\" title=\"Go 遍历通道与关闭通道\"></a>Go 遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p>\n<h3 id=\"语法-8\"><a href=\"#语法-8\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">v, ok :&#x3D; &lt;-ch\n</code></pre>\n\n<h3 id=\"example-8\"><a href=\"#example-8\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n        &quot;fmt&quot;\n)\n\nfunc fibonacci(n int, c chan int) &#123;\n        x, y :&#x3D; 0, 1\n        for i :&#x3D; 0; i &lt; n; i++ &#123;\n                c &lt;- x\n                x, y &#x3D; y, x+y\n        &#125;\n        close(c)\n&#125;\n\nfunc main() &#123;\n        c :&#x3D; make(chan int, 10)\n        go fibonacci(cap(c), c)\n        &#x2F;&#x2F; range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个\n        &#x2F;&#x2F; 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据\n        &#x2F;&#x2F; 之后就结束了。\n        &#x2F;&#x2F; 如果上面的 c 通道不关闭，那么 range 函数就不会结束，从而在接收第 11 个数据的时候就阻塞了。\n        for i :&#x3D; range c &#123;\n                fmt.Println(i)\n        &#125;\n&#125;\n\n&#x2F;&#x2F; 执行输出结果为：\n\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 5\n&#x2F;&#x2F; 8\n&#x2F;&#x2F; 13\n&#x2F;&#x2F; 21\n&#x2F;&#x2F; 34\n</code></pre>\n\n<p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>\n<h3 id=\"example-不关闭\"><a href=\"#example-不关闭\" class=\"headerlink\" title=\"example 不关闭\"></a>example 不关闭</h3><img src=\"http://t-blog-images.aijs.top/img/202210151355250.png\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fatal error: all goroutines are asleep - deadlock!</code></pre>\n\n<h3 id=\"模块中大写\"><a href=\"#模块中大写\" class=\"headerlink\" title=\"模块中大写\"></a>模块中大写</h3><p><a href=\"https://go.dev/doc/code#:~:text=Because%20our%20ReverseRunes%20function%20begins%20with%20an%20upper%2Dcase%20letter%2C%20it%20is%20exported%2C%20and%20can%20be%20used%20in%20other%20packages%20that%20import%20our%20morestrings%20package.\" target=\"_blank\" >见</a></p>\n<p>模块中大些的函数是被导出。</p>\n<ul>\n<li>缓存，取代产生文件</li>\n<li>绝对路径导入使用 <code>import ( &quot;packagepath&quot;)</code></li>\n<li>安装<code>go install packagepath</code></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.runoob.com/go/go-ide.html\" target=\"_blank\" >runoob</a></p>\n<p><a href=\"https://golang.google.cn/play/\" target=\"_blank\" >golang play</a></p>\n<p><a href=\"https://github.com/gin-gonic/gin\" target=\"_blank\" >gin-gonic&#x2F;gin</a></p>\n<p><a href=\"https://golang.google.cn/doc/tutorial/web-service-gin\" target=\"_blank\" >Tutorial: Developing a RESTful API with Go and Gin</a></p>\n<h2 id=\"博客收录\"><a href=\"#博客收录\" class=\"headerlink\" title=\"博客收录\"></a>博客收录</h2><p><a href=\"https://learnku.com/docs/the-way-to-go/if-else-structure/3592\" target=\"_blank\" >这个文档比较好</a></p>\n<p><a href=\"https://pkg.go.dev/\" target=\"_blank\" >https://pkg.go.dev/</a></p>\n<h2 id=\"待看\"><a href=\"#待看\" class=\"headerlink\" title=\"待看\"></a>待看</h2><p><a href=\"https://www.bilibili.com/video/BV1ZJ411W7jG/\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://github.com/golang/go/wiki/NonEnglish\" target=\"_blank\" >NonEnglish 文档</a><br><a href=\"https://go-zh.org/doc/\" target=\"_blank\" >go 中文文档</a><br><a href=\"https://www.topgoer.com/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/fmt.html\" target=\"_blank\" >中文文档</a></p>\n","text":"走心建议尽量早一点的进入这些新技术，而不是等待这些技术成熟之后再进入。原因有这么几个: 技术的发展过程非常重要。因为你可以清楚地看到这些新技术的生态圈发展过程，让我们收获最大的往往不是这些技术本身，而是一个技术的变现和行业的发展 从中我们可以看到非常具体的各种思潮和思路，这些东西...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"Go","slug":"Go","count":5,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":5,"path":"api/tags/Go.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%B0%E5%BF%83\"><span class=\"toc-text\">走心</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%F0%9F%A4%94\"><span class=\"toc-text\">🤔</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-go\"><span class=\"toc-text\">下载安装 go</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Tour-%E6%95%99%E7%A8%8B\"><span class=\"toc-text\">Tour 教程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">命名返回</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#If\"><span class=\"toc-text\">If</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">基本操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D\"><span class=\"toc-text\">:&#x3D;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%AE%9A\"><span class=\"toc-text\">长度不定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">指定索引赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD\"><span class=\"toc-text\">自动推断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">多维数组语法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88\"><span class=\"toc-text\">指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88\"><span class=\"toc-text\">指针的指针</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">结构体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88\"><span class=\"toc-text\">结构体指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-1\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87\"><span class=\"toc-text\">切片</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-1\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#len-%E5%92%8C-cap-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">len() 和 cap() 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA-nil-%E5%88%87%E7%89%87\"><span class=\"toc-text\">空(nil)切片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E6%88%AA%E5%8F%96\"><span class=\"toc-text\">切片截取</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#append-%E5%92%8C-copy-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">append() 和 copy() 函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Range\"><span class=\"toc-text\">Range</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-2\"><span class=\"toc-text\">语法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-3\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-2\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#delete\"><span class=\"toc-text\">delete</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-3\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">类型转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-4\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-4\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3-interface\"><span class=\"toc-text\">接口 interface</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-5\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-5\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">错误处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-6\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-6\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">并发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-7\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93\"><span class=\"toc-text\">通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-7\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">通道缓冲区</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Go-%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93%E4%B8%8E%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93\"><span class=\"toc-text\">Go 遍历通道与关闭通道</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-8\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-8\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-%E4%B8%8D%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">example 不关闭</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%A4%A7%E5%86%99\"><span class=\"toc-text\">模块中大写</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95\"><span class=\"toc-text\">博客收录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%85%E7%9C%8B\"><span class=\"toc-text\">待看</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Go Gin","uid":"b21d66657c866de8629862fe6f5e2c48","slug":"2022-10-15gin","date":"2022-10-15T06:57:18.000Z","updated":"2022-10-17T11:18:29.863Z","comments":true,"path":"api/articles/2022-10-15gin.json","keywords":null,"cover":[],"text":"背景 巩固 go 语言学习 听说很多大公司用 go 来开发服务器，我特来看看 了解 go web 开发 Gin选这个框架原因如下： 社区活跃 Go 官网推荐Tutorial: Developing a RESTful API with Go and Gin github 上 st...","link":"","photos":[],"count_time":{"symbolsCount":"49k","symbolsTime":"44 mins."},"categories":[{"name":"Go","slug":"Go","count":5,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":5,"path":"api/tags/Go.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"nextjs useSearchParams","uid":"9a1d323e88658104fe9c4ac04b72ebe7","slug":"2022-10-14useSearchParams","date":"2022-10-14T08:57:11.000Z","updated":"2022-10-17T11:18:29.861Z","comments":true,"path":"api/articles/2022-10-14useSearchParams.json","keywords":null,"cover":[],"text":"背景需求 列表切换详情，返回列表，要求查询表单参数不丢失， 思路 记录参数到 url 上，在记录的过程中，列表页面不刷新 返回时候列表页只作为一个 history 栈中的一个记录 MDN 直接点：history.replaceState history.replaceState ...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"React","slug":"React","count":26,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":20,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}