{"title":"Go 语言 特殊语法","uid":"cc6337a39cba986d99843e70d56686e5","slug":"2022-10-15go","date":"2022-10-15T01:54:03.000Z","updated":"2022-12-22T13:36:21.788Z","comments":true,"path":"api/articles/2022-10-15go.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202212211225570.webp","content":"<h2 id=\"目前所遇到最好的教程\"><a href=\"#目前所遇到最好的教程\" class=\"headerlink\" title=\"目前所遇到最好的教程\"></a>目前所遇到最好的教程</h2><p><a href=\"https://www.topgoer.com/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E7%A8%8B%E5%BA%8F.html\" target=\"_blank\" >go 教程</a></p>\n<p><a href=\"https://studygolang.com/pkgdoc\" target=\"_blank\" >https://studygolang.com/pkgdoc</a></p>\n<h2 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h2><!-- <img src=\"http://t-blog-images.aijs.top/img/202210220808678.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222111407.jpg\" />\n\n<h2 id=\"下载安装-go\"><a href=\"#下载安装-go\" class=\"headerlink\" title=\"下载安装 go\"></a>下载安装 go</h2><p><a href=\"https://golang.google.cn/doc/install\" target=\"_blank\" >官方安装包地址</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ go version\ngo version go1.19.2 darwin&#x2F;amd64\n</code></pre>\n\n<h2 id=\"Tour-教程\"><a href=\"#Tour-教程\" class=\"headerlink\" title=\"Tour 教程\"></a>Tour 教程</h2><p>之前没找到到这文档，看了菜鸟教程的 go，傻白白地以为没教程</p>\n<p><a href=\"https://tour.go-zh.org/welcome/1\" target=\"_blank\" >https://tour.go-zh.org/welcome/1</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202210180958616.webp\" />\n \n<h3 id=\"命名返回\"><a href=\"#命名返回\" class=\"headerlink\" title=\"命名返回\"></a>命名返回</h3><p><a href=\"https://tour.go-zh.org/basics/7\" target=\"_blank\" >见</a></p>\n<p><strong>实现</strong></p>\n<ul>\n<li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</li>\n<li>没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。</li>\n</ul>\n<p><strong>功能</strong></p>\n<ul>\n<li>返回值的名称应当具有一定的意义，它可以作为文档使用。</li>\n</ul>\n<p><strong>优缺点：</strong><br>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><!-- <img src=\"http://t-blog-images.aijs.top/img/202210220851614.png\" /> -->\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 返回多个返回值，有形参名称的\nfunc foo3(a string, b int) (r1 int, r2 int) &#123;\n\tfmt.Println(&quot;----foo3 ----&quot;)\n\tfmt.Println(&quot;a &#x3D;&quot;, a)\n\tfmt.Println(&quot;b &#x3D;&quot;, b)\n\t&#x2F;&#x2F; r1r2属于foo3的形参，初始化默认的值是0\n\t&#x2F;&#x2F; r1r2作用域空间是foo3整个函数体的&#123;&#125;空间\n\tfmt.Println(&quot;r1 &#x3D;&quot;, r1)\n\tfmt.Println(&quot;r2 &quot;, r2)\n\t&#x2F;&#x2F; 给有名称的返回值变量赋值\n\tr1 &#x3D; 1000\n\tr2 &#x3D; 2000\n\treturn\n&#125;\n\n</code></pre>\n\n<h2 id=\"If\"><a href=\"#If\" class=\"headerlink\" title=\"If\"></a>If</h2><p>if 的简短语句<br>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。</p>\n<p>if 和 else<br>在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;math&quot;\n)\n\nfunc pow(x, n, lim float64) float64 &#123;\n\tif v :&#x3D; math.Pow(x, n); v &lt; lim &#123;\n\t\treturn v\n\t&#125; else &#123;\n\t\tfmt.Printf(&quot;%g &gt;&#x3D; %g\\n&quot;, v, lim)\n\t&#125;\n\t&#x2F;&#x2F; 这里开始就不能使用 v 了\n\treturn lim\n&#125;\n\nfunc main() &#123;\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n&#125;\n</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">if initialization; condition &#123;\n    &#x2F;&#x2F; do something\n&#125;\n\n&#x2F;&#x2F; 例如:\n\nval :&#x3D; 10\nif val &gt; max &#123;\n    &#x2F;&#x2F; do something\n&#125;\n&#x2F;&#x2F; 你也可以这样写:\n\nif val :&#x3D; 10; val &gt; max &#123;\n    &#x2F;&#x2F; do something\n&#125;\n\n&#x2F;&#x2F; ————————————————\n&#x2F;&#x2F; 原文作者：Go 技术论坛文档：《Go 入门指南（）》\n&#x2F;&#x2F; 转自链接：https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;the-way-to-go&#x2F;if-else-structure&#x2F;3592\n&#x2F;&#x2F; 版权声明：翻译文档著作权归译者和 LearnKu 社区所有。转载请保留原文链接\n</code></pre>\n\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><p>switch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>\n<h3 id=\"与众不同\"><a href=\"#与众不同\" class=\"headerlink\" title=\"与众不同\"></a>与众不同</h3><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。<br><em>实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。</em><br>除非以 <em>fallthrough 语句结束，否则分支会自动终止</em> Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>\n<h3 id=\"switch-的求值顺序\"><a href=\"#switch-的求值顺序\" class=\"headerlink\" title=\"switch 的求值顺序\"></a>switch 的求值顺序</h3><p>switch 的求值顺序<br>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; （例如，\n\nswitch i &#123;\ncase 0:\ncase f():\n&#125;\n&#x2F;&#x2F; 在 i&#x3D;&#x3D;0 时 f 不会被调用。）</code></pre>\n\n<h3 id=\"没有条件的-switch\"><a href=\"#没有条件的-switch\" class=\"headerlink\" title=\"没有条件的 switch\"></a>没有条件的 switch</h3><p>没有条件的 switch 同 switch true 一样。</p>\n<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202210201608273.webp\" />\n\n<h2 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h2><h3 id=\"推迟到外函数执行\"><a href=\"#推迟到外函数执行\" class=\"headerlink\" title=\"推迟到外函数执行\"></a>推迟到外函数执行</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; defer\n&#x2F;&#x2F; defer 语句会将函数推迟到外层函数返回之后执行。\n&#x2F;&#x2F; 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tdefer fmt.Println(&quot;world&quot;)\n\n\tfmt.Println(&quot;hello&quot;)\n&#125;\n\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world</code></pre>\n\n<p>哦～原来如此，<code>defer db.Close()</code></p>\n<h3 id=\"执行推迟时候，出栈\"><a href=\"#执行推迟时候，出栈\" class=\"headerlink\" title=\"执行推迟时候，出栈\"></a>执行推迟时候，出栈</h3><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>数组是<code>具有相同唯一类型</code>的一组<code>已编号且长度固定</code>的数据项序列，这种类型可以是任意的<code>原始类型</code>例如整型、字符串或者<code>自定义类型</code></p>\n<p>语法：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var variable_name [SIZE] variable_type</code></pre>\n\n<p><strong>数组初始化</strong></p>\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; [] 被用于限定大小，&#123;&#125; 用于内容，与其他语言不同\nvar balance &#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></pre>\n\n<h3 id=\"x3D\"><a href=\"#x3D\" class=\"headerlink\" title=\":&#x3D;\"></a>:&#x3D;</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 我们也可以通过字面量在声明数组的同时快速初始化数组：\nbalance :&#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; &#x2F;&#x2F; :&#x3D; 声明赋值运算符</code></pre>\n\n<h3 id=\"长度不定\"><a href=\"#长度不定\" class=\"headerlink\" title=\"长度不定\"></a>长度不定</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 如果数组长度不确定，可以使用 ... 代替数组的长度，\n&#x2F;&#x2F; 编译器会根据元素个数自行推断数组的长度：\nvar balance &#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F; 或\nbalance :&#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F; 如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</code></pre>\n\n<h3 id=\"指定索引赋值\"><a href=\"#指定索引赋值\" class=\"headerlink\" title=\"指定索引赋值\"></a>指定索引赋值</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 将索引为 1 和 3 的元素初始化\nbalance :&#x3D; [5]float32&#123;1:2.0,3:7.0&#125;\n&#x2F;&#x2F; 初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。</code></pre>\n\n<h3 id=\"自动推断\"><a href=\"#自动推断\" class=\"headerlink\" title=\"自动推断\"></a>自动推断</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：\n\nbalance[4] &#x3D; 50.0\n</code></pre>\n\n<h3 id=\"多维数组语法\"><a href=\"#多维数组语法\" class=\"headerlink\" title=\"多维数组语法\"></a>多维数组语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    &#x2F;&#x2F; Step 1: 创建数组\n    values :&#x3D; [][]int&#123;&#125; &#x2F;&#x2F; 这里要注意下，目前见到的例子都是空值初始化\n\n    &#x2F;&#x2F; Step 2: 使用 append() 函数向空的二维数组添加两行一维数组\n    row1 :&#x3D; []int&#123;1, 2, 3&#125;\n    row2 :&#x3D; []int&#123;4, 5, 6&#125;\n    values &#x3D; append(values, row1)\n    values &#x3D; append(values, row2)\n\n    &#x2F;&#x2F; Step 3: 显示两行数据\n    fmt.Println(&quot;Row 1&quot;)\n    fmt.Println(values[0])\n    fmt.Println(&quot;Row 2&quot;)\n    fmt.Println(values[1])\n\n    &#x2F;&#x2F; Step 4: 访问第一个元素\n    fmt.Println(&quot;第一个元素为：&quot;)\n    fmt.Println(values[0][0])\n&#125;\n</code></pre>\n\n<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><h3 id=\"指针的指针\"><a href=\"#指针的指针\" class=\"headerlink\" title=\"指针的指针\"></a>指针的指针</h3><p><strong>指向指针的指针</strong><br>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p>\n<p>当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</p>\n<p>指向指针的指针变量声明格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var ptr **int;\n</code></pre>\n\n<p><strong>例子：</strong></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\n   var a int\n   var ptr *int\n   var pptr **int\n\n   a &#x3D; 3000\n\n   &#x2F;* 指针 ptr 地址 *&#x2F;\n   ptr &#x3D; &amp;a\n\n   &#x2F;* 指向指针 ptr 地址 *&#x2F;\n   pptr &#x3D; &amp;ptr\n\n   &#x2F;* 获取 pptr 的值 *&#x2F;\n   fmt.Printf(&quot;变量 a &#x3D; %d\\n&quot;, a )\n   fmt.Printf(&quot;指针变量 *ptr &#x3D; %d\\n&quot;, *ptr )\n   fmt.Printf(&quot;指向指针的指针变量 **pptr &#x3D; %d\\n&quot;, **pptr)\n&#125;\n</code></pre>\n\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><ul>\n<li><p>其他语言对比：go 语言保留了，OC 中的结构体？可以理解为类的另一种写法</p>\n</li>\n<li><p>自身数组区别：Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>\n</li>\n<li><p>构造函数有没有联系：我在想：结构体里的<code>构</code>是不是，构造函数的 <code>构</code></p>\n</li>\n</ul>\n<p>函数传值：传值：直接结构体生成的变量，传引用：变量前<code>*</code> <code>*user</code></p>\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210221329044.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222110201.jpg\" />\n\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210221336286.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222124574.jpg\" />\n\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210221336095.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222124989.jpg\" />\n\n<h3 id=\"结构体继承\"><a href=\"#结构体继承\" class=\"headerlink\" title=\"结构体继承\"></a>结构体继承</h3><p><strong>子类实现</strong></p>\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210221425432.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222124349.jpg\" />\n\n<p><strong>实例化</strong></p>\n<p>两种赋值方式， 第一种没见过吧，～～</p>\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210221425435.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222125092.jpg\" />\n\n<h2 id=\"万能类型-与-断言\"><a href=\"#万能类型-与-断言\" class=\"headerlink\" title=\"万能类型 与 断言\"></a>万能类型 与 断言</h2><!-- <img src=\"http://t-blog-images.aijs.top/img/202210221504291.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222125112.jpg\" />\n\n<h2 id=\"大小写\"><a href=\"#大小写\" class=\"headerlink\" title=\"大小写\"></a>大小写</h2><!-- <img src=\"http://t-blog-images.aijs.top/img/202210221335053.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222123797.jpg\" />\n\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 结构体定义需要使用 type 和 struct 语句。\n&#x2F;&#x2F; struct 语句定义一个新的数据类型，结构体中有一个或多个成员。\n&#x2F;&#x2F; type 语句设定了结构体的名称。结构体的格式如下：\n\ntype struct_variable_type struct &#123;\n   member definition\n   member definition\n   ...\n   member definition\n&#125;</code></pre>\n\n<p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">variable_name :&#x3D; structure_variable_type &#123;value1, value2...valuen&#125;\n或\nvariable_name :&#x3D; structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</code></pre>\n\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n\n    &#x2F;&#x2F; 创建一个新的结构体\n    fmt.Println(Books&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)\n\n    &#x2F;&#x2F; 也可以使用 key &#x3D;&gt; value 格式\n    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;, subject: &quot;Go 语言教程&quot;, book_id: 6495407&#125;)\n\n    &#x2F;&#x2F; 忽略的字段为 0 或 空\n   fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;&#125;)\n&#125;</code></pre>\n\n<h3 id=\"结构体指针\"><a href=\"#结构体指针\" class=\"headerlink\" title=\"结构体指针\"></a>结构体指针</h3><p>你可以定义<code>指向结构体的指针类似于其他指针变量</code>，格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var struct_pointer *Books\n\n&#x2F;&#x2F; 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：\nstruct_pointer &#x3D; &amp;Book1\n\n&#x2F;&#x2F; 使用结构体指针访问结构体成员，使用 &quot;.&quot; 操作符：\nstruct_pointer.title</code></pre>\n\n<h3 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">\npackage main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n   var Book1 Books        &#x2F;* 声明 Book1 为 Books 类型 *&#x2F;\n   var Book2 Books        &#x2F;* 声明 Book2 为 Books 类型 *&#x2F;\n\n   &#x2F;* book 1 描述 *&#x2F;\n   Book1.title &#x3D; &quot;Go 语言&quot;\n   Book1.author &#x3D; &quot;www.runoob.com&quot;\n   Book1.subject &#x3D; &quot;Go 语言教程&quot;\n   Book1.book_id &#x3D; 6495407\n\n   &#x2F;* book 2 描述 *&#x2F;\n   Book2.title &#x3D; &quot;Python 教程&quot;\n   Book2.author &#x3D; &quot;www.runoob.com&quot;\n   Book2.subject &#x3D; &quot;Python 语言教程&quot;\n   Book2.book_id &#x3D; 6495700\n\n   &#x2F;* 打印 Book1 信息 *&#x2F;\n   printBook(&amp;Book1)\n\n   &#x2F;* 打印 Book2 信息 *&#x2F;\n   printBook(&amp;Book2)\n&#125;\nfunc printBook( book *Books ) &#123;\n   fmt.Printf( &quot;Book title : %s\\n&quot;, book.title)\n   fmt.Printf( &quot;Book author : %s\\n&quot;, book.author)\n   fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject)\n   fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id)\n&#125;</code></pre>\n\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><ul>\n<li>python 中也有切片，与 go 很像，又与 python 区别很大</li>\n</ul>\n<p>Go 语言切片是<code>对数组的抽象</code>。</p>\n<p>切片出现的原因：go 数组长度固定，不够灵活</p>\n<p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，<br>Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，<code>可以追加元素，在追加时可能使切片的容量增大</code>。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 方式1\nvar identifier []type\n&#x2F;&#x2F; 方式2 使用 make() 函数来创建切片\nvar slice1 []type &#x3D; make([]type, len)\n&#x2F;&#x2F; 方式3 也可以简写为\nslice1 :&#x3D; make([]type, len)</code></pre>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类 python</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 直接初始化切片，[] 表示是切片类型，&#123;1,2,3&#125; 初始化值依次是 1,2,3，其 cap&#x3D;len&#x3D;3。\ns :&#x3D;[] int &#123;1,2,3 &#125;\n\n&#x2F;&#x2F; 初始化切片 s，是数组 arr 的引用。\ns :&#x3D; arr[:]\n\n&#x2F;&#x2F; 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。\ns :&#x3D; arr[startIndex:endIndex] &#x2F;&#x2F; 左闭右开\n\n&#x2F;&#x2F; 默认 endIndex 时将表示一直到arr的最后一个元素。\ns :&#x3D; arr[startIndex:]\n\n&#x2F;&#x2F; 默认 startIndex 时将表示从 arr 的第一个元素开始。\ns :&#x3D; arr[:endIndex]\n\n&#x2F;&#x2F; 通过切片 s 初始化切片 s1。\ns1 :&#x3D; s[startIndex:endIndex]\n\n&#x2F;&#x2F; 通过内置函数 make() 初始化切片s，[]int 标识为其元素类型为 int 的切片。\ns :&#x3D;make([]int,len,cap)</code></pre>\n\n<h3 id=\"len-和-cap-函数\"><a href=\"#len-和-cap-函数\" class=\"headerlink\" title=\"len() 和 cap() 函数\"></a>len() 和 cap() 函数</h3><p><code>make([]T, length, capacity/*可选参数，容量*/)</code></p>\n<p>切片是可索引的，并且可以由 len() 方法获取长度。</p>\n<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 以下为具体实例：\n&#x2F;&#x2F; 实例\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var numbers &#x3D; make([]int,3&#x2F;**长度 *&#x2F;,5&#x2F;**容量 *&#x2F;)\n\n   printSlice(numbers)\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;\n&#x2F;&#x2F; 以上实例运行输出结果为:\n\nlen&#x3D;3 cap&#x3D;5 slice&#x3D;[0 0 0]</code></pre>\n\n<h3 id=\"空-nil-切片\"><a href=\"#空-nil-切片\" class=\"headerlink\" title=\"空(nil)切片\"></a>空(nil)切片</h3><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>\n<h3 id=\"切片截取\"><a href=\"#切片截取\" class=\"headerlink\" title=\"切片截取\"></a>切片截取</h3><p>注意点：切片声明时候赋值用<code>&#123;&#125;</code>，在切片赋值和打印时候都是数组<code>[item1,item2, ...]</code></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   &#x2F;* 创建切片 *&#x2F;\n   numbers :&#x3D; []int&#123;0,1,2,3,4,5,6,7,8&#125;\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;9 cap&#x3D;9 slice&#x3D;[0 1 2 3 4 5 6 7 8]\n\n   &#x2F;* 打印原始切片 *&#x2F;\n   fmt.Println(&quot;numbers &#x3D;&#x3D;&quot;, numbers) &#x2F;&#x2F; numbers &#x3D;&#x3D; [0 1 2 3 4 5 6 7 8]\n\n   &#x2F;* 打印子切片从索引1(包含) 到索引4(不包含)*&#x2F;\n   fmt.Println(&quot;numbers[1:4] &#x3D;&#x3D;&quot;, numbers[1:4]) &#x2F;&#x2F; numbers[1:4] &#x3D;&#x3D; [1 2 3]\n\n   &#x2F;* 默认下限为 0*&#x2F;\n   fmt.Println(&quot;numbers[:3] &#x3D;&#x3D;&quot;, numbers[:3]) &#x2F;&#x2F; numbers[:3] &#x3D;&#x3D; [0 1 2]\n\n   &#x2F;* 默认上限为 len(s)*&#x2F;\n   fmt.Println(&quot;numbers[4:] &#x3D;&#x3D;&quot;, numbers[4:]) &#x2F;&#x2F; numbers[4:] &#x3D;&#x3D; [4 5 6 7 8]\n\n   numbers1 :&#x3D; make([]int,0,5)\n   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;5 slice&#x3D;[]\n\n   &#x2F;* 打印子切片从索引  0(包含) 到索引 2(不包含) *&#x2F;\n   number2 :&#x3D; numbers[:2]\n   printSlice(number2) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;9 slice&#x3D;[0 1]\n\n   &#x2F;* 打印子切片从索引 2(包含) 到索引 5(不包含) *&#x2F;\n   number3 :&#x3D; numbers[2:5]\n   printSlice(number3) &#x2F;&#x2F; len&#x3D;3 cap&#x3D;7 slice&#x3D;[2 3 4]\n\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;</code></pre>\n\n<h3 id=\"append-和-copy-函数\"><a href=\"#append-和-copy-函数\" class=\"headerlink\" title=\"append() 和 copy() 函数\"></a>append() 和 copy() 函数</h3><p><strong>这个又何 python</strong>很像，python 中，有些申请的变量是不能更改的，更改操作是对原来的拷贝再处理过程</p>\n<p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>\n<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var numbers []int\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;0 slice&#x3D;[]\n\n   &#x2F;* 允许追加空切片 *&#x2F;\n   numbers &#x3D; append(numbers, 0)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;1 cap&#x3D;1 slice&#x3D;[0]\n\n   &#x2F;* 向切片添加一个元素 *&#x2F;\n   numbers &#x3D; append(numbers, 1)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;2 slice&#x3D;[0 1]\n\n   &#x2F;* 同时添加多个元素 *&#x2F;\n   numbers &#x3D; append(numbers, 2,3,4)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;6 slice&#x3D;[0 1 2 3 4]\n\n   &#x2F;* 创建切片 numbers1 是之前切片的两倍容量*&#x2F;\n   numbers1 :&#x3D; make([]int, len(numbers), (cap(numbers))*2)\n\n   &#x2F;* 拷贝 numbers 的内容到 numbers1 *&#x2F;\n   copy(numbers1,numbers)\n   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;12 slice&#x3D;[0 1 2 3 4]\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;\n</code></pre>\n\n<h2 id=\"Range\"><a href=\"#Range\" class=\"headerlink\" title=\"Range\"></a>Range</h2><p>注意： 这玩意和 python 很不一样，这个是标识符， python 的 range 是个函数</p>\n<p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素</p>\n<ul>\n<li><code>数组</code>和<code>切片</code>中它返回元素的索引和索引对应的值</li>\n<li>集合中返回 key-value 对</li>\n</ul>\n<h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>for 循环的 range 格式可以对 <code>slice</code>、<code>map</code>、<code>数组</code>、<code>字符串</code>等进行迭代循环。格式如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 语法1\nfor key, value :&#x3D; range oldMap &#123;\n    newMap[key] &#x3D; value\n&#125;\n&#x2F;&#x2F; 语法2\nfor key :&#x3D; range oldMap\n\n&#x2F;&#x2F; 语法3\nfor key, _ :&#x3D; range oldMap\n\n&#x2F;&#x2F; 语法4\nfor _, value :&#x3D; range oldMap</code></pre>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>go map 没有 javascript 那么多 api,简单来说就一个，那就是像对象一样赋值</p>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;* 声明变量，默认 map 是 nil *&#x2F;\nvar map_variable map[key_data_type]value_data_type\n\n&#x2F;* 使用 make 函数 *&#x2F;\nmap_variable :&#x3D; make(map[key_data_type]value_data_type)</code></pre>\n\n<h3 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    var countryCapitalMap map[string]string &#x2F;*创建集合 *&#x2F;\n    countryCapitalMap &#x3D; make(map[string]string)\n\n    &#x2F;* map插入key - value对,各个国家对应的首都 *&#x2F;\n    countryCapitalMap [ &quot;France&quot; ] &#x3D; &quot;巴黎&quot;\n    countryCapitalMap [ &quot;Italy&quot; ] &#x3D; &quot;罗马&quot;\n    countryCapitalMap [ &quot;Japan&quot; ] &#x3D; &quot;东京&quot;\n    countryCapitalMap [ &quot;India &quot; ] &#x3D; &quot;新德里&quot;\n\n    &#x2F;*使用键输出地图值 *&#x2F;\n    for country :&#x3D; range countryCapitalMap &#123;\n        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])\n    &#125;\n\n    &#x2F;*查看元素在集合中是否存在 *&#x2F;\n    capital, ok :&#x3D; countryCapitalMap [ &quot;American&quot; ] &#x2F;*如果确定是真实的,则存在,否则不存在 *&#x2F;\n    &#x2F;*fmt.Println(capital) *&#x2F;\n    &#x2F;*fmt.Println(ok) *&#x2F;\n    if (ok) &#123;\n        fmt.Println(&quot;American 的首都是&quot;, capital)\n    &#125; else &#123;\n        fmt.Println(&quot;American 的首都不存在&quot;)\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><p>go map 删除元素用的是 delete 方法</p>\n<p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">delete(countryCapitalMap, &quot;France&quot;)</code></pre>\n\n<h3 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n        &#x2F;* 创建map *&#x2F;\n        countryCapitalMap :&#x3D; map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;\n\n        fmt.Println(&quot;原始地图&quot;)\n\n        &#x2F;* 打印地图 *&#x2F;\n        for country :&#x3D; range countryCapitalMap &#123;\n                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])\n        &#125;\n\n        &#x2F;*删除元素*&#x2F; delete(countryCapitalMap, &quot;France&quot;)\n        fmt.Println(&quot;法国条目被删除&quot;)\n\n        fmt.Println(&quot;删除元素后地图&quot;)\n\n        &#x2F;*打印地图*&#x2F;\n        for country :&#x3D; range countryCapitalMap &#123;\n                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])\n        &#125;\n&#125;</code></pre>\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type_name(expression) &#x2F;&#x2F; type_name 为类型，expression 为表达式。</code></pre>\n\n<h3 id=\"example-4\"><a href=\"#example-4\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var sum int &#x3D; 17\n   var count int &#x3D; 5\n   var mean float32\n\n   mean &#x3D; float32(sum)&#x2F;float32(count) &#x2F;&#x2F; 这里\n   fmt.Printf(&quot;mean 的值为: %f\\n&quot;,mean)\n&#125;</code></pre>\n\n<h2 id=\"接口-interface\"><a href=\"#接口-interface\" class=\"headerlink\" title=\"接口 interface\"></a>接口 interface</h2><p>Go 语言提供了另外一种数据类型即接口，它<strong>把所有的具有共性的方法定义在一起</strong>，任何<strong>其他类型只要实现了这些方法就是实现了这个接口</strong>。</p>\n<h3 id=\"语法-5\"><a href=\"#语法-5\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;* 定义接口 *&#x2F;\ntype interface_name interface &#123;\n   method_name1 [return_type]\n   method_name2 [return_type]\n   method_name3 [return_type]\n   ...\n   method_namen [return_type]\n&#125;\n\n&#x2F;* 定义结构体 *&#x2F;\ntype struct_name struct &#123;\n   &#x2F;* variables *&#x2F;\n&#125;\n\n&#x2F;* 实现接口方法 *&#x2F;\nfunc (struct_name_variable struct_name) method_name1() [return_type] &#123;\n   &#x2F;* 方法实现 *&#x2F;\n&#125;\n...\nfunc (struct_name_variable struct_name) method_namen() [return_type] &#123;\n   &#x2F;* 方法实现*&#x2F;\n&#125;</code></pre>\n\n<h3 id=\"example-5\"><a href=\"#example-5\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n)\n\ntype Phone interface &#123;\n    call()\n&#125;\n\ntype NokiaPhone struct &#123;\n&#125;\n\nfunc (nokiaPhone NokiaPhone) &#x2F;**前面这块 *&#x2F;call() &#123;\n    fmt.Println(&quot;I am Nokia, I can call you!&quot;)\n&#125;\n\ntype IPhone struct &#123;\n&#125;\n\nfunc (iPhone IPhone)&#x2F;**前面这块 *&#x2F; call() &#123;\n    fmt.Println(&quot;I am iPhone, I can call you!&quot;)\n&#125;\n\nfunc main() &#123;\n    var phone Phone &#x2F;&#x2F; interface 类型变量\n    &#x2F;&#x2F; 我本以为没有new 关键字，原来有啊\n    &#x2F;&#x2F; 不明白这里为什么 NokiaPhone的实例可以赋值给 phone，原因：**其他类型只要实现了这些方法就是实现了这个接口**\n    phone &#x3D; new(NokiaPhone)\n    phone.call()\n\n    phone &#x3D; new(IPhone)\n    phone.call()\n\n&#125;\n</code></pre>\n\n<h2 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h2><h3 id=\"reflect-数据结构\"><a href=\"#reflect-数据结构\" class=\"headerlink\" title=\"reflect 数据结构\"></a>reflect 数据结构</h3><!-- <img src=\"http://t-blog-images.aijs.top/img/202210221536036.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222115379.jpg\" />\n\n<h3 id=\"获取字段、类型、值\"><a href=\"#获取字段、类型、值\" class=\"headerlink\" title=\"获取字段、类型、值\"></a>获取字段、类型、值</h3><!-- <img src=\"http://t-blog-images.aijs.top/img/202210221536613.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222102153.png\" />\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210221707726.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222125508.jpg\" />\n\n<h3 id=\"结构体数据转-json\"><a href=\"#结构体数据转-json\" class=\"headerlink\" title=\"结构体数据转 json\"></a>结构体数据转 json</h3><!-- <img src=\"http://t-blog-images.aijs.top/img/202210221713548.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222106998.jpg\" />\n\n<h3 id=\"json-转结构体数据\"><a href=\"#json-转结构体数据\" class=\"headerlink\" title=\"json 转结构体数据\"></a>json 转结构体数据</h3><img src=\"http://t-blog-images.aijs.top/img/202210221715593.png\" />\n\n<h3 id=\"结构体标签\"><a href=\"#结构体标签\" class=\"headerlink\" title=\"结构体标签\"></a>结构体标签</h3><img src=\"http://t-blog-images.aijs.top/img/202210221724590.png\" />\n\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210221726291.png\" /> -->\n\n<h2 id=\"Reflect-api-及作用\"><a href=\"#Reflect-api-及作用\" class=\"headerlink\" title=\"Reflect api 及作用 ?\"></a>Reflect api 及作用 ?</h2><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; - 获取类型信息：reflect.TypeOf，是静态的 &#x2F;&#x2F; 结构体\n&#x2F;&#x2F; - 获取值信息：reflect.ValueOf，是动态的 &#x2F;&#x2F; &#123;1 zs 20&#125;\n&#x2F;&#x2F; - 遍历探测其 属性 &#x2F;&#x2F; NumField()\n&#x2F;&#x2F; - 遍历探测其 方法 &#x2F;&#x2F; NumMethod()   &#x2F;&#x2F;  &#123;&quot;Name&quot;: &quot;Hello&quot;, &quot;Type&quot;: func(main.User)&#125;\n&#x2F;&#x2F; reflect.Value提供了Elem()方法，可以获得指针向指向的value，设置的是指针所指向的内容 https:&#x2F;&#x2F;www.topgoer.cn&#x2F;docs&#x2F;gozhuanjia&#x2F;chapter066.1-reflect\n&#x2F;&#x2F; 其他api见文档 https:&#x2F;&#x2F;pkg.go.dev&#x2F;reflect\n</code></pre>\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;reflect&quot;\n)\n\n&#x2F;&#x2F; 定义结构体\ntype User struct &#123;\n\tId   int\n\tName string\n\tAge  int\n&#125;\n\n&#x2F;&#x2F; 绑方法\nfunc (u User) Hello() &#123;\n\tfmt.Println(&quot;Hello&quot;)\n&#125;\n\n&#x2F;&#x2F; 传入interface&#123;&#125;\nfunc Poni(o interface&#123;&#125;) &#123;\n\tt :&#x3D; reflect.TypeOf(o) &#x2F;&#x2F; 结构体\n\tfmt.Println(&quot;类型：&quot;, t)\n\tfmt.Println(&quot;字符串类型：&quot;, t.Name())\n\t&#x2F;&#x2F; 获取值\n\tv :&#x3D; reflect.ValueOf(o)\n\tfmt.Println(v)\n\t&#x2F;&#x2F; 可以获取所有属性\n\t&#x2F;&#x2F; 获取结构体字段个数：t.NumField()\n\tfor i :&#x3D; 0; i &lt; t.NumField(); i++ &#123; &#x2F;&#x2F; 遍历探测其Filed\n\t\t&#x2F;&#x2F; 取每个字段\n\t\tf :&#x3D; t.Field(i)\n\t\tfmt.Printf(&quot;%s : %v&quot;, f.Name, f.Type) &#x2F;&#x2F; Id : int\n\t\t&#x2F;&#x2F; 获取字段的值信息\n\t\t&#x2F;&#x2F; Interface()：获取字段对应的值\n\t\tval :&#x3D; v.Field(i).Interface() &#x2F;&#x2F; 奇怪，Interface竟然能拿到值\n\n\t\t&#x2F;&#x2F; fmt.Println(&quot;  val :&quot;, val) &#x2F;&#x2F;   val : 1\n\n    &#x2F;&#x2F; fmt.Println(&quot;Name Type  val :&quot;, f.Name, f.Type, val)\n\n    &#x2F;&#x2F; Name Type  val : Id int 1\n    &#x2F;&#x2F; Name Type  val : Name string zs\n    &#x2F;&#x2F; Name Type  val : Age int 20\n\t&#125;\n\tfmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n\tfor i :&#x3D; 0; i &lt; t.NumMethod(); i++ &#123;\n\t\tm :&#x3D; t.Method(i)\n\t\tfmt.Println(m.Name)\n\t\tfmt.Println(m.Type)\n\t&#125;\n\n&#125;\nfunc main() &#123;\n\tu :&#x3D; User&#123;1, &quot;zs&quot;, 20&#125;\n\tPoni(u)\n&#125;\n\n&#x2F;&#x2F; 类型： main.User\n&#x2F;&#x2F; 字符串类型： User\n&#x2F;&#x2F; &#123;1 zs 20&#125;\n&#x2F;&#x2F; Id : int  val : 1\n&#x2F;&#x2F; Name : string  val : zs\n&#x2F;&#x2F; Age : int  val : 20\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Hello\n&#x2F;&#x2F; func(main.User)\n\n&#x2F;&#x2F; Program exited.\n</code></pre>\n\n<p><a href=\"https://www.topgoer.com/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/%E5%8F%8D%E5%B0%84.html\" target=\"_blank\" >参考</a></p>\n<h3 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h3><p><a href=\"https://juejin.cn/post/6844903559335526407\" target=\"_blank\" >Golang 的反射 reflect 深入理解和示例</a></p>\n<h2 id=\"Go-的-json-解析：Marshal-与-Unmarshal\"><a href=\"#Go-的-json-解析：Marshal-与-Unmarshal\" class=\"headerlink\" title=\"Go 的 json 解析：Marshal 与 Unmarshal\"></a>Go 的 json 解析：Marshal 与 Unmarshal</h2><ul>\n<li>json.Marshal 结构体转 json</li>\n<li>json.Unmarshal json 转结构体</li>\n</ul>\n<h3 id=\"json-Marshal\"><a href=\"#json-Marshal\" class=\"headerlink\" title=\"json.Marshal\"></a>json.Marshal</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import (\n    &quot;encoding&#x2F;json&quot;\n    &quot;fmt&quot;\n)\n\ntype User struct &#123;\n    Name  string &#96;json:&quot;user_name&quot;&#96;\n    Age   int    &#96;json:&quot;age&quot;&#96;\n    sex   string\n    Work1 *Work1\n    Work2 *Work2\n    Work3 Work3\n    Work4 interface&#123;&#125; &#96;json:&quot;work4&quot;&#96;\n&#125;\n\ntype Work1 struct &#123;\n    Name   string &#96;json:&quot;work1_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work2 struct &#123;\n    Name   string &#96;json:&quot;work2_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work3 struct &#123;\n    Name   string &#96;json:&quot;work3_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work4 struct &#123;\n    Name    string &#96;json:&quot;work4_name&quot;&#96;\n    Salary  float32\n    Address string &#96;json:&quot;work4_add&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 实例化User\n    u1 :&#x3D; User&#123;\n        Name: &quot;ares&quot;,\n        Age:  18,\n        sex:  &quot;男&quot;,\n    &#125;\n    &#x2F;&#x2F; 指针\n    w1 :&#x3D; Work1&#123;\n        Name:   &quot;god1&quot;,\n        Salary: 100,\n    &#125;\n    u1.Work1 &#x3D; &amp;w1\n    &#x2F;&#x2F; 指针\n    w2 :&#x3D; new(Work2)\n    w2.Name &#x3D; &quot;god2&quot;\n    w2.Salary &#x3D; 200\n    u1.Work2 &#x3D; w2\n    &#x2F;&#x2F; 非指针\n    w3 :&#x3D; Work3&#123;\n        Name:   &quot;god3&quot;,\n        Salary: 300,\n    &#125;\n    u1.Work3 &#x3D; w3\n    &#x2F;&#x2F; 非指针\n    w4 :&#x3D; Work4&#123;\n        Name:    &quot;god4&quot;,\n        Salary:  400,\n        Address: &quot;cbd&quot;,\n    &#125;\n    u1.Work4 &#x3D; w4\n    &#x2F;&#x2F;Marshal失败时err!&#x3D;nil\n    jsonU, err :&#x3D; json.Marshal(u1)\n    if err !&#x3D; nil &#123;\n        fmt.Println(&quot;生成json字符串错误&quot;)\n    &#125;\n\n    &#x2F;&#x2F; jsonU是[]byte类型，转化成string类型便于查看\n    &#x2F;**\n    &#123;\n        &quot;user_name&quot;: &quot;ares&quot;,\n        &quot;age&quot;: 18,\n        &quot;Work1&quot;: &#123;\n            &quot;work1_name&quot;: &quot;god1&quot;,\n            &quot;Salary&quot;: 100\n        &#125;,\n        &quot;Work2&quot;: &#123;\n            &quot;work2_name&quot;: &quot;god2&quot;,\n            &quot;Salary&quot;: 200\n        &#125;,\n        &quot;Work3&quot;: &#123;\n            &quot;work3_name&quot;: &quot;god3&quot;,\n            &quot;Salary&quot;: 300\n        &#125;,\n        &quot;work4&quot;: &#123;\n            &quot;work4_name&quot;: &quot;god4&quot;,\n            &quot;Salary&quot;: 400,\n            &quot;work4_add&quot;: &quot;cbd&quot;\n        &#125;\n    &#125;\n    *&#x2F;\n    fmt.Println(string(jsonU))\n&#125;\n</code></pre>\n\n<h3 id=\"Json-Unmarshal\"><a href=\"#Json-Unmarshal\" class=\"headerlink\" title=\"Json Unmarshal\"></a>Json Unmarshal</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;aresxin&#x2F;p&#x2F;go-json.html&quot; target&#x3D;&quot;_blank&quot; &gt;Go 的 json 解析:Marshal 与 Unmarshal&lt;&#x2F;a&gt;\nimport (\n    &quot;encoding&#x2F;json&quot;\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\ntype User struct &#123;\n    Name  string &#96;json:&quot;user_name&quot;&#96;\n    Age   int    &#96;json:&quot;age&quot;&#96;\n    sex   string\n    Work1 *Work1\n    Work2 json.RawMessage\n    Work3 Work3\n    Work4 interface&#123;&#125; &#96;json:&quot;work4&quot;&#96;\n    Work5 interface&#123;&#125;\n&#125;\n\ntype Work1 struct &#123;\n    Name   string &#96;json:&quot;work1_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work2 struct &#123;\n    Name   string &#96;json:&quot;work2_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work3 struct &#123;\n    Name   string &#96;json:&quot;work3_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work4 struct &#123;\n    Name    string &#96;json:&quot;work4_name&quot;&#96;\n    Salary  float32\n    Address string &#96;json:&quot;work4_add&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F;json字符中的&quot;引号，需用\\进行转义，否则编译出错\n    data :&#x3D; &quot;&#123;\\&quot;user_name\\&quot;:\\&quot;ares\\&quot;,\\&quot;sex\\&quot;:\\&quot;男\\&quot;,\\&quot;age\\&quot;:18,\\&quot;Work1\\&quot;:&#123;\\&quot;work1_name\\&quot;:\\&quot;god1\\&quot;,\\&quot;Salary\\&quot;:100&#125;,\\&quot;Work2\\&quot;:&#123;\\&quot;work2_name\\&quot;:\\&quot;god2\\&quot;,\\&quot;Salary\\&quot;:200&#125;,\\&quot;Work3\\&quot;:&#123;\\&quot;work3_name\\&quot;:\\&quot;god3\\&quot;,\\&quot;Salary\\&quot;:300&#125;,\\&quot;work4\\&quot;:&#123;\\&quot;work4_name\\&quot;:\\&quot;god4\\&quot;,\\&quot;Salary\\&quot;:400,\\&quot;work4_add\\&quot;:\\&quot;cbd\\&quot;&#125;&#125;&quot;\n    str :&#x3D; []byte(data)\n    u1 :&#x3D; User&#123;&#125;\n    &#x2F;&#x2F; Unmarshal的第一个参数是json字符串，第二个参数是接受json解析的数据结构.第二个参数必须是指针，否则无法接收解析的数据，\n    err :&#x3D; json.Unmarshal(str, &amp;u1)\n    if err !&#x3D; nil &#123;\n        fmt.Println(&quot;Unmarshal err,&quot;, err)\n    &#125;\n    &#x2F;&#x2F; &#123;ares 18  0xc0000a41c8 0xc0000a41e0 &#123;god3 300&#125; map[Salary:400 work4_add:cbd work4_name:god4]&#125;  Work2 为*Work2类型\n    &#x2F;&#x2F;  Work2 为json.RawMessage类型  &#123;ares 18  0xc0000a4198 [123 34 119 111 114 107 50 95 110 97 109 101 34 58 34 103 111 100 50 34 44 34 83 97 108 97 114 121 34 58 50 48 48 125] &#123;god3 300&#125; map[Salary:400 work4_add:cbd work4_name:god4] &lt;nil&gt;&#125;\n\n    fmt.Println(u1)\n    &#x2F;&#x2F; 查看类型\n    nameType :&#x3D; reflect.TypeOf(u1.Name)\n    ageType :&#x3D; reflect.TypeOf(u1.Age)\n    sexType :&#x3D; reflect.TypeOf(u1.sex)\n    work1Type :&#x3D; reflect.TypeOf(u1.Work1)\n    work2Type :&#x3D; reflect.TypeOf(u1.Work2)\n    work3Type :&#x3D; reflect.TypeOf(u1.Work3)\n    work4Type :&#x3D; reflect.TypeOf(u1.Work4)\n    work5Type :&#x3D; reflect.TypeOf(u1.Work5)\n    fmt.Println(nameType)  &#x2F;&#x2F; string\n    fmt.Println(ageType)   &#x2F;&#x2F; int\n    fmt.Println(sexType)   &#x2F;&#x2F; string\n    fmt.Println(work1Type) &#x2F;&#x2F; *main.Work1\n    fmt.Println(work2Type) &#x2F;&#x2F; json.RawMessage\n    fmt.Println(work3Type) &#x2F;&#x2F; main.Work3\n    fmt.Println(work4Type) &#x2F;&#x2F; map[string]interface &#123;&#125;\n    fmt.Println(work5Type) &#x2F;&#x2F; &lt;nil&gt;\n&#125;\n</code></pre>\n\n<p>json 字符串解析时，需要一个“接收体”接受解析后的数据，且 Unmarshal 时接收体必须传递指针。<br>解析时，接收体可自行定义。json 串中的 key 自动在接收体中寻找匹配的项进行赋值。<br>匹配规则：</p>\n<ul>\n<li>先查找与 key 一样的 json 标签，找到则赋值给该标签对应的变量；</li>\n<li>没有 json 标签的，就从上往下依次查找变量名与 key 一样的变量，或者变量名忽略大小写后与 key 一样的变量，第一个匹配的就赋值，后面就算有匹配的也忽略（变量可导出，首字母大写）。</li>\n<li>当接收体中存在 json 串中匹配不了的项时，解析会自动忽略该项，该项仍保留原值。</li>\n<li>如变量 Work5，保留空值 nil。</li>\n<li>json 解析后，json 串中 value，只要是”简单数据”，都会按照默认的类型赋值。<ul>\n<li>简单数据：是指不能再进行二次 json 解析的数据，例如 name</li>\n<li>复合数据：是可进行二次甚至多次 json 解析的，因为它的 value 也是个可被解析的独立 json，例如 work1-5。</li>\n</ul>\n</li>\n<li>对于”复合数据”，如果接收体中配的项被声明为 interface{}类型，go 都会默认解析成 map[string]interface{}类型。</li>\n<li>如果想直接解析到 struct Class 对象中，可以将接受体对应的项定义为该 struct 类型。</li>\n<li>如果不想指定 work 变量为具体的类型，仍想保留 interface{}类型，但又希望该变量可以解析到 struct work 对象中，可以将该变量定义为 json.RawMessage 类型。</li>\n<li>被声明为 json.RawMessage 类型的变量在 json 解析时，变量值仍保留 json 的原值，即未被自动解析为 map[string]interface{}类型,可以对该变量进行二次 json 解析，因为其值仍是个独立且可解析的完整 json 串,只需再定义一个新的接受体即可。</li>\n</ul>\n<h2 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h2><img src=\"http://t-blog-images.aijs.top/img/202210222040847.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210222041745.png\" />\n\n<h2 id=\"goroutine-数据通信\"><a href=\"#goroutine-数据通信\" class=\"headerlink\" title=\"goroutine 数据通信\"></a>goroutine 数据通信</h2><img src=\"http://t-blog-images.aijs.top/img/202210222058287.png\" />\n\n<h2 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h2><img src=\"http://t-blog-images.aijs.top/img/202210222125508.jpg\" />\n\n<h2 id=\"两个-channel-执行过程，及阻塞\"><a href=\"#两个-channel-执行过程，及阻塞\" class=\"headerlink\" title=\"两个 channel 执行过程，及阻塞\"></a>两个 channel 执行过程，及阻塞</h2><img src=\"http://t-blog-images.aijs.top/img/202210222145876.jpg\" />\n\n<p><strong>无缓存</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/202210222148949.jpg\" />\n\n<p><strong>有缓存</strong><br><img src=\"http://t-blog-images.aijs.top/img/202210222148500.jpg\" /></p>\n<h3 id=\"关闭-特点\"><a href=\"#关闭-特点\" class=\"headerlink\" title=\"关闭 特点\"></a>关闭 特点</h3><img src=\"http://t-blog-images.aijs.top/img/202210222155221.png\" />\n\n<p>当 channel 已经满，再向里面写数据，会阻塞<br>当 channel 为空，从里面取数据也会阻塞</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><h4 id=\"读阻塞\"><a href=\"#读阻塞\" class=\"headerlink\" title=\"读阻塞\"></a>读阻塞</h4><img src=\"http://t-blog-images.aijs.top/img/202210222202688.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210222203039.png\" />\n\n<h4 id=\"写阻塞\"><a href=\"#写阻塞\" class=\"headerlink\" title=\"写阻塞\"></a>写阻塞</h4><img src=\"http://t-blog-images.aijs.top/img/202210222204476.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210222332462.png\" />\n\n<h3 id=\"channel-range\"><a href=\"#channel-range\" class=\"headerlink\" title=\"channel range\"></a>channel range</h3><img src=\"http://t-blog-images.aijs.top/img/202210222333136.png\" />\n\n<h3 id=\"channel-select\"><a href=\"#channel-select\" class=\"headerlink\" title=\"channel select\"></a>channel select</h3><img src=\"http://t-blog-images.aijs.top/img/202210222334406.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210222338620.png\" />\n\n<h2 id=\"管理工具\"><a href=\"#管理工具\" class=\"headerlink\" title=\"管理工具\"></a>管理工具</h2><img src=\"http://t-blog-images.aijs.top/img/202210222353689.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210222354251.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210222356816.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210231102618.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210231114931.png\" />\n\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p><strong>通过内置的错误接口提供了非常简单的错误处理机制。</strong></p>\n<h3 id=\"语法-6\"><a href=\"#语法-6\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>error 类型是一个接口类型，这是它的定义：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type error interface &#123;\n  Error() string\n&#125;\n</code></pre>\n\n<p>我们可以在编码中<strong>通过实现 error 接口类型来生成错误信息</strong>。</p>\n<p>函数通常在最后的返回值中返回错误信息。<strong>使用 errors.New 可返回一个错误信息</strong>：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func Sqrt(f float64) (float64, error) &#123;\n    if f &lt; 0 &#123;\n        return 0, errors.New(&quot;math: square root of negative number&quot;)\n    &#125;\n    &#x2F;&#x2F; 实现\n&#125;</code></pre>\n\n<h3 id=\"example-6\"><a href=\"#example-6\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n)\n\n&#x2F;&#x2F; 定义一个 DivideError 结构\n&#x2F;&#x2F; 定义 xxx 结构体\ntype DivideError struct &#123;\n    dividee int\n    divider int\n&#125;\n\n&#x2F;&#x2F; 实现 &#96;error&#96; 接口\nfunc (de *DivideError&#x2F;**指针 *&#x2F;) Error() string &#123;\n    strFormat :&#x3D; &#96;\n    Cannot proceed, the divider is zero.\n    dividee: %d\n    divider: 0\n&#96;\n&#x2F;&#x2F; fmt.Sprintf这个api, 有点面熟，先定义模版，再替换模版中的变量值\n    return fmt.Sprintf(strFormat, de.dividee)\n&#125;\n\n&#x2F;&#x2F; 定义 &#96;int&#96; 类型除法运算的函数\nfunc Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;\n    if varDivider &#x3D;&#x3D; 0 &#123;\n        &#x2F;&#x2F; 结构体\n        dData :&#x3D; DivideError &#123;\n                dividee: varDividee,\n                divider: varDivider,\n        &#125;\n        &#x2F;&#x2F; 定义了一个结构体，直接调用结构体的方法，这也太直接了吧？\n        errorMsg &#x3D; dData.Error()\n        return\n    &#125; else &#123;\n        return varDividee &#x2F; varDivider, &quot;&quot;\n    &#125;\n\n&#125;\n\nfunc main() &#123;\n\n    &#x2F;&#x2F; 正常情况\n    &#x2F;** :&#x3D; 前面两个、后面两个，分别赋值 *&#x2F;\n    &#x2F;&#x2F; result 有值，执行if内容\n    if result, errorMsg :&#x3D; Divide(100, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;\n            fmt.Println(&quot;100&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 100&#x2F;10 &#x3D;  10\n    &#125;\n    &#x2F;&#x2F; result 为 0 ,执行if内容打印了\n    if result, errorMsg :&#x3D; Divide(0, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;\n      fmt.Println(&quot;0&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 0&#x2F;10 &#x3D;  0\n    &#125;\n\n    &#x2F;&#x2F; 当除数为零的时候会返回错误信息\n    &#x2F;&#x2F; errorMsg 有值，执行if内容\n    if _, errorMsg :&#x3D; Divide(100, 0); errorMsg !&#x3D; &quot;&quot; &#123;\n            fmt.Println(&quot;errorMsg is: &quot;, errorMsg)\n    &#x2F;&#x2F; errorMsg is:\n    &#x2F;&#x2F;   Cannot proceed, the divider is zero.\n    &#x2F;&#x2F;   dividee: 100\n    &#x2F;&#x2F;   divider: 0\n    &#x2F;&#x2F; 这个返回有点意思，前面格式化错误打印，第一个变量是通过 &#96;&#96;运算得来的，和javascript 有点类似，原样的格式输出\n    &#125;\n\n&#125;</code></pre>\n\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210151324359.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222122218.jpg\" />\n\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><p>go 支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>\n<p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>\n<h3 id=\"语法-7\"><a href=\"#语法-7\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">go 函数名( 参数列表 )</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 例如：\n\ngo f(x, y, z)\n&#x2F;&#x2F; 开启一个新的 goroutine:f(x, y, z)\n</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，\n&#x2F;&#x2F; 以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。\n\npackage main\n\nimport (\n        &quot;fmt&quot;\n        &quot;time&quot;\n)\n\nfunc say(s string) &#123;\n        for i :&#x3D; 0; i &lt; 5; i++ &#123;\n                time.Sleep(100 * time.Millisecond)\n                fmt.Println(s)\n        &#125;\n&#125;\n\nfunc main() &#123;\n        go say(&quot;world&quot;)\n        say(&quot;hello&quot;)\n&#125;\n\n&#x2F;&#x2F; 执行以上代码，你会看到输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行：\n\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello</code></pre>\n\n<h3 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h3><p>用来：打通 goroutine，进行数据传输的</p>\n<p>通道（channel）<strong>是用来传递数据的一个数据结构</strong>。</p>\n<p>通道可用于<strong>两个 goroutine 之间</strong>通过传递一个指定类型的值来<strong>同步运行和通讯</strong>。操作符<code>&lt;-</code> 用于指定通道的方向，发送或接收。</p>\n<p><strong>如果未指定方向，则为双向通道。</strong></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch\nv :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据\n           &#x2F;&#x2F; 并把值赋给 v\n&#x2F;&#x2F; 声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：\n\nch :&#x3D; make(chan int)</code></pre>\n\n<p>注意：默认情况下，<strong>通道是不带缓冲区的</strong>。发送端发送数据，同时<strong>必须有接收端</strong>相应的接收数据。</p>\n<p>以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：</p>\n<h3 id=\"example-7\"><a href=\"#example-7\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc sum(s []int, c chan int) &#123;\n        sum :&#x3D; 0\n        for _, v :&#x3D; range s &#123;\n                sum +&#x3D; v\n        &#125;\n        c &lt;- sum &#x2F;&#x2F; 把 sum 发送到通道 c\n&#125;\n\nfunc main() &#123;\n        s :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;\n\n        c :&#x3D; make(chan int)\n        go sum(s[:len(s)&#x2F;2], c) &#x2F;&#x2F; s[:len(s)&#x2F;2] [ -9, 4, 0]\n        go sum(s[len(s)&#x2F;2:], c) &#x2F;&#x2F; s[len(s)&#x2F;2:] [7, 2, 8]\n        x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收\n\n        fmt.Println(x, y, x+y)\n\n        &#x2F;&#x2F; -5 17 12\n&#125;\n\n</code></pre>\n\n<!-- <img src=\"http://t-blog-images.aijs.top/img/202210151346664.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222122467.jpg\" />\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 小改下\nfunc main() &#123;\n\ts :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;\n\n    c :&#x3D; make(chan int)\n    go sum(s[:len(s)&#x2F;2], c)\n    go sum(s[len(s)&#x2F;2:], c)\n\n    &#x2F;&#x2F; 下面这两个比goroutine先执行\n    fmt.Println(&quot;c&quot;)\n    fmt.Println(c)\n\n    x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收\n\n    a :&#x3D; &lt;-c &#x2F;&#x2F; 这里会报错\n\n    fmt.Println(a)\n\n    fmt.Println(x, y, x+y)\n\n&#125;\n\n&#x2F;&#x2F; c\n&#x2F;&#x2F; 0xc00006e060\n&#x2F;&#x2F; [-9 4 0]\n&#x2F;&#x2F; [7 2 8]\n&#x2F;&#x2F; fatal error: all goroutines are asleep - deadlock!\n\n&#x2F;&#x2F; goroutine 1 [chan receive]:\n&#x2F;&#x2F; main.main()\n&#x2F;&#x2F; &#x2F;tmp&#x2F;sandbox2040469662&#x2F;prog.go:26 +0x249\n\n&#x2F;&#x2F; Program exited.\n</code></pre>\n\n<h3 id=\"通道缓冲区\"><a href=\"#通道缓冲区\" class=\"headerlink\" title=\"通道缓冲区\"></a>通道缓冲区</h3><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">ch :&#x3D; make(chan int, 100)</code></pre>\n\n<p><strong>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态</strong>，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>\n<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则<strong>缓冲区一满，数据发送端就无法再发送数据了</strong>。</p>\n<p>注意：</p>\n<ul>\n<li>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。</li>\n<li>如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；</li>\n<li>如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n&#x2F;&#x2F; 这里我们定义了一个可以存储整数类型的带缓冲通道\n&#x2F;&#x2F; 缓冲区大小为2\n  ch :&#x3D; make(chan int, 2)\n\n  &#x2F;&#x2F; 因为 ch 是带缓冲的通道，我们可以同时发送两个数据\n  &#x2F;&#x2F; 而不用立刻需要去同步读取数据\n  ch &lt;- 1\n  ch &lt;- 2\n\n  &#x2F;&#x2F; 获取这两个数据\n  fmt.Println(&lt;-ch)\n  fmt.Println(&lt;-ch)\n\n&#x2F;&#x2F; 执行输出结果为：\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#125;\n</code></pre>\n\n<h2 id=\"Go-遍历通道与关闭通道\"><a href=\"#Go-遍历通道与关闭通道\" class=\"headerlink\" title=\"Go 遍历通道与关闭通道\"></a>Go 遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p>\n<h3 id=\"语法-8\"><a href=\"#语法-8\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">v, ok :&#x3D; &lt;-ch\n</code></pre>\n\n<h3 id=\"example-8\"><a href=\"#example-8\" class=\"headerlink\" title=\"example\"></a>example</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n        &quot;fmt&quot;\n)\n\nfunc fibonacci(n int, c chan int) &#123;\n        x, y :&#x3D; 0, 1\n        for i :&#x3D; 0; i &lt; n; i++ &#123;\n                c &lt;- x\n                x, y &#x3D; y, x+y\n        &#125;\n        close(c)\n&#125;\n\nfunc main() &#123;\n        c :&#x3D; make(chan int, 10)\n        go fibonacci(cap(c), c)\n        &#x2F;&#x2F; range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个\n        &#x2F;&#x2F; 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据\n        &#x2F;&#x2F; 之后就结束了。\n        &#x2F;&#x2F; 如果上面的 c 通道不关闭，那么 range 函数就不会结束，从而在接收第 11 个数据的时候就阻塞了。\n        for i :&#x3D; range c &#123;\n                fmt.Println(i)\n        &#125;\n&#125;\n\n&#x2F;&#x2F; 执行输出结果为：\n\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 5\n&#x2F;&#x2F; 8\n&#x2F;&#x2F; 13\n&#x2F;&#x2F; 21\n&#x2F;&#x2F; 34\n</code></pre>\n\n<p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>\n<h3 id=\"example-不关闭\"><a href=\"#example-不关闭\" class=\"headerlink\" title=\"example 不关闭\"></a>example 不关闭</h3><!-- <img src=\"http://t-blog-images.aijs.top/img/202210151355250.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/202210222123098.jpg\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fatal error: all goroutines are asleep - deadlock!</code></pre>\n\n<h3 id=\"模块中大写\"><a href=\"#模块中大写\" class=\"headerlink\" title=\"模块中大写\"></a>模块中大写</h3><p><a href=\"https://go.dev/doc/code#:~:text=Because%20our%20ReverseRunes%20function%20begins%20with%20an%20upper%2Dcase%20letter%2C%20it%20is%20exported%2C%20and%20can%20be%20used%20in%20other%20packages%20that%20import%20our%20morestrings%20package.\" target=\"_blank\" >见</a></p>\n<p>模块中大些的函数是被导出。</p>\n<ul>\n<li>缓存，取代产生文件</li>\n<li>绝对路径导入使用 <code>import ( &quot;packagepath&quot;)</code></li>\n<li>安装<code>go install packagepath</code></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.runoob.com/go/go-ide.html\" target=\"_blank\" >runoob</a></p>\n<p><a href=\"https://golang.google.cn/play/\" target=\"_blank\" >golang play</a></p>\n<p><a href=\"https://github.com/gin-gonic/gin\" target=\"_blank\" >gin-gonic&#x2F;gin</a></p>\n<p><a href=\"https://golang.google.cn/doc/tutorial/web-service-gin\" target=\"_blank\" >Tutorial: Developing a RESTful API with Go and Gin</a></p>\n<h2 id=\"博客收录\"><a href=\"#博客收录\" class=\"headerlink\" title=\"博客收录\"></a>博客收录</h2><p><a href=\"https://learnku.com/docs/the-way-to-go/if-else-structure/3592\" target=\"_blank\" >这个文档比较好</a></p>\n<p><a href=\"https://pkg.go.dev/\" target=\"_blank\" >https://pkg.go.dev/</a></p>\n<h2 id=\"待看\"><a href=\"#待看\" class=\"headerlink\" title=\"待看\"></a>待看</h2><p><a href=\"https://www.bilibili.com/video/BV1ZJ411W7jG/\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://github.com/golang/go/wiki/NonEnglish\" target=\"_blank\" >NonEnglish 文档</a><br><a href=\"https://go-zh.org/doc/\" target=\"_blank\" >go 中文文档</a><br><a href=\"https://www.topgoer.com/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/fmt.html\" target=\"_blank\" >中文文档</a></p>\n<p><a href=\"http://daohang.coder55.com/?F=top\" target=\"_blank\" >导航分类</a></p>\n<p><a href=\"https://www.topgoer.com/\" target=\"_blank\" >https://www.topgoer.com/</a></p>\n","text":"目前所遇到最好的教程go 教程 https://studygolang.com/pkgdoc 🤔 下载安装 go官方安装包地址 ♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ go ve...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"Go","slug":"Go","count":19,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":19,"path":"api/tags/Go.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%89%8D%E6%89%80%E9%81%87%E5%88%B0%E6%9C%80%E5%A5%BD%E7%9A%84%E6%95%99%E7%A8%8B\"><span class=\"toc-text\">目前所遇到最好的教程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%F0%9F%A4%94\"><span class=\"toc-text\">🤔</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-go\"><span class=\"toc-text\">下载安装 go</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Tour-%E6%95%99%E7%A8%8B\"><span class=\"toc-text\">Tour 教程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">命名返回</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#If\"><span class=\"toc-text\">If</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#switch\"><span class=\"toc-text\">switch</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">与众不同</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#switch-%E7%9A%84%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">switch 的求值顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84-switch\"><span class=\"toc-text\">没有条件的 switch</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#defer\"><span class=\"toc-text\">defer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A8%E8%BF%9F%E5%88%B0%E5%A4%96%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">推迟到外函数执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%8E%A8%E8%BF%9F%E6%97%B6%E5%80%99%EF%BC%8C%E5%87%BA%E6%A0%88\"><span class=\"toc-text\">执行推迟时候，出栈</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">基本操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D\"><span class=\"toc-text\">:&#x3D;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%AE%9A\"><span class=\"toc-text\">长度不定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">指定索引赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD\"><span class=\"toc-text\">自动推断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">多维数组语法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88\"><span class=\"toc-text\">指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88\"><span class=\"toc-text\">指针的指针</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">结构体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">结构体继承</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%87%E8%83%BD%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">万能类型 与 断言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E5%B0%8F%E5%86%99\"><span class=\"toc-text\">大小写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88\"><span class=\"toc-text\">结构体指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-1\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87\"><span class=\"toc-text\">切片</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-1\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#len-%E5%92%8C-cap-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">len() 和 cap() 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA-nil-%E5%88%87%E7%89%87\"><span class=\"toc-text\">空(nil)切片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E6%88%AA%E5%8F%96\"><span class=\"toc-text\">切片截取</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#append-%E5%92%8C-copy-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">append() 和 copy() 函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Range\"><span class=\"toc-text\">Range</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-2\"><span class=\"toc-text\">语法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-3\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-2\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#delete\"><span class=\"toc-text\">delete</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-3\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">类型转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-4\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-4\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3-interface\"><span class=\"toc-text\">接口 interface</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-5\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-5\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reflect\"><span class=\"toc-text\">reflect</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#reflect-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">reflect 数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC\"><span class=\"toc-text\">获取字段、类型、值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E8%BD%AC-json\"><span class=\"toc-text\">结构体数据转 json</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#json-%E8%BD%AC%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">json 转结构体数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">结构体标签</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reflect-api-%E5%8F%8A%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">Reflect api 及作用 ?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#other\"><span class=\"toc-text\">other</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Go-%E7%9A%84-json-%E8%A7%A3%E6%9E%90%EF%BC%9AMarshal-%E4%B8%8E-Unmarshal\"><span class=\"toc-text\">Go 的 json 解析：Marshal 与 Unmarshal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#json-Marshal\"><span class=\"toc-text\">json.Marshal</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Json-Unmarshal\"><span class=\"toc-text\">Json Unmarshal</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#goroutine\"><span class=\"toc-text\">goroutine</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#goroutine-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">goroutine 数据通信</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#channel\"><span class=\"toc-text\">channel</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA-channel-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%8F%8A%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">两个 channel 执行过程，及阻塞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%97%AD-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">关闭 特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">读阻塞</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%99%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">写阻塞</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#channel-range\"><span class=\"toc-text\">channel range</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#channel-select\"><span class=\"toc-text\">channel select</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">管理工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">错误处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-6\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-6\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">并发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-7\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93\"><span class=\"toc-text\">通道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-7\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">通道缓冲区</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Go-%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93%E4%B8%8E%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93\"><span class=\"toc-text\">Go 遍历通道与关闭通道</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95-8\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-8\"><span class=\"toc-text\">example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-%E4%B8%8D%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">example 不关闭</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%A4%A7%E5%86%99\"><span class=\"toc-text\">模块中大写</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95\"><span class=\"toc-text\">博客收录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%85%E7%9C%8B\"><span class=\"toc-text\">待看</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Go Gin","uid":"b21d66657c866de8629862fe6f5e2c48","slug":"2022-10-15gin","date":"2022-10-15T06:57:18.000Z","updated":"2022-12-22T13:36:21.787Z","comments":true,"path":"api/articles/2022-10-15gin.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202212211225570.webp","text":"背景 巩固 go 语言学习 听说很多大公司用 go 来开发服务器，我特来看看 了解 go web 开发 Gin选这个框架原因如下： 社区活跃 Go 官网推荐Tutorial: Developing a RESTful API with Go and Gin github 上 st...","link":"","photos":[],"count_time":{"symbolsCount":"49k","symbolsTime":"44 mins."},"categories":[{"name":"Go","slug":"Go","count":19,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":19,"path":"api/tags/Go.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"nextjs useSearchParams","uid":"9a1d323e88658104fe9c4ac04b72ebe7","slug":"2022-10-14useSearchParams","date":"2022-10-14T08:57:11.000Z","updated":"2022-10-17T11:18:29.861Z","comments":true,"path":"api/articles/2022-10-14useSearchParams.json","keywords":null,"cover":[],"text":"背景需求 列表切换详情，返回列表，要求查询表单参数不丢失， 思路 记录参数到 url 上，在记录的过程中，列表页面不刷新 返回时候列表页只作为一个 history 栈中的一个记录 MDN 直接点：history.replaceState history.replaceState ...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}