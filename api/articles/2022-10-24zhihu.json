{"title":"知乎网站找到面试题","uid":"f806b0ce6fb2f43b93c3ab8035d48439","slug":"2022-10-24zhihu","date":"2022-10-24T13:38:58.000Z","updated":"2022-11-21T13:08:33.123Z","comments":true,"path":"api/articles/2022-10-24zhihu.json","keywords":null,"cover":[],"content":"<h2 id=\"爬取脚本\"><a href=\"#爬取脚本\" class=\"headerlink\" title=\"爬取脚本\"></a>爬取脚本</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.from(document.getElementsByTagName(&quot;h3&quot;)).forEach((item) &#x3D;&gt; &#123;\n  document.body.append(item.innerText + &quot;\\n&quot;);\n&#125;);</code></pre>\n\n<h2 id=\"1-🌟-介绍-js-的基本数据类型。\"><a href=\"#1-🌟-介绍-js-的基本数据类型。\" class=\"headerlink\" title=\"1.🌟 介绍 js 的基本数据类型。\"></a>1.🌟 介绍 js 的基本数据类型。</h2><h2 id=\"2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？\"><a href=\"#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？\" class=\"headerlink\" title=\"2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？\"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h2><h2 id=\"3-什么是堆？什么是栈？它们之间有什么区别和联系？\"><a href=\"#3-什么是堆？什么是栈？它们之间有什么区别和联系？\" class=\"headerlink\" title=\"3. 什么是堆？什么是栈？它们之间有什么区别和联系？\"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h2><h2 id=\"4-🌟-内部属性-Class-是什么？\"><a href=\"#4-🌟-内部属性-Class-是什么？\" class=\"headerlink\" title=\"4.🌟 内部属性 [[Class]] 是什么？\"></a>4.🌟 内部属性 [[Class]] 是什么？</h2><ul>\n<li>值等于 加上 <code>toStringTag</code> 属性</li>\n<li><code>Null()和 Undefined()这样的原生构造函数并不存在</code>,<code>但是内部[[class]]属性值仍然是&quot;Null&quot;和&quot;Undefined&quot;</code>.</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 方式1\nclass myClass &#123;\n  get [Symbol.toStringTag]() &#123;\n    return &quot;myClass1&quot;;\n  &#125;\n&#125;\nObject.prototype.toString.call(new myClass()); &#x2F;&#x2F; &quot;[object myClass1]&quot;\n\n&#x2F;&#x2F; 方式2\nconst obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, Symbol.toStringTag, &#123; value: &quot;CustomObject&quot; &#125;); &#x2F;&#x2F; &quot;[object CustomObject]&quot;</code></pre>\n\n<p><a href=\"https://juejin.cn/post/7081618269043425310\" target=\"_blank\" >见</a></p>\n<h2 id=\"5-介绍-js-有哪些内置对象？\"><a href=\"#5-介绍-js-有哪些内置对象？\" class=\"headerlink\" title=\"5. 介绍 js 有哪些内置对象？\"></a>5. 介绍 js 有哪些内置对象？</h2><h2 id=\"undeclared-x2F-undefined-x2F-null\"><a href=\"#undeclared-x2F-undefined-x2F-null\" class=\"headerlink\" title=\"undeclared&#x2F;undefined&#x2F;null\"></a>undeclared&#x2F;undefined&#x2F;null</h2><h3 id=\"6-🌟-undefined-与-undeclared-的区别？\"><a href=\"#6-🌟-undefined-与-undeclared-的区别？\" class=\"headerlink\" title=\"6.🌟 undefined 与 undeclared 的区别？\"></a>6.🌟 undefined 与 undeclared 的区别？</h3><ul>\n<li>已在作用域中声明但还没有赋值的变量，是 undefined 的。</li>\n<li>还没有在作用域中声明过的变量，是 undeclared 的。</li>\n</ul>\n<h3 id=\"7-🌟-null-和-undefined-的区别？\"><a href=\"#7-🌟-null-和-undefined-的区别？\" class=\"headerlink\" title=\"7.🌟 null 和 undefined 的区别？\"></a>7.🌟 null 和 undefined 的区别？</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">- 基本数据类型 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 &#96;undefined&#96; 和 &#96;null&#96;\n- 含义不同\n- undefined 不是保留字\n- typeof null 为“object”\n- null 计算中被转化成 &#96;0&#96;, undefined 被转化成 &#96;NaN&#96;\n- undefined 是一个标识符,undefined 是全局对象的一个属性</code></pre>\n\n<h3 id=\"8-如何获取安全的-undefined-值？\"><a href=\"#8-如何获取安全的-undefined-值？\" class=\"headerlink\" title=\"8. 如何获取安全的 undefined 值？\"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 <code>undefined 是一个标识符</code>，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</p>\n<p><code>undefined 是全局对象的一个属性</code></p>\n<p>表达式 <code>void ___</code> 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</p>\n<p>按惯例我们用 void 0 来获得 undefined。</p>\n<h2 id=\"9-说几条写-JavaScript-的基本规范？\"><a href=\"#9-说几条写-JavaScript-的基本规范？\" class=\"headerlink\" title=\"9. 说几条写 JavaScript 的基本规范？\"></a>9. 说几条写 JavaScript 的基本规范？</h2><h2 id=\"原型-x2F-原型链\"><a href=\"#原型-x2F-原型链\" class=\"headerlink\" title=\"原型&#x2F;原型链\"></a>原型&#x2F;原型链</h2><h3 id=\"10-🌟-JavaScript-原型，原型链？-有什么特点？\"><a href=\"#10-🌟-JavaScript-原型，原型链？-有什么特点？\" class=\"headerlink\" title=\"10.🌟 JavaScript 原型，原型链？ 有什么特点？\"></a>10.🌟 JavaScript 原型，原型链？ 有什么特点？</h3><h3 id=\"11-js-获取原型的方法？\"><a href=\"#11-js-获取原型的方法？\" class=\"headerlink\" title=\"11. js 获取原型的方法？\"></a>11. js 获取原型的方法？</h3><h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h2><h3 id=\"12-在-js-中不同进制数字的表示方式\"><a href=\"#12-在-js-中不同进制数字的表示方式\" class=\"headerlink\" title=\"12. 在 js 中不同进制数字的表示方式\"></a>12. 在 js 中不同进制数字的表示方式</h3><h3 id=\"13-js-中整数的安全范围是多少？\"><a href=\"#13-js-中整数的安全范围是多少？\" class=\"headerlink\" title=\"13. js 中整数的安全范围是多少？\"></a>13. js 中整数的安全范围是多少？</h3><h3 id=\"14-typeof-NaN-的结果是什么？\"><a href=\"#14-typeof-NaN-的结果是什么？\" class=\"headerlink\" title=\"14. typeof NaN 的结果是什么？\"></a>14. typeof NaN 的结果是什么？</h3><h3 id=\"15-🌟-isNaN-和-Number-isNaN-函数的区别？\"><a href=\"#15-🌟-isNaN-和-Number-isNaN-函数的区别？\" class=\"headerlink\" title=\"15.🌟 isNaN 和 Number.isNaN 函数的区别？\"></a>15.🌟 isNaN 和 Number.isNaN 函数的区别？</h3><ul>\n<li><p><code>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true</code>，因此非数字值传入也<code>可能</code>会<br>返回 true ，会影响 NaN 的判断。</p>\n</li>\n<li><p><code>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN </code>，这种方法对于 NaN 的判断更为<br>准确</p>\n</li>\n</ul>\n<h2 id=\"16-Array-构造函数只有一个参数值时的表现？\"><a href=\"#16-Array-构造函数只有一个参数值时的表现？\" class=\"headerlink\" title=\"16. Array 构造函数只有一个参数值时的表现？\"></a>16. Array 构造函数只有一个参数值时的表现？</h2><h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; Array(); &#x2F;&#x2F; []\nvar b &#x3D; Array(1); &#x2F;&#x2F; [empty]\nb &#x3D;&#x3D; a; &#x2F;&#x2F; false\na[0] &#x3D;&#x3D; b[0]; &#x2F;&#x2F; true</code></pre>\n\n<h3 id=\"empty-是个什么东西？\"><a href=\"#empty-是个什么东西？\" class=\"headerlink\" title=\"empty 是个什么东西？\"></a>empty 是个什么东西？</h3><p><a href=\"https://segmentfault.com/q/1010000014236517\" target=\"_blank\" > empty 是个什么东西？</a></p>\n<h2 id=\"数据转换规则\"><a href=\"#数据转换规则\" class=\"headerlink\" title=\"数据转换规则\"></a>数据转换规则</h2><h3 id=\"17-其他值到字符串的转换规则？-ToString\"><a href=\"#17-其他值到字符串的转换规则？-ToString\" class=\"headerlink\" title=\"17. 其他值到字符串的转换规则？ ToString\"></a>17. 其他值到字符串的转换规则？ ToString</h3><p><a href=\"/#/post/2022-11-01抽象相等比较\" target=\"_blank\" >前端基础 - 抽象相等比较</a></p>\n<h4 id=\"补充-1\"><a href=\"#补充-1\" class=\"headerlink\" title=\"补充\"></a>补充</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Infinity.toString(); &#x2F;&#x2F; &quot;Infinity&quot;\nNaN.toString(); &#x2F;&#x2F; &quot;NaN&quot;</code></pre>\n\n<h4 id=\"基本数据类型使用-Object-prototype-toString\"><a href=\"#基本数据类型使用-Object-prototype-toString\" class=\"headerlink\" title=\"基本数据类型使用 Object.prototype.toString()\"></a>基本数据类型使用 Object.prototype.toString()</h4><p>基本数据类型全部返回 <code>[object Object]</code></p>\n<h3 id=\"18-其他值到数字值的转换规则？-ToNumber\"><a href=\"#18-其他值到数字值的转换规则？-ToNumber\" class=\"headerlink\" title=\"18. 其他值到数字值的转换规则？ ToNumber\"></a>18. 其他值到数字值的转换规则？ ToNumber</h3><p><a href=\"/#/post/2022-11-01抽象相等比较\" target=\"_blank\" >前端基础 - 抽象相等比较</a></p>\n<h3 id=\"19-其他值到布尔类型的值的转换规则？-ToBoolean\"><a href=\"#19-其他值到布尔类型的值的转换规则？-ToBoolean\" class=\"headerlink\" title=\"19. 其他值到布尔类型的值的转换规则？ ToBoolean\"></a>19. 其他值到布尔类型的值的转换规则？ ToBoolean</h3><p><a href=\"/#/post/2022-11-01抽象相等比较\" target=\"_blank\" >前端基础 - 抽象相等比较</a></p>\n<h3 id=\"20-和-的-valueOf-和-toString-的结果是什么？\"><a href=\"#20-和-的-valueOf-和-toString-的结果是什么？\" class=\"headerlink\" title=\"20. {} 和 [] 的 valueOf 和 toString 的结果是什么？\"></a>20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><p><a href=\"/#/post/2022-11-01抽象相等比较\" target=\"_blank\" >前端基础 - 抽象相等比较</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</code></pre>\n\n<h3 id=\"21-🌟-什么是假值对象？\"><a href=\"#21-🌟-什么是假值对象？\" class=\"headerlink\" title=\"21.🌟 什么是假值对象？\"></a>21.🌟 什么是假值对象？</h3><p><a href=\"/#/post/2022-11-01抽象相等比较\" target=\"_blank\" >前端基础 - 抽象相等比较</a></p>\n<p><code>充当效仿 undefined 的角色</code></p>\n<h3 id=\"22-操作符的作用？\"><a href=\"#22-操作符的作用？\" class=\"headerlink\" title=\"22. ~ 操作符的作用？\"></a>22. ~ 操作符的作用？</h3><h3 id=\"23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？\"><a href=\"#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？\" class=\"headerlink\" title=\"23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？\"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h3><ul>\n<li>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。</li>\n<li>而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN</li>\n</ul>\n<h3 id=\"24-操作符什么时候用于字符串的拼接？\"><a href=\"#24-操作符什么时候用于字符串的拼接？\" class=\"headerlink\" title=\"24. + 操作符什么时候用于字符串的拼接？\"></a>24. + 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其<br>中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以<br>数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p>\n<p><a href=\"/#/post/2022-11-01抽象相等比较\" target=\"_blank\" >前端基础 - 抽象相等比较</a></p>\n<h3 id=\"25-什么情况下会发生布尔值的隐式强制类型转换？\"><a href=\"#25-什么情况下会发生布尔值的隐式强制类型转换？\" class=\"headerlink\" title=\"25. 什么情况下会发生布尔值的隐式强制类型转换？\"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h3><h3 id=\"26-和-amp-amp-操作符的返回值？\"><a href=\"#26-和-amp-amp-操作符的返回值？\" class=\"headerlink\" title=\"26. || 和 &amp;&amp; 操作符的返回值？\"></a>26. || 和 &amp;&amp; 操作符的返回值？</h3><h3 id=\"27-Symbol-值的强制类型转换？\"><a href=\"#27-Symbol-值的强制类型转换？\" class=\"headerlink\" title=\"27. Symbol 值的强制类型转换？\"></a>27. Symbol 值的强制类型转换？</h3><h3 id=\"28-x3D-x3D-操作符的强制类型转换规则？\"><a href=\"#28-x3D-x3D-操作符的强制类型转换规则？\" class=\"headerlink\" title=\"28. &#x3D;&#x3D; 操作符的强制类型转换规则？\"></a>28. &#x3D;&#x3D; 操作符的强制类型转换规则？</h3><h3 id=\"29-如何将字符串转化为数字，例如-‘12-3b’\"><a href=\"#29-如何将字符串转化为数字，例如-‘12-3b’\" class=\"headerlink\" title=\"29. 如何将字符串转化为数字，例如 ‘12.3b’?\"></a>29. 如何将字符串转化为数字，例如 ‘12.3b’?</h3><p>（1）使用 <code>Number()</code> 方法，前提是所包含的字符串不包含不合法字符。</p>\n<p>（2）使用 <code>parseInt() </code>方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>\n<p>（3）使用 <code>parseFloat()</code> 方法，该函数解析一个字符串参数并返回一个浮点数。</p>\n<p>（4）使用 <code>+ 操作符的隐式转换</code>。 结果<code>NaN</code></p>\n<h3 id=\"30-🌟-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』\"><a href=\"#30-🌟-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』\" class=\"headerlink\" title=\"30.🌟 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?\"></a>30.🌟 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h3><p><a href=\"https://juejin.cn/post/6844903609029623815\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;\\B(?&#x3D;(\\d&#123;3&#125;)+(?!\\d))&#x2F;g;\n&#x2F;&#x2F; \\B非单词边界\n&#x2F;&#x2F; ?&#x3D; 先行断言   后面是  --\n&#x2F;&#x2F; ?! 后行断言， 后面不是 --</code></pre>\n\n<h2 id=\"31-常用正则表达式\"><a href=\"#31-常用正则表达式\" class=\"headerlink\" title=\"31. 常用正则表达式\"></a>31. 常用正则表达式</h2><h2 id=\"32-生成随机数的各种方法？\"><a href=\"#32-生成随机数的各种方法？\" class=\"headerlink\" title=\"32. 生成随机数的各种方法？\"></a>32. 生成随机数的各种方法？</h2><h2 id=\"33-如何实现数组的随机排序？\"><a href=\"#33-如何实现数组的随机排序？\" class=\"headerlink\" title=\"33. 如何实现数组的随机排序？\"></a>33. 如何实现数组的随机排序？</h2><h2 id=\"34-javascript-创建对象的几种方式？\"><a href=\"#34-javascript-创建对象的几种方式？\" class=\"headerlink\" title=\"34. javascript 创建对象的几种方式？\"></a>34. javascript 创建对象的几种方式？</h2><h2 id=\"35-JavaScript-继承的几种实现方式？\"><a href=\"#35-JavaScript-继承的几种实现方式？\" class=\"headerlink\" title=\"35. JavaScript 继承的几种实现方式？\"></a>35. JavaScript 继承的几种实现方式？</h2><h2 id=\"36-寄生式组合继承的实现？\"><a href=\"#36-寄生式组合继承的实现？\" class=\"headerlink\" title=\"36. 寄生式组合继承的实现？\"></a>36. 寄生式组合继承的实现？</h2><h2 id=\"37-🌟-Javascript-的作用域链？\"><a href=\"#37-🌟-Javascript-的作用域链？\" class=\"headerlink\" title=\"37.🌟 Javascript 的作用域链？\"></a>37.🌟 Javascript 的作用域链？</h2><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>函数。</p>\n<ul>\n<li>作用域链的本质：上是一个指向变量对象的指针列表。变量对象是一个<code>包含了执行环境中所有变量和函数</code>的对象。</li>\n<li>作用域链的前端:<code>始终都是当前执行上下文的变量对象</code>。</li>\n<li>作用域链的最后一个对象: <code>始终是全局执行上下文的变量对象（也就是全局对象)</code>。</li>\n</ul>\n<p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p>\n<p>作用域链的创建过程跟执行上下文的建立有关….</p>\n<h2 id=\"38-🌟-谈谈-This-对象的理解。\"><a href=\"#38-🌟-谈谈-This-对象的理解。\" class=\"headerlink\" title=\"38.🌟 谈谈 This 对象的理解。\"></a>38.🌟 谈谈 This 对象的理解。</h2><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模<br>式来判断。</p>\n<ul>\n<li>构造函数调用</li>\n<li>显示绑定调用 apply、call、bind</li>\n<li>属性方法调用</li>\n<li>函数调用，严格模式 undefined,非严格模式指向 window</li>\n</ul>\n<h2 id=\"39-eval-是做什么的？\"><a href=\"#39-eval-是做什么的？\" class=\"headerlink\" title=\"39. eval 是做什么的？\"></a>39. eval 是做什么的？</h2><h2 id=\"DOM-事件\"><a href=\"#DOM-事件\" class=\"headerlink\" title=\"DOM 事件\"></a>DOM 事件</h2><h3 id=\"40-什么是-DOM-和-BOM？\"><a href=\"#40-什么是-DOM-和-BOM？\" class=\"headerlink\" title=\"40. 什么是 DOM 和 BOM？\"></a>40. 什么是 DOM 和 BOM？</h3><h3 id=\"41-写一个通用的事件侦听器函数。\"><a href=\"#41-写一个通用的事件侦听器函数。\" class=\"headerlink\" title=\"41. 写一个通用的事件侦听器函数。\"></a>41. 写一个通用的事件侦听器函数。</h3><h3 id=\"42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？\"><a href=\"#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？\" class=\"headerlink\" title=\"42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？\"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><h3 id=\"43-🌟-三种事件模型是什么？\"><a href=\"#43-🌟-三种事件模型是什么？\" class=\"headerlink\" title=\"43. 🌟 三种事件模型是什么？\"></a>43. 🌟 三种事件模型是什么？</h3><p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p>\n<ul>\n<li><p><code>第一种事件模型是最早的 DOM0 级模型</code>，<code>这种模型不会传播，所以没有事件流的概念</code>，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p>\n</li>\n<li><p><code>第二种事件模型是 IE 事件模型</code>，在该事件模型中，<code>一次事件共有两个过程</code>，<code>事件处理阶段和事件冒泡阶段</code>。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p>\n</li>\n<li><p><code>第三种是 DOM2 级事件模型</code>，在该事件模型中，<code>一次事件共有三个过程</code>，</p>\n<ul>\n<li>第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>\n<li>后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中<code>第三个参数可以指定事件是否在捕获阶段执行</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>DOM2 级事件执行过程</strong></p>\n<ul>\n<li>绑定在被点击元素的事件是按照代码顺序发生。</li>\n<li>其他元素通过冒泡或者捕获“感知”的事件。</li>\n<li>按照 W3C 的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 。</li>\n</ul>\n<h3 id=\"44-事件委托是什么？\"><a href=\"#44-事件委托是什么？\" class=\"headerlink\" title=\"44. 事件委托是什么？\"></a>44. 事件委托是什么？</h3><h2 id=\"45-“1”-“2”-“3”-map-parseInt-答案是多少？\"><a href=\"#45-“1”-“2”-“3”-map-parseInt-答案是多少？\" class=\"headerlink\" title=\"45. [“1”, “2”, “3”].map(parseInt) 答案是多少？\"></a>45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</h2><h2 id=\"46-🌟-什么是闭包，为什么要用它？\"><a href=\"#46-🌟-什么是闭包，为什么要用它？\" class=\"headerlink\" title=\"46. 🌟 什么是闭包，为什么要用它？\"></a>46. 🌟 什么是闭包，为什么要用它？</h2><p>闭包: 是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以<br>访问到当前函数的局部变量。</p>\n<p><strong>闭包有两个常用的用途。</strong></p>\n<p><code>闭包的第一个用途</code>是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外<br>部访问到函数内部的变量，可以使用这种方法<code>来创建私有变量</code>。</p>\n<p><code>函数的另一个用途</code>是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以<br>这个<code>变量对象不会被回收</code>。</p>\n<p>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</p>\n<h2 id=\"47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？\"><a href=\"#47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？\" class=\"headerlink\" title=\"47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？\"></a>47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h2><p>use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</p>\n<p>设立”严格模式”的目的，主要有以下几个：</p>\n<ul>\n<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的 Javascript 做好铺垫</li>\n</ul>\n<h2 id=\"48-如何判断一个对象是否属于某个类？\"><a href=\"#48-如何判断一个对象是否属于某个类？\" class=\"headerlink\" title=\"48. 如何判断一个对象是否属于某个类？\"></a>48. 如何判断一个对象是否属于某个类？</h2><ul>\n<li><p><code>第一种方式</code>是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>\n</li>\n<li><p><code>第二种方式</code>可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p>\n</li>\n<li><p><code>第三种方式</code>，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的<br>[[Class]] 属性来进行判断。</p>\n</li>\n</ul>\n<h2 id=\"49-🌟-instanceof-的作用？\"><a href=\"#49-🌟-instanceof-的作用？\" class=\"headerlink\" title=\"49.🌟 instanceof 的作用？\"></a>49.🌟 instanceof 的作用？</h2><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置</p>\n<h2 id=\"50-🌟-new-操作符具体干了什么呢？如何实现？\"><a href=\"#50-🌟-new-操作符具体干了什么呢？如何实现？\" class=\"headerlink\" title=\"50.🌟 new 操作符具体干了什么呢？如何实现？\"></a>50.🌟 new 操作符具体干了什么呢？如何实现？</h2><p>（1）首先创建了一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>\n<h2 id=\"51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？\"><a href=\"#51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？\" class=\"headerlink\" title=\"51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？\"></a>51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h2><p><strong>hasOwnProperty</strong></p>\n<p>所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。<br>这个方法可以用来检测一个对象是否含有特定的自身属性，和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</p>\n<h2 id=\"52-对于-JSON-的了解？\"><a href=\"#52-对于-JSON-的了解？\" class=\"headerlink\" title=\"52. 对于 JSON 的了解？\"></a>52. 对于 JSON 的了解？</h2><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p>\n<p>在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p>\n<p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 _JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等_，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>\n<p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p>\n<p>另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</p>\n<h2 id=\"53-forEach-call-“”-function-a-a-style-outline-x3D-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？\"><a href=\"#53-forEach-call-“”-function-a-a-style-outline-x3D-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？\" class=\"headerlink\" title=\"53. [].forEach.call($$(“”),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？\"></a>53. [].forEach.call($$(“”),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</h2><h2 id=\"54-js-延迟加载的方式有哪些？\"><a href=\"#54-js-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"54. js 延迟加载的方式有哪些？\"></a>54. js 延迟加载的方式有哪些？</h2><p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p>\n<p>几种方式：</p>\n<ul>\n<li><p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p>\n</li>\n<li><p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p>\n</li>\n<li><p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p>\n</li>\n<li><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p>\n</li>\n</ul>\n<h2 id=\"55-🌟-Ajax-是什么-如何创建一个-Ajax？\"><a href=\"#55-🌟-Ajax-是什么-如何创建一个-Ajax？\" class=\"headerlink\" title=\"55.🌟 Ajax 是什么? 如何创建一个 Ajax？\"></a>55.🌟 Ajax 是什么? 如何创建一个 Ajax？</h2><h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><h3 id=\"56-谈一谈浏览器的缓存机制？\"><a href=\"#56-谈一谈浏览器的缓存机制？\" class=\"headerlink\" title=\"56. 谈一谈浏览器的缓存机制？\"></a>56. 谈一谈浏览器的缓存机制？</h3><h3 id=\"57-Ajax-解决浏览器缓存问题？\"><a href=\"#57-Ajax-解决浏览器缓存问题？\" class=\"headerlink\" title=\"57. Ajax 解决浏览器缓存问题？\"></a>57. Ajax 解决浏览器缓存问题？</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">1.在 XMLHttpRequest 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。\n2.在 XMLHttpRequest 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。\n3.在 URL 后面加上一个随机数： &quot;fresh&#x3D;&quot; + Math.random();。\n4.在 URL 后面加上时间戳：&quot;nowtime&#x3D;&quot; + new Date().getTime();。\n5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup(&#123;cache:false&#125;)。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。\n</code></pre>\n\n<h2 id=\"58-同步和异步的区别？\"><a href=\"#58-同步和异步的区别？\" class=\"headerlink\" title=\"58. 同步和异步的区别？\"></a>58. 同步和异步的区别？</h2><h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><h3 id=\"59-什么是浏览器的同源策略？\"><a href=\"#59-什么是浏览器的同源策略？\" class=\"headerlink\" title=\"59. 什么是浏览器的同源策略？\"></a>59. 什么是浏览器的同源策略？</h3><p>浏览器的同源策略的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。<br>这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。</p>\n<p>同源政策主要限制了三个方面</p>\n<ul>\n<li><p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p>\n</li>\n<li><p>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</p>\n</li>\n<li><p>第三个是当前域下 ajax 无法发送跨域请求。</p>\n</li>\n</ul>\n<p>同源政策的目的: 主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，<br>对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>\n<h3 id=\"60-🌟-如何解决跨域问题？\"><a href=\"#60-🌟-如何解决跨域问题？\" class=\"headerlink\" title=\"60.🌟 如何解决跨域问题？\"></a>60.🌟 如何解决跨域问题？</h3><p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p>\n<p><strong>如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</strong></p>\n<p>（1）将 <code>document.domain</code> 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</p>\n<p><strong>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</strong></p>\n<p>（2）使用 <code>location.hash</code> 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p>\n<p>（3）使用 <code>window.name</code> 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p>\n<p>（4）使用 <code>postMessage</code> 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</p>\n<p><strong>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</strong></p>\n<p>（5）使用 <code>jsonp</code> 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</p>\n<p>（6）使用 <code>CORS</code> 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</p>\n<p><strong>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</strong></p>\n<p>（7）使用 <code>websocket</code> 协议，这个协议没有同源限制。</p>\n<p>（8）使用<code>服务器来代理跨域的访问请求</code>，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p>\n<h3 id=\"61-服务器代理转发时，该如何处理-cookie？\"><a href=\"#61-服务器代理转发时，该如何处理-cookie？\" class=\"headerlink\" title=\"61. 服务器代理转发时，该如何处理 cookie？\"></a>61. 服务器代理转发时，该如何处理 cookie？</h3><h3 id=\"62-简单谈一下-cookie-？\"><a href=\"#62-简单谈一下-cookie-？\" class=\"headerlink\" title=\"62. 简单谈一下 cookie ？\"></a>62. 简单谈一下 cookie ？</h3><ul>\n<li><p>我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。</p>\n</li>\n<li><p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条 cookie 包括了 5 个属性值 <code>expires、domain、path、secure、HttpOnly</code>。</p>\n<ul>\n<li>其中 expires 指定了 cookie 失效的时间</li>\n<li>domain 是域名、path 是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。</li>\n<li>secure 规定了 cookie 只能在确保安全的情况下传输，</li>\n<li>HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</li>\n</ul>\n</li>\n<li><p>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</p>\n</li>\n</ul>\n<h2 id=\"模块加载\"><a href=\"#模块加载\" class=\"headerlink\" title=\"模块加载\"></a>模块加载</h2><h3 id=\"63-模块化开发怎么做？\"><a href=\"#63-模块化开发怎么做？\" class=\"headerlink\" title=\"63. 模块化开发怎么做？\"></a>63. 模块化开发怎么做？</h3><h3 id=\"64-js-的几种模块规范？\"><a href=\"#64-js-的几种模块规范？\" class=\"headerlink\" title=\"64. js 的几种模块规范？\"></a>64. js 的几种模块规范？</h3><p>js 中现在比较成熟的有四种模块加载方案。</p>\n<p><code>第一种是 CommonJS 方案</code>，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是<br>服务器端的解决方案，它是以同步的方式来引入模块的，<code>因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式 加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适</code></p>\n<p><code>第二种是 AMD 方案</code>，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定<br>义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p>\n<p><code>第三种是 CMD 方案</code>，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js<br>的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p>\n<p><code>第四种方案是 ES6 提出的方案</code>，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</p>\n<h3 id=\"65-AMD-和-CMD-规范的区别？\"><a href=\"#65-AMD-和-CMD-规范的区别？\" class=\"headerlink\" title=\"65. AMD 和 CMD 规范的区别？\"></a>65. AMD 和 CMD 规范的区别？</h3><h3 id=\"66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\"><a href=\"#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\" class=\"headerlink\" title=\"66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><h3 id=\"67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\"><a href=\"#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\" class=\"headerlink\" title=\"67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>\n<h3 id=\"68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？\"><a href=\"#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？\" class=\"headerlink\" title=\"68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？\"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h3><h2 id=\"69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西\"><a href=\"#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西\" class=\"headerlink\" title=\"69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?\"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h2><p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。</p>\n<p><em>在 class 中添加的方法，其实是添加在类的原型上的。</em></p>\n<h2 id=\"70-documen-write-和-innerHTML-的区别？\"><a href=\"#70-documen-write-和-innerHTML-的区别？\" class=\"headerlink\" title=\"70. documen.write 和 innerHTML 的区别？\"></a>70. documen.write 和 innerHTML 的区别？</h2><p>document.write 的内容会代替整个文档内容，<code>会重写整个页面</code>。</p>\n<p>innerHTML 的内容只是替代指定元素的内容，<code>只会重写页面中的部分内容</code>。</p>\n<h2 id=\"71-🌟-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\"><a href=\"#71-🌟-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\" class=\"headerlink\" title=\"71.🌟 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\"></a>71.🌟 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; (1）创建新节点\ncreateDocumentFragment(node);\ncreateElement(node);\ncreateTextNode(text);\n&#x2F;&#x2F; （2）添加、移除、替换、插入\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n&#x2F;&#x2F; （3）查找\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n&#x2F;&#x2F; （4）属性操作\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);</code></pre>\n\n<h2 id=\"72-innerHTML-与-outerHTML-的区别？\"><a href=\"#72-innerHTML-与-outerHTML-的区别？\" class=\"headerlink\" title=\"72. innerHTML 与 outerHTML 的区别？\"></a>72. innerHTML 与 outerHTML 的区别？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 对于这样一个 HTML 元素：&lt;div&gt;content&lt;br&#x2F;&gt;&lt;&#x2F;div&gt;。\n\n&#x2F;&#x2F; innerHTML：内部 HTML，content&lt;br&#x2F;&gt;；\n&#x2F;&#x2F; outerHTML：外部 HTML，&lt;div&gt;content&lt;br&#x2F;&gt;&lt;&#x2F;div&gt;；\n&#x2F;&#x2F; innerText：内部文本，content ；\n&#x2F;&#x2F; outerText：内部文本，content ；</code></pre>\n\n<h2 id=\"73-call-和-apply-的区别？\"><a href=\"#73-call-和-apply-的区别？\" class=\"headerlink\" title=\"73. .call() 和 .apply() 的区别？\"></a>73. .call() 和 .apply() 的区别？</h2><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>\n<p><em>apply 接受两个参数</em> ,<code>第一个参数指定了函数体内 this 对象的指向</code>，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p>\n<p><em>call 传入的参数数量不固定</em> ,跟 apply 相同的是，<code>第一个参数也是代表函数体内的 this 指向</code>，从第二个参数开始往后，每个参数被依次传入函数。</p>\n<h2 id=\"74-🌟JavaScript-类数组对象的定义？\"><a href=\"#74-🌟JavaScript-类数组对象的定义？\" class=\"headerlink\" title=\"74. 🌟JavaScript 类数组对象的定义？\"></a>74. 🌟JavaScript 类数组对象的定义？</h2><p><em>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法</em></p>\n<p>常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length<br>属性值，代表可接收的参数个数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 常见的类数组转换为数组的方法有这样几种：\n\n&#x2F;&#x2F; （1）通过 call 调用数组的 slice 方法来实现转换\nArray.prototype.slice.call(arrayLike);\n\n&#x2F;&#x2F; （2）通过 call 调用数组的 splice 方法来实现转换\nArray.prototype.splice.call(arrayLike, 0);\n\n&#x2F;&#x2F; （3）通过 apply 调用数组的 concat 方法来实现转换\nArray.prototype.concat.apply([], arrayLike);\n\n&#x2F;&#x2F; （4）通过 Array.from 方法来实现转换\nArray.from(arrayLike);</code></pre>\n\n<h2 id=\"75-🌟-数组和对象有哪些原生方法，列举一下？\"><a href=\"#75-🌟-数组和对象有哪些原生方法，列举一下？\" class=\"headerlink\" title=\"75.🌟 数组和对象有哪些原生方法，列举一下？\"></a>75.🌟 数组和对象有哪些原生方法，列举一下？</h2><h2 id=\"76-数组的-fill-方法？\"><a href=\"#76-数组的-fill-方法？\" class=\"headerlink\" title=\"76. 数组的 fill 方法？\"></a>76. 数组的 fill 方法？</h2><h2 id=\"77-🌟-的长度？\"><a href=\"#77-🌟-的长度？\" class=\"headerlink\" title=\"77.🌟 [,,,] 的长度？\"></a>77.🌟 [,,,] 的长度？</h2><p><code>长度为 3</code></p>\n<p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p>\n<p>JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</p>\n<p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数<br>量。</p>\n<h2 id=\"78-🌟-JavaScript-中的作用域与变量声明提升？\"><a href=\"#78-🌟-JavaScript-中的作用域与变量声明提升？\" class=\"headerlink\" title=\"78.🌟 JavaScript 中的作用域与变量声明提升？\"></a>78.🌟 JavaScript 中的作用域与变量声明提升？</h2><p>变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</p>\n<p><em>造成变量声明提升的本质原因</em>:<code>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象</code>。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</p>\n<h2 id=\"79-如何编写高性能的-Javascript-？\"><a href=\"#79-如何编写高性能的-Javascript-？\" class=\"headerlink\" title=\"79. 如何编写高性能的 Javascript ？\"></a>79. 如何编写高性能的 Javascript ？</h2><ol>\n<li>避免使用过深的嵌套循环。</li>\n<li>当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找</li>\n<li>循环能提前终止，要提前终止</li>\n<li>对象&#x2F;map 可以代替数组遍历</li>\n</ol>\n<h2 id=\"80-简单介绍一下-V8-引擎的垃圾回收机制\"><a href=\"#80-简单介绍一下-V8-引擎的垃圾回收机制\" class=\"headerlink\" title=\"80. 简单介绍一下 V8 引擎的垃圾回收机制\"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h2><h2 id=\"81-哪些操作会造成内存泄漏？\"><a href=\"#81-哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"81. 哪些操作会造成内存泄漏？\"></a>81. 哪些操作会造成内存泄漏？</h2><h2 id=\"82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？\"><a href=\"#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？\" class=\"headerlink\" title=\"82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？\"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h2><h2 id=\"83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）\"><a href=\"#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）\" class=\"headerlink\" title=\"83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）\"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h2><h2 id=\"84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？\"><a href=\"#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？\" class=\"headerlink\" title=\"84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？\"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h2><p>按照 HTML5 标准中的 HTML 语法规则，如果在 <code>&lt;/body&gt;</code>后再出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是 parse error，浏览器会忽略之前的<code>&lt;/body&gt;</code>，即视作仍旧在 body 内。</p>\n<p>所以实际效果和写在<code>&lt;/body&gt;</code>之前是没有区别的。总之，这种写法虽然也能 work，但是并没有带来任何额外好处，实际上出现这样的写法很可能是误解了“将 script 放在页面最末端”的教条。所以还是不要这样写为好。</p>\n<p>作者：贺师俊<br>链接：<a href=\"https://www.zhihu.com/question/20027966/answer/13727164\">https://www.zhihu.com/question/20027966/answer/13727164</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"85-移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？\"><a href=\"#85-移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？\" class=\"headerlink\" title=\"85. 移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？\"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？</h2><h2 id=\"86-什么是“前端路由”？-什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？\"><a href=\"#86-什么是“前端路由”？-什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？\" class=\"headerlink\" title=\"86. 什么是“前端路由”？ 什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？\"></a>86. 什么是“前端路由”？ 什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h2><h2 id=\"87-如何测试前端代码么？知道-BDD-TDD-Unit-Test-么？知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？\"><a href=\"#87-如何测试前端代码么？知道-BDD-TDD-Unit-Test-么？知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？\" class=\"headerlink\" title=\"87. 如何测试前端代码么？知道 BDD, TDD, Unit Test 么？知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？\"></a>87. 如何测试前端代码么？知道 BDD, TDD, Unit Test 么？知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h2><h2 id=\"88-检测浏览器版本版本有哪些方式？\"><a href=\"#88-检测浏览器版本版本有哪些方式？\" class=\"headerlink\" title=\"88. 检测浏览器版本版本有哪些方式？\"></a>88. 检测浏览器版本版本有哪些方式？</h2><p>检测浏览器版本一共有两种方式：</p>\n<p>_一种是检测 window.navigator.userAgent 的值_，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p>\n<p>_第二种方式是功能检测_，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p>\n<h2 id=\"89-什么是-Polyfill-？\"><a href=\"#89-什么是-Polyfill-？\" class=\"headerlink\" title=\"89. 什么是 Polyfill ？\"></a>89. 什么是 Polyfill ？</h2><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p>\n<h2 id=\"90-使用-JS-实现获取文件扩展名？\"><a href=\"#90-使用-JS-实现获取文件扩展名？\" class=\"headerlink\" title=\"90. 使用 JS 实现获取文件扩展名？\"></a>90. 使用 JS 实现获取文件扩展名？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。\n\n&#x2F;&#x2F; 对于 &#39;filename&#39; 和 &#39;.hiddenfile&#39; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。\n\n&#x2F;&#x2F; String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。\n\nfunction getFileExtension(filename) &#123;\n  return filename.slice(((filename.lastIndexOf(&quot;.&quot;) - 1) &gt;&gt;&gt; 0) + 2);\n&#125;</code></pre>\n\n<h2 id=\"91-介绍一下-js-的节流与防抖？\"><a href=\"#91-介绍一下-js-的节流与防抖？\" class=\"headerlink\" title=\"91. 介绍一下 js 的节流与防抖？\"></a>91. 介绍一下 js 的节流与防抖？</h2><h2 id=\"92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？\"><a href=\"#92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？\" class=\"headerlink\" title=\"92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？\"></a>92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h2><p>两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回 false）。</p>\n<p>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</p>\n<p><strong>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</strong></p>\n<h2 id=\"93-escape-encodeURI-encodeURIComponent-有什么区别？\"><a href=\"#93-escape-encodeURI-encodeURIComponent-有什么区别？\" class=\"headerlink\" title=\"93. escape,encodeURI,encodeURIComponent 有什么区别？\"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h2><p><code>encodeURI</code> 是对整个 URI 进行转义，<code>将 URI 中的非法字符转换为合法字符</code>，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p>\n<p><code>encodeURIComponent</code> 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p>\n<p><code>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别</code>，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</p>\n<h2 id=\"94-Unicode-和-UTF-8-之间的关系？\"><a href=\"#94-Unicode-和-UTF-8-之间的关系？\" class=\"headerlink\" title=\"94. Unicode 和 UTF-8 之间的关系？\"></a>94. Unicode 和 UTF-8 之间的关系？</h2><h3 id=\"utf8\"><a href=\"#utf8\" class=\"headerlink\" title=\"utf8\"></a>utf8</h3><p><strong>优点</strong></p>\n<ul>\n<li>UTF-8 编码可以通过屏蔽位和移位操作<code>快速读写</code>。</li>\n<li>字符串比较时 strcmp()和 wcscmp()的返回结果相同，因此使<code>排序变得更加容易</code>。</li>\n<li>字节 FF 和 FE 在 UTF-8 编码中永远不会出现，因此他们<code>可以用来区分 UTF-16 或 UTF-32 文本</code>。</li>\n<li>UTF-8 是<code>字节顺序无关的</code>。它的<code>字节顺序在所有系统中都是一样的</code>，因此它实际上并不需要 BOM。 [1]</li>\n<li>同时兼容 ASCII 编码</li>\n</ul>\n<p><strong>缺点</strong><br>你无法从 UNICODE 字符数判断出 UTF-8 文本的字节数，因为 UTF-8 采用的是不定长的编码方式。</p>\n<p><a href=\"https://baike.baidu.com/item/UTF-8/481798\" target=\"_blank\" >百度百科 UTF-8</a></p>\n<h2 id=\"95-js-的事件循环是什么？\"><a href=\"#95-js-的事件循环是什么？\" class=\"headerlink\" title=\"95. js 的事件循环是什么？\"></a>95. js 的事件循环是什么？</h2><h2 id=\"96-js-中的深浅拷贝实现？\"><a href=\"#96-js-中的深浅拷贝实现？\" class=\"headerlink\" title=\"96. js 中的深浅拷贝实现？\"></a>96. js 中的深浅拷贝实现？</h2><p><code>浅拷贝</code>指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。</p>\n<p><code>深拷贝</code>相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p>\n<h2 id=\"97-手写-call、apply-及-bind-函数\"><a href=\"#97-手写-call、apply-及-bind-函数\" class=\"headerlink\" title=\"97. 手写 call、apply 及 bind 函数\"></a>97. 手写 call、apply 及 bind 函数</h2><h2 id=\"98-函数柯里化的实现\"><a href=\"#98-函数柯里化的实现\" class=\"headerlink\" title=\"98. 函数柯里化的实现\"></a>98. 函数柯里化的实现</h2><h2 id=\"99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？\"><a href=\"#99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？\" class=\"headerlink\" title=\"99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？\"></a>99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</h2><h2 id=\"100-原码、反码和补码的介绍-101-toPrecision-和-toFixed-和-Math-round-的区别？\"><a href=\"#100-原码、反码和补码的介绍-101-toPrecision-和-toFixed-和-Math-round-的区别？\" class=\"headerlink\" title=\"100. 原码、反码和补码的介绍 101. toPrecision 和 toFixed 和 Math.round 的区别？\"></a>100. 原码、反码和补码的介绍 101. toPrecision 和 toFixed 和 Math.round 的区别？</h2><h2 id=\"102-什么是-XSS-攻击？如何防范-XSS-攻击？\"><a href=\"#102-什么是-XSS-攻击？如何防范-XSS-攻击？\" class=\"headerlink\" title=\"102. 什么是 XSS 攻击？如何防范 XSS 攻击？\"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h2><h2 id=\"注意点-SQL-注入不属于-XSS-攻击\"><a href=\"#注意点-SQL-注入不属于-XSS-攻击\" class=\"headerlink\" title=\"注意点 SQL 注入不属于 XSS 攻击\"></a>注意点 SQL 注入不属于 XSS 攻击</h2><p><strong>原因：SQL 注入，执行是在服务端执行，XSS 攻击是在客户端执行</strong></p>\n<h2 id=\"103-什么是-CSP？\"><a href=\"#103-什么是-CSP？\" class=\"headerlink\" title=\"103. 什么是 CSP？\"></a>103. 什么是 CSP？</h2><h2 id=\"104-什么是-CSRF-攻击？如何防范-CSRF-攻击？\"><a href=\"#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？\" class=\"headerlink\" title=\"104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？\"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><h2 id=\"105-什么是-Samesite-Cookie-属性？\"><a href=\"#105-什么是-Samesite-Cookie-属性？\" class=\"headerlink\" title=\"105. 什么是 Samesite Cookie 属性？\"></a>105. 什么是 Samesite Cookie 属性？</h2><h2 id=\"106-什么是点击劫持？如何防范点击劫持？\"><a href=\"#106-什么是点击劫持？如何防范点击劫持？\" class=\"headerlink\" title=\"106. 什么是点击劫持？如何防范点击劫持？\"></a>106. 什么是点击劫持？如何防范点击劫持？</h2><h2 id=\"107-SQL-注入攻击？\"><a href=\"#107-SQL-注入攻击？\" class=\"headerlink\" title=\"107. SQL 注入攻击？\"></a>107. SQL 注入攻击？</h2><h2 id=\"108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？\"><a href=\"#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？\" class=\"headerlink\" title=\"108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？\"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h2><h2 id=\"109-vue-双向数据绑定原理？\"><a href=\"#109-vue-双向数据绑定原理？\" class=\"headerlink\" title=\"109. vue 双向数据绑定原理？\"></a>109. vue 双向数据绑定原理？</h2><h2 id=\"110-Object-defineProperty-介绍？\"><a href=\"#110-Object-defineProperty-介绍？\" class=\"headerlink\" title=\"110. Object.defineProperty 介绍？\"></a>110. Object.defineProperty 介绍？</h2><h2 id=\"111-使用-Object-defineProperty-来进行数据劫持有什么缺点？\"><a href=\"#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？\" class=\"headerlink\" title=\"111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？\"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h2><h2 id=\"112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？\"><a href=\"#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？\" class=\"headerlink\" title=\"112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？\"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2><h2 id=\"113-如何比较两个-DOM-树的差异？\"><a href=\"#113-如何比较两个-DOM-树的差异？\" class=\"headerlink\" title=\"113. 如何比较两个 DOM 树的差异？\"></a>113. 如何比较两个 DOM 树的差异？</h2><h2 id=\"114-什么是-requestAnimationFrame-？\"><a href=\"#114-什么是-requestAnimationFrame-？\" class=\"headerlink\" title=\"114. 什么是 requestAnimationFrame ？\"></a>114. 什么是 requestAnimationFrame ？</h2><h2 id=\"115-谈谈你对-webpack-的看法-116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？\"><a href=\"#115-谈谈你对-webpack-的看法-116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？\" class=\"headerlink\" title=\"115. 谈谈你对 webpack 的看法 116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？\"></a>115. 谈谈你对 webpack 的看法 116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</h2><h2 id=\"117-谈一谈你理解的函数式编程？\"><a href=\"#117-谈一谈你理解的函数式编程？\" class=\"headerlink\" title=\"117. 谈一谈你理解的函数式编程？\"></a>117. 谈一谈你理解的函数式编程？</h2><h2 id=\"118-异步编程的实现方式？\"><a href=\"#118-异步编程的实现方式？\" class=\"headerlink\" title=\"118. 异步编程的实现方式？\"></a>118. 异步编程的实现方式？</h2><h2 id=\"119-Js-动画与-CSS-动画区别及相应实现\"><a href=\"#119-Js-动画与-CSS-动画区别及相应实现\" class=\"headerlink\" title=\"119. Js 动画与 CSS 动画区别及相应实现\"></a>119. Js 动画与 CSS 动画区别及相应实现</h2><h2 id=\"120-get-请求传参长度的误区\"><a href=\"#120-get-请求传参长度的误区\" class=\"headerlink\" title=\"120. get 请求传参长度的误区\"></a>120. get 请求传参长度的误区</h2><h2 id=\"121-URL-和-URI-的区别？\"><a href=\"#121-URL-和-URI-的区别？\" class=\"headerlink\" title=\"121. URL 和 URI 的区别？\"></a>121. URL 和 URI 的区别？</h2><h2 id=\"122-get-和-post-请求在缓存方面的区别\"><a href=\"#122-get-和-post-请求在缓存方面的区别\" class=\"headerlink\" title=\"122. get 和 post 请求在缓存方面的区别\"></a>122. get 和 post 请求在缓存方面的区别</h2><h2 id=\"123-图片的懒加载和预加载\"><a href=\"#123-图片的懒加载和预加载\" class=\"headerlink\" title=\"123. 图片的懒加载和预加载\"></a>123. 图片的懒加载和预加载</h2><h2 id=\"124-mouseover-和-mouseenter-的区别？\"><a href=\"#124-mouseover-和-mouseenter-的区别？\" class=\"headerlink\" title=\"124. mouseover 和 mouseenter 的区别？\"></a>124. mouseover 和 mouseenter 的区别？</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>mouseenter: <code>当鼠标指针从它后代的物理空间移动到它自己的物理空间时，它不会冒泡，也不会发送给它的任何后代</code></li>\n<li>mouseover: <code>可能会存在性能问题</code>。层次结构很深，发送到 mouseover 事件可能相当多，并导致严重的<code>性能问题</code>。在这种情况下，最好是监听 mouseenter 事件。</li>\n<li>mouseleave（当鼠标退出其内容区域时向元素触发），mouseenter 事件的作用与 CSS 伪类 <code>:hover</code> 非常相似</li>\n</ul>\n<h3 id=\"对应关系\"><a href=\"#对应关系\" class=\"headerlink\" title=\"对应关系\"></a>对应关系</h3><ul>\n<li>mouseenter&#x2F;mouseleave</li>\n<li>mouseover&#x2F;mouseout 冒泡</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseenter_event\" target=\"_blank\" >MDN mouseenter_event</a></p>\n<h2 id=\"125-js-拖拽功能的实现\"><a href=\"#125-js-拖拽功能的实现\" class=\"headerlink\" title=\"125. js 拖拽功能的实现\"></a>125. js 拖拽功能的实现</h2><h2 id=\"126-为什么使用-setTimeout-实现-setInterval？怎么模拟？\"><a href=\"#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？\" class=\"headerlink\" title=\"126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？\"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h2><h3 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，<br>但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，<br>只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。</p>\n<h3 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h3><p>所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p>\n<h2 id=\"127-let-和-const-的注意点？\"><a href=\"#127-let-和-const-的注意点？\" class=\"headerlink\" title=\"127. let 和 const 的注意点？\"></a>127. let 和 const 的注意点？</h2><h2 id=\"128-什么是-rest-参数？\"><a href=\"#128-什么是-rest-参数？\" class=\"headerlink\" title=\"128. 什么是 rest 参数？\"></a>128. 什么是 rest 参数？</h2><h2 id=\"129-什么是尾调用，使用尾调用有什么好处？\"><a href=\"#129-什么是尾调用，使用尾调用有什么好处？\" class=\"headerlink\" title=\"129. 什么是尾调用，使用尾调用有什么好处？\"></a>129. 什么是尾调用，使用尾调用有什么好处？</h2><h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>尾调用指的是函数的最后一步调用另一个函数。</p>\n<h3 id=\"本质-1\"><a href=\"#本质-1\" class=\"headerlink\" title=\"本质\"></a>本质</h3><p>我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。</p>\n<p>使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>\n<h2 id=\"130-Symbol-类型的注意点？\"><a href=\"#130-Symbol-类型的注意点？\" class=\"headerlink\" title=\"130. Symbol 类型的注意点？\"></a>130. Symbol 类型的注意点？</h2><ol>\n<li>Symbol 函数前<code>不能使用 new 命令</code>，否则会报错。</li>\n<li>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li>\n<li>Symbol 作为属性名，该属性不会出现在 <code>for...in</code>、<code>for...of</code> 循环中，也不会被<code> Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。</li>\n<li>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li>\n<li>Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li>\n<li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li>\n<li>获取 Symbol 括号内的值(description)，用 Symbol.prototype.description</li>\n</ol>\n<h2 id=\"131-Set-和-WeakSet-结构？\"><a href=\"#131-Set-和-WeakSet-结构？\" class=\"headerlink\" title=\"131. Set 和 WeakSet 结构？\"></a>131. Set 和 WeakSet 结构？</h2><ul>\n<li>WeakSet 弱引用，假设，除了 WeakSet 之外没有其他的引用，那么垃圾回收机制，可能被回收</li>\n</ul>\n<h2 id=\"132-Map-和-WeakMap-结构？\"><a href=\"#132-Map-和-WeakMap-结构？\" class=\"headerlink\" title=\"132. Map 和 WeakMap 结构？\"></a>132. Map 和 WeakMap 结构？</h2><h3 id=\"Map-与-Object-的区别\"><a href=\"#Map-与-Object-的区别\" class=\"headerlink\" title=\"Map 与 Object 的区别\"></a>Map 与 Object 的区别</h3><ul>\n<li>Object 本质上是哈希结构的键值对的集合，它只能用字符串、数字或者 Symbol 等简单数据类型</li>\n<li>Map 类继承了 Object，并对 Object 功能做了一些拓展，Map 的键可以是任意的数据类型。</li>\n<li>Map 技高一筹,他的 <code>key 既可以是基本数据类型，也可以是引用数据类型</code></li>\n<li>Map 实现了迭代器，可用 for…of 遍历，而 Object 不行。</li>\n<li>Map 可以直接拿到长度，而 Object 不行。 填入 Map 的元素，会保持原有的顺序，而 Object</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/94cf51649517\" target=\"_blank\" >这篇文章，“同名碰撞写的有问题”</a></p>\n<p><strong>obj[key] &#x3D; value 实际上是</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function processingKey(key) &#123;\n  if (key &#x3D;&#x3D;&#x3D; undefined) &#123;\n    return &quot;undefined&quot;;\n  &#125; else if (key &#x3D;&#x3D;&#x3D; null) &#123;\n    return &quot;null&quot;;\n  &#125; else &#123;\n    return key.toString();\n  &#125;\n&#125;\nobj[processingKey(key)] &#x3D; value;</code></pre>\n\n<p><a href=\"https://juejin.cn/post/6844904000827949064\" target=\"_blank\" >[js 行为研究] 对象作为对象的键会发生什么？</a></p>\n<h2 id=\"133-什么是-Proxy-？\"><a href=\"#133-什么是-Proxy-？\" class=\"headerlink\" title=\"133. 什么是 Proxy ？\"></a>133. 什么是 Proxy ？</h2><p><a href=\"/#/post/2022-06-10js-数据劫持\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2022-06-10js-数据劫持</a></p>\n<p><a href=\"/#/post/2022-07-04js\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2022-07-04js 数据劫持</a></p>\n<h2 id=\"134-Reflect-对象创建目的？\"><a href=\"#134-Reflect-对象创建目的？\" class=\"headerlink\" title=\"134. Reflect 对象创建目的？\"></a>134. Reflect 对象创建目的？</h2><h3 id=\"问题：-ES6-Proxy-里面为什么要用-Reflect？\"><a href=\"#问题：-ES6-Proxy-里面为什么要用-Reflect？\" class=\"headerlink\" title=\"问题： ES6 Proxy 里面为什么要用 Reflect？\"></a>问题： <a href=\"https://www.zhihu.com/question/460133198\" target=\"_blank\" >ES6 Proxy 里面为什么要用 Reflect？</a></h3><p>Proxy &amp; Reflect 的话题</p>\n<ul>\n<li><p>Proxy 代理，它内置了一系列”陷阱“用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>\n</li>\n<li><p>Reflect 反射，它提供拦截 JavaScript 操作的方法。这些方法与 Proxy 的方法相同。</p>\n</li>\n<li><p>简单来说，我们可以通过 Proxy 创建对于原始对象的代理对象，从而在代理对象中使用 - Reflect 达到对于 JavaScript 原始操作的拦截。</p>\n</li>\n</ul>\n<p>作者：WangHaoyu<br>链接：<a href=\"https://www.zhihu.com/question/460133198/answer/2416115070\">https://www.zhihu.com/question/460133198/answer/2416115070</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"为什么-Proxy-amp-Reflect-联合使用\"><a href=\"#为什么-Proxy-amp-Reflect-联合使用\" class=\"headerlink\" title=\"为什么 Proxy &amp; Reflect 联合使用\"></a>为什么 Proxy &amp; Reflect 联合使用</h3><ul>\n<li>是为了和 Proxy 的 API 对应上，是为触发代理对象的劫持时保证正确的 this 上下文指向</li>\n<li>Proxy 中 receiver 存在的意义就是为了正确的在陷阱中传递上下文</li>\n<li>Reflect.get(target, key, receiver) 可理解成为 target[key].call(receiver)</li>\n</ul>\n<h2 id=\"135-require-模块引入的查找方式？\"><a href=\"#135-require-模块引入的查找方式？\" class=\"headerlink\" title=\"135. require 模块引入的查找方式？\"></a>135. require 模块引入的查找方式？</h2><p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p>\n<p>（1）如果 X 是内置模块（比如 require(‘http’)）<br>　　 a. 返回该模块。<br>　　 b. 不再继续执行。</p>\n<p>（2）如果 X 以 “.&#x2F;“ 或者 “&#x2F;“ 或者 “..&#x2F;“ 开头<br>　　 a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　 b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</p>\n<pre><code><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; X\n&#x2F;&#x2F; X.js\n&#x2F;&#x2F; X.json\n&#x2F;&#x2F; X.node</code></pre>\nc. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; X&#x2F;package.json（main 字段）\n&#x2F;&#x2F; X&#x2F;index.js\n&#x2F;&#x2F; X&#x2F;index.json\n&#x2F;&#x2F; X&#x2F;index.node</code></pre>\n</code></pre>\n<p>（3）如果 X 不带路径<br>　　 a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　 b. 依次在每个目录中，将 X 当成文件名或目录名加载。</p>\n<p>（4）抛出 “not found”</p>\n<h2 id=\"136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？\"><a href=\"#136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？\" class=\"headerlink\" title=\"136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？\"></a>136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？</h2><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。<br>Promises&#x2F;A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p>\n<p><code>Promise 是一个构造函数</code>，接收一个函数作为参数，返回<code>一个 Promise 实例</code>。<br><code>一个 Promise 实例</code>有三种状态，分别是 <code>pending</code>、<code>resolved</code> 和 <code>rejected</code>，分别代表了进行中、已成功和已失败。<br>实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p>\n<p>状态的改变是通过 <code>resolve()</code> 和 <code>reject()</code> 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>\n<h2 id=\"137-手写一个-Promise\"><a href=\"#137-手写一个-Promise\" class=\"headerlink\" title=\"137. 手写一个 Promise\"></a>137. 手写一个 Promise</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const PENDING &#x3D; &quot;pending&quot;;\nconst RESOLVED &#x3D; &quot;resolved&quot;;\nconst REJECTED &#x3D; &quot;rejected&quot;;\n\nfunction MyPromise(fn) &#123;\n  &#x2F;&#x2F; 保存初始化状态\n  var self &#x3D; this;\n\n  &#x2F;&#x2F; 初始化状态\n  this.state &#x3D; PENDING;\n\n  &#x2F;&#x2F; 用于保存 resolve 或者 rejected 传入的值\n  this.value &#x3D; null;\n\n  &#x2F;&#x2F; 用于保存 resolve 的回调函数\n  this.resolvedCallbacks &#x3D; [];\n\n  &#x2F;&#x2F; 用于保存 reject 的回调函数\n  this.rejectedCallbacks &#x3D; [];\n\n  &#x2F;&#x2F; 状态转变为 resolved 方法\n  function resolve(value) &#123;\n    &#x2F;&#x2F; 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变\n    if (value instanceof MyPromise) &#123;\n      return value.then(resolve, reject);\n    &#125;\n\n    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 只有状态为 pending 时才能转变，\n      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;\n        &#x2F;&#x2F; 修改状态\n        self.state &#x3D; RESOLVED;\n\n        &#x2F;&#x2F; 设置传入的值\n        self.value &#x3D; value;\n\n        &#x2F;&#x2F; 执行回调函数\n        self.resolvedCallbacks.forEach((callback) &#x3D;&gt; &#123;\n          callback(value);\n        &#125;);\n      &#125;\n    &#125;, 0);\n  &#125;\n\n  &#x2F;&#x2F; 状态转变为 rejected 方法\n  function reject(value) &#123;\n    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 只有状态为 pending 时才能转变\n      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;\n        &#x2F;&#x2F; 修改状态\n        self.state &#x3D; REJECTED;\n\n        &#x2F;&#x2F; 设置传入的值\n        self.value &#x3D; value;\n\n        &#x2F;&#x2F; 执行回调函数\n        self.rejectedCallbacks.forEach((callback) &#x3D;&gt; &#123;\n          callback(value);\n        &#125;);\n      &#125;\n    &#125;, 0);\n  &#125;\n\n  &#x2F;&#x2F; 将两个方法传入函数执行\n  try &#123;\n    fn(resolve, reject);\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; 遇到错误时，捕获错误，执行 reject 函数\n    reject(e);\n  &#125;\n&#125;\n\nMyPromise.prototype.then &#x3D; function (onResolved, onRejected) &#123;\n  &#x2F;&#x2F; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数\n  onResolved &#x3D;\n    typeof onResolved &#x3D;&#x3D;&#x3D; &quot;function&quot;\n      ? onResolved\n      : function (value) &#123;\n          return value;\n        &#125;;\n\n  onRejected &#x3D;\n    typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot;\n      ? onRejected\n      : function (error) &#123;\n          throw error;\n        &#125;;\n\n  &#x2F;&#x2F; 如果是等待状态，则将函数加入对应列表中\n  if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;\n    this.resolvedCallbacks.push(onResolved);\n    this.rejectedCallbacks.push(onRejected);\n  &#125;\n\n  &#x2F;&#x2F; 如果状态已经凝固，则直接执行对应状态的函数\n\n  if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;\n    onResolved(this.value);\n  &#125;\n\n  if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;\n    onRejected(this.value);\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"138-如何检测浏览器所支持的最小字体大小？\"><a href=\"#138-如何检测浏览器所支持的最小字体大小？\" class=\"headerlink\" title=\"138. 如何检测浏览器所支持的最小字体大小？\"></a>138. 如何检测浏览器所支持的最小字体大小？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function isSupportFontSize(size) &#123;\n  &#x2F;&#x2F; 创建dom，设置字体大小，挂在dom,获取字体\n  let pdom &#x3D; document.createElement(&quot;p&quot;);\n  pdom.style.fontSize &#x3D; size + &quot;px&quot;;\n\n  document.body.append(pdom);\n\n  function getstyle(obj, key) &#123;\n    if (obj.currentStyle) &#123;\n      return obj.currentStyle[key];\n    &#125; else &#123;\n      return getComputedStyle(obj, false)[key];\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 验证是否一致\n  return parseFloat(getstyle(pdom, &quot;fontSize&quot;)) &#x3D;&#x3D; size;\n&#125;\n\nisSupportFontSize(10);</code></pre>\n\n<h2 id=\"139-怎么做-JS-代码-Error-统计？\"><a href=\"#139-怎么做-JS-代码-Error-统计？\" class=\"headerlink\" title=\"139. 怎么做 JS 代码 Error 统计？\"></a>139. 怎么做 JS 代码 Error 统计？</h2><p>error 统计使用浏览器的 window.error 事件。</p>\n<h2 id=\"140-单例模式模式是什么？\"><a href=\"#140-单例模式模式是什么？\" class=\"headerlink\" title=\"140. 单例模式模式是什么？\"></a>140. 单例模式模式是什么？</h2><p><code>单例模式保证了全局只有一个实例来被访问</code>。比如说常用的如弹框组件的实现和全局状态的实现。</p>\n<h2 id=\"141-策略模式是什么？\"><a href=\"#141-策略模式是什么？\" class=\"headerlink\" title=\"141. 策略模式是什么？\"></a>141. 策略模式是什么？</h2><p><code>策略模式主要是用来将方法的实现和方法的调用分离开</code>，外部通过不同的参数可以调用不同的策略。主要在 MVP 模式解耦的时候<br>用来将视图层的方法定义和方法调用分离。</p>\n<h2 id=\"142-代理模式是什么？\"><a href=\"#142-代理模式是什么？\" class=\"headerlink\" title=\"142. 代理模式是什么？\"></a>142. 代理模式是什么？</h2><p>代理模式是为<code>一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理</code>。</p>\n<h2 id=\"143-中介者模式是什么？\"><a href=\"#143-中介者模式是什么？\" class=\"headerlink\" title=\"143. 中介者模式是什么？\"></a>143. 中介者模式是什么？</h2><p>中介者模式指的是，<code>多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦</code></p>\n<h2 id=\"144-适配器模式是什么？\"><a href=\"#144-适配器模式是什么？\" class=\"headerlink\" title=\"144. 适配器模式是什么？\"></a>144. 适配器模式是什么？</h2><p><code>适配器用来解决两个接口不兼容的情况</code>，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种<br>新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种<br>自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</p>\n<h2 id=\"145-观察者模式和发布订阅模式有什么不同？\"><a href=\"#145-观察者模式和发布订阅模式有什么不同？\" class=\"headerlink\" title=\"145. 观察者模式和发布订阅模式有什么不同？\"></a>145. 观察者模式和发布订阅模式有什么不同？</h2><p><code>发布订阅模式其实属于广义上的观察者模式</code></p>\n<ul>\n<li><p><code>在观察者模式中</code>，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p>\n</li>\n<li><p><code>而在发布订阅模式中</code>，<code>发布者和订阅者之间多了一个调度中心</code>。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</p>\n</li>\n</ul>\n<h2 id=\"146-Vue-的生命周期是什么？\"><a href=\"#146-Vue-的生命周期是什么？\" class=\"headerlink\" title=\"146. Vue 的生命周期是什么？\"></a>146. Vue 的生命周期是什么？</h2><h2 id=\"147-Vue-的各个生命阶段是什么？\"><a href=\"#147-Vue-的各个生命阶段是什么？\" class=\"headerlink\" title=\"147. Vue 的各个生命阶段是什么？\"></a>147. Vue 的各个生命阶段是什么？</h2><h2 id=\"148-Vue-组件间的参数传递方式？\"><a href=\"#148-Vue-组件间的参数传递方式？\" class=\"headerlink\" title=\"148. Vue 组件间的参数传递方式？\"></a>148. Vue 组件间的参数传递方式？</h2><h2 id=\"149-computed-和-watch-的差异？\"><a href=\"#149-computed-和-watch-的差异？\" class=\"headerlink\" title=\"149. computed 和 watch 的差异？\"></a>149. computed 和 watch 的差异？</h2><h2 id=\"150-vue-router-中的导航钩子函数\"><a href=\"#150-vue-router-中的导航钩子函数\" class=\"headerlink\" title=\"150. vue-router 中的导航钩子函数\"></a>150. vue-router 中的导航钩子函数</h2><h2 id=\"151-route-和-router-的区别？\"><a href=\"#151-route-和-router-的区别？\" class=\"headerlink\" title=\"151. $route 和 $router 的区别？\"></a>151. $route 和 $router 的区别？</h2><h2 id=\"152-vue-常用的修饰符？\"><a href=\"#152-vue-常用的修饰符？\" class=\"headerlink\" title=\"152. vue 常用的修饰符？\"></a>152. vue 常用的修饰符？</h2><h2 id=\"153-vue-中-key-值的作用？\"><a href=\"#153-vue-中-key-值的作用？\" class=\"headerlink\" title=\"153. vue 中 key 值的作用？\"></a>153. vue 中 key 值的作用？</h2><h2 id=\"154-computed-和-watch-区别？\"><a href=\"#154-computed-和-watch-区别？\" class=\"headerlink\" title=\"154. computed 和 watch 区别？\"></a>154. computed 和 watch 区别？</h2><h2 id=\"155-keep-alive-组件有什么作用？\"><a href=\"#155-keep-alive-组件有什么作用？\" class=\"headerlink\" title=\"155. keep-alive 组件有什么作用？\"></a>155. keep-alive 组件有什么作用？</h2><h2 id=\"156-vue-中-mixin-和-mixins-区别？\"><a href=\"#156-vue-中-mixin-和-mixins-区别？\" class=\"headerlink\" title=\"156. vue 中 mixin 和 mixins 区别？\"></a>156. vue 中 mixin 和 mixins 区别？</h2><h2 id=\"157-开发中常用的几种-Content-Type-？\"><a href=\"#157-开发中常用的几种-Content-Type-？\" class=\"headerlink\" title=\"157. 开发中常用的几种 Content-Type ？\"></a>157. 开发中常用的几种 Content-Type ？</h2><h2 id=\"158-如何封装一个-javascript-的类型判断函数？\"><a href=\"#158-如何封装一个-javascript-的类型判断函数？\" class=\"headerlink\" title=\"158. 如何封装一个 javascript 的类型判断函数？\"></a>158. 如何封装一个 javascript 的类型判断函数？</h2><h2 id=\"159-如何判断一个对象是否为空对象？\"><a href=\"#159-如何判断一个对象是否为空对象？\" class=\"headerlink\" title=\"159. 如何判断一个对象是否为空对象？\"></a>159. 如何判断一个对象是否为空对象？</h2><h2 id=\"160-使用闭包实现每隔一秒打印-1-2-3-4\"><a href=\"#160-使用闭包实现每隔一秒打印-1-2-3-4\" class=\"headerlink\" title=\"160. 使用闭包实现每隔一秒打印 1,2,3,4\"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h2><h2 id=\"161-手写一个-jsonp\"><a href=\"#161-手写一个-jsonp\" class=\"headerlink\" title=\"161. 手写一个 jsonp\"></a>161. 手写一个 jsonp</h2><h2 id=\"162-手写一个观察者模式？\"><a href=\"#162-手写一个观察者模式？\" class=\"headerlink\" title=\"162. 手写一个观察者模式？\"></a>162. 手写一个观察者模式？</h2><h2 id=\"163-EventEmitter-实现\"><a href=\"#163-EventEmitter-实现\" class=\"headerlink\" title=\"163. EventEmitter 实现\"></a>163. EventEmitter 实现</h2><h2 id=\"164-一道常被人轻视的前端-JS-面试题\"><a href=\"#164-一道常被人轻视的前端-JS-面试题\" class=\"headerlink\" title=\"164. 一道常被人轻视的前端 JS 面试题\"></a>164. 一道常被人轻视的前端 JS 面试题</h2><h2 id=\"165-如何确定页面的可用性时间，什么是-Performance-API？\"><a href=\"#165-如何确定页面的可用性时间，什么是-Performance-API？\" class=\"headerlink\" title=\"165. 如何确定页面的可用性时间，什么是 Performance API？\"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h2><h2 id=\"166-js-中的命名规则\"><a href=\"#166-js-中的命名规则\" class=\"headerlink\" title=\"166. js 中的命名规则\"></a>166. js 中的命名规则</h2><h2 id=\"167-js-语句末尾分号是否可以省略？\"><a href=\"#167-js-语句末尾分号是否可以省略？\" class=\"headerlink\" title=\"167. js 语句末尾分号是否可以省略？\"></a>167. js 语句末尾分号是否可以省略？</h2><h2 id=\"168-Object-assign\"><a href=\"#168-Object-assign\" class=\"headerlink\" title=\"168. Object.assign()\"></a>168. Object.assign()</h2><h2 id=\"169-Math-ceil-和-Math-floor\"><a href=\"#169-Math-ceil-和-Math-floor\" class=\"headerlink\" title=\"169. Math.ceil 和 Math.floor\"></a>169. Math.ceil 和 Math.floor</h2><h2 id=\"170-js-for-循环注意点\"><a href=\"#170-js-for-循环注意点\" class=\"headerlink\" title=\"170. js for 循环注意点\"></a>170. js for 循环注意点</h2><h2 id=\"171-一个列表，假设有-100000-个数据，这个该怎么办？\"><a href=\"#171-一个列表，假设有-100000-个数据，这个该怎么办？\" class=\"headerlink\" title=\"171. 一个列表，假设有 100000 个数据，这个该怎么办？\"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h2><h2 id=\"172-js-中倒计时的纠偏实现？\"><a href=\"#172-js-中倒计时的纠偏实现？\" class=\"headerlink\" title=\"172. js 中倒计时的纠偏实现？\"></a>172. js 中倒计时的纠偏实现？</h2><h2 id=\"173-进程间通信的方式？\"><a href=\"#173-进程间通信的方式？\" class=\"headerlink\" title=\"173. 进程间通信的方式？\"></a>173. 进程间通信的方式？</h2><h2 id=\"174-如何查找一篇英文文章中出现频率最高的单词？\"><a href=\"#174-如何查找一篇英文文章中出现频率最高的单词？\" class=\"headerlink\" title=\"174. 如何查找一篇英文文章中出现频率最高的单词？\"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h2><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h2 id=\"JS-为什么不能直接赋值-undefined-？\"><a href=\"#JS-为什么不能直接赋值-undefined-？\" class=\"headerlink\" title=\"JS 为什么不能直接赋值 undefined ？\"></a>JS 为什么不能直接赋值 undefined ？</h2><p><a href=\"https://juejin.cn/post/7113217396801798151\" target=\"_blank\" >JS 为什么不能直接赋值 undefined ？</a></p>\n<p>低级浏览器可以被改写，不安全</p>\n<h2 id=\"进制表示\"><a href=\"#进制表示\" class=\"headerlink\" title=\"进制表示\"></a>进制表示</h2><ul>\n<li>十六进制 hexadecimal <code>0x</code></li>\n<li>八进制 octal <code>0O</code></li>\n<li>二进制 binary <code>0b</code></li>\n<li>十进制 decimal</li>\n</ul>\n<p><a href=\"https://www.zhihu.com/question/66324454\" target=\"_blank\" >见</a></p>\n<h2 id=\"CommonJS-AMD-CMD-全称\"><a href=\"#CommonJS-AMD-CMD-全称\" class=\"headerlink\" title=\"CommonJS,AMD,CMD 全称\"></a>CommonJS,AMD,CMD 全称</h2><h3 id=\"全称\"><a href=\"#全称\" class=\"headerlink\" title=\"全称\"></a>全称</h3><ul>\n<li><p>AMD 规范:全称<code>Asynchronous Module Definition</code>，称为 异步模块加载规范 。一般应用在浏览器端。流行的浏览器端异步加载库 RequireJS 实现的就是 AMD 规范。</p>\n</li>\n<li><p>CMD 规范，全称<code>Common Module Definition</code>，称为 通用模块加载规范。一般也是用在浏览器端。浏览器端异步加载库 Sea.js 实现的就是 CMD 规范。</p>\n</li>\n<li><p>CommonJS: 称为同步模块加载规范，也就是说，只有加载完成，才能执行后面的操作。</p>\n</li>\n</ul>\n<p>AMD 特点: 依赖前置，提前执行!<br>CMD 特点: 依赖就近，延迟执行!</p>\n<h3 id=\"CMD-与-AMD-区别\"><a href=\"#CMD-与-AMD-区别\" class=\"headerlink\" title=\"CMD 与 AMD 区别\"></a>CMD 与 AMD 区别</h3><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。<br>CMD 推崇依赖就近，AMD 推崇依赖前置。</p>\n<h3 id=\"nodejs-为什么使用-commonjs-规范\"><a href=\"#nodejs-为什么使用-commonjs-规范\" class=\"headerlink\" title=\"nodejs 为什么使用 commonjs 规范\"></a>nodejs 为什么使用 commonjs 规范</h3><p>因为 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式。但如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范</p>\n<p>作者：一点代码<br>链接：<a href=\"https://www.jianshu.com/p/65ab05d3cdeb\">https://www.jianshu.com/p/65ab05d3cdeb</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"class-是-prototype-的语法糖？\"><a href=\"#class-是-prototype-的语法糖？\" class=\"headerlink\" title=\"class 是 prototype 的语法糖？\"></a>class 是 prototype 的语法糖？</h2><ul>\n<li>两者如何增加属性？</li>\n<li>两者如何实现继承？</li>\n<li>既然是语法糖，那么父类是 class，子类是 prototype 能否继承？</li>\n<li>既然是语法糖，这个糖如何实现的？</li>\n<li>prototype 如何实现 class 的 static</li>\n</ul>\n<h3 id=\"是不是属于自身属性\"><a href=\"#是不是属于自身属性\" class=\"headerlink\" title=\"是不是属于自身属性\"></a>是不是属于自身属性</h3><ul>\n<li><code>实例.hasOwnProperty(属性)</code> 查看该属性是否来自本身。</li>\n<li><code>Object.getOwnPropertyNames(obj)</code> 返回所有对象本身属性名数组，无论是否能枚举</li>\n<li><code>属性 in 对象 判断能否通过该对象访问该属性</code>，无论是在本身还是原型上</li>\n</ul>\n<h3 id=\"获取一个对象的-prototype\"><a href=\"#获取一个对象的-prototype\" class=\"headerlink\" title=\"获取一个对象的 prototype\"></a>获取一个对象的 prototype</h3><ul>\n<li><code>Object.getPrototypeOf(obj) 方法</code>，他返回对象的 prototype</li>\n<li><code>Object.setPrototypeOf(object, prototype) 方法</code>，设置对象的 prototype</li>\n<li>还可以使用对象的<code>__proto__</code>属性获取和修改对象的 prototype（不推荐）</li>\n</ul>\n<p>作者：羽月<br>链接：<a href=\"https://juejin.cn/post/6844903788642484237\">https://juejin.cn/post/6844903788642484237</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p><a href=\"https://juejin.cn/post/6844903788642484237#heading-4\" target=\"_blank\" >见</a></p>\n<h2 id=\"为什么-JavaScript-最大安全整数是-2-53-1\"><a href=\"#为什么-JavaScript-最大安全整数是-2-53-1\" class=\"headerlink\" title=\"为什么 JavaScript 最大安全整数是 2^53-1\"></a>为什么 JavaScript 最大安全整数是 2^53-1</h2><p><strong>这个 53 是怎么得到的？</strong></p>\n<p>IEEE 754 规定了四种表示浮点数值的方式：</p>\n<p>单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）。</p>\n<p><code>Number</code> 类型使用的便是其中的<code>双精确度（64 位）</code>。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202211011218126.webp\" />\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">位置</th>\n<th align=\"left\">位数</th>\n<th align=\"left\">作用</th>\n<th align=\"left\">表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0-51</td>\n<td align=\"left\">52</td>\n<td align=\"left\">尾数位</td>\n<td align=\"left\">原码表示</td>\n</tr>\n<tr>\n<td align=\"left\">52-62</td>\n<td align=\"left\">11</td>\n<td align=\"left\">指数位</td>\n<td align=\"left\">移码表示</td>\n</tr>\n<tr>\n<td align=\"left\">63</td>\n<td align=\"left\">1</td>\n<td align=\"left\">符号位</td>\n<td align=\"left\">0,1</td>\n</tr>\n</tbody></table>\n<p><strong>因为： 此时就不安全了;</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">2 ** 53 &#x3D;&#x3D;&#x3D; 2 ** 53 + 1; &#x2F;&#x2F;true</code></pre>\n\n<p><strong>在 2^53-1 之后的数中，只要指数相同，并且尾数前 52 位相同，则这个两个数数值相同。</strong></p>\n<p><a href=\"https://juejin.cn/post/6880143057930190855\" target=\"_blank\" >为什么 JavaScript 最大安全整数是 2^53-1</a></p>\n<h2 id=\"没你想象的那么简单\"><a href=\"#没你想象的那么简单\" class=\"headerlink\" title=\", 没你想象的那么简单\"></a>, 没你想象的那么简单</h2><p>对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let x &#x3D; 1;\n\nx &#x3D; (x++, x);\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 2\n\nx &#x3D; (2, 3);\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 3</code></pre>\n\n<p>这也太难了吧</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/142745906\" target=\"_blank\" >170 道 JavaScript 面试题及知识点总结（上）</a><br><a href=\"https://zhuanlan.zhihu.com/p/142749891\" target=\"_blank\" >170 道 JavaScript 面试题及知识点总结（下）</a></p>\n","text":"爬取脚本Array.from(document.getElementsByTagName(&quot;h3&quot;)).forEach((item) &#x3D;&gt; &#123; document.body.append(item.innerText + &quot;\\...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%88%AC%E5%8F%96%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">爬取脚本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%F0%9F%8C%9F-%E4%BB%8B%E7%BB%8D-js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82\"><span class=\"toc-text\">1.🌟 介绍 js 的基本数据类型。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-JavaScript-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%EF%BC%9F%E4%BD%A0%E8%83%BD%E7%94%BB%E4%B8%80%E4%B8%8B%E4%BB%96%E4%BB%AC%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F\"><span class=\"toc-text\">3. 什么是堆？什么是栈？它们之间有什么区别和联系？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%F0%9F%8C%9F-%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7-Class-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">4.🌟 内部属性 [[Class]] 是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BB%8B%E7%BB%8D-js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">5. 介绍 js 有哪些内置对象？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#undeclared-x2F-undefined-x2F-null\"><span class=\"toc-text\">undeclared&#x2F;undefined&#x2F;null</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%F0%9F%8C%9F-undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">6.🌟 undefined 与 undeclared 的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%F0%9F%8C%9F-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">7.🌟 null 和 undefined 的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC%EF%BC%9F\"><span class=\"toc-text\">8. 如何获取安全的 undefined 值？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-JavaScript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83%EF%BC%9F\"><span class=\"toc-text\">9. 说几条写 JavaScript 的基本规范？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B-x2F-%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">原型&#x2F;原型链</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%F0%9F%8C%9F-JavaScript-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">10.🌟 JavaScript 原型，原型链？ 有什么特点？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">11. js 获取原型的方法？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%80%BC\"><span class=\"toc-text\">数值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E5%9C%A8-js-%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">12. 在 js 中不同进制数字的表示方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-js-%E4%B8%AD%E6%95%B4%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F\"><span class=\"toc-text\">13. js 中整数的安全范围是多少？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-typeof-NaN-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">14. typeof NaN 的结果是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%F0%9F%8C%9F-isNaN-%E5%92%8C-Number-isNaN-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">15.🌟 isNaN 和 Number.isNaN 函数的区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-Array-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%80%BC%E6%97%B6%E7%9A%84%E8%A1%A8%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">16. Array 构造函数只有一个参数值时的表现？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">补充</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#empty-%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F\"><span class=\"toc-text\">empty 是个什么东西？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99\"><span class=\"toc-text\">数据转换规则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F-ToString\"><span class=\"toc-text\">17. 其他值到字符串的转换规则？ ToString</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85-1\"><span class=\"toc-text\">补充</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8-Object-prototype-toString\"><span class=\"toc-text\">基本数据类型使用 Object.prototype.toString()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F-ToNumber\"><span class=\"toc-text\">18. 其他值到数字值的转换规则？ ToNumber</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F-ToBoolean\"><span class=\"toc-text\">19. 其他值到布尔类型的值的转换规则？ ToBoolean</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E5%92%8C-%E7%9A%84-valueOf-%E5%92%8C-toString-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-%F0%9F%8C%9F-%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%87%E5%80%BC%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">21.🌟 什么是假值对象？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">22. ~ 操作符的作用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#24-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5%EF%BC%9F\"><span class=\"toc-text\">24. + 操作符什么时候用于字符串的拼接？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#25-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9F\"><span class=\"toc-text\">25. 什么情况下会发生布尔值的隐式强制类型转换？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#26-%E5%92%8C-amp-amp-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F\"><span class=\"toc-text\">26. || 和 &amp;&amp; 操作符的返回值？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#27-Symbol-%E5%80%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9F\"><span class=\"toc-text\">27. Symbol 值的强制类型转换？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#28-x3D-x3D-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F\"><span class=\"toc-text\">28. &#x3D;&#x3D; 操作符的强制类型转换规则？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#29-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%EF%BC%8C%E4%BE%8B%E5%A6%82-%E2%80%9812-3b%E2%80%99\"><span class=\"toc-text\">29. 如何将字符串转化为数字，例如 ‘12.3b’?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#30-%F0%9F%8C%9F-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%EF%BC%8C%E5%A6%82-12000000-11-%E8%BD%AC%E5%8C%96%E4%B8%BA%E3%80%8E12-000-000-11%E3%80%8F\"><span class=\"toc-text\">30.🌟 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#31-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">31. 常用正则表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">32. 生成随机数的各种方法？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#33-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%EF%BC%9F\"><span class=\"toc-text\">33. 如何实现数组的随机排序？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#34-javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">34. javascript 创建对象的几种方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#35-JavaScript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">35. JavaScript 继承的几种实现方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#36-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">36. 寄生式组合继承的实现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#37-%F0%9F%8C%9F-Javascript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F\"><span class=\"toc-text\">37.🌟 Javascript 的作用域链？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#38-%F0%9F%8C%9F-%E8%B0%88%E8%B0%88-This-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82\"><span class=\"toc-text\">38.🌟 谈谈 This 对象的理解。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#39-eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">39. eval 是做什么的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DOM-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">DOM 事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#40-%E4%BB%80%E4%B9%88%E6%98%AF-DOM-%E5%92%8C-BOM%EF%BC%9F\"><span class=\"toc-text\">40. 什么是 DOM 和 BOM？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#41-%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0%E3%80%82\"><span class=\"toc-text\">41. 写一个通用的事件侦听器函数。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#42-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FIE-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%EF%BC%9F\"><span class=\"toc-text\">42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#43-%F0%9F%8C%9F-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">43. 🌟 三种事件模型是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#44-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">44. 事件委托是什么？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-%E2%80%9C1%E2%80%9D-%E2%80%9C2%E2%80%9D-%E2%80%9C3%E2%80%9D-map-parseInt-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F\"><span class=\"toc-text\">45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#46-%F0%9F%8C%9F-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83%EF%BC%9F\"><span class=\"toc-text\">46. 🌟 什么是闭包，为什么要用它？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#47-javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84-%E2%80%9Cuse-strict%E2%80%9D-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%9F\"><span class=\"toc-text\">48. 如何判断一个对象是否属于某个类？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-%F0%9F%8C%9F-instanceof-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">49.🌟 instanceof 的作用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#50-%F0%9F%8C%9F-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">50.🌟 new 操作符具体干了什么呢？如何实现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-Javascript-%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%9F%A5%E6%89%BE%E6%97%B6%EF%BC%8C%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%8E%BB%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%9E%8B%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%EF%BC%9F\"><span class=\"toc-text\">51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#52-%E5%AF%B9%E4%BA%8E-JSON-%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">52. 对于 JSON 的了解？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#53-forEach-call-%E2%80%9C%E2%80%9D-function-a-a-style-outline-x3D-%E2%80%9D1px-solid-%E2%80%9D-Math-random-1-lt-lt-24-toString-16-%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">53. [].forEach.call($$(“”),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#54-js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">54. js 延迟加载的方式有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#55-%F0%9F%8C%9F-Ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Ajax%EF%BC%9F\"><span class=\"toc-text\">55.🌟 Ajax 是什么? 如何创建一个 Ajax？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#56-%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">56. 谈一谈浏览器的缓存机制？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#57-Ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">57. Ajax 解决浏览器缓存问题？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#58-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">58. 同步和异步的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#59-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F\"><span class=\"toc-text\">59. 什么是浏览器的同源策略？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#60-%F0%9F%8C%9F-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">60.🌟 如何解决跨域问题？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#61-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%97%B6%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-cookie%EF%BC%9F\"><span class=\"toc-text\">61. 服务器代理转发时，该如何处理 cookie？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#62-%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B-cookie-%EF%BC%9F\"><span class=\"toc-text\">62. 简单谈一下 cookie ？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">模块加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#63-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F\"><span class=\"toc-text\">63. 模块化开发怎么做？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#64-js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9F\"><span class=\"toc-text\">64. js 的几种模块规范？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#65-AMD-%E5%92%8C-CMD-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">65. AMD 和 CMD 规范的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#66-ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E3%80%81AMD%E3%80%81CMD-%E7%9A%84%E5%B7%AE%E5%BC%82%E3%80%82\"><span class=\"toc-text\">66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#67-requireJS-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E7%BC%93%E5%AD%98%E7%9A%84%EF%BC%9F%EF%BC%89\"><span class=\"toc-text\">67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#68-JS-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E6%80%8E%E4%B9%88%E9%80%A0%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#69-ECMAScript6-%E6%80%8E%E4%B9%88%E5%86%99-class%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-class-%E8%BF%99%E7%A7%8D%E4%B8%9C%E8%A5%BF\"><span class=\"toc-text\">69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#70-documen-write-%E5%92%8C-innerHTML-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">70. documen.write 和 innerHTML 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#71-%F0%9F%8C%9F-DOM-%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">71.🌟 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#72-innerHTML-%E4%B8%8E-outerHTML-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">72. innerHTML 与 outerHTML 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#73-call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">73. .call() 和 .apply() 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#74-%F0%9F%8C%9FJavaScript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9F\"><span class=\"toc-text\">74. 🌟JavaScript 类数组对象的定义？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#75-%F0%9F%8C%9F-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%EF%BC%8C%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%EF%BC%9F\"><span class=\"toc-text\">75.🌟 数组和对象有哪些原生方法，列举一下？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#76-%E6%95%B0%E7%BB%84%E7%9A%84-fill-%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">76. 数组的 fill 方法？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#77-%F0%9F%8C%9F-%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9F\"><span class=\"toc-text\">77.🌟 [,,,] 的长度？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#78-%F0%9F%8C%9F-JavaScript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%EF%BC%9F\"><span class=\"toc-text\">78.🌟 JavaScript 中的作用域与变量声明提升？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#79-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-Javascript-%EF%BC%9F\"><span class=\"toc-text\">79. 如何编写高性能的 Javascript ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#80-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">80. 简单介绍一下 V8 引擎的垃圾回收机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#81-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F\"><span class=\"toc-text\">81. 哪些操作会造成内存泄漏？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#82-%E9%9C%80%E6%B1%82%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E3%80%81%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E3%80%82%E7%BB%99%E5%87%BA%E4%BD%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9F\"><span class=\"toc-text\">82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#83-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%9F%EF%BC%88%E9%98%BF%E9%87%8C%EF%BC%89\"><span class=\"toc-text\">83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#84-%E6%8A%8A-script-%E6%A0%87%E7%AD%BE%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9C%80%E5%BA%95%E9%83%A8%E7%9A%84-body-%E5%B0%81%E9%97%AD%E4%B9%8B%E5%89%8D%E5%92%8C%E5%B0%81%E9%97%AD%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%AE%83%E4%BB%AC%EF%BC%9F\"><span class=\"toc-text\">84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#85-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6%EF%BC%9F\"><span class=\"toc-text\">85. 移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#86-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E2%80%9D%EF%BC%9F-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E2%80%9C%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E2%80%9D%EF%BC%9F%E2%80%9C%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E2%80%9D%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">86. 什么是“前端路由”？ 什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#87-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B9%88%EF%BC%9F%E7%9F%A5%E9%81%93-BDD-TDD-Unit-Test-%E4%B9%88%EF%BC%9F%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B9%88-mocha-sinon-jasmin-qUnit-%EF%BC%9F\"><span class=\"toc-text\">87. 如何测试前端代码么？知道 BDD, TDD, Unit Test 么？知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#88-%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">88. 检测浏览器版本版本有哪些方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#89-%E4%BB%80%E4%B9%88%E6%98%AF-Polyfill-%EF%BC%9F\"><span class=\"toc-text\">89. 什么是 Polyfill ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#90-%E4%BD%BF%E7%94%A8-JS-%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D%EF%BC%9F\"><span class=\"toc-text\">90. 使用 JS 实现获取文件扩展名？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#91-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%EF%BC%9F\"><span class=\"toc-text\">91. 介绍一下 js 的节流与防抖？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#92-Object-is-%E4%B8%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-%E2%80%9C-x3D-x3D-x3D-%E2%80%9D%E3%80%81%E2%80%9C-x3D-x3D-%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#93-escape-encodeURI-encodeURIComponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">93. escape,encodeURI,encodeURIComponent 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#94-Unicode-%E5%92%8C-UTF-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F\"><span class=\"toc-text\">94. Unicode 和 UTF-8 之间的关系？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#utf8\"><span class=\"toc-text\">utf8</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#95-js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">95. js 的事件循环是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#96-js-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">96. js 中的深浅拷贝实现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#97-%E6%89%8B%E5%86%99-call%E3%80%81apply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">97. 手写 call、apply 及 bind 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#98-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">98. 函数柯里化的实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#99-%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-x3D-0-3%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#100-%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BB%8B%E7%BB%8D-101-toPrecision-%E5%92%8C-toFixed-%E5%92%8C-Math-round-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">100. 原码、反码和补码的介绍 101. toPrecision 和 toFixed 和 Math.round 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#102-%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">102. 什么是 XSS 攻击？如何防范 XSS 攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9-SQL-%E6%B3%A8%E5%85%A5%E4%B8%8D%E5%B1%9E%E4%BA%8E-XSS-%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">注意点 SQL 注入不属于 XSS 攻击</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#103-%E4%BB%80%E4%B9%88%E6%98%AF-CSP%EF%BC%9F\"><span class=\"toc-text\">103. 什么是 CSP？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#104-%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#105-%E4%BB%80%E4%B9%88%E6%98%AF-Samesite-Cookie-%E5%B1%9E%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">105. 什么是 Samesite Cookie 属性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#106-%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%EF%BC%9F\"><span class=\"toc-text\">106. 什么是点击劫持？如何防范点击劫持？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#107-SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">107. SQL 注入攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#108-%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F%E6%AF%94%E4%B9%8B-MVC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-MVP-%EF%BC%9F\"><span class=\"toc-text\">108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#109-vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">109. vue 双向数据绑定原理？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#110-Object-defineProperty-%E4%BB%8B%E7%BB%8D%EF%BC%9F\"><span class=\"toc-text\">110. Object.defineProperty 介绍？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#111-%E4%BD%BF%E7%94%A8-Object-defineProperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#112-%E4%BB%80%E4%B9%88%E6%98%AF-Virtual-DOM%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-Virtual-DOM-%E6%AF%94%E5%8E%9F%E7%94%9F-DOM-%E5%BF%AB%EF%BC%9F\"><span class=\"toc-text\">112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#113-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-DOM-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F\"><span class=\"toc-text\">113. 如何比较两个 DOM 树的差异？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#114-%E4%BB%80%E4%B9%88%E6%98%AF-requestAnimationFrame-%EF%BC%9F\"><span class=\"toc-text\">114. 什么是 requestAnimationFrame ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#115-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-webpack-%E7%9A%84%E7%9C%8B%E6%B3%95-116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-%E4%B8%8E-scrollWidth-x2F-scrollHeight-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">115. 谈谈你对 webpack 的看法 116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#117-%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">117. 谈一谈你理解的函数式编程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#118-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">118. 异步编程的实现方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#119-Js-%E5%8A%A8%E7%94%BB%E4%B8%8E-CSS-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">119. Js 动画与 CSS 动画区别及相应实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#120-get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA\"><span class=\"toc-text\">120. get 请求传参长度的误区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#121-URL-%E5%92%8C-URI-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">121. URL 和 URI 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#122-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">122. get 和 post 请求在缓存方面的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#123-%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">123. 图片的懒加载和预加载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#124-mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">124. mouseover 和 mouseenter 的区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">对应关系</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#125-js-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">125. js 拖拽功能的实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#126-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-setTimeout-%E5%AE%9E%E7%8E%B0-setInterval%EF%BC%9F%E6%80%8E%E4%B9%88%E6%A8%A1%E6%8B%9F%EF%BC%9F\"><span class=\"toc-text\">126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">本质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">现象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#127-let-%E5%92%8C-const-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">127. let 和 const 的注意点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#128-%E4%BB%80%E4%B9%88%E6%98%AF-rest-%E5%8F%82%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">128. 什么是 rest 参数？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#129-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F\"><span class=\"toc-text\">129. 什么是尾调用，使用尾调用有什么好处？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E8%B4%A8-1\"><span class=\"toc-text\">本质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">注意点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#130-Symbol-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">130. Symbol 类型的注意点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#131-Set-%E5%92%8C-WeakSet-%E7%BB%93%E6%9E%84%EF%BC%9F\"><span class=\"toc-text\">131. Set 和 WeakSet 结构？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#132-Map-%E5%92%8C-WeakMap-%E7%BB%93%E6%9E%84%EF%BC%9F\"><span class=\"toc-text\">132. Map 和 WeakMap 结构？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Map-%E4%B8%8E-Object-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Map 与 Object 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#133-%E4%BB%80%E4%B9%88%E6%98%AF-Proxy-%EF%BC%9F\"><span class=\"toc-text\">133. 什么是 Proxy ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#134-Reflect-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9B%AE%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">134. Reflect 对象创建目的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A-ES6-Proxy-%E9%87%8C%E9%9D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Reflect%EF%BC%9F\"><span class=\"toc-text\">问题： ES6 Proxy 里面为什么要用 Reflect？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-Proxy-amp-Reflect-%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">为什么 Proxy &amp; Reflect 联合使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#135-require-%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">135. require 模块引入的查找方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#136-%E4%BB%80%E4%B9%88%E6%98%AF-Promise-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF-Promises-x2F-A-%E8%A7%84%E8%8C%83%EF%BC%9F\"><span class=\"toc-text\">136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#137-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-Promise\"><span class=\"toc-text\">137. 手写一个 Promise</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#138-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%EF%BC%9F\"><span class=\"toc-text\">138. 如何检测浏览器所支持的最小字体大小？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#139-%E6%80%8E%E4%B9%88%E5%81%9A-JS-%E4%BB%A3%E7%A0%81-Error-%E7%BB%9F%E8%AE%A1%EF%BC%9F\"><span class=\"toc-text\">139. 怎么做 JS 代码 Error 统计？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#140-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">140. 单例模式模式是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#141-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">141. 策略模式是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#142-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">142. 代理模式是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#143-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">143. 中介者模式是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#144-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">144. 适配器模式是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#145-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">145. 观察者模式和发布订阅模式有什么不同？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#146-Vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">146. Vue 的生命周期是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#147-Vue-%E7%9A%84%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">147. Vue 的各个生命阶段是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#148-Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">148. Vue 组件间的参数传递方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#149-computed-%E5%92%8C-watch-%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F\"><span class=\"toc-text\">149. computed 和 watch 的差异？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#150-vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">150. vue-router 中的导航钩子函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#151-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">151. $route 和 $router 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#152-vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F\"><span class=\"toc-text\">152. vue 常用的修饰符？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#153-vue-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">153. vue 中 key 值的作用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#154-computed-%E5%92%8C-watch-%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">154. computed 和 watch 区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#155-keep-alive-%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">155. keep-alive 组件有什么作用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#156-vue-%E4%B8%AD-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">156. vue 中 mixin 和 mixins 区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#157-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D-Content-Type-%EF%BC%9F\"><span class=\"toc-text\">157. 开发中常用的几种 Content-Type ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#158-%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-javascript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">158. 如何封装一个 javascript 的类型判断函数？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#159-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">159. 如何判断一个对象是否为空对象？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#160-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-1-2-3-4\"><span class=\"toc-text\">160. 使用闭包实现每隔一秒打印 1,2,3,4</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#161-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-jsonp\"><span class=\"toc-text\">161. 手写一个 jsonp</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#162-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">162. 手写一个观察者模式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#163-EventEmitter-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">163. EventEmitter 实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#164-%E4%B8%80%E9%81%93%E5%B8%B8%E8%A2%AB%E4%BA%BA%E8%BD%BB%E8%A7%86%E7%9A%84%E5%89%8D%E7%AB%AF-JS-%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">164. 一道常被人轻视的前端 JS 面试题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#165-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF-Performance-API%EF%BC%9F\"><span class=\"toc-text\">165. 如何确定页面的可用性时间，什么是 Performance API？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#166-js-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">166. js 中的命名规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#167-js-%E8%AF%AD%E5%8F%A5%E6%9C%AB%E5%B0%BE%E5%88%86%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%EF%BC%9F\"><span class=\"toc-text\">167. js 语句末尾分号是否可以省略？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#168-Object-assign\"><span class=\"toc-text\">168. Object.assign()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#169-Math-ceil-%E5%92%8C-Math-floor\"><span class=\"toc-text\">169. Math.ceil 和 Math.floor</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#170-js-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">170. js for 循环注意点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#171-%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%EF%BC%8C%E5%81%87%E8%AE%BE%E6%9C%89-100000-%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">171. 一个列表，假设有 100000 个数据，这个该怎么办？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#172-js-%E4%B8%AD%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%E5%AE%9E%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">172. js 中倒计时的纠偏实现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#173-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">173. 进程间通信的方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#174-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D%EF%BC%9F\"><span class=\"toc-text\">174. 如何查找一篇英文文章中出现频率最高的单词？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JS-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC-undefined-%EF%BC%9F\"><span class=\"toc-text\">JS 为什么不能直接赋值 undefined ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">进制表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CommonJS-AMD-CMD-%E5%85%A8%E7%A7%B0\"><span class=\"toc-text\">CommonJS,AMD,CMD 全称</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E7%A7%B0\"><span class=\"toc-text\">全称</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CMD-%E4%B8%8E-AMD-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">CMD 与 AMD 区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#nodejs-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-commonjs-%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">nodejs 为什么使用 commonjs 规范</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class-%E6%98%AF-prototype-%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9F\"><span class=\"toc-text\">class 是 prototype 的语法糖？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B1%9E%E4%BA%8E%E8%87%AA%E8%BA%AB%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">是不是属于自身属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84-prototype\"><span class=\"toc-text\">获取一个对象的 prototype</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-JavaScript-%E6%9C%80%E5%A4%A7%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0%E6%98%AF-2-53-1\"><span class=\"toc-text\">为什么 JavaScript 最大安全整数是 2^53-1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95\"><span class=\"toc-text\">, 没你想象的那么简单</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"css theme","uid":"03a0cd201b7e39fe38e7f2e815b3009b","slug":"2022-10-26theme","date":"2022-10-26T07:58:01.000Z","updated":"2022-11-01T12:57:51.477Z","comments":true,"path":"api/articles/2022-10-26theme.json","keywords":null,"cover":[],"text":"mdn 主题切换 light&#x2F;dark&#x2F;os-default_theme.scss&#x2F;&#x2F; _theme.scss @use &quot;sass:color&quot;; @use &quot;..&#x2F;vars.scss&quot; ...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"27 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"可视化埋点","uid":"0ad1ddce4e48037c2d0625fb3e573482","slug":"2022-10-24可视化埋点","date":"2022-10-24T13:00:52.000Z","updated":"2022-10-24T13:01:36.555Z","comments":true,"path":"api/articles/2022-10-24可视化埋点.json","keywords":null,"cover":null,"text":"参考链接从 0 到 1 搭建可视化埋点平台 ","link":"","photos":[],"count_time":{"symbolsCount":22,"symbolsTime":"1 mins."},"categories":[{"name":"前端基建","slug":"前端基建","count":1,"path":"api/categories/前端基建.json"}],"tags":[{"name":"前端基建","slug":"前端基建","count":1,"path":"api/tags/前端基建.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}