{"title":"RN bundle","uid":"c85283c353292595a12ddbaa92f14295","slug":"2023-04-27rn-bundle","date":"2023-04-27T06:23:10.000Z","updated":"2023-05-15T13:17:32.997Z","comments":true,"path":"api/articles/2023-04-27rn-bundle.json","keywords":null,"cover":null,"content":"<h2 id=\"一个应用-有多个-react-native-bundle，每个-bundle-再点击应用的时候进行加载的实现原理\"><a href=\"#一个应用-有多个-react-native-bundle，每个-bundle-再点击应用的时候进行加载的实现原理\" class=\"headerlink\" title=\"一个应用 有多个 react-native bundle，每个 bundle 再点击应用的时候进行加载的实现原理\"></a>一个应用 有多个 react-native bundle，每个 bundle 再点击应用的时候进行加载的实现原理</h2><p>在 React Native 中，一个应用可以被分为多个独立的模块或页面。每个模块或页面可以被打包成一个独立的 JavaScript bundle，然后在需要时动态加载。</p>\n<p>实现这个功能的主要原理是使用 React Native 提供的 <code>DynamicImport</code> 组件。这个组件可以在运行时动态加载 JavaScript bundle，并返回一个 Promise 对象。当 Promise 被解析时，被加载的 bundle 会被执行，从而实现模块或页面的动态加载。</p>\n<p>具体实现步骤如下：</p>\n<ol>\n<li><p>将应用的各个模块或页面打包成独立的 JavaScript bundle。</p>\n</li>\n<li><p>在应用启动时，加载应用的主 bundle，然后使用 <code>DynamicImport</code> 组件动态加载首个模块或页面的 bundle。</p>\n</li>\n<li><p>当用户需要加载其他模块或页面时，使用 <code>DynamicImport</code> 组件动态加载对应的 bundle，并在加载完成后将新的模块或页面展示给用户。</p>\n</li>\n</ol>\n<p>需要注意的是，动态加载的 JavaScript bundle 会在运行时解析并执行，因此需要确保加载的 bundle 中不包含任何恶意代码，以保障应用的安全性。此外，需要注意动态加载可能会影响应用的性能，因此应尽量减少动态加载的次数，以提高应用的响应速度。</p>\n<h3 id=\"代码怎么写\"><a href=\"#代码怎么写\" class=\"headerlink\" title=\"代码怎么写\"></a>代码怎么写</h3><p>这里是一个简单的示例，演示如何使用 React Native 实现动态加载多个 JavaScript bundle：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;\nimport &#123; View, Text, Button, ActivityIndicator &#125; from &#39;react-native&#39;;\nimport DynamicImport from &#39;react-native-dynamic-import&#39;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [moduleLoaded, setModuleLoaded] &#x3D; useState(false);\n  const [module, setModule] &#x3D; useState(null);\n\n  const loadModule &#x3D; async () &#x3D;&gt; &#123;\n    setModuleLoaded(false);\n    const module &#x3D; await import(&#39;.&#x2F;path&#x2F;to&#x2F;module&#39;);\n    setModule(module.default);\n    setModuleLoaded(true);\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    loadModule();\n  &#125;, []);\n\n  return (\n    &lt;View&gt;\n      &#123;moduleLoaded ? &lt;module &#x2F;&gt; : &lt;ActivityIndicator size&#x3D;&quot;large&quot; color&#x3D;&quot;#0000ff&quot; &#x2F;&gt;&#125;\n      &lt;Button title&#x3D;&quot;Load module&quot; onPress&#x3D;&#123;loadModule&#125; &#x2F;&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;;\n\nexport default App;</code></pre>\n\n<p>在这个示例中，我们首先使用 <code>useState</code> 钩子定义了两个状态变量 <code>moduleLoaded</code> 和 <code>module</code>，用于跟踪模块是否已经加载完成以及加载的模块内容。然后我们使用 <code>useEffect</code> 钩子在应用启动时自动加载首个模块，然后在渲染时根据状态变量决定是展示模块内容还是展示加载动画。最后我们添加了一个按钮，用于手动触发加载新的模块。</p>\n<p>在 <code>loadModule</code> 函数中，我们使用 <code>import</code> 语句动态加载指定的 JavaScript bundle，并将默认导出的模块内容保存到状态变量 <code>module</code> 中。在加载完成后，我们将状态变量 <code>moduleLoaded</code> 设为 <code>true</code>，从而触发重新渲染并展示模块内容。</p>\n<p>需要注意的是，上面的代码只是一个简单的示例，实际应用中可能需要根据具体情况进行适当修改。同时，我们还需要确保在打包应用时将各个模块或页面打包成独立的 JavaScript bundle，并在需要时使用 <code>DynamicImport</code> 组件动态加载这些 bundle。</p>\n<h3 id=\"react-native-dynamic-import-（已被开发者清空）\"><a href=\"#react-native-dynamic-import-（已被开发者清空）\" class=\"headerlink\" title=\"react-native-dynamic-import （已被开发者清空）\"></a>react-native-dynamic-import （已被开发者清空）</h3><p><code>react-native-dynamic-import</code> 是一个可以在 React Native 中实现动态加载 JavaScript 模块的第三方库，可以在 npm 上进行安装。</p>\n<p>安装 <code>react-native-dynamic-import</code> 的步骤如下：</p>\n<ol>\n<li><p>打开终端或命令行工具，进入你的 React Native 项目目录。</p>\n</li>\n<li><p>运行以下命令来安装 <code>react-native-dynamic-import</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install --save react-native-dynamic-import</code></pre>\n\n<p>如果你使用的是 yarn 包管理器，可以使用以下命令来安装：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add react-native-dynamic-import</code></pre>\n\n<p>这将在你的项目中安装 <code>react-native-dynamic-import</code>，并将其添加到 <code>package.json</code> 文件中的 <code>dependencies</code> 字段。</p>\n</li>\n<li><p>在需要使用 <code>DynamicImport</code> 组件的代码文件中，使用以下语句导入该组件：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import DynamicImport from &#39;react-native-dynamic-import&#39;;</code></pre>\n\n<p>然后你就可以在代码中使用 <code>DynamicImport</code> 组件来实现动态加载 JavaScript 模块了。</p>\n</li>\n</ol>\n<p>需要注意的是，<code>react-native-dynamic-import</code> 是一个第三方库，使用前请确保已经熟悉了其文档和使用方法，并且按照官方推荐的方式进行使用。</p>\n<h3 id=\"不使用-react-native-dynamic-import-如何实现\"><a href=\"#不使用-react-native-dynamic-import-如何实现\" class=\"headerlink\" title=\"不使用 react-native-dynamic-import 如何实现\"></a>不使用 react-native-dynamic-import 如何实现</h3><p>如果你不想使用第三方库 <code>react-native-dynamic-import</code> 来实现动态加载 JavaScript 模块，你可以使用 React Native 内置的 <code>require()</code> 函数来手动加载模块。</p>\n<p>以下是一个简单的示例代码，演示了如何使用 <code>require()</code> 函数手动加载 JavaScript 模块：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;\nimport &#123; View, Text, Button, ActivityIndicator &#125; from &#39;react-native&#39;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [moduleLoaded, setModuleLoaded] &#x3D; useState(false);\n  const [module, setModule] &#x3D; useState(null);\n\n  const loadModule &#x3D; () &#x3D;&gt; &#123;\n    setModuleLoaded(false);\n    const module &#x3D; require(&#39;.&#x2F;path&#x2F;to&#x2F;module&#39;);\n    setModule(module);\n    setModuleLoaded(true);\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    loadModule();\n  &#125;, []);\n\n  return (\n    &lt;View&gt;\n      &#123;moduleLoaded ? &lt;module.default &#x2F;&gt; : &lt;ActivityIndicator size&#x3D;&quot;large&quot; color&#x3D;&quot;#0000ff&quot; &#x2F;&gt;&#125;\n      &lt;Button title&#x3D;&quot;Load module&quot; onPress&#x3D;&#123;loadModule&#125; &#x2F;&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;;\n\nexport default App;</code></pre>\n\n<p>在这个示例中，我们仍然使用 <code>useState</code> 钩子定义了两个状态变量 <code>moduleLoaded</code> 和 <code>module</code>，用于跟踪模块是否已经加载完成以及加载的模块内容。然后我们使用 <code>useEffect</code> 钩子在应用启动时自动加载首个模块，然后在渲染时根据状态变量决定是展示模块内容还是展示加载动画。最后我们添加了一个按钮，用于手动触发加载新的模块。</p>\n<p>在 <code>loadModule</code> 函数中，我们使用 <code>require</code> 函数手动加载指定的 JavaScript 模块，并将其保存到状态变量 <code>module</code> 中。在加载完成后，我们将状态变量 <code>moduleLoaded</code> 设为 <code>true</code>，从而触发重新渲染并展示模块内容。</p>\n<p>需要注意的是，使用 <code>require()</code> 函数手动加载 JavaScript 模块可能会导致一些问题，例如会阻塞 UI 线程等。因此在实际应用中，我们建议使用 <code>react-native-dynamic-import</code> 或其他更可靠的方式来实现动态加载 JavaScript 模块。</p>\n<h3 id=\"react-native-dynamic-import-代码仓库空了\"><a href=\"#react-native-dynamic-import-代码仓库空了\" class=\"headerlink\" title=\"react-native-dynamic-import 代码仓库空了\"></a>react-native-dynamic-import 代码仓库空了</h3><p>经过进一步查证，发现 <code>react-native-dynamic-import</code> 似乎已经没有维护了，并且它的代码仓库也已经被删除。建议你不要使用这个库，可以考虑使用其他方式来实现动态加载模块的功能，例如使用 <code>import()</code> 函数或者第三方库 <code>react-loadable</code> 等。对于使用 <code>import()</code> 函数的方式，可以参考我之前的回答。如果你需要使用 <code>react-loadable</code>，可以参考官方文档进行使用。</p>\n<h3 id=\"每个-bundle-对应一个应用的情况如何处理呢\"><a href=\"#每个-bundle-对应一个应用的情况如何处理呢\" class=\"headerlink\" title=\"每个 bundle 对应一个应用的情况如何处理呢\"></a>每个 bundle 对应一个应用的情况如何处理呢</h3><p>如果每个 <code>bundle</code> 对应一个独立的应用，那么你可以使用 React Native 提供的 <code>AppRegistry</code> API 来注册和启动这些应用。<code>AppRegistry</code> API 可以让你在一个 React Native 应用中同时运行多个独立的应用，并且它还提供了一些方便的方法来管理这些应用的生命周期。</p>\n<p>以下是一个简单的示例代码，演示了如何使用 <code>AppRegistry</code> API 注册和启动两个独立的应用：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; AppRegistry &#125; from &#39;react-native&#39;;\n\n&#x2F;&#x2F; 定义应用1\nconst App1 &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &#x2F;&#x2F; ...\n  );\n&#125;;\nAppRegistry.registerComponent(&#39;App1&#39;, () &#x3D;&gt; App1);\n\n&#x2F;&#x2F; 定义应用2\nconst App2 &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &#x2F;&#x2F; ...\n  );\n&#125;;\nAppRegistry.registerComponent(&#39;App2&#39;, () &#x3D;&gt; App2);\n\n&#x2F;&#x2F; 启动应用1\nAppRegistry.runApplication(&#39;App1&#39;, &#123;\n  initialProps: &#123;&#125;,\n  rootTag: document.getElementById(&#39;app1&#39;)\n&#125;);\n\n&#x2F;&#x2F; 启动应用2\nAppRegistry.runApplication(&#39;App2&#39;, &#123;\n  initialProps: &#123;&#125;,\n  rootTag: document.getElementById(&#39;app2&#39;)\n&#125;);</code></pre>\n\n<p>在这个示例中，我们首先定义了两个独立的应用 <code>App1</code> 和 <code>App2</code>，然后分别使用 <code>AppRegistry.registerComponent()</code> 方法将它们注册到 <code>AppRegistry</code> 中。最后，我们分别使用 <code>AppRegistry.runApplication()</code> 方法来启动这两个应用，并且通过 <code>rootTag</code> 属性将它们分别渲染到不同的 HTML 元素中。</p>\n<p>需要注意的是，<code>AppRegistry</code> API 只能在 React Native 中使用，如果你要将你的 React Native 应用嵌入到一个 Web 页面中，你需要使用类似 <code>react-native-web</code> 的工具将其转换为 Web 可运行的形式。</p>\n<h3 id=\"如果-app1-和-app2-不在项目中，需要从服务端加载，改如何处理\"><a href=\"#如果-app1-和-app2-不在项目中，需要从服务端加载，改如何处理\" class=\"headerlink\" title=\"如果 app1 和 app2 不在项目中，需要从服务端加载，改如何处理\"></a>如果 app1 和 app2 不在项目中，需要从服务端加载，改如何处理</h3><p>如果 <code>app1</code> 和 <code>app2</code> 不在 React Native 项目中，而是需要从服务端动态加载，你可以使用动态加载 JavaScript 模块的方式来实现。</p>\n<p>以下是一个简单的示例代码，演示了如何通过动态加载 JavaScript 模块来从服务端加载并启动 <code>app1</code> 和 <code>app2</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; AppRegistry &#125; from &#39;react-native&#39;;\n\n&#x2F;&#x2F; 加载并启动应用\nconst loadAndRunApp &#x3D; async (appName, rootTag) &#x3D;&gt; &#123;\n  try &#123;\n    const &#123; default: App &#125; &#x3D; await import(&#96;https:&#x2F;&#x2F;example.com&#x2F;apps&#x2F;$&#123;appName&#125;.js&#96;);\n    AppRegistry.registerComponent(appName, () &#x3D;&gt; App);\n    AppRegistry.runApplication(appName, &#123;\n      initialProps: &#123;&#125;,\n      rootTag: rootTag,\n    &#125;);\n  &#125; catch (err) &#123;\n    console.error(&#96;Failed to load app $&#123;appName&#125;: $&#123;err&#125;&#96;);\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 加载并启动应用1\nloadAndRunApp(&#39;app1&#39;, document.getElementById(&#39;app1&#39;));\n\n&#x2F;&#x2F; 加载并启动应用2\nloadAndRunApp(&#39;app2&#39;, document.getElementById(&#39;app2&#39;));</code></pre>\n\n<p>在这个示例中，我们定义了一个 <code>loadAndRunApp()</code> 函数，它接受应用名称和根元素的 ID 作为参数，然后使用 <code>import()</code> 函数动态加载指定的 JavaScript 模块，并在加载完成后使用 <code>AppRegistry</code> API 来注册和启动这个应用。最后，我们分别调用 <code>loadAndRunApp()</code> 函数来加载和启动 <code>app1</code> 和 <code>app2</code>。</p>\n<p>需要注意的是，动态加载 JavaScript 模块可能会受到一些安全限制，例如跨域访问限制等。因此在实际应用中，我们建议在服务端将应用打包成可运行的 JavaScript 模块，并将其放置到静态资源服务器上，从而避免跨域访问等安全问题。</p>\n<h3 id=\"如何打包出-app1-js-和-app2-js\"><a href=\"#如何打包出-app1-js-和-app2-js\" class=\"headerlink\" title=\"如何打包出 app1.js 和 app2.js\"></a>如何打包出 app1.js 和 app2.js</h3><p>如果你要将 <code>app1</code> 和 <code>app2</code> 打包成可运行的 JavaScript 模块，你可以使用 React Native 提供的 <code>react-native bundle</code> 命令来进行打包。以下是一个简单的示例代码，演示了如何使用 <code>react-native bundle</code> 命令来打包 <code>app1</code> 和 <code>app2</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">react-native bundle --entry-file app1.js --bundle-output .&#x2F;dist&#x2F;app1.js --platform ios --dev false\nreact-native bundle --entry-file app2.js --bundle-output .&#x2F;dist&#x2F;app2.js --platform ios --dev false</code></pre>\n\n<p>在这个示例中，我们分别使用 <code>react-native bundle</code> 命令来打包 <code>app1</code> 和 <code>app2</code>。其中，<code>--entry-file</code> 参数指定了入口文件，<code>--bundle-output</code> 参数指定了输出文件，<code>--platform</code> 参数指定了平台，<code>--dev</code> 参数指定了是否打开开发模式。</p>\n<p>需要注意的是，打包出的 JavaScript 模块只包含了应用的代码，如果你的应用需要使用一些第三方库或者组件，你需要将这些依赖打包到同一个 JavaScript 模块中，或者将它们单独打包成独立的 JavaScript 模块，并在运行时使用动态加载的方式来加载它们。</p>\n","text":"一个应用 有多个 react-native bundle，每个 bundle 再点击应用的时候进行加载的实现原理在 React Native 中，一个应用可以被分为多个独立的模块或页面。每个模块或页面可以被打包成一个独立的 JavaScript bundle，然后在需要时动态加载...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"react-native","slug":"react-native","count":8,"path":"api/categories/react-native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":8,"path":"api/tags/react-native.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8-%E6%9C%89%E5%A4%9A%E4%B8%AA-react-native-bundle%EF%BC%8C%E6%AF%8F%E4%B8%AA-bundle-%E5%86%8D%E7%82%B9%E5%87%BB%E5%BA%94%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">一个应用 有多个 react-native bundle，每个 bundle 再点击应用的时候进行加载的实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%80%8E%E4%B9%88%E5%86%99\"><span class=\"toc-text\">代码怎么写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-native-dynamic-import-%EF%BC%88%E5%B7%B2%E8%A2%AB%E5%BC%80%E5%8F%91%E8%80%85%E6%B8%85%E7%A9%BA%EF%BC%89\"><span class=\"toc-text\">react-native-dynamic-import （已被开发者清空）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BD%BF%E7%94%A8-react-native-dynamic-import-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">不使用 react-native-dynamic-import 如何实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-native-dynamic-import-%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E7%A9%BA%E4%BA%86\"><span class=\"toc-text\">react-native-dynamic-import 代码仓库空了</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA-bundle-%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%91%A2\"><span class=\"toc-text\">每个 bundle 对应一个应用的情况如何处理呢</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C-app1-%E5%92%8C-app2-%E4%B8%8D%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%94%B9%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86\"><span class=\"toc-text\">如果 app1 和 app2 不在项目中，需要从服务端加载，改如何处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E5%87%BA-app1-js-%E5%92%8C-app2-js\"><span class=\"toc-text\">如何打包出 app1.js 和 app2.js</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"tampermonkey使用","uid":"d62e160e4077fd4450156ded5ae45c33","slug":"2023-04-27tampermonkey","date":"2023-04-27T09:32:00.000Z","updated":"2023-05-15T13:17:32.998Z","comments":true,"path":"api/articles/2023-04-27tampermonkey.json","keywords":null,"cover":[],"text":"动机很多网页没有适配 dark 主题，我觉得 dark 看起来更舒服些 之前操作页面加载完成后，在控制台执行如下代码，页面成 dark 模式（自己注入脚本实现） var st &#x3D; document.createElement(&#39;style&#39;); st.i...","link":"","photos":[],"count_time":{"symbolsCount":895,"symbolsTime":"1 mins."},"categories":[{"name":"工具","slug":"工具","count":22,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":16,"path":"api/tags/工具.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Go Example","uid":"be94f55e80fa4ce47d468eae65467080","slug":"2023-04-20panic","date":"2023-04-20T10:54:32.000Z","updated":"2023-05-15T13:17:32.997Z","comments":true,"path":"api/articles/2023-04-20panic.json","keywords":null,"cover":[],"text":"Panic用于抛出异常 recover用于捕获异常 package main import &quot;fmt&quot; func mayPanic() &#123; panic(&quot;a problem&quot;) &#125; func main() &#123; ...","link":"","photos":[],"count_time":{"symbolsCount":747,"symbolsTime":"1 mins."},"categories":[{"name":"Go","slug":"Go","count":19,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":19,"path":"api/tags/Go.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}