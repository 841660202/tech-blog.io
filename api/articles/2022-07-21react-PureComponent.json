{"title":"React@16.5.0 PureComponent","uid":"d6e3ef07929a629e78ad737d602fe838","slug":"2022-07-21react-PureComponent","date":"2022-07-21T08:28:39.000Z","updated":"2022-09-16T15:02:32.005Z","comments":true,"path":"api/articles/2022-07-21react-PureComponent.json","keywords":null,"cover":[],"content":"<h2 id=\"串串\"><a href=\"#串串\" class=\"headerlink\" title=\"串串\"></a>串串</h2><img src=\"http://t-blog-images.aijs.top/img/pureComponent1.webp\" />\n\n<p>PureComponent 继承 Component,添加 isPureReactComponent 标记</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; ComponentDummy 是典型的 JavaScript 原型模拟继承的做法，\nfunction ComponentDummy() &#123;&#125;\nComponentDummy.prototype &#x3D; Component.prototype;\n\n&#x2F;**\n * Convenience component with default shallow equality check for sCU.\n * 具有sCU默认浅相等检查的便利组件。\n *&#x2F;\nfunction PureComponent(props, context, updater) &#123;\n  this.props &#x3D; props;\n  this.context &#x3D; context;\n  &#x2F;&#x2F; If a component has string refs, we will assign a different object later.\n  &#x2F;&#x2F; 如果组件具有字符串引用，我们将稍后指定其他对象。\n  this.refs &#x3D; emptyObject;\n  this.updater &#x3D; updater || ReactNoopUpdateQueue;\n&#125;\n\nconst pureComponentPrototype &#x3D; (PureComponent.prototype &#x3D; new ComponentDummy());\npureComponentPrototype.constructor &#x3D; PureComponent;\n&#x2F;&#x2F; Avoid an extra prototype jump for these methods.  避免这些方法的额外原型跳转。\n&#x2F;&#x2F; 为了避免原型链拉长导致方法查找的性能开销，还用 Object.assign 把方法从 ReactComponent 拷贝过来了\nObject.assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent &#x3D; true; &#x2F;&#x2F; checkShouldComponentUpdate中有浅比较&#96;shallowEqual&#96;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; packages&#x2F;react&#x2F;src&#x2F;ReactBaseClasses.js\n&#x2F;&#x2F; PureComponent-&gt;继承Component, 添加 isPureReactComponent &#x3D; true\n\n&#x2F;&#x2F; packages&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js\n&#x2F;&#x2F; checkShouldComponentUpdate-&gt;\n&#x2F;&#x2F; shallowEqual</code></pre>\n\n<h2 id=\"checkShouldComponentUpdate\"><a href=\"#checkShouldComponentUpdate\" class=\"headerlink\" title=\"checkShouldComponentUpdate\"></a>checkShouldComponentUpdate</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextLegacyContext\n) &#123;\n  const instance &#x3D; workInProgress.stateNode;\n  &#x2F;&#x2F; 实例上有shouldComponentUpdate，走实例的判断\n  if (typeof instance.shouldComponentUpdate &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n    startPhaseTimer(workInProgress, &quot;shouldComponentUpdate&quot;);\n    const shouldUpdate &#x3D; instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextLegacyContext\n    );\n    stopPhaseTimer();\n\n    if (__DEV__) &#123;\n      warningWithoutStack(\n        shouldUpdate !&#x3D;&#x3D; undefined,\n        &quot;%s.shouldComponentUpdate(): Returned undefined instead of a &quot; +\n          &quot;boolean value. Make sure to return true or false.&quot;,\n        getComponentName(ctor) || &quot;Component&quot;\n      );\n    &#125;\n\n    return shouldUpdate; &#x2F;&#x2F; 返回了\n  &#125;\n  &#x2F;&#x2F; 实例没有看看组件是不是PureComponent,如果是进行浅比较\n  &#x2F;&#x2F; 浅比较\n  if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  &#125;\n\n  return true;\n&#125;</code></pre>\n\n<h2 id=\"shallowEqual\"><a href=\"#shallowEqual\" class=\"headerlink\" title=\"shallowEqual\"></a>shallowEqual</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function shallowEqual(objA: mixed, objB: mixed): boolean &#123;\n  if (is(objA, objB)) &#123;\n    return true;\n  &#125;\n\n  if (\n    typeof objA !&#x3D;&#x3D; &quot;object&quot; ||\n    objA &#x3D;&#x3D;&#x3D; null ||\n    typeof objB !&#x3D;&#x3D; &quot;object&quot; ||\n    objB &#x3D;&#x3D;&#x3D; null\n  ) &#123;\n    return false;\n  &#125;\n\n  const keysA &#x3D; Object.keys(objA);\n  const keysB &#x3D; Object.keys(objB);\n\n  if (keysA.length !&#x3D;&#x3D; keysB.length) &#123;\n    return false;\n  &#125;\n\n  &#x2F;&#x2F; Test for A&#39;s keys different from B.\n  &#x2F;&#x2F; 只是对键对应的值进行比较，从MDN Object.is Api了解到 都是相同对象（意味着都是同一个对象的值引用）\n  &#x2F;&#x2F; 如果这里进行递归处理，就变成了deepCompare\n\n  for (let i &#x3D; 0; i &lt; keysA.length; i++) &#123;\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) &#123;\n      return false;\n    &#125;\n  &#125;\n\n  return true;\n&#125;</code></pre>\n\n<h2 id=\"is\"><a href=\"#is\" class=\"headerlink\" title=\"is\"></a>is</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;is\n *&#x2F;\nfunction is(x, y) &#123;\n  &#x2F;&#x2F; SameValue algorithm\n  if (x &#x3D;&#x3D;&#x3D; y) &#123;\n    &#x2F;&#x2F; Steps 1-5, 7-10\n    &#x2F;&#x2F; Steps 6.b-6.e: +0 !&#x3D; -0\n    &#x2F;&#x2F; Added the nonzero y check to make Flow happy, but it is redundant\n    return x !&#x3D;&#x3D; 0 || y !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;\n  &#125; else &#123;\n    &#x2F;&#x2F; Step 6.a: NaN &#x3D;&#x3D; NaN\n    return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"end-and-start\"><a href=\"#end-and-start\" class=\"headerlink\" title=\"end and start\"></a>end and start</h2><p>其实上到这个地方，PureComponent 就聊完了</p>\n<h2 id=\"与-beginWork-串串\"><a href=\"#与-beginWork-串串\" class=\"headerlink\" title=\"与 beginWork 串串\"></a>与 beginWork 串串</h2><img src=\"http://t-blog-images.aijs.top/img/pureComponent.webp\" />\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; beginWork-&gt;\n&#x2F;&#x2F; updateClassComponent(到这里就与@link: http:&#x2F;&#x2F;v.aijs.top&#x2F;posts&#x2F;2022-07-21react-createElement 串起来了)-&gt;\n&#x2F;&#x2F; resumeMountClassInstance-&gt; | updateClassInstance-&gt;\n&#x2F;&#x2F; checkShouldComponentUpdate-&gt;\n&#x2F;&#x2F; shallowEqual</code></pre>\n\n<h2 id=\"resumeMountClassInstance\"><a href=\"#resumeMountClassInstance\" class=\"headerlink\" title=\"resumeMountClassInstance\"></a>resumeMountClassInstance</h2><p>如果已经创建实例，则重用实例</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function resumeMountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime\n): boolean &#123;\n  &#x2F;&#x2F; 是否应该更新，两种情况：forceUpdate 或者 checkShouldComponentUpdate 返回true\n  const shouldUpdate &#x3D;\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextLegacyContext\n    );\n\n  if (shouldUpdate) &#123;\n    &#x2F;&#x2F; In order to support react-lifecycles-compat polyfilled components,\n    &#x2F;&#x2F; Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &amp;&amp;\n      (typeof instance.UNSAFE_componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot; ||\n        typeof instance.componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;)\n    ) &#123;\n      startPhaseTimer(workInProgress, &quot;componentWillMount&quot;);\n      if (typeof instance.componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n        instance.componentWillMount();\n      &#125;\n      if (typeof instance.UNSAFE_componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n        instance.UNSAFE_componentWillMount();\n      &#125;\n      stopPhaseTimer();\n    &#125;\n    &#x2F;&#x2F; 这里进行标记了\n    if (typeof instance.componentDidMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n      workInProgress.effectTag |&#x3D; Update;\n    &#125;\n  &#125; else &#123;\n  &#125;\n\n  &#x2F;&#x2F; Update the existing instance&#39;s state, props, and context pointers even\n  &#x2F;&#x2F; if shouldComponentUpdate returns false.\n  instance.props &#x3D; newProps;\n  instance.state &#x3D; newState;\n  instance.context &#x3D; nextLegacyContext;\n\n  return shouldUpdate;\n&#125;</code></pre>\n\n<h2 id=\"startPhaseTimer\"><a href=\"#startPhaseTimer\" class=\"headerlink\" title=\"startPhaseTimer\"></a>startPhaseTimer</h2><p><code>packages/react-reconciler/src/ReactDebugFiberPerf.js</code>文件中，性能测量相关，不用关心</p>\n<h2 id=\"updateClassComponent\"><a href=\"#updateClassComponent\" class=\"headerlink\" title=\"updateClassComponent\"></a>updateClassComponent</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps,\n  renderExpirationTime: ExpirationTime\n) &#123;\n  let shouldUpdate;\n  if (current &#x3D;&#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F;  如果还没创建实例，初始化\n    if (workInProgress.stateNode &#x3D;&#x3D;&#x3D; null) &#123;\n    &#125; else &#123;\n      &#x2F;&#x2F;  如果已经创建实例，则重用实例\n      &#x2F;&#x2F; In a resume, we&#39;ll already have an instance we can reuse.\n      shouldUpdate &#x3D; resumeMountClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; 更新类实例\n    shouldUpdate &#x3D; updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n  &#125;\n  return finishClassComponent(\n    &#x2F;&#x2F; 调用组件实例的render函数获取需渲染的子元素，并把子元素进行处理为Fiber类型，处理state和props：\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime\n  );\n&#125;</code></pre>\n","text":"串串 PureComponent 继承 Component,添加 isPureReactComponent 标记 &#x2F;&#x2F; ComponentDummy 是典型的 JavaScript 原型模拟继承的做法， function ComponentDummy() &#...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%B2%E4%B8%B2\"><span class=\"toc-text\">串串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#checkShouldComponentUpdate\"><span class=\"toc-text\">checkShouldComponentUpdate</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shallowEqual\"><span class=\"toc-text\">shallowEqual</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#is\"><span class=\"toc-text\">is</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#end-and-start\"><span class=\"toc-text\">end and start</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8E-beginWork-%E4%B8%B2%E4%B8%B2\"><span class=\"toc-text\">与 beginWork 串串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#resumeMountClassInstance\"><span class=\"toc-text\">resumeMountClassInstance</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#startPhaseTimer\"><span class=\"toc-text\">startPhaseTimer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#updateClassComponent\"><span class=\"toc-text\">updateClassComponent</span></a></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React@16.5.0 diffing algorithm","uid":"591f2a8f52aa8db4f8ec9853d594cc54","slug":"2022-07-22react-diffing","date":"2022-07-22T01:16:00.000Z","updated":"2022-09-16T15:02:43.733Z","comments":true,"path":"api/articles/2022-07-22react-diffing.json","keywords":null,"cover":[],"text":"说明 React provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applicati...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"React@16.5.0 unsafe_","uid":"f07658ed4d8d481756bfa8b0d656b104","slug":"2022-07-21react-unsafe","date":"2022-07-21T06:23:16.000Z","updated":"2022-09-16T15:02:37.982Z","comments":true,"path":"api/articles/2022-07-21react-unsafe.json","keywords":null,"cover":null,"text":"我整理这篇文章的目的很多时候，我在学技术时候更多关注的是教程和文档,原因有三：时间紧、任务重、新技术很多 最近手头无事，刚好搜源码搜到了，希望闲暇之余，你也能了解 React 变更过程，加深 React 的理解 过时的组件生命周期往往会带来不安全的编码实践 componentWi...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}