{"title":"重拾java","uid":"67e193579c0cb334ed58fb94e7cd04b2","slug":"2023-05-25java","date":"2023-05-25T12:52:54.000Z","updated":"2023-07-08T01:06:25.359Z","comments":true,"path":"api/articles/2023-05-25java.json","keywords":null,"cover":[],"content":"<h1 id=\"文章结构\"><a href=\"#文章结构\" class=\"headerlink\" title=\"文章结构\"></a>文章结构</h1><p>跟着兴趣走而不是顺序</p>\n<h1 id=\"输入校验\"><a href=\"#输入校验\" class=\"headerlink\" title=\"输入校验\"></a>输入校验</h1><p><a href=\"https://spring.io/guides/gs/validating-form-input/\" target=\"_blank\" >validating-form-input</a></p>\n<ol>\n<li>如何校验</li>\n<li>如何处理检验不通过的信息</li>\n</ol>\n<p>“Validating Form” 是指对表单数据进行验证以确保其符合特定规则或要求的过程。在 Web 应用程序中，表单通常用于收集用户输入的数据，例如注册表格、登录表格等，验证表单可以帮助防止恶意数据输入和应用程序错误。在验证过程中，可以检查表单中的数据是否为空、是否符合格式、是否在允许的范围内等。对于 Java Spring 等后端框架，通常会提供表单验证的 API 来简化表单验证过程。</p>\n<h1 id=\"注解有哪些\"><a href=\"#注解有哪些\" class=\"headerlink\" title=\"注解有哪些\"></a>注解有哪些</h1><p>以下是对这些常用的 Java 标准注解的简要介绍：</p>\n<ol>\n<li><code>@Null</code>：指定被注解的属性或方法必须为 null 值；</li>\n<li><code>@NotNull</code>：指定被注解的属性或方法不能为 null 值；</li>\n<li><code>@AssertTrue</code>：指定被注解的属性或方法必须为 true 值；</li>\n<li><code>@AssertFalse</code>：指定被注解的属性或方法必须为 false 值；</li>\n<li><code>@Min</code>：指定被注解的属性或方法必须大于或等于指定的最小值；</li>\n<li><code>@Max</code>：指定被注解的属性或方法必须小于或等于指定的最大值；</li>\n<li><code>@DecimalMin</code>：指定被注解的属性或方法必须大于或等于指定的最小值，该值必须是一个十进制数；</li>\n<li><code>@DecimalMax</code>：指定被注解的属性或方法必须小于或等于指定的最大值，该值必须是一个十进制数；</li>\n<li><code>@Negative</code>：指定被注解的属性或方法必须为负数；</li>\n<li><code>@NegativeOrZero</code>：指定被注解的属性或方法必须为负数或零；</li>\n<li><code>@Positive</code>：指定被注解的属性或方法必须为正数；</li>\n<li><code>@PositiveOrZero</code>：指定被注解的属性或方法必须为正数或零；</li>\n<li><code>@Size</code>：指定被注解的属性或方法必须具有指定的大小范围；</li>\n<li><code>@Digits</code>：指定被注解的属性或方法必须是一个数字，并且具有指定的整数和小数位数；</li>\n<li><code>@Past</code>：指定被注解的属性或方法必须是一个过去的日期或时间；</li>\n<li><code>@PastOrPresent</code>：指定被注解的属性或方法必须是一个过去的日期或时间，或者是当前日期或时间；</li>\n<li><code>@Future</code>：指定被注解的属性或方法必须是一个将来的日期或时间；</li>\n<li><code>@FutureOrPresent</code>：指定被注解的属性或方法必须是一个将来的日期或时间，或者是当前日期或时间；</li>\n<li><code>@Pattern</code>：指定被注解的属性或方法必须匹配指定的正则表达式；</li>\n<li><code>@NotEmpty</code>：指定被注解的属性或方法不能为 null 值或空字符串；</li>\n<li><code>@NotBlank</code>：指定被注解的属性或方法不能为 null 值或空字符串，并且必须至少包含一个非空格字符；</li>\n<li><code>@Email</code>：指定被注解的属性或方法必须是一个有效的电子邮件地址。</li>\n</ol>\n<p>这些注解可以用于验证数据模型中的属性或方法，以确保它们符合指定的要求。可以在方法或类级别上使用这些注解进行验证。</p>\n<h3 id=\"Validating-Form-有哪些注解\"><a href=\"#Validating-Form-有哪些注解\" class=\"headerlink\" title=\"Validating Form 有哪些注解\"></a>Validating Form 有哪些注解</h3><p>在 Java Spring 框架中，常用的表单验证注解包括：</p>\n<ol>\n<li><code>@NotNull</code>：检查值是否为 null。</li>\n<li><code>@NotEmpty</code>：检查字符串、集合、Map 或数组是否为空。</li>\n<li><code>@NotBlank</code>：检查字符串是否为空或仅包含空格。</li>\n<li><code>@Size</code>：检查值的大小是否在指定范围内。</li>\n<li><code>@Min</code>：检查值是否大于等于指定的最小值。</li>\n<li><code>@Max</code>：检查值是否小于等于指定的最大值。</li>\n<li><code>@Email</code>：检查值是否为有效的电子邮件地址。</li>\n<li><code>@Pattern</code>：检查值是否与指定的正则表达式匹配。</li>\n</ol>\n<p>这些注解可以应用于表单实体的属性上，以检查表单数据是否符合预期的格式和规则。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    @NotNull\n    private String username;\n\n    @NotBlank\n    private String password;\n\n    @Email\n    private String email;\n\n    @Size(min &#x3D; 2, max &#x3D; 20)\n    private String firstName;\n\n    @Size(min &#x3D; 2, max &#x3D; 20)\n    private String lastName;\n\n    &#x2F;&#x2F; getters and setters\n&#125;</code></pre>\n\n<p>在上面的例子中，<code>@NotNull</code>和<code>@NotBlank</code>注解用于检查<code>username</code>和<code>password</code>属性是否为空或仅包含空格。<code>@Email</code>注解用于检查<code>email</code>属性是否为有效的电子邮件地址。<code>@Size</code>注解用于检查<code>firstName</code>和<code>lastName</code>属性的长度是否在 2 到 20 个字符之间。</p>\n<h3 id=\"Positive\"><a href=\"#Positive\" class=\"headerlink\" title=\"@Positive\"></a>@Positive</h3><p><code>@Positive</code> 是 Java 中的一个注解，它可以应用于数值型的属性或方法参数，用于指定该数值必须为正数（大于零）。如果使用 <code>@Positive</code> 注解的属性或方法参数的值小于或等于零，则会触发验证错误。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Order &#123;\n    @Positive(message &#x3D; &quot;订单金额必须为正数&quot;)\n    private BigDecimal amount;\n\n    &#x2F;&#x2F; getter 和 setter 方法\n&#125;</code></pre>\n\n<p>在上述示例中，<code>amount</code> 属性被标记为 <code>@Positive</code>，它必须为正数，否则会触发验证错误。如果您使用 Java Bean Validation 框架进行验证，可以使用类似下面的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ValidatorFactory factory &#x3D; Validation.buildDefaultValidatorFactory();\nValidator validator &#x3D; factory.getValidator();\n\nOrder order &#x3D; new Order();\norder.setAmount(new BigDecimal(&quot;-1.00&quot;));\n\nSet&lt;ConstraintViolation&lt;Order&gt;&gt; violations &#x3D; validator.validate(order);\nfor (ConstraintViolation&lt;Order&gt; violation : violations) &#123;\n    System.out.println(violation.getMessage());\n&#125;</code></pre>\n\n<p>在上述代码中，我们创建了一个 <code>Order</code> 对象并将其 <code>amount</code> 属性设置为 <code>-1.00</code>。然后，我们使用 Validator 对象验证该对象，并获取验证错误的列表。由于 <code>amount</code> 属性的值不是正数，因此会生成一个验证错误，该错误消息为 “订单金额必须为正数”。</p>\n<p>需要注意的是，<code>@Positive</code> 注解只适用于数值类型，包括原始类型和包装类型（如 <code>int</code>、<code>Integer</code>、<code>double</code>、<code>Double</code> 等）。如果您想验证其他类型的值是否为正数，可以考虑使用其他适当的验证注解。</p>\n<h3 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"@Null\"></a>@Null</h3><p><code>@Null</code> 是 Java 中的一个注解，用于指定被注解的属性必须为 <code>null</code>。如果一个属性被标记为 <code>@Null</code>，但是其值不为 <code>null</code>，则会触发验证错误。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    @Null(message &#x3D; &quot;身份证号必须为空&quot;)\n    private String idCard;\n\n    &#x2F;&#x2F; getter 和 setter 方法\n&#125;</code></pre>\n\n<p>在上述示例中，<code>idCard</code> 属性被标记为 <code>@Null</code>，它的值必须为 <code>null</code>，否则会触发验证错误。如果您使用 Java Bean Validation 框架进行验证，可以使用类似下面的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ValidatorFactory factory &#x3D; Validation.buildDefaultValidatorFactory();\nValidator validator &#x3D; factory.getValidator();\n\nPerson person &#x3D; new Person();\nperson.setIdCard(&quot;1234567890&quot;);\n\nSet&lt;ConstraintViolation&lt;Person&gt;&gt; violations &#x3D; validator.validate(person);\nfor (ConstraintViolation&lt;Person&gt; violation : violations) &#123;\n    System.out.println(violation.getMessage());\n&#125;</code></pre>\n\n<p>在上述代码中，我们创建了一个 <code>Person</code> 对象并设置了其 <code>idCard</code> 属性。然后，我们使用 Validator 对象验证该对象，并获取验证错误的列表。由于 <code>idCard</code> 属性的值不为 <code>null</code>，因此会生成一个验证错误，该错误消息为 “身份证号必须为空”。</p>\n<p>需要注意的是，<code>@Null</code> 注解只适用于引用类型，包括 <code>String</code>、集合和自定义类等。对于原始类型和包装类型（如 <code>int</code>、<code>Integer</code>、<code>double</code>、<code>Double</code> 等），应该使用 <code>@NotNull</code> 或 <code>@NotEmpty</code> 注解。</p>\n<h3 id=\"NotNull\"><a href=\"#NotNull\" class=\"headerlink\" title=\"@NotNull\"></a>@NotNull</h3><p><code>@NotNull</code> 是 Java 中的一个注解，用于指定被注解的属性必须为非空。如果一个属性被标记为 <code>@NotNull</code>，但是其值为 <code>null</code>，则会触发验证错误。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    @NotNull(message &#x3D; &quot;姓名不能为空&quot;)\n    private String name;\n\n    &#x2F;&#x2F; getter 和 setter 方法\n&#125;</code></pre>\n\n<p>在上述示例中，<code>name</code> 属性被标记为 <code>@NotNull</code>，它的值必须为非空，否则会触发验证错误。如果您使用 Java Bean Validation 框架进行验证，可以使用类似下面的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ValidatorFactory factory &#x3D; Validation.buildDefaultValidatorFactory();\nValidator validator &#x3D; factory.getValidator();\n\nPerson person &#x3D; new Person();\nperson.setName(null);\n\nSet&lt;ConstraintViolation&lt;Person&gt;&gt; violations &#x3D; validator.validate(person);\nfor (ConstraintViolation&lt;Person&gt; violation : violations) &#123;\n    System.out.println(violation.getMessage());\n&#125;</code></pre>\n\n<p>在上述代码中，我们创建了一个 <code>Person</code> 对象并将其 <code>name</code> 属性设置为 <code>null</code>。然后，我们使用 Validator 对象验证该对象，并获取验证错误的列表。由于 <code>name</code> 属性的值为 <code>null</code>，因此会生成一个验证错误，该错误消息为 “姓名不能为空”。</p>\n<p>需要注意的是，<code>@NotNull</code> 注解只适用于引用类型，包括 <code>String</code>、集合和自定义类等。对于原始类型和包装类型（如 <code>int</code>、<code>Integer</code>、<code>double</code>、<code>Double</code> 等），应该使用 <code>@NotNull</code> 或 <code>@NotEmpty</code></p>\n<h3 id=\"AssertTrue\"><a href=\"#AssertTrue\" class=\"headerlink\" title=\"@AssertTrue\"></a>@AssertTrue</h3><p><code>@AssertTrue</code> 是 Java 中的一个注解，用于指定被注解的属性或方法必须为 <code>true</code>。如果一个属性或方法被标记为 <code>@AssertTrue</code>，但它的返回值为 <code>false</code>，则会触发验证错误。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    private boolean adult;\n\n    @AssertTrue(message &#x3D; &quot;必须为成年人&quot;)\n    public boolean isAdult() &#123;\n        return adult;\n    &#125;\n\n    &#x2F;&#x2F; getter 和 setter 方法\n&#125;</code></pre>\n\n<p>在上述示例中，<code>isAdult()</code> 方法被标记为 <code>@AssertTrue</code>，它的返回值必须为 <code>true</code>，否则会触发验证错误。如果您使用 Java Bean Validation 框架进行验证，可以使用类似下面的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ValidatorFactory factory &#x3D; Validation.buildDefaultValidatorFactory();\nValidator validator &#x3D; factory.getValidator();\n\nPerson person &#x3D; new Person();\nperson.setAdult(false);\n\nSet&lt;ConstraintViolation&lt;Person&gt;&gt; violations &#x3D; validator.validate(person);\nfor (ConstraintViolation&lt;Person&gt; violation : violations) &#123;\n    System.out.println(violation.getMessage());\n&#125;</code></pre>\n\n<p>在上述代码中，我们创建了一个 <code>Person</code> 对象并将其</p>\n<h3 id=\"AssertFalse\"><a href=\"#AssertFalse\" class=\"headerlink\" title=\"@AssertFalse\"></a>@AssertFalse</h3><h3 id=\"Min-注解\"><a href=\"#Min-注解\" class=\"headerlink\" title=\"@Min 注解\"></a>@Min 注解</h3><p><code>@Min</code> 注解是 Java 中的一个注解，用于指定被注解的属性或方法必须大于或等于指定的最小值。如果一个属性或方法被标记为 <code>@Min(value = num)</code>，但它的返回值小于 <code>num</code>，则会触发验证错误。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Min(value &#x3D; num, message &#x3D; &quot;错误消息&quot;)</code></pre>\n\n<p>其中：</p>\n<ul>\n<li><code>value</code>：指定最小值，该值必须是一个整数或长整数。</li>\n<li><code>message</code>：可选参数，用于指定验证失败时的错误消息。</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    @Min(value &#x3D; 18, message &#x3D; &quot;必须年满18岁&quot;)\n    private int age;\n\n    &#x2F;&#x2F; getter 和 setter 方法\n&#125;</code></pre>\n\n<p>在上述示例中，<code>age</code> 属性被标记为 <code>@Min(value = 18)</code>，它的返回值必须大于或等于 18，否则会触发验证错误。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li><code>@Min</code> 注解只适用于数字类型和 <code>CharSequence</code> 类型。对于其他类型的属性或方法，应该使用不同的注解进行验证。</li>\n<li>如果被注解的属性或方法的类型为原始类型（如 <code>int</code>、<code>long</code> 等），则 <code>value</code> 参数必须与该类型相同。如果被注解的属性或方法的类型为包装类型（如 <code>Integer</code>、<code>Long</code> 等），则 <code>value</code> 参数可以是相应的原始类型或包装类型。</li>\n<li>如果被注解的属性或方法的类型为 <code>CharSequence</code>，则 <code>value</code> 参数将被解释为一个字符串，并将其转换为一个数字。如果无法将该字符串转换为数字，则会触发验证错误。</li>\n<li>如果没有指定 <code>message</code> 参数，则将使用默认错误消息，即 “{javax.validation.constraints.Min.message}”。</li>\n</ul>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    @Min(value &#x3D; 18, message &#x3D; &quot;必须年满18岁&quot;)\n    private int age;\n\n    &#x2F;&#x2F; getter 和 setter 方法\n&#125;</code></pre>\n\n<h1 id=\"restfull\"><a href=\"#restfull\" class=\"headerlink\" title=\"restfull\"></a>restfull</h1><h2 id=\"RESTful-风格的注解有哪些？\"><a href=\"#RESTful-风格的注解有哪些？\" class=\"headerlink\" title=\"RESTful 风格的注解有哪些？\"></a>RESTful 风格的注解有哪些？</h2><p>以下是常用的 RESTful 风格的注解：</p>\n<ol>\n<li><code>@Path</code>：指定资源的路径，可以在类或方法级别上使用；</li>\n<li><code>@GET</code>：指定获取资源的方法，通常用于获取数据；</li>\n<li><code>@POST</code>：指定创建资源的方法，通常用于提交数据；</li>\n<li><code>@PUT</code>：指定更新资源的方法，通常用于更新数据；</li>\n<li><code>@DELETE</code>：指定删除资源的方法，通常用于删除数据；</li>\n<li><code>@PathParam</code>：指定获取路径参数的值；</li>\n<li><code>@QueryParam</code>：指定获取查询参数的值；</li>\n<li><code>@FormParam</code>：指定获取表单参数的值；</li>\n<li><code>@HeaderParam</code>：指定获取请求头中的参数的值；</li>\n<li><code>@CookieParam</code>：指定获取请求中的 cookie 的值；</li>\n<li><code>@Consumes</code>：指定接受请求的 MIME 类型；</li>\n<li><code>@Produces</code>：指定返回响应的 MIME 类型；</li>\n<li><code>@Context</code>：指定注入上下文对象，如 HttpServletRequest、HttpServletResponse 等。</li>\n</ol>\n<p>这些注解可以用于开发 RESTful 风格的应用程序，它们帮助开发人员定义和映射 API 路由以及处理 HTTP 请求和响应。</p>\n<p>以下是每个注解的示例：</p>\n<ol>\n<li><code>@Path</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\npublic class UserController &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li><code>@GET</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\n@GET\npublic User getUserById(@PathParam(&quot;id&quot;) int id) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li><code>@POST</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@POST\n@Consumes(MediaType.APPLICATION_JSON)\npublic Response createUser(User user) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li><code>@PUT</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\n@PUT\n@Consumes(MediaType.APPLICATION_JSON)\npublic Response updateUser(@PathParam(&quot;id&quot;) int id, User user) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li><code>@DELETE</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\n@DELETE\npublic Response deleteUser(@PathParam(&quot;id&quot;) int id) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"6\">\n<li><code>@PathParam</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\n@GET\npublic User getUserById(@PathParam(&quot;id&quot;) int id) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"7\">\n<li><code>@QueryParam</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@GET\npublic List&lt;User&gt; getUsers(\n  @QueryParam(&quot;page&quot;) int page,\n  @QueryParam(&quot;per_page&quot;) int perPage\n) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"8\">\n<li><code>@FormParam</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@POST\npublic Response createUser(\n  @FormParam(&quot;name&quot;) String name,\n  @FormParam(&quot;email&quot;) String email\n) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"9\">\n<li><code>@HeaderParam</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@GET\npublic List&lt;User&gt; getUsers(@HeaderParam(&quot;Authorization&quot;) String auth) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"10\">\n<li><code>@CookieParam</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@GET\npublic List&lt;User&gt; getUsers(@CookieParam(&quot;session_id&quot;) String sessionId) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"11\">\n<li><code>@Consumes</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@POST\n@Consumes(MediaType.APPLICATION_JSON)\npublic Response createUser(User user) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"12\">\n<li><code>@Produces</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@GET\n@Produces(MediaType.APPLICATION_JSON)\npublic List&lt;User&gt; getUsers() &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"13\">\n<li><code>@Context</code>：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\n@GET\npublic List&lt;User&gt; getUsers(@Context HttpServletRequest request) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>这些示例展示了如何使用注解来定义 RESTful Web 服务的 API 路由、处理 HTTP 请求和响应。</p>\n<h2 id=\"每个提供一个请求示例-不太友好啊\"><a href=\"#每个提供一个请求示例-不太友好啊\" class=\"headerlink\" title=\"每个提供一个请求示例 不太友好啊\"></a>每个提供一个请求示例 不太友好啊</h2><p>以下是每个注解的请求示例：</p>\n<ol>\n<li><p><code>@Path</code>：如果使用以下 URL（基本 URL + <code>/users</code>）调用 Web 服务，则路由到 <code>UserController</code> 类：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre>\n</li>\n<li><p><code>@GET</code>：使用以下 URL 调用 <code>getUserById</code> 方法，其中 <code>id</code> 参数的值为 123：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users&#x2F;123</code></pre>\n</li>\n<li><p><code>@POST</code>：向以下 URL 发送 <code>User</code> 对象的 JSON 表示形式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre>\n</li>\n<li><p><code>@PUT</code>：向以下 URL 发送 <code>User</code> 对象的 JSON 表示形式，其中 <code>id</code> 参数的值为 123：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users&#x2F;123</code></pre>\n</li>\n<li><p><code>@DELETE</code>：使用以下 URL 调用 <code>deleteUser</code> 方法，其中 <code>id</code> 参数的值为 123：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users&#x2F;123</code></pre>\n</li>\n<li><p><code>@PathParam</code>：使用以下 URL 调用 <code>getUserById</code> 方法，其中 <code>id</code> 参数的值为 123：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users&#x2F;123</code></pre>\n</li>\n<li><p><code>@QueryParam</code>：使用以下 URL 调用 <code>getUsers</code> 方法，并用 <code>page</code> 和 <code>per_page</code> 参数指定分页参数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users?page&#x3D;1&amp;per_page&#x3D;10</code></pre>\n</li>\n<li><p><code>@FormParam</code>：向以下 URL 发送 <code>name</code> 和 <code>email</code> 表单参数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre>\n</li>\n<li><p><code>@HeaderParam</code>：使用以下 URL 调用 <code>getUsers</code> 方法，并将 <code>Authorization</code> 标头设置为 JWT：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></pre>\n</li>\n<li><p><code>@CookieParam</code>：使用以下 URL 调用 <code>getUsers</code> 方法，并将 <code>session_id</code> cookie 设置为会话 ID：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Cookie: session_id&#x3D;abc123</code></pre>\n</li>\n<li><p><code>@Consumes</code>：向以下 URL 发送 <code>User</code> 对象的 JSON 表示形式，并将 <code>Content-Type</code> 标头设置为 <code>application/json</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Content-Type: application&#x2F;json\n\n&#123;\n  &quot;name&quot;: &quot;Alice&quot;,\n  &quot;email&quot;: &quot;alice@example.com&quot;\n&#125;</code></pre>\n</li>\n<li><p><code>@Produces</code>：使用以下 URL 调用 <code>getUsers</code> 方法，并将 <code>Accept</code> 标头设置为 <code>application/json</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Accept: application&#x2F;json</code></pre>\n</li>\n<li><p><code>@Context</code>：使用以下 URL 调用 <code>getUsers</code> 方法，并将 <code>HttpServletRequest</code> 对象传递给 <code>@Context</code> 标记的参数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;users</code></pre></li>\n</ol>\n<h2 id=\"更详细\"><a href=\"#更详细\" class=\"headerlink\" title=\"更详细\"></a>更详细</h2><p>当使用 Java 中的 JAX-RS 或类似框架时，您可以使用各种注解来定义 RESTful Web 服务的路由、HTTP 请求方法、路径参数、查询参数、请求体、响应头等等。</p>\n<p>以下是每个注解以及使用示例的更详细说明：</p>\n<ol>\n<li><p><code>@Path</code>：指定类或方法的路径，用于将 Web 服务请求路由到正确的位置。例如，如果有一个名为 <code>UserController</code> 的控制器类，并且希望将所有 <code>/users</code> 路径的请求路由到该类下的方法，可以使用以下代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\npublic class UserController &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@GET</code>：指定方法用于处理 HTTP GET 请求。例如，以下代码定义了一个 <code>getUserById</code> 方法，用于获取具有指定 ID 的用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\n@Path(&quot;&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@PathParam(&quot;id&quot;) int id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@POST</code>：指定方法用于处理 HTTP POST 请求。例如，以下代码定义了一个 <code>createUser</code> 方法，用于创建新用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@POST\npublic void createUser(User user) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@PUT</code>：指定方法用于处理 HTTP PUT 请求。例如，以下代码定义了一个 <code>updateUser</code> 方法，用于更新具有指定 ID 的用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PUT\n@Path(&quot;&#x2F;&#123;id&#125;&quot;)\npublic void updateUser(@PathParam(&quot;id&quot;) int id, User user) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@DELETE</code>：指定方法用于处理 HTTP DELETE 请求。例如，以下代码定义了一个 <code>deleteUser</code> 方法，用于删除具有指定 ID 的用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@DELETE\n@Path(&quot;&#x2F;&#123;id&#125;&quot;)\npublic void deleteUser(@PathParam(&quot;id&quot;) int id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@PathParam</code>：指定路由路径中的参数。例如，在上面的 <code>getUserById</code> 方法示例中，<code>&#123;id&#125;</code> 是一个路径参数，可以使用 <code>@PathParam</code> 注解来访问它的值：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\n@Path(&quot;&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@PathParam(&quot;id&quot;) int id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@QueryParam</code>：指定查询参数。例如，以下代码定义了一个 <code>getUsers</code> 方法，用于获取用户列表，并使用 <code>page</code> 和 <code>per_page</code> 参数指定分页：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\npublic List&lt;User&gt; getUsers(\n        @QueryParam(&quot;page&quot;) int page,\n        @QueryParam(&quot;per_page&quot;) int perPage) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@FormParam</code>：指定表单参数。例如，以下代码定义了一个 <code>createUser</code> 方法，用于从表单中创建新用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@POST\npublic void createUser(\n        @FormParam(&quot;name&quot;) String name,\n        @FormParam(&quot;email&quot;) String email) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@HeaderParam</code>：指定请求标头参数。例如，以下代码定义了一个 <code>getUsers</code> 方法，并将 <code>Authorization</code> 标头设置为 JWT：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\npublic List&lt;User&gt; getUsers(\n        @HeaderParam(&quot;Authorization&quot;) String authorization) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@CookieParam</code>：指定 cookie 参数。例如，以下代码定义了一个 <code>getUsers</code> 方法，并将 <code>session_id</code> cookie 设置为会话 ID：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\npublic List&lt;User&gt; getUsers(\n        @CookieParam(&quot;session_id&quot;) String sessionId) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@Consumes</code>：指定请求体的 MIME 类型。例如，以下代码定义了一个 <code>createUser</code> 方法，用于从 JSON 请求体中创建新用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@POST\n@Consumes(MediaType.APPLICATION_JSON)\npublic void createUser(User user) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@Produces</code>：指定响应的 MIME 类型。例如，以下代码定义了一个 <code>getUsers</code> 方法，以 JSON 格式返回用户列表：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\n@Produces(MediaType.APPLICATION</code></pre>\n</li>\n<li><p><code>@DefaultValue</code>：指定查询参数、表单参数或标头参数的默认值。例如，以下代码定义了一个 <code>getUsers</code> 方法，使用 <code>page</code> 查询参数指定分页，默认为 <code>1</code>：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\npublic List&lt;User&gt; getUsers(\n        @QueryParam(&quot;page&quot;) @DefaultValue(&quot;1&quot;) int page) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@Encoded</code>：指示注释的元素是否应编码。例如，以下代码定义了一个 <code>getUserByName</code> 方法，使用 URL 编码的用户名作为路径参数：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\n@Path(&quot;&#x2F;&#123;name&#125;&quot;)\npublic User getUserByName(@Encoded @PathParam(&quot;name&quot;) String name) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@Context</code>：注入 JAX-RS 上下文对象。例如，以下代码定义了一个 <code>getUsers</code> 方法，并注入 <code>UriInfo</code> 对象，用于访问请求的 URI 和查询参数：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\npublic List&lt;User&gt; getUsers(@Context UriInfo uriInfo) &#123;\n    String query &#x3D; uriInfo.getRequestUri().getQuery();\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ol>\n<p>这些注解是 JAX-RS 中最常用的注解之一，但并不是全部。您还可以使用其他注解来指定更细粒度的控制，例如 <code>@MatrixParam</code> 用于访问路径矩阵参数、<code>@BeanParam</code> 用于注入一个参数对象等等。在编写 RESTful Web 服务时，了解这些注解是至关重要的。</p>\n<h2 id=\"前端-fetch\"><a href=\"#前端-fetch\" class=\"headerlink\" title=\"前端 fetch\"></a>前端 fetch</h2><p>以下是具有相应的前端 fetch 请求的示例：</p>\n<ol>\n<li><p><code>@GET</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(&#39;&#x2F;users&#39;)\n  .then((response) &#x3D;&gt; response.json())\n  .then((data) &#x3D;&gt; console.log(data))\n  .catch((error) &#x3D;&gt; console.error(error));</code></pre>\n</li>\n<li><p><code>@POST</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(&#39;&#x2F;users&#39;, &#123;\n  method: &#39;POST&#39;,\n  headers: new Headers(&#123;\n    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,\n  &#125;),\n  body: JSON.stringify(&#123;\n    name: &#39;John Doe&#39;,\n    email: &#39;johndoe@example.com&#39;,\n  &#125;),\n&#125;)\n  .then((response) &#x3D;&gt; response.json())\n  .then((data) &#x3D;&gt; console.log(data))\n  .catch((error) &#x3D;&gt; console.error(error));</code></pre>\n</li>\n<li><p><code>@PUT</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(&#39;&#x2F;users&#x2F;1&#39;, &#123;\n  method: &#39;PUT&#39;,\n  headers: new Headers(&#123;\n    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,\n  &#125;),\n  body: JSON.stringify(&#123;\n    name: &#39;John Doe&#39;,\n    email: &#39;johndoe@example.com&#39;,\n  &#125;),\n&#125;)\n  .then((response) &#x3D;&gt; response.json())\n  .then((data) &#x3D;&gt; console.log(data))\n  .catch((error) &#x3D;&gt; console.error(error));</code></pre>\n</li>\n<li><p><code>@DELETE</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(&#39;&#x2F;users&#x2F;1&#39;, &#123;\n  method: &#39;DELETE&#39;,\n&#125;)\n  .then((response) &#x3D;&gt; console.log(&#39;User deleted successfully&#39;))\n  .catch((error) &#x3D;&gt; console.error(error));</code></pre></li>\n</ol>\n<p>请注意，在使用 fetch 发送请求时，需要指定请求的 HTTP 方法、请求头和请求体等信息。同时，还需要注意处理异步响应的方式，例如使用 <code>then</code> 和 <code>catch</code> 方法处理响应和错误。</p>\n<h2 id=\"PathParam-和-QueryParam-的区别\"><a href=\"#PathParam-和-QueryParam-的区别\" class=\"headerlink\" title=\"@PathParam 和 @QueryParam 的区别\"></a>@PathParam 和 @QueryParam 的区别</h2><p>@PathParam 和 @QueryParam 是 JAX-RS 中的两个注解，用于从 HTTP 请求的 URL 中提取路径参数和查询参数。</p>\n<p>@PathParam 用于提取 URL 中的路径参数，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\n@Path(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\npublic User getUser(@PathParam(&quot;id&quot;) Long id) &#123;\n    &#x2F;&#x2F; 根据 id 查询用户信息\n    &#x2F;&#x2F; ...\n    return user;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>@Path(&quot;/users/&#123;id&#125;&quot;)</code> 指定了 URL 的模式，其中 <code>&#123;id&#125;</code> 表示路径参数，该参数将通过 <code>@PathParam(&quot;id&quot;)</code> 注解绑定到 <code>id</code> 变量上。例如，如果请求的 URL 为 <code>/users/1</code>，则 <code>id</code> 的值为 <code>1</code>。</p>\n<p>@QueryParam 用于提取 URL 中的查询参数，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GET\n@Path(&quot;&#x2F;users&quot;)\npublic List&lt;User&gt; getUsers(\n    @QueryParam(&quot;page&quot;) Integer page,\n    @QueryParam(&quot;size&quot;) Integer size\n) &#123;\n    &#x2F;&#x2F; 根据 page 和 size 查询用户列表\n    &#x2F;&#x2F; ...\n    return users;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>@QueryParam</code> 注解用于绑定 URL 中的查询参数，例如 <code>/users?page=1&amp;size=10</code>，其中 <code>page</code> 和 <code>size</code> 将分别绑定到 <code>page</code> 和 <code>size</code> 变量上，它们的值分别为 <code>1</code> 和 <code>10</code>。</p>\n<p>请注意，@PathParam 和 @QueryParam 注解只能用于 JAX-RS 资源方法中的参数上，它们不能用于类或属性上。</p>\n<h2 id=\"Path-与-FormParam-的区别\"><a href=\"#Path-与-FormParam-的区别\" class=\"headerlink\" title=\"@Path 与 @FormParam 的区别\"></a>@Path 与 @FormParam 的区别</h2><p>@Path 和 @FormParam 是 JAX-RS 中的两个注解，但它们的作用不同。</p>\n<p>@Path 注解是用于声明 REST 资源类或方法的 URL 路径模板。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Path(&quot;&#x2F;users&quot;)\npublic class UserResource &#123;\n\n    @GET\n    @Path(&quot;&#x2F;&#123;id&#125;&quot;)\n    public User getUserById(@PathParam(&quot;id&quot;) Long id) &#123;\n        &#x2F;&#x2F; 根据 id 查询用户信息\n        &#x2F;&#x2F; ...\n        return user;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>@Path(&quot;/users&quot;)</code> 声明了 UserResource 类的 URL 路径模板，而 <code>@Path(&quot;/&#123;id&#125;&quot;)</code> 则声明了 getUserById 方法的 URL 路径模板。这意味着在访问 getUserById 方法时，请求的 URL 路径应该类似于 <code>/users/1</code>，其中 <code>1</code> 是路径参数，通过 <code>@PathParam(&quot;id&quot;)</code> 注解绑定到 <code>id</code> 变量上。</p>\n<p>但是，@FormParam 注解是用于从 HTTP 请求的表单数据中提取参数值的注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@POST\n@Path(&quot;&#x2F;users&quot;)\npublic Response createUser(\n    @FormParam(&quot;name&quot;) String name,\n    @FormParam(&quot;email&quot;) String email,\n    @FormParam(&quot;password&quot;) String password\n) &#123;\n    &#x2F;&#x2F; 创建新用户\n    &#x2F;&#x2F; ...\n    return Response.ok().build();\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>@FormParam</code> 注解用于从 HTTP POST 请求的表单数据中提取参数值，通过 <code>name</code>、<code>email</code> 和 <code>password</code> 变量绑定这些参数值。</p>\n<p>因此，@Path 注解和 @FormParam 注解的作用不同，@Path 用于声明 URL 路径模板，而 @FormParam 用于从 HTTP 请求的表单数据中提取参数值。</p>\n<h2 id=\"PathVariable-与-PathParam-的区别\"><a href=\"#PathVariable-与-PathParam-的区别\" class=\"headerlink\" title=\"@PathVariable 与@PathParam 的区别\"></a>@PathVariable 与@PathParam 的区别</h2><h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"java-中的类是为了干嘛用的\"><a href=\"#java-中的类是为了干嘛用的\" class=\"headerlink\" title=\"java 中的类是为了干嘛用的\"></a>java 中的类是为了干嘛用的</h2><p>Java 中的类是一种用于封装数据和方法的抽象数据类型，它是面向对象编程的基础。类描述了一组相似的对象的行为和状态，包括：</p>\n<ul>\n<li>实例变量：描述对象的状态，存储在对象中。</li>\n<li>构造函数：用于创建对象，初始化实例变量。</li>\n<li>方法：描述对象的行为，可以访问和修改实例变量。</li>\n</ul>\n<p>类是 Java 中最基本的组成部分之一，可以创建任意数量的对象来访问类中定义的方法和实例变量。在 Java 中，类通常用于：</p>\n<ul>\n<li>封装数据：类中的实例变量可以存储对象的状态，而方法可以允许其他代码修改这些状态。</li>\n<li>抽象行为：通过把方法与特定的类相关联，类可以抽象出一些行为模式，从而使得代码更加可读和可维护。</li>\n<li>代码复用：类可以继承和实现其他类，从而获得它们的方法和行为，从而减少代码重复。</li>\n<li>限制访问：类可以使用访问修饰符限制其他代码对实例变量和方法的访问，从而保护数据安全和程序的正确性。</li>\n</ul>\n<p>总之，类是 Java 中最基本的组成部分之一，它提供了一种强大的机制来封装数据和行为，从而使代码更容易理解、维护和扩展。</p>\n<h2 id=\"类就是一种自定义的数据类型\"><a href=\"#类就是一种自定义的数据类型\" class=\"headerlink\" title=\"类就是一种自定义的数据类型\"></a>类就是一种自定义的数据类型</h2><p>是的，类可以被看作一种自定义的数据类型。类允许程序员将数据和相关的方法组合在一起，形成一个包含特定行为和属性的对象。可以使用类来创建一个或多个实例，每个实例都有自己的属性值，但共享类中定义的方法。</p>\n<p>Java 中的类是一种面向对象编程的基本单元。使用类可以将代码和数据结构封装在一起，从而提高代码的可重用性、可读性和可维护性。类可以定义实例变量和方法，以及构造函数用于初始化实例变量。程序员可以使用类来创建对象，并通过访问对象的方法来操作对象的状态。</p>\n<p>Java 中的类还支持继承和多态等特性，以便实现更复杂的对象关系和行为。类可以扩展其他类，以获得父类的属性和方法，并且可以重写父类的方法以实现特定的行为。此外，类还可以实现接口，以提供特定的行为和功能。</p>\n<p>总之，Java 中的类是一种自定义的数据类型，允许程序员将数据和相关的方法组合在一起形成一个包含特定行为和属性的对象。通过使用类，程序员可以更好地组织代码并实现复杂的对象关系和行为。</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><ol>\n<li>基本数据类型有哪些</li>\n<li>字符串</li>\n<li>数组</li>\n<li>集合</li>\n<li>字典</li>\n</ol>\n<h1 id=\"swagger-如何使用\"><a href=\"#swagger-如何使用\" class=\"headerlink\" title=\"swagger 如何使用\"></a>swagger 如何使用</h1><p>Swagger 是一种 API 文档生成工具，可以根据代码自动生成 API 文档，并提供在线 API 文档浏览器和测试工具。在 Java 中，可以使用 Swagger 来生成 RESTful API 文档。下面是使用 Swagger 的简要步骤：</p>\n<ol>\n<li>添加 Swagger Maven 依赖</li>\n</ol>\n<p>在 Maven 项目的 pom.xml 文件中添加 Swagger Maven 依赖：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<ol start=\"2\">\n<li>创建 Swagger 配置类</li>\n</ol>\n<p>创建一个 Swagger 配置类，用于 Swagger 相关配置：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n@EnableSwagger2\npublic class SwaggerConfig &#123;\n\n    @Bean\n    public Docket api() &#123;\n        return new Docket(DocumentationType.SWAGGER_2)\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo.controller&quot;))\n                .paths(PathSelectors.any())\n                .build()\n                .apiInfo(apiInfo());\n    &#125;\n\n    private ApiInfo apiInfo() &#123;\n        return new ApiInfoBuilder()\n                .title(&quot;Demo API&quot;)\n                .description(&quot;Demo API 文档&quot;)\n                .version(&quot;1.0.0&quot;)\n                .build();\n    &#125;\n\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>在 Controller 类中添加 Swagger 注解</li>\n</ol>\n<p>在需要生成 API 文档的 Controller 类和方法上添加 Swagger 注解，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;api&quot;)\n@Api(tags&#x3D;&quot;用户管理&quot;)\npublic class UserController &#123;\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(&quot;&#x2F;users&quot;)\n    @ApiOperation(&quot;获取所有用户信息&quot;)\n    public List&lt;User&gt; getUsers() &#123;\n        return userService.getUsers();\n    &#125;\n\n    @PostMapping(&quot;&#x2F;users&quot;)\n    @ApiOperation(&quot;创建用户&quot;)\n    public User createUser(@RequestBody User user) &#123;\n        return userService.createUser(user);\n    &#125;\n\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>启动项目并访问 Swagger UI</li>\n</ol>\n<p>启动项目之后，访问 Swagger UI 地址即可查看生成的 API 文档和测试工具，默认地址为：<a href=\"http://localhost:8080/swagger-ui.html%E3%80%82\">http://localhost:8080/swagger-ui.html。</a></p>\n<p>以上是使用 Swagger 的简要步骤，具体使用可以参考 Swagger 官方文档。</p>\n<h2 id=\"swagger-的注解有哪些\"><a href=\"#swagger-的注解有哪些\" class=\"headerlink\" title=\"swagger 的注解有哪些\"></a>swagger 的注解有哪些</h2><p>Swagger 的注解用于标记 API 文档的相关信息，包括 API 的描述、参数、返回值、响应码等，常用的注解有以下几种：</p>\n<ol>\n<li><p><code>@Api</code>：用于标记 Controller 类，表示该类是 Swagger API 文档的一部分。</p>\n</li>\n<li><p><code>@ApiOperation</code>：用于标记 Controller 中的方法，表示该方法是 API 的一个操作，并提供该操作的描述信息。</p>\n</li>\n<li><p><code>@ApiParam</code>：用于标记 Controller 中的参数，表示该参数是 API 操作的一个输入参数，并提供该参数的描述信息。</p>\n</li>\n<li><p><code>@ApiImplicitParam</code>：用于标记 Controller 中的参数，表示该参数是 API 操作的一个输入参数，并提供该参数的描述信息，与@ApiParam 不同的是，该注解支持更多的参数配置。</p>\n</li>\n<li><p><code>@ApiResponses</code>：用于标记 Controller 中的方法，表示该方法的响应信息。</p>\n</li>\n<li><p><code>@ApiResponse</code>：用于标记 Controller 中的方法，表示该方法的一个响应信息。</p>\n</li>\n<li><p><code>@ApiModel</code>：用于标记 Model 类，表示该类是 Swagger API 文档的一部分。</p>\n</li>\n<li><p><code>@ApiModelProperty</code>：用于标记 Model 类中的属性，表示该属性是 Model 的一个属性，并提供该属性的描述信息。</p>\n</li>\n</ol>\n<p>以上是 Swagger 的常用注解，可以根据需要选择合适的注解来标记 API 文档。</p>\n<h2 id=\"每个-swagger-注解提供一个示例\"><a href=\"#每个-swagger-注解提供一个示例\" class=\"headerlink\" title=\"每个 swagger 注解提供一个示例\"></a>每个 swagger 注解提供一个示例</h2><p>以下是每个 Swagger 注解的示例：</p>\n<ol>\n<li>@Api</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Api(value &#x3D; &quot;用户管理&quot;, tags &#x3D; &#123;&quot;用户操作接口&quot;&#125;)\n@RestController\npublic class UserController &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>@ApiOperation</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;获取用户信息&quot;, notes &#x3D; &quot;根据用户ID获取用户信息&quot;)\n@GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@ApiParam(value &#x3D; &quot;用户ID&quot;, example &#x3D; &quot;1&quot;) @PathVariable(&quot;id&quot;) Long id) &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>@ApiParam</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;user&quot;)\npublic List&lt;User&gt; getUserList(@ApiParam(value &#x3D; &quot;用户名&quot;, example &#x3D; &quot;张三&quot;) @RequestParam(value &#x3D; &quot;name&quot;, required &#x3D; false) String name) &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>@ApiImplicitParam</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;新增用户&quot;, notes &#x3D; &quot;新增一个用户&quot;)\n@ApiImplicitParam(name &#x3D; &quot;user&quot;, value &#x3D; &quot;用户信息&quot;, required &#x3D; true, dataType &#x3D; &quot;User&quot;, paramType &#x3D; &quot;body&quot;)\n@PostMapping(&quot;&#x2F;user&quot;)\npublic void addUser(@RequestBody User user) &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>@ApiResponses</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;删除用户&quot;, notes &#x3D; &quot;根据用户ID删除用户&quot;)\n@ApiResponses(&#123;\n    @ApiResponse(code &#x3D; 200, message &#x3D; &quot;删除成功&quot;),\n    @ApiResponse(code &#x3D; 400, message &#x3D; &quot;请求参数错误&quot;),\n    @ApiResponse(code &#x3D; 401, message &#x3D; &quot;未授权&quot;),\n    @ApiResponse(code &#x3D; 403, message &#x3D; &quot;禁止访问&quot;),\n    @ApiResponse(code &#x3D; 500, message &#x3D; &quot;服务器内部错误&quot;)\n&#125;)\n@DeleteMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\npublic void deleteUserById(@PathVariable(&quot;id&quot;) Long id) &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ol start=\"6\">\n<li>@ApiResponse</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;修改用户信息&quot;, notes &#x3D; &quot;根据用户ID修改用户信息&quot;)\n@ApiResponses(&#123;\n    @ApiResponse(code &#x3D; 200, message &#x3D; &quot;修改成功&quot;),\n    @ApiResponse(code &#x3D; 400, message &#x3D; &quot;请求参数错误&quot;),\n    @ApiResponse(code &#x3D; 401, message &#x3D; &quot;未授权&quot;),\n    @ApiResponse(code &#x3D; 403, message &#x3D; &quot;禁止访问&quot;),\n    @ApiResponse(code &#x3D; 500, message &#x3D; &quot;服务器内部错误&quot;)\n&#125;)\n@PutMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\npublic void updateUserById(@PathVariable(&quot;id&quot;) Long id, @RequestBody User user) &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ol start=\"7\">\n<li>@ApiModel</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiModel(&quot;用户实体类&quot;)\npublic class User &#123;\n    @ApiModelProperty(value &#x3D; &quot;用户ID&quot;, example &#x3D; &quot;1&quot;)\n    private Long id;\n    @ApiModelProperty(value &#x3D; &quot;用户名&quot;, example &#x3D; &quot;张三&quot;)\n    private String name;\n    @ApiModelProperty(value &#x3D; &quot;年龄&quot;, example &#x3D; &quot;18&quot;)\n    private Integer age;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ol start=\"8\">\n<li>@ApiModelProperty</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiModel(&quot;用户实体类&quot;)\npublic class User &#123;\n    @ApiModelProperty(value &#x3D; &quot;用户ID&quot;, example &#x3D; &quot;1&quot;)\n    private Long id;\n    @ApiModelProperty(value &#x3D; &quot;用户名&quot;, example &#x3D; &quot;张三&quot;, required &#x3D; true)\n    private String name;\n    @ApiModelProperty(value &#x3D; &quot;年龄&quot;, example &#x3D; &quot;18&quot;)\n    private Integer age;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p>以上是每个 Swagger 注解的示例，可以根据需要进行参考和使用。</p>\n<h2 id=\"controller-层，springboot-与-swagger-注解同时使用怎么写比如-QueryParam\"><a href=\"#controller-层，springboot-与-swagger-注解同时使用怎么写比如-QueryParam\" class=\"headerlink\" title=\"controller 层，springboot 与 swagger 注解同时使用怎么写比如@QueryParam\"></a>controller 层，springboot 与 swagger 注解同时使用怎么写比如@QueryParam</h2><p>在 Spring Boot Controller 层与 Swagger 注解同时使用，可以结合 Swagger 注解中定义的请求参数相关注解来实现。</p>\n<p>例如，对于 <code>@QueryParam</code> 注解，可以使用 Swagger 中的 <code>@ApiParam</code> 注解来实现，示例如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;user&quot;)\npublic List&lt;User&gt; getUserList(\n        @ApiParam(value &#x3D; &quot;用户名&quot;, required &#x3D; false) @QueryParam(&quot;name&quot;) String name,\n        @ApiParam(value &#x3D; &quot;用户年龄&quot;, required &#x3D; false) @QueryParam(&quot;age&quot;) Integer age) &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p>其中，<code>@QueryParam</code> 注解用于获取请求参数，而 <code>@ApiParam</code> 注解则用于在 Swagger 中展示该请求参数的信息，包括参数名、是否必填、数据类型等。</p>\n<p>需要注意的是，<code>@ApiParam</code> 注解需要引入 <code>io.swagger.annotations.ApiParam</code> 类，这可以通过在 <code>pom.xml</code> 文件中添加以下依赖来实现：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;springfox.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;springfox.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>其中，<code>$&#123;springfox.version&#125;</code> 是 Springfox 的版本号，可以根据需要进行修改。</p>\n<p>除此之外，在 Controller 层使用 Swagger 注解时，还需要在启动类中添加以下注解：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableSwagger2\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class, args);\n    &#125;\n&#125;</code></pre>\n\n<p>这样就可以在 Swagger 中展示 Controller 层中的接口信息了。</p>\n<h2 id=\"这样看起来增加了很多的代码量\"><a href=\"#这样看起来增加了很多的代码量\" class=\"headerlink\" title=\"这样看起来增加了很多的代码量\"></a>这样看起来增加了很多的代码量</h2><p>确实，使用 Swagger 注解会增加一定的代码量，但其优势在于可以方便地生成接口文档，让接口文档与代码一起维护，有助于提高团队协作效率。</p>\n<p>同时，Swagger 也提供了一些方便的工具来简化注解的使用，比如可以使用 <code>@ApiOperation</code> 注解来描述接口的作用，使用 <code>@ApiImplicitParam</code> 注解来描述参数。这些工具可以极大地减少注解的使用量，使代码更加简洁清晰。</p>\n<p>总的来说，使用 Swagger 注解会增加一些代码量，但可以带来更好的团队协作效率和文档维护效率。如果对于代码量有较高要求，也可以考虑使用其他的文档生成工具来代替 Swagger。</p>\n<h2 id=\"ApiImplicitParam\"><a href=\"#ApiImplicitParam\" class=\"headerlink\" title=\"@ApiImplicitParam\"></a>@ApiImplicitParam</h2><p><code>@ApiImplicitParam</code> 是 Swagger 注解之一，用于描述接口参数的信息。</p>\n<p><code>@ApiImplicitParam</code> 的常用属性有：</p>\n<ul>\n<li><code>name</code>：参数名字。</li>\n<li><code>value</code>：参数的简单描述。</li>\n<li><code>required</code>：参数是否必须，默认为 <code>false</code>。</li>\n<li><code>dataType</code>：参数的数据类型，可以使用 Java 中的数据类型，也可以使用 Swagger 中的数据类型。</li>\n<li><code>paramType</code>：参数的传递方式，可以是 <code>path</code>、<code>query</code>、<code>header</code>、<code>body</code> 或者 <code>form</code>。</li>\n<li><code>defaultValue</code>：参数的默认值。</li>\n<li><code>allowableValues</code>：参数可选值的范围，可以用逗号分隔。</li>\n</ul>\n<p>举个例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;获取用户信息&quot;, notes &#x3D; &quot;根据用户 ID 获取用户信息&quot;)\n@ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;用户 ID&quot;, dataType &#x3D; &quot;Long&quot;, paramType &#x3D; &quot;path&quot;, required &#x3D; true)\n@GetMapping(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\npublic User getUser(@PathVariable Long id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>上面的代码中，<code>@ApiImplicitParam</code> 描述了接口的参数 <code>id</code>，参数的名字为 <code>id</code>，参数的简单描述为 “用户 ID”，参数的数据类型为 <code>Long</code>，参数的传递方式为 <code>path</code>，参数为必传参数。</p>\n<h2 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h2><p><a href=\"https://www.cnblogs.com/wyq178/p/10291447.html\" target=\"_blank\" >博客</a></p>\n<h2 id=\"ApiImplicitParams\"><a href=\"#ApiImplicitParams\" class=\"headerlink\" title=\"@ApiImplicitParams\"></a>@ApiImplicitParams</h2><p><code>@ApiImplicitParams</code> 是 Swagger2 中用于给 RESTful API 接口方法的参数列表添加说明信息的注解。它可以在方法级别上为所有参数添加说明，也可以在每个参数的注解上添加参数说明。</p>\n<p><code>@ApiImplicitParams</code> 注解包含了一个 <code>@ApiImplicitParam</code> 注解数组，每个 <code>@ApiImplicitParam</code> 注解用于描述一个参数。它包含以下信息：</p>\n<ul>\n<li><code>name</code>：参数名称。</li>\n<li><code>value</code>：参数的简要说明。</li>\n<li><code>dataType</code>：参数的数据类型。</li>\n<li><code>paramType</code>：参数的位置，可以是 path、query、header、cookie 和 form 中的一种。</li>\n<li><code>required</code>：参数是否为必填项。</li>\n<li><code>defaultValue</code>：参数的默认值。</li>\n</ul>\n<p>例如，以下是一个使用 <code>@ApiImplicitParams</code> 和 <code>@ApiImplicitParam</code> 注解的示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiImplicitParams(&#123;\n    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;User ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;, paramType&#x3D;&quot;path&quot;),\n    @ApiImplicitParam(name &#x3D; &quot;name&quot;, value &#x3D; &quot;User Name&quot;, required &#x3D; true, dataType &#x3D; &quot;String&quot;, paramType&#x3D;&quot;query&quot;)\n&#125;)\n@GetMapping(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@PathVariable(&quot;id&quot;) Long id, @RequestParam(&quot;name&quot;) String name) &#123;\n    return userService.getUserById(id);\n&#125;</code></pre>\n\n<p>在这个示例中，<code>@ApiImplicitParams</code> 注解用于给 <code>getUserById()</code> 方法的参数列表添加说明信息，包括参数名称、简要说明、数据类型、位置和是否为必填项。在 Swagger2 自动生成的 API 文档中，这些信息将被用于描述该接口方法的参数列表。</p>\n<h2 id=\"ApiImplicitParams-和-ApiImplicitParam-注解的区别\"><a href=\"#ApiImplicitParams-和-ApiImplicitParam-注解的区别\" class=\"headerlink\" title=\"@ApiImplicitParams 和 @ApiImplicitParam 注解的区别\"></a>@ApiImplicitParams 和 @ApiImplicitParam 注解的区别</h2><p><strong>可以理解为父子项关系</strong></p>\n<p><code>@ApiImplicitParams</code> 和 <code>@ApiImplicitParam</code> 注解都是 Swagger2 中用于给 RESTful API 接口方法的参数列表添加说明信息的注解，但它们之间有一些区别。</p>\n<ul>\n<li><code>@ApiImplicitParams</code> 注解用于在方法级别上为所有参数添加说明，它包含了一个 <code>@ApiImplicitParam</code> 注解数组，每个 <code>@ApiImplicitParam</code> 注解用于描述一个参数。</li>\n<li><code>@ApiImplicitParam</code> 注解用于在每个参数的注解上添加参数说明，它包含以下信息：参数名称、简要说明、数据类型、位置和是否为必填项。</li>\n</ul>\n<p>因此，<code>@ApiImplicitParams</code> 注解适用于需要为多个参数添加说明的情况，而 <code>@ApiImplicitParam</code> 注解适用于需要为单个参数添加说明的情况。在使用时，我们应该根据具体需求选择使用哪个注解。</p>\n<h2 id=\"ApiImplicitParams-和-ApiImplicitParam-使得-swagger-的注解独立于-controller-方法体内？\"><a href=\"#ApiImplicitParams-和-ApiImplicitParam-使得-swagger-的注解独立于-controller-方法体内？\" class=\"headerlink\" title=\"@ApiImplicitParams 和 @ApiImplicitParam 使得 swagger 的注解独立于 controller 方法体内？\"></a>@ApiImplicitParams 和 @ApiImplicitParam 使得 swagger 的注解独立于 controller 方法体内？</h2><ul>\n<li>@ApiParam 用于方法体内</li>\n<li>是的， @ApiImplicitParams 和 @ApiImplicitParam 注解可以为 Swagger2 API 添加参数说明信息，它们的存在使得 Swagger2 的注解与代码实现分离，可以使代码更加清晰可读，方便维护和更新 API。</li>\n</ul>\n<h2 id=\"ApiParam-与-ApiImplicitParam-的区别\"><a href=\"#ApiParam-与-ApiImplicitParam-的区别\" class=\"headerlink\" title=\"@ApiParam 与 @ApiImplicitParam 的区别\"></a>@ApiParam 与 @ApiImplicitParam 的区别</h2><p><code>@ApiParam</code> 和 <code>@ApiImplicitParam</code> 在参数上的使用方式是有区别的。</p>\n<p><code>@ApiParam</code> 注解可以用在方法的参数上，也可以用在属性的 getter 方法上，用来说明单个参数的信息。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@ApiParam(value &#x3D; &quot;用户ID&quot;, required &#x3D; true) @PathVariable Long id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>@ApiParam</code> 注解用于说明 <code>id</code> 这个参数的信息，包括参数名称、是否必填等。</p>\n<p>而 <code>@ApiImplicitParam</code> 注解则需要配合 <code>@ApiImplicitParams</code> 注解一起使用，用于说明多个参数的信息，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiImplicitParams(&#123;\n    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;用户ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;, paramType &#x3D; &quot;path&quot;),\n    @ApiImplicitParam(name &#x3D; &quot;name&quot;, value &#x3D; &quot;用户名&quot;, required &#x3D; true, dataType &#x3D; &quot;String&quot;, paramType &#x3D; &quot;query&quot;)\n&#125;)\n@GetMapping(&quot;&#x2F;users&quot;)\npublic List&lt;User&gt; getUsers(Long id, String name) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>@ApiImplicitParams</code> 注解用于包含多个 <code>@ApiImplicitParam</code> 注解，分别用于说明 <code>id</code> 和 <code>name</code> 这两个参数的信息。其中，<code>paramType</code> 属性用于指定参数的位置，例如 <code>path</code> 或 <code>query</code> 等。</p>\n<p>综上所述，虽然 <code>@ApiParam</code> 和 <code>@ApiImplicitParam</code> 都可以用于说明参数的信息，但是它们在参数上的使用方式是有区别的。</p>\n<h2 id=\"ApiOperation-与-Api-区别\"><a href=\"#ApiOperation-与-Api-区别\" class=\"headerlink\" title=\"@ApiOperation 与@Api 区别\"></a>@ApiOperation 与@Api 区别</h2><p><code>@ApiOperation</code> 和 <code>@Api</code> 都是 Swagger 注解，用于生成 API 文档。它们的作用不同：</p>\n<ul>\n<li><p><code>@Api</code> 注解用于标识一个 API 接口的基本信息，包括接口名称、接口描述、接口路径等，常用于类级别的注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Api(tags &#x3D; &quot;User&quot;, description &#x3D; &quot;用户相关接口&quot;)\n@RestController\npublic class UserController &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@ApiOperation</code> 注解用于标识一个具体的 API 操作，包括操作名称、操作描述、请求参数、返回值等，常用于方法级别的注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;获取用户信息&quot;, notes &#x3D; &quot;根据用户ID获取用户信息&quot;)\n@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@PathVariable Long id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ul>\n<p>总的来说，<code>@Api</code> 注解用于标识一个 API 接口的基本信息，而 <code>@ApiOperation</code> 注解用于标识一个具体的 API 操作的详细信息。两者结合使用，可以帮助我们生成清晰、完整的 API 文档。</p>\n<h2 id=\"ApiResponses-与-ApiResponse-的区别\"><a href=\"#ApiResponses-与-ApiResponse-的区别\" class=\"headerlink\" title=\"@ApiResponses 与 @ApiResponse 的区别\"></a>@ApiResponses 与 @ApiResponse 的区别</h2><p><strong>可以理解为父子项关系</strong></p>\n<p><code>@ApiResponses</code> 和 <code>@ApiResponse</code> 都是 Swagger 注解，用于生成 API 文档。它们的作用不同：</p>\n<ul>\n<li><p><code>@ApiResponse</code> 注解用于标识一个具体的 API 操作返回的响应信息，包括响应码、响应描述、响应模型等，常用于方法级别的注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;获取用户信息&quot;, notes &#x3D; &quot;根据用户ID获取用户信息&quot;)\n@ApiResponses(&#123;\n    @ApiResponse(code &#x3D; 200, message &#x3D; &quot;请求成功&quot;, response &#x3D; User.class),\n    @ApiResponse(code &#x3D; 404, message &#x3D; &quot;未找到用户信息&quot;)\n&#125;)\n@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@PathVariable Long id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@ApiResponses</code> 注解用于标识一个 API 操作的所有响应信息，包括成功响应和错误响应等，常用于方法级别的注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiOperation(value &#x3D; &quot;获取用户信息&quot;, notes &#x3D; &quot;根据用户ID获取用户信息&quot;)\n@ApiResponses(&#123;\n    @ApiResponse(code &#x3D; 200, message &#x3D; &quot;请求成功&quot;, response &#x3D; User.class),\n    @ApiResponse(code &#x3D; 401, message &#x3D; &quot;用户未登录&quot;),\n    @ApiResponse(code &#x3D; 403, message &#x3D; &quot;没有权限访问&quot;),\n    @ApiResponse(code &#x3D; 404, message &#x3D; &quot;未找到用户信息&quot;)\n&#125;)\n@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\npublic ResponseEntity&lt;User&gt; getUserById(@PathVariable Long id) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ul>\n<p>总的来说，<code>@ApiResponse</code> 注解用于标识一个具体的 API 操作返回的响应信息，而 <code>@ApiResponses</code> 注解用于标识一个 API 操作的所有响应信息。两者结合使用，可以帮助我们生成清晰、完整的 API 文档。</p>\n<h2 id=\"ApiModel-和-ApiModelProperty-的区别\"><a href=\"#ApiModel-和-ApiModelProperty-的区别\" class=\"headerlink\" title=\"@ApiModel 和 @ApiModelProperty 的区别\"></a>@ApiModel 和 @ApiModelProperty 的区别</h2><p><code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 都是 Swagger 注解，用于生成 API 文档。它们的作用不同：</p>\n<ul>\n<li><p><code>@ApiModel</code> 注解用于对模型类进行说明，常用于类级别的注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiModel(description &#x3D; &quot;用户信息&quot;)\npublic class User &#123;\n    @ApiModelProperty(value &#x3D; &quot;用户ID&quot;, example &#x3D; &quot;1&quot;)\n    private Long id;\n\n    @ApiModelProperty(value &#x3D; &quot;用户名&quot;, example &#x3D; &quot;John&quot;)\n    private String name;\n\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><code>@ApiModelProperty</code> 注解用于对模型类的属性进行说明，常用于属性级别的注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    @ApiModelProperty(value &#x3D; &quot;用户ID&quot;, example &#x3D; &quot;1&quot;)\n    private Long id;\n\n    @ApiModelProperty(value &#x3D; &quot;用户名&quot;, example &#x3D; &quot;John&quot;)\n    private String name;\n\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ul>\n<p>总的来说，<code>@ApiModel</code> 注解用于对模型类进行说明，而 <code>@ApiModelProperty</code> 注解用于对模型类的属性进行说明。两者结合使用，可以帮助我们生成清晰、完整的 API 文档。</p>\n<h2 id=\"controller-用自定义模型接收参数\"><a href=\"#controller-用自定义模型接收参数\" class=\"headerlink\" title=\"controller 用自定义模型接收参数\"></a>controller 用自定义模型接收参数</h2><p>在 Controller 中使用自定义模型类接收参数，可以将参数转换为更加直观、易于管理的对象，提高代码的可读性和可维护性。以下是一个简单的例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;users&quot;)\npublic class UserController &#123;\n\n    @PostMapping\n    public User createUser(@RequestBody User user) &#123;\n        &#x2F;&#x2F; 在这里可以对 user 对象进行业务逻辑处理\n        &#x2F;&#x2F; ...\n        return user;\n    &#125;\n\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>上述代码中，<code>createUser</code> 方法使用 <code>@RequestBody</code> 注解，表示接收请求体中的 JSON 数据，并将其转换为 <code>User</code> 对象。此时，Spring Boot 会自动根据请求体中的 JSON 数据，将其转换为 <code>User</code> 对象。</p>\n<p>如果请求体中的 JSON 数据字段名与 <code>User</code> 中的属性名不一致，可以使用 <code>@JsonProperty</code> 注解，指定它们之间的映射关系。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    @JsonProperty(&quot;user_id&quot;)\n    private Long id;\n    private String name;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>上述代码中，<code>id</code> 属性使用了 <code>@JsonProperty(&quot;user_id&quot;)</code> 注解，表示在将 JSON 数据转换为 <code>User</code> 对象时，将使用 <code>user_id</code> 字段的值来填充 <code>id</code> 属性。</p>\n<p>需要注意的是，当使用自定义模型类接收参数时，前端请求中的参数必须符合模型类中属性的类型和格式。如果请求参数不符合要求，Spring Boot 会自动返回 400 错误（Bad Request）。</p>\n<h2 id=\"返回值是模型的注解\"><a href=\"#返回值是模型的注解\" class=\"headerlink\" title=\"返回值是模型的注解\"></a>返回值是模型的注解</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;users&quot;)\n@Api(tags &#x3D; &quot;用户管理&quot;)\npublic class UserController &#123;\n\n    @PostMapping\n    @ApiOperation(value &#x3D; &quot;创建用户&quot;, notes &#x3D; &quot;根据用户对象创建用户&quot;)\n    @ApiResponses(&#123;\n            @ApiResponse(code &#x3D; 200, message &#x3D; &quot;成功&quot;, response &#x3D; User.class),\n            @ApiResponse(code &#x3D; 400, message &#x3D; &quot;请求参数错误&quot;),\n            @ApiResponse(code &#x3D; 500, message &#x3D; &quot;服务器内部错误&quot;)\n    &#125;)\n    public User createUser(\n            @ApiParam(name &#x3D; &quot;用户对象&quot;, value &#x3D; &quot;传入json格式&quot;, required &#x3D; true)\n            @RequestBody User user) &#123;\n        &#x2F;&#x2F; 在这里可以对 user 对象进行业务逻辑处理\n        &#x2F;&#x2F; ...\n        return user;\n    &#125;\n\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>上述代码中，@Api 注解用于指定接口所属的标签，@ApiOperation 注解用于说明接口的作用和参数，@ApiResponses 注解用于说明接口可能返回的状态码和响应类，@ApiParam 注解用于说明参数的名称、类型、格式和是否必填。在使用 Swagger 时，需要在项目中添加相应的依赖包，并配置 Swagger 的 Docket 对象</p>\n<h2 id=\"RequestBody-User-user-加-swagger-注解\"><a href=\"#RequestBody-User-user-加-swagger-注解\" class=\"headerlink\" title=\"@RequestBody User user 加 swagger 注解\"></a>@RequestBody User user 加 swagger 注解</h2><p>其实，<code>@RequestBody User user</code> 中的 <code>@RequestBody</code> 注解也可以加上 Swagger 的注解来说明请求参数的类型和格式。例如，可以在 <code>@ApiParam</code> 注解中使用 <code>dataType</code> 属性来指定请求参数的类型，如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping\n@ApiOperation(value &#x3D; &quot;创建用户&quot;, notes &#x3D; &quot;根据用户对象创建用户&quot;)\n@ApiResponses(&#123;\n        @ApiResponse(code &#x3D; 200, message &#x3D; &quot;成功&quot;, response &#x3D; User.class),\n        @ApiResponse(code &#x3D; 400, message &#x3D; &quot;请求参数错误&quot;),\n        @ApiResponse(code &#x3D; 500, message &#x3D; &quot;服务器内部错误&quot;)\n&#125;)\npublic User createUser(\n        @ApiParam(name &#x3D; &quot;用户对象&quot;, value &#x3D; &quot;传入json格式&quot;, required &#x3D; true, dataType &#x3D; &quot;User&quot;) &#x2F;&#x2F; dataType &#x3D; &quot;User&quot;\n        @RequestBody User user) &#123;\n    &#x2F;&#x2F; 在这里可以对 user 对象进行业务逻辑处理\n    &#x2F;&#x2F; ...\n    return user;\n&#125;</code></pre>\n\n<p>在上述代码中，我们在 <code>@ApiParam</code> 注解中添加了 <code>dataType = &quot;User&quot;</code> 属性来指定请求参数的类型为 User 类型。这样，Swagger 就能够正确地显示请求参数的类型和格式了。当然，如果不加 <code>dataType</code> 属性，Swagger 也可以根据 User 类型自动生成请求参数的说明。</p>\n<h2 id=\"dataType-会不会有两个-User-重复的情况？\"><a href=\"#dataType-会不会有两个-User-重复的情况？\" class=\"headerlink\" title=\"dataType 会不会有两个 User 重复的情况？\"></a>dataType 会不会有两个 User 重复的情况？</h2><p>如果你在同一个 Controller 类中有两个以上的方法都使用了 <code>@RequestBody User user</code> 的形式，那么在使用 Swagger 注解的时候可能会出现重复的情况。此时，你可以使用 <code>@ApiModel</code> 注解来定义一个模型类，用于描述 User 对象的属性和类型，然后在使用 <code>@RequestBody</code> 注解时指定该模型类即可避免重复。</p>\n<p>例如，我们可以在 Controller 类所在的包下创建一个名为 <code>UserRequest</code> 的类，用于描述 User 对象的属性和类型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ApiModel(&quot;用户请求参数&quot;)\npublic class UserRequest &#123;\n    @ApiModelProperty(value &#x3D; &quot;用户名&quot;, required &#x3D; true)\n    private String username;\n    @ApiModelProperty(value &#x3D; &quot;密码&quot;, required &#x3D; true)\n    private String password;\n    &#x2F;&#x2F; 其他属性\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; getter 和 setter 方法\n&#125;</code></pre>\n\n<p>然后，在 Controller 中使用该模型类来描述请求参数：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping\n@ApiOperation(value &#x3D; &quot;创建用户&quot;, notes &#x3D; &quot;根据用户对象创建用户&quot;)\n@ApiResponses(&#123;\n        @ApiResponse(code &#x3D; 200, message &#x3D; &quot;成功&quot;, response &#x3D; User.class),\n        @ApiResponse(code &#x3D; 400, message &#x3D; &quot;请求参数错误&quot;),\n        @ApiResponse(code &#x3D; 500, message &#x3D; &quot;服务器内部错误&quot;)\n&#125;)\npublic User createUser(\n        @ApiParam(name &#x3D; &quot;用户对象&quot;, value &#x3D; &quot;传入json格式&quot;, required &#x3D; true, dataType &#x3D; &quot;UserRequest&quot;)\n        @RequestBody UserRequest request) &#123;\n    &#x2F;&#x2F; 在这里可以对 request 对象进行业务逻辑处理\n    &#x2F;&#x2F; ...\n    return user;\n&#125;</code></pre>\n\n<p>在上述代码中，我们在 <code>@ApiParam</code> 注解中添加了 <code>dataType = &quot;UserRequest&quot;</code> 属性，用于指定请求参数的类型为 <code>UserRequest</code> 类型，从而避免了重复。同时，我们还使用了 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解来描述了 <code>UserRequest</code> 类的各个属性和类型，从而让 Swagger 能够正确地显示请求参数的说明。</p>\n<h1 id=\"有些项目为什么先写接口，后写-service\"><a href=\"#有些项目为什么先写接口，后写-service\" class=\"headerlink\" title=\"有些项目为什么先写接口，后写 service?\"></a>有些项目为什么先写接口，后写 service?</h1><p>在一些项目中，开发者可能会先写接口，再写 Service 的原因有以下几个：</p>\n<ol>\n<li><p>接口设计更加重要：在一些复杂的项目中，接口设计对于整个项目的架构和扩展性非常重要。因此在开发过程中，开发者可能会先进行接口的设计和规划，再逐步实现具体的业务逻辑。</p>\n</li>\n<li><p>接口驱动开发：接口驱动开发是一种以接口为中心的开发方式，通过先定义接口，再根据接口逐步实现具体的业务逻辑。这种开发方式能够更好地支持团队协作和模块化开发，同时也能够更好地保证代码的可测试性和可维护性。</p>\n</li>\n<li><p>提高代码复用性：通过先定义接口，可以更好地实现代码的复用。不同的 Service 组件可以共用相同的接口，从而提高开发效率和代码复用性。</p>\n</li>\n</ol>\n<p>总的来说，先写接口后写 Service 是一种比较常见的开发方式，能够更好地支持项目开发和维护。当然，这并不是唯一的开发方式，具体的开发方式需要根据项目需求和团队技术水平来进行选择。</p>\n<h1 id=\"service-controller\"><a href=\"#service-controller\" class=\"headerlink\" title=\"service controller\"></a>service controller</h1><p>以下是一个基于 Spring Boot 的简单示例，演示了如何在 Service 和 Controller 之间进行数据传递和处理。</p>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class UserService &#123;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public List&lt;User&gt; getAllUsers() &#123;\n        return userRepository.findAll();\n    &#125;\n\n    public User getUserById(Long id) &#123;\n        return userRepository.findById(id).orElse(null);\n    &#125;\n\n    public User createUser(User user) &#123;\n        return userRepository.save(user);\n    &#125;\n\n    public User updateUser(User user) &#123;\n        return userRepository.save(user);\n    &#125;\n\n    public void deleteUserById(Long id) &#123;\n        userRepository.deleteById(id);\n    &#125;\n&#125;</code></pre>\n\n<p>上面的 UserService 组件提供了一些基本的用户管理功能，如获取所有用户、根据 ID 获取用户、创建用户、更新用户和删除用户。它依赖于 UserRepository 组件，用于访问数据库中的用户数据。</p>\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;users&quot;)\npublic class UserController &#123;\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping\n    public List&lt;User&gt; getAllUsers() &#123;\n        return userService.getAllUsers();\n    &#125;\n\n    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n    public User getUserById(@PathVariable Long id) &#123;\n        return userService.getUserById(id);\n    &#125;\n\n    @PostMapping\n    public User createUser(@RequestBody User user) &#123;\n        return userService.createUser(user);\n    &#125;\n\n    @PutMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n    public User updateUser(@PathVariable Long id, @RequestBody User user) &#123;\n        user.setId(id);\n        return userService.updateUser(user);\n    &#125;\n\n    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n    public void deleteUserById(@PathVariable Long id) &#123;\n        userService.deleteUserById(id);\n    &#125;\n&#125;</code></pre>\n\n<p>上面的 UserController 组件提供了一些基本的 RESTful API，用于处理用户管理相关的 Web 请求。它依赖于 UserService 组件，用于处理业务逻辑并返回结果给客户端。</p>\n<p>总的来说，上面的例子演示了如何使用 Service 和 Controller 构建一个基本的 Web 应用程序，实现了用户管理的功能。</p>\n<h2 id=\"PathVariable-与-PathParam-的区别-1\"><a href=\"#PathVariable-与-PathParam-的区别-1\" class=\"headerlink\" title=\"@PathVariable 与@PathParam 的区别\"></a>@PathVariable 与@PathParam 的区别</h2><p><code>@PathVariable</code>和<code>@PathParam</code>都是用于获取路径变量的注解，但是它们是针对不同的框架而设计的。</p>\n<p><code>@PathVariable</code>是 Spring 框架中的注解，用于获取 RESTful 请求路径中的参数值。如前面所述，<code>@PathVariable</code>可以将 URL 中的参数绑定到一个方法的参数中。</p>\n<p>而<code>@PathParam</code>是 JAX-RS 规范中的注解，用于获取 RESTful 请求路径中的参数值。如<code>@PathVariable</code>一样，<code>@PathParam</code>也可以将 URL 中的参数绑定到一个方法的参数中。</p>\n<p>虽然<code>@PathVariable</code>和<code>@PathParam</code>实现的功能类似，但是它们之间还是存在一些区别的：</p>\n<ol>\n<li>引入的包不同：</li>\n</ol>\n<p><code>@PathVariable</code>是 Spring 框架中的注解，需要引入<code>org.springframework.web.bind.annotation.PathVariable</code>这个包。</p>\n<p><code>@PathParam</code>是 JAX-RS 规范中的注解，需要引入<code>javax.ws.rs.PathParam</code>这个包。</p>\n<ol start=\"2\">\n<li>参数名字不同：</li>\n</ol>\n<p>在使用<code>@PathVariable</code>注解时，我们需要在括号里指定参数名字，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@GetMapping(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@PathVariable(&quot;id&quot;) Long id) &#123;\n    &#x2F;&#x2F; code\n&#125;</code></pre>\n\n<p>在使用<code>@PathParam</code>注解时，我们可以直接使用参数名字，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@GET\n@Path(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\npublic User getUserById(@PathParam(&quot;id&quot;) Long id) &#123;\n    &#x2F;&#x2F; code\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>使用的框架不同：</li>\n</ol>\n<p><code>@PathVariable</code>是 Spring 框架中的注解，适用于 Spring MVC 框架。</p>\n<p><code>@PathParam</code>是 JAX-RS 规范中的注解，适用于 JAX-RS 框架。</p>\n<p>综上所述，虽然<code>@PathVariable</code>和<code>@PathParam</code>都可以用于获取 RESTful 请求路径中的参数值，但是它们是针对不同的框架而设计的，使用时需要根据具体情况进行选择。</p>\n<h1 id=\"java-声明一个变量有哪些修饰符\"><a href=\"#java-声明一个变量有哪些修饰符\" class=\"headerlink\" title=\"java 声明一个变量有哪些修饰符\"></a>java 声明一个变量有哪些修饰符</h1><p>在 Java 中，我们可以使用以下访问修饰符来声明变量：</p>\n<ol>\n<li><code>public</code>：可以被任何类访问，适用于共有变量。</li>\n<li><code>private</code>：只能被本类访问，适用于私有变量。</li>\n<li><code>protected</code>：可以被同一包内的类以及所有子类访问，适用于受保护的变量。</li>\n<li><code>static</code>：静态变量，属于类，而不是属于实例。</li>\n<li><code>final</code>：表示变量一旦赋值后，就不能再被修改，适用于常量。</li>\n<li><code>transient</code>：表示变量不会被序列化，适用于需要忽略的变量。</li>\n<li><code>volatile</code>：表示变量是易变的，适用于需要多线程访问的变量。</li>\n<li><code>synchronized</code>：表示变量在多线程中同步访问，适用于需要同步的变量。</li>\n</ol>\n<p>在声明变量时，可以使用其中的一个或多个修饰符，以此来限制变量的访问和修改。例如，以下代码声明了一个私有的、静态的、常量字符串变量：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final String GREETING &#x3D; &quot;Hello, World!&quot;;</code></pre>\n\n<h2 id=\"不用修饰符行不行\"><a href=\"#不用修饰符行不行\" class=\"headerlink\" title=\"不用修饰符行不行\"></a>不用修饰符行不行</h2><p>在 Java 中，可以不使用任何访问修饰符来声明一个变量。这样声明的变量将具有默认的访问级别，也称为包级私有访问级别。这意味着变量可以被同一包中的其他类访问，但不能被其他包中的类访问。</p>\n<p>例如，以下代码声明了一个默认访问级别的整数变量：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int num &#x3D; 10;</code></pre>\n\n<p>在这个例子中，如果该代码片段在同一包中的其他类中被引用，那么变量<code>num</code>可以被访问。但是，如果这个代码片段被引用到另一个包中的类中，那么变量<code>num</code>将不能被访问。</p>\n<p>虽然可以不使用任何修饰符来声明变量，但是在实际开发中，最好为变量选择适当的访问修饰符来限制访问级别，提高代码的可读性和安全性。</p>\n<h2 id=\"写个-CRUD-的示例\"><a href=\"#写个-CRUD-的示例\" class=\"headerlink\" title=\"写个 CRUD 的示例\"></a>写个 CRUD 的示例</h2><p>以下是一个简单的 Java 示例，演示了如何在 DAO 层中实现 CRUD 操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserDao &#123;\n  &#x2F;&#x2F; 创建新用户\n  public void createUser(User user) throws SQLException;\n\n  &#x2F;&#x2F; 根据用户ID读取用户\n  public User getUserById(int userId) throws SQLException;\n\n  &#x2F;&#x2F; 更新用户信息\n  public void updateUser(User user) throws SQLException;\n\n  &#x2F;&#x2F; 删除用户\n  public void deleteUser(int userId) throws SQLException;\n&#125;\n\npublic class UserDaoImpl implements UserDao &#123;\n  &#x2F;&#x2F; 数据库连接\n  private Connection conn;\n\n  &#x2F;&#x2F; 构造函数\n  public UserDaoImpl(Connection conn) &#123;\n    this.conn &#x3D; conn;\n  &#125;\n\n  @Override\n  public void createUser(User user) throws SQLException &#123;\n    PreparedStatement ps &#x3D; conn.prepareStatement(&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;);\n    ps.setString(1, user.getName());\n    ps.setString(2, user.getEmail());\n    ps.executeUpdate();\n    ps.close();\n  &#125;\n\n  @Override\n  public User getUserById(int userId) throws SQLException &#123;\n    PreparedStatement ps &#x3D; conn.prepareStatement(&quot;SELECT * FROM users WHERE id &#x3D; ?&quot;);\n    ps.setInt(1, userId);\n    ResultSet rs &#x3D; ps.executeQuery();\n    User user &#x3D; null;\n    if (rs.next()) &#123;\n      user &#x3D; new User();\n      user.setId(rs.getInt(&quot;id&quot;));\n      user.setName(rs.getString(&quot;name&quot;));\n      user.setEmail(rs.getString(&quot;email&quot;));\n    &#125;\n    rs.close();\n    ps.close();\n    return user;\n  &#125;\n\n  @Override\n  public void updateUser(User user) throws SQLException &#123;\n    PreparedStatement ps &#x3D; conn.prepareStatement(&quot;UPDATE users SET name &#x3D; ?, email &#x3D; ? WHERE id &#x3D; ?&quot;);\n    ps.setString(1, user.getName());\n    ps.setString(2, user.getEmail());\n    ps.setInt(3, user.getId());\n    ps.executeUpdate();\n    ps.close();\n  &#125;\n\n  @Override\n  public void deleteUser(int userId) throws SQLException &#123;\n    PreparedStatement ps &#x3D; conn.prepareStatement(&quot;DELETE FROM users WHERE id &#x3D; ?&quot;);\n    ps.setInt(1, userId);\n    ps.executeUpdate();\n    ps.close();\n  &#125;\n&#125;</code></pre>\n\n<p>在此示例中，<code>UserDao</code>接口定义了四个方法，分别用于创建、读取、更新和删除用户。<code>UserDaoImpl</code>类实现了该接口，并提供了相应的实现，其中使用 Java 的 JDBC API 与数据库进行交互。这个简单的示例演示了如何在 DAO 层中实现 CRUD 操作，以便为应用程序提供持久化存储。当然，实际情况可能更为复杂，具体实现方式也会因应用程序的需求而有所不同。</p>\n<h2 id=\"这个-CURD-的示例，对应的-service-层是\"><a href=\"#这个-CURD-的示例，对应的-service-层是\" class=\"headerlink\" title=\"这个 CURD 的示例，对应的 service 层是\"></a>这个 CURD 的示例，对应的 service 层是</h2><p>在一个 MVC 应用程序中，通常存在 DAO 层、Service 层和 Controller 层，其中 Service 层是连接 DAO 层和 Controller 层的中间层，用于处理业务逻辑。下面是一个 Java 示例，演示了如何在 Service 层中使用 DAO 层实现 CRUD 操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserService &#123;\n  &#x2F;&#x2F; 创建新用户\n  public void createUser(User user) throws SQLException;\n\n  &#x2F;&#x2F; 根据用户ID读取用户\n  public User getUserById(int userId) throws SQLException;\n\n  &#x2F;&#x2F; 更新用户信息\n  public void updateUser(User user) throws SQLException;\n\n  &#x2F;&#x2F; 删除用户\n  public void deleteUser(int userId) throws SQLException;\n&#125;\n\npublic class UserServiceImpl implements UserService &#123;\n  &#x2F;&#x2F; 数据访问对象\n  private UserDao userDao;\n\n  &#x2F;&#x2F; 构造函数\n  public UserServiceImpl(UserDao userDao) &#123;\n    this.userDao &#x3D; userDao;\n  &#125;\n\n  @Override\n  public void createUser(User user) throws SQLException &#123;\n    userDao.createUser(user);\n  &#125;\n\n  @Override\n  public User getUserById(int userId) throws SQLException &#123;\n    return userDao.getUserById(userId);\n  &#125;\n\n  @Override\n  public void updateUser(User user) throws SQLException &#123;\n    userDao.updateUser(user);\n  &#125;\n\n  @Override\n  public void deleteUser(int userId) throws SQLException &#123;\n    userDao.deleteUser(userId);\n  &#125;\n&#125;</code></pre>\n\n<p>在此示例中，<code>UserServiceImpl</code>类实现了<code>UserService</code>接口，其中提供了与 DAO 层中的方法相应的方法。在 Service 层中，我们可以对 DAO 层中的方法进行包装，以便通过 Service 层来处理业务逻辑。在此示例中，Service 层中只是将 DAO 层的方法透传，但在实际情况中，可能需要在 Service 层中添加更多的业务逻辑处理。</p>\n<h2 id=\"对应的-controller-是\"><a href=\"#对应的-controller-是\" class=\"headerlink\" title=\"对应的 controller 是\"></a>对应的 controller 是</h2><p>在 MVC 应用程序中，Controller 层负责处理浏览器请求并将它们路由到适当的处理程序。以下是 Java Spring 框架中的示例，演示如何使用 UserService 来处理 HTTP 请求：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;users&quot;)\npublic class UserController &#123;\n  &#x2F;&#x2F; 用户服务对象\n  private UserService userService;\n\n  &#x2F;&#x2F; 构造函数\n  public UserController(UserService userService) &#123;\n    this.userService &#x3D; userService;\n  &#125;\n\n  @PostMapping(&quot;&quot;)\n  public ResponseEntity&lt;?&gt; createUser(@RequestBody User user) throws SQLException &#123;\n    &#x2F;&#x2F; 创建新用户\n    userService.createUser(user);\n\n    return ResponseEntity.ok(user);\n  &#125;\n\n  @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n  public ResponseEntity&lt;?&gt; getUserById(@PathVariable(&quot;id&quot;) int userId) throws SQLException &#123;\n    &#x2F;&#x2F; 根据用户ID获取用户信息\n    User user &#x3D; userService.getUserById(userId);\n\n    return ResponseEntity.ok(user);\n  &#125;\n\n  @PutMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n  public ResponseEntity&lt;?&gt; updateUser(@PathVariable(&quot;id&quot;) int userId, @RequestBody User user) throws SQLException &#123;\n    &#x2F;&#x2F; 更新用户信息\n    user.setId(userId);\n    userService.updateUser(user);\n\n    return ResponseEntity.ok(user);\n  &#125;\n\n  @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n  public ResponseEntity&lt;?&gt; deleteUser(@PathVariable(&quot;id&quot;) int userId) throws SQLException &#123;\n    &#x2F;&#x2F; 删除用户\n    userService.deleteUser(userId);\n\n    return ResponseEntity.ok().build();\n  &#125;\n&#125;</code></pre>\n\n<p>在此示例中，<code>UserController</code>类是一个 RESTful 控制器，它使用<code>@RestController</code>和<code>@RequestMapping</code>注释来处理 HTTP 请求。对于每个请求，Controller 层调用 UserService 来处理业务逻辑，然后将响应返回给客户端。在此示例中，<code>createUser</code>方法使用了<code>@PostMapping</code>注释，<code>getUserById</code>方法使用了<code>@GetMapping</code>注释，<code>updateUser</code>方法使用了<code>@PutMapping</code>注释，<code>deleteUser</code>方法使用了<code>@DeleteMapping</code>注释。</p>\n<h1 id=\"这个-DAO-用-mybatis-改写下\"><a href=\"#这个-DAO-用-mybatis-改写下\" class=\"headerlink\" title=\"这个 DAO 用 mybatis 改写下\"></a>这个 DAO 用 mybatis 改写下</h1><p>假设以下是一个使用 JDBC 实现的 UserDAO 接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserDAO &#123;\n    public List&lt;User&gt; getAllUsers() throws SQLException;\n    public User getUserById(int id) throws SQLException;\n    public void addUser(User user) throws SQLException;\n    public void updateUser(User user) throws SQLException;\n    public void deleteUser(int id) throws SQLException;\n&#125;</code></pre>\n\n<p>下面是使用 MyBatis 重写 UserDAO 接口的示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    @Select(&quot;SELECT * FROM users&quot;)\n    public List&lt;User&gt; getAllUsers();\n\n    @Select(&quot;SELECT * FROM users WHERE id &#x3D; #&#123;id&#125;&quot;)\n    public User getUserById(int id);\n\n    @Insert(&quot;INSERT INTO users (name, email, phone) VALUES (#&#123;name&#125;, #&#123;email&#125;, #&#123;phone&#125;)&quot;)\n    public void addUser(User user);\n\n    @Update(&quot;UPDATE users SET name&#x3D;#&#123;name&#125;, email&#x3D;#&#123;email&#125;, phone&#x3D;#&#123;phone&#125; WHERE id&#x3D;#&#123;id&#125;&quot;)\n    public void updateUser(User user);\n\n    @Delete(&quot;DELETE FROM users WHERE id&#x3D;#&#123;id&#125;&quot;)\n    public void deleteUser(int id);\n&#125;</code></pre>\n\n<p>在这个例子中，我们使用 MyBatis 的注解来简化数据库操作。<code>@Select</code>注解用于查询操作，<code>@Insert</code>注解用于插入操作，<code>@Update</code>注解用于更新操作，<code>@Delete</code>注解用于删除操作。注解中的 SQL 语句使用#{parameterName}占位符来表示参数。这些占位符将在运行时被实际的参数值替换。</p>\n<p>现在，我们需要在 Spring 应用程序中配置 MyBatis，以便使用 UserMapper：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- MyBatis配置文件 --&gt;\n&lt;configuration&gt;\n    &lt;mappers&gt;\n        &lt;!-- 指定UserMapper接口 --&gt;\n        &lt;mapper class&#x3D;&quot;com.example.mappers.UserMapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n&lt;!-- Spring配置文件 --&gt;\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath*:com&#x2F;example&#x2F;mappers&#x2F;*.xml&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;userMapper&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;\n    &lt;property name&#x3D;&quot;mapperInterface&quot; value&#x3D;&quot;com.example.mappers.UserMapper&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<p>在这个示例中，我们使用 Spring 的 JDBC 数据源来配置 MyBatis。<code>SqlSessionFactoryBean</code>用于创建<code>SqlSessionFactory</code>对象，它需要数据源和 MyBatis 配置文件的位置。然后，我们使用<code>MapperFactoryBean</code>将<code>UserMapper</code>接口注入到 Spring 应用程序中。现在，我们可以使用<code>UserMapper</code>接口来查询、插入、更新和删除用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Repository\npublic class UserDAOImpl implements UserDAO &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public List&lt;User&gt; getAllUsers() throws SQLException &#123;\n        return userMapper.getAllUsers();\n    &#125;\n\n    @Override\n    public User getUserById(int id) throws SQLException &#123;\n        return userMapper.getUserById(id);\n    &#125;\n\n    @Override\n    public void addUser(User user) throws SQLException &#123;\n        userMapper.addUser(user);\n    &#125;\n\n    @Override\n    public void updateUser(User user) throws SQLException &#123;\n        userMapper.updateUser(user);\n    &#125;\n\n    @Override\n    public void deleteUser(int id) throws SQLException &#123;\n        userMapper.deleteUser(id);\n    &#125;\n&#125;</code></pre>\n\n<p>在 DAO 实现类中，我们注入了 UserMapper 接口，并实现了 UserDAO 接口中的方法。现在，我们可以将 UserDAO 用作数据访问对象，以在我们的应用程序中访问数据库。</p>\n<h2 id=\"sql-不是在-xml-文件中书写的吗\"><a href=\"#sql-不是在-xml-文件中书写的吗\" class=\"headerlink\" title=\"sql 不是在 xml 文件中书写的吗\"></a>sql 不是在 xml 文件中书写的吗</h2><p>是的，您是正确的。在 MyBatis 中，通常将 SQL 语句和 Mapper 接口分离，在 XML 文件中编写 SQL 语句。</p>\n<p>以下是使用 MyBatis 和 XML 文件重写 UserDAO 接口的示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- UserMapper.xml --&gt;\n&lt;mapper namespace&#x3D;&quot;com.example.mappers.UserMapper&quot;&gt;\n    &lt;select id&#x3D;&quot;getAllUsers&quot; resultType&#x3D;&quot;com.example.models.User&quot;&gt;\n        SELECT * FROM users\n    &lt;&#x2F;select&gt;\n\n    &lt;select id&#x3D;&quot;getUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.example.models.User&quot;&gt;\n        SELECT * FROM users WHERE id &#x3D; #&#123;id&#125;\n    &lt;&#x2F;select&gt;\n\n    &lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.example.models.User&quot;&gt;\n        INSERT INTO users (name, email, phone) VALUES (#&#123;name&#125;, #&#123;email&#125;, #&#123;phone&#125;)\n    &lt;&#x2F;insert&gt;\n\n    &lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.example.models.User&quot;&gt;\n        UPDATE users SET name&#x3D;#&#123;name&#125;, email&#x3D;#&#123;email&#125;, phone&#x3D;#&#123;phone&#125; WHERE id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;update&gt;\n\n    &lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;\n        DELETE FROM users WHERE id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;delete&gt;\n&lt;&#x2F;mapper&gt;</code></pre>\n\n<p>在 XML 文件中，我们使用<code>mapper</code>元素来创建 Mapper 接口，<code>select</code>元素用于查询操作，<code>insert</code>元素用于插入操作，<code>update</code>元素用于更新操作，<code>delete</code>元素用于删除操作。这些元素中的 SQL 语句使用#{}占位符来表示参数。这些占位符将在运行时被实际的参数值替换。</p>\n<p>现在，我们需要在 Spring 应用程序中配置 MyBatis，以便使用 UserMapper：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- MyBatis配置文件 --&gt;\n&lt;configuration&gt;\n    &lt;mappers&gt;\n        &lt;!-- 指定UserMapper接口 --&gt;\n        &lt;mapper resource&#x3D;&quot;com&#x2F;example&#x2F;mappers&#x2F;UserMapper.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n&lt;!-- Spring配置文件 --&gt;\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath*:com&#x2F;example&#x2F;mappers&#x2F;*.xml&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;userMapper&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;\n    &lt;property name&#x3D;&quot;mapperInterface&quot; value&#x3D;&quot;com.example.mappers.UserMapper&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<p>在这个示例中，我们使用 Spring 的 JDBC 数据源来配置 MyBatis。<code>SqlSessionFactoryBean</code>用于创建<code>SqlSessionFactory</code>对象，它需要数据源和 MyBatis 配置文件的位置。然后，我们使用<code>MapperFactoryBean</code>将<code>UserMapper</code>接口注入到 Spring 应用程序中。现在，我们可以使用<code>UserMapper</code>接口来查询、插入、更新和删除用户：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Repository\npublic class UserDAOImpl implements UserDAO &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public List&lt;User&gt; getAllUsers() throws SQLException &#123;\n        return userMapper.getAllUsers();\n    &#125;\n\n    @Override\n    public User getUserById(int id) throws SQLException &#123;\n        return userMapper.getUserById(id);\n    &#125;\n\n    @Override\n    public void addUser(User user) throws SQLException &#123;\n        userMapper.addUser(user);\n    &#125;\n\n    @Override\n    public void updateUser(User user) throws SQLException &#123;\n        userMapper.updateUser(user);\n    &#125;\n\n    @Override\n    public void deleteUser(int id) throws SQLException &#123;\n        userMapper.deleteUser(id);\n    &#125;\n&#125;</code></pre>\n\n<p>在 DAO 实现类中，我们注入了 UserMapper 接口，并实现了 UserDAO 接口中的方法。现在，我们可以将 UserDAO 用作数据访问对象，以在我们的应用程序中访问数据库。</p>\n<p>请注意，在 XML 中编写 SQL 语句的主要好处是可以更轻松地进行 SQL 语句的调整和管理。可以在 XML 中定义通用的 SQL 语句段，并在需要时重复使用。这些具有更高复用性的 SQL 模块可以在整个应用程序中共享，从而减少了代码中的重复性，并提高了代码的可维护性和可读性。同时，使用 XML 文件也使得 SQL 语句和 Java 代码分离，使得代码更加清晰和易于阅读。</p>\n<h2 id=\"UserMapper-xml-内容解释下\"><a href=\"#UserMapper-xml-内容解释下\" class=\"headerlink\" title=\"UserMapper.xml 内容解释下\"></a>UserMapper.xml 内容解释下</h2><p>好的，以下是对 UserMapper.xml 中的内容的解释：</p>\n<p>首先，我们使用<code>mapper</code>元素来创建 Mapper 接口：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;mapper namespace&#x3D;&quot;com.example.mappers.UserMapper&quot;&gt;</code></pre>\n\n<p><code>namespace</code>属性指定 Mapper 接口的完全限定名，Mapper 是一个接口，它定义了一组可以用于操作数据库的方法。</p>\n<p>接下来，我们定义了一些 SQL 语句，包括：</p>\n<ol>\n<li>查询所有用户：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getAllUsers&quot; resultType&#x3D;&quot;com.example.models.User&quot;&gt;\n    SELECT * FROM users\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个<code>select</code>元素中，我们指定了 SQL 查询语句<code>SELECT * FROM users</code>，并将其赋值给一个<code>id</code>为<code>getAllUsers</code>的节点，这个节点的查询结果类型为<code>com.example.models.User</code>。</p>\n<ol start=\"2\">\n<li>通过 ID 查询用户：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.example.models.User&quot;&gt;\n    SELECT * FROM users WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>这个<code>select</code>元素类似于第一个，但是它还有一个<code>parameterType</code>属性，它指定了查询所需要的参数类型为<code>int</code>。在 SQL 语句中，我们使用了<code>#&#123;id&#125;</code>占位符来表示这个参数。</p>\n<ol start=\"3\">\n<li>插入用户：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.example.models.User&quot;&gt;\n    INSERT INTO users (name, email, phone) VALUES (#&#123;name&#125;, #&#123;email&#125;, #&#123;phone&#125;)\n&lt;&#x2F;insert&gt;</code></pre>\n\n<p>这个<code>insert</code>元素表示将用户对象插入到数据库中。在元素中，我们指定了 SQL 插入语句<code>INSERT INTO users (name, email, phone) VALUES (#&#123;name&#125;, #&#123;email&#125;, #&#123;phone&#125;)</code>，并将其赋值给一个<code>id</code>为<code>addUser</code>的节点。节点的参数类型为<code>com.example.models.User</code>，我们使用了<code>#&#123;name&#125;</code>、<code>#&#123;email&#125;</code>、<code>#&#123;phone&#125;</code>占位符来表示这个对象中的属性。</p>\n<ol start=\"4\">\n<li>更新用户：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.example.models.User&quot;&gt;\n    UPDATE users SET name&#x3D;#&#123;name&#125;, email&#x3D;#&#123;email&#125;, phone&#x3D;#&#123;phone&#125; WHERE id&#x3D;#&#123;id&#125;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>这个<code>update</code>元素表示将用户对象在数据库中进行更新。在元素中，我们指定了 SQL 更新语句<code>UPDATE users SET name=#&#123;name&#125;, email=#&#123;email&#125;, phone=#&#123;phone&#125; WHERE id=#&#123;id&#125;</code>，并将其赋值给一个<code>id</code>为<code>updateUser</code>的节点。节点的参数类型为<code>com.example.models.User</code>，用户对象中的属性通过<code>#&#123;name&#125;</code>、<code>#&#123;email&#125;</code>、<code>#&#123;phone&#125;</code>占位符来表示，<code>#&#123;id&#125;</code>占位符表示更新操作的参数。</p>\n<ol start=\"5\">\n<li>删除用户：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;\n    DELETE FROM users WHERE id&#x3D;#&#123;id&#125;\n&lt;&#x2F;delete&gt;</code></pre>\n\n<p>这个<code>delete</code>元素表示将用户从数据库中删除。在元素中，我们指定了 SQL 删除语句<code>DELETE FROM users WHERE id=#&#123;id&#125;</code>，并将其赋值给一个<code>id</code>为<code>deleteUser</code>的节点。节点的参数类型为<code>int</code>，表示要删除的用户 ID。</p>\n<p>以上就是 UserMapper.xml 中的内容的解释。</p>\n<h2 id=\"我可以这么理解：UserMapper-xml-是对-com-example-mappers-UserMapper-的接口实现，之前是在-java-文件中写的实现，现在为了维护性和灵活性，将其放到-xml-中进行实现\"><a href=\"#我可以这么理解：UserMapper-xml-是对-com-example-mappers-UserMapper-的接口实现，之前是在-java-文件中写的实现，现在为了维护性和灵活性，将其放到-xml-中进行实现\" class=\"headerlink\" title=\"我可以这么理解：UserMapper.xml 是对 com.example.mappers.UserMapper 的接口实现，之前是在 java 文件中写的实现，现在为了维护性和灵活性，将其放到 xml 中进行实现\"></a>我可以这么理解：UserMapper.xml 是对 com.example.mappers.UserMapper 的接口实现，之前是在 java 文件中写的实现，现在为了维护性和灵活性，将其放到 xml 中进行实现</h2><p>是的，您的理解是正确的。</p>\n<p>在 MyBatis 中，Mapper 接口是用于定义操作数据库的方法，而 Mapper XML 文件则是用于实现这些方法的具体 SQL 语句。在 Mapper XML 文件中，可以使用各种元素来编写 SQL 语句，并且这些元素可以与 Java 代码分离，从而提高了代码的可维护性和可读性。</p>\n<p>通过将接口与 XML 文件结合起来，MyBatis 可以动态生成 Mapper 接口的实现类，使开发人员能够轻松地使用 Mapper 接口来操作数据库，同时也可以随时更改 SQL 语句而无需更改 Java 代码。</p>\n<h2 id=\"xml-中-id-对应方法名？\"><a href=\"#xml-中-id-对应方法名？\" class=\"headerlink\" title=\"xml 中 id 对应方法名？\"></a>xml 中 id 对应方法名？</h2><p>是的，MyBatis 的 Mapper XML 文件中的 <code>&lt;select&gt;</code>, <code>&lt;insert&gt;</code>, <code>&lt;update&gt;</code>, <code>&lt;delete&gt;</code> 等元素的 <code>id</code> 属性对应着 Mapper 接口中的方法名，MyBatis 将会根据 <code>id</code> 属性值来查找对应的方法调用。</p>\n<p>例如，下面是一个 Mapper 接口中的方法定义：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    User selectUserById(int id);\n&#125;</code></pre>\n\n<p>对应的 XML 文件应该是这样的：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;mapper namespace&#x3D;&quot;com.example.mappers.UserMapper&quot;&gt;\n    &lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;com.example.model.User&quot;&gt;\n        SELECT * FROM users WHERE id &#x3D; #&#123;id&#125;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;</code></pre>\n\n<p>在这个例子中，<code>&lt;select&gt;</code> 元素的 <code>id</code> 属性的值为 <code>selectUserById</code>，对应着 <code>UserMapper</code> 接口中的方法名。当执行这个方法时，MyBatis 会在 XML 文件中找到 <code>id</code> 属性值为 <code>selectUserById</code> 的 <code>&lt;select&gt;</code> 元素，进而执行该 SQL 查询语句，并将结果映射到 <code>User</code> 类型的对象中返回给调用方。</p>\n<h2 id=\"入参是如何和-xml-进行绑定的？\"><a href=\"#入参是如何和-xml-进行绑定的？\" class=\"headerlink\" title=\"入参是如何和 xml 进行绑定的？\"></a>入参是如何和 xml 进行绑定的？</h2><p>MyBatis 中的 SQL 语句可以使用 <code>#&#123;&#125;</code> 占位符来表示参数，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;com.example.model.User&quot;&gt;\n    SELECT * FROM users WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个例子中，<code>#&#123;id&#125;</code> 就是一个占位符，表示 SQL 查询语句中的参数。在 Mapper 接口的方法中，我们需要定义一个与该占位符对应的参数，方法的参数名可以随意命名，但是需要使用 <code>@Param</code> 注解来指定参数名称，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    User selectUserById(@Param(&quot;id&quot;) int id);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>@Param(&quot;id&quot;)</code> 注解就是用来指定方法参数名为 <code>id</code>，使得这个参数与 SQL 查询语句中的 <code>#&#123;id&#125;</code> 占位符对应起来。这样，当执行 <code>selectUserById</code> 方法时，MyBatis 就会自动将参数绑定到 SQL 查询语句中的占位符上，然后执行查询，并将结果映射到 <code>User</code> 类型的对象中返回给调用方。</p>\n<p>值得注意的是，MyBatis 在绑定参数时，会根据参数类型自动进行转换，例如将 Java 中的 <code>Integer</code> 类型自动转换为 SQL 中的 <code>int</code> 类型，或者将 Java 中的 <code>List</code> 类型自动转换为 SQL 中的 <code>IN</code> 子句等。如果需要手动指定参数类型，可以使用 <code>#&#123;id, jdbcType=INTEGER&#125;</code> 的形式来指定。</p>\n<h2 id=\"如果参数是一个对象呢？\"><a href=\"#如果参数是一个对象呢？\" class=\"headerlink\" title=\"如果参数是一个对象呢？\"></a>如果参数是一个对象呢？</h2><p>如果参数是一个对象，可以使用 <code>#&#123;&#125;</code> 占位符来表示对象中的属性，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.example.model.User&quot;&gt;\n    INSERT INTO users (id, name, age) VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;)\n&lt;&#x2F;insert&gt;</code></pre>\n\n<p>在这个例子中，<code>#&#123;id&#125;</code>、<code>#&#123;name&#125;</code> 和 <code>#&#123;age&#125;</code> 都是占位符，分别表示 <code>User</code> 对象中的 <code>id</code>、<code>name</code> 和 <code>age</code> 属性。在 Mapper 接口的方法中，我们只需要定义一个与该对象对应的参数即可，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    void insertUser(User user);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>User</code> 对象就是一个参数，MyBatis 会自动将这个对象的属性绑定到 SQL 语句中的占位符上，然后执行插入操作。需要注意的是，对象的属性名称要与 SQL 语句中的占位符名称一致，否则绑定会失败。</p>\n<p>如果对象中有复杂的属性结构，可以在 SQL 语句中使用 <code>.</code> 来表示属性的层次结构，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;insert id&#x3D;&quot;insertOrder&quot; parameterType&#x3D;&quot;com.example.model.Order&quot;&gt;\n    INSERT INTO orders (id, user_id, total_price) VALUES (#&#123;id&#125;, #&#123;user.id&#125;, #&#123;totalPrice&#125;)\n&lt;&#x2F;insert&gt;</code></pre>\n\n<p>在这个例子中，<code>#&#123;user.id&#125;</code> 表示 <code>Order</code> 对象中的 <code>user</code> 属性的 <code>id</code> 子属性。在 Mapper 接口的方法中，我们只需要定义一个与 <code>Order</code> 对象对应的参数即可，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface OrderMapper &#123;\n    void insertOrder(Order order);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>Order</code> 对象就是一个参数，MyBatis 会自动将这个对象的属性绑定到 SQL 语句中的占位符上，然后执行插入操作。需要注意的是，对象的属性名称和子属性名称要与 SQL 语句中的占位符名称一致，否则绑定会失败。</p>\n<h2 id=\"对象不需要用-Param-注解？\"><a href=\"#对象不需要用-Param-注解？\" class=\"headerlink\" title=\"对象不需要用@Param 注解？\"></a>对象不需要用@Param 注解？</h2><p>在 MyBatis 中，如果参数是一个简单类型（如 int、String 等）或者是一个 Map，可以使用 <code>@Param</code> 注解来指定参数的名称，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    void updateUser(@Param(&quot;id&quot;) int id, @Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) int age);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>@Param</code> 注解用来指定方法参数的名称，这样可以让 MyBatis 识别参数并绑定到 SQL 语句中的占位符上。</p>\n<p>但是，如果参数是一个对象，你不需要使用 <code>@Param</code> 注解来指定参数名称。因为 MyBatis 会自动将对象的属性名作为参数名称，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    void insertUser(User user);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>User</code> 对象就是一个参数，MyBatis 会自动将对象的属性名作为参数名称，并绑定到 SQL 语句中的占位符上。</p>\n<p>需要注意的是，如果对象中的属性名与 SQL 语句中的占位符名不一致，可以使用 <code>#&#123;propertyName&#125;</code> 的方式来指定属性名，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.example.model.User&quot;&gt;\n    INSERT INTO users (user_id, user_name, user_age) VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;)\n&lt;&#x2F;insert&gt;</code></pre>\n\n<p>在这个例子中，<code>#&#123;id&#125;</code>、<code>#&#123;name&#125;</code> 和 <code>#&#123;age&#125;</code> 分别对应 <code>User</code> 对象中的 <code>id</code>、<code>name</code> 和 <code>age</code> 属性。</p>\n<h2 id=\"mybatis-Param\"><a href=\"#mybatis-Param\" class=\"headerlink\" title=\"mybatis @Param\"></a>mybatis @Param</h2><p>在 MyBatis 中，<code>@Param</code> 注解用于指定 SQL 语句中的参数名。当方法的参数不是一个简单类型（如 int、String 等）或者是一个 Map 时，可以使用 <code>@Param</code> 注解来指定参数的名称。</p>\n<p>下面是一个使用 <code>@Param</code> 注解的示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    List&lt;User&gt; selectUsers(@Param(&quot;name&quot;) String name, @Param(&quot;minAge&quot;) int minAge);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>@Param</code> 注解用来指定方法参数的名称，这样可以让 MyBatis 识别参数并绑定到 SQL 语句中的占位符上。在 SQL 语句中可以这样使用：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;selectUsers&quot; resultType&#x3D;&quot;User&quot;&gt;\n    SELECT * FROM users WHERE name &#x3D; #&#123;name&#125; AND age &gt;&#x3D; #&#123;minAge&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在 SQL 语句中，<code>#&#123;name&#125;</code> 和 <code>#&#123;minAge&#125;</code> 分别对应于 <code>selectUsers</code> 方法中的 <code>name</code> 和 <code>minAge</code> 参数。</p>\n<p>需要注意的是，当方法的参数是一个对象时，不需要使用 <code>@Param</code> 注解来指定参数名称。MyBatis 会自动将对象的属性名作为参数名称，并绑定到 SQL 语句中的占位符上。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    void insertUser(User user);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>User</code> 对象就是一个参数，MyBatis 会自动将对象的属性名作为参数名称，并绑定到 SQL 语句中的占位符上。</p>\n<h2 id=\"Param-有命名的作用？\"><a href=\"#Param-有命名的作用？\" class=\"headerlink\" title=\"@Param 有命名的作用？\"></a>@Param 有命名的作用？</h2><p>是的，<code>@Param</code> 注解除了可以指定参数的名称，还可以起到命名的作用。</p>\n<p>在 MyBatis 中，当方法的参数是一个基本数据类型或者是一个 Map 时，如果没有指定 <code>@Param</code> 注解，那么 MyBatis 会把参数的名称默认设置为 arg0、arg1、arg2…，这样在 SQL 语句中就无法使用参数名称来绑定参数。</p>\n<p>因此，使用 <code>@Param</code> 注解来指定参数的名称，可以避免这种问题，并且使得 SQL 语句更易于阅读和维护。</p>\n<p>另外，当方法的参数是一个复杂对象时，MyBatis 会自动将对象的属性名作为参数名称，这种情况下不需要使用 <code>@Param</code> 注解指定参数名称，但是如果需要起到命名的作用，也可以使用 <code>@Param</code> 注解。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    void updateUser(@Param(&quot;id&quot;) int id, @Param(&quot;user&quot;) User user);\n&#125;</code></pre>\n\n<p>在这个例子中，<code>@Param(&quot;id&quot;)</code> 注解指定了参数名称为 id，<code>@Param(&quot;user&quot;)</code> 注解指定了参数名称为 user，这样在 SQL 语句中就可以使用参数名称来绑定参数，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;map&quot;&gt;\n    UPDATE users SET name &#x3D; #&#123;user.name&#125;, age &#x3D; #&#123;user.age&#125; WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>在 SQL 语句中，<code>#&#123;id&#125;</code> 和 <code>#&#123;user.name&#125;</code>、<code>#&#123;user.age&#125;</code> 分别对应于 <code>updateUser</code> 方法中的 <code>id</code> 和 <code>user</code> 参数。</p>\n<h2 id=\"mybatis-xml-有哪些语法\"><a href=\"#mybatis-xml-有哪些语法\" class=\"headerlink\" title=\"mybatis xml 有哪些语法\"></a>mybatis xml 有哪些语法</h2><p>MyBatis 的 XML 文件主要包括以下语法：</p>\n<h3 id=\"1-命名空间\"><a href=\"#1-命名空间\" class=\"headerlink\" title=\"1. 命名空间\"></a>1. 命名空间</h3><p>命名空间用于指定 Mapper 接口的完整类名，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;mapper namespace&#x3D;&quot;com.example.mapper.UserMapper&quot;&gt;\n    &lt;!-- SQL 语句 --&gt;\n&lt;&#x2F;mapper&gt;</code></pre>\n\n<h3 id=\"2-参数类型\"><a href=\"#2-参数类型\" class=\"headerlink\" title=\"2. 参数类型\"></a>2. 参数类型</h3><p>在 Mapper 接口中定义方法时，可以指定该方法的参数类型。在 XML 文件中，需要使用 <code>parameterType</code> 属性来指定参数类型，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<h3 id=\"3-返回类型\"><a href=\"#3-返回类型\" class=\"headerlink\" title=\"3. 返回类型\"></a>3. 返回类型</h3><p>在 Mapper 接口中定义方法时，可以指定该方法的返回类型。在 XML 文件中，需要使用 <code>resultType</code> 或 <code>resultMap</code> 属性来指定返回类型，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getAllUsers&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users\n&lt;&#x2F;select&gt;\n\n&lt;select id&#x3D;&quot;getUserById&quot; parameterType&#x3D;&quot;int&quot; resultMap&#x3D;&quot;userResultMap&quot;&gt;\n    SELECT * FROM users WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<h3 id=\"4-SQL-语句\"><a href=\"#4-SQL-语句\" class=\"headerlink\" title=\"4. SQL 语句\"></a>4. SQL 语句</h3><p>在 XML 文件中，可以编写各种类型的 SQL 语句，例如 SELECT、INSERT、UPDATE、DELETE 等。SQL 语句需要包含在相应标签中，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getAllUsers&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users\n&lt;&#x2F;select&gt;\n\n&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    INSERT INTO users(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)\n&lt;&#x2F;insert&gt;\n\n&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    UPDATE users SET name &#x3D; #&#123;name&#125;, age &#x3D; #&#123;age&#125; WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;update&gt;\n\n&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;\n    DELETE FROM users WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;delete&gt;</code></pre>\n\n<h3 id=\"5-SQL-片段\"><a href=\"#5-SQL-片段\" class=\"headerlink\" title=\"5. SQL 片段\"></a>5. SQL 片段</h3><p>SQL 片段用于封装重复使用的 SQL 代码，可以通过 <code>sql</code> 标签定义 SQL 片段，然后在其他 SQL 语句中使用 <code>include</code> 标签引用 SQL 片段，例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;sql id&#x3D;&quot;userColumns&quot;&gt;\n    id, name, age\n&lt;&#x2F;sql&gt;\n\n&lt;select id&#x3D;&quot;getAllUsers&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT &lt;include refid&#x3D;&quot;userColumns&quot;&#x2F;&gt; FROM users\n&lt;&#x2F;select&gt;\n\n&lt;select id&#x3D;&quot;getUserById&quot; parameterType&#x3D;&quot;int&quot; resultMap&#x3D;&quot;userResultMap&quot;&gt;\n    SELECT &lt;include refid&#x3D;&quot;userColumns&quot;&#x2F;&gt; FROM users WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<h3 id=\"6-动态-SQL\"><a href=\"#6-动态-SQL\" class=\"headerlink\" title=\"6. 动态 SQL\"></a>6. 动态 SQL</h3><p>动态 SQL 用于根据条件拼接 SQL 语句，在 MyBatis 中支持以下标签：</p>\n<ul>\n<li><code>&lt;if&gt;</code>：根据条件判断是否包含 SQL 片段；</li>\n<li><code>&lt;choose&gt;</code>：类似于 Java 中的 switch 语句，根据条件匹配不同的 SQL 片段；</li>\n<li><code>&lt;when&gt;</code>：配合 <code>&lt;choose&gt;</code> 标签使用，表示一个条件分支；</li>\n<li><code>&lt;otherwise&gt;</code>：配合 <code>&lt;choose&gt;</code> 标签使用，表示没有任何条件匹配时执行的 SQL 片段；</li>\n<li><code>&lt;trim&gt;</code>：用于从 SQL 语句的开头或结尾移除指定字符；</li>\n<li><code>&lt;where&gt;</code>：用于动态拼接 WHERE 子句；</li>\n<li><code>&lt;set&gt;</code>：用于动态拼接 SET 子句；</li>\n<li><code>&lt;foreach&gt;</code>：用于遍历集合或数组，生成多个 SQL 片段。</li>\n</ul>\n<p>例如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserByConditions&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users\n    &lt;where&gt;\n        &lt;if test&#x3D;&quot;name !&#x3D; null&quot;&gt;AND name &#x3D; #&#123;name&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;age !&#x3D; null&quot;&gt;AND age &#x3D; #&#123;age&#125;&lt;&#x2F;if&gt;\n    &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;\n\n&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    UPDATE users\n    &lt;set&gt;\n        &lt;if test&#x3D;&quot;name !&#x3D; null&quot;&gt;name &#x3D; #&#123;name&#125;,&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;age !&#x3D; null&quot;&gt;age &#x3D; #&#123;age&#125;,&lt;&#x2F;if&gt;\n    &lt;&#x2F;set&gt;\n    WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;update&gt;\n\n&lt;select id&#x3D;&quot;getUserByIds&quot; parameterType&#x3D;&quot;list&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users\n    WHERE id IN\n    &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;\n        #&#123;id&#125;\n    &lt;&#x2F;foreach&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个示例代码中，使用了 <code>&lt;foreach&gt;</code> 标签遍历了一个 List 类型的参数，并将其中的元素拼接成了一个 IN 子句。其中，<code>collection</code> 属性指定了要遍历的集合或数组，<code>item</code> 属性指定了循环变量的名称，<code>open</code> 属性指定了循环开始时要插入的字符串，<code>separator</code> 属性指定了每个循环变量之间的分隔符，<code>close</code> 属性指定了循环结束时要插入的字符串。</p>\n<h2 id=\"每个标签的示例代码\"><a href=\"#每个标签的示例代码\" class=\"headerlink\" title=\"每个标签的示例代码\"></a>每个标签的示例代码</h2><p>好的，以下是每个标签的示例代码：</p>\n<p><strong><if></strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserByName&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users\n    WHERE 1&#x3D;1\n    &lt;if test&#x3D;&quot;name !&#x3D; null and name.trim() !&#x3D; &#39;&#39;&quot;&gt;\n        AND name &#x3D; #&#123;name&#125;\n    &lt;&#x2F;if&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个示例代码中，使用了 <code>&lt;if&gt;</code> 标签判断了一个条件，如果符合条件，则拼接了一个 AND name &#x3D; #{name} 的 SQL 片段。</p>\n<p><strong><choose>、<when>、<otherwise></strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserByCondition&quot; parameterType&#x3D;&quot;com.example.dto.UserQuery&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users\n    &lt;choose&gt;\n        &lt;when test&#x3D;&quot;name !&#x3D; null and name.trim() !&#x3D; &#39;&#39;&quot;&gt;\n            WHERE name &#x3D; #&#123;name&#125;\n        &lt;&#x2F;when&gt;\n        &lt;when test&#x3D;&quot;age !&#x3D; null&quot;&gt;\n            WHERE age &#x3D; #&#123;age&#125;\n        &lt;&#x2F;when&gt;\n        &lt;otherwise&gt;\n            WHERE 1&#x3D;1\n        &lt;&#x2F;otherwise&gt;\n    &lt;&#x2F;choose&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个示例代码中，使用了 <code>&lt;choose&gt;</code> 标签匹配了不同的条件，如果有任何一个条件匹配成功，则执行相应的 SQL 片段。注意，必须要有 <code>&lt;otherwise&gt;</code> 标签，表示没有任何条件匹配成功时执行的 SQL 片段。</p>\n<p><strong><trim></strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    UPDATE users\n    &lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot; suffix&#x3D;&quot; WHERE id &#x3D; #&#123;id&#125;&quot;&gt;\n        &lt;if test&#x3D;&quot;name !&#x3D; null&quot;&gt;name &#x3D; #&#123;name&#125;,&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;age !&#x3D; null&quot;&gt;age &#x3D; #&#123;age&#125;,&lt;&#x2F;if&gt;\n    &lt;&#x2F;trim&gt;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>在这个示例代码中，使用了 <code>&lt;trim&gt;</code> 标签移除了 SQL 语句的结尾多余的逗号，并添加了 SET 和 WHERE 子句。</p>\n<p><strong><where>、<set></strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    UPDATE users\n    &lt;set&gt;\n        &lt;if test&#x3D;&quot;name !&#x3D; null&quot;&gt;name &#x3D; #&#123;name&#125;,&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;age !&#x3D; null&quot;&gt;age &#x3D; #&#123;age&#125;,&lt;&#x2F;if&gt;\n    &lt;&#x2F;set&gt;\n    WHERE 1&#x3D;1\n    &lt;if test&#x3D;&quot;id !&#x3D; null&quot;&gt;AND id &#x3D; #&#123;id&#125;&lt;&#x2F;if&gt;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>在这个示例代码中，使用了 <code>&lt;set&gt;</code> 标签拼接了一个 SET 子句，并使用了 <code>&lt;where&gt;</code> 标签拼接了一个 WHERE 子句。注意，必须要有 WHERE 1&#x3D;1，否则如果所有的条件都不满足，这个 SQL 语句将会是不合法的。</p>\n<p><strong><foreach></strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserByIds&quot; parameterType&#x3D;&quot;list&quot; resultType&#x3D;&quot;com.example.entity.User&quot;&gt;\n    SELECT * FROM users\n    WHERE id IN\n    &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;\n        #&#123;id&#125;\n    &lt;&#x2F;foreach&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个示例代码中，使用了 <code>&lt;foreach&gt;</code> 标签遍历了一个 List 类型的参数，并将其中的元素拼接成了一个 IN 子句。其中，<code>collection</code> 属性指定了要遍历的集合或数组，<code>item</code> 属性指定了循环变量的名称，<code>open</code> 属性指定了循环开始时要插入的字符串，<code>separator</code> 属性指定了每个循环变量之间的分隔符，<code>close</code> 属性指定了循环结束时要插入的字符串。</p>\n<h2 id=\"suffixOverrides-suffix\"><a href=\"#suffixOverrides-suffix\" class=\"headerlink\" title=\"suffixOverrides suffix\"></a>suffixOverrides suffix</h2><p><code>suffixOverrides</code> 和 <code>suffix</code> 是 <code>&lt;trim&gt;</code> 标签的两个属性，用于控制移除 SQL 语句开头或结尾的字符。</p>\n<ul>\n<li><code>suffixOverrides</code> 属性表示要移除的后缀字符串，如果 SQL 语句结尾包含这个字符串，则将它移除。例如，如果设置了 <code>suffixOverrides=&quot;,&quot;</code>，则如果 SQL 语句结尾是逗号，将会被移除。</li>\n<li><code>suffix</code> 属性表示要添加的后缀字符串，会在 SQL 语句结尾添加这个字符串。例如，如果设置了 <code>suffix=&quot; WHERE id = #&#123;id&#125;&quot;</code>，则会在 SQL 语句结尾添加 WHERE id &#x3D; #{id}。</li>\n</ul>\n<p>这两个属性常常和 <code>&lt;if&gt;</code> 标签配合使用，用于动态拼接 SQL 语句。例如，可以使用 <code>&lt;if&gt;</code> 标签判断一个条件，如果符合条件，则拼接一个字符串，否则不拼接。同时，使用 <code>&lt;trim&gt;</code> 标签移除拼接后的字符串结尾的逗号或其他字符，避免 SQL 语句不合法。最后，使用 <code>&lt;trim&gt;</code> 标签添加 WHERE 或 SET 子句，避免 SQL 语句语法错误。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"、\"><a href=\"#、\" class=\"headerlink\" title=\"#{}、${}\"></a>#{}、${}</h3><p>在 MyBatis 中，<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>都是用于传递参数值到 SQL 语句中的方式，但它们之间存在一些区别。</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"#{}\"></a><code>#&#123;&#125;</code></h4><p><code>#&#123;&#125;</code>是 MyBatis 中比较常用的一种传参方式，它会将传入的参数值自动进行预编译处理，防止 SQL 注入攻击，通常用于防止 SQL 注入。</p>\n<p><code>#&#123;&#125;</code>可以用在 SQL 语句的任意位置，如下面的示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;User&quot;&gt;\n  select * from user where id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在上面的示例中，<code>#&#123;id&#125;</code>将会被 MyBatis 处理成<code>?</code>，这样就防止了 SQL 注入攻击。同时，MyBatis 还可以自动将传入的参数值转换为对应的 JDBC 类型，如将 Java 的 Date 类型转换为 JDBC 的 Timestamp 类型。</p>\n<h4 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"${}\"></a><code>$&#123;&#125;</code></h4><p><code>$&#123;&#125;</code>是另一种传参方式，它不会进行预编译处理，而是直接将传入的参数值拼接到 SQL 语句中，通常用于动态拼接 SQL 语句。</p>\n<p><code>$&#123;&#125;</code>可以用在 SQL 语句的任意位置，如下面的示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserByName&quot; resultType&#x3D;&quot;User&quot;&gt;\n  select * from user where name like &#39;%$&#123;name&#125;%&#39;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在上面的示例中，<code>$&#123;name&#125;</code>将不会被 MyBatis 进行预编译处理，而是原样拼接到 SQL 语句中，这样就可能会存在 SQL 注入攻击的风险。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li><code>#&#123;&#125;</code>会将传入的参数值进行预编译处理，防止 SQL 注入攻击，通常用于防止 SQL 注入；</li>\n<li><code>$&#123;&#125;</code>不会进行预编译处理，而是直接将传入的参数值拼接到 SQL 语句中，通常用于动态拼接 SQL 语句；</li>\n<li>在不确定传入参数是否存在 SQL 注入攻击风险时，建议使用<code>#&#123;&#125;</code>，以防止 SQL 注入攻击。</li>\n</ul>\n<h3 id=\"JDBC-要求，如果一个列允许使用-null-值，并且会使用值为-null-的参数，就必须要指定-JDBC-类型（jdbcType）。\"><a href=\"#JDBC-要求，如果一个列允许使用-null-值，并且会使用值为-null-的参数，就必须要指定-JDBC-类型（jdbcType）。\" class=\"headerlink\" title=\"JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。\"></a>JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。</h3><p>阅读 PreparedStatement.setNull()的 JavaDoc 来获取更多信息。</p>\n<p><a href=\"https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#:~:text=JDBC%20%E8%A6%81%E6%B1%82%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%88%97%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8%20null%20%E5%80%BC%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%80%BC%E4%B8%BA%20null%20%E7%9A%84%E5%8F%82%E6%95%B0\" target=\"_blank\" >见</a></p>\n<h3 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h3><h2 id=\"结果映射\"><a href=\"#结果映射\" class=\"headerlink\" title=\"结果映射\"></a>结果映射</h2><h3 id=\"类型全名\"><a href=\"#类型全名\" class=\"headerlink\" title=\"类型全名\"></a>类型全名</h3><p>一个 JavaBean 可以被映射到 ResultSet，就像映射到 HashMap 一样简单。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;selectUsers&quot; resultType&#x3D;&quot;com.someapp.model.User&quot;&gt;\n  select id, username, hashedPassword\n  from some_table\n  where id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><p>类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- mybatis-config.xml 中 --&gt;\n&lt;typeAlias type&#x3D;&quot;com.someapp.model.User&quot; alias&#x3D;&quot;User&quot;&#x2F;&gt;\n\n&lt;!-- SQL 映射 XML 中 --&gt;\n&lt;select id&#x3D;&quot;selectUsers&quot; resultType&#x3D;&quot;User&quot;&gt;\n  select id, username, hashedPassword\n  from some_table\n  where id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<h3 id=\"如果列名和属性名不能匹配上\"><a href=\"#如果列名和属性名不能匹配上\" class=\"headerlink\" title=\"如果列名和属性名不能匹配上\"></a>如果列名和属性名不能匹配上</h3><p>在这些情况下，MyBatis 会在幕后自动创建一个 ResultMap，再根据属性名来映射列到 JavaBean 的属性上。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;selectUsers&quot; resultType&#x3D;&quot;User&quot;&gt;\n  select\n    user_id             as &quot;id&quot;,\n    user_name           as &quot;userName&quot;,\n    hashed_password     as &quot;hashedPassword&quot;\n  from some_table\n  where id &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<h3 id=\"显式使用外部的-resultMap-会怎样\"><a href=\"#显式使用外部的-resultMap-会怎样\" class=\"headerlink\" title=\"显式使用外部的 resultMap 会怎样\"></a>显式使用外部的 resultMap 会怎样</h3><img src=\"http://t-blog-images.aijs.top/img/202305271857113.webp\" />\n\n<h1 id=\"高级结果映射\"><a href=\"#高级结果映射\" class=\"headerlink\" title=\"高级结果映射\"></a>高级结果映射</h1><h3 id=\"结果映射（resultMap）\"><a href=\"#结果映射（resultMap）\" class=\"headerlink\" title=\"结果映射（resultMap）\"></a>结果映射（resultMap）</h3><h3 id=\"id-amp-result\"><a href=\"#id-amp-result\" class=\"headerlink\" title=\"id &amp; result\"></a>id &amp; result</h3><h3 id=\"支持的-JDBC-类型\"><a href=\"#支持的-JDBC-类型\" class=\"headerlink\" title=\"支持的 JDBC 类型\"></a>支持的 JDBC 类型</h3><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><h2 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h2><h3 id=\"关联的嵌套-Select-查询\"><a href=\"#关联的嵌套-Select-查询\" class=\"headerlink\" title=\"关联的嵌套 Select 查询\"></a>关联的嵌套 Select 查询</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;blogResult&quot; type&#x3D;&quot;Blog&quot;&gt;\n  &lt;association property&#x3D;&quot;author&quot; column&#x3D;&quot;author_id&quot; javaType&#x3D;&quot;Author&quot; select&#x3D;&quot;selectAuthor&quot;&#x2F;&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;select id&#x3D;&quot;selectBlog&quot; resultMap&#x3D;&quot;blogResult&quot;&gt;\n  SELECT * FROM BLOG WHERE ID &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;\n\n&lt;select id&#x3D;&quot;selectAuthor&quot; resultType&#x3D;&quot;Author&quot;&gt;\n  SELECT * FROM AUTHOR WHERE ID &#x3D; #&#123;id&#125;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>上述代码是一个 MyBatis 的示例，它使用了 <code>resultMap</code> 和 <code>association</code> 标签来将两个表 <code>Blog</code> 和 <code>Author</code> 进行关联查询。具体解释如下：</p>\n<ul>\n<li><code>resultMap</code> 标签定义了一个结果映射，它的 <code>id</code> 属性是映射的唯一标识，<code>type</code> 属性指定了映射的 Java 对象类型；</li>\n<li><code>association</code> 标签定义了一个关联关系，它的 <code>property</code> 属性指定了关联的 Java 对象属性名，<code>column</code> 属性指定了关联的数据库列名，<code>javaType</code> 属性指定了关联的 Java 对象类型，<code>select</code> 属性指定了关联的查询语句；</li>\n<li><code>select</code> 标签中的 SQL 查询语句会在关联查询时执行，查询出关联的对象。</li>\n</ul>\n<p>在上述示例中，<code>selectBlog</code> 查询语句使用了 <code>resultMap</code> 属性来指定查询结果的映射方式为 <code>blogResult</code>，因此查询结果会按照 <code>blogResult</code> 定义的映射方式进行映射。<code>blogResult</code> 映射方式中使用了 <code>association</code> 标签来定义了一个 <code>author</code> 对象的关联关系，指定了 <code>selectAuthor</code> 查询语句来查询 <code>author</code> 对象。</p>\n<p>因此，在执行 <code>selectBlog</code> 查询语句时，MyBatis 会先查询出 <code>Blog</code> 对象，然后执行 <code>selectAuthor</code> 查询语句来查询出关联的 <code>Author</code> 对象，最后将两个对象进行关联。查询结果会映射到 <code>Blog</code> 对象中，<code>author</code> 对象的属性会被填充为查询出的 <code>Author</code> 对象。</p>\n<h3 id=\"关联的嵌套结果映射-解决-“关联的嵌套-Select”-N-1-问题\"><a href=\"#关联的嵌套结果映射-解决-“关联的嵌套-Select”-N-1-问题\" class=\"headerlink\" title=\"关联的嵌套结果映射 解决 “关联的嵌套 Select” N+1 问题\"></a>关联的嵌套结果映射 解决 “关联的嵌套 Select” N+1 问题</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;authorResult&quot; type&#x3D;&quot;Author&quot;&gt;\n  &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;author_id&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;author_username&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;password&quot; column&#x3D;&quot;author_password&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;email&quot; column&#x3D;&quot;author_email&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;bio&quot; column&#x3D;&quot;author_bio&quot;&#x2F;&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;resultMap id&#x3D;&quot;blogResult&quot; type&#x3D;&quot;Blog&quot;&gt;\n  &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;blog_id&quot; &#x2F;&gt;\n  &lt;result property&#x3D;&quot;title&quot; column&#x3D;&quot;blog_title&quot;&#x2F;&gt;\n  &lt;association property&#x3D;&quot;author&quot;\n    resultMap&#x3D;&quot;authorResult&quot; &#x2F;&gt;\n  &lt;association property&#x3D;&quot;coAuthor&quot;\n    resultMap&#x3D;&quot;authorResult&quot;\n    columnPrefix&#x3D;&quot;co_&quot; &#x2F;&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>关联的嵌套结果映射 输出结果是</p>\n<p>对于上述配置的 <code>resultMap</code>，假设 <code>Blog</code> 对应的数据库表包含以下数据：</p>\n<table>\n<thead>\n<tr>\n<th>blog_id</th>\n<th>blog_title</th>\n<th>author_id</th>\n<th>co_author_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>My First Blog</td>\n<td>100</td>\n<td>200</td>\n</tr>\n<tr>\n<td>2</td>\n<td>My Second Blog<br/>(co-authored with Jane Smith)</td>\n<td>101</td>\n<td>201</td>\n</tr>\n</tbody></table>\n<p>其中 <code>author_id</code> 和 <code>co_author_id</code> 是外键，分别指向 <code>Author</code> 表中的记录。</p>\n<p>当执行以下 SQL 语句查询 <code>Blog</code> 数据时：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT blog_id, blog_title, b.author_id, b.co_author_id,\n  a1.author_username AS author_username, a1.author_password AS author_password,\n  a1.author_email AS author_email, a1.author_bio AS author_bio,\n  a2.author_username AS co_author_username, a2.author_password AS co_author_password,\n  a2.author_email AS co_author_email, a2.author_bio AS co_author_bio\nFROM blog b\nLEFT JOIN author a1 ON b.author_id &#x3D; a1.author_id\nLEFT JOIN author a2 ON b.co_author_id &#x3D; a2.author_id\nWHERE blog_id &#x3D; 2;</code></pre>\n\n<p>则对应的 <code>Blog</code> 结果对象为：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;id&quot;: 2,\n  &quot;title&quot;: &quot;My Second Blog (co-authored with Jane Smith)&quot;,\n  &quot;author&quot;: &#123;\n    &quot;id&quot;: 101,\n    &quot;username&quot;: &quot;johnny&quot;,\n    &quot;password&quot;: &quot;password&quot;,\n    &quot;email&quot;: &quot;johnny@example.com&quot;,\n    &quot;bio&quot;: &quot;I&#39;m Johnny, a blogger from Seattle.&quot;\n  &#125;,\n  &quot;coAuthor&quot;: &#123;\n    &quot;id&quot;: 201,\n    &quot;username&quot;: &quot;jane&quot;,\n    &quot;password&quot;: &quot;password&quot;,\n    &quot;email&quot;: &quot;jane@example.com&quot;,\n    &quot;bio&quot;: &quot;I&#39;m Jane, a blogger from New York.&quot;\n  &#125;\n&#125;</code></pre>\n\n<p>其中 <code>author</code> 和 <code>coAuthor</code> 嵌套了一个 <code>Author</code> 对象，并根据 <code>resultMap</code> 中的配置将查询结果映射到了这些对象的属性上。注意，由于 <code>co_author_id</code> 列名中包含了 <code>co_</code> 前缀，因此在 <code>coAuthor</code> 的 <code>resultMap</code> 中需要指定 <code>columnPrefix=&quot;co_&quot;</code>。</p>\n<h3 id=\"关联的多结果集（ResultSet）\"><a href=\"#关联的多结果集（ResultSet）\" class=\"headerlink\" title=\"关联的多结果集（ResultSet）\"></a>关联的多结果集（ResultSet）</h3><h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"集合的嵌套-Select-查询\"><a href=\"#集合的嵌套-Select-查询\" class=\"headerlink\" title=\"集合的嵌套 Select 查询\"></a>集合的嵌套 Select 查询</h3><h3 id=\"集合的嵌套结果映射\"><a href=\"#集合的嵌套结果映射\" class=\"headerlink\" title=\"集合的嵌套结果映射\"></a>集合的嵌套结果映射</h3><h3 id=\"集合的多结果集（ResultSet）\"><a href=\"#集合的多结果集（ResultSet）\" class=\"headerlink\" title=\"集合的多结果集（ResultSet）\"></a>集合的多结果集（ResultSet）</h3><h3 id=\"鉴别器\"><a href=\"#鉴别器\" class=\"headerlink\" title=\"鉴别器\"></a>鉴别器</h3><h1 id=\"mybatis-集合-GPT\"><a href=\"#mybatis-集合-GPT\" class=\"headerlink\" title=\"mybatis 集合 GPT\"></a>mybatis 集合 GPT</h1><p>MyBatis 中的集合指的是 Java 对象中的一个集合属性，比如 <code>List</code>、<code>Set</code>、<code>Map</code> 等。MyBatis 提供了一些元素来处理这些集合属性。</p>\n<p>假设我们有如下的一个 <code>Blog</code> 类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Blog &#123;\n    private int id;\n    private String title;\n    private List&lt;String&gt; tags;\n    &#x2F;&#x2F; getters and setters\n&#125;</code></pre>\n\n<p>其中 <code>tags</code> 是一个字符串类型的列表，表示文章的标签。现在我们需要查询文章及其对应的标签列表，可以使用以下的 SQL 语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT id, title FROM blog WHERE id &#x3D; #&#123;id&#125;;\nSELECT tag FROM tag WHERE blog_id &#x3D; #&#123;id&#125;;</code></pre>\n\n<p>第一条 SQL 语句查询文章的基本信息，第二条 SQL 语句查询对应的标签列表。由于这两条 SQL 语句没有直接的关联，因此无法直接使用嵌套查询来完成。这时可以使用 MyBatis 提供的集合元素来处理。</p>\n<p>首先，在 <code>Blog</code> 类对应的 <code>resultMap</code> 中添加如下的元素：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;blogResult&quot; type&#x3D;&quot;Blog&quot;&gt;\n  &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot; &#x2F;&gt;\n  &lt;result property&#x3D;&quot;title&quot; column&#x3D;&quot;title&quot;&#x2F;&gt;\n  &lt;collection property&#x3D;&quot;tags&quot; ofType&#x3D;&quot;java.lang.String&quot;&gt;\n    &lt;result column&#x3D;&quot;tag&quot;&#x2F;&gt;\n  &lt;&#x2F;collection&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>其中 <code>&lt;collection&gt;</code> 元素用于处理 <code>tags</code> 属性，<code>property</code> 属性指定了集合属性的名称，<code>ofType</code> 属性指定了集合元素的类型，<code>&lt;result&gt;</code> 元素用于将查询结果映射到集合元素上。</p>\n<p>然后，在 mapper.xml 文件中使用如下的 SQL 语句来完成查询：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getBlogWithTags&quot; resultMap&#x3D;&quot;blogResult&quot;&gt;\n  &lt;parameter property&#x3D;&quot;id&quot; &#x2F;&gt;\n  SELECT id, title FROM blog WHERE id &#x3D; #&#123;id&#125;;\n  SELECT tag FROM tag WHERE blog_id &#x3D; #&#123;id&#125;;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>其中 <code>&lt;select&gt;</code> 元素包含了两条 SQL 语句，通过在第一条 SQL 语句中使用 <code>resultMap</code>，指定了查询结果的映射关系。在第二条 SQL 语句中，使用 <code>SELECT</code> 元素来执行查询并将结果映射到集合属性 <code>tags</code> 上。</p>\n<p>接下来，我们可以在 Java 代码中调用该方法来查询文章及其对应的标签列表：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Blog blog &#x3D; sqlSession.selectOne(&quot;getBlogWithTags&quot;, 1);\nSystem.out.println(blog.getTags());</code></pre>\n\n<p>这样就可以查询到文章及其对应的标签列表了。需要注意的是，使用集合元素时，需要保证 SQL 语句返回的结果集是有序的，否则可能导致映射错误。</p>\n<h2 id=\"需要注意的是，使用集合元素时，需要保证-SQL-语句返回的结果集是有序的-怎么理解？\"><a href=\"#需要注意的是，使用集合元素时，需要保证-SQL-语句返回的结果集是有序的-怎么理解？\" class=\"headerlink\" title=\"需要注意的是，使用集合元素时，需要保证 SQL 语句返回的结果集是有序的 怎么理解？\"></a>需要注意的是，使用集合元素时，需要保证 SQL 语句返回的结果集是有序的 怎么理解？</h2><p>使用 MyBatis 的集合元素时，需要保证 SQL 语句返回的结果集是有序的，否则可能会导致映射错误。</p>\n<p>这是因为 MyBatis 在处理集合属性时，是通过循环遍历结果集并逐个映射到集合元素上的。如果结果集是无序的，那么很可能会导致集合元素与结果集中的数据不匹配，从而导致错误的数据被映射到集合属性中。</p>\n<p>例如，我们有如下的一个 <code>Blog</code> 类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Blog &#123;\n    private int id;\n    private String title;\n    private List&lt;String&gt; tags;\n    &#x2F;&#x2F; getters and setters\n&#125;</code></pre>\n\n<p>其中 <code>tags</code> 是一个字符串类型的列表，表示文章的标签。现在我们需要查询文章及其对应的标签列表，可以使用以下的 SQL 语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT id, title FROM blog WHERE id &#x3D; #&#123;id&#125;;\nSELECT tag FROM tag WHERE blog_id &#x3D; #&#123;id&#125; ORDER BY id DESC;</code></pre>\n\n<p>第一条 SQL 语句查询文章的基本信息，第二条 SQL 语句查询对应的标签列表，并使用 <code>ORDER BY</code> 子句将结果集按照 <code>id</code> 字段倒序排序。这样可以保证查询结果是有序的，从而避免了使用集合元素时可能出现的映射错误。</p>\n<p>因此，需要注意的是，在使用 MyBatis 的集合元素时，必须保证 SQL 语句返回的结果集是有序的，否则可能会导致映射错误。</p>\n<h2 id=\"mybatis-集合的嵌套结果映射\"><a href=\"#mybatis-集合的嵌套结果映射\" class=\"headerlink\" title=\"mybatis 集合的嵌套结果映射\"></a>mybatis 集合的嵌套结果映射</h2><p>MyBatis 中提供了集合的嵌套结果映射，可以将一对多、多对多等关系的数据映射到 Java 对象中的集合属性中。具体来说，可以通过嵌套的 <code>&lt;collection&gt;</code> 元素或 <code>&lt;association&gt;</code> 元素来实现。</p>\n<p>下面以一对多的关系为例，介绍 MyBatis 集合的嵌套结果映射：</p>\n<p>假设我们有如下的两个表：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE department (\n    id INT PRIMARY KEY,\n    name VARCHAR(20) NOT NULL\n);\n\nCREATE TABLE employee (\n    id INT PRIMARY KEY,\n    name VARCHAR(20) NOT NULL,\n    department_id INT NOT NULL,\n    FOREIGN KEY (department_id) REFERENCES department(id)\n);</code></pre>\n\n<p>其中 <code>department</code> 表表示部门信息，<code>employee</code> 表表示员工信息，并且 <code>employee</code> 表中的 <code>department_id</code> 外键关联了 <code>department</code> 表的 <code>id</code> 字段。</p>\n<p>现在我们需要查询每个部门及其对应的所有员工信息，可以使用以下的 SQL 语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT id, name FROM department;\nSELECT id, name, department_id FROM employee;</code></pre>\n\n<p>第一条 SQL 语句查询部门信息，第二条 SQL 语句查询员工信息，并使用 <code>department_id</code> 字段与 <code>department</code> 表的 <code>id</code> 字段进行关联。这样可以查询出每个部门及其对应的所有员工信息。</p>\n<p>接下来，我们可以通过如下的 MyBatis 映射文件将查询结果映射到 Java 对象中：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;departmentMap&quot; type&#x3D;&quot;Department&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;collection property&#x3D;&quot;employees&quot; ofType&#x3D;&quot;Employee&quot;&gt;\n        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n        &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;&#x2F;collection&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;resultMap id&#x3D;&quot;employeeMap&quot; type&#x3D;&quot;Employee&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;association property&#x3D;&quot;department&quot; javaType&#x3D;&quot;Department&quot;&gt;\n        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;department_id&quot;&#x2F;&gt;\n        &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;&#x2F;association&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;select id&#x3D;&quot;getDepartments&quot; resultMap&#x3D;&quot;departmentMap&quot;&gt;\n    SELECT id, name FROM department;\n&lt;&#x2F;select&gt;\n\n&lt;select id&#x3D;&quot;getEmployeesByDepartment&quot; resultMap&#x3D;&quot;employeeMap&quot;&gt;\n    SELECT id, name, department_id FROM employee WHERE department_id &#x3D; #&#123;id&#125;;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>其中，<code>&lt;collection&gt;</code> 元素用于映射部门的员工列表，<code>&lt;association&gt;</code> 元素用于映射员工所在的部门信息。在 <code>&lt;collection&gt;</code> 元素和 <code>&lt;association&gt;</code> 元素中，分别使用 <code>ofType</code> 属性和 <code>javaType</code> 属性指定集合元素和关联对象的类型。</p>\n<p>这样，在查询部门信息时，MyBatis 会自动查询对应的员工信息，并将查询结果映射到 <code>Department</code> 对象中的 <code>employees</code> 集合属性中；在查询员工信息时，MyBatis 会自动查询对应的部门信息，并将查询结果映射到 <code>Employee</code> 对象中的 <code>department</code> 属性中。这样，就可以方便地实现一对多关系的数据查询和映射了。</p>\n<ul>\n<li>一对多，正向用 collection，反向用 association</li>\n</ul>\n<h2 id=\"mybatis-集合-一对多，正向用-collection，反向用-association\"><a href=\"#mybatis-集合-一对多，正向用-collection，反向用-association\" class=\"headerlink\" title=\"mybatis 集合 一对多，正向用 collection，反向用 association\"></a>mybatis 集合 一对多，正向用 collection，反向用 association</h2><p>是的，MyBatis 中集合映射分为正向映射和反向映射，一对多关系中分别对应使用 <code>&lt;collection&gt;</code> 和 <code>&lt;association&gt;</code> 元素。</p>\n<p>正向映射表示从一的一侧到多的一侧的映射，即将一的一侧的数据关联到多的一侧的数据中。在 MyBatis 中，可以使用 <code>&lt;collection&gt;</code> 元素来实现正向映射。例如，如果需要将一个部门对应的多个员工映射到 <code>Department</code> 对象中的 <code>employees</code> 属性中，可以使用如下的映射配置：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;departmentMap&quot; type&#x3D;&quot;Department&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;collection property&#x3D;&quot;employees&quot; ofType&#x3D;&quot;Employee&quot;&gt;\n        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n        &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;&#x2F;collection&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>其中，<code>&lt;collection&gt;</code> 元素用于映射部门的员工列表，<code>property</code> 属性指定了 Java 对象中的集合属性名称，<code>ofType</code> 属性指定了集合元素的类型，<code>id</code> 元素用于指定集合元素的主键映射，<code>result</code> 元素用于指定集合元素的普通属性映射。</p>\n<p>反向映射表示从多的一侧到一的一侧的映射，即将多的一侧的数据关联到一的一侧的数据中。在 MyBatis 中，可以使用 <code>&lt;association&gt;</code> 元素来实现反向映射。例如，如果需要将一个员工对应的部门信息映射到 <code>Employee</code> 对象中的 <code>department</code> 属性中，可以使用如下的映射配置：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;employeeMap&quot; type&#x3D;&quot;Employee&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;association property&#x3D;&quot;department&quot; javaType&#x3D;&quot;Department&quot;&gt;\n        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;department_id&quot;&#x2F;&gt;\n        &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;&#x2F;association&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>其中，<code>&lt;association&gt;</code> 元素用于映射员工所在的部门信息，<code>property</code> 属性指定了 Java 对象中的属性名称，<code>javaType</code> 属性指定了关联对象的类型，<code>id</code> 元素用于指定关联对象的主键映射，<code>result</code> 元素用于指定关联对象的普通属性映射。</p>\n<p>需要注意的是，正向映射和反向映射的区别在于集合元素和关联对象的位置和属性，因此在使用 <code>&lt;collection&gt;</code> 和 <code>&lt;association&gt;</code> 元素时需要根据具体情况进行选择和配置。</p>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><p>以下是一对多关系的正向映射和反向映射的 MyBatis 配置文件示例：</p>\n<p><strong>正向映射示例</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;orderMap&quot; type&#x3D;&quot;Order&quot;&gt;\n  &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n  &lt;collection property&#x3D;&quot;items&quot; ofType&#x3D;&quot;OrderItem&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;price&quot; column&#x3D;&quot;price&quot;&#x2F;&gt;\n  &lt;&#x2F;collection&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>在上述示例中，使用 <code>&lt;collection&gt;</code> 元素将 <code>Order</code> 对象中的 <code>items</code> 属性映射为多个 <code>OrderItem</code> 对象，其中 <code>id</code> 元素用于指定 <code>OrderItem</code> 对象的主键映射，<code>result</code> 元素用于指定 <code>OrderItem</code> 对象的普通属性映射。</p>\n<p><strong>反向映射示例</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;orderItemMap&quot; type&#x3D;&quot;OrderItem&quot;&gt;\n  &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;price&quot; column&#x3D;&quot;price&quot;&#x2F;&gt;\n  &lt;association property&#x3D;&quot;order&quot; javaType&#x3D;&quot;Order&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;order_id&quot;&#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;order_name&quot;&#x2F;&gt;\n  &lt;&#x2F;association&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>在上述示例中，使用 <code>&lt;association&gt;</code> 元素将 <code>OrderItem</code> 对象中的 <code>order</code> 属性映射为一个 <code>Order</code> 对象，其中 <code>id</code> 元素用于指定 <code>OrderItem</code> 对象的主键映射，<code>result</code> 元素用于指定 <code>OrderItem</code> 对象的普通属性映射。</p>\n<h2 id=\"对象结构\"><a href=\"#对象结构\" class=\"headerlink\" title=\"对象结构\"></a>对象结构</h2><p>以下是示例代码的 Java 对象结构的演示：</p>\n<p><strong>正向映射的 Java 对象结构</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Order &#123;\n  private Long id;\n  private String name;\n  private List&lt;OrderItem&gt; items;\n  &#x2F;&#x2F; getter and setter methods\n&#125;\n\npublic class OrderItem &#123;\n  private Long id;\n  private String name;\n  private BigDecimal price;\n  private Order order;\n  &#x2F;&#x2F; getter and setter methods\n&#125;</code></pre>\n\n<p>在上述示例中，<code>Order</code> 对象包含一个 <code>List&lt;OrderItem&gt;</code> 类型的属性 <code>items</code>，而 <code>OrderItem</code> 对象包含一个 <code>Order</code> 类型的属性 <code>order</code>。</p>\n<p><strong>反向映射的 Java 对象结构</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class OrderItem &#123;\n  private Long id;\n  private String name;\n  private BigDecimal price;\n  private Order order;\n  &#x2F;&#x2F; getter and setter methods\n&#125;\n\npublic class Order &#123;\n  private Long id;\n  private String name;\n  &#x2F;&#x2F; getter and setter methods\n&#125;</code></pre>\n\n<p>在上述示例中，<code>OrderItem</code> 对象包含一个 <code>Order</code> 类型的属性 <code>order</code>，而 <code>Order</code> 对象不包含 <code>OrderItem</code> 类型的属性。</p>\n<h2 id=\"集合的多结果集（ResultSet）-1\"><a href=\"#集合的多结果集（ResultSet）-1\" class=\"headerlink\" title=\"集合的多结果集（ResultSet）\"></a>集合的多结果集（ResultSet）</h2><p>集合的多结果集（ResultSet）指的是在 MyBatis 中可以通过一次 SQL 查询操作，返回多个不同类型的结果集，并将它们映射到对应的 Java 对象中。这个功能可以通过 <code>select</code> 元素的 <code>resultMap</code> 属性和 <code>resultSets</code> 属性来实现。</p>\n<p>具体而言，<code>resultMap</code> 属性可以指定一个结果集映射规则，将查询结果映射到一个 Java 对象上。而 <code>resultSets</code> 属性可以指定一个包含多个结果集的结果集映射规则，将查询结果映射到多个 Java 对象上。</p>\n<p>举个例子，假设我们有一个包含多个表的数据库，我们可以通过如下的 SQL 语句来查询这些表的数据：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT * FROM table1;\nSELECT * FROM table2;\nSELECT * FROM table3;</code></pre>\n\n<p>对应的 MyBatis 配置文件如下：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getMultipleResultSets&quot; resultSets&#x3D;&quot;resultSet1,resultSet2,resultSet3&quot;&gt;\n  SELECT * FROM table1;\n  SELECT * FROM table2;\n  SELECT * FROM table3;\n&lt;&#x2F;select&gt;\n\n&lt;resultMap id&#x3D;&quot;resultSet1&quot; type&#x3D;&quot;com.example.Table1&quot;&gt;\n  &lt;!-- 将 table1 表的列映射到 Table1 对象的属性上 --&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;resultMap id&#x3D;&quot;resultSet2&quot; type&#x3D;&quot;com.example.Table2&quot;&gt;\n  &lt;!-- 将 table2 表的列映射到 Table2 对象的属性上 --&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;resultMap id&#x3D;&quot;resultSet3&quot; type&#x3D;&quot;com.example.Table3&quot;&gt;\n  &lt;!-- 将 table3 表的列映射到 Table3 对象的属性上 --&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>在这个例子中，我们通过 <code>resultSets</code> 属性指定了三个结果集映射规则，每个规则分别将查询结果映射到一个 Java 对象上。当我们执行这个 SQL 查询语句时，MyBatis 会执行三次查询操作，分别获得三个结果集，并将它们映射到对应的 Java 对象中。最终，我们就可以通过一个方法来获得这三个 Java 对象的列表。</p>\n<h2 id=\"这样设计有什么优点？\"><a href=\"#这样设计有什么优点？\" class=\"headerlink\" title=\"这样设计有什么优点？\"></a>这样设计有什么优点？</h2><p>将多个结果集映射到不同的 Java 对象中，有如下几个优点：</p>\n<ol>\n<li><p>灵活性更强：通过将多个结果集映射到不同的 Java 对象中，我们可以更灵活地控制每个结果集的映射规则。这样可以使得我们的代码更加清晰和易于维护。</p>\n</li>\n<li><p>性能更好：将多个结果集映射到不同的 Java 对象中，可以减少对数据库的查询次数，从而提高性能。这种方式避免了在 Java 层面对多个结果集进行拼接的操作，减少了数据传输的开销。</p>\n</li>\n<li><p>可读性更好：将多个结果集映射到不同的 Java 对象中，可以使得代码更加易于理解和阅读。每个 Java 对象都代表了一个具体的数据表或者查询结果，这样可以方便代码编写和维护。同时，由于每个结果集的映射规则都是独立的，因此可以更容易地维护代码的可读性。</p>\n</li>\n<li><p>映射规则更加精细：通过将多个结果集映射到不同的 Java 对象中，我们可以更加精细地控制映射规则。例如，对于一些复杂的数据表中的数据，我们可以将其映射到一个专门的 Java 对象中，从而更好地表达其语义。这种方式可以使得代码更加精细和规范，提高代码的可读性和可维护性。</p>\n</li>\n</ol>\n<h2 id=\"直接分开单个查询不也一样吗\"><a href=\"#直接分开单个查询不也一样吗\" class=\"headerlink\" title=\"直接分开单个查询不也一样吗\"></a>直接分开单个查询不也一样吗</h2><p>将多个结果集映射到不同的 Java 对象中和直接分开单个查询确实可以达到类似的效果，但两者之间还是有一些区别的。</p>\n<ol>\n<li><p>可读性更好：将多个结果集映射到不同的 Java 对象中可以方便代码编写和维护，同时也可以提高代码的可读性。而直接分开单个查询则需要在代码中手动拼接多个查询结果，这样会导致代码可读性较差。</p>\n</li>\n<li><p>映射规则更加精细：将多个结果集映射到不同的 Java 对象中可以更加精细地控制映射规则。这种方式可以使得代码更加精细和规范，提高代码的可读性和可维护性。而直接分开单个查询则需要在代码中手动拼接多个查询结果，这样映射规则的精细程度受到了一定的限制。</p>\n</li>\n<li><p>性能更好：将多个结果集映射到不同的 Java 对象中可以减少对数据库的查询次数，从而提高性能。而直接分开单个查询则需要对多个查询结果进行手动拼接，这样会增加网络传输的开销，导致性能下降。</p>\n</li>\n</ol>\n<p>因此，将多个结果集映射到不同的 Java 对象中可以提高代码的可读性和可维护性，同时还可以提高性能和映射规则的精细程度，具有一定的优势。</p>\n<h2 id=\"不懂，写个完整示例\"><a href=\"#不懂，写个完整示例\" class=\"headerlink\" title=\"不懂，写个完整示例\"></a>不懂，写个完整示例</h2><p>好的，下面是一个将多个结果集映射到不同的 Java 对象中的示例：</p>\n<p>假设我们有一个学生表和一个班级表，其中学生表包含 id、name 和 class_id 三个字段，班级表包含 id 和 name 两个字段。我们需要查询所有学生的信息，并且要将学生和对应班级的信息映射到不同的 Java 对象中。</p>\n<p>首先，我们需要定义两个 Java 对象：Student 和 Class。Student 对象包含 id、name 和 classInfo 三个字段，其中 classInfo 是一个 Class 对象，包含 id 和 name 两个字段。Class 对象只包含 id 和 name 两个字段。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    private Long id;\n    private String name;\n    private Class classInfo;\n    &#x2F;&#x2F; 省略 get 和 set 方法\n&#125;\n\npublic class Class &#123;\n    private Long id;\n    private String name;\n    &#x2F;&#x2F; 省略 get 和 set 方法\n&#125;</code></pre>\n\n<p>然后，我们可以使用 MyBatis 来编写查询语句，并使用 resultMap 来将查询结果映射到对应的 Java 对象中。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;selectAllStudents&quot; resultType&#x3D;&quot;Student&quot;&gt;\n    SELECT s.id, s.name, c.id AS classInfo.id, c.name AS classInfo.name\n    FROM student s\n    LEFT JOIN class c ON s.class_id &#x3D; c.id\n&lt;&#x2F;select&gt;\n\n&lt;resultMap id&#x3D;&quot;studentResultMap&quot; type&#x3D;&quot;Student&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot; &#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot; &#x2F;&gt;\n    &lt;association property&#x3D;&quot;classInfo&quot; resultMap&#x3D;&quot;classResultMap&quot; &#x2F;&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;resultMap id&#x3D;&quot;classResultMap&quot; type&#x3D;&quot;Class&quot;&gt;\n    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot; &#x2F;&gt;\n    &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot; &#x2F;&gt;\n&lt;&#x2F;resultMap&gt;</code></pre>\n\n<p>最后，在 Java 代码中调用查询语句。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Student&gt; students &#x3D; sqlSession.selectList(&quot;selectAllStudents&quot;);</code></pre>\n\n<p>这样，我们就可以将多个结果集映射到不同的 Java 对象中了。通过使用 resultMap，我们可以更加精细地控制映射规则，同时也可以提高代码的可读性和可维护性。</p>\n<h2 id=\"查询语句的结果是什么样子\"><a href=\"#查询语句的结果是什么样子\" class=\"headerlink\" title=\"查询语句的结果是什么样子\"></a>查询语句的结果是什么样子</h2><p>查询语句的结果类似于下面的表格：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>classInfo.id</th>\n<th>classInfo.name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Tom</td>\n<td>1</td>\n<td>Class One</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Lucy</td>\n<td>2</td>\n<td>Class Two</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Jack</td>\n<td>1</td>\n<td>Class One</td>\n</tr>\n</tbody></table>\n<p>其中，每一行表示一个学生的信息，id 和 name 分别对应 Student 对象的 id 和 name 属性，classInfo.id 和 classInfo.name 分别对应 Class 对象的 id 和 name 属性。注意，这里使用了 LEFT JOIN，因此可能存在学生未对应班级的情况，此时 classInfo.id 和 classInfo.name 的值为 NULL。</p>\n<h2 id=\"我理解：-结果集映射理解为，sql-查询结果是扁平的，结果集映射是对数据二次整理，转化成想要的样子\"><a href=\"#我理解：-结果集映射理解为，sql-查询结果是扁平的，结果集映射是对数据二次整理，转化成想要的样子\" class=\"headerlink\" title=\"我理解： 结果集映射理解为，sql 查询结果是扁平的，结果集映射是对数据二次整理，转化成想要的样子\"></a>我理解： 结果集映射理解为，sql 查询结果是扁平的，结果集映射是对数据二次整理，转化成想要的样子</h2><p>结果集映射（Result Set Mapping）是将 SQL 查询结果转化为应用程序需要的格式的过程。在 SQL 查询结果中，通常是一个扁平的表格，每一行表示一条记录，每一列表示一个字段。但是在应用程序中，我们通常需要将这些记录转化为对象或其他形式的数据结构，这就需要进行结果集映射。</p>\n<p>结果集映射包括两个方面：</p>\n<ol>\n<li><p>对查询结果进行二次整理，将扁平的结果转化为一个个对象或其他数据结构。</p>\n</li>\n<li><p>将查询结果中的字段映射到对象或其他数据结构的属性上，使得应用程序可以方便地访问和处理数据。</p>\n</li>\n</ol>\n<p>对于 Java 应用程序来说，通常使用 ORM 框架进行结果集映射，例如 Hibernate、MyBatis 等。这些框架可以将 SQL 查询结果映射到 Java 对象上，并提供方便的 API 进行数据访问和处理。</p>\n<h2 id=\"插入成功后返回主键的-xml\"><a href=\"#插入成功后返回主键的-xml\" class=\"headerlink\" title=\"插入成功后返回主键的 xml\"></a>插入成功后返回主键的 xml</h2><p>如果你是使用 MyBatis 进行数据库操作，可以通过以下的 XML 配置来实现插入成功后返回主键：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 定义插入语句 --&gt;\n&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.example.User&quot;&gt;\n  insert into user (username, password, email) values (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)\n&lt;&#x2F;insert&gt;\n\n&lt;!-- 配置主键生成 --&gt;\n&lt;selectKey resultType&#x3D;&quot;java.lang.Long&quot; keyProperty&#x3D;&quot;id&quot; order&#x3D;&quot;AFTER&quot;&gt;\n  select last_insert_id()\n&lt;&#x2F;selectKey&gt;</code></pre>\n\n<p>以上 XML 配置中，<code>insertUser</code> 是插入语句的 ID，<code>com.example.User</code> 是参数类型。在插入语句中，使用了 <code>#&#123;&#125;</code> 占位符语法，用来设置插入的值。<code>selectKey</code> 标签定义了生成主键的方式，其中 <code>resultType</code> 表示主键的数据类型，<code>keyProperty</code> 表示主键对应的 Java 对象属性名，<code>order</code> 表示 <code>selectKey</code> 的执行顺序，这里是在插入之后执行。</p>\n<p>在 Java 代码中，调用 <code>insertUser</code> 方法后，会返回一个 <code>java.lang.Long</code> 类型的主键值，并将该值设置到 <code>User</code> 对象的 <code>id</code> 属性中。</p>\n<h2 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h2><p>以下是一个使用 MyBatis 实现插入成功后返回主键的完整示例：</p>\n<h4 id=\"1-创建表格\"><a href=\"#1-创建表格\" class=\"headerlink\" title=\"1. 创建表格\"></a>1. 创建表格</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;user&#96; (\n  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,\n  &#96;username&#96; varchar(50) NOT NULL,\n  &#96;password&#96; varchar(50) NOT NULL,\n  &#96;email&#96; varchar(50) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;</code></pre>\n\n<h4 id=\"2-创建-User-实体类\"><a href=\"#2-创建-User-实体类\" class=\"headerlink\" title=\"2. 创建 User 实体类\"></a>2. 创建 User 实体类</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    private Long id;\n    private String username;\n    private String password;\n    private String email;\n    &#x2F;&#x2F; getters and setters\n&#125;</code></pre>\n\n<h4 id=\"3-创建-MyBatis-Mapper-XML-文件\"><a href=\"#3-创建-MyBatis-Mapper-XML-文件\" class=\"headerlink\" title=\"3. 创建 MyBatis Mapper XML 文件\"></a>3. 创建 MyBatis Mapper XML 文件</h4><p>在 MyBatis Mapper XML 文件中，定义插入语句和主键生成方式：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- UserMapper.xml --&gt;\n&lt;mapper namespace&#x3D;&quot;com.example.UserMapper&quot;&gt;\n\n    &lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.example.User&quot;&gt;\n        insert into user (username, password, email) values (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)\n    &lt;&#x2F;insert&gt;\n\n    &lt;selectKey resultType&#x3D;&quot;java.lang.Long&quot; keyProperty&#x3D;&quot;id&quot; order&#x3D;&quot;AFTER&quot;&gt;\n        select last_insert_id()\n    &lt;&#x2F;selectKey&gt;\n\n&lt;&#x2F;mapper&gt;</code></pre>\n\n<h4 id=\"4-创建-MyBatis-Mapper-接口\"><a href=\"#4-创建-MyBatis-Mapper-接口\" class=\"headerlink\" title=\"4. 创建 MyBatis Mapper 接口\"></a>4. 创建 MyBatis Mapper 接口</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserMapper &#123;\n    void insertUser(User user);\n&#125;</code></pre>\n\n<h4 id=\"5-创建-MyBatis-配置文件\"><a href=\"#5-创建-MyBatis-配置文件\" class=\"headerlink\" title=\"5. 创建 MyBatis 配置文件\"></a>5. 创建 MyBatis 配置文件</h4><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- mybatis-config.xml --&gt;\n&lt;configuration&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource&#x3D;&quot;com&#x2F;example&#x2F;UserMapper.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;</code></pre>\n\n<h4 id=\"6-创建测试类\"><a href=\"#6-创建测试类\" class=\"headerlink\" title=\"6. 创建测试类\"></a>6. 创建测试类</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyBatisTest &#123;\n\n    private SqlSessionFactory sessionFactory;\n    private UserMapper userMapper;\n\n    @Before\n    public void setUp() throws Exception &#123;\n        &#x2F;&#x2F; 创建 SqlSessionFactory\n        InputStream inputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);\n        sessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#x2F;&#x2F; 创建 UserMapper\n        SqlSession sqlSession &#x3D; sessionFactory.openSession();\n        userMapper &#x3D; sqlSession.getMapper(UserMapper.class);\n    &#125;\n\n    @Test\n    public void testInsertUser() &#123;\n        User user &#x3D; new User();\n        user.setUsername(&quot;test&quot;);\n        user.setPassword(&quot;123456&quot;);\n        user.setEmail(&quot;test@example.com&quot;);\n        &#x2F;&#x2F; 插入用户\n        userMapper.insertUser(user);\n        &#x2F;&#x2F; 获取主键\n        Long id &#x3D; user.getId();\n        System.out.println(id);\n    &#125;\n\n    @After\n    public void tearDown() throws Exception &#123;\n        sessionFactory.close();\n    &#125;\n&#125;</code></pre>\n\n<p>在测试类中，我们首先通过 <code>Resources.getResourceAsStream()</code> 方法获取 MyBatis 配置文件的输入流，然后通过 <code>SqlSessionFactoryBuilder().build()</code> 方法创建 <code>SqlSessionFactory</code> 对象。接下来，我们通过 <code>SqlSession.getMapper()</code> 方法获取 UserMapper 对象，然后调用 <code>insertUser()</code> 方法插入数据。最后，我们可以通过 <code>User.getId()</code> 方法获取插入后的主键值。</p>\n<h1 id=\"动态-SQL\"><a href=\"#动态-SQL\" class=\"headerlink\" title=\"动态 SQL\"></a>动态 SQL</h1><ol>\n<li>if</li>\n<li>choose (when, otherwise)</li>\n<li>trim (where, set)</li>\n<li>foreach</li>\n</ol>\n<p>这些 MyBatis 标签可以帮助我们更方便地编写动态 SQL 语句。</p>\n<ul>\n<li><p><strong>if 标签：</strong> 用于指定 SQL 语句中的某些部分是否应该被包含。通常用于根据不同的条件来动态生成 SQL 语句，避免生成无用的语句。</p>\n</li>\n<li><p><strong>choose (when, otherwise) 标签：</strong> 用于在多个选项中选择一个选项。类似于编程语言中的 switch&#x2F;case 语句。可以根据不同的条件生成不同的 SQL 语句，从而更方便地处理复杂的逻辑。</p>\n</li>\n<li><p><strong>trim (where, set) 标签：</strong> 用于处理 SQL 语句中的空格和逗号。<strong>在某些情况下，生成的 SQL 语句可能会包含多余的空格或逗号，这可能会导致语法错误或性能下降</strong>。使用 trim 标签可以帮助我们更方便地处理这些问题。</p>\n</li>\n<li><p><strong>foreach 标签：</strong> 用于循环遍历一个集合。通常用于批量操作，例如批量插入、批量更新或批量删除。使用 foreach 标签可以避免重复编写 SQL 语句。</p>\n</li>\n</ul>\n<h2 id=\"消除-SQL-语句中多余的空格和逗号的问题\"><a href=\"#消除-SQL-语句中多余的空格和逗号的问题\" class=\"headerlink\" title=\"消除 SQL 语句中多余的空格和逗号的问题\"></a>消除 SQL 语句中多余的空格和逗号的问题</h2><p>如果你想要的结果是消除 SQL 语句中多余的空格和逗号的问题，可以使用 trim 标签中的 where 和 set 子标签来解决。</p>\n<h3 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h3><ul>\n<li><strong>where 子标签：</strong> 用于移除 SQL 语句中多余的 WHERE 关键字和条件语句之间的空格。</li>\n</ul>\n<p>例如，以下代码使用了 where 子标签来消除 SQL 语句中多余的 WHERE 关键字和条件语句之间的空格：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">&lt;select id&#x3D;&quot;selectByCondition&quot; resultType&#x3D;&quot;User&quot;&gt;\n  SELECT * FROM user\n  &lt;where&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt;\n      AND username &#x3D; #&#123;username&#125;\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null&quot;&gt;\n      AND email &#x3D; #&#123;email&#125;\n    &lt;&#x2F;if&gt;\n  &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>这样，即使只有 username 或 email 一个条件被指定，也不会在 SQL 语句中产生多余的空格和逻辑关键字。</p>\n<h3 id=\"更新语句\"><a href=\"#更新语句\" class=\"headerlink\" title=\"更新语句\"></a>更新语句</h3><ul>\n<li><strong>set 子标签：</strong> 用于移除 SQL 语句中多余的 SET 关键字和更新语句之间的逗号。</li>\n</ul>\n<p>例如，以下代码使用了 set 子标签来消除 SQL 语句中多余的 SET 关键字和更新语句之间的逗号：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n  UPDATE user\n  &lt;set&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt;\n      username &#x3D; #&#123;username&#125;,\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null&quot;&gt;\n      email &#x3D; #&#123;email&#125;,\n    &lt;&#x2F;if&gt;\n  &lt;&#x2F;set&gt;\n  WHERE id &#x3D; #&#123;id&#125;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>这样，即使只有 username 或 email 一个属性被指定更新，也不会在 SQL 语句中产生多余的逗号。</p>\n<h2 id=\"插入语句不需要特殊处理吗\"><a href=\"#插入语句不需要特殊处理吗\" class=\"headerlink\" title=\"插入语句不需要特殊处理吗\"></a>插入语句不需要特殊处理吗</h2><p>对于插入语句的 SQL，是不需要特殊处理的，因为插入语句中不会出现多余关键字或者逗号的情况。</p>\n<p>例如，以下是一个简单的插入语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n  INSERT INTO user (username, email)\n  VALUES (#&#123;username&#125;, #&#123;email&#125;)\n&lt;&#x2F;insert&gt;</code></pre>\n\n<p>在这个插入语句中，我们使用了 INSERT INTO 关键字和 VALUES 子句，没有多余的逗号或其他关键字。无需使用 trim 标签中的 where 和 set 子标签来消除多余的空格和逗号。</p>\n<h2 id=\"foreach-完整示例\"><a href=\"#foreach-完整示例\" class=\"headerlink\" title=\"foreach 完整示例\"></a>foreach 完整示例</h2><p>以下是一个使用 foreach 标签的完整示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;User&quot;&gt;\n  SELECT * FROM user\n  WHERE id IN\n  &lt;foreach item&#x3D;&quot;item&quot; collection&#x3D;&quot;ids&quot; open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;\n    #&#123;item&#125;\n  &lt;&#x2F;foreach&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个示例中，我们使用了 foreach 标签来迭代一个名为 ids 的集合，并将集合中的每个元素作为参数传递给 SQL 语句中的 IN 子句，从而实现了动态的 SQL 查询。<code>item</code> 是循环过程中的变量名，它表示集合中的当前元素。</p>\n<ul>\n<li><code>open</code> 属性定义循环开始时使用的字符串，以此例子为例，循环开始时会自动追加左括号 “(“，</li>\n<li><code>separator</code> 属性定义每个元素之间使用的分隔符，以此例子为例，将使用逗号 “,” 分隔元素。</li>\n<li><code>close</code> 属性定义循环结束时使用的字符串，以此例子为例，循环结束时会自动追加右括号 “)”。</li>\n</ul>\n<p>在 <code>foreach</code> 标签的内部，我们使用 <code>#&#123;item&#125;</code> 表示集合中的当前元素。这个元素将被插入到 SQL 查询中的 IN 子句中，生成最终的查询语句。</p>\n<p>注意，这里 <code>resultType</code> 属性的值是 <code>User</code>，表示查询的结果将被映射为一个 <code>User</code> 对象。这意味着你需要在代码中定义一个 <code>User</code> 类来接收查询结果。具体的 <code>User</code> 类定义可以在 <code>resultType</code> 指定的类中实现。</p>\n<h2 id=\"trim-where-set-示例\"><a href=\"#trim-where-set-示例\" class=\"headerlink\" title=\"trim (where, set) 示例\"></a>trim (where, set) 示例</h2><p><code>&lt;trim&gt;</code> 标签可用于在生成动态 SQL 语句时去除多余的 SQL 代码，它支持的属性有 <code>prefix</code>、<code>suffix</code>、<code>prefixOverrides</code>、<code>suffixOverrides</code>，其中 <code>prefix</code> 和 <code>suffix</code> 属性可以在去除多余代码后自动添加前缀和后缀。</p>\n<p>以下是一个使用 <code>&lt;trim&gt;</code> 标签的示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n  UPDATE user\n  &lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot;&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;password !&#x3D; null&quot;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null&quot;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;phone !&#x3D; null&quot;&gt;phone&#x3D;#&#123;phone&#125;&lt;&#x2F;if&gt;\n  &lt;&#x2F;trim&gt;\n  WHERE id&#x3D;#&#123;id&#125;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>在这个示例中，我们使用了 <code>&lt;trim&gt;</code> 标签来去除 SQL 语句中多余的逗号。其中，<code>prefix</code> 属性为 SET，表示在 SQL 语句中 SET 关键字前添加 SET 字符串，<code>suffixOverrides</code> 属性为逗号，表示去掉 SQL 语句中最后一个逗号。</p>\n<p>在 <code>&lt;trim&gt;</code> 标签的内部，我们使用了 <code>&lt;if&gt;</code> 标签来判断需要更新的属性是否为 null，如果不为 null，则使用对应的 SQL 代码更新该属性。其中，<code>test</code> 属性的值为判断条件，表示当前属性是否为 null。</p>\n<p>需要注意的是，这里的 <code>parameterType</code> 属性的值是 <code>User</code>，表示传递给 SQL 语句的参数为一个 <code>User</code> 对象。因此，在代码中需要定义一个 <code>User</code> 类来接收参数。具体的 <code>User</code> 类定义可以在 <code>parameterType</code> 指定的类中实现。</p>\n<h2 id=\"where-标签、set-标签示例\"><a href=\"#where-标签、set-标签示例\" class=\"headerlink\" title=\"where 标签、set 标签示例\"></a>where 标签、set 标签示例</h2><p><code>&lt;where&gt;</code> 标签和 <code>&lt;set&gt;</code> 标签都是 MyBatis 中用于生成动态 SQL 语句的标签。</p>\n<p><code>&lt;where&gt;</code> 标签可以用于去除 SQL 语句中多余的 WHERE 关键字，并根据条件生成 WHERE 子句。以下是一个使用 <code>&lt;where&gt;</code> 标签的示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;User&quot;&gt;\n  SELECT * FROM user\n  &lt;where&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null and username !&#x3D; &#39;&#39;&quot;&gt;\n      AND username&#x3D;#&#123;username&#125;\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null and email !&#x3D; &#39;&#39;&quot;&gt;\n      AND email&#x3D;#&#123;email&#125;\n    &lt;&#x2F;if&gt;\n  &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;</code></pre>\n\n<p>在这个示例中，我们使用了 <code>&lt;where&gt;</code> 标签来根据条件生成 WHERE 子句，并去除 SQL 语句中多余的 WHERE 关键字。其中，<code>&lt;if&gt;</code> 标签用于判断条件是否成立。</p>\n<p><code>&lt;set&gt;</code> 标签可以用于生成动态 SQL 语句中的 SET 子句。以下是一个使用 <code>&lt;set&gt;</code> 标签的示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n  UPDATE user\n  &lt;set&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;password !&#x3D; null&quot;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null&quot;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;phone !&#x3D; null&quot;&gt;phone&#x3D;#&#123;phone&#125;&lt;&#x2F;if&gt;\n  &lt;&#x2F;set&gt;\n  WHERE id&#x3D;#&#123;id&#125;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>在这个示例中，我们使用了 <code>&lt;set&gt;</code> 标签来生成 UPDATE 语句中的 SET 子句，并根据条件生成需要更新的属性。其中，<code>&lt;if&gt;</code> 标签用于判断条件是否成立。需要注意的是，最后一个属性后面不需要添加逗号。</p>\n<h2 id=\"上面代码用-trim-重写\"><a href=\"#上面代码用-trim-重写\" class=\"headerlink\" title=\"上面代码用 trim 重写\"></a>上面代码用 trim 重写</h2><p>除了 <code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 标签之外，MyBatis 还提供了 <code>&lt;trim&gt;</code> 标签用于生成动态 SQL 语句中的各种修饰子句，包括 SELECT、FROM、WHERE、SET 等。</p>\n<p>以下是将上面的示例代码使用 <code>&lt;trim&gt;</code> 标签重写的示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;User&quot;&gt;\n  SELECT * FROM user\n  &lt;trim prefix&#x3D;&quot;WHERE&quot; prefixOverrides&#x3D;&quot;AND |OR &quot;&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null and username !&#x3D; &#39;&#39;&quot;&gt;\n      AND username&#x3D;#&#123;username&#125;\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null and email !&#x3D; &#39;&#39;&quot;&gt;\n      AND email&#x3D;#&#123;email&#125;\n    &lt;&#x2F;if&gt;\n  &lt;&#x2F;trim&gt;\n&lt;&#x2F;select&gt;\n\n&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n  UPDATE user\n  &lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot;&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;password !&#x3D; null&quot;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null&quot;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;phone !&#x3D; null&quot;&gt;phone&#x3D;#&#123;phone&#125;&lt;&#x2F;if&gt;\n  &lt;&#x2F;trim&gt;\n  WHERE id&#x3D;#&#123;id&#125;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>在这个示例中，我们使用了 <code>&lt;trim&gt;</code> 标签来去除 SQL 语句中多余的关键字，并根据条件生成修饰子句。其中，<code>prefix</code> 属性用于设置修饰子句的前缀，<code>suffix</code> 属性用于设置修饰子句的后缀，<code>prefixOverrides</code> 和 <code>suffixOverrides</code> 属性用于设置需要去除的关键字。</p>\n<p>需要注意的是，<code>&lt;trim&gt;</code> 标签的 <code>prefixOverrides</code> 和 <code>suffixOverrides</code> 属性的值需要用管道符号（|）分隔多个关键字，而且非最后一个关键字后面也需要添加一个空格。</p>\n<h2 id=\"最后一个关键字后面也需要添加一个空格？怎么看上去是非最后一个要加空格呢？\"><a href=\"#最后一个关键字后面也需要添加一个空格？怎么看上去是非最后一个要加空格呢？\" class=\"headerlink\" title=\"最后一个关键字后面也需要添加一个空格？怎么看上去是非最后一个要加空格呢？\"></a>最后一个关键字后面也需要添加一个空格？怎么看上去是非最后一个要加空格呢？</h2><p>抱歉，我的回答有误。在 <code>&lt;trim&gt;</code> 标签的 <code>prefixOverrides</code> 和 <code>suffixOverrides</code> 属性中，应该在每个关键字后面加上一个空格，但对于最后一个关键字，不需要加上空格。</p>\n<p>因此，在上面的示例代码中，<code>prefixOverrides</code> 和 <code>suffixOverrides</code> 属性应该改为：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;trim prefix&#x3D;&quot;WHERE&quot; prefixOverrides&#x3D;&quot;AND | OR&quot;&gt;\n  ...\n&lt;&#x2F;trim&gt;\n\n&lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot;&gt;\n  ...\n&lt;&#x2F;trim&gt;</code></pre>\n\n<p>这样就可以正确地去除 SQL 语句中多余的关键字了。非常抱歉给您带来困惑。</p>\n<h2 id=\"用-和-标签改写\"><a href=\"#用-和-标签改写\" class=\"headerlink\" title=\"用  和  标签改写\"></a>用 <where> 和 <set> 标签改写</h2><p>下面是使用 <code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 标签改写后的代码：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;User&quot;&gt;\n  SELECT * FROM user\n  &lt;where&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null and username !&#x3D; &#39;&#39;&quot;&gt;\n      AND username&#x3D;#&#123;username&#125;\n    &lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null and email !&#x3D; &#39;&#39;&quot;&gt;\n      AND email&#x3D;#&#123;email&#125;\n    &lt;&#x2F;if&gt;\n  &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;\n\n&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt;\n  UPDATE user\n  &lt;set&gt;\n    &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt;username&#x3D;#&#123;username&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;password !&#x3D; null&quot;&gt;password&#x3D;#&#123;password&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;email !&#x3D; null&quot;&gt;email&#x3D;#&#123;email&#125;,&lt;&#x2F;if&gt;\n    &lt;if test&#x3D;&quot;phone !&#x3D; null&quot;&gt;phone&#x3D;#&#123;phone&#125;&lt;&#x2F;if&gt;\n  &lt;&#x2F;set&gt;\n  WHERE id&#x3D;#&#123;id&#125;\n&lt;&#x2F;update&gt;</code></pre>\n\n<p>可以看到，在 <code>&lt;where&gt;</code> 标签中，我们只需要把所有的 <code>&lt;if&gt;</code> 标签放入其中即可，不需要设置 <code>prefix</code> 或 <code>suffixOverrides</code> 属性。同理，在 <code>&lt;set&gt;</code> 标签中，我们也只需要把所有的 <code>&lt;if&gt;</code> 标签放入其中即可。</p>\n<p>使用 <code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 标签可以更加清晰地表达 SQL 语句的含义，并且可以让 SQL 语句更加易于阅读和维护。</p>\n<h1 id=\"java-语法\"><a href=\"#java-语法\" class=\"headerlink\" title=\"java 语法\"></a>java 语法</h1><h2 id=\"语言特点\"><a href=\"#语言特点\" class=\"headerlink\" title=\"语言特点\"></a>语言特点</h2><p><strong>Java 语言是简单的：</strong></p>\n<p>Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。</p>\n<p><strong>Java 语言是面向对象的：</strong></p>\n<p>Java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。Java 语言全面支持动态绑定，而 C++语言只对虚函数使用动态绑定。总之，Java 语言是一个纯的面向对象程序设计语言。</p>\n<p><strong>Java 语言是多线程的：</strong></p>\n<p>在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable) 的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）</p>\n<p>当然特点有很多，关注点就三个，“简单”不畏惧，“面向对象”组织方式，“多线程”并发</p>\n<h2 id=\"语法结构\"><a href=\"#语法结构\" class=\"headerlink\" title=\"语法结构\"></a>语法结构</h2><img src=\"http://t-blog-images.aijs.top/img/202305281648221.webp\" />\n\n<h2 id=\"Java-标识符\"><a href=\"#Java-标识符\" class=\"headerlink\" title=\"Java 标识符\"></a>Java 标识符</h2><p>类名、变量名以及方法名都被称为标识符</p>\n<h2 id=\"Java-修饰符\"><a href=\"#Java-修饰符\" class=\"headerlink\" title=\"Java 修饰符\"></a>Java 修饰符</h2><p>像其他语言一样，Java 可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>\n<p>访问控制修饰符 : default, public , protected, private<br>非访问控制修饰符 : final, abstract, static, synchronized</p>\n<h2 id=\"Java-变量\"><a href=\"#Java-变量\" class=\"headerlink\" title=\"Java 变量\"></a>Java 变量</h2><ol>\n<li>局部变量</li>\n<li>类变量（静态变量）</li>\n<li>成员变量（非静态变量）</li>\n</ol>\n<h1 id=\"访问控制\"><a href=\"#访问控制\" class=\"headerlink\" title=\"访问控制\"></a>访问控制</h1><ol>\n<li>什么是访问控制</li>\n<li>为什么需要访问控制</li>\n<li>解决了什么问题</li>\n<li>为什么其他语言没有访问控制</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202305302042876.webp\" />\n\n<p>在面向对象编程（Object-Oriented Programming, OOP）中，访问控制修饰符用于控制类的成员变量和方法的访问权限。Java 和 C++是两种常用的面向对象编程语言，都支持以下四种访问控制修饰符：</p>\n<ol>\n<li><p>public：公共访问修饰符，被声明为 public 的成员变量和方法可以被任何类中的对象访问。</p>\n</li>\n<li><p>protected：受保护的访问修饰符，被声明为 protected 的成员变量和方法可以被同一包内的类和子类访问。实际应用中，该修饰符较少使用。</p>\n</li>\n<li><p>default（也称为 package-private）：默认访问修饰符，没有修饰符的成员变量和方法被默认为 default，只能被同一包内的类访问。</p>\n</li>\n<li><p>private：私有访问修饰符，被声明为 private 的成员变量和方法只能被所属类的对象访问。其他类的对象不能直接访问这些成员变量和方法。<strong>私有访问修饰符用于隐藏类的实现细节，提高程序的安全性和可维护性。</strong></p>\n</li>\n</ol>\n<h2 id=\"为什么需要访问控制，解决了什么问题\"><a href=\"#为什么需要访问控制，解决了什么问题\" class=\"headerlink\" title=\"为什么需要访问控制，解决了什么问题\"></a>为什么需要访问控制，解决了什么问题</h2><p>访问控制（Access Control）是面向对象编程中一个重要的概念，主要用于控制类的成员变量和方法的访问权限。访问控制可以解决以下问题：</p>\n<ol>\n<li><p><code>安全性问题</code>：访问控制可以防止不合法的访问或者修改对象的状态。通过限制访问权限，可以避免程序中出现潜在的安全漏洞，提高程序的安全性。</p>\n</li>\n<li><p><code>封装性问题</code>：封装性是面向对象编程的一个重要特性，可以隐藏对象的状态和行为。访问控制可以帮助开发人员实现封装性，避免对象的状态被不合法的访问或者修改。</p>\n</li>\n<li><p><code>维护性问题</code>：在大型的程序中，往往需要多人协同开发。访问控制可以帮助开发人员清晰地定义类的接口，避免不同开发人员之间的代码冲突，提高程序的可维护性。</p>\n</li>\n<li><p><code>代码复用问题</code>：访问控制可以控制类的成员变量和方法的访问权限，使得代码的复用更加灵活。通过定义不同的访问权限，可以使得类的成员变量和方法在不同的场景下被重用，提高代码的复用性。</p>\n</li>\n</ol>\n<p>综上所述，访问控制是面向对象编程中一个非常重要的概念，可以帮助开发人员实现程序的安全性、封装性、可维护性和代码复用性。</p>\n<h2 id=\"私有访问修饰符-private\"><a href=\"#私有访问修饰符-private\" class=\"headerlink\" title=\"私有访问修饰符-private\"></a>私有访问修饰符-private</h2><p>私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p>\n<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p>\n<p>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>\n<h2 id=\"公有访问修饰符-public\"><a href=\"#公有访问修饰符-public\" class=\"headerlink\" title=\"公有访问修饰符-public\"></a>公有访问修饰符-public</h2><p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p>\n<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>\n<h2 id=\"受保护的访问修饰符-protected\"><a href=\"#受保护的访问修饰符-protected\" class=\"headerlink\" title=\"受保护的访问修饰符-protected\"></a>受保护的访问修饰符-protected</h2><ol>\n<li>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>\n<li>子类与基类不在同一包中：那么在子类中，<code>子类实例</code>可以访问其从基类继承而来的 protected 方法，而不能访问<code>基类实例的protected方法</code>。</li>\n<li>protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。</li>\n<li><code>接口及接口的成员变量和成员方法不能声明为 protected</code></li>\n</ol>\n<h2 id=\"访问控制修饰符-很难掌握\"><a href=\"#访问控制修饰符-很难掌握\" class=\"headerlink\" title=\"访问控制修饰符 很难掌握\"></a>访问控制修饰符 很难掌握</h2><p>访问控制修饰符是面向对象编程中一个基础的概念，包括 public、protected 和 private 三种修饰符。它们的作用是控制类的成员变量和方法的访问权限，从而实现面向对象编程的封装性。</p>\n<p>虽然初学者可能会感到这些修饰符有些难以掌握，但是只需要理解它们的基本原理和使用场景，就可以轻松掌握它们的用法。下面是对这些修饰符的简单介绍：</p>\n<ul>\n<li>public：公有的，可以被任意访问。一般用于对外公开的成员变量和方法。</li>\n<li>protected：受保护的，只能被当前类和子类访问。一般用于类的内部或者子类中的成员变量和方法。</li>\n<li>private：私有的，只能在当前类中访问。一般用于类的内部的成员变量和方法。</li>\n</ul>\n<p>需要注意的是，每种修饰符都有不同的使用场景。一般来说，我们应该尽可能地将成员变量和方法的访问权限设置为 private 或 protected，以实现类的封装性。只有在需要对外公开的情况下，才使用 public 修饰符。</p>\n<p>另外，需要注意的是，访问控制修饰符只能限制对成员变量和方法的直接访问，而不能限制对对象的间接访问。例如，可以通过类的公有方法来修改类的私有成员变量，因此在使用访问控制修饰符时，应该结合其他技术手段来增强程序的安全性。</p>\n<h2 id=\"在使用访问控制修饰符时，应该结合其他技术手段来增强程序的安全性？\"><a href=\"#在使用访问控制修饰符时，应该结合其他技术手段来增强程序的安全性？\" class=\"headerlink\" title=\"在使用访问控制修饰符时，应该结合其他技术手段来增强程序的安全性？\"></a>在使用访问控制修饰符时，应该结合其他技术手段来增强程序的安全性？</h2><p>是的，访问控制修饰符虽然可以控制类的成员变量和方法的访问权限，但并不能完全保证程序的安全性。因此，在使用访问控制修饰符时，我们应该结合其他技术手段来增强程序的安全性，以下是一些常用的技术手段：</p>\n<ol>\n<li><p>封装性：访问控制修饰符是实现封装性的基础，通过将类的成员变量和方法设置为 private 或 protected，可以使得类的实现细节对外部程序不可见，从而增强程序的安全性。</p>\n</li>\n<li><p>接口设计：合理的接口设计可以将类的使用者和实现者隔离开来，从而降低程序的耦合度。使用者只需要了解接口的使用方法，而无需了解具体的实现细节，这样可以有效地提高程序的安全性。</p>\n</li>\n<li><p>异常处理：在程序中，可能会出现一些意外情况，例如空指针引用、数组越界等等。为了增强程序的安全性，我们应该对这些异常情况进行处理，例如使用 try-catch 语句捕获异常，或者使用断言等方法检查输入参数的合法性。</p>\n</li>\n<li><p>安全编程规范：编写安全的代码需要遵循一定的编程规范，例如不要使用不安全的函数、不要在程序中硬编码密码、不要使用不安全的网络协议等等。遵循这些规范可以有效地防止程序受到攻击。</p>\n</li>\n</ol>\n<p>综上所述，访问控制修饰符只是实现程序安全的一种手段，我们还需要结合其他技术手段来增强程序的安全性。</p>\n<h2 id=\"接口及接口的成员变量和成员方法不能声明为-protected-怎么理解\"><a href=\"#接口及接口的成员变量和成员方法不能声明为-protected-怎么理解\" class=\"headerlink\" title=\"接口及接口的成员变量和成员方法不能声明为 protected 怎么理解\"></a>接口及接口的成员变量和成员方法不能声明为 protected 怎么理解</h2><p>在 Java 中，<strong>接口是一种特殊的抽象类</strong>，它<strong>只包含常量和抽象方法的定义</strong>，<strong>并且所有的方法都是公共的</strong>。因此，接口及接口的成员变量和成员方法不能声明为 protected。</p>\n<p>这是因为接口的作用是定义某一类对象应该具有的方法，而不关心其具体实现。接口的所有方法都是公共的，可以被实现该接口的类所调用。因此，接口成员不能声明为 protected，因为这会限制实现该接口的类的访问权限，从而破坏了接口的定义。</p>\n<p>此外，接口中的成员变量都是 public static final 的常量，因此也不能声明为 protected。而成员方法中的访问控制修饰符只能是 public 或默认的，不能是 protected 或 private。</p>\n<p>因此，接口及接口的成员变量和成员方法不能声明为 protected，这是 Java 语言设计的一部分。如果希望限制接口中方法的访问权限，可以使用默认访问修饰符（即不写访问修饰符），这样该方法就只能在同一个包内被访问。</p>\n<h2 id=\"default-和-protected-哪个限制更严格\"><a href=\"#default-和-protected-哪个限制更严格\" class=\"headerlink\" title=\"default 和 protected 哪个限制更严格\"></a>default 和 protected 哪个限制更严格</h2><p>在 Java 中，default 和 protected 是两种访问修饰符，用于限制类、接口、成员变量和成员方法的访问权限。其中，</p>\n<ul>\n<li>default 访问修饰符也称为包访问权限，表示<strong>只有在同一包中的其他类</strong>才能访问该变量或方法；</li>\n<li>而 protected 访问修饰符表示<strong>只有在同一包中或者该类的子类</strong>才能访问该变量或方法。</li>\n</ul>\n<p>从访问权限来看，protected 比 default 更严格，因为 protected 修饰的变量或方法只有在同一包中或者该类的子类中才能访问，而 default 修饰的变量或方法则可以在同一包中的任何类中访问。这意味着，</p>\n<ul>\n<li>如果一个类的成员变量或方法只想被该类及其子类所访问，那么应该使用 protected 修饰符；</li>\n<li>如果一个类的成员变量或方法想要在同一包中的其他类中访问，那么应该使用 default 修饰符。</li>\n</ul>\n<p>需要注意的是，在不同的应用场景下，default 和 protected 的使用会有所不同。比如，在面向对象编程中，为了保护类的内部状态，通常会将成员变量声明为 private，而将成员方法声明为 public 或 protected，以便子类可以访问。在此情况下，protected 就比 default 更严格，因为它只能被子类所访问，而 default 则会暴露更多的实现细节，从而增加了代码的耦合度。</p>\n<h2 id=\"访问控制和继承-【能升不能降】\"><a href=\"#访问控制和继承-【能升不能降】\" class=\"headerlink\" title=\"访问控制和继承 【能升不能降】\"></a>访问控制和继承 【能升不能降】</h2><p>请注意以下方法继承的规则：</p>\n<p>父类中声明为 public 的方法在子类中也必须为 public。</p>\n<p>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</p>\n<p>父类中声明为 private 的方法，不能够被子类继承。</p>\n<h2 id=\"如何理解？\"><a href=\"#如何理解？\" class=\"headerlink\" title=\"如何理解？\"></a>如何理解？</h2><p>上述规则是 Java 中方法继承的基本规则，可以通过以下方式理解：</p>\n<ol>\n<li>父类中声明为 public 的方法在子类中也必须为 public。</li>\n</ol>\n<p>这意味着，如果父类中的某个方法是公共的，那么子类重写该方法时也必须将其声明为公共的。因为公共的方法可以被任何类访问，如果子类将其访问权限降低，就会破坏原有的代码结构，从而导致系统的不稳定。</p>\n<ol start=\"2\">\n<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>\n</ol>\n<p>当父类中的某个方法被声明为 protected 时，子类可以继承该方法。由于 protected 方法的访问权限比公共方法低，因此，子类可以在保持原有访问权限的同时，对该方法进行重写。但是，由于 private 方法的访问权限更低，因此，子类无法继承该方法。</p>\n<ol start=\"3\">\n<li>父类中声明为 private 的方法，不能够被子类继承。</li>\n</ol>\n<p>这是因为，私有方法的访问权限最低，只能在当前类中被访问，而子类与父类之间是存在继承关系的，子类无法直接访问父类的私有方法。此外，由于 private 方法无法被继承，因此子类也无法重写该方法，从而导致无法扩展该方法的功能。</p>\n<h2 id=\"子类比父类更具体，子类的访问权限更低，看上去很合理-【误区】\"><a href=\"#子类比父类更具体，子类的访问权限更低，看上去很合理-【误区】\" class=\"headerlink\" title=\"子类比父类更具体，子类的访问权限更低，看上去很合理 【误区】\"></a>子类比父类更具体，子类的访问权限更低，看上去很合理 【误区】</h2><p>子类比父类更具体这一点是正确的，因为子类是基于父类的基础上进行扩展和修改的，因此子类应该比父类更具体。但是，子类的访问权限更低并不一定是合理的。具体而言，如果在子类中将父类中声明为 public 的方法的访问权限降低为 private 或 protected，那么这可能会破坏原有的代码结构，从而导致系统的不稳定。在子类中，应该尽可能保留父类中方法的访问权限，以确保子类能够正确地继承和扩展父类的功能。当然，在某些情况下，将父类的方法的访问权限降低也是可以接受的，但这通常是在子类需要完全重写父类中的方法时才需要这样做。因此，我们应该根据具体情况来决定是否需要将子类中的访问权限降低。</p>\n<h1 id=\"抽象类和接口的区别\"><a href=\"#抽象类和接口的区别\" class=\"headerlink\" title=\"抽象类和接口的区别\"></a>抽象类和接口的区别</h1><p>抽象类和接口是 Java 中两个常用的概念，它们都可以用于实现多态，但是它们之间有几个重要的区别：</p>\n<ol>\n<li><p><code>实现方式</code>：抽象类是一个类，它可以拥有成员变量和非抽象方法，而接口是一个纯粹的抽象定义，它只能拥有常量和抽象方法。</p>\n</li>\n<li><p><code>实现数量</code>：一个类只能继承一个抽象类，而一个类可以实现多个接口。这是因为 Java 只支持单继承，但是可以实现多个接口。</p>\n</li>\n<li><p><code>构造函数</code>：抽象类可以有构造函数，而接口没有构造函数。</p>\n</li>\n<li><p><code>方法实现</code>：抽象类中的抽象方法可以有实现，而接口中的所有方法都必须是抽象的，不能有实现。</p>\n</li>\n<li><p><code>访问修饰符</code>：抽象类中的成员变量和方法可以有 public、protected 和 private 等访问修饰符，而接口中的所有变量和方法都必须是 public 的。</p>\n</li>\n<li><p><code>设计用途</code>：抽象类通常用于构建类层次结构，通过继承实现代码的复用和扩展。而接口通常用于描述类之间的通用行为规范，通过实现接口来实现多态。</p>\n</li>\n</ol>\n<p>综上所述，抽象类和接口都是 Java 中实现多态的机制，但是它们的设计目的和实现方式有所不同，需要根据具体需求选择使用。</p>\n<ul>\n<li>如果需要构建类层次结构，可以使用抽象类；</li>\n<li>如果需要描述通用的行为规范，可以使用接口。</li>\n</ul>\n<h1 id=\"java-运算符-【同-js】\"><a href=\"#java-运算符-【同-js】\" class=\"headerlink\" title=\"java 运算符 【同 js】\"></a>java 运算符 【同 js】</h1><ol>\n<li>算术运算符</li>\n<li>关系运算符</li>\n<li>位运算符</li>\n<li>逻辑运算符</li>\n<li>赋值运算符</li>\n<li>其他运算符</li>\n</ol>\n<p>java 运算符，与 javascript 运算符使用方式相同</p>\n<h1 id=\"Java-循环结构-【同-js-有个注意点】\"><a href=\"#Java-循环结构-【同-js-有个注意点】\" class=\"headerlink\" title=\"Java 循环结构 【同 js,有个注意点】\"></a>Java 循环结构 【同 js,有个注意点】</h1><ol>\n<li>for, while 及 do…while</li>\n<li>break 关键字 continue 关键字</li>\n</ol>\n<p>以上同 javascript</p>\n<ol start=\"3\">\n<li>Java 增强 for 循环</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for(声明语句 : 表达式)\n&#123;\n   &#x2F;&#x2F;代码句子\n&#125;</code></pre>\n\n<h1 id=\"Java-条件语句【同-js】\"><a href=\"#Java-条件语句【同-js】\" class=\"headerlink\" title=\"Java 条件语句【同 js】\"></a>Java 条件语句【同 js】</h1><p>if…else</p>\n<h1 id=\"Java-switch-case-语句【同-js-case-规则可以理解更严格的-typescript】\"><a href=\"#Java-switch-case-语句【同-js-case-规则可以理解更严格的-typescript】\" class=\"headerlink\" title=\"Java switch case 语句【同 js, case 规则可以理解更严格的 typescript】\"></a>Java switch case 语句【同 js, case 规则可以理解更严格的 typescript】</h1><p><strong>switch case 语句有如下规则：</strong></p>\n<ol>\n<li><p>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</p>\n</li>\n<li><p>switch 语句可以拥有多个 case 语句。<strong>每个 case 后面跟一个要比较的值和冒号</strong>。</p>\n</li>\n<li><p>case 语句中的值的<strong>数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量</strong>。</p>\n</li>\n<li><p>当变量的值与 case 语句的值相等时，那么 <strong>case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</strong></p>\n</li>\n<li><p>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</p>\n</li>\n<li><p>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</p>\n</li>\n</ol>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><img src=\"http://t-blog-images.aijs.top/img/202305302237578.webp\" />\n\n<p>基本数据类型由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包</p>\n<p>这个和 js 基本数据类型也是一样</p>\n<h2 id=\"Java-Math-类\"><a href=\"#Java-Math-类\" class=\"headerlink\" title=\"Java Math 类\"></a>Java Math 类</h2><p>这个和 js 很像</p>\n<ul>\n<li>rint() 返回与参数最接近的整数。返回类型为 double。</li>\n<li>toRadians()将角度转换为弧度。</li>\n<li>random() 返回一个随机数</li>\n</ul>\n<h2 id=\"Java-Character-类\"><a href=\"#Java-Character-类\" class=\"headerlink\" title=\"Java Character 类\"></a>Java Character 类</h2><p>Character 类用于对单个字符进行操作。</p>\n<p>Character 类在对象中包装一个基本类型 char 的值</p>\n<ul>\n<li><strong>自动装箱</strong></li>\n</ul>\n<p>Java 中 Character 类是表示字符的数据类型，它提供了许多实用的方法，以下是一些常用的 Character 方法：</p>\n<ol>\n<li><p><code>charValue()</code>：返回此 Character 对象的 char 值。</p>\n</li>\n<li><p><code>compareTo(Character anotherChar)</code>：按照字符的 Unicode 值比较两个 Character 对象。</p>\n</li>\n<li><p><code>isLetter(char ch)</code>：判断指定的字符是否是字母。</p>\n</li>\n<li><p><code>isDigit(char ch)</code>：判断指定的字符是否是数字。</p>\n</li>\n<li><p><code>isWhitespace(char ch)</code>：判断指定的字符是否是空白字符。</p>\n</li>\n<li><p><code>isUpperCase(char ch)</code>：判断指定的字符是否是大写字母。</p>\n</li>\n<li><p><code>isLowerCase(char ch)</code>：判断指定的字符是否是小写字母。</p>\n</li>\n<li><p><code>toUpperCase(char ch)</code>：将指定的字符转换为大写字母。</p>\n</li>\n<li><p><code>toLowerCase(char ch)</code>：将指定的字符转换为小写字母。</p>\n</li>\n<li><p><code>toString()</code>：返回此 Character 的字符串表示形式。</p>\n</li>\n<li><p><code>valueOf(char c)</code>：返回一个 Character 对象，该对象表示指定的 char 值。</p>\n</li>\n</ol>\n<p>这些方法可以用于操作和判断字符类型，使程序更加方便和灵活。</p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nString s1 &#x3D; &quot;Runoob&quot;;              &#x2F;&#x2F; String 直接创建\nString s2 &#x3D; &quot;Runoob&quot;;              &#x2F;&#x2F; String 直接创建\nString s3 &#x3D; s1;                    &#x2F;&#x2F; 相同引用\nString s4 &#x3D; new String(&quot;Runoob&quot;);   &#x2F;&#x2F; String 对象创建\nString s5 &#x3D; new String(&quot;Runoob&quot;);   &#x2F;&#x2F; String 对象创建</code></pre>\n\n<p>当然可以，除了基本的字符串操作方法，我们还可以将 String 类的方法按照以下维度进行划分：</p>\n<ol>\n<li>大小写转换：toLowerCase()、toUpperCase()、toLowerCase(Locale locale)、toUpperCase(Locale locale)</li>\n<li>去除空格：trim()</li>\n<li>字符串比较：compareTo()、compareToIgnoreCase()、equals()、equalsIgnoreCase()</li>\n<li>字符串查找：indexOf()、lastIndexOf()、startsWith()、endsWith()、contains()</li>\n<li>字符串替换和格式化：replace()、replaceAll()、replaceFirst()、format()</li>\n<li>字符串截取和分割：substring()、split()</li>\n<li>字符串连接：concat()、join()</li>\n<li>字符串转换：getBytes()、valueOf()、toString()、intern()</li>\n<li>正则表达式操作：matches()</li>\n<li>字符串长度和容量：length()、capacity()</li>\n<li>Unicode 支持：codePointAt()、codePointBefore()、codePointCount()</li>\n<li>字符集操作：getBytes(Charset charset)、new String(byte[] bytes, Charset charset)</li>\n<li><strong>String 中 &#x3D;&#x3D; 比较引用地址是否相同，equals() 比较字符串的内容是否相同：</strong> <a href=\"https://www.runoob.com/java/java-string-equals.html#:~:text=%E4%BD%BF%E7%94%A8%20%3D%3D%20%E5%92%8C%20equals()%20%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82\" target=\"_blank\" >见</a></li>\n</ol>\n<p>根据不同的需要，选择合适的方法可以更加方便、高效地处理字符串。</p>\n<details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p>Java 中的 String 类是一个常用的类，它提供了许多实用的方法，以下是一些常用的 String 方法：</p>\n<ol>\n<li><p><code>length()</code>：返回字符串的长度。</p>\n</li>\n<li><p><code>charAt(int index)</code>：返回指定索引处的字符。</p>\n</li>\n<li><p><code>substring(int beginIndex, int endIndex)</code>：返回一个新的字符串，它是此字符串的一个子字符串。</p>\n</li>\n<li><p><code>indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现的索引。</p>\n</li>\n<li><p><code>lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最后一次出现的索引。</p>\n</li>\n<li><p><code>startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开始。</p>\n</li>\n<li><p><code>endsWith(String suffix)</code>：测试此字符串是否以指定的后缀结束。</p>\n</li>\n<li><p><code>replace(char oldChar, char newChar)</code>：用新字符替换字符串中的旧字符。</p>\n</li>\n<li><p><code>toUpperCase()</code>：将此字符串中的所有字符转换为大写。</p>\n</li>\n<li><p><code>toLowerCase()</code>：将此字符串中的所有字符转换为小写。</p>\n</li>\n<li><p><code>trim()</code>：返回去掉字符串两端空格的新字符串。</p>\n</li>\n<li><p><code>valueOf()</code>：将其他类型的值转换为字符串。</p>\n</li>\n</ol>\n<p>这些方法可以用于操作和处理字符串，使程序更加方便和灵活。除了上述的方法，String 类还提供了其他实用的方法，可以根据程序的需要进行选择和使用。</p>\n<p>看上去和 js 又是相同的</p>\n<h2 id=\"还有吗\"><a href=\"#还有吗\" class=\"headerlink\" title=\"还有吗\"></a>还有吗</h2><p>是的，除了上述提到的 String 方法，Java 中的 String 类还提供了其他一些常用的方法，包括：</p>\n<ol>\n<li><p><code>equals(Object object)</code>：比较此字符串与指定对象是否相等。</p>\n</li>\n<li><p><code>equalsIgnoreCase(String anotherString)</code>：比较此字符串与另一个字符串是否相等，忽略大小写。</p>\n</li>\n<li><p><code>getBytes(String charsetName)</code>：使用指定的字符集将此字符串编码为字节数组。</p>\n</li>\n<li><p><code>toCharArray()</code>：将此字符串转换为新的字符数组。</p>\n</li>\n<li><p><code>split(String regex)</code>：根据给定的正则表达式将此字符串拆分成字符串数组。</p>\n</li>\n<li><p><code>contains(CharSequence s)</code>：测试此字符串是否包含指定的字符序列。</p>\n</li>\n<li><p><code>isEmpty()</code>：判断此字符串是否为空。</p>\n</li>\n<li><p><code>subSequence(int beginIndex, int endIndex)</code>：返回一个新的字符序列，它是此字符串的一个子序列。</p>\n</li>\n<li><p><code>format(String format, Object... args)</code>：使用指定的格式字符串和参数返回一个格式化后的字符串。</p>\n</li>\n<li><p><code>join(CharSequence delimiter, CharSequence... elements)</code>：将多个字符串连接成一个字符串，以指定的分隔符分隔。</p>\n</li>\n</ol>\n<p>这些方法也是 String 类中常用的方法，可以根据实际需求选择并使用。</p>\n\n</details>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"HashSet、LinkedHashSet、TreeSet-使用场景\"><a href=\"#HashSet、LinkedHashSet、TreeSet-使用场景\" class=\"headerlink\" title=\"HashSet、LinkedHashSet、TreeSet 使用场景\"></a>HashSet、LinkedHashSet、TreeSet 使用场景</h3><ul>\n<li><p><code>HashSet</code> 适用于无序集合，查找、插入、删除速度均一。</p>\n</li>\n<li><p><code>LinkedHashSet</code> 适用于有序集合，保留元素插入的顺序，查找、插入、删除速度均一。</p>\n</li>\n<li><p><code>TreeSet</code> 适用于有序集合，自动按照元素大小排序，可以快速定位元素，但是比 <code>HashSet</code> 和 <code>LinkedHashSet</code> 效率略低，插入、查找、删除速度均较慢。<br>:::details</p>\n<ul>\n<li><code>HashSet</code> 适用于需要快速检索元素，且元素顺序不重要的场景。<code>HashSet</code> 内部使用哈希表实现，插入、查找、删除等操作的时间复杂度都是 O(1)。但是，元素在哈希表中的存储位置是随机的，因此 <code>HashSet</code> 的元素顺序是不确定的。</li>\n<li><code>LinkedHashSet</code> 适用于需要按照插入顺序访问元素的场景。<code>LinkedHashSet</code> 内部使用哈希表实现，但同时维护了一个双向链表，用于维护插入顺序。因此，<code>LinkedHashSet</code> 的元素顺序是按照插入顺序确定的。插入、查找、删除操作的时间复杂度都是 O(1)。</li>\n<li><code>TreeSet</code> 适用于需要对元素进行排序，或者需要在一定范围内快速查找元素的场景。<code>TreeSet</code> 内部使用红黑树实现，可以自动对元素进行排序，插入、查找、删除操作的时间复杂度是 O(logN)。<code>TreeSet</code> 还提供了一些方法，比如可以快速得到最大值、最小值以及在某个范围内的元素。由于底层实现是红黑树，因此 <code>TreeSet</code> 的元素顺序是确定的。<br>:::</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"HashMap-、TreeMap、LinkedHashMap-各自的使用场景\"><a href=\"#HashMap-、TreeMap、LinkedHashMap-各自的使用场景\" class=\"headerlink\" title=\"HashMap 、TreeMap、LinkedHashMap 各自的使用场景\"></a>HashMap 、TreeMap、LinkedHashMap 各自的使用场景</h3><ul>\n<li><code>HashMap</code> 适用于对数据顺序没有严格要求、插入与查找效率都很高的场景。</li>\n<li><code>TreeMap</code> 适用于需要对键进行排序或快速找到单个元素的场景。</li>\n<li><code>LinkedHashMap</code> 适用于需要访问数据顺序以及快速访问数据的场景。</li>\n</ul>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><p><code>HashMap</code>、<code>TreeMap</code> 和 <code>LinkedHashMap</code> 都属于 Java 中的 <code>Map</code> 接口的具体实现，它们虽然都可以实现键值对映射，但在具体的场景下，使用不同的实现会更加合适。</p>\n<p>以下是各自的使用场景：</p>\n<ol>\n<li><code>HashMap</code></li>\n</ol>\n<p><code>HashMap</code> 是基于哈希表实现的，它的存储和查找效率很高，在键值对随机分布和快速访问的场景下表现优异。在对数据的顺序没有严格要求的情况下，使用 <code>HashMap</code> 可以获得很好的性能。例如，对于无序的数据，使用 <code>HashMap</code> 可以更快速地进行查找和插入操作。</p>\n<ol start=\"2\">\n<li><code>TreeMap</code></li>\n</ol>\n<p><code>TreeMap</code> 是基于红黑树实现的，它可以对键值对进行排序存储，因此在对数据需要排序或者需要快速找到单个元素的情况下，使用 <code>TreeMap</code> 是比较合适的。例如，在区间查找、排序、去重等场景中，使用 <code>TreeMap</code> 可以获得更好的效率。</p>\n<ol start=\"3\">\n<li><code>LinkedHashMap</code></li>\n</ol>\n<p><code>LinkedHashMap</code> 是既可以访问数据快速又可以保持插入顺序的实现。在迭代访问数据时，使用 <code>LinkedHashMap</code> 可以获得更好的性能。例如，在 LRU 缓存实现中，使用 <code>LinkedHashMap</code> 可以方便地维护缓存访问顺序。</p>\n</p>\n</details>\n","text":"文章结构跟着兴趣走而不是顺序 输入校验validating-form-input 如何校验 如何处理检验不通过的信息 “Validating Form” 是指对表单数据进行验证以确保其符合特定规则或要求的过程。在 Web 应用程序中，表单通常用于收集用户输入的数据，例如注册表格、...","link":"","photos":[],"count_time":{"symbolsCount":"118k","symbolsTime":"1:48"},"categories":[{"name":"java","slug":"java","count":1,"path":"api/categories/java.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%87%E7%AB%A0%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">文章结构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%A1%E9%AA%8C\"><span class=\"toc-text\">输入校验</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">注解有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Validating-Form-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">Validating Form 有哪些注解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Positive\"><span class=\"toc-text\">@Positive</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Null\"><span class=\"toc-text\">@Null</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NotNull\"><span class=\"toc-text\">@NotNull</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AssertTrue\"><span class=\"toc-text\">@AssertTrue</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AssertFalse\"><span class=\"toc-text\">@AssertFalse</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Min-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">@Min 注解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">示例代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#restfull\"><span class=\"toc-text\">restfull</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RESTful-%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">RESTful 风格的注解有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B-%E4%B8%8D%E5%A4%AA%E5%8F%8B%E5%A5%BD%E5%95%8A\"><span class=\"toc-text\">每个提供一个请求示例 不太友好啊</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E8%AF%A6%E7%BB%86\"><span class=\"toc-text\">更详细</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF-fetch\"><span class=\"toc-text\">前端 fetch</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PathParam-%E5%92%8C-QueryParam-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@PathParam 和 @QueryParam 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Path-%E4%B8%8E-FormParam-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@Path 与 @FormParam 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PathVariable-%E4%B8%8E-PathParam-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@PathVariable 与@PathParam 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#java-%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%98%AF%E4%B8%BA%E4%BA%86%E5%B9%B2%E5%98%9B%E7%94%A8%E7%9A%84\"><span class=\"toc-text\">java 中的类是为了干嘛用的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%B0%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">类就是一种自定义的数据类型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#swagger-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">swagger 如何使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#swagger-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">swagger 的注解有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA-swagger-%E6%B3%A8%E8%A7%A3%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">每个 swagger 注解提供一个示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#controller-%E5%B1%82%EF%BC%8Cspringboot-%E4%B8%8E-swagger-%E6%B3%A8%E8%A7%A3%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E6%80%8E%E4%B9%88%E5%86%99%E6%AF%94%E5%A6%82-QueryParam\"><span class=\"toc-text\">controller 层，springboot 与 swagger 注解同时使用怎么写比如@QueryParam</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E6%A0%B7%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%BE%88%E5%A4%9A%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8F\"><span class=\"toc-text\">这样看起来增加了很多的代码量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiImplicitParam\"><span class=\"toc-text\">@ApiImplicitParam</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2\"><span class=\"toc-text\">参考博客</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiImplicitParams\"><span class=\"toc-text\">@ApiImplicitParams</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiImplicitParams-%E5%92%8C-ApiImplicitParam-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@ApiImplicitParams 和 @ApiImplicitParam 注解的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiImplicitParams-%E5%92%8C-ApiImplicitParam-%E4%BD%BF%E5%BE%97-swagger-%E7%9A%84%E6%B3%A8%E8%A7%A3%E7%8B%AC%E7%AB%8B%E4%BA%8E-controller-%E6%96%B9%E6%B3%95%E4%BD%93%E5%86%85%EF%BC%9F\"><span class=\"toc-text\">@ApiImplicitParams 和 @ApiImplicitParam 使得 swagger 的注解独立于 controller 方法体内？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiParam-%E4%B8%8E-ApiImplicitParam-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@ApiParam 与 @ApiImplicitParam 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiOperation-%E4%B8%8E-Api-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@ApiOperation 与@Api 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiResponses-%E4%B8%8E-ApiResponse-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@ApiResponses 与 @ApiResponse 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApiModel-%E5%92%8C-ApiModelProperty-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">@ApiModel 和 @ApiModelProperty 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#controller-%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">controller 用自定义模型接收参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">返回值是模型的注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RequestBody-User-user-%E5%8A%A0-swagger-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">@RequestBody User user 加 swagger 注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dataType-%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA-User-%E9%87%8D%E5%A4%8D%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F\"><span class=\"toc-text\">dataType 会不会有两个 User 重复的情况？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%89%E4%BA%9B%E9%A1%B9%E7%9B%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E5%86%99%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%90%8E%E5%86%99-service\"><span class=\"toc-text\">有些项目为什么先写接口，后写 service?</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#service-controller\"><span class=\"toc-text\">service controller</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Service\"><span class=\"toc-text\">Service</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Controller\"><span class=\"toc-text\">Controller</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PathVariable-%E4%B8%8E-PathParam-%E7%9A%84%E5%8C%BA%E5%88%AB-1\"><span class=\"toc-text\">@PathVariable 与@PathParam 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#java-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">java 声明一个变量有哪些修饰符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%A1%8C%E4%B8%8D%E8%A1%8C\"><span class=\"toc-text\">不用修饰符行不行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%99%E4%B8%AA-CRUD-%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">写个 CRUD 的示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B8%AA-CURD-%E7%9A%84%E7%A4%BA%E4%BE%8B%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84-service-%E5%B1%82%E6%98%AF\"><span class=\"toc-text\">这个 CURD 的示例，对应的 service 层是</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%BA%94%E7%9A%84-controller-%E6%98%AF\"><span class=\"toc-text\">对应的 controller 是</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B8%AA-DAO-%E7%94%A8-mybatis-%E6%94%B9%E5%86%99%E4%B8%8B\"><span class=\"toc-text\">这个 DAO 用 mybatis 改写下</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sql-%E4%B8%8D%E6%98%AF%E5%9C%A8-xml-%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B9%A6%E5%86%99%E7%9A%84%E5%90%97\"><span class=\"toc-text\">sql 不是在 xml 文件中书写的吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UserMapper-xml-%E5%86%85%E5%AE%B9%E8%A7%A3%E9%87%8A%E4%B8%8B\"><span class=\"toc-text\">UserMapper.xml 内容解释下</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9AUserMapper-xml-%E6%98%AF%E5%AF%B9-com-example-mappers-UserMapper-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B9%8B%E5%89%8D%E6%98%AF%E5%9C%A8-java-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%86%99%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%8E%B0%E5%9C%A8%E4%B8%BA%E4%BA%86%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%92%8C%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%8C%E5%B0%86%E5%85%B6%E6%94%BE%E5%88%B0-xml-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">我可以这么理解：UserMapper.xml 是对 com.example.mappers.UserMapper 的接口实现，之前是在 java 文件中写的实现，现在为了维护性和灵活性，将其放到 xml 中进行实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#xml-%E4%B8%AD-id-%E5%AF%B9%E5%BA%94%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%9F\"><span class=\"toc-text\">xml 中 id 对应方法名？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A5%E5%8F%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C-xml-%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">入参是如何和 xml 进行绑定的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">如果参数是一个对象呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E7%94%A8-Param-%E6%B3%A8%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">对象不需要用@Param 注解？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mybatis-Param\"><span class=\"toc-text\">mybatis @Param</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Param-%E6%9C%89%E5%91%BD%E5%90%8D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">@Param 有命名的作用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mybatis-xml-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">mybatis xml 有哪些语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">1. 命名空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2. 参数类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3. 返回类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-SQL-%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">4. SQL 语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-SQL-%E7%89%87%E6%AE%B5\"><span class=\"toc-text\">5. SQL 片段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%8A%A8%E6%80%81-SQL\"><span class=\"toc-text\">6. 动态 SQL</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E6%A0%87%E7%AD%BE%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">每个标签的示例代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#suffixOverrides-suffix\"><span class=\"toc-text\">suffixOverrides suffix</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%81\"><span class=\"toc-text\">#{}、${}</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">#{}</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-1\"><span class=\"toc-text\">${}</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDBC-%E8%A6%81%E6%B1%82%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%88%97%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8-null-%E5%80%BC%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%80%BC%E4%B8%BA-null-%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BF%85%E9%A1%BB%E8%A6%81%E6%8C%87%E5%AE%9A-JDBC-%E7%B1%BB%E5%9E%8B%EF%BC%88jdbcType%EF%BC%89%E3%80%82\"><span class=\"toc-text\">JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2\"><span class=\"toc-text\">字符串替换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">结果映射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E5%85%A8%E5%90%8D\"><span class=\"toc-text\">类型全名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D\"><span class=\"toc-text\">类型别名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E5%88%97%E5%90%8D%E5%92%8C%E5%B1%9E%E6%80%A7%E5%90%8D%E4%B8%8D%E8%83%BD%E5%8C%B9%E9%85%8D%E4%B8%8A\"><span class=\"toc-text\">如果列名和属性名不能匹配上</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E7%9A%84-resultMap-%E4%BC%9A%E6%80%8E%E6%A0%B7\"><span class=\"toc-text\">显式使用外部的 resultMap 会怎样</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">高级结果映射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%EF%BC%88resultMap%EF%BC%89\"><span class=\"toc-text\">结果映射（resultMap）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#id-amp-result\"><span class=\"toc-text\">id &amp; result</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%AF%E6%8C%81%E7%9A%84-JDBC-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">支持的 JDBC 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94\"><span class=\"toc-text\">关联</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E7%9A%84%E5%B5%8C%E5%A5%97-Select-%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">关联的嵌套 Select 查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E7%9A%84%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-%E8%A7%A3%E5%86%B3-%E2%80%9C%E5%85%B3%E8%81%94%E7%9A%84%E5%B5%8C%E5%A5%97-Select%E2%80%9D-N-1-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">关联的嵌套结果映射 解决 “关联的嵌套 Select” N+1 问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E7%9A%84%E5%A4%9A%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%88ResultSet%EF%BC%89\"><span class=\"toc-text\">关联的多结果集（ResultSet）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88\"><span class=\"toc-text\">集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E7%9A%84%E5%B5%8C%E5%A5%97-Select-%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">集合的嵌套 Select 查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E7%9A%84%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">集合的嵌套结果映射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%9A%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%88ResultSet%EF%BC%89\"><span class=\"toc-text\">集合的多结果集（ResultSet）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%89%B4%E5%88%AB%E5%99%A8\"><span class=\"toc-text\">鉴别器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#mybatis-%E9%9B%86%E5%90%88-GPT\"><span class=\"toc-text\">mybatis 集合 GPT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81-SQL-%E8%AF%AD%E5%8F%A5%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E9%9B%86%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">需要注意的是，使用集合元素时，需要保证 SQL 语句返回的结果集是有序的 怎么理解？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mybatis-%E9%9B%86%E5%90%88%E7%9A%84%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">mybatis 集合的嵌套结果映射</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mybatis-%E9%9B%86%E5%90%88-%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E6%AD%A3%E5%90%91%E7%94%A8-collection%EF%BC%8C%E5%8F%8D%E5%90%91%E7%94%A8-association\"><span class=\"toc-text\">mybatis 集合 一对多，正向用 collection，反向用 association</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">对象结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%9A%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%88ResultSet%EF%BC%89-1\"><span class=\"toc-text\">集合的多结果集（ResultSet）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">这样设计有什么优点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%88%86%E5%BC%80%E5%8D%95%E4%B8%AA%E6%9F%A5%E8%AF%A2%E4%B8%8D%E4%B9%9F%E4%B8%80%E6%A0%B7%E5%90%97\"><span class=\"toc-text\">直接分开单个查询不也一样吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E6%87%82%EF%BC%8C%E5%86%99%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">不懂，写个完整示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90\"><span class=\"toc-text\">查询语句的结果是什么样子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E7%90%86%E8%A7%A3%EF%BC%9A-%E7%BB%93%E6%9E%9C%E9%9B%86%E6%98%A0%E5%B0%84%E7%90%86%E8%A7%A3%E4%B8%BA%EF%BC%8Csql-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%98%AF%E6%89%81%E5%B9%B3%E7%9A%84%EF%BC%8C%E7%BB%93%E6%9E%9C%E9%9B%86%E6%98%A0%E5%B0%84%E6%98%AF%E5%AF%B9%E6%95%B0%E6%8D%AE%E4%BA%8C%E6%AC%A1%E6%95%B4%E7%90%86%EF%BC%8C%E8%BD%AC%E5%8C%96%E6%88%90%E6%83%B3%E8%A6%81%E7%9A%84%E6%A0%B7%E5%AD%90\"><span class=\"toc-text\">我理解： 结果集映射理解为，sql 查询结果是扁平的，结果集映射是对数据二次整理，转化成想要的样子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%88%90%E5%8A%9F%E5%90%8E%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE%E7%9A%84-xml\"><span class=\"toc-text\">插入成功后返回主键的 xml</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">完整示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC\"><span class=\"toc-text\">1. 创建表格</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA-User-%E5%AE%9E%E4%BD%93%E7%B1%BB\"><span class=\"toc-text\">2. 创建 User 实体类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%88%9B%E5%BB%BA-MyBatis-Mapper-XML-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3. 创建 MyBatis Mapper XML 文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%88%9B%E5%BB%BA-MyBatis-Mapper-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4. 创建 MyBatis Mapper 接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%88%9B%E5%BB%BA-MyBatis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5. 创建 MyBatis 配置文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB\"><span class=\"toc-text\">6. 创建测试类</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81-SQL\"><span class=\"toc-text\">动态 SQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E9%99%A4-SQL-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%A4%9A%E4%BD%99%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%92%8C%E9%80%97%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">消除 SQL 语句中多余的空格和逗号的问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">查询语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">更新语句</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5%E4%B8%8D%E9%9C%80%E8%A6%81%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86%E5%90%97\"><span class=\"toc-text\">插入语句不需要特殊处理吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#foreach-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">foreach 完整示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#trim-where-set-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">trim (where, set) 示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#where-%E6%A0%87%E7%AD%BE%E3%80%81set-%E6%A0%87%E7%AD%BE%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">where 标签、set 标签示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%94%A8-trim-%E9%87%8D%E5%86%99\"><span class=\"toc-text\">上面代码用 trim 重写</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%8E%E9%9D%A2%E4%B9%9F%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%9F%E6%80%8E%E4%B9%88%E7%9C%8B%E4%B8%8A%E5%8E%BB%E6%98%AF%E9%9D%9E%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%A6%81%E5%8A%A0%E7%A9%BA%E6%A0%BC%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">最后一个关键字后面也需要添加一个空格？怎么看上去是非最后一个要加空格呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8-%E5%92%8C-%E6%A0%87%E7%AD%BE%E6%94%B9%E5%86%99\"><span class=\"toc-text\">用  和  标签改写</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#java-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">java 语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">语言特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">语法结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-%E6%A0%87%E8%AF%86%E7%AC%A6\"><span class=\"toc-text\">Java 标识符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">Java 修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">Java 变量</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">访问控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">为什么需要访问控制，解决了什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-private\"><span class=\"toc-text\">私有访问修饰符-private</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public\"><span class=\"toc-text\">公有访问修饰符-public</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-protected\"><span class=\"toc-text\">受保护的访问修饰符-protected</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6-%E5%BE%88%E9%9A%BE%E6%8E%8C%E6%8F%A1\"><span class=\"toc-text\">访问控制修饰符 很难掌握</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%BB%93%E5%90%88%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5%E6%9D%A5%E5%A2%9E%E5%BC%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">在使用访问控制修饰符时，应该结合其他技术手段来增强程序的安全性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%8F%8A%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA-protected-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">接口及接口的成员变量和成员方法不能声明为 protected 怎么理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#default-%E5%92%8C-protected-%E5%93%AA%E4%B8%AA%E9%99%90%E5%88%B6%E6%9B%B4%E4%B8%A5%E6%A0%BC\"><span class=\"toc-text\">default 和 protected 哪个限制更严格</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF-%E3%80%90%E8%83%BD%E5%8D%87%E4%B8%8D%E8%83%BD%E9%99%8D%E3%80%91\"><span class=\"toc-text\">访问控制和继承 【能升不能降】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">如何理解？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%90%E7%B1%BB%E6%AF%94%E7%88%B6%E7%B1%BB%E6%9B%B4%E5%85%B7%E4%BD%93%EF%BC%8C%E5%AD%90%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%9B%B4%E4%BD%8E%EF%BC%8C%E7%9C%8B%E4%B8%8A%E5%8E%BB%E5%BE%88%E5%90%88%E7%90%86-%E3%80%90%E8%AF%AF%E5%8C%BA%E3%80%91\"><span class=\"toc-text\">子类比父类更具体，子类的访问权限更低，看上去很合理 【误区】</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">抽象类和接口的区别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#java-%E8%BF%90%E7%AE%97%E7%AC%A6-%E3%80%90%E5%90%8C-js%E3%80%91\"><span class=\"toc-text\">java 运算符 【同 js】</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-%E3%80%90%E5%90%8C-js-%E6%9C%89%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9%E3%80%91\"><span class=\"toc-text\">Java 循环结构 【同 js,有个注意点】</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E3%80%90%E5%90%8C-js%E3%80%91\"><span class=\"toc-text\">Java 条件语句【同 js】</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-switch-case-%E8%AF%AD%E5%8F%A5%E3%80%90%E5%90%8C-js-case-%E8%A7%84%E5%88%99%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84-typescript%E3%80%91\"><span class=\"toc-text\">Java switch case 语句【同 js, case 规则可以理解更严格的 typescript】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">基本数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-Math-%E7%B1%BB\"><span class=\"toc-text\">Java Math 类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-Character-%E7%B1%BB\"><span class=\"toc-text\">Java Character 类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#String\"><span class=\"toc-text\">String</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%98%E6%9C%89%E5%90%97\"><span class=\"toc-text\">还有吗</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set\"><span class=\"toc-text\">Set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashSet%E3%80%81LinkedHashSet%E3%80%81TreeSet-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">HashSet、LinkedHashSet、TreeSet 使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap-%E3%80%81TreeMap%E3%80%81LinkedHashMap-%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">HashMap 、TreeMap、LinkedHashMap 各自的使用场景</span></a></li></ol></li></ol></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"py文件中字段提取","uid":"f16cfe223ad4d183c261ac932e97ed00","slug":"2023-05-26py","date":"2023-05-26T09:48:31.000Z","updated":"2023-05-29T00:41:07.270Z","comments":true,"path":"api/articles/2023-05-26py.json","keywords":null,"cover":null,"text":"背景项目中多语言一团糟，开发的正常，客户的 app 上没有多语言数据 要将项目中用到的多语言全部提取 去重 提取多语言，与内部 APP 多语言合并 合并项目中额外新增的部分 手动处理部分涉及业务逻辑的多语言 上传客户多语言平台，供客户修改 主要是提取 import os impo...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"python","slug":"python","count":1,"path":"api/categories/python.json"}],"tags":[{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"部署后，无法运行","uid":"16c06075633c447ebc480ad4e752e204","slug":"2023-05-18bug","date":"2023-05-18T03:03:01.000Z","updated":"2023-07-08T01:06:25.355Z","comments":true,"path":"api/articles/2023-05-18bug.json","keywords":null,"cover":[],"text":"日志2023-05-18T01:29:15.077Z ERROR next 63acefd419084df6 socrates &#123;&quot;stack&quot;:&quot;ReferenceError: Cannot access &#39;detail&#39;...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"next","slug":"next","count":1,"path":"api/categories/next.json"}],"tags":[{"name":"next","slug":"next","count":1,"path":"api/tags/next.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}