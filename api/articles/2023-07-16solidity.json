{"title":"Solidity","uid":"f708a9779c264010c95b53120252c787","slug":"2023-07-16solidity","date":"2023-07-16T02:13:49.000Z","updated":"2023-07-31T06:42:49.727Z","comments":true,"path":"api/articles/2023-07-16solidity.json","keywords":null,"cover":[],"content":"<h2 id=\"为什么搞了个-solidity-语言，golang-rust-不能满足需要吗\"><a href=\"#为什么搞了个-solidity-语言，golang-rust-不能满足需要吗\" class=\"headerlink\" title=\"为什么搞了个 solidity 语言，golang rust 不能满足需要吗\"></a>为什么搞了个 solidity 语言，golang rust 不能满足需要吗</h2><p>Solidity 是一种专门用于智能合约开发的编程语言，它在以太坊和其他以太坊兼容区块链平台上广泛使用。当开发者想要在以太坊平台上构建去中心化应用程序（DApps）或编写智能合约时，Solidity 是一种常见的选择。</p>\n<p>至于为什么选择使用 Solidity 而不是其他语言（如 Golang 或 Rust），有以下几个原因：</p>\n<ol>\n<li><p>生态系统支持：Solidity 在以太坊生态系统中得到广泛支持，有大量的开发工具、框架和库可供使用。这使得开发者能够更容易地构建、测试、部署和维护智能合约。</p>\n</li>\n<li><p>成熟度：Solidity 已经存在一段时间，并且经过了实际应用中的验证。它已经被广泛测试和审查，因此在安全性方面有一定的可靠性。</p>\n</li>\n<li><p>语言特性：Solidity 是专门为智能合约编写而设计的语言，它提供了一些特定的功能和模式，使得编写智能合约更加方便和直观。它具有与以太坊虚拟机（EVM）交互的内建函数和数据类型。</p>\n</li>\n</ol>\n<p>虽然 Golang 和 Rust 也是非常强大和适用于区块链开发的语言，但 Solidity 在智能合约领域有一些独特的优势和特点，因此被广泛应用于以太坊和其他以太坊兼容的区块链平台。选择使用哪种语言取决于具体的项目需求、平台支持和开发者的偏好。</p>\n<h2 id=\"Solidity-语法借鉴了哪些编程语言\"><a href=\"#Solidity-语法借鉴了哪些编程语言\" class=\"headerlink\" title=\"Solidity 语法借鉴了哪些编程语言\"></a>Solidity 语法借鉴了哪些编程语言</h2><p>Solidity 的语法借鉴了多种编程语言，包括以下几个主要的参考：</p>\n<ol>\n<li><p>JavaScript：Solidity 的语法结构和一些关键字与 JavaScript 相似。这使得熟悉 JavaScript 的开发者更容易上手 Solidity。</p>\n</li>\n<li><p>C++：Solidity 的语法和 C++有一些相似之处，例如使用大括号来定义代码块、使用分号作为语句结束符等。</p>\n</li>\n<li><p>Python：在 Solidity 中，一些语法特性借鉴了 Python，例如使用缩进来表示代码块、使用冒号来引入控制结构等。</p>\n</li>\n<li><p>Java：Solidity 的一些面向对象的概念和关键字与 Java 类似，例如类、继承、接口等。</p>\n</li>\n</ol>\n<p>尽管 Solidity 从这些编程语言中借鉴了一些语法特性，但它也有一些独有的特点，包括特定于智能合约的功能，如<strong>状态变量</strong>、事件等。因此，即使您熟悉其中一种语言，学习 Solidity 时还需要了解其独特的特性和概念。</p>\n<h2 id=\"状态变量？\"><a href=\"#状态变量？\" class=\"headerlink\" title=\"状态变量？\"></a>状态变量？</h2><p>在 Solidity 中，状态变量是用来存储和跟踪智能合约的状态信息的变量。它们是合约的一部分，被永久地存储在区块链上，并且可以在合约的不同函数之间共享和访问。</p>\n<p>状态变量可以是各种数据类型，如整数、布尔值、地址、字符串等。它们用于存储合约需要跟踪的数据，例如合约的状态、用户余额、记录等。</p>\n<p>状态变量的声明通常在合约的顶部，并且可以具有不同的可见性修饰符，如<code>public</code>、<code>private</code>、<code>internal</code>和<code>external</code>。这些修饰符决定了状态变量是否可以被合约内部或外部的其他部分访问。</p>\n<p>以下是一个示例，展示了 Solidity 中的状态变量的声明和使用：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    &#x2F;&#x2F; 公共状态变量\n    uint public myNumber;\n\n    &#x2F;&#x2F; 私有状态变量\n    string private myString;\n\n    &#x2F;&#x2F; 内部状态变量\n    address internal myAddress;\n\n    &#x2F;&#x2F; 外部状态变量\n    bool external myBool;\n\n    &#x2F;&#x2F; 构造函数，初始化状态变量\n    constructor(uint _number, string memory _string) &#123;\n        myNumber &#x3D; _number;\n        myString &#x3D; _string;\n        myAddress &#x3D; msg.sender;\n        myBool &#x3D; true;\n    &#125;\n\n    &#x2F;&#x2F; 修改器函数，修改状态变量的值\n    function setNumber(uint _newNumber) public &#123;\n        myNumber &#x3D; _newNumber;\n    &#125;\n\n    &#x2F;&#x2F; 访问器函数，返回状态变量的值\n    function getString() public view returns (string memory) &#123;\n        return myString;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>myNumber</code>、<code>myString</code>、<code>myAddress</code>和<code>myBool</code>都是状态变量，它们的可见性和类型不同。通过构造函数和函数来初始化和修改这些状态变量的值，并可以通过访问器函数获取它们的当前值。</p>\n<h2 id=\"为什么叫合约？\"><a href=\"#为什么叫合约？\" class=\"headerlink\" title=\"为什么叫合约？\"></a>为什么叫合约？</h2><p>在以太坊和其他区块链平台上，智能合约是一种以代码形式编写的可自动执行的合约。它们是在区块链上执行的可编程逻辑，可以定义和执行各种规则和操作。智能合约使用区块链平台的底层技术来确保其执行的安全性和可靠性。</p>\n<p>智能合约被称为”合约”是因为它们类似于传统法律合约中的规则和条款，可以定义参与方之间的协议和条件。通过编写智能合约，参与方可以在没有中间人的情况下进行交互并自动执行合约中定义的逻辑。</p>\n<p>在区块链技术中，智能合约是通过编程语言（如 Solidity）编写的，并部署到区块链上。合约的代码和数据存储在区块链的区块中，并由网络中的节点执行和验证。这使得智能合约具有不可篡改性、透明性和去中心化的特点。</p>\n<p>因此，在区块链领域，将包含可执行逻辑的代码称为”合约”是合理的，因为它们可以实现类似于传统法律合约的功能，并以可编程的方式执行。</p>\n<h2 id=\"solidity-语法\"><a href=\"#solidity-语法\" class=\"headerlink\" title=\"solidity 语法\"></a>solidity 语法</h2><p>Solidity 是一种面向智能合约的高级编程语言，用于在以太坊平台上开发智能合约。以下是 Solidity 的一些常见语法：</p>\n<ol>\n<li><p>类型声明：Solidity 支持各种数据类型，包括整数、浮点数、布尔值、地址、字符串等。类型声明通常在变量声明时使用，例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">uint256 public myNumber;\nstring public myString;\nbool private myFlag;\naddress payable public myAddress;</code></pre>\n</li>\n<li><p>函数声明：Solidity 中的函数声明包括函数的可见性（public、private、internal、external）、返回类型、函数名和参数列表。例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function add(uint256 a, uint256 b) public pure returns (uint256) &#123;\n    return a + b;\n&#125;</code></pre>\n</li>\n<li><p>修饰符（Modifiers）：修饰符可以用于修改函数的行为。例如，可以使用 <code>onlyOwner</code> 修饰符限制只有合约拥有者才能调用某个函数：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">modifier onlyOwner() &#123;\n    require(msg.sender &#x3D;&#x3D; owner, &quot;Only owner can call this function&quot;);\n    _;\n&#125;</code></pre>\n</li>\n<li><p>事件（Events）：事件用于在合约上发布通知。它们可以用于与前端应用程序进行交互或记录状态变化。例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">event NewTransaction(address indexed from, address indexed to, uint256 amount);\n\nfunction transfer(address to, uint256 amount) public &#123;\n    &#x2F;&#x2F; 执行转账逻辑\n    emit NewTransaction(msg.sender, to, amount);\n&#125;</code></pre>\n</li>\n<li><p>结构体（Structs）：结构体允许定义一个包含多个字段的自定义数据类型。例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">struct Person &#123;\n    string name;\n    uint256 age;\n&#125;\n\nPerson public myPerson;</code></pre></li>\n</ol>\n<p>以上只是 Solidity 的一些基本语法示例，还有许多其他功能和语法，如继承、接口、映射、数组等。建议阅读 Solidity 官方文档以了解更多详细信息和最新特性：<a href=\"https://docs.soliditylang.org/\">Solidity 官方文档</a></p>\n<h2 id=\"Function-Modifiers\"><a href=\"#Function-Modifiers\" class=\"headerlink\" title=\"Function Modifiers\"></a>Function Modifiers</h2><p>函数修饰符（Function Modifiers）是 Solidity 中用于修改函数行为的特殊功能。它们可以在函数执行前或执行后添加额外的逻辑。使用修饰符可以提高代码的可重用性和安全性。</p>\n<p>修饰符通常与函数一起使用，并通过在函数声明前使用 <code>modifier</code> 关键字来定义。以下是几个常见的修饰符用法：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">modifier onlyOwner() &#123;\n    require(msg.sender &#x3D;&#x3D; owner, &quot;Only contract owner can call this function&quot;);\n    _; &#x2F;&#x2F; 在修饰符代码和函数体之间插入占位符&quot;_&quot;\n&#125;\n\nmodifier validAmount(uint256 amount) &#123;\n    require(amount &gt; 0, &quot;Amount must be greater than 0&quot;);\n    _;\n&#125;</code></pre>\n\n<p>在使用修饰符的函数声明中，修饰符放置在函数修饰符列表的开头。修饰符可以同时使用多个，用空格分隔。例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function transfer(address to, uint256 amount) public onlyOwner validAmount(amount) &#123;\n    &#x2F;&#x2F; 执行转账逻辑\n&#125;</code></pre>\n\n<p>在上述示例中，<code>onlyOwner</code> 修饰符确保只有合约所有者可以调用该函数，而 <code>validAmount</code> 修饰符确保转账金额大于零。如果修饰符的要求（如 <code>require</code> 语句）未满足，则函数将抛出异常并停止执行。</p>\n<p>修饰符可以使代码更简洁、易读和易于维护，同时可以确保函数的行为符合预期。在 Solidity 中，修饰符是一种强大的工具，可以应用于各种情况，例如权限控制、输入验证等。</p>\n<h2 id=\"“undefined”或“null”值的概念在-Solidity-中不存在\"><a href=\"#“undefined”或“null”值的概念在-Solidity-中不存在\" class=\"headerlink\" title=\"“undefined”或“null”值的概念在 Solidity 中不存在\"></a>“undefined”或“null”值的概念在 Solidity 中不存在</h2><p>有点像 golang</p>\n<p>但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。 要处理任何意外的值，应该使用 错误处理 来恢复整个交易，或者返回一个带有第二个 bool 值的元组表示成功</p>\n<h2 id=\"solidity-有哪些会出现悬空引用\"><a href=\"#solidity-有哪些会出现悬空引用\" class=\"headerlink\" title=\"solidity 有哪些会出现悬空引用\"></a>solidity 有哪些会出现悬空引用</h2><p>这点比 rust 恶心</p>\n<p>在 Solidity 中，悬空引用是指引用了一个已经被销毁或不存在的合约或存储变量。当访问悬空引用时，通常会导致未定义的行为或异常情况。以下是一些常见会导致悬空引用的情况：</p>\n<ol>\n<li><p>合约自我销毁（selfdestruct）：当一个合约通过自我销毁函数（selfdestruct）销毁时，其他合约或外部函数可能仍然保留对已销毁合约的引用。这样的引用将变成悬空引用。</p>\n</li>\n<li><p>引用已删除的数组元素：如果您从一个动态数组中删除了某个元素，并且后续代码仍然引用了已删除的元素索引，这将导致悬空引用。</p>\n</li>\n<li><p>引用已过期的结构体成员：如果您在一个结构体中存储了引用类型（如引用类型的数组或映射），并且从外部修改了这些成员的值，那么结构体中存储的引用成员可能会成为悬空引用。</p>\n</li>\n<li><p>使用已清空的映射：如果您在一个映射中删除了某个键值对，并且后续代码仍然尝试访问已删除的键，这将导致悬空引用。</p>\n</li>\n<li><p>访问已转账的合约：当合约通过转账发送以太币给其他合约时，其他合约可能会保留对已转账合约的引用。如果已转账的合约被销毁或更改了其状态，那么这些引用将变成悬空引用。</p>\n</li>\n</ol>\n<p>为了避免悬空引用，您应该注意在操作合约或存储变量时，确保它们处于有效状态，并避免在已删除、销毁或已过期的情况下进行引用。</p>\n<h2 id=\"我该如何确定一个引用是否悬空？\"><a href=\"#我该如何确定一个引用是否悬空？\" class=\"headerlink\" title=\"我该如何确定一个引用是否悬空？\"></a>我该如何确定一个引用是否悬空？</h2><p>要确定一个引用是否悬空，您可以考虑以下几个方法：</p>\n<ol>\n<li><p>检查引用是否为零地址：对于合约引用，您可以检查引用是否为零地址（0x0000000000000000000000000000000000000000）。如果引用为零地址，则可以确定它是一个悬空引用。</p>\n</li>\n<li><p>检查引用是否为有效状态：对于存储变量引用，您可以检查变量的状态是否有效。例如，如果引用指向一个数组，您可以检查数组的长度是否大于引用的索引。如果引用指向一个映射，您可以检查映射中是否存在引用的键。如果引用的状态无效，那么它可能是一个悬空引用。</p>\n</li>\n<li><p>使用一致的约定：在编写合约时，可以使用一致的约定来避免悬空引用。例如，可以使用特殊的标记值（如零值或特定的未使用状态）来表示悬空引用，并在代码中进行检查。这样，在引用之前，您可以检查引用是否处于有效状态。</p>\n</li>\n</ol>\n<p>请注意，检查引用是否悬空是一种防御性编程的做法，但并不能完全解决问题。在编写 Solidity 合约时，您应该设计合理的逻辑和使用合适的数据结构来避免悬空引用的出现。</p>\n<h2 id=\"没有规则吗？\"><a href=\"#没有规则吗？\" class=\"headerlink\" title=\"没有规则吗？\"></a>没有规则吗？</h2><p>对于 Solidity 合约中的引用，确实存在一些规则和最佳实践来避免悬空引用：</p>\n<ol>\n<li><p>初始化引用：在声明引用变量时，应尽量在同一语句中将其初始化为有效值。避免在声明后立即使用引用之前不初始化它。</p>\n</li>\n<li><p>避免删除引用：避免在使用引用之后删除引用所引用的对象。删除对象后，引用将变为悬空引用。</p>\n</li>\n<li><p>避免引用失效：如果引用指向一个可变对象（如数组），确保在使用引用之前，对象的状态仍然有效。例如，检查引用的索引是否超出数组的长度。</p>\n</li>\n<li><p>清空引用：如果必须清空引用，例如在某个状态变化后，确保在清空引用之前不再使用它。清空引用后，可以使用一致的约定（如将引用设置为零值或其他特殊值）来表示悬空引用。</p>\n</li>\n<li><p>严格检查外部引用：在调用外部合约或外部函数时，特别注意检查返回的引用是否悬空。要确保调用的合约或函数不返回悬空引用，可以使用断言或其他错误处理机制来验证返回值。</p>\n</li>\n</ol>\n<p>需要注意的是，这些规则和最佳实践仅作为一种帮助避免悬空引用的指导方针，并不能完全消除悬空引用的可能性。在编写合约时，始终要仔细设计和测试代码逻辑，以尽量避免悬空引用的出现。</p>\n<h1 id=\"代码示例分析\"><a href=\"#代码示例分析\" class=\"headerlink\" title=\"代码示例分析\"></a>代码示例分析</h1><h2 id=\"mapping-types\"><a href=\"#mapping-types\" class=\"headerlink\" title=\"mapping-types\"></a><a href=\"https://learnblockchain.cn/docs/solidity/types.html#mapping-types\" target=\"_blank\" >mapping-types</a></h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;&#x3D;0.4.0 &lt;0.9.0;\n\ncontract MappingExample &#123;\n    mapping(address &#x3D;&gt; uint) public balances;\n\n    function update(uint newBalance) public &#123;\n        balances[msg.sender] &#x3D; newBalance;\n    &#125;\n&#125;\n\ncontract MappingLBC &#123;\n    function f() public returns (uint) &#123;\n        MappingExample m &#x3D; new MappingExample();\n        m.update(100);\n        return m.balances(this);\n    &#125;\n&#125;</code></pre>\n\n<p>在 Solidity 中，状态变量是用来存储和跟踪智能合约的状态信息的变量。它们是合约的一部分，被永久地存储在区块链上，并且可以在合约的不同函数之间共享和访问。</p>\n<p>状态变量可以是各种数据类型，如整数、布尔值、地址、字符串等。它们用于存储合约需要跟踪的数据，例如合约的状态、用户余额、记录等。</p>\n<p>状态变量的声明通常在合约的顶部，并且可以具有不同的可见性修饰符，如<code>public</code>、<code>private</code>、<code>internal</code>和<code>external</code>。这些修饰符决定了状态变量是否可以被合约内部或外部的其他部分访问。</p>\n<p>以下是一个示例，展示了 Solidity 中的状态变量的声明和使用：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    &#x2F;&#x2F; 公共状态变量\n    uint public myNumber;\n\n    &#x2F;&#x2F; 私有状态变量\n    string private myString;\n\n    &#x2F;&#x2F; 内部状态变量\n    address internal myAddress;\n\n    &#x2F;&#x2F; 外部状态变量\n    bool external myBool;\n\n    &#x2F;&#x2F; 构造函数，初始化状态变量\n    constructor(uint _number, string memory _string) &#123;\n        myNumber &#x3D; _number;\n        myString &#x3D; _string;\n        myAddress &#x3D; msg.sender;\n        myBool &#x3D; true;\n    &#125;\n\n    &#x2F;&#x2F; 修改器函数，修改状态变量的值\n    function setNumber(uint _newNumber) public &#123;\n        myNumber &#x3D; _newNumber;\n    &#125;\n\n    &#x2F;&#x2F; 访问器函数，返回状态变量的值\n    function getString() public view returns (string memory) &#123;\n        return myString;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>myNumber</code>、<code>myString</code>、<code>myAddress</code>和<code>myBool</code>都是状态变量，它们的可见性和类型不同。通过构造函数和函数来初始化和修改这些状态变量的值，并可以通过访问器函数获取它们的当前值。</p>\n<h2 id=\"iterable-mappings\"><a href=\"#iterable-mappings\" class=\"headerlink\" title=\"iterable-mappings\"></a><a href=\"https://learnblockchain.cn/docs/solidity/types.html#iterable-mappings\" target=\"_blank\" >iterable-mappings</a></h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\nstruct IndexValue &#123; uint keyIndex; uint value; &#125;\nstruct KeyFlag &#123; uint key; bool deleted; &#125;\n\nstruct itmap &#123;\n    mapping(uint &#x3D;&gt; IndexValue) data;\n    KeyFlag[] keys;\n    uint size;\n&#125;\n\ntype Iterator is uint;\n\nlibrary IterableMapping &#123;\n    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) &#123;\n        uint keyIndex &#x3D; self.data[key].keyIndex;\n        self.data[key].value &#x3D; value;\n        if (keyIndex &gt; 0)\n            return true;\n        else &#123;\n            keyIndex &#x3D; self.keys.length;\n\n            self.keys.push();\n            self.data[key].keyIndex &#x3D; keyIndex + 1;\n            self.keys[keyIndex].key &#x3D; key;\n            self.size++;\n            return false;\n        &#125;\n    &#125;\n\n    function remove(itmap storage self, uint key) internal returns (bool success) &#123;\n        uint keyIndex &#x3D; self.data[key].keyIndex;\n        if (keyIndex &#x3D;&#x3D; 0)\n            return false;\n        delete self.data[key];\n        self.keys[keyIndex - 1].deleted &#x3D; true;\n        self.size --;\n    &#125;\n\n    function contains(itmap storage self, uint key) internal view returns (bool) &#123;\n        return self.data[key].keyIndex &gt; 0;\n    &#125;\n\n    function iterateStart(itmap storage self) internal view returns (Iterator) &#123;\n        return iteratorSkipDeleted(self, 0);\n    &#125;\n\n    function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) &#123;\n        return Iterator.unwrap(iterator) &lt; self.keys.length;\n    &#125;\n\n    function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) &#123;\n        return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);\n    &#125;\n\n    function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) &#123;\n        uint keyIndex &#x3D; Iterator.unwrap(iterator);\n        key &#x3D; self.keys[keyIndex].key;\n        value &#x3D; self.data[key].value;\n    &#125;\n\n    function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) &#123;\n        while (keyIndex &lt; self.keys.length &amp;&amp; self.keys[keyIndex].deleted)\n            keyIndex++;\n        return Iterator.wrap(keyIndex);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 如何使用\ncontract User &#123;\n    &#x2F;&#x2F; Just a struct holding our data.\n    itmap data;\n    &#x2F;&#x2F; Apply library functions to the data type.\n    using IterableMapping for itmap;\n\n    &#x2F;&#x2F; Insert something\n    function insert(uint k, uint v) public returns (uint size) &#123;\n        &#x2F;&#x2F; This calls IterableMapping.insert(data, k, v)\n        data.insert(k, v);\n        &#x2F;&#x2F; We can still access members of the struct,\n        &#x2F;&#x2F; but we should take care not to mess with them.\n        return data.size;\n    &#125;\n\n    &#x2F;&#x2F; Computes the sum of all stored data.\n    function sum() public view returns (uint s) &#123;\n        for (\n            Iterator i &#x3D; data.iterateStart();\n            data.iterateValid(i);\n            i &#x3D; data.iterateNext(i)\n        ) &#123;\n            (, uint value) &#x3D; data.iterateGet(i);\n            s +&#x3D; value;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述代码中，定义了一个名为<code>IterableMapping</code>的库和一个名为<code>User</code>的合约。</p>\n<p><code>IterableMapping</code>库实现了一个可迭代的映射结构。这个映射结构<code>itmap</code>包含了一个<code>mapping</code>类型的<code>data</code>变量，用于存储键值对的数据。<code>itmap</code>还包含了一个<code>keys</code>数组，用于维护键的顺序，并标记已删除的键。另外，<code>size</code>变量记录了映射中的元素个数。</p>\n<p>库中的函数包括：</p>\n<ul>\n<li><code>insert</code>：向映射中插入一个键值对，并返回是否替换了已存在的键。</li>\n<li><code>remove</code>：从映射中移除指定键，并返回操作是否成功。</li>\n<li><code>contains</code>：检查映射中是否包含指定的键。</li>\n<li><code>iterateStart</code>：返回一个迭代器，指向映射中的第一个元素。</li>\n<li><code>iterateValid</code>：判断迭代器是否指向有效的元素。</li>\n<li><code>iterateNext</code>：返回下一个有效元素的迭代器。</li>\n<li><code>iterateGet</code>：获取迭代器指向的键和对应的值。</li>\n</ul>\n<p><code>User</code>合约使用了<code>IterableMapping</code>库，并在<code>data</code>变量上调用库中的函数来对映射进行操作。</p>\n<p><code>insert</code>函数用于向映射中插入一个键值对，并返回插入后映射中的元素个数。</p>\n<p><code>sum</code>函数用于计算映射中所有值的总和。它通过使用迭代器遍历映射中的所有元素，并累加值来实现。</p>\n<p>该代码演示了如何使用库来扩展结构，并在合约中使用库中的函数来操作数据结构。这种模式可以提高代码的可读性和重用性，尤其是在处理复杂数据结构时。</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><img src=\"http://t-blog-images.aijs.top/img/202307162134604.webp\" />\n\n<h1 id=\"solidity\"><a href=\"#solidity\" class=\"headerlink\" title=\"solidity\"></a>solidity</h1><p><a href=\"https://www.w3cschool.cn/solidity/solidity-structure-of-a-contract.html\" target=\"_blank\" >中文教程</a></p>\n<h2 id=\"合约结构-为什么设计成类？\"><a href=\"#合约结构-为什么设计成类？\" class=\"headerlink\" title=\"合约结构 为什么设计成类？\"></a>合约结构 为什么设计成类？</h2><p>Solidity 中的合约结构被设计成类的形式是为了实现更强大和灵活的功能，同时提供更好的代码组织和可维护性。以下是设计成类的主要原因：</p>\n<p><strong>1. 封装数据和逻辑：</strong> 类的概念允许将数据和相关的操作封装在一起。在 Solidity 中，合约类可以定义状态变量和函数，这样可以更好地组织和管理合约的数据和行为。</p>\n<p><strong>2. 可继承性：</strong> 合约类支持继承关系，这意味着你可以创建一个新的合约类继承自已有的类，并在新类中添加自定义的属性和方法。通过继承，可以实现代码的复用和模块化，同时也方便了合约的维护和更新。</p>\n<p><strong>3. 访问控制和权限管理：</strong> 类的结构使得对合约的访问控制和权限管理更加灵活和可靠。Solidity 中可以使用访问修饰符（如<code>public</code>、<code>private</code>、<code>internal</code>和<code>external</code>）来控制对函数和状态变量的访问权限。这样可以防止未经授权的操作和非法访问。</p>\n<p><strong>4. 可测试性和调试性：</strong> 通过将合约逻辑封装在类中，可以更容易进行合约的测试和调试。测试人员可以直接实例化合约类并调用其方法，验证其行为。类的封装也使得测试更加精确和可控。</p>\n<p><strong>5. 代码的可读性和可维护性：</strong> 类的结构可以提高代码的可读性和可维护性。通过将相关函数和状态变量放在同一个类中，可以更容易理解合约的整体逻辑和实现细节。这对于其他开发者审阅代码、进行维护和修复 bug 都很有帮助。</p>\n<p>综上所述，设计成类的合约结构使得 Solidity 的应用更加灵活、可扩展和易于维护。它提供了封装、继承、访问控制和权限管理等功能，使得智能合约的开发更加高效和可靠。</p>\n<h2 id=\"地址字面量\"><a href=\"#地址字面量\" class=\"headerlink\" title=\"地址字面量\"></a>地址字面量</h2><p>在以太坊区块链中，地址字面量是用来表示以太坊账户地址的一种方式。以太坊地址是一个长字符串，通常由 0x 开头，由数字（0-9）和字母（A-F）组成，共 40 个字符。</p>\n<p>以下是一些示例以太坊地址字面量：</p>\n<ul>\n<li>0x2f342678d8A2456C837D9e88c4c1abbba5DBeA64</li>\n<li>0x8d289Cc4d82A9814cbA7a230660B013aCE2e8595</li>\n<li>0xAbcDeF0123456789aBcDef0123456789aBcDef012</li>\n</ul>\n<p>这些地址字面量是人可读的形式，用于标识以太坊上的不同账户或合约。通过地址字面量，用户可以快速识别和区分不同的账户或合约，以进行转账、交互和查看余额等操作。</p>\n<h2 id=\"为什么字母限制在-A-F\"><a href=\"#为什么字母限制在-A-F\" class=\"headerlink\" title=\"为什么字母限制在 A-F\"></a>为什么字母限制在 A-F</h2><p>在以太坊地址中，字母限制在 A-F 是因为它们用于表示 16 进制的数字。以太坊地址是由 16 进制字符（0-9，A-F）组成的。</p>\n<p>以太坊地址是基于公钥生成的，公钥是由 256 位的二进制数表示的。为了使公钥更加紧凑，以太坊使用了 16 进制来表示这 256 位二进制数。在 16 进制表示中，数字 0 到 9 用于表示 0 到 15 的十进制数，而字母 A 到 F 分别表示 10 到 15 的十进制数。</p>\n<p>因此，以太坊地址使用了 0-9 和 A-F 这 16 个字符来表示 256 位二进制数的每四位。这种表示方式更为紧凑，使得地址更加简洁且易读。</p>\n<h2 id=\"为什么不采用-32-进制\"><a href=\"#为什么不采用-32-进制\" class=\"headerlink\" title=\"为什么不采用 32 进制\"></a>为什么不采用 32 进制</h2><p>采用 16 进制而不是 32 进制表示以太坊地址有几个原因：</p>\n<ol>\n<li><p>兼容性：16 进制是计算机编程中广泛使用的一种格式，许多编程语言和工具都提供了对 16 进制的原生支持。相比之下，32 进制并没有得到广泛采用，可能需要额外的工作来实现 32 进制的编码和解码。</p>\n</li>\n<li><p>可读性：16 进制使用了 0-9 和 A-F 这 16 个字符，与人类的阅读和记忆习惯更加符合。相比之下，32 进制需要使用 0-9 和 A-V 这 32 个字符，包含了较多的字符，不够直观和易读。</p>\n</li>\n<li><p>复杂性：使用 32 进制表示以太坊地址需要更多的位数，因为每个字符可以表示 5 个比特（$2^5&#x3D;32$）。这将增加表示和处理地址的复杂性，并且会导致更长的地址字符串。</p>\n</li>\n</ol>\n<p>综上所述，采用 16 进制表示以太坊地址有着兼容性好、可读性高和简单性的优势，因此成为了以太坊和其他类似的区块链系统的标准做法。</p>\n<h2 id=\"bytes\"><a href=\"#bytes\" class=\"headerlink\" title=\"bytes\"></a>bytes</h2><p><code>bytes</code> 类型在 Solidity 中用于表示可变长度的字节数组。它类似于 <code>bytes1</code>、<code>bytes2</code>、<code>bytes3</code> 等固定长度的字节数组类型，但 <code>bytes</code> 类型可以具有不同的长度。</p>\n<p>您可以使用 <code>bytes</code> 类型来处理和存储可变长度的二进制数据。与固定长度的字节数组类型不同， <code>bytes</code> 类型允许动态地改变其长度。这使得 <code>bytes</code> 可以用于存储和操作不定长度的数据，例如变长字节序列、哈希值或其他二进制数据。</p>\n<p>以下是 <code>bytes</code> 类型的几个重要用法和特性：</p>\n<ul>\n<li>定义 <code>bytes</code> 类型变量：可以使用以下语法定义一个 <code>bytes</code> 类型的变量：<code>bytes memory myBytes;</code>。这会创建一个可存储任意长度字节数组的变量。</li>\n<li>获取字节数组长度：可以使用 <code>myBytes.length</code> 属性获取字节数组的长度，返回字节数组中字节的数量。</li>\n<li>修改字节数组的长度：<code>bytes</code> 类型的长度是可变的。您可以使用 <code>myBytes.length = newSize;</code> 来修改字节数组的长度。</li>\n<li>迭代和访问元素：可以使用 <code>myBytes[i]</code> 来访问字节数组中特定索引位置 <code>i</code> 处的字节，其中 <code>i</code> 是从 0 开始的索引。</li>\n</ul>\n<p>需要注意的是，与固定长度的字节数组类型不同， <code>bytes</code> 类型的操作相对较慢，因为它需要动态分配内存和处理长度变化。因此，在处理具有固定长度的字节数据时，建议使用固定长度的字节数组类型。</p>\n<p>希望这解答了您关于 <code>bytes</code> 类型的疑问！如果您有进一步的问题，请随时提问。</p>\n<h2 id=\"举个例子看看是怎么使用的\"><a href=\"#举个例子看看是怎么使用的\" class=\"headerlink\" title=\"举个例子看看是怎么使用的\"></a>举个例子看看是怎么使用的</h2><p>当使用 <code>bytes</code> 类型时，您可以创建、修改和访问字节数组的元素。以下是一个示例，展示了如何使用 <code>bytes</code> 类型：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract BytesExample &#123;\n    function manipulateBytes() public pure returns (bytes memory) &#123;\n        &#x2F;&#x2F; 定义一个 bytes 变量\n        bytes memory myBytes &#x3D; new bytes(4); &#x2F;&#x2F; 创建一个长度为 4 的字节数组\n\n        &#x2F;&#x2F; 设置字节数组的元素\n        myBytes[0] &#x3D; 0x61; &#x2F;&#x2F; 字符 &#39;a&#39; 的 ASCII 值\n        myBytes[1] &#x3D; 0x62; &#x2F;&#x2F; 字符 &#39;b&#39; 的 ASCII 值\n        myBytes[2] &#x3D; 0x63; &#x2F;&#x2F; 字符 &#39;c&#39; 的 ASCII 值\n        myBytes[3] &#x3D; 0x64; &#x2F;&#x2F; 字符 &#39;d&#39; 的 ASCII 值\n\n        &#x2F;&#x2F; 修改字节数组的长度\n        myBytes &#x3D; new bytes(6); &#x2F;&#x2F; 将字节数组的长度改为 6，原有的值将被保留，新添加的位置将被填充为默认值 0x00\n\n        &#x2F;&#x2F; 访问字节数组的元素\n        byte secondByte &#x3D; myBytes[1]; &#x2F;&#x2F; 读取索引为 1 的字节\n\n        return myBytes;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的合约中，<code>manipulateBytes</code> 函数演示了如何定义、修改和访问 <code>bytes</code> 类型的字节数组。首先，我们创建了一个长度为 4 的字节数组 <code>myBytes</code>，并设置了其前四个元素为 ASCII 值。然后，我们将 <code>myBytes</code> 的长度修改为 6，保留了原有的值并填充了新的位置。最后，我们访问 <code>myBytes</code> 中的第二个元素，并将其返回。</p>\n<p>这只是使用 <code>bytes</code> 类型的一个简单示例，您可以根据自己的需求进行扩展和修改。希望这能帮助您理解如何使用 <code>bytes</code> 类型进行字节数组操作！如有进一步问题，请随时提问。</p>\n<h2 id=\"solidity-引用数据类型有哪些\"><a href=\"#solidity-引用数据类型有哪些\" class=\"headerlink\" title=\"solidity 引用数据类型有哪些\"></a>solidity 引用数据类型有哪些</h2><p>Solidity 是一种用于编写智能合约的编程语言，它引入了多种数据类型来支持合约的开发。以下是 Solidity 中常用的引用数据类型：</p>\n<ol>\n<li><p>引用类型（Reference Types）:</p>\n<ul>\n<li>数组（Array）: 用于存储相同类型的数据元素的有序集合。可以有定长数组（fixed-size arrays）和动态数组（dynamic arrays）。</li>\n<li>结构体（Struct）: 允许开发者自定义复杂的数据结构。</li>\n<li>映射（Mapping）: 是一种键值对的集合，类似于哈希表或关联数组。</li>\n</ul>\n</li>\n<li><p>引用类型修饰符（Reference Type Modifiers）:</p>\n<ul>\n<li>引用 (引用类型修饰符)：<strong>通过在变量声明中添加 <code>storage</code> 关键字将变量声明为引用类型，存储在存储器中，并可以在函数调用之间保留数据</strong>。</li>\n</ul>\n</li>\n<li><p>引用类型字面量（Literal Reference Types）:</p>\n<ul>\n<li>字节串（Bytes）: 用于存储和操作字节序列。</li>\n<li>枚举（Enum）: 定义一组命名常数，并且该类型的变量只能在预定义的常数中取值。</li>\n</ul>\n</li>\n</ol>\n<p>这些引用数据类型可用于在 Solidity 智能合约中声明变量、函数参数和返回值，以及数据的存储和操作。使用这些数据类型，开发者可以更有效地处理复杂的数据结构和逻辑。</p>\n<h2 id=\"memory：storage-和-calldata\"><a href=\"#memory：storage-和-calldata\" class=\"headerlink\" title=\"memory：storage 和 calldata\"></a>memory：storage 和 calldata</h2><p>在 Solidity 中，存在三种不同的数据位置：<code>memory</code>、<code>storage</code>和<code>calldata</code>。这些关键字用于指定变量在何处存储以及如何访问。</p>\n<ul>\n<li><p><code>memory</code>：<code>memory</code>是用于临时存储和处理数据的位置。在函数内部声明的局部变量默认存储在<code>memory</code>中，它们在函数执行完毕后会被清除。<code>memory</code>适用于临时存储大型数组、字符串或复杂对象等数据。</p>\n</li>\n<li><p><code>storage</code>：<code>storage</code>是永久存储和访问数据的位置。它指的是以太坊网络上的永久存储，用于存储智能合约的状态和数据。在合约中声明的状态变量默认存储在<code>storage</code>中，它们的值在多次函数调用之间保持不变。<code>storage</code>适用于存储可持久化的状态信息和数据。</p>\n</li>\n<li><p><code>calldata</code>：<code>calldata</code>是用于存储函数参数和外部函数调用数据的位置。它是只读的，这意味着无法对其中的数据进行修改。函数参数默认位于<code>calldata</code>中，它在函数执行期间一直保持不变。<code>calldata</code>适用于在函数之间传递和接收数据，尤其适用于合约之间的交互。</p>\n</li>\n</ul>\n<p>这些数据位置关键字用于指定变量的存储位置和访问方式，以确保正确地管理和处理数据。开发者在编写 Solidity 合约时需要根据变量的作用和需求选择合适的数据位置。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>当声明变量时，可以使用关键字<code>memory</code>、<code>storage</code>和<code>calldata</code>来指定变量的存储位置。以下是一些示例：</p>\n<ol>\n<li>使用<code>memory</code>存储位置的临时变量：</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function concatenateStrings(string memory _str1, string memory _str2) public pure returns (string memory) &#123;\n    string memory result &#x3D; string(abi.encodePacked(_str1, _str2));\n    return result;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>result</code>变量被声明为<code>memory</code>类型。它用于临时存储连接了两个字符串的结果，并在函数结束后被清除。</p>\n<ol start=\"2\">\n<li>使用<code>storage</code>存储位置的状态变量：</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    uint public myNumber;\n\n    function setNumber(uint _num) public &#123;\n        myNumber &#x3D; _num;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>myNumber</code>是一个状态变量，它存储在永久存储位置<code>storage</code>中。<code>setNumber</code>函数用于修改该状态变量的值。</p>\n<ol start=\"3\">\n<li>使用<code>calldata</code>存储位置的函数参数：</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    function processArray(uint[] calldata _data) public pure returns (uint) &#123;\n        uint sum &#x3D; 0;\n        for (uint i &#x3D; 0; i &lt; _data.length; i++) &#123;\n            sum +&#x3D; _data[i];\n        &#125;\n        return sum;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>_data</code>是一个函数参数，它存储在<code>calldata</code>中。<code>processArray</code>函数对传入的数组进行求和操作，并返回结果。</p>\n<p>这些示例展示了如何在不同情境下声明和使用不同数据位置的变量。通过选择适当的存储位置，可以有效地管理和处理数据。</p>\n<h2 id=\"uint-calldata-data-写成-uint-data-可以吗\"><a href=\"#uint-calldata-data-写成-uint-data-可以吗\" class=\"headerlink\" title=\"uint[] calldata _data 写成 uint[] _data 可以吗\"></a><code>uint[] calldata _data</code> 写成 <code>uint[] _data</code> 可以吗</h2><p>是的，你可以使用<code>uint[] _data</code>来声明一个函数参数，其中<code>_data</code>将默认使用<code>memory</code>存储位置。</p>\n<p>以下是使用<code>uint[] _data</code>声明函数参数的示例：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    function processArray(uint[] _data) public pure returns (uint) &#123;\n        uint sum &#x3D; 0;\n        for (uint i &#x3D; 0; i &lt; _data.length; i++) &#123;\n            sum +&#x3D; _data[i];\n        &#125;\n        return sum;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，<code>_data</code>参数作为一个动态大小的数组传递给函数<code>processArray</code>。由于未明确指定存储位置，它将默认为<code>memory</code>位置。</p>\n<p>请注意，对于<code>calldata</code>数据位置，只有函数参数才能使用。在其他变量声明中，需要明确使用<code>memory</code>或<code>storage</code>关键字指定存储位置。</p>\n<h2 id=\"solidity-结构体是什么？\"><a href=\"#solidity-结构体是什么？\" class=\"headerlink\" title=\"solidity 结构体是什么？\"></a>solidity 结构体是什么？</h2><p>在 Solidity 中，结构体（Struct）是一种自定义的复合数据类型，用于定义包含多个不同类型成员的数据结构。</p>\n<p>结构体允许你创建一个新的数据类型，其中可以将多个相关的数据组合在一起，并按照需要访问这些数据。相当于其他编程语言中的“记录”或“对象”。</p>\n<p>以下是一个示例，展示了如何声明和使用结构体：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">&#x2F;&#x2F; 定义结构体\nstruct Person &#123;\n    string name;\n    uint age;\n    address walletAddress;\n&#125;\n\n&#x2F;&#x2F; 声明结构体变量\nPerson public myPerson;\n\n&#x2F;&#x2F; 初始化结构体变量\nfunction setPerson() public &#123;\n    myPerson &#x3D; Person(&quot;Alice&quot;, 25, 0x1234567890abcdef);\n&#125;\n\n&#x2F;&#x2F; 访问结构体成员\nfunction getPersonName() public view returns (string memory) &#123;\n    return myPerson.name;\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了一个名为<code>Person</code>的结构体，它包含了一个字符串类型的<code>name</code>、一个无符号整数类型的<code>age</code>和一个地址类型的<code>walletAddress</code>。然后，我们声明了一个名为<code>myPerson</code>的公共变量来存储一个<code>Person</code>类型的结构体。</p>\n<p><code>setPerson</code>函数用于初始化<code>myPerson</code>结构体变量。<code>getPersonName</code>函数用于获取<code>myPerson</code>结构体变量的<code>name</code>成员。</p>\n<h2 id=\"结构体不能继承\"><a href=\"#结构体不能继承\" class=\"headerlink\" title=\"结构体不能继承\"></a>结构体不能继承</h2><p>是的，结构体（Struct）不能直接继承其他结构体或合约。在 Solidity 中，继承（Inheritance）只能应用于合约（Contract）之间，而不是结构体之间。</p>\n<p>继承允许一个合约从另一个合约中继承属性和方法。合约可以使用<code>is</code>关键字来声明继承关系，并继承父合约中的成员（状态变量和函数）。</p>\n<p>以下是一个示例，展示了如何在 Solidity 中使用继承：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract Animal &#123;\n    string public name;\n\n    constructor(string memory _name) &#123;\n        name &#x3D; _name;\n    &#125;\n\n    function speak() public virtual returns (string memory) &#123;\n        return &quot;Animal sound&quot;;\n    &#125;\n&#125;\n\ncontract Dog is Animal &#123;\n    constructor(string memory _name) Animal(_name) &#123;&#125;\n\n    function speak() public override returns (string memory) &#123;\n        return &quot;Woof!&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了一个名为<code>Animal</code>的合约，其中包含了一个公共的<code>name</code>变量和一个<code>speak</code>函数。然后，我们定义了一个名为<code>Dog</code>的合约，使用<code>is</code>关键字来继承自<code>Animal</code>合约。子合约中重写（override）了<code>Animal</code>合约中的<code>speak</code>函数，并实现了自己的行为。</p>\n<p>总结起来，结构体不支持继承，只有合约之间可以使用继承来共享和扩展代码。</p>\n<h2 id=\"那这看上去与-golang-stuct-差别很大\"><a href=\"#那这看上去与-golang-stuct-差别很大\" class=\"headerlink\" title=\"那这看上去与 golang stuct 差别很大\"></a>那这看上去与 golang stuct 差别很大</h2><p>是的，Solidity 中的结构体与 Go 语言中的 struct 有一些差别。</p>\n<p>在 Go 语言中，结构体可以被继承并用作其他结构体的基础。子结构体将继承父结构体的字段和方法，并可添加自己的额外字段和方法。这使得在 Go 中可以实现面向对象的概念。</p>\n<p>而在 Solidity 中，结构体之间没有继承的概念。结构体主要用于定义数据的集合，包含一组相关的变量。它们通常在合约中作为状态变量的一部分使用，而不是被用作继承的基础。</p>\n<p>虽然 Solidity 中的结构体不支持直接的继承，但你可以通过组合多个结构体来模拟类似于继承的行为。</p>\n<p>以下是一个示例，展示了如何在 Solidity 中实现结构体的组合：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">struct Animal &#123;\n    string name;\n    uint age;\n&#125;\n\nstruct Dog &#123;\n    Animal animal;\n    string breed;\n&#125;\n\ncontract MyContract &#123;\n    Dog myDog;\n\n    constructor(string memory _name, uint _age, string memory _breed) &#123;\n        myDog.animal &#x3D; Animal(_name, _age);\n        myDog.breed &#x3D; _breed;\n    &#125;\n&#125;</code></pre>\n\n<p>上述示例中，我们定义了两个结构体 <code>Animal</code> 和 <code>Dog</code>。然后我们在 <code>Dog</code> 结构体中嵌入了 <code>Animal</code> 结构体，并在合约 <code>MyContract</code> 中使用了 <code>Dog</code> 结构体。</p>\n<p>虽然结构体不能直接继承，但使用组合可以实现类似的功能。</p>\n<h2 id=\"solidity-封装、继承、多态体现在哪些地方，举例说明\"><a href=\"#solidity-封装、继承、多态体现在哪些地方，举例说明\" class=\"headerlink\" title=\"solidity 封装、继承、多态体现在哪些地方，举例说明\"></a>solidity 封装、继承、多态体现在哪些地方，举例说明</h2><p>在 Solidity 中，封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）是面向对象编程的重要概念。它们可以通过合约（Contract）之间的关系来实现。</p>\n<p>封装：封装是指将数据和操作数据的方法组合在一起，形成一个独立的单元。在 Solidity 中，合约可以使用修饰符（Modifiers）来封装和限制不同的访问级别。</p>\n<p>以下是一个示例，展示了如何使用修饰符来封装和实现访问控制：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    uint private myPrivateData;\n\n    function setData(uint _data) public onlyOwner &#123;\n        myPrivateData &#x3D; _data;\n    &#125;\n\n    function getData() public view returns (uint) &#123;\n        return myPrivateData;\n    &#125;\n\n    modifier onlyOwner &#123;\n        require(msg.sender &#x3D;&#x3D; owner, &quot;Only contract owner can call this function&quot;);\n        _;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，<code>myPrivateData</code>是一个私有变量，只能在合约内部访问。<code>setData</code>函数用于设置<code>myPrivateData</code>的值，只有合约的拥有者（owner）可以调用该函数，因为它使用了<code>onlyOwner</code>修饰符来封装了访问控制。<code>getData</code>函数用于获取<code>myPrivateData</code>的值。通过封装，我们可以隐藏数据细节并限制对它们的访问。</p>\n<p>继承：继承是指一个合约（子合约）可以从另一个合约（父合约）继承属性和方法。子合约可以在不改变父合约的情况下扩展其功能或修改其行为。</p>\n<p>以下是一个示例，展示了如何在 Solidity 中使用继承：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract Animal &#123;\n    string public name;\n\n    constructor(string memory _name) &#123;\n        name &#x3D; _name;\n    &#125;\n\n    function speak() public virtual returns (string memory);\n&#125;\n\ncontract Dog is Animal &#123;\n    constructor(string memory _name) Animal(_name) &#123;&#125;\n\n    function speak() public override returns (string memory) &#123;\n        return &quot;Woof!&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了一个名为<code>Animal</code>的父合约，其中包含了一个公共的<code>name</code>变量和一个<code>speak</code>函数。然后，我们定义了一个名为<code>Dog</code>的子合约，继承自<code>Animal</code>合约。子合约中重写（override）了<code>Animal</code>合约中的<code>speak</code>函数，并实现了自己的行为。</p>\n<p>多态：多态是指在不同的上下文中，同一个函数可以表现出不同的行为。在 Solidity 中，可以通过函数重载和函数覆盖来实现多态。</p>\n<p>以下是一个示例，展示了如何在 Solidity 中实现函数重载和函数覆盖：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract Animal &#123;\n    function makeSound() public pure virtual returns (string memory);\n&#125;\n\ncontract Dog is Animal &#123;\n    function makeSound() public pure override returns (string memory) &#123;\n        return &quot;Woof!&quot;;\n    &#125;\n&#125;\n\ncontract Cat is Animal &#123;\n    function makeSound() public pure override returns (string memory) &#123;\n        return &quot;Meow!&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了一个名为<code>Animal</code>的父合约，其中包含了一个名为<code>makeSound</code>的函数。然后，我们定义了两个子合约，分别为<code>Dog</code>和<code>Cat</code>，它们都继承自<code>Animal</code>合约并重写了<code>makeSound</code>函数。在不同的合约实例中调用<code>makeSound</code>函数时，会表现出不同的行为，实现了多态性。</p>\n<h2 id=\"solidity-函数修饰符是不是装饰器？\"><a href=\"#solidity-函数修饰符是不是装饰器？\" class=\"headerlink\" title=\"solidity 函数修饰符是不是装饰器？\"></a>solidity 函数修饰符是不是装饰器？</h2><p>是的，Solidity 中的函数修饰符可以被看作类似于装饰器的概念。它们允许你在函数执行前后或中间添加额外的逻辑，以修改函数的行为或应用特定的约束条件。</p>\n<p>函数修饰符可以在 Solidity 合约中定义，并在合约的函数声明中使用。修饰符使用 <code>modifier</code> 关键字来声明，并且可以被放置在函数的任意位置。</p>\n<p>通过使用修饰符，你可以在函数执行前对传入的参数进行验证、检查合约状态、检查权限等操作。通过这种方式，你可以在不改变原始函数逻辑的情况下，将可重复的验证和逻辑提取到修饰符中，使代码更加清晰和可维护。</p>\n<p>以下是一个示例，展示了如何在 Solidity 中定义和使用函数修饰符：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    address public owner;\n\n    constructor() &#123;\n        owner &#x3D; msg.sender;\n    &#125;\n\n    modifier onlyOwner &#123;\n        require(msg.sender &#x3D;&#x3D; owner, &quot;Only the contract owner can call this function&quot;);\n        _; &#x2F;&#x2F; 修饰符中的 &quot;_&quot; 表示修饰符所修饰的函数体\n    &#125;\n\n    function doSomething() public onlyOwner &#123;\n        &#x2F;&#x2F; 只有合约拥有者才能调用这个函数\n        &#x2F;&#x2F; 执行一些功能...\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了一个修饰符 <code>onlyOwner</code>，它会在被修饰的函数执行前进行检查，确保只有合约的拥有者可以调用该函数。如果调用者不是合约的拥有者，将会触发异常并终止函数执行。</p>\n<p>函数修饰符类似于装饰器，它们提供了一种方便的方式来应用额外的逻辑和约束条件，以增强合约的功能和安全性。</p>\n<h2 id=\"solidity-算术运算的检查模式与非检查模式\"><a href=\"#solidity-算术运算的检查模式与非检查模式\" class=\"headerlink\" title=\"solidity 算术运算的检查模式与非检查模式\"></a>solidity 算术运算的检查模式与非检查模式</h2><p>在 Solidity 中，进行算术运算时，你可以选择使用检查模式（<code>SafeMath</code>）或非检查模式来处理溢出和下溢错误。</p>\n<ol>\n<li>检查模式（SafeMath）：<ul>\n<li>检查模式是一种安全的算术运算模式，旨在防止溢出和下溢错误。</li>\n<li>在使用检查模式之前，通常需要引入和使用 SafeMath 库。</li>\n<li>使用 SafeMath 库提供的函数，例如 <code>add()</code>、<code>sub()</code>、<code>mul()</code> 和 <code>div()</code> 等，可以确保在进行加法、减法、乘法和除法运算时，结果不会溢出或下溢。</li>\n<li>如果溢出或下溢，SafeMath 会抛出异常并终止合约执行。</li>\n</ul>\n</li>\n</ol>\n<p>例如，使用 SafeMath 的加法运算示例如下：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\nimport &quot;.&#x2F;SafeMath.sol&quot;;\n\ncontract MyContract &#123;\n    using SafeMath for uint256;\n\n    function myFunction(uint256 x, uint256 y) public pure returns (uint256) &#123;\n        &#x2F;&#x2F; 使用 SafeMath 进行加法运算\n        uint256 result &#x3D; x.add(y);\n\n        return result;\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>非检查模式：<ul>\n<li>非检查模式是指直接进行算术运算，没有添加溢出或下溢检查。</li>\n<li>非检查模式更加简单和直接，但可能导致溢出和下溢错误，并且可能会导致不可预见的结果或安全漏洞。因此，在使用非检查模式时，需要确保输入数据的有效性和结果范围的合理性。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    function myFunction(uint256 x, uint256 y) public pure returns (uint256) &#123;\n        &#x2F;&#x2F; 非检查模式的加法运算\n        uint256 result &#x3D; x + y;\n\n        return result;\n    &#125;\n&#125;</code></pre>\n\n<p>总之，使用检查模式（SafeMath）可以确保算术运算结果的安全性，并防止溢出和下溢错误。而在非检查模式下，直接进行算术运算可能导致不可预见的问题。因此，建议在 Solidity 合约中使用检查模式来确保代码的安全性和可靠性。</p>\n<h2 id=\"solidity-revert-抛出异常\"><a href=\"#solidity-revert-抛出异常\" class=\"headerlink\" title=\"solidity revert 抛出异常?\"></a>solidity revert 抛出异常?</h2><p>是的，Solidity 中的 <code>revert</code> 用于抛出异常并回滚当前的合约调用。</p>\n<p>当出现错误或异常情况时，合约可以使用 <code>revert</code> 来中止当前的执行，并向上一级调用者传递错误信息。这样做可以防止合约状态被修改并保持原有的调用栈。</p>\n<p><code>revert</code> 可以接受一个可选的错误消息参数，用于提供更详细的异常信息。例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function myFunction() public &#123;\n    &#x2F;&#x2F; 如果条件不满足，抛出异常并回滚\n    if (条件判断) &#123;\n        revert(&quot;错误消息&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 继续执行其他操作\n&#125;</code></pre>\n\n<p>当 <code>revert</code> 被调用时，当前合约调用会回滚到之前的状态，并将异常消息传递给上一级调用者。这也意味着在调用合约的外部函数中捕获异常是不可能的。只有上一级合约或外部调用者有机会捕获并处理异常。</p>\n<h2 id=\"solidity-assert-与-require-的区别\"><a href=\"#solidity-assert-与-require-的区别\" class=\"headerlink\" title=\"solidity assert 与 require 的区别\"></a>solidity assert 与 require 的区别</h2><p>在 Solidity 中，<code>assert</code> 和 <code>require</code> 都用于进行断言和异常处理，但它们有着不同的行为和用途。</p>\n<ul>\n<li><code>require</code> 用于验证函数的先决条件，即函数执行前的输入检查。如果条件不满足，则会抛出异常并回滚所有状态更改。这个异常是可以被捕获并处理的。使用 <code>require</code> 是一种很好的做法来确保函数被调用时输入满足所需的条件。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function myFunction(uint256 x) public &#123;\n    &#x2F;&#x2F; 使用 require 验证输入条件\n    require(x &gt; 0, &quot;x 必须大于 0&quot;);\n\n    &#x2F;&#x2F; 继续执行函数的其他操作\n&#125;</code></pre>\n\n<ul>\n<li><code>assert</code> 用于验证在智能合约中的一些内部情况，即检查合约内部状态的一致性。它主要用于捕获和消除编程错误，例如溢出错误或其他不应该发生的情况。如果条件检查失败，<code>assert</code> 会引发异常并终止整个交易，同时也会消耗整个所使用的燃气。这是为了确保在出现错误时立即停止合约的执行。与 <code>require</code> 不同，<code>assert</code> 的异常是无法被捕获和处理的。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function myFunction() public &#123;\n    uint256 x &#x3D; 1;\n    uint256 y &#x3D; 2;\n\n    &#x2F;&#x2F; 使用 assert 验证内部状态一致性\n    assert(x + y &#x3D;&#x3D; 3);\n\n    &#x2F;&#x2F; 继续执行函数的其他操作\n&#125;</code></pre>\n\n<p>因此，<code>require</code> 主要用于输入检查和先决条件的验证，而 <code>assert</code> 主要用于内部状态的一致性检查和捕获编程错误。在编写合约时，根据情况正确选择使用 <code>require</code> 或 <code>assert</code> 是很重要的，以确保合约的安全和正确性。</p>\n<h2 id=\"solidity-作用域和声明\"><a href=\"#solidity-作用域和声明\" class=\"headerlink\" title=\"solidity 作用域和声明\"></a>solidity 作用域和声明</h2><p>Solidity 中有不同的作用域和声明方式，用于定义变量、函数、合约等。下面是 Solidity 中常见的作用域和声明方式：</p>\n<ol>\n<li>全局作用域：<ul>\n<li>在 Solidity 合约中，声明在合约体外的变量和函数具有全局作用域。</li>\n<li>具有全局作用域的变量和函数可以在合约的任何地方使用。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    uint256 globalVariable; &#x2F;&#x2F; 全局变量\n\n    function globalFunction() public pure &#123;\n        &#x2F;&#x2F; 全局函数\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>合约作用域：<ul>\n<li>Solidity 合约本身具有作用域。</li>\n<li>在合约内部定义的变量和函数可以在整个合约范围内使用。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    uint256 contractVariable; &#x2F;&#x2F; 合约变量\n\n    function contractFunction() public pure &#123;\n        &#x2F;&#x2F; 合约函数\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>函数作用域：<ul>\n<li>在 Solidity 中，函数具有自己的作用域。</li>\n<li>在函数内部声明的变量只能在函数内部使用。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    function myFunction() public pure &#123;\n        uint256 functionVariable; &#x2F;&#x2F; 函数变量\n\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>块作用域：<ul>\n<li>Solidity 也支持块作用域，例如 <code>if</code>、<code>for</code> 等语句块可以创建自己的作用域。</li>\n<li>在块作用域内声明的变量仅在该块范围内有效。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    function myFunction() public pure &#123;\n        &#x2F;&#x2F; 块作用域\n        &#123;\n            uint256 blockVariable; &#x2F;&#x2F; 块变量\n\n            &#x2F;&#x2F; ...\n        &#125;\n\n        &#x2F;&#x2F; blockVariable 在此不可见\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>声明变量：<ul>\n<li>Solidity 支持不同类型的变量声明，如 <code>uint256</code>、<code>bool</code>、<code>string</code> 等。</li>\n<li>变量声明可以在合约的任何地方完成，包括全局作用域、合约作用域、函数作用域等。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    uint256 public myVariable; &#x2F;&#x2F; 公共变量声明\n\n    function myFunction() public &#123;\n        uint256 localVariable; &#x2F;&#x2F; 本地变量声明\n\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;</code></pre>\n\n<p>总结起来，Solidity 中的作用域可以在全局、合约、函数和块级别定义变量和函数。了解作用域的概念对于正确声明和使用这些元素至关重要。</p>\n<h2 id=\"solidity-赋值方式有哪些\"><a href=\"#solidity-赋值方式有哪些\" class=\"headerlink\" title=\"solidity 赋值方式有哪些\"></a>solidity 赋值方式有哪些</h2><p>在 Solidity 中，常见的赋值方式包括：</p>\n<ol>\n<li>直接赋值：使用等号（<code>=</code>）将一个值赋给一个变量。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">uint256 myVariable &#x3D; 10;</code></pre>\n\n<ol start=\"2\">\n<li>批量赋值：使用逗号分隔的多个变量，将多个值一次性赋给多个变量。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">uint256 a &#x3D; 10, b &#x3D; 20, c &#x3D; 30;</code></pre>\n\n<ol start=\"3\">\n<li>数组赋值：将多个值赋给数组变量。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">uint256[] myArray;\nmyArray &#x3D; [10, 20, 30];</code></pre>\n\n<ol start=\"4\">\n<li>结构体赋值：将值赋给结构体变量的各个成员。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">struct Person &#123;\n    string name;\n    uint256 age;\n&#125;\n\nPerson myPerson;\nmyPerson.name &#x3D; &quot;Alice&quot;;\nmyPerson.age &#x3D; 25;</code></pre>\n\n<ol start=\"5\">\n<li>映射（Mapping）赋值：将值赋给映射的特定键。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">mapping(address &#x3D;&gt; uint256) balances;\nbalances[msg.sender] &#x3D; 1000;</code></pre>\n\n<ol start=\"6\">\n<li>枚举（Enum）赋值：将枚举值赋给变量。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">enum Color &#123; Red, Green, Blue &#125;\nColor myColor &#x3D; Color.Blue;</code></pre>\n\n<p>需要注意的是，在 Solidity 中，赋值号（<code>=</code>）右侧的表达式应具有与目标变量相兼容的类型。赋值运算符的使用取决于变量的类型和赋值的方式。</p>\n<p>除了上述提到的常见赋值方式外，Solidity 还支持一些其他的赋值方式，包括：</p>\n<ol start=\"7\">\n<li>构造函数赋值：在合约的构造函数中，可以通过参数传递值来为实例变量赋初值。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    uint256 public myVariable;\n\n    constructor(uint256 initialValue) &#123;\n        myVariable &#x3D; initialValue;\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"8\">\n<li>等式赋值：使用等式（<code>==</code>）检查两个值是否相等，而不是进行实际的赋值操作。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">bool result &#x3D; (a &#x3D;&#x3D; b);</code></pre>\n\n<ol start=\"9\">\n<li>引用赋值：通过引用将一个变量的值赋给另一个变量。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">uint256 a &#x3D; 10;\nuint256 b &#x3D; a;</code></pre>\n\n<p>需要注意的是，引用赋值涉及到值的复制，基本数据类型的赋值会复制值本身，而复杂数据类型（如数组、映射、结构体）的赋值会复制引用，因此修改其中一个变量的值可能会影响另一个变量。</p>\n<p>这些是常见的 Solidity 赋值方式，覆盖了大多数场景。根据变量类型和具体情况的不同，选择合适的赋值方式可以提高代码的可读性和效率。</p>\n<h2 id=\"solidity-合约-Constant-和-Immutable-状态变量\"><a href=\"#solidity-合约-Constant-和-Immutable-状态变量\" class=\"headerlink\" title=\"solidity 合约 Constant 和 Immutable 状态变量\"></a>solidity 合约 Constant 和 Immutable 状态变量</h2><p>在 Solidity 中，常量（constant）和不可变（immutable）是用于声明状态变量的修饰符，用于指定变量的不可更改性质。</p>\n<ol>\n<li><strong>Constant（常量）</strong>: <code>constant</code> 被用于表示一个状态变量的值在部署合约后就无法更改。常量必须在声明时进行赋值，并且只能是字面量、常量表达式或者通过全局函数（如 <code>block.number</code>）计算得出的值。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    uint256 public constant MY_CONSTANT &#x3D; 10;\n&#125;</code></pre>\n\n<p>在这个示例中，<code>MY_CONSTANT</code> 被声明为常量，并被赋值为 10。在合约的执行期间，<code>MY_CONSTANT</code> 的值始终为 10，无法被修改。</p>\n<ol start=\"2\">\n<li><strong>Immutable（不可变）</strong>: <code>immutable</code> 被用于表示一个状态变量的值在部署合约时指定，并在后续的合约生命周期中无法更改。与常量不同，不可变变量允许在声明时通过构造函数进行赋值，并且可以是运行时计算的值。</li>\n</ol>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    uint256 public immutable MY_IMMUTABLE;\n\n    constructor(uint256 initialValue) &#123;\n        MY_IMMUTABLE &#x3D; initialValue;\n    &#125;\n&#125;</code></pre>\n\n<p>在这个示例中，<code>MY_IMMUTABLE</code> 被声明为不可变变量。构造函数接受一个参数，将其赋值给 <code>MY_IMMUTABLE</code> 变量。一旦合约部署完成，<code>MY_IMMUTABLE</code> 的值将无法更改。</p>\n<p>需要注意的是，常量和不可变变量有一些限制。例如，它们不能指向非常量或不可变变量的引用类型，也不能与一些关键字一起使用（如 <code>mapping</code>）。此外，不可变变量的值在部署合约时必须是确定的，而常量则更加灵活。</p>\n<p>这些修饰符使得 Solidity 合约具有更严格的不可更改性限制，可以在编写合约时确保某些变量的值不会被修改，提高代码的安全性和可靠性。</p>\n<h2 id=\"solidity-函数\"><a href=\"#solidity-函数\" class=\"headerlink\" title=\"solidity 函数\"></a>solidity 函数</h2><p>在 Solidity 中，函数是合约中执行特定任务的代码块。它们用于实现合约的行为和逻辑。以下是有关 Solidity 函数的一些重要概念和示例：</p>\n<h2 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h2><p>函数定义由函数名称、可选的修饰符（如 <code>public</code>、<code>private</code> 和 <code>external</code>）以及参数列表组成。以下是一个示例函数定义：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function add(uint256 a, uint256 b) public pure returns (uint256) &#123;\n    return a + b;\n&#125;</code></pre>\n\n<p>在这个示例中，函数名是 <code>add</code>。它接受两个 <code>uint256</code> 类型的参数 <code>a</code> 和 <code>b</code>。函数使用 <code>public</code> 修饰符表示该函数可以被任何人调用。<code>pure</code> 关键字表示函数不会修改合约状态，并且不会读取或更改存储在合约中的变量。<code>returns (uint256)</code> 表示函数返回一个 <code>uint256</code> 类型的值。</p>\n<h2 id=\"函数修饰符\"><a href=\"#函数修饰符\" class=\"headerlink\" title=\"函数修饰符\"></a>函数修饰符</h2><p>函数修饰符用于声明函数的可见性和行为。以下是一些常见的修饰符：</p>\n<ul>\n<li><code>public</code>：任何人都可以调用该函数。</li>\n<li><code>private</code>：只能在合约内部调用函数。</li>\n<li><code>internal</code>：只能在合约内部和继承合约中调用函数。</li>\n<li><code>external</code>：只能从合约外部调用该函数。</li>\n</ul>\n<p>修饰符用于控制函数访问权限，并帮助确保合约的安全性和正确性。</p>\n<h2 id=\"函数参数和返回值\"><a href=\"#函数参数和返回值\" class=\"headerlink\" title=\"函数参数和返回值\"></a>函数参数和返回值</h2><p>函数可以有输入参数和返回值。函数的参数列表指定了函数在调用时接受的值，而返回值指定了函数在调用完成后返回的值。以下是一个函数的参数和返回值的示例：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">function transfer(address to, uint256 amount) public returns (bool) &#123;\n    &#x2F;&#x2F; 执行转账逻辑\n    &#x2F;&#x2F; 如果转账成功，返回 true；否则返回 false\n&#125;</code></pre>\n\n<p>在这个例子中，函数 <code>transfer</code> 接受两个参数 <code>to</code> 和 <code>amount</code>，第一个是 <code>address</code> 类型，第二个是 <code>uint256</code> 类型。函数返回一个布尔值，表示转账操作是否成功。</p>\n<h2 id=\"修饰函数状态\"><a href=\"#修饰函数状态\" class=\"headerlink\" title=\"修饰函数状态\"></a>修饰函数状态</h2><p>Solidity 中的函数可以有不同的状态修饰符来表示它们对合约状态的影响。以下是一些常见的状态修饰符：</p>\n<ul>\n<li><code>pure</code>：函数不读取或更改合约状态，也不访问合约存储。</li>\n<li><code>view</code> 或 <code>constant</code>：函数不修改合约状态，但可以读取合约存储。</li>\n<li><code>payable</code>：函数可以接受以太币作为支付。</li>\n</ul>\n<p>这些修饰符帮助开发人员理解函数的行为和影响，并提供了额外的安全性和灵活性。</p>\n<p>以上是 Solidity 函数的基本知识。函数是 Solidity 合约的核心元素之一，可以实现各种逻辑和功能。具体的函数实现取决于您想要实现的合约行为和需求。</p>\n<h2 id=\"pure\"><a href=\"#pure\" class=\"headerlink\" title=\"pure\"></a>pure</h2><pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity &gt;&#x3D;0.4.16 &lt;0.9.0;\n\ncontract Simple &#123;\n    function arithmetic(uint a, uint b)\n        public\n        pure\n        returns (uint sum, uint product)\n    &#123;\n        sum &#x3D; a + b;\n        product &#x3D; a * b;\n    &#125;\n&#125;</code></pre>\n\n<p>这是一个简单的 Solidity 合约，该合约声明了一个名为 <code>Simple</code> 的合约，并包含一个名为 <code>arithmetic</code> 的函数。以下是对这个合约的解释：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity &gt;&#x3D;0.4.16 &lt;0.9.0;\n\ncontract Simple &#123;\n    function arithmetic(uint a, uint b)\n        public\n        pure\n        returns (uint sum, uint product)\n    &#123;\n        sum &#x3D; a + b;\n        product &#x3D; a * b;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><code>pragma solidity &gt;=0.4.16 &lt;0.9.0;</code>：这是 Solidity 的版本声明，表示该合约适用于 Solidity 版本大于等于 0.4.16 且小于 0.9.0 的范围。</li>\n<li><code>contract Simple &#123; ... &#125;</code>：这是合约的定义，合约名为 <code>Simple</code>。在这个合约中，我们可以声明变量、编写函数等。</li>\n<li><code>function arithmetic(uint a, uint b) public pure returns (uint sum, uint product)</code>：这是一个公共函数 <code>arithmetic</code>，它接收两个无符号整数参数 <code>a</code> 和 <code>b</code>，并返回两个无符号整数结果 <code>sum</code> 和 <code>product</code>。<code>public</code> 关键字表示该函数可以被外部调用，而 <code>pure</code> 关键字表示该函数不会读取或修改合约的状态。</li>\n<li><code>sum = a + b;</code>：在函数体中，我们将参数 <code>a</code> 和 <code>b</code> 相加，将结果赋值给 <code>sum</code> 变量。</li>\n<li><code>product = a * b;</code>：我们将参数 <code>a</code> 和 <code>b</code> 相乘，将结果赋值给 <code>product</code> 变量。</li>\n<li>最后，函数结束，并返回 <code>sum</code> 和 <code>product</code>。</li>\n</ul>\n<p>这个合约的目的是接受两个数字作为输入，计算它们的和与积，并将结果返回给调用者。注意，由于 <code>pure</code> 关键字的使用，这个函数在计算过程中不会访问或修改合约状态，因此它可以被其他合约或外部调用者以低成本调用。</p>\n<h2 id=\"pure-关键字处理的函数，如果发生合约状态修改了，会怎样\"><a href=\"#pure-关键字处理的函数，如果发生合约状态修改了，会怎样\" class=\"headerlink\" title=\"pure 关键字处理的函数，如果发生合约状态修改了，会怎样\"></a>pure 关键字处理的函数，如果发生合约状态修改了，会怎样</h2><p>如果使用了 <code>pure</code> 关键字修饰的函数发生合约状态的修改，这将导致编译错误。<code>pure</code> 关键字明确表示该函数不会读取或修改合约的状态，因此任何尝试修改状态的操作都会被编译器拒绝。</p>\n<p>如果尝试在使用 <code>pure</code> 关键字修饰的函数中修改合约状态，编译器将产生错误消息，阻止合约的编译。开发者需要确保按照 <code>pure</code> 关键字的要求编写代码，以便在声明为 <code>pure</code> 的函数中不会发生对合约状态的修改。</p>\n<p>以下是一个示例，展示了在 <code>pure</code> 函数中修改合约状态的错误示例：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity &gt;&#x3D;0.4.16 &lt;0.9.0;\n\ncontract Simple &#123;\n    uint public counter &#x3D; 0;\n\n    function updateCounter() public pure &#123;\n        counter &#x3D; counter + 1;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，<code>updateCounter</code> 函数被声明为 <code>pure</code>，但是它尝试修改合约状态，将在编译时引发错误。运行上述合约代码将产生如下错误消息：<code>TypeError: Member &quot;increment&quot; not found or not visible after argument-dependent lookup in contract Simple.</code></p>\n<h2 id=\"view-和-pure-的区别\"><a href=\"#view-和-pure-的区别\" class=\"headerlink\" title=\"view 和 pure 的区别\"></a>view 和 pure 的区别</h2><p><code>view</code> 和 <code>pure</code> 是 Solidity 中用于状态修饰的关键字，它们有以下几个区别：</p>\n<ol>\n<li><p><code>view</code>：使用 <code>view</code> 修饰的函数表示该函数不会修改合约的状态，只会读取合约的数据。它可以被其他函数调用，包括 <code>view</code> 和非 <code>view</code> 函数。在一个 <code>view</code> 函数内部，可以调用其他 <code>view</code> 函数，但不能调用 <code>pure</code> 函数。可以认为 <code>view</code> 函数是只读函数，它提供了一种不修改状态的方式来访问合约的数据。</p>\n</li>\n<li><p><code>pure</code>：使用 <code>pure</code> 修饰的函数表示该函数既不会修改合约的状态，也不会读取合约的数据。它可以被其他函数调用，包括 <code>view</code> 和非 <code>view</code> 函数。在一个 <code>pure</code> 函数内部，可以调用其他 <code>pure</code> 函数，但不能调用 <code>view</code> 函数。<code>pure</code> 函数执行的操作仅基于传入的参数进行计算，而不依赖于合约中的任何状态。</p>\n</li>\n</ol>\n<p>总结来说，<code>view</code> 关键字适用于读取合约的数据状态，而 <code>pure</code> 关键字适用于只基于参数进行计算的函数，不涉及合约的状态读取或修改。</p>\n<p>以下是一个示例，展示了 <code>view</code> 和 <code>pure</code> 关键字的使用：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity &gt;&#x3D;0.4.16 &lt;0.9.0;\n\ncontract Simple &#123;\n    uint public counter &#x3D; 0;\n\n    function getCount() public view returns(uint) &#123;\n        return counter;\n    &#125;\n\n    function increment(uint value) public pure returns(uint) &#123;\n        return value + 1;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，<code>getCount</code> 函数被声明为 <code>view</code>，表示它仅用于读取合约的状态。而 <code>increment</code> 函数被声明为 <code>pure</code>，表示它仅对传入的参数进行计算，不依赖于合约的状态。</p>\n<h2 id=\"为什么这么设计？\"><a href=\"#为什么这么设计？\" class=\"headerlink\" title=\"为什么这么设计？\"></a>为什么这么设计？</h2><p>Solidity 语言中引入了 <code>view</code> 和 <code>pure</code> 关键字的设计是为了提供更加清晰和安全的状态修饰功能。</p>\n<ol>\n<li><p><strong>清晰性</strong>：通过在函数签名中使用 <code>view</code> 或 <code>pure</code> 关键字，合约的开发者和使用者可以清晰地了解一个函数是否会修改状态或读取状态。这样的标记使得代码更易于理解和维护。</p>\n</li>\n<li><p><strong>安全性</strong>：通过使用状态修饰关键字，Solidity 编译器可以进行静态分析和优化。合约中使用 <code>view</code> 关键字修饰的函数不会引起状态变动，因此可以在不同的调用之间进行缓存，并且可以并行执行，提高合约的效率和吞吐量。同时，使用 <code>pure</code> 关键字修饰的函数不会对状态或其他外部依赖产生影响，这有助于确保代码的功能和可预测性。</p>\n</li>\n</ol>\n<p>此外，这种设计还使得 Solidity 可以提供一些内置的安全机制，例如在一个 <code>view</code> 函数的上下文中调用另一个 <code>view</code> 函数时，编译器可以确保它不会导致无限循环。同样，调用一个 <code>view</code> 函数时，编译器也会确保该函数不会触发外部操作（如发送 Ether 或修改存储）。</p>\n<p>通过 <code>view</code> 和 <code>pure</code> 关键字的区分，Solidity 可以更好地支持函数的语义分析和编译器优化，从而提供更安全、高效和可靠的智能合约编程体验。</p>\n<h2 id=\"solidity-receive-有什么用\"><a href=\"#solidity-receive-有什么用\" class=\"headerlink\" title=\"solidity receive 有什么用\"></a>solidity receive 有什么用</h2><p>在 Solidity 中，<code>receive</code> 是一个特殊的函数，用于接收以太币（Ether）的转账。</p>\n<p>当合约接收到以太币转账时，如果合约中定义了 <code>receive</code> 函数，那么该函数将会被调用。<code>receive</code> 函数没有任何参数和返回值，并且默认为 <code>external</code> 可见性。</p>\n<p><code>receive</code> 函数的主要用途是接收以太币，而且它是相对简化的方式来处理转账。使用 <code>receive</code> 函数，您无需为接收以太币定义一个专用的函数签名（如 <code>fallback</code> 函数），而只需将逻辑直接放在 <code>receive</code> 函数中即可。</p>\n<p>以下是一个示例：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract MyContract &#123;\n    receive() external payable &#123;\n        &#x2F;&#x2F; 处理接收到的以太币\n        &#x2F;&#x2F; 可以在这里执行逻辑，存储状态或触发其他函数\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，当合约接收到以太币时，<code>receive</code> 函数将被调用。接收到的以太币将以可支付的方式传递给函数，可以访问 <code>msg.value</code> 来获取转账的数量。</p>\n<p>请注意，一个合约中只能有一个 <code>receive</code> 函数，且它必须是外部可见性。如果合约定义了 <code>receive</code> 函数，则不能再定义 <code>fallback</code> 函数或带有 <code>payable</code> 关键字的函数来接收以太币。</p>\n<h2 id=\"可以理解为勾子函数吗\"><a href=\"#可以理解为勾子函数吗\" class=\"headerlink\" title=\"可以理解为勾子函数吗\"></a>可以理解为勾子函数吗</h2><p>是的，你可以把 <code>receive</code> 函数看作是一个钩子（hook）函数，用于在合约接收以太币时执行特定的逻辑。当合约接收到以太币时，自动调用 <code>receive</code> 函数，类似于勾子函数的行为。</p>\n<p>勾子函数是在某个特定事件发生时自动触发的函数。在 Solidity 中，<code>receive</code> 函数可以看作是一个特殊的勾子函数，用于捕捉以太币转账事件。当有以太币转账到合约地址时，<code>receive</code> 函数将会被自动调用。</p>\n<p>通过定义 <code>receive</code> 函数，您可以在接收以太币的同时执行自定义的逻辑，例如更新合约的状态、触发其他函数或与用户进行交互等。它提供了一种方便的方式来处理以太币转账，并根据具体需求执行相应的操作。</p>\n<h2 id=\"solidity-Fallback-函数\"><a href=\"#solidity-Fallback-函数\" class=\"headerlink\" title=\"solidity Fallback 函数\"></a>solidity Fallback 函数</h2><p>Solidity 中的 <code>fallback</code> 函数是一个特殊的函数，它在合约接收到无法识别的函数调用或者未支付以太币时自动触发。 <code>fallback</code> 函数通常用于实现接收以太币或者未知调用的逻辑。</p>\n<p>以下是一个示例的 Solidity 合约，演示了如何使用 <code>fallback</code> 函数：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    &#x2F;&#x2F; fallback 函数\n    fallback() external payable &#123;\n        &#x2F;&#x2F; 在接收以太币时执行的逻辑\n        &#x2F;&#x2F; 可以选择在此处理其他币的转账，使用特定代币合约的 transfer 函数\n    &#125;\n&#125;</code></pre>\n\n<p>注意以下几点：</p>\n<ul>\n<li>fallback 函数没有任何参数。</li>\n<li>fallback 函数必须声明为 <code>external</code> 和 <code>payable</code>。</li>\n<li>fallback 函数只能有一个。</li>\n<li>fallback 函数不能接收函数参数或返回值，它只能处理以太币转账或其他特定逻辑。</li>\n</ul>\n<p>如果合约没有显式定义 <code>fallback</code> 函数，或者定义的 <code>fallback</code> 函数不是 <code>external payable</code>，则在接收未知函数调用或者以太币转账时会抛出异常。请注意，从 Solidity 0.6.0 版本开始，推荐使用 <code>fallback</code> 函数来替代旧版本中的 <code>fallback</code> 关键字。</p>\n<h2 id=\"solidity-fallback-也是勾子函数？\"><a href=\"#solidity-fallback-也是勾子函数？\" class=\"headerlink\" title=\"solidity fallback 也是勾子函数？\"></a>solidity fallback 也是勾子函数？</h2><p>是的，<code>fallback</code> 函数也可以被视为一种钩子函数，具体取决于如何使用它。在 Solidity 中，钩子函数是一种允许开发人员在合约的特定事件发生时插入逻辑的函数。</p>\n<p>当合约接收到无法识别的函数调用或者未支付以太币时，<code>fallback</code> 函数会被触发。这时你可以在 <code>fallback</code> 函数中编写特定的逻辑，以处理接收到的以太币或者执行其他需要的操作。</p>\n<p>因此，你可以将 <code>fallback</code> 函数视为合约中的一个钩子函数，用于处理未知调用或者以太币转账事件。通过在 <code>fallback</code> 函数中添加逻辑，你可以控制合约在这种情况下的行为。同时，这也使得 <code>fallback</code> 函数成为了一种用于扩展合约功能的强大工具。</p>\n<h2 id=\"还有哪些勾子函数\"><a href=\"#还有哪些勾子函数\" class=\"headerlink\" title=\"还有哪些勾子函数\"></a>还有哪些勾子函数</h2><p>除了 <code>fallback</code> 函数，Solidity 中还有其他几种常用的钩子函数：</p>\n<ol>\n<li><p><code>constructor</code> 函数：<code>constructor</code> 函数在合约部署时执行，并且只会执行一次。你可以在该函数中初始化合约的状态变量、执行必要的设置和操作。</p>\n</li>\n<li><p><code>receive</code> 函数：<code>receive</code> 函数用于接收以太币转账。当用户向合约地址转账时，如果没有指定函数调用，或者指定的函数调用无法匹配，将会触发 <code>receive</code> 函数。你可以在 <code>receive</code> 函数中编写逻辑以处理接收到的以太币。</p>\n</li>\n<li><p><code>fallback</code> 函数的变体：从 Solidity 0.6.0 开始，引入了两个新的变体函数 <code>fallback</code> 和 <code>receive</code>，以明确表示它们的用途。使用 <code>fallback</code> 函数来处理未知的函数调用，使用 <code>receive</code> 函数来处理以太币转账。这样做是为了增加合约的可读性和安全性。</p>\n</li>\n</ol>\n<p>注意：在 Solidity 0.8.0 版本之后，使用 <code>fallback</code> 函数作为默认的接收以太币函数已被弃用，应该明确使用 <code>receive</code> 函数来接收以太币。</p>\n<p>以上是 Solidity 中常见的钩子函数，它们可以在合约中用来添加特定的逻辑和处理不同的事件。</p>\n<h2 id=\"solidity-事件如何理解\"><a href=\"#solidity-事件如何理解\" class=\"headerlink\" title=\"solidity 事件如何理解\"></a>solidity 事件如何理解</h2><p>在 Solidity 中，事件（Event）是智能合约的一种重要机制，用于向区块链网络中的外部应用程序通知发生的特定事件。事件可以被视为合约中的观察者模式，用于实时通知关心这些事件的外部应用程序。</p>\n<p>事件提供了一种在智能合约中记录重要信息的方式，并且允许其他应用程序通过监听事件获得这些信息。当某个合约中的特定条件满足时，合约可以触发一个事件，并向区块链网络中广播该事件的内容。</p>\n<p>下面是一个简单的 Solidity 合约例子，其中定义了一个名为<code>MyContract</code>的合约，并声明了一个事件<code>MyEvent</code>：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity ^0.8.0;\n\ncontract MyContract &#123;\n    event MyEvent(uint256 indexed id, string message);\n\n    function triggerEvent(uint256 id, string memory message) public &#123;\n        emit MyEvent(id, message);\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，<code>MyEvent</code>是一个事件，它有两个参数：<code>id</code>和<code>message</code>。当<code>triggerEvent</code>函数被调用时，它会触发<code>MyEvent</code>事件，并向监听该合约的外部应用程序广播事件的内容。</p>\n<p>外部应用程序可以通过订阅该合约并监听事件来获取事件通知。通过监听事件，外部应用程序可以及时获取合约中的重要信息或状态变化，从而实现与合约的实时交互。</p>\n<p>总结起来，Solidity 中的事件可以被视为智能合约与外部世界之间进行通信的桥梁，使得合约可以主动通知外部应用程序发生的事情。通过事件，合约中的重要信息可以被记录和共享，实现更高效的去中心化应用程序开发。</p>\n<h2 id=\"就是发布订阅模式？\"><a href=\"#就是发布订阅模式？\" class=\"headerlink\" title=\"就是发布订阅模式？\"></a>就是发布订阅模式？</h2><p>是的，Solidity 中的事件可以类比为发布-订阅模式（Publish-Subscribe Pattern）。在该模式下，合约充当发布者，而外部应用程序则是订阅者。合约通过触发事件将信息发布到区块链网络上，而外部应用程序可以订阅事件并接收到发布的信息。</p>\n<p>类似于发布-订阅模式，事件的主要目的是为了实现解耦和异步通信。通过定义事件和触发事件，合约可以向外部应用程序发布重要信息，无需直接依赖或调用所关联的外部应用程序。外部应用程序可以根据自己的需求选择性地订阅事件，只处理感兴趣的信息。</p>\n<p>在 Solidity 中，合约定义了事件的结构和参数，而事件由合约的函数进行触发。触发事件后，事件的数据将被记录到区块链中，并通过链上的广播机制传播给所有关注该事件的外部应用程序。订阅者可以通过监听事件来获取事件数据，从而实现了合约与外部应用程序之间的实时通信。</p>\n<p>所以，可以说 Solidity 中的事件可以用发布-订阅模式来理解，它提供了一种可靠和高效的通信机制，使得合约与外部应用程序可以进行实时的信息交流。</p>\n<h2 id=\"所有的事件被触发后，都会被区块链会主动记录？\"><a href=\"#所有的事件被触发后，都会被区块链会主动记录？\" class=\"headerlink\" title=\"所有的事件被触发后，都会被区块链会主动记录？\"></a>所有的事件被触发后，都会被区块链会主动记录？</h2><p>是的，一旦合约中的事件被触发，事件的数据将会被主动记录到区块链中。这是因为区块链是一个去中心化的分布式账本，每个区块都包含了一些交易和状态变化。事件数据会作为交易的一部分，被写入区块并广播给网络中的节点。</p>\n<p>区块链的特点之一是不可篡改性，一旦事件数据被写入到区块中，就无法更改或删除。这确保了事件的不可变性和持久性。因此，无论何时触发一个事件，相应的数据都会被永久记录在区块链上，可以被任何人随时检索和验证。</p>\n<p>当外部应用程序订阅事件时，它们可以通过监听区块链中的新区块来获取最新的事件数据。通过区块链的共识机制，事件数据的可靠性和准确性得到了保证，不会因为单一节点或中心化系统的错误而丢失或篡改。这使得事件记录在区块链上成为一种可信的方式，用于实现去中心化应用程序和合约的可靠通信。</p>\n<h2 id=\"为什么-solidity-用-virtual-而不用-abstract\"><a href=\"#为什么-solidity-用-virtual-而不用-abstract\" class=\"headerlink\" title=\"为什么 solidity 用 virtual 而不用 abstract\"></a>为什么 solidity 用 virtual 而不用 abstract</h2><p>Solidity 使用 <code>virtual</code> 关键字而不使用 <code>abstract</code> 的原因是 Solidity 支持多继承，而 <code>abstract</code> 关键字通常用于单继承的面向对象编程语言。</p>\n<p>在 Solidity 中，<code>virtual</code> 关键字用于标记函数可以在子合约中被覆盖或重写。子合约可以选择是否要重写父合约中的虚函数，并且可以通过使用 <code>override</code> 关键字来明确指出重写。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">pragma solidity &gt;&#x3D;0.8.0 &lt;0.9.0;\n\ncontract Parent &#123;\n    function myFunction() public virtual &#123;\n        &#x2F;&#x2F; 一些实现逻辑\n    &#125;\n&#125;\n\ncontract Child is Parent &#123;\n    function myFunction() public virtual override &#123;\n        &#x2F;&#x2F; 重写父合约中的虚函数\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，父合约 <code>Parent</code> 中的 <code>myFunction()</code> 函数被标记为 <code>virtual</code>，表明它可以被子合约重写。然后，子合约 <code>Child</code> 继承了 <code>Parent</code> 合约，并使用 <code>override</code> 关键字来明确表明它正在重写父合约中的虚函数。</p>\n<p>这种设计允许 Solidity 中的多继承方式，其中一个合约可以继承多个基类，并对每个基类中的虚函数进行适当的重写。</p>\n<p>相比之下，<code>abstract</code> 关键字通常用于定义抽象类或接口，它们不提供实现，而是定义了一组要求子类必须实现的函数签名。然而，由于 Solidity 支持多继承和实现多个接口，因此没有直接使用 <code>abstract</code> 关键字的需求。</p>\n<p>总而言之，Solidity 选择使用 <code>virtual</code> 关键字以满足多继承和函数重写的需要，而不是使用 <code>abstract</code> 关键字来定义抽象类或接口。</p>\n<h2 id=\"solidity-外部函数-与-非外部函数的区别\"><a href=\"#solidity-外部函数-与-非外部函数的区别\" class=\"headerlink\" title=\"solidity 外部函数 与 非外部函数的区别\"></a>solidity 外部函数 与 非外部函数的区别</h2><p>在 Solidity 中，有两种类型的函数：外部函数（<code>external</code>）和非外部函数（默认为内部函数）。</p>\n<ol>\n<li><p>外部函数（<code>external</code>）</p>\n<ul>\n<li>外部函数只能通过外部调用的方式来访问，不能在合约内部直接调用。</li>\n<li>外部函数通常被用作合约的公共接口，供外部合约或外部账户使用。</li>\n<li>外部函数的调用者需要使用消息调用（message call）来触发函数执行。</li>\n<li>外部函数的 gas 开销较高，因为它们需要将所有函数参数从调用环境中复制到合约内部。</li>\n<li>外部函数不能访问合约的状态变量，但可以通过参数传递和返回值来进行交互。</li>\n</ul>\n</li>\n<li><p>非外部函数（默认为内部函数）</p>\n<ul>\n<li>非外部函数（默认为内部函数）可在合约内部直接调用。</li>\n<li>非外部函数的调用直接由 EVM 执行，而非通过消息调用。</li>\n<li>非外部函数的 gas 开销较低，因为参数和返回值在内部直接传递。</li>\n<li>非外部函数可以访问合约的状态变量和其他内部函数。</li>\n<li>非外部函数可以被其他函数调用，包括外部函数和内部函数。</li>\n</ul>\n</li>\n</ol>\n<p>总结起来，外部函数适用于合约的公共接口，供外部调用者使用，而非外部函数则用于合约内部的函数交互和状态变量访问。选择使用哪种类型的函数取决于合约的使用场景和需求。</p>\n<h2 id=\"solidity-require\"><a href=\"#solidity-require\" class=\"headerlink\" title=\"solidity require\"></a>solidity require</h2><p>在 Solidity 中，<code>require</code>是一个条件语句，用于检查函数执行或合约状态是否满足特定条件。如果条件不满足，<code>require</code>将抛出异常并中止函数执行。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">require(condition, errorMessage);</code></pre>\n\n<ul>\n<li><code>condition</code>是一个布尔表达式，表示需要满足的条件。</li>\n<li><code>errorMessage</code>是一个可选的字符串参数，用于在条件不满足时提供错误消息。</li>\n</ul>\n<p>下面是一个简单的示例，展示了<code>require</code>的使用：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract Example &#123;\n    uint public value;\n\n    function setValue(uint _newValue) public &#123;\n        &#x2F;&#x2F; 确保传入的新值小于100\n        require(_newValue &lt; 100, &quot;New value must be less than 100&quot;);\n        value &#x3D; _newValue;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>require</code>用于确保传入的新值小于 100。如果条件不满足，将中止函数执行并抛出包含错误消息的异常。使用<code>require</code>可以增强智能合约的安全性和可靠性，以确保合约在执行时符合预期的条件。</p>\n<h2 id=\"solidity-合约没有操作数据库，数据存哪里了？\"><a href=\"#solidity-合约没有操作数据库，数据存哪里了？\" class=\"headerlink\" title=\"solidity 合约没有操作数据库，数据存哪里了？\"></a>solidity 合约没有操作数据库，数据存哪里了？</h2><p>在 Solidity 合约中，数据不会直接存储在数据库中。相反，数据存储在合约的存储空间中，这是合约持久地存储数据的地方。</p>\n<p>Solidity 的存储空间是合约在区块链上的存储区域，可以将其视为合约的本地变量或状态变量。这些存储空间中的数据在合约生命周期内保持不变，无论是在读取还是更改数据。</p>\n<p>在 Solidity 合约中，可以定义各种类型的变量作为存储变量，如整数、浮点数、布尔值、地址以及自定义结构体等。这些存储变量会占用合约存储空间，并被持久保存在区块链上。</p>\n<p>以下是一个简单的示例，演示了存储变量的使用：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">contract Example &#123;\n    uint public value; &#x2F;&#x2F; 存储变量\n\n    function setValue(uint _newValue) public &#123;\n        value &#x3D; _newValue; &#x2F;&#x2F; 更新存储变量的值\n    &#125;\n\n    function getValue() public view returns (uint) &#123;\n        return value; &#x2F;&#x2F; 读取存储变量的值\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>value</code>是一个公共的存储变量，用于存储整数值。<code>setValue</code>函数可以更新<code>value</code>的值，而<code>getValue</code>函数可以读取<code>value</code>的值。这些数据存储在合约的存储空间中，并可以被其他函数和外部实体访问。</p>\n<p>需要注意的是，区块链是一个分布式和共享的系统，每个节点都会保存整个合约的存储空间。这确保了合约数据的不可篡改性和共享性。</p>\n<h2 id=\"存在变量上，就是持久的？\"><a href=\"#存在变量上，就是持久的？\" class=\"headerlink\" title=\"存在变量上，就是持久的？\"></a>存在变量上，就是持久的？</h2><p>是的，Solidity 中的存储变量是持久的，也就是说它们的值会永久保存在区块链上。</p>\n<p>当您在 Solidity 合约中声明一个存储变量时，该变量的值将持久保存在合约的存储空间中。无论是在合约内部还是外部调用合约，存储变量的值都会保留，并且在合约的整个生命周期内都可访问。</p>\n<p>这种持久性是区块链的关键优势之一，因为它确保了数据的不可篡改性和可验证性。一旦合约的存储变量被设置，其值将无法被修改，除非通过合约中的函数进行更新。</p>\n<p>需要注意的是，修改存储变量的值会涉及到交易的执行和矿工的共识过程。因此，在更新存储变量时，会产生相应的交易成本和执行时间。</p>\n<p>此外，区块链技术通常有不同的类型，例如：公有链、私有链和联盟链。在私有链或联盟链中，存储变量的持久性可能会受到特定配置和规则的限制。但在公有链上，存储变量的值是持久的，并且可以被所有参与区块链网络的节点验证和访问。</p>\n<h2 id=\"如果有几千万个区块，我要查我的合约中的数据，是不是很慢？\"><a href=\"#如果有几千万个区块，我要查我的合约中的数据，是不是很慢？\" class=\"headerlink\" title=\"如果有几千万个区块，我要查我的合约中的数据，是不是很慢？\"></a>如果有几千万个区块，我要查我的合约中的数据，是不是很慢？</h2><p>如果合约中的数据随着区块的增加而增加，那么查询最新的数据可能会比较快速，因为最新的数据通常会在区块链的最新区块中。</p>\n<p>然而，如果您需要查询早期的区块中的数据，可能会变得比较慢。因为区块链数据是线性存储的，要搜索特定数据需要遍历所有相关的区块。这会导致查询时间的增加，尤其是当区块链中存在大量的区块时。</p>\n<p>为了解决这个问题，您可以考虑使用事件日志。事件是 Solidity 合约中的一种可触发机制，用于记录特定操作的结果。将重要的数据变化记录在事件中，可以使您更方便地检索历史数据。通过查询事件，您可以跳过遍历整个区块链的过程，从而加快数据查询的速度。</p>\n<p>此外，您还可以考虑使用外部数据存储解决方案，如 IPFS 或其他数据库。这些解决方案可以将合约中的数据存储在外部位置，并提供更快速的查询和访问。</p>\n<p>综上所述，查询合约中数据的速度可能会取决于区块链的规模和数据的存储方式。尽管查询早期区块的数据可能会较慢，但通过合理的数据组织和选择适当的查询方法，您可以优化查询速度并更高效地获取合约中的数据。</p>\n<h2 id=\"直接存到自己外部服务器上？\"><a href=\"#直接存到自己外部服务器上？\" class=\"headerlink\" title=\"直接存到自己外部服务器上？\"></a>直接存到自己外部服务器上？</h2><p>是的，您可以将合约中的数据存储到自己的外部服务器上。这样做的好处是，您可以根据自己的需求和服务器性能来定制数据存储和查询方式，从而获得更高的灵活性和性能。</p>\n<p>以下是一种可能的方案：</p>\n<ol>\n<li><p>提交数据到合约：当有数据需要存储时，您可以通过向合约发送事务来提交数据。</p>\n</li>\n<li><p>合约处理事务：合约可以验证和处理事务中的数据，并将其存储到外部服务器。</p>\n</li>\n<li><p>存储到外部服务器：合约可以通过与外部服务器进行通信，将数据传输到指定的外部服务器。您可以使用 HTTP 请求、API 或其他通信协议来完成这个过程。</p>\n</li>\n<li><p>数据存储和查询：外部服务器将数据存储在适合您的需求的数据结构中。您可以使用标准的数据库系统（例如 MySQL、PostgreSQL）或分布式存储系统（例如 IPFS）来存储数据。存储在外部服务器上的数据可以通过适当的查询接口进行检索。</p>\n</li>\n</ol>\n<p>通过将数据存储在自己的外部服务器上，您可以根据需求进行优化和扩展，提高数据的存储和查询效率。同时，您也可以通过备份和冗余机制来提高数据的安全性。请注意，在使用外部服务器存储数据时，确保数据传输和存储的安全性，以防止未经授权的访问和篡改。</p>\n<h2 id=\"合约只能读写自己的存储？\"><a href=\"#合约只能读写自己的存储？\" class=\"headerlink\" title=\"合约只能读写自己的存储？\"></a>合约只能读写自己的存储？</h2><img src=\"http://t-blog-images.aijs.top/img/202307211728914.webp\" />\n\n<h2 id=\"solidity-合约只能读写存储区内属于自己的部分-如果想读其他合约的存储区怎么办？\"><a href=\"#solidity-合约只能读写存储区内属于自己的部分-如果想读其他合约的存储区怎么办？\" class=\"headerlink\" title=\"solidity 合约只能读写存储区内属于自己的部分,如果想读其他合约的存储区怎么办？\"></a>solidity 合约只能读写存储区内属于自己的部分,如果想读其他合约的存储区怎么办？</h2><p>在 Solidity 中，合约只能读写和操作本合约的存储区，无法直接读取其他合约的存储区。这是为了确保安全性和隐私性。每个合约都拥有自己的存储空间，并且可以使用<code>storage</code>关键字来定义和访问存储变量。</p>\n<p>如果您想读取其他合约的存储区，有两种常见的方法：</p>\n<ol>\n<li><p>通过接口调用：如果其他合约实现了可调用的接口，您可以通过在您的合约中调用该接口来请求数据。其他合约可以在接口函数中实现读取操作，并返回所需的数据。注意，这种方法需要与其他合约进行协调和约定。</p>\n</li>\n<li><p>使用事件日志：如果其他合约定义了事件（event），您可以订阅这些事件并监听日志输出。当事件被触发时，可以从日志中提取所需的数据。</p>\n</li>\n</ol>\n<p>当与其他合约交互时，请确保已经对交互进行了充分的测试和安全审核，以防止潜在的漏洞和攻击。同时，尊重其他合约的隐私权和协议规定，在未经授权的情况下不要访问其存储区或执行不当的操作。</p>\n<h2 id=\"日志可能会不准吧\"><a href=\"#日志可能会不准吧\" class=\"headerlink\" title=\"日志可能会不准吧\"></a>日志可能会不准吧</h2><p>是的，日志可以被视为一种间接的方式来获取其他合约的数据，因此在某些情况下可能不够准确或实时。依赖事件日志的方法存在一定的延迟，因为需要等待事件被触发并写入日志。</p>\n<p>另外，需要注意的是，事件日志中的数据通常是经过编码和压缩的，读取这些数据可能需要进行相应的解码操作。这也增加了读取数据的复杂性。</p>\n<p>除了上述提到的使用接口调用和事件日志进行数据获取的方法外，目前在 Solidity 中没有直接访问其他合约存储区的方法。这是出于安全和隐私考虑，保护合约之间的数据隔离和权限控制。</p>\n<p>如果您需要从多个合约中共享数据，一种常见的做法是在需要共享的数据上定义一个公共状态变量，并使用存取函数（getter 和 setter）来访问和修改数据。这样，其他合约可以通过调用这些存取函数来读取和写入数据。</p>\n<p>请记住，在设计和开发合约之前，要仔细考虑数据隔离和访问权限的安全性，确保在与其他合约交互时不会引入潜在的漏洞或安全风险。</p>\n<h2 id=\"不让读写其他的合约，岂不是每个合约又是一个中心化？\"><a href=\"#不让读写其他的合约，岂不是每个合约又是一个中心化？\" class=\"headerlink\" title=\"不让读写其他的合约，岂不是每个合约又是一个中心化？\"></a>不让读写其他的合约，岂不是每个合约又是一个中心化？</h2><p>不一定。尽管不直接允许合约之间读写对方的数据，但区块链的去中心化特性确保了每个合约在其自己的账本上运行，并且通过智能合约的互操作性可以实现合约之间的通信和协作。</p>\n<p>这种限制的设计是出于安全和隐私的考虑，以确保每个合约的数据隔离和权限控制。合约之间的数据共享可以通过事件日志和接口调用来间接实现。每个合约可以发布事件日志，其他合约可以订阅这些事件来获取所需的数据。此外，合约可以定义接口函数，让其他合约调用这些函数来进行数据读取。</p>\n<p>虽然合约之间的数据共享受到一些限制，但在智能合约开发中，可以借助全局变量、事件日志、外部调用等方式来实现分布式系统的逻辑。关键是在设计合约时要考虑到数据的安全性、隐私保护和权限控制，以确保整个系统的去中心化特性得以保留。通过智能合约的规范和标准化，合约之间的互操作性也得以促进。</p>\n<h2 id=\"一个合约是一个中心化？\"><a href=\"#一个合约是一个中心化？\" class=\"headerlink\" title=\"一个合约是一个中心化？\"></a>一个合约是一个中心化？</h2><p>一个合约本身并不一定是中心化的。智能合约是由代码编写的自动执行的合约，它们运行在区块链上。合约的中心化或去中心化特性取决于所选择的区块链平台和合约的设计。</p>\n<p>在公有区块链平台上，如以太坊和比特币等，智能合约是分布式的，存在于多个节点上，并由共识算法保证合约的执行是公正和可信的。这使得合约的执行结果不受单个中心化实体的控制，而是由整个网络共同验证和执行。因此，这种情况下的智能合约可以被认为是去中心化的。</p>\n<p>然而，在私有区块链或许可区块链中，合约的情况可能有所不同。私有区块链是由特定实体或组织控制和管理的，这可能导致合约的执行受到中心化实体的影响。在这种情况下，合约的中心化程度取决于区块链网络的设置和参与方之间的信任模型。</p>\n<p>总的来说，一个合约本身不是中心化的，而是在所选择的区块链环境中运行。合约的中心化或去中心化特性取决于区块链平台的性质和设计。在公有区块链上，智能合约通常是去中心化的，但在私有区块链中，中心化的元素可能存在。</p>\n<h2 id=\"公链是透明的，那么合约可以读-x2F-写公链数据？\"><a href=\"#公链是透明的，那么合约可以读-x2F-写公链数据？\" class=\"headerlink\" title=\"公链是透明的，那么合约可以读&#x2F;写公链数据？\"></a>公链是透明的，那么合约可以读&#x2F;写公链数据？</h2><p>是的，智能合约可以读取和写入公链上的数据。在公有区块链上，智能合约是在所有参与节点上执行的，这使得合约的执行结果和数据对于所有人都是可见和透明的。</p>\n<p>智能合约可以通过调用公链的 API 或内置函数来读取与合约相关的数据。这些数据可能包括账户余额、交易记录、区块信息等。合约也可以使用写入操作将数据写入公链上。</p>\n<p>例如，在以太坊上，智能合约可以使用 Solidity 编程语言编写，通过调用以太坊提供的函数和变量来读取和写入以太坊的数据。合约可以读取公链的状态，并根据该状态执行特定的逻辑。</p>\n<p>需要注意的是，在许多公有区块链上，执行合约的操作需要支付一些费用，称为燃气费。这是为了防止滥用和确保网络的正常运行。因此，合约执行的读写操作通常需要支付一定数量的燃气费用。</p>\n<p>总结来说，智能合约可以读取和写入公链上的数据，从而实现透明、公平和可信的业务逻辑。这也是区块链技术的一个关键优势之一。</p>\n<h2 id=\"合约可以读写参与者数据？\"><a href=\"#合约可以读写参与者数据？\" class=\"headerlink\" title=\"合约可以读写参与者数据？\"></a>合约可以读写参与者数据？</h2><p>我很抱歉，之前的回答有一点不准确。智能合约一般是无法直接读写参与者的数据的。智能合约主要用于处理自身存储区中的数据，而无法直接访问和修改其他参与者的数据。</p>\n<p>智能合约中的代码可以读取外部数据，如区块链上的区块信息和其他合约的公共数据。但对于参与者的私有数据，智能合约是无法直接访问的。参与者可以选择向合约公开一部分数据，以便合约可以读取和处理它们，但这是在参与者自愿的基础上进行的。</p>\n<p>相反，参与者可以调用合约中定义的函数来与合约进行交互，并根据合约的逻辑和规则来更新他们自己的数据。合约可以对这些数据进行验证和处理，但不能直接修改参与者的数据。</p>\n<p>总之，智能合约能够读取和处理存储在区块链上的数据，但不能直接读取或修改参与者的私有数据。合约的参与者可以根据合约定义的规则与合约进行交互，并根据合约的逻辑来更新他们自己的数据。</p>\n<h2 id=\"参与者可以读合约数据？\"><a href=\"#参与者可以读合约数据？\" class=\"headerlink\" title=\"参与者可以读合约数据？\"></a>参与者可以读合约数据？</h2><p>是的，参与者可以读取智能合约中的公开数据。智能合约中的公开数据是指对所有参与者可见和访问的数据。这些数据可以通过调用合约中的相应函数来读取。</p>\n<p>智能合约通常会定义一些公开的访问函数，用于查询合约中存储的数据。例如，一个智能合约可能包含一个公开的函数，用于查询合约中的某个变量的值。参与者可以调用这个公开函数，并通过返回值来获得合约中存储的数据。</p>\n<p>需要注意的是，不是合约中的所有数据都是公开的，有些数据可能被定义为私有或受限制的。只有合约的创建者或特定的参与者才能访问这些私有数据。</p>\n<p>总结起来，合约中的公开数据可以被参与者读取，而私有数据则只能被特定的参与者或合约本身访问。</p>\n<h2 id=\"合约的参与者是如何定义的？\"><a href=\"#合约的参与者是如何定义的？\" class=\"headerlink\" title=\"合约的参与者是如何定义的？\"></a>合约的参与者是如何定义的？</h2><p>合约的参与者是指与智能合约进行交互的个体或实体，也称为合约的用户或使用者。参与者可以包括以下几种类型：</p>\n<ol>\n<li><p>发起者（Creator）：合约的发起者是指创建合约的实体。发起者是合约的初始拥有者，并且通常具有特殊的权限，例如可以修改合约的状态或终止合约。</p>\n</li>\n<li><p>用户（User）：用户是指与智能合约进行交互的个体。用户可以是任何拥有访问该合约的能力的人或实体。他们可以调用合约的函数、读取合约中的数据或修改合约的状态，以完成特定的操作。</p>\n</li>\n<li><p>外部合约（External Contract）：智能合约可以与其他合约进行交互。这些外部合约也被视为合约的参与者，因为它们可以调用当前合约的函数或与其进行数据交换。</p>\n</li>\n<li><p>区块链网络（Blockchain Network）：合约的参与者也可以是整个区块链网络中的其他参与节点。这些节点可以参与合约的验证和执行过程，确保合约的正确运行。他们可能负责验证交易、维护网络共识和执行合约代码。</p>\n</li>\n</ol>\n<p>需要注意的是，参与者的权限和功能可能会根据合约的实际需求和设计而有所不同。智能合约的开发者可以根据需要定义和管理合约的参与者，并为他们分配相应的权限和角色。</p>\n<h2 id=\"参与者只能看到合约公开的数据，看上去不是全透明\"><a href=\"#参与者只能看到合约公开的数据，看上去不是全透明\" class=\"headerlink\" title=\"参与者只能看到合约公开的数据，看上去不是全透明\"></a>参与者只能看到合约公开的数据，看上去不是全透明</h2><p>是的，参与者在智能合约中只能看到合约公开的数据。智能合约的设计可以包含公开的函数和数据，以便参与者可以对其进行访问和交互。公开的函数允许参与者执行特定的操作，而公开的数据则允许参与者查看合约的状态或特定的数据字段。</p>\n<p>然而，智能合约中可能还存在一些私有的函数和数据。私有函数和数据对于外部参与者来说是不可见的，只有合约内部可以访问和使用。这样可以确保在合约的操作过程中保护敏感数据的隐私性和安全性。</p>\n<p>需要注意的是，尽管参与者只能看到合约公开的数据，但所有参与者都可以通过区块链的不可变性来验证合约的历史记录和执行过程。这使得合约的整体运行过程对于所有参与者来说是透明的，确保了合约的诚信和可验证性。</p>\n<h2 id=\"参与者如何验证历史记录和执行过程？\"><a href=\"#参与者如何验证历史记录和执行过程？\" class=\"headerlink\" title=\"参与者如何验证历史记录和执行过程？\"></a>参与者如何验证历史记录和执行过程？</h2><p>参与者可以通过区块链浏览器查看公开的交易历史和合约状态，以验证智能合约的历史记录和执行过程的透明性。此外，他们还可以审查合约的源代码来确认合约的规则和逻辑是否按预期运行。</p>\n<h2 id=\"参与者大都是技术小白，应该也看不懂吧\"><a href=\"#参与者大都是技术小白，应该也看不懂吧\" class=\"headerlink\" title=\"参与者大都是技术小白，应该也看不懂吧\"></a>参与者大都是技术小白，应该也看不懂吧</h2><p>是的，作为技术小白，参与者可能无法理解完整的区块链技术细节。然而，他们仍然可以从简化的角度了解区块链的功能和优势。以下是简化的解释:</p>\n<ul>\n<li><p><strong>透明性</strong>：区块链提供了公开和可验证的交易历史记录，任何人都可以查看。这意味着参与者可以信任交易的可靠性和透明性，而无需依赖中心化的机构或第三方进行确认。</p>\n</li>\n<li><p><strong>去中心化</strong>：区块链是一个分布式网络，没有单一的中心机构控制和管理数据。这意味着没有人可以单方面更改或操纵数据，而且如果某个节点发生故障，网络仍然可以正常运行。</p>\n</li>\n<li><p><strong>智能合约</strong>：区块链上的智能合约是预先编程的代码，可以自动执行合约中设定的规则和条件。智能合约的执行过程是透明的，参与者可以信任合约按照代码的规定进行操作，而无需担心篡改或欺骗。</p>\n</li>\n<li><p><strong>安全性</strong>：区块链使用加密技术保护数据的安全性和完整性。交易经过加密，确保了数据的保密性，同时使用散列算法和区块链接保证了数据的不可篡改性和可追溯性。</p>\n</li>\n</ul>\n<p>尽管参与者不必深入了解区块链技术的底层细节，但了解这些简化的概念可以帮助他们理解区块链的基本原理和优势。</p>\n<h2 id=\"如果区块链的维护者，删库跑路了怎么办？\"><a href=\"#如果区块链的维护者，删库跑路了怎么办？\" class=\"headerlink\" title=\"如果区块链的维护者，删库跑路了怎么办？\"></a>如果区块链的维护者，删库跑路了怎么办？</h2><p>如果区块链的维护者删库跑路，这会带来一些挑战。在大多数公开和去中心化的区块链网络中，维护者通常是分布在全球各地的节点运营者，因此单个维护者的离开并不会导致整个网络的崩溃。然而，这可能会对数据的可访问性和进一步的发展产生一些影响。</p>\n<p>下面是一些应对该情况的可能措施：</p>\n<ol>\n<li><p><strong>节点迁移</strong>：协议可以允许其他节点接替离开的节点的维护角色，从而确保网络的连续性。节点迁移过程可能需要社区的共同努力和共识，以确保新节点能够正常运行并继续网络的维护。</p>\n</li>\n<li><p><strong>镜像备份</strong>：社区中的其他节点可能已经创建了备份的副本数据。这些备份可以用来恢复遗失的数据，以保证区块链的连贯性。</p>\n</li>\n<li><p><strong>重新构建</strong>：如果原始维护者无法回归，并且没有可靠的备份数据，可能需要重新构建区块链。这将需要参与者共同合作，创建新的区块链网络，并努力恢复过去的数据。</p>\n</li>\n<li><p><strong>审计和监管</strong>：加强对区块链项目的审计和监管，可以减少诸如删库跑路等潜在问题的发生。通过确保透明度和监管机构的监督，可以降低欺诈行为发生的风险。</p>\n</li>\n</ol>\n<p>需要注意，不同的区块链网络可能采取不同的措施来解决这种问题，具体应对方法取决于每个区块链网络的设计和社区的共识。总体而言，区块链的去中心化特点使得单个维护者的行为对整个网络的影响较小，而社区的合作和技术手段可以帮助应对可能出现的问题。</p>\n<h2 id=\"有补救措施？\"><a href=\"#有补救措施？\" class=\"headerlink\" title=\"有补救措施？\"></a>有补救措施？</h2><p>当区块链的维护者删库跑路时，以下是一些可能的补救措施：</p>\n<ol>\n<li><p><strong>社区共识和治理</strong>：区块链项目通常依赖于社区的力量和共识。在这种情况下，社区成员可以共同商讨并找到解决方案。通过透明的讨论和投票，社区可以选举新的维护者，或者重新设计区块链以修复损失的数据。</p>\n</li>\n<li><p><strong>备份数据</strong>：每个参与者都应该定期进行数据备份，以防止个别维护者的数据丢失。如果备份数据在维护者离开时可用，那么新的维护者可以使用备份数据来恢复区块链。</p>\n</li>\n<li><p><strong>技术审计和安全性</strong>：在选择参与任何区块链项目之前，进行技术审计和安全性评估是非常重要的。评估区块链项目的安全性、稳定性和可信度，以减少不可预测的风险。</p>\n</li>\n<li><p><strong>多样化的节点运营者</strong>：鼓励更多的节点参与者加入维护网络，这样可以降低个别维护者的离开对整个网络造成的损害。多样化的节点运营者可以提高区块链的去中心化程度，并增加网络的韧性。</p>\n</li>\n<li><p><strong>减少依赖性</strong>：降低对单个维护者的依赖，可以通过多节点备份、多节点共识机制等方式实现。这样一来，即使一个维护者离开，其他节点仍然能够继续维护区块链的运行。</p>\n</li>\n</ol>\n<p>需要强调的是，补救措施将根据具体情况和区块链项目的设计而有所不同。正确认识和减轻可能的风险，并与社区共同努力，是应对该问题的关键。</p>\n<h2 id=\"补救数据要付费吗\"><a href=\"#补救数据要付费吗\" class=\"headerlink\" title=\"补救数据要付费吗\"></a>补救数据要付费吗</h2><p>补救数据是否需要付费取决于具体的情况和所采取的补救措施。</p>\n<p>如果数据已经在维护者离开之前被备份，并且备份数据可用，那么使用备份数据来恢复区块链通常不需要额外费用。</p>\n<p>然而，如果没有备份数据，或者需要进行数据恢复、数据重建或类似的复杂工作，可能需要额外的费用。这些费用可能涉及到技术审计、数据恢复专家的聘请，或者其他相关的服务。</p>\n<p>具体情况可能各不相同，如果发生了这样的问题，建议与相关的维护者、社区或专业的数据恢复专家进一步商讨，以了解所需的补救措施和相关费用。</p>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><p>下面是一个使用 Solidity 的代码示例，演示了外部函数和非外部函数的区别：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">&#x2F;&#x2F; SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract FunctionExample &#123;\n    uint private myNumber;\n\n    function setNumber(uint _num) external &#123;\n        myNumber &#x3D; _num;\n    &#125;\n\n    function getNumber() public view returns (uint) &#123;\n        return myNumber;\n    &#125;\n\n    function internalFunction(uint _num) internal pure returns (uint) &#123;\n        return _num * 2;\n    &#125;\n\n    function externalFunction(uint _num) external pure returns (uint) &#123;\n        return _num + 5;\n    &#125;\n&#125;</code></pre>\n\n<p>上述代码中的 <code>FunctionExample</code> 合约包含两个函数：<code>internalFunction</code> 和 <code>externalFunction</code>。其中，<code>internalFunction</code> 是一个内部函数，默认为内部函数，可以被合约内部的其他函数调用。而 <code>externalFunction</code> 则是一个外部函数，通过外部调用的方式来访问。</p>\n<p>在这个示例中，<code>setNumber</code> 是一个外部函数，可以从外部合约或外部账户调用来设置 <code>myNumber</code> 的值。而 <code>getNumber</code> 是一个非外部函数（默认为内部函数），只能在合约内部直接调用，用于返回 <code>myNumber</code> 的值。</p>\n<p><code>internalFunction</code> 和 <code>externalFunction</code> 都是纯函数（<code>pure</code>），没有修改合约的状态变量。<code>internalFunction</code> 是内部函数，可以被其他函数调用，而 <code>externalFunction</code> 是外部函数，可以通过外部调用来访问。</p>\n<p>请注意，为了使示例代码能够成功编译和执行，你需要使用 Solidity 0.8.0 或更高版本。</p>\n<h1 id=\"我的理解\"><a href=\"#我的理解\" class=\"headerlink\" title=\"我的理解\"></a>我的理解</h1><h2 id=\"我编写的合约和其他人编写的合约是两个程序，两个程序是运行在区块链上的，程序之间的通信是合约之间的数据传递\"><a href=\"#我编写的合约和其他人编写的合约是两个程序，两个程序是运行在区块链上的，程序之间的通信是合约之间的数据传递\" class=\"headerlink\" title=\"我编写的合约和其他人编写的合约是两个程序，两个程序是运行在区块链上的，程序之间的通信是合约之间的数据传递\"></a>我编写的合约和其他人编写的合约是两个程序，两个程序是运行在区块链上的，程序之间的通信是合约之间的数据传递</h2><p>是的，您理解得很准确。在区块链上，合约是以智能合约的形式部署和运行的计算机程序。合约之间可以进行数据传递和通信。</p>\n<p>当一个合约调用另一个合约时，数据可以通过函数参数和返回值进行传递。调用合约的函数可以将数据作为参数传递给被调用合约的函数，被调用合约的函数可以通过返回值将处理结果传递回调用合约。</p>\n<p>以下是一个合约之间数据传递的示例代码：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">&#x2F;&#x2F; 合约A\ncontract ContractA &#123;\n    uint public data;\n\n    function setData(uint _data) public &#123;\n        data &#x3D; _data;\n        &#x2F;&#x2F; 调用合约B的setData函数\n        ContractB(contractBAddress).setData(data);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 合约B\ncontract ContractB &#123;\n    uint public data;\n\n    function setData(uint _data) public &#123;\n        data &#x3D; _data;\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的示例中，合约 A 中的<code>setData</code>函数在设置<code>data</code>变量的同时也调用了合约 B 的<code>setData</code>函数。<code>data</code>变量的值通过函数参数在合约之间进行传递。</p>\n<p>需要注意的是，在合约之间进行通信时，您需要提供目标合约的地址。在示例中，<code>contractBAddress</code>是指向合约 B 的地址，当然您需要先获得该地址。</p>\n<p>通过合约之间的数据传递和通信，您可以实现更复杂的应用逻辑，实现合约之间的协作和互操作性。</p>\n<h2 id=\"也就是说开发的合约其实是嵌入到区块链上执行的脚本？\"><a href=\"#也就是说开发的合约其实是嵌入到区块链上执行的脚本？\" class=\"headerlink\" title=\"也就是说开发的合约其实是嵌入到区块链上执行的脚本？\"></a>也就是说开发的合约其实是嵌入到区块链上执行的脚本？</h2><p>是的，智能合约实际上是在区块链上执行的脚本。它们是以编程语言（如 Solidity）编写的计算机程序，部署到区块链上并在整个网络中运行。</p>\n<p>智能合约可以包含定义变量、函数、事件和修饰器等元素，同时也可以执行逻辑判断、循环、数据持久化等操作。当合约被部署到区块链上后，它会被复制到每一个节点上，并且所有的节点都会执行相同的代码逻辑，以达到共识。</p>\n<p>智能合约在区块链上执行的好处是具有去中心化和不可篡改性。由于合约的代码在整个网络中都是公开可见的，所有人都可以验证合约的逻辑和操作。此外，合约的执行是由区块链网络中的节点共同验证和执行的，没有单一的中心化控制。</p>\n<p>因此，智能合约具有安全性和可靠性，可以实现诸如数字货币交易、去中心化应用（DApps）等功能。同时，它们也提供了一种可编程的方式来在区块链上实现自动化的业务逻辑和条件执行。</p>\n<h2 id=\"说白了，区块链就是类似服务器在运行\"><a href=\"#说白了，区块链就是类似服务器在运行\" class=\"headerlink\" title=\"说白了，区块链就是类似服务器在运行\"></a>说白了，区块链就是类似服务器在运行</h2><p>区块链可以被看作是一个分布式的计算机系统，其中的节点彼此连接并共同参与到网络中。每个节点都运行着相同的区块链软件，并共同维护着一个不可篡改的、去中心化的账本。</p>\n<p>从这个角度来看，可以将区块链比作一个分布式的服务器网络。然而，与传统的中心化服务器不同，区块链是由众多节点共同参与管理的，而不依赖于单一的实体或组织。节点在网络中通过共识算法一致地达成一致，并共同维护和更新区块链的状态。</p>\n<p>在区块链上执行的智能合约可以被视为类似于服务器上运行的脚本或应用程序。这些合约在整个网络中复制并执行，每个节点都会验证和执行相同的合约代码。而且，智能合约的执行是确定性的，每个节点都会按照相同的规则对交易进行验证和执行。</p>\n<p>然而，与传统的中心化服务器不同，区块链的去中心化特性使得其具有更高的安全性和抗攻击能力。同时，由于区块链的透明性和可验证性，它还提供了更高的可信度和防篡改性。因此，区块链比简单的服务器更具有分散性和可靠性。</p>\n<h2 id=\"多个合约可以在一起发布\"><a href=\"#多个合约可以在一起发布\" class=\"headerlink\" title=\"多个合约可以在一起发布\"></a>多个合约可以在一起发布</h2><p>是的，在 Solidity 中，可以将多个合约组合在一起，并在同一个交易中进行发布。这个过程被称为合约库。</p>\n<p>合约库允许将可重用的功能和逻辑封装到单独的合约中，然后在其他合约中进行使用。它有助于提高代码的可维护性和可复用性。</p>\n<p>以下是一个示例，展示了如何在一个发布交易中包含多个合约：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">&#x2F;&#x2F; 合约库1\ncontract Library1 &#123;\n    function func1() public pure returns (uint256) &#123;\n        return 1;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 合约库2\ncontract Library2 &#123;\n    function func2() public pure returns (uint256) &#123;\n        return 2;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 主合约\ncontract MyContract &#123;\n    Library1 public lib1;\n    Library2 public lib2;\n\n    constructor() &#123;\n        lib1 &#x3D; new Library1();\n        lib2 &#x3D; new Library2();\n    &#125;\n\n    function getValues() public view returns (uint256, uint256) &#123;\n        return (lib1.func1(), lib2.func2());\n    &#125;\n&#125;</code></pre>\n\n<p>在这个例子中，我们定义了两个合约库 <code>Library1</code> 和 <code>Library2</code>，它们分别具有 <code>func1</code> 和 <code>func2</code> 这两个函数。然后，我们在 <code>MyContract</code> 主合约的构造函数中创建了这两个合约库的实例。</p>\n<p>在主合约中，我们可以通过这两个实例来调用合约库的函数。例如，在 <code>getValues</code> 函数中，我们分别调用了 <code>lib1.func1()</code> 和 <code>lib2.func2()</code>。这样，我们可以在同一个合约中使用多个合约库的功能。</p>\n<p>注意，当在一个发布交易中包含多个合约时，每个合约都会有自己的地址，并且可以通过该地址来访问和调用它们的函数。</p>\n<p>总结起来，Solidity 允许将多个合约组合在一起发布，以便在同一个交易中使用它们。这有助于将代码模块化并提高代码的可维护性和可复用性。</p>\n","text":"为什么搞了个 solidity 语言，golang rust 不能满足需要吗Solidity 是一种专门用于智能合约开发的编程语言，它在以太坊和其他以太坊兼容区块链平台上广泛使用。当开发者想要在以太坊平台上构建去中心化应用程序（DApps）或编写智能合约时，Solidity 是一...","link":"","photos":[],"count_time":{"symbolsCount":"51k","symbolsTime":"47 mins."},"categories":[{"name":"区块链","slug":"区块链","count":1,"path":"api/categories/区块链.json"}],"tags":[{"name":"区块链","slug":"区块链","count":1,"path":"api/tags/区块链.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%90%9E%E4%BA%86%E4%B8%AA-solidity-%E8%AF%AD%E8%A8%80%EF%BC%8Cgolang-rust-%E4%B8%8D%E8%83%BD%E6%BB%A1%E8%B6%B3%E9%9C%80%E8%A6%81%E5%90%97\"><span class=\"toc-text\">为什么搞了个 solidity 语言，golang rust 不能满足需要吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Solidity-%E8%AF%AD%E6%B3%95%E5%80%9F%E9%89%B4%E4%BA%86%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">Solidity 语法借鉴了哪些编程语言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F\"><span class=\"toc-text\">状态变量？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%90%88%E7%BA%A6%EF%BC%9F\"><span class=\"toc-text\">为什么叫合约？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">solidity 语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Function-Modifiers\"><span class=\"toc-text\">Function Modifiers</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%9Cundefined%E2%80%9D%E6%88%96%E2%80%9Cnull%E2%80%9D%E5%80%BC%E7%9A%84%E6%A6%82%E5%BF%B5%E5%9C%A8-Solidity-%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">“undefined”或“null”值的概念在 Solidity 中不存在</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%82%AC%E7%A9%BA%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">solidity 有哪些会出现悬空引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E6%82%AC%E7%A9%BA%EF%BC%9F\"><span class=\"toc-text\">我该如何确定一个引用是否悬空？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E6%9C%89%E8%A7%84%E5%88%99%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">没有规则吗？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">代码示例分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mapping-types\"><span class=\"toc-text\">mapping-types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iterable-mappings\"><span class=\"toc-text\">iterable-mappings</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#solidity\"><span class=\"toc-text\">solidity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%BA%A6%E7%BB%93%E6%9E%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%88%90%E7%B1%BB%EF%BC%9F\"><span class=\"toc-text\">合约结构 为什么设计成类？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">地址字面量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%97%E6%AF%8D%E9%99%90%E5%88%B6%E5%9C%A8-A-F\"><span class=\"toc-text\">为什么字母限制在 A-F</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%87%87%E7%94%A8-32-%E8%BF%9B%E5%88%B6\"><span class=\"toc-text\">为什么不采用 32 进制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bytes\"><span class=\"toc-text\">bytes</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E7%9C%8B%E7%9C%8B%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84\"><span class=\"toc-text\">举个例子看看是怎么使用的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">solidity 引用数据类型有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#memory%EF%BC%9Astorage-%E5%92%8C-calldata\"><span class=\"toc-text\">memory：storage 和 calldata</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">例子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#uint-calldata-data-%E5%86%99%E6%88%90-uint-data-%E5%8F%AF%E4%BB%A5%E5%90%97\"><span class=\"toc-text\">uint[] calldata _data 写成 uint[] _data 可以吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">solidity 结构体是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">结构体不能继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%82%A3%E8%BF%99%E7%9C%8B%E4%B8%8A%E5%8E%BB%E4%B8%8E-golang-stuct-%E5%B7%AE%E5%88%AB%E5%BE%88%E5%A4%A7\"><span class=\"toc-text\">那这看上去与 golang stuct 差别很大</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">solidity 封装、继承、多态体现在哪些地方，举例说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%98%AF%E4%B8%8D%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">solidity 函数修饰符是不是装饰器？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">solidity 算术运算的检查模式与非检查模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-revert-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">solidity revert 抛出异常?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-assert-%E4%B8%8E-require-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">solidity assert 与 require 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">solidity 作用域和声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">solidity 赋值方式有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%90%88%E7%BA%A6-Constant-%E5%92%8C-Immutable-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">solidity 合约 Constant 和 Immutable 状态变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">solidity 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">定义函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">函数修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">函数参数和返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">修饰函数状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pure\"><span class=\"toc-text\">pure</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pure-%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%84%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%94%9F%E5%90%88%E7%BA%A6%E7%8A%B6%E6%80%81%E4%BF%AE%E6%94%B9%E4%BA%86%EF%BC%8C%E4%BC%9A%E6%80%8E%E6%A0%B7\"><span class=\"toc-text\">pure 关键字处理的函数，如果发生合约状态修改了，会怎样</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#view-%E5%92%8C-pure-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">view 和 pure 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F\"><span class=\"toc-text\">为什么这么设计？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-receive-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">solidity receive 有什么用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E5%8B%BE%E5%AD%90%E5%87%BD%E6%95%B0%E5%90%97\"><span class=\"toc-text\">可以理解为勾子函数吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-Fallback-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">solidity Fallback 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-fallback-%E4%B9%9F%E6%98%AF%E5%8B%BE%E5%AD%90%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">solidity fallback 也是勾子函数？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8B%BE%E5%AD%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">还有哪些勾子函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E4%BA%8B%E4%BB%B6%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">solidity 事件如何理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%B1%E6%98%AF%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">就是发布订阅模式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%A2%AB%E8%A7%A6%E5%8F%91%E5%90%8E%EF%BC%8C%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BC%9A%E4%B8%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%EF%BC%9F\"><span class=\"toc-text\">所有的事件被触发后，都会被区块链会主动记录？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-solidity-%E7%94%A8-virtual-%E8%80%8C%E4%B8%8D%E7%94%A8-abstract\"><span class=\"toc-text\">为什么 solidity 用 virtual 而不用 abstract</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0-%E4%B8%8E-%E9%9D%9E%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">solidity 外部函数 与 非外部函数的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-require\"><span class=\"toc-text\">solidity require</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%90%88%E7%BA%A6%E6%B2%A1%E6%9C%89%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%93%AA%E9%87%8C%E4%BA%86%EF%BC%9F\"><span class=\"toc-text\">solidity 合约没有操作数据库，数据存哪里了？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E4%B8%8A%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8C%81%E4%B9%85%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">存在变量上，就是持久的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E6%9C%89%E5%87%A0%E5%8D%83%E4%B8%87%E4%B8%AA%E5%8C%BA%E5%9D%97%EF%BC%8C%E6%88%91%E8%A6%81%E6%9F%A5%E6%88%91%E7%9A%84%E5%90%88%E7%BA%A6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BE%88%E6%85%A2%EF%BC%9F\"><span class=\"toc-text\">如果有几千万个区块，我要查我的合约中的数据，是不是很慢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%88%B0%E8%87%AA%E5%B7%B1%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%EF%BC%9F\"><span class=\"toc-text\">直接存到自己外部服务器上？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%BA%A6%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%9F\"><span class=\"toc-text\">合约只能读写自己的存储？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#solidity-%E5%90%88%E7%BA%A6%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%86%99%E5%AD%98%E5%82%A8%E5%8C%BA%E5%86%85%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E9%83%A8%E5%88%86-%E5%A6%82%E6%9E%9C%E6%83%B3%E8%AF%BB%E5%85%B6%E4%BB%96%E5%90%88%E7%BA%A6%E7%9A%84%E5%AD%98%E5%82%A8%E5%8C%BA%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">solidity 合约只能读写存储区内属于自己的部分,如果想读其他合约的存储区怎么办？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B8%8D%E5%87%86%E5%90%A7\"><span class=\"toc-text\">日志可能会不准吧</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E8%AE%A9%E8%AF%BB%E5%86%99%E5%85%B6%E4%BB%96%E7%9A%84%E5%90%88%E7%BA%A6%EF%BC%8C%E5%B2%82%E4%B8%8D%E6%98%AF%E6%AF%8F%E4%B8%AA%E5%90%88%E7%BA%A6%E5%8F%88%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%AD%E5%BF%83%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">不让读写其他的合约，岂不是每个合约又是一个中心化？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E5%90%88%E7%BA%A6%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%AD%E5%BF%83%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">一个合约是一个中心化？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E9%93%BE%E6%98%AF%E9%80%8F%E6%98%8E%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E5%90%88%E7%BA%A6%E5%8F%AF%E4%BB%A5%E8%AF%BB-x2F-%E5%86%99%E5%85%AC%E9%93%BE%E6%95%B0%E6%8D%AE%EF%BC%9F\"><span class=\"toc-text\">公链是透明的，那么合约可以读&#x2F;写公链数据？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%BA%A6%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%86%99%E5%8F%82%E4%B8%8E%E8%80%85%E6%95%B0%E6%8D%AE%EF%BC%9F\"><span class=\"toc-text\">合约可以读写参与者数据？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E4%B8%8E%E8%80%85%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%90%88%E7%BA%A6%E6%95%B0%E6%8D%AE%EF%BC%9F\"><span class=\"toc-text\">参与者可以读合约数据？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%BA%A6%E7%9A%84%E5%8F%82%E4%B8%8E%E8%80%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">合约的参与者是如何定义的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E4%B8%8E%E8%80%85%E5%8F%AA%E8%83%BD%E7%9C%8B%E5%88%B0%E5%90%88%E7%BA%A6%E5%85%AC%E5%BC%80%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%9C%8B%E4%B8%8A%E5%8E%BB%E4%B8%8D%E6%98%AF%E5%85%A8%E9%80%8F%E6%98%8E\"><span class=\"toc-text\">参与者只能看到合约公开的数据，看上去不是全透明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E4%B8%8E%E8%80%85%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">参与者如何验证历史记录和执行过程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E4%B8%8E%E8%80%85%E5%A4%A7%E9%83%BD%E6%98%AF%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%99%BD%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%B9%9F%E7%9C%8B%E4%B8%8D%E6%87%82%E5%90%A7\"><span class=\"toc-text\">参与者大都是技术小白，应该也看不懂吧</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E7%BB%B4%E6%8A%A4%E8%80%85%EF%BC%8C%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">如果区块链的维护者，删库跑路了怎么办？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E8%A1%A5%E6%95%91%E6%8E%AA%E6%96%BD%EF%BC%9F\"><span class=\"toc-text\">有补救措施？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E6%95%91%E6%95%B0%E6%8D%AE%E8%A6%81%E4%BB%98%E8%B4%B9%E5%90%97\"><span class=\"toc-text\">补救数据要付费吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">代码示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%88%91%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">我的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E7%BC%96%E5%86%99%E7%9A%84%E5%90%88%E7%BA%A6%E5%92%8C%E5%85%B6%E4%BB%96%E4%BA%BA%E7%BC%96%E5%86%99%E7%9A%84%E5%90%88%E7%BA%A6%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%B8%A4%E4%B8%AA%E7%A8%8B%E5%BA%8F%E6%98%AF%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E7%9A%84%EF%BC%8C%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%98%AF%E5%90%88%E7%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">我编写的合约和其他人编写的合约是两个程序，两个程序是运行在区块链上的，程序之间的通信是合约之间的数据传递</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E5%BC%80%E5%8F%91%E7%9A%84%E5%90%88%E7%BA%A6%E5%85%B6%E5%AE%9E%E6%98%AF%E5%B5%8C%E5%85%A5%E5%88%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC%EF%BC%9F\"><span class=\"toc-text\">也就是说开发的合约其实是嵌入到区块链上执行的脚本？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E7%99%BD%E4%BA%86%EF%BC%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%B1%E6%98%AF%E7%B1%BB%E4%BC%BC%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">说白了，区块链就是类似服务器在运行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E5%90%88%E7%BA%A6%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%8F%91%E5%B8%83\"><span class=\"toc-text\">多个合约可以在一起发布</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"父子组件数据不一致","uid":"7160f8f90ec20d38188bb78c979fe324","slug":"2023-07-17bug","date":"2023-07-17T08:46:15.000Z","updated":"2023-07-20T14:58:47.214Z","comments":true,"path":"api/articles/2023-07-17bug.json","keywords":null,"cover":[],"text":"父子组件数据不一致 直接原因：useEffect 没有更新 根本原因：这里的代码，切换文章应该是文章 id，写成了分享 shareId，很多文件没有分享，未分享的文章切换就会出错 ","link":"","photos":[],"count_time":{"symbolsCount":93,"symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":38,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":32,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"svelte kit","uid":"9769659b2de5d4126dd03449784d4bdb","slug":"2023-07-14sveltekit","date":"2023-07-14T15:49:23.000Z","updated":"2023-07-20T14:58:47.213Z","comments":true,"path":"api/articles/2023-07-14sveltekit.json","keywords":null,"cover":null,"text":"SvelteKit 中 universal and server load functions 是啥在 SvelteKit 中，有两个重要的概念：Universal（通用）和 Server Load Functions（服务器加载函数）。 Universal（通用）: Unive...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"svelte","slug":"svelte","count":2,"path":"api/categories/svelte.json"}],"tags":[{"name":"svelte","slug":"svelte","count":2,"path":"api/tags/svelte.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}