{"title":"前端基础-http CORS","uid":"ed5ec0392ecb18ec3bd3ba76435a94c5","slug":"2022-07-26http-CORS","date":"2022-07-26T06:46:35.000Z","updated":"2022-09-16T13:54:56.227Z","comments":true,"path":"api/articles/2022-07-26http-CORS.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202208011718040.webp","content":"<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><!-- <img src=\"http://t-blog-images.aijs.top/img/202208011714853.webp\"  style=\"max-width:100%;width: 400px\"/> -->\n<img src=\"http://t-blog-images.aijs.top/img/202208011718040.webp\"  style=\"max-width:100%;width: 400px\"/>\n\n<h2 id=\"跨源资源共享（CORS）\"><a href=\"#跨源资源共享（CORS）\" class=\"headerlink\" title=\"跨源资源共享（CORS）\"></a>跨源资源共享（CORS）</h2><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。</p>\n<p><code>同源安全策略</code> 默认阻止“跨域”获取资源。但是 <code>CORS 给了 web 服务器这样的权限</code>，即服务器可以选择，允许跨域请求访问到它们的资源。</p>\n<p><code>跨源资源共享 (CORS)</code>（或通俗地译为<code>跨域资源共享</code>）是一种<strong>基于 HTTP 头的机制</strong>，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。<strong>跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的”预检”请求</strong>。<strong>在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</strong></p>\n<p>出于安全性(<code>应对CSRF攻击</code>)，浏览器<strong>限制</strong>脚本内发起的跨源 <code>HTTP</code> 请求。 例如，<code>XMLHttpRequest</code> 和 <code>Fetch API</code> 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202207261534554.webp\" style=\"max-width: 100%; width: 400px\"/>\n\n<p><code>跨源域资源共享（CORS）机制</code>, 允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 <code>XMLHttpRequest</code> 或 <code>Fetch</code>）使用 CORS，以降低跨源 <code>HTTP</code> 请求所带来的风险。</p>\n<h2 id=\"什么情况下需要-CORS？\"><a href=\"#什么情况下需要-CORS？\" class=\"headerlink\" title=\"什么情况下需要 CORS？\"></a>什么情况下需要 CORS？</h2><ul>\n<li><code>HTTP</code>请求</li>\n<li><code>Web字体</code></li>\n<li><code>WebGL</code>贴图</li>\n<li>使用 <code>drawImage</code> 将 Images&#x2F;video 画面绘制到 <code>canvas</code>。</li>\n<li>来自图像的 CSS 图形 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images#cors_compatibility\" target=\"_blank\" >见</a></li>\n</ul>\n<h2 id=\"功能概述\"><a href=\"#功能概述\" class=\"headerlink\" title=\"功能概述\"></a>功能概述</h2><ul>\n<li><p>跨源资源共享标准新增了一组 <code>HTTP</code> 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。</p>\n</li>\n<li><p>对那些<code>可能对服务器数据产生副作用的 HTTP 请求方法</code>（特别是 <code>GET</code> 以外的 <code>HTTP</code> 请求，或者搭配某些 MIME 类型 的 <code>POST</code> 请求），浏览器必须首先使用 <code>OPTIONS</code> 方法发起一个<code>预检请求</code>（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，<code>是否需要携带身份凭证</code>（包括 <code>Cookies</code> 和 <code>HTTP 认证</code> 相关数据）。</p>\n</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><code>CORS</code> 请求失败会产生错误，但是为了安全，在 <code>JavaScript 代码层面是无法获知到底具体是哪里出了问题</code>。你只能查看浏览器的控制台以得知具体是哪里出现了错误。</p>\n</div>\n<h2 id=\"HTTP-访问控制场景\"><a href=\"#HTTP-访问控制场景\" class=\"headerlink\" title=\"HTTP 访问控制场景\"></a>HTTP 访问控制场景</h2><h3 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h3><p><strong>某些请求不会触发 CORS 预检请求</strong>。本文称这样的请求为<code>“简单请求”</code>，请注意，该术语并不属于 Fetch（其中定义了 CORS）规范。若请求 满足所有下述条件，则该请求可视为“简单请求”：</p>\n<ul>\n<li><p>使用下列方法之一：<code>GET</code>、<code>HEAD</code>、<code>POST</code></p>\n<br/>\n<br/></li>\n<li><p>除了被用户代理自动设置的首部字段（例如 <code>Connection</code>，<code>User-Agent</code>）和在 <code>Fetch</code> 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 <code>Fetch</code> 规范定义的 对 <code>CORS</code> 安全的首部字段集合</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Accept\nAccept-Language\nContent-Language\nContent-Type（需要注意额外的限制）</code></pre>\n</li>\n<li><p><code>Content-Type</code> 的值仅限于下列三者之一：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">text&#x2F;plain\nmultipart&#x2F;form-data\napplication&#x2F;x-www-form-urlencoded</code></pre>\n<br/>\n<br/></li>\n<li><p>请求中的任意 <code>XMLHttpRequest</code> 对象均没有注册任何事件监听器；（除了： <code>XMLHttpRequest</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问)</p>\n<br/>\n<br/></li>\n<li><p>请求中没有使用 <code>ReadableStream</code> 对象</p>\n</li>\n</ul>\n<p>比如说，假如站点 <code>https://foo.example</code> 的网页应用想要访问 <code>https://bar.other</code> 的资源。foo.example 的网页中可能包含类似于下面的 JavaScript 代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const xhr &#x3D; new XMLHttpRequest();\nconst url &#x3D; &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;public-data&#x2F;&quot;;\n\nxhr.open(&quot;GET&quot;, url);\nxhr.onreadystatechange &#x3D; someHandler;\nxhr.send();</code></pre>\n\n<p>客户端和服务器之间使用 <code>CORS</code> 首部字段来处理权限：</p>\n<p>以下是浏览器发送给服务器的请求报文：</p>\n<pre class=\"line-numbers language-GET\" data-language=\"GET\"><div class=\"caption\"><span>/resources/public-data/ HTTP/1.1</span></div><code class=\"language-GET\">Host: bar.other\nUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko&#x2F;20100101 Firefox&#x2F;71.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-us,en;q&#x3D;0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nOrigin: https:&#x2F;&#x2F;foo.example</code></pre>\n\n<p>请求首部字段 <code>Origin</code> 表明该请求来源于 <code>http://foo.example</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache&#x2F;2\nAccess-Control-Allow-Origin: *\nKeep-Alive: timeout&#x3D;2, max&#x3D;100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application&#x2F;xml\n\n[XML Data]</code></pre>\n\n<p>本例中，服务端返回的 <code>Access-Control-Allow-Origin: * </code>表明，该资源可以被 <em>任意</em> 外域访问。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Origin: *</code></pre>\n\n<p>使用 <code>Origin</code> 和 <code>Access-Control-Allow-Origin</code> 就能完成最简单的访问控制。如果服务端仅允许来自 <a href=\"https://foo.example/\">https://foo.example</a> 的访问，该首部字段的内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Origin: https:&#x2F;&#x2F;foo.example</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>备注： 当响应的是附带身份凭证的请求时，服务端 必须 明确 Access-Control-Allow-Origin 的值，而不能使用通配符“*”。不过可以是<code>$http_origin</code> <a href=\"https://blog.csdn.net/u014589884/article/details/108028681\" target=\"_blank\" >$http_XXX 这个格式是 nginx 取请求中 header 的 XXX 的值的</a></p>\n</div>\n<h3 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h3><p>与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。<br>如下是一个需要执行预检请求的 HTTP 请求：<span style=\"color: red\">预检是浏览器主动发起的，研发都不用做</span></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const xhr &#x3D; new XMLHttpRequest();\nxhr.open(&quot;POST&quot;, &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;post-here&#x2F;&quot;);\nxhr.setRequestHeader(&quot;X-PINGOTHER&quot;, &quot;pingpong&quot;);\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;xml&quot;);\nxhr.onreadystatechange &#x3D; handler;\nxhr.send(&quot;&lt;person&gt;&lt;name&gt;Arun&lt;&#x2F;name&gt;&lt;&#x2F;person&gt;&quot;);</code></pre>\n\n<p>上面的代码使用 <code>POST</code> 请求发送一个 <code>XML</code> 文档，该请求包含了一个<code>自定义的请求首部字段（X-PINGOTHER: pingpong）</code>。另外，该请求的 <code>Content-Type</code> 为 <code>application/xml</code>。因此，该请求需要首先发起“预检请求”。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202207261604436.webp\" style=\"max-width: 100%; width: 400px\"/>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>备注： 如下所述，实际的 POST 请求不会携带 Access-Control-Request-* 首部，它们仅用于 OPTIONS 请求。</p>\n</p>\n</div>\n<p><strong>下面是服务端和客户端完整的信息交互。首次交互是 预检请求&#x2F;响应：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">OPTIONS &#x2F;doc HTTP&#x2F;1.1 # 这里\nHost: bar.other\nUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko&#x2F;20100101 Firefox&#x2F;71.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-us,en;q&#x3D;0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nOrigin: https:&#x2F;&#x2F;foo.example # 这里\nAccess-Control-Request-Method: POST # 这里\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type # 这里\n\nHTTP&#x2F;1.1 204 No Content\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache&#x2F;2\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\nAccess-Control-Max-Age: 86400\nVary: Accept-Encoding, Origin\nKeep-Alive: timeout&#x3D;2, max&#x3D;100\nConnection: Keep-Alive</code></pre>\n\n<p>浏览器检测到，从 <code>JavaScript</code> 中发起的请求需要被预检。从上面的报文中，我们看到，第 1~10 行发送了一个使用 OPTIONS 方法 的“预检请求”。<strong>OPTIONS 是 HTTP&#x2F;1.1 协议中定义的方法，用以从服务器获取更多信息</strong>。<strong>该方法不会对服务器资源产生影响</strong>。 预检请求中同时携带了下面两个首部字段：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type # X-PINGOTHER 是自定义的</code></pre>\n\n<p>首部字段 <code>Access-Control-Request-Method</code> 告知服务器，实际请求将使用 <code>POST</code> 方法。<br>首部字段 <code>Access-Control-Request-Headers</code> 告知服务器，实际请求将携带两个自定义请求首部字段：<code>X-PINGOTHER</code> 与 <code>Content-Type</code>。服务器据此决定，该实际请求是否被允许。</p>\n<p>第 13-22 行为预检请求的响应，表明服务器将接受后续的实际请求。重点看第 16-19 行：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Origin: https:&#x2F;&#x2F;foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\nAccess-Control-Max-Age: 86400</code></pre>\n\n<p>服务器的响应携带了 <code>Access-Control-Allow-Origin: https://foo.example</code>，从而限制请求的源域。同时，携带的 <code>Access-Control-Allow-Methods</code> 表明服务器允许客户端使用 <code>POST</code> 和 <code>GET</code> 方法发起请求（与 <code>Allow</code> 响应首部类似，但其具有严格的访问控制）。</p>\n<p>首部字段 <code>Access-Control-Allow-Headers</code> 表明服务器允许请求中携带字段 X-<code>PINGOTHER</code> 与<code> Content-Type</code>。与 <code>Access-Control-Allow-Methods</code> 一样，<code>Access-Control-Allow-Headers</code> 的值为逗号分割的列表。</p>\n<p>最后，首部字段 <code>Access-Control-Max-Age</code> 表明该响应的有效时间为 <code>86400</code> 秒，也就是 24 小时。<strong>在有效时间内，浏览器无须为同一请求再次发起预检请求。</strong> <span style=\"color: red\">请注意，浏览器自身维护了一个 最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</span></p>\n<h3 id=\"预检会拖慢速度\"><a href=\"#预检会拖慢速度\" class=\"headerlink\" title=\"预检会拖慢速度\"></a>预检会拖慢速度</h3><p>类似要去看病，先预检台、挂号、分诊。。。对于“急诊的”咋整？</p>\n<p><code>Access-Control-Max-Age</code>整个上限，对于不同的浏览器上限要区别对待， <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age\" target=\"_blank\" >见</a></p>\n<h3 id=\"附带身份凭证的请求\"><a href=\"#附带身份凭证的请求\" class=\"headerlink\" title=\"附带身份凭证的请求\"></a>附带身份凭证的请求</h3><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>当发出跨源请求时，第三方 cookie 策略仍将适用。无论如何改变本章节中描述的服务器和客户端的设置，该策略都会强制执行</p>\n</div>\n<p><code>XMLHttpRequest</code> 或 <code>Fetch</code> 与 <code>CORS</code> 的一个有趣的特性是，可以基于<code> HTTP cookies</code> 和<code> HTTP 认证信息</code>发送身份凭证。<br>一般而言，对于跨源 <code>XMLHttpRequest</code> 或 <code>Fetch</code> 请求，浏览器 <em>不会</em> 发送身份凭证信息。<strong>如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。</strong></p>\n<p>本例中，<a href=\"https://foo.example/\">https://foo.example</a> 的某脚本向 <a href=\"https://bar.other/\">https://bar.other</a> 发起一个 GET 请求，并设置 Cookies：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const invocation &#x3D; new XMLHttpRequest();\nconst url &#x3D; &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;credentialed-content&#x2F;&quot;;\n\nfunction callOtherDomain() &#123;\n  if (invocation) &#123;\n    invocation.open(&quot;GET&quot;, url, true);\n    invocation.withCredentials &#x3D; true; &#x2F;&#x2F; 这里\n    invocation.onreadystatechange &#x3D; handler;\n    invocation.send();\n  &#125;\n&#125;</code></pre>\n\n<p>第 7 行将 <code>XMLHttpRequest</code> 的 <code>withCredentials</code> 标志设置为 <code>true</code>，从而向服务器发送 <code>Cookies</code>。<br><strong>因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”</strong>。但是，如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code>，<strong>浏览器将不会把响应内容返回给请求的发送者</strong>。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202207261630388.webp\" style=\"max-width: 100%; width: 400px\"/>\n\n<p>CORS 预检请求不能包含凭据。预检请求的 <em>响应</em> 必须指定 <code>Access-Control-Allow-Credentials: true</code> 来表明可以携带凭据进行实际的请求。</p>\n<p><strong>附带身份凭证的请求与通配符</strong></p>\n<p>在响应附带身份凭证的请求时：</p>\n<ul>\n<li>服务器不能将 <code>Access-Control-Allow-Origin</code> 的值设为通配符“*”，而应将其设置为特定的域，如：<code>Access-Control-Allow-Origin: https://example.com</code>。</li>\n<li>服务器不能将 <code>Access-Control-Allow-Headers</code>的值设为通配符“*”，而应将其设置为首部名称的列表，如：<code>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</code></li>\n<li>服务器不能将 <code>Access-Control-Allow-Methods</code> 的值设为通配符“*”，而应将其设置为特定请求方法名称的列表，如：<code>Access-Control-Allow-Methods: POST, GET</code></li>\n<li>对于附带身份凭证的请求（通常是 Cookie），服务器不得设置 <code>Access-Control-Allow-Origin 的值为“*”</code>。</li>\n</ul>\n<p>这是因为请求的首部中携带了 Cookie 信息，如果 <code>Access-Control-Allow-Origin 的值为“*”</code>，请求将会失败。<br>而将 <code>Access-Control-Allow-Origin</code> 的值设置为 <code>https://example.com</code>，则请求将成功执行。<br>另外，响应首部中也携带了 <code>Set-Cookie</code> 字段，尝试对 <code>Cookie</code> 进行修改。如果操作失败(<code>SameSite</code>限制)，将会抛出异常。</p>\n<p><strong>第三方 cookies</strong></p>\n<p>在 <code>CORS</code> 响应中设置的 <code>cookies</code> 适用一般性第三方 <code>cookie</code> 策略, <code>Cookie</code> 策略受 <code>SameSite</code> 属性控制</p>\n<h2 id=\"http-响应首部字段\"><a href=\"#http-响应首部字段\" class=\"headerlink\" title=\"http 响应首部字段\"></a>http 响应首部字段</h2><ul>\n<li><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code>, 对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符</li>\n<li><code>Access-Control-Expose-Headers</code> , 让服务器把允许浏览器访问的头放入白名单</li>\n<li><code>Access-Control-Max-Age: &lt;delta-seconds&gt;</code>, 指定了 preflight 请求的结果能够被缓存多久</li>\n<li><code>Access-Control-Allow-Credentials</code>, 它指定了实际的请求是否可以使用 credentials</li>\n<li><code>Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code>,其指明了实际请求中允许携带的首部字段</li>\n<li><code>Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code>, 其指明了实际请求中允许携带的首部字段</li>\n</ul>\n<details class=\"custom-details\">\n<summary>查看更多</summary>\n<p>本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。</p>\n<p><strong>Access-Control-Allow-Origin</strong></p>\n<p>响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Origin: &lt;origin&gt; | *</code></pre>\n\n<p>其中，origin 参数的值指定了允许访问该资源的外域 URI。<strong>对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符</strong>，表示允许来自所有域的请求。</p>\n<p>例如，下面的字段值将允许来自 <a href=\"https://mozilla.org/\">https://mozilla.org</a> 的请求：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Origin: https:&#x2F;&#x2F;mozilla.org\nVary: Origin</code></pre>\n\n<p>_如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容_。</p>\n<p><strong>Access-Control-Expose-Headers</strong><br>译者注：在跨源访问时，<code>XMLHttpRequest</code> 对象的 <code>getResponseHeader()</code> 方法只能拿到一些最基本的响应头，</p>\n<ul>\n<li><code>Cache-Control</code>、</li>\n<li><code>Content-Language</code>、</li>\n<li><code>Content-Type</code>、</li>\n<li><code>Expires</code>、</li>\n<li><code>Last-Modified</code>、</li>\n<li><code>Pragma</code><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers\" target=\"_blank\" >见 Access-Control-Expose-Headers</a><br>如果要访问其他头，则需要服务器设置本响应头。</li>\n</ul>\n<p><code>Access-Control-Expose-Headers</code> 头, 让服务器把允许浏览器访问的头放入白名单，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</code></pre>\n\n<p><strong>这样浏览器就能够通过 getResponseHeader 访问 X-My-Custom-Header 和 X-Another-Custom-Header 响应头了。</strong></p>\n<p><strong>Access-Control-Max-Age</strong><br>Access-Control-Max-Age 头指定了 preflight 请求的结果能够被缓存多久，请参考本文在前面提到的 preflight 例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Max-Age: &lt;delta-seconds&gt;</code></pre>\n\n<p>delta-seconds 参数表示 preflight 预检请求的结果在多少秒内有效。</p>\n<ul>\n<li>在 Firefox 中，上限是 24 小时 （即 86400 秒）。</li>\n<li>在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。</li>\n<li>从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。</li>\n<li>Chromium 同时规定了一个默认值 5 秒。</li>\n<li>如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age\" target=\"_blank\" >见 Access-Control-Max-Age</a></li>\n</ul>\n<p><strong>Access-Control-Allow-Credentials</strong><br>Access-Control-Allow-Credentials 头指定了当浏览器的 credentials 设置为 true 时是否允许浏览器读取 response 的内容。当用在对 preflight 预检测请求的响应中时，它指定了实际的请求是否可以使用 credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Credentials: true</code></pre>\n\n<p>上文已经讨论了附带身份凭证的请求。</p>\n<p><strong>Access-Control-Allow-Methods</strong><br>Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code></pre>\n\n<p>有关 preflight request 的示例已在上方给出。</p>\n<p><strong>Access-Control-Allow-Headers</strong><br>Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code></pre>\n\n</p>\n</details>\n<h2 id=\"http-请求首部字段\"><a href=\"#http-请求首部字段\" class=\"headerlink\" title=\"http 请求首部字段\"></a>http 请求首部字段</h2><p>可用于发起跨源请求的首部字段。请注意，这些首部字段<strong>无须手动设置</strong>。 当开发者使用 <code>XMLHttpRequest</code> 对象发起跨源请求时，它们已经被设置就绪。</p>\n<ul>\n<li><code>Origin</code> 首部字段表明预检请求或实际请求的源站</li>\n<li><code>Access-Control-Request-Method</code> 首部字段用于预检请求。其作用是，将实际请求所使用的 <code>HTTP</code> 方法告诉服务器。</li>\n<li><code>Access-Control-Request-Headers</code> 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</li>\n</ul>\n<h2 id=\"CORS-错误及处理\"><a href=\"#CORS-错误及处理\" class=\"headerlink\" title=\"CORS 错误及处理\"></a>CORS 错误及处理</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors/CORSAllowOriginNotMatchingOrigin\" target=\"_blank\" >见</a></p>\n<h2 id=\"在-nestjs-中本地调试\"><a href=\"#在-nestjs-中本地调试\" class=\"headerlink\" title=\"在 nestjs 中本地调试\"></a>在 nestjs 中本地调试</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">async function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create&lt;NestExpressApplication&gt;(\n    ApplicationModule,\n  )\n  &#x2F;&#x2F; 允许跨域\n  app.enableCors(&#123;\n    origin: &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#39;,\n    credentials: true,\n  &#125;)\n</code></pre>\n\n<p><strong>正确结果</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/202208250949357.webp\" />\n\n<ul>\n<li>去掉 <code>credentials: true,</code> 测试</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">app.enableCors(&#123;\n  origin: &quot;http:&#x2F;&#x2F;127.0.0.1:5501&quot;,\n  &#x2F;&#x2F; credentials: true,\n&#125;);</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202208291423214.webp\" />\n\n<ul>\n<li>去掉 <code>origin: &#39;http://127.0.0.1:5501&#39;,</code> 测试</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">app.enableCors(&#123;\n  &#x2F;&#x2F; origin: &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#39;,\n  credentials: true,\n&#125;);</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202208291425435.webp\" />\n\n<h2 id=\"阿里云-COS-跨域配置\"><a href=\"#阿里云-COS-跨域配置\" class=\"headerlink\" title=\"阿里云 COS 跨域配置\"></a>阿里云 COS 跨域配置</h2><img src=\"http://t-blog-images.aijs.top/img/202209021744126.webp\" style=\"width: 500px;max-width: 100%\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209021746095.webp\" />\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\" target=\"_blank\" >Web 开发技术&gt;HTTP&gt;跨源资源共享（CORS）</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors/CORSAllowOriginNotMatchingOrigin\" target=\"_blank\" >Web 开发技术&gt;HTTP&gt;跨源资源共享（CORS）&gt;CORS errors</a></p>\n","text":"思维导图 跨源资源共享（CORS）CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。 同源安全策略 默认阻止...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":18,"path":"api/tags/面试.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">思维导图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89\"><span class=\"toc-text\">跨源资源共享（CORS）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81-CORS%EF%BC%9F\"><span class=\"toc-text\">什么情况下需要 CORS？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">功能概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">HTTP 访问控制场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">简单请求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">预检请求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E6%A3%80%E4%BC%9A%E6%8B%96%E6%85%A2%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">预检会拖慢速度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%B8%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E8%AF%81%E7%9A%84%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">附带身份凭证的请求</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#http-%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">http 响应首部字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#http-%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">http 请求首部字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CORS-%E9%94%99%E8%AF%AF%E5%8F%8A%E5%A4%84%E7%90%86\"><span class=\"toc-text\">CORS 错误及处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8-nestjs-%E4%B8%AD%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">在 nestjs 中本地调试</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%BF%E9%87%8C%E4%BA%91-COS-%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">阿里云 COS 跨域配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-http 连接管理","uid":"28bb441cd50232946d7be5a33559cd7e","slug":"2022-07-26http-connect","date":"2022-07-26T13:53:35.000Z","updated":"2022-09-16T13:54:56.228Z","comments":true,"path":"api/articles/2022-07-26http-connect.json","keywords":null,"cover":[],"text":"HTTP&#x2F;1.x 的连接管理 短连接 HTTP&#x2F;1.0 默认是短连接(冷连接),每一个 HTTP 请求都由它自己独立的连接完成, TCP 协议握手耗费时间,TCP 可以保持更多的热连接来适应负载 查看更多 HTTP 最早期的模型，也是 HTTP&#x2F;1....","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":18,"path":"api/tags/面试.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"React V17.0 候选版本：无新功能","uid":"4afe9cca9efcce45bab52ea3fe738dfb","slug":"2022-07-25React-v17","date":"2022-07-25T06:54:43.000Z","updated":"2022-09-16T15:02:55.176Z","comments":true,"path":"api/articles/2022-07-25React-v17.json","keywords":null,"cover":[],"text":"无新特性React 17 的版本是非比寻常的，因为它没有添加任何面向开发人员的新功能。而主要侧重于升级简化 React 本身。 我们正在积极开发 React 的新功能，但它们并不属于此版本。React 17 是我们进行深度推广战略的关键所在。 此版本之所以特殊，你可以认为 Rea...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"React","slug":"React","count":26,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":20,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}