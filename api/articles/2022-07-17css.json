{"title":"前端基础-CSS3","uid":"04f522a5377d4d5450ce4cf8a54e76ff","slug":"2022-07-17css","date":"2022-07-17T07:39:25.000Z","updated":"2022-07-17T14:22:48.322Z","comments":true,"path":"api/articles/2022-07-17css.json","keywords":null,"cover":[],"content":"<h2 id=\"CSS-选择器的优先级是怎样的\"><a href=\"#CSS-选择器的优先级是怎样的\" class=\"headerlink\" title=\"CSS 选择器的优先级是怎样的\"></a>CSS 选择器的优先级是怎样的</h2><p>CSS 选择器的优先级是：<code>!important &gt; 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</code></p>\n<p>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>\n<ul>\n<li>A 的值等于 1 的前提是存在内联样式, 否则 A &#x3D; 0;</li>\n<li>B 的值等于 ID 选择器 出现的次数;</li>\n<li>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;</li>\n<li>D 的值等于 标签选择器 和 伪元素 出现的总次数 。</li>\n</ul>\n<p>就⽐如下⾯的选择器，它不存在内联样式，所以 A&#x3D;0,不存在 id 选择器 B&#x3D;0,存在⼀个类选择器 C&#x3D;1,存在三个标签选择器 D&#x3D;3，那么最终计算结果为:</p>\n<pre class=\"line-numbers language-CSS\" data-language=\"CSS\"><code class=\"language-CSS\">ul ol li .red &#123; ... &#125;\n &#x2F;* &#123;0, 0, 1 ,3&#125; *&#x2F;</code></pre>\n\n<p>按照这个结算⽅式，下⾯的计算结果为:</p>\n<pre class=\"line-numbers language-CSS\" data-language=\"CSS\"><code class=\"language-CSS\">#red &#123; &#125;\n &#x2F;* &#123;0, 1, 0, 0&#125; *&#x2F;\n</code></pre>\n\n<p>⽐较优先级的⽅式是从 A 到 D 去⽐较值的⼤⼩，A、B、C、D 权重从左到右，依次减⼩。判断优先级时，从左到右，⼀⼀⽐较，<code>直到⽐较出最⼤值，即可停⽌</code>。</p>\n<p>⽐如第⼆个例⼦的 B 与第⼀个例⼦的 B 相⽐，1&gt;0,<code>接下来就不需要⽐较了，第⼆个选择器的优先级更⾼</code>。</p>\n<h2 id=\"比-important更高的优先级\"><a href=\"#比-important更高的优先级\" class=\"headerlink\" title=\"比!important更高的优先级\"></a>比<code>!important</code>更高的优先级</h2><ul>\n<li><code>media媒体查询</code></li>\n<li><code>max-width、min-width</code></li>\n<li><code>picture source</code></li>\n<li><code>image srcset</code></li>\n<li><code>同是!important，内部文件优先于外部文件</code></li>\n<li><code>同是!important，link 优先于@import</code></li>\n</ul>\n<h2 id=\"link-和-import-的区别\"><a href=\"#link-和-import-的区别\" class=\"headerlink\" title=\"link 和@import 的区别\"></a>link 和@import 的区别</h2><ul>\n<li>link 属于 <code>XHTML 标签</code>，⽽@import 是 <code>CSS 提供的</code>。</li>\n<li>⻚⾯被加载时，<code>link 会同时被加载</code>，⽽@import 引⽤的 CSS 会<code>等到⻚⾯被加载完再加载</code>。</li>\n<li>import 只在 IE 5 以上才能识别，⽽ link 是 XHTML 标签，⽆<code>兼容问题</code>。</li>\n<li>link ⽅式的样式<code>权重</code>⾼于@import 的权重。</li>\n<li>使⽤ dom 控制样式时的差别。当使⽤ <code>javascript 控制 dom 去改变样式</code>的时候，只能使⽤ link 标签，因为@import 不是 dom 可以控制的。</li>\n</ul>\n<h2 id=\"CSS-隐藏⻚⾯元素\"><a href=\"#CSS-隐藏⻚⾯元素\" class=\"headerlink\" title=\"CSS 隐藏⻚⾯元素\"></a>CSS 隐藏⻚⾯元素</h2><ul>\n<li><code>opacity:0 </code>：本质上是将元素的透明度将为 0，就看起来隐藏了，但是依然<code>占据空间可交互</code></li>\n<li><code>visibility:hidden</code> : 与上⼀个⽅法类似的效果，<code>占据空间不可交互</code></li>\n<li><code>overflow:hidden</code> : 这个只隐藏元素溢出的部分，<code>占据空间不可交互</code></li>\n<li><code>display:none</code> : 这个是彻底隐藏了元素，元素从⽂档流中消失，<code>不占据空间不交互</code></li>\n<li><code>z-index:-9999</code> : 原理是将层级放到底部，这样就被覆盖了，<code>不占据空间不交互</code></li>\n<li><code>transform: scale(0,0) </code>: 平⾯变换，将元素缩放为 0，<code>占据空间不可交互</code></li>\n<li><code>transform: </code>: 移出可视区域<code>占据空间不可交互</code></li>\n</ul>\n<h2 id=\"em-px-rem-区别\"><a href=\"#em-px-rem-区别\" class=\"headerlink\" title=\"em\\px\\rem 区别\"></a>em\\px\\rem 区别</h2><ul>\n<li><code>px</code>：绝对单位，⻚⾯按精确像素展示。</li>\n<li><code>em</code>：相对单位，基准点为⽗节点字体的⼤⼩，如果⾃身定义了 font-size 按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内 1em 不是⼀个固定的值。</li>\n<li><code>rem</code>：相对单位，可理解为”root em”, 相对根节点 html 的字体⼤⼩来计算，CSS3 新加属性，chrome&#x2F;firefox&#x2F;IE9+⽀ 持</li>\n</ul>\n<h2 id=\"块级元素⽔平居中的⽅法\"><a href=\"#块级元素⽔平居中的⽅法\" class=\"headerlink\" title=\"块级元素⽔平居中的⽅法\"></a>块级元素⽔平居中的⽅法</h2><p>如果使⽤ Hack 的话，⽔平居中的⽅法⾮常多，主流的，奇葩的⻅拓展阅读</p>\n<ul>\n<li><code>margin:0 auto </code>⽅法</li>\n</ul>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;style&gt;\n  .center &#123;\n    height: 200px;\n    width: 200px;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre>\n\n<ul>\n<li><code>flex</code> 布局，⽬前主流⽅法</li>\n</ul>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;style&gt;\n  .center&#123; display:flex; justify-content:center; 9 &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;1&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;2&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<ul>\n<li><code>table</code> ⽅法</li>\n</ul>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;style&gt;\n  .center &#123;\n    display: table;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre>\n\n<p>还有⼀些通过 <code>position+(margin|transform)</code>等⽅法的不⼀样列举了，⾮重点没必要</p>\n<h2 id=\"CSS-5-种定位⽅式\"><a href=\"#CSS-5-种定位⽅式\" class=\"headerlink\" title=\"CSS 5 种定位⽅式\"></a>CSS 5 种定位⽅式</h2><ul>\n<li><code>static</code>: <code>正常⽂档流定位</code>，此时 top, right, bottom, left 和 z-index <code>属性⽆效</code>，<code>块级元素：从上往下纵向排布</code>，<code>⾏级元素:从左向右排列</code>。</li>\n<li><code>relative</code>：<code>相对定位</code>，此时的『相对』是<code>相对于正常⽂档流的位置</code>。</li>\n<li><code>absolute</code>：<code>相对于最近的⾮ static 定位祖先元素的偏移</code>，⽐如⼀个绝对定位元素它的⽗级、和祖 ⽗级元素都为 relative，它会相对他的⽗级⽽产⽣偏移。</li>\n<li><code>fixed</code>：指定元素<code>相对于屏幕视⼝（viewport）的位置</code>。元素的位置在屏幕滚动时不会改变，⽐如那 种回到顶部的按钮⼀般都是⽤此定位⽅式。</li>\n<li><code>sticky</code>：<code>粘性定位</code>，特性<code>近似于 relative 和 fixed 的合体</code>，其在实际应⽤中的近似效果就是 IOS 通讯录滚动的时候的 『顶屁股』。</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>需要注意 BFC 的影响，<a href=\"https://blog.csdn.net/kaosini/article/details/118760075\" target=\"_blank\" >position:fixed 没有相对浏览器窗口定位的原因 transform 冲突</a>,<code>注：在虚拟列表时候会遇到</code></p>\n</div>\n<h2 id=\"层叠上下文\"><a href=\"#层叠上下文\" class=\"headerlink\" title=\"层叠上下文\"></a>层叠上下文</h2><p><strong>是什么</strong></p>\n<p>层叠上下⽂是 HTML 元素的三维概念，这些 HTML 元素在⼀条假想的相对于⾯向（电脑屏幕的）视窗或者⽹⻚的⽤户的 z 轴上延伸，HTML 元素依据其⾃身属性按照优先级顺序占⽤层叠上下⽂的空间。</p>\n<p><code>可以理解为 JS 中的作用域，一个页面中往往不仅仅只有一个层叠上下文</code></p>\n<p><strong>如何产⽣？</strong></p>\n<p>触发以下条件则会产⽣层叠上下⽂：</p>\n<p><strong>默认创建层叠上下文</strong></p>\n<ul>\n<li>根元素 (HTML)</li>\n</ul>\n<p><strong>需要配合 z-index 触发创建层叠上下文</strong></p>\n<ul>\n<li>z-index 值不为 “auto”的 绝对&#x2F;相对定位</li>\n<li>⼀个 z-index 值不为 “auto”的 flex 项⽬ (flex item)，即：⽗元素 display: flex|inline-flex</li>\n</ul>\n<p><strong>不需要配合 z-index 触发创建层叠上下文</strong></p>\n<ul>\n<li>opacity 属性值⼩于 1 的元素（参考 the specification for opacity）</li>\n<li>元素的以下属性的值不是 none：<ul>\n<li>transform</li>\n<li>filter</li>\n<li>perspective</li>\n<li>clip-path</li>\n<li>mask &#x2F; mask-image &#x2F; mask-border</li>\n</ul>\n</li>\n<li>isolation 属性被设置为 “isolate”的元素</li>\n<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇⽂章）</li>\n<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>创建了层叠上下文的元素只影响其子孙代元素</code>，<code>它自身的层叠水平是由它的父层叠上下文所决定的</code></p></blockquote>\n<p>当两个元素<code>层叠水平相同</code>的时候，这时候就要遵循下面两个准则：</p>\n<ul>\n<li>后来居上原则</li>\n<li>谁 z-index 大，谁在上的准则</li>\n</ul>\n<h3 id=\"如何理解-z-index？\"><a href=\"#如何理解-z-index？\" class=\"headerlink\" title=\"如何理解 z-index？\"></a>如何理解 z-index？</h3><p>CSS 中的 z-index 属性控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，可以修改 z-index 来控制元素的图层 位置，⽽且 <code>z-index 只能影响设置了 position 值的元素</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个属性是个“拼爹”的属性。(如果父元素层级低，那么子元素再怎么努力都没有用 <a href=\"https://blog.csdn.net/ccq2y/article/details/82143283\" target=\"_blank\" >见</a></p></blockquote>\n<h3 id=\"7-阶层叠水平\"><a href=\"#7-阶层叠水平\" class=\"headerlink\" title=\"7 阶层叠水平\"></a>7 阶层叠水平</h3><!-- <img src=\"http://t-blog-images.aijs.top/img/20220717205730.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/20220717215517.png\" />\n\n<ul>\n<li>如果元素的层叠水平一样，没有别的因素干扰，则遵循后来者居上原则。<a href=\"https://zhuanlan.zhihu.com/p/115951908\" target=\"_blank\" >见</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/weixin_30607659/article/details/101594118\" target=\"_blank\" >CSS 7 阶层叠水平</a></p>\n<h3 id=\"如何比较两个-DOM-元素的显示顺序呢\"><a href=\"#如何比较两个-DOM-元素的显示顺序呢\" class=\"headerlink\" title=\"如何比较两个 DOM 元素的显示顺序呢\"></a>如何比较两个 DOM 元素的显示顺序呢</h3><!-- - 1、同一个层叠上下文，层叠级别大的元素在上\n\n- 2、同一个层叠上下文，层叠级别相同，后来居上\n\n- 3、不同的层叠上下文，由父级元素层叠上下文决定 -->\n\n<ul>\n<li>如果是<code>在相同的层叠上下文</code>，按照层叠水平的规则来显示元素</li>\n<li>如果是<code>在不同的层叠上下文中</code>，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下, 这个两个元素所在的局部层叠上下文的层叠水平。</li>\n</ul>\n<h3 id=\"为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？\"><a href=\"#为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？\" class=\"headerlink\" title=\"为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？\"></a>为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？</h3><p>因为 float 和块级元素一般都作布局，内联元素都是内容。而一个网页中最重要的就是内容，所以一定要让内容的层叠顺序相当高，这样可以在发生层叠时，重要的图片、文字内容可以优先暴露在屏幕上。</p>\n<p><a href=\"https://segmentfault.com/a/1190000021602879?sort=newest\" target=\"_blank\" >重学前端之 CSS(三)BFC 与层叠上下文</a></p>\n<h2 id=\"块级格式化上下文\"><a href=\"#块级格式化上下文\" class=\"headerlink\" title=\"块级格式化上下文\"></a>块级格式化上下文</h2><h3 id=\"BFC-是什么\"><a href=\"#BFC-是什么\" class=\"headerlink\" title=\"BFC 是什么?\"></a>BFC 是什么?</h3><p>书⾯解释：BFC(Block Formatting Context)这⼏个英⽂拆解</p>\n<ul>\n<li><p><code>Box</code>: CSS 布局的基本单位，Box 是 CSS 布局的对象和基本单位， 直观点来说，就是⼀个⻚⾯是由很多个 Box 组成的，实际就是上个问题说的盒模型</p>\n</li>\n<li><p><code>Formatting context</code>：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤</p>\n<p><code>简⽽⾔之，它是⼀块独⽴的区域，让处于 BFC 内部的元素与外部的元素互相隔离</code></p>\n</li>\n</ul>\n<h3 id=\"如何形成\"><a href=\"#如何形成\" class=\"headerlink\" title=\"如何形成?\"></a>如何形成?</h3><p>BFC 触发条件:</p>\n<ul>\n<li><code>根元素</code>，即 HTML 元素</li>\n<li><code>float</code> 不为 none</li>\n<li><code>display</code> 的值为 inline-block、table-cell、table-caption</li>\n<li><code>position</code>: fixed&#x2F;absolute</li>\n<li><code>overflow</code> 不为 visible</li>\n</ul>\n<h3 id=\"BFC-特点\"><a href=\"#BFC-特点\" class=\"headerlink\" title=\"BFC 特点\"></a>BFC 特点</h3><p><a href=\"https://www.shuzhiduo.com/A/qVdeBaYAzP/#:~:text=auto%E3%80%81hidden%E3%80%81scroll-,BFC%E7%9A%84%E7%89%B9%E7%82%B9,-1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA\" target=\"_blank\" >BFC 的特点</a></p>\n<ul>\n<li>1、在一个 BFC 内部，<code>盒子会在垂直方向上排列</code></li>\n<li>2、在一个 BFC 内部，<code>相邻的 margin-bottom 和 margin-top 叠加</code></li>\n<li>3、在一个 BFC 内部，<code>每个元素左边紧贴着包含盒子的左边</code></li>\n<li>4、在一个 BFC 内部，<code>如果有一个内部元素是一个新的 BFC，则新 BFC 区域不会与 float 元素的区域重叠</code></li>\n<li>5、计算一个 BFC 高度时，<code>内部浮动元素的高度也会参与计算</code></li>\n</ul>\n<h3 id=\"作⽤是什么？\"><a href=\"#作⽤是什么？\" class=\"headerlink\" title=\"作⽤是什么？\"></a>作⽤是什么？</h3><ul>\n<li>防⽌ margin 发⽣重叠</li>\n<li>两栏布局，防⽌⽂字环绕等</li>\n<li>防⽌元素塌陷</li>\n</ul>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h2><h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><h2 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h2>","text":"CSS 选择器的优先级是怎样的CSS 选择器的优先级是：!important &gt; 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下： A 的值等于 1 的前提是存在内...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":17,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":19,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":14,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">CSS 选择器的优先级是怎样的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94-important%E6%9B%B4%E9%AB%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">比!important更高的优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#link-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">link 和@import 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">CSS 隐藏⻚⾯元素</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#em-px-rem-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">em\\px\\rem 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E2%BD%94%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E2%BD%85%E6%B3%95\"><span class=\"toc-text\">块级元素⽔平居中的⽅法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-5-%E7%A7%8D%E5%AE%9A%E4%BD%8D%E2%BD%85%E5%BC%8F\"><span class=\"toc-text\">CSS 5 种定位⽅式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">层叠上下文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-z-index%EF%BC%9F\"><span class=\"toc-text\">如何理解 z-index？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E9%98%B6%E5%B1%82%E5%8F%A0%E6%B0%B4%E5%B9%B3\"><span class=\"toc-text\">7 阶层叠水平</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-DOM-%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E9%A1%BA%E5%BA%8F%E5%91%A2\"><span class=\"toc-text\">如何比较两个 DOM 元素的显示顺序呢</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-inlin-block-%E5%92%8C-inline-%E7%9A%84%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E6%AF%94%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E9%83%BD%E9%AB%98%EF%BC%9F\"><span class=\"toc-text\">为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">块级格式化上下文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">BFC 是什么?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90\"><span class=\"toc-text\">如何形成?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">BFC 特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">作⽤是什么？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%92%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">盒模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flex\"><span class=\"toc-text\">flex</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">媒体查询</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"待办事项","uid":"c370dd6ecfc84fe9fdfa77b1a6f29341","slug":"todo","date":"2022-12-14T03:59:59.000Z","updated":"2022-07-17T14:33:25.384Z","comments":true,"path":"api/articles/todo.json","keywords":null,"cover":[],"text":"&#x2F;&#x2F; 1. headless-recorder &#x2F;&#x2F; 2. lightHouse https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangdou369098655&#x2F;article&#x2F;details...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Todo","slug":"Todo","count":1,"path":"api/categories/Todo.json"}],"tags":[{"name":"Todo","slug":"Todo","count":1,"path":"api/tags/Todo.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-html","uid":"2854d1d5923e1e62aed568f709662bf4","slug":"2022-07-17html","date":"2022-07-17T01:44:42.000Z","updated":"2022-07-17T07:31:50.506Z","comments":true,"path":"api/articles/2022-07-17html.json","keywords":null,"cover":[],"text":"doctype 的作⽤是什么？DOCTYPE 是 html5 标准⽹⻚声明，且必须声明在 HTML ⽂档的第⼀⾏。 来告知浏览器的解析器⽤什么⽂档标准解析这个⽂档，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析 ⽂档解析类型有： BackCo...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":17,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":19,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":14,"path":"api/tags/面试.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}