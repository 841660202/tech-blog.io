{"title":"前端基础-CSS3","uid":"04f522a5377d4d5450ce4cf8a54e76ff","slug":"2022-07-17css","date":"2022-07-17T07:39:25.000Z","updated":"2022-11-21T13:08:33.108Z","comments":true,"path":"api/articles/2022-07-17css.json","keywords":null,"cover":[],"content":"<h2 id=\"CSS-选择器的优先级是怎样的\"><a href=\"#CSS-选择器的优先级是怎样的\" class=\"headerlink\" title=\"CSS 选择器的优先级是怎样的\"></a>CSS 选择器的优先级是怎样的</h2><p>CSS 选择器的优先级是：<span style=\"color: red\">（标签选择器 &lt; 类选择器 &lt; ID 选择器）</span> <code>&lt; 内联 &lt; !important &lt; 特殊情况 </code></p>\n<p>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>\n<ul>\n<li>A 的值等于 1 的前提是存在内联样式, 否则 A &#x3D; 0;</li>\n<li>B 的值等于 ID 选择器 出现的次数;</li>\n<li>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;</li>\n<li>D 的值等于 标签选择器 和 伪元素 出现的总次数 。</li>\n</ul>\n<p>就⽐如下⾯的选择器，它不存在内联样式，所以 A&#x3D;0,不存在 id 选择器 B&#x3D;0,存在⼀个类选择器 C&#x3D;1,存在三个标签选择器 D&#x3D;3，那么最终计算结果为:</p>\n<pre class=\"line-numbers language-CSS\" data-language=\"CSS\"><code class=\"language-CSS\">ul ol li .red &#123; ... &#125;\n &#x2F;* &#123;0, 0, 1 ,3&#125; *&#x2F;</code></pre>\n\n<p>按照这个结算⽅式，下⾯的计算结果为:</p>\n<pre class=\"line-numbers language-CSS\" data-language=\"CSS\"><code class=\"language-CSS\">#red &#123; &#125;\n &#x2F;* &#123;0, 1, 0, 0&#125; *&#x2F;\n</code></pre>\n\n<p>⽐较优先级的⽅式是从 A 到 D 去⽐较值的⼤⼩，A、B、C、D 权重从左到右，依次减⼩。判断优先级时，从左到右，⼀⼀⽐较，<code>直到⽐较出最⼤值，即可停⽌</code>。</p>\n<p>⽐如第⼆个例⼦的 B 与第⼀个例⼦的 B 相⽐，1&gt;0,<code>接下来就不需要⽐较了，第⼆个选择器的优先级更⾼</code>。</p>\n<h2 id=\"比-important更高的优先级\"><a href=\"#比-important更高的优先级\" class=\"headerlink\" title=\"比!important更高的优先级\"></a>比<code>!important</code>更高的优先级</h2><p>从三个方面来说： <span style=\"color: red\">H5 标签、CSS3 样式、媒体查询、文件关系</span></p>\n<ul>\n<li><code>picture source</code></li>\n<li><code>image srcset</code></li>\n<li><code>max-width、min-width</code></li>\n<li><code>media媒体查询</code></li>\n<li><code>同是!important，内部文件优先于外部文件</code></li>\n<li><code>同是!important，link 优先于@import</code></li>\n<li>antd <code>:global</code> 样式覆盖</li>\n</ul>\n<h2 id=\"link-和-import-的区别\"><a href=\"#link-和-import-的区别\" class=\"headerlink\" title=\"link 和@import 的区别\"></a>link 和@import 的区别</h2><ul>\n<li>link 属于 <code>XHTML 标签</code>，⽽@import 是 <code>CSS 提供的</code>。</li>\n<li>⻚⾯被加载时，<code>link 会同时被加载</code>，⽽@import 引⽤的 CSS 会<code>等到⻚⾯被加载完再加载</code>。</li>\n<li>import 只在 IE 5 以上才能识别，⽽ link 是 XHTML 标签，⽆<code>兼容问题</code>。</li>\n<li>link ⽅式的样式<code>权重</code>⾼于@import 的权重。</li>\n<li>使⽤ dom 控制样式时的差别。当使⽤ <code>javascript 控制 dom 去改变样式</code>的时候，只能使⽤ link 标签，因为@import 不是 dom 可以控制的。</li>\n</ul>\n<h2 id=\"CSS-隐藏⻚⾯元素\"><a href=\"#CSS-隐藏⻚⾯元素\" class=\"headerlink\" title=\"CSS 隐藏⻚⾯元素\"></a>CSS 隐藏⻚⾯元素</h2><ul>\n<li><code>opacity:0 </code>：本质上是将元素的透明度将为 0，就看起来隐藏了，但是依然<code>占据空间可交互</code></li>\n<li><code>visibility:hidden</code> : 与上⼀个⽅法类似的效果，<code>占据空间不可交互</code></li>\n<li><code>overflow:hidden</code> : 这个只隐藏元素溢出的部分，<code>占据空间不可交互</code></li>\n<li><code>display:none</code> : 这个是彻底隐藏了元素，元素从⽂档流中消失，<code>不占据空间不交互</code></li>\n<li><code>z-index:-9999</code> : 原理是将层级放到底部，这样就被覆盖了，<code>不占据空间不交互</code></li>\n<li><code>transform: scale(0,0) </code>: 平⾯变换，将元素缩放为 0，<code>占据空间不可交互</code></li>\n<li><code>transform: </code>: 移出可视区域<code>占据空间不可交互</code></li>\n</ul>\n<h2 id=\"em-px-rem-区别\"><a href=\"#em-px-rem-区别\" class=\"headerlink\" title=\"em\\px\\rem 区别\"></a>em\\px\\rem 区别</h2><ul>\n<li><code>px</code>：绝对单位，⻚⾯按精确像素展示。</li>\n<li><code>em</code>：相对单位，基准点为⽗节点字体的⼤⼩，如果⾃身定义了 font-size 按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内 1em 不是⼀个固定的值。</li>\n<li><code>rem</code>：相对单位，可理解为”root em”, 相对根节点 html 的字体⼤⼩来计算，CSS3 新加属性，chrome&#x2F;firefox&#x2F;IE9+⽀ 持</li>\n</ul>\n<h2 id=\"块级元素⽔平居中的⽅法\"><a href=\"#块级元素⽔平居中的⽅法\" class=\"headerlink\" title=\"块级元素⽔平居中的⽅法\"></a>块级元素⽔平居中的⽅法</h2><p>如果使⽤ Hack 的话，⽔平居中的⽅法⾮常多，主流的，奇葩的⻅拓展阅读</p>\n<ul>\n<li><code>margin:0 auto </code>⽅法</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  .center &#123;\n    height: 200px;\n    width: 200px;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre>\n\n<ul>\n<li><code>flex</code> 布局，⽬前主流⽅法</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  .center&#123; display:flex; justify-content:center; 9 &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;1&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;2&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<ul>\n<li><code>table</code> ⽅法 <code>标签打印时候遇到</code></li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  .center &#123;\n    display: table;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre>\n\n<p>还有⼀些通过 <code>position+(margin|transform)</code>等⽅法的不⼀样列举了，⾮重点没必要</p>\n<h2 id=\"CSS-5-种定位⽅式\"><a href=\"#CSS-5-种定位⽅式\" class=\"headerlink\" title=\"CSS 5 种定位⽅式\"></a>CSS 5 种定位⽅式</h2><ul>\n<li><code>static</code>: <code>正常⽂档流定位</code>，此时 top, right, bottom, left 和 z-index <code>属性⽆效</code>，<code>块级元素：从上往下纵向排布</code>，<code>⾏级元素:从左向右排列</code>。</li>\n<li><code>relative</code>：<code>相对定位</code>，此时的『相对』是<code>相对于正常⽂档流的位置</code>。</li>\n<li><code>absolute</code>：<code>相对于最近的⾮ static 定位祖先元素的偏移</code>，⽐如⼀个绝对定位元素它的⽗级、和祖 ⽗级元素都为 relative，它会相对他的⽗级⽽产⽣偏移。</li>\n<li><code>fixed</code>：指定元素<code>相对于屏幕视⼝（viewport）的位置</code>。元素的位置在屏幕滚动时不会改变，⽐如那 种回到顶部的按钮⼀般都是⽤此定位⽅式。</li>\n<li><code>sticky</code>：<code>粘性定位</code>，特性<code>近似于 relative 和 fixed 的合体</code>，其在实际应⽤中的近似效果就是 IOS 通讯录滚动的时候的 『顶屁股』。</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>需要注意 BFC 的影响，<a href=\"https://blog.csdn.net/kaosini/article/details/118760075\" target=\"_blank\" >position:fixed 没有相对浏览器窗口定位的原因 transform 冲突</a>,<code>注：在虚拟列表时候会遇到</code></p>\n</div>\n<h2 id=\"层叠上下文\"><a href=\"#层叠上下文\" class=\"headerlink\" title=\"层叠上下文\"></a>层叠上下文</h2><p><strong>是什么</strong></p>\n<p>层叠上下⽂是 HTML 元素的三维概念，这些 HTML 元素在⼀条假想的相对于⾯向（电脑屏幕的）视窗或者⽹⻚的⽤户的 z 轴上延伸，HTML 元素依据其⾃身属性按照优先级顺序占⽤层叠上下⽂的空间。</p>\n<p><code>可以理解为 JS 中的作用域，一个页面中往往不仅仅只有一个层叠上下文</code></p>\n<h3 id=\"如何产⽣？\"><a href=\"#如何产⽣？\" class=\"headerlink\" title=\"如何产⽣？\"></a>如何产⽣？</h3><p>触发以下条件则会产⽣层叠上下⽂：</p>\n<p><strong>默认创建层叠上下文</strong></p>\n<ul>\n<li>根元素 (HTML)</li>\n</ul>\n<p><strong>需要配合 z-index 触发创建层叠上下文</strong></p>\n<ul>\n<li><code>z-index + position</code>值不为 “auto”的 绝对&#x2F;相对定位</li>\n<li><code>z-index + flex</code> ⼀个 z-index 值不为 “auto”的 flex 项⽬ (flex item)，即：⽗元素 display: flex|inline-flex</li>\n</ul>\n<p><strong>不需要配合 z-index 触发创建层叠上下文</strong></p>\n<ul>\n<li>opacity 属性值⼩于 1 的元素（参考 the specification for opacity）</li>\n<li>元素的以下属性的值不是 none：<ul>\n<li>transform</li>\n<li>filter 滤镜</li>\n<li>perspective 3D 元素距视图的距离,以像素计</li>\n<li>clip-path 裁剪图片</li>\n<li>mask &#x2F; mask-image &#x2F; mask-border</li>\n</ul>\n</li>\n<li>isolation 属性被设置为 “isolate”的元素 使用 isolation:isolate 进行阻断，形成一个混合组。组以外的其他元素不会发生层叠。<a href=\"https://www.zhangxinxu.com/wordpress/2016/01/understand-css3-isolation-isolate/\" target=\"_blank\" >深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 </a></li>\n<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇⽂章）</li>\n<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素 (使用滚动回弹效果), <code>在 iOS 13 之后，不需要</code> <a href=\"https://www.cnblogs.com/xiahj/p/8036419.html#1--webkit-overflow-scrollingtouch%E6%98%AF%E4%BB%80%E4%B9%88\" target=\"_blank\" >见</a></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>创建了层叠上下文的元素只影响其子孙代元素</code>，<code>它自身的层叠水平是由它的父层叠上下文所决定的</code></p></blockquote>\n<p>当两个元素<code>层叠水平相同</code>的时候，这时候就要遵循下面两个准则：</p>\n<ul>\n<li>后来居上原则</li>\n<li>谁 z-index 大，谁在上的准则</li>\n</ul>\n<h3 id=\"如何理解-z-index？\"><a href=\"#如何理解-z-index？\" class=\"headerlink\" title=\"如何理解 z-index？\"></a>如何理解 z-index？</h3><p>CSS 中的 z-index 属性控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，可以修改 z-index 来控制元素的图层 位置，⽽且 <code>z-index 只能影响设置了 position 值的元素</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个属性是个“拼爹”的属性。(如果父元素层级低，那么子元素再怎么努力都没有用 <a href=\"https://blog.csdn.net/ccq2y/article/details/82143283\" target=\"_blank\" >见</a></p></blockquote>\n<h3 id=\"7-阶层叠\"><a href=\"#7-阶层叠\" class=\"headerlink\" title=\"7 阶层叠\"></a>7 阶层叠</h3><!-- <img src=\"http://t-blog-images.aijs.top/img/20220717205730.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/20220717215517.png\" />\n\n<p>上图从底到上：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">背景 ---------&gt; 布局相关 -------&gt; 内容相关 ---------------------------------&gt;\n      |                                   |                    ｜\nz-index负值                            z-index0&#x2F;不依赖z-index   z-index正值</code></pre>\n\n<ul>\n<li>如果元素的层叠级别一样，没有别的因素干扰，则遵循后来者居上原则。<a href=\"https://zhuanlan.zhihu.com/p/115951908\" target=\"_blank\" >见</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/weixin_30607659/article/details/101594118\" target=\"_blank\" >CSS 7 阶层叠水平</a></p>\n<h3 id=\"如何比较两个-DOM-元素的显示顺序呢\"><a href=\"#如何比较两个-DOM-元素的显示顺序呢\" class=\"headerlink\" title=\"如何比较两个 DOM 元素的显示顺序呢\"></a>如何比较两个 DOM 元素的显示顺序呢</h3><!-- - 1、同一个层叠上下文，层叠级别大的元素在上\n\n- 2、同一个层叠上下文，层叠级别相同，后来居上\n\n- 3、不同的层叠上下文，由父级元素层叠上下文决定 -->\n\n<ul>\n<li>如果是<code>在不同的层叠上下文中</code>，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下, 这个两个元素所在的局部层叠上下文的层叠水平。</li>\n<li>如果是<code>在相同的层叠上下文</code>，按照层叠水平的规则来显示元素; 层叠级别相同，后来居上</li>\n</ul>\n<h3 id=\"为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？\"><a href=\"#为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？\" class=\"headerlink\" title=\"为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？\"></a>为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？</h3><p>因为 float 和块级元素一般都作布局，内联元素都是内容。而一个网页中最重要的就是内容，所以一定要让内容的层叠顺序相当高，这样可以在发生层叠时，重要的图片、文字内容可以优先暴露在屏幕上。</p>\n<p><a href=\"https://segmentfault.com/a/1190000021602879?sort=newest\" target=\"_blank\" >重学前端之 CSS(三)BFC 与层叠上下文</a></p>\n<h2 id=\"块级格式化上下文\"><a href=\"#块级格式化上下文\" class=\"headerlink\" title=\"块级格式化上下文\"></a>块级格式化上下文</h2><h3 id=\"BFC-是什么\"><a href=\"#BFC-是什么\" class=\"headerlink\" title=\"BFC 是什么?\"></a>BFC 是什么?</h3><p>书⾯解释：BFC(Block Formatting Context)这⼏个英⽂拆解</p>\n<ul>\n<li><p><code>Box</code>: CSS 布局的基本单位，Box 是 CSS 布局的对象和基本单位， 直观点来说，就是⼀个⻚⾯是由很多个 Box 组成的，实际就是上个问题说的盒模型</p>\n</li>\n<li><p><code>Formatting context</code>：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤</p>\n<p><code>简⽽⾔之，它是⼀块独⽴的区域，让处于 BFC 内部的元素与外部的元素互相隔离</code></p>\n</li>\n</ul>\n<h3 id=\"如何形成\"><a href=\"#如何形成\" class=\"headerlink\" title=\"如何形成?\"></a>如何形成?</h3><p>BFC 触发条件:</p>\n<ul>\n<li><code>根元素</code>，即 HTML 元素</li>\n<li><code>float</code> 不为 none</li>\n<li><code>display</code> 的值为 inline-block、table-cell、table-caption(表格标题)</li>\n<li><code>position</code>: fixed&#x2F;absolute</li>\n<li><code>overflow</code> 不为 visible</li>\n</ul>\n<h3 id=\"BFC-特点\"><a href=\"#BFC-特点\" class=\"headerlink\" title=\"BFC 特点\"></a>BFC 特点</h3><p><a href=\"https://www.shuzhiduo.com/A/qVdeBaYAzP/#:~:text=auto%E3%80%81hidden%E3%80%81scroll-,BFC%E7%9A%84%E7%89%B9%E7%82%B9,-1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA\" target=\"_blank\" >BFC 的特点</a></p>\n<ul>\n<li>1、在一个 BFC 内部，<code>盒子会在垂直方向上排列</code></li>\n<li>2、在一个 BFC 内部，<code>相邻的 margin-bottom 和 margin-top 叠加</code></li>\n<li>3、在一个 BFC 内部，<code>每个元素左边紧贴着包含盒子的左边</code></li>\n<li>4、在一个 BFC 内部，<code>如果有一个内部元素是一个新的 BFC，则新 BFC 区域不会与 float 元素的区域重叠</code></li>\n<li>5、计算一个 BFC 高度时，<code>内部浮动元素的高度也会参与计算</code></li>\n</ul>\n<h3 id=\"作⽤是什么？\"><a href=\"#作⽤是什么？\" class=\"headerlink\" title=\"作⽤是什么？\"></a>作⽤是什么？</h3><ul>\n<li>防⽌ <code>margin重叠</code></li>\n<li>两栏布局，防⽌<code>⽂字环绕</code>等</li>\n<li>防⽌<code>元素塌陷</code></li>\n</ul>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h2><p>盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。</p>\n<h3 id=\"标准盒模型-x2F-怪异盒模型\"><a href=\"#标准盒模型-x2F-怪异盒模型\" class=\"headerlink\" title=\"标准盒模型&#x2F;怪异盒模型\"></a>标准盒模型&#x2F;怪异盒模型</h3><p>在 W3C 标准下，我们定义元素的 width 值即为盒模型中的 content 的宽度值，height 值即为盒模型中的 content 的⾼度值。 因此，</p>\n<p><strong>标准盒模型下：</strong></p>\n<p><code>元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</code></p>\n<img src=\"http://t-blog-images.aijs.top/img/20220718000736.png\" />\n\n<p><strong>IE 怪异盒模型</strong></p>\n<p>（IE8 以下）width 的宽度并不是 content 的宽度，⽽是</p>\n<p><code>元素的宽度 = margin-left + width + margin-right</code></p>\n<p>对于 width,</p>\n<p><code>width = border-left + padding-left + content 的宽度值 + padding-right + border-right</code>，height 同理。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220718000754.png\" />\n\n<p><code>现代浏览器默认使⽤ W3C 的标准盒模型</code>，在不少情况下怪异盒模型更好⽤，于是 W3C 在 css3 中加⼊ <code>box-sizing</code> 。</p>\n<p><code>box-sizing: content-box</code> &#x2F;&#x2F; 标准盒模型<br><code>box-sizing: border-box</code> &#x2F;&#x2F; 怪异盒模型<br><code>box-sizing: padding-box</code> &#x2F;&#x2F; ⽕狐的私有模型，没⼈⽤</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p>可以使用一个，两个或三个值来指定 flex 属性。</p>\n<h3 id=\"none\"><a href=\"#none\" class=\"headerlink\" title=\"none\"></a>none</h3><p>元素会根据自身宽高来设置尺寸。它是完全非弹性的：<span style=\"color: red\">既不会缩短，也不会伸长</span> 来适应 flex 容器。相当于将属性设置为<code>&quot;flex: 0 0 auto&quot;</code>。</p>\n  <br/>\n  <br/>\n\n<h3 id=\"initial\"><a href=\"#initial\" class=\"headerlink\" title=\"initial\"></a>initial</h3><p>元素会根据自身宽高设置尺寸。它 <span style=\"color: red\">会缩短自身以适应 flex 容器，但不会伸长并吸收 </span> flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为<code>&quot;flex: 0 1 auto&quot;</code>。<br><br/><br><br/></p>\n<h3 id=\"auto\"><a href=\"#auto\" class=\"headerlink\" title=\"auto\"></a>auto</h3><p>元素会根据自身的宽度与高度来确定尺寸，但是 <span style=\"color: red\">会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应</span> flex 容器。这相当于将属性设置为 <code>&quot;flex: 1 1 auto&quot;</code>.</p>\n<h3 id=\"单值语法\"><a href=\"#单值语法\" class=\"headerlink\" title=\"单值语法:\"></a>单值语法:</h3><p>值必须为以下其中之一:</p>\n<ul>\n<li>一个无单位数(<code>&lt;number&gt;</code>): 它会被当作 flex:<code>&lt;number&gt;</code> 1 0; 解释：<code>&lt;flex-shrink&gt;</code>的值被假定为 1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为 0。</li>\n<li>一个有效的宽度(width)值: 它会被当作 <code>&lt;flex-basis&gt;</code>的值。</li>\n<li>关键字 none，auto 或 initial.</li>\n</ul>\n<h3 id=\"双值语法\"><a href=\"#双值语法\" class=\"headerlink\" title=\"双值语法:\"></a>双值语法:</h3><p>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。第二个值必须为以下之一：</p>\n<ul>\n<li>无单位数：它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>\n<li>有效的宽度值: 它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>\n</ul>\n<h3 id=\"三值语法\"><a href=\"#三值语法\" class=\"headerlink\" title=\"三值语法:\"></a>三值语法:</h3><ul>\n<li>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。</li>\n<li>第二个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>\n<li>第三个值必须为一个有效的宽度值， 并且它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>\n</ul>\n<p><a href=\"/#/post/2022-05-23width0\" target=\"_blank\" >见</a></p>\n<h2 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h2><p><a href=\"https://www.cnblogs.com/xiaohuochai/p/5848612.html\" target=\"_blank\" >深入理解 CSS Media 媒体查询</a></p>\n<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>媒体查询包含⼀个可选的媒体类型和，满⾜ CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为 true 或 false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式 的值都是 true，那么该媒体查询的结果为 true.那么媒体查询内的样式将会⽣效。<br>媒体查询，用于<code>响应适配</code>。</p>\n<h3 id=\"如何使⽤？\"><a href=\"#如何使⽤？\" class=\"headerlink\" title=\"如何使⽤？\"></a>如何使⽤？</h3><div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>媒体属性必须用括号()包起来，否则无效</p>\n</div>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- link元素中的CSS媒体查询 --&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;(max-width: 800px)&quot; href&#x3D;&quot;example.css&quot; &#x2F;&gt;\n&lt;!-- 样式表中的CSS媒体查询 --&gt;\n&lt;style&gt;\n  @media (max-width: 600px) &#123;\n    .facet_sidebar &#123;\n      display: none;\n    &#125;\n  &#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<h3 id=\"常见媒体属性\"><a href=\"#常见媒体属性\" class=\"headerlink\" title=\"常见媒体属性\"></a>常见媒体属性</h3><ul>\n<li><p>设备宽高比（device-aspect-ratio）</p>\n</li>\n<li><p>设备高度（device-height）</p>\n</li>\n<li><p>设备宽度（device-width）</p>\n</li>\n<li><p>方向（orientation）值：landscape(横屏) | portrait(竖屏)</p>\n</li>\n<li><p>分辨率（resolution）像素密度</p>\n</li>\n</ul>\n<h3 id=\"print-x2F-screen\"><a href=\"#print-x2F-screen\" class=\"headerlink\" title=\"print&#x2F;screen\"></a>print&#x2F;screen</h3><p>不用括号</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot; media&#x3D;&quot;print&quot; &#x2F;&gt;\n\n&lt;style&gt;\n  @media print &#123;\n  &#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<h3 id=\"逻辑操作符\"><a href=\"#逻辑操作符\" class=\"headerlink\" title=\"逻辑操作符\"></a>逻辑操作符</h3><p>操作符 not、and、only 和逗号(,)可以用来构建复杂的媒体查询</p>\n<h3 id=\"相对单位\"><a href=\"#相对单位\" class=\"headerlink\" title=\"相对单位\"></a>相对单位</h3><p>如果媒体查询@media 使用的是相对单位，<span style=\"color: red\">如 rem，这里有一个坑需要着重强调一下</span></p>\n<p><span style=\"color: red\">一般而言，rem 是相对于 HTML 的字体大小的。但是，由于媒体查询的级别非常高，它并不是 HTML 的子元素，不是相对于 HTML，而是相对于浏览器的，而浏览器的默认字体大小是 16px</span></p>\n<p>如果 HTML 设置字体大小为 12px，设置如下媒体查询</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">media&#x3D;&quot;only screen and (max-width:1rem)&quot;</code></pre>\n\n<p>实际上，max-width 等于 16px，而不是 12px</p>\n<p>而正是<code>由于媒体查询是相对于浏览器的</code>， 所以使用 rem 就没有必要，完全可以使用 em 来替代</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">media&#x3D;&quot;only screen and (max-width:1em)&quot;</code></pre>\n\n<h2 id=\"回流和重绘\"><a href=\"#回流和重绘\" class=\"headerlink\" title=\"回流和重绘\"></a>回流和重绘</h2><h3 id=\"浏览器渲染机制\"><a href=\"#浏览器渲染机制\" class=\"headerlink\" title=\"浏览器渲染机制\"></a>浏览器渲染机制</h3><p><span style=\"color: red\">浏览器采用流式布局</span><br>浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就形成渲染树<br>有了渲染树，我们就知道所有节点的样式，然后计算他们在页面上的大小和位置，把它们绘制到页面上</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：浏览器采用流式布局，对渲染树的计算只需要遍历一次就能完成，<span style=\"color: red\">但 table 布局除外，他需要花费 3 倍的时间</span> ，所以我们要尽量避免使用 table 布局</p></blockquote>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><ul>\n<li><code>影响部分或全部页面的布局时，会进行回流</code>，回流的代价比重绘高</li>\n<li><code>回流一定会引起重绘，但重绘不一定会引起回流</code></li>\n</ul>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>元素样式发生变化，但是<code>不影响页面整个布局的情况下会进行重绘</code>，如 outline、visibility、color、background-color 等</p>\n<h3 id=\"浏览器优化\"><a href=\"#浏览器优化\" class=\"headerlink\" title=\"浏览器优化\"></a>浏览器优化</h3><p>浏览器是<code>通过队列机制来批量更新布局</code>，浏览器刷新频率为（60 帧&#x2F;s）,每刷新一次需要 16.6ms，也就是说 16.6ms 浏览器会清空队列，但是在我们获取布局信息的时候，有一些属性或方法会强制浏览器刷新，触发重绘和回流并且清空队列，比如：</p>\n<ul>\n<li>offset 系列：<code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code> <a href=\"https://www.jb51.net/article/219621.htm\" target=\"_blank\" >距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent 为 body</a></li>\n<li>scroll 系列： <code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code> <a href=\"https://blog.csdn.net/muxi229/article/details/106849535\" target=\"_blank\" >方法返回或设置匹配元素的滚动条的偏移位置</a></li>\n<li>client 系列：<code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code> clientTop、clientLeft 获取的是上边框、左边框的宽度 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientLeft\" target=\"_blank\" >见 MDN</a></li>\n<li><code>width</code>、<code>height</code></li>\n<li><code>getComputedStyle()</code> 用于获取指定元素的 CSS 样式</li>\n<li><code>getBoundingClientRect()</code> 用于获取某个元素相对于视窗的位置集合。集合中有 top, right, bottom, left 等属性。</li>\n</ul>\n<p>强制触发浏览器刷新,所以我们要尽量少使用以上属性和方法</p>\n<h3 id=\"减少重绘和回流\"><a href=\"#减少重绘和回流\" class=\"headerlink\" title=\"减少重绘和回流\"></a>减少重绘和回流</h3><ul>\n<li><code>替代方案</code><br>使用 transform 代替 top<br>使用 visibility(只触发重绘)代替 display(触发回流)</li>\n<li><code>嵌套层级</code><br>尽可能在 DOM 树的末端改变样式类 class，影响尽量少的节点<br>css 选择器尽量不要嵌套过深，从右往左匹配</li>\n<li><code>动画</code><br>动画效果最好添加到 <code>position：absolute 或 fixed 的元素上，不影响其他元素</code>，只引发重绘，不引发回流，控制动画的速度可以使用 <code>requestAnimationFrame()</code></li>\n<li><code>css 表达式</code><br>避免使用 css 表达式，calc()会引发回流</li>\n<li><code>设为图层</code><br>将频繁重绘或回流的节点设置为图层，如：will-change，video，iframe，cavas，防止影响别的节点</li>\n<li><code>CSS3 硬件加速</code>，transform，opacity 等不会引起回流重绘</li>\n<li>批量操作使用 <code>documentFragment</code>,批量更新，虚拟 dom</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/bf5c498107e2\" target=\"_blank\" >参考链接</a></p>\n<h2 id=\"层叠、优先级和继承\"><a href=\"#层叠、优先级和继承\" class=\"headerlink\" title=\"层叠、优先级和继承\"></a>层叠、优先级和继承</h2><p>决定着如何将 CSS 应用到 HTML 中，以及如何解决冲突。</p>\n<h3 id=\"层叠\"><a href=\"#层叠\" class=\"headerlink\" title=\"层叠\"></a>层叠</h3><ul>\n<li>简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</li>\n</ul>\n<p>三要素：资源顺序，优先级，重要程度</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><ul>\n<li>高的优先级——它范围更小</li>\n<li>覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有相同优先级而且顺序靠后，<code>或者更高优先级</code>。</li>\n<li>!important 非必要不使用，影响调试</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#!important\" target=\"_blank\" >见</a></p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>表单元素默认不会继承字体样式</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Images_media_form_elements#:~:text=%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C-,%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E9%BB%98%E8%AE%A4%E4%B8%8D%E4%BC%9A%E7%BB%A7%E6%89%BF%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F,-%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%A6%82%E6%9E%9C%E4%BD%A0\" target=\"_blank\" >见</a></p>\n<h2 id=\"display-inline-block\"><a href=\"#display-inline-block\" class=\"headerlink\" title=\"display: inline-block\"></a>display: inline-block</h2><p>在内联和块之间提供了一个中间状态。这对于以下情况非常有用：您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠</p>\n<p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<a> 是像 <span> 一样的内联元素；你可以使用 display: inline-block 来设置内边距，让用户更容易点击链接</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#%E4%BD%BF%E7%94%A8_display_inline-block\" target=\"_blank\" >见</a></p>\n<h2 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比\"></a>百分比</h2><p>使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的内联尺寸进行计算的，也就是元素的水平宽度。在我们的示例中，所有的外边距或填充都是宽度的 10%。请记住一个事实，当你使用百分比作为元素外边距或填充的单位时，你将得到一个相同尺寸的外边距或填充。</p>\n<h2 id=\"max-width-的常见用法为，\"><a href=\"#max-width-的常见用法为，\" class=\"headerlink\" title=\"max-width 的常见用法为，\"></a>max-width 的常见用法为，</h2><p>在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p>\n<p>作为示例，如果你设定一个图像的属性为 width: 100%，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。</p>\n<p>如果你使用了 max-width: 100%，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的 100%。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS#min-%E5%92%8C_max-%E5%B0%BA%E5%AF%B8:~:text=%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E3%80%82-,max%2Dwidth%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E4%B8%BA,-%EF%BC%8C%E5%9C%A8%E6%B2%A1%E6%9C%89%E8%B6%B3%E5%A4%9F\" target=\"_blank\" >见</a></p>\n<p><span style=\"color: red\">这个技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放</span></p>\n<h2 id=\"object-fit\"><a href=\"#object-fit\" class=\"headerlink\" title=\"object-fit\"></a>object-fit</h2><h2 id=\"替换元素-与-普通元素的区别\"><a href=\"#替换元素-与-普通元素的区别\" class=\"headerlink\" title=\"替换元素 与 普通元素的区别\"></a><code>替换元素</code> 与 <code>普通元素</code>的区别</h2><h3 id=\"什么是替换元素\"><a href=\"#什么是替换元素\" class=\"headerlink\" title=\"什么是替换元素\"></a>什么是替换元素</h3><p>图像和视频被描述为<strong>替换元素</strong></p>\n<h3 id=\"与普通区别\"><a href=\"#与普通区别\" class=\"headerlink\" title=\"与普通区别\"></a>与普通区别</h3><ul>\n<li>CSS 不能影响它们的内部布局, 仅影响它们在页面上相对于其它元素的位置</li>\n<li>flex 或者 grid 布局中，默认情况下元素会被拉伸到充满整块区域。但是图像不会被拉伸，而会对齐到网格区域或者弹性容器的起始处。</li>\n</ul>\n<h2 id=\"介绍下-Web-字体\"><a href=\"#介绍下-Web-字体\" class=\"headerlink\" title=\"介绍下 Web 字体\"></a>介绍下 Web 字体</h2><h3 id=\"声明及使用\"><a href=\"#声明及使用\" class=\"headerlink\" title=\"声明及使用\"></a>声明及使用</h3><p>CSS 有一个@font-face 块，它指定要下载的字体文件：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">@font-face &#123;\n  font-family: &quot;myFont&quot;;\n  src: url(&quot;myFont.ttf&quot;);\n&#125;\n\n&#x2F;* 使用 *&#x2F;\nhtml &#123;\n  font-family: &quot;myFont&quot;, &quot;Bitstream Vera Serif&quot;, serif;\n&#125;\n\n&#x2F;* 详细使用 *&#x2F;\n@font-face &#123;\n  font-family: &quot;ciclefina&quot;;\n  src: url(&quot;fonts&#x2F;cicle_fina-webfont.eot&quot;);\n  &#x2F;* 字体路径及文件格式 *&#x2F;\n  src: url(&quot;fonts&#x2F;cicle_fina-webfont.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.woff2&quot;)\n      format(&quot;woff2&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.woff&quot;) format(&quot;woff&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.ttf&quot;)\n      format(&quot;truetype&quot;),\n    url(&quot;fonts&#x2F;cicle_fina-webfont.svg#ciclefina&quot;) format(&quot;svg&quot;);\n  font-weight: normal;\n  font-style: normal;\n&#125;</code></pre>\n\n<h3 id=\"字体使用注意点\"><a href=\"#字体使用注意点\" class=\"headerlink\" title=\"字体使用注意点\"></a>字体使用注意点</h3><h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>例如，</p>\n<ul>\n<li>大多数现代浏览器都支持 WOFF &#x2F; WOFF2(Web Open Font Format versions 1 and 2，Web 开放字体格式版本 1 和 2)，它是最有效的格式，</li>\n<li>但是旧版本 IE 只支持 EOT (Embedded Open Type，嵌入式开放类型) 的字体，</li>\n<li>你可能需要包括一个 SVG 版本的字体支持旧版本的 iPhone 和 Android 浏览器。</li>\n</ul>\n<h3 id=\"付费\"><a href=\"#付费\" class=\"headerlink\" title=\"付费\"></a>付费</h3><p>字体一般都不能自由使用。您必须为他们付费，或者遵循其他许可条件，比如在代码中 (或者在您的站点上) 提供字体创建者。你不应该在没有适当的授权的情况下偷窃字体。</p>\n<h3 id=\"字体查找\"><a href=\"#字体查找\" class=\"headerlink\" title=\"字体查找\"></a>字体查找</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Web_fonts#%E6%9F%A5%E6%89%BE%E5%AD%97%E4%BD%93\" target=\"_blank\" >见</a></p>\n<h2 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h2><h3 id=\"产生的背景\"><a href=\"#产生的背景\" class=\"headerlink\" title=\"产生的背景\"></a>产生的背景</h3><p>引入 float 属性是为了能让 Web 开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面上看到过</p>\n<h3 id=\"浮动是如何工作的\"><a href=\"#浮动是如何工作的\" class=\"headerlink\" title=\"浮动是如何工作的\"></a>浮动是如何工作的</h3><p>浮动元素 (这个例子中的 <code>&lt;div&gt;</code> 元素) 会脱离正常的文档布局流，并吸附到其父容器的左边（这个例子中的 <code>&lt;body&gt;</code> 元素）。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间</p>\n<h3 id=\"清除浮动-3-中方式\"><a href=\"#清除浮动-3-中方式\" class=\"headerlink\" title=\"清除浮动 3 中方式\"></a>清除浮动 3 中方式</h3><ul>\n<li>伪元素方法</li>\n<li>使用 overflow : 将包裹元素的 overflow 属性设置为除 visible 外的其他值</li>\n<li>display: flow-root: 一个较为现代的方案是使用 display 属性的 flow-root 值</li>\n</ul>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* 伪元素方法 *&#x2F;\n.wrapper::after &#123;\n  content: &quot;&quot;;\n  clear: both;\n  display: block;\n&#125;\n&#x2F;* 将包裹元素的 overflow 属性设置为除 visible 外的其他值 *&#x2F;\n.wrapper &#123;\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  overflow: auto;\n&#125;\n\n.wrapper &#123;\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  display: flow-root;\n&#125;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202210261409914.webp\" />\n\n<h2 id=\"介绍下-flex\"><a href=\"#介绍下-flex\" class=\"headerlink\" title=\"介绍下 flex\"></a>介绍下 flex</h2><h3 id=\"flex-出现解决了什么问题\"><a href=\"#flex-出现解决了什么问题\" class=\"headerlink\" title=\"flex 出现解决了什么问题\"></a>flex 出现解决了什么问题</h3><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的创建工具只有 floats 和 positioning。这两个工具大部分情况下都很好使，但是在某些方面它们具有一定的局限性，让人难以完成任务</p>\n<ul>\n<li>在父内容里面垂直居中一个块内容。</li>\n<li>使容器的<code>所有子项占用等量的可用宽度/高度</code>，而不管有多少宽度&#x2F;高度可用。</li>\n<li>使<code>多列布局中的所有列采用相同的高度</code>，即使它们包含的内容量不同。</li>\n</ul>\n<p>弹性盒子使得很多布局任务变得更加容易</p>\n<h3 id=\"flex-布局的特点\"><a href=\"#flex-布局的特点\" class=\"headerlink\" title=\"flex 布局的特点\"></a>flex 布局的特点</h3><img src=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png\" />\n\n<ul>\n<li>主轴</li>\n<li>交叉轴</li>\n<li>flex 容器（flex container）</li>\n<li>flex 项(flex item)</li>\n</ul>\n<h3 id=\"行还是列\"><a href=\"#行还是列\" class=\"headerlink\" title=\"行还是列\"></a>行还是列</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">flex-direction</code></pre>\n\n<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">flex-wrap: wrap; &#x2F;**换行 *&#x2F;</code></pre>\n\n<h3 id=\"flex-flow\"><a href=\"#flex-flow\" class=\"headerlink\" title=\"flex-flow\"></a>flex-flow</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">flex-direction: row;\nflex-wrap: wrap;\n\n&#x2F;* 简写 *&#x2F;\nflex-flow: row wrap;</code></pre>\n\n<h3 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h3><ul>\n<li>默认值：stretch, 会使 flex 项沿着交叉轴的方向拉伸，以填充父容器</li>\n<li>center</li>\n<li>flex-start,flex-end,在交叉轴开始&#x2F;结束处对齐</li>\n</ul>\n<h3 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h3><ul>\n<li>默认值：flex-start, 会使所有的 flex 项都位于主轴开始处</li>\n<li>flex-end 使 flex 项位于结尾处</li>\n<li>center, 让 flex 项在主轴中居中</li>\n<li>space-around 使所有 flex 项在主轴均匀分布，任意一端会留一点空间</li>\n<li>space-between 与 space-around 类似，两端不留空间</li>\n</ul>\n<h3 id=\"flex-项排序\"><a href=\"#flex-项排序\" class=\"headerlink\" title=\"flex 项排序\"></a>flex 项排序</h3><p>可以改变 flex 项的布局位置的功能，而<code>不会影响 dom 树里元素的顺序</code></p>\n<ul>\n<li>默认 order 使 0</li>\n<li>order 越大越靠后</li>\n<li>相同 order，按 dom 树顺序排布（也就是没啥影响）</li>\n</ul>\n<h2 id=\"响应式设计\"><a href=\"#响应式设计\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h2><p>响应式 Web 设计不是单独的技术，它是描述 Web 设计的一种方式、或者是一组最佳实践的一个词，它是用来建立可以响应查看内容的设备的样式的一个词</p>\n<h3 id=\"出现的背景\"><a href=\"#出现的背景\" class=\"headerlink\" title=\"出现的背景\"></a>出现的背景</h3><p>响应式设计之前的灵活布局，根据不同屏幕分辨率进行探测，载入对应的 css</p>\n<h3 id=\"响应式设计包含三部分\"><a href=\"#响应式设计包含三部分\" class=\"headerlink\" title=\"响应式设计包含三部分\"></a>响应式设计包含三部分</h3><ul>\n<li>液态网格</li>\n<li>液态图像</li>\n<li>媒体查询</li>\n</ul>\n<h3 id=\"响应式设计-1\"><a href=\"#响应式设计-1\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h3><ul>\n<li><em>断点：</em>媒体查询，以及样式改变时的点，被叫做断点（breakpoints）</li>\n<li><em>移动优先：</em>为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局</li>\n</ul>\n<h3 id=\"响应式图像\"><a href=\"#响应式图像\" class=\"headerlink\" title=\"响应式图像\"></a>响应式图像</h3><ul>\n<li>可以用一张有着所需最大尺寸的图像。然后缩放它</li>\n<li>响应式图像，使用了<code>&lt;picture&gt;</code>元素和<code>&lt;img&gt;</code> srcset 和 sizes 特性，解决了这两个问题</li>\n</ul>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* 方案1 *&#x2F;\nimg &#123;\n  max-width: 100%:\n&#125;\n\n&#x2F;* 方案2，响应式图像 *&#x2F;\n</code></pre>\n\n<h2 id=\"视口元标签\"><a href=\"#视口元标签\" class=\"headerlink\" title=\"视口元标签\"></a>视口元标签</h2><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1&quot; &#x2F;&gt;</code></pre>\n\n<h3 id=\"为什么需要视口元标签\"><a href=\"#为什么需要视口元标签\" class=\"headerlink\" title=\"为什么需要视口元标签\"></a>为什么需要视口元标签</h3><p>因为移动端浏览器倾向于在它们的视口宽度上说谎。</p>\n<p>由于原来 iPhone 发布以后，人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为 960 像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本</p>\n<p>其他的移动端浏览器（例如谷歌安卓上的）也是这么做的</p>\n<p>没有做响应式的网站，依然可以看到，不过，很少见了</p>\n<h2 id=\"媒体查询-1\"><a href=\"#媒体查询-1\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h2><p>仅在浏览器和设备的环境与你指定的规则相匹配的时候 CSS 才会真的被应用</p>\n<h3 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕） *&#x2F;\n&#x2F;* 媒体类型： all、print、screen、speech *&#x2F;\n&#x2F;* 一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试； *&#x2F;\n&#x2F;* 宽和高，orientation portrait：竖屏 landscape 横屏 *&#x2F;\n&#x2F;* 一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。 *&#x2F;\n@media media-type and (media-feature-rule) &#123;\n  &#x2F;* CSS rules go here *&#x2F;\n&#125;</code></pre>\n\n<h3 id=\"与-x2F-或-x2F-非\"><a href=\"#与-x2F-或-x2F-非\" class=\"headerlink\" title=\"与&#x2F;或&#x2F;非\"></a>与&#x2F;或&#x2F;非</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* 与：使用and *&#x2F;\n@media screen and (min-width: 400px) and (orientation: landscape) &#123;\n  body &#123;\n    color: blue;\n  &#125;\n&#125;\n&#x2F;* 或：使用逗号 *&#x2F;\n@media screen and (min-width: 400px), screen and (orientation: landscape) &#123;\n  body &#123;\n    color: blue;\n  &#125;\n&#125;\n&#x2F;* 非：使用not *&#x2F;\n@media not all and (orientation: landscape) &#123;\n  body &#123;\n    color: blue;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"选择断点\"><a href=\"#选择断点\" class=\"headerlink\" title=\"选择断点\"></a>选择断点</h3><p><code>开发工具响应式设计模式</code>能很好地帮助弄清楚断点应该设置在哪里。<br>你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.zhangxinxu.com/wordpress/2016/01/understand-css3-isolation-isolate/\" target=\"_blank\" >深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 </a></p>\n<p><a href=\"https://blog.csdn.net/weixin_30607659/article/details/101594118\" target=\"_blank\" >CSS 7 阶层叠水平</a></p>\n<p><a href=\"https://www.shuzhiduo.com/A/qVdeBaYAzP/#:~:text=auto%E3%80%81hidden%E3%80%81scroll-,BFC%E7%9A%84%E7%89%B9%E7%82%B9,-1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA\" target=\"_blank\" >BFC 的特点</a></p>\n<p><a href=\"https://www.cnblogs.com/xiaohuochai/p/5848612.html\" target=\"_blank\" >深入理解 CSS Media 媒体查询</a></p>\n<p><a href=\"/#/post/2022-05-23width0\" target=\"_blank\" >flex width:0</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n","text":"CSS 选择器的优先级是怎样的CSS 选择器的优先级是：（标签选择器 &lt; 类选择器 &lt; ID 选择器） &lt; 内联 &lt; !important &lt; 特殊情况 到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下： A 的...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">CSS 选择器的优先级是怎样的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94-important%E6%9B%B4%E9%AB%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">比!important更高的优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#link-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">link 和@import 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">CSS 隐藏⻚⾯元素</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#em-px-rem-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">em\\px\\rem 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E2%BD%94%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E2%BD%85%E6%B3%95\"><span class=\"toc-text\">块级元素⽔平居中的⽅法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-5-%E7%A7%8D%E5%AE%9A%E4%BD%8D%E2%BD%85%E5%BC%8F\"><span class=\"toc-text\">CSS 5 种定位⽅式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">层叠上下文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BA%A7%E2%BD%A3%EF%BC%9F\"><span class=\"toc-text\">如何产⽣？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-z-index%EF%BC%9F\"><span class=\"toc-text\">如何理解 z-index？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E9%98%B6%E5%B1%82%E5%8F%A0\"><span class=\"toc-text\">7 阶层叠</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-DOM-%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E9%A1%BA%E5%BA%8F%E5%91%A2\"><span class=\"toc-text\">如何比较两个 DOM 元素的显示顺序呢</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-inlin-block-%E5%92%8C-inline-%E7%9A%84%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E6%AF%94%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E9%83%BD%E9%AB%98%EF%BC%9F\"><span class=\"toc-text\">为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">块级格式化上下文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">BFC 是什么?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90\"><span class=\"toc-text\">如何形成?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">BFC 特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">作⽤是什么？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%92%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">盒模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B-x2F-%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">标准盒模型&#x2F;怪异盒模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flex\"><span class=\"toc-text\">flex</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#none\"><span class=\"toc-text\">none</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#initial\"><span class=\"toc-text\">initial</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#auto\"><span class=\"toc-text\">auto</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E5%80%BC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">单值语法:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%80%BC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">双值语法:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%80%BC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">三值语法:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">媒体查询</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E2%BD%A4%EF%BC%9F\"><span class=\"toc-text\">如何使⽤？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%AA%92%E4%BD%93%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">常见媒体属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#print-x2F-screen\"><span class=\"toc-text\">print&#x2F;screen</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">逻辑操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%BD%8D\"><span class=\"toc-text\">相对单位</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98\"><span class=\"toc-text\">回流和重绘</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">浏览器渲染机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%B5%81\"><span class=\"toc-text\">回流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E7%BB%98\"><span class=\"toc-text\">重绘</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">浏览器优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81\"><span class=\"toc-text\">减少重绘和回流</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%82%E5%8F%A0%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">层叠、优先级和继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82%E5%8F%A0\"><span class=\"toc-text\">层叠</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">优先级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#display-inline-block\"><span class=\"toc-text\">display: inline-block</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%99%BE%E5%88%86%E6%AF%94\"><span class=\"toc-text\">百分比</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#max-width-%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E4%B8%BA%EF%BC%8C\"><span class=\"toc-text\">max-width 的常见用法为，</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#object-fit\"><span class=\"toc-text\">object-fit</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0-%E4%B8%8E-%E6%99%AE%E9%80%9A%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">替换元素 与 普通元素的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">什么是替换元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E6%99%AE%E9%80%9A%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">与普通区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D%E4%B8%8B-Web-%E5%AD%97%E4%BD%93\"><span class=\"toc-text\">介绍下 Web 字体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">声明及使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E4%BD%93%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">字体使用注意点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%BC%E5%AE%B9%E6%80%A7\"><span class=\"toc-text\">兼容性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%98%E8%B4%B9\"><span class=\"toc-text\">付费</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E4%BD%93%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">字体查找</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#float\"><span class=\"toc-text\">float</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">产生的背景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%AE%E5%8A%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\"><span class=\"toc-text\">浮动是如何工作的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8-3-%E4%B8%AD%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">清除浮动 3 中方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D%E4%B8%8B-flex\"><span class=\"toc-text\">介绍下 flex</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#flex-%E5%87%BA%E7%8E%B0%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">flex 出现解决了什么问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#flex-%E5%B8%83%E5%B1%80%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">flex 布局的特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E8%BF%98%E6%98%AF%E5%88%97\"><span class=\"toc-text\">行还是列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8D%A2%E8%A1%8C\"><span class=\"toc-text\">换行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#flex-flow\"><span class=\"toc-text\">flex-flow</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#align-items\"><span class=\"toc-text\">align-items</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#justify-content\"><span class=\"toc-text\">justify-content</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#flex-%E9%A1%B9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">flex 项排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">响应式设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">出现的背景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8C%85%E5%90%AB%E4%B8%89%E9%83%A8%E5%88%86\"><span class=\"toc-text\">响应式设计包含三部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-1\"><span class=\"toc-text\">响应式设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E5%83%8F\"><span class=\"toc-text\">响应式图像</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%86%E5%8F%A3%E5%85%83%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">视口元标签</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%A7%86%E5%8F%A3%E5%85%83%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">为什么需要视口元标签</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-1\"><span class=\"toc-text\">媒体查询</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99\"><span class=\"toc-text\">语法规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E-x2F-%E6%88%96-x2F-%E9%9D%9E\"><span class=\"toc-text\">与&#x2F;或&#x2F;非</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%96%AD%E7%82%B9\"><span class=\"toc-text\">选择断点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-设计模式","uid":"21c81236c6b792525b47c142ae6ad187","slug":"2022-07-18设计模式","date":"2022-07-18T06:53:04.000Z","updated":"2022-10-31T13:18:24.941Z","comments":true,"path":"api/articles/2022-07-18设计模式.json","keywords":null,"cover":null,"text":"为什么需要设计模式 有助于写出可复用&#x2F;可维护性更高的程序 原则：找出程序中变化的地方，并将变化封装起来，它的关键是意图，而不是结构 SOLID 设计原则S: Single Responsibility Principle 单一职责原则 对象应该仅具有一种单一功能 O: ...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-html","uid":"2854d1d5923e1e62aed568f709662bf4","slug":"2022-07-17html","date":"2022-07-17T01:44:42.000Z","updated":"2022-11-26T07:05:03.112Z","comments":true,"path":"api/articles/2022-07-17html.json","keywords":null,"cover":[],"text":"doctype 的作⽤是什么？DOCTYPE 是 html5 标准⽹⻚声明，且必须声明在 HTML ⽂档的第⼀⾏。 来告知浏览器的解析器⽤什么⽂档标准解析这个⽂档，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析 ⽂档解析类型有： BackCo...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}