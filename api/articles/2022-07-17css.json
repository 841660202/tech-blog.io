{"title":"前端基础-CSS3","uid":"04f522a5377d4d5450ce4cf8a54e76ff","slug":"2022-07-17css","date":"2022-07-17T07:39:25.000Z","updated":"2022-09-16T13:54:56.218Z","comments":true,"path":"api/articles/2022-07-17css.json","keywords":null,"cover":[],"content":"<h2 id=\"CSS-选择器的优先级是怎样的\"><a href=\"#CSS-选择器的优先级是怎样的\" class=\"headerlink\" title=\"CSS 选择器的优先级是怎样的\"></a>CSS 选择器的优先级是怎样的</h2><p>CSS 选择器的优先级是：<span style=\"color: red\">（标签选择器 &lt; 类选择器 &lt; ID 选择器）</span> <code>&lt; 内联 &lt; !important &lt; 特殊情况 </code></p>\n<p>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>\n<ul>\n<li>A 的值等于 1 的前提是存在内联样式, 否则 A &#x3D; 0;</li>\n<li>B 的值等于 ID 选择器 出现的次数;</li>\n<li>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;</li>\n<li>D 的值等于 标签选择器 和 伪元素 出现的总次数 。</li>\n</ul>\n<p>就⽐如下⾯的选择器，它不存在内联样式，所以 A&#x3D;0,不存在 id 选择器 B&#x3D;0,存在⼀个类选择器 C&#x3D;1,存在三个标签选择器 D&#x3D;3，那么最终计算结果为:</p>\n<pre class=\"line-numbers language-CSS\" data-language=\"CSS\"><code class=\"language-CSS\">ul ol li .red &#123; ... &#125;\n &#x2F;* &#123;0, 0, 1 ,3&#125; *&#x2F;</code></pre>\n\n<p>按照这个结算⽅式，下⾯的计算结果为:</p>\n<pre class=\"line-numbers language-CSS\" data-language=\"CSS\"><code class=\"language-CSS\">#red &#123; &#125;\n &#x2F;* &#123;0, 1, 0, 0&#125; *&#x2F;\n</code></pre>\n\n<p>⽐较优先级的⽅式是从 A 到 D 去⽐较值的⼤⼩，A、B、C、D 权重从左到右，依次减⼩。判断优先级时，从左到右，⼀⼀⽐较，<code>直到⽐较出最⼤值，即可停⽌</code>。</p>\n<p>⽐如第⼆个例⼦的 B 与第⼀个例⼦的 B 相⽐，1&gt;0,<code>接下来就不需要⽐较了，第⼆个选择器的优先级更⾼</code>。</p>\n<h2 id=\"比-important更高的优先级\"><a href=\"#比-important更高的优先级\" class=\"headerlink\" title=\"比!important更高的优先级\"></a>比<code>!important</code>更高的优先级</h2><p>从三个方面来说： <span style=\"color: red\">H5 标签、CSS3 样式、媒体查询、文件关系</span></p>\n<ul>\n<li><code>picture source</code></li>\n<li><code>image srcset</code></li>\n<li><code>max-width、min-width</code></li>\n<li><code>media媒体查询</code></li>\n<li><code>同是!important，内部文件优先于外部文件</code></li>\n<li><code>同是!important，link 优先于@import</code></li>\n<li>antd <code>:global</code> 样式覆盖</li>\n</ul>\n<h2 id=\"link-和-import-的区别\"><a href=\"#link-和-import-的区别\" class=\"headerlink\" title=\"link 和@import 的区别\"></a>link 和@import 的区别</h2><ul>\n<li>link 属于 <code>XHTML 标签</code>，⽽@import 是 <code>CSS 提供的</code>。</li>\n<li>⻚⾯被加载时，<code>link 会同时被加载</code>，⽽@import 引⽤的 CSS 会<code>等到⻚⾯被加载完再加载</code>。</li>\n<li>import 只在 IE 5 以上才能识别，⽽ link 是 XHTML 标签，⽆<code>兼容问题</code>。</li>\n<li>link ⽅式的样式<code>权重</code>⾼于@import 的权重。</li>\n<li>使⽤ dom 控制样式时的差别。当使⽤ <code>javascript 控制 dom 去改变样式</code>的时候，只能使⽤ link 标签，因为@import 不是 dom 可以控制的。</li>\n</ul>\n<h2 id=\"CSS-隐藏⻚⾯元素\"><a href=\"#CSS-隐藏⻚⾯元素\" class=\"headerlink\" title=\"CSS 隐藏⻚⾯元素\"></a>CSS 隐藏⻚⾯元素</h2><ul>\n<li><code>opacity:0 </code>：本质上是将元素的透明度将为 0，就看起来隐藏了，但是依然<code>占据空间可交互</code></li>\n<li><code>visibility:hidden</code> : 与上⼀个⽅法类似的效果，<code>占据空间不可交互</code></li>\n<li><code>overflow:hidden</code> : 这个只隐藏元素溢出的部分，<code>占据空间不可交互</code></li>\n<li><code>display:none</code> : 这个是彻底隐藏了元素，元素从⽂档流中消失，<code>不占据空间不交互</code></li>\n<li><code>z-index:-9999</code> : 原理是将层级放到底部，这样就被覆盖了，<code>不占据空间不交互</code></li>\n<li><code>transform: scale(0,0) </code>: 平⾯变换，将元素缩放为 0，<code>占据空间不可交互</code></li>\n<li><code>transform: </code>: 移出可视区域<code>占据空间不可交互</code></li>\n</ul>\n<h2 id=\"em-px-rem-区别\"><a href=\"#em-px-rem-区别\" class=\"headerlink\" title=\"em\\px\\rem 区别\"></a>em\\px\\rem 区别</h2><ul>\n<li><code>px</code>：绝对单位，⻚⾯按精确像素展示。</li>\n<li><code>em</code>：相对单位，基准点为⽗节点字体的⼤⼩，如果⾃身定义了 font-size 按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内 1em 不是⼀个固定的值。</li>\n<li><code>rem</code>：相对单位，可理解为”root em”, 相对根节点 html 的字体⼤⼩来计算，CSS3 新加属性，chrome&#x2F;firefox&#x2F;IE9+⽀ 持</li>\n</ul>\n<h2 id=\"块级元素⽔平居中的⽅法\"><a href=\"#块级元素⽔平居中的⽅法\" class=\"headerlink\" title=\"块级元素⽔平居中的⽅法\"></a>块级元素⽔平居中的⽅法</h2><p>如果使⽤ Hack 的话，⽔平居中的⽅法⾮常多，主流的，奇葩的⻅拓展阅读</p>\n<ul>\n<li><code>margin:0 auto </code>⽅法</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  .center &#123;\n    height: 200px;\n    width: 200px;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre>\n\n<ul>\n<li><code>flex</code> 布局，⽬前主流⽅法</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  .center&#123; display:flex; justify-content:center; 9 &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;1&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;2&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<ul>\n<li><code>table</code> ⽅法 <code>标签打印时候遇到</code></li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  .center &#123;\n    display: table;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre>\n\n<p>还有⼀些通过 <code>position+(margin|transform)</code>等⽅法的不⼀样列举了，⾮重点没必要</p>\n<h2 id=\"CSS-5-种定位⽅式\"><a href=\"#CSS-5-种定位⽅式\" class=\"headerlink\" title=\"CSS 5 种定位⽅式\"></a>CSS 5 种定位⽅式</h2><ul>\n<li><code>static</code>: <code>正常⽂档流定位</code>，此时 top, right, bottom, left 和 z-index <code>属性⽆效</code>，<code>块级元素：从上往下纵向排布</code>，<code>⾏级元素:从左向右排列</code>。</li>\n<li><code>relative</code>：<code>相对定位</code>，此时的『相对』是<code>相对于正常⽂档流的位置</code>。</li>\n<li><code>absolute</code>：<code>相对于最近的⾮ static 定位祖先元素的偏移</code>，⽐如⼀个绝对定位元素它的⽗级、和祖 ⽗级元素都为 relative，它会相对他的⽗级⽽产⽣偏移。</li>\n<li><code>fixed</code>：指定元素<code>相对于屏幕视⼝（viewport）的位置</code>。元素的位置在屏幕滚动时不会改变，⽐如那 种回到顶部的按钮⼀般都是⽤此定位⽅式。</li>\n<li><code>sticky</code>：<code>粘性定位</code>，特性<code>近似于 relative 和 fixed 的合体</code>，其在实际应⽤中的近似效果就是 IOS 通讯录滚动的时候的 『顶屁股』。</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>需要注意 BFC 的影响，<a href=\"https://blog.csdn.net/kaosini/article/details/118760075\" target=\"_blank\" >position:fixed 没有相对浏览器窗口定位的原因 transform 冲突</a>,<code>注：在虚拟列表时候会遇到</code></p>\n</div>\n<h2 id=\"层叠上下文\"><a href=\"#层叠上下文\" class=\"headerlink\" title=\"层叠上下文\"></a>层叠上下文</h2><p><strong>是什么</strong></p>\n<p>层叠上下⽂是 HTML 元素的三维概念，这些 HTML 元素在⼀条假想的相对于⾯向（电脑屏幕的）视窗或者⽹⻚的⽤户的 z 轴上延伸，HTML 元素依据其⾃身属性按照优先级顺序占⽤层叠上下⽂的空间。</p>\n<p><code>可以理解为 JS 中的作用域，一个页面中往往不仅仅只有一个层叠上下文</code></p>\n<h3 id=\"如何产⽣？\"><a href=\"#如何产⽣？\" class=\"headerlink\" title=\"如何产⽣？\"></a>如何产⽣？</h3><p>触发以下条件则会产⽣层叠上下⽂：</p>\n<p><strong>默认创建层叠上下文</strong></p>\n<ul>\n<li>根元素 (HTML)</li>\n</ul>\n<p><strong>需要配合 z-index 触发创建层叠上下文</strong></p>\n<ul>\n<li><code>z-index + position</code>值不为 “auto”的 绝对&#x2F;相对定位</li>\n<li><code>z-index + flex</code> ⼀个 z-index 值不为 “auto”的 flex 项⽬ (flex item)，即：⽗元素 display: flex|inline-flex</li>\n</ul>\n<p><strong>不需要配合 z-index 触发创建层叠上下文</strong></p>\n<ul>\n<li>opacity 属性值⼩于 1 的元素（参考 the specification for opacity）</li>\n<li>元素的以下属性的值不是 none：<ul>\n<li>transform</li>\n<li>filter 滤镜</li>\n<li>perspective 3D 元素距视图的距离,以像素计</li>\n<li>clip-path 裁剪图片</li>\n<li>mask &#x2F; mask-image &#x2F; mask-border</li>\n</ul>\n</li>\n<li>isolation 属性被设置为 “isolate”的元素 使用 isolation:isolate 进行阻断，形成一个混合组。组以外的其他元素不会发生层叠。<a href=\"https://www.zhangxinxu.com/wordpress/2016/01/understand-css3-isolation-isolate/\" target=\"_blank\" >深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 </a></li>\n<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇⽂章）</li>\n<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素 (使用滚动回弹效果), <code>在 iOS 13 之后，不需要</code> <a href=\"https://www.cnblogs.com/xiahj/p/8036419.html#1--webkit-overflow-scrollingtouch%E6%98%AF%E4%BB%80%E4%B9%88\" target=\"_blank\" >见</a></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>创建了层叠上下文的元素只影响其子孙代元素</code>，<code>它自身的层叠水平是由它的父层叠上下文所决定的</code></p></blockquote>\n<p>当两个元素<code>层叠水平相同</code>的时候，这时候就要遵循下面两个准则：</p>\n<ul>\n<li>后来居上原则</li>\n<li>谁 z-index 大，谁在上的准则</li>\n</ul>\n<h3 id=\"如何理解-z-index？\"><a href=\"#如何理解-z-index？\" class=\"headerlink\" title=\"如何理解 z-index？\"></a>如何理解 z-index？</h3><p>CSS 中的 z-index 属性控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，可以修改 z-index 来控制元素的图层 位置，⽽且 <code>z-index 只能影响设置了 position 值的元素</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个属性是个“拼爹”的属性。(如果父元素层级低，那么子元素再怎么努力都没有用 <a href=\"https://blog.csdn.net/ccq2y/article/details/82143283\" target=\"_blank\" >见</a></p></blockquote>\n<h3 id=\"7-阶层叠\"><a href=\"#7-阶层叠\" class=\"headerlink\" title=\"7 阶层叠\"></a>7 阶层叠</h3><!-- <img src=\"http://t-blog-images.aijs.top/img/20220717205730.png\" /> -->\n<img src=\"http://t-blog-images.aijs.top/img/20220717215517.png\" />\n\n<p>上图从底到上：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">背景 ---------&gt; 布局相关 -------&gt; 内容相关 ---------------------------------&gt;\n      |                                   |                    ｜\nz-index负值                            z-index0&#x2F;不依赖z-index   z-index正值</code></pre>\n\n<ul>\n<li>如果元素的层叠级别一样，没有别的因素干扰，则遵循后来者居上原则。<a href=\"https://zhuanlan.zhihu.com/p/115951908\" target=\"_blank\" >见</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/weixin_30607659/article/details/101594118\" target=\"_blank\" >CSS 7 阶层叠水平</a></p>\n<h3 id=\"如何比较两个-DOM-元素的显示顺序呢\"><a href=\"#如何比较两个-DOM-元素的显示顺序呢\" class=\"headerlink\" title=\"如何比较两个 DOM 元素的显示顺序呢\"></a>如何比较两个 DOM 元素的显示顺序呢</h3><!-- - 1、同一个层叠上下文，层叠级别大的元素在上\n\n- 2、同一个层叠上下文，层叠级别相同，后来居上\n\n- 3、不同的层叠上下文，由父级元素层叠上下文决定 -->\n\n<ul>\n<li>如果是<code>在不同的层叠上下文中</code>，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下, 这个两个元素所在的局部层叠上下文的层叠水平。</li>\n<li>如果是<code>在相同的层叠上下文</code>，按照层叠水平的规则来显示元素; 层叠级别相同，后来居上</li>\n</ul>\n<h3 id=\"为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？\"><a href=\"#为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？\" class=\"headerlink\" title=\"为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？\"></a>为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？</h3><p>因为 float 和块级元素一般都作布局，内联元素都是内容。而一个网页中最重要的就是内容，所以一定要让内容的层叠顺序相当高，这样可以在发生层叠时，重要的图片、文字内容可以优先暴露在屏幕上。</p>\n<p><a href=\"https://segmentfault.com/a/1190000021602879?sort=newest\" target=\"_blank\" >重学前端之 CSS(三)BFC 与层叠上下文</a></p>\n<h2 id=\"块级格式化上下文\"><a href=\"#块级格式化上下文\" class=\"headerlink\" title=\"块级格式化上下文\"></a>块级格式化上下文</h2><h3 id=\"BFC-是什么\"><a href=\"#BFC-是什么\" class=\"headerlink\" title=\"BFC 是什么?\"></a>BFC 是什么?</h3><p>书⾯解释：BFC(Block Formatting Context)这⼏个英⽂拆解</p>\n<ul>\n<li><p><code>Box</code>: CSS 布局的基本单位，Box 是 CSS 布局的对象和基本单位， 直观点来说，就是⼀个⻚⾯是由很多个 Box 组成的，实际就是上个问题说的盒模型</p>\n</li>\n<li><p><code>Formatting context</code>：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤</p>\n<p><code>简⽽⾔之，它是⼀块独⽴的区域，让处于 BFC 内部的元素与外部的元素互相隔离</code></p>\n</li>\n</ul>\n<h3 id=\"如何形成\"><a href=\"#如何形成\" class=\"headerlink\" title=\"如何形成?\"></a>如何形成?</h3><p>BFC 触发条件:</p>\n<ul>\n<li><code>根元素</code>，即 HTML 元素</li>\n<li><code>float</code> 不为 none</li>\n<li><code>display</code> 的值为 inline-block、table-cell、table-caption(表格标题)</li>\n<li><code>position</code>: fixed&#x2F;absolute</li>\n<li><code>overflow</code> 不为 visible</li>\n</ul>\n<h3 id=\"BFC-特点\"><a href=\"#BFC-特点\" class=\"headerlink\" title=\"BFC 特点\"></a>BFC 特点</h3><p><a href=\"https://www.shuzhiduo.com/A/qVdeBaYAzP/#:~:text=auto%E3%80%81hidden%E3%80%81scroll-,BFC%E7%9A%84%E7%89%B9%E7%82%B9,-1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA\" target=\"_blank\" >BFC 的特点</a></p>\n<ul>\n<li>1、在一个 BFC 内部，<code>盒子会在垂直方向上排列</code></li>\n<li>2、在一个 BFC 内部，<code>相邻的 margin-bottom 和 margin-top 叠加</code></li>\n<li>3、在一个 BFC 内部，<code>每个元素左边紧贴着包含盒子的左边</code></li>\n<li>4、在一个 BFC 内部，<code>如果有一个内部元素是一个新的 BFC，则新 BFC 区域不会与 float 元素的区域重叠</code></li>\n<li>5、计算一个 BFC 高度时，<code>内部浮动元素的高度也会参与计算</code></li>\n</ul>\n<h3 id=\"作⽤是什么？\"><a href=\"#作⽤是什么？\" class=\"headerlink\" title=\"作⽤是什么？\"></a>作⽤是什么？</h3><ul>\n<li>防⽌ <code>margin重叠</code></li>\n<li>两栏布局，防⽌<code>⽂字环绕</code>等</li>\n<li>防⽌<code>元素塌陷</code></li>\n</ul>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h2><p>盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。</p>\n<h3 id=\"标准盒模型-x2F-怪异盒模型\"><a href=\"#标准盒模型-x2F-怪异盒模型\" class=\"headerlink\" title=\"标准盒模型&#x2F;怪异盒模型\"></a>标准盒模型&#x2F;怪异盒模型</h3><p>在 W3C 标准下，我们定义元素的 width 值即为盒模型中的 content 的宽度值，height 值即为盒模型中的 content 的⾼度值。 因此，</p>\n<p><strong>标准盒模型下：</strong></p>\n<p><code>元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</code></p>\n<img src=\"http://t-blog-images.aijs.top/img/20220718000736.png\" />\n\n<p><strong>IE 怪异盒模型</strong></p>\n<p>（IE8 以下）width 的宽度并不是 content 的宽度，⽽是</p>\n<p><code>元素的宽度 = margin-left + width + margin-right</code></p>\n<p>对于 width,</p>\n<p><code>width = border-left + padding-left + content 的宽度值 + padding-right + border-right</code>，height 同理。</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220718000754.png\" />\n\n<p><code>现代浏览器默认使⽤ W3C 的标准盒模型</code>，在不少情况下怪异盒模型更好⽤，于是 W3C 在 css3 中加⼊ <code>box-sizing</code> 。</p>\n<p><code>box-sizing: content-box</code> &#x2F;&#x2F; 标准盒模型<br><code>box-sizing: border-box</code> &#x2F;&#x2F; 怪异盒模型<br><code>box-sizing: padding-box</code> &#x2F;&#x2F; ⽕狐的私有模型，没⼈⽤</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p>可以使用一个，两个或三个值来指定 flex 属性。</p>\n<h3 id=\"none\"><a href=\"#none\" class=\"headerlink\" title=\"none\"></a>none</h3><p>元素会根据自身宽高来设置尺寸。它是完全非弹性的：<span style=\"color: red\">既不会缩短，也不会伸长</span> 来适应 flex 容器。相当于将属性设置为<code>&quot;flex: 0 0 auto&quot;</code>。</p>\n  <br/>\n  <br/>\n\n<h3 id=\"initial\"><a href=\"#initial\" class=\"headerlink\" title=\"initial\"></a>initial</h3><p>元素会根据自身宽高设置尺寸。它 <span style=\"color: red\">会缩短自身以适应 flex 容器，但不会伸长并吸收 </span> flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为<code>&quot;flex: 0 1 auto&quot;</code>。<br><br/><br><br/></p>\n<h3 id=\"auto\"><a href=\"#auto\" class=\"headerlink\" title=\"auto\"></a>auto</h3><p>元素会根据自身的宽度与高度来确定尺寸，但是 <span style=\"color: red\">会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应</span> flex 容器。这相当于将属性设置为 <code>&quot;flex: 1 1 auto&quot;</code>.</p>\n<h3 id=\"单值语法\"><a href=\"#单值语法\" class=\"headerlink\" title=\"单值语法:\"></a>单值语法:</h3><p>值必须为以下其中之一:</p>\n<ul>\n<li>一个无单位数(<code>&lt;number&gt;</code>): 它会被当作 flex:<code>&lt;number&gt;</code> 1 0; 解释：<code>&lt;flex-shrink&gt;</code>的值被假定为 1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为 0。</li>\n<li>一个有效的宽度(width)值: 它会被当作 <code>&lt;flex-basis&gt;</code>的值。</li>\n<li>关键字 none，auto 或 initial.</li>\n</ul>\n<h3 id=\"双值语法\"><a href=\"#双值语法\" class=\"headerlink\" title=\"双值语法:\"></a>双值语法:</h3><p>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。第二个值必须为以下之一：</p>\n<ul>\n<li>无单位数：它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>\n<li>有效的宽度值: 它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>\n</ul>\n<h3 id=\"三值语法\"><a href=\"#三值语法\" class=\"headerlink\" title=\"三值语法:\"></a>三值语法:</h3><ul>\n<li>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。</li>\n<li>第二个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>\n<li>第三个值必须为一个有效的宽度值， 并且它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>\n</ul>\n<p><a href=\"http://v.aijs.top/post/2022-05-23width0\" target=\"_blank\" >见</a></p>\n<h2 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h2><p><a href=\"https://www.cnblogs.com/xiaohuochai/p/5848612.html\" target=\"_blank\" >深入理解 CSS Media 媒体查询</a></p>\n<h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>媒体查询包含⼀个可选的媒体类型和，满⾜ CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为 true 或 false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式 的值都是 true，那么该媒体查询的结果为 true.那么媒体查询内的样式将会⽣效。<br>媒体查询，用于<code>响应适配</code>。</p>\n<h3 id=\"如何使⽤？\"><a href=\"#如何使⽤？\" class=\"headerlink\" title=\"如何使⽤？\"></a>如何使⽤？</h3><div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>媒体属性必须用括号()包起来，否则无效</p>\n</div>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- link元素中的CSS媒体查询 --&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;(max-width: 800px)&quot; href&#x3D;&quot;example.css&quot; &#x2F;&gt;\n&lt;!-- 样式表中的CSS媒体查询 --&gt;\n&lt;style&gt;\n  @media (max-width: 600px) &#123;\n    .facet_sidebar &#123;\n      display: none;\n    &#125;\n  &#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<h3 id=\"常见媒体属性\"><a href=\"#常见媒体属性\" class=\"headerlink\" title=\"常见媒体属性\"></a>常见媒体属性</h3><ul>\n<li><p>设备宽高比（device-aspect-ratio）</p>\n</li>\n<li><p>设备高度（device-height）</p>\n</li>\n<li><p>设备宽度（device-width）</p>\n</li>\n<li><p>方向（orientation）值：landscape(横屏) | portrait(竖屏)</p>\n</li>\n<li><p>分辨率（resolution）像素密度</p>\n</li>\n</ul>\n<h3 id=\"print-x2F-screen\"><a href=\"#print-x2F-screen\" class=\"headerlink\" title=\"print&#x2F;screen\"></a>print&#x2F;screen</h3><p>不用括号</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot; media&#x3D;&quot;print&quot; &#x2F;&gt;\n\n&lt;style&gt;\n  @media print &#123;\n  &#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<h3 id=\"逻辑操作符\"><a href=\"#逻辑操作符\" class=\"headerlink\" title=\"逻辑操作符\"></a>逻辑操作符</h3><p>操作符 not、and、only 和逗号(,)可以用来构建复杂的媒体查询</p>\n<h3 id=\"相对单位\"><a href=\"#相对单位\" class=\"headerlink\" title=\"相对单位\"></a>相对单位</h3><p>如果媒体查询@media 使用的是相对单位，<span style=\"color: red\">如 rem，这里有一个坑需要着重强调一下</span></p>\n<p><span style=\"color: red\">一般而言，rem 是相对于 HTML 的字体大小的。但是，由于媒体查询的级别非常高，它并不是 HTML 的子元素，不是相对于 HTML，而是相对于浏览器的，而浏览器的默认字体大小是 16px</span></p>\n<p>如果 HTML 设置字体大小为 12px，设置如下媒体查询</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">media&#x3D;&quot;only screen and (max-width:1rem)&quot;</code></pre>\n\n<p>实际上，max-width 等于 16px，而不是 12px</p>\n<p>而正是<code>由于媒体查询是相对于浏览器的</code>， 所以使用 rem 就没有必要，完全可以使用 em 来替代</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">media&#x3D;&quot;only screen and (max-width:1em)&quot;</code></pre>\n\n<h2 id=\"回流和重绘\"><a href=\"#回流和重绘\" class=\"headerlink\" title=\"回流和重绘\"></a>回流和重绘</h2><h3 id=\"浏览器渲染机制\"><a href=\"#浏览器渲染机制\" class=\"headerlink\" title=\"浏览器渲染机制\"></a>浏览器渲染机制</h3><p><span style=\"color: red\">浏览器采用流式布局</span><br>浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就形成渲染树<br>有了渲染树，我们就知道所有节点的样式，然后计算他们在页面上的大小和位置，把它们绘制到页面上</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：浏览器采用流式布局，对渲染树的计算只需要遍历一次就能完成，<span style=\"color: red\">但 table 布局除外，他需要花费 3 倍的时间</span> ，所以我们要尽量避免使用 table 布局</p></blockquote>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><ul>\n<li><code>影响部分或全部页面的布局时，会进行回流</code>，回流的代价比重绘高</li>\n<li><code>回流一定会引起重绘，但重绘不一定会引起回流</code></li>\n</ul>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>元素样式发生变化，但是<code>不影响页面整个布局的情况下会进行重绘</code>，如 outline、visibility、color、background-color 等</p>\n<h3 id=\"浏览器优化\"><a href=\"#浏览器优化\" class=\"headerlink\" title=\"浏览器优化\"></a>浏览器优化</h3><p>浏览器是<code>通过队列机制来批量更新布局</code>，浏览器刷新频率为（60 帧&#x2F;s）,每刷新一次需要 16.6ms，也就是说 16.6ms 浏览器会清空队列，但是在我们获取布局信息的时候，有一些属性或方法会强制浏览器刷新，触发重绘和回流并且清空队列，比如：</p>\n<ul>\n<li>offset 系列：<code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code> <a href=\"https://www.jb51.net/article/219621.htm\" target=\"_blank\" >距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent 为 body</a></li>\n<li>scroll 系列： <code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code> <a href=\"https://blog.csdn.net/muxi229/article/details/106849535\" target=\"_blank\" >方法返回或设置匹配元素的滚动条的偏移位置</a></li>\n<li>client 系列：<code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code> clientTop、clientLeft 获取的是上边框、左边框的宽度 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientLeft\" target=\"_blank\" >见 MDN</a></li>\n<li><code>width</code>、<code>height</code></li>\n<li><code>getComputedStyle()</code> 用于获取指定元素的 CSS 样式</li>\n<li><code>getBoundingClientRect()</code> 用于获取某个元素相对于视窗的位置集合。集合中有 top, right, bottom, left 等属性。</li>\n</ul>\n<p>强制触发浏览器刷新,所以我们要尽量少使用以上属性和方法</p>\n<h3 id=\"减少重绘和回流\"><a href=\"#减少重绘和回流\" class=\"headerlink\" title=\"减少重绘和回流\"></a>减少重绘和回流</h3><ul>\n<li><code>替代方案</code><br>使用 transform 代替 top<br>使用 visibility(只触发重绘)代替 display(触发回流)</li>\n<li><code>嵌套层级</code><br>尽可能在 DOM 树的末端改变样式类 class，影响尽量少的节点<br>css 选择器尽量不要嵌套过深，从右往左匹配</li>\n<li><code>动画</code><br>动画效果最好添加到 <code>position：absolute 或 fixed 的元素上，不影响其他元素</code>，只引发重绘，不引发回流，控制动画的速度可以使用 <code>requestAnimationFrame()</code></li>\n<li><code>css 表达式</code><br>避免使用 css 表达式，calc()会引发回流</li>\n<li><code>设为图层</code><br>将频繁重绘或回流的节点设置为图层，如：will-change，video，iframe，cavas，防止影响别的节点</li>\n<li><code>CSS3 硬件加速</code>，transform，opacity 等不会引起回流重绘</li>\n<li>批量操作使用 documentFragment,批量更新，虚拟 dom</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/bf5c498107e2\" target=\"_blank\" >参考链接</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.zhangxinxu.com/wordpress/2016/01/understand-css3-isolation-isolate/\" target=\"_blank\" >深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 </a></p>\n<p><a href=\"https://blog.csdn.net/weixin_30607659/article/details/101594118\" target=\"_blank\" >CSS 7 阶层叠水平</a></p>\n<p><a href=\"https://www.shuzhiduo.com/A/qVdeBaYAzP/#:~:text=auto%E3%80%81hidden%E3%80%81scroll-,BFC%E7%9A%84%E7%89%B9%E7%82%B9,-1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA\" target=\"_blank\" >BFC 的特点</a></p>\n<p><a href=\"https://www.cnblogs.com/xiaohuochai/p/5848612.html\" target=\"_blank\" >深入理解 CSS Media 媒体查询</a></p>\n<p><a href=\"http://v.aijs.top/post/2022-05-23width0\" target=\"_blank\" >flex width:0</a></p>\n","text":"CSS 选择器的优先级是怎样的CSS 选择器的优先级是：（标签选择器 &lt; 类选择器 &lt; ID 选择器） &lt; 内联 &lt; !important &lt; 特殊情况 到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下： A 的...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":17,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">CSS 选择器的优先级是怎样的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94-important%E6%9B%B4%E9%AB%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">比!important更高的优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#link-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">link 和@import 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">CSS 隐藏⻚⾯元素</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#em-px-rem-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">em\\px\\rem 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E2%BD%94%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E2%BD%85%E6%B3%95\"><span class=\"toc-text\">块级元素⽔平居中的⽅法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-5-%E7%A7%8D%E5%AE%9A%E4%BD%8D%E2%BD%85%E5%BC%8F\"><span class=\"toc-text\">CSS 5 种定位⽅式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">层叠上下文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BA%A7%E2%BD%A3%EF%BC%9F\"><span class=\"toc-text\">如何产⽣？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-z-index%EF%BC%9F\"><span class=\"toc-text\">如何理解 z-index？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E9%98%B6%E5%B1%82%E5%8F%A0\"><span class=\"toc-text\">7 阶层叠</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-DOM-%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E9%A1%BA%E5%BA%8F%E5%91%A2\"><span class=\"toc-text\">如何比较两个 DOM 元素的显示顺序呢</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-inlin-block-%E5%92%8C-inline-%E7%9A%84%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E6%AF%94%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E9%83%BD%E9%AB%98%EF%BC%9F\"><span class=\"toc-text\">为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">块级格式化上下文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">BFC 是什么?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90\"><span class=\"toc-text\">如何形成?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">BFC 特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">作⽤是什么？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%92%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">盒模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B-x2F-%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">标准盒模型&#x2F;怪异盒模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flex\"><span class=\"toc-text\">flex</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#none\"><span class=\"toc-text\">none</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#initial\"><span class=\"toc-text\">initial</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#auto\"><span class=\"toc-text\">auto</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E5%80%BC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">单值语法:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%80%BC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">双值语法:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%80%BC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">三值语法:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">媒体查询</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E2%BD%A4%EF%BC%9F\"><span class=\"toc-text\">如何使⽤？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%AA%92%E4%BD%93%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">常见媒体属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#print-x2F-screen\"><span class=\"toc-text\">print&#x2F;screen</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">逻辑操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%BD%8D\"><span class=\"toc-text\">相对单位</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98\"><span class=\"toc-text\">回流和重绘</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">浏览器渲染机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%B5%81\"><span class=\"toc-text\">回流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E7%BB%98\"><span class=\"toc-text\">重绘</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">浏览器优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81\"><span class=\"toc-text\">减少重绘和回流</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-设计模式","uid":"21c81236c6b792525b47c142ae6ad187","slug":"2022-07-18设计模式","date":"2022-07-18T06:53:04.000Z","updated":"2022-09-16T13:54:56.219Z","comments":true,"path":"api/articles/2022-07-18设计模式.json","keywords":null,"cover":null,"text":"SOLID 设计原则S: Single Responsibility Principle 单一职责原则 一个程序只做一件事 O: OpenClosed Principle 开放&#x2F;封闭原则 对扩展开放，对修改封闭 L: 里氏替换原则 子类能覆盖父类，父类能出现的地方，子类...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":17,"path":"api/tags/面试.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-html","uid":"2854d1d5923e1e62aed568f709662bf4","slug":"2022-07-17html","date":"2022-07-17T01:44:42.000Z","updated":"2022-09-16T13:54:56.218Z","comments":true,"path":"api/articles/2022-07-17html.json","keywords":null,"cover":[],"text":"doctype 的作⽤是什么？DOCTYPE 是 html5 标准⽹⻚声明，且必须声明在 HTML ⽂档的第⼀⾏。 来告知浏览器的解析器⽤什么⽂档标准解析这个⽂档，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析 ⽂档解析类型有： BackCo...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":17,"path":"api/tags/面试.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"丷为中华之崛起而学习丷","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}