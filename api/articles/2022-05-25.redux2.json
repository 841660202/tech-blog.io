{"title":"redux 源码 2","uid":"da6549350c9a9d927d67bdb10bc76a3c","slug":"2022-05-25.redux2","date":"2022-05-25T13:32:54.000Z","updated":"2022-09-16T14:58:02.583Z","comments":true,"path":"api/articles/2022-05-25.redux2.json","keywords":null,"cover":[],"content":"<h2 id=\"redux-简介\"><a href=\"#redux-简介\" class=\"headerlink\" title=\"redux 简介\"></a>redux 简介</h2><p>Predictable state container for JavaScript apps</p>\n<p>字面意思</p>\n<p>js应用可预测状态容器</p>\n<p><img src=\"http://t-blog-images.aijs.top/img/20220527091836.webp\"></p>\n<h2 id=\"怎么用，为什么用\"><a href=\"#怎么用，为什么用\" class=\"headerlink\" title=\"怎么用，为什么用\"></a>怎么用，为什么用</h2><p><a href=\"https://redux.js.org/\">看官网。。。</a></p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p><strong>代码注释如下</strong></p>\n<ul>\n<li>redux store持有state树，唯一可以改变store中数据的方式是dispatch</li>\n<li>在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer</li>\n<li>一个根据当前state和行为返回新state的函数</li>\n<li>初始state，</li>\n<li>store中间件。可以使用第三方中间件增强store</li>\n<li>redux store 可以读取state，dispatch行为，订阅改变</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">\n&#x2F;**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call &#96;dispatch()&#96; on it.\n * \n * redux store持有state树，唯一可以改变store中数据的方式是dispatch\n * \n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using &#96;combineReducers&#96;.\n *\n * 在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer\n * \n * @param reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n * \n * 一个根据当前state和行为返回新state的函数\n *\n * @param preloadedState The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use &#96;combineReducers&#96; to produce the root reducer function, this must be\n * an object with the same shape as &#96;combineReducers&#96; keys.\n *\n * 初始state，\n * \n * @param enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is &#96;applyMiddleware()&#96;.\n *\n * store中间件。可以使用第三方中间件增强store\n * \n * @returns A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n * \n * redux store 可以读取state，dispatch行为，订阅改变\n *&#x2F;</code></pre>\n<p><strong>函数声明</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt;, &#x2F;&#x2F; &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;,&#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;, &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件\n\n  &#x2F;&#x2F; 这里可以看到 preloadedState的参数| StoreEnhancer&lt;Ext, StateExt&gt; 与 enhancer类型一致， 这里处理第二参数可能是 enhancer\n  &#x2F;&#x2F; 代码主体分有做判断：\n  &#x2F;&#x2F; if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  &#x2F;&#x2F;   enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  &#x2F;&#x2F;   preloadedState &#x3D; undefined\n  &#x2F;&#x2F; &#125; \n\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;&#125;</code></pre>\n<p><strong>createStore 主体代码</strong></p>\n<ul>\n<li>一些入参校验</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">if (\n  (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||\n  (typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof arguments[3] &#x3D;&#x3D;&#x3D; &#39;function&#39;)\n) &#123;\n  throw new Error(\n    &#39;It looks like you are passing several store enhancers to &#39; +\n      &#39;createStore(). This is not supported. Instead, compose them &#39; +\n      &#39;together to a single function. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#creating-a-store-with-enhancers for an example.&#39;\n  )\n&#125;\n\nif (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  preloadedState &#x3D; undefined\n&#125;\n\nif (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  if (typeof enhancer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new Error(\n      &#96;Expected the enhancer to be a function. Instead, received: &#39;$&#123;kindOf(\n        enhancer\n      )&#125;&#39;&#96;\n    )\n  &#125;\n\n  return enhancer(createStore)(\n    reducer,\n    preloadedState as PreloadedState&lt;S&gt;\n  ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n&#125;\n\nif (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n  throw new Error(\n    &#96;Expected the root reducer to be a function. Instead, received: &#39;$&#123;kindOf(\n      reducer\n    )&#125;&#39;&#96;\n  )\n&#125;\n\n&#x2F;&#x2F; 当前reducer\nlet currentReducer &#x3D; reducer\n&#x2F;&#x2F; 当前状态\nlet currentState &#x3D; preloadedState as S\n&#x2F;&#x2F; 当前订阅\nlet currentListeners: (() &#x3D;&gt; void)[] | null &#x3D; []\n&#x2F;&#x2F; 新的订阅\nlet nextListeners &#x3D; currentListeners\nlet isDispatching &#x3D; false\n\n\n\n&#x2F;**\n * This makes a shallow copy of currentListeners so we can use\n * nextListeners as a temporary list while dispatching.\n *\n * This prevents any bugs around consumers calling\n * subscribe&#x2F;unsubscribe in the middle of a dispatch.\n *&#x2F;\n&#x2F;&#x2F; 浅拷贝当前currentListeners得到 nextListeners 用于 dispatching   \n\n&#x2F;&#x2F; 确定新的可变监听\nfunction ensureCanMutateNextListeners() &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 获取store的状态\nfunction getState(): S &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 传入监听，返回监听移除的函数\nfunction subscribe(listener: () &#x3D;&gt; void) &#123;\n  。。。\n\n  return function unsubscribe() &#123;\n    。。。。\n  &#125;\n&#125;\n\n\nfunction dispatch(action: A) &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 用于同构更新reducer\nfunction replaceReducer&lt;NewState, NewActions extends A&gt;(\n  nextReducer: Reducer&lt;NewState, NewActions&gt;\n): Store&lt;ExtendState&lt;NewState, StateExt&gt;, NewActions, StateExt, Ext&gt; &amp; Ext &#123;\n  。。。\n&#125;\n\n&#x2F;**\n * Interoperability point for observable&#x2F;reactive libraries.\n * @returns A minimal observable of state changes.\n * For more information, see the observable proposal:\n * https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-observable\n *&#x2F;\n&#x2F;&#x2F; 实现小型观察状态变更\nfunction observable() &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 当store被创建，初始化操作会被dispatch，，每个reducer会返回最初的state. 有效地填充初始状态树。\ndispatch(&#123; type: ActionTypes.INIT &#125; as A)\n\n\nconst store &#x3D; &#123;\n  dispatch: dispatch as Dispatch&lt;A&gt;,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nreturn store &#x2F;&#x2F; store上的api我们又熟悉了\n\n</code></pre>\n<p><strong>ensureCanMutateNextListeners</strong></p>\n<ul>\n<li>浅拷贝当前currentListeners得到 nextListeners 用于 dispatching</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function ensureCanMutateNextListeners() &#123;\n  if (nextListeners &#x3D;&#x3D;&#x3D; currentListeners) &#123;\n    nextListeners &#x3D; currentListeners.slice()\n  &#125;\n&#125;\n</code></pre>\n\n\n<p><strong>getState</strong></p>\n<ul>\n<li>获取store的状态</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getState(): S &#123;\n  if (isDispatching) &#123;\n    throw new Error(\n      &#39;You may not call store.getState() while the reducer is executing. &#39; +\n        &#39;The reducer has already received the state as an argument. &#39; +\n        &#39;Pass it down from the top reducer instead of reading it from the store.&#39;\n    )\n  &#125;\n\n  return currentState as S\n&#125;</code></pre>\n<p><strong>subscribe</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call &#96;getState()&#96; to read the current state tree inside the callback.\n   *\n   * You may call &#96;dispatch()&#96; from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every &#96;dispatch()&#96; call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the &#96;dispatch()&#96; that is currently in progress.\n   * However, the next &#96;dispatch()&#96; call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested &#96;dispatch()&#96; before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the &#96;dispatch()&#96; started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param listener A callback to be invoked on every dispatch.\n   * @returns A function to remove this change listener.\n   *&#x2F;\n  &#x2F;&#x2F; 上述注释\n  &#x2F;** 添加一个监听，在action被触发时候会调用，state会进行更新，在回调中可以用getState方法获取当前状态树\n   * 两个注意：订阅的是在每个dispatch之前的快照，\n   * 1.\n   * 订阅是在每次&#39;dispatch（）&#39;调用之前进行快照的。\n   * 如果在调用侦听器时订阅或取消订阅，这将不会对当前正在进行的“dispatch（）”产生任何影响。\n   * 但是，下一个&#39;dispatch（）&#39;调用（无论是否嵌套）将使用订阅列表的最新快照。\n   * 2。\n   * 监听器不应该期望看到所有的状态更改，因为在调用监听器之前，状态可能在嵌套的&#39;dispatch（）&#39;期间被多次更新。\n   * 但是，可以保证在“dispatch（）”启动之前注册的所有订阅者在退出时都将以最新状态调用。\n   * *&#x2F;\n  function subscribe(listener: () &#x3D;&gt; void) &#123;\n    if (typeof listener !&#x3D;&#x3D; &#39;function&#39;) &#123;\n      throw new Error(\n        &#96;Expected the listener to be a function. Instead, received: &#39;$&#123;kindOf(\n          listener\n        )&#125;&#39;&#96;\n      )\n    &#125;\n\n    if (isDispatching) &#123;\n      throw new Error(\n        &#39;You may not call store.subscribe() while the reducer is executing. &#39; +\n          &#39;If you would like to be notified after the store has been updated, subscribe from a &#39; +\n          &#39;component and invoke store.getState() in the callback to access the latest state. &#39; +\n          &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;\n      )\n    &#125;\n\n    let isSubscribed &#x3D; true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener) &#x2F;&#x2F; 增加\n\n    return function unsubscribe() &#123;\n      if (!isSubscribed) &#123;\n        return\n      &#125;\n\n      if (isDispatching) &#123;\n        throw new Error(\n          &#39;You may not unsubscribe from a store listener while the reducer is executing. &#39; +\n            &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;\n        )\n      &#125;\n\n      isSubscribed &#x3D; false\n\n      ensureCanMutateNextListeners()\n      const index &#x3D; nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1) &#x2F;&#x2F; 移除\n      currentListeners &#x3D; null\n    &#125;\n  &#125;</code></pre>\n\n<p><strong>dispatch</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Dispatches an action. It is the only way to trigger a state change.\n *\n * The &#96;reducer&#96; function, used to create the store, will be called with the\n * current state tree and the given &#96;action&#96;. Its return value will\n * be considered the **next** state of the tree, and the change listeners\n * will be notified.\n *\n * The base implementation only supports plain object actions. If you want to\n * dispatch a Promise, an Observable, a thunk, or something else, you need to\n * wrap your store creating function into the corresponding middleware. For\n * example, see the documentation for the &#96;redux-thunk&#96; package. Even the\n * middleware will eventually dispatch plain object actions using this method.\n *\n * @param action A plain object representing “what changed”. It is\n * a good idea to keep actions serializable so you can record and replay user\n * sessions, or use the time travelling &#96;redux-devtools&#96;. An action must have\n * a &#96;type&#96; property which may not be &#96;undefined&#96;. It is a good idea to use\n * string constants for action types.\n *\n * @returns For convenience, the same action object you dispatched.\n *\n * Note that, if you use a custom middleware, it may wrap &#96;dispatch()&#96; to\n * return something else (for example, a Promise you can await).\n *&#x2F;\nfunction dispatch(action: A) &#123;\n  if (!isPlainObject(action)) &#123; &#x2F;&#x2F; 只能是简单的对象\n    throw new Error(\n      &#96;Actions must be plain objects. Instead, the actual type was: &#39;$&#123;kindOf(\n        action\n      )&#125;&#39;. You may need to add middleware to your store setup to handle dispatching other values, such as &#39;redux-thunk&#39; to handle dispatching functions. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#middleware and https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-6-async-logic#using-the-redux-thunk-middleware for examples.&#96;\n    )\n  &#125;\n\n  if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n    throw new Error(\n      &#39;Actions may not have an undefined &quot;type&quot; property. You may have misspelled an action type string constant.&#39;\n    )\n  &#125;\n\n  if (isDispatching) &#123;\n    throw new Error(&#39;Reducers may not dispatch actions.&#39;)\n  &#125;\n\n  try &#123;\n    isDispatching &#x3D; true\n    currentState &#x3D; currentReducer(currentState, action) &#x2F;&#x2F; 传入当前状态和操作，返回新的状态\n  &#125; finally &#123;\n    isDispatching &#x3D; false\n  &#125;\n\n  const listeners &#x3D; (currentListeners &#x3D; nextListeners) &#x2F;&#x2F; 触发更新\n  for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;\n    const listener &#x3D; listeners[i]\n    listener()\n  &#125;\n\n  return action\n&#125;</code></pre>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><ul>\n<li>使用时候以键值对形式存在<br><strong>使用</strong></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useInfoReducer from &#39;.&#x2F;userInfo&#39;\nimport recordReducer from &#39;.&#x2F;record&#39;\n\nconst rootReducer &#x3D; combineReducers(&#123;\n  useInfoReducer,\n  recordReducer\n&#125;)\n\nconst store &#x3D; createStore(rootReducer)</code></pre>\n\n<p><strong>源码</strong></p>\n<ul>\n<li>返回不期望的state型警告信息</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getUnexpectedStateShapeWarningMessage(\n  inputState: object,\n  reducers: ReducersMapObject,\n  action: Action,\n  unexpectedKeyCache: &#123; [key: string]: true &#125;\n) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers)\n  const argumentName &#x3D;\n    action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.INIT\n      ? &#39;preloadedState argument passed to createStore&#39;\n      : &#39;previous state received by the reducer&#39;\n\n  if (reducerKeys.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return (\n      &#39;Store does not have a valid reducer. Make sure the argument passed &#39; +\n      &#39;to combineReducers is an object whose values are reducers.&#39;\n    )\n  &#125;\n\n  if (!isPlainObject(inputState)) &#123;\n    return (\n      &#96;The $&#123;argumentName&#125; has unexpected type of &quot;$&#123;kindOf(\n        inputState\n      )&#125;&quot;. Expected argument to be an object with the following &#96; +\n      &#96;keys: &quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;&#96;\n    )\n  &#125;\n\n  const unexpectedKeys &#x3D; Object.keys(inputState).filter(\n    key &#x3D;&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach(key &#x3D;&gt; &#123;\n    unexpectedKeyCache[key] &#x3D; true\n  &#125;)\n\n  if (action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.REPLACE) return\n\n  if (unexpectedKeys.length &gt; 0) &#123;\n    return (\n      &#96;Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &#39;keys&#39; : &#39;key&#39;&#125; &#96; +\n      &#96;&quot;$&#123;unexpectedKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot; found in $&#123;argumentName&#125;. &#96; +\n      &#96;Expected to find one of the known reducer keys instead: &#96; +\n      &#96;&quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;. Unexpected keys will be ignored.&#96;\n    )\n  &#125;\n&#125;\n &#x2F;&#x2F; 对 reducer型进行断言\nfunction assertReducerShape(reducers: ReducersMapObject) &#123;\n  Object.keys(reducers).forEach(key &#x3D;&gt; &#123;\n    const reducer &#x3D; reducers[key]\n    const initialState &#x3D; reducer(undefined, &#123; type: ActionTypes.INIT &#125;)\n\n    if (typeof initialState &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n      throw new Error(\n         &#x2F;&#x2F; 初始化initialState时候可以用null,但是不可以用undefined\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined during initialization. &#96; +\n          &#96;If the state passed to the reducer is undefined, you must &#96; +\n          &#96;explicitly return the initial state. The initial state may &#96; +\n          &#96;not be undefined. If you don&#39;t want to set a value for this reducer, &#96; +\n          &#96;you can use null instead of undefined.&#96;\n      )\n    &#125;\n\n    if (\n      typeof reducer(undefined, &#123;\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      &#125;) &#x3D;&#x3D;&#x3D; &#39;undefined&#39;\n    ) &#123;\n      throw new Error( \n        &#x2F;&#x2F; 1.随机类型&#x2F; redux&#x2F;*类型 的操作类型为redux私有，不允许使用 \n        &#x2F;&#x2F; 2.初始化状态不可以是undefined, \n        &#x2F;&#x2F; 3.新状态如果是undefined的，必须返回初始状态\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. &#96; +\n          &#96;Don&#39;t try to handle &#39;$&#123;ActionTypes.INIT&#125;&#39; or other actions in &quot;redux&#x2F;*&quot; &#96; +\n          &#96;namespace. They are considered private. Instead, you must return the &#96; +\n          &#96;current state for any unknown actions, unless it is undefined, &#96; +\n          &#96;in which case you must return the initial state, regardless of the &#96; +\n          &#96;action type. The initial state may not be undefined, but can be null.&#96;\n      )\n    &#125;\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; combineReducers的实现，其实就是将多个值，合并在一个对象中\nexport default function combineReducers(reducers: ReducersMapObject) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers)\n  const finalReducers: ReducersMapObject &#x3D; &#123;&#125;\n  for (let i &#x3D; 0; i &lt; reducerKeys.length; i++) &#123;\n    const key &#x3D; reducerKeys[i]\n\n    if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n      finalReducers[key] &#x3D; reducers[key]\n    &#125;\n  &#125;\n  const finalReducerKeys &#x3D; Object.keys(finalReducers)\n\n  &#x2F;&#x2F; This is used to make sure we don&#39;t warn about the same\n  &#x2F;&#x2F; keys multiple times.\n  &#x2F;&#x2F;这用于确保我们不会多次警告相同的key。\n  let unexpectedKeyCache: &#123; [key: string]: true &#125;\n\n  return function combination(\n    state: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;,\n    action: AnyAction\n  ) &#123;\n    &#x2F;&#x2F;校验信息...\n\n    let hasChanged &#x3D; false\n    const nextState: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;\n    for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;\n      const key &#x3D; finalReducerKeys[i]\n      &#x2F;&#x2F; reducer\n      const reducer &#x3D; finalReducers[key]\n      &#x2F;&#x2F; 之前状态\n      const previousStateForKey &#x3D; state[key]\n      &#x2F;&#x2F; 新状态\n      const nextStateForKey &#x3D; reducer(previousStateForKey, action)\n\n\n\n      if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n        const actionType &#x3D; action &amp;&amp; action.type\n        throw new Error(\n          &#96;When called with an action of type $&#123;\n            actionType ? &#96;&quot;$&#123;String(actionType)&#125;&quot;&#96; : &#39;(unknown type)&#39;\n          &#125;, the slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined. &#96; +\n            &#96;To ignore an action, you must explicitly return the previous state. &#96; +\n            &#96;If you want this reducer to hold no value, you can return null instead of undefined.&#96;\n        )\n      &#125;\n      nextState[key] &#x3D; nextStateForKey\n      &#x2F;&#x2F; 判断是否发生更新\n      hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey\n    &#125;\n    hasChanged &#x3D;\n      hasChanged || finalReducerKeys.length !&#x3D;&#x3D; Object.keys(state).length\n      &#x2F;&#x2F; 更新返回新的状态，否则返回之前状态\n    return hasChanged ? nextState : state\n  &#125;\n&#125;</code></pre>\n\n\n<h2 id=\"bindActionCreators\"><a href=\"#bindActionCreators\" class=\"headerlink\" title=\"bindActionCreators\"></a>bindActionCreators</h2><ul>\n<li>给action包裹层dispatch</li>\n<li>action有两种类型： 函数、键值对</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function bindActionCreators(\n  actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject,\n  dispatch: Dispatch\n) &#123;\n  &#x2F;&#x2F; 函数类型直接bindActionCreator返回\n  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return bindActionCreator(actionCreators, dispatch)\n  &#125;\n\n  if (typeof actionCreators !&#x3D;&#x3D; &#39;object&#39; || actionCreators &#x3D;&#x3D;&#x3D; null) &#123;\n    throw new Error(\n      &#96;bindActionCreators expected an object or a function, but instead received: &#39;$&#123;kindOf(\n        actionCreators\n      )&#125;&#39;. &#96; +\n        &#96;Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?&#96;\n    )\n  &#125;\n\n  const boundActionCreators: ActionCreatorsMapObject &#x3D; &#123;&#125;\n  &#x2F;&#x2F; 对象遍历调用bindActionCreator\n  for (const key in actionCreators) &#123;\n    const actionCreator &#x3D; actionCreators[key]\n    if (typeof actionCreator &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n      boundActionCreators[key] &#x3D; bindActionCreator(actionCreator, dispatch)\n    &#125;\n  &#125;\n  return boundActionCreators\n&#125;</code></pre>\n<p><strong>使用及测试代码见</strong></p>\n<p><code>redux/test/typescript/actionCreators.ts</code></p>\n<p><strong>bindActionCreator</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 作用是每个actionCreator增加一个dispatch包裹\nfunction bindActionCreator&lt;A extends AnyAction &#x3D; AnyAction&gt;(\n  actionCreator: ActionCreator&lt;A&gt;,\n  dispatch: Dispatch\n) &#123;\n  return function (this: any, ...args: any[]) &#123;\n    return dispatch(actionCreator.apply(this, args)) &#x2F;&#x2F; 主要代码\n  &#125;\n&#125;</code></pre>\n\n\n\n\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><ul>\n<li>中间件</li>\n<li>对store能力进行增强</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer&lt;any&gt; &#123;\n  return (createStore: StoreEnhancerStoreCreator) &#x3D;&gt;\n    &lt;S, A extends AnyAction&gt;(\n      reducer: Reducer&lt;S, A&gt;,\n      preloadedState?: PreloadedState&lt;S&gt;\n    ) &#x3D;&gt; &#123;\n      const store &#x3D; createStore(reducer, preloadedState)\n\n\n      &#x2F;&#x2F; 声明\n      let dispatch: Dispatch &#x3D; () &#x3D;&gt; &#123;\n        throw new Error(\n          &#39;Dispatching while constructing your middleware is not allowed. &#39; +\n            &#39;Other middleware would not be applied to this dispatch.&#39;\n        )\n      &#125;\n\n      const middlewareAPI: MiddlewareAPI &#x3D; &#123;\n        getState: store.getState,\n                                      &#x2F;&#x2F;使用上述函数进行\n        dispatch: (action, ...args) &#x3D;&gt; dispatch(action, ...args)\n      &#125;\n      &#x2F;&#x2F; 中间件数组\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n\n\n      &#x2F;&#x2F; 增强的是dispatch\n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;\n\n\n&#96;&#96;&#96;ts\n\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n      \n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><ul>\n<li>洋葱模型<br><strong>使用</strong></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">compose(f, g, h)\n(...args) &#x3D;&gt; f(g(h(...args)))\n</code></pre>\n<p><strong>源码</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function compose(...funcs: Function[]) &#123;\n  &#x2F;&#x2F; 参数长度判断\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line\n    return &lt;T&gt;(arg: T) &#x3D;&gt; arg\n  &#125;\n  &#x2F;&#x2F; 长度为1\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0]\n  &#125;\n  &#x2F;&#x2F; 主要代码一行\n  return funcs.reduce((a, b) &#x3D;&gt; (...args: any) &#x3D;&gt;  a(b(...args)))\n&#125;\n</code></pre>\n<p><strong>讲compose的文章</strong></p>\n<p><a href=\"http://givencui.com/index.php/archives/28/\" target=\"_blank\" >这里有一篇非常好</a></p>\n<h2 id=\"DO-NOT-USE-ActionTypes\"><a href=\"#DO-NOT-USE-ActionTypes\" class=\"headerlink\" title=\"__DO_NOT_USE__ActionTypes\"></a>__DO_NOT_USE__ActionTypes</h2><ul>\n<li>一些私有的action被redux保留，对于不明确的action，必须返回当前state.</li>\n<li>如果当前状态是undefined,必须返回初始状态</li>\n<li>不要在代码中直接涉及这些action</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const ActionTypes &#x3D; &#123;\n  INIT: &#96;@@redux&#x2F;INIT$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  REPLACE: &#96;@@redux&#x2F;REPLACE$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  PROBE_UNKNOWN_ACTION: () &#x3D;&gt; &#96;@@redux&#x2F;PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;&#96;\n&#125;\n</code></pre>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"http://t-blog-images.aijs.top/img/redux源码内容.png\"/>\n\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p><img src=\"http://t-blog-images.aijs.top/img/20220527091836.webp\"></p>\n<h2 id=\"巩固\"><a href=\"#巩固\" class=\"headerlink\" title=\"巩固\"></a>巩固</h2><p><img src=\"http://t-blog-images.aijs.top/img/20220527095407.webp\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.51cto.com/u_15283585/2958523\">最精简的Redux源码解析，看完从此再也不怕面试官</a><br><a href=\"https://www.jianshu.com/p/490fc0d89029\">Redux 源码解析</a><br><a href=\"https://github.com/841660202/redux\">github 源码</a></p>\n","text":"redux 简介Predictable state container for JavaScript apps 字面意思 js应用可预测状态容器 怎么用，为什么用看官网。。。 createStore代码注释如下 redux store持有state树，唯一可以改变store中数据...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"React","slug":"React","count":18,"path":"api/categories/React.json"}],"tags":[{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#redux-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">redux 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">怎么用，为什么用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createStore\"><span class=\"toc-text\">createStore</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#combineReducers\"><span class=\"toc-text\">combineReducers</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bindActionCreators\"><span class=\"toc-text\">bindActionCreators</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#applyMiddleware\"><span class=\"toc-text\">applyMiddleware</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#compose\"><span class=\"toc-text\">compose</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DO-NOT-USE-ActionTypes\"><span class=\"toc-text\">__DO_NOT_USE__ActionTypes</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">回顾</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A9%E5%9B%BA\"><span class=\"toc-text\">巩固</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"js 代码注释","uid":"5df43a7a7d0a76be0dcfbc13fca3f3d6","slug":"2022-05-26code","date":"2022-05-26T07:31:20.000Z","updated":"2022-09-16T13:54:56.117Z","comments":true,"path":"api/articles/2022-05-26code.json","keywords":null,"cover":[],"text":"代码注释//这种js注释代码在vscode其他地方引用时候，没有提示， 如果需要有提示，需要写成/** 提示 **/ 写法1 export enum ELeaveType &#123; MATERNITY_ &#x3D; 17, &#x2F;&#x2F; &quot;产假&amp...","link":"","photos":[],"count_time":{"symbolsCount":469,"symbolsTime":"1 mins."},"categories":[{"name":"code","slug":"code","count":1,"path":"api/categories/code.json"}],"tags":[{"name":"code","slug":"code","count":1,"path":"api/tags/code.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"redux 源码 1","uid":"af1b42282a210ca45f834a49b50349c6","slug":"2022-05-25.redux","date":"2022-05-25T05:48:17.000Z","updated":"2022-09-16T14:57:59.791Z","comments":true,"path":"api/articles/2022-05-25.redux.json","keywords":null,"cover":[],"text":"介绍A Predictable State Container for JS Apps package.json&#123; &quot;name&quot;: &quot;redux&quot;, &quot;version&quot;: &quot;5.0.0-alpha.0...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":18,"path":"api/categories/React.json"}],"tags":[{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}