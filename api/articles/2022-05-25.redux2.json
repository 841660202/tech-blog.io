{"title":"redux 源码 2","uid":"da6549350c9a9d927d67bdb10bc76a3c","slug":"2022-05-25.redux2","date":"2022-05-25T13:32:54.000Z","updated":"2023-02-20T21:20:56.460Z","comments":true,"path":"api/articles/2022-05-25.redux2.json","keywords":null,"cover":[],"content":"<h2 id=\"redux-简介\"><a href=\"#redux-简介\" class=\"headerlink\" title=\"redux 简介\"></a>redux 简介</h2><p>Predictable state container for JavaScript apps</p>\n<p>字面意思</p>\n<p>js 应用可预测状态容器</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220527091836.webp\" style=\"width:500px;max-width:100%\" />\n\n<h2 id=\"怎么用，为什么用\"><a href=\"#怎么用，为什么用\" class=\"headerlink\" title=\"怎么用，为什么用\"></a>怎么用，为什么用</h2><p><a href=\"https://redux.js.org/\">看官网。。。</a></p>\n<h2 id=\"createStore\"><a href=\"#createStore\" class=\"headerlink\" title=\"createStore\"></a>createStore</h2><p><strong>代码注释如下</strong></p>\n<ol>\n<li>redux store 持有 state 树，唯一可以改变 store 中数据的方式是 dispatch</li>\n<li>在你的 app 中应该有唯一一个 store.为了区分不同部分响应操作的的状态树，可以将几个 reducer 通过 combinereducers 合并为一个 reducer</li>\n<li>一个根据当前 state 和行为返回新 state 的函数</li>\n<li>初始 state，</li>\n<li>store 中间件。可以使用第三方中间件增强 store</li>\n<li>redux store 可以读取 state，dispatch 行为，订阅改变</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call &#96;dispatch()&#96; on it.\n *\n * redux store持有state树，唯一可以改变store中数据的方式是dispatch\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using &#96;combineReducers&#96;.\n *\n * 在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer\n *\n * @param reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * 一个根据当前state和行为返回新state的函数\n *\n * @param preloadedState The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use &#96;combineReducers&#96; to produce the root reducer function, this must be\n * an object with the same shape as &#96;combineReducers&#96; keys.\n *\n * 初始state，\n *\n * @param enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is &#96;applyMiddleware()&#96;.\n *\n * store中间件。可以使用第三方中间件增强store\n *\n * @returns A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n *\n * redux store 可以读取state，dispatch行为，订阅改变\n *&#x2F;</code></pre>\n\n<p><strong>函数声明</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext;\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt;, &#x2F;&#x2F; &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext;\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;, &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n\n  &#x2F;&#x2F; 这里可以看到 preloadedState的参数| StoreEnhancer&lt;Ext, StateExt&gt; 与 enhancer类型一致， 这里处理第二参数可能是 enhancer\n  &#x2F;&#x2F; 代码主体分有做判断：\n  &#x2F;&#x2F; if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  &#x2F;&#x2F;   enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  &#x2F;&#x2F;   preloadedState &#x3D; undefined\n  &#x2F;&#x2F; &#125;\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;&#125;</code></pre>\n\n<p><strong>createStore 主体代码</strong></p>\n<ul>\n<li>一些入参校验</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">if (\n  (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||\n  (typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof arguments[3] &#x3D;&#x3D;&#x3D; &#39;function&#39;)\n) &#123;\n  throw new Error(\n    &#39;It looks like you are passing several store enhancers to &#39; +\n      &#39;createStore(). This is not supported. Instead, compose them &#39; +\n      &#39;together to a single function. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#creating-a-store-with-enhancers for an example.&#39;\n  )\n&#125;\n\nif (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  preloadedState &#x3D; undefined\n&#125;\n\nif (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  if (typeof enhancer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new Error(\n      &#96;Expected the enhancer to be a function. Instead, received: &#39;$&#123;kindOf(\n        enhancer\n      )&#125;&#39;&#96;\n    )\n  &#125;\n\n  return enhancer(createStore)(\n    reducer,\n    preloadedState as PreloadedState&lt;S&gt;\n  ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n&#125;\n\nif (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n  throw new Error(\n    &#96;Expected the root reducer to be a function. Instead, received: &#39;$&#123;kindOf(\n      reducer\n    )&#125;&#39;&#96;\n  )\n&#125;\n\n&#x2F;&#x2F; 当前reducer\nlet currentReducer &#x3D; reducer\n&#x2F;&#x2F; 当前状态\nlet currentState &#x3D; preloadedState as S\n&#x2F;&#x2F; 当前订阅\nlet currentListeners: (() &#x3D;&gt; void)[] | null &#x3D; []\n&#x2F;&#x2F; 新的订阅\nlet nextListeners &#x3D; currentListeners\nlet isDispatching &#x3D; false\n\n\n\n&#x2F;**\n * This makes a shallow copy of currentListeners so we can use\n * nextListeners as a temporary list while dispatching.\n *\n * This prevents any bugs around consumers calling\n * subscribe&#x2F;unsubscribe in the middle of a dispatch.\n *&#x2F;\n&#x2F;&#x2F; 浅拷贝当前currentListeners得到 nextListeners 用于 dispatching\n\n&#x2F;&#x2F; 确定新的可变监听\nfunction ensureCanMutateNextListeners() &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 获取store的状态\nfunction getState(): S &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 传入监听，返回监听移除的函数\nfunction subscribe(listener: () &#x3D;&gt; void) &#123;\n  。。。\n\n  return function unsubscribe() &#123;\n    。。。。\n  &#125;\n&#125;\n\n\nfunction dispatch(action: A) &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 用于同构更新reducer\nfunction replaceReducer&lt;NewState, NewActions extends A&gt;(\n  nextReducer: Reducer&lt;NewState, NewActions&gt;\n): Store&lt;ExtendState&lt;NewState, StateExt&gt;, NewActions, StateExt, Ext&gt; &amp; Ext &#123;\n  。。。\n&#125;\n\n&#x2F;**\n * Interoperability point for observable&#x2F;reactive libraries.\n * @returns A minimal observable of state changes.\n * For more information, see the observable proposal:\n * https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-observable\n *&#x2F;\n&#x2F;&#x2F; 实现小型观察状态变更\nfunction observable() &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 当store被创建，初始化操作会被dispatch，，每个reducer会返回最初的state. 有效地填充初始状态树。\ndispatch(&#123; type: ActionTypes.INIT &#125; as A)\n\n\nconst store &#x3D; &#123;\n  dispatch: dispatch as Dispatch&lt;A&gt;,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nreturn store &#x2F;&#x2F; store上的api我们又熟悉了\n\n</code></pre>\n\n<p><strong>ensureCanMutateNextListeners</strong></p>\n<ul>\n<li>浅拷贝当前 currentListeners 得到 nextListeners 用于 dispatching</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function ensureCanMutateNextListeners() &#123;\n  if (nextListeners &#x3D;&#x3D;&#x3D; currentListeners) &#123;\n    nextListeners &#x3D; currentListeners.slice();\n  &#125;\n&#125;</code></pre>\n\n<p><strong>getState</strong></p>\n<ul>\n<li>获取 store 的状态</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getState(): S &#123;\n  if (isDispatching) &#123;\n    throw new Error(\n      &quot;You may not call store.getState() while the reducer is executing. &quot; +\n        &quot;The reducer has already received the state as an argument. &quot; +\n        &quot;Pass it down from the top reducer instead of reading it from the store.&quot;\n    );\n  &#125;\n\n  return currentState as S;\n&#125;</code></pre>\n\n<p><strong>subscribe</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Adds a change listener. It will be called any time an action is dispatched,\n * and some part of the state tree may potentially have changed. You may then\n * call &#96;getState()&#96; to read the current state tree inside the callback.\n *\n * You may call &#96;dispatch()&#96; from a change listener, with the following\n * caveats:\n *\n * 1. The subscriptions are snapshotted just before every &#96;dispatch()&#96; call.\n * If you subscribe or unsubscribe while the listeners are being invoked, this\n * will not have any effect on the &#96;dispatch()&#96; that is currently in progress.\n * However, the next &#96;dispatch()&#96; call, whether nested or not, will use a more\n * recent snapshot of the subscription list.\n *\n * 2. The listener should not expect to see all state changes, as the state\n * might have been updated multiple times during a nested &#96;dispatch()&#96; before\n * the listener is called. It is, however, guaranteed that all subscribers\n * registered before the &#96;dispatch()&#96; started will be called with the latest\n * state by the time it exits.\n *\n * @param listener A callback to be invoked on every dispatch.\n * @returns A function to remove this change listener.\n *&#x2F;\n&#x2F;&#x2F; 上述注释\n&#x2F;** 添加一个监听，在action被触发时候会调用，state会进行更新，在回调中可以用getState方法获取当前状态树\n * 两个注意：订阅的是在每个dispatch之前的快照，\n * 1.\n * 订阅是在每次&#39;dispatch（）&#39;调用之前进行快照的。\n * 如果在调用侦听器时订阅或取消订阅，这将不会对当前正在进行的“dispatch（）”产生任何影响。\n * 但是，下一个&#39;dispatch（）&#39;调用（无论是否嵌套）将使用订阅列表的最新快照。\n * 2。\n * 监听器不应该期望看到所有的状态更改，因为在调用监听器之前，状态可能在嵌套的&#39;dispatch（）&#39;期间被多次更新。\n * 但是，可以保证在“dispatch（）”启动之前注册的所有订阅者在退出时都将以最新状态调用。\n * *&#x2F;\nfunction subscribe(listener: () &#x3D;&gt; void) &#123;\n  if (typeof listener !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(\n      &#96;Expected the listener to be a function. Instead, received: &#39;$&#123;kindOf(\n        listener\n      )&#125;&#39;&#96;\n    );\n  &#125;\n\n  if (isDispatching) &#123;\n    throw new Error(\n      &quot;You may not call store.subscribe() while the reducer is executing. &quot; +\n        &quot;If you would like to be notified after the store has been updated, subscribe from a &quot; +\n        &quot;component and invoke store.getState() in the callback to access the latest state. &quot; +\n        &quot;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&quot;\n    );\n  &#125;\n\n  let isSubscribed &#x3D; true;\n\n  ensureCanMutateNextListeners();\n  nextListeners.push(listener); &#x2F;&#x2F; 增加\n\n  return function unsubscribe() &#123;\n    if (!isSubscribed) &#123;\n      return;\n    &#125;\n\n    if (isDispatching) &#123;\n      throw new Error(\n        &quot;You may not unsubscribe from a store listener while the reducer is executing. &quot; +\n          &quot;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&quot;\n      );\n    &#125;\n\n    isSubscribed &#x3D; false;\n\n    ensureCanMutateNextListeners();\n    const index &#x3D; nextListeners.indexOf(listener);\n    nextListeners.splice(index, 1); &#x2F;&#x2F; 移除\n    currentListeners &#x3D; null;\n  &#125;;\n&#125;</code></pre>\n\n<p><strong>dispatch</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Dispatches an action. It is the only way to trigger a state change.\n *\n * The &#96;reducer&#96; function, used to create the store, will be called with the\n * current state tree and the given &#96;action&#96;. Its return value will\n * be considered the **next** state of the tree, and the change listeners\n * will be notified.\n *\n * The base implementation only supports plain object actions. If you want to\n * dispatch a Promise, an Observable, a thunk, or something else, you need to\n * wrap your store creating function into the corresponding middleware. For\n * example, see the documentation for the &#96;redux-thunk&#96; package. Even the\n * middleware will eventually dispatch plain object actions using this method.\n *\n * @param action A plain object representing “what changed”. It is\n * a good idea to keep actions serializable so you can record and replay user\n * sessions, or use the time travelling &#96;redux-devtools&#96;. An action must have\n * a &#96;type&#96; property which may not be &#96;undefined&#96;. It is a good idea to use\n * string constants for action types.\n *\n * @returns For convenience, the same action object you dispatched.\n *\n * Note that, if you use a custom middleware, it may wrap &#96;dispatch()&#96; to\n * return something else (for example, a Promise you can await).\n *&#x2F;\nfunction dispatch(action: A) &#123;\n  if (!isPlainObject(action)) &#123;\n    &#x2F;&#x2F; 只能是简单的对象\n    throw new Error(\n      &#96;Actions must be plain objects. Instead, the actual type was: &#39;$&#123;kindOf(\n        action\n      )&#125;&#39;. You may need to add middleware to your store setup to handle dispatching other values, such as &#39;redux-thunk&#39; to handle dispatching functions. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#middleware and https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-6-async-logic#using-the-redux-thunk-middleware for examples.&#96;\n    );\n  &#125;\n\n  if (typeof action.type &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n    throw new Error(\n      &#39;Actions may not have an undefined &quot;type&quot; property. You may have misspelled an action type string constant.&#39;\n    );\n  &#125;\n\n  if (isDispatching) &#123;\n    throw new Error(&quot;Reducers may not dispatch actions.&quot;);\n  &#125;\n\n  try &#123;\n    isDispatching &#x3D; true;\n    currentState &#x3D; currentReducer(currentState, action); &#x2F;&#x2F; 传入当前状态和操作，返回新的状态\n  &#125; finally &#123;\n    isDispatching &#x3D; false;\n  &#125;\n\n  const listeners &#x3D; (currentListeners &#x3D; nextListeners); &#x2F;&#x2F; 触发更新\n  for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;\n    const listener &#x3D; listeners[i];\n    listener();\n  &#125;\n\n  return action;\n&#125;</code></pre>\n\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><ul>\n<li>使用时候以键值对形式存在<br><strong>使用</strong></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useInfoReducer from &quot;.&#x2F;userInfo&quot;;\nimport recordReducer from &quot;.&#x2F;record&quot;;\n\nconst rootReducer &#x3D; combineReducers(&#123;\n  useInfoReducer,\n  recordReducer,\n&#125;);\n\nconst store &#x3D; createStore(rootReducer);</code></pre>\n\n<p><strong>源码</strong></p>\n<ul>\n<li>返回不期望的 state 型警告信息</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getUnexpectedStateShapeWarningMessage(\n  inputState: object,\n  reducers: ReducersMapObject,\n  action: Action,\n  unexpectedKeyCache: &#123; [key: string]: true &#125;\n) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers);\n  const argumentName &#x3D;\n    action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.INIT\n      ? &quot;preloadedState argument passed to createStore&quot;\n      : &quot;previous state received by the reducer&quot;;\n\n  if (reducerKeys.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return (\n      &quot;Store does not have a valid reducer. Make sure the argument passed &quot; +\n      &quot;to combineReducers is an object whose values are reducers.&quot;\n    );\n  &#125;\n\n  if (!isPlainObject(inputState)) &#123;\n    return (\n      &#96;The $&#123;argumentName&#125; has unexpected type of &quot;$&#123;kindOf(\n        inputState\n      )&#125;&quot;. Expected argument to be an object with the following &#96; +\n      &#96;keys: &quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;&#96;\n    );\n  &#125;\n\n  const unexpectedKeys &#x3D; Object.keys(inputState).filter(\n    (key) &#x3D;&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]\n  );\n\n  unexpectedKeys.forEach((key) &#x3D;&gt; &#123;\n    unexpectedKeyCache[key] &#x3D; true;\n  &#125;);\n\n  if (action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length &gt; 0) &#123;\n    return (\n      &#96;Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &quot;keys&quot; : &quot;key&quot;&#125; &#96; +\n      &#96;&quot;$&#123;unexpectedKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot; found in $&#123;argumentName&#125;. &#96; +\n      &#96;Expected to find one of the known reducer keys instead: &#96; +\n      &#96;&quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;. Unexpected keys will be ignored.&#96;\n    );\n  &#125;\n&#125;\n&#x2F;&#x2F; 对 reducer型进行断言\nfunction assertReducerShape(reducers: ReducersMapObject) &#123;\n  Object.keys(reducers).forEach((key) &#x3D;&gt; &#123;\n    const reducer &#x3D; reducers[key];\n    const initialState &#x3D; reducer(undefined, &#123; type: ActionTypes.INIT &#125;);\n\n    if (typeof initialState &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n      throw new Error(\n        &#x2F;&#x2F; 初始化initialState时候可以用null,但是不可以用undefined\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined during initialization. &#96; +\n          &#96;If the state passed to the reducer is undefined, you must &#96; +\n          &#96;explicitly return the initial state. The initial state may &#96; +\n          &#96;not be undefined. If you don&#39;t want to set a value for this reducer, &#96; +\n          &#96;you can use null instead of undefined.&#96;\n      );\n    &#125;\n\n    if (\n      typeof reducer(undefined, &#123;\n        type: ActionTypes.PROBE_UNKNOWN_ACTION(),\n      &#125;) &#x3D;&#x3D;&#x3D; &quot;undefined&quot;\n    ) &#123;\n      throw new Error(\n        &#x2F;&#x2F; 1.随机类型&#x2F; redux&#x2F;*类型 的操作类型为redux私有，不允许使用\n        &#x2F;&#x2F; 2.初始化状态不可以是undefined,\n        &#x2F;&#x2F; 3.新状态如果是undefined的，必须返回初始状态\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. &#96; +\n          &#96;Don&#39;t try to handle &#39;$&#123;ActionTypes.INIT&#125;&#39; or other actions in &quot;redux&#x2F;*&quot; &#96; +\n          &#96;namespace. They are considered private. Instead, you must return the &#96; +\n          &#96;current state for any unknown actions, unless it is undefined, &#96; +\n          &#96;in which case you must return the initial state, regardless of the &#96; +\n          &#96;action type. The initial state may not be undefined, but can be null.&#96;\n      );\n    &#125;\n  &#125;);\n&#125;\n\n&#x2F;&#x2F; combineReducers的实现，其实就是将多个值，合并在一个对象中\nexport default function combineReducers(reducers: ReducersMapObject) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers);\n  const finalReducers: ReducersMapObject &#x3D; &#123;&#125;;\n  for (let i &#x3D; 0; i &lt; reducerKeys.length; i++) &#123;\n    const key &#x3D; reducerKeys[i];\n\n    if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n      finalReducers[key] &#x3D; reducers[key];\n    &#125;\n  &#125;\n  const finalReducerKeys &#x3D; Object.keys(finalReducers);\n\n  &#x2F;&#x2F; This is used to make sure we don&#39;t warn about the same\n  &#x2F;&#x2F; keys multiple times.\n  &#x2F;&#x2F;这用于确保我们不会多次警告相同的key。\n  let unexpectedKeyCache: &#123; [key: string]: true &#125;;\n\n  return function combination(\n    state: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;,\n    action: AnyAction\n  ) &#123;\n    &#x2F;&#x2F;校验信息...\n\n    let hasChanged &#x3D; false;\n    const nextState: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;;\n    for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;\n      const key &#x3D; finalReducerKeys[i];\n      &#x2F;&#x2F; reducer\n      const reducer &#x3D; finalReducers[key];\n      &#x2F;&#x2F; 之前状态\n      const previousStateForKey &#x3D; state[key];\n      &#x2F;&#x2F; 新状态\n      const nextStateForKey &#x3D; reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n        const actionType &#x3D; action &amp;&amp; action.type;\n        throw new Error(\n          &#96;When called with an action of type $&#123;\n            actionType ? &#96;&quot;$&#123;String(actionType)&#125;&quot;&#96; : &quot;(unknown type)&quot;\n          &#125;, the slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined. &#96; +\n            &#96;To ignore an action, you must explicitly return the previous state. &#96; +\n            &#96;If you want this reducer to hold no value, you can return null instead of undefined.&#96;\n        );\n      &#125;\n      nextState[key] &#x3D; nextStateForKey;\n      &#x2F;&#x2F; 判断是否发生更新\n      hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey;\n    &#125;\n    hasChanged &#x3D;\n      hasChanged || finalReducerKeys.length !&#x3D;&#x3D; Object.keys(state).length;\n    &#x2F;&#x2F; 更新返回新的状态，否则返回之前状态\n    return hasChanged ? nextState : state;\n  &#125;;\n&#125;</code></pre>\n\n<h2 id=\"bindActionCreators\"><a href=\"#bindActionCreators\" class=\"headerlink\" title=\"bindActionCreators\"></a>bindActionCreators</h2><ul>\n<li>给 action 包裹层 dispatch</li>\n<li>action 有两种类型： 函数、键值对</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function bindActionCreators(\n  actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject,\n  dispatch: Dispatch\n) &#123;\n  &#x2F;&#x2F; 函数类型直接bindActionCreator返回\n  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n    return bindActionCreator(actionCreators, dispatch);\n  &#125;\n\n  if (typeof actionCreators !&#x3D;&#x3D; &quot;object&quot; || actionCreators &#x3D;&#x3D;&#x3D; null) &#123;\n    throw new Error(\n      &#96;bindActionCreators expected an object or a function, but instead received: &#39;$&#123;kindOf(\n        actionCreators\n      )&#125;&#39;. &#96; +\n        &#96;Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?&#96;\n    );\n  &#125;\n\n  const boundActionCreators: ActionCreatorsMapObject &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 对象遍历调用bindActionCreator\n  for (const key in actionCreators) &#123;\n    const actionCreator &#x3D; actionCreators[key];\n    if (typeof actionCreator &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n      boundActionCreators[key] &#x3D; bindActionCreator(actionCreator, dispatch);\n    &#125;\n  &#125;\n  return boundActionCreators;\n&#125;</code></pre>\n\n<p><strong>使用及测试代码见</strong></p>\n<p><code>redux/test/typescript/actionCreators.ts</code></p>\n<p><strong>bindActionCreator</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 作用是每个actionCreator增加一个dispatch包裹\nfunction bindActionCreator&lt;A extends AnyAction &#x3D; AnyAction&gt;(\n  actionCreator: ActionCreator&lt;A&gt;,\n  dispatch: Dispatch\n) &#123;\n  return function (this: any, ...args: any[]) &#123;\n    return dispatch(actionCreator.apply(this, args)); &#x2F;&#x2F; 主要代码\n  &#125;;\n&#125;</code></pre>\n\n<h2 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h2><ul>\n<li>中间件</li>\n<li>对 store 能力进行增强</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer&lt;any&gt; &#123;\n  return (createStore: StoreEnhancerStoreCreator) &#x3D;&gt;\n    &lt;S, A extends AnyAction&gt;(\n      reducer: Reducer&lt;S, A&gt;,\n      preloadedState?: PreloadedState&lt;S&gt;\n    ) &#x3D;&gt; &#123;\n      const store &#x3D; createStore(reducer, preloadedState)\n\n\n      &#x2F;&#x2F; 声明\n      let dispatch: Dispatch &#x3D; () &#x3D;&gt; &#123;\n        throw new Error(\n          &#39;Dispatching while constructing your middleware is not allowed. &#39; +\n            &#39;Other middleware would not be applied to this dispatch.&#39;\n        )\n      &#125;\n\n      const middlewareAPI: MiddlewareAPI &#x3D; &#123;\n        getState: store.getState,\n                                      &#x2F;&#x2F;使用上述函数进行\n        dispatch: (action, ...args) &#x3D;&gt; dispatch(action, ...args)\n      &#125;\n      &#x2F;&#x2F; 中间件数组\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n\n\n      &#x2F;&#x2F; 增强的是dispatch\n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;\n\n\n&#96;&#96;&#96;ts\n\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n\n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h2><ul>\n<li>洋葱模型<br><strong>使用</strong></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">compose(f, g, h)\n(...args) &#x3D;&gt; f(g(h(...args)))\n</code></pre>\n\n<p><strong>源码</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function compose(...funcs: Function[]) &#123;\n  &#x2F;&#x2F; 参数长度判断\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line\n    return &lt;T&gt;(arg: T) &#x3D;&gt; arg;\n  &#125;\n  &#x2F;&#x2F; 长度为1\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0];\n  &#125;\n  &#x2F;&#x2F; 主要代码一行\n  return funcs.reduce(\n    (a, b) &#x3D;&gt;\n      (...args: any) &#x3D;&gt;\n        a(b(...args))\n  );\n&#125;</code></pre>\n\n<p><strong>讲 compose 的文章</strong></p>\n<p><a href=\"http://givencui.com/index.php/archives/28/\" target=\"_blank\" >这里有一篇非常好</a></p>\n<h2 id=\"DO-NOT-USEActionTypes\"><a href=\"#DO-NOT-USEActionTypes\" class=\"headerlink\" title=\"DO_NOT_USEActionTypes\"></a><strong>DO_NOT_USE</strong>ActionTypes</h2><ul>\n<li>一些私有的 action 被 redux 保留，对于不明确的 action，必须返回当前 state.</li>\n<li>如果当前状态是 undefined,必须返回初始状态</li>\n<li>不要在代码中直接涉及这些 action</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const ActionTypes &#x3D; &#123;\n  INIT: &#96;@@redux&#x2F;INIT$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  REPLACE: &#96;@@redux&#x2F;REPLACE$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  PROBE_UNKNOWN_ACTION: () &#x3D;&gt; &#96;@@redux&#x2F;PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;&#96;,\n&#125;;</code></pre>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"http://t-blog-images.aijs.top/img/redux源码内容.png\"/>\n\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p><img src=\"http://t-blog-images.aijs.top/img/20220527091836.webp\"></p>\n<h2 id=\"巩固\"><a href=\"#巩固\" class=\"headerlink\" title=\"巩固\"></a>巩固</h2><p><img src=\"http://t-blog-images.aijs.top/img/20220527095407.webp\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.51cto.com/u_15283585/2958523\">最精简的 Redux 源码解析，看完从此再也不怕面试官</a><br><a href=\"https://www.jianshu.com/p/490fc0d89029\">Redux 源码解析</a><br><a href=\"https://github.com/841660202/redux\">github 源码</a></p>\n","text":"redux 简介Predictable state container for JavaScript apps 字面意思 js 应用可预测状态容器 怎么用，为什么用看官网。。。 createStore代码注释如下 redux store 持有 state 树，唯一可以改变 sto...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":16,"path":"api/tags/源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#redux-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">redux 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">怎么用，为什么用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createStore\"><span class=\"toc-text\">createStore</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#combineReducers\"><span class=\"toc-text\">combineReducers</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bindActionCreators\"><span class=\"toc-text\">bindActionCreators</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#applyMiddleware\"><span class=\"toc-text\">applyMiddleware</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#compose\"><span class=\"toc-text\">compose</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DO-NOT-USEActionTypes\"><span class=\"toc-text\">DO_NOT_USEActionTypes</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">回顾</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A9%E5%9B%BA\"><span class=\"toc-text\">巩固</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"js 代码注释","uid":"5df43a7a7d0a76be0dcfbc13fca3f3d6","slug":"2022-05-26code","date":"2022-05-26T07:31:20.000Z","updated":"2023-07-31T06:42:49.718Z","comments":true,"path":"api/articles/2022-05-26code.json","keywords":null,"cover":[],"text":"代码注释//这种 js 注释代码在 vscode 其他地方引用时候，没有提示， 如果需要有提示，需要写成/** 提示 **/ 写法1; export enum ELeaveType &#123; MATERNITY_ &#x3D; 17, &#x2F;&#x2F; &quot;产...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"code","slug":"code","count":1,"path":"api/categories/code.json"}],"tags":[{"name":"code","slug":"code","count":1,"path":"api/tags/code.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"redux 源码 1","uid":"af1b42282a210ca45f834a49b50349c6","slug":"2022-05-25.redux","date":"2022-05-25T05:48:17.000Z","updated":"2022-09-16T14:57:59.791Z","comments":true,"path":"api/articles/2022-05-25.redux.json","keywords":null,"cover":[],"text":"介绍A Predictable State Container for JS Apps package.json&#123; &quot;name&quot;: &quot;redux&quot;, &quot;version&quot;: &quot;5.0.0-alpha.0...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"redux","slug":"redux","count":6,"path":"api/tags/redux.json"},{"name":"源码","slug":"源码","count":16,"path":"api/tags/源码.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}