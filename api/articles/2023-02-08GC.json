{"title":"垃圾回收机制","uid":"1e558081e29dbc1646c77a0cee4dbc74","slug":"2023-02-08GC","date":"2023-02-08T12:22:21.000Z","updated":"2023-05-15T13:17:32.975Z","comments":true,"path":"api/articles/2023-02-08GC.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202302082055497.webp","content":"<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>清除不在使用的对象，释放所占用的内存</p>\n<p>当定义一个变量，给它重新赋值一个新的对象后，原来的对象就不再使用了，就可以把它清除掉</p>\n<h2 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h2><ol>\n<li>引用计数法</li>\n<li>标记清除法</li>\n</ol>\n<h2 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h2><ol>\n<li>当对象被引用一次，引用数+1，</li>\n<li>被取消引用一次，引用数-1，</li>\n<li>当引用数为 0 的时候，就触发垃圾回收机制进行回收</li>\n</ol>\n<p>问题：这样会产生一个很严重的问题，循环引用，引用的次数永远不可能为 0，无法回收，内存无法释放</p>\n<h2 id=\"标记清除法\"><a href=\"#标记清除法\" class=\"headerlink\" title=\"标记清除法\"></a>标记清除法</h2><ol>\n<li>将所有的对象标记为 0</li>\n<li>从根对象开始遍历，将存活的对象标记为 1</li>\n<li>然后将标记为 0 的对象清除掉</li>\n<li>最后，将标记为 1 的对象重新标记为 0，方便下一次垃圾回收机制回收</li>\n</ol>\n<p>问题：清除之后位置是不连续的，如果进来一个新对象找位置，是一个问题</p>\n<h2 id=\"新对象如何找合适的位置？\"><a href=\"#新对象如何找合适的位置？\" class=\"headerlink\" title=\"新对象如何找合适的位置？\"></a>新对象如何找合适的位置？</h2><ol>\n<li>first-fit: 找到能放置下新对象的第一个块位置（性能最好）</li>\n<li>best-fit: 找到能放置下新对象的最小块</li>\n<li>worst-fit: 找到最大的块，切一块空间给新对象（会产生更多不连续的空间）</li>\n</ol>\n<h2 id=\"v8-垃圾回收优化算法\"><a href=\"#v8-垃圾回收优化算法\" class=\"headerlink\" title=\"v8 垃圾回收优化算法\"></a>v8 垃圾回收优化算法</h2><img src=\"http://t-blog-images.aijs.top/img/202302082055497.webp\" style=\"width:500px;max-width:100%\" />\n\n<p>优化标记算法</p>\n<ol>\n<li>有的对象需要频繁回收，有的对象不需要频繁回收</li>\n<li>小的存活时间短的需要频繁回收</li>\n<li>大的老的，不需要频繁回收</li>\n<li>在堆内存中分出两个区域来，一个是新生代区，一个是老生代区，</li>\n<li>新生代区一般存： 小的存活时间短的需要频繁回收， 老生代区存： 大的老的，不需要频繁回收</li>\n</ol>\n<h3 id=\"新生代区回收机制\"><a href=\"#新生代区回收机制\" class=\"headerlink\" title=\"新生代区回收机制\"></a>新生代区回收机制</h3><ol>\n<li>新生代区会分离出两个空间：from 空间、to 空间</li>\n<li>from 空间是使用空间，to 空间是闲置空间</li>\n<li>当 from 空间中的对象要满的时候，就开始标记，将存活的对象标记好，标记好后，将他们复制到闲置的空间中，将 form 空间清空</li>\n</ol>\n<h3 id=\"老生代区回收机制\"><a href=\"#老生代区回收机制\" class=\"headerlink\" title=\"老生代区回收机制\"></a>老生代区回收机制</h3><ol>\n<li>标记清除算法 &amp; 标记压缩算法<ol>\n<li>将所有的对象标记为 0</li>\n<li>从根对象开始遍历，将存活的对象标记为 1</li>\n<li>然后将标记为 0 的对象清除掉</li>\n<li>最后，将标记为 1 的对象重新标记为 0，</li>\n<li>使用压缩算法，将位置整理好</li>\n</ol>\n</li>\n</ol>\n<p>js 是单线程语言，在执行垃圾回收的时候，js 执行会被暂停</p>\n<h3 id=\"v8-多线程回收机制\"><a href=\"#v8-多线程回收机制\" class=\"headerlink\" title=\"v8 多线程回收机制\"></a>v8 多线程回收机制</h3><p>v8 机制，对这种情况做了一定的优化：垃圾回收机制支持多线程，并行回收，使垃圾回收机制的时间加快了，时间变短，最大化保证 js 执行，但是依然会阻塞 js 的执行</p>\n<h3 id=\"v8-增量标记\"><a href=\"#v8-增量标记\" class=\"headerlink\" title=\"v8 增量标记\"></a>v8 增量标记</h3><p>垃圾回收可以分段执行： 执行一段 js，执行一段垃圾回收机制，交叉执行，最大化保证 js 的执行</p>\n<p>问题：如何知道上一次标记的位置？</p>\n<h3 id=\"v8-三色标记法\"><a href=\"#v8-三色标记法\" class=\"headerlink\" title=\"v8 三色标记法\"></a>v8 三色标记法</h3><p>将上次标记到的位置标记为灰色，当下次执行的时候从灰色开始重新标记</p>\n<h3 id=\"v8-并发回收\"><a href=\"#v8-并发回收\" class=\"headerlink\" title=\"v8 并发回收\"></a>v8 并发回收</h3><p>js 在主线程中执行，垃圾回收在辅助线程中执行</p>\n","text":"是什么清除不在使用的对象，释放所占用的内存 当定义一个变量，给它重新赋值一个新的对象后，原来的对象就不再使用了，就可以把它清除掉 策略 引用计数法 标记清除法 引用计数法 当对象被引用一次，引用数+1， 被取消引用一次，引用数-1， 当引用数为 0 的时候，就触发垃圾回收机制进行...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95\"><span class=\"toc-text\">引用计数法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95\"><span class=\"toc-text\">标记清除法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E6%89%BE%E5%90%88%E9%80%82%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9F\"><span class=\"toc-text\">新对象如何找合适的位置？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">v8 垃圾回收优化算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%8C%BA%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">新生代区回收机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%80%81%E7%94%9F%E4%BB%A3%E5%8C%BA%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">老生代区回收机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#v8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">v8 多线程回收机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#v8-%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0\"><span class=\"toc-text\">v8 增量标记</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#v8-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95\"><span class=\"toc-text\">v8 三色标记法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#v8-%E5%B9%B6%E5%8F%91%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">v8 并发回收</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据存储的复盘","uid":"beed7925d3f184cc44d11ac5313f14be","slug":"2023-02-09数据","date":"2023-02-09T02:06:51.000Z","updated":"2023-02-20T21:20:56.488Z","comments":true,"path":"api/articles/2023-02-09数据.json","keywords":null,"cover":null,"text":"背景 列表查询查询条件，需要创建筛选器进行服务端存储 用户打开页面获取筛选器列表 点击筛选器列表，获取筛选器详情，并用筛选器详情进行列表查询操作 要点：查询条件，与筛选器条件一致性 问题 后端将筛选器存的数据进行非必要拆分 筛选器与查询列表的接口条件字段对不上 筛选器与查询列表的...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"复盘","slug":"复盘","count":7,"path":"api/categories/复盘.json"}],"tags":[{"name":"复盘","slug":"复盘","count":7,"path":"api/tags/复盘.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"vscode 升级后一些问题","uid":"d22bd3e2ae8312f99881c275d1b03727","slug":"2023-02-08vscode","date":"2023-02-08T02:12:13.000Z","updated":"2023-02-20T21:20:56.487Z","comments":true,"path":"api/articles/2023-02-08vscode.json","keywords":null,"cover":"https://www.ymama.net/config/ueditor/php/upload/image/20200827/1598515434460503.png","text":"代码片段失效了升级后，需要增加 如下配置 &quot;editor.suggest.showSnippets&quot;: true, 讲道理是不应该的：电脑配置是同步 github 的，不会出现丢失的现象 见#173924 代码片段之前正常的内容也会报红 issues 很多反馈...","link":"","photos":[],"count_time":{"symbolsCount":250,"symbolsTime":"1 mins."},"categories":[{"name":"vscode","slug":"vscode","count":8,"path":"api/categories/vscode.json"}],"tags":[{"name":"vscode","slug":"vscode","count":11,"path":"api/tags/vscode.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}