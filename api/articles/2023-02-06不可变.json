{"title":"immer","uid":"02c9defcec8ead4b797947c1373e1cfd","slug":"2023-02-06不可变","date":"2023-02-06T08:24:33.000Z","updated":"2023-02-20T21:20:56.487Z","comments":true,"path":"api/articles/2023-02-06不可变.json","keywords":null,"cover":[],"content":"<h2 id=\"什么是不可变数据范式\"><a href=\"#什么是不可变数据范式\" class=\"headerlink\" title=\"什么是不可变数据范式\"></a>什么是不可变数据范式</h2><h2 id=\"immerjs\"><a href=\"#immerjs\" class=\"headerlink\" title=\"immerjs\"></a>immerjs</h2><p><a href=\"https://immerjs.github.io/immer/zh-CN/\" target=\"_blank\" >中文官网</a></p>\n<div style=\"display: flex;align-items: center;padding-top:4px;padding-bottom: 4px\"><a target=\"_blank\" href=\"https://github.com/immerjs/immer\">https://github.com/immerjs/immer</a><img src=\"https://img.shields.io/github/stars/immerjs/immer?style=social\" /></div>\n\n<h2 id=\"immer-是什么\"><a href=\"#immer-是什么\" class=\"headerlink\" title=\"immer 是什么\"></a>immer 是什么</h2><p>在于 baseState 将保持不变，但 nextState 将反映对 DraftState 所做的所有更改.</p>\n<h2 id=\"为什么需要-immer\"><a href=\"#为什么需要-immer\" class=\"headerlink\" title=\"为什么需要 immer\"></a>为什么需要 immer</h2><ol>\n<li>不可变的数据结构的变化检测：</li>\n<li>如果对象的引用没有改变，那么对象本身也没有改变。</li>\n<li>此外，它使克隆对象相对便宜：数据树的未更改部分不需要复制，并且在内存中与相同状态的旧版本共享</li>\n</ol>\n<h2 id=\"immer-使用场景\"><a href=\"#immer-使用场景\" class=\"headerlink\" title=\"immer 使用场景\"></a>immer 使用场景</h2><ol>\n<li>Immer 可以在需要使用不可变数据结构的任何上下文中使用。</li>\n<li>例如与 React state、React 或 Redux reducers 或者 configuration management 结合使用</li>\n<li><code>react-dnd 排序，防止整个列表突变</code></li>\n</ol>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><strong>只关注变更，剩下的 Immer 自动完成</strong></p>\n<ol>\n<li>使用 Immer 时，<code>将所有更改应用到临时 draft，它是 currentState 的代理</code>。</li>\n<li>完成了所有的 mutations 后，Immer 根据 draft state 的 mutations 生成 nextState。</li>\n<li>这意味着您可以通过简单地修改数据来与数据交互，同时保留不可变数据的所有好处。</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202302061656094.webp\" style=\"width:500px;max-width:100%\" />\n\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li><code>遵循不可变数据范式</code>，同时使用普通的 JavaScript 对象、数组、Sets 和 Maps。无需学习新的 API 或 “mutations patterns”！</li>\n<li>强类型，无基于字符串的路径选择器等</li>\n<li>开箱即用的<code>结构共享</code></li>\n<li>开箱即用的<code>对象冻结</code></li>\n<li>深度更新轻而易举</li>\n<li>样板代码减少。更少的噪音，更简洁的代码</li>\n<li>对 JSON 补丁的一流支持</li>\n<li>小：3KB gzip</li>\n</ol>\n<p>总之：过程简单，小巧方便</p>\n<h2 id=\"使用上需要注意的地方\"><a href=\"#使用上需要注意的地方\" class=\"headerlink\" title=\"使用上需要注意的地方\"></a>使用上需要注意的地方</h2><p><a href=\"https://immerjs.github.io/immer/zh-CN/installation\" target=\"_blank\" >见</a></p>\n<p>功能选用</p>\n<h2 id=\"使用上\"><a href=\"#使用上\" class=\"headerlink\" title=\"使用上\"></a>使用上</h2><h3 id=\"produce\"><a href=\"#produce\" class=\"headerlink\" title=\"produce\"></a>produce</h3><h3 id=\"react-hooks\"><a href=\"#react-hooks\" class=\"headerlink\" title=\"react hooks\"></a>react hooks</h3><p><a href=\"https://immerjs.github.io/immer/zh-CN/example-setstate\" target=\"_blank\" >见</a></p>\n<h3 id=\"对象-x2F-数组-x2F-嵌套结构\"><a href=\"#对象-x2F-数组-x2F-嵌套结构\" class=\"headerlink\" title=\"对象&#x2F;数组&#x2F;嵌套结构\"></a>对象&#x2F;数组&#x2F;嵌套结构</h3><h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 没有额外的 API,同原生\nimport produce from &quot;immer&quot;;\n\nconst todosObj &#x3D; &#123;\n  id1: &#123; done: false, body: &quot;Take out the trash&quot; &#125;,\n  id2: &#123; done: false, body: &quot;Check Email&quot; &#125;,\n&#125;;\n\n&#x2F;&#x2F; 添加\nconst addedTodosObj &#x3D; produce(todosObj, (draft) &#x3D;&gt; &#123;\n  draft[&quot;id3&quot;] &#x3D; &#123; done: false, body: &quot;Buy bananas&quot; &#125;;\n&#125;);\n\n&#x2F;&#x2F; 删除\nconst deletedTodosObj &#x3D; produce(todosObj, (draft) &#x3D;&gt; &#123;\n  delete draft[&quot;id1&quot;];\n&#125;);\n\n&#x2F;&#x2F; 更新\nconst updatedTodosObj &#x3D; produce(todosObj, (draft) &#x3D;&gt; &#123;\n  draft[&quot;id1&quot;].done &#x3D; true;\n&#125;);</code></pre>\n\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 没有额外的 API,同原生\nimport produce from &quot;immer&quot;;\n\nconst todosArray &#x3D; [\n  &#123; id: &quot;id1&quot;, done: false, body: &quot;Take out the trash&quot; &#125;,\n  &#123; id: &quot;id2&quot;, done: false, body: &quot;Check Email&quot; &#125;,\n];\n\n&#x2F;&#x2F; 添加\nconst addedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.push(&#123; id: &quot;id3&quot;, done: false, body: &quot;Buy bananas&quot; &#125;);\n&#125;);\n\n&#x2F;&#x2F; 索引删除\nconst deletedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.splice(3 &#x2F;*索引 *&#x2F;, 1);\n&#125;);\n\n&#x2F;&#x2F; 索引更新\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft[3].done &#x3D; true;\n&#125;);\n\n&#x2F;&#x2F; 索引插入\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.splice(3, 0, &#123; id: &quot;id3&quot;, done: false, body: &quot;Buy bananas&quot; &#125;);\n&#125;);\n\n&#x2F;&#x2F; 删除最后一个元素\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.pop();\n&#125;);\n\n&#x2F;&#x2F; 删除第一个元素\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.shift();\n&#125;);\n\n&#x2F;&#x2F; 数组开头添加元素\nconst addedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.unshift(&#123; id: &quot;id3&quot;, done: false, body: &quot;Buy bananas&quot; &#125;);\n&#125;);\n\n&#x2F;&#x2F; 根据 id 删除\nconst deletedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  const index &#x3D; draft.findIndex((todo) &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; &quot;id1&quot;);\n  if (index !&#x3D;&#x3D; -1) draft.splice(index, 1);\n&#125;);\n\n&#x2F;&#x2F; 根据 id 更新\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  const index &#x3D; draft.findIndex((todo) &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; &quot;id1&quot;);\n  if (index !&#x3D;&#x3D; -1) draft[index].done &#x3D; true;\n&#125;);\n\n&#x2F;&#x2F; 过滤\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 过滤器实际上会返回一个不可变的状态，但是如果过滤器不是处于对象的顶层，这个依然很有用\n  return draft.filter((todo) &#x3D;&gt; todo.done);\n&#125;);</code></pre>\n\n<h4 id=\"嵌套数据结构\"><a href=\"#嵌套数据结构\" class=\"headerlink\" title=\"嵌套数据结构\"></a>嵌套数据结构</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import produce from &quot;immer&quot;;\n\n&#x2F;&#x2F; 复杂数据结构例子\nconst store &#x3D; &#123;\n  users: new Map([\n    &#x2F;&#x2F; 这里转化为map类型啦\n    [\n      &quot;17&quot;,\n      &#123;\n        name: &quot;Michel&quot;,\n        todos: [\n          &#123;\n            title: &quot;Get coffee&quot;,\n            done: false,\n          &#125;,\n        ],\n      &#125;,\n    ],\n  ]),\n&#125;;\n\n&#x2F;&#x2F; 深度更新\nconst nextStore &#x3D; produce(store, (draft) &#x3D;&gt; &#123;\n  draft.users.get(&quot;17&quot;).todos[0].done &#x3D; true;\n&#125;);\n\n&#x2F;&#x2F; 过滤\nconst nextStore &#x3D; produce(store, (draft) &#x3D;&gt; &#123;\n  const user &#x3D; draft.users.get(&quot;17&quot;);\n\n  user.todos &#x3D; user.todos.filter((todo) &#x3D;&gt; todo.done);\n&#125;);</code></pre>\n\n<h4 id=\"优化点\"><a href=\"#优化点\" class=\"headerlink\" title=\"优化点\"></a>优化点</h4><ol>\n<li>请注意，许多数组操作可用于通过传递多个参数或使用展开操作来一次插入多个元素：todos.unshift(…items)。</li>\n<li>请注意，当处理包含通常由某个 id 标识的对象的数组时，我们建议使用基于 Map 或索引的对象（如上所示）而不是执行频繁的查找操作，查找表通常执行效率更高。</li>\n</ol>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><h3 id=\"按需深拷贝的实现\"><a href=\"#按需深拷贝的实现\" class=\"headerlink\" title=\"按需深拷贝的实现\"></a>按需深拷贝的实现</h3><p><a href=\"https://zhuanlan.zhihu.com/p/455242804#:~:text=%E5%86%99%E6%B3%95%E4%B8%8D%E5%90%8C%E8%80%8C%E5%B7%B2%E3%80%82-,%E6%8C%89%E9%9C%80%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0,-%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E6%B7%B1\" target=\"_blank\" >见</a></p>\n<ol>\n<li>先标记出在 produce 的回调函数中对 draft 做了哪些修改<ol>\n<li>当在 produce 的回调函数（称之为 recipe 函数）中修改 draft 数据时，</li>\n<li>通过 set 或 deleteProperty 中的 markChange 完成变化追踪，</li>\n<li>同时通过 state.copy* 来记录修改后的值，并通过 state.assigned* 来记录修改的类型</li>\n</ol>\n</li>\n<li>当数据修改完成（recipe 函数执行完成）后，通过 <code>state.copy_</code> 和 <code>state.modified_</code> 来生成新的状态<ol>\n<li>通过递归遍历子属性，</li>\n<li>通过之前的标记判断子属性部分的数据是否有被修改过，</li>\n<li>如果未被修改则直接使用原始状态中的引用，否则就使用 state.copy_ 中记录的更新来设置子属性数据</li>\n</ol>\n</li>\n</ol>\n<p>是不是有点 react 的味道，<code>找出变化标记-&gt;产出</code></p>\n<h3 id=\"produce-1\"><a href=\"#produce-1\" class=\"headerlink\" title=\"produce\"></a>produce</h3><img src=\"http://t-blog-images.aijs.top/img/202302080942736.webp\" style=\"width:500px;max-width:100%\" />\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://github.com/ascoders/weekly/blob/master/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/48.%E7%B2%BE%E8%AF%BB%E3%80%8AImmer.js%E3%80%8B%E6%BA%90%E7%A0%81.md\" target=\"_blank\" >48.精读《Immer.js》源码.md</a></p>\n<p><a href=\"https://juejin.cn/post/7039681632386678791#heading-1\" target=\"_blank\" >精读 Immer 源码（一）</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/455242804#:~:text=%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%82-,immer%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86,-immer%20%E7%9A%84%E5%AE%9E%E7%8E%B0\" target=\"_blank\" >immer 实现原理</a></p>\n","text":"什么是不可变数据范式immerjs中文官网 https://github.com/immerjs/immer immer 是什么在于 baseState 将保持不变，但 nextState 将反映对 DraftState 所做的所有更改. 为什么需要 immer 不可变的数据结构...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"前端工具","slug":"前端工具","count":1,"path":"api/categories/前端工具.json"}],"tags":[{"name":"前端工具","slug":"前端工具","count":1,"path":"api/tags/前端工具.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">什么是不可变数据范式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#immerjs\"><span class=\"toc-text\">immerjs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#immer-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">immer 是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-immer\"><span class=\"toc-text\">为什么需要 immer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#immer-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">immer 使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">工作原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9\"><span class=\"toc-text\">使用上需要注意的地方</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%B8%8A\"><span class=\"toc-text\">使用上</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#produce\"><span class=\"toc-text\">produce</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-hooks\"><span class=\"toc-text\">react hooks</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1-x2F-%E6%95%B0%E7%BB%84-x2F-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">对象&#x2F;数组&#x2F;嵌套结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%A5%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">嵌套数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E7%82%B9\"><span class=\"toc-text\">优化点</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">源码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%9C%80%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">按需深拷贝的实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#produce-1\"><span class=\"toc-text\">produce</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"vscode 升级后一些问题","uid":"d22bd3e2ae8312f99881c275d1b03727","slug":"2023-02-08vscode","date":"2023-02-08T02:12:13.000Z","updated":"2023-02-20T21:20:56.487Z","comments":true,"path":"api/articles/2023-02-08vscode.json","keywords":null,"cover":"https://www.ymama.net/config/ueditor/php/upload/image/20200827/1598515434460503.png","text":"代码片段失效了升级后，需要增加 如下配置 &quot;editor.suggest.showSnippets&quot;: true, 讲道理是不应该的：电脑配置是同步 github 的，不会出现丢失的现象 见#173924 代码片段之前正常的内容也会报红 issues 很多反馈...","link":"","photos":[],"count_time":{"symbolsCount":250,"symbolsTime":"1 mins."},"categories":[{"name":"vscode","slug":"vscode","count":8,"path":"api/categories/vscode.json"}],"tags":[{"name":"vscode","slug":"vscode","count":11,"path":"api/tags/vscode.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端工程化","uid":"d24ff20ad1a722248c0f6ba78f471b7d","slug":"2023-02-04工程化","date":"2023-02-04T12:29:26.000Z","updated":"2023-07-31T07:55:27.586Z","comments":true,"path":"api/articles/2023-02-04工程化.json","keywords":null,"cover":[],"text":"babelBabel 的原理是什么?babel 的转译过程也分为三个阶段，这三步具体是： 解析 Parse: 将代码解析⽣成抽象语法树( 即 AST )，即词法分析与语法分析的过程 转换 Transform: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}