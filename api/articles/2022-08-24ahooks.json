{"title":"ahooks源码","uid":"847fdfbf845470be05a2ff27391aae0c","slug":"2022-08-24ahooks","date":"2022-08-24T09:16:49.000Z","updated":"2022-08-31T13:00:11.737Z","comments":true,"path":"api/articles/2022-08-24ahooks.json","keywords":null,"cover":[],"content":"<h2 id=\"useUpdate\"><a href=\"#useUpdate\" class=\"headerlink\" title=\"useUpdate\"></a>useUpdate</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>useUpdate 会返回一个函数，调用该函数会强制组件重新渲染。</p></blockquote>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useCallback, useState &#125; from &quot;react&quot;;\n\nconst useUpdate &#x3D; () &#x3D;&gt; &#123;\n  const [, setState] &#x3D; useState(&#123;&#125;);\n\n  return useCallback(() &#x3D;&gt; setState(&#123;&#125;), []); &#x2F;&#x2F; setState(&#123;&#125;) 每次置为新的对象，即使页面没有用到该useState的返回值，也会更新\n&#125;;\n\nexport default useUpdate;</code></pre>\n\n<h2 id=\"useControllableValue\"><a href=\"#useControllableValue\" class=\"headerlink\" title=\"useControllableValue\"></a>useControllableValue</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在某些组件开发时，我们需要组件的状态既可以自己管理，也可以被外部控制，useControllableValue 就是帮你管理这种状态的 Hook。</p></blockquote>\n<p>简单来说，默认情况下,外层组件有 value, onChange 就用外层的，外层没有，自己处理</p>\n<img src=\"http://t-blog-images.aijs.top/img/202208241724077.webp\" />\n\n<p>虽然是复用，可这里这么写有点奇怪</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport type &#123; SetStateAction &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport useUpdate from &quot;..&#x2F;useUpdate&quot;;\n\nexport interface Options&lt;T&gt; &#123;\n  defaultValue?: T;\n  defaultValuePropName?: string;\n  valuePropName?: string;\n  trigger?: string;\n&#125;\n\nexport type Props &#x3D; Record&lt;string, any&gt;;\n\nexport interface StandardProps&lt;T&gt; &#123;\n  value: T;\n  defaultValue?: T;\n  onChange: (val: T) &#x3D;&gt; void;\n&#125;\n\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props: StandardProps&lt;T&gt;\n): [T, (v: SetStateAction&lt;T&gt;) &#x3D;&gt; void];\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props?: Props,\n  options?: Options&lt;T&gt;\n): [T, (v: SetStateAction&lt;T&gt;, ...args: any[]) &#x3D;&gt; void];\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props: Props &#x3D; &#123;&#125;,\n  options: Options&lt;T&gt; &#x3D; &#123;&#125;\n) &#123;\n  &#x2F;&#x2F; 这里一堆，是函数重写？\n  const &#123;\n    defaultValue,\n    defaultValuePropName &#x3D; &quot;defaultValue&quot;,\n    valuePropName &#x3D; &quot;value&quot;,\n    trigger &#x3D; &quot;onChange&quot;,\n  &#125; &#x3D; options;\n\n  const value &#x3D; props[valuePropName] as T;\n  &#x2F;&#x2F; options 默认情况， 如果 props 有 value 字段，则由父级接管控制 state\n  const isControlled &#x3D; props.hasOwnProperty(valuePropName);\n\n  const initialValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (isControlled) &#123;\n      &#x2F;&#x2F; 如果是受控，返回受控的value\n      return value;\n    &#125;\n    if (props.hasOwnProperty(defaultValuePropName)) &#123;\n      &#x2F;&#x2F; 非受控，props有默认值，返回默认值\n      return props[defaultValuePropName];\n    &#125;\n    return defaultValue;\n  &#125;, []);\n\n  const stateRef &#x3D; useRef(initialValue); &#x2F;&#x2F; 存的是父组件的值\n\n  if (isControlled) &#123;\n    stateRef.current &#x3D; value;\n  &#125;\n\n  const update &#x3D; useUpdate(); &#x2F;&#x2F; 上面了解到，该组件会强制react进行重渲染\n\n  &#x2F;&#x2F; options 默认情况，state变化时候，会触发onChange\n  function setState(v: SetStateAction&lt;T&gt;, ...args: any[]) &#123;\n    const r &#x3D; isFunction(v) ? v(stateRef.current) : v;\n\n    if (!isControlled) &#123;\n      &#x2F;&#x2F; 非受控，重渲染\n      stateRef.current &#x3D; r;\n      update();\n    &#125;\n    if (props[trigger]) &#123;\n      &#x2F;&#x2F; 有回调，执行回调\n      props[trigger](r, ...args);\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 返回存的值, 对setState进行缓存\n  return [stateRef.current, useMemoizedFn(setState)] as const;\n&#125;\n\nexport default useControllableValue;</code></pre>\n\n<h2 id=\"useLatest\"><a href=\"#useLatest\" class=\"headerlink\" title=\"useLatest\"></a>useLatest</h2><h2 id=\"闭包陷阱\"><a href=\"#闭包陷阱\" class=\"headerlink\" title=\"闭包陷阱\"></a>闭包陷阱</h2><p>将值放到 ref 上，并返回，可以防“闭包陷阱”，</p>\n<p><a href=\"https://juejin.cn/post/6972893133243695141\" target=\"_blank\" >见</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>useRef 每次 render 时都会返回同一个引用类型的对象，我们设置值和读取值都在这个对象上处理，这样就能获取到最新的 value 值了。<br>“闭包陷阱” 最大的问题就是在函数数内无法获取的最新的 state 的值，那 React 提供了哪些方法来解决呢？</p>\n<ul>\n<li>useRef 上面已有介绍</li>\n<li>useState 更新值时传入回调函数</li>\n</ul></blockquote>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useRef &#125; from &quot;react&quot;;\n\nfunction useLatest&lt;T&gt;(value: T) &#123;\n  const ref &#x3D; useRef(value);\n  ref.current &#x3D; value;\n\n  return ref;\n&#125;\n\nexport default useLatest;</code></pre>\n\n<h2 id=\"useMemoizedFn\"><a href=\"#useMemoizedFn\" class=\"headerlink\" title=\"useMemoizedFn\"></a>useMemoizedFn</h2><ul>\n<li>2+版本，为<code>usePersistFn</code>, 使用时候最好，将这些 hooks 放到一个文件中作为引用的过度文件。以防以后全局搜 <code>usePersistFn</code> 替换为 <code>useMemoizedFn</code></li>\n</ul>\n<p><code>useMemoizedFn</code> 如何实现 <code>useCallback</code> 效果，却不用使用第二参数 <code>deps</code> 呢？</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\ntype noop &#x3D; (this: any, ...args: any[]) &#x3D;&gt; any;\n\ntype PickFunction&lt;T extends noop&gt; &#x3D; (\n  this: ThisParameterType&lt;T&gt;,\n  ...args: Parameters&lt;T&gt;\n) &#x3D;&gt; ReturnType&lt;T&gt;;\n\nfunction useMemoizedFn&lt;T extends noop&gt;(fn: T) &#123;\n  const fnRef &#x3D; useRef&lt;T&gt;(fn);\n\n  &#x2F;&#x2F; why not write &#96;fnRef.current &#x3D; fn&#96;?\n  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;728\n  fnRef.current &#x3D; useMemo(() &#x3D;&gt; fn, [fn]); &#x2F;&#x2F; 为了兼容 react devtool\n\n  const memoizedFn &#x3D; useRef&lt;PickFunction&lt;T&gt;&gt;();\n\n  if (!memoizedFn.current) &#123;\n    &#x2F;&#x2F; 不存在，则重新生成函数， 这里用于缓存优化，但是函数执行的时候上下文中的参数是最新的，见下面模拟（出于这点，所以不需要deps）\n    memoizedFn.current &#x3D; function (this, ...args) &#123;\n      return fnRef.current.apply(this, args);\n    &#125;;\n  &#125;\n\n  return memoizedFn.current as T;\n&#125;\n\nexport default useMemoizedFn;</code></pre>\n\n<p><strong>模拟函数声明，函数内变量更新</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/202208241826880.webp\" />\n\n<h2 id=\"useToggle\"><a href=\"#useToggle\" class=\"headerlink\" title=\"useToggle\"></a>useToggle</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useMemo, useState &#125; from &quot;react&quot;;\n\nexport interface Actions&lt;T&gt; &#123;\n  setLeft: () &#x3D;&gt; void;\n  setRight: () &#x3D;&gt; void;\n  set: (value: T) &#x3D;&gt; void;\n  toggle: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; 1\nfunction useToggle&lt;T &#x3D; boolean&gt;(): [boolean, Actions&lt;T&gt;];\n&#x2F;&#x2F; 2\nfunction useToggle&lt;T&gt;(defaultValue: T): [T, Actions&lt;T&gt;];\n&#x2F;&#x2F; 3\nfunction useToggle&lt;T, U&gt;(\n  defaultValue: T,\n  reverseValue: U\n): [T | U, Actions&lt;T | U&gt;];\n&#x2F;&#x2F; 4\nfunction useToggle&lt;D, R&gt;(\n  defaultValue: D &#x3D; false as unknown as D,\n  reverseValue?: R\n) &#123;\n  &#x2F;&#x2F; 可以理解为缓存吧\n  const [state, setState] &#x3D; useState&lt;D | R&gt;(defaultValue);\n\n  const actions &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 最初的相反值 &#x3D; 设置的相反值 or 是初始值的取反\n    const reverseValueOrigin &#x3D; (\n      reverseValue &#x3D;&#x3D;&#x3D; undefined ? !defaultValue : reverseValue\n    ) as D | R;\n    &#x2F;&#x2F; 默认值取反\n    const toggle &#x3D; () &#x3D;&gt;\n      setState((s) &#x3D;&gt; (s &#x3D;&#x3D;&#x3D; defaultValue ? reverseValueOrigin : defaultValue));\n    &#x2F;&#x2F; 设置值\n    const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);\n    &#x2F;&#x2F; 设置初始值\n    const setLeft &#x3D; () &#x3D;&gt; setState(defaultValue);\n    &#x2F;&#x2F; 设置为相反值\n    const setRight &#x3D; () &#x3D;&gt; setState(reverseValueOrigin);\n    &#x2F;&#x2F; 这就有点意思了，左边右边，反过来，再翻过去，刚好 toggle\n    return &#123;\n      toggle,\n      set,\n      setLeft,\n      setRight,\n    &#125;;\n    &#x2F;&#x2F; useToggle ignore value change\n    &#x2F;&#x2F; &#125;, [defaultValue, reverseValue]);\n  &#125;, []);\n\n  return [state, actions &#x2F;**这里是对象，却用了s结尾，乍一看还以为数组 *&#x2F;];\n&#125;\n\nexport default useToggle;</code></pre>\n\n<h2 id=\"useBoolean\"><a href=\"#useBoolean\" class=\"headerlink\" title=\"useBoolean\"></a>useBoolean</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useMemo &#125; from &quot;react&quot;;\nimport useToggle from &quot;..&#x2F;useToggle&quot;;\n\n&#x2F;&#x2F; 这里与 useToggle很像\nexport interface Actions &#123;\n  setTrue: () &#x3D;&gt; void;\n  setFalse: () &#x3D;&gt; void;\n  set: (value: boolean) &#x3D;&gt; void;\n  toggle: () &#x3D;&gt; void;\n&#125;\n\n&#x2F;&#x2F; 主要用toggle整了点事，然后暴露更具有语义话的api\nexport default function useBoolean(defaultValue &#x3D; false): [boolean, Actions] &#123;\n  const [state, &#123; toggle, set &#125;] &#x3D; useToggle(defaultValue);\n\n  const actions: Actions &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);\n    const setTrue &#x3D; () &#x3D;&gt; set(true);\n    const setFalse &#x3D; () &#x3D;&gt; set(false);\n    return &#123;\n      toggle,\n      set: (v) &#x3D;&gt; set(!!v),\n      setTrue,\n      setFalse,\n    &#125;;\n  &#125;, []);\n\n  return [state, actions];\n&#125;</code></pre>\n\n<h2 id=\"useMount\"><a href=\"#useMount\" class=\"headerlink\" title=\"useMount\"></a>useMount</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\nconst useMount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 删减\n  useEffect(() &#x3D;&gt; &#123;\n    fn?.();\n  &#125;, []);\n&#125;;\n\nexport default useMount;</code></pre>\n\n<h2 id=\"useUnmount\"><a href=\"#useUnmount\" class=\"headerlink\" title=\"useUnmount\"></a>useUnmount</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\nconst useUnmount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 删减\n  const fnRef &#x3D; useLatest(fn);\n\n  useEffect(\n    () &#x3D;&gt; () &#x3D;&gt; &#123;\n      fnRef.current();\n    &#125;,\n    []\n  );\n&#125;;\n\nexport default useUnmount;</code></pre>\n\n<h2 id=\"useUnmountedRef\"><a href=\"#useUnmountedRef\" class=\"headerlink\" title=\"useUnmountedRef\"></a>useUnmountedRef</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>获取当前组件是否已经卸载的 Hook。</p></blockquote>\n<p>什么业务场景会使用？？</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\nconst useUnmountedRef &#x3D; () &#x3D;&gt; &#123;\n  const unmountedRef &#x3D; useRef(false); &#x2F;&#x2F; 默认没有卸载\n  useEffect(() &#x3D;&gt; &#123;\n    unmountedRef.current &#x3D; false; &#x2F;&#x2F; 挂载\n    return () &#x3D;&gt; &#123;\n      unmountedRef.current &#x3D; true; &#x2F;&#x2F; 卸载\n    &#125;;\n  &#125;, []);\n  return unmountedRef;\n&#125;;\n\nexport default useUnmountedRef;</code></pre>\n\n<h2 id=\"useUpdateEffect-有依赖项\"><a href=\"#useUpdateEffect-有依赖项\" class=\"headerlink\" title=\"useUpdateEffect (有依赖项)\"></a>useUpdateEffect (有依赖项)</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>useUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。</p></blockquote>\n<p><span style=\"color: red\">如何实现忽略首次执行的</span></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport &#123; createUpdateEffect &#125; from &quot;..&#x2F;createUpdateEffect&quot;; &#x2F;&#x2F; 见下面源码\n\nexport default createUpdateEffect(useEffect);</code></pre>\n\n<h2 id=\"createUpdateEffect\"><a href=\"#createUpdateEffect\" class=\"headerlink\" title=\"createUpdateEffect\"></a>createUpdateEffect</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useRef &#125; from &quot;react&quot;;\nimport type &#123; useEffect, useLayoutEffect &#125; from &quot;react&quot;;\n\ntype EffectHookType &#x3D; typeof useEffect | typeof useLayoutEffect;\n\n&#x2F;&#x2F; export const createUpdateEffect: (hook: EffectHookType) &#x3D;&gt; EffectHookType &#x3D; (hook) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;\nexport const createUpdateEffect &#x3D; (hook &#x2F;** useEffect *&#x2F;) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 柯里化\n  const isMounted &#x3D; useRef(false);\n\n  &#x2F;&#x2F; for react-refresh react刷新时候执行卸载\n  hook(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F;卸载\n    return () &#x3D;&gt; &#123;\n      isMounted.current &#x3D; false;\n    &#125;;\n  &#125;, []);\n\n  hook(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 挂在\n    if (!isMounted.current) &#123;\n      &#x2F;&#x2F; 非第一次， isMounted.current &#x3D; true , 此时走  effect()\n      isMounted.current &#x3D; true;\n    &#125; else &#123;\n      return effect();\n    &#125;\n  &#125;, deps);\n&#125;;\n\nexport default createUpdateEffect;</code></pre>\n\n<h2 id=\"useHistoryTravel\"><a href=\"#useHistoryTravel\" class=\"headerlink\" title=\"useHistoryTravel\"></a>useHistoryTravel</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>管理状态历史变化记录，方便在历史记录中前进与后退。</p></blockquote>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useRef, useState &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport &#123; isNumber &#125; from &quot;..&#x2F;utils&quot;;\n\ninterface IData&lt;T&gt; &#123;\n  present?: T;\n  past: T[];\n  future: T[];\n&#125;\n\nconst dumpIndex &#x3D; &lt;T&gt;(step: number, arr: T[]) &#x3D;&gt; &#123;\n  let index &#x3D;\n    step &gt; 0\n      ? step - 1 &#x2F;&#x2F; move forward\n      : arr.length + step; &#x2F;&#x2F; move backward\n  if (index &gt;&#x3D; arr.length - 1) &#123;\n    index &#x3D; arr.length - 1;\n  &#125;\n  if (index &lt; 0) &#123;\n    index &#x3D; 0;\n  &#125;\n  return index;\n&#125;;\n\nconst split &#x3D; &lt;T&gt;(step: number, targetArr: T[]) &#x3D;&gt; &#123;\n  const index &#x3D; dumpIndex(step, targetArr);\n  return &#123;\n    _current: targetArr[index],\n    _before: targetArr.slice(0, index),\n    _after: targetArr.slice(index + 1),\n  &#125;;\n&#125;;\n\nexport default function useHistoryTravel&lt;T&gt;(initialValue?: T) &#123;\n  const [history, setHistory] &#x3D; useState&lt;IData&lt;T | undefined&gt;&gt;(&#123;\n    present: initialValue, &#x2F;&#x2F; 当前\n    past: [], &#x2F;&#x2F; 历史记录\n    future: [], &#x2F;&#x2F; 未来记录\n  &#125;);\n\n  const &#123; present, past, future &#125; &#x3D; history;\n\n  const initialValueRef &#x3D; useRef(initialValue);\n\n  const reset &#x3D; (...params: any[]) &#x3D;&gt; &#123;\n    const _initial &#x3D; params.length &gt; 0 ? params[0] : initialValueRef.current;\n    initialValueRef.current &#x3D; _initial;\n\n    setHistory(&#123;\n      present: _initial,\n      future: [],\n      past: [],\n    &#125;);\n  &#125;;\n\n  const updateValue &#x3D; (val: T) &#x3D;&gt; &#123;\n    setHistory(&#123;\n      present: val,\n      future: [],\n      past: [...past, present],\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 向前\n  const _forward &#x3D; (step: number &#x3D; 1) &#x3D;&gt; &#123;\n    if (future.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n    const &#123; _before, _current, _after &#125; &#x3D; split(step, future);\n    setHistory(&#123;\n      past: [...past, present, ..._before],\n      present: _current,\n      future: _after,\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 向后\n  const _backward &#x3D; (step: number &#x3D; -1) &#x3D;&gt; &#123;\n    if (past.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n\n    const &#123; _before, _current, _after &#125; &#x3D; split(step, past);\n    setHistory(&#123;\n      past: _before,\n      present: _current,\n      future: [..._after, present, ...future],\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 可进，可退，可不动\n  const go &#x3D; (step: number) &#x3D;&gt; &#123;\n    const stepNum &#x3D; isNumber(step) ? step : Number(step);\n    if (stepNum &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n    if (stepNum &gt; 0) &#123;\n      return _forward(stepNum);\n    &#125;\n    _backward(stepNum);\n  &#125;;\n\n  return &#123;\n    value: present, &#x2F;&#x2F; 当前\n    backLength: past.length, &#x2F;&#x2F; 可后退长度\n    forwardLength: future.length, &#x2F;&#x2F; 可前进长度\n    setValue: useMemoizedFn(updateValue), &#x2F;&#x2F; 跳转到哪个记录\n    go: useMemoizedFn(go), &#x2F;&#x2F; 回退到哪个\n    back: useMemoizedFn(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 回退一个\n      go(-1);\n    &#125;),\n    forward: useMemoizedFn(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 前进一个\n      go(1);\n    &#125;),\n    reset: useMemoizedFn(reset), &#x2F;&#x2F; 重置\n  &#125;;\n&#125;</code></pre>\n\n<h2 id=\"useInfiniteScroll\"><a href=\"#useInfiniteScroll\" class=\"headerlink\" title=\"useInfiniteScroll\"></a>useInfiniteScroll</h2><p>useInfiniteScroll 封装了常见的无限滚动逻辑。</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const &#123; data, loading, loadingMore, loadMore &#125; &#x3D; useInfiniteScroll(service);</code></pre>\n\n<p>useInfiniteScroll 的第一个参数 service 是一个异步函数，对这个函数的入参和出参有如下 <span style=\"color: red\">约定</span>：</p>\n<p>service 返回的数据必须包含 list 数组，类型为 <code>&#123; list: any[], ...rest &#125;</code><br>service 的入参为整合后的最新 data<br>假如第一次请求返回数据为<code> &#123; list: [1, 2, 3], nextId: 4 &#125;</code>, 第二次返回的数据为<code> &#123; list: [4, 5, 6], nextId: 7 &#125;</code>, 则我们会自动合并 list，整合后的的 data 为 <code>&#123; list: [1, 2, 3, 4, 5, 6], nextId: 7 &#125;</code>。</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useMemo, useState &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;; &#x2F;&#x2F; 简化版useCallback\nimport useRequest from &quot;..&#x2F;useRequest&quot;; &#x2F;&#x2F; 请求封装的hook\n&#x2F;&#x2F; useUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。\nimport useUpdateEffect from &quot;..&#x2F;useUpdateEffect&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getClientHeight, getScrollHeight, getScrollTop &#125; from &quot;..&#x2F;utils&#x2F;rect&quot;;\nimport type &#123; Data, InfiniteScrollOptions, Service &#125; from &quot;.&#x2F;types&quot;;\n\nconst useInfiniteScroll &#x3D; &lt;TData extends Data&gt;(\n  service: Service&lt;TData&gt;,\n  options: InfiniteScrollOptions&lt;TData&gt; &#x3D; &#123;&#125;\n) &#x3D;&gt; &#123;\n  const &#123;\n    target,\n    isNoMore,\n    threshold &#x3D; 100,\n    reloadDeps &#x3D; [],\n    manual,\n    onBefore,\n    onSuccess,\n    onError,\n    onFinally,\n  &#125; &#x3D; options;\n\n  const [finalData, setFinalData] &#x3D; useState&lt;TData&gt;();\n  const [loadingMore, setLoadingMore] &#x3D; useState(false);\n\n  const noMore &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (!isNoMore) return false;\n    return isNoMore(finalData);\n  &#125;, [finalData]);\n\n  const &#123; loading, run, runAsync, cancel &#125; &#x3D; useRequest(\n    async (lastData?: TData) &#x3D;&gt; &#123;\n      const currentData &#x3D; await service(lastData);\n      if (!lastData) &#123;\n        setFinalData(currentData);\n      &#125; else &#123;\n        setFinalData(&#123;\n          ...currentData,\n          &#x2F;&#x2F; @ts-ignore\n          list: [...lastData.list, ...currentData.list],\n        &#125;);\n      &#125;\n      return currentData;\n    &#125;,\n    &#123;\n      manual,\n      onFinally: (_, d, e) &#x3D;&gt; &#123;\n        setLoadingMore(false);\n        onFinally?.(d, e);\n      &#125;,\n      onBefore: () &#x3D;&gt; onBefore?.(),\n      onSuccess: (d) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n          &#x2F;&#x2F; eslint-disable-next-line @typescript-eslint&#x2F;no-use-before-define\n          scrollMethod();\n        &#125;);\n        onSuccess?.(d);\n      &#125;,\n      onError: (e) &#x3D;&gt; onError?.(e),\n    &#125;\n  );\n\n  const loadMore &#x3D; () &#x3D;&gt; &#123;\n    if (noMore) return;\n    setLoadingMore(true);\n    run(finalData);\n  &#125;;\n\n  const loadMoreAsync &#x3D; () &#x3D;&gt; &#123;\n    if (noMore) return Promise.reject();\n    setLoadingMore(true);\n    return runAsync(finalData);\n  &#125;;\n\n  const reload &#x3D; () &#x3D;&gt; run();\n  const reloadAsync &#x3D; () &#x3D;&gt; runAsync();\n\n  &#x2F;&#x2F; scrollMethod会尝试去检测是否满足加载条件\n  const scrollMethod &#x3D; () &#x3D;&gt; &#123;\n    const el &#x3D; getTargetElement(target);\n    if (!el) &#123;\n      return;\n    &#125;\n\n    const scrollTop &#x3D; getScrollTop(el);\n    const scrollHeight &#x3D; getScrollHeight(el);\n    const clientHeight &#x3D; getClientHeight(el);\n\n    if (scrollHeight - scrollTop &lt;&#x3D; clientHeight + threshold) &#123;\n      loadMore();\n    &#125;\n  &#125;;\n  &#x2F;&#x2F; 监听滚动，加载中的会被拦掉，\n  useEventListener(\n    &quot;scroll&quot;,\n    () &#x3D;&gt; &#123;\n      if (loading || loadingMore) &#123;\n        return;\n      &#125;\n      scrollMethod();\n    &#125;,\n    &#123; target &#125;\n  );\n\n  useUpdateEffect(() &#x3D;&gt; &#123;\n    run();\n  &#125;, [...reloadDeps]);\n\n  return &#123;\n    &#x2F;&#x2F; 数据\n    data: finalData,\n    loading: !loadingMore &amp;&amp; loading,\n    loadingMore,\n    noMore,\n    &#x2F;&#x2F; 一些方法\n    loadMore: useMemoizedFn(loadMore),\n    loadMoreAsync: useMemoizedFn(loadMoreAsync),\n    &#x2F;&#x2F; 这两个声明的函数直接返回\n    &#x2F;&#x2F; const reload &#x3D; () &#x3D;&gt; run();\n    &#x2F;&#x2F; const reloadAsync &#x3D; () &#x3D;&gt; runAsync();\n    reload: useMemoizedFn(reload),\n    reloadAsync: useMemoizedFn(reloadAsync),\n    mutate &#x2F;**数据突变 *&#x2F;: setFinalData,\n    cancel,\n  &#125;;\n&#125;;\n\nexport default useInfiniteScroll;</code></pre>\n\n<h3 id=\"getTargetElement\"><a href=\"#getTargetElement\" class=\"headerlink\" title=\"getTargetElement\"></a>getTargetElement</h3><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import type &#123; MutableRefObject &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;.&#x2F;index&quot;;\nimport isBrowser from &quot;.&#x2F;isBrowser&quot;;\n\ntype TargetValue&lt;T&gt; &#x3D; T | undefined | null;\n\ntype TargetType &#x3D; HTMLElement | Element | Window | Document;\n\nexport type BasicTarget&lt;T extends TargetType &#x3D; Element&gt; &#x3D;\n  | (() &#x3D;&gt; TargetValue&lt;T&gt;) &#x2F;&#x2F; 函数\n  | TargetValue&lt;T&gt; &#x2F;&#x2F; 直接dom\n  | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;; &#x2F;&#x2F; ref\n\nexport function getTargetElement&lt;T extends TargetType&gt;(\n  target: BasicTarget&lt;T&gt;,\n  defaultElement?: T\n) &#123;\n  &#x2F;&#x2F; 服务端渲染情况\n  if (!isBrowser) &#123;\n    return undefined;\n  &#125;\n  &#x2F;&#x2F; 假设，一定存在\n  if (!target) &#123;\n    return defaultElement;\n  &#125;\n\n  let targetElement: TargetValue&lt;T&gt;;\n  &#x2F;&#x2F; 函数\n  if (isFunction(target)) &#123;\n    targetElement &#x3D; target();\n    &#x2F;&#x2F; ref\n  &#125; else if (&quot;current&quot; in target) &#123;\n    targetElement &#x3D; target.current;\n    &#x2F;&#x2F; 直接dom\n  &#125; else &#123;\n    targetElement &#x3D; target;\n  &#125;\n\n  return targetElement;\n&#125;</code></pre>\n\n<h3 id=\"getClientHeight-getScrollHeight-getScrollTop\"><a href=\"#getClientHeight-getScrollHeight-getScrollTop\" class=\"headerlink\" title=\"getClientHeight, getScrollHeight, getScrollTop\"></a>getClientHeight, getScrollHeight, getScrollTop</h3><p>使用<code>Math.max</code>，对 rect 的计算进行兼容性处理</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const getScrollTop &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  if (el &#x3D;&#x3D;&#x3D; document || el &#x3D;&#x3D;&#x3D; document.body) &#123;\n    &#x2F;&#x2F; 处理浏览器兼容性\n    &#x2F;&#x2F; IE6&#x2F;7&#x2F;8：\n    &#x2F;&#x2F; 可以使用 document.documentElement.scrollTop；\n    &#x2F;&#x2F; IE9及以上：\n    &#x2F;&#x2F; 可以使用window.pageYOffset或者document.documentElement.scrollTop\n    &#x2F;&#x2F; Safari:\n    &#x2F;&#x2F; safari： window.pageYOffset 与document.body.scrollTop都可以；\n    &#x2F;&#x2F; Firefox:\n    &#x2F;&#x2F; 火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset 或者 document.documentElement.scrollTop ；\n    &#x2F;&#x2F; Chrome：\n    &#x2F;&#x2F; 谷歌浏览器只认识document.body.scrollTop;\n    return Math.max(\n      window.pageYOffset,\n      document.documentElement.scrollTop,\n      document.body.scrollTop\n    );\n  &#125;\n  return (el as Element).scrollTop;\n&#125;;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202208301756200.webp\" />\n\n<p><a href=\"https://segmentfault.com/a/1190000008065472\" target=\"_blank\" >JS 基础篇– body.scrollTop 与 documentElement.scrollTop</a></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const getScrollHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  return (\n    (el as Element).scrollHeight ||\n    Math.max(document.documentElement.scrollHeight, document.body.scrollHeight)\n  );\n&#125;;\n\nconst getClientHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  return (\n    (el as Element).clientHeight ||\n    Math.max(document.documentElement.clientHeight, document.body.clientHeight)\n  );\n&#125;;\n\nexport &#123; getScrollTop, getScrollHeight, getClientHeight &#125;;</code></pre>\n\n<h2 id=\"useEventListener\"><a href=\"#useEventListener\" class=\"headerlink\" title=\"useEventListener\"></a>useEventListener</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\ntype noop &#x3D; (...p: any) &#x3D;&gt; void;\n\nexport type Target &#x3D; BasicTarget&lt;HTMLElement | Element | Window | Document&gt;;\n\ntype Options&lt;T extends Target &#x3D; Target&gt; &#x3D; &#123;\n  target?: T;\n  capture?: boolean;\n  once?: boolean;\n  passive?: boolean;\n&#125;;\n\nfunction useEventListener&lt;K extends keyof HTMLElementEventMap&gt;(\n  eventName: K,\n  handler: (ev: HTMLElementEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;HTMLElement&gt;\n): void;\nfunction useEventListener&lt;K extends keyof ElementEventMap&gt;(\n  eventName: K,\n  handler: (ev: ElementEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Element&gt;\n): void;\nfunction useEventListener&lt;K extends keyof DocumentEventMap&gt;(\n  eventName: K,\n  handler: (ev: DocumentEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Document&gt;\n): void;\nfunction useEventListener&lt;K extends keyof WindowEventMap&gt;(\n  eventName: K,\n  handler: (ev: WindowEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Window&gt;\n): void;\nfunction useEventListener(\n  eventName: string,\n  handler: noop,\n  options: Options\n): void;\n\nfunction useEventListener(\n  eventName: string,\n  handler: noop,\n  options: Options &#x3D; &#123;&#125;\n) &#123;\n  const handlerRef &#x3D; useLatest(handler);\n\n  useEffectWithTarget(\n    &#x2F;&#x2F; 做了缓存\n    &#x2F;&#x2F; effect\n    () &#x3D;&gt; &#123;\n      const targetElement &#x3D; getTargetElement(options.target, window);\n      if (!targetElement?.addEventListener) &#123;\n        return;\n      &#125;\n\n      const eventListener &#x3D; (event: Event) &#x3D;&gt; &#123;\n        return handlerRef.current(event);\n      &#125;;\n\n      targetElement.addEventListener(eventName, eventListener, &#123;\n        capture: options.capture,\n        once: options.once,\n        passive: options.passive,\n      &#125;);\n\n      return () &#x3D;&gt; &#123;\n        targetElement.removeEventListener(eventName, eventListener, &#123;\n          capture: options.capture,\n        &#125;);\n      &#125;;\n    &#125;,\n    &#x2F;&#x2F; deps 依赖项\n    [eventName, options.capture, options.once, options.passive],\n    &#x2F;&#x2F; target\n    options.target\n  );\n&#125;\n\nexport default useEventListener;</code></pre>\n\n<h2 id=\"useEffectWithTarget\"><a href=\"#useEffectWithTarget\" class=\"headerlink\" title=\"useEffectWithTarget\"></a>useEffectWithTarget</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport createEffectWithTarget from &quot;.&#x2F;createEffectWithTarget&quot;;\n&#x2F;&#x2F; createEffectWithTarget将useEffect进行包裹\nconst useEffectWithTarget &#x3D; createEffectWithTarget(useEffect);\n\nexport default useEffectWithTarget;</code></pre>\n\n<h2 id=\"createEffectWithTarget\"><a href=\"#createEffectWithTarget\" class=\"headerlink\" title=\"createEffectWithTarget\"></a>createEffectWithTarget</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import type &#123;\n  DependencyList,\n  EffectCallback,\n  useEffect,\n  useLayoutEffect,\n&#125; from &quot;react&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\nimport depsAreSame from &quot;.&#x2F;depsAreSame&quot;;\nimport type &#123; BasicTarget &#125; from &quot;.&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;.&#x2F;domTarget&quot;;\n\nconst createEffectWithTarget &#x3D; (\n  useEffectType: typeof useEffect | typeof useLayoutEffect\n) &#x3D;&gt; &#123;\n  &#x2F;**\n   *\n   * @param effect\n   * @param deps\n   * @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom\n   *&#x2F;\n  const useEffectWithTarget &#x3D; (\n    effect: EffectCallback,\n    deps: DependencyList,\n    target: BasicTarget&lt;any&gt; | BasicTarget&lt;any&gt;[]\n  ) &#x3D;&gt; &#123;\n    const hasInitRef &#x3D; useRef(false);\n\n    const lastElementRef &#x3D; useRef&lt;(Element | null)[]&gt;([]);\n    const lastDepsRef &#x3D; useRef&lt;DependencyList&gt;([]);\n\n    const unLoadRef &#x3D; useRef&lt;any&gt;();\n    &#x2F;&#x2F; 类型 useEffectType: typeof useEffect | typeof useLayoutEffect\n    useEffectType(() &#x3D;&gt; &#123;\n      const targets &#x3D; Array.isArray(target) ? target : [target];\n      const els &#x3D; targets.map((item) &#x3D;&gt; getTargetElement(item));\n\n      &#x2F;&#x2F; init run\n      if (!hasInitRef.current) &#123;\n        hasInitRef.current &#x3D; true;\n        lastElementRef.current &#x3D; els;\n        lastDepsRef.current &#x3D; deps;\n\n        unLoadRef.current &#x3D; effect(); &#x2F;&#x2F; 执行结果\n        return;\n      &#125;\n      &#x2F;&#x2F; 如上文注释： @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom\n      &#x2F;&#x2F; 存在不等情况会执行赋值\n      if (\n        els.length !&#x3D;&#x3D; lastElementRef.current.length ||\n        !depsAreSame(els, lastElementRef.current) ||\n        !depsAreSame(deps, lastDepsRef.current)\n      ) &#123;\n        unLoadRef.current?.();  &#x2F;&#x2F; 执行\n\n        lastElementRef.current &#x3D; els;\n        lastDepsRef.current &#x3D; deps;\n        unLoadRef.current &#x3D; effect();\n      &#125;\n    &#125;);\n    &#x2F;&#x2F; 卸载\n    useUnmount(() &#x3D;&gt; &#123;\n      unLoadRef.current?.();\n      &#x2F;&#x2F; for react-refresh\n      hasInitRef.current &#x3D; false;\n    &#125;);\n  &#125;;\n\n  return useEffectWithTarget;\n&#125;;\n\nexport default createEffectWithTarget;</code></pre>\n\n<h2 id=\"useWhyDidYouUpdate\"><a href=\"#useWhyDidYouUpdate\" class=\"headerlink\" title=\"useWhyDidYouUpdate\"></a>useWhyDidYouUpdate</h2><p><a href=\"https://ahooks.js.org/zh-CN/hooks/use-why-did-you-update#params\" target=\"_blank\" >见</a></p>\n<p>原理：useEffect 在组件更新时候会执行， 将之前的 props 存在 ref 上，之后会将所有的 key 比较，找到变更的 key 的 changedProps</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\nexport type IProps &#x3D; Record&lt;string, any&gt;;\n\nexport default function useWhyDidYouUpdate(\n  componentName: string,\n  props: IProps\n) &#123;\n  const prevProps &#x3D; useRef&lt;IProps&gt;(&#123;&#125;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (prevProps.current) &#123;\n      const allKeys &#x3D; Object.keys(&#123; ...prevProps.current, ...props &#125;);\n      const changedProps: IProps &#x3D; &#123;&#125;;\n\n      allKeys.forEach((key) &#x3D;&gt; &#123;\n        if (!Object.is(prevProps.current[key], props[key])) &#123;\n          changedProps[key] &#x3D; &#123;\n            from: prevProps.current[key],\n            to: props[key],\n          &#125;;\n        &#125;\n      &#125;);\n\n      if (Object.keys(changedProps).length) &#123;\n        console.log(&quot;[why-did-you-update]&quot;, componentName, changedProps);\n      &#125;\n    &#125;\n\n    prevProps.current &#x3D; props;\n  &#125;);\n&#125;</code></pre>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>hooks 设计目标导向，拿到哪些值 和 api</li>\n</ul>\n","text":"useUpdate useUpdate 会返回一个函数，调用该函数会强制组件重新渲染。 import &#123; useCallback, useState &#125; from &quot;react&quot;; const useUpdate &#x3D; () &#x...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"源码","slug":"源码","count":2,"path":"api/categories/源码.json"}],"tags":[{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUpdate\"><span class=\"toc-text\">useUpdate</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useControllableValue\"><span class=\"toc-text\">useControllableValue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useLatest\"><span class=\"toc-text\">useLatest</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1\"><span class=\"toc-text\">闭包陷阱</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMemoizedFn\"><span class=\"toc-text\">useMemoizedFn</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useToggle\"><span class=\"toc-text\">useToggle</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useBoolean\"><span class=\"toc-text\">useBoolean</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMount\"><span class=\"toc-text\">useMount</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUnmount\"><span class=\"toc-text\">useUnmount</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUnmountedRef\"><span class=\"toc-text\">useUnmountedRef</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUpdateEffect-%E6%9C%89%E4%BE%9D%E8%B5%96%E9%A1%B9\"><span class=\"toc-text\">useUpdateEffect (有依赖项)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createUpdateEffect\"><span class=\"toc-text\">createUpdateEffect</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useHistoryTravel\"><span class=\"toc-text\">useHistoryTravel</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useInfiniteScroll\"><span class=\"toc-text\">useInfiniteScroll</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#getTargetElement\"><span class=\"toc-text\">getTargetElement</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#getClientHeight-getScrollHeight-getScrollTop\"><span class=\"toc-text\">getClientHeight, getScrollHeight, getScrollTop</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useEventListener\"><span class=\"toc-text\">useEventListener</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useEffectWithTarget\"><span class=\"toc-text\">useEffectWithTarget</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createEffectWithTarget\"><span class=\"toc-text\">createEffectWithTarget</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useWhyDidYouUpdate\"><span class=\"toc-text\">useWhyDidYouUpdate</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"待办事项","uid":"c370dd6ecfc84fe9fdfa77b1a6f29341","slug":"todo","date":"2022-12-14T03:59:59.000Z","updated":"2022-08-04T12:35:49.688Z","comments":true,"path":"api/articles/todo.json","keywords":null,"cover":[],"text":"特殊记忆 &#x2F;&#x2F; 1. headless-recorder &#x2F;&#x2F; 2. lightHouse https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangdou369098655&#x2F;article&#x2F;de...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Todo","slug":"Todo","count":1,"path":"api/categories/Todo.json"}],"tags":[{"name":"Todo","slug":"Todo","count":1,"path":"api/tags/Todo.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"有过期机制的localStorage","uid":"b204c24ab6e396e5de06d4bc0adf7d2a","slug":"2022-08-24expirestorage","date":"2022-08-24T08:49:06.000Z","updated":"2022-08-24T13:57:29.581Z","comments":true,"path":"api/articles/2022-08-24expirestorage.json","keywords":null,"cover":[],"text":"场景对于一些数据不经常更新的数据，保持一定时间的新鲜的时候可以用于缓存 localStorage见原文 把原文代码改了下，主要对JSON.parse进行 fixed Storage.prototype.setStorageWithAge &#x3D; (key, value, e...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"存储","slug":"存储","count":1,"path":"api/categories/存储.json"}],"tags":[{"name":"存储","slug":"存储","count":1,"path":"api/tags/存储.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}