{"title":"ahooks源码","uid":"847fdfbf845470be05a2ff27391aae0c","slug":"2022-08-24ahooks","date":"2022-08-24T09:16:49.000Z","updated":"2022-09-16T13:54:56.315Z","comments":true,"path":"api/articles/2022-08-24ahooks.json","keywords":null,"cover":"https://ahooks.js.org/logo.svg","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随意看看，了解下，无固定顺序，全凭兴趣</p>\n<h2 id=\"useUpdate\"><a href=\"#useUpdate\" class=\"headerlink\" title=\"useUpdate\"></a>useUpdate</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>useUpdate 会返回一个函数，调用该函数会强制组件重新渲染。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useCallback, useState &#125; from &quot;react&quot;;\n\nconst useUpdate &#x3D; () &#x3D;&gt; &#123;\n  const [, setState] &#x3D; useState(&#123;&#125;);\n\n  return useCallback(() &#x3D;&gt; setState(&#123;&#125;), []); &#x2F;&#x2F; setState(&#123;&#125;) 每次置为新的对象，即使页面没有用到该useState的返回值，也会更新\n&#125;;\n\nexport default useUpdate;</code></pre>\n\n<h2 id=\"useControllableValue\"><a href=\"#useControllableValue\" class=\"headerlink\" title=\"useControllableValue\"></a>useControllableValue</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在某些组件开发时，我们需要组件的状态既可以自己管理，也可以被外部控制，useControllableValue 就是帮你管理这种状态的 Hook。</p></blockquote>\n<p>简单来说，默认情况下,外层组件有 value, onChange 就用外层的，外层没有，自己处理</p>\n<img src=\"http://t-blog-images.aijs.top/img/202208241724077.webp\" />\n\n<p>虽然是复用，可这里这么写有点奇怪</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport type &#123; SetStateAction &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport useUpdate from &quot;..&#x2F;useUpdate&quot;;\n\nexport interface Options&lt;T&gt; &#123;\n  defaultValue?: T;\n  defaultValuePropName?: string;\n  valuePropName?: string;\n  trigger?: string;\n&#125;\n\nexport type Props &#x3D; Record&lt;string, any&gt;;\n\nexport interface StandardProps&lt;T&gt; &#123;\n  value: T;\n  defaultValue?: T;\n  onChange: (val: T) &#x3D;&gt; void;\n&#125;\n\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props: StandardProps&lt;T&gt;\n): [T, (v: SetStateAction&lt;T&gt;) &#x3D;&gt; void];\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props?: Props,\n  options?: Options&lt;T&gt;\n): [T, (v: SetStateAction&lt;T&gt;, ...args: any[]) &#x3D;&gt; void];\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props: Props &#x3D; &#123;&#125;,\n  options: Options&lt;T&gt; &#x3D; &#123;&#125;\n) &#123;\n  &#x2F;&#x2F; 这里一堆，是函数重写？\n  const &#123;\n    defaultValue,\n    defaultValuePropName &#x3D; &quot;defaultValue&quot;,\n    valuePropName &#x3D; &quot;value&quot;,\n    trigger &#x3D; &quot;onChange&quot;,\n  &#125; &#x3D; options;\n\n  const value &#x3D; props[valuePropName] as T;\n  &#x2F;&#x2F; options 默认情况， 如果 props 有 value 字段，则由父级接管控制 state\n  const isControlled &#x3D; props.hasOwnProperty(valuePropName);\n\n  const initialValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (isControlled) &#123;\n      &#x2F;&#x2F; 如果是受控，返回受控的value\n      return value;\n    &#125;\n    if (props.hasOwnProperty(defaultValuePropName)) &#123;\n      &#x2F;&#x2F; 非受控，props有默认值，返回默认值\n      return props[defaultValuePropName];\n    &#125;\n    return defaultValue;\n  &#125;, []);\n\n  const stateRef &#x3D; useRef(initialValue); &#x2F;&#x2F; 存的是父组件的值\n\n  if (isControlled) &#123;\n    stateRef.current &#x3D; value;\n  &#125;\n\n  const update &#x3D; useUpdate(); &#x2F;&#x2F; 上面了解到，该组件会强制react进行重渲染\n\n  &#x2F;&#x2F; options 默认情况，state变化时候，会触发onChange\n  function setState(v: SetStateAction&lt;T&gt;, ...args: any[]) &#123;\n    const r &#x3D; isFunction(v) ? v(stateRef.current) : v;\n\n    if (!isControlled) &#123;\n      &#x2F;&#x2F; 非受控，重渲染\n      stateRef.current &#x3D; r;\n      update();\n    &#125;\n    if (props[trigger]) &#123;\n      &#x2F;&#x2F; 有回调，执行回调\n      props[trigger](r, ...args);\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 返回存的值, 对setState进行缓存\n  return [stateRef.current, useMemoizedFn(setState)] as const;\n&#125;\n\nexport default useControllableValue;</code></pre>\n\n<h2 id=\"useLatest\"><a href=\"#useLatest\" class=\"headerlink\" title=\"useLatest\"></a>useLatest</h2><h2 id=\"闭包陷阱\"><a href=\"#闭包陷阱\" class=\"headerlink\" title=\"闭包陷阱\"></a>闭包陷阱</h2><p>将值放到 ref 上，并返回，可以防“闭包陷阱”，</p>\n<p><a href=\"https://juejin.cn/post/6972893133243695141\" target=\"_blank\" >见</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>useRef 每次 render 时都会返回同一个引用类型的对象，我们设置值和读取值都在这个对象上处理，这样就能获取到最新的 value 值了。<br>“闭包陷阱” 最大的问题就是在函数数内无法获取的最新的 state 的值，那 React 提供了哪些方法来解决呢？</p>\n<ul>\n<li>useRef 上面已有介绍</li>\n<li>useState 更新值时传入回调函数</li>\n</ul></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useRef &#125; from &quot;react&quot;;\n\nfunction useLatest&lt;T&gt;(value: T) &#123;\n  const ref &#x3D; useRef(value);\n  ref.current &#x3D; value;\n\n  return ref;\n&#125;\n\nexport default useLatest;</code></pre>\n\n<h2 id=\"useMemoizedFn\"><a href=\"#useMemoizedFn\" class=\"headerlink\" title=\"useMemoizedFn\"></a>useMemoizedFn</h2><ul>\n<li>2+版本，为<code>usePersistFn</code>, 使用时候最好，将这些 hooks 放到一个文件中作为引用的过度文件。以防以后全局搜 <code>usePersistFn</code> 替换为 <code>useMemoizedFn</code></li>\n</ul>\n<p><code>useMemoizedFn</code> 如何实现 <code>useCallback</code> 效果，却不用使用第二参数 <code>deps</code> 呢？</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\ntype noop &#x3D; (this: any, ...args: any[]) &#x3D;&gt; any;\n\ntype PickFunction&lt;T extends noop&gt; &#x3D; (\n  this: ThisParameterType&lt;T&gt;,\n  ...args: Parameters&lt;T&gt;\n) &#x3D;&gt; ReturnType&lt;T&gt;;\n\nfunction useMemoizedFn&lt;T extends noop&gt;(fn: T) &#123;\n  const fnRef &#x3D; useRef&lt;T&gt;(fn);\n\n  &#x2F;&#x2F; why not write &#96;fnRef.current &#x3D; fn&#96;?\n  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;728\n  fnRef.current &#x3D; useMemo(() &#x3D;&gt; fn, [fn]); &#x2F;&#x2F; 为了兼容 react devtool\n\n  const memoizedFn &#x3D; useRef&lt;PickFunction&lt;T&gt;&gt;();\n\n  if (!memoizedFn.current) &#123;\n    &#x2F;&#x2F; 不存在，则重新生成函数， 这里用于缓存优化，但是函数执行的时候上下文中的参数是最新的，见下面模拟（出于这点，所以不需要deps）\n    memoizedFn.current &#x3D; function (this, ...args) &#123;\n      return fnRef.current.apply(this, args);\n    &#125;;\n  &#125;\n\n  return memoizedFn.current as T;\n&#125;\n\nexport default useMemoizedFn;</code></pre>\n\n<p><strong>模拟函数声明，函数内变量更新</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/202208241826880.webp\" />\n\n<h2 id=\"useToggle\"><a href=\"#useToggle\" class=\"headerlink\" title=\"useToggle\"></a>useToggle</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemo, useState &#125; from &quot;react&quot;;\n\nexport interface Actions&lt;T&gt; &#123;\n  setLeft: () &#x3D;&gt; void;\n  setRight: () &#x3D;&gt; void;\n  set: (value: T) &#x3D;&gt; void;\n  toggle: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; 1\nfunction useToggle&lt;T &#x3D; boolean&gt;(): [boolean, Actions&lt;T&gt;];\n&#x2F;&#x2F; 2\nfunction useToggle&lt;T&gt;(defaultValue: T): [T, Actions&lt;T&gt;];\n&#x2F;&#x2F; 3\nfunction useToggle&lt;T, U&gt;(\n  defaultValue: T,\n  reverseValue: U\n): [T | U, Actions&lt;T | U&gt;];\n&#x2F;&#x2F; 4\nfunction useToggle&lt;D, R&gt;(\n  defaultValue: D &#x3D; false as unknown as D,\n  reverseValue?: R\n) &#123;\n  &#x2F;&#x2F; 可以理解为缓存吧\n  const [state, setState] &#x3D; useState&lt;D | R&gt;(defaultValue);\n\n  const actions &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 最初的相反值 &#x3D; 设置的相反值 or 是初始值的取反\n    const reverseValueOrigin &#x3D; (\n      reverseValue &#x3D;&#x3D;&#x3D; undefined ? !defaultValue : reverseValue\n    ) as D | R;\n    &#x2F;&#x2F; 默认值取反\n    const toggle &#x3D; () &#x3D;&gt;\n      setState((s) &#x3D;&gt; (s &#x3D;&#x3D;&#x3D; defaultValue ? reverseValueOrigin : defaultValue));\n    &#x2F;&#x2F; 设置值\n    const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);\n    &#x2F;&#x2F; 设置初始值\n    const setLeft &#x3D; () &#x3D;&gt; setState(defaultValue);\n    &#x2F;&#x2F; 设置为相反值\n    const setRight &#x3D; () &#x3D;&gt; setState(reverseValueOrigin);\n    &#x2F;&#x2F; 这就有点意思了，左边右边，反过来，再翻过去，刚好 toggle\n    return &#123;\n      toggle,\n      set,\n      setLeft,\n      setRight,\n    &#125;;\n    &#x2F;&#x2F; useToggle ignore value change\n    &#x2F;&#x2F; &#125;, [defaultValue, reverseValue]);\n  &#125;, []);\n\n  return [state, actions &#x2F;**这里是对象，却用了s结尾，乍一看还以为数组 *&#x2F;];\n&#125;\n\nexport default useToggle;</code></pre>\n\n<h2 id=\"useBoolean\"><a href=\"#useBoolean\" class=\"headerlink\" title=\"useBoolean\"></a>useBoolean</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemo &#125; from &quot;react&quot;;\nimport useToggle from &quot;..&#x2F;useToggle&quot;;\n\n&#x2F;&#x2F; 这里与 useToggle很像\nexport interface Actions &#123;\n  setTrue: () &#x3D;&gt; void;\n  setFalse: () &#x3D;&gt; void;\n  set: (value: boolean) &#x3D;&gt; void;\n  toggle: () &#x3D;&gt; void;\n&#125;\n\n&#x2F;&#x2F; 主要用toggle整了点事，然后暴露更具有语义话的api\nexport default function useBoolean(defaultValue &#x3D; false): [boolean, Actions] &#123;\n  const [state, &#123; toggle, set &#125;] &#x3D; useToggle(defaultValue);\n\n  const actions: Actions &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);\n    const setTrue &#x3D; () &#x3D;&gt; set(true);\n    const setFalse &#x3D; () &#x3D;&gt; set(false);\n    return &#123;\n      toggle,\n      set: (v) &#x3D;&gt; set(!!v),\n      setTrue,\n      setFalse,\n    &#125;;\n  &#125;, []);\n\n  return [state, actions];\n&#125;</code></pre>\n\n<h2 id=\"useMount\"><a href=\"#useMount\" class=\"headerlink\" title=\"useMount\"></a>useMount</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\nconst useMount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 删减\n  useEffect(() &#x3D;&gt; &#123;\n    fn?.();\n  &#125;, []);\n&#125;;\n\nexport default useMount;</code></pre>\n\n<h2 id=\"useUnmount\"><a href=\"#useUnmount\" class=\"headerlink\" title=\"useUnmount\"></a>useUnmount</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\nconst useUnmount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 删减\n  const fnRef &#x3D; useLatest(fn);\n\n  useEffect(\n    () &#x3D;&gt; () &#x3D;&gt; &#123;\n      fnRef.current();\n    &#125;,\n    []\n  );\n&#125;;\n\nexport default useUnmount;</code></pre>\n\n<h2 id=\"useUnmountedRef\"><a href=\"#useUnmountedRef\" class=\"headerlink\" title=\"useUnmountedRef\"></a>useUnmountedRef</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>获取当前组件是否已经卸载的 Hook。</p></blockquote>\n<p>什么业务场景会使用？？</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\nconst useUnmountedRef &#x3D; () &#x3D;&gt; &#123;\n  const unmountedRef &#x3D; useRef(false); &#x2F;&#x2F; 默认没有卸载\n  useEffect(() &#x3D;&gt; &#123;\n    unmountedRef.current &#x3D; false; &#x2F;&#x2F; 挂载\n    return () &#x3D;&gt; &#123;\n      unmountedRef.current &#x3D; true; &#x2F;&#x2F; 卸载\n    &#125;;\n  &#125;, []);\n  return unmountedRef;\n&#125;;\n\nexport default useUnmountedRef;</code></pre>\n\n<h2 id=\"useUpdateEffect-有依赖项\"><a href=\"#useUpdateEffect-有依赖项\" class=\"headerlink\" title=\"useUpdateEffect (有依赖项)\"></a>useUpdateEffect (有依赖项)</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>useUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。</p></blockquote>\n<p><span style=\"color: red\">如何实现忽略首次执行的</span></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport &#123; createUpdateEffect &#125; from &quot;..&#x2F;createUpdateEffect&quot;; &#x2F;&#x2F; 见下面源码\n\nexport default createUpdateEffect(useEffect);</code></pre>\n\n<h2 id=\"createUpdateEffect\"><a href=\"#createUpdateEffect\" class=\"headerlink\" title=\"createUpdateEffect\"></a>createUpdateEffect</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useRef &#125; from &quot;react&quot;;\nimport type &#123; useEffect, useLayoutEffect &#125; from &quot;react&quot;;\n\ntype EffectHookType &#x3D; typeof useEffect | typeof useLayoutEffect;\n\n&#x2F;&#x2F; export const createUpdateEffect: (hook: EffectHookType) &#x3D;&gt; EffectHookType &#x3D; (hook) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;\nexport const createUpdateEffect &#x3D; (hook &#x2F;** useEffect *&#x2F;) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 柯里化\n  const isMounted &#x3D; useRef(false);\n\n  &#x2F;&#x2F; for react-refresh react刷新时候执行卸载\n  hook(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F;卸载\n    return () &#x3D;&gt; &#123;\n      isMounted.current &#x3D; false;\n    &#125;;\n  &#125;, []);\n\n  hook(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 挂在\n    if (!isMounted.current) &#123;\n      &#x2F;&#x2F; 非第一次， isMounted.current &#x3D; true , 此时走  effect()\n      isMounted.current &#x3D; true;\n    &#125; else &#123;\n      return effect();\n    &#125;\n  &#125;, deps);\n&#125;;\n\nexport default createUpdateEffect;</code></pre>\n\n<h2 id=\"useHistoryTravel\"><a href=\"#useHistoryTravel\" class=\"headerlink\" title=\"useHistoryTravel\"></a>useHistoryTravel</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>管理状态历史变化记录，方便在历史记录中前进与后退。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useRef, useState &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport &#123; isNumber &#125; from &quot;..&#x2F;utils&quot;;\n\ninterface IData&lt;T&gt; &#123;\n  present?: T;\n  past: T[];\n  future: T[];\n&#125;\n\nconst dumpIndex &#x3D; &lt;T&gt;(step: number, arr: T[]) &#x3D;&gt; &#123;\n  let index &#x3D;\n    step &gt; 0\n      ? step - 1 &#x2F;&#x2F; move forward\n      : arr.length + step; &#x2F;&#x2F; move backward\n  if (index &gt;&#x3D; arr.length - 1) &#123;\n    index &#x3D; arr.length - 1;\n  &#125;\n  if (index &lt; 0) &#123;\n    index &#x3D; 0;\n  &#125;\n  return index;\n&#125;;\n\nconst split &#x3D; &lt;T&gt;(step: number, targetArr: T[]) &#x3D;&gt; &#123;\n  const index &#x3D; dumpIndex(step, targetArr);\n  return &#123;\n    _current: targetArr[index],\n    _before: targetArr.slice(0, index),\n    _after: targetArr.slice(index + 1),\n  &#125;;\n&#125;;\n\nexport default function useHistoryTravel&lt;T&gt;(initialValue?: T) &#123;\n  const [history, setHistory] &#x3D; useState&lt;IData&lt;T | undefined&gt;&gt;(&#123;\n    present: initialValue, &#x2F;&#x2F; 当前\n    past: [], &#x2F;&#x2F; 历史记录\n    future: [], &#x2F;&#x2F; 未来记录\n  &#125;);\n\n  const &#123; present, past, future &#125; &#x3D; history;\n\n  const initialValueRef &#x3D; useRef(initialValue);\n\n  const reset &#x3D; (...params: any[]) &#x3D;&gt; &#123;\n    const _initial &#x3D; params.length &gt; 0 ? params[0] : initialValueRef.current;\n    initialValueRef.current &#x3D; _initial;\n\n    setHistory(&#123;\n      present: _initial,\n      future: [],\n      past: [],\n    &#125;);\n  &#125;;\n\n  const updateValue &#x3D; (val: T) &#x3D;&gt; &#123;\n    setHistory(&#123;\n      present: val,\n      future: [],\n      past: [...past, present],\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 向前\n  const _forward &#x3D; (step: number &#x3D; 1) &#x3D;&gt; &#123;\n    if (future.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n    const &#123; _before, _current, _after &#125; &#x3D; split(step, future);\n    setHistory(&#123;\n      past: [...past, present, ..._before],\n      present: _current,\n      future: _after,\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 向后\n  const _backward &#x3D; (step: number &#x3D; -1) &#x3D;&gt; &#123;\n    if (past.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n\n    const &#123; _before, _current, _after &#125; &#x3D; split(step, past);\n    setHistory(&#123;\n      past: _before,\n      present: _current,\n      future: [..._after, present, ...future],\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 可进，可退，可不动\n  const go &#x3D; (step: number) &#x3D;&gt; &#123;\n    const stepNum &#x3D; isNumber(step) ? step : Number(step);\n    if (stepNum &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n    if (stepNum &gt; 0) &#123;\n      return _forward(stepNum);\n    &#125;\n    _backward(stepNum);\n  &#125;;\n\n  return &#123;\n    value: present, &#x2F;&#x2F; 当前\n    backLength: past.length, &#x2F;&#x2F; 可后退长度\n    forwardLength: future.length, &#x2F;&#x2F; 可前进长度\n    setValue: useMemoizedFn(updateValue), &#x2F;&#x2F; 跳转到哪个记录\n    go: useMemoizedFn(go), &#x2F;&#x2F; 回退到哪个\n    back: useMemoizedFn(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 回退一个\n      go(-1);\n    &#125;),\n    forward: useMemoizedFn(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 前进一个\n      go(1);\n    &#125;),\n    reset: useMemoizedFn(reset), &#x2F;&#x2F; 重置\n  &#125;;\n&#125;</code></pre>\n\n<h2 id=\"useInfiniteScroll\"><a href=\"#useInfiniteScroll\" class=\"headerlink\" title=\"useInfiniteScroll\"></a>useInfiniteScroll</h2><p>useInfiniteScroll 封装了常见的无限滚动逻辑。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const &#123; data, loading, loadingMore, loadMore &#125; &#x3D; useInfiniteScroll(service);</code></pre>\n\n<p>useInfiniteScroll 的第一个参数 service 是一个异步函数，对这个函数的入参和出参有如下 <span style=\"color: red\">约定</span>：</p>\n<p>service 返回的数据必须包含 list 数组，类型为 <code>&#123; list: any[], ...rest &#125;</code><br>service 的入参为整合后的最新 data<br>假如第一次请求返回数据为<code> &#123; list: [1, 2, 3], nextId: 4 &#125;</code>, 第二次返回的数据为<code> &#123; list: [4, 5, 6], nextId: 7 &#125;</code>, 则我们会自动合并 list，整合后的的 data 为 <code>&#123; list: [1, 2, 3, 4, 5, 6], nextId: 7 &#125;</code>。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemo, useState &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;; &#x2F;&#x2F; 简化版useCallback\nimport useRequest from &quot;..&#x2F;useRequest&quot;; &#x2F;&#x2F; 请求封装的hook\n&#x2F;&#x2F; useUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。\nimport useUpdateEffect from &quot;..&#x2F;useUpdateEffect&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getClientHeight, getScrollHeight, getScrollTop &#125; from &quot;..&#x2F;utils&#x2F;rect&quot;;\nimport type &#123; Data, InfiniteScrollOptions, Service &#125; from &quot;.&#x2F;types&quot;;\n\nconst useInfiniteScroll &#x3D; &lt;TData extends Data&gt;(\n  service: Service&lt;TData&gt;,\n  options: InfiniteScrollOptions&lt;TData&gt; &#x3D; &#123;&#125;\n) &#x3D;&gt; &#123;\n  const &#123;\n    target,\n    isNoMore,\n    threshold &#x3D; 100,\n    reloadDeps &#x3D; [],\n    manual,\n    onBefore,\n    onSuccess,\n    onError,\n    onFinally,\n  &#125; &#x3D; options;\n\n  const [finalData, setFinalData] &#x3D; useState&lt;TData&gt;();\n  const [loadingMore, setLoadingMore] &#x3D; useState(false);\n\n  const noMore &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (!isNoMore) return false;\n    return isNoMore(finalData);\n  &#125;, [finalData]);\n\n  const &#123; loading, run, runAsync, cancel &#125; &#x3D; useRequest(\n    async (lastData?: TData) &#x3D;&gt; &#123;\n      const currentData &#x3D; await service(lastData);\n      if (!lastData) &#123;\n        setFinalData(currentData);\n      &#125; else &#123;\n        setFinalData(&#123;\n          ...currentData,\n          &#x2F;&#x2F; @ts-ignore\n          list: [...lastData.list, ...currentData.list],\n        &#125;);\n      &#125;\n      return currentData;\n    &#125;,\n    &#123;\n      manual,\n      onFinally: (_, d, e) &#x3D;&gt; &#123;\n        setLoadingMore(false);\n        onFinally?.(d, e);\n      &#125;,\n      onBefore: () &#x3D;&gt; onBefore?.(),\n      onSuccess: (d) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n          &#x2F;&#x2F; eslint-disable-next-line @typescript-eslint&#x2F;no-use-before-define\n          scrollMethod();\n        &#125;);\n        onSuccess?.(d);\n      &#125;,\n      onError: (e) &#x3D;&gt; onError?.(e),\n    &#125;\n  );\n\n  const loadMore &#x3D; () &#x3D;&gt; &#123;\n    if (noMore) return;\n    setLoadingMore(true);\n    run(finalData);\n  &#125;;\n\n  const loadMoreAsync &#x3D; () &#x3D;&gt; &#123;\n    if (noMore) return Promise.reject();\n    setLoadingMore(true);\n    return runAsync(finalData);\n  &#125;;\n\n  const reload &#x3D; () &#x3D;&gt; run();\n  const reloadAsync &#x3D; () &#x3D;&gt; runAsync();\n\n  &#x2F;&#x2F; scrollMethod会尝试去检测是否满足加载条件\n  const scrollMethod &#x3D; () &#x3D;&gt; &#123;\n    const el &#x3D; getTargetElement(target);\n    if (!el) &#123;\n      return;\n    &#125;\n\n    const scrollTop &#x3D; getScrollTop(el);\n    const scrollHeight &#x3D; getScrollHeight(el);\n    const clientHeight &#x3D; getClientHeight(el);\n\n    if (scrollHeight - scrollTop &lt;&#x3D; clientHeight + threshold) &#123;\n      loadMore();\n    &#125;\n  &#125;;\n  &#x2F;&#x2F; 监听滚动，加载中的会被拦掉，\n  useEventListener(\n    &quot;scroll&quot;,\n    () &#x3D;&gt; &#123;\n      if (loading || loadingMore) &#123;\n        return;\n      &#125;\n      scrollMethod();\n    &#125;,\n    &#123; target &#125;\n  );\n\n  useUpdateEffect(() &#x3D;&gt; &#123;\n    run();\n  &#125;, [...reloadDeps]);\n\n  return &#123;\n    &#x2F;&#x2F; 数据\n    data: finalData,\n    loading: !loadingMore &amp;&amp; loading,\n    loadingMore,\n    noMore,\n    &#x2F;&#x2F; 一些方法\n    loadMore: useMemoizedFn(loadMore),\n    loadMoreAsync: useMemoizedFn(loadMoreAsync),\n    &#x2F;&#x2F; 这两个声明的函数直接返回\n    &#x2F;&#x2F; const reload &#x3D; () &#x3D;&gt; run();\n    &#x2F;&#x2F; const reloadAsync &#x3D; () &#x3D;&gt; runAsync();\n    reload: useMemoizedFn(reload),\n    reloadAsync: useMemoizedFn(reloadAsync),\n    mutate &#x2F;**数据突变 *&#x2F;: setFinalData,\n    cancel,\n  &#125;;\n&#125;;\n\nexport default useInfiniteScroll;</code></pre>\n\n<h3 id=\"getTargetElement\"><a href=\"#getTargetElement\" class=\"headerlink\" title=\"getTargetElement\"></a>getTargetElement</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import type &#123; MutableRefObject &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;.&#x2F;index&quot;;\nimport isBrowser from &quot;.&#x2F;isBrowser&quot;;\n\ntype TargetValue&lt;T&gt; &#x3D; T | undefined | null;\n\ntype TargetType &#x3D; HTMLElement | Element | Window | Document;\n\nexport type BasicTarget&lt;T extends TargetType &#x3D; Element&gt; &#x3D;\n  | (() &#x3D;&gt; TargetValue&lt;T&gt;) &#x2F;&#x2F; 函数\n  | TargetValue&lt;T&gt; &#x2F;&#x2F; 直接dom\n  | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;; &#x2F;&#x2F; ref\n\nexport function getTargetElement&lt;T extends TargetType&gt;(\n  target: BasicTarget&lt;T&gt;,\n  defaultElement?: T\n) &#123;\n  &#x2F;&#x2F; 服务端渲染情况\n  if (!isBrowser) &#123;\n    return undefined;\n  &#125;\n  &#x2F;&#x2F; 假设，一定存在\n  if (!target) &#123;\n    return defaultElement;\n  &#125;\n\n  let targetElement: TargetValue&lt;T&gt;;\n  &#x2F;&#x2F; 函数\n  if (isFunction(target)) &#123;\n    targetElement &#x3D; target();\n    &#x2F;&#x2F; ref\n  &#125; else if (&quot;current&quot; in target) &#123;\n    targetElement &#x3D; target.current;\n    &#x2F;&#x2F; 直接dom\n  &#125; else &#123;\n    targetElement &#x3D; target;\n  &#125;\n\n  return targetElement;\n&#125;</code></pre>\n\n<h3 id=\"getClientHeight-getScrollHeight-getScrollTop\"><a href=\"#getClientHeight-getScrollHeight-getScrollTop\" class=\"headerlink\" title=\"getClientHeight, getScrollHeight, getScrollTop\"></a>getClientHeight, getScrollHeight, getScrollTop</h3><p>使用<code>Math.max</code>，对 rect 的计算进行兼容性处理</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const getScrollTop &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  if (el &#x3D;&#x3D;&#x3D; document || el &#x3D;&#x3D;&#x3D; document.body) &#123;\n    &#x2F;&#x2F; 处理浏览器兼容性\n    &#x2F;&#x2F; IE6&#x2F;7&#x2F;8：\n    &#x2F;&#x2F; 可以使用 document.documentElement.scrollTop；\n    &#x2F;&#x2F; IE9及以上：\n    &#x2F;&#x2F; 可以使用window.pageYOffset或者document.documentElement.scrollTop\n    &#x2F;&#x2F; Safari:\n    &#x2F;&#x2F; safari： window.pageYOffset 与document.body.scrollTop都可以；\n    &#x2F;&#x2F; Firefox:\n    &#x2F;&#x2F; 火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset 或者 document.documentElement.scrollTop ；\n    &#x2F;&#x2F; Chrome：\n    &#x2F;&#x2F; 谷歌浏览器只认识document.body.scrollTop;\n    return Math.max(\n      window.pageYOffset,\n      document.documentElement.scrollTop,\n      document.body.scrollTop\n    );\n  &#125;\n  return (el as Element).scrollTop;\n&#125;;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202208301756200.webp\" />\n\n<p><a href=\"https://segmentfault.com/a/1190000008065472\" target=\"_blank\" >JS 基础篇– body.scrollTop 与 documentElement.scrollTop</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const getScrollHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  return (\n    (el as Element).scrollHeight ||\n    Math.max(document.documentElement.scrollHeight, document.body.scrollHeight)\n  );\n&#125;;\n\nconst getClientHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  return (\n    (el as Element).clientHeight ||\n    Math.max(document.documentElement.clientHeight, document.body.clientHeight)\n  );\n&#125;;\n\nexport &#123; getScrollTop, getScrollHeight, getClientHeight &#125;;</code></pre>\n\n<h2 id=\"useEventListener\"><a href=\"#useEventListener\" class=\"headerlink\" title=\"useEventListener\"></a>useEventListener</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\ntype noop &#x3D; (...p: any) &#x3D;&gt; void;\n\nexport type Target &#x3D; BasicTarget&lt;HTMLElement | Element | Window | Document&gt;;\n\ntype Options&lt;T extends Target &#x3D; Target&gt; &#x3D; &#123;\n  target?: T;\n  capture?: boolean;\n  once?: boolean;\n  passive?: boolean;\n&#125;;\n\nfunction useEventListener&lt;K extends keyof HTMLElementEventMap&gt;(\n  eventName: K,\n  handler: (ev: HTMLElementEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;HTMLElement&gt;\n): void;\nfunction useEventListener&lt;K extends keyof ElementEventMap&gt;(\n  eventName: K,\n  handler: (ev: ElementEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Element&gt;\n): void;\nfunction useEventListener&lt;K extends keyof DocumentEventMap&gt;(\n  eventName: K,\n  handler: (ev: DocumentEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Document&gt;\n): void;\nfunction useEventListener&lt;K extends keyof WindowEventMap&gt;(\n  eventName: K,\n  handler: (ev: WindowEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Window&gt;\n): void;\nfunction useEventListener(\n  eventName: string,\n  handler: noop,\n  options: Options\n): void;\n\nfunction useEventListener(\n  eventName: string,\n  handler: noop,\n  options: Options &#x3D; &#123;&#125;\n) &#123;\n  const handlerRef &#x3D; useLatest(handler);\n\n  useEffectWithTarget(\n    &#x2F;&#x2F; 做了缓存\n    &#x2F;&#x2F; effect\n    () &#x3D;&gt; &#123;\n      const targetElement &#x3D; getTargetElement(options.target, window);\n      if (!targetElement?.addEventListener) &#123;\n        return;\n      &#125;\n\n      const eventListener &#x3D; (event: Event) &#x3D;&gt; &#123;\n        return handlerRef.current(event);\n      &#125;;\n\n      targetElement.addEventListener(eventName, eventListener, &#123;\n        capture: options.capture,\n        once: options.once,\n        passive: options.passive,\n      &#125;);\n\n      return () &#x3D;&gt; &#123;\n        targetElement.removeEventListener(eventName, eventListener, &#123;\n          capture: options.capture,\n        &#125;);\n      &#125;;\n    &#125;,\n    &#x2F;&#x2F; deps 依赖项\n    [eventName, options.capture, options.once, options.passive],\n    &#x2F;&#x2F; target\n    options.target\n  );\n&#125;\n\nexport default useEventListener;</code></pre>\n\n<h2 id=\"useEffectWithTarget\"><a href=\"#useEffectWithTarget\" class=\"headerlink\" title=\"useEffectWithTarget\"></a>useEffectWithTarget</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect &#125; from &quot;react&quot;;\nimport createEffectWithTarget from &quot;.&#x2F;createEffectWithTarget&quot;;\n&#x2F;&#x2F; createEffectWithTarget将useEffect进行包裹\nconst useEffectWithTarget &#x3D; createEffectWithTarget(useEffect);\n\nexport default useEffectWithTarget;</code></pre>\n\n<h2 id=\"createEffectWithTarget\"><a href=\"#createEffectWithTarget\" class=\"headerlink\" title=\"createEffectWithTarget\"></a>createEffectWithTarget</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import type &#123;\n  DependencyList,\n  EffectCallback,\n  useEffect,\n  useLayoutEffect,\n&#125; from &quot;react&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\nimport depsAreSame from &quot;.&#x2F;depsAreSame&quot;;\nimport type &#123; BasicTarget &#125; from &quot;.&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;.&#x2F;domTarget&quot;;\n\nconst createEffectWithTarget &#x3D; (\n  useEffectType: typeof useEffect | typeof useLayoutEffect\n) &#x3D;&gt; &#123;\n  &#x2F;**\n   *\n   * @param effect\n   * @param deps\n   * @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom\n   *&#x2F;\n  const useEffectWithTarget &#x3D; (\n    effect: EffectCallback,\n    deps: DependencyList,\n    target: BasicTarget&lt;any&gt; | BasicTarget&lt;any&gt;[]\n  ) &#x3D;&gt; &#123;\n    const hasInitRef &#x3D; useRef(false);\n\n    const lastElementRef &#x3D; useRef&lt;(Element | null)[]&gt;([]);\n    const lastDepsRef &#x3D; useRef&lt;DependencyList&gt;([]);\n\n    const unLoadRef &#x3D; useRef&lt;any&gt;();\n    &#x2F;&#x2F; 类型 useEffectType: typeof useEffect | typeof useLayoutEffect\n    useEffectType(() &#x3D;&gt; &#123;\n      const targets &#x3D; Array.isArray(target) ? target : [target];\n      const els &#x3D; targets.map((item) &#x3D;&gt; getTargetElement(item));\n\n      &#x2F;&#x2F; init run\n      if (!hasInitRef.current) &#123;\n        hasInitRef.current &#x3D; true;\n        lastElementRef.current &#x3D; els;\n        lastDepsRef.current &#x3D; deps;\n\n        unLoadRef.current &#x3D; effect(); &#x2F;&#x2F; 执行结果\n        return;\n      &#125;\n      &#x2F;&#x2F; 如上文注释： @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom\n      &#x2F;&#x2F; 存在不等情况会执行赋值\n      if (\n        els.length !&#x3D;&#x3D; lastElementRef.current.length ||\n        !depsAreSame(els, lastElementRef.current) ||\n        !depsAreSame(deps, lastDepsRef.current)\n      ) &#123;\n        unLoadRef.current?.(); &#x2F;&#x2F; 执行\n\n        lastElementRef.current &#x3D; els;\n        lastDepsRef.current &#x3D; deps;\n        unLoadRef.current &#x3D; effect();\n      &#125;\n    &#125;);\n    &#x2F;&#x2F; 卸载\n    useUnmount(() &#x3D;&gt; &#123;\n      unLoadRef.current?.();\n      &#x2F;&#x2F; for react-refresh\n      hasInitRef.current &#x3D; false;\n    &#125;);\n  &#125;;\n\n  return useEffectWithTarget;\n&#125;;\n\nexport default createEffectWithTarget;</code></pre>\n\n<h2 id=\"useWhyDidYouUpdate\"><a href=\"#useWhyDidYouUpdate\" class=\"headerlink\" title=\"useWhyDidYouUpdate\"></a>useWhyDidYouUpdate</h2><p><a href=\"https://ahooks.js.org/zh-CN/hooks/use-why-did-you-update#params\" target=\"_blank\" >见</a></p>\n<p>原理：useEffect 在组件更新时候会执行， 将之前的 props 存在 ref 上，之后会将所有的 key 比较，找到变更的 key 的 changedProps</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\nexport type IProps &#x3D; Record&lt;string, any&gt;;\n\nexport default function useWhyDidYouUpdate(\n  componentName: string,\n  props: IProps\n) &#123;\n  const prevProps &#x3D; useRef&lt;IProps&gt;(&#123;&#125;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (prevProps.current) &#123;\n      const allKeys &#x3D; Object.keys(&#123; ...prevProps.current, ...props &#125;);\n      const changedProps: IProps &#x3D; &#123;&#125;;\n\n      allKeys.forEach((key) &#x3D;&gt; &#123;\n        if (!Object.is(prevProps.current[key], props[key])) &#123;\n          changedProps[key] &#x3D; &#123;\n            from: prevProps.current[key],\n            to: props[key],\n          &#125;;\n        &#125;\n      &#125;);\n\n      if (Object.keys(changedProps).length) &#123;\n        console.log(&quot;[why-did-you-update]&quot;, componentName, changedProps);\n      &#125;\n    &#125;\n\n    prevProps.current &#x3D; props;\n  &#125;);\n&#125;</code></pre>\n\n<h2 id=\"useUrlState\"><a href=\"#useUrlState\" class=\"headerlink\" title=\"useUrlState\"></a>useUrlState</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemoizedFn, useUpdate &#125; from &quot;ahooks&quot;;\nimport &#123; parse, stringify &#125; from &quot;query-string&quot;;\nimport type &#123; ParseOptions, StringifyOptions &#125; from &quot;query-string&quot;;\nimport &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport type * as React from &quot;react&quot;;\nimport * as tmp from &quot;react-router&quot;;\n\n&#x2F;&#x2F; ignore waring &#96;&quot;export &#39;useNavigate&#39; (imported as &#39;rc&#39;) was not found in &#39;react-router&#39;&#96;\nconst rc &#x3D; tmp as any;\n\nexport interface Options &#123;\n  navigateMode?: &quot;push&quot; | &quot;replace&quot;;\n  parseOptions?: ParseOptions;\n  stringifyOptions?: StringifyOptions;\n&#125;\n\nconst baseParseConfig: ParseOptions &#x3D; &#123;\n  parseNumbers: false,\n  parseBooleans: false,\n&#125;;\n\nconst baseStringifyConfig: StringifyOptions &#x3D; &#123;\n  skipNull: false,\n  skipEmptyString: false,\n&#125;;\n\ntype UrlState &#x3D; Record&lt;string, any&gt;;\n\nconst useUrlState &#x3D; &lt;S extends UrlState &#x3D; UrlState&gt;(\n  initialState?: S | (() &#x3D;&gt; S),\n  options?: Options\n) &#x3D;&gt; &#123;\n  type State &#x3D; Partial&lt;&#123; [key in keyof S]: any &#125;&gt;;\n  const &#123;\n    navigateMode &#x3D; &quot;push&quot;, &#x2F;&#x2F; 状态变更时切换 history 的方式\n    parseOptions,\n    stringifyOptions,\n  &#125; &#x3D; options || &#123;&#125;;\n\n  const mergedParseOptions &#x3D; &#123; ...baseParseConfig, ...parseOptions &#125;;\n  const mergedStringifyOptions &#x3D; &#123;\n    ...baseStringifyConfig,\n    ...stringifyOptions,\n  &#125;;\n\n  const location &#x3D; rc.useLocation();\n\n  &#x2F;&#x2F; react-router v5\n  const history &#x3D; rc.useHistory?.();\n  &#x2F;&#x2F; react-router v6\n  const navigate &#x3D; rc.useNavigate?.();\n\n  const update &#x3D; useUpdate();\n\n  const initialStateRef &#x3D; useRef(\n    typeof initialState &#x3D;&#x3D;&#x3D; &quot;function&quot;\n      ? (initialState as () &#x3D;&gt; S)()\n      : initialState || &#123;&#125;\n  );\n  &#x2F;&#x2F; 解析出 query\n  const queryFromUrl &#x3D; useMemo(() &#x3D;&gt; &#123;\n    return parse(location.search, mergedParseOptions);\n  &#125;, [location.search]);\n\n  &#x2F;&#x2F; 更改后的 query\n  const targetQuery: State &#x3D; useMemo(\n    () &#x3D;&gt; (&#123;\n      ...initialStateRef.current,\n      ...queryFromUrl,\n    &#125;),\n    [queryFromUrl]\n  );\n\n  const setState &#x3D; (s: React.SetStateAction&lt;State&gt;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果是函数，则将上一个值，作为参数传入\n    const newQuery &#x3D; typeof s &#x3D;&#x3D;&#x3D; &quot;function&quot; ? s(targetQuery) : s;\n\n    &#x2F;&#x2F; 1. 如果 setState 后，search 没变化，就需要 update 来触发一次更新。比如 demo1 直接点击 clear，就需要 update 来触发更新。\n    &#x2F;&#x2F; 2. update 和 history 的更新会合并，不会造成多次更新\n    update(); &#x2F;&#x2F; 担心不更新\n    if (history) &#123;\n      history[navigateMode](&#123;\n        hash: location.hash,\n        search:\n          stringify(&#123; ...queryFromUrl, ...newQuery &#125;, mergedStringifyOptions) ||\n          &quot;?&quot;,\n      &#125;);\n    &#125;\n    if (navigate) &#123;\n      navigate(\n        &#123;\n          hash: location.hash,\n          search:\n            stringify(\n              &#123; ...queryFromUrl, ...newQuery &#125;,\n              mergedStringifyOptions\n            ) || &quot;?&quot;,\n        &#125;,\n        &#123;\n          replace: navigateMode &#x3D;&#x3D;&#x3D; &quot;replace&quot;,\n        &#125;\n      );\n    &#125;\n  &#125;;\n\n  return [targetQuery &#x2F;**url query 对象 *&#x2F;, useMemoizedFn(setState)] as const;\n&#125;;\n\nexport default useUrlState;</code></pre>\n\n<h2 id=\"useSafeState\"><a href=\"#useSafeState\" class=\"headerlink\" title=\"useSafeState\"></a>useSafeState</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>用法与 React.useState 完全一样，但是在组件卸载后异步回调内的 setState 不再执行，避免因组件卸载后更新状态而导致的内存泄漏。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useCallback, useState &#125; from &quot;react&quot;;\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\n&#x2F;&#x2F; &gt; 获取当前组件是否已经卸载的 Hook。\nimport useUnmountedRef from &quot;..&#x2F;useUnmountedRef&quot;;\n\nfunction useSafeState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];\n\nfunction useSafeState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;\n];\n\nfunction useSafeState&lt;S&gt;(initialState?: S | (() &#x3D;&gt; S)) &#123;\n  const unmountedRef &#x3D; useUnmountedRef();\n  const [state, setState] &#x3D; useState(initialState);\n  const setCurrentState &#x3D; useCallback((currentState) &#x3D;&gt; &#123;\n    &#x2F;** if component is unmounted, stop update *&#x2F;\n    &#x2F;&#x2F; 组件卸载停止更新\n    if (unmountedRef.current) return;\n    setState(currentState);\n  &#125;, []);\n\n  return [state, setCurrentState] as const;\n&#125;\n\nexport default useSafeState;</code></pre>\n\n<h2 id=\"useGetState\"><a href=\"#useGetState\" class=\"headerlink\" title=\"useGetState\"></a>useGetState</h2><p>内部使用 <code>useRef</code> 缓存了值，在调用 <code>getState</code> 时候，将 ref 值返回.</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;\n\ntype GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;\n\nfunction useGetState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];\nfunction useGetState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,\n  GetStateAction&lt;S | undefined&gt;\n];\nfunction useGetState&lt;S&gt;(initialState?: S) &#123;\n  const [state, setState] &#x3D; useState(initialState);\n\n  const stateRef &#x3D; useRef(state);\n  stateRef.current &#x3D; state;\n\n  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);\n\n  return [state, setState, getState];\n&#125;\n\nexport default useGetState;</code></pre>\n\n<h2 id=\"useResetState\"><a href=\"#useResetState\" class=\"headerlink\" title=\"useResetState\"></a>useResetState</h2><p><code>initialState</code>的值，用于重置</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useState &#125; from &quot;react&quot;;\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\n\ntype ResetState &#x3D; () &#x3D;&gt; void;\n\nconst useResetState &#x3D; &lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, ResetState] &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(initialState);\n\n  const resetState &#x3D; useMemoizedFn(() &#x3D;&gt; &#123;\n    setState(initialState);\n  &#125;);\n\n  return [state, setState, resetState];\n&#125;;\n\nexport default useResetState;</code></pre>\n\n<h2 id=\"useRafState\"><a href=\"#useRafState\" class=\"headerlink\" title=\"useRafState\"></a>useRafState</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>只在 requestAnimationFrame callback 时更新 state，一般用于性能优化。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useCallback, useRef, useState &#125; from &quot;react&quot;;\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\n\nfunction useRafState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];\nfunction useRafState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;\n];\n\nfunction useRafState&lt;S&gt;(initialState?: S | (() &#x3D;&gt; S)) &#123;\n  &#x2F;&#x2F; 先前调用window.requestAnimationFrame()方法时返回的 ID.\n  const ref &#x3D; useRef(0); &#x2F;&#x2F; requestID\n  const [state, setState] &#x3D; useState(initialState);\n\n  const setRafState &#x3D; useCallback((value: S | ((prevState: S) &#x3D;&gt; S)) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; cancelAnimationFrame 取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。\n    cancelAnimationFrame(ref.current &#x2F;**requestID *&#x2F;);\n\n    ref.current &#x3D; requestAnimationFrame(() &#x3D;&gt; &#123;\n      setState(value);\n    &#125;);\n  &#125;, []);\n\n  &#x2F;&#x2F; 卸载，取消动画镇\n  useUnmount(() &#x3D;&gt; &#123;\n    cancelAnimationFrame(ref.current &#x2F;**requestID *&#x2F;);\n  &#125;);\n\n  return [state, setRafState] as const;\n&#125;\n\nexport default useRafState;</code></pre>\n\n<h2 id=\"usePrevious\"><a href=\"#usePrevious\" class=\"headerlink\" title=\"usePrevious\"></a>usePrevious</h2><p>先猜下，又用了 ref 进行缓存</p>\n<p>悄悄源码</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useRef &#125; from &quot;react&quot;;\n\nexport type ShouldUpdateFunc&lt;T&gt; &#x3D; (prev: T | undefined, next: T) &#x3D;&gt; boolean;\n\nconst defaultShouldUpdate &#x3D; &lt;T&gt;(a?: T, b?: T) &#x3D;&gt; !Object.is(a, b); &#x2F;&#x2F; 默认比较\n\nfunction usePrevious&lt;T&gt;(\n  state: T,\n  shouldUpdate: ShouldUpdateFunc&lt;T&gt; &#x3D; defaultShouldUpdate\n): T | undefined &#123;\n  const prevRef &#x3D; useRef&lt;T&gt;(); &#x2F;&#x2F; 存前一个\n  const curRef &#x3D; useRef&lt;T&gt;(); &#x2F;&#x2F; 存当前，🤔，存当前的，相当于中介，如：把两瓶水交换，借助第三个瓶子\n\n  if (shouldUpdate(curRef.current, state)) &#123;\n    &#x2F;&#x2F; 不一样，更新值\n    prevRef.current &#x3D; curRef.current;\n    curRef.current &#x3D; state;\n  &#125;\n\n  return prevRef.current; &#x2F;&#x2F; 最终返回之前的值\n&#125;\n\nexport default usePrevious;</code></pre>\n\n<h2 id=\"useMap\"><a href=\"#useMap\" class=\"headerlink\" title=\"useMap\"></a>useMap</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useState &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\n\nfunction useMap&lt;K, T&gt;(initialValue?: Iterable&lt;readonly [K, T]&gt;) &#123;\n  &#x2F;&#x2F; 初始值\n  const getInitValue &#x3D; () &#x3D;&gt; &#123;\n    return initialValue &#x3D;&#x3D;&#x3D; undefined ? new Map() : new Map(initialValue);\n  &#125;;\n\n  const [map, setMap] &#x3D; useState&lt;Map&lt;K, T&gt;&gt;(() &#x3D;&gt; getInitValue());\n\n  &#x2F;&#x2F; 设置， 新旧合并，新的属性会覆盖旧的\n  const set &#x3D; (key: K, entry: T) &#x3D;&gt; &#123;\n    setMap((prev) &#x3D;&gt; &#123;\n      const temp &#x3D; new Map(prev); &#x2F;&#x2F; 将之前的值拷贝，切断 temp 与 prev之间联系？\n      temp.set(key, entry);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 完全重新赋值\n  const setAll &#x3D; (newMap: Iterable&lt;readonly [K, T]&gt;) &#x3D;&gt; &#123;\n    setMap(new Map(newMap));\n  &#125;;\n  &#x2F;&#x2F; 删除某个key对应的值\n  const remove &#x3D; (key: K) &#x3D;&gt; &#123;\n    setMap((prev) &#x3D;&gt; &#123;\n      const temp &#x3D; new Map(prev);\n      temp.delete(key);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 重置，恢复为初始值\n  const reset &#x3D; () &#x3D;&gt; setMap(getInitValue());\n  &#x2F;&#x2F; 根据key返回值， map 是useState上的map\n  const get &#x3D; (key: K) &#x3D;&gt; map.get(key);\n\n  return [\n    map,\n    &#123;\n      &#x2F;&#x2F; 一些方法，包裹后，暴露出去\n      set: useMemoizedFn(set),\n      setAll: useMemoizedFn(setAll),\n      remove: useMemoizedFn(remove),\n      reset: useMemoizedFn(reset),\n      get: useMemoizedFn(get),\n    &#125;,\n  ] as const;\n&#125;\n\nexport default useMap;</code></pre>\n\n<h2 id=\"useSet\"><a href=\"#useSet\" class=\"headerlink\" title=\"useSet\"></a>useSet</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useState &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\n\nfunction useSet&lt;K&gt;(initialValue?: Iterable&lt;K&gt;) &#123;\n  const getInitValue &#x3D; () &#x3D;&gt; &#123;\n    return initialValue &#x3D;&#x3D;&#x3D; undefined ? new Set&lt;K&gt;() : new Set(initialValue);\n  &#125;;\n\n  const [set, setSet] &#x3D; useState&lt;Set&lt;K&gt;&gt;(() &#x3D;&gt; getInitValue());\n  &#x2F;&#x2F; 已经有的，不会重复添加，set存值，保证唯一，没必要重复插入\n  const add &#x3D; (key: K) &#x3D;&gt; &#123;\n    if (set.has(key)) &#123;\n      return;\n    &#125;\n    setSet((prevSet) &#x3D;&gt; &#123;\n      const temp &#x3D; new Set(prevSet);\n      temp.add(key);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 没有不继续执行，有继续之前，将prevSet，生成一个新的Set,然后删除key,并返回新的map，\n  const remove &#x3D; (key: K) &#x3D;&gt; &#123;\n    if (!set.has(key)) &#123;\n      return;\n    &#125;\n    setSet((prevSet) &#x3D;&gt; &#123;\n      const temp &#x3D; new Set(prevSet);\n      temp.delete(key);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 重置到最初值\n  const reset &#x3D; () &#x3D;&gt; setSet(getInitValue());\n\n  return [\n    set,\n    &#123;\n      &#x2F;&#x2F; 方法，缓存下\n      add: useMemoizedFn(add),\n      remove: useMemoizedFn(remove),\n      reset: useMemoizedFn(reset),\n    &#125;,\n  ] as const;\n&#125;\n\nexport default useSet;</code></pre>\n\n<p>useMap&#x2F;useSet 返回的都是新的 Map&#x2F;Set 对象, 所以每次变化都会触发更新。之前开发中进行突变，不会触发页面更新</p>\n<h2 id=\"useMemoizedFn-1\"><a href=\"#useMemoizedFn-1\" class=\"headerlink\" title=\"useMemoizedFn\"></a>useMemoizedFn</h2><p>持久化 function 的 Hook，理论上，可以使用 useMemoizedFn 完全代替 useCallback。</p>\n<p>在某些场景中，我们需要使用 useCallback 来记住一个函数，但是在第二个参数 deps 变化时，会重新生成函数，导致函数地址变化。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const [state, setState] &#x3D; useState(&quot;&quot;);\n\n&#x2F;&#x2F; 在 state 变化时，func 地址会变化\nconst func &#x3D; useCallback(() &#x3D;&gt; &#123;\n  console.log(state);\n&#125;, [state]);</code></pre>\n\n<p>使用 useMemoizedFn，可以省略第二个参数 deps，<span style=\"color: red\">同时保证函数地址永远不会变化</span>。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>如果以地址变化的更新，不可用 <code>useMemoizedFn</code></p>\n</div>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const [state, setState] &#x3D; useState(&quot;&quot;);\n\n&#x2F;&#x2F; func 地址永远不会变化\nconst func &#x3D; useMemoizedFn(() &#x3D;&gt; &#123;\n  console.log(state);\n&#125;);</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\nimport isDev from &quot;..&#x2F;utils&#x2F;isDev&quot;;\n\ntype noop &#x3D; (this: any, ...args: any[]) &#x3D;&gt; any;\n\ntype PickFunction&lt;T extends noop&gt; &#x3D; (\n  this: ThisParameterType&lt;T&gt;,\n  ...args: Parameters&lt;T&gt;\n) &#x3D;&gt; ReturnType&lt;T&gt;;\n\nfunction useMemoizedFn&lt;T extends noop&gt;(fn: T) &#123;\n  if (isDev) &#123;\n    if (!isFunction(fn)) &#123;\n      console.error(\n        &#96;useMemoizedFn expected parameter is a function, got $&#123;typeof fn&#125;&#96;\n      );\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 下面这两行代码看上去确实有点奇怪\n  &#x2F;&#x2F; 为了解决 usePersistFn（useMemoizedFn）不能兼容react devtool\n  const fnRef &#x3D; useRef&lt;T&gt;(fn);\n  &#x2F;&#x2F; why not write &#96;fnRef.current &#x3D; fn&#96;?\n  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;728\n  fnRef.current &#x3D; useMemo(() &#x3D;&gt; fn, [fn]);\n\n  &#x2F;&#x2F; 缓存函数地址\n  const memoizedFn &#x3D; useRef&lt;PickFunction&lt;T&gt;&gt;();\n  if (!memoizedFn.current) &#123;\n    memoizedFn.current &#x3D; function (this, ...args) &#123;\n      &#x2F;&#x2F; 没有函数的时候，这里重新生成了一个函数，并将执行结果作为新函数的结果\n      return fnRef.current.apply(this, args); &#x2F;&#x2F; fnRef.current, 从缓存里取的\n    &#125;;\n  &#125;\n\n  return memoizedFn.current as T;\n&#125;\n\nexport default useMemoizedFn;</code></pre>\n\n<h2 id=\"useFocusWithin\"><a href=\"#useFocusWithin\" class=\"headerlink\" title=\"useFocusWithin\"></a>useFocusWithin</h2><p>监听当前焦点是否在某个区域之内，同 css 属性 :focus-within</p>\n<p>可用于： 聚焦发送请求，以保证用户获取最新数据</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useState &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\n\nexport interface Options &#123;\n  onFocus?: (e: FocusEvent) &#x3D;&gt; void;\n  onBlur?: (e: FocusEvent) &#x3D;&gt; void;\n  onChange?: (isFocusWithin: boolean) &#x3D;&gt; void;\n&#125;\n\nexport default function useFocusWithin(target: BasicTarget, options?: Options) &#123;\n  const [isFocusWithin, setIsFocusWithin] &#x3D; useState(false);\n  const &#123; onFocus, onBlur, onChange &#125; &#x3D; options || &#123;&#125;;\n\n  useEventListener(\n    &quot;focusin&quot;,\n    (e: FocusEvent) &#x3D;&gt; &#123;\n      if (!isFocusWithin) &#123;\n        onFocus?.(e);\n        onChange?.(true);\n        setIsFocusWithin(true); &#x2F;&#x2F; 聚焦\n      &#125;\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n\n  useEventListener(\n    &quot;focusout&quot;,\n    (e: FocusEvent) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; contains 原生\n      if (\n        isFocusWithin &amp;&amp;\n        !(e.currentTarget as Element)?.contains?.(e.relatedTarget as Element)\n      ) &#123;\n        onBlur?.(e);\n        onChange?.(false);\n        setIsFocusWithin(false); &#x2F;&#x2F; 失去焦点\n      &#125;\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n\n  return isFocusWithin;\n&#125;</code></pre>\n\n<p>问题：我记得有个间隔多久之后，再次聚焦才发送请求的，之后看看是哪个 api</p>\n<h2 id=\"useTitle\"><a href=\"#useTitle\" class=\"headerlink\" title=\"useTitle\"></a>useTitle</h2><p>这个 api 在<code>nextjs</code>中或许不是那么好用，因为 nextjs 有自己的 api，<code>useTitle</code>更新后，会被 nextjs<code>&lt;Title&gt;&lt;/Title&gt;</code>给覆盖掉</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect, useRef &#125; from &quot;react&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\nimport isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;\n\nexport interface Options &#123;\n  restoreOnUnmount?: boolean;\n&#125;\n\nconst DEFAULT_OPTIONS: Options &#x3D; &#123;\n  restoreOnUnmount: false,\n&#125;;\n\nfunction useTitle(title: string, options: Options &#x3D; DEFAULT_OPTIONS) &#123;\n  const titleRef &#x3D; useRef(isBrowser ? document.title : &quot;&quot;);\n  &#x2F;&#x2F; 额，这里在服务端可以拿到 document吗？如果拿不到会报错的，没加 isBrowser 判断，那么在服务端可以拿到\n  useEffect(() &#x3D;&gt; &#123;\n    document.title &#x3D; title;\n  &#125;, [title]);\n\n  useUnmount(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; restoreOnUnmount\t组件卸载时，是否恢复上一个页面标题\n    if (options.restoreOnUnmount) &#123;\n      &#x2F;&#x2F; 卸载恢复\n      document.title &#x3D; titleRef.current;\n    &#125;\n  &#125;);\n&#125;\n\nexport default useTitle;</code></pre>\n\n<h2 id=\"useFavicon\"><a href=\"#useFavicon\" class=\"headerlink\" title=\"useFavicon\"></a>useFavicon</h2><p>实现：link 标签更改&#x2F;动态创建标签放到 head 尾部</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect &#125; from &quot;react&quot;;\n&#x2F;&#x2F; shortcut icon 类型限制\nconst ImgTypeMap &#x3D; &#123;\n  SVG: &quot;image&#x2F;svg+xml&quot;,\n  ICO: &quot;image&#x2F;x-icon&quot;,\n  GIF: &quot;image&#x2F;gif&quot;,\n  PNG: &quot;image&#x2F;png&quot;,\n&#125;;\n\ntype ImgTypes &#x3D; keyof typeof ImgTypeMap;\n\nconst useFavicon &#x3D; (href: string) &#x3D;&gt; &#123;\n  useEffect(() &#x3D;&gt; &#123;\n    if (!href) return;\n    &#x2F;&#x2F; 截取后缀判断是否满足\n    const cutUrl &#x3D; href.split(&quot;.&quot;);\n    const imgSuffix &#x3D; cutUrl[cutUrl.length - 1].toLocaleUpperCase() as ImgTypes;\n\n    &#x2F;&#x2F;存在获取，不存在\n    const link: HTMLLinkElement &#x3D;\n      document.querySelector(&quot;link[rel*&#x3D;&#39;icon&#39;]&quot;) ||\n      document.createElement(&quot;link&quot;);\n\n    link.type &#x3D; ImgTypeMap[imgSuffix];\n    link.href &#x3D; href;\n    link.rel &#x3D; &quot;shortcut icon&quot;;\n\n    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(link);\n  &#125;, [href]);\n&#125;;\n\nexport default useFavicon;</code></pre>\n\n<h2 id=\"useFullscreen\"><a href=\"#useFullscreen\" class=\"headerlink\" title=\"useFullscreen\"></a>useFullscreen</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useState &#125; from &quot;react&quot;;\nimport screenfull from &quot;screenfull&quot;; &#x2F;&#x2F; @link https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;main&#x2F;index.js\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\n\nexport interface Options &#123;\n  onExit?: () &#x3D;&gt; void;\n  onEnter?: () &#x3D;&gt; void;\n&#125;\n\nconst useFullscreen &#x3D; (target: BasicTarget, options?: Options) &#x3D;&gt; &#123;\n  const &#123; onExit, onEnter &#125; &#x3D; options || &#123;&#125;;\n  &#x2F;&#x2F; 退出\n  const onExitRef &#x3D; useLatest(onExit);\n  &#x2F;&#x2F; 进入\n  const onEnterRef &#x3D; useLatest(onEnter);\n  &#x2F;&#x2F; 是否全屏\n  const [state, setState] &#x3D; useState(false);\n\n  const onChange &#x3D; () &#x3D;&gt; &#123;\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; 支持全屏\n      const &#123; isFullscreen &#125; &#x3D; screenfull;\n      if (isFullscreen) &#123;\n        onEnterRef.current?.();\n      &#125; else &#123;\n        screenfull.off(&quot;change&quot;, onChange);\n        onExitRef.current?.();\n      &#125;\n      setState(isFullscreen);\n    &#125;\n  &#125;;\n\n  const enterFullscreen &#x3D; () &#x3D;&gt; &#123;\n    const el &#x3D; getTargetElement(target);\n    if (!el) &#123;\n      return;\n    &#125;\n\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; 支持全屏\n      try &#123;\n        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;991e917bffc818c5367186c6ec5e70ae7a37cfc5&#x2F;index.js#L80\n        screenfull.request(el);\n        screenfull.on(&quot;change&quot;, onChange);\n      &#125; catch (error) &#123;\n        console.error(error);\n      &#125;\n    &#125;\n  &#125;;\n\n  const exitFullscreen &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 支持全屏\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;991e917bffc818c5367186c6ec5e70ae7a37cfc5&#x2F;index.js#L96\n      &#x2F;&#x2F; 奇怪了，这里怎么返回了一个promise\n      screenfull.exit();\n    &#125;\n  &#125;;\n\n  const toggleFullscreen &#x3D; () &#x3D;&gt; &#123;\n    if (state) &#123;\n      exitFullscreen();\n    &#125; else &#123;\n      enterFullscreen();\n    &#125;\n  &#125;;\n\n  useUnmount(() &#x3D;&gt; &#123;\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; 支持全屏\n      screenfull.off(&quot;change&quot;, onChange);\n    &#125;\n  &#125;);\n\n  return [\n    state,\n    &#123;\n      enterFullscreen: useMemoizedFn(enterFullscreen),\n      exitFullscreen: useMemoizedFn(exitFullscreen),\n      toggleFullscreen: useMemoizedFn(toggleFullscreen),\n      isEnabled: screenfull.isEnabled,\n    &#125;,\n  ] as const;\n&#125;;\n\nexport default useFullscreen;</code></pre>\n\n<h2 id=\"screenfull\"><a href=\"#screenfull\" class=\"headerlink\" title=\"screenfull\"></a>screenfull</h2><p><a href=\"https://github.com/sindresorhus/screenfull/blob/991e917bffc818c5367186c6ec5e70ae7a37cfc5/index.js#L50\">https://github.com/sindresorhus/screenfull/blob/991e917bffc818c5367186c6ec5e70ae7a37cfc5/index.js#L50</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const nativeAPI &#x3D; (() &#x3D;&gt; &#123;\n  if (typeof document &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n    return false;\n  &#125;\n\n  const unprefixedMethods &#x3D; methodMap[0];\n  const returnValue &#x3D; &#123;&#125;;\n\n  for (const methodList of methodMap &#x2F;**二维数组 *&#x2F;) &#123;\n    const exitFullscreenMethod &#x3D; methodList?.[1];\n    if (exitFullscreenMethod in document) &#123;\n      &#x2F;&#x2F; 支持的方法，都给提取出来，放到 nativeAPI,之后使用nativeAPI上的方法\n      for (const [index, method] of methodList.entries()) &#123;\n        returnValue[unprefixedMethods[index]] &#x3D; method;\n      &#125;\n\n      return returnValue;\n    &#125;\n  &#125;\n\n  return false;\n&#125;)();\n\n&#x2F;&#x2F; ....\n\nlet screenfull &#x3D; &#123;\n  &#x2F;&#x2F; eslint-disable-next-line default-param-last\n  request(element &#x3D; document.documentElement, options) &#123;&#125;,\n  &#x2F;&#x2F; 退出全屏\n  exit() &#123;&#125;,\n  &#x2F;&#x2F; 全屏&#x2F;非全屏切换\n  toggle(element, options) &#123;&#125;,\n  &#x2F;&#x2F; 更改\n  onchange(callback) &#123;&#125;,\n  &#x2F;&#x2F; 错误处理\n  onerror(callback) &#123;&#125;,\n  &#x2F;&#x2F; 事件监听\n  on(event, callback) &#123;&#125;,\n  &#x2F;&#x2F; 移除监听\n  off(event, callback) &#123;&#125;,\n  &#x2F;&#x2F; 原生api\n  raw: nativeAPI,\n&#125;;\n\n&#x2F;&#x2F; 扩展三个方法\nObject.defineProperties(screenfull, &#123;\n  isFullscreen: &#123;\n    get: () &#x3D;&gt; Boolean(document[nativeAPI.fullscreenElement]),\n  &#125;,\n  element: &#123;\n    enumerable: true,\n    get: () &#x3D;&gt; document[nativeAPI.fullscreenElement] ?? undefined,\n  &#125;,\n  isEnabled: &#123;\n    enumerable: true,\n    &#x2F;&#x2F; Coerce to boolean in case of old WebKit.\n    get: () &#x3D;&gt; Boolean(document[nativeAPI.fullscreenEnabled]),\n  &#125;,\n&#125;);\n&#x2F;&#x2F; nativeAPI为&#123;&#125; , 不支持原生 isEnabled 为 false, 所以在用screenfull上api时候都要先用isEnabled判断下\nif (!nativeAPI) &#123;\n  screenfull &#x3D; &#123; isEnabled: false &#125;;\n&#125;\n\nexport default screenfull;</code></pre>\n\n<h2 id=\"useExternal\"><a href=\"#useExternal\" class=\"headerlink\" title=\"useExternal\"></a>useExternal</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>动态注入 JS 或 CSS 资源，useExternal 可以保证资源全局唯一。</p></blockquote>\n<p>实现原理：通过 <code>useEffect</code>,deps 不改变，逻辑不会重复执行的特点</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;\n\nexport interface Options &#123;\n  type?: &quot;js&quot; | &quot;css&quot;;\n  js?: Partial&lt;HTMLScriptElement&gt;;\n  css?: Partial&lt;HTMLStyleElement&gt;;\n&#125;\n\n&#x2F;&#x2F; &#123;[path]: count&#125;\n&#x2F;&#x2F; remove external when no used\nconst EXTERNAL_USED_COUNT: Record&lt;string, number&gt; &#x3D; &#123;&#125;;\n\nexport type Status &#x3D; &quot;unset&quot; | &quot;loading&quot; | &quot;ready&quot; | &quot;error&quot;;\n\ninterface loadResult &#123;\n  ref: Element;\n  status: Status;\n&#125;\n&#x2F;&#x2F; 加载js\nconst loadScript &#x3D; (path: string, props &#x3D; &#123;&#125;): loadResult &#x3D;&gt; &#123;\n  const script &#x3D; document.querySelector(&#96;script[src&#x3D;&quot;$&#123;path&#125;&quot;]&#96;);\n\n  if (!script) &#123;\n    const newScript &#x3D; document.createElement(&quot;script&quot;);\n    newScript.src &#x3D; path;\n\n    Object.keys(props).forEach((key) &#x3D;&gt; &#123;\n      newScript[key] &#x3D; props[key];\n    &#125;);\n\n    newScript.setAttribute(&quot;data-status&quot;, &quot;loading&quot;);\n    document.body.appendChild(newScript);\n\n    return &#123;\n      ref: newScript,\n      status: &quot;loading&quot;,\n    &#125;;\n  &#125;\n\n  return &#123;\n    ref: script,\n    status: (script.getAttribute(&quot;data-status&quot;) as Status) || &quot;ready&quot;,\n  &#125;;\n&#125;;\n&#x2F;&#x2F; 加载css\nconst loadCss &#x3D; (path: string, props &#x3D; &#123;&#125;): loadResult &#x3D;&gt; &#123;\n  const css &#x3D; document.querySelector(&#96;link[href&#x3D;&quot;$&#123;path&#125;&quot;]&#96;);\n  if (!css) &#123;\n    const newCss &#x3D; document.createElement(&quot;link&quot;);\n\n    newCss.rel &#x3D; &quot;stylesheet&quot;;\n    newCss.href &#x3D; path;\n    Object.keys(props).forEach((key) &#x3D;&gt; &#123;\n      newCss[key] &#x3D; props[key];\n    &#125;);\n    &#x2F;&#x2F; IE9+\n    const isLegacyIECss &#x3D; &quot;hideFocus&quot; in newCss;\n    &#x2F;&#x2F; use preload in IE Edge (to detect load errors)\n    if (isLegacyIECss &amp;&amp; newCss.relList) &#123;\n      newCss.rel &#x3D; &quot;preload&quot;;\n      newCss.as &#x3D; &quot;style&quot;;\n    &#125;\n    newCss.setAttribute(&quot;data-status&quot;, &quot;loading&quot;);\n    document.head.appendChild(newCss);\n\n    return &#123;\n      ref: newCss,\n      status: &quot;loading&quot;,\n    &#125;;\n  &#125;\n\n  return &#123;\n    ref: css,\n    status: (css.getAttribute(&quot;data-status&quot;) as Status) || &quot;ready&quot;,\n  &#125;;\n&#125;;\n\nconst useExternal &#x3D; (path?: string, options?: Options) &#x3D;&gt; &#123;\n  const [status, setStatus] &#x3D; useState&lt;Status&gt;(path ? &quot;loading&quot; : &quot;unset&quot;);\n\n  const ref &#x3D; useRef&lt;Element&gt;();\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!path) &#123;\n      &#x2F;&#x2F; 没有资源，直接拦截掉\n      setStatus(&quot;unset&quot;);\n      return;\n    &#125;\n    const pathname &#x3D; path.replace(&#x2F;[|#].*$&#x2F;, &quot;&quot;);\n\n    &#x2F;&#x2F; css\n    if (\n      options?.type &#x3D;&#x3D;&#x3D; &quot;css&quot; ||\n      (!options?.type &amp;&amp; &#x2F;(^css!|\\.css$)&#x2F;.test(pathname))\n    ) &#123;\n      const result &#x3D; loadCss(path, options?.css);\n      ref.current &#x3D; result.ref;\n      setStatus(result.status);\n      &#x2F;&#x2F; js\n    &#125; else if (\n      options?.type &#x3D;&#x3D;&#x3D; &quot;js&quot; ||\n      (!options?.type &amp;&amp; &#x2F;(^js!|\\.js$)&#x2F;.test(pathname))\n    ) &#123;\n      const result &#x3D; loadScript(path, options?.js);\n      ref.current &#x3D; result.ref;\n      setStatus(result.status);\n    &#125; else &#123;\n      &#x2F;&#x2F; 其他情况不处理\n      &#x2F;&#x2F; do nothing\n      console.error(\n        &quot;Cannot infer the type of external resource, and please provide a type (&#39;js&#39; | &#39;css&#39;). &quot; +\n          &quot;Refer to the https:&#x2F;&#x2F;ahooks.js.org&#x2F;hooks&#x2F;dom&#x2F;use-external&#x2F;#options&quot;\n      );\n    &#125;\n    &#x2F;&#x2F; 非js&#x2F;css，这里会阻止掉继续执行\n    if (!ref.current) &#123;\n      return;\n    &#125;\n\n    if (EXTERNAL_USED_COUNT[path] &#x3D;&#x3D;&#x3D; undefined) &#123;\n      EXTERNAL_USED_COUNT[path] &#x3D; 1;\n    &#125; else &#123;\n      EXTERNAL_USED_COUNT[path] +&#x3D; 1;\n    &#125;\n\n    const handler &#x3D; (event: Event) &#x3D;&gt; &#123;\n      const targetStatus &#x3D; event.type &#x3D;&#x3D;&#x3D; &quot;load&quot; ? &quot;ready&quot; : &quot;error&quot;;\n      ref.current?.setAttribute(&quot;data-status&quot;, targetStatus);\n      setStatus(targetStatus);\n    &#125;;\n    &#x2F;&#x2F; 监听资源加载情况\n    ref.current.addEventListener(&quot;load&quot;, handler);\n    ref.current.addEventListener(&quot;error&quot;, handler);\n\n    &#x2F;&#x2F; 卸载\n    return () &#x3D;&gt; &#123;\n      ref.current?.removeEventListener(&quot;load&quot;, handler);\n      ref.current?.removeEventListener(&quot;error&quot;, handler);\n\n      EXTERNAL_USED_COUNT[path] -&#x3D; 1;\n\n      if (EXTERNAL_USED_COUNT[path] &#x3D;&#x3D;&#x3D; 0) &#123;\n        ref.current?.remove(); &#x2F;&#x2F; 这里通过remove方法移除 对应的dom\n      &#125;\n\n      ref.current &#x3D; undefined;\n    &#125;;\n  &#125;, [path]);\n\n  return status;\n&#125;;\n\nexport default useExternal;</code></pre>\n\n<p><code>dom.remove()</code>移除 dom 测试</p>\n<img src=\"http://t-blog-images.aijs.top/img/202209011131253.gif\" />\n\n<h2 id=\"useHover\"><a href=\"#useHover\" class=\"headerlink\" title=\"useHover\"></a>useHover</h2><p>监听 DOM 元素是否有鼠标悬停。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useBoolean from &quot;..&#x2F;useBoolean&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\n\nexport interface Options &#123;\n  onEnter?: () &#x3D;&gt; void;\n  onLeave?: () &#x3D;&gt; void;\n  onChange?: (isHovering: boolean) &#x3D;&gt; void;\n&#125;\n\nexport default (target: BasicTarget, options?: Options): boolean &#x3D;&gt; &#123;\n  const &#123; onEnter, onLeave, onChange &#125; &#x3D; options || &#123;&#125;;\n\n  const [state, &#123; setTrue, setFalse &#125;] &#x3D; useBoolean(false);\n  &#x2F;&#x2F; 监听鼠标进入\n  useEventListener(\n    &quot;mouseenter&quot;,\n    () &#x3D;&gt; &#123;\n      onEnter?.();\n      setTrue();\n      onChange?.(true);\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n  &#x2F;&#x2F; 监听鼠标离开\n  useEventListener(\n    &quot;mouseleave&quot;,\n    () &#x3D;&gt; &#123;\n      onLeave?.();\n      setFalse();\n      onChange?.(false);\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n  &#x2F;&#x2F; isHovering 鼠标元素是否处于 hover\n  return state;\n&#125;;</code></pre>\n\n<h2 id=\"useInViewport\"><a href=\"#useInViewport\" class=\"headerlink\" title=\"useInViewport\"></a>useInViewport</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>观察元素是否在可见区域，以及元素可见比例。更多信息参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\" target=\"_blank\" >Intersection Observer API</a>。</p></blockquote>\n<details class=\"custom-details\">\n<summary>IntersectionObserver</summary>\n<p><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Intersection Observer API 提供了一种异步检测目标元素与祖先元素或 viewport 相交情况变化的方法。</p>\n<p>过去，要检测一个元素是否可见或者两个元素是否相交并不容易，很多解决办法不可靠或性能很差。然而，随着互联网的发展，这种需求却与日俱增，比如，下面这些情况都需要用到相交检测：</p>\n<ul>\n<li>图片懒加载——当图片滚动到可见时才进行加载</li>\n<li>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li>\n<li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li>\n<li>在用户看见某个区域时执行任务或播放动画</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>假如有一个无限滚动的网页，开发者使用了一个第三方库来管理整个页面的广告，又用了另外一个库来实现消息盒子和点赞，并且页面有很多动画（译注：动画往往意味着较高的性能消耗）。两个库都有自己的相交检测程序，都运行在主线程里，<span style=\"color: red\">而网站的开发者对这些库的内部实现知之甚少，所以并未意识到有什么问题</span>。但当用户滚动页面时，这些相交检测程序就会在页面滚动回调函数里不停触发调用，造成性能问题，体验效果让人失望。</p></blockquote>\n<p><code>Intersection observer</code> 的概念和用法<br><code>Intersection Observer</code> API 允许你配置一个回调函数，当以下情况发生时会被调用</p>\n<p>每当目标 (target) 元素与设备视窗或者其他指定元素发生交集的时候执行。设备视窗或者其他元素我们称它为根元素或根 (root)。<br>Observer 第一次监听目标元素的时候<br>通常，您需要关注文档最接近的可滚动祖先元素的交集更改，如果元素不是可滚动元素的后代，则默认为设备视窗。如果要观察相对于根 (root) 元素的交集，请指定根 (root) 元素为 null。</p>\n<p>无论您是使用视口还是其他元素作为根，API 都以相同的方式工作，只要目标元素的可见性发生变化，就会执行您提供的回调函数，以便它与所需的交叉点交叉。</p>\n<p>目标 (target) 元素与根 (root) 元素之间的交叉度是交叉比 (intersection ratio)。这是目标 (target) 元素相对于根 (root) 的交集百分比的表示，它的取值在 0.0 和 1.0 之间。</p>\n<p>创建一个 <code>intersection observer</code><br>创建一个 IntersectionObserver 对象，并传入相应参数和回调用函数，该回调函数将会在目标 (target) 元素和根 (root) 元素的交集大小超过阈值 (threshold) 规定的大小时候被执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let options &#x3D; &#123;\n  root: document.querySelector(&quot;#scrollArea&quot;),\n  rootMargin: &quot;0px&quot;,\n  threshold: 1.0,\n&#125;;\n\nlet observer &#x3D; new IntersectionObserver(callback, options);</code></pre>\n\n<p>阈值为 1.0 意味着目标元素完全出现在 root 选项指定的元素中可见时，回调函数将会被执行。</p>\n<p><strong>Intersection observer options</strong><br>传递到 IntersectionObserver() 构造函数的 options 对象，允许您控制观察者的回调函数的被调用时的环境。它有以下字段：</p>\n<p><strong>root</strong><br>指定根 (root) 元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为 null，则默认为浏览器视窗。</p>\n<p><strong>rootMargin</strong><br>根 (root) 元素的外边距。类似于 CSS 中的 margin 属性，比如 “10px 20px 30px 40px” (top, right, bottom, left)。如果有指定 root 参数，则 rootMargin 也可以使用百分比来取值。该属性值是用作 root 元素和 target 发生交集时候的计算交集的区域范围，使用该属性可以控制 root 元素每一边的收缩或者扩张。默认值为 0。</p>\n<p><strong>threshold</strong><br>可以是单一的 number 也可以是 number 数组，target 元素和 root 元素相交程度达到该值的时候 IntersectionObserver 注册的回调函数将会被执行。如果你只是想要探测当 target 元素的在 root 元素中的可见性超过 50% 的时候，你可以指定该属性值为 0.5。如果你想要 target 元素在 root 元素的可见程度每多 25% 就执行一次回调，那么你可以指定一个数组 [0, 0.25, 0.5, 0.75, 1]。默认值是 0 (意味着只要有一个 target 像素出现在 root 元素中，回调函数将会被执行)。该值为 1.0 含义是当 target 完全出现在 root 元素中时候 回调才会被执行。</p>\n<p><strong>Targeting an element to be observed</strong><br>创建一个 observer 后需要给定一个目标元素进行观察。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let target &#x3D; document.querySelector(&quot;#listItem&quot;);\nobserver.observe(target);</code></pre>\n\n<p>每当目标满足该 <code>IntersectionObserver</code> 指定的 <code>threshold</code> 值，回调被调用。</p>\n<p>只要目标满足为 <code>IntersectionObserver</code> 指定的阈值，就会调用回调。回调接收 <code>IntersectionObserverEntry</code> 对象和观察者的列表：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let callback &#x3D; (entries, observer) &#x3D;&gt; &#123;\n  entries.forEach((entry) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; Each entry describes an intersection change for one observed target element:\n    &#x2F;&#x2F; entry.boundingClientRect\n    &#x2F;&#x2F; entry.intersectionRatio\n    &#x2F;&#x2F; entry.intersectionRect\n    &#x2F;&#x2F; entry.isIntersecting\n    &#x2F;&#x2F; entry.rootBounds\n    &#x2F;&#x2F; entry.target\n    &#x2F;&#x2F; entry.time\n  &#125;);\n&#125;;</code></pre>\n\n<p>请留意，<span style=\"color: red\">你注册的回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 Window.requestIdleCallback() 方法</span>。</p>\n</p>\n</details>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &quot;intersection-observer&quot;;\nimport &#123; useState &#125; from &quot;react&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\nexport interface Options &#123;\n  rootMargin?: string;\n  threshold?: number | number[];\n  root?: BasicTarget&lt;Element&gt;;\n&#125;\n\nfunction useInViewport(target: BasicTarget, options?: Options) &#123;\n  &#x2F;&#x2F; inViewport\t是否可见\n  const [state, setState] &#x3D; useState&lt;boolean&gt;();\n  &#x2F;&#x2F; ratio\t当前可见比例，在每次到达 options.threshold 设置节点时更新\n  const [ratio, setRatio] &#x3D; useState&lt;number&gt;();\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target);\n      if (!el) &#123;\n        return;\n      &#125;\n\n      const observer &#x3D; new IntersectionObserver(\n        (entries) &#x3D;&gt; &#123;\n          for (const entry of entries) &#123;\n            setRatio(entry.intersectionRatio);\n            setState(entry.isIntersecting);\n          &#125;\n        &#125;,\n        &#123;\n          ...options,\n          root: getTargetElement(options?.root),\n        &#125;\n      );\n\n      observer.observe(el);\n\n      return () &#x3D;&gt; &#123;\n        observer.disconnect();\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n\n  return [state, ratio] as const;\n&#125;\n\nexport default useInViewport;</code></pre>\n\n<h2 id=\"useMutationObserver\"><a href=\"#useMutationObserver\" class=\"headerlink\" title=\"useMutationObserver\"></a>useMutationObserver</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useDeepCompareEffectWithTarget from &quot;..&#x2F;utils&#x2F;useDeepCompareWithTarget&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\n\nconst useMutationObserver &#x3D; (\n  callback: MutationCallback,\n  target: BasicTarget,\n  options: MutationObserverInit &#x3D; &#123;&#125;\n): void &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 拿到最新的回调函数，useLatest内部使用useRef实现\n  const callbackRef &#x3D; useLatest(callback);\n\n  useDeepCompareEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const element &#x3D; getTargetElement(target); &#x2F;&#x2F; 被观察的dom对象\n      if (!element) &#123;\n        return;\n      &#125;\n      &#x2F;&#x2F; 实例化一个（突变观察者）观察对象\n      const observer &#x3D; new MutationObserver(callbackRef.current);\n      &#x2F;&#x2F; 开始观察\n      observer.observe(element, options);\n\n      &#x2F;&#x2F; 卸载停止观察\n      return () &#x3D;&gt; &#123;\n        if (observer) &#123;\n          observer.disconnect();\n        &#125;\n      &#125;;\n    &#125;,\n    [options],\n    target\n  );\n&#125;;\n\nexport default useMutationObserver;</code></pre>\n\n<details class=\"custom-details\">\n<summary>MutationObserver</summary>\n<p><code>MutationObserver</code> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>\n<p><strong>构造函数</strong><br>MutationObserver()<br>创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。</p>\n<p><strong>方法</strong><br>disconnect()<br>阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe() 方法，该观察者对象包含的回调函数都不会再被调用。</p>\n<p>observe()<br>配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。</p>\n<p>takeRecords()<br>从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。</p>\n<p>示例改编自 <a href=\"https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\" target=\"_blank\" >这篇博客</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 选择需要观察变动的节点\nconst targetNode &#x3D; document.getElementById(&quot;some-id&quot;);\n\n&#x2F;&#x2F; 观察器的配置（需要观察什么变动）\nconst config &#x3D; &#123; attributes: true, childList: true, subtree: true &#125;;\n\n&#x2F;&#x2F; 当观察到变动时执行的回调函数\nconst callback &#x3D; function (mutationsList, observer) &#123;\n  &#x2F;&#x2F; Use traditional &#39;for loops&#39; for IE 11\n  for (let mutation of mutationsList) &#123;\n    if (mutation.type &#x3D;&#x3D;&#x3D; &quot;childList&quot;) &#123;\n      console.log(&quot;A child node has been added or removed.&quot;);\n    &#125; else if (mutation.type &#x3D;&#x3D;&#x3D; &quot;attributes&quot;) &#123;\n      console.log(&quot;The &quot; + mutation.attributeName + &quot; attribute was modified.&quot;);\n    &#125;\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 创建一个观察器实例并传入回调函数\nconst observer &#x3D; new MutationObserver(callback);\n\n&#x2F;&#x2F; 以上述配置开始观察目标节点\nobserver.observe(targetNode, config);\n\n&#x2F;&#x2F; 之后，可停止观察\nobserver.disconnect();</code></pre>\n\n\n</details>\n<h2 id=\"useKeyPress【不是很理解】\"><a href=\"#useKeyPress【不是很理解】\" class=\"headerlink\" title=\"useKeyPress【不是很理解】\"></a>useKeyPress【不是很理解】</h2><p>代码有点长，也不是很重要</p>\n<details class=\"custom-details\">\n<summary>useKeyPress 源码</summary>\n<p><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useLatest from &quot;..&#x2F;useLatest&quot;;\nimport &#123; isFunction, isNumber, isString &#125; from &quot;..&#x2F;utils&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useDeepCompareEffectWithTarget from &quot;..&#x2F;utils&#x2F;useDeepCompareWithTarget&quot;;\n\nexport type KeyPredicate &#x3D; (event: KeyboardEvent) &#x3D;&gt; boolean;\nexport type keyType &#x3D; number | string;\nexport type KeyFilter &#x3D;\n  | keyType\n  | keyType[]\n  | ((event: KeyboardEvent) &#x3D;&gt; boolean);\nexport type EventHandler &#x3D; (event: KeyboardEvent) &#x3D;&gt; void;\nexport type KeyEvent &#x3D; &quot;keydown&quot; | &quot;keyup&quot;;\n\nexport type Target &#x3D; BasicTarget&lt;HTMLElement | Document | Window&gt;;\n\nexport type Options &#x3D; &#123;\n  events?: KeyEvent[];\n  target?: Target;\n  exactMatch?: boolean;\n&#125;;\n\n&#x2F;&#x2F; 键盘事件 keyCode 别名\nconst aliasKeyCodeMap &#x3D; &#123;\n  &quot;0&quot;: 48,\n  &quot;1&quot;: 49,\n  &quot;2&quot;: 50,\n  &quot;3&quot;: 51,\n  &quot;4&quot;: 52,\n  &quot;5&quot;: 53,\n  &quot;6&quot;: 54,\n  &quot;7&quot;: 55,\n  &quot;8&quot;: 56,\n  &quot;9&quot;: 57,\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  ctrl: 17,\n  alt: 18,\n  pausebreak: 19,\n  capslock: 20,\n  esc: 27,\n  space: 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  leftarrow: 37,\n  uparrow: 38,\n  rightarrow: 39,\n  downarrow: 40,\n  insert: 45,\n  delete: 46,\n  a: 65,\n  b: 66,\n  c: 67,\n  d: 68,\n  e: 69,\n  f: 70,\n  g: 71,\n  h: 72,\n  i: 73,\n  j: 74,\n  k: 75,\n  l: 76,\n  m: 77,\n  n: 78,\n  o: 79,\n  p: 80,\n  q: 81,\n  r: 82,\n  s: 83,\n  t: 84,\n  u: 85,\n  v: 86,\n  w: 87,\n  x: 88,\n  y: 89,\n  z: 90,\n  leftwindowkey: 91,\n  rightwindowkey: 92,\n  selectkey: 93,\n  numpad0: 96,\n  numpad1: 97,\n  numpad2: 98,\n  numpad3: 99,\n  numpad4: 100,\n  numpad5: 101,\n  numpad6: 102,\n  numpad7: 103,\n  numpad8: 104,\n  numpad9: 105,\n  multiply: 106,\n  add: 107,\n  subtract: 109,\n  decimalpoint: 110,\n  divide: 111,\n  f1: 112,\n  f2: 113,\n  f3: 114,\n  f4: 115,\n  f5: 116,\n  f6: 117,\n  f7: 118,\n  f8: 119,\n  f9: 120,\n  f10: 121,\n  f11: 122,\n  f12: 123,\n  numlock: 144,\n  scrolllock: 145,\n  semicolon: 186,\n  equalsign: 187,\n  comma: 188,\n  dash: 189,\n  period: 190,\n  forwardslash: 191,\n  graveaccent: 192,\n  openbracket: 219,\n  backslash: 220,\n  closebracket: 221,\n  singlequote: 222,\n&#125;;\n\n&#x2F;&#x2F; 修饰键\nconst modifierKey &#x3D; &#123;\n  ctrl: (event: KeyboardEvent) &#x3D;&gt; event.ctrlKey,\n  shift: (event: KeyboardEvent) &#x3D;&gt; event.shiftKey,\n  alt: (event: KeyboardEvent) &#x3D;&gt; event.altKey,\n  meta: (event: KeyboardEvent) &#x3D;&gt; event.metaKey,\n&#125;;\n\n&#x2F;&#x2F; 根据 event 计算激活键数量\nfunction countKeyByEvent(event: KeyboardEvent) &#123;\n  const countOfModifier &#x3D; Object.keys(modifierKey).reduce((total, key) &#x3D;&gt; &#123;\n    if (modifierKey[key](event)) &#123;\n      return total + 1;\n    &#125;\n\n    return total;\n  &#125;, 0);\n\n  &#x2F;&#x2F; 16 17 18 91 92 是修饰键的 keyCode，如果 keyCode 是修饰键，那么激活数量就是修饰键的数量，如果不是，那么就需要 +1\n  return [16, 17, 18, 91, 92].includes(event.keyCode)\n    ? countOfModifier\n    : countOfModifier + 1;\n&#125;\n\n&#x2F;**\n * 判断按键是否激活\n * @param [event: KeyboardEvent]键盘事件\n * @param [keyFilter: any] 当前键\n * @returns Boolean\n *&#x2F;\nfunction genFilterKey(\n  event: KeyboardEvent,\n  keyFilter: keyType,\n  exactMatch: boolean\n) &#123;\n  &#x2F;&#x2F; 浏览器自动补全 input 的时候，会触发 keyDown、keyUp 事件，但此时 event.key 等为空\n  if (!event.key) &#123;\n    return false;\n  &#125;\n\n  &#x2F;&#x2F; 数字类型直接匹配事件的 keyCode\n  if (isNumber(keyFilter)) &#123;\n    return event.keyCode &#x3D;&#x3D;&#x3D; keyFilter;\n  &#125;\n\n  &#x2F;&#x2F; 字符串依次判断是否有组合键\n  const genArr &#x3D; keyFilter.split(&quot;.&quot;);\n  let genLen &#x3D; 0;\n\n  for (const key of genArr) &#123;\n    &#x2F;&#x2F; 组合键\n    const genModifier &#x3D; &#x2F;** 修饰键*&#x2F; modifierKey[key];\n    &#x2F;&#x2F; keyCode 别名\n    const aliasKeyCode &#x3D;\n      &#x2F;**键盘事件 keyCode 别名*&#x2F; aliasKeyCodeMap[key.toLowerCase()];\n\n    if (\n      (genModifier &amp;&amp; genModifier(event)) ||\n      (aliasKeyCode &amp;&amp; aliasKeyCode &#x3D;&#x3D;&#x3D; event.keyCode)\n    ) &#123;\n      genLen++;\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * 需要判断触发的键位和监听的键位完全一致，判断方法就是触发的键位里有且等于监听的键位\n   * genLen &#x3D;&#x3D;&#x3D; genArr.length 能判断出来触发的键位里有监听的键位\n   * countKeyByEvent(event) &#x3D;&#x3D;&#x3D; genArr.length 判断出来触发的键位数量里有且等于监听的键位数量\n   * 主要用来防止按组合键其子集也会触发的情况，例如监听 ctrl+a 会触发监听 ctrl 和 a 两个键的事件。\n   *&#x2F;\n  if (exactMatch) &#123;\n    return genLen &#x3D;&#x3D;&#x3D; genArr.length &amp;&amp; countKeyByEvent(event) &#x3D;&#x3D;&#x3D; genArr.length;\n  &#125;\n  return genLen &#x3D;&#x3D;&#x3D; genArr.length;\n&#125;\n\n&#x2F;**\n * 键盘输入预处理方法\n * @param [keyFilter: any] 当前键\n * @returns () &#x3D;&gt; Boolean\n *&#x2F;\nfunction genKeyFormatter(\n  keyFilter: KeyFilter,\n  exactMatch: boolean\n): KeyPredicate &#123;\n  if (isFunction(keyFilter)) &#123;\n    return keyFilter;\n  &#125;\n  if (isString(keyFilter) || isNumber(keyFilter)) &#123;\n    return (event: KeyboardEvent) &#x3D;&gt; genFilterKey(event, keyFilter, exactMatch);\n  &#125;\n  if (Array.isArray(keyFilter)) &#123;\n    return (event: KeyboardEvent) &#x3D;&gt;\n      keyFilter.some((item) &#x3D;&gt; genFilterKey(event, item, exactMatch));\n  &#125;\n  return keyFilter ? () &#x3D;&gt; true : () &#x3D;&gt; false;\n&#125;\n\nconst defaultEvents: KeyEvent[] &#x3D; [&quot;keydown&quot;];\n\nfunction useKeyPress(\n  keyFilter: KeyFilter, &#x2F;&#x2F; 支持 keyCode、别名、组合键、数组，自定义函数\n  eventHandler: EventHandler, &#x2F;&#x2F; 回调函数\n  option?: Options &#x2F;&#x2F; 可选配置项\n) &#123;\n  const &#123; events &#x3D; defaultEvents, target, exactMatch &#x3D; false &#125; &#x3D; option || &#123;&#125;;\n  const eventHandlerRef &#x3D; useLatest(eventHandler); &#x2F;&#x2F; 缓存了下\n  const keyFilterRef &#x3D; useLatest(keyFilter); &#x2F;&#x2F; 缓存了下\n\n  useDeepCompareEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target, window);\n      if (!el) &#123;\n        return;\n      &#125;\n\n      const callbackHandler &#x3D; (event: KeyboardEvent) &#x3D;&gt; &#123;\n        const genGuard: KeyPredicate &#x3D; genKeyFormatter(\n          keyFilterRef.current,\n          exactMatch\n        );\n        if (genGuard(event)) &#123;\n          &#x2F;&#x2F; 是不是匹配到了，匹配到了执行回调\n          return eventHandlerRef.current?.(event);\n        &#125;\n      &#125;;\n\n      for (const eventName of events) &#123;\n        el?.addEventListener?.(eventName, callbackHandler);\n      &#125;\n      return () &#x3D;&gt; &#123;\n        for (const eventName of events) &#123;\n          el?.removeEventListener?.(eventName, callbackHandler);\n        &#125;\n      &#125;;\n    &#125;,\n    [events],\n    target\n  );\n&#125;\n\nexport default useKeyPress;</code></pre>\n\n</p>\n</details>\n<h2 id=\"useDrop-amp-useDrag\"><a href=\"#useDrop-amp-useDrag\" class=\"headerlink\" title=\"useDrop &amp; useDrag\"></a>useDrop &amp; useDrag</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>处理元素拖拽的 Hook。</p>\n<p>useDrop 可以单独使用来接收文件、文字和网址的拖拽。</p>\n<p>useDrag 允许一个 DOM 节点被拖拽，需要配合 useDrop 使用。</p>\n<p>向节点内触发粘贴动作也会被视为拖拽。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\nexport interface Options &#123;\n  onDragStart?: (event: React.DragEvent) &#x3D;&gt; void;\n  onDragEnd?: (event: React.DragEvent) &#x3D;&gt; void;\n&#125;\n\nconst useDrag &#x3D; &lt;T&gt;(data: T, target: BasicTarget, options: Options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  const optionsRef &#x3D; useLatest(options);\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const targetElement &#x3D; getTargetElement(target);\n      &#x2F;&#x2F; 不具备增加监听的方法\n      if (!targetElement?.addEventListener) &#123;\n        return;\n      &#125;\n\n      const onDragStart &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        optionsRef.current.onDragStart?.(event);\n        event.dataTransfer.setData(&quot;custom&quot;, JSON.stringify(data));\n      &#125;;\n\n      const onDragEnd &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        optionsRef.current.onDragEnd?.(event);\n      &#125;;\n\n      targetElement.setAttribute(&quot;draggable&quot;, &quot;true&quot;);\n      &#x2F;&#x2F; 绑定\n      targetElement.addEventListener(&quot;dragstart&quot;, onDragStart as any);\n      targetElement.addEventListener(&quot;dragend&quot;, onDragEnd as any);\n\n      return () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 解绑定\n        targetElement.removeEventListener(&quot;dragstart&quot;, onDragStart as any);\n        targetElement.removeEventListener(&quot;dragend&quot;, onDragEnd as any);\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n&#125;;\n\nexport default useDrag;</code></pre>\n\n<p>useDrop</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\n\nexport interface Options &#123;\n  onFiles?: (files: File[], event?: React.DragEvent) &#x3D;&gt; void;\n  onUri?: (url: string, event?: React.DragEvent) &#x3D;&gt; void;\n  onDom?: (content: any, event?: React.DragEvent) &#x3D;&gt; void;\n  onText?: (text: string, event?: React.ClipboardEvent) &#x3D;&gt; void;\n  onDragEnter?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onDragOver?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onDragLeave?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onDrop?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onPaste?: (event?: React.ClipboardEvent) &#x3D;&gt; void;\n&#125;\n\nconst useDrop &#x3D; (target: BasicTarget, options: Options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  const optionsRef &#x3D; useLatest(options);\n\n  &#x2F;&#x2F; https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;26459269\n  const dragEnterTarget &#x3D; useRef&lt;any&gt;();\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const targetElement &#x3D; getTargetElement(target);\n      if (!targetElement?.addEventListener) &#123;\n        return;\n      &#125;\n\n      const onData &#x3D; (\n        dataTransfer: DataTransfer, &#x2F;&#x2F; 拖数据\n        event: React.DragEvent | React.ClipboardEvent\n      ) &#x3D;&gt; &#123;\n        const uri &#x3D; dataTransfer.getData(&quot;text&#x2F;uri-list&quot;);\n        const dom &#x3D; dataTransfer.getData(&quot;custom&quot;);\n\n        if (dom &amp;&amp; optionsRef.current.onDom) &#123;\n          let data &#x3D; dom;\n          try &#123;\n            data &#x3D; JSON.parse(dom);\n          &#125; catch (e) &#123;\n            data &#x3D; dom;\n          &#125;\n          optionsRef.current.onDom(data, event as React.DragEvent);\n          return;\n        &#125;\n        &#x2F;&#x2F; uri数据类型\n        if (uri &amp;&amp; optionsRef.current.onUri) &#123;\n          optionsRef.current.onUri(uri, event as React.DragEvent);\n          return;\n        &#125;\n        &#x2F;&#x2F; 文件数据类型\n        if (\n          dataTransfer.files &amp;&amp;\n          dataTransfer.files.length &amp;&amp;\n          optionsRef.current.onFiles\n        ) &#123;\n          optionsRef.current.onFiles(\n            Array.from(dataTransfer.files),\n            event as React.DragEvent\n          );\n          return;\n        &#125;\n        &#x2F;&#x2F; 文本数据类型\n        if (\n          dataTransfer.items &amp;&amp;\n          dataTransfer.items.length &amp;&amp;\n          optionsRef.current.onText\n        ) &#123;\n          dataTransfer.items[0].getAsString((text) &#x3D;&gt; &#123;\n            optionsRef.current.onText!(text, event as React.ClipboardEvent);\n          &#125;);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 拖拽进入\n      const onDragEnter &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        event.preventDefault();\n        event.stopPropagation();\n\n        dragEnterTarget.current &#x3D; event.target;\n        optionsRef.current.onDragEnter?.(event);\n      &#125;;\n      &#x2F;&#x2F; 拖拽中\n      const onDragOver &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        event.preventDefault();\n        optionsRef.current.onDragOver?.(event);\n      &#125;;\n      &#x2F;&#x2F; 拖拽出去\n      const onDragLeave &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        if (event.target &#x3D;&#x3D;&#x3D; dragEnterTarget.current) &#123;\n          optionsRef.current.onDragLeave?.(event);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 放下\n      const onDrop &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        event.preventDefault();\n        onData(event.dataTransfer, event);\n        optionsRef.current.onDrop?.(event);\n      &#125;;\n      &#x2F;&#x2F; 粘贴\n      const onPaste &#x3D; (event: React.ClipboardEvent) &#x3D;&gt; &#123;\n        onData(event.clipboardData, event);\n        optionsRef.current.onPaste?.(event);\n      &#125;;\n\n      targetElement.addEventListener(&quot;dragenter&quot;, onDragEnter as any);\n      targetElement.addEventListener(&quot;dragover&quot;, onDragOver as any);\n      targetElement.addEventListener(&quot;dragleave&quot;, onDragLeave as any);\n      targetElement.addEventListener(&quot;drop&quot;, onDrop as any);\n      targetElement.addEventListener(&quot;paste&quot;, onPaste as any);\n\n      return () &#x3D;&gt; &#123;\n        targetElement.removeEventListener(&quot;dragenter&quot;, onDragEnter as any);\n        targetElement.removeEventListener(&quot;dragover&quot;, onDragOver as any);\n        targetElement.removeEventListener(&quot;dragleave&quot;, onDragLeave as any);\n        targetElement.removeEventListener(&quot;drop&quot;, onDrop as any);\n        targetElement.removeEventListener(&quot;paste&quot;, onPaste as any);\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n&#125;;\n\nexport default useDrop;</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/paste_event\" target=\"_blank\" >原生事件</a></p>\n<h2 id=\"useDocumentVisibility\"><a href=\"#useDocumentVisibility\" class=\"headerlink\" title=\"useDocumentVisibility\"></a>useDocumentVisibility</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useState &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;\n\ntype VisibilityState &#x3D; &quot;hidden&quot; | &quot;visible&quot; | &quot;prerender&quot; | undefined;\n\nconst getVisibility &#x3D; () &#x3D;&gt; &#123;\n  if (!isBrowser) &#123;\n    return &quot;visible&quot;;\n  &#125;\n  return document.visibilityState;\n&#125;;\n\nfunction useDocumentVisibility(): VisibilityState &#123;\n  const [documentVisibility, setDocumentVisibility] &#x3D; useState(() &#x3D;&gt;\n    getVisibility()\n  );\n\n  useEventListener(\n    &quot;visibilitychange&quot;,\n    () &#x3D;&gt; &#123;\n      setDocumentVisibility(getVisibility());\n    &#125;,\n    &#123;\n      target: () &#x3D;&gt; document,\n    &#125;\n  );\n\n  return documentVisibility;\n&#125;\n\nexport default useDocumentVisibility;</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState\" target=\"_blank\" >见</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>典型用法是防止当页面正在渲染时加载资源，或者当页面在背景中或窗口最小化时禁止某些活动。</p></blockquote>\n<p>猜想：首页<code>prerender</code>后<code>visible</code>前，可以作为<code>performance</code>上报点？</p>\n<h2 id=\"useResponsive\"><a href=\"#useResponsive\" class=\"headerlink\" title=\"useResponsive\"></a>useResponsive</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;\n\ntype Subscriber &#x3D; () &#x3D;&gt; void;\n&#x2F;&#x2F; set类型，保证唯一性，因为useEffect可能存在重复执行的情况\nconst subscribers &#x3D; new Set&lt;Subscriber&gt;();\n\ntype ResponsiveConfig &#x3D; Record&lt;string, number&gt;;\ntype ResponsiveInfo &#x3D; Record&lt;string, boolean&gt;;\n\nlet info: ResponsiveInfo;\n\nlet responsiveConfig: ResponsiveConfig &#x3D; &#123;\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n&#125;;\n&#x2F;&#x2F; 处理size变更\nfunction handleResize() &#123;\n  &#x2F;&#x2F; 这里缓存上次的info\n  const oldInfo &#x3D; info;\n  &#x2F;&#x2F; 这里计算新的info\n  calculate();\n  &#x2F;&#x2F; 前后发生变化，就会实行订阅的方法\n  if (oldInfo &#x3D;&#x3D;&#x3D; info) return;\n  &#x2F;&#x2F; 将收集到的观察者统统执行一遍\n  for (const subscriber of subscribers) &#123;\n    subscriber();\n  &#125;\n&#125;\n&#x2F;&#x2F; 避免重复执行\nlet listening &#x3D; false;\n&#x2F;&#x2F; 计算\nfunction calculate() &#123;\n  const width &#x3D; window.innerWidth;\n  const newInfo &#x3D; &#123;&#125; as ResponsiveInfo;\n  let shouldUpdate &#x3D; false;\n  for (const key of Object.keys(responsiveConfig)) &#123;\n    newInfo[key] &#x3D; width &gt;&#x3D; responsiveConfig[key];\n    if (newInfo[key] !&#x3D;&#x3D; info[key]) &#123;\n      shouldUpdate &#x3D; true;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 需要更新\n  if (shouldUpdate) &#123;\n    info &#x3D; newInfo;\n  &#125;\n&#125;\n&#x2F;&#x2F; 配置响应\n&#x2F;&#x2F; 只需配置一次，请勿在组件中重复调用该方法\n&#x2F;&#x2F; 每次调用都会重新计算\nexport function configResponsive(config: ResponsiveConfig) &#123;\n  responsiveConfig &#x3D; config;\n  if (info) calculate();\n&#125;\n\nexport function useResponsive() &#123;\n  &#x2F;&#x2F; 客户端渲染\n  if (isBrowser &amp;&amp; !listening) &#123;\n    info &#x3D; &#123;&#125;;\n    calculate();\n    window.addEventListener(&quot;resize&quot;, handleResize);\n    listening &#x3D; true;\n  &#125;\n  const [state, setState] &#x3D; useState&lt;ResponsiveInfo&gt;(info);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 非客户端渲染，直接拦掉\n    if (!isBrowser) return;\n    &#x2F;&#x2F; 定义一个订阅者函数\n    const subscriber &#x3D; () &#x3D;&gt; &#123;\n      setState(info);\n    &#125;;\n    &#x2F;&#x2F; 加入订阅\n    subscribers.add(subscriber);\n    return () &#x3D;&gt; &#123;\n      subscribers.delete(subscriber);\n      if (subscribers.size &#x3D;&#x3D;&#x3D; 0) &#123;\n        window.removeEventListener(&quot;resize&quot;, handleResize);\n        listening &#x3D; false;\n      &#125;\n    &#125;;\n  &#125;, []);\n\n  return state;\n&#125;</code></pre>\n\n<p>小插曲：github octotree loading</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.octotree-show\n  .octotree-sidebar.octotree-github-sidebar\n  .octotree-spin\n  .octotree-spin--loader &#123;\n  width: 16px;\n  height: 16px;\n  border-radius: 50%;\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent rgb(106, 115, 125) rgb(106, 115, 125) transparent;\n  border-image: initial;\n  border-top: 2px solid transparent;\n  border-left: 2px solid transparent;\n  animation: 0.5s linear 0s infinite normal none running loading;\n&#125;</code></pre>\n\n<h2 id=\"useScroll\"><a href=\"#useScroll\" class=\"headerlink\" title=\"useScroll\"></a>useScroll</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import useRafState from &quot;..&#x2F;useRafState&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\ntype Position &#x3D; &#123; left: number; top: number &#125;;\n&#x2F;&#x2F; 我把 BasicTarget 拿过来放在这里，不会有太多割裂感\n&#x2F;&#x2F; export type BasicTarget&lt;T extends TargetType &#x3D; Element&gt; &#x3D;\n&#x2F;&#x2F;   | (() &#x3D;&gt; TargetValue&lt;T&gt;) &#x2F;&#x2F; 函数\n&#x2F;&#x2F;   | TargetValue&lt;T&gt; &#x2F;&#x2F; 直接dom\n&#x2F;&#x2F;   | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;; &#x2F;&#x2F; ref\nexport type Target &#x3D; BasicTarget&lt;Element | Document&gt;;\nexport type ScrollListenController &#x3D; (val: Position) &#x3D;&gt; boolean;\n\nfunction useScroll(\n  target?: Target,\n  shouldUpdate: ScrollListenController &#x3D; () &#x3D;&gt; true\n): Position | undefined &#123;\n  const [position, setPosition] &#x3D; useRafState&lt;Position&gt;();\n\n  const shouldUpdateRef &#x3D; useLatest(shouldUpdate);\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target, document &#x2F;**兜底值 *&#x2F;);\n      if (!el) &#123;\n        return;\n      &#125;\n      const updatePosition &#x3D; () &#x3D;&gt; &#123;\n        let newPosition: Position;\n        &#x2F;&#x2F; 是不是document\n        if (el &#x3D;&#x3D;&#x3D; document) &#123;\n          &#x2F;&#x2F; ？scrollingElement啥玩意\n          &#x2F;&#x2F; @link https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Document&#x2F;scrollingElement\n          &#x2F;&#x2F; scrollingElement （ Document 的只读属性）返回滚动文档的 Element 对象的引用。\n          &#x2F;&#x2F; 在标准模式下，这是文档的根元素， document.documentElement.\n          &#x2F;&#x2F; 当在怪异模式下， scrollingElement 属性返回 HTML body 元素（若不存在返回 null ）。\n          if (document.scrollingElement) &#123;\n            newPosition &#x3D; &#123;\n              left: document.scrollingElement.scrollLeft,\n              top: document.scrollingElement.scrollTop,\n            &#125;;\n          &#125; else &#123;\n            &#x2F;&#x2F; When in quirks mode, the scrollingElement attribute returns the HTML body element if it exists and is potentially scrollable, otherwise it returns null.\n            &#x2F;&#x2F; 在quirks模式下，scrollingElement属性返回HTML主体元素（如果它存在并且可能是可滚动的），否则返回null。\n            &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Document&#x2F;scrollingElement\n            &#x2F;&#x2F; https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;28633221&#x2F;document-body-scrolltop-firefox-returns-0-only-js\n            newPosition &#x3D; &#123;\n              left: Math.max(\n                &#x2F;&#x2F; 兼容写法\n                window.pageXOffset,\n                document.documentElement.scrollLeft,\n                document.body.scrollLeft\n              ),\n              top: Math.max(\n                &#x2F;&#x2F; 兼容写法\n                window.pageYOffset,\n                document.documentElement.scrollTop,\n                document.body.scrollTop\n              ),\n            &#125;;\n          &#125;\n        &#125; else &#123;\n          newPosition &#x3D; &#123;\n            left: (el as Element).scrollLeft,\n            top: (el as Element).scrollTop,\n          &#125;;\n        &#125;\n        &#x2F;&#x2F; 默认直接返回true\n        if (shouldUpdateRef.current(newPosition)) &#123;\n          setPosition(newPosition);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 立即执行一次\n      updatePosition();\n      &#x2F;&#x2F; 监听到scroll执行\n      el.addEventListener(&quot;scroll&quot;, updatePosition);\n      return () &#x3D;&gt; &#123;\n        el.removeEventListener(&quot;scroll&quot;, updatePosition);\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n\n  return position;\n&#125;\n\nexport default useScroll;</code></pre>\n\n<h2 id=\"useSize\"><a href=\"#useSize\" class=\"headerlink\" title=\"useSize\"></a>useSize</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 这里用了polyfill\nimport ResizeObserver from &quot;resize-observer-polyfill&quot;;\nimport useRafState from &quot;..&#x2F;useRafState&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useIsomorphicLayoutEffectWithTarget from &quot;..&#x2F;utils&#x2F;useIsomorphicLayoutEffectWithTarget&quot;;\n\ntype Size &#x3D; &#123; width: number; height: number &#125;;\n\nfunction useSize(target: BasicTarget): Size | undefined &#123;\n  const [state, setState] &#x3D; useRafState&lt;Size&gt;();\n\n  useIsomorphicLayoutEffectWithTarget(\n    &#x2F;&#x2F; useEffect第一个函数\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target);\n\n      if (!el) &#123;\n        return;\n      &#125;\n\n      const resizeObserver &#x3D; new ResizeObserver((entries) &#x3D;&gt; &#123;\n        entries.forEach((entry) &#x3D;&gt; &#123;\n          const &#123; clientWidth, clientHeight &#125; &#x3D; entry.target;\n          setState(&#123;\n            width: clientWidth,\n            height: clientHeight,\n          &#125;);\n        &#125;);\n      &#125;);\n      &#x2F;&#x2F; 开始观察某个dom\n      resizeObserver.observe(el);\n      return () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 停止观察dom\n        resizeObserver.disconnect();\n      &#125;;\n    &#125;,\n    &#x2F;&#x2F; useEffect的依赖项\n    [],\n    target &#x2F;&#x2F; 也参与依赖项计算 depsAreSame\n  );\n\n  return state;\n&#125;\n\nexport default useSize;</code></pre>\n\n<h2 id=\"useIsomorphicLayoutEffectWithTarget\"><a href=\"#useIsomorphicLayoutEffectWithTarget\" class=\"headerlink\" title=\"useIsomorphicLayoutEffectWithTarget\"></a>useIsomorphicLayoutEffectWithTarget</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import isBrowser from &quot;.&#x2F;isBrowser&quot;;\nimport useEffectWithTarget from &quot;.&#x2F;useEffectWithTarget&quot;;\nimport useLayoutEffectWithTarget from &quot;.&#x2F;useLayoutEffectWithTarget&quot;;\n&#x2F;&#x2F; 对用不同的执行环境，进行区分\nconst useIsomorphicLayoutEffectWithTarget &#x3D; isBrowser\n  ? useLayoutEffectWithTarget\n  : useEffectWithTarget;\n\nexport default useIsomorphicLayoutEffectWithTarget;</code></pre>\n\n<h2 id=\"useReactive-（这个比较特别）\"><a href=\"#useReactive-（这个比较特别）\" class=\"headerlink\" title=\"useReactive （这个比较特别）\"></a>useReactive （这个比较特别）</h2><p>提供一种数据响应式的操作体验，定义数据状态不需要写 useState，直接修改属性即可刷新视图。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useRef &#125; from &quot;react&quot;;\nimport useCreation from &quot;..&#x2F;useCreation&quot;;\nimport useUpdate from &quot;..&#x2F;useUpdate&quot;;\nimport &#123; isObject &#125; from &quot;..&#x2F;utils&quot;;\n\n&#x2F;&#x2F; k:v 原对象:代理过的对象\nconst proxyMap &#x3D; new WeakMap();\n&#x2F;&#x2F; k:v 代理过的对象:原对象\nconst rawMap &#x3D; new WeakMap();\n\nfunction observer&lt;T extends Record&lt;string, any&gt;&gt;(\n  initialVal: T,\n  cb: () &#x3D;&gt; void\n): T &#123;\n  const existingProxy &#x3D; proxyMap.get(initialVal);\n\n  &#x2F;&#x2F; 添加缓存 防止重新构建proxy\n  &#x2F;&#x2F; 如果重复构建，会怎样？\n  if (existingProxy) &#123;\n    return existingProxy;\n  &#125;\n\n  &#x2F;&#x2F; 防止代理已经代理过的对象 浏览器奔溃\n  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;839\n  if (rawMap.has(initialVal)) &#123;\n    return initialVal;\n  &#125;\n\n  const proxy &#x3D; new Proxy&lt;T&gt;(initialVal, &#123;\n    get(target, key, receiver) &#123;\n      const res &#x3D; Reflect.get(target, key, receiver);\n      &#x2F;&#x2F; 把所有的嵌套对象都给监听\n      return isObject(res) ? observer(res, cb) : Reflect.get(target, key);\n    &#125;,\n    set(target, key, val) &#123;\n      const ret &#x3D; Reflect.set(target, key, val);\n      cb();\n      return ret;\n    &#125;,\n    deleteProperty(target, key) &#123;\n      const ret &#x3D; Reflect.deleteProperty(target, key);\n      cb();\n      return ret;\n    &#125;,\n  &#125;);\n\n  proxyMap.set(initialVal, proxy);\n  rawMap.set(proxy, initialVal);\n\n  return proxy;\n&#125;\n\nfunction useReactive&lt;S extends Record&lt;string, any&gt;&gt;(initialState: S): S &#123;\n  const update &#x3D; useUpdate();\n  const stateRef &#x3D; useRef&lt;S&gt;(initialState);\n  &#x2F;&#x2F; useCreation，非必要不更新\n  const state &#x3D; useCreation(\n    &#x2F;**工厂*&#x2F; () &#x3D;&gt; &#123;\n      return observer(\n        stateRef.current &#x2F;**initialVal *&#x2F;,\n        &#x2F;**回调*&#x2F; () &#x3D;&gt; &#123;\n          update(); &#x2F;&#x2F; 刷新，我比较好奇，这么刷新，react傻呆呆又要重新计算一遍吗\n        &#125;\n      );\n    &#125;,\n    []\n  );\n\n  return state;\n&#125;\n\nexport default useReactive;</code></pre>\n\n<h2 id=\"useCreation\"><a href=\"#useCreation\" class=\"headerlink\" title=\"useCreation\"></a>useCreation</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>useCreation 是 useMemo 或 useRef 的替代品。</p>\n<p>因为 useMemo 不能保证被 memo 的值一定不会被重计算，而 useCreation 可以保证这一点。以下为 React 官方文档中的介绍</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import type &#123; DependencyList &#125; from &quot;react&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\nimport depsAreSame from &quot;..&#x2F;utils&#x2F;depsAreSame&quot;;\n\nexport default function useCreation&lt;T&gt;(factory: () &#x3D;&gt; T, deps: DependencyList) &#123;\n  const &#123; current &#125; &#x3D; useRef(&#123;\n    deps,\n    obj: undefined as undefined | T,\n    initialized: false,\n  &#125;);\n  &#x2F;&#x2F; 发生变化时候，就会重新计算\n  if (current.initialized &#x3D;&#x3D;&#x3D; false || !depsAreSame(current.deps, deps)) &#123;\n    current.deps &#x3D; deps;\n    current.obj &#x3D; factory(); &#x2F;&#x2F; 工厂\n    current.initialized &#x3D; true;\n  &#125;\n  return current.obj as T;\n&#125;</code></pre>\n\n<h2 id=\"useTrackedEffect\"><a href=\"#useTrackedEffect\" class=\"headerlink\" title=\"useTrackedEffect\"></a>useTrackedEffect</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import type &#123; DependencyList &#125; from &quot;react&quot;;\nimport &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\ntype Effect &#x3D; (\n  changes?: number[],\n  previousDeps?: DependencyList, &#x2F;&#x2F; 之前的依赖\n  currentDeps?: DependencyList &#x2F;&#x2F; 之后的依赖\n) &#x3D;&gt; void | (() &#x3D;&gt; void);\n\nconst diffTwoDeps &#x3D; (deps1?: DependencyList, deps2?: DependencyList) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;Let&#39;s do a reference equality check on 2 dependency list.\n  &#x2F;&#x2F;If deps1 is defined, we iterate over deps1 and do comparison on each element with equivalent element from deps2\n  &#x2F;&#x2F;As this func is used only in this hook, we assume 2 deps always have same length.\n  return deps1\n    ? &#x2F;&#x2F; deps1（缓存）有， deps2 有 则用Object.is比较\n      deps1\n        .map((_ele, idx) &#x3D;&gt; (!Object.is(deps1[idx], deps2?.[idx]) ? idx : -1))\n        .filter((ele) &#x3D;&gt; ele &gt;&#x3D; 0)\n    : &#x2F;&#x2F; deps1（缓存）没有， deps2 有 则把第二个取个遍，否则，返回[]\n    deps2\n    ? deps2.map((_ele, idx) &#x3D;&gt; idx)\n    : [];\n&#125;;\n\nconst useTrackedEffect &#x3D; (effect: Effect, deps?: DependencyList) &#x3D;&gt; &#123;\n  const previousDepsRef &#x3D; useRef&lt;DependencyList&gt;();\n\n  useEffect(() &#x3D;&gt; &#123;\n    const changes &#x3D; diffTwoDeps(\n      previousDepsRef.current &#x2F;**之前的依赖缓存了 *&#x2F;,\n      deps\n    );\n    const previousDeps &#x3D; previousDepsRef.current;\n    previousDepsRef.current &#x3D; deps;\n    return effect(changes, previousDeps, deps);\n  &#125;, deps);\n&#125;;\n\nexport default useTrackedEffect;</code></pre>\n\n<h2 id=\"useVirtualList\"><a href=\"#useVirtualList\" class=\"headerlink\" title=\"useVirtualList\"></a>useVirtualList</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useEffect, useMemo, useState, useRef &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport useSize from &quot;..&#x2F;useSize&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; isNumber &#125; from &quot;..&#x2F;utils&quot;;\n\ntype ItemHeight&lt;T&gt; &#x3D; (index: number, data: T) &#x3D;&gt; number;\n\nexport interface Options&lt;T&gt; &#123;\n  containerTarget: BasicTarget; &#x2F;&#x2F; 外面容器，支持 DOM 节点或者 Ref 对象\n  wrapperTarget: BasicTarget; &#x2F;&#x2F; 内部容器，支持 DOM 节点或者 Ref 对象\n  itemHeight: number | ItemHeight&lt;T&gt;; &#x2F;&#x2F; 行高度，静态高度可以直接写入像素值，动态高度可传入函数， 这里的动态是假动态，净骗我，意思是你算好了给 useVirtualList ，就认为你的是动态，并非 “完全自动计算高度”\n  overscan?: number; &#x2F;&#x2F; 视区上、下额外展示的 DOM 节点数量\n&#125;\n\nconst useVirtualList &#x3D; &lt;T &#x3D; any&gt;(list: T[], options: Options&lt;T&gt;) &#x3D;&gt; &#123;\n  const &#123; containerTarget, wrapperTarget, itemHeight, overscan &#x3D; 5 &#125; &#x3D; options;\n\n  &#x2F;&#x2F; 缓存了下\n  const itemHeightRef &#x3D; useLatest(itemHeight);\n  &#x2F;&#x2F; 计算容器宽高\n  const size &#x3D; useSize(containerTarget);\n  &#x2F;&#x2F; 是不是scrollToFunc 触发的滚动\n  const scrollTriggerByScrollToFunc &#x3D; useRef(false);\n  &#x2F;&#x2F; 展示的数据\n  const [targetList, setTargetList] &#x3D; useState&lt;&#123; index: number; data: T &#125;[]&gt;(\n    []\n  );\n  &#x2F;&#x2F; 可见数量\n  const getVisibleCount &#x3D; (containerHeight: number, fromIndex: number) &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      &#x2F;&#x2F; 容器高度&#x2F;每个元素高度\n      return Math.ceil(\n        &#x2F;**天花板，向上取整*&#x2F; containerHeight &#x2F; itemHeightRef.current\n      );\n    &#125;\n\n    let sum &#x3D; 0;\n    let endIndex &#x3D; 0;\n    for (let i &#x3D; fromIndex; i &lt; list.length; i++) &#123;\n      const height &#x3D; itemHeightRef.current(i, list[i]);\n      sum +&#x3D; height;\n      endIndex &#x3D; i;\n      if (sum &gt;&#x3D; containerHeight) &#123;\n        break;\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 最后一个可见元素 - 开始元素 &#x3D;  可见元素数量\n    return endIndex - fromIndex;\n  &#125;;\n  &#x2F;&#x2F; 获取间隔数量\n  const getOffset &#x3D; (scrollTop: number) &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      return Math.floor(scrollTop &#x2F; itemHeightRef.current) + 1;\n    &#125;\n    let sum &#x3D; 0;\n    let offset &#x3D; 0;\n    for (let i &#x3D; 0; i &lt; list.length; i++) &#123;\n      const height &#x3D; itemHeightRef.current(i, list[i]);\n      sum +&#x3D; height;\n      if (sum &gt;&#x3D; scrollTop) &#123;\n        offset &#x3D; i;\n        break;\n      &#125;\n    &#125;\n    return offset + 1;\n  &#125;;\n\n  &#x2F;&#x2F; 获取顶部距离\n  const getDistanceTop &#x3D; (index: number) &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      const height &#x3D; index * itemHeightRef.current;\n      return height;\n    &#125;\n    const height &#x3D; list\n      .slice(0, index)\n      .reduce(\n        (sum, _, i) &#x3D;&gt;\n          sum +\n          (itemHeightRef.current as ItemHeight&lt;T&gt;)(\n            i,\n            list[i]\n          ) &#x2F;**这块是个函数，参数是 i, item *&#x2F;,\n        0\n      );\n    return height;\n  &#125;;\n  &#x2F;&#x2F; 高度和\n  const totalHeight &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      return list.length * itemHeightRef.current;\n    &#125;\n    return list.reduce(\n      (sum, _, index) &#x3D;&gt;\n        sum + (itemHeightRef.current as ItemHeight&lt;T&gt;)(index, list[index]),\n      0\n    );\n  &#125;, [list]);\n  &#x2F;&#x2F;\n  const calculateRange &#x3D; () &#x3D;&gt; &#123;\n    const container &#x3D; getTargetElement(containerTarget);\n    const wrapper &#x3D; getTargetElement(wrapperTarget) as HTMLElement;\n\n    if (container &amp;&amp; wrapper) &#123;\n      const &#123; scrollTop, clientHeight &#125; &#x3D; container;\n\n      const offset &#x3D; getOffset(scrollTop);\n      const visibleCount &#x3D; getVisibleCount(clientHeight, offset);\n\n      const start &#x3D; Math.max(0, offset - overscan);\n      const end &#x3D; Math.min(list.length, offset + visibleCount + overscan);\n\n      const offsetTop &#x3D; getDistanceTop(start);\n      &#x2F;&#x2F; 这里是计算内部容器上边距（用margin和height看来对未渲染的元素进行占位） 下面放个图：\n      &#x2F;&#x2F; http:&#x2F;&#x2F;t-blog-images.aijs.top&#x2F;img&#x2F;202209021833942.webp\n      wrapper.style.height &#x3D; totalHeight - offsetTop + &quot;px&quot;;\n      wrapper.style.marginTop &#x3D; offsetTop + &quot;px&quot;;\n      &#x2F;&#x2F; 可见元素\n      setTargetList(\n        list.slice(start, end).map((ele, index) &#x3D;&gt; (&#123;\n          data: ele,\n          index: index + start,\n        &#125;))\n      );\n    &#125;\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!size?.width || !size?.height) &#123;\n      return;\n    &#125;\n    calculateRange();\n  &#125;, [size?.width, size?.height, list]);\n  &#x2F;&#x2F; 监听滚动，进行不断的计算\n  useEventListener(\n    &quot;scroll&quot;,\n    (e) &#x3D;&gt; &#123;\n      if (scrollTriggerByScrollToFunc.current) &#123;\n        scrollTriggerByScrollToFunc.current &#x3D; false;\n        return;\n      &#125;\n      e.preventDefault();\n      calculateRange();\n    &#125;,\n    &#123;\n      target: containerTarget,\n    &#125;\n  );\n  &#x2F;&#x2F; 滚动到某个下标\n  const scrollTo &#x3D; (index: number) &#x3D;&gt; &#123;\n    const container &#x3D; getTargetElement(containerTarget);\n    if (container) &#123;\n      scrollTriggerByScrollToFunc.current &#x3D; true;\n      container.scrollTop &#x3D; getDistanceTop(index);\n      calculateRange();\n    &#125;\n  &#125;;\n\n  return [targetList, useMemoizedFn(scrollTo)] as const;\n&#125;;\n\nexport default useVirtualList;</code></pre>\n\n<p><strong>这里是计算内部容器上边距（用 margin 和 height 来对未渲染的元素进行占位）</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/202209021833942.webp\" />\n\n<h2 id=\"useRequest-难搞哦-有点多\"><a href=\"#useRequest-难搞哦-有点多\" class=\"headerlink\" title=\"useRequest 难搞哦 有点多\"></a>useRequest 难搞哦 有点多</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>hooks 设计目标导向，拿到哪些值 和 api</li>\n</ul>\n","text":"背景随意看看，了解下，无固定顺序，全凭兴趣 useUpdate useUpdate 会返回一个函数，调用该函数会强制组件重新渲染。 import &#123; useCallback, useState &#125; from &quot;react&quot;; const u...","link":"","photos":[],"count_time":{"symbolsCount":"97k","symbolsTime":"1:28"},"categories":[{"name":"源码","slug":"源码","count":2,"path":"api/categories/源码.json"}],"tags":[{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUpdate\"><span class=\"toc-text\">useUpdate</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useControllableValue\"><span class=\"toc-text\">useControllableValue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useLatest\"><span class=\"toc-text\">useLatest</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1\"><span class=\"toc-text\">闭包陷阱</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMemoizedFn\"><span class=\"toc-text\">useMemoizedFn</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useToggle\"><span class=\"toc-text\">useToggle</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useBoolean\"><span class=\"toc-text\">useBoolean</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMount\"><span class=\"toc-text\">useMount</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUnmount\"><span class=\"toc-text\">useUnmount</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUnmountedRef\"><span class=\"toc-text\">useUnmountedRef</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUpdateEffect-%E6%9C%89%E4%BE%9D%E8%B5%96%E9%A1%B9\"><span class=\"toc-text\">useUpdateEffect (有依赖项)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createUpdateEffect\"><span class=\"toc-text\">createUpdateEffect</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useHistoryTravel\"><span class=\"toc-text\">useHistoryTravel</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useInfiniteScroll\"><span class=\"toc-text\">useInfiniteScroll</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#getTargetElement\"><span class=\"toc-text\">getTargetElement</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#getClientHeight-getScrollHeight-getScrollTop\"><span class=\"toc-text\">getClientHeight, getScrollHeight, getScrollTop</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useEventListener\"><span class=\"toc-text\">useEventListener</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useEffectWithTarget\"><span class=\"toc-text\">useEffectWithTarget</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createEffectWithTarget\"><span class=\"toc-text\">createEffectWithTarget</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useWhyDidYouUpdate\"><span class=\"toc-text\">useWhyDidYouUpdate</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useUrlState\"><span class=\"toc-text\">useUrlState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useSafeState\"><span class=\"toc-text\">useSafeState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useGetState\"><span class=\"toc-text\">useGetState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useResetState\"><span class=\"toc-text\">useResetState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useRafState\"><span class=\"toc-text\">useRafState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#usePrevious\"><span class=\"toc-text\">usePrevious</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMap\"><span class=\"toc-text\">useMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useSet\"><span class=\"toc-text\">useSet</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMemoizedFn-1\"><span class=\"toc-text\">useMemoizedFn</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useFocusWithin\"><span class=\"toc-text\">useFocusWithin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useTitle\"><span class=\"toc-text\">useTitle</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useFavicon\"><span class=\"toc-text\">useFavicon</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useFullscreen\"><span class=\"toc-text\">useFullscreen</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#screenfull\"><span class=\"toc-text\">screenfull</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useExternal\"><span class=\"toc-text\">useExternal</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useHover\"><span class=\"toc-text\">useHover</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useInViewport\"><span class=\"toc-text\">useInViewport</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMutationObserver\"><span class=\"toc-text\">useMutationObserver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useKeyPress%E3%80%90%E4%B8%8D%E6%98%AF%E5%BE%88%E7%90%86%E8%A7%A3%E3%80%91\"><span class=\"toc-text\">useKeyPress【不是很理解】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useDrop-amp-useDrag\"><span class=\"toc-text\">useDrop &amp; useDrag</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useDocumentVisibility\"><span class=\"toc-text\">useDocumentVisibility</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useResponsive\"><span class=\"toc-text\">useResponsive</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useScroll\"><span class=\"toc-text\">useScroll</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useSize\"><span class=\"toc-text\">useSize</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useIsomorphicLayoutEffectWithTarget\"><span class=\"toc-text\">useIsomorphicLayoutEffectWithTarget</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useReactive-%EF%BC%88%E8%BF%99%E4%B8%AA%E6%AF%94%E8%BE%83%E7%89%B9%E5%88%AB%EF%BC%89\"><span class=\"toc-text\">useReactive （这个比较特别）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useCreation\"><span class=\"toc-text\">useCreation</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useTrackedEffect\"><span class=\"toc-text\">useTrackedEffect</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useVirtualList\"><span class=\"toc-text\">useVirtualList</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useRequest-%E9%9A%BE%E6%90%9E%E5%93%A6-%E6%9C%89%E7%82%B9%E5%A4%9A\"><span class=\"toc-text\">useRequest 难搞哦 有点多</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"企业微信 下载/导出","uid":"624f5234ec8cf95d8c13811af9eb0639","slug":"2022-09-02wx-download","date":"2022-09-02T08:59:24.000Z","updated":"2022-09-16T13:54:56.316Z","comments":true,"path":"api/articles/2022-09-02wx-download.json","keywords":null,"cover":[],"text":"浏览器环境a 标签方式一般情况 &#x2F;** * @param &#123; String &#125; target 下载对象 * @param &#123; String &#125; type 类型 url &#x2F; blob *&#x2F; export cons...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/categories/企业微信.json"}],"tags":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/tags/企业微信.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"有过期机制的localStorage","uid":"b204c24ab6e396e5de06d4bc0adf7d2a","slug":"2022-08-24expirestorage","date":"2022-08-24T08:49:06.000Z","updated":"2022-09-16T13:54:56.316Z","comments":true,"path":"api/articles/2022-08-24expirestorage.json","keywords":null,"cover":[],"text":"场景对于一些数据不经常更新的数据，保持一定时间的新鲜的时候可以用于缓存 localStorage见原文 把原文代码改了下，主要对JSON.parse进行 fixed Storage.prototype.setStorageWithAge &#x3D; (key, value, e...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"存储","slug":"存储","count":1,"path":"api/categories/存储.json"}],"tags":[{"name":"存储","slug":"存储","count":1,"path":"api/tags/存储.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}