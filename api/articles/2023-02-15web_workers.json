{"title":"性能优化-Web Workers","uid":"606d0004659da737e4ce8d55e7a861d1","slug":"2023-02-15web_workers","date":"2023-02-15T01:44:35.000Z","updated":"2023-02-20T21:20:56.496Z","comments":true,"path":"api/articles/2023-02-15web_workers.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202302151701564.webp","content":"<h2 id=\"Web-workers-是什么？\"><a href=\"#Web-workers-是什么？\" class=\"headerlink\" title=\"Web workers 是什么？\"></a>Web workers 是什么？</h2><ol>\n<li>为 Web 内容在后台线程中运行脚本提供了一种简单的方法</li>\n<li>线程可以执行任务而不干扰用户界面</li>\n</ol>\n<h2 id=\"运行原理\"><a href=\"#运行原理\" class=\"headerlink\" title=\"运行原理\"></a>运行原理</h2><p>一个 worker 是使用一个构造函数创建的一个对象 (e.g. Worker()) 运行一个命名的 JavaScript 文件</p>\n<ol>\n<li>这个文件包含将在工作线程中运行的代码;</li>\n<li>workers 运行在独立上下文. 在 Worker 内通过 window 获取全局作用域 (而不是 self) 将返回错误</li>\n</ol>\n<h2 id=\"专用-worker-vs-共享-worker\"><a href=\"#专用-worker-vs-共享-worker\" class=\"headerlink\" title=\"专用 worker vs 共享 worker\"></a>专用 worker vs 共享 worker</h2><p><strong>作用域不同、脚本被使用不同</strong></p>\n<ol>\n<li>专用 workers，DedicatedWorkerGlobalScope 对象代表了 worker 的上下文（专用 workers 是指标准 worker 仅在单一脚本中被使用；</li>\n<li>共享 worker 的上下文是 SharedWorkerGlobalScope 对象）。</li>\n<li>一个专用 worker 仅仅能被首次生成它的脚本使用，而共享 worker 可以同时被多个脚本使用</li>\n</ol>\n<h2 id=\"Worker-上下文和函数\"><a href=\"#Worker-上下文和函数\" class=\"headerlink\" title=\"Worker 上下文和函数\"></a>Worker 上下文和函数</h2><p>Worker 在另一个全局上下文中运行，与当前的 window 不同！<br>Window 并不直接在 worker 中可用，其中的很多方法都通过共享的混入（<code>WindowOrWorkerGlobalScope</code>）定义，<br>并通过 worker 派生的 <code>WorkerGlobalScope</code> 上下文提供这些方法：</p>\n<ol>\n<li>DedicatedWorkerGlobalScope——专用 worker</li>\n<li>SharedWorkerGlobalScope ——共享 worker</li>\n<li>ServiceWorkerGlobalScope——service worker</li>\n</ol>\n<p>一些函数在所有的 worker 和主线程中均可用（来自 WindowOrWorkerGlobalScope）：</p>\n<ol>\n<li>setInterval()、setTimeout()。</li>\n<li>clearInterval()、clearTimeout()、</li>\n<li>atob()、btoa()、</li>\n<li>dump() 非标准、</li>\n</ol>\n<p>以下函数仅在 worker 中可用：</p>\n<ol>\n<li>WorkerGlobalScope.importScripts()（所有的 worker）</li>\n<li>DedicatedWorkerGlobalScope.postMessage （仅专用 worker）</li>\n</ol>\n<h2 id=\"以下-Web-API-在-worker-中可用：\"><a href=\"#以下-Web-API-在-worker-中可用：\" class=\"headerlink\" title=\"以下 Web API 在 worker 中可用：\"></a>以下 Web API 在 worker 中可用：</h2><ol>\n<li>Broadcast Channel API、Channel Messaging API、</li>\n<li>Cache API、IndexedDB、</li>\n<li>Console API、Crypto、CustomEvent、</li>\n<li>DOMRequest 和 DOMCursor、</li>\n<li>Fetch、FileReader、FileReaderSync（仅在 worker 中可用）、</li>\n<li>FormData、ImageData、</li>\n<li><code>Network Information API</code>、<code>Notifications、Performance</code>、<code>PerformanceEntry</code>、<code>PerformanceMeasure</code>、PerformanceMark、PerformanceObserver、PerformanceResourceTiming、</li>\n<li>Promise、Server-sent 事件、ServiceWorkerRegistration、</li>\n<li>TextEncoder 和 TextDecoder、URL、WebGL 中的 OffscreenCanvas（通过特性首选项 gfx.offscreencanvas.enabled 启用）、WebSocket、XMLHttpRequest（尽管 responseXML 和 channel 属性始终为 null）。</li>\n<li>worker 也可以创建其它的 worker，所以以下的 API 也同样可用：</li>\n<li>Worker、WorkerGlobalScope、WorkerLocation、WorkerNavigator。</li>\n</ol>\n<h2 id=\"react-web-worker\"><a href=\"#react-web-worker\" class=\"headerlink\" title=\"react web worker\"></a>react web worker</h2><div style=\"display: flex;align-items: center;padding-top:4px;padding-bottom: 4px\"><a target=\"_blank\" href=\"https://github.com/BlueBlazin/web-worker-hooks\">https://github.com/BlueBlazin/web-worker-hooks</a><img src=\"https://img.shields.io/github/stars/BlueBlazin/web-worker-hooks?style=social\" /></div>\n\n<h2 id=\"性能监控\"><a href=\"#性能监控\" class=\"headerlink\" title=\"性能监控\"></a>性能监控</h2><p><a href=\"https://create-react-app.dev/docs/measuring-performance\" target=\"_blank\" >create-react-app measuring-performance</a></p>\n<p><a href=\"https://github.com/BlueBlazin/web-worker-hooks/blob/790769225fb6446ca337139e6287de83cb7ba396/examples/src/index.js\" target=\"_blank\" >demo</a></p>\n","text":"Web workers 是什么？ 为 Web 内容在后台线程中运行脚本提供了一种简单的方法 线程可以执行任务而不干扰用户界面 运行原理一个 worker 是使用一个构造函数创建的一个对象 (e.g. Worker()) 运行一个命名的 JavaScript 文件 这个文件包含将在...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/tags/性能优化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Web-workers-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">Web workers 是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">运行原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%93%E7%94%A8-worker-vs-%E5%85%B1%E4%BA%AB-worker\"><span class=\"toc-text\">专用 worker vs 共享 worker</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Worker-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Worker 上下文和函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A5%E4%B8%8B-Web-API-%E5%9C%A8-worker-%E4%B8%AD%E5%8F%AF%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">以下 Web API 在 worker 中可用：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-web-worker\"><span class=\"toc-text\">react web worker</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7\"><span class=\"toc-text\">性能监控</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Web存储","uid":"3daa6efee784365da039127060479457","slug":"2023-02-15web_storage","date":"2023-02-15T07:12:05.000Z","updated":"2023-02-20T21:20:56.495Z","comments":true,"path":"api/articles/2023-02-15web_storage.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202302151705380.webp","text":" Web 存储 SessionStorage 特定于选项卡，其作用范围涵盖选项卡的整个生存期。它对于存储 IndexedDB 键等少量会话特定信息可能很有用。 此机制是同步的，会阻塞主线程，因此应谨慎使用。 其大小限制约为 5MB，并且只能包含字符串。 由于它特定于选项卡，因此无...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"性能指标 - CLS","uid":"fd6ac5dbf2fdaf53f897b01a2ee4dbfc","slug":"2023-02-14web_cls","date":"2023-02-14T14:32:14.000Z","updated":"2023-02-20T21:20:56.495Z","comments":true,"path":"api/articles/2023-02-14web_cls.json","keywords":null,"cover":"https://web-dev.imgix.net/image/tcFciHGuF3MxnTr1y5ue01OGLBn2/dgpDFckbHwwOKdIGDa3N.svg","text":"Cumulative Layout Shift (CLS)累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1. 或更少。 什么是 CLSCLS，即 Cumulative Layout Shift 累积布局偏移 CLS 测量整个页面生命周期内发生...","link":"","photos":[],"count_time":{"symbolsCount":824,"symbolsTime":"1 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/tags/性能优化.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}