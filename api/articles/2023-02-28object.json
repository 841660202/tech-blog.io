{"title":"Object","uid":"1ff3c92d43d399f4cad1a3cbd62d0b1a","slug":"2023-02-28object","date":"2023-02-28T13:10:33.000Z","updated":"2023-02-28T15:51:50.356Z","comments":true,"path":"api/articles/2023-02-28object.json","keywords":null,"cover":null,"content":"<h2 id=\"Object-assign-方法\"><a href=\"#Object-assign-方法\" class=\"headerlink\" title=\"Object.assign() 方法\"></a>Object.assign() 方法</h2><p>将所有<code>可枚举</code>（Object.propertyIsEnumerable() 返回 true）的<code>自有</code>（Object.hasOwnProperty() 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>复制对象</li>\n<li>浅拷贝</li>\n<li>合并对象：对象为引用类型，作为 target 的原对象的值也会变</li>\n<li>合并具有相同属性的对象：后面的覆盖前面的</li>\n<li>拷贝<em>symbol</em>类型属性：</li>\n<li><code>原型链上的属性</code>和<code>不可枚举属性</code>不能被复制</li>\n<li>基本类型会被包装为对象</li>\n<li>异常会打断后续拷贝任务</li>\n<li>拷贝访问器</li>\n</ol>\n<h2 id=\"js-实现-Object-assign\"><a href=\"#js-实现-Object-assign\" class=\"headerlink\" title=\"js 实现 Object.assign\"></a>js 实现 Object.assign</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function completeAssign(target, ...sources) &#123;\n  &#x2F;&#x2F; 资源全部处理一遍\n  sources.forEach((source) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理一个资源的所有key\n    let descriptors &#x3D; Object.keys(source).reduce((descriptors, key) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 拿到key的配置信息\n      descriptors[key] &#x3D; Object.getOwnPropertyDescriptor(source, key);\n      return descriptors;\n    &#125;, &#123;&#125;);\n\n    &#x2F;&#x2F; By default, Object.assign copies enumerable Symbols, too\n    &#x2F;&#x2F; 将资源的sym信息全部拿出来，放到descriptors上\n    Object.getOwnPropertySymbols(source).forEach((sym) &#x3D;&gt; &#123;\n      let descriptor &#x3D; Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor.enumerable) &#123;\n        descriptors[sym] &#x3D; descriptor;\n      &#125;\n    &#125;);\n    &#x2F;&#x2F; 最后全部添加到target上\n    Object.defineProperties(target, descriptors);\n  &#125;);\n  return target;\n&#125;</code></pre>\n\n<h2 id=\"Object-entries\"><a href=\"#Object-entries\" class=\"headerlink\" title=\"Object.entries\"></a>Object.entries</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (!Object.entries)\n  Object.entries &#x3D; function (obj) &#123;\n    var ownProps &#x3D; Object.keys(obj),\n      i &#x3D; ownProps.length,\n      resArray &#x3D; new Array(i); &#x2F;&#x2F; preallocate the Array\n\n    while (i--) resArray[i] &#x3D; [ownProps[i] &#x2F;*key*&#x2F;, obj[ownProps[i]] &#x2F;*value *&#x2F;];\n\n    return resArray;\n  &#125;;</code></pre>\n\n<h2 id=\"Object-fromEntries\"><a href=\"#Object-fromEntries\" class=\"headerlink\" title=\"Object.fromEntries\"></a>Object.fromEntries</h2><ol>\n<li>map_转化为_object</li>\n<li>array_转化为_object</li>\n<li>对象转换</li>\n</ol>\n<h2 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze()\"></a>Object.freeze()</h2><ol>\n<li>一个被冻结的对象再也不能被修改；</li>\n<li>冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</li>\n<li>冻结一个对象后该对象的原型也不能被修改。</li>\n<li>freeze() 返回和传入的参数相同的对象。</li>\n</ol>\n<h2 id=\"deepFreeze\"><a href=\"#deepFreeze\" class=\"headerlink\" title=\"deepFreeze\"></a>deepFreeze</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 深冻结函数。\nfunction deepFreeze(obj) &#123;\n  &#x2F;&#x2F; 取回定义在 obj 上的属性名\n  var propNames &#x3D; Object.getOwnPropertyNames(obj);\n\n  &#x2F;&#x2F; 在冻结自身之前冻结属性\n  propNames.forEach(function (name) &#123;\n    var prop &#x3D; obj[name];\n\n    &#x2F;&#x2F; 如果 prop 是个对象，冻结它\n    if (typeof prop &#x3D;&#x3D; &quot;object&quot; &amp;&amp; prop !&#x3D;&#x3D; null) deepFreeze(prop);\n  &#125;);\n\n  &#x2F;&#x2F; 冻结自身 (no-op if already frozen)\n  return Object.freeze(obj);\n&#125;\n\nobj2 &#x3D; &#123;\n  internal: &#123;&#125;,\n&#125;;\n\ndeepFreeze(obj2);\nobj2.internal.a &#x3D; &quot;anotherValue&quot;;\nobj2.internal.a; &#x2F;&#x2F; undefined</code></pre>\n\n<h2 id=\"Object-seal\"><a href=\"#Object-seal\" class=\"headerlink\" title=\"Object.seal()\"></a>Object.seal()</h2><h2 id=\"Object-seal-与-Object-freeze-的区别\"><a href=\"#Object-seal-与-Object-freeze-的区别\" class=\"headerlink\" title=\"Object.seal() 与 Object.freeze()的区别\"></a>Object.seal() 与 Object.freeze()的区别</h2><p>冻结的对象中的现有属性值是不可变的。用 Object.seal()密封的对象可以改变其现有属性值</p>\n<h2 id=\"Object-getOwnPropertyNames\"><a href=\"#Object-getOwnPropertyNames\" class=\"headerlink\" title=\"Object.getOwnPropertyNames\"></a>Object.getOwnPropertyNames</h2><p>法返回一个由指定对象的所有自身属性的属性名(<code>可不可枚举的不重要，重要的是自己的</code>)（但不包括 Symbol 值作为名称的属性）组成的数组</p>\n<ol>\n<li>使用_object.getownpropertynames</li>\n<li>只获取不可枚举的属性</li>\n</ol>\n<h2 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys\"></a>Object.keys</h2><p>Object.keys() 方法会返回一个由一个给定对象的<code>自身可枚举属性组成的数组</code>，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致</p>\n<h2 id=\"Object-values\"><a href=\"#Object-values\" class=\"headerlink\" title=\"Object.values\"></a>Object.values</h2><p>Object.values() 方法返回一个给定对象自身的所有<code>可枚举属性值的数组</code>，值的顺序与使用 for…in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）</p>\n<ol>\n<li>返回值</li>\n<li>描述</li>\n<li>示例</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var obj &#x3D; &#123; foo: &quot;bar&quot;, baz: 42 &#125;;\nconsole.log(Object.values(obj)); &#x2F;&#x2F; [&#39;bar&#39;, 42]\n\n&#x2F;&#x2F; array like object\nvar obj &#x3D; &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125;;\nconsole.log(Object.values(obj)); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n&#x2F;&#x2F; array like object with random key ordering\n&#x2F;&#x2F; when we use numeric keys, the value returned in a numerical order according to the keys\nvar an_obj &#x3D; &#123; 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot; &#125;;\nconsole.log(Object.values(an_obj)); &#x2F;&#x2F; [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]\n\n&#x2F;&#x2F; getFoo is property which isn&#39;t enumerable\n&#x2F;&#x2F; 不可枚举\nvar my_obj &#x3D; Object.create(\n  &#123;&#125;,\n  &#123;\n    getFoo: &#123;\n      value: function () &#123;\n        return this.foo;\n      &#125;,\n    &#125;,\n  &#125;\n);\nmy_obj.foo &#x3D; &quot;bar&quot;;\nconsole.log(Object.values(my_obj)); &#x2F;&#x2F; [&#39;bar&#39;]\n\n&#x2F;&#x2F; non-object argument will be coerced to an object\n&#x2F;&#x2F; 非对象参数会被强转为对象\nconsole.log(Object.values(&quot;foo&quot;)); &#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</code></pre>\n\n<h2 id=\"MDN-文章爬取标题脚本\"><a href=\"#MDN-文章爬取标题脚本\" class=\"headerlink\" title=\"MDN 文章爬取标题脚本\"></a>MDN 文章爬取标题脚本</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">data &#x3D; &quot;&quot;;\nArray.from(temp1.getElementsByTagName(&quot;section&quot;)).forEach((item, index) &#x3D;&gt; &#123;\n  data +&#x3D; index + 1 + &quot;. &quot; + item.getAttribute(&quot;aria-labelledby&quot;) + &quot;\\n&quot;;\n&#125;);\ncopy(data);</code></pre>\n","text":"Object.assign() 方法将所有可枚举（Object.propertyIsEnumerable() 返回 true）的自有（Object.hasOwnProperty() 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象 特点 复制对象 浅拷贝 合...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-assign-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Object.assign() 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E5%AE%9E%E7%8E%B0-Object-assign\"><span class=\"toc-text\">js 实现 Object.assign</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-entries\"><span class=\"toc-text\">Object.entries</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-fromEntries\"><span class=\"toc-text\">Object.fromEntries</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-freeze\"><span class=\"toc-text\">Object.freeze()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#deepFreeze\"><span class=\"toc-text\">deepFreeze</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-seal\"><span class=\"toc-text\">Object.seal()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-seal-%E4%B8%8E-Object-freeze-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Object.seal() 与 Object.freeze()的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-getOwnPropertyNames\"><span class=\"toc-text\">Object.getOwnPropertyNames</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-keys\"><span class=\"toc-text\">Object.keys</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-values\"><span class=\"toc-text\">Object.values</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MDN-%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E6%A0%87%E9%A2%98%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">MDN 文章爬取标题脚本</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"智能提示 first select outtime","uid":"8649e6cab92cb169d0b5940efd5b27f4","slug":"2023-03-01first-select","date":"2023-03-01T02:35:54.000Z","updated":"2023-03-03T12:24:32.191Z","comments":true,"path":"api/articles/2023-03-01first-select.json","keywords":null,"cover":[],"text":"背景 vscode 在 0.75 版本时候出了严重 bug 导致快捷键和 Suggestion 提示废掉了，紧急发布 0.75.1 版本， (当前版本)0.75.1 版本发布后 Suggestion 提示不会默认选择第一个了 vscode 之后的版本会启用 tab 来选中第一个 ...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":20,"path":"api/tags/工具.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"ts代码段调试","uid":"3ba10f79d449e988902f7328033fb9f2","slug":"2023-02-28ts","date":"2023-02-28T06:36:23.000Z","updated":"2023-02-28T12:42:55.930Z","comments":true,"path":"api/articles/2023-02-28ts.json","keywords":null,"cover":[],"text":"背景项目中使用 typesscript 进行开发，运行的时候是编译后的 js 脚本，有时候在项目，需要封装复杂的业务处理函数。 最开始的方法 先将代码在项目中编写 出问题了，项目中不方便调试 改为 js 代码，删除类型 调试完毕后，增加类型 复制到项目中 后来参考 pont,写了...","link":"","photos":[],"count_time":{"symbolsCount":683,"symbolsTime":"1 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":13,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}