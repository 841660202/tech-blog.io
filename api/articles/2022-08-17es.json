{"title":"前端基础-es6+","uid":"a1c8da0653d05a3bca517b77d6bf6809","slug":"2022-08-17es","date":"2022-08-17T14:46:14.000Z","updated":"2023-05-15T13:17:32.955Z","comments":true,"path":"api/articles/2022-08-17es.json","keywords":null,"cover":null,"content":"<h2 id=\"old\"><a href=\"#old\" class=\"headerlink\" title=\"old\"></a>old</h2><p><a href=\"https://juejin.cn/post/6844903959283367950\" target=\"_blank\" >1.5 万字概括 ES6 全部特性(已更新 ES2020)</a></p>\n<h1 id=\"ES6-最新到-ES-几\"><a href=\"#ES6-最新到-ES-几\" class=\"headerlink\" title=\"ES6+最新到 ES 几\"></a>ES6+最新到 ES 几</h1><p>ES6（ECMAScript 2015）是 JavaScript 的第六个主要版本，而 ES2021（ECMAScript 2021）是 JavaScript 的最新版本。因此，ES6+是指从 ES6 版本开始的所有后续版本，包括 ES7（ECMAScript 2016）、ES8（ECMAScript 2017）、ES9（ECMAScript 2018）、ES10（ECMAScript 2019）、ES11（ECMAScript 2020）、ES12（ECMAScript 2021）等。</p>\n<h1 id=\"ES12\"><a href=\"#ES12\" class=\"headerlink\" title=\"ES12\"></a>ES12</h1><p>ES12（ECMAScript 2021）是 JavaScript 的最新版本，它于 2021 年 6 月正式发布。它引入了一些新的语言特性和功能，包括：</p>\n<ol>\n<li><p>String.prototype.replaceAll()：可以用于替换字符串中所有匹配项的方法。</p>\n</li>\n<li><p>Promise.any()：返回一组 Promise 对象中最快完成的那个 Promise 的结果。</p>\n</li>\n<li><p>Logical Assignment Operators：包括 <code>&amp;&amp;=</code>, <code>||=</code>, 和 <code>??=</code>，用于对变量进行逻辑运算和赋值。</p>\n</li>\n<li><p>WeakRefs：通过弱引用来跟踪对象，以避免内存泄漏。</p>\n</li>\n<li><p>Numeric Separators：可以在数字中使用下划线 <code>_</code> 分隔符，以增加数字的可读性。</p>\n</li>\n<li><p>FinalizationRegistry：允许在对象被垃圾回收前执行清理操作。</p>\n</li>\n</ol>\n<p>还有其他一些小的改进和新的语言特性，这些改进和特性都旨在提高 JavaScript 的开发效率和可靠性。</p>\n<h2 id=\"Numeric-Separators-很久很久以前不能用吗？我记得前些年就可以了难道是-TS？\"><a href=\"#Numeric-Separators-很久很久以前不能用吗？我记得前些年就可以了难道是-TS？\" class=\"headerlink\" title=\"Numeric Separators(很久很久以前不能用吗？我记得前些年就可以了难道是 TS？)\"></a>Numeric Separators(很久很久以前不能用吗？我记得前些年就可以了难道是 TS？)</h2><p>Numeric Separators 是 ES2021（ECMAScript 2021）中的一项新特性，它允许在数字常量中使用下划线 <code>_</code> 分隔符，以增加数字的可读性。</p>\n<p>在以前的 JavaScript 版本中，对于较长的数字常量，可能很难确定数字的确切值，这可能导致代码的阅读和理解变得困难。例如，一个十六进制数字常量可能长成这样：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const num &#x3D; 0xaabbccddeeff0011;</code></pre>\n\n<p>这个数字常量虽然并不长，但它可能需要一些时间才能弄清它的确切值是多少。通过使用 Numeric Separators，我们可以将数字分成更易于阅读的部分，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const num &#x3D; 0xaa_bb_cc_dd_ee_ff_00_11;</code></pre>\n\n<p>这个数字常量使用了下划线作为分隔符，每四个十六进制数字就会被分成一组。这使得数字常量更易于阅读和理解。</p>\n<p>Numeric Separators 不仅可以用于十六进制数字常量，还可以用于二进制、八进制和十进制数字常量。例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const binNum &#x3D; 0b1010_1100_0011_0000; &#x2F;&#x2F; 43920\nconst octNum &#x3D; 0o12_3456; &#x2F;&#x2F; 5342\nconst decNum &#x3D; 1_000_000; &#x2F;&#x2F; 1000000</code></pre>\n\n<p>需要注意的是，Numeric Separators 只是在代码中增加了可读性，实际上它们在数字常量的值方面没有任何影响。</p>\n<h2 id=\"FinalizationRegistry\"><a href=\"#FinalizationRegistry\" class=\"headerlink\" title=\"FinalizationRegistry\"></a>FinalizationRegistry</h2><p>FinalizationRegistry 是 ES2021（ECMAScript 2021）中引入的一项新特性，它允许在对象被垃圾回收前执行清理操作。</p>\n<p>在 JavaScript 中，垃圾回收器负责自动回收不再被引用的对象，以释放内存。在某些情况下，当对象被垃圾回收时，可能需要执行一些清理操作，例如关闭文件或释放其他资源。在 ES2021 之前，这通常需要手动实现一个类似于“终结器”（finalizer）的机制，以在对象被垃圾回收时执行清理操作。</p>\n<p>FinalizationRegistry 通过提供一个回调函数，在对象被垃圾回收时自动执行清理操作，来简化这个过程。它的基本用法如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 创建一个FinalizationRegistry实例\nconst registry &#x3D; new FinalizationRegistry((key) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 在对象被垃圾回收时执行清理操作\n  console.log(&#96;Object with key $&#123;key&#125; is garbage collected.&#96;);\n&#125;);\n\n&#x2F;&#x2F; 创建一个需要进行清理操作的对象\nconst obj &#x3D; &#123; name: &#39;John&#39; &#125;;\nconst key &#x3D; &#123; id: 1 &#125;;\n\n&#x2F;&#x2F; 注册对象和其对应的key\nregistry.register(obj, key);\n\n&#x2F;&#x2F; 取消对象的注册\n&#x2F;&#x2F; registry.unregister(obj);\n\n&#x2F;&#x2F; 对象不再被引用，将会被垃圾回收\nobj &#x3D; null;</code></pre>\n\n<p>在这个例子中，我们创建了一个 FinalizationRegistry 实例，并使用 register()方法将对象和其对应的 key 注册到 registry 中。当对象不再被引用并被垃圾回收时，FinalizationRegistry 会自动调用回调函数，并将对象的 key 作为参数传递给它。</p>\n<p>需要注意的是，FinalizationRegistry 只能用于跟踪弱引用（weak references）对象。弱引用对象是指不会阻止垃圾回收器回收对象的引用，因此可以使用 FinalizationRegistry 来跟踪这些对象，并在它们被垃圾回收时执行清理操作。</p>\n<h1 id=\"ES11\"><a href=\"#ES11\" class=\"headerlink\" title=\"ES11\"></a>ES11</h1><p>ES11，全称 ECMAScript 2020，是 JavaScript 的一个重要版本，于 2020 年正式发布。它引入了一些新的语言特性和 API，包括：</p>\n<ol>\n<li><p>可选链操作符（Optional Chaining Operator）<br>这个特性允许开发者使用 <code>?.</code> 操作符来简化访问嵌套对象的代码，避免了深层次的嵌套和 null 异常的问题。</p>\n</li>\n<li><p>空值合并操作符（Nullish Coalescing Operator）<br>这个特性允许开发者使用 <code>??</code> 操作符来判断一个值是否为 null 或 undefined，如果是，则使用默认值。</p>\n</li>\n<li><p>动态导入（Dynamic Import）<br>这个特性允许开发者在运行时异步加载模块，而不是在编译时加载。这使得 JavaScript 应用程序可以更加动态和灵活。</p>\n</li>\n<li><p>BigInt<br>这个特性允许开发者使用大于 2^53-1 的整数，这对于处理需要高精度数学的场景非常有用。</p>\n</li>\n<li><p>globalThis<br>这个特性提供了一个标准的方式来访问全局对象，无论在哪个环境下运行。</p>\n</li>\n<li><p>Promise.allSettled()<br>这个特性返回一个 Promise，当所有 Promise 都已解决或拒绝时，它将解决并返回一个包含所有 Promise 结果的数组，无论它们是否被解决或拒绝。</p>\n</li>\n<li><p>String.prototype.matchAll()<br>这个特性允许开发者在一个字符串中查找所有匹配的子字符串，并返回一个迭代器。</p>\n</li>\n</ol>\n<p>总之，ES11 引入的这些新特性和 API，可以让开发者更加方便地编写高效的 JavaScript 代码，提高开发效率和应用程序的性能。</p>\n<p>ES11，全称 ECMAScript 2020，是 JavaScript 的第十一个正式版本，于 2020 年 6 月发布。ES11 引入了一些新特性和改进，其中一些重要的特性包括：</p>\n<h2 id=\"可选链操作符（Optional-chaining）\"><a href=\"#可选链操作符（Optional-chaining）\" class=\"headerlink\" title=\"可选链操作符（Optional chaining）\"></a>可选链操作符（Optional chaining）</h2><p>可选链操作符（?.）可以简化访问嵌套对象或数组的代码，当访问的属性或方法不存在时，返回 undefined 而不是抛出错误。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;\n  name: &#39;John&#39;,\n  address: &#123;\n    city: &#39;New York&#39;,\n  &#125;,\n&#125;;\n\nconsole.log(person.address?.city); &#x2F;&#x2F; 输出 &#39;New York&#39;\nconsole.log(person.address?.zipCode); &#x2F;&#x2F; 输出 undefined</code></pre>\n\n<h2 id=\"空值合并操作符（Nullish-coalescing）\"><a href=\"#空值合并操作符（Nullish-coalescing）\" class=\"headerlink\" title=\"空值合并操作符（Nullish coalescing）\"></a>空值合并操作符（Nullish coalescing）</h2><p>空值合并操作符（??）用于处理 undefined 或 null 值的情况，它只在左侧操作数的值为 undefined 或 null 时返回右侧操作数的值，否则返回左侧操作数的值。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const value1 &#x3D; undefined;\nconst value2 &#x3D; null;\nconst value3 &#x3D; 0;\n\nconsole.log(value1 ?? &#39;default value&#39;); &#x2F;&#x2F; 输出 &#39;default value&#39;\nconsole.log(value2 ?? &#39;default value&#39;); &#x2F;&#x2F; 输出 &#39;default value&#39;\nconsole.log(value3 ?? &#39;default value&#39;); &#x2F;&#x2F; 输出 0</code></pre>\n\n<h2 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h2><p>Promise.allSettled() 方法返回一个 Promise，该 Promise 在所有 Promise 对象都已经 fulfilled 或 rejected 后解决。与 Promise.all() 不同的是，即使其中某个 Promise 被 rejected，Promise.allSettled() 仍然会等待其他 Promise 的完成，并且会返回所有 Promise 的状态和值。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const promises &#x3D; [Promise.resolve(&#39;value1&#39;), Promise.reject(new Error(&#39;error message&#39;)), Promise.resolve(&#39;value3&#39;)];\n\nPromise.allSettled(promises).then((results) &#x3D;&gt; console.log(results));</code></pre>\n\n<p>输出结果为：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[\n  &#123; status: &#39;fulfilled&#39;, value: &#39;value1&#39; &#125;,\n  &#123; status: &#39;rejected&#39;, reason: Error: error message at ... &#125;,\n  &#123; status: &#39;fulfilled&#39;, value: &#39;value3&#39; &#125;\n]</code></pre>\n\n<p>除了以上三个特性，ES11 还引入了 String.prototype.matchAll() 方法、globalThis 对象、BigInt 类型和 import() 函数等新特性和改进。</p>\n<h2 id=\"动态导入（Dynamic-Import）\"><a href=\"#动态导入（Dynamic-Import）\" class=\"headerlink\" title=\"动态导入（Dynamic Import）\"></a>动态导入（Dynamic Import）</h2><p>动态导入（Dynamic Import）是 ECMAScript 2020（ES2020 &#x2F; ES11）中引入的一个新特性，它允许在运行时异步地加载 ES 模块。与静态导入不同，动态导入并不在模块内部执行，而是在代码运行时才执行。</p>\n<p>动态导入的语法如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import(moduleSpecifier)\n  .then((module) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 使用加载的模块\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理错误\n  &#125;);</code></pre>\n\n<p>其中 <code>moduleSpecifier</code> 参数是一个字符串，用于指定需要加载的模块。它可以是相对路径或绝对路径，也可以是一个 URL。返回的是一个 Promise，用于异步加载指定的模块。当加载成功时，<code>then</code> 方法将传递一个包含导出对象的模块对象，否则 <code>catch</code> 方法将会捕捉错误并进行处理。</p>\n<p>动态导入可以用于按需加载模块，避免一次性加载过多的代码，提高应用程序的性能。例如，在使用 Webpack 打包应用程序时，可以将代码分割成多个小的代码块，然后在需要时动态地加载它们，而不是在一开始就加载所有的代码。</p>\n<p>需要注意的是，动态导入是 ECMAScript 2020 中引入的新特性，因此需要使用支持该特性的 JavaScript 引擎才能运行。</p>\n<h2 id=\"ES5-实现动态导入功能\"><a href=\"#ES5-实现动态导入功能\" class=\"headerlink\" title=\"ES5 实现动态导入功能\"></a>ES5 实现动态导入功能</h2><p>ES5 并没有官方的动态导入功能，但是可以使用一些工具或者编写一些代码来模拟实现类似的功能。下面是一个简单的实现示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function importModule(modulePath, callback) &#123;\n  var script &#x3D; document.createElement(&#39;script&#39;);\n  script.onload &#x3D; function () &#123;\n    callback(window[modulePath]);\n  &#125;;\n  script.src &#x3D; modulePath + &#39;.js&#39;;\n  document.head.appendChild(script);\n&#125;\n\n&#x2F;&#x2F; 使用示例\nimportModule(&#39;module1&#39;, function (module1) &#123;\n  &#x2F;&#x2F; 使用模块1\n&#125;);\n\nimportModule(&#39;module2&#39;, function (module2) &#123;\n  &#x2F;&#x2F; 使用模块2\n&#125;);</code></pre>\n\n<p>在上面的示例中，<code>importModule</code> 函数接受两个参数，一个是模块路径 <code>modulePath</code>，另一个是加载完成后的回调函数 <code>callback</code>。当函数被调用时，它会动态地创建一个 <code>&lt;script&gt;</code> 标签，然后将其添加到 <code>&lt;head&gt;</code> 元素中。当该脚本加载完成时，回调函数将被调用，并将加载的模块作为参数传递给它。</p>\n<p>需要注意的是，这种方式存在一些限制。例如，加载的脚本必须是同源的，否则会因为跨域问题而导致加载失败。此外，如果需要加载的模块较多，就会产生大量的 HTTP 请求，影响应用程序的性能。因此，如果需要在 ES5 中实现类似动态导入的功能，建议使用一些工具或框架，例如 RequireJS 或者 SystemJS。</p>\n<h2 id=\"ES11-动态导入（Dynamic-Import）可以加载非同源？\"><a href=\"#ES11-动态导入（Dynamic-Import）可以加载非同源？\" class=\"headerlink\" title=\"ES11 动态导入（Dynamic Import）可以加载非同源？\"></a>ES11 动态导入（Dynamic Import）可以加载非同源？</h2><p>ES11 动态导入（Dynamic Import）可以加载非同源的模块，但这涉及到跨域资源共享（CORS）策略的限制。</p>\n<p>根据 CORS 策略，Web 浏览器只允许从同一源加载的资源进行跨域访问，也就是说，如果在一个网站上使用动态导入来加载另一个域的模块，那么这个请求将会被浏览器拦截。</p>\n<p>为了解决这个问题，开发者可以使用一些工具或技术来绕过 CORS 策略。例如，在服务端设置 CORS 头部，将需要访问的域名添加到许可的列表中，或者使用代理服务器进行转发。此外，一些第三方库，例如 SystemJS 和 Webpack，也提供了一些解决跨域访问的方法，可以在前端代码中使用动态导入加载非同源的模块。需要注意的是，这些方法都需要开发者根据自己的需求进行选择和配置。</p>\n<h2 id=\"ES11-动态导入（Dynamic-Import）-自动添加？\"><a href=\"#ES11-动态导入（Dynamic-Import）-自动添加？\" class=\"headerlink\" title=\"ES11 动态导入（Dynamic Import） 自动添加？\"></a>ES11 动态导入（Dynamic Import） 自动添加<script>？</h2><p>ES11 动态导入（Dynamic Import）会自动在 HTML 页面中添加对应的 <code>&lt;script&gt;</code> 标签，用于加载指定的模块。</p>\n<p>在使用动态导入时，可以直接在 JavaScript 代码中指定需要加载的模块路径，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import(&#39;.&#x2F;module.js&#39;)\n  .then((module) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 使用加载的模块\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理加载失败的情况\n  &#125;);</code></pre>\n\n<p>在上面的代码中，<code>import</code> 函数会根据指定的模块路径动态加载对应的 JavaScript 模块。当模块加载完成后，<code>then</code> 回调函数将会被调用，并将加载的模块作为参数传递给它。如果加载过程中出现错误，<code>catch</code> 回调函数将会被调用，并将错误信息作为参数传递给它。</p>\n<p>需要注意的是，当使用动态导入时，浏览器会自动在 HTML 页面中添加对应的 <code>&lt;script&gt;</code> 标签，用于加载指定的模块。这个标签会被添加到 <code>&lt;head&gt;</code> 元素中，并且会使用异步加载的方式进行加载，不会阻塞其他的页面内容的加载。这种自动添加 <code>&lt;script&gt;</code> 标签的机制可以使得开发者更方便地使用动态导入功能，并且不需要手动添加 <code>&lt;script&gt;</code> 标签，从而提高了代码的可读性和维护性。</p>\n<h1 id=\"ES10\"><a href=\"#ES10\" class=\"headerlink\" title=\"ES10\"></a>ES10</h1><p>ECMAScript 2019，也称为 ES10，是 JavaScript 语言的第十个版本，于 2019 年 6 月发布。它引入了几个新的语言特性和功能，包括：</p>\n<ol>\n<li><p><code>Array.prototype.flat()</code> 和 <code>Array.prototype.flatMap()</code> 方法：用于扁平化数组和映射数组元素。</p>\n</li>\n<li><p><code>String.prototype.trimStart()</code> 和 <code>String.prototype.trimEnd()</code> 方法：用于去除字符串的首尾空格。</p>\n</li>\n<li><p><code>Object.fromEntries()</code> 方法：用于将键值对数组转换为对象。</p>\n</li>\n<li><p><code>Symbol.prototype.description</code> 属性：用于获取 Symbol 对象的描述字符串。</p>\n</li>\n<li><p><code>可选的 catch 绑定</code>：允许在 try-catch 语句中省略 catch 块中的异常绑定，从而使得代码更加简洁。</p>\n</li>\n<li><p><code>BigInt</code> 类型：用于表示任意精度的整数，可以解决 JavaScript 中对大整数的精度问题。</p>\n</li>\n<li><p>动态 <code>import()</code> 函数：可以实现动态地导入模块。</p>\n</li>\n</ol>\n<p>总之，ES10 引入了一些实用的新特性和功能，使得 JavaScript 语言更加现代化和强大。这些新特性和功能可以帮助开发者更加方便地编写复杂的 JavaScript 应用程序，并提高代码的可读性和可维护性。</p>\n<h2 id=\"ES10-与-ES11-动态-import-函数有什么区别？\"><a href=\"#ES10-与-ES11-动态-import-函数有什么区别？\" class=\"headerlink\" title=\"ES10 与 ES11 动态 import() 函数有什么区别？\"></a>ES10 与 ES11 动态 import() 函数有什么区别？</h2><p>ES10 引入了动态 <code>import()</code> 函数，而 ES11 对它进行了一些改进。</p>\n<p>在 ES10 中，<code>import()</code> 函数是一个异步函数，它可以动态地导入 JavaScript 模块。它返回一个 Promise 对象，可以通过 Promise 的 then 方法获取导入的模块。</p>\n<p>在 ES11 中，<code>import()</code> 函数被更新，它可以在任何地方调用，而不仅仅是在顶级作用域中。这使得我们可以动态地导入模块，并将其赋值给变量或常量。</p>\n<p>ES11 还增加了一个新的特性，即顶级的 <code>await</code> 关键字。它允许我们在顶级作用域中使用 await，从而使得我们可以在模块加载完成之前阻塞 JavaScript 解释器。这意味着我们可以在模块加载完成之后再执行其他的代码，而不需要使用回调函数或 Promise 链。</p>\n<p>例如，下面的代码演示了如何使用顶级的 await 和动态 <code>import()</code> 函数：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 在顶级作用域中使用 await 和 import()\nconst module &#x3D; await import(&#39;.&#x2F;module.js&#39;);\n\n&#x2F;&#x2F; 在模块加载完成之后再执行其他的代码\nconsole.log(module.foo());</code></pre>\n\n<p>需要注意的是，顶级的 <code>await</code> 关键字只能在 ES2017+ 的 JavaScript 模块中使用，并且只能在模块的顶级作用域中使用。如果在其他地方使用，会导致语法错误。</p>\n<h1 id=\"ES9\"><a href=\"#ES9\" class=\"headerlink\" title=\"ES9\"></a>ES9</h1><p>ECMAScript 2018，也称为 ES9，是 JavaScript 语言的第九个版本，于 2018 年 6 月发布。它引入了几个新的语言特性和功能，包括：</p>\n<ol>\n<li><p><code>Promise.prototype.finally()</code> 方法：用于在 Promise 结束时执行一些操作，无论 Promise 成功还是失败。</p>\n</li>\n<li><p><code>Rest/Spread 属性</code>：用于对象和数组的解构赋值语法中，可以轻松地获取对象和数组的剩余部分。</p>\n</li>\n<li><p>正则表达式的命名捕获组：可以在正则表达式中使用命名捕获组，从而使得正则表达式的匹配更加直观和易于理解。</p>\n</li>\n<li><p>正则表达式的 <code>dotAll</code> 标志：可以匹配任何字符，包括行终止符。</p>\n</li>\n<li><p><code>Async Iteration</code>：可以使用 <code>for-await-of</code> 循环来遍历异步迭代器。</p>\n</li>\n</ol>\n<p>总之，ES9 引入了一些实用的新特性和功能，使得 JavaScript 语言更加现代化和强大。这些新特性和功能可以帮助开发者更加方便地编写复杂的 JavaScript 应用程序，并提高代码的可读性和可维护性。</p>\n<h2 id=\"正则表达式的命名捕获组\"><a href=\"#正则表达式的命名捕获组\" class=\"headerlink\" title=\"正则表达式的命名捕获组\"></a>正则表达式的命名捕获组</h2><p>在 ES9 中，正则表达式新增了命名捕获组（Named Capture Groups）功能，它允许给正则表达式中的捕获组起一个名称，使得正则表达式的匹配结果更加直观和易于理解。</p>\n<p>命名捕获组可以通过 <code>(?&lt;name&gt;pattern)</code> 的语法来定义，其中 <code>name</code> 是捕获组的名称，<code>pattern</code> 是捕获组的正则表达式。在匹配成功后，可以使用 <code>match.groups</code> 属性来获取命名捕获组的结果，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const regex &#x3D; &#x2F;(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)&#x2F;;\nconst result &#x3D; regex.exec(&#39;2021-05-18&#39;);\n\nconsole.log(result.groups.year); &#x2F;&#x2F; &quot;2021&quot;\nconsole.log(result.groups.month); &#x2F;&#x2F; &quot;05&quot;\nconsole.log(result.groups.day); &#x2F;&#x2F; &quot;18&quot;</code></pre>\n\n<p>在上面的代码中，正则表达式 <code>/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/</code> 匹配日期字符串，并定义了三个命名捕获组，分别对应年、月、日。在匹配成功后，可以通过 <code>result.groups</code> 属性获取命名捕获组的结果。</p>\n<p>命名捕获组的优点在于，可以用更加直观和自然的方式来访问捕获组的结果，而不需要记住捕获组的编号。同时，命名捕获组还可以提高代码的可读性和可维护性，使得正则表达式更加易于理解和修改。</p>\n<h2 id=\"正则表达式的-dotAll-标志\"><a href=\"#正则表达式的-dotAll-标志\" class=\"headerlink\" title=\"正则表达式的 dotAll 标志\"></a>正则表达式的 <code>dotAll</code> 标志</h2><p>当使用正则表达式进行匹配时，默认情况下，<code>.</code> 只能匹配除了行终止符以外的任意字符。如果需要匹配包括行终止符在内的任意字符，就可以使用 <code>dotAll</code> 标志。</p>\n<p>在正则表达式中，<code>dotAll</code> 标志使用 <code>s</code> 表示，它可以通过在正则表达式末尾添加 <code>s</code> 来启用。</p>\n<p>以下是一个简化的例子：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const regex &#x3D; &#x2F;hello.world&#x2F;s;\nconst str1 &#x3D; &#39;hello\\nworld&#39;;\nconst str2 &#x3D; &#39;hello world&#39;;\n\nconsole.log(regex.test(str1)); &#x2F;&#x2F; true\nconsole.log(regex.test(str2)); &#x2F;&#x2F; false</code></pre>\n\n<p>如果正则表达式需要匹配包括行终止符在内的任意字符，就可以添加 <code>s</code> 标志来启用 <code>dotAll</code> 功能。</p>\n<h2 id=\"Async-Iteration\"><a href=\"#Async-Iteration\" class=\"headerlink\" title=\"Async Iteration\"></a>Async Iteration</h2><p>ES2018 引入了异步迭代器（Async Iteration）功能，它可以用于在异步环境下遍历数据集合，如异步操作返回的集合。异步迭代器通过 <code>Symbol.asyncIterator</code> 来定义，并使用 <code>for-await-of</code> 语句进行迭代。</p>\n<p>异步迭代器与普通迭代器的主要区别在于，它的 <code>next()</code> 方法返回的是一个 Promise 对象。当异步迭代器完成遍历时，它会返回一个 resolved 状态的 Promise 对象，并将 value 属性设置为 undefined。</p>\n<p>以下是一个简单的例子，演示了如何使用异步迭代器：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function* asyncGenerator() &#123;\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n&#125;\n\n(async function () &#123;\n  for await (const item of asyncGenerator()) &#123;\n    console.log(item);\n  &#125;\n&#125;)();</code></pre>\n\n<p>在上面的代码中，<code>asyncGenerator()</code> 函数定义了一个异步生成器，它通过 <code>yield</code> 关键字生成两个字符串。<code>for-await-of</code> 语句通过异步迭代器遍历异步生成器返回的数据集合，并依次打印每个元素的值。</p>\n<p>需要注意的是，在异步环境下，数据集合的获取和遍历过程都是异步的，因此需要使用 <code>async/await</code> 来处理异步操作。</p>\n<h1 id=\"ES8\"><a href=\"#ES8\" class=\"headerlink\" title=\"ES8\"></a>ES8</h1><p>ES8（也称为 ECMAScript 2017）是 ECMAScript 标准的第八个版本，于 2017 年发布。ES8 引入了一些新功能和语言特性，包括：</p>\n<ol>\n<li><p>异步函数（Async Functions）：ES8 引入了异步函数的概念，通过 <code>async/await</code> 关键字，可以更方便地进行异步编程。</p>\n</li>\n<li><p><code>Object.values()</code> 和 <code>Object.entries()</code> 方法：这两个方法用于获取对象的属性值和键值对数组，便于对对象进行遍历。</p>\n</li>\n<li><p>字符串填充方法 <code>padStart()</code> 和 <code>padEnd()</code>：这两个方法可以用于在字符串前面或后面添加指定数量的填充字符。</p>\n</li>\n<li><p><code>Object.getOwnPropertyDescriptors()</code> 方法：该方法返回指定对象所有自身属性（非继承属性）的描述符。</p>\n</li>\n<li><p><code>函数参数列表和调用语法中的尾逗号</code>：在函数参数列表和函数调用语句的参数列表中，允许添加末尾的逗号，这使得代码的变更更加方便。</p>\n</li>\n<li><p><code>SharedArrayBuffer</code> 对象：该对象用于创建可以被共享的缓冲区。</p>\n</li>\n</ol>\n<p>以上是 ES8 引入的一些新功能和语言特性。这些特性的引入使得 JavaScript 编程更加简洁和高效。</p>\n<h1 id=\"ES7\"><a href=\"#ES7\" class=\"headerlink\" title=\"ES7\"></a>ES7</h1><p>ES7（也称为 ECMAScript 2016）是 ECMAScript 标准的第七个版本，于 2016 年发布。ES7 引入了一些新功能和语言特性，包括：</p>\n<ol>\n<li><p>数组的 <code>includes()</code> 方法：该方法用于检查数组是否包含指定的值。</p>\n</li>\n<li><p>幂运算符（Exponentiation Operator）：使用 <code>**</code> 运算符可以进行幂运算，例如 <code>2 ** 3</code> 表示 2 的 3 次方。</p>\n</li>\n<li><p><code>Async</code> 函数中的 <code>Await</code> 关键字可以在普通函数中使用：这意味着可以在普通函数中使用异步操作。</p>\n</li>\n<li><p>函数绑定运算符（Function Binding Operator）：使用 <code>::</code> 运算符可以将函数绑定到指定的对象上。</p>\n</li>\n</ol>\n<p>以上是 ES7 引入的一些新功能和语言特性。这些特性的引入使得 JavaScript 编程更加方便和灵活。</p>\n<h2 id=\"函数绑定运算符（Function-Binding-Operator）\"><a href=\"#函数绑定运算符（Function-Binding-Operator）\" class=\"headerlink\" title=\"函数绑定运算符（Function Binding Operator）\"></a>函数绑定运算符（Function Binding Operator）</h2><p>函数绑定运算符（Function Binding Operator）是 ES7（ECMAScript 2016）引入的一个新特性，它使用双冒号（::）作为运算符，可以将函数绑定到指定的对象上，形成一个新的绑定函数。</p>\n<p>使用函数绑定运算符可以简化代码，使代码更加简洁易懂。例如，使用函数绑定运算符可以将以下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const boundFn &#x3D; fn.bind(obj);</code></pre>\n\n<p>简化为：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const boundFn &#x3D; obj::fn;</code></pre>\n\n<p>其中，<code>fn</code> 是要绑定的函数，<code>obj</code> 是要绑定到的对象。绑定后的 <code>boundFn</code> 函数与 <code>fn</code> 函数相同，但它的 <code>this</code> 指向了 <code>obj</code> 对象。</p>\n<p>需要注意的是，函数绑定运算符只是一个语法糖，它本质上还是通过 <code>bind</code> 方法实现的，因此在使用函数绑定运算符时，需要保证该方法的可用性。此外，函数绑定运算符还存在一些语法限制，例如无法与箭头函数一起使用。</p>\n<h2 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h2><p>以下是一个使用函数绑定运算符的完整示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个对象\nconst obj &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  sayHi() &#123;\n    console.log(&#96;Hi, my name is $&#123;this.name&#125;.&#96;);\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 绑定函数到对象上\nconst boundFn &#x3D; obj::obj.sayHi;\n\n&#x2F;&#x2F; 调用绑定函数\nboundFn(); &#x2F;&#x2F; 输出：Hi, my name is Tom.</code></pre>\n\n<p>在上面的示例中，我们首先定义了一个包含 <code>name</code> 属性和 <code>sayHi</code> 方法的对象 <code>obj</code>。然后，使用函数绑定运算符将 <code>sayHi</code> 方法绑定到 <code>obj</code> 对象上，得到一个新的绑定函数 <code>boundFn</code>。最后，调用绑定函数 <code>boundFn</code>，输出 <code>Hi, my name is Tom.</code>。</p>\n<p>需要注意的是，<code>obj::obj.sayHi</code> 中的第一个 <code>obj</code> 是绑定的对象，第二个 <code>obj.sayHi</code> 则是要绑定的函数。</p>\n<h2 id=\"直接写-const-boundFn-obj-sayHi-不是更简单吗？\"><a href=\"#直接写-const-boundFn-obj-sayHi-不是更简单吗？\" class=\"headerlink\" title=\"直接写 const boundFn = obj.sayHi; 不是更简单吗？\"></a>直接写 const boundFn = obj.sayHi; 不是更简单吗？</h2><p>是的，你说得没错，直接写 <code>const boundFn = obj.sayHi</code> 也能得到一个指向 <code>obj.sayHi</code> 方法的函数。但是，在这种情况下，<code>boundFn</code> 函数的 <code>this</code> 指向将是调用该函数的上下文（即函数调用时所在的对象），而不是绑定到 <code>obj</code> 对象上。</p>\n<p>使用函数绑定运算符的优点在于，它可以显式地将函数绑定到指定的对象上，避免了由于函数调用时上下文的不确定性导致的错误。此外，它还能让代码更加简洁易懂，减少代码冗余。</p>\n<h2 id=\"已经有了-bind-为什么还要设计\"><a href=\"#已经有了-bind-为什么还要设计\" class=\"headerlink\" title=\"已经有了 bind 为什么还要设计 ::\"></a>已经有了 bind 为什么还要设计 ::</h2><p><code>::</code> 函数绑定运算符的主要优势在于语法更加简洁，特别是在使用函数嵌套时，可以有效地减少代码的嵌套深度，使代码更加清晰易懂。相比之下，使用 <code>bind</code> 方法时需要手动指定函数的 <code>this</code> 值和任意多个参数，语法相对繁琐。</p>\n<p>此外，函数绑定运算符还可以在更大程度上保留函数原本的语义，而不是通过 <code>bind</code> 方法显式地创建一个新的函数。这种方式在函数柯里化和函数组合等场景中特别有用。</p>\n<p>当然，如果你更喜欢使用 <code>bind</code> 方法或其他方式进行函数绑定，完全没有问题。这只是 JavaScript 提供的一种语法糖，你可以根据自己的喜好和代码风格选择使用。</p>\n<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p>ES6（ECMAScript 2015）是 JavaScript 语言的一个重大更新版本，引入了许多新特性和语法糖，使得 JavaScript 编程更加简单、直观和高效。</p>\n<p>一些 ES6 新特性包括：</p>\n<ul>\n<li>let 和 const 关键字，用于声明块级作用域的变量和常量。</li>\n<li>箭头函数，简化了函数定义的语法，并自动绑定了函数体内部的 this 指向。</li>\n<li>模板字符串，使得字符串拼接和格式化更加直观和方便。</li>\n<li>解构赋值，可以从对象或数组中快速提取值并赋给变量。</li>\n<li>默认参数和剩余参数，可以为函数的参数设置默认值或接受任意数量的参数。</li>\n<li>类和继承，提供了面向对象编程的语法和机制。</li>\n<li>Promise，为异步编程提供了更加方便和可靠的解决方案。</li>\n<li>模块化，可以方便地定义和导出模块，使得代码更加模块化和可重用。</li>\n</ul>\n<p>除此之外，ES6 还引入了很多其他的新特性和语法糖，如迭代器和生成器、Symbol、Proxy 和 Reflect 等，这些特性极大地拓展了 JavaScript 的功能和应用范围，使得它可以更好地应对现代 Web 开发的需求。</p>\n","text":"old1.5 万字概括 ES6 全部特性(已更新 ES2020) ES6+最新到 ES 几ES6（ECMAScript 2015）是 JavaScript 的第六个主要版本，而 ES2021（ECMAScript 2021）是 JavaScript 的最新版本。因此，ES6+是指...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#old\"><span class=\"toc-text\">old</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ES6-%E6%9C%80%E6%96%B0%E5%88%B0-ES-%E5%87%A0\"><span class=\"toc-text\">ES6+最新到 ES 几</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ES12\"><span class=\"toc-text\">ES12</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Numeric-Separators-%E5%BE%88%E4%B9%85%E5%BE%88%E4%B9%85%E4%BB%A5%E5%89%8D%E4%B8%8D%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F%E6%88%91%E8%AE%B0%E5%BE%97%E5%89%8D%E4%BA%9B%E5%B9%B4%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E9%9A%BE%E9%81%93%E6%98%AF-TS%EF%BC%9F\"><span class=\"toc-text\">Numeric Separators(很久很久以前不能用吗？我记得前些年就可以了难道是 TS？)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FinalizationRegistry\"><span class=\"toc-text\">FinalizationRegistry</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ES11\"><span class=\"toc-text\">ES11</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88Optional-chaining%EF%BC%89\"><span class=\"toc-text\">可选链操作符（Optional chaining）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88Nullish-coalescing%EF%BC%89\"><span class=\"toc-text\">空值合并操作符（Nullish coalescing）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise-allSettled\"><span class=\"toc-text\">Promise.allSettled()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5%EF%BC%88Dynamic-Import%EF%BC%89\"><span class=\"toc-text\">动态导入（Dynamic Import）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES5-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">ES5 实现动态导入功能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES11-%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5%EF%BC%88Dynamic-Import%EF%BC%89%E5%8F%AF%E4%BB%A5%E5%8A%A0%E8%BD%BD%E9%9D%9E%E5%90%8C%E6%BA%90%EF%BC%9F\"><span class=\"toc-text\">ES11 动态导入（Dynamic Import）可以加载非同源？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES11-%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5%EF%BC%88Dynamic-Import%EF%BC%89-%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%EF%BC%9F\"><span class=\"toc-text\">ES11 动态导入（Dynamic Import） 自动添加？&lt;&#x2F;h2&gt;&lt;p&gt;ES11 动态导入（Dynamic Import）会自动在 HTML 页面中添加对应的 &lt;code&gt;&lt;script&gt;&lt;&#x2F;code&gt; 标签，用于加载指定的模块。&lt;&#x2F;p&gt;\n&lt;p&gt;在使用动态导入时，可以直接在 JavaScript 代码中指定需要加载的模块路径，例如：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;import(&#39;.&#x2F;module.js&#39;)\n  .then((module) &#x3D;&gt; &amp;#123;\n    &#x2F;&#x2F; 使用加载的模块\n  &amp;#125;)\n  .catch((error) &#x3D;&gt; &amp;#123;\n    &#x2F;&#x2F; 处理加载失败的情况\n  &amp;#125;);&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;在上面的代码中，&lt;code&gt;import&lt;&#x2F;code&gt; 函数会根据指定的模块路径动态加载对应的 JavaScript 模块。当模块加载完成后，&lt;code&gt;then&lt;&#x2F;code&gt; 回调函数将会被调用，并将加载的模块作为参数传递给它。如果加载过程中出现错误，&lt;code&gt;catch&lt;&#x2F;code&gt; 回调函数将会被调用，并将错误信息作为参数传递给它。&lt;&#x2F;p&gt;\n&lt;p&gt;需要注意的是，当使用动态导入时，浏览器会自动在 HTML 页面中添加对应的 &lt;code&gt;&lt;script&gt;&lt;&#x2F;code&gt; 标签，用于加载指定的模块。这个标签会被添加到 &lt;code&gt;&lt;head&gt;&lt;&#x2F;code&gt; 元素中，并且会使用异步加载的方式进行加载，不会阻塞其他的页面内容的加载。这种自动添加 &lt;code&gt;&lt;script&gt;&lt;&#x2F;code&gt; 标签的机制可以使得开发者更方便地使用动态导入功能，并且不需要手动添加 &lt;code&gt;&lt;script&gt;&lt;&#x2F;code&gt; 标签，从而提高了代码的可读性和维护性。&lt;&#x2F;p&gt;\n&lt;h1 id&#x3D;&quot;ES10&quot;&gt;&lt;a href&#x3D;&quot;#ES10&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;ES10&quot;&gt;&lt;&#x2F;a&gt;ES10&lt;&#x2F;h1&gt;&lt;p&gt;ECMAScript 2019，也称为 ES10，是 JavaScript 语言的第十个版本，于 2019 年 6 月发布。它引入了几个新的语言特性和功能，包括：&lt;&#x2F;p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Array.prototype.flat()&lt;&#x2F;code&gt; 和 &lt;code&gt;Array.prototype.flatMap()&lt;&#x2F;code&gt; 方法：用于扁平化数组和映射数组元素。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;String.prototype.trimStart()&lt;&#x2F;code&gt; 和 &lt;code&gt;String.prototype.trimEnd()&lt;&#x2F;code&gt; 方法：用于去除字符串的首尾空格。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Object.fromEntries()&lt;&#x2F;code&gt; 方法：用于将键值对数组转换为对象。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Symbol.prototype.description&lt;&#x2F;code&gt; 属性：用于获取 Symbol 对象的描述字符串。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;可选的 catch 绑定&lt;&#x2F;code&gt;：允许在 try-catch 语句中省略 catch 块中的异常绑定，从而使得代码更加简洁。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;BigInt&lt;&#x2F;code&gt; 类型：用于表示任意精度的整数，可以解决 JavaScript 中对大整数的精度问题。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;动态 &lt;code&gt;import()&lt;&#x2F;code&gt; 函数：可以实现动态地导入模块。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n&lt;p&gt;总之，ES10 引入了一些实用的新特性和功能，使得 JavaScript 语言更加现代化和强大。这些新特性和功能可以帮助开发者更加方便地编写复杂的 JavaScript 应用程序，并提高代码的可读性和可维护性。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;ES10-与-ES11-动态-import-函数有什么区别？&quot;&gt;&lt;a href&#x3D;&quot;#ES10-与-ES11-动态-import-函数有什么区别？&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;ES10 与 ES11 动态 import() 函数有什么区别？&quot;&gt;&lt;&#x2F;a&gt;ES10 与 ES11 动态 import() 函数有什么区别？&lt;&#x2F;h2&gt;&lt;p&gt;ES10 引入了动态 &lt;code&gt;import()&lt;&#x2F;code&gt; 函数，而 ES11 对它进行了一些改进。&lt;&#x2F;p&gt;\n&lt;p&gt;在 ES10 中，&lt;code&gt;import()&lt;&#x2F;code&gt; 函数是一个异步函数，它可以动态地导入 JavaScript 模块。它返回一个 Promise 对象，可以通过 Promise 的 then 方法获取导入的模块。&lt;&#x2F;p&gt;\n&lt;p&gt;在 ES11 中，&lt;code&gt;import()&lt;&#x2F;code&gt; 函数被更新，它可以在任何地方调用，而不仅仅是在顶级作用域中。这使得我们可以动态地导入模块，并将其赋值给变量或常量。&lt;&#x2F;p&gt;\n&lt;p&gt;ES11 还增加了一个新的特性，即顶级的 &lt;code&gt;await&lt;&#x2F;code&gt; 关键字。它允许我们在顶级作用域中使用 await，从而使得我们可以在模块加载完成之前阻塞 JavaScript 解释器。这意味着我们可以在模块加载完成之后再执行其他的代码，而不需要使用回调函数或 Promise 链。&lt;&#x2F;p&gt;\n&lt;p&gt;例如，下面的代码演示了如何使用顶级的 await 和动态 &lt;code&gt;import()&lt;&#x2F;code&gt; 函数：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;&#x2F;&#x2F; 在顶级作用域中使用 await 和 import()\nconst module &#x3D; await import(&#39;.&#x2F;module.js&#39;);\n\n&#x2F;&#x2F; 在模块加载完成之后再执行其他的代码\nconsole.log(module.foo());&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;需要注意的是，顶级的 &lt;code&gt;await&lt;&#x2F;code&gt; 关键字只能在 ES2017+ 的 JavaScript 模块中使用，并且只能在模块的顶级作用域中使用。如果在其他地方使用，会导致语法错误。&lt;&#x2F;p&gt;\n&lt;h1 id&#x3D;&quot;ES9&quot;&gt;&lt;a href&#x3D;&quot;#ES9&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;ES9&quot;&gt;&lt;&#x2F;a&gt;ES9&lt;&#x2F;h1&gt;&lt;p&gt;ECMAScript 2018，也称为 ES9，是 JavaScript 语言的第九个版本，于 2018 年 6 月发布。它引入了几个新的语言特性和功能，包括：&lt;&#x2F;p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Promise.prototype.finally()&lt;&#x2F;code&gt; 方法：用于在 Promise 结束时执行一些操作，无论 Promise 成功还是失败。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Rest&#x2F;Spread 属性&lt;&#x2F;code&gt;：用于对象和数组的解构赋值语法中，可以轻松地获取对象和数组的剩余部分。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;正则表达式的命名捕获组：可以在正则表达式中使用命名捕获组，从而使得正则表达式的匹配更加直观和易于理解。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;正则表达式的 &lt;code&gt;dotAll&lt;&#x2F;code&gt; 标志：可以匹配任何字符，包括行终止符。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Async Iteration&lt;&#x2F;code&gt;：可以使用 &lt;code&gt;for-await-of&lt;&#x2F;code&gt; 循环来遍历异步迭代器。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n&lt;p&gt;总之，ES9 引入了一些实用的新特性和功能，使得 JavaScript 语言更加现代化和强大。这些新特性和功能可以帮助开发者更加方便地编写复杂的 JavaScript 应用程序，并提高代码的可读性和可维护性。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;正则表达式的命名捕获组&quot;&gt;&lt;a href&#x3D;&quot;#正则表达式的命名捕获组&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;正则表达式的命名捕获组&quot;&gt;&lt;&#x2F;a&gt;正则表达式的命名捕获组&lt;&#x2F;h2&gt;&lt;p&gt;在 ES9 中，正则表达式新增了命名捕获组（Named Capture Groups）功能，它允许给正则表达式中的捕获组起一个名称，使得正则表达式的匹配结果更加直观和易于理解。&lt;&#x2F;p&gt;\n&lt;p&gt;命名捕获组可以通过 &lt;code&gt;(?&lt;name&gt;pattern)&lt;&#x2F;code&gt; 的语法来定义，其中 &lt;code&gt;name&lt;&#x2F;code&gt; 是捕获组的名称，&lt;code&gt;pattern&lt;&#x2F;code&gt; 是捕获组的正则表达式。在匹配成功后，可以使用 &lt;code&gt;match.groups&lt;&#x2F;code&gt; 属性来获取命名捕获组的结果，例如：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;const regex &#x3D; &#x2F;(?&lt;year&gt;\\d&amp;#123;4&amp;#125;)-(?&lt;month&gt;\\d&amp;#123;2&amp;#125;)-(?&lt;day&gt;\\d&amp;#123;2&amp;#125;)&#x2F;;\nconst result &#x3D; regex.exec(&#39;2021-05-18&#39;);\n\nconsole.log(result.groups.year); &#x2F;&#x2F; &quot;2021&quot;\nconsole.log(result.groups.month); &#x2F;&#x2F; &quot;05&quot;\nconsole.log(result.groups.day); &#x2F;&#x2F; &quot;18&quot;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;在上面的代码中，正则表达式 &lt;code&gt;&#x2F;(?&lt;year&gt;\\d&amp;#123;4&amp;#125;)-(?&lt;month&gt;\\d&amp;#123;2&amp;#125;)-(?&lt;day&gt;\\d&amp;#123;2&amp;#125;)&#x2F;&lt;&#x2F;code&gt; 匹配日期字符串，并定义了三个命名捕获组，分别对应年、月、日。在匹配成功后，可以通过 &lt;code&gt;result.groups&lt;&#x2F;code&gt; 属性获取命名捕获组的结果。&lt;&#x2F;p&gt;\n&lt;p&gt;命名捕获组的优点在于，可以用更加直观和自然的方式来访问捕获组的结果，而不需要记住捕获组的编号。同时，命名捕获组还可以提高代码的可读性和可维护性，使得正则表达式更加易于理解和修改。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;正则表达式的-dotAll-标志&quot;&gt;&lt;a href&#x3D;&quot;#正则表达式的-dotAll-标志&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;正则表达式的 dotAll 标志&quot;&gt;&lt;&#x2F;a&gt;正则表达式的 &lt;code&gt;dotAll&lt;&#x2F;code&gt; 标志&lt;&#x2F;h2&gt;&lt;p&gt;当使用正则表达式进行匹配时，默认情况下，&lt;code&gt;.&lt;&#x2F;code&gt; 只能匹配除了行终止符以外的任意字符。如果需要匹配包括行终止符在内的任意字符，就可以使用 &lt;code&gt;dotAll&lt;&#x2F;code&gt; 标志。&lt;&#x2F;p&gt;\n&lt;p&gt;在正则表达式中，&lt;code&gt;dotAll&lt;&#x2F;code&gt; 标志使用 &lt;code&gt;s&lt;&#x2F;code&gt; 表示，它可以通过在正则表达式末尾添加 &lt;code&gt;s&lt;&#x2F;code&gt; 来启用。&lt;&#x2F;p&gt;\n&lt;p&gt;以下是一个简化的例子：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;const regex &#x3D; &#x2F;hello.world&#x2F;s;\nconst str1 &#x3D; &#39;hello\\nworld&#39;;\nconst str2 &#x3D; &#39;hello world&#39;;\n\nconsole.log(regex.test(str1)); &#x2F;&#x2F; true\nconsole.log(regex.test(str2)); &#x2F;&#x2F; false&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;如果正则表达式需要匹配包括行终止符在内的任意字符，就可以添加 &lt;code&gt;s&lt;&#x2F;code&gt; 标志来启用 &lt;code&gt;dotAll&lt;&#x2F;code&gt; 功能。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;Async-Iteration&quot;&gt;&lt;a href&#x3D;&quot;#Async-Iteration&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;Async Iteration&quot;&gt;&lt;&#x2F;a&gt;Async Iteration&lt;&#x2F;h2&gt;&lt;p&gt;ES2018 引入了异步迭代器（Async Iteration）功能，它可以用于在异步环境下遍历数据集合，如异步操作返回的集合。异步迭代器通过 &lt;code&gt;Symbol.asyncIterator&lt;&#x2F;code&gt; 来定义，并使用 &lt;code&gt;for-await-of&lt;&#x2F;code&gt; 语句进行迭代。&lt;&#x2F;p&gt;\n&lt;p&gt;异步迭代器与普通迭代器的主要区别在于，它的 &lt;code&gt;next()&lt;&#x2F;code&gt; 方法返回的是一个 Promise 对象。当异步迭代器完成遍历时，它会返回一个 resolved 状态的 Promise 对象，并将 value 属性设置为 undefined。&lt;&#x2F;p&gt;\n&lt;p&gt;以下是一个简单的例子，演示了如何使用异步迭代器：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;async function* asyncGenerator() &amp;#123;\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n&amp;#125;\n\n(async function () &amp;#123;\n  for await (const item of asyncGenerator()) &amp;#123;\n    console.log(item);\n  &amp;#125;\n&amp;#125;)();&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;在上面的代码中，&lt;code&gt;asyncGenerator()&lt;&#x2F;code&gt; 函数定义了一个异步生成器，它通过 &lt;code&gt;yield&lt;&#x2F;code&gt; 关键字生成两个字符串。&lt;code&gt;for-await-of&lt;&#x2F;code&gt; 语句通过异步迭代器遍历异步生成器返回的数据集合，并依次打印每个元素的值。&lt;&#x2F;p&gt;\n&lt;p&gt;需要注意的是，在异步环境下，数据集合的获取和遍历过程都是异步的，因此需要使用 &lt;code&gt;async&#x2F;await&lt;&#x2F;code&gt; 来处理异步操作。&lt;&#x2F;p&gt;\n&lt;h1 id&#x3D;&quot;ES8&quot;&gt;&lt;a href&#x3D;&quot;#ES8&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;ES8&quot;&gt;&lt;&#x2F;a&gt;ES8&lt;&#x2F;h1&gt;&lt;p&gt;ES8（也称为 ECMAScript 2017）是 ECMAScript 标准的第八个版本，于 2017 年发布。ES8 引入了一些新功能和语言特性，包括：&lt;&#x2F;p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;异步函数（Async Functions）：ES8 引入了异步函数的概念，通过 &lt;code&gt;async&#x2F;await&lt;&#x2F;code&gt; 关键字，可以更方便地进行异步编程。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Object.values()&lt;&#x2F;code&gt; 和 &lt;code&gt;Object.entries()&lt;&#x2F;code&gt; 方法：这两个方法用于获取对象的属性值和键值对数组，便于对对象进行遍历。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;字符串填充方法 &lt;code&gt;padStart()&lt;&#x2F;code&gt; 和 &lt;code&gt;padEnd()&lt;&#x2F;code&gt;：这两个方法可以用于在字符串前面或后面添加指定数量的填充字符。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Object.getOwnPropertyDescriptors()&lt;&#x2F;code&gt; 方法：该方法返回指定对象所有自身属性（非继承属性）的描述符。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;函数参数列表和调用语法中的尾逗号&lt;&#x2F;code&gt;：在函数参数列表和函数调用语句的参数列表中，允许添加末尾的逗号，这使得代码的变更更加方便。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;SharedArrayBuffer&lt;&#x2F;code&gt; 对象：该对象用于创建可以被共享的缓冲区。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n&lt;p&gt;以上是 ES8 引入的一些新功能和语言特性。这些特性的引入使得 JavaScript 编程更加简洁和高效。&lt;&#x2F;p&gt;\n&lt;h1 id&#x3D;&quot;ES7&quot;&gt;&lt;a href&#x3D;&quot;#ES7&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;ES7&quot;&gt;&lt;&#x2F;a&gt;ES7&lt;&#x2F;h1&gt;&lt;p&gt;ES7（也称为 ECMAScript 2016）是 ECMAScript 标准的第七个版本，于 2016 年发布。ES7 引入了一些新功能和语言特性，包括：&lt;&#x2F;p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;数组的 &lt;code&gt;includes()&lt;&#x2F;code&gt; 方法：该方法用于检查数组是否包含指定的值。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;幂运算符（Exponentiation Operator）：使用 &lt;code&gt;**&lt;&#x2F;code&gt; 运算符可以进行幂运算，例如 &lt;code&gt;2 ** 3&lt;&#x2F;code&gt; 表示 2 的 3 次方。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;Async&lt;&#x2F;code&gt; 函数中的 &lt;code&gt;Await&lt;&#x2F;code&gt; 关键字可以在普通函数中使用：这意味着可以在普通函数中使用异步操作。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;li&gt;&lt;p&gt;函数绑定运算符（Function Binding Operator）：使用 &lt;code&gt;::&lt;&#x2F;code&gt; 运算符可以将函数绑定到指定的对象上。&lt;&#x2F;p&gt;\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n&lt;p&gt;以上是 ES7 引入的一些新功能和语言特性。这些特性的引入使得 JavaScript 编程更加方便和灵活。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;函数绑定运算符（Function-Binding-Operator）&quot;&gt;&lt;a href&#x3D;&quot;#函数绑定运算符（Function-Binding-Operator）&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;函数绑定运算符（Function Binding Operator）&quot;&gt;&lt;&#x2F;a&gt;函数绑定运算符（Function Binding Operator）&lt;&#x2F;h2&gt;&lt;p&gt;函数绑定运算符（Function Binding Operator）是 ES7（ECMAScript 2016）引入的一个新特性，它使用双冒号（::）作为运算符，可以将函数绑定到指定的对象上，形成一个新的绑定函数。&lt;&#x2F;p&gt;\n&lt;p&gt;使用函数绑定运算符可以简化代码，使代码更加简洁易懂。例如，使用函数绑定运算符可以将以下代码：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;const boundFn &#x3D; fn.bind(obj);&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;简化为：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;const boundFn &#x3D; obj::fn;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;其中，&lt;code&gt;fn&lt;&#x2F;code&gt; 是要绑定的函数，&lt;code&gt;obj&lt;&#x2F;code&gt; 是要绑定到的对象。绑定后的 &lt;code&gt;boundFn&lt;&#x2F;code&gt; 函数与 &lt;code&gt;fn&lt;&#x2F;code&gt; 函数相同，但它的 &lt;code&gt;this&lt;&#x2F;code&gt; 指向了 &lt;code&gt;obj&lt;&#x2F;code&gt; 对象。&lt;&#x2F;p&gt;\n&lt;p&gt;需要注意的是，函数绑定运算符只是一个语法糖，它本质上还是通过 &lt;code&gt;bind&lt;&#x2F;code&gt; 方法实现的，因此在使用函数绑定运算符时，需要保证该方法的可用性。此外，函数绑定运算符还存在一些语法限制，例如无法与箭头函数一起使用。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;完整示例&quot;&gt;&lt;a href&#x3D;&quot;#完整示例&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;完整示例&quot;&gt;&lt;&#x2F;a&gt;完整示例&lt;&#x2F;h2&gt;&lt;p&gt;以下是一个使用函数绑定运算符的完整示例：&lt;&#x2F;p&gt;\n&lt;pre class&#x3D;&quot;line-numbers language-javascript&quot; data-language&#x3D;&quot;javascript&quot;&gt;&lt;code class&#x3D;&quot;language-javascript&quot;&gt;&#x2F;&#x2F; 定义一个对象\nconst obj &#x3D; &amp;#123;\n  name: &#39;Tom&#39;,\n  sayHi() &amp;#123;\n    console.log(&#96;Hi, my name is $&amp;#123;this.name&amp;#125;.&#96;);\n  &amp;#125;,\n&amp;#125;;\n\n&#x2F;&#x2F; 绑定函数到对象上\nconst boundFn &#x3D; obj::obj.sayHi;\n\n&#x2F;&#x2F; 调用绑定函数\nboundFn(); &#x2F;&#x2F; 输出：Hi, my name is Tom.&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;\n\n&lt;p&gt;在上面的示例中，我们首先定义了一个包含 &lt;code&gt;name&lt;&#x2F;code&gt; 属性和 &lt;code&gt;sayHi&lt;&#x2F;code&gt; 方法的对象 &lt;code&gt;obj&lt;&#x2F;code&gt;。然后，使用函数绑定运算符将 &lt;code&gt;sayHi&lt;&#x2F;code&gt; 方法绑定到 &lt;code&gt;obj&lt;&#x2F;code&gt; 对象上，得到一个新的绑定函数 &lt;code&gt;boundFn&lt;&#x2F;code&gt;。最后，调用绑定函数 &lt;code&gt;boundFn&lt;&#x2F;code&gt;，输出 &lt;code&gt;Hi, my name is Tom.&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;\n&lt;p&gt;需要注意的是，&lt;code&gt;obj::obj.sayHi&lt;&#x2F;code&gt; 中的第一个 &lt;code&gt;obj&lt;&#x2F;code&gt; 是绑定的对象，第二个 &lt;code&gt;obj.sayHi&lt;&#x2F;code&gt; 则是要绑定的函数。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;直接写-const-boundFn-obj-sayHi-不是更简单吗？&quot;&gt;&lt;a href&#x3D;&quot;#直接写-const-boundFn-obj-sayHi-不是更简单吗？&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;直接写 const boundFn &#x3D; obj.sayHi; 不是更简单吗？&quot;&gt;&lt;&#x2F;a&gt;直接写 const boundFn &#x3D; obj.sayHi; 不是更简单吗？&lt;&#x2F;h2&gt;&lt;p&gt;是的，你说得没错，直接写 &lt;code&gt;const boundFn &#x3D; obj.sayHi&lt;&#x2F;code&gt; 也能得到一个指向 &lt;code&gt;obj.sayHi&lt;&#x2F;code&gt; 方法的函数。但是，在这种情况下，&lt;code&gt;boundFn&lt;&#x2F;code&gt; 函数的 &lt;code&gt;this&lt;&#x2F;code&gt; 指向将是调用该函数的上下文（即函数调用时所在的对象），而不是绑定到 &lt;code&gt;obj&lt;&#x2F;code&gt; 对象上。&lt;&#x2F;p&gt;\n&lt;p&gt;使用函数绑定运算符的优点在于，它可以显式地将函数绑定到指定的对象上，避免了由于函数调用时上下文的不确定性导致的错误。此外，它还能让代码更加简洁易懂，减少代码冗余。&lt;&#x2F;p&gt;\n&lt;h2 id&#x3D;&quot;已经有了-bind-为什么还要设计&quot;&gt;&lt;a href&#x3D;&quot;#已经有了-bind-为什么还要设计&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;已经有了 bind 为什么还要设计 ::&quot;&gt;&lt;&#x2F;a&gt;已经有了 bind 为什么还要设计 ::&lt;&#x2F;h2&gt;&lt;p&gt;&lt;code&gt;::&lt;&#x2F;code&gt; 函数绑定运算符的主要优势在于语法更加简洁，特别是在使用函数嵌套时，可以有效地减少代码的嵌套深度，使代码更加清晰易懂。相比之下，使用 &lt;code&gt;bind&lt;&#x2F;code&gt; 方法时需要手动指定函数的 &lt;code&gt;this&lt;&#x2F;code&gt; 值和任意多个参数，语法相对繁琐。&lt;&#x2F;p&gt;\n&lt;p&gt;此外，函数绑定运算符还可以在更大程度上保留函数原本的语义，而不是通过 &lt;code&gt;bind&lt;&#x2F;code&gt; 方法显式地创建一个新的函数。这种方式在函数柯里化和函数组合等场景中特别有用。&lt;&#x2F;p&gt;\n&lt;p&gt;当然，如果你更喜欢使用 &lt;code&gt;bind&lt;&#x2F;code&gt; 方法或其他方式进行函数绑定，完全没有问题。这只是 JavaScript 提供的一种语法糖，你可以根据自己的喜好和代码风格选择使用。&lt;&#x2F;p&gt;\n&lt;h1 id&#x3D;&quot;ES6&quot;&gt;&lt;a href&#x3D;&quot;#ES6&quot; class&#x3D;&quot;headerlink&quot; title&#x3D;&quot;ES6&quot;&gt;&lt;&#x2F;a&gt;ES6&lt;&#x2F;h1&gt;&lt;p&gt;ES6（ECMAScript 2015）是 JavaScript 语言的一个重大更新版本，引入了许多新特性和语法糖，使得 JavaScript 编程更加简单、直观和高效。&lt;&#x2F;p&gt;\n&lt;p&gt;一些 ES6 新特性包括：&lt;&#x2F;p&gt;\n&lt;ul&gt;\n&lt;li&gt;let 和 const 关键字，用于声明块级作用域的变量和常量。&lt;&#x2F;li&gt;\n&lt;li&gt;箭头函数，简化了函数定义的语法，并自动绑定了函数体内部的 this 指向。&lt;&#x2F;li&gt;\n&lt;li&gt;模板字符串，使得字符串拼接和格式化更加直观和方便。&lt;&#x2F;li&gt;\n&lt;li&gt;解构赋值，可以从对象或数组中快速提取值并赋给变量。&lt;&#x2F;li&gt;\n&lt;li&gt;默认参数和剩余参数，可以为函数的参数设置默认值或接受任意数量的参数。&lt;&#x2F;li&gt;\n&lt;li&gt;类和继承，提供了面向对象编程的语法和机制。&lt;&#x2F;li&gt;\n&lt;li&gt;Promise，为异步编程提供了更加方便和可靠的解决方案。&lt;&#x2F;li&gt;\n&lt;li&gt;模块化，可以方便地定义和导出模块，使得代码更加模块化和可重用。&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n&lt;p&gt;除此之外，ES6 还引入了很多其他的新特性和语法糖，如迭代器和生成器、Symbol、Proxy 和 Reflect 等，这些特性极大地拓展了 JavaScript 的功能和应用范围，使得它可以更好地应对现代 Web 开发的需求。&lt;&#x2F;p&gt;\n</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"包管理工具-pnpm","uid":"8fccc11bb8bff3e49fb035b6c0baca2d","slug":"2022-08-19pnpm","date":"2022-08-19T02:38:25.000Z","updated":"2023-07-08T01:06:25.347Z","comments":true,"path":"api/articles/2022-08-19pnpm.json","keywords":null,"cover":[],"text":"pnpm 官网 pnpm 安装路径👑 ~ $ which pnpm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pnpm 👑 ~ $ which pn pn: aliased to pnpm 使用较短的别名pnpm 可能很难输入，因此您可以使用较短的别名...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"包管理工具","slug":"包管理工具","count":1,"path":"api/categories/包管理工具.json"}],"tags":[{"name":"包管理工具","slug":"包管理工具","count":1,"path":"api/tags/包管理工具.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"企业微信- 授权","uid":"d81dd412709b6fc04e7a6fd5be173494","slug":"2022-08-17wx-auth","date":"2022-08-17T08:02:43.000Z","updated":"2022-11-21T13:08:33.115Z","comments":true,"path":"api/articles/2022-08-17wx-auth.json","keywords":null,"cover":[],"text":"背景 项目：已经有一个项目了，又整一个新项目共存 域名：一级相同，二级域名不同 微信授权回调限制, 回调可信域名只能配置一个 变更后的授权流程 draw.io 增加调试 - 强制内网强制 本地&#x2F;日常&#x2F;预发环境 走内网，方便在企业微信进行适配 &#x2F;&#x...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/categories/企业微信.json"}],"tags":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/tags/企业微信.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}