{"title":"性能指标 - LCP","uid":"c0c40ac20df205f0ad9a5f01d2cefd4b","slug":"2023-02-14web_lcp","date":"2023-02-14T13:19:15.000Z","updated":"2023-02-20T21:20:56.495Z","comments":true,"path":"api/articles/2023-02-14web_lcp.json","keywords":null,"cover":"https://web-dev.imgix.net/image/tcFciHGuF3MxnTr1y5ue01OGLBn2/ZZU8Z7TMKXmzZT2mCjJU.svg","content":"<h2 id=\"Largest-Contentful-Paint-LCP\"><a href=\"#Largest-Contentful-Paint-LCP\" class=\"headerlink\" title=\"Largest Contentful Paint (LCP)\"></a>Largest Contentful Paint (LCP)</h2><p>最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的 2.5 秒内发生</p>\n<img src=\"https://web-dev.imgix.net/image/tcFciHGuF3MxnTr1y5ue01OGLBn2/ZZU8Z7TMKXmzZT2mCjJU.svg\" style=\"width:200px;max-width:100%\" />\n\n<h2 id=\"导致-LCP-不佳的最常见原因是：\"><a href=\"#导致-LCP-不佳的最常见原因是：\" class=\"headerlink\" title=\"导致 LCP 不佳的最常见原因是：\"></a>导致 LCP 不佳的最常见原因是：</h2><ol>\n<li>缓慢的服务器响应速度</li>\n<li>阻塞渲染的 JavaScript 和 CSS</li>\n<li>缓慢的资源加载速度</li>\n<li>客户端渲染</li>\n</ol>\n<h2 id=\"缓慢的服务器响应速度\"><a href=\"#缓慢的服务器响应速度\" class=\"headerlink\" title=\"缓慢的服务器响应速度\"></a>缓慢的服务器响应速度</h2><p>您可以通过多种不同的方式来改进您的 TTFB：</p>\n<ol>\n<li>优化您的服务器</li>\n<li>CDN</li>\n<li>缓存资产<ol>\n<li>配置反向代理（Varnish、nginx）来提供缓存内容，或者当安装在应用程序服务器之前充当缓存服务器</li>\n<li>配置和管理您的云服务提供商（Firebase、AWS、Azure）的缓存行为</li>\n<li>使用提供边缘服务器的 CDN，以便将您的内容进行缓存并存储在离您的用户更近的地方</li>\n</ol>\n</li>\n<li>优先使用缓存提供 HTML 页面<ol>\n<li>安装好的 Service Worker 会在浏览器后台运行，并可以拦截来自服务器的请求。此级别的程序化缓存控制使得缓存部分或全部 HTML 页面内容得以实现，并且只会在内容发生更改时更新缓存。</li>\n</ol>\n</li>\n<li>尽早建立第三方连接<ol>\n<li><code>rel=&quot;preconnect&quot;</code>来告知浏览器您的页面打算尽快建立连接</li>\n<li><code>dns-prefetch</code> 来更快地完成 DNS 查找</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"阻塞渲染的-JavaScript-和-CSS-原因分析\"><a href=\"#阻塞渲染的-JavaScript-和-CSS-原因分析\" class=\"headerlink\" title=\"阻塞渲染的 JavaScript 和 CSS 原因分析\"></a>阻塞渲染的 JavaScript 和 CSS 原因分析</h2><ol>\n<li>浏览器在能够渲染任何内容之前，需要将 HTML 标记解析为 DOM 树。</li>\n<li>如果 HTML 解析器遇到任何外部样式表（<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>）或同步 JavaScript 标签（<code>&lt;script src=&quot;main.js&quot;&gt;</code>），则会暂停解析</li>\n<li><code>这些资源会使 FCP 延迟，进而导致 LCP 延迟</code>。</li>\n<li>延迟加载任何非关键的 JavaScript 和 CSS，从而提高网页主要内容的加载速度。</li>\n</ol>\n<h3 id=\"减少-CSS-阻塞时间\"><a href=\"#减少-CSS-阻塞时间\" class=\"headerlink\" title=\"减少 CSS 阻塞时间\"></a>减少 CSS 阻塞时间</h3><p>通过以下操作确保您的网站上只有最少量的必要 CSS 会阻塞渲染：</p>\n<ol>\n<li><p>关键的 CSS 要<code>削减</code></p>\n<ol>\n<li>对于 webpack：optimize-css-assets-webpack-plugin ,</li>\n<li>对于 Gulp：gulp-clean-css</li>\n<li>对于 Rollup：rollup-plugin-css-porter</li>\n</ol>\n</li>\n<li><p>非关键 CSS 要<code>延迟加载</code></p>\n<ol>\n<li>使用 Chrome 开发者工具中的<code>代码覆盖率选项卡</code>查找您网页上任何未使用的 CSS。</li>\n<li>如果是在您网站的单独页面上使用，可以将所有未使用的 CSS 完全删除或移动到另一个样式表。</li>\n<li>对于任何初始渲染时不需要的 CSS，请使用 loadCSS 来异步加载文件，这里运用了<code>rel=&quot;preload&quot;和onload</code></li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;link\n  rel&#x3D;&quot;preload&quot;\n  href&#x3D;&quot;stylesheet.css&quot;\n  as&#x3D;&quot;style&quot;\n  onload&#x3D;&quot;this.rel&#x3D;&#39;stylesheet&#39;&quot;\n&#x2F;&gt;</code></pre>\n</li>\n<li><p>关键的 CSS 进行<code>内联</code></p>\n<ol>\n<li>将重要样式进行内联后，就不再需要通过往返请求来获取关键 CSS。</li>\n<li>延迟加载其余部分可以最大限度地减少 CSS 阻塞时间</li>\n<li><code>Critters</code> 是一个 webpack 插件，能够内联关键 CSS 并对其余部分进行懒加载</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"减少-JavaScript-阻塞时间\"><a href=\"#减少-JavaScript-阻塞时间\" class=\"headerlink\" title=\"减少 JavaScript 阻塞时间\"></a>减少 JavaScript 阻塞时间</h3><p>下载并向用户提供尽可能少的必要 JavaScript。减少阻塞渲染的 JavaScript 数量能够让渲染速度更快，从而获得更好的 LCP。</p>\n<p>这可以通过优化您的脚本来实现，有如下几种不同的方式：</p>\n<ol>\n<li>削减和压缩 JavaScript 文件</li>\n<li>延迟加载未使用的 JavaScript</li>\n<li>最大限度减少未使用的 polyfill</li>\n</ol>\n<h2 id=\"其他资源的影响\"><a href=\"#其他资源的影响\" class=\"headerlink\" title=\"其他资源的影响\"></a>其他资源的影响</h2><h3 id=\"影响-LCP-的元素类型为：\"><a href=\"#影响-LCP-的元素类型为：\" class=\"headerlink\" title=\"影响 LCP 的元素类型为：\"></a>影响 LCP 的元素类型为：</h3><ol>\n<li><code>&lt;img&gt;</code>元素</li>\n<li>内嵌在<code>&lt;svg&gt;</code>元素内的<code>&lt;image&gt;</code>元素</li>\n<li><code>&lt;video&gt;</code>元素（使用封面图像测量 LCP）</li>\n<li>通过 <code>url()函数</code>加载的带有背景图像的元素</li>\n<li>包含<code>文本节点或其他行内级文本元素</code>的块级元素</li>\n</ol>\n<h3 id=\"优化措施\"><a href=\"#优化措施\" class=\"headerlink\" title=\"优化措施\"></a>优化措施</h3><ol>\n<li>优化和压缩图像</li>\n<li>压缩文本文件</li>\n<li>预加载重要资源</li>\n<li>基于网络连接交付不同资产（自适应服务）</li>\n<li>使用<code>Service Worker</code>缓存资产</li>\n</ol>\n<p><strong>优化压缩图像</strong></p>\n<ol>\n<li>首先考虑不使用图像。如果图像与内容无关，请将其删除。</li>\n<li>压缩图像（例如使用 <code>Imagemin</code>）</li>\n<li>文件格式（JPEG 2000、JPEG XR 或 WebP）</li>\n<li>使用响应式图像</li>\n<li>考虑使用图像 CDN</li>\n</ol>\n<h2 id=\"使用-Service-Worker-缓存资产\"><a href=\"#使用-Service-Worker-缓存资产\" class=\"headerlink\" title=\"使用 Service Worker 缓存资产\"></a>使用 Service Worker 缓存资产</h2><ol>\n<li><code>Service Worker</code> 可用于完成许多有用的任务，其中包括本文前面提到的提供较小的 HTML 响应。</li>\n<li>Service Worker 还可用于缓存任何静态资源，并在收到重复请求时将资源直接提供给浏览器，而无需通过网络。</li>\n<li>使用 Service Worker 预缓存关键资源可以显著减少资源加载时间，特别是对于使用较弱连接重新加载网页（甚至离线访问）的用户。</li>\n<li>与自己编写自定义 Service Worker 来更新预缓存资产相比，诸如 Workbox 这样的库可以使整个过程更加容易。</li>\n</ol>\n<h2 id=\"自适应服务-资源变体\"><a href=\"#自适应服务-资源变体\" class=\"headerlink\" title=\"自适应服务(资源变体)\"></a>自适应服务(资源变体)</h2><p>当加载构成页面主要内容的资源时，根据用户的设备或网络条件按需获取不同的资源会是一个有效做法。您可以使用网络状况 API、设备内存 API 和硬件并发 API 来实现这一做法。</p>\n<p>如果您有对初始渲染十分关键的大型资产，那么您可以根据用户的连接或设备采用同一资源的不同变体。例如，对于任何低于 4G 的连接速度，您可以显示图像，而不是视频：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (navigator.connection &amp;&amp; navigator.connection.effectiveType) &#123;\n  if (navigator.connection.effectiveType &#x3D;&#x3D;&#x3D; &quot;4g&quot;) &#123;\n    &#x2F;&#x2F; 加载视频\n  &#125; else &#123;\n    &#x2F;&#x2F; 加载图像\n  &#125;\n&#125;</code></pre>\n\n<p>您可以使用的一系列实用属性：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; navigator.connection.effectiveType：有效连接类型\n&#x2F;&#x2F; navigator.connection.saveData：启用&#x2F;禁用数据保护程序\n&#x2F;&#x2F; navigator.hardwareConcurrency：CPU 核心数\n&#x2F;&#x2F; navigator.deviceMemory：设备内存</code></pre>\n\n<h2 id=\"客户端渲染\"><a href=\"#客户端渲染\" class=\"headerlink\" title=\"客户端渲染\"></a>客户端渲染</h2><p>许多网站使用客户端 JavaScript 逻辑直接在浏览器中渲染页面。诸如 React、Angular 和 Vue 这类的框架和库使构建单页应用变得更加容易，这些单页应用完全在客户端（而不是在服务器）中处理网页的各个层面。</p>\n<p>如果您正在搭建一个主要在客户端进行渲染的网站，那么您应该特别小心网站在使用大型 JavaScript 包时可能对 LCP 产生的影响。如果您没有通过优化来加以阻止，那么在所有关键 JavaScript 完成下载和执行前，用户可能都无法看到页面上的任何内容或与之交互。</p>\n<p>在搭建客户端渲染的网站时，请考虑以下优化：</p>\n<ol>\n<li>最小化关键 JavaScript</li>\n<li>使用服务端渲染</li>\n<li>使用预渲染</li>\n</ol>\n<h3 id=\"最小化关键-JavaScript\"><a href=\"#最小化关键-JavaScript\" class=\"headerlink\" title=\"最小化关键 JavaScript\"></a>最小化关键 JavaScript</h3><ol>\n<li>削减 JavaScript</li>\n<li>延迟加载未使用的 JavaScript</li>\n<li>最大限度减少未使用的 polyfill</li>\n<li>请回到减少 JavaScript 阻塞时间部分，阅读有关这些优化的更多信息。</li>\n</ol>\n<h3 id=\"使用服务端渲染\"><a href=\"#使用服务端渲染\" class=\"headerlink\" title=\"使用服务端渲染\"></a>使用服务端渲染</h3><ol>\n<li><p>对于主要由客户端渲染的网站来说，首先需要关注的始终应该是将 JavaScript 的数量最小化。但是，您还应该考虑结合服务端渲染体验来尽可能地改善 LCP。</p>\n</li>\n<li><p>这个概念的实现方式是使用服务器将应用渲染为 HTML，然后客户端将所有 JavaScript 及所需数据”水合”到相同的 DOM 内容中。这个做法可以通过确保页面的主要内容首先在服务器上进行渲染（而不是仅在客户端上进行渲染）来改进 LCP，但该做法有一些弊端：</p>\n</li>\n<li><p>在服务器和客户端上维护相同的由 JavaScript 渲染的应用会增加复杂性。</p>\n</li>\n<li><p>与只使用服务器提供静态页面相比，在服务器上执行 JavaScript 来渲染 HTML 文件总是会增加服务器响应时间 (首字节时间 TTFB)。</p>\n</li>\n<li><p>服务端渲染的页面可能看似具备交互性，但在所有客户端 JavaScript 执行完毕之前，页面其实无法对任何用户输入作出响应。简而言之，该做法会使 Time to Interactive 可交互时间 (TTI) 变得更糟。</p>\n</li>\n</ol>\n<h3 id=\"使用预渲染\"><a href=\"#使用预渲染\" class=\"headerlink\" title=\"使用预渲染\"></a>使用预渲染</h3><p>预渲染是一种独立的技巧，该技巧比服务端渲染简单，并且还提供了一种改进应用程序 LCP 的方法。<br>无头浏览器是一种没有用户界面的浏览器，我们会用无头浏览器在搭建期间生成每个路由的静态 HTML 文件。<br>然后可以将这些文件与应用程序所需的 JavaScript 包一起进行运送。</p>\n<p>在使用预渲染后，TTI 仍然会受到负面影响，但服务器响应时间不会像服务端渲染解决方案（仅在接到请求后才对各个页面进行动态渲染）中那样受到很大影响。</p>\n","text":"Largest Contentful Paint (LCP)最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的 2.5 秒内发生 导致 LCP 不佳的最常见原因是： 缓慢的服务器响应速度 阻塞渲染的 JavaScript 和 CSS 缓慢的资源加...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Largest-Contentful-Paint-LCP\"><span class=\"toc-text\">Largest Contentful Paint (LCP)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E8%87%B4-LCP-%E4%B8%8D%E4%BD%B3%E7%9A%84%E6%9C%80%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%E6%98%AF%EF%BC%9A\"><span class=\"toc-text\">导致 LCP 不佳的最常见原因是：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E6%85%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">缓慢的服务器响应速度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%E7%9A%84-JavaScript-%E5%92%8C-CSS-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">阻塞渲染的 JavaScript 和 CSS 原因分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91-CSS-%E9%98%BB%E5%A1%9E%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">减少 CSS 阻塞时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91-JavaScript-%E9%98%BB%E5%A1%9E%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">减少 JavaScript 阻塞时间</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">其他资源的影响</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%B1%E5%93%8D-LCP-%E7%9A%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E4%B8%BA%EF%BC%9A\"><span class=\"toc-text\">影响 LCP 的元素类型为：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD\"><span class=\"toc-text\">优化措施</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Service-Worker-%E7%BC%93%E5%AD%98%E8%B5%84%E4%BA%A7\"><span class=\"toc-text\">使用 Service Worker 缓存资产</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E9%80%82%E5%BA%94%E6%9C%8D%E5%8A%A1-%E8%B5%84%E6%BA%90%E5%8F%98%E4%BD%93\"><span class=\"toc-text\">自适应服务(资源变体)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">客户端渲染</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E5%8C%96%E5%85%B3%E9%94%AE-JavaScript\"><span class=\"toc-text\">最小化关键 JavaScript</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">使用服务端渲染</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%A2%84%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">使用预渲染</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"性能指标 - FID","uid":"7f4dccbee0ac34fdbc8e55c8be3f50e9","slug":"2023-02-14web_fid","date":"2023-02-14T14:04:49.000Z","updated":"2023-02-20T21:20:56.495Z","comments":true,"path":"api/articles/2023-02-14web_fid.json","keywords":null,"cover":"https://web-dev.imgix.net/image/tcFciHGuF3MxnTr1y5ue01OGLBn2/iHYrrXKe4QRcb2uu8eV8.svg","text":"First Input Delay (FID)首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为 100 毫秒或更短 如何改进 FID要了解如何改进某个特定网站的 FID，您可以运行一次灯塔性能审计，并留心查看审计建议的各种具体机会。 虽然 FID 是一项实际...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Web performance","uid":"e2a10815e593824fa56e5bdca444887f","slug":"2023-02-12Web_Performance","date":"2023-02-12T13:59:56.000Z","updated":"2023-02-20T21:20:56.492Z","comments":true,"path":"api/articles/2023-02-12Web_Performance.json","keywords":null,"cover":[],"text":"Web_PerformanceWeb 性能 Animation performance and frame rateAnimation performance and frame rate 对于动画媒体 文件动画： 例如视频和动画 gif，主要的性能问题是文件大小——下载文件的速...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}