{"title":"Redis 命令及分区","uid":"66c41c8c78c6433d94dadc3b731a3d3d","slug":"2022-11-04redis","date":"2022-11-04T09:09:30.000Z","updated":"2023-03-07T14:09:36.378Z","comments":true,"path":"api/articles/2022-11-04redis.json","keywords":null,"cover":[],"content":"<h2 id=\"爬取脚本\"><a href=\"#爬取脚本\" class=\"headerlink\" title=\"爬取脚本\"></a>爬取脚本</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var data &#x3D; &quot;&quot;;\nArray.from(document.getElementsByClassName(&quot;left&quot;)[0].children[1].children).forEach((li) &#x3D;&gt; &#123;\n  var a &#x3D; li.children[0];\n  data +&#x3D; &#96;\\&#96;$&#123;a.innerText&#125;\\&#96;: \\n&#96;.replace(&quot;Redis &quot;, &quot;&quot;).replace(&quot; 命令&quot;, &quot;&quot;);\n&#125;);\ncopy(data);</code></pre>\n\n<h2 id=\"最最基本\"><a href=\"#最最基本\" class=\"headerlink\" title=\"最最基本\"></a>最最基本</h2><ul>\n<li>redis 是数据库，具备增删改查</li>\n<li>redis 数据“分类型储存”，命令进行类型操作</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>懒得安装了，直接用在线的吧 <a href=\"https://try.redis.io/\" target=\"_blank\" >https://try.redis.io/</a></p>\n<h2 id=\"Number-数值\"><a href=\"#Number-数值\" class=\"headerlink\" title=\"Number 数值\"></a>Number 数值</h2><h3 id=\"加\"><a href=\"#加\" class=\"headerlink\" title=\"加\"></a>加</h3><ul>\n<li><code>Incr</code>:</li>\n<li><code>Incrby</code>:</li>\n<li><code>Incrbyfloat</code>:</li>\n</ul>\n<h3 id=\"减\"><a href=\"#减\" class=\"headerlink\" title=\"减\"></a>减</h3><ul>\n<li><code>Decr</code>:</li>\n<li><code>Decrby</code>:</li>\n</ul>\n<h2 id=\"String-字符串\"><a href=\"#String-字符串\" class=\"headerlink\" title=\"String 字符串\"></a>String 字符串</h2><h3 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h3><ul>\n<li><code>SET</code>: 设置指定 key 的值 <code>SET KEY_NAME VALUE</code></li>\n<li><code>Mset</code>: 同时设置一个或多个 key-value 对 <code>MSET key1 value1 key2 value2 .. keyN valueN</code></li>\n<li><code>Setnx</code>: 只有在 key 不存在时设置 key 的值 <code>SETNX KEY_NAME VALUE</code></li>\n<li><code>Msetnx</code>: 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在 <code>MSETNX key1 value1 key2 value2 .. keyN valueN</code></li>\n<li><code>Setex</code>: 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) <code>SETEX KEY_NAME TIMEOUT VALUE</code></li>\n<li><code>Setbit</code>: 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit) <code>Setbit KEY_NAME OFFSET</code> <a href=\"https://blog.csdn.net/qq_18433441/article/details/79650406\" target=\"_blank\" >对 redis 中 setbit 命令的理解</a></li>\n<li><code>Setrange</code>: 从偏移量 offset 开始,用 value 参数覆写给定 key 所储存的字符串值 <code>SETRANGE KEY_NAME OFFSET VALUE</code></li>\n<li><code>Psetex</code>: 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位<code>PSETEX key1 EXPIRY_IN_MILLISECONDS value1 </code></li>\n</ul>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><ul>\n<li><code>Getrange</code>: 返回 key 中字符串值的子字符 <code>GETRANGE KEY_NAME start end</code></li>\n<li><code>Get</code>: 获取指定 key 的值 <code>GET KEY_NAME</code></li>\n<li><code>Getbit</code>: 对 key 所储存的字符串值，获取指定偏移量上的位(bit) <code>GETBIT KEY_NAME OFFSET</code></li>\n<li><code>Getset</code>: 将给定 key 的值设为 value ，并返回 key 的旧值(old value) <code>GETSET KEY_NAME VALUE</code></li>\n<li><code>Mget</code>: 获取所有(一个或多个)给定 key 的值 <code>MGET KEY1 KEY2 .. KEYN</code></li>\n<li><code>Strlen</code>: 返回 key 所储存的字符串值的长度 <code>STRLEN KEY_NAME</code></li>\n<li><code>Append</code>: 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾,不存在新增 <code>APPEND KEY_NAME NEW_VALUE</code></li>\n</ul>\n<h2 id=\"Hash-对象存储\"><a href=\"#Hash-对象存储\" class=\"headerlink\" title=\"Hash 对象存储\"></a>Hash 对象存储</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>对象存储，对象的 k-v 编辑</p>\n<h3 id=\"Hash-增\"><a href=\"#Hash-增\" class=\"headerlink\" title=\"Hash 增\"></a>Hash 增</h3><ul>\n<li><code>Hmset</code>: 同时将多个 field-value (域-值)对设置到哈希表 key 中 <code>HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN</code></li>\n<li><code>Hmget</code>: 获取所有给定字段的值 <code>HMGET KEY_NAME FIELD1...FIELDN</code></li>\n<li><code>Hset</code>: 将哈希表 key 中的字段 field 的值设为 value <code>HSET KEY_NAME FIELD VALUE </code></li>\n<li><code>Hsetnx</code>: 只有在字段 field 不存在时，设置哈希表字段的值。<code>HSETNX KEY_NAME FIELD VALUE</code></li>\n</ul>\n<h3 id=\"Hash-删\"><a href=\"#Hash-删\" class=\"headerlink\" title=\"Hash 删\"></a>Hash 删</h3><ul>\n<li><code>Hdel</code>: 删除一个或多个哈希表字段 <code>HDEL KEY_NAME FIELD1.. FIELDN </code></li>\n</ul>\n<h3 id=\"Hash-改\"><a href=\"#Hash-改\" class=\"headerlink\" title=\"Hash 改\"></a>Hash 改</h3><ul>\n<li><code>Hincrbyfloat</code>: Redis Hincrbyfloat 命令 - 为哈希表 key 中的指定字段的浮点数值加上增量 increment <code>HINCRBYFLOAT KEY_NAME FIELD_NAME INCR_BY_NUMBER </code></li>\n<li><code>Hincrby</code>: 为哈希表 key 中的指定字段的整数值加上增量 increment <code>HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER</code></li>\n</ul>\n<h3 id=\"Hash-查\"><a href=\"#Hash-查\" class=\"headerlink\" title=\"Hash 查\"></a>Hash 查</h3><ul>\n<li><code>Hget</code>: 获取存储在哈希表中指定字段的值 <code>HGET KEY_NAME FIELD_NAME</code></li>\n<li><code>Hgetall</code>: 获取在哈希表中指定 key 的所有字段和值 <code>HGETALL KEY_NAME </code></li>\n<li><code>Hkeys</code>: 获取所有哈希表中的字段 <code>HKEYS KEY_NAME</code></li>\n<li><code>Hvals</code>: 获取哈希表中所有值 <code>HVALS KEY_NAME FIELD VALUE </code></li>\n<li><code>Hexists</code>: 查看哈希表 key 中，指定的字段是否存在 <code>HEXISTS KEY_NAME FIELD_NAME</code></li>\n<li><code>Hlen</code>: 获取哈希表中字段的数量 <code>HLEN KEY_NAME</code></li>\n</ul>\n<h2 id=\"LIST-列表存储\"><a href=\"#LIST-列表存储\" class=\"headerlink\" title=\"LIST 列表存储\"></a>LIST 列表存储</h2><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>有点像数组的增删“改”查，没看到有改的方法</p>\n<h3 id=\"LIST-增\"><a href=\"#LIST-增\" class=\"headerlink\" title=\"LIST 增\"></a>LIST 增</h3><ul>\n<li><code>Lset</code>: 通过索引设置列表元素的值 <code>LSET KEY_NAME INDEX VALUE</code></li>\n<li><code>Linsert</code>: 在列表的元素前或者后插入元素 <code>LINSERT KEY_NAME BEFORE EXISTING_VALUE NEW_VALUE </code></li>\n<li><code>Lpushx</code>: 将一个或多个值插入到已存在的列表头部 <code>LPUSHX KEY_NAME VALUE1.. VALUEN</code></li>\n<li><code>Rpushx</code>: 为已存在的列表添加值 <code>RPUSHX KEY_NAME VALUE1..VALUEN</code></li>\n<li><code>Lpush</code>:在列表头部添加一个或多个值 <code>LPUSH KEY_NAME VALUE1.. VALUEN</code></li>\n<li><code>Rpush</code>: 在列表尾部添加一个或多个值 <code>RPUSH KEY_NAME VALUE1..VALUEN</code></li>\n</ul>\n<h3 id=\"LIST-删\"><a href=\"#LIST-删\" class=\"headerlink\" title=\"LIST 删\"></a>LIST 删</h3><ul>\n<li><code>Lrem</code>: 移除列表元素 <code>LREM KEY_NAME COUNT VALUE</code></li>\n<li><code>Ltrim</code>: 只保留指定区间内的元素 <code>LTRIM KEY_NAME START STOP</code></li>\n<li><code>Rpoplpush</code>: 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 <code>RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME</code></li>\n<li><code>Brpoplpush</code>: 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；</li>\n<li><code>BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT </code></li>\n<li><code>Blpop</code>: 移出并获取列表的第一个元素 <code>BLPOP LIST1 LIST2 .. LISTN TIMEOUT</code></li>\n<li><code>Brpop</code>: 移出并获取列表的最后一个元素 <code>BRPOP LIST1 LIST2 .. LISTN TIMEOUT </code></li>\n<li><code>Lpop</code>: 移出并获取列表的第一个元素 <code>LPOP KEY_NAME</code></li>\n<li><code>Rpop</code>: 移除并获取列表最后一个元素 <code>RPOP KEY_NAME</code></li>\n</ul>\n<p><strong>注意：带有 <code>TIMEOUT</code> 的命令。如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></p>\n<h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><ul>\n<li>清空列表 <code>ltrim key start end</code> 中的 start 要比 end 大即可，数值且都为正数。如：<code>ltrim key 1 0</code></li>\n</ul>\n<h3 id=\"LIST-改\"><a href=\"#LIST-改\" class=\"headerlink\" title=\"LIST 改\"></a>LIST 改</h3><h3 id=\"LIST-查\"><a href=\"#LIST-查\" class=\"headerlink\" title=\"LIST 查\"></a>LIST 查</h3><p>Lindex 命令 通过索引获取列表中的元素 <code>LINDEX KEY_NAME INDEX_POSITION</code><br>Lrange 命令 获取列表指定范围内的元素 <code>LRANGE KEY_NAME START END</code><br>Llen 命令 获取列表长度 <code>LLEN KEY_NAME </code></p>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"增-1\"><a href=\"#增-1\" class=\"headerlink\" title=\"增\"></a>增</h3><ul>\n<li><code>Sadd</code>: 向集合添加一个或多个成员 <code>SADD KEY_NAME VALUE1..VALUEN</code></li>\n</ul>\n<h3 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h3><ul>\n<li><code>Srem</code>: 移除集合中一个或多个成员 <code>SREM KEY MEMBER1..MEMBERN</code></li>\n<li><code>Spop</code>: 移除并返回集合中的一个随机元素 <code>SPOP KEY</code></li>\n</ul>\n<h3 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h3><ul>\n<li><code>Smove</code>: 将 member 元素从 source 集合移动到 destination 集合 <code>SMOVE SOURCE DESTINATION MEMBER</code></li>\n</ul>\n<h3 id=\"查-1\"><a href=\"#查-1\" class=\"headerlink\" title=\"查\"></a>查</h3><ul>\n<li><code>Smembers</code>: 返回集合中的所有成员 <code>SMEMBERS KEY VALUE </code></li>\n<li><code>Scard</code>: 获取集合的成员数 <code>SCARD KEY_NAME</code> <span style=\"color: red\">你用个 scount 也比 scard 好啊</span></li>\n<li><code>Sscan</code>: 迭代集合中的元素 <code>SSCAN KEY [MATCH pattern] [COUNT count]</code> <strong>没看懂</strong></li>\n<li><code>Srandmember</code>: 返回集合中一个或多个随机数 <code>SRANDMEMBER KEY [count]</code></li>\n<li><code>Sismember</code>: 判断 member 元素是否是集合 key 的成员 <code>SISMEMBER KEY VALUE</code></li>\n</ul>\n<h3 id=\"交集\"><a href=\"#交集\" class=\"headerlink\" title=\"交集\"></a>交集</h3><ul>\n<li><code>Sinter</code>: 返回给定所有集合的交集 <code>SINTER KEY KEY1..KEYN </code></li>\n<li><code>Sinterstore</code>: 返回给定所有集合的交集并存储在 destination <code>SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN</code></li>\n</ul>\n<h3 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集\"></a>并集</h3><ul>\n<li><code>Sunion</code>: 返回所有给定集合的并集 <code>SUNION KEY KEY1..KEYN</code></li>\n<li><code>Sunionstore</code>: 所有给定集合的并集存储在 destination <code>SUNIONSTORE DESTINATION KEY KEY1..KEYN</code></li>\n</ul>\n<h3 id=\"差集\"><a href=\"#差集\" class=\"headerlink\" title=\"差集\"></a>差集</h3><ul>\n<li><code>Sdiff</code>: 返回给定所有集合的差集 <code>SDIFF KEY KEY1..KEYN</code></li>\n<li><code>Sdiffstore</code>: 返回给定所有集合的差集并存储在 destination <code>SDIFFSTORE DESTINATION_KEY KEY1..KEYN</code></li>\n</ul>\n<h2 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h2><ul>\n<li><code>每个元素都会关联一个 double 类型的分数</code>。redis 正是通过分数来为集合中的成员进行<code>从小到大</code>的排序。</li>\n<li>有序集合的成员是唯一的,但<code>分数(score)却可以重复</code></li>\n</ul>\n<h3 id=\"增-2\"><a href=\"#增-2\" class=\"headerlink\" title=\"增\"></a>增</h3><ul>\n<li><code>Zadd</code>: 向有序集合添加一个或多个成员，或者更新已存在成员的分数 <code>ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN</code></li>\n</ul>\n<h3 id=\"删-1\"><a href=\"#删-1\" class=\"headerlink\" title=\"删\"></a>删</h3><ul>\n<li><code>Zrem</code>: 移除有序集合中的一个或多个成员 <code>ZRANK key member</code></li>\n<li><code>Zremrangebyrank</code>: 移除有序集合中给定的分数区间的所有成员 <code>ZREMRANGEBYSCORE key min max</code></li>\n<li><code>Zremrangebylex</code>: 移除有序集合中给定的字典区间的所有成员 <code>ZREMRANGEBYLEX key min max</code> <code>这里原文档书写有误</code></li>\n</ul>\n<img src=\"http://t-blog-images.aijs.top/img/202211042109618.png\" />\n\n<h3 id=\"改-1\"><a href=\"#改-1\" class=\"headerlink\" title=\"改\"></a>改</h3><ul>\n<li><code>Zincrby</code>: 有序集合中对指定成员的分数加上增量 increment <code>ZINCRBY key increment member</code></li>\n</ul>\n<h3 id=\"查-2\"><a href=\"#查-2\" class=\"headerlink\" title=\"查\"></a>查</h3><ul>\n<li><code>Zcard</code>: 获取有序集合的成员数 <code>ZCARD KEY_NAME</code></li>\n<li><code>Zrange</code>: 通过索引区间返回有序集合成指定区间内的成员 <code>ZRANGE key start stop [WITHSCORES]</code> # 显示有序集下标区间 start 至 stop 的成员</li>\n<li><code>Zrangebylex</code>: 移除有序集合中给定的字典区间的所有成员 <code>ZREMRANGEBYLEX key min max</code></li>\n<li><code>Zrangebyscore</code>: 通过分数返回有序集合指定区间内的成员 <code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> # -inf +inf 正负无穷大</li>\n<li><code>Zcount</code>: 计算在有序集合中指定区间分数的成员数 <code>ZCOUNT key min max</code></li>\n<li><code>Zlexcount</code>:在有序集合中计算指定字典区间内成员数量 <code>ZLEXCOUNT KEY MIN MAX</code></li>\n<li><code>Zrank</code>: 获得成员按分数值递增(从小到大)排列的排名 <code>ZRANK key member</code></li>\n<li><code>Zrevrank</code>: 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 <code>ZREVRANK key member</code></li>\n</ul>\n<h3 id=\"交集-1\"><a href=\"#交集-1\" class=\"headerlink\" title=\"交集\"></a>交集</h3><ul>\n<li><code>Zinterstore</code>: 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 <code>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></li>\n</ul>\n<h3 id=\"并集-1\"><a href=\"#并集-1\" class=\"headerlink\" title=\"并集\"></a>并集</h3><ul>\n<li><code>Zunionstore</code>: 计算给定的一个或多个有序集的并集，并存储在新的 key 中 <code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></li>\n</ul>\n<h3 id=\"差集-1\"><a href=\"#差集-1\" class=\"headerlink\" title=\"差集\"></a>差集</h3><ul>\n<li><code>Zscore</code>: 返回有序集中，成员的分数值 <code>ZSCORE key member</code></li>\n<li><code>Zscan</code>: 迭代有序集合中的元素（包括元素成员和元素分值） <code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code> ???</li>\n<li><code>Zremrangebylex</code>: 移除有序集合中给定的字典区间的所有成员 <code>ZREMRANGEBYLEX key min max</code></li>\n<li><code>Zrevrangebyscore</code>: 移除有序集合中给定的分数区间的所有成员 <code>ZREMRANGEBYSCORE key min max</code></li>\n<li><code>Zrevrange</code>: 返回有序集中指定区间内的成员，通过索引，分数从高到底 <code>ZREVRANGE key start stop [WITHSCORES]</code></li>\n</ul>\n<h2 id=\"Redis-发布订阅-有啥用\"><a href=\"#Redis-发布订阅-有啥用\" class=\"headerlink\" title=\"Redis 发布订阅? 有啥用\"></a>Redis 发布订阅? 有啥用</h2><h2 id=\"Redis-事务【一损俱损】\"><a href=\"#Redis-事务【一损俱损】\" class=\"headerlink\" title=\"Redis 事务【一损俱损】\"></a>Redis 事务【一损俱损】</h2><h3 id=\"Redis-事务三个阶段\"><a href=\"#Redis-事务三个阶段\" class=\"headerlink\" title=\"Redis 事务三个阶段\"></a>Redis 事务三个阶段</h3><p>一个事务从开始到执行会经历以下三个阶段：</p>\n<ul>\n<li>开始事务。</li>\n<li>命令入队。</li>\n<li>执行事务。</li>\n</ul>\n<h3 id=\"Redis-事务命令\"><a href=\"#Redis-事务命令\" class=\"headerlink\" title=\"Redis 事务命令\"></a>Redis 事务命令</h3><ol>\n<li><code>MULTI</code> 标记一个事务块的开始。</li>\n<li><code>EXEC</code> 执行所有事务块内的命令。</li>\n<li><code>DISCARD</code> 取消事务，放弃执行事务块内的所有命令。</li>\n<li><code>UNWATCH</code> 取消 WATCH 命令对所有 key 的监视。</li>\n<li><code>WATCH key [key ...]</code> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li>\n</ol>\n<h2 id=\"Redis-脚本\"><a href=\"#Redis-脚本\" class=\"headerlink\" title=\"Redis 脚本\"></a>Redis 脚本</h2><h3 id=\"eval-呃怎么和-js-eval-那么像\"><a href=\"#eval-呃怎么和-js-eval-那么像\" class=\"headerlink\" title=\"eval 呃怎么和 js eval 那么像\"></a>eval 呃怎么和 js eval 那么像</h3><p>Redis 脚本使用 Lua 解释器来执行脚本 Redis 脚本使用 Lua 解释器来执行脚本</p>\n<p>【暂时跳过】没时间整这个</p>\n<h3 id=\"连接命令\"><a href=\"#连接命令\" class=\"headerlink\" title=\"连接命令\"></a>连接命令</h3><ol>\n<li>AUTH password 验证密码是否正确</li>\n<li>ECHO message 打印字符串</li>\n<li>PING 查看服务是否运行</li>\n<li>QUIT 关闭当前连接</li>\n<li>SELECT index 切换到指定的数据库</li>\n</ol>\n<h2 id=\"分区\"><a href=\"#分区\" class=\"headerlink\" title=\"分区\"></a>分区</h2><h3 id=\"分区的优势【容量大，速度快】\"><a href=\"#分区的优势【容量大，速度快】\" class=\"headerlink\" title=\"分区的优势【容量大，速度快】\"></a>分区的优势【容量大，速度快】</h3><ul>\n<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>\n<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>\n</ul>\n<h3 id=\"分区的不足【复杂度高，操作、事务受限】\"><a href=\"#分区的不足【复杂度高，操作、事务受限】\" class=\"headerlink\" title=\"分区的不足【复杂度高，操作、事务受限】\"></a>分区的不足【复杂度高，操作、事务受限】</h3><p>redis 的一些特性在分区方面表现的不是很好：</p>\n<ul>\n<li>涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的 redis 实例上时，你就不能对这两个 set 执行交集操作。</li>\n<li>涉及多个 key 的 redis 事务不能使用。</li>\n<li>当使用分区时，数据处理较为复杂</li>\n</ul>\n<h3 id=\"分区类型\"><a href=\"#分区类型\" class=\"headerlink\" title=\"分区类型\"></a>分区类型</h3><p>Redis 有两种类型分区。 假设有 4 个 Redis 实例 R0，R1，R2，R3，和类似 user:1，user:2 这样的表示用户的多个 key，对既定的 key 有多种不同方式来选择这个 key 存放在哪个实例中。也就是说，有不同的系统来映射某个 key 到某个 Redis 服务。</p>\n<h4 id=\"范围分区\"><a href=\"#范围分区\" class=\"headerlink\" title=\"范围分区\"></a>范围分区</h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。</p>\n<p>比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用户会保存到 R1，以此类推。</p>\n<p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对 Redis 来说并非是好的方法。</p>\n<h4 id=\"哈希分区【这个更优】\"><a href=\"#哈希分区【这个更优】\" class=\"headerlink\" title=\"哈希分区【这个更优】\"></a>哈希分区【这个更优】</h4><p>另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是 object_name:这种形式，像下面描述的一样简单：</p>\n<p>用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key foobar 执行 crc32(foobar)会输出类似 93024922 的整数。<br>对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个 Redis 实例中的一个了。93024922 % 4 &#x3D; 2，就是说 key foobar 应该被存到 R2 实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.redis.net.cn/order/3573.html\" target=\"_blank\" >https://www.redis.net.cn/order/3573.html</a></p>\n<p><a href=\"https://try.redis.io/\" target=\"_blank\" >https://try.redis.io/</a></p>\n<p>吐槽：某些云厂家卖人家的东西，也不给社区捐钱，啊呸</p>\n","text":"爬取脚本var data &#x3D; &quot;&quot;; Array.from(document.getElementsByClassName(&quot;left&quot;)[0].children[1].children).forEach((li) &#x3D;&...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"Redis","slug":"Redis","count":1,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%88%AC%E5%8F%96%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">爬取脚本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E6%9C%80%E5%9F%BA%E6%9C%AC\"><span class=\"toc-text\">最最基本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">安装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Number-%E6%95%B0%E5%80%BC\"><span class=\"toc-text\">Number 数值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0\"><span class=\"toc-text\">加</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F\"><span class=\"toc-text\">减</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#String-%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">String 字符串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A2%9E\"><span class=\"toc-text\">增</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5\"><span class=\"toc-text\">查</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hash-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">Hash 对象存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hash-%E5%A2%9E\"><span class=\"toc-text\">Hash 增</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hash-%E5%88%A0\"><span class=\"toc-text\">Hash 删</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hash-%E6%94%B9\"><span class=\"toc-text\">Hash 改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hash-%E6%9F%A5\"><span class=\"toc-text\">Hash 查</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LIST-%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">LIST 列表存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0-1\"><span class=\"toc-text\">描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LIST-%E5%A2%9E\"><span class=\"toc-text\">LIST 增</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LIST-%E5%88%A0\"><span class=\"toc-text\">LIST 删</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">技巧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LIST-%E6%94%B9\"><span class=\"toc-text\">LIST 改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LIST-%E6%9F%A5\"><span class=\"toc-text\">LIST 查</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88\"><span class=\"toc-text\">集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A2%9E-1\"><span class=\"toc-text\">增</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0\"><span class=\"toc-text\">删</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%B9\"><span class=\"toc-text\">改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5-1\"><span class=\"toc-text\">查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E9%9B%86\"><span class=\"toc-text\">交集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E9%9B%86\"><span class=\"toc-text\">并集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%AE%E9%9B%86\"><span class=\"toc-text\">差集</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88\"><span class=\"toc-text\">有序集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A2%9E-2\"><span class=\"toc-text\">增</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0-1\"><span class=\"toc-text\">删</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%B9-1\"><span class=\"toc-text\">改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5-2\"><span class=\"toc-text\">查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E9%9B%86-1\"><span class=\"toc-text\">交集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E9%9B%86-1\"><span class=\"toc-text\">并集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%AE%E9%9B%86-1\"><span class=\"toc-text\">差集</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E6%9C%89%E5%95%A5%E7%94%A8\"><span class=\"toc-text\">Redis 发布订阅? 有啥用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis-%E4%BA%8B%E5%8A%A1%E3%80%90%E4%B8%80%E6%8D%9F%E4%BF%B1%E6%8D%9F%E3%80%91\"><span class=\"toc-text\">Redis 事务【一损俱损】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis-%E4%BA%8B%E5%8A%A1%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">Redis 事务三个阶段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis-%E4%BA%8B%E5%8A%A1%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">Redis 事务命令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis-%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">Redis 脚本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#eval-%E5%91%83%E6%80%8E%E4%B9%88%E5%92%8C-js-eval-%E9%82%A3%E4%B9%88%E5%83%8F\"><span class=\"toc-text\">eval 呃怎么和 js eval 那么像</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">连接命令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">分区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E7%9A%84%E4%BC%98%E5%8A%BF%E3%80%90%E5%AE%B9%E9%87%8F%E5%A4%A7%EF%BC%8C%E9%80%9F%E5%BA%A6%E5%BF%AB%E3%80%91\"><span class=\"toc-text\">分区的优势【容量大，速度快】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E7%9A%84%E4%B8%8D%E8%B6%B3%E3%80%90%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%AB%98%EF%BC%8C%E6%93%8D%E4%BD%9C%E3%80%81%E4%BA%8B%E5%8A%A1%E5%8F%97%E9%99%90%E3%80%91\"><span class=\"toc-text\">分区的不足【复杂度高，操作、事务受限】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">分区类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">范围分区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%E3%80%90%E8%BF%99%E4%B8%AA%E6%9B%B4%E4%BC%98%E3%80%91\"><span class=\"toc-text\">哈希分区【这个更优】</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"云原生 给自己科普 k8s","uid":"492312f2926ba8445ea0e3998e226f61","slug":"2022-11-05k8s","date":"2022-11-05T06:50:49.000Z","updated":"2022-12-22T13:36:21.795Z","comments":true,"path":"api/articles/2022-11-05k8s.json","keywords":null,"cover":"https://img1.baidu.com/it/u=2053451129,2889213081&fm=253&fmt=auto&app=138&f=PNG?w=640&h=320","text":"满脑子问题k8s 是什么k8s 如何安装k8s 为什么最少 3 个 masterk8s 如何控制 node如何进行 iterm 多服务器操作scp 命令如何使用？有教程吗？sz 命令如何安装环境为什么要配置 host如何安装 yumlkind 种类有几个？应该用哪个？思维导图爬取...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"云原生","slug":"云原生","count":5,"path":"api/categories/云原生.json"}],"tags":[{"name":"云原生","slug":"云原生","count":5,"path":"api/tags/云原生.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Graphql","uid":"b629fbc3034174b0bda5cbb3b1a0e487","slug":"2022-11-03graphql","date":"2022-11-03T09:51:55.000Z","updated":"2022-11-04T12:06:31.430Z","comments":true,"path":"api/articles/2022-11-03graphql.json","keywords":null,"cover":[],"text":"文章背景中文官网废话太多，语句也有些不通顺的地方 Graphql 是什么GraphQL 全称叫 Graph Query Language，官方宣传语是“为你的 API 量身定制的查询语言”。 用传统的方式来解释就是：相当于将你所有后端 API 组成的集合看成一个数据库，用户终端发...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Graphql","slug":"Graphql","count":1,"path":"api/categories/Graphql.json"}],"tags":[{"name":"Graphql","slug":"Graphql","count":1,"path":"api/tags/Graphql.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}