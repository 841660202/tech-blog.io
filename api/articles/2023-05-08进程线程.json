{"title":"nodejs进程线程通信","uid":"1c1176847881d39523eab2c0cd2228ab","slug":"2023-05-08进程线程","date":"2023-05-08T02:42:06.000Z","updated":"2023-05-15T13:17:33.006Z","comments":true,"path":"api/articles/2023-05-08进程线程.json","keywords":null,"cover":null,"content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>进程间通信与线程间通信的区别 ?</li>\n<li>进程通信有哪些方式 ?</li>\n<li>线程通信有哪些方式 ?</li>\n<li>kafaka 不属于进程通信 ?</li>\n<li>Electron 为什么使用线程通信 ?</li>\n<li>HTTP 可以替代 RPC ?</li>\n<li>为什么出现 RPC ?</li>\n<li>多进程，多线程，与同步是否冲突 ?</li>\n</ol>\n<h1 id=\"Nodejs-进程之间如何通信\"><a href=\"#Nodejs-进程之间如何通信\" class=\"headerlink\" title=\"Nodejs 进程之间如何通信\"></a>Nodejs 进程之间如何通信</h1><p>在 Node.js 中，不同的进程之间可以通过以下几种方式进行通信：</p>\n<ol>\n<li><p><code>子进程</code>：可以使用 child_process 模块创建子进程，并通过标准输入输出流（stdin、stdout）进行通信。父进程可以向子进程发送消息，子进程可以从 stdin 读取消息，并将结果通过 stdout 返回给父进程。</p>\n</li>\n<li><p><code>IPC</code>：可以使用 Node.js 提供的 IPC（Inter-Process Communication）模块在不同的进程之间进行通信。IPC 模块提供了多种通信方式，例如命名管道、Socket、信号和共享内存等。</p>\n</li>\n<li><p><code>远程调用</code>：可以使用远程调用（RPC）框架在不同的进程之间进行通信。RPC 框架可以通过定义 IDL（接口定义语言）来描述接口和数据结构，从而实现进程之间的远程调用和数据传输。</p>\n</li>\n<li><p><code>消息队列</code>：可以使用消息队列在不同的进程之间进行异步通信。进程可以将消息发送到消息队列中，其他进程可以订阅该队列来接收消息。</p>\n</li>\n</ol>\n<p>需要注意的是，不同的进程之间通信需要考虑数据安全性和可靠性问题。需要对数据进行加密和签名，对请求进行身份验证和授权，定期备份和监控系统，以保证系统的稳定性和可靠性。</p>\n<h2 id=\"子进程\"><a href=\"#子进程\" class=\"headerlink\" title=\"子进程\"></a>子进程</h2><h3 id=\"利用标准输入输出进行通信\"><a href=\"#利用标准输入输出进行通信\" class=\"headerlink\" title=\"利用标准输入输出进行通信\"></a>利用标准输入输出进行通信</h3><p>非常抱歉，看来这个示例依赖的 MQ 库可能已经被删除了。我可以给你提供一个示例代码，使用 Node.js 的内置<code>child_process</code>模块创建一个子进程并在主进程和子进程之间通过标准输入输出通信。这个示例不需要任何额外的依赖库。请参考以下代码：</p>\n<p><strong>parent.js</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);\nconst child &#x3D; spawn(&#39;node&#39;, [&#39;child.js&#39;]);\n\nchild.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n  console.log(&#96;Received data from child: $&#123;data&#125;&#96;);\n&#125;);\n\nchild.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;\n  console.log(&#96;Child process exited with code $&#123;code&#125;&#96;);\n&#125;);\n\nchild.stdin.write(&#39;Hello from parent\\n&#39;);</code></pre>\n\n<p><strong>child.js</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">process.stdin.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n  console.log(&#96;Received data from parent: $&#123;data&#125;&#96;);\n  process.stdout.write(&#39;Hello from child\\n&#39;);\n&#125;);\n\nprocess.on(&#39;exit&#39;, () &#x3D;&gt; &#123;\n  console.log(&#39;Child process exited&#39;);\n&#125;);</code></pre>\n\n<p>在这个示例中，主进程（<code>parent.js</code>）创建了一个子进程（<code>child.js</code>），并向子进程写入一条消息。子进程接收到这个消息后，向主进程回复一条消息。主进程监听子进程的标准输出，并打印出子进程发送过来的消息。</p>\n<p>请注意，这个示例只是演示了如何在主进程和子进程之间进行通信。在实际应用中，您可能需要添加更多的代码来处理各种边界情况和错误处理。</p>\n<h3 id=\"stdout-stdin-为什么能够进行通信？\"><a href=\"#stdout-stdin-为什么能够进行通信？\" class=\"headerlink\" title=\"stdout stdin 为什么能够进行通信？\"></a>stdout stdin 为什么能够进行通信？</h3><p>在操作系统中，每个进程都有三个标准的输入&#x2F;输出文件描述符：</p>\n<ul>\n<li>stdin（标准输入）：默认指向键盘输入。</li>\n<li>stdout（标准输出）：默认指向终端输出。</li>\n<li>stderr（标准错误）：默认也指向终端输出。</li>\n</ul>\n<p>在进程间通信的过程中，子进程可以将标准输出重定向到管道中，而父进程则可以从管道中读取子进程输出的数据。这样就可以实现进程间通信了。</p>\n<p>在 Node.js 中，可以通过 child_process 模块创建子进程，并将子进程的标准输出重定向到父进程的标准输入上，实现父子进程间的通信。父进程可以使用子进程的 stdin 对象来发送数据，子进程可以使用 process.stdout 对象来发送数据。当然，也可以将子进程的标准输入重定向到管道中，父进程从管道中读取子进程的输出数据，从而实现进程间通信。</p>\n<h3 id=\"还是不懂\"><a href=\"#还是不懂\" class=\"headerlink\" title=\"还是不懂\"></a>还是不懂</h3><p>当你在控制台上输入命令并按下回车键时，该命令被发送到系统的标准输入（stdin）中。系统进程或应用程序可以通过读取标准输入来获取输入的命令。这样就可以实现控制台输入和进程通信了。</p>\n<p>同样地，进程也可以通过向标准输出（stdout）写入数据，将消息发送到控制台。控制台可以通过读取标准输出来获取进程发送的消息。这样就可以实现进程输出和控制台输出了。</p>\n<p>因此，在 Node.js 中，可以通过将进程的标准输入和标准输出与管道（pipe）相连来实现进程间通信。一个进程将数据写入其标准输出，并且另一个进程将其标准输入连接到另一端的管道中，就可以实现进程间通信了。</p>\n<h3 id=\"假设有多个进程，如何确定哪个读取哪个？\"><a href=\"#假设有多个进程，如何确定哪个读取哪个？\" class=\"headerlink\" title=\"假设有多个进程，如何确定哪个读取哪个？\"></a>假设有多个进程，如何确定哪个读取哪个？</h3><p>如果多个进程同时读取同一个管道，那么系统会将管道中的数据循环地分配给不同的进程进行读取，这样每个进程都有机会读取到管道中的数据。这种机制被称为轮询（Round-Robin）。</p>\n<p>轮询机制是一种公平的机制，保证了所有进程都有机会读取到管道中的数据。当然，如果某个进程需要更频繁地读取管道中的数据，可以增加该进程的调度次数，以此来提高该进程读取数据的机会。</p>\n<h2 id=\"IPC-机制\"><a href=\"#IPC-机制\" class=\"headerlink\" title=\"IPC 机制\"></a>IPC 机制</h2><h3 id=\"IPC-机制-是什么\"><a href=\"#IPC-机制-是什么\" class=\"headerlink\" title=\"IPC 机制 是什么\"></a>IPC 机制 是什么</h3><p>IPC（Inter-Process Communication，进程间通信）是指不同进程之间进行通信、交换数据的机制。</p>\n<p>在操作系统中，每个进程都拥有自己的地址空间和内存空间，不同进程之间无法直接访问对方的内存空间。因此，如果需要让不同进程之间进行数据交换或通信，就需要使用 IPC 机制。</p>\n<p>常见的 IPC 机制包括：</p>\n<ol>\n<li><p>管道（Pipe）：管道是一种半双工的通信方式，它创建一个管道文件用于进程间通信，一端用于写入数据，另一端用于读取数据。</p>\n</li>\n<li><p>命名管道（Named Pipe）：命名管道是一种特殊的管道，它允许不同进程之间进行通信，而且不需要进程有亲缘关系（即不需要父子进程关系）。</p>\n</li>\n<li><p>信号量（Semaphore）：信号量是一种计数器，用于控制多个进程对共享资源的访问。通过信号量，进程可以协调访问共享资源的顺序。</p>\n</li>\n<li><p>共享内存（Shared Memory）：共享内存是一种允许不同进程之间共享内存空间的机制。进程可以将同一个内存区域映射到自己的地址空间中，从而实现共享。</p>\n</li>\n<li><p>消息队列（Message Queue）：消息队列是一种用于在进程之间传递数据的机制。它允许进程向队列中写入数据，并从队列中读取数据。</p>\n</li>\n</ol>\n<p>在不同的应用场景中，可以根据需求选择合适的 IPC 机制进行进程间通信。在 Node.js 中，也提供了多种 IPC 机制，例如使用管道、TCP、UDP 等方式进行进程间通信。</p>\n<h3 id=\"electron-与-html-端通信是多进程还是多线程\"><a href=\"#electron-与-html-端通信是多进程还是多线程\" class=\"headerlink\" title=\"electron 与 html 端通信是多进程还是多线程\"></a>electron 与 html 端通信是多进程还是多线程</h3><p>Electron 与 HTML 端之间的通信是通过多进程实现的，具体来说，Electron 主进程和渲染进程分别运行在不同的进程中。</p>\n<p>Electron 主进程是 Node.js 进程，用于管理应用程序的整个生命周期，例如窗口管理、菜单管理、文件系统访问等。Electron 渲染进程则是基于 Chromium 的渲染进程，负责展示 HTML、CSS 和 JavaScript 内容。</p>\n<p>在 Electron 中，主进程与渲染进程之间的通信是通过 IPC（进程间通信）机制实现的。主进程和渲染进程之间可以互相发送消息，通过 <code>ipcMain</code> 和 <code>ipcRenderer</code> 模块进行监听和发送。</p>\n<p>在渲染进程中，我们可以使用 <code>ipcRenderer</code> 模块向主进程发送消息，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123; ipcRenderer &#125; &#x3D; require(&#39;electron&#39;);\n\nipcRenderer.send(&#39;message-from-renderer&#39;, &#123; data: &#39;hello from renderer&#39; &#125;);\n\nipcRenderer.on(&#39;message-from-main&#39;, (event, args) &#x3D;&gt; &#123;\n  console.log(args);\n&#125;);</code></pre>\n\n<p>在主进程中，我们可以使用 <code>ipcMain</code> 模块来监听渲染进程发送过来的消息，并通过 <code>event.sender.send()</code> 方法向渲染进程发送消息，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123; ipcMain &#125; &#x3D; require(&#39;electron&#39;);\n\nipcMain.on(&#39;message-from-renderer&#39;, (event, args) &#x3D;&gt; &#123;\n  console.log(args);\n  event.sender.send(&#39;message-from-main&#39;, &#123; data: &#39;hello from main&#39; &#125;);\n&#125;);</code></pre>\n\n<p>通过 IPC 机制，主进程和渲染进程可以互相发送消息并进行通信，从而实现了 Electron 应用程序的功能。需要注意的是，Electron 中的每个窗口都运行在自己的渲染进程中，因此在使用 Electron 开发应用程序时，需要考虑进程间通信的设计和优化。</p>\n<h2 id=\"nodejs-RPC-示例\"><a href=\"#nodejs-RPC-示例\" class=\"headerlink\" title=\"nodejs RPC 示例\"></a>nodejs RPC 示例</h2><p>RPC（Remote Procedure Call）远程过程调用是一种分布式计算的通信方式，可以使得不同的进程或者机器之间进行函数调用。Node.js 中可以通过一些 RPC 框架实现 RPC，例如 zerorpc、node-rpc 等。</p>\n<p>以下是一个基于 node-rpc 的简单示例：</p>\n<p>服务端代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const rpc &#x3D; require(&#39;node-remote-ipc&#39;).connectToServer(&#39;my-rpc&#39;);\n\nfunction add(a, b, callback) &#123;\n  callback(null, a + b);\n&#125;\n\nrpc.expose(&#39;add&#39;, add);</code></pre>\n\n<p>客户端代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const rpc &#x3D; require(&#39;node-remote-ipc&#39;).connectToServer(&#39;my-rpc&#39;);\n\nrpc.call(&#39;add&#39;, 2, 3, (err, result) &#x3D;&gt; &#123;\n  if (err) &#123;\n    console.error(err);\n  &#125; else &#123;\n    console.log(result); &#x2F;&#x2F; 输出 5\n  &#125;\n&#125;);</code></pre>\n\n<p>这里的服务端通过 rpc.expose 方法将 add 函数暴露给客户端调用，客户端通过 rpc.call 方法调用服务端的 add 函数，并在回调函数中获取执行结果。需要注意的是，这里使用的是 node-remote-ipc 模块进行 RPC 通信，其底层实现是基于 node.js 的进程间通信机制实现的。</p>\n<h3 id=\"RPC-与前后端请求类似\"><a href=\"#RPC-与前后端请求类似\" class=\"headerlink\" title=\"RPC 与前后端请求类似\"></a>RPC 与前后端请求类似</h3><p>是的，RPC 调用和前后端请求确实有些相似。在前后端请求中，客户端向服务器发送请求，服务器返回响应。类似地，在 RPC 中，客户端向远程服务器发送请求，远程服务器处理请求并返回响应。</p>\n<p>不同之处在于，RPC 是在进程或者机器之间进行通信的，而前后端请求则是在客户端和服务器之间进行通信的。此外，RPC 更加面向对象，它是对方法调用的封装，而前后端请求则更加面向资源。</p>\n<h3 id=\"RPC-与前后端请求的区别\"><a href=\"#RPC-与前后端请求的区别\" class=\"headerlink\" title=\"RPC 与前后端请求的区别\"></a>RPC 与前后端请求的区别</h3><p>RPC 和前后端请求确实有相似之处，但是它们的应用场景和实现方式有很大的区别。</p>\n<p>RPC（Remote Procedure Call）是一种进程间通信的技术，它允许客户端调用远程服务器上的某个服务或者方法，并且在客户端和服务器之间传输数据。RPC 的目的是让调用远程方法像调用本地方法一样简单。RPC 通常被用于分布式系统中，用于实现不同进程或者不同机器之间的方法调用和数据交换。</p>\n<p>而前后端请求则是指前端（如浏览器）向后端（如服务器）发起的请求，用于获取数据或执行某些操作。前后端请求通常采用 HTTP 协议进行通信，并且遵循 RESTful 设计原则。前后端请求通常用于 Web 应用程序中，用于实现客户端与服务器之间的数据交换和业务逻辑处理。</p>\n<p>总体来说，RPC 和前后端请求的区别在于应用场景和实现方式。RPC 主要用于分布式系统中不同进程或者不同机器之间的方法调用和数据交换，而前后端请求主要用于 Web 应用程序中客户端与服务器之间的数据交换和业务逻辑处理。</p>\n<h3 id=\"用-HTTP-通信替代-RPC-可以吗\"><a href=\"#用-HTTP-通信替代-RPC-可以吗\" class=\"headerlink\" title=\"用 HTTP 通信替代 RPC 可以吗\"></a>用 HTTP 通信替代 RPC 可以吗</h3><p><code>可以</code>，HTTP 通信可以用于替代 RPC 通信。事实上，一些 Web API 使用 HTTP 作为其通信协议，如 RESTful API。</p>\n<p>使用 HTTP 代替 RPC 通信具有一些优点和缺点。优点包括：</p>\n<ol>\n<li><p>HTTP 协议已经广泛使用，因此有很多现成的工具和库可以使用。</p>\n</li>\n<li><p>HTTP 协议通常在防火墙中允许通过，因此可以更轻松地在不同的网络环境中使用。</p>\n</li>\n<li><p>使用 HTTP 协议可以使用 Web 服务器处理请求，从而将负载分散到多个服务器上。</p>\n</li>\n</ol>\n<p>缺点包括：</p>\n<ol>\n<li><p>HTTP 协议本质上是请求&#x2F;响应模式，需要在每个请求和响应之间建立新的连接，而 RPC 通信可以更快地建立长时间连接并传输多个请求和响应。</p>\n</li>\n<li><p>使用 HTTP 协议时，必须处理各种 HTTP 状态码和请求头，这可能会导致一些额外的开销。</p>\n</li>\n<li><p>HTTP 协议不支持直接序列化和反序列化复杂对象，因此需要使用额外的库来实现这些功能。</p>\n</li>\n</ol>\n<h2 id=\"nodejs-消息队列实现进程间通信\"><a href=\"#nodejs-消息队列实现进程间通信\" class=\"headerlink\" title=\"nodejs 消息队列实现进程间通信\"></a>nodejs 消息队列实现进程间通信</h2><p>Node.js 中的消息队列机制可以用来实现进程间通信。它的基本原理是通过在进程间传递消息，来实现数据的共享和通信。Node.js 中有多个实现消息队列的库，其中较为常见的包括：</p>\n<ul>\n<li>node-ipc：一款基于 Unix 消息队列的 IPC 库。</li>\n<li>nanomsg：一个高性能、异步的消息队列库，支持多种通信模式和传输协议。</li>\n<li>zmq：又称 ZeroMQ，是一个高性能、异步的消息队列库，支持多种通信模式和传输协议。</li>\n</ul>\n<p>使用这些库可以非常方便地实现进程间通信。下面是一个使用 node-ipc 实现进程间通信的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 父进程\nconst ipc &#x3D; require(&#39;node-ipc&#39;);\n\nipc.config.id &#x3D; &#39;parent&#39;;\nipc.config.retry &#x3D; 1500;\nipc.config.silent &#x3D; true;\n\nipc.serve(() &#x3D;&gt; &#123;\n  ipc.server.on(&#39;message&#39;, (data, socket) &#x3D;&gt; &#123;\n    console.log(&#39;Parent received message: &#39;, data);\n    ipc.server.emit(socket, &#39;reply&#39;, &#39;Message received by parent&#39;);\n  &#125;);\n&#125;);\n\nipc.server.start();\n\n&#x2F;&#x2F; 子进程\nconst child &#x3D; require(&#39;child_process&#39;);\n\nconst childProcess &#x3D; child.fork(&#39;.&#x2F;child.js&#39;);\n\nchildProcess.on(&#39;message&#39;, (data) &#x3D;&gt; &#123;\n  console.log(&#39;Parent received message from child: &#39;, data);\n&#125;);\n\nsetInterval(() &#x3D;&gt; &#123;\n  childProcess.send(&#39;Ping from parent&#39;);\n&#125;, 3000);</code></pre>\n\n<p>上述代码创建了一个父进程和一个子进程，它们之间通过 node-ipc 实现消息的收发。父进程启动一个 IPC 服务器，监听子进程发来的消息，子进程通过<code>child_process</code>模块的<code>fork()</code>方法创建，然后发送<code>Ping from parent</code>消息到父进程。父进程在收到子进程的消息后会打印输出，并回复一个消息给子进程，子进程也会在收到父进程的回复后打印输出。</p>\n<h3 id=\"node-ipc-消息队列通信与-ipc-通信的区别？\"><a href=\"#node-ipc-消息队列通信与-ipc-通信的区别？\" class=\"headerlink\" title=\"node-ipc 消息队列通信与 ipc 通信的区别？\"></a>node-ipc 消息队列通信与 ipc 通信的区别？</h3><p>node-ipc 是一个 Node.js 库，用于在进程间进行异步通信和传输数据。它可以在本地进程之间，也可以在不同主机之间传输消息。它提供了一组简单的 API，使得编写进程间通信应用变得更加容易。</p>\n<p>与 IPC（Inter-Process Communication，进程间通信）相比，node-ipc 的特点在于它基于消息队列实现，而 IPC 可以使用多种不同的通信方式（例如管道、信号量、共享内存等）。</p>\n<p>使用 node-ipc 可以方便地实现进程间通信，通过消息队列来传递数据，而无需手动处理复杂的底层通信细节。同时，它支持多种消息传输格式（例如 JSON、Buffer、字符串等），可以根据应用程序的需要选择合适的格式进行消息传递。</p>\n<h3 id=\"node-ipc、-nanomsg、zmq-比较\"><a href=\"#node-ipc、-nanomsg、zmq-比较\" class=\"headerlink\" title=\"node-ipc、 nanomsg、zmq 比较\"></a>node-ipc、 nanomsg、zmq 比较</h3><p>node-ipc、nanomsg 和 zmq 都是可用于实现进程间通信的库，它们各自有不同的特点和适用场景。</p>\n<ol>\n<li><p>node-ipc：这是一个专为 Node.js 设计的库，提供了易于使用的 API，可以使用不同的传输方式（如 UNIX 域套接字、TCP、UDP 等）实现进程间通信。它的设计重点是易用性和可靠性，因此适用于小型应用程序和通信需求不高的场景。</p>\n</li>\n<li><p>nanomsg：这是一个跨平台的轻量级消息传递库，支持不同的通信模式（如 pub-sub、pair 等），可以使用不同的传输方式（如 IPC、TCP、inproc 等）实现进程间通信。它的设计重点是高性能和灵活性，适用于大型应用程序和对通信效率有要求的场景。</p>\n</li>\n<li><p>zmq：这是一个高性能的、可扩展的消息传递库，支持不同的通信模式（如 pub-sub、req-rep 等），可以使用不同的传输方式（如 TCP、IPC、inproc 等）实现进程间通信。它的设计重点是可扩展性和高性能，适用于大型分布式系统和对通信效率有高要求的场景。</p>\n</li>\n</ol>\n<p>因此，在选择这些库时，需要根据实际情况选择适合的库，例如，如果应用程序需要在 Node.js 中实现进程间通信，node-ipc 可能是更好的选择；如果应用程序需要高性能和灵活性，nanomsg 或 zmq 可能更适合。</p>\n<h2 id=\"kafaka-属于进程间通信？\"><a href=\"#kafaka-属于进程间通信？\" class=\"headerlink\" title=\"kafaka 属于进程间通信？\"></a>kafaka 属于进程间通信？</h2><p>Kafka 是一种分布式的消息队列系统，主要用于异步通信和处理大规模数据流。它不属于进程间通信，而是一种基于发布-订阅模式的消息传递系统，可以实现不同进程、不同系统之间的消息传递和数据共享。Kafka 使用了一些高级的分布式技术，例如分区、副本、消费者组等，保证了高吞吐量、高可靠性、高扩展性等特点。</p>\n<h1 id=\"进程间通信与线程间通信的区别\"><a href=\"#进程间通信与线程间通信的区别\" class=\"headerlink\" title=\"进程间通信与线程间通信的区别\"></a>进程间通信与线程间通信的区别</h1><p>进程间通信和线程间通信都是实现多任务并发执行的方式，但是它们有以下几点区别：</p>\n<ol>\n<li><p>资源共享：进程间通信需要借助操作系统提供的 IPC 机制进行通信，资源共享相对困难。而线程间通信可以直接访问进程内的共享数据。</p>\n</li>\n<li><p>效率：进程间通信效率相对较低，因为需要进行系统调用。而线程间通信效率较高，因为不需要跨进程调用。</p>\n</li>\n<li><p>安全性：由于进程间的内存空间相互独立，进程间通信相对安全。而线程间通信需要注意同步和互斥，否则会引起竞态条件等问题。</p>\n</li>\n<li><p>可扩展性：进程间通信可以在不同的机器上进行通信，因此具有很好的可扩展性。而线程间通信通常限于同一台机器上的进程内部。</p>\n</li>\n</ol>\n<p>因此，进程间通信和线程间通信各有优缺点，选择合适的通信方式取决于具体应用场景。</p>\n<h1 id=\"什么时候用线程通信，什么时候用进程通信\"><a href=\"#什么时候用线程通信，什么时候用进程通信\" class=\"headerlink\" title=\"什么时候用线程通信，什么时候用进程通信\"></a>什么时候用线程通信，什么时候用进程通信</h1><p>在并发编程中，选择使用线程通信或进程通信主要取决于应用程序的特定需求和设计。以下是一些通用的指导原则：</p>\n<p>使用线程通信：</p>\n<ul>\n<li>当需要共享相同的内存空间时，例如，多个线程需要访问相同的数据结构。</li>\n<li>当需要高效地共享数据时，线程通信比进程通信更快。</li>\n<li>当应用程序需要在同一台机器上的不同部分之间进行通信时，例如，单个应用程序中的多个模块之间的通信。</li>\n</ul>\n<p>使用进程通信：</p>\n<ul>\n<li>当应用程序需要在不同的计算机上进行通信时，例如，分布式应用程序。</li>\n<li>当需要独立控制不同的进程时，例如，运行在一个沙箱中的应用程序。</li>\n<li>当进程需要使用不同的资源时，例如，一个进程需要访问数据库，另一个进程需要访问文件系统。</li>\n</ul>\n<p>需要注意的是，线程通信和进程通信各有优缺点，具体情况需要根据应用程序的需求进行选择。</p>\n<h1 id=\"electron-为什么不用线程通信的方式\"><a href=\"#electron-为什么不用线程通信的方式\" class=\"headerlink\" title=\"electron 为什么不用线程通信的方式\"></a>electron 为什么不用线程通信的方式</h1><p>Electron 主要是使用 Chromium 和 Node.js 来构建跨平台的桌面应用程序，其中 Chromium 是基于多进程的架构来实现的。每个 Chromium 页面都在自己的进程中运行，称为“渲染进程”，而 Electron 应用程序本身也有自己的进程，称为“主进程”。因此，在 Electron 应用程序中使用进程间通信是一种更自然的选择。</p>\n<p>此外，<strong>线程间通信需要考虑同步和锁等问题，容易导致死锁和性能问题</strong>，而进程间通信则避免了这些问题。<br>同时，<strong>使用多进程可以利用多核处理器的优势，更好地提高应用程序的性能</strong>。<br>因此，使用进程间通信是 Electron 应用程序的一种比较合适的选择。</p>\n<h1 id=\"线程通信方式有哪些\"><a href=\"#线程通信方式有哪些\" class=\"headerlink\" title=\"线程通信方式有哪些\"></a>线程通信方式有哪些</h1><p>见的线程通信方式有<code>共享内存</code>、<code>消息传递</code>、<code>信号量</code>、<code>互斥量</code>和<code>条件变量</code>等。</p>\n<ol>\n<li>其中共享内存是最快速的通信方式，但需要自行解决同步和互斥问题；</li>\n<li>消息传递可以采用同步或异步方式，不需要考虑同步问题，但传输数据需要进行序列化和反序列化。</li>\n<li>信号量、互斥量和条件变量则主要用于解决同步和互斥问题</li>\n</ol>\n<h2 id=\"nodejs-共享内存-线程通信-SharedArrayBuffer-和-Atomics\"><a href=\"#nodejs-共享内存-线程通信-SharedArrayBuffer-和-Atomics\" class=\"headerlink\" title=\"nodejs 共享内存 线程通信 SharedArrayBuffer 和 Atomics\"></a>nodejs 共享内存 线程通信 SharedArrayBuffer 和 Atomics</h2><p>Node.js 的线程是通过 Worker 模块来实现的，Worker 线程之间的通信可以使用共享内存来实现。具体来说，Node.js 提供了 SharedArrayBuffer 和 Atomics API 来支持多个线程之间的共享内存访问。</p>\n<p>SharedArrayBuffer 是一个特殊的 ArrayBuffer，它允许多个线程共享同一段内存空间。可以使用 new SharedArrayBuffer() 创建一个 SharedArrayBuffer 对象，然后使用 Worker 线程的 postMessage() 方法将这个对象发送给其他线程。</p>\n<p>Atomics API 是用来操作 SharedArrayBuffer 的 API。它提供了原子操作，可以确保多个线程在访问共享内存时不会互相干扰。可以使用 Atomics.load()、Atomics.store()、Atomics.add()、Atomics.sub()、Atomics.and()、Atomics.or()、Atomics.xor()、Atomics.exchange()、Atomics.compareExchange() 等方法来对共享内存中的数据进行操作。</p>\n<p>下面是一个使用共享内存进行线程通信的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; worker.js\nconst &#123; parentPort, workerData, threadId &#125; &#x3D; require(&#39;worker_threads&#39;);\nconst &#123; SharedArrayBuffer, Atomics &#125; &#x3D; require(&#39;worker_threads&#39;);\n\n&#x2F;&#x2F; 接收主线程传来的共享内存\nconst sharedBuffer &#x3D; workerData.sharedBuffer;\n\n&#x2F;&#x2F; 从共享内存中读取数据\nconst data &#x3D; new Int32Array(sharedBuffer);\n\nconsole.log(&#96;worker $&#123;threadId&#125; got data: $&#123;data[0]&#125;, $&#123;data[1]&#125;&#96;);\n\n&#x2F;&#x2F; 修改共享内存中的数据\nAtomics.add(data, 0, 1);\nAtomics.sub(data, 1, 1);\n\n&#x2F;&#x2F; 将修改后的共享内存发送回主线程\nparentPort.postMessage(sharedBuffer);</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; main.js\nconst &#123; Worker, isMainThread &#125; &#x3D; require(&#39;worker_threads&#39;);\nconst &#123; SharedArrayBuffer &#125; &#x3D; require(&#39;worker_threads&#39;);\n\nif (isMainThread) &#123;\n  const sharedBuffer &#x3D; new SharedArrayBuffer(8);\n\n  &#x2F;&#x2F; 在主线程中写入数据到共享内存\n  const data &#x3D; new Int32Array(sharedBuffer);\n  data[0] &#x3D; 1;\n  data[1] &#x3D; 2;\n\n  console.log(&#96;main thread send data: $&#123;data[0]&#125;, $&#123;data[1]&#125;&#96;);\n\n  &#x2F;&#x2F; 创建 Worker 线程，并将共享内存传递给它\n  const worker &#x3D; new Worker(__filename, &#123;\n    workerData: &#123;\n      sharedBuffer: sharedBuffer,\n    &#125;,\n  &#125;);\n\n  &#x2F;&#x2F; 接收 Worker 线程发送回来的共享内存，并打印出来\n  worker.on(&#39;message&#39;, (sharedBuffer) &#x3D;&gt; &#123;\n    const data &#x3D; new Int32Array(sharedBuffer);\n    console.log(&#96;main thread receive data: $&#123;data[0]&#125;, $&#123;data[1]&#125;&#96;);\n  &#125;);\n&#125; else &#123;\n  require(&#39;.&#x2F;worker.js&#39;);\n&#125;</code></pre>\n\n<p>这个示例中，主线程创建了一个 SharedArrayBuffer，并将其中的数据写入到共享内存中。然后，它创建了一个 Worker 线程，并将共享内存传递给它。Worker 线程接收到共享内存后，从中读取出数据并打印出来，然后修改了其中的</p>\n<h2 id=\"nodejs-消息传递方式进行线程通信-parentPort\"><a href=\"#nodejs-消息传递方式进行线程通信-parentPort\" class=\"headerlink\" title=\"nodejs 消息传递方式进行线程通信 parentPort\"></a>nodejs 消息传递方式进行线程通信 parentPort</h2><p>在 Node.js 中，可以使用消息传递方式进行线程通信。这种方式下，每个线程都拥有自己的消息队列，线程之间可以通过消息队列进行通信。</p>\n<p>具体而言，可以使用 <code>worker_threads</code> 模块创建新的线程，然后通过 <code>worker.postMessage()</code> 方法向线程发送消息。在接收线程中，可以监听 <code>message</code> 事件来处理从主线程发送过来的消息。</p>\n<p>以下是一个简单的示例，展示了如何在 Node.js 中使用消息传递方式进行线程通信：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; main.js\nconst &#123; Worker &#125; &#x3D; require(&#39;worker_threads&#39;);\n\n&#x2F;&#x2F; 创建新的线程\nconst worker &#x3D; new Worker(&#39;.&#x2F;worker.js&#39;);\n\n&#x2F;&#x2F; 监听 worker 线程的消息\nworker.on(&#39;message&#39;, (message) &#x3D;&gt; &#123;\n  console.log(&#96;Received message from worker: $&#123;message&#125;&#96;);\n&#125;);\n\n&#x2F;&#x2F; 向 worker 线程发送消息\nworker.postMessage(&#39;Hello from main thread!&#39;);\n\n&#x2F;&#x2F; worker.js\nconst &#123; parentPort &#125; &#x3D; require(&#39;worker_threads&#39;);\n\n&#x2F;&#x2F; 监听主线程的消息\nparentPort.on(&#39;message&#39;, (message) &#x3D;&gt; &#123;\n  console.log(&#96;Received message from main thread: $&#123;message&#125;&#96;);\n&#125;);\n\n&#x2F;&#x2F; 向主线程发送消息\nparentPort.postMessage(&#39;Hello from worker thread!&#39;);</code></pre>\n\n<p>在这个示例中，主线程通过 <code>worker.postMessage()</code> 方法向工作线程发送消息，并监听工作线程发送的消息。工作线程也监听主线程发送的消息，并通过 <code>parentPort.postMessage()</code> 方法向主线程发送消息。</p>\n<p>需要注意的是，消息传递方式不同于共享内存和同步机制，因此需要使用序列化和反序列化来传递数据。在示例中，消息被自动序列化为字符串，然后在另一个线程中反序列化。因此，在使用消息传递方式进行线程通信时，需要注意数据类型的处理。</p>\n<h2 id=\"nodejs-条件变量-方式进行线程通信-SharedArrayBuffer-Atomics\"><a href=\"#nodejs-条件变量-方式进行线程通信-SharedArrayBuffer-Atomics\" class=\"headerlink\" title=\"nodejs 条件变量 方式进行线程通信 SharedArrayBuffer, Atomics\"></a>nodejs 条件变量 方式进行线程通信 SharedArrayBuffer, Atomics</h2><p>在 Node.js 中，线程通信可以通过条件变量实现。条件变量是一种同步机制，用于在线程之间通信和协调。它允许一个或多个线程在满足某些条件之前等待，当条件满足时通知等待线程。</p>\n<p>Node.js 中条件变量通过 <code>worker_threads</code> 模块的 <code>Atomics</code> 和 <code>SharedArrayBuffer</code> API 来实现。<code>Atomics.wait()</code> 方法可以让线程等待在一个共享内存的地址上，直到其他线程在该地址上进行通知。</p>\n<p>下面是一个示例，展示了如何使用条件变量实现线程间通信。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123; Worker, isMainThread, workerData, threadId, parentPort &#125; &#x3D; require(&#39;worker_threads&#39;);\nconst &#123; SharedArrayBuffer, Atomics &#125; &#x3D; require(&#39;worker_threads&#39;);\n\nif (isMainThread) &#123;\n  const sab &#x3D; new SharedArrayBuffer(4);\n  const ia &#x3D; new Int32Array(sab);\n  const worker &#x3D; new Worker(__filename, &#123;\n    workerData: sab,\n  &#125;);\n  Atomics.store(ia, 0, 0);\n  setInterval(() &#x3D;&gt; &#123;\n    Atomics.add(ia, 0, 1);\n    console.log(&#96;Main thread incremented value to $&#123;ia[0]&#125;&#96;);\n  &#125;, 1000);\n  worker.on(&#39;message&#39;, (msg) &#x3D;&gt; &#123;\n    console.log(&#96;Main thread received message: $&#123;msg&#125;&#96;);\n  &#125;);\n&#125; else &#123;\n  const sab &#x3D; workerData;\n  const ia &#x3D; new Int32Array(sab);\n  const cv &#x3D; new Int32Array(sab, 4, 1);\n  setInterval(() &#x3D;&gt; &#123;\n    if (Atomics.load(ia, 0) &#x3D;&#x3D;&#x3D; 5) &#123;\n      Atomics.store(cv, 0, 1);\n      parentPort.postMessage(&#39;Notified main thread&#39;);\n    &#125;\n  &#125;, 1000);\n  Atomics.store(cv, 0, 0);\n  while (Atomics.load(cv, 0) &#x3D;&#x3D;&#x3D; 0) &#123;\n    Atomics.wait(cv, 0);\n  &#125;\n&#125;</code></pre>\n\n<p>这个例子中，主线程和工作线程共享了一个 4 字节的内存块，并且主线程每秒钟增加一次该值。工作线程在一个循环中等待，直到主线程将该值增加到 5，然后使用条件变量通知主线程。主线程在接收到通知后，输出一个消息。</p>\n<h2 id=\"条件变量方式与共享内存方式看上去一样？\"><a href=\"#条件变量方式与共享内存方式看上去一样？\" class=\"headerlink\" title=\"条件变量方式与共享内存方式看上去一样？\"></a>条件变量方式与共享内存方式看上去一样？</h2><p>条件变量和共享内存是两种不同的线程通信方式，它们的<strong>实现机制和使用方法有很大的不同</strong>。</p>\n<p>条件变量是线程同步机制的一种，用于线程之间的通信。在使用条件变量时，一般是先加锁，然后等待某个条件变量被满足，如果条件不满足，则释放锁并等待，直到条件被满足后再重新加锁。在等待过程中，线程是阻塞的，不占用 CPU 资源。条件变量常常和互斥锁一起使用，实现线程同步和互斥。</p>\n<p>共享内存是另一种线程通信方式，它可以使多个线程访问同一块物理内存，实现数据共享。多个线程可以在内存中读取和修改同一个变量，这种方式比较高效，但也需要注意多线程访问时的并发控制，避免数据的竞争和冲突。</p>\n<p>因此，条件变量和共享内存虽然都可以实现线程间通信，但是它们的实现机制和应用场景是不同的，需要根据具体的需求选择合适的方式。</p>\n<h2 id=\"条件变量方式与共享内存-都是通过-SharedArrayBuffer-Atomics-实现的\"><a href=\"#条件变量方式与共享内存-都是通过-SharedArrayBuffer-Atomics-实现的\" class=\"headerlink\" title=\"条件变量方式与共享内存 都是通过 SharedArrayBuffer, Atomics 实现的\"></a>条件变量方式与共享内存 都是通过 SharedArrayBuffer, Atomics 实现的</h2><p>尽管条件变量和共享内存都可以使用 SharedArrayBuffer 和 Atomics 来实现，<strong>但它们的使用场景和原理是不同的</strong>。</p>\n<ul>\n<li>条件变量主要用于实现线程同步和通信，</li>\n<li>共享内存主要用于实现数据共享和同步。</li>\n</ul>\n<h2 id=\"多进程，多线程，与同步是否冲突\"><a href=\"#多进程，多线程，与同步是否冲突\" class=\"headerlink\" title=\"多进程，多线程，与同步是否冲突\"></a>多进程，多线程，与同步是否冲突</h2><p>多进程、多线程和同步并不一定冲突。在并发编程中，进程和线程可以通过同步机制来实现协作和同步。同步机制可以保证在多个线程或进程中对共享资源的访问是有序的和互斥的，从而避免了竞态条件和数据不一致等问题。</p>\n<p>在实际应用中，根据需求和特点可以选择不同的并发模型和同步机制。例如，</p>\n<ul>\n<li><code>多线程</code>适用于需要高并发、多计算任务和数据共享的场景；</li>\n<li><code>多进程</code>适用于需要高可用性和稳定性、有多个独立的工作任务或需要利用多核 CPU 的场景；</li>\n<li><code>同步机制</code>则可以通过锁、条件变量、信号量等来实现。</li>\n</ul>\n<p>虽然同步机制可以提高并发编程的安全性和正确性，但过多的同步机制也会降低程序的性能和并发度。因此，在实际应用中需要根据具体情况选择适当的并发模型和同步机制，以达到合适的并发度和性能。</p>\n<h1 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h1><h2 id=\"nodejs-与-java-性能比较\"><a href=\"#nodejs-与-java-性能比较\" class=\"headerlink\" title=\"nodejs 与 java 性能比较\"></a>nodejs 与 java 性能比较</h2><p>Node.js 和 Java 都是非常流行的后端开发语言，它们都有自己的优势和特点。</p>\n<p>一方面，Node.js 是基于 V8 引擎的 JavaScript 运行时，其主要优势在于对 I&#x2F;O 密集型应用的处理能力非常出色，能够处理大量并发的 I&#x2F;O 操作，例如处理大量的 HTTP 请求、WebSocket 连接等。由于其单线程的特性，Node.js 也具有很好的响应能力和低延迟的优势。</p>\n<p>另一方面，Java 是一种编译型语言，其主要优势在于其强大的性能和多线程能力。Java 能够在多核 CPU 上运行，利用多线程技术来提高并发处理能力。Java 还具有非常丰富的库和框架，支持构建大型、复杂的分布式系统和企业应用。</p>\n<p>因此，Node.js 和 Java 在性能和应用场景方面存在一定的差异。对于 I&#x2F;O 密集型应用，Node.js 是非常适合的选择，而对于计算密集型应用，Java 通常会表现得更出色。同时，对于复杂的分布式系统和企业应用，Java 通常会是更好的选择，因为它有更好的支持和成熟的技术栈。</p>\n<p>需要注意的是，性能并不是唯一的选择标准，还需要考虑开发成本、维护成本、生态和人才等方面的因素。在实际选择时，需要根据具体的应用场景和需求进行权衡。</p>\n<h2 id=\"nodejs-也可以多线程啊\"><a href=\"#nodejs-也可以多线程啊\" class=\"headerlink\" title=\"nodejs 也可以多线程啊\"></a>nodejs 也可以多线程啊</h2><p>是的，Node.js 支持多线程，但是需要使用 <code>worker_threads</code> 模块来实现多线程。使用 <code>worker_threads</code> 可以在 Node.js 中创建和管理多个线程，从而提高 CPU 密集型应用程序的性能。但是需要注意，Node.js 的单线程模型是为了避免锁等并发问题，使用多线程需要开发者自己保证线程安全，同时多线程的实现也比较复杂，需要注意线程间通信和数据同步等问题。</p>\n<h2 id=\"nodejs-多线程和-java-多线程哪个性能更高\"><a href=\"#nodejs-多线程和-java-多线程哪个性能更高\" class=\"headerlink\" title=\"nodejs 多线程和 java 多线程哪个性能更高\"></a>nodejs 多线程和 java 多线程哪个性能更高</h2><p>这个问题不好简单回答。性能取决于很多因素，如应用程序的特定需求，操作系统的类型和版本，硬件配置，代码实现等等。同时，多线程编程的性能比单线程编程更为复杂，因为需要考虑线程同步、锁定、上下文切换等问题，这些都可能影响应用程序的性能。</p>\n<p>在一些特定的场景下，Node.js 的多线程实现和 Java 的多线程实现可能会有不同的表现。例如，当涉及到大量计算密集型操作时，Java 的多线程实现可能会更快，因为 Java 中的线程是真正的操作系统线程，<strong>而 Node.js 中的线程则是通过 JavaScript 运行时模拟的线程</strong>。然而，对于一些 IO 密集型的应用程序，Node.js 的异步 I&#x2F;O 模型和事件驱动的架构可以提供更高的性能。</p>\n<p>综上所述，没有哪种编程语言或多线程实现是绝对更快的，性能取决于应用程序的需求和实现。</p>\n<h2 id=\"Node-js-中的线程则是通过-JavaScript-运行时模拟的线程？\"><a href=\"#Node-js-中的线程则是通过-JavaScript-运行时模拟的线程？\" class=\"headerlink\" title=\"Node.js 中的线程则是通过 JavaScript 运行时模拟的线程？\"></a>Node.js 中的线程则是通过 JavaScript 运行时模拟的线程？</h2><p>在 Node.js 中，线程是由 libuv 库来实现的，这个库是一个跨平台的异步 I&#x2F;O 库，它将操作系统提供的线程、线程池、事件机制等底层机制进行封装和抽象，向上层应用程序提供了一个高效的异步 I&#x2F;O 框架。Node.js 中的线程是由 libuv 库来管理和调度的，JavaScript 运行时并不直接控制线程的创建和销毁。所以，可以说 Node.js 中的线程是通过 libuv 库来实现的。</p>\n<h2 id=\"libuv-不是真正的操作系统线程？\"><a href=\"#libuv-不是真正的操作系统线程？\" class=\"headerlink\" title=\"libuv 不是真正的操作系统线程？\"></a>libuv 不是真正的操作系统线程？</h2><p>是的，<code>libuv</code> 并不是真正的操作系统线程。<code>libuv</code> 实现了一种称为“线程池”的技术，可以在一个或多个操作系统线程中调度多个 JavaScript 线程。这种线程池的实现方式类似于 Java 中的线程池，线程的创建和销毁由线程池管理，从而避免了频繁的创建和销毁线程的开销，提高了应用程序的性能。</p>\n<p>在 <code>libuv</code> 的实现中，每个 JavaScript 线程都对应一个事件循环，事件循环是单线程运行的，但是它通过底层的线程池机制实现了对多个 JavaScript 线程的调度和管理。这种实现方式在保证高性能的同时，也能够充分发挥 JavaScript 单线程的优势，使得编写高性能、高并发的 Node.js 应用程序变得更加容易。</p>\n<h2 id=\"在处理-大量计算密集型操作时，golang-和-java-哪个性能更高\"><a href=\"#在处理-大量计算密集型操作时，golang-和-java-哪个性能更高\" class=\"headerlink\" title=\"在处理 大量计算密集型操作时，golang 和 java 哪个性能更高\"></a>在处理 大量计算密集型操作时，golang 和 java 哪个性能更高</h2><p>通常情况下，处理大量计算密集型操作时，Java 和 Golang 都可以提供高性能的解决方案。</p>\n<p>Java 可以通过 JIT 编译器优化代码性能，还有一些开源库提供了高效的并发编程支持。在 Java 8 中引入的 lambda 表达式和函数式编程特性也使得并发编程更加便捷。</p>\n<p>Golang 则是一门专为高并发而生的编程语言，具有轻量级的协程和通道，可以非常方便地进行并发编程。此外，Golang 的垃圾回收机制、并发模型和内存管理等方面的设计也有助于提高性能。</p>\n<p>因此，选择 Java 还是 Golang 取决于具体的应用场景和需求。如果应用需要在大量的并发请求下保持高性能，Golang 可能更适合；如果应用需要使用大量的第三方库和复杂的企业级解决方案，Java 可能更合适。</p>\n","text":"问题 进程间通信与线程间通信的区别 ? 进程通信有哪些方式 ? 线程通信有哪些方式 ? kafaka 不属于进程通信 ? Electron 为什么使用线程通信 ? HTTP 可以替代 RPC ? 为什么出现 RPC ? 多进程，多线程，与同步是否冲突 ? Nodejs 进程之间如...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/categories/nodejs.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Nodejs-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">Nodejs 进程之间如何通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%90%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">子进程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">利用标准输入输出进行通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#stdout-stdin-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9F\"><span class=\"toc-text\">stdout stdin 为什么能够进行通信？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%98%E6%98%AF%E4%B8%8D%E6%87%82\"><span class=\"toc-text\">还是不懂</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%87%E8%AE%BE%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%93%AA%E4%B8%AA%E8%AF%BB%E5%8F%96%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">假设有多个进程，如何确定哪个读取哪个？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IPC-%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">IPC 机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IPC-%E6%9C%BA%E5%88%B6-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">IPC 机制 是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#electron-%E4%B8%8E-html-%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">electron 与 html 端通信是多进程还是多线程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-RPC-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">nodejs RPC 示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RPC-%E4%B8%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%B1%BB%E4%BC%BC\"><span class=\"toc-text\">RPC 与前后端请求类似</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RPC-%E4%B8%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">RPC 与前后端请求的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8-HTTP-%E9%80%9A%E4%BF%A1%E6%9B%BF%E4%BB%A3-RPC-%E5%8F%AF%E4%BB%A5%E5%90%97\"><span class=\"toc-text\">用 HTTP 通信替代 RPC 可以吗</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">nodejs 消息队列实现进程间通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#node-ipc-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%9A%E4%BF%A1%E4%B8%8E-ipc-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">node-ipc 消息队列通信与 ipc 通信的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#node-ipc%E3%80%81-nanomsg%E3%80%81zmq-%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">node-ipc、 nanomsg、zmq 比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#kafaka-%E5%B1%9E%E4%BA%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F\"><span class=\"toc-text\">kafaka 属于进程间通信？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">进程间通信与线程间通信的区别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">什么时候用线程通信，什么时候用进程通信</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#electron-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">electron 为什么不用线程通信的方式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">线程通信方式有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-SharedArrayBuffer-%E5%92%8C-Atomics\"><span class=\"toc-text\">nodejs 共享内存 线程通信 SharedArrayBuffer 和 Atomics</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-parentPort\"><span class=\"toc-text\">nodejs 消息传递方式进行线程通信 parentPort</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-SharedArrayBuffer-Atomics\"><span class=\"toc-text\">nodejs 条件变量 方式进行线程通信 SharedArrayBuffer, Atomics</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9C%8B%E4%B8%8A%E5%8E%BB%E4%B8%80%E6%A0%B7%EF%BC%9F\"><span class=\"toc-text\">条件变量方式与共享内存方式看上去一样？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-%E9%83%BD%E6%98%AF%E9%80%9A%E8%BF%87-SharedArrayBuffer-Atomics-%E5%AE%9E%E7%8E%B0%E7%9A%84\"><span class=\"toc-text\">条件变量方式与共享内存 都是通过 SharedArrayBuffer, Atomics 实现的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%98%AF%E5%90%A6%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">多进程，多线程，与同步是否冲突</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">性能比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E4%B8%8E-java-%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">nodejs 与 java 性能比较</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%95%8A\"><span class=\"toc-text\">nodejs 也可以多线程啊</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9B%B4%E9%AB%98\"><span class=\"toc-text\">nodejs 多线程和 java 多线程哪个性能更高</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Node-js-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%99%E6%98%AF%E9%80%9A%E8%BF%87-JavaScript-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A8%A1%E6%8B%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">Node.js 中的线程则是通过 JavaScript 运行时模拟的线程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#libuv-%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">libuv 不是真正的操作系统线程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%A4%84%E7%90%86-%E5%A4%A7%E9%87%8F%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8Cgolang-%E5%92%8C-java-%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9B%B4%E9%AB%98\"><span class=\"toc-text\">在处理 大量计算密集型操作时，golang 和 java 哪个性能更高</span></a></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"虚拟列表（没想好怎么写）","uid":"7c8d110856dc8b871f4c54e1b5f1f295","slug":"2023-05-09vr-list","date":"2023-05-09T02:23:25.000Z","updated":"2023-05-15T13:17:33.008Z","comments":true,"path":"api/articles/2023-05-09vr-list.json","keywords":null,"cover":[],"text":"虚拟列表原理虚拟列表实现原理虚拟列表（Virtual List）是一种常见的前端性能优化技术，用于解决渲染大量数据时，DOM 元素过多导致页面卡顿的问题。虚拟列表通过只渲染当前可见区域的 DOM 元素，来减少页面渲染的负担，从而提高页面性能。 虚拟列表的实现原理一般分为以下几步：...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/tags/性能优化.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Python 编程语言的基本语法","uid":"63b21671e504fbf555fa8354eb1a75b6","slug":"2023-05-06python","date":"2023-05-06T09:44:08.000Z","updated":"2023-05-29T00:41:07.264Z","comments":true,"path":"api/articles/2023-05-06python.json","keywords":null,"cover":null,"text":"动机用不用的着我就想学，咋滴～，距去年国庆学的 Python 和 Django 有半年了，原计划五一劳动节再学一遍 Python 的，结果呢–看“仙侠剧”、搓饭、遛猫（真的是遛猫不是遛狗），五一就没了，😅 理解 python 特性Python 是一个高层次的结合了解释性、编译性、...","link":"","photos":[],"count_time":{"symbolsCount":"71k","symbolsTime":"1:04"},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}