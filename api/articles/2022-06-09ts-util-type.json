{"title":"10.Typescript 工具类型","uid":"effcb24e596d83e2df5140f38213b656","slug":"2022-06-09ts-util-type","date":"2022-06-08T14:49:28.000Z","updated":"2022-09-15T14:26:10.837Z","comments":true,"path":"api/articles/2022-06-09ts-util-type.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","content":"<p>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.<br><code>Typescript提供了一些帮助类型转换的工具类型，这些工具类型可以在全局范围内使用。</code></p>\n<h2 id=\"Partial\"><a href=\"#Partial\" class=\"headerlink\" title=\"Partial\"></a>Partial<Type></h2><p>Released: 2.1</p>\n<p>Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.<br><code>构造一个具有所有属性类型的可选属性的类型。这个工具将返回一个表示给定类型的所有子集的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n&#125;\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;\n  return &#123; ...todo, ...fieldsToUpdate &#125;;\n&#125;\n\nconst todo1 &#x3D; &#123;\n  title: &quot;organize desk&quot;,\n  description: &quot;clear clutter&quot;,\n&#125;;\n\nconst todo2 &#x3D; updateTodo(todo1, &#123;\n  description: &quot;throw out trash&quot;,\n&#125;);</code></pre>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p>\n<ul>\n<li>首先通过 keyof T，遍历出类型 T 的所有属性，然后通过 in 操作符进行遍历，最后在属性后加上?，将属性变为可选属性。</li>\n<li>注意 这个 <code>in</code> 不是<code>收缩类型操作符in</code> ,而是<code>映射类型</code>中的<code>in</code></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;HEAD&#x2F;src&#x2F;lib&#x2F;es5.d.ts#L1517\ntype Partial&lt;T&gt; &#x3D; &#123;\n  [P in keyof T]?: T[P];\n&#125;;</code></pre>\n\n<h2 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required<Type></h2><p>Released:2.8</p>\n<p>Constructs a type consisting of all properties of Type set to required. The opposite of Partial.<br><code>构造一个具有所有属性类型的必需属性的类型。与Partial相反。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Props &#123;\na?: number;\nb?: string;\n&#125;\n\nconst obj: Props &#x3D; &#123; a: 5 &#125;;\n\nconst obj2: Required&lt;Props&gt; &#x3D; &#123; a: 5 &#125;;\nProperty &#39;b&#39; is missing in type &#39;&#123; a: number; &#125;&#39; but required in type &#39;Required&lt;Props&gt;&#39;.</code></pre>\n\n<h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 用于将 T 类型的所有属性设置为必选状态，首先通过 keyof T，取出类型 T 的所有属性， 然后通过 in 操作符进行遍历，最后在属性后的 ? 前加上 -，将属性变为必选属性。</p>\n<p>这里顺便讲下-这个符号的作用，这是 TypeScript 2.8 为映射类型增加了添加或删除特定修饰符的能力。具体来说，readonly 和?映射类型中的属性修饰符现在可以加上+或-前缀，以指示应该添加或删除该修饰符，当然一般+号是可以省略的。<a href=\"https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers:~:text=You%20can%20remove%20or%20add%20these%20modifiers%20by%20prefixing%20with%20%2D%20or%20%2B.%20If%20you%20don%E2%80%99t%20add%20a%20prefix%2C%20then%20%2B%20is%20assumed.\">ts 官网 类型操作符&#x2F;映射类型</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Required&lt;T&gt; &#x3D; &#123;\n  [P in keyof T]-?: T[P];\n&#125;;</code></pre>\n\n<h2 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly<Type></h2><p>Released:2.1</p>\n<p>Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.<br><code>构造一个具有所有属性类型的只读属性的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n&#125;\n\nconst todo: Readonly&lt;Todo&gt; &#x3D; &#123;\n  title: &quot;Delete inactive users&quot;,\n&#125;;\n\ntodo.title &#x3D; &quot;Hello&quot;;\n&#x2F;&#x2F; Cannot assign to &#39;title&#39; because it is a read-only property.</code></pre>\n\n<p>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).<br><code>这个工具是用来表示在运行时将失败的赋值表达式的用途（即尝试重新分配一个冻结对象的属性）。</code><br><strong>Object.freeze</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function freeze&lt;Type&gt;(obj: Type): Readonly&lt;Type&gt;;</code></pre>\n\n<h2 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;\n  [P in K]: T;\n&#125;;</code></pre>\n\n<h2 id=\"Record-lt-Keys-Type-gt\"><a href=\"#Record-lt-Keys-Type-gt\" class=\"headerlink\" title=\"Record&lt;Keys, Type&gt;\"></a>Record&lt;Keys, Type&gt;</h2><p>Released:2.1</p>\n<p>Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface CatInfo &#123;\n  age: number;\n  breed: string;\n&#125;\n\ntype CatName &#x3D; &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;;\n\nconst cats: Record&lt;CatName, CatInfo&gt; &#x3D; &#123;\n  miffy: &#123; age: 10, breed: &quot;Persian&quot; &#125;,\n  boris: &#123; age: 5, breed: &quot;Maine Coon&quot; &#125;,\n  mordred: &#123; age: 16, breed: &quot;British Shorthair&quot; &#125;,\n&#125;;\n\ncats.boris;\n\nconst cats: Record&lt;CatName, CatInfo&gt;;</code></pre>\n\n<h2 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p>\n<p>接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;\n  [P in K]: T;\n&#125;;</code></pre>\n\n<h2 id=\"Pick-lt-Type-Keys-gt\"><a href=\"#Pick-lt-Type-Keys-gt\" class=\"headerlink\" title=\"Pick&lt;Type, Keys&gt;\"></a>Pick&lt;Type, Keys&gt;</h2><p>Released:2.1</p>\n<p>Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\ntype TodoPreview &#x3D; Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;\n\nconst todo: TodoPreview &#x3D; &#123;\n  title: &quot;Clean room&quot;,\n  completed: false,\n&#125;;\n\ntodo;\n\n&#x2F;&#x2F; const todo: TodoPreview;</code></pre>\n\n<h2 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>从 T 类型中提取部分属性，作为新的返回类型。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;\n  [P in K]: T[P];\n&#125;;</code></pre>\n\n<h2 id=\"Omit-lt-Type-Keys-gt\"><a href=\"#Omit-lt-Type-Keys-gt\" class=\"headerlink\" title=\"Omit&lt;Type, Keys&gt;\"></a>Omit&lt;Type, Keys&gt;</h2><p>Released:3.5</p>\n<p>Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).<br><code>用于构造一个类型，它是从Type类型里面过滤了一些属性Keys(Keys是字符串字面量 或者 字符串字面量的联合类型)</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n&#125;\n\ntype TodoPreview &#x3D; Omit&lt;Todo, &quot;description&quot;&gt;;\n\nconst todo: TodoPreview &#x3D; &#123;\n  title: &quot;Clean room&quot;,\n  completed: false,\n  createdAt: 1615544252770,\n&#125;;\n\ntodo;\n\n&#x2F;&#x2F; const todo: TodoPreview;\n\ntype TodoInfo &#x3D; Omit&lt;Todo, &quot;completed&quot; | &quot;createdAt&quot;&gt;;\n\nconst todoInfo: TodoInfo &#x3D; &#123;\n  title: &quot;Pick up kids&quot;,\n  description: &quot;Kindergarten closes at 5pm&quot;,\n&#125;;\n\ntodoInfo;\n\n&#x2F;&#x2F; const todoInfo: TodoInfo</code></pre>\n\n<h2 id=\"原理-5\"><a href=\"#原理-5\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>使用 <strong>keyof 类型操作符号</strong>、<strong>extends</strong>、<strong>类型操作符 Exclude</strong>、 <strong>类型操作符 Pick</strong></p>\n<ul>\n<li>结合 Pick 和 Exclude 方法，提取出不含 K 属性的类型。</li>\n<li>1.keyof T 返回的是联合类型</li>\n<li>2.<a href=\"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\">extends</a></li>\n<li>3.Exclude&lt;T, K&gt; 返回的是联合类型， 可以接收一个联合类型和一个联合类型，返回一个联合类型</li>\n<li>4.把 K 中的 key, 从 T 中排除掉，剩下的就是 Omit 的类型。</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Omit&lt;T, K extends keyof T&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code></pre>\n\n<h2 id=\"Exclude-lt-UnionType-ExcludedMembers-gt\"><a href=\"#Exclude-lt-UnionType-ExcludedMembers-gt\" class=\"headerlink\" title=\"Exclude&lt;UnionType, ExcludedMembers&gt;\"></a>Exclude&lt;UnionType, ExcludedMembers&gt;</h2><p>Released:2.8</p>\n<p>Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.<br><code>用于构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example;\ntype T0 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;\n&#x2F;&#x2F; type T0 &#x3D; &quot;b&quot; | &quot;c&quot;;\n\ntype T1 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;;\n&#x2F;&#x2F; type T1 &#x3D; &quot;c&quot;;\n\ntype T2 &#x3D; Exclude&lt;string | number | (() &#x3D;&gt; void), Function&gt;;\n&#x2F;&#x2F; type T2 &#x3D; string | number;</code></pre>\n\n<h2 id=\"extends-关键字\"><a href=\"#extends-关键字\" class=\"headerlink\" title=\"extends 关键字\"></a>extends 关键字</h2><p>不学 extends，Exclude 和 Extract，很难理解</p>\n<p>extends 关键字在 TS 编程中出现的频率挺高的，而且<code>不同场景下代表的含义不一样</code>，特此总结一下：</p>\n<ul>\n<li><p>表示继承&#x2F;拓展的含义</p>\n</li>\n<li><p>表示约束的含义</p>\n</li>\n<li><p>表示分配的含义</p>\n</li>\n</ul>\n<hr/>\n\n<h3 id=\"表示继承-x2F-拓展\"><a href=\"#表示继承-x2F-拓展\" class=\"headerlink\" title=\"表示继承&#x2F;拓展\"></a><strong>表示继承&#x2F;拓展</strong></h3><p>extends 是 ts 里一个很常见的关键字，同时也是 es6 里引入的一个新的关键字。在 js 里，extends 一般和 class 一起使用</p>\n<ul>\n<li>es6 继承父类的方法和属性</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n  kind &#x3D; &quot;animal&quot;;\n  constructor(kind) &#123;\n    this.kind &#x3D; kind;\n  &#125;\n  sayHello() &#123;\n    console.log(&#96;Hello, I am a $&#123;this.kind&#125;!&#96;);\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  constructor(kind) &#123;\n    super(kind);\n  &#125;\n  bark() &#123;\n    console.log(&quot;wang wang&quot;);\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog(&quot;dog&quot;);\ndog.name; &#x2F;&#x2F;  &#x3D;&gt; &#39;dog&#39;\ndog.sayHello(); &#x2F;&#x2F; &#x3D;&gt; Hello, I am a dog!</code></pre>\n\n<p>这里 Dog 继承了父类的 sayHello 方法，因为可以在 Dog 实例 dog 上调用。</p>\n<ul>\n<li>ts 继承某个类型<br>在 ts 里，extends 除了可以像 js 继承值，还可以继承&#x2F;扩展类型：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface Animal &#123;\n  kind: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  bark(): void;\n&#125;\n&#x2F;&#x2F; Dog &#x3D;&gt; &#123; name: string; bark(): void &#125;</code></pre>\n\n<hr/>\n\n<h3 id=\"泛型约束\"><a href=\"#泛型约束\" class=\"headerlink\" title=\"泛型约束\"></a>泛型约束</h3><p>在书写泛型的时候，我们往往需要对类型参数作一定的限制，比如希望传入的参数都有 name 属性的数组我们可以这么写：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCnames&lt;T extends &#123; name: string &#125;&gt;(entities: T[]): string[] &#123;\n  return entities.map((entity) &#x3D;&gt; entity.cname);\n&#125;</code></pre>\n\n<p>这里 extends 对传入的参数作了一个限制，就是 entities 的每一项可以是一个对象，但是必须含有类型为 string 的 cname 属性。</p>\n<p>再比如，redux 里 dispatch 一个 action，必须包含 type 属性：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;redux&#x2F;blob&#x2F;2edd0363271af46e327e118f3d92e78e258bf0cd&#x2F;src&#x2F;types&#x2F;store.ts#L83\n\n&#x2F;&#x2F; Dispatch\nexport interface Dispatch&lt;A extends Action &#x3D; AnyAction&gt; &#123;\n  &lt;T extends A&gt;(action: T, ...extraArgs: any[]): T;\n&#125;\n\n&#x2F;&#x2F; AnyAction\nexport interface AnyAction extends Action &#123;\n  &#x2F;&#x2F; Allows any extra properties to be defined in an action.\n  [extraProps: string]: any;\n&#125;\n&#x2F;&#x2F; Action\nexport interface Action&lt;T &#x3D; any&gt; &#123;\n  type: T;\n&#125;\n\n&#x2F;&#x2F; 上述代码 简化\ninterface Dispatch&lt;T extends &#123; type: string &#125;&gt; &#123;\n  (action: T): T;\n&#125;</code></pre>\n\n<h3 id=\"条件类型与高阶类型\"><a href=\"#条件类型与高阶类型\" class=\"headerlink\" title=\"条件类型与高阶类型\"></a>条件类型与高阶类型</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">SomeType extends OtherType ? TrueType : FalseType;\n</code></pre>\n\n<p>When the type on the left of the extendsis assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).<br><code>当左边的类型可以赋值给右边的类型，那么你就会得到第一个分支的类型，否则你就会得到第二个分支的类型。</code></p>\n<p>extends 还有一大用途就是用来判断一个类型是不是可以分配给另一个类型，这在写高级类型的时候非常有用，举个 ????：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Human &#x3D; &#123;\n  name: string;\n&#125;;\ntype Duck &#x3D; &#123;\n  name: string;\n&#125;;\ntype Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;yes&#39;</code></pre>\n\n<p>在 vscode 里或者 ts playground 里输入这段代码，你会发现 Bool 的类型是’yes’。这是因为 Human 和 Duck 的类型完全相同，或者说 Human 类型的一切约束条件，Duck 都具备；换言之，类型为 Human 的值可以分配给类型为 Duck 的值（分配成功的前提是，Duck 里面得的类型得有一样的），反之亦然。需要理解的是，这里 A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集。稍微扩展下来详细说明这个问题：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Human &#x3D; &#123;\n  name: string;\n  occupation: string;\n&#125;;\ntype Duck &#x3D; &#123;\n  name: string;\n&#125;;\ntype Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;no&#39;</code></pre>\n\n<p>当我们给 Human 加上一个 occupation 属性，发现此时 Bool 是’no’，这是因为 Duck 没有类型为 string 的 occupation 属性，类型 Duck 不满足类型 Human 的类型约束。因此，A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集，理解 extends 在类型三元表达式里的用法非常重要。</p>\n<p>继续看示例</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type A1 &#x3D; &quot;x&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; string\ntype A2 &#x3D; &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; number\n\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; ?</code></pre>\n\n<p>A1 和 A2 是 extends 条件判断的普通用法，和上面的判断方法一样。</p>\n<p>P 是带参数 T 的泛型类型，其表达式和 A1，A2 的形式完全相同，A3 是泛型类型 P 传入参数’x’ | ‘y’得到的类型，如果将’x’ | ‘y’带入泛型类的表达式，可以看到和 A2 类型的形式是完全一样的，那是不是说明，A3 和 A2 的类型就是完全一样的呢？</p>\n<p>有兴趣可以自己试一试，这里就直接给结论了</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre>\n\n<p>是不是很反直觉？这个反直觉结果的原因就是所谓的分配条件类型（Distributive Conditional Types）</p>\n<p>When conditional types act on a generic type, they become distributive when given a union type<br><code>当条件类型作用于泛型类型时，它们变成分配条件类型（Distributive Conditional Types）</code></p>\n<p>这句话翻译过来也还是看不懂，大白话</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于使用 extends 关键字的条件类型（即上面的三元表达式类型），<strong>如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</strong></p></blockquote>\n<p>If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.<br><code>如果将联合类型传入 ToArray，则条件类型将会应用到联合类型的每一个成员。</code></p>\n<p>还是用上面的例子说明</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre>\n\n<p>该例中，extends 的前参为 T，T 是一个泛型参数。在 A3 的定义中，给 T 传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入 P<T></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">P&lt;&#39;x&#39; | &#39;y&#39;&gt; &#x3D;&gt; P&lt;&#39;x&#39;&gt; | P&lt;&#39;y&#39;&gt;\n\n&#39;x&#39;代入得到\n\n&#39;x&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; string\n\n&#39;y&#39;代入得到\n\n&#39;y&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; number\n\n然后将每一项代入得到的结果联合起来，得到 string | number\n</code></pre>\n\n<p>总之，满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型</p>\n<p>特殊的 never</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; never 是所有类型的子类型\ntype A1 &#x3D; never extends &quot;x&quot; ? string : number; &#x2F;&#x2F; string\n\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; never</code></pre>\n\n<p>上面的示例中，A2 和 A1 的结果竟然不一样，看起来 never 并不是一个联合类型，所以直接代入条件类型的定义即可，获取的结果应该和 A1 一直才对啊？</p>\n<p>实际上，这里还是条件分配类型在起作用。never 被认为是空的联合类型，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以 P<T>的表达式其实根本就没有执行，所以 A2 的定义也就类似于永远没有返回的函数一样，是 never 类型的。</p>\n<p>防止条件判断中的分配</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type P&lt;T&gt; &#x3D; [T] extends [&quot;x&quot;] ? string : number;\ntype A1 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; number\ntype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; string</code></pre>\n\n<p>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p>\n<hr/>\n\n<h2 id=\"原理-注意\"><a href=\"#原理-注意\" class=\"headerlink\" title=\"原理(注意)\"></a>原理(注意)</h2><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>需前置学习 extends 关键字</p>\n\n</div>\n<ul>\n<li>源码很简单，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 never，否则返回 T</li>\n<li>never 是一个特殊的类型，在这里可以表示为空的联合类型，在于与其他类型的联合后，结果为其他类型。</li>\n<li>没有遍历，怎么也能实现呢? <code>这里还涉及到extends条件类型的特殊情况，extends的前参T如果是一个泛型参数。对于使用extends关键字的条件类型（即上面的三元表达式类型），如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，两个类型会成为分配条件类型（Distributive Conditional Types）。分配条件类型是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</code></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;</code></pre>\n\n<h2 id=\"Extract-lt-Type-Union-gt\"><a href=\"#Extract-lt-Type-Union-gt\" class=\"headerlink\" title=\"Extract&lt;Type, Union&gt;\"></a>Extract&lt;Type, Union&gt;</h2><p>Released:2.8</p>\n<p>Constructs a type by extracting from Type all union members that are assignable to Union.<br><code>用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype T0 &#x3D; Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;;\n&#x2F;&#x2F; type T0 &#x3D; &quot;a&quot;;\n\ntype T1 &#x3D; Extract&lt;string | number | (() &#x3D;&gt; void), Function&gt;;\n&#x2F;&#x2F; type T1 &#x3D; () &#x3D;&gt; void;</code></pre>\n\n<h2 id=\"原理-注意-1\"><a href=\"#原理-注意-1\" class=\"headerlink\" title=\"原理(注意)\"></a>原理(注意)</h2><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p><p>需前置学习 extends 关键字</p>\n</p>\n</div>\n<p>原理：与 Exclude 相反，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 T，否则返回 never。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;</code></pre>\n\n<h2 id=\"NonNullable\"><a href=\"#NonNullable\" class=\"headerlink\" title=\"NonNullable\"></a>NonNullable<Type></h2><p>Released:2.8</p>\n<p>Constructs a type by excluding null and undefined from Type.<br><code>用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype T0 &#x3D; NonNullable&lt;string | number | undefined&gt;;\n\n&#x2F;&#x2F; type T0 &#x3D; string | number;\n\ntype T1 &#x3D; NonNullable&lt;string[] | null | undefined&gt;;\n\n&#x2F;&#x2F; type T1 &#x3D; string[];</code></pre>\n\n<h2 id=\"原理-6\"><a href=\"#原理-6\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>判断 T 是否可以赋值给 null 或者 undefined 类型，是则返回 never，否则返回 T，如果这段看不明白的可以再看下 Exclude 那段关于 extends 的补充说明。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type NonNullable&lt;T&gt; &#x3D; T extends null | undefined ? never : T;</code></pre>\n\n<h2 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters<Type></h2><p>Released:3.1</p>\n<p>Constructs a tuple type from the types used in the parameters of a function type Type.<br><code>用于根据所有Type中函数类型的参数构造一个元祖类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ndeclare function f1(arg: &#123; a: number; b: string &#125;): void;\n\ntype T0 &#x3D; Parameters&lt;() &#x3D;&gt; string&gt;;\n&#x2F;&#x2F; type T0 &#x3D; []\n\ntype T1 &#x3D; Parameters&lt;(s: string) &#x3D;&gt; void&gt;;\n&#x2F;&#x2F; type T1 &#x3D; [s: string]\n\ntype T2 &#x3D; Parameters&lt;&lt;T&gt;(arg: T) &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T2 &#x3D; [arg: unknown]\n\ntype T3 &#x3D; Parameters&lt;typeof f1&gt;;\n&#x2F;&#x2F; type T3 &#x3D; [arg: &#123;\n&#x2F;&#x2F;   a: number;\n&#x2F;&#x2F;   b: string;\n&#x2F;&#x2F; &#125;]\n\ntype T4 &#x3D; Parameters&lt;any&gt;;\n&#x2F;&#x2F; type T4 &#x3D; unknown[]\n\ntype T5 &#x3D; Parameters&lt;never&gt;;\n&#x2F;&#x2F; type T5 &#x3D; never\n\ntype T6 &#x3D; Parameters&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T6 &#x3D; never\n\ntype T7 &#x3D; Parameters&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.\n\ntype T7 &#x3D; never;</code></pre>\n\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><ul>\n<li><code>Parameters</code> 首先约束参数 <code>T </code>必须是个函数类型</li>\n<li>判断 <code>T</code> 是否是函数类型，如果是则使用 <code>infer P</code> 暂时存一下函数的参数类型，直接用 P 即可得到这个类型并返回，否则就返回 <code>never</code></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Parameters&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (\n  ...args: infer P\n) &#x3D;&gt; any\n  ? P\n  : never;</code></pre>\n\n<p>这里用到了<code>infer</code>，<code>infer P</code>标记一个泛型，表示这个泛型是一个待推断的类型，并且可以直接使用。</p>\n<h2 id=\"ConstructorParameters\"><a href=\"#ConstructorParameters\" class=\"headerlink\" title=\"ConstructorParameters\"></a>ConstructorParameters<Type></h2><p><code>构造参数类型</code><br>Released:3.1</p>\n<p>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).<br><code>构造一个从构造函数类型Type中提取的元组或数组类型。如果Type不是函数，则生成never类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype T0 &#x3D; ConstructorParameters&lt;ErrorConstructor&gt;;\n&#x2F;&#x2F; type T0 &#x3D; [message?: string]\n\ntype T1 &#x3D; ConstructorParameters&lt;FunctionConstructor&gt;;\n&#x2F;&#x2F; type T1 &#x3D; string[]\n\ntype T2 &#x3D; ConstructorParameters&lt;RegExpConstructor&gt;;\n&#x2F;&#x2F; type T2 &#x3D; [pattern: string | RegExp, flags?: string]\n\ntype T3 &#x3D; ConstructorParameters&lt;any&gt;;\n&#x2F;&#x2F; type T3 &#x3D; unknown[]\n\ntype T4 &#x3D; ConstructorParameters&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.\n\n&#x2F;&#x2F; type T4 &#x3D; never</code></pre>\n\n<h2 id=\"ReturnType\"><a href=\"#ReturnType\" class=\"headerlink\" title=\"ReturnType\"></a>ReturnType<Type></h2><p>Released:2.8</p>\n<p>Constructs a type consisting of the return type of function Type.<br><code>用于构造一个含有Type函数的返回值的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ndeclare function f1(): &#123; a: number; b: string &#125;;\n\ntype T0 &#x3D; ReturnType&lt;() &#x3D;&gt; string&gt;;\n&#x2F;&#x2F; type T0 &#x3D; string\n\ntype T1 &#x3D; ReturnType&lt;(s: string) &#x3D;&gt; void&gt;;\n&#x2F;&#x2F; type T1 &#x3D; void\n\ntype T2 &#x3D; ReturnType&lt;&lt;T&gt;() &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T2 &#x3D; unknown\n\ntype T3 &#x3D; ReturnType&lt;&lt;T extends U, U extends number[]&gt;() &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T3 &#x3D; number[]\n\ntype T4 &#x3D; ReturnType&lt;typeof f1&gt;;\n&#x2F;&#x2F; type T4 &#x3D; &#123;\n&#x2F;&#x2F; a: number;\n&#x2F;&#x2F; b: string;\n&#x2F;&#x2F; &#125;\n\ntype T5 &#x3D; ReturnType&lt;any&gt;;\n&#x2F;&#x2F; type T5 &#x3D; any\n\ntype T6 &#x3D; ReturnType&lt;never&gt;;\n&#x2F;&#x2F; type T6 &#x3D; never\n\ntype T7 &#x3D; ReturnType&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T7 &#x3D; any\n\ntype T8 &#x3D; ReturnType&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.\n\n&#x2F;&#x2F; type T8 &#x3D; any</code></pre>\n\n<h2 id=\"原理-7\"><a href=\"#原理-7\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>与 Parameters 类似</p>\n<p>ReturnType 首先约束参数 T 必须是个函数类型<br>判断 T 是否是函数类型，如果是则使用 infer R 暂时存一下函数的返回值类型，后面的语句直接用 R 即可得到这个类型并返回，否则就返回 any</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (\n  ...args: any\n) &#x3D;&gt; infer R\n  ? R\n  : any;</code></pre>\n\n<h2 id=\"InstanceType\"><a href=\"#InstanceType\" class=\"headerlink\" title=\"InstanceType\"></a>InstanceType<Type></h2><p>Released:2.8</p>\n<p>Constructs a type consisting of the instance type of a constructor function in Type.<br><code>返回构造函数类型T的实例类型</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\nclass C &#123;\n  x &#x3D; 0;\n  y &#x3D; 0;\n&#125;\n\ntype T0 &#x3D; InstanceType&lt;typeof C&gt;;\n&#x2F;&#x2F; type T0 &#x3D; C\n\ntype T1 &#x3D; InstanceType&lt;any&gt;;\n&#x2F;&#x2F; type T1 &#x3D; any\n\ntype T2 &#x3D; InstanceType&lt;never&gt;;\n&#x2F;&#x2F; type T2 &#x3D; never\n\ntype T3 &#x3D; InstanceType&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T3 &#x3D; any\n\ntype T4 &#x3D; InstanceType&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.\n\n&#x2F;&#x2F; type T4 &#x3D; any</code></pre>\n<h2 id=\"原理-8\"><a href=\"#原理-8\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><code>type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any</code><br>与ResultType 类似<br><code>type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code></p>\n<h2 id=\"ThisParameterType\"><a href=\"#ThisParameterType\" class=\"headerlink\" title=\"ThisParameterType\"></a>ThisParameterType<Type></h2><p>Released:3.3</p>\n<p>Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter.<br><code>用于提取一个函数类型Type的this (opens new window)参数类型，返回unknown (opens new window)如果这个函数类型没有this参数。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\nfunction toHex(this: Number) &#123;\n  return this.toString(16);\n&#125;\n\nfunction numberToString(n: ThisParameterType&lt;typeof toHex&gt;) &#123;\n  return toHex.apply(n);\n&#125;</code></pre>\n\n<h2 id=\"OmitThisParameter\"><a href=\"#OmitThisParameter\" class=\"headerlink\" title=\"OmitThisParameter\"></a>OmitThisParameter<Type></h2><p>Released:3.3</p>\n<p>Removes the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type.<br><code>用于移除一个函数类型Type的this (opens new window)参数类型。如果Type没有明确的声明this 类型，那么这个返回的结果就是Type，不然的话，就返回一个新的函数类型，基于Type，但不再有this参数。范型会被抹去，只有最后重载的签名被传播进了返回的新的函数类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\nfunction toHex(this: Number) &#123;\n  return this.toString(16);\n&#125;\n\nconst fiveToHex: OmitThisParameter&lt;typeof toHex&gt; &#x3D; toHex.bind(5);\n\nconsole.log(fiveToHex());</code></pre>\n\n<h2 id=\"ThisType\"><a href=\"#ThisType\" class=\"headerlink\" title=\"ThisType\"></a>ThisType<Type></h2><p>Released:2.3</p>\n<p>This utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility.<br><code>这个类型不返回一个转换过的类型，它被用作标记一个上下文的this类型。注意下如果想使用这个工具类型，noImplicitThis (opens new window)的flag必须启用。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype ObjectDescriptor&lt;D, M&gt; &#x3D; &#123;\n  data?: D;\n  methods?: M &amp; ThisType&lt;D &amp; M&gt;; &#x2F;&#x2F; Type of &#39;this&#39; in methods is D &amp; M\n&#125;;\n\nfunction makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M &#123;\n  let data: object &#x3D; desc.data || &#123;&#125;;\n  let methods: object &#x3D; desc.methods || &#123;&#125;;\n  return &#123; ...data, ...methods &#125; as D &amp; M;\n&#125;\n\nlet obj &#x3D; makeObject(&#123;\n  data: &#123; x: 0, y: 0 &#125;,\n  methods: &#123;\n    moveBy(dx: number, dy: number) &#123;\n      this.x +&#x3D; dx; &#x2F;&#x2F; Strongly typed this\n      this.y +&#x3D; dy; &#x2F;&#x2F; Strongly typed this\n    &#125;,\n  &#125;,\n&#125;);\n\nobj.x &#x3D; 10;\nobj.y &#x3D; 20;\nobj.moveBy(5, 5);</code></pre>\n\n<p>In the example above, the methods object in the argument to makeObject has a contextual type that includes ThisType&lt;D &amp; M&gt; and therefore the type of this in methods within the methods object is { x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }. Notice how the type of the methods property simultaneously is an inference target and a source for the this type in methods.<br><code>在上面的示例中，makeObject的参数中的methods对象包含了一个上下文类型，该类型包含了ThisType&lt;D &amp; M&gt;，因此methods对象中的this类型是&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;。请注意，methods属性的类型同时是一个推断目标和一个methods对象中的this类型的源。</code><br>The ThisType<T> marker interface is simply an empty interface declared in lib.d.ts. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.<br><code>ThisType&lt;T&gt;标记接口是在lib.d.ts中声明的空接口。它只是在对象字面量的上下文类型中被识别而已，该接口的行为与空接口一样。</code></p>\n<h2 id=\"Intrinsic-String-Manipulation-Types\"><a href=\"#Intrinsic-String-Manipulation-Types\" class=\"headerlink\" title=\"Intrinsic String Manipulation Types\"></a>Intrinsic String Manipulation Types</h2><p><code>内部字符串操作类型</code><br>Uppercase<StringType><br>Lowercase<StringType><br>Capitalize<StringType><br>Uncapitalize<StringType></p>\n<p>To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the Template Literal Types documentation.<br><code>为了帮助模板字符串操作，TypeScript包含一组可以在字符串操作中使用的类型。你可以在模板字符串类型文档中找到它们。</code></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html\">typescript handbook utility-types</a><br><a href=\"https://ts.yayujs.com/reference/UtilityTypes.html#intrinsic-string-manipulation-types\">工具类型</a><br><a href=\"https://blog.csdn.net/qq_34998786/article/details/120300361\">Typescript 中的 extends 关键字</a>Exclude 与 Extract 前置学习项<br><a href=\"https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses\">Typescript Classes extends-clauses</a><br><a href=\"https://blog.csdn.net/qq_32438227/article/details/125058423\">彻底搞懂 typescript 工具类型及其原理</a> 该文有错误内容，要注意哦<br><a href=\"https://juejin.cn/post/6844904066485583885\">TypeScript 的 extends 条件类型</a></p>\n","text":"TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.Typescript提供了一些帮...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"typescript","slug":"typescript","count":11,"path":"api/categories/typescript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":11,"path":"api/tags/TypeScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Partial\"><span class=\"toc-text\">Partial</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Required\"><span class=\"toc-text\">Required</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-1\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Readonly\"><span class=\"toc-text\">Readonly</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-2\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Record-lt-Keys-Type-gt\"><span class=\"toc-text\">Record&lt;Keys, Type&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-3\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pick-lt-Type-Keys-gt\"><span class=\"toc-text\">Pick&lt;Type, Keys&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-4\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Omit-lt-Type-Keys-gt\"><span class=\"toc-text\">Omit&lt;Type, Keys&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-5\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Exclude-lt-UnionType-ExcludedMembers-gt\"><span class=\"toc-text\">Exclude&lt;UnionType, ExcludedMembers&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#extends-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">extends 关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E7%A4%BA%E7%BB%A7%E6%89%BF-x2F-%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">表示继承&#x2F;拓展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">泛型约束</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%AB%98%E9%98%B6%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">条件类型与高阶类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">原理(注意)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Extract-lt-Type-Union-gt\"><span class=\"toc-text\">Extract&lt;Type, Union&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-%E6%B3%A8%E6%84%8F-1\"><span class=\"toc-text\">原理(注意)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NonNullable\"><span class=\"toc-text\">NonNullable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-6\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Parameters\"><span class=\"toc-text\">Parameters</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">原理：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ConstructorParameters\"><span class=\"toc-text\">ConstructorParameters</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReturnType\"><span class=\"toc-text\">ReturnType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-7\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#InstanceType\"><span class=\"toc-text\">InstanceType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-8\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ThisParameterType\"><span class=\"toc-text\">ThisParameterType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OmitThisParameter\"><span class=\"toc-text\">OmitThisParameter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ThisType\"><span class=\"toc-text\">ThisType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Intrinsic-String-Manipulation-Types\"><span class=\"toc-text\">Intrinsic String Manipulation Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"修补node_modules下源码","uid":"c3d5408da05b02828c848a49ca35cf59","slug":"2022-06-09patch-package","date":"2022-06-09T01:51:48.000Z","updated":"2022-09-15T14:26:10.835Z","comments":true,"path":"api/articles/2022-06-09patch-package.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220609160539.webp","text":"背景之前在简书上记录过，没迁移简书文章，所以重新记录 由于hexo-theme-aurora代码配色不是很友好，需要自定义配色，又不想改其 github 上代码，直接处理node_modules下的配色文件 安装 patch-packagepatch-package 包可以通过 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"工具","slug":"工具","count":15,"path":"api/categories/工具.json"}],"tags":[{"name":"npm","slug":"npm","count":5,"path":"api/tags/npm.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"9.Typescript手册 模块","uid":"29a670518a826389296f8915224ed71e","slug":"2022-06-08ts-modules","date":"2022-06-08T14:47:47.000Z","updated":"2022-09-15T14:26:10.765Z","comments":true,"path":"api/articles/2022-06-08ts-modules.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"JavaScript has a long history of different ways to handle modularizing code. TypeScript having been around since 2012, has implemented suppo...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"typescript","slug":"typescript","count":11,"path":"api/categories/typescript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":11,"path":"api/tags/TypeScript.json"}],"author":{"name":"陈海龙","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"需要就学呗，多大点事😂","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}