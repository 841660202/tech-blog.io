{"title":"10.Typescript 工具类型","uid":"effcb24e596d83e2df5140f38213b656","slug":"2022-06-09ts-util-type","date":"2022-06-08T14:49:28.000Z","updated":"2023-07-31T06:42:49.721Z","comments":true,"path":"api/articles/2022-06-09ts-util-type.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","content":"<p>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.<br><code>Typescript提供了一些帮助类型转换的工具类型，这些工具类型可以在全局范围内使用。</code></p>\n<h2 id=\"Partial\"><a href=\"#Partial\" class=\"headerlink\" title=\"Partial\"></a>Partial<Type></h2><p>Released: 2.1</p>\n<p>Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.<br><code>构造一个具有所有属性类型的可选属性的类型。这个工具将返回一个表示给定类型的所有子集的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n&#125;\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;\n  return &#123; ...todo, ...fieldsToUpdate &#125;;\n&#125;\n\nconst todo1 &#x3D; &#123;\n  title: &#39;organize desk&#39;,\n  description: &#39;clear clutter&#39;,\n&#125;;\n\nconst todo2 &#x3D; updateTodo(todo1, &#123;\n  description: &#39;throw out trash&#39;,\n&#125;);</code></pre>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p>\n<ul>\n<li>首先通过 keyof T，遍历出类型 T 的所有属性，然后通过 in 操作符进行遍历，最后在属性后加上?，将属性变为可选属性。</li>\n<li>注意 这个 <code>in</code> 不是<code>收缩类型操作符in</code> ,而是<code>映射类型</code>中的<code>in</code></li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;HEAD&#x2F;src&#x2F;lib&#x2F;es5.d.ts#L1517\ntype Partial&lt;T&gt; &#x3D; &#123;\n  [P in keyof T]?: T[P];\n&#125;;</code></pre>\n\n<h2 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required<Type></h2><p>Released:2.8</p>\n<p>Constructs a type consisting of all properties of Type set to required. The opposite of Partial.<br><code>构造一个具有所有属性类型的必需属性的类型。与Partial相反。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Props &#123;\na?: number;\nb?: string;\n&#125;\n\nconst obj: Props &#x3D; &#123; a: 5 &#125;;\n\nconst obj2: Required&lt;Props&gt; &#x3D; &#123; a: 5 &#125;;\nProperty &#39;b&#39; is missing in type &#39;&#123; a: number; &#125;&#39; but required in type &#39;Required&lt;Props&gt;&#39;.</code></pre>\n\n<h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 用于将 T 类型的所有属性设置为必选状态，首先通过 keyof T，取出类型 T 的所有属性， 然后通过 in 操作符进行遍历，最后在属性后的 ? 前加上 -，将属性变为必选属性。</p>\n<p>这里顺便讲下-这个符号的作用，这是 TypeScript 2.8 为映射类型增加了添加或删除特定修饰符的能力。具体来说，readonly 和?映射类型中的属性修饰符现在可以加上+或-前缀，以指示应该添加或删除该修饰符，当然一般+号是可以省略的。<a href=\"https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers:~:text=You%20can%20remove%20or%20add%20these%20modifiers%20by%20prefixing%20with%20%2D%20or%20%2B.%20If%20you%20don%E2%80%99t%20add%20a%20prefix%2C%20then%20%2B%20is%20assumed.\">ts 官网 类型操作符&#x2F;映射类型</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Required&lt;T&gt; &#x3D; &#123;\n  [P in keyof T]-?: T[P];\n&#125;;</code></pre>\n\n<h2 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly<Type></h2><p>Released:2.1</p>\n<p>Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.<br><code>构造一个具有所有属性类型的只读属性的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n&#125;\n\nconst todo: Readonly&lt;Todo&gt; &#x3D; &#123;\n  title: &#39;Delete inactive users&#39;,\n&#125;;\n\ntodo.title &#x3D; &#39;Hello&#39;;\n&#x2F;&#x2F; Cannot assign to &#39;title&#39; because it is a read-only property.</code></pre>\n\n<p>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).<br><code>这个工具是用来表示在运行时将失败的赋值表达式的用途（即尝试重新分配一个冻结对象的属性）。</code><br><strong>Object.freeze</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function freeze&lt;Type&gt;(obj: Type): Readonly&lt;Type&gt;;</code></pre>\n\n<h2 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Readonly&lt;T&gt; &#x3D; &#123;\n  readonly [P in keyof T]: T[P];\n&#125;;</code></pre>\n\n<h2 id=\"Record-lt-Keys-Type-gt\"><a href=\"#Record-lt-Keys-Type-gt\" class=\"headerlink\" title=\"Record&lt;Keys, Type&gt;\"></a>Record&lt;Keys, Type&gt;</h2><p>Released:2.1</p>\n<p>Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface CatInfo &#123;\n  age: number;\n  breed: string;\n&#125;\n\ntype CatName &#x3D; &#39;miffy&#39; | &#39;boris&#39; | &#39;mordred&#39;;\n\nconst cats: Record&lt;CatName, CatInfo&gt; &#x3D; &#123;\n  miffy: &#123; age: 10, breed: &#39;Persian&#39; &#125;,\n  boris: &#123; age: 5, breed: &#39;Maine Coon&#39; &#125;,\n  mordred: &#123; age: 16, breed: &#39;British Shorthair&#39; &#125;,\n&#125;;\n\ncats.boris;\n\nconst cats: Record&lt;CatName, CatInfo&gt;;</code></pre>\n\n<h2 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p>\n<p>接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;\n  [P in K]: T;\n&#125;;</code></pre>\n\n<h2 id=\"Pick-lt-Type-Keys-gt\"><a href=\"#Pick-lt-Type-Keys-gt\" class=\"headerlink\" title=\"Pick&lt;Type, Keys&gt;\"></a>Pick&lt;Type, Keys&gt;</h2><p>Released:2.1</p>\n<p>Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\ntype TodoPreview &#x3D; Pick&lt;Todo, &#39;title&#39; | &#39;completed&#39;&gt;;\n\nconst todo: TodoPreview &#x3D; &#123;\n  title: &#39;Clean room&#39;,\n  completed: false,\n&#125;;\n\ntodo;\n\n&#x2F;&#x2F; const todo: TodoPreview;</code></pre>\n\n<h2 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>从 T 类型中提取部分属性，作为新的返回类型。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;\n  [P in K]: T[P];\n&#125;;</code></pre>\n\n<h2 id=\"Omit-lt-Type-Keys-gt\"><a href=\"#Omit-lt-Type-Keys-gt\" class=\"headerlink\" title=\"Omit&lt;Type, Keys&gt;\"></a>Omit&lt;Type, Keys&gt;</h2><p>Released:3.5</p>\n<p>Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).<br><code>用于构造一个类型，它是从Type类型里面过滤了一些属性Keys(Keys是字符串字面量 或者 字符串字面量的联合类型)</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n&#125;\n\ntype TodoPreview &#x3D; Omit&lt;Todo, &#39;description&#39;&gt;;\n\nconst todo: TodoPreview &#x3D; &#123;\n  title: &#39;Clean room&#39;,\n  completed: false,\n  createdAt: 1615544252770,\n&#125;;\n\ntodo;\n\n&#x2F;&#x2F; const todo: TodoPreview;\n\ntype TodoInfo &#x3D; Omit&lt;Todo, &#39;completed&#39; | &#39;createdAt&#39;&gt;;\n\nconst todoInfo: TodoInfo &#x3D; &#123;\n  title: &#39;Pick up kids&#39;,\n  description: &#39;Kindergarten closes at 5pm&#39;,\n&#125;;\n\ntodoInfo;\n\n&#x2F;&#x2F; const todoInfo: TodoInfo</code></pre>\n\n<h2 id=\"原理-5\"><a href=\"#原理-5\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>使用 <strong>keyof 类型操作符号</strong>、<strong>extends</strong>、<strong>类型操作符 Exclude</strong>、 <strong>类型操作符 Pick</strong></p>\n<ul>\n<li>结合 Pick 和 Exclude 方法，提取出不含 K 属性的类型。</li>\n<li>1.keyof T 返回的是联合类型</li>\n<li>2.<a href=\"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\">extends</a></li>\n<li>3.Exclude&lt;T, K&gt; 返回的是联合类型， 可以接收一个联合类型和一个联合类型，返回一个联合类型</li>\n<li>4.把 K 中的 key, 从 T 中排除掉，剩下的就是 Omit 的类型。</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Omit&lt;T, K extends keyof T&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code></pre>\n\n<h2 id=\"Exclude-lt-UnionType-ExcludedMembers-gt\"><a href=\"#Exclude-lt-UnionType-ExcludedMembers-gt\" class=\"headerlink\" title=\"Exclude&lt;UnionType, ExcludedMembers&gt;\"></a>Exclude&lt;UnionType, ExcludedMembers&gt;</h2><p>Released:2.8</p>\n<p>Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.<br><code>用于构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example;\ntype T0 &#x3D; Exclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39;&gt;;\n&#x2F;&#x2F; type T0 &#x3D; &quot;b&quot; | &quot;c&quot;;\n\ntype T1 &#x3D; Exclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39; | &#39;b&#39;&gt;;\n&#x2F;&#x2F; type T1 &#x3D; &quot;c&quot;;\n\ntype T2 &#x3D; Exclude&lt;string | number | (() &#x3D;&gt; void), Function&gt;;\n&#x2F;&#x2F; type T2 &#x3D; string | number;</code></pre>\n\n<h2 id=\"原理-6\"><a href=\"#原理-6\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>源码很简单，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 never，否则返回 T</li>\n<li>never 是一个特殊的类型，在这里可以表示为空的联合类型，在于与其他类型的联合后，结果为其他类型。</li>\n<li>没有遍历，怎么也能实现呢? <code>这里还涉及到extends条件类型的特殊情况，extends的前参T如果是一个泛型参数。对于使用extends关键字的条件类型（即上面的三元表达式类型），如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，两个类型会成为分配条件类型（Distributive Conditional Types）。分配条件类型是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</code></li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;</code></pre>\n\n<h2 id=\"Extract-lt-Type-Union-gt\"><a href=\"#Extract-lt-Type-Union-gt\" class=\"headerlink\" title=\"Extract&lt;Type, Union&gt;\"></a>Extract&lt;Type, Union&gt;</h2><p>Released:2.8</p>\n<p>Constructs a type by extracting from Type all union members that are assignable to Union.<br><code>用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype T0 &#x3D; Extract&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39; | &#39;f&#39;&gt;;\n&#x2F;&#x2F; type T0 &#x3D; &quot;a&quot;;\n\ntype T1 &#x3D; Extract&lt;string | number | (() &#x3D;&gt; void), Function&gt;;\n&#x2F;&#x2F; type T1 &#x3D; () &#x3D;&gt; void;</code></pre>\n\n<h2 id=\"原理-注意\"><a href=\"#原理-注意\" class=\"headerlink\" title=\"原理(注意)\"></a>原理(注意)</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>需前置学习 extends 关键字</p>\n\n</div>\n<p>原理：与 Exclude 相反，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 T，否则返回 never。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;</code></pre>\n\n<h2 id=\"NonNullable\"><a href=\"#NonNullable\" class=\"headerlink\" title=\"NonNullable\"></a>NonNullable<Type></h2><p>Released:2.8</p>\n<p>Constructs a type by excluding null and undefined from Type.<br><code>用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype T0 &#x3D; NonNullable&lt;string | number | undefined&gt;;\n\n&#x2F;&#x2F; type T0 &#x3D; string | number;\n\ntype T1 &#x3D; NonNullable&lt;string[] | null | undefined&gt;;\n\n&#x2F;&#x2F; type T1 &#x3D; string[];</code></pre>\n\n<h2 id=\"原理-7\"><a href=\"#原理-7\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>判断 T 是否可以赋值给 null 或者 undefined 类型，是则返回 never，否则返回 T，如果这段看不明白的可以再看下 Exclude 那段关于 extends 的补充说明。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type NonNullable&lt;T&gt; &#x3D; T extends null | undefined ? never : T;</code></pre>\n\n<h2 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters<Type></h2><p>Released:3.1</p>\n<p>Constructs a tuple type from the types used in the parameters of a function type Type.<br><code>用于根据所有Type中函数类型的参数构造一个元祖类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ndeclare function f1(arg: &#123; a: number; b: string &#125;): void;\n\ntype T0 &#x3D; Parameters&lt;() &#x3D;&gt; string&gt;;\n&#x2F;&#x2F; type T0 &#x3D; []\n\ntype T1 &#x3D; Parameters&lt;(s: string) &#x3D;&gt; void&gt;;\n&#x2F;&#x2F; type T1 &#x3D; [s: string]\n\ntype T2 &#x3D; Parameters&lt;&lt;T&gt;(arg: T) &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T2 &#x3D; [arg: unknown]\n\ntype T3 &#x3D; Parameters&lt;typeof f1&gt;;\n&#x2F;&#x2F; type T3 &#x3D; [arg: &#123;\n&#x2F;&#x2F;   a: number;\n&#x2F;&#x2F;   b: string;\n&#x2F;&#x2F; &#125;]\n\ntype T4 &#x3D; Parameters&lt;any&gt;;\n&#x2F;&#x2F; type T4 &#x3D; unknown[]\n\ntype T5 &#x3D; Parameters&lt;never&gt;;\n&#x2F;&#x2F; type T5 &#x3D; never\n\ntype T6 &#x3D; Parameters&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T6 &#x3D; never\n\ntype T7 &#x3D; Parameters&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.\n\ntype T7 &#x3D; never;</code></pre>\n\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><ol>\n<li><code>Parameters</code> 首先约束参数 <code>T </code>必须是个函数类型</li>\n<li>判断 <code>T</code> 是否是函数类型，如果是则使用 <code>infer P</code> 暂时存一下函数的参数类型，直接用 P 即可得到这个类型并返回，否则就返回 <code>never</code></li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Parameters&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: infer P) &#x3D;&gt; any ? P : never;</code></pre>\n\n<p>这里用到了<code>infer</code>，<code>infer P</code>标记一个泛型，表示这个泛型是一个待推断的类型，并且可以直接使用。</p>\n<h2 id=\"ConstructorParameters\"><a href=\"#ConstructorParameters\" class=\"headerlink\" title=\"ConstructorParameters\"></a>ConstructorParameters<Type></h2><p><code>构造参数类型</code><br>Released:3.1</p>\n<p>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).<br><code>构造一个从构造函数类型Type中提取的元组或数组类型。如果Type不是函数，则生成never类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype T0 &#x3D; ConstructorParameters&lt;ErrorConstructor&gt;;\n&#x2F;&#x2F; type T0 &#x3D; [message?: string]\n\ntype T1 &#x3D; ConstructorParameters&lt;FunctionConstructor&gt;;\n&#x2F;&#x2F; type T1 &#x3D; string[]\n\ntype T2 &#x3D; ConstructorParameters&lt;RegExpConstructor&gt;;\n&#x2F;&#x2F; type T2 &#x3D; [pattern: string | RegExp, flags?: string]\n\ntype T3 &#x3D; ConstructorParameters&lt;any&gt;;\n&#x2F;&#x2F; type T3 &#x3D; unknown[]\n\ntype T4 &#x3D; ConstructorParameters&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.\n\n&#x2F;&#x2F; type T4 &#x3D; never</code></pre>\n\n<h2 id=\"ReturnType\"><a href=\"#ReturnType\" class=\"headerlink\" title=\"ReturnType\"></a>ReturnType<Type></h2><p>Released:2.8</p>\n<p>Constructs a type consisting of the return type of function Type.<br><code>用于构造一个含有Type函数的返回值的类型。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ndeclare function f1(): &#123; a: number; b: string &#125;;\n\ntype T0 &#x3D; ReturnType&lt;() &#x3D;&gt; string&gt;;\n&#x2F;&#x2F; type T0 &#x3D; string\n\ntype T1 &#x3D; ReturnType&lt;(s: string) &#x3D;&gt; void&gt;;\n&#x2F;&#x2F; type T1 &#x3D; void\n\ntype T2 &#x3D; ReturnType&lt;&lt;T&gt;() &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T2 &#x3D; unknown\n\ntype T3 &#x3D; ReturnType&lt;&lt;T extends U, U extends number[]&gt;() &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T3 &#x3D; number[]\n\ntype T4 &#x3D; ReturnType&lt;typeof f1&gt;;\n&#x2F;&#x2F; type T4 &#x3D; &#123;\n&#x2F;&#x2F; a: number;\n&#x2F;&#x2F; b: string;\n&#x2F;&#x2F; &#125;\n\ntype T5 &#x3D; ReturnType&lt;any&gt;;\n&#x2F;&#x2F; type T5 &#x3D; any\n\ntype T6 &#x3D; ReturnType&lt;never&gt;;\n&#x2F;&#x2F; type T6 &#x3D; never\n\ntype T7 &#x3D; ReturnType&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T7 &#x3D; any\n\ntype T8 &#x3D; ReturnType&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.\n\n&#x2F;&#x2F; type T8 &#x3D; any</code></pre>\n\n<h2 id=\"原理-8\"><a href=\"#原理-8\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>与 Parameters 类似</p>\n<ol>\n<li>ReturnType 首先约束参数 T 必须是个函数类型</li>\n<li>判断 T 是否是函数类型，如果是则使用 infer R 暂时存一下函数的返回值类型，后面的语句直接用 R 即可得到这个类型并返回，否则就返回 any</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;</code></pre>\n\n<h2 id=\"InstanceType\"><a href=\"#InstanceType\" class=\"headerlink\" title=\"InstanceType\"></a>InstanceType<Type></h2><p>Released:2.8</p>\n<p>Constructs a type consisting of the instance type of a constructor function in Type.<br><code>返回构造函数类型T的实例类型</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\nclass C &#123;\n  x &#x3D; 0;\n  y &#x3D; 0;\n&#125;\n\ntype T0 &#x3D; InstanceType&lt;typeof C&gt;;\n&#x2F;&#x2F; type T0 &#x3D; C\n\ntype T1 &#x3D; InstanceType&lt;any&gt;;\n&#x2F;&#x2F; type T1 &#x3D; any\n\ntype T2 &#x3D; InstanceType&lt;never&gt;;\n&#x2F;&#x2F; type T2 &#x3D; never\n\ntype T3 &#x3D; InstanceType&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T3 &#x3D; any\n\ntype T4 &#x3D; InstanceType&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.\n\n&#x2F;&#x2F; type T4 &#x3D; any</code></pre>\n\n<h2 id=\"原理-9\"><a href=\"#原理-9\" class=\"headerlink\" title=\"原理\"></a>原理</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type InstanceType&lt;T extends abstract new (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends abstract new (...args: any) &#x3D;&gt; infer R ? R : any;</code></pre>\n\n<p>与 ResultType 类似</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;</code></pre>\n\n<h2 id=\"ThisParameterType\"><a href=\"#ThisParameterType\" class=\"headerlink\" title=\"ThisParameterType\"></a>ThisParameterType<Type></h2><p>Released:3.3</p>\n<p>Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter.<br><code>用于提取一个函数类型Type的this (opens new window)参数类型，返回unknown (opens new window)如果这个函数类型没有this参数。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\nfunction toHex(this: Number) &#123;\n  return this.toString(16);\n&#125;\n\nfunction numberToString(n: ThisParameterType&lt;typeof toHex&gt;) &#123;\n  return toHex.apply(n);\n&#125;</code></pre>\n\n<h2 id=\"OmitThisParameter\"><a href=\"#OmitThisParameter\" class=\"headerlink\" title=\"OmitThisParameter\"></a>OmitThisParameter<Type></h2><p>Released:3.3</p>\n<p>Removes the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type.</p>\n<ol>\n<li>用于移除一个函数类型 Type 的 this (opens new window)参数类型。</li>\n<li>如果 Type 没有明确的声明 this 类型，那么这个返回的结果就是 Type，</li>\n<li>不然的话，就返回一个新的函数类型，基于 Type，但不再有 this 参数。</li>\n<li>范型会被抹去，只有最后重载的签名被传播进了返回的新的函数类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\nfunction toHex(this: Number) &#123;\n  return this.toString(16);\n&#125;\n\nconst fiveToHex: OmitThisParameter&lt;typeof toHex&gt; &#x3D; toHex.bind(5);\n\nconsole.log(fiveToHex());</code></pre>\n\n<h2 id=\"ThisType\"><a href=\"#ThisType\" class=\"headerlink\" title=\"ThisType\"></a>ThisType<Type></h2><p>Released:2.3</p>\n<p>This utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility.</p>\n<ol>\n<li>这个类型不返回一个转换过的类型，它被用作标记一个上下文的 this 类型。</li>\n<li>想使用这个工具类型，noImplicitThis 必须启用。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; Example\ntype ObjectDescriptor&lt;D, M&gt; &#x3D; &#123;\n  data?: D;\n  methods?: M &amp; ThisType&lt;D &amp; M&gt;; &#x2F;&#x2F; Type of &#39;this&#39; in methods is D &amp; M\n&#125;;\n\nfunction makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M &#123;\n  let data: object &#x3D; desc.data || &#123;&#125;;\n  let methods: object &#x3D; desc.methods || &#123;&#125;;\n  return &#123; ...data, ...methods &#125; as D &amp; M;\n&#125;\n\nlet obj &#x3D; makeObject(&#123;\n  data: &#123; x: 0, y: 0 &#125;,\n  methods: &#123;\n    moveBy(dx: number, dy: number) &#123;\n      this.x +&#x3D; dx; &#x2F;&#x2F; Strongly typed this\n      this.y +&#x3D; dy; &#x2F;&#x2F; Strongly typed this\n    &#125;,\n  &#125;,\n&#125;);\n\nobj.x &#x3D; 10;\nobj.y &#x3D; 20;\nobj.moveBy(5, 5);</code></pre>\n\n<p>In the example above, the methods object in the argument to makeObject has a contextual type that includes ThisType&lt;D &amp; M&gt; and therefore the type of this in methods within the methods object is { x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }. Notice how the type of the methods property simultaneously is an inference target and a source for the this type in methods.<br><code>在上面的示例中，makeObject的参数中的methods对象包含了一个上下文类型，该类型包含了ThisType&lt;D &amp; M&gt;，因此methods对象中的this类型是&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;。请注意，methods属性的类型同时是一个推断目标和一个methods对象中的this类型的源。</code><br>The ThisType<T> marker interface is simply an empty interface declared in lib.d.ts. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.<br><code>ThisType&lt;T&gt;标记接口是在lib.d.ts中声明的空接口。它只是在对象字面量的上下文类型中被识别而已，该接口的行为与空接口一样。</code></p>\n<h2 id=\"Intrinsic-String-Manipulation-Types\"><a href=\"#Intrinsic-String-Manipulation-Types\" class=\"headerlink\" title=\"Intrinsic String Manipulation Types\"></a>Intrinsic String Manipulation Types</h2><p><code>内部字符串操作类型</code><br>Uppercase<StringType><br>Lowercase<StringType><br>Capitalize<StringType><br>Uncapitalize<StringType></p>\n<p>To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the Template Literal Types documentation.<br><code>为了帮助模板字符串操作，TypeScript包含一组可以在字符串操作中使用的类型。你可以在模板字符串类型文档中找到它们。</code></p>\n<h2 id=\"Typescript-中-extends-的作用\"><a href=\"#Typescript-中-extends-的作用\" class=\"headerlink\" title=\"Typescript 中 extends 的作用\"></a>Typescript 中 extends 的作用</h2><h4 id=\"1、接口继承\"><a href=\"#1、接口继承\" class=\"headerlink\" title=\"1、接口继承\"></a>1、接口继承</h4><p>可以继承父类接口的方法和属性</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; dog 具有 Animal 的 name 属性。\nconst dog: Dog &#x3D; &#123;\n  name: &#39;tom&#39;,\n  sayHello: function () &#123;&#125;,\n&#125;;</code></pre>\n\n<h4 id=\"2、普通条件判断\"><a href=\"#2、普通条件判断\" class=\"headerlink\" title=\"2、普通条件判断\"></a>2、普通条件判断</h4><p>用来判断一个类型是否可以分配给另外一个类型</p>\n<p>A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n\nconst dog: Dog &#x3D; &#123;\n  name: &#39;tom&#39;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\ntype bool &#x3D; Animal extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;\ntype bool1 &#x3D; Dog extends Animal ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;</code></pre>\n\n<h4 id=\"3、泛型条件判断\"><a href=\"#3、泛型条件判断\" class=\"headerlink\" title=\"3、泛型条件判断\"></a>3、泛型条件判断</h4><p>对于使用 extends 关键字的条件类型，如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。</p>\n<p>分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</p>\n<p>满足两个要点即可适用分配律：</p>\n<p>参数是泛型类型，</p>\n<p>代入参数的是联合类型<br>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Animal&lt;T&gt; &#x3D; T;\ntype Animal1&lt;T&gt; &#x3D; [T];\ntype Dog &#x3D; Animal&lt;&#39;x&#39; | &#39;y&#39;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;\ntype Dog1 &#x3D; Animal1&lt;&#39;x&#39; | &#39;y&#39;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]\n\ntype A &#x3D; &#39;x&#39; extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;\ntype B &#x3D; &#39;x&#39; extends Dog1 ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;\ntype C &#x3D; [&#39;x&#39; | &#39;y&#39;] extends Dog1 ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;\ntype D &#x3D; &#39;x&#39; | &#39;y&#39; extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; D &#x3D; &#39;yse&#39;</code></pre>\n\n<h4 id=\"4、泛型约束\"><a href=\"#4、泛型约束\" class=\"headerlink\" title=\"4、泛型约束\"></a>4、泛型约束</h4><p>在书写泛型时，往往需要对类型参数作一定对限制。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;\n  return obj[key];\n&#125;\n\nconst obj &#x3D; &#123;\n  name: &#39;tom&#39;,\n  age: 12,\n&#125;;\n\ngetInfo(obj, &#39;age&#39;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html\">typescript handbook utility-types</a><br><a href=\"https://ts.yayujs.com/reference/UtilityTypes.html#intrinsic-string-manipulation-types\">工具类型</a><br><a href=\"https://blog.csdn.net/qq_34998786/article/details/120300361\">Typescript 中的 extends 关键字</a>Exclude 与 Extract 前置学习项<br><a href=\"https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses\">Typescript Classes extends-clauses</a><br><a href=\"https://blog.csdn.net/qq_32438227/article/details/125058423\">彻底搞懂 typescript 工具类型及其原理</a> 该文有错误内容，要注意哦<br><a href=\"https://juejin.cn/post/6844904066485583885\">TypeScript 的 extends 条件类型</a></p>\n","text":"TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.Typescript提供了一些帮...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":13,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Partial\"><span class=\"toc-text\">Partial</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Required\"><span class=\"toc-text\">Required</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-1\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Readonly\"><span class=\"toc-text\">Readonly</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-2\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Record-lt-Keys-Type-gt\"><span class=\"toc-text\">Record&lt;Keys, Type&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-3\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pick-lt-Type-Keys-gt\"><span class=\"toc-text\">Pick&lt;Type, Keys&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-4\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Omit-lt-Type-Keys-gt\"><span class=\"toc-text\">Omit&lt;Type, Keys&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-5\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Exclude-lt-UnionType-ExcludedMembers-gt\"><span class=\"toc-text\">Exclude&lt;UnionType, ExcludedMembers&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-6\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Extract-lt-Type-Union-gt\"><span class=\"toc-text\">Extract&lt;Type, Union&gt;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">原理(注意)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NonNullable\"><span class=\"toc-text\">NonNullable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-7\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Parameters\"><span class=\"toc-text\">Parameters</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">原理：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ConstructorParameters\"><span class=\"toc-text\">ConstructorParameters</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReturnType\"><span class=\"toc-text\">ReturnType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-8\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#InstanceType\"><span class=\"toc-text\">InstanceType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86-9\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ThisParameterType\"><span class=\"toc-text\">ThisParameterType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OmitThisParameter\"><span class=\"toc-text\">OmitThisParameter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ThisType\"><span class=\"toc-text\">ThisType</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Intrinsic-String-Manipulation-Types\"><span class=\"toc-text\">Intrinsic String Manipulation Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Typescript-%E4%B8%AD-extends-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">Typescript 中 extends 的作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">1、接口继承</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%99%AE%E9%80%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">2、普通条件判断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">3、泛型条件判断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">4、泛型约束</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"修补node_modules下源码","uid":"c3d5408da05b02828c848a49ca35cf59","slug":"2022-06-09patch-package","date":"2022-06-09T01:51:48.000Z","updated":"2022-09-16T13:54:56.137Z","comments":true,"path":"api/articles/2022-06-09patch-package.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220609160539.webp","text":"背景之前在简书上记录过，没迁移简书文章，所以重新记录 由于hexo-theme-aurora代码配色不是很友好，需要自定义配色，又不想改其 github 上代码，直接处理node_modules下的配色文件 安装 patch-packagepatch-package 包可以通过 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"npm","slug":"npm","count":5,"path":"api/tags/npm.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"9.Typescript手册 模块","uid":"29a670518a826389296f8915224ed71e","slug":"2022-06-08ts-modules","date":"2022-06-08T14:47:47.000Z","updated":"2022-09-16T14:59:17.127Z","comments":true,"path":"api/articles/2022-06-08ts-modules.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"JavaScript has a long history of different ways to handle modularizing code. TypeScript having been around since 2012, has implemented suppo...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":13,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}