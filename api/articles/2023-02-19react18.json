{"title":"React18 版本主要更新内容","uid":"935f55a55c003dca5fd748af01a100e2","slug":"2023-02-19react18","date":"2023-02-19T11:37:57.000Z","updated":"2023-02-20T21:20:56.497Z","comments":true,"path":"api/articles/2023-02-19react18.json","keywords":null,"cover":null,"content":"<h2 id=\"react-18\"><a href=\"#react-18\" class=\"headerlink\" title=\"react 18\"></a>react 18</h2><ol>\n<li><p>修 bug</p>\n<ol>\n<li>由于并发模式可能带来破坏，所以 react18 的并发模式可选</li>\n<li><code>Suspense fallback=&#123;undefined&#125;</code> 表现与<code>null</code>相同</li>\n</ol>\n</li>\n<li><p>增加开发体验</p>\n<ol>\n<li>自动批处理: 之前需要使用 <code>ReactDOM.unstable_batchedUpdates</code>, 现在： 超时、promise、本机事件处理程序、任何其他事件被批处理</li>\n<li>内置 <code>React.lazy + Suspense</code></li>\n<li><code>useId</code>: 生成唯一 ID</li>\n<li><code>useTransition、useDeferredValue</code>: 将紧急更新与非紧急更新分开</li>\n<li>2 个新的<code>渲染api</code>: <code>createRoot</code> 和 <code>hydrateRoot</code> ：应用的根节点也向我们暴露了出来，渲染整个应用的时候只需要调用 root 的 render 方法</li>\n</ol>\n</li>\n<li><p>为其他框架库提供扩展</p>\n<ol>\n<li><code>useInsertionEffect</code>: 为 CSS-in-JS 库添加</li>\n<li><code>useSyncExternalStore</code>: 帮助外部存储库与 React 集成。</li>\n</ol>\n</li>\n<li><p>为以后做准备</p>\n<ol>\n<li>严格模式模拟卸载和重新挂载</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"New-Feature-Automatic-Batching\"><a href=\"#New-Feature-Automatic-Batching\" class=\"headerlink\" title=\"New Feature: Automatic Batching\"></a>New Feature: Automatic Batching</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">之前：只有React事件被批处理。\nsetTimeout(() &#x3D;&gt; &#123;\n  setCount((c) &#x3D;&gt; c + 1);\n  setFlag((f) &#x3D;&gt; !f);\n  &#x2F;&#x2F; React将渲染两次，每次状态更新一次（无批处理）\n&#125;, 1000);\n\n&#x2F;&#x2F;之后：超时、promise、本机事件处理程序或任何其他事件被批处理\nsetTimeout(() &#x3D;&gt; &#123;\n  setCount((c) &#x3D;&gt; c + 1);\n  setFlag((f) &#x3D;&gt; !f);\n&#x2F;&#x2F; React最后只会重新渲染一次（那是批处理！）\n&#125;, 1000);</code></pre>\n\n<h2 id=\"New-Feature-Transitions\"><a href=\"#New-Feature-Transitions\" class=\"headerlink\" title=\"New Feature: Transitions\"></a>New Feature: Transitions</h2><p>过渡是 React 中的一个新概念，用于区分: 紧急更新和非紧急更新。</p>\n<ol>\n<li>输入、点击或按下等紧急更新需要立即响应，以符合我们对物理对象行为的直觉。否则他们会感到“错误”。</li>\n<li>过渡是不同的，因为用户不期望在屏幕上看到每个中间值。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; startTransition &#125; from &quot;react&quot;;\n\n&#x2F;&#x2F; Urgent: Show what was typed\nsetInputValue(input);\n\n&#x2F;&#x2F; Mark any state updates inside as transitions\nstartTransition(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; Transition: Show the results\n  setSearchQuery(input);\n&#125;);</code></pre>\n\n<h2 id=\"New-Suspense-Features\"><a href=\"#New-Suspense-Features\" class=\"headerlink\" title=\"New Suspense Features\"></a>New Suspense Features</h2><p>Suspense 允许您以声明方式指定组件树的一部分的加载状态，如果它还没有准备好显示</p>\n<ol>\n<li><code>之前版本</code>：<code>可以使用 Suspense 在客户端进行代码拆分 React.lazy</code>.</li>\n<li><code>现在版本</code>：<code>Suspense</code>支持数据请求</li>\n<li><code>未来版本</code>：<code>Suspense callback</code>可以处理任何异步操作（<code>加载代码、数据、图像</code>等）。</li>\n</ol>\n<h2 id=\"New-Client-and-Server-Rendering-APIs\"><a href=\"#New-Client-and-Server-Rendering-APIs\" class=\"headerlink\" title=\"New Client and Server Rendering APIs\"></a>New Client and Server Rendering APIs</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; createRoot: ReactDOM.render;\n&#x2F;&#x2F; hydrateRoot: ReactDOM.hydrate;</code></pre>\n\n<h2 id=\"新的严格模式行为\"><a href=\"#新的严格模式行为\" class=\"headerlink\" title=\"新的严格模式行为\"></a>新的严格模式行为</h2><p>将来，我们想添加一个功能，允许 React 在保留状态的同时添加和删除 UI 的部分。</p>\n<p>例如，当用户离开屏幕并返回时，React 应该能够立即显示上一个屏幕。为此，React 将使用与以前相同的组件状态卸载和重新挂载树。</p>\n<p>此功能将为 React 应用程序提供开箱即用的更好性能，但需要组件对多次挂载和销毁的效果具有弹性。</p>\n<p>大多数效果无需任何更改即可工作，但有些效果假设它们只挂载或销毁一次。</p>\n<h3 id=\"在此更改之前，React-会挂载组件并创建效果：\"><a href=\"#在此更改之前，React-会挂载组件并创建效果：\" class=\"headerlink\" title=\"在此更改之前，React 会挂载组件并创建效果：\"></a>在此更改之前，React 会挂载组件并创建效果：</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; * React mounts the component.\n&#x2F;&#x2F;    * Layout effects are created.\n&#x2F;&#x2F;    * Effects are created.\n\n&#x2F;&#x2F; 使用React 18中的严格模式，React将在开发模式下模拟卸载和重新挂载组件：\n\n&#x2F;&#x2F; * React mounts the component. [挂在组件]\n&#x2F;&#x2F;   * Layout effects are created.\n&#x2F;&#x2F;   * Effects are created.\n&#x2F;&#x2F; * React simulates unmounting the component.【模拟卸载组件】\n&#x2F;&#x2F;   * Layout effects are destroyed.\n&#x2F;&#x2F;   * Effects are destroyed.\n&#x2F;&#x2F; * React simulates mounting the component with the previous state.【使用先前状态，模拟组件挂载】\n&#x2F;&#x2F;   * Layout effects are created.\n&#x2F;&#x2F;   * Effects are created.</code></pre>\n\n<h2 id=\"新的-hooks-amp-other\"><a href=\"#新的-hooks-amp-other\" class=\"headerlink\" title=\"新的 hooks &amp; other\"></a>新的 hooks &amp; other</h2><ol>\n<li><code>useId</code>: 添加 useId 以生成唯一 ID</li>\n<li><code>useTransition、useDeferredValue</code>: 添加 useTranption 和 useDeferredValue 以将紧急更新与转换分开</li>\n<li><code>useInsertionEffect</code>: 为 CSS-in-JS 库添加 useInsertionEffects</li>\n<li><code>useSyncExternalStore</code>: 添加 useSyncExternalStore 以帮助外部存储库与 React 集成。</li>\n<li><code>StrictMode</code>: 使<code>&lt;StrictMode&gt;</code>重新运行效果以检查可恢复状态。</li>\n<li><code>Suspense fallback=&#123;undefined&#125;</code> 表现与<code>null</code>相同.</li>\n</ol>\n","text":"react 18 修 bug 由于并发模式可能带来破坏，所以 react18 的并发模式可选 Suspense fallback=&#123;undefined&#125; 表现与null相同 增加开发体验 自动批处理: 之前需要使用 ReactDOM.unstable_batc...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":34,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":28,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-18\"><span class=\"toc-text\">react 18</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#New-Feature-Automatic-Batching\"><span class=\"toc-text\">New Feature: Automatic Batching</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#New-Feature-Transitions\"><span class=\"toc-text\">New Feature: Transitions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#New-Suspense-Features\"><span class=\"toc-text\">New Suspense Features</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#New-Client-and-Server-Rendering-APIs\"><span class=\"toc-text\">New Client and Server Rendering APIs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">新的严格模式行为</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E6%AD%A4%E6%9B%B4%E6%94%B9%E4%B9%8B%E5%89%8D%EF%BC%8CReact-%E4%BC%9A%E6%8C%82%E8%BD%BD%E7%BB%84%E4%BB%B6%E5%B9%B6%E5%88%9B%E5%BB%BA%E6%95%88%E6%9E%9C%EF%BC%9A\"><span class=\"toc-text\">在此更改之前，React 会挂载组件并创建效果：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%9A%84-hooks-amp-other\"><span class=\"toc-text\">新的 hooks &amp; other</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"性能优化-Preload, Prefetch And Priorities in Chrome","uid":"18f2de6f6ea6d59c8b217d81ff25660d","slug":"2023-02-20priorities","date":"2023-02-20T10:13:09.000Z","updated":"2023-02-20T21:20:56.497Z","comments":true,"path":"api/articles/2023-02-20priorities.json","keywords":null,"cover":"https://miro.medium.com/v2/resize:fit:720/format:webp/1*W4_tAMHlFs6tunMxbXQjFA.png","text":"Preload, Prefetch 是如何工作的深入了解 Chrome 网络堆栈的见解，以清楚地了解 Web 加载原语（如&lt;link rel=&quot;preload&quot;&gt;和&lt;link rel=&quot;prefetch&quot;&gt;）如何在幕...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"RN performance","uid":"a625702239d2378e2ca779050afa4d60","slug":"2023-02-19rn-performance","date":"2023-02-19T09:11:10.000Z","updated":"2023-02-20T21:20:56.497Z","comments":true,"path":"api/articles/2023-02-19rn-performance.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202302171928314.webp","text":"bundle 优化bundle 优化速览 环境预创建 异步检测、下载 公用资源拆包 按需加载 新版本 一、React Native 环境预创建一个载体页一个引擎。 通常，一个 React Native 页面从加载渲染到展示大致分为以下几步： 【React Native 环境初始化...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"react-native","slug":"react-native","count":4,"path":"api/categories/react-native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":4,"path":"api/tags/react-native.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}