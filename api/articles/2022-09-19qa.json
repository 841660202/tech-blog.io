{"title":"前端基础-qa","uid":"d55ac1d91034293bfc294fd694ca97c4","slug":"2022-09-19qa","date":"2022-09-18T09:13:05.000Z","updated":"2022-09-20T13:37:06.279Z","comments":true,"path":"api/articles/2022-09-19qa.json","keywords":null,"cover":[],"content":"<h2 id=\"var-let-const-区别：\"><a href=\"#var-let-const-区别：\" class=\"headerlink\" title=\"var let const 区别：\"></a>var let const 区别：</h2><ol>\n<li>版本： var 是 es6 之前， const、let es6 之后，</li>\n<li>分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域</li>\n<li>提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使用会报错</li>\n<li>重复：var 可以重复声明、重复赋值，let 不可以重复声明，单可重复赋值，const 不可重复声明和赋值</li>\n<li>存储：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li>\n<li>默认： 默认情况下是 var 声明</li>\n<li>函数：函数声明提升优先于 var</li>\n</ol>\n<h2 id=\"作用域：\"><a href=\"#作用域：\" class=\"headerlink\" title=\"作用域：\"></a>作用域：</h2><h3 id=\"什么是执行上下文？\"><a href=\"#什么是执行上下文？\" class=\"headerlink\" title=\"什么是执行上下文？\"></a>什么是执行上下文？</h3><p>当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。<br>分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。</p>\n<p><code>全局上下文：</code>默认&#x2F;基础的上下文，任何不在函数内部的代码都在全局上下文中，一个程序中只有一个全局执行上下文</p>\n<p><code>函数执行上下文</code>：一个函数被调用时，会为该函数创建一个上下文，每个函数都有自己的函数上下文，函数上下文可以有任意多个</p>\n<p><code>eval上下文</code>：执行在 eval 函数内部的代码也会有属于它自己的执行上下文</p>\n<h3 id=\"什么是词法环境？\"><a href=\"#什么是词法环境？\" class=\"headerlink\" title=\"什么是词法环境？\"></a>什么是词法环境？</h3><h3 id=\"什么是作用域？\"><a href=\"#什么是作用域？\" class=\"headerlink\" title=\"什么是作用域？\"></a>什么是作用域？</h3><p>通俗点来讲就是：指变量的可使用范围</p>\n<p>一般有三种作用域：全局作用域、函数作用域、块级作用域</p>\n<p>全局作用域：声明的变量，全局可见<br>函数作用域：声明的变量在当前函数内部可见<br>块级作用域：{},条件语句，循环语句中</p>\n<h3 id=\"什么是作用域链？\"><a href=\"#什么是作用域链？\" class=\"headerlink\" title=\"什么是作用域链？\"></a>什么是作用域链？</h3><p>由于函数嵌套，一个变量在当前函数作用域找不到，会往上找，直到全局作用域，这种作用域嵌套的现象；由内向外，一层一层往上的链式规则，这就是作用域链</p>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"什么是原型\"><a href=\"#什么是原型\" class=\"headerlink\" title=\"什么是原型\"></a>什么是原型</h3><p>js 面向对象编程的实现</p>\n<p>在 JavaScript 中原型是一个 prototype 对象，用于表示类型之间的关系。</p>\n<p>每一个对象都与另一个对象相关联，那个关联的对象就称为原型</p>\n<h3 id=\"为什么使用原型\"><a href=\"#为什么使用原型\" class=\"headerlink\" title=\"为什么使用原型\"></a>为什么使用原型</h3><p>原型对象的用途： 是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。</p>\n<p>所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。</p>\n<h3 id=\"原型分类\"><a href=\"#原型分类\" class=\"headerlink\" title=\"原型分类\"></a>原型分类</h3><p>显示原型和隐式原型</p>\n<p>显示原型： prototype 关键字标识<br>隐式原型： <code>__proto__</code>表示<br>一个构造函数显示原型 &#x3D;&#x3D;&#x3D; 该构造函数一个实例的隐式原型 即： （构造函数.<code>prototype</code> &#x3D;&#x3D;&#x3D; 构造函数实例.<code>__proto__</code>）</p>\n<h3 id=\"什么是原型链\"><a href=\"#什么是原型链\" class=\"headerlink\" title=\"什么是原型链\"></a>什么是原型链</h3><ol>\n<li>每个实例对象的<code>__proto__</code>​ 属性, 指向它的构造函数的原型对象（<code>prototype</code>）。</li>\n<li>该原型对象也有一个自己的原型对象（<code>__proto__</code>​），层层向上直到一个对象的原型对象为 <code>null</code>​。</li>\n<li>根据定义，<code>null</code>​ 没有原型，并作为这个原型链中的最后一个环节</li>\n</ol>\n<p>简单来说，原型链是： 一个对象 找原型对象 的依据</p>\n<p><a href=\"https://www.51cto.com/article/718086.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"创建对象的几种方式\"><a href=\"#创建对象的几种方式\" class=\"headerlink\" title=\"创建对象的几种方式\"></a>创建对象的几种方式</h3><ul>\n<li>对象字面量</li>\n<li>构造函数</li>\n<li>new 关键字</li>\n<li>Object.create</li>\n<li>class</li>\n</ul>\n<h3 id=\"Number、Boolean-包装类型的原型链是怎样的？\"><a href=\"#Number、Boolean-包装类型的原型链是怎样的？\" class=\"headerlink\" title=\"Number、Boolean 包装类型的原型链是怎样的？\"></a>Number、Boolean 包装类型的原型链是怎样的？</h3><h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><h3 id=\"实例与构造函数之间的关系\"><a href=\"#实例与构造函数之间的关系\" class=\"headerlink\" title=\"实例与构造函数之间的关系\"></a>实例与构造函数之间的关系</h3><p>实例.<code>__proto__</code> &#x3D;&#x3D;&#x3D; 该实例的构造函数.<code>prototype</code></p>\n<h3 id=\"ES6-语法中的-class、extends-与-super-的原理\"><a href=\"#ES6-语法中的-class、extends-与-super-的原理\" class=\"headerlink\" title=\"ES6 语法中的 class、extends 与 super 的原理\"></a>ES6 语法中的 class、extends 与 super 的原理</h3><h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><h3 id=\"聊下-this-指向问题\"><a href=\"#聊下-this-指向问题\" class=\"headerlink\" title=\"聊下 this 指向问题\"></a>聊下 this 指向问题</h3><p>以下皆对普通函数而言，箭头函数可不是这么玩的</p>\n<h3 id=\"为什要有-this\"><a href=\"#为什要有-this\" class=\"headerlink\" title=\"为什要有 this\"></a>为什要有 this</h3><p>this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。</p>\n<p>简单来说：this,被放到作用域中， 为了简化代码</p>\n<h3 id=\"this-是如何定义的\"><a href=\"#this-是如何定义的\" class=\"headerlink\" title=\"this 是如何定义的\"></a>this 是如何定义的</h3><p>简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的</p>\n<p>我们简单总结一下 this 的特点：</p>\n<ul>\n<li>this 是在运行时绑定的，不是在编写时绑定</li>\n<li>this 的绑定与函数的声明和位置没有任何关系</li>\n<li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。</li>\n</ul>\n<p>所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</p>\n<p>简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>\n<h3 id=\"this-绑定规则\"><a href=\"#this-绑定规则\" class=\"headerlink\" title=\"this 绑定规则\"></a>this 绑定规则</h3><p>判断函数调用时是否使用了 new，即 new 绑定，如果使用了，则 this 绑定的是新创建的对象。<br>函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。<br>函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。<br>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，在严格模式下，默认绑定的 this 是 undefined，非严格模式下绑定到全局对象。</p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7115390077353590792\">https://juejin.cn/post/7115390077353590792</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"this-绑定的优先级\"><a href=\"#this-绑定的优先级\" class=\"headerlink\" title=\"this 绑定的优先级\"></a>this 绑定的优先级</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定</code></pre>\n\n<h2 id=\"new-做了哪些事情\"><a href=\"#new-做了哪些事情\" class=\"headerlink\" title=\"new 做了哪些事情\"></a>new 做了哪些事情</h2><p>1、创建一个空对象；</p>\n<p>2、将空对象的原型，指向于构造函数的原型；</p>\n<p>3、将空对象作为构造函数的上下文（改变 this 指向）；</p>\n<p>4、对有返回值的构造函数做判断处理</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;定义构造函数\nfunction Fun(age, name) &#123;\n  this.age &#x3D; age;\n  this.name &#x3D; name;\n  return 1;\n&#125;\n\nfunction myNew(fn, ...args) &#123;\n  &#x2F;&#x2F;1、先创造空对象\n  &#x2F;&#x2F;其实等于var obj &#x3D; Object.create(&#123;&#125;)\n  var obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F;2、obj的__proto__指向原型\n  Object.setPrototypeOf(obj, fn.prototype);\n  &#x2F;&#x2F;3、改变this指向，执行构造函数内部函数\n  var result &#x3D; fn.apply(obj, args);\n  &#x2F;&#x2F;4、判断return\n  return result instanceof Object ? result : obj;\n&#125;</code></pre>\n\n<p><a href=\"cnblogs.com/jacky02/p/16048701.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;</code></pre>\n\n<h3 id=\"Object-create-与-new-的区别\"><a href=\"#Object-create-与-new-的区别\" class=\"headerlink\" title=\"Object.create 与 new 的区别\"></a>Object.create 与 new 的区别</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; new Object() 方式创建\nvar obj &#x3D; &#123; name: &quot;jack&quot; &#125;;\nvar b &#x3D; new Object(obj);\nconsole.log(b.name);\nconsole.log(b.__proto__.name); &#x2F;&#x2F;undefined\n\n&#x2F;&#x2F; Object.create() 方式创建\nvar obj2 &#x3D; &#123; name: &quot;apple&quot; &#125;;\nvar c &#x3D; Object.create(obj2);\nconsole.log(c.name);\nconsole.log(c.__proto__.name); &#x2F;&#x2F;apple</code></pre>\n\n<p>new 出来的 b 对象，通过原型链无法访问到 name 属性，而 Object.create 出来的 c 却可以</p>\n<h2 id=\"箭头函数与普通函数区别\"><a href=\"#箭头函数与普通函数区别\" class=\"headerlink\" title=\"箭头函数与普通函数区别\"></a>箭头函数与普通函数区别</h2><ol>\n<li>使用简单：箭头函数使用起来简单，更适合匿名函数，比较特殊的对象方法，可以简写(){},这个不是箭头函数</li>\n<li>箭头函数没有自己的 this, arguments, super, new.target,</li>\n<li>基于此：箭头函数不适用于构造函数、new、yeild 等场合</li>\n<li>在 apply,call,bind 中第一个参数会被忽略</li>\n<li>具名箭头函数可以用 var let const , 普通函数除这些之外还可用 function 关键字</li>\n<li>普通函数可以声明立即执行函数，箭头函数不可</li>\n<li>箭头函数没有 arguments，可以使用…rest, （这里有个注意的点：普通函数 arguments，在非严格模式下，有默认参数、剩余参数和结构赋值的情况会出现： arguments 与形参不一致的情况）</li>\n<li>箭头函数无 prototype 属性</li>\n<li>在使用短路运算符的时候，箭头函数要用()括起来，否则因解析顺序导致错误</li>\n</ol>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p><code>背景</code>：js 是单线程的，同一时间 dom 的操作不允许并行</p>\n<p><code>出现的原因</code>：单线程，如果出现耗时的情况会一直等待，以浏览器为例： 浏览器分为 5 大线程，定时器线程和网络线程</p>\n<p><code>解决了什么问题</code>：在单线程中，可以跳过一些耗时的操作，先去做其他的事情，待到需要执行的时候，再执行，而这一策略被称为 事件循环</p>\n<p><code>执行过程：</code> <code>宿主环境</code>：以浏览器环境来说</p>\n<ol>\n<li>在 javascript 中，将任务放到执行栈中执行，执行完成的会出栈；未执行的会依次压入栈底，</li>\n<li>先执行同步任务（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部），直至同步任务都被执行完</li>\n<li>然后执行微任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）直至微任务队列都被执行完</li>\n<li>然后执行宏任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）</li>\n<li>会再去检测微任务队列，之后，再以相同的方式去执行宏任务队列</li>\n</ol>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h2 id=\"类-class\"><a href=\"#类-class\" class=\"headerlink\" title=\"类 class\"></a>类 class</h2><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><h4 id=\"通过构造函数\"><a href=\"#通过构造函数\" class=\"headerlink\" title=\"通过构造函数\"></a>通过构造函数</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  constructor() &#123;\n    console.log(&quot;this&quot;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h4 id=\"通过静态方法\"><a href=\"#通过静态方法\" class=\"headerlink\" title=\"通过静态方法\"></a>通过静态方法</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"编程方法论\"><a href=\"#编程方法论\" class=\"headerlink\" title=\"编程方法论\"></a>编程方法论</h2><h3 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h3><h3 id=\"什么是面向对象编程\"><a href=\"#什么是面向对象编程\" class=\"headerlink\" title=\"什么是面向对象编程\"></a>什么是面向对象编程</h3><h3 id=\"什么是面向过程编程\"><a href=\"#什么是面向过程编程\" class=\"headerlink\" title=\"什么是面向过程编程\"></a>什么是面向过程编程</h3><h2 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h2><h3 id=\"type-与-interface-的区别\"><a href=\"#type-与-interface-的区别\" class=\"headerlink\" title=\"type 与 interface 的区别\"></a>type 与 interface 的区别</h3><p><a href=\"https://www.51cto.com/article/705857.html\" target=\"_blank\" >见</a><br><a href=\"https://juejin.cn/post/6844903749501059085\" target=\"_blank\" >见</a></p>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><ol>\n<li>都可以描述一个对象或者函数</li>\n<li>都允许拓展（extends） interface 继承使用 <code>extends关键字</code> ， type 继承使用 <code>&amp;</code>关键字</li>\n</ol>\n<ul>\n<li><code>interface extends interface</code></li>\n<li><code>interface extends type</code></li>\n<li><code>type extends interface</code></li>\n<li><code>type extends type</code></li>\n</ul>\n<p>不同点</p>\n<ul>\n<li>type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</li>\n<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</li>\n<li>interface 能够声明合并 (type 不可以)</li>\n</ul>\n<h4 id=\"描述上：1-都可以描述一个对象或者函数\"><a href=\"#描述上：1-都可以描述一个对象或者函数\" class=\"headerlink\" title=\"描述上：1. 都可以描述一个对象或者函数\"></a>描述上：1. 都可以描述一个对象或者函数</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; interface\ninterface User &#123;\n  name: string\n  age: number\n&#125;\n\ninterface SetUser &#123;\n  (name: string, age: number): void;\n&#125;\n\n&#x2F;&#x2F; type\n\ntype User &#x3D; &#123;\n  name: string\n  age: number\n&#125;;\n\ntype SetUser &#x3D; (name: string, age: number)&#x3D;&gt; void;\n</code></pre>\n\n<h4 id=\"扩展上：-2-都允许拓展（extends\"><a href=\"#扩展上：-2-都允许拓展（extends\" class=\"headerlink\" title=\"扩展上： 2. 都允许拓展（extends\"></a>扩展上： 2. 都允许拓展（extends</h4><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ntype User &#x3D; Name &amp; &#123; age: number &#125;;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ntype User &#x3D; Name &amp; &#123;\n  age: number;\n&#125;;</code></pre>\n\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><h4 id=\"1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以\"><a href=\"#1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以\" class=\"headerlink\" title=\"1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)\"></a>1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基本类型别名\ntype Name &#x3D; string;\n\n&#x2F;&#x2F; 联合类型\ninterface Dog &#123;\n  wong();\n&#125;\ninterface Cat &#123;\n  miao();\n&#125;\n\ntype Pet &#x3D; Dog | Cat;\n\n&#x2F;&#x2F; 具体定义数组每个位置的类型\ntype PetList &#x3D; [Dog, Pet];</code></pre>\n\n<h4 id=\"2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以\"><a href=\"#2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以\" class=\"headerlink\" title=\"2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)\"></a>2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 当你想获取一个变量的类型时，使用 typeof\nlet div &#x3D; document.createElement(&quot;div&quot;);\ntype B &#x3D; typeof div;</code></pre>\n\n<p>其他骚操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type StringOrNumber &#x3D; string | number;\ntype Text &#x3D; string | &#123; text: string &#125;;\ntype NameLookup &#x3D; Dictionary&lt;string, Person&gt;;\ntype Callback&lt;T&gt; &#x3D; (data: T) &#x3D;&gt; void;\ntype Pair&lt;T&gt; &#x3D; [T, T];\ntype Coordinates &#x3D; Pair&lt;number&gt;;\ntype Tree&lt;T&gt; &#x3D; T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;\n</code></pre>\n\n<h4 id=\"interface-能够声明合并-type-不行\"><a href=\"#interface-能够声明合并-type-不行\" class=\"headerlink\" title=\"interface 能够声明合并(type 不行)\"></a>interface 能够声明合并(type 不行)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface User &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface User &#123;\n  sex: string;\n&#125;\n\n&#x2F;*\nUser 接口为 &#123;\n  name: string\n  age: number\n  sex: string\n&#125;\n*&#x2F;</code></pre>\n<h2 id=\"Typescript-中-extends-的作用\"><a href=\"#Typescript-中-extends-的作用\" class=\"headerlink\" title=\"Typescript 中 extends 的作用\"></a>Typescript 中 extends 的作用</h2><h4 id=\"1、接口继承\"><a href=\"#1、接口继承\" class=\"headerlink\" title=\"1、接口继承\"></a>1、接口继承</h4><p>可以继承父类接口的方法和属性</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; dog 具有 Animal 的 name 属性。\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;</code></pre>\n\n<h4 id=\"2、普通条件判断\"><a href=\"#2、普通条件判断\" class=\"headerlink\" title=\"2、普通条件判断\"></a>2、普通条件判断</h4><p>用来判断一个类型是否可以分配给另外一个类型</p>\n<p>A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\ntype bool &#x3D; Animal extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;\ntype bool1 &#x3D; Dog extends Animal ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;</code></pre>\n\n<h4 id=\"3、泛型条件判断\"><a href=\"#3、泛型条件判断\" class=\"headerlink\" title=\"3、泛型条件判断\"></a>3、泛型条件判断</h4><p>对于使用 extends 关键字的条件类型，如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。</p>\n<p>分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</p>\n<p>满足两个要点即可适用分配律：</p>\n<p>参数是泛型类型，</p>\n<p>代入参数的是联合类型<br>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Animal&lt;T&gt; &#x3D; T;\ntype Animal1&lt;T&gt; &#x3D; [T];\ntype Dog &#x3D; Animal&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;\ntype Dog1 &#x3D; Animal1&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]\n\ntype A &#x3D; &quot;x&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;\ntype B &#x3D; &quot;x&quot; extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;\ntype C &#x3D; [&quot;x&quot; | &quot;y&quot;] extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;\ntype D &#x3D; &quot;x&quot; | &quot;y&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; D &#x3D; &#39;yse&#39;</code></pre>\n\n<h4 id=\"4、泛型约束\"><a href=\"#4、泛型约束\" class=\"headerlink\" title=\"4、泛型约束\"></a>4、泛型约束</h4><p>在书写泛型时，往往需要对类型参数作一定对限制。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;\n  return obj[key];\n&#125;\n\nconst obj &#x3D; &#123;\n  name: &quot;tom&quot;,\n  age: 12,\n&#125;;\n\ngetInfo(obj, &quot;age&quot;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。</code></pre>\n\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><h3 id=\"聊下-key\"><a href=\"#聊下-key\" class=\"headerlink\" title=\"聊下 key\"></a>聊下 key</h3><h4 id=\"为什么引入-key\"><a href=\"#为什么引入-key\" class=\"headerlink\" title=\"为什么引入 key\"></a>为什么引入 key</h4><p><strong>key 帮助 React 识别出被修改、添加或删除的 item</strong></p>\n<p>在对子节点进行递归时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。在子元素列表末尾新增元素时，更新开销比较小。</p>\n<p>React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。</p>\n<p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。</p>\n<p>React 并不会意识到应该保留 <li>Duke</li> 和 <li>Villanova</li>，而是会重建每一个子元素。这种情况会带来性能问题。</p>\n<p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。使得树的转换效率得以提高：</p>\n<p>现在 React 知道只有带着 ‘2014’ key 的元素是新元素，带着 ‘2015’ 以及 ‘2016’ key 的元素仅仅移动了。</p>\n<p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p>\n<h4 id=\"key-有什么要求\"><a href=\"#key-有什么要求\" class=\"headerlink\" title=\"key 有什么要求\"></a>key 有什么要求</h4><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p>\n<h4 id=\"通常情况-key-不会用-index\"><a href=\"#通常情况-key-不会用-index\" class=\"headerlink\" title=\"通常情况 key 不会用 index\"></a>通常情况 key 不会用 index</h4><p>原因：</p>\n<ol>\n<li><p>使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。</p>\n</li>\n<li><p>由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，</p>\n</li>\n</ol>\n<h4 id=\"什么时候使用-key\"><a href=\"#什么时候使用-key\" class=\"headerlink\" title=\"什么时候使用 key\"></a>什么时候使用 key</h4><ol>\n<li>子元素列表时候需要用 key</li>\n<li>同级元素比如两个按钮，在使用三目运算符进行条件处理时候，也需要加 key，不加会出现，按钮事件被错误触发的现象，（这是由于 React 可中断渲染和合成事件共同作用引起的）</li>\n</ol>\n<h4 id=\"key-在源码单节点、多节点中的\"><a href=\"#key-在源码单节点、多节点中的\" class=\"headerlink\" title=\"key 在源码单节点、多节点中的\"></a>key 在源码单节点、多节点中的</h4><h3 id=\"diff-单节点、多节点\"><a href=\"#diff-单节点、多节点\" class=\"headerlink\" title=\"diff [单节点、多节点]\"></a>diff [单节点、多节点]</h3><h3 id=\"hooks-产生的原因\"><a href=\"#hooks-产生的原因\" class=\"headerlink\" title=\"hooks 产生的原因\"></a>hooks 产生的原因</h3><p>Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题</p>\n<h4 id=\"在组件之间复用状态逻辑很难\"><a href=\"#在组件之间复用状态逻辑很难\" class=\"headerlink\" title=\"在组件之间复用状态逻辑很难\"></a><code>在组件之间复用状态逻辑很难</code></h4><h4 id=\"复杂组件变得难以理解\"><a href=\"#复杂组件变得难以理解\" class=\"headerlink\" title=\"复杂组件变得难以理解\"></a><code>复杂组件变得难以理解</code></h4><p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。）</p>\n<h4 id=\"难以理解的-class\"><a href=\"#难以理解的-class\" class=\"headerlink\" title=\"难以理解的 class\"></a><code>难以理解的 class</code></h4><p>(除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。)</p>\n<h3 id=\"useEffect-执行特点\"><a href=\"#useEffect-执行特点\" class=\"headerlink\" title=\"useEffect 执行特点\"></a>useEffect 执行特点</h3><h4 id=\"1-useEffect-做了什么？\"><a href=\"#1-useEffect-做了什么？\" class=\"headerlink\" title=\"1. useEffect 做了什么？\"></a>1. useEffect 做了什么？</h4><p>(<br>通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。<br>)</p>\n<h4 id=\"2-为什么在组件内部调用-useEffect？\"><a href=\"#2-为什么在组件内部调用-useEffect？\" class=\"headerlink\" title=\"2. 为什么在组件内部调用 useEffect？\"></a>2. 为什么在组件内部调用 useEffect？</h4><p>(<br>将 useEffect 放在组件内部,让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。<br>)</p>\n<h4 id=\"3-useEffect-会在每次渲染后都执行吗？\"><a href=\"#3-useEffect-会在每次渲染后都执行吗？\" class=\"headerlink\" title=\"3. useEffect 会在每次渲染后都执行吗？\"></a>3. useEffect 会在每次渲染后都执行吗？</h4><p>(<br>是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。<br>)</p>\n<h4 id=\"4-传递给-useEffect-的函数在每次渲染中都会有所不同\"><a href=\"#4-传递给-useEffect-的函数在每次渲染中都会有所不同\" class=\"headerlink\" title=\"4. 传递给 useEffect 的函数在每次渲染中都会有所不同\"></a>4. 传递给 useEffect 的函数在每次渲染中都会有所不同</h4><p>(<br>经验丰富的 JavaScript 开发人员可能会注意到，传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。<br>)</p>\n<h4 id=\"5-effect-异步执行\"><a href=\"#5-effect-异步执行\" class=\"headerlink\" title=\"5. effect 异步执行\"></a>5. effect 异步执行</h4><p>不需要同步地执行, 如果需要同步用 <code>useLayoutEffect</code></p>\n<h4 id=\"6-为什么要在-effect-中返回一个函数？\"><a href=\"#6-为什么要在-effect-中返回一个函数？\" class=\"headerlink\" title=\"6. 为什么要在 effect 中返回一个函数？\"></a>6. 为什么要在 effect 中返回一个函数？</h4><p>(<br>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。<br>)</p>\n<h4 id=\"7-React-何时清除-effect？\"><a href=\"#7-React-何时清除-effect？\" class=\"headerlink\" title=\"7. React 何时清除 effect？\"></a>7. React 何时清除 effect？</h4><p>(<br>React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。<br>)</p>\n<h3 id=\"useEffect-使用特点上？\"><a href=\"#useEffect-使用特点上？\" class=\"headerlink\" title=\"useEffect 使用特点上？\"></a>useEffect 使用特点上？</h3><ul>\n<li><p>提示: 使用多个 Effect 实现关注点分离</p>\n</li>\n<li><p>解释：为什么每次更新的时候都要运行 Effect(此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug。)</p>\n</li>\n<li><p>提示: 通过跳过 Effect 进行性能优化（使用第二参数，未来版本，可能会在构建时自动添加第二个参数。）</p>\n</li>\n</ul>\n<h3 id=\"useEffect-实现原理\"><a href=\"#useEffect-实现原理\" class=\"headerlink\" title=\"useEffect 实现原理\"></a>useEffect 实现原理</h3><h3 id=\"Hook-使用规则\"><a href=\"#Hook-使用规则\" class=\"headerlink\" title=\"Hook 使用规则\"></a>Hook 使用规则</h3><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>\n<p>只能<code>在函数最外层调用 Hook</code>。<code>不要在循环</code>、<code>条件判断</code>或者<code>子函数中调用</code>。</p>\n<p><code>只能在 React 的函数组件中调用 Hook</code>。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）</p>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><h3 id=\"父子组件生命周期函数执行顺序：\"><a href=\"#父子组件生命周期函数执行顺序：\" class=\"headerlink\" title=\"父子组件生命周期函数执行顺序：\"></a>父子组件生命周期函数执行顺序：</h3><p>父子组件生命周期函数执行顺序：</p>\n<p><strong>类组件</strong></p>\n<p>进入页面：parent-constructor -&gt; parent-getDerivedStateFromProps -&gt; parent-render -&gt; child-constructor -&gt; child-getDerivedStateFromProps -&gt; child-render -&gt; child-componentDidMount -&gt; parent-componentDidMount<br>（子组件先挂载，父组件后挂载）</p>\n<p>更新页面：parent-getDerivedStateFromProps -&gt; parent-shouldComponentUpdate -&gt; parent-render -&gt; child-getDerivedStateFromProps -&gt; child-shouldComponentUpdate -&gt; child-render -&gt; child-componentDidUpdate -&gt; parent-componentDidUpdate<br>（子组件先更新，父组件后更新）<br>销毁页面：parent-componentWillUnmount -&gt; child-componentWillUnmount<br>（父组件先 willUnmount，子组件后 willlUnmount）</p>\n<p><a href=\"https://www.cnblogs.com/foreveronlymiss/p/15387022.html\" target=\"_blank\" >见</a></p>\n<p><strong>函数组件</strong></p>\n<p>子组件先于父组件</p>\n<p><a href=\"https://blog.csdn.net/qq_35770417/article/details/120706178\" target=\"_blank\" >见</a></p>\n<h3 id=\"StrictMode\"><a href=\"#StrictMode\" class=\"headerlink\" title=\"StrictMode\"></a>StrictMode</h3><p>用来突出显示应用程序中潜在问题的工具,不会渲染任何可见的 UI,它为其后代元素触发额外的检查和警告(<span style=\"color: red\">严格模式检查仅在开发模式下运行；它们不会影响生产构建。</span>)</p>\n<p>作用：</p>\n<ul>\n<li>识别不安全的生命周期（使用了第三方库，很难确保它们不使用这些生命周期方法）</li>\n<li>使用过时字符串 ref API 的警告</li>\n<li>检测过时的 context API</li>\n<li>使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>确保可复用状态（在未来，我们希望增加一个功能，允许 React 在保留 state 的同时对 UI 进行增删）</li>\n</ul>\n<h3 id=\"协调\"><a href=\"#协调\" class=\"headerlink\" title=\"协调\"></a>协调</h3><p>当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。</p>\n<h3 id=\"合成事件的捕获和冒泡如何实现\"><a href=\"#合成事件的捕获和冒泡如何实现\" class=\"headerlink\" title=\"合成事件的捕获和冒泡如何实现\"></a>合成事件的捕获和冒泡如何实现</h3><p>数组正反序遍历</p>\n<h3 id=\"父子组件合成事件的捕获和冒泡执行顺序\"><a href=\"#父子组件合成事件的捕获和冒泡执行顺序\" class=\"headerlink\" title=\"父子组件合成事件的捕获和冒泡执行顺序\"></a>父子组件合成事件的捕获和冒泡执行顺序</h3><p>V17 之前，合成事件和原生事件的执行顺序与冒泡&#x2F;捕获模式无关，原生事件恒早于合成事件；</p>\n<p>V17 后，合成事件和原生事件的执行顺序与冒泡&#x2F;捕获模式相关，冒泡模式，原生事件早于合成事件，捕获模式，合成事件早于原生事件。</p>\n<p>&#x2F;&#x2F; V17.0.2 document 原生事件 &gt; 合成事件（父 -&gt; 子） &gt; 原生事件（父 -&gt; 子）<br>&#x2F;&#x2F; 原生事件：document DOM 事件监听！<br>&#x2F;&#x2F; React 事件：父元素事件监听！<br>&#x2F;&#x2F; React 事件：子元素事件监听！<br>&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！</p>\n<p>&#x2F;&#x2F; V16.14.0 document 原生事件 &gt; 原生事件（父 -&gt; 子）&gt; 合成事件（父 -&gt; 子）<br>&#x2F;&#x2F; 原生事件：document DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！<br>&#x2F;&#x2F; React 事件：父元素事件监听！<br>&#x2F;&#x2F; React 事件：子元素事件监听！</p>\n<p>作者：活抓一只小机灵<br>链接：<a href=\"https://juejin.cn/post/7005129812981317668\">https://juejin.cn/post/7005129812981317668</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h3><h4 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h4><p>是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口。</p>\n<h4 id=\"要使用浏览器的底层事件？\"><a href=\"#要使用浏览器的底层事件？\" class=\"headerlink\" title=\"要使用浏览器的底层事件？\"></a>要使用浏览器的底层事件？</h4><p>需要使用 nativeEvent 属性来获取</p>\n<h4 id=\"变化？\"><a href=\"#变化？\" class=\"headerlink\" title=\"变化？\"></a>变化？</h4><p>从 v17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中。</p>\n<h4 id=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"><a href=\"#在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\" class=\"headerlink\" title=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"></a>在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</h4><p>如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。</p>\n<h4 id=\"事件委托的变更\"><a href=\"#事件委托的变更\" class=\"headerlink\" title=\"事件委托的变更\"></a>事件委托的变更</h4><p>React v17 中，React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中<br>经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。</p>\n<h4 id=\"全新的-JSX-转换\"><a href=\"#全新的-JSX-转换\" class=\"headerlink\" title=\"全新的 JSX 转换\"></a>全新的 JSX 转换</h4><p>此时源代码无需引入 React 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）</p>\n<p>此变化与所有现有 JSX 代码兼容，所以你无需修改组件。如果你对此感兴趣，你可以查看 RFC 了解全新转换工作的具体细节。</p>\n<p>特点：</p>\n<ul>\n<li>新的 JSX 转换不依赖 React 环境</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>不需要引入 Ract 使用全新的转换，你可以单独使用 JSX 而无需引入 React。</li>\n<li>改善 bundle 根据你的配置，JSX 的编译输出可能会略微改善 bundle 的大小。</li>\n<li>以备未来之需 它将减少你需要学习 React 概念的数量，以备未来之需。</li>\n</ul>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><h3 id=\"git-rebase-与-git-merge\"><a href=\"#git-rebase-与-git-merge\" class=\"headerlink\" title=\"git rebase 与 git merge\"></a>git rebase 与 git merge</h3><p>merge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）<br>rebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，</p>\n<p>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>\n<h4 id=\"副作用清理时间\"><a href=\"#副作用清理时间\" class=\"headerlink\" title=\"副作用清理时间\"></a>副作用清理时间</h4><ul>\n<li>React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。</li>\n<li>React 16 只对组件内的 effect 保证这种顺序。</li>\n</ul>\n<h4 id=\"React17-重大更改\"><a href=\"#React17-重大更改\" class=\"headerlink\" title=\"React17 重大更改\"></a>React17 重大更改</h4><ul>\n<li>更改事件委托</li>\n<li>对标浏览器，对事件系统进行小改</li>\n<li>去除事件池 不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水 （因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。）</li>\n<li>副作用清理时间 （- React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。，- React 16 只对组件内的 effect 保证这种顺序。）</li>\n<li>返回一致的 undefined 错误，（算是改 bug 了，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错）</li>\n<li>原生组件栈 （生产环境提示更友好。在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。<em>React 实现这一点的方式有点非常规</em>。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。因此，<em>当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息</em>）</li>\n<li>移除私有导出（与 react 关联不是很大的部分被移出）</li>\n</ul>\n<h3 id=\"变基原理：\"><a href=\"#变基原理：\" class=\"headerlink\" title=\"变基原理：\"></a>变基原理：</h3><ol>\n<li>是首先找到这两个分支的最近共同祖先 C2</li>\n<li>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3</li>\n<li>最后以此将之前另存为临时文件的修改依序应用</li>\n</ol>\n<h3 id=\"什么时候用哪个？\"><a href=\"#什么时候用哪个？\" class=\"headerlink\" title=\"什么时候用哪个？\"></a>什么时候用哪个？</h3><p>这本身存在分歧，主要看团队需要，如果团队需要历史记录保留，便于追踪，可以使用 merge ,如果不希望保留过多的过程，只关注结果那么可以用 rebase.无论用哪个，为了避免 rebase 的坑， 需要遵循以下原则：</p>\n<h3 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h3><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ git rebase --onto master server client</code></pre>\n\n<p>你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#:~:text=Figure%2039.%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E9%87%8C%E5%86%8D%E5%88%86%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\ngit rebase -i HEAD~4\n# s 命令压缩</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171547417.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171551269.png\" />\n\n<p><a href=\"https://www.cnblogs.com/lookphp/p/5799533.html\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://backlog.com/git-tutorial/cn/stepup/stepup7_7.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h3><img src=\"http://t-blog-images.aijs.top/img/202209181100864.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209181059249.png\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~3\nThe previous cherry-pick is now empty, possibly due to conflict resolution.\nIf you wish to commit it anyway, use:\n\n    git commit --allow-empty\n\nOtherwise, please use &#39;git reset&#39;\ninteractive rebase in progress; onto e1a52d3\nLast commands done (2 commands done):\n   pick 78c1fd9 应对github bug s 压缩\n   pick 8935665 应对github bug\nNext commands to do (4 remaining commands):\n   pick 421821a update\n   pick 4eff6a3 update\nYou are currently rebasing branch &#39;main&#39; on &#39;e1a52d3&#39;.\n\nnothing to commit, working tree clean\nCould not apply 8935665... 应对github bug\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~2\n\nIt seems that there is already a rebase-merge directory, and\nI wonder if you are in the middle of another rebase.  If that is the\ncase, please try\n        git rebase (--continue | --abort | --skip)\nIf that is not the case, please\n        rm -fr &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;.git&#x2F;rebase-merge&quot;\nand run me again.  I am stopping in case you still have something\nvaluable there.\n$ git rebase --abort</code></pre>\n","text":"var let const 区别： 版本： var 是 es6 之前， const、let es6 之后， 分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域 提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":18,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">var let const 区别：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A\"><span class=\"toc-text\">作用域：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9F\"><span class=\"toc-text\">什么是执行上下文？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83%EF%BC%9F\"><span class=\"toc-text\">什么是词法环境？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F\"><span class=\"toc-text\">什么是作用域？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F\"><span class=\"toc-text\">什么是作用域链？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">原型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">什么是原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">为什么使用原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">原型分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">什么是原型链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建对象的几种方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Number%E3%80%81Boolean-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">Number、Boolean 包装类型的原型链是怎样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#instanceof\"><span class=\"toc-text\">instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">实例与构造函数之间的关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-class%E3%80%81extends-%E4%B8%8E-super-%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ES6 语法中的 class、extends 与 super 的原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this\"><span class=\"toc-text\">this</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-this-%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">聊下 this 指向问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E8%A6%81%E6%9C%89-this\"><span class=\"toc-text\">为什要有 this</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84\"><span class=\"toc-text\">this 是如何定义的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99\"><span class=\"toc-text\">this 绑定规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">this 绑定的优先级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85\"><span class=\"toc-text\">new 做了哪些事情</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create\"><span class=\"toc-text\">Object.create()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create-%E4%B8%8E-new-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Object.create 与 new 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">箭头函数与普通函数区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB-class\"><span class=\"toc-text\">类 class</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">通过构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过静态方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA\"><span class=\"toc-text\">编程方法论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是函数式编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向对象编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向过程编程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typescript\"><span class=\"toc-text\">typescript</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#type-%E4%B8%8E-interface-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">type 与 interface 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">相同点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0%E4%B8%8A%EF%BC%9A1-%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">描述上：1. 都可以描述一个对象或者函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E4%B8%8A%EF%BC%9A-2-%E9%83%BD%E5%85%81%E8%AE%B8%E6%8B%93%E5%B1%95%EF%BC%88extends\"><span class=\"toc-text\">扩展上： 2. 都允许拓展（extends</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">不同点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-type-%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%8C%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%85%83%E7%BB%84%E7%AD%89%E7%B1%BB%E5%9E%8B-interface-%E4%B8%8D%E5%8F%AF%E4%BB%A5\"><span class=\"toc-text\">1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-type-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-typeof-%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E7%9A%84-%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC-interface-%E4%B8%8D%E5%8F%AF%E4%BB%A5\"><span class=\"toc-text\">2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#interface-%E8%83%BD%E5%A4%9F%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6-type-%E4%B8%8D%E8%A1%8C\"><span class=\"toc-text\">interface 能够声明合并(type 不行)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Typescript-%E4%B8%AD-extends-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">Typescript 中 extends 的作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">1、接口继承</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%99%AE%E9%80%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">2、普通条件判断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">3、泛型条件判断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">4、泛型约束</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React\"><span class=\"toc-text\">React</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-key\"><span class=\"toc-text\">聊下 key</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5-key\"><span class=\"toc-text\">为什么引入 key</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#key-%E6%9C%89%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">key 有什么要求</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5-key-%E4%B8%8D%E4%BC%9A%E7%94%A8-index\"><span class=\"toc-text\">通常情况 key 不会用 index</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-key\"><span class=\"toc-text\">什么时候使用 key</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#key-%E5%9C%A8%E6%BA%90%E7%A0%81%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9A%84\"><span class=\"toc-text\">key 在源码单节点、多节点中的</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diff-%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">diff [单节点、多节点]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hooks-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">hooks 产生的原因</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A4%8D%E7%94%A8%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%E5%BE%88%E9%9A%BE\"><span class=\"toc-text\">在组件之间复用状态逻辑很难</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">复杂组件变得难以理解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84-class\"><span class=\"toc-text\">难以理解的 class</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">useEffect 执行特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-useEffect-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1. useEffect 做了什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8-useEffect%EF%BC%9F\"><span class=\"toc-text\">2. 为什么在组件内部调用 useEffect？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-useEffect-%E4%BC%9A%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%90%8E%E9%83%BD%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3. useEffect 会在每次渲染后都执行吗？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BC%A0%E9%80%92%E7%BB%99-useEffect-%E7%9A%84%E5%87%BD%E6%95%B0%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E4%B8%AD%E9%83%BD%E4%BC%9A%E6%9C%89%E6%89%80%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">4. 传递给 useEffect 的函数在每次渲染中都会有所不同</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-effect-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">5. effect 异步执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8-effect-%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">6. 为什么要在 effect 中返回一个函数？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-React-%E4%BD%95%E6%97%B6%E6%B8%85%E9%99%A4-effect%EF%BC%9F\"><span class=\"toc-text\">7. React 何时清除 effect？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E4%BD%BF%E7%94%A8%E7%89%B9%E7%82%B9%E4%B8%8A%EF%BC%9F\"><span class=\"toc-text\">useEffect 使用特点上？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">useEffect 实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hook-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">Hook 使用规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">父子组件生命周期函数执行顺序：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#StrictMode\"><span class=\"toc-text\">StrictMode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%B0%83\"><span class=\"toc-text\">协调</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">合成事件的捕获和冒泡如何实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">父子组件合成事件的捕获和冒泡执行顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">合成事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">是什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BA%95%E5%B1%82%E4%BA%8B%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">要使用浏览器的底层事件？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">变化？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E8%A2%AB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5%E8%A7%A6%E5%8F%91%EF%BC%9F\"><span class=\"toc-text\">在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8F%98%E6%9B%B4\"><span class=\"toc-text\">事件委托的变更</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%96%B0%E7%9A%84-JSX-%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">全新的 JSX 转换</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#git\"><span class=\"toc-text\">git</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-rebase-%E4%B8%8E-git-merge\"><span class=\"toc-text\">git rebase 与 git merge</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%89%AF%E4%BD%9C%E7%94%A8%E6%B8%85%E7%90%86%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">副作用清理时间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#React17-%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%94%B9\"><span class=\"toc-text\">React17 重大更改</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%9F%BA%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">变基原理：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">什么时候用哪个？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%A4%94\"><span class=\"toc-text\">🤔</span></a></li></ol></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"比你优秀的人，比你更努力！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React中的术语","uid":"4cfbb91d77b5df4256b735640b2a3f88","slug":"2022-09-19react","date":"2022-09-19T12:42:20.000Z","updated":"2022-09-20T12:57:05.700Z","comments":true,"path":"api/articles/2022-09-19react.json","keywords":null,"cover":null,"text":"浅合并this.setState 会进行浅合并 falsyfalsy 表达式 MDN 8 个 falsy 值 &#x2F;&#x2F; | 值 | 说明 | &#x2F;&#x2F; | :-------- | :---------------------------------...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"React","slug":"React","count":20,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":14,"path":"api/tags/React.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"比你优秀的人，比你更努力！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-this","uid":"f0c189916a4d9ce9f34f51ecbf84a8dc","slug":"2022-09-18this","date":"2022-09-18T04:09:38.000Z","updated":"2022-09-18T08:44:46.706Z","comments":true,"path":"api/articles/2022-09-18this.json","keywords":null,"cover":null,"text":"注意啦，注意啦以下皆对普通函数而言，箭头函数可不是这么玩的 为什要有 thisthis 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。 简单来说：this，被放到作用域中， 为了...","link":"","photos":[],"count_time":{"symbolsCount":838,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"比你优秀的人，比你更努力！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}