{"title":"前端基础-qa","uid":"d55ac1d91034293bfc294fd694ca97c4","slug":"2022-09-19qa","date":"2022-09-18T09:13:05.000Z","updated":"2023-06-04T04:39:39.423Z","comments":true,"path":"api/articles/2022-09-19qa.json","keywords":null,"cover":[],"content":"<h2 id=\"var-let-const-区别：\"><a href=\"#var-let-const-区别：\" class=\"headerlink\" title=\"var let const 区别：\"></a>var let const 区别：</h2><!-- 1. `版本`： var 是 es6 之前， const、let es6 之后，\n2. `分类`： 在 es6 之前只有`全局作用域`和`函数作用域`， const、let 块级作用域\n3. `提升`：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前使用会报错\n4. `重复`：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值\n5. `存储`：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的\n6. `默认`： 默认情况下是 var 声明\n7. `函数`：函数声明提升优先于 var\n\n补充说明： const 和不变性。\n\n1. const 创建一个变量名绑定，该绑定在创建后不能重新分配。\n2. const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。 -->\n\n<h2 id=\"什么是执行上下文？\"><a href=\"#什么是执行上下文？\" class=\"headerlink\" title=\"什么是执行上下文？\"></a>什么是执行上下文？</h2><p>当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。</p>\n<ol>\n<li><code>全局上下文：</code>默认&#x2F;基础的上下文，任何不在函数内部的代码都在全局上下文中，一个程序中只有一个全局执行上下文</li>\n<li><code>函数执行上下文</code>：一个函数被调用时，会为该函数创建一个上下文，每个函数都有自己的函数上下文，函数上下文可以有任意多个</li>\n<li><code>eval上下文</code>：执行在 eval 函数内部的代码也会有属于它自己的执行上下文</li>\n</ol>\n<h2 id=\"javascript-的执行顺序\"><a href=\"#javascript-的执行顺序\" class=\"headerlink\" title=\"javascript 的执行顺序\"></a>javascript 的执行顺序</h2><!-- 1. `JavaScript 代码在执行的过程中`，需要先做变量提升，之所以如此，是因为 JavaScript 代码在执行前需要进行`编译`；\n2. 在编译阶段，\n   1. 变量和函数会被存放到`变量环境`中，变量的默认值为 undefined；\n   2. 块级作用域会被存放到`词法环境`中；\n   3. 存在两个相同的函数，后面的会`覆盖`前面的函数；\n3. 调用函数时，JavaScript 引擎维护了一个栈的数据结构（`调用栈`），每次调用函数都会将函数的执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码；\n4. 当函数执行完毕后，JavaScript 引擎会将该函数的执行上下文`弹出栈`；\n5. 当分配的栈空间被占满时，会引发`栈溢出`的情况；\n\n作者：chicABoo\n链接：https://juejin.cn/post/6965786039185047559\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->\n\n<p>JavaScript 中的代码执行顺序是基于事件循环模型的，其大致流程如下：</p>\n<ol>\n<li><p><code>执行全局代码</code>。在这个过程中，JavaScript 引擎会创建全局执行上下文，并将其中的全局变量、函数等定义在全局作用域中。</p>\n</li>\n<li><p><code>执行函数代码</code>。当遇到函数调用时，JavaScript 引擎会创建函数执行上下文，并将其中的变量、函数等定义在函数作用域中。</p>\n</li>\n<li><p><code>添加任务到任务队列</code>。如果在函数执行过程中遇到异步操作，如定时器、网络请求等，JavaScript 引擎会将这些操作封装成一个任务，并将任务添加到任务队列中。</p>\n</li>\n<li><p><code>等待执行</code>。在任务添加完成之后，JavaScript 引擎会一直等待，直到当前代码执行完成并且所有任务的依赖关系得到满足。</p>\n</li>\n<li><p><code>从任务队列中取出任务并执行</code>。当任务的依赖关系满足后，JavaScript 引擎会从任务队列中取出任务，并将任务中的回调函数放入调用栈中执行。在执行任务的过程中，如果遇到新的异步操作，会将其添加到任务队列中，然后继续等待。</p>\n</li>\n</ol>\n<p>需要注意的是，JavaScript 是单线程的语言，即在任何时刻只能有一个任务在执行。这就意味着，如果某个任务的执行时间过长，会阻塞后续任务的执行，导致页面失去响应。因此，开发人员需要注意控制任务的执行时间，避免长时间的计算和循环等操作。</p>\n<h2 id=\"javascript-的执行顺序-与事件循环是什么一个概念吗\"><a href=\"#javascript-的执行顺序-与事件循环是什么一个概念吗\" class=\"headerlink\" title=\"javascript 的执行顺序 与事件循环是什么一个概念吗\"></a>javascript 的执行顺序 与事件循环是什么一个概念吗</h2><p>JavaScript 的执行顺序与事件循环是相关的，但不是完全相同的概念。</p>\n<p>JavaScript 中的执行顺序是基于事件循环模型的，即在执行代码时，JavaScript 引擎会不断地从任务队列中取出任务并执行，然后再继续等待下一个任务。这个过程就是事件循环。</p>\n<p><strong>事件循环是 JavaScript 引擎处理异步任务的一种机制，其中异步任务包括定时器、网络请求、用户交互等</strong>。这些异步任务在执行时，不会阻塞主线程的执行，而是在任务完成后，将回调函数放入任务队列中，等待 JavaScript 引擎处理。</p>\n<p>因此，JavaScript 的执行顺序和事件循环密切相关，但并不完全相同。JavaScript 的执行顺序包括了全局代码、函数代码等的执行顺序，而事件循环则是异步任务的执行顺序。同时，JavaScript 引擎还需要控制调用栈、作用域链等多种因素，来保证代码的正确执行。</p>\n<h2 id=\"作用域【精】\"><a href=\"#作用域【精】\" class=\"headerlink\" title=\"作用域【精】\"></a>作用域【精】</h2><p><strong>MDN:</strong></p>\n<!-- <span style=\"color: red\">在当前的执行上下文。值和表达式在其中 \"可见\" 或可被访问到的上下文。</span> 如果一个**变量或者其他表达式**,不 \"在当前的作用域中\"，那么它就是不可用的。\n\n作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。\n\n作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。\n\n> 在函数之外声明的变量，叫做`全局变量`，因为它可被当前文档中的任何其他代码所访问。\n> 在函数内部声明的变量，叫做`局部变量`，因为它只能在当前函数的内部访问。\n> ECMAScript 6 之前的 JavaScript 没有 `语句块作用域`；\n> es6 之后，`语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量`。 -->\n\n<ol>\n<li>是什么</li>\n<li>如何分类</li>\n<li>如何实现作用域</li>\n<li>如何控制作用域</li>\n</ol>\n<p>作用域是<strong>指在程序中定义变量的区域，它规定了变量的可见性和生命周期</strong>。在 JavaScript 中，作用域可以分为全局作用域和局部作用域，其中全局作用域指的是在整个程序中都可见的变量，局部作用域指的是在函数或代码块内定义的变量。</p>\n<p>具体来说，JavaScript 中的作用域是通过作用域链实现的。作用域链是由多个执行上下文（Execution Context）的变量对象组成的链表结构，它决定了变量的查找顺序和可见性。</p>\n<p>当代码在执行时，JavaScript 引擎会创建执行上下文，并将其推入执行栈中。每个执行上下文都有一个变量对象，用于存储变量、函数声明和函数参数等信息。当查找变量时，JavaScript 引擎会先在当前执行上下文的变量对象中查找，如果没有找到，则会向上一级执行上下文的变量对象中查找，直到找到该变量或到达全局执行上下文为止。</p>\n<p>在 JavaScript 中，变量的作用域可以通过关键字 var、let、const 来控制。</p>\n<ul>\n<li>使用 var 关键字声明的变量具有函数作用域，即在函数内部声明的变量在函数外部无法访问。</li>\n<li>而使用 let 或 const 关键字声明的变量具有块级作用域，即在代码块内部声明的变量只能在该代码块内访问。</li>\n</ul>\n<p>因此，理解作用域是很重要的，<strong>它可以帮助我们正确地声明变量，避免命名冲突，提高代码的可读性和可维护性</strong>。同时，也可以帮助我们更好地理解 JavaScript 的执行机制和运行时环境。</p>\n<p>例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  var x &#x3D; 5;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 5</code></pre>\n\n<p>使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  let y &#x3D; 5;\n&#125;\nconsole.log(y); &#x2F;&#x2F; ReferenceError: y 没有被声明</code></pre>\n\n<h2 id=\"作用域链【精】\"><a href=\"#作用域链【精】\" class=\"headerlink\" title=\"作用域链【精】\"></a>作用域链【精】</h2><!-- JavaScript 在执⾏过程中, 会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了`作⽤域链`。 -->\n\n<p>什么是作用域链</p>\n<p>作用域链（Scope Chain）是由多个执行上下文的变量对象组成的链表结构，用于决定变量的查找顺序和可见性。在 JavaScript 中，每个函数都有一个作用域链，它由当前函数的变量对象和所有包含它的父函数的变量对象组成。</p>\n<p>当 JavaScript 引擎在执行一个函数时，会首先在该函数的变量对象中查找要访问的变量。如果找到了，则直接使用该变量；否则，会沿着作用域链依次向上查找，直到找到该变量或到达全局执行上下文的变量对象为止。如果在最后都没有找到该变量，则会抛出“ReferenceError”异常。</p>\n<p>举个例子，假设我们有以下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function foo() &#123;\n  var x &#x3D; 10;\n\n  function bar() &#123;\n    var y &#x3D; 20;\n    console.log(x + y);\n  &#125;\n\n  bar();\n&#125;\n\nfoo();</code></pre>\n\n<p>在执行函数 <code>bar</code> 时，JavaScript 引擎会先在 <code>bar</code> 函数的变量对象中查找变量 <code>y</code>，找到后直接使用。但是，当它需要访问变量 <code>x</code> 时，会沿着作用域链向上查找，在 <code>foo</code> 函数的变量对象中找到该变量，因此可以正常访问并输出 <code>30</code>。</p>\n<p><strong>需要注意的是，作用域链是在函数创建时确定的，与函数的调用方式无关</strong>。</p>\n<ul>\n<li>因此，在一个函数内部定义的变量只能在该函数内部访问，而不能在外部访问。</li>\n<li>此外，由于闭包的存在，一个函数可以访问其定义时的作用域链上的所有变量，这也是 JavaScript 中一种强大的编程技巧。</li>\n</ul>\n<!-- ## 作用域\n\n作用域是可访问变量的集合。\n\n1. 全局作用域\n2. 函数作用域\n3. 块级作用域\n\nJavaScript 变量生命周期\n\n1. 局部变量在函数执行完毕后销毁。\n2. 全局变量在页面关闭后销毁。\n\n## 作用域链\n\n1. 当执行一段代码时，JS 引擎首先在当前执行上下文中查找变量，\n2. 如果找不到，会根据外部引用, 去对应的外部执行上下文查找变量，直到查找到最外层的全局执行上下文，\n3. 从当前执行上下文到全局执行上下文，形成了一个链条，我们称为`作用域链`\n\n简单来说：由于函数嵌套，一个变量在当前函数作用域找不到，会往上找，直到全局作用域，这种作用域嵌套的现象；由内向外，一层一层往上的链式规则，这就是作用域链\n\n<a href=\"https://juejin.cn/post/7023259995219165214\" target=\"_blank\" >JavaScript 执行机制二（深入之闭包）</a> -->\n\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><ol>\n<li>词法作用域是<code>由代码声明的位置决定的</code>，所以词法作用域<code>是静态作用域</code>，通过它<code>能预测代码在执行过程中如何查找标识</code>。</li>\n<li>对于代码中<code>存在块级作用域的情况</code>，<code>作用域链首先在词法环境中查找，没找到才会到变量环境中查找</code></li>\n</ol>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bfb6a6ffe2147be9ce8dbcc60eb0de5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" />\n\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>在 JavaScript 中，根据词法作用域的规则，内部函数总能访问外部函数声明的变量，当通过调用外部函数返回内部函数时，即使外部函数执行完毕，内部函数引用外部函数的变量仍存在内存中，我们就把这些变量的集合称为闭包</p>\n<h3 id=\"那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\"><a href=\"#那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\" class=\"headerlink\" title=\"那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\"></a>那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？</h3><ol>\n<li>如果一个函数内有闭包，javascript 在执行这个函数时候，会预扫描内部函数是否有使用的 foo 函数中声明的变量；</li>\n<li>预扫描过程中，在内层函数 showName 中找到了外部函数 foo 中声明的变量 name，因此在 JavaScript 中判断这是一个闭包，</li>\n<li>此时会在堆中开辟一个空间创建 closure(foo)对象，将 name 值存到里面。</li>\n<li>而执行栈中的 foo 执行上下文中的 name 存的值是 closure(foo)的地址，因此当 foo 函数执行完成并销毁，name 值仍然存在堆的 closure(foo)的对象中，具体如下图所示：</li>\n<li><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22b437d4602e45379d9c9b4139817a24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" /></li>\n</ol>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/7023259995219165214\">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"闭包是如何回收的\"><a href=\"#闭包是如何回收的\" class=\"headerlink\" title=\"闭包是如何回收的\"></a>闭包是如何回收的</h3><ol>\n<li>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭。但如果这个变量之后不在使用，就会造成内存泄露</li>\n<li>如果引用闭包的函数是一个局部变量，等函数销毁后，在下一次执行垃圾回收时，判断闭包这块内容不再使用，那么 JavaScript 引擎的垃圾回收器就会回收这块内容</li>\n</ol>\n<h3 id=\"闭包使用原则\"><a href=\"#闭包使用原则\" class=\"headerlink\" title=\"闭包使用原则\"></a>闭包使用原则</h3><ol>\n<li>如果该闭包会一直使用，那么它可以作为全局变量而存在；</li>\n<li>但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>作用域链：</code>每个执行上下文都有一个指向外部的 outer，这个指向外部的引用 outer 在编译时就决定了，也就是说，根据声明的位置就能确定外部引用 outer，这就是词法作用域（静态作用域），它能预测代码执行过程中如何查找标识。通过它就能确定作用域链。</li>\n<li><code>闭包：</code>外部函数声明的变量，在内部函数中调用，当调用外部函数返回内部函数时，外部函数中声明的变量并不会随着外部函数执行完成而销毁，这些变量构成的集合就是外部函数的闭包。</li>\n<li><code>栈和堆空间：</code>基本数据类型是存在栈空间中的，引用数据类型是存在堆空间中的。<code>当形成闭包时，外部函数声明的变量存放在调用栈中，对于外部函数中的变量被内部函数所使用，在堆中就会创建一个 closure(函数名)的对象，用于存放闭包的变量集合，而外部函数中存的只是堆中的地址。所以说，当外部函数执行完成销毁时，JavaScript 引擎并不会回收堆中的地址。</code></li>\n<li><code>正确使用闭包：</code>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用。</li>\n</ol>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/7023259995219165214\">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"什么是作用域？\"><a href=\"#什么是作用域？\" class=\"headerlink\" title=\"什么是作用域？\"></a>什么是作用域？</h3><p>通俗点来讲就是：指变量的可使用范围</p>\n<p>一般有三种作用域：全局作用域、函数作用域、块级作用域</p>\n<ol>\n<li><code>全局作用域</code>：声明的变量，全局可见</li>\n<li><code>函数作用域</code>：声明的变量在当前函数内部可见</li>\n<li><code>块级作用域</code>：{},条件语句，循环语句中</li>\n</ol>\n<h3 id=\"原型与原型链\"><a href=\"#原型与原型链\" class=\"headerlink\" title=\"原型与原型链\"></a>原型与原型链</h3><p>原型（prototype）是 JavaScript 中的一个重要概念，<strong>用于实现继承和共享属性</strong>。每个 JavaScript 对象都有一个原型对象，即通过 constructor 构造函数创建该对象的模板对象。可以通过对象的 <code>__proto__</code> 属性来访问该对象的原型对象。</p>\n<p>原型链（prototype chain）是由一系列原型对象组成的链式结构。每个对象都有一个指向其原型对象的指针，即 <code>__proto__</code> 属性。当访问对象的某个属性时，如果该对象本身没有该属性，则会沿着原型链向上查找，直到找到该属性或者到达原型链的末端（Object.prototype）。如果一直找不到该属性，则返回 undefined。</p>\n<p>下面是一个例子，用于说明原型与原型链的概念：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义一个构造函数 Person\nfunction Person(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 给 Person 的原型对象添加方法 sayHello\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;.&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建一个 Person 对象\nconst person &#x3D; new Person(&#39;Alice&#39;, 18);\n\n&#x2F;&#x2F; 访问 person 的属性和方法\nconsole.log(person.name); &#x2F;&#x2F; &quot;Alice&quot;\nconsole.log(person.age); &#x2F;&#x2F; 18\nperson.sayHello(); &#x2F;&#x2F; &quot;Hello, my name is Alice.&quot;\n\n&#x2F;&#x2F; 查看 person 的原型对象\nconsole.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true\nconsole.log(Person.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true\nconsole.log(Object.prototype.__proto__); &#x2F;&#x2F; null</code></pre>\n\n<p>在上面的例子中，Person 是一个构造函数，它的原型对象（即 Person.prototype）定义了一个方法 sayHello。通过 new 操作符创建一个 Person 对象时，JavaScript 引擎会将该对象的原型指向 Person.prototype，从而实现了继承和共享属性。在访问 person 的属性和方法时，JavaScript 引擎会先查找该对象本身是否有该属性或方法，如果没有，则沿着原型链向上查找，直到找到为止。</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>原型</p>\n<p><strong>什么是原型</strong></p>\n<p>在 js 面向对象编程的实现 中, 原型是一个 prototype 对象，用于表示类型之间的关系。每一个对象都与另一个对象相关联，那个关联的对象就称为原型</p>\n<p><strong>为什么使用原型</strong></p>\n<ol>\n<li>原型对象的用途： 是为每个实例对象 “存储” 共享的方法和属性，它仅仅是一个普通对象而已。</li>\n<li>所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。</li>\n</ol>\n<p><strong>原型分类</strong></p>\n<p>显示原型和隐式原型</p>\n<ol>\n<li>显示原型： prototype 关键字标识</li>\n<li>隐式原型： <code>__proto__</code>表示</li>\n<li>一个构造函数显示原型 &#x3D;&#x3D;&#x3D; 该构造函数一个实例的隐式原型 即： （构造函数.<code>prototype</code> &#x3D;&#x3D;&#x3D; 构造函数实例.<code>__proto__</code>）</li>\n</ol>\n<p><strong>什么是原型链</strong></p>\n<ol>\n<li>每个实例对象的<code>__proto__</code>​ 属性, 指向它的构造函数的原型对象（<code>prototype</code>）。</li>\n<li>该原型对象也有一个自己的原型对象（<code>__proto__</code>​），层层向上直到一个对象的原型对象为 <code>null</code>​。</li>\n<li>根据定义，<code>null</code>​ 没有原型，并作为这个原型链中的最后一个环节</li>\n</ol>\n<p><strong>简单来说，原型链是： 一个对象 找原型对象 的依据</strong></p>\n<p><a href=\"https://www.51cto.com/article/718086.html\" target=\"_blank\" >见</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%80%A7%E8%83%BD:~:text=%E5%B9%B6%E4%BD%9C%E4%B8%BA%E8%BF%99%E4%B8%AA-,%E5%8E%9F%E5%9E%8B%E9%93%BE,-%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA\" target=\"_blank\" >原型链</a></p>\n\n</details>\n<h3 id=\"创建对象的几种方式\"><a href=\"#创建对象的几种方式\" class=\"headerlink\" title=\"创建对象的几种方式\"></a>创建对象的几种方式</h3><ol>\n<li>对象字面量</li>\n<li>构造函数</li>\n<li>new 关键字</li>\n<li>Object.create</li>\n<li>class</li>\n</ol>\n<h4 id=\"继承，原型链\"><a href=\"#继承，原型链\" class=\"headerlink\" title=\"继承，原型链\"></a>继承，原型链</h4><p>当谈到继承时，JavaScript 只有一种结构：对象。</p>\n<p>每个实例对象（object）都有一个私有属性（称之为 <code>__proto__</code>）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（<code>__proto__</code>），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节</p>\n<h4 id=\"继承属性\"><a href=\"#继承属性\" class=\"headerlink\" title=\"继承属性\"></a>继承属性</h4><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。</p>\n<ol>\n<li>JavaScript 对象有一个指向一个原型对象的链。</li>\n<li>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</li>\n</ol>\n<h4 id=\"继承方法\"><a href=\"#继承方法\" class=\"headerlink\" title=\"继承方法\"></a>继承方法</h4><p>函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var o &#x3D; &#123;\n  a: 2,\n  m: function () &#123;\n    return this.a + 1;\n  &#125;,\n&#125;;\n\nconsole.log(o.m()); &#x2F;&#x2F; 3\n&#x2F;&#x2F; 当调用 o.m 时，&#39;this&#39; 指向了 o.\n\nvar p &#x3D; Object.create(o);\n&#x2F;&#x2F; p 是一个继承自 o 的对象\n\np.a &#x3D; 4; &#x2F;&#x2F; 创建 p 的自身属性 &#39;a&#39;\nconsole.log(p.m()); &#x2F;&#x2F; 5 &#x2F;&#x2F; 属性屏蔽\n&#x2F;&#x2F; 调用 p.m 时，&#39;this&#39; 指向了 p\n&#x2F;&#x2F; 又因为 p 继承了 o 的 m 函数\n&#x2F;&#x2F; 所以，此时的 &#39;this.a&#39; 即 p.a，就是 p 的自身属性 &#39;a&#39;</code></pre>\n\n<h4 id=\"使用语法结构创建的对象\"><a href=\"#使用语法结构创建的对象\" class=\"headerlink\" title=\"使用语法结构创建的对象\"></a>使用语法结构创建的对象</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var o &#x3D; &#123; a: 1 &#125;;\n\n&#x2F;&#x2F; o 这个对象继承了 Object.prototype 上面的所有属性\n&#x2F;&#x2F; o 自身没有名为 hasOwnProperty 的属性\n&#x2F;&#x2F; hasOwnProperty 是 Object.prototype 的属性\n&#x2F;&#x2F; 因此 o 继承了 Object.prototype 的 hasOwnProperty\n&#x2F;&#x2F; Object.prototype 的原型为 null\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; o ---&gt; Object.prototype ---&gt; null\n\nvar a &#x3D; [&#39;yo&#39;, &#39;whadup&#39;, &#39;?&#39;];\n\n&#x2F;&#x2F; 数组都继承于 Array.prototype\n&#x2F;&#x2F; (Array.prototype 中包含 indexOf, forEach 等方法)\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null\n\nfunction f() &#123;\n  return 2;\n&#125;\n\n&#x2F;&#x2F; 函数都继承于 Function.prototype\n&#x2F;&#x2F; (Function.prototype 中包含 call, bind 等方法)\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre>\n\n<h4 id=\"使用构造器创建的对象\"><a href=\"#使用构造器创建的对象\" class=\"headerlink\" title=\"使用构造器创建的对象\"></a>使用构造器创建的对象</h4><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Graph() &#123;\n  this.vertices &#x3D; [];\n  this.edges &#x3D; [];\n&#125;\n\nGraph.prototype &#x3D; &#123;\n  addVertex: function (v) &#123;\n    this.vertices.push(v);\n  &#125;,\n&#125;;\n\nvar g &#x3D; new Graph();\n&#x2F;&#x2F; g 是生成的对象，他的自身属性有 &#39;vertices&#39; 和 &#39;edges&#39;。\n&#x2F;&#x2F; 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。</code></pre>\n\n<h4 id=\"使用-Object-create-创建的对象\"><a href=\"#使用-Object-create-创建的对象\" class=\"headerlink\" title=\"使用 Object.create 创建的对象\"></a>使用 Object.create 创建的对象</h4><p>ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; &#123; a: 1 &#125;;\n&#x2F;&#x2F; a ---&gt; Object.prototype ---&gt; null\n\nvar b &#x3D; Object.create(a);\n&#x2F;&#x2F; b ---&gt; a ---&gt; Object.prototype ---&gt; null\nconsole.log(b.a); &#x2F;&#x2F; 1 (继承而来)\n\nvar c &#x3D; Object.create(b);\n&#x2F;&#x2F; c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null\n\nvar d &#x3D; Object.create(null);\n&#x2F;&#x2F; d ---&gt; null\nconsole.log(d.hasOwnProperty); &#x2F;&#x2F; undefined，因为 d 没有继承 Object.prototype</code></pre>\n\n<h3 id=\"Number、Boolean-包装类型的原型链是怎样的？\"><a href=\"#Number、Boolean-包装类型的原型链是怎样的？\" class=\"headerlink\" title=\"Number、Boolean 包装类型的原型链是怎样的？\"></a>Number、Boolean 包装类型的原型链是怎样的？</h3><p><code>包装类型是构造函数 -&gt; 构造函数的原型是函数原型 -&gt; 对象的原型-&gt; null</code></p>\n<h3 id=\"简单数据类型，为什么可以调用方法\"><a href=\"#简单数据类型，为什么可以调用方法\" class=\"headerlink\" title=\"简单数据类型，为什么可以调用方法\"></a>简单数据类型，为什么可以调用方法</h3><p><a href=\"https://www.cnblogs.com/venoral/p/5243189.html\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var s1 &#x3D; &#39;some text&#39;;\nvar s2 &#x3D; s1.substring(2); &#x2F;&#x2F;&#39;me text&#39;</code></pre>\n\n<p>基本类型不是对象，因而从逻辑上讲他们不该有方法，其实为了让我们实现这种操作，后台已经完成了一系列的处理。</p>\n<p>第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台会完成如下处理：</p>\n<ol>\n<li><strong>创建</strong> <code>String/Boolean/Number</code> 类的一个实例。<code>var s1=new String(&#39;some text&#39;);</code></li>\n<li><strong>调用</strong>在实例上调用指定的方法。<code>var s2=s1.substring(2);//&#39;me text&#39;</code></li>\n<li><strong>销毁</strong>这个实例<code>。s1=null</code></li>\n</ol>\n<p><strong>引用类型与基本包装类型的主要区别就是对象的生存期：</strong></p>\n<ul>\n<li><em>使用 new 操作符创建的引用类型的实例</em> ，在执行完离开当前作用域之前都一直保存在内存中。</li>\n<li><em>自动创建的基本包装类型的对象</em> ，只存在于代码执行的一瞬间，然后被立即销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</li>\n</ul>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><p>instanceof 运算符</p>\n<ol>\n<li><del>判断一个对象是否是另一个对象的实例</del></li>\n<li>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</li>\n</ol>\n<h3 id=\"实例与构造函数之间的关系\"><a href=\"#实例与构造函数之间的关系\" class=\"headerlink\" title=\"实例与构造函数之间的关系\"></a>实例与构造函数之间的关系</h3><p>实例.<code>__proto__</code> &#x3D;&#x3D;&#x3D; 该实例的构造函数.<code>prototype</code></p>\n<h3 id=\"ES6-语法中的-class、extends-与-super-的原理\"><a href=\"#ES6-语法中的-class、extends-与-super-的原理\" class=\"headerlink\" title=\"ES6 语法中的 class、extends 与 super 的原理\"></a>ES6 语法中的 class、extends 与 super 的原理</h3><p><a href=\"https://www.cnblogs.com/rencoo/p/11879150.html\" target=\"_blank\" >见</a></p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><h3 id=\"聊下-this-指向问题\"><a href=\"#聊下-this-指向问题\" class=\"headerlink\" title=\"聊下 this 指向问题\"></a>聊下 this 指向问题</h3><p>以下皆对普通函数而言，箭头函数可不是这么玩的</p>\n<h3 id=\"为什要有-this\"><a href=\"#为什要有-this\" class=\"headerlink\" title=\"为什要有 this\"></a>为什要有 this</h3><p>简单来说：<code>this,被放到作用域中， 为了简化代码</code></p>\n<p>this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。</p>\n<h3 id=\"this-是如何定义的\"><a href=\"#this-是如何定义的\" class=\"headerlink\" title=\"this 是如何定义的\"></a>this 是如何定义的</h3><p>简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的</p>\n<p>我们简单总结一下 this 的特点：</p>\n<ul>\n<li>this 是在运行时绑定的，不是在编写时绑定</li>\n<li>this 的绑定与函数的声明和位置没有任何关系</li>\n<li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。</li>\n</ul>\n<p>所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</p>\n<p>简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>\n<h3 id=\"this-绑定规则\"><a href=\"#this-绑定规则\" class=\"headerlink\" title=\"this 绑定规则\"></a>this 绑定规则</h3><ol>\n<li>判断函数调用时是否使用了 new，如果使用了 new 绑定，则 this 绑定的是新创建的对象。</li>\n<li>函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。</li>\n<li>函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。</li>\n<li>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，<br>4.1 在严格模式下，默认绑定的 this 是 undefined，<br>4.2 非严格模式下绑定到全局对象。</li>\n</ol>\n<p><em>类声明和类表达式的主体都执行在严格模式下</em></p>\n<p><a href=\"/posts/2022-10-21js-class\" target=\"_blank\" >前端基础-class</a></p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7115390077353590792\">https://juejin.cn/post/7115390077353590792</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"this-绑定的优先级\"><a href=\"#this-绑定的优先级\" class=\"headerlink\" title=\"this 绑定的优先级\"></a>this 绑定的优先级</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定</code></pre>\n\n<h2 id=\"new-做了哪些事情\"><a href=\"#new-做了哪些事情\" class=\"headerlink\" title=\"new 做了哪些事情\"></a>new 做了哪些事情</h2><ol>\n<li>创建一个空对象；</li>\n<li>将空对象的原型，指向于构造函数的原型；</li>\n<li>将空对象作为构造函数的上下文（改变 this 指向）；</li>\n<li>对有返回值的构造函数做判断处理</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;定义构造函数\nfunction Fun(age, name) &#123;\n  this.age &#x3D; age;\n  this.name &#x3D; name;\n  return 1;\n&#125;\n\nfunction myNew(fn, ...args) &#123;\n  &#x2F;&#x2F;1、先创造空对象\n  &#x2F;&#x2F;其实等于var obj &#x3D; Object.create(&#123;&#125;)\n  var obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F;2、obj的__proto__指向原型\n  Object.setPrototypeOf(obj, fn.prototype);\n  &#x2F;&#x2F;3、改变this指向，执行构造函数内部函数\n  var result &#x3D; fn.apply(obj, args);\n  &#x2F;&#x2F;4、判断return\n  return result instanceof Object ? result : obj;\n&#125;</code></pre>\n\n<p><a href=\"cnblogs.com/jacky02/p/16048701.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;</code></pre>\n\n<h3 id=\"Object-create-与-new-的区别\"><a href=\"#Object-create-与-new-的区别\" class=\"headerlink\" title=\"Object.create 与 new 的区别\"></a>Object.create 与 new 的区别</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; new Object() 方式创建\nvar obj &#x3D; &#123; name: &#39;jack&#39; &#125;;\nvar b &#x3D; new Object(obj);\nconsole.log(b.name);\nconsole.log(b.__proto__.name); &#x2F;&#x2F;undefined\n\n&#x2F;&#x2F; Object.create() 方式创建\nvar obj2 &#x3D; &#123; name: &#39;apple&#39; &#125;;\nvar c &#x3D; Object.create(obj2);\nconsole.log(c.name);\nconsole.log(c.__proto__.name); &#x2F;&#x2F;apple</code></pre>\n\n<p>new 出来的 b 对象，通过原型链无法访问到 name 属性，而 Object.create 出来的 c 却可以</p>\n<h2 id=\"箭头函数与普通函数区别\"><a href=\"#箭头函数与普通函数区别\" class=\"headerlink\" title=\"箭头函数与普通函数区别\"></a>箭头函数与普通函数区别</h2><ol>\n<li><p><strong>声明</strong>具名箭头函数可以用 var let const , 普通函数除这些之外还可用 function 关键字</p>\n</li>\n<li><p><strong>使用</strong>简单：箭头函数使用起来简单，更适合匿名函数; <code>比较特殊的对象方法</code>，可以简写<code>()&#123;&#125;</code>,这个不是箭头函数</p>\n</li>\n<li><p><strong>立即执行</strong> 普通函数可以声明立即执行函数，箭头函数也可<code>void (()=&gt; &#123;console.log(1)&#125;)()</code></p>\n</li>\n<li><p><strong>运算上</strong> 在使用短路运算符的时候，箭头函数要用<code>()</code>括起来，否则因解析顺序导致错误</p>\n</li>\n<li><p><strong>拥有</strong> 箭头函数没有自己的 <code>this</code>， <code>prototype</code>，<code>arguments</code>, <code>super</code>, <code>new.target</code>,</p>\n</li>\n<li><p>基于此：箭头函数不适用于<code>构造函数、new、yeild</code> 等场合</p>\n</li>\n<li><p>在 <code>apply,call,bind</code> 中第一个参数会被忽略</p>\n</li>\n<li><p>箭头函数没有 arguments，可以使用…rest, （这里有个注意的点：普通函数 arguments，<strong>在非严格模式下</strong>，有<code>默认参数、剩余参数和结构赋值</code>的情况会出现： arguments 与形参不一致的情况）</p>\n</li>\n</ol>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p><code>背景</code>：js 是单线程的，同一时间 dom 的操作不允许并行</p>\n<p><code>出现的原因</code>：单线程，如果出现耗时的情况会一直等待，以浏览器为例： 浏览器分为 5 大线程，定时器线程和网络线程</p>\n<p><code>解决了什么问题</code>：在单线程中，可以跳过一些耗时的操作，先去做其他的事情，待到需要执行的时候，再执行，而这一策略被称为 事件循环</p>\n<p><code>执行过程：</code> <code>宿主环境</code>：以浏览器环境来说</p>\n<ol>\n<li>在 javascript 中，将任务放到执行栈中执行，执行完成的会出栈；未执行的会依次压入栈底，</li>\n<li>先执行同步任务（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部），直至同步任务都被执行完</li>\n<li>然后执行微任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）直至微任务队列都被执行完</li>\n<li>然后执行宏任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）</li>\n<li>会再去检测微任务队列，之后，再以相同的方式去执行宏任务队列</li>\n</ol>\n<h2 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h2 id=\"类-class\"><a href=\"#类-class\" class=\"headerlink\" title=\"类 class\"></a>类 class</h2><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><h3 id=\"通过构造函数\"><a href=\"#通过构造函数\" class=\"headerlink\" title=\"通过构造函数\"></a>通过构造函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  constructor() &#123;\n    console.log(&#39;this&#39;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h3 id=\"通过静态方法\"><a href=\"#通过静态方法\" class=\"headerlink\" title=\"通过静态方法\"></a>通过静态方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"为什么类名上可以直接添加属性\"><a href=\"#为什么类名上可以直接添加属性\" class=\"headerlink\" title=\"为什么类名上可以直接添加属性\"></a>为什么类名上可以直接添加属性</h2><p>在 JavaScript 中，类是一种特殊的对象，可以像普通对象一样添加属性和方法。类名本身也是一个对象，可以直接添加静态属性和方法。如果要添加实例属性和方法，应该在类的构造函数中添加。</p>\n<details class=\"custom-details\">\n<summary>更多内容</summary>\n<p><p>在 JavaScript 中，类是一种特殊的对象，可以像普通对象一样添加属性和方法。当我们定义一个类时，实际上是在定义一个函数，该函数会被用作构造函数，用于创建类的实例对象。在类的定义中，我们可以通过类名来访问类本身，<strong>这个类本身也是一个对象，可以直接添加属性和方法</strong>。</p>\n<p>举个例子，假设我们定义了一个名为 Person 的类，可以通过下面的代码为这个类添加一个静态属性 <code>type</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Person &#123;\n  static type &#x3D; &#39;human&#39;;\n  &#x2F;&#x2F; ...\n&#125;\nconsole.log(Person.type); &#x2F;&#x2F; &#39;human&#39;</code></pre>\n\n<p>在这个例子中，我们通过 <code>static</code> 关键字为 Person 类添加了一个静态属性 <code>type</code>。这个属性是通过类名直接访问的，而不是通过类的实例对象访问的。当我们调用 <code>console.log(Person.type)</code> 时，会输出 <code>&#39;human&#39;</code>，因为类名 Person 本身也是一个对象，可以直接添加属性和方法。</p>\n<p>需要注意的是，如果要在类中添加实例属性和方法，应该在类的构造函数中添加，而不是在类名上添加。例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Person &#123;\n  constructor(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n  &#125;\n  sayHello() &#123;\n    console.log(&#96;Hello, my name is $&#123;this.name&#125;.&#96;);\n  &#125;\n&#125;\n\nconst person &#x3D; new Person(&#39;Alice&#39;, 18);\nconsole.log(person.name); &#x2F;&#x2F; &#39;Alice&#39;\nconsole.log(person.age); &#x2F;&#x2F; 18\nperson.sayHello(); &#x2F;&#x2F; &#39;Hello, my name is Alice.&#39;</code></pre>\n\n<p>在这个例子中，我们在 Person 类的构造函数中添加了两个实例属性 <code>name</code> 和 <code>age</code>，以及一个实例方法 <code>sayHello</code>。在创建 Person 对象时，这些属性和方法会被添加到实例对象中，可以通过实例对象访问。</p>\n</p>\n</details>\n<h2 id=\"类是特殊的对象，哪里特殊了？\"><a href=\"#类是特殊的对象，哪里特殊了？\" class=\"headerlink\" title=\"类是特殊的对象，哪里特殊了？\"></a>类是特殊的对象，哪里特殊了？</h2><p>类是一种特殊的对象，它具有一些特殊的行为和属性：</p>\n<ol>\n<li>类可以使用 <code>class</code> 关键字定义，而对象不能。</li>\n<li>类可以用 <code>new</code> 关键字创建实例对象，而对象不能。</li>\n<li>类的属性和方法都是在原型对象上定义的，而对象的属性和方法都是直接在对象上定义的。</li>\n<li>类可以拥有静态属性和方法，这些属性和方法不需要通过类的实例对象访问，而对象只能拥有实例属性和方法。</li>\n<li>类定义的方法都是不可枚举的，而对象的方法默认是可枚举的。</li>\n<li>类的构造函数是特殊的方法，它在创建实例对象时自动调用，而对象没有构造函数。</li>\n</ol>\n<p>因此，类是一种特殊的对象，具有一些只有类才有的行为和属性。</p>\n<h2 id=\"编程方法论\"><a href=\"#编程方法论\" class=\"headerlink\" title=\"编程方法论\"></a>编程方法论</h2><!-- ### 什么是函数式编程\n\n1. 函数式编程是`通过组合纯函数，避免状态共享、可变数据、副作用，来构建软件的过程`。\n2. 函数式编程是`声明式的`，而不是命令式的，`应用程序状态通过纯函数流动`。\n3. 与面向对象编程不同，在面向对象编程中，`应用程序状态，通常与对象中的方法，共享和协作`。\n4. 与命令式或面向对象的代码相比，函数式代码往往`更简洁、更可预测、更易于测试`\n\n<a href=\"https://github.com/xitu/gold-miner/blob/master/TODO1/master-the-javascript-interview-what-is-functional-programming.md\" target=\"_blank\" >见</a>\n\n### 特点\n\n函数式编程有些重要的概念：\n\n1. `纯函数`： 给定相同的输入，总是得到相同的输出，没有副作用\n2. `函数组合`：将两个或两个以上的函数组合起来以产生一个新函数或进行某种计算的过程\n3. `避免状态共享`：共享作用域中存在的任何变量、对象或内存空间，或者是在作用域之间传递的对象的属性。共享作用域可以包括全局作用域或闭包作用域。通常，在面向对象编程中，通过向其他对象添加属性，在作用域之间共享对象。\n4. `避免可变数据`： 不可变对象是指创建后不能修改的对象。相反，可变对象是在创建后可以修改的对象， 可以通过：Object.freeze 进行冻结\n5. `避免副作用`：副作用是指：除了返回值之外，任何应用程序状态的改变都是可以在被调用函数之外观察到的\n\n<a href=\"https://juejin.cn/post/6844904130796847111\" target=\"_blank\" >见</a> -->\n\n<h3 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h3><ol>\n<li>函数式编程是一种编程范式，</li>\n<li>它的<strong>核心思想是将计算过程，视为函数应用的连续组合，避免使用可变状态和数据，强调函数的纯粹性和不可变性</strong>。</li>\n<li>在函数式编程中，函数是一等公民，可以作为参数传递给其他函数，也可以作为返回值返回。</li>\n<li>函数式编程中的函数通常都是无副作用的，即函数执行不会对外部环境产生任何影响。</li>\n</ol>\n<p>函数式编程可以带来很多好处，例如：</p>\n<ul>\n<li><code>简化代码</code>：函数式编程可以用更少的代码实现同样的功能，因为函数可以复用和组合。</li>\n<li><code>易于测试</code>：由于函数式编程中的函数是无副作用的，所以可以很容易地编写测试用例。</li>\n<li><code>可读性高</code>：函数式编程代码通常比较简洁，容易阅读和理解。</li>\n<li><code>易于并发</code>：由于函数式编程中的函数没有副作用，所以可以很容易地并发执行。</li>\n</ul>\n<p>在 JavaScript 中，函数式编程可以使用函数的高阶特性、柯里化、纯函数、不可变性等特性实现。</p>\n<h3 id=\"什么是面向对象编程\"><a href=\"#什么是面向对象编程\" class=\"headerlink\" title=\"什么是面向对象编程\"></a>什么是面向对象编程</h3><ol>\n<li>面向对象编程（Object-Oriented Programming，简称 OOP）是一种编程范式，</li>\n<li>它的<strong>核心思想是将数据和操作数据的方法（函数）作为一个整体，通过封装、继承和多态等机制来组织代码和数据，以实现更高的抽象和重用性</strong>。</li>\n</ol>\n<p>在面向对象编程中，一个程序由多个对象组成，每个对象包含数据和对数据进行操作的方法。对象之间可以通过消息传递来进行通信，从而实现协作和交互。</p>\n<p>面向对象编程有很多优点，例如：</p>\n<ol>\n<li><code>简化代码</code>：通过封装机制，可以将数据和行为打包在一起，从而简化代码实现和维护。</li>\n<li><code>提高可靠性</code>：通过封装机制，可以将内部细节隐藏起来，减少代码中的错误和不必要的干扰。</li>\n<li><code>易于扩展</code>：通过继承和多态机制，可以在不影响原有代码的情况下扩展功能和适应需求变化。</li>\n<li><code>代码重用</code>：通过继承和多态机制，可以在不重复编写代码的情况下实现功能扩展和模块化。</li>\n<li><code>易于理解</code>：通过面向对象的抽象和封装，可以将复杂问题分解为简单的对象和方法，使代码更易于理解和维护。</li>\n</ol>\n<p>在 JavaScript 中，面向对象编程可以通过对象、构造函数、原型、继承等机制实现。</p>\n<h3 id=\"什么是面向过程编程\"><a href=\"#什么是面向过程编程\" class=\"headerlink\" title=\"什么是面向过程编程\"></a>什么是面向过程编程</h3><ol>\n<li>面向过程编程（Procedural Programming）是一种基于过程的编程范式，</li>\n<li>它的<strong>核心思想是通过定义一系列的函数（过程），将程序分解为一系列的步骤，然后按照步骤顺序执行这些函数来完成任务。</strong></li>\n</ol>\n<p>在面向过程编程中，程序的执行是从上到下、从头到尾依次执行的，没有对象、类、继承等概念。程序员需要手动管理变量的生命周期、函数的调用关系等问题，这会导致程序难以扩展和维护。</p>\n<p>面向过程编程适用于一些简单的问题和小型项目，它的优点是代码简单、运行速度快，缺点是难以扩展和维护，可读性较差。</p>\n<p>与面向过程编程相对应的是面向对象编程，面向对象编程将程序分解为一些对象，并通过封装、继承、多态等机制来组织代码和数据，具有更好的可扩展性和可维护性。</p>\n<h3 id=\"CICD-的自动化流水线，是面向过程编程？\"><a href=\"#CICD-的自动化流水线，是面向过程编程？\" class=\"headerlink\" title=\"CICD 的自动化流水线，是面向过程编程？\"></a>CICD 的自动化流水线，是面向过程编程？</h3><p>CICD 的自动化流水线不是面向过程编程，而是面向工具和流程的编程范式。CICD 流水线是一个工具链，可以自动化执行一系列任务，例如代码构建、测试、打包、部署等，以实现软件的快速、高质量发布。CICD 流水线通常使用脚本编写，包括构建脚本、测试脚本、部署脚本等，这些脚本通常使用一些特定的工具和语言编写，例如 Jenkins、Gitlab CI、Travis CI、Python 等。</p>\n<p>CICD 流水线的设计和实现需要考虑很多方面，包括流程规划、工具选择、脚本编写等，需要综合考虑工具的可用性、可扩展性、易用性等方面，因此更加关注工具链和流程的设计，而不是程序的具体实现。<strong>因此，CICD 的自动化流水线不是面向过程编程，而是面向工具和流程的编程范式</strong>。</p>\n<h2 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h2><h3 id=\"typescript-中-type-与-interface-的区别\"><a href=\"#typescript-中-type-与-interface-的区别\" class=\"headerlink\" title=\"typescript 中 type 与 interface 的区别\"></a>typescript 中 type 与 interface 的区别</h3><p>TypeScript 中 <code>type</code> 和 <code>interface</code> 都用于定义类型，但它们的用法和语法略有不同。以下是它们的主要区别：</p>\n<ol>\n<li><p><code>type</code> 可以定义<code>基本类型</code>、<code>联合类型</code>、<code>交叉类型</code>和<code>元组类型</code>，而 <code>interface</code> 只能定义对象类型。</p>\n</li>\n<li><p><code>type</code> 可以使用 <code>extends</code> 关键字来<code>继承另一个类型</code>或<code>联合另一个类型</code>，而 <code>interface</code> 只能通过继承其他接口来扩展自己的成员。</p>\n</li>\n<li><p><code>interface</code> 可以声明合并，即多个同名接口可以自动合并为一个接口，而 <code>type</code> 不支持这种合并。</p>\n</li>\n</ol>\n<p>以下是 <code>type</code> 和 <code>interface</code> 的使用示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 使用 type 定义类型\ntype Name &#x3D; string;\ntype Age &#x3D; number;\n\ntype Person &#x3D; &#123;\n  name: Name;\n  age: Age;\n&#125;;\n\ntype PersonOrUndefined &#x3D; Person | undefined;\n\n&#x2F;&#x2F; 使用 interface 定义类型\ninterface User &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface Employee extends User &#123;\n  jobTitle: string;\n&#125;\n\ninterface User &#123;\n  email: string;\n&#125;\n\n&#x2F;&#x2F; User 接口会被自动合并为包含 name、age 和 email 三个属性的接口</code></pre>\n\n<p>总的来说，<code>type</code> 和 <code>interface</code> 都有自己的用途和优势，开发者可以根据实际需求选择使用哪种方式来定义类型。</p>\n<details class=\"custom-details\">\n<summary>定义元组类型</summary>\n<p>在 TypeScript 中，可以使用元组类型来表示固定长度和固定类型的数组。元组类型使用方括号 <code>[]</code> 来定义，其中方括号中按顺序列出了每个元素的类型。</p>\n<p>以下是一个示例，其中定义了一个元组类型 <code>Person</code>，包含了一个字符串类型的姓名和一个数字类型的年龄：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Person &#x3D; [string, number];\n\n&#x2F;&#x2F; 定义一个元组变量，按顺序依次是姓名和年龄\nconst john: Person &#x3D; [&#39;John&#39;, 30];\nconst mary: Person &#x3D; [&#39;Mary&#39;, 25];\n\n&#x2F;&#x2F; 错误示例，元素数量必须匹配\nconst jane: Person &#x3D; [&#39;Jane&#39;]; &#x2F;&#x2F; 缺少年龄\nconst tom: Person &#x3D; [40, &#39;Tom&#39;]; &#x2F;&#x2F; 类型不匹配</code></pre>\n\n<p>需要注意的是，元组类型的长度是固定的，一旦定义后就不能再增加或减少元素的个数。在使用元组类型时，需要确保每个元素的类型和顺序都是正确的，否则会导致类型错误。</p>\n\n</details>\n<details class=\"custom-details\">\n<summary>废弃</summary>\n<p><p>描述上：1. 都可以描述一个对象或者函数</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; interface\ninterface User &#123;\n  name: string\n  age: number\n&#125;\n\ninterface SetUser &#123;\n  (name: string, age: number): void;\n&#125;\n\n&#x2F;&#x2F; type\n\ntype User &#x3D; &#123;\n  name: string\n  age: number\n&#125;;\n\ntype SetUser &#x3D; (name: string, age: number)&#x3D;&gt; void;\n</code></pre>\n\n<p>扩展上： 2. 都允许拓展（extends</p>\n<p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ntype User &#x3D; Name &amp; &#123; age: number &#125;;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ntype User &#x3D; Name &amp; &#123;\n  age: number;\n&#125;;</code></pre>\n\n<p>不同点</p>\n<ol>\n<li>type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基本类型别名\ntype Name &#x3D; string;\n\n&#x2F;&#x2F; 联合类型\ninterface Dog &#123;\n  wong();\n&#125;\ninterface Cat &#123;\n  miao();\n&#125;\n\ntype Pet &#x3D; Dog | Cat;\n\n&#x2F;&#x2F; 具体定义数组每个位置的类型\ntype PetList &#x3D; [Dog, Pet];</code></pre>\n\n<ol start=\"2\">\n<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 当你想获取一个变量的类型时，使用 typeof\nlet div &#x3D; document.createElement(&#39;div&#39;);\ntype B &#x3D; typeof div;</code></pre>\n\n<p>其他骚操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type StringOrNumber &#x3D; string | number;\ntype Text &#x3D; string | &#123; text: string &#125;;\ntype NameLookup &#x3D; Dictionary&lt;string, Person&gt;;\ntype Callback&lt;T&gt; &#x3D; (data: T) &#x3D;&gt; void;\ntype Pair&lt;T&gt; &#x3D; [T, T];\ntype Coordinates &#x3D; Pair&lt;number&gt;;\ntype Tree&lt;T&gt; &#x3D; T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;\n</code></pre>\n\n<p>interface 能够声明合并(type 不行)</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface User &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface User &#123;\n  sex: string;\n&#125;\n\n&#x2F;*\nUser 接口为 &#123;\n  name: string\n  age: number\n  sex: string\n&#125;\n*&#x2F;</code></pre>\n\n</p>\n</details>\n<h3 id=\"Typescript-中-extends-的作用\"><a href=\"#Typescript-中-extends-的作用\" class=\"headerlink\" title=\"Typescript 中 extends 的作用\"></a>Typescript 中 extends 的作用</h3><h4 id=\"1、接口继承\"><a href=\"#1、接口继承\" class=\"headerlink\" title=\"1、接口继承\"></a>1、接口继承</h4><p>可以继承父类接口的方法和属性</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; dog 具有 Animal 的 name 属性。\nconst dog: Dog &#x3D; &#123;\n  name: &#39;tom&#39;,\n  sayHello: function () &#123;&#125;,\n&#125;;</code></pre>\n\n<h4 id=\"2、普通条件判断-表示-能够分配\"><a href=\"#2、普通条件判断-表示-能够分配\" class=\"headerlink\" title=\"2、普通条件判断 表示 能够分配\"></a>2、普通条件判断 表示 能够分配</h4><p><code>用来判断一个类型是否可以分配给另外一个类型</code></p>\n<p>A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。<br>换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n\nconst dog: Dog &#x3D; &#123;\n  name: &#39;tom&#39;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\ntype bool &#x3D; Animal extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;\ntype bool1 &#x3D; Dog extends Animal ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;</code></pre>\n\n<h4 id=\"3、泛型条件判断\"><a href=\"#3、泛型条件判断\" class=\"headerlink\" title=\"3、泛型条件判断\"></a>3、泛型条件判断</h4><p>对于使用 extends 关键字的条件类型，<code>如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。</code></p>\n<p>分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</p>\n<p>满足两个要点即可适用分配律：</p>\n<p>参数是泛型类型，</p>\n<p>代入参数的是联合类型<br><code>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Animal&lt;T&gt; &#x3D; T;\ntype Animal1&lt;T&gt; &#x3D; [T];\ntype Dog &#x3D; Animal&lt;&#39;x&#39; | &#39;y&#39;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;\ntype Dog1 &#x3D; Animal1&lt;&#39;x&#39; | &#39;y&#39;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]\n\ntype A &#x3D; &#39;x&#39; extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;\ntype B &#x3D; &#39;x&#39; extends Dog1 ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;\ntype C &#x3D; [&#39;x&#39; | &#39;y&#39;] extends Dog1 ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;\ntype D &#x3D; &#39;x&#39; | &#39;y&#39; extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; D &#x3D; &#39;yes&#39;</code></pre>\n\n<h4 id=\"4、泛型约束\"><a href=\"#4、泛型约束\" class=\"headerlink\" title=\"4、泛型约束\"></a>4、泛型约束</h4><p>在书写泛型时，往往需要对类型参数作一定对限制。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;\n  return obj[key];\n&#125;\n\nconst obj &#x3D; &#123;\n  name: &#39;tom&#39;,\n  age: 12,\n&#125;;\n\ngetInfo(obj, &#39;age&#39;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。</code></pre>\n\n<h4 id=\"5-ES6-类继承\"><a href=\"#5-ES6-类继承\" class=\"headerlink\" title=\"5. ES6 类继承\"></a>5. ES6 类继承</h4><h3 id=\"什么是联合类型\"><a href=\"#什么是联合类型\" class=\"headerlink\" title=\"什么是联合类型\"></a>什么是联合类型</h3><p>联合类型在 TypeScript 中非常有用，可以让我们更加灵活地定义类型，处理多种类型的数据，提高代码的可重用性和可扩展性。但是在使用联合类型时需要注意，<strong>如果一个变量或参数的类型是联合类型，那么它只能使用所有类型中的公共属性和方法，不能使用特定类型的属性和方法</strong>。因此，在编写代码时需要谨慎使用联合类型，避免出现类型错误</p>\n<h3 id=\"什么是交叉类型\"><a href=\"#什么是交叉类型\" class=\"headerlink\" title=\"什么是交叉类型\"></a>什么是交叉类型</h3><p>在 TypeScript 中，交叉类型是一种将多个类型合并为一个类型的方式。交叉类型使用 <code>&amp;</code> 运算符来连接多个类型，表示同时具有这些类型的特征。例如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface A &#123;\n  name: string;\n&#125;\n\ninterface B &#123;\n  age: number;\n&#125;\n\ntype C &#x3D; A &amp; B;\n\nconst person: C &#x3D; &#123; name: &#39;Tom&#39;, age: 18 &#125;;</code></pre>\n\n<p>在上面的示例中，我们定义了两个接口 <code>A</code> 和 <code>B</code>，分别具有 <code>name</code> 和 <code>age</code> 属性。然后，我们使用 <code>&amp;</code> 运算符将它们合并为一个新的类型 <code>C</code>，表示具有 <code>name</code> 和 <code>age</code> 属性的类型。最后，我们创建了一个类型为 <code>C</code> 的对象 <code>person</code>，它具有 <code>name</code> 和 <code>age</code> 属性。</p>\n<p>交叉类型可以让我们更加灵活地组合不同类型的特征，从而创建出更加复杂的类型。例如，我们可以将一个类型 <code>A</code> 和一个类型 <code>B</code> 合并为一个新类型 <code>C</code>，表示同时具有 <code>A</code> 和 <code>B</code> 的特征。然后，我们可以将类型 <code>C</code> 用于函数参数、变量类型等场景中，从而使程序更加灵活和健壮。</p>\n<p>需要注意的是，交叉类型只能表示同时具有多个类型的特征，而不能表示只具有某个类型的特征。如果需要表示某个类型的特征，可以使用联合类型。例如，如果一个变量可以是字符串类型或者数字类型，可以使用联合类型 <code>string | number</code> 表示。</p>\n<h3 id=\"交叉类型与联合类型的区别\"><a href=\"#交叉类型与联合类型的区别\" class=\"headerlink\" title=\"交叉类型与联合类型的区别\"></a>交叉类型与联合类型的区别</h3><ol>\n<li><code>交叉类型</code>使用 <code>&amp;</code> 运算符合并多个类型，<code>表示同时具有这些类型的特征</code>，适用于将多个类型合并为一个类型的场景。</li>\n<li><code>联合类型</code>使用 <code>|</code> 运算符连接多个类型，<code>表示具有这些类型中至少一个类型的特征</code>，适用于表示一个变量、参数、返回值等可以具有多种类型的场景。</li>\n</ol>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><h3 id=\"什么是-React\"><a href=\"#什么是-React\" class=\"headerlink\" title=\"什么是 React\"></a>什么是 React</h3><ol>\n<li>React 是一个用于构建用户界面的 JavaScript 库。</li>\n<li>它由 Facebook 开发并开源，现在已经成为了前端开发中最受欢迎的框架之一。</li>\n<li>React 的主要思想是将 UI 拆分成可重用的组件，这些组件可以随时进行组合和嵌套，以构建复杂的用户界面。</li>\n<li>React 使用虚拟 DOM（Virtual DOM）来实现高效的更新和渲染，通过仅更新实际更改的部分，避免了不必要的 DOM 操作和重新渲染整个页面的成本。</li>\n<li>React 还具有单向数据流（One-Way Data Binding）的特性，使得组件的状态和行为更加可控和易于维护。</li>\n<li>总的来说，React 是一个强大而灵活的工具，可以帮助开发人员构建快速、高效和易于维护的现代 Web 应用程序。</li>\n</ol>\n<h3 id=\"聊下-key\"><a href=\"#聊下-key\" class=\"headerlink\" title=\"聊下 key\"></a>聊下 key</h3><h3 id=\"为什么引入-key\"><a href=\"#为什么引入-key\" class=\"headerlink\" title=\"为什么引入 key\"></a>为什么引入 key</h3><p><strong>key 帮助 React 识别出被修改、添加或删除的 item</strong></p>\n<p><a href=\"https://react.docschina.org/docs/reconciliation.html#recursing-on-children\" target=\"_blank\" >深入解析为什么 key 是必须的</a></p>\n<h3 id=\"引入-key-的背景\"><a href=\"#引入-key-的背景\" class=\"headerlink\" title=\"引入 key 的背景\"></a>引入 key 的背景</h3><p>对子节点进行递归</p>\n<p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p>\n<p>在子元素列表末尾新增元素时，更新开销比较小。比如：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n  &lt;li&gt;third&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n\n<p>React 会先匹配两个 <code>&lt;li&gt;first&lt;/li&gt;</code> 对应的树，然后匹配第二个元素 <code>&lt;li&gt;second&lt;/li&gt;</code> 对应的树，最后插入第三个元素的 <code>&lt;li&gt;third&lt;/li&gt;</code> 树。</p>\n<p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;ul&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n\n<p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</p>\n<h3 id=\"key-解决这个问题\"><a href=\"#key-解决这个问题\" class=\"headerlink\" title=\"key 解决这个问题\"></a>key 解决这个问题</h3><p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2014&quot;&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre>\n\n<p>现在 React 知道只有带着 ‘2014’ key 的元素是新元素，带着 ‘2015’ 以及 ‘2016’ key 的元素仅仅移动了。</p>\n<p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;</code></pre>\n\n<p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p>\n<h3 id=\"key-有什么要求\"><a href=\"#key-有什么要求\" class=\"headerlink\" title=\"key 有什么要求\"></a>key 有什么要求</h3><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p>\n<h3 id=\"通常情况-key-不会用-index\"><a href=\"#通常情况-key-不会用-index\" class=\"headerlink\" title=\"通常情况 key 不会用 index\"></a>通常情况 key 不会用 index</h3><p>原因：</p>\n<ol>\n<li><p>使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。</p>\n</li>\n<li><p><strong>由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，</strong></p>\n</li>\n</ol>\n<h3 id=\"什么时候使用-key\"><a href=\"#什么时候使用-key\" class=\"headerlink\" title=\"什么时候使用 key\"></a>什么时候使用 key</h3><ol>\n<li>子元素列表时候需要用 key</li>\n<li>同级元素比如两个按钮，在使用三目运算符进行条件处理时候，也需要加 key，不加会出现，按钮事件被错误触发的现象，（这是由于 React 可中断渲染和合成事件共同作用引起的）</li>\n</ol>\n<h3 id=\"key-在源码单节点、多节点中的\"><a href=\"#key-在源码单节点、多节点中的\" class=\"headerlink\" title=\"key 在源码单节点、多节点中的\"></a>key 在源码单节点、多节点中的</h3><h3 id=\"diff-单节点、多节点\"><a href=\"#diff-单节点、多节点\" class=\"headerlink\" title=\"diff [单节点、多节点]\"></a>diff [单节点、多节点]</h3><h3 id=\"hooks-产生的原因\"><a href=\"#hooks-产生的原因\" class=\"headerlink\" title=\"hooks 产生的原因\"></a>hooks 产生的原因</h3><p>Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题</p>\n<h3 id=\"在组件之间复用状态逻辑很难\"><a href=\"#在组件之间复用状态逻辑很难\" class=\"headerlink\" title=\"在组件之间复用状态逻辑很难\"></a><code>在组件之间复用状态逻辑很难</code></h3><h3 id=\"复杂组件变得难以理解\"><a href=\"#复杂组件变得难以理解\" class=\"headerlink\" title=\"复杂组件变得难以理解\"></a><code>复杂组件变得难以理解</code></h3><p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。）</p>\n<h3 id=\"难以理解的-class\"><a href=\"#难以理解的-class\" class=\"headerlink\" title=\"难以理解的 class\"></a><code>难以理解的 class</code></h3><p>(除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。</p>\n<p>为了解决这些问题，</p>\n<ol>\n<li><code>Hook 使你在非 class 的情况下可以使用更多的 React 特性</code>。</li>\n<li>从概念上讲，<code>React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则</code>。</li>\n<li>Hook 提供了问题的解决方案，<code>无需学习复杂的函数式或响应式编程技术</code>。</li>\n</ol>\n<h3 id=\"useEffect-执行特点\"><a href=\"#useEffect-执行特点\" class=\"headerlink\" title=\"useEffect 执行特点\"></a>useEffect 执行特点</h3><h4 id=\"1-useEffect-做了什么？\"><a href=\"#1-useEffect-做了什么？\" class=\"headerlink\" title=\"1. useEffect 做了什么？\"></a>1. useEffect 做了什么？</h4><p>(<br>通过使用这个 Hook，你可以<code>告诉 React 组件需要在渲染后执行某些操作</code>。React 会保存你传递的函数（我们将它称之为 “effect”），<code>并且在执行 DOM 更新之后调用它</code>。<br>)</p>\n<h4 id=\"2-为什么在组件内部调用-useEffect？\"><a href=\"#2-为什么在组件内部调用-useEffect？\" class=\"headerlink\" title=\"2. 为什么在组件内部调用 useEffect？\"></a>2. 为什么在组件内部调用 useEffect？</h4><p>(<br>将 useEffect 放在组件内部,让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。<br>)</p>\n<h4 id=\"3-useEffect-会在每次渲染后都执行吗？\"><a href=\"#3-useEffect-会在每次渲染后都执行吗？\" class=\"headerlink\" title=\"3. useEffect 会在每次渲染后都执行吗？\"></a>3. useEffect 会在每次渲染后都执行吗？</h4><p>(<br>是的，<code>默认情况下，它在第一次渲染之后和每次更新之后都会执行</code>。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。<code>React 保证了每次运行 effect 的同时，DOM 都已经更新完毕</code>。<br>)</p>\n<h4 id=\"4-传递给-useEffect-的函数在每次渲染中都会有所不同\"><a href=\"#4-传递给-useEffect-的函数在每次渲染中都会有所不同\" class=\"headerlink\" title=\"4. 传递给 useEffect 的函数在每次渲染中都会有所不同\"></a>4. 传递给 useEffect 的函数在每次渲染中都会有所不同</h4><p>(<br>经验丰富的 JavaScript 开发人员可能会注意到，<code>传递给 useEffect 的函数在每次渲染中都会有所不同</code>，这是刻意为之的。<code>事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因</code>。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。<br>)</p>\n<h4 id=\"5-effect-异步执行\"><a href=\"#5-effect-异步执行\" class=\"headerlink\" title=\"5. effect 异步执行\"></a>5. effect 异步执行</h4><p>不需要同步地执行, 如果需要同步用 <code>useLayoutEffect</code></p>\n<h4 id=\"6-为什么要在-effect-中返回一个函数？\"><a href=\"#6-为什么要在-effect-中返回一个函数？\" class=\"headerlink\" title=\"6. 为什么要在 effect 中返回一个函数？\"></a>6. 为什么要在 effect 中返回一个函数？</h4><p>(<br>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。<br>)</p>\n<h4 id=\"7-React-何时清除-effect？\"><a href=\"#7-React-何时清除-effect？\" class=\"headerlink\" title=\"7. React 何时清除 effect？\"></a>7. React 何时清除 effect？</h4><p>(</p>\n<ol>\n<li><code>React 会在组件卸载的时候执行清除操作</code>。</li>\n<li>正如之前学到的，effect 在每次渲染的时候都会执行。<code>这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</code><br>)</li>\n</ol>\n<h3 id=\"useEffect-使用特点上？\"><a href=\"#useEffect-使用特点上？\" class=\"headerlink\" title=\"useEffect 使用特点上？\"></a>useEffect 使用特点上？</h3><ol>\n<li>提示: 使用多个 Effect 实现关注点分离</li>\n<li>解释：为什么每次更新的时候都要运行 Effect(<code>此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug</code>。)</li>\n<li>提示: 通过跳过 Effect 进行性能优化（<code>使用第二参数，未来版本，可能会在构建时自动添加第二个参数。</code>）</li>\n</ol>\n<h3 id=\"useEffect-实现原理\"><a href=\"#useEffect-实现原理\" class=\"headerlink\" title=\"useEffect 实现原理\"></a>useEffect 实现原理</h3><p><code>useEffect</code> 是 React 提供的一个用于处理副作用的 Hook，它的实现原理可以大致分为以下两步：</p>\n<ol>\n<li><p>在组件渲染时，React 将 <code>useEffect</code> 中的回调函数加入到“副作用队列”中。这个副作用队列是一个全局的任务队列，存储了所有需要处理的副作用任务。</p>\n</li>\n<li><p>在浏览器完成页面的渲染后，React 会开始处理副作用队列。React 会依次执行队列中的每个副作用任务，并将执行结果保存在内部的状态中。如果队列中有新的任务加入，React 会将新的任务加入队列的尾部，等待下一次处理。</p>\n</li>\n</ol>\n<p>在 <code>useEffect</code> 的实现中，React 会使用一个链表数据结构来管理副作用队列，每个链表节点代表一个副作用任务。当组件卸载时，React 会遍历这个链表，将所有的副作用任务进行清理。</p>\n<p>需要注意的是，<strong>在函数式组件中，由于每次渲染都会创建新的函数作用域，所以 <code>useEffect</code> 中的回调函数也会被重新创建</strong>。因此，当使用 <code>useEffect</code> 时，应该确保回调函数中不会引用过期的变量，否则会导致意外的结果。为了避免这种问题，可以使用 <code>useCallback</code> 或 <code>useMemo</code> 来缓存函数。</p>\n<h3 id=\"Hook-使用规则\"><a href=\"#Hook-使用规则\" class=\"headerlink\" title=\"Hook 使用规则\"></a>Hook 使用规则</h3><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>\n<ol>\n<li><code>只能在 React 的函数组件中调用 Hook</code>。不要在其他 JavaScript 函数中调用。</li>\n<li>只能<code>在函数最外层调用 Hook</code>。<code>不要在循环</code>、<code>条件判断</code>或者<code>子函数中调用</code>。</li>\n<li>在自定义的 Hook 中</li>\n</ol>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><ol>\n<li>挂载：constructor()、static getDerivedStateFromProps()、render()、componentDidMount()</li>\n<li>更新：static getDerivedStateFromProps()、shouldComponentUpdate()、render()、getSnapshotBeforeUpdate()、componentDidUpdate()</li>\n<li>错误处理：static getDerivedStateFromError()、componentDidCatch()</li>\n<li>卸载：componentWillUnmount()</li>\n</ol>\n<p><strong>react 生命周期函数：</strong></p>\n<ol>\n<li><p>constructor()：组件构造函数，在组件挂载之前调用；<code>仅用于初始化内部 state 以及为事件处理函数绑定实例</code>；</p>\n</li>\n<li><p><code>static getDerivedStateFromProps()</code>：会在调用 render 方法之前调用，并且<code>在初始挂载及后续更新时都会被调用</code>，此方法适用于 state 的值在任何时候都取决于 props；</p>\n</li>\n<li><p>render()：是 class 组件中唯一必须实现的方法；</p>\n</li>\n<li><p>componentDidMount：会在组件挂载后（插入 DOM 树中）立即调用；</p>\n</li>\n<li><p>shouldComponentUpdate()：根据该函数的返回值，来确定组件是否重新渲染；</p>\n</li>\n<li><p>getSnapshotBeforeUpdate()：在最近一次渲染输出（提交到 DOM 节点）之前调用；<code>此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()</code>；</p>\n</li>\n<li><p>componentDidUpdate()：会在更新后会被立即调用，首次渲染不会执行此方法；</p>\n</li>\n<li><p>componentWillUnmount()：会在组件卸载及销毁之前直接调用；</p>\n</li>\n<li><p><code>static getDerivedStateFromError()</code>：此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state；它会在渲染阶段调用，因此不允许出现副作用</p>\n</li>\n<li><p><code>componentDidCatch()</code>：此生命周期在后代组件抛出错误后被调用，会在“提交”阶段被调用，因此允许执行副作用。</p>\n</li>\n</ol>\n<h3 id=\"父子组件生命周期函数执行顺序：\"><a href=\"#父子组件生命周期函数执行顺序：\" class=\"headerlink\" title=\"父子组件生命周期函数执行顺序：\"></a>父子组件生命周期函数执行顺序：</h3><p>父子组件生命周期函数执行顺序：</p>\n<p><strong>类组件</strong></p>\n<p><strong>进入页面：</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">parent-constructor -&gt;\nparent-getDerivedStateFromProps -&gt;\nparent-render -&gt;\n\nchild-constructor -&gt;\nchild-getDerivedStateFromProps -&gt;\nchild-render -&gt;\nchild-componentDidMount -&gt;\n\nparent-componentDidMount\n&#x2F;&#x2F; （子组件先挂载，父组件后挂载）</code></pre>\n\n<p><strong>更新页面：</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">parent-getDerivedStateFromProps -&gt;\nparent-shouldComponentUpdate -&gt;\nparent-render -&gt;\n\nchild-getDerivedStateFromProps -&gt;\nchild-shouldComponentUpdate -&gt;\nchild-render -&gt;\nchild-componentDidUpdate -&gt;\n\nparent-componentDidUpdate\n&#x2F;&#x2F; （子组件先更新，父组件后更新）</code></pre>\n\n<p><strong>销毁页面：</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">parent-componentWillUnmount -&gt;\nchild-componentWillUnmount\n\n&#x2F;&#x2F;（父组件先 willUnmount，子组件后 willlUnmount）</code></pre>\n\n<p><a href=\"https://www.cnblogs.com/foreveronlymiss/p/15387022.html\" target=\"_blank\" >见</a></p>\n<p><strong>函数组件</strong></p>\n<p>子组件先于父组件</p>\n<p><a href=\"https://blog.csdn.net/qq_35770417/article/details/120706178\" target=\"_blank\" >见</a></p>\n<h3 id=\"严格模式-StrictMode\"><a href=\"#严格模式-StrictMode\" class=\"headerlink\" title=\"严格模式 StrictMode\"></a>严格模式 StrictMode</h3><ol>\n<li>环境： 严格模式检查<code>仅在开发模式下运行</code>；它们不会影响生产构建</li>\n<li>范围：<code>它为其后代元素触发额外的检查和警告</code></li>\n<li>作用：<code>突出显示应用程序中潜在问题的工具</code>，不会渲染任何可见的 UI</li>\n</ol>\n<p>作用具体表现：</p>\n<ol>\n<li>识别<code>不安全的生命周期</code>（使用了第三方库，很难确保它们不使用这些生命周期方法）</li>\n<li>使用过时<code>字符串 ref API</code>、 <code>context API</code></li>\n<li>使用<code>废弃的 findDOMNode 方法</code>的警告</li>\n<li><code>检测意外的副作用</code></li>\n<li>确保可复用状态（在未来，我们希望增加一个功能，允许 React 在保留 state 的同时对 UI 进行增删）</li>\n</ol>\n<h3 id=\"协调\"><a href=\"#协调\" class=\"headerlink\" title=\"协调\"></a>协调</h3><p>当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。</p>\n<h3 id=\"什么是“协调”\"><a href=\"#什么是“协调”\" class=\"headerlink\" title=\"什么是“协调”\"></a>什么是“协调”</h3><ol>\n<li>是什么： 是 React 中一种用于更新视图的机制</li>\n<li>原理是： 协调算法采用了一种称为“双缓存技术”的方式</li>\n<li>执行过程：diff 启发式算法进行比较、构建虚拟 dom 树，进行更新</li>\n<li>收益：React 可以在避免大量 DOM 操作的同时，高效地更新视图</li>\n</ol>\n<p>“协调”（reconciliation）<strong>是 React 中一种用于更新视图的机制</strong>。它是 <strong>React 实现高效更新的核心算法</strong>，也是 React 的重要特性之一。</p>\n<p>在 React 中，当组件的状态（state）或属性（props）发生变化时，会触发重新渲染。在重新渲染之前，React 会先通过协调算法对新旧虚拟 DOM 树进行比较，找出需要更新的部分，然后才会重新渲染这些部分。</p>\n<p><strong>协调算法采用了一种称为“双缓存技术”的方式</strong>，<br>它会创建两个虚拟 DOM 树，一个是当前的虚拟 DOM 树，另一个是新的虚拟 DOM 树。<br>当需要更新时，React 会先将新的虚拟 DOM 树与当前的虚拟 DOM 树进行比较，找出需要更新的部分，并在新的虚拟 DOM 树上进行修改。<br>然后，React 会将新的虚拟 DOM 树渲染成真实的 DOM 树，并将其与当前的 DOM 树进行比较，找出需要更新的部分。<br>最后，React 将需要更新的部分更新到浏览器中，完成一次渲染。</p>\n<p>通过协调算法，React 可以在避免大量 DOM 操作的同时，高效地更新视图。这也是 React 能够在大型应用程序中表现出色的原因之一。</p>\n<h3 id=\"react17-版本前后合成事件执行顺序有什么变化\"><a href=\"#react17-版本前后合成事件执行顺序有什么变化\" class=\"headerlink\" title=\"react17 版本前后合成事件执行顺序有什么变化\"></a>react17 版本前后合成事件执行顺序有什么变化</h3><p>在 React 17 版本之前，合成事件和原生事件的执行顺序有所不同。具体来说，React 16 及以下版本中的事件处理过程如下：</p>\n<ol>\n<li><p>当一个合成事件和一个原生事件都绑定在同一个元素上时，React 会先调用组件上的事件处理函数，执行合成事件。</p>\n</li>\n<li><p>如果在合成事件处理函数中调用了 <code>event.stopPropagation()</code> 方法阻止事件冒泡，那么原生事件不会被触发。</p>\n</li>\n<li><p>如果合成事件处理函数执行完成后，没有调用 <code>event.stopPropagation()</code> 方法，则 React 会直接触发原生事件。</p>\n</li>\n<li><p><strong>原生事件系统按照事件冒泡的方式，从当前元素开始，逐级向上执行所有元素的事件处理函数，直到文档根节点。</strong></p>\n</li>\n</ol>\n<p>React 17 版本中的事件处理过程有所改变。具体来说，React 17 中的事件处理过程如下：</p>\n<ol>\n<li><p>当一个合成事件和一个原生事件都绑定在同一个元素上时，React 会先调用组件上的事件处理函数，执行合成事件。</p>\n</li>\n<li><p>如果在合成事件处理函数中调用了 <code>event.stopPropagation()</code> 方法阻止事件冒泡，那么原生事件也不会被触发。</p>\n</li>\n<li><p>如果合成事件处理函数执行完成后，没有调用 <code>event.stopPropagation()</code> 方法，则 React 会将事件传递给原生事件系统，但是不会立即触发原生事件。</p>\n</li>\n<li><p><strong>当 React 完成整个更新过程后，会统一处理原生事件。在这个过程中，React 会按照事件冒泡的方式，从当前元素开始，逐级向上执行所有元素的事件处理函数，直到文档根节点。</strong></p>\n</li>\n</ol>\n<p>因此，React 17 中的事件处理过程更符合开发者的直觉，也更加安全和可靠。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202305061222021.webp\" />\n\n<h2 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h2><ol>\n<li>是什么</li>\n<li>为什么</li>\n<li>实现原理</li>\n<li>17 版本前后有什么区别</li>\n</ol>\n<h3 id=\"合成事件的捕获和冒泡如何实现\"><a href=\"#合成事件的捕获和冒泡如何实现\" class=\"headerlink\" title=\"合成事件的捕获和冒泡如何实现\"></a>合成事件的捕获和冒泡如何实现</h3><p>数组正反序遍历</p>\n<h3 id=\"父子组件合成事件的捕获和冒泡执行顺序\"><a href=\"#父子组件合成事件的捕获和冒泡执行顺序\" class=\"headerlink\" title=\"父子组件合成事件的捕获和冒泡执行顺序\"></a>父子组件合成事件的捕获和冒泡执行顺序</h3><p>V17 之前，<code>合成事件和原生事件的执行顺序与冒泡/捕获模式无关</code>,</p>\n<p><code>原生事件恒早于合成事件</code></p>\n<p>V17 后，<code>合成事件和原生事件的执行顺序与冒泡/捕获模式相关</code>，</p>\n<ol>\n<li><code>捕获模式，合成事件早于原生事件</code>。</li>\n<li><code>冒泡模式，原生事件早于合成事件</code>，</li>\n<li>React 17 将事件委托放在了 root 上而不是以前的 document 上</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; V17.0.2 document 原生事件 &gt; 合成事件（父 -&gt; 子） &gt; 原生事件（父 -&gt; 子）\n&#x2F;&#x2F; 原生事件：document DOM 事件监听！\n&#x2F;&#x2F; React 事件：父元素事件监听！\n&#x2F;&#x2F; React 事件：子元素事件监听！\n&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！\n&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; V16.14.0 document 原生事件 &gt; 原生事件（父 -&gt; 子）&gt; 合成事件（父 -&gt; 子）\n&#x2F;&#x2F; 原生事件：document DOM 事件监听！\n&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！\n&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！\n&#x2F;&#x2F; React 事件：父元素事件监听！\n&#x2F;&#x2F; React 事件：子元素事件监听！</code></pre>\n\n<p>作者：活抓一只小机灵<br>链接：<a href=\"https://juejin.cn/post/7005129812981317668\">https://juejin.cn/post/7005129812981317668</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"合成事件-1\"><a href=\"#合成事件-1\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h3><p>在 React 中，<strong>合成事件是指在浏览器原生事件基础上封装出来的一种事件系统，React 在组件的根节点上注册事件监听器，然后将事件通过事件池（Event Pool）传递给组件，供组件内部使用</strong>。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>相比原生事件，合成事件具有如下优点：</p>\n<ol>\n<li><p><code>跨浏览器兼容性好</code>：React 的合成事件系统可以跨浏览器兼容，无需考虑浏览器兼容性问题。</p>\n</li>\n<li><p><code>性能更好</code>：React 会在事件池中重复利用合成事件对象，避免了频繁创建和销毁事件对象的开销，从而提高了性能。</p>\n</li>\n<li><p><code>更好的事件处理机制</code>：React 的合成事件系统可以将事件处理函数中的 <code>this</code> 指向组件实例，避免了使用 <code>bind</code> 方法或箭头函数绑定 <code>this</code> 的麻烦。</p>\n</li>\n<li><p><code>更好的事件委托机制</code>：React 的合成事件系统可以方便地进行事件委托，将事件绑定在父组件上，从而避免了给每个子组件都绑定事件监听器的开销。</p>\n</li>\n</ol>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><p><strong>需要注意的是，</strong></p>\n<ol>\n<li>由于合成事件是在组件根节点上注册的，因此如果事件的目标元素被更新或卸载，而组件根节点没有被更新或卸载，那么事件处理函数可能会出现错误。</li>\n<li>为了避免这种情况，应该在组件卸载时，手动将组件的事件监听器从组件根节点上卸载。</li>\n</ol>\n<h3 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h3><p>是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口。</p>\n<h3 id=\"要使用浏览器的底层事件？\"><a href=\"#要使用浏览器的底层事件？\" class=\"headerlink\" title=\"要使用浏览器的底层事件？\"></a>要使用浏览器的底层事件？</h3><p>需要使用 nativeEvent 属性来获取</p>\n<h3 id=\"变化？\"><a href=\"#变化？\" class=\"headerlink\" title=\"变化？\"></a>变化？</h3><p>从 v17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中。</p>\n<h3 id=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"><a href=\"#在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\" class=\"headerlink\" title=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"></a>在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</h3><p>如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。</p>\n<h3 id=\"事件委托的变更\"><a href=\"#事件委托的变更\" class=\"headerlink\" title=\"事件委托的变更\"></a>事件委托的变更</h3><ol>\n<li>React v17 中，React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中</li>\n<li>原因：经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。</li>\n</ol>\n<h3 id=\"全新的-JSX-转换\"><a href=\"#全新的-JSX-转换\" class=\"headerlink\" title=\"全新的 JSX 转换\"></a>全新的 JSX 转换</h3><p>此时源代码无需引入 React 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）</p>\n<p>此变化与所有现有 JSX 代码兼容，所以你无需修改组件。如果你对此感兴趣，你可以查看 RFC 了解全新转换工作的具体细节。</p>\n<p>特点：</p>\n<ul>\n<li>新的 JSX 转换不依赖 React 环境</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>不需要引入 React 使用全新的转换，你可以单独使用 JSX 而无需引入 React。</li>\n<li>改善 bundle 根据你的配置，JSX 的编译输出可能会略微改善 bundle 的大小。</li>\n<li>以备未来之需 它将减少你需要学习 React 概念的数量，以备未来之需。</li>\n</ul>\n<h3 id=\"副作用清理时间\"><a href=\"#副作用清理时间\" class=\"headerlink\" title=\"副作用清理时间\"></a>副作用清理时间</h3><ul>\n<li>React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。</li>\n<li>React 16 只对组件内的 effect 保证这种顺序。</li>\n</ul>\n<h3 id=\"React17-重大更改\"><a href=\"#React17-重大更改\" class=\"headerlink\" title=\"React17 重大更改\"></a>React17 重大更改</h3><ol>\n<li><code>更改事件委托</code></li>\n<li><code>对标浏览器，对事件系统进行小改</code></li>\n<li><code>去除事件池</code> 不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水 （因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。）</li>\n<li><code>副作用清理时间</code><ol>\n<li><ul>\n<li>React 17 将<code>在运行任何新副作用之前执行所有副作用的清理函数</code>（针对所有组件）。</li>\n</ul>\n</li>\n<li><ul>\n<li>React 16 只对组件内的 effect 保证这种顺序。）</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><code>返回一致的 undefined 错误</code>，（算是改 bug 了，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错）</li>\n<li><code>原生组件栈</code> （生产环境提示更友好。<ol>\n<li>在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。<em>React 实现这一点的方式有点非常规</em> 。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。</li>\n<li>因此，<em>当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息</em> ）</li>\n</ol>\n</li>\n<li><code>移除私有导出</code>（与 react 关联不是很大的部分被移出）</li>\n</ol>\n<h3 id=\"react18-新特性\"><a href=\"#react18-新特性\" class=\"headerlink\" title=\"react18 新特性\"></a>react18 新特性</h3><ol>\n<li><p>修 bug</p>\n<ol>\n<li>由于并发模式可能带来破坏，所以 react18 的并发模式可选</li>\n<li><code>Suspense fallback=&#123;undefined&#125;</code> 表现与<code>null</code>相同</li>\n</ol>\n</li>\n<li><p>增加开发体验</p>\n<ol>\n<li>自动批处理: 之前需要使用 <code>ReactDOM.unstable_batchedUpdates</code>, 现在： 超时、promise、本机事件处理程序、任何其他事件被批处理</li>\n<li>内置 <code>React.lazy + Suspense</code></li>\n<li><code>useId</code>: 生成唯一 ID</li>\n<li><code>useTransition、useDeferredValue</code>: 将紧急更新与非紧急更新分开</li>\n<li>2 个新的<code>渲染api</code>: <code>createRoot</code> 和 <code>hydrateRoot</code> ：应用的根节点也向我们暴露了出来，渲染整个应用的时候只需要调用 root 的 render 方法</li>\n</ol>\n</li>\n<li><p>为其他框架库提供扩展</p>\n<ol>\n<li><code>useInsertionEffect</code>: 为 CSS-in-JS 库添加 <a href=\"https://segmentfault.com/a/1190000040966821#:~:text=/%3E%0A%20%20%20%20%3C/%3E%0A%20%20)%3B%0A)%3B-,useInsertionEffect,-%E7%94%A8%E4%BA%8E%E6%8F%92%E5%85%A5%E5%85%A8%E5%B1%80\" target=\"_blank\" >见</a></li>\n<li><code>useSyncExternalStore</code>: 帮助外部存储库与 React 集成。 <a href=\"https://juejin.cn/post/7056588815170813965\" target=\"_blank\" >见</a></li>\n</ol>\n</li>\n<li><p>为以后做准备</p>\n<ol>\n<li>严格模式模拟卸载和重新挂载</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><h4 id=\"componentDidCatch\"><a href=\"#componentDidCatch\" class=\"headerlink\" title=\"componentDidCatch\"></a>componentDidCatch</h4><p>React 的开发和生产构建版本在 componentDidCatch() 的方式上有轻微差别。</p>\n<ol>\n<li>在开发模式下，错误会冒泡至 window，这意味着任何 window.onerror 或 window.addEventListener(‘error’, callback) 会中断这些已经被 componentDidCatch() 捕获的错误。</li>\n<li>在生产模式下，错误不会冒泡</li>\n</ol>\n<h4 id=\"static-getDerivedStateFromError\"><a href=\"#static-getDerivedStateFromError\" class=\"headerlink\" title=\"static getDerivedStateFromError()\"></a>static getDerivedStateFromError()</h4><ol>\n<li><code>getDerivedStateFromError() </code>会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class ErrorBoundary extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; hasError: false &#125;;\n  &#125;\n\n  static getDerivedStateFromError(error) &#123;\n    &#x2F;&#x2F; 更新 state 使下一次渲染可以显降级 UI\n    return &#123; hasError: true &#125;;\n  &#125;\n\n  render() &#123;\n    if (this.state.hasError) &#123;\n      &#x2F;&#x2F; 你可以渲染任何自定义的降级  UI\n      return &lt;h1&gt;Something went wrong.&lt;&#x2F;h1&gt;;\n    &#125;\n\n    return this.props.children;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"使用-Redux-与不使用-Redux-有什么区别\"><a href=\"#使用-Redux-与不使用-Redux-有什么区别\" class=\"headerlink\" title=\"使用 Redux 与不使用 Redux 有什么区别\"></a>使用 Redux 与不使用 Redux 有什么区别</h2><p>Redux 是一个状态管理库，它提供了一种规范化的方式来管理应用程序的状态。使用 Redux 和不使用 Redux 之间的区别在于应用程序的状态管理方式和应用程序的复杂度。</p>\n<ol>\n<li><p><code>状态管理方式</code>：在没有 Redux 的情况下，应用程序的状态通常存储在组件的本地状态中，而且需要通过 props 将状态传递给子组件，这种方式通常称为“自上而下”（Top-down）的数据流。而使用 Redux，应用程序的状态存储在全局的 store 中，每个组件都可以访问 store 中的状态，这种方式称为“单向数据流”（Unidirectional data flow）。</p>\n</li>\n<li><p><code>应用程序的复杂度</code>：当应用程序的状态变得复杂时，使用 Redux 可以使应用程序更易于管理。Redux 提供了一种规范化的状态管理方式，可以使状态的变化更加可预测和可控，也方便了状态的调试和测试。而在简单的应用程序中，使用 Redux 可能会增加代码的复杂度和维护成本。</p>\n</li>\n<li><p><code>开发效率</code>：使用 Redux 可以提高开发效率，<strong>因为 Redux 提供了一些工具和中间件，可以方便地处理异步操作、路由和调试等问题</strong>。同时，使用 Redux 也可以使应用程序的代码更具可读性和可维护性。</p>\n</li>\n</ol>\n<p>总之，使用 Redux 和不使用 Redux 之间的区别在于状态管理方式和应用程序的复杂度。Redux 可以使应用程序更易于管理和调试，提高开发效率，但在简单的应用程序中可能会增加代码的复杂度和维护成本。需要根据具体应用场景来选择是否使用 Redux。</p>\n<h2 id=\"Redux-常用的中间件有哪些\"><a href=\"#Redux-常用的中间件有哪些\" class=\"headerlink\" title=\"Redux 常用的中间件有哪些\"></a>Redux 常用的中间件有哪些</h2><p>Redux 是一个状态管理库，它本身并没有<code>提供异步处理</code>、<code>日志记录</code>、<code>路由</code>等额外的功能，但是<code>它提供了一个灵活的中间件（Middleware）机制</code>，<code>允许开发者在 Redux 的 Action 被发起之后，到达 Reducer 之前，对 Action 进行拦截、解释或者修改等处理</code>。</p>\n<p>下面是一些常用的 Redux 中间件：</p>\n<ol>\n<li><p><code>Redux Thunk</code>：Redux Thunk 是一个允许 Action Creator 返回函数的中间件，这样我们就可以在 Action Creator 内部执行异步操作（例如发送 AJAX 请求），并且在异步操作结束后再去派发真正的 Action。使用 Redux Thunk 可以简化异步 Action 的处理。</p>\n</li>\n<li><p><code>Redux Saga</code>：Redux Saga 是一个基于 Generator 的中间件，它提供了一种基于 ES6 Generator 的异步处理方式。<code>使用 Redux Saga 可以将异步操作转化为同步的、可测试的代码</code>，它使用简洁的语法和强大的控制流来处理异步操作。</p>\n</li>\n<li><p><code>Redux Promise</code>：<code>Redux Promise 是一个允许 Action Creator 返回 Promise 的中间件，它将 Promise 解析成值，并将其作为 Action 发送到 Reducer</code>。</p>\n</li>\n<li><p><code>Redux Logger</code>：<code>Redux Logger 是一个记录 Redux Action 和状态变化的中间件，它可以帮助开发者更好地了解应用程序中发生的事情</code>。</p>\n</li>\n<li><p><code>Redux Immutable State Invariant</code>：Redux Immutable State Invariant 是一个用于检测不可变状态（Immutable State）的中间件，它可以在开发过程中帮助开发者发现可能存在的状态变异问题。</p>\n</li>\n<li><p><code>Redux-Thunk-Saga</code>：<code>Redux-Thunk-Saga 是一个结合了 Redux Thunk 和 Redux Saga 的中间件，它提供了一种同时支持同步和异步 Action 的处理方式</code>。</p>\n</li>\n</ol>\n<p>总之，Redux 中间件提供了一种简单、灵活的方式来扩展 Redux 功能，开发者可以根据需要选择适合自己的中间件。以上仅是一些常用的中间件，实际使用时还可以根据具体需求进行选择和扩展。</p>\n<h2 id=\"如何简化-Action-和-Reducer-的定义\"><a href=\"#如何简化-Action-和-Reducer-的定义\" class=\"headerlink\" title=\"如何简化 Action 和 Reducer 的定义\"></a>如何简化 Action 和 Reducer 的定义</h2><p>使用 <code>redux-actions</code>: <code>createAction</code>、 <code>createReducer</code>、 <code>handleActions</code></p>\n<p><code>redux-action 的动机</code>： Redux 使数据存储突变变得可预测，但它也使它们变得冗长。这个工具是考虑到这一点而制作的。大量的样板可能会让编写和阅读变得痛苦。在动作创建者和简化器中跟踪动作字符串常量对初学者来说可能是压倒性的。redux-action 是 Redux 中符合 FSA 的动作的实用工具带。有了处理和创建动作的助手，每个人都可以更轻松地在 Redux 中使用 FSA</p>\n<p>Redux 提供了一些辅助函数来简化 Action 和 Reducer 的定义，下面介绍一些常用的函数：</p>\n<ol>\n<li><code>createAction</code>: <code>createAction</code>是一个用于创建 Action Creator 的函数，它接收一个字符串类型的 Action 类型和一个处理函数，并返回一个 Action Creator。使用<code>createAction</code>函数可以简化 Action 的定义，同时可以使 Action Creator 具备可读性。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createAction &#125; from &#39;redux-actions&#39;;\n\nconst increment &#x3D; createAction(&#39;INCREMENT&#39;, (value) &#x3D;&gt; (&#123; payload: value &#125;));\n\n&#x2F;&#x2F; 上面代码等价于\nconst increment &#x3D; (value) &#x3D;&gt; (&#123;\n  type: &#39;INCREMENT&#39;,\n  payload: value,\n&#125;);</code></pre>\n\n<ol start=\"2\">\n<li><code>createReducer</code>: <code>createReducer</code>是一个用于创建 Reducer 的函数，它接收一个初始状态和一组 Action 处理函数，返回一个 Reducer。使用<code>createReducer</code>函数可以简化 Reducer 的定义，同时可以使 Reducer 具备可读性。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createReducer &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; createReducer(0, &#123;\n  INCREMENT: (state, action) &#x3D;&gt; state + action.payload,\n  DECREMENT: (state, action) &#x3D;&gt; state - action.payload,\n&#125;);\n\n&#x2F;&#x2F; 上面代码等价于\nconst counterReducer &#x3D; (state &#x3D; 0, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;INCREMENT&#39;:\n      return state + action.payload;\n    case &#39;DECREMENT&#39;:\n      return state - action.payload;\n    default:\n      return state;\n  &#125;\n&#125;;</code></pre>\n\n<ol start=\"3\">\n<li><code>handleActions</code>: <code>handleActions</code>是一个用于创建 Reducer 的函数，它接收一个 Action 处理函数的对象和一个初始状态，返回一个 Reducer。使用<code>handleActions</code>函数可以简化 Reducer 的定义，同时可以使 Reducer 具备可读性。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; handleActions &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleActions(\n  &#123;\n    INCREMENT: (state, action) &#x3D;&gt; state + action.payload,\n    DECREMENT: (state, action) &#x3D;&gt; state - action.payload,\n  &#125;,\n  0\n);\n\n&#x2F;&#x2F; 上面代码等价于\nconst counterReducer &#x3D; (state &#x3D; 0, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;INCREMENT&#39;:\n      return state + action.payload;\n    case &#39;DECREMENT&#39;:\n      return state - action.payload;\n    default:\n      return state;\n  &#125;\n&#125;;</code></pre>\n\n<p>通过使用 Redux 提供的辅助函数，我们可以简化 Action 和 Reducer 的定义，使其更具可读性和可维护性。同时，这些辅助函数还可以帮助我们避免一些常见的错误。</p>\n<h3 id=\"redux-actions-有哪些-API\"><a href=\"#redux-actions-有哪些-API\" class=\"headerlink\" title=\"redux-actions 有哪些 API\"></a>redux-actions 有哪些 API</h3><p><code>redux-actions</code> 是一个用于简化 Redux Action 和 Reducer 定义的工具库，其提供了以下几个 API：</p>\n<ol>\n<li><code>createAction(type, payloadCreator, metaCreator)</code>: 一个用于创建 action creator 的工厂函数，接收一个 action 类型字符串以及一个 payloadCreator 函数和一个 metaCreator 函数（可选）。<code>payloadCreator</code> 和 <code>metaCreator</code> 函数都是可选的，但至少需要提供一个。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createAction &#125; from &#39;redux-actions&#39;;\n\nconst increment &#x3D; createAction(&#39;INCREMENT&#39;, (value) &#x3D;&gt; (&#123; payload: value &#125;));\nconst decrement &#x3D; createAction(&#39;DECREMENT&#39;, (value) &#x3D;&gt; (&#123; payload: value &#125;));</code></pre>\n\n<ol start=\"2\">\n<li><code>createActions(actionMap, ...identityActions)</code>: 一个用于创建多个 action creator 的工厂函数，接收一个 action 创建器对象和任意数量的 action 类型字符串，它将返回一个包含所有创建的 action creator 的对象。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createActions &#125; from &#39;redux-actions&#39;;\n\nconst &#123; increment, decrement &#125; &#x3D; createActions(&#123;\n  INCREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n  DECREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n&#125;);\n\n&#x2F;&#x2F; 使用 identityActions 选项添加额外的 action creator\nconst &#123; increment, decrement, reset &#125; &#x3D; createActions(\n  &#123;\n    INCREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n    DECREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n  &#125;,\n  &#39;RESET&#39;\n);</code></pre>\n\n<ol start=\"3\">\n<li><code>handleAction(type, reducer, initialState)</code>: 一个用于创建 reducer 的工厂函数，接收一个 action 类型字符串、一个 reducer 函数以及一个初始状态，它将返回一个 reducer 函数。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; handleAction &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleAction(&#39;INCREMENT&#39;, (state, action) &#x3D;&gt; state + action.payload, 0);</code></pre>\n\n<ol start=\"4\">\n<li><code>handleActions(reducerMap, initialState)</code>: 一个用于创建多个 reducer 的工厂函数，接收一个 reducer 函数对象和一个初始状态，它将返回一个 reducer 函数。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; handleActions &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleActions(\n  &#123;\n    INCREMENT: (state, action) &#x3D;&gt; state + action.payload,\n    DECREMENT: (state, action) &#x3D;&gt; state - action.payload,\n  &#125;,\n  0\n);</code></pre>\n\n<ol start=\"5\">\n<li><code>combineActions(...types)</code>: 一个用于将多个 action 类型字符串组合成一个字符串的函数，通常用于在 reducer 中处理多个 action。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; combineActions &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleAction(combineActions(&#39;INCREMENT&#39;, &#39;DECREMENT&#39;), (state, action) &#x3D;&gt; state + action.payload, 0);</code></pre>\n\n<p>除此之外，<code>redux-actions</code> 还提供了一些实用工具函数，例如：<code>createSelector</code>, <code>createAsyncAction</code>, <code>createActionWithReducer</code>, <code>createCurriedAction</code> 等。这些工具函数可以根据需要在项目中灵活使用。</p>\n<h2 id=\"React-与-Vue-的区别\"><a href=\"#React-与-Vue-的区别\" class=\"headerlink\" title=\"React 与 Vue 的区别\"></a>React 与 Vue 的区别</h2><p>React 和 Vue 都是现代的 JavaScript 框架，用于构建用户界面。它们有很多相似的特性，例如组件化、虚拟 DOM 和响应式数据绑定，但也有</p>\n<h3 id=\"一些重要的区别：\"><a href=\"#一些重要的区别：\" class=\"headerlink\" title=\"一些重要的区别：\"></a>一些重要的区别：</h3><ol>\n<li>数据绑定</li>\n<li>模版语法</li>\n<li>组件设计</li>\n<li>社区生态</li>\n<li>性能表现</li>\n<li>开发工具</li>\n</ol>\n<p>详细信息</p>\n<ol>\n<li><p><code>响应式数据绑定</code>：</p>\n<ol>\n<li>在 Vue 中，数据绑定是双向的，意味着当数据发生变化时，视图也会相应地更新；而在 React 中，数据流是单向的，即数据的更改只能从父组件传递到子组件。</li>\n<li>React 更强调单向数据流的思想，以及数据的不可变性，这有助于降低复杂度和提高性能。</li>\n</ol>\n</li>\n<li><p><code>模板语法</code>：</p>\n<ol>\n<li>Vue 使用模板语法来描述界面，类似于 HTML，让开发人员可以直接看到界面结构；</li>\n<li>而 React 则使用 JSX 语法，将组件的结构、行为和样式都组合在一起，以更加灵活和自由的方式构建界面。</li>\n</ol>\n</li>\n<li><p><code>组件设计</code>：</p>\n<ol>\n<li>Vue 的组件通常是一个组合了模板、样式和行为的单元，其中模板和逻辑部分的组合方式更为紧密；</li>\n<li>而 React 更注重组件的设计，以实现高度复用性和可测试性。React 的组件更像是一个纯粹的函数，接收 props 参数，然后渲染出对应的 UI。</li>\n</ol>\n</li>\n<li><p><code>社区生态</code>：</p>\n</li>\n<li><p>Vue 在国内拥有更为庞大和活跃的社区，支持中文文档和教程，更容易上手和学习；</p>\n</li>\n<li><p>而 React 则更加国际化，其社区在全球范围内都很活跃，拥有更多的第三方库和插件，也更容易与其他技术栈集成。</p>\n</li>\n<li><p><code>学习曲线</code>：</p>\n</li>\n<li><p>Vue 在学习上相对于 React 更加容易，其文档和教程更加易于理解和上手。Vue 也更像传统的 MVVM 框架，对于从后端开发转型前端的开发人员来说更为友好。</p>\n</li>\n<li><p>而 React 则需要更多的 JavaScript 知识和函数式编程思想的理解，需要一定的学习曲线。</p>\n</li>\n<li><p><code>性能表现</code>：</p>\n<ol>\n<li>React 对于大型应用程序的性能表现更好，因为它使用了虚拟 DOM 技术，可以更快速地更新 UI。</li>\n<li>而 Vue 的性能表现在小型应用程序中较为优秀。</li>\n</ol>\n</li>\n<li><p><code>开发者工具</code>：Vue 开发者工具提供了比 React 更好的调试和排查工具，能够更好地帮助开发人员定位和解决问题。</p>\n</li>\n</ol>\n<p>总之，React 和 Vue 都是优秀的前端框架，选择哪一个取决于具体项目需求、开发团队的技能水平和偏好等因素。在大型应用程序中，React 更为适用；而对于小型应用程序和快速原型开发，则更建议使用 Vue。</p>\n<h3 id=\"React-和-Vue-的实现原理有一些区别\"><a href=\"#React-和-Vue-的实现原理有一些区别\" class=\"headerlink\" title=\"React 和 Vue 的实现原理有一些区别\"></a>React 和 Vue 的实现原理有一些区别</h3><p><code>React使用虚拟DOM（Virtual DOM）实现高效的UI更新</code>。每个 React 组件都有一个对应的虚拟 DOM 树，当组件的状态发生变化时，React 会重新生成虚拟 DOM 树，并比较前后两棵树的差异，然后只更新变化的部分，最后将变化的部分应用到真实 DOM 上。这种方式避免了频繁的 DOM 操作，提高了 UI 更新的效率。</p>\n<p>Vue<code>使用模板和响应式数据绑定来实现UI的更新</code>。Vue 将数据绑定到视图上，当数据发生变化时，Vue 会自动更新视图。Vue 使用一个 Observer 来监听数据的变化，同时也使用了异步批量更新的机制，以最小化 DOM 操作次数，从而提高性能。</p>\n<p>另外，React 和 Vue 的组件化方式也略有不同。React 的组件通常是一个函数，输入一些参数，输出一个对应的 UI 组件。而 Vue 的组件则是一个对象，包含了模板、样式和行为等多个部分。React 更加强调单向数据流，组件间数据的传递一般都是从父组件到子组件。而 Vue 则支持双向数据绑定，可以让组件更加灵活。</p>\n<h3 id=\"从原理上讲，Vue-和-React-哪个性能更好，为什么\"><a href=\"#从原理上讲，Vue-和-React-哪个性能更好，为什么\" class=\"headerlink\" title=\"从原理上讲，Vue 和 React 哪个性能更好，为什么\"></a>从原理上讲，Vue 和 React 哪个性能更好，为什么</h3><p>从原理上讲，React 的性能更好。主要原因是 React 使用了虚拟 DOM 技术。</p>\n<p>虚拟 DOM 是一种轻量级的、基于内存的、抽象的 DOM 表示方式。每个 React 组件都有一个对应的虚拟 DOM 树，当组件的状态发生变化时，React 会重新生成虚拟 DOM 树，并比较前后两棵树的差异，然后只更新变化的部分，最后将变化的部分应用到真实 DOM 上。这种方式避免了频繁的 DOM 操作，提高了 UI 更新的效率。</p>\n<p>相比之下，Vue 使用模板和响应式数据绑定来实现 UI 的更新。当数据发生变化时，Vue 会自动更新视图。Vue 的数据绑定机制相对于 React 的虚拟 DOM 机制更为简单，但是在大量数据和复杂的 UI 组件场景下，性能表现可能不如 React。</p>\n<p>当然，这并不是说 Vue 的性能不好，Vue 在小型应用程序中性能表现非常优秀。而在大型应用程序中，React 的虚拟 DOM 机制可以更快速地更新 UI，因此在性能方面更具优势。但是，性能的表现还受到很多因素的影响，如应用程序的复杂度、数据量、代码质量等，具体性能表现需要根据具体情况来评估。</p>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><h3 id=\"git-rebase-与-git-merge\"><a href=\"#git-rebase-与-git-merge\" class=\"headerlink\" title=\"git rebase 与 git merge\"></a>git rebase 与 git merge</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>缩写</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pick</td>\n<td>p</td>\n<td>保留该 commit</td>\n</tr>\n<tr>\n<td>reword</td>\n<td>r</td>\n<td>保留该 commit，但需要修改该 commit 的注释</td>\n</tr>\n<tr>\n<td>edit</td>\n<td>e</td>\n<td>保留该 commit , 但我要停下来修改该提交(不仅仅修改注释)</td>\n</tr>\n<tr>\n<td>squash</td>\n<td>s</td>\n<td>将该 commit 合并到前一个 commit</td>\n</tr>\n<tr>\n<td>fixup</td>\n<td>f</td>\n<td>将该 commit 合并到前一个 commit，但不要保留该提交的注释信息</td>\n</tr>\n<tr>\n<td>exec</td>\n<td>x</td>\n<td>执行 shell 命令</td>\n</tr>\n<tr>\n<td>drop</td>\n<td>d</td>\n<td>丢弃该 commit</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://blog.csdn.net/small_white_123/article/details/121563248\" target=\"_blank\" >见</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202301281645578.webp\" />\n\n<ol>\n<li>merge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）</li>\n<li>rebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，</li>\n<li>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</li>\n</ol>\n<h3 id=\"变基原理：\"><a href=\"#变基原理：\" class=\"headerlink\" title=\"变基原理：\"></a>变基原理：</h3><ol>\n<li>是首先找到这两个分支的最近共同祖先 C2</li>\n<li>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3</li>\n<li>最后以此将之前另存为临时文件的修改依序应用</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/140881562\" target=\"_blank\" >小姐姐用动图展示 10 个 Git 命令</a></p>\n<h3 id=\"什么时候用哪个？\"><a href=\"#什么时候用哪个？\" class=\"headerlink\" title=\"什么时候用哪个？\"></a>什么时候用哪个？</h3><p>这本身存在分歧，主要看团队需要，</p>\n<ol>\n<li>如果团队需要历史记录保留，便于追踪，可以使用 merge ,</li>\n<li>如果不希望保留过多的过程，只关注结果那么可以用 rebase.无论用哪个，为了避免 rebase 的坑， 需要遵循以下原则：</li>\n</ol>\n<h3 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h3><p>总的原则是，<code>只对尚未推送或分享给别人的本地修改执行变基操作清理历史</code>， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ git rebase --onto master server client</code></pre>\n\n<p>你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#:~:text=Figure%2039.%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E9%87%8C%E5%86%8D%E5%88%86%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\ngit rebase -i HEAD~4\n# s 命令压缩</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171547417.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171551269.png\" />\n\n<p><a href=\"https://www.cnblogs.com/lookphp/p/5799533.html\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://backlog.com/git-tutorial/cn/stepup/stepup7_7.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h3><img src=\"http://t-blog-images.aijs.top/img/202209181100864.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209181059249.png\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~3\nThe previous cherry-pick is now empty, possibly due to conflict resolution.\nIf you wish to commit it anyway, use:\n\n    git commit --allow-empty\n\nOtherwise, please use &#39;git reset&#39;\ninteractive rebase in progress; onto e1a52d3\nLast commands done (2 commands done):\n   pick 78c1fd9 应对github bug s 压缩\n   pick 8935665 应对github bug\nNext commands to do (4 remaining commands):\n   pick 421821a update\n   pick 4eff6a3 update\nYou are currently rebasing branch &#39;main&#39; on &#39;e1a52d3&#39;.\n\nnothing to commit, working tree clean\nCould not apply 8935665... 应对github bug\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~2\n\nIt seems that there is already a rebase-merge directory, and\nI wonder if you are in the middle of another rebase.  If that is the\ncase, please try\n        git rebase (--continue | --abort | --skip)\nIf that is not the case, please\n        rm -fr &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;.git&#x2F;rebase-merge&quot;\nand run me again.  I am stopping in case you still have something\nvaluable there.\n$ git rebase --abort</code></pre>\n\n<h2 id=\"掘金小猪课堂\"><a href=\"#掘金小猪课堂\" class=\"headerlink\" title=\"掘金小猪课堂\"></a>掘金小猪课堂</h2><h3 id=\"for…in-和-for…of-的区别\"><a href=\"#for…in-和-for…of-的区别\" class=\"headerlink\" title=\"for…in 和 for…of 的区别\"></a>for…in 和 for…of 的区别</h3><ol>\n<li>for…in 可以遍历对象和数组，for…of 不能遍历对象</li>\n<li>for…in <strong>循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键</strong></li>\n<li>for…in 遍历的索引为字符串类型</li>\n<li>for..of 适用遍历数组&#x2F;字符串&#x2F;map&#x2F;set 等拥有迭代器对象的集合，但是不能遍历对象</li>\n<li>for…of 与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句</li>\n<li>具有迭代器对象才可以使用 for…of</li>\n</ol>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7002484014414037000\">https://juejin.cn/post/7002484014414037000</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"JavaScript-中可迭代对象\"><a href=\"#JavaScript-中可迭代对象\" class=\"headerlink\" title=\"JavaScript 中可迭代对象\"></a>JavaScript 中可迭代对象</h3><ol>\n<li>String、Array、Set、Map</li>\n<li>NodeList、Arguments</li>\n</ol>\n<h3 id=\"几种获取-URL-参数\"><a href=\"#几种获取-URL-参数\" class=\"headerlink\" title=\"几种获取 URL 参数\"></a><a href=\"https://juejin.cn/post/7075305529903415304\" target=\"_blank\" >几种获取 URL 参数</a></h3><ol>\n<li>通过正则匹配的方式</li>\n<li>利用 split 方法分割法</li>\n<li>使用 URLSearchParams 方法</li>\n<li>利用 a 标签内置方法</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; - 通过正则匹配的方式\n&#x2F;&#x2F; 利用正则表达式\nlet url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&#39;;\n&#x2F;&#x2F; &#x2F;&#x2F; 返回参数对象\nfunction queryURLParams(url) &#123;\n  let pattern &#x3D; &#x2F;(\\w+)&#x3D;(\\w+)&#x2F;gi; &#x2F;&#x2F;定义正则表达式\n  let parames &#x3D; &#123;&#125;; &#x2F;&#x2F; 定义参数对象\n  url.replace(pattern, ($, $1, $2) &#x3D;&gt; &#123;\n    parames[$1] &#x3D; $2;\n  &#125;);\n  return parames;\n&#125;\nconsole.log(queryURLParams(url));\n\n&#x2F;&#x2F; - 使用 URLSearchParams 方法\nlet URL &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&#39;;\nfunction queryURLParams(URL) &#123;\n  let url &#x3D; URL.split(&#39;?&#39;)[1];\n  const urlSearchParams &#x3D; new URLSearchParams(url);\n  const params &#x3D; Object.fromEntries(urlSearchParams.entries());\n  return params;\n&#125;\nconsole.log(queryURLParams(URL));\n\n&#x2F;&#x2F; 作者：小猪课堂\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7075305529903415304\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<h3 id=\"clientHeight、offsetHeight、scrollHeight-的区别\"><a href=\"#clientHeight、offsetHeight、scrollHeight-的区别\" class=\"headerlink\" title=\"clientHeight、offsetHeight、scrollHeight 的区别\"></a>clientHeight、offsetHeight、scrollHeight 的区别</h3><p>三个属性虽然都很类似，但是每一个又有一些不一样的地方，总结起来就下面三点：</p>\n<p><code>clientHeight</code>、<code>offsetHeight</code>和<code>scrollHeight</code>是 HTML 元素对象的属性，用于获取元素的高度。</p>\n<ul>\n<li><code>clientHeight</code>属性用于获取元素的可视高度，即<strong>元素内容的高度加上内边距（padding）的高度</strong>，但不包括边框（border）和外边距（margin）的高度。</li>\n<li><code>offsetHeight</code>属性用于获取元素在文档中的高度，包括<strong>元素的可视高度、内边距、边框和滚动条（如果存在）的高度</strong>，但不包括外边距的高度。</li>\n<li><code>scrollHeight</code>属性用于获取元素的滚动高度，即<strong>元素的总高度，包括元素内容的高度、内边距、边框和任何溢出内容的高度（如果存在）</strong>，但不包括外边距的高度。</li>\n</ul>\n<p>这些属性的值可能会受到 CSS 样式、文档流和父元素的影响，因此在使用时需要谨慎考虑它们的差异和适用场景。例如，</p>\n<ol>\n<li>当元素的内容溢出时，<code>scrollHeight</code>属性可以用于检测滚动条是否滚动到底部；</li>\n<li>而在计算元素的可见高度时，应该使用<code>clientHeight</code>属性。</li>\n</ol>\n<h3 id=\"childNodes-和-children-有什么区别？\"><a href=\"#childNodes-和-children-有什么区别？\" class=\"headerlink\" title=\"childNodes 和 children 有什么区别？\"></a>childNodes 和 children 有什么区别？</h3><ol>\n<li><code>获取节点上</code>: <code>childNodes</code>返回的是包含<strong>所有子节点的动态列表，包括元素节点、文本节点、注释节点等</strong>，而<code>children</code>返回的是包含<strong>所有子元素节点的静态集合</strong>。</li>\n<li><code>节点遍历</code>：同时，<code>childNodes</code>支持索引访问每个子节点，而<code>children</code>则需要使用<code>item()</code>方法或类似数组的<code>length</code>属性和迭代器进行访问。</li>\n<li><code>兼容性</code>：需要注意的是，<code>children</code>在某些浏览器版本中可能不被支持。</li>\n</ol>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p><code>childNodes</code>和<code>children</code>都是 DOM 节点对象的属性，用于获取子节点。</p>\n<ul>\n<li><code>childNodes</code>属性用于获取所有子节点，包括文本节点、注释节点等，它返回的是一个包含所有子节点的列表（NodeList）对象。</li>\n<li><code>children</code>属性用于获取所有子元素节点，不包括文本节点、注释节点等，它返回的是一个包含所有子元素节点的 HTML 集合（HTMLCollection）对象。</li>\n</ul>\n<p>因此，<code>children</code>属性仅返回元素节点，而<code>childNodes</code>属性返回所有类型的子节点。此外，它们还有以下区别：</p>\n<ul>\n<li><code>childNodes</code>属性返回的是一个动态的节点列表，即它会随着 DOM 结构的变化而变化；而<code>children</code>属性返回的是一个静态的 HTML 集合，即它不会随着 DOM 结构的变化而变化。</li>\n<li><code>childNodes</code>属性返回的是一个列表对象，可以使用索引访问每个子节点；而<code>children</code>属性返回的是一个 HTML 集合对象，不能使用索引访问每个子元素节点，只能使用<code>item()</code>方法或类似数组的<code>length</code>属性和迭代器访问。</li>\n</ul>\n<p>需要注意的是，<code>children</code>属性在 IE8 及以下版本中不支持，因此在编写跨浏览器的 JavaScript 代码时需要进行兼容性处理。</p>\n\n</details>\n<h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h2><p><strong>Ajax</strong></p>\n<p><em>全称：</em> Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。<br><em>特点</em> 局部刷新页面，无需重载整个页面。<br><em>简单来说</em> Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。</p>\n<h3 id=\"Ajax-名字的由来\"><a href=\"#Ajax-名字的由来\" class=\"headerlink\" title=\"Ajax 名字的由来\"></a>Ajax 名字的由来</h3><p>“Ajax”这个词并非一个正式的缩写或首字母缩写，而是一个缩写词。它代表”Asynchronous JavaScript and XML”（异步 JavaScript 和 XML），是一种使用 JavaScript、XMLHttpRequest 对象和一些其他技术来创建异步 Web 应用程序的开发技术。</p>\n<p>在 2005 年的一篇名为”Ajax: A New Approach to Web Applications”的文章中，Jesse James Garrett 将这种技术称为 Ajax。这个名字的原因是，这种技术使用 JavaScript 和 XMLHttpRequest 对象在后台异步地向服务器发送请求和接收响应，从而可以实现无需刷新整个 Web 页面而更新部分内容的动态 Web 应用程序。Ajax 技术在 Web 开发中广泛应用，例如在实现无限滚动、搜索框提示、自动保存等功能上都有应用。</p>\n<h3 id=\"XMLHttpRequest-示例\"><a href=\"#XMLHttpRequest-示例\" class=\"headerlink\" title=\"XMLHttpRequest 示例\"></a>XMLHttpRequest 示例</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  function ajax(url) &#123;\n    &#x2F;&#x2F; 实例\n    const xhr &#x3D; new XMLHttpRequest();\n    &#x2F;&#x2F; 方法\n    xhr.open(&quot;get&quot;, url, false);\n    &#x2F;&#x2F; 监听\n    xhr.onreadystatechange &#x3D; function () &#123;\n      &#x2F;&#x2F; 异步回调函数\n      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          console.info(&quot;响应结果&quot;, xhr.response)\n        &#125;\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 发送\n    xhr.send(null);\n  &#125;\n\n  ajax(&#39;https:&#x2F;&#x2F;smallpig.site&#x2F;api&#x2F;category&#x2F;getCategory&#39;)\n&lt;&#x2F;script&gt;</code></pre>\n\n<h3 id=\"XMLHttpRequest-实例有哪些属性\"><a href=\"#XMLHttpRequest-实例有哪些属性\" class=\"headerlink\" title=\"XMLHttpRequest 实例有哪些属性\"></a>XMLHttpRequest 实例有哪些属性</h3><p>XMLHttpRequest 对象有以下一些常用的属性：</p>\n<ol>\n<li><p>readyState：表示 XMLHttpRequest 对象的状态，具体取值为 0-4，分别对应 <code>0: 未初始化</code>、<code>1: 已打开</code>、<code>2: 已发送</code>、<code>3:接收中</code>、<code>4：完成</code>。</p>\n</li>\n<li><p>responseText：<code>表示响应数据的文本内容</code>，通常用于处理文本和 XML 数据。</p>\n</li>\n<li><p>responseXML：<code>表示响应数据的 XML 文档对象</code>，通常用于处理 XML 数据。</p>\n</li>\n<li><p>status：<code>表示响应状态码</code>，通常用于判断请求是否成功。</p>\n</li>\n<li><p>statusText：<code>表示响应状态码的文本描述</code>。</p>\n</li>\n<li><p>timeout：<code>表示 XMLHttpRequest 对象的超时时间</code>，通常用于处理请求超时等情况。</p>\n</li>\n<li><p>withCredentials：<code>表示 XMLHttpRequest 对象是否需要跨域访问凭证，通常用于处理跨域请求等情况</code>。</p>\n</li>\n</ol>\n<p>这些属性可以帮助我们对 HTTP 请求和响应进行更加精细化的控制和处理，从而提高应用程序的效率和可靠性。</p>\n<h3 id=\"XMLHttpRequest-实例有哪些方法\"><a href=\"#XMLHttpRequest-实例有哪些方法\" class=\"headerlink\" title=\"XMLHttpRequest 实例有哪些方法\"></a>XMLHttpRequest 实例有哪些方法</h3><p>XMLHttpRequest 实例有以下一些常用的方法：</p>\n<ol>\n<li><p>open(method, url, async)：<strong>初始化一个 HTTP 请求</strong>。参数 method 指定请求的方法（GET、POST 等），url 指定请求的 URL 地址，async 指定是否使用异步方式发送请求。</p>\n</li>\n<li><p>setRequestHeader(name, value)：<strong>设置 HTTP 请求头信息</strong>。参数 name 指定请求头的名称，value 指定请求头的值。</p>\n</li>\n<li><p>send(body)：<strong>发送 HTTP 请求</strong>。参数 body 指定请求的主体内容（在使用 POST 方法时会用到），如果不需要主体内容，则传递 null 即可。</p>\n</li>\n<li><p>abort()：<strong>取消 HTTP 请求</strong>。</p>\n</li>\n<li><p>getAllResponseHeaders()：<strong>获取所有的 HTTP 响应头信息</strong>。</p>\n</li>\n<li><p>getResponseHeader(name)：<strong>获取指定的 HTTP 响应头信息</strong>。参数 name 指定响应头的名称。</p>\n</li>\n<li><p>overrideMimeType(type)：覆盖 HTTP 响应的 MIME 类型。常用于解决一些浏览器不支持的 MIME 类型问题。</p>\n</li>\n<li><p>setResponseType(type)：<strong>设置 HTTP 响应的类型</strong>。常用于处理二进制数据或文本数据。</p>\n</li>\n<li><p>addEventListener(event, listener, useCapture)：<strong>为 XMLHttpRequest 对象添加事件监听器</strong>。参数 event 指定事件类型（如 load、error 等），listener 指定事件处理函数，useCapture 指定事件是否使用捕获模式。</p>\n</li>\n</ol>\n<p>这些方法可以帮助我们创建、发送和处理 HTTP 请求和响应，并且提供了很多的灵活性和可定制性，以满足各种不同的需求。</p>\n<h3 id=\"XMLHttpRequest-有哪些事件\"><a href=\"#XMLHttpRequest-有哪些事件\" class=\"headerlink\" title=\"XMLHttpRequest 有哪些事件\"></a>XMLHttpRequest 有哪些事件</h3><p>XMLHttpRequest 对象有以下一些常用的事件：</p>\n<ol>\n<li><p><code>onreadystatechange</code>：该事件在 XMLHttpRequest 对象的状态发生变化时触发，可以通过监听该事件实现异步请求。</p>\n</li>\n<li><p><code>onload</code>：该事件在 XMLHttpRequest 对象成功接收到完整的响应数据时触发，通常用于处理文本和 XML 数据。</p>\n</li>\n<li><p><code>onerror</code>：该事件在 XMLHttpRequest 对象遇到错误时触发，通常用于处理网络连接问题等异常情况。</p>\n</li>\n<li><p><code>onabort</code>：该事件在 XMLHttpRequest 对象被中止时触发，通常用于处理取消 HTTP 请求等情况。</p>\n</li>\n<li><p><code>ontimeout</code>：该事件在 XMLHttpRequest 对象超时时触发，通常用于处理请求超时等情况。</p>\n</li>\n</ol>\n<p>这些事件可以帮助我们对 HTTP 请求和响应进行更加精细化的控制和处理，从而提高应用程序的效率和可靠性。</p>\n<h3 id=\"XMLHttpRequest-open-方法中-async\"><a href=\"#XMLHttpRequest-open-方法中-async\" class=\"headerlink\" title=\"XMLHttpRequest open 方法中 async\"></a>XMLHttpRequest open 方法中 async</h3><p>在 XMLHttpRequest 的 open()方法中，async 参数用于设置请求是否异步。当 async 为 true 时表示异步请求，当 async 为 false 时表示同步请求。默认情况下，async 为 true，即默认为异步请求。</p>\n<p>异步请求的好处在于不会阻塞 JavaScript 的执行，从而可以提高应用程序的响应速度和用户体验。当异步请求发送后，JavaScript 可以继续执行其他代码，等到服务器响应后再通过回调函数来处理响应结果。</p>\n<p>但是，异步请求也存在一些问题。比如，由于异步请求是异步执行的，所以无法保证请求的顺序性。同时，由于 JavaScript 和异步请求是并发执行的，所以需要特别注意并发问题，比如请求过多导致服务器繁忙或者响应数据不一致等。</p>\n<p>因此，在实际开发中，我们需要根据实际需求来选择是使用异步请求还是同步请求。通常情况下，我们会选择异步请求来提高应用程序的响应速度和用户体验，同时需要注意并发问题和请求顺序性。</p>\n<h3 id=\"XMLHttpRequest-上传进度、下载进度\"><a href=\"#XMLHttpRequest-上传进度、下载进度\" class=\"headerlink\" title=\"XMLHttpRequest 上传进度、下载进度\"></a>XMLHttpRequest 上传进度、下载进度</h3><p>XMLHttpRequest 对象提供了多个事件来监听 HTTP 请求的进度，其中包括上传进度和下载进度。这些事件包括：</p>\n<ol>\n<li>loadstart：当请求开始发送时触发。</li>\n<li>progress：当请求正在发送或接收数据时，每隔一段时间触发一次，可以用来监听上传进度和下载进度。</li>\n<li>abort：当请求被终止时触发。</li>\n<li>error：当请求出错时触发。</li>\n<li>load：当请求成功完成时触发。</li>\n<li>timeout：当请求超时时触发。</li>\n<li>loadend：当请求完成（无论成功或失败）时触发。</li>\n</ol>\n<p>其中，可以使用 progress 事件来监听上传进度和下载进度。当进行文件上传时，可以使用 XMLHttpRequest 对象的 upload 属性来监听上传进度。示例如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var xhr &#x3D; new XMLHttpRequest();\nxhr.upload.addEventListener(\n  &#39;progress&#39;,\n  function (event) &#123;\n    if (event.lengthComputable) &#123;\n      var percentComplete &#x3D; event.loaded &#x2F; event.total;\n      console.log(percentComplete);\n    &#125;\n  &#125;,\n  false\n);\nxhr.open(&#39;POST&#39;, &#39;upload.php&#39;, true);\nxhr.send(formData);</code></pre>\n\n<p>当进行文件下载时，可以使用 XMLHttpRequest 对象本身来监听下载进度。示例如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var xhr &#x3D; new XMLHttpRequest();\nxhr.addEventListener(\n  &#39;progress&#39;,\n  function (event) &#123;\n    if (event.lengthComputable) &#123;\n      var percentComplete &#x3D; event.loaded &#x2F; event.total;\n      console.log(percentComplete);\n    &#125;\n  &#125;,\n  false\n);\nxhr.open(&#39;GET&#39;, &#39;file.zip&#39;, true);\nxhr.responseType &#x3D; &#39;blob&#39;;\nxhr.send();</code></pre>\n\n<p>在这两个示例中，我们使用了 XMLHttpRequest 对象的 addEventListener()方法来添加事件监听器。在 progress 事件中，我们可以通过 event.loaded 和 event.total 属性来获取已经下载或上传的数据量和总数据量，从而计算出当前的进度百分比。</p>\n<h3 id=\"XMLHttpRequest-上传-x2F-下载换种写法\"><a href=\"#XMLHttpRequest-上传-x2F-下载换种写法\" class=\"headerlink\" title=\"XMLHttpRequest 上传&#x2F;下载换种写法\"></a>XMLHttpRequest 上传&#x2F;下载换种写法</h3><p>以下是使用 Promise 封装的示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function downloadFile(url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest();\n    xhr.open(&#39;GET&#39;, url, true);\n    xhr.responseType &#x3D; &#39;blob&#39;;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        const blob &#x3D; new Blob([this.response]);\n        const fileName &#x3D; xhr.getResponseHeader(&#39;Content-Disposition&#39;).match(&#x2F;filename&#x3D;(.*)&#x2F;)[1];\n        const link &#x3D; document.createElement(&#39;a&#39;);\n        link.href &#x3D; window.URL.createObjectURL(blob);\n        link.download &#x3D; fileName;\n        link.click();\n        resolve();\n      &#125; else &#123;\n        reject(new Error(this.statusText));\n      &#125;\n    &#125;;\n    xhr.onerror &#x3D; function () &#123;\n      reject(new Error(&#39;XMLHttpRequest Error: &#39; + this.statusText));\n    &#125;;\n    xhr.onprogress &#x3D; function (event) &#123;\n      if (event.lengthComputable) &#123;\n        const percentComplete &#x3D; (event.loaded &#x2F; event.total) * 100;\n        console.log(&#39;Download progress: &#39; + percentComplete.toFixed(2) + &#39;%&#39;);\n      &#125;\n    &#125;;\n    xhr.send();\n  &#125;);\n&#125;\n\nfunction uploadFile(url, file) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest();\n    xhr.open(&#39;POST&#39;, url, true);\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve();\n      &#125; else &#123;\n        reject(new Error(this.statusText));\n      &#125;\n    &#125;;\n    xhr.onerror &#x3D; function () &#123;\n      reject(new Error(&#39;XMLHttpRequest Error: &#39; + this.statusText));\n    &#125;;\n    xhr.upload.onprogress &#x3D; function (event) &#123;\n      if (event.lengthComputable) &#123;\n        const percentComplete &#x3D; (event.loaded &#x2F; event.total) * 100;\n        console.log(&#39;Upload progress: &#39; + percentComplete.toFixed(2) + &#39;%&#39;);\n      &#125;\n    &#125;;\n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, file);\n    xhr.send(formData);\n  &#125;);\n&#125;</code></pre>\n\n<p>使用 Promise 封装后，可以更加方便地处理异步操作，并且可以链式调用。</p>\n<h3 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h3><p><em>注意：</em>不应该和 Ajax 做比较, 应该和 <code>XMLHttpRequest</code>做比较， Ajax 一个是思想，Fetch 一个是真实存在的 API</p>\n<p><em>特点</em></p>\n<ol>\n<li>Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象</li>\n<li>内置的 API，使用上更简单</li>\n<li>使用 promise, 不使用回调</li>\n<li>数据流对象处理数据<code>常用res.json()转化成json数据</code></li>\n</ol>\n<h3 id=\"Fetch-有哪些属性、方法、事件\"><a href=\"#Fetch-有哪些属性、方法、事件\" class=\"headerlink\" title=\"Fetch 有哪些属性、方法、事件\"></a>Fetch 有哪些属性、方法、事件</h3><p>Fetch 是一个现代的 Web API，用于在 JavaScript 中进行网络请求。它提供了一组方法来完成基于网络的操作，包括获取和发送数据，可以用于替代早期的 XMLHttpRequest。</p>\n<p>Fetch 的常用属性、方法、事件包括：</p>\n<p><strong>Fetch 方法</strong></p>\n<ul>\n<li><code>fetch()</code>：用于发起网络请求，并返回一个 Promise 对象。</li>\n<li><code>Request()</code>：用于创建一个请求对象，包括请求的 URL、请求方法、请求头等信息。</li>\n<li><code>Headers()</code>：用于创建请求头对象，包括设置请求头的名称和值。</li>\n<li><code>Response()</code>：用于创建响应对象，包括响应状态码、响应头、响应体等信息。</li>\n</ul>\n<p><strong>Fetch 属性</strong></p>\n<ul>\n<li><code>Headers.append()</code>：用于向请求头中添加新的键值对。</li>\n<li><code>Headers.delete()</code>：用于从请求头中删除指定键名的键值对。</li>\n<li><code>Headers.entries()</code>：返回一个迭代器，用于迭代请求头中的键值对。</li>\n<li><code>Headers.get()</code>：用于获取指定键名的键值对。</li>\n<li><code>Headers.has()</code>：用于检查指定键名是否存在于请求头中。</li>\n<li><code>Headers.keys()</code>：返回一个迭代器，用于迭代请求头中的键名。</li>\n<li><code>Headers.set()</code>：用于设置请求头中指定键名的键值对。</li>\n<li><code>Headers.values()</code>：返回一个迭代器，用于迭代请求头中的键值。</li>\n</ul>\n<p><strong>Fetch 事件</strong></p>\n<ul>\n<li><code>fetch</code>：在发起网络请求后触发，表示请求已经被发送到服务器。</li>\n<li><code>abort</code>：在请求被取消时触发。</li>\n<li><code>error</code>：在发生网络错误时触发。</li>\n<li><code>progress</code>：在上传或下载进度发生变化时触发。</li>\n</ul>\n<p><strong>Fetch 方法</strong></p>\n<ul>\n<li><code>fetch()</code>：用于发起网络请求，并返回一个 Promise 对象。</li>\n<li><code>Request()</code>：用于创建一个请求对象，包括请求的 URL、请求方法、请求头等信息。</li>\n<li><code>Headers()</code>：用于创建请求头对象，包括设置请求头的名称和值。</li>\n<li><code>Response()</code>：用于创建响应对象，包括响应状态码、响应头、响应体等信息。</li>\n</ul>\n<p><strong>Fetch 选项</strong></p>\n<ul>\n<li><code>method</code>：HTTP 请求方法，默认为 GET。</li>\n<li><code>headers</code>：请求头对象，可以使用 <code>Headers</code> 或者对象字面量创建。</li>\n<li><code>body</code>：请求体，可以是字符串、Blob 对象、FormData 对象等。</li>\n<li><code>mode</code>：请求模式，决定请求跨域时使用的方式，有 cors、no-cors、same-origin 和 navigate。</li>\n<li><code>cache</code>：请求缓存模式，有 default、no-store、reload、no-cache、force-cache 和 only-if-cached。</li>\n<li><code>redirect</code>：重定向模式，有 follow、error、manual。</li>\n<li><code>referrer</code>：请求的 Referrer，可以是空字符串、URL 或者 no-referrer。</li>\n<li><code>referrerPolicy</code>：Referrer 策略，有 no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin 和 unsafe-url。</li>\n<li><code>integrity</code>：用于验证响应是否被篡改的 Subresource Integrity</li>\n</ul>\n<h3 id=\"Fetch-上传进度、下载进度\"><a href=\"#Fetch-上传进度、下载进度\" class=\"headerlink\" title=\"Fetch 上传进度、下载进度\"></a>Fetch 上传进度、下载进度</h3><p>Fetch API 提供了 <code>fetch</code> 方法的扩展，支持上传进度和下载进度的监控。</p>\n<p>上传进度的监控：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(url, &#123;\n  method: &#39;POST&#39;,\n  body: formData,\n&#125;)\n  .then((response) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...\n  &#125;);\n\nconst progress &#x3D; (event) &#x3D;&gt; &#123;\n  if (event.lengthComputable) &#123;\n    const percent &#x3D; Math.round((event.loaded &#x2F; event.total) * 100);\n    console.log(&#96;Upload Progress: $&#123;percent&#125;%&#96;);\n  &#125;\n&#125;;\n\nformData.addEventListener(&#39;progress&#39;, progress);</code></pre>\n\n<p>下载进度的监控：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(url)\n  .then((response) &#x3D;&gt; &#123;\n    const reader &#x3D; response.body.getReader();\n    const contentLength &#x3D; +response.headers.get(&#39;content-length&#39;);\n\n    const read &#x3D; () &#x3D;&gt; &#123;\n      reader.read().then((&#123; done, value &#125;) &#x3D;&gt; &#123;\n        if (done) &#123;\n          console.log(&#39;Download Complete&#39;);\n        &#125; else &#123;\n          const downloadedLength &#x3D; value.byteLength;\n          const percent &#x3D; Math.round((downloadedLength &#x2F; contentLength) * 100);\n          console.log(&#96;Download Progress: $&#123;percent&#125;%&#96;);\n          read();\n        &#125;\n      &#125;);\n    &#125;;\n\n    read();\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...\n  &#125;);</code></pre>\n\n<p>以上代码中，</p>\n<ol>\n<li>我们通过监听 FormData 的 progress 事件来监控上传进度，</li>\n<li>通过监听 Response 的 body 属性上的 Reader 对象的 read() 方法返回的 Promise 来监控下载进度。</li>\n<li>在上传和下载的回调函数中，可以根据已上传或已下载的数据大小和总大小计算出进度百分比并输出到控制台。</li>\n</ol>\n<h3 id=\"Fetch-与-XMLHttpRequest-区别\"><a href=\"#Fetch-与-XMLHttpRequest-区别\" class=\"headerlink\" title=\"Fetch 与 XMLHttpRequest 区别\"></a>Fetch 与 XMLHttpRequest 区别</h3><p>Fetch 和 XMLHttpRequest（以下简称 XHR）都是用于发送 HTTP 请求的客户端 API，但是它们之间有以下不同点：</p>\n<ol>\n<li><p><code>语法差异</code>：Fetch 使用 Promise 实现异步请求，语法更加简洁易懂，XHR 使用回调函数的方式实现异步请求。</p>\n</li>\n<li><p><code>跨域策略</code>：Fetch 在跨域请求时默认不会携带 Cookie，需要手动设置，而 XHR 会自动携带 Cookie。</p>\n</li>\n<li><p><code>请求和响应的处理方式</code>：Fetch 的请求和响应对象都是基于 Stream 对象实现的，支持更加灵活的请求和响应处理方式，而 XHR 的请求和响应对象都是基于文本和二进制数据实现的。</p>\n</li>\n<li><p><code>缓存处理</code>：Fetch 对于请求的缓存处理更加方便，可以通过设置 Request 对象的 cache 属性控制缓存策略，XHR 只能通过设置请求头中的 If-Modified-Since 或者 If-None-Match 来控制缓存策略。</p>\n</li>\n<li><p><code>错误处理</code>：Fetch 对于网络错误和请求超时的处理更加方便，支持 Promise 中的 reject 方法处理错误，XHR 需要手动设置 onerror 和 ontimeout 事件处理错误。</p>\n</li>\n<li><p><code>其他</code>：Fetch 支持 Service Worker，支持 Request 和 Response 对象的 clone 方法，XHR 不支持。</p>\n</li>\n<li><p>Fetch 的返回值是 Promise，而 XMLHttpRequest 的返回值是 XMLHttpRequest 对象。</p>\n</li>\n<li><p>Fetch 不会自动将接收到的 JSON、XML 等数据解析成 JavaScript 对象，需要手动解析；而 XMLHttpRequest 支持设置响应类型，可以自动解析为 JavaScript 对象。</p>\n</li>\n<li><p>Fetch 默认不携带 Cookie，需要设置 credentials 选项为 ‘include’ 才会携带 Cookie，而 XMLHttpRequest 在跨域请求时会自动携带 Cookie。</p>\n</li>\n<li><p>Fetch 不支持超时设置，需要使用 Promise.race() 实现超时处理，而 XMLHttpRequest 支持通过设置 timeout 属性实现超时。</p>\n</li>\n<li><p>Fetch 的错误处理需要使用 catch()，而 XMLHttpRequest 可以通过 onerror、ontimeout 等事件处理错误。</p>\n</li>\n</ol>\n<p>需要注意的是，Fetch 的兼容性不如 XHR 好，在一些老版本浏览器中可能无法使用，需要进行 polyfill 或者 fallback 处理。</p>\n<h3 id=\"Fetch-不支持超时设置\"><a href=\"#Fetch-不支持超时设置\" class=\"headerlink\" title=\"Fetch 不支持超时设置\"></a>Fetch 不支持超时设置</h3><p>Fetch API 默认是不支持超时设置的，但是可以使用 Promise.race() 实现超时处理。比如，以下示例中，在 5 秒内如果 Fetch 请求没有响应，就会返回超时错误：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const controller &#x3D; new AbortController();\nconst timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;\n  controller.abort();\n&#125;, 5000);\n\nfetch(&#39;https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;data&#39;, &#123; signal: controller.signal &#125;)\n  .then((response) &#x3D;&gt; response.json())\n  .then((data) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理返回的数据\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    if (error.name &#x3D;&#x3D;&#x3D; &#39;AbortError&#39;) &#123;\n      console.log(&#39;Fetch 请求超时&#39;);\n    &#125; else &#123;\n      console.error(&#39;Fetch 请求错误:&#39;, error);\n    &#125;\n  &#125;)\n  .finally(() &#x3D;&gt; &#123;\n    clearTimeout(timeout);\n  &#125;);</code></pre>\n\n<p>在这个示例中，使用 AbortController 实例创建一个信号(signal)，然后将该信号传递给 Fetch API。同时，使用 setTimeout() 函数在 5 秒后中断 Fetch 请求。最后，使用 Promise.race() 将 Fetch 请求 Promise 和超时 Promise 一起包装，如果其中一个 Promise 被 resolve 或 reject，整个 Promise 链都会被 resolve 或 reject。如果超时，Fetch 请求的 Promise 会被 reject，并抛出 AbortError 错误。</p>\n<h3 id=\"Fetch-不支持自动取消请求\"><a href=\"#Fetch-不支持自动取消请求\" class=\"headerlink\" title=\"Fetch 不支持自动取消请求\"></a>Fetch 不支持自动取消请求</h3><p>是的，Fetch API 不支持自动取消请求。如果要手动取消一个 Fetch 请求，需要使用 <code>AbortController</code> 和 <code>AbortSignal</code> 对象。具体做法是在发送 Fetch 请求时创建一个 <code>AbortController</code> 对象，然后将它的 <code>signal</code> 属性赋值给 Fetch 请求的 <code>signal</code> 属性。当需要取消请求时，可以调用 <code>AbortController</code> 对象的 <code>abort()</code> 方法，这会向 <code>AbortSignal</code> 对象发送一个中止信号，使得 Fetch 请求中止。</p>\n<h3 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h3><p><em>Axios</em>是一个基于 promise 和 XHR 封装的网络请求库</p>\n<p><em>特点：</em></p>\n<ol>\n<li>从浏览器中创建 XMLHttpRequests，从 node.js 创建 http 请求</li>\n<li>支持 Promise API</li>\n<li>能够拦截请求和响应，转换请求数据和响应数据</li>\n<li>具备 <code>取消请求，自动转换 JSON 数据，客户端支持防御 XSRF</code> 的特点</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202210171747226.webp\" />\n\n<h3 id=\"Axios-实现原理\"><a href=\"#Axios-实现原理\" class=\"headerlink\" title=\"Axios 实现原理\"></a>Axios 实现原理</h3><p>Axios 是一个基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 环境中使用。Axios 提供了一个简单易用的 API，能够帮助我们发送 HTTP 请求、处理响应数据等。</p>\n<p>Axios 的实现原理可以大致分为以下几个部分：</p>\n<ol>\n<li><p>创建 Axios 实例：通过 <code>Axios.create()</code> 方法创建一个 Axios 实例，可以设置一些默认的配置参数，如请求头、响应类型、请求超时等。</p>\n</li>\n<li><p>发送请求：Axios 支持多种请求方法，如 GET、POST、PUT、DELETE 等。每个请求方法都返回一个 Promise 对象，我们可以通过 <code>.then()</code> 和 <code>.catch()</code> 方法处理请求的响应数据和错误信息。</p>\n</li>\n<li><p>处理请求配置：Axios 将请求配置对象作为参数传递给请求方法。在请求发送之前，Axios 会对请求配置进行处理和合并，包括请求 URL、请求参数、请求头等。</p>\n</li>\n<li><p>发送请求前的拦截器：Axios 支持请求和响应的拦截器，可以在请求发送之前或者响应返回之后进行拦截和处理。拦截器是通过 <code>interceptors</code> 属性实现的，<code>interceptors</code> 包括 <code>request</code> 和 <code>response</code> 两个对象，分别代表请求和响应的拦截器。</p>\n</li>\n<li><p>发送请求：Axios 使用底层的 <code>XMLHttpRequest</code> 或者 <code>fetch</code> API 发送请求。发送请求的过程中，Axios 支持请求的取消、请求进度的监测等功能。</p>\n</li>\n<li><p>处理响应数据：在请求成功后，Axios 会对响应数据进行处理和转换，可以通过 <code>transformResponse</code> 和 <code>transformRequest</code> 配置项自定义响应数据的处理方式。在处理响应数据的过程中，Axios 也支持响应的拦截器，可以对响应数据进行统一的处理。</p>\n</li>\n<li><p>发送请求后的拦截器：Axios 支持请求和响应的拦截器，可以在请求发送之前或者响应返回之后进行拦截和处理。拦截器是通过 <code>interceptors</code> 属性实现的，<code>interceptors</code> 包括 <code>request</code> 和 <code>response</code> 两个对象，分别代表请求和响应的拦截器。</p>\n</li>\n<li><p>处理错误：在请求过程中，可能会出现一些错误，如网络错误、请求超时等。Axios 会对这些错误进行处理和封装，然后抛出一个统一的错误对象。</p>\n</li>\n</ol>\n<p>以上就是 Axios 的大致实现原理，Axios 在底层使用了 Promise 和异步编程技术，能够帮助我们更加方便地处理 HTTP 请求和响应数据。</p>\n<h3 id=\"Axios-执行过程\"><a href=\"#Axios-执行过程\" class=\"headerlink\" title=\"Axios 执行过程\"></a>Axios 执行过程</h3><p>Axios 是一个基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 中使用，用于发送 HTTP 请求和处理响应。Axios 执行的过程可以简要概括为以下几个步骤：</p>\n<ol>\n<li><p>创建 Axios 实例：使用 Axios.create() 方法创建一个 Axios 实例，并配置默认请求参数和拦截器等。</p>\n</li>\n<li><p>发送请求：使用 Axios 实例的 HTTP 请求方法（如 axios.get、axios.post 等）发送请求，参数包括请求 URL、请求参数、请求头等。</p>\n</li>\n<li><p>发送请求前拦截：在发送请求前，Axios 可以对请求参数、请求头等进行拦截处理，可以通过 Axios 实例的 interceptors.request.use() 方法添加拦截器。</p>\n</li>\n<li><p>执行请求：Axios 会根据请求方法、请求 URL、请求参数等信息生成一个 HTTP 请求对象，并使用浏览器内置的 XMLHttpRequest 对象或 Node.js 中的 http 模块发送请求。</p>\n</li>\n<li><p>接收响应：当服务器返回响应时，Axios 接收到响应并对其进行处理，包括解析响应数据、响应头等。可以通过 Axios 实例的 interceptors.response.use() 方法添加响应拦截器。</p>\n</li>\n<li><p>处理响应数据：Axios 会根据响应状态码等信息判断请求是否成功，如果成功会返回响应数据，否则会抛出异常。Axios 还会根据响应数据的 Content-Type 头信息将响应数据转换为合适的数据格式，如 JSON 对象、XML 对象等。</p>\n</li>\n<li><p>处理异常：如果请求发生异常，如网络错误、请求超时等，Axios 会抛出异常并中断请求。可以使用 try-catch 语句捕获异常并进行处理。</p>\n</li>\n</ol>\n<p>总的来说，Axios 执行过程中的重要步骤包括创建实例、发送请求、拦截请求、执行请求、接收响应、处理响应数据和处理异常。</p>\n<h3 id=\"Axios-拦截器的实现原理\"><a href=\"#Axios-拦截器的实现原理\" class=\"headerlink\" title=\"Axios 拦截器的实现原理\"></a>Axios 拦截器的实现原理</h3><p>Axios 拦截器的实现原理是基于 Promise 的链式调用。Axios 中的拦截器包括请求拦截器和响应拦截器。</p>\n<p>当我们发送请求时，Axios 会将请求拦截器中的回调函数按照添加顺序依次执行。请求拦截器可以修改请求头、请求数据等内容，也可以通过返回 Promise 来实现异步操作，例如异步获取 token 等。</p>\n<p>然后，Axios 将经过请求拦截器处理后的请求发送到服务器，并等待服务器的响应。当服务器响应后，Axios 会将响应拦截器中的回调函数按照添加顺序依次执行。响应拦截器可以修改响应数据、响应头等内容，也可以通过返回 Promise 来实现异步操作，例如根据响应状态码进行特定的错误处理等。</p>\n<p>Axios 的拦截器使用了 Promise 的链式调用，每个拦截器中的回调函数都是一个 Promise 对象。通过 <code>Promise.resolve</code> 方法将每个回调函数包装成一个 Promise 对象，并使用 <code>then</code> 方法将它们串联起来，形成了一个 Promise 链。Axios 通过执行这个 Promise 链来实现拦截器的调用。</p>\n<p>Axios 的拦截器实现可以帮助我们实现很多通用的功能，例如请求前的 token 鉴权、请求后的响应数据处理等，这些功能可以在拦截器中统一实现，避免了代码的重复编写。同时，Axios 也提供了取消请求等高级功能，使得网络请求变得更加灵活和可控。</p>\n<h3 id=\"Ajax、XMLHttpRequest、Fetch、Axios-四者的区别\"><a href=\"#Ajax、XMLHttpRequest、Fetch、Axios-四者的区别\" class=\"headerlink\" title=\"Ajax、XMLHttpRequest、Fetch、Axios 四者的区别\"></a>Ajax、XMLHttpRequest、Fetch、Axios 四者的区别</h3><h3 id=\"判断两个对象是否相等\"><a href=\"#判断两个对象是否相等\" class=\"headerlink\" title=\"判断两个对象是否相等\"></a>判断两个对象是否相等</h3><p>在 JavaScript 中，判断两个对象是否相等可以使用以下方法：</p>\n<ol>\n<li>相等运算符 <code>==</code> 或全等运算符 <code>===</code> ：用于比较两个对象的值是否相等。如果两个对象的引用地址不同，则会返回 <code>false</code>。</li>\n<li>JSON.stringify() 方法：将两个对象转换为字符串后再进行比较。如果两个对象的属性名称、属性顺序和属性值都相等，则它们被视为相等。</li>\n<li>Lodash 库的 isEqual() 方法：这是一个专门用于比较两个对象是否相等的方法。它会递归地比较两个对象的属性，如果两个对象的属性名称、属性顺序和属性值都相等，则它们被视为相等。</li>\n</ol>\n<p>需要注意的是，如果对象中包含函数或循环引用，则以上方法可能会产生不正确的结果。此时可以考虑对函数进行特殊处理，或使用第三方库来处理循环引用问题。</p>\n<h3 id=\"将类数组转为数组\"><a href=\"#将类数组转为数组\" class=\"headerlink\" title=\"将类数组转为数组\"></a>将类数组转为数组</h3><p><em>类数组特点：</em></p>\n<ol>\n<li>类数组是一个对象， 带有 length 属性</li>\n<li>没有数组方法，即不可调用数组的原型方法</li>\n</ol>\n<p><em>类数组：</em></p>\n<ol>\n<li>arguments</li>\n<li>HTMLCollection</li>\n<li>NodeList</li>\n</ol>\n<p><em>实现方案</em></p>\n<ol>\n<li>Array.from ES6 提供的方法，只能实现浅拷贝</li>\n<li>扩展运算符 不能使用在非迭代对象上</li>\n<li>数组 slice 方法 在不改变原数组的情况下返回数组中的某些元素并形成新的数组。</li>\n</ol>\n<h3 id=\"判断数据类型\"><a href=\"#判断数据类型\" class=\"headerlink\" title=\"判断数据类型\"></a>判断数据类型</h3><ol>\n<li><code>typeof</code> 能判断基本数据类型，不能判断引用数据类型</li>\n<li><code>instanceof</code> 可以判断引用数据类型, 不能判断基本数据类型</li>\n</ol>\n<p>虽然上面两个结合可以处理，但是过于复杂</p>\n<p>每个对象都有一个 <code>toString()</code>  方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()  方法被每个  Object  对象继承。</p>\n<p><code>如果此方法在自定义对象中未被覆盖，toString()  返回  &quot;[object type]&quot;，其中  type  是对象的类型</code></p>\n<p>在 JavaScript 中，我们可以使用 typeof 操作符来判断变量的数据类型。typeof 可以返回以下结果：</p>\n<ul>\n<li>“undefined”：如果这个值未定义。</li>\n<li>“boolean”：如果这个值是布尔值。</li>\n<li>“number”：如果这个值是数字。</li>\n<li>“bigint”：如果这个值是大整数，是 ES6 新增的类型。</li>\n<li>“string”：如果这个值是字符串。</li>\n<li>“symbol”：如果这个值是符号，是 ES6 新增的类型。</li>\n<li>“object”：如果这个值是对象或 null。</li>\n<li>“function”：如果这个值是函数。</li>\n</ul>\n<p>另外，我们还可以使用 instanceof 操作符来判断一个对象是否属于某个类。例如，可以使用以下语句来判断一个对象是否是数组：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [1, 2, 3];\nconsole.log(arr instanceof Array); &#x2F;&#x2F; true</code></pre>\n\n<p>还可以使用 Object.prototype.toString.call() 方法来获取变量的类型字符串，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(Object.prototype.toString.call([])); &#x2F;&#x2F; &quot;[object Array]&quot;\nconsole.log(Object.prototype.toString.call(&#123;&#125;)); &#x2F;&#x2F; &quot;[object Object]&quot;\nconsole.log(Object.prototype.toString.call(123)); &#x2F;&#x2F; &quot;[object Number]&quot;\nconsole.log(Object.prototype.toString.call(null)); &#x2F;&#x2F; &quot;[object Null]&quot;\nconsole.log(Object.prototype.toString.call(undefined)); &#x2F;&#x2F; &quot;[object Undefined]&quot;\nconsole.log(Object.prototype.toString.call(&#39;string&#39;)); &#x2F;&#x2F; &quot;[object String]&quot;\nconsole.log(Object.prototype.toString.call(true)); &#x2F;&#x2F; &quot;[object Boolean]&quot;\nconsole.log(Object.prototype.toString.call(function () &#123;&#125;)); &#x2F;&#x2F; &quot;[object Function]&quot;\nconsole.log(Object.prototype.toString.call(new Date())); &#x2F;&#x2F; &quot;[object Date]&quot;\nconsole.log(Object.prototype.toString.call(&#x2F;[a-z]&#x2F;)); &#x2F;&#x2F; &quot;[object RegExp]&quot;</code></pre>\n\n<p>通过使用 Object.prototype.toString.call()，可以得到更加准确的类型信息，尤其是在处理引用类型时更为有用。</p>\n<h3 id=\"Object-prototype-toString-call-封装\"><a href=\"#Object-prototype-toString-call-封装\" class=\"headerlink\" title=\"Object.prototype.toString.call 封装\"></a>Object.prototype.toString.call 封装</h3><p>可以将 Object.prototype.toString.call 封装成一个函数，方便使用，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getType(obj) &#123;\n  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n&#125;</code></pre>\n\n<p>这样，我们就可以直接使用 <code>getType</code> 函数来获取对象的类型，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(getType([])); &#x2F;&#x2F; &quot;array&quot;\nconsole.log(getType(&#123;&#125;)); &#x2F;&#x2F; &quot;object&quot;\nconsole.log(getType(new Date())); &#x2F;&#x2F; &quot;date&quot;\nconsole.log(getType(null)); &#x2F;&#x2F; &quot;null&quot;\nconsole.log(getType(undefined)); &#x2F;&#x2F; &quot;undefined&quot;\nconsole.log(getType(&#39;&#39;)); &#x2F;&#x2F; &quot;string&quot;\nconsole.log(getType(1)); &#x2F;&#x2F; &quot;number&quot;\nconsole.log(getType(true)); &#x2F;&#x2F; &quot;boolean&quot;\nconsole.log(getType(function () &#123;&#125;)); &#x2F;&#x2F; &quot;function&quot;</code></pre>\n\n<h3 id=\"session、cookie、token-的区别？\"><a href=\"#session、cookie、token-的区别？\" class=\"headerlink\" title=\"session、cookie、token 的区别？\"></a>session、cookie、token 的区别？</h3><p>1.为什么会有它们？</p>\n<p><strong>无状态</strong><br>我们都知道 HTTP 协议是无状态的，所谓的无状态就是客户端每次想要与服务端通信，都必须重新与服务端链接，意味着请求一次客户端和服务端就连接一次，下一次请求与上一次请求是没有关系的。</p>\n<p><strong>区分用户</strong><br>这种无状态的方式就会存在一个问题：如何判断两次请求的是同一个人？<br>就好比用户在页面 A 发起请求获取个人信息，然后在另一个页面同样发起请求获取个人信息，我们如何确定这俩个请求是同一个人发的呢？</p>\n<p>为了解决这种问题，我们就迫切需要一种方式知道发起请求的客户端是谁？此时，cookie、token、session 就出现了，它们就可以解决客户端标识的问题，在扩大一点就是解决权限问题。</p>\n<p>它们就好比让每个客户端或者说登录用户有了自己的身份证，我们可以通过这个身份证确定发请求的是谁！</p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7090503270447185951\">https://juejin.cn/post/7090503270447185951</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>cookie 的缺点：</p>\n<ol>\n<li>增加请求体积，浪费性能，因为每次请求都会携带 cookie。</li>\n<li>增加服务端资源消耗，因为每个客户端连接进来都需要生成 session，会占用服务端资源的。</li>\n<li>容易遭受 CSRF 攻击，即跨站域请求伪造。</li>\n</ol>\n<h2 id=\"new-做了哪些操作？手写一个-new-方法！\"><a href=\"#new-做了哪些操作？手写一个-new-方法！\" class=\"headerlink\" title=\"new 做了哪些操作？手写一个 new 方法！\"></a>new 做了哪些操作？手写一个 new 方法！</h2><p><code>new</code> 操作符</p>\n<ol>\n<li>创建一个新的对象，</li>\n<li>将其 <code>__proto__</code> 属性指向构造函数的原型，</li>\n<li>然后执行构造函数并将 <code>this</code> 指向新的对象，</li>\n<li>最后将新的对象返回。</li>\n</ol>\n<p>手写一个简单的 <code>new</code> 方法示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function myNew(constructor, ...args) &#123;\n  &#x2F;&#x2F; 创建一个空对象并将其 __proto__ 属性指向构造函数的原型\n  const obj &#x3D; Object.create(constructor.prototype);\n\n  &#x2F;&#x2F; 执行构造函数并将 this 指向新对象\n  const result &#x3D; constructor.apply(obj, args);\n\n  &#x2F;&#x2F; 返回新对象或构造函数返回的对象\n  return result instanceof Object ? result : obj;\n&#125;</code></pre>\n\n<p>这里的 <code>...args</code> 表示使用了剩余参数语法，可以将传入 <code>myNew</code> 方法的第二个参数及以后的参数都存储到一个数组中。在执行构造函数时，将这个数组作为参数传入，可以让我们在不知道构造函数参数个数的情况下也能使用 <code>myNew</code> 方法来创建对象。</p>\n<h2 id=\"跨标签页的通讯方式有哪些\"><a href=\"#跨标签页的通讯方式有哪些\" class=\"headerlink\" title=\"跨标签页的通讯方式有哪些\"></a>跨标签页的通讯方式有哪些</h2><h3 id=\"为什么需要跨标签页通信\"><a href=\"#为什么需要跨标签页通信\" class=\"headerlink\" title=\"为什么需要跨标签页通信\"></a>为什么需要跨标签页通信</h3><p>一个标签页的数据，要同步给另一个标签页</p>\n<h3 id=\"列举\"><a href=\"#列举\" class=\"headerlink\" title=\"列举\"></a>列举</h3><h4 id=\"同源\"><a href=\"#同源\" class=\"headerlink\" title=\"同源\"></a>同源</h4><ol>\n<li><code>广播模式：</code>Broadcast Channel &#x2F; LocalStorage + StorageEvent &#x2F; Service Worker &#x2F;</li>\n<li><code>存储模式：</code>Shared Worker &#x2F; IndexedDB &#x2F; cookie</li>\n<li><code>传递模式：</code>window.open + window.opener <code>有局限性：只有从一个 tab 打开新 tab,新 tab 才可以拿到之前 tab 的引用</code></li>\n<li><code>基于服务端：</code>Websocket &#x2F; Comet &#x2F; SSE 等</li>\n<li><code>visibilitychange</code> 监听 tab 展示</li>\n</ol>\n<h4 id=\"非同源：\"><a href=\"#非同源：\" class=\"headerlink\" title=\"非同源：\"></a>非同源：</h4><ol>\n<li><code>可以使用一个用户不可见的 iframe 作为“桥”。</code></li>\n<li><code>由于 iframe 与父页面间， 通过指定 origin 来忽略同源限制</code>，&#96;因此可以在每个页面中嵌入一个 iframe （例如：<a href=\"http://sample.com/bridge.html%EF%BC%89%EF%BC%8C\">http://sample.com/bridge.html），</a></li>\n<li>而这些 iframe 由于使用的是一个 url，因此属于同源页面&#96;，其通信方式可以复用上面第一部分提到的各种方式</li>\n</ol>\n<p>作者：AlienZHOU<br>链接：<a href=\"https://juejin.cn/post/6844903811232825357\">https://juejin.cn/post/6844903811232825357</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API\" target=\"_blank\" >Broadcast_Channel_API</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Page_Visibility_API\" target=\"_blank\" >Page_Visibility_API</a></li>\n<li><a href=\"https://juejin.cn/post/6844903811232825357\" target=\"_blank\" >面试官：前端跨页面通信，你知道哪些方法？</a></li>\n</ol>\n<h3 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;alienzhou.github.io&#x2F;cross-tab-communication&#x2F;&quot; style&#x3D;&quot;width: 100%; height: 800px&quot;&gt;&lt;&#x2F;iframe&gt;</code></pre>\n\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p><a href=\"https://github.com/alienzhou/alienzhou.github.io/blob/master/cross-tab-communication/index.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"非同源\"><a href=\"#非同源\" class=\"headerlink\" title=\"非同源\"></a>非同源</h3><p><a href=\"https://juejin.cn/post/6869686782942773255\" target=\"_blank\" >见</a></p>\n<p>实现原理：<br><a href=\"http://localhost:3000/bbb.html%EF%BC%88%E7%AE%80%E7%A7%B0\">http://localhost:3000/bbb.html（简称</a> bbb 页面）嵌入 iframe 页面 <a href=\"http://localhost:3001/a.html%EF%BC%88%E7%AE%80%E7%A7%B0\">http://localhost:3001/a.html（简称</a> iframe 页面）<br>iframe 能够接受父级页面 bbb.html 发送过来的数据<br>与此同时 iframe 与实际需要接受数据的 <a href=\"http://localhost:3001/b.html\">http://localhost:3001/b.html</a>(简称 b 页面)同源，所以可以通过同源通信的 Broadcast Channel 方式将 iframe 接受到的数据发送给 b 页面实现 bbb 页面与 b 页面之间的数据发送</p>\n<p>作者：Tsuki_<br>链接：<a href=\"https://juejin.cn/post/6869686782942773255\">https://juejin.cn/post/6869686782942773255</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"demo-代码\"><a href=\"#demo-代码\" class=\"headerlink\" title=\"demo 代码\"></a>demo 代码</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 父传子\n\niframe.contentWindow.postMessage(&#39;父页面传送的数据&#39;, &#39;*&#39;);\n\n&#x2F;&#x2F; 父接子\n\nwindow.addEventListener(&#39;message&#39;, function (data) &#123;\n  console.log(data);\n&#125;);\n\n&#x2F;&#x2F; 子接父\nwindow.addEventListener(&#39;message&#39;, function (obj) &#123;\n  console.log(&#39;子页面&#39;);\n  console.log(obj);\n  let parentWindow &#x3D; obj.source;\n  parentWindow.postMessage(&#39;子页面传送的数据&#39;, &#39;*&#39;);\n&#125;);\n&#x2F;&#x2F; 子传父\nfunction sendMesg() &#123;\n  window.parent.window.postMessage(&#39;子页面传送的数据&#39;, &#39;*&#39;);\n&#125;</code></pre>\n\n<p><a href=\"https://blog.csdn.net/wangliuqi123/article/details/109577991\" target=\"_blank\" >见</a></p>\n<h2 id=\"transition-和-animation-的属性分别有哪些\"><a href=\"#transition-和-animation-的属性分别有哪些\" class=\"headerlink\" title=\"transition 和 animation 的属性分别有哪些\"></a>transition 和 animation 的属性分别有哪些</h2><p><a href=\"https://blog.csdn.net/gtLBTNq9mr3/article/details/123587378\" target=\"_blank\" >见</a></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">对比点</th>\n<th align=\"left\">transition</th>\n<th align=\"left\">animation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>侧重点</code></td>\n<td align=\"left\"><code>单一动画属性</code>的过度效果,其<code>过程是简单</code>，<br/>由开始到结束的过程，中间不存在可能的动画转折</td>\n<td align=\"left\">强调的是<code>多种动画属性的结合</code>，<br/>按时间轴线出现周折性动画变换的动画过程，其过程是复杂的</td>\n</tr>\n<tr>\n<td align=\"left\"><code>状态</code></td>\n<td align=\"left\">开始状态 和 结束状态</td>\n<td align=\"left\">多个状态，有帧的概念</td>\n</tr>\n<tr>\n<td align=\"left\"><code>功能更强大</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">“播放次数”、“播放方向”、“播放状态”</td>\n</tr>\n<tr>\n<td align=\"left\"><code>触发</code></td>\n<td align=\"left\">选择器&#x2F;js 来触发</td>\n<td align=\"left\">自动触发</td>\n</tr>\n<tr>\n<td align=\"left\"><code>使用规则</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">需 @keyframes &#x2F;animation-name</td>\n</tr>\n<tr>\n<td align=\"left\"><code>动效控制</code></td>\n<td align=\"left\">“持续时间”、“延迟时间” 、“时间缓动函数”</td>\n<td align=\"left\">同前者</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2018/06/css3-animation-steps-step-start-end/\" target=\"_blank\" >CSS3 animation 属性中的 steps 功能符深入介绍</a></p>\n<ol>\n<li><p><code>状态</code>：CSS 的 transition 只有两个状态：开始状态 和 结束状态；但 animation 可能是多个状态，有帧的概念</p>\n</li>\n<li><p><code>触发</code>：CSS 的 transition 需要借助别的方式来触发，比如 CSS 的状态选择器（如:hover）或 借助 JavaScript 来触发；animation 可以自动触发</p>\n</li>\n<li><p><code>动效控制</code>：CSS transition 和 animation 虽然实现动效方式不同，但他们之间有些概念是相同的。比如他们都有“持续时间”、“延迟时间” 和“时间缓动函数”等概念，这些都是用来控制动效的效果。</p>\n</li>\n<li><p>CSS 的 animation 是离不开 @keyframes 的，换句话说，我们需要先使用 @keyframes 来注册一个动画效果，即帧来描述动画效果。当然，只注册也不见得有效果，还是需要使用 animation-name 属性引用 @keyframes 注册好的动画效果。</p>\n</li>\n<li><p>animation 控制动效上要比 transition 强，因为它具备一些控制动效的属性，比如“播放次数”、“播放方向”、“播放状态”等。</p>\n</li>\n<li><p>CSS transition 强调的是单一动画属性的过度效果,其过程是简单的，由开始到结束的过程，中间不存在可能的动画转折，只有 0 到 1，比喻：渐隐，渐显;</p>\n</li>\n<li><p>CSS animation 强调的是多种动画属性的结合，按时间轴线出现周折性动画变换的动画过程，其过程是复杂的，由开始——&gt;结束的过程中，存在可能的动画转折，其过程可能是开始—0—1—2—3&gt;结束的过程。</p>\n</li>\n</ol>\n<p>综合来说：CSS animation 可以包括 CSS transition 的动画形式。感觉两者之间,transition 像是 animation 的子集。</p>\n<h2 id=\"CSS3-font\"><a href=\"#CSS3-font\" class=\"headerlink\" title=\"CSS3 font\"></a>CSS3 font</h2><ol>\n<li>必须要先有字体文件</li>\n<li><code>@font-face</code>声明字体<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  @font-face &#123;\n    font-family: myFirstFont;\n    src: url(&#39;你自己的字体文件路径.ttf&#39;);\n  &#125;\n&lt;&#x2F;style&gt;</code></pre></li>\n<li>css 选择器中使用 <code>font-family</code></li>\n</ol>\n<h2 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h2><h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的技术。</p>\n<p><em>函数柯里化，是可以用来慢慢凑齐参数，延迟函数的执行。（先分期交钱，后交货！）</em></p>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>函数有记忆功能（多次接受参数，记忆历史参数信息），累积接受参数个数函数小于定义参数个数时返回一个函数，继续接受参数，<code>典型的闭包 + 递归</code></p>\n<h3 id=\"为什么会出现\"><a href=\"#为什么会出现\" class=\"headerlink\" title=\"为什么会出现\"></a>为什么会出现</h3><h3 id=\"柯里化-1\"><a href=\"#柯里化-1\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const curry &#x3D; (fn, ...rest) &#x3D;&gt; &#123;\n  return (...args) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;判断参数总数是否和fn参数个数相等\n    if ([...rest, ...args].length &#x3D;&#x3D;&#x3D; fn.length) &#123;\n      return fn(...rest, ...args); &#x2F;&#x2F;拓展参数，调用fn\n    &#125; else &#123;\n      return curry(fn, [...rest, ...args]); &#x2F;&#x2F;迭代，传入现有的所有参数\n    &#125;\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; const curry &#x3D; (fn, ...args1) &#x3D;&gt; (...args2) &#x3D;&gt; ((arg) &#x3D;&gt; (arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, ...arg)))([\n&#x2F;&#x2F;       ...args1,\n&#x2F;&#x2F;       ...args2,\n&#x2F;&#x2F;     ]);\n\n&#x2F;&#x2F; 调用\nconst foo &#x3D; (a, b, c) &#x3D;&gt; a * b * c;\ncurry(foo)(2, 3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2)(3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3)(4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3, 4)(); &#x2F;&#x2F; -&gt; 24</code></pre>\n\n<p><a href=\"https://www.jianshu.com/p/c87242cd2f6c\" target=\"_blank\" >见</a></p>\n<h2 id=\"异步编程-promise-与-async-的区别\"><a href=\"#异步编程-promise-与-async-的区别\" class=\"headerlink\" title=\"异步编程 promise 与 async 的区别\"></a>异步编程 promise 与 async 的区别</h2><h3 id=\"async-特点\"><a href=\"#async-特点\" class=\"headerlink\" title=\"async 特点\"></a>async 特点</h3><h4 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h4><ol>\n<li>async 解决了什么问题 promise 链式调用的烦恼</li>\n<li>async 和 await 关键字,让我们可以用一种更简洁的方式， 写出基于 Promise 的异步行为，而无需刻意地链式调用 promise</li>\n</ol>\n<h4 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h4><ul>\n<li>async 函数是 AsyncFunction 构造函数的实例 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function#:~:text=async%20%E5%87%BD%E6%95%B0%E6%98%AF%20AsyncFunction%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B\" target=\"_blank\" >见</a></li>\n</ul>\n<h4 id=\"是什么-1\"><a href=\"#是什么-1\" class=\"headerlink\" title=\"是什么\"></a>是什么</h4><ol>\n<li>async 函数可能包含 0 个或者多个 await 表达式。</li>\n<li>await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。</li>\n<li>promise 的解决值会被当作该 await 表达式的返回值</li>\n</ol>\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ol>\n<li>从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。</li>\n<li>一个不含 await 表达式的 async 函数是会同步运行的。</li>\n<li>如果函数体内有一个 await 表达式，async 函数就<code>一定</code>会异步执行。</li>\n</ol>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><ul>\n<li>async 返回值<code>一定</code>为 promise, 如果返回值不是 promise，将会被隐式包装在一个 promise 中</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function foo() &#123;\n  return 1;\n&#125;\n&#x2F;&#x2F; 等价于\nfunction foo() &#123;\n  return Promise.resolve(1);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(1);\nasync function foo() &#123;\n  console.log(2);\n  await 1;\n  console.log(3);\n&#125;\nfoo();\nconsole.log(4);\n\n&#x2F;&#x2F; 结果：1243</code></pre>\n\n<h4 id=\"两个-await-执行说明\"><a href=\"#两个-await-执行说明\" class=\"headerlink\" title=\"两个 await, 执行说明\"></a>两个 await, 执行说明</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function foo() &#123;\n  const result1 &#x3D; await new Promise((resolve) &#x3D;&gt; setTimeout(() &#x3D;&gt; resolve(&#39;1&#39;)));\n  const result2 &#x3D; await new Promise((resolve) &#x3D;&gt; setTimeout(() &#x3D;&gt; resolve(&#39;2&#39;)));\n&#125;\nfoo();</code></pre>\n\n<ol>\n<li>foo 函数的第一行将会同步执行，await 将会等待 promise 的结束。然后暂停通过 foo 的进程，并将控制权交还给调用 foo 的函数。(控制权转出)</li>\n<li>一段时间后，当第一个 promise 完结的时候，控制权将重新回到 foo 函数内。示例中将会将 1（promise 状态为 fulfilled）作为结果返回给 await 表达式的左边即 result1。 (控制权转入)</li>\n<li>接下来函数会继续进行，到达第二个 await 区域，此时 foo 函数的进程将再次被暂停。(控制权转出)</li>\n<li>一段时间后，同样当第二个 promise 完结的时候，result2 将被赋值为 2，之后函数将会正常同步执行，将默认返回 undefined (控制权转入)</li>\n</ol>\n<p><em>注意： promise 链不是一次就构建好的，相反，promise 链是分阶段构造的，因此在处理异步函数时必须注意对错误函数的处理。</em></p>\n<h4 id=\"async-x2F-await-和-Promise-x2F-then-对比以及错误处理\"><a href=\"#async-x2F-await-和-Promise-x2F-then-对比以及错误处理\" class=\"headerlink\" title=\"async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理\"></a>async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理</h4><ol>\n<li>大多数 async 函数也可以使用 Promises 编写。但是，<code>在错误处理方面，async 函数更容易捕获异常错误</code></li>\n<li>如果任一 <code>awaited 调用失败</code>，它将<code>自动捕获异常</code>，async 函数<code>执行中断</code>，并通过<code>隐式返回 Promise </code>将错误传递给调用者</li>\n<li><code>async 函数仍有可能然可能错误地忽略错误</code>. 在 async 中， 没有等待 await 返回，则不会传播任何错误</li>\n</ol>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>简单</code>：promise 链式调用繁杂，async&#x2F;await 相对来说，更简单</li>\n<li><code>并发</code>：promise api 能够实现并发， async&#x2F;await 只会顺序执行</li>\n<li><code>返回</code>：async&#x2F;await 的返回值，一定是一个 promise，会进行隐式的包装（如果在发生错误时候进行，捕获处理然后返回一个值，之后真正返回并不是这个值，而是被 promise 包装了）</li>\n<li><code>错误</code>：async&#x2F;await 在处理错误方面更容易（任意一个 await 出错，会自动捕获异常，执行中断，隐式返回 promise 错误，这几个环环相扣）,如果没有等待返回的情况下，async 可能错误的忽略错误，不进行传播错误</li>\n<li><code>错误捕获</code>：因 async&#x2F;await 一定返回的是 promise,所以 async&#x2F;await 既可以用<code>try catch</code>， 也可以用<code>.catch</code> (<code>try catch</code>是 js 语法，<code>.catch</code>是<code>promise.catch</code>语法)</li>\n</ol>\n<h2 id=\"包装对象-x2F-原型与原型链\"><a href=\"#包装对象-x2F-原型与原型链\" class=\"headerlink\" title=\"包装对象&#x2F;原型与原型链\"></a>包装对象&#x2F;原型与原型链</h2><h3 id=\"包装对象的含义\"><a href=\"#包装对象的含义\" class=\"headerlink\" title=\"包装对象的含义\"></a>包装对象的含义</h3><p>（Number&#x2F;String）经过封装，能够处理（number&#x2F;string）的对象</p>\n<h3 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h3><div style=\"display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;\">\n<img src=\"http://t-blog-images.aijs.top/img/202210261711923.webp\" style=\"width: 550px;max-width:100%\" />\n<div style=\"width:10px\"></div>\n<img src=\"http://t-blog-images.aijs.top/img/202210261734112.webp\" style=\"width: 360px;max-width:100%\"/>\n</div>\n\n<p>细品 原型与原型链关系图：</p>\n<p>竖着看分为三栏：左侧为实例对象，中间为构造函数，右侧为原型对象</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">实例</th>\n<th align=\"left\">构造函数 <span style=\"color: red\">created by Function</span></th>\n<th align=\"left\">原型对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">new Foo&#x2F;Number&#x2F;String</td>\n<td align=\"left\">function Foo&#x2F;Number&#x2F;String()</td>\n<td align=\"left\">Foo&#x2F;Number&#x2F;String.prototype</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">new Object</td>\n<td align=\"left\">function Object()</td>\n<td align=\"left\">Object.prototype</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n<td align=\"left\">function Function()</td>\n<td align=\"left\">Function.prototype</td>\n</tr>\n</tbody></table>\n<p><strong>注意：序号 1</strong><br>从 MDN Number 包装对象的目录接口也可以看出：Number 的原型链： <code>Function.prototype -&gt; Object.prototype -&gt; null</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; .__proto__ 表示：隐式原型\n&#x2F;&#x2F; .prototype 表示：显示原型\n实例.__proto__ &#x3D;&#x3D; 实例的原型对象\n构造函数的.__proto__ &#x3D;&#x3D; Function 的原型对象\n原型对象的.constructor &#x3D;&#x3D; 对应的构造函数\n构造函数的.prototype &#x3D;&#x3D; 对应的原型对象\n非(Object 和 null)的.__proto__ &#x3D;&#x3D; Object.prototype\nObject.__proto__ &#x3D;&#x3D; null\n\n&#x2F;&#x2F; 有意思的是 Function\nFunction.__proto__ &#x3D;&#x3D; Function.prototype\n</code></pre>\n\n<h2 id=\"Object-freeze-vs-Object-seal-vs-Object-preventExtensions\"><a href=\"#Object-freeze-vs-Object-seal-vs-Object-preventExtensions\" class=\"headerlink\" title=\"Object.freeze() vs Object.seal() vs Object.preventExtensions()\"></a>Object.freeze() vs Object.seal() vs Object.preventExtensions()</h2><h3 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze()\"></a>Object.freeze()</h3><ol>\n<li>不增加新属性、不删除已有属性、不赋值</li>\n<li>子属性对象可编辑</li>\n</ol>\n<h3 id=\"Object-seal\"><a href=\"#Object-seal\" class=\"headerlink\" title=\"Object.seal()\"></a>Object.seal()</h3><ol>\n<li>不增加新属性、不删除已有属性</li>\n<li>可赋值</li>\n</ol>\n<h3 id=\"Object-preventExtensions\"><a href=\"#Object-preventExtensions\" class=\"headerlink\" title=\"Object.preventExtensions()\"></a>Object.preventExtensions()</h3><ol>\n<li>不增加新属性</li>\n<li>可改已有属性</li>\n</ol>\n<h3 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h3><table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">默认</th>\n<th align=\"left\">preventExtensions</th>\n<th align=\"left\">seal</th>\n<th align=\"left\">freeze</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">增加新属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">移除属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">更改属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">子对象属性操作</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://javascript.plainenglish.io/object-freeze-vs-object-seal-vs-object-preventextensions-e78ef3a24201\" target=\"_blank\" >见</a></p>\n<h2 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"前端工程化\"></a>前端工程化</h2><h3 id=\"是什么-2\"><a href=\"#是什么-2\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><ol>\n<li>通过<code>制定规范</code>、<code>借助工具和框架</code>, 解决前端开发, 以及前后端协作过程中的<code>痛点和难度问题</code>,<code>提高研发效率</code></li>\n</ol>\n<h3 id=\"为什么-1\"><a href=\"#为什么-1\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><ol>\n<li>随着需求的增加，前端也变成大前端，还要做 App、小程序以及各种端。</li>\n<li>在这种需求日增的情况下，必须得考虑一种新的方式，优化前端的开发工作，</li>\n<li>例如，<code>解决代码冗余</code>，<code>项目可维护性</code>，<code>提升版本迭代速度</code>等等一系列的问题。前端工程化的概念也就是在这中情况下被提出了。</li>\n</ol>\n<h3 id=\"如何实施前端工程化\"><a href=\"#如何实施前端工程化\" class=\"headerlink\" title=\"如何实施前端工程化\"></a>如何实施前端工程化</h3><ol>\n<li>前端后分离</li>\n<li>使用 webpack 实现项目构建</li>\n<li>使用 babel 完成 javascript 编译</li>\n<li>CSS 预编译</li>\n<li>组件化</li>\n<li>模块化开发</li>\n<li>本地开发环境&#x2F;模拟数据</li>\n<li>规范化约束</li>\n<li>项目部署</li>\n</ol>\n<h2 id=\"npm-run-做了什么\"><a href=\"#npm-run-做了什么\" class=\"headerlink\" title=\"npm run 做了什么\"></a>npm run 做了什么</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; package.json; -&gt; node_modules&#x2F;.bin&#x2F; -&gt;对应的可执行文件执行\n\n&#x2F;&#x2F; 在安装依赖的时候，是通过npm install xxx来执行的，\n&#x2F;&#x2F; 例如npm install @vue&#x2F;cli-service,npm在安装这个依赖的时候，\n&#x2F;&#x2F; 就会在node_modules&#x2F;.bin&#x2F;目录中创建好vue-cli-service为名的几个可执行文件了【不同系统对应不同的可执行文件】\n&#x2F;&#x2F; .bin目录下的文件不是任何一个npm包。目录下的文件，表示这是一个个软连接，打开文件可以看到文件顶部写着#!&#x2F;bin&#x2F;sh,表示这是一个脚本\n\n&#x2F;&#x2F; 当使用 npm run serve 执行 vue-cli-service serve时，\n&#x2F;&#x2F; 虽然没有安装 vue-cli-service的全局命令，但是npm 会到 .&#x2F;node_modules&#x2F;.bin中找到 vue-cli-service 文件作为 脚本来执行，\n&#x2F;&#x2F; 则相当于执行了 .&#x2F;node_modules&#x2F;.bin&#x2F;vue-cli-service serve（最后的 serve 作为参数传入）</code></pre>\n\n<h2 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h2><p><strong>1. 检查配置</strong></p>\n<ol>\n<li>项目级别的.npmrc 文件 &gt;</li>\n<li>用户级别的.npmrc 文件 &gt;</li>\n<li>全局的.npmrc 文件 &gt;</li>\n<li>npm 内置的.npmrc 文件;</li>\n</ol>\n<p><strong>2、没有 lock 文件</strong></p>\n<ol>\n<li><code>分析</code>：分析依赖关系，这是因为我们包会依赖其他的包，并且会多个包之间产生相同的依赖的关系。</li>\n<li><code>下载</code>：从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）。</li>\n<li><code>缓存</code>：获取到压缩包后会对压缩包进行缓存（从 npm5 开始有的）。</li>\n<li><code>解压缩</code>：将压缩包解压到项目的 node_modules 文件夹中（前面我们讲过，require 的查找顺序会在该包下面查找）。</li>\n</ol>\n<p><strong>3、有 lock 文件</strong></p>\n<ol>\n<li><code>比对</code>：检测 lock 中包的版本是否和 package.json 中一致（会按照 semver 版本规范检测）。</li>\n<li><code>无缓存</code>：不一致，那么会重新构建依赖关系，直接会走顶层的流程。</li>\n<li><code>有缓存</code>：一致的情况下，会去优先查找缓存。没有找到，会从 registry 仓库下载，直接走顶层流程。</li>\n<li><code>查找到</code>：会获取缓存中的压缩文件，并且将压缩文件解压到 node_modules 文件夹中。</li>\n</ol>\n<h2 id=\"实现-jsonp，传入-URL，callback-和-callbackName-三个参数\"><a href=\"#实现-jsonp，传入-URL，callback-和-callbackName-三个参数\" class=\"headerlink\" title=\"实现 jsonp，传入 URL，callback 和 callbackName 三个参数\"></a>实现 jsonp，传入 URL，callback 和 callbackName 三个参数</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function jsonp(url, callbackName, callback) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    try &#123;\n      let str &#x3D; &#96;$&#123;url&#125;?callback&#x3D;$&#123;callbackName&#125;&#96;;\n      &#123;\n        &#x2F;* 创建标签 *&#x2F;\n      &#125;\n      let scriptEle &#x3D; document.createElement(&#39;script&#39;);\n      scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;;\n      scriptEle.src &#x3D; str;\n      &#123;\n        &#x2F;* 监听加载 *&#x2F;\n      &#125;\n      scriptEle.addEventListener(&#39;load&#39;, callback);\n      &#123;\n        &#x2F;* 回调清理 *&#x2F;\n      &#125;\n      window[callbackName] &#x3D; function (data) &#123;\n        resolve(data);\n        document.body.removeChild(scriptEle);\n      &#125;;\n      document.body.appendChild(scriptEle);\n    &#125; catch (err) &#123;\n      reject(err);\n    &#125;\n  &#125;);\n&#125;\n\njsonp(&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;home&#39;, &#39;fun1&#39;, () &#x3D;&gt; &#123;\n  console.log(&#39;加载成功&#39;);\n&#125;).then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);</code></pre>\n\n<h2 id=\"原生-js-实现动态加载-js-文件\"><a href=\"#原生-js-实现动态加载-js-文件\" class=\"headerlink\" title=\"原生 js 实现动态加载 js 文件?\"></a>原生 js 实现动态加载 js 文件?</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function loadScript(src, attrs) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    try &#123;\n      &#x2F;&#x2F; 创建标签\n      let scriptEle &#x3D; document.createElement(&#39;script&#39;);\n      &#x2F;&#x2F; 类型\n      scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;;\n      &#x2F;&#x2F; src\n      scriptEle.src &#x3D; src;\n      &#x2F;&#x2F; 增加属性\n      for (let key in attrs) &#123;\n        scriptEle.setAttribute(key, attrs[key]);\n      &#125;\n      &#x2F;&#x2F; 监听完成\n      scriptEle.addEventListener(&#39;load&#39;, function () &#123;\n        resolve(&#39;成功&#39;);\n      &#125;);\n      &#x2F;&#x2F; 挂载后加载\n      document.body.appendChild(scriptEle);\n    &#125; catch (err) &#123;\n      reject(err);\n    &#125;\n  &#125;);\n&#125;\nloadScript(&#39;http:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.6.2&#x2F;jquery.min.js&#39;, &#123; async: true &#125;).then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);</code></pre>\n\n<h2 id=\"js-中的-for-循环注意点？\"><a href=\"#js-中的-for-循环注意点？\" class=\"headerlink\" title=\"js 中的 for 循环注意点？\"></a>js 中的 for 循环注意点？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 多个判断条件以最后一个为准\n&#x2F;&#x2F; 最后一个是 j &lt; 9\nfor (var i &#x3D; 0, j &#x3D; 0; i &lt; 5, j &lt; 9; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4\n&#x2F;&#x2F; 5 5\n&#x2F;&#x2F; 6 6\n&#x2F;&#x2F; 7 7\n&#x2F;&#x2F; 8 8\n&#x2F;&#x2F; 最后一个是  i &lt; 5\nfor (var i &#x3D; 0, j &#x3D; 0; j &lt; 9, i &lt; 5; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4</code></pre>\n\n<h2 id=\"new-操作符和点运算符的优先级\"><a href=\"#new-操作符和点运算符的优先级\" class=\"headerlink\" title=\"new 操作符和点运算符的优先级\"></a>new 操作符和点运算符的优先级</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Foo() &#123;\n  getName &#x3D; function () &#123;\n    console.log(1);\n  &#125;; &#x2F;&#x2F;会修改全局的下的getName\n  return this; &#x2F;&#x2F; 构造函数的返回值值得注意，如果是引用类型，则得到引用数据，null除外\n&#125;\nFoo.getName &#x3D; function () &#123;\n  console.log(2);\n&#125;;\nFoo.prototype.getName &#x3D; function () &#123;\n  console.log(3);\n&#125;;\nvar getName &#x3D; function () &#123;\n  console.log(4);\n&#125;;\nfunction getName() &#123;\n  console.log(5);\n&#125;\n\n&#x2F;&#x2F;请写出以下输出结果：\nFoo.getName(); &#x2F;&#x2F;2\ngetName(); &#x2F;&#x2F; 4\nFoo().getName(); &#x2F;&#x2F; 1\ngetName(); &#x2F;&#x2F; 1\nnew Foo.getName(); &#x2F;&#x2F; 2 这里是new了一个Foo.getName函数，并没有先执行Foo.getName()在去执行new操作\nnew Foo().getName(); &#x2F;&#x2F; 3 (new Foo()).getName() 此时的getName是找到Foo构造函数的原型对象上的getName属性\nnew new Foo().getName(); &#x2F;&#x2F; 3  new ((new Foo()).getName)();\n&#x2F;*******************升级版********************&#x2F;\n&#x2F;&#x2F; function Foo() &#123;\n&#x2F;&#x2F; \t\tthis.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(3);\n&#x2F;&#x2F; \t\t\treturn &#123;\n&#x2F;&#x2F; \t\t\t\tgetName: getName&#x2F;&#x2F;这个就是第六问中涉及的构造函数的返回值问题\n&#x2F;&#x2F; \t\t\t&#125;\n&#x2F;&#x2F; \t\t&#125;;&#x2F;&#x2F;这个就是第六问中涉及到的， JS 构造函数公有方法和原型链方法的优先级\n&#x2F;&#x2F; \t\tgetName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(1);\n&#x2F;&#x2F; \t\t&#125;;\n&#x2F;&#x2F; \t\treturn this\n&#x2F;&#x2F; \t&#125;\n&#x2F;&#x2F; \tFoo.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(2);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tFoo.prototype.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(6);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tvar getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(4);\n&#x2F;&#x2F; \t&#125;;\n\n&#x2F;&#x2F; \tfunction getName() &#123;\n&#x2F;&#x2F; \t\tconsole.log(5);\n&#x2F;&#x2F; \t&#125; &#x2F;&#x2F;答案：\n&#x2F;&#x2F; \tFoo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;4\n&#x2F;&#x2F; \tconsole.log(Foo())\n&#x2F;&#x2F; \tFoo().getName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tnew Foo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tnew Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F;             &#x2F;&#x2F;多了一问\n&#x2F;&#x2F; \tnew Foo().getName().getName(); &#x2F;&#x2F;3 1\n&#x2F;&#x2F; \tnew new Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_34146986&#x2F;article&#x2F;details&#x2F;92386841</code></pre>\n\n<h2 id=\"new-一个构造函数，如果函数返回不同类型的值，结果会如何\"><a href=\"#new-一个构造函数，如果函数返回不同类型的值，结果会如何\" class=\"headerlink\" title=\"new 一个构造函数，如果函数返回不同类型的值，结果会如何?\"></a>new 一个构造函数，如果函数返回不同类型的值，结果会如何?</h2><p>new 的原理： 最后要判断构造函数返回值是不是个对象，不是对象是对象返回这个值，不是对象，返回构造函数的实例</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">null instanceof Object; &#x2F;&#x2F; false\nObject instanceof null; &#x2F;&#x2F; 报错，instanceof 的右侧必须是一个对象\n&#x2F;&#x2F; Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object</code></pre>\n\n<h3 id=\"什么都不返回\"><a href=\"#什么都不返回\" class=\"headerlink\" title=\"什么都不返回\"></a>什么都不返回</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回一个新的对象\"><a href=\"#返回一个新的对象\" class=\"headerlink\" title=\"返回一个新的对象\"></a>返回一个新的对象</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return &#123;\n    name: &#39;1234&#39;,\n  &#125;;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;&#123;name: &#39;1234&#39;&#125;</code></pre>\n\n<h3 id=\"返回一个原始值\"><a href=\"#返回一个原始值\" class=\"headerlink\" title=\"返回一个原始值\"></a>返回一个原始值</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return 111;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-null\"><a href=\"#返回-null\" class=\"headerlink\" title=\"返回 null\"></a>返回 null</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return null;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-true\"><a href=\"#返回-true\" class=\"headerlink\" title=\"返回 true\"></a>返回 true</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return true;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-this\"><a href=\"#返回-this\" class=\"headerlink\" title=\"返回 this\"></a>返回 this</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  &#x2F;&#x2F; 构造函数this指的是对象实例\n  return this;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1);\n&#x2F;&#x2F; Person &#123;&#125;\n\n&#x2F;&#x2F; 但是 this instanceof Object true, 这里涉及到this指向问题</code></pre>\n\n<h2 id=\"为什么要用-apply-x2F-call-这两个函数\"><a href=\"#为什么要用-apply-x2F-call-这两个函数\" class=\"headerlink\" title=\"为什么要用 apply&#x2F;call 这两个函数\"></a>为什么要用 apply&#x2F;call 这两个函数</h2><ol>\n<li>说白了就是“拿来主义”、“借刀杀人”的功效，</li>\n<li>比如我想做什么事，我不会不要紧，只要有人会就可以实现。</li>\n<li>在程序里面就是，现在假如你想用什么方法，但是当前对象没有，你可以选择拓展，自己造一个这样的方法，但是你也可以直接拿来用</li>\n</ol>\n<p>有时候这样使用更方便，我们只需要对象和回调方法即可，按照一般的说法就是：call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。</p>\n<p><a href=\"https://segmentfault.com/q/1010000006732812\" target=\"_blank\" >讲真，为什么要用 apply 和 call 这两个函数？</a></p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h3 id=\"height-x2F-width\"><a href=\"#height-x2F-width\" class=\"headerlink\" title=\"height&#x2F;width\"></a>height&#x2F;width</h3><p>width 中的 max-content,min-content,fit-content 的区别</p>\n<ol>\n<li><code>max-content</code> 实验性 设置为允许的最大高度。</li>\n<li><code>min-content</code> 实验性 设置为允许的最小高度。</li>\n<li><code>available</code> 实验性 包含块高度减去当前元素的边距，边框和填充。</li>\n<li><code>fit-content</code> 实验性 将 fill-content 公式中的可用位置替换为特定的参数以进行使用，如：<code>min(max-content, max(min-content, ))</code></li>\n</ol>\n<h3 id=\"width-属性-100-和-auto-的区别\"><a href=\"#width-属性-100-和-auto-的区别\" class=\"headerlink\" title=\"width 属性 100%和 auto 的区别\"></a>width 属性 100%和 auto 的区别</h3><ol>\n<li><p><code>width：100%</code><br>100%表示子元素的宽度和父元素的宽度相等，其中并不包括子元素内外边距以及边框的值，为子元素真正的宽度</p>\n</li>\n<li><p><code>width：auto</code><br>auto 表示子元素的 宽度+内边距+外边距+边框 才等于父元素的宽度</p>\n</li>\n</ol>\n<p><strong>注意：上述父元素的宽度都是父元素真正的宽度，即父元素 width 属性值</strong><br>————————————————<br>版权声明：本文为 CSDN 博主「Tie_may」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/Tie_may/article/details/113761173\">https://blog.csdn.net/Tie_may/article/details/113761173</a></p>\n<h3 id=\"vertical-align-middle\"><a href=\"#vertical-align-middle\" class=\"headerlink\" title=\"vertical-align: middle\"></a>vertical-align: middle</h3><p>Vertical-align 被<code>用于垂直对齐 inline 元素</code>，<code>也就是 display 值为 inline 和 inline-block 的元素</code></p>\n<p>CSS 的属性 vertical-align 用来指定<code>行内元素（inline）</code>或<code>表格单元格（table-cell）元素</code>的垂直对齐方式。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align\" target=\"_blank\" >MDN</a></p>\n<h3 id=\"will-change\"><a href=\"#will-change\" class=\"headerlink\" title=\"will-change\"></a>will-change</h3><ol>\n<li><code>不要将 will-change 应用到太多元素上：</code>浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。</li>\n<li><code>有节制地使用：</code>通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。</li>\n<li><code>不要过早应用 will-change 优化：</code>如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是<code>作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题</code>。<code>过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程</code>，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。</li>\n<li><code>给它足够的工作时间：</code>这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。</li>\n</ol>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><ol>\n<li><p><code>auto</code><br>盒子不会创建一个新的本地堆叠上下文。在当前堆叠上下文中生成的盒子的堆叠层级和父级盒子相同。</p>\n</li>\n<li><p><code>&lt;integer&gt;</code><br><code>&lt;integer&gt;</code>（整型数字）是生成的盒子在当前堆叠上下文中的堆叠层级。</p>\n</li>\n</ol>\n<p><strong>此盒子也会创建一个堆叠层级为 0 的本地堆叠上下文。这意味着后代（元素）的 z-indexes 不与此元素的外部元素的 z-indexes 进行对比。</strong></p>\n<h3 id=\"介绍下盒模型\"><a href=\"#介绍下盒模型\" class=\"headerlink\" title=\"介绍下盒模型\"></a>介绍下盒模型</h3><img src=\"http://t-blog-images.aijs.top/img/202301311827280.webp\" />\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model\" target=\"_blank\" >见</a></p>\n<h3 id=\"CSS-是怎么工作的\"><a href=\"#CSS-是怎么工作的\" class=\"headerlink\" title=\"CSS 是怎么工作的\"></a>CSS 是怎么工作的</h3><ol>\n<li><code>浏览器载入 HTML 文件（比如从网络上获取）</code>。</li>\n<li><code>将 HTML 文件转化成一个 DOM（Document Object Model）</code>，DOM 是文件在计算机内存中的表现形式，下一节将更加详细的解释 DOM。</li>\n<li><code>接下来，浏览器会拉取该 HTML 相关的大部分资源</code>，比如嵌入到页面的图片、视频和 CSS 样式。JavaScript 则会稍后进行处理，简单起见，同时此节主讲 CSS，所以这里对如何加载 JavaScript 不会展开叙述。</li>\n<li><code>浏览器拉取到 CSS 之后会进行解析</code>，<code>根据选择器的不同类型（比如 element、class、id 等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）</code>。</li>\n<li>上述的规则应用于渲染树之后，<code>渲染树会依照应该出现的结构进行布局</code>。</li>\n<li><code>网页展示在屏幕上（这一步被称为着色）</code>。</li>\n</ol>\n<img src=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works/rendering.svg\" style=\"width:500px;max-width:100%\" />\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works\" target=\"_blank\" >见</a>\n\n<h3 id=\"当浏览器遇到无法解析的-CSS-代码会发生什么\"><a href=\"#当浏览器遇到无法解析的-CSS-代码会发生什么\" class=\"headerlink\" title=\"当浏览器遇到无法解析的 CSS 代码会发生什么\"></a>当浏览器遇到无法解析的 CSS 代码会发生什么</h3><p>浏览器什么也不会做，继续解析下一个 CSS 样式！</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works#%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E9%81%87%E5%88%B0%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84_css_%E4%BB%A3%E7%A0%81%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\" target=\"_blank\" >见</a></p>\n<h3 id=\"层叠、优先级和继承\"><a href=\"#层叠、优先级和继承\" class=\"headerlink\" title=\"层叠、优先级和继承\"></a>层叠、优先级和继承</h3><p>层叠相关因素：<code>资源顺序、优先级 、重要程度</code></p>\n<ol>\n<li><code>样式表层叠</code>——简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</li>\n<li><code>优先级</code> 浏览器是根据<code>优先级</code>来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度：<code>越具体优先级越高</code>,权重越大，优先级越高</li>\n<li><code>继承</code>也需要在上下文中去理解——一些设置在父元素上的 CSS 属性是可以被子元素继承的，有些则不能</li>\n</ol>\n<h3 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"!important\"></a>!important</h3><p>强烈建议除了非常情况不要使用它<br>覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有相同优先级而且顺序靠后，或者更高优先级。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"从-performanceAPI-来讲\"><a href=\"#从-performanceAPI-来讲\" class=\"headerlink\" title=\"从 performanceAPI 来讲\"></a>从 performanceAPI 来讲</h3><p>一大堆…,简单说要个几分钟，展开来讲几十分钟，几个小时</p>\n<h3 id=\"协议优化\"><a href=\"#协议优化\" class=\"headerlink\" title=\"协议优化\"></a>协议优化</h3><ol>\n<li>http2 优于 http1</li>\n<li>http3 优于 http2</li>\n</ol>\n<h3 id=\"加载优化\"><a href=\"#加载优化\" class=\"headerlink\" title=\"加载优化\"></a>加载优化</h3><ol>\n<li>预加载</li>\n<li>懒加载 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\" target=\"_blank\" >Intersection Observer</a></li>\n<li>按需加载</li>\n<li>延迟加载、异步加载</li>\n<li>压缩（webpack 来讲 html、css、js、json、image 都可以压缩）</li>\n<li>CDN</li>\n</ol>\n<h3 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h3><ol>\n<li>css、htm 嵌套减少</li>\n<li>react-native 里有个视图拍平优化</li>\n<li>回流和重绘</li>\n<li>按需渲染</li>\n<li>useCallback、useMemo、shouldComponentUpdate 浅比较</li>\n<li>局部渲染、局部刷新</li>\n</ol>\n<h3 id=\"缓存优化\"><a href=\"#缓存优化\" class=\"headerlink\" title=\"缓存优化\"></a>缓存优化</h3><ol>\n<li>强缓存</li>\n<li>协商缓存</li>\n<li>闭包数据缓存</li>\n</ol>\n<h3 id=\"更新优化\"><a href=\"#更新优化\" class=\"headerlink\" title=\"更新优化\"></a>更新优化</h3><ol>\n<li>虚拟 dom,批量更新</li>\n<li>按需更新 immutable.js、immerjs</li>\n</ol>\n<h3 id=\"上线后收集用户信息\"><a href=\"#上线后收集用户信息\" class=\"headerlink\" title=\"上线后收集用户信息\"></a>上线后收集用户信息</h3><ol>\n<li>performanceAPI</li>\n<li>web-vital</li>\n</ol>\n<h3 id=\"收集后分析处理\"><a href=\"#收集后分析处理\" class=\"headerlink\" title=\"收集后分析处理\"></a>收集后分析处理</h3><ol>\n<li>浏览器 performance 窗口 分析 longtask</li>\n<li>浏览器 mermory monitor 分析内存的释放情况</li>\n<li>浏览器 Record coverage while performance tracing <a href=\"https://blog.csdn.net/qq_43127921/article/details/122151253\" target=\"_blank\" >见</a></li>\n<li>lighthouse 插件</li>\n<li>Web Vitals 插件</li>\n</ol>\n<h3 id=\"页面可见性-API\"><a href=\"#页面可见性-API\" class=\"headerlink\" title=\"页面可见性 API\"></a>页面可见性 API</h3><p>document.hidden&#x2F;visibilitychange</p>\n<ol>\n<li>网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片。</li>\n<li>显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。</li>\n<li>页面想要检测是否正在渲染，以便可以准确的计算网页浏览量</li>\n<li>当设备进入待机模式时，网站想要关闭设备声音（用户按下电源键关闭屏幕）</li>\n</ol>\n<h3 id=\"按需拷贝\"><a href=\"#按需拷贝\" class=\"headerlink\" title=\"按需拷贝\"></a>按需拷贝</h3><p>immerjs</p>\n<h2 id=\"原生-js-深拷贝-x2F-浅拷贝\"><a href=\"#原生-js-深拷贝-x2F-浅拷贝\" class=\"headerlink\" title=\"原生 js 深拷贝&#x2F;浅拷贝\"></a>原生 js 深拷贝&#x2F;浅拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><ol>\n<li>所有标准的内置对象复制操作创建的是浅拷贝而不是深拷贝<ol>\n<li><code>展开语法</code></li>\n<li><code>Array.prototype.concat()</code>、<code>Array.prototype.slice()</code>、<code>Array.from()</code></li>\n<li><code>Object.assign()</code> 和 <code>Object.create()</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><ol>\n<li>对象的深拷贝是指其属性与其拷贝的源对象的属性不共享相同的引用（指向相同的底层值）的副本。</li>\n<li>因此，当你更改源或副本时，可以确保不会导致其他对象也发生更改；</li>\n<li>不会出现无意中对源或副本造成意料之外的更改</li>\n</ol>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy\" target=\"_blank\" >深拷贝</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/web/api/structuredClone\" target=\"_blank\" >window.structuredClone</a></p>\n<h3 id=\"window-structuredClone\"><a href=\"#window-structuredClone\" class=\"headerlink\" title=\"window.structuredClone\"></a>window.structuredClone</h3><p><code>structuredClone</code> 是浏览器提供的一个用于深度复制对象的方法，可以将包括 JavaScript 对象、TypedArray、ArrayBuffer 等数据类型在内的大多数对象进行复制，并且还支持复制一些浏览器 API 对象（如 File、Blob、ImageBitmap 等）。</p>\n<p>与传统的 <code>JSON.parse()</code> 和 <code>JSON.stringify()</code> 相比，<code>structuredClone</code> 更加强大，可以复制更多类型的对象，而且支持复制对象的内部循环引用。</p>\n<p><code>structuredClone</code> 方法只能在主线程中使用，不能在 Worker 中使用。并且由于该方法是浏览器独有的，不能在 Node.js 环境中使用。</p>\n<h2 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react-native\"></a>react-native</h2><h3 id=\"react-native-新特性\"><a href=\"#react-native-新特性\" class=\"headerlink\" title=\"react-native 新特性\"></a>react-native 新特性</h3><ol>\n<li>恢复 PropTypes</li>\n<li>默认情况下为 TypeScript</li>\n<li>使用 Flexbox Gap 简化布局</li>\n<li>受 Web 启发,对可访问性、样式和事件进行增强</li>\n<li>开发者体验改进</li>\n<li>新架构更新</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202302182122000.webp\" />\n\n<p><a href=\"https://reactnative.dev/blog\" target=\"_blank\" >https://reactnative.dev/blog</a></p>\n<h3 id=\"react-native-与原生的通信\"><a href=\"#react-native-与原生的通信\" class=\"headerlink\" title=\"react-native 与原生的通信\"></a>react-native 与原生的通信</h3><p><a href=\"/#/post/2023-02-17rn-native\" target=\"_blank\" >见：2023-02-17rn-native</a></p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ol>\n<li><p>数组中有哪些方法</p>\n<ol>\n<li><p>构造方法<br>在 JavaScript 中，数组有两种构造方法：</p>\n<ol>\n<li>使用 <code>Array()</code> 构造函数</li>\n</ol>\n<p>可以使用 <code>Array()</code> 构造函数来创建一个新的空数组，或者使用 <code>Array()</code> 构造函数并提供一个初始化数组的列表来创建一个新的数组。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 创建一个空数组\nlet arr1 &#x3D; new Array();\n\n&#x2F;&#x2F; 创建一个包含 3 个元素的数组\nlet arr2 &#x3D; new Array(3);\n\n&#x2F;&#x2F; 创建一个包含 3 个元素的数组，并进行初始化\nlet arr3 &#x3D; new Array(1, 2, 3);</code></pre>\n\n<ol start=\"2\">\n<li>使用数组字面量（Array Literals）</li>\n</ol>\n<p>使用数组字面量是创建数组的一种简单方式，使用一对方括号 <code>[]</code>，其中包含用逗号分隔的数组元素列表。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 创建一个包含 3 个元素的数组，并进行初始化\nlet arr &#x3D; [1, 2, 3];</code></pre>\n</li>\n<li><p>静态方法</p>\n<ol>\n<li>Array.from()： 从数组类对象或可迭代对象创建一个新的 Array 实例。</li>\n<li>Array.isArray()：如果参数是数组则返回 true ，否则返回 false 。</li>\n<li>Array.of()： 创建一个新的 Array 实例，具有可变数量的参数，而不管参数的数量或类型。</li>\n</ol>\n</li>\n<li><p>在访问索引之前执行 <code>in 检查</code>，并且<code>不将空槽与 undefined 合并</code>：</p>\n<ol>\n<li>concat()</li>\n<li>every()</li>\n<li>some()</li>\n<li>flat()</li>\n<li>flatMap()</li>\n<li>indexOf()</li>\n<li>forEach()</li>\n<li>lastIndexOf()</li>\n<li>map()</li>\n<li>filter()</li>\n<li>reduce()</li>\n<li>reduceRight()</li>\n<li>slice()</li>\n<li>reverse()</li>\n<li>sort()</li>\n<li>copyWithin()</li>\n</ol>\n</li>\n<li><p>将空槽视为 undefined：</p>\n<ol>\n<li>join()</li>\n<li>keys()</li>\n<li>values()</li>\n<li>entries()</li>\n<li>fill()</li>\n<li>find()</li>\n<li>findIndex()</li>\n<li>findLast()</li>\n<li>findLastIndex()</li>\n<li>includes()</li>\n<li>group() (en-US)</li>\n<li>groupToMap() (en-US)</li>\n<li>toLocaleString()</li>\n</ol>\n</li>\n<li><p>创建新数组的</p>\n<ol>\n<li>concat()</li>\n<li>map()</li>\n<li>filter()</li>\n<li>slice()</li>\n<li>splice()（构造返回的已删除元素数组）</li>\n<li>flat()</li>\n<li>flatMap()</li>\n</ol>\n</li>\n<li><p>可以对原数组进行修改：</p>\n<ol>\n<li>shift() &#x2F;&#x2F; 去掉</li>\n<li>unshift() &#x2F;&#x2F; 增加</li>\n<li>push()</li>\n<li>pop()</li>\n<li>splice()</li>\n<li>fill()</li>\n<li>reverse()</li>\n<li>sort()</li>\n<li>copyWithin()</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"数组-group\"><a href=\"#数组-group\" class=\"headerlink\" title=\"数组 group\"></a>数组 group</h3><p>JavaScript 中的数组没有内置的 <code>group</code> 方法，但可以通过编写自定义函数来实现类似的功能。</p>\n<p>通常实现数组分组的方法有两种：</p>\n<ol>\n<li><p>基于 <code>reduce</code> 方法实现分组</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function groupBy(array, func) &#123;\n  return array.reduce((result, item) &#x3D;&gt; &#123;\n    const group &#x3D; func(item);\n    if (!result[group]) &#123;\n      result[group] &#x3D; [];\n    &#125;\n    result[group].push(item);\n    return result;\n  &#125;, &#123;&#125;);\n&#125;</code></pre>\n\n<p>上述函数接受两个参数，第一个参数是要进行分组的数组，第二个参数是一个函数，用于返回指定项的分组键。该函数内部使用 <code>reduce</code> 方法，遍历数组，将每个元素根据分组键进行分组，返回一个对象，键为分组键，值为对应的元素数组。</p>\n</li>\n<li><p>基于 <code>forEach</code> 方法实现分组</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function groupBy(array, func) &#123;\n  const result &#x3D; &#123;&#125;;\n  array.forEach((item) &#x3D;&gt; &#123;\n    const group &#x3D; func(item);\n    if (!result[group]) &#123;\n      result[group] &#x3D; [];\n    &#125;\n    result[group].push(item);\n  &#125;);\n  return result;\n&#125;</code></pre>\n\n<p>该函数与前一种实现方式类似，但使用 <code>forEach</code> 方法代替了 <code>reduce</code> 方法。</p>\n</li>\n</ol>\n<p>使用方式如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const data &#x3D; [\n  &#123; name: &#39;apple&#39;, category: &#39;fruit&#39; &#125;,\n  &#123; name: &#39;banana&#39;, category: &#39;fruit&#39; &#125;,\n  &#123; name: &#39;carrot&#39;, category: &#39;vegetable&#39; &#125;,\n];\n\nconst result &#x3D; groupBy(data, (item) &#x3D;&gt; item.category);\nconsole.log(result);\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;   fruit: [\n&#x2F;&#x2F;     &#123; name: &#39;apple&#39;, category: &#39;fruit&#39; &#125;,\n&#x2F;&#x2F;     &#123; name: &#39;banana&#39;, category: &#39;fruit&#39; &#125;\n&#x2F;&#x2F;   ],\n&#x2F;&#x2F;   vegetable: [&#123; name: &#39;carrot&#39;, category: &#39;vegetable&#39; &#125;]\n&#x2F;&#x2F; &#125;</code></pre>\n\n<h3 id=\"数组-api-实现原理\"><a href=\"#数组-api-实现原理\" class=\"headerlink\" title=\"数组 api 实现原理\"></a>数组 api 实现原理</h3><p><a href=\"/#/post/2022-06-10js-arr\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2022-06-10js-arr</a></p>\n<h2 id=\"比较-koa-express-nestjs\"><a href=\"#比较-koa-express-nestjs\" class=\"headerlink\" title=\"比较 koa express nestjs\"></a>比较 koa express nestjs</h2><p>Koa、Express 和 NestJS 都是常用的 Node.js Web 框架，它们各有特点：</p>\n<ol>\n<li><p>Express：是目前最流行的 Node.js Web 框架之一，它简单易学、易用、灵活，生态圈也非常强大，适用于小型的 Web 应用和 API 服务。Express 的定位是一个基础框架，它提供了很多构建 Web 应用的中间件，比如 body-parser、cookie-parser、compression 等等。</p>\n</li>\n<li><p>Koa：Koa 是由 Express 原班人马打造的一个轻量级 Web 框架，它的设计思想是基于 async&#x2F;await 实现中间件的洋葱模型，提供了更为简洁的 API，使得编写代码更加舒适、清晰。Koa 没有内置的中间件，而是需要手动选择和引入，可以更加灵活地定制和控制 Web 应用的行为。</p>\n</li>\n<li><p>NestJS：是一个使用 TypeScript 构建的 Web 应用框架，它结合了 Express 和 Angular 的设计理念，提供了更为现代化和优雅的 API 和架构，适用于构建大型 Web 应用和企业级应用。NestJS 提供了基于类和装饰器的开发方式，使得代码结构更加清晰和易于维护，同时还提供了丰富的功能和插件，如异常处理、ORM、GraphQL 等等。</p>\n</li>\n</ol>\n<p>总之，Koa 是一个轻量级的框架，提供了简洁的 API，适用于构建小型的 Web 应用和 API 服务；Express 是一个基础框架，提供了大量的中间件和插件，适用于构建中小型的 Web 应用和 API 服务；而 NestJS 是一个现代化的框架，提供了丰富的功能和插件，适用于构建大型的 Web 应用和企业级应用。选择框架需要根据实际需求进行权衡。</p>\n<h2 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"></a>Service Worker</h2><h3 id=\"Service-Worker-与-主线程通信\"><a href=\"#Service-Worker-与-主线程通信\" class=\"headerlink\" title=\"Service Worker 与 主线程通信\"></a>Service Worker 与 主线程通信</h3><p>Service Worker 可以与页面的主线程进行通信，但是不能直接访问 DOM，因为它运行在另一个线程中。</p>\n<p>主线程和 Service Worker 之间的通信可以通过消息传递来实现，</p>\n<ol>\n<li>Service Worker 可以使用 <code>postMessage()</code> 方法向主线程发送消息，主线程则可以使用 <code>navigator.serviceWorker.onmessage</code> 事件来监听这些消息并作出响应。</li>\n<li>另外，主线程也可以使用 <code>ServiceWorker.postMessage()</code> 方法向 Service Worker 发送消息，Service Worker 则可以使用 <code>self.addEventListener(&#39;message&#39;, function (event) &#123;&#125;)</code> 来监听并处理这些消息。</li>\n</ol>\n<p>在 Service Worker 中，还可以使用 <code>importScripts()</code> 方法加载其他 JavaScript 文件，这些文件可以与 Service Worker 进行通信。通常，这些 JavaScript 文件包含一些工具函数或库，用于实现 Service Worker 的一些功能。</p>\n<h3 id=\"Service-Worker-与-主线程通信-1\"><a href=\"#Service-Worker-与-主线程通信-1\" class=\"headerlink\" title=\"Service Worker 与 主线程通信\"></a>Service Worker 与 主线程通信</h3><p>Service Worker 是运行在浏览器后台的一个线程，用于提供一些强大的特性，如离线缓存、推送通知和后台同步等。与其他 JavaScript 线程不同，Service Worker 运行在与网页不同的上下文中，不能直接访问 DOM。但是，Service Worker 可以与 JavaScript 在网页上下文中通信，例如通过 postMessage() 方法和 message 事件。</p>\n<p>在网页上下文中，可以通过 navigator.serviceWorker.controller.postMessage() 方法向 Service Worker 发送消息，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">navigator.serviceWorker.controller.postMessage(&#123;\n  type: &#39;update-cache&#39;,\n&#125;);</code></pre>\n\n<p>在 Service Worker 中，可以通过监听 message 事件来接收消息：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">self.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;\n  if (event.data &amp;&amp; event.data.type &#x3D;&#x3D;&#x3D; &#39;update-cache&#39;) &#123;\n    &#x2F;&#x2F; 执行更新缓存的操作\n  &#125;\n&#125;);</code></pre>\n\n<p>需要注意的是，Service Worker 的生命周期与网页不同，可能会在网页关闭后仍然继续运行。因此，在网页中向 Service Worker 发送消息时，需要判断 Service Worker 是否已经启动并处于活动状态，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (navigator.serviceWorker.controller) &#123;\n  navigator.serviceWorker.controller.postMessage(&#123;\n    type: &#39;update-cache&#39;,\n  &#125;);\n&#125; else &#123;\n  &#x2F;&#x2F; Service Worker 未启动或处于等待状态\n&#125;</code></pre>\n\n<h3 id=\"Service-Worker-与主线程通信的完整示例\"><a href=\"#Service-Worker-与主线程通信的完整示例\" class=\"headerlink\" title=\"Service Worker 与主线程通信的完整示例\"></a>Service Worker 与主线程通信的完整示例</h3><p>下面是一个简单的示例，展示了如何在 Service Worker 和主线程之间进行通信：</p>\n<p>在 Service Worker 中：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 添加消息事件监听器，等待主线程的消息\nself.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 接收到主线程发来的消息\n  const &#123; data &#125; &#x3D; event;\n\n  if (data.type &#x3D;&#x3D;&#x3D; &#39;FETCH&#39;) &#123;\n    &#x2F;&#x2F; 执行异步操作\n    fetch(data.url)\n      .then((response) &#x3D;&gt; response.json())\n      .then((data) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 将结果返回给主线程\n        self.postMessage(&#123; type: &#39;FETCH_RESULT&#39;, result: data &#125;);\n      &#125;)\n      .catch((error) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 将错误返回给主线程\n        self.postMessage(&#123; type: &#39;FETCH_ERROR&#39;, error &#125;);\n      &#125;);\n  &#125;\n&#125;);</code></pre>\n\n<p>在主线程中：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 注册 Service Worker\nnavigator.serviceWorker.register(&#39;sw.js&#39;);\n\n&#x2F;&#x2F; 发送消息给 Service Worker\nnavigator.serviceWorker.controller.postMessage(&#123;\n  type: &#39;FETCH&#39;,\n  url: &#39;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;todos&#x2F;1&#39;,\n&#125;);\n\n&#x2F;&#x2F; 添加消息事件监听器，等待 Service Worker 的响应\nnavigator.serviceWorker.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;\n  const &#123; data &#125; &#x3D; event;\n\n  if (data.type &#x3D;&#x3D;&#x3D; &#39;FETCH_RESULT&#39;) &#123;\n    &#x2F;&#x2F; 接收到 Service Worker 的结果\n    console.log(data.result);\n  &#125; else if (data.type &#x3D;&#x3D;&#x3D; &#39;FETCH_ERROR&#39;) &#123;\n    &#x2F;&#x2F; 接收到 Service Worker 的错误信息\n    console.error(data.error);\n  &#125;\n&#125;);</code></pre>\n\n<p>在主线程中，我们使用 <code>navigator.serviceWorker.controller.postMessage</code> 发送消息给 Service Worker，然后添加了一个 <code>message</code> 事件监听器，等待 Service Worker 的响应。在 Service Worker 中，我们添加了一个 <code>message</code> 事件监听器，等待主线程发送消息。当接收到消息后，Service Worker 执行异步操作，然后将结果或错误信息发送回主线程。</p>\n<h3 id=\"serviceWorker-为什么设计在-Navigator-上，而不是在-window-上\"><a href=\"#serviceWorker-为什么设计在-Navigator-上，而不是在-window-上\" class=\"headerlink\" title=\"serviceWorker 为什么设计在 Navigator 上，而不是在 window 上\"></a>serviceWorker 为什么设计在 Navigator 上，而不是在 window 上</h3><ol>\n<li><code>窗口无关</code>： serviceWorker 设计在 Navigator 上是因为它是浏览器中的一个独立线程，不受窗口生命周期的影响，</li>\n<li><code>全局对象</code>：而 Navigator 是浏览器中的全局对象，可以在整个页面范围内访问。</li>\n<li>因此，将 serviceWorker 添加到 Navigator 上，使得它可以在整个页面中被访问和控制。</li>\n</ol>\n<h3 id=\"很多情况下的通信是将“子实例”暴露在“父实例”中，实现通信\"><a href=\"#很多情况下的通信是将“子实例”暴露在“父实例”中，实现通信\" class=\"headerlink\" title=\"很多情况下的通信是将“子实例”暴露在“父实例”中，实现通信\"></a>很多情况下的通信是将“子实例”暴露在“父实例”中，实现通信</h3><h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><img src=\"http://t-blog-images.aijs.top/img/202306041239567.webp\" />\n","text":"var let const 区别： 什么是执行上下文？当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。 全局上下文：默认&#x2F;基础的上下文，任何不在函数...","link":"","photos":[],"count_time":{"symbolsCount":"95k","symbolsTime":"1:27"},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">var let const 区别：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9F\"><span class=\"toc-text\">什么是执行上下文？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#javascript-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">javascript 的执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#javascript-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%90%97\"><span class=\"toc-text\">javascript 的执行顺序 与事件循环是什么一个概念吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%90%E7%B2%BE%E3%80%91\"><span class=\"toc-text\">作用域【精】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%90%E7%B2%BE%E3%80%91\"><span class=\"toc-text\">作用域链【精】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">词法作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%82%A3%E4%B9%88%E9%97%AD%E5%8C%85%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%EF%BC%8C%E9%94%80%E6%AF%81%E4%BA%86%EF%BC%8C%E5%8F%98%E9%87%8F%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F\"><span class=\"toc-text\">那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84\"><span class=\"toc-text\">闭包是如何回收的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">闭包使用原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F\"><span class=\"toc-text\">什么是作用域？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">原型与原型链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建对象的几种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">继承，原型链</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">继承属性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">继承方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">使用语法结构创建的对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">使用构造器创建的对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Object-create-%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">使用 Object.create 创建的对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Number%E3%80%81Boolean-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">Number、Boolean 包装类型的原型链是怎样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">简单数据类型，为什么可以调用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#instanceof\"><span class=\"toc-text\">instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">实例与构造函数之间的关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-class%E3%80%81extends-%E4%B8%8E-super-%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ES6 语法中的 class、extends 与 super 的原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this\"><span class=\"toc-text\">this</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-this-%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">聊下 this 指向问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E8%A6%81%E6%9C%89-this\"><span class=\"toc-text\">为什要有 this</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84\"><span class=\"toc-text\">this 是如何定义的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99\"><span class=\"toc-text\">this 绑定规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">this 绑定的优先级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85\"><span class=\"toc-text\">new 做了哪些事情</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create\"><span class=\"toc-text\">Object.create()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create-%E4%B8%8E-new-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Object.create 与 new 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">箭头函数与普通函数区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85-1\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB-class\"><span class=\"toc-text\">类 class</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">通过构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E5%90%8D%E4%B8%8A%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">为什么类名上可以直接添加属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%98%AF%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%93%AA%E9%87%8C%E7%89%B9%E6%AE%8A%E4%BA%86%EF%BC%9F\"><span class=\"toc-text\">类是特殊的对象，哪里特殊了？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA\"><span class=\"toc-text\">编程方法论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是函数式编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向对象编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向过程编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CICD-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%8C%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">CICD 的自动化流水线，是面向过程编程？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typescript\"><span class=\"toc-text\">typescript</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#typescript-%E4%B8%AD-type-%E4%B8%8E-interface-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">typescript 中 type 与 interface 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Typescript-%E4%B8%AD-extends-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">Typescript 中 extends 的作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">1、接口继承</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%99%AE%E9%80%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-%E8%A1%A8%E7%A4%BA-%E8%83%BD%E5%A4%9F%E5%88%86%E9%85%8D\"><span class=\"toc-text\">2、普通条件判断 表示 能够分配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">3、泛型条件判断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">4、泛型约束</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-ES6-%E7%B1%BB%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">5. ES6 类继承</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">什么是联合类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">什么是交叉类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">交叉类型与联合类型的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React\"><span class=\"toc-text\">React</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-React\"><span class=\"toc-text\">什么是 React</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-key\"><span class=\"toc-text\">聊下 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5-key\"><span class=\"toc-text\">为什么引入 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5-key-%E7%9A%84%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">引入 key 的背景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">key 解决这个问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E6%9C%89%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">key 有什么要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5-key-%E4%B8%8D%E4%BC%9A%E7%94%A8-index\"><span class=\"toc-text\">通常情况 key 不会用 index</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-key\"><span class=\"toc-text\">什么时候使用 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E5%9C%A8%E6%BA%90%E7%A0%81%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9A%84\"><span class=\"toc-text\">key 在源码单节点、多节点中的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diff-%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">diff [单节点、多节点]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hooks-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">hooks 产生的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A4%8D%E7%94%A8%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%E5%BE%88%E9%9A%BE\"><span class=\"toc-text\">在组件之间复用状态逻辑很难</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">复杂组件变得难以理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84-class\"><span class=\"toc-text\">难以理解的 class</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">useEffect 执行特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-useEffect-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1. useEffect 做了什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8-useEffect%EF%BC%9F\"><span class=\"toc-text\">2. 为什么在组件内部调用 useEffect？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-useEffect-%E4%BC%9A%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%90%8E%E9%83%BD%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3. useEffect 会在每次渲染后都执行吗？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BC%A0%E9%80%92%E7%BB%99-useEffect-%E7%9A%84%E5%87%BD%E6%95%B0%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E4%B8%AD%E9%83%BD%E4%BC%9A%E6%9C%89%E6%89%80%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">4. 传递给 useEffect 的函数在每次渲染中都会有所不同</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-effect-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">5. effect 异步执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8-effect-%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">6. 为什么要在 effect 中返回一个函数？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-React-%E4%BD%95%E6%97%B6%E6%B8%85%E9%99%A4-effect%EF%BC%9F\"><span class=\"toc-text\">7. React 何时清除 effect？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E4%BD%BF%E7%94%A8%E7%89%B9%E7%82%B9%E4%B8%8A%EF%BC%9F\"><span class=\"toc-text\">useEffect 使用特点上？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">useEffect 实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hook-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">Hook 使用规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">父子组件生命周期函数执行顺序：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-StrictMode\"><span class=\"toc-text\">严格模式 StrictMode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%B0%83\"><span class=\"toc-text\">协调</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%8D%8F%E8%B0%83%E2%80%9D\"><span class=\"toc-text\">什么是“协调”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react17-%E7%89%88%E6%9C%AC%E5%89%8D%E5%90%8E%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">react17 版本前后合成事件执行顺序有什么变化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">合成事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">合成事件的捕获和冒泡如何实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">父子组件合成事件的捕获和冒泡执行顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6-1\"><span class=\"toc-text\">合成事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BA%95%E5%B1%82%E4%BA%8B%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">要使用浏览器的底层事件？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">变化？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E8%A2%AB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5%E8%A7%A6%E5%8F%91%EF%BC%9F\"><span class=\"toc-text\">在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8F%98%E6%9B%B4\"><span class=\"toc-text\">事件委托的变更</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%96%B0%E7%9A%84-JSX-%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">全新的 JSX 转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%AF%E4%BD%9C%E7%94%A8%E6%B8%85%E7%90%86%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">副作用清理时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React17-%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%94%B9\"><span class=\"toc-text\">React17 重大更改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react18-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">react18 新特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">错误处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#componentDidCatch\"><span class=\"toc-text\">componentDidCatch</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#static-getDerivedStateFromError\"><span class=\"toc-text\">static getDerivedStateFromError()</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Redux-%E4%B8%8E%E4%B8%8D%E4%BD%BF%E7%94%A8-Redux-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">使用 Redux 与不使用 Redux 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">Redux 常用的中间件有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96-Action-%E5%92%8C-Reducer-%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">如何简化 Action 和 Reducer 的定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#redux-actions-%E6%9C%89%E5%93%AA%E4%BA%9B-API\"><span class=\"toc-text\">redux-actions 有哪些 API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%8E-Vue-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">React 与 Vue 的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">一些重要的区别：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E5%92%8C-Vue-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%9C%89%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">React 和 Vue 的实现原理有一些区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E5%8E%9F%E7%90%86%E4%B8%8A%E8%AE%B2%EF%BC%8CVue-%E5%92%8C-React-%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">从原理上讲，Vue 和 React 哪个性能更好，为什么</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#git\"><span class=\"toc-text\">git</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-rebase-%E4%B8%8E-git-merge\"><span class=\"toc-text\">git rebase 与 git merge</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%9F%BA%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">变基原理：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">什么时候用哪个？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%A4%94\"><span class=\"toc-text\">🤔</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%98%E9%87%91%E5%B0%8F%E7%8C%AA%E8%AF%BE%E5%A0%82\"><span class=\"toc-text\">掘金小猪课堂</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">for…in 和 for…of 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript-%E4%B8%AD%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">JavaScript 中可迭代对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%A0%E7%A7%8D%E8%8E%B7%E5%8F%96-URL-%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">几种获取 URL 参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#clientHeight%E3%80%81offsetHeight%E3%80%81scrollHeight-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">clientHeight、offsetHeight、scrollHeight 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#childNodes-%E5%92%8C-children-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">childNodes 和 children 有什么区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Ajax\"><span class=\"toc-text\">Ajax</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ajax-%E5%90%8D%E5%AD%97%E7%9A%84%E7%94%B1%E6%9D%A5\"><span class=\"toc-text\">Ajax 名字的由来</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XMLHttpRequest-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">XMLHttpRequest 示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XMLHttpRequest-%E5%AE%9E%E4%BE%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">XMLHttpRequest 实例有哪些属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XMLHttpRequest-%E5%AE%9E%E4%BE%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">XMLHttpRequest 实例有哪些方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XMLHttpRequest-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">XMLHttpRequest 有哪些事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XMLHttpRequest-open-%E6%96%B9%E6%B3%95%E4%B8%AD-async\"><span class=\"toc-text\">XMLHttpRequest open 方法中 async</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XMLHttpRequest-%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E3%80%81%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6\"><span class=\"toc-text\">XMLHttpRequest 上传进度、下载进度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XMLHttpRequest-%E4%B8%8A%E4%BC%A0-x2F-%E4%B8%8B%E8%BD%BD%E6%8D%A2%E7%A7%8D%E5%86%99%E6%B3%95\"><span class=\"toc-text\">XMLHttpRequest 上传&#x2F;下载换种写法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fetch\"><span class=\"toc-text\">Fetch</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fetch-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">Fetch 有哪些属性、方法、事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fetch-%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E3%80%81%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6\"><span class=\"toc-text\">Fetch 上传进度、下载进度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fetch-%E4%B8%8E-XMLHttpRequest-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Fetch 与 XMLHttpRequest 区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fetch-%E4%B8%8D%E6%94%AF%E6%8C%81%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">Fetch 不支持超时设置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fetch-%E4%B8%8D%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">Fetch 不支持自动取消请求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Axios\"><span class=\"toc-text\">Axios</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Axios-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Axios 实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Axios-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">Axios 执行过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Axios-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Axios 拦截器的实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ajax%E3%80%81XMLHttpRequest%E3%80%81Fetch%E3%80%81Axios-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Ajax、XMLHttpRequest、Fetch、Axios 四者的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89\"><span class=\"toc-text\">判断两个对象是否相等</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">将类数组转为数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">判断数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-prototype-toString-call-%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">Object.prototype.toString.call 封装</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#session%E3%80%81cookie%E3%80%81token-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">session、cookie、token 的区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-new-%E6%96%B9%E6%B3%95%EF%BC%81\"><span class=\"toc-text\">new 做了哪些操作？手写一个 new 方法！</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">跨标签页的通讯方式有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">为什么需要跨标签页通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E4%B8%BE\"><span class=\"toc-text\">列举</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%BA%90\"><span class=\"toc-text\">同源</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%90%8C%E6%BA%90%EF%BC%9A\"><span class=\"toc-text\">非同源：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">演示</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">源码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%90%8C%E6%BA%90\"><span class=\"toc-text\">非同源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#demo-%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">demo 代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#transition-%E5%92%8C-animation-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">transition 和 animation 的属性分别有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS3-font\"><span class=\"toc-text\">CSS3 font</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">柯里化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0\"><span class=\"toc-text\">为什么会出现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96-1\"><span class=\"toc-text\">柯里化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-promise-%E4%B8%8E-async-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">异步编程 promise 与 async 的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">async 特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">为什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E6%88%90\"><span class=\"toc-text\">构成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88-1\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">注意点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA-await-%E6%89%A7%E8%A1%8C%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">两个 await, 执行说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#async-x2F-await-%E5%92%8C-Promise-x2F-then-%E5%AF%B9%E6%AF%94%E4%BB%A5%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1-x2F-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">包装对象&#x2F;原型与原型链</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%AB%E4%B9%89\"><span class=\"toc-text\">包装对象的含义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承关系</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-freeze-vs-Object-seal-vs-Object-preventExtensions\"><span class=\"toc-text\">Object.freeze() vs Object.seal() vs Object.preventExtensions()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-freeze\"><span class=\"toc-text\">Object.freeze()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-seal\"><span class=\"toc-text\">Object.seal()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-preventExtensions\"><span class=\"toc-text\">Object.preventExtensions()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%86\"><span class=\"toc-text\">区分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">前端工程化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88-2\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-1\"><span class=\"toc-text\">为什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">如何实施前端工程化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-run-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">npm run 做了什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-install\"><span class=\"toc-text\">npm install</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-jsonp%EF%BC%8C%E4%BC%A0%E5%85%A5-URL%EF%BC%8Ccallback-%E5%92%8C-callbackName-%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">实现 jsonp，传入 URL，callback 和 callbackName 三个参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%94%9F-js-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-js-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">原生 js 实现动态加载 js 文件?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%B8%AD%E7%9A%84-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">js 中的 for 循环注意点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">new 操作符和点运算符的优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BC%9A%E5%A6%82%E4%BD%95\"><span class=\"toc-text\">new 一个构造函数，如果函数返回不同类型的值，结果会如何?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E9%83%BD%E4%B8%8D%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">什么都不返回</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">返回一个新的对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">返回一个原始值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-null\"><span class=\"toc-text\">返回 null</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-true\"><span class=\"toc-text\">返回 true</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-this\"><span class=\"toc-text\">返回 this</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-apply-x2F-call-%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">为什么要用 apply&#x2F;call 这两个函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS\"><span class=\"toc-text\">CSS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#height-x2F-width\"><span class=\"toc-text\">height&#x2F;width</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#width-%E5%B1%9E%E6%80%A7-100-%E5%92%8C-auto-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">width 属性 100%和 auto 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vertical-align-middle\"><span class=\"toc-text\">vertical-align: middle</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#will-change\"><span class=\"toc-text\">will-change</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#z-index\"><span class=\"toc-text\">z-index</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%9B%92%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">介绍下盒模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CSS-%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84\"><span class=\"toc-text\">CSS 是怎么工作的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E9%81%87%E5%88%B0%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84-CSS-%E4%BB%A3%E7%A0%81%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">当浏览器遇到无法解析的 CSS 代码会发生什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82%E5%8F%A0%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">层叠、优先级和继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#important\"><span class=\"toc-text\">!important</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8E-performanceAPI-%E6%9D%A5%E8%AE%B2\"><span class=\"toc-text\">从 performanceAPI 来讲</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">协议优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">加载优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">渲染优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">缓存优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">更新优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E7%BA%BF%E5%90%8E%E6%94%B6%E9%9B%86%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">上线后收集用户信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%B6%E9%9B%86%E5%90%8E%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86\"><span class=\"toc-text\">收集后分析处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E5%8F%AF%E8%A7%81%E6%80%A7-API\"><span class=\"toc-text\">页面可见性 API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%9C%80%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">按需拷贝</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%94%9F-js-%E6%B7%B1%E6%8B%B7%E8%B4%9D-x2F-%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">原生 js 深拷贝&#x2F;浅拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">浅拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">深拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#window-structuredClone\"><span class=\"toc-text\">window.structuredClone</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-native\"><span class=\"toc-text\">react-native</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-native-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">react-native 新特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-native-%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9A%84%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">react-native 与原生的通信</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84-group\"><span class=\"toc-text\">数组 group</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84-api-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">数组 api 实现原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83-koa-express-nestjs\"><span class=\"toc-text\">比较 koa express nestjs</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Service-Worker\"><span class=\"toc-text\">Service Worker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Service-Worker-%E4%B8%8E-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">Service Worker 与 主线程通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Service-Worker-%E4%B8%8E-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-1\"><span class=\"toc-text\">Service Worker 与 主线程通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Service-Worker-%E4%B8%8E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Service Worker 与主线程通信的完整示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#serviceWorker-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E5%9C%A8-Navigator-%E4%B8%8A%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9C%A8-window-%E4%B8%8A\"><span class=\"toc-text\">serviceWorker 为什么设计在 Navigator 上，而不是在 window 上</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%88%E5%A4%9A%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%98%AF%E5%B0%86%E2%80%9C%E5%AD%90%E5%AE%9E%E4%BE%8B%E2%80%9D%E6%9A%B4%E9%9C%B2%E5%9C%A8%E2%80%9C%E7%88%B6%E5%AE%9E%E4%BE%8B%E2%80%9D%E4%B8%AD%EF%BC%8C%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">很多情况下的通信是将“子实例”暴露在“父实例”中，实现通信</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">实践</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React中的术语","uid":"4cfbb91d77b5df4256b735640b2a3f88","slug":"2022-09-19react","date":"2022-09-19T12:42:20.000Z","updated":"2022-09-20T12:57:05.700Z","comments":true,"path":"api/articles/2022-09-19react.json","keywords":null,"cover":null,"text":"浅合并this.setState 会进行浅合并 falsyfalsy 表达式 MDN 8 个 falsy 值 &#x2F;&#x2F; | 值 | 说明 | &#x2F;&#x2F; | :-------- | :---------------------------------...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"React","slug":"React","count":38,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":32,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"vscode 常用快捷键（持续更新...）","uid":"5380d0b3be253a4f070c3aa29aef0cf7","slug":"2022-09-17vscode-shortcuts","date":"2022-09-17T13:55:58.000Z","updated":"2023-05-15T13:17:32.956Z","comments":true,"path":"api/articles/2022-09-17vscode-shortcuts.json","keywords":null,"cover":"https://www.ymama.net/config/ueditor/php/upload/image/20200827/1598515434460503.png","text":"直接换行cmd + enter; 选中多个相同的元素cmd + d; &#x2F;&#x2F; 每次向后多选一个相同的 选中相同内容cmd + shift + L; &#x2F;&#x2F; 全文，选相同内容 &#x2F;&#x2F; &#123; &#x2F;&#x2F; &q...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"vscode","slug":"vscode","count":8,"path":"api/categories/vscode.json"}],"tags":[{"name":"vscode","slug":"vscode","count":11,"path":"api/tags/vscode.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}