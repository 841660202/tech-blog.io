{"title":"前端基础-qa","uid":"d55ac1d91034293bfc294fd694ca97c4","slug":"2022-09-19qa","date":"2022-09-18T09:13:05.000Z","updated":"2022-10-27T11:59:58.321Z","comments":true,"path":"api/articles/2022-09-19qa.json","keywords":null,"cover":[],"content":"<h2 id=\"var-let-const-区别：\"><a href=\"#var-let-const-区别：\" class=\"headerlink\" title=\"var let const 区别：\"></a>var let const 区别：</h2><ol>\n<li>版本： var 是 es6 之前， const、let es6 之后，</li>\n<li>分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域</li>\n<li>提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使用会报错</li>\n<li>重复：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值</li>\n<li>存储：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li>\n<li>默认： 默认情况下是 var 声明</li>\n<li>函数：函数声明提升优先于 var</li>\n</ol>\n<p>补充说明： const 和不变性。</p>\n<p>const 创建一个变量名绑定，该绑定在创建后不能重新分配。<br>const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。</p>\n<h2 id=\"什么是执行上下文？\"><a href=\"#什么是执行上下文？\" class=\"headerlink\" title=\"什么是执行上下文？\"></a>什么是执行上下文？</h2><p>当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。<br>分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。</p>\n<p><code>全局上下文：</code>默认&#x2F;基础的上下文，任何不在函数内部的代码都在全局上下文中，一个程序中只有一个全局执行上下文</p>\n<p><code>函数执行上下文</code>：一个函数被调用时，会为该函数创建一个上下文，每个函数都有自己的函数上下文，函数上下文可以有任意多个</p>\n<p><code>eval上下文</code>：执行在 eval 函数内部的代码也会有属于它自己的执行上下文</p>\n<h2 id=\"javascript-的执行顺序\"><a href=\"#javascript-的执行顺序\" class=\"headerlink\" title=\"javascript 的执行顺序\"></a>javascript 的执行顺序</h2><ol>\n<li><code>JavaScript 代码在执行的过程中</code>，需要先做变量提升，之所以如此，是因为 JavaScript 代码在执行前需要进行<code>编译</code>；</li>\n<li>在编译阶段，<ul>\n<li>变量和函数会被存放到<code>变量环境</code>中，变量的默认值为 undefined；</li>\n<li>块级作用域会被存放到<code>词法环境</code>中；</li>\n<li>存在两个相同的函数，后面的会<code>覆盖</code>前面的函数；</li>\n</ul>\n</li>\n<li>调用函数时，JavaScript 引擎维护了一个栈的数据结构（<code>调用栈</code>），每次调用函数都会将函数的执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码；</li>\n<li>当函数执行完毕后，JavaScript 引擎会将该函数的执行上下文<code>弹出栈</code>；</li>\n<li>当分配的栈空间被占满时，会引发<code>栈溢出</code>的情况；</li>\n</ol>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/6965786039185047559\">https://juejin.cn/post/6965786039185047559</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>作用域是可访问变量的集合。</p>\n<ul>\n<li>全局作用域</li>\n<li>函数作用域</li>\n<li>块级作用域</li>\n</ul>\n<p>JavaScript 变量生命周期</p>\n<ul>\n<li>局部变量在函数执行完毕后销毁。</li>\n<li>全局变量在页面关闭后销毁。</li>\n</ul>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>当执行一段代码时，JavaScript 引擎首先在当前执行上下文中查找变量，<br>如果找不到，会根据外部引用 outer 去对应的外部执行上下文查找变量，直到查找到最外层的全局执行上下文，<br>从当前执行上下文到全局执行上下文，形成了一个链条，我们称为<code>作用域链</code></p>\n<p>简单来说：由于函数嵌套，一个变量在当前函数作用域找不到，会往上找，直到全局作用域，这种作用域嵌套的现象；由内向外，一层一层往上的链式规则，这就是作用域链</p>\n<p><a href=\"https://juejin.cn/post/7023259995219165214\" target=\"_blank\" >JavaScript 执行机制二（深入之闭包）</a></p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><ul>\n<li>词法作用域是由代码声明的位置决定的，所以词法作用域是静态作用域，通过它能预测代码在执行过程中如何查找标识。</li>\n<li>对于代码中存在块级作用域的情况，作用域链首先在词法环境中查找，没找到才会到变量环境中查找</li>\n</ul>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bfb6a6ffe2147be9ce8dbcc60eb0de5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" />\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在 JavaScript 中，根据词法作用域的规则，内部函数总能访问外部函数声明的变量，当通过调用外部函数返回内部函数时，即使外部函数执行完毕，内部函数引用外部函数的变量仍存在内存中，我们就把这些变量的集合称为闭包</p>\n<h3 id=\"那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\"><a href=\"#那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\" class=\"headerlink\" title=\"那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\"></a>那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？</h3><ol>\n<li>如果一个函数内有闭包，javascript 在执行这个函数时候，会预扫描内部函数是否有使用的 foo 函数中声明的变量；</li>\n<li>预扫描过程中，在内层函数 showName 中找到了外部函数 foo 中声明的变量 name，因此在 JavaScript 中判断这是一个闭包，</li>\n<li>此时会在堆中开辟一个空间创建 closure(foo)对象，将 name 值存到里面。</li>\n<li>而执行栈中的 foo 执行上下文中的 name 存的值是 closure(foo)的地址，因此当 foo 函数执行完成并销毁，name 值仍然存在堆的 closure(foo)的对象中，具体如下图所示：</li>\n<li><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22b437d4602e45379d9c9b4139817a24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" /></li>\n</ol>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/7023259995219165214\">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"闭包是如何回收的\"><a href=\"#闭包是如何回收的\" class=\"headerlink\" title=\"闭包是如何回收的\"></a>闭包是如何回收的</h3><ul>\n<li>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭。但如果这个变量之后不在使用，就会造成内存泄露</li>\n<li>如果引用闭包的函数是一个局部变量，等函数销毁后，在下一次执行垃圾回收时，判断闭包这块内容不再使用，那么 JavaScript 引擎的垃圾回收器就会回收这块内容</li>\n</ul>\n<h3 id=\"闭包使用原则\"><a href=\"#闭包使用原则\" class=\"headerlink\" title=\"闭包使用原则\"></a>闭包使用原则</h3><ul>\n<li>如果该闭包会一直使用，那么它可以作为全局变量而存在；</li>\n<li>但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><code>作用域链：</code>每个执行上下文都有一个指向外部的 outer，这个指向外部的引用 outer 在编译时就决定了，也就是说，根据声明的位置就能确定外部引用 outer，这就是词法作用域（静态作用域），它能预测代码执行过程中如何查找标识。通过它就能确定作用域链。</li>\n<li><code>闭包：</code>外部函数声明的变量，在内部函数中调用，当调用外部函数返回内部函数时，外部函数中声明的变量并不会随着外部函数执行完成而销毁，这些变量构成的集合就是外部函数的闭包。</li>\n<li><code>栈和堆空间：</code>基本数据类型是存在栈空间中的，引用数据类型是存在堆空间中的。<code>当形成闭包时，外部函数声明的变量存放在调用栈中，对于外部函数中的变量被内部函数所使用，在堆中就会创建一个 closure(函数名)的对象，用于存放闭包的变量集合，而外部函数中存的只是堆中的地址。所以说，当外部函数执行完成销毁时，JavaScript 引擎并不会回收堆中的地址。</code></li>\n<li><code>正确使用闭包：</code>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用。</li>\n</ul>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/7023259995219165214\">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"什么是作用域？\"><a href=\"#什么是作用域？\" class=\"headerlink\" title=\"什么是作用域？\"></a>什么是作用域？</h3><p>通俗点来讲就是：指变量的可使用范围</p>\n<p>一般有三种作用域：全局作用域、函数作用域、块级作用域</p>\n<p>全局作用域：声明的变量，全局可见<br>函数作用域：声明的变量在当前函数内部可见<br>块级作用域：{},条件语句，循环语句中</p>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"什么是原型\"><a href=\"#什么是原型\" class=\"headerlink\" title=\"什么是原型\"></a>什么是原型</h3><p>js 面向对象编程的实现</p>\n<p>在 JavaScript 中原型是一个 prototype 对象，用于表示类型之间的关系。</p>\n<p>每一个对象都与另一个对象相关联，那个关联的对象就称为原型</p>\n<h3 id=\"为什么使用原型\"><a href=\"#为什么使用原型\" class=\"headerlink\" title=\"为什么使用原型\"></a>为什么使用原型</h3><p>原型对象的用途： 是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。</p>\n<p>所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。</p>\n<h3 id=\"原型分类\"><a href=\"#原型分类\" class=\"headerlink\" title=\"原型分类\"></a>原型分类</h3><p>显示原型和隐式原型</p>\n<p>显示原型： prototype 关键字标识<br>隐式原型： <code>__proto__</code>表示<br>一个构造函数显示原型 &#x3D;&#x3D;&#x3D; 该构造函数一个实例的隐式原型 即： （构造函数.<code>prototype</code> &#x3D;&#x3D;&#x3D; 构造函数实例.<code>__proto__</code>）</p>\n<h3 id=\"什么是原型链\"><a href=\"#什么是原型链\" class=\"headerlink\" title=\"什么是原型链\"></a>什么是原型链</h3><ol>\n<li>每个实例对象的<code>__proto__</code>​ 属性, 指向它的构造函数的原型对象（<code>prototype</code>）。</li>\n<li>该原型对象也有一个自己的原型对象（<code>__proto__</code>​），层层向上直到一个对象的原型对象为 <code>null</code>​。</li>\n<li>根据定义，<code>null</code>​ 没有原型，并作为这个原型链中的最后一个环节</li>\n</ol>\n<p>简单来说，原型链是： 一个对象 找原型对象 的依据</p>\n<p><a href=\"https://www.51cto.com/article/718086.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"创建对象的几种方式\"><a href=\"#创建对象的几种方式\" class=\"headerlink\" title=\"创建对象的几种方式\"></a>创建对象的几种方式</h3><ul>\n<li>对象字面量</li>\n<li>构造函数</li>\n<li>new 关键字</li>\n<li>Object.create</li>\n<li>class</li>\n</ul>\n<h3 id=\"Number、Boolean-包装类型的原型链是怎样的？\"><a href=\"#Number、Boolean-包装类型的原型链是怎样的？\" class=\"headerlink\" title=\"Number、Boolean 包装类型的原型链是怎样的？\"></a>Number、Boolean 包装类型的原型链是怎样的？</h3><h3 id=\"简单数据类型，为什么可以调用方法\"><a href=\"#简单数据类型，为什么可以调用方法\" class=\"headerlink\" title=\"简单数据类型，为什么可以调用方法\"></a>简单数据类型，为什么可以调用方法</h3><p><a href=\"https://www.cnblogs.com/venoral/p/5243189.html\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var s1 &#x3D; &quot;some text&quot;;\nvar s2 &#x3D; s1.substring(2); &#x2F;&#x2F;&#39;me text&#39;</code></pre>\n\n<p>基本类型不是对象，因而从逻辑上讲他们不该有方法，其实为了让我们实现这种操作，后台已经完成了一系列的处理。</p>\n<p>第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台会完成如下处理：</p>\n<p><strong>创建</strong> <code>String/Boolean/Number</code> 类的一个实例。<code>var s1=new String(&#39;some text&#39;);</code><br><strong>调用</strong>在实例上调用指定的方法。<code>var s2=s1.substring(2);//&#39;me text&#39;</code><br><strong>销毁</strong>这个实例<code>。s1=null</code></p>\n<p><strong>引用类型与基本包装类型的主要区别就是对象的生存期：</strong></p>\n<ul>\n<li>_使用 new 操作符创建的引用类型的实例_，在执行流离开当前作用域之前都一直保存在内存中。</li>\n<li>_自动创建的基本包装类型的对象_，只存在于代码执行的一瞬间，然后被立即销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</li>\n</ul>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><h3 id=\"实例与构造函数之间的关系\"><a href=\"#实例与构造函数之间的关系\" class=\"headerlink\" title=\"实例与构造函数之间的关系\"></a>实例与构造函数之间的关系</h3><p>实例.<code>__proto__</code> &#x3D;&#x3D;&#x3D; 该实例的构造函数.<code>prototype</code></p>\n<h3 id=\"ES6-语法中的-class、extends-与-super-的原理\"><a href=\"#ES6-语法中的-class、extends-与-super-的原理\" class=\"headerlink\" title=\"ES6 语法中的 class、extends 与 super 的原理\"></a>ES6 语法中的 class、extends 与 super 的原理</h3><h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><h3 id=\"聊下-this-指向问题\"><a href=\"#聊下-this-指向问题\" class=\"headerlink\" title=\"聊下 this 指向问题\"></a>聊下 this 指向问题</h3><p>以下皆对普通函数而言，箭头函数可不是这么玩的</p>\n<h3 id=\"为什要有-this\"><a href=\"#为什要有-this\" class=\"headerlink\" title=\"为什要有 this\"></a>为什要有 this</h3><p>this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。</p>\n<p>简单来说：this,被放到作用域中， 为了简化代码</p>\n<h3 id=\"this-是如何定义的\"><a href=\"#this-是如何定义的\" class=\"headerlink\" title=\"this 是如何定义的\"></a>this 是如何定义的</h3><p>简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的</p>\n<p>我们简单总结一下 this 的特点：</p>\n<ul>\n<li>this 是在运行时绑定的，不是在编写时绑定</li>\n<li>this 的绑定与函数的声明和位置没有任何关系</li>\n<li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。</li>\n</ul>\n<p>所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</p>\n<p>简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>\n<h3 id=\"this-绑定规则\"><a href=\"#this-绑定规则\" class=\"headerlink\" title=\"this 绑定规则\"></a>this 绑定规则</h3><p>判断函数调用时是否使用了 new，如果使用了 new 绑定，则 this 绑定的是新创建的对象。<br>函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。<br>函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。<br>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，</p>\n<ul>\n<li>在严格模式下，默认绑定的 this 是 undefined，</li>\n<li>非严格模式下绑定到全局对象。</li>\n</ul>\n<p><em>类声明和类表达式的主体都执行在严格模式下</em></p>\n<p><a href=\"/posts/2022-10-21js-class\" target=\"_blank\" >前端基础-class</a></p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7115390077353590792\">https://juejin.cn/post/7115390077353590792</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"this-绑定的优先级\"><a href=\"#this-绑定的优先级\" class=\"headerlink\" title=\"this 绑定的优先级\"></a>this 绑定的优先级</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定</code></pre>\n\n<h2 id=\"new-做了哪些事情\"><a href=\"#new-做了哪些事情\" class=\"headerlink\" title=\"new 做了哪些事情\"></a>new 做了哪些事情</h2><p>1、创建一个空对象；</p>\n<p>2、将空对象的原型，指向于构造函数的原型；</p>\n<p>3、将空对象作为构造函数的上下文（改变 this 指向）；</p>\n<p>4、对有返回值的构造函数做判断处理</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;定义构造函数\nfunction Fun(age, name) &#123;\n  this.age &#x3D; age;\n  this.name &#x3D; name;\n  return 1;\n&#125;\n\nfunction myNew(fn, ...args) &#123;\n  &#x2F;&#x2F;1、先创造空对象\n  &#x2F;&#x2F;其实等于var obj &#x3D; Object.create(&#123;&#125;)\n  var obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F;2、obj的__proto__指向原型\n  Object.setPrototypeOf(obj, fn.prototype);\n  &#x2F;&#x2F;3、改变this指向，执行构造函数内部函数\n  var result &#x3D; fn.apply(obj, args);\n  &#x2F;&#x2F;4、判断return\n  return result instanceof Object ? result : obj;\n&#125;</code></pre>\n\n<p><a href=\"cnblogs.com/jacky02/p/16048701.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;</code></pre>\n\n<h3 id=\"Object-create-与-new-的区别\"><a href=\"#Object-create-与-new-的区别\" class=\"headerlink\" title=\"Object.create 与 new 的区别\"></a>Object.create 与 new 的区别</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; new Object() 方式创建\nvar obj &#x3D; &#123; name: &quot;jack&quot; &#125;;\nvar b &#x3D; new Object(obj);\nconsole.log(b.name);\nconsole.log(b.__proto__.name); &#x2F;&#x2F;undefined\n\n&#x2F;&#x2F; Object.create() 方式创建\nvar obj2 &#x3D; &#123; name: &quot;apple&quot; &#125;;\nvar c &#x3D; Object.create(obj2);\nconsole.log(c.name);\nconsole.log(c.__proto__.name); &#x2F;&#x2F;apple</code></pre>\n\n<p>new 出来的 b 对象，通过原型链无法访问到 name 属性，而 Object.create 出来的 c 却可以</p>\n<h2 id=\"箭头函数与普通函数区别\"><a href=\"#箭头函数与普通函数区别\" class=\"headerlink\" title=\"箭头函数与普通函数区别\"></a>箭头函数与普通函数区别</h2><ol>\n<li><p><strong>使用</strong>简单：箭头函数使用起来简单，更适合匿名函数，比较特殊的对象方法，可以简写(){},这个不是箭头函数</p>\n</li>\n<li><p><strong>声明</strong>具名箭头函数可以用 var let const , 普通函数除这些之外还可用 function 关键字</p>\n</li>\n<li><p><strong>立即执行</strong> 普通函数可以声明立即执行函数，箭头函数也可<code>void (()=&gt; &#123;console.log(1)&#125;)()</code></p>\n</li>\n<li><p><strong>运算上</strong> 在使用短路运算符的时候，箭头函数要用()括起来，否则因解析顺序导致错误</p>\n</li>\n<li><p><strong>拥有</strong> 箭头函数没有自己的 this, prototype，arguments, super, new.target,</p>\n</li>\n<li><p>基于此：箭头函数不适用于构造函数、new、yeild 等场合</p>\n</li>\n<li><p>在 apply,call,bind 中第一个参数会被忽略</p>\n</li>\n<li><p>箭头函数没有 arguments，可以使用…rest, （这里有个注意的点：普通函数 arguments，<strong>在非严格模式下</strong>，有默认参数、剩余参数和结构赋值的情况会出现： arguments 与形参不一致的情况）</p>\n</li>\n</ol>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p><code>背景</code>：js 是单线程的，同一时间 dom 的操作不允许并行</p>\n<p><code>出现的原因</code>：单线程，如果出现耗时的情况会一直等待，以浏览器为例： 浏览器分为 5 大线程，定时器线程和网络线程</p>\n<p><code>解决了什么问题</code>：在单线程中，可以跳过一些耗时的操作，先去做其他的事情，待到需要执行的时候，再执行，而这一策略被称为 事件循环</p>\n<p><code>执行过程：</code> <code>宿主环境</code>：以浏览器环境来说</p>\n<ol>\n<li>在 javascript 中，将任务放到执行栈中执行，执行完成的会出栈；未执行的会依次压入栈底，</li>\n<li>先执行同步任务（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部），直至同步任务都被执行完</li>\n<li>然后执行微任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）直至微任务队列都被执行完</li>\n<li>然后执行宏任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）</li>\n<li>会再去检测微任务队列，之后，再以相同的方式去执行宏任务队列</li>\n</ol>\n<h2 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h2 id=\"类-class\"><a href=\"#类-class\" class=\"headerlink\" title=\"类 class\"></a>类 class</h2><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><h3 id=\"通过构造函数\"><a href=\"#通过构造函数\" class=\"headerlink\" title=\"通过构造函数\"></a>通过构造函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  constructor() &#123;\n    console.log(&quot;this&quot;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h3 id=\"通过静态方法\"><a href=\"#通过静态方法\" class=\"headerlink\" title=\"通过静态方法\"></a>通过静态方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"编程方法论\"><a href=\"#编程方法论\" class=\"headerlink\" title=\"编程方法论\"></a>编程方法论</h2><h3 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h3><p>函数式编程（通常缩写为 FP）是通过组合纯函数，避免状态共享、可变数据和副作用来构建软件的过程。</p>\n<p>函数式编程是声明式的，而不是命令式的，应用程序状态通过纯函数流动。</p>\n<p>与面向对象编程不同，在面向对象编程中，应用程序状态通常与对象中的方法共享和协作。</p>\n<p>与命令式或面向对象的代码相比，函数式代码往往更简洁、更可预测、更易于测试</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>函数式编程有些重要的概念：</p>\n<ul>\n<li>纯函数： 给定相同的输入，总是得到相同的输出，没有副作用</li>\n<li>函数组合：将两个或两个以上的函数组合起来以产生一个新函数或进行某种计算的过程</li>\n<li>避免状态共享：共享作用域中存在的任何变量、对象或内存空间，或者是在作用域之间传递的对象的属性。共享作用域可以包括全局作用域或闭包作用域。通常，在面向对象编程中，通过向其他对象添加属性，在作用域之间共享对象。</li>\n<li>避免可变数据： 不可变对象是指创建后不能修改的对象。相反，可变对象是在创建后可以修改的对象， 可以通过：Object.freeze 进行冻结</li>\n<li>避免副作用：副作用是指：除了返回值之外，任何应用程序状态的改变都是可以在被调用函数之外观察到的</li>\n</ul>\n<p><a href=\"https://juejin.cn/post/6844904130796847111\" target=\"_blank\" >见</a></p>\n<h3 id=\"什么是面向对象编程\"><a href=\"#什么是面向对象编程\" class=\"headerlink\" title=\"什么是面向对象编程\"></a>什么是面向对象编程</h3><h3 id=\"什么是面向过程编程\"><a href=\"#什么是面向过程编程\" class=\"headerlink\" title=\"什么是面向过程编程\"></a>什么是面向过程编程</h3><h2 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h2><h3 id=\"type-与-interface-的区别\"><a href=\"#type-与-interface-的区别\" class=\"headerlink\" title=\"type 与 interface 的区别\"></a>type 与 interface 的区别</h3><p><a href=\"https://www.51cto.com/article/705857.html\" target=\"_blank\" >见</a><br><a href=\"https://juejin.cn/post/6844903749501059085\" target=\"_blank\" >见</a></p>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><ol>\n<li>都可以描述一个对象或者函数</li>\n<li>都允许拓展（extends） interface 继承使用 <code>extends关键字</code> ， type 继承使用 <code>&amp;</code>关键字</li>\n</ol>\n<ul>\n<li><code>interface extends interface</code></li>\n<li><code>interface extends type</code></li>\n<li><code>type extends interface</code></li>\n<li><code>type extends type</code></li>\n</ul>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><ul>\n<li>type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</li>\n<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</li>\n<li>interface 能够声明合并 (type 不可以)</li>\n</ul>\n<h4 id=\"描述上：1-都可以描述一个对象或者函数\"><a href=\"#描述上：1-都可以描述一个对象或者函数\" class=\"headerlink\" title=\"描述上：1. 都可以描述一个对象或者函数\"></a>描述上：1. 都可以描述一个对象或者函数</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; interface\ninterface User &#123;\n  name: string\n  age: number\n&#125;\n\ninterface SetUser &#123;\n  (name: string, age: number): void;\n&#125;\n\n&#x2F;&#x2F; type\n\ntype User &#x3D; &#123;\n  name: string\n  age: number\n&#125;;\n\ntype SetUser &#x3D; (name: string, age: number)&#x3D;&gt; void;\n</code></pre>\n\n<h4 id=\"扩展上：-2-都允许拓展（extends\"><a href=\"#扩展上：-2-都允许拓展（extends\" class=\"headerlink\" title=\"扩展上： 2. 都允许拓展（extends\"></a>扩展上： 2. 都允许拓展（extends</h4><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ntype User &#x3D; Name &amp; &#123; age: number &#125;;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ntype User &#x3D; Name &amp; &#123;\n  age: number;\n&#125;;</code></pre>\n\n<h3 id=\"不同点-1\"><a href=\"#不同点-1\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><h4 id=\"1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以\"><a href=\"#1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以\" class=\"headerlink\" title=\"1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)\"></a>1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基本类型别名\ntype Name &#x3D; string;\n\n&#x2F;&#x2F; 联合类型\ninterface Dog &#123;\n  wong();\n&#125;\ninterface Cat &#123;\n  miao();\n&#125;\n\ntype Pet &#x3D; Dog | Cat;\n\n&#x2F;&#x2F; 具体定义数组每个位置的类型\ntype PetList &#x3D; [Dog, Pet];</code></pre>\n\n<h4 id=\"2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以\"><a href=\"#2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以\" class=\"headerlink\" title=\"2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)\"></a>2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 当你想获取一个变量的类型时，使用 typeof\nlet div &#x3D; document.createElement(&quot;div&quot;);\ntype B &#x3D; typeof div;</code></pre>\n\n<p>其他骚操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type StringOrNumber &#x3D; string | number;\ntype Text &#x3D; string | &#123; text: string &#125;;\ntype NameLookup &#x3D; Dictionary&lt;string, Person&gt;;\ntype Callback&lt;T&gt; &#x3D; (data: T) &#x3D;&gt; void;\ntype Pair&lt;T&gt; &#x3D; [T, T];\ntype Coordinates &#x3D; Pair&lt;number&gt;;\ntype Tree&lt;T&gt; &#x3D; T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;\n</code></pre>\n\n<h4 id=\"interface-能够声明合并-type-不行\"><a href=\"#interface-能够声明合并-type-不行\" class=\"headerlink\" title=\"interface 能够声明合并(type 不行)\"></a>interface 能够声明合并(type 不行)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface User &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface User &#123;\n  sex: string;\n&#125;\n\n&#x2F;*\nUser 接口为 &#123;\n  name: string\n  age: number\n  sex: string\n&#125;\n*&#x2F;</code></pre>\n\n<h2 id=\"Typescript-中-extends-的作用\"><a href=\"#Typescript-中-extends-的作用\" class=\"headerlink\" title=\"Typescript 中 extends 的作用\"></a>Typescript 中 extends 的作用</h2><h3 id=\"1、接口继承\"><a href=\"#1、接口继承\" class=\"headerlink\" title=\"1、接口继承\"></a>1、接口继承</h3><p>可以继承父类接口的方法和属性</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; dog 具有 Animal 的 name 属性。\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;</code></pre>\n\n<h3 id=\"2、普通条件判断\"><a href=\"#2、普通条件判断\" class=\"headerlink\" title=\"2、普通条件判断\"></a>2、普通条件判断</h3><p>用来判断一个类型是否可以分配给另外一个类型</p>\n<p>A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\ntype bool &#x3D; Animal extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;\ntype bool1 &#x3D; Dog extends Animal ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;</code></pre>\n\n<h3 id=\"3、泛型条件判断\"><a href=\"#3、泛型条件判断\" class=\"headerlink\" title=\"3、泛型条件判断\"></a>3、泛型条件判断</h3><p>对于使用 extends 关键字的条件类型，如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。</p>\n<p>分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</p>\n<p>满足两个要点即可适用分配律：</p>\n<p>参数是泛型类型，</p>\n<p>代入参数的是联合类型<br>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Animal&lt;T&gt; &#x3D; T;\ntype Animal1&lt;T&gt; &#x3D; [T];\ntype Dog &#x3D; Animal&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;\ntype Dog1 &#x3D; Animal1&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]\n\ntype A &#x3D; &quot;x&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;\ntype B &#x3D; &quot;x&quot; extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;\ntype C &#x3D; [&quot;x&quot; | &quot;y&quot;] extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;\ntype D &#x3D; &quot;x&quot; | &quot;y&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; D &#x3D; &#39;yse&#39;</code></pre>\n\n<h3 id=\"4、泛型约束\"><a href=\"#4、泛型约束\" class=\"headerlink\" title=\"4、泛型约束\"></a>4、泛型约束</h3><p>在书写泛型时，往往需要对类型参数作一定对限制。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;\n  return obj[key];\n&#125;\n\nconst obj &#x3D; &#123;\n  name: &quot;tom&quot;,\n  age: 12,\n&#125;;\n\ngetInfo(obj, &quot;age&quot;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。</code></pre>\n\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><h3 id=\"聊下-key\"><a href=\"#聊下-key\" class=\"headerlink\" title=\"聊下 key\"></a>聊下 key</h3><h3 id=\"为什么引入-key\"><a href=\"#为什么引入-key\" class=\"headerlink\" title=\"为什么引入 key\"></a>为什么引入 key</h3><p><strong>key 帮助 React 识别出被修改、添加或删除的 item</strong></p>\n<p>在对子节点进行递归时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。在子元素列表末尾新增元素时，更新开销比较小。</p>\n<p>React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。</p>\n<p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。</p>\n<p>React 并不会意识到应该保留 <li>Duke</li> 和 <li>Villanova</li>，而是会重建每一个子元素。这种情况会带来性能问题。</p>\n<p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。使得树的转换效率得以提高：</p>\n<p>现在 React 知道只有带着 ‘2014’ key 的元素是新元素，带着 ‘2015’ 以及 ‘2016’ key 的元素仅仅移动了。</p>\n<p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p>\n<h3 id=\"key-有什么要求\"><a href=\"#key-有什么要求\" class=\"headerlink\" title=\"key 有什么要求\"></a>key 有什么要求</h3><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p>\n<h3 id=\"通常情况-key-不会用-index\"><a href=\"#通常情况-key-不会用-index\" class=\"headerlink\" title=\"通常情况 key 不会用 index\"></a>通常情况 key 不会用 index</h3><p>原因：</p>\n<ol>\n<li><p>使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。</p>\n</li>\n<li><p>由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，</p>\n</li>\n</ol>\n<h3 id=\"什么时候使用-key\"><a href=\"#什么时候使用-key\" class=\"headerlink\" title=\"什么时候使用 key\"></a>什么时候使用 key</h3><ol>\n<li>子元素列表时候需要用 key</li>\n<li>同级元素比如两个按钮，在使用三目运算符进行条件处理时候，也需要加 key，不加会出现，按钮事件被错误触发的现象，（这是由于 React 可中断渲染和合成事件共同作用引起的）</li>\n</ol>\n<h3 id=\"key-在源码单节点、多节点中的\"><a href=\"#key-在源码单节点、多节点中的\" class=\"headerlink\" title=\"key 在源码单节点、多节点中的\"></a>key 在源码单节点、多节点中的</h3><h3 id=\"diff-单节点、多节点\"><a href=\"#diff-单节点、多节点\" class=\"headerlink\" title=\"diff [单节点、多节点]\"></a>diff [单节点、多节点]</h3><h3 id=\"hooks-产生的原因\"><a href=\"#hooks-产生的原因\" class=\"headerlink\" title=\"hooks 产生的原因\"></a>hooks 产生的原因</h3><p>Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题</p>\n<h3 id=\"在组件之间复用状态逻辑很难\"><a href=\"#在组件之间复用状态逻辑很难\" class=\"headerlink\" title=\"在组件之间复用状态逻辑很难\"></a><code>在组件之间复用状态逻辑很难</code></h3><h3 id=\"复杂组件变得难以理解\"><a href=\"#复杂组件变得难以理解\" class=\"headerlink\" title=\"复杂组件变得难以理解\"></a><code>复杂组件变得难以理解</code></h3><p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。）</p>\n<h3 id=\"难以理解的-class\"><a href=\"#难以理解的-class\" class=\"headerlink\" title=\"难以理解的 class\"></a><code>难以理解的 class</code></h3><p>(除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。)</p>\n<h3 id=\"useEffect-执行特点\"><a href=\"#useEffect-执行特点\" class=\"headerlink\" title=\"useEffect 执行特点\"></a>useEffect 执行特点</h3><h4 id=\"1-useEffect-做了什么？\"><a href=\"#1-useEffect-做了什么？\" class=\"headerlink\" title=\"1. useEffect 做了什么？\"></a>1. useEffect 做了什么？</h4><p>(<br>通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。<br>)</p>\n<h4 id=\"2-为什么在组件内部调用-useEffect？\"><a href=\"#2-为什么在组件内部调用-useEffect？\" class=\"headerlink\" title=\"2. 为什么在组件内部调用 useEffect？\"></a>2. 为什么在组件内部调用 useEffect？</h4><p>(<br>将 useEffect 放在组件内部,让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。<br>)</p>\n<h4 id=\"3-useEffect-会在每次渲染后都执行吗？\"><a href=\"#3-useEffect-会在每次渲染后都执行吗？\" class=\"headerlink\" title=\"3. useEffect 会在每次渲染后都执行吗？\"></a>3. useEffect 会在每次渲染后都执行吗？</h4><p>(<br>是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。<br>)</p>\n<h4 id=\"4-传递给-useEffect-的函数在每次渲染中都会有所不同\"><a href=\"#4-传递给-useEffect-的函数在每次渲染中都会有所不同\" class=\"headerlink\" title=\"4. 传递给 useEffect 的函数在每次渲染中都会有所不同\"></a>4. 传递给 useEffect 的函数在每次渲染中都会有所不同</h4><p>(<br>经验丰富的 JavaScript 开发人员可能会注意到，传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。<br>)</p>\n<h4 id=\"5-effect-异步执行\"><a href=\"#5-effect-异步执行\" class=\"headerlink\" title=\"5. effect 异步执行\"></a>5. effect 异步执行</h4><p>不需要同步地执行, 如果需要同步用 <code>useLayoutEffect</code></p>\n<h4 id=\"6-为什么要在-effect-中返回一个函数？\"><a href=\"#6-为什么要在-effect-中返回一个函数？\" class=\"headerlink\" title=\"6. 为什么要在 effect 中返回一个函数？\"></a>6. 为什么要在 effect 中返回一个函数？</h4><p>(<br>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。<br>)</p>\n<h4 id=\"7-React-何时清除-effect？\"><a href=\"#7-React-何时清除-effect？\" class=\"headerlink\" title=\"7. React 何时清除 effect？\"></a>7. React 何时清除 effect？</h4><p>(<br>React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。<br>)</p>\n<h3 id=\"useEffect-使用特点上？\"><a href=\"#useEffect-使用特点上？\" class=\"headerlink\" title=\"useEffect 使用特点上？\"></a>useEffect 使用特点上？</h3><ul>\n<li><p>提示: 使用多个 Effect 实现关注点分离</p>\n</li>\n<li><p>解释：为什么每次更新的时候都要运行 Effect(此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug。)</p>\n</li>\n<li><p>提示: 通过跳过 Effect 进行性能优化（使用第二参数，未来版本，可能会在构建时自动添加第二个参数。）</p>\n</li>\n</ul>\n<h3 id=\"useEffect-实现原理\"><a href=\"#useEffect-实现原理\" class=\"headerlink\" title=\"useEffect 实现原理\"></a>useEffect 实现原理</h3><h3 id=\"Hook-使用规则\"><a href=\"#Hook-使用规则\" class=\"headerlink\" title=\"Hook 使用规则\"></a>Hook 使用规则</h3><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>\n<p>只能<code>在函数最外层调用 Hook</code>。<code>不要在循环</code>、<code>条件判断</code>或者<code>子函数中调用</code>。</p>\n<p><code>只能在 React 的函数组件中调用 Hook</code>。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）</p>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><h3 id=\"父子组件生命周期函数执行顺序：\"><a href=\"#父子组件生命周期函数执行顺序：\" class=\"headerlink\" title=\"父子组件生命周期函数执行顺序：\"></a>父子组件生命周期函数执行顺序：</h3><p>父子组件生命周期函数执行顺序：</p>\n<p><strong>类组件</strong></p>\n<p>进入页面：parent-constructor -&gt; parent-getDerivedStateFromProps -&gt; parent-render -&gt; child-constructor -&gt; child-getDerivedStateFromProps -&gt; child-render -&gt; child-componentDidMount -&gt; parent-componentDidMount<br>（子组件先挂载，父组件后挂载）</p>\n<p>更新页面：parent-getDerivedStateFromProps -&gt; parent-shouldComponentUpdate -&gt; parent-render -&gt; child-getDerivedStateFromProps -&gt; child-shouldComponentUpdate -&gt; child-render -&gt; child-componentDidUpdate -&gt; parent-componentDidUpdate<br>（子组件先更新，父组件后更新）<br>销毁页面：parent-componentWillUnmount -&gt; child-componentWillUnmount<br>（父组件先 willUnmount，子组件后 willlUnmount）</p>\n<p><a href=\"https://www.cnblogs.com/foreveronlymiss/p/15387022.html\" target=\"_blank\" >见</a></p>\n<p><strong>函数组件</strong></p>\n<p>子组件先于父组件</p>\n<p><a href=\"https://blog.csdn.net/qq_35770417/article/details/120706178\" target=\"_blank\" >见</a></p>\n<h3 id=\"StrictMode\"><a href=\"#StrictMode\" class=\"headerlink\" title=\"StrictMode\"></a>StrictMode</h3><p>用来突出显示应用程序中潜在问题的工具,不会渲染任何可见的 UI,它为其后代元素触发额外的检查和警告(<span style=\"color: red\">严格模式检查仅在开发模式下运行；它们不会影响生产构建。</span>)</p>\n<p>作用：</p>\n<ul>\n<li>识别不安全的生命周期（使用了第三方库，很难确保它们不使用这些生命周期方法）</li>\n<li>使用过时字符串 ref API 的警告</li>\n<li>检测过时的 context API</li>\n<li>使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>确保可复用状态（在未来，我们希望增加一个功能，允许 React 在保留 state 的同时对 UI 进行增删）</li>\n</ul>\n<h3 id=\"协调\"><a href=\"#协调\" class=\"headerlink\" title=\"协调\"></a>协调</h3><p>当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。</p>\n<h3 id=\"合成事件的捕获和冒泡如何实现\"><a href=\"#合成事件的捕获和冒泡如何实现\" class=\"headerlink\" title=\"合成事件的捕获和冒泡如何实现\"></a>合成事件的捕获和冒泡如何实现</h3><p>数组正反序遍历</p>\n<h3 id=\"父子组件合成事件的捕获和冒泡执行顺序\"><a href=\"#父子组件合成事件的捕获和冒泡执行顺序\" class=\"headerlink\" title=\"父子组件合成事件的捕获和冒泡执行顺序\"></a>父子组件合成事件的捕获和冒泡执行顺序</h3><p>V17 之前，合成事件和原生事件的执行顺序与冒泡&#x2F;捕获模式无关，原生事件恒早于合成事件；</p>\n<p>V17 后，合成事件和原生事件的执行顺序与冒泡&#x2F;捕获模式相关，冒泡模式，原生事件早于合成事件，捕获模式，合成事件早于原生事件。</p>\n<p>&#x2F;&#x2F; V17.0.2 document 原生事件 &gt; 合成事件（父 -&gt; 子） &gt; 原生事件（父 -&gt; 子）<br>&#x2F;&#x2F; 原生事件：document DOM 事件监听！<br>&#x2F;&#x2F; React 事件：父元素事件监听！<br>&#x2F;&#x2F; React 事件：子元素事件监听！<br>&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！</p>\n<p>&#x2F;&#x2F; V16.14.0 document 原生事件 &gt; 原生事件（父 -&gt; 子）&gt; 合成事件（父 -&gt; 子）<br>&#x2F;&#x2F; 原生事件：document DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！<br>&#x2F;&#x2F; React 事件：父元素事件监听！<br>&#x2F;&#x2F; React 事件：子元素事件监听！</p>\n<p>作者：活抓一只小机灵<br>链接：<a href=\"https://juejin.cn/post/7005129812981317668\">https://juejin.cn/post/7005129812981317668</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h3><h3 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h3><p>是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口。</p>\n<h3 id=\"要使用浏览器的底层事件？\"><a href=\"#要使用浏览器的底层事件？\" class=\"headerlink\" title=\"要使用浏览器的底层事件？\"></a>要使用浏览器的底层事件？</h3><p>需要使用 nativeEvent 属性来获取</p>\n<h3 id=\"变化？\"><a href=\"#变化？\" class=\"headerlink\" title=\"变化？\"></a>变化？</h3><p>从 v17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中。</p>\n<h3 id=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"><a href=\"#在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\" class=\"headerlink\" title=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"></a>在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</h3><p>如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。</p>\n<h3 id=\"事件委托的变更\"><a href=\"#事件委托的变更\" class=\"headerlink\" title=\"事件委托的变更\"></a>事件委托的变更</h3><p>React v17 中，React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中<br>经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。</p>\n<h3 id=\"全新的-JSX-转换\"><a href=\"#全新的-JSX-转换\" class=\"headerlink\" title=\"全新的 JSX 转换\"></a>全新的 JSX 转换</h3><p>此时源代码无需引入 React 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）</p>\n<p>此变化与所有现有 JSX 代码兼容，所以你无需修改组件。如果你对此感兴趣，你可以查看 RFC 了解全新转换工作的具体细节。</p>\n<p>特点：</p>\n<ul>\n<li>新的 JSX 转换不依赖 React 环境</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>不需要引入 Ract 使用全新的转换，你可以单独使用 JSX 而无需引入 React。</li>\n<li>改善 bundle 根据你的配置，JSX 的编译输出可能会略微改善 bundle 的大小。</li>\n<li>以备未来之需 它将减少你需要学习 React 概念的数量，以备未来之需。</li>\n</ul>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><h3 id=\"git-rebase-与-git-merge\"><a href=\"#git-rebase-与-git-merge\" class=\"headerlink\" title=\"git rebase 与 git merge\"></a>git rebase 与 git merge</h3><p>merge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）<br>rebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，</p>\n<p>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>\n<h3 id=\"副作用清理时间\"><a href=\"#副作用清理时间\" class=\"headerlink\" title=\"副作用清理时间\"></a>副作用清理时间</h3><ul>\n<li>React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。</li>\n<li>React 16 只对组件内的 effect 保证这种顺序。</li>\n</ul>\n<h3 id=\"React17-重大更改\"><a href=\"#React17-重大更改\" class=\"headerlink\" title=\"React17 重大更改\"></a>React17 重大更改</h3><ul>\n<li>更改事件委托</li>\n<li>对标浏览器，对事件系统进行小改</li>\n<li>去除事件池 不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水 （因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。）</li>\n<li>副作用清理时间 （- React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。，- React 16 只对组件内的 effect 保证这种顺序。）</li>\n<li>返回一致的 undefined 错误，（算是改 bug 了，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错）</li>\n<li>原生组件栈 （生产环境提示更友好。在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。_React 实现这一点的方式有点非常规_。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。因此，_当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息_）</li>\n<li>移除私有导出（与 react 关联不是很大的部分被移出）</li>\n</ul>\n<h3 id=\"变基原理：\"><a href=\"#变基原理：\" class=\"headerlink\" title=\"变基原理：\"></a>变基原理：</h3><ol>\n<li>是首先找到这两个分支的最近共同祖先 C2</li>\n<li>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3</li>\n<li>最后以此将之前另存为临时文件的修改依序应用</li>\n</ol>\n<h3 id=\"什么时候用哪个？\"><a href=\"#什么时候用哪个？\" class=\"headerlink\" title=\"什么时候用哪个？\"></a>什么时候用哪个？</h3><p>这本身存在分歧，主要看团队需要，如果团队需要历史记录保留，便于追踪，可以使用 merge ,如果不希望保留过多的过程，只关注结果那么可以用 rebase.无论用哪个，为了避免 rebase 的坑， 需要遵循以下原则：</p>\n<h3 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h3><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ git rebase --onto master server client</code></pre>\n\n<p>你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#:~:text=Figure%2039.%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E9%87%8C%E5%86%8D%E5%88%86%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\ngit rebase -i HEAD~4\n# s 命令压缩</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171547417.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171551269.png\" />\n\n<p><a href=\"https://www.cnblogs.com/lookphp/p/5799533.html\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://backlog.com/git-tutorial/cn/stepup/stepup7_7.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h3><img src=\"http://t-blog-images.aijs.top/img/202209181100864.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209181059249.png\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~3\nThe previous cherry-pick is now empty, possibly due to conflict resolution.\nIf you wish to commit it anyway, use:\n\n    git commit --allow-empty\n\nOtherwise, please use &#39;git reset&#39;\ninteractive rebase in progress; onto e1a52d3\nLast commands done (2 commands done):\n   pick 78c1fd9 应对github bug s 压缩\n   pick 8935665 应对github bug\nNext commands to do (4 remaining commands):\n   pick 421821a update\n   pick 4eff6a3 update\nYou are currently rebasing branch &#39;main&#39; on &#39;e1a52d3&#39;.\n\nnothing to commit, working tree clean\nCould not apply 8935665... 应对github bug\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~2\n\nIt seems that there is already a rebase-merge directory, and\nI wonder if you are in the middle of another rebase.  If that is the\ncase, please try\n        git rebase (--continue | --abort | --skip)\nIf that is not the case, please\n        rm -fr &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;.git&#x2F;rebase-merge&quot;\nand run me again.  I am stopping in case you still have something\nvaluable there.\n$ git rebase --abort</code></pre>\n\n<h2 id=\"掘金小猪课堂\"><a href=\"#掘金小猪课堂\" class=\"headerlink\" title=\"掘金小猪课堂\"></a>掘金小猪课堂</h2><h3 id=\"for…in-和-for…of-的区别\"><a href=\"#for…in-和-for…of-的区别\" class=\"headerlink\" title=\"for…in 和 for…of 的区别\"></a>for…in 和 for…of 的区别</h3><p>for…in 可以遍历对象和数组，for…of 不能遍历对象<br>for…in <strong>循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键</strong><br>for…in 遍历的索引为字符串类型<br>for..of 适用遍历数&#x2F;数组对象&#x2F;字符串&#x2F;map&#x2F;set 等拥有迭代器对象的集合，但是不能遍历对象<br>for…of 与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句<br>具有迭代器对象才可以使用 for…of</p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7002484014414037000\">https://juejin.cn/post/7002484014414037000</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"JavaScript-中可迭代对象\"><a href=\"#JavaScript-中可迭代对象\" class=\"headerlink\" title=\"JavaScript 中可迭代对象\"></a>JavaScript 中可迭代对象</h3><p>Set<br>Map</p>\n<p>String<br>Array</p>\n<p>Arguments<br>NodeList</p>\n<h3 id=\"几种获取-URL-参数\"><a href=\"#几种获取-URL-参数\" class=\"headerlink\" title=\"几种获取 URL 参数\"></a><a href=\"https://juejin.cn/post/7075305529903415304\" target=\"_blank\" >几种获取 URL 参数</a></h3><ul>\n<li>通过正则匹配的方式</li>\n<li>利用 a 标签内置方法</li>\n<li>利用 split 方法分割法</li>\n<li>使用 URLSearchParams 方法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; - 通过正则匹配的方式\n&lt;script&gt;\n  &#x2F;&#x2F; 利用正则表达式\n  let url &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&quot;\n  &#x2F;&#x2F; &#x2F;&#x2F; 返回参数对象\n  function queryURLParams(url) &#123;\n    let pattern &#x3D; &#x2F;(\\w+)&#x3D;(\\w+)&#x2F;ig; &#x2F;&#x2F;定义正则表达式\n    let parames &#x3D; &#123;&#125;; &#x2F;&#x2F; 定义参数对象\n    url.replace(pattern, ($, $1, $2) &#x3D;&gt; &#123;\n      parames[$1] &#x3D; $2;\n    &#125;);\n    return parames;\n  &#125;\n  console.log(queryURLParams(url))\n&lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; - 使用 URLSearchParams 方法\n&lt;script&gt;\n  let URL &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&quot;\n  function queryURLParams(URL) &#123;\n    let url &#x3D; URL.split(&quot;?&quot;)[1];\n    const urlSearchParams &#x3D; new URLSearchParams(url);\n    const params &#x3D; Object.fromEntries(urlSearchParams.entries());\n    return params\n  &#125;\n  console.log(queryURLParams(URL))\n&lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; 作者：小猪课堂\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7075305529903415304\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<h3 id=\"offsetHeight、scrollHeight、clientHeight-的区别\"><a href=\"#offsetHeight、scrollHeight、clientHeight-的区别\" class=\"headerlink\" title=\"offsetHeight、scrollHeight、clientHeight 的区别\"></a>offsetHeight、scrollHeight、clientHeight 的区别</h3><p>三个属性虽然都很类似，但是每一个又有一些不一样的地方，总结起来就下面三点：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;*占据空间*&#x2F; offsetHeight &#x3D; 内容高度 + padding + border;\n&#x2F;*内容*&#x2F; clientheight &#x3D; 内容高度 + padding;\n&#x2F;*滚动*&#x2F; scrollHeight &#x3D; 内容实际尺寸 + padding;\n\n&#x2F;&#x2F; 作者：小猪课堂\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7085317886046126087\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<h3 id=\"childNodes-和-children-有什么区别？\"><a href=\"#childNodes-和-children-有什么区别？\" class=\"headerlink\" title=\"childNodes 和 children 有什么区别？\"></a>childNodes 和 children 有什么区别？</h3><p><strong>Node -&gt; childNodes</strong></p>\n<p>在 DOM 树中，所有的节点都是 Node，包括 Element，也就是说 Node 包含了 <code>HTML 元素标签</code>、<code>text</code>、<code>以及注释</code>等等内容，它是所有 DOM 的基类。</p>\n<p><strong>Element -&gt; HTMLCollection</strong></p>\n<p>在 DOM 树中，Element 只包含 HTML 元素标签。</p>\n<p><strong>关系</strong></p>\n<p>childNodes 属于 NodeList 集合，它会返回所有的子节点，包括文本、标签、注释等等。</p>\n<p>children 数据 HTMLCollection 集合，它会返回所有 HTML 元素节点。</p>\n<p>childNodes 包含 children。</p>\n<h3 id=\"Ajax、Fetch、Axios-三者的区别\"><a href=\"#Ajax、Fetch、Axios-三者的区别\" class=\"headerlink\" title=\"Ajax、Fetch、Axios 三者的区别\"></a>Ajax、Fetch、Axios 三者的区别</h3><p><strong>Ajax</strong></p>\n<p><em>全称：</em> Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。<br><em>特点</em> 局部刷新页面，无需重载整个页面。<br><em>简单来说</em> Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  function ajax(url) &#123;\n    &#x2F;&#x2F; 实例\n    const xhr &#x3D; new XMLHttpRequest();\n    &#x2F;&#x2F; 方法\n    xhr.open(&quot;get&quot;, url, false);\n    &#x2F;&#x2F; 监听\n    xhr.onreadystatechange &#x3D; function () &#123;\n      &#x2F;&#x2F; 异步回调函数\n      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          console.info(&quot;响应结果&quot;, xhr.response)\n        &#125;\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 发送\n    xhr.send(null);\n  &#125;\n\n  ajax(&#39;https:&#x2F;&#x2F;smallpig.site&#x2F;api&#x2F;category&#x2F;getCategory&#39;)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>Fetch</strong></p>\n<p><em>注意：</em>不应该和 Ajax 做比较, 应该和 <code>XMLHttpRequest</code>做比较， Ajax 一个是思想，Fetch 一个是真实存在的 API</p>\n<p><em>特点</em></p>\n<ul>\n<li>Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象</li>\n<li>内置的 API</li>\n<li>使用上更简单</li>\n<li>使用 promise, 不使用回调</li>\n<li>数据流对象处理数据<code>常用res.json()转化成json数据</code></li>\n</ul>\n<p><strong>Axios</strong></p>\n<p><em>Axios</em>是一个基于 promise 和 XHR 封装的网络请求库</p>\n<p><em>特点：</em></p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequests，从 node.js 创建 http 请求</li>\n<li>支持 Promise API</li>\n<li>拦截请求和响应</li>\n<li>转换请求数据和响应数据</li>\n<li>取消请求</li>\n<li>自动转换 JSON 数据</li>\n<li>客户端支持防御 XSRF</li>\n</ul>\n<img src=\"http://t-blog-images.aijs.top/img/202210171747226.webp\" />\n\n<h3 id=\"判断两个对象是否相等\"><a href=\"#判断两个对象是否相等\" class=\"headerlink\" title=\"判断两个对象是否相等\"></a>判断两个对象是否相等</h3><h3 id=\"实现浏览器多标签页之间通信\"><a href=\"#实现浏览器多标签页之间通信\" class=\"headerlink\" title=\"实现浏览器多标签页之间通信\"></a>实现浏览器多标签页之间通信</h3><p><strong>浏览器自身解决方案</strong></p>\n<p>localStorage(不跨域)、cookie(不跨域)、indexDB(不跨域)、sharedWorker(不跨域)</p>\n<p><strong>服务端协同</strong></p>\n<p>websocket</p>\n<p><strong>sessionStorage,webworker</strong></p>\n<p>属于页面会话级别</p>\n<h3 id=\"将类数组转为数组\"><a href=\"#将类数组转为数组\" class=\"headerlink\" title=\"将类数组转为数组\"></a>将类数组转为数组</h3><p><em>类数组：</em></p>\n<ul>\n<li>类数组是一个对象， 带有 length 属性</li>\n<li>没有数组方法，即不可调用数组的原型方法</li>\n</ul>\n<p><em>类数组：</em></p>\n<ul>\n<li>arguments</li>\n<li>HTMLCollection</li>\n<li>NodeList</li>\n</ul>\n<p><em>实现方案</em></p>\n<ul>\n<li>Array.from ES6 提供的方法，只能实现浅拷贝</li>\n<li>扩展运算符 不能使用在非迭代对象上</li>\n<li>数组 slice 方法 在不改变原数组的情况下返回数组中的某些元素并形成新的数组。</li>\n</ul>\n<h3 id=\"判断数据类型\"><a href=\"#判断数据类型\" class=\"headerlink\" title=\"判断数据类型\"></a>判断数据类型</h3><p>typeof 能判断基本数据类型，不能判断引用数据类型<br>instanceof 可以判断引用数据类型, 不能判断基本数据类型</p>\n<p>虽然上面两个结合可以处理，但是过于复杂</p>\n<p>每个对象都有一个  toString()  方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()  方法被每个  Object  对象继承。如果此方法在自定义对象中未被覆盖，toString()  返回  “[object type]”，其中  type  是对象的类型</p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7089322067677413412\">https://juejin.cn/post/7089322067677413412</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  function getType(data) &#123;\n    let originType &#x3D; Object.prototype.toString.call(data); &#x2F;&#x2F; 获取内部属性值\n    let index &#x3D; originType.indexOf(&#39; &#39;); &#x2F;&#x2F; 以空格分割\n    let type &#x3D; originType.slice(index + 1, -1); &#x2F;&#x2F; 截取 [object Number]\n    return type.toLowerCase();\n  &#125;\n  console.info(getType(&quot;小猪课堂&quot;)); &#x2F;&#x2F; string\n  console.info(getType(123)); &#x2F;&#x2F; number\n  console.info(getType(true)); &#x2F;&#x2F; boolean\n  console.info(getType(null)); &#x2F;&#x2F; null\n  console.info(getType(undefined)); &#x2F;&#x2F; undefined\n  console.info(getType(&#123; name: &quot;小猪课堂&quot; &#125;)); &#x2F;&#x2F; object\n  console.info(getType([1,3,2])); &#x2F;&#x2F; array\n  console.info(getType(Promise.resolve())); &#x2F;&#x2F; promise\n  console.info(getType(new Set())); &#x2F;&#x2F; set\n  console.info(getType(new WeakMap())); &#x2F;&#x2F; weakmap\n  console.info(getType(new Date())); &#x2F;&#x2F; date\n  console.info(getType(() &#x3D;&gt; &#123;&#125;)); &#x2F;&#x2F; function\n  console.info(getType(new Map)); &#x2F;&#x2F; map\n  console.info(getType(BigInt(100))); &#x2F;&#x2F; bigint\n  console.info(getType(new RegExp(&#39;&#39;))); &#x2F;&#x2F; regexp\n  console.info(getType((Symbol()))); &#x2F;&#x2F; symbol\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<h3 id=\"session、cookie、token-的区别？\"><a href=\"#session、cookie、token-的区别？\" class=\"headerlink\" title=\"session、cookie、token 的区别？\"></a>session、cookie、token 的区别？</h3><p>1.为什么会有它们？</p>\n<p><strong>无状态</strong><br>我们都知道 HTTP 协议是无状态的，所谓的无状态就是客户端每次想要与服务端通信，都必须重新与服务端链接，意味着请求一次客户端和服务端就连接一次，下一次请求与上一次请求是没有关系的。</p>\n<p><strong>区分用户</strong><br>这种无状态的方式就会存在一个问题：如何判断两次请求的是同一个人？就好比用户在页面 A 发起请求获取个人信息，然后在另一个页面同样发起请求获取个人信息，我们如何确定这俩个请求是同一个人发的呢？</p>\n<p>为了解决这种问题，我们就迫切需要一种方式知道发起请求的客户端是谁？此时，cookie、token、session 就出现了，它们就可以解决客户端标识的问题，在扩大一点就是解决权限问题。</p>\n<p>它们就好比让每个客户端或者说登录用户有了自己的身份证，我们可以通过这个身份证确定发请求的是谁！</p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7090503270447185951\">https://juejin.cn/post/7090503270447185951</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>cookie 的缺点：</p>\n<ul>\n<li>增加请求体积，浪费性能，因为每次请求都会携带 cookie。</li>\n<li>增加服务端资源消耗，因为每个客户端连接进来都需要生成 session，会占用服务端资源的。</li>\n<li>容易遭受 CSRF 攻击，即跨站域请求伪造。</li>\n</ul>\n<h3 id=\"new-做了哪些操作？手写一个-new-方法！\"><a href=\"#new-做了哪些操作？手写一个-new-方法！\" class=\"headerlink\" title=\"new 做了哪些操作？手写一个 new 方法！\"></a>new 做了哪些操作？手写一个 new 方法！</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  &#x2F;&#x2F; 定义构造函数\n  function Person(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n\n\n    return this.name + &#39;:&#39; + this.age\n  &#125;\n  &#x2F;&#x2F; 定义原型方法\n  Person.prototype.say &#x3D; function () &#123;\n    console.log(&quot;你好：&quot;, this.name)\n  &#125;\n\n\n  &#x2F;&#x2F; 手动实现new方法\n  function myNew(constructor) &#123;\n    if (typeof constructor !&#x3D;&#x3D; &quot;function&quot;) &#123;\n      throw &quot;myNew方法的第一个参数必须是一个方法&quot;;\n    &#125;\n\n\n    &#x2F;&#x2F; 基于constructor的原型创建一个全新的对象\n    let newObj &#x3D; Object.create(constructor.prototype);\n\n\n    &#x2F;&#x2F; 获取传入的参数\n    let args &#x3D; Array.from(arguments).slice(1);\n\n\n    &#x2F;&#x2F; 执行constructor函数，获取结果，并将属性添加到新对象newObj上\n    let result &#x3D; constructor.apply(newObj, args); &#x2F;&#x2F; 将this指向newObj\n\n\n    &#x2F;&#x2F; 判断result类型，如果是object或者function类型，则直接返回结果\n    let originType &#x3D; Object.prototype.toString.call(result); &#x2F;&#x2F; 获取内部属性值\n    let isObject &#x3D; originType &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;;\n    let isFunction &#x3D; originType &#x3D;&#x3D;&#x3D; &#39;[object Function]&#39;;\n    if (isObject || isFunction) &#123;\n      return result;\n    &#125; else &#123;\n      &#x2F;&#x2F; 返回新对象\n      return newObj;\n    &#125;\n  &#125;\n\n\n  let obj &#x3D; myNew(Person, &#39;小猪课堂&#39;, 26);\n  console.log(obj);\n  obj.say();\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"跨标签页的通讯方式有哪些\"><a href=\"#跨标签页的通讯方式有哪些\" class=\"headerlink\" title=\"跨标签页的通讯方式有哪些\"></a>跨标签页的通讯方式有哪些</h2><h3 id=\"为什么需要跨标签页通信\"><a href=\"#为什么需要跨标签页通信\" class=\"headerlink\" title=\"为什么需要跨标签页通信\"></a>为什么需要跨标签页通信</h3><p>一个标签页的数据，要同步给另一个标签页</p>\n<h3 id=\"列举\"><a href=\"#列举\" class=\"headerlink\" title=\"列举\"></a>列举</h3><ul>\n<li><code>广播模式：</code>Broadcast Channe &#x2F; Service Worker &#x2F; LocalStorage + StorageEvent</li>\n<li><code>共享存储模式：</code>Shared Worker &#x2F; IndexedDB &#x2F; cookie</li>\n<li><code>口口相传模式：</code>window.open + window.opener</li>\n<li><code>基于服务端：</code>Websocket &#x2F; Comet &#x2F; SSE 等</li>\n</ul>\n<p>作者：AlienZHOU<br>链接：<a href=\"https://juejin.cn/post/6844903811232825357\">https://juejin.cn/post/6844903811232825357</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>除了轮询还可以通过监听 tab 切换来实现数据同步<br>过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听 visibilitychange 这样的事件，来做一次信息同步即可</p>\n<h3 id=\"详细说明\"><a href=\"#详细说明\" class=\"headerlink\" title=\"详细说明\"></a>详细说明</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API\" target=\"_blank\" >Broadcast_Channel_API</a><br><a href=\"https://juejin.cn/post/6844903811232825357\" target=\"_blank\" >面试官：前端跨页面通信，你知道哪些方法？</a></p>\n<h3 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;iframe\n  src&#x3D;&quot;https:&#x2F;&#x2F;alienzhou.github.io&#x2F;cross-tab-communication&#x2F;&quot;\n  style&#x3D;&quot;width: 100%; height: 800px&quot;\n&gt;&lt;&#x2F;iframe&gt;</code></pre>\n\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p><a href=\"https://github.com/alienzhou/alienzhou.github.io/blob/master/cross-tab-communication/index.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"非同源\"><a href=\"#非同源\" class=\"headerlink\" title=\"非同源\"></a>非同源</h3><p><a href=\"https://juejin.cn/post/6869686782942773255\" target=\"_blank\" >见</a></p>\n<p>实现原理：<br><a href=\"http://localhost:3000/bbb.html%EF%BC%88%E7%AE%80%E7%A7%B0\">http://localhost:3000/bbb.html（简称</a> bbb 页面）嵌入 iframe 页面 <a href=\"http://localhost:3001/a.html%EF%BC%88%E7%AE%80%E7%A7%B0\">http://localhost:3001/a.html（简称</a> iframe 页面）<br>iframe 能够接受父级页面 bbb.html 发送过来的数据<br>与此同时 iframe 与实际需要接受数据的 <a href=\"http://localhost:3001/b.html\">http://localhost:3001/b.html</a>(简称 b 页面)同源，所以可以通过同源通信的 Broadcast Channel 方式将 iframe 接受到的数据发送给 b 页面实现 bbb 页面与 b 页面之间的数据发送</p>\n<p>作者：Tsuki_<br>链接：<a href=\"https://juejin.cn/post/6869686782942773255\">https://juejin.cn/post/6869686782942773255</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"demo-代码\"><a href=\"#demo-代码\" class=\"headerlink\" title=\"demo 代码\"></a>demo 代码</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 父传子\n\niframe.contentWindow.postMessage(&quot;父页面传送的数据&quot;, &quot;*&quot;);\n\n&#x2F;&#x2F; 父接子\n\nwindow.addEventListener(&quot;message&quot;, function (data) &#123;\n  console.log(data);\n&#125;);\n\n&#x2F;&#x2F; 子接父\nwindow.addEventListener(&quot;message&quot;, function (obj) &#123;\n  console.log(&quot;子页面&quot;);\n  console.log(obj);\n  let parentWindow &#x3D; obj.source;\n  parentWindow.postMessage(&quot;子页面传送的数据&quot;, &quot;*&quot;);\n&#125;);\n&#x2F;&#x2F; 子传父\nfunction sendMesg() &#123;\n  window.parent.window.postMessage(&quot;子页面传送的数据&quot;, &quot;*&quot;);\n&#125;</code></pre>\n\n<p><a href=\"https://blog.csdn.net/wangliuqi123/article/details/109577991\" target=\"_blank\" >见</a></p>\n<h2 id=\"CSS3-中-transition-和-animation-的属性分别有哪些\"><a href=\"#CSS3-中-transition-和-animation-的属性分别有哪些\" class=\"headerlink\" title=\"CSS3 中 transition 和 animation 的属性分别有哪些\"></a>CSS3 中 transition 和 animation 的属性分别有哪些</h2><h2 id=\"CSS3-font\"><a href=\"#CSS3-font\" class=\"headerlink\" title=\"CSS3 font\"></a>CSS3 font</h2><h2 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h2><h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的技术。</p>\n<p><em>函数柯里化，是可以用来慢慢凑齐参数，延迟函数的执行。（先分期交钱，后交货！）</em></p>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>函数有记忆功能（多次接受参数，记忆历史参数信息），累积接受参数个数函数小于定义参数个数时返回一个函数，继续接受参数，<code>典型的闭包 + 递归</code></p>\n<h3 id=\"为什么会出现\"><a href=\"#为什么会出现\" class=\"headerlink\" title=\"为什么会出现\"></a>为什么会出现</h3><h3 id=\"柯里化-1\"><a href=\"#柯里化-1\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const curry &#x3D; (fn, ...rest) &#x3D;&gt; &#123;\n  return (...args) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;判断参数总数是否和fn参数个数相等\n    if ([...rest, ...args].length &#x3D;&#x3D;&#x3D; fn.length) &#123;\n      return fn(...rest, ...args); &#x2F;&#x2F;拓展参数，调用fn\n    &#125; else &#123;\n      return curry(fn, [...rest, ...args]); &#x2F;&#x2F;迭代，传入现有的所有参数\n    &#125;\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; const curry &#x3D; (fn, ...args1) &#x3D;&gt; (...args2) &#x3D;&gt; ((arg) &#x3D;&gt; (arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, ...arg)))([\n&#x2F;&#x2F;       ...args1,\n&#x2F;&#x2F;       ...args2,\n&#x2F;&#x2F;     ]);\n\n&#x2F;&#x2F; 调用\nconst foo &#x3D; (a, b, c) &#x3D;&gt; a * b * c;\ncurry(foo)(2, 3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2)(3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3)(4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3, 4)(); &#x2F;&#x2F; -&gt; 24</code></pre>\n\n<p><a href=\"https://www.jianshu.com/p/c87242cd2f6c\" target=\"_blank\" >见</a></p>\n<h2 id=\"promise-与-async-的区别\"><a href=\"#promise-与-async-的区别\" class=\"headerlink\" title=\"promise 与 async 的区别\"></a>promise 与 async 的区别</h2><h3 id=\"async-特点\"><a href=\"#async-特点\" class=\"headerlink\" title=\"async 特点\"></a>async 特点</h3><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>async 解决了什么问题 promise 链式调用的烦恼<br>async 和 await 关键字让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 promise</p>\n<h4 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h4><ul>\n<li>async 函数是 AsyncFunction 构造函数的实例 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function#:~:text=async%20%E5%87%BD%E6%95%B0%E6%98%AF%20AsyncFunction%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B\" target=\"_blank\" >见</a></li>\n</ul>\n<h4 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h4><ul>\n<li>async 函数可能包含 0 个或者多个 await 表达式。</li>\n<li>await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。</li>\n<li>promise 的解决值会被当作该 await 表达式的返回值</li>\n</ul>\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ul>\n<li>从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。这样的话，一个不含 await 表达式的 async 函数是会同步运行的。</li>\n<li>如果函数体内有一个 await 表达式，async 函数就<code>一定</code>会异步执行。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><ul>\n<li>async 返回值<code>一定</code>为 promise, 如果返回值不是 promise，将会被隐式包装在一个 promise 中</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function foo() &#123;\n  return 1;\n&#125;\n&#x2F;&#x2F; 等价于\nfunction foo() &#123;\n  return Promise.resolve(1);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(1);\nasync function foo() &#123;\n  console.log(2);\n  await 1;\n  console.log(3);\n&#125;\nfoo();\nconsole.log(4);\n\n&#x2F;&#x2F; 结果：1243</code></pre>\n\n<h4 id=\"两个-await-执行说明\"><a href=\"#两个-await-执行说明\" class=\"headerlink\" title=\"两个 await, 执行说明\"></a>两个 await, 执行说明</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function foo() &#123;\n  const result1 &#x3D; await new Promise((resolve) &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; resolve(&quot;1&quot;))\n  );\n  const result2 &#x3D; await new Promise((resolve) &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; resolve(&quot;2&quot;))\n  );\n&#125;\nfoo();</code></pre>\n\n<ol>\n<li>foo 函数的第一行将会同步执行，await 将会等待 promise 的结束。然后暂停通过 foo 的进程，并将控制权交还给调用 foo 的函数。(控制权转出)</li>\n<li>一段时间后，当第一个 promise 完结的时候，控制权将重新回到 foo 函数内。示例中将会将 1（promise 状态为 fulfilled）作为结果返回给 await 表达式的左边即 result1。 (控制权转入)</li>\n<li>接下来函数会继续进行，到达第二个 await 区域，此时 foo 函数的进程将再次被暂停。(控制权转出)</li>\n<li>一段时间后，同样当第二个 promise 完结的时候，result2 将被赋值为 2，之后函数将会正常同步执行，将默认返回 undefined (控制权转入)</li>\n</ol>\n<p><em>注意： promise 链不是一次就构建好的，相反，promise 链是分阶段构造的，因此在处理异步函数时必须注意对错误函数的处理。</em></p>\n<h4 id=\"async-x2F-await-和-Promise-x2F-then-对比以及错误处理\"><a href=\"#async-x2F-await-和-Promise-x2F-then-对比以及错误处理\" class=\"headerlink\" title=\"async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理\"></a>async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理</h4><ul>\n<li>大多数 async 函数也可以使用 Promises 编写。但是，<code>在错误处理方面，async 函数更容易捕获异常错误</code></li>\n<li>如果任一 <code>awaited 调用失败</code>，它将<code>自动捕获异常</code>，async 函数<code>执行中断</code>，并通过<code>隐式返回 Promise </code>将错误传递给调用者</li>\n<li>async 函数仍有可能然可能错误地忽略错误.在 async 中， 没有等待 await 返回，则不会传播任何错误</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>promise 链式调用繁杂，async&#x2F;await 相对来说，更简单</li>\n<li>promise api 能够实现并发， async&#x2F;await 只会顺序执行</li>\n<li>async&#x2F;await 的返回值，一定是一个 promise，会进行隐式的包装（如果在发生错误时候进行，捕获处理然后返回一个值，之后真正返回并不是这个值，而是被 promise 包装了）</li>\n<li>async&#x2F;await 在处理错误方面更容易（任意一个 await 出错，会自动捕获异常，执行中断，隐式返回 promise 错误，这几个环环相扣）</li>\n<li>如果没有等待返回的情况下，async 可能错误的忽略错误，不进行传播错误</li>\n<li>因 async&#x2F;await 一定返回的是 promise,所以 async&#x2F;await 既可以用<code>try catch</code>， 也可以用<code>.catch</code> (<code>try catch</code>是 js 语法，<code>.catch</code>是<code>promise.catch</code>语法)</li>\n</ol>\n<h2 id=\"包装对象-x2F-原型与原型链\"><a href=\"#包装对象-x2F-原型与原型链\" class=\"headerlink\" title=\"包装对象&#x2F;原型与原型链\"></a>包装对象&#x2F;原型与原型链</h2><h3 id=\"包装对象的含义\"><a href=\"#包装对象的含义\" class=\"headerlink\" title=\"包装对象的含义\"></a>包装对象的含义</h3><p>（Number&#x2F;String）经过封装，能够处理（number&#x2F;string）的对象</p>\n<h3 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h3><div style=\"display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;\">\n<img src=\"http://t-blog-images.aijs.top/img/202210261711923.webp\" style=\"width: 550px;max-width:100%\" />\n<div style=\"width:10px\"></div>\n<img src=\"http://t-blog-images.aijs.top/img/202210261734112.webp\" style=\"width: 360px;max-width:100%\"/>\n</div>\n\n<p>细品 原型与原型链关系图：</p>\n<p>竖着看分为三栏：左侧为实例对象，中间为构造函数，右侧为原型对象</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">实例</th>\n<th align=\"left\">构造函数 <span style=\"color: red\">created by Function</span></th>\n<th align=\"left\">实例原型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">new Foo&#x2F;Number&#x2F;String</td>\n<td align=\"left\">function Foo&#x2F;Number&#x2F;String()</td>\n<td align=\"left\">Foo&#x2F;Number&#x2F;String.prototype</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">new Object</td>\n<td align=\"left\">function Object()</td>\n<td align=\"left\">Object.prototype</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n<td align=\"left\">function Function()</td>\n<td align=\"left\">Function.prototype</td>\n</tr>\n</tbody></table>\n<p><strong>注意：序号 1</strong><br>从 MDN Number 包装对象的目录接口也可以看出：Number 的原型链： <code>Function.prototype -&gt; Object.prototype -&gt; null</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; .__proto__ 表示：隐式原型\n&#x2F;&#x2F; .prototype 表示：显示原型\n实例.__proto__ &#x3D;&#x3D; 实例的原型对象\n构造函数的.__proto__ &#x3D;&#x3D; Function 的原型对象\n原型对象的.constructor &#x3D;&#x3D; 对应的构造函数\n构造函数的.prototype &#x3D;&#x3D; 对应的原型对象\n非(Object 和 null)的.__proto__ &#x3D;&#x3D; Object.prototype\nObject.__proto__ &#x3D;&#x3D; null\n\n&#x2F;&#x2F; 有意思的是 Function\nFunction.__proto__ &#x3D;&#x3D; Function.prototype\n</code></pre>\n\n<h2 id=\"Object-freeze-vs-Object-seal-vs-Object-preventExtensions\"><a href=\"#Object-freeze-vs-Object-seal-vs-Object-preventExtensions\" class=\"headerlink\" title=\"Object.freeze() vs Object.seal() vs Object.preventExtensions()\"></a>Object.freeze() vs Object.seal() vs Object.preventExtensions()</h2><h3 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze()\"></a>Object.freeze()</h3><ul>\n<li>不增加新属性</li>\n<li>不删除已有属性</li>\n<li>不赋值</li>\n<li>子属性对象可编辑</li>\n</ul>\n<h3 id=\"Object-seal\"><a href=\"#Object-seal\" class=\"headerlink\" title=\"Object.seal()\"></a>Object.seal()</h3><ul>\n<li>不增加新属性</li>\n<li>不删除已有属性</li>\n<li>可赋值</li>\n</ul>\n<h3 id=\"Object-preventExtensions\"><a href=\"#Object-preventExtensions\" class=\"headerlink\" title=\"Object.preventExtensions()\"></a>Object.preventExtensions()</h3><ul>\n<li>不增加新属性</li>\n<li>可改已有属性</li>\n</ul>\n<h3 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h3><table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">默认</th>\n<th align=\"left\">preventExtensions</th>\n<th align=\"left\">seal</th>\n<th align=\"left\">freeze</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">增加新属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">移除属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">更改属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">子对象属性操作</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://javascript.plainenglish.io/object-freeze-vs-object-seal-vs-object-preventextensions-e78ef3a24201\" target=\"_blank\" >见</a></p>\n<h2 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"前端工程化\"></a>前端工程化</h2><h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><p>最早的前端开发就是实现页面，及交互的特效。<br>但是随着需求的增加，前端也变成大前端，还要做 App、小程序以及各种端。在这种需求日增的情况下，必须得考虑一种新的方式，优化前端的开发工作，<br>例如，解决代码冗余，项目可维护性，提升版本迭代速度等等一系列的问题。前端工程化的概念也就是在这中情况下被提出了。</p>\n<h3 id=\"是什么-1\"><a href=\"#是什么-1\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>前端工程化的主要目标就是解放生产力、提高生产效率。通过制定一系列的规范，借<br>助工具和框架解决前端开发以及前后端协作过程中的痛点和难度问题。</p>\n<h3 id=\"如何实施前端工程化\"><a href=\"#如何实施前端工程化\" class=\"headerlink\" title=\"如何实施前端工程化\"></a>如何实施前端工程化</h3><ul>\n<li>前端后分离</li>\n<li>使用 webpack 实现项目构建</li>\n<li>使用 babel 完成 javascript 编译</li>\n<li>CSS 预编译</li>\n<li>模块化开发</li>\n<li>组件化</li>\n<li>本地开发环境&#x2F;模拟数据</li>\n<li>规范化约束</li>\n<li>项目部署</li>\n</ul>\n<h2 id=\"npm-run-做了什么\"><a href=\"#npm-run-做了什么\" class=\"headerlink\" title=\"npm run 做了什么\"></a>npm run 做了什么</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; package.json; -&gt; node_modules&#x2F;.bin&#x2F; -&gt;对应的可执行文件执行\n\n&#x2F;&#x2F; 在安装依赖的时候，是通过npm install xxx来执行的，例如npm install @vue&#x2F;cli-service,npm在安装这个依赖的时候，就会在node_modules&#x2F;.bin&#x2F;目录中创建好vue-cli-service为名的几个可执行文件了【不同系统对应不同的可执行文件】\n&#x2F;&#x2F; .bin目录下的文件不是任何一个npm包。目录下的文件，表示这是一个个软连接，打开文件可以看到文件顶部写着#!&#x2F;bin&#x2F;sh,表示这是一个脚本\n\n&#x2F;&#x2F; 当使用 npm run serve 执行 vue-cli-service serve时，虽然没有安装 vue-cli-service的全局命令，但是npm 会到 .&#x2F;node_modules&#x2F;.bin中找到 vue-cli-service 文件作为 脚本来执行，则相当于执行了 .&#x2F;node_modules&#x2F;.bin&#x2F;vue-cli-service serve（最后的 serve 作为参数传入）</code></pre>\n\n<h2 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h2><p><strong>1. 检查配置</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">项目级别的.npmrc文件 &gt;\n  用户级别的.npmrc文件 &gt;\n  全局的.npmrc文件 &gt;\n  npm内置的.npmrc文件;</code></pre>\n\n<p><strong>2、没有 lock 文件</strong><br>2.1、分析依赖关系，这是因为我们包会依赖其他的包，并且会多个包之间产生相同的依赖的关系。<br>2.2、从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）。<br>2.3、 获取到压缩包后会对压缩包进行缓存（从 npm5 开始有的）。<br>2.4、将压缩包解压到项目的 node_modules 文件夹中（前面我们讲过，require 的查找顺序会在该包下面查找）。<br><strong>3、有 lock 文件</strong><br>3.1、检测 lock 中包的版本是否和 package.json 中一致（会按照 semver 版本规范检测）。<br>3.2、不一致，那么会重新构建依赖关系，直接会走顶层的流程。<br>3.3、一致的情况下，会去优先查找缓存。<br>3.4、没有找到，会从 registry 仓库下载，直接走顶层流程。<br>3.5、查找到，会获取缓存中的压缩文件，并且将压缩文件解压到 node_modules 文件夹中。</p>\n<h2 id=\"实现-jsonp，传入-URL，callback-和-callbackName-三个参数\"><a href=\"#实现-jsonp，传入-URL，callback-和-callbackName-三个参数\" class=\"headerlink\" title=\"实现 jsonp，传入 URL，callback 和 callbackName 三个参数\"></a>实现 jsonp，传入 URL，callback 和 callbackName 三个参数</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n\n  function jsonp(url, callbackName, callback) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      try &#123;\n        let str &#x3D; &#96;$&#123;url&#125;?callback&#x3D;$&#123;callbackName&#125;&#96;\n        let scriptEle &#x3D; document.createElement(&#39;script&#39;)\n        scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;\n        scriptEle.src &#x3D; str\n        scriptEle.addEventListener(&#39;load&#39;, callback)\n        window[callbackName] &#x3D; function (data) &#123;\n          resolve(data)\n          document.body.removeChild(scriptEle)\n        &#125;\n        document.body.appendChild(scriptEle)\n      &#125; catch (err) &#123;\n        reject(err)\n      &#125;\n    &#125;)\n  &#125;\n\n\n  jsonp(&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;home&#39;, &#39;fun1&#39;, () &#x3D;&gt; &#123;console.log(&#39;加载成功&#39;)&#125;).then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<h2 id=\"原生-js-实现动态加载-js-文件\"><a href=\"#原生-js-实现动态加载-js-文件\" class=\"headerlink\" title=\"原生 js 实现动态加载 js 文件?\"></a>原生 js 实现动态加载 js 文件?</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n    function loadScript(src, attrs) &#123;\n      return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        try &#123;\n          &#x2F;&#x2F; 创建标签\n          let scriptEle &#x3D; document.createElement(&#39;script&#39;)\n          &#x2F;&#x2F; 类型\n          scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;\n          &#x2F;&#x2F; src\n          scriptEle.src &#x3D; src\n          &#x2F;&#x2F; 增加属性\n          for (let key in attrs) &#123;\n            scriptEle.setAttribute(key, attrs[key])\n          &#125;\n          &#x2F;&#x2F; 监听完成\n          scriptEle.addEventListener(&#39;load&#39;, function () &#123;\n            resolve(&#39;成功&#39;)\n          &#125;)\n          &#x2F;&#x2F; 挂载后加载\n          document.body.appendChild(scriptEle)\n        &#125; catch (err) &#123;\n          reject(err)\n        &#125;\n      &#125;)\n    &#125;\n    loadScript(&#39;http:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.6.2&#x2F;jquery.min.js&#39;, &#123;async: true&#125;).then(res &#x3D;&gt; &#123;\n      console.log(res)\n    &#125;)\n  &lt;&#x2F;script&gt;\n</code></pre>\n\n<h2 id=\"js-中的-for-循环注意点？\"><a href=\"#js-中的-for-循环注意点？\" class=\"headerlink\" title=\"js 中的 for 循环注意点？\"></a>js 中的 for 循环注意点？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 多个判断条件以最后一个为准\n&#x2F;&#x2F; 最后一个是 j &lt; 9\nfor (var i &#x3D; 0, j &#x3D; 0; i &lt; 5, j &lt; 9; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4\n&#x2F;&#x2F; 5 5\n&#x2F;&#x2F; 6 6\n&#x2F;&#x2F; 7 7\n&#x2F;&#x2F; 8 8\n&#x2F;&#x2F; 最后一个是  i &lt; 5\nfor (var i &#x3D; 0, j &#x3D; 0; j &lt; 9, i &lt; 5; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4</code></pre>\n\n<h2 id=\"new-操作符和点运算符的优先级\"><a href=\"#new-操作符和点运算符的优先级\" class=\"headerlink\" title=\"new 操作符和点运算符的优先级\"></a>new 操作符和点运算符的优先级</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Foo() &#123;\n  getName &#x3D; function () &#123;\n    console.log(1);\n  &#125;; &#x2F;&#x2F;会修改全局的下的getName\n  return this; &#x2F;&#x2F; 构造函数的返回值值得注意，如果是引用类型，则得到引用数据，null除外\n&#125;\nFoo.getName &#x3D; function () &#123;\n  console.log(2);\n&#125;;\nFoo.prototype.getName &#x3D; function () &#123;\n  console.log(3);\n&#125;;\nvar getName &#x3D; function () &#123;\n  console.log(4);\n&#125;;\nfunction getName() &#123;\n  console.log(5);\n&#125;\n\n&#x2F;&#x2F;请写出以下输出结果：\nFoo.getName(); &#x2F;&#x2F;2\ngetName(); &#x2F;&#x2F; 4\nFoo().getName(); &#x2F;&#x2F; 1\ngetName(); &#x2F;&#x2F; 1\nnew Foo.getName(); &#x2F;&#x2F; 2 这里是new了一个Foo.getName函数，并没有先执行Foo.getName()在去执行new操作\nnew Foo().getName(); &#x2F;&#x2F; 3 (new Foo()).getName() 此时的getName是找到Foo构造函数的原型对象上的getName属性\nnew new Foo().getName(); &#x2F;&#x2F; 3  new ((new Foo()).getName)();\n&#x2F;*******************升级版********************&#x2F;\n&#x2F;&#x2F; function Foo() &#123;\n&#x2F;&#x2F; \t\tthis.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(3);\n&#x2F;&#x2F; \t\t\treturn &#123;\n&#x2F;&#x2F; \t\t\t\tgetName: getName&#x2F;&#x2F;这个就是第六问中涉及的构造函数的返回值问题\n&#x2F;&#x2F; \t\t\t&#125;\n&#x2F;&#x2F; \t\t&#125;;&#x2F;&#x2F;这个就是第六问中涉及到的， JS 构造函数公有方法和原型链方法的优先级\n&#x2F;&#x2F; \t\tgetName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(1);\n&#x2F;&#x2F; \t\t&#125;;\n&#x2F;&#x2F; \t\treturn this\n&#x2F;&#x2F; \t&#125;\n&#x2F;&#x2F; \tFoo.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(2);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tFoo.prototype.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(6);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tvar getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(4);\n&#x2F;&#x2F; \t&#125;;\n\n&#x2F;&#x2F; \tfunction getName() &#123;\n&#x2F;&#x2F; \t\tconsole.log(5);\n&#x2F;&#x2F; \t&#125; &#x2F;&#x2F;答案：\n&#x2F;&#x2F; \tFoo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;4\n&#x2F;&#x2F; \tconsole.log(Foo())\n&#x2F;&#x2F; \tFoo().getName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tnew Foo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tnew Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F;             &#x2F;&#x2F;多了一问\n&#x2F;&#x2F; \tnew Foo().getName().getName(); &#x2F;&#x2F;3 1\n&#x2F;&#x2F; \tnew new Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_34146986&#x2F;article&#x2F;details&#x2F;92386841</code></pre>\n\n<h2 id=\"new-一个构造函数，如果函数返回不同类型的值，结果会如何\"><a href=\"#new-一个构造函数，如果函数返回不同类型的值，结果会如何\" class=\"headerlink\" title=\"new 一个构造函数，如果函数返回不同类型的值，结果会如何?\"></a>new 一个构造函数，如果函数返回不同类型的值，结果会如何?</h2><p>new 的原理： 最后要判断构造函数返回值是不是个对象，不是对象是对象返回这个值，不是对象，返回构造函数的实例</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">null instanceof Object; &#x2F;&#x2F; false\nObject instanceof null; &#x2F;&#x2F; 报错，instanceof 的右侧必须是一个对象\n&#x2F;&#x2F; Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object</code></pre>\n\n<h3 id=\"什么都不返回\"><a href=\"#什么都不返回\" class=\"headerlink\" title=\"什么都不返回\"></a>什么都不返回</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回一个新的对象\"><a href=\"#返回一个新的对象\" class=\"headerlink\" title=\"返回一个新的对象\"></a>返回一个新的对象</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return &#123;\n    name: &quot;1234&quot;,\n  &#125;;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;&#123;name: &#39;1234&#39;&#125;</code></pre>\n\n<h3 id=\"返回一个原始值\"><a href=\"#返回一个原始值\" class=\"headerlink\" title=\"返回一个原始值\"></a>返回一个原始值</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return 111;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-null\"><a href=\"#返回-null\" class=\"headerlink\" title=\"返回 null\"></a>返回 null</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return null;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-true\"><a href=\"#返回-true\" class=\"headerlink\" title=\"返回 true\"></a>返回 true</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return true;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-this\"><a href=\"#返回-this\" class=\"headerlink\" title=\"返回 this\"></a>返回 this</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  &#x2F;&#x2F; 构造函数this指的是对象实例\n  return this;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1);\n&#x2F;&#x2F; Person &#123;&#125;\n\n&#x2F;&#x2F; 但是 this instanceof Object true, 这里涉及到this指向问题</code></pre>\n\n<h2 id=\"为什么要用-apply-x2F-call-这两个函数\"><a href=\"#为什么要用-apply-x2F-call-这两个函数\" class=\"headerlink\" title=\"为什么要用 apply&#x2F;call 这两个函数\"></a>为什么要用 apply&#x2F;call 这两个函数</h2><ul>\n<li>说白了就是“拿来主义”、“借刀杀人”的功效，</li>\n<li>比如我想做什么事，我不会不要紧，只要有人会就可以实现。</li>\n<li>在程序里面就是，现在假如你想用什么方法，但是当前对象没有，你可以选择拓展，自己造一个这样的方法，但是你也可以直接拿来用</li>\n</ul>\n<p>有时候这样使用更方便，我们只需要对象和回调方法即可，按照一般的说法就是：call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。</p>\n<p><a href=\"https://segmentfault.com/q/1010000006732812\" target=\"_blank\" >讲真，为什么要用 apply 和 call 这两个函数？</a></p>\n","text":"var let const 区别： 版本： var 是 es6 之前， const、let es6 之后， 分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域 提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使...","link":"","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">var let const 区别：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9F\"><span class=\"toc-text\">什么是执行上下文？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#javascript-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">javascript 的执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">作用域链</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">词法作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%82%A3%E4%B9%88%E9%97%AD%E5%8C%85%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%EF%BC%8C%E9%94%80%E6%AF%81%E4%BA%86%EF%BC%8C%E5%8F%98%E9%87%8F%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F\"><span class=\"toc-text\">那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84\"><span class=\"toc-text\">闭包是如何回收的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">闭包使用原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F\"><span class=\"toc-text\">什么是作用域？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">原型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">什么是原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">为什么使用原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">原型分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">什么是原型链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建对象的几种方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Number%E3%80%81Boolean-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">Number、Boolean 包装类型的原型链是怎样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">简单数据类型，为什么可以调用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#instanceof\"><span class=\"toc-text\">instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">实例与构造函数之间的关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-class%E3%80%81extends-%E4%B8%8E-super-%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ES6 语法中的 class、extends 与 super 的原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this\"><span class=\"toc-text\">this</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-this-%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">聊下 this 指向问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E8%A6%81%E6%9C%89-this\"><span class=\"toc-text\">为什要有 this</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84\"><span class=\"toc-text\">this 是如何定义的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99\"><span class=\"toc-text\">this 绑定规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">this 绑定的优先级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85\"><span class=\"toc-text\">new 做了哪些事情</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create\"><span class=\"toc-text\">Object.create()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create-%E4%B8%8E-new-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Object.create 与 new 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">箭头函数与普通函数区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85-1\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB-class\"><span class=\"toc-text\">类 class</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">通过构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA\"><span class=\"toc-text\">编程方法论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是函数式编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向对象编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向过程编程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typescript\"><span class=\"toc-text\">typescript</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#type-%E4%B8%8E-interface-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">type 与 interface 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">相同点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">不同点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0%E4%B8%8A%EF%BC%9A1-%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">描述上：1. 都可以描述一个对象或者函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E4%B8%8A%EF%BC%9A-2-%E9%83%BD%E5%85%81%E8%AE%B8%E6%8B%93%E5%B1%95%EF%BC%88extends\"><span class=\"toc-text\">扩展上： 2. 都允许拓展（extends</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9-1\"><span class=\"toc-text\">不同点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-type-%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%8C%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%85%83%E7%BB%84%E7%AD%89%E7%B1%BB%E5%9E%8B-interface-%E4%B8%8D%E5%8F%AF%E4%BB%A5\"><span class=\"toc-text\">1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-type-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-typeof-%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E7%9A%84-%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC-interface-%E4%B8%8D%E5%8F%AF%E4%BB%A5\"><span class=\"toc-text\">2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#interface-%E8%83%BD%E5%A4%9F%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6-type-%E4%B8%8D%E8%A1%8C\"><span class=\"toc-text\">interface 能够声明合并(type 不行)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Typescript-%E4%B8%AD-extends-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">Typescript 中 extends 的作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">1、接口继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%99%AE%E9%80%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">2、普通条件判断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">3、泛型条件判断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">4、泛型约束</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React\"><span class=\"toc-text\">React</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-key\"><span class=\"toc-text\">聊下 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5-key\"><span class=\"toc-text\">为什么引入 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E6%9C%89%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">key 有什么要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5-key-%E4%B8%8D%E4%BC%9A%E7%94%A8-index\"><span class=\"toc-text\">通常情况 key 不会用 index</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-key\"><span class=\"toc-text\">什么时候使用 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E5%9C%A8%E6%BA%90%E7%A0%81%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9A%84\"><span class=\"toc-text\">key 在源码单节点、多节点中的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diff-%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">diff [单节点、多节点]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hooks-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">hooks 产生的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A4%8D%E7%94%A8%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%E5%BE%88%E9%9A%BE\"><span class=\"toc-text\">在组件之间复用状态逻辑很难</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">复杂组件变得难以理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84-class\"><span class=\"toc-text\">难以理解的 class</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">useEffect 执行特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-useEffect-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1. useEffect 做了什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8-useEffect%EF%BC%9F\"><span class=\"toc-text\">2. 为什么在组件内部调用 useEffect？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-useEffect-%E4%BC%9A%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%90%8E%E9%83%BD%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3. useEffect 会在每次渲染后都执行吗？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BC%A0%E9%80%92%E7%BB%99-useEffect-%E7%9A%84%E5%87%BD%E6%95%B0%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E4%B8%AD%E9%83%BD%E4%BC%9A%E6%9C%89%E6%89%80%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">4. 传递给 useEffect 的函数在每次渲染中都会有所不同</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-effect-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">5. effect 异步执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8-effect-%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">6. 为什么要在 effect 中返回一个函数？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-React-%E4%BD%95%E6%97%B6%E6%B8%85%E9%99%A4-effect%EF%BC%9F\"><span class=\"toc-text\">7. React 何时清除 effect？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E4%BD%BF%E7%94%A8%E7%89%B9%E7%82%B9%E4%B8%8A%EF%BC%9F\"><span class=\"toc-text\">useEffect 使用特点上？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">useEffect 实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hook-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">Hook 使用规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">父子组件生命周期函数执行顺序：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#StrictMode\"><span class=\"toc-text\">StrictMode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%B0%83\"><span class=\"toc-text\">协调</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">合成事件的捕获和冒泡如何实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">父子组件合成事件的捕获和冒泡执行顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">合成事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BA%95%E5%B1%82%E4%BA%8B%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">要使用浏览器的底层事件？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">变化？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E8%A2%AB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5%E8%A7%A6%E5%8F%91%EF%BC%9F\"><span class=\"toc-text\">在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8F%98%E6%9B%B4\"><span class=\"toc-text\">事件委托的变更</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%96%B0%E7%9A%84-JSX-%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">全新的 JSX 转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#git\"><span class=\"toc-text\">git</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-rebase-%E4%B8%8E-git-merge\"><span class=\"toc-text\">git rebase 与 git merge</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%AF%E4%BD%9C%E7%94%A8%E6%B8%85%E7%90%86%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">副作用清理时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React17-%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%94%B9\"><span class=\"toc-text\">React17 重大更改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%9F%BA%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">变基原理：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">什么时候用哪个？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%A4%94\"><span class=\"toc-text\">🤔</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%98%E9%87%91%E5%B0%8F%E7%8C%AA%E8%AF%BE%E5%A0%82\"><span class=\"toc-text\">掘金小猪课堂</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">for…in 和 for…of 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript-%E4%B8%AD%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">JavaScript 中可迭代对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%A0%E7%A7%8D%E8%8E%B7%E5%8F%96-URL-%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">几种获取 URL 参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#offsetHeight%E3%80%81scrollHeight%E3%80%81clientHeight-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">offsetHeight、scrollHeight、clientHeight 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#childNodes-%E5%92%8C-children-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">childNodes 和 children 有什么区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ajax%E3%80%81Fetch%E3%80%81Axios-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Ajax、Fetch、Axios 三者的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89\"><span class=\"toc-text\">判断两个对象是否相等</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">实现浏览器多标签页之间通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">将类数组转为数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">判断数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#session%E3%80%81cookie%E3%80%81token-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">session、cookie、token 的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-new-%E6%96%B9%E6%B3%95%EF%BC%81\"><span class=\"toc-text\">new 做了哪些操作？手写一个 new 方法！</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">跨标签页的通讯方式有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">为什么需要跨标签页通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E4%B8%BE\"><span class=\"toc-text\">列举</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">详细说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">演示</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">源码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%90%8C%E6%BA%90\"><span class=\"toc-text\">非同源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#demo-%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">demo 代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS3-%E4%B8%AD-transition-%E5%92%8C-animation-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">CSS3 中 transition 和 animation 的属性分别有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS3-font\"><span class=\"toc-text\">CSS3 font</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">柯里化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0\"><span class=\"toc-text\">为什么会出现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96-1\"><span class=\"toc-text\">柯里化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#promise-%E4%B8%8E-async-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">promise 与 async 的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">async 特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E6%88%90\"><span class=\"toc-text\">构成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E6%88%90\"><span class=\"toc-text\">组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">注意点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA-await-%E6%89%A7%E8%A1%8C%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">两个 await, 执行说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#async-x2F-await-%E5%92%8C-Promise-x2F-then-%E5%AF%B9%E6%AF%94%E4%BB%A5%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1-x2F-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">包装对象&#x2F;原型与原型链</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%AB%E4%B9%89\"><span class=\"toc-text\">包装对象的含义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承关系</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-freeze-vs-Object-seal-vs-Object-preventExtensions\"><span class=\"toc-text\">Object.freeze() vs Object.seal() vs Object.preventExtensions()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-freeze\"><span class=\"toc-text\">Object.freeze()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-seal\"><span class=\"toc-text\">Object.seal()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-preventExtensions\"><span class=\"toc-text\">Object.preventExtensions()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%86\"><span class=\"toc-text\">区分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">前端工程化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">为什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88-1\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">如何实施前端工程化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-run-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">npm run 做了什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-install\"><span class=\"toc-text\">npm install</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-jsonp%EF%BC%8C%E4%BC%A0%E5%85%A5-URL%EF%BC%8Ccallback-%E5%92%8C-callbackName-%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">实现 jsonp，传入 URL，callback 和 callbackName 三个参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%94%9F-js-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-js-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">原生 js 实现动态加载 js 文件?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%B8%AD%E7%9A%84-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">js 中的 for 循环注意点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">new 操作符和点运算符的优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BC%9A%E5%A6%82%E4%BD%95\"><span class=\"toc-text\">new 一个构造函数，如果函数返回不同类型的值，结果会如何?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E9%83%BD%E4%B8%8D%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">什么都不返回</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">返回一个新的对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">返回一个原始值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-null\"><span class=\"toc-text\">返回 null</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-true\"><span class=\"toc-text\">返回 true</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-this\"><span class=\"toc-text\">返回 this</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-apply-x2F-call-%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">为什么要用 apply&#x2F;call 这两个函数</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React中的术语","uid":"4cfbb91d77b5df4256b735640b2a3f88","slug":"2022-09-19react","date":"2022-09-19T12:42:20.000Z","updated":"2022-09-20T12:57:05.700Z","comments":true,"path":"api/articles/2022-09-19react.json","keywords":null,"cover":null,"text":"浅合并this.setState 会进行浅合并 falsyfalsy 表达式 MDN 8 个 falsy 值 &#x2F;&#x2F; | 值 | 说明 | &#x2F;&#x2F; | :-------- | :---------------------------------...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"React","slug":"React","count":28,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":22,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-this","uid":"f0c189916a4d9ce9f34f51ecbf84a8dc","slug":"2022-09-18this","date":"2022-09-18T04:09:38.000Z","updated":"2022-09-18T08:44:46.706Z","comments":true,"path":"api/articles/2022-09-18this.json","keywords":null,"cover":null,"text":"注意啦，注意啦以下皆对普通函数而言，箭头函数可不是这么玩的 为什要有 thisthis 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。 简单来说：this，被放到作用域中， 为了...","link":"","photos":[],"count_time":{"symbolsCount":838,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":39,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":41,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}