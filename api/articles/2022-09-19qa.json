{"title":"前端基础-qa","uid":"d55ac1d91034293bfc294fd694ca97c4","slug":"2022-09-19qa","date":"2022-09-18T09:13:05.000Z","updated":"2023-02-20T21:20:56.473Z","comments":true,"path":"api/articles/2022-09-19qa.json","keywords":null,"cover":[],"content":"<h2 id=\"var-let-const-区别：\"><a href=\"#var-let-const-区别：\" class=\"headerlink\" title=\"var let const 区别：\"></a>var let const 区别：</h2><ol>\n<li><code>版本</code>： var 是 es6 之前， const、let es6 之后，</li>\n<li><code>分类</code>： 在 es6 之前只有<code>全局作用域</code>和<code>函数作用域</code>， const、let 块级作用域</li>\n<li><code>提升</code>：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前使用会报错</li>\n<li><code>重复</code>：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值</li>\n<li><code>存储</code>：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li>\n<li><code>默认</code>： 默认情况下是 var 声明</li>\n<li><code>函数</code>：函数声明提升优先于 var</li>\n</ol>\n<p>补充说明： const 和不变性。</p>\n<ol>\n<li>const 创建一个变量名绑定，该绑定在创建后不能重新分配。</li>\n<li>const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。</li>\n</ol>\n<h2 id=\"什么是执行上下文？\"><a href=\"#什么是执行上下文？\" class=\"headerlink\" title=\"什么是执行上下文？\"></a>什么是执行上下文？</h2><p>当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。</p>\n<ol>\n<li><code>全局上下文：</code>默认&#x2F;基础的上下文，任何不在函数内部的代码都在全局上下文中，一个程序中只有一个全局执行上下文</li>\n<li><code>函数执行上下文</code>：一个函数被调用时，会为该函数创建一个上下文，每个函数都有自己的函数上下文，函数上下文可以有任意多个</li>\n<li><code>eval上下文</code>：执行在 eval 函数内部的代码也会有属于它自己的执行上下文</li>\n</ol>\n<h2 id=\"javascript-的执行顺序\"><a href=\"#javascript-的执行顺序\" class=\"headerlink\" title=\"javascript 的执行顺序\"></a>javascript 的执行顺序</h2><ol>\n<li><code>JavaScript 代码在执行的过程中</code>，需要先做变量提升，之所以如此，是因为 JavaScript 代码在执行前需要进行<code>编译</code>；</li>\n<li>在编译阶段，<ol>\n<li>变量和函数会被存放到<code>变量环境</code>中，变量的默认值为 undefined；</li>\n<li>块级作用域会被存放到<code>词法环境</code>中；</li>\n<li>存在两个相同的函数，后面的会<code>覆盖</code>前面的函数；</li>\n</ol>\n</li>\n<li>调用函数时，JavaScript 引擎维护了一个栈的数据结构（<code>调用栈</code>），每次调用函数都会将函数的执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码；</li>\n<li>当函数执行完毕后，JavaScript 引擎会将该函数的执行上下文<code>弹出栈</code>；</li>\n<li>当分配的栈空间被占满时，会引发<code>栈溢出</code>的情况；</li>\n</ol>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/6965786039185047559\">https://juejin.cn/post/6965786039185047559</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>作用域是可访问变量的集合。</p>\n<ol>\n<li>全局作用域</li>\n<li>函数作用域</li>\n<li>块级作用域</li>\n</ol>\n<p>JavaScript 变量生命周期</p>\n<ol>\n<li>局部变量在函数执行完毕后销毁。</li>\n<li>全局变量在页面关闭后销毁。</li>\n</ol>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><ol>\n<li>当执行一段代码时，JS 引擎首先在当前执行上下文中查找变量，</li>\n<li>如果找不到，会根据外部引用, 去对应的外部执行上下文查找变量，直到查找到最外层的全局执行上下文，</li>\n<li>从当前执行上下文到全局执行上下文，形成了一个链条，我们称为<code>作用域链</code></li>\n</ol>\n<p>简单来说：由于函数嵌套，一个变量在当前函数作用域找不到，会往上找，直到全局作用域，这种作用域嵌套的现象；由内向外，一层一层往上的链式规则，这就是作用域链</p>\n<p><a href=\"https://juejin.cn/post/7023259995219165214\" target=\"_blank\" >JavaScript 执行机制二（深入之闭包）</a></p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><ol>\n<li>词法作用域是<code>由代码声明的位置决定的</code>，所以词法作用域<code>是静态作用域</code>，通过它<code>能预测代码在执行过程中如何查找标识</code>。</li>\n<li>对于代码中<code>存在块级作用域的情况</code>，<code>作用域链首先在词法环境中查找，没找到才会到变量环境中查找</code></li>\n</ol>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bfb6a6ffe2147be9ce8dbcc60eb0de5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" />\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在 JavaScript 中，根据词法作用域的规则，内部函数总能访问外部函数声明的变量，当通过调用外部函数返回内部函数时，即使外部函数执行完毕，内部函数引用外部函数的变量仍存在内存中，我们就把这些变量的集合称为闭包</p>\n<h3 id=\"那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\"><a href=\"#那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\" class=\"headerlink\" title=\"那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\"></a>那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？</h3><ol>\n<li>如果一个函数内有闭包，javascript 在执行这个函数时候，会预扫描内部函数是否有使用的 foo 函数中声明的变量；</li>\n<li>预扫描过程中，在内层函数 showName 中找到了外部函数 foo 中声明的变量 name，因此在 JavaScript 中判断这是一个闭包，</li>\n<li>此时会在堆中开辟一个空间创建 closure(foo)对象，将 name 值存到里面。</li>\n<li>而执行栈中的 foo 执行上下文中的 name 存的值是 closure(foo)的地址，因此当 foo 函数执行完成并销毁，name 值仍然存在堆的 closure(foo)的对象中，具体如下图所示：</li>\n<li><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22b437d4602e45379d9c9b4139817a24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" /></li>\n</ol>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/7023259995219165214\">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"闭包是如何回收的\"><a href=\"#闭包是如何回收的\" class=\"headerlink\" title=\"闭包是如何回收的\"></a>闭包是如何回收的</h3><ol>\n<li>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭。但如果这个变量之后不在使用，就会造成内存泄露</li>\n<li>如果引用闭包的函数是一个局部变量，等函数销毁后，在下一次执行垃圾回收时，判断闭包这块内容不再使用，那么 JavaScript 引擎的垃圾回收器就会回收这块内容</li>\n</ol>\n<h3 id=\"闭包使用原则\"><a href=\"#闭包使用原则\" class=\"headerlink\" title=\"闭包使用原则\"></a>闭包使用原则</h3><ol>\n<li>如果该闭包会一直使用，那么它可以作为全局变量而存在；</li>\n<li>但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>作用域链：</code>每个执行上下文都有一个指向外部的 outer，这个指向外部的引用 outer 在编译时就决定了，也就是说，根据声明的位置就能确定外部引用 outer，这就是词法作用域（静态作用域），它能预测代码执行过程中如何查找标识。通过它就能确定作用域链。</li>\n<li><code>闭包：</code>外部函数声明的变量，在内部函数中调用，当调用外部函数返回内部函数时，外部函数中声明的变量并不会随着外部函数执行完成而销毁，这些变量构成的集合就是外部函数的闭包。</li>\n<li><code>栈和堆空间：</code>基本数据类型是存在栈空间中的，引用数据类型是存在堆空间中的。<code>当形成闭包时，外部函数声明的变量存放在调用栈中，对于外部函数中的变量被内部函数所使用，在堆中就会创建一个 closure(函数名)的对象，用于存放闭包的变量集合，而外部函数中存的只是堆中的地址。所以说，当外部函数执行完成销毁时，JavaScript 引擎并不会回收堆中的地址。</code></li>\n<li><code>正确使用闭包：</code>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用。</li>\n</ol>\n<p>作者：chicABoo<br>链接：<a href=\"https://juejin.cn/post/7023259995219165214\">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"什么是作用域？\"><a href=\"#什么是作用域？\" class=\"headerlink\" title=\"什么是作用域？\"></a>什么是作用域？</h3><p>通俗点来讲就是：指变量的可使用范围</p>\n<p>一般有三种作用域：全局作用域、函数作用域、块级作用域</p>\n<ol>\n<li><code>全局作用域</code>：声明的变量，全局可见</li>\n<li><code>函数作用域</code>：声明的变量在当前函数内部可见</li>\n<li><code>块级作用域</code>：{},条件语句，循环语句中</li>\n</ol>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"什么是原型\"><a href=\"#什么是原型\" class=\"headerlink\" title=\"什么是原型\"></a>什么是原型</h3><p>在 js 面向对象编程的实现 中, 原型是一个 prototype 对象，用于表示类型之间的关系。每一个对象都与另一个对象相关联，那个关联的对象就称为原型</p>\n<h3 id=\"为什么使用原型\"><a href=\"#为什么使用原型\" class=\"headerlink\" title=\"为什么使用原型\"></a>为什么使用原型</h3><ol>\n<li>原型对象的用途： 是为每个实例对象 “存储” 共享的方法和属性，它仅仅是一个普通对象而已。</li>\n<li>所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。</li>\n</ol>\n<h3 id=\"原型分类\"><a href=\"#原型分类\" class=\"headerlink\" title=\"原型分类\"></a>原型分类</h3><p>显示原型和隐式原型</p>\n<ol>\n<li>显示原型： prototype 关键字标识</li>\n<li>隐式原型： <code>__proto__</code>表示</li>\n<li>一个构造函数显示原型 &#x3D;&#x3D;&#x3D; 该构造函数一个实例的隐式原型 即： （构造函数.<code>prototype</code> &#x3D;&#x3D;&#x3D; 构造函数实例.<code>__proto__</code>）</li>\n</ol>\n<h3 id=\"什么是原型链\"><a href=\"#什么是原型链\" class=\"headerlink\" title=\"什么是原型链\"></a>什么是原型链</h3><ol>\n<li>每个实例对象的<code>__proto__</code>​ 属性, 指向它的构造函数的原型对象（<code>prototype</code>）。</li>\n<li>该原型对象也有一个自己的原型对象（<code>__proto__</code>​），层层向上直到一个对象的原型对象为 <code>null</code>​。</li>\n<li>根据定义，<code>null</code>​ 没有原型，并作为这个原型链中的最后一个环节</li>\n</ol>\n<p>简单来说，原型链是： 一个对象 找原型对象 的依据</p>\n<p><a href=\"https://www.51cto.com/article/718086.html\" target=\"_blank\" >见</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%80%A7%E8%83%BD:~:text=%E5%B9%B6%E4%BD%9C%E4%B8%BA%E8%BF%99%E4%B8%AA-,%E5%8E%9F%E5%9E%8B%E9%93%BE,-%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA\" target=\"_blank\" >原型链</a></p>\n<h3 id=\"创建对象的几种方式\"><a href=\"#创建对象的几种方式\" class=\"headerlink\" title=\"创建对象的几种方式\"></a>创建对象的几种方式</h3><ol>\n<li>对象字面量</li>\n<li>构造函数</li>\n<li>new 关键字</li>\n<li>Object.create</li>\n<li>class</li>\n</ol>\n<h4 id=\"继承，原型链\"><a href=\"#继承，原型链\" class=\"headerlink\" title=\"继承，原型链\"></a>继承，原型链</h4><p>当谈到继承时，JavaScript 只有一种结构：</p>\n<p>对象。每个实例对象（object）都有一个私有属性（称之为 <code>__proto__</code>）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（<code>__proto__</code>），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节</p>\n<h4 id=\"继承属性\"><a href=\"#继承属性\" class=\"headerlink\" title=\"继承属性\"></a>继承属性</h4><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。</p>\n<p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>\n<h4 id=\"继承方法\"><a href=\"#继承方法\" class=\"headerlink\" title=\"继承方法\"></a>继承方法</h4><p>函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var o &#x3D; &#123;\n  a: 2,\n  m: function () &#123;\n    return this.a + 1;\n  &#125;,\n&#125;;\n\nconsole.log(o.m()); &#x2F;&#x2F; 3\n&#x2F;&#x2F; 当调用 o.m 时，&#39;this&#39; 指向了 o.\n\nvar p &#x3D; Object.create(o);\n&#x2F;&#x2F; p 是一个继承自 o 的对象\n\np.a &#x3D; 4; &#x2F;&#x2F; 创建 p 的自身属性 &#39;a&#39;\nconsole.log(p.m()); &#x2F;&#x2F; 5 &#x2F;&#x2F; 属性屏蔽\n&#x2F;&#x2F; 调用 p.m 时，&#39;this&#39; 指向了 p\n&#x2F;&#x2F; 又因为 p 继承了 o 的 m 函数\n&#x2F;&#x2F; 所以，此时的 &#39;this.a&#39; 即 p.a，就是 p 的自身属性 &#39;a&#39;</code></pre>\n\n<h4 id=\"使用语法结构创建的对象\"><a href=\"#使用语法结构创建的对象\" class=\"headerlink\" title=\"使用语法结构创建的对象\"></a>使用语法结构创建的对象</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var o &#x3D; &#123; a: 1 &#125;;\n\n&#x2F;&#x2F; o 这个对象继承了 Object.prototype 上面的所有属性\n&#x2F;&#x2F; o 自身没有名为 hasOwnProperty 的属性\n&#x2F;&#x2F; hasOwnProperty 是 Object.prototype 的属性\n&#x2F;&#x2F; 因此 o 继承了 Object.prototype 的 hasOwnProperty\n&#x2F;&#x2F; Object.prototype 的原型为 null\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; o ---&gt; Object.prototype ---&gt; null\n\nvar a &#x3D; [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];\n\n&#x2F;&#x2F; 数组都继承于 Array.prototype\n&#x2F;&#x2F; (Array.prototype 中包含 indexOf, forEach 等方法)\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null\n\nfunction f() &#123;\n  return 2;\n&#125;\n\n&#x2F;&#x2F; 函数都继承于 Function.prototype\n&#x2F;&#x2F; (Function.prototype 中包含 call, bind 等方法)\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code></pre>\n\n<h4 id=\"使用构造器创建的对象\"><a href=\"#使用构造器创建的对象\" class=\"headerlink\" title=\"使用构造器创建的对象\"></a>使用构造器创建的对象</h4><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Graph() &#123;\n  this.vertices &#x3D; [];\n  this.edges &#x3D; [];\n&#125;\n\nGraph.prototype &#x3D; &#123;\n  addVertex: function (v) &#123;\n    this.vertices.push(v);\n  &#125;,\n&#125;;\n\nvar g &#x3D; new Graph();\n&#x2F;&#x2F; g 是生成的对象，他的自身属性有 &#39;vertices&#39; 和 &#39;edges&#39;。\n&#x2F;&#x2F; 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。</code></pre>\n\n<h4 id=\"使用-Object-create-创建的对象\"><a href=\"#使用-Object-create-创建的对象\" class=\"headerlink\" title=\"使用 Object.create 创建的对象\"></a>使用 Object.create 创建的对象</h4><p>ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; &#123; a: 1 &#125;;\n&#x2F;&#x2F; a ---&gt; Object.prototype ---&gt; null\n\nvar b &#x3D; Object.create(a);\n&#x2F;&#x2F; b ---&gt; a ---&gt; Object.prototype ---&gt; null\nconsole.log(b.a); &#x2F;&#x2F; 1 (继承而来)\n\nvar c &#x3D; Object.create(b);\n&#x2F;&#x2F; c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null\n\nvar d &#x3D; Object.create(null);\n&#x2F;&#x2F; d ---&gt; null\nconsole.log(d.hasOwnProperty); &#x2F;&#x2F; undefined，因为 d 没有继承 Object.prototype</code></pre>\n\n<h3 id=\"Number、Boolean-包装类型的原型链是怎样的？\"><a href=\"#Number、Boolean-包装类型的原型链是怎样的？\" class=\"headerlink\" title=\"Number、Boolean 包装类型的原型链是怎样的？\"></a>Number、Boolean 包装类型的原型链是怎样的？</h3><p><code>包装类型是构造函数 -&gt; 构造函数的原型是函数原型 -&gt; 对象的原型-&gt; null</code></p>\n<h3 id=\"简单数据类型，为什么可以调用方法\"><a href=\"#简单数据类型，为什么可以调用方法\" class=\"headerlink\" title=\"简单数据类型，为什么可以调用方法\"></a>简单数据类型，为什么可以调用方法</h3><p><a href=\"https://www.cnblogs.com/venoral/p/5243189.html\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var s1 &#x3D; &quot;some text&quot;;\nvar s2 &#x3D; s1.substring(2); &#x2F;&#x2F;&#39;me text&#39;</code></pre>\n\n<p>基本类型不是对象，因而从逻辑上讲他们不该有方法，其实为了让我们实现这种操作，后台已经完成了一系列的处理。</p>\n<p>第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台会完成如下处理：</p>\n<p><strong>创建</strong> <code>String/Boolean/Number</code> 类的一个实例。<code>var s1=new String(&#39;some text&#39;);</code><br><strong>调用</strong>在实例上调用指定的方法。<code>var s2=s1.substring(2);//&#39;me text&#39;</code><br><strong>销毁</strong>这个实例<code>。s1=null</code></p>\n<p><strong>引用类型与基本包装类型的主要区别就是对象的生存期：</strong></p>\n<ul>\n<li><em>使用 new 操作符创建的引用类型的实例</em> ，在执行完离开当前作用域之前都一直保存在内存中。</li>\n<li><em>自动创建的基本包装类型的对象</em> ，只存在于代码执行的一瞬间，然后被立即销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</li>\n</ul>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><p>instanceof 运算符</p>\n<ol>\n<li><del>判断一个对象是否是另一个对象的实例</del></li>\n<li>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</li>\n</ol>\n<h3 id=\"实例与构造函数之间的关系\"><a href=\"#实例与构造函数之间的关系\" class=\"headerlink\" title=\"实例与构造函数之间的关系\"></a>实例与构造函数之间的关系</h3><p>实例.<code>__proto__</code> &#x3D;&#x3D;&#x3D; 该实例的构造函数.<code>prototype</code></p>\n<h3 id=\"ES6-语法中的-class、extends-与-super-的原理\"><a href=\"#ES6-语法中的-class、extends-与-super-的原理\" class=\"headerlink\" title=\"ES6 语法中的 class、extends 与 super 的原理\"></a>ES6 语法中的 class、extends 与 super 的原理</h3><p><a href=\"https://www.cnblogs.com/rencoo/p/11879150.html\" target=\"_blank\" >见</a></p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><h3 id=\"聊下-this-指向问题\"><a href=\"#聊下-this-指向问题\" class=\"headerlink\" title=\"聊下 this 指向问题\"></a>聊下 this 指向问题</h3><p>以下皆对普通函数而言，箭头函数可不是这么玩的</p>\n<h3 id=\"为什要有-this\"><a href=\"#为什要有-this\" class=\"headerlink\" title=\"为什要有 this\"></a>为什要有 this</h3><p>简单来说：<code>this,被放到作用域中， 为了简化代码</code></p>\n<p>this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。</p>\n<h3 id=\"this-是如何定义的\"><a href=\"#this-是如何定义的\" class=\"headerlink\" title=\"this 是如何定义的\"></a>this 是如何定义的</h3><p>简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的</p>\n<p>我们简单总结一下 this 的特点：</p>\n<ul>\n<li>this 是在运行时绑定的，不是在编写时绑定</li>\n<li>this 的绑定与函数的声明和位置没有任何关系</li>\n<li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。</li>\n</ul>\n<p>所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</p>\n<p>简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>\n<h3 id=\"this-绑定规则\"><a href=\"#this-绑定规则\" class=\"headerlink\" title=\"this 绑定规则\"></a>this 绑定规则</h3><ol>\n<li>判断函数调用时是否使用了 new，如果使用了 new 绑定，则 this 绑定的是新创建的对象。</li>\n<li>函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。</li>\n<li>函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。</li>\n<li>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，<br>4.1 在严格模式下，默认绑定的 this 是 undefined，<br>4.2 非严格模式下绑定到全局对象。</li>\n</ol>\n<p><em>类声明和类表达式的主体都执行在严格模式下</em></p>\n<p><a href=\"/posts/2022-10-21js-class\" target=\"_blank\" >前端基础-class</a></p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7115390077353590792\">https://juejin.cn/post/7115390077353590792</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"this-绑定的优先级\"><a href=\"#this-绑定的优先级\" class=\"headerlink\" title=\"this 绑定的优先级\"></a>this 绑定的优先级</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定</code></pre>\n\n<h2 id=\"new-做了哪些事情\"><a href=\"#new-做了哪些事情\" class=\"headerlink\" title=\"new 做了哪些事情\"></a>new 做了哪些事情</h2><ol>\n<li>创建一个空对象；</li>\n<li>将空对象的原型，指向于构造函数的原型；</li>\n<li>将空对象作为构造函数的上下文（改变 this 指向）；</li>\n<li>对有返回值的构造函数做判断处理</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;定义构造函数\nfunction Fun(age, name) &#123;\n  this.age &#x3D; age;\n  this.name &#x3D; name;\n  return 1;\n&#125;\n\nfunction myNew(fn, ...args) &#123;\n  &#x2F;&#x2F;1、先创造空对象\n  &#x2F;&#x2F;其实等于var obj &#x3D; Object.create(&#123;&#125;)\n  var obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F;2、obj的__proto__指向原型\n  Object.setPrototypeOf(obj, fn.prototype);\n  &#x2F;&#x2F;3、改变this指向，执行构造函数内部函数\n  var result &#x3D; fn.apply(obj, args);\n  &#x2F;&#x2F;4、判断return\n  return result instanceof Object ? result : obj;\n&#125;</code></pre>\n\n<p><a href=\"cnblogs.com/jacky02/p/16048701.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;</code></pre>\n\n<h3 id=\"Object-create-与-new-的区别\"><a href=\"#Object-create-与-new-的区别\" class=\"headerlink\" title=\"Object.create 与 new 的区别\"></a>Object.create 与 new 的区别</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; new Object() 方式创建\nvar obj &#x3D; &#123; name: &quot;jack&quot; &#125;;\nvar b &#x3D; new Object(obj);\nconsole.log(b.name);\nconsole.log(b.__proto__.name); &#x2F;&#x2F;undefined\n\n&#x2F;&#x2F; Object.create() 方式创建\nvar obj2 &#x3D; &#123; name: &quot;apple&quot; &#125;;\nvar c &#x3D; Object.create(obj2);\nconsole.log(c.name);\nconsole.log(c.__proto__.name); &#x2F;&#x2F;apple</code></pre>\n\n<p>new 出来的 b 对象，通过原型链无法访问到 name 属性，而 Object.create 出来的 c 却可以</p>\n<h2 id=\"箭头函数与普通函数区别\"><a href=\"#箭头函数与普通函数区别\" class=\"headerlink\" title=\"箭头函数与普通函数区别\"></a>箭头函数与普通函数区别</h2><ol>\n<li><p><strong>使用</strong>简单：箭头函数使用起来简单，更适合匿名函数; <code>比较特殊的对象方法</code>，可以简写<code>()&#123;&#125;</code>,这个不是箭头函数</p>\n</li>\n<li><p><strong>声明</strong>具名箭头函数可以用 var let const , 普通函数除这些之外还可用 function 关键字</p>\n</li>\n<li><p><strong>立即执行</strong> 普通函数可以声明立即执行函数，箭头函数也可<code>void (()=&gt; &#123;console.log(1)&#125;)()</code></p>\n</li>\n<li><p><strong>运算上</strong> 在使用短路运算符的时候，箭头函数要用<code>()</code>括起来，否则因解析顺序导致错误</p>\n</li>\n<li><p><strong>拥有</strong> 箭头函数没有自己的 this, prototype，arguments, super, new.target,</p>\n</li>\n<li><p>基于此：箭头函数不适用于<code>构造函数、new、yeild</code> 等场合</p>\n</li>\n<li><p>在 apply,call,bind 中第一个参数会被忽略</p>\n</li>\n<li><p>箭头函数没有 arguments，可以使用…rest, （这里有个注意的点：普通函数 arguments，<strong>在非严格模式下</strong>，有<code>默认参数、剩余参数和结构赋值</code>的情况会出现： arguments 与形参不一致的情况）</p>\n</li>\n</ol>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p><code>背景</code>：js 是单线程的，同一时间 dom 的操作不允许并行</p>\n<p><code>出现的原因</code>：单线程，如果出现耗时的情况会一直等待，以浏览器为例： 浏览器分为 5 大线程，定时器线程和网络线程</p>\n<p><code>解决了什么问题</code>：在单线程中，可以跳过一些耗时的操作，先去做其他的事情，待到需要执行的时候，再执行，而这一策略被称为 事件循环</p>\n<p><code>执行过程：</code> <code>宿主环境</code>：以浏览器环境来说</p>\n<ol>\n<li>在 javascript 中，将任务放到执行栈中执行，执行完成的会出栈；未执行的会依次压入栈底，</li>\n<li>先执行同步任务（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部），直至同步任务都被执行完</li>\n<li>然后执行微任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）直至微任务队列都被执行完</li>\n<li>然后执行宏任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）</li>\n<li>会再去检测微任务队列，之后，再以相同的方式去执行宏任务队列</li>\n</ol>\n<h2 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h2 id=\"类-class\"><a href=\"#类-class\" class=\"headerlink\" title=\"类 class\"></a>类 class</h2><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><h3 id=\"通过构造函数\"><a href=\"#通过构造函数\" class=\"headerlink\" title=\"通过构造函数\"></a>通过构造函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  constructor() &#123;\n    console.log(&quot;this&quot;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h3 id=\"通过静态方法\"><a href=\"#通过静态方法\" class=\"headerlink\" title=\"通过静态方法\"></a>通过静态方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"编程方法论\"><a href=\"#编程方法论\" class=\"headerlink\" title=\"编程方法论\"></a>编程方法论</h2><h3 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h3><ol>\n<li>函数式编程是<code>通过组合纯函数，避免状态共享、可变数据、副作用，来构建软件的过程</code>。</li>\n<li>函数式编程是<code>声明式的</code>，而不是命令式的，<code>应用程序状态通过纯函数流动</code>。</li>\n<li>与面向对象编程不同，在面向对象编程中，<code>应用程序状态，通常与对象中的方法，共享和协作</code>。</li>\n<li>与命令式或面向对象的代码相比，函数式代码往往<code>更简洁、更可预测、更易于测试</code></li>\n</ol>\n<p><a href=\"https://github.com/xitu/gold-miner/blob/master/TODO1/master-the-javascript-interview-what-is-functional-programming.md\" target=\"_blank\" >见</a></p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>函数式编程有些重要的概念：</p>\n<ol>\n<li><code>纯函数</code>： 给定相同的输入，总是得到相同的输出，没有副作用</li>\n<li><code>函数组合</code>：将两个或两个以上的函数组合起来以产生一个新函数或进行某种计算的过程</li>\n<li><code>避免状态共享</code>：共享作用域中存在的任何变量、对象或内存空间，或者是在作用域之间传递的对象的属性。共享作用域可以包括全局作用域或闭包作用域。通常，在面向对象编程中，通过向其他对象添加属性，在作用域之间共享对象。</li>\n<li><code>避免可变数据</code>： 不可变对象是指创建后不能修改的对象。相反，可变对象是在创建后可以修改的对象， 可以通过：Object.freeze 进行冻结</li>\n<li><code>避免副作用</code>：副作用是指：除了返回值之外，任何应用程序状态的改变都是可以在被调用函数之外观察到的</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/6844904130796847111\" target=\"_blank\" >见</a></p>\n<h3 id=\"什么是面向对象编程\"><a href=\"#什么是面向对象编程\" class=\"headerlink\" title=\"什么是面向对象编程\"></a>什么是面向对象编程</h3><h3 id=\"什么是面向过程编程\"><a href=\"#什么是面向过程编程\" class=\"headerlink\" title=\"什么是面向过程编程\"></a>什么是面向过程编程</h3><h2 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h2><h3 id=\"type-与-interface-的区别\"><a href=\"#type-与-interface-的区别\" class=\"headerlink\" title=\"type 与 interface 的区别\"></a>type 与 interface 的区别</h3><p><a href=\"https://www.51cto.com/article/705857.html\" target=\"_blank\" >见</a><br><a href=\"https://juejin.cn/post/6844903749501059085\" target=\"_blank\" >见</a></p>\n<h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><ol>\n<li>都可以描述一个对象或者函数</li>\n<li>都允许拓展（extends） interface 继承使用 <code>extends关键字</code> ， type 继承使用 <code>&amp;</code>关键字</li>\n</ol>\n<ul>\n<li><code>interface extends interface</code></li>\n<li><code>interface extends type</code></li>\n<li><code>type extends interface</code></li>\n<li><code>type extends type</code></li>\n</ul>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><ul>\n<li>type 可以声明<code>基本类型别名，联合类型，元组</code>等类型(interface 不可以)</li>\n<li>type 语句中<code>可以使用 typeof 获取实例的 类型进行赋值</code>(interface 不可以)</li>\n<li>interface 能够声明合并 (type 不可以)</li>\n</ul>\n<h4 id=\"描述上：1-都可以描述一个对象或者函数\"><a href=\"#描述上：1-都可以描述一个对象或者函数\" class=\"headerlink\" title=\"描述上：1. 都可以描述一个对象或者函数\"></a>描述上：1. 都可以描述一个对象或者函数</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; interface\ninterface User &#123;\n  name: string\n  age: number\n&#125;\n\ninterface SetUser &#123;\n  (name: string, age: number): void;\n&#125;\n\n&#x2F;&#x2F; type\n\ntype User &#x3D; &#123;\n  name: string\n  age: number\n&#125;;\n\ntype SetUser &#x3D; (name: string, age: number)&#x3D;&gt; void;\n</code></pre>\n\n<h4 id=\"扩展上：-2-都允许拓展（extends\"><a href=\"#扩展上：-2-都允许拓展（extends\" class=\"headerlink\" title=\"扩展上： 2. 都允许拓展（extends\"></a>扩展上： 2. 都允许拓展（extends</h4><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ntype User &#x3D; Name &amp; &#123; age: number &#125;;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; interface extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ninterface User extends Name &#123;\n  age: number;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; type extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ntype User &#x3D; Name &amp; &#123;\n  age: number;\n&#125;;</code></pre>\n\n<h3 id=\"不同点-1\"><a href=\"#不同点-1\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><h4 id=\"1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以\"><a href=\"#1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以\" class=\"headerlink\" title=\"1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)\"></a>1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基本类型别名\ntype Name &#x3D; string;\n\n&#x2F;&#x2F; 联合类型\ninterface Dog &#123;\n  wong();\n&#125;\ninterface Cat &#123;\n  miao();\n&#125;\n\ntype Pet &#x3D; Dog | Cat;\n\n&#x2F;&#x2F; 具体定义数组每个位置的类型\ntype PetList &#x3D; [Dog, Pet];</code></pre>\n\n<h4 id=\"2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以\"><a href=\"#2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以\" class=\"headerlink\" title=\"2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)\"></a>2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 当你想获取一个变量的类型时，使用 typeof\nlet div &#x3D; document.createElement(&quot;div&quot;);\ntype B &#x3D; typeof div;</code></pre>\n\n<p>其他骚操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type StringOrNumber &#x3D; string | number;\ntype Text &#x3D; string | &#123; text: string &#125;;\ntype NameLookup &#x3D; Dictionary&lt;string, Person&gt;;\ntype Callback&lt;T&gt; &#x3D; (data: T) &#x3D;&gt; void;\ntype Pair&lt;T&gt; &#x3D; [T, T];\ntype Coordinates &#x3D; Pair&lt;number&gt;;\ntype Tree&lt;T&gt; &#x3D; T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;\n</code></pre>\n\n<h4 id=\"interface-能够声明合并-type-不行\"><a href=\"#interface-能够声明合并-type-不行\" class=\"headerlink\" title=\"interface 能够声明合并(type 不行)\"></a>interface 能够声明合并(type 不行)</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface User &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface User &#123;\n  sex: string;\n&#125;\n\n&#x2F;*\nUser 接口为 &#123;\n  name: string\n  age: number\n  sex: string\n&#125;\n*&#x2F;</code></pre>\n\n<h2 id=\"Typescript-中-extends-的作用\"><a href=\"#Typescript-中-extends-的作用\" class=\"headerlink\" title=\"Typescript 中 extends 的作用\"></a>Typescript 中 extends 的作用</h2><h3 id=\"1、接口继承\"><a href=\"#1、接口继承\" class=\"headerlink\" title=\"1、接口继承\"></a>1、接口继承</h3><p>可以继承父类接口的方法和属性</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; dog 具有 Animal 的 name 属性。\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;</code></pre>\n\n<h3 id=\"2、普通条件判断\"><a href=\"#2、普通条件判断\" class=\"headerlink\" title=\"2、普通条件判断\"></a>2、普通条件判断</h3><p><code>用来判断一个类型是否可以分配给另外一个类型</code></p>\n<p>A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。<br>换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\ntype bool &#x3D; Animal extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;\ntype bool1 &#x3D; Dog extends Animal ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;</code></pre>\n\n<h3 id=\"3、泛型条件判断\"><a href=\"#3、泛型条件判断\" class=\"headerlink\" title=\"3、泛型条件判断\"></a>3、泛型条件判断</h3><p>对于使用 extends 关键字的条件类型，<code>如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。</code></p>\n<p>分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</p>\n<p>满足两个要点即可适用分配律：</p>\n<p>参数是泛型类型，</p>\n<p>代入参数的是联合类型<br><code>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</code></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Animal&lt;T&gt; &#x3D; T;\ntype Animal1&lt;T&gt; &#x3D; [T];\ntype Dog &#x3D; Animal&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;\ntype Dog1 &#x3D; Animal1&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]\n\ntype A &#x3D; &quot;x&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;\ntype B &#x3D; &quot;x&quot; extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;\ntype C &#x3D; [&quot;x&quot; | &quot;y&quot;] extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;\ntype D &#x3D; &quot;x&quot; | &quot;y&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; D &#x3D; &#39;yes&#39;</code></pre>\n\n<h3 id=\"4、泛型约束\"><a href=\"#4、泛型约束\" class=\"headerlink\" title=\"4、泛型约束\"></a>4、泛型约束</h3><p>在书写泛型时，往往需要对类型参数作一定对限制。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;\n  return obj[key];\n&#125;\n\nconst obj &#x3D; &#123;\n  name: &quot;tom&quot;,\n  age: 12,\n&#125;;\n\ngetInfo(obj, &quot;age&quot;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。</code></pre>\n\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><h3 id=\"聊下-key\"><a href=\"#聊下-key\" class=\"headerlink\" title=\"聊下 key\"></a>聊下 key</h3><h3 id=\"为什么引入-key\"><a href=\"#为什么引入-key\" class=\"headerlink\" title=\"为什么引入 key\"></a>为什么引入 key</h3><p><strong>key 帮助 React 识别出被修改、添加或删除的 item</strong></p>\n<p><a href=\"https://react.docschina.org/docs/reconciliation.html#recursing-on-children\" target=\"_blank\" >深入解析为什么 key 是必须的</a></p>\n<h3 id=\"引入-key-的背景\"><a href=\"#引入-key-的背景\" class=\"headerlink\" title=\"引入 key 的背景\"></a>引入 key 的背景</h3><p>对子节点进行递归</p>\n<p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p>\n<p>在子元素列表末尾新增元素时，更新开销比较小。比如：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n  &lt;li&gt;third&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n\n<p>React 会先匹配两个 <code>&lt;li&gt;first&lt;/li&gt;</code> 对应的树，然后匹配第二个元素 <code>&lt;li&gt;second&lt;/li&gt;</code> 对应的树，最后插入第三个元素的 <code>&lt;li&gt;third&lt;/li&gt;</code> 树。</p>\n<p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;ul&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n\n<p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</p>\n<h3 id=\"key-解决这个问题\"><a href=\"#key-解决这个问题\" class=\"headerlink\" title=\"key 解决这个问题\"></a>key 解决这个问题</h3><p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2014&quot;&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre>\n\n<p>现在 React 知道只有带着 ‘2014’ key 的元素是新元素，带着 ‘2015’ 以及 ‘2016’ key 的元素仅仅移动了。</p>\n<p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;</code></pre>\n\n<p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p>\n<h3 id=\"key-有什么要求\"><a href=\"#key-有什么要求\" class=\"headerlink\" title=\"key 有什么要求\"></a>key 有什么要求</h3><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p>\n<h3 id=\"通常情况-key-不会用-index\"><a href=\"#通常情况-key-不会用-index\" class=\"headerlink\" title=\"通常情况 key 不会用 index\"></a>通常情况 key 不会用 index</h3><p>原因：</p>\n<ol>\n<li><p>使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。</p>\n</li>\n<li><p>由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，</p>\n</li>\n</ol>\n<h3 id=\"什么时候使用-key\"><a href=\"#什么时候使用-key\" class=\"headerlink\" title=\"什么时候使用 key\"></a>什么时候使用 key</h3><ol>\n<li>子元素列表时候需要用 key</li>\n<li>同级元素比如两个按钮，在使用三目运算符进行条件处理时候，也需要加 key，不加会出现，按钮事件被错误触发的现象，（这是由于 React 可中断渲染和合成事件共同作用引起的）</li>\n</ol>\n<h3 id=\"key-在源码单节点、多节点中的\"><a href=\"#key-在源码单节点、多节点中的\" class=\"headerlink\" title=\"key 在源码单节点、多节点中的\"></a>key 在源码单节点、多节点中的</h3><h3 id=\"diff-单节点、多节点\"><a href=\"#diff-单节点、多节点\" class=\"headerlink\" title=\"diff [单节点、多节点]\"></a>diff [单节点、多节点]</h3><h3 id=\"hooks-产生的原因\"><a href=\"#hooks-产生的原因\" class=\"headerlink\" title=\"hooks 产生的原因\"></a>hooks 产生的原因</h3><p>Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题</p>\n<h3 id=\"在组件之间复用状态逻辑很难\"><a href=\"#在组件之间复用状态逻辑很难\" class=\"headerlink\" title=\"在组件之间复用状态逻辑很难\"></a><code>在组件之间复用状态逻辑很难</code></h3><h3 id=\"复杂组件变得难以理解\"><a href=\"#复杂组件变得难以理解\" class=\"headerlink\" title=\"复杂组件变得难以理解\"></a><code>复杂组件变得难以理解</code></h3><p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。）</p>\n<h3 id=\"难以理解的-class\"><a href=\"#难以理解的-class\" class=\"headerlink\" title=\"难以理解的 class\"></a><code>难以理解的 class</code></h3><p>(除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。</p>\n<p>为了解决这些问题，</p>\n<ol>\n<li><code>Hook 使你在非 class 的情况下可以使用更多的 React 特性</code>。</li>\n<li>从概念上讲，<code>React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则</code>。</li>\n<li>Hook 提供了问题的解决方案，<code>无需学习复杂的函数式或响应式编程技术</code>。</li>\n</ol>\n<h3 id=\"useEffect-执行特点\"><a href=\"#useEffect-执行特点\" class=\"headerlink\" title=\"useEffect 执行特点\"></a>useEffect 执行特点</h3><h4 id=\"1-useEffect-做了什么？\"><a href=\"#1-useEffect-做了什么？\" class=\"headerlink\" title=\"1. useEffect 做了什么？\"></a>1. useEffect 做了什么？</h4><p>(<br>通过使用这个 Hook，你可以<code>告诉 React 组件需要在渲染后执行某些操作</code>。React 会保存你传递的函数（我们将它称之为 “effect”），<code>并且在执行 DOM 更新之后调用它</code>。<br>)</p>\n<h4 id=\"2-为什么在组件内部调用-useEffect？\"><a href=\"#2-为什么在组件内部调用-useEffect？\" class=\"headerlink\" title=\"2. 为什么在组件内部调用 useEffect？\"></a>2. 为什么在组件内部调用 useEffect？</h4><p>(<br>将 useEffect 放在组件内部,让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。<br>)</p>\n<h4 id=\"3-useEffect-会在每次渲染后都执行吗？\"><a href=\"#3-useEffect-会在每次渲染后都执行吗？\" class=\"headerlink\" title=\"3. useEffect 会在每次渲染后都执行吗？\"></a>3. useEffect 会在每次渲染后都执行吗？</h4><p>(<br>是的，<code>默认情况下，它在第一次渲染之后和每次更新之后都会执行</code>。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。<code>React 保证了每次运行 effect 的同时，DOM 都已经更新完毕</code>。<br>)</p>\n<h4 id=\"4-传递给-useEffect-的函数在每次渲染中都会有所不同\"><a href=\"#4-传递给-useEffect-的函数在每次渲染中都会有所不同\" class=\"headerlink\" title=\"4. 传递给 useEffect 的函数在每次渲染中都会有所不同\"></a>4. 传递给 useEffect 的函数在每次渲染中都会有所不同</h4><p>(<br>经验丰富的 JavaScript 开发人员可能会注意到，<code>传递给 useEffect 的函数在每次渲染中都会有所不同</code>，这是刻意为之的。<code>事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因</code>。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。<br>)</p>\n<h4 id=\"5-effect-异步执行\"><a href=\"#5-effect-异步执行\" class=\"headerlink\" title=\"5. effect 异步执行\"></a>5. effect 异步执行</h4><p>不需要同步地执行, 如果需要同步用 <code>useLayoutEffect</code></p>\n<h4 id=\"6-为什么要在-effect-中返回一个函数？\"><a href=\"#6-为什么要在-effect-中返回一个函数？\" class=\"headerlink\" title=\"6. 为什么要在 effect 中返回一个函数？\"></a>6. 为什么要在 effect 中返回一个函数？</h4><p>(<br>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。<br>)</p>\n<h4 id=\"7-React-何时清除-effect？\"><a href=\"#7-React-何时清除-effect？\" class=\"headerlink\" title=\"7. React 何时清除 effect？\"></a>7. React 何时清除 effect？</h4><p>(<br><code>React 会在组件卸载的时候执行清除操作</code>。正如之前学到的，effect 在每次渲染的时候都会执行。<code>这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</code><br>)</p>\n<h3 id=\"useEffect-使用特点上？\"><a href=\"#useEffect-使用特点上？\" class=\"headerlink\" title=\"useEffect 使用特点上？\"></a>useEffect 使用特点上？</h3><ul>\n<li><p>提示: 使用多个 Effect 实现关注点分离</p>\n</li>\n<li><p>解释：为什么每次更新的时候都要运行 Effect(<code>此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug</code>。)</p>\n</li>\n<li><p>提示: 通过跳过 Effect 进行性能优化（<code>使用第二参数，未来版本，可能会在构建时自动添加第二个参数。</code>）</p>\n</li>\n</ul>\n<h3 id=\"useEffect-实现原理\"><a href=\"#useEffect-实现原理\" class=\"headerlink\" title=\"useEffect 实现原理\"></a>useEffect 实现原理</h3><h3 id=\"Hook-使用规则\"><a href=\"#Hook-使用规则\" class=\"headerlink\" title=\"Hook 使用规则\"></a>Hook 使用规则</h3><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>\n<ol>\n<li><p>只能<code>在函数最外层调用 Hook</code>。<code>不要在循环</code>、<code>条件判断</code>或者<code>子函数中调用</code>。</p>\n</li>\n<li><p><code>只能在 React 的函数组件中调用 Hook</code>。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）</p>\n</li>\n</ol>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><ol>\n<li><p>挂载：constructor()、static getDerivedStateFromProps()、render()、componentDidMount()</p>\n</li>\n<li><p>更新：static getDerivedStateFromProps()、shouldComponentUpdate()、render()、getSnapshotBeforeUpdate()、componentDidUpdate()</p>\n</li>\n<li><p>错误处理：static getDerivedStateFromError()、componentDidCatch()</p>\n</li>\n<li><p>卸载：componentWillUnmount()</p>\n</li>\n</ol>\n<p><strong>react 生命周期函数：</strong></p>\n<ol>\n<li><p>constructor()：组件构造函数，在组件挂载之前调用；<code>仅用于初始化内部 state 以及为事件处理函数绑定实例</code>；</p>\n</li>\n<li><p><code>static getDerivedStateFromProps()</code>：会在调用 render 方法之前调用，并且<code>在初始挂载及后续更新时都会被调用</code>，此方法适用于 state 的值在任何时候都取决于 props；</p>\n</li>\n<li><p>render()：是 class 组件中唯一必须实现的方法；</p>\n</li>\n<li><p>componentDidMount：会在组件挂载后（插入 DOM 树中）立即调用；</p>\n</li>\n<li><p>shouldComponentUpdate()：根据该函数的返回值，来确定组件是否重新渲染；</p>\n</li>\n<li><p>getSnapshotBeforeUpdate()：在最近一次渲染输出（提交到 DOM 节点）之前调用；<code>此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()</code>；</p>\n</li>\n<li><p>componentDidUpdate()：会在更新后会被立即调用，首次渲染不会执行此方法；</p>\n</li>\n<li><p>componentWillUnmount()：会在组件卸载及销毁之前直接调用；</p>\n</li>\n<li><p><code>static getDerivedStateFromError()</code>：此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state；它会在渲染阶段调用，因此不允许出现副作用</p>\n</li>\n<li><p><code>componentDidCatch()</code>：此生命周期在后代组件抛出错误后被调用，会在“提交”阶段被调用，因此允许执行副作用。</p>\n</li>\n</ol>\n<h3 id=\"父子组件生命周期函数执行顺序：\"><a href=\"#父子组件生命周期函数执行顺序：\" class=\"headerlink\" title=\"父子组件生命周期函数执行顺序：\"></a>父子组件生命周期函数执行顺序：</h3><p>父子组件生命周期函数执行顺序：</p>\n<p><strong>类组件</strong></p>\n<p><strong>进入页面：</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">parent-constructor -&gt;\nparent-getDerivedStateFromProps -&gt;\nparent-render -&gt;\n\nchild-constructor -&gt;\nchild-getDerivedStateFromProps -&gt;\nchild-render -&gt;\nchild-componentDidMount -&gt;\n\nparent-componentDidMount\n&#x2F;&#x2F; （子组件先挂载，父组件后挂载）</code></pre>\n\n<p><strong>更新页面：</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">parent-getDerivedStateFromProps -&gt;\nparent-shouldComponentUpdate -&gt;\nparent-render -&gt;\n\nchild-getDerivedStateFromProps -&gt;\nchild-shouldComponentUpdate -&gt;\nchild-render -&gt;\nchild-componentDidUpdate -&gt;\n\nparent-componentDidUpdate\n&#x2F;&#x2F; （子组件先更新，父组件后更新）</code></pre>\n\n<p><strong>销毁页面：</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">parent-componentWillUnmount -&gt;\nchild-componentWillUnmount\n\n&#x2F;&#x2F;（父组件先 willUnmount，子组件后 willlUnmount）</code></pre>\n\n<p><a href=\"https://www.cnblogs.com/foreveronlymiss/p/15387022.html\" target=\"_blank\" >见</a></p>\n<p><strong>函数组件</strong></p>\n<p>子组件先于父组件</p>\n<p><a href=\"https://blog.csdn.net/qq_35770417/article/details/120706178\" target=\"_blank\" >见</a></p>\n<h3 id=\"严格模式-StrictMode\"><a href=\"#严格模式-StrictMode\" class=\"headerlink\" title=\"严格模式 StrictMode\"></a>严格模式 StrictMode</h3><ol>\n<li>环境： 严格模式检查<code>仅在开发模式下运行</code>；它们不会影响生产构建</li>\n<li>范围：<code>它为其后代元素触发额外的检查和警告</code></li>\n<li>作用：<code>突出显示应用程序中潜在问题的工具</code>，不会渲染任何可见的 UI</li>\n</ol>\n<p>作用具体表现：</p>\n<ol>\n<li>识别<code>不安全的生命周期</code>（使用了第三方库，很难确保它们不使用这些生命周期方法）</li>\n<li>使用过时<code>字符串 ref API</code>、 <code>context API</code></li>\n<li>使用<code>废弃的 findDOMNode 方法</code>的警告</li>\n<li><code>检测意外的副作用</code></li>\n<li>确保可复用状态（在未来，我们希望增加一个功能，允许 React 在保留 state 的同时对 UI 进行增删）</li>\n</ol>\n<h3 id=\"协调\"><a href=\"#协调\" class=\"headerlink\" title=\"协调\"></a>协调</h3><p>当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。</p>\n<h3 id=\"合成事件的捕获和冒泡如何实现\"><a href=\"#合成事件的捕获和冒泡如何实现\" class=\"headerlink\" title=\"合成事件的捕获和冒泡如何实现\"></a>合成事件的捕获和冒泡如何实现</h3><p>数组正反序遍历</p>\n<h3 id=\"父子组件合成事件的捕获和冒泡执行顺序\"><a href=\"#父子组件合成事件的捕获和冒泡执行顺序\" class=\"headerlink\" title=\"父子组件合成事件的捕获和冒泡执行顺序\"></a>父子组件合成事件的捕获和冒泡执行顺序</h3><p>V17 之前，<code>合成事件和原生事件的执行顺序与冒泡/捕获模式无关</code>,</p>\n<p><code>原生事件恒早于合成事件</code></p>\n<p>V17 后，<code>合成事件和原生事件的执行顺序与冒泡/捕获模式相关</code>，</p>\n<ol>\n<li><code>捕获模式，合成事件早于原生事件</code>。</li>\n<li><code>冒泡模式，原生事件早于合成事件</code>，</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; V17.0.2 document 原生事件 &gt; 合成事件（父 -&gt; 子） &gt; 原生事件（父 -&gt; 子）\n&#x2F;&#x2F; 原生事件：document DOM 事件监听！\n&#x2F;&#x2F; React 事件：父元素事件监听！\n&#x2F;&#x2F; React 事件：子元素事件监听！\n&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！\n&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; V16.14.0 document 原生事件 &gt; 原生事件（父 -&gt; 子）&gt; 合成事件（父 -&gt; 子）\n&#x2F;&#x2F; 原生事件：document DOM 事件监听！\n&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！\n&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！\n&#x2F;&#x2F; React 事件：父元素事件监听！\n&#x2F;&#x2F; React 事件：子元素事件监听！</code></pre>\n\n<p>作者：活抓一只小机灵<br>链接：<a href=\"https://juejin.cn/post/7005129812981317668\">https://juejin.cn/post/7005129812981317668</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h3><h3 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h3><p>是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口。</p>\n<h3 id=\"要使用浏览器的底层事件？\"><a href=\"#要使用浏览器的底层事件？\" class=\"headerlink\" title=\"要使用浏览器的底层事件？\"></a>要使用浏览器的底层事件？</h3><p>需要使用 nativeEvent 属性来获取</p>\n<h3 id=\"变化？\"><a href=\"#变化？\" class=\"headerlink\" title=\"变化？\"></a>变化？</h3><p>从 v17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中。</p>\n<h3 id=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"><a href=\"#在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\" class=\"headerlink\" title=\"在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？\"></a>在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</h3><p>如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。</p>\n<h3 id=\"事件委托的变更\"><a href=\"#事件委托的变更\" class=\"headerlink\" title=\"事件委托的变更\"></a>事件委托的变更</h3><p>React v17 中，React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中<br>经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。</p>\n<h3 id=\"全新的-JSX-转换\"><a href=\"#全新的-JSX-转换\" class=\"headerlink\" title=\"全新的 JSX 转换\"></a>全新的 JSX 转换</h3><p>此时源代码无需引入 React 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）</p>\n<p>此变化与所有现有 JSX 代码兼容，所以你无需修改组件。如果你对此感兴趣，你可以查看 RFC 了解全新转换工作的具体细节。</p>\n<p>特点：</p>\n<ul>\n<li>新的 JSX 转换不依赖 React 环境</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>不需要引入 React 使用全新的转换，你可以单独使用 JSX 而无需引入 React。</li>\n<li>改善 bundle 根据你的配置，JSX 的编译输出可能会略微改善 bundle 的大小。</li>\n<li>以备未来之需 它将减少你需要学习 React 概念的数量，以备未来之需。</li>\n</ul>\n<h3 id=\"副作用清理时间\"><a href=\"#副作用清理时间\" class=\"headerlink\" title=\"副作用清理时间\"></a>副作用清理时间</h3><ul>\n<li>React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。</li>\n<li>React 16 只对组件内的 effect 保证这种顺序。</li>\n</ul>\n<h3 id=\"React17-重大更改\"><a href=\"#React17-重大更改\" class=\"headerlink\" title=\"React17 重大更改\"></a>React17 重大更改</h3><ol>\n<li><code>更改事件委托</code></li>\n<li><code>对标浏览器，对事件系统进行小改</code></li>\n<li><code>去除事件池</code> 不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水 （因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。）</li>\n<li><code>副作用清理时间</code> （- React 17 将<code>在运行任何新副作用之前执行所有副作用的清理函数</code>（针对所有组件）。，- React 16 只对组件内的 effect 保证这种顺序。）</li>\n<li><code>返回一致的 undefined 错误</code>，（算是改 bug 了，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错）</li>\n<li><code>原生组件栈</code> （生产环境提示更友好。在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。<em>React 实现这一点的方式有点非常规</em> 。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。因此，<em>当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息</em> ）</li>\n<li><code>移除私有导出</code>（与 react 关联不是很大的部分被移出）</li>\n</ol>\n<h3 id=\"react18-新特性\"><a href=\"#react18-新特性\" class=\"headerlink\" title=\"react18 新特性\"></a>react18 新特性</h3><ol>\n<li>3 个新特性：<ol>\n<li>循序渐进实现并发模式：由于并发模式可能带来破坏，所以 react18 的并发模式可选</li>\n<li>自动批处理: 之前需要使用 <code>ReactDOM.unstable_batchedUpdates</code>, 现在： 超时、promise、本机事件处理程序、任何其他事件被批处理</li>\n<li>内置 <code>React.lazy + Suspense</code></li>\n<li>过渡拆分（紧急更新、非紧急更新）、</li>\n<li>严格模式模拟卸载和重新挂载</li>\n</ol>\n</li>\n<li>2 个新的<code>渲染api</code>: <code>createRoot</code> 和 <code>hydrateRoot</code></li>\n<li>新钩子：<ol>\n<li><code>useId</code>: 添加 useId 以生成唯一 ID</li>\n<li><code>useTransition、useDeferredValue</code>: 添加 useTranption 和 useDeferredValue 以将紧急更新与转换分开</li>\n<li><code>useInsertionEffect</code>: 为 CSS-in-JS 库添加 useInsertionEffects</li>\n<li><code>useSyncExternalStore</code>: 添加 useSyncExternalStore 以帮助外部存储库与 React 集成。</li>\n<li><code>StrictMode</code>: 使<code>&lt;StrictMode&gt;</code>重新运行效果以检查可恢复状态。</li>\n<li></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><h3 id=\"git-rebase-与-git-merge\"><a href=\"#git-rebase-与-git-merge\" class=\"headerlink\" title=\"git rebase 与 git merge\"></a>git rebase 与 git merge</h3><p><a href=\"https://blog.csdn.net/small_white_123/article/details/121563248\" target=\"_blank\" >见</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202301281645578.webp\" />\n\n<p>merge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）<br>rebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，</p>\n<p>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>\n<h3 id=\"变基原理：\"><a href=\"#变基原理：\" class=\"headerlink\" title=\"变基原理：\"></a>变基原理：</h3><ol>\n<li>是首先找到这两个分支的最近共同祖先 C2</li>\n<li>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3</li>\n<li>最后以此将之前另存为临时文件的修改依序应用</li>\n</ol>\n<h3 id=\"什么时候用哪个？\"><a href=\"#什么时候用哪个？\" class=\"headerlink\" title=\"什么时候用哪个？\"></a>什么时候用哪个？</h3><p>这本身存在分歧，主要看团队需要，</p>\n<ul>\n<li>如果团队需要历史记录保留，便于追踪，可以使用 merge ,</li>\n<li>如果不希望保留过多的过程，只关注结果那么可以用 rebase.无论用哪个，为了避免 rebase 的坑， 需要遵循以下原则：</li>\n</ul>\n<h3 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h3><p>总的原则是，<code>只对尚未推送或分享给别人的本地修改执行变基操作清理历史</code>， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ git rebase --onto master server client</code></pre>\n\n<p>你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#:~:text=Figure%2039.%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E9%87%8C%E5%86%8D%E5%88%86%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\ngit rebase -i HEAD~4\n# s 命令压缩</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171547417.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209171551269.png\" />\n\n<p><a href=\"https://www.cnblogs.com/lookphp/p/5799533.html\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://backlog.com/git-tutorial/cn/stepup/stepup7_7.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"🤔\"><a href=\"#🤔\" class=\"headerlink\" title=\"🤔\"></a>🤔</h3><img src=\"http://t-blog-images.aijs.top/img/202209181100864.png\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202209181059249.png\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~3\nThe previous cherry-pick is now empty, possibly due to conflict resolution.\nIf you wish to commit it anyway, use:\n\n    git commit --allow-empty\n\nOtherwise, please use &#39;git reset&#39;\ninteractive rebase in progress; onto e1a52d3\nLast commands done (2 commands done):\n   pick 78c1fd9 应对github bug s 压缩\n   pick 8935665 应对github bug\nNext commands to do (4 remaining commands):\n   pick 421821a update\n   pick 4eff6a3 update\nYou are currently rebasing branch &#39;main&#39; on &#39;e1a52d3&#39;.\n\nnothing to commit, working tree clean\nCould not apply 8935665... 应对github bug\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~2\n\nIt seems that there is already a rebase-merge directory, and\nI wonder if you are in the middle of another rebase.  If that is the\ncase, please try\n        git rebase (--continue | --abort | --skip)\nIf that is not the case, please\n        rm -fr &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;.git&#x2F;rebase-merge&quot;\nand run me again.  I am stopping in case you still have something\nvaluable there.\n$ git rebase --abort</code></pre>\n\n<h2 id=\"掘金小猪课堂\"><a href=\"#掘金小猪课堂\" class=\"headerlink\" title=\"掘金小猪课堂\"></a>掘金小猪课堂</h2><h3 id=\"for…in-和-for…of-的区别\"><a href=\"#for…in-和-for…of-的区别\" class=\"headerlink\" title=\"for…in 和 for…of 的区别\"></a>for…in 和 for…of 的区别</h3><p>for…in 可以遍历对象和数组，for…of 不能遍历对象<br>for…in <strong>循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键</strong><br>for…in 遍历的索引为字符串类型<br>for..of 适用遍历数&#x2F;数组对象&#x2F;字符串&#x2F;map&#x2F;set 等拥有迭代器对象的集合，但是不能遍历对象<br>for…of 与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句<br>具有迭代器对象才可以使用 for…of</p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7002484014414037000\">https://juejin.cn/post/7002484014414037000</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"JavaScript-中可迭代对象\"><a href=\"#JavaScript-中可迭代对象\" class=\"headerlink\" title=\"JavaScript 中可迭代对象\"></a>JavaScript 中可迭代对象</h3><p>String<br>Array</p>\n<p>Set<br>Map</p>\n<p>NodeList<br>Arguments</p>\n<h3 id=\"几种获取-URL-参数\"><a href=\"#几种获取-URL-参数\" class=\"headerlink\" title=\"几种获取 URL 参数\"></a><a href=\"https://juejin.cn/post/7075305529903415304\" target=\"_blank\" >几种获取 URL 参数</a></h3><ol>\n<li>通过正则匹配的方式</li>\n<li>利用 split 方法分割法</li>\n<li>使用 URLSearchParams 方法</li>\n<li>利用 a 标签内置方法</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; - 通过正则匹配的方式\n&lt;script&gt;\n  &#x2F;&#x2F; 利用正则表达式\n  let url &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&quot;\n  &#x2F;&#x2F; &#x2F;&#x2F; 返回参数对象\n  function queryURLParams(url) &#123;\n    let pattern &#x3D; &#x2F;(\\w+)&#x3D;(\\w+)&#x2F;ig; &#x2F;&#x2F;定义正则表达式\n    let parames &#x3D; &#123;&#125;; &#x2F;&#x2F; 定义参数对象\n    url.replace(pattern, ($, $1, $2) &#x3D;&gt; &#123;\n      parames[$1] &#x3D; $2;\n    &#125;);\n    return parames;\n  &#125;\n  console.log(queryURLParams(url))\n&lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; - 使用 URLSearchParams 方法\n&lt;script&gt;\n  let URL &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&quot;\n  function queryURLParams(URL) &#123;\n    let url &#x3D; URL.split(&quot;?&quot;)[1];\n    const urlSearchParams &#x3D; new URLSearchParams(url);\n    const params &#x3D; Object.fromEntries(urlSearchParams.entries());\n    return params\n  &#125;\n  console.log(queryURLParams(URL))\n&lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; 作者：小猪课堂\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7075305529903415304\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<h3 id=\"clientHeight、offsetHeight、scrollHeight-的区别\"><a href=\"#clientHeight、offsetHeight、scrollHeight-的区别\" class=\"headerlink\" title=\"clientHeight、offsetHeight、scrollHeight 的区别\"></a>clientHeight、offsetHeight、scrollHeight 的区别</h3><p>三个属性虽然都很类似，但是每一个又有一些不一样的地方，总结起来就下面三点：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;*内容*&#x2F; clientheight &#x3D; 内容高度 + padding;\n&#x2F;*占据空间*&#x2F; offsetHeight &#x3D; 内容高度 + padding + border;\n&#x2F;*滚动*&#x2F; scrollHeight &#x3D; 内容实际尺寸 + padding;\n\n&#x2F;&#x2F; 作者：小猪课堂\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7085317886046126087\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<h3 id=\"childNodes-和-children-有什么区别？\"><a href=\"#childNodes-和-children-有什么区别？\" class=\"headerlink\" title=\"childNodes 和 children 有什么区别？\"></a>childNodes 和 children 有什么区别？</h3><p><strong>Node -&gt; childNodes</strong></p>\n<p>在 DOM 树中，所有的节点都是 Node，包括 Element，也就是说 Node 包含了 <code>HTML 元素标签</code>、<code>text</code>、<code>以及注释</code>等等内容，它是所有 DOM 的基类。</p>\n<p><strong>Element -&gt; HTMLCollection</strong></p>\n<p>在 DOM 树中，Element 只包含 HTML 元素标签。</p>\n<p><strong>关系</strong></p>\n<p>childNodes 属于 NodeList 集合，它会返回所有的子节点，包括文本、标签、注释等等。</p>\n<p>children 数据 HTMLCollection 集合，它会返回所有 HTML 元素节点。</p>\n<p>childNodes 包含 children。</p>\n<h3 id=\"Ajax、Fetch、Axios-三者的区别\"><a href=\"#Ajax、Fetch、Axios-三者的区别\" class=\"headerlink\" title=\"Ajax、Fetch、Axios 三者的区别\"></a>Ajax、Fetch、Axios 三者的区别</h3><p><strong>Ajax</strong></p>\n<p><em>全称：</em> Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。<br><em>特点</em> 局部刷新页面，无需重载整个页面。<br><em>简单来说</em> Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  function ajax(url) &#123;\n    &#x2F;&#x2F; 实例\n    const xhr &#x3D; new XMLHttpRequest();\n    &#x2F;&#x2F; 方法\n    xhr.open(&quot;get&quot;, url, false);\n    &#x2F;&#x2F; 监听\n    xhr.onreadystatechange &#x3D; function () &#123;\n      &#x2F;&#x2F; 异步回调函数\n      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          console.info(&quot;响应结果&quot;, xhr.response)\n        &#125;\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 发送\n    xhr.send(null);\n  &#125;\n\n  ajax(&#39;https:&#x2F;&#x2F;smallpig.site&#x2F;api&#x2F;category&#x2F;getCategory&#39;)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>Fetch</strong></p>\n<p><em>注意：</em>不应该和 Ajax 做比较, 应该和 <code>XMLHttpRequest</code>做比较， Ajax 一个是思想，Fetch 一个是真实存在的 API</p>\n<p><em>特点</em></p>\n<ol>\n<li>Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象</li>\n<li>内置的 API，使用上更简单</li>\n<li>使用 promise, 不使用回调</li>\n<li>数据流对象处理数据<code>常用res.json()转化成json数据</code></li>\n</ol>\n<p><strong>Axios</strong></p>\n<p><em>Axios</em>是一个基于 promise 和 XHR 封装的网络请求库</p>\n<p><em>特点：</em></p>\n<ol>\n<li>从浏览器中创建 XMLHttpRequests，从 node.js 创建 http 请求</li>\n<li>支持 Promise API</li>\n<li>能够拦截请求和响应，转换请求数据和响应数据</li>\n<li>具备 <code>取消请求，自动转换 JSON 数据，客户端支持防御 XSRF</code> 的特点</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/202210171747226.webp\" />\n\n<h3 id=\"判断两个对象是否相等\"><a href=\"#判断两个对象是否相等\" class=\"headerlink\" title=\"判断两个对象是否相等\"></a>判断两个对象是否相等</h3><h3 id=\"将类数组转为数组\"><a href=\"#将类数组转为数组\" class=\"headerlink\" title=\"将类数组转为数组\"></a>将类数组转为数组</h3><p><em>类数组特点：</em></p>\n<ol>\n<li>类数组是一个对象， 带有 length 属性</li>\n<li>没有数组方法，即不可调用数组的原型方法</li>\n</ol>\n<p><em>类数组：</em></p>\n<ol>\n<li>arguments</li>\n<li>HTMLCollection</li>\n<li>NodeList</li>\n</ol>\n<p><em>实现方案</em></p>\n<ol>\n<li>Array.from ES6 提供的方法，只能实现浅拷贝</li>\n<li>扩展运算符 不能使用在非迭代对象上</li>\n<li>数组 slice 方法 在不改变原数组的情况下返回数组中的某些元素并形成新的数组。</li>\n</ol>\n<h3 id=\"判断数据类型\"><a href=\"#判断数据类型\" class=\"headerlink\" title=\"判断数据类型\"></a>判断数据类型</h3><ol>\n<li><code>typeof</code> 能判断基本数据类型，不能判断引用数据类型</li>\n<li><code>instanceof</code> 可以判断引用数据类型, 不能判断基本数据类型</li>\n</ol>\n<p>虽然上面两个结合可以处理，但是过于复杂</p>\n<p>每个对象都有一个  toString()  方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()  方法被每个  Object  对象继承。</p>\n<p><code>如果此方法在自定义对象中未被覆盖，toString()  返回  &quot;[object type]&quot;，其中  type  是对象的类型</code></p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7089322067677413412\">https://juejin.cn/post/7089322067677413412</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  function getType(data) &#123;\n    let originType &#x3D; Object.prototype.toString.call(data); &#x2F;&#x2F; 获取内部属性值\n    let index &#x3D; originType.indexOf(&#39; &#39;); &#x2F;&#x2F; 以空格分割\n    let type &#x3D; originType.slice(index + 1, -1); &#x2F;&#x2F; 截取 [object Number]\n    return type.toLowerCase();\n  &#125;\n  console.info(getType(&quot;小猪课堂&quot;)); &#x2F;&#x2F; string\n  console.info(getType(123)); &#x2F;&#x2F; number\n  console.info(getType(true)); &#x2F;&#x2F; boolean\n  console.info(getType(null)); &#x2F;&#x2F; null\n  console.info(getType(undefined)); &#x2F;&#x2F; undefined\n  console.info(getType(&#123; name: &quot;小猪课堂&quot; &#125;)); &#x2F;&#x2F; object\n  console.info(getType([1,3,2])); &#x2F;&#x2F; array\n  console.info(getType(Promise.resolve())); &#x2F;&#x2F; promise\n  console.info(getType(new Set())); &#x2F;&#x2F; set\n  console.info(getType(new WeakMap())); &#x2F;&#x2F; weakmap\n  console.info(getType(new Date())); &#x2F;&#x2F; date\n  console.info(getType(() &#x3D;&gt; &#123;&#125;)); &#x2F;&#x2F; function\n  console.info(getType(new Map)); &#x2F;&#x2F; map\n  console.info(getType(BigInt(100))); &#x2F;&#x2F; bigint\n  console.info(getType(new RegExp(&#39;&#39;))); &#x2F;&#x2F; regexp\n  console.info(getType((Symbol()))); &#x2F;&#x2F; symbol\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<h3 id=\"session、cookie、token-的区别？\"><a href=\"#session、cookie、token-的区别？\" class=\"headerlink\" title=\"session、cookie、token 的区别？\"></a>session、cookie、token 的区别？</h3><p>1.为什么会有它们？</p>\n<p><strong>无状态</strong><br>我们都知道 HTTP 协议是无状态的，所谓的无状态就是客户端每次想要与服务端通信，都必须重新与服务端链接，意味着请求一次客户端和服务端就连接一次，下一次请求与上一次请求是没有关系的。</p>\n<p><strong>区分用户</strong><br>这种无状态的方式就会存在一个问题：如何判断两次请求的是同一个人？就好比用户在页面 A 发起请求获取个人信息，然后在另一个页面同样发起请求获取个人信息，我们如何确定这俩个请求是同一个人发的呢？</p>\n<p>为了解决这种问题，我们就迫切需要一种方式知道发起请求的客户端是谁？此时，cookie、token、session 就出现了，它们就可以解决客户端标识的问题，在扩大一点就是解决权限问题。</p>\n<p>它们就好比让每个客户端或者说登录用户有了自己的身份证，我们可以通过这个身份证确定发请求的是谁！</p>\n<p>作者：小猪课堂<br>链接：<a href=\"https://juejin.cn/post/7090503270447185951\">https://juejin.cn/post/7090503270447185951</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>cookie 的缺点：</p>\n<ul>\n<li>增加请求体积，浪费性能，因为每次请求都会携带 cookie。</li>\n<li>增加服务端资源消耗，因为每个客户端连接进来都需要生成 session，会占用服务端资源的。</li>\n<li>容易遭受 CSRF 攻击，即跨站域请求伪造。</li>\n</ul>\n<h3 id=\"new-做了哪些操作？手写一个-new-方法！\"><a href=\"#new-做了哪些操作？手写一个-new-方法！\" class=\"headerlink\" title=\"new 做了哪些操作？手写一个 new 方法！\"></a>new 做了哪些操作？手写一个 new 方法！</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  &#x2F;&#x2F; 定义构造函数\n  function Person(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n\n\n    return this.name + &#39;:&#39; + this.age\n  &#125;\n  &#x2F;&#x2F; 定义原型方法\n  Person.prototype.say &#x3D; function () &#123;\n    console.log(&quot;你好：&quot;, this.name)\n  &#125;\n\n\n  &#x2F;&#x2F; 手动实现new方法\n  function myNew(constructor) &#123;\n    if (typeof constructor !&#x3D;&#x3D; &quot;function&quot;) &#123;\n      throw &quot;myNew方法的第一个参数必须是一个方法&quot;;\n    &#125;\n\n\n    &#x2F;&#x2F; 基于constructor的原型创建一个全新的对象\n    let newObj &#x3D; Object.create(constructor.prototype);\n\n\n    &#x2F;&#x2F; 获取传入的参数\n    let args &#x3D; Array.from(arguments).slice(1);\n\n\n    &#x2F;&#x2F; 执行constructor函数，获取结果，并将属性添加到新对象newObj上\n    let result &#x3D; constructor.apply(newObj, args); &#x2F;&#x2F; 将this指向newObj\n\n\n    &#x2F;&#x2F; 判断result类型，如果是object或者function类型，则直接返回结果\n    let originType &#x3D; Object.prototype.toString.call(result); &#x2F;&#x2F; 获取内部属性值\n    let isObject &#x3D; originType &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;;\n    let isFunction &#x3D; originType &#x3D;&#x3D;&#x3D; &#39;[object Function]&#39;;\n    if (isObject || isFunction) &#123;\n      return result;\n    &#125; else &#123;\n      &#x2F;&#x2F; 返回新对象\n      return newObj;\n    &#125;\n  &#125;\n\n\n  let obj &#x3D; myNew(Person, &#39;小猪课堂&#39;, 26);\n  console.log(obj);\n  obj.say();\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"跨标签页的通讯方式有哪些\"><a href=\"#跨标签页的通讯方式有哪些\" class=\"headerlink\" title=\"跨标签页的通讯方式有哪些\"></a>跨标签页的通讯方式有哪些</h2><h3 id=\"为什么需要跨标签页通信\"><a href=\"#为什么需要跨标签页通信\" class=\"headerlink\" title=\"为什么需要跨标签页通信\"></a>为什么需要跨标签页通信</h3><p>一个标签页的数据，要同步给另一个标签页</p>\n<h3 id=\"列举\"><a href=\"#列举\" class=\"headerlink\" title=\"列举\"></a>列举</h3><h4 id=\"同源\"><a href=\"#同源\" class=\"headerlink\" title=\"同源\"></a>同源</h4><ol>\n<li><code>广播模式：</code>Broadcast Channel &#x2F; LocalStorage + StorageEvent &#x2F; Service Worker &#x2F;</li>\n<li><code>存储模式：</code>Shared Worker &#x2F; IndexedDB &#x2F; cookie</li>\n<li><code>传递模式：</code>window.open + window.opener <code>有局限性：只有从一个 tab 打开新 tab,新 tab 才可以拿到之前 tab 的引用</code></li>\n<li><code>基于服务端：</code>Websocket &#x2F; Comet &#x2F; SSE 等</li>\n<li><code>visibilitychange</code> 监听 tab 展示</li>\n</ol>\n<h4 id=\"非同源：\"><a href=\"#非同源：\" class=\"headerlink\" title=\"非同源：\"></a>非同源：</h4><ol>\n<li><code>可以使用一个用户不可见的 iframe 作为“桥”。</code></li>\n<li><code>由于 iframe 与父页面间， 通过指定 origin 来忽略同源限制</code>，<code>因此可以在每个页面中嵌入一个 iframe （例如：http://sample.com/bridge.html），而这些 iframe 由于使用的是一个 url，因此属于同源页面</code>，其通信方式可以复用上面第一部分提到的各种方式</li>\n</ol>\n<p>作者：AlienZHOU<br>链接：<a href=\"https://juejin.cn/post/6844903811232825357\">https://juejin.cn/post/6844903811232825357</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API\" target=\"_blank\" >Broadcast_Channel_API</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Page_Visibility_API\" target=\"_blank\" >Page_Visibility_API</a></li>\n<li><a href=\"https://juejin.cn/post/6844903811232825357\" target=\"_blank\" >面试官：前端跨页面通信，你知道哪些方法？</a></li>\n</ol>\n<h3 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;iframe\n  src&#x3D;&quot;https:&#x2F;&#x2F;alienzhou.github.io&#x2F;cross-tab-communication&#x2F;&quot;\n  style&#x3D;&quot;width: 100%; height: 800px&quot;\n&gt;&lt;&#x2F;iframe&gt;</code></pre>\n\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p><a href=\"https://github.com/alienzhou/alienzhou.github.io/blob/master/cross-tab-communication/index.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"非同源\"><a href=\"#非同源\" class=\"headerlink\" title=\"非同源\"></a>非同源</h3><p><a href=\"https://juejin.cn/post/6869686782942773255\" target=\"_blank\" >见</a></p>\n<p>实现原理：<br><a href=\"http://localhost:3000/bbb.html%EF%BC%88%E7%AE%80%E7%A7%B0\">http://localhost:3000/bbb.html（简称</a> bbb 页面）嵌入 iframe 页面 <a href=\"http://localhost:3001/a.html%EF%BC%88%E7%AE%80%E7%A7%B0\">http://localhost:3001/a.html（简称</a> iframe 页面）<br>iframe 能够接受父级页面 bbb.html 发送过来的数据<br>与此同时 iframe 与实际需要接受数据的 <a href=\"http://localhost:3001/b.html\">http://localhost:3001/b.html</a>(简称 b 页面)同源，所以可以通过同源通信的 Broadcast Channel 方式将 iframe 接受到的数据发送给 b 页面实现 bbb 页面与 b 页面之间的数据发送</p>\n<p>作者：Tsuki_<br>链接：<a href=\"https://juejin.cn/post/6869686782942773255\">https://juejin.cn/post/6869686782942773255</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"demo-代码\"><a href=\"#demo-代码\" class=\"headerlink\" title=\"demo 代码\"></a>demo 代码</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 父传子\n\niframe.contentWindow.postMessage(&quot;父页面传送的数据&quot;, &quot;*&quot;);\n\n&#x2F;&#x2F; 父接子\n\nwindow.addEventListener(&quot;message&quot;, function (data) &#123;\n  console.log(data);\n&#125;);\n\n&#x2F;&#x2F; 子接父\nwindow.addEventListener(&quot;message&quot;, function (obj) &#123;\n  console.log(&quot;子页面&quot;);\n  console.log(obj);\n  let parentWindow &#x3D; obj.source;\n  parentWindow.postMessage(&quot;子页面传送的数据&quot;, &quot;*&quot;);\n&#125;);\n&#x2F;&#x2F; 子传父\nfunction sendMesg() &#123;\n  window.parent.window.postMessage(&quot;子页面传送的数据&quot;, &quot;*&quot;);\n&#125;</code></pre>\n\n<p><a href=\"https://blog.csdn.net/wangliuqi123/article/details/109577991\" target=\"_blank\" >见</a></p>\n<h2 id=\"transition-和-animation-的属性分别有哪些\"><a href=\"#transition-和-animation-的属性分别有哪些\" class=\"headerlink\" title=\"transition 和 animation 的属性分别有哪些\"></a>transition 和 animation 的属性分别有哪些</h2><p><a href=\"https://blog.csdn.net/gtLBTNq9mr3/article/details/123587378\" target=\"_blank\" >见</a></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">对比点</th>\n<th align=\"left\">transition</th>\n<th align=\"left\">animation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>侧重点</code></td>\n<td align=\"left\"><code>单一动画属性</code>的过度效果,其<code>过程是简单</code>，<br/>由开始到结束的过程，中间不存在可能的动画转折</td>\n<td align=\"left\">强调的是<code>多种动画属性的结合</code>，<br/>按时间轴线出现周折性动画变换的动画过程，其过程是复杂的</td>\n</tr>\n<tr>\n<td align=\"left\"><code>状态</code></td>\n<td align=\"left\">开始状态 和 结束状态</td>\n<td align=\"left\">多个状态，有帧的概念</td>\n</tr>\n<tr>\n<td align=\"left\"><code>功能更强大</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">“播放次数”、“播放方向”、“播放状态”</td>\n</tr>\n<tr>\n<td align=\"left\"><code>触发</code></td>\n<td align=\"left\">选择器&#x2F;js 来触发</td>\n<td align=\"left\">自动触发</td>\n</tr>\n<tr>\n<td align=\"left\"><code>使用规则</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">需 @keyframes &#x2F;animation-name</td>\n</tr>\n<tr>\n<td align=\"left\"><code>动效控制</code></td>\n<td align=\"left\">“持续时间”、“延迟时间” 、“时间缓动函数”</td>\n<td align=\"left\">同前者</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2018/06/css3-animation-steps-step-start-end/\" target=\"_blank\" >CSS3 animation 属性中的 steps 功能符深入介绍</a></p>\n<ol>\n<li><p><code>状态</code>：CSS 的 transition 只有两个状态：开始状态 和 结束状态；但 animation 可能是多个状态，有帧的概念</p>\n</li>\n<li><p><code>触发</code>：CSS 的 transition 需要借助别的方式来触发，比如 CSS 的状态选择器（如:hover）或 借助 JavaScript 来触发；animation 可以自动触发</p>\n</li>\n<li><p><code>动效控制</code>：CSS transition 和 animation 虽然实现动效方式不同，但他们之间有些概念是相同的。比如他们都有“持续时间”、“延迟时间” 和“时间缓动函数”等概念，这些都是用来控制动效的效果。</p>\n</li>\n<li><p>CSS 的 animation 是离不开 @keyframes 的，换句话说，我们需要先使用 @keyframes 来注册一个动画效果，即帧来描述动画效果。当然，只注册也不见得有效果，还是需要使用 animation-name 属性引用 @keyframes 注册好的动画效果。</p>\n</li>\n<li><p>animation 控制动效上要比 transition 强，因为它具备一些控制动效的属性，比如“播放次数”、“播放方向”、“播放状态”等。</p>\n</li>\n<li><p>CSS transition 强调的是单一动画属性的过度效果,其过程是简单的，由开始到结束的过程，中间不存在可能的动画转折，只有 0 到 1，比喻：渐隐，渐显;</p>\n</li>\n<li><p>CSS animation 强调的是多种动画属性的结合，按时间轴线出现周折性动画变换的动画过程，其过程是复杂的，由开始——&gt;结束的过程中，存在可能的动画转折，其过程可能是开始—0—1—2—3&gt;结束的过程。</p>\n</li>\n</ol>\n<p>综合来说：CSS animation 可以包括 CSS transition 的动画形式。感觉两者之间,transition 像是 animation 的子集。</p>\n<h2 id=\"CSS3-font\"><a href=\"#CSS3-font\" class=\"headerlink\" title=\"CSS3 font\"></a>CSS3 font</h2><ol>\n<li>必须要先有字体文件</li>\n<li><code>@font-face</code>声明字体<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n  @font-face &#123;\n    font-family: myFirstFont;\n    src: url(&quot;你自己的字体文件路径.ttf&quot;);\n  &#125;\n&lt;&#x2F;style&gt;</code></pre></li>\n<li>css 选择器中使用 <code>font-family</code></li>\n</ol>\n<h2 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h2><h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的技术。</p>\n<p><em>函数柯里化，是可以用来慢慢凑齐参数，延迟函数的执行。（先分期交钱，后交货！）</em></p>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>函数有记忆功能（多次接受参数，记忆历史参数信息），累积接受参数个数函数小于定义参数个数时返回一个函数，继续接受参数，<code>典型的闭包 + 递归</code></p>\n<h3 id=\"为什么会出现\"><a href=\"#为什么会出现\" class=\"headerlink\" title=\"为什么会出现\"></a>为什么会出现</h3><h3 id=\"柯里化-1\"><a href=\"#柯里化-1\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const curry &#x3D; (fn, ...rest) &#x3D;&gt; &#123;\n  return (...args) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;判断参数总数是否和fn参数个数相等\n    if ([...rest, ...args].length &#x3D;&#x3D;&#x3D; fn.length) &#123;\n      return fn(...rest, ...args); &#x2F;&#x2F;拓展参数，调用fn\n    &#125; else &#123;\n      return curry(fn, [...rest, ...args]); &#x2F;&#x2F;迭代，传入现有的所有参数\n    &#125;\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; const curry &#x3D; (fn, ...args1) &#x3D;&gt; (...args2) &#x3D;&gt; ((arg) &#x3D;&gt; (arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, ...arg)))([\n&#x2F;&#x2F;       ...args1,\n&#x2F;&#x2F;       ...args2,\n&#x2F;&#x2F;     ]);\n\n&#x2F;&#x2F; 调用\nconst foo &#x3D; (a, b, c) &#x3D;&gt; a * b * c;\ncurry(foo)(2, 3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2)(3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3)(4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3, 4)(); &#x2F;&#x2F; -&gt; 24</code></pre>\n\n<p><a href=\"https://www.jianshu.com/p/c87242cd2f6c\" target=\"_blank\" >见</a></p>\n<h2 id=\"异步编程-promise-与-async-的区别\"><a href=\"#异步编程-promise-与-async-的区别\" class=\"headerlink\" title=\"异步编程 promise 与 async 的区别\"></a>异步编程 promise 与 async 的区别</h2><h3 id=\"async-特点\"><a href=\"#async-特点\" class=\"headerlink\" title=\"async 特点\"></a>async 特点</h3><h4 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h4><ol>\n<li>async 解决了什么问题 promise 链式调用的烦恼</li>\n<li>async 和 await 关键字,让我们可以用一种更简洁的方式， 写出基于 Promise 的异步行为，而无需刻意地链式调用 promise</li>\n</ol>\n<h4 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h4><ul>\n<li>async 函数是 AsyncFunction 构造函数的实例 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function#:~:text=async%20%E5%87%BD%E6%95%B0%E6%98%AF%20AsyncFunction%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B\" target=\"_blank\" >见</a></li>\n</ul>\n<h4 id=\"是什么-1\"><a href=\"#是什么-1\" class=\"headerlink\" title=\"是什么\"></a>是什么</h4><ol>\n<li>async 函数可能包含 0 个或者多个 await 表达式。</li>\n<li>await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。</li>\n<li>promise 的解决值会被当作该 await 表达式的返回值</li>\n</ol>\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ol>\n<li>从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。</li>\n<li>一个不含 await 表达式的 async 函数是会同步运行的。</li>\n<li>如果函数体内有一个 await 表达式，async 函数就<code>一定</code>会异步执行。</li>\n</ol>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><ul>\n<li>async 返回值<code>一定</code>为 promise, 如果返回值不是 promise，将会被隐式包装在一个 promise 中</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function foo() &#123;\n  return 1;\n&#125;\n&#x2F;&#x2F; 等价于\nfunction foo() &#123;\n  return Promise.resolve(1);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(1);\nasync function foo() &#123;\n  console.log(2);\n  await 1;\n  console.log(3);\n&#125;\nfoo();\nconsole.log(4);\n\n&#x2F;&#x2F; 结果：1243</code></pre>\n\n<h4 id=\"两个-await-执行说明\"><a href=\"#两个-await-执行说明\" class=\"headerlink\" title=\"两个 await, 执行说明\"></a>两个 await, 执行说明</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function foo() &#123;\n  const result1 &#x3D; await new Promise((resolve) &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; resolve(&quot;1&quot;))\n  );\n  const result2 &#x3D; await new Promise((resolve) &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; resolve(&quot;2&quot;))\n  );\n&#125;\nfoo();</code></pre>\n\n<ol>\n<li>foo 函数的第一行将会同步执行，await 将会等待 promise 的结束。然后暂停通过 foo 的进程，并将控制权交还给调用 foo 的函数。(控制权转出)</li>\n<li>一段时间后，当第一个 promise 完结的时候，控制权将重新回到 foo 函数内。示例中将会将 1（promise 状态为 fulfilled）作为结果返回给 await 表达式的左边即 result1。 (控制权转入)</li>\n<li>接下来函数会继续进行，到达第二个 await 区域，此时 foo 函数的进程将再次被暂停。(控制权转出)</li>\n<li>一段时间后，同样当第二个 promise 完结的时候，result2 将被赋值为 2，之后函数将会正常同步执行，将默认返回 undefined (控制权转入)</li>\n</ol>\n<p><em>注意： promise 链不是一次就构建好的，相反，promise 链是分阶段构造的，因此在处理异步函数时必须注意对错误函数的处理。</em></p>\n<h4 id=\"async-x2F-await-和-Promise-x2F-then-对比以及错误处理\"><a href=\"#async-x2F-await-和-Promise-x2F-then-对比以及错误处理\" class=\"headerlink\" title=\"async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理\"></a>async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理</h4><ol>\n<li>大多数 async 函数也可以使用 Promises 编写。但是，<code>在错误处理方面，async 函数更容易捕获异常错误</code></li>\n<li>如果任一 <code>awaited 调用失败</code>，它将<code>自动捕获异常</code>，async 函数<code>执行中断</code>，并通过<code>隐式返回 Promise </code>将错误传递给调用者</li>\n<li><code>async 函数仍有可能然可能错误地忽略错误</code>. 在 async 中， 没有等待 await 返回，则不会传播任何错误</li>\n</ol>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>简单</code>：promise 链式调用繁杂，async&#x2F;await 相对来说，更简单</li>\n<li><code>并发</code>：promise api 能够实现并发， async&#x2F;await 只会顺序执行</li>\n<li><code>返回</code>：async&#x2F;await 的返回值，一定是一个 promise，会进行隐式的包装（如果在发生错误时候进行，捕获处理然后返回一个值，之后真正返回并不是这个值，而是被 promise 包装了）</li>\n<li><code>错误</code>：async&#x2F;await 在处理错误方面更容易（任意一个 await 出错，会自动捕获异常，执行中断，隐式返回 promise 错误，这几个环环相扣）,如果没有等待返回的情况下，async 可能错误的忽略错误，不进行传播错误</li>\n<li><code>错误捕获</code>：因 async&#x2F;await 一定返回的是 promise,所以 async&#x2F;await 既可以用<code>try catch</code>， 也可以用<code>.catch</code> (<code>try catch</code>是 js 语法，<code>.catch</code>是<code>promise.catch</code>语法)</li>\n</ol>\n<h2 id=\"包装对象-x2F-原型与原型链\"><a href=\"#包装对象-x2F-原型与原型链\" class=\"headerlink\" title=\"包装对象&#x2F;原型与原型链\"></a>包装对象&#x2F;原型与原型链</h2><h3 id=\"包装对象的含义\"><a href=\"#包装对象的含义\" class=\"headerlink\" title=\"包装对象的含义\"></a>包装对象的含义</h3><p>（Number&#x2F;String）经过封装，能够处理（number&#x2F;string）的对象</p>\n<h3 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h3><div style=\"display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;\">\n<img src=\"http://t-blog-images.aijs.top/img/202210261711923.webp\" style=\"width: 550px;max-width:100%\" />\n<div style=\"width:10px\"></div>\n<img src=\"http://t-blog-images.aijs.top/img/202210261734112.webp\" style=\"width: 360px;max-width:100%\"/>\n</div>\n\n<p>细品 原型与原型链关系图：</p>\n<p>竖着看分为三栏：左侧为实例对象，中间为构造函数，右侧为原型对象</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">实例</th>\n<th align=\"left\">构造函数 <span style=\"color: red\">created by Function</span></th>\n<th align=\"left\">原型对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">new Foo&#x2F;Number&#x2F;String</td>\n<td align=\"left\">function Foo&#x2F;Number&#x2F;String()</td>\n<td align=\"left\">Foo&#x2F;Number&#x2F;String.prototype</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">new Object</td>\n<td align=\"left\">function Object()</td>\n<td align=\"left\">Object.prototype</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n<td align=\"left\">function Function()</td>\n<td align=\"left\">Function.prototype</td>\n</tr>\n</tbody></table>\n<p><strong>注意：序号 1</strong><br>从 MDN Number 包装对象的目录接口也可以看出：Number 的原型链： <code>Function.prototype -&gt; Object.prototype -&gt; null</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; .__proto__ 表示：隐式原型\n&#x2F;&#x2F; .prototype 表示：显示原型\n实例.__proto__ &#x3D;&#x3D; 实例的原型对象\n构造函数的.__proto__ &#x3D;&#x3D; Function 的原型对象\n原型对象的.constructor &#x3D;&#x3D; 对应的构造函数\n构造函数的.prototype &#x3D;&#x3D; 对应的原型对象\n非(Object 和 null)的.__proto__ &#x3D;&#x3D; Object.prototype\nObject.__proto__ &#x3D;&#x3D; null\n\n&#x2F;&#x2F; 有意思的是 Function\nFunction.__proto__ &#x3D;&#x3D; Function.prototype\n</code></pre>\n\n<h2 id=\"Object-freeze-vs-Object-seal-vs-Object-preventExtensions\"><a href=\"#Object-freeze-vs-Object-seal-vs-Object-preventExtensions\" class=\"headerlink\" title=\"Object.freeze() vs Object.seal() vs Object.preventExtensions()\"></a>Object.freeze() vs Object.seal() vs Object.preventExtensions()</h2><h3 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze()\"></a>Object.freeze()</h3><ol>\n<li>不增加新属性、不删除已有属性、不赋值</li>\n<li>子属性对象可编辑</li>\n</ol>\n<h3 id=\"Object-seal\"><a href=\"#Object-seal\" class=\"headerlink\" title=\"Object.seal()\"></a>Object.seal()</h3><ol>\n<li>不增加新属性、不删除已有属性</li>\n<li>可赋值</li>\n</ol>\n<h3 id=\"Object-preventExtensions\"><a href=\"#Object-preventExtensions\" class=\"headerlink\" title=\"Object.preventExtensions()\"></a>Object.preventExtensions()</h3><ol>\n<li>不增加新属性</li>\n<li>可改已有属性</li>\n</ol>\n<h3 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h3><table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">默认</th>\n<th align=\"left\">preventExtensions</th>\n<th align=\"left\">seal</th>\n<th align=\"left\">freeze</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">增加新属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">移除属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">更改属性</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">子对象属性操作</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n<td align=\"left\">可</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://javascript.plainenglish.io/object-freeze-vs-object-seal-vs-object-preventextensions-e78ef3a24201\" target=\"_blank\" >见</a></p>\n<h2 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"前端工程化\"></a>前端工程化</h2><h3 id=\"是什么-2\"><a href=\"#是什么-2\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><ol>\n<li>通过<code>制定规范</code>、<code>借助工具和框架</code>, 解决前端开发, 以及前后端协作过程中的<code>痛点和难度问题</code>,<code>提高研发效率</code></li>\n</ol>\n<h3 id=\"为什么-1\"><a href=\"#为什么-1\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><ol>\n<li>随着需求的增加，前端也变成大前端，还要做 App、小程序以及各种端。</li>\n<li>在这种需求日增的情况下，必须得考虑一种新的方式，优化前端的开发工作，</li>\n<li>例如，<code>解决代码冗余</code>，<code>项目可维护性</code>，<code>提升版本迭代速度</code>等等一系列的问题。前端工程化的概念也就是在这中情况下被提出了。</li>\n</ol>\n<h3 id=\"如何实施前端工程化\"><a href=\"#如何实施前端工程化\" class=\"headerlink\" title=\"如何实施前端工程化\"></a>如何实施前端工程化</h3><ol>\n<li>前端后分离</li>\n<li>使用 webpack 实现项目构建</li>\n<li>使用 babel 完成 javascript 编译</li>\n<li>CSS 预编译</li>\n<li>模块化开发</li>\n<li>组件化</li>\n<li>本地开发环境&#x2F;模拟数据</li>\n<li>规范化约束</li>\n<li>项目部署</li>\n</ol>\n<h2 id=\"npm-run-做了什么\"><a href=\"#npm-run-做了什么\" class=\"headerlink\" title=\"npm run 做了什么\"></a>npm run 做了什么</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; package.json; -&gt; node_modules&#x2F;.bin&#x2F; -&gt;对应的可执行文件执行\n\n&#x2F;&#x2F; 在安装依赖的时候，是通过npm install xxx来执行的，\n&#x2F;&#x2F; 例如npm install @vue&#x2F;cli-service,npm在安装这个依赖的时候，\n&#x2F;&#x2F; 就会在node_modules&#x2F;.bin&#x2F;目录中创建好vue-cli-service为名的几个可执行文件了【不同系统对应不同的可执行文件】\n&#x2F;&#x2F; .bin目录下的文件不是任何一个npm包。目录下的文件，表示这是一个个软连接，打开文件可以看到文件顶部写着#!&#x2F;bin&#x2F;sh,表示这是一个脚本\n\n&#x2F;&#x2F; 当使用 npm run serve 执行 vue-cli-service serve时，\n&#x2F;&#x2F; 虽然没有安装 vue-cli-service的全局命令，但是npm 会到 .&#x2F;node_modules&#x2F;.bin中找到 vue-cli-service 文件作为 脚本来执行，\n&#x2F;&#x2F; 则相当于执行了 .&#x2F;node_modules&#x2F;.bin&#x2F;vue-cli-service serve（最后的 serve 作为参数传入）</code></pre>\n\n<h2 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h2><p><strong>1. 检查配置</strong></p>\n<ol>\n<li>项目级别的.npmrc 文件 &gt;</li>\n<li>用户级别的.npmrc 文件 &gt;</li>\n<li>全局的.npmrc 文件 &gt;</li>\n<li>npm 内置的.npmrc 文件;</li>\n</ol>\n<p><strong>2、没有 lock 文件</strong></p>\n<ol>\n<li><code>分析</code>：分析依赖关系，这是因为我们包会依赖其他的包，并且会多个包之间产生相同的依赖的关系。</li>\n<li><code>下载</code>：从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）。</li>\n<li><code>缓存</code>：获取到压缩包后会对压缩包进行缓存（从 npm5 开始有的）。</li>\n<li><code>解压缩</code>：将压缩包解压到项目的 node_modules 文件夹中（前面我们讲过，require 的查找顺序会在该包下面查找）。</li>\n</ol>\n<p><strong>3、有 lock 文件</strong></p>\n<ol>\n<li><code>比对</code>：检测 lock 中包的版本是否和 package.json 中一致（会按照 semver 版本规范检测）。</li>\n<li><code>无缓存</code>：不一致，那么会重新构建依赖关系，直接会走顶层的流程。</li>\n<li><code>有缓存</code>：一致的情况下，会去优先查找缓存。没有找到，会从 registry 仓库下载，直接走顶层流程。</li>\n<li><code>查找到</code>：会获取缓存中的压缩文件，并且将压缩文件解压到 node_modules 文件夹中。</li>\n</ol>\n<h2 id=\"实现-jsonp，传入-URL，callback-和-callbackName-三个参数\"><a href=\"#实现-jsonp，传入-URL，callback-和-callbackName-三个参数\" class=\"headerlink\" title=\"实现 jsonp，传入 URL，callback 和 callbackName 三个参数\"></a>实现 jsonp，传入 URL，callback 和 callbackName 三个参数</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n\n  function jsonp(url, callbackName, callback) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      try &#123;\n        let str &#x3D; &#96;$&#123;url&#125;?callback&#x3D;$&#123;callbackName&#125;&#96;\n        &#123;&#x2F;* 创建标签 *&#x2F;&#125;\n        let scriptEle &#x3D; document.createElement(&#39;script&#39;)\n        scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;\n        scriptEle.src &#x3D; str\n        &#123;&#x2F;* 监听加载 *&#x2F;&#125;\n        scriptEle.addEventListener(&#39;load&#39;, callback)\n        &#123;&#x2F;* 回调清理 *&#x2F;&#125;\n        window[callbackName] &#x3D; function (data) &#123;\n          resolve(data)\n          document.body.removeChild(scriptEle)\n        &#125;\n        document.body.appendChild(scriptEle)\n      &#125; catch (err) &#123;\n        reject(err)\n      &#125;\n    &#125;)\n  &#125;\n\n\n  jsonp(&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;home&#39;, &#39;fun1&#39;, () &#x3D;&gt; &#123;console.log(&#39;加载成功&#39;)&#125;).then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n\n&lt;&#x2F;script&gt;\n</code></pre>\n\n<h2 id=\"原生-js-实现动态加载-js-文件\"><a href=\"#原生-js-实现动态加载-js-文件\" class=\"headerlink\" title=\"原生 js 实现动态加载 js 文件?\"></a>原生 js 实现动态加载 js 文件?</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n    function loadScript(src, attrs) &#123;\n      return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        try &#123;\n          &#x2F;&#x2F; 创建标签\n          let scriptEle &#x3D; document.createElement(&#39;script&#39;)\n          &#x2F;&#x2F; 类型\n          scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;\n          &#x2F;&#x2F; src\n          scriptEle.src &#x3D; src\n          &#x2F;&#x2F; 增加属性\n          for (let key in attrs) &#123;\n            scriptEle.setAttribute(key, attrs[key])\n          &#125;\n          &#x2F;&#x2F; 监听完成\n          scriptEle.addEventListener(&#39;load&#39;, function () &#123;\n            resolve(&#39;成功&#39;)\n          &#125;)\n          &#x2F;&#x2F; 挂载后加载\n          document.body.appendChild(scriptEle)\n        &#125; catch (err) &#123;\n          reject(err)\n        &#125;\n      &#125;)\n    &#125;\n    loadScript(&#39;http:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.6.2&#x2F;jquery.min.js&#39;, &#123;async: true&#125;).then(res &#x3D;&gt; &#123;\n      console.log(res)\n    &#125;)\n  &lt;&#x2F;script&gt;\n</code></pre>\n\n<h2 id=\"js-中的-for-循环注意点？\"><a href=\"#js-中的-for-循环注意点？\" class=\"headerlink\" title=\"js 中的 for 循环注意点？\"></a>js 中的 for 循环注意点？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 多个判断条件以最后一个为准\n&#x2F;&#x2F; 最后一个是 j &lt; 9\nfor (var i &#x3D; 0, j &#x3D; 0; i &lt; 5, j &lt; 9; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4\n&#x2F;&#x2F; 5 5\n&#x2F;&#x2F; 6 6\n&#x2F;&#x2F; 7 7\n&#x2F;&#x2F; 8 8\n&#x2F;&#x2F; 最后一个是  i &lt; 5\nfor (var i &#x3D; 0, j &#x3D; 0; j &lt; 9, i &lt; 5; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4</code></pre>\n\n<h2 id=\"new-操作符和点运算符的优先级\"><a href=\"#new-操作符和点运算符的优先级\" class=\"headerlink\" title=\"new 操作符和点运算符的优先级\"></a>new 操作符和点运算符的优先级</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Foo() &#123;\n  getName &#x3D; function () &#123;\n    console.log(1);\n  &#125;; &#x2F;&#x2F;会修改全局的下的getName\n  return this; &#x2F;&#x2F; 构造函数的返回值值得注意，如果是引用类型，则得到引用数据，null除外\n&#125;\nFoo.getName &#x3D; function () &#123;\n  console.log(2);\n&#125;;\nFoo.prototype.getName &#x3D; function () &#123;\n  console.log(3);\n&#125;;\nvar getName &#x3D; function () &#123;\n  console.log(4);\n&#125;;\nfunction getName() &#123;\n  console.log(5);\n&#125;\n\n&#x2F;&#x2F;请写出以下输出结果：\nFoo.getName(); &#x2F;&#x2F;2\ngetName(); &#x2F;&#x2F; 4\nFoo().getName(); &#x2F;&#x2F; 1\ngetName(); &#x2F;&#x2F; 1\nnew Foo.getName(); &#x2F;&#x2F; 2 这里是new了一个Foo.getName函数，并没有先执行Foo.getName()在去执行new操作\nnew Foo().getName(); &#x2F;&#x2F; 3 (new Foo()).getName() 此时的getName是找到Foo构造函数的原型对象上的getName属性\nnew new Foo().getName(); &#x2F;&#x2F; 3  new ((new Foo()).getName)();\n&#x2F;*******************升级版********************&#x2F;\n&#x2F;&#x2F; function Foo() &#123;\n&#x2F;&#x2F; \t\tthis.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(3);\n&#x2F;&#x2F; \t\t\treturn &#123;\n&#x2F;&#x2F; \t\t\t\tgetName: getName&#x2F;&#x2F;这个就是第六问中涉及的构造函数的返回值问题\n&#x2F;&#x2F; \t\t\t&#125;\n&#x2F;&#x2F; \t\t&#125;;&#x2F;&#x2F;这个就是第六问中涉及到的， JS 构造函数公有方法和原型链方法的优先级\n&#x2F;&#x2F; \t\tgetName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(1);\n&#x2F;&#x2F; \t\t&#125;;\n&#x2F;&#x2F; \t\treturn this\n&#x2F;&#x2F; \t&#125;\n&#x2F;&#x2F; \tFoo.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(2);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tFoo.prototype.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(6);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tvar getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(4);\n&#x2F;&#x2F; \t&#125;;\n\n&#x2F;&#x2F; \tfunction getName() &#123;\n&#x2F;&#x2F; \t\tconsole.log(5);\n&#x2F;&#x2F; \t&#125; &#x2F;&#x2F;答案：\n&#x2F;&#x2F; \tFoo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;4\n&#x2F;&#x2F; \tconsole.log(Foo())\n&#x2F;&#x2F; \tFoo().getName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tnew Foo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tnew Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F;             &#x2F;&#x2F;多了一问\n&#x2F;&#x2F; \tnew Foo().getName().getName(); &#x2F;&#x2F;3 1\n&#x2F;&#x2F; \tnew new Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_34146986&#x2F;article&#x2F;details&#x2F;92386841</code></pre>\n\n<h2 id=\"new-一个构造函数，如果函数返回不同类型的值，结果会如何\"><a href=\"#new-一个构造函数，如果函数返回不同类型的值，结果会如何\" class=\"headerlink\" title=\"new 一个构造函数，如果函数返回不同类型的值，结果会如何?\"></a>new 一个构造函数，如果函数返回不同类型的值，结果会如何?</h2><p>new 的原理： 最后要判断构造函数返回值是不是个对象，不是对象是对象返回这个值，不是对象，返回构造函数的实例</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">null instanceof Object; &#x2F;&#x2F; false\nObject instanceof null; &#x2F;&#x2F; 报错，instanceof 的右侧必须是一个对象\n&#x2F;&#x2F; Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object</code></pre>\n\n<h3 id=\"什么都不返回\"><a href=\"#什么都不返回\" class=\"headerlink\" title=\"什么都不返回\"></a>什么都不返回</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回一个新的对象\"><a href=\"#返回一个新的对象\" class=\"headerlink\" title=\"返回一个新的对象\"></a>返回一个新的对象</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return &#123;\n    name: &quot;1234&quot;,\n  &#125;;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;&#123;name: &#39;1234&#39;&#125;</code></pre>\n\n<h3 id=\"返回一个原始值\"><a href=\"#返回一个原始值\" class=\"headerlink\" title=\"返回一个原始值\"></a>返回一个原始值</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return 111;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-null\"><a href=\"#返回-null\" class=\"headerlink\" title=\"返回 null\"></a>返回 null</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return null;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-true\"><a href=\"#返回-true\" class=\"headerlink\" title=\"返回 true\"></a>返回 true</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  return true;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre>\n\n<h3 id=\"返回-this\"><a href=\"#返回-this\" class=\"headerlink\" title=\"返回 this\"></a>返回 this</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person() &#123;\n  &#x2F;&#x2F; 构造函数this指的是对象实例\n  return this;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1);\n&#x2F;&#x2F; Person &#123;&#125;\n\n&#x2F;&#x2F; 但是 this instanceof Object true, 这里涉及到this指向问题</code></pre>\n\n<h2 id=\"为什么要用-apply-x2F-call-这两个函数\"><a href=\"#为什么要用-apply-x2F-call-这两个函数\" class=\"headerlink\" title=\"为什么要用 apply&#x2F;call 这两个函数\"></a>为什么要用 apply&#x2F;call 这两个函数</h2><ul>\n<li>说白了就是“拿来主义”、“借刀杀人”的功效，</li>\n<li>比如我想做什么事，我不会不要紧，只要有人会就可以实现。</li>\n<li>在程序里面就是，现在假如你想用什么方法，但是当前对象没有，你可以选择拓展，自己造一个这样的方法，但是你也可以直接拿来用</li>\n</ul>\n<p>有时候这样使用更方便，我们只需要对象和回调方法即可，按照一般的说法就是：call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。</p>\n<p><a href=\"https://segmentfault.com/q/1010000006732812\" target=\"_blank\" >讲真，为什么要用 apply 和 call 这两个函数？</a></p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h3 id=\"height-x2F-width\"><a href=\"#height-x2F-width\" class=\"headerlink\" title=\"height&#x2F;width\"></a>height&#x2F;width</h3><p>width 中的 max-content,min-content,fit-content 的区别</p>\n<ol>\n<li><code>max-content</code> 实验性 设置为允许的最大高度。</li>\n<li><code>min-content</code> 实验性 设置为允许的最小高度。</li>\n<li><code>available</code> 实验性 包含块高度减去当前元素的边距，边框和填充。</li>\n<li><code>fit-content</code> 实验性 将 fill-content 公式中的可用位置替换为特定的参数以进行使用，如：<code>min(max-content, max(min-content, ))</code></li>\n</ol>\n<h3 id=\"width-属性-100-和-auto-的区别\"><a href=\"#width-属性-100-和-auto-的区别\" class=\"headerlink\" title=\"width 属性 100%和 auto 的区别\"></a>width 属性 100%和 auto 的区别</h3><ol>\n<li><p><code>width：100%</code><br>100%表示子元素的宽度和父元素的宽度相等，其中并不包括子元素内外边距以及边框的值，为子元素真正的宽度</p>\n</li>\n<li><p><code>width：auto</code><br>auto 表示子元素的 宽度+内边距+外边距+边框 才等于父元素的宽度</p>\n</li>\n</ol>\n<p><strong>注意：上述父元素的宽度都是父元素真正的宽度，即父元素 width 属性值</strong><br>————————————————<br>版权声明：本文为 CSDN 博主「Tie_may」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/Tie_may/article/details/113761173\">https://blog.csdn.net/Tie_may/article/details/113761173</a></p>\n<h3 id=\"vertical-align-middle\"><a href=\"#vertical-align-middle\" class=\"headerlink\" title=\"vertical-align: middle\"></a>vertical-align: middle</h3><p>Vertical-align 被<code>用于垂直对齐 inline 元素</code>，<code>也就是 display 值为 inline 和 inline-block 的元素</code></p>\n<p>CSS 的属性 vertical-align 用来指定<code>行内元素（inline）</code>或<code>表格单元格（table-cell）元素</code>的垂直对齐方式。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align\" target=\"_blank\" >MDN</a></p>\n<h3 id=\"will-change\"><a href=\"#will-change\" class=\"headerlink\" title=\"will-change\"></a>will-change</h3><ol>\n<li><code>不要将 will-change 应用到太多元素上：</code>浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。</li>\n<li><code>有节制地使用：</code>通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。</li>\n<li><code>不要过早应用 will-change 优化：</code>如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是<code>作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题</code>。<code>过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程</code>，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。</li>\n<li><code>给它足够的工作时间：</code>这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。</li>\n</ol>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><ol>\n<li><p><code>auto</code><br>盒子不会创建一个新的本地堆叠上下文。在当前堆叠上下文中生成的盒子的堆叠层级和父级盒子相同。</p>\n</li>\n<li><p><code>&lt;integer&gt;</code><br><code>&lt;integer&gt;</code>（整型数字）是生成的盒子在当前堆叠上下文中的堆叠层级。</p>\n</li>\n</ol>\n<p><strong>此盒子也会创建一个堆叠层级为 0 的本地堆叠上下文。这意味着后代（元素）的 z-indexes 不与此元素的外部元素的 z-indexes 进行对比。</strong></p>\n<h3 id=\"介绍下盒模型\"><a href=\"#介绍下盒模型\" class=\"headerlink\" title=\"介绍下盒模型\"></a>介绍下盒模型</h3><img src=\"http://t-blog-images.aijs.top/img/202301311827280.webp\" />\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model\" target=\"_blank\" >见</a></p>\n<h3 id=\"CSS-是怎么工作的\"><a href=\"#CSS-是怎么工作的\" class=\"headerlink\" title=\"CSS 是怎么工作的\"></a>CSS 是怎么工作的</h3><ol>\n<li><code>浏览器载入 HTML 文件（比如从网络上获取）</code>。</li>\n<li><code>将 HTML 文件转化成一个 DOM（Document Object Model）</code>，DOM 是文件在计算机内存中的表现形式，下一节将更加详细的解释 DOM。</li>\n<li><code>接下来，浏览器会拉取该 HTML 相关的大部分资源</code>，比如嵌入到页面的图片、视频和 CSS 样式。JavaScript 则会稍后进行处理，简单起见，同时此节主讲 CSS，所以这里对如何加载 JavaScript 不会展开叙述。</li>\n<li><code>浏览器拉取到 CSS 之后会进行解析</code>，<code>根据选择器的不同类型（比如 element、class、id 等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）</code>。</li>\n<li>上述的规则应用于渲染树之后，<code>渲染树会依照应该出现的结构进行布局</code>。</li>\n<li><code>网页展示在屏幕上（这一步被称为着色）</code>。</li>\n</ol>\n<img src=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works/rendering.svg\" style=\"width:500px;max-width:100%\" />\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works\" target=\"_blank\" >见</a>\n\n<h3 id=\"当浏览器遇到无法解析的-CSS-代码会发生什么\"><a href=\"#当浏览器遇到无法解析的-CSS-代码会发生什么\" class=\"headerlink\" title=\"当浏览器遇到无法解析的 CSS 代码会发生什么\"></a>当浏览器遇到无法解析的 CSS 代码会发生什么</h3><p>浏览器什么也不会做，继续解析下一个 CSS 样式！</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works#%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E9%81%87%E5%88%B0%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84_css_%E4%BB%A3%E7%A0%81%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\" target=\"_blank\" >见</a></p>\n<h3 id=\"层叠、优先级和继承\"><a href=\"#层叠、优先级和继承\" class=\"headerlink\" title=\"层叠、优先级和继承\"></a>层叠、优先级和继承</h3><p>层叠相关因素：<code>资源顺序、优先级 、重要程度</code></p>\n<ol>\n<li><code>样式表层叠</code>——简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</li>\n<li><code>优先级</code> 浏览器是根据<code>优先级</code>来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度：<code>越具体优先级越高</code>,权重越大，优先级越高</li>\n<li><code>继承</code>也需要在上下文中去理解——一些设置在父元素上的 CSS 属性是可以被子元素继承的，有些则不能</li>\n</ol>\n<h3 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"!important\"></a>!important</h3><p>强烈建议除了非常情况不要使用它<br>覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有相同优先级而且顺序靠后，或者更高优先级。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"从-performanceAPI-来讲\"><a href=\"#从-performanceAPI-来讲\" class=\"headerlink\" title=\"从 performanceAPI 来讲\"></a>从 performanceAPI 来讲</h3><p>一大堆…,简单说要个几分钟，展开来讲几十分钟，几个小时</p>\n<h3 id=\"协议优化\"><a href=\"#协议优化\" class=\"headerlink\" title=\"协议优化\"></a>协议优化</h3><ol>\n<li>http2 优于 http1</li>\n<li>http3 优于 http2</li>\n</ol>\n<h3 id=\"加载优化\"><a href=\"#加载优化\" class=\"headerlink\" title=\"加载优化\"></a>加载优化</h3><ol>\n<li>预加载</li>\n<li>懒加载 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\" target=\"_blank\" >Intersection Observer</a></li>\n<li>按需加载</li>\n<li>延迟加载、异步加载</li>\n<li>压缩（webpack 来讲 html、css、js、json、image 都可以压缩）</li>\n<li>CDN</li>\n</ol>\n<h3 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h3><ol>\n<li>css、htm 嵌套减少</li>\n<li>react-native 里有个视图拍平优化</li>\n<li>回流和重绘</li>\n<li>按需渲染</li>\n<li>useCallback、useMemo、shouldComponentUpdate 浅比较</li>\n<li>局部渲染、局部刷新</li>\n</ol>\n<h3 id=\"缓存优化\"><a href=\"#缓存优化\" class=\"headerlink\" title=\"缓存优化\"></a>缓存优化</h3><ol>\n<li>强缓存</li>\n<li>协商缓存</li>\n<li>闭包数据缓存</li>\n</ol>\n<h3 id=\"更新优化\"><a href=\"#更新优化\" class=\"headerlink\" title=\"更新优化\"></a>更新优化</h3><ol>\n<li>虚拟 dom,批量更新</li>\n<li>按需更新 immutable.js、immerjs</li>\n</ol>\n<h3 id=\"页面可见性-API\"><a href=\"#页面可见性-API\" class=\"headerlink\" title=\"页面可见性 API\"></a>页面可见性 API</h3><p>document.hidden&#x2F;visibilitychange</p>\n<ol>\n<li>网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片。</li>\n<li>显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。</li>\n<li>页面想要检测是否正在渲染，以便可以准确的计算网页浏览量</li>\n<li>当设备进入待机模式时，网站想要关闭设备声音（用户按下电源键关闭屏幕）</li>\n</ol>\n<h2 id=\"原生-js-深拷贝-x2F-浅拷贝\"><a href=\"#原生-js-深拷贝-x2F-浅拷贝\" class=\"headerlink\" title=\"原生 js 深拷贝&#x2F;浅拷贝\"></a>原生 js 深拷贝&#x2F;浅拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><ol>\n<li>所有标准的内置对象复制操作创建的是浅拷贝而不是深拷贝<ol>\n<li><code>展开语法</code></li>\n<li><code>Array.prototype.concat()</code>、<code>Array.prototype.slice()</code>、<code>Array.from()</code></li>\n<li><code>Object.assign()</code> 和 <code>Object.create()</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><ol>\n<li>对象的深拷贝是指其属性与其拷贝的源对象的属性不共享相同的引用（指向相同的底层值）的副本。</li>\n<li>因此，当你更改源或副本时，可以确保不会导致其他对象也发生更改；</li>\n<li>不会出现无意中对源或副本造成意料之外的更改</li>\n</ol>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy\" target=\"_blank\" >深拷贝</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/web/api/structuredClone\" target=\"_blank\" >window.structuredClone</a></p>\n<p><code>Suspense fallback=&#123;undefined&#125;</code> 表现与<code>null</code>相同.</p>\n<h2 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react-native\"></a>react-native</h2><h3 id=\"react-native-新特性\"><a href=\"#react-native-新特性\" class=\"headerlink\" title=\"react-native 新特性\"></a>react-native 新特性</h3><img src=\"http://t-blog-images.aijs.top/img/202302182122000.webp\" />\n\n<ol>\n<li>默认情况下为 TypeScript</li>\n<li>使用 Flexbox Gap 简化布局</li>\n<li>受 Web 启发的可访问性、样式和事件道具</li>\n<li>恢复 PropTypes</li>\n<li>开发者体验改进</li>\n<li>新架构更新</li>\n</ol>\n<p><a href=\"https://reactnative.dev/blog\" target=\"_blank\" >https://reactnative.dev/blog</a></p>\n<h3 id=\"react-native-与原生的通信\"><a href=\"#react-native-与原生的通信\" class=\"headerlink\" title=\"react-native 与原生的通信\"></a>react-native 与原生的通信</h3><p><a href=\"/#/post/2023-02-17rn-native\" target=\"_blank\" >见：2023-02-17rn-native</a></p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ol>\n<li><p>数组中有哪些方法</p>\n<ol>\n<li><p>构造方法</p>\n</li>\n<li><p>静态方法</p>\n<ol>\n<li>Array.from()： 从数组类对象或可迭代对象创建一个新的 Array 实例。</li>\n<li>Array.isArray()：如果参数是数组则返回 true ，否则返回 false 。</li>\n<li>Array.of()： 创建一个新的 Array 实例，具有可变数量的参数，而不管参数的数量或类型。</li>\n</ol>\n</li>\n<li><p>在访问索引之前执行 <code>in 检查</code>，并且<code>不将空槽与 undefined 合并</code>：</p>\n<ol>\n<li>copyWithin()</li>\n<li>concat()</li>\n<li>every()</li>\n<li>filter()</li>\n<li>flat()</li>\n<li>flatMap()</li>\n<li>indexOf()</li>\n<li>forEach()</li>\n<li>lastIndexOf()</li>\n<li>map()</li>\n<li>reduce()</li>\n<li>reduceRight()</li>\n<li>reverse()</li>\n<li>slice()</li>\n<li>some()</li>\n<li>sort()</li>\n</ol>\n</li>\n<li><p>将空槽视为 undefined：</p>\n<ol>\n<li>join()</li>\n<li>keys()</li>\n<li>values()</li>\n<li>entries()</li>\n<li>fill()</li>\n<li>find()</li>\n<li>findIndex()</li>\n<li>findLast()</li>\n<li>findLastIndex()</li>\n<li>includes()</li>\n<li>group() (en-US)</li>\n<li>groupToMap() (en-US)</li>\n<li>toLocaleString()</li>\n</ol>\n</li>\n<li><p>创建新数组的</p>\n<ol>\n<li>concat()</li>\n<li>map()</li>\n<li>filter()</li>\n<li>slice()</li>\n<li>splice()（构造返回的已删除元素数组）</li>\n<li>flat()</li>\n<li>flatMap()</li>\n</ol>\n</li>\n<li><p>可以对原数组进行修改：</p>\n<ol>\n<li>shift() &#x2F;&#x2F; 去掉</li>\n<li>unshift() &#x2F;&#x2F; 增加</li>\n<li>push()</li>\n<li>pop()</li>\n<li>splice()</li>\n<li>fill()</li>\n<li>reverse()</li>\n<li>sort()</li>\n<li>copyWithin()</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","text":"var let const 区别： 版本： var 是 es6 之前， const、let es6 之后， 分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域 提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前...","link":"","photos":[],"count_time":{"symbolsCount":"54k","symbolsTime":"49 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":19,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">var let const 区别：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9F\"><span class=\"toc-text\">什么是执行上下文？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#javascript-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">javascript 的执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">作用域链</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">词法作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%82%A3%E4%B9%88%E9%97%AD%E5%8C%85%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%EF%BC%8C%E9%94%80%E6%AF%81%E4%BA%86%EF%BC%8C%E5%8F%98%E9%87%8F%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F\"><span class=\"toc-text\">那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84\"><span class=\"toc-text\">闭包是如何回收的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">闭包使用原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F\"><span class=\"toc-text\">什么是作用域？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">原型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">什么是原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">为什么使用原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">原型分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">什么是原型链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建对象的几种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">继承，原型链</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">继承属性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">继承方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">使用语法结构创建的对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">使用构造器创建的对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Object-create-%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">使用 Object.create 创建的对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Number%E3%80%81Boolean-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">Number、Boolean 包装类型的原型链是怎样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">简单数据类型，为什么可以调用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#instanceof\"><span class=\"toc-text\">instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">实例与构造函数之间的关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-class%E3%80%81extends-%E4%B8%8E-super-%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">ES6 语法中的 class、extends 与 super 的原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this\"><span class=\"toc-text\">this</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-this-%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">聊下 this 指向问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E8%A6%81%E6%9C%89-this\"><span class=\"toc-text\">为什要有 this</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84\"><span class=\"toc-text\">this 是如何定义的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99\"><span class=\"toc-text\">this 绑定规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">this 绑定的优先级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85\"><span class=\"toc-text\">new 做了哪些事情</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create\"><span class=\"toc-text\">Object.create()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create-%E4%B8%8E-new-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Object.create 与 new 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">箭头函数与普通函数区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85-1\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB-class\"><span class=\"toc-text\">类 class</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">通过构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA\"><span class=\"toc-text\">编程方法论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是函数式编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向对象编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是面向过程编程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typescript\"><span class=\"toc-text\">typescript</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#type-%E4%B8%8E-interface-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">type 与 interface 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">相同点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">不同点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0%E4%B8%8A%EF%BC%9A1-%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">描述上：1. 都可以描述一个对象或者函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E4%B8%8A%EF%BC%9A-2-%E9%83%BD%E5%85%81%E8%AE%B8%E6%8B%93%E5%B1%95%EF%BC%88extends\"><span class=\"toc-text\">扩展上： 2. 都允许拓展（extends</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9-1\"><span class=\"toc-text\">不同点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-type-%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%8C%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%85%83%E7%BB%84%E7%AD%89%E7%B1%BB%E5%9E%8B-interface-%E4%B8%8D%E5%8F%AF%E4%BB%A5\"><span class=\"toc-text\">1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-type-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-typeof-%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E7%9A%84-%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC-interface-%E4%B8%8D%E5%8F%AF%E4%BB%A5\"><span class=\"toc-text\">2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#interface-%E8%83%BD%E5%A4%9F%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6-type-%E4%B8%8D%E8%A1%8C\"><span class=\"toc-text\">interface 能够声明合并(type 不行)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Typescript-%E4%B8%AD-extends-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">Typescript 中 extends 的作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">1、接口继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%99%AE%E9%80%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">2、普通条件判断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">3、泛型条件判断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">4、泛型约束</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React\"><span class=\"toc-text\">React</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%8A%E4%B8%8B-key\"><span class=\"toc-text\">聊下 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5-key\"><span class=\"toc-text\">为什么引入 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5-key-%E7%9A%84%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">引入 key 的背景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">key 解决这个问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E6%9C%89%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">key 有什么要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5-key-%E4%B8%8D%E4%BC%9A%E7%94%A8-index\"><span class=\"toc-text\">通常情况 key 不会用 index</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-key\"><span class=\"toc-text\">什么时候使用 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E5%9C%A8%E6%BA%90%E7%A0%81%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9A%84\"><span class=\"toc-text\">key 在源码单节点、多节点中的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diff-%E5%8D%95%E8%8A%82%E7%82%B9%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">diff [单节点、多节点]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hooks-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">hooks 产生的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A4%8D%E7%94%A8%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%E5%BE%88%E9%9A%BE\"><span class=\"toc-text\">在组件之间复用状态逻辑很难</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">复杂组件变得难以理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84-class\"><span class=\"toc-text\">难以理解的 class</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">useEffect 执行特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-useEffect-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1. useEffect 做了什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8-useEffect%EF%BC%9F\"><span class=\"toc-text\">2. 为什么在组件内部调用 useEffect？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-useEffect-%E4%BC%9A%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%90%8E%E9%83%BD%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3. useEffect 会在每次渲染后都执行吗？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BC%A0%E9%80%92%E7%BB%99-useEffect-%E7%9A%84%E5%87%BD%E6%95%B0%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E4%B8%AD%E9%83%BD%E4%BC%9A%E6%9C%89%E6%89%80%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">4. 传递给 useEffect 的函数在每次渲染中都会有所不同</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-effect-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">5. effect 异步执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8-effect-%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">6. 为什么要在 effect 中返回一个函数？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-React-%E4%BD%95%E6%97%B6%E6%B8%85%E9%99%A4-effect%EF%BC%9F\"><span class=\"toc-text\">7. React 何时清除 effect？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E4%BD%BF%E7%94%A8%E7%89%B9%E7%82%B9%E4%B8%8A%EF%BC%9F\"><span class=\"toc-text\">useEffect 使用特点上？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">useEffect 实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hook-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">Hook 使用规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">父子组件生命周期函数执行顺序：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-StrictMode\"><span class=\"toc-text\">严格模式 StrictMode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%B0%83\"><span class=\"toc-text\">协调</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">合成事件的捕获和冒泡如何实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">父子组件合成事件的捕获和冒泡执行顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">合成事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%BA%95%E5%B1%82%E4%BA%8B%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">要使用浏览器的底层事件？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">变化？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E8%A2%AB%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5%E8%A7%A6%E5%8F%91%EF%BC%9F\"><span class=\"toc-text\">在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8F%98%E6%9B%B4\"><span class=\"toc-text\">事件委托的变更</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%96%B0%E7%9A%84-JSX-%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">全新的 JSX 转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%AF%E4%BD%9C%E7%94%A8%E6%B8%85%E7%90%86%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">副作用清理时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React17-%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%94%B9\"><span class=\"toc-text\">React17 重大更改</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react18-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">react18 新特性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#git\"><span class=\"toc-text\">git</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-rebase-%E4%B8%8E-git-merge\"><span class=\"toc-text\">git rebase 与 git merge</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%9F%BA%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">变基原理：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">什么时候用哪个？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%A4%94\"><span class=\"toc-text\">🤔</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%98%E9%87%91%E5%B0%8F%E7%8C%AA%E8%AF%BE%E5%A0%82\"><span class=\"toc-text\">掘金小猪课堂</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">for…in 和 for…of 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript-%E4%B8%AD%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">JavaScript 中可迭代对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%A0%E7%A7%8D%E8%8E%B7%E5%8F%96-URL-%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">几种获取 URL 参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#clientHeight%E3%80%81offsetHeight%E3%80%81scrollHeight-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">clientHeight、offsetHeight、scrollHeight 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#childNodes-%E5%92%8C-children-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">childNodes 和 children 有什么区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ajax%E3%80%81Fetch%E3%80%81Axios-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Ajax、Fetch、Axios 三者的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89\"><span class=\"toc-text\">判断两个对象是否相等</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">将类数组转为数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">判断数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#session%E3%80%81cookie%E3%80%81token-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">session、cookie、token 的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-new-%E6%96%B9%E6%B3%95%EF%BC%81\"><span class=\"toc-text\">new 做了哪些操作？手写一个 new 方法！</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">跨标签页的通讯方式有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">为什么需要跨标签页通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E4%B8%BE\"><span class=\"toc-text\">列举</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%BA%90\"><span class=\"toc-text\">同源</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%90%8C%E6%BA%90%EF%BC%9A\"><span class=\"toc-text\">非同源：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">演示</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">源码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%90%8C%E6%BA%90\"><span class=\"toc-text\">非同源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#demo-%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">demo 代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#transition-%E5%92%8C-animation-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">transition 和 animation 的属性分别有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS3-font\"><span class=\"toc-text\">CSS3 font</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">柯里化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0\"><span class=\"toc-text\">为什么会出现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96-1\"><span class=\"toc-text\">柯里化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-promise-%E4%B8%8E-async-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">异步编程 promise 与 async 的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">async 特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">为什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E6%88%90\"><span class=\"toc-text\">构成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88-1\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">注意点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA-await-%E6%89%A7%E8%A1%8C%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">两个 await, 执行说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#async-x2F-await-%E5%92%8C-Promise-x2F-then-%E5%AF%B9%E6%AF%94%E4%BB%A5%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\"><span class=\"toc-text\">async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1-x2F-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">包装对象&#x2F;原型与原型链</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%AB%E4%B9%89\"><span class=\"toc-text\">包装对象的含义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承关系</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-freeze-vs-Object-seal-vs-Object-preventExtensions\"><span class=\"toc-text\">Object.freeze() vs Object.seal() vs Object.preventExtensions()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-freeze\"><span class=\"toc-text\">Object.freeze()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-seal\"><span class=\"toc-text\">Object.seal()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-preventExtensions\"><span class=\"toc-text\">Object.preventExtensions()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%86\"><span class=\"toc-text\">区分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">前端工程化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88-2\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-1\"><span class=\"toc-text\">为什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">如何实施前端工程化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-run-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">npm run 做了什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-install\"><span class=\"toc-text\">npm install</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-jsonp%EF%BC%8C%E4%BC%A0%E5%85%A5-URL%EF%BC%8Ccallback-%E5%92%8C-callbackName-%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">实现 jsonp，传入 URL，callback 和 callbackName 三个参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%94%9F-js-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-js-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">原生 js 实现动态加载 js 文件?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%B8%AD%E7%9A%84-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">js 中的 for 循环注意点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">new 操作符和点运算符的优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new-%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BC%9A%E5%A6%82%E4%BD%95\"><span class=\"toc-text\">new 一个构造函数，如果函数返回不同类型的值，结果会如何?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E9%83%BD%E4%B8%8D%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">什么都不返回</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">返回一个新的对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">返回一个原始值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-null\"><span class=\"toc-text\">返回 null</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-true\"><span class=\"toc-text\">返回 true</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E-this\"><span class=\"toc-text\">返回 this</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-apply-x2F-call-%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">为什么要用 apply&#x2F;call 这两个函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS\"><span class=\"toc-text\">CSS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#height-x2F-width\"><span class=\"toc-text\">height&#x2F;width</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#width-%E5%B1%9E%E6%80%A7-100-%E5%92%8C-auto-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">width 属性 100%和 auto 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vertical-align-middle\"><span class=\"toc-text\">vertical-align: middle</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#will-change\"><span class=\"toc-text\">will-change</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#z-index\"><span class=\"toc-text\">z-index</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%9B%92%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">介绍下盒模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CSS-%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84\"><span class=\"toc-text\">CSS 是怎么工作的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E9%81%87%E5%88%B0%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84-CSS-%E4%BB%A3%E7%A0%81%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">当浏览器遇到无法解析的 CSS 代码会发生什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82%E5%8F%A0%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">层叠、优先级和继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#important\"><span class=\"toc-text\">!important</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8E-performanceAPI-%E6%9D%A5%E8%AE%B2\"><span class=\"toc-text\">从 performanceAPI 来讲</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">协议优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">加载优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">渲染优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">缓存优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">更新优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E5%8F%AF%E8%A7%81%E6%80%A7-API\"><span class=\"toc-text\">页面可见性 API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%94%9F-js-%E6%B7%B1%E6%8B%B7%E8%B4%9D-x2F-%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">原生 js 深拷贝&#x2F;浅拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">浅拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">深拷贝</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-native\"><span class=\"toc-text\">react-native</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-native-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">react-native 新特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-native-%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9A%84%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">react-native 与原生的通信</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React中的术语","uid":"4cfbb91d77b5df4256b735640b2a3f88","slug":"2022-09-19react","date":"2022-09-19T12:42:20.000Z","updated":"2022-09-20T12:57:05.700Z","comments":true,"path":"api/articles/2022-09-19react.json","keywords":null,"cover":null,"text":"浅合并this.setState 会进行浅合并 falsyfalsy 表达式 MDN 8 个 falsy 值 &#x2F;&#x2F; | 值 | 说明 | &#x2F;&#x2F; | :-------- | :---------------------------------...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"React","slug":"React","count":34,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":28,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"vscode 常用快捷键（持续更新...）","uid":"5380d0b3be253a4f070c3aa29aef0cf7","slug":"2022-09-17vscode-shortcuts","date":"2022-09-17T13:55:58.000Z","updated":"2023-02-20T21:20:56.471Z","comments":true,"path":"api/articles/2022-09-17vscode-shortcuts.json","keywords":null,"cover":"https://www.ymama.net/config/ueditor/php/upload/image/20200827/1598515434460503.png","text":"直接换行cmd + enter; 选中多个相同的元素cmd + d; &#x2F;&#x2F; 每次向后多选一个相同的 选中相同内容cmd + shift + L; &#x2F;&#x2F; 全文，选相同内容 多位置同时编辑cmd + 点击; 选择一块内容cmd + shift ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"vscode","slug":"vscode","count":8,"path":"api/categories/vscode.json"}],"tags":[{"name":"vscode","slug":"vscode","count":11,"path":"api/tags/vscode.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}