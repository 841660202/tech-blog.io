{"title":"Tree","uid":"d40bc58623f2003592cb7592af431750","slug":"2022-12-21tree","date":"2022-12-21T01:33:18.000Z","updated":"2022-12-22T13:36:21.803Z","comments":true,"path":"api/articles/2022-12-21tree.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202212211225980.webp","content":"<h2 id=\"需求按照权限进行树的渲染\"><a href=\"#需求按照权限进行树的渲染\" class=\"headerlink\" title=\"需求按照权限进行树的渲染\"></a>需求按照权限进行树的渲染</h2><ol>\n<li>权限控制树的渲染，从根节点开始渲染</li>\n<li>权限 paths 为空，全部可见，权限 paths 为<code>[&#39;/1&#39;]</code>即根节点，全部可见</li>\n<li>权限 paths 非空，父子路径关系的前端需要去重，只保留父路径</li>\n<li>有父路径权限的，其子路径部门&#x2F;员工全部可见</li>\n<li>去重后，子路径没有父路径的，需要渲染，根节点…至子节点路径的所有部门，不渲染无关子节点和员工</li>\n<li>非叶子节点的部门不可选中</li>\n</ol>\n<h2 id=\"处理步骤\"><a href=\"#处理步骤\" class=\"headerlink\" title=\"处理步骤\"></a>处理步骤</h2><ol>\n<li>判断 paths 是否为空数组，如果是，全部可见</li>\n<li>否则，对 paths 进行整理，按照路径长度进行分组，按照分组进行去重，只保留叶子节点的部门</li>\n<li>对去重后的数据进行转化，找到连续的 paths 路径 如果<code>[&#39;1/2/3/4/5&#39;] =&gt; [&#39;/1/&#39;, &#39;/1/2/&#39;, &#39;1/2/3/&#39;, &#39;1/2/3/4/&#39; , &#39;1/2/3/4/5/&#39;]</code></li>\n<li>转化成<code>map</code>优化后续检测</li>\n<li>由于 paths 的转化浪费性能，所以进行必要的必包缓存</li>\n<li>暴露 api:<ol>\n<li>全部可见</li>\n<li>检测部门的 staffs 是否应该展示</li>\n<li>检测部门是否展示（对部门数据进行去重）</li>\n<li>部门是否为叶子节点可以被选中</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"原数据，用于产出测试数据\"><a href=\"#原数据，用于产出测试数据\" class=\"headerlink\" title=\"原数据，用于产出测试数据\"></a>原数据，用于产出测试数据</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var data &#x3D; &#123;\n  success: true,\n  msg: &quot;请求成功&quot;,\n  errCode: null,\n  result: &#123;\n    staffs: [\n      &#123;\n        staffId: &quot;00001&quot;,\n        staffNo: &quot;00001&quot;,\n        belongToOrgs: null,\n      &#125;,\n      &#123;\n        staffId: &quot;00002&quot;,\n        staffNo: &quot;00002&quot;,\n        belongToOrgs: null,\n      &#125;,\n    ],\n    orgs: [\n      &#123;\n        orgId: 3,\n        path: &quot;&#x2F;1&#x2F;3&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n      &#123;\n        orgId: 116,\n        path: &quot;&#x2F;1&#x2F;116&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n      &#123;\n        orgId: 119,\n        path: &quot;&#x2F;1&#x2F;119&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n      &#123;\n        orgId: 28,\n        path: &quot;&#x2F;1&#x2F;28&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n    ],\n  &#125;,\n&#125;;\n&#x2F;&#x2F; 转化查询数据\n&#x2F;&#x2F; var result &#x3D; []\n&#x2F;&#x2F; data.result.orgs.forEach((item) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   result.push(item.path)\n&#x2F;&#x2F; &#125;)\n&#x2F;&#x2F; copy(result);</code></pre>\n\n<h2 id=\"两组测试数据\"><a href=\"#两组测试数据\" class=\"headerlink\" title=\"两组测试数据\"></a>两组测试数据</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var l2 &#x3D; [\n  &quot;&#x2F;1&#x2F;3&quot;,\n  &quot;&#x2F;1&#x2F;116&quot;,\n  &quot;&#x2F;1&#x2F;119&quot;,\n  &quot;&#x2F;1&#x2F;28&quot;,\n  &quot;&#x2F;1&#x2F;120&quot;,\n  &quot;&#x2F;1&#x2F;121&quot;,\n  &quot;&#x2F;1&#x2F;122&quot;,\n  &quot;&#x2F;1&#x2F;29&quot;,\n  &quot;&#x2F;1&#x2F;908&quot;,\n  &quot;&#x2F;1&#x2F;4&quot;,\n  &quot;&#x2F;1&#x2F;6&quot;,\n  &quot;&#x2F;1&#x2F;757&quot;,\n  &quot;&#x2F;1&#x2F;9&quot;,\n  &quot;&#x2F;1&#x2F;2974&quot;,\n  &quot;&#x2F;1&#x2F;7&quot;,\n  &quot;&#x2F;1&#x2F;8&quot;,\n  &quot;&#x2F;1&#x2F;1731&quot;,\n  &quot;&#x2F;1&#x2F;3885&quot;,\n  &quot;&#x2F;1&#x2F;10&quot;,\n  &quot;&#x2F;1&#x2F;11&quot;,\n  &quot;&#x2F;1&#x2F;4082&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;2098&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;48&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;3593&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;877&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;93&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;4&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&quot;,\n];\n\nvar l3 &#x3D; [&quot;&#x2F;1&quot;, &quot;&#x2F;1&#x2F;3&#x2F;2098&quot;, &quot;&#x2F;1&#x2F;3&#x2F;48&quot;, &quot;&#x2F;1&#x2F;3&#x2F;3593&quot;, &quot;&#x2F;1&#x2F;3&#x2F;877&quot;, &quot;&#x2F;1&#x2F;3&#x2F;1417&quot;];</code></pre>\n\n<h2 id=\"数据格式化成带有-prefix-字段\"><a href=\"#数据格式化成带有-prefix-字段\" class=\"headerlink\" title=\"数据格式化成带有 prefix 字段\"></a>数据格式化成带有 prefix 字段</h2><ul>\n<li>prefix 字段 可用来向前匹配</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 格式化数据，优化遍历\n * @param &#123;*&#125; paths\n * @returns\n *&#x2F;\nconst formPathsToPrefixItems &#x3D; (paths) &#x3D;&gt; &#123;\n  const path_dept &#x3D; [];\n  const deptsSet &#x3D; new Set();\n  const groupObj &#x3D; &#123;&#125;;\n  const pathArr &#x3D; paths.map((path) &#x3D;&gt; &#123;\n    const dept &#x3D; path.split(&quot;&#x2F;&quot;).length - 1;\n\n    deptsSet.add(dept);\n\n    const item &#x3D; &#123;\n      path,\n      dept,\n      prefix_path: path + &quot;&#x2F;&quot;,\n    &#125;;\n\n    groupObj[dept] &#x3D; [].concat(groupObj[dept] || []).concat(item);\n\n    return item;\n  &#125;);\n  return &#123;\n    pathArr,\n    deptArr: Array.from(deptsSet).sort(),\n    groupObj,\n  &#125;;\n&#125;;\n\nconst formPathResults &#x3D; formPathsToPrefixItems(l2);\n\nconsole.log(&quot;formPathResults&quot;, formPathResults);</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; &#x2F;&#x2F; 清理节点\n\n&#x2F;&#x2F; &#x2F;&#x2F; - 如果有父节点，就不再进行自节点过滤\n\n&#x2F;&#x2F; const prefix_path2map &#x3D; (datas) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   const map &#x3D; new Map()\n\n&#x2F;&#x2F;   datas.forEach((item) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     map.set(item.prefix_path, item)\n&#x2F;&#x2F;   &#125;)\n\n&#x2F;&#x2F;   console.log(&#39;map&#39;, map)\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; prefix_path2map(formPathResults.pathArr)\n\n&#x2F;&#x2F; console.log(&#39;pathSet&#39;, formPathResults.deptsSet)\n\n&#x2F;&#x2F; &#x2F;&#x2F; 一级剩余的树，二级剩余的树，三级剩余的树\n\n&#x2F;&#x2F; &#x2F;&#x2F; 对paths进行分组\n\n&#x2F;&#x2F; const prefix_path2GropMap &#x3D; (datas) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   const gropMap &#x3D; new Map()\n\n&#x2F;&#x2F;   datas.forEach((item) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     map.set(item.prefix_path, item)\n&#x2F;&#x2F;   &#125;)\n\n&#x2F;&#x2F;   console.log(&#39;map&#39;, map)\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; groupObj\n&#x2F;&#x2F; deptSet\n&#x2F;&#x2F; filterData\n\n&#x2F;&#x2F; console.log(JSON.stringify(formPathResults.pathArr, null, 1))\n&#x2F;&#x2F; console.log(formPathResults.deptArr)\n&#x2F;&#x2F; console.log(JSON.stringify(formPathResults, null, 2))</code></pre>\n\n<h2 id=\"数据去重\"><a href=\"#数据去重\" class=\"headerlink\" title=\"数据去重\"></a>数据去重</h2><p>去重规则：<code>[&#39;/1&#39;,&#39;/1/2&#39;, &#39;/1/3/4&#39;]</code> &#x3D;&gt; <code>[&#39;/1&#39;]</code><br>去重规则：<code>[&#39;/1/2&#39;, &#39;/1/3/4&#39;]</code> &#x3D;&gt; <code>[&#39;/1/2&#39;, &#39;/1/3/4&#39;]</code></p>\n<p>即：路径有子路径，只保留父路径</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 数据去重\n * @param &#123;*&#125; param0\n * @returns\n *&#x2F;\nconst filterPath &#x3D; (&#123; deptArr, groupObj &#125;) &#x3D;&gt; &#123;\n  deptArr.forEach((dept, index) &#x3D;&gt; &#123;\n    const c_arr &#x3D; groupObj[dept];\n    c_arr.forEach((pathItem) &#x3D;&gt; &#123;\n      const &#123; prefix_path &#125; &#x3D; pathItem;\n      deptArr.slice(index + 1).forEach((largeDept) &#x3D;&gt; &#123;\n        const arr &#x3D; groupObj[largeDept];\n        groupObj[largeDept] &#x3D; arr.filter(\n          (item) &#x3D;&gt; !item.prefix_path.includes(prefix_path)\n        );\n      &#125;);\n    &#125;);\n  &#125;);\n\n  return groupObj;\n&#125;;\n\nconst filterResult &#x3D; filterPath(formPathResults);\n\nconsole.log(filterResult);</code></pre>\n\n<h2 id=\"工具方法\"><a href=\"#工具方法\" class=\"headerlink\" title=\"工具方法\"></a>工具方法</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 对象转化成数组\n * @param &#123;*&#125; obj\n * @returns\n *&#x2F;\nconst obj2Arr &#x3D; (obj) &#x3D;&gt; &#123;\n  let arr &#x3D; [];\n  for (const [k, v] of Object.entries(obj)) &#123;\n    arr &#x3D; arr.concat(v);\n  &#125;\n  return arr;\n&#125;;</code></pre>\n\n<h2 id=\"格式化可见\"><a href=\"#格式化可见\" class=\"headerlink\" title=\"格式化可见\"></a>格式化可见</h2><ul>\n<li>paths 未传，全部可见</li>\n<li>paths 有传，按照 paths 进行处理</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const formatViews &#x3D; (paths) &#x3D;&gt; &#123;\n  let viewAll &#x3D; false;\n  if (Array.isArray(paths) &amp;&amp; paths.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    viewAll &#x3D; true;\n  &#125;\n  const prefix_paths &#x3D; obj2Arr(filterPath(formPathsToPrefixItems(paths))).map(\n    (item) &#x3D;&gt; item.prefix_path\n  );\n  return &#123;\n    viewAll,\n    prefix_paths,\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; console.log(&#39;formatViews(l2)&#39;, formatViews(l2))\nconsole.log(&quot;formatViews(l3)&quot;, formatViews(l3));\n&#x2F;&#x2F; console.log(&#39;formatViews([])&#39;, formatViews([]))</code></pre>\n\n<h2 id=\"将-path-进行转树\"><a href=\"#将-path-进行转树\" class=\"headerlink\" title=\"将 path 进行转树\"></a>将 path 进行转树</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const pathToTree &#x3D; (input) &#x3D;&gt; &#123;\n  let root &#x3D; [];\n  for (let i &#x3D; 0; i &lt; input.length; i++) &#123;\n    let chain &#x3D; input[i].split(&quot;&#x2F;&quot;);\n    let currentHierarchy &#x3D; root;\n    for (let j &#x3D; 0; j &lt; chain.length; j++) &#123;\n      let wantedNode &#x3D; chain[j];\n      if (wantedNode &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;\n        continue;\n      &#125;\n      let lastHierarchy &#x3D; currentHierarchy;\n      &#x2F;&#x2F; 遍历root是否已有该层级\n      for (let k &#x3D; 0; k &lt; currentHierarchy.length; k++) &#123;\n        if (currentHierarchy[k].orgId &#x3D;&#x3D;&#x3D; wantedNode) &#123;\n          currentHierarchy &#x3D; currentHierarchy[k].children;\n          break;\n        &#125;\n      &#125;\n      if (lastHierarchy &#x3D;&#x3D;&#x3D; currentHierarchy) &#123;\n        let path;\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          path &#x3D; input[i];\n        &#125; else &#123;\n          path &#x3D; chain.slice(0, j + 1).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n        &#125;\n        let newNode &#x3D; &#123;\n          path: path,\n          orgId: wantedNode,\n          children: [],\n        &#125;;\n        &#x2F;&#x2F; 文件，最后一个字符不是&quot;&#x2F;“符号\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          delete newNode.children;\n        &#125;\n        currentHierarchy.push(newNode);\n        currentHierarchy &#x3D; newNode.children;\n      &#125;\n    &#125;\n  &#125;\n  return root;\n&#125;;\n\n&#x2F;&#x2F; 去重（因后端数据不够准确，放到前端去重）\n&#x2F;&#x2F; console.log(\n&#x2F;&#x2F;   &#39;pathToTree(formatViews(l2).prefix_paths)&#39;,\n&#x2F;&#x2F;   JSON.stringify(pathToTree(formatViews(l2).prefix_paths), null, 2),\n&#x2F;&#x2F; )\n\nconst v_tree &#x3D; pathToTree(formatViews(l2).prefix_paths);</code></pre>\n\n<h2 id=\"将树转化成-map，用于后续的节点检测\"><a href=\"#将树转化成-map，用于后续的节点检测\" class=\"headerlink\" title=\"将树转化成 map，用于后续的节点检测\"></a>将树转化成 map，用于后续的节点检测</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 匹配 对长路径进行拆分，长路径才是，有限权限，（有限权限过程可见，不可操作），对应的叶子节点可以操作\n&#x2F;&#x2F; 整合成map转化成是否有子节点情况的查询，\n&#x2F;&#x2F;    - 如果没有子节点，则：后代可见，\n&#x2F;&#x2F;    - 如果有子节点，则仅对应子节点可见\nconst treeToMap &#x3D; (tree, map) &#x3D;&gt; &#123;\n  if (Array.isArray(tree) &amp;&amp; tree.length &gt; 0) &#123;\n    tree.forEach((item) &#x3D;&gt; &#123;\n      if (item.children?.length &#x3D;&#x3D;&#x3D; 0) &#123;\n        map.set(item.path, &quot;叶子结点&quot;);\n      &#125; else &#123;\n        map.set(item.path, &quot;枝干&quot;);\n      &#125;\n\n      if (Array.isArray(item.children)) &#123;\n        treeToMap(item.children, map);\n      &#125;\n    &#125;);\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"节点是否存在\"><a href=\"#节点是否存在\" class=\"headerlink\" title=\"节点是否存在\"></a>节点是否存在</h2><ul>\n<li>使用必包，实现数据缓存</li>\n<li>使用科里化优化调用</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 叶子结点\n\nfunction existLeafNode() &#123;\n  let leafNodeMap &#x3D; new Map();\n  treeToMap(v_tree, leafNodeMap);\n  console.log(&quot;leafNodeMap&quot;, leafNodeMap);\n  return function (path) &#123;\n    const slitpaths &#x3D; path.split(&quot;&#x2F;&quot;);\n    &#x2F;&#x2F; console.log(&#39;slitpaths&#39;, slitpaths)\n    for (let i &#x3D; slitpaths.length; i &gt; 1; i &#x3D; i - 1) &#123;\n      const s &#x3D; slitpaths.slice(0, i - 1).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n      if (s &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        continue;\n      &#125;\n      if (leafNodeMap.has(s)) return true;\n    &#125;\n    return false;\n  &#125;;\n&#125;\n\nconst existFunc &#x3D; existLeafNode();\n\nconsole.log(&quot;&#x2F;1&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;93&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;93&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;1&quot;, existFunc(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;1&quot;));\nconsole.log(&quot;&#x2F;2&#x2F;12&quot;, existFunc(&quot;&#x2F;2&#x2F;12&quot;));\n\nconst ddd &#x3D; [&quot;&#x2F;1&#x2F;5&#x2F;6&quot;, &quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;1&quot;];</code></pre>\n\n<h2 id=\"完整去除测试代码-封装成-hook\"><a href=\"#完整去除测试代码-封装成-hook\" class=\"headerlink\" title=\"完整去除测试代码(封装成 hook)\"></a>完整去除测试代码(封装成 hook)</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; useMemoizedFn &#125; from &quot;ahooks&quot;;\nimport &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\n&#x2F;**\n * 格式化数据，优化遍历\n * @param &#123;*&#125; paths\n * @returns\n *&#x2F;\nconst formPathsToPrefixItems &#x3D; (paths) &#x3D;&gt; &#123;\n  const deptsSet &#x3D; new Set();\n  const groupObj &#x3D; &#123;&#125;;\n  const pathArr &#x3D; paths.map((path) &#x3D;&gt; &#123;\n    const dept &#x3D; path.split(&quot;&#x2F;&quot;).length - 1;\n\n    deptsSet.add(dept);\n\n    const item &#x3D; &#123;\n      path,\n      dept,\n      prefix_path: path + &quot;&#x2F;&quot;,\n    &#125;;\n\n    groupObj[dept] &#x3D; ([] as any).concat(groupObj[dept] || []).concat(item);\n\n    return item;\n  &#125;);\n  return &#123;\n    pathArr,\n    deptArr: Array.from(deptsSet).sort(),\n    groupObj,\n  &#125;;\n&#125;;\n&#x2F;* &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; *&#x2F;\n&#x2F;&#x2F; 1. 数据去重\n&#x2F;&#x2F; 2. 数据拆分-枝干，节点\n&#x2F;&#x2F; 3. node是否展示\n\n&#x2F;**\n * 数据去重\n * @param &#123;*&#125; param0\n * @returns\n *&#x2F;\nconst filterPath &#x3D; (&#123; deptArr, groupObj &#125;) &#x3D;&gt; &#123;\n  deptArr.forEach((dept, index) &#x3D;&gt; &#123;\n    const c_arr &#x3D; groupObj[dept];\n    c_arr.forEach((pathItem) &#x3D;&gt; &#123;\n      const &#123; prefix_path &#125; &#x3D; pathItem;\n      deptArr.slice(index + 1).forEach((largeDept) &#x3D;&gt; &#123;\n        const arr &#x3D; groupObj[largeDept];\n        groupObj[largeDept] &#x3D; arr.filter(\n          (item) &#x3D;&gt; !item.prefix_path.includes(prefix_path)\n        );\n      &#125;);\n    &#125;);\n  &#125;);\n\n  return groupObj;\n&#125;;\n\n&#x2F;**\n * 对象转化成数组\n * @param &#123;*&#125; obj\n * @returns\n *&#x2F;\nconst obj2Arr &#x3D; (obj) &#x3D;&gt; &#123;\n  let arr: any &#x3D; [];\n  for (const [k, v] of Object.entries(obj)) &#123;\n    arr &#x3D; arr.concat(v);\n  &#125;\n  return arr;\n&#125;;\n&#x2F;**\n * 全部展示\n * @param paths\n * @returns\n *&#x2F;\nconst formatViews &#x3D; (paths) &#x3D;&gt; &#123;\n  let authAll &#x3D; false;\n  if (Array.isArray(paths) &amp;&amp; paths.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    authAll &#x3D; true;\n  &#125;\n  const prefix_paths &#x3D; obj2Arr(filterPath(formPathsToPrefixItems(paths))).map(\n    (item) &#x3D;&gt; item.prefix_path\n  );\n  return &#123;\n    authAll,\n    prefix_paths,\n  &#125;;\n&#125;;\n&#x2F;**\n *\n * @param input\n * @returns\n *&#x2F;\nconst pathToTree &#x3D; (input) &#x3D;&gt; &#123;\n  let root: any[] &#x3D; [];\n  for (let i &#x3D; 0; i &lt; input.length; i++) &#123;\n    let chain &#x3D; input[i].split(&quot;&#x2F;&quot;);\n    let currentHierarchy &#x3D; root;\n    for (let j &#x3D; 0; j &lt; chain.length; j++) &#123;\n      let wantedNode &#x3D; chain[j];\n      if (wantedNode &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;\n        continue;\n      &#125;\n      let lastHierarchy &#x3D; currentHierarchy;\n      &#x2F;&#x2F; 遍历root是否已有该层级\n      for (let k &#x3D; 0; k &lt; currentHierarchy.length; k++) &#123;\n        if (currentHierarchy[k].orgId &#x3D;&#x3D;&#x3D; wantedNode) &#123;\n          currentHierarchy &#x3D; currentHierarchy[k].children;\n          break;\n        &#125;\n      &#125;\n      if (lastHierarchy &#x3D;&#x3D;&#x3D; currentHierarchy) &#123;\n        let path;\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          path &#x3D; input[i];\n        &#125; else &#123;\n          path &#x3D; chain.slice(0, j + 1).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n        &#125;\n        let newNode: any &#x3D; &#123;\n          path: path,\n          orgId: wantedNode,\n          children: [],\n        &#125;;\n        &#x2F;&#x2F; 文件，最后一个字符不是&quot;&#x2F;“符号\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          delete newNode.children;\n        &#125;\n        currentHierarchy.push(newNode);\n        currentHierarchy &#x3D; newNode.children;\n      &#125;\n    &#125;\n  &#125;\n  return root;\n&#125;;\n\n&#x2F;&#x2F; 匹配 对长路径进行拆分，长路径才是，有限权限，（有限权限过程可见，不可操作），对应的叶子节点可以操作\n&#x2F;&#x2F; 整合成map转化成是否有子节点情况的查询，\n&#x2F;&#x2F;    - 如果没有子节点，则：后代可见，\n&#x2F;&#x2F;    - 如果有子节点，则仅对应子节点可见\n\nenum EType &#123;\n  leaf &#x3D; &quot;下全可见&quot;,\n  has_child &#x3D; &quot;仍需判断&quot;,\n&#125;\n&#x2F;**\n *\n * @param tree\n * @param map\n *&#x2F;\nconst treeToMap &#x3D; (tree, map) &#x3D;&gt; &#123;\n  if (Array.isArray(tree) &amp;&amp; tree.length &gt; 0) &#123;\n    tree.forEach((item) &#x3D;&gt; &#123;\n      if (item.children?.length &#x3D;&#x3D;&#x3D; 0) &#123;\n        map.set(item.path, EType.leaf);\n      &#125; else &#123;\n        map.set(item.path, EType.has_child);\n      &#125;\n\n      if (Array.isArray(item.children)) &#123;\n        treeToMap(item.children, map);\n      &#125;\n    &#125;);\n  &#125;\n&#125;;\n&#x2F;**\n * 节点是否应该存在\n * @param leafNodeMap\n * @returns\n *&#x2F;\nfunction existLeafNode(leafNodeMap) &#123;\n  return function (path, isStaff &#x3D; false) &#123;\n    if (\n      (!isStaff &amp;&amp; leafNodeMap.has(path + &quot;&#x2F;&quot;)) ||\n      (isStaff &amp;&amp; leafNodeMap.get(path + &quot;&#x2F;&quot;) &#x3D;&#x3D;&#x3D; EType.leaf)\n    ) &#123;\n      return true;\n    &#125;\n    const slitpaths &#x3D; path.split(&quot;&#x2F;&quot;);\n    for (let i &#x3D; slitpaths.length; i &gt; 1; i &#x3D; i - 1) &#123;\n      const s &#x3D; slitpaths.slice(0, i).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n      if (s &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        continue;\n      &#125;\n      if (leafNodeMap.has(s)) &#123;\n        return leafNodeMap.get(s) &#x3D;&#x3D;&#x3D; EType.leaf;\n      &#125;\n    &#125;\n    return false;\n  &#125;;\n&#125;\n&#x2F;**\n * 是否是可选的部门节点\n * @param leafNodeMap\n * @returns\n *&#x2F;\nfunction isLeafOrgSelectableNode(leafNodeMap) &#123;\n  return function (path) &#123;\n    return leafNodeMap.get(path + &quot;&#x2F;&quot;) &#x3D;&#x3D;&#x3D; EType.leaf;\n  &#125;;\n&#125;\n\n&#x2F;**\n * hook\n * @param list\n * @returns\n *&#x2F;\nexport const useExistNode &#x3D; (list) &#x3D;&gt; &#123;\n  const refExistNode &#x3D; useRef&lt;any&gt;();\n  const refAll &#x3D; useRef(false);\n  const refIsOrgSelectableNode &#x3D; useRef&lt;any&gt;();\n\n  useEffect(() &#x3D;&gt; &#123;\n    const &#123; prefix_paths, authAll &#125; &#x3D; formatViews(list);\n    &#x2F;&#x2F; 查看全部\n    if (authAll) &#123;\n      refAll.current &#x3D; authAll;\n\n      refExistNode.current &#x3D; () &#x3D;&gt; &#123;\n        return true;\n      &#125;;\n      refIsOrgSelectableNode.current &#x3D; () &#x3D;&gt; &#123;\n        return true;\n      &#125;;\n\n      &#x2F;&#x2F;部分可见\n    &#125; else &#123;\n      refAll.current &#x3D; false;\n\n      const v_tree &#x3D; pathToTree(prefix_paths);\n      let leafNodeMap &#x3D; new Map();\n      treeToMap(v_tree, leafNodeMap);\n\n      refExistNode.current &#x3D; existLeafNode(leafNodeMap);\n      refIsOrgSelectableNode.current &#x3D; isLeafOrgSelectableNode(leafNodeMap);\n    &#125;\n  &#125;, [list]);\n\n  const filterNodes &#x3D; useMemoizedFn((list) &#x3D;&gt;\n    list.filter((item) &#x3D;&gt; refExistNode.current(item.path))\n  );\n\n  return [\n    refAll.current,\n    refExistNode.current,\n    filterNodes,\n    refIsOrgSelectableNode.current,\n  ];\n&#125;;\n&#x2F;**\n * 对树员工数据进行编码，同一员工存在不同部门，需要保证key唯一，否则渲染会有奇葩的效果\n *&#x2F;\nexport const formatOptionStaffs &#x3D; (staffs) &#x3D;&gt; &#123;\n  if (Array.isArray(staffs)) &#123;\n    return staffs?.map((item) &#x3D;&gt; &#123;\n      const mainOrg &#x3D; item.belongToOrgs.find((item) &#x3D;&gt; item.mainDutyFlag &#x3D;&#x3D;&#x3D; 1);\n      return &#123;\n        ...item,\n        key: mainOrg?.orgId\n          ? &#96;$&#123;mainOrg?.orgId&#125;-$&#123;item.staffId&#125;&#96;\n          : &#96;$&#123;item.staffId&#125;&#96;,\n      &#125;;\n    &#125;);\n  &#125;\n  return [];\n&#125;;</code></pre>\n","text":"需求按照权限进行树的渲染 权限控制树的渲染，从根节点开始渲染 权限 paths 为空，全部可见，权限 paths 为[&#39;/1&#39;]即根节点，全部可见 权限 paths 非空，父子路径关系的前端需要去重，只保留父路径 有父路径权限的，其子路径部门&#x2F;员工全部可...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"Tree","slug":"Tree","count":1,"path":"api/categories/Tree.json"}],"tags":[{"name":"Tree","slug":"Tree","count":1,"path":"api/tags/Tree.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9C%80%E6%B1%82%E6%8C%89%E7%85%A7%E6%9D%83%E9%99%90%E8%BF%9B%E8%A1%8C%E6%A0%91%E7%9A%84%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">需求按照权限进行树的渲染</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">处理步骤</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BA%A7%E5%87%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">原数据，用于产出测试数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%BB%84%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">两组测试数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%88%90%E5%B8%A6%E6%9C%89-prefix-%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">数据格式化成带有 prefix 字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D\"><span class=\"toc-text\">数据去重</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">工具方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8F%AF%E8%A7%81\"><span class=\"toc-text\">格式化可见</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%86-path-%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%A0%91\"><span class=\"toc-text\">将 path 进行转树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%86%E6%A0%91%E8%BD%AC%E5%8C%96%E6%88%90-map%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%90%8E%E7%BB%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">将树转化成 map，用于后续的节点检测</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">节点是否存在</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E5%8E%BB%E9%99%A4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-%E5%B0%81%E8%A3%85%E6%88%90-hook\"><span class=\"toc-text\">完整去除测试代码(封装成 hook)</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"a 链接 color无效","uid":"20f0bf3c93eae96e0413417a3ffb6073","slug":"2022-12-21a","date":"2022-12-21T09:57:01.000Z","updated":"2022-12-22T13:36:21.802Z","comments":true,"path":"api/articles/2022-12-21a.json","keywords":null,"cover":"https://img1.baidu.com/it/u=1826751777,2960439106&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500","text":"背景在查看之前文章，进行完善的时候遇到了 a 标签 color无效，即使是使用了内连样式 + !important仍然无效 实现原理 2022-11-01 抽象相等比较 问题所在一点点调试发现是 -webkit-text-fill-color在捣蛋 背后依据-webkit-tex...","link":"","photos":[],"count_time":{"symbolsCount":395,"symbolsTime":"1 mins."},"categories":[{"name":"CSS","slug":"CSS","count":4,"path":"api/categories/CSS.json"}],"tags":[{"name":"CSS","slug":"CSS","count":4,"path":"api/tags/CSS.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"jwt Bearer 的作用","uid":"d924cc13ecef19a5718fd1f83f8206d4","slug":"2022-12-14jwt","date":"2022-12-14T07:37:53.000Z","updated":"2022-12-22T13:36:21.802Z","comments":true,"path":"api/articles/2022-12-14jwt.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202212211225980.webp","text":"规范要求 w3c 规定 Authorization: &lt;type&gt; &lt;credentials&gt; 认证的方式type, 具体信息credentials 可以不加吗可以 如果是遵循规范，需要加 如果是不遵循规范，可不加 参考链接jwt token 为什么要在前...","link":"","photos":[],"count_time":{"symbolsCount":160,"symbolsTime":"1 mins."},"categories":[{"name":"Go","slug":"Go","count":15,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":15,"path":"api/tags/Go.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}