{"title":"RN performance","uid":"a625702239d2378e2ca779050afa4d60","slug":"2023-02-19rn-performance","date":"2023-02-19T09:11:10.000Z","updated":"2023-05-15T13:17:32.986Z","comments":true,"path":"api/articles/2023-02-19rn-performance.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202302171928314.webp","content":"<h2 id=\"bundle-优化\"><a href=\"#bundle-优化\" class=\"headerlink\" title=\"bundle 优化\"></a>bundle 优化</h2><h3 id=\"bundle-优化速览\"><a href=\"#bundle-优化速览\" class=\"headerlink\" title=\"bundle 优化速览\"></a>bundle 优化速览</h3><ol>\n<li><code>环境预创建</code></li>\n<li><code>异步检测、下载</code></li>\n<li><code>公用资源拆包</code></li>\n<li><code>按需加载</code></li>\n<li><code>新版本</code></li>\n</ol>\n<h3 id=\"一、React-Native-环境预创建\"><a href=\"#一、React-Native-环境预创建\" class=\"headerlink\" title=\"一、React Native 环境预创建\"></a>一、React Native 环境预创建</h3><p>一个载体页一个引擎。</p>\n<p>通常，一个 React Native 页面从加载渲染到展示大致分为以下几步：</p>\n<pre class=\"line-numbers language-s\" data-language=\"s\"><code class=\"language-s\">【React Native 环境初始化】 -&gt; 【下载&#x2F;加载 bundle】 -&gt; 【执行 JavaScript 代码】</code></pre>\n\n<p>在 Android 环境中是特别耗时的。所以，我们想到的第一个优化点就是提前将 React Native 环境创建好</p>\n<h3 id=\"二、异步更新-rn-更新思路\"><a href=\"#二、异步更新-rn-更新思路\" class=\"headerlink\" title=\"二、异步更新(rn 更新思路)\"></a>二、异步更新(rn 更新思路)</h3><p>原先我们进入 React Native 载体页后需要先下载最新的 JavaScript 代码包版本，若有更新，就要下载最新的包并加载。在这个过程中，我们会经历两次网络请求，即获取是否有更新，如果有下载热更新的 bundle 包。如果用户网络比较差，下载 bundle 包就会很慢，最终等待时间也会较长。</p>\n<p>针对部分特殊的页面，采取了异步更新的策略。异步更新策略的主要思路为:</p>\n<ol>\n<li>在进入页面之前选择性地提前下载 JavaScript 代码包，</li>\n<li>进入载体页后再看 JavaScript 代码包是否有缓存，如果有，我们就优先加载缓存并渲染；</li>\n<li>然后再异步检测是否有最新版本的 JavaScript 代码包，</li>\n<li>如果有，下载到本地并进行缓存，再等下次进入载体页时生效。</li>\n</ol>\n<h4 id=\"优化前\"><a href=\"#优化前\" class=\"headerlink\" title=\"优化前\"></a>优化前</h4><img src=\"https://pic3.zhimg.com/80/v2-f14c91af94e5e4068609322e4b1b73de_1440w.webp\" style=\"width:300px;max-width:100%\" />\n\n<p>打开一个 RN 页面所需要经历的一些流程。流程图中可以看出，我们从进入载体页到渲染页面，需要两次网络请求，不管网速快还是慢，这个流程算是比较漫长的</p>\n<h4 id=\"优化后\"><a href=\"#优化后\" class=\"headerlink\" title=\"优化后\"></a>优化后</h4><p><strong>渲染与版本检测进行分离</strong>，在进行异步更新后，我们的流程就会变成下图这样</p>\n<img src=\"https://pic1.zhimg.com/80/v2-1ffaba651fe459cfcd94575558b05340_1440w.webp\" style=\"width:300px;max-width:100%\" />\n\n<h4 id=\"更新时机\"><a href=\"#更新时机\" class=\"headerlink\" title=\"更新时机\"></a>更新时机</h4><p><strong>提前下载业务代码包</strong></p>\n<p>在业务页面中，我们可以对 JavaScript 代码包进行提前下载并缓存，在用户跳转到 React Native 页面后，检测是否有缓存的 JavaScript 代码包，如果有我们就直接渲染页面。这样就不需要等待版本号检测网络接口以及下载最新包的网络接口，也不依赖于用户的网络情况，减少了用户等待时间。</p>\n<p><strong>非必要更新，下次启动后生效</strong></p>\n<p>在渲染页面的同时，我们通过异步检测 JavaScript 代码包的版本，若有新版本就进行更新并缓存，下次生效。当然，业务也可以选择更新完最新包之后，提示用户有新版本页面，以及是否选择刷新并加载最新页面。</p>\n<p><strong>问题： 更新链路比较长</strong></p>\n<img src=\"https://pic3.zhimg.com/80/v2-0277793458e3c0172958ce1e3732aff2_1440w.webp\" style=\"width:300px;max-width:100%\" />\n\n<ol>\n<li>整个流程是从 React Native 环境初始化到热更新 ，再到 JavaScript 业务代码执行，最后到业务界面展示。</li>\n<li>链路比较长，而且每一个步骤都依赖前一个步骤的结果。</li>\n<li>特别是热更新流程，最长可涉及两次网络调用，分别是检测是否需要更新与下载最新 bundle 文件。</li>\n</ol>\n<p>针对这种场景，我们想到一个优化点，在等待网络返回的过程中，Native 能不能把闲置的 CPU 资源利用起来呢？</p>\n<h3 id=\"三、接口预缓存\"><a href=\"#三、接口预缓存\" class=\"headerlink\" title=\"三、接口预缓存\"></a>三、接口预缓存</h3><p>在纯客户端开发中，我们经常使用接口数据缓存策略来提升用户体验，在最新数据返回前，先使用缓存数据进行页面渲染。<br><img src=\"https://pic4.zhimg.com/80/v2-4d7cf7cdbd872a65ccf22256fe774d47_1440w.webp\" style=\"width:250px;max-width:100%\" /></p>\n<h3 id=\"四、拆包\"><a href=\"#四、拆包\" class=\"headerlink\" title=\"四、拆包\"></a>四、拆包</h3><h4 id=\"Common-业务-bundle\"><a href=\"#Common-业务-bundle\" class=\"headerlink\" title=\"Common + 业务 bundle\"></a>Common + 业务 bundle</h4><p>React Native 页面的 JavaScript 代码包是热更新平台根据版本号进行下发的，每次有业务改动，我们都需要通过网络请求更新代码包。<br>不过，只要 React Native 官方版本没有发生变化，JavaScript 代码包中 React Native 源码相关的部分是不会发生变化的，所以我们不需要在每次业务包更新的时候都进行下发，在工程中内置一份就好了。</p>\n<p>因此，我们在对 JavaScript 代码进行打包的时候，需要讲包拆分成两个部分：</p>\n<ol>\n<li>一个是 Common 部分，也就是 React Native 源码部分；</li>\n<li>另一个是业务代码部分，也就是我们需要动态下载的部分。</li>\n</ol>\n<img src=\"https://pic3.zhimg.com/80/v2-fd8eaca2a62acb1962f8db7a651f0242_1440w.webp\" style=\"width:200px;max-width:100%\" />\n\n<h4 id=\"方案：\"><a href=\"#方案：\" class=\"headerlink\" title=\"方案：\"></a>方案：</h4><p>经过上面的拆分后，Common 包内置到工程中（至少为几百 kb 的大小），业务代码包进行动态下载。然后我们利用 JSContext 环境，在进入载体页后在环境中先加载 Common 包，再加载业务代码包就可以完整的渲染出 React Native 页面</p>\n<h3 id=\"五、按需加载\"><a href=\"#五、按需加载\" class=\"headerlink\" title=\"五、按需加载\"></a>五、按需加载</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>其实我们通过前面拆包的方案，已经减少了动态下载的业务代码包的大小。但是还会存在部分业务非常庞大，拆包后业务代码包的大小依然很大的情况，依然会导致下载速度较慢，并且还会受网络情况的影响。</p>\n<p>因此，我们可以再次针对业务代码包进行拆分，将一个业务代码包拆分为一个主包和多个子包的方式。在进入页面后优先请求主包的 JavaScript 代码资源，能够快速地渲染首屏页面，紧接着用户点击某一个模块时，再继续下载对应模块的代码包并进行渲染，就能再进一步减少加载时间。</p>\n<img src=\"https://pic3.zhimg.com/80/v2-3b476ec20761da6529eddabdcc06cb56_1440w.webp\" style=\"width:200px;max-width:100%\" />\n\n<h4 id=\"按需加载前提\"><a href=\"#按需加载前提\" class=\"headerlink\" title=\"按需加载前提\"></a>按需加载前提</h4><p>那么，什么时候需要把业务代码包拆分成一个主包和多个子包呢？把什么模块作为主包，什么模块作为子包比较合适呢？</p>\n<p>其实，当业务逻辑比较简单的时候，我们并不需要对业务代码包进行拆分，当时当业务比较复杂的时候，特别是一些大型的项目就有可能需要进行拆包，而拆包的逻辑，通常是按照业务进行拆分的。举个例子，我们有一下这个包含 Tab 的业务页面</p>\n<h3 id=\"六、其他优化\"><a href=\"#六、其他优化\" class=\"headerlink\" title=\"六、其他优化\"></a>六、其他优化</h3><h4 id=\"数据缓存\"><a href=\"#数据缓存\" class=\"headerlink\" title=\"数据缓存\"></a>数据缓存</h4><p>在 React Native 移动端的性能优化中，除了 React Native 环境创建、bundle 文件、接口数据等方面的优化外，还有一个大的优化点，就是 React Native 运行时优化。</p>\n<h4 id=\"使用新版本新架构\"><a href=\"#使用新版本新架构\" class=\"headerlink\" title=\"使用新版本新架构\"></a>使用新版本新架构</h4><p>众所周知，React Native 旧版本的运行效率有两大痛点：</p>\n<ol>\n<li>是 JSC 引擎解释执行 JavaScript 代码效率低，引擎启动速度慢；</li>\n<li>是 JavaScript 与 Native 通信效率低，特别是涉及批量地 UI 交互更是如此。</li>\n</ol>\n<p>所以，React Native 新架构采用了 JSI 进行通信，替换了 JSBridge，无异步地序列化与反序列化操作、无内存拷贝，可以做到同步通信。</p>\n<h4 id=\"Hermes\"><a href=\"#Hermes\" class=\"headerlink\" title=\"Hermes\"></a>Hermes</h4><p>除此之外，React Native 0.60 及以后的版本开始支持 Hermes 引擎。</p>\n<p>对比 JSC 引擎，Hermes 引擎在启动速度、代码执行效率上都有大幅提升，所以接下来我们就来重点讲解 Hermes 引擎的特点、它的优化手段以及如何在移动端启用。</p>\n<h3 id=\"爬取标题脚本\"><a href=\"#爬取标题脚本\" class=\"headerlink\" title=\"爬取标题脚本\"></a>爬取标题脚本</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var hlist &#x3D; temp1.getElementsByTagName(&#39;h2&#39;);\nvar data &#x3D; &#39;&#39;;\nfunction gethlist(_domlist) &#123;\n  Array.from(_domlist).forEach((li) &#x3D;&gt; &#123;\n    var title &#x3D; li.innerText;\n    data &#x3D; data + &#96;#### $&#123;title&#125; \\n\\n&#96;;\n  &#125;);\n&#125;\ngethlist(hlist);\ncopy(data);</code></pre>\n\n<h2 id=\"react-native-端代码优化\"><a href=\"#react-native-端代码优化\" class=\"headerlink\" title=\"react-native 端代码优化\"></a>react-native 端代码优化</h2><ol>\n<li>减少 re-render</li>\n<li>减轻渲染压力</li>\n<li>图片优化那些事</li>\n<li>对象创建调用分离</li>\n<li>动画性能优化</li>\n<li>长列表性能优化</li>\n<li>React Native 性能优化用到的工具</li>\n</ol>\n<h3 id=\"一、减少-re-render\"><a href=\"#一、减少-re-render\" class=\"headerlink\" title=\"一、减少 re-render\"></a>一、减少 re-render</h3><ol>\n<li>shouldComponentUpdate</li>\n<li>React.PureComponent</li>\n<li>React.memo、React.callback</li>\n</ol>\n<h3 id=\"二、减轻渲染压力\"><a href=\"#二、减轻渲染压力\" class=\"headerlink\" title=\"二、减轻渲染压力\"></a>二、减轻渲染压力</h3><ol>\n<li>使用 React.Fragment 避免多层嵌套,RN 好像没有</li>\n</ol>\n<h3 id=\"三、图片优化那些事\"><a href=\"#三、图片优化那些事\" class=\"headerlink\" title=\"三、图片优化那些事\"></a>三、图片优化那些事</h3><ol>\n<li>Image 组件的优化项<ol>\n<li>加载本地&#x2F;网络图片</li>\n<li>自动匹配 @2x&#x2F;@3x 图片</li>\n<li>图片加载事件：onLoadStart&#x2F;onLoad&#x2F;onLoadEnd&#x2F;onError</li>\n<li>loading 默认图 or loading 指示器</li>\n</ol>\n</li>\n<li>使用图片管理优化库<br>图片优化前，我们先想一下，一个基本的图片下载管理库要实现什么：<ol>\n<li>下载管理：在加载多张图片的场景，能管理好多个请求，可以控制图片加载的优先级</li>\n<li>图片类型：首先你的主要职责是加载图片，你起码能加载多种图片类型</li>\n<li>缓存管理：做好三级缓存，不能每个图片都要请求网络，均衡好内存缓存和磁盘缓存的策略</li>\n<li>多图加载：大量图片同时渲染时，如何让图片迅速加载，减少卡顿</li>\n</ol>\n</li>\n<li>图片服务器辅助</li>\n</ol>\n<h3 id=\"四、对象创建调用分离\"><a href=\"#四、对象创建调用分离\" class=\"headerlink\" title=\"四、对象创建调用分离\"></a>四、对象创建调用分离</h3><ol>\n<li>绑定回调函数</li>\n<li><code>StyleSheet.flatten([styles.item, props.style])</code> &#x2F;&#x2F; &lt;&#x3D; 合并默认样式和自定义样式</li>\n<li>避免在 render 函数里创建新数组&#x2F;对象</li>\n</ol>\n<h3 id=\"五、动画性能优化\"><a href=\"#五、动画性能优化\" class=\"headerlink\" title=\"五、动画性能优化\"></a>五、动画性能优化</h3><h3 id=\"六、长列表性能优化\"><a href=\"#六、长列表性能优化\" class=\"headerlink\" title=\"六、长列表性能优化\"></a>六、长列表性能优化</h3><p>React Native 有好几个列表组件，先简单介绍一下：</p>\n<ol>\n<li><code>ScrollView</code>：会把视图里的所有 View 渲染，直接对接 Native 的滚动列表</li>\n<li><code>VirtualizedList</code>：虚拟列表核心文件，使用 ScrollView，长列表优化配置项主要是控制它</li>\n<li><code>FlatList</code>：使用 VirtualizedList，实现了一行多列的功能，大部分功能都是 VirtualizedList 提供的</li>\n<li><code>SectionList</code>：使用 VirtualizedList，底层使用 <code>VirtualizedSectionList</code>，把二维数据转为一维数据</li>\n</ol>\n<p>VirtualizedList 有个 debug 的配置项，开启后会在视图右侧显示虚拟列表的显示情况<br><img src=\"https://pic2.zhimg.com/80/v2-50732a318b5994767b75eeab700d2925_1440w.jpg\" style=\"width:300px;max-width:100%\" /></p>\n<h3 id=\"七、React-Native-性能优化用到的工具\"><a href=\"#七、React-Native-性能优化用到的工具\" class=\"headerlink\" title=\"七、React Native 性能优化用到的工具\"></a>七、React Native 性能优化用到的工具</h3><h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/530381812\" target=\"_blank\" >React Native 如何做性能优化</a></p>\n<p><a href=\"https://www.cnblogs.com/zhengyan/p/13651183.html\" target=\"_blank\" >react-native 端代码优化</a></p>\n","text":"bundle 优化bundle 优化速览 环境预创建 异步检测、下载 公用资源拆包 按需加载 新版本 一、React Native 环境预创建一个载体页一个引擎。 通常，一个 React Native 页面从加载渲染到展示大致分为以下几步： 【React Native 环境初始化...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"react-native","slug":"react-native","count":8,"path":"api/categories/react-native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":8,"path":"api/tags/react-native.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bundle-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">bundle 优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bundle-%E4%BC%98%E5%8C%96%E9%80%9F%E8%A7%88\"><span class=\"toc-text\">bundle 优化速览</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81React-Native-%E7%8E%AF%E5%A2%83%E9%A2%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">一、React Native 环境预创建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0-rn-%E6%9B%B4%E6%96%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">二、异步更新(rn 更新思路)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%89%8D\"><span class=\"toc-text\">优化前</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%90%8E\"><span class=\"toc-text\">优化后</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">更新时机</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E9%A2%84%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">三、接口预缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%8B%86%E5%8C%85\"><span class=\"toc-text\">四、拆包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Common-%E4%B8%9A%E5%8A%A1-bundle\"><span class=\"toc-text\">Common + 业务 bundle</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%EF%BC%9A\"><span class=\"toc-text\">方案：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">五、按需加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%89%8D%E6%8F%90\"><span class=\"toc-text\">按需加载前提</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">六、其他优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">数据缓存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%96%B0%E7%89%88%E6%9C%AC%E6%96%B0%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">使用新版本新架构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Hermes\"><span class=\"toc-text\">Hermes</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%AC%E5%8F%96%E6%A0%87%E9%A2%98%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">爬取标题脚本</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-native-%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">react-native 端代码优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%87%8F%E5%B0%91-re-render\"><span class=\"toc-text\">一、减少 re-render</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%87%8F%E8%BD%BB%E6%B8%B2%E6%9F%93%E5%8E%8B%E5%8A%9B\"><span class=\"toc-text\">二、减轻渲染压力</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E9%82%A3%E4%BA%9B%E4%BA%8B\"><span class=\"toc-text\">三、图片优化那些事</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%B0%83%E7%94%A8%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">四、对象创建调用分离</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">五、动画性能优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">六、长列表性能优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81React-Native-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">七、React Native 性能优化用到的工具</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React18 版本主要更新内容","uid":"935f55a55c003dca5fd748af01a100e2","slug":"2023-02-19react18","date":"2023-02-19T11:37:57.000Z","updated":"2023-05-15T13:17:32.984Z","comments":true,"path":"api/articles/2023-02-19react18.json","keywords":null,"cover":null,"text":"react 18 修 bug 由于并发模式可能带来破坏，所以 react18 的并发模式可选 Suspense fallback=&#123;undefined&#125; 表现与null相同 增加开发体验 自动批处理: 之前需要使用 ReactDOM.unstable_batc...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":38,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":32,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"技术选型-考虑因素","uid":"6f467a9b3152eb555a0298695fd77d63","slug":"2023-02-18技术选型","date":"2023-02-18T01:52:12.000Z","updated":"2023-05-15T13:17:32.982Z","comments":true,"path":"api/articles/2023-02-18技术选型.json","keywords":null,"cover":null,"text":" 考虑的角度 纵向考虑： 过去 看公司内部：现有技术积累，技术储备，人员配置 现在 学习成本、和收益 将来 看市场份额：市场是否普及，技术是为项目服务的，不能只顾着自己爽了，以后没人维护，或者维护成本很高 横向对比： 看技术本身：易用性、适用场景；能否解决什么痛点问题 看社区生态...","link":"","photos":[],"count_time":{"symbolsCount":281,"symbolsTime":"1 mins."},"categories":[{"name":"复盘","slug":"复盘","count":7,"path":"api/categories/复盘.json"}],"tags":[{"name":"复盘","slug":"复盘","count":7,"path":"api/tags/复盘.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}