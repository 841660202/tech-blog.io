{"title":"TypeORM 答疑","uid":"2ba7b685164c0dbd4aedd1d197c6832b","slug":"2023-05-11typeorm","date":"2023-05-11T07:40:11.000Z","updated":"2023-05-15T13:17:33.010Z","comments":true,"path":"api/articles/2023-05-11typeorm.json","keywords":null,"cover":[],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>这篇文章主要是答疑，不是参考文档，参考文档去官网查看，这里不做详细讨论</p>\n<h2 id=\"TypeORM-是什么\"><a href=\"#TypeORM-是什么\" class=\"headerlink\" title=\"TypeORM 是什么\"></a>TypeORM 是什么</h2><p>TypeORM 是一个用于 Node.js 和 JavaScript 的对象关系映射（ORM）库。它提供了一种将数据库中的数据映射到 JavaScript 对象的方式，使得在应用程序中使用数据库变得更加简单和方便。</p>\n<p>TypeORM 支持多种数据库系统，如 MySQL、PostgreSQL、SQLite、Microsoft SQL Server 等。它提供了许多功能，包括实体管理、数据查询、关系管理、事务支持等。TypeORM 使用装饰器语法来定义实体和其属性，使得实体类的定义更加直观和易于理解。</p>\n<p>通过 TypeORM，开发者可以使用面向对象的方式来处理数据库操作，而不需要直接编写 SQL 语句。它提供了强大的查询构建器和查询语言，可以轻松地执行复杂的数据库查询操作。</p>\n<p>TypeORM 还提供了数据库迁移工具，可以帮助开发者管理数据库模式的变化，并进行版本控制。这使得在开发过程中对数据库进行结构调整和更新变得更加容易。</p>\n<p>总之，TypeORM 是一个强大的 ORM 库，可以简化数据库操作，提高开发效率，并促进代码的可维护性。</p>\n<h2 id=\"比较-TypeORM-和-Sequelize\"><a href=\"#比较-TypeORM-和-Sequelize\" class=\"headerlink\" title=\"比较 TypeORM 和 Sequelize\"></a>比较 TypeORM 和 Sequelize</h2><p>TypeORM 和 Sequelize 都是用于 Node.js 的 ORM 库，它们都提供了将数据库操作映射到 JavaScript 对象的能力。然而，它们在一些方面存在一些区别。</p>\n<ol>\n<li><p>语法和风格：</p>\n<ol>\n<li>TypeORM 使用装饰器语法来定义实体和属性，这使得代码更加直观和易于理解。</li>\n<li>Sequelize 则使用 JavaScript 对象和函数来表示模型和查询操作，更接近传统的编程风格。</li>\n</ol>\n</li>\n<li><p>数据库支持：</p>\n<ol>\n<li>TypeORM 支持多种数据库系统，包括 MySQL、PostgreSQL、SQLite、Microsoft SQL Server 等。</li>\n<li>Sequelize 也支持多种数据库，包括 MySQL、PostgreSQL、SQLite、Microsoft SQL Server 等，但还支持 NoSQL 数据库 MongoDB。</li>\n</ol>\n</li>\n<li><p>成熟度和社区支持：</p>\n<ol>\n<li>Sequelize 是一个成熟的 ORM 库，已经存在较长时间，并且有着广泛的社区支持和活跃的维护者。</li>\n<li>TypeORM 相对较新，但也有不断增长的用户群和开发者社区。</li>\n</ol>\n</li>\n<li><p>查询构建器：</p>\n<ol>\n<li>TypeORM 和 Sequelize 都提供了查询构建器，用于构建复杂的数据库查询。</li>\n<li>TypeORM 的查询构建器更加灵活和强大，可以支持更复杂的查询操作。</li>\n<li>Sequelize 的查询构建器也很强大，但在某些情况下可能需要编写原生 SQL 语句来执行更高级的查询。</li>\n</ol>\n</li>\n<li><p>数据迁移：</p>\n<ol>\n<li>TypeORM 和 Sequelize 都提供了数据库迁移工具，用于管理数据库模式的变化。</li>\n<li>它们都可以帮助开发者进行数据库结构的调整和更新。</li>\n</ol>\n</li>\n</ol>\n<p>选择 TypeORM 还是 Sequelize 取决于具体的项目需求和个人偏好。如果需要多数据库支持、强大的查询构建器和装饰器语法，可以选择 TypeORM。如果需要对 NoSQL 数据库进行操作，或者更喜欢传统的 JavaScript 编程风格，可以选择 Sequelize。</p>\n<h1 id=\"实体\"><a href=\"#实体\" class=\"headerlink\" title=\"实体\"></a>实体</h1><h2 id=\"嵌入式实体-与-实体继承-的区别\"><a href=\"#嵌入式实体-与-实体继承-的区别\" class=\"headerlink\" title=\"嵌入式实体 与 实体继承 的区别\"></a>嵌入式实体 与 实体继承 的区别</h2><p>嵌入式实体（Embedded Entity）和实体继承（Entity Inheritance）是对象关系映射（ORM）中两种不同的建模技术。</p>\n<ol>\n<li><code>嵌入式实体</code>：嵌入式实体是将一个实体对象嵌入到另一个实体对象中，作为其属性的一部分。这种关系表示了一个对象包含了另一个对象，就像一个整体。嵌入式实体通常用于表示具有紧密关联的对象，其中一个对象是另一个对象的组成部分。在数据库中，嵌入式实体的属性通常直接存储在包含它的实体的表中，而不是单独的表。</li>\n</ol>\n<p>例如，假设我们有一个”User”实体，它包含一个嵌入式实体”Address”。”Address”对象包含了用户的地址信息，包括街道、城市和邮政编码等。在数据库中，”User”表会包含”Address”的相关字段。</p>\n<ol start=\"2\">\n<li><code>实体继承</code>：实体继承是面向对象编程中的概念，它允许一个实体从另一个实体继承属性和行为。这种关系表示了一种”是一个”的关系，子实体是父实体的特殊化。</li>\n</ol>\n<p>在 ORM 中，实体继承可以通过两种方式实现：单表继承（Single Table Inheritance）和类表继承（Class Table Inheritance）。</p>\n<ol>\n<li><code>单表继承</code>将所有的实体类型存储在同一个表中，通过一个类型字段来区分不同的实体类型。</li>\n<li><code>类表继承</code>则将每个实体类型存储在独立的表中，每个表都包含其自己的属性。</li>\n</ol>\n<p>例如，假设我们有一个基类实体”Animal”，它有两个子类实体”Cat”和”Dog”。在单表继承中，可以在一个表中存储所有的动物，使用一个类型字段来标识是猫还是狗。在类表继承中，可以为”Animal”、”Cat”和”Dog”分别创建三个独立的表。</p>\n<p>总结来说，</p>\n<ol>\n<li>嵌入式实体用于表示一个实体是另一个实体的组成部分，</li>\n<li>而实体继承用于表示一个实体是另一个实体的特殊化。选择使用哪种技术取决于具体的业务需求和数据模型的设计。</li>\n</ol>\n<p><strong>注意：单表继承，在 gorm 表现为多态</strong></p>\n<h2 id=\"单表继承（数据库表结构，插入数据、查询数据）示例\"><a href=\"#单表继承（数据库表结构，插入数据、查询数据）示例\" class=\"headerlink\" title=\"单表继承（数据库表结构，插入数据、查询数据）示例\"></a>单表继承（数据库表结构，插入数据、查询数据）示例</h2><p>好的，以下是一个使用单表继承的完整示例，包括创建数据库表、使用 TypeORM 插入数据和查询数据的代码示例：</p>\n<ol>\n<li>数据库表结构：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Entity, PrimaryGeneratedColumn, Column, TableInheritance &#125; from &#39;typeorm&#39;;\n\n@Entity()\n@TableInheritance(&#123; column: &#123; type: &#39;varchar&#39;, name: &#39;type&#39; &#125; &#125;)\nexport class Animal &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  color: string;\n&#125;\n\n@Entity()\nexport class Cat extends Animal &#123;\n  @Column()\n  breed: string;\n&#125;\n\n@Entity()\nexport class Dog extends Animal &#123;\n  @Column()\n  breed: string;\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>插入数据：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Cat, Dog &#125; from &#39;.&#x2F;models&#x2F;animal&#39;;\n\nasync function insertData() &#123;\n  const connection &#x3D; await createConnection();\n\n  const cat1 &#x3D; new Cat();\n  cat1.name &#x3D; &#39;Kitty&#39;;\n  cat1.color &#x3D; &#39;Gray&#39;;\n  cat1.breed &#x3D; &#39;Persian&#39;;\n  await connection.manager.save(cat1);\n\n  const dog1 &#x3D; new Dog();\n  dog1.name &#x3D; &#39;Buddy&#39;;\n  dog1.color &#x3D; &#39;Brown&#39;;\n  dog1.breed &#x3D; &#39;Labrador&#39;;\n  await connection.manager.save(dog1);\n\n  const cat2 &#x3D; new Cat();\n  cat2.name &#x3D; &#39;Whiskers&#39;;\n  cat2.color &#x3D; &#39;White&#39;;\n  cat2.breed &#x3D; &#39;Siamese&#39;;\n  await connection.manager.save(cat2);\n\n  await connection.close();\n&#125;\n\ninsertData().catch((error) &#x3D;&gt; console.log(error));</code></pre>\n\n<ol start=\"3\">\n<li>查询数据：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Animal, Cat, Dog &#125; from &#39;.&#x2F;models&#x2F;animal&#39;;\n\nasync function queryData() &#123;\n  const connection &#x3D; await createConnection();\n\n  &#x2F;&#x2F; 获取所有动物\n  const animals &#x3D; await connection.manager.find(Animal);\n  console.log(&#39;所有动物：&#39;, animals);\n\n  &#x2F;&#x2F; 获取所有猫\n  const cats &#x3D; await connection.manager.find(Cat);\n  console.log(&#39;所有猫：&#39;, cats);\n\n  &#x2F;&#x2F; 获取所有狗\n  const dogs &#x3D; await connection.manager.find(Dog);\n  console.log(&#39;所有狗：&#39;, dogs);\n\n  await connection.close();\n&#125;\n\nqueryData().catch((error) &#x3D;&gt; console.log(error));</code></pre>\n\n<p>以上代码示例假设你已经正确安装了 TypeORM 和相关依赖，并且在你的项目中设置了数据库连接配置。你可以根据实际情况进行适当的调整和修改。</p>\n<h2 id=\"查询结果\"><a href=\"#查询结果\" class=\"headerlink\" title=\"查询结果\"></a>查询结果</h2><p>根据前面的代码示例，查询数据的结果如下：</p>\n<p>获取所有动物：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 查询结果\n[\n  &#123; id: 1, name: &#39;Kitty&#39;, color: &#39;Gray&#39;, breed: &#39;Persian&#39;, type: &#39;Cat&#39; &#125;,\n  &#123; id: 2, name: &#39;Buddy&#39;, color: &#39;Brown&#39;, breed: &#39;Labrador&#39;, type: &#39;Dog&#39; &#125;,\n  &#123; id: 3, name: &#39;Whiskers&#39;, color: &#39;White&#39;, breed: &#39;Siamese&#39;, type: &#39;Cat&#39; &#125;,\n];</code></pre>\n\n<p>获取所有猫：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 查询结果\n[\n  &#123; id: 1, name: &#39;Kitty&#39;, color: &#39;Gray&#39;, breed: &#39;Persian&#39;, type: &#39;Cat&#39; &#125;,\n  &#123; id: 3, name: &#39;Whiskers&#39;, color: &#39;White&#39;, breed: &#39;Siamese&#39;, type: &#39;Cat&#39; &#125;,\n];</code></pre>\n\n<p>获取所有狗：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 查询结果\n[&#123; id: 2, name: &#39;Buddy&#39;, color: &#39;Brown&#39;, breed: &#39;Labrador&#39;, type: &#39;Dog&#39; &#125;];</code></pre>\n\n<p>以上结果展示了从数据库中查询到的动物数据。每个对象都包含了相应的属性，如 id、name、color、breed 和 type。根据查询条件不同，返回的结果集会根据类型进行筛选。</p>\n<p>请注意，这只是一个示例，实际的查询结果可能会根据你的具体数据和查询条件有所不同。</p>\n<h2 id=\"Tree-Entities\"><a href=\"#Tree-Entities\" class=\"headerlink\" title=\"Tree Entities\"></a>Tree Entities</h2><p>Tree Entities（树实体）是一种用于表示层次结构数据的模型，常用于树状结构的数据存储和查询。TypeORM 提供了支持 Tree Entities 的功能，可以方便地操作和管理树形数据。</p>\n<p>在 TypeORM 中，可以使用<code>@Tree</code>装饰器和一些特定的列装饰器来定义树实体。</p>\n<p>下面是一个示例，展示了如何使用 TypeORM 创建和操作树实体：</p>\n<ol>\n<li>定义树实体类：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Entity, PrimaryGeneratedColumn, Column, Tree, TreeParent, TreeChildren &#125; from &#39;typeorm&#39;;\n\n@Entity()\n@Tree(&#39;closure-table&#39;)\nexport class Category &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @TreeParent()\n  parent: Category;\n\n  @TreeChildren()\n  children: Category[];\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>插入树实体数据：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function insertData() &#123;\n  const connection &#x3D; await createConnection();\n\n  const root &#x3D; new Category();\n  root.name &#x3D; &#39;Root&#39;;\n\n  const child1 &#x3D; new Category();\n  child1.name &#x3D; &#39;Child 1&#39;;\n  child1.parent &#x3D; root;\n\n  const child2 &#x3D; new Category();\n  child2.name &#x3D; &#39;Child 2&#39;;\n  child2.parent &#x3D; root;\n\n  const grandchild1 &#x3D; new Category();\n  grandchild1.name &#x3D; &#39;Grandchild 1&#39;;\n  grandchild1.parent &#x3D; child1;\n\n  await connection.manager.save([root, child1, child2, grandchild1]);\n\n  await connection.close();\n&#125;\n\ninsertData().catch((error) &#x3D;&gt; console.log(error));</code></pre>\n\n<ol start=\"3\">\n<li>查询树实体数据：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function queryData() &#123;\n  const connection &#x3D; await createConnection();\n\n  &#x2F;&#x2F; 获取所有根级别的类别\n  const rootCategories &#x3D; await connection.manager.find(Category, &#123; parent: null &#125;);\n  console.log(&#39;根级别的类别：&#39;, rootCategories);\n\n  &#x2F;&#x2F; 获取指定类别的所有子类别\n  const category &#x3D; await connection.manager.findOne(Category, &#123; where: &#123; name: &#39;Child 1&#39; &#125; &#125;);\n  const children &#x3D; await connection.manager.find(Category, &#123; parent: category &#125;);\n  console.log(&#39;Child 1的子类别：&#39;, children);\n\n  await connection.close();\n&#125;\n\nqueryData().catch((error) &#x3D;&gt; console.log(error));</code></pre>\n\n<p>上述代码示例定义了一个<code>Category</code>树实体类，其中包含了 id、name、parent 和 children 等属性。通过设置装饰器，我们定义了树结构的关系。</p>\n<p>通过插入数据和查询数据的代码，我们可以创建和操作树形结构的数据。通过根级别和父子关系，我们可以轻松地构建和查询树形数据的层次结构。</p>\n<p>请注意，以上示例只是一个简单的演示，实际使用中可能需要根据具体的业务需求和数据模型进行适当的调整和修改。</p>\n<h2 id=\"Tree-“closure-table”-是什么，有什么用\"><a href=\"#Tree-“closure-table”-是什么，有什么用\" class=\"headerlink\" title=\"@Tree(“closure-table”) 是什么，有什么用\"></a>@Tree(“closure-table”) 是什么，有什么用</h2><p><code>@Tree(&quot;closure-table&quot;)</code> 是 TypeORM 中的一个装饰器，用于定义树实体的层次关系存储策略之一，即闭包表（Closure Table）。</p>\n<p>闭包表是一种用于存储和查询树形结构数据的技术。它通过在数据库中创建一个额外的表来表示树中的层次关系，这个表通常称为闭包表。闭包表记录了树中每个节点与其祖先节点之间的关系。</p>\n<p>在 TypeORM 中，<code>@Tree(&quot;closure-table&quot;)</code> 装饰器的作用是告诉 TypeORM 使用闭包表策略来存储树实体的层次关系。</p>\n<p>闭包表策略的优点是灵活性和查询性能。它允许对树进行高效的插入、更新和删除操作，并且可以使用递归查询来查询树中的节点及其子节点。闭包表还可以处理树的复杂结构和多层级关系。</p>\n<p>使用 <code>@Tree(&quot;closure-table&quot;)</code> 装饰器后，TypeORM 会自动生成一个闭包表，并在其中存储树实体的层次关系。</p>\n<p>注意，TypeORM 还提供其他存储策略，如嵌套集合（Nested Set）和路径枚举（Path Enumeration），每种策略都有其特定的用途和性能特点。选择适当的存储策略取决于你的数据模型和具体的查询需求。</p>\n<h3 id=\"上述代码对应的数据库表结构\"><a href=\"#上述代码对应的数据库表结构\" class=\"headerlink\" title=\"上述代码对应的数据库表结构\"></a>上述代码对应的数据库表结构</h3><p>基于前面提供的代码示例，使用 <code>@Tree(&quot;closure-table&quot;)</code> 装饰器来定义树实体的存储策略为闭包表。对应的数据库表结构如下：</p>\n<ol>\n<li>Category 表：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Root</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Child 1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Child 2</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Grandchild 1</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>CategoryClosure 表：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>ancestor</th>\n<th>descendant</th>\n<th>depth</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>0</td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>4</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>CategoryClosure 表用于记录树中每个节点与其祖先节点之间的关系。每一行表示一个祖先与后代之间的关系，包括祖先节点的 ID、后代节点的 ID 以及它们之间的层次深度。</p>\n<p>通过 Category 表和 CategoryClosure 表的组合，可以表示树形结构中的层次关系。</p>\n<p>请注意，上述表结构仅为了说明闭包表存储策略的概念，实际的数据库表结构可能会有一些差异，具体取决于数据库的特定实现和 TypeORM 的配置。</p>\n<h3 id=\"如果用原生-mysql-如何写查询语句\"><a href=\"#如果用原生-mysql-如何写查询语句\" class=\"headerlink\" title=\"如果用原生 mysql 如何写查询语句\"></a>如果用原生 mysql 如何写查询语句</h3><p>如果你使用原生 MySQL，以下是一些示例查询语句，用于检索树形结构数据（基于之前提供的树实体示例）：</p>\n<ol>\n<li>获取所有根级别的类别：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT * FROM Category WHERE parent IS NULL;</code></pre>\n\n<ol start=\"2\">\n<li>获取指定类别的所有子类别：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT c.* FROM Category c\nJOIN CategoryClosure cc ON c.id &#x3D; cc.descendant\nJOIN Category pc ON pc.id &#x3D; cc.ancestor\nWHERE pc.name &#x3D; &#39;Child 1&#39;;</code></pre>\n\n<ol start=\"3\">\n<li>获取指定类别的所有祖先类别：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT pc.* FROM Category c\nJOIN CategoryClosure cc ON c.id &#x3D; cc.ancestor\nJOIN Category pc ON pc.id &#x3D; cc.descendant\nWHERE c.name &#x3D; &#39;Grandchild 1&#39;;</code></pre>\n\n<p>以上查询语句用于从数据库中检索树形结构的数据。根据具体的业务需求和数据模型，你可能需要根据实际情况进行调整和修改。</p>\n<p>请注意，以上查询语句是基于前面提供的树实体示例和假设的数据库表结构。如果你的数据模型和表结构不同，你需要相应地调整查询语句以适应你的实际情况。</p>\n<ol start=\"4\">\n<li>查询完整树的 sql</li>\n</ol>\n<p>要查询完整的树形结构，可以使用递归查询（Recursive Query）来检索所有的节点和它们的层次关系。在 MySQL 中，可以使用通用表表达式（CTE）和递归查询来实现。</p>\n<p>以下是一个示例的递归查询语句，用于检索完整的树形结构：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">WITH RECURSIVE Tree AS (\n  SELECT\n    id,\n    name,\n    parent,\n    0 AS level\n  FROM Category\n  WHERE parent IS NULL\n\n  UNION ALL\n\n  SELECT\n    c.id,\n    c.name,\n    c.parent,\n    t.level + 1\n  FROM Category c\n  JOIN Tree t ON t.id &#x3D; c.parent\n)\nSELECT * FROM Tree;</code></pre>\n\n<p>上述查询语句使用了递归的方式，通过不断连接树的父节点和子节点，来逐级检索树中的节点。查询结果包含了每个节点的 ID、名称、父节点和层级（level）信息。</p>\n<p>请注意，以上查询语句是基于假设的树形数据模型和表结构。你需要根据实际的数据模型和表结构进行适当的调整和修改。</p>\n<h3 id=\"findTrees\"><a href=\"#findTrees\" class=\"headerlink\" title=\"findTrees\"></a>findTrees</h3><p>在 TypeORM 中，<code>findTrees</code> 是用于查询树形结构数据的一个特殊方法，它可以直接返回完整的树形结构，而不需要手动编写递归查询语句。</p>\n<p>使用 <code>findTrees</code> 方法，你可以轻松地检索整个树形结构，包括节点及其子节点的层次关系。该方法会自动处理递归查询，并将结果以树形结构的形式返回。</p>\n<p>以下是示例代码，演示如何使用 <code>findTrees</code> 方法查询树形结构数据：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function queryData() &#123;\n  const connection &#x3D; await createConnection();\n\n  const tree &#x3D; await connection.getRepository(Category).findTrees();\n  console.log(&#39;完整树形结构：&#39;, tree);\n\n  await connection.close();\n&#125;\n\nqueryData().catch((error) &#x3D;&gt; console.log(error));</code></pre>\n\n<p>使用 <code>findTrees</code> 方法，它将自动执行递归查询，检索整个树形结构，并返回一个包含完整树的结果数组。每个节点对象将包含其子节点的数组，从而形成树形结构。</p>\n<p>需要注意的是，使用 <code>findTrees</code> 方法前提是你的实体类已正确定义了树形结构的关系装饰器，如 <code>@TreeParent()</code> 和 <code>@TreeChildren()</code>。</p>\n<p>因此，相比手动编写递归查询语句，使用 <code>findTrees</code> 方法可以更为方便和简洁地获取完整的树形结构数据。</p>\n<h2 id=\"Tree-“materialized-path”-【公司用的这种，这种做组织树懒加载挺好的】\"><a href=\"#Tree-“materialized-path”-【公司用的这种，这种做组织树懒加载挺好的】\" class=\"headerlink\" title=\"@Tree(“materialized-path”)【公司用的这种，这种做组织树懒加载挺好的】\"></a>@Tree(“materialized-path”)【公司用的这种，这种做组织树懒加载挺好的】</h2><p>当使用 <code>@Tree(&quot;materialized-path&quot;)</code> 装饰器时，TypeORM 将使用”Materialized Path”（材料化路径）作为树形结构的存储策略。在”Materialized Path”模型中，每个节点都包含一个路径，该路径表示该节点与其祖先节点之间的关系。</p>\n<p>对于使用 <code>@Tree(&quot;materialized-path&quot;)</code> 的树形实体，以下是一个示例的数据库表结构，用于存储树形结构数据：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE Category (\n  id INT PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  path VARCHAR(255) NOT NULL\n);</code></pre>\n\n<p>在上述表结构中，Category 表包含三个列：</p>\n<ul>\n<li><code>id</code>：节点的唯一标识符。</li>\n<li><code>name</code>：节点的名称。</li>\n<li><code>path</code>：节点的材料化路径，表示该节点与其祖先节点之间的关系。</li>\n</ul>\n<p>例如，一个示例的 Category 表数据如下：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Root</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Child 1</td>\n<td>&#x2F;1&#x2F;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Child 2</td>\n<td>&#x2F;1&#x2F;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Grandchild 1</td>\n<td>&#x2F;1&#x2F;2&#x2F;</td>\n</tr>\n</tbody></table>\n<p>在这个示例中，根节点的路径为 <code>/</code>，Child 1 和 Child 2 节点的路径为 <code>/1/</code>，Grandchild 1 节点的路径为 <code>/1/2/</code>。通过这种路径表示方式，可以明确节点与其祖先节点之间的层次关系。</p>\n<p>请注意，上述的数据库表结构仅为示例，实际的表结构可能会根据具体的数据模型和 TypeORM 的配置而有所不同。材料化路径模型的具体实现可能还涉及其他列或索引，以支持更高效的查询操作。</p>\n<h3 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h3><p>以下是一个使用 <code>@Tree(&quot;materialized-path&quot;)</code> 装饰器的完整示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Entity, PrimaryGeneratedColumn, Column, Tree, TreeParent, TreeChildren &#125; from &#39;typeorm&#39;;\n\n@Entity()\n@Tree(&#39;materialized-path&#39;)\nexport class Category &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  path: string;\n\n  @TreeParent()\n  parent: Category;\n\n  @TreeChildren()\n  children: Category[];\n&#125;</code></pre>\n\n<p>在这个示例中，<code>Category</code> 实体类使用了 <code>@Tree(&quot;materialized-path&quot;)</code> 装饰器，指定了树形结构的存储策略为材料化路径。</p>\n<p>实体类中定义了以下属性：</p>\n<ul>\n<li><code>id</code>：节点的唯一标识符，使用 <code>PrimaryGeneratedColumn</code> 装饰器标记为自动生成。</li>\n<li><code>name</code>：节点的名称，使用 <code>Column</code> 装饰器标记为数据库表的列。</li>\n<li><code>path</code>：节点的材料化路径，使用 <code>Column</code> 装饰器标记为数据库表的列。</li>\n<li><code>parent</code>：父节点，使用 <code>TreeParent</code> 装饰器标记为父节点关系。</li>\n<li><code>children</code>：子节点数组，使用 <code>TreeChildren</code> 装饰器标记为子节点关系。</li>\n</ul>\n<p>使用上述实体类定义后，TypeORM 将根据装饰器的配置自动生成对应的数据库表结构，包括主键、列和索引。在本例中，使用材料化路径作为树形结构的存储策略，并通过 <code>path</code> 列来表示节点与其祖先节点之间的关系。</p>\n<p>请注意，上述示例仅展示了如何使用 <code>@Tree(&quot;materialized-path&quot;)</code> 装饰器来定义树形实体类，并不包含具体的查询或操作代码。你可以根据需要使用 TypeORM 提供的各种查询方法来检索和操作树形结构的数据。</p>\n<h3 id=\"materialized-path-增删改查\"><a href=\"#materialized-path-增删改查\" class=\"headerlink\" title=\"materialized-path 增删改查\"></a>materialized-path 增删改查</h3><p>使用 “Materialized Path”（材料化路径）作为树形结构的存储策略时，你可以使用 TypeORM 提供的各种查询和操作方法来进行增删改查操作。下面是一些示例代码，展示了如何使用 TypeORM 来执行这些操作：</p>\n<p><strong>创建节点：</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function createCategory(name: string, path: string, parentId: number | null) &#123;\n  const category &#x3D; new Category();\n  category.name &#x3D; name;\n  category.path &#x3D; path;\n\n  if (parentId) &#123;\n    const parentCategory &#x3D; await getConnection().getRepository(Category).findOne(parentId);\n    category.parent &#x3D; parentCategory;\n  &#125;\n\n  await getConnection().getRepository(Category).save(category);\n&#125;</code></pre>\n\n<p><strong>删除节点：</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function deleteCategory(id: number) &#123;\n  const categoryRepository &#x3D; getConnection().getRepository(Category);\n  const category &#x3D; await categoryRepository.findOne(id);\n\n  if (category) &#123;\n    await categoryRepository.remove(category);\n  &#125;\n&#125;</code></pre>\n\n<p><strong>更新节点：</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function updateCategory(id: number, name: string, path: string, parentId: number | null) &#123;\n  const categoryRepository &#x3D; getConnection().getRepository(Category);\n  const category &#x3D; await categoryRepository.findOne(id);\n\n  if (category) &#123;\n    category.name &#x3D; name;\n    category.path &#x3D; path;\n\n    if (parentId) &#123;\n      const parentCategory &#x3D; await categoryRepository.findOne(parentId);\n      category.parent &#x3D; parentCategory;\n    &#125; else &#123;\n      category.parent &#x3D; null;\n    &#125;\n\n    await categoryRepository.save(category);\n  &#125;\n&#125;</code></pre>\n\n<p><strong>查询节点：</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function getCategory(id: number) &#123;\n  const category &#x3D; await getConnection()\n    .getRepository(Category)\n    .findOne(id, &#123; relations: [&#39;children&#39;] &#125;);\n  console.log(category);\n&#125;</code></pre>\n\n<p>在上述示例中，我们假设已经建立了名为 <code>Category</code> 的实体类，并且已经创建了与数据库的连接。</p>\n<p>使用这些示例代码，你可以执行相应的操作来增加、删除、更新和查询材料化路径模型的树形结构数据。需要注意的是，具体的操作方法和查询语句可能会根据你的数据模型和需求有所调整，这里提供的示例代码只是基于给出的实体类进行演示。你可以根据自己的实际情况进行适当的修改和调整。</p>\n<h1 id=\"比较-Materialized-Path-与-Closure-table\"><a href=\"#比较-Materialized-Path-与-Closure-table\" class=\"headerlink\" title=\"比较 Materialized Path 与 Closure table\"></a>比较 Materialized Path 与 Closure table</h1><h2 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h2><p>在数据库中存储树形结构数据有多种方式，常见的有 Closure Table 和 Materialized Path 两种。下面对这两种方式进行比较。</p>\n<ol>\n<li>存储结构</li>\n</ol>\n<p>Closure Table 使用一张表来存储所有节点之间的关系，每个节点与其祖先节点的关系都被记录下来。Closure Table 表结构相对简单，但随着树的深度增加，表中的数据量也会随之增加。</p>\n<p>Materialized Path 则使用一个字符串字段来存储每个节点的路径信息。每个节点的路径信息包含该节点的祖先节点 ID，以及该节点自身的 ID，以某种特定的分隔符来分隔不同的节点 ID。Materialized Path 的存储方式相对简洁，但是查询和更新操作会涉及到字符串的解析和拼接。</p>\n<ol start=\"2\">\n<li>查询效率</li>\n</ol>\n<p>Closure Table 的查询效率相对较低，因为需要进行多次 JOIN 操作，特别是在查询节点的所有子孙节点时，性能较差。</p>\n<p>Materialized Path 的查询效率相对较高，因为只需要进行基于字符串的 LIKE 匹配操作即可，而且查询所有子孙节点时只需要查询特定的路径即可。</p>\n<ol start=\"3\">\n<li>更新效率</li>\n</ol>\n<p>Closure Table 的更新效率相对较高，因为只需要更新与某个节点相关的部分数据，而不需要更新整个路径。</p>\n<p>Materialized Path 的更新效率相对较低，因为每次更新都需要对包含该节点的所有路径进行更新。</p>\n<ol start=\"4\">\n<li>数据库复杂度</li>\n</ol>\n<p>Closure Table 的表结构比较简单，但需要维护大量冗余的关系数据，因此数据库的复杂度较高。</p>\n<p>Materialized Path 的表结构相对简单，但需要使用字符串拼接和解析等复杂操作，因此数据库的复杂度也相对较高。</p>\n<p>总结</p>\n<ol>\n<li>Closure Table 适用于深度较浅的树形结构，或者<strong>需要频繁查询节点的祖先和子孙节点</strong>的情况。</li>\n<li>Materialized Path 适用于深度较深的树形结构，或者<strong>需要频繁查询节点的路径信息</strong>的情况。</li>\n<li>选择哪种方式取决于具体的业务需求和数据特点。</li>\n</ol>\n<h2 id=\"不懂\"><a href=\"#不懂\" class=\"headerlink\" title=\"不懂\"></a>不懂</h2><p>让我再给你一些更简单的解释：</p>\n<p>Closure Table（闭包表）和 Materialized Path（材料化路径）是两种用于存储树形结构数据的方法。</p>\n<p>Closure Table 使用一个单独的表来存储节点之间的关系。该表记录了每个节点与其祖先节点的关系，包括所有的父节点和子节点。这种方式的表结构比较简单，但在查询和更新数据时可能需要进行多次的连接操作，导致性能较低。</p>\n<p>Materialized Path 使用一个字符串字段来存储每个节点的路径信息。节点的路径信息包括该节点的祖先节点的标识和节点本身的标识，使用特定的分隔符进行分隔。这种方式的表结构相对简洁，查询数据时只需基于字符串匹配即可，性能较高。</p>\n<p><strong>两种方式各有优劣。</strong></p>\n<ol>\n<li>Closure Table 适合较浅的树形结构和需要频繁查询节点的祖先和子孙节点的情况。</li>\n<li>Materialized Path 适合较深的树形结构和需要频繁查询节点路径信息的情况。</li>\n</ol>\n<p>具体选择哪种方式取决于你的业务需求和数据特点。如果你还有其他问题，我会很乐意为你解答。</p>\n<h1 id=\"邻接表（Adjacency-List）【可跳过】\"><a href=\"#邻接表（Adjacency-List）【可跳过】\" class=\"headerlink\" title=\"邻接表（Adjacency List）【可跳过】\"></a>邻接表（Adjacency List）【可跳过】</h1><p>邻接表（Adjacency List）是一种用于表示树形结构的数据模型。在邻接表中，每个节点都包含一个指向其子节点的列表或指针。这种表示方法通过使用父节点到子节点的引用关系来描述树的结构。</p>\n<p>在邻接表中，每个节点通常包含以下信息：</p>\n<ul>\n<li>节点标识符（ID）：用于唯一标识节点的值。</li>\n<li>节点数据：节点所包含的实际数据。</li>\n<li>父节点引用：指向父节点的指针或引用。</li>\n<li>子节点列表：包含指向子节点的指针或引用的列表。</li>\n</ul>\n<p>使用邻接表表示树形结构时，可以轻松地遍历树的层次结构，查找节点的父节点、子节点以及兄弟节点。由于每个节点仅存储了与其直接相关的信息，因此在空间上相对节省。但是，当需要进行深度遍历或搜索整个树时，可能需要进行多次查询或递归操作，影响性能。</p>\n<p>下面是一个使用邻接表表示树形结构的示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class TreeNode &#123;\n  id: number;\n  data: string;\n  parent: TreeNode | null;\n  children: TreeNode[];\n\n  constructor(id: number, data: string, parent: TreeNode | null &#x3D; null) &#123;\n    this.id &#x3D; id;\n    this.data &#x3D; data;\n    this.parent &#x3D; parent;\n    this.children &#x3D; [];\n  &#125;\n\n  addChild(child: TreeNode) &#123;\n    this.children.push(child);\n    child.parent &#x3D; this;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建一个树形结构\nconst root &#x3D; new TreeNode(1, &#39;Root&#39;);\n\nconst child1 &#x3D; new TreeNode(2, &#39;Child 1&#39;);\nconst child2 &#x3D; new TreeNode(3, &#39;Child 2&#39;);\nconst child3 &#x3D; new TreeNode(4, &#39;Child 3&#39;);\n\nconst grandchild1 &#x3D; new TreeNode(5, &#39;Grandchild 1&#39;);\nconst grandchild2 &#x3D; new TreeNode(6, &#39;Grandchild 2&#39;);\n\nroot.addChild(child1);\nroot.addChild(child2);\nroot.addChild(child3);\n\nchild1.addChild(grandchild1);\nchild1.addChild(grandchild2);\n\n&#x2F;&#x2F; 遍历树形结构\nfunction traverseTree(node: TreeNode, depth: number &#x3D; 0) &#123;\n  const indent &#x3D; &#39;  &#39;.repeat(depth);\n  console.log(indent + node.data);\n\n  for (const child of node.children) &#123;\n    traverseTree(child, depth + 1);\n  &#125;\n&#125;\n\ntraverseTree(root);</code></pre>\n\n<p>上述示例中的 <code>TreeNode</code> 类表示树形结构中的节点，通过 <code>parent</code> 和 <code>children</code> 属性建立父子关系。我们可以使用 <code>addChild</code> 方法来添加子节点，并使用 <code>traverseTree</code> 函数遍历整个树形结构。</p>\n<p>邻接表是一种常见的树形结构表示方法，它简单明了并且易于理解。但是对于大型树形结构和深度遍历操作，可能会面临性能挑战。在这种情况下，其他存储模型如 Closure Table、Materialized Path 或 Nested Set Model</p>\n<h2 id=\"view-entities-做什么用，什么场景会用到\"><a href=\"#view-entities-做什么用，什么场景会用到\" class=\"headerlink\" title=\"view-entities 做什么用，什么场景会用到\"></a>view-entities 做什么用，什么场景会用到</h2><p>View Entities 是 TypeORM 中的一个功能，<strong>用于创建虚拟实体类，映射到数据库中的视图</strong>。它们是基于数据库视图的概念，可以将多个表或查询的结果视为单个实体，方便进行查询和操作。</p>\n<p>使用 View Entities 可以解决以下场景：</p>\n<ol>\n<li><p><code>简化复杂查询</code>：当需要执行多个表之间的联接查询、聚合操作或其他复杂查询时，可以创建一个 View Entity，将多个表或查询结果组合成一个虚拟的实体类。这样，你可以像操作普通实体一样对其进行查询，而不需要手动编写复杂的 SQL 查询。</p>\n</li>\n<li><p><code>提供抽象视图层</code>：有时候，你希望将数据库中的多个表或查询结果视为单个实体，以便在业务逻辑中使用。通过创建 View Entity，你可以将这些表或查询结果封装为一个高层次的抽象视图，从而简化代码逻辑。</p>\n</li>\n<li><p><code>数据报表和分析</code>：如果需要在数据库中创建视图以供报表或分析使用，View Entities 是一个很好的选择。你可以定义一个 View Entity，将相关表或查询结果映射到该实体中，然后使用 TypeORM 提供的查询功能来检索和处理报表数据。</p>\n</li>\n</ol>\n<p>需要注意的是，<strong>由于 View Entities 是基于数据库视图创建的，它们通常是只读的</strong>。这意味着你不能通过 View Entity 对数据库进行插入、更新或删除操作。但你仍然可以使用它们执行查询操作，获取数据的实时快照或数据报表。</p>\n<p>总结来说，View Entities 是 TypeORM 提供的一个功能，用于创建虚拟实体类，映射到数据库中的视图。它们在简化复杂查询、提供抽象视图层以及数据报表和分析等场景下非常有用。</p>\n<h2 id=\"数据库视图-的作用【新医和阿里，病例质检项目-给第三方提供数据库视图】\"><a href=\"#数据库视图-的作用【新医和阿里，病例质检项目-给第三方提供数据库视图】\" class=\"headerlink\" title=\"数据库视图 的作用【新医和阿里，病例质检项目 给第三方提供数据库视图】\"></a>数据库视图 的作用【新医和阿里，病例质检项目 给第三方提供数据库视图】</h2><p>数据库视图（Database View）是数据库中一个虚拟的表，它是基于一个或多个数据库表或查询的结果集创建的。视图并不实际存储数据，而是通过查询和计算从基本表中获取数据并将其呈现给用户。</p>\n<p>数据库视图的作用包括：</p>\n<ol>\n<li><p>数据抽象和安全性：视图可以提供数据的抽象层，隐藏了底层表的细节和复杂性。通过视图，可以将底层表的特定列或行筛选出来，只暴露给用户需要的数据。这样，用户无需直接访问底层表，而是通过视图来获取数据，提高了数据的安全性和隐私性。</p>\n</li>\n<li><p>简化复杂查询：数据库视图可以将多个表的关联和联接操作抽象为一个视图，使复杂的查询变得简单。通过在视图上执行查询操作，可以避免编写复杂的 SQL 语句和多表联接操作，提高了查询的可读性和易用性。</p>\n</li>\n<li><p>数据一致性和逻辑完整性：通过视图，可以定义计算列、虚拟列和数据转换规则，从而保持数据的一致性和逻辑完整性。视图可以对数据进行格式化、计算和转换，使得数据呈现更加准确和符合业务规则。</p>\n</li>\n<li><p>简化应用程序开发：通过在数据库中创建视图，可以为应用程序提供简化的数据访问接口。应用程序可以直接使用视图来进行数据查询，而无需了解和处理底层表的复杂性。这简化了应用程序的开发过程，并提高了开发效率。</p>\n</li>\n<li><p>性能优化：在某些情况下，数据库视图可以提高查询性能。通过预先定义并优化视图，数据库可以在查询执行时使用视图的缓存结果，减少了重复计算和查询的开销，提高了查询的性能。</p>\n</li>\n</ol>\n<p>总的来说，数据库视图提供了数据的抽象层、简化复杂查询、数据一致性和逻辑完整性、简化应用程序开发以及性能优化等作用。通过合理使用数据库视图，可以提高数据访问的灵活性、安全性和效率，减少开发工作量，并改善数据库的性能。</p>\n<h1 id=\"manager-和-getRepository\"><a href=\"#manager-和-getRepository\" class=\"headerlink\" title=\".manager 和.getRepository()\"></a>.manager 和.getRepository()</h1><h2 id=\"简单来说\"><a href=\"#简单来说\" class=\"headerlink\" title=\"简单来说\"></a>简单来说</h2><p>Repository 与 manager 相似，增删改查更具体，会具体到传入的实体</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p><code>.manager</code> 和 <code>.getRepository()</code> 都是 TypeORM 中用于执行数据库操作的方法，但它们有一些不同的使用场景和用途。</p>\n<ol>\n<li><p><code>.manager</code>：</p>\n<ul>\n<li><code>.manager</code> 是 TypeORM 中的一个属性，用于获取当前数据库连接的管理器（EntityManager）。管理器是 TypeORM 中的一个核心对象，用于执行数据库操作，包括插入、更新、删除和查询等。</li>\n<li>通过 <code>.manager</code> 可以直接执行数据库操作，例如使用 <code>.save()</code> 方法保存实体、使用 <code>.remove()</code> 方法删除实体、使用 <code>.query()</code> 方法执行原生 SQL 查询等。</li>\n<li><strong>管理器提供了更灵活的操作方式，可以进行高级的数据库操作和事务管理</strong>。</li>\n</ul>\n</li>\n<li><p><code>.getRepository()</code>：</p>\n<ul>\n<li><code>.getRepository()</code> 是 TypeORM 中的一个方法，用于获取特定实体类（Entity）的存储库（Repository）。</li>\n<li>存储库是 TypeORM 中的一个概念，它提供了对实体类的常见数据库操作的封装，如插入、更新、删除和查询等。通过存储库，可以方便地执行与实体类相关的操作，而无需编写复杂的 SQL 查询。</li>\n<li><code>.getRepository()</code> 方法接受实体类作为参数，并返回该实体类对应的存储库实例。然后可以使用存储库提供的方法进行数据库操作，如 <code>.save()</code>、<code>.remove()</code>、<code>.findOne()</code>、<code>.find()</code> 等。</li>\n</ul>\n</li>\n</ol>\n<p>一般来说，使用 <code>.manager</code> 更适合需要执行高级数据库操作或需要自定义的复杂查询的场景。而使用 <code>.getRepository()</code> 更适合进行常规的实体操作，如插入、更新、删除和查询等。</p>\n<p>以下是两者的示例用法：</p>\n<p>使用 <code>.manager</code> 执行数据库操作的示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getManager &#125; from &#39;typeorm&#39;;\n\nconst entityManager &#x3D; getManager();\nconst user &#x3D; new User();\nuser.name &#x3D; &#39;John Doe&#39;;\n\nawait entityManager.save(user);\nawait entityManager.remove(user);\nconst result &#x3D; await entityManager.query(&#39;SELECT * FROM users&#39;);</code></pre>\n\n<p>使用 <code>.getRepository()</code> 执行数据库操作的示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getRepository &#125; from &#39;typeorm&#39;;\n\nconst userRepository &#x3D; getRepository(User);\nconst user &#x3D; new User();\nuser.name &#x3D; &#39;John Doe&#39;;\n\nawait userRepository.save(user);\nawait userRepository.remove(user);\nconst result &#x3D; await userRepository.findOne(&#123; id: 1 &#125;);</code></pre>\n\n<p>根据具体的需求和场景，可以选择使用 <code>.manager</code> 或 <code>.getRepository()</code> 进行适当的数据库操作。</p>\n<h1 id=\"查询相关的配置-（Find-Options）-详细文档\"><a href=\"#查询相关的配置-（Find-Options）-详细文档\" class=\"headerlink\" title=\"查询相关的配置 （Find Options） 详细文档\"></a>查询相关的配置 （Find Options） <a href=\"https://typeorm.io/find-options\" target=\"_blank\" >详细文档</a></h1><h2 id=\"typeorm-Find-Options-简单配置有哪些？\"><a href=\"#typeorm-Find-Options-简单配置有哪些？\" class=\"headerlink\" title=\"typeorm Find Options 简单配置有哪些？\"></a>typeorm Find Options 简单配置有哪些？</h2><p>在 TypeORM 中，常用的基本查询配置选项包括：</p>\n<ol>\n<li><p><code>where</code>: 指定查询的条件表达式，可以使用实体属性、操作符和值进行比较。</p>\n</li>\n<li><p><code>relations</code>: 指定要同时加载的关联实体。</p>\n</li>\n<li><p><code>order</code>: 指定查询结果的排序顺序。</p>\n</li>\n<li><p><code>skip</code> 和 <code>take</code>: 用于分页查询，指定要跳过的记录数量和要返回的记录数量。</p>\n</li>\n<li><p><code>select</code>: 指定要返回的实体属性。</p>\n</li>\n<li><p><code>join</code>: 指定要执行的关联查询。</p>\n</li>\n<li><p><code>group</code>: 指定查询结果的分组条件。</p>\n</li>\n<li><p><code>cache</code>: 指定查询是否应该使用缓存。</p>\n</li>\n</ol>\n<p>这些基本配置选项可以根据具体的需求进行组合和定制，用于在查询实体时指定特定的条件、排序、关联加载、分页等操作。</p>\n<p>以下是一个基本的示例，展示了如何使用这些基本配置选项：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; getRepository &#125; from &#39;typeorm&#39;;\n\nconst userRepository &#x3D; getRepository(User);\n\nconst options &#x3D; &#123;\n  where: &#123;\n    age: 25,\n    isActive: true,\n  &#125;,\n  relations: [&#39;posts&#39;],\n  order: &#123;\n    createdDate: &#39;DESC&#39;,\n  &#125;,\n  skip: 0,\n  take: 10,\n  select: [&#39;id&#39;, &#39;name&#39;],\n  join: &#123;\n    alias: &#39;user&#39;,\n    innerJoin: &#123;\n      &#39;user.posts&#39;: &#39;post&#39;,\n    &#125;,\n  &#125;,\n  group: [&#39;category&#39;],\n  cache: true,\n&#125;;\n\nconst users &#x3D; await userRepository.find(options);</code></pre>\n\n<p>根据具体的业务需求，你可以选择适当的查询选项来定制查询行为。以上列出的基本配置选项提供了一些常见的用法示例，但并不限于此，你可以根据具体情况进行进一步的定制和组合。</p>\n<h2 id=\"高级配置\"><a href=\"#高级配置\" class=\"headerlink\" title=\"高级配置\"></a>高级配置</h2><p>可以将 typeorm 的高级配置进一步简化为以下几个方面：</p>\n<ol>\n<li><p>比较符号：用于定义在查询中使用的比较符号，例如等于、大于等。比如 <code>Equal</code>, <code>MoreThan</code>, <code>LessThanOrEqual</code> 等。</p>\n</li>\n<li><p>逻辑符号：用于定义查询中的逻辑操作符，例如 AND、OR 等。比如 <code>And</code>, <code>Or</code>, <code>Not</code> 等。</p>\n</li>\n<li><p>关联关系：用于在查询中包含实体之间的关联关系，例如通过外键关联的两个实体之间的关系等。比如 <code>Join</code>, <code>LeftJoinAndSelect</code> 等。</p>\n</li>\n<li><p>其他：还有其他的高级配置，例如排序、分组、选取指定字段等。比如 <code>OrderBy</code>, <code>Select</code> 等。</p>\n</li>\n</ol>\n<h2 id=\"高级配置示例\"><a href=\"#高级配置示例\" class=\"headerlink\" title=\"高级配置示例\"></a>高级配置示例</h2><ol>\n<li><code>Not</code>：用于指定查询条件的否定，即排除满足特定条件的实体。例如：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Not &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询不满足条件的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; age: Not(25) &#125; &#125;);</code></pre>\n\n<ol start=\"2\">\n<li><code>In</code>：用于指定一个属性值必须在给定的值数组中的查询条件。例如：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; In &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询满足条件的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; role: In([&#39;admin&#39;, &#39;manager&#39;]) &#125; &#125;);</code></pre>\n\n<ol start=\"3\">\n<li><code>Like</code>：用于在查询条件中模糊匹配字符串。例如：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Like &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询名称以 &quot;John&quot; 开头的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; name: Like(&#39;John%&#39;) &#125; &#125;);</code></pre>\n\n<ol start=\"4\">\n<li><code>Between</code>：用于指定一个属性值在指定的范围内的查询条件。例如：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Between &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询年龄在 18 到 30 之间的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; age: Between(18, 30) &#125; &#125;);</code></pre>\n\n<ol start=\"5\">\n<li><code>IsNull</code> 和 <code>IsNotNull</code>：用于查询属性值是否为 null 或非 null。例如：</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; IsNull, IsNotNull &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询名字为空的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; name: IsNull() &#125; &#125;);\n\n&#x2F;&#x2F; 查询名字不为空的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; name: IsNotNull() &#125; &#125;);</code></pre>\n\n<p>这些高级查询选项提供了更灵活和强大的查询能力，可以根据具体的业务需求来使用。请参考 TypeORM 的文档以获取更多关于高级查询选项的详细信息和示例。</p>\n<p>使用 typeorm 提供的相关 API<br><a href=\"https://typeorm.io/find-options#advanced-options\" target=\"_blank\" >advanced-options</a></p>\n<h1 id=\"关联关系\"><a href=\"#关联关系\" class=\"headerlink\" title=\"关联关系\"></a>关联关系</h1><h1 id=\"实体管理器-manager\"><a href=\"#实体管理器-manager\" class=\"headerlink\" title=\"实体管理器 manager\"></a>实体管理器 manager</h1><p>实体管理器 manager 上有这一系列 API 用于数据库的增删改查</p>\n<h2 id=\"有哪些-API\"><a href=\"#有哪些-API\" class=\"headerlink\" title=\"有哪些 API\"></a>有哪些 API</h2><p>因为 chatGPT 给的不全，typeof 文档上也能看到，但是这里直接找源码查看</p>\n<p><a href=\"https://github.com/typeorm/typeorm/blob/d4607a86723eef07e62e6d7321a07f3ae5ed1f90/src/data-source/DataSource.ts#LL146C29-L146C48\" target=\"_blank\" >src&#x2F;data-source&#x2F;DataSource.ts</a></p>\n<ol>\n<li>通过官方文档可知，manager 从 <code>DataSource</code>类的实例上获取，也就是 <code>manager</code> 是 <code>DataSource</code>类 的属性</li>\n<li>从上述连接源码可知： <code>this.manager = this.createEntityManager()</code></li>\n<li>所以要查看 manager 有哪些 API, 只需要看 <code>DataSource</code> 类的 <code>createEntityManager</code>方法的返回值类型</li>\n</ol>\n<p><a href=\"https://github.com/typeorm/typeorm/blob/d4607a86723eef07e62e6d7321a07f3ae5ed1f90/src/entity-manager/EntityManager.ts#LL46C1-L1512C2\" target=\"_blank\" >src&#x2F;entity-manager&#x2F;EntityManager.ts</a></p>\n<p>源码从 173 行开始就是想关 API 了</p>\n<img src=\"http://t-blog-images.aijs.top/img/202305111852921.webp\" />\n\n<p>图中出现多个重复的情况，可以理解为“多态”吧，参数不同，自动调用不同的方法</p>\n<h2 id=\"manager-increment\"><a href=\"#manager-increment\" class=\"headerlink\" title=\"manager.increment\"></a>manager.increment</h2><p><code>await manager.increment(User, &#123; firstName: &quot;Timber&quot; &#125;, &quot;age&quot;, 3)</code> 是 TypeORM 中用于增加实体的指定属性值的方法。</p>\n<p>这个方法的作用是在指定的实体中增加特定属性的值。它接受以下参数：</p>\n<ol>\n<li><p>第一个参数是实体的类名或实体对象。在这个例子中，传入的是 <code>User</code> 类型或者 <code>User</code> 实体对象。</p>\n</li>\n<li><p>第二个参数是一个条件对象，用于确定要增加属性值的实体。在这个例子中，传入的是 <code>&#123; firstName: &quot;Timber&quot; &#125;</code>，表示要增加 <code>firstName</code> 为 “Timber” 的实体的属性值。</p>\n</li>\n<li><p>第三个参数是要增加的属性的名称。在这个例子中，传入的是 <code>&quot;age&quot;</code>，表示要增加实体的 <code>age</code> 属性值。</p>\n</li>\n<li><p>第四个参数是要增加的值的数量。在这个例子中，传入的是 <code>3</code>，表示要将 <code>age</code> 属性的值增加 3。</p>\n</li>\n</ol>\n<p>示例中的代码表示在满足条件 <code>&#123; firstName: &quot;Timber&quot; &#125;</code> 的 <code>User</code> 实体中，将 <code>age</code> 属性的值增加 3。</p>\n<p>请注意，该方法会直接更新数据库中的对应实体的属性值，并返回一个 Promise 对象。可以使用 <code>await</code> 关键字等待操作完成。</p>\n<h2 id=\"manager-increment-返回所有更新的-id-吗？\"><a href=\"#manager-increment-返回所有更新的-id-吗？\" class=\"headerlink\" title=\"manager.increment 返回所有更新的 id 吗？\"></a>manager.increment 返回所有更新的 id 吗？</h2><p><code>manager.increment()</code> 方法在增加属性值时，并不会返回更新的实体的 ID。它仅仅是更新了数据库中对应实体的属性值，而不会返回任何实体或 ID。</p>\n<p>如果您需要获取更新后的实体或 ID，可以使用 <code>manager.findOne()</code> 或 <code>manager.find()</code> 方法来执行查询操作，以获取更新后的实体的信息。</p>\n<p>例如，您可以在执行 <code>manager.increment()</code> 后立即执行一个查询，以获取更新后的实体的 ID，如下所示：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const incrementedUser &#x3D; await manager.increment(User, &#123; firstName: &#39;Timber&#39; &#125;, &#39;age&#39;, 3);\nconst updatedUser &#x3D; await manager.findOne(User, &#123; firstName: &#39;Timber&#39; &#125;);\n\n&#x2F;&#x2F; 获取更新后的实体的 ID\nconst updatedUserId &#x3D; updatedUser.id;</code></pre>\n\n<p>在上面的示例中，我们执行了 <code>manager.increment()</code> 来增加 <code>firstName</code> 为 “Timber” 的 <code>User</code> 实体的 <code>age</code> 属性值。然后，我们使用 <code>manager.findOne()</code> 查询更新后的实体，并获取其 ID。</p>\n<p>请注意，执行查询操作后，您将获得更新后的实体的完整信息，包括 ID 和其他属性。</p>\n<h2 id=\"manager-count\"><a href=\"#manager-count\" class=\"headerlink\" title=\"manager.count\"></a>manager.count</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const count &#x3D; await manager.count(User, &#123;\n  where: &#123;\n    firstName: &#39;Timber&#39;,\n  &#125;,\n&#125;);</code></pre>\n\n<p><code>const count = await manager.count(User, &#123; where: &#123; firstName: &quot;Timber&quot; &#125; &#125;)</code> 是 TypeORM 中用于计算满足指定条件的实体数量的方法。</p>\n<p>这个方法的作用是计算数据库中满足特定条件的实体的数量。它接受以下参数：</p>\n<ol>\n<li><p>第一个参数是实体的类名或实体对象。在这个例子中，传入的是 <code>User</code> 类型或者 <code>User</code> 实体对象。</p>\n</li>\n<li><p>第二个参数是一个条件对象，用于确定要计算数量的实体。在这个例子中，传入的是 <code>&#123; where: &#123; firstName: &quot;Timber&quot; &#125; &#125;</code>，表示要计算 <code>firstName</code> 为 “Timber” 的实体的数量。</p>\n</li>\n</ol>\n<p>示例中的代码表示计算数据库中 <code>User</code> 实体中 <code>firstName</code> 为 “Timber” 的实体数量，并将结果赋值给 <code>count</code> 变量。</p>\n<p>这个方法返回一个 Promise，解析为满足条件的实体的数量。您可以使用 <code>await</code> 关键字等待结果的解析。</p>\n<h2 id=\"manager-countBy\"><a href=\"#manager-countBy\" class=\"headerlink\" title=\"manager.countBy\"></a>manager.countBy</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const count &#x3D; await manager.countBy(User, &#123; firstName: &#39;Timber&#39; &#125;);</code></pre>\n\n<p>在 TypeORM 中，没有名为 <code>countBy()</code> 的方法。但是，您可以使用 <code>count()</code> 方法和适当的查询条件来实现类似的功能。</p>\n<p>以下是使用 <code>count()</code> 方法计算满足指定条件的实体数量的示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const count &#x3D; await manager.count(User, &#123; where: &#123; firstName: &#39;Timber&#39; &#125; &#125;);</code></pre>\n\n<p>上述代码使用 <code>count()</code> 方法来计算满足条件 <code>&#123; firstName: &quot;Timber&quot; &#125;</code> 的 <code>User</code> 实体的数量，并将结果赋值给变量 <code>count</code>。</p>\n<p>请注意，<code>count()</code> 方法返回一个 Promise，解析为满足条件的实体的数量。您可以使用 <code>await</code> 关键字等待结果的解析。</p>\n<h2 id=\"manager-count-vs-manager-countBy\"><a href=\"#manager-count-vs-manager-countBy\" class=\"headerlink\" title=\"manager.count vs manager.countBy\"></a>manager.count vs manager.countBy</h2><p><code>manager.*By</code>api 是对 <code>manager.*</code>的简化，能省掉 <code>where</code></p>\n<h1 id=\"Query-Builder\"><a href=\"#Query-Builder\" class=\"headerlink\" title=\"Query Builder\"></a>Query Builder</h1><p>哈～， 建造者模式</p>\n<p><a href=\"https://typeorm.io/select-query-builder\" target=\"_blank\" >Query Builder</a></p>\n<h2 id=\"query-builder-属于建造者模式\"><a href=\"#query-builder-属于建造者模式\" class=\"headerlink\" title=\"query builder 属于建造者模式\"></a>query builder 属于建造者模式</h2><p>是的，TypeORM 中的 Query Builder 属于建造者模式（Builder Pattern）的一种实现。</p>\n<p>建造者模式是一种创建对象的设计模式，它将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。在 TypeORM 中，Query Builder 提供了一种流畅且可组合的方式来构建复杂的查询，同时允许以多种形式表示查询条件、关联关系、排序等。</p>\n<p>使用 Query Builder，您可以逐步构建查询，通过链式调用方法来添加各种查询条件和操作。它提供了一系列方法，例如 <code>select()</code>、<code>where()</code>、<code>leftJoinAndSelect()</code>、<code>orderBy()</code> 等，可以根据需要按照特定的顺序和逻辑组合这些方法，构建出复杂的查询语句。</p>\n<p>Query Builder 的优势在于它提供了更灵活和可读性更好的方式来构建查询，同时还可以根据需要动态地添加、修改或删除查询条件，使得查询的构建过程更加可控和可扩展。</p>\n<p>需要注意的是，<strong>Query Builder 并不是强制性使用的，您也可以直接使用原生的 SQL 查询或者使用 Repository 提供的方法来执行查询操作。Query Builder 更适用于需要动态构建查询的场景或者复杂的查询需求。</strong></p>\n<h2 id=\"三种方式创建-QueryBuilder\"><a href=\"#三种方式创建-QueryBuilder\" class=\"headerlink\" title=\"三种方式创建 QueryBuilder\"></a>三种方式创建 QueryBuilder</h2><h3 id=\"使用数据源-创建和使用-QueryBuilder\"><a href=\"#使用数据源-创建和使用-QueryBuilder\" class=\"headerlink\" title=\"使用数据源 创建和使用 QueryBuilder\"></a>使用数据源 创建和使用 QueryBuilder</h3><p>在 TypeORM 中，您可以使用数据源（Connection）来创建和使用 QueryBuilder。以下是使用数据源创建和使用 QueryBuilder 的示例：</p>\n<ol>\n<li><p>创建 QueryBuilder 实例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const connection &#x3D; await createConnection(&#123;\n  type: &#39;mysql&#39;,\n  host: &#39;localhost&#39;,\n  port: 3306,\n  username: &#39;username&#39;,\n  password: &#39;password&#39;,\n  database: &#39;database&#39;,\n&#125;);\n\nconst queryBuilder &#x3D; connection.createQueryBuilder();</code></pre>\n</li>\n<li><p>使用 QueryBuilder 进行查询操作：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const queryBuilder &#x3D; connection.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();</code></pre></li>\n</ol>\n<p>在上述示例中，我们首先创建了一个数据源（Connection），然后使用 <code>createQueryBuilder()</code> 方法创建了一个 QueryBuilder 实例。接下来，我们可以使用 QueryBuilder 进行查询操作，例如选择字段、设置表名、设置查询条件等。最后，我们通过调用适当的方法（如 <code>getMany()</code>）来执行查询并获取结果。</p>\n<p>请注意，具体的数据库连接配置参数（如 <code>type</code>、<code>host</code>、<code>port</code>、<code>username</code>、<code>password</code>、<code>database</code> 等）需要根据您的实际数据库配置进行调整。</p>\n<p>使用数据源创建和使用 QueryBuilder 的方式与使用实体管理器（EntityManager）或自定义仓库（Custom Repository）创建和使用 QueryBuilder 的方式相似。只是在创建 QueryBuilder 时，使用的是数据源的 <code>createQueryBuilder()</code> 方法来创建实例。</p>\n<p>希望这可以帮助您理解如何使用数据源创建和使用 QueryBuilder。如有任何疑问，请随时提问。</p>\n<h3 id=\"from-User-quot-user-quot\"><a href=\"#from-User-quot-user-quot\" class=\"headerlink\" title=\".from(User, &quot;user&quot;)\"></a><code>.from(User, &quot;user&quot;)</code></h3><p>在 TypeORM 的 QueryBuilder 中，<code>.from(User, &quot;user&quot;)</code> 是用于指定查询的主体表的方法。</p>\n<p>在这个例子中，<code>.from(User, &quot;user&quot;)</code> 指定了查询的主体表为名为 “user” 的表，而该表对应的实体类是 <code>User</code>。这样，在后续的查询操作中，我们可以使用 “user” 作为表的别名来引用该表。</p>\n<p>以下是一个完整的示例，演示了如何使用 <code>.from()</code> 方法来指定查询的主体表：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const queryBuilder &#x3D; connection.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;) &#x2F;&#x2F; 指定主体表为 &quot;user&quot;，对应的实体类是 User\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();</code></pre>\n\n<p>在上述示例中，我们在 <code>.from()</code> 方法中指定了主体表为 “user”，并使用 <code>.where()</code> 方法来添加一个条件，判断年龄是否大于 18。这样，后续的查询操作中，可以使用 “user” 作为表的别名来引用该表的列。</p>\n<p>请注意，表的别名可以根据需要进行调整，只需确保在后续的查询操作中使用相应的别名即可。</p>\n<p>希望这可以解答您的疑问。如果还有其他问题，请随时提问。</p>\n<h3 id=\"使用实体管理器-创建和使用-QueryBuilder\"><a href=\"#使用实体管理器-创建和使用-QueryBuilder\" class=\"headerlink\" title=\"使用实体管理器 创建和使用 QueryBuilder\"></a>使用实体管理器 创建和使用 QueryBuilder</h3><p>在 TypeORM 中，您可以使用实体管理器（EntityManager）来创建和使用 QueryBuilder。以下是使用实体管理器创建和使用 QueryBuilder 的示例：</p>\n<ol>\n<li><p>创建 QueryBuilder 实例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const entityManager &#x3D; getConnection().manager;\nconst queryBuilder &#x3D; entityManager.createQueryBuilder();</code></pre>\n</li>\n<li><p>使用 QueryBuilder 进行查询操作：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const entityManager &#x3D; getConnection().manager;\nconst queryBuilder &#x3D; entityManager.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();</code></pre></li>\n</ol>\n<p>在上述示例中，我们首先通过 <code>getConnection().manager</code> 获取实体管理器实例（EntityManager），然后使用 <code>createQueryBuilder()</code> 方法创建一个 QueryBuilder 实例。接下来，我们可以使用 QueryBuilder 进行查询操作，例如选择字段、设置表名、设置查询条件等。最后，我们通过调用适当的方法（如 <code>getMany()</code>）来执行查询并获取结果。</p>\n<p>需要注意的是，在使用实体管理器创建 QueryBuilder 时，可以直接从 <code>getConnection().manager</code> 获取实体管理器实例，也可以通过 <code>entityManager</code> 对象的方式获取实体管理器实例。</p>\n<p>希望这可以帮助您理解如何使用实体管理器创建和使用 QueryBuilder。如果还有任何疑问，请随时提问。</p>\n<h3 id=\"使用存储库-创建和使用-QueryBuilder\"><a href=\"#使用存储库-创建和使用-QueryBuilder\" class=\"headerlink\" title=\"使用存储库 创建和使用 QueryBuilder\"></a>使用存储库 创建和使用 QueryBuilder</h3><p>在 TypeORM 中，您可以使用存储库（Repository）来创建和使用 QueryBuilder。以下是使用存储库创建和使用 QueryBuilder 的示例：</p>\n<ol>\n<li><p>获取实体的存储库实例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const userRepository &#x3D; getConnection().getRepository(User);</code></pre>\n</li>\n<li><p>使用存储库的 <code>createQueryBuilder()</code> 方法创建 QueryBuilder 实例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const queryBuilder &#x3D; userRepository.createQueryBuilder();</code></pre>\n</li>\n<li><p>使用 QueryBuilder 进行查询操作：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const userRepository &#x3D; getConnection().getRepository(User);\nconst queryBuilder &#x3D; userRepository.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();</code></pre></li>\n</ol>\n<p>在上述示例中，我们首先通过 <code>getConnection().getRepository(User)</code> 获取实体 <code>User</code> 的存储库实例（UserRepository）。然后，使用存储库的 <code>createQueryBuilder()</code> 方法创建一个 QueryBuilder 实例。接下来，我们可以使用 QueryBuilder 进行查询操作，例如选择字段、设置表名、设置查询条件等。最后，通过调用适当的方法（如 <code>getMany()</code>）来执行查询并获取结果。</p>\n<p>需要注意的是，在使用存储库创建 QueryBuilder 时，我们首先获取实体的存储库实例，然后使用存储库实例的 <code>createQueryBuilder()</code> 方法创建 QueryBuilder 实例。</p>\n<p>希望这可以帮助您理解如何使用存储库创建和使用 QueryBuilder。如果还有任何疑问，请随时提问。</p>\n<h2 id=\"userRepository-为什么叫存储库实例，什么是存储库？\"><a href=\"#userRepository-为什么叫存储库实例，什么是存储库？\" class=\"headerlink\" title=\"userRepository 为什么叫存储库实例，什么是存储库？\"></a>userRepository 为什么叫存储库实例，什么是存储库？</h2><p>在 TypeORM 中，存储库（Repository）是一种设计模式，用于封装对数据库实体的常见操作，如创建、读取、更新和删除（CRUD）操作。存储库提供了一种方便的方式来管理实体对象的持久化和查询。</p>\n<p>存储库的主要目的是为了解耦业务逻辑与底层数据访问层（数据库）之间的关系。它提供了一个抽象层，使业务逻辑能够以更高层次的概念与实体进行交互，而不需要直接处理底层的数据库连接和查询语句。</p>\n<p>在 TypeORM 中，每个实体类（Entity）都可以有一个对应的存储库（Repository），用于管理该实体的持久化和查询操作。存储库提供了一组方法，例如 <code>find()</code>、<code>findOne()</code>、<code>save()</code>、<code>remove()</code> 等，用于执行各种数据库操作。</p>\n<p>当我们通过 <code>getConnection().getRepository(User)</code> 获取到 <code>User</code> 实体的存储库实例时，我们就可以使用该实例来执行对 <code>User</code> 实体的操作，例如保存新的用户、查询用户信息、更新用户数据等。</p>\n<p>存储库的好处在于，它封装了与数据库的交互细节，使得业务逻辑的代码更加简洁、可维护。它还提供了一些便捷的方法和查询构建器（如 QueryBuilder）来简化常见的数据库操作。</p>\n<p>因此，当我们将 <code>userRepository</code> 称为存储库实例时，意味着它是用于管理特定实体（如 <code>User</code>）的存储库的一个实例。我们可以通过该实例调用存储库提供的方法，执行对实体的操作。</p>\n<p>希望这能够解答您的疑问。如果还有其他问题，请随时提问。</p>\n<h2 id=\"还是不懂\"><a href=\"#还是不懂\" class=\"headerlink\" title=\"还是不懂\"></a>还是不懂</h2><p>存储库（Repository）是一个设计模式，用于将实体（Entity）的持久化和检索操作与业务逻辑分离开来。通过将实体的 CRUD 操作封装在存储库中，可以在不影响业务逻辑的情况下，灵活地更改数据访问层的实现细节，比如更改数据库类型或者更换 ORM 框架。</p>\n<p>在 TypeORM 中，存储库是对实体管理器的封装，提供了与实体相关的各种操作方法，如保存（save）、删除（delete）、查找（find）等。使用存储库可以简化对实体的 CRUD 操作，提高代码的可读性和可维护性。</p>\n<h2 id=\"存储库可以理解为，将某个实体看成一个库，可以对其做-CRUD-操作？\"><a href=\"#存储库可以理解为，将某个实体看成一个库，可以对其做-CRUD-操作？\" class=\"headerlink\" title=\"存储库可以理解为，将某个实体看成一个库，可以对其做 CRUD 操作？\"></a>存储库可以理解为，将某个实体看成一个库，可以对其做 CRUD 操作？</h2><p>是的，您可以将存储库理解为一个将某个实体看作一个“库”或“集合”，并提供对该实体进行 CRUD（创建、读取、更新、删除）操作的接口。存储库封装了与实体相关的数据库操作，使得在业务逻辑中使用存储库更加方便和可读。</p>\n<p>通过存储库，您可以对实体执行各种操作，如创建新的实体对象并保存到数据库中、从数据库中检索实体、更新现有实体的属性或关系、删除实体等。存储库提供了一组方法来执行这些操作，使您能够以面向实体的方式进行操作，而不必直接编写底层的 SQL 查询语句。</p>\n<p>存储库的好处之一是将数据访问层与业务逻辑层分离，使得代码结构更加清晰和可维护。通过使用存储库，您可以将数据库操作与实体的业务逻辑分离开来，使代码更易于理解、测试和扩展。</p>\n<p>总之，存储库可以被视为一个用于对特定实体执行 CRUD 操作的接口或抽象，它提供了一组方法来操作实体并与底层数据库进行交互。</p>\n<p>希望这能够帮助您理解存储库的概念。如果还有其他问题，请随时提问。</p>\n<h2 id=\"将数据访问层与业务逻辑层分离，体现在哪，我没看出来呢\"><a href=\"#将数据访问层与业务逻辑层分离，体现在哪，我没看出来呢\" class=\"headerlink\" title=\"将数据访问层与业务逻辑层分离，体现在哪，我没看出来呢\"></a>将数据访问层与业务逻辑层分离，体现在哪，我没看出来呢</h2><p>将数据访问层与业务逻辑层分离体现在以下几个方面：</p>\n<ol>\n<li><p>代码结构清晰：通过使用存储库，您可以将数据访问相关的代码独立于业务逻辑代码，将它们分别放置在不同的模块或文件中。这样，代码结构更加清晰，易于理解和维护。</p>\n</li>\n<li><p>解耦合：存储库将实体的持久化和查询操作封装起来，使得业务逻辑层不需要直接处理数据库连接和查询语句。业务逻辑层只需要通过存储库提供的接口方法来执行相应的操作，而无需关注底层的数据访问细节。这样可以实现业务逻辑层与数据访问层的解耦合，提高代码的可维护性和可测试性。</p>\n</li>\n<li><p>抽象数据访问层：存储库提供了一组抽象的方法来执行对实体的操作，例如保存、检索、更新和删除。这些方法屏蔽了底层数据库的细节，使得业务逻辑层可以通过简单的方法调用来完成对实体的操作，而不需要编写复杂的 SQL 查询语句。</p>\n</li>\n<li><p>可替换性：通过使用存储库，可以轻松更改底层的数据访问技术或数据库类型，而不需要修改业务逻辑层的代码。例如，如果将数据库从 MySQL 切换到 PostgreSQL，只需更改存储库的配置，而不会对业务逻辑层产生影响。</p>\n</li>\n</ol>\n<p>综上所述，将数据访问层与业务逻辑层分离使得代码更加模块化、可扩展和可维护。通过使用存储库，业务逻辑层可以专注于业务逻辑的实现，而不必关心底层的数据访问细节，提高了代码的可读性和可维护性。</p>\n<p>希望这能够更好地解释数据访问层与业务逻辑层分离的概念。如果还有其他问题，请随时提问。</p>\n<h2 id=\"处理关系-关联时候能够提升性能\"><a href=\"#处理关系-关联时候能够提升性能\" class=\"headerlink\" title=\"处理关系[关联时候能够提升性能]\"></a>处理关系[关联时候能够提升性能]</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">await dataSource\n    .createQueryBuilder()\n    .relation(Post, &quot;categories&quot;)\n    .of(post)\n    .add(category)\n\n性能更高，为什么？</code></pre>\n\n<p>这段代码使用 TypeORM 的 QueryBuilder 和关系操作功能来将一个特定的分类（category）与给定的帖子（post）建立关联关系。</p>\n<p>在性能方面，这种方法相对高效的原因有几点：</p>\n<ol>\n<li><p><code>直接操作关系</code>：通过使用 <code>.relation()</code> 方法，可以直接在数据库中操作实体之间的关系，而无需加载整个实体对象。这样可以避免加载和更新实体本身的所有属性，减少了数据传输和数据库操作的开销。</p>\n</li>\n<li><p><code>批量操作</code>：在一次查询中，可以同时处理多个关系操作。在上述代码中，<code>.add(category)</code> 可以将给定的分类添加到帖子的分类列表中。这种批量操作可以减少与数据库的交互次数，提高性能。</p>\n</li>\n<li><p><code>不加载整个实体</code>：通过使用关系操作功能，可以避免加载整个实体对象，仅仅操作关系表的数据。这对于大型数据集和复杂关系的情况下尤其有效，因为不需要加载和处理整个实体的所有属性，从而减少了内存和计算资源的消耗。</p>\n</li>\n</ol>\n<p>总而言之，使用 TypeORM 的关系操作功能可以提供更高的性能，因为它直接操作关系表，支持批量操作，并避免加载整个实体对象。这些优化可以减少数据库操作的次数和数据传输的开销，从而提高性能。</p>\n<p>需要注意的是，性能优化是一个复杂的问题，具体的性能差异可能取决于实际的数据库结构、数据量和使用的数据库引擎。在实际使用中，建议进行基准测试和性能分析，以确定最适合您特定场景的最佳性能优化方法。</p>\n<p>希望这能够回答您的问题。如果还有其他疑问，请随时提问。</p>\n<h2 id=\"首先不晓得代码是什么意思\"><a href=\"#首先不晓得代码是什么意思\" class=\"headerlink\" title=\"首先不晓得代码是什么意思\"></a>首先不晓得代码是什么意思</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">await dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(&#123; firstPostId: 1, secondPostId: 3 &#125;)\n  .add(&#123; firstCategoryId: 2, secondCategoryId: 4 &#125;);</code></pre>\n\n<p>上述代码使用 TypeORM 的 QueryBuilder 和关系操作功能来将多个分类与多个帖子建立关联关系。</p>\n<p>根据提供的代码，我们可以假设以下情况：</p>\n<ol>\n<li><code>Post</code> 实体具有名为 <code>categories</code> 的关系属性，表示帖子与分类之间的关系。</li>\n<li><code>Category</code> 实体具有名为 <code>id</code> 的属性，用于标识分类的唯一性。</li>\n</ol>\n<p>基于这些假设，上述代码的目的是将 ID 为 2 和 4 的分类分别与 ID 为 1 和 3 的帖子建立关联关系。</p>\n<p>具体生成的 SQL 查询语句将类似于以下内容：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">INSERT INTO post_categories_post (postId, categoryId) VALUES (1, 2), (3, 4);</code></pre>\n\n<p>上述 SQL 查询语句将在 <code>post_categories_post</code> 表中插入新的关联关系记录，其中 <code>(1, 2)</code> 表示将 ID 为 2 的分类与 ID 为 1 的帖子建立关联关系，<code>(3, 4)</code> 表示将 ID 为 4 的分类与 ID 为 3 的帖子建立关联关系。</p>\n<p>请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。</p>\n<p>希望这能够回答您的问题。如果还有其他疑问，请随时提问。</p>\n<h2 id=\"如果是-1-2-3-4-5-6-该如何书写-queryBuilder【注意啊，这个代码关系是组合】\"><a href=\"#如果是-1-2-3-4-5-6-该如何书写-queryBuilder【注意啊，这个代码关系是组合】\" class=\"headerlink\" title=\"如果是(1,2) (3,4) (5,6),该如何书写 queryBuilder【注意啊，这个代码关系是组合】\"></a>如果是(1,2) (3,4) (5,6),该如何书写 queryBuilder【注意啊，这个代码关系是组合】</h2><p>如果要将多个帖子与多个分类建立关联关系，例如将 (1, 2)，(3, 4)，(5, 6) 这些对应的帖子和分类建立关联关系，可以使用 TypeORM 的 QueryBuilder 如下所示：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">await dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(&#123; id: [1, 3, 5] &#125;) &#x2F;&#x2F; 传入帖子的 ID 数组\n  .add(&#123; id: [2, 4, 6] &#125;); &#x2F;&#x2F; 传入分类的 ID 数组</code></pre>\n\n<p>上述代码将在 <code>Post</code> 实体的 <code>categories</code> 关系中将给定的帖子 ID 和分类 ID 建立关联关系。</p>\n<p>生成的 SQL 查询语句将类似于以下内容：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">INSERT INTO post_categories_post (postId, categoryId) VALUES\n  (1, 2),\n  (1, 4),\n  (1, 6),\n  (3, 2),\n  (3, 4),\n  (3, 6),\n  (5, 2),\n  (5, 4),\n  (5, 6);</code></pre>\n\n<p>上述 SQL 查询语句将在 <code>post_categories_post</code> 表中插入多个关联关系记录，分别表示将给定的帖子和分类之间建立关联关系。</p>\n<p>请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。</p>\n<p>希望这能够回答您的问题。如果还有其他疑问，请随时提问。</p>\n<h2 id=\"只想-1-和-2-建立关系，3-和-4-建立关系，5-和-6-建立关系\"><a href=\"#只想-1-和-2-建立关系，3-和-4-建立关系，5-和-6-建立关系\" class=\"headerlink\" title=\"只想 1 和 2 建立关系，3 和 4 建立关系，5 和 6 建立关系\"></a>只想 1 和 2 建立关系，3 和 4 建立关系，5 和 6 建立关系</h2><p>如果只想将 (1, 2)，(3, 4)，(5, 6) 这些对应的帖子和分类建立关联关系，可以使用 TypeORM 的 QueryBuilder 如下所示：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">await dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(1) &#x2F;&#x2F; 第一个帖子的 ID\n  .add(2); &#x2F;&#x2F; 第一个分类的 ID\n\nawait dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(3) &#x2F;&#x2F; 第二个帖子的 ID\n  .add(4); &#x2F;&#x2F; 第二个分类的 ID\n\nawait dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(5) &#x2F;&#x2F; 第三个帖子的 ID\n  .add(6); &#x2F;&#x2F; 第三个分类的 ID</code></pre>\n\n<p>上述代码将分别针对每对帖子和分类执行关联关系的添加操作。</p>\n<p>生成的 SQL 查询语句将类似于以下内容：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">INSERT INTO post_categories_post (postId, categoryId) VALUES\n  (1, 2),\n  (3, 4),\n  (5, 6);</code></pre>\n\n<p>上述 SQL 查询语句将在 <code>post_categories_post</code> 表中插入关联关系记录，分别表示将给定的帖子和分类之间建立关联关系。</p>\n<p>请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。</p>\n<p>希望这能够回答您的问题。如果还有其他疑问，请随时提问。</p>\n<h2 id=\"调用了三次，能简化吗\"><a href=\"#调用了三次，能简化吗\" class=\"headerlink\" title=\"调用了三次，能简化吗\"></a>调用了三次，能简化吗</h2><p>可以使用 TypeORM 的 QueryBuilder 的 <code>insert</code> 方法来实现简化：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">await dataSource\n  .createQueryBuilder()\n  .insert()\n  .into(&#39;post_categories_post&#39;)\n  .values([\n    &#123; postId: 1, categoryId: 2 &#125;,\n    &#123; postId: 3, categoryId: 4 &#125;,\n    &#123; postId: 5, categoryId: 6 &#125;,\n  ])\n  .execute();</code></pre>\n\n<p>上述代码使用 <code>insert</code> 方法将多个关联关系记录一次性插入到 <code>post_categories_post</code> 表中。</p>\n<p>生成的 SQL 查询语句将类似于以下内容：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">INSERT INTO post_categories_post (postId, categoryId) VALUES\n  (1, 2),\n  (3, 4),\n  (5, 6);</code></pre>\n\n<p>上述 SQL 查询语句将在 <code>post_categories_post</code> 表中插入关联关系记录，分别表示将给定的帖子和分类之间建立关联关系。</p>\n<p>这种方式通过一次数据库操作实现了多个关联关系的添加，可以更简洁地完成任务。</p>\n<p>希望这能够回答您的问题。如果还有其他疑问，请随时提问。</p>\n<h2 id=\"不存在的情况才进行插入？\"><a href=\"#不存在的情况才进行插入？\" class=\"headerlink\" title=\"不存在的情况才进行插入？\"></a>不存在的情况才进行插入？</h2><p>如果只想在关联关系不存在的情况下才进行插入操作，可以使用 <code>createQueryBuilder()</code> 方法创建的 QueryBuilder，并使用 <code>relation</code> 和 <code>of</code> 方法来检查关联关系是否存在，然后使用 <code>add</code> 方法添加关联关系。</p>\n<p>以下是一个示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const postId &#x3D; 1;\nconst categoryId &#x3D; 2;\n\nconst queryBuilder &#x3D; dataSource.createQueryBuilder();\nconst relationExists &#x3D; await queryBuilder.relation(Post, &#39;categories&#39;).of(postId).has(categoryId);\n\nif (!relationExists) &#123;\n  await queryBuilder.relation(Post, &#39;categories&#39;).of(postId).add(categoryId);\n&#125;</code></pre>\n\n<p>上述代码首先检查关联关系是否已存在，如果不存在则执行插入操作。</p>\n<p>这样可以确保只在关联关系不存在时才进行插入，避免重复插入已存在的关联关系。</p>\n<p>希望这能够回答您的问题。如果还有其他疑问，请随时提问。</p>\n<h2 id=\"能简化吗-见\"><a href=\"#能简化吗-见\" class=\"headerlink\" title=\"能简化吗 见\"></a>能简化吗 <a href=\"https://typeorm.io/insert-query-builder\" target=\"_blank\" >见</a></h2><p>可以使用 TypeORM 提供的 <code>createQueryBuilder</code> 的 <code>insert</code> 方法结合 <code>onConflict</code> 子句来实现插入操作时的冲突检测和条件控制。</p>\n<p>以下是一个示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">await dataSource\n  .createQueryBuilder()\n  .insert()\n  .into(&#39;post_categories_post&#39;)\n  .values([\n    &#123; postId: 1, categoryId: 2 &#125;,\n    &#123; postId: 3, categoryId: 4 &#125;,\n    &#123; postId: 5, categoryId: 6 &#125;,\n  ])\n  .onConflict(&#96;(&quot;postId&quot;, &quot;categoryId&quot;) DO NOTHING&#96;)\n  .execute();</code></pre>\n\n<p>上述代码使用 <code>insert</code> 方法将多个关联关系记录一次性插入到 <code>post_categories_post</code> 表中。<code>onConflict</code> 子句指定了在冲突发生时不进行任何操作，从而达到仅在关联关系不存在时才进行插入的效果。</p>\n<p>这样可以简化代码并确保只在关联关系不存在时才进行插入，避免重复插入已存在的关联关系。</p>\n<p>请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。</p>\n<p>希望这能够回答您的问题。如果还有其他疑问，请随时提问。</p>\n<h2 id=\"createQueryBuilder-源码\"><a href=\"#createQueryBuilder-源码\" class=\"headerlink\" title=\"createQueryBuilder 源码\"></a>createQueryBuilder 源码</h2><p><a href=\"https://github.com/typeorm/typeorm/blob/d4607a86723eef07e62e6d7321a07f3ae5ed1f90/src/data-source/DataSource.ts#LL538C1-L578C1\" target=\"_blank\" >DataSource 下的 createQueryBuilder 方法返回了 SelectQueryBuilder 构建器（建造者模式）</a></p>\n<p><a href=\"https://github.com/typeorm/typeorm/blob/d4607a86723eef07e62e6d7321a07f3ae5ed1f90/src/query-builder/SelectQueryBuilder.ts#LL52C1-L4494C2\" target=\"_blank\" >SelectQueryBuilder</a></p>\n<h2 id=\"createQueryBuilder-示例\"><a href=\"#createQueryBuilder-示例\" class=\"headerlink\" title=\"createQueryBuilder 示例\"></a>createQueryBuilder 示例</h2><p>以下是使用 TypeORM 的 <code>createQueryBuilder</code> 方法的示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; createConnection, getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; User &#125; from &#39;.&#x2F;entities&#x2F;User&#39;;\n\n&#x2F;&#x2F; 创建数据库连接\nawait createConnection();\n\n&#x2F;&#x2F; 获取查询构建器\nconst queryBuilder &#x3D; getConnection().createQueryBuilder();\n\n&#x2F;&#x2F; 构建查询\nconst result &#x3D; await queryBuilder\n  .select(&#39;user&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .orderBy(&#39;user.name&#39;, &#39;ASC&#39;)\n  .take(10)\n  .getMany();\n\n&#x2F;&#x2F; 打印查询结果\nconsole.log(result);</code></pre>\n\n<p>上述示例中，首先使用 <code>createConnection</code> 方法创建数据库连接。然后，使用 <code>getConnection</code> 方法获取连接对象，并通过调用 <code>createQueryBuilder</code> 方法创建一个查询构建器实例。</p>\n<p>接下来，通过链式调用的方式使用查询构建器构建查询，包括选择要返回的实体（<code>User</code>），添加过滤条件（<code>user.age &gt; :age</code>），指定排序规则（<code>user.name ASC</code>），以及限制返回结果的数量（<code>take(10)</code>）。</p>\n<p>最后，通过调用 <code>getMany</code> 方法执行查询并获取结果。</p>\n<p>这只是一个简单的示例，您可以根据自己的需求使用不同的查询构建器方法来构建更复杂的查询。</p>\n<p>希望这个示例对您有帮助。如果有其他问题，请随时提问。</p>\n<h2 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">await myDataSource.createQueryBuilder(&#39;users&#39;).delete().from(User).where(&#39;id &#x3D; :id&#39;, &#123; id: 1 &#125;).execute();</code></pre>\n\n<p><code>.createQueryBuilder(&#39;users&#39;)</code> 中的 <code>&#39;users&#39;</code> 是给查询构建器指定一个别名，用于在查询中引用该表或实体。</p>\n<p>在 TypeORM 的 QueryBuilder 中，通过指定别名可以在查询过程中引用表或实体，以便于构建复杂的查询逻辑。</p>\n<p>在上述代码中，<code>.createQueryBuilder(&#39;users&#39;)</code> 为查询构建器指定了别名 <code>&#39;users&#39;</code>，以便在后续的查询方法中使用该别名来引用 <code>User</code> 实体。</p>\n<p>通过指定别名，您可以在查询中引用该实体的字段、关联关系等，并进行各种查询操作，如选择特定字段、添加条件、进行排序等。</p>\n<p>希望这解释清楚了 <code>.createQueryBuilder(&#39;users&#39;)</code> 的含义。如果还有其他疑问，请随时提问。</p>\n<p><a href=\"https://typeorm.io/select-query-builder#what-are-aliases-for\" target=\"_blank\" >select-query-builder#what-are-aliases-for</a></p>\n<h2 id=\"softdelete\"><a href=\"#softdelete\" class=\"headerlink\" title=\"softdelete\"></a>softdelete</h2><p>软删除，这里就不提了，这篇文章主要是答疑</p>\n<h2 id=\"软删除对应的字段是哪个\"><a href=\"#软删除对应的字段是哪个\" class=\"headerlink\" title=\"软删除对应的字段是哪个\"></a>软删除对应的字段是哪个</h2><p>在 TypeORM 中，软删除（Soft Delete）是一种通过标记实体而不是直接从数据库中删除实体的技术。TypeORM 提供了一个装饰器 <code>@DeleteDateColumn</code> 来定义软删除相关的字段。</p>\n<p>软删除字段通常是一个日期时间类型的列，用于记录实体被标记为删除的时间。通过在实体类的属性上添加 <code>@DeleteDateColumn</code> 装饰器，可以指定软删除字段的名称和类型。</p>\n<p>以下是一个示例，展示如何在 TypeORM 中定义软删除字段：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Entity, PrimaryGeneratedColumn, Column, DeleteDateColumn &#125; from &#39;typeorm&#39;;\n\n@Entity()\nexport class User &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @DeleteDateColumn(&#123; name: &#39;deleted_at&#39; &#125;)\n  deletedAt: Date;\n&#125;</code></pre>\n\n<p>在上述示例中，<code>User</code> 实体类具有一个名为 <code>deletedAt</code> 的软删除字段，其类型为 <code>Date</code>。通过添加 <code>@DeleteDateColumn</code> 装饰器，并指定 <code>name</code> 参数为数据库表中的字段名（例如 <code>deleted_at</code>），可以定义软删除字段。</p>\n<p>当使用 TypeORM 的删除操作时，它会将软删除字段设置为实体的删除时间，而不是直接从数据库中删除实体记录。</p>\n<p>请注意，要启用软删除功能，还需要在 TypeORM 的连接配置中设置 <code>softDelete: true</code>。</p>\n<p>希望这个解释对您有所帮助！如果您有其他问题，请随时提问。</p>\n<h1 id=\"转译，以解决安全问题\"><a href=\"#转译，以解决安全问题\" class=\"headerlink\" title=\"转译，以解决安全问题\"></a>转译，以解决安全问题</h1><p>我们用过 <code>where(&quot;user.name = :name&quot;, &#123; name: &quot;Timber&quot; &#125;)</code>。<code>&#123; name: &quot;Timber&quot; &#125;</code>代表什么？它是我们用来防止 SQL 注入的参数。我们可以这样写：<code>where(&quot;user.name = &#39;&quot; + name + &quot;&#39;)</code>，但是这并不安全，因为它打开了 SQL 注入的代码。安全的方法是使用这种特殊语法：<code>where(&quot;user.name = :name&quot;, &#123; name: &quot;Timber&quot; &#125;)</code>，其中:name 是参数名称，值在对象中指定：<code>&#123; name: &quot;Timber&quot; &#125;</code>。</p>\n<h2 id=\"方式-1\"><a href=\"#方式-1\" class=\"headerlink\" title=\"方式 1\"></a>方式 1</h2><p><code>.where(&quot;user.name = :name&quot;, &#123; name: &quot;Timber&quot; &#125;)</code></p>\n<h2 id=\"方式-2\"><a href=\"#方式-2\" class=\"headerlink\" title=\"方式 2\"></a>方式 2</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">.where(&quot;user.name &#x3D; :name&quot;)\n.setParameter(&quot;name&quot;, &quot;Timber&quot;)</code></pre>\n\n<p>注意：不要在查询构建器中对不同的值使用相同的参数名称。如果多次设置值将被覆盖。</p>\n<p>您还可以提供一个值数组，并通过使用特殊的扩展语法将它们转换为 SQL 语句中的值列表：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">.where(&quot;user.name IN (:...names)&quot;, &#123; names: [ &quot;Timber&quot;, &quot;Cristal&quot;, &quot;Lina&quot; ] &#125;)\n&#x2F;&#x2F; 这变成：\n\n&#x2F;&#x2F; WHERE user.name IN (&#39;Timber&#39;, &#39;Cristal&#39;, &#39;Lina&#39;)</code></pre>\n\n<h1 id=\"重难点在实体管理器\"><a href=\"#重难点在实体管理器\" class=\"headerlink\" title=\"重难点在实体管理器\"></a>重难点在实体管理器</h1><h1 id=\"有哪些实体相关的装饰器\"><a href=\"#有哪些实体相关的装饰器\" class=\"headerlink\" title=\"有哪些实体相关的装饰器\"></a>有哪些实体相关的装饰器</h1><p>在 TypeORM 中，有多种实体相关的装饰器（decorators）可以用来定义和配置实体类。以下是一些常用的实体相关的装饰器：</p>\n<ol>\n<li><p><code>@Entity()</code>：用于将一个类标记为 TypeORM 实体。必须将此装饰器应用于实体类的顶部。</p>\n</li>\n<li><p><code>@PrimaryGeneratedColumn()</code>：用于定义一个自动生成的主键列。通常与 <code>@Entity()</code> 一起使用。</p>\n</li>\n<li><p><code>@Column()</code>：用于定义一个实体属性对应的数据库列。可以指定列的类型、长度、是否可为空等选项。</p>\n</li>\n<li><p><code>@CreateDateColumn()</code>：用于定义一个在实体创建时自动设置的日期时间列。</p>\n</li>\n<li><p><code>@UpdateDateColumn()</code>：用于定义一个在实体更新时自动更新的日期时间列。</p>\n</li>\n<li><p><code>@DeleteDateColumn()</code>：用于定义一个在实体被软删除时设置的日期时间列。</p>\n</li>\n<li><p><code>@JoinColumn()</code>：用于定义实体之间的关系的连接列。通常在关系的拥有方使用。</p>\n</li>\n<li><p><code>@ManyToOne()</code>：用于定义多对一关系。指定一个实体与另一个实体的关联关系。</p>\n</li>\n<li><p><code>@OneToMany()</code>：用于定义一对多关系。指定一个实体与多个另一个实体的关联关系。</p>\n</li>\n<li><p><code>@ManyToMany()</code>：用于定义多对多关系。指定两个实体之间的多对多关联关系。</p>\n</li>\n<li><p><code>@JoinTable()</code>：用于定义多对多关系中的关联表。</p>\n</li>\n<li><p><code>@Index()</code>：用于定义数据库索引。</p>\n</li>\n</ol>\n<p>这只是一小部分常用的实体相关装饰器，TypeORM 还提供了其他装饰器和选项，用于进一步定义和配置实体类与数据库之间的映射关系。</p>\n<p>请注意，不同的装饰器具有不同的选项和用法，具体使用方式和详细文档可以参考 TypeORM 的官方文档或相关资料。</p>\n<p>希望这些信息对您有所帮助！如果您有其他问题，请随时提问。</p>\n<p><a href=\"https://typeorm.io/decorator-reference\" target=\"_blank\" >decorator-reference</a></p>\n<p><a href=\"https://github.com/typeorm/typeorm/blob/master/docs/zh_CN/decorator-reference.md\" target=\"_blank\" >中文</a></p>\n<h2 id=\"CreateDateColumn-在数据库中是什么格式\"><a href=\"#CreateDateColumn-在数据库中是什么格式\" class=\"headerlink\" title=\"@CreateDateColumn 在数据库中是什么格式\"></a>@CreateDateColumn 在数据库中是什么格式</h2><p>在数据库中，<code>@CreateDateColumn()</code> 装饰器所定义的日期时间列的格式是取决于所使用的数据库管理系统的。TypeORM 会根据数据库的特定规则和类型映射将日期时间值存储在相应的列中。</p>\n<p>以下是一些常见数据库管理系统中 <code>@CreateDateColumn()</code> 列的示例格式：</p>\n<ol>\n<li><p>MySQL：默认情况下，TypeORM 会使用 MySQL 的 <code>DATETIME</code> 类型存储创建日期时间。日期时间值的格式为 <code>YYYY-MM-DD HH:MM:SS</code>。</p>\n</li>\n<li><p>PostgreSQL：TypeORM 会使用 PostgreSQL 的 <code>TIMESTAMP WITH TIME ZONE</code> 类型存储创建日期时间。日期时间值的格式为 <code>YYYY-MM-DD HH:MM:SS.ssssss+TZ</code>。</p>\n</li>\n<li><p>SQLite：TypeORM 会使用 SQLite 的 <code>TEXT</code> 类型存储创建日期时间。日期时间值的格式为 <code>YYYY-MM-DD HH:MM:SS.sss</code>。</p>\n</li>\n<li><p>SQL Server：TypeORM 会使用 SQL Server 的 <code>DATETIME2</code> 类型存储创建日期时间。日期时间值的格式为 <code>YYYY-MM-DD HH:MM:SS.ssssss</code>。</p>\n</li>\n</ol>\n<p>请注意，数据库中存储的日期时间格式可能因数据库配置、连接选项或其他因素而有所变化。此外，TypeORM 还允许自定义日期时间列的格式和类型映射，以适应特定的需求。</p>\n<p>如果需要更具体的日期时间格式或类型，请参考 TypeORM 文档中关于特定数据库管理系统的配置和选项，或者根据实际情况进行定制。</p>\n<p>希望这个解答对您有所帮助！如果您有其他问题，请随时提问。</p>\n<h2 id=\"能定制格式吗\"><a href=\"#能定制格式吗\" class=\"headerlink\" title=\"能定制格式吗\"></a>能定制格式吗</h2><p>在 TypeORM 中，可以通过使用 <code>@CreateDateColumn()</code> 装饰器的选项来自定义日期时间列的格式。</p>\n<p><code>@CreateDateColumn()</code> 装饰器接受一个选项对象，其中可以包含 <code>type</code>、<code>precision</code>、<code>default</code>、<code>nullable</code> 等属性。其中，<code>type</code> 属性用于指定日期时间列的数据库类型。</p>\n<p>要自定义日期时间列的格式，可以使用 <code>@CreateDateColumn()</code> 的 <code>transformer</code> 属性。<code>transformer</code> 属性允许您指定一个自定义的转换器函数，用于在将值存储到数据库和从数据库读取值时进行格式转换。</p>\n<p>以下是一个示例，展示如何使用 <code>@CreateDateColumn()</code> 的 <code>transformer</code> 属性自定义日期时间列的格式：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ValueTransformer &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 自定义转换器函数\nconst dateTimeTransformer: ValueTransformer &#x3D; &#123;\n  to: (value: Date) &#x3D;&gt; value.toISOString(), &#x2F;&#x2F; 转换为 ISO 8601 格式字符串\n  from: (value: string) &#x3D;&gt; new Date(value), &#x2F;&#x2F; 转换为 Date 对象\n&#125;;\n\n@Entity()\nexport class User &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @CreateDateColumn(&#123; transformer: dateTimeTransformer &#125;)\n  createdAt: Date;\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了一个名为 <code>dateTimeTransformer</code> 的自定义转换器函数，并将其传递给 <code>@CreateDateColumn()</code> 的 <code>transformer</code> 属性。该转换器函数将日期时间值转换为 ISO 8601 格式的字符串进行存储，并在从数据库读取值时将其转换为 Date 对象。</p>\n<p>通过自定义转换器函数，您可以根据需求定义任何所需的日期时间格式或转换逻辑。</p>\n<p>希望这个解答对您有所帮助！如果您有其他问题，请随时提问。</p>\n<h2 id=\"ISO-8601-格式是怎样的\"><a href=\"#ISO-8601-格式是怎样的\" class=\"headerlink\" title=\"ISO 8601 格式是怎样的\"></a>ISO 8601 格式是怎样的</h2><p>ISO 8601 是一种国际标准，用于表示日期、时间和日期时间的格式。它定义了一套通用的日期时间表示法，以确保在不同国家、不同文化和不同计算机系统之间的一致性和互操作性。</p>\n<p>ISO 8601 格式具有以下特点：</p>\n<ol>\n<li><p>日期格式：使用年份、月份和日期表示日期。常用格式为 <code>YYYY-MM-DD</code>，例如 <code>2023-05-12</code> 表示 2023 年 5 月 12 日。</p>\n</li>\n<li><p>时间格式：使用小时、分钟和秒表示时间。常用格式为 <code>HH:MM:SS</code>，例如 <code>14:30:00</code> 表示下午 2 点 30 分。</p>\n</li>\n<li><p>日期时间格式：组合日期和时间，并使用一个可选的时区偏移。常用格式为 <code>YYYY-MM-DDTHH:MM:SS±hh:mm</code>，例如 <code>2023-05-12T14:30:00+08:00</code> 表示北京时间下的 2023 年 5 月 12 日下午 2 点 30 分。</p>\n</li>\n</ol>\n<p>ISO 8601 还支持其他格式和扩展，如毫秒、微秒、周数等。它提供了一种标准的方式来表示日期、时间和日期时间，以便于交换、存储和解析。</p>\n<p>在上述示例中，使用 ISO 8601 格式 <code>YYYY-MM-DDTHH:MM:SS</code> 来表示日期时间值。这种格式在国际化环境中广泛使用，并且被许多编程语言和数据库系统支持。</p>\n<p>希望这个解答对您有所帮助！如果您有其他问题，请随时提问。</p>\n<h2 id=\"如果要存时间戳在数据库中呢\"><a href=\"#如果要存时间戳在数据库中呢\" class=\"headerlink\" title=\"如果要存时间戳在数据库中呢\"></a>如果要存时间戳在数据库中呢</h2><p>如果您想将时间戳存储在数据库中而不是使用日期时间格式，您可以使用 <code>@CreateDateColumn()</code> 的 <code>type</code> 属性来指定数据库列的类型为时间戳类型。</p>\n<p>在 TypeORM 中，支持以下时间戳类型：</p>\n<ul>\n<li><code>&#39;timestamp&#39;</code>：存储带有时区的时间戳。</li>\n<li><code>&#39;timestamp without time zone&#39;</code>：存储不带时区的时间戳。</li>\n<li><code>&#39;bigint&#39;</code>：存储大整数类型的时间戳（以毫秒为单位）。</li>\n</ul>\n<p>以下是使用 TypeORM 存储时间戳的示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123; Entity, PrimaryGeneratedColumn, Column, CreateDateColumn &#125; from &#39;typeorm&#39;;\n\n@Entity()\nexport class User &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @CreateDateColumn(&#123; type: &#39;timestamp&#39; &#125;)\n  createdAt: Date;\n&#125;</code></pre>\n\n<p>在上述示例中，我们使用 <code>@CreateDateColumn()</code> 的 <code>type</code> 属性将 <code>createdAt</code> 列的类型指定为 <code>&#39;timestamp&#39;</code>。这将在数据库中存储带有时区的时间戳。</p>\n<p>如果您希望存储不带时区的时间戳，可以将 <code>type</code> 属性设置为 <code>&#39;timestamp without time zone&#39;</code>。如果您希望以大整数类型（以毫秒为单位）存储时间戳，可以将 <code>type</code> 属性设置为 <code>&#39;bigint&#39;</code>。</p>\n<p>通过适当选择 <code>type</code> 属性，您可以在数据库中存储时间戳而不是日期时间格式。</p>\n<p>希望这个解答对您有所帮助！如果您有其他问题，请随时提问。</p>\n<h2 id=\"CreateDateColumn-细分析\"><a href=\"#CreateDateColumn-细分析\" class=\"headerlink\" title=\"@CreateDateColumn 细分析\"></a>@CreateDateColumn 细分析</h2><p>@CreateDateColumn 在文档上只有简单实用,chatGPT 给出的使用在参考文档上没有，如果遇到其他 API，也会在参考文档上查看不到，那时，就不会用了，有万金油吗？</p>\n<p><a href=\"https://github.com/typeorm/typeorm/blob/d4607a86723eef07e62e6d7321a07f3ae5ed1f90/src/decorator/columns/CreateDateColumn.ts#LL10C1-L19C2\" target=\"_blank\" >源码</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export function CreateDateColumn(options?: ColumnOptions): PropertyDecorator &#123;\n  return function (object: Object, propertyName: string) &#123;\n    getMetadataArgsStorage().columns.push(&#123;\n      target: object.constructor,\n      propertyName: propertyName,\n      mode: &#39;createDate&#39;,\n      options: options || &#123;&#125;,\n    &#125; as ColumnMetadataArgs);\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 分析：\n\n&#x2F;&#x2F; 入参： ColumnOptions类型</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/202305121736741.webp\" />\n\n<p><a href=\"https://github.com/typeorm/typeorm/blob/d4607a86723eef07e62e6d7321a07f3ae5ed1f90/src/decorator/options/ColumnOptions.ts#LL4C1-L190C2\" target=\"_blank\" >ColumnOptions 源码</a></p>\n<p>由此，晓得的参数可以如何配置，再个细化，每个属性、方法各代表什么意思，如此，就掌握了一个注解的使用，同时，也就掌握了实体字段注解的所有注解的配置</p>\n<p>源码的注视信息，好像在哪见过</p>\n<ol>\n<li><a href=\"https://typeorm.io/decorator-reference#entity:~:text=%40Column%20accept%20several%20options%20you%20can%20use%3A\" target=\"_blank\" >见</a></li>\n<li><a href=\"https://typeorm.io/decorator-reference#entity:~:text=%40Column%20accept%20several%20options%20you%20can%20use%3A\" target=\"_blank\" >中文</a></li>\n</ol>\n<h1 id=\"TypeScript-重载\"><a href=\"#TypeScript-重载\" class=\"headerlink\" title=\"TypeScript 重载\"></a>TypeScript 重载</h1><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(): PropertyDecorator;\n\n&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(options: PrimaryGeneratedColumnNumericOptions): PropertyDecorator;\n\n&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(strategy: &#39;increment&#39;, options?: PrimaryGeneratedColumnNumericOptions): PropertyDecorator;\n\n&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(strategy: &#39;uuid&#39;, options?: PrimaryGeneratedColumnUUIDOptions): PropertyDecorator;</code></pre>\n\n<p>这段代码是一个函数的重载（Function Overload）</p>\n<p>函数重载是指在 TypeScript 中，<strong>可以定义多个具有不同参数类型或参数个数的函数签名，但相同的函数名称</strong>。</p>\n<p>在调用该函数时，<strong>TypeScript 会根据传入的参数类型或参数个数来选择合适的函数定义进行调用</strong>。</p>\n<p>在你提供的代码中，有多个函数重载定义了名为 <code>PrimaryGeneratedColumn</code> 的函数。每个函数重载都有不同的参数类型和参数个数。</p>\n<p>这种函数重载的设计可以提供更灵活的使用方式，以适应不同的调用情况。根据传入的参数，TypeScript 将会根据函数的定义来选择匹配的函数重载进行调用。这样可以在不同的情况下提供不同的选项，以便在使用装饰器时能够传递不同的配置参数。</p>\n<p>总的来说，函数重载是一种在 TypeScript 中定义同名函数但具有不同参数类型或参数个数的方式，用于提供灵活的函数调用选项。</p>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/2/functions.html#overload-signatures-and-the-implementation-signature\" target=\"_blank\" >Typescript 重载</a></p>\n<h1 id=\"附文档\"><a href=\"#附文档\" class=\"headerlink\" title=\"附文档\"></a>附文档</h1><p><a href=\"https://github.com/typeorm/typeorm/tree/d4607a86723eef07e62e6d7321a07f3ae5ed1f90/docs/zh_CN\" target=\"_blank\" >中文文档</a></p>\n","text":"背景这篇文章主要是答疑，不是参考文档，参考文档去官网查看，这里不做详细讨论 TypeORM 是什么TypeORM 是一个用于 Node.js 和 JavaScript 的对象关系映射（ORM）库。它提供了一种将数据库中的数据映射到 JavaScript 对象的方式，使得在应用程序...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"43 mins."},"categories":[{"name":"TypeORM","slug":"TypeORM","count":1,"path":"api/categories/TypeORM.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":12,"path":"api/tags/chatGPT2021.json"},{"name":"TypeORM","slug":"TypeORM","count":1,"path":"api/tags/TypeORM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TypeORM-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">TypeORM 是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83-TypeORM-%E5%92%8C-Sequelize\"><span class=\"toc-text\">比较 TypeORM 和 Sequelize</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BD%93\"><span class=\"toc-text\">实体</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E4%BD%93-%E4%B8%8E-%E5%AE%9E%E4%BD%93%E7%BB%A7%E6%89%BF-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">嵌入式实体 与 实体继承 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%A1%A8%E7%BB%A7%E6%89%BF%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E3%80%81%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%EF%BC%89%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">单表继承（数据库表结构，插入数据、查询数据）示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">查询结果</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Tree-Entities\"><span class=\"toc-text\">Tree Entities</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Tree-%E2%80%9Cclosure-table%E2%80%9D-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">@Tree(“closure-table”) 是什么，有什么用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">上述代码对应的数据库表结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E7%94%A8%E5%8E%9F%E7%94%9F-mysql-%E5%A6%82%E4%BD%95%E5%86%99%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">如果用原生 mysql 如何写查询语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#findTrees\"><span class=\"toc-text\">findTrees</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Tree-%E2%80%9Cmaterialized-path%E2%80%9D-%E3%80%90%E5%85%AC%E5%8F%B8%E7%94%A8%E7%9A%84%E8%BF%99%E7%A7%8D%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%81%9A%E7%BB%84%E7%BB%87%E6%A0%91%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8C%BA%E5%A5%BD%E7%9A%84%E3%80%91\"><span class=\"toc-text\">@Tree(“materialized-path”)【公司用的这种，这种做组织树懒加载挺好的】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">完整示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#materialized-path-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5\"><span class=\"toc-text\">materialized-path 增删改查</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83-Materialized-Path-%E4%B8%8E-Closure-table\"><span class=\"toc-text\">比较 Materialized Path 与 Closure table</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">比较</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E6%87%82\"><span class=\"toc-text\">不懂</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88Adjacency-List%EF%BC%89%E3%80%90%E5%8F%AF%E8%B7%B3%E8%BF%87%E3%80%91\"><span class=\"toc-text\">邻接表（Adjacency List）【可跳过】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#view-entities-%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BC%9A%E7%94%A8%E5%88%B0\"><span class=\"toc-text\">view-entities 做什么用，什么场景会用到</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE-%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%90%E6%96%B0%E5%8C%BB%E5%92%8C%E9%98%BF%E9%87%8C%EF%BC%8C%E7%97%85%E4%BE%8B%E8%B4%A8%E6%A3%80%E9%A1%B9%E7%9B%AE-%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE%E3%80%91\"><span class=\"toc-text\">数据库视图 的作用【新医和阿里，病例质检项目 给第三方提供数据库视图】</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#manager-%E5%92%8C-getRepository\"><span class=\"toc-text\">.manager 和.getRepository()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4\"><span class=\"toc-text\">简单来说</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE-%EF%BC%88Find-Options%EF%BC%89-%E8%AF%A6%E7%BB%86%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">查询相关的配置 （Find Options） 详细文档</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typeorm-Find-Options-%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">typeorm Find Options 简单配置有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">高级配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">高级配置示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">关联关系</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8-manager\"><span class=\"toc-text\">实体管理器 manager</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B-API\"><span class=\"toc-text\">有哪些 API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#manager-increment\"><span class=\"toc-text\">manager.increment</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#manager-increment-%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E6%9B%B4%E6%96%B0%E7%9A%84-id-%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">manager.increment 返回所有更新的 id 吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#manager-count\"><span class=\"toc-text\">manager.count</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#manager-countBy\"><span class=\"toc-text\">manager.countBy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#manager-count-vs-manager-countBy\"><span class=\"toc-text\">manager.count vs manager.countBy</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Query-Builder\"><span class=\"toc-text\">Query Builder</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#query-builder-%E5%B1%9E%E4%BA%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">query builder 属于建造者模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-QueryBuilder\"><span class=\"toc-text\">三种方式创建 QueryBuilder</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90-%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-QueryBuilder\"><span class=\"toc-text\">使用数据源 创建和使用 QueryBuilder</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#from-User-quot-user-quot\"><span class=\"toc-text\">.from(User, &quot;user&quot;)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8-%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-QueryBuilder\"><span class=\"toc-text\">使用实体管理器 创建和使用 QueryBuilder</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%BA%93-%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-QueryBuilder\"><span class=\"toc-text\">使用存储库 创建和使用 QueryBuilder</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#userRepository-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%AD%98%E5%82%A8%E5%BA%93%E5%AE%9E%E4%BE%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E5%BA%93%EF%BC%9F\"><span class=\"toc-text\">userRepository 为什么叫存储库实例，什么是存储库？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%98%E6%98%AF%E4%B8%8D%E6%87%82\"><span class=\"toc-text\">还是不懂</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%BA%93%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%EF%BC%8C%E5%B0%86%E6%9F%90%E4%B8%AA%E5%AE%9E%E4%BD%93%E7%9C%8B%E6%88%90%E4%B8%80%E4%B8%AA%E5%BA%93%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%85%B6%E5%81%9A-CRUD-%E6%93%8D%E4%BD%9C%EF%BC%9F\"><span class=\"toc-text\">存储库可以理解为，将某个实体看成一个库，可以对其做 CRUD 操作？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%86%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82%E4%B8%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%B1%82%E5%88%86%E7%A6%BB%EF%BC%8C%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%EF%BC%8C%E6%88%91%E6%B2%A1%E7%9C%8B%E5%87%BA%E6%9D%A5%E5%91%A2\"><span class=\"toc-text\">将数据访问层与业务逻辑层分离，体现在哪，我没看出来呢</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%85%B3%E7%B3%BB-%E5%85%B3%E8%81%94%E6%97%B6%E5%80%99%E8%83%BD%E5%A4%9F%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">处理关系[关联时候能够提升性能]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A6%96%E5%85%88%E4%B8%8D%E6%99%93%E5%BE%97%E4%BB%A3%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">首先不晓得代码是什么意思</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E6%98%AF-1-2-3-4-5-6-%E8%AF%A5%E5%A6%82%E4%BD%95%E4%B9%A6%E5%86%99-queryBuilder%E3%80%90%E6%B3%A8%E6%84%8F%E5%95%8A%EF%BC%8C%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%85%B3%E7%B3%BB%E6%98%AF%E7%BB%84%E5%90%88%E3%80%91\"><span class=\"toc-text\">如果是(1,2) (3,4) (5,6),该如何书写 queryBuilder【注意啊，这个代码关系是组合】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E6%83%B3-1-%E5%92%8C-2-%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB%EF%BC%8C3-%E5%92%8C-4-%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB%EF%BC%8C5-%E5%92%8C-6-%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">只想 1 和 2 建立关系，3 和 4 建立关系，5 和 6 建立关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E4%BA%86%E4%B8%89%E6%AC%A1%EF%BC%8C%E8%83%BD%E7%AE%80%E5%8C%96%E5%90%97\"><span class=\"toc-text\">调用了三次，能简化吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5%E6%89%8D%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%EF%BC%9F\"><span class=\"toc-text\">不存在的情况才进行插入？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%BD%E7%AE%80%E5%8C%96%E5%90%97-%E8%A7%81\"><span class=\"toc-text\">能简化吗 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createQueryBuilder-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">createQueryBuilder 源码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#createQueryBuilder-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">createQueryBuilder 示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#delete\"><span class=\"toc-text\">delete</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#softdelete\"><span class=\"toc-text\">softdelete</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E6%AE%B5%E6%98%AF%E5%93%AA%E4%B8%AA\"><span class=\"toc-text\">软删除对应的字段是哪个</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E8%AF%91%EF%BC%8C%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">转译，以解决安全问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E5%BC%8F-1\"><span class=\"toc-text\">方式 1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E5%BC%8F-2\"><span class=\"toc-text\">方式 2</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%87%8D%E9%9A%BE%E7%82%B9%E5%9C%A8%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8\"><span class=\"toc-text\">重难点在实体管理器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">有哪些实体相关的装饰器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CreateDateColumn-%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">@CreateDateColumn 在数据库中是什么格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%BD%E5%AE%9A%E5%88%B6%E6%A0%BC%E5%BC%8F%E5%90%97\"><span class=\"toc-text\">能定制格式吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ISO-8601-%E6%A0%BC%E5%BC%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">ISO 8601 格式是怎样的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E8%A6%81%E5%AD%98%E6%97%B6%E9%97%B4%E6%88%B3%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%91%A2\"><span class=\"toc-text\">如果要存时间戳在数据库中呢</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CreateDateColumn-%E7%BB%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">@CreateDateColumn 细分析</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TypeScript-%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">TypeScript 重载</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%99%84%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">附文档</span></a>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ClickHouse","uid":"c6848d81e0857e8e07365785ba422395","slug":"2023-05-12clickhouse","date":"2023-05-12T03:39:31.000Z","updated":"2023-05-15T13:17:33.011Z","comments":true,"path":"api/articles/2023-05-12clickhouse.json","keywords":null,"cover":[],"text":"clickhouse 是什么 ClickHouse® 是一个开源的面向列的数据库管理系统，允许实时生成分析数据报告 ClickHouse 是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)。 ClickHouse 是一个用于分析大规模数据的开源列式数据库管理系统。它专...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"大数据","slug":"大数据","count":1,"path":"api/categories/大数据.json"}],"tags":[{"name":"大数据","slug":"大数据","count":1,"path":"api/tags/大数据.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"开发/维护成本","uid":"536f5310746872e6a5c917e9332792d4","slug":"2023-05-10成本","date":"2023-05-10T09:08:49.000Z","updated":"2023-05-15T13:17:33.008Z","comments":true,"path":"api/articles/2023-05-10成本.json","keywords":null,"cover":null,"text":"知道需求开发和不晓得需求读代码维护，哪个成本更高成本更高的情况取决于具体的情况和项目要求。以下是一些考虑因素： 需求开发成本高：如果项目需求不明确或频繁变化，需要进行大量的需求澄清、迭代和变更管理，那么需求开发的成本可能更高。 不晓得需求读代码维护成本高：如果代码质量较低、文档不...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"其他","slug":"其他","count":3,"path":"api/categories/其他.json"}],"tags":[{"name":"其他","slug":"其他","count":2,"path":"api/tags/其他.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}