{"title":"axios 1.0.0-alpha.1 源码","uid":"5878c07e39be3e6af6ed1f1edce82a5a","slug":"2022-06-23axios","date":"2022-06-23T01:22:54.000Z","updated":"2022-09-16T15:01:27.534Z","comments":true,"path":"api/articles/2022-06-23axios.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220623092515.webp","content":"<h2 id=\"官网\"><a href=\"#官网\" class=\"headerlink\" title=\"官网\"></a>官网</h2><p><a href=\"https://axios-http.com\" target=\"_blank\" >官网首页</a><br><a href=\"https://axios-http.com/docs/intro\" target=\"_blank\" >官方文档介绍</a><br><a href=\"https://axios-http.com/zh/docs/example\" target=\"_blank\" >中文文档</a></p>\n<p>Promise based HTTP client for the browser and node.js<br><em>基于 promise 可以用于浏览器和 node.js 的网络请求库</em></p>\n<p>Axios is a promise-based HTTP Client for node.js and the browser. It is isomorphic (&#x3D; it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js http module, while on the client (browser) it uses XMLHttpRequests.<br><em>Axios 是一个基于 promise 网络请求库，作用于 node.js 和浏览器中。 它是 isomorphic「同构」 的(即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</em></p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><ul>\n<li>从浏览器创建 XMLHttpRequests</li>\n<li>从 node.js 创建 http 请求</li>\n<li>支持 Promise API</li>\n<li>拦截请求和响应</li>\n<li>转换请求和响应数据</li>\n<li>取消请求</li>\n<li>自动转换 JSON 数据</li>\n<li>客户端支持防御 XSRF</li>\n</ul>\n<h2 id=\"使用及-Axios-API\"><a href=\"#使用及-Axios-API\" class=\"headerlink\" title=\"使用及 Axios API\"></a>使用及 Axios API</h2><p><a href=\"https://axios-http.com/zh/docs/example\" target=\"_blank\" >get example 使用</a><br><a href=\"https://axios-http.com/zh/docs/post_example\" target=\"_blank\" >post example 使用</a><br><a href=\"https://axios-http.com/zh/docs/api_intro\" target=\"_blank\" >API</a></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>请求方式别名<br>为了方便起见，已经为所有支持的请求方法提供了别名。</p>\n<p>axios.request(config)<br>axios.get(url[, config])<br>axios.delete(url[, config])<br>axios.head(url[, config]) ?<br>axios.options(url[, config]) 预检<br>axios.post(url[, data[, config]])<br>axios.put(url[, data[, config]])<br>axios.patch(url[, data[, config]])? patch 方法用来更新局部资源<br>注意<br>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>\n<p>restful 只是标准，标准的意思是如果在大家都依此行事的话，沟通成本会很低，开发效率就高。但并非强制(也没人强制得了)，所以你说在你的程序里把方法名从 put 改成 patch 没有任何影响，那是自然，因为你的后端程序并没有按照标准对两个方法做不同处理，她的表现自然是一样的</p>\n<p>即约定，但并不是所有的人都这么干，具体项目如何实现，还需要前后端一致（打个比方：有的后端用 post 做删除，用 post 做查询，用 post 做更新，再举个例子三脚插头有大有小不知道你晓不晓得？只要对应的插孔是对应的大小也就可以运行，要不然连不上）</p>\n</p>\n</div>\n<p>…</p>\n<p><strong>axios.options(url[, config])</strong></p>\n<p><a href=\"https://blog.csdn.net/csdnyp/article/details/122651869\">axios 中为什么会有 OPTIONS 请求</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>浏览器限制跨域<br>浏览器限制跨域请求一般有两种方式：<br>1、限制发起跨域请求<br>2、跨域请求可以正常发起，但是返回的结果会被浏览器拦截</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一般情况下，浏览器会以第二种方式限制跨域请求。这种存在一种情况，_请求已经到达服务器并响应了某些操作，改变了数据库数据，但是返回的结果会被浏览器拦截，用户就不能取到相应的结果进行后续的操作_。<strong>所以为了避免这种情况，浏览器就会通过 OPTIONS 方法对请求进行预检，通过询问服务器是否允许这次请求，允许之后，服务器才会响应真实请求，否则就阻止真实请求</strong>。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>项目中需要 OPTIONS 预检吗？<br>用户登陆之后，我们会获取 token 值，在每一次发起请求时，请求头都会携带这个 token 值，所以会触发预检请求。因为目前除了登录，其他请求接口请求头都携带了 token，而且我们的 Content-Type 绝大多数是 application&#x2F;json，所以预检总会存在。如果不想发起 OPTIONS 预检请求，建议后端在请求的返回头部添加：Access-Control-Max-Age:(number)。</p></blockquote>\n<p><a href=\"https://blog.csdn.net/u011200562/article/details/110431341\" target=\"_blank\" >Access-Control-Max-Age 是什么</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>浏览器的同源策略，就是出于安全考虑，浏览器会限制从脚本发起的跨域 HTTP 请求（比如异步请求 GET, POST, PUT, DELETE, OPTIONS 等等），所以浏览器会向所请求的服务器发起两次请求，第一次是浏览器使用 OPTIONS 方法发起一个预检请求，第二次才是真正的异步请求，第一次的预检请求获知服务器是否允许该跨域请求：如果允许，才发起第二次真实的请求；如果不允许，则拦截第二次请求。</p>\n<p>Access-Control-Max-Age 用来指定本次预检请求的有效期，单位为秒，，在此期间不用发出另一条预检请求。</p>\n<p>例如：</p>\n<p>resp.addHeader(“Access-Control-Max-Age”, “0”)，表示每次异步请求都发起预检请求，也就是说，发送两次请求。</p>\n<p>resp.addHeader(“Access-Control-Max-Age”, “1800”)，表示隔 30 分钟才发起预检请求。也就是说，发送两次请求</p></blockquote>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li><p><a href=\"https://axios-http.com/zh/docs/config_defaults#:~:text=%3D%20AUTH_TOKEN%3B-,%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7,-%E9%85%8D%E7%BD%AE%E5%B0%86%E4%BC%9A%E6%8C%89\" target=\"_blank\" >配置的优先级</a><br>配置将会按优先级进行合并。它的顺序是：在 <code>lib/defaults.js</code> 中找到的库默认值，然后是实例的 <code>defaults</code> 属性，最后是<code>请求的 config 参数</code>。后面的优先级要高于前面的。下面有一个例子。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 使用库提供的默认配置创建实例\n&#x2F;&#x2F; 此时超时配置的默认值是 &#96;0&#96;\nconst instance &#x3D; axios.create();\n&#x2F;&#x2F; 重写库的超时默认值\n&#x2F;&#x2F; 现在，所有使用此实例的请求都将等待 2.5 秒，然后才会超时\ninstance.defaults.timeout &#x3D; 2500;\n\n&#x2F;&#x2F; 重写此请求的超时时间，因为该请求需要很长时间\ninstance.get(&quot;&#x2F;longRequest&quot;, &#123;\n  timeout: 5000,\n&#125;);</code></pre>\n</li>\n<li><p>版本发布没有遵守<code>语义化版本</code></p>\n</li>\n</ol>\n<p>在 redux 章节曾聊过包的版本, 必须有, 要符合<a href=\"https://docs.npmjs.com/about-semantic-versioning\">semantic versioning guidelines</a>, 参考 <a href=\"https://semver.org/lang/zh-CN/\">语义化版本控制规范</a>, 建议仔细通读<br><img src=\"http://t-blog-images.aijs.top/img/20220525140247.webp\" width=600 style=\"object-fit: content\"/></p>\n<p></p>\n\n<h2 id=\"假设\"><a href=\"#假设\" class=\"headerlink\" title=\"假设\"></a>假设</h2><p>已经通过官方文档对 axios 的使用和 api 已经有了初步的了解</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><ul>\n<li>了解特性的实现过程</li>\n<li>了解 api 的实现过程</li>\n<li>看看代码靠不靠谱，有没有“彩蛋”(蛙去～，我早上突然冒的想法，竟然在下午真的遇到了，直觉～)</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.\n├── CHANGELOG.md\n├── CODE_OF_CONDUCT.md\n├── COLLABORATOR_GUIDE.md\n├── CONTRIBUTING.md\n├── ECOSYSTEM.md\n├── LICENSE\n├── README.md\n├── SECURITY.md\n├── UPGRADE_GUIDE.md\n├── bin\n├── bower.json # 用于bower install\n├── dist\n├── examples\n├── gulpfile.js # gulp任务\n├── index.d.ts\n├── index.js\n├── karma.conf.cjs\n├── lib\n├── package-lock.json\n├── package.json # &quot;build&quot;: &quot;gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m&quot;,\n├── rollup.config.js # rollup 打包配置\n├── sandbox # 一个前后端测试demo\n├── test\n├── tsconfig.json\n├── tslint.json\n└── webpack.config.js # webpack配置，没有使用的样子\n\n6 directories, 20 files\n</code></pre>\n\n<h2 id=\"gulpfile-js\"><a href=\"#gulpfile-js\" class=\"headerlink\" title=\"gulpfile.js\"></a>gulpfile.js</h2><p>gulpfile 现在项目很少见，上次见是在 2017 年的时候了，一开始，我看到有 根目录<code>bower.json</code> <code>gulpfile.js</code> <code>rollup.config.js</code> <code>webpack.config.js</code>,有点懵逼～</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220623135204.webp\"/>\n\n<h2 id=\"bower-json\"><a href=\"#bower-json\" class=\"headerlink\" title=\"bower.json\"></a>bower.json</h2><p><strong>了解下，有这么个东西，以后估计也用不到</strong></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1710656712337561707&wfr=spider&for=pc\" target=\"_blank\" >bower 介绍见</a><br><a href=\"https://github.com/bower/bower\" target=\"_blank\" >github 仓库</a></p>\n<p>Bower 是一个客户端的软件包管理器，它可用于搜索、安装和卸载如 JavaScript、HTML、CSS<br>之类的网络资源，Bower 是 Web 开发中的一个前端文件包管理器，类似于 Node 模块的<br>npm 包管理器，bower 依赖于 Git、Node 和 npm。</p>\n<h2 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h2><p>看完上述几个文件有点懵，工具像是重复的样子</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;npm run test:eslint &amp;&amp; npm run test:mocha &amp;&amp; npm run test:karma &amp;&amp; npm run test:dtslint&quot;,\n  &quot;test:eslint&quot;: &quot;node bin&#x2F;ssl_hotfix.js eslint lib&#x2F;**&#x2F;*.js&quot;,\n  &quot;test:dtslint&quot;: &quot;node bin&#x2F;ssl_hotfix.js dtslint&quot;,\n  &quot;test:mocha&quot;: &quot;node bin&#x2F;ssl_hotfix.js mocha test&#x2F;unit&#x2F;**&#x2F;*.js --timeout 30000 --exit&quot;,\n  &quot;test:karma&quot;: &quot;node bin&#x2F;ssl_hotfix.js cross-env LISTEN_ADDR&#x3D;:: karma start karma.conf.cjs --single-run&quot;,\n  &quot;test:karma:server&quot;: &quot;node bin&#x2F;ssl_hotfix.js cross-env karma start karma.conf.cjs&quot;,\n  &quot;start&quot;: &quot;node .&#x2F;sandbox&#x2F;server.js&quot;,\n  &quot;preversion&quot;: &quot;gulp version &amp;&amp; npm test&quot;,\n  &quot;version&quot;: &quot;npm run build &amp;&amp; git add dist &amp;&amp; git add package.json&quot;,\n  &quot;prepublishOnly&quot;: &quot;npm test&quot;,\n  &quot;postpublish&quot;: &quot;git push &amp;&amp; git push --tags &quot;,\n  &quot;build&quot;: &quot;gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m&quot;, &#x2F;&#x2F; 打包只用到了gulp 和 rollup，没有用到webpack,webpack.config.js是多余的\n  &quot;examples&quot;: &quot;node .&#x2F;examples&#x2F;server.js&quot;,\n  &quot;coveralls&quot;: &quot;cat coverage&#x2F;lcov.info | .&#x2F;node_modules&#x2F;coveralls&#x2F;bin&#x2F;coveralls.js&quot;,\n  &quot;fix&quot;: &quot;eslint --fix lib&#x2F;**&#x2F;*.js&quot;\n&#125;,</code></pre>\n\n<h2 id=\"rollup-config-js\"><a href=\"#rollup-config-js\" class=\"headerlink\" title=\"rollup.config.js\"></a>rollup.config.js</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import resolve from &quot;@rollup&#x2F;plugin-node-resolve&quot;;\nimport commonjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\nimport &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;\nimport json from &quot;@rollup&#x2F;plugin-json&quot;;\nimport &#123; babel &#125; from &quot;@rollup&#x2F;plugin-babel&quot;;\nimport autoExternal from &quot;rollup-plugin-auto-external&quot;;\n\nconst lib &#x3D; require(&quot;.&#x2F;package.json&quot;);\nconst outputFileName &#x3D; &quot;axios&quot;;\nconst name &#x3D; &quot;axios&quot;;\nconst input &#x3D; &quot;.&#x2F;lib&#x2F;axios.js&quot;; &#x2F;&#x2F; 源码入口\n&#x2F;&#x2F; minifiedVersion参数最小化，默认true，下面三处调用都没有传，这个文件与webpack.config.js无关\nconst buildConfig &#x3D; (&#123;\n  es5,\n  browser &#x3D; true,\n  minifiedVersion &#x3D; true,\n  ...config\n&#125;) &#x3D;&gt; &#123;\n  const build &#x3D; (&#123; minified &#125;) &#x3D;&gt; (&#123;\n    input,\n    ...config,\n    output: &#123;\n      ...config.output, &#x2F;&#x2F; 里面有banner信息\n      file: &#96;$&#123;config.output.file&#125;.$&#123;minified ? &quot;min.js&quot; : &quot;js&quot;&#125;&#96;,\n    &#125;,\n    plugins: [\n      json(),\n      resolve(&#123; browser &#125;),\n      commonjs(),\n      minified &amp;&amp; terser(),\n      ...(es5\n        ? [\n            babel(&#123;\n              babelHelpers: &quot;bundled&quot;,\n              presets: [&quot;@babel&#x2F;preset-env&quot;],\n            &#125;),\n          ]\n        : []),\n      ...(config.plugins || []),\n    ],\n  &#125;);\n\n  const configs &#x3D; [build(&#123; minified: false &#125;)];\n\n  if (minifiedVersion) &#123;\n    build(&#123; minified: true &#125;);\n  &#125;\n\n  return configs;\n&#125;;\n\nexport default async () &#x3D;&gt; &#123;\n  const year &#x3D; new Date().getFullYear();\n  const banner &#x3D; &#96;&#x2F;&#x2F; Axios v$&#123;lib.version&#125; Copyright (c) $&#123;year&#125; $&#123;lib.author&#125; and contributors&#96;;\n\n  return [\n    ...buildConfig(&#123;\n      es5: true,\n      output: &#123;\n        file: &#96;dist&#x2F;$&#123;outputFileName&#125;&#96;,\n        name,\n        format: &quot;umd&quot;, &#x2F;&#x2F; umd格式\n        exports: &quot;default&quot;,\n        banner,\n      &#125;,\n    &#125;),\n\n    ...buildConfig(&#123;\n      output: &#123;\n        file: &#96;dist&#x2F;esm&#x2F;$&#123;outputFileName&#125;&#96;,\n        format: &quot;esm&quot;, &#x2F;&#x2F; esm格式\n        preferConst: true,\n        exports: &quot;named&quot;,\n        banner,\n      &#125;,\n    &#125;),\n    &#x2F;&#x2F; Node.js commonjs build\n    &#123;\n      input,\n      output: &#123;\n        file: &#96;dist&#x2F;node&#x2F;$&#123;name&#125;.cjs&#96;,\n        format: &quot;cjs&quot;, &#x2F;&#x2F; commonjs格式\n        preferConst: true,\n        exports: &quot;default&quot;,\n        banner,\n      &#125;,\n      plugins: [autoExternal(), resolve(), commonjs()],\n    &#125;,\n  ];\n&#125;;</code></pre>\n\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn build\nyarn run v1.4.0\n$ gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m\n[14:19:33] Using gulpfile ~&#x2F;Desktop&#x2F;axios&#x2F;gulpfile.js\n[14:19:33] Starting &#39;clear&#39;...\n[14:19:33] Finished &#39;clear&#39; after 5.74 ms\n[!] Error: Cannot find module &#39;@babel&#x2F;core&#39;\nRequire stack:\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;@rollup&#x2F;plugin-babel&#x2F;dist&#x2F;index.js\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;rollup.config.js\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;rollup&#x2F;dist&#x2F;shared&#x2F;loadConfigFile.js\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;rollup&#x2F;dist&#x2F;bin&#x2F;rollup\nError: Cannot find module &#39;@babel&#x2F;core&#39;\n\n解决：\n\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn add @babel&#x2F;core -D\nyarn add v1.4.0\n[1&#x2F;4] 🔍  Resolving packages...\n[2&#x2F;4] 🚚  Fetching packages...\nwarning Pattern [&quot;@definitelytyped&#x2F;typescript-versions@latest&quot;] is trying to unpack in the same destination &quot;&#x2F;Users&#x2F;haotian&#x2F;Library&#x2F;Caches&#x2F;Yarn&#x2F;v1&#x2F;npm-@definitelytyped&#x2F;typescript-versions-0.0.118-de13fb755c5181443860c3c74b6730f47f6541fc&quot; as pattern [&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;,&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;,&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;]. This could result in non-deterministic behavior, skipping.\n[3&#x2F;4] 🔗  Linking dependencies...\nwarning &quot; &gt; @rollup&#x2F;plugin-babel@5.3.1&quot; has unmet peer dependency &quot;@types&#x2F;babel__core@^7.1.9&quot;.\nwarning &quot; &gt; istanbul-instrumenter-loader@3.0.1&quot; has unmet peer dependency &quot;webpack@^2.0.0 || ^3.0.0 || ^4.0.0&quot;.\nwarning &quot;karma &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.\nwarning &quot;karma &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.\nwarning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; node-fetch@2.6.7&quot; has unmet peer dependency &quot;encoding@^0.1.0&quot;.\nwarning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; ws@7.5.8&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.\nwarning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; ws@7.5.8&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.\nwarning &quot; &gt; terser-webpack-plugin@4.2.3&quot; has unmet peer dependency &quot;webpack@^4.0.0 || ^5.0.0&quot;.\n[4&#x2F;4] 📃  Building fresh packages...\nsuccess Saved lockfile.\nsuccess Saved 5 new dependencies.\n├─ @ampproject&#x2F;remapping@2.2.0\n├─ @babel&#x2F;core@7.18.5\n├─ @babel&#x2F;helpers@7.18.2\n├─ gensync@1.0.0-beta.2\n└─ json5@2.2.1\n✨  Done in 37.80s.\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn build\nyarn run v1.4.0\n$ gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m\n[14:20:32] Using gulpfile ~&#x2F;Desktop&#x2F;axios&#x2F;gulpfile.js\n[14:20:32] Starting &#39;clear&#39;...\n[14:20:32] Finished &#39;clear&#39; after 48 ms\n\n.&#x2F;lib&#x2F;axios.js → dist&#x2F;axios.js...\ncreated dist&#x2F;axios.js in 3.5s\n\n.&#x2F;lib&#x2F;axios.js → dist&#x2F;esm&#x2F;axios.js...\ncreated dist&#x2F;esm&#x2F;axios.js in 711ms\n\n.&#x2F;lib&#x2F;axios.js → dist&#x2F;node&#x2F;axios.cjs...\ncreated dist&#x2F;node&#x2F;axios.cjs in 1.1s\n✨  Done in 9.39s.\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $</code></pre>\n\n</p>\n</div>\n<h2 id=\"打包产物\"><a href=\"#打包产物\" class=\"headerlink\" title=\"打包产物\"></a>打包产物</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.\n├── axios.js\n├── axios.js.map\n├── esm\n│   ├── axios.js\n│   └── axios.js.map\n└── node\n    ├── axios.cjs\n    └── axios.cjs.map\n\n2 directories, 6 files</code></pre>\n\n<p>哎？咋滴回事，我们在<code>rollup.config.js</code>见到<code>minifiedVersion</code>默认是<code>true</code>,传给 <code>minified</code>咋的没见<code>min.js</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const configs &#x3D; [build(&#123; minified: false &#125;)];\n\nif (minifiedVersion) &#123;\n  build(&#123; minified: true &#125;); &#x2F;&#x2F; 这么些应该是为了开发调试，在sandbox中 &lt;script src&#x3D;&quot;&#x2F;axios.js&quot;&gt;&lt;&#x2F;script&gt;\n&#125;\n\nreturn configs;\n&#x2F;&#x2F; 这里暴露的是configs， build(&#123;minified: true&#125;)完全没搞事情，\n&#x2F;&#x2F; 这代码应该是用 build(&#123;minified: true&#125;) 替换   build(&#123;minified: false&#125;) 才对</code></pre>\n\n<p>修改下，然后运行<code>yarn build</code></p>\n<img src=\"http://t-blog-images.aijs.top/img/20220623143251.webp\" />\n\n<h2 id=\"axios-js\"><a href=\"#axios-js\" class=\"headerlink\" title=\"axios.js\"></a>axios.js</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;use strict&quot;;\n\nimport utils from &quot;.&#x2F;utils.js&quot;;\nimport bind from &quot;.&#x2F;helpers&#x2F;bind.js&quot;;\nimport Axios from &quot;.&#x2F;core&#x2F;Axios.js&quot;;\nimport mergeConfig from &quot;.&#x2F;core&#x2F;mergeConfig.js&quot;;\nimport defaults from &quot;.&#x2F;defaults&#x2F;index.js&quot;;\nimport formDataToJSON from &quot;.&#x2F;helpers&#x2F;formDataToJSON.js&quot;;\nimport CanceledError from &quot;.&#x2F;cancel&#x2F;CanceledError.js&quot;;\nimport CancelToken from &quot;.&#x2F;cancel&#x2F;CancelToken.js&quot;;\nimport isCancel from &quot;.&#x2F;cancel&#x2F;isCancel.js&quot;;\nimport &#123; VERSION &#125; from &quot;.&#x2F;env&#x2F;data.js&quot;;\nimport toFormData from &quot;.&#x2F;helpers&#x2F;toFormData.js&quot;;\nimport AxiosError from &quot;..&#x2F;lib&#x2F;core&#x2F;AxiosError.js&quot;;\nimport spread from &quot;.&#x2F;helpers&#x2F;spread.js&quot;;\nimport isAxiosError from &quot;.&#x2F;helpers&#x2F;isAxiosError.js&quot;;\n\n&#x2F;**\n * Create an instance of Axios\n *\n * @param &#123;Object&#125; defaultConfig The default config for the instance\n *\n * @returns &#123;Axios&#125; A new instance of Axios\n *&#x2F;\nfunction createInstance(defaultConfig) &#123;\n  const context &#x3D; new Axios(defaultConfig);\n  const instance &#x3D; bind(Axios.prototype.request, context);\n\n  &#x2F;&#x2F; Copy axios.prototype to instance\n  &#x2F;&#x2F; 拷贝原型到实例\n  utils.extend(instance, Axios.prototype, context, &#123; allOwnKeys: true &#125;);\n\n  &#x2F;&#x2F; Copy context to instance\n  &#x2F;&#x2F; 拷贝上下文到实例\n  utils.extend(instance, context, &#123; allOwnKeys: true &#125;);\n\n  &#x2F;&#x2F; Factory for creating new instances\n  &#x2F;&#x2F; 用于创建新实例的工厂\n  instance.create &#x3D; function create(instanceConfig) &#123;\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  &#125;;\n\n  return instance;\n&#125;\n\n&#x2F;&#x2F; Create the default instance to be exported\n&#x2F;&#x2F; 使用默认配置创建实例\nconst axios &#x3D; createInstance(defaults);\n\n&#x2F;&#x2F; Expose Axios class to allow class inheritance\n&#x2F;&#x2F; 暴露Axios类，允许类被继承\naxios.Axios &#x3D; Axios;\n\n&#x2F;&#x2F; Expose Cancel &amp; CancelToken\naxios.CanceledError &#x3D; CanceledError;\naxios.CancelToken &#x3D; CancelToken;\naxios.isCancel &#x3D; isCancel;\naxios.VERSION &#x3D; VERSION; &#x2F;&#x2F; gulp的env任务会将package.json的版本信息读取并写入 .&#x2F;lib&#x2F;env&#x2F;data.js，见下面代码：\n&#x2F;&#x2F; const env &#x3D; gulp.task(&#39;env&#39;, async function () &#123;\n&#x2F;&#x2F;   var npm &#x3D; JSON.parse(await fs.readFile(&#39;package.json&#39;));\n\n&#x2F;&#x2F;   await fs.writeFile(&#39;.&#x2F;lib&#x2F;env&#x2F;data.js&#39;, Object.entries(&#123;\n&#x2F;&#x2F;     VERSION: npm.version\n&#x2F;&#x2F;   &#125;).map(([key, value]) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     return &#96;export const $&#123;key&#125; &#x3D; $&#123;JSON.stringify(value)&#125;;&#96;\n&#x2F;&#x2F;   &#125;).join(&#39;\\n&#39;));\n&#x2F;&#x2F; &#125;);\naxios.toFormData &#x3D; toFormData;\n\n&#x2F;&#x2F; Expose AxiosError class\n&#x2F;&#x2F; 暴露AxuosError错误类\naxios.AxiosError &#x3D; AxiosError;\n\n&#x2F;&#x2F; alias for CanceledError for backward compatibility\n&#x2F;&#x2F; CanceledError的别名用于向后兼容\naxios.Cancel &#x3D; axios.CanceledError;\n\n&#x2F;&#x2F; Expose all&#x2F;spread\n&#x2F;&#x2F; 暴露并发\naxios.all &#x3D; function all(promises) &#123;\n  return Promise.all(promises);\n&#125;;\n&#x2F;&#x2F; 暴露spread\naxios.spread &#x3D; spread; &#x2F;&#x2F; 使用尾部调用柯里化，执行的结果还是一个函数\n\n&#x2F;&#x2F; Expose isAxiosError\n&#x2F;&#x2F; 暴露判断AxiosError的方法\naxios.isAxiosError &#x3D; isAxiosError;\n\naxios.formToJSON &#x3D; (thing) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 调用工具，将thing进行json化\n  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n&#125;;\n\nexport default axios;</code></pre>\n\n<p>其他细节不看</p>\n<h2 id=\"运行-sandbox\"><a href=\"#运行-sandbox\" class=\"headerlink\" title=\"运行 sandbox\"></a>运行 sandbox</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yarn start</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn start\nyarn run v1.4.0\n$ node .&#x2F;sandbox&#x2F;server.js\nListening on localhost:3009...\n[Thu Jun 23 2022 16:16:31 GMT+0800 (中国标准时间)] GET &#x2F;\nfile:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:14\n  fs.createReadStream(path.join(__dirname, file)).pipe(res);\n                                ^\n\nReferenceError: __dirname is not defined\n    at pipeFileToResponse (file:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:14:33)\n    at Server.&lt;anonymous&gt; (file:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:30:5)\n    at Server.emit (node:events:390:28)\n    at parserOnIncoming (node:_http_server:951:12)\n    at HTTPParser.parserOnHeadersComplete (node:_http_common:128:17)\nerror An unexpected error occurred: &quot;Command failed.\\nExit code: 1\\nCommand: sh\\nArguments: -c node .&#x2F;sandbox&#x2F;server.js\\nDirectory: &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios\\nOutput:\\n&quot;.\ninfo If you think this is a bug, please open a bug report with the information provided in &quot;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;yarn-error.log&quot;.\ninfo Visit https:&#x2F;&#x2F;yarnpkg.com&#x2F;en&#x2F;docs&#x2F;cli&#x2F;run for documentation about this command.\n</code></pre>\n\n<p>修改</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const __filename &#x3D; url.fileURLToPath(import.meta.url); &#x2F;&#x2F; 增加这行 @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;import.meta\nconst __dirname &#x3D; path.dirname(__filename); &#x2F;&#x2F; 增加这行\n\nfunction pipeFileToResponse(res, file, type) &#123;\n  if (type) &#123;\n    res.writeHead(200, &#123;\n      &quot;Content-Type&quot;: type,\n    &#125;);\n  &#125;\n\n  fs.createReadStream(path.join(__dirname, file)).pipe(res);\n&#125;</code></pre>\n\n<img src=\"http://t-blog-images.aijs.top/img/20220623162402.webp\" />\n\n<h2 id=\"core-目录\"><a href=\"#core-目录\" class=\"headerlink\" title=\"core 目录\"></a>core 目录</h2><h2 id=\"axios-执行流程\"><a href=\"#axios-执行流程\" class=\"headerlink\" title=\"axios 执行流程\"></a>axios 执行流程</h2><p>执行流程</p>\n<p>先看看整体执行流程，有大体的概念，后面会细说整体流程有以下几点：</p>\n<ol>\n<li>axios.create 创建单独实例，或直接使用 axios 实例(axios&#x2F;axios.get…)</li>\n<li>request 方法是入口，axios&#x2F;axios.get 等调用都会走进 request 进行处理</li>\n<li>请求拦截器</li>\n<li>请求数据转换器，对传入的参数 data 和 header 做数据处理，比如 JSON.stringify(data)</li>\n<li>适配器，判断是浏览器端还是 node 端，执行不同的方法</li>\n<li>响应数据转换器，对服务端的数据进行处理，比如 JSON.parse(data)</li>\n<li>响应拦截器，对服务端数据做处理，比如 token 失效退出登陆，报错 dialog 提示</li>\n<li>返回数据给开发者</li>\n</ol>\n<img src=\"http://t-blog-images.aijs.top/img/20220623165311.webp\"/>\n\n<h2 id=\"入口文件\"><a href=\"#入口文件\" class=\"headerlink\" title=\"入口文件\"></a>入口文件</h2><p><code>file:lib/axios.js</code></p>\n<p>从下面这段代码可以得出，导出的 axios 就是实例化后的对象，还在其上挂载 create 方法，以供创建独立实例，从而达到实例之间互不影响，互相隔离。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">...\n&#x2F;&#x2F; 创建实例过程的方法\nfunctioncreateInstance(defaultConfig) &#123;return instance;&#125;&#x2F;&#x2F; 实例化\nvar axios &#x3D; createInstance(defaults);&#x2F;&#x2F; 创建独立的实例，隔离作用域\naxios.create &#x3D; functioncreate(instanceConfig) &#123;return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;...\n&#x2F;&#x2F; 导出实例\nmodule.exports &#x3D; axios; &#x2F;&#x2F; 可能大家对 createInstance 方法感到好奇，下面一探究竟。\n\nfunctioncreateInstance(defaultConfig) &#123;\n  &#x2F;&#x2F; 实例化，创建一个上下文\nvar context &#x3D; new Axios(defaultConfig);\n&#x2F;&#x2F; 平时调用的 get&#x2F;post 等等请求，底层都是调用 request 方法\n&#x2F;&#x2F; 将 request 方法的 this 指向 context(上下文)，形成新的实例\nvar instance &#x3D; bind(Axios.prototype.request, context);\n&#x2F;&#x2F; Axios.prototype 上的方法 (get&#x2F;post...)挂载到新的实例 instance 上，\n&#x2F;&#x2F; 并且将原型方法中 this 指向\ncontext utils.extend(instance, Axios.prototype, context);\n&#x2F;&#x2F; Axios 属性值挂载到新的实例 instance 上\n&#x2F;&#x2F; 开发中才能使用 axios.default&#x2F;interceptors\nutils.extend(instance, context);return instance;&#125;\n&#x2F;&#x2F; 从上面代码可以看得出，Axios 不是简单的创建实例 context，而且进行一系列的上下文绑定和属性方法挂载，从而去支持 axios()，也支持 axios.get() 等等用法；</code></pre>\n\n<p>createInstance 函数是一个核心入口，我们在把上面流程梳理一下：</p>\n<ol>\n<li>通过构造函数 Axios 创建实例 context，作为下面 request 方法的上下文（this 指向）</li>\n<li>将 Axios.prototype.request 方法作为实例使用，并把 this 指向 context，形成新的实例 instance</li>\n<li>将构造函数 Axios.prototype 上的方法挂载到新的实例 instance 上，然后将原型各个方法中的 this 指向 context，开发中才能使用 axios.get&#x2F;post… 等等</li>\n<li>将构造函数 Axios 的实例属性挂载到新的实例 instance 上，我们开发中才能使用下面属性 axios.default.baseUrl &#x3D; ‘https:&#x2F;&#x2F;…’axios.interceptors.request.use(resolve,reject)<br>大家可能对上面第 2 点 request 方法感到好奇，createInstance 方法明明可以写一行代码 return new Axios() 即可，为什么大费周章使用 request 方法绑定新实例，其实就只是为了支持 axios() 写法，开发者可以写少几行代码。。。</li>\n</ol>\n<h2 id=\"默认配置\"><a href=\"#默认配置\" class=\"headerlink\" title=\"默认配置\"></a>默认配置</h2><p><code>file:lib/defaults.js</code></p>\n<p>从 createInstance 方法调用发现有个默认配置，主要是内置的属性和方法，可对其进行覆盖</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var defaults &#x3D; &#123;\n  ...\n  &#x2F;&#x2F; 请求超时时间，默认不超时\n  timeout: 0,\n   &#x2F;&#x2F; 请求数据转换器\n  transformRequest: [functiontransformRequest(data, headers) &#123;...&#125;],\n  &#x2F;&#x2F; 响应数据转换器\n  transformResponse: [functiontransformResponse(data) &#123;...&#125;], ...&#125;;\n  ...</code></pre>\n\n<p>主要有两点：</p>\n<ol>\n<li>配置：外部传入，可覆盖内部默认配置</li>\n<li>拦截器：实例后，开发者可通过 use 方法注册成功和失败的钩子函数，比如</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">axios.interceptors.request.use((config)&#x3D;&gt;config,(error)&#x3D;&gt;error);\nfunctionAxios(instanceConfig) &#123;\n  &#x2F;&#x2F; 配置\n  this.defaults &#x3D; instanceConfig;\n  &#x2F;&#x2F; 拦截器实例\n  this.interceptors &#x3D; &#123;request: new InterceptorManager(),response: new InterceptorManager() &#125;;&#125;</code></pre>\n\n<p>在看看原型方法 request 做了什么</p>\n<p>支持多类型传参<br>配置优先级定义<br>通过 promise 链式调用，依次顺序执行</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 伪代码\nAxios.prototype.request &#x3D; functionrequest(config) &#123;\n  &#x2F;&#x2F; 为了支持\n  request(url, &#123;...&#125;), request(&#123;url, ...&#125;)if (typeof config &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123; config &#x3D; arguments[1] || &#123;&#125;; config.url &#x3D; arguments[0]; &#125; else &#123; config &#x3D; config || &#123;&#125;; &#125;\n  &#x2F;&#x2F; 配置优先级： 调用方法的配置 &gt; 实例化 axios 的配置 &gt; 默认配置\n  &#x2F;&#x2F; 举个例子，类似：\n  axios.get(url, &#123;&#125;) &gt; axios.create(url, &#123;&#125;) &gt; 内部默认设置 config &#x3D; mergeConfig(this.defaults, config);\n  &#x2F;&#x2F; 拦截器（请求和响应）\n  var requestInterceptorChain &#x3D; [&#123;fulfilled: interceptor.request.fulfilled,rejected: interceptor.request.rejected &#125;];\n  var responseInterceptorChain &#x3D; [&#123;fulfilled: interceptor.response.fulfilled,rejected: interceptor.response.rejected &#125;];\n  var promise;&#x2F;&#x2F; 形成一个 promise 链条的数组\n  var chain &#x3D; [].concat(requestInterceptorChain, chain, responseInterceptorChain);\n  &#x2F;&#x2F; 传入配置\n  promise &#x3D; Promise.resolve(config);\n  &#x2F;&#x2F; 形成 promise 链条调用\n   while (chain.length) &#123; promise &#x3D; promise.then(chain.shift(), chain.shift()); &#125; ... return promise;&#125;;</code></pre>\n\n<p>通过对数组的遍历，形成一条异步的 promise 调用链，是 axios 对 promise 的巧妙运用，用一张图表示</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220623165416.webp\" />\n\n<h2 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h2><p><code>file:lib/core/InterceptorManager.js</code></p>\n<p>上面说到的 promise 调用链，里面涉及到拦截器，拦截器比较简单，挂载一个属性和三个原型方法</p>\n<ul>\n<li>handler: 存放 use 注册的回调函数</li>\n<li>use: 注册成功和失败的回调函数</li>\n<li>eject: 删除注册过的函数</li>\n<li>forEach: 遍历回调函数，一般内部使用多，比如：promise 调用链那个方法里，循环遍历回调函数，存放到 promise 调用链的数组中</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class InterceptorManager &#123;\n  constructor() &#123;\n    this.handlers &#x3D; [];\n  &#125;\n\n  &#x2F;**\n   * Add a new interceptor to the stack\n   * &#x2F;&#x2F; 注册成功和失败的回调函数\n   * @param &#123;Function&#125; fulfilled The function to handle &#96;then&#96; for a &#96;Promise&#96;\n   * @param &#123;Function&#125; rejected The function to handle &#96;reject&#96; for a &#96;Promise&#96;\n   *\n   * @return &#123;Number&#125; An ID used to remove interceptor later\n   *&#x2F;\n  use(fulfilled, rejected, options) &#123;\n    this.handlers.push(&#123;\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null,\n    &#125;);\n    return this.handlers.length - 1;\n  &#125;\n\n  &#x2F;**\n   * Remove an interceptor from the stack\n   * &#x2F;&#x2F; 删除注册过的函数\n   * @param &#123;Number&#125; id The ID that was returned by &#96;use&#96;\n   *\n   * @returns &#123;Boolean&#125; &#96;true&#96; if the interceptor was removed, &#96;false&#96; otherwise\n   *&#x2F;\n  eject(id) &#123;\n    if (this.handlers[id]) &#123;\n      this.handlers[id] &#x3D; null;\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * Clear all interceptors from the stack\n   * 调用栈清空所有拦截器\n   * @returns &#123;void&#125;\n   *&#x2F;\n  clear() &#123;\n    if (this.handlers) &#123;\n      this.handlers &#x3D; [];\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become &#96;null&#96; calling &#96;eject&#96;.\n   * &#x2F;&#x2F; 遍历回调函数，一般内部使用多\n   * @param &#123;Function&#125; fn The function to call for each interceptor\n   *\n   * @returns &#123;void&#125;\n   *&#x2F;\n  forEach(fn) &#123;\n    utils.forEach(this.handlers, function forEachHandler(h) &#123;\n      if (h !&#x3D;&#x3D; null) &#123;\n        fn(h);\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n\nexport default InterceptorManager;</code></pre>\n\n<h2 id=\"dispatchRequest\"><a href=\"#dispatchRequest\" class=\"headerlink\" title=\"dispatchRequest\"></a>dispatchRequest</h2><p><code>file: lib/core/dispatchRequest.js</code></p>\n<p>上面说到的 promise 调用链中的 dispatchRequest 方法，主要做了以下操作：<br>以 <code>transformData.call</code>方式调用</p>\n<ul>\n<li>transformRequest: 对 config 中的 data 进行加工，比如对 post 请求的 data 进行字符串化 （JSON.stringify(data)）</li>\n<li>adapter：适配器，包含浏览器端 xhr 和 node 端的 http</li>\n<li>transformResponse: 对服务端响应的数据进行加工，比如 JSON.parse(data)</li>\n</ul>\n<p>dispatchRequest 局部图</p>\n<img src=\"http://t-blog-images.aijs.top/img/20220623165506.webp\" width=300 height=/>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; functiondispatchRequest(config) &#123;\n  ...\n  &#x2F;&#x2F; transformRequest 方法，上下文绑定 config，对 data 和 headers 进行加工\n  config.data &#x3D; transformData.call( config,\n  &#x2F;&#x2F; 上下文环境，即 this 指向 config.data,\n  &#x2F;&#x2F; 请求 body 参数 config.headers,\n  &#x2F;&#x2F; 请求头 config.transformRequest\n  &#x2F;&#x2F; 转换数据方法\n  );\n  &#x2F;&#x2F; adapter 是一个适配器，包含浏览器端 xhr 和 node 端的 http\n  &#x2F;&#x2F; 内置有 adapter，也可外部自定义去发起 ajax 请求\n  var adapter &#x3D; config.adapter || defaults.adapter;return adapter(config).then(\n    functiononAdapterResolution(response) &#123;\n    &#x2F;&#x2F; transformResponse 方法，上下文绑定 config，对 data 和 headers 进行加工\n      response.data &#x3D; transformData.call( config,\n      &#x2F;&#x2F; 上下文环境，即 this 指向\n      response.data, &#x2F;&#x2F; 服务端响应的 data\n      config.transformResponse &#x2F;&#x2F; 转换数据方法\n      );\n\n      response.headers, &#x2F;&#x2F; 服务端响应的 headers\n\n      return response;\n     &#125;,\n    functiononAdapterRejection(reason) &#123;\n     ...\n     return Promise.reject(reason);\n    &#125;);\n  &#125;;</code></pre>\n\n<h2 id=\"数据转换器\"><a href=\"#数据转换器\" class=\"headerlink\" title=\"数据转换器\"></a>数据转换器</h2><p><code>file:lib/core/transformData.js</code></p>\n<p>上面说到的数据转换器，比较好理解，源码如下</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; fns 方法即（请求或响应）数据转换器方法，在刚开始 defaults 文件里定义的默认配置，也可外部自定义方法，源码如下：\n\n&#x2F;**\n * Transform the data for a request or a response\n * 转换请求或响应的数据\n * @param &#123;Array|Function&#125; fns 一个数组，包含一个或多个方法转换器方法\n * @param &#123;?Object&#125; response The response object\n *\n * @returns &#123;*&#125; The resulting transformed data\n *&#x2F;\nexport default function transformData(fns, response) &#123;\n  const config &#x3D; this || defaults;\n  const context &#x3D; response || config;\n  const headers &#x3D; AxiosHeaders.from(context.headers);\n  let data &#x3D; context.data;\n\n  utils.forEach(fns, function transform(fn) &#123;\n    data &#x3D; fn.call(\n      config,\n      data,\n      headers.normalize(),\n      response ? response.status : undefined\n    );\n  &#125;);\n\n  headers.normalize();\n\n  return data;\n&#125;</code></pre>\n\n<h2 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h2><p><code>file: lib/defaults.js</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nconst defaults &#x3D; &#123;\n  ...\n  &#x2F;&#x2F; 返回转化后的请求参数\n  transformRequest: [function transformRequest(data, headers) &#123;\n    const contentType &#x3D; headers.getContentType() || &#39;&#39;;\n    const hasJSONContentType &#x3D; contentType.indexOf(&#39;application&#x2F;json&#39;) &gt; -1;\n    const isObjectPayload &#x3D; utils.isObject(data);\n\n    if (isObjectPayload &amp;&amp; utils.isHTMLForm(data)) &#123;\n      data &#x3D; new FormData(data);\n    &#125;\n\n    const isFormData &#x3D; utils.isFormData(data);\n\n    if (isFormData) &#123;\n      if (!hasJSONContentType) &#123;\n        return data;\n      &#125;\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    &#125;\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) &#123;\n      return data;\n    &#125;\n    if (utils.isArrayBufferView(data)) &#123;\n      return data.buffer;\n    &#125;\n    if (utils.isURLSearchParams(data)) &#123;\n      headers.setContentType(&#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8&#39;, false);\n      return data.toString();\n    &#125;\n\n    let isFileList;\n\n    if (isObjectPayload) &#123;\n      if (contentType.indexOf(&#39;application&#x2F;x-www-form-urlencoded&#39;) &gt; -1) &#123;\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      &#125;\n\n      if ((isFileList &#x3D; utils.isFileList(data)) || contentType.indexOf(&#39;multipart&#x2F;form-data&#39;) &gt; -1) &#123;\n        const _FormData &#x3D; this.env &amp;&amp; this.env.FormData;\n\n        return toFormData(\n          isFileList ? &#123;&#39;files[]&#39;: data&#125; : data,\n          _FormData &amp;&amp; new _FormData(),\n          this.formSerializer\n        );\n      &#125;\n    &#125;\n\n    if (isObjectPayload || hasJSONContentType ) &#123;\n      headers.setContentType(&#39;application&#x2F;json&#39;, false);\n      return stringifySafely(data);\n    &#125;\n\n    return data;\n  &#125;],\n  &#x2F;&#x2F; 返回转化后的响应数据\n  transformResponse: [function transformResponse(data) &#123;\n    const transitional &#x3D; this.transitional || defaults.transitional;\n    const forcedJSONParsing &#x3D; transitional &amp;&amp; transitional.forcedJSONParsing;\n    const JSONRequested &#x3D; this.responseType &#x3D;&#x3D;&#x3D; &#39;json&#39;;\n\n    if (data &amp;&amp; utils.isString(data) &amp;&amp; ((forcedJSONParsing &amp;&amp; !this.responseType) || JSONRequested)) &#123;\n      const silentJSONParsing &#x3D; transitional &amp;&amp; transitional.silentJSONParsing;\n      const strictJSONParsing &#x3D; !silentJSONParsing &amp;&amp; JSONRequested;\n\n      try &#123;\n        return JSON.parse(data); &#x2F;&#x2F; 解析数据\n      &#125; catch (e) &#123;\n        if (strictJSONParsing) &#123;\n          if (e.name &#x3D;&#x3D;&#x3D; &#39;SyntaxError&#39;) &#123;\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          &#125;\n          throw e;\n        &#125;\n      &#125;\n    &#125;\n\n    return data;\n  &#125;],\n\n\n&#125;;</code></pre>\n\n<h2 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h2><p><code>file:lib/defaults.js</code></p>\n<p>主要包含两部分源码，即浏览器端 xhr 和 node 端的 http 请求，通过判断环境，执行不同端的 api。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import utils from &quot;..&#x2F;utils.js&quot;;\nimport httpAdapter from &quot;.&#x2F;http.js&quot;;\nimport xhrAdapter from &quot;.&#x2F;xhr.js&quot;;\n\nconst adapters &#x3D; &#123;\n  http: httpAdapter,\n  xhr: xhrAdapter,\n&#125;;\n\nexport default &#123;\n  getAdapter: (nameOrAdapter) &#x3D;&gt; &#123;\n    if (utils.isString(nameOrAdapter)) &#123;\n      const adapter &#x3D; adapters[nameOrAdapter];\n\n      if (!nameOrAdapter) &#123;\n        throw Error(\n          utils.hasOwnProp(nameOrAdapter)\n            ? &#96;Adapter &#39;$&#123;nameOrAdapter&#125;&#39; is not available in the build&#96;\n            : &#96;Can not resolve adapter &#39;$&#123;nameOrAdapter&#125;&#39;&#96;\n        );\n      &#125;\n\n      return adapter;\n    &#125;\n\n    if (!utils.isFunction(nameOrAdapter)) &#123;\n      throw new TypeError(&quot;adapter is not a function&quot;);\n    &#125;\n\n    return nameOrAdapter;\n  &#125;,\n  adapters,\n&#125;;\n\n&#x2F;&#x2F; 注：&#x2F;axios&#x2F;lib&#x2F;core&#x2F;dispatchRequest.js\n&#x2F;&#x2F; const adapter &#x3D; config.adapter || defaults.adapter; 中调用 defaults.adapter\n&#x2F;&#x2F; file: &#x2F;axios&#x2F;lib&#x2F;defaults&#x2F;index.js\n&#x2F;&#x2F; export const default &#x3D; &#123;\n&#x2F;&#x2F;   adapter: getDefaultAdapter(),\n&#x2F;&#x2F; &#125;</code></pre>\n\n<p>对外提供统一 api，但底层兼容浏览器端和 node 端，类似 sdk，底层更改不影响上层 api，保持向后兼容</p>\n<h2 id=\"发起请求\"><a href=\"#发起请求\" class=\"headerlink\" title=\"发起请求\"></a>发起请求</h2><p><code>file: lib/adapters/xhr.js</code><br>平时用得比较多的是浏览器端，这里只讲 XMLHttpRequest 的封装，node 端有兴趣的同学自行查看源码(lib&#x2F;adapters&#x2F;http.js)</p>\n<p>简易版流程图表示大致内容：</p>\n<p><a href=\"http://t-blog-images.aijs.top/img/20220623172736.webp\" target=\"_blank\" ></a></p>\n<p>注意：新版本有改动</p>\n<ul>\n<li>setCancelToken 没啦，有 cancelToken 和 signal</li>\n<li>isSetCookie 没有这个</li>\n<li><code>onreadystatechange</code> 不一定有, <code>onloadend</code>方法一定会被调用</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (&quot;onloadend&quot; in request) &#123;\n  &#x2F;&#x2F; Use onloadend if available\n  request.onloadend &#x3D; onloadend;\n&#125; else &#123;\n  &#x2F;&#x2F; Listen for ready state to emulate onloadend\n  request.onreadystatechange &#x3D; function handleLoad() &#123;\n    if (!request || request.readyState !&#x3D;&#x3D; 4) &#123;\n      return;\n    &#125;\n\n    &#x2F;&#x2F; The request errored out and we didn&#39;t get a response, this will be\n    &#x2F;&#x2F; handled by onerror instead\n    &#x2F;&#x2F; With one exception: request that using file: protocol, most browsers\n    &#x2F;&#x2F; will return status as 0 even though it&#39;s a successful request\n    if (\n      request.status &#x3D;&#x3D;&#x3D; 0 &amp;&amp;\n      !(request.responseURL &amp;&amp; request.responseURL.indexOf(&quot;file:&quot;) &#x3D;&#x3D;&#x3D; 0)\n    ) &#123;\n      return;\n    &#125;\n    &#x2F;&#x2F; readystate handler is calling before onerror or ontimeout handlers,\n    &#x2F;&#x2F; so we should call onloadend on the next &#39;tick&#39;\n    setTimeout(onloadend);\n  &#125;;\n&#125;</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://baijiahao.baidu.com/s?id=1704404768648603231&wfr=spider&for=pc&searchword=axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\" target=\"_blank\" >Axios 源码解析-完整篇</a></p>\n<p><a href=\"https://blog.csdn.net/qq_27053493/article/details/97462300\" target=\"_blank\" >一步一步解析 Axios 源码，从入门到原理</a></p>\n<p><a href=\"https://www.codingsky.com/doc/2022/4/2/433.html\" target=\"_blank\" >axios源码中的10多个工具函数，值得一学~</a></p>\n","text":"官网官网首页官方文档介绍中文文档 Promise based HTTP client for the browser and node.js基于 promise 可以用于浏览器和 node.js 的网络请求库 Axios is a promise-based HTTP Clien...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"Http","slug":"Http","count":1,"path":"api/categories/Http.json"}],"tags":[{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%98%E7%BD%91\"><span class=\"toc-text\">官网</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%8F%8A-Axios-API\"><span class=\"toc-text\">使用及 Axios API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">注意点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%81%87%E8%AE%BE\"><span class=\"toc-text\">假设</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">源码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#gulpfile-js\"><span class=\"toc-text\">gulpfile.js</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bower-json\"><span class=\"toc-text\">bower.json</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#package-json\"><span class=\"toc-text\">package.json</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#rollup-config-js\"><span class=\"toc-text\">rollup.config.js</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%8C%85%E4%BA%A7%E7%89%A9\"><span class=\"toc-text\">打包产物</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#axios-js\"><span class=\"toc-text\">axios.js</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C-sandbox\"><span class=\"toc-text\">运行 sandbox</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#core-%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">core 目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#axios-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">axios 执行流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">入口文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">默认配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%A6%E6%88%AA%E5%99%A8\"><span class=\"toc-text\">拦截器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dispatchRequest\"><span class=\"toc-text\">dispatchRequest</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E5%99%A8\"><span class=\"toc-text\">数据转换器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Axios\"><span class=\"toc-text\">Axios</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%82%E9%85%8D%E5%99%A8\"><span class=\"toc-text\">适配器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">发起请求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"点","uid":"e9a180d03e63743825beabe89becedc8","slug":"2022-06-23点","date":"2022-06-23T09:53:22.000Z","updated":"2022-09-16T13:54:56.153Z","comments":true,"path":"api/articles/2022-06-23点.json","keywords":null,"cover":[],"text":" 记得之前在哪看到过是js解析时候的问题 &#x2F;&#x2F; 比如 1.toString() &#x2F;&#x2F; 会被解析认为这个.是数字1的点，即：1. 这个含小数的数 Number(1).toString() &#x2F;&#x2F; ok 1 .toString...","link":"","photos":[],"count_time":{"symbolsCount":295,"symbolsTime":"1 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":1,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":1,"path":"api/tags/javaScript.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"react-router v0.6.4 依赖 history 5.0.0-beta.5源码","uid":"a154738b9ff4f1409237a2b3abef8f87","slug":"2022-06-22.history","date":"2022-06-22T10:40:45.000Z","updated":"2022-09-16T15:00:17.131Z","comments":true,"path":"api/articles/2022-06-22.history.json","keywords":null,"cover":null,"text":"介绍Documentation for version 5 can be found in the docs directory. This is the current stable release. Version 5 is used in React Router vers...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"React","slug":"React","count":26,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":20,"path":"api/tags/React.json"},{"name":"源码","slug":"源码","count":14,"path":"api/tags/源码.json"},{"name":"react-router","slug":"react-router","count":3,"path":"api/tags/react-router.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}