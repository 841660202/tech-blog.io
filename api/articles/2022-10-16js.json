{"title":"js面试题","uid":"abbf797f56f759efd8b49b85ff4481ae","slug":"2022-10-16js","date":"2022-10-16T15:17:54.000Z","updated":"2022-10-17T12:21:18.490Z","comments":true,"path":"api/articles/2022-10-16js.json","keywords":null,"cover":null,"content":"<h2 id=\"B-站爬取脚本\"><a href=\"#B-站爬取脚本\" class=\"headerlink\" title=\"B 站爬取脚本\"></a>B 站爬取脚本</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var list &#x3D; document.getElementsByClassName(&quot;video-list&quot;)[0];\n\nArray.from(list.children).forEach((item) &#x3D;&gt; &#123;\n  var t &#x3D; item.children[1].innerText;\n  document.body.append(t);\n\n  var br &#x3D; document.createElement(&quot;br&quot;);\n  document.body.append(br);\n&#125;);</code></pre>\n\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><h3 id=\"JS-面试题之-js-的-typeof-返回哪些数据类型\"><a href=\"#JS-面试题之-js-的-typeof-返回哪些数据类型\" class=\"headerlink\" title=\"JS 面试题之 js 的 typeof 返回哪些数据类型\"></a>JS 面试题之 js 的 typeof 返回哪些数据类型</h3><p>string, boolean, number, undefined, function, object。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">typeof console;\n&#x2F;&#x2F; &#39;object&#39;\ntypeof console.log;\n&#x2F;&#x2F; &#39;function&#39;\ntypeof console.log();\n&#x2F;&#x2F; &#39;undefined&#39;</code></pre>\n\n<p>首先在 JS 中，分两种数据类型：</p>\n<p><strong>基本数据类型：</strong> Number、String、Boolean、Null、 Undefined、Symbol（ES6），这些类型可以直接操作保存在变量中的实际值。同时要记住，这这些值他是存放在栈中的。</p>\n<p><strong>引用数据类型：</strong> Object（_在 JS 中除了基本数据类型以外的都是对象_，数据-Array 是对象，函数-Function 是对象，正则表达式-Reg 是对象,，日期时间-Date 是对象）。</p>\n<p>然后到目前为止，ECMAScript 标准中定义了 8 种数据类型，它们分别是 Undefined、Null、Number、Boolean、String、<code>Symbol</code>、<code>BigInt</code>、Object。<br>————————————————<br>版权声明：本文为 CSDN 博主「伍文亮」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_44963070/article/details/124046875\">https://blog.csdn.net/weixin_44963070/article/details/124046875</a></p>\n<h3 id=\"JS-中-this-相关问题\"><a href=\"#JS-中-this-相关问题\" class=\"headerlink\" title=\"JS 中 this 相关问题\"></a>JS 中 this 相关问题</h3><h3 id=\"JS-面试题之-ajax、axios、fetch-的区别\"><a href=\"#JS-面试题之-ajax、axios、fetch-的区别\" class=\"headerlink\" title=\"JS 面试题之 ajax、axios、fetch 的区别\"></a>JS 面试题之 ajax、axios、fetch 的区别</h3><p>参考答案：</p>\n<p><strong>（1）AJAX</strong><br>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p>\n<p><em>其缺点如下：</em></p>\n<p>本身是针对 MVC 编程，不符合前端 MVVM 的浪潮<br>基于原生 XHR 开发，XHR 本身的架构不清晰<br>不符合关注分离（Separation of Concerns）的原则<br>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</p>\n<p><strong>（2）Fetch</strong><br>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的。Fetch 的代码结构比起 ajax 简单多。fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</p>\n<p><em>fetch 的优点：</em></p>\n<p>语法简洁，更加语义化<br>基于标准 Promise 实现，支持 async&#x2F;await<br>更加底层，提供的 API 丰富（request, response）<br>脱离了 XHR，是 ES 规范里新的实现方式<br><em>fetch 的缺点：</em></p>\n<p>fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。<br>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: ‘include’})<br>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>fetch 没有办法原生监测请求的进度，而 XHR 可以</p>\n<p><strong>（3）Axios</strong><br>Axios 是一种基于 Promise 封装的 HTTP 客户端，其特点如下：</p>\n<p>浏览器端发起 XMLHttpRequests 请求, node 端发起 http 请求<br>支持 Promise API<br>监听请求和返回<br>对请求和返回进行转化<br>取消请求<br>自动转换 json 数据<br>客户端支持抵御 XSRF 攻击</p>\n<h3 id=\"JS-面试题之-for…in-和-for…of-的区别\"><a href=\"#JS-面试题之-for…in-和-for…of-的区别\" class=\"headerlink\" title=\"JS 面试题之 for…in 和 for…of 的区别\"></a>JS 面试题之 for…in 和 for…of 的区别</h3><h3 id=\"JS-面试题之如何判断一个对象是否属于某个类？\"><a href=\"#JS-面试题之如何判断一个对象是否属于某个类？\" class=\"headerlink\" title=\"JS 面试题之如何判断一个对象是否属于某个类？\"></a>JS 面试题之如何判断一个对象是否属于某个类？</h3><p>instanceof</p>\n<p>Object.prototype.toString.call()</p>\n<h3 id=\"JS-面试题之谈谈-use-strict-及其作用？\"><a href=\"#JS-面试题之谈谈-use-strict-及其作用？\" class=\"headerlink\" title=\"JS 面试题之谈谈 use strict 及其作用？\"></a>JS 面试题之谈谈 use strict 及其作用？</h3><h3 id=\"JS-面试题之谈谈尾调用及其好处？\"><a href=\"#JS-面试题之谈谈尾调用及其好处？\" class=\"headerlink\" title=\"JS 面试题之谈谈尾调用及其好处？\"></a>JS 面试题之谈谈尾调用及其好处？</h3><h3 id=\"JS-面试题之-escape、encodeURI、encodeURIComponent-的区别\"><a href=\"#JS-面试题之-escape、encodeURI、encodeURIComponent-的区别\" class=\"headerlink\" title=\"JS 面试题之 escape、encodeURI、encodeURIComponent 的区别\"></a>JS 面试题之 escape、encodeURI、encodeURIComponent 的区别</h3><h3 id=\"JS-面试题之-isNaN-和-Number-isNaN-函数的区别？\"><a href=\"#JS-面试题之-isNaN-和-Number-isNaN-函数的区别？\" class=\"headerlink\" title=\"JS 面试题之 isNaN 和 Number.isNaN 函数的区别？\"></a>JS 面试题之 isNaN 和 Number.isNaN 函数的区别？</h3><p>isNaN 接收参数，会尝试将这个参数转化成数值，任何不能被转换为数值的值都会返回 true,<br>因此非数字值传入也会返回 true,会影响 NaN 的判断。</p>\n<p>Number.isNaN 也会首先判断传入的参数是否为数字，如果是数字再继续判断是否为 NaN，不会进行数据类型的转化，这种方法对 NaN 的判断更准确</p>\n<h3 id=\"JS-面试题之说说你对堆区和栈区的理解\"><a href=\"#JS-面试题之说说你对堆区和栈区的理解\" class=\"headerlink\" title=\"JS 面试题之说说你对堆区和栈区的理解\"></a>JS 面试题之说说你对堆区和栈区的理解</h3><p><strong>数据结构：</strong><br>(1)、栈：栈在数据结构中的特性是后进先出的特性。<br>(2)、堆：对在数据结构中是一个优先队列，按照优先级进行排序，其中完全二叉树是堆数据结构的一个实现。</p>\n<p><strong>操作系统：</strong><br>在操作系统中将内存分为栈区和堆区。<br>(1)、栈：基本的数据类型，函数参数等存放在栈中，是计算机自动分配的内存空间<br>(2)、堆：一些函数，对象等数据类型的数据存放在堆中，堆中的内存程序员自己进行分配和释放，如果程序员不释放，在程序执行结束后，系统会自动释放。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/122503152\">https://blog.csdn.net/weixin_47450807/article/details/122503152</a></p>\n<h3 id=\"JS-面试题之说说-Ajax-组成部分\"><a href=\"#JS-面试题之说说-Ajax-组成部分\" class=\"headerlink\" title=\"JS 面试题之说说 Ajax 组成部分\"></a>JS 面试题之说说 Ajax 组成部分</h3><p><code>Asynchronous</code> <code>JavaScript</code> and <code>XML</code></p>\n<h3 id=\"JavaScript-中-BOM-与-DOM-的区别\"><a href=\"#JavaScript-中-BOM-与-DOM-的区别\" class=\"headerlink\" title=\"JavaScript 中 BOM 与 DOM 的区别\"></a>JavaScript 中 BOM 与 DOM 的区别</h3><p>DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性</p>\n<p>BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器</p>\n<p>Javascript 由三部分构成，<code>ECMAScript</code>，<code>DOM</code> 和 <code>BOM</code></p>\n<ol>\n<li><em>ECMAScript(核心)</em> 　　描述了 JS 的语法和基本对象</li>\n<li>_DOM 是文档对象模型_，处理网页内容的方法和接口。是 W3C 的标准； [所有浏览器公共遵守的标准]</li>\n<li>_BOM 是浏览器对象模型_，提供与浏览器交互的方法和接口。各个浏览器厂商根据 DOM 在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同]</li>\n</ol>\n<p><strong>DOM</strong></p>\n<p>这个 DOM 定义了一个 HTMLDocument 和 HTMLElement 做为这种实现的基础,就是说为了能以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素）</p>\n<p><strong>BOM</strong></p>\n<p>比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数</p>\n<p>Window 对象包含属性：document、location、navigator、screen、history、frames<br>Document 根节点包含子节点：forms、embeds、anchors、images、links</p>\n<p>从 window.document 已然可以看出，DOM 的最根本的对象是 BOM 的 window 对象的子对象。</p>\n<p>由于 BOM 的 window 包含了 document，因此可以直接使用 window 对象的 document 属性，通过 document 属性就可以访问、检索、修改 XHTML 文档内容与结构。</p>\n<p>因为 document 对象又是 DOM（Document Object Model）模型的根节点。</p>\n<p>可以说，BOM 包含了 DOM(对象)，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象，<br>从而 js 可以操作浏览器以及浏览器读取到的文档。</p>\n<p>作者：王小端 coder<br>链接：<a href=\"https://juejin.cn/post/6844903939008102413\">https://juejin.cn/post/6844903939008102413</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"JS-面试题之你是怎么理解闭包的？\"><a href=\"#JS-面试题之你是怎么理解闭包的？\" class=\"headerlink\" title=\"JS 面试题之你是怎么理解闭包的？\"></a>JS 面试题之你是怎么理解闭包的？</h3><h3 id=\"JS-面试题之说下-JS-的基本数据类型\"><a href=\"#JS-面试题之说下-JS-的基本数据类型\" class=\"headerlink\" title=\"JS 面试题之说下 JS 的基本数据类型\"></a>JS 面试题之说下 JS 的基本数据类型</h3><h2 id=\"为什么-js-是单线程\"><a href=\"#为什么-js-是单线程\" class=\"headerlink\" title=\"为什么 js 是单线程\"></a>为什么 js 是单线程</h2><p>这主要和 js 的用途有关，_js 是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作 dom_；<br>这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>举个例子：如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，<br>_此时浏览器就会一脸茫然，不知所措_。所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，<br>这已经成了这门语言的核心特征，将来也不会改变。</p>\n<h2 id=\"进程、线程\"><a href=\"#进程、线程\" class=\"headerlink\" title=\"进程、线程\"></a>进程、线程</h2><p><strong>什么是进程:</strong><br><em>进程：</em>是 cpu 分配资源的最小单位；（是能拥有资源和独立运行的最小单位）</p>\n<p><strong>什么是线程:</strong><br><em>线程：</em>是 cpu 调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p>\n<p><strong>浏览器是多进程的？</strong><br>放在浏览器中，每打开一个 tab 页面，其实就是新开了一个进程，<br>在这个进程中，还有 _ui 渲染线程_，_js 引擎线程_，<em>http 请求线程</em>等。 所以，浏览器是一个多进程的。</p>\n<p>_为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准_，允许 JavaScript 脚本创建多个线程，<br>但是<code>子线程完全受主线程控制</code>，且<code>不得操作 DOM</code>。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>\n<h2 id=\"宏微任务以及执行顺序\"><a href=\"#宏微任务以及执行顺序\" class=\"headerlink\" title=\"宏微任务以及执行顺序\"></a>宏微任务以及执行顺序</h2><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队。<br>1、**宏任务:<strong>用来保存待执行的宏任务（回调），比如：<code>定时器回调</code>、<code>DOM 事件回调</code>、<code>ajax 回调</code><br>2、</strong>微任务:**用来保存待执行的微任务（回调），比如：<code>promise 的回调</code>、<code>MutationObserver 的回调</code></p>\n<p>JS 执行时会区别这 2 个队列<br>1、JS 引擎首先必须先执行所有的初始化<em>同步任务代码</em><br>2、_每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行_，也就是优先级比宏任务高，且与微任务所处的代码位置无关<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/124533748\">https://blog.csdn.net/weixin_47450807/article/details/124533748</a></p>\n<h2 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h2><p>参考答案:<br>暂时性死区的本质就是，只要一进入当前作用域，_所要使用的变量就已经存在了，但是不可获取_，_直到声明变量的那一行代码出现_，才可以获取和使用该变量。</p>\n<p><strong>let 、const 与暂时性死区</strong><br>let 或 const 声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。</p>\n<p><strong>首先看看不具有暂时性死区的 var：</strong><br>当进入 var 变量的作用域（包围它的函数），<em>立即为它创建（绑定）存储空间。变量会立即被初始化并赋值为 undefined。</em><br>当执行到变量声明的时候，如果变量定义了值则会被赋值。</p>\n<p><strong>通过 let 声明的变量拥有暂时性死区，生命周期如下：</strong><br>当进入 let 变量的作用域（包围它的语法块），<em>立即为它创建（绑定）存储空间。此时变量仍是未初始化的。</em><br>获取或设置未初始化的变量将抛出异常 ReferenceError。<br>当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为 undefined。</p>\n<p>const 工作方式与 let 类似，但是定义的时候必须赋值并且不能改变。</p>\n<h2 id=\"面向对象的三大特性，分别说一下什么意思\"><a href=\"#面向对象的三大特性，分别说一下什么意思\" class=\"headerlink\" title=\"面向对象的三大特性，分别说一下什么意思?\"></a>面向对象的三大特性，分别说一下什么意思?</h2><p>1、*封装:*将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。</p>\n<p>对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。</p>\n<p>2、*继承:*继承可以解决代码复用，让编程更加靠近人类思维。</p>\n<p>当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p>\n<p>3、*多态:*多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：<em>多态是指通过指向父类的引用，来调用在不同子类中实现的方法。</em></p>\n<h2 id=\"Promise-和-async-await-的区别\"><a href=\"#Promise-和-async-await-的区别\" class=\"headerlink\" title=\"Promise 和 async await 的区别\"></a>Promise 和 async await 的区别</h2><p><strong>1、概念:</strong><br><strong>Promise</strong> 是异步编程的一种解决方案，比传统的解决方案——<em>回调函数</em>和<em>事件</em>——更合理和更强大，简单地说，Promise 好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的。</p>\n<p><strong>async await</strong>也是异步编程的一种解决方案，他遵循的是 Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个 Promise 对象。</p>\n<p><strong>两者的区别:</strong><br>1、Promise 的出现解决了传统 callback 函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而 async await 代码看起来会简洁些，使得异步代码看起来像同步代码，await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。<br>2、async await 与 Promise 一样，是非阻塞的。<br>3、async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数。</p>\n","text":"B 站爬取脚本var list &#x3D; document.getElementsByClassName(&quot;video-list&quot;)[0]; Array.from(list.children).forEach((item) &#x3D;&gt; &#123...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"js","slug":"js","count":1,"path":"api/categories/js.json"}],"tags":[{"name":"js","slug":"js","count":1,"path":"api/tags/js.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B-%E7%AB%99%E7%88%AC%E5%8F%96%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">B 站爬取脚本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js\"><span class=\"toc-text\">js</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-js-%E7%9A%84-typeof-%E8%BF%94%E5%9B%9E%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">JS 面试题之 js 的 typeof 返回哪些数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E4%B8%AD-this-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">JS 中 this 相关问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-ajax%E3%80%81axios%E3%80%81fetch-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">JS 面试题之 ajax、axios、fetch 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">JS 面试题之 for…in 和 for…of 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%9F\"><span class=\"toc-text\">JS 面试题之如何判断一个对象是否属于某个类？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%B0%88%E8%B0%88-use-strict-%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">JS 面试题之谈谈 use strict 及其作用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%B0%88%E8%B0%88%E5%B0%BE%E8%B0%83%E7%94%A8%E5%8F%8A%E5%85%B6%E5%A5%BD%E5%A4%84%EF%BC%9F\"><span class=\"toc-text\">JS 面试题之谈谈尾调用及其好处？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-escape%E3%80%81encodeURI%E3%80%81encodeURIComponent-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">JS 面试题之 escape、encodeURI、encodeURIComponent 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-isNaN-%E5%92%8C-Number-isNaN-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">JS 面试题之 isNaN 和 Number.isNaN 函数的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%A0%86%E5%8C%BA%E5%92%8C%E6%A0%88%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">JS 面试题之说说你对堆区和栈区的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AF%B4%E8%AF%B4-Ajax-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">JS 面试题之说说 Ajax 组成部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript-%E4%B8%AD-BOM-%E4%B8%8E-DOM-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">JavaScript 中 BOM 与 DOM 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">JS 面试题之你是怎么理解闭包的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AF%B4%E4%B8%8B-JS-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">JS 面试题之说下 JS 的基本数据类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-js-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">为什么 js 是单线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">进程、线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">宏微任务以及执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA\"><span class=\"toc-text\">暂时性死区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">面向对象的三大特性，分别说一下什么意思?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise-%E5%92%8C-async-await-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Promise 和 async await 的区别</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"待办事项","uid":"c370dd6ecfc84fe9fdfa77b1a6f29341","slug":"todo","date":"2022-12-14T03:59:59.000Z","updated":"2022-09-26T12:16:19.528Z","comments":true,"path":"api/articles/todo.json","keywords":null,"cover":[],"text":"特殊记忆 &#x2F;&#x2F; 1. headless-recorder &#x2F;&#x2F; 2. lightHouse https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangdou369098655&#x2F;article&#x2F;de...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"Todo","slug":"Todo","count":1,"path":"api/categories/Todo.json"}],"tags":[{"name":"Todo","slug":"Todo","count":1,"path":"api/tags/Todo.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"gorm","uid":"9e2838a04929d964c7bc52054867739d","slug":"2022-10-16gorm","date":"2022-10-16T10:34:17.000Z","updated":"2022-10-17T11:18:29.864Z","comments":true,"path":"api/articles/2022-10-16gorm.json","keywords":null,"cover":[],"text":"githubhttps://github.com/go-gorm/gorm ORM orm 解决的问题专注于语言，弱化 sql 关系 默认值零值 || 默认值 方式 1: 指针 方式 2: sql 结构体 map[string]interface&#123;&#125;&#123...","link":"","photos":[],"count_time":{"symbolsCount":692,"symbolsTime":"1 mins."},"categories":[{"name":"Go","slug":"Go","count":5,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":5,"path":"api/tags/Go.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}