{"title":"js面试题","uid":"abbf797f56f759efd8b49b85ff4481ae","slug":"2022-10-16js","date":"2022-10-16T15:17:54.000Z","updated":"2022-12-22T13:36:21.790Z","comments":true,"path":"api/articles/2022-10-16js.json","keywords":null,"cover":null,"content":"<h2 id=\"B-站爬取脚本\"><a href=\"#B-站爬取脚本\" class=\"headerlink\" title=\"B 站爬取脚本\"></a>B 站爬取脚本</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var list &#x3D; document.getElementsByClassName(&quot;video-list&quot;)[0];\n\nArray.from(list.children).forEach((item) &#x3D;&gt; &#123;\n  var t &#x3D; item.children[1].innerText;\n  document.body.append(t);\n\n  var br &#x3D; document.createElement(&quot;br&quot;);\n  document.body.append(br);\n&#125;);</code></pre>\n\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><h3 id=\"js-的-typeof-返回哪些数据类型\"><a href=\"#js-的-typeof-返回哪些数据类型\" class=\"headerlink\" title=\"js 的 typeof 返回哪些数据类型\"></a>js 的 typeof 返回哪些数据类型</h3><p>string, boolean, number, undefined, function, object。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">typeof console;\n&#x2F;&#x2F; &#39;object&#39;\ntypeof console.log;\n&#x2F;&#x2F; &#39;function&#39;\ntypeof console.log();\n&#x2F;&#x2F; &#39;undefined&#39;</code></pre>\n\n<p>首先在 JS 中，分两种数据类型：</p>\n<p><strong>基本数据类型：</strong> Number、String、Boolean、Null、 Undefined、Symbol（ES6），这些类型可以直接操作保存在变量中的实际值。同时要记住，这这些值他是存放在栈中的。</p>\n<p><strong>引用数据类型：</strong> Object（<em>在 JS 中除了基本数据类型以外的都是对象</em> )</p>\n<ol>\n<li>函数-Function 是对象</li>\n<li>数据-Array 是对象</li>\n<li>日期时间-Date 是对象</li>\n<li>正则表达式-Reg 是对象</li>\n</ol>\n<p>到目前为止，ECMAScript 标准中定义了 8 种数据类型，它们分别是 Undefined、Null、Number、Boolean、String、<code>Symbol</code>、<code>BigInt</code>、Object。<br>————————————————<br>版权声明：本文为 CSDN 博主「伍文亮」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_44963070/article/details/124046875\">https://blog.csdn.net/weixin_44963070/article/details/124046875</a></p>\n<h3 id=\"JS-中-this-相关问题\"><a href=\"#JS-中-this-相关问题\" class=\"headerlink\" title=\"JS 中 this 相关问题\"></a>JS 中 this 相关问题</h3><h3 id=\"ajax、axios、fetch-的区别\"><a href=\"#ajax、axios、fetch-的区别\" class=\"headerlink\" title=\"ajax、axios、fetch 的区别\"></a>ajax、axios、fetch 的区别</h3><p>参考答案：</p>\n<p><strong>（1）AJAX</strong> 即<code>“Asynchronous Javascript And XML”</code>（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</p>\n<ul>\n<li>它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>\n<li>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。</li>\n<li>这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>\n</ul>\n<p><em>其缺点如下：</em></p>\n<ul>\n<li>本身是针对 MVC 编程，不符合前端 MVVM 的浪潮</li>\n<li>基于原生 XHR 开发，XHR 本身的架构不清晰</li>\n<li>不符合关注分离（Separation of Concerns）的原则</li>\n<li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>\n</ul>\n<p><strong>（2）Fetch</strong></p>\n<ul>\n<li>fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</li>\n<li>fetch 号称是 XMLHttpRequest 的替代品</li>\n<li>fetch 是基于 promise 设计的。</li>\n<li>fetch 的代码结构比起 ajax 简单多。</li>\n</ul>\n<p><em>fetch 的优点：</em></p>\n<ol>\n<li>脱离了 XHR，是 ES 规范里新的实现方式</li>\n<li>更加底层，提供的 API 丰富（request, response）</li>\n<li>基于标准 Promise 实现，支持 async&#x2F;await</li>\n<li>语法简洁，更加语义化</li>\n</ol>\n<p><em>fetch 的缺点：</em></p>\n<ul>\n<li><p>fetch 没有办法原生监测请求的进度，而 XHR 可以</p>\n</li>\n<li><p><code>HTTP 404 状态并不被认为是网络错误</code>。</p>\n</li>\n<li><p>fetch <code>只对网络请求报错才会被 reject,其他情况会被 resolved 掉</code></p>\n<ol>\n<li>当遇到网络错误时，fetch() 返回的 promise 会被 reject，并传回 <code>TypeError</code>，虽然这也可能因为权限或其它问题导致。</li>\n<li>成功的 fetch() 检查不仅要包括 promise 被 resolve，还要包括 <code>Response.ok</code> 属性为 true。</li>\n</ol>\n</li>\n<li><p>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {<code>credentials: &#39;include&#39;</code>})</p>\n</li>\n<li><p>fetch 支持 abort（利用 signal 结合 AbortController），不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\" target=\"_blank\" >见</a></p>\n</li>\n<li><p><code>AbortError</code>： 请求被 <code>AbortController.abort()</code>终止。</p>\n</li>\n<li><p><code>TypeError</code> ：</p>\n<ol>\n<li>method 为<code>get</code> <code>head</code> 方法, 配置 <code>body</code> <code>non-null</code> 或者不是 <code>undefined</code> 时候</li>\n<li>url 有误</li>\n<li>如果 fetch()接收到含有用户名和密码的 URL（例如 <a href=\"http://user:password@example.com),它将会抛出一个/\">http://user:password@example.com），它将会抛出一个</a> TypeError 。</li>\n<li>请求头配置有误</li>\n<li><code>cache</code> 字段为<code>only-if-cached</code>， <code>mode</code>不是 <code>same-origin</code></li>\n<li><code>no-cors</code> 非 <code>get</code>、<code>head</code>、<code>post</code> 时候会报错</li>\n</ol>\n</li>\n</ul>\n<p><strong>（3）Axios</strong> Axios 是一种基于 Promise 封装的 HTTP 客户端，其特点如下：</p>\n<ol>\n<li>浏览器端发起 XMLHttpRequests 请求, node 端发起 http 请求</li>\n<li>支持 Promise API</li>\n<li>监听请求和返回</li>\n<li>对请求和返回进行转化</li>\n<li>取消请求</li>\n<li>自动转换 json 数据</li>\n<li>客户端支持抵御 CSRF 攻击</li>\n</ol>\n<h3 id=\"for…in-和-for…of-的区别\"><a href=\"#for…in-和-for…of-的区别\" class=\"headerlink\" title=\"for…in 和 for…of 的区别\"></a>for…in 和 for…of 的区别</h3><ol>\n<li><p>for…of 循环是 ES6 新增的遍历方法。</p>\n</li>\n<li><p>for…of 循环可用于<code>数组/类数组</code>，包括<code>字符串</code>、<code>数组</code>、<code>Set</code> 和 <code>Map</code> 结构、某些类似数组的对象(比如 <code>arguments</code> 对象、<code>DOM NodeList</code> 对象)、<code>Generator</code> 对象；</p>\n</li>\n<li><p><code>对于普通的对象，for...of 循环不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。for...of 循环遍历得到键值。</code></p>\n</li>\n<li><p>for…in 循环不适用于遍历数组，主要是为了遍历对象而生，但是只能获得对象的键名，不能直接获得键值。</p>\n</li>\n<li><p>对于数组的遍历，for…in 循环会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)；for…of 循环只返回数组的下标对应的属性值。</p>\n</li>\n<li><p><code>for…in 循环会遍历对象的整个原型链，性能非常差不推荐使用</code>；而 for…of 循环只遍历当前对象不会遍历原型链。</p>\n</li>\n</ol>\n<p>作者：光头络腮胡<br>链接：<a href=\"https://juejin.cn/post/7148367249257005086\">https://juejin.cn/post/7148367249257005086</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"javascript-提前终止循环\"><a href=\"#javascript-提前终止循环\" class=\"headerlink\" title=\"javascript 提前终止循环\"></a>javascript 提前终止循环</h3><p>哪些循环可以提前终止掉循环</p>\n<ul>\n<li><code>for 循环</code></li>\n<li><code>for...in</code></li>\n<li><code>some</code></li>\n<li><code>every</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法</th>\n<th>break</th>\n<th>continue</th>\n<th>return</th>\n<th>return true</th>\n<th>return false</th>\n<th>结论</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">for 循环</td>\n<td>成功</td>\n<td>跳出本次循环</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>√</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">Array.forEach()</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>跳出本次循环</td>\n<td>跳出本次循环</td>\n<td>跳出本次循环</td>\n<td>×</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">for…in</td>\n<td>成功</td>\n<td>跳出本次循环</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>√</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">Array.map()</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>跳出本次循环</td>\n<td>跳出本次循环</td>\n<td>跳出本次循环</td>\n<td>×</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">Array.some()</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>跳出本次循环</td>\n<td>成功</td>\n<td>跳出本次循环</td>\n<td>√</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">Array.every()</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>成功</td>\n<td>跳出本次循环</td>\n<td>成功</td>\n<td>√</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">Array.filter()</td>\n<td>不合法</td>\n<td>不合法</td>\n<td>跳出本次循环</td>\n<td>跳出本次循环</td>\n<td>跳出本次循环</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<h3 id=\"如何判断一个对象是否属于某个类？\"><a href=\"#如何判断一个对象是否属于某个类？\" class=\"headerlink\" title=\"如何判断一个对象是否属于某个类？\"></a>如何判断一个对象是否属于某个类？</h3><p>instanceof</p>\n<p>Object.prototype.toString.call()</p>\n<h3 id=\"谈谈尾调用及其好处？\"><a href=\"#谈谈尾调用及其好处？\" class=\"headerlink\" title=\"谈谈尾调用及其好处？\"></a>谈谈尾调用及其好处？</h3><h4 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h4><p>尾调用指的是函数的最后一步调用另一个函数。</p>\n<p>我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。</p>\n<h4 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h4><p>使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。</p>\n<p><em>但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</em></p>\n<h3 id=\"escape、encodeURI、encodeURIComponent-的区别\"><a href=\"#escape、encodeURI、encodeURIComponent-的区别\" class=\"headerlink\" title=\"escape、encodeURI、encodeURIComponent 的区别\"></a>escape、encodeURI、encodeURIComponent 的区别</h3><ul>\n<li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li>\n<li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li>\n<li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，<ol>\n<li>escape 是直接在字符的 unicode 编码前加上 %u，</li>\n<li>encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"isNaN-和-Number-isNaN-函数的区别？\"><a href=\"#isNaN-和-Number-isNaN-函数的区别？\" class=\"headerlink\" title=\"isNaN 和 Number.isNaN 函数的区别？\"></a>isNaN 和 Number.isNaN 函数的区别？</h3><p><code>isNaN 接收参数，会尝试将这个参数转化成数值，任何不能被转换为数值的值都会返回 true</code>,<span style=\"color: red; font-size: 12px\">因此非数字值传入也会返回 true,会影响 NaN 的判断。</span></p>\n<p><code>Number.isNaN 也会首先判断传入的参数是否为数字，如果是数字再继续判断是否为 NaN，不会进行数据类型的转化，这种方法对 NaN 的判断更准确</code></p>\n<h3 id=\"说说你对堆区和栈区的理解\"><a href=\"#说说你对堆区和栈区的理解\" class=\"headerlink\" title=\"说说你对堆区和栈区的理解\"></a>说说你对堆区和栈区的理解</h3><p><strong>数据结构：</strong><br>(1)、栈：栈在数据结构中的特性是后进先出的特性。<br>(2)、堆：对在数据结构中是一个优先队列，按照优先级进行排序，其中完全二叉树是堆数据结构的一个实现。</p>\n<p><strong>操作系统：</strong><br>在操作系统中将内存分为栈区和堆区。<br>(1)、栈：基本的数据类型，函数参数等存放在栈中，是计算机自动分配的内存空间<br>(2)、堆：一些函数，对象等数据类型的数据存放在堆中，堆中的内存程序员自己进行分配和释放，如果程序员不释放，在程序执行结束后，系统会自动释放。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/122503152\">https://blog.csdn.net/weixin_47450807/article/details/122503152</a></p>\n<h3 id=\"说说-Ajax-组成部分\"><a href=\"#说说-Ajax-组成部分\" class=\"headerlink\" title=\"说说 Ajax 组成部分\"></a>说说 Ajax 组成部分</h3><p><code>Asynchronous</code> <code>JavaScript</code> and <code>XML</code></p>\n<h3 id=\"JavaScript-中-BOM-与-DOM-的区别\"><a href=\"#JavaScript-中-BOM-与-DOM-的区别\" class=\"headerlink\" title=\"JavaScript 中 BOM 与 DOM 的区别\"></a>JavaScript 中 BOM 与 DOM 的区别</h3><p>BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器</p>\n<p>DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性</p>\n<p>Javascript 由三部分构成，<code>ECMAScript</code>，<code>DOM</code> 和 <code>BOM</code></p>\n<ol>\n<li><em>ECMAScript(核心)</em> , 描述了 JS 的语法和基本对象</li>\n<li><em>BOM 是浏览器对象模型</em> , 提供与浏览器交互的方法和接口。各个浏览器厂商根据 DOM 在各自浏览器上的实现;<code>[表现为不同浏览器定义有差别,实现方式不同]</code></li>\n<li><em>DOM 是文档对象模型</em> , 处理网页内容的方法和接口。是 W3C 的标准； <code>[所有浏览器公共遵守的标准]</code></li>\n</ol>\n<p><strong>BOM</strong></p>\n<p><em>比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数</em></p>\n<p>Window 对象包含属性：document、location、navigator、screen、history、frames<br>Document 根节点包含子节点：forms、embeds、anchors、images、links</p>\n<p>从 window.document 已然可以看出，DOM 的最根本的对象是 BOM 的 window 对象的子对象。</p>\n<p>由于 BOM 的 window 包含了 document，因此可以直接使用 window 对象的 document 属性，通过 document 属性就可以访问、检索、修改 XHTML 文档内容与结构。</p>\n<p>因为 document 对象又是 DOM（Document Object Model）模型的根节点。</p>\n<p>可以说，BOM 包含了 DOM(对象)，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象，<br>从而 js 可以操作浏览器以及浏览器读取到的文档。</p>\n<p><strong>DOM</strong></p>\n<p><em>这个 DOM 定义了一个 HTMLDocument 和 HTMLElement 做为这种实现的基础,就是说为了能以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素）</em></p>\n<p><strong>总结：</strong></p>\n<ol>\n<li><code>描述的范围不同</code>: BOM 包含了 DOM(对象)，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象</li>\n<li><code>描述的内容不同</code>: DOM 以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素），BOM 比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数</li>\n</ol>\n<p>作者：王小端 coder<br>链接：<a href=\"https://juejin.cn/post/6844903939008102413\">https://juejin.cn/post/6844903939008102413</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"你是怎么理解闭包的？\"><a href=\"#你是怎么理解闭包的？\" class=\"headerlink\" title=\"你是怎么理解闭包的？\"></a>你是怎么理解闭包的？</h3><h3 id=\"说下-JS-的基本数据类型\"><a href=\"#说下-JS-的基本数据类型\" class=\"headerlink\" title=\"说下 JS 的基本数据类型\"></a>说下 JS 的基本数据类型</h3><h2 id=\"use-strict-及其作用？\"><a href=\"#use-strict-及其作用？\" class=\"headerlink\" title=\"use strict 及其作用？\"></a>use strict 及其作用？</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" >MDN use strict</a></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>es5 的严格模式:</p>\n<p><strong>在不使用严格模式时，程序猿开发的代码会有 sloppy 现象，严格模式是为了让程序员避免 sloppy 模式。</strong></p>\n<p>为了形成与正常代码不同的语义，为此对正常的 JavaScript 语义做了一些更改<br>从而使代码隐式地脱离<code>“马虎模式/稀松模式/懒散模式“</code>（sloppy）模式</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li><code>浏览器支持程度不同：</code><ul>\n<li>不支持严格模式与支持严格模式的浏览器，在执行严格模式代码时会采用不同行为。</li>\n<li>不支持严格模式的浏览器，即使代码设置了严格模式，严格模式也不生效</li>\n</ul>\n</li>\n<li><code>代码可混合共存：</code>严格模式代码和非严格模式代码可以共存</li>\n</ul>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><ol>\n<li>严格模式（对过去）：通过抛出错误来消除了一些原有<code>静默错误</code>。</li>\n<li>严格模式（对过去）：修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。</li>\n<li>严格模式（对未来）：为未来的 ECMAScript 版本铺平道路,禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。</li>\n</ol>\n<h3 id=\"体现：\"><a href=\"#体现：\" class=\"headerlink\" title=\"体现：\"></a>体现：</h3><p><strong>将过失错误转成异常</strong></p>\n<ol>\n<li>严格模式下无法再意外创建全局变量</li>\n<li>在严格模式下，试图删除不可删除的属性时会抛出异常</li>\n<li>严格模式会使引起静默失败 (silently fail，注：不报错也没有任何效果) 的赋值操作抛出异常 如：<small>（给 NaN 赋值会抛出一个异常、给不可写属性赋值）</small></li>\n<li>Gecko 版本 34 之前，严格模式要求一个对象内的所有属性名在对象内必须唯一</li>\n<li>严格模式要求函数的参数名唯一</li>\n<li>严格模式禁止八进制数字语法（ECMAScript 并不包含八进制语法， ECMAScript 6 中支持为一个数字加”0o”的前缀来表示八进制数）</li>\n</ol>\n<p><strong>简化变量使用</strong></p>\n<ul>\n<li><p>在严格模式下 eval 仅仅为被运行的代码创建变量，所以 eval 不会使得名称映射到外部变量或者其他局部变量：</p>\n</li>\n<li><p>让 eval 和 arguments 变的简单</p>\n</li>\n</ul>\n<p><em>arguments</em></p>\n<p>名称 eval 和 arguments 不能通过程序语法被绑定 (be bound) 或赋值<br>严格模式下，参数的值不会随 arguments 对象的值的改变而变化<br>不再支持 arguments.callee</p>\n<p><strong>更安全（有性能&#x2F;安全问题的不予实现）</strong></p>\n<ol>\n<li><p>严格模式下，<code>通过 this 传递给一个函数的值不会被强制转换为一个对象</code>，对一个普通的函数来说，this 总会是一个对象，这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患</p>\n</li>\n<li><p>在严格模式下，<code>那么 fun.caller 和 fun.arguments </code>都是不可删除的属性而且在存值、取值时都会报错</p>\n</li>\n<li><p>严格模式下的 arguments 不会再提供访问与调用这个函数相关的变量的途径，旧时的 ECMAScript 实现中 arguments.caller 曾经是一个对象，里面存储的属性指向那个函数的变量，有安全隐患，还会有性能问题。现在的浏览器没有实现这个</p>\n</li>\n</ol>\n<h2 id=\"继承原型链\"><a href=\"#继承原型链\" class=\"headerlink\" title=\"继承原型链\"></a>继承原型链</h2><h3 id=\"new-做了什么\"><a href=\"#new-做了什么\" class=\"headerlink\" title=\"new 做了什么\"></a>new 做了什么</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#:~:text=Copy%20to%20Clipboard-,JavaScript%20%E5%AE%9E%E9%99%85%E4%B8%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E6%98%AF%EF%BC%9A,-var%20o%20%3D\" target=\"_blank\" >JavaScript 实际上执行的是：</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 这里并没有像很多面试题实现new那样，注意问题，new做了什么，而不是如何实现\nvar o &#x3D; new Object();\n&#x2F;&#x2F; 私有属性（称之为 __proto__）指向它的构造函数的原型对象（prototype\n&#x2F;&#x2F; 这里要注意下，实例对象的属性能不能改是配置决定，而不是是不是私有决定\no.__proto__ &#x3D; Foo.prototype;\nFoo.call(o);</code></pre>\n\n<h2 id=\"并发模型与事件循环\"><a href=\"#并发模型与事件循环\" class=\"headerlink\" title=\"并发模型与事件循环\"></a>并发模型与事件循环</h2><h2 id=\"为什么-js-是单线程\"><a href=\"#为什么-js-是单线程\" class=\"headerlink\" title=\"为什么 js 是单线程\"></a>为什么 js 是单线程</h2><p>这主要和 js 的用途有关，<em>js 是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作 dom</em> ；<br>这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>举个例子：如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，<br><em>此时浏览器就会一脸茫然，不知所措</em> 。所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，<br>这已经成了这门语言的核心特征，将来也不会改变。</p>\n<h2 id=\"进程、线程\"><a href=\"#进程、线程\" class=\"headerlink\" title=\"进程、线程\"></a>进程、线程</h2><p><strong>什么是进程:</strong><br><em>进程：</em>是 cpu 分配资源的最小单位；（是能拥有资源和独立运行的最小单位）</p>\n<p><strong>什么是线程:</strong><br><em>线程：</em>是 cpu 调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p>\n<p><strong>浏览器是多进程的？</strong><br>放在浏览器中，每打开一个 tab 页面，其实就是新开了一个进程，<br>在这个进程中，还有 <em>ui 渲染线程</em> 、 <em>js 引擎线程</em> 、 <em>http 请求线程</em>等。 所以，浏览器是一个多进程的。</p>\n<p><em>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准</em> ，允许 JavaScript 脚本创建多个线程，<br>但是<code>子线程完全受主线程控制</code>，且<code>不得操作 DOM</code>。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>\n<h2 id=\"宏微任务以及执行顺序\"><a href=\"#宏微任务以及执行顺序\" class=\"headerlink\" title=\"宏微任务以及执行顺序\"></a>宏微任务以及执行顺序</h2><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队。<br>1、<strong>宏任务:</strong> 用来保存待执行的宏任务（回调），比如：<code>定时器回调</code>、<code>DOM 事件回调</code>、<code>ajax 回调</code><br>2、<strong>微任务:</strong> 用来保存待执行的微任务（回调），比如：<code>promise 的回调</code>、<code>MutationObserver 的回调</code></p>\n<p>JS 执行时会区别这 2 个队列<br>1、JS 引擎首先必须先执行所有的初始化<em>同步任务代码</em><br>2、<em>每次在准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行</em> ，也就是微任务优先级比宏任务高，且与微任务所处的代码位置无关<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/124533748\">https://blog.csdn.net/weixin_47450807/article/details/124533748</a></p>\n<h2 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h2><p>参考答案:<br>暂时性死区的本质就是，只要一进入当前作用域，<em>所要使用的变量就已经存在了，但是不可获取</em> , <em>直到声明变量的那一行代码出现</em> , 才可以获取和使用该变量。</p>\n<p><strong>let 、const 与暂时性死区</strong><br>let 或 const 声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。</p>\n<p><strong>首先看看不具有暂时性死区的 var：</strong><br>当进入 var 变量的作用域（包围它的函数），<em>立即为它创建（绑定）存储空间。变量会立即被初始化并赋值为 undefined。</em><br>当执行到变量声明的时候，如果变量定义了值则会被赋值。</p>\n<p><strong>通过 let 声明的变量拥有暂时性死区，生命周期如下：</strong><br>当进入 let 变量的作用域（包围它的语法块），<em>立即为它创建（绑定）存储空间。此时变量仍是未初始化的。</em><br>获取或设置未初始化的变量将抛出异常 <code>ReferenceError</code>。<br>当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为 undefined。</p>\n<p>const 工作方式与 let 类似，<code>但是定义的时候必须赋值并且不能改变</code></p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>B 站：小甲鱼 鱼 C，讲闭包讲的很好</p>\n<p>闭包：不是 js 特有的，几乎所有的变成语言中，都存在闭包</p>\n<p>闭包包含自由（未绑定到特定对象）变量，这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在学过的编程语言中 js、oc、swift、android、kotlin、dart、golang、python 以及 Java（Java8 及以上）等语言中都能找到对闭包不同程度的支持。</p>\n<p><a href=\"https://baike.baidu.com/item/%E9%97%AD%E5%8C%85/10908873?fr=kg_general\" target=\"_blank\" >见百度百科</a></p>\n<h2 id=\"面向对象的三大特性，分别说一下什么意思\"><a href=\"#面向对象的三大特性，分别说一下什么意思\" class=\"headerlink\" title=\"面向对象的三大特性，分别说一下什么意思?\"></a>面向对象的三大特性，分别说一下什么意思?</h2><p>1、<em>封装:</em> 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。</p>\n<p>对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。</p>\n<p>2、<em>继承:</em> 继承可以解决代码复用，让编程更加靠近人类思维。</p>\n<p>当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p>\n<p>3、<em>多态:</em> 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：<em>多态是指通过指向父类的引用，来调用在不同子类中实现的方法。</em></p>\n<h2 id=\"Promise-和-async-await-的区别\"><a href=\"#Promise-和-async-await-的区别\" class=\"headerlink\" title=\"Promise 和 async await 的区别\"></a>Promise 和 async await 的区别</h2><p><strong>1、概念:</strong><br><strong>Promise</strong> 是异步编程的一种解决方案，比传统的解决方案——<em>回调函数</em>和<em>事件</em>——更合理和更强大</p>\n<p>简单地说，Promise 好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的。</p>\n<p><strong>async await</strong>也是异步编程的一种解决方案，他遵循的是 <em>Generator 函数的语法糖</em> ，他拥有<em>内置执行器</em> ，不需要额外的调用直接会自动执行并输出结果，它返回的是一个 Promise 对象。</p>\n<p><strong>两者的区别:</strong></p>\n<p><em>相同点</em></p>\n<ol>\n<li><em>async await 与 Promise 一样，是非阻塞的</em></li>\n</ol>\n<p><em>不同点</em></p>\n<ol>\n<li><p><em>版本不同:</em> promise 是 ES6，async&#x2F;await 是 ES7</p>\n</li>\n<li><p><em>背景不同:</em><br>2.1. <code> Promise 的出现是为了解决了传统 callback 函数导致的“地域回调”问题,</code>语法导致了它向纵向发展行成了一个<em>回调链</em>，遇到复杂的业务场景，这样的语法显然也是不美观的。</p>\n<br/>\n\n<p>2.2. <code> 而 async await 代码看起来会简洁些,使得异步代码看起来像同步代码,</code> await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</p>\n</li>\n<li><p><em>async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数</em></p>\n</li>\n<li><p>错误捕获 Promise 有<code>.catch</code>,async await 既可以用<code>.then</code> 又可以用 <code>try-catch</code> 捕捉</p>\n</li>\n</ol>\n<p>补充： <a href=\"/#/post/2022-10-19js表达式\" target=\"_blank\" >2022-10-19js 表达式</a></p>\n<h2 id=\"setTimeout-值打印\"><a href=\"#setTimeout-值打印\" class=\"headerlink\" title=\"setTimeout 值打印\"></a>setTimeout 值打印</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 输出 10个10\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(i);\n  &#125;, 100);\n&#125;\n\n&#x2F;&#x2F; 打印出0 - 9;\n\n&#x2F;&#x2F; var -&gt; let\nfor (let i &#x3D; 0; i &lt; 10; i++) &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(i);\n  &#125;, 100);\n&#125;\n&#x2F;&#x2F; 立即执行函数\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  (function (i) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(i);\n    &#125;, 100);\n  &#125;)(i);\n&#125;\n&#x2F;&#x2F; setTimeout传入参数的方式\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  setTimeout(\n    (n) &#x3D;&gt; &#123;\n      console.log(n);\n    &#125;,\n    100,\n    i\n  );\n&#125;</code></pre>\n\n<h2 id=\"立即执行函数有什么用，作用域是怎样的\"><a href=\"#立即执行函数有什么用，作用域是怎样的\" class=\"headerlink\" title=\"立即执行函数有什么用，作用域是怎样的\"></a>立即执行函数有什么用，作用域是怎样的</h2><p><strong>只有一个作用：创建一个独立的作用域。</strong></p>\n<p><em>这个作用域里面的变量，外面访问不到（即避免「变量污染」）。</em></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/22465092\" target=\"_blank\" >什么是立即执行函数？有什么作用？</a></p>\n<h2 id=\"默认类型转化？\"><a href=\"#默认类型转化？\" class=\"headerlink\" title=\"默认类型转化？\"></a>默认类型转化？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 打印出 1\nlet a &#x3D; ?\nif (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;\n  console.log(&#39;1&#39;)\n&#125;\n\nlet a &#x3D; &#123;\n  i: 1,\n  [Symbol.toPrimitive]() &#123;\n    return this.i++\n  &#125;\n&#125;\nif (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;\n  console.log(&#39;hhhhhh&#39;)\n&#125;\n\n</code></pre>\n\n<p><a href=\"/#/post/2022-11-01抽象相等比较\" style=\"color: #f07\" target=\"_blank\" >实现原理 2022-11-01 抽象相等比较</a></p>\n<h2 id=\"require-和-import-的区别？\"><a href=\"#require-和-import-的区别？\" class=\"headerlink\" title=\"require 和 import 的区别？\"></a>require 和 import 的区别？</h2><h3 id=\"遵循规范：\"><a href=\"#遵循规范：\" class=\"headerlink\" title=\"遵循规范：\"></a>遵循规范：</h3><p>require 是 Commonjs 规范引入方式<br>import 是 ES6 的一个语法标准，如果要兼容浏览器的话必须转化成 ES5 的语法</p>\n<h3 id=\"调用时间：\"><a href=\"#调用时间：\" class=\"headerlink\" title=\"调用时间：\"></a>调用时间：</h3><p>require 是运行时调用，所以 require 理论上可以运用在代码的任何地方<br>import 是编译时调用，所以必须放在文件开头</p>\n<h3 id=\"本质：\"><a href=\"#本质：\" class=\"headerlink\" title=\"本质：\"></a>本质：</h3><p><em>require 是赋值过程。</em> module.exports 后面的内容是什么，require 的结果就是什么，比如对象、数字、字符串、函数等，然后再把 require 的结果赋值给某个变量，它相当于 module.exports 的传送门</p>\n<p><em>import 是解构过程,</em> 但是目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require</p>\n<h3 id=\"导入导出\"><a href=\"#导入导出\" class=\"headerlink\" title=\"导入导出\"></a>导入导出</h3><p><em>require() | exports 的用法</em><br>通过 require 引入基础数据类型时，属于复制该变量。通过 require 引入复杂数据类型时，属于浅拷贝该对象。</p>\n<p><em>导入模块 require() 的用法</em><br>require() 函数用于在当前模块中加载别的模块。在函数内写入模块的路径即可（相对路径和绝对路径都行）</p>\n<p><code>exports</code> 是 module.exports 的一种简写形式，不能直接给 exports 赋值。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p><em>当直接给 module.exports 赋值时，exports 会失效。</em></p>\n<p><a href=\"https://blog.csdn.net/wwf1225/article/details/124150794\" target=\"_blank\" >见</a></p>\n<h2 id=\"src-和-href-的区别，并且-img-中的-srcset-的作用是什么\"><a href=\"#src-和-href-的区别，并且-img-中的-srcset-的作用是什么\" class=\"headerlink\" title=\"src 和 href 的区别，并且 img 中的 srcset 的作用是什么\"></a>src 和 href 的区别，并且 img 中的 srcset 的作用是什么</h2><h3 id=\"src-和-href-的区别\"><a href=\"#src-和-href-的区别\" class=\"headerlink\" title=\"src 和 href 的区别\"></a>src 和 href 的区别</h3><p><strong>总结：</strong></p>\n<ul>\n<li><code>资源</code>：src <code>会将资源加载到标签所在的位置</code>；href <code>用来建立与当前元素/文档之间的链接</code></li>\n<li><code>元素</code>：src <code>用于 js 脚本、img、frame 等标签</code>；href <code>用与 link、a 标签</code></li>\n<li><code>阻塞</code>：src <code>会暂停其他资源的下载和处理，一般放到底部</code>；link <code>会并行下载，不会阻塞</code></li>\n</ul>\n<p><em>src</em> 是指向外部资源的位置，</p>\n<ul>\n<li>指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，如 js 脚本，img 图⽚和 frame 等元素。</li>\n<li><code>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在底部⽽不是头部</code>。</li>\n</ul>\n<p><em>href</em> 是指网络资源所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。比如 link 标签。</p>\n<h3 id=\"知道-img-的-srcset-的作用是什么？\"><a href=\"#知道-img-的-srcset-的作用是什么？\" class=\"headerlink\" title=\"知道 img 的 srcset 的作用是什么？\"></a>知道 img 的 srcset 的作用是什么？</h3><p>可以设计响应式图片,我们可以使⽤两个新的属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择正确的⼀个资源。<br><code>srcset 定义了我们允许浏览器选择的图像集，以及每个图像的⼤⼩</code>。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;img\n  src&#x3D;&quot;.&#x2F;img&#x2F;1.jpg&quot;\n  srcset&#x3D;&quot;.&#x2F;img&#x2F;2.jpg 500w, .&#x2F;img&#x2F;3.jpg 1000w, .&#x2F;img&#x2F;4.jpg 1200w&quot;\n  sizes&#x3D;&quot;(max-width:500px) 600px, (max-width: 1000px) 1500px&quot;\n  alt&#x3D;&quot;&quot;\n&#x2F;&gt;\n&lt;!-- 这里size中max-width:500px表示最大为500px时,将其当做600px,然后和srcset进行匹配 --&gt;</code></pre>\n\n<p>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/124214601\">https://blog.csdn.net/weixin_47450807/article/details/124214601</a></p>\n<h3 id=\"还有哪⼀个标签能起到跟-srcset-相似作⽤？\"><a href=\"#还有哪⼀个标签能起到跟-srcset-相似作⽤？\" class=\"headerlink\" title=\"还有哪⼀个标签能起到跟 srcset 相似作⽤？\"></a>还有哪⼀个标签能起到跟 srcset 相似作⽤？</h3><p><code>&lt;picture&gt;</code>元素通过包含零或多个<code>&lt;source&gt;</code>元素和一个<code>&lt;img&gt;</code>元素来为不同的显示&#x2F;设备场景提供图像版本。</p>\n<p>浏览器会选择最匹配的⼦ <code>&lt;source&gt;</code> 元素，</p>\n<p>如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 src 属性中的 URL。</p>\n<p>然后，所选图像呈现在 <code>&lt;img&gt;</code> 元素占据的空间中。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;picture&gt;\n  &lt;source\n    srcset&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;surfer-240-200.jpg&quot;\n    media&#x3D;&quot;(min-width: 800px)&quot;\n  &#x2F;&gt;\n  &lt;img src&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;painted-hand-298-332.jpg&quot; &#x2F;&gt;\n&lt;&#x2F;picture&gt;</code></pre>\n\n<h2 id=\"存在哪些常用的-meta-标签？\"><a href=\"#存在哪些常用的-meta-标签？\" class=\"headerlink\" title=\"存在哪些常用的 meta 标签？\"></a>存在哪些常用的 meta 标签？</h2><p><a href=\"/#/post/2022-07-17html\" target=\"_blank\" >有哪些常⽤的 meta 标签？</a></p>\n<h2 id=\"客户端渲染-与-服务器渲染-的区别？\"><a href=\"#客户端渲染-与-服务器渲染-的区别？\" class=\"headerlink\" title=\"客户端渲染 与 服务器渲染 的区别？\"></a>客户端渲染 与 服务器渲染 的区别？</h2><p><strong>区分依据</strong></p>\n<p>DOM 树在服务端生成还是在客户端生成的。</p>\n<p><strong>服务端渲染的优点：</strong></p>\n<p>1、尽量不占用前端的资源，前端这块耗时少，速度快。</p>\n<p>2、有利于 SEO（search engine optimization）优化，因为在后端有完整的 html 页面，所以爬虫更容易爬取信息。</p>\n<p><strong>服务端渲染的缺点：</strong></p>\n<p>1、不利于前后端分离，开发的效率降低了。</p>\n<p>2、对 html 的解析，对前端来说加快了速度，但是加大了服务器的压力。</p>\n<p><strong>客户端渲染的优点：</strong></p>\n<p>1、前后端分离，开发效率高。</p>\n<p>2、用户体验更好，我们将网站做成 SPA（单页面应用）或者部分内容做成 SPA，当用户点击时，不会形成频繁的跳转。</p>\n<p><strong>客户端渲染的缺点：</strong></p>\n<p>1、首屏响应速度慢。</p>\n<p>2、不利于 SEO 优化，因为爬虫不认识 SPA，所以它只是记录了一个页面。</p>\n<p><strong>实际开发中</strong></p>\n<p><a href=\"https://blog.csdn.net/weixin_47450807/category_11593058.html\" target=\"_blank\" >见</a></p>\n<p><strong>如何选择</strong></p>\n<p>我们要根据业务场景去选择渲染的方式。</p>\n<p><strong>如果是企业级网站</strong>，主要功能是页面展示，它没有复杂的交互，并且需要良好的 SEO，那我们应该使用服务端渲染。</p>\n<p><strong>如果是后台管理页面</strong>，交互性很强，它不需要考虑到 SEO，那我们应该使用客户端渲染。</p>\n<p>具体使用哪种渲染方式也不是绝对的，<strong>现在很多网站使用服务端渲染和客户端渲染结合的方式</strong>：首屏使用服务端渲染，其他页面使用客户端渲染。这样可以保证首屏的加载速度，也完成了前后端分离。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.iamshuaidi.com/4997.html\" target=\"_blank\" > escape、encodeURI、encodeURIComponent 的区别</a></p>\n","text":"B 站爬取脚本var list &#x3D; document.getElementsByClassName(&quot;video-list&quot;)[0]; Array.from(list.children).forEach((item) &#x3D;&gt; &#123...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"js","slug":"js","count":1,"path":"api/categories/js.json"}],"tags":[{"name":"js","slug":"js","count":1,"path":"api/tags/js.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B-%E7%AB%99%E7%88%AC%E5%8F%96%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">B 站爬取脚本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js\"><span class=\"toc-text\">js</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#js-%E7%9A%84-typeof-%E8%BF%94%E5%9B%9E%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">js 的 typeof 返回哪些数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JS-%E4%B8%AD-this-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">JS 中 this 相关问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ajax%E3%80%81axios%E3%80%81fetch-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">ajax、axios、fetch 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">for…in 和 for…of 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#javascript-%E6%8F%90%E5%89%8D%E7%BB%88%E6%AD%A2%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">javascript 提前终止循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%9F\"><span class=\"toc-text\">如何判断一个对象是否属于某个类？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%88%E8%B0%88%E5%B0%BE%E8%B0%83%E7%94%A8%E5%8F%8A%E5%85%B6%E5%A5%BD%E5%A4%84%EF%BC%9F\"><span class=\"toc-text\">谈谈尾调用及其好处？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">好处</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#escape%E3%80%81encodeURI%E3%80%81encodeURIComponent-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">escape、encodeURI、encodeURIComponent 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#isNaN-%E5%92%8C-Number-isNaN-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">isNaN 和 Number.isNaN 函数的区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%A0%86%E5%8C%BA%E5%92%8C%E6%A0%88%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">说说你对堆区和栈区的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E8%AF%B4-Ajax-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">说说 Ajax 组成部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript-%E4%B8%AD-BOM-%E4%B8%8E-DOM-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">JavaScript 中 BOM 与 DOM 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">你是怎么理解闭包的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E4%B8%8B-JS-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">说下 JS 的基本数据类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#use-strict-%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">use strict 及其作用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%93%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">体现：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">继承原型链</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">new 做了什么</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">并发模型与事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-js-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">为什么 js 是单线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">进程、线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">宏微任务以及执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA\"><span class=\"toc-text\">暂时性死区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">面向对象的三大特性，分别说一下什么意思?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise-%E5%92%8C-async-await-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Promise 和 async await 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#setTimeout-%E5%80%BC%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">setTimeout 值打印</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">立即执行函数有什么用，作用域是怎样的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">默认类型转化？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#require-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">require 和 import 的区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%B5%E5%BE%AA%E8%A7%84%E8%8C%83%EF%BC%9A\"><span class=\"toc-text\">遵循规范：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E6%97%B6%E9%97%B4%EF%BC%9A\"><span class=\"toc-text\">调用时间：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E8%B4%A8%EF%BC%9A\"><span class=\"toc-text\">本质：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA\"><span class=\"toc-text\">导入导出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E4%B8%94-img-%E4%B8%AD%E7%9A%84-srcset-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">src 和 href 的区别，并且 img 中的 srcset 的作用是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">src 和 href 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9F%A5%E9%81%93-img-%E7%9A%84-srcset-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">知道 img 的 srcset 的作用是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%98%E6%9C%89%E5%93%AA%E2%BC%80%E4%B8%AA%E6%A0%87%E7%AD%BE%E8%83%BD%E8%B5%B7%E5%88%B0%E8%B7%9F-srcset-%E7%9B%B8%E4%BC%BC%E4%BD%9C%E2%BD%A4%EF%BC%9F\"><span class=\"toc-text\">还有哪⼀个标签能起到跟 srcset 相似作⽤？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84-meta-%E6%A0%87%E7%AD%BE%EF%BC%9F\"><span class=\"toc-text\">存在哪些常用的 meta 标签？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93-%E4%B8%8E-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">客户端渲染 与 服务器渲染 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Web api history","uid":"ef92ce33f7630db6de42bc09728ad0ae","slug":"2022-10-18history","date":"2022-10-18T08:36:43.000Z","updated":"2022-11-21T13:08:33.121Z","comments":true,"path":"api/articles/2022-10-18history.json","keywords":null,"cover":[],"text":"historyhttps://developer.mozilla.org/en-US/docs/Web/API/History replaceState 不刷新页面更改页面参数不刷新页面 用来存 hash 用来存页面查询参数 &#x2F;#&#x2F;post&#x2F;2022...","link":"","photos":[],"count_time":{"symbolsCount":325,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"gorm","uid":"9e2838a04929d964c7bc52054867739d","slug":"2022-10-16gorm","date":"2022-10-16T10:34:17.000Z","updated":"2022-12-22T13:36:21.789Z","comments":true,"path":"api/articles/2022-10-16gorm.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202212211225570.webp","text":"githubhttps://github.com/go-gorm/gorm ORM orm 解决的问题专注于语言，弱化 sql gorm 内部如何实现GORM 内部使用 SQL builder 生成 SQL。 对于每个操作，GORM 都会创建一个 *gorm.Statement ...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"Go","slug":"Go","count":19,"path":"api/categories/Go.json"}],"tags":[{"name":"Go","slug":"Go","count":19,"path":"api/tags/Go.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}