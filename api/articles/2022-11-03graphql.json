{"title":"Graphql","uid":"b629fbc3034174b0bda5cbb3b1a0e487","slug":"2022-11-03graphql","date":"2022-11-03T09:51:55.000Z","updated":"2022-11-04T12:06:31.430Z","comments":true,"path":"api/articles/2022-11-03graphql.json","keywords":null,"cover":[],"content":"<h1 id=\"文章背景\"><a href=\"#文章背景\" class=\"headerlink\" title=\"文章背景\"></a>文章背景</h1><p>中文官网废话太多，语句也有些不通顺的地方</p>\n<h1 id=\"Graphql-是什么\"><a href=\"#Graphql-是什么\" class=\"headerlink\" title=\"Graphql 是什么\"></a>Graphql 是什么</h1><p>GraphQL 全称叫 Graph Query Language，官方宣传语是“为你的 API 量身定制的查询语言”。</p>\n<p>用传统的方式来解释就是：相当于将你所有后端 API 组成的集合看成一个数据库，用户终端发送一个查询语句，你的 GraphQL 服务解析这条语句并通过一系列规则从你的“ API 数据库”里面将查询的数据结果返回给终端，而 GraphQL 就相当于这个系统的一个查询语言。</p>\n<p>作者：倩倩_a570<br>链接：<a href=\"https://www.jianshu.com/p/05e405eef8fa\">https://www.jianshu.com/p/05e405eef8fa</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p><strong>注意：GraphQL 不是数据库</strong></p>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时</p>\n<p>简单来说：提供了 schema 结构的数据，按照规则，填写相应的字段就可以获取到对应的字段内容，不多不少，刚刚好</p>\n<h2 id=\"在什么背景下提出的\"><a href=\"#在什么背景下提出的\" class=\"headerlink\" title=\"在什么背景下提出的\"></a>在什么背景下提出的</h2><p>GraphQL 在 rest 背景下提出</p>\n<p>REST API ：服务端决定有哪些数据返回，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理；而数据不能满足需求则需要请求更多的接口。以上就是我们常说的“过渡获取”和“欠缺获取”</p>\n<p>由于”过度”和”欠缺”的获取问题及其对客户端应用程序性能的影响，促进有效获取的 API 技术才有机会在市场上引起轰动 —— GraphQL 大胆地介入并填补了这一空白。</p>\n<p>作者：倩倩_a570<br>链接：<a href=\"https://www.jianshu.com/p/05e405eef8fa\">https://www.jianshu.com/p/05e405eef8fa</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>简单来说：相比较 Rest 风格来讲，GraphQL，相当于在 Rest 返回时候有选择的进行聚合字段进行返回</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>请求你所要的数据不多不少</li>\n<li>获取多个资源只用一个请求</li>\n<li>描述所有的可能类型系统</li>\n<li>更倾向于查询</li>\n</ul>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><h3 id=\"GitHub-GraphQL-API\"><a href=\"#GitHub-GraphQL-API\" class=\"headerlink\" title=\"GitHub GraphQL API\"></a>GitHub GraphQL API</h3><p><a href=\"https://docs.github.com/cn/graphql/overview/explorer\" target=\"_blank\" >https://docs.github.com/cn/graphql/overview/explorer</a></p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\"># 涉及到知识点如下：\n# 查询\n# 字段（Fields）\n# 参数（Arguments）\n# 别名（Aliases）\n# 操作名称（Operation Name）\n# 变量（Variables）\n# 指令（Directives）\n# 元字段（Meta fields）\nquery myquery(\n  $if: Boolean &#x3D; false\n  $withUpdateAt: Boolean!\n  $withUser: Boolean!\n) &#123;\n  viewer &#123;\n    __typename # 元字段 ，查看类型\n    uuid: id # 给id更改别名为uuid\n    status &#123;\n      __typename\n      createdAt @skip(if: $if) # $if变量为true的时候，不返回 createdAt\n      updatedAt @include(if: $withUpdateAt) # $withUpdateAt变量为false的时候，不返回 updatedAt\n      user @include(if: $withUser) &#123;\n        __typename\n        id\n        email\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"参数值\"><a href=\"#参数值\" class=\"headerlink\" title=\"参数值\"></a>参数值</h3><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;skipCreatedAt&quot;: false,\n  &quot;withUpdateAt&quot;: true,\n  &quot;withUser&quot;: true\n&#125;</code></pre>\n\n<h3 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h3><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;viewer&quot;: &#123;\n      &quot;__typename&quot;: &quot;User&quot;,\n      &quot;uuid&quot;: &quot;MDQ6VXNlcjE4MzA1MzYx&quot;,\n      &quot;status&quot;: &#123;\n        &quot;__typename&quot;: &quot;UserStatus&quot;,\n        &quot;createdAt&quot;: &quot;2019-01-11T14:57:43Z&quot;,\n        &quot;updatedAt&quot;: &quot;2019-09-24T08:56:23Z&quot;,\n        &quot;user&quot;: &#123;\n          &quot;__typename&quot;: &quot;User&quot;,\n          &quot;id&quot;: &quot;MDQ6VXNlcjE4MzA1MzYx&quot;,\n          &quot;email&quot;: &quot;&quot;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"schema\"><a href=\"#schema\" class=\"headerlink\" title=\"schema\"></a>schema</h2><p>GraphQL 查询语言基本上就是关于选择对象上的字段</p>\n<p>GraphQL 查询的结构和结果非常相似，因此即便不知道服务器的情况，你也能预测查询会返回什么结果</p>\n<h3 id=\"为什么引入-schema\"><a href=\"#为什么引入-schema\" class=\"headerlink\" title=\"为什么引入 schema?\"></a>为什么引入 schema?</h3><p>需要的数据的确切描述依然很有意义，我们能选择什么字段？服务器会返回哪种对象？这些对象下有哪些字段可用？</p>\n<p>GraphQL 服务都会定义一套类型，用以描述从那个服务查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询</p>\n<h3 id=\"对象类型和字段\"><a href=\"#对象类型和字段\" class=\"headerlink\" title=\"对象类型和字段\"></a>对象类型和字段</h3><p>GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段例如：</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\"># 嗯， 看上去有点像 golang 的结构体\ntype Character &#123;\n  name: String!\n  appearsIn: [Episode!]!\n&#125;</code></pre>\n\n<ul>\n<li><code>对象类型</code> 拥有一些字段的类型</li>\n<li><code>字段</code> 对象类型的次级选项</li>\n<li><code>标量</code> 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择</li>\n<li><code>非空</code> String!</li>\n<li><code>数组</code> [Episode!]</li>\n</ul>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">type Starship &#123;\n  id: ID!\n  name: String!\n  length(unit: LengthUnit &#x3D; METER): Float\n&#125;</code></pre>\n\n<p>在 GraphQL 中，所有参数必须具名传递</p>\n<p>参数可能是必选或者可选的，当一个参数是可选的，我们可以定义一个默认值 —— 如果 unit 参数没有传递，那么它将会被默认设置为 METER</p>\n<p><strong>要么可选，要么必选，可选的必须有默认值！</strong></p>\n<h3 id=\"查询和变更类型\"><a href=\"#查询和变更类型\" class=\"headerlink\" title=\"查询和变更类型\"></a>查询和变更类型</h3><p>schema 中大部分是普通对象类型，schema 内有两个特殊类型：</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">schema &#123;\n  query: Query\n  mutation: Mutation\n&#125;</code></pre>\n\n<p>例如：</p>\n<p>服务端：schema</p>\n<pre class=\"line-numbers language-schema\" data-language=\"schema\"><code class=\"language-schema\">type Query &#123;\n  hero(episode: Episode): Character\n  droid(id: ID!): Droid\n&#125;</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">query &#123;\n  hero &#123;\n    name\n  &#125;\n  droid(id: &quot;2000&quot;) &#123;\n    name\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"标量类型\"><a href=\"#标量类型\" class=\"headerlink\" title=\"标量类型\"></a>标量类型</h3><p>标量类型的来源：表示 GraphQL 查询的叶子节点</p>\n<h4 id=\"默认标量类型\"><a href=\"#默认标量类型\" class=\"headerlink\" title=\"默认标量类型\"></a>默认标量类型</h4><p>GraphQL 默认标量类型：</p>\n<ul>\n<li><code>Int</code>：有符号 32 位整数。</li>\n<li><code>Float</code>：有符号双精度浮点值。</li>\n<li><code>String</code>：UTF‐8 字符序列。</li>\n<li><code>Boolean</code>：true 或者 false。</li>\n<li><code>ID</code>：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li>\n</ul>\n<h4 id=\"自定义标量类型\"><a href=\"#自定义标量类型\" class=\"headerlink\" title=\"自定义标量类型\"></a>自定义标量类型</h4><p>例如，我们可以定义一个 Date 类型：</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">scalar Date</code></pre>\n\n<p>然后就取决于我们的实现中如何定义将其序列化、反序列化和验证</p>\n<h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><p>枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">enum Episode &#123;\n  NEWHOPE\n  EMPIRE\n  JEDI\n&#125;</code></pre>\n\n<p>无论在 schema 的哪处 使用了 Episode，都可以肯定它返回的是 NEWHOPE、EMPIRE 和 JEDI 之一。</p>\n<h3 id=\"列表和非空\"><a href=\"#列表和非空\" class=\"headerlink\" title=\"列表和非空\"></a>列表和非空</h3><p>类型修饰符</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">type Character &#123;\n  name: String! # 英文!表示非空\n  appearsIn: [Episode]! # 在 GraphQL schema 语言中，我们通过将类型包在方括号中来标记列表\n&#125;</code></pre>\n\n<p>非空和列表修饰符可以组合使用。例如你可以要求一个非空字符串的数组：<br>这表示数组本身可以为空，但是其不能有任何空值成员。用 JSON 举例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">myField: null &#x2F;&#x2F; 有效\nmyField: [] &#x2F;&#x2F; 有效\nmyField: [&#39;a&#39;, &#39;b&#39;] &#x2F;&#x2F; 有效\nmyField: [&#39;a&#39;, null, &#39;b&#39;] &#x2F;&#x2F; 错误\n</code></pre>\n\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>接口是一个<code>抽象类型</code>，它包含某些字段，<code>对象类型</code>必须包含这些字段，才能算实现了这个接口</p>\n<p>与 typescript 不同的是这里的<code>implements</code>关键字来实现接口，把接口字段<code>又</code>罗列了一遍</p>\n<p><strong>接口</strong></p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">interface Character &#123; # 接口interface定义\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n&#125;</code></pre>\n\n<p><strong>实现了 Character 的类型：</strong></p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\"># 实现接口\ntype Human implements Character &#123;\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n\n  starships: [Starship]\n  totalCredits: Int\n&#125;\n# 实现接口\ntype Droid implements Character &#123;\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n\n  primaryFunction: String\n&#125;\n\n# 引入了其他的字段 totalCredits、starships 和 primaryFunction，这都属于特定的类型的角色</code></pre>\n\n<p><strong>如果要查询一个只存在于特定对象类型上的字段，你需要使用内联片段：</strong></p>\n<p><strong>查询语句</strong></p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">query HeroForEpisode($ep: Episode!) &#123;\n  hero(episode: $ep) &#123;\n    name\n    ... on Droid &#123;\n      primaryFunction\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p><strong>参数：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  &quot;ep&quot;: &quot;JEDI&quot;\n&#125;</code></pre>\n\n<p><strong>返回：</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;hero&quot;: &#123;\n      &quot;name&quot;: &quot;R2-D2&quot;,\n      &quot;primaryFunction&quot;: &quot;Astromech&quot;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\"># 与typescript 的联合类型相似\nunion SearchResult &#x3D; Human | Droid | Starship</code></pre>\n\n<p><strong>注意</strong>，联合类型的成员需要是具体对象类型；<code>不能使用接口</code>或者<code>其他联合类型</code>来创造一个联合类型。</p>\n<p>由于 Human 和 Droid 共享一个公共接口（Character），你可以在一个地方查询它们的公共字段，而不必在多个类型中重复相同的字段：</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  search(text: &quot;an&quot;) &#123;\n    __typename\n    ... on Character &#123;\n      # 使用了接口\n      name\n    &#125;\n    ... on Human &#123;\n      height\n    &#125;\n    ... on Droid &#123;\n      primaryFunction\n    &#125;\n    ... on Starship &#123;\n      name #Starship不是接口，要获取类型，还是要作为对象属性来写\n      length\n    &#125;\n  &#125;\n&#125;\n# 这里的Starship 是上文的对象类型\n# type Starship &#123;\n#   id: ID!\n#   name: String!\n#   length(unit: LengthUnit &#x3D; METER): Float\n# &#125;</code></pre>\n\n<h3 id=\"输入类型\"><a href=\"#输入类型\" class=\"headerlink\" title=\"输入类型\"></a>输入类型</h3><p>枚举和字符串等标量值作为参数传递给字段，也能很容易地传递复杂对象。这在变更（mutation）中特别有用，因为有时候你需要传递一整个对象作为新建对象。</p>\n<p>输入对象看上去和常规对象一模一样，除了关键字是 <code>input</code> 而不是 <code>type</code>:</p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">input ReviewInput &#123;\n  stars: Int!\n  commentary: String\n&#125;</code></pre>\n\n<h4 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h4><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\"># $review为参数对象\nmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;\n  createReview(episode: $ep, review: $review) &#123;\n    stars\n    commentary\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h4><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;ep&quot;: &quot;JEDI&quot;,\n  &quot;review&quot;: &#123;\n    &quot;stars&quot;: 5,\n    &quot;commentary&quot;: &quot;This is a great movie!&quot;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"结果-1\"><a href=\"#结果-1\" class=\"headerlink\" title=\"结果\"></a>结果</h4><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;createReview&quot;: &#123;\n      &quot;stars&quot;: 5,\n      &quot;commentary&quot;: &quot;This is a great movie!&quot;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"验证（规则限制）\"><a href=\"#验证（规则限制）\" class=\"headerlink\" title=\"验证（规则限制）\"></a>验证（规则限制）</h2><p>什么是验证？谁来验证？</p>\n<p>通过使用类型系统，你可以预判一个查询是否有效。这让服务器和客户端可以在无效查询创建时就有效地通知开发者，而不用依赖运行时检查。</p>\n<p><strong>助解：</strong></p>\n<ol>\n<li>有问题，提示，不执行查询，有点像浏览器 Option 预检的味道；好像不是 typescript 那种静态校验</li>\n<li>类型系统来校验</li>\n<li>这部分内容，更像是使用限制，你不能这么干，你要那么干</li>\n</ol>\n<h3 id=\"死循环\"><a href=\"#死循环\" class=\"headerlink\" title=\"死循环\"></a>死循环</h3><p><strong>有个问题：如果是树状结构的组织架构，咋整了？组织架构是递归结构</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/202211041022372.webp\" />\n\n<h3 id=\"对象类型不存在的字段\"><a href=\"#对象类型不存在的字段\" class=\"headerlink\" title=\"对象类型不存在的字段\"></a>对象类型不存在的字段</h3><img src=\"http://t-blog-images.aijs.top/img/202211041023087.webp\" />\n\n<h3 id=\"返回的不是标量-x2F-枚举类型\"><a href=\"#返回的不是标量-x2F-枚举类型\" class=\"headerlink\" title=\"返回的不是标量&#x2F;枚举类型\"></a>返回的不是标量&#x2F;枚举类型</h3><img src=\"http://t-blog-images.aijs.top/img/202211041026559.webp\" />\n\n<h3 id=\"特定类型的特定字段\"><a href=\"#特定类型的特定字段\" class=\"headerlink\" title=\"特定类型的特定字段\"></a>特定类型的特定字段</h3><p>如果对应的 Character 是 Droid，我们希望获取 primaryFunction 字段，而在其他情况下，则忽略此字段。我们可以使用之前引入的“片段”来解决这个问题。先在 Droid 上定义一个片段，然后在查询中引入它，这样我们就能在定义了 primaryFunction 的地方查询它</p>\n<h4 id=\"错误示范\"><a href=\"#错误示范\" class=\"headerlink\" title=\"错误示范\"></a>错误示范</h4><img src=\"http://t-blog-images.aijs.top/img/202211041029172.webp\" />\n\n<h4 id=\"具名片段\"><a href=\"#具名片段\" class=\"headerlink\" title=\"具名片段\"></a>具名片段</h4><img src=\"http://t-blog-images.aijs.top/img/202211041029675.webp\" />\n\n<h4 id=\"匿名片段\"><a href=\"#匿名片段\" class=\"headerlink\" title=\"匿名片段\"></a>匿名片段</h4><img src=\"http://t-blog-images.aijs.top/img/202211041030465.webp\" />\n\n<h3 id=\"更多内容\"><a href=\"#更多内容\" class=\"headerlink\" title=\"更多内容\"></a>更多内容</h3><p><a href=\"https://github.com/graphql/graphql-js/blob/master/src/validation\" target=\"_blank\" >GraphQL.js 的 validation 目录包含了规范兼容的 GraphQL 验证器实现代码。</a></p>\n<h2 id=\"执行\"><a href=\"#执行\" class=\"headerlink\" title=\"执行\"></a>执行</h2><p>一个 GraphQL 查询在被验证后，GraphQL 服务器会将之执行，并返回与请求的结构相对应的结果，该结果通常会是 JSON 的格式。</p>\n<h3 id=\"一个查询请求被执行的全过程\"><a href=\"#一个查询请求被执行的全过程\" class=\"headerlink\" title=\"一个查询请求被执行的全过程\"></a>一个查询请求被执行的全过程</h3><p>GraphQL 查询中的每个字段视为返回子类型的父类型函数或方法。<br>事实上，这正是 GraphQL 的工作原理。</p>\n<ul>\n<li><p>每个类型的每个字段都由一个 resolver 函数支持，该函数由 GraphQL 服务器开发人员提供。</p>\n</li>\n<li><p>当一个字段被执行时，相应的 resolver 被调用以产生下一个值。</p>\n</li>\n<li><p>如果字段产生标量值，例如字符串或数字，则执行完成。</p>\n</li>\n<li><p>如果一个字段产生一个对象，则该查询将继续执行该对象对应字段的解析器，直到生成标量值。</p>\n</li>\n<li><p>GraphQL 查询始终以标量值结束。</p>\n</li>\n</ul>\n<h3 id=\"根字段-amp-解析器\"><a href=\"#根字段-amp-解析器\" class=\"headerlink\" title=\"根字段 &amp; 解析器#\"></a>根字段 &amp; 解析器#</h3><ul>\n<li>Root 类型或 Query 类型 代表着所有进入 GraphQL API 可能的入口点</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Query: &#123;\n  human(obj, args, context, info) &#123;\n    return context.db.loadHumanByID(args.id).then(\n      userData &#x3D;&gt; new Human(userData)\n    )\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li><code>obj</code> 上一级对象，如果字段属于根节点查询类型通常不会被使用。</li>\n<li><code>args</code> 可以提供在 GraphQL 查询中传入的参数。</li>\n<li><code>context</code> 会被提供给所有解析器，并且持有重要的上下文信息比如当前登入的用户或者数据库访问对象。</li>\n<li><code>info</code> 一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值</li>\n</ul>\n<h3 id=\"异步解析器\"><a href=\"#异步解析器\" class=\"headerlink\" title=\"异步解析器\"></a>异步解析器</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">human(obj, args, context, info) &#123;\n  return context.db.loadHumanByID(args.id).then(\n    userData &#x3D;&gt; new Human(userData)\n  )\n&#125;</code></pre>\n\n<ul>\n<li><code>context</code> 提供了一个数据库访问对象，用来通过查询中传递的参数 id 来查询数据，因为从数据库拉取数据的过程是一个异步操作，该方法返回了一个 Promise 对象，在 JavaScript 语言中 Promise 对象用来处理异步操作，但在许多语言中存在相同的概念，通常称作 Futures、Tasks 或者 Defferred。</li>\n<li>当数据库返回查询结果，我们就能构造并返回一个新的 Human 对象。</li>\n<li>等返回：这里要注意的是，只有解析器能感知到 Promise 的进度，GraphQL 查询只关注一个包含着 name 属性的 human 字段是否返回，在执行期间如果异步操作没有完成，则 GraphQL 会一直等待下去，因此在这个环节需要关注异步处理上的优化。</li>\n</ul>\n<h3 id=\"不重要的解析器\"><a href=\"#不重要的解析器\" class=\"headerlink\" title=\"不重要的解析器\"></a>不重要的解析器</h3><h3 id=\"标量强制\"><a href=\"#标量强制\" class=\"headerlink\" title=\"标量强制\"></a>标量强制</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  human(id: 1002) &#123;\n    name      # 先处理name\n    appearsIn # appearsIn,starships同步执行， appearsIn 是枚举类型\n    starships &#123;\n      name\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>appearsIn 字段，因为类型系统已经被设定，所以解析器函数的返回值必须符合与类型系统对应的 API 规则的约束</p>\n<h3 id=\"列表解析器\"><a href=\"#列表解析器\" class=\"headerlink\" title=\"列表解析器\"></a>列表解析器</h3><p>返回一个 Promises 列表，并发执行这些 Promise，当执行结束返回一个对象列表后，它将继续并发加载列表中每个对象的 name 字段。</p>\n<h3 id=\"产生结果\"><a href=\"#产生结果\" class=\"headerlink\" title=\"产生结果\"></a>产生结果</h3><p>当每个字段被解析时，结果被放置到键值映射中，字段名称（或别名）作为键值映射的键，解析器的值作为键值映射的值。<br>这个过程从查询字段的底部叶子节点开始返回，直到根 Query 类型的起始节点。（为什么这么设计？）<br>最后合并成为能够镜像到原始查询结构的结果，然后可以将其发送（通常为 JSON 格式）到请求的客户端。</p>\n<h2 id=\"自省\"><a href=\"#自省\" class=\"headerlink\" title=\"自省\"></a>自省</h2><p>有时候会需要去问 <code>GraphQL Schema</code> 它支持哪些查询。GraphQL 通过内省系统让我们可以做到这点！</p>\n<p>助解：这个与 <code>elastic</code> 有点类似了，我们在不晓得有哪些东西的时候，自省<code>关键字</code>语句，就会给提示，这个对象有哪些东西</p>\n<h3 id=\"语句-1\"><a href=\"#语句-1\" class=\"headerlink\" title=\"语句\"></a>语句</h3><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  __schema &#123;\n    types &#123;\n      name\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"返回\"><a href=\"#返回\" class=\"headerlink\" title=\"返回\"></a>返回</h3><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;__schema&quot;: &#123;\n      &quot;types&quot;: [\n        &#123;\n          &quot;name&quot;: &quot;Query&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;String&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;ID&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Mutation&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Episode&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Character&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Int&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;LengthUnit&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Human&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Float&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Droid&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;FriendsConnection&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;FriendsEdge&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;PageInfo&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Boolean&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Review&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;ReviewInput&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Starship&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;SearchResult&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Schema&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Type&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__TypeKind&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Field&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__InputValue&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__EnumValue&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Directive&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__DirectiveLocation&quot;\n        &#125;\n      ]\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p>有好多类型！它们都是什么？我们来总结一下：</p>\n<ul>\n<li><code>Query</code>, <code>Character</code>, <code>Human</code>, <code>Episode</code>, <code>Droid</code> - 这些是我们在类型系统中定义的类型。<code>对象类型</code></li>\n<li><code>String</code>, <code>Boolean</code> - 这些是内建的标量，由类型系统提供。</li>\n<li><code>__Schema</code>, <code>__Type</code>, <code>__TypeKind</code>, <code>__Field</code>, <code>__InputValue</code>, <code>__EnumValue</code>, <code>__Directive</code> - 这些有着两个下划线的类型是内省系统的一部分。</li>\n</ul>\n<p>这里有点要注意的是：<code>__TypeKind</code>, <code>__Field</code>, <code>__InputValue</code>, <code>__EnumValue</code>, <code>__Directive</code> ,这些是 <code>__Type</code> 与 kind、field 等的组合</p>\n<p>现在，来试试找到一个可以探索出有哪些可用查询的地方。</p>\n<p>当我们设计类型系统的时候，我们<code>确定了一个所有查询开始的地方，来问问内省系统它是什么！</code></p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  __schema &#123;\n    queryType &#123;\n      name\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;__schema&quot;: &#123;\n      &quot;queryType&quot;: &#123;\n        &quot;name&quot;: &quot;Query&quot;\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"类型-type\"><a href=\"#类型-type\" class=\"headerlink\" title=\"类型 __type\"></a>类型 <code>__type</code></h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n  &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h4><p><strong>例 1</strong></p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    kind # 是一个接口还是一个对象？\n  &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;,\n      &quot;kind&quot;: &quot;OBJECT&quot;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p><strong>例 2</strong></p>\n<pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  __type(name: &quot;Character&quot;) &#123;\n    name\n    kind # 这里\n  &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Character&quot;,\n      &quot;kind&quot;: &quot;INTERFACE&quot; # 它是一个接口\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"对象的字段\"><a href=\"#对象的字段\" class=\"headerlink\" title=\"对象的字段\"></a>对象的字段</h4><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    # 这里\n    fields &#123;\n      name\n      type &#123;\n        name\n        kind\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;,\n      &quot;fields&quot;: [\n        &#123;\n          &quot;name&quot;: &quot;id&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;name&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;friends&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;LIST&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;friendsConnection&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;appearsIn&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;primaryFunction&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: &quot;String&quot;,\n            &quot;kind&quot;: &quot;SCALAR&quot;\n          &#125;\n        &#125;\n      ]\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"查看包装类型-ofType\"><a href=\"#查看包装类型-ofType\" class=\"headerlink\" title=\"查看包装类型 ofType\"></a>查看包装类型 ofType</h4><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    fields &#123;\n      name\n      type &#123;\n        name\n        kind\n        # 这里\n        ofType &#123;\n          name\n          kind\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"文档描述-description\"><a href=\"#文档描述-description\" class=\"headerlink\" title=\"文档描述 description\"></a>文档描述 description</h4><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    description #这里\n  &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;,\n      &quot;description&quot;: &quot;An autonomous mechanical character in the Star Wars universe&quot;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h2><h3 id=\"复数\"><a href=\"#复数\" class=\"headerlink\" title=\"复数\"></a>复数</h3><p>复数类型字段对应的数据</p>\n<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  hero &#123;\n    name\n    friends(first: 2) &#123;\n      # 前两个\n      name\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"分页和边\"><a href=\"#分页和边\" class=\"headerlink\" title=\"分页和边\"></a>分页和边</h3><p>我们可以像这样 friends(first:2 offset:2) 来请求列表中接下来的两个结果。 &#x2F;&#x2F; 跳过 2 个，取 2 个<br>我们可以像这样 friends(first:2 after:$friendId), 来请求我们上一次获取到的最后一个朋友之后的两个结果。&#x2F;&#x2F; 在某个id对应的数据之后取2个<br>我们可以像这样 friends(first:2 after:$friendCursor), 从最后一项中获取一个游标并使用它来分页。 &#x2F;&#x2F; 在某个游标之后取 2 个</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"完整链接模式\"><a href=\"#完整链接模式\" class=\"headerlink\" title=\"完整链接模式\"></a>完整链接模式</h3><pre class=\"line-numbers language-graphql\" data-language=\"graphql\"><code class=\"language-graphql\">&#123;\n  hero &#123;\n    name\n    friendsConnection(first: 2, after: &quot;Y3Vyc29yMQ&#x3D;&#x3D;&quot;) &#123;\n      totalCount\n      edges &#123;\n        node &#123;\n          name\n        &#125;\n        cursor\n      &#125;\n      pageInfo &#123;\n        # 列表的结尾、计数及连接，晓得什么时候结束\n        endCursor\n        hasNextPage\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;data&quot;: &#123;\n    &quot;hero&quot;: &#123;\n      &quot;name&quot;: &quot;R2-D2&quot;,\n      &quot;friendsConnection&quot;: &#123;\n        &quot;totalCount&quot;: 3,\n        &quot;edges&quot;: [\n          &#123;\n            &quot;node&quot;: &#123;\n              &quot;name&quot;: &quot;Han Solo&quot;\n            &#125;,\n            &quot;cursor&quot;: &quot;Y3Vyc29yMg&#x3D;&#x3D;&quot;\n          &#125;,\n          &#123;\n            &quot;node&quot;: &#123;\n              &quot;name&quot;: &quot;Leia Organa&quot;\n            &#125;,\n            &quot;cursor&quot;: &quot;Y3Vyc29yMw&#x3D;&#x3D;&quot;\n          &#125;\n        ],\n        &quot;pageInfo&quot;: &#123;\n          &quot;endCursor&quot;: &quot;Y3Vyc29yMw&#x3D;&#x3D;&quot;,\n          &quot;hasNextPage&quot;: false\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n","text":"文章背景中文官网废话太多，语句也有些不通顺的地方 Graphql 是什么GraphQL 全称叫 Graph Query Language，官方宣传语是“为你的 API 量身定制的查询语言”。 用传统的方式来解释就是：相当于将你所有后端 API 组成的集合看成一个数据库，用户终端发...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Graphql","slug":"Graphql","count":1,"path":"api/categories/Graphql.json"}],"tags":[{"name":"Graphql","slug":"Graphql","count":1,"path":"api/tags/Graphql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%87%E7%AB%A0%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">文章背景</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Graphql-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">Graphql 是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E4%BB%80%E4%B9%88%E8%83%8C%E6%99%AF%E4%B8%8B%E6%8F%90%E5%87%BA%E7%9A%84\"><span class=\"toc-text\">在什么背景下提出的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">特点：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">查询</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GitHub-GraphQL-API\"><span class=\"toc-text\">GitHub GraphQL API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E5%80%BC\"><span class=\"toc-text\">参数值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#schema\"><span class=\"toc-text\">schema</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5-schema\"><span class=\"toc-text\">为什么引入 schema?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">对象类型和字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%8F%98%E6%9B%B4%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">查询和变更类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">标量类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">默认标量类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">自定义标量类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">枚举类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E5%92%8C%E9%9D%9E%E7%A9%BA\"><span class=\"toc-text\">列表和非空</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">联合类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">输入类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">语句</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0-1\"><span class=\"toc-text\">参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">结果</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81%EF%BC%88%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6%EF%BC%89\"><span class=\"toc-text\">验证（规则限制）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">死循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">对象类型不存在的字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E7%9A%84%E4%B8%8D%E6%98%AF%E6%A0%87%E9%87%8F-x2F-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">返回的不是标量&#x2F;枚举类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">特定类型的特定字段</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E7%A4%BA%E8%8C%83\"><span class=\"toc-text\">错误示范</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B7%E5%90%8D%E7%89%87%E6%AE%B5\"><span class=\"toc-text\">具名片段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E7%89%87%E6%AE%B5\"><span class=\"toc-text\">匿名片段</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">更多内容</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">一个查询请求被执行的全过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E5%AD%97%E6%AE%B5-amp-%E8%A7%A3%E6%9E%90%E5%99%A8\"><span class=\"toc-text\">根字段 &amp; 解析器#</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E8%A7%A3%E6%9E%90%E5%99%A8\"><span class=\"toc-text\">异步解析器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E9%87%8D%E8%A6%81%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8\"><span class=\"toc-text\">不重要的解析器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E9%87%8F%E5%BC%BA%E5%88%B6\"><span class=\"toc-text\">标量强制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%99%A8\"><span class=\"toc-text\">列表解析器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">产生结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E7%9C%81\"><span class=\"toc-text\">自省</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E5%8F%A5-1\"><span class=\"toc-text\">语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">返回</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B-type\"><span class=\"toc-text\">类型 __type</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">种类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">对象的字段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B-ofType\"><span class=\"toc-text\">查看包装类型 ofType</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%A1%A3%E6%8F%8F%E8%BF%B0-description\"><span class=\"toc-text\">文档描述 description</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">分页</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%95%B0\"><span class=\"toc-text\">复数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87\"><span class=\"toc-text\">切片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%A1%B5%E5%92%8C%E8%BE%B9\"><span class=\"toc-text\">分页和边</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">完整链接模式</span></a></li></ol></li></ol></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis 命令及分区","uid":"66c41c8c78c6433d94dadc3b731a3d3d","slug":"2022-11-04redis","date":"2022-11-04T09:09:30.000Z","updated":"2023-03-07T14:09:36.378Z","comments":true,"path":"api/articles/2022-11-04redis.json","keywords":null,"cover":[],"text":"爬取脚本var data &#x3D; &quot;&quot;; Array.from(document.getElementsByClassName(&quot;left&quot;)[0].children[1].children).forEach((li) &#x3D;&...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"Redis","slug":"Redis","count":1,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"pdf 添加水印并下载","uid":"005b684f59380abe36489fcebc43072f","slug":"2022-11-02pdf-watermark","date":"2022-11-02T03:37:47.000Z","updated":"2022-11-02T12:30:25.268Z","comments":true,"path":"api/articles/2022-11-02pdf-watermark.json","keywords":null,"cover":[],"text":"页面渲染React-PDF + Canvas 实现预览水印效果 需求变更用户下载 pdf 也要加载水印 方案 方案 1. 后端 在 pdf 上传时候水印 方案 2. 后端 pdf 增加水印 方案 3. 前端在文件上传时候增加水印 方案 4. 前端在文件下载的时候增加水印 现在场景...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"PDF","slug":"PDF","count":1,"path":"api/categories/PDF.json"}],"tags":[{"name":"PDF","slug":"PDF","count":1,"path":"api/tags/PDF.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}