{"title":"虚拟列表（没想好怎么写）","uid":"7c8d110856dc8b871f4c54e1b5f1f295","slug":"2023-05-09vr-list","date":"2023-05-09T02:23:25.000Z","updated":"2023-05-15T13:17:33.008Z","comments":true,"path":"api/articles/2023-05-09vr-list.json","keywords":null,"cover":[],"content":"<h1 id=\"虚拟列表原理\"><a href=\"#虚拟列表原理\" class=\"headerlink\" title=\"虚拟列表原理\"></a>虚拟列表原理</h1><h2 id=\"虚拟列表实现原理\"><a href=\"#虚拟列表实现原理\" class=\"headerlink\" title=\"虚拟列表实现原理\"></a>虚拟列表实现原理</h2><p>虚拟列表（Virtual List）是一种常见的前端性能优化技术，用于解决渲染大量数据时，DOM 元素过多导致页面卡顿的问题。<br>虚拟列表通过只渲染当前可见区域的 DOM 元素，来减少页面渲染的负担，从而提高页面性能。</p>\n<p>虚拟列表的实现原理一般分为以下几步：</p>\n<ol>\n<li><p>计算可视区域的大小和位置。虚拟列表需要根据当前容器的大小和滚动位置，计算出可视区域的大小和位置，以便后续渲染和定位列表项。</p>\n</li>\n<li><p>计算列表项的尺寸。虚拟列表需要根据数据源和样式信息，计算出每个列表项的高度或宽度，以便后续计算容器的滚动范围和渲染列表项。</p>\n</li>\n<li><p>渲染可视区域的列表项。虚拟列表根据当前可视区域的位置和大小，计算出需要渲染的列表项的索引范围，然后仅渲染这些列表项的 DOM 元素，将它们插入到容器中。</p>\n</li>\n<li><p>更新列表项的内容。虚拟列表需要根据数据源的变化，更新已经渲染的列表项的内容，以保证列表项的正确性。</p>\n</li>\n<li><p>处理容器的滚动事件。虚拟列表需要监听容器的滚动事件，根据滚动的位置和方向，重新计算可视区域的位置和大小，从而实现列表项的滚动效果。</p>\n</li>\n</ol>\n<p>总之，虚拟列表的实现原理是通过计算可视区域和列表项的尺寸，以及渲染可视区域的列表项等步骤，来实现只渲染当前可见区域的 DOM 元素，从而减少页面渲染的负担，提高页面性能。</p>\n<h2 id=\"优化虚拟列表\"><a href=\"#优化虚拟列表\" class=\"headerlink\" title=\"优化虚拟列表\"></a>优化虚拟列表</h2><p>优化虚拟列表的性能可以从以下几个方面入手：</p>\n<ol>\n<li>减少 DOM 操作次数</li>\n</ol>\n<p>在虚拟列表中，DOM 操作是性能瓶颈之一。为了减少 DOM 操作的次数，可以使用文档片段（document fragment）来批量操作 DOM 元素，从而减少对页面的渲染次数。具体来说，可以在循环中使用文档片段来创建元素，并在创建完成后一次性将文档片段添加到容器中。</p>\n<ol start=\"2\">\n<li>使用 debounce 和 throttle 控制滚动事件</li>\n</ol>\n<p>滚动事件是虚拟列表中另一个性能瓶颈。为了减少滚动事件的触发次数，可以使用 debounce 和 throttle 函数来控制滚动事件的触发。debounce 函数可以延迟滚动事件的触发时间，从而减少事件的触发次数；throttle 函数可以控制滚动事件的触发频率，从而减少事件的触发次数。</p>\n<ol start=\"3\">\n<li>使用 requestAnimationFrame</li>\n</ol>\n<p>使用 requestAnimationFrame 可以将滚动事件的处理移到浏览器的下一帧中，从而减少事件的触发次数，提高页面的性能和响应速度。</p>\n<ol start=\"4\">\n<li>使用缓存机制</li>\n</ol>\n<p>在虚拟列表中，可以使用缓存机制来提高性能。具体来说，可以缓存已经渲染的元素，以避免重复渲染，从而提高渲染速度。可以使用一个对象来保存已经渲染的元素，并在渲染新元素时先检查是否已经存在缓存中。如果已经存在，就可以直接从缓存中取出元素，避免重复渲染。</p>\n<ol start=\"5\">\n<li>使用懒加载</li>\n</ol>\n<p>懒加载可以将元素的加载延迟到真正需要的时候再进行，从而减少页面的加载时间。在虚拟列表中，可以使用懒加载来延迟元素的加载，从而提高页面的性能和响应速度。具体来说，可以在滚动时判断当前元素是否需要加载，如果需要加载，则进行加载操作，否则不进行操作。</p>\n<p>以上是一些优化虚拟列表性能的方法，实际应用时需要根据具体情况进行选择。需要注意的是，在进行性能优化时，要避免过度优化，以免降低代码的可读性和可维护性。</p>\n<h2 id=\"如何在滚动过程中，只更新可视区域内的元素，不需要重新渲染整个列表\"><a href=\"#如何在滚动过程中，只更新可视区域内的元素，不需要重新渲染整个列表\" class=\"headerlink\" title=\"如何在滚动过程中，只更新可视区域内的元素，不需要重新渲染整个列表\"></a>如何在滚动过程中，只更新可视区域内的元素，不需要重新渲染整个列表</h2><p>实现虚拟列表的关键就是根据可视区域的位置和大小来确定需要渲染哪些元素。一般来说，可以通过监听滚动事件，计算出当前可视区域的位置和大小，然后根据可视区域的位置和大小来确定需要渲染哪些元素。</p>\n<p>具体实现步骤如下：</p>\n<ol>\n<li>首先，需要获取列表容器和列表项的高度（或宽度），以及总共的元素数量。</li>\n<li>然后，可以监听列表容器的滚动事件，计算出当前可视区域的位置和大小，比如可视区域的开始索引和结束索引。</li>\n<li>接下来，可以根据可视区域的开始索引和结束索引来确定需要渲染哪些元素，通常会在可视区域外的元素设置一个占位符，避免出现闪动现象。</li>\n<li>最后，只需要更新可视区域内的元素，不需要重新渲染整个列表。</li>\n</ol>\n<p>在更新元素时，可以使用 DOM 操作来更新元素的内容，也可以使用虚拟 DOM 的技术来更新元素。使用虚拟 DOM 的好处是可以提高更新效率，减少 DOM 操作的次数。</p>\n<p>需要注意的是，在实现虚拟列表时，需要考虑到各种情况，比如滚动方向、滚动速度、元素高度不一致等因素，以确保列表的性能和渲染效果都能够满足需求。</p>\n<h2 id=\"可视区域外的元素设置一个占位符，避免出现闪动现象？\"><a href=\"#可视区域外的元素设置一个占位符，避免出现闪动现象？\" class=\"headerlink\" title=\"可视区域外的元素设置一个占位符，避免出现闪动现象？\"></a>可视区域外的元素设置一个占位符，避免出现闪动现象？</h2><p>是的，为了避免出现闪动现象，通常在可视区域外的元素会设置一个占位符。</p>\n<p>假设可视区域开始的索引是 start，结束的索引是 end，元素的总数是 total。则在可视区域外的元素可以通过占位符来替代，这个占位符的高度（或宽度）应该与元素的高度（或宽度）相同，以确保列表的布局不会出现变化。</p>\n<p>具体实现步骤如下：</p>\n<ol>\n<li>在列表容器内部创建一个占位符元素，并设置其高度（或宽度）与列表项相同。</li>\n<li>在渲染列表时，根据可视区域的开始索引和结束索引，分别渲染可视区域内的元素和占位符。</li>\n<li>在滚动过程中，根据可视区域的位置和大小来更新可视区域内的元素和占位符的内容。</li>\n<li>在更新元素时，需要同时更新相应的占位符，以确保列表的布局不会出现变化。</li>\n</ol>\n<p>通过设置占位符，可以避免在滚动过程中出现列表元素的闪动现象，从而提高用户体验。</p>\n<h1 id=\"react-window-与-react-virtualized\"><a href=\"#react-window-与-react-virtualized\" class=\"headerlink\" title=\"react-window 与 react-virtualized\"></a>react-window 与 react-virtualized</h1><p>据作者说：几年前开发 react-virtualized，他刚接触 React，这个库他在设计时候并不是很好，然后又不能去做大的调整，以避免给开发者带来痛苦</p>\n<p>几年前我写了 react-虚拟化。当时，我对 React 和窗口概念都不熟悉。正因为如此，我做了一些后来后悔的 API 决定。其中之一是添加了太多非必要的特性和组件。一旦你向开源项目添加了一些东西，删除它对用户来说是非常痛苦的。</p>\n<p>React-windows 是对 react-虚拟化的完全重写。尽可能多的实现功能。专注于使包更小、更快。花心思使 API（和留档）尽可能适合初学者（需要注意的是，窗口仍然是一种高级用例）。</p>\n<p>优先选用 <code>react-windows</code></p>\n<h1 id=\"react-windows-常见问题\"><a href=\"#react-windows-常见问题\" class=\"headerlink\" title=\"react-windows 常见问题\"></a>react-windows 常见问题</h1><h2 id=\"列表或网格可以-100-填充页面的宽度或高度吗？\"><a href=\"#列表或网格可以-100-填充页面的宽度或高度吗？\" class=\"headerlink\" title=\"列表或网格可以 100%填充页面的宽度或高度吗？\"></a>列表或网格可以 100%填充页面的宽度或高度吗？</h2><p>使用 <code>react-virtualized-auto-sizer</code></p>\n<img src=\"https://user-images.githubusercontent.com/29597/54005716-50f41880-410f-11e9-864f-a65bbdf49e07.png\" style=\"width:400px;max-width:100%\" />\n\n<h2 id=\"滚动时列表是空白的\"><a href=\"#滚动时列表是空白的\" class=\"headerlink\" title=\"滚动时列表是空白的?\"></a>滚动时列表是空白的?</h2><img src=\"https://user-images.githubusercontent.com/29597/54005352-eb535c80-410d-11e9-80b2-d3d02db1f599.gif\" style=\"width:400px;max-width:100%\"  />\n\n<p>那么您可能忘记使用样式参数了！</p>\n<p>像 react-windows 这样的库通过绝对定位列表项（通过内联样式）来工作，因此不要忘记将其附加到您呈现的 DOM 元素</p>\n<img src=\"https://user-images.githubusercontent.com/29597/54005433-45ecb880-410e-11e9-8721-420ff1a153da.png\"  style=\"width:400px;max-width:100%\" />\n\n<h2 id=\"延迟加载列表的数据\"><a href=\"#延迟加载列表的数据\" class=\"headerlink\" title=\"延迟加载列表的数据?\"></a>延迟加载列表的数据?</h2><p>使用 <code>react-window-infinite-loader</code></p>\n<img src=\"https://user-images.githubusercontent.com/29597/54006733-653a1480-4113-11e9-907b-08ca5e27b3f9.png\" style=\"width:400px;max-width:100%\" />\n\n<h2 id=\"附加自定义属性或事件处理程序？\"><a href=\"#附加自定义属性或事件处理程序？\" class=\"headerlink\" title=\"附加自定义属性或事件处理程序？\"></a>附加自定义属性或事件处理程序？</h2><p>使用 <code>outerElementType</code> 属性</p>\n<img src=\"https://user-images.githubusercontent.com/29597/54215333-f9ee9a80-44a4-11e9-9142-34c67026d950.png\" style=\"width:400px;max-width:100%\"  />\n\n<h2 id=\"在列表的顶部和底部添加填充？\"><a href=\"#在列表的顶部和底部添加填充？\" class=\"headerlink\" title=\"在列表的顶部和底部添加填充？\"></a>在列表的顶部和底部添加填充？</h2><p>需要一些内联样式</p>\n<img src=\"https://user-images.githubusercontent.com/29597/58774454-65ad4480-8576-11e9-8889-07044fd41393.png\" style=\"width:400px;max-width:100%\"  />\n\n<h2 id=\"在物品之间添加间隙？\"><a href=\"#在物品之间添加间隙？\" class=\"headerlink\" title=\"在物品之间添加间隙？\"></a>在物品之间添加间隙？</h2><img src=\"https://user-images.githubusercontent.com/29597/55043972-c14ad700-4ff5-11e9-9caa-2e9f4d85f96c.png\" style=\"width:400px;max-width:100%\"  />\n\n<h1 id=\"react-windows-代码\"><a href=\"#react-windows-代码\" class=\"headerlink\" title=\"react-windows 代码\"></a>react-windows 代码</h1><p><a href=\"https://github.com/bvaughn/react-window/blob/master/src/createListComponent.js#L138\" target=\"_blank\" >createListComponent 代码</a></p>\n","text":"虚拟列表原理虚拟列表实现原理虚拟列表（Virtual List）是一种常见的前端性能优化技术，用于解决渲染大量数据时，DOM 元素过多导致页面卡顿的问题。虚拟列表通过只渲染当前可见区域的 DOM 元素，来减少页面渲染的负担，从而提高页面性能。 虚拟列表的实现原理一般分为以下几步：...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/tags/性能优化.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":12,"path":"api/tags/chatGPT2021.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">虚拟列表原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">虚拟列表实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">优化虚拟列表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%BB%9A%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%8F%AA%E6%9B%B4%E6%96%B0%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E6%95%B4%E4%B8%AA%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">如何在滚动过程中，只更新可视区域内的元素，不需要重新渲染整个列表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E5%A4%96%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%8D%A0%E4%BD%8D%E7%AC%A6%EF%BC%8C%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E9%97%AA%E5%8A%A8%E7%8E%B0%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">可视区域外的元素设置一个占位符，避免出现闪动现象？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#react-window-%E4%B8%8E-react-virtualized\"><span class=\"toc-text\">react-window 与 react-virtualized</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#react-windows-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">react-windows 常见问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E6%88%96%E7%BD%91%E6%A0%BC%E5%8F%AF%E4%BB%A5-100-%E5%A1%AB%E5%85%85%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%BD%E5%BA%A6%E6%88%96%E9%AB%98%E5%BA%A6%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">列表或网格可以 100%填充页面的宽度或高度吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BB%9A%E5%8A%A8%E6%97%B6%E5%88%97%E8%A1%A8%E6%98%AF%E7%A9%BA%E7%99%BD%E7%9A%84\"><span class=\"toc-text\">滚动时列表是空白的?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%88%97%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">延迟加载列表的数据?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E6%88%96%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%9F\"><span class=\"toc-text\">附加自定义属性或事件处理程序？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%88%97%E8%A1%A8%E7%9A%84%E9%A1%B6%E9%83%A8%E5%92%8C%E5%BA%95%E9%83%A8%E6%B7%BB%E5%8A%A0%E5%A1%AB%E5%85%85%EF%BC%9F\"><span class=\"toc-text\">在列表的顶部和底部添加填充？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%89%A9%E5%93%81%E4%B9%8B%E9%97%B4%E6%B7%BB%E5%8A%A0%E9%97%B4%E9%9A%99%EF%BC%9F\"><span class=\"toc-text\">在物品之间添加间隙？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#react-windows-%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">react-windows 代码</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"NestJS","uid":"87f7fda2bbc28a023cd312e8d321db40","slug":"2023-05-09nestjs","date":"2023-05-09T10:25:51.000Z","updated":"2023-05-15T13:17:33.007Z","comments":true,"path":"api/articles/2023-05-09nestjs.json","keywords":null,"cover":null,"text":"开箱即用 开箱即用的应用框架就是一个已经预设好基本功能和样式的框架，可以帮助开发者快速地开发应用程序，不需要从零开始构建基础功能和样式。 通常，这类框架提供了一些预设的组件、工具、库、样式和模板等，也提供了文档、示例和编码规范等辅助开发的资源。 开箱即用的应用框架可以大大缩短应用...","link":"","photos":[],"count_time":{"symbolsCount":"75k","symbolsTime":"1:08"},"categories":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/categories/nodejs.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":12,"path":"api/tags/chatGPT2021.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"nodejs进程线程通信","uid":"1c1176847881d39523eab2c0cd2228ab","slug":"2023-05-08进程线程","date":"2023-05-08T02:42:06.000Z","updated":"2023-05-15T13:17:33.006Z","comments":true,"path":"api/articles/2023-05-08进程线程.json","keywords":null,"cover":null,"text":"问题 进程间通信与线程间通信的区别 ? 进程通信有哪些方式 ? 线程通信有哪些方式 ? kafaka 不属于进程通信 ? Electron 为什么使用线程通信 ? HTTP 可以替代 RPC ? 为什么出现 RPC ? 多进程，多线程，与同步是否冲突 ? Nodejs 进程之间如...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/categories/nodejs.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":12,"path":"api/tags/chatGPT2021.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}