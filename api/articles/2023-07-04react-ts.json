{"title":"React ts","uid":"6ab3589fb705488879a93d4f18abc3a2","slug":"2023-07-04react-ts","date":"2023-07-04T08:28:12.000Z","updated":"2023-07-08T01:06:25.368Z","comments":true,"path":"api/articles/2023-07-04react-ts.json","keywords":null,"cover":null,"content":"<h2 id=\"useImperativeHandle-如何使用-typescript-类型\"><a href=\"#useImperativeHandle-如何使用-typescript-类型\" class=\"headerlink\" title=\"useImperativeHandle 如何使用 typescript 类型\"></a>useImperativeHandle 如何使用 typescript 类型</h2><p>在 TypeScript 中使用 <code>useImperativeHandle</code> 需要定义一个合适的类型以确保类型安全性。以下是使用 <code>useImperativeHandle</code> 的示例代码，包括 TypeScript 类型的定义：</p>\n<p>首先，在使用 <code>useImperativeHandle</code> 的组件内部定义一个 Ref 对象，并定义一个相应的接口类型：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; forwardRef, useImperativeHandle, Ref &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\ninterface MyComponentRef &#123;\n  &#x2F;&#x2F; 定义暴露给父组件的方法\n  myMethod: () &#x3D;&gt; void;\n&#125;\n\nconst MyComponent &#x3D; forwardRef&lt;MyComponentRef, MyComponentProps&gt;((props, ref) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n\n  &#x2F;&#x2F; 在组件内部定义暴露给父组件的方法\n  const myMethod &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 实现方法的逻辑\n  &#125;;\n\n  &#x2F;&#x2F; 使用 useImperativeHandle 将 myMethod 暴露给父组件\n  useImperativeHandle(ref, () &#x3D;&gt; (&#123;\n    myMethod\n  &#125;));\n\n  &#x2F;&#x2F; ...\n\n  return (\n    &#x2F;&#x2F; JSX\n  );\n&#125;);</code></pre>\n\n<p>在上述代码中，<code>MyComponentRef</code> 定义了暴露给父组件的方法类型，这个类型将用作 <code>useImperativeHandle</code> 的泛型参数，以确保正确的类型引用。</p>\n<p>然后，在父组件中使用 <code>ref</code> 来调用 <code>MyComponent</code> 组件中的暴露方法：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; useRef &#125; from &#39;react&#39;;\n\nconst ParentComponent &#x3D; () &#x3D;&gt; &#123;\n  const myComponentRef &#x3D; useRef&lt;MyComponentRef | null&gt;(null);\n\n  &#x2F;&#x2F; 调用 MyComponent 中暴露的方法\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    if (myComponentRef.current) &#123;\n      myComponentRef.current.myMethod();\n    &#125;\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;调用子组件方法&lt;&#x2F;button&gt;\n      &lt;MyComponent ref&#x3D;&#123;myComponentRef&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>myComponentRef</code> 是一个 <code>useRef</code> 对象，用于引用 <code>MyComponent</code> 组件。通过访问 <code>current</code> 属性，可以调用 <code>myMethod</code> 方法。</p>\n<p>使用这种方法，你可以在 TypeScript 中安全地使用 <code>useImperativeHandle</code>，并定义正确的类型以确保代码的类型安全性。</p>\n<h2 id=\"useRef-中用到的-dom-类型有哪些？\"><a href=\"#useRef-中用到的-dom-类型有哪些？\" class=\"headerlink\" title=\"useRef 中用到的 dom 类型有哪些？\"></a>useRef 中用到的 dom 类型有哪些？</h2><p>在 React 中，<code>useRef</code> 通常用于引用 DOM 元素。以下是一些常见的 DOM 类型：</p>\n<ul>\n<li><code>HTMLInputElement</code>: 输入框元素类型</li>\n<li><code>HTMLTextAreaElement</code>: 文本域元素类型</li>\n<li><code>HTMLSelectElement</code>: 选择框元素类型</li>\n<li><code>HTMLButtonElement</code>: 按钮元素类型</li>\n<li><code>HTMLDivElement</code>: <code>&lt;div&gt;</code> 元素类型</li>\n<li><code>HTMLParagraphElement</code>: <code>&lt;p&gt;</code> 元素类型</li>\n<li><code>HTMLSpanElement</code>: <code>&lt;span&gt;</code> 元素类型</li>\n<li><code>HTMLHeadingElement</code>: 标题元素类型 (<code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, 等等)</li>\n<li><code>HTMLAnchorElement</code>: 锚点元素类型 (<code>&lt;a&gt;</code> 元素)</li>\n</ul>\n<p>这些是一些常见的 DOM 元素类型，但实际上可以根据你的应用中具体使用的元素类型进行扩展。你可以根据需要使用适当的 DOM 类型来定义 <code>useRef</code>。</p>\n<p>需要注意的是，使用 <code>useRef</code> 引用的 DOM 元素可能为 <code>null</code>，因此在访问元素属性或方法之前，应该进行存在性检查，以避免运行时错误。例如：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; useRef, useEffect &#125; from &#39;react&#39;;\n\nconst MyComponent &#x3D; () &#x3D;&gt; &#123;\n  const inputRef &#x3D; useRef&lt;HTMLInputElement | null&gt;(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (inputRef.current) &#123;\n      inputRef.current.focus();\n    &#125;\n  &#125;, []);\n\n  return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<p>在上述示例中，<code>inputRef</code> 引用了一个输入框元素，并在 <code>useEffect</code> 钩子中使用 <code>focus</code> 方法聚焦到输入框上。但在使用 <code>focus</code> 方法之前，首先进行了存在性检查以避免 <code>inputRef.current</code> 为 <code>null</code> 的情况。</p>\n<h2 id=\"useContext-用到的类型\"><a href=\"#useContext-用到的类型\" class=\"headerlink\" title=\"useContext 用到的类型\"></a>useContext 用到的类型</h2><p>在使用 <code>useContext</code> 进行上下文（Context）的状态访问时，通常需要指定上下文的类型。以下是常见的类型：</p>\n<ul>\n<li>上下文值的类型：上下文值的类型定义了上下文提供的数据类型。</li>\n<li>上下文对象的类型：上下文对象类型定义了包含上下文值和其他辅助方法或属性的对象类型。</li>\n</ul>\n<p>这是一个使用 <code>useContext</code> 的简单示例，展示了上下文值和上下文对象的类型定义。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import React, &#123; useContext, createContext &#125; from &#39;react&#39;;\n\n&#x2F;&#x2F; 定义上下文值的类型\ntype Theme &#x3D; &#39;light&#39; | &#39;dark&#39;;\n\n&#x2F;&#x2F; 定义上下文对象的类型\ninterface ThemeContextType &#123;\n  theme: Theme;\n  toggleTheme: () &#x3D;&gt; void;\n&#125;\n\n&#x2F;&#x2F; 创建上下文\nconst ThemeContext &#x3D; createContext&lt;ThemeContextType | undefined&gt;(undefined);\n\n&#x2F;&#x2F; 使用上下文\nconst MyComponent &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 获取上下文值和方法\n  const themeContext &#x3D; useContext(ThemeContext);\n\n  &#x2F;&#x2F; 检查上下文是否存在\n  if (!themeContext) &#123;\n    return null;\n  &#125;\n\n  const &#123; theme, toggleTheme &#125; &#x3D; themeContext;\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;toggleTheme&#125;&gt;Toggle Theme&lt;&#x2F;button&gt;\n      &lt;p&gt;Current Theme: &#123;theme&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 在父组件中提供上下文值和方法\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const theme: Theme &#x3D; &#39;light&#39;;\n\n  const toggleTheme &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理主题切换逻辑\n  &#125;;\n\n  return (\n    &lt;ThemeContext.Provider value&#x3D;&#123;&#123; theme, toggleTheme &#125;&#125;&gt;\n      &lt;MyComponent &#x2F;&gt;\n    &lt;&#x2F;ThemeContext.Provider&gt;\n  );\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>ThemeContextType</code> 定义了上下文对象的类型，包含了 <code>theme</code> 和 <code>toggleTheme</code> 这两个属性。在上下文创建时，我们使用了 <code>createContext</code> 来定义 <code>ThemeContext</code>，并使用上下文对象类型进行泛型参数化。</p>\n<p>通过 <code>useContext(ThemeContext)</code>，我们在 <code>MyComponent</code> 中获取了上下文的值和方法，并进行了存在性检查。然后我们可以在组件中使用这些上下文的值和方法。</p>\n<p>需要注意，上述示例中的类型是示意性的，你可以根据你的具体上下文定义自己的类型。</p>\n<h2 id=\"useMemo-缓存组件\"><a href=\"#useMemo-缓存组件\" class=\"headerlink\" title=\"useMemo 缓存组件\"></a>useMemo 缓存组件</h2><p>是的，你可以使用 <code>useMemo</code> 来缓存包裹组件。具体方法是将要缓存的组件作为 <code>useMemo</code> 的计算函数，并将依赖项数组留空，这样组件将在首次渲染时计算并缓存结果。</p>\n<p>以下是一个示例，演示如何使用 <code>useMemo</code> 包裹组件：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React, &#123; useMemo &#125; from &#39;react&#39;;\n\nconst CachedComponentWrapper &#x3D; (&#123; items &#125;) &#x3D;&gt; &#123;\n  const MemoizedComponent &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 返回要缓存的组件\n    return &lt;Component items&#x3D;&#123;items&#125; &#x2F;&gt;;\n  &#125;, []); &#x2F;&#x2F; 依赖项留空\n\n  return MemoizedComponent;\n&#125;;\n\n&#x2F;&#x2F; 要缓存的组件\nconst Component &#x3D; (&#123; items &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 组件的逻辑和渲染\n  &#x2F;&#x2F; ...\n\n  return &lt;div&gt;&#123;&#x2F;* 使用 items 渲染内容 *&#x2F;&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\n&#x2F;&#x2F; 在父组件中使用 CachedComponentWrapper\nconst ParentComponent &#x3D; () &#x3D;&gt; &#123;\n  const items &#x3D; [\n    &#x2F;* 数据源 *&#x2F;\n  ];\n\n  return &lt;CachedComponentWrapper items&#x3D;&#123;items&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<p>在上面的示例中，<code>CachedComponentWrapper</code> 组件使用 <code>useMemo</code> 将 <code>Component</code> 组件包裹起来，将其计算结果缓存下来。在这种情况下，由于缓存的组件没有任何依赖项，它将在首次渲染时计算并缓存结果。然后每次渲染 <code>CachedComponentWrapper</code> 组件时，都将返回缓存的组件，而不会重新创建和渲染。</p>\n<p>注意，由于缓存的组件不依赖任何其他变量或状态，当父组件重新渲染时，缓存的组件将不会被重新渲染。这在某些情况下可能是你想要的结果，但请确保你理解这种行为所带来的影响。</p>\n<h2 id=\"React-相关的-typescript-类型有哪些\"><a href=\"#React-相关的-typescript-类型有哪些\" class=\"headerlink\" title=\"React 相关的 typescript 类型有哪些\"></a>React 相关的 typescript 类型有哪些</h2><p>在使用 React 进行 TypeScript 开发时，有一些常用的类型可以用来声明组件和组件所使用的 props、state 等。以下是一些常见的 React 相关的 TypeScript 类型：</p>\n<ol>\n<li><strong>React.FC</strong>：表示一个函数组件的类型。使用该类型可以帮助约束函数组件的 props。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; FC &#125; from &#39;react&#39;;\n\nconst MyComponent: FC&lt;MyComponentProps&gt; &#x3D; (&#123; prop1, prop2 &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li><strong>React.Component</strong>：表示一个类组件的类型。使用该类型可以帮助约束类组件的 props 和 state。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; Component &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\ninterface MyComponentState &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nclass MyComponent extends Component&lt;MyComponentProps, MyComponentState&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li><strong>React.PropsWithChildren</strong>：用于包裹组件的 props，以使其能够接收子组件作为 children 属性。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React from &#39;react&#39;;\n\ninterface MyComponentProps extends React.PropsWithChildren&lt;&#123;&#125;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li><strong>React.ReactNode</strong>：表示组件可以渲染的任何内容。可以用作组件的 children 类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; ReactNode &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  children: ReactNode;\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li><strong>React.CSSProperties</strong>：表示 CSS 样式属性的类型，用于定义组件的样式。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; CSSProperties &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  style?: CSSProperties;\n&#125;</code></pre>\n\n<ol start=\"6\">\n<li><strong>React.RefObject</strong>：表示一个 ref 对象的类型，用于获取组件的引用。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; RefObject, useRef &#125; from &#39;react&#39;;\n\nconst MyComponent &#x3D; () &#x3D;&gt; &#123;\n  const ref: RefObject&lt;HTMLDivElement&gt; &#x3D; useRef(null);\n\n  &#x2F;&#x2F; ...\n&#125;;</code></pre>\n\n<ol start=\"7\">\n<li><strong>React.ChangeEvent</strong>：表示表单元素（如 input、select、textarea）的变化事件对象类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; ChangeEvent &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  onChange: (event: ChangeEvent&lt;HTMLInputElement&gt;) &#x3D;&gt; void;\n&#125;</code></pre>\n\n<ol start=\"8\">\n<li><strong>React.MouseEvent</strong>：表示鼠标事件对象类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; MouseEvent &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  onClick: (event: MouseEvent&lt;HTMLButtonElement&gt;) &#x3D;&gt; void;\n&#125;</code></pre>\n\n<ol start=\"9\">\n<li><strong>React.KeyboardEvent</strong>：表示键盘事件对象类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; KeyboardEvent &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  onKeyDown: (event: KeyboardEvent&lt;HTMLInputElement&gt;) &#x3D;&gt; void;\n&#125;</code></pre>\n\n<ol start=\"10\">\n<li><strong>React.FormEvent</strong>：表示表单提交事件对象类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; FormEvent &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  onSubmit: (event: FormEvent&lt;HTMLFormElement&gt;) &#x3D;&gt; void;\n&#125;</code></pre>\n\n<ol start=\"11\">\n<li><strong>React.FunctionComponent</strong>：与 React.FC 类似，用于定义函数组件的类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; FunctionComponent &#125; from &#39;react&#39;;\n\nconst MyComponent: FunctionComponent&lt;MyComponentProps&gt; &#x3D; (&#123; prop1, prop2 &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;;</code></pre>\n\n<ol start=\"12\">\n<li><strong>React.ReactNodeArray</strong>：表示组件可以渲染的节点数组（ReactNode 的数组）。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; ReactNodeArray &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  children: ReactNodeArray;\n&#125;</code></pre>\n\n<ol start=\"13\">\n<li><strong>React.Ref</strong>：表示对元素或组件的引用类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; Ref &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  inputRef: Ref&lt;HTMLInputElement&gt;;\n&#125;</code></pre>\n\n<ol start=\"14\">\n<li><strong>React.HTMLProps</strong>：用于将原生 HTML 属性添加到自定义组件的类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; HTMLProps &#125; from &#39;react&#39;;\n\ninterface MyComponentProps extends HTMLProps&lt;HTMLDivElement&gt; &#123;\n  &#x2F;&#x2F; 自定义属性\n  customProp: string;\n&#125;</code></pre>\n\n<ol start=\"15\">\n<li><strong>React.ComponentType</strong>：表示 React 组件的类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; ComponentType &#125; from &#39;react&#39;;\n\nconst MyComponent: ComponentType&lt;MyComponentProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;;</code></pre>\n\n<ol start=\"16\">\n<li><strong>React.PropsWithChildren</strong>：用于为组件添加 children 属性的类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; PropsWithChildren &#125; from &#39;react&#39;;\n\ninterface MyComponentProps extends PropsWithChildren&lt;any&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"17\">\n<li><strong>React.ReactElement</strong>：表示 React 元素的类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; ReactElement &#125; from &#39;react&#39;;\n\nconst MyComponent: ReactElement&lt;MyComponentProps&gt; &#x3D; &lt;MyComponent prop1&#x3D;&quot;value&quot; &#x2F;&gt;;</code></pre>\n\n<ol start=\"18\">\n<li><strong>React.FC</strong>: 这是一个泛型类型，用于表示函数组件的类型。它可以指定组件接受的 prop 类型。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import React, &#123; FC &#125; from &#39;react&#39;;\n\ninterface MyComponentProps &#123;\n  name: string;\n&#125;\n\nconst MyComponent: FC&lt;MyComponentProps&gt; &#x3D; (&#123; name &#125;) &#x3D;&gt; &#123;\n  return &lt;div&gt;Hello, &#123;name&#125;!&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h2 id=\"ReactElement-与-ReactNode-的区别\"><a href=\"#ReactElement-与-ReactNode-的区别\" class=\"headerlink\" title=\"ReactElement 与 ReactNode 的区别\"></a>ReactElement 与 ReactNode 的区别</h2><p><code>ReactElement</code> 和 <code>ReactNode</code> 都是 React 中用于描述组件的子元素的类型。</p>\n<ul>\n<li><p><code>ReactNode</code> 是一个广泛的类型，可以表示任何类型的子元素，包括 React 元素、字符串、数字、布尔值等。你可以将 <code>ReactNode</code> 理解为表示任何可以在 React 中渲染的内容的类型。</p>\n</li>\n<li><p><code>ReactElement</code> 是 <code>ReactNode</code> 的一个特殊子集，它表示一个合法的 React 元素。React 元素是通过使用 JSX 或者 <code>React.createElement</code> 创建的，并且具有特定的类型和属性。React 元素是构成 React 应用的基本构建块，它描述了要在 DOM 中渲染的元素的样子。</p>\n</li>\n</ul>\n<p>举个例子，考虑以下 JSX 语法：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const element &#x3D; &lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;;</code></pre>\n\n<p>在这个例子中，<code>&lt;h1&gt;Hello, World!&lt;/h1&gt;</code> 是一个 JSX 表达式，它会被转化成一个 <code>ReactElement</code>。这个 <code>ReactElement</code> 描述了要在 DOM 中渲染的 <code>&lt;h1&gt;</code> 元素。</p>\n<p>而在如下代码中：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const node &#x3D; &lt;div&gt;Hello, World!&lt;&#x2F;div&gt;;</code></pre>\n\n<p>这个代码涉及的 <code>&lt;div&gt;Hello, World!&lt;/div&gt;</code> 是一个 JSX 表达式，也是一个 <code>ReactElement</code>，描述了要在 DOM 中渲染的 <code>&lt;div&gt;</code> 元素。</p>\n<p>所以，可以认为 <code>ReactElement</code> 是 <code>ReactNode</code> 的一个特殊子集，<code>ReactNode</code> 则是更广泛的概念，可以表示任何可以在 React 中渲染的内容。</p>\n<h2 id=\"正确-x2F-错误示例\"><a href=\"#正确-x2F-错误示例\" class=\"headerlink\" title=\"正确&#x2F;错误示例\"></a>正确&#x2F;错误示例</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 爬取脚本\nvar list &#x3D; &#39;&#39;;\nArray.from(temp1.getElementsByClassName(&#39;block hover:underline&#39;)).forEach((a, index) &#x3D;&gt; &#123;\n  console.log(a);\n  const href &#x3D; a.href;\n  const text &#x3D; a.children[0].innerHTML;\n  list +&#x3D; &#96;$&#123;index + 1&#125;. &lt;a href&#x3D;&quot;$&#123;location.href + href&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;text&#125;&lt;&#x2F;a&gt;\\n&#96;;\n&#125;);\nconsole.log(list);\ncopy(list);</code></pre>\n\n<ol>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-react-onsubmit-event-type\" target=\"_blank\">Type the onSubmit event in React (TypeScript)</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/react-typescript-usestate-array-of-objects\" target=\"_blank\">Type useState as Array or Object in React TypeScript</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-react-onfocus-onblur-event-type\" target=\"_blank\">Type the onFocus and onBlur events in React (TypeScript)</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-react-onkeydown-event-type\" target=\"_blank\">Type onKeyDown, onKeyUp, onKeyPress events in React (TS)</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-type-has-no-properties-in-common-with-type\" target=\"_blank\">Type ‘X’ has no properties in common with type ‘Y’ in TS</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-react-onclick-event-type\" target=\"_blank\">Type the onClick event of an element in React (TypeScript)</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-type-is-missing-following-properties-from-type\" target=\"_blank\">Type ‘X’ is missing the following properties from type ‘Y’</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-react-onchange-event-type\" target=\"_blank\">Type the onChange event of an element in React (TypeScript)</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-types-have-separate-declarations-of-private-property\" target=\"_blank\">Types have separate declarations of a private property in TS</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-type-object-must-have-symbol-iterator-method\" target=\"_blank\">Type Object must have a Symbol.iterator method that returns an iterator</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-tuple-type-of-length-has-no-element-at-index\" target=\"_blank\">Tuple type of length has no element at index X in TS</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/aws-cdk-typescript-lambda\" target=\"_blank\">Write TypeScript Lambda functions in AWS CDK - Complete Guide</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-date-type\" target=\"_blank\">How to type a Date object in TypeScript</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-process-env-type\" target=\"_blank\">Define types for process.env in TypeScript</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-async-function-type\" target=\"_blank\">How to type an async Function in TypeScript</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-reduce-type\" target=\"_blank\">How to Type the reduce() method in TypeScript</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/typescript-spread-types-may-only-be-created-from-object-types\" target=\"_blank\">Spread types may only be created from object types in TS</a></li>\n<li><a href=\"https://bobbyhadz.com/blog/react-type-children-has-no-properties-in-common\" target=\"_blank\">React: Type {children: Element} has no properties in common with type IntrinsicAttributes</a></li>\n</ol>\n","text":"useImperativeHandle 如何使用 typescript 类型在 TypeScript 中使用 useImperativeHandle 需要定义一个合适的类型以确保类型安全性。以下是使用 useImperativeHandle 的示例代码，包括 TypeScript...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useImperativeHandle-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-typescript-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">useImperativeHandle 如何使用 typescript 类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useRef-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84-dom-%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">useRef 中用到的 dom 类型有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useContext-%E7%94%A8%E5%88%B0%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">useContext 用到的类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useMemo-%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">useMemo 缓存组件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%9B%B8%E5%85%B3%E7%9A%84-typescript-%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">React 相关的 typescript 类型有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReactElement-%E4%B8%8E-ReactNode-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">ReactElement 与 ReactNode 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E7%A1%AE-x2F-%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">正确&#x2F;错误示例</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Swagger 页面解析","uid":"21f262aa0def51563dca48d4ff6e0e83","slug":"2023-07-05swagger","date":"2023-07-05T07:20:26.000Z","updated":"2023-07-08T01:06:25.368Z","comments":true,"path":"api/articles/2023-07-05swagger.json","keywords":null,"cover":null,"text":"背景后端有些用接口是用 swagger 书写的，CV 操作太累 以前方案 用阿里的一个 vscode 插件进行生成，有些生成的比较烂，不能在已有的项目中使用工具 自己写一个分析 swagger json 工具有一定的工作量，尤其是在处理具有依赖关系的模型时 改造 knife4j,...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"工具","slug":"工具","count":20,"path":"api/tags/工具.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"ellipsis检测","uid":"0f92e5beba8a19456370cfbf5ca7de88","slug":"2023-07-04ellipsis","date":"2023-07-04T02:06:40.000Z","updated":"2023-07-16T02:13:26.428Z","comments":true,"path":"api/articles/2023-07-04ellipsis.json","keywords":null,"cover":[],"text":"ellipsis 字符串长度不够准确 如何不用字符串长度更好的实现 html 前端如何检测 触发了 ellipsis要检测 HTML 前端中是否触发了文本省略（ellipsis），可以使用以下方法： 使用 JavaScript 和 DOM 操作： 在元素的父容器上使用 offse...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":6,"path":"api/tags/前端.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}