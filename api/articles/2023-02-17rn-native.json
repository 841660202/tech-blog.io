{"title":"RN 与原生的通信","uid":"c83d31c32f6ad912ea131cac215fb5d8","slug":"2023-02-17rn-native","date":"2023-02-17T11:12:39.000Z","updated":"2023-02-20T21:20:56.496Z","comments":true,"path":"api/articles/2023-02-17rn-native.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202302171928314.webp","content":"<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>RN 与原生进行数据交换</p>\n<h2 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h2><ol>\n<li><code>访问原生API</code>: 有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；</li>\n<li><code>复用原生功能</code>: 或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍；</li>\n<li><code>性能和线程</code>: 又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。</li>\n<li><code>RN没有，原生有</code>: 如果 React Native 还不支持某个你需要的原生特性，你应当可以自己实现该特性的封装</li>\n</ol>\n<p><a href=\"https://reactnative.dev/docs/0.70/native-modules-android\" target=\"_blank\" >https://reactnative.dev/docs/0.70/native-modules-android</a></p>\n<p><a href=\"https://reactnative.dev/docs/0.70/native-modules-ios\" target=\"_blank\" >https://reactnative.dev/docs/0.70/native-modules-ios</a></p>\n<h2 id=\"安卓原生模块\"><a href=\"#安卓原生模块\" class=\"headerlink\" title=\"安卓原生模块\"></a>安卓原生模块</h2><h3 id=\"RN-调用原生方法\"><a href=\"#RN-调用原生方法\" class=\"headerlink\" title=\"RN 调用原生方法\"></a>RN 调用原生方法</h3><ol>\n<li>注册方法<ol>\n<li>继承 RN 类： <code>ReactContextBaseJavaModule</code></li>\n<li>实现方法： <code>public String getName() &#123;</code></li>\n<li>暴露方法： <code>public Map&lt;String, Object&gt; getConstants() &#123;</code></li>\n<li>导出方法：给 JavaScript 使用，Java 方法需要使用注解<code>@ReactMethod</code></li>\n</ol>\n</li>\n<li>注册模块：<ol>\n<li><code>implements ReactPackage</code></li>\n<li>重写<code>createViewManagers</code>, <code>createNativeModules</code>方法</li>\n<li>在<code>MainApplication.java</code>中 提供 <code>getPackages</code>返回</li>\n</ol>\n</li>\n<li>RN 端使用 <code>NativeModules</code> 进行调用</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; NativeModules &#125; from &quot;react-native&quot;;\n&#x2F;&#x2F; 下一句中的ToastExample即对应上文\n&#x2F;&#x2F; public String getName()中返回的字符串\nexport default NativeModules.ToastExample;</code></pre>\n\n<h3 id=\"回调参数\"><a href=\"#回调参数\" class=\"headerlink\" title=\"回调参数\"></a>回调参数</h3><p>原生模块还支持一种特殊的参数——回调函数。它提供了一个函数来把返回值传回给 JavaScript。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.facebook.react.bridge.Callback;\n\n@ReactMethod\n&#x2F;&#x2F; prettier-ignore\n  public void measureLayout( int tag, int ancestorTag, Callback errorCallback, Callback successCallback) &#123;\n    try &#123;\n      measureLayout(tag, ancestorTag, mMeasureBuffer);\n      float relativeX &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[0]);\n      float relativeY &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[1]);\n      float width &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[2]);\n      float height &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[3]);\n      &#x2F;&#x2F; successCallback\n      &#x2F;&#x2F; 多提句, 你看这个invoke像不像electron的invoke?\n      successCallback.invoke(relativeX, relativeY, width, height);\n    &#125; catch (IllegalViewOperationException e) &#123;\n      &#x2F;&#x2F; errorCallback\n      errorCallback.invoke(e.getMessage());\n    &#125;\n  &#125;</code></pre>\n\n<h3 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h3><ol>\n<li>原生模块还可以使用 promise 来简化代码，搭配 ES2016(ES7)标准的 async&#x2F;await 语法则效果更佳。</li>\n<li>如果桥接原生方法的最后一个参数是一个 Promise，则对应的 JS 方法就会返回一个 Promise 对象</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.facebook.react.bridge.Promise;\n\n@ReactMethod\n  public void measureLayout( int tag, int ancestorTag, Promise promise) &#123; &#x2F;&#x2F; 这个promise类型\n    try &#123;\n      measureLayout(tag, ancestorTag, mMeasureBuffer);\n\n      WritableMap map &#x3D; Arguments.createMap();\n\n      map.putDouble(&quot;relativeX&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[0]));\n      map.putDouble(&quot;relativeY&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[1]));\n      map.putDouble(&quot;width&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[2]));\n      map.putDouble(&quot;height&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[3]));\n\n      promise.resolve(map);\n    &#125; catch (IllegalViewOperationException e) &#123;\n      promise.reject(E_LAYOUT_ERROR, e);\n    &#125;\n  &#125;</code></pre>\n\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>如果一个过程要阻塞执行一段时间，这个工作应当分配到一个内部管理的工作线程，然后从那边可以调用任意的回调函数</p>\n<h3 id=\"RN-监听原生事件\"><a href=\"#RN-监听原生事件\" class=\"headerlink\" title=\"RN 监听原生事件\"></a>RN 监听原生事件</h3><p>发送事件到 JavaScript</p>\n<ol>\n<li>原生模块可以在没有被调用的情况下往 JavaScript 发送事件通知。</li>\n<li>最简单的办法就是通过<code>RCTDeviceEventEmitter</code>，这可以通过 <code>ReactContext</code> 来获得对应的引用</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; NativeEventEmitter, NativeModules &#125; from &#39;react-native&#39;;\n&#x2F;&#x2F; ...\n  componentDidMount() &#123;\n    &#x2F;&#x2F; ...\n    const eventEmitter &#x3D; new NativeEventEmitter(NativeModules.ToastExample);\n    this.eventListener &#x3D; eventEmitter.addListener(&#39;EventReminder&#39;, (event) &#x3D;&gt; &#123;\n       console.log(event.eventProperty) &#x2F;&#x2F; &quot;someValue&quot;\n    &#125;);\n    &#x2F;&#x2F; ...\n  &#125;\n  componentWillUnmount() &#123;\n    this.eventListener.remove(); &#x2F;&#x2F; 组件卸载时记得移除监听事件\n  &#125;\n</code></pre>\n\n<h2 id=\"IOS-原生模块\"><a href=\"#IOS-原生模块\" class=\"headerlink\" title=\"IOS 原生模块\"></a>IOS 原生模块</h2><p><a href=\"http://www.bczl.xyz/objc/doc-zh/\" target=\"_blank\" >陌生感袭来，现在已经不晓得<code>.m</code> <code>.h</code> 文件搞啥的了</a></p>\n<ol>\n<li>为了实现 RCTBridgeModule 协议，</li>\n<li>你的类需要包含 RCT_EXPORT_MODULE()宏。</li>\n<li>这个宏也可以添加一个参数用来指定在 JavaScript 中访问这个模块的名字。</li>\n<li>如果你不指定，默认就会使用这个 Objective-C 类的名字。</li>\n<li>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; NativeModules &#125; from &quot;react-native&quot;;\n\nconst CalendarManager &#x3D; NativeModules.CalendarManager;\n\nCalendarManager.addEvent(&quot;Birthday Party&quot;, &quot;4 Privet Drive, Surrey&quot;);</code></pre>\n\n<h4 id=\"IOS-RCT-REMAP-METHOD-宏\"><a href=\"#IOS-RCT-REMAP-METHOD-宏\" class=\"headerlink\" title=\"IOS RCT_REMAP_METHOD()宏\"></a>IOS RCT_REMAP_METHOD()宏</h4><ol>\n<li>React Native 还定义了一个 RCT_REMAP_METHOD()宏，它可以指定 JavaScript 方法名。</li>\n<li>因为 JavaScript 端不能有<code>同名不同参</code>的方法存在，所以当原生端存在重载方法时，<code>可以使用这个宏来避免在 JavaScript 端的名字冲突。</code></li>\n</ol>\n<h2 id=\"Hermes\"><a href=\"#Hermes\" class=\"headerlink\" title=\"Hermes\"></a>Hermes</h2><ol>\n<li>Hermes 专为资源受限的设备而设计，并针对启动、应用程序大小和内存消耗进行了优化。</li>\n<li>Hermes 和其他 JS 引擎之间的一个关键区别: 是它能够提前将 JavaScript 源代码编译为字节码。</li>\n<li>这个预编译的字节码捆绑在二进制文件中，使解释器不必在应用程序启动期间执行这一昂贵的步骤</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/weixin_43972437/article/details/122901903\" target=\"_blank\" >见</a></p>\n","text":"是什么RN 与原生进行数据交换 为什么 访问原生API: 有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装； 复用原生功能: 或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍； 性能和线程: 又或者你需要...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"react-native","slug":"react-native","count":4,"path":"api/categories/react-native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":4,"path":"api/tags/react-native.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">为什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%8D%93%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">安卓原生模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RN-%E8%B0%83%E7%94%A8%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">RN 调用原生方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">回调参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#promise\"><span class=\"toc-text\">promise</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RN-%E7%9B%91%E5%90%AC%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">RN 监听原生事件</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IOS-%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">IOS 原生模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#IOS-RCT-REMAP-METHOD-%E5%AE%8F\"><span class=\"toc-text\">IOS RCT_REMAP_METHOD()宏</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hermes\"><span class=\"toc-text\">Hermes</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"状态管理工具-mobx","uid":"bda443873131c24fe879383385449e93","slug":"2023-02-18mobx","date":"2023-02-18T01:36:28.000Z","updated":"2023-02-20T22:43:20.284Z","comments":true,"path":"api/articles/2023-02-18mobx.json","keywords":null,"cover":null,"text":"mobx 是什么 它通过运用透明的函数式响应编程（Transparent Functional Reactive Programming，TFRP）使状态管理变得简单和可扩展 任何可以从应用状态中派生出来的值都应该被自动派生出来 mobx 有什么特点 透明函数式响应编程 简单无模...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"状态管理工具","slug":"状态管理工具","count":1,"path":"api/categories/状态管理工具.json"}],"tags":[{"name":"状态管理工具","slug":"状态管理工具","count":1,"path":"api/tags/状态管理工具.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Mac 键盘错乱","uid":"44465ab41d804f6d7f2b3ae4f9d00825","slug":"2023-02-17keyboard","date":"2023-02-17T02:23:33.000Z","updated":"2023-02-20T21:20:56.496Z","comments":true,"path":"api/articles/2023-02-17keyboard.json","keywords":null,"cover":[],"text":"怎么发生的键盘脏了，将电脑置为输入密码界面，然后用酒精湿巾擦拭，擦完后“键盘乱了”，键盘输出结果乱七八糟 &#x2F;&#x2F; 错乱后的结果 &#x2F;&#x2F; qwfpgjluy;arstdhneizxcvbkm &#x2F;&#x2F; 正确的结果 &#x2F;&#...","link":"","photos":[],"count_time":{"symbolsCount":194,"symbolsTime":"1 mins."},"categories":[{"name":"Mac","slug":"Mac","count":1,"path":"api/categories/Mac.json"}],"tags":[{"name":"Mac","slug":"Mac","count":1,"path":"api/tags/Mac.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}