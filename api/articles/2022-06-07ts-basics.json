{"title":"2.Typescript åŸºç¡€","uid":"3d6d9d5bd9a34b12b2d2da5941501c4f","slug":"2022-06-07ts-basics","date":"2022-06-06T07:56:08.000Z","updated":"2022-06-09T13:53:32.968Z","comments":true,"path":"api/articles/2022-06-07ts-basics.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","content":"<h2 id=\"The-Basics\"><a href=\"#The-Basics\" class=\"headerlink\" title=\"The Basics\"></a>The Basics</h2><p>Welcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the â€˜Getting Startedâ€™ guides<br><code>æ¬¢è¿æ¥åˆ° TypeScript æ‰‹å†Œçš„ç¬¬ä¸€é¡µã€‚å¦‚æœæ‚¨æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨ TypeScript - æ‚¨å¯èƒ½æƒ³è¦å¼€å§‹ä¸€ä¸ª&#39;Getting Started&#39;æŒ‡å—</code></p>\n<p>Each and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named message.<br><code>æ¯ä¸ªå’Œæ‰€æœ‰çš„å€¼åœ¨ JavaScript ä¸­éƒ½æœ‰ä¸€ç»„è¡Œä¸ºå¯ä»¥è§‚å¯Ÿä»è¿è¡Œä¸åŒçš„æ“ä½œã€‚è¿™ä¼šæ„Ÿè§‰å¾ˆæŠ½è±¡ï¼Œä½†æ˜¯ä½œä¸ºä¸€ä¸ªå¿«é€Ÿçš„ä¾‹å­ï¼Œè€ƒè™‘ä¸€äº›æˆ‘ä»¬å¯èƒ½è¿è¡Œçš„æ“ä½œçš„å˜é‡åç§° messageã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Accessing the property &#39;toLowerCase&#39;\n&#x2F;&#x2F; on &#39;message&#39; and then calling it\nmessage.toLowerCase();\n&#x2F;&#x2F; Calling &#39;message&#39;\nmessage();</code></pre>\n\n<p>If we break this down, the first runnable line of code accesses a property called toLowerCase and then calls it. The second one tries to call message directly.<br><code>å¦‚æœ æˆ‘ä»¬å°†è¿™ä¸ªåˆ†è§£ï¼Œç¬¬ä¸€ä¸ªå¯è¿è¡Œçš„è¡Œä»£ç è®¿é—®ä¸€ä¸ªå±æ€§å«åš toLowerCase å¹¶ä¸”è°ƒç”¨å®ƒã€‚ç¬¬äºŒä¸ªå°è¯•ç›´æ¥è°ƒç”¨ messageã€‚</code><br>But assuming we donâ€™t know the value of message - and thatâ€™s pretty common - we canâ€™t reliably say what results weâ€™ll get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place.<br><code>ä½†æ˜¯å‡è®¾æˆ‘ä»¬ä¸çŸ¥é“ message çš„å€¼ - å¹¶ä¸”è¿™æ˜¯å¾ˆå¸¸è§çš„ - æˆ‘ä»¬ä¸å¯ä»¥å¯é åœ°è¯´ä»€ä¹ˆç»“æœæˆ‘ä»¬ä¼šå¾—åˆ°è¿è¡Œè¿™äº›ä»£ç ã€‚æ¯ä¸ªæ“ä½œçš„è¡Œä¸ºå–å†³äºæˆ‘ä»¬æœ¬èº«çš„å€¼ã€‚</code></p>\n<ul>\n<li>Is message callable? <code>message æ˜¯å¯è°ƒç”¨çš„å—ï¼Ÿ</code></li>\n<li>Does it have a property called toLowerCase on it? <code>message æœ‰ä¸€ä¸ªå±æ€§å«åš toLowerCase å—ï¼Ÿ</code></li>\n<li>If it does, is toLowerCase even callable? <code>å¦‚æœæ˜¯ï¼Œæ˜¯å¦ toLowerCase å¯è°ƒç”¨ï¼Ÿ</code></li>\n<li>If both of these values are callable, what do they return? <code>å¦‚æœè¿™ä¸¤ä¸ªå€¼éƒ½æ˜¯å¯è°ƒç”¨çš„ï¼Œå®ƒä»¬ä¼šè¿”å›ä»€ä¹ˆï¼Ÿ</code></li>\n</ul>\n<p>The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.<br><code>è¿™äº›é—®é¢˜çš„ç­”æ¡ˆé€šå¸¸æ˜¯æˆ‘ä»¬åœ¨å†™ JavaScript æ—¶ä¿ç•™åœ¨æˆ‘ä»¬çš„è„‘ä¸­ï¼Œå¹¶ä¸”æˆ‘ä»¬å¿…é¡»å¸Œæœ›æˆ‘ä»¬æ‹¿åˆ°æ‰€æœ‰çš„ç»†èŠ‚æ­£ç¡®ã€‚</code><br>Letâ€™s say message was defined in the following way.<br><code>è®©æˆ‘ä»¬å‡è®¾ message è¢«å®šä¹‰ä¸ºä»¥ä¸‹çš„æ–¹å¼ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const message &#x3D; &quot;Hello World!&quot;;</code></pre>\n\n<p>As you can probably guess, if we try to run message.toLowerCase(), weâ€™ll get the same string only in lower-case.<br><code>å¦‚æœæˆ‘ä»¬è¯•ç€è¿è¡Œ message.toLowerCase()ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªåªæœ‰å°å†™å­—æ¯çš„å­—ç¬¦ä¸²ã€‚</code><br>What about that second line of code? If youâ€™re familiar with JavaScript, youâ€™ll know this fails with an exception:<br><code>å¦‚æœæ‚¨ç†Ÿæ‚‰ JavaScriptï¼Œæ‚¨ä¼šçŸ¥é“è¿™ä¸ªå¤±è´¥äº†ä¸€ä¸ªå¼‚å¸¸ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; TypeError: message is not a function</code></pre>\n\n<p>Itâ€™d be great if we could avoid mistakes like this.<br><code>æˆ‘ä»¬åº”è¯¥èƒ½é¿å…è¿™æ ·çš„é”™è¯¯ã€‚</code><br>When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts of behaviors and capabilities it has. Thatâ€™s part of what that TypeError is alluding to - itâ€™s saying that the string â€œHello World!â€ cannot be called as a function.<br><code>å½“æˆ‘ä»¬è¿è¡Œæˆ‘ä»¬çš„ä»£ç ï¼Œæˆ‘ä»¬çš„ JavaScript è¿è¡Œæ—¶é€šè¿‡åˆ†æå€¼çš„ç±»å‹æ¥å†³å®šå¦‚ä½•åšã€‚è¿™æ˜¯å®ƒå¼•ç”¨çš„ TypeError çš„ä¸€éƒ¨åˆ† - å®ƒè¯´æ˜ &quot;Hello World!&quot; ä¸èƒ½è¢«è°ƒç”¨ä½œä¸ºå‡½æ•°ã€‚</code><br>For some values, such as the primitives string and number, we can identify their type at runtime using the typeof operator. But for other things like functions, thereâ€™s no corresponding runtime mechanism to identify their types. For example, consider this function:<br><code>å¯¹äºæŸäº›å€¼ï¼Œå¦‚å­—ç¬¦ä¸²å’Œæ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿è¡Œæ—¶é€šè¿‡ typeof æ“ä½œç¬¦æ¥è¯†åˆ«å®ƒçš„ç±»å‹ã€‚ä½†æ˜¯å¯¹äºå…¶ä»–çš„ä¸œè¥¿ï¼Œæ²¡æœ‰ç›¸åº”çš„è¿è¡Œæ—¶æœºåˆ¶æ¥è¯†åˆ«å®ƒä»¬çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬æ¥çœ‹è¿™ä¸ªå‡½æ•°ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function fn(x) &#123;\n  return x.flip();\n&#125;</code></pre>\n\n<p>We can observe by reading the code that this function will only work if given an object with a callable flip property, but JavaScript doesnâ€™t surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what fn does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what code will do before it runs, which means itâ€™s harder to know what your code is going to do while youâ€™re writing it.<br><code>æˆ‘ä»¬å¯ä»¥é€šè¿‡é˜…è¯»ä»£ç , çœ‹åˆ°è¿™ä¸ªå‡½æ•°åªæœ‰åœ¨ç»™å®šä¸€ä¸ªå¯è°ƒç”¨ flip å±æ€§çš„å¯¹è±¡æ—¶æ‰èƒ½å·¥ä½œï¼Œä½† JavaScript æ²¡æœ‰ä¸€ç§æ–¹å¼å¯ä»¥åœ¨è¿è¡Œä»£ç æ—¶æ¥è¯†åˆ« fn çš„è¡Œä¸ºã€‚åªæœ‰åœ¨è°ƒç”¨å®ƒæ—¶æ‰èƒ½çŸ¥é“ fn çš„è¡Œä¸ºï¼Œè¿™ç§è¡Œä¸ºéš¾ä»¥é¢„æµ‹ï¼Œè¿™æ„å‘³ç€åœ¨å†™ä»£ç æ—¶éš¾ä»¥çŸ¥é“ä½ çš„ä»£ç ä¼šåšä»€ä¹ˆã€‚</code><br>Seen in this way, a type is the concept of describing which values can be passed to fn and which will crash. JavaScript only truly provides dynamic typing - running the code to see what happens.<br><code>åœ¨è¿™ç§æ–¹å¼ä¸­ï¼Œä¸€ä¸ªç±»å‹æ˜¯æè¿°å“ªäº›å€¼å¯ä»¥ä¼ ç»™ fnï¼Œå“ªäº›ä¼šå´©æºƒçš„æ¦‚å¿µã€‚JavaScript åªæ˜¯æä¾›äº†åŠ¨æ€ç±»å‹å®šä¹‰ - è¿è¡Œä»£ç æ¥çœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚</code><br>The alternative is to use a static type system to make predictions about what code is expected before it runs.<br><code>å¦ä¸€ç§æ–¹å¼æ˜¯ä½¿ç”¨é™æ€ç±»å‹ç³»ç»Ÿæ¥é¢„æµ‹åœ¨è¿è¡Œä»£ç ä¹‹å‰ä¼šå‘ç”Ÿä»€ä¹ˆã€‚</code></p>\n<h2 id=\"Static-type-checking\"><a href=\"#Static-type-checking\" class=\"headerlink\" title=\"Static type-checking\"></a>Static type-checking</h2><p><code>é™æ€ç±»å‹æ£€æŸ¥</code><br>Think back to that TypeError we got earlier from trying to call a string as a function. Most people donâ€™t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.<br><code>æƒ³èµ·é‚£ä¸ª TypeError æˆ‘ä»¬ä»¥å‰ä»å°è¯•è°ƒç”¨ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå‡½æ•°æ—¶å¾—åˆ°çš„ã€‚å¤§å¤šæ•°äººä¸å–œæ¬¢åœ¨è¿è¡Œä»–ä»¬çš„ä»£ç æ—¶å¾—åˆ°ä»»ä½•ç±»å‹çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯è¢«ç§°ä¸º bugï¼è€Œå½“æˆ‘ä»¬å†™æ–°ä»£ç æ—¶ï¼Œæˆ‘ä»¬å°½å¯èƒ½åœ°é¿å…å¼•å…¥æ–°çš„ bugã€‚</code><br>If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but thatâ€™s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that weâ€™re forced to dig through.<br><code>å¦‚æœæˆ‘ä»¬æ·»åŠ äº›ç‚¹ä»£ç ï¼Œä¿å­˜æˆ‘ä»¬çš„æ–‡ä»¶ï¼Œé‡æ–°è¿è¡Œä»£ç ï¼Œå¹¶ç«‹å³çœ‹åˆ°é”™è¯¯ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¿«é€Ÿåœ°å‘ç°é—®é¢˜ï¼›ä½†è¿™å¹¶ä¸æ€»æ˜¯å¦‚æ­¤ã€‚æˆ‘ä»¬å¯èƒ½æ²¡æœ‰æµ‹è¯•ç‰¹æ€§çš„å……åˆ†ç¨‹åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯èƒ½æ²¡æœ‰çœŸæ­£å‘ç”Ÿå¯èƒ½ä¼šæŠ›å‡ºçš„é”™è¯¯ï¼æˆ–è€…å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿçœ‹åˆ°é”™è¯¯ï¼Œæˆ‘ä»¬å¯èƒ½å·²ç»åšäº†å¤§é‡çš„é‡æ„å’Œæ·»åŠ äº†å¾ˆå¤šä¸åŒçš„ä»£ç ï¼Œæˆ‘ä»¬è¢«è¿«è¦æ¢ç´¢å®ƒä»¬ã€‚</code><br>Ideally, we could have a tool that helps us find these bugs before our code runs. Thatâ€™s what a static type-checker like TypeScript does. Static types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.<br><code>æœ€å¥½çš„æ–¹å¼æ˜¯æˆ‘ä»¬å¯ä»¥åœ¨æˆ‘ä»¬çš„ä»£ç è¿è¡Œä¹‹å‰ï¼Œæœ‰ä¸€ä¸ªå·¥å…·å¸®æˆ‘ä»¬æ‰¾åˆ°è¿™äº› bugã€‚è¿™æ˜¯ TypeScript çš„é™æ€ç±»å‹æ£€æŸ¥å™¨åšçš„ã€‚é™æ€ç±»å‹ç³»ç»Ÿæè¿°äº†æˆ‘ä»¬çš„å€¼åœ¨è¿è¡Œæˆ‘ä»¬çš„ç¨‹åºæ—¶çš„å½¢çŠ¶å’Œè¡Œä¸ºã€‚ä¸€ä¸ªç±»å‹æ£€æŸ¥å™¨åƒ TypeScript ä½¿ç”¨è¿™äº›ä¿¡æ¯ï¼Œå‘Šè¯‰æˆ‘ä»¬å½“å¯èƒ½ä¼šå‡ºç°é—®é¢˜æ—¶ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const message &#x3D; &quot;hello!&quot;;\n\nmessage();\n&#x2F;&#x2F; This expression is not callable.\n&#x2F;&#x2F;   Type &#39;String&#39; has no call signatures.</code></pre>\n\n<p>Running that last sample with TypeScript will give us an error message before we run the code in the first place.<br><code>è¿è¡Œè¿™ä¸ªæœ€åä¸€ä¸ªç¤ºä¾‹ï¼ŒTypeScript å°†åœ¨ç¬¬ä¸€ä¸ªä»£ç ä¹‹å‰æŠ¥é”™ã€‚</code></p>\n<h2 id=\"Non-exception-Failures\"><a href=\"#Non-exception-Failures\" class=\"headerlink\" title=\"Non-exception Failures\"></a>Non-exception Failures</h2><p><code>éå¼‚å¸¸å¤±è´¥</code><br>So far weâ€™ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected.<br><code>ç›´åˆ°ç°åœ¨ï¼Œæˆ‘ä»¬éƒ½è®¨è®ºäº†ä¸€äº›å…³äºè¿è¡Œæ—¶é”™è¯¯çš„äº‹æƒ…ï¼Œæ¯”å¦‚è¯´ï¼Œå½“ JavaScript è¿è¡Œæ—¶è®¤ä¸ºæŸäº›ä¸œè¥¿æ˜¯æ— æ•ˆçš„ã€‚è¿™äº›æƒ…å†µå‡ºç°çš„åŸå› æ˜¯ ECMAScript è§„èŒƒæ˜ç¡®æŒ‡å‡ºäº†åœ¨è¿è¡Œæ—¶å¦‚ä½•åº”è¯¥è¡Œä¸ºã€‚</code><br>For example, the specification says that trying to call something that isnâ€™t callable should throw an error. Maybe that sounds like â€œobvious behaviorâ€, but you could imagine that accessing a property that doesnâ€™t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value undefined:<br><code>æ¯”å¦‚è¯´ï¼Œè§„èŒƒæŒ‡å‡ºäº†å°è¯•è°ƒç”¨ä¸å¯è°ƒç”¨çš„ä¸œè¥¿åº”è¯¥æŠ›å‡ºä¸€ä¸ªé”™è¯¯ã€‚å¯èƒ½ä¼šè®¤ä¸ºè¿™æ˜¯â€œæ˜æ˜¾çš„è¡Œä¸ºâ€ï¼Œä½†ä½ å¯ä»¥æƒ³è±¡ä¸€ä¸‹ï¼Œè®¿é—®ä¸€ä¸ªå¯¹è±¡ä¸Šä¸å­˜åœ¨çš„å±æ€§åº”è¯¥æŠ›å‡ºä¸€ä¸ªé”™è¯¯ã€‚è€Œ JavaScript ç»™æˆ‘ä»¬ä¸åŒçš„è¡Œä¸ºï¼Œè¿”å›å€¼ undefinedï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const user &#x3D; &#123;\n  name: &quot;Daniel&quot;,\n  age: 26,\n&#125;;\nuser.location; &#x2F;&#x2F; returns undefined</code></pre>\n\n<p>Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if itâ€™s â€œvalidâ€ JavaScript that wonâ€™t immediately throw an error. In TypeScript, the following code produces an error about location not being defined:<br><code>æœ€ç»ˆï¼Œä¸€ä¸ªé™æ€ç±»å‹ç³»ç»Ÿå¿…é¡»è¦åœ¨å®ƒçš„ç³»ç»Ÿä¸­ï¼Œå‘Šè¯‰æˆ‘ä»¬åº”è¯¥æŠŠå“ªäº›ä»£ç æ ‡è®°ä¸ºé”™è¯¯çš„ä»£ç ï¼Œå³ä½¿å®ƒæ˜¯â€œæœ‰æ•ˆçš„ JavaScriptâ€ï¼Œä¹Ÿä¸ä¼šç«‹å³æŠ›å‡ºé”™è¯¯ã€‚åœ¨ TypeScript ä¸­ï¼Œä¸‹é¢çš„ä»£ç ä¼šæŠ¥é”™ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const user &#x3D; &#123;\n  name: &quot;Daniel&quot;,\n  age: 26,\n&#125;;\n\nuser.location;\n&#x2F;&#x2F; Property &#39;location&#39; does not exist on type &#39;&#123; name: string; age: number; &#125;&#39;.</code></pre>\n\n<p>While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches a lot of legitimate bugs.<br><code>åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¿™æ„å‘³ç€ä¸€ä¸ªäº¤æ¢ï¼Œåœ¨ä½ èƒ½è¡¨è¾¾çš„èŒƒå›´å†…ï¼Œåœ¨ä½ çš„ç¨‹åºä¸­ï¼Œä½ å¯ä»¥æŠŠä¸€äº›æœ‰æ•ˆçš„ JavaScript æŠ›å‡ºé”™è¯¯ã€‚è€Œ TypeScript æ•è·å¾ˆå¤šæœ‰æ•ˆçš„é”™è¯¯ã€‚</code><br>For example: typos,<br><code>æ¯”å¦‚è¯´ï¼Œæ‹¼å†™é”™è¯¯ï¼Œ</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const announcement &#x3D; &quot;Hello World!&quot;;\n\n&#x2F;&#x2F; How quickly can you spot the typos?\nannouncement.toLocaleLowercase();\nannouncement.toLocalLowerCase();\n\n&#x2F;&#x2F; We probably meant to write this...\nannouncement.toLocaleLowerCase();</code></pre>\n\n<p>uncalled functions,<br><code>æœªè°ƒç”¨çš„å‡½æ•°ï¼Œ</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function flipCoin() &#123;\n  &#x2F;&#x2F; Meant to be Math.random()\n  return Math.random &lt; 0.5;\n  &#x2F;&#x2F; Operator &#39;&lt;&#39; cannot be applied to types &#39;() &#x3D;&gt; number&#39; and &#39;number&#39;.\n&#125;</code></pre>\n\n<p>or basic logic errors.<br><code>æˆ–åŸºæœ¬çš„é€»è¾‘é”™è¯¯ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const value &#x3D; Math.random() &lt; 0.5 ? &quot;a&quot; : &quot;b&quot;;\nif (value !&#x3D;&#x3D; &quot;a&quot;) &#123;\n  &#x2F;&#x2F; ...\n&#125; else if (value &#x3D;&#x3D;&#x3D; &quot;b&quot;) &#123;\n  &#x2F;&#x2F; This condition will always return &#39;false&#39; since the types &#39;&quot;a&quot;&#39; and &#39;&quot;b&quot;&#39; have no overlap.\n  &#x2F;&#x2F; Oops, unreachable\n&#125;</code></pre>\n\n<h2 id=\"Types-for-Tooling\"><a href=\"#Types-for-Tooling\" class=\"headerlink\" title=\"Types for Tooling\"></a>Types for Tooling</h2><p><code>ç±»å‹ä¸ºå·¥å…·</code><br>TypeScript can catch bugs when we make mistakes in our code. Thatâ€™s great, but TypeScript can also prevent us from making those mistakes in the first place.<br><code>TypeScript å¯ä»¥æ•è·æˆ‘ä»¬åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­åšé”™è¯¯çš„é”™è¯¯ã€‚è¿™å¾ˆå¥½ï¼Œä½† TypeScript å¯ä»¥é˜²æ­¢æˆ‘ä»¬åšé”™è¯¯ã€‚</code><br>The type-checker has information to check things like whether weâ€™re accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use.<br><code>ç±»å‹æ£€æŸ¥å™¨æœ‰ä¿¡æ¯æ¥æ£€æŸ¥å˜é‡å’Œå…¶ä»–å±æ€§æ˜¯å¦æ­£ç¡®ã€‚ä¸€æ—¦æœ‰è¿™äº›ä¿¡æ¯ï¼Œå®ƒä¹Ÿå¯ä»¥å¼€å§‹æå»ºè®®ä½ åº”è¯¥ä½¿ç”¨å“ªäº›å±æ€§ã€‚</code><br>That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. Thatâ€™s part of what people often refer to when they talk about tooling in TypeScript.<br><code>è¿™æ„å‘³ç€ TypeScript å¯ä»¥ç”¨äºç¼–è¾‘ä»£ç ï¼Œå¹¶ä¸”æ ¸å¿ƒç±»å‹æ£€æŸ¥å™¨å¯ä»¥æä¾›é”™è¯¯æ¶ˆæ¯å’Œä»£ç è¡¥å…¨ã€‚è¿™æ˜¯äººä»¬é€šå¸¸åœ¨è¯´è®¨è®ºå·¥å…·æ—¶æ‰€æåˆ°çš„ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import express from &quot;express&quot;;\nconst app &#x3D; express();\n\napp.get(&quot;&#x2F;&quot;, function (req, res) &#123;\n  res.sen\n    &#x2F;&#x2F; send\n    &#x2F;&#x2F; sendDate\n    &#x2F;&#x2F; sendfile\n    &#x2F;&#x2F; sendFile\n    &#x2F;&#x2F; sendStatus\n&#125;);\n\napp.</code></pre>\n\n<p>TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver â€œquick fixesâ€ to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so itâ€™s likely that your favorite editor has TypeScript support available.<br><code>TypeScript ä¹Ÿæ·±æ·±åœ°è®¤è¯†åˆ°å·¥å…·ï¼Œå¹¶ä¸”è¿™ä¹ŸåŒ…æ‹¬äº†å®Œæˆå’Œé”™è¯¯çš„è¡¥å…¨ï¼Œä½ åœ¨è¾“å…¥æ—¶å¯ä»¥è‡ªåŠ¨ä¿®å¤é”™è¯¯ï¼Œé‡æ–°ç»„ç»‡ä»£ç ï¼Œä»¥åŠå¯»æ‰¾å˜é‡çš„å®šä¹‰ï¼Œæˆ–å¯»æ‰¾æ‰€æœ‰å¼•ç”¨çš„å˜é‡ã€‚è¿™å…¨éƒ¨æ˜¯åŸºäºç±»å‹æ£€æŸ¥å™¨çš„ï¼Œå¹¶ä¸”æ˜¯å®Œå…¨çš„è·¨å¹³å°ï¼Œæ‰€ä»¥ä½ å¯èƒ½å–œæ¬¢çš„ç¼–è¾‘å™¨æœ‰ TypeScript çš„æ”¯æŒã€‚</code></p>\n<h2 id=\"tsc-the-TypeScript-compiler\"><a href=\"#tsc-the-TypeScript-compiler\" class=\"headerlink\" title=\"tsc, the TypeScript compiler\"></a>tsc, the TypeScript compiler</h2><p><code>tsc</code>ï¼ŒTypeScript ç¼–è¯‘å™¨<br>Weâ€™ve been talking about type-checking, but we havenâ€™t yet used our type-checker. Letâ€™s get acquainted with our new friend tsc, the TypeScript compiler. First weâ€™ll need to grab it via npm.<br><code>æˆ‘ä»¬å·²ç»è®²è¿°äº†ç±»å‹æ£€æŸ¥ï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰ä½¿ç”¨æˆ‘ä»¬çš„ç±»å‹æ£€æŸ¥å™¨ã€‚æˆ‘ä»¬éœ€è¦é€šè¿‡ npm æ¥è·å– tscï¼ŒTypeScript ç¼–è¯‘å™¨ã€‚</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install -g typescript</code></pre>\n\n<p>This installs the TypeScript Compiler tsc globally. You can use npx or similar tools if youâ€™d prefer to run tsc from a local node_modules package instead.<br><code>è¿™å°†å®‰è£… TypeScript ç¼–è¯‘å™¨ tsc åœ¨å…¨å±€ã€‚å¦‚æœä½ æƒ³ä»æœ¬åœ°çš„ node_modules åŒ…é‡Œè¿è¡Œ tscï¼Œå¯ä»¥ä½¿ç”¨ npx æˆ–ç±»ä¼¼çš„å·¥å…·ã€‚</code><br>Now letâ€™s move to an empty folder and try writing our first TypeScript program: hello.ts:<br><code>ç°åœ¨æˆ‘ä»¬ç§»åŠ¨åˆ°ä¸€ä¸ªç©ºæ–‡ä»¶å¤¹ï¼Œå¹¶å°è¯•å†™æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ª TypeScript ç¨‹åºï¼šhello.tsï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Greets the world.\nconsole.log(&quot;Hello world!&quot;);</code></pre>\n\n<p>Notice there are no frills here; this â€œhello worldâ€ program looks identical to what youâ€™d write for a â€œhello worldâ€ program in JavaScript. And now letâ€™s type-check it by running the command tsc which was installed for us by the typescript package.<br><code>é€šè¿‡è¿è¡Œ tsc å‘½ä»¤ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥æˆ‘ä»¬çš„ç¨‹åºã€‚</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tsc hello.ts\n</code></pre>\n\n<p>Tada!<br><code>æ‹æ‹æ‹ï¼</code><br>Wait, â€œtadaâ€ what exactly? We ran tsc and nothing happened! Well, there were no type errors, so we didnâ€™t get any output in our console since there was nothing to report.<br><code>ç­‰ç­‰ï¼Œâ€œæ‹æ‹æ‹â€ï¼Œä»€ä¹ˆæ„æ€ï¼Ÿæˆ‘ä»¬è¿è¡Œ tscï¼Œæ²¡æœ‰ä»»ä½•äº‹æƒ…å‘ç”Ÿï¼</code><br>But check again - we got some file output instead. If we look in our current directory, weâ€™ll see a hello.js file next to hello.ts. Thatâ€™s the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file. And if we check the contents, weâ€™ll see what TypeScript spits out after it processes a .ts file:<br><code>ä½†å†æ£€æŸ¥ä¸€æ¬¡ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ä¸€ä¸ª hello.js æ–‡ä»¶ï¼Œå®ƒåœ¨ hello.ts åé¢ã€‚è¿™æ˜¯ tsc ç¼–è¯‘æˆ–è½¬æ¢æˆä¸€ä¸ªçº¯ JavaScript æ–‡ä»¶çš„ hello.ts çš„è¾“å‡ºã€‚å¦‚æœæˆ‘ä»¬æ£€æŸ¥å†…å®¹ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ° TypeScript åœ¨å¤„ç† .ts æ–‡ä»¶åæ‰“å°å‡ºæ¥çš„å†…å®¹ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Greets the world.\nconsole.log(&quot;Hello world!&quot;);</code></pre>\n\n<p>In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While thatâ€™s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.<br><code>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒTypeScript å°è¯•è¾“å‡ºä¸€ä¸ªæ¸…æ´çš„å¯è¯»ä»£ç ï¼Œçœ‹èµ·æ¥åƒä¸€ä¸ªäººå†™çš„ä»£ç ã€‚è¿™å¹¶ä¸æ€»æ˜¯å¦‚æ­¤ç®€å•ï¼ŒTypeScript ç¼©è¿›ä¸€è‡´ï¼Œæ³¨æ„ä»£ç çš„ä¸åŒè¡Œï¼Œå¹¶å°è¯•ä¿æŒæ³¨é‡Šåœ¨åŒä¸€è¡Œã€‚</code><br>What about if we did introduce a type-checking error? Letâ€™s rewrite hello.ts:<br><code>å¦‚æœæˆ‘ä»¬æŠŠ hello.ts ä¸­çš„ console.log æ”¹æˆ console.logsï¼Œæˆ‘ä»¬ä¼šå‘ç°ä»€ä¹ˆï¼Ÿæˆ‘ä»¬å†æ¬¡é‡å†™ hello.tsï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; This is an industrial-grade general-purpose greeter function:\nfunction greet(person, date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date&#125;!&#96;);\n&#125;\n\ngreet(&quot;Brendan&quot;);</code></pre>\n\n<p>If we run tsc hello.ts again, notice that we get an error on the command line!<br><code>å¦‚æœæˆ‘ä»¬è¿è¡Œ tsc hello.ts å†æ¬¡ï¼Œæˆ‘ä»¬ä¼šå‘ç°åœ¨å‘½ä»¤è¡Œä¸Šå‡ºç°ä¸€ä¸ªé”™è¯¯ï¼</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">Expected 2 arguments, but got 1.</code></pre>\n\n<p>TypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so. So far weâ€™ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!<br><code>TypeScript æé†’æˆ‘ä»¬æ²¡æœ‰ä¼ é€’å‚æ•°ç»™ greet å‡½æ•°ï¼Œå¹¶ä¸”æ­£ç¡®åœ°ã€‚ç›´åˆ°ç°åœ¨ï¼Œæˆ‘ä»¬åªå†™äº†æ ‡å‡† JavaScriptï¼Œç„¶è€Œç±»å‹æ£€æŸ¥ä»ç„¶å¯ä»¥æ‰¾åˆ°æˆ‘ä»¬çš„ä»£ç çš„é—®é¢˜ã€‚æ„Ÿè°¢ TypeScriptï¼</code></p>\n<h2 id=\"Emitting-with-Errors\"><a href=\"#Emitting-with-Errors\" class=\"headerlink\" title=\"Emitting with Errors\"></a>Emitting with Errors</h2><p><code>å‘å°„é”™è¯¯</code><br>One thing you might not have noticed from the last example was that our hello.js file changed again. If we open that file up then weâ€™ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScriptâ€™s core values: much of the time, you will know better than TypeScript.<br><code>ä¸€ä¸ªä½ å¯èƒ½æ²¡æœ‰æ³¨æ„åˆ°çš„äº‹æƒ…æ˜¯ï¼Œæˆ‘ä»¬çš„ hello.js æ–‡ä»¶å˜äº†ä¸€æ¬¡ã€‚å¦‚æœæˆ‘ä»¬æ‰“å¼€è¿™ä¸ªæ–‡ä»¶ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°å®ƒçš„å†…å®¹ä»ç„¶åŸºæœ¬å’Œæˆ‘ä»¬çš„è¾“å…¥æ–‡ä»¶ä¸€æ ·ã€‚è¿™å¯èƒ½æ˜¯ä¸€ä¸ªå¾ˆç³Ÿçš„æƒ…å†µï¼Œå› ä¸º tsc æŠ¥å‘Šäº†æˆ‘ä»¬çš„ä»£ç çš„é”™è¯¯ï¼Œä½†è¿™æ˜¯åŸºäº TypeScript çš„æ ¸å¿ƒå€¼ï¼šå¾ˆå¤šæ—¶å€™ï¼Œä½ ä¼šæ›´äº†è§£æ›´å¤šçš„äº‹æƒ…ã€‚</code><br>To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so thereâ€™s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time thatâ€™s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually youâ€™ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?<br><code>é‡å¤ä¸Šä¸€æ®µå†…å®¹ï¼Œç±»å‹æ£€æŸ¥ä»£ç é™åˆ¶äº†ä½ å¯ä»¥è¿è¡Œçš„ç¨‹åºï¼Œå› æ­¤æœ‰ä¸€ä¸ªäº¤æ¢ï¼Œå¦‚æœä½ çš„ç±»å‹æ£€æŸ¥å™¨æ‰¾åˆ°äº†å¯æ¥å—çš„ä¸œè¥¿ï¼Œé‚£ä¹ˆä½ å¯ä»¥è¿è¡Œå®ƒã€‚ä½†æ˜¯ï¼Œæœ‰æ—¶å€™ï¼Œè¿™äº›æ£€æŸ¥ä¼šæ‹–æ…¢ä½ çš„ç¨‹åºã€‚ä¾‹å¦‚ï¼Œå‡è®¾ä½ æ˜¯ä¸€ä¸ª JavaScript çš„ç§»æ¤è€…ï¼Œå¹¶ä¸”ä½ æŠŠç±»å‹æ£€æŸ¥é”™è¯¯æ’å…¥åˆ°ä½ çš„ä»£ç ä¸­ã€‚æœ€ç»ˆï¼Œä½ ä¼šæŠŠå®ƒä»¬æ¸…ç†æ‰ï¼Œä½†æ˜¯åŸæ¥çš„ JavaScript ä»£ç å·²ç»å·²ç»æ­£å¸¸è¿è¡Œäº†ï¼ä¸ºä»€ä¹ˆä½ ä¼šæŠŠå®ƒç§»æ¤åˆ° TypeScript ä¸­ï¼Œç„¶ååœæ­¢è¿è¡Œå®ƒï¼Ÿ</code><br>So TypeScript doesnâ€™t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. Try changing your hello.ts file and running tsc with that flag:<br><code>å› æ­¤ï¼ŒTypeScript ä¸ä¼šæ‹–æ…¢ä½ ã€‚ä½†æ˜¯ï¼Œéšç€æ—¶é—´çš„æ¨ç§»ï¼Œä½ å¯èƒ½ä¼šæƒ³è¦æ›´åŠ å®‰å…¨ï¼Œå¹¶ä¸”ä½¿ TypeScript å˜å¾—æ›´ä¸¥æ ¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ noEmitOnError ç¼–è¯‘å™¨é€‰é¡¹ã€‚è¯•ç€æŠŠ hello.ts æ–‡ä»¶ä¸­çš„ä»£ç æ”¹ä¸€ä¸‹ï¼Œç„¶åè¿è¡Œ tsc å¹¶ä¸”ä½¿ç”¨è¿™ä¸ªé€‰é¡¹ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">tsc --noEmitOnError hello.ts</code></pre>\n\n<p>Youâ€™ll notice that hello.js never gets updated.<br><code>hello.js ä¸ä¼šè¢«æ›´æ–°ã€‚</code></p>\n<h2 id=\"Explicit-Types\"><a href=\"#Explicit-Types\" class=\"headerlink\" title=\"Explicit Types\"></a>Explicit Types</h2><p><code>æ˜¾å¼ç±»å‹</code><br>Up until now, we havenâ€™t told TypeScript what person or date are. Letâ€™s edit the code to tell TypeScript that person is a string, and that date should be a Date object. Weâ€™ll also use the toDateString() method on date.<br><code>ç›´åˆ°ç°åœ¨ï¼Œæˆ‘ä»¬éƒ½æ²¡æœ‰å‘Šè¯‰ TypeScript ä»€ä¹ˆæ˜¯äººæˆ–æ—¥æœŸã€‚æˆ‘ä»¬ç°åœ¨ç¼–è¾‘ä»£ç ï¼Œè®© TypeScript çŸ¥é“ person æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè€Œ date åº”è¯¥æ˜¯ä¸€ä¸ª Date å¯¹è±¡ã€‚æˆ‘ä»¬ä¹Ÿä½¿ç”¨ date çš„ toDateString() æ–¹æ³•ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function greet(person: string, date: Date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;</code></pre>\n\n<p>What we did was add type annotations on person and date to describe what types of values greet can be called with. You can read that signature as â€greet takes a person of type string, and a date of type Dateâ€œ.<br><code>æˆ‘ä»¬åšäº†ä¸€ä¸ªç±»å‹æ ‡æ³¨ï¼Œè®© TypeScript çŸ¥é“ greet å¯ä»¥è¢«è°ƒç”¨çš„æ—¶å€™ï¼Œperson çš„ç±»å‹æ˜¯ stringï¼Œè€Œ date çš„ç±»å‹æ˜¯ Dateã€‚</code><br>With this, TypeScript can tell us about other cases where greet might have been called incorrectly. For exampleâ€¦<br><code>è¿™æ ·ï¼ŒTypeScript å¯ä»¥å‘Šè¯‰æˆ‘ä»¬å…¶ä»–æƒ…å†µä¸‹ greet å¯èƒ½ä¼šè¢«è°ƒç”¨é”™è¯¯ã€‚ä¾‹å¦‚â€¦</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function greet(person: string, date: Date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;\ngreet(&quot;Maddison&quot;, Date());\n&#x2F;&#x2F; Argument of type &#39;string&#39; is not assignable to parameter of type &#39;Date&#39;.</code></pre>\n\n<p>Huh? TypeScript reported an error on our second argument, but why?<br><code>å“ï¼ŸTypeScript åœ¨ç¬¬äºŒä¸ªå‚æ•°ä¸ŠæŠ¥é”™äº†ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆï¼Ÿ</code><br>Perhaps surprisingly, calling Date() in JavaScript returns a string. On the other hand, constructing a Date with new Date() actually gives us what we were expecting.<br><code>å¯èƒ½å°±æ˜¯å› ä¸º JavaScript ä¸­çš„ Date() è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè€Œ new Date() åˆ™ä¼šè¿”å›æˆ‘ä»¬æœŸæœ›çš„ç»“æœã€‚</code><br>Anyway, we can quickly fix up the error:<br><code>ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å¿«é€Ÿä¿®å¤é”™è¯¯ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function greet(person: string, date: Date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;\n\ngreet(&quot;Maddison&quot;, new Date());</code></pre>\n\n<p>Keep in mind, we donâ€™t always have to write explicit type annotations. In many cases, TypeScript can even just infer (or â€œfigure outâ€) the types for us even if we omit them.<br><code>è®°ä½ï¼Œæˆ‘ä»¬ä¸æ˜¯æ€»æ˜¯è¦å†™æ˜ç±»å‹æ ‡æ³¨ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒTypeScript ä¹Ÿå¯ä»¥è‡ªåŠ¨æ¨æ–­ï¼ˆæˆ–è€…è¯´è®¤ä¸ºï¼‰ç±»å‹ï¼Œå³ä½¿æˆ‘ä»¬æ²¡æœ‰å†™æ˜ç±»å‹æ ‡æ³¨ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">let msg &#x3D; &quot;hello there!&quot;;\n\nlet msg: string;</code></pre>\n\n<p>Even though we didnâ€™t tell TypeScript that msg had the type string it was able to figure that out. Thatâ€™s a feature, and itâ€™s best not to add annotations when the type system would end up inferring the same type anyway.<br><code>å³ä½¿æˆ‘ä»¬æ²¡æœ‰å‘Šè¯‰ TypeScript msg çš„ç±»å‹æ˜¯ stringï¼Œå®ƒä¹Ÿèƒ½å¤Ÿè‡ªåŠ¨æ¨æ–­å‡ºæ¥ã€‚è¿™æ˜¯ä¸€ä¸ªç‰¹æ€§ï¼Œå¹¶ä¸”å½“ç±»å‹ç³»ç»Ÿè‡ªåŠ¨æ¨æ–­å‡ºç›¸åŒç±»å‹çš„æ—¶å€™ï¼Œä¸è¦å†™æ˜ç±»å‹æ ‡æ³¨ã€‚</code><br>:::tip</p>\n<p>the message bubble inside the code sample above. That is what your editor would show if you had hovered over the word.<br><code>åœ¨ä¸Šé¢çš„ä»£ç æ®µä¸­ï¼Œä½ çš„ç¼–è¾‘å™¨ä¼šæ˜¾ç¤ºä¸€ä¸ªæ¶ˆæ¯æ³¡ã€‚å¦‚æœä½ é¼ æ ‡æ‚¬åœåœ¨è¿™ä¸ªå•è¯ä¸Šï¼Œé‚£ä¹ˆä½ çš„ç¼–è¾‘å™¨ä¼šæ˜¾ç¤ºè¿™ä¸ªæ¶ˆæ¯æ³¡ã€‚</code><br>:::</p>\n<h2 id=\"Erased-Types\"><a href=\"#Erased-Types\" class=\"headerlink\" title=\"Erased Types\"></a>Erased Types</h2><p><code>æ“¦é™¤ç±»å‹</code><br>Letâ€™s take a look at what happens when we compile the above function greet with tsc to output JavaScript:<br><code>æˆ‘ä»¬çœ‹çœ‹å¦‚æœæˆ‘ä»¬ç”¨ tsc ç¼–è¯‘ä¸Šé¢çš„å‡½æ•° greetï¼Œå®ƒä¼šè¾“å‡º JavaScript ä»£ç ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&quot;use strict&quot;;\nfunction greet(person, date) &#123;\n  console.log(\n    &quot;Hello &quot;.concat(person, &quot;, today is &quot;).concat(date.toDateString(), &quot;!&quot;)\n  );\n&#125;\ngreet(&quot;Maddison&quot;, new Date());</code></pre>\n\n<p>Notice two things here:<br><code>æ³¨æ„è¿™é‡Œæœ‰ä¸¤ä»¶äº‹æƒ…ï¼š</code><br>Our person and date parameters no longer have type annotations.<br><code>æˆ‘ä»¬çš„ person å’Œ date å‚æ•°æ²¡æœ‰ç±»å‹æ ‡æ³¨ã€‚</code><br>Our â€œtemplate stringâ€ - that string that used backticks (the <code>character) - was converted to plain strings with concatenations (+).</code>æˆ‘ä»¬çš„æ¨¡æ¿å­—ç¬¦ä¸²ï¼ˆä½¿ç”¨ å­—ç¬¦ï¼‰å·²ç»è¢«è½¬æ¢æˆäº†çº¯å­—ç¬¦ä¸²ï¼Œå¹¶ä¸”ä½¿ç”¨äº† + å­—ç¬¦ä¸²è¿æ¥ã€‚<code>More on that second point later, but letâ€™s now focus on that first point. Type annotations arenâ€™t part of JavaScript (or ECMAScript to be pedantic), so there really arenâ€™t any browsers or other runtimes that can just run TypeScript unmodified. Thatâ€™s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.</code>TypeScript ä¸æ˜¯ JavaScriptï¼ˆæˆ–è€…è¯´ ECMAScriptï¼‰çš„ä¸€éƒ¨åˆ†ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰æµè§ˆå™¨æˆ–å…¶ä»–è¿è¡Œæ—¶å¯ä»¥ç›´æ¥è¿è¡Œ TypeScript çš„æƒ…å†µã€‚å› æ­¤ TypeScript éœ€è¦ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥å»æ‰æˆ–è½¬æ¢ TypeScript çš„ä»»ä½•ç‰¹å®šä»£ç ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥è¿è¡Œå®ƒã€‚å¤§å¤šæ•° TypeScript ç‰¹å®šä»£ç éƒ½ä¼šè¢«å»æ‰ï¼Œåä¹‹ï¼Œè¿™é‡Œçš„ç±»å‹æ ‡æ³¨ä¹Ÿä¼šè¢«å»æ‰ã€‚&#96;</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>Remember: Type annotations never change the runtime behavior of your program.<br><code>è®°ä½ï¼šç±»å‹æ ‡æ³¨ä¸ä¼šæ”¹å˜ä½ çš„ç¨‹åºçš„è¿è¡Œæ—¶è¡Œä¸ºã€‚</code>\n</div>\n<h2 id=\"Downleveling\"><a href=\"#Downleveling\" class=\"headerlink\" title=\"Downleveling\"></a>Downleveling</h2><p><code>é™çº§</code><br>One other difference from the above was that our template string was rewritten from<br><code>æˆ‘ä»¬çš„æ¨¡æ¿å­—ç¬¦ä¸²æ˜¯ä»</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;;</code></pre>\n\n<p>to</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&quot;Hello &quot; + person + &quot;, today is &quot; + date.toDateString() + &quot;!&quot;;</code></pre>\n\n<p>Why did this happen?<br><code>ä¸ºä»€ä¹ˆè¿™æ ·å‘ç”Ÿäº†ï¼Ÿ</code><br>Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - donâ€™t ask). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or â€œhigherâ€ version of ECMAScript down to an older or â€œlowerâ€ one is sometimes called downleveling.<br><code>æ¨¡æ¿å­—ç¬¦ä¸²æ˜¯ ECMAScript 2015 çš„ä¸€ä¸ªç‰¹æ€§ï¼ˆæˆ–è€…è¯´ ECMAScript 6ï¼ŒES2015ï¼ŒES6 ç­‰ï¼‰ã€‚TypeScript æœ‰èƒ½åŠ›å°†ä»æ›´æ–°çš„ ECMAScript ç§»åˆ°æ›´æ—§çš„ ECMAScriptï¼Œæ¯”å¦‚ ECMAScript 3 æˆ– ECMAScript 5ï¼ˆæˆ–è€…è¯´ ES3 å’Œ ES5ï¼‰ã€‚è¿™ç§ç§»åŠ¨çš„è¿‡ç¨‹ç§°ä¸ºé™çº§ã€‚</code><br>By default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with â€“target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running tsc â€“target es2015 hello.ts gives us the following output:<br><code>é»˜è®¤æƒ…å†µä¸‹ï¼ŒTypeScript ç›®æ ‡ ES3ï¼Œä¸€ä¸ªéå¸¸è€çš„ ECMAScript ç‰ˆæœ¬ã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸€ä¸ªæ›´æ–°çš„ç‰ˆæœ¬ï¼Œä½¿ç”¨ target é€‰é¡¹ã€‚è¿è¡Œ tsc --target es2015 hello.ts å°±ä¼šå¾—åˆ°ä»¥ä¸‹çš„è¾“å‡ºï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function greet(person, date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;\ngreet(&quot;Maddison&quot;, new Date());</code></pre>\n\n<p>While the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.<br><code>é»˜è®¤ç›®æ ‡æ˜¯ ES3ï¼Œå¤§å¤šæ•°å½“å‰æµè§ˆå™¨éƒ½æ”¯æŒ ES2015ã€‚å¤§å¤šæ•°å¼€å‘äººå‘˜å¯ä»¥å®‰å…¨åœ°æŒ‡å®š ES2015 æˆ–ä»¥ä¸Šä½œä¸ºç›®æ ‡ï¼Œé™¤ééœ€è¦ä¸æŸäº›å¤è€çš„æµè§ˆå™¨å…¼å®¹ã€‚</code></p>\n<h2 id=\"Strictness\"><a href=\"#Strictness\" class=\"headerlink\" title=\"Strictness\"></a>Strictness</h2><p><code>ä¸¥æ ¼</code><br>Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and thereâ€™s no checking for potentially null&#x2F;undefined values. Much like how tsc emits in the face of errors, these defaults are put in place to stay out of your way. If youâ€™re migrating existing JavaScript, that might be a desirable first step.<br><code>ä¸åŒçš„ç”¨æˆ·åˆ° TypeScript ä¸Šæ¥çœ‹ï¼Œæœ‰ä¸åŒçš„æ„å›¾ã€‚æœ‰äººæƒ³è¦ä¸€ä¸ªæ›´å®½æ¾çš„é€‰æ‹©ï¼Œè¿™å¯ä»¥å¸®åŠ©éªŒè¯æŸäº›éƒ¨åˆ†çš„ç¨‹åºï¼Œå¹¶ä¸”ä»ç„¶æœ‰å¾ˆå¥½çš„å·¥å…·ã€‚è¿™æ˜¯ TypeScript é»˜è®¤çš„è¡Œä¸ºï¼Œå…¶ä¸­ç±»å‹æ˜¯å¯é€‰çš„ï¼Œæ¨æ–­ä¼šæ¥å—æ›´å®½æ¾çš„ç±»å‹ï¼Œå¹¶ä¸”æ²¡æœ‰æ£€æŸ¥å¯èƒ½ null/undefined çš„å€¼ã€‚å’Œ tsc åœ¨å‡ºç°é”™è¯¯çš„æ—¶å€™ä¸€æ ·ï¼Œè¿™äº›é»˜è®¤å€¼è¢«æ”¾åœ¨äº†ä½ çš„è„šè·Ÿä¸Šï¼ˆå…œåº•ï¼šè¿™äº›é»˜è®¤é€‰é¡¹å¹¶ä¸ä¼šé˜»ç¢ä½ çš„å¼€å‘ï¼‰ã€‚å¦‚æœä½ æ­£åœ¨è¿ç§»å·²æœ‰çš„ JavaScriptï¼Œé‚£ä¹ˆè¿™å¯èƒ½æ˜¯ä¸€ä¸ªæœ€ä½³çš„ç¬¬ä¸€æ­¥ã€‚</code><br>In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and thatâ€™s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.<br><code>ä¸åŒçš„ç”¨æˆ·å–œæ¬¢ç«‹åˆ»éªŒè¯ç¨‹åºï¼Œè€Œä¸æ˜¯ç­‰åˆ°æœ€åã€‚è¿™æ˜¯ TypeScript çš„è¯­è¨€æä¾›äº†ä¸¥æ ¼æ€§è®¾ç½®ï¼Œè¿™äº›è®¾ç½®å¯ä»¥æ”¹å˜é™æ€ç±»å‹æ£€æŸ¥çš„è¡Œä¸ºã€‚è¿™äº›è®¾ç½®å¯ä»¥æ”¹å˜é™æ€ç±»å‹æ£€æŸ¥çš„è¡Œä¸ºï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå¼€å…³ã€‚è¿™äº›è®¾ç½®è¶Šé«˜ï¼ŒTypeScript è¶Šä¼šæ£€æŸ¥æ›´å¤šçš„ä¿¡æ¯ã€‚è¿™å¯èƒ½éœ€è¦ä¸€ç‚¹é¢å¤–çš„å·¥ä½œï¼Œä½†ä¸€èˆ¬æ¥è¯´ï¼Œè¿™èƒ½æä¾›æ›´å¥½çš„å·¥å…·ï¼Œå¹¶ä¸”èƒ½æ›´å¥½åœ°æ”¯æŒä½ çš„ä»£ç ã€‚å½“å¯èƒ½çš„æ—¶å€™ï¼Œä¸€ä¸ªæ–°çš„ä»£ç åº”è¯¥æ€»æ˜¯å¼€å¯è¿™äº›ä¸¥æ ¼æ€§æ£€æŸ¥ã€‚</code><br>TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The strict flag in the CLI, or â€œstrictâ€: true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks.<br><code>TypeScript æœ‰å¤šä¸ªä¸¥æ ¼æ€§æ ‡å¿—ï¼Œå¯ä»¥å¼€å¯æˆ–å…³é—­ï¼Œæ‰€æœ‰çš„ç¤ºä¾‹éƒ½å°†ä½¿ç”¨æ‰€æœ‰çš„æ ‡å¿—ï¼Œé™¤éç‰¹åˆ«è¯´æ˜ã€‚CLI ä¸­çš„ strict å¼€å…³ï¼Œæˆ– tsconfig.json ä¸­çš„ strict: true å¼€å¯äº†æ‰€æœ‰çš„æ ‡å¿—ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥å•ç‹¬å…³é—­å®ƒä»¬ã€‚ä¸¤ä¸ªæœ€å¤§çš„ï¼Œä½ åº”è¯¥çŸ¥é“çš„æ˜¯ noImplicitAny å’Œ strictNullChecksã€‚</code></p>\n<h2 id=\"noImplicitAny\"><a href=\"#noImplicitAny\" class=\"headerlink\" title=\"noImplicitAny\"></a>noImplicitAny</h2><p><code>æ— éšå¼any</code><br>Recall that in some places, TypeScript doesnâ€™t try to infer types for us and instead falls back to the most lenient type: any. This isnâ€™t the worst thing that can happen - after all, falling back to any is just the plain JavaScript experience anyway.<br><code>åœ¨æŸäº›åœ°æ–¹ï¼ŒTypeScript ä¸ä¼šä¸ºæˆ‘ä»¬è‡ªåŠ¨æ¨æ–­ç±»å‹ï¼Œè€Œæ˜¯ä½¿ç”¨æœ€å®½æ¾çš„ç±»å‹ï¼šanyã€‚è¿™å¹¶ä¸æ˜¯æœ€å·®çš„æƒ…å†µï¼Œå› ä¸ºä»ç„¶æ˜¯ JavaScript çš„ç»éªŒã€‚</code><br>However, using any often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling youâ€™ll get, meaning youâ€™ll run into fewer bugs as you code. Turning on the noImplicitAny flag will issue an error on any variables whose type is implicitly inferred as any.<br><code>ä½¿ç”¨ any å¾ˆå®¹æ˜“è®©ä½ çš„ç¨‹åºå˜å¾—æ›´åŠ ä¸å¯é ã€‚å› ä¸ºæ›´åŠ ç±»å‹åŒ–çš„ç¨‹åºï¼Œä½ ä¼šå‘ç°æ›´å¤šçš„é”™è¯¯ï¼Œå¹¶ä¸”æ›´åŠ å®¹æ˜“åœ°è°ƒè¯•ã€‚å¼€å¯ noImplicitAny æ ‡å¿—ä¼šåœ¨ä»»ä½•è‡ªåŠ¨æ¨æ–­ç±»å‹ä¸º any çš„å˜é‡ä¸Šå‘å‡ºé”™è¯¯ã€‚</code></p>\n<h2 id=\"strictNullChecks\"><a href=\"#strictNullChecks\" class=\"headerlink\" title=\"strictNullChecks\"></a>strictNullChecks</h2><p><code>ä¸¥æ ¼null</code><br>By default, values like null and undefined are assignable to any other type. This can make writing some code easier, but forgetting to handle null and undefined is the cause of countless bugs in the world - some consider it<code> a billion dollar mistake!</code> The <code>strictNullChecks</code> flag makes handling null and undefined more explicit, and spares us from worrying about whether we forgot to handle null and undefined.<br><code>é»˜è®¤æƒ…å†µä¸‹ï¼Œnull å’Œ undefined å¯ä»¥èµ‹å€¼ç»™ä»»ä½•ç±»å‹ã€‚è¿™å¯ä»¥è®©å†™ä¸€äº›ä»£ç æ›´å®¹æ˜“ï¼Œä½†æ˜¯å¿˜è®°å¤„ç† null å’Œ undefined å°±ä¼šå¯¼è‡´ä¸–ç•Œä¸Šçš„å¾ˆå¤šé”™è¯¯ï¼Œæœ‰äººè®¤ä¸ºè¿™æ˜¯ä¸€ç™¾äº¿ç¾å…ƒé”™è¯¯ï¼ strictNullChecks å¯ä»¥è®©å¤„ç† null å’Œ undefined æ›´åŠ æ˜ç¡®ï¼Œå¹¶ä¸”è®©æˆ‘ä»¬ä¸ç”¨æ‹…å¿ƒæ˜¯å¦å¿˜è®°å¤„ç† null å’Œ undefinedã€‚</code></p>\n<h2 id=\"å‚è€ƒé“¾æ¥\"><a href=\"#å‚è€ƒé“¾æ¥\" class=\"headerlink\" title=\"å‚è€ƒé“¾æ¥\"></a>å‚è€ƒé“¾æ¥</h2><p><a href=\"https://www.typescriptlang.org/docs/handbook/2/basic-types.html#static-type-checking\">Typescript The Basics</a></p>\n","text":"The BasicsWelcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the ...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"typescript","slug":"typescript","count":9,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":9,"path":"api/tags/typescript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#The-Basics\"><span class=\"toc-text\">The Basics</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Static-type-checking\"><span class=\"toc-text\">Static type-checking</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Non-exception-Failures\"><span class=\"toc-text\">Non-exception Failures</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Types-for-Tooling\"><span class=\"toc-text\">Types for Tooling</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#tsc-the-TypeScript-compiler\"><span class=\"toc-text\">tsc, the TypeScript compiler</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Emitting-with-Errors\"><span class=\"toc-text\">Emitting with Errors</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Explicit-Types\"><span class=\"toc-text\">Explicit Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Erased-Types\"><span class=\"toc-text\">Erased Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Downleveling\"><span class=\"toc-text\">Downleveling</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Strictness\"><span class=\"toc-text\">Strictness</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#noImplicitAny\"><span class=\"toc-text\">noImplicitAny</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#strictNullChecks\"><span class=\"toc-text\">strictNullChecks</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">å‚è€ƒé“¾æ¥</span></a></li></ol>","author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"3.Typescript å¸¸è§ç±»å‹","uid":"746ca231a136437ea4011b4445608ad1","slug":"2022-06-08ts-Everyday Types","date":"2022-06-06T08:40:41.000Z","updated":"2022-06-09T13:53:32.969Z","comments":true,"path":"api/articles/2022-06-08ts-Everyday Types.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"Everyday Typeså¸¸è§ç±»å‹In this chapter, weâ€™ll cover some of the most common types of values youâ€™ll find in JavaScript code, and explain the corre...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"27 mins."},"categories":[{"name":"typescript","slug":"typescript","count":9,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":9,"path":"api/tags/typescript.json"}],"author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"1.Typescriptèµ·æ­¥","uid":"bb89616b2d7e7f4e050ed00ae2d71539","slug":"2022-06-08ts-start","date":"2022-06-06T01:58:32.000Z","updated":"2022-06-09T13:53:32.972Z","comments":true,"path":"api/articles/2022-06-08ts-start.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"è¯´æ˜æ­¤æ–‡åŠåç»­çš„å‡ ç¯‡æ˜¯å¯¹Typescriptå®˜æ–¹åŸæ–‡çš„ç¿»è¯‘ï¼Œæ–¹ä¾¿é˜…è¯» Get Startedtypescript èµ·æ­¥ï¼Œåˆ†åˆ«é’ˆå¯¹ 4 ç±»ä¸åŒçš„ç¨‹åºå¼€å‘è€…è¿›è¡Œå¼•å¯¼ï¼Œ å¯¹å·å…¥åº§ æ–°æ‰‹ç¨‹åºçŒ¿ï¼Œæ²¡æœ‰æ¥è§¦è¿‡ä»»ä½•å¼€å‘è¯­è¨€ JS å¼€å‘è€… Java&#x2F;C#å¼€å‘ [è·³è¿‡] å‡½æ•°å¼ç¼–ç¨‹äººå‘˜ ...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"typescript","slug":"typescript","count":9,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":9,"path":"api/tags/typescript.json"}],"author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}