{"title":"React@16、17 杂货","uid":"7914c7b61758cb63e0d9afa98b764a25","slug":"2022-07-23react-杂货","date":"2022-07-22T16:25:08.000Z","updated":"2022-09-16T15:02:50.889Z","comments":true,"path":"api/articles/2022-07-23react-杂货.json","keywords":null,"cover":null,"content":"<h2 id=\"注意版本哈\"><a href=\"#注意版本哈\" class=\"headerlink\" title=\"注意版本哈\"></a>注意版本哈</h2><p><a href=\"https://juejin.cn/post/7034899177205137438\" target=\"_blank\" >从前有座山之 react 源码解读之 ReactContext</a></p>\n<p><a href=\"https://blog.csdn.net/m0_51744158/article/details/120870752\" target=\"_blank\" >React 源码解析————ReactContext.js,ReactLazy.js</a></p>\n<p><a href=\"https://www.cnblogs.com/sunxiaopei/p/12239160.html\" target=\"_blank\" >React 的 React.createRef()&#x2F;forwardRef()源码解析(三)</a></p>\n<p><a href=\"https://www.cnblogs.com/sunxiaopei/p/12205447.html\" target=\"_blank\" >React 的 React.createElement 源码解析(一)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/81947864\" target=\"_blank\" >React 源码解析(三) requestWork 之前的的准备工作</a></p>\n<p><a href=\"https://wenku.baidu.com/view/4306c6f2d25abe23482fb4daa58da0116c171fe1.html\" target=\"_blank\" >react 源码解析 7.Fiber 架构</a></p>\n<h2 id=\"前后版本差异\"><a href=\"#前后版本差异\" class=\"headerlink\" title=\"前后版本差异\"></a>前后版本差异</h2><h3 id=\"expirationTime\"><a href=\"#expirationTime\" class=\"headerlink\" title=\"expirationTime\"></a>expirationTime</h3><p>expirationTime 越小优先级越高，而现在是 expirationTime 越大优先级越高</p>\n<h3 id=\"React16-与-17-版本合成事件的区别\"><a href=\"#React16-与-17-版本合成事件的区别\" class=\"headerlink\" title=\"React16 与 17 版本合成事件的区别\"></a>React16 与 17 版本合成事件的区别</h3><ul>\n<li>react16 时事件委托的对象是 document，react17 时事件委托的对象是容器组件</li>\n<li>react16 时原生事件与 react 事件执行时，冒泡阶段与捕获阶段没有区分开（捕获-&gt; 冒泡 -&gt; 捕获）；</li>\n<li>react17 时优化了合成事件的执行，当与原生事件一起调用时，捕获阶段总是先于冒泡阶段（捕获 -&gt; 冒泡）</li>\n<li>react17 废弃了事件池</li>\n</ul>\n<!-- ————————————————\n版权声明：本文为CSDN博主「Monkey_Kcode」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_47431743/article/details/122156714 -->\n\n<h3 id=\"更改事件委托\"><a href=\"#更改事件委托\" class=\"headerlink\" title=\"更改事件委托\"></a>更改事件委托</h3><p>从技术上讲，始终可以在应用程序中嵌套不同版本的 React。但是，由于 React 事件系统的工作原理，这很难实现。</p>\n<p>自从其发布以来，React 一直自动进行事件委托。当 document 上触发 DOM 事件时，React 会找出调用的组件，然后 React 事件会在组件中向上 “冒泡”。但实际上，原生事件已经冒泡出了 document 级别，React 在其中安装了事件处理器。</p>\n<p>但是，这就是逐步升级的困难所在。</p>\n<p><span style=\"color: red\">如果页面上有多个 React 版本，他们都将在顶层注册事件处理器。这会破坏 <code>e.stopPropagation()</code>：如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本 React 嵌套变得困难重重</span>。这种担忧并不是没有根据的 —— 例如，四年前 Atom 编辑器就遇到了相同的问题。</p>\n<p>基于此： 在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const rootNode &#x3D; document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App &#x2F;&gt;, rootNode);</code></pre>\n\n<p>在 React 16 或更早版本中，React 会对大多数事件执行 <code>document.addEventListener()</code>。React 17 将会在底层调用 <code>rootNode.addEventListener()</code>。</p>\n<h3 id=\"Hooks-的实现原理\"><a href=\"#Hooks-的实现原理\" class=\"headerlink\" title=\"Hooks 的实现原理\"></a>Hooks 的实现原理</h3><p>React 会维护俩个链表，一个是 <code>currentHook</code>，另外一个是 <code>WorkInProgressHook</code>,每一个节点类型都是 <code>Hooks</code>，每当 <code>hooks</code> 函数被调用，react 就会创建一个 <code>hooks</code> 对象，并挂在链表的尾部，函数组件之所以能做一些类组件不能做的事儿，就是因为 <code>hook</code> 对象，函数组件的状态，计算值，缓存等都是交给 <code>hook</code> 去完成的，这样组件通过 Fiber.memoizedState 属性指向 hook 链表的头部来关联 <code>hook</code> 对象和当前组件，这样就发挥了 <code>hooks</code> 的作用。每次调用 hooks API 的时候，就会首先调用 <code>createWorkInProgressHook</code> 函数。得到 <code>hooks</code> 的串联不是一个数组，而是一个链式结构，从根节点 <code>workInProgressHook</code> 向下通过 next 进行串联，这也是为什么 <code>Hooks</code> 不能嵌套使用，不能在条件判断中使用，不能在循环中使用，否则链式就会被破坏。</p>\n<!-- ————————————————\n版权声明：本文为CSDN博主「leoxiaoge」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/github_37759996/article/details/119187241 -->\n\n<h3 id=\"createSyntheticEvent-源码\"><a href=\"#createSyntheticEvent-源码\" class=\"headerlink\" title=\"createSyntheticEvent 源码\"></a>createSyntheticEvent 源码</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function createSyntheticEvent(Interface: EventInterfaceType) &#123;\n  function SyntheticBaseEvent(\n    reactName: string | null,\n    reactEventType: string,\n    targetInst: Fiber,\n    nativeEvent: &#123;[propName: string]: mixed&#125;,\n    nativeEventTarget: null | EventTarget,\n  ) &#123;\n\n  Object.assign(SyntheticBaseEvent.prototype, &#123;\n    preventDefault: function() &#123;&#125;,\n\n    stopPropagation: function() &#123;&#125;,\n\n    &#x2F;**\n     * We release all dispatched &#96;SyntheticEvent&#96;s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won&#39;t be added back into the pool.\n     *&#x2F;\n    &#x2F;**\n    *我们在每个事件循环后释放所有调度的&#39;SyntheticEvent&#39;，添加\n    *他们回到水池里。这允许一种保持引用的方法\n    *不会被添加回池中。\n    *&#x2F;\n    persist: function() &#123;\n      &#x2F;&#x2F; Modern event system doesn&#39;t use pooling.\n      &#x2F;&#x2F; 现代事件系统不使用池。\n    &#125;,\n\n    &#x2F;**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return &#123;boolean&#125; True if this should not be released, false otherwise.\n     *&#x2F;\n    isPersistent: functionThatReturnsTrue,\n  &#125;);\n  return SyntheticBaseEvent;\n&#125;</code></pre>\n\n<p><code>persist</code>是个空函数，因为现在的事件系统不使用<code>事件池机制</code></p>\n<p><code>事件池</code>可以形象地理解为有个池子里装满了 SyntheticEvent 对象，程序有需要时会从池中取出一些使用，使用完后再放回池中。</p>\n<p><code>事件池机制</code>意味着 SyntheticEvent 对象会被缓存且反复使用，目的是提高性能，减少创建不必要的对象。当 SyntheticEvent 对象被收回到事件池中时，属性会被抹除、重置为 null。</p>\n<p>因此，我们在写 React 事件回调函数的时候切记<code>不能将 event 用于异步操作</code> —— 当异步操作真正执行的时候，SyntheticEvent 对象有可能已经被重置了</p>\n<p><strong>有事件池的情况下，如何处理异步事件</strong></p>\n<ul>\n<li>解决方案一： 使用 event.persist() 方法</li>\n<li>解决方案二： 及时缓存所需的 event 属性值</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 解决方案一：\nhandleChange &#x3D; (event) &#x3D;&gt; &#123;\n  event.persist(); &#x2F;&#x2F; 持久化\n  this.setState((prevState) &#x3D;&gt; (&#123;\n    value: event.target.value,\n    editionCounter: prevState.editionCounter + 1,\n  &#125;));\n&#125;;\n&#x2F;&#x2F; 解决方案二：\nhandleChange &#x3D; (event) &#x3D;&gt; &#123;\n  const value &#x3D; event.target.value; &#x2F;&#x2F; value这个本地变量已经保存了目标值\n  this.setState((prevState) &#x3D;&gt; (&#123;\n    value,\n    editionCounter: prevState.editionCounter + 1,\n  &#125;));\n&#125;;</code></pre>\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/212187297\" target=\"_blank\" >见</a></p>\n<p><strong>移除版本</strong><br>在 17.0.0 (October 20, 2020)，React DOM，Remove event pooling. (@trueadm in #18969)</p>\n<p><strong>移除原因</strong></p>\n<p><a href=\"https://blog.saeloun.com/2021/04/06/react-17-removes-event-pooling-in-modern-system.html#event-pooling\" target=\"_blank\" >见 Event Pooling</a></p>\n<ul>\n<li>虽然建立事件池是为了提高性能，但在现代浏览器中并没有提高性能。</li>\n<li>事件池也让开发人员感到困惑。例如，无法访问<code>eventx.target</code>。设置状态更新程序中的目标。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>With React 16 and earlier, we have to call event.persist() to properly use the event, or read the property we need.</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">handleChange(event) &#123;\n  console.log(event.target.value);\n  event.persist();\n  this.setState(() &#x3D;&gt; (&#123;\n    text: event.target.value\n  &#125;));\n&#125;\n</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>In React 17, the same code works as expected allowing us to fetch event.target.value without calling event.persist().<br>The old event pooling optimization has been fully removed, so we can read the event fields whenever we need them.</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">export class App extends React.Component &#123;\n  constructor() &#123;\n    super();\n    this.state &#x3D; &#123; text: &quot;&quot; &#125;;\n    this.handleChange &#x3D; this.handleChange.bind(this);\n  &#125;\n  handleChange(event) &#123;\n    console.log(event.target.value);\n    this.setState(() &#x3D;&gt; (&#123;\n      text: event.target.value,\n    &#125;));\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;span&gt;Text: &lt;&#x2F;span&gt;\n        &lt;input onChange&#x3D;&#123;this.handleChange&#125; value&#x3D;&#123;this.state.text&#125; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"为什么原生事件的-stopPropagation-可以阻止合成事件的传递？\"><a href=\"#为什么原生事件的-stopPropagation-可以阻止合成事件的传递？\" class=\"headerlink\" title=\"为什么原生事件的 stopPropagation 可以阻止合成事件的传递？\"></a>为什么原生事件的 stopPropagation 可以阻止合成事件的传递？</h3><p>因为合成事件是在原生事件触发之后才开始收集并触发的，所以当原生事件调用 stopPropagation 阻止传递后，根本到不到 root 节点，触发不了 React 绑定的处理函数，自然合成事件也不会触发，所以原生事件不是阻止了合成事件的传递，而是阻止了 React 中绑定的事件函数的执行。</p>\n<h3 id=\"react-基础知识总结\"><a href=\"#react-基础知识总结\" class=\"headerlink\" title=\"react 基础知识总结\"></a>react 基础知识总结</h3><p><a href=\"http://www.zzvips.com/article/230111.html\" target=\"_blank\" >见</a></p>\n<h2 id=\"React17-源码\"><a href=\"#React17-源码\" class=\"headerlink\" title=\"React17 源码\"></a>React17 源码</h2><p><a href=\"https://www.zhihu.com/column/c_1203007131219533824\" target=\"_blank\" >见</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://www.zzvips.com/article/230111.html\" target=\"_blank\" >react 基础知识总结</a></p>\n<p><a href=\"http://www.zzvips.com/article/227118.html\" target=\"_blank\" >React 事件机制源码解析 17.0.1</a></p>\n<p><a href=\"https://react.docschina.org/blog/2020/08/10/react-v17-rc.html#changes-to-event-delegation\" target=\"_blank\" >更改事件委托</a></p>\n","text":"注意版本哈从前有座山之 react 源码解读之 ReactContext React 源码解析————ReactContext.js,ReactLazy.js React 的 React.createRef()&#x2F;forwardRef()源码解析(三) React 的 R...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"React","slug":"React","count":34,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":28,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%89%88%E6%9C%AC%E5%93%88\"><span class=\"toc-text\">注意版本哈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82\"><span class=\"toc-text\">前后版本差异</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#expirationTime\"><span class=\"toc-text\">expirationTime</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React16-%E4%B8%8E-17-%E7%89%88%E6%9C%AC%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">React16 与 17 版本合成事件的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%94%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98\"><span class=\"toc-text\">更改事件委托</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hooks-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Hooks 的实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#createSyntheticEvent-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">createSyntheticEvent 源码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%9A%84-stopPropagation-%E5%8F%AF%E4%BB%A5%E9%98%BB%E6%AD%A2%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%EF%BC%9F\"><span class=\"toc-text\">为什么原生事件的 stopPropagation 可以阻止合成事件的传递？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#react-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">react 基础知识总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React17-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">React17 源码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React V17.0 候选版本：无新功能","uid":"4afe9cca9efcce45bab52ea3fe738dfb","slug":"2022-07-25React-v17","date":"2022-07-25T06:54:43.000Z","updated":"2022-09-16T15:02:55.176Z","comments":true,"path":"api/articles/2022-07-25React-v17.json","keywords":null,"cover":[],"text":"无新特性React 17 的版本是非比寻常的，因为它没有添加任何面向开发人员的新功能。而主要侧重于升级简化 React 本身。 我们正在积极开发 React 的新功能，但它们并不属于此版本。React 17 是我们进行深度推广战略的关键所在。 此版本之所以特殊，你可以认为 Rea...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"React","slug":"React","count":34,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":28,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"React@16.5.0 diffing algorithm","uid":"591f2a8f52aa8db4f8ec9853d594cc54","slug":"2022-07-22react-diffing","date":"2022-07-22T01:16:00.000Z","updated":"2022-09-16T15:02:43.733Z","comments":true,"path":"api/articles/2022-07-22react-diffing.json","keywords":null,"cover":[],"text":"说明 React provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applicati...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}