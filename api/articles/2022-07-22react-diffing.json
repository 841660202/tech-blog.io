{"title":"React@16.5.0 diffing algorithm","uid":"591f2a8f52aa8db4f8ec9853d594cc54","slug":"2022-07-22react-diffing","date":"2022-07-22T01:16:00.000Z","updated":"2022-09-16T15:02:43.733Z","comments":true,"path":"api/articles/2022-07-22react-diffing.json","keywords":null,"cover":[],"content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>React provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React’s “diffing” algorithm so that component updates are predictable while being fast enough for high-performance apps.</p></blockquote>\n<p>嗯，这里使用了英文原文，我觉得中文版本，翻译的不够准确</p>\n<p>撇开中文版官方不谈，译文如下：</p>\n<p>React 提供了响应式 API,所以你不用担心每次更新都会发生什么变化。这使得开发应用更点单，但在 React 中如何实现这一点可能并不明显。这篇文章解释了我们在 React 的 diffing 算法的选择，因此，组件更新是可预测的，同时对高性能应用程序来说足够快。</p>\n<h2 id=\"设计动机\"><a href=\"#设计动机\" class=\"headerlink\" title=\"设计动机\"></a>设计动机</h2><p>在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。</p>\n<p>在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。</p>\n<p>React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p>\n<p>此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。</p>\n<p>如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的 <code>启发式算法</code>：</p>\n<ul>\n<li><code>两个不同类型的元素会产生出不同的树；</code></li>\n<li><code>开发者可以使用 key 属性标识哪些子元素在不同的渲染中可能是不变的。</code></li>\n</ul>\n<p>在实践中，我们发现以上假设在几乎所有实用的场景下都成立。</p>\n<details class=\"custom-details\">\n<summary>启发式算法定义</summary>\n<p><a href=\"https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987\" target=\"_blank\" ><code>启发式算法</code></a>（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计</p>\n</details>\n<h2 id=\"Diffing-算法\"><a href=\"#Diffing-算法\" class=\"headerlink\" title=\"Diffing 算法\"></a>Diffing 算法</h2><p>当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。</p>\n<h3 id=\"对比不同类型的元素\"><a href=\"#对比不同类型的元素\" class=\"headerlink\" title=\"对比不同类型的元素\"></a>对比不同类型的元素</h3><p>当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树</p>\n<ul>\n<li><p>当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 <code>componentWillUnmount()</code> 方法。</p>\n</li>\n<li><p>当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 <code>UNSAFE_componentWillMount()</code> 方法，紧接着 <code>componentDidMount()</code> 方法。</p>\n</li>\n</ul>\n<p>所有与之前的树相关联的 state 也会被销毁。</p>\n<p>在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;div&gt;\n  &lt;Counter &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n&lt;span&gt;\n  &lt;Counter &#x2F;&gt;\n&lt;&#x2F;span&gt;\n</code></pre>\n\n<p>React 会销毁 Counter 组件并且重新装载一个新的组件。</p>\n<h3 id=\"对比同一类型的元素\"><a href=\"#对比同一类型的元素\" class=\"headerlink\" title=\"对比同一类型的元素\"></a>对比同一类型的元素</h3><p>当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;div className&#x3D;&quot;before&quot; title&#x3D;&quot;stuff&quot; &#x2F;&gt;\n\n&lt;div className&#x3D;&quot;after&quot; title&#x3D;&quot;stuff&quot; &#x2F;&gt;</code></pre>\n\n<p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>className</code> 属性。</p>\n<br/>\n<br/>\n\n<p>当更新 <code>style</code> 属性时，React 仅更新有所更变的属性。比如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;div style&#x3D;&#123;&#123;color: &#39;red&#39;, fontWeight: &#39;bold&#39;&#125;&#125; &#x2F;&gt;\n\n&lt;div style&#x3D;&#123;&#123;color: &#39;green&#39;, fontWeight: &#39;bold&#39;&#125;&#125; &#x2F;&gt;</code></pre>\n\n<p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>color</code> 样式，无需修改 <code>fontWeight</code>。</p>\n<p>在处理完当前节点之后，React 继续对子节点进行递归。</p>\n<h3 id=\"对比同类型的组件元素\"><a href=\"#对比同类型的组件元素\" class=\"headerlink\" title=\"对比同类型的组件元素\"></a>对比同类型的组件元素</h3><p>当一个组件更新时，<code>组件实例会保持不变</code>，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 <code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code>方法。</p>\n<p>下一步，调用 render() 方法，<strong>diff 算法将在之前的结果以及新的结果中进行递归</strong>。</p>\n<h3 id=\"对子节点进行递归\"><a href=\"#对子节点进行递归\" class=\"headerlink\" title=\"对子节点进行递归\"></a>对子节点进行递归</h3><p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 <code>mutation</code>变化。</p>\n<p><code>在子元素列表末尾新增元素时，更新开销比较小</code>。比如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n  &lt;li&gt;third&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n\n<p>React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。</p>\n<p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;ul&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n\n<p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</p>\n<h3 id=\"Keys\"><a href=\"#Keys\" class=\"headerlink\" title=\"Keys\"></a>Keys</h3><p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2014&quot;&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre>\n\n<p>现在 React 知道只有带着 <code>&#39;2014&#39;</code> key 的元素是新元素，带着 <code>&#39;2015&#39;</code> 以及 <code>&#39;2016&#39;</code> key 的元素仅仅移动了。</p>\n<p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;</code></pre>\n\n<p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。<strong>这个 key 不需要全局唯一，但在列表中需要保持唯一</strong>。</p>\n<p>最后，_你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢_。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><strong>当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题</strong>。由于组件实例是基于它们的 key 来决定是否更新以及复用，<code>如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致</code><small style=\"color: red;\">非受控组件的 state（比如输入框）</small><code>可能相互篡改，会出现无法预期的变动</code>。</p>\n</p>\n</div>\n<p>在 Codepen 有两个例子，分别为 <a href=\"https://zh-hans.reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key\" target=\"_blank\" >展示使用下标作为 key 时导致的问题</a>，以及 <a href=\"https://zh-hans.reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key\" target=\"_blank\" >不使用下标作为 key 的例子的版本，修复了重新排列，排序，以及在列表头插入的问题</a>。</p>\n<p><strong>修复前</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/Kapture 2022-07-22 at 09.23.57.gif\" style=\"max-width: 100%; width: 400px\" />\n\n<p><strong>修复后</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/Kapture 2022-07-22 at 09.29.46.gif\" style=\"max-width: 100%; width: 400px\" />\n\n<h2 id=\"权衡\"><a href=\"#权衡\" class=\"headerlink\" title=\"权衡\"></a>权衡</h2><p>请谨记协调算法是一个实现细节。</p>\n<p>React 可以在每个 action 之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用 render 方法，这不代表 React 会卸载或装载它们。React 只会基于以上提到的规则来决定如何进行差异的合并。</p>\n<p>我们定期优化启发式算法，让常见用例更高效地执行。<strong>在当前的实现中，可以理解为一棵子树能在其兄弟之间移动，但不能移动到其他位置。</strong>在这种情况下，算法会重新渲染整棵子树。</p>\n<p>由于 React 依赖启发式算法，因此当以下假设没有得到满足，性能会有所损耗。</p>\n<ul>\n<li>该算法不会尝试匹配不同组件类型的子树。<strong>如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型</strong>。在实践中，我们没有遇到这类问题。<br/>\n<br/></li>\n<li>Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，<strong>这可能导致性能下降和子组件中的状态丢失。</strong></li>\n</ul>\n<h2 id=\"diffing-algorithm\"><a href=\"#diffing-algorithm\" class=\"headerlink\" title=\"diffing algorithm\"></a>diffing algorithm</h2><p><a href=\"https://react.iamkasong.com/diff/prepare.html#diff%E7%9A%84%E7%93%B6%E9%A2%88%E4%BB%A5%E5%8F%8Areact%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9\" target=\"_blank\" >见</a></p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>注意：React 技术揭秘讲的内容并不一定是全面且正确的，可能你在读的源码版本不一致，但可借鉴</p>\n</div>\n<h2 id=\"reconcileChildFibers\"><a href=\"#reconcileChildFibers\" class=\"headerlink\" title=\"reconcileChildFibers\"></a>reconcileChildFibers</h2><img src=\"http://t-blog-images.aijs.top/img/begin-diff.png\" />\n\n<p>读源码中…</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm\" target=\"_blank\" >reconciliation</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_47431743/article/details/121589419\" target=\"_blank\" >代码调试</a></p>\n<p><a href=\"https://www.jianshu.com/p/c87cc324756f\" target=\"_blank\" >探索 React 源码：Reconciler</a></p>\n","text":"说明 React provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applicati...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA\"><span class=\"toc-text\">设计动机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Diffing-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Diffing 算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">对比不同类型的元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%E5%90%8C%E4%B8%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">对比同一类型的元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%84%E4%BB%B6%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">对比同类型的组件元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%AD%90%E8%8A%82%E7%82%B9%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92\"><span class=\"toc-text\">对子节点进行递归</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Keys\"><span class=\"toc-text\">Keys</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%83%E8%A1%A1\"><span class=\"toc-text\">权衡</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#diffing-algorithm\"><span class=\"toc-text\">diffing algorithm</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reconcileChildFibers\"><span class=\"toc-text\">reconcileChildFibers</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React@16、17 杂货","uid":"7914c7b61758cb63e0d9afa98b764a25","slug":"2022-07-23react-杂货","date":"2022-07-22T16:25:08.000Z","updated":"2022-09-16T15:02:50.889Z","comments":true,"path":"api/articles/2022-07-23react-杂货.json","keywords":null,"cover":null,"text":"注意版本哈从前有座山之 react 源码解读之 ReactContext React 源码解析————ReactContext.js,ReactLazy.js React 的 React.createRef()&#x2F;forwardRef()源码解析(三) React 的 R...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"React","slug":"React","count":38,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":32,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"React@16.5.0 PureComponent","uid":"d6e3ef07929a629e78ad737d602fe838","slug":"2022-07-21react-PureComponent","date":"2022-07-21T08:28:39.000Z","updated":"2022-10-17T11:18:29.854Z","comments":true,"path":"api/articles/2022-07-21react-PureComponent.json","keywords":null,"cover":[],"text":"串串 PureComponent 继承 Component,添加 isPureReactComponent 标记 &#x2F;&#x2F; ComponentDummy 是典型的 JavaScript 原型模拟继承的做法， function ComponentDummy() &#...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/categories/react-1650.json"}],"tags":[{"name":"react_1650","slug":"react-1650","count":5,"path":"api/tags/react-1650.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}