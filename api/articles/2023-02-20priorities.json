{"title":"性能优化-Preload, Prefetch And Priorities in Chrome","uid":"18f2de6f6ea6d59c8b217d81ff25660d","slug":"2023-02-20priorities","date":"2023-02-20T10:13:09.000Z","updated":"2023-02-23T13:26:54.130Z","comments":true,"path":"api/articles/2023-02-20priorities.json","keywords":null,"cover":"https://miro.medium.com/v2/resize:fit:720/format:webp/1*W4_tAMHlFs6tunMxbXQjFA.png","content":"<h2 id=\"Preload-Prefetch-是如何工作的\"><a href=\"#Preload-Prefetch-是如何工作的\" class=\"headerlink\" title=\"Preload, Prefetch 是如何工作的\"></a>Preload, Prefetch 是如何工作的</h2><!-- 深入了解 Chrome 网络堆栈的见解，以清楚地了解 Web 加载原语（如`<link rel=\"preload\">`和`<link rel=\"prefetch\">`）如何在幕后工作，以便您可以更有效地使用它们 -->\n\n<p>正如其他文章中很好地介绍的那样，preload 是一种声明式获取，允许您强制浏览器发出对资源的请求，而不会阻止文档的 onload 事件</p>\n<p><code>prefetch</code> 是向浏览器提示可能需要资源，但将决定是否以及何时加载委托给浏览器</p>\n<p><code>preload</code> 可以将加载事件与脚本解析时间分离。</p>\n<p>如果您以前没有使用过它，请阅读“<a href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\" target=\"_blank\" >预加载：它有什么好处？</a>”Yoav Weiss</p>\n<p>预加载在生产中被大型站点用于许多用例，您可以在本文后面找到更多。在此之前，让我们深入了解网络堆栈实际上如何处理预加载与预取。</p>\n<h2 id=\"什么时候用，用哪个？\"><a href=\"#什么时候用，用哪个？\" class=\"headerlink\" title=\"什么时候用，用哪个？\"></a>什么时候用，用哪个？</h2><p><code>&lt;link rel=&quot;preload&quot;&gt;</code>vs<code>&lt;link rel=&quot;prefetch&quot;&gt;</code></p>\n<p>提示：</p>\n<ol>\n<li>您高度信任的预加载资源将在当前页面中使用。</li>\n<li>预取资源可能用于跨多个导航边界的未来导航</li>\n<li><code>preload</code> 用于请求页面所需的资源（关键脚本、Web 字体、图像）</li>\n<li><code>preload</code> 用户未来的导航（例如在视图或页面之间），其中获取的资源和请求需要跨导航保持不变。</li>\n<li>如果页面 A 为页面 B 所需的关键资源发起预取请求，关键资源和导航请求可以并行完成。</li>\n<li>如果我们对这个用例使用预加载，它将在页面 A 卸载时立即被取消。</li>\n</ol>\n<p>在 <code>preload</code> 和 <code>prefetch</code> 之间，我们得到了为当前导航<em>or</em>未来导航加载关键资源的解决方案</p>\n<h2 id=\"lt-link-rel-quot-preload-quot-gt-和-lt-link-rel-quot-prefetch-quot-gt-的缓存行为是什么？\"><a href=\"#lt-link-rel-quot-preload-quot-gt-和-lt-link-rel-quot-prefetch-quot-gt-的缓存行为是什么？\" class=\"headerlink\" title=\"&lt;link rel=&quot;preload&quot;&gt;和&lt;link rel=&quot;prefetch&quot;&gt;的缓存行为是什么？\"></a><code>&lt;link rel=&quot;preload&quot;&gt;</code>和<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>的缓存行为是什么？</h2><p>Chrome 有四个缓存：</p>\n<ol>\n<li><code>HTTP 缓存</code>、</li>\n<li><code>Service Worker 缓存</code></li>\n<li><code>内存缓存</code>、</li>\n<li><code>Push 缓存</code>。</li>\n</ol>\n<p>预加载和预取资源都存储在 HTTP 缓存中</p>\n<p>当资源被预加载或预取时，缓存过程：<code>从网络堆栈 -&gt; HTTP 缓存 -&gt; 渲染器的内存缓存</code>。</p>\n<ol>\n<li><code>如果资源可以被缓存</code>（例如， valid <code>cache-control</code> with valid <code>max-age</code>），它就会存储在 HTTP 缓存中，并且可用于当前和未来的会话。</li>\n<li><code>如果资源不可缓存</code>，它不会存储在 HTTP 缓存中。相反，它会上升到内存缓存并停留在那里，直到它被使用。</li>\n</ol>\n<h2 id=\"Chrome-的网络优先级如何处理预加载和预取？\"><a href=\"#Chrome-的网络优先级如何处理预加载和预取？\" class=\"headerlink\" title=\"Chrome 的网络优先级如何处理预加载和预取？\"></a>Chrome 的网络优先级如何处理预加载和预取？</h2><h3 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h3><p>根据它们在文档中的位置以及它们是异步、延迟还是阻塞而获得不同的优先级</p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>图像（可视且在视口中）的优先级（净：中等）高于不在视口中的图像（净：最低）</p>\n<p>所以在某种程度上 Chrome 最好为您伪延迟加载这些图像。图像以较低的优先级开始，布局完成后，发现它们在视口中，将获得优先级提升（但请注意，布局完成时已经在飞行中的图像不会重新排序）</p>\n<h3 id=\"“as”属性预加载的资源\"><a href=\"#“as”属性预加载的资源\" class=\"headerlink\" title=\"“as”属性预加载的资源\"></a>“as”属性预加载的资源</h3><p><strong>预加载 as&#x3D;”style”将获得最高优先级，而 as&#x3D;”script”将获得低或中优先级。</strong></p>\n<h2 id=\"当页面尝试预加载已缓存在-Service-Worker-缓存、HTTP-缓存或两者中的资源时会发生什么？\"><a href=\"#当页面尝试预加载已缓存在-Service-Worker-缓存、HTTP-缓存或两者中的资源时会发生什么？\" class=\"headerlink\" title=\"当页面尝试预加载已缓存在 Service Worker 缓存、HTTP 缓存或两者中的资源时会发生什么？\"></a>当页面尝试预加载已缓存在 Service Worker 缓存、HTTP 缓存或两者中的资源时会发生什么？</h2><p>视情况而定，但一般来说，资源不会从网络中重新获取，除非它已经从 HTTP 缓存中过期，或者 Service Worker 有意重新获取它。</p>\n<p>如果资源在 HTTP 缓存中（在 SW 缓存和网络之间），则预加载应该从同一资源获得缓存命中。</p>\n<h2 id=\"是否会浪费用户带宽\"><a href=\"#是否会浪费用户带宽\" class=\"headerlink\" title=\"是否会浪费用户带宽?\"></a>是否会浪费用户带宽?</h2><p>使用“预加载”或“预取”，会浪费用户带宽的风险，尤其是在资源不可缓存的情况下。</p>\n<p>没有使用的预加载，会收到警告：</p>\n<img src=\"http://t-blog-images.aijs.top/img/202302201842219.webp\" />\n\n<p>发出此警告的原因是，您可能正在使用预加载来尝试为您需要提高性能的其他资源预热缓存，但如果这些预加载的资源没有被使用，您无缘无故地做了额外的工作。在移动设备上，这等于浪费了用户的数据计划，因此请注意您正在预加载的内容。</p>\n<h2 id=\"什么会导致双重获取\"><a href=\"#什么会导致双重获取\" class=\"headerlink\" title=\"什么会导致双重获取?\"></a>什么会导致双重获取?</h2><img src=\"http://t-blog-images.aijs.top/img/202302201844982.webp\" />\n\n<ol>\n<li><code>prefetch</code>作为<code>preload</code>的后备</li>\n<li><code>fetch（）</code>与 <code>preload</code> 一起工作</li>\n<li>预加载的内容（例如脚本）时没有提供有效的“as”</li>\n<li>没有跨域的预加载字体将双重获取</li>\n<li>完全预加载所有内容</li>\n</ol>\n<p><strong>不要使用“prefetch”作为“preload”的后备</strong>。它们再次被用于不同的目的，并且通常最终会导致双重获取，而这可能不是您的意图。如果支持为当前会话预热缓存，请使用 preload，否则为未来会话预取。不要使用一个代替另一个</p>\n<p><strong>暂时不要依赖 fetch（）与 preload 一起工作</strong>。 Chrome 如果您尝试将 preload 与 fetch（）API 一起使用，您最终会触发双重下载。XHR 目前不会发生这种情况</p>\n<p><strong>如果您在指定要预加载的内容（例如脚本）时没有提供有效的“as”，您最终将获取两次</strong></p>\n<p><strong>没有跨域的预加载字体将双重获取！</strong><br>确保在使用预加载获取字体时添加跨域属性，否则它们将被双重下载。使用匿名模式 CORS 请求它们。即使字体与页面位于同一原点，此建议也适用。这也适用于其他匿名获取（例如默认情况下的 XHR）</p>\n<p><strong>不要尝试完全预加载所有内容！</strong><br>相反，选择您想要更早加载的特定后期发现的资源，并使用预加载告诉浏览器它们</p>\n<h2 id=\"全部资源都预加载？有什么建议和限制？\"><a href=\"#全部资源都预加载？有什么建议和限制？\" class=\"headerlink\" title=\"全部资源都预加载？有什么建议和限制？\"></a>全部资源都预加载？有什么建议和限制？</h2><p>预加载可能在您的页面后期发现的资源，但在其他方面很重要的是要尽早获取。</p>\n<p>对于脚本，预加载您的密钥包很好，因为它以一种仅使用<code>&lt;script async&gt;</code>不会阻止窗口的 onload 事件的方式将获取与执行分开。<br>您可以预加载图像、样式、字体、媒体。最重要的是，您可以更好地控制早期获取，作为页面作者，您知道您的页面肯定需要尽早获取。</p>\n<h2 id=\"prefetch-有什么特点\"><a href=\"#prefetch-有什么特点\" class=\"headerlink\" title=\"prefetch 有什么特点\"></a>prefetch 有什么特点</h2><ol>\n<li>在 Chrome 中，如果用户在其他页面的预取请求仍在运行时离开页面，则这些请求不会被终止。</li>\n<li>此外，无论资源的可缓存性如何，预取请求都会在未指定的网络堆栈缓存中维护至少 5 分钟。</li>\n</ol>\n<h2 id=\"使用-JS-编写的自定义“预加载”实现。这与-rel-x3D-”preload”或-Preload-标头有何不同？\"><a href=\"#使用-JS-编写的自定义“预加载”实现。这与-rel-x3D-”preload”或-Preload-标头有何不同？\" class=\"headerlink\" title=\"使用 JS 编写的自定义“预加载”实现。这与 rel&#x3D;”preload”或 Preload 标头有何不同？\"></a>使用 JS 编写的自定义“预加载”实现。这与 rel&#x3D;”preload”或 Preload 标头有何不同？</h2><p>预加载将获取资源与 JS 处理和执行分离。因此，标记中声明的预加载由预加载扫描器在 Chrome 进行优化。这意味着在许多情况下，预加载将在超文本标记语言解析器到达标记之前被获取（具有指定的优先级）。这使得它比自定义预加载实现更强大。</p>\n<h2 id=\"如何功能检测对链接-rel-x3D-preload-的支持？\"><a href=\"#如何功能检测对链接-rel-x3D-preload-的支持？\" class=\"headerlink\" title=\"如何功能检测对链接 rel&#x3D;preload 的支持？\"></a>如何功能检测对链接 rel&#x3D;preload 的支持？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const preloadSupported &#x3D; () &#x3D;&gt; &#123;\n  const link &#x3D; document.createElement(&quot;link&quot;);\n  const relList &#x3D; link.relList;\n  if (!relList || !relList.supports) return false;\n  return relList.supports(&quot;preload&quot;);\n&#125;;</code></pre>\n\n<h2 id=\"可以立即应用预加载的-CSS-样式表吗？\"><a href=\"#可以立即应用预加载的-CSS-样式表吗？\" class=\"headerlink\" title=\"可以立即应用预加载的 CSS 样式表吗？\"></a>可以立即应用预加载的 CSS 样式表吗？</h2><p>可以。预加载支持基于标记的异步加载。使用<link rel=\"preload\">加载的样式表可以使用’onload’事件立即应用于当前文档，如下所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- prettier-ignore --&gt;\n&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;style.css&quot; onload&#x3D;&quot;this.rel&#x3D;stylesheet&quot;&gt;</code></pre>\n\n<h2 id=\"当前浏览器对-Preload-和-Prefetch-的支持如何？\"><a href=\"#当前浏览器对-Preload-和-Prefetch-的支持如何？\" class=\"headerlink\" title=\"当前浏览器对 Preload 和 Prefetch 的支持如何？\"></a>当前浏览器对 Preload 和 Prefetch 的支持如何？</h2><p><code>&lt;link rel=&quot;preload&quot;&gt;</code>可供全球约 50%的用户使用，并在 Safari 技术预览版中实现。<br><code>&lt;link rel=&quot;prefetch&quot;&gt;</code>可供全球 71%的用户使用。</p>\n<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf\" target=\"_blank\" >Preload, Prefetch And Priorities in Chrome</a></p>\n","text":"Preload, Prefetch 是如何工作的 正如其他文章中很好地介绍的那样，preload 是一种声明式获取，允许您强制浏览器发出对资源的请求，而不会阻止文档的 onload 事件 prefetch 是向浏览器提示可能需要资源，但将决定是否以及何时加载委托给浏览器 prel...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":9,"path":"api/tags/性能优化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Preload-Prefetch-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\"><span class=\"toc-text\">Preload, Prefetch 是如何工作的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%8C%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">什么时候用，用哪个？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lt-link-rel-quot-preload-quot-gt-%E5%92%8C-lt-link-rel-quot-prefetch-quot-gt-%E7%9A%84%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">&lt;link rel&#x3D;&quot;preload&quot;&gt;和&lt;link rel&#x3D;&quot;prefetch&quot;&gt;的缓存行为是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Chrome-%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BC%98%E5%85%88%E7%BA%A7%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8F%96%EF%BC%9F\"><span class=\"toc-text\">Chrome 的网络优先级如何处理预加载和预取？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#script\"><span class=\"toc-text\">script</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%89%87\"><span class=\"toc-text\">图片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%80%9Cas%E2%80%9D%E5%B1%9E%E6%80%A7%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">“as”属性预加载的资源</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BD%93%E9%A1%B5%E9%9D%A2%E5%B0%9D%E8%AF%95%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%B7%B2%E7%BC%93%E5%AD%98%E5%9C%A8-Service-Worker-%E7%BC%93%E5%AD%98%E3%80%81HTTP-%E7%BC%93%E5%AD%98%E6%88%96%E4%B8%A4%E8%80%85%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">当页面尝试预加载已缓存在 Service Worker 缓存、HTTP 缓存或两者中的资源时会发生什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E5%90%A6%E4%BC%9A%E6%B5%AA%E8%B4%B9%E7%94%A8%E6%88%B7%E5%B8%A6%E5%AE%BD\"><span class=\"toc-text\">是否会浪费用户带宽?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%8F%8C%E9%87%8D%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">什么会导致双重获取?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E9%83%A8%E8%B5%84%E6%BA%90%E9%83%BD%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%92%8C%E9%99%90%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">全部资源都预加载？有什么建议和限制？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#prefetch-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">prefetch 有什么特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-JS-%E7%BC%96%E5%86%99%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E2%80%9C%E9%A2%84%E5%8A%A0%E8%BD%BD%E2%80%9D%E5%AE%9E%E7%8E%B0%E3%80%82%E8%BF%99%E4%B8%8E-rel-x3D-%E2%80%9Dpreload%E2%80%9D%E6%88%96-Preload-%E6%A0%87%E5%A4%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">使用 JS 编写的自定义“预加载”实现。这与 rel&#x3D;”preload”或 Preload 标头有何不同？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%8A%9F%E8%83%BD%E6%A3%80%E6%B5%8B%E5%AF%B9%E9%93%BE%E6%8E%A5-rel-x3D-preload-%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%9F\"><span class=\"toc-text\">如何功能检测对链接 rel&#x3D;preload 的支持？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E4%BB%A5%E7%AB%8B%E5%8D%B3%E5%BA%94%E7%94%A8%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84-CSS-%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">可以立即应用预加载的 CSS 样式表吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BD%93%E5%89%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9-Preload-%E5%92%8C-Prefetch-%E7%9A%84%E6%94%AF%E6%8C%81%E5%A6%82%E4%BD%95%EF%BC%9F\"><span class=\"toc-text\">当前浏览器对 Preload 和 Prefetch 的支持如何？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E6%96%87%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">原文链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"css-in-js Emotion","uid":"dcd1b904e1a0e1af1d4a643d739dc3fa","slug":"2023-02-21css_in_js","date":"2023-02-21T06:20:01.000Z","updated":"2023-02-23T13:26:54.130Z","comments":true,"path":"api/articles/2023-02-21css_in_js.json","keywords":null,"cover":"https://i.imgur.com/9WKHXbg.png","text":"背景最近一段时间，维护敏捷平台的几个相关项目，都是使用 Emotion 进行开发的，所以有必要系统了解下 Emotion Emotion 是什么 使用: 使用 js 编写 css 样式而设计的库 手段: 提供可预测的样式组合, 支持字符串和对象样式 效果: 具有源码映射、标签和测...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"css-in-js","slug":"css-in-js","count":1,"path":"api/categories/css-in-js.json"}],"tags":[{"name":"css-in-js","slug":"css-in-js","count":1,"path":"api/tags/css-in-js.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"react-native性能优化","uid":"3badd62824c1bd78d6cf74cef1c634b2","slug":"2023-02-19rn-performance-o","date":"2023-02-19T15:06:09.000Z","updated":"2023-03-01T15:20:52.608Z","comments":true,"path":"api/articles/2023-02-19rn-performance-o.json","keywords":null,"cover":"https://pic1.zhimg.com/v2-24ef1ffd343e72a2dca843b25c62e224_1440w.jpg?source=172ae18b","text":"性能优化 使用 Image 缓存解决方案，使用适当大小的图片 Animated 库中使用 nativeDriver 避免不必要的渲染 不要在源代码中保留 console 表达式 使用 Flipper 进行调试 使用 Hermes 不要使用 Scrollview 渲染一个大列表数据...","link":"","photos":[],"count_time":{"symbolsCount":531,"symbolsTime":"1 mins."},"categories":[{"name":"react-native","slug":"react-native","count":8,"path":"api/categories/react-native.json"}],"tags":[{"name":"react-native","slug":"react-native","count":8,"path":"api/tags/react-native.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}