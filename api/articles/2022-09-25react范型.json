{"title":"React TS 范型组件","uid":"f3f72853c8b7c10482dbb43fb811bec2","slug":"2022-09-25react范型","date":"2022-09-25T11:24:31.000Z","updated":"2022-09-25T12:06:21.355Z","comments":true,"path":"api/articles/2022-09-25react范型.json","keywords":null,"cover":null,"content":"<h2 id=\"泛型类型\"><a href=\"#泛型类型\" class=\"headerlink\" title=\"泛型类型\"></a>泛型类型</h2><p>TypeScript 中，类型（interface, type）是可以声明成泛型的，这很常见。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Props&lt;T&gt; &#123;\n  content: T;\n&#125;</code></pre>\n\n<p>这表明 Props 接口定义了这么一种类型：</p>\n<p>它是包含一个 content 字段的对象, 该 content 字段的类型由使用时的泛型 T 决定</p>\n<p><strong>使用时候ts自动推断</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type StringProps &#x3D; Props&lt;string&gt;;\n\nlet props: StringProps;\n\nprops &#x3D; &#123;\n  &#x2F;&#x2F;   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322)\n  content: 42\n&#125;;\n\nprops &#x3D; &#123;\n  &#x2F;&#x2F; ✅\n  content: &quot;hello&quot;\n&#125;;</code></pre>\n\n<p>TypeScript 能够跟使用时候提供的值自动推断出类型 T，无需显式指定：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Props&lt;T&gt; &#123;\n  content: T;\n&#125;\n\nfunction Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  console.log(props);\n&#125;\n\n&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;number&gt;(props: Props&lt;number&gt;): void *&#x2F;\nFoo(&#123; content: 42 &#125;);\n\n&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;string&gt;(props: Props&lt;string&gt;): void *&#x2F;\nFoo(&#123; content: &quot;hello&quot; &#125;);</code></pre>\n\n<p>上面因为 Foo 函数接收 <code>Props&lt;T&gt;</code> 作为入参，<br>意味着我们在调用 Foo 的时候需要传递类型 T 以确定<code> Props&lt;T&gt;</code>，所以 Foo 函数也变成了泛型。</p>\n<p>当调用 <code>Foo(&#123; content: 42 &#125;)</code> 的时候，TypeScript 自动解析出 T 为 number，此时对应的函数签名为：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function Foo&lt;number&gt;(props: Props&lt;number&gt;): void;</code></pre>\n<p>而我们并没有显式地指定其中的类型 T，像这样 <code>Foo&lt;number&gt;(&#123; content: 42 &#125;)</code>;。</p>\n<h2 id=\"泛型组件\"><a href=\"#泛型组件\" class=\"headerlink\" title=\"泛型组件\"></a>泛型组件</h2><p>将上面的 Foo 函数返回 JSX 元素，就成了一个 React 组件。因为它是泛型函数，它所形成的组件也就成了 泛型组件&#x2F;Generic Components。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">function Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  return &lt;div&gt; &#123;props.content&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;\n      &lt;Foo&lt;string&gt;&#x2F;**真的有点奇葩，理却是这个理 *&#x2F; content&#x3D;&#123;&quot;hello&quot;&#125;&gt;&lt;&#x2F;Foo&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<p>因为 TypeScript 可根据传入的实际值解析泛型类型，所以 <code>&lt;Foo&lt;string&gt; content=&#123;&quot;hello&quot;&#125;&gt;&lt;/Foo&gt;</code> 中 string 是可选的，这里只为展示，让你看到其实 React 组件还可以这么玩。</p>\n<p>为了进一步理解泛型组件，再看下非泛型情况下上面的组件是长怎样的。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface Props &#123;\n  content: string;\n&#125;\n\nfunction Foo(props: Props) &#123;\n  return &lt;div&gt;&#123;props.content&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &#123;&#x2F;*   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322) *&#x2F;&#125;\n      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;\n      &lt;Foo content&#x3D;&#123;&quot;hello&quot;&#125;&gt;&lt;&#x2F;Foo&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n<p>以上，便是一个 React 组件常规的写法。它定义的入参 Props 只接收 string 类型。由此也看出泛型的优势，即大部分代码可复用的情况下，将参数变成泛型后，不同类型的入参可复用同一组件，不用为新类型新写一个组件。</p>\n<p>除了函数组件，对于类类型的组件来说，也是一样可泛型化的。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\ninterface Props&lt;T&gt; &#123;\n  content: T;\n&#125;\n\nclass Bar&lt;T&gt; extends React.Component&lt;Props&lt;T&gt;&gt; &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.content&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Bar content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Bar&gt;\n      &lt;Bar&lt;string&gt; content&#x3D;&#123;&quot;hello&quot;&#125;&gt;&lt;&#x2F;Bar&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<p>一个更加真实的示例<br>一个更加实用的示例是列表组件。列表中的分页加载，滚动刷新逻辑等，对于所有列表数据都是通用的，将这个列表组件书写成泛型便可和任意类型列表数据结合，而无须通过其他方式来达到复用的目的，将列表元素声明成 any 或 Record&lt;string,any&gt; 等类型。</p>\n<p>先看不使用泛型情况下，如何实现这么一个列表组件。此处只看列表元素的展示以阐述泛型的作用，其他逻辑比如数据加载等先忽略。</p>\n<p>列表组件 List.tsx</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\ninterface Item &#123;\n  [prop: string]: any;\n&#125;\n\ninterface Props &#123;\n  list: Item[];\n  children: (item: Item, index: number) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List(&#123; list, children &#125;: Props) &#123;\n  &#x2F;&#x2F; 列表中其他逻辑...\n  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;\n&#125;</code></pre>\n\n<p>上面，为了尽可能满足大部分数据类型，将列表的元素类型定义成了 <code>[prop: string]: any;</code> 的形式，其实和 <code>Record&lt;string,any&gt; </code>没差。在这里已经可以看到类型的丢失了，因为出现了 <code>any</code>，而我们使用 TypeScript 的首要准则是<code>尽量避免 any</code>。</p>\n<p>然后是使用上面所定义的列表组件：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface User &#123;\n  id: number;\n  name: string;\n&#125;\nconst data: User[] &#x3D; [\n  &#123;\n    id: 1,\n    name: &quot;wayou&quot;\n  &#125;,\n  &#123;\n    id: 1,\n    name: &quot;niuwayong&quot;\n  &#125;\n];\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;List list&#x3D;&#123;data&#125;&gt;\n        &#123;item &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item.name&#96; 类型为 &#96;any&#96;\n          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n<p>这里使用时，item.name 的类型已经成了 any。对于简单数据来说，还可以接收这样类型的丢失，但对于复杂类型，类型的丢失就完全享受不到 TypeScript 所带来的类型便利了。</p>\n<p>上面的实现还有个问题是它规定了列表元素必需是对象，理所应当地就不能处理元始类型数组了，比如无法渲染 [‘wayou’,’niuwayong’] 这样的输入。</p>\n<p>下面使用泛型改造上面的列表组件，让它支持外部传入类型。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface Props&lt;T&gt; &#123;\n  list: T[];\n  children: (item: T, index: number) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List&lt;T&gt;(&#123; list, children &#125;: Props&lt;T&gt;) &#123;\n  &#x2F;&#x2F; 列表中其他逻辑...\n  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;\n&#125;</code></pre>\n<p>改造后，列表元素的类型完全由使用的地方决定，作为列表组件，内部它无须关心，同时对于外部传递的 children 回调中 item 入参，类型也没有丢失。</p>\n<p>使用改造后的泛型列表：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface User &#123;\n  id: number;\n  name: string;\n&#125;\nconst data: User[] &#x3D; [\n  &#123;\n    id: 1,\n    name: &quot;wayou&quot;\n  &#125;,\n  &#123;\n    id: 1,\n    name: &quot;niuwayong&quot;\n  &#125;\n];\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;List list&#x3D;&#123;data&#125;&gt;\n        &#123;item &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;User&#96;\n          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n      &lt;List list&#x3D;&#123;[&quot;wayou&quot;, &quot;niuwayong&quot;]&#125;&gt;\n        &#123;item &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;string&#96;\n          return &lt;div key&#x3D;&#123;item&#125;&gt;&#123;item&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h2 id=\"antd-Table\"><a href=\"#antd-Table\" class=\"headerlink\" title=\"antd Table\"></a>antd Table</h2><p>有人说：“表格那个真心体会到泛型组件”</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;&#x2F; &#x2F;code&#x2F;源码&#x2F;ant-design&#x2F;components&#x2F;table&#x2F;Table.tsx\n...\nexport &#123; ColumnsType, TablePaginationConfig &#125;;\n...\n\nexport interface TableProps&lt;RecordType&gt;extends Omit&lt;\n    RcTableProps&lt;RecordType&gt;,\n    | &#39;transformColumns&#39;\n    | &#39;internalHooks&#39;\n    | &#39;internalRefs&#39;\n    | &#39;data&#39;\n    | &#39;columns&#39;\n    | &#39;scroll&#39;\n    | &#39;emptyText&#39;\n  &gt; &#123;\n  ...\n  columns?: ColumnsType&lt;RecordType&gt;;\n  ...\n  &#125;\n\nfunction Table&lt;RecordType extends object &#x3D; any&gt;(props: TableProps&lt;RecordType&gt;) &#123;\n  ...\n  const &#123;\n    ...\n    columns,\n    ...\n  &#125; &#x3D; props;\n  &#x2F;&#x2F; 转化后的，之后直接用于 RcTable\n  const mergedColumns &#x3D; React.useMemo(() &#x3D;&gt; &#123;\n    const matched &#x3D; new Set(Object.keys(screens).filter((m: Breakpoint) &#x3D;&gt; screens[m]));\n\n    return (columns || convertChildrenToColumns(children)).filter(\n      (c: ColumnType&lt;RecordType&gt;) &#x3D;&gt;\n        !c.responsive || c.responsive.some((r: Breakpoint) &#x3D;&gt; matched.has(r)),\n    );\n  &#125;, [children, columns, screens]);\n&#125;</code></pre>\n\n","text":"泛型类型TypeScript 中，类型（interface, type）是可以声明成泛型的，这很常见。 interface Props&lt;T&gt; &#123; content: T; &#125; 这表明 Props 接口定义了这么一种类型： 它是包含一个 content...","link":"","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"React","slug":"React","count":26,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":20,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">泛型类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">泛型组件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#antd-Table\"><span class=\"toc-text\">antd Table</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React 页面传参数","uid":"6ed47af3bfb605ace618e0b5ed2afe7c","slug":"2022-09-26react-params","date":"2022-09-26T02:45:19.000Z","updated":"2022-09-26T13:04:44.190Z","comments":true,"path":"api/articles/2022-09-26react-params.json","keywords":null,"cover":null,"text":"刷新不丢失更改浏览器url 方案1: input type&#x3D;”search” 方案2: 直接操作location.href 方案3: storage刷新丢失，不刷新保留contextredux","link":"","photos":[],"count_time":{"symbolsCount":103,"symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":26,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":20,"path":"api/tags/React.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"python3 干就完了～","uid":"1ff7bc15a19101d81a6f563025053eaf","slug":"2022-09-24python","date":"2022-09-24T10:21:22.000Z","updated":"2022-10-15T02:11:29.157Z","comments":true,"path":"api/articles/2022-09-24python.json","keywords":null,"cover":[],"text":"Python3 升级$ python --version Python 2.7.15 $ python3 --version Python 3.7.2 $ brew upgrade python@3.10 大概是2019年安装的python 3.7.2版本，看了下文档，有少数内容...","link":"","photos":[],"count_time":{"symbolsCount":"72k","symbolsTime":"1:05"},"categories":[{"name":"Python3","slug":"Python3","count":1,"path":"api/categories/Python3.json"}],"tags":[{"name":"Python3","slug":"Python3","count":1,"path":"api/tags/Python3.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}