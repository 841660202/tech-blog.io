{"title":"React TS 范型组件","uid":"f3f72853c8b7c10482dbb43fb811bec2","slug":"2022-09-25react范型","date":"2022-09-25T11:24:31.000Z","updated":"2023-05-15T13:17:32.961Z","comments":true,"path":"api/articles/2022-09-25react范型.json","keywords":null,"cover":null,"content":"<h2 id=\"泛型类型\"><a href=\"#泛型类型\" class=\"headerlink\" title=\"泛型类型\"></a>泛型类型</h2><p>TypeScript 中，类型（interface, type）是可以声明成泛型的，这很常见。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Props&lt;T&gt; &#123;\n  content: T;\n&#125;</code></pre>\n\n<p>这表明 Props 接口定义了这么一种类型：</p>\n<p>它是包含一个 content 字段的对象, 该 content 字段的类型由使用时的泛型 T 决定</p>\n<p><strong>使用时候 ts 自动推断</strong></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type StringProps &#x3D; Props&lt;string&gt;;\n\nlet props: StringProps;\n\nprops &#x3D; &#123;\n  &#x2F;&#x2F;   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322)\n  content: 42,\n&#125;;\n\nprops &#x3D; &#123;\n  &#x2F;&#x2F; ✅\n  content: &#39;hello&#39;,\n&#125;;</code></pre>\n\n<p>TypeScript 能够跟使用时候提供的值自动推断出类型 T，无需显式指定：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Props&lt;T&gt; &#123;\n  content: T;\n&#125;\n\nfunction Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  console.log(props);\n&#125;\n\n&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;number&gt;(props: Props&lt;number&gt;): void *&#x2F;\nFoo(&#123; content: 42 &#125;);\n\n&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;string&gt;(props: Props&lt;string&gt;): void *&#x2F;\nFoo(&#123; content: &#39;hello&#39; &#125;);</code></pre>\n\n<p>上面因为 Foo 函数接收 <code>Props&lt;T&gt;</code> 作为入参，<br>意味着我们在调用 Foo 的时候需要传递类型 T 以确定<code> Props&lt;T&gt;</code>，所以 Foo 函数也变成了泛型。</p>\n<p>当调用 <code>Foo(&#123; content: 42 &#125;)</code> 的时候，TypeScript 自动解析出 T 为 number，此时对应的函数签名为：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function Foo&lt;number&gt;(props: Props&lt;number&gt;): void;</code></pre>\n\n<p>而我们并没有显式地指定其中的类型 T，像这样 <code>Foo&lt;number&gt;(&#123; content: 42 &#125;)</code>;。</p>\n<h2 id=\"泛型组件\"><a href=\"#泛型组件\" class=\"headerlink\" title=\"泛型组件\"></a>泛型组件</h2><p>将上面的 Foo 函数返回 JSX 元素，就成了一个 React 组件。因为它是泛型函数，它所形成的组件也就成了 泛型组件&#x2F;Generic Components。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">function Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  return &lt;div&gt; &#123;props.content&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;\n      &lt;Foo&lt;string&gt; &#x2F;**真的有点奇葩，理却是这个理 *&#x2F; content&#x3D;&#123;&#39;hello&#39;&#125;&gt;&lt;&#x2F;Foo&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<p>因为 TypeScript 可根据传入的实际值解析泛型类型，所以 <code>&lt;Foo&lt;string&gt; content=&#123;&quot;hello&quot;&#125;&gt;&lt;/Foo&gt;</code> 中 string 是可选的，这里只为展示，让你看到其实 React 组件还可以这么玩。</p>\n<p>为了进一步理解泛型组件，再看下非泛型情况下上面的组件是长怎样的。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface Props &#123;\n  content: string;\n&#125;\n\nfunction Foo(props: Props) &#123;\n  return &lt;div&gt;&#123;props.content&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &#123;&#x2F;*   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322) *&#x2F;&#125;\n      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;\n      &lt;Foo content&#x3D;&#123;&#39;hello&#39;&#125;&gt;&lt;&#x2F;Foo&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<p>以上，便是一个 React 组件常规的写法。它定义的入参 Props 只接收 string 类型。由此也看出泛型的优势，即大部分代码可复用的情况下，将参数变成泛型后，不同类型的入参可复用同一组件，不用为新类型新写一个组件。</p>\n<p>除了函数组件，对于类类型的组件来说，也是一样可泛型化的。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface Props&lt;T&gt; &#123;\n  content: T;\n&#125;\n\nclass Bar&lt;T&gt; extends React.Component&lt;Props&lt;T&gt;&gt; &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.content&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Bar content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Bar&gt;\n      &lt;Bar&lt;string&gt; content&#x3D;&#123;&#39;hello&#39;&#125;&gt;&lt;&#x2F;Bar&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<p>一个更加真实的示例<br>一个更加实用的示例是列表组件。列表中的分页加载，滚动刷新逻辑等，对于所有列表数据都是通用的，将这个列表组件书写成泛型便可和任意类型列表数据结合，而无须通过其他方式来达到复用的目的，将列表元素声明成 any 或 Record&lt;string,any&gt; 等类型。</p>\n<p>先看不使用泛型情况下，如何实现这么一个列表组件。此处只看列表元素的展示以阐述泛型的作用，其他逻辑比如数据加载等先忽略。</p>\n<p>列表组件 List.tsx</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface Item &#123;\n  [prop: string]: any;\n&#125;\n\ninterface Props &#123;\n  list: Item[];\n  children: (item: Item, index: number) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List(&#123; list, children &#125;: Props) &#123;\n  &#x2F;&#x2F; 列表中其他逻辑...\n  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;\n&#125;</code></pre>\n\n<p>上面，为了尽可能满足大部分数据类型，将列表的元素类型定义成了 <code>[prop: string]: any;</code> 的形式，其实和 <code>Record&lt;string,any&gt; </code>没差。在这里已经可以看到类型的丢失了，因为出现了 <code>any</code>，而我们使用 TypeScript 的首要准则是<code>尽量避免 any</code>。</p>\n<p>然后是使用上面所定义的列表组件：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface User &#123;\n  id: number;\n  name: string;\n&#125;\nconst data: User[] &#x3D; [\n  &#123;\n    id: 1,\n    name: &#39;wayou&#39;,\n  &#125;,\n  &#123;\n    id: 1,\n    name: &#39;niuwayong&#39;,\n  &#125;,\n];\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;List list&#x3D;&#123;data&#125;&gt;\n        &#123;(item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item.name&#96; 类型为 &#96;any&#96;\n          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<p>这里使用时，item.name 的类型已经成了 any。对于简单数据来说，还可以接收这样类型的丢失，但对于复杂类型，类型的丢失就完全享受不到 TypeScript 所带来的类型便利了。</p>\n<p>上面的实现还有个问题是它规定了列表元素必需是对象，理所应当地就不能处理元始类型数组了，比如无法渲染 [‘wayou’,’niuwayong’] 这样的输入。</p>\n<p>下面使用泛型改造上面的列表组件，让它支持外部传入类型。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface Props&lt;T&gt; &#123;\n  list: T[];\n  children: (item: T, index: number) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List&lt;T&gt;(&#123; list, children &#125;: Props&lt;T&gt;) &#123;\n  &#x2F;&#x2F; 列表中其他逻辑...\n  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;\n&#125;</code></pre>\n\n<p>改造后，列表元素的类型完全由使用的地方决定，作为列表组件，内部它无须关心，同时对于外部传递的 children 回调中 item 入参，类型也没有丢失。</p>\n<p>使用改造后的泛型列表：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface User &#123;\n  id: number;\n  name: string;\n&#125;\nconst data: User[] &#x3D; [\n  &#123;\n    id: 1,\n    name: &#39;wayou&#39;,\n  &#125;,\n  &#123;\n    id: 1,\n    name: &#39;niuwayong&#39;,\n  &#125;,\n];\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;List list&#x3D;&#123;data&#125;&gt;\n        &#123;(item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;User&#96;\n          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n      &lt;List list&#x3D;&#123;[&#39;wayou&#39;, &#39;niuwayong&#39;]&#125;&gt;\n        &#123;(item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;string&#96;\n          return &lt;div key&#x3D;&#123;item&#125;&gt;&#123;item&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h2 id=\"范型组件的优势\"><a href=\"#范型组件的优势\" class=\"headerlink\" title=\"范型组件的优势\"></a>范型组件的优势</h2><p>泛型的优势，即<code>大部分代码可复用的情况下，将参数变成泛型后，不同类型的入参可复用同一组件，不用为新类型新写一个组件</code></p>\n<h2 id=\"antd-Table\"><a href=\"#antd-Table\" class=\"headerlink\" title=\"antd Table\"></a>antd Table</h2><p>有人说：“表格那个真心体会到泛型组件”</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">&#x2F;&#x2F; &#x2F;code&#x2F;源码&#x2F;ant-design&#x2F;components&#x2F;table&#x2F;Table.tsx\n...\nexport &#123; ColumnsType, TablePaginationConfig &#125;;\n...\n\nexport interface TableProps&lt;RecordType&gt;extends Omit&lt;\n    RcTableProps&lt;RecordType&gt;,\n    | &#39;transformColumns&#39;\n    | &#39;internalHooks&#39;\n    | &#39;internalRefs&#39;\n    | &#39;data&#39;\n    | &#39;columns&#39;\n    | &#39;scroll&#39;\n    | &#39;emptyText&#39;\n  &gt; &#123;\n  ...\n  columns?: ColumnsType&lt;RecordType&gt;;\n  ...\n  &#125;\n\nfunction Table&lt;RecordType extends object &#x3D; any&gt;(props: TableProps&lt;RecordType&gt;) &#123;\n  ...\n  const &#123;\n    ...\n    columns,\n    ...\n  &#125; &#x3D; props;\n  &#x2F;&#x2F; 转化后的，之后直接用于 RcTable\n  const mergedColumns &#x3D; React.useMemo(() &#x3D;&gt; &#123;\n    const matched &#x3D; new Set(Object.keys(screens).filter((m: Breakpoint) &#x3D;&gt; screens[m]));\n\n    return (columns || convertChildrenToColumns(children)).filter(\n      (c: ColumnType&lt;RecordType&gt;) &#x3D;&gt;\n        !c.responsive || c.responsive.some((r: Breakpoint) &#x3D;&gt; matched.has(r)),\n    );\n  &#125;, [children, columns, screens]);\n&#125;</code></pre>\n\n<h2 id=\"React-typescript-范型组件-chatGPT\"><a href=\"#React-typescript-范型组件-chatGPT\" class=\"headerlink\" title=\"React typescript 范型组件 chatGPT\"></a>React typescript 范型组件 chatGPT</h2><p>在 React 中使用 TypeScript，可以使用范型（Generics）来定义组件的类型，以适应不同的数据类型和数据结构。</p>\n<p>具体来说，如果需要定义一个可以接受任意数据类型的 props 的组件，可以使用范型来定义 props 的类型。例如：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import React from &#39;react&#39;;\n\ninterface Props&lt;T&gt; &#123;\n  data: T[];\n  renderItem: (item: T) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  const &#123; data, renderItem &#125; &#x3D; props;\n\n  return (\n    &lt;ul&gt;\n      &#123;data.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;renderItem(item)&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;</code></pre>\n\n<p>在上面的代码中，我们使用 <code>Props&lt;T&gt;</code> 来定义 props 的类型，其中 <code>T</code> 是范型参数，表示可以接受任意数据类型的数据。然后在组件中使用这个范型参数来定义 <code>data</code> 属性的类型，以及 <code>renderItem</code> 方法的参数类型和返回值类型。</p>\n<p>当使用这个组件时，需要传入一个具体的数据类型作为 <code>T</code> 的值，例如：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">interface User &#123;\n  id: number;\n  name: string;\n  age: number;\n&#125;\n\nfunction App() &#123;\n  const users: User[] &#x3D; [\n    &#123; id: 1, name: &#39;Alice&#39;, age: 20 &#125;,\n    &#123; id: 2, name: &#39;Bob&#39;, age: 25 &#125;,\n    &#123; id: 3, name: &#39;Charlie&#39;, age: 30 &#125;,\n  ];\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User List&lt;&#x2F;h1&gt;\n      &lt;List&lt;User&gt;\n        data&#x3D;&#123;users&#125;\n        renderItem&#x3D;&#123;(user) &#x3D;&gt; (\n          &lt;div&gt;\n            &lt;p&gt;Name: &#123;user.name&#125;&lt;&#x2F;p&gt;\n            &lt;p&gt;Age: &#123;user.age&#125;&lt;&#x2F;p&gt;\n          &lt;&#x2F;div&gt;\n        )&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<p>在上面的代码中，我们传入一个类型为 <code>User[]</code> 的数组作为 <code>data</code> 属性的值，并定义一个渲染方法，用来渲染每个用户的信息。由于我们在组件中使用了范型参数 <code>T</code>，因此 TypeScript 可以根据传入的数据类型自动推导出 <code>data</code> 和 <code>renderItem</code> 的类型，从而确保类型安全。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://blog.csdn.net/sinat_17775997/article/details/102514763\" target=\"_blank\" >见</a></p>\n<p><a href=\"https://www.jianshu.com/p/6c438ccfd285\" target=\"_blank\" >React——table 泛型</a></p>\n<p><a href=\"https://blog.csdn.net/qq_33051709/article/details/118487227#:~:text=JSX%20%E8%AF%AD%E6%B3%95%E5%86%B2%E7%AA%81-,%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%A6%82%E4%B8%8B,-%E6%88%96%E8%80%85%20%E6%B7%BB%E5%8A%A0%20extends\" target=\"_blank\" >React 箭头函数组件使用泛型</a></p>\n","text":"泛型类型TypeScript 中，类型（interface, type）是可以声明成泛型的，这很常见。 interface Props&lt;T&gt; &#123; content: T; &#125; 这表明 Props 接口定义了这么一种类型： 它是包含一个 content...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"React","slug":"React","count":39,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":33,"path":"api/tags/React.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">泛型类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">泛型组件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9E%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">范型组件的优势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#antd-Table\"><span class=\"toc-text\">antd Table</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-typescript-%E8%8C%83%E5%9E%8B%E7%BB%84%E4%BB%B6-chatGPT\"><span class=\"toc-text\">React typescript 范型组件 chatGPT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">相关链接</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Chrome Extension","uid":"caa824bced9b699073234ee0cec471c8","slug":"2022-09-27chrome-extension","date":"2022-09-27T14:12:28.000Z","updated":"2022-10-15T02:11:29.158Z","comments":true,"path":"api/articles/2022-09-27chrome-extension.json","keywords":null,"cover":[],"text":"动机ModHeader，交互丑也就罢了，用Cookie还要收费,多大点事～ 还跟我要钱 chrome extension官网chrome extension官网 收集 原生 vite + vue3 vite + react create-react-app 见 原生的优点：是容易...","link":"","photos":[],"count_time":{"symbolsCount":659,"symbolsTime":"1 mins."},"categories":[{"name":"Chrome","slug":"Chrome","count":2,"path":"api/categories/Chrome.json"}],"tags":[{"name":"Chrome","slug":"Chrome","count":3,"path":"api/tags/Chrome.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"python","uid":"b3aebf06f866bf48f5b4df028fe75c8a","slug":"2022-09-24python","date":"2022-09-24T10:21:22.000Z","updated":"2022-12-05T13:02:15.574Z","comments":true,"path":"api/articles/2022-09-24python.json","keywords":null,"cover":[],"text":"Python3 升级官网 https://github.com/python/cpython https://github.com/golang/go $ python --version Python 2.7.15 $ python3 --version Python 3.7....","link":"","photos":[],"count_time":{"symbolsCount":"72k","symbolsTime":"1:05"},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>自律，为了更好的自己</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}