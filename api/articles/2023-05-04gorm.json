{"title":"Gorm的一些疑问","uid":"0a2a2b57038aa5719495ef60739019cc","slug":"2023-05-04gorm","date":"2023-05-04T01:31:34.000Z","updated":"2023-05-15T13:17:33.002Z","comments":true,"path":"api/articles/2023-05-04gorm.json","keywords":null,"cover":null,"content":"<h3 id=\"gorm\"><a href=\"#gorm\" class=\"headerlink\" title=\"gorm\"></a>gorm</h3><p><a href=\"https://blog.csdn.net/u010525694/article/details/94294890\" target=\"_blank\" >gorm 中文文档</a></p>\n<h3 id=\"golang-gorm-有哪些-API\"><a href=\"#golang-gorm-有哪些-API\" class=\"headerlink\" title=\"golang gorm 有哪些 API\"></a>golang gorm 有哪些 API</h3><p>Golang 的 ORM 库 GORM 是一个流行的数据库操作库，提供了丰富的 API 用于进行数据库操作。以下是 GORM 库的一些常用 API：</p>\n<ol>\n<li>创建连接：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db, err :&#x3D; gorm.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1:3306)&#x2F;dbname?charset&#x3D;utf8&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;)</code></pre>\n\n<ol start=\"2\">\n<li>定义模型（定义数据库表结构）：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID   uint\n    Name string\n    Age  int\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>创建表：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.CreateTable(&amp;User&#123;&#125;)</code></pre>\n\n<ol start=\"4\">\n<li>插入记录：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">user :&#x3D; User&#123;Name: &quot;John&quot;, Age: 30&#125;\ndb.Create(&amp;user)</code></pre>\n\n<ol start=\"5\">\n<li>查询记录：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.First(&amp;user, 1) &#x2F;&#x2F; 查询ID为1的记录并将结果存入user变量</code></pre>\n\n<ol start=\"6\">\n<li>更新记录：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Model(&amp;user).Update(&quot;Age&quot;, 40) &#x2F;&#x2F; 将user的Age字段更新为40</code></pre>\n\n<ol start=\"7\">\n<li>删除记录：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Delete(&amp;user) &#x2F;&#x2F; 删除user记录</code></pre>\n\n<ol start=\"8\">\n<li>查询多条记录：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var users []User\ndb.Find(&amp;users)</code></pre>\n\n<ol start=\"9\">\n<li>使用条件查询：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Where(&quot;age &gt; ?&quot;, 30).Find(&amp;users) &#x2F;&#x2F; 查询年龄大于30的记录</code></pre>\n\n<ol start=\"10\">\n<li>使用事务：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">tx :&#x3D; db.Begin()\n&#x2F;&#x2F; 在事务中执行数据库操作\ntx.Create(&amp;user)\ntx.Delete(&amp;user)\ntx.Commit() &#x2F;&#x2F; 提交事务</code></pre>\n\n<ol start=\"11\">\n<li>使用预加载（Eager Loading）优化查询：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var users []User\ndb.Preload(&quot;Profile&quot;).Find(&amp;users) &#x2F;&#x2F; 预加载关联的Profile模型，减少查询次数</code></pre>\n\n<p>以上只是 GORM 库提供的一部分 API，GORM 还提供了许多其他功能，如关联查询、分页查询、原生 SQL 执行、钩子函数等。你可以查看 GORM 官方文档（<a href=\"https://gorm.io)以获取更详细的api参考和示例代码./\">https://gorm.io）以获取更详细的API参考和示例代码。</a></p>\n<h3 id=\"一对一\"><a href=\"#一对一\" class=\"headerlink\" title=\"一对一\"></a>一对一</h3><p>在 GORM 中，一对一（One-to-One）关联是指两个模型之间的关联关系，其中一个模型的实例对应着另一个模型的实例。以下是 GORM 中一对一关联的常用 API：</p>\n<ol>\n<li>定义模型：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID       uint\n    Name     string\n    Age      int\n    Profile  Profile &#x2F;&#x2F; 与Profile模型建立一对一关联\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    UserID   uint &#x2F;&#x2F; 通过UserID字段与User模型建立外键关联\n    Address  string\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>创建表：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.CreateTable(&amp;User&#123;&#125;)\ndb.CreateTable(&amp;Profile&#123;&#125;)</code></pre>\n\n<ol start=\"3\">\n<li>插入记录：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">profile :&#x3D; Profile&#123;Address: &quot;1234 Main St.&quot;&#125;\nuser :&#x3D; User&#123;Name: &quot;John&quot;, Age: 30, Profile: profile&#125; &#x2F;&#x2F; 将Profile关联到User\ndb.Create(&amp;user)</code></pre>\n\n<ol start=\"4\">\n<li>查询记录（包含关联记录）：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Preload(&quot;Profile&quot;).First(&amp;user, 1) &#x2F;&#x2F; 查询ID为1的User记录，并关联查询其对应的Profile记录</code></pre>\n\n<ol start=\"5\">\n<li>更新关联记录：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Model(&amp;user).Update(&quot;Profile.Address&quot;, &quot;5678 Elm St.&quot;) &#x2F;&#x2F; 更新关联的Profile记录的Address字段</code></pre>\n\n<ol start=\"6\">\n<li>解除关联关系：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Model(&amp;user).Association(&quot;Profile&quot;).Delete(&amp;user.Profile) &#x2F;&#x2F; 解除User与Profile的关联关系</code></pre>\n\n<p>需要注意的是，GORM 中的一对一关联需要通过外键字段进行关联，如上面的示例中的<code>UserID</code>字段。GORM 还提供了其他丰富的一对一关联操作，如设置外键、设置级联关系、查询关联记录、创建关联记录等。详细的一对一关联操作请参考 GORM 官方文档（<a href=\"https://gorm.io/docs/associations.html#one-to-one%EF%BC%89%E4%BB%A5%E8%8E%B7%E5%8F%96%E6%9B%B4%E8%AF%A6%E7%BB%86%E7%9A%84API%E5%8F%82%E8%80%83%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E3%80%82\">https://gorm.io/docs/associations.html#one-to-one）以获取更详细的API参考和示例代码。</a></p>\n<h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><ol>\n<li>belongto，我属于你，你给我打标记</li>\n<li>hasone 我拥有你，我给你打标记</li>\n<li>belongto 是 hasone 的反向，从我的角度：我是你的，从你的角度：你是拥有我的</li>\n</ol>\n<h3 id=\"belongto-与-hasone-的区别\"><a href=\"#belongto-与-hasone-的区别\" class=\"headerlink\" title=\"belongto 与 hasone 的区别\"></a>belongto 与 hasone 的区别</h3><ol>\n<li>belongto: 在包含外键的模型中定义关联字段来实现</li>\n<li>hasone: 在包含外键的模型中定义关联字段，并在关联的模型中添加外键字段来实现</li>\n</ol>\n<p>在 GORM 中，<code>BelongsTo</code>和<code>HasOne</code>是两种不同的关联类型，用于建立模型之间的关联关系，分别表示一对一的反向关联和正向关联。</p>\n<ol>\n<li><code>BelongsTo</code>关联：<code>BelongsTo</code>表示一对一的反向关联，即一个模型关联到另一个模型，但另一个模型没有关联回来。在数据库中，这通常通过在包含外键的模型中定义关联字段来实现。例如：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; BelongsTo关联，一个User对应一个Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>Profile</code>模型通过在其定义中添加一个<code>UserID</code>字段与<code>User</code>模型建立了<code>BelongsTo</code>关联，表示一个<code>Profile</code>对应一个<code>User</code>。</p>\n<ol start=\"2\">\n<li><code>HasOne</code>关联：<code>HasOne</code>表示一对一的正向关联，即一个模型关联到另一个模型，并且另一个模型也关联回来。在数据库中，这通常通过在包含外键的模型中定义关联字段，并在关联的模型中添加外键字段来实现。例如：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; HasOne关联，一个User对应一个Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    User     User &#x2F;&#x2F; 关联回User模型\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>User</code>模型通过在其定义中添加一个<code>Profile</code>字段与<code>Profile</code>模型建立了<code>HasOne</code>关联，表示一个<code>User</code>对应一个<code>Profile</code>，并且<code>Profile</code>模型通过在其定义中添加一个<code>UserID</code>字段与<code>User</code>模型建立了外键关联，并关联回了<code>User</code>模型。</p>\n<p>总结而言，<br><code>BelongsTo</code>关联表示一对一的反向关联，只在包含外键的模型中定义关联字段；<br>而<code>HasOne</code>关联表示一对一的正向关联，既在包含外键的模型中定义关联字段，也在关联的模型中添加外键字段并关联回来。</p>\n<p>两者在使用上略有差异，具体的选择取决于你的数据模型设计和业务需求。</p>\n<h3 id=\"gorm-BelongsTo-和-HasOne-的适用场景\"><a href=\"#gorm-BelongsTo-和-HasOne-的适用场景\" class=\"headerlink\" title=\"gorm BelongsTo 和 HasOne 的适用场景\"></a>gorm BelongsTo 和 HasOne 的适用场景</h3><p>在 GORM 中，<code>BelongsTo</code>和<code>HasOne</code>是两种不同的关联类型，适用于不同的场景。</p>\n<ol>\n<li><code>BelongsTo</code>适用场景：<br><code>BelongsTo</code>表示一对一的反向关联，适用于以下场景：</li>\n</ol>\n<ul>\n<li>当一个模型（称为子模型）属于另一个模型（称为父模型），并且子模型中包含了父模型的外键字段时。</li>\n<li>当你需要在查询子模型时，自动加载关联的父模型。</li>\n</ul>\n<p>例如，一个用户（User）模型关联一个配置文件（Profile）模型，其中配置文件（Profile）模型包含了用户（User）模型的外键字段，那么可以使用<code>BelongsTo</code>关联来表示这种关系。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 父模型\ntype User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; BelongsTo关联，一个User对应一个Profile\n&#125;\n&#x2F;&#x2F; 子模型 子模型中包含了父模型的外键字段时\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li><code>HasOne</code>适用场景：<br><code>HasOne</code>表示一对一的正向关联，适用于以下场景：</li>\n</ol>\n<ul>\n<li>当一个模型（称为父模型）关联一个模型（称为子模型），并且子模型中包含了父模型的外键字段时。</li>\n<li>当你需要在查询父模型时，自动加载关联的子模型。</li>\n</ul>\n<p>例如，一个用户（User）模型关联一个配置文件（Profile）模型，其中用户（User）模型包含了配置文件（Profile）模型的外键字段，那么可以使用<code>HasOne</code>关联来表示这种关系。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 父模型\ntype User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; HasOne关联，一个User对应一个Profile\n&#125;\n&#x2F;&#x2F; 子模型， 子模型中包含了父模型的外键字段时\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    User     User &#x2F;&#x2F; 关联回User模型\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;</code></pre>\n\n<p>需要根据具体的数据模型设计和业务需求来选择使用<code>BelongsTo</code>还是<code>HasOne</code>关联。如果子模型包含了父模型的外键字段，则使用<code>BelongsTo</code>关联；如果父模型包含了子模型的外键字段，并且需要在查询父模型时自动加载关联的子模型，则使用<code>HasOne</code>关联。</p>\n<h3 id=\"两者在数据库数据查询返回有什么不同\"><a href=\"#两者在数据库数据查询返回有什么不同\" class=\"headerlink\" title=\"两者在数据库数据查询返回有什么不同\"></a>两者在数据库数据查询返回有什么不同</h3><p>在 GORM 中，<code>BelongsTo</code>和<code>HasOne</code>在数据库数据查询返回时有一些不同。</p>\n<ol>\n<li><code>BelongsTo</code>关联：</li>\n</ol>\n<ul>\n<li>当使用<code>BelongsTo</code>关联时，通过查询子模型（包含外键字段）可以自动加载关联的父模型。例如，当查询用户（User）模型时，可以自动加载关联的配置文件（Profile）模型，从而在结果中包含了关联的父模型的数据。</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Preload(&quot;Profile&quot;).First(&amp;user)\n&#x2F;&#x2F; 上述代码中，使用了Preload方法加载了关联的Profile模型，从而在查询用户模型时自动加载了关联的父模型数据。</code></pre>\n\n<ol start=\"2\">\n<li><code>HasOne</code>关联：</li>\n</ol>\n<ul>\n<li>当使用<code>HasOne</code>关联时，通过查询父模型（包含子模型的外键字段）可以自动加载关联的子模型。例如，当查询配置文件（Profile）模型时，可以自动加载关联的用户（User）模型，从而在结果中包含了关联的子模型的数据。</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var profile Profile\ndb.Preload(&quot;User&quot;).First(&amp;profile)\n&#x2F;&#x2F; 上述代码中，使用了Preload方法加载了关联的User模型，从而在查询配置文件模型时自动加载了关联的子模型数据。</code></pre>\n\n<p>需要注意的是，在使用<code>BelongsTo</code>和<code>HasOne</code>关联时，都可以使用 GORM 提供的<code>Preload</code>方法来进行预加载，从而在查询时自动加载关联的模型数据，避免了 N+1 查询问题。具体的查询返回结果会根据你的数据模型设计和数据库查询操作而有所不同，但通过预加载关联模型，可以方便地获取关联的数据并避免额外的数据库查询。</p>\n<h3 id=\"User-BelongsTo-Profile\"><a href=\"#User-BelongsTo-Profile\" class=\"headerlink\" title=\"User BelongsTo Profile\"></a>User BelongsTo Profile</h3><p>对不起，我之前的回答中确实遗漏了 GORM 中关联关系的 tag 设置。下面是正确的示例代码：</p>\n<p>使用 <code>BelongsTo</code> 关联时的结构体定义：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID       uint\n    Profile  Profile   &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96; &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到 User 模型\n&#125;</code></pre>\n\n<h3 id=\"User-HasOne-Profile\"><a href=\"#User-HasOne-Profile\" class=\"headerlink\" title=\"User HasOne Profile\"></a>User HasOne Profile</h3><p>使用 <code>HasOne</code> 关联时的结构体定义：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID       uint\n    Profile  Profile   &#96;gorm:&quot;foreignkey:UserID&quot;&#96; &#x2F;&#x2F; HasOne 关联，一个 User 拥有一个 Profile\n    ProfileID uint      &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n&#125;</code></pre>\n\n<p>在以上示例代码中，使用了 <code>gorm</code> 的 tag 来指定外键字段的名称，通过 <code>foreignkey</code> tag 来显式指定外键字段的名称，从而与关联的模型建立正确的关联关系。</p>\n<p><code>BelongsTo</code> 关联中，<code>User</code> 模型中的 <code>Profile</code> 字段的 tag 设置为 <code>foreignkey:ProfileID</code>，表示 <code>ProfileID</code> 字段在 <code>Profile</code> 模型中用作外键字段，关联到 <code>User</code> 模型的 <code>ID</code> 字段。</p>\n<p><code>HasOne</code> 关联中，<code>User</code> 模型中的 <code>Profile</code> 字段的 tag 设置为 <code>foreignkey:UserID</code>，表示 <code>UserID</code> 字段在 <code>User</code> 模型中用作外键字段，关联到 <code>Profile</code> 模型的 <code>ID</code> 字段。</p>\n<p>根据具体的业务需求和数据库设计，可以根据 <code>gorm</code> 的 tag 设置来正确定义结构体，以建立合适的关联关系。</p>\n<h3 id=\"BelongsTo-建表的结果\"><a href=\"#BelongsTo-建表的结果\" class=\"headerlink\" title=\"BelongsTo 建表的结果\"></a>BelongsTo 建表的结果</h3><p>在使用 GORM 中的 <code>BelongsTo</code> 方法建立一对一关联关系时，对应的数据库表结构通常会包含一个外键字段，用于关联到另一个表的主键。以下是一个示例：</p>\n<p>假设我们有两个模型 <code>User</code> 和 <code>Profile</code>，其中 <code>User</code> 模型通过 <code>BelongsTo</code> 方法与 <code>Profile</code> 模型建立一对一关联关系，其中 <code>User</code> 模型包含一个外键字段 <code>ProfileID</code>，用于关联到 <code>Profile</code> 模型的主键字段 <code>ID</code>。</p>\n<p>定义 <code>User</code> 和 <code>Profile</code> 模型如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID        uint\n    ProfileID uint     &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n    Name      string\n    Profile   Profile  &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96;  &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n&#125;</code></pre>\n\n<p>在以上示例中，<code>User</code> 模型包含了一个名为 <code>ProfileID</code> 的外键字段，用于关联到 <code>Profile</code> 模型的主键字段 <code>ID</code>。通过在 <code>User</code> 模型的 <code>Profile</code> 字段上使用 <code>gorm</code> 的 <code>foreignkey</code> tag，指定了外键字段的名称为 <code>ProfileID</code>。</p>\n<p>对应的数据库表结构可能如下所示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">users 表：\n+----+-------------+------+\n| ID | ProfileID   | Name |\n+----+-------------+------+\n| 1  | 1           | John |\n+----+-------------+------+\n| 2  | 2           | Jane |\n+----+-------------+------+\n\nprofiles 表：\n+----+---------+\n| ID | Address |\n+----+---------+\n| 1  | Addr1   |\n+----+---------+\n| 2  | Addr2   |\n+----+---------+</code></pre>\n\n<p>在以上示例中，<code>users</code> 表包含了一个外键字段 <code>ProfileID</code>，用于关联到 <code>profiles</code> 表的主键字段 <code>ID</code>，从而建立了一对一关联关系。每个 <code>User</code> 对应一个 <code>Profile</code>，通过 <code>ProfileID</code> 字段进行关联。通过 GORM 的 <code>BelongsTo</code> 方法和外键字段的定义，可以在数据库中建立一对一关联关系，并进行相应的查询和操作。</p>\n<h3 id=\"查询的结果\"><a href=\"#查询的结果\" class=\"headerlink\" title=\"查询的结果\"></a>查询的结果</h3><p>通过 GORM 进行查询时，使用 <code>BelongsTo</code> 方法建立的一对一关联关系会在查询结果中包含关联的数据。例如，使用以下的查询代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Preload(&quot;Profile&quot;).First(&amp;user, 1)</code></pre>\n\n<p>其中 <code>db</code> 是 GORM 的数据库连接实例，<code>User</code> 是模型结构体，<code>Profile</code> 是关联的模型结构体。</p>\n<p>以上查询会查询 ID 为 1 的 <code>User</code> 记录，并将关联的 <code>Profile</code> 数据一并查询出来，将其填充到 <code>User</code> 模型的 <code>Profile</code> 字段中。</p>\n<p>查询结果会包含关联的 <code>Profile</code> 数据，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#123;\n  &quot;ID&quot;: 1,\n  &quot;ProfileID&quot;: 1,\n  &quot;Name&quot;: &quot;John&quot;,\n  &quot;Profile&quot;: &#123;\n    &quot;ID&quot;: 1,\n    &quot;Address&quot;: &quot;Addr1&quot;\n  &#125;\n&#125;</code></pre>\n\n<p>可以看到，查询结果中包含了 <code>Profile</code> 数据，它作为 <code>User</code> 模型的嵌套字段被填充到了 <code>Profile</code> 字段中。这样可以方便地获取一对一关联关系的数据，并进行操作和处理。</p>\n<h3 id=\"sqlite-完整事例代码\"><a href=\"#sqlite-完整事例代码\" class=\"headerlink\" title=\"sqlite 完整事例代码\"></a>sqlite 完整事例代码</h3><p>以下是一个完整的示例代码，演示如何使用 GORM 进行一对一关联关系的查询：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    ID        uint\n    ProfileID uint     &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n    Name      string\n    Profile   Profile  &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96;  &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;Failed to connect database&quot;)\n    &#125;\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;)  &#x2F;&#x2F; 自动迁移表结构\n\n    &#x2F;&#x2F; 创建一条 User 记录和对应的 Profile 记录\n    user :&#x3D; User&#123;Name: &quot;John&quot;&#125;\n    profile :&#x3D; Profile&#123;Address: &quot;Addr1&quot;&#125;\n    db.Create(&amp;user)\n    db.Create(&amp;profile)\n    user.ProfileID &#x3D; profile.ID\n    db.Save(&amp;user)\n\n    &#x2F;&#x2F; 查询 User 记录并包含关联的 Profile 数据\n    var result User\n    db.Preload(&quot;Profile&quot;).First(&amp;result, 1)\n\n    &#x2F;&#x2F; 输出查询结果\n    fmt.Printf(&quot;User: %+v\\n&quot;, result)\n    fmt.Printf(&quot;Profile: %+v\\n&quot;, result.Profile)\n&#125;</code></pre>\n\n<p>在以上示例中，首先定义了 <code>User</code> 和 <code>Profile</code> 两个模型，并使用 <code>BelongsTo</code> 方法建立了一对一关联关系。然后通过 GORM 进行数据库连接，并创建了一条 <code>User</code> 记录和对应的 <code>Profile</code> 记录。接着通过 <code>Preload</code> 方法查询 <code>User</code> 记录时，包含了关联的 <code>Profile</code> 数据，最终将查询结果输出到控制台。</p>\n<p>请注意，示例中使用了 SQLite 作为数据库，需要提前安装 SQLite 并创建一个名为 <code>test.db</code> 的数据库文件。实际使用中，数据库连接参数和表结构定义可能需要根据具体情况进行调整。</p>\n<h3 id=\"使用-mysql-作为数据库的代码怎么写\"><a href=\"#使用-mysql-作为数据库的代码怎么写\" class=\"headerlink\" title=\"使用 mysql 作为数据库的代码怎么写\"></a>使用 mysql 作为数据库的代码怎么写</h3><p>以下是一个使用 MySQL 数据库作为存储的完整示例代码，演示如何使用 GORM 进行一对一关联关系的查询：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tID        uint\n\tProfileID uint     &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n\tName      string\n\tProfile   Profile  &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96;  &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n\tID       uint\n\tAddress  string\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接数据库\n\tdsn :&#x3D; &quot;root:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;Failed to connect database&quot;)\n\t&#125;\n\tdb.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;) &#x2F;&#x2F; 自动迁移表结构\n\n\t&#x2F;&#x2F; 创建一条 User 记录和对应的 Profile 记录\n\tuser :&#x3D; User&#123;Name: &quot;John&quot;&#125;\n\tprofile :&#x3D; Profile&#123;Address: &quot;Addr1&quot;&#125;\n\tdb.Create(&amp;user)\n\tdb.Create(&amp;profile)\n\tuser.ProfileID &#x3D; profile.ID\n\tdb.Save(&amp;user)\n\n\t&#x2F;&#x2F; 查询 User 记录并包含关联的 Profile 数据\n\tvar result User\n\tdb.Preload(&quot;Profile&quot;).First(&amp;result, 1)\n\n\t&#x2F;&#x2F; 输出查询结果\n\tfmt.Printf(&quot;User: %+v\\n&quot;, result)\n\tfmt.Printf(&quot;Profile: %+v\\n&quot;, result.Profile)\n&#125;</code></pre>\n\n<p>在以上示例中，我们使用了 GORM 的 MySQL 数据库驱动 <code>gorm.io/driver/mysql</code>，并通过 <code>dsn</code> 参数设置了 MySQL 数据库的连接信息，包括用户名、密码、地址、端口、数据库名称以及连接参数。接着创建了 <code>User</code> 和 <code>Profile</code> 两个模型，并使用 <code>BelongsTo</code> 方法建立了一对一关联关系。其余的创建记录、查询记录和输出查询结果的代码与之前的示例类似。</p>\n<p>请注意，在实际使用中，需要根据自己的 MySQL 数据库配置和表结构定义进行相应的调整。</p>\n<h3 id=\"上述代码的表结构，及建表语句\"><a href=\"#上述代码的表结构，及建表语句\" class=\"headerlink\" title=\"上述代码的表结构，及建表语句\"></a>上述代码的表结构，及建表语句</h3><p>根据以上示例代码，对应的 MySQL 数据库表结构可以如下定义：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- User 表\nCREATE TABLE &#96;users&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;profile_id&#96; INT(10) UNSIGNED NOT NULL,\n  &#96;name&#96; VARCHAR(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  KEY &#96;fk_users_profile&#96; (&#96;profile_id&#96;),\n  CONSTRAINT &#96;fk_users_profile&#96; FOREIGN KEY (&#96;profile_id&#96;) REFERENCES &#96;profiles&#96; (&#96;id&#96;) ON DELETE CASCADE\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;\n\n-- Profile 表\nCREATE TABLE &#96;profiles&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;address&#96; VARCHAR(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</code></pre>\n\n<p>以上 SQL 语句创建了两张表，分别是 <code>users</code> 表和 <code>profiles</code> 表。<code>users</code> 表包含了 <code>id</code>、<code>profile_id</code> 和 <code>name</code> 三个字段，其中 <code>id</code> 是主键，<code>profile_id</code> 是外键，与 <code>profiles</code> 表的 <code>id</code> 字段关联。<code>profiles</code> 表包含了 <code>id</code> 和 <code>address</code> 两个字段，其中 <code>id</code> 是主键。</p>\n<p>在 <code>users</code> 表中，<code>profile_id</code> 字段与 <code>profiles</code> 表的 <code>id</code> 字段建立了外键关系，并通过 <code>CONSTRAINT</code> 定义了外键约束，指定了在删除 <code>profiles</code> 表中的记录时要执行的操作为级联删除 (<code>ON DELETE CASCADE</code>)，即删除 <code>profiles</code> 表中的记录时，会同时删除关联的 <code>users</code> 表中的记录。这样就实现了 User 和 Profile 之间的一对一关联关系。</p>\n<h3 id=\"gorm-注意事项\"><a href=\"#gorm-注意事项\" class=\"headerlink\" title=\"gorm 注意事项\"></a>gorm 注意事项</h3><h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><ol>\n<li>注意从 map 创建时，不会调用钩子，不会保存关联，也不会重新填充主键值</li>\n</ol>\n<h3 id=\"gorm-有哪些-tag\"><a href=\"#gorm-有哪些-tag\" class=\"headerlink\" title=\"gorm 有哪些 tag\"></a>gorm 有哪些 tag</h3><p><code>gorm</code> 是 Go 中一款流行的 ORM（对象关系映射）库，用于操作数据库。<code>gorm</code> 支持使用标签（tag）来对模型（Model）的字段进行注解，以指定其在数据库中的映射行为。以下是 <code>gorm</code> 支持的一些常用的标签（tag）：</p>\n<ol>\n<li><code>gorm:&quot;column:column_name&quot;</code>：指定字段在数据库表中对应的列名。</li>\n<li><code>gorm:&quot;primary_key&quot;</code>：指定字段作为数据库表的主键。</li>\n<li><code>gorm:&quot;type:data_type&quot;</code>：指定字段在数据库中的数据类型，如 <code>int</code>, <code>varchar</code>, <code>text</code> 等。</li>\n<li><code>gorm:&quot;size:size&quot;</code>：指定字段在数据库中的大小限制，如 <code>size:255</code> 表示该字段最大长度为 255。</li>\n<li><code>gorm:&quot;not null&quot;</code>：指定字段不能为空。</li>\n<li><code>gorm:&quot;unique&quot;</code>：指定字段在数据库表中的值必须唯一。</li>\n<li><code>gorm:&quot;index&quot;</code>：为字段创建数据库索引。</li>\n<li><code>gorm:&quot;default:default_value&quot;</code>：指定字段在数据库中的默认值。</li>\n<li><code>gorm:&quot;auto_increment&quot;</code>：指定字段在数据库中自增。</li>\n<li><code>gorm:&quot;precision:precision; scale:scale&quot;</code>：指定字段的精度和小数位数，仅适用于浮点数字段。</li>\n<li><code>gorm:&quot;uniqueIndex:unique_index_name&quot;</code>：为字段创建指定名称的唯一索引。</li>\n<li><code>gorm:&quot;index:idx_name&quot;</code>：为字段创建指定名称的索引。</li>\n<li><code>gorm:&quot;comment:comment&quot;</code>：为字段添加注释。</li>\n</ol>\n<p>以上只是 <code>gorm</code> 支持的一些常用的标签，实际上 <code>gorm</code> 还支持更多的标签，用于配置模型在数据库中的映射行为。通过使用这些标签，我们可以灵活地定义模型的字段属性，并与数据库表的列进行对应，从而实现方便的数据库操作。</p>\n<p>当然，还有更多的 <code>gorm</code> 标签可以用于进一步配置模型在数据库中的映射行为，包括但不限于以下几个：</p>\n<ol start=\"14\">\n<li><code>gorm:&quot;embedded&quot;</code>：指定字段为嵌入式结构体。</li>\n<li><code>gorm:&quot;embeddedPrefix:prefix&quot;</code>：指定嵌入式结构体在数据库表中的列名前缀。</li>\n<li><code>gorm:&quot;polymorphic:polymorphic_field;polymorphic_value&quot;</code>：指定字段为多态关联，用于多表关联查询。</li>\n<li><code>gorm:&quot;foreignkey:foreign_key_field&quot;</code>：指定关联的外键字段。</li>\n<li><code>gorm:&quot;association_foreignkey:association_foreign_key_field&quot;</code>：指定关联的外键字段。</li>\n<li><code>gorm:&quot;many2many:join_table&quot;</code>：指定多对多关联的中间表名称。</li>\n<li><code>gorm:&quot;many2many:join_table:foreignkey:foreign_key;association_foreignkey:association_foreign_key&quot;</code>：指定多对多关联的中间表及外键字段。</li>\n<li><code>gorm:&quot;polymorphic:polymorphic_field;polymorphic_identity:polymorphic_identity_value&quot;</code>：指定多态关联的字段及标识值。</li>\n</ol>\n<p>这些标签可以用于进一步配置模型在数据库中的映射行为，实现更复杂的数据库操作需求。详细的 <code>gorm</code> 标签用法可以参考 <code>gorm</code> 的官方文档：<a href=\"https://gorm.io/docs/models.html#field-attributes\">https://gorm.io/docs/models.html#field-attributes</a></p>\n<p>当然，这还不是全部，<code>gorm</code> 还提供了一些其他的标签，如下：</p>\n<ol start=\"22\">\n<li><code>gorm:&quot;unique&quot;</code>：指定字段在数据库中为唯一值。</li>\n<li><code>gorm:&quot;not null&quot;</code>：指定字段在数据库中不能为空。</li>\n<li><code>gorm:&quot;default:value&quot;</code>：指定字段在数据库中的默认值。</li>\n<li><code>gorm:&quot;index&quot;</code>：为字段创建数据库索引。</li>\n<li><code>gorm:&quot;size:value&quot;</code>：指定字段的数据库大小。</li>\n<li><code>gorm:&quot;precision:value&quot;</code>：指定字段的数据库精度。</li>\n<li><code>gorm:&quot;scale:value&quot;</code>：指定字段的数据库刻度。</li>\n<li><code>gorm:&quot;comment:comment&quot;</code>：为字段添加数据库注释。</li>\n</ol>\n<p>这些标签可以用于进一步定制模型在数据库中的表现形式，满足不同的业务需求。具体使用方法和示例可以参考 <code>gorm</code> 的官方文档：<a href=\"https://gorm.io/docs/models.html#field-attributes\">https://gorm.io/docs/models.html#field-attributes</a></p>\n<p>是的，还有一些其他的 <code>gorm</code> 标签，包括：</p>\n<ol start=\"30\">\n<li><code>gorm:&quot;createIndex&quot;</code>：在创建表时为字段创建索引。</li>\n<li><code>gorm:&quot;updateIndex&quot;</code>：在更新表时为字段创建索引。</li>\n<li><code>gorm:&quot;deleteIndex&quot;</code>：在删除表时删除字段的索引。</li>\n<li><code>gorm:&quot;uniqueIndex&quot;</code>：为字段创建唯一索引。</li>\n<li><code>gorm:&quot;fulltextIndex&quot;</code>：为字段创建全文索引。</li>\n<li><code>gorm:&quot;compositeIndex:composite_index_name&quot;</code>：为字段创建复合索引，并指定索引名称。</li>\n<li><code>gorm:&quot;type:column_type&quot;</code>：指定字段在数据库中的列类型。</li>\n<li><code>gorm:&quot;column:column_name&quot;</code>：指定字段在数据库中的列名称。</li>\n<li><code>gorm:&quot;autoCreateTime&quot;</code>：在创建记录时自动设置字段的创建时间。</li>\n<li><code>gorm:&quot;autoUpdateTime&quot;</code>：在更新记录时自动设置字段的更新时间。</li>\n<li><code>gorm:&quot;primaryKey&quot;</code>：将字段设置为主键。</li>\n<li><code>gorm:&quot;uniqueIndex:unique_index_name&quot;</code>：为字段创建唯一索引，并指定索引名称。</li>\n<li><code>gorm:&quot;check:constraint_name:constraint_expression&quot;</code>：为字段创建检查约束，并指定约束名称和约束表达式。</li>\n</ol>\n<p>这些标签可以用于进一步定制模型在数据库中的映射行为和表现形式，满足更复杂的数据库操作需求。具体使用方法和示例可以参考 <code>gorm</code> 的官方文档：<a href=\"https://gorm.io/docs/models.html#field-attributes\">https://gorm.io/docs/models.html#field-attributes</a></p>\n<p>抱歉，以上列出的是 gorm 中比较常用的标签，目前没有其他的 gorm 标签了。如果有新的版本发布，可能会有新的标签被引入。您可以随时查阅 gorm 的官方文档，以获取最新的信息和更新。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ol>\n<li>db.Table</li>\n<li>db.Rows</li>\n<li>db.Scan</li>\n</ol>\n<h3 id=\"db-Table\"><a href=\"#db-Table\" class=\"headerlink\" title=\"db.Table\"></a>db.Table</h3><p><code>db.Table</code> 是 <code>gorm</code> 库中用于指定查询表名的方法。通过 <code>db.Table</code> 方法，可以在查询时显式指定要查询的数据库表名，而不是使用 <code>gorm</code> 的默认表名推断规则。</p>\n<p>例如，下面是使用 <code>db.Table</code> 方法查询名为 “users” 的数据库表的示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 定义 User 结构体\ntype User struct &#123;\n\tID   uint\n\tName string\n\tAge  int\n&#125;\n\n&#x2F;&#x2F; 使用 db.Table 指定表名为 &quot;users&quot; 进行查询\nvar users []User\ndb.Table(&quot;users&quot;).Find(&amp;users)</code></pre>\n\n<p>在这个示例中，<code>db.Table(&quot;users&quot;)</code> 方法指定了查询的数据库表名为 “users”，然后使用 <code>Find</code> 方法执行查询操作，并将查询结果存储到 <code>users</code> 变量中。</p>\n<p>需要注意的是，使用 <code>db.Table</code> 方法后，<code>gorm</code> 将会完全按照指定的表名进行查询，而不再使用默认的表名推断规则。这可以在需要查询非默认表名的情况下使用，例如当查询多个不同表结构相似的表时，或者当需要查询不在 <code>gorm</code> 模型定义中的表时。</p>\n<h3 id=\"FirstOrInit-x2F-FirstOrCreate\"><a href=\"#FirstOrInit-x2F-FirstOrCreate\" class=\"headerlink\" title=\"FirstOrInit&#x2F;FirstOrCreate\"></a>FirstOrInit&#x2F;FirstOrCreate</h3><ol>\n<li>db.FirstOrInit 有点像多态</li>\n<li>Attrs 不会被用于生成查询 SQL, 找不到仅用于创建，找到了无效</li>\n<li>不管是否找到记录，Assign 都会将属性赋值给 struct，但这些属性不会被用于生成查询 SQL，也不会被保存到数据库</li>\n</ol>\n<p><strong>gorm FirstOrCreate 和 FirstOrInit 的区别：</strong></p>\n<p><code>FirstOrCreate</code> 和 <code>FirstOrInit</code> 都是 GORM 提供的查询方法，用于在数据库中查找记录。它们的区别在于：</p>\n<ul>\n<li><p><code>FirstOrCreate</code> 方法会在数据库中查找符合条件的记录，如果找到了则返回该记录，否则会创建一条新记录并返回。如果创建新记录时需要设置一些默认值，可以在调用 <code>FirstOrCreate</code> 方法之前为相应字段设置默认值。</p>\n</li>\n<li><p><code>FirstOrInit</code> 方法也会在数据库中查找符合条件的记录，如果找到了则返回该记录，否则会返回一个未保存的新记录（即未设置主键的新实例），然后可以对新实例进行修改并保存到数据库中。</p>\n</li>\n</ul>\n<p>举个例子，假设我们有一个 <code>User</code> 模型，要根据用户名查找用户记录，如果找到则返回该记录，否则创建一条新记录并返回。可以使用 <code>FirstOrCreate</code> 方法来实现：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrCreate(&amp;user)</code></pre>\n\n<p>如果数据库中已经存在用户名为 “Alice” 的用户记录，则会返回该记录，否则会创建一条新记录并返回。</p>\n<p>另一方面，如果我们要返回一个未保存的新用户实例（即未设置主键的新记录），可以使用 <code>FirstOrInit</code> 方法：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrInit(&amp;user)</code></pre>\n\n<p>如果数据库中已经存在用户名为 “Alice” 的用户记录，则会返回该记录，否则会返回一个未保存的新用户实例。我们可以对新实例进行修改并保存到数据库中：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">if user.ID &#x3D;&#x3D; 0 &#123;\n  user.Name &#x3D; &quot;Alice&quot;\n  db.Create(&amp;user)\n&#125; else &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p><code>FirstOrCreate</code> 和 <code>FirstOrInit</code> 方法还有一些注意事项：</p>\n<ul>\n<li><p><code>FirstOrCreate</code> 方法不仅可以根据一个条件查找记录，还可以根据多个条件查找记录，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Where(User&#123;Name: &quot;Alice&quot;, Age: 18&#125;).FirstOrCreate(&amp;user)</code></pre>\n</li>\n<li><p><code>FirstOrInit</code> 方法只能根据一个条件查找记录，如果要根据多个条件查找记录，可以使用 <code>Where</code> 方法指定多个条件，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Where(&quot;name &#x3D; ? AND age &#x3D; ?&quot;, &quot;Alice&quot;, 18).FirstOrInit(&amp;user)</code></pre>\n</li>\n<li><p><code>FirstOrInit</code> 方法返回的是一个未保存的新实例，因此如果要在返回结果之后进行更新操作，需要调用 <code>Save</code> 方法将新实例保存到数据库中，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrInit(&amp;user)\nuser.Age &#x3D; 18\ndb.Save(&amp;user)</code></pre>\n\n<p>如果只是想修改内存中的实例而不保存到数据库中，可以使用 <code>Updates</code> 方法，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrInit(&amp;user)\ndb.Model(&amp;user).Updates(User&#123;Age: 18&#125;)</code></pre></li>\n</ul>\n<p>还有一点需要注意的是，<code>FirstOrCreate</code> 和 <code>FirstOrInit</code> 方法都是使用 <code>SELECT ... FROM ... WHERE ... LIMIT 1</code> 的方式查询数据库的。如果需要查询的条件有索引，这种方式可以有效地利用索引，提高查询性能。但如果需要查询的条件没有索引，这种方式可能会导致全表扫描，查询速度会比较慢。</p>\n<p>另外，如果需要查询的条件不唯一，即有多条记录符合条件，那么 <code>FirstOrCreate</code> 和 <code>FirstOrInit</code> 方法都只会返回其中的一条记录。如果需要返回所有符合条件的记录，可以使用 <code>Find</code> 方法进行查询，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var users []User\ndb.Where(&quot;age &#x3D; ?&quot;, 18).Find(&amp;users)</code></pre>\n\n<p>这样就可以返回所有年龄为 18 的用户记录了。</p>\n<h3 id=\"零值处理\"><a href=\"#零值处理\" class=\"headerlink\" title=\"零值处理\"></a>零值处理</h3><ol>\n<li>Save 会保存所有的字段，即使字段是零值（如果保存值不包含主键，它将执行 Create，否则将执行 Update（包含所有字段））</li>\n<li>Update<ol>\n<li>更新支持使用 struct 或 map[string]face{}更新，使用 struct 更新时默认只会更新非零字段</li>\n<li>注意使用 struct 更新时，GORM 只会更新非零字段。您可能希望使用 map 来更新属性或使用 Select 来指定要更新的字段</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"gorm-dryrun\"><a href=\"#gorm-dryrun\" class=\"headerlink\" title=\"gorm dryrun\"></a>gorm dryrun</h3><p>在 Gorm 中，DryRun 模式是一种用于调试 SQL 语句的特殊模式。当你在开发阶段使用 Gorm 时，你可能会需要查看 Gorm 生成的 SQL 语句，以便确定 Gorm 是否正确地生成了预期的 SQL 语句。DryRun 模式允许你在不实际执行 SQL 语句的情况下查看生成的 SQL 语句。</p>\n<p>在 Gorm 中启用 DryRun 模式非常简单。只需将 <code>db.Session(&amp;gorm.Session&#123;DryRun: true&#125;)</code> 作为查询的第一个参数传递给 Gorm，即可启用 DryRun 模式。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">db.Session(&amp;gorm.Session&#123;DryRun: true&#125;).Find(&amp;users)</code></pre>\n\n<p>在上面的示例中，我们将 DryRun 模式启用，并通过 <code>Find</code> 方法查询了用户数据。由于我们启用了 DryRun 模式，Gorm 只会生成 SQL 语句，并将其打印到控制台上，而不会实际执行 SQL 语句。你可以通过查看控制台输出来检查生成的 SQL 语句是否正确。</p>\n<h3 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h3><p>在使用 Gorm 或任何其他 ORM（对象关系映射）库时，确保 SQL 安全是非常重要的，以防止 SQL 注入攻击。下面是一些在使用 Gorm 时保持 SQL 安全的建议：</p>\n<ol>\n<li>使用参数化查询（Prepared Statements）：Gorm 默认使用参数化查询，这可以防止 SQL 注入攻击。参数化查询将查询参数与 SQL 查询语句分开，确保参数不会被解释为 SQL 代码。在 Gorm 中，你可以使用 <code>db.Preload()</code>、<code>db.Where()</code>、<code>db.First()</code> 等方法进行查询，并将查询参数作为参数传递，而不是将其直接嵌入到 SQL 查询语句中。</li>\n</ol>\n<p>例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">name :&#x3D; &quot;John&quot;\nage :&#x3D; 25\ndb.Where(&quot;name &#x3D; ?&quot;, name).Where(&quot;age &gt; ?&quot;, age).Find(&amp;users)</code></pre>\n\n<ol start=\"2\">\n<li>不要直接拼接 SQL 查询语句：避免将用户输入或其他未经验证的数据直接拼接到 SQL 查询语句中，这可能会导致 SQL 注入攻击。相反，使用 Gorm 提供的方法来构建查询，如 <code>db.Where()</code>、<code>db.Or()</code>、<code>db.Not()</code> 等，这些方法会自动处理参数化查询。</li>\n</ol>\n<p>例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">name :&#x3D; &quot;John&quot;\nage :&#x3D; 25\ndb.Where(&quot;name &#x3D; ?&quot;, name).Where(&quot;age &gt; ?&quot;, age).Find(&amp;users)</code></pre>\n\n<ol start=\"3\">\n<li><p>验证用户输入：在将用户输入数据传递给 SQL 查询之前，务必对其进行验证和过滤，以防止恶意 SQL 注入攻击。可以使用合适的验证库或编写自己的验证逻辑来确保用户输入数据的合法性。</p>\n</li>\n<li><p>限制数据库权限：在使用数据库时，确保数据库用户只具有最小必需的权限，例如只允许执行特定的查询和操作，以限制潜在的攻击面。</p>\n</li>\n<li><p>更新 Gorm 版本：定期更新 Gorm 到最新版本，以确保你使用的是最新的安全补丁和修复了可能存在的安全漏洞的版本。</p>\n</li>\n</ol>\n<p>总之，确保 SQL 安全对于使用 Gorm 或任何其他 ORM 库都是至关重要的。遵循最佳实践，使用参数化查询、验证用户输入、限制数据库权限等措施，以保护你的应用程序免受 SQL 注入攻击。</p>\n<h3 id=\"验证用户输入\"><a href=\"#验证用户输入\" class=\"headerlink\" title=\"验证用户输入\"></a>验证用户输入</h3><p>验证用户输入是确保应用程序安全的重要步骤，包括在使用 Gorm 或任何其他 ORM 库时。下面是一些实现验证用户输入的方法：</p>\n<ol>\n<li>使用 Go 的内置验证库：Go 标准库中提供了多个用于验证用户输入的包，例如 <code>regexp</code>、<code>strconv</code>、<code>strings</code> 等。你可以使用这些包来检查用户输入是否符合期望的格式、类型、长度等。例如，你可以使用正则表达式验证电子邮件地址的格式，使用 <code>strconv</code> 包将字符串转换为数字等。</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import (\n    &quot;regexp&quot;\n)\n\nfunc ValidateEmail(email string) bool &#123;\n    &#x2F;&#x2F; 使用正则表达式验证电子邮件地址格式\n    pattern :&#x3D; &#96;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,&#125;$&#96;\n    return regexp.MustCompile(pattern).MatchString(email)\n&#125;\n\nfunc main() &#123;\n    email :&#x3D; &quot;user@example.com&quot;\n    if ValidateEmail(email) &#123;\n        fmt.Println(&quot;Email is valid&quot;)\n    &#125; else &#123;\n        fmt.Println(&quot;Email is invalid&quot;)\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>自定义验证逻辑：根据你的应用程序需求，你可以编写自己的验证逻辑来验证用户输入。例如，你可以检查密码的长度、检查输入是否为合法的日期等。可以通过编写自定义的验证函数或方法来实现。</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func ValidatePassword(password string) bool &#123;\n    &#x2F;&#x2F; 检查密码长度是否大于等于8\n    return len(password) &gt;&#x3D; 8\n&#125;\n\nfunc main() &#123;\n    password :&#x3D; &quot;mypassword&quot;\n    if ValidatePassword(password) &#123;\n        fmt.Println(&quot;Password is valid&quot;)\n    &#125; else &#123;\n        fmt.Println(&quot;Password is invalid&quot;)\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>使用第三方验证库：除了 Go 标准库外，还有许多第三方验证库可供选择，这些库提供了更丰富的验证功能，如 <code>validator</code>、<code>go-playground/validator</code> 等。这些库提供了各种验证规则和自定义验证功能，可以方便地在你的应用程序中使用。</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import (\n    &quot;github.com&#x2F;go-playground&#x2F;validator&#x2F;v10&quot;\n)\n\ntype User struct &#123;\n    Name     string &#96;validate:&quot;required&quot;&#96;\n    Age      int    &#96;validate:&quot;gte&#x3D;18&quot;&#96;\n    Email    string &#96;validate:&quot;email&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    user :&#x3D; User&#123;Name: &quot;John&quot;, Age: 20, Email: &quot;user@example.com&quot;&#125;\n    validate :&#x3D; validator.New()\n    err :&#x3D; validate.Struct(user)\n    if err !&#x3D; nil &#123;\n        fmt.Println(&quot;Validation failed:&quot;, err)\n    &#125; else &#123;\n        fmt.Println(&quot;Validation passed&quot;)\n    &#125;\n&#125;</code></pre>\n\n<p>以上只是验证用户输入的一些简单示例，实际上，验证用户输入可能会涉及更复杂的业务逻辑和多个字段的验证。根据你的应用程序需求，选择合适的验证方法，并根据最佳实践来保护应用程序免受恶意用户输入造成的安全威胁。</p>\n<h3 id=\"gin-防-sql-注入校验\"><a href=\"#gin-防-sql-注入校验\" class=\"headerlink\" title=\"gin 防 sql 注入校验\"></a>gin 防 sql 注入校验</h3><p>在使用 Gin 进行 SQL 注入校验时，可以考虑以下几种方法：</p>\n<ol>\n<li>使用预处理语句：使用预处理语句来执行 SQL 查询和更新操作，而不是直接将用户输入的数据插入 SQL 查询中。预处理语句可以在 SQL 查询执行之前将用户输入的数据作为参数传递给数据库，从而防止 SQL 注入攻击。在使用 Gin 进行数据库操作时，可以使用 <code>?</code> 占位符来代替直接插入用户输入的数据，然后将用户输入的数据作为参数传递给数据库库的方法，数据库库会自动使用预处理语句来执行 SQL 操作。</li>\n</ol>\n<p>例如，在使用 Go 自带的 <code>database/sql</code> 进行数据库操作时，可以使用 <code>?</code> 占位符来代替直接插入用户输入的数据，并将用户输入的数据作为参数传递给 <code>Exec</code> 或 <code>Query</code> 方法，<code>database/sql</code> 会自动使用预处理语句来执行 SQL 操作。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import &quot;database&#x2F;sql&quot;\nimport _ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;\n\nfunc getUserByName(c *gin.Context) &#123;\n    &#x2F;&#x2F; 获取用户输入的用户名\n    username :&#x3D; c.Query(&quot;username&quot;)\n\n    &#x2F;&#x2F; 使用预处理语句，将用户输入作为参数传递\n    stmt, err :&#x3D; db.Prepare(&quot;SELECT * FROM users WHERE username &#x3D; ?&quot;)\n    if err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理错误\n        &#x2F;&#x2F; ...\n    &#125;\n    defer stmt.Close()\n\n    rows, err :&#x3D; stmt.Query(username)\n    if err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理错误\n        &#x2F;&#x2F; ...\n    &#125;\n\n    &#x2F;&#x2F; 处理查询结果\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>使用 ORM 的安全特性：一些数据库 ORM 库（如 Gorm、Xorm 等）提供了安全特性，可以防止 SQL 注入攻击。这些特性通常包括自动转义用户输入的数据，避免将用户输入的数据作为原始 SQL 查询的一部分。在使用 ORM 进行数据库操作时，尽量使用 ORM 提供的安全特性，以确保用户输入的数据不会导致 SQL 注入。</li>\n</ol>\n<p>例如，在使用 Gorm 进行查询时，可以使用 <code>Find</code> 方法，并将用户输入的数据作为参数传递给方法，Gorm 会自动转义用户输入的数据，从而防止 SQL 注入攻击。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\nimport &quot;gorm.io&#x2F;gorm&quot;\n\nfunc getUserByName(c *gin.Context) &#123;\n    &#x2F;&#x2F; 获取用户输入的用户名\n    username :&#x3D; c.Query(&quot;username&quot;)\n\n    &#x2F;&#x2F; 使用 Gorm 进行查询，将用户输入作为参数传递，Gorm 会自动转义用户输入的数据\n    var user User\n    if err :&#x3D; db.Find(&amp;user, &quot;username &#x3D; ?&quot;, username).Error; err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理错误\n        &#x2F;&#x2F; ...\n    &#125;\n\n    &#x2F;&#x2F; 处理查询结果\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>自定义输入验证：根据你的应用程序需求，可以编写自定义的输入验证逻辑，对用户输入的数据进行校验。例如，可以使用正则表达式、字符串处理函数等方法对用户输入的数据进行验证，确保其符合预期的格式，从而防止 SQL 注入攻击。在使用 Gin 进行输入验证时，可以使用 <code>regexp</code> 包来进行正则表达式验证，或者使用字符串处理函数来对用户输入的数据进行格式化、过滤或转义。</li>\n</ol>\n<p>例如，可以编写一个自定义的验证函数 <code>isValidUsername</code> 来验证用户名是否符合预期的格式，例如只包含字母和数字，长度在 6 到 20 个字符之间：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import (\n    &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n    &quot;regexp&quot;\n)\n\nfunc getUserByName(c *gin.Context) &#123;\n    &#x2F;&#x2F; 获取用户输入的用户名\n    username :&#x3D; c.Query(&quot;username&quot;)\n\n    &#x2F;&#x2F; 自定义输入验证逻辑，例如使用正则表达式验证用户名格式\n    if !isValidUsername(username) &#123;\n        &#x2F;&#x2F; 处理用户名格式错误\n        &#x2F;&#x2F; ...\n    &#125;\n\n    &#x2F;&#x2F; 使用 Gorm 进行查询，将用户输入作为参数传递，Gorm 会自动转义用户输入的数据\n    &#x2F;&#x2F; ...\n&#125;\n\nfunc isValidUsername(username string) bool &#123;\n    &#x2F;&#x2F; 定义用户名格式的正则表达式\n    pattern :&#x3D; &quot;^[a-zA-Z0-9]&#123;6,20&#125;$&quot;\n\n    &#x2F;&#x2F; 使用正则表达式验证用户名格式\n    match, _ :&#x3D; regexp.MatchString(pattern, username)\n\n    return match\n&#125;</code></pre>\n\n<p>以上是一些常见的防止 SQL 注入攻击的方法，在实际应用中，可以根据具体的业务场景和安全需求，结合使用这些方法或其他安全措施来确保应用程序的数据安全。同时，还应定期更新依赖库，并保持应用程序的安全最佳实践，以保护应用程序免受 SQL 注入等安全威胁。</p>\n<h3 id=\"gorm-多态【我觉得：就算不晓得所谓的多态，我也不可能设计出后面那种表】\"><a href=\"#gorm-多态【我觉得：就算不晓得所谓的多态，我也不可能设计出后面那种表】\" class=\"headerlink\" title=\"gorm 多态【我觉得：就算不晓得所谓的多态，我也不可能设计出后面那种表】\"></a>gorm 多态【我觉得：就算不晓得所谓的多态，我也不可能设计出后面那种表】</h3><p>在 Gorm 中，多态（Polymorphism）是指在一个数据库表中存储多种类型的数据，并通过一个公共的字段来标识不同的类型。这样可以在一个表中存储多种实体的数据，从而避免了创建多张表的复杂性。</p>\n<p>Gorm 提供了多态关联（Polymorphic Associations）的功能，可以通过使用 <code>gorm:&quot;polymorphic&quot;</code> 标签来定义多态关联。下面是一个示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Comment struct &#123;\n    ID           uint\n    Comment      string\n    CommentableID uint\n    CommentableType string\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>Comment</code> 模型有一个 <code>CommentableID</code> 字段用来存储关联的实体的 ID，以及一个 <code>CommentableType</code> 字段用来存储关联实体的类型。<code>CommentableID</code> 字段存储了实体的 ID，<code>CommentableType</code> 字段存储了实体的类型（例如 “Post” 或 “Video”），用于标识关联的实体类型。</p>\n<p>在定义多态关联时，可以使用 <code>gorm:&quot;polymorphic&quot;</code> 标签来声明 <code>CommentableID</code> 和 <code>CommentableType</code> 字段的多态关联，如下所示：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Comment struct &#123;\n    ID           uint\n    Comment      string\n    CommentableID uint\n    CommentableType string &#96;gorm:&quot;polymorphic:Commentable;&quot;&#96;\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;&quot;&#96;\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;&quot;&#96;\n&#125;</code></pre>\n\n<p>在以上示例中，<code>Comment</code> 模型中的 <code>CommentableType</code> 字段使用了 <code>gorm:&quot;polymorphic:Commentable;&quot;</code> 标签，其中 “Commentable” 是关联的多态类型名，用于在数据库中存储关联实体的类型。</p>\n<p>使用多态关联后，可以通过 Gorm 进行查询和操作，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 查询评论的所有子评论\nvar comments []Comment\ndb.Where(&quot;CommentableID &#x3D; ? AND CommentableType &#x3D; ?&quot;, parentCommentID, &quot;Comment&quot;).Find(&amp;comments)\n\n&#x2F;&#x2F; 查询文章的评论\nvar post Post\ndb.Preload(&quot;Comments&quot;).Find(&amp;post)\n\n&#x2F;&#x2F; 查询视频的评论\nvar video Video\ndb.Preload(&quot;Comments&quot;).Find(&amp;video)</code></pre>\n\n<p>通过使用多态关联，可以轻松地在一个表中存储多种类型的数据，并通过公共的字段进行关联和查询，从而实现多态的功能。</p>\n<h3 id=\"gorm-多态与不使用多态看上去没有什么区别\"><a href=\"#gorm-多态与不使用多态看上去没有什么区别\" class=\"headerlink\" title=\"gorm 多态与不使用多态看上去没有什么区别\"></a>gorm 多态与不使用多态看上去没有什么区别</h3><p>在某些情况下，使用多态和不使用多态的确会看上去没有什么区别，但是多态的优势在于更好的代码可读性和可维护性。</p>\n<p>使用多态关联的一个重要好处是，可以避免重复代码和逻辑，特别是当有多个模型需要关联到同一模型时，可以避免在每个模型中重复定义相同的关联字段和关联方法。另外，使用多态关联还可以使代码更加简洁和易于理解。</p>\n<p>例如，假设有一个 <code>Comment</code> 模型需要关联到 <code>Post</code> 和 <code>Video</code> 两个模型，如果不使用多态关联，需要在 <code>Comment</code> 模型中定义两个不同的外键，如下所示：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Comment struct &#123;\n    ID        uint\n    Comment   string\n    PostID    uint\n    VideoID   uint\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;</code></pre>\n\n<p>这样的代码会让数据模型变得混乱，而且在查询和操作数据时也会变得更加麻烦。</p>\n<p>相反，使用多态关联，可以将外键字段和关联方法定义在 <code>Comment</code> 模型中，从而使代码更加简洁和易于理解，如前面所示的示例。使用多态关联还可以在代码中使用多态的概念，从而使代码更加可读性和可维护性。</p>\n<p>因此，虽然使用多态关联可能看起来并没有显著的区别，但它确实可以提高代码的可读性和可维护性。</p>\n<h3 id=\"polymorphicValue\"><a href=\"#polymorphicValue\" class=\"headerlink\" title=\"polymorphicValue\"></a>polymorphicValue</h3><p><code>polymorphicValue</code> 是 GORM 中用于处理多态关联的字段，它允许在关联关系中使用不同的数据类型，从而实现一对多或多对多关联的灵活性。</p>\n<p><strong>在 GORM 中，<code>polymorphicValue</code> 是一个用于表示多态关联的字段名，它通常与 <code>polymorphicType</code> 字段一起使用，用于指定多态关联的实际类型。 <code>polymorphicValue</code> 字段的值通常是一个字符串，用于表示关联的实际类型的名称或标识。</strong></p>\n<p>以下是一个简单的示例，演示了如何在 GORM 中使用 <code>polymorphicValue</code> 字段来实现多态关联：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Comment struct &#123;\n    ID              uint\n    Body            string\n    CommentableID   uint\n    CommentableType string\n    Commentable     interface&#123;&#125; &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96; &#x2F;&#x2F; 定义多态关联\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96; &#x2F;&#x2F; 定义多态关联\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96; &#x2F;&#x2F; 定义多态关联\n&#125;</code></pre>\n\n<p>在上面的例子中，<code>Comment</code> 模型通过 <code>Commentable</code> 字段与 <code>Post</code> 和 <code>Video</code> 模型建立了多态关联，表示一条评论可以关联到多个不同类型的模型（即 <code>Post</code> 和 <code>Video</code>），同时通过 <code>CommentableType</code> 字段和 <code>polymorphicValue</code> 标签来标识实际关联的类型。</p>\n<p>在数据库中，可以通过添加 <code>CommentableID</code> 和 <code>CommentableType</code> 字段来表示多态关联的关系。同时，GORM 会自动解析 <code>Commentable</code> 字段和 <code>polymorphicValue</code> 标签，从而在查询和操作数据时可以直接通过关联字段进行操作，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 查询帖子及其评论\nvar post Post\ndb.Preload(&quot;Comments&quot;).Find(&amp;post, 1) &#x2F;&#x2F; 查询 ID 为 1 的帖子及其评论\n\n&#x2F;&#x2F; 查询视频及其评论\nvar video Video\ndb.Preload(&quot;Comments&quot;).Find(&amp;video, 1) &#x2F;&#x2F; 查询 ID 为 1 的视频及其评论\n\n&#x2F;&#x2F; 创建评论关联到帖子\npost :&#x3D; Post&#123;Title: &quot;Post 1&quot;&#125;\ncomment :&#x3D; Comment&#123;Body: &quot;Comment 1&quot;, Commentable: &amp;post&#125;\ndb.Create(&amp;post)\ndb.Create(&amp;comment)\n\n&#x2F;&#x2F; 创建评论关联到视频\nvideo :&#x3D; Video&#123;Title: &quot;Video 1&quot;&#125;\ncomment :&#x3D; Comment&#123;Body: &quot;Comment 2&quot;, Commentable: &amp;video&#125;\ndb.Create(&amp;video)\ndb.Create(&amp;comment)</code></pre>\n\n<p>通过以上示例，可以看到如何在 GORM 中使用 <code>polymorphicValue</code> 字段来实现多态关联，从而实现模型之间的灵活关联查询和操作。</p>\n<h3 id=\"得到的表结构\"><a href=\"#得到的表结构\" class=\"headerlink\" title=\"得到的表结构\"></a>得到的表结构</h3><p>上面的示例中，Comment 模型通过 Commentable 字段与 Post 和 Video 模型建立了多态关联，同时通过 CommentableType 字段和 polymorphicValue 标签指定了实际关联类型的名称为 commentable_type。</p>\n<p>在生成的 MySQL 表结构中，会包含 commentable_type 字段来表示实际关联类型，例如：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;comments&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;body&#96; VARCHAR(255) NOT NULL,\n  &#96;commentable_id&#96; INT(10) UNSIGNED NOT NULL,\n  &#96;commentable_type&#96; VARCHAR(255) NOT NULL, -- 多态关联类型字段\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;posts&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;title&#96; VARCHAR(255) NOT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;videos&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;title&#96; VARCHAR(255) NOT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);</code></pre>\n\n<p>从上面的表结构可以看到，comments 表中包含了 commentable_type 字段来表示实际关联类型，这样在查询和操作多态关联数据时，GORM 可以根据该字段来判断实际关联类型，从而实现多态关联的查询和操作。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><p>好的，以下是使用 GORM 插入几条数据的示例，假设我们已经定义了如下的数据模型：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Comment struct &#123;\n    ID              uint\n    Body            string\n    CommentableID   uint\n    CommentableType string &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96;\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96;\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96;\n&#125;</code></pre>\n\n<p>现在我们可以通过创建实例并设置相关字段的值，然后使用 GORM 的 <code>Create</code> 方法插入数据到对应的表中。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 创建 Post\npost :&#x3D; Post&#123;\n    Title: &quot;Post 1&quot;,\n    Comments: []Comment&#123;\n        &#123;Body: &quot;Comment 1 for Post 1&quot;&#125;,\n        &#123;Body: &quot;Comment 2 for Post 1&quot;&#125;,\n    &#125;,\n&#125;\ngormDB.Create(&amp;post)\n\n&#x2F;&#x2F; 创建 Video\nvideo :&#x3D; Video&#123;\n    Title: &quot;Video 1&quot;,\n    Comments: []Comment&#123;\n        &#123;Body: &quot;Comment 1 for Video 1&quot;&#125;,\n        &#123;Body: &quot;Comment 2 for Video 1&quot;&#125;,\n    &#125;,\n&#125;\ngormDB.Create(&amp;video)</code></pre>\n\n<p>上面的示例中，我们分别创建了一个带有多个评论的 <code>Post</code> 和 <code>Video</code> 实例，并使用 <code>Create</code> 方法将它们插入到对应的表中。由于评论模型 <code>Comment</code> 中定义了 <code>CommentableID</code> 和 <code>CommentableType</code> 字段作为多态关联的键值对，GORM 会根据 <code>polymorphicValue</code> 标签自动设置 <code>CommentableType</code> 字段的值为 <code>commentable_type</code>，从而插入多态关联数据到 <code>comments</code> 表中。</p>\n<p>插入数据后，可以通过查询相关的表来验证数据是否插入成功。例如，可以使用以下代码查询 <code>comments</code> 表中的数据：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var comments []Comment\ngormDB.Find(&amp;comments)\nfmt.Println(comments)</code></pre>\n\n<p>如果一切设置正确，你应该能够在输出中看到插入的评论数据，并且 <code>CommentableType</code> 字段的值应该与 <code>polymorphicValue</code> 标签中指定的值相同。</p>\n<h3 id=\"至此数据库数据\"><a href=\"#至此数据库数据\" class=\"headerlink\" title=\"至此数据库数据\"></a>至此数据库数据</h3><p>假设我们使用的是 MySQL 数据库，并且已经成功执行了上面的示例代码插入了一些数据，那么在数据库中存储的数据将类似于以下的结构：</p>\n<p>comments 表：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">+----+------------------------+----------------+---------------------+------------------+\n| ID | Body                   | CommentableID  | CommentableType     | created_at       |\n+----+------------------------+----------------+---------------------+------------------+\n| 1  | Comment 1 for Post 1  | 1              | Post                | 2023-04-26 12:34 |\n| 2  | Comment 2 for Post 1  | 1              | Post                | 2023-04-26 12:34 |\n| 3  | Comment 1 for Video 1 | 1              | Video               | 2023-04-26 12:34 |\n| 4  | Comment 2 for Video 1 | 1              | Video               | 2023-04-26 12:34 |\n+----+------------------------+----------------+---------------------+------------------+</code></pre>\n\n<p><strong>非 GPT 生成：</strong>怎么看上去，像是一对多了呢</p>\n<p>posts 表：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">+----+--------+------------------+\n| ID | Title  | created_at       |\n+----+--------+------------------+\n| 1  | Post 1 | 2023-04-26 12:34 |\n+----+--------+------------------+</code></pre>\n\n<p>videos 表：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">+----+--------+------------------+\n| ID | Title  | created_at       |\n+----+--------+------------------+\n| 1  | Video 1| 2023-04-26 12:34 |\n+----+--------+------------------+</code></pre>\n\n<p>从上面的数据表结构可以看出，comments 表中的 <code>CommentableID</code> 字段表示关联的评论所属的记录的 ID，<code>CommentableType</code> 字段表示关联的评论所属的记录类型，即 <code>Post</code> 或者 <code>Video</code>。这种方式实现了多态关联，允许一个表中的记录关联到多个不同表中的记录。</p>\n<h3 id=\"CommentableType-是从哪里获取到的\"><a href=\"#CommentableType-是从哪里获取到的\" class=\"headerlink\" title=\"CommentableType 是从哪里获取到的\"></a>CommentableType 是从哪里获取到的</h3><p>在使用 GORM 中的多态关联时，<code>CommentableType</code> 字段的值是由 GORM 根据模型关联的结构自动设置的。在示例中，<code>CommentableType</code> 是由 <code>Comment</code> 模型中定义的多态字段 <code>PolymorphicType</code> 决定的，其值是关联到的模型的名称。</p>\n<p>在示例中，<code>Comment</code> 模型中定义了 <code>PolymorphicType</code> 字段，其值为 <code>gorm:&quot;polymorphic:Commentable;&quot;</code>。这里的 <code>Commentable</code> 是一个字符串，表示多态关联的关联名，即关联到的模型的名称。当创建一个关联到 <code>Comment</code> 模型的记录时，GORM 会自动将 <code>CommentableType</code> 字段设置为 <code>Post</code> 或者 <code>Video</code>，具体取决于关联的模型是 <code>Post</code> 还是 <code>Video</code>。这样在数据库中就可以记录下每条评论关联到的记录类型，从而实现多态关联。</p>\n<h3 id=\"gorm-has-many-自引用\"><a href=\"#gorm-has-many-自引用\" class=\"headerlink\" title=\"gorm has many 自引用\"></a>gorm has many 自引用</h3><p>在 GORM 中，可以通过使用 <code>ForeignKey</code> 和 <code>AssociationForeignKey</code> 标签来实现模型的自引用关系，从而建立一个模型与自身的 “Has Many” 关联。</p>\n<p>下面是一个简单的示例，演示了如何在 GORM 中定义一个自引用的模型关联：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID        uint\n    Name      string\n    ParentID  uint\n    Children  []User &#96;gorm:&quot;foreignkey:ParentID&quot;&#96; &#x2F;&#x2F; 定义子用户的关联\n    Parent    *User  &#96;gorm:&quot;foreignkey:ID&quot;&#96;       &#x2F;&#x2F; 定义父用户的关联\n&#125;</code></pre>\n\n<p>在上面的例子中，<code>User</code> 模型通过 <code>ParentID</code> 字段与自身建立了 “Has Many” 关联，表示一个用户可以有多个子用户，同时通过 <code>Parent</code> 字段与自身建立了 “Belongs To” 关联，表示一个用户只能有一个父用户。</p>\n<p>在数据库中，可以通过添加 <code>ParentID</code> 字段来表示用户之间的关系。同时，GORM 会自动解析模型中定义的关联字段，从而在查询和操作数据时可以直接通过关联字段进行操作，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 查询用户及其子用户\nvar user User\ndb.Preload(&quot;Children&quot;).Find(&amp;user, 1) &#x2F;&#x2F; 查询 ID 为 1 的用户及其子用户\n\n&#x2F;&#x2F; 创建父用户及其子用户\nparent :&#x3D; User&#123;Name: &quot;Parent&quot;&#125;\nchild1 :&#x3D; User&#123;Name: &quot;Child 1&quot;, Parent: &amp;parent&#125;\nchild2 :&#x3D; User&#123;Name: &quot;Child 2&quot;, Parent: &amp;parent&#125;\ndb.Create(&amp;parent)\ndb.Create(&amp;child1)\ndb.Create(&amp;child2)\n\n&#x2F;&#x2F; 查询子用户的父用户\nvar child User\ndb.Preload(&quot;Parent&quot;).Find(&amp;child, 1) &#x2F;&#x2F; 查询 ID 为 1 的子用户及其父用户</code></pre>\n\n<p>通过以上示例，可以看到如何在 GORM 中使用 <code>Has Many</code> 和 <code>Belongs To</code> 关联来实现模型的自引用关系，从而实现模型之间的关联查询和操作。</p>\n<h3 id=\"以上示例查询结果\"><a href=\"#以上示例查询结果\" class=\"headerlink\" title=\"以上示例查询结果\"></a>以上示例查询结果</h3><p>以上示例中的查询结果可能会根据具体的数据库记录和数据模型定义而有所不同。以下是可能的查询结果的示例：</p>\n<ol>\n<li>查询用户及其子用户：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Preload(&quot;Children&quot;).Find(&amp;user, 1)</code></pre>\n\n<p>查询 ID 为 1 的用户及其子用户，结果可能如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">user :&#x3D; User&#123;\n    ID:        1,\n    Name:      &quot;Parent&quot;,\n    ParentID:  0, &#x2F;&#x2F; 或者 null，表示该用户为顶级用户，没有父用户\n    Children: []User&#123;\n        &#123;ID: 2, Name: &quot;Child 1&quot;, ParentID: 1&#125;,\n        &#123;ID: 3, Name: &quot;Child 2&quot;, ParentID: 1&#125;,\n    &#125;,\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>查询子用户的父用户：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var child User\ndb.Preload(&quot;Parent&quot;).Find(&amp;child, 1)</code></pre>\n\n<p>查询 ID 为 1 的子用户及其父用户，结果可能如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">child :&#x3D; User&#123;\n    ID:        1,\n    Name:      &quot;Child 1&quot;,\n    ParentID:  1,\n    Parent: &amp;User&#123;\n        ID:       1,\n        Name:     &quot;Parent&quot;,\n        ParentID: 0,\n    &#125;,\n&#125;</code></pre>\n\n<p>注意：以上示例中的查询结果仅为示意，并可能因实际数据和数据模型的定义而有所不同。实际的查询结果会根据数据库中的数据以及数据模型的字段定义和标签设置而定。</p>\n<h3 id=\"gorm-Preload-API-的作用\"><a href=\"#gorm-Preload-API-的作用\" class=\"headerlink\" title=\"gorm .Preload() API 的作用\"></a>gorm .Preload() API 的作用</h3><p><code>Preload()</code> 是 GORM 中用于预加载关联数据的 API，其作用是在查询某个模型数据时，同时预加载其关联模型的数据，以避免在渲染视图时因为 N+1 问题导致的性能问题。在使用 <code>Preload()</code> API 时，GORM 会发出一条 JOIN 查询语句来加载关联数据，而不是使用多条查询语句逐个加载关联数据。</p>\n<p>例如，假设我们有以下的模型定义：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n  gorm.Model\n  Name      string\n  Age       int\n  Addresses []Address\n&#125;\n\ntype Address struct &#123;\n  gorm.Model\n  UserID    uint\n  City      string\n  Country   string\n&#125;</code></pre>\n\n<p>其中，<code>User</code> 模型拥有多个 <code>Address</code> 模型的关联，即一个用户可以有多个地址。如果我们在查询用户数据时需要同时查询用户的地址数据，可以使用 <code>Preload()</code> API 来实现：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var user User\ndb.Preload(&quot;Addresses&quot;).First(&amp;user, 1)</code></pre>\n\n<p>这里的 <code>Preload(&quot;Addresses&quot;)</code> 表示预加载 <code>User</code> 模型的 <code>Addresses</code> 关联模型数据。在执行查询时，GORM 会发出一条 JOIN 查询语句来同时查询用户和其地址数据，从而避免了 N+1 查询问题。</p>\n<p>需要注意的是，使用 <code>Preload()</code> API 时应避免过度预加载，以免查询语句过于复杂导致性能下降。可以通过设置参数来控制预加载的深度和范围，以满足具体的查询需求。</p>\n<h3 id=\"N-1-问题-是什么意思\"><a href=\"#N-1-问题-是什么意思\" class=\"headerlink\" title=\"N+1 问题 是什么意思\"></a>N+1 问题 是什么意思</h3><p>N+1 问题（N+1 Query Problem）是指在加载关联数据时，使用了 N 条查询语句来查询 N 条主记录以及它们的关联数据，从而导致性能问题的一种情况。通常情况下，N+1 问题是由 ORM 框架的延迟加载机制所导致的。</p>\n<p>举个例子，假设我们有一个 <code>User</code> 模型和一个 <code>Post</code> 模型，它们之间是一对多的关联关系（即一个用户可以有多篇文章）。如果我们要查询所有用户以及他们的所有文章，可能会写出如下的查询代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var users []User\ndb.Find(&amp;users)\n\nfor _, user :&#x3D; range users &#123;\n  var posts []Post\n  db.Where(&quot;user_id &#x3D; ?&quot;, user.ID).Find(&amp;posts)\n  user.Posts &#x3D; posts\n&#125;</code></pre>\n\n<p>这里的第一条查询语句会加载所有用户的数据，而在第二个循环中，我们对每个用户分别执行一次查询来加载他们的文章数据。这样就会导致 N+1 问题，即执行了 N+1 条查询语句。如果用户数据量很大，那么就会导致性能问题，因为查询语句的执行需要时间和资源。</p>\n<p>为了避免 N+1 问题，可以使用 GORM 中的 <code>Preload()</code> API 来预加载关联数据，或者手动使用 JOIN 查询语句来同时加载主记录和关联记录。这样可以将多条查询语句合并为一条查询，从而提高查询性能。</p>\n<h3 id=\"many2many\"><a href=\"#many2many\" class=\"headerlink\" title=\"many2many\"></a>many2many</h3><p>在 GORM 中，Many-to-Many 关系可以使用 <code>Many2Many</code> 方法来定义。它允许您定义两个表之间的多对多关系，并使用中间表进行关联。</p>\n<p>以下是一个示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID       uint\n    Name     string\n    Languages []Language &#96;gorm:&quot;many2many:user_languages;&quot;&#96;\n&#125;\n\ntype Language struct &#123;\n    ID   uint\n    Name string\n    Users []User &#96;gorm:&quot;many2many:user_languages;&quot;&#96;\n&#125;</code></pre>\n\n<p>在上面的代码中，<code>User</code> 和 <code>Language</code> 之间的多对多关系使用 <code>many2many</code> 方法定义。<code>user_languages</code> 是中间表的表名，它将这两个模型关联起来。</p>\n<p>在此示例中，每个用户可以拥有多种语言，而每种语言也可以被多个用户使用。中间表 <code>user_languages</code> 将两个模型之间的关系保存在一起。</p>\n<p>要使用此关系，您可以使用以下代码将语言添加到用户的语言列表中：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">user :&#x3D; User&#123;&#125;\nlanguage :&#x3D; Language&#123;&#125;\n\n&#x2F;&#x2F; 通过ID获取用户和语言\ndb.First(&amp;user, 1)\ndb.First(&amp;language, 2)\n\n&#x2F;&#x2F; 添加语言到用户的语言列表\ndb.Model(&amp;user).Association(&quot;Languages&quot;).Append(&amp;language)</code></pre>\n\n<p>在上面的示例中，我们从数据库中获取了一个用户和一种语言，然后将语言添加到用户的语言列表中。</p>\n<p>您还可以从用户的语言列表中获取所有语言：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Model(&amp;user).Association(&quot;Languages&quot;).Find(&amp;languages)</code></pre>\n\n<p>上面的代码将获取用户的所有语言，并将它们存储在 <code>languages</code> 列表中。</p>\n<h3 id=\"解释下-如下代码\"><a href=\"#解释下-如下代码\" class=\"headerlink\" title=\"解释下 如下代码\"></a>解释下 如下代码</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    gorm.Model\n    Profiles []Profile &#96;gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;&#96;\n    Refer    uint      &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\ntype Profile struct &#123;\n    gorm.Model\n    Name      string\n    UserRefer uint &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n</code></pre>\n\n<p>以上代码定义了两个 GORM 模型 <code>User</code> 和 <code>Profile</code>。<code>User</code> 模型具有多对多关系，并且使用名为 <code>user_profiles</code> 的中间表来定义它们之间的关系。中间表具有自定义外键列 <code>Refer</code> 和 <code>UserReferID</code>，分别用于关联 <code>User</code> 和 <code>Profile</code> 模型。<code>Profile</code> 模型具有 <code>UserRefer</code> 字段，用于关联 <code>User</code> 模型。</p>\n<p>具体来说，以下是关键代码行的解释：</p>\n<ul>\n<li><code>gorm.Model</code> 是 GORM 提供的一个带有 <code>ID</code>、<code>CreatedAt</code> 和 <code>UpdatedAt</code> 字段的基本模型，可以被嵌入到自定义模型中以获得这些通用字段。</li>\n<li><code>Profiles []Profile</code> 定义了 <code>User</code> 模型中的一个 <code>Profile</code> 切片，表示每个用户都可以拥有多个个人资料。</li>\n<li><code>gorm:&quot;many2many:user_profiles&quot;</code> 告诉 GORM 将 <code>User</code> 和 <code>Profile</code> 模型之间的关系保存在名为 <code>user_profiles</code> 的中间表中。</li>\n<li><code>foreignKey:Refer</code> 和 <code>joinForeignKey:UserReferID</code> 分别指定了用于关联 <code>User</code> 模型的外键列和用于关联中间表的外键列。</li>\n<li><code>References:UserRefer</code> 和 <code>joinReferences:ProfileRefer</code> 分别指定了用于关联 <code>User</code> 模型的外键列和用于关联 <code>Profile</code> 模型的外键列。</li>\n<li><code>Refer uint</code> 声明了一个自定义的外键列 <code>Refer</code>，它用于将 <code>User</code> 模型与中间表关联起来。</li>\n<li><code>gorm:&quot;index:,unique&quot;</code> 将 <code>Refer</code> 列标记为唯一索引，以确保每个 <code>User</code> 对应一个唯一的外键值。</li>\n<li><code>UserRefer uint</code> 是 <code>Profile</code> 模型中的一个字段，表示每个个人资料都与一个用户关联。</li>\n<li><code>gorm:&quot;index:,unique&quot;</code> 将 <code>UserRefer</code> 列标记为唯一索引，以确保每个 <code>Profile</code> 对应一个唯一的外键值。</li>\n</ul>\n<p>总体来说，以上代码展示了如何在 GORM 中定义多对多关系，并使用自定义中间表和外键列来保存关系。</p>\n<h3 id=\"上述代码执行后的建表语句是什么\"><a href=\"#上述代码执行后的建表语句是什么\" class=\"headerlink\" title=\"上述代码执行后的建表语句是什么\"></a>上述代码执行后的建表语句是什么</h3><p>执行以上代码后，GORM 会自动创建三张数据库表：</p>\n<ol>\n<li><code>users</code> 表：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;users&#96; (\n  &#96;id&#96; bigint unsigned NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime(6) NOT NULL,\n  &#96;updated_at&#96; datetime(6) NOT NULL,\n  &#96;deleted_at&#96; datetime(6) DEFAULT NULL,\n  &#96;refer&#96; bigint unsigned NOT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;idx_users_refer&#96; (&#96;refer&#96;),\n  KEY &#96;users_deleted_at&#96; (&#96;deleted_at&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;</code></pre>\n\n<p><code>users</code> 表包含一个自增主键 <code>id</code>、<code>created_at</code> 和 <code>updated_at</code> 字段，以及一个名为 <code>refer</code> 的自定义外键列。<code>refer</code> 列被标记为唯一索引，以确保每个用户对应一个唯一的外键值。</p>\n<ol start=\"2\">\n<li><code>profiles</code> 表：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;profiles&#96; (\n  &#96;id&#96; bigint unsigned NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime(6) NOT NULL,\n  &#96;updated_at&#96; datetime(6) NOT NULL,\n  &#96;deleted_at&#96; datetime(6) DEFAULT NULL,\n  &#96;name&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,\n  &#96;user_refer&#96; bigint unsigned NOT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;idx_profiles_user_refer&#96; (&#96;user_refer&#96;),\n  KEY &#96;profiles_deleted_at&#96; (&#96;deleted_at&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;</code></pre>\n\n<p><code>profiles</code> 表包含一个自增主键 <code>id</code>、<code>created_at</code> 和 <code>updated_at</code> 字段，以及一个名为 <code>user_refer</code> 的自定义外键列。<code>user_refer</code> 列被标记为唯一索引，以确保每个个人资料对应一个唯一的外键值。</p>\n<ol start=\"3\">\n<li><code>user_profiles</code> 表：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;user_profiles&#96; (\n  &#96;user_refer_id&#96; bigint unsigned NOT NULL,\n  &#96;profile_refer_id&#96; bigint unsigned NOT NULL,\n  PRIMARY KEY (&#96;user_refer_id&#96;,&#96;profile_refer_id&#96;),\n  KEY &#96;idx_user_profiles_profile_refer_id&#96; (&#96;profile_refer_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;</code></pre>\n\n<p><code>user_profiles</code> 表包含两个名为 <code>user_refer_id</code> 和 <code>profile_refer_id</code> 的外键列，用于关联 <code>users</code> 表和 <code>profiles</code> 表。这两个外键列被用作联合主键，以确保每个关系都是唯一的。</p>\n<h3 id=\"上述代码的增删改查完整代码是什么样\"><a href=\"#上述代码的增删改查完整代码是什么样\" class=\"headerlink\" title=\"上述代码的增删改查完整代码是什么样\"></a>上述代码的增删改查完整代码是什么样</h3><p>以下是对于上述代码的增删改查的完整 GORM 代码示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tgorm.Model\n\tProfiles []Profile &#96;gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;&#96;\n\tRefer    uint      &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\ntype Profile struct &#123;\n\tgorm.Model\n\tName      string\n\tUserRefer uint &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\tdsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;database?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\terr &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 创建用户和个人资料\n\tuser :&#x3D; User&#123;\n\t\tRefer: 1,\n\t\tProfiles: []Profile&#123;\n\t\t\t&#123;\n\t\t\t\tName: &quot;Alice&quot;,\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\tName: &quot;Bob&quot;,\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;\n\terr &#x3D; db.Create(&amp;user).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 查询用户和个人资料\n\tvar result User\n\terr &#x3D; db.Where(&quot;refer &#x3D; ?&quot;, 1).Preload(&quot;Profiles&quot;).First(&amp;result).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Printf(&quot;User: %v, Profiles: %v\\n&quot;, result, result.Profiles)\n\n\t&#x2F;&#x2F; 更新用户和个人资料\n\terr &#x3D; db.Model(&amp;result).Updates(User&#123;\n\t\tRefer: 2,\n\t\tProfiles: []Profile&#123;\n\t\t\t&#123;\n\t\t\t\tName: &quot;Charlie&quot;,\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\tName: &quot;Dave&quot;,\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 查询用户和个人资料\n\terr &#x3D; db.Where(&quot;refer &#x3D; ?&quot;, 2).Preload(&quot;Profiles&quot;).First(&amp;result).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Printf(&quot;User: %v, Profiles: %v\\n&quot;, result, result.Profiles)\n\n\t&#x2F;&#x2F; 删除用户和个人资料\n\terr &#x3D; db.Delete(&amp;result).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n&#125;</code></pre>\n\n<p>该示例中的 <code>dsn</code> 变量包含数据库连接的详细信息，如数据库地址、用户名、密码和数据库名称等。</p>\n<p>示例中使用 <code>db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;)</code> 自动创建表结构。</p>\n<p>使用 <code>db.Create(&amp;user)</code> 创建用户和个人资料，使用 <code>db.Where().Preload().First()</code> 查询用户和个人资料，使用 <code>db.Model().Updates()</code> 更新用户和个人资料，使用 <code>db.Delete()</code> 删除用户和个人资料。在查询用户时，使用 <code>Preload()</code> 函数来关联查询用户的个人资料。</p>\n<h3 id=\"joinForeignKey-和-joinReferences-各是什么作用\"><a href=\"#joinForeignKey-和-joinReferences-各是什么作用\" class=\"headerlink\" title=\"joinForeignKey 和 joinReferences 各是什么作用\"></a>joinForeignKey 和 joinReferences 各是什么作用</h3><p><code>joinForeignKey</code> 和 <code>joinReferences</code> 是 GORM many-to-many 关系中的两个关键属性，用于指定多对多关联表的外键关联方式。</p>\n<ul>\n<li><p><code>joinForeignKey</code>: 它指定用于关联多对多关系的关联表中的外键名称。在上述示例中，<code>joinForeignKey</code> 的值为 <code>UserReferID</code>，这意味着 <code>user_profiles</code> 表将包含一个名为 <code>user_refer_id</code> 的外键，该外键将引用 <code>users</code> 表中的 <code>id</code> 列。</p>\n</li>\n<li><p><code>joinReferences</code>: 它指定用于关联多对多关系的关联表中引用的外部表和列的名称。在上述示例中，<code>joinReferences</code> 的值为 <code>ProfileRefer</code>，这意味着 <code>user_profiles</code> 表将引用 <code>profiles</code> 表中的 <code>user_refer</code> 列。</p>\n</li>\n</ul>\n<p>这两个属性一起使用，可以定义多对多关联表的外键关联方式，以及外键关联的表和列。</p>\n<p>哈哈，就是相当于 rename 啊</p>\n<h3 id=\"foreignKey-和-References-的区别\"><a href=\"#foreignKey-和-References-的区别\" class=\"headerlink\" title=\"foreignKey 和 References 的区别\"></a>foreignKey 和 References 的区别</h3><p><code>foreignKey</code> 和 <code>References</code> 是 GORM 模型中的两个属性，用于指定关联关系中外键和引用的列名。它们的区别如下：</p>\n<ul>\n<li><p><code>foreignKey</code>: 它用于指定包含外键的模型中的列名。在 many-to-many 关系中，它指定关联模型中的外键列。在 one-to-many 和 many-to-one 关系中，它指定包含外键的模型中的列名。例如，<code>foreignKey: UserReferID</code> 指定 User 模型中的 <code>UserReferID</code> 列是一个外键。</p>\n</li>\n<li><p><code>References</code>: 它用于指定引用的模型中的列名。在 many-to-many 关系中，它指定关联的模型中的列名。在 one-to-many 和 many-to-one 关系中，它指定关联的模型中的主键列名。例如，<code>References: ProfileRefer</code> 指定 Profile 模型中的 <code>ProfileRefer</code> 列是被引用的列。</p>\n</li>\n</ul>\n<p>因此，<code>foreignKey</code> 和 <code>References</code> 分别用于指定关联关系中的外键和引用的列名。</p>\n<p><strong>在 many-to-many 关系中，</strong></p>\n<ul>\n<li><code>foreignKey</code> 用于指定关联模型中的外键列名，</li>\n<li><code>References</code> 用于指定被关联的模型中的列名。</li>\n</ul>\n<p><strong>在 one-to-many 和 many-to-one 关系中，</strong></p>\n<ul>\n<li><code>foreignKey</code> 用于指定包含外键的模型中的列名，</li>\n<li><code>References</code> 用于指定被关联的模型中的主键列名。</li>\n</ul>\n<p><strong>理解</strong></p>\n<p>gorm foreignKey，可以理解成标记，References 理解成这个标记从哪来，这么理解没错吧</p>\n<p>foreignKey，可以理解成标记，References 理解成这个标记从哪来</p>\n<p>可以这么理解，<code>foreignKey</code> 和 <code>References</code> 分别用于指定关联关系中的外键和引用的列名。</p>\n<ul>\n<li><p><code>foreignKey</code> 可以理解为一个标记，用于标记包含外键的模型中的列名。</p>\n</li>\n<li><p><code>References</code> 可以理解为标记的来源，用于指定被关联的模型中的列名或主键列名，以便 GORM 知道应该关联哪些表和列。</p>\n</li>\n</ul>\n<p>在 many-to-many 关系中，<code>foreignKey</code> 用于标记关联模型中的外键列名，<code>References</code> 用于指定被关联的模型中的列名。</p>\n<p>在 one-to-many 和 many-to-one 关系中，<code>foreignKey</code> 用于标记包含外键的模型中的列名，<code>References</code> 用于指定被关联的模型中的主键列名。</p>\n<h3 id=\"gorm-设计一个用户可以有多个角色，每个角色可以有多个权限\"><a href=\"#gorm-设计一个用户可以有多个角色，每个角色可以有多个权限\" class=\"headerlink\" title=\"gorm 设计一个用户可以有多个角色，每个角色可以有多个权限\"></a>gorm 设计一个用户可以有多个角色，每个角色可以有多个权限</h3><p>下面是一个示例 GORM 模型，用于描述用户、角色和权限之间的多对多关系：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    gorm.Model\n    Roles []Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name       string\n    Permissions []Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;</code></pre>\n\n<p>在上面的示例中，<code>User</code> 模型和 <code>Role</code> 模型之间是多对多关系，<code>Role</code> 模型和 <code>Permission</code> 模型之间也是多对多关系。在 <code>User</code> 模型中，<code>Roles</code> 属性定义为一个 <code>[]Role</code> 切片，用于存储用户所拥有的角色。在 <code>Role</code> 模型中，<code>Permissions</code> 属性定义为一个 <code>[]Permission</code> 切片，用于存储角色所拥有的权限。</p>\n<p>在模型定义中，<code>many2many</code> 标签用于定义多对多关系的关联表名。例如，在 <code>User</code> 模型中，<code>gorm:&quot;many2many:user_roles&quot;</code> 定义了一个名为 <code>user_roles</code> 的关联表，用于关联 <code>User</code> 模型和 <code>Role</code> 模型。在 <code>Role</code> 模型中，<code>gorm:&quot;many2many:role_permissions&quot;</code> 定义了一个名为 <code>role_permissions</code> 的关联表，用于关联 <code>Role</code> 模型和 <code>Permission</code> 模型。</p>\n<p>通过上述示例，可以实现用户和角色之间的多对多关系，以及角色和权限之间的多对多关系。在应用程序中，可以使用 GORM 提供的 API 对这些模型进行增删改查操作。例如，可以使用以下代码将一个角色添加到一个用户中：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">user :&#x3D; &amp;User&#123;ID: 1&#125;\nrole :&#x3D; &amp;Role&#123;ID: 2&#125;\ndb.Model(user).Association(&quot;Roles&quot;).Append(role)</code></pre>\n\n<p>类似地，可以使用 GORM 提供的 API 执行其他类型的操作，例如查询用户拥有的所有角色、查询拥有特定权限的所有角色等等。</p>\n<h3 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h3><p>根据上面给出的模型定义，GORM 可以自动创建相应的数据库表结构。下面是这些模型对应的数据库表结构示例：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;users&#96; (\n  &#96;id&#96; int NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  &#96;deleted_at&#96; datetime DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;roles&#96; (\n  &#96;id&#96; int NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  &#96;deleted_at&#96; datetime DEFAULT NULL,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;permissions&#96; (\n  &#96;id&#96; int NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  &#96;deleted_at&#96; datetime DEFAULT NULL,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;user_roles&#96; (\n  &#96;user_id&#96; int NOT NULL,\n  &#96;role_id&#96; int NOT NULL,\n  PRIMARY KEY (&#96;user_id&#96;,&#96;role_id&#96;),\n  KEY &#96;user_roles_role_id_foreign&#96; (&#96;role_id&#96;),\n  CONSTRAINT &#96;user_roles_user_id_foreign&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;users&#96; (&#96;id&#96;) ON DELETE CASCADE,\n  CONSTRAINT &#96;user_roles_role_id_foreign&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;roles&#96; (&#96;id&#96;) ON DELETE CASCADE\n);\n\nCREATE TABLE &#96;role_permissions&#96; (\n  &#96;role_id&#96; int NOT NULL,\n  &#96;permission_id&#96; int NOT NULL,\n  PRIMARY KEY (&#96;role_id&#96;,&#96;permission_id&#96;),\n  KEY &#96;role_permissions_permission_id_foreign&#96; (&#96;permission_id&#96;),\n  CONSTRAINT &#96;role_permissions_role_id_foreign&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;roles&#96; (&#96;id&#96;) ON DELETE CASCADE,\n  CONSTRAINT &#96;role_permissions_permission_id_foreign&#96; FOREIGN KEY (&#96;permission_id&#96;) REFERENCES &#96;permissions&#96; (&#96;id&#96;) ON DELETE CASCADE\n);</code></pre>\n\n<p>可以看到，GORM 自动生成了五个表结构，分别对应 <code>User</code>、<code>Role</code>、<code>Permission</code>、<code>user_roles</code> 和 <code>role_permissions</code> 这五个模型。其中，<code>users</code>、<code>roles</code> 和 <code>permissions</code> 分别对应 <code>User</code>、<code>Role</code> 和 <code>Permission</code> 这三个模型的基本信息。<code>user_roles</code> 表用于关联 <code>User</code> 和 <code>Role</code> 之间的多对多关系，<code>role_permissions</code> 表用于关联 <code>Role</code> 和 <code>Permission</code> 之间的多对多关系。</p>\n<h3 id=\"含增删改查的完整代码\"><a href=\"#含增删改查的完整代码\" class=\"headerlink\" title=\"含增删改查的完整代码\"></a>含增删改查的完整代码</h3><p>以下是完整的代码示例，包含增删改查操作：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;gorm.io&#x2F;gorm&#x2F;clause&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    err &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to migrate database&quot;)\n    &#125;\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;Name: &quot;管理员&quot;&#125;\n    role2 :&#x3D; &amp;Role&#123;Name: &quot;普通用户&quot;&#125;\n    perm1 :&#x3D; &amp;Permission&#123;Name: &quot;创建用户&quot;&#125;\n    perm2 :&#x3D; &amp;Permission&#123;Name: &quot;删除用户&quot;&#125;\n\n    db.Create(role1)\n    db.Create(role2)\n    db.Create(perm1)\n    db.Create(perm2)\n\n    &#x2F;&#x2F; 创建用户并分配角色和权限\n    user1 :&#x3D; &amp;User&#123;Name: &quot;张三&quot;&#125;\n    user2 :&#x3D; &amp;User&#123;Name: &quot;李四&quot;&#125;\n\n    user1.Roles &#x3D; append(user1.Roles, role1)\n    user1.Roles[0].Permissions &#x3D; append(user1.Roles[0].Permissions, perm1)\n    user1.Roles[0].Permissions &#x3D; append(user1.Roles[0].Permissions, perm2)\n\n    user2.Roles &#x3D; append(user2.Roles, role2)\n    user2.Roles[0].Permissions &#x3D; append(user2.Roles[0].Permissions, perm1)\n\n    db.Create(user1)\n    db.Create(user2)\n\n    &#x2F;&#x2F; 查询用户和角色信息\n    var users []*User\n    db.Preload(clause.Associations).Find(&amp;users)\n    for _, user :&#x3D; range users &#123;\n        fmt.Printf(&quot;用户 %s 的角色信息：\\n&quot;, user.Name)\n        for _, role :&#x3D; range user.Roles &#123;\n            fmt.Printf(&quot;角色 %s 的权限信息：\\n&quot;, role.Name)\n            for _, perm :&#x3D; range role.Permissions &#123;\n                fmt.Printf(&quot;- %s\\n&quot;, perm.Name)\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 更新用户角色信息\n    db.Model(user1).Association(&quot;Roles&quot;).Replace([]*Role&#123;role2&#125;)\n    db.Model(user2).Association(&quot;Roles&quot;).Clear()\n\n    &#x2F;&#x2F; 删除用户和角色信息\n    db.Delete(user1)\n    db.Delete(user2)\n    db.Delete(role1)\n    db.Delete(role2)\n    db.Delete(perm1)\n    db.Delete(perm2)\n&#125;</code></pre>\n\n<p>在这个代码示例中，我们首先定义了 <code>User</code>、<code>Role</code> 和 <code>Permission</code> 三个模型，用于表示用户、角色和权限之间的关系。其中，<code>User</code> 模型中有一个 <code>Roles</code> 字段，表示一个用户可以拥有多个角色；<code>Role</code> 模型中有一个 <code>Permissions</code> 字段，表示一个角色可以拥有多</p>\n<h3 id=\"简化后的代码\"><a href=\"#简化后的代码\" class=\"headerlink\" title=\"简化后的代码\"></a>简化后的代码</h3><p>可以，以下是一个简化版的代码示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;)\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;Name: &quot;管理员&quot;&#125;\n    role2 :&#x3D; &amp;Role&#123;Name: &quot;普通用户&quot;&#125;\n    perm1 :&#x3D; &amp;Permission&#123;Name: &quot;创建用户&quot;&#125;\n    perm2 :&#x3D; &amp;Permission&#123;Name: &quot;删除用户&quot;&#125;\n\n    db.Create(role1, role2)\n    db.Create(perm1, perm2)\n\n    &#x2F;&#x2F; 创建用户并分配角色和权限\n    user1 :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Roles: []*Role&#123;role1&#125;,&#125;\n    user1.Roles[0].Permissions &#x3D; []*Permission&#123;perm1, perm2&#125;\n    user2 :&#x3D; &amp;User&#123;Name: &quot;李四&quot;, Roles: []*Role&#123;role2&#125;,&#125;\n    user2.Roles[0].Permissions &#x3D; []*Permission&#123;perm1&#125;\n\n    db.Create(user1, user2)\n\n    &#x2F;&#x2F; 查询用户和角色信息\n    var users []*User\n    db.Preload(&quot;Roles.Permissions&quot;).Find(&amp;users)\n    for _, user :&#x3D; range users &#123;\n        fmt.Printf(&quot;用户 %s 的角色信息：\\n&quot;, user.Name)\n        for _, role :&#x3D; range user.Roles &#123;\n            fmt.Printf(&quot;角色 %s 的权限信息：\\n&quot;, role.Name)\n            for _, perm :&#x3D; range role.Permissions &#123;\n                fmt.Printf(&quot;- %s\\n&quot;, perm.Name)\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 更新用户角色信息\n    db.Model(user1).Association(&quot;Roles&quot;).Replace([]*Role&#123;role2&#125;)\n    db.Model(user2).Association(&quot;Roles&quot;).Clear()\n\n    &#x2F;&#x2F; 删除用户和角色信息\n    db.Delete(user1, user2)\n    db.Delete(role1, role2)\n    db.Delete(perm1, perm2)\n&#125;</code></pre>\n\n<p>这个代码示例去掉了一些冗余的代码，并且使用了链式调用的方式进行创建、查询、更新和删除操作。同时，由于 GORM 的 Preload 方法支持链式调用，因此我们可以在查询用户信息时，一次性把用户、角色和权限的信息全部查询出来，代码更加简洁。</p>\n<h3 id=\"进一步简化后的代码\"><a href=\"#进一步简化后的代码\" class=\"headerlink\" title=\"进一步简化后的代码\"></a>进一步简化后的代码</h3><p>可以使用简化的代码实现相同的功能：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name  string\n    Roles []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;)\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;Name: &quot;管理员&quot;, Permissions: []*Permission&#123;&#123;Name: &quot;创建用户&quot;&#125;, &#123;Name: &quot;删除用户&quot;&#125;&#125;&#125;\n    role2 :&#x3D; &amp;Role&#123;Name: &quot;普通用户&quot;, Permissions: []*Permission&#123;&#123;Name: &quot;创建用户&quot;&#125;&#125;&#125;\n\n    db.Create(role1, role2)\n\n    &#x2F;&#x2F; 创建用户并分配角色和权限\n    user1 :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Roles: []*Role&#123;role1&#125;&#125;\n    user2 :&#x3D; &amp;User&#123;Name: &quot;李四&quot;, Roles: []*Role&#123;role2&#125;&#125;\n\n    db.Create(user1, user2)\n\n    &#x2F;&#x2F; 查询用户和角色信息\n    var users []*User\n    db.Preload(&quot;Roles.Permissions&quot;).Find(&amp;users)\n    for _, user :&#x3D; range users &#123;\n        fmt.Printf(&quot;用户 %s 的角色信息：\\n&quot;, user.Name)\n        for _, role :&#x3D; range user.Roles &#123;\n            fmt.Printf(&quot;角色 %s 的权限信息：\\n&quot;, role.Name)\n            for _, perm :&#x3D; range role.Permissions &#123;\n                fmt.Printf(&quot;- %s\\n&quot;, perm.Name)\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 更新用户角色信息\n    db.Model(user1).Association(&quot;Roles&quot;).Replace([]*Role&#123;role2&#125;)\n    db.Model(user2).Association(&quot;Roles&quot;).Clear()\n\n    &#x2F;&#x2F; 删除用户和角色信息\n    db.Delete(user1, user2)\n    db.Delete(role1, role2)\n&#125;</code></pre>\n\n<p>这个简化的代码与之前的代码相比主要做了以下几点改进：</p>\n<ol>\n<li>在创建角色时，同时创建了相应的权限，避免了后续的额外操作；</li>\n<li>在创建用户时，只需要指定用户的角色，而不需要为角色添加权限，因为角色已经预设了权限；</li>\n<li>通过链式操作，更加简洁地实现了用户角色的增删改查操作；</li>\n<li>精简了查询用户角色信息的代码。</li>\n</ol>\n<h3 id=\"上述代码中-Permission-什么意思\"><a href=\"#上述代码中-Permission-什么意思\" class=\"headerlink\" title=\"上述代码中 []*Permission 什么意思\"></a>上述代码中 []*Permission 什么意思</h3><p><code>[]*Permission</code> 表示 Permission 结构体的指针数组。在这个例子中，一个 Role 可以有多个 Permission，因此 Role 结构体中的 Permissions 字段的类型是 <code>[]*Permission</code>。指针数组的优点是可以动态地分配内存，这样可以减少内存的浪费。另外，使用指针数组还可以提高程序的效率，因为指针传递比值传递更快。</p>\n<h3 id=\"上述代码中-更新用户角色信息，为什么用-Association\"><a href=\"#上述代码中-更新用户角色信息，为什么用-Association\" class=\"headerlink\" title=\"上述代码中 更新用户角色信息，为什么用 Association\"></a>上述代码中 更新用户角色信息，为什么用 Association</h3><p>在 GORM 中，使用 <code>Association</code> 方法可以方便地处理多对多关系的增删改查操作。当我们想要在多对多关系中更新关联记录时，可以使用 <code>Association</code> 方法来更新关联关系。</p>\n<p>具体来说，我们可以通过 <code>Association</code> 方法获取到某个模型的关联模型，然后使用关联模型的方法来更新关联关系。在这个例子中，我们需要更新用户和角色之间的关联关系，因此可以使用 <code>user.Roles().Replace(roles)</code> 方法来替换当前用户的角色列表。这个方法会把原有的角色列表清空，然后添加新的角色列表，实现了更新操作。如果需要追加角色，可以使用 <code>Add</code> 方法。如果需要删除角色，可以使用 <code>Delete</code> 方法。</p>\n<p>总之，使用 <code>Association</code> 方法可以简化多对多关系的更新操作，提高程序的可读性和可维护性。</p>\n<h3 id=\"把原有的角色列表清空，然后添加新的角色列表，会不会出现，列表清空了，却没有添加成功的现象\"><a href=\"#把原有的角色列表清空，然后添加新的角色列表，会不会出现，列表清空了，却没有添加成功的现象\" class=\"headerlink\" title=\"把原有的角色列表清空，然后添加新的角色列表，会不会出现，列表清空了，却没有添加成功的现象\"></a>把原有的角色列表清空，然后添加新的角色列表，会不会出现，列表清空了，却没有添加成功的现象</h3><p>在使用 <code>Association</code> 方法更新多对多关系时，如果出现了列表清空了但没有添加成功的情况，一般有两个可能的原因：</p>\n<ol>\n<li><p>数据库事务问题。在使用 GORM 操作数据库时，通常需要开启事务来确保操作的原子性和一致性。如果更新多对多关系时没有开启事务或事务异常终止，可能会导致清空列表成功但添加新列表失败的情况。</p>\n</li>\n<li><p>数据库字段约束问题。在多对多关系中，经常需要使用中间表来记录两个模型之间的关联关系。如果中间表中定义的外键约束或唯一约束等字段约束与当前操作不兼容，也可能导致清空列表成功但添加新列表失败的情况。</p>\n</li>\n</ol>\n<p>为了避免出现这种情况，我们可以在更新多对多关系之前先检查数据库事务的状态，确保事务正常运行。此外，我们还应该仔细检查中间表的字段定义和约束，确保与当前操作相兼容。</p>\n<h3 id=\"先检查数据库事务的状态？\"><a href=\"#先检查数据库事务的状态？\" class=\"headerlink\" title=\"先检查数据库事务的状态？\"></a>先检查数据库事务的状态？</h3><p>是的，检查数据库事务的状态可以确保事务正常运行，从而避免出现清空列表成功但添加新列表失败的情况。在 GORM 中，我们可以使用 <code>gorm.DB</code> 结构体的 <code>Begin</code> 方法开启一个数据库事务，然后使用 <code>gorm.DB</code> 结构体的 <code>Commit</code> 和 <code>Rollback</code> 方法来提交或回滚事务。</p>\n<p>具体来说，在更新多对多关系时，可以使用 <code>DB.Begin</code> 方法开启一个数据库事务，然后在事务中执行清空列表和添加新列表的操作，最后使用 <code>DB.Commit</code> 方法提交事务。如果出现异常，可以使用 <code>DB.Rollback</code> 方法回滚事务。</p>\n<p>以下是一个简单的示例代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func UpdateUserRole(db *gorm.DB, user *User, roles []*Role) error &#123;\n    tx :&#x3D; db.Begin()\n\n    if err :&#x3D; tx.Error; err !&#x3D; nil &#123;\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Model(user).Association(&quot;Roles&quot;).Replace(roles).Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Commit().Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    return nil\n&#125;</code></pre>\n\n<p>在这个示例中，我们首先使用 <code>DB.Begin</code> 方法开启一个事务，然后在事务中执行清空列表和添加新列表的操作。如果操作成功，就使用 <code>DB.Commit</code> 方法提交事务，否则使用 <code>DB.Rollback</code> 方法回滚事务。注意，在操作过程中，我们使用 <code>tx.Error</code> 方法检查事务的状态，确保事务正常运行。</p>\n<h3 id=\"至此，完整代码\"><a href=\"#至此，完整代码\" class=\"headerlink\" title=\"至此，完整代码\"></a>至此，完整代码</h3><p>以下是完整的示例代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Username string &#96;gorm:&quot;uniqueIndex&quot;&#96;\n    Password string\n    Roles    []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name       string         &#96;gorm:&quot;uniqueIndex&quot;&#96;\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string &#96;gorm:&quot;uniqueIndex&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    if err :&#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;); err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 创建用户\n    user1 :&#x3D; &amp;User&#123;\n        Username: &quot;user1&quot;,\n        Password: &quot;password1&quot;,\n    &#125;\n    db.Create(user1)\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;\n        Name: &quot;role1&quot;,\n        Permissions: []*Permission&#123;\n            &#123;Name: &quot;permission1&quot;&#125;,\n            &#123;Name: &quot;permission2&quot;&#125;,\n        &#125;,\n    &#125;\n    db.Create(role1)\n    role2 :&#x3D; &amp;Role&#123;\n        Name: &quot;role2&quot;,\n        Permissions: []*Permission&#123;\n            &#123;Name: &quot;permission2&quot;&#125;,\n            &#123;Name: &quot;permission3&quot;&#125;,\n        &#125;,\n    &#125;\n    db.Create(role2)\n\n    &#x2F;&#x2F; 更新用户角色信息\n    roles :&#x3D; []*Role&#123;role1, role2&#125;\n    if err :&#x3D; UpdateUserRoles(db, user1, roles); err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 查询用户信息\n    var user User\n    db.Preload(&quot;Roles.Permissions&quot;).First(&amp;user, &quot;username &#x3D; ?&quot;, &quot;user1&quot;)\n    fmt.Printf(&quot;User: %+v\\n&quot;, user)\n&#125;\n\nfunc UpdateUserRoles(db *gorm.DB, user *User, roles []*Role) error &#123;\n    tx :&#x3D; db.Begin()\n\n    if err :&#x3D; tx.Error; err !&#x3D; nil &#123;\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Model(user).Association(&quot;Roles&quot;).Replace(roles).Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Commit().Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    return nil\n&#125;</code></pre>\n\n<p>在这个示例中，我们定义了 <code>User</code>、<code>Role</code> 和 <code>Permission</code> 三个模型，并使用 <code>many2many</code> 关系将它们关联起来。在 <code>UpdateUserRoles</code> 函数中，我们使用了 <code>Association</code> 方法更新用户的角色信息，并在事务中执行操作，确保操作的原子性。最后，我们查询了用户信息，并打印出来。</p>\n<h3 id=\"primaryKey\"><a href=\"#primaryKey\" class=\"headerlink\" title=\"primaryKey\"></a>primaryKey</h3><p><code>primaryKey</code> 是 GORM 中用于指定主键名称的选项之一。如果不使用此选项，则默认情况下，GORM 会将模型的 ID 字段作为主键。如果模型有多个字段组成复合主键，则可以使用 <code>gorm:&quot;primaryKey&quot;</code> 标签在这些字段上指定为主键。</p>\n<p>例如，下面的代码演示了如何在 GORM 中使用复合主键：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    Name   string &#96;gorm:&quot;primaryKey&quot;&#96;\n    Number int    &#96;gorm:&quot;primaryKey&quot;&#96;\n    Email  string\n&#125;\n\ndb.AutoMigrate(&amp;User&#123;&#125;)</code></pre>\n\n<p>在上面的示例中，<code>User</code> 模型的主键由 <code>Name</code> 和 <code>Number</code> 两个字段组成。在 <code>Name</code> 和 <code>Number</code> 字段上都使用了 <code>primaryKey</code> 标签，表示它们是组成主键的一部分。执行 <code>db.AutoMigrate(&amp;User&#123;&#125;)</code> 后，GORM 将会在数据库中创建一个名为 <code>users</code> 的表，其中包含 <code>Name</code> 和 <code>Number</code> 两个字段作为主键。</p>\n<p>需要注意的是，使用复合主键的模型在使用 GORM 进行增删改查等操作时，需要使用 <code>db.Session(&amp;gorm.Session&#123;FullSaveAssociations: true&#125;)</code> 开启完整关联保存模式，以保证 GORM 能够正确地处理关联数据的更新和删除。</p>\n<h3 id=\"完整的例子\"><a href=\"#完整的例子\" class=\"headerlink\" title=\"完整的例子\"></a>完整的例子</h3><p>以下是一个使用 GORM 创建包含复合主键的表格的示例代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Book struct &#123;\n\tID    int    &#96;gorm:&quot;primaryKey;autoIncrement:false&quot;&#96;\n\tTitle string &#96;gorm:&quot;primaryKey;autoIncrement:false&quot;&#96;\n\tAuthor string\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接数据库\n\tdsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\tdb.AutoMigrate(&amp;Book&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建数据行\n\tbook1 :&#x3D; &amp;Book&#123;ID: 1, Title: &quot;GORM Basics&quot;, Author: &quot;John Doe&quot;&#125;\n\tbook2 :&#x3D; &amp;Book&#123;ID: 2, Title: &quot;Advanced GORM&quot;, Author: &quot;Jane Smith&quot;&#125;\n\n\tdb.Create(book1)\n\tdb.Create(book2)\n\n\t&#x2F;&#x2F; 查询数据行\n\tvar books []*Book\n\tdb.Find(&amp;books)\n\n\t&#x2F;&#x2F; 打印查询结果\n\tfor _, book :&#x3D; range books &#123;\n\t\tfmt.Printf(&quot;Book: %s by %s\\n&quot;, book.Title, book.Author)\n\t&#125;\n&#125;</code></pre>\n\n<p>在这个例子中，我们定义了一个 <code>Book</code> 结构体，并为其中的 <code>ID</code> 和 <code>Title</code> 字段都添加了 <code>primaryKey</code> 标记，以实现复合主键。然后我们创建了两条数据行，分别为 ID 为 1 和 2 的两本书。最后我们查询了所有的书，并将结果打印出来。</p>\n<h3 id=\"使用了-autoIncrement-false\"><a href=\"#使用了-autoIncrement-false\" class=\"headerlink\" title=\"使用了 autoIncrement:false\"></a>使用了 autoIncrement:false</h3><p>复合主键的情况下，通常不会使用自增长的方式来生成主键，而是需要手动指定主键的值。在 GORM 中，可以通过在模型中定义多个字段，并使用 <code>primaryKey</code> 标记来指定这些字段作为复合主键。</p>\n<p>下面是一个使用 GORM 定义复合主键的完整示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;time&quot;\n)\n\ntype OrderItem struct &#123;\n    OrderID  int    &#96;gorm:&quot;primaryKey&quot;&#96;\n    ItemCode string &#96;gorm:&quot;primaryKey&quot;&#96;\n    Name     string\n    Price    float64\n    CreatedAt time.Time\n&#125;\n\nfunc main() &#123;\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;OrderItem&#123;&#125;)\n\n    &#x2F;&#x2F; 插入数据\n    item1 :&#x3D; &amp;OrderItem&#123;OrderID: 1, ItemCode: &quot;A001&quot;, Name: &quot;商品A&quot;, Price: 100.0, CreatedAt: time.Now()&#125;\n    item2 :&#x3D; &amp;OrderItem&#123;OrderID: 1, ItemCode: &quot;A002&quot;, Name: &quot;商品B&quot;, Price: 200.0, CreatedAt: time.Now()&#125;\n    item3 :&#x3D; &amp;OrderItem&#123;OrderID: 2, ItemCode: &quot;A003&quot;, Name: &quot;商品C&quot;, Price: 300.0, CreatedAt: time.Now()&#125;\n    db.Create(item1, item2, item3)\n\n    &#x2F;&#x2F; 查询数据\n    var items []*OrderItem\n    db.Find(&amp;items)\n    for _, item :&#x3D; range items &#123;\n        println(item.OrderID, item.ItemCode, item.Name, item.Price, item.CreatedAt)\n    &#125;\n\n    &#x2F;&#x2F; 更新数据\n    db.Model(item1).Updates(map[string]interface&#123;&#125;&#123;&quot;Price&quot;: 150.0&#125;)\n\n    &#x2F;&#x2F; 删除数据\n    db.Delete(item2)\n&#125;</code></pre>\n\n<p>在这个例子中，<code>OrderID</code> 和 <code>ItemCode</code> 两个字段一起作为 <code>OrderItem</code> 模型的复合主键，分别使用 <code>primaryKey</code> 标记来指定。这里注意到 <code>autoIncrement</code> 参数被设置为 <code>false</code>，因为复合主键一般不使用自增长的方式生成主键。</p>\n<p>在插入数据时，需要手动指定主键的值。在查询、更新和删除数据时，也需要同时指定主键的值来定位需要操作的数据行。</p>\n<h3 id=\"什么情况下，使用复合主键\"><a href=\"#什么情况下，使用复合主键\" class=\"headerlink\" title=\"什么情况下，使用复合主键\"></a>什么情况下，使用复合主键</h3><p>复合主键通常用于满足业务需求，例如要求某些字段的组合必须唯一。在这种情况下，单一的主键可能无法满足要求，因为其中一个字段可能不足以唯一标识一个记录。例如，在一个订单表中，一个订单可能有多个商品，因此订单编号和商品编号的组合可能是唯一的，这时候就可以使用复合主键来保证唯一性。</p>\n<h3 id=\"关联模式\"><a href=\"#关联模式\" class=\"headerlink\" title=\"关联模式\"></a>关联模式</h3><p>在 GORM 中，关联模式有四种，分别是：</p>\n<ol>\n<li>BelongsTo 关联</li>\n<li>HasOne 关联</li>\n<li>HasMany 关联</li>\n<li>ManyToMany 关联</li>\n</ol>\n<p>下面对每种关联模式进行简要介绍：</p>\n<ol>\n<li>BelongsTo 关联：</li>\n</ol>\n<p>BelongsTo 关联表示一个模型属于另一个模型，也就是一对一的关系。在 GORM 中，使用 <code>BelongsTo</code> 方法来定义关联关系，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    gorm.Model\n    Name      string\n    CompanyID uint\n    Company   Company\n&#125;\n\ntype Company struct &#123;\n    gorm.Model\n    Name  string\n    Users []User\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).BelongsTo(&amp;Company&#123;&#125;)</code></pre>\n\n<ol start=\"2\">\n<li>HasOne 关联：</li>\n</ol>\n<p>HasOne 关联表示一个模型拥有另一个模型，也就是一对一的关系。在 GORM 中，使用 <code>HasOne</code> 方法来定义关联关系，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    gorm.Model\n    Name         string\n    CreditCard   CreditCard\n    CreditCardID uint\n&#125;\n\ntype CreditCard struct &#123;\n    gorm.Model\n    Number string\n    UserID uint\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).HasOne(&amp;CreditCard&#123;&#125;)</code></pre>\n\n<ol start=\"3\">\n<li>HasMany 关联：</li>\n</ol>\n<p>HasMany 关联表示一个模型拥有多个另一个模型，也就是一对多的关系。在 GORM 中，使用 <code>HasMany</code> 方法来定义关联关系，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    gorm.Model\n    Name   string\n    Orders []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID uint\n    Amount float32\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).HasMany(&amp;Order&#123;&#125;)</code></pre>\n\n<ol start=\"4\">\n<li>ManyToMany 关联：</li>\n</ol>\n<p>ManyToMany 关联表示两个模型之间有多对多的关系。在 GORM 中，使用 <code>Many2Many</code> 方法来定义关联关系，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).Many2Many(&amp;Role&#123;&#125;, &quot;user_roles&quot;)\ndb.Model(&amp;Role&#123;&#125;).Many2Many(&amp;Permission&#123;&#125;, &quot;role_permissions&quot;)</code></pre>\n\n<p>以上就是 GORM 中四种关联模式的介绍。需要注意的是，使用关联模式时，应该根据实际情况选择合适的模式。</p>\n<h3 id=\"如何区分-BelongsTo-和-HasOne\"><a href=\"#如何区分-BelongsTo-和-HasOne\" class=\"headerlink\" title=\"如何区分 BelongsTo 和 HasOne\"></a>如何区分 BelongsTo 和 HasOne</h3><p>在 GORM 中，BelongsTo 和 HasOne 都表示一对一的关系，但它们在语义上有所不同。</p>\n<p>BelongsTo 表示一个模型“属于”另一个模型，比如一个订单属于一个用户。在这种关系下，通常在从表（即属于表）中建立外键关联到主表（即拥有表）中。</p>\n<p>HasOne 表示一个模型“拥有”另一个模型，比如一个用户拥有一个个人资料。在这种关系下，通常在主表中建立外键关联到从表中。</p>\n<p>因此，可以根据语义来区分这两种关系。如果一个模型属于另一个模型，则使用 BelongsTo，如果一个模型拥有另一个模型，则使用 HasOne。</p>\n<p>总结：</p>\n<ol>\n<li>使用上看主键是在从表还是在主表：在从表 BelongsTo, 在主表 HasOne</li>\n<li>语义不同： 如果一个模型属于另一个模型，则使用 BelongsTo，如果一个模型拥有另一个模型，则使用 HasOne。</li>\n</ol>\n<h3 id=\"关联操作\"><a href=\"#关联操作\" class=\"headerlink\" title=\"关联操作\"></a>关联操作</h3><p>在 GORM 中，关联操作主要包括以下几个方面：</p>\n<ol>\n<li>预加载（Preloading）：一般用于查询时，同时将关联对象加载到内存中，避免多次查询数据库。</li>\n<li>关联查询（Joins）：根据关联条件，将两个或多个表关联起来，查询相关数据。</li>\n<li>关联插入（Association）：将两个或多个表之间的关联关系插入到关联表中。</li>\n<li>关联更新（Association）：更新关联表中的关联关系。</li>\n<li>关联删除（Association）：删除关联表中的关联关系。</li>\n</ol>\n<p>这些操作涉及到不同的 GORM 方法，比如 <code>Preload</code>、<code>Joins</code>、<code>Association</code> 等。具体的使用方法可以查看 GORM 的官方文档。</p>\n<h3 id=\"Association\"><a href=\"#Association\" class=\"headerlink\" title=\"Association\"></a>Association</h3><p>在 GORM 中，Association 指的是通过关联关系进行增删改查操作的方法，主要包括以下几个方法：</p>\n<ul>\n<li><code>Append</code>：添加关联记录</li>\n<li><code>Delete</code>：删除关联记录</li>\n<li><code>Replace</code>：替换关联记录</li>\n<li><code>Clear</code>：清空关联记录</li>\n</ul>\n<p>这些方法可以用于多对多、一对多等关联关系，可以通过关联的对象的指针或 ID 进行操作。这些方法在使用时需要注意事务的管理，避免出现数据不一致的情况。在使用时，也需要注意避免出现死循环的情况，特别是在多层级的关联关系中。</p>\n<h3 id=\"Association-这四个-API-怎么用\"><a href=\"#Association-这四个-API-怎么用\" class=\"headerlink\" title=\"Association 这四个 API 怎么用\"></a>Association 这四个 API 怎么用</h3><p>这四个 API 都是用于修改关联关系的，具体如下：</p>\n<ol>\n<li><code>db.Model(&amp;user).Association(&quot;Roles&quot;).Append(&amp;role1, &amp;role2)</code>：将 <code>user</code> 与 <code>role1</code> 和 <code>role2</code> 关联，如果关联关系已经存在，则不会进行任何操作。</li>\n<li><code>db.Model(&amp;user).Association(&quot;Roles&quot;).Delete(&amp;role1, &amp;role2)</code>：删除 <code>user</code> 与 <code>role1</code> 和 <code>role2</code> 的关联关系，如果关联关系不存在，则不会进行任何操作。</li>\n<li><code>db.Model(&amp;user).Association(&quot;Roles&quot;).Replace(&amp;role1, &amp;role2)</code>：将 <code>user</code> 与 <code>role1</code> 和 <code>role2</code> 的关联关系替换为新的关联关系，如果关联关系已经存在，则先删除旧的关联关系再进行新的关联。</li>\n<li><code>db.Model(&amp;user).Association(&quot;Roles&quot;).Clear()</code>：清空 <code>user</code> 与 <code>Roles</code> 的关联关系。</li>\n</ol>\n<p>其中，<code>user</code> 表示主表，<code>Roles</code> 表示关联表。在使用这些 API 前，需要先在主表中定义关联关系，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;</code></pre>\n\n<p>这里的 <code>user_roles</code> 是中间表的名称，用于维护主表和关联表之间的关联关系。同时，在关联表中也需要定义相应的关联关系，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type Role struct &#123;\n    gorm.Model\n    Name        string\n    Users       []*User &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;</code></pre>\n\n<p>这里的 <code>user_roles</code> 和主表中的名称要保持一致，<code>Users</code> 表示与 <code>User</code> 表关联的字段，<code>role_permissions</code> 是另一个中间表的名称，用于维护 <code>Role</code> 表与 <code>Permission</code> 表之间的关联关系。</p>\n<h3 id=\"Association-完整的例子\"><a href=\"#Association-完整的例子\" class=\"headerlink\" title=\"Association 完整的例子\"></a>Association 完整的例子</h3><p>以下是一个完整的例子，展示如何在 GORM 中定义和使用关联模式：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;log&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name      string\n    Email     string\n    Profile   Profile\n    Addresses []Address\n&#125;\n\ntype Profile struct &#123;\n    gorm.Model\n    UserID uint\n    Age    int\n&#125;\n\ntype Address struct &#123;\n    gorm.Model\n    UserID  uint\n    Country string\n    City    string\n&#125;\n\nfunc main() &#123;\n    dsn :&#x3D; &quot;root:123456@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    err &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;, &amp;Address&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n\n    &#x2F;&#x2F; 创建用户和关联数据\n    user :&#x3D; User&#123;\n        Name:  &quot;张三&quot;,\n        Email: &quot;zhangsan@example.com&quot;,\n        Profile: Profile&#123;\n            Age: 18,\n        &#125;,\n        Addresses: []Address&#123;\n            &#123;Country: &quot;China&quot;, City: &quot;Shanghai&quot;&#125;,\n            &#123;Country: &quot;USA&quot;, City: &quot;New York&quot;&#125;,\n        &#125;,\n    &#125;\n\n    result :&#x3D; db.Create(&amp;user)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    &#x2F;&#x2F; 查询用户和关联数据\n    var user2 User\n    result &#x3D; db.Preload(&quot;Profile&quot;).Preload(&quot;Addresses&quot;).First(&amp;user2)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    log.Println(user2)\n\n    &#x2F;&#x2F; 更新关联数据\n    user2.Addresses[0].City &#x3D; &quot;Beijing&quot;\n    result &#x3D; db.Save(&amp;user2)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    &#x2F;&#x2F; 删除关联数据\n    result &#x3D; db.Delete(&amp;user2.Addresses[0])\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    &#x2F;&#x2F; 删除用户和关联数据\n    result &#x3D; db.Delete(&amp;user2)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n&#125;</code></pre>\n\n<p>在这个例子中，我们定义了三个模型：<code>User</code>、<code>Profile</code> 和 <code>Address</code>。它们之间的关联模式分别为：</p>\n<ul>\n<li><code>User</code> 和 <code>Profile</code>：一个用户有一个个人资料，使用 BelongsTo 模式。</li>\n<li><code>User</code> 和 <code>Address</code>：一个用户有多个地址，使用 HasMany 模式。</li>\n<li><code>Address</code> 和 <code>User</code>：一个地址属于一个用户，使用 BelongsTo 模式。</li>\n</ul>\n<p>我们首先创建一个用户和关联数据，并通过 <code>Create()</code> 方法将它们存储到数据库中。接着，我们查询该用户及其关联数据，使用 <code>Preload()</code> 方法可以在一次查询中加载关联数据，避免了多次查询数据库的问题。我们还演示了如何更新关联数据和删除关联数据，以及如何删除用户及其关联数据。</p>\n<p>下面是一个完整的例子，演示如何使用 GORM 进行实体关联。</p>\n<p>假设有两个表：用户和订单。一个用户可以拥有多个订单，而一个订单只能属于一个用户。用户和订单之间是一对多的关系。首先，定义两个模型：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    gorm.Model\n    Name    string\n    Email   string\n    Orders  []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID  uint\n    Name    string\n    Price   float64\n&#125;</code></pre>\n\n<p>在用户模型中，使用了 GORM 内置的 <code>gorm.Model</code> 结构体，该结构体包含了一些常用的字段，比如 ID、CreatedAt、UpdatedAt 和 DeletedAt。同时，用户模型还包含了一个名为 <code>Orders</code> 的字段，该字段为用户的订单列表。在订单模型中，使用了 <code>UserID</code> 字段来存储订单所属的用户 ID。</p>\n<p>然后，使用 GORM 进行实体关联：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 创建用户和订单\nuser :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Email: &quot;zhangsan@example.com&quot;&#125;\norder1 :&#x3D; &amp;Order&#123;Name: &quot;订单1&quot;, Price: 100&#125;\norder2 :&#x3D; &amp;Order&#123;Name: &quot;订单2&quot;, Price: 200&#125;\nuser.Orders &#x3D; []Order&#123;*order1, *order2&#125;\ndb.Create(user)\n\n&#x2F;&#x2F; 查询用户及其订单信息\nvar u User\ndb.Preload(&quot;Orders&quot;).First(&amp;u)\nfmt.Println(&quot;用户信息：&quot;, u)\nfor _, order :&#x3D; range u.Orders &#123;\n    fmt.Println(&quot;订单信息：&quot;, order)\n&#125;\n\n&#x2F;&#x2F; 更新用户订单信息\ndb.Model(&amp;u).Association(&quot;Orders&quot;).Delete(order1)\ndb.Model(&amp;u).Association(&quot;Orders&quot;).Replace([]Order&#123;*order2&#125;)\ndb.Model(&amp;u).Association(&quot;Orders&quot;).Clear()\n\n&#x2F;&#x2F; 删除用户及其订单信息\ndb.Delete(&amp;u)</code></pre>\n\n<p>在创建用户时，使用了用户模型的 <code>Orders</code> 字段来设置用户的订单列表。在查询用户时，使用了 GORM 的 <code>Preload</code> 方法来预加载用户的订单信息，以避免 N+1 查询的问题。在更新用户订单信息时，使用了 GORM 的 <code>Association</code> 方法来对用户的订单列表进行增删改查操作。在删除用户时，使用了 GORM 的 <code>Delete</code> 方法来同时删除用户及其订单信息。</p>\n<h3 id=\"完整代码如下：\"><a href=\"#完整代码如下：\" class=\"headerlink\" title=\"完整代码如下：\"></a>完整代码如下：</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name    string\n    Email   string\n    Orders  []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID  uint\n    Name    string\n    Price   float64\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;)\n\n    &#x2F;&#x2F; 创建用户和订单\n    user :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Email: &quot;zhangsan@example.com&quot;&#125;\n    order1 :&#x3D; &amp;Order&#123;Name: &quot;订单1&quot;, Price:\n\n&#x2F;&#x2F; 可以通过 &#96;Association&#96; 方法来进行关联操作。&#96;Association&#96; 方法接受一个关联字段的名称作为参数，返回该关联字段的关联对象，可以对该关联对象进行增删改查等操作。\n\n&#x2F;&#x2F; 例如，在上一个例子中，我们可以通过以下代码来进行关联操作：\n\n&#x2F;&#x2F; 建立关联关系\ndb.Model(&amp;user).Association(&quot;Profile&quot;).Assign(&amp;profile)\n\n&#x2F;&#x2F; 清空关联关系\ndb.Model(&amp;user).Association(&quot;Profile&quot;).Clear()\n\n&#x2F;&#x2F; 添加关联关系\ndb.Model(&amp;user).Association(&quot;Addresses&quot;).Append(&amp;address)\n\n&#x2F;&#x2F; 删除关联关系\ndb.Model(&amp;user).Association(&quot;Addresses&quot;).Delete(&amp;address)</code></pre>\n\n<p>其中，</p>\n<ol>\n<li><code>Assign</code> 方法可以用来建立关联关系，</li>\n<li><code>Clear</code> 方法可以用来清空关联关系，</li>\n<li><code>Append</code> 方法可以用来添加关联关系，</li>\n<li><code>Delete</code> 方法可以用来删除关联关系。</li>\n</ol>\n<p>完整代码如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tgorm.Model\n\tName      string\n\tProfile   Profile\n\tAddresses []Address\n&#125;\n\ntype Profile struct &#123;\n\tgorm.Model\n\tUserID uint\n\tName   string\n&#125;\n\ntype Address struct &#123;\n\tgorm.Model\n\tUserID  uint\n\tCity    string\n\tCountry string\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接数据库\n\tdsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\tdb.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;, &amp;Address&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建用户、资料和地址\n\tuser :&#x3D; &amp;User&#123;\n\t\tName: &quot;张三&quot;,\n\t\tProfile: Profile&#123;\n\t\t\tName: &quot;张三的资料&quot;,\n\t\t&#125;,\n\t\tAddresses: []Address&#123;\n\t\t\t&#123;City: &quot;北京&quot;, Country: &quot;中国&quot;&#125;,\n\t\t\t&#123;City: &quot;上海&quot;, Country: &quot;中国&quot;&#125;,\n\t\t&#125;,\n\t&#125;\n\n\tdb.Create(user)\n\n\t&#x2F;&#x2F; 查询用户、资料和地址\n\tvar u User\n\tdb.Preload(&quot;Profile&quot;).Preload(&quot;Addresses&quot;).Find(&amp;u)\n\n\tfmt.Printf(&quot;用户：%s\\n&quot;, u.Name)\n\tfmt.Printf(&quot;资料：%s\\n&quot;, u.Profile.Name)\n\tfmt.Println(&quot;地址：&quot;)\n\tfor _, address :&#x3D; range u.Addresses &#123;\n\t\tfmt.Printf(&quot;- %s, %s\\n&quot;, address.City, address.Country)\n\t&#125;\n\n\t&#x2F;&#x2F; 建立关联关系\n\tprofile :&#x3D; Profile&#123;\n\t\tName: &quot;新的资料&quot;,\n\t&#125;\n\tdb.Model(&amp;user).Association(&quot;Profile&quot;).Assign(&amp;profile)\n\n\t&#x2F;&#x2F; 清空关联关系\n\tdb.Model(&amp;user).Association(&quot;Addresses&quot;).Clear()\n\n\t&#x2F;&#x2F; 添加关联关系\n\taddress :&#x3D; Address&#123;\n\t\tCity:    &quot;广州&quot;,\n\t\tCountry: &quot;中国&quot;,\n\t&#125;\n\tdb.Model(&amp;user).Association(&quot;Addresses&quot;).Append(&amp;address)\n\n\t&#x2F;&#x2F; 删除关联关系\n\tdb.Model(&amp;user).Association(&quot;Addresses&quot;).Delete(&amp;address)\n&#125;</code></pre>\n\n<h3 id=\"建立关联关系-清空关联关系-对数据库有什么影响\"><a href=\"#建立关联关系-清空关联关系-对数据库有什么影响\" class=\"headerlink\" title=\"建立关联关系 清空关联关系 对数据库有什么影响\"></a>建立关联关系 清空关联关系 对数据库有什么影响</h3><p>建立和清空关联关系对数据库都会产生影响，具体如下：</p>\n<h3 id=\"建立关联关系：\"><a href=\"#建立关联关系：\" class=\"headerlink\" title=\"建立关联关系：\"></a>建立关联关系：</h3><p>当我们使用 gorm 的关联 API （例如 <code>Association</code>）来建立两个实体之间的关联关系时，gorm 会自动在关联关系所对应的中间表中插入一些新的数据记录，这些记录描述了这两个实体之间的关联关系。这些新插入的数据会被持久化到数据库中。</p>\n<p>例如，当我们将一个用户实体与一个角色实体建立起多对多关联关系时，gorm 会自动在 user_roles 中间表中插入一个新的数据记录，记录描述了这个用户实体和这个角色实体之间的关联关系。</p>\n<h3 id=\"清空关联关系：\"><a href=\"#清空关联关系：\" class=\"headerlink\" title=\"清空关联关系：\"></a>清空关联关系：</h3><p>当我们使用 gorm 的关联 API（例如 <code>Association</code>）来清空两个实体之间的关联关系时，gorm 会自动从关联关系所对应的中间表中删除所有相关的数据记录。这些记录描述了这两个实体之间的关联关系。这些被删除的数据会被持久化到数据库中。</p>\n<p>例如，当我们清空一个用户实体与一个角色实体之间的多对多关联关系时，gorm 会自动从 user_roles 中间表中删除所有描述这个用户实体和这个角色实体之间关联关系的数据记录。</p>\n<h3 id=\"上述，清空关联关系中的删除，是软删除还是物理删除\"><a href=\"#上述，清空关联关系中的删除，是软删除还是物理删除\" class=\"headerlink\" title=\"上述，清空关联关系中的删除，是软删除还是物理删除\"></a>上述，清空关联关系中的删除，是软删除还是物理删除</h3><p>上述代码中的 <code>Clear()</code> 操作是物理删除，即从关联表中删除所有关联的记录。如果需要使用软删除，可以使用 <code>gorm.Model</code> 提供的软删除机制，或者手动添加一个 <code>deleted_at</code> 字段，并在删除记录时将该字段赋值为当前时间戳，表示该记录已被删除，而不是从数据库中删除该记录。具体实现方式可以参考 GORM 的文档或者其他相关资料。</p>\n<h3 id=\"实体关联\"><a href=\"#实体关联\" class=\"headerlink\" title=\"实体关联\"></a>实体关联</h3><p><a href=\"https://gorm.io/zh_CN/docs/associations.html#%E6%9F%A5%E6%89%BE%E5%85%B3%E8%81%94\">https://gorm.io/zh_CN/docs/associations.html#%E6%9F%A5%E6%89%BE%E5%85%B3%E8%81%94</a></p>\n<h3 id=\"db-Model-amp-user-Association-“Orders”-Find-amp-orders-与-db-Preload-“Orders”-Find-amp-users-的区别\"><a href=\"#db-Model-amp-user-Association-“Orders”-Find-amp-orders-与-db-Preload-“Orders”-Find-amp-users-的区别\" class=\"headerlink\" title=\"db.Model(&amp;user).Association(“Orders”).Find(&amp;orders) 与 db.Preload(“Orders”).Find(&amp;users) 的区别\"></a>db.Model(&amp;user).Association(“Orders”).Find(&amp;orders) 与 db.Preload(“Orders”).Find(&amp;users) 的区别</h3><p><code>db.Model(&amp;user).Association(&quot;Orders&quot;).Find(&amp;orders)</code> 和 <code>db.Preload(&quot;Orders&quot;).Find(&amp;users)</code> 两者的作用不同。</p>\n<ul>\n<li><p><code>db.Model(&amp;user).Association(&quot;Orders&quot;).Find(&amp;orders)</code>：是在已有用户实体的前提下，通过 <code>Association</code> 方法获取其 <code>Orders</code> 关联实体的值并填充到 <code>&amp;orders</code> 中。这种方法适用于已经查询出了用户实体并需要获取其关联实体的情况。</p>\n</li>\n<li><p><code>db.Preload(&quot;Orders&quot;).Find(&amp;users)</code>：是在查询用户实体时预加载 <code>Orders</code> 关联实体的值，以避免在后续使用时需要执行额外的 SQL 查询。这种方法适用于需要查询用户实体和其关联实体的情况。</p>\n</li>\n</ul>\n<p>总之，两种方法的区别在于是否在查询时进行预加载，以及获取关联实体的方式不同。选择哪种方法应根据具体情况而定。</p>\n<h3 id=\"两者使用场景\"><a href=\"#两者使用场景\" class=\"headerlink\" title=\"两者使用场景\"></a>两者使用场景</h3><p>当你需要加载单个对象的关联数据时，可以使用 <code>Association</code> 方法。当你需要加载多个对象的关联数据时，可以使用 <code>Preload</code> 方法。</p>\n<p>使用 <code>Association</code> 方法时，需要先获取主对象的实例，并通过指定关联字段的名称来获取关联数据。这种方式更适用于当你只需要获取一个对象的关联数据时。</p>\n<p>而使用 <code>Preload</code> 方法时，你可以通过在 <code>Find</code> 或 <code>First</code> 方法中传递参数来加载多个对象的关联数据。这种方式更适用于当你需要一次性获取多个对象的关联数据时，因为它可以通过 SQL 查询语句的联接操作来一次性加载多个对象的关联数据，减少了对数据库的访问次数，提高了查询效率。但是，如果你只需要获取一个对象的关联数据时，使用 <code>Preload</code> 方法反而会浪费一定的资源，因为它会在查询主对象时将所有的关联数据都加载进来，而不管你是否需要。</p>\n<h3 id=\"db-Omit-“Languages-“-Create-amp-user-与-db-Omit-“Languages”-Create-amp-user-的区别\"><a href=\"#db-Omit-“Languages-“-Create-amp-user-与-db-Omit-“Languages”-Create-amp-user-的区别\" class=\"headerlink\" title=\"db.Omit(“Languages.*“).Create(&amp;user) 与 db.Omit(“Languages”).Create(&amp;user)的区别\"></a>db.Omit(“Languages.*“).Create(&amp;user) 与 db.Omit(“Languages”).Create(&amp;user)的区别</h3><p><code>db.Omit(&quot;Languages.*&quot;).Create(&amp;user)</code> 和 <code>db.Omit(&quot;Languages&quot;).Create(&amp;user)</code> 都是使用 GORM 的 Omit 方法来指定忽略某个字段，不会将该字段的值插入数据库。</p>\n<p>但是两者的区别在于忽略的是整个 Languages 关联模型还是 Languages 模型的所有字段。具体来说：</p>\n<ul>\n<li><code>db.Omit(&quot;Languages.*&quot;).Create(&amp;user)</code> 忽略了 Languages 关联模型的所有字段，相当于没有创建 Languages 模型的记录。</li>\n<li><code>db.Omit(&quot;Languages&quot;).Create(&amp;user)</code> 只忽略了 Languages 模型本身的所有字段，不会影响到 Languages 关联模型的其他字段，例如在该例子中的 <code>UserLanguages</code> 表中的 <code>user_id</code> 和 <code>language_id</code> 字段。也就是说，执行该语句后仍然可以在 <code>UserLanguages</code> 表中插入对应的 <code>user_id</code> 和 <code>language_id</code>。</li>\n</ul>\n<p>因此，根据具体需求来选择使用哪种方式进行字段忽略。<br>下面是一个完整的示例，展示如何使用 <code>Omit</code> 方法来避免 GORM 创建或更新时处理某些关联的字段：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Language struct &#123;\n\tgorm.Model\n\tName string\n&#125;\n\ntype User struct &#123;\n\tgorm.Model\n\tName      string\n\tLanguages []*Language &#96;gorm:&quot;many2many:user_languages&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接 SQLite 数据库\n\tdsn :&#x3D; &quot;test.db&quot;\n\tdb, err :&#x3D; gorm.Open(sqlite.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\tdb.AutoMigrate(&amp;User&#123;&#125;, &amp;Language&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建语言记录\n\tlang1 :&#x3D; &amp;Language&#123;Name: &quot;Go&quot;&#125;\n\tlang2 :&#x3D; &amp;Language&#123;Name: &quot;Python&quot;&#125;\n\tlang3 :&#x3D; &amp;Language&#123;Name: &quot;Java&quot;&#125;\n\tdb.Create(lang1, lang2, lang3)\n\n\t&#x2F;&#x2F; 创建用户并分配语言\n\tuser :&#x3D; &amp;User&#123;\n\t\tName: &quot;Alice&quot;,\n\t\tLanguages: []*Language&#123;\n\t\t\tlang1,\n\t\t\tlang2,\n\t\t&#125;,\n\t&#125;\n\tdb.Omit(&quot;Languages.*&quot;).Create(user)\n\n\t&#x2F;&#x2F; 查询用户信息\n\tvar users []User\n\tdb.Preload(&quot;Languages&quot;).Find(&amp;users)\n\tfor _, u :&#x3D; range users &#123;\n\t\tfmt.Printf(&quot;%s&#39;s languages:\\n&quot;, u.Name)\n\t\tfor _, l :&#x3D; range u.Languages &#123;\n\t\t\tfmt.Printf(&quot;- %s\\n&quot;, l.Name)\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 更新用户语言信息\n\tdb.Model(user).Association(&quot;Languages&quot;).Replace([]*Language&#123;lang3&#125;)\n\tdb.Save(user)\n\n\t&#x2F;&#x2F; 查询用户信息\n\tvar updatedUser User\n\tdb.Preload(&quot;Languages&quot;).First(&amp;updatedUser, user.ID)\n\tfmt.Printf(&quot;%s&#39;s updated languages:\\n&quot;, updatedUser.Name)\n\tfor _, l :&#x3D; range updatedUser.Languages &#123;\n\t\tfmt.Printf(&quot;- %s\\n&quot;, l.Name)\n\t&#125;\n\n\t&#x2F;&#x2F; 删除用户和语言记录\n\tdb.Unscoped().Delete(user)\n\tdb.Unscoped().Delete(lang1, lang2, lang3)\n&#125;</code></pre>\n\n<p>在这个示例中，我们创建了三个 <code>Language</code> 记录并将它们分配给一个名为 <code>Alice</code> 的 <code>User</code>。在创建 <code>User</code> 记录时，我们使用 <code>Omit</code> 方法来忽略 <code>Languages</code> 关联的创建和更新。因此，即使我们没有为 <code>User</code> 记录分配任何语言，GORM 仍会成功创建该记录。</p>\n<p>在更新 <code>User</code> 记录时，我们使用 <code>Association</code> 和 <code>Replace</code> 方法来清空原有的语言分配并将其替换为另一个语言记录。最后，我们删除了所有的记录。</p>\n<h3 id=\"mac-查看是否有-sqlite\"><a href=\"#mac-查看是否有-sqlite\" class=\"headerlink\" title=\"mac 查看是否有 sqlite\"></a>mac 查看是否有 sqlite</h3><p>macOS 系统默认是自带 SQLite 的，可以通过终端输入以下命令查看系统中是否已经安装了 SQLite：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sqlite3 --version</code></pre>\n\n<p>如果已经安装了 SQLite，则会返回安装的版本信息，否则会提示 command not found。</p>\n<h3 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h3><p>查询语句是指用来从数据库中获取数据的命令。在关系型数据库中，通常使用 SQL（Structured Query Language）来编写查询语句。在 GORM 中，我们可以使用链式方法和原生 SQL 语句来构建查询。</p>\n<p>以下是一些 GORM 中常用的查询方法：</p>\n<ol>\n<li>db.Find(&amp;result, conditions, params)：查询符合条件的所有记录，结果将保存到 result 中。</li>\n<li>db.First(&amp;result, conditions, params)：查询符合条件的第一条记录，结果将保存到 result 中。</li>\n<li>db.Last(&amp;result, conditions, params)：查询符合条件的最后一条记录，结果将保存到 result 中。</li>\n<li>db.Where(conditions, params).Find(&amp;result)：使用指定的条件查询符合条件的所有记录，结果将保存到 result 中。</li>\n<li>db.Order(order).Find(&amp;result)：按照指定的顺序查询所有记录，结果将保存到 result 中。</li>\n<li>db.Limit(limit).Find(&amp;result)：限制查询结果的数量，并将结果保存到 result 中。</li>\n<li>db.Offset(offset).Find(&amp;result)：设置查询的偏移量，并将结果保存到 result 中。</li>\n<li>db.Select(columns).Find(&amp;result)：只查询指定的列，并将结果保存到 result 中。</li>\n<li>db.Joins(joins).Find(&amp;result)：查询关联表的记录，并将结果保存到 result 中。</li>\n<li>db.Raw(query, values).Scan(&amp;result)：使用原生 SQL 查询数据库，并将结果保存到 result 中。</li>\n</ol>\n<p>除了以上方法外，还有许多其他的查询方法。具体使用哪些方法取决于你的具体需求和业务逻辑。</p>\n<h3 id=\"gorm-polymorphicValue-使用完整示例\"><a href=\"#gorm-polymorphicValue-使用完整示例\" class=\"headerlink\" title=\"gorm polymorphicValue 使用完整示例\"></a>gorm polymorphicValue 使用完整示例</h3><p>下面是使用 GORM 实现多态关联的完整示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Content struct &#123;\n    gorm.Model\n    PolymorphicValue interface&#123;&#125; &#96;gorm:&quot;polymorphic:Owner;&quot;&#96;\n&#125;\n\ntype Text struct &#123;\n    Content\n    Body string\n&#125;\n\ntype Image struct &#123;\n    Content\n    URL string\n&#125;\n\ntype Video struct &#123;\n    Content\n    URL string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n\n    db.AutoMigrate(&amp;Text&#123;&#125;, &amp;Image&#123;&#125;, &amp;Video&#123;&#125;)\n\n    text :&#x3D; Text&#123;\n        Body: &quot;Hello, world!&quot;,\n    &#125;\n\n    db.Create(&amp;text)\n\n    image :&#x3D; Image&#123;\n        URL: &quot;https:&#x2F;&#x2F;example.com&#x2F;image.png&quot;,\n    &#125;\n\n    db.Create(&amp;image)\n\n    video :&#x3D; Video&#123;\n        URL: &quot;https:&#x2F;&#x2F;example.com&#x2F;video.mp4&quot;,\n    &#125;\n\n    db.Create(&amp;video)\n\n    var content Content\n    db.First(&amp;content, 1)\n\n    switch owner :&#x3D; content.PolymorphicValue.(type) &#123;\n    case *Text:\n        fmt.Println(&quot;Text body:&quot;, owner.Body)\n    case *Image:\n        fmt.Println(&quot;Image URL:&quot;, owner.URL)\n    case *Video:\n        fmt.Println(&quot;Video URL:&quot;, owner.URL)\n    &#125;\n\n&#125;</code></pre>\n\n<p>在这个例子中，我们定义了三个子模型 Text、Image 和 Video，它们都扩展了 Content 模型，并且都有一个特定的字段。Content 模型具有一个名为”PolymorphicValue”的字段，它可以存储对不同类型的实体的引用。”polymorphic”标记告诉 GORM 将”PolymorphicValue”字段用作多态关联。</p>\n<p>在这个例子中，我们创建了一个 Text、Image 和 Video 实例，并将它们保存到数据库中。我们然后获取了一个 Content 实例，并根据存储在”PolymorphicValue”字段中的值的类型进行不同的处理。</p>\n<p>这是一个简单的示例，演示了如何使用 GORM 实现多态关联。根据您的实际需求，可能需要使用更复杂的模型层次结构和多态关联来实现您的数据模型。</p>\n<h3 id=\"上述例子的数据库结构\"><a href=\"#上述例子的数据库结构\" class=\"headerlink\" title=\"上述例子的数据库结构\"></a>上述例子的数据库结构</h3><p>上述示例中，使用了 GORM 提供的自动迁移功能来创建数据表，因此在运行程序时会自动创建以下数据表：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">texts\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - body (text)\n\nimages\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - url (text)\n\nvideos\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - url (text)\n\ncontents\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - owner_type (varchar(255))\n  - owner_id (integer)</code></pre>\n\n<p>在这个例子中，每个子模型(Text、Image、Video)都对应一个数据表(texts、images、videos)，同时 Content 模型对应了一个数据表(contents)。Content 模型中的”PolymorphicValue”字段会根据它所引用的实体的类型自动填充”owner_type”和”owner_id”字段，以便在查询时可以根据类型进行过滤。在本例中，”owner_type”字段的值将分别是”texts”、”images”、”videos”，而”owner_id”字段的值将分别是对应实体在其数据表中的主键。</p>\n<h3 id=\"owner-type-的值为什么是复数的形式\"><a href=\"#owner-type-的值为什么是复数的形式\" class=\"headerlink\" title=\"owner_type 的值为什么是复数的形式\"></a>owner_type 的值为什么是复数的形式</h3><p>在 GORM 中，”owner_type”字段的值是引用的实体类型对应的数据表名称。对于大多数情况下，GORM 会默认使用引用的实体类型名称的复数形式作为对应的数据表名称。这是因为通常情况下，一个实体类型对应着多条记录，因此使用复数形式更符合数据表名称的语义。</p>\n<p>当然，在某些情况下，您可能需要自定义实体类型对应的数据表名称。在 GORM 中，您可以使用模型的”table name”标记来自定义数据表名称，例如：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Product struct &#123;\n  gorm.Model\n  Name string\n  Price float64\n  OrderID uint\n  OrderType string\n&#125;\n\ntype Order struct &#123;\n  gorm.Model\n  Products []Product &#96;gorm:&quot;foreignKey:OrderID;polymorphic:OrderType;&quot;&#96;\n&#125;\n\nfunc (Product) TableName() string &#123;\n  return &quot;product&quot;\n&#125;\n\nfunc (Order) TableName() string &#123;\n  return &quot;order&quot;\n&#125;</code></pre>\n\n<p>在上面的示例中，Product 和 Order 两个模型都通过 TableName 方法自定义了对应的数据表名称。这样，在定义多态关联时，对应的数据表名称就会变成单数形式了。所以，使用复数形式的数据表名称仅仅是 GORM 的默认行为，您可以根据需要自定义数据表名称。</p>\n<h3 id=\"polymorphicValue-两个结构体的例子\"><a href=\"#polymorphicValue-两个结构体的例子\" class=\"headerlink\" title=\"polymorphicValue 两个结构体的例子\"></a>polymorphicValue 两个结构体的例子</h3><p>好的，以下是一个完整的例子：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Animal struct &#123;\n    gorm.Model\n    Name       string\n    Toy        Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:animal&quot;&#96;\n&#125;\n\ntype Toy struct &#123;\n    gorm.Model\n    Name       string\n    OwnerID    int\n    OwnerType  string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n    &#x2F;&#x2F; 自动迁移\n    db.AutoMigrate(&amp;Animal&#123;&#125;, &amp;Toy&#123;&#125;)\n\n    dog :&#x3D; Animal&#123;Name: &quot;Dog&quot;&#125;\n    db.Create(&amp;dog)\n    toy1 :&#x3D; Toy&#123;Name: &quot;Bone&quot;, OwnerID: int(dog.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy1)\n\n    cat :&#x3D; Animal&#123;Name: &quot;Cat&quot;&#125;\n    db.Create(&amp;cat)\n    toy2 :&#x3D; Toy&#123;Name: &quot;Mouse&quot;, OwnerID: int(cat.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy2)\n\n    var toys []Toy\n    db.Preload(&quot;Owner&quot;).Find(&amp;toys)\n\n    for _, toy :&#x3D; range toys &#123;\n        fmt.Printf(&quot;Toy name: %s, Owner name: %s\\n&quot;, toy.Name, toy.Owner.Name)\n    &#125;\n&#125;</code></pre>\n\n<p>这个例子中定义了两个 GORM 模型，Animal 和 Toy。Animal 模型中定义了一个 Toy 类型的字段，用于表示动物玩具的信息。在这个字段的 tag 中，使用了”polymorphic”标记来定义多态关联，并指定了”Owner”作为关联的字段名称。这样，当 Animal 模型与 Toy 模型关联时，GORM 将会将 Animal 的 ID 值赋值给 Toy 模型中的 OwnerID 字段，并将”animal”字符串赋值给 Toy 模型中的 OwnerType 字段。</p>\n<p>另外，在”polymorphic”标记的基础上，还使用了”polymorphicValue”标记来指定 OwnerType 字段中的值。具体来说，当 Animal 模型与 Toy 模型关联时，OwnerType 字段中的值将会被设置为”animal”。这个值用来表示动物玩具的所有者是一只动物。如果存在其他的所有者类型，例如”human”，那么它们的 OwnerType 值就可以分别设置为”human”。</p>\n<p>最终，在 main 函数中，我们使用 GORM 创建了两个 Animal 对象（分别代表一只狗和一只猫），并创建了两个 Toy 对象（分别代表狗和猫的玩具）。然后，我们使用 GORM 的 Preload 方法来加载 Toy 对象的 Owner 字段，以便在输出 Toy 信息时，能够同时输出它们的所有者信息。</p>\n<p>最终的输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Toy name: Bone, Owner name: Dog\nToy name: Mouse, Owner name: Cat</code></pre>\n\n<p>可以看到，程序成功地创建了 Animal 和 Toy 对象，并建立了它们之间的多态关联。同时，在输出 Toy 信息时，也成功地输出了它</p>\n<h3 id=\"polymorphicValue-三个结构体的例子\"><a href=\"#polymorphicValue-三个结构体的例子\" class=\"headerlink\" title=\"polymorphicValue 三个结构体的例子\"></a>polymorphicValue 三个结构体的例子</h3><p>如果需要实现三个结构体之间的多态关联，可以按照以下步骤进行操作：</p>\n<ol>\n<li>在 GORM 模型中定义多态关联的字段，例如定义一个 Owner 字段；</li>\n<li>在 Owner 字段的 tag 中，使用”polymorphic”标记来定义多态关联，并指定关联的字段名称，例如”Owner”；</li>\n<li>在 Owner 字段的 tag 中，使用”polymorphicValue”标记来指定 OwnerType 字段中的值；</li>\n<li>在其他两个模型中分别定义一个 HasMany 类型的字段，用于保存多态关联的信息；</li>\n<li>在其他两个模型的 HasMany 字段的 tag 中，使用”polymorphic”标记来定义多态关联，并指定关联的字段名称，例如”Owner”；</li>\n<li>在其他两个模型的 HasMany 字段的 tag 中，使用”polymorphicValue”标记来指定 OwnerType 字段中的值；</li>\n<li>在代码中创建和查询这三个模型时，根据需要使用 GORM 的 Preload 方法来加载关联信息。</li>\n</ol>\n<p>下面是一个具有三个模型之间多态关联的完整例子：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Animal struct &#123;\n    gorm.Model\n    Name       string\n    Toys       []Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:animal&quot;&#96;\n&#125;\n\ntype Human struct &#123;\n    gorm.Model\n    Name       string\n    Toys       []Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:human&quot;&#96;\n&#125;\n\ntype Toy struct &#123;\n    gorm.Model\n    Name       string\n    OwnerID    int\n    OwnerType  string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n    &#x2F;&#x2F; 自动迁移\n    db.AutoMigrate(&amp;Animal&#123;&#125;, &amp;Human&#123;&#125;, &amp;Toy&#123;&#125;)\n&#x2F;&#x2F; 创建-&gt;返回id-&gt;拼接toy数据-&gt;保存数据库\n    dog :&#x3D; Animal&#123;Name: &quot;Dog&quot;&#125;\n    db.Create(&amp;dog)\n    toy1 :&#x3D; Toy&#123;Name: &quot;Bone&quot;, OwnerID: int(dog.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy1)\n\n    cat :&#x3D; Animal&#123;Name: &quot;Cat&quot;&#125;\n    db.Create(&amp;cat)\n    toy2 :&#x3D; Toy&#123;Name: &quot;Mouse&quot;, OwnerID: int(cat.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy2)\n\n    person :&#x3D; Human&#123;Name: &quot;John&quot;&#125;\n    db.Create(&amp;person)\n    toy3 :&#x3D; Toy&#123;Name: &quot;Car&quot;, OwnerID: int(person.ID), OwnerType: &quot;human&quot;&#125;\n    db.Create(&amp;toy3)\n\n    var animals []Animal\n    db.Preload(&quot;Toys&quot;).Find(&amp;animals)\n    for _, animal :&#x3D; range animals &#123;\n        for _, toy :&#x3D; range animal.Toys &#123;\n            fmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, animal.Name, toy.Name)\n        &#125;\n    &#125;\n\n    var humans []Human\n    db.Preload(&quot;Toys&quot;).Find(&amp;humans)\n    for _, human :&#x3D; range humans &#123;\n        for _, toy :&#x3D; range human.Toys &#123;\n            fmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, human.Name, toy.Name)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>在这个例子中，我们定义了三个 GORM 模型：Animal、Human 和 Toy。其中 Animal 和 Human 模型都<br>具有多个 Toy，而 Toy 模型保存了所有的多态关联信息。Animal 和 Human 模型的 Toy 字段的 tag 中都使用了”polymorphic”标记来定义多态关联，并指定了 Owner 字段作为关联字段，同时使用了”polymorphicValue”标记来指定 OwnerType 字段的值。</p>\n<p>在代码中，我们创建了一些 Animal、Human 和 Toy 的实例，并使用 GORM 的 Create 方法将它们保存到数据库中。然后使用 GORM 的 Preload 方法来加载所有 Animal 和 Human 实例及它们的 Toy。</p>\n<p>最后，我们遍历加载的 Animal 和 Human 实例，并输出每个实例的名称以及它们的 Toy 的名称。注意，这里我们使用了嵌套循环来遍历 Animal 和 Human 的 Toys，这样就可以遍历所有的多态关联信息。</p>\n<p>当我们运行这个程序时，输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Dog&#39;s toy name: Bone\nCat&#39;s toy name: Mouse\nJohn&#39;s toy name: Car</code></pre>\n\n<p>这表明我们成功地实现了 Animal、Human 和 Toy 之间的多态关联。</p>\n<h3 id=\"简化后的代码-1\"><a href=\"#简化后的代码-1\" class=\"headerlink\" title=\"简化后的代码\"></a>简化后的代码</h3><p>好的，这里是一个简化后的示例代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Animal struct &#123;\n\tID   uint\n\tName string\n\tToy  Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:animal&quot;&#96;\n&#125;\n\ntype Human struct &#123;\n\tID   uint\n\tName string\n\tToy  Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:human&quot;&#96;\n&#125;\n\ntype Toy struct &#123;\n\tID        uint\n\tName      string\n\tOwnerID   uint\n\tOwnerType string\n&#125;\n\nfunc main() &#123;\n\tdb, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\tdb.AutoMigrate(&amp;Animal&#123;&#125;, &amp;Human&#123;&#125;, &amp;Toy&#123;&#125;)\n&#x2F;&#x2F; 这里直接将数据，完整化成一个Animal&#x2F;Human数据结构，创建时候，自动生成Toy数据\n\tdog :&#x3D; Animal&#123;Name: &quot;Dog&quot;, Toy: Toy&#123;Name: &quot;Bone&quot;&#125;&#125;\n\tcat :&#x3D; Animal&#123;Name: &quot;Cat&quot;, Toy: Toy&#123;Name: &quot;Mouse&quot;&#125;&#125;\n\tjohn :&#x3D; Human&#123;Name: &quot;John&quot;, Toy: Toy&#123;Name: &quot;Car&quot;&#125;&#125;\n\n\tdb.Create(&amp;dog)\n\tdb.Create(&amp;cat)\n\tdb.Create(&amp;john)\n\n\tvar animals []Animal\n\tdb.Preload(&quot;Toy&quot;).Find(&amp;animals)\n\n\tfor _, animal :&#x3D; range animals &#123;\n\t\tfmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, animal.Name, animal.Toy.Name)\n\t&#125;\n\n\tvar humans []Human\n\tdb.Preload(&quot;Toy&quot;).Find(&amp;humans)\n\n\tfor _, human :&#x3D; range humans &#123;\n\t\tfmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, human.Name, human.Toy.Name)\n\t&#125;\n&#125;</code></pre>\n\n<p>这个简化版本的代码与之前的示例类似，只是使用了 <code>uint</code> 类型的 ID，并将 Animal 和 Human 的 Toy 字段的类型都改为了 <code>Toy</code>。此外，这个版本还省略了模型定义和数据库表结构的信息，只包含了必要的字段和标记。</p>\n<p>这个简化版代码的运行结果与之前的示例相同：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Dog&#39;s toy name: Bone\nCat&#39;s toy name: Mouse\nJohn&#39;s toy name: Car</code></pre>\n\n<h3 id=\"自引用-Has-One-如何理解\"><a href=\"#自引用-Has-One-如何理解\" class=\"headerlink\" title=\"自引用 Has One 如何理解\"></a>自引用 Has One 如何理解</h3><p>自引用 Has One 是指在一个模型中定义一个与该模型自身相同类型的 Has One 关联关系。这种关联关系可以用来表示一个模型具有与之相关联的另一个模型，而该关联模型本身也具有与之相关联的另一个模型，因此形成了一个自我引用的关系。</p>\n<p>例如，我们可以考虑一个 Employee 模型，每个 Employee 模型都可能有一个 Manager 模型与之相关联。而每个 Manager 模型本身也可能有一个 Manager 模型与之相关联，因为一个 Manager 可能受另一个 Manager 管理。</p>\n<p>在 GORM 中，我们可以通过在模型中定义一个与该模型自身相同类型的 Has One 关联关系来实现自引用 Has One。我们可以使用 <code>foreignkey</code> 和 <code>references</code> 标记来指定关联关系的外键和引用的主键，以及使用 <code>polymorphic</code> 标记来支持多态关联。</p>\n<p>以下是一个 Employee 模型的示例代码，其中包括了一个与该模型自身相同类型的 Has One 关联关系：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Employee struct &#123;\n  ID         uint\n  Name       string\n  ManagerID  *uint\n  Manager    *Employee &#96;gorm:&quot;foreignKey:ManagerID;references:ID&quot;&#96;\n&#125;</code></pre>\n\n<p>在这个示例代码中，Employee 模型包含了一个 ManagerID 字段和一个指向 Manager 模型的指针类型的 Manager 字段。我们使用了 <code>foreignKey</code> 和 <code>references</code> 标记来指定 ManagerID 字段作为外键，并引用了 Employee 模型的 ID 主键。这样，每个 Employee 模型都可以与一个其他 Employee 模型相关联，形成自引用的 Has One 关联关系。</p>\n<p>当我们使用 GORM 创建和查询 Employee 模型时，GORM 会自动处理自引用 Has One 关联关系，并使用 JOIN 操作来加载相关联的 Manager 模型。</p>\n<p>例如，我们可以使用以下代码创建两个 Employee 模型，并将其中一个模型的 Manager 字段设置为另一个模型：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">db.Create(&amp;Employee&#123;Name: &quot;Alice&quot;&#125;)\ndb.Create(&amp;Employee&#123;Name: &quot;Bob&quot;, ManagerID: &amp;[]uint&#123;1&#125;[0]&#125;)</code></pre>\n\n<p>这个代码会将两个 Employee 模型保存到数据库中，其中一个模型的 Manager 字段会指向另一个模型。然后我们可以使用以下代码查询所有 Employee 模型，以及每个模型的名称和 Manager 名称：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var employees []Employee\ndb.Preload(&quot;Manager&quot;).Find(&amp;employees)\nfor _, employee :&#x3D; range employees &#123;\n  fmt.Printf(&quot;%s&#39;s manager: %v\\n&quot;, employee.Name, employee.Manager)\n&#125;</code></pre>\n\n<p>这个代码会输出以下内容：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Alice&#39;s manager: &lt;nil&gt;\nBob&#39;s manager: &amp;&#123;1 Alice 0xc000106320&#125;</code></pre>\n\n<p>这表明我们成功地创建了两个 Employee 模型，并将其中一个模型的 Manager 字段设置为另一个模型，从而实现了自引用 Has One 关联关系。</p>\n<h3 id=\"上面为什么使用指针类型\"><a href=\"#上面为什么使用指针类型\" class=\"headerlink\" title=\"上面为什么使用指针类型\"></a>上面为什么使用指针类型</h3><p>在 GORM 中，如果我们想要定义一个与该模型自身相同类型的关联关系，通常需要使用指针类型。这是因为在关联模型中，我们通常需要引用到该模型自身的实例，而如果使用非指针类型，会导致循环依赖和递归引用的问题，进而导致程序崩溃。</p>\n<p>在自引用 Has One 中，我们通常使用指针类型来定义模型的关联字段，以避免这些问题。例如，在 Employee 模型中，我们使用了 <code>ManagerID</code> 字段和 <code>Manager</code> 字段来表示每个员工的上级领导。<code>Manager</code> 字段的类型为 <code>*Employee</code>，这意味着它是一个指向另一个 Employee 实例的指针类型。</p>\n<p>通过使用指针类型，我们可以避免循环依赖和递归引用的问题，并让 GORM 能够正确地处理关联关系。当我们查询一个 Employee 实例时，GORM 会自动加载与之相关联的 Manager 实例，以及与之相关联的 Manager 实例的 Manager 实例，以此类推，直到所有的关联关系都被加载完毕。</p>\n<p>总之，在 GORM 中，为了避免循环依赖和递归引用的问题，并正确地处理与该模型自身相同类型的关联关系，我们通常需要使用指针类型来定义关联字段。这适用于所有类型的关联关系，包括自引用 Has One。</p>\n<h3 id=\"为什么指针引用可以避免-循环依赖和递归引用的问题\"><a href=\"#为什么指针引用可以避免-循环依赖和递归引用的问题\" class=\"headerlink\" title=\"为什么指针引用可以避免 循环依赖和递归引用的问题\"></a>为什么指针引用可以避免 循环依赖和递归引用的问题</h3><p>指针引用可以避免循环依赖和递归引用的问题，是因为指针允许我们将一个类型的实例作为另一个类型的属性引用，而不是直接包含该类型的实例。这种方式可以避免出现嵌套的实例，进而避免循环依赖和递归引用的问题。</p>\n<p>假设我们有两个结构体类型 <code>A</code> 和 <code>B</code>，它们都有一个属性字段 <code>a</code> 和 <code>b</code>，分别指向对方的实例。如果我们使用非指针类型定义这两个结构体，那么在编译时就会发生错误，因为定义中存在循环依赖：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type A struct &#123;\n    a B\n&#125;\n\ntype B struct &#123;\n    b A\n&#125;</code></pre>\n\n<p>相反，如果我们使用指针类型来定义这两个结构体，那么这个问题就可以得到解决：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type A struct &#123;\n    a *B\n&#125;\n\ntype B struct &#123;\n    b *A\n&#125;</code></pre>\n\n<p>这种方式下，<code>a</code> 和 <code>b</code> 不再是实例，而是指向另一个类型的实例的指针。这样，我们就可以避免出现嵌套的实例，进而避免循环依赖和递归引用的问题。</p>\n<p>在 GORM 中，我们使用指针类型来定义自引用 Has One 的关联字段，以避免这些问题。例如，在 <code>Employee</code> 模型中，我们使用 <code>ManagerID</code> 字段和 <code>Manager</code> 字段来表示每个员工的上级领导。<code>Manager</code> 字段的类型为 <code>*Employee</code>，这意味着它是一个指向另一个 <code>Employee</code> 实例的指针类型。通过使用指针类型，我们可以避免循环依赖和递归引用的问题，并让 GORM 能够正确地处理关联关系。</p>\n<h3 id=\"什么时候用指针类型，什么时候用实例\"><a href=\"#什么时候用指针类型，什么时候用实例\" class=\"headerlink\" title=\"什么时候用指针类型，什么时候用实例\"></a>什么时候用指针类型，什么时候用实例</h3><p>在定义 GORM 模型的时候，我们应该根据具体的情况选择使用指针类型或实例类型。</p>\n<p>通常情况下，我们使用指针类型来定义关联关系字段，以避免循环依赖和递归引用的问题，同时也可以更好地处理关联关系。例如，如果一个员工有一个上级领导，我们可以使用 <code>Manager</code> 字段来表示这个关系：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Employee struct &#123;\n    ID         uint\n    Name       string\n    ManagerID  uint\n    Manager    *Employee\n&#125;</code></pre>\n\n<p>在这个例子中，<code>Manager</code> 字段的类型为 <code>*Employee</code>，表示这是一个指向另一个 <code>Employee</code> 实例的指针类型。这样，我们可以避免循环依赖和递归引用的问题，同时也可以让 GORM 能够正确地处理关联关系。</p>\n<p>然而，在某些情况下，我们可能需要使用实例类型来定义关联关系字段。例如，如果我们需要表示一个关联到多个 <code>OrderItem</code> 的 <code>Order</code>，我们可以使用 <code>Items</code> 字段来表示这个关系：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Order struct &#123;\n    ID         uint\n    Name       string\n    Items      []OrderItem\n&#125;\n\ntype OrderItem struct &#123;\n    ID         uint\n    Name       string\n    OrderID    uint\n&#125;</code></pre>\n\n<p>在这个例子中，<code>Items</code> 字段的类型为 <code>[]OrderItem</code>，表示这是一个包含多个 <code>OrderItem</code> 实例的切片类型。由于一个 <code>Order</code> 可能关联到多个 <code>OrderItem</code>，所以我们需要使用实例类型来表示这个关系。</p>\n<p>总之，我们应该根据具体的情况选择使用指针类型或实例类型来定义 GORM 模型的关联关系字段。</p>\n<ol>\n<li>如果一个实例可能关联到多个实例，那么我们应该使用实例类型；</li>\n<li>如果一个实例只会关联到一个实例，或者存在循环依赖和递归引用的问题，那么我们应该使用指针类型。</li>\n</ol>\n<h3 id=\"指针和实例的区别\"><a href=\"#指针和实例的区别\" class=\"headerlink\" title=\"指针和实例的区别\"></a>指针和实例的区别</h3><p>在 GORM 模型中，指针和实例都可以用来表示模型之间的关联关系。</p>\n<ol>\n<li>指针通常用于表示一对一或一对多的关系，</li>\n<li>而实例通常用于表示多对一或多对多的关系。</li>\n</ol>\n<p>指针类型在 GORM 模型中的用法如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID    uint\n    Name  string\n    Email string\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Content  string\n    UserID   uint\n    User     *User &#x2F;&#x2F; 指向 User 实例的指针类型\n&#125;</code></pre>\n\n<p>在这个例子中，<code>Post</code> 模型包含一个指向 <code>User</code> 实例的指针类型字段 <code>User</code>，表示一个 <code>Post</code> 对象对应一个 <code>User</code> 对象。</p>\n<p>实例类型在 GORM 模型中的用法如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n    ID       uint\n    Name     string\n    Email    string\n    Articles []Article &#x2F;&#x2F; 包含多个 Article 实例的切片类型\n&#125;\n\ntype Article struct &#123;\n    ID        uint\n    Title     string\n    Content   string\n    UserID    uint\n    User      User &#x2F;&#x2F; 关联到 User 实例\n&#125;</code></pre>\n\n<p>在这个例子中，<code>User</code> 模型包含一个包含多个 <code>Article</code> 实例的切片类型字段 <code>Articles</code>，表示一个 <code>User</code> 对象关联到多个 <code>Article</code> 对象。而 <code>Article</code> 模型包含一个关联到 <code>User</code> 实例的实例类型字段 <code>User</code>，表示一个 <code>Article</code> 对象对应一个 <code>User</code> 对象。</p>\n<p>在使用指针和实例类型时，我们需要根据具体的场景来选择。通常来说，如果一个模型关联到多个实例，我们应该使用实例类型；如果一个模型只会关联到一个实例，或者存在循环依赖和递归引用的问题，我们应该使用指针类型。此外，我们还需要注意在使用指针类型时避免空指针错误的问题。</p>\n<h3 id=\"如何避免空指针错误\"><a href=\"#如何避免空指针错误\" class=\"headerlink\" title=\"如何避免空指针错误\"></a>如何避免空指针错误</h3><ol>\n<li>在创建模型实例时，为指针类型字段分配内存空间。</li>\n<li>在读取数据时，判断指针类型字段是否为空。</li>\n<li>在更新数据时，使用 <code>Update</code> 方法更新非空字段。</li>\n</ol>\n<p>在 GORM 模型中使用指针类型时，由于指针类型字段可能为空，所以需要注意避免空指针错误的问题。下面是一些避免空指针错误的建议：</p>\n<ol>\n<li>在创建模型实例时，为指针类型字段分配内存空间。</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">user :&#x3D; &amp;User&#123;Name: &quot;Alice&quot;&#125;\npost :&#x3D; &amp;Post&#123;Title: &quot;Hello&quot;, Content: &quot;World&quot;, User: user&#125;</code></pre>\n\n<p>在这个例子中，我们在创建 <code>post</code> 实例时为 <code>User</code> 字段分配了内存空间，避免了空指针错误的问题。</p>\n<ol start=\"2\">\n<li>在读取数据时，判断指针类型字段是否为空。</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var post Post\nif err :&#x3D; db.Preload(&quot;User&quot;).First(&amp;post, 1).Error; err !&#x3D; nil &#123;\n    if errors.Is(err, gorm.ErrRecordNotFound) &#123;\n        &#x2F;&#x2F; 处理记录不存在的情况\n    &#125; else &#123;\n        &#x2F;&#x2F; 处理其他错误\n    &#125;\n&#125; else &#123;\n    if post.User !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理 User 不为空的情况\n    &#125;\n&#125;</code></pre>\n\n<p>在这个例子中，我们在读取 <code>post</code> 实例时，使用 <code>Preload</code> 方法预加载 <code>User</code> 字段，然后在判断 <code>post.User</code> 是否为空时进行了特判，避免了空指针错误的问题。</p>\n<ol start=\"3\">\n<li>在更新数据时，使用 <code>Update</code> 方法更新非空字段。</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var post Post\nif err :&#x3D; db.First(&amp;post, 1).Error; err !&#x3D; nil &#123;\n    &#x2F;&#x2F; 处理错误\n&#125; else &#123;\n    if post.User !&#x3D; nil &#123;\n        if err :&#x3D; db.Model(&amp;post).Update(&quot;Title&quot;, &quot;New Title&quot;, &quot;User&quot;, post.User).Error; err !&#x3D; nil &#123;\n            &#x2F;&#x2F; 处理错误\n        &#125;\n    &#125; else &#123;\n        if err :&#x3D; db.Model(&amp;post).Update(&quot;Title&quot;, &quot;New Title&quot;).Error; err !&#x3D; nil &#123;\n            &#x2F;&#x2F; 处理错误\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>在这个例子中，我们在更新 <code>post</code> 实例时，先判断 <code>post.User</code> 是否为空，然后根据情况使用 <code>Update</code> 方法更新相应的字段，避免了空指针错误的问题。</p>\n<p>总的来说，避免空指针错误需要根据具体的场景进行处理，需要注意细节问题。</p>\n<h3 id=\"什么是外键约束，有什么用\"><a href=\"#什么是外键约束，有什么用\" class=\"headerlink\" title=\"什么是外键约束，有什么用\"></a>什么是外键约束，有什么用</h3><p>外键约束（Foreign Key Constraint）是一种数据库中的约束条件，用于保证表与表之间的数据完整性。</p>\n<p>具体来说，外键约束可以用于定义两个表之间的关系，使得一个表的某个字段值必须是另一个表的某个字段的值。这样，当我们在更新或删除一个表的记录时，数据库系统会自动检查该记录是否与其他表有关联，如果有，则会自动更新或删除其他表的相应记录，以保证数据完整性。</p>\n<p>例如，我们可以定义一个 <code>orders</code> 表和一个 <code>customers</code> 表，用于存储订单和客户信息。为了保证数据完整性，我们可以在 <code>orders</code> 表中定义一个外键约束，将 <code>customer_id</code> 字段作为外键，关联到 <code>customers</code> 表的 <code>id</code> 字段上。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE customers (\n    id INT PRIMARY KEY,\n    name VARCHAR(255)\n);\n\nCREATE TABLE orders (\n    id INT PRIMARY KEY,\n    customer_id INT,\n    order_date DATE,\n    FOREIGN KEY (customer_id) REFERENCES customers(id)\n);</code></pre>\n\n<p>在这个例子中，我们定义了一个 <code>orders</code> 表和一个 <code>customers</code> 表，其中 <code>orders</code> 表中的 <code>customer_id</code> 字段作为外键，关联到 <code>customers</code> 表的 <code>id</code> 字段上。</p>\n<p>这样，在插入或更新 <code>orders</code> 表的数据时，数据库系统会自动检查 <code>customer_id</code> 字段的值是否存在于 <code>customers</code> 表中，如果不存在，则会抛出错误。</p>\n<p>外键约束可以保证数据的完整性和一致性，<strong>但是在使用时需要注意几点</strong>：</p>\n<ol>\n<li><p>外键约束可能会降低数据库的性能，因为数据库系统需要进行额外的检查和操作。</p>\n</li>\n<li><p>外键约束可能会限制数据库的灵活性，因为数据库系统会强制执行特定的数据关系。</p>\n</li>\n<li><p>外键约束需要在设计数据库时谨慎使用，需要考虑业务需求和实际情况。</p>\n</li>\n</ol>\n<h3 id=\"gorm-外键约束有哪些，各有什么用，举例子说明\"><a href=\"#gorm-外键约束有哪些，各有什么用，举例子说明\" class=\"headerlink\" title=\"gorm 外键约束有哪些，各有什么用，举例子说明\"></a>gorm 外键约束有哪些，各有什么用，举例子说明</h3><p>GORM 中常用的外键约束有以下几种：</p>\n<ol>\n<li><p><code>ForeignKeyConstraint</code>：用于定义外键约束，并指定关联的表、字段以及操作。</p>\n</li>\n<li><p><code>OnDelete</code>：用于指定删除记录时的行为，包括 <code>CASCADE</code>（级联删除）、<code>SET NULL</code>（置空）等。</p>\n</li>\n<li><p><code>OnUpdate</code>：用于指定更新记录时的行为，包括 <code>CASCADE</code>（级联更新）、<code>SET NULL</code>（置空）等。</p>\n</li>\n</ol>\n<p>下面是各种外键约束的详细说明及示例：</p>\n<ol>\n<li><code>ForeignKeyConstraint</code>：用于定义外键约束，并指定关联的表、字段以及操作。例如：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Order struct &#123;\n    ID          int\n    CustomerID  int\n    Customer    Customer &#96;gorm:&quot;foreignKey:CustomerID;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;&quot;&#96;\n&#125;\n\ntype Customer struct &#123;\n    ID      int\n    Name    string\n&#125;</code></pre>\n\n<p>在这个例子中，我们定义了一个 <code>Order</code> 模型和一个 <code>Customer</code> 模型，其中 <code>Order</code> 模型中的 <code>CustomerID</code> 字段作为外键，关联到 <code>Customer</code> 模型的 <code>ID</code> 字段上。同时，我们使用 <code>gorm:&quot;foreignKey&quot;</code> 标签定义了外键约束，并指定了 <code>OnUpdate</code> 和 <code>OnDelete</code> 的行为。在这个例子中，当 <code>Customer</code> 表中的记录被更新时，与之关联的 <code>Order</code> 表中的 <code>CustomerID</code> 字段也会被更新，同时，当 <code>Customer</code> 表中的记录被删除时，与之关联的 <code>Order</code> 表中的 <code>CustomerID</code> 字段会被置空。</p>\n<ol start=\"2\">\n<li><code>OnDelete</code>：用于指定删除记录时的行为，包括 <code>CASCADE</code>（级联删除）、<code>SET NULL</code>（置空）等。例如：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Order struct &#123;\n    ID          int\n    CustomerID  int\n    Customer    Customer &#96;gorm:&quot;foreignKey:CustomerID;&quot;&#96;\n&#125;\n\ntype Customer struct &#123;\n    ID      int\n    Name    string\n&#125;\n\ndb.Model(&amp;Order&#123;&#125;).AddForeignKey(&quot;customer_id&quot;, &quot;customers(id)&quot;, &quot;SET NULL&quot;, &quot;CASCADE&quot;)</code></pre>\n\n<p>在这个例子中，我们使用 <code>AddForeignKey</code> 方法添加了一个外键约束，指定了删除记录时的行为为 <code>SET NULL</code>。这意味着，当 <code>customers</code> 表中的某个记录被删除时，与之关联的 <code>orders</code> 表中的 <code>customer_id</code> 字段会被置空。</p>\n<ol start=\"3\">\n<li><code>OnUpdate</code>：用于指定更新记录时的行为，包括 <code>CASCADE</code>（级联更新）、<code>SET NULL</code>（置空）等。例如：</li>\n</ol>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Order struct &#123;\n    ID          int\n    CustomerID  int\n    Customer    Customer &#96;gorm:&quot;foreignKey:CustomerID;&quot;&#96;\n&#125;\n\ntype Customer struct &#123;\n    ID      int\n    Name    string\n&#125;\n\ndb.Model(&amp;Order&#123;&#125;).AddForeignKey(&quot;customer_id&quot;, &quot;customers(id)&quot;, &quot;CASCADE&quot;, &quot;SET NULL&quot;)</code></pre>\n\n<p>在这个例子中，我们使用 <code>AddForeignKey</code> 方法添加了一个外键约束，指定了更新记录时的行为为 <code>CASCADE</code>。这 4. 外键约束 - RESTRICT</p>\n<p>当有一个外键约束指定为 RESTRICT 时，当主表中的某一行被删除或更新时，只有在从表中没有相应的引用时才能执行这个操作。如果在从表中有相应的引用，则会抛出一个错误。</p>\n<p>使用 RESTRICT 可以保证在主表中的某一行被删除或更新之前，需要确保在从表中没有相应的引用。这有助于保持数据的完整性。</p>\n<p>例如，我们有一个商店应用，其中有一个 product 表和一个 order 表，每个订单都需要引用产品表中的一个产品，我们可以在 order 表中创建一个外键，指向 product 表中的 id 字段，并将这个外键指定为 RESTRICT，这样就可以确保在删除或更新产品之前，所有订单都已经完成或取消。</p>\n<ol start=\"5\">\n<li>外键约束 - SET NULL</li>\n</ol>\n<p>当有一个外键约束指定为 SET NULL 时，当主表中的某一行被删除或更新时，所有从表中的相应外键都会被设置为 NULL。</p>\n<p>使用 SET NULL 可以保证在主表中的某一行被删除或更新之后，从表中的相应外键不再引用一个不存在的主键。</p>\n<p>例如，我们有一个博客应用，其中有一个 post 表和一个 comment 表，每个评论都需要引用 post 表中的一个文章，我们可以在 comment 表中创建一个外键，指向 post 表中的 id 字段，并将这个外键指定为 SET NULL，这样就可以确保在删除或更新文章之后，所有评论都不再引用一个不存在的文章。</p>\n<ol start=\"6\">\n<li>外键约束 - SET DEFAULT</li>\n</ol>\n<p>当有一个外键约束指定为 SET DEFAULT 时，当主表中的某一行被删除或更新时，所有从表中的相应外键都会被设置为默认值。</p>\n<p>使用 SET DEFAULT 可以保证在主表中的某一行被删除或更新之后，从表中的相应外键都有一个默认值。</p>\n<p>例如，我们有一个用户应用，其中有一个 user 表和一个 post 表，每个文章都需要引用 user 表中的一个用户，我们可以在 post 表中创建一个外键，指向 user 表中的 id 字段，并将这个外键指定为 SET DEFAULT，这样就可以确保在删除或更新用户之后，所有文章都有一个默认的用户。</p>\n<ol start=\"7\">\n<li>外键约束 - NO ACTION</li>\n</ol>\n<p>当有一个外键约束指定为 NO ACTION 时，当主表中的某一行被删除或更新时，所有从表中的相应外键不受影响。</p>\n<p>使用 NO ACTION 可以保证在主表中的某一行被删除或更新之后，从表中的相应外键不会受到影响。但是这也意味着可能会存在从表中的外键引用一个不存在的主键或者引用一个已经被更新或删除的主键。</p>\n<p>需要注意的是，使用</p>\n<p>在 GORM 中，还有一种外键约束是 <code>OnUpdate</code> 和 <code>OnDelete</code>，它们用于定义当关联的主表数据被修改或删除时，关联的从表数据应该如何处理。</p>\n<p>常见的几种处理方式如下：</p>\n<ul>\n<li><code>RESTRICT</code>：当关联的主表数据被修改或删除时，抛出一个错误，防止此操作发生。这是默认的行为。</li>\n<li><code>CASCADE</code>：当关联的主表数据被修改或删除时，同时修改或删除关联的从表数据。</li>\n<li><code>SET NULL</code>：当关联的主表数据被修改或删除时，将关联的从表数据的外键列设置为 NULL。</li>\n<li><code>NO ACTION</code>：与 <code>RESTRICT</code> 类似，不执行任何操作，但不会抛出错误。</li>\n</ul>\n<p>以下是一个示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type User struct &#123;\n  ID   int\n  Name string\n\n  &#x2F;&#x2F; 声明一个 has-many 关系，一个用户可以有多篇文章\n  Articles []Article &#96;gorm:&quot;foreignKey:UserID;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;&quot;&#96;\n&#125;\n\ntype Article struct &#123;\n  ID     int\n  Title  string\n  Body   string\n  UserID int     &#x2F;&#x2F; 声明一个外键，指向 User 的 ID 字段\n  User   *User   &#x2F;&#x2F; 声明一个 belongs-to 关系，一篇文章只能属于一个用户\n&#125;</code></pre>\n\n<p>在上述示例中，我们定义了一个 <code>has-many</code> 的关系，即一个用户可以有多篇文章，同时声明了 <code>OnUpdate:CASCADE,OnDelete:SET NULL</code> 外键约束。这意味着当用户被更新时，所有与之相关的文章的外键 <code>UserID</code> 将被更新为 <code>NULL</code>，当用户被删除时，与之相关的文章将被删除。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><p>需要注意的是，在 GORM v2.0 版本中，外键约束的声明方式发生了变化，使用 <code>constraint</code> 标签来声明，而不是之前的 <code>ForeignKey</code>。</p>\n</div>\n<h3 id=\"时间戳完整代码示例\"><a href=\"#时间戳完整代码示例\" class=\"headerlink\" title=\"时间戳完整代码示例\"></a>时间戳完整代码示例</h3><p>以下是一个完整的示例代码，展示如何使用 GORM 存储时间戳和将时间戳转换为 <code>time.Time</code> 对象，以及将 <code>time.Time</code> 对象转换为毫秒级别的 Unix 时间戳。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n\t&quot;gorm.io&#x2F;gorm&#x2F;logger&quot;\n)\n\ntype User struct &#123;\n\tID        uint\n\tName      string\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 初始化 GORM 连接\n\tdsn :&#x3D; &quot;test.db&quot;\n\tdb, err :&#x3D; gorm.Open(sqlite.Open(dsn), &amp;gorm.Config&#123;\n\t\tLogger: logger.Default.LogMode(logger.Info),\n\t&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; 迁移数据表结构\n\tdb.AutoMigrate(&amp;User&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建新用户\n\tuser :&#x3D; User&#123;Name: &quot;John Doe&quot;&#125;\n\tdb.Create(&amp;user)\n\n\t&#x2F;&#x2F; 查询用户\n\tvar savedUser User\n\tdb.First(&amp;savedUser, user.ID)\n\n\t&#x2F;&#x2F; 输出时间戳和时间对象\n\tfmt.Printf(&quot;User %d was created at time %v and updated at time %v\\n&quot;, savedUser.ID, savedUser.CreatedAt, savedUser.UpdatedAt)\n\n\t&#x2F;&#x2F; 输出时间戳（秒级别）\n\tfmt.Printf(&quot;User %d was created at timestamp %d and updated at timestamp %d\\n&quot;, savedUser.ID, savedUser.CreatedAt.Unix(), savedUser.UpdatedAt.Unix())\n\n\t&#x2F;&#x2F; 输出时间戳（毫秒级别）\n\tfmt.Printf(&quot;User %d was created at timestamp %d and updated at timestamp %d\\n&quot;, savedUser.ID, savedUser.CreatedAt.UnixMilli(), savedUser.UpdatedAt.UnixMilli())\n&#125;</code></pre>\n\n<p>这个例子中，我们定义了一个 <code>User</code> 结构体，其中包含 <code>CreatedAt</code> 和 <code>UpdatedAt</code> 两个字段，它们的类型均为 <code>time.Time</code>。在使用 GORM 操作这个结构体时，GORM 会自动将这些字段转换为数据库中的时间戳格式进行存储，而在查询时，GORM 也会自动将数据库中的时间戳转换为 <code>time.Time</code> 对象。</p>\n<p>在上面的例子中，我们创建了一个新用户，并将其保存到数据库中。然后我们使用 <code>First()</code> 方法查询数据库中保存的用户，并输出其创建时间和更新时间。接着我们使用 <code>Unix()</code> 和 <code>UnixMilli()</code> 方法分别将时间对象转换为秒级别和毫秒级别的 Unix 时间戳，并输出它们的值。</p>\n<p>这里需要注意的是，在将 <code>time.Time</code> 对象转换为 Unix 时间戳时，需要使用 <code>Unix()</code> 或 <code>UnixMilli()</code> 方法。其中，<code>Unix()</code> 方法返回的是秒级别的 Unix 时间戳，而 <code>UnixMilli()</code> 方法返回的是毫秒级别的 Unix 时间戳。</p>\n<h3 id=\"上述代码表结构和结果\"><a href=\"#上述代码表结构和结果\" class=\"headerlink\" title=\"上述代码表结构和结果\"></a>上述代码表结构和结果</h3><p>表结构：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;users&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) NOT NULL,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci</code></pre>\n\n<p>结果：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">[&#123;1 John 1641062400000 1641062400000&#125; &#123;2 Jane 1641066000000 1641066000000&#125;]</code></pre>\n\n<p>其中，第一个用户的 <code>created_at</code> 和 <code>updated_at</code> 时间戳分别为 1641062400000（2022-01-02 00:00:00）和 1641062400000（2022-01-02 00:00:00），第二个用户的 <code>created_at</code> 和 <code>updated_at</code> 时间戳分别为 1641066000000（2022-01-02 01:00:00）和 1641066000000（2022-01-02 01:00:00）。</p>\n<h3 id=\"clause-Associations\"><a href=\"#clause-Associations\" class=\"headerlink\" title=\"clause.Associations\"></a>clause.Associations</h3><p>下面是一个使用 <code>clause.Associations</code> 的完整示例，用于加载 <code>User</code> 对象及其关联的 <code>Order</code> 和 <code>OrderItem</code> 对象：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;gorm.io&#x2F;gorm&#x2F;clause&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Orders []Order &#96;gorm:&quot;foreignKey:UserID&quot;&#96;\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID     uint\n    OrderItems []OrderItem &#96;gorm:&quot;foreignKey:OrderID&quot;&#96;\n&#125;\n\ntype OrderItem struct &#123;\n    gorm.Model\n    OrderID     uint\n    ProductName string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 创建 SQLite 数据库连接\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移数据库表结构\n    err &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;, &amp;OrderItem&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 创建测试数据\n    orderItems :&#x3D; []OrderItem&#123;\n        &#123;ProductName: &quot;Product A&quot;&#125;,\n        &#123;ProductName: &quot;Product B&quot;&#125;,\n    &#125;\n    orders :&#x3D; []Order&#123;\n        &#123;OrderItems: orderItems&#125;,\n        &#123;OrderItems: orderItems&#125;,\n    &#125;\n    users :&#x3D; []User&#123;\n        &#123;Name: &quot;User A&quot;, Orders: orders&#125;,\n        &#123;Name: &quot;User B&quot;, Orders: orders&#125;,\n    &#125;\n    err &#x3D; db.Create(&amp;users).Error\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 查询所有用户及其关联的订单和订单项\n    var loadedUsers []User\n    err &#x3D; db.Preload(clause.Associations).Find(&amp;loadedUsers).Error\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 打印查询结果\n    for _, user :&#x3D; range loadedUsers &#123;\n        println(&quot;User:&quot;, user.ID, user.Name)\n        for _, order :&#x3D; range user.Orders &#123;\n            println(&quot;\\tOrder:&quot;, order.ID, order.UserID)\n            for _, orderItem :&#x3D; range order.OrderItems &#123;\n                println(&quot;\\t\\tOrderItem:&quot;, orderItem.ID, orderItem.OrderID, orderItem.ProductName)\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>在上述示例中，我们创建了一个 <code>User</code> 模型和一个 <code>Order</code> 模型，<code>Order</code> 模型有多个 <code>OrderItem</code> 模型。我们在 <code>User</code> 模型上定义了一个 <code>Orders</code> 字段，它表示一个用户可能有多个订单，而在 <code>Order</code> 模型上定义了一个 <code>OrderItems</code> 字段，它表示一个订单可能包含多个订单项。</p>\n<p>我们通过 <code>db.Preload(clause.Associations)</code> 来加载所有关联的订单和订单项。在查询结果中，我们可以看到每个用户及其关联的订单和订单项。</p>\n<h3 id=\"clause-Associations-还是没有理解\"><a href=\"#clause-Associations-还是没有理解\" class=\"headerlink\" title=\"clause.Associations 还是没有理解\"></a>clause.Associations 还是没有理解</h3><p><code>clause.Associations</code> 实际上是一个 <code>gorm.Associations</code> 类型的常量，用于指示预加载操作要预加载哪些关联关系。</p>\n<p>在 GORM 中，一个模型可以与其他模型建立多种关联关系，例如一对多、多对多、多态等等。当我们查询一个模型时，通常也需要把相关联的模型数据一起查询出来，这就需要用到预加载功能。</p>\n<p>在使用预加载功能时，我们可以使用 <code>Preload</code> 方法来指定要预加载哪些关联关系。<code>clause.Associations</code> 就是其中一种指定方式。</p>\n<p>当我们使用 <code>db.Preload(clause.Associations).Find(&amp;users)</code> 方法时，GORM 会自动解析 <code>User</code> 模型定义中的所有关联关系，并将其包装在一个 <code>gorm.Associations</code> 类型的列表中，然后将这个列表传递给 <code>Preload</code> 方法。</p>\n<p>使用 <code>clause.Associations</code> 的好处是，它能够避免手动编写字符串形式的关联关系名称，从而减少人为出错的可能性。另外，当模型的关联关系发生变化时，使用 <code>clause.Associations</code> 可以自动地更新预加载的关联关系，而不需要手动修改代码。</p>\n<h3 id=\"Embedded-Preloading\"><a href=\"#Embedded-Preloading\" class=\"headerlink\" title=\"Embedded Preloading\"></a>Embedded Preloading</h3><p>以下是一个使用 Embedded Preloading 的完整代码示例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;gorm.io&#x2F;gorm&#x2F;clause&quot;\n    &quot;time&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Orders []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID     uint\n    OrderItems []OrderItem\n&#125;\n\ntype OrderItem struct &#123;\n    gorm.Model\n    OrderID     uint\n    ProductName string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;, &amp;OrderItem&#123;&#125;)\n\n    user1 :&#x3D; User&#123;\n        Name: &quot;Alice&quot;,\n        Orders: []Order&#123;\n            &#123;\n                OrderItems: []OrderItem&#123;\n                    &#123;\n                        ProductName: &quot;Product A&quot;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n    &#125;\n\n    user2 :&#x3D; User&#123;\n        Name: &quot;Bob&quot;,\n        Orders: []Order&#123;\n            &#123;\n                OrderItems: []OrderItem&#123;\n                    &#123;\n                        ProductName: &quot;Product B&quot;,\n                    &#125;,\n                    &#123;\n                        ProductName: &quot;Product C&quot;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n    &#125;\n\n    db.Create(&amp;user1)\n    db.Create(&amp;user2)\n\n    var users []User\n    db.Preload(clause.Associations).Find(&amp;users)\n\n    for _, user :&#x3D; range users &#123;\n        println(&quot;User ID:&quot;, user.ID)\n        println(&quot;User Name:&quot;, user.Name)\n        for _, order :&#x3D; range user.Orders &#123;\n            println(&quot;  Order ID:&quot;, order.ID)\n            println(&quot;  Order User ID:&quot;, order.UserID)\n            for _, orderItem :&#x3D; range order.OrderItems &#123;\n                println(&quot;    OrderItem ID:&quot;, orderItem.ID)\n                println(&quot;    OrderItem ProductName:&quot;, orderItem.ProductName)\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>该示例中使用 Embedded Preloading 预加载了 User、Order 和 OrderItem 三个模型的关联数据。最终输出了所有 User、Order 和 OrderItem 的详细信息。</p>\n<p>在代码中，通过 <code>db.Preload(clause.Associations).Find(&amp;users)</code> 对 User、Order 和 OrderItem 三个模型进行了 Embedded Preloading 预加载。这意味着，对于 User、Order 和 OrderItem 三个模型，它们的关联数据都会在一次查询中一次性加载出来。这样可以避免 N + 1 查询问题，提高查询效率。</p>\n<p>注意，在进行 Embedded Preloading 预加载时，需要使用 <code>clause.Associations</code> 这个关键字，这样才能正确地指定 Embedded Preloading 操作。</p>\n<h3 id=\"for-range-实现原理\"><a href=\"#for-range-实现原理\" class=\"headerlink\" title=\"for range 实现原理\"></a>for range 实现原理</h3><p><code>for range</code> 是 Go 语言中的一个迭代器语法，通常用于迭代数组、切片、映射和管道等集合类型。它的使用方法类似于 <code>foreach</code> 循环，可以遍历集合中的所有元素。</p>\n<p><code>for range</code> 的实现原理是根据集合的类型来调用不同的迭代器函数，这些函数会返回一个包含当前元素信息的 <code>value</code> 和一个指示迭代是否结束的 <code>ok</code> 值。迭代器函数根据集合的类型可以是以下几种：</p>\n<ul>\n<li>数组和切片：返回元素索引和值。</li>\n<li>映射：返回键和值。</li>\n<li>字符串：返回字符的索引和值。</li>\n<li>管道：返回管道中的值。</li>\n</ul>\n<p>在 <code>for range</code> 循环中，会通过调用集合的迭代器函数获取当前元素的 <code>value</code> 和 <code>ok</code> 值，然后判断 <code>ok</code> 值是否为 <code>true</code>。如果为 <code>true</code>，则表示迭代器还有元素需要遍历，将 <code>value</code> 赋值给循环变量；否则，表示迭代器已经遍历完所有元素，退出循环。</p>\n<p>需要注意的是，如果在迭代过程中修改了集合中的元素，则会导致迭代器失效，可能会引发不可预知的结果。因此，不建议在 <code>for range</code> 循环中修改集合的元素。</p>\n<p>以下是一个简单的例子，演示了如何使用 <code>for range</code> 循环遍历切片：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    nums :&#x3D; []int&#123;1, 2, 3, 4, 5&#125;\n    for index, value :&#x3D; range nums &#123;\n        fmt.Printf(&quot;index: %d, value: %d\\n&quot;, index, value)\n    &#125;\n&#125;</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">index: 0, value: 1\nindex: 1, value: 2\nindex: 2, value: 3\nindex: 3, value: 4\nindex: 4, value: 5</code></pre>\n\n<h3 id=\"for-range-原理-x2F-源码\"><a href=\"#for-range-原理-x2F-源码\" class=\"headerlink\" title=\"for range 原理&#x2F;源码\"></a>for range 原理&#x2F;源码</h3><p>for range 循环在 Go 语言中的实现是通过 <code>range</code> 关键字和具体类型的方法来实现的。<code>range</code> 关键字本身并不是一个迭代器，而是会自动在背后调用一个包含了迭代器逻辑的方法。</p>\n<p>对于数组、切片、字符串等内置类型，<code>range</code> 会自动调用 <code>range</code> 相应的方法来实现迭代。</p>\n<p>下面是 <code>range</code> 的源码实现，以数组为例：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">for index, element :&#x3D; range array &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>相当于编译器会转换为以下代码：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">for i :&#x3D; 0; i &lt; len(array); i++ &#123;\n    index :&#x3D; i\n    element :&#x3D; array[i]\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>可以看到，编译器会在背后自动生成循环逻辑，包括从 0 到 <code>len(array)</code> 的循环变量 <code>i</code>，以及在每次循环中自动获取当前的索引和元素值。</p>\n<p>对于自定义类型，需要实现 <code>range</code> 方法才能支持 <code>for range</code> 循环。具体来说，需要实现以下接口：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Iterable interface &#123;\n    Iterator() Iterator\n&#125;\n\ntype Iterator interface &#123;\n    Next() bool\n    Value() interface&#123;&#125;\n&#125;</code></pre>\n\n<p>其中，<code>Iterable</code> 接口定义了获取迭代器的方法 <code>Iterator()</code>，而 <code>Iterator</code> 接口定义了每次迭代的方法 <code>Next()</code> 和获取当前值的方法 <code>Value()</code>。当然，<code>Value()</code> 方法返回的类型可以是任意类型，只要在使用时能够转换为对应的目标类型即可。</p>\n<p>以下是一个自定义类型的例子：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Person struct &#123;\n    Name string\n    Age  int\n&#125;\n\ntype People []Person\n\nfunc (p People) Iterator() Iterator &#123;\n    return &amp;peopleIterator&#123;p, -1&#125;\n&#125;\n\ntype peopleIterator struct &#123;\n    people People\n    index  int\n&#125;\n\nfunc (pi *peopleIterator) Next() bool &#123;\n    pi.index++\n    return pi.index &lt; len(pi.people)\n&#125;\n\nfunc (pi *peopleIterator) Value() interface&#123;&#125; &#123;\n    return pi.people[pi.index]\n&#125;</code></pre>\n\n<ol>\n<li>这里定义了 <code>Person</code> 和 <code>People</code> 两个类型，</li>\n<li>其中 <code>People</code> 是一个包含多个 <code>Person</code> 的切片，实现了 <code>Iterable</code> 接口。</li>\n<li>当 <code>People</code> 被用于 <code>for range</code> 循环时，会自动调用 <code>Iterable</code> 接口中的 <code>Iterator()</code> 方法来获取迭代器，</li>\n<li>然后在背后自动调用 <code>Iterator</code> 接口中的 <code>Next()</code> 和 <code>Value()</code> 方法来实现迭代。</li>\n</ol>\n<p>在上述例子中，</p>\n<ol>\n<li><code>Next()</code> 方法会自增索引并判断是否已经到达切片的末尾，</li>\n<li>而 <code>Value()</code> 方法则返回当前索引的元素值。</li>\n</ol>\n<p>由于切片中的元素类型是 <code>Person</code>，因此需要在调用 <code>Value()</code> 方法后将返回值转换为 <code>Person</code> 类型，以便在循环中使用。</p>\n<h3 id=\"Embedded-Preloading-如何理解？\"><a href=\"#Embedded-Preloading-如何理解？\" class=\"headerlink\" title=\"Embedded Preloading 如何理解？\"></a>Embedded Preloading 如何理解？</h3><p><strong>使用限制：被预加载项需要唯一，能够互相区分</strong></p>\n<p>Embedded Preloading 只适用于 belongs to 关系（即属于关系），因为在数据库中，其他关系的值是相同的，我们无法区分它们。</p>\n<p>举个例子，假设我们有两个表：</p>\n<p>user 和 order，它们的关系是一对多，即一个用户可以拥有多个订单。如果我们想要预加载订单，并将它们嵌入到用户结构体中，我们可以使用 Embedded Preloading。</p>\n<p>但是，如果我们还有一个表 product，和 order 的关系也是一对多，即一个订单可以包含多个商品。</p>\n<p>此时，如果我们想要将商品预加载，并将它们嵌入到订单结构体中，使用 Embedded Preloading 就不适用了，因为在数据库中，不同的订单可能拥有相同的商品，我们无法区分它们，所以需要使用普通的 Preloading。</p>\n<h3 id=\"如果-product，和-order-的关系-也使用-Embedded-Preloading-会怎样\"><a href=\"#如果-product，和-order-的关系-也使用-Embedded-Preloading-会怎样\" class=\"headerlink\" title=\"如果 product，和 order 的关系 也使用 Embedded Preloading 会怎样\"></a>如果 product，和 order 的关系 也使用 Embedded Preloading 会怎样</h3><p>如果 <code>product</code> 和 <code>order</code> 之间的关系也使用 <code>Embedded Preloading</code>，则会出现类似于 <code>order_items</code> 的情况，即 <code>product_id</code> 和 <code>order_id</code> 无法区分，从而导致查询结果不准确。因此，在使用 <code>Embedded Preloading</code> 时，需要根据实际情况选择需要预加载的关系，避免出现这种问题。</p>\n<h3 id=\"看不懂，举例说明\"><a href=\"#看不懂，举例说明\" class=\"headerlink\" title=\"看不懂，举例说明\"></a>看不懂，举例说明</h3><p>好的，下面举一个简单的例子来说明 Embedded Preloading 只适用于属于关系。</p>\n<p>假设有以下两个模型：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Product struct &#123;\n    gorm.Model\n    Name string\n    Price float64\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    Products []Product\n&#125;</code></pre>\n\n<p>在这个例子中，<code>Order</code> 模型有多个 <code>Product</code> 模型。</p>\n<p>如果使用 Embedded Preloading 来预加载 <code>Products</code>，我们将无法在数据库中区分哪个 <code>Product</code> 属于哪个 <code>Order</code>，因为所有 <code>Product</code> 的 <code>OrderID</code> 值都是相同的，这是无效的。</p>\n<p>因此，Embedded Preloading 仅适用于属于关系，例如 <code>Order</code> 属于 <code>User</code>，但是 <code>Product</code> 不属于 <code>Order</code>。</p>\n<h3 id=\"db-Table-“users”-Select-“COALESCE-age-”-42-Rows-什么意思\"><a href=\"#db-Table-“users”-Select-“COALESCE-age-”-42-Rows-什么意思\" class=\"headerlink\" title=\"db.Table(“users”).Select(“COALESCE(age,?)”, 42).Rows() 什么意思\"></a>db.Table(“users”).Select(“COALESCE(age,?)”, 42).Rows() 什么意思</h3><p>这段代码使用了 GORM 的 Raw SQL 功能。<code>db.Table(&quot;users&quot;)</code> 用于指定查询的表，<code>.Select(&quot;COALESCE(age,?)&quot;, 42)</code> 用于执行 SQL 的 SELECT 语句，并将结果以行的形式返回。</p>\n<p>具体来说，这条 SQL 语句中的 <code>COALESCE(age,?)</code> 是一个函数，表示如果 <code>age</code> 不为 NULL，则返回 <code>age</code> 的值，否则返回 <code>?</code> 的值（即 42）。因此，这个查询将返回所有用户的行，但如果某个用户的 <code>age</code> 字段为 NULL，则该字段的值将被替换为 42。</p>\n<p>最后的 <code>.Rows()</code> 用于返回查询结果的行集。</p>\n<h3 id=\"COALESCE-是什么\"><a href=\"#COALESCE-是什么\" class=\"headerlink\" title=\"COALESCE 是什么\"></a>COALESCE 是什么</h3><p><code>COALESCE</code> 是一个 SQL 函数，用于返回一组表达式中的第一个非空表达式的值。如果所有表达式的值都为 NULL，则返回 NULL。</p>\n<p>例如，假设有以下表格：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Tom</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Jerry</td>\n<td>20</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Mike</td>\n<td>25</td>\n</tr>\n</tbody></table>\n<p>如果执行以下 SQL 查询：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT COALESCE(age, 18) AS age FROM table_name;</code></pre>\n\n<p>则会得到以下结果：</p>\n<table>\n<thead>\n<tr>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>18</td>\n</tr>\n<tr>\n<td>20</td>\n</tr>\n<tr>\n<td>25</td>\n</tr>\n</tbody></table>\n<p>即如果 age 字段是 NULL，则返回默认值 18，否则返回 age 字段的值。</p>\n<h3 id=\"sql\"><a href=\"#sql\" class=\"headerlink\" title=\"sql\"></a>sql</h3><p>db.Joins(“JOIN emails ON emails.user_id &#x3D; users.id AND emails.email &#x3D; ?”, “<a href=\"mailto:&#x6a;&#x69;&#110;&#122;&#x68;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x6f;&#x72;&#103;\">&#x6a;&#x69;&#110;&#122;&#x68;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x6f;&#x72;&#103;</a>“).Joins(“JOIN credit_cards ON credit_cards.user_id &#x3D; users.id”).Where(“credit_cards.number &#x3D; ?”, “411111111111”).Find(&amp;user)</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT * FROM users\n  JOIN emails ON emails.user_id &#x3D; users.id AND emails.email &#x3D; &#39;jinzhu@example.org&#39;\n  JOIN credit_cards ON credit_cards.user_id &#x3D; users.id WHERE credit_cards.number &#x3D; &#39;411111111111&#39;\n\n\n</code></pre>\n\n<h3 id=\"Distinct-works-with-Pluck-and-Count-too-的例子\"><a href=\"#Distinct-works-with-Pluck-and-Count-too-的例子\" class=\"headerlink\" title=\"Distinct works with Pluck and Count too 的例子\"></a>Distinct works with Pluck and Count too 的例子</h3><p>假设我们有一个 <code>User</code> 模型，其中包含 <code>Name</code> 和 <code>Age</code> 字段，并且有多个用户具有相同的姓名，但不同的年龄。我们想要找出唯一的姓名列表。我们可以使用 <code>Distinct</code> 方法来执行此操作：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var names []string\ndb.Distinct(&quot;name&quot;).Order(&quot;name asc&quot;).Find(&amp;users).Pluck(&quot;name&quot;, &amp;names)</code></pre>\n\n<p>此代码将按升序顺序返回所有唯一的姓名列表。如果我们想知道有多少个唯一的姓名，则可以使用 <code>Count</code> 方法：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var count int64\ndb.Distinct(&quot;name&quot;).Count(&amp;count)</code></pre>\n\n<p>类似地，如果我们想要在计算唯一值之前应用其他条件，我们可以在 <code>Distinct</code> 方法之前使用 <code>Where</code>、<code>Joins</code> 和 <code>Group</code> 等方法。</p>\n<h3 id=\"Find-、Scan-和-Rows\"><a href=\"#Find-、Scan-和-Rows\" class=\"headerlink\" title=\"Find 、Scan 和 Rows\"></a>Find 、Scan 和 Rows</h3><p>Scan 方法 1. 将结果扫描到结构中的工作方式与我们使用 Find 的方式类似 2. Scan 至少要求接受数据的类型是 slice 或 struct 及它们的指针类型。</p>\n<p>Rows 方法 是执行 SQL 查询，并返回一个指向结果集的行迭代器</p>\n<h3 id=\"Rows-方法为什么需要-defer-close\"><a href=\"#Rows-方法为什么需要-defer-close\" class=\"headerlink\" title=\".Rows() 方法为什么需要 defer close\"></a>.Rows() 方法为什么需要 defer close</h3><p>在使用 <code>Rows()</code> 方法时，GORM 会返回一个 <code>*sql.Rows</code> 对象，这个对象代表了查询返回的结果集，需要通过调用 <code>Next()</code> 方法迭代每一行数据，并通过调用 <code>Scan()</code> 方法将行数据扫描到相应的结构体字段中。</p>\n<p>当查询结束后，必须调用 <code>Rows()</code> 方法返回的结果集对象的 <code>Close()</code> 方法来释放相关的资源。如果不及时释放这些资源，可能会导致内存泄漏或数据库连接池耗尽等问题。</p>\n<p>为了确保 <code>Close()</code> 方法得到及时调用，GORM 的 <code>Rows()</code> 方法在返回结果集对象时会将其包装在一个 <code>sql.RowsWrapper</code> 结构体中，并将该结构体返回给调用方。这个结构体实现了 <code>io.Closer</code> 接口，并在 <code>Close()</code> 方法中调用了原始结果集对象的 <code>Close()</code> 方法。</p>\n<p>由于 <code>sql.RowsWrapper</code> 实现了 <code>io.Closer</code> 接口，因此可以通过使用 <code>defer</code> 关键字在函数退出时自动调用 <code>Close()</code> 方法，从而避免忘记释放资源的问题。</p>\n","text":"gormgorm 中文文档 golang gorm 有哪些 APIGolang 的 ORM 库 GORM 是一个流行的数据库操作库，提供了丰富的 API 用于进行数据库操作。以下是 GORM 库的一些常用 API： 创建连接： db, err :&#x3D; gorm.Open(...","link":"","photos":[],"count_time":{"symbolsCount":"120k","symbolsTime":"1:49"},"categories":[{"name":"Gorm","slug":"Gorm","count":1,"path":"api/categories/Gorm.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"},{"name":"Gorm","slug":"Gorm","count":1,"path":"api/tags/Gorm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm\"><span class=\"toc-text\">gorm</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#golang-gorm-%E6%9C%89%E5%93%AA%E4%BA%9B-API\"><span class=\"toc-text\">golang gorm 有哪些 API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%AF%B9%E4%B8%80\"><span class=\"toc-text\">一对一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#belongto-%E4%B8%8E-hasone-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">belongto 与 hasone 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-BelongsTo-%E5%92%8C-HasOne-%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">gorm BelongsTo 和 HasOne 的适用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E8%80%85%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">两者在数据库数据查询返回有什么不同</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#User-BelongsTo-Profile\"><span class=\"toc-text\">User BelongsTo Profile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#User-HasOne-Profile\"><span class=\"toc-text\">User HasOne Profile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BelongsTo-%E5%BB%BA%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">BelongsTo 建表的结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">查询的结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sqlite-%E5%AE%8C%E6%95%B4%E4%BA%8B%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">sqlite 完整事例代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-mysql-%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81%E6%80%8E%E4%B9%88%E5%86%99\"><span class=\"toc-text\">使用 mysql 作为数据库的代码怎么写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%8A%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">上述代码的表结构，及建表语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">gorm 注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-%E6%9C%89%E5%93%AA%E4%BA%9B-tag\"><span class=\"toc-text\">gorm 有哪些 tag</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#db-Table\"><span class=\"toc-text\">db.Table</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#FirstOrInit-x2F-FirstOrCreate\"><span class=\"toc-text\">FirstOrInit&#x2F;FirstOrCreate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E5%80%BC%E5%A4%84%E7%90%86\"><span class=\"toc-text\">零值处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-dryrun\"><span class=\"toc-text\">gorm dryrun</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">安全</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5\"><span class=\"toc-text\">验证用户输入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gin-%E9%98%B2-sql-%E6%B3%A8%E5%85%A5%E6%A0%A1%E9%AA%8C\"><span class=\"toc-text\">gin 防 sql 注入校验</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-%E5%A4%9A%E6%80%81%E3%80%90%E6%88%91%E8%A7%89%E5%BE%97%EF%BC%9A%E5%B0%B1%E7%AE%97%E4%B8%8D%E6%99%93%E5%BE%97%E6%89%80%E8%B0%93%E7%9A%84%E5%A4%9A%E6%80%81%EF%BC%8C%E6%88%91%E4%B9%9F%E4%B8%8D%E5%8F%AF%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%87%BA%E5%90%8E%E9%9D%A2%E9%82%A3%E7%A7%8D%E8%A1%A8%E3%80%91\"><span class=\"toc-text\">gorm 多态【我觉得：就算不晓得所谓的多态，我也不可能设计出后面那种表】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-%E5%A4%9A%E6%80%81%E4%B8%8E%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E7%9C%8B%E4%B8%8A%E5%8E%BB%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">gorm 多态与不使用多态看上去没有什么区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#polymorphicValue\"><span class=\"toc-text\">polymorphicValue</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%97%E5%88%B0%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">得到的表结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">插入数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%B3%E6%AD%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">至此数据库数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CommentableType-%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84\"><span class=\"toc-text\">CommentableType 是从哪里获取到的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-has-many-%E8%87%AA%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">gorm has many 自引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A5%E4%B8%8A%E7%A4%BA%E4%BE%8B%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">以上示例查询结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-Preload-API-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">gorm .Preload() API 的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#N-1-%E9%97%AE%E9%A2%98-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">N+1 问题 是什么意思</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#many2many\"><span class=\"toc-text\">many2many</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E4%B8%8B-%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">解释下 如下代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">上述代码执行后的建表语句是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7\"><span class=\"toc-text\">上述代码的增删改查完整代码是什么样</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#joinForeignKey-%E5%92%8C-joinReferences-%E5%90%84%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">joinForeignKey 和 joinReferences 各是什么作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#foreignKey-%E5%92%8C-References-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">foreignKey 和 References 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%A7%92%E8%89%B2%EF%BC%8C%E6%AF%8F%E4%B8%AA%E8%A7%92%E8%89%B2%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%9D%83%E9%99%90\"><span class=\"toc-text\">gorm 设计一个用户可以有多个角色，每个角色可以有多个权限</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">表结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AB%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">含增删改查的完整代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8C%96%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">简化后的代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%AE%80%E5%8C%96%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">进一步简化后的代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%B8%AD-Permission-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">上述代码中 []*Permission 什么意思</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%B8%AD-%E6%9B%B4%E6%96%B0%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-Association\"><span class=\"toc-text\">上述代码中 更新用户角色信息，为什么用 Association</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%8A%E5%8E%9F%E6%9C%89%E7%9A%84%E8%A7%92%E8%89%B2%E5%88%97%E8%A1%A8%E6%B8%85%E7%A9%BA%EF%BC%8C%E7%84%B6%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E8%A7%92%E8%89%B2%E5%88%97%E8%A1%A8%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%EF%BC%8C%E5%88%97%E8%A1%A8%E6%B8%85%E7%A9%BA%E4%BA%86%EF%BC%8C%E5%8D%B4%E6%B2%A1%E6%9C%89%E6%B7%BB%E5%8A%A0%E6%88%90%E5%8A%9F%E7%9A%84%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">把原有的角色列表清空，然后添加新的角色列表，会不会出现，列表清空了，却没有添加成功的现象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%A3%80%E6%9F%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9F\"><span class=\"toc-text\">先检查数据库事务的状态？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%B3%E6%AD%A4%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">至此，完整代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#primaryKey\"><span class=\"toc-text\">primaryKey</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">完整的例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%BA%86-autoIncrement-false\"><span class=\"toc-text\">使用了 autoIncrement:false</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%90%88%E4%B8%BB%E9%94%AE\"><span class=\"toc-text\">什么情况下，使用复合主键</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">关联模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86-BelongsTo-%E5%92%8C-HasOne\"><span class=\"toc-text\">如何区分 BelongsTo 和 HasOne</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">关联操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Association\"><span class=\"toc-text\">Association</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Association-%E8%BF%99%E5%9B%9B%E4%B8%AA-API-%E6%80%8E%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">Association 这四个 API 怎么用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Association-%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">Association 完整的例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">完整代码如下：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E7%AB%8B%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-%E6%B8%85%E7%A9%BA%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">建立关联关系 清空关联关系 对数据库有什么影响</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E7%AB%8B%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%EF%BC%9A\"><span class=\"toc-text\">建立关联关系：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%85%E7%A9%BA%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%EF%BC%9A\"><span class=\"toc-text\">清空关联关系：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%EF%BC%8C%E6%B8%85%E7%A9%BA%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%8C%E6%98%AF%E8%BD%AF%E5%88%A0%E9%99%A4%E8%BF%98%E6%98%AF%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">上述，清空关联关系中的删除，是软删除还是物理删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BD%93%E5%85%B3%E8%81%94\"><span class=\"toc-text\">实体关联</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#db-Model-amp-user-Association-%E2%80%9COrders%E2%80%9D-Find-amp-orders-%E4%B8%8E-db-Preload-%E2%80%9COrders%E2%80%9D-Find-amp-users-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">db.Model(&amp;user).Association(“Orders”).Find(&amp;orders) 与 db.Preload(“Orders”).Find(&amp;users) 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E8%80%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">两者使用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#db-Omit-%E2%80%9CLanguages-%E2%80%9C-Create-amp-user-%E4%B8%8E-db-Omit-%E2%80%9CLanguages%E2%80%9D-Create-amp-user-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">db.Omit(“Languages.*“).Create(&amp;user) 与 db.Omit(“Languages”).Create(&amp;user)的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mac-%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E6%9C%89-sqlite\"><span class=\"toc-text\">mac 查看是否有 sqlite</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">查询语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-polymorphicValue-%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">gorm polymorphicValue 使用完整示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">上述例子的数据库结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#owner-type-%E7%9A%84%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">owner_type 的值为什么是复数的形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#polymorphicValue-%E4%B8%A4%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">polymorphicValue 两个结构体的例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#polymorphicValue-%E4%B8%89%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">polymorphicValue 三个结构体的例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8C%96%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">简化后的代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%BC%95%E7%94%A8-Has-One-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">自引用 Has One 如何理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E9%9D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">上面为什么使用指针类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E9%80%92%E5%BD%92%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">为什么指针引用可以避免 循环依赖和递归引用的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">什么时候用指针类型，什么时候用实例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">指针和实例的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">如何避免空指针错误</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">什么是外键约束，有什么用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gorm-%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%BE%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">gorm 外键约束有哪些，各有什么用，举例子说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E6%88%B3%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">时间戳完整代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">上述代码表结构和结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#clause-Associations\"><span class=\"toc-text\">clause.Associations</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#clause-Associations-%E8%BF%98%E6%98%AF%E6%B2%A1%E6%9C%89%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">clause.Associations 还是没有理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Embedded-Preloading\"><span class=\"toc-text\">Embedded Preloading</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for-range-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">for range 实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for-range-%E5%8E%9F%E7%90%86-x2F-%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">for range 原理&#x2F;源码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Embedded-Preloading-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">Embedded Preloading 如何理解？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C-product%EF%BC%8C%E5%92%8C-order-%E7%9A%84%E5%85%B3%E7%B3%BB-%E4%B9%9F%E4%BD%BF%E7%94%A8-Embedded-Preloading-%E4%BC%9A%E6%80%8E%E6%A0%B7\"><span class=\"toc-text\">如果 product，和 order 的关系 也使用 Embedded Preloading 会怎样</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9C%8B%E4%B8%8D%E6%87%82%EF%BC%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">看不懂，举例说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#db-Table-%E2%80%9Cusers%E2%80%9D-Select-%E2%80%9CCOALESCE-age-%E2%80%9D-42-Rows-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">db.Table(“users”).Select(“COALESCE(age,?)”, 42).Rows() 什么意思</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#COALESCE-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">COALESCE 是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sql\"><span class=\"toc-text\">sql</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Distinct-works-with-Pluck-and-Count-too-%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">Distinct works with Pluck and Count too 的例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Find-%E3%80%81Scan-%E5%92%8C-Rows\"><span class=\"toc-text\">Find 、Scan 和 Rows</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rows-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-defer-close\"><span class=\"toc-text\">.Rows() 方法为什么需要 defer close</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"简单了解Jest","uid":"d38ec567dd1420f161a414e047d4332c","slug":"2023-05-05jest","date":"2023-05-05T06:25:39.000Z","updated":"2023-05-15T13:17:33.003Z","comments":true,"path":"api/articles/2023-05-05jest.json","keywords":null,"cover":[],"text":"toBeFalsy 是什么意思toBeFalsy 是 Jest 和 Jasmine 中的一个匹配器（Matcher），用于判断一个值是否为假值。如果一个值可以被强制转换为 false，则该值被视为假值。 例如，以下值被视为假值： false 0 -0 0n (BigInt 0) ...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"Jest","slug":"Jest","count":1,"path":"api/categories/Jest.json"}],"tags":[{"name":"Jest","slug":"Jest","count":1,"path":"api/tags/Jest.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"golang 的一些疑问","uid":"5c7c230f682d9d5e4199756d8ecfb6e2","slug":"2023-05-04go","date":"2023-05-04T01:30:35.000Z","updated":"2023-05-15T13:17:32.999Z","comments":true,"path":"api/articles/2023-05-04go.json","keywords":null,"cover":[],"text":" 引用类型和值类型 Go 中严格区分引用类型和值类型 golang appendappend 是 Go 语言中的内置函数，用于向切片中追加元素。其语法为： append(slice []Type, elems ...Type) []Type 其中，slice 是要追加元素的切片，...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[{"name":"Go","slug":"Go","count":19,"path":"api/categories/Go.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"},{"name":"Go","slug":"Go","count":19,"path":"api/tags/Go.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}