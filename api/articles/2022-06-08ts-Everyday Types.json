{"title":"3.Typescript å¸¸è§ç±»å‹","uid":"746ca231a136437ea4011b4445608ad1","slug":"2022-06-08ts-Everyday Types","date":"2022-06-06T08:40:41.000Z","updated":"2022-06-09T13:53:32.969Z","comments":true,"path":"api/articles/2022-06-08ts-Everyday Types.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","content":"<h2 id=\"Everyday-Types\"><a href=\"#Everyday-Types\" class=\"headerlink\" title=\"Everyday Types\"></a>Everyday Types</h2><p><code>å¸¸è§ç±»å‹</code><br>In this chapter, weâ€™ll cover some of the most common types of values youâ€™ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isnâ€™t an exhaustive list, and future chapters will describe more ways to name and use other types.<br><code>åœ¨è¿™ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨ä¸€äº› JavaScript ä»£ç ä¸­çš„å¸¸è§ç±»å‹ï¼Œå¹¶åœ¨ TypeScript ä¸­è¯´æ˜è¿™äº›ç±»å‹çš„ç›¸åº”æ–¹å¼ã€‚è¿™å¹¶ä¸æ˜¯ä¸€ä¸ªå®Œæ•´çš„åˆ—è¡¨ï¼Œè€Œä¸”æœªæ¥çš„ç« èŠ‚å°†è¯´æ˜æ›´å¤šçš„æ–¹æ³•æ¥å‘½åå’Œä½¿ç”¨å…¶ä»–ç±»å‹ã€‚</code><br>Types can also appear in many more places than just type annotations. As we learn about the types themselves, weâ€™ll also learn about the places where we can refer to these types to form new constructs.<br><code>ç±»å‹ä¹Ÿå¯ä»¥å‡ºç°åœ¨ç±»å‹æ³¨é‡Šä¹‹å¤–ã€‚æˆ‘ä»¬å­¦ä¹ ç±»å‹æœ¬èº«æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå­¦ä¹ åˆ°å“ªäº›åœ°æ–¹å¯ä»¥å¼•ç”¨è¿™äº›ç±»å‹æ¥å½¢æˆæ–°çš„æ„é€ ã€‚</code><br>Weâ€™ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.<br><code>æˆ‘ä»¬å°†å¼€å§‹ä»‹ç»æœ€åŸºæœ¬çš„ JavaScript æˆ– TypeScript ä»£ç ä¸­å¯èƒ½é‡åˆ°çš„å¸¸è§ç±»å‹ã€‚è¿™äº›ç±»å‹å°†ä½œä¸ºæ›´å¤æ‚çš„ç±»å‹çš„åŸºç¡€å»ºç­‘å—ã€‚</code></p>\n<h2 id=\"The-primitives-string-number-and-boolean\"><a href=\"#The-primitives-string-number-and-boolean\" class=\"headerlink\" title=\"The primitives: string,number, and boolean\"></a>The primitives: string,number, and boolean</h2><p>JavaScript has three very commonly used primitives: string, number, and boolean. Each has a corresponding type in TypeScript. As you might expect, these are the same names youâ€™d see if you used the JavaScript typeof operator on a value of those types:<br><code>JavaScript æœ‰ä¸‰ä¸ªéå¸¸å¸¸è§çš„åŸå§‹ç±»å‹ï¼šå­—ç¬¦ä¸²ï¼Œæ•°å­—å’Œå¸ƒå°”å€¼ã€‚è¿™ä¸‰ä¸ªç±»å‹åœ¨ TypeScript ä¸­å¯¹åº”ã€‚å¦‚æœä½ å¯ä»¥æ¥å—ï¼Œè¿™ä¸‰ä¸ªç±»å‹çš„åå­—éƒ½æ˜¯ç›¸åŒçš„ï¼š</code></p>\n<ul>\n<li>string represents string values like â€œHello, worldâ€<br><code>string è¡¨ç¤ºå­—ç¬¦ä¸²ï¼Œæ¯”å¦‚ &quot;Hello, world&quot;</code></li>\n<li>number is for numbers like 42. JavaScript does not have a special runtime value for integers, so thereâ€™s no equivalent to int or float - everything is simply number<br><code>number æ˜¯æ•°å­—ï¼Œæ¯”å¦‚ 42ã€‚JavaScript ä¸æ”¯æŒæ•´æ•°ï¼Œæ‰€ä»¥æ²¡æœ‰ç›¸åº”çš„ int æˆ– float - æ‰€æœ‰éƒ½æ˜¯ number</code></li>\n<li>boolean is for the two values true and false<br><code>boolean æ˜¯å¸ƒå°”å€¼ï¼Œæ¯”å¦‚ true å’Œ false</code></li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><p>The type names String, Number, and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string, number, or boolean for types.<br><code>ç±»å‹å String ï¼ŒNumber å’Œ Boolean ï¼ˆé¦–å­—æ¯å¤§å†™ï¼‰ä¹Ÿæ˜¯åˆæ³•çš„ï¼Œä½†å®ƒä»¬æ˜¯ä¸€äº›éå¸¸å°‘è§çš„ç‰¹æ®Šå†…ç½®ç±»å‹ã€‚æ‰€ä»¥ç±»å‹æ€»æ˜¯ä½¿ç”¨ string ï¼Œnumber æˆ–è€… boolean ã€‚</code></p>\n</div>\n<h2 id=\"Arrays\"><a href=\"#Arrays\" class=\"headerlink\" title=\"Arrays\"></a>Arrays</h2><p><code>æ•°ç»„</code><br>To specify the type of an array like [1, 2, 3], you can use the syntax number[]; this syntax works for any type (e.g. string[] is an array of strings, and so on). You may also see this written as Array<number>, which means the same thing. Weâ€™ll learn more about the syntax T<U> when we cover generics.<br><code>æŒ‡å®šæ•°ç»„çš„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ number[] çš„è¯­æ³•ï¼Œè¿™ç§è¯­æ³•å¯ä»¥ç”¨äºä»»ä½•ç±»å‹ï¼ˆæ¯”å¦‚ string[] æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè€Œ so onï¼‰ã€‚ä½ ä¹Ÿå¯ä»¥çœ‹åˆ°è¿™ç§å†™æ³• Array&lt;number&gt;ï¼Œå®ƒè¡¨ç¤ºç›¸åŒçš„æ„æ€ã€‚æˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­å­¦ä¹ æ›´å¤šå…³äºè¯­æ³• T&lt;U&gt; çš„è¯¦ç»†ä¿¡æ¯ã€‚</code><br>:::warning<br>Note that [number] is a different thing; refer to the section on Tuples.<br><code>[number] ä¸æ˜¯åŒä¸€ä¸ªä¸œè¥¿ï¼Œè¯·å‚è§å…³äºå…ƒç»„çš„ç« èŠ‚ã€‚</code><br>:::</p>\n<h2 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h2><p>TypeScript also has a special type, any, that you can use whenever you donâ€™t want a particular value to cause typechecking errors.<br><code>TypeScript ä¹Ÿæœ‰ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ anyï¼Œå¯ä»¥ç”¨äºæŒ‡å®šä½ ä¸æƒ³è¦æŸä¸ªå€¼å¯¼è‡´ç±»å‹æ£€æŸ¥é”™è¯¯çš„æƒ…å†µã€‚</code><br>When a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else thatâ€™s syntactically legal:<br><code>å½“å€¼æ˜¯ any ç±»å‹æ—¶ï¼Œä½ å¯ä»¥è®¿é—®å®ƒçš„ä»»ä½•å±æ€§ï¼ˆè¿™å°†å¯¼è‡´å®ƒçš„ç±»å‹ä¸º any ï¼‰ï¼Œè°ƒç”¨å®ƒï¼Œå°†å®ƒèµ‹å€¼ç»™ï¼ˆæˆ–ä»ï¼‰ä»»ä½•ç±»å‹çš„å€¼ï¼Œæˆ–è€…å…¶ä»–ä»»ä½•åˆæ³•çš„è¯­æ³•ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">let obj: any &#x3D; &#123; x: 0 &#125;;\n&#x2F;&#x2F; None of the following lines of code will throw compiler errors.\n&#x2F;&#x2F; ä»¥ä¸‹ä»£ç è¡Œéƒ½ä¸ä¼šå¼•å‘ç¼–è¯‘å™¨é”™è¯¯ã€‚\n&#x2F;&#x2F; Using &#96;any&#96; disables all further type checking, and it is assumed\n&#x2F;&#x2F; ä½¿ç”¨â€œanyâ€å°†ç¦ç”¨æ‰€æœ‰è¿›ä¸€æ­¥çš„ç±»å‹æ£€æŸ¥ï¼Œå¹¶ä¸”å‡å®š\n&#x2F;&#x2F; you know the environment better than TypeScript.\n&#x2F;&#x2F; ä½ çŸ¥é“ç¯å¢ƒä¼˜äºTypeScriptã€‚\nobj.foo();\nobj();\nobj.bar &#x3D; 100;\nobj &#x3D; &quot;hello&quot;;\nconst n: number &#x3D; obj;</code></pre>\n\n<p>The any type is useful when you donâ€™t want to write out a long type just to convince TypeScript that a particular line of code is okay.<br><code>any ç±»å‹æ˜¯ç”¨äºæŒ‡å®šä½ ä¸æƒ³è¦å†™å‡ºä¸€ä¸ªé•¿çš„ç±»å‹æ¥è¯´æ˜ TypeScript å¯¹æŸä¸€è¡Œä»£ç æ˜¯åˆæ³•çš„ã€‚</code></p>\n<h2 id=\"noImplicitAny\"><a href=\"#noImplicitAny\" class=\"headerlink\" title=\"noImplicitAny\"></a>noImplicitAny</h2><p>When you donâ€™t specify a type, and TypeScript canâ€™t infer it from context, the compiler will typically default to any.<br><code>å½“ä½ ä¸æŒ‡å®šç±»å‹ï¼Œå¹¶ä¸” TypeScript ä¸èƒ½ä»ä¸Šä¸‹æ–‡ä¸­æ¨æ–­å‡ºæ¥æ—¶ï¼Œç¼–è¯‘å™¨é»˜è®¤ä½¿ç”¨ anyã€‚</code><br>You usually want to avoid this, though, because any isnâ€™t type-checked. Use the compiler flag noImplicitAny to flag any implicit any as an error.<br><code>ä½ é€šå¸¸æƒ³é¿å…è¿™ç§æƒ…å†µï¼Œä½†æ˜¯ any ä¸ä¼šè¢«ç±»å‹æ£€æŸ¥ã€‚ä½¿ç”¨ç¼–è¯‘å™¨æ ‡è®° noImplicitAny æ¥æ ‡è®° any ä¸ºé”™è¯¯ã€‚</code></p>\n<h2 id=\"Type-Annotations-on-Variables\"><a href=\"#Type-Annotations-on-Variables\" class=\"headerlink\" title=\"Type Annotations on Variables\"></a>Type Annotations on Variables</h2><p><code>å˜é‡ä¸Šçš„ç±»å‹æ³¨è§£</code></p>\n<p>When you declare a variable using const, var, or let, you can optionally add a type annotation to explicitly specify the type of the variable:<br><code>ä½¿ç”¨ const ï¼Œvar æˆ– let å£°æ˜å˜é‡æ—¶ï¼Œå¯ä»¥æ·»åŠ ä¸€ä¸ªç±»å‹æ³¨è§£æ¥æ˜¾å¼æŒ‡å®šå˜é‡çš„ç±»å‹ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">let myName: string &#x3D; &quot;Alice&quot;;</code></pre>\n\n<p>TypeScript doesnâ€™t use â€œtypes on the leftâ€-style declarations like int x &#x3D; 0; Type annotations will always go after the thing being typed.<br><code>TypeScript ä¸ä½¿ç”¨â€œå·¦è¾¹çš„ç±»å‹â€çš„å£°æ˜æ–¹å¼ï¼Œå¦‚ int x = 0; ç±»å‹æ³¨è§£å°†æ€»æ˜¯åœ¨è¢«ç±»å‹çš„ä¸œè¥¿åé¢ã€‚</code><br>In most cases, though, this isnâ€™t needed. Wherever possible, TypeScript tries to automatically infer the types in your code. For example, the type of a variable is inferred based on the type of its initializer:<br><code>åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä¸éœ€è¦è¿™æ ·åšã€‚åœ¨æ¯ä¸ªå˜é‡çš„åˆå§‹å€¼çš„ç±»å‹å¯ä»¥è¢«è‡ªåŠ¨æ¨æ–­å‡ºæ¥ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; No type annotation needed -- &#39;myName&#39; inferred as type &#39;string&#39;\n&#x2F;&#x2F; æ²¡æœ‰ç±»å‹æ³¨è§£éœ€è¦ -- &#39;myName&#39; ç±»å‹è¢«æ¨æ–­ä¸º &#39;string&#39;\nlet myName &#x3D; &quot;Alice&quot;;</code></pre>\n\n<p>For the most part you donâ€™t need to explicitly learn the rules of inference. If youâ€™re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand whatâ€™s going on.<br><code>å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½ ä¸éœ€è¦æ˜¾å¼åœ°æŒ‡å®šç±»å‹æ³¨è§£ã€‚å¦‚æœä½ æ˜¯æ–°æ‰‹ï¼Œå°è¯•ä½¿ç”¨æ¯”ä½ è®¤ä¸ºæ›´å°‘çš„ç±»å‹æ³¨è§£ï¼Œä½ å¯èƒ½ä¼šæ„å¤–åœ°å‘ç° TypeScript å¯ä»¥å®Œå…¨ç†è§£ä½ çš„ä»£ç ã€‚</code></p>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><p><code>å‡½æ•°</code></p>\n<p>Functions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.<br><code>å‡½æ•°æ˜¯ JavaScript ä¸­ä¼ é€’æ•°æ®çš„ä¸»è¦æ–¹å¼ã€‚TypeScript å…è®¸ä½ æŒ‡å®šå‡½æ•°çš„è¾“å…¥å’Œè¾“å‡ºå€¼çš„ç±»å‹ã€‚</code></p>\n<h2 id=\"Parameter-Type-Annotations\"><a href=\"#Parameter-Type-Annotations\" class=\"headerlink\" title=\"Parameter Type Annotations\"></a>Parameter Type Annotations</h2><p><code>å‚æ•°ä¸Šçš„ç±»å‹æ³¨è§£</code></p>\n<p>When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:<br><code>å£°æ˜å‡½æ•°æ—¶ï¼Œå¯ä»¥åœ¨æ¯ä¸ªå‚æ•°åé¢æ·»åŠ ç±»å‹æ³¨è§£æ¥å£°æ˜å‡½æ•°æ¥å—å“ªäº›ç±»å‹çš„å‚æ•°ã€‚å‚æ•°ç±»å‹æ³¨è§£åœ¨å‚æ•°ååé¢ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Parameter type annotation\nfunction greet(name: string) &#123;\n  console.log(&quot;Hello, &quot; + name.toUpperCase() + &quot;!!&quot;);\n&#125;</code></pre>\n\n<p>When a parameter has a type annotation, arguments to that function will be checked:<br><code>å½“å‚æ•°æœ‰ç±»å‹æ³¨è§£æ—¶ï¼Œå‡½æ•°çš„å‚æ•°ä¼šè¢«æ£€æŸ¥ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Would be a runtime error if executed!\n&#x2F;&#x2F; å¦‚æœæ‰§è¡Œï¼Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ï¼\ngreet(42);\n&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.\n&#x2F;&#x2F; å‚æ•°ç±»å‹ &#39;number&#39; ä¸èƒ½èµ‹å€¼ç»™å‚æ•°ç±»å‹ &#39;string&#39;ã€‚</code></pre>\n\n<p>Even if you donâ€™t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.<br><code>å³ä½¿ä½ æ²¡æœ‰ç±»å‹æ³¨è§£ï¼ŒTypeScript ä¹Ÿä¼šæ£€æŸ¥ä½ ä¼ å…¥çš„å‚æ•°æ˜¯å¦æ­£ç¡®ã€‚</code></p>\n<h2 id=\"Return-Type-Annotations\"><a href=\"#Return-Type-Annotations\" class=\"headerlink\" title=\"Return Type Annotations\"></a>Return Type Annotations</h2><p><code>è¿”å›å€¼ä¸Šçš„ç±»å‹æ³¨è§£</code></p>\n<p>You can also add return type annotations. Return type annotations appear after the parameter list:<br><code>ä½ ä¹Ÿå¯ä»¥æ·»åŠ è¿”å›å€¼ç±»å‹æ³¨è§£ã€‚è¿”å›å€¼ç±»å‹æ³¨è§£å‡ºç°åœ¨å‚æ•°åˆ—è¡¨åé¢ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function getFavoriteNumber(): number &#123;\n  return 26;\n&#125;</code></pre>\n\n<p>Much like variable type annotations, you usually donâ€™t need a return type annotation because TypeScript will infer the functionâ€™s return type based on its return statements. The type annotation in the above example doesnâ€™t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.<br><code>å’Œå˜é‡ç±»å‹æ³¨è§£ä¸€æ ·ï¼Œä½ é€šå¸¸ä¸éœ€è¦è¿”å›å€¼ç±»å‹æ³¨è§£ï¼Œå› ä¸º TypeScript å°†åŸºäºè¿”å›è¯­å¥çš„ç±»å‹æ¨æ–­å‡ºæ¥ã€‚ä¸Šé¢çš„ç¤ºä¾‹ç¤ºä¾‹ä¸ä¼šæ”¹å˜ä»»ä½•ä¸œè¥¿ã€‚ä¸€äº›ä»£ç åº“å°†æ˜¾å¼æŒ‡å®šä¸€ä¸ªè¿”å›å€¼ç±»å‹ï¼Œä»¥é˜²æ­¢æ„å¤–çš„æ”¹å˜ï¼Œæˆ–è€…åªæ˜¯ä¸ºäº†ä¸ªäººåå¥½ã€‚</code></p>\n<h2 id=\"Anonymous-Functions\"><a href=\"#Anonymous-Functions\" class=\"headerlink\" title=\"Anonymous Functions\"></a>Anonymous Functions</h2><p><code>åŒ¿åå‡½æ•°</code></p>\n<p>Anonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how itâ€™s going to be called, the parameters of that function are automatically given types.<br><code>åŒ¿åå‡½æ•°å’Œå‡½æ•°å£°æ˜ä¸€æ ·ã€‚å½“å‡½æ•°å‡ºç°åœ¨ TypeScript å¯ä»¥ç¡®å®šå®ƒä¼šå¦‚ä½•è¢«è°ƒç”¨æ—¶ï¼Œå‡½æ•°çš„å‚æ•°ä¼šè¢«è‡ªåŠ¨æŒ‡å®šç±»å‹ã€‚</code><br>Hereâ€™s an example:<br><code>è¿™é‡Œæœ‰ä¸€ä¸ªç¤ºä¾‹ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; No type annotations here, but TypeScript can spot the bug\n&#x2F;&#x2F; æ²¡æœ‰ç±»å‹æ³¨è§£ï¼Œä½† TypeScript å¯ä»¥æ£€æµ‹åˆ°é”™è¯¯\nconst names &#x3D; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;];\n\n&#x2F;&#x2F; Contextual typing for function\n&#x2F;&#x2F; å‡½æ•°ä¸Šä¸‹æ–‡ç±»å‹\nnames.forEach(function (s) &#123;\n  console.log(s.toUppercase());\n  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?\n  &#x2F;&#x2F; å±æ€§ &#39;toUppercase&#39; ä¸å­˜åœ¨äºç±»å‹ &#39;string&#39; ä¸­ã€‚ä½ å¯èƒ½æƒ³ç”¨ &#39;toUpperCase&#39; å—ï¼Ÿ\n&#125;);\n\n&#x2F;&#x2F; Contextual typing also applies to arrow functions\n&#x2F;&#x2F; ç®­å¤´å‡½æ•°ä¸Šä¸‹æ–‡ç±»å‹\nnames.forEach((s) &#x3D;&gt; &#123;\n  console.log(s.toUppercase());\n  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?\n  &#x2F;&#x2F; å±æ€§ &#39;toUppercase&#39; ä¸å­˜åœ¨äºç±»å‹ &#39;string&#39; ä¸­ã€‚ä½ å¯èƒ½æƒ³ç”¨ &#39;toUpperCase&#39; å—ï¼Ÿ\n&#125;);</code></pre>\n\n<p>Even though the parameter s didnâ€™t have a type annotation, TypeScript used the types of the forEach function, along with the inferred type of the array, to determine the type s will have.<br><code>å³ä½¿å‚æ•° s æ²¡æœ‰ç±»å‹æ³¨è§£ï¼ŒTypeScript ä¼šä½¿ç”¨ forEach å‡½æ•°çš„ç±»å‹ï¼Œä»¥åŠæ¨æ–­çš„æ•°ç»„ç±»å‹ï¼Œæ¥ç¡®å®š s çš„ç±»å‹ã€‚</code><br>This process is called contextual typing because the context that the function occurred within informs what type it should have.<br><code>è¿™ä¸ªè¿‡ç¨‹æ˜¯ä¸Šä¸‹æ–‡ç±»å‹çš„ï¼Œå› ä¸ºå‡½æ•°å‘ç”Ÿåœ¨å“ªé‡Œçš„ä¸Šä¸‹æ–‡ï¼Œå°±ä¼šç¡®å®šå®ƒåº”è¯¥æœ‰å“ªç§ç±»å‹ã€‚</code><br>Similar to the inference rules, you donâ€™t need to explicitly learn how this happens, but understanding that it does happen can help you notice when type annotations arenâ€™t needed. Later, weâ€™ll see more examples of how the context that a value occurs in can affect its type.<br><code>ä¸æ¨æ–­è§„åˆ™ç›¸ä¼¼ï¼Œä½ ä¸éœ€è¦æ˜¾å¼å­¦ä¹ è¿™ç§è¿‡ç¨‹ï¼Œä½†æ˜¯äº†è§£è¿™ç§è¿‡ç¨‹å¯ä»¥å¸®åŠ©ä½ å‘ç°ï¼Œå½“å€¼ä¸éœ€è¦ç±»å‹æ³¨è§£æ—¶ï¼Œå®ƒä¼šå‘ç”Ÿä»€ä¹ˆã€‚ä¹‹åï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°æ›´å¤šçš„ä¾‹å­ï¼Œå¦‚ä½•å€¼çš„ä¸Šä¸‹æ–‡å¯ä»¥å½±å“å®ƒçš„ç±»å‹ã€‚</code></p>\n<h2 id=\"Object-Types\"><a href=\"#Object-Types\" class=\"headerlink\" title=\"Object Types\"></a>Object Types</h2><p><code>å¯¹è±¡ç±»å‹</code></p>\n<p>Apart from primitives, the most common sort of type youâ€™ll encounter is an object type. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.<br><code>é™¤äº†åŸå§‹ç±»å‹ï¼Œæœ€å¸¸è§çš„ç±»å‹æ˜¯å¯¹è±¡ç±»å‹ã€‚è¿™æŒ‡çš„æ˜¯ä»»ä½• JavaScript å€¼ï¼Œå®ƒçš„å±æ€§éƒ½æ˜¯å¾ˆå¤šçš„ï¼ä¸ºäº†å®šä¹‰å¯¹è±¡ç±»å‹ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ—å‡ºå®ƒçš„å±æ€§å’Œå®ƒä»¬çš„ç±»å‹ã€‚</code><br>For example, hereâ€™s a function that takes a point-like object:<br><code>è¿™é‡Œæœ‰ä¸€ä¸ªæ¥å—ç‚¹ç±»å‹å¯¹è±¡çš„å‡½æ•°ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; The parameter&#39;s type annotation is an object type\nfunction printCoord(pt: &#123; x: number; y: number &#125;) &#123;\n  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);\n  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);\n&#125;\nprintCoord(&#123; x: 3, y: 7 &#125;);</code></pre>\n\n<p>Here, we annotated the parameter with a type with two properties - x and y - which are both of type number. You can use , or ; to separate the properties, and the last separator is optional either way.<br><code>è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæœ‰ä¸¤ä¸ªå±æ€§çš„ç±»å‹ï¼Œx å’Œ yï¼Œå®ƒä»¬éƒ½æ˜¯ number ç±»å‹ã€‚ä½ å¯ä»¥ä½¿ç”¨ , æˆ– ; åˆ†éš”å±æ€§ï¼Œæœ€åçš„åˆ†éš”ç¬¦å¯ä»¥æ˜¯ä»»æ„çš„ã€‚</code><br>The type part of each property is also optional. If you donâ€™t specify a type, it will be assumed to be any.<br><code>æ¯ä¸ªå±æ€§çš„ç±»å‹éƒ¨åˆ†éƒ½æ˜¯å¯é€‰çš„ã€‚å¦‚æœä½ æ²¡æœ‰æŒ‡å®šç±»å‹ï¼Œå®ƒä¼šè¢«è®¤ä¸ºæ˜¯ any ç±»å‹ã€‚</code></p>\n<h2 id=\"Optional-Properties\"><a href=\"#Optional-Properties\" class=\"headerlink\" title=\"Optional Properties\"></a>Optional Properties</h2><p><code>å¯é€‰å±æ€§</code></p>\n<p>Object types can also specify that some or all of their properties are optional. To do this, add a ? after the property name:<br><code>å¯¹è±¡ç±»å‹å¯ä»¥æŒ‡å®šä¸€äº›æˆ–å…¨éƒ¨çš„å±æ€§æ˜¯å¯é€‰çš„ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œåªéœ€è¦åœ¨å±æ€§ååé¢åŠ ä¸Š ? å°±å¯ä»¥äº†ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function printName(obj: &#123; first: string; last?: string &#125;) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F; Both OK\nprintName(&#123; first: &quot;Bob&quot; &#125;);\nprintName(&#123; first: &quot;Alice&quot;, last: &quot;Alisson&quot; &#125;);</code></pre>\n\n<p>In JavaScript, if you access a property that doesnâ€™t exist, youâ€™ll get the value undefined rather than a runtime error. Because of this, when you read from an optional property, youâ€™ll have to check for undefined before using it.</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function printName(obj: &#123; first: string; last?: string &#125;) &#123;\n  &#x2F;&#x2F; Error - might crash if &#39;obj.last&#39; wasn&#39;t provided!\n  console.log(obj.last.toUpperCase());\nObject is possibly &#39;undefined&#39;.\n  if (obj.last !&#x3D;&#x3D; undefined) &#123;\n    &#x2F;&#x2F; OK\n    console.log(obj.last.toUpperCase());\n  &#125;\n\n  &#x2F;&#x2F; A safe alternative using modern JavaScript syntax:\n  console.log(obj.last?.toUpperCase());\n&#125;</code></pre>\n\n<h2 id=\"Union-Types\"><a href=\"#Union-Types\" class=\"headerlink\" title=\"Union Types\"></a>Union Types</h2><p><code>è”åˆç±»å‹</code></p>\n<p>TypeScriptâ€™s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, itâ€™s time to start combining them in interesting ways.</p>\n<h2 id=\"Defining-a-Union-Type\"><a href=\"#Defining-a-Union-Type\" class=\"headerlink\" title=\"Defining a Union Type\"></a>Defining a Union Type</h2><p><code>å®šä¹‰ä¸€ä¸ªè”åˆç±»å‹</code></p>\n<p>The first way to combine types you might see is a union type. A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the unionâ€™s members.</p>\n<p>Letâ€™s write a function that can operate on strings or numbers:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function printId(id: number | string) &#123;\n  console.log(&quot;Your ID is: &quot; + id);\n&#125;\n&#x2F;&#x2F; OK\nprintId(101);\n&#x2F;&#x2F; OK\nprintId(&quot;202&quot;);\n&#x2F;&#x2F; Error\nprintId(&#123; myID: 22342 &#125;);\n&#x2F;&#x2F; Argument of type &#39;&#123; myID: number; &#125;&#39; is not assignable to parameter of type &#39;string | number&#39;.</code></pre>\n\n<h2 id=\"Working-with-Union-Types\"><a href=\"#Working-with-Union-Types\" class=\"headerlink\" title=\"Working with Union Types\"></a>Working with Union Types</h2><p><code>ä½¿ç”¨è”åˆç±»å‹</code></p>\n<p>Itâ€™s easy to provide a value matching a union type - simply provide a type matching any of the unionâ€™s members. If you have a value of a union type, how do you work with it?</p>\n<p>TypeScript will only allow an operation if it is valid for every member of the union. For example, if you have the union string | number, you canâ€™t use methods that are only available on string:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function printId(id: number | string) &#123;\n  console.log(id.toUpperCase());\nProperty &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.\n  Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.\n&#125;</code></pre>\n\n<p>The solution is to narrow the union with code, the same as you would in JavaScript without type annotations. Narrowing occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.</p>\n<p>For example, TypeScript knows that only a string value will have a typeof value â€œstringâ€:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function printId(id: number | string) &#123;\n  if (typeof id &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    &#x2F;&#x2F; In this branch, id is of type &#39;string&#39;\n    console.log(id.toUpperCase());\n  &#125; else &#123;\n    &#x2F;&#x2F; Here, id is of type &#39;number&#39;\n    console.log(id);\n  &#125;\n&#125;</code></pre>\n\n<p>Another example is to use a function like Array.isArray:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function welcomePeople(x: string[] | string) &#123;\n  if (Array.isArray(x)) &#123;\n    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string[]&#39;\n    console.log(&quot;Hello, &quot; + x.join(&quot; and &quot;));\n  &#125; else &#123;\n    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string&#39;\n    console.log(&quot;Welcome lone traveler &quot; + x);\n  &#125;\n&#125;</code></pre>\n\n<p>Notice that in the else branch, we donâ€™t need to do anything special - if x wasnâ€™t a string[], then it must have been a string.</p>\n<p>Sometimes youâ€™ll have a union where all the members have something in common. For example, both arrays and strings have a slice method. If every member in a union has a property in common, you can use that property without narrowing:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Return type is inferred as number[] | string\nfunction getFirstThree(x: number[] | string) &#123;\n  return x.slice(0, 3);\n&#125;</code></pre>\n\n<p>It might be confusing that a union of types appears to have the intersection of those typesâ€™ properties. This is not an accident - the name union comes from type theory. The union number | string is composed by taking the union of the values from each type. Notice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about every person is that they must be wearing a hat.</p>\n<h2 id=\"Type-Aliases\"><a href=\"#Type-Aliases\" class=\"headerlink\" title=\"Type Aliases\"></a>Type Aliases</h2><p><code>ç±»å‹åˆ«å</code></p>\n<p>Weâ€™ve been using object types and union types by writing them directly in type annotations. This is convenient, but itâ€™s common to want to use the same type more than once and refer to it by a single name.</p>\n<p>A type alias is exactly that - a name for any type. The syntax for a type alias is:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">type Point &#x3D; &#123;\n  x: number;\n  y: number;\n&#125;;\n\n&#x2F;&#x2F; Exactly the same as the earlier example\nfunction printCoord(pt: Point) &#123;\n  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);\n  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);\n&#125;\n\nprintCoord(&#123; x: 100, y: 100 &#125;);</code></pre>\n\n<p>You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">type ID &#x3D; number | string;</code></pre>\n\n<p>Note that aliases are only aliases - you cannot use type aliases to create different&#x2F;distinct â€œversionsâ€ of the same type. When you use the alias, itâ€™s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">type UserInputSanitizedString &#x3D; string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString &#123;\n  return sanitize(str);\n&#125;\n\n&#x2F;&#x2F; Create a sanitized input\nlet userInput &#x3D; sanitizeInput(getInput());\n\n&#x2F;&#x2F; Can still be re-assigned with a string though\nuserInput &#x3D; &quot;new input&quot;;</code></pre>\n\n<h2 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h2><p><code>æ¥å£</code></p>\n<p>An interface declaration is another way to name an object type:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">interface Point &#123;\n  x: number;\n  y: number;\n&#125;\n\nfunction printCoord(pt: Point) &#123;\n  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);\n  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);\n&#125;\n\nprintCoord(&#123; x: 100, y: 100 &#125;);</code></pre>\n\n<p>Just like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the structure of the value we passed to printCoord - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a structurally typed type system.</p>\n<h2 id=\"Differences-Between-Type-Aliases-and-Interfaces\"><a href=\"#Differences-Between-Type-Aliases-and-Interfaces\" class=\"headerlink\" title=\"Differences Between Type Aliases and Interfaces\"></a>Differences Between Type Aliases and Interfaces</h2><p><code>ç±»å‹åˆ«åå’Œæ¥å£çš„åŒºåˆ«</code></p>\n<p>Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p>\n<p><strong>Interface</strong></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Extending an interface\n\ninterface Animal &#123;\n  name: string;\n&#125;\n\ninterface Bear extends Animal &#123;\n  honey: boolean;\n&#125;\n\nconst bear &#x3D; getBear();\nbear.name;\nbear.honey;</code></pre>\n\n<p><strong>Type</strong></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Extending a type via intersections\n\ntype Animal &#x3D; &#123;\n  name: string;\n&#125;;\n\ntype Bear &#x3D; Animal &amp; &#123;\n  honey: boolean;\n&#125;;\n\nconst bear &#x3D; getBear();\nbear.name;\nbear.honey;</code></pre>\n\n<p>Adding new fields to an existing interface</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">interface Window &#123;\n  title: string;\n&#125;\n\ninterface Window &#123;\n  ts: TypeScriptAPI;\n&#125;\n\nconst src &#x3D; &#39;const a &#x3D; &quot;Hello World&quot;&#39;;\nwindow.ts.transpileModule(src, &#123;&#125;);</code></pre>\n\n<p>A type cannot be changed after being created</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">type Window &#x3D; &#123;\n  title: string;\n&#125;;\n\ntype Window &#x3D; &#123;\n  ts: TypeScriptAPI;\n&#125;;\n\n&#x2F;&#x2F; Error: Duplicate identifier &#39;Window&#39;.</code></pre>\n\n<p>Youâ€™ll learn more about these concepts in later chapters, so donâ€™t worry if you donâ€™t understand all of these right away.</p>\n<ul>\n<li>Prior to TypeScript version 4.2, type alias names may appear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.</li>\n<li>Type aliases may not participate in declaration merging, but interfaces can.</li>\n<li>Interfaces may only be used to declare the shapes of objects, not rename primitives.</li>\n<li>Interface names will always appear in their original form in error messages, but only when they are used by name.</li>\n</ul>\n<p>For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use interface until you need to use features from type.</p>\n<h2 id=\"Type-Assertions\"><a href=\"#Type-Assertions\" class=\"headerlink\" title=\"Type Assertions\"></a>Type Assertions</h2><p><code>ç±»å‹æ–­è¨€</code></p>\n<p>Sometimes you will have information about the type of a value that TypeScript canâ€™t know about.</p>\n<p>For example, if youâ€™re using document.getElementById, TypeScript only knows that this will return some kind of HTMLElement, but you might know that your page will always have an HTMLCanvasElement with a given ID.</p>\n<p>In this situation, you can use a type assertion to specify a more specific type:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const myCanvas &#x3D; document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;</code></pre>\n\n<p>Like a type annotation, type assertions are removed by the compiler and wonâ€™t affect the runtime behavior of your code.</p>\n<p>You can also use the angle-bracket syntax (except if the code is in a .tsx file), which is equivalent:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const myCanvas &#x3D; &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;);</code></pre>\n\n<p>Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There wonâ€™t be an exception or null generated if the type assertion is wrong.</p>\n<p>TypeScript only allows type assertions which convert to a more specific or less specific version of a type. This rule prevents â€œimpossibleâ€ coercions like:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const x &#x3D; &quot;hello&quot; as number;\n&#x2F;&#x2F; Conversion of type &#39;string&#39; to type &#39;number&#39; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#39;unknown&#39; first.</code></pre>\n\n<p>Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to any (or unknown, which weâ€™ll introduce later), then to the desired type:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const a &#x3D; expr as any as T;</code></pre>\n\n<h2 id=\"Literal-Types\"><a href=\"#Literal-Types\" class=\"headerlink\" title=\"Literal Types\"></a>Literal Types</h2><p><code>å­—é¢é‡ç±»å‹</code></p>\n<p>In addition to the general types string and number, we can refer to specific strings and numbers in type positions.</p>\n<p>One way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both var and let allow for changing what is held inside the variable, and const does not. This is reflected in how TypeScript creates types for literals.</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">let changingString &#x3D; &quot;Hello World&quot;;\nchangingString &#x3D; &quot;OlÃ¡ Mundo&quot;;\n&#x2F;&#x2F; Because &#96;changingString&#96; can represent any possible string, that\n&#x2F;&#x2F; is how TypeScript describes it in the type system\nchangingString;\n\nlet changingString: string;\n\nconst constantString &#x3D; &quot;Hello World&quot;;\n&#x2F;&#x2F; Because &#96;constantString&#96; can only represent 1 possible string, it\n&#x2F;&#x2F; has a literal type representation\nconstantString;\n\nconst constantString: &quot;Hello World&quot;;</code></pre>\n\n<p>By themselves, literal types arenâ€™t very valuable:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">let x: &quot;hello&quot; &#x3D; &quot;hello&quot;;\n&#x2F;&#x2F; OK\nx &#x3D; &quot;hello&quot;;\n&#x2F;&#x2F; ...\nx &#x3D; &quot;howdy&quot;;\n&#x2F;&#x2F; Type &#39;&quot;howdy&quot;&#39; is not assignable to type &#39;&quot;hello&quot;&#39;.</code></pre>\n\n<p>Itâ€™s not much use to have a variable that can only have one value!</p>\n<p>But by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) &#123;\n  &#x2F;&#x2F; ...\n&#125;\nprintText(&quot;Hello, world&quot;, &quot;left&quot;);\nprintText(&quot;G&#39;day, mate&quot;, &quot;centre&quot;);\nArgument of type &#39;&quot;centre&quot;&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot; | &quot;center&quot;&#39;.</code></pre>\n\n<p>Numeric literal types work the same way:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function compare(a: string, b: string): -1 | 0 | 1 &#123;\n  return a &#x3D;&#x3D;&#x3D; b ? 0 : a &gt; b ? 1 : -1;\n&#125;</code></pre>\n\n<p>Of course, you can combine these with non-literal types:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">interface Options &#123;\n  width: number;\n&#125;\nfunction configure(x: Options | &quot;auto&quot;) &#123;\n  &#x2F;&#x2F; ...\n&#125;\nconfigure(&#123; width: 100 &#125;);\nconfigure(&quot;auto&quot;);\nconfigure(&quot;automatic&quot;);\nArgument of type &#39;&quot;automatic&quot;&#39; is not assignable to parameter of type &#39;Options | &quot;auto&quot;&#39;.</code></pre>\n\n<p>Thereâ€™s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types true and false. The type boolean itself is actually just an alias for the union true | false.</p>\n<h2 id=\"Literal-Inference\"><a href=\"#Literal-Inference\" class=\"headerlink\" title=\"Literal Inference\"></a>Literal Inference</h2><p><code>å­—é¢é‡æ¨æ–­</code><br>When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const obj &#x3D; &#123; counter: 0 &#125;;\nif (someCondition) &#123;\n  obj.counter &#x3D; 1;\n&#125;</code></pre>\n\n<p>TypeScript doesnâ€™t assume the assignment of 1 to a field which previously had 0 is an error. Another way of saying this is that obj.counter must have the type number, not 0, because types are used to determine both reading and writing behavior.</p>\n<p>The same applies to strings:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125;;\nhandleRequest(req.url, req.method);\nArgument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;GET&quot; | &quot;POST&quot;&#39;.</code></pre>\n\n<p>In the above example req.method is inferred to be string, not â€œGETâ€. Because code can be evaluated between the creation of req and the call of handleRequest which could assign a new string like â€œGUESSâ€ to req.method, TypeScript considers this code to have an error.</p>\n<p>There are two ways to work around this.</p>\n<p>You can change the inference by adding a type assertion in either location:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Change 1:\nconst req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; &#125;;\n&#x2F;&#x2F; Change 2\nhandleRequest(req.url, req.method as &quot;GET&quot;);</code></pre>\n\n<p>Change 1 means â€œI intend for req.method to always have the literal type â€œGETâ€â€, preventing the possible assignment of â€œGUESSâ€ to that field after. Change 2 means â€œI know for other reasons that req.method has the value â€œGETâ€â€œ.</p>\n<p>You can use as const to convert the entire object to be type literals:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125; as const;\nhandleRequest(req.url, req.method);</code></pre>\n\n<p>The as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number.</p>\n<h2 id=\"null-and-undefined\"><a href=\"#null-and-undefined\" class=\"headerlink\" title=\"null and undefined\"></a>null and undefined</h2><p><code>nullå’Œundefined</code></p>\n<p>JavaScript has two primitive values used to signal absent or uninitialized value: null and undefined.</p>\n<p>TypeScript has two corresponding types by the same names. How these types behave depends on whether you have the strictNullChecks option on.</p>\n<h2 id=\"strictNullChecks-off\"><a href=\"#strictNullChecks-off\" class=\"headerlink\" title=\"strictNullChecks off\"></a>strictNullChecks off</h2><p><code>strictNullCheckså…³é—­</code></p>\n<p>With strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn strictNullChecks on if itâ€™s practical to do so in their codebase.</p>\n<h2 id=\"strictNullChecks-on\"><a href=\"#strictNullChecks-on\" class=\"headerlink\" title=\"strictNullChecks on\"></a>strictNullChecks on</h2><p><code>strictNullCheckså¼€å¯</code></p>\n<p>With strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value. Just like checking for undefined before using an optional property, we can use narrowing to check for values that might be null:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function doSomething(x: string | null) &#123;\n  if (x &#x3D;&#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; do nothing\n  &#125; else &#123;\n    console.log(&quot;Hello, &quot; + x.toUpperCase());\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"Non-null-Assertion-Operator-Postfix\"><a href=\"#Non-null-Assertion-Operator-Postfix\" class=\"headerlink\" title=\"Non-null Assertion Operator (Postfix !)\"></a>Non-null Assertion Operator (Postfix !)</h2><p><code>éç©ºæ–­è¨€è¿ç®—ç¬¦</code></p>\n<p>TypeScript also has a special syntax for removing null and undefined from a type without doing any explicit checking. Writing ! after any expression is effectively a type assertion that the value isnâ€™t null or undefined:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function liveDangerously(x?: number | null) &#123;\n  &#x2F;&#x2F; No error\n  console.log(x!.toFixed());\n&#125;</code></pre>\n\n<p>Just like other type assertions, this doesnâ€™t change the runtime behavior of your code, so itâ€™s important to only use ! when you know that the value canâ€™t be null or undefined.</p>\n<h2 id=\"Enums\"><a href=\"#Enums\" class=\"headerlink\" title=\"Enums\"></a>Enums</h2><p><code>æšä¸¾</code></p>\n<p>Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. Because of this, itâ€™s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the Enum reference page.</p>\n<h2 id=\"Less-Common-Primitives\"><a href=\"#Less-Common-Primitives\" class=\"headerlink\" title=\"Less Common Primitives\"></a>Less Common Primitives</h2><p><code>æ›´å°‘å¸¸è§çš„åŸå§‹ç±»å‹</code><br>Itâ€™s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.</p>\n<p>bigint<br>From ES2020 onwards, there is a primitive in JavaScript used for very large integers, BigInt:</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; Creating a bigint via the BigInt function\nconst oneHundred: bigint &#x3D; BigInt(100);\n\n&#x2F;&#x2F; Creating a BigInt via the literal syntax\nconst anotherHundred: bigint &#x3D; 100n;</code></pre>\n\n<p>You can learn more about BigInt in the TypeScript 3.2 release notes.</p>\n<h2 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h2><p>There is a primitive in JavaScript used to create a globally unique reference via the function Symbol():</p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const firstName &#x3D; Symbol(&quot;name&quot;);\nconst secondName &#x3D; Symbol(&quot;name&quot;);\n\nif (firstName &#x3D;&#x3D;&#x3D; secondName) &#123;\nThis condition will always return &#39;false&#39; since the types &#39;typeof firstName&#39; and &#39;typeof secondName&#39; have no overlap.\n  &#x2F;&#x2F; Can&#39;t ever happen\n&#125;</code></pre>\n\n<p>You can learn more about them in Symbols reference page.</p>\n<h2 id=\"å‚è€ƒé“¾æ¥\"><a href=\"#å‚è€ƒé“¾æ¥\" class=\"headerlink\" title=\"å‚è€ƒé“¾æ¥\"></a>å‚è€ƒé“¾æ¥</h2><p><a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean\">Typescript å¸¸è§ç±»å‹</a></p>\n","text":"Everyday Typeså¸¸è§ç±»å‹In this chapter, weâ€™ll cover some of the most common types of values youâ€™ll find in JavaScript code, and explain the corre...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"27 mins."},"categories":[{"name":"typescript","slug":"typescript","count":8,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":8,"path":"api/tags/typescript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Everyday-Types\"><span class=\"toc-text\">Everyday Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#The-primitives-string-number-and-boolean\"><span class=\"toc-text\">The primitives: string,number, and boolean</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Arrays\"><span class=\"toc-text\">Arrays</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#any\"><span class=\"toc-text\">any</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#noImplicitAny\"><span class=\"toc-text\">noImplicitAny</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Type-Annotations-on-Variables\"><span class=\"toc-text\">Type Annotations on Variables</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Functions\"><span class=\"toc-text\">Functions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Parameter-Type-Annotations\"><span class=\"toc-text\">Parameter Type Annotations</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Return-Type-Annotations\"><span class=\"toc-text\">Return Type Annotations</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Anonymous-Functions\"><span class=\"toc-text\">Anonymous Functions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-Types\"><span class=\"toc-text\">Object Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Optional-Properties\"><span class=\"toc-text\">Optional Properties</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Union-Types\"><span class=\"toc-text\">Union Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Defining-a-Union-Type\"><span class=\"toc-text\">Defining a Union Type</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Working-with-Union-Types\"><span class=\"toc-text\">Working with Union Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Type-Aliases\"><span class=\"toc-text\">Type Aliases</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interfaces\"><span class=\"toc-text\">Interfaces</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Differences-Between-Type-Aliases-and-Interfaces\"><span class=\"toc-text\">Differences Between Type Aliases and Interfaces</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Type-Assertions\"><span class=\"toc-text\">Type Assertions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Literal-Types\"><span class=\"toc-text\">Literal Types</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Literal-Inference\"><span class=\"toc-text\">Literal Inference</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#null-and-undefined\"><span class=\"toc-text\">null and undefined</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#strictNullChecks-off\"><span class=\"toc-text\">strictNullChecks off</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#strictNullChecks-on\"><span class=\"toc-text\">strictNullChecks on</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Non-null-Assertion-Operator-Postfix\"><span class=\"toc-text\">Non-null Assertion Operator (Postfix !)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Enums\"><span class=\"toc-text\">Enums</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Less-Common-Primitives\"><span class=\"toc-text\">Less Common Primitives</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#symbol\"><span class=\"toc-text\">symbol</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">å‚è€ƒé“¾æ¥</span></a></li></ol>","author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"4.Typescriptæ‰‹å†Œ æ”¶ç¼©ç±»å‹","uid":"aab722f3fd65a7516918bd7fed1d7d01","slug":"2022-06-08ts-norrowing","date":"2022-06-07T01:21:19.000Z","updated":"2022-06-09T13:53:32.971Z","comments":true,"path":"api/articles/2022-06-08ts-norrowing.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"Narrowingç¼©å°èŒƒå›´ Imagine we have a function called padLeft.è¯•æƒ³æˆ‘ä»¬æœ‰è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°åä¸º padLeftï¼š function padLeft(padding: number | string, input: string):...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"typescript","slug":"typescript","count":8,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":8,"path":"api/tags/typescript.json"}],"author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"2.Typescript åŸºç¡€","uid":"3d6d9d5bd9a34b12b2d2da5941501c4f","slug":"2022-06-07ts-basics","date":"2022-06-06T07:56:08.000Z","updated":"2022-06-09T13:53:32.968Z","comments":true,"path":"api/articles/2022-06-07ts-basics.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"The BasicsWelcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the ...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"typescript","slug":"typescript","count":8,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":8,"path":"api/tags/typescript.json"}],"author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}