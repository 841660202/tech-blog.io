{"title":"4.系统学习 mysql 事务","uid":"968e01e6b4020ddd66a1e79ae770349d","slug":"2022-11-30mysql-事务","date":"2022-11-30T06:04:20.000Z","updated":"2022-11-30T13:39:08.839Z","comments":true,"path":"api/articles/2022-11-30mysql-事务.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","content":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"为什么需要事务\"><a href=\"#为什么需要事务\" class=\"headerlink\" title=\"为什么需要事务\"></a>为什么需要事务</h3><p>MySQL 事务允许您执行一组 MySQL 操作，<code>以确保数据库永远不会包含部分操作的结果</code>。</p>\n<ul>\n<li>在一组操作中，如果其中一个操作失败，则会发生回滚以将数据库还原到其原始状态。</li>\n<li>如果没有发生错误，则将整个语句集提交给数据库。</li>\n</ul>\n<h3 id=\"事务特点\"><a href=\"#事务特点\" class=\"headerlink\" title=\"事务特点\"></a>事务特点</h3><p>事务是必须满足 4 个条件<code>(ACID)</code>：</p>\n<p><code>原子性(Atomicity)</code>: 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n<p><code>一致性(Consistency)</code>:在事务开始之前和事务结束以后，数据库的完整性没有被破坏。应用系统应该从一个正确的状态到另一个正确的状态,这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>\n<p><code>隔离性(Isolation)</code>:数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。防止出现：<code>脏读、幻读、不可重复读</code>。</p>\n<p><code>持久性(Durability)</code>:事务处理结束后，对数据的修改就是永久的。<br>————————————————<br>版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/xyy1028/article/details/106165503\">https://blog.csdn.net/xyy1028/article/details/106165503</a></p>\n<h3 id=\"mysql-隔离机制\"><a href=\"#mysql-隔离机制\" class=\"headerlink\" title=\"mysql 隔离机制\"></a>mysql 隔离机制</h3><p><strong>为了实现事务隔离性</strong></p>\n<img src=\"http://t-blog-images.aijs.top/img/202211291432266.webp\" style=\"width:500px;max-width:100%\" />\n\n<p><a href=\"https://blog.csdn.net/qq_45830276/article/details/125246751\" target=\"_blank\" >见</a></p>\n<h3 id=\"并发导致事务隔离性出问题\"><a href=\"#并发导致事务隔离性出问题\" class=\"headerlink\" title=\"并发导致事务隔离性出问题\"></a>并发导致事务隔离性出问题</h3><p>a.如果两个事务<code>并发的修改</code>则必须隔离开。</p>\n<p>b.如果两个事务<code>并发的查询</code>则完全不用隔离。</p>\n<p>c.<code>如果一个事务修改，另一个事务查询</code>，则可能出现<code>脏读、不可重复读、幻读</code>的情况，隔离级别主要针对这种情况。</p>\n<h3 id=\"脏读、不可重复读、幻读\"><a href=\"#脏读、不可重复读、幻读\" class=\"headerlink\" title=\"脏读、不可重复读、幻读\"></a>脏读、不可重复读、幻读</h3><ol>\n<li><p><code>脏读</code>：一个事务读取到另一个事务未提交的数据。</p>\n</li>\n<li><p><code>不可重复读</code>：一个事务读取到另一个事务已经提交的数据。例如事务 A 读取了一条记录，此时事务 B 修改了该条数据并提交成功，事务 A 再次查询该条数据发现与第一次读取的不一样，即为不可重复度（同一个事务内重复读取的数据不一样，则理解成不可重复读）。</p>\n</li>\n<li><p><code>幻读</code>：一个事务读取到另一个事务已经提交的数据，但与不可重复读不同的是，不可重复读的原因在于 update，而幻读源于其他事务 insert 或 delete 了记录导致记录条数不一致。</p>\n</li>\n</ol>\n<ul>\n<li><code>不可重复读的原因在于 update</code>，</li>\n<li><code>幻读源于其他事务 insert 或 delete 了记录导致记录条数不一致。</code></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/xyy1028/article/details/106165503\" target=\"_blank\" >见</a></p>\n<h3 id=\"针对上面的三个问题，四大隔离级别：\"><a href=\"#针对上面的三个问题，四大隔离级别：\" class=\"headerlink\" title=\"针对上面的三个问题，四大隔离级别：\"></a>针对上面的三个问题，四大隔离级别：</h3><p><code>读未提交(read uncommitted)</code> : 不作任何隔离，具有脏读、不可重复读、幻读问题</p>\n<p><code>读已提交(read committed) </code>: 可防止脏读，不能防止不可重复读和幻读问题</p>\n<p><code>可重复读(repeatable read) </code>: 可以防止脏读、不可重复读，不能防止幻读问题（mysql 默认是这个隔离级别）</p>\n<p><code>串行化(serializable) </code>: 数据库运行在串行化，上述问题都可以防止，只是性能非常低<br>————————————————<br>版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/xyy1028/article/details/106165503\">https://blog.csdn.net/xyy1028/article/details/106165503</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202211291432266.webp\" style=\"width:500px;max-width:100%\" />\n\n<h3 id=\"这几个级别是什么意思，为什么这么命名？\"><a href=\"#这几个级别是什么意思，为什么这么命名？\" class=\"headerlink\" title=\"这几个级别是什么意思，为什么这么命名？\"></a>这几个级别是什么意思，为什么这么命名？</h3><ul>\n<li><code>读未提交(read uncommitted)</code> 事务 A 读到了事务 B 未提交的数据</li>\n<li><code>读已提交(read committed) </code> 事务 A 读到了事务 B 已提交的数据</li>\n<li><code>可重复读(repeatable read) </code>，事务 A 读到了快照，与事务 B 操作无关</li>\n</ul>\n<h3 id=\"可重复读级别出现读不到，但却可更新\"><a href=\"#可重复读级别出现读不到，但却可更新\" class=\"headerlink\" title=\"可重复读级别出现读不到，但却可更新\"></a>可重复读级别出现读不到，但却可更新</h3><p>为什么是这样呢？</p>\n<p>要了解这个原因,则还需要知道另一个概念:<code>MVCC</code></p>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><h4 id=\"为什么存在\"><a href=\"#为什么存在\" class=\"headerlink\" title=\"为什么存在\"></a>为什么存在</h4><p>是为了解决<code>rc</code>和<code>rr</code>现象，效率高开销低，避免加锁，设计的</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>MVCC 全称 Mutli Version Concurreny Control，多版本并发控制，是 MySQL 中基于<code>乐观锁</code>理论实现隔离级别的方式，用于实现<code>读已提交(read committed)</code>和<code>可重复读(repeatable read)</code>隔离级别的实现。<br>它通过行的多版本控制方式来读取当前执行时间数据库中的行数据。原理是<code>将数据保存在某个时间点(版本号)的快照来实现的</code>，MySQL 中 MVCC 的实现方式是在数据库保存最新版本的数据，但是会在使用 undo 时动态重构旧版本数据。这样就可以实现不加锁读。</p>\n<p>MVCC 可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此效率高开销低。MVCC 实现了非阻塞的读操作，写操作也只锁定必要的行。</p></blockquote>\n<h4 id=\"InnoDB-的-MVCC-实现机制\"><a href=\"#InnoDB-的-MVCC-实现机制\" class=\"headerlink\" title=\"InnoDB 的 MVCC 实现机制\"></a>InnoDB 的 MVCC 实现机制</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。<br>这两个列，<br>一个保存了行的创建时间，<br>一个保存行的过期时间（或删除时间）。</p>\n<p>当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在可重复读(repeatable read)隔离级别下，MVCC 具体是如何操作的：</p></blockquote>\n<h4 id=\"MySQL-中，会在表中每一条数据后面添加两个隐藏字段\"><a href=\"#MySQL-中，会在表中每一条数据后面添加两个隐藏字段\" class=\"headerlink\" title=\"MySQL 中，会在表中每一条数据后面添加两个隐藏字段:\"></a>MySQL 中，会在表中每一条数据后面添加两个隐藏字段:</h4><p><em>创建版本号：</em> 创建一行数据时，将当前系统版本号作为创建版本号赋值<br><em>删除版本号：</em> 删除一行数据时，将当前系统版本号作为删除版本号赋值</p>\n<h4 id=\"在-RR-隔离级别下，MVCC-的操作如下\"><a href=\"#在-RR-隔离级别下，MVCC-的操作如下\" class=\"headerlink\" title=\"在 RR 隔离级别下，MVCC 的操作如下:\"></a>在 RR 隔离级别下，MVCC 的操作如下:</h4><p>select 读取数据的规则必须同时满足以下两个条件：</p>\n<p><em>a. 创建版本号 &lt;&#x3D; 当前事务版本号:</em></p>\n<p>InnoDB 只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务本身插入或者修改过的。（这也是我们为什么在可重复读隔离级别下,读操作不会查到其他事务新增的数据,但是进行修改操作后却读出了三条数据的原因）</p>\n<p><em>b. 删除版本号为空 或 &gt; 当前事务版本号:</em></p>\n<p>这可以确保事务读取到的行，在事务开始之前未被删除。</p>\n<p><code>insert 操作:</code><br>InnoDB 为新插入的每一行保存当前系统版本号作为行的创建版本号。</p>\n<p><code>delete 操作:</code><br>InnoDB 为删除的每一行保存当前系统版本号作为行的删除版本号。</p>\n<p><code>update 操作:</code><br>插入一条新记录，保存当前系统版本号为行创建版本号，同时保存当前系统版本号到原来的行删除版本号，实际上这里的更新是通过 delete 和 insert 实现的。</p>\n<h4 id=\"快照读和当前读\"><a href=\"#快照读和当前读\" class=\"headerlink\" title=\"快照读和当前读\"></a>快照读和当前读</h4><p>MVCC 机制虽然让数据可重复读</p>\n<ul>\n<li>有时我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它<code>快照读(snapshot read)</code>，</li>\n<li>而读取数据库最新版本数据的方式，叫<code>当前读 (current read)</code>。</li>\n</ul>\n<h4 id=\"快照读：\"><a href=\"#快照读：\" class=\"headerlink\" title=\"快照读：\"></a>快照读：</h4><p><code>当执行 select 操作时 innodb 默认会执行快照读</code>，会记录下这次 select 后的结果，之后 select 的时候就会返回这次快照的数据，即使其他事务提交了也不会影响当前 select 的数据，这就实现了可重复读了。</p>\n<p>如上所示，开启了事务 A、B、C，</p>\n<ol>\n<li>这时候事务 A 插入了一条数据然后提交,</li>\n<li>然后事务 C 这时候执行 select，那么返回的数据中就会有事务 A 添加的那条数据。</li>\n<li>但是之后无论再有其他事务插入并提交数据都没有关系，因为快照已经生成了，事务 C 后面的 select 都是根据快照来的。</li>\n</ol>\n<h4 id=\"当前读：\"><a href=\"#当前读：\" class=\"headerlink\" title=\"当前读：\"></a>当前读：</h4><p><code>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。</code><br>在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。<br>假设要更新一条记录，但是在另一个事务中已经删除掉这条数据并且提交了，如果更新就会产生冲突，所以在 update 的时候需要知道最新的数据。</p>\n<h4 id=\"select-的当前读需要手动的加锁：\"><a href=\"#select-的当前读需要手动的加锁：\" class=\"headerlink\" title=\"select 的当前读需要手动的加锁：\"></a>select 的当前读需要手动的加锁：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select _ from user lock in share mode;\nselect _ from user for update;</code></pre>\n\n<p>综上所述，在快照读读情况下，MySQL 通过 MVCC 可以避免幻读。但是在当前读情况下幻读依然存在，所以说 MVCC 对于幻读的解决是不彻底的</p>\n<p>————————————————<br>版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/xyy1028/article/details/106165503\">https://blog.csdn.net/xyy1028/article/details/106165503</a></p>\n<h4 id=\"那么如何彻底解决幻读\"><a href=\"#那么如何彻底解决幻读\" class=\"headerlink\" title=\"那么如何彻底解决幻读\"></a>那么如何彻底解决幻读</h4><p><strong>法一：</strong>使用串行化读的隔离级别，但该方法效率太低。</p>\n<p><strong>法二：</strong>我们先大概看看 mysql InnoDB 引擎下的行锁:</p>\n<p><code>Record lock：</code>单个行记录上的锁<br><code>Gap lock：</code>间隙锁，锁定一个范围，不包括记录本身<br><code>Next-key lock：</code>Record + Gap 锁定一个范围，包含记录本身 <a href=\"https://www.zhihu.com/question/437140380#:~:text=%23-,%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F,-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB\" target=\"_blank\" ><code>【可能导致死锁现象】</code></a></p>\n<p>在纯粹的读操作时,Innodb 用 MVCC 解决幻读问题,新的 insert 和 update 不会阻塞。<br>在涉及到写操作时,Innodb 用 MVCC 和 Next-key lock 解决幻读问题,新的 insert 和 update 会阻塞。</p>\n<p>当我们为 select 后加上 for update 或者 lock in share mode,则查找到的行会被加上 Next-key lock</p>\n<h3 id=\"表锁定\"><a href=\"#表锁定\" class=\"headerlink\" title=\"表锁定\"></a>表锁定</h3><ul>\n<li><code>读锁</code>是<code>“共享”锁</code>，它可以防止正在获取写锁，但不能锁定其他读锁。</li>\n<li><code>写锁</code>是<code>“独占”锁</code>，可以防止任何其他类型的锁。</li>\n<li>如果会话正常或异常终止，MySQL 将<code>隐式释放所有锁</code>。此功能也与 WRITE 锁相关。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 要锁定表，请在LOCK TABLES关键字后指定其名称。此外，您可以指定锁的类型，可以是   READ或  WRITE。\nLOCK TABLES table_name [READ | WRITE]\n-- 要释放表的锁，请使用以下语句：\nUNLOCK TABLES;\n\n-- SHOW PROCESSLIST查看详细信息。\n\nmysql&gt; SHOW PROCESSLIST;\n+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+\n| Id   | User | Host            | db        | Command | Time | State                        | Info                            |\n+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+\n| 4884 | root | localhost:64108 | mysqldemo | Sleep   | 1479 |                              | NULL                            |\n| 4892 | root | localhost       | mysqldemo | Query   |    0 | init                         | SHOW PROCESSLIST                |\n| 4896 | root | localhost       | mysqldemo | Query   |   97 | Waiting for table level lock | INSERT INTO tbl(col) VALUES(20) |\n+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+\n3 rows in set (0.00 sec)\n</code></pre>\n\n<h3 id=\"行锁-x2F-记录锁-x2F-间隙锁-x2F-表锁\"><a href=\"#行锁-x2F-记录锁-x2F-间隙锁-x2F-表锁\" class=\"headerlink\" title=\"行锁&#x2F;记录锁&#x2F;间隙锁&#x2F;表锁\"></a>行锁&#x2F;记录锁&#x2F;间隙锁&#x2F;表锁</h3><ul>\n<li>行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from performance_schema.data_locks\\G;\n-- 这条语句，查看事务执行 SQL 过程中加了什么锁</code></pre>\n\n<p>LOCK_TYPE 中的 <code>RECORD 表示行级锁，而不是记录锁的意思</code>，</p>\n<p>通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p>\n<ul>\n<li>如果 LOCK_MODE 为 <code>X</code>，说明是 X 型的 next-key 锁；</li>\n<li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是 X 型的记录锁；</li>\n<li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是 X 型的间隙锁；</li>\n</ul>\n<p>作者：小林 coding<br>链接：<a href=\"https://www.zhihu.com/question/437140380/answer/2619527535\">https://www.zhihu.com/question/437140380/answer/2619527535</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"锁的退化\"><a href=\"#锁的退化\" class=\"headerlink\" title=\"锁的退化\"></a>锁的退化</h3><ul>\n<li>如果表中最后一个记录的 order_no 为 1005，那么等值查询 order_no &#x3D; 1006（不存在），就是 next key lock，如上面事务 A 的情况。</li>\n<li>如果表中最后一个记录的 order_no 为 1010，那么等值查询 order_no &#x3D; 1006（不存在），就是间隙锁</li>\n</ul>\n<pre class=\"line-numbers language-SQL\" data-language=\"SQL\"><code class=\"language-SQL\">-- 当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id &#x3D; 1008 的记录就会被锁住：\n--\nInsert into t_order (order_no, create_date) values (1008, now());</code></pre>\n\n<p><strong>而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。</strong><br><strong>而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 select … for update 语句并不会相互影响。</strong></p>\n<p>作者：小林 coding<br>链接：<a href=\"https://www.zhihu.com/question/437140380/answer/2619527535\">https://www.zhihu.com/question/437140380/answer/2619527535</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"MySQL-死锁产生的原因和解决方法\"><a href=\"#MySQL-死锁产生的原因和解决方法\" class=\"headerlink\" title=\"MySQL 死锁产生的原因和解决方法\"></a>MySQL 死锁产生的原因和解决方法</h3><h4 id=\"产生的条件\"><a href=\"#产生的条件\" class=\"headerlink\" title=\"产生的条件\"></a>产生的条件</h4><p>因争夺资源而造成的一种互相等待的现象</p>\n<p><strong>死锁的四个必要条件</strong>：<code>互斥</code>、<code>占有且等待</code>、<code>不可强占用</code>、<code>循环等待</code>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p>\n<p><a href=\"https://blog.csdn.net/java1527/article/details/127105144\" target=\"_blank\" >MySQL 死锁产生的原因和解决方法</a></p>\n<h4 id=\"规避措施\"><a href=\"#规避措施\" class=\"headerlink\" title=\"规避措施\"></a>规避措施</h4><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p>\n<ul>\n<li><code>设置事务等待锁的超时时间</code>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</li>\n<li><code>开启主动死锁检测</code>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</li>\n</ul>\n<p>作者：小林 coding<br>链接：<a href=\"https://www.zhihu.com/question/437140380/answer/2619527535\">https://www.zhihu.com/question/437140380/answer/2619527535</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/xyy1028/article/details/106165503\" target=\"_blank\" >Mysql 事务</a></p>\n","text":"事务为什么需要事务MySQL 事务允许您执行一组 MySQL 操作，以确保数据库永远不会包含部分操作的结果。 在一组操作中，如果其中一个操作失败，则会发生回滚以将数据库还原到其原始状态。 如果没有发生错误，则将整个语句集提交给数据库。 事务特点事务是必须满足 4 个条件(ACID...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">事务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">为什么需要事务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">事务特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mysql-%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">mysql 隔离机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%80%A7%E5%87%BA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">并发导致事务隔离性出问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB\"><span class=\"toc-text\">脏读、不可重复读、幻读</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%92%88%E5%AF%B9%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">针对上面的三个问题，四大隔离级别：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%99%E5%87%A0%E4%B8%AA%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%91%BD%E5%90%8D%EF%BC%9F\"><span class=\"toc-text\">这几个级别是什么意思，为什么这么命名？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%BA%A7%E5%88%AB%E5%87%BA%E7%8E%B0%E8%AF%BB%E4%B8%8D%E5%88%B0%EF%BC%8C%E4%BD%86%E5%8D%B4%E5%8F%AF%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">可重复读级别出现读不到，但却可更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MVCC\"><span class=\"toc-text\">MVCC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">为什么存在</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#InnoDB-%E7%9A%84-MVCC-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">InnoDB 的 MVCC 实现机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MySQL-%E4%B8%AD%EF%BC%8C%E4%BC%9A%E5%9C%A8%E8%A1%A8%E4%B8%AD%E6%AF%8F%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%90%8E%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%A4%E4%B8%AA%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">MySQL 中，会在表中每一条数据后面添加两个隐藏字段:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8-RR-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8CMVCC-%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B\"><span class=\"toc-text\">在 RR 隔离级别下，MVCC 的操作如下:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB\"><span class=\"toc-text\">快照读和当前读</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9A\"><span class=\"toc-text\">快照读：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%9A\"><span class=\"toc-text\">当前读：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#select-%E7%9A%84%E5%BD%93%E5%89%8D%E8%AF%BB%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E7%9A%84%E5%8A%A0%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">select 的当前读需要手动的加锁：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB\"><span class=\"toc-text\">那么如何彻底解决幻读</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E9%94%81%E5%AE%9A\"><span class=\"toc-text\">表锁定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E9%94%81-x2F-%E8%AE%B0%E5%BD%95%E9%94%81-x2F-%E9%97%B4%E9%9A%99%E9%94%81-x2F-%E8%A1%A8%E9%94%81\"><span class=\"toc-text\">行锁&#x2F;记录锁&#x2F;间隙锁&#x2F;表锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%81%E7%9A%84%E9%80%80%E5%8C%96\"><span class=\"toc-text\">锁的退化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MySQL-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">MySQL 死锁产生的原因和解决方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">产生的条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%84%E9%81%BF%E6%8E%AA%E6%96%BD\"><span class=\"toc-text\">规避措施</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"5.系统学习 mysql erd","uid":"50df4ae65a1c6c2ab192fc07c4455498","slug":"2022-11-30mysql-erd","date":"2022-11-30T09:13:32.000Z","updated":"2022-11-30T13:38:57.490Z","comments":true,"path":"api/articles/2022-11-30mysql-erd.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","text":"ERER 实体关系 Entity RelationshipER 图鱼尾符号demo1 见 demo2 见 vscode vuerd-vscode 插件自动生成这个图是自动生成的， 1 对多0&#x2F;1 对多 这些事如何在 sql 中体现的？难道是对数据进行分析 vuerd-v...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"3.系统学习 mysql CRUD","uid":"c0939ae244a4c8b0accf26e60862ce5e","slug":"2022-11-30mysql-crud","date":"2022-11-30T01:32:15.000Z","updated":"2022-12-02T14:13:36.772Z","comments":true,"path":"api/articles/2022-11-30mysql-crud.json","keywords":null,"cover":"https://img2.baidu.com/it/u=3082189317,4216979427&fm=253&fmt=auto&app=120&f=PNG?w=1000&h=500","text":"增INSERT &#x2F; INSERT INTO SELECT 单行插入 多行插入 默认值插入 日期值插入 -- 单行&#x2F;多行插入 INSERT INTO table_name(c1,c2,...) VALUES(v1,v2,..); -- 多行插入 INSERT I...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/categories/Mysql.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":12,"path":"api/tags/Mysql.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}