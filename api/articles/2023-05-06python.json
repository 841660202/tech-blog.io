{"title":"Python 编程语言的基本语法","uid":"63b21671e504fbf555fa8354eb1a75b6","slug":"2023-05-06python","date":"2023-05-06T09:44:08.000Z","updated":"2023-05-29T00:41:07.264Z","comments":true,"path":"api/articles/2023-05-06python.json","keywords":null,"cover":null,"content":"<h2 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h2><p>用不用的着我就想学，咋滴～，距去年国庆学的 Python 和 Django 有半年了，原计划五一劳动节再学一遍 Python 的，结果呢–看“仙侠剧”、搓饭、遛猫（真的是遛猫不是遛狗），五一就没了，😅</p>\n<h2 id=\"理解-python-特性\"><a href=\"#理解-python-特性\" class=\"headerlink\" title=\"理解 python 特性\"></a>理解 python 特性</h2><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</p>\n<p>Python 的设计<strong>具有很强的可读性</strong>，它具有比其他语言<strong>更有特色语法结构</strong>。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>Python 是一种简单易学、可读性强的编程语言，它的语法也相对简单。下面是 Python 基本语法的介绍：</p>\n<ol>\n<li>注释</li>\n</ol>\n<p>Python 中的注释以 # 开头，可以在代码中添加说明和解释。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 这是一条注释\n\nprint(&quot;Hello, world!&quot;)  # 这也是一条注释</code></pre>\n\n<ol start=\"2\">\n<li>变量</li>\n</ol>\n<p>Python 中的变量名可以包含字母、数字和下划线，但不能以数字开头。变量名区分大小写。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; 1\ny &#x3D; 2\nz &#x3D; &quot;hello&quot;</code></pre>\n\n<ol start=\"3\">\n<li>数据类型</li>\n</ol>\n<p>Python 支持多种数据类型，包括整数、浮点数、字符串、布尔值、列表、元组、字典等。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; 1  # 整数\nb &#x3D; 3.14  # 浮点数\nc &#x3D; &quot;hello&quot;  # 字符串\nd &#x3D; True  # 布尔值\ne &#x3D; [1, 2, 3]  # 列表\nf &#x3D; (4, 5, 6)  # 元组\ng &#x3D; &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20&#125;  # 字典</code></pre>\n\n<ol start=\"4\">\n<li>控制流语句</li>\n</ol>\n<p>Python 中的控制流语句包括条件语句和循环语句。条件语句使用 if、elif 和 else 关键字，循环语句使用 for 和 while 关键字。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 条件语句\nx &#x3D; 10\nif x &gt; 0:\n    print(&quot;x is positive&quot;)\nelif x &#x3D;&#x3D; 0:\n    print(&quot;x is zero&quot;)\nelse:\n    print(&quot;x is negative&quot;)\n\n# 循环语句\nfor i in range(5):\n    print(i)\n\nwhile x &gt; 0:\n    x -&#x3D; 1\n    print(x)</code></pre>\n\n<ol start=\"5\">\n<li>函数</li>\n</ol>\n<p>Python 中使用 def 关键字定义函数，函数可以接受参数和返回值。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def add(x, y):\n    return x + y\n\nresult &#x3D; add(1, 2)\nprint(result)</code></pre>\n\n<p>以上是 Python 编程语言的基本语法介绍，掌握这些基础语法后，可以开始编写简单的 Python 程序。</p>\n<h1 id=\"字符串格式化-4-种方式\"><a href=\"#字符串格式化-4-种方式\" class=\"headerlink\" title=\"字符串格式化 4 种方式\"></a>字符串格式化 4 种方式</h1><p>在 Python 3 中，有多种方式可以进行字符串格式化。以下是一些常见的字符串格式化方法：</p>\n<ol>\n<li>使用百分号（%）格式化字符串：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">name &#x3D; &quot;John&quot;\nage &#x3D; 30\nmessage &#x3D; &quot;My name is %s and I am %d years old.&quot; % (name, age)\nprint(message)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">My name is John and I am 30 years old.</code></pre>\n\n<ol start=\"2\">\n<li>使用大括号（{}）和 <code>format()</code> 方法格式化字符串：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">name &#x3D; &quot;John&quot;\nage &#x3D; 30\nmessage &#x3D; &quot;My name is &#123;&#125; and I am &#123;&#125; years old.&quot;.format(name, age)\nprint(message)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">My name is John and I am 30 years old.</code></pre>\n\n<ol start=\"3\">\n<li>使用 f-string（格式化字符串字面值）：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">name &#x3D; &quot;John&quot;\nage &#x3D; 30\nmessage &#x3D; f&quot;My name is &#123;name&#125; and I am &#123;age&#125; years old.&quot;\nprint(message)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">My name is John and I am 30 years old.</code></pre>\n\n<ol start=\"4\">\n<li>使用模板字符串：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from string import Template\n\nname &#x3D; &quot;John&quot;\nage &#x3D; 30\ntemplate &#x3D; Template(&quot;My name is $name and I am $age years old.&quot;)\nmessage &#x3D; template.substitute(name&#x3D;name, age&#x3D;age)\nprint(message)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">My name is John and I am 30 years old.</code></pre>\n\n<p>这些是 Python 3 中常用的字符串格式化方法。每种方法都有自己的特点和用法，你可以根据需要选择适合的方式来格式化字符串。请注意，f-string 是 Python 3.6 引入的新特性，它提供了一种简洁且直观的字符串格式化语法。</p>\n<h2 id=\"字符串内置函数分类\"><a href=\"#字符串内置函数分类\" class=\"headerlink\" title=\"字符串内置函数分类\"></a>字符串内置函数分类</h2><p>字符串在 Python 中是不可变的对象，它提供了许多内置函数来操作和处理字符串。这些内置函数可以按照功能进行分类，以下是字符串内置函数的常见分类：</p>\n<ol>\n<li>访问和索引：</li>\n</ol>\n<ul>\n<li><code>len()</code>: 返回字符串的长度。</li>\n<li>索引和切片操作：可以通过索引或切片来访问字符串中的单个字符或子串。</li>\n</ul>\n<ol start=\"2\">\n<li>查找和匹配：</li>\n</ol>\n<ul>\n<li><code>find()</code>: 在字符串中查找指定的子串，并返回第一个匹配的索引。</li>\n<li><code>index()</code>: 类似于 <code>find()</code>，但如果找不到匹配的子串，会抛出异常。</li>\n<li><code>count()</code>: 统计字符串中指定子串的出现次数。</li>\n<li><code>startswith()</code>: 检查字符串是否以指定的子串开头。</li>\n<li><code>endswith()</code>: 检查字符串是否以指定的子串结尾。</li>\n<li><code>replace()</code>: 替换字符串中的子串。</li>\n<li><code>split()</code>: 将字符串拆分为子串，并返回一个列表。</li>\n<li><code>join()</code>: 将多个字符串连接成一个字符串。</li>\n</ul>\n<ol start=\"3\">\n<li>大小写转换：</li>\n</ol>\n<ul>\n<li><code>lower()</code>: 将字符串转换为小写。</li>\n<li><code>upper()</code>: 将字符串转换为大写。</li>\n<li><code>capitalize()</code>: 将字符串首字母大写。</li>\n<li><code>title()</code>: 将字符串中每个单词的首字母大写。</li>\n</ul>\n<ol start=\"4\">\n<li>格式化和对齐：</li>\n</ol>\n<ul>\n<li><code>format()</code>: 格式化字符串，用于替换占位符。</li>\n<li><code>strip()</code>: 去除字符串两端的空白字符。</li>\n<li><code>lstrip()</code>: 去除字符串左侧的空白字符。</li>\n<li><code>rstrip()</code>: 去除字符串右侧的空白字符。</li>\n<li><code>center()</code>: 将字符串居中对齐。</li>\n<li><code>ljust()</code>: 将字符串左对齐。</li>\n<li><code>rjust()</code>: 将字符串右对齐。</li>\n</ul>\n<ol start=\"5\">\n<li>判断字符类型：</li>\n</ol>\n<ul>\n<li><code>isdigit()</code>: 判断字符串是否只包含数字字符。</li>\n<li><code>isalpha()</code>: 判断字符串是否只包含字母字符。</li>\n<li><code>isalnum()</code>: 判断字符串是否只包含字母和数字字符。</li>\n<li><code>islower()</code>: 判断字符串中的字母是否都为小写。</li>\n<li><code>isupper()</code>: 判断字符串中的字母是否都为大写。</li>\n<li><code>isspace()</code>: 判断字符串是否只包含空白字符。</li>\n</ul>\n<p>这只是字符串内置函数的一部分，还有其他一些函数可以用于字符串操作。根据需要选择适当的函数来处理和操作字符串，可以实现各种字符串处理的需求。</p>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><h2 id=\"元组使用场景\"><a href=\"#元组使用场景\" class=\"headerlink\" title=\"元组使用场景\"></a>元组使用场景</h2><p>元组是 Python 中的不可变序列，它可以包含多个元素，并且元素的顺序是固定的。元组在以下场景中非常有用：</p>\n<ol>\n<li><p><code>定义不可变数据集合</code>：由于元组是不可变的，它们适合用于表示不可修改的数据集合。例如，你可以使用元组来表示一组坐标点、一组配置参数或者一组常量值。</p>\n</li>\n<li><p><code>函数返回多个值</code>：函数可以返回多个值，而元组是一种便捷的方式来组织和返回多个值。函数可以将这些值封装在一个元组中，并且调用函数的代码可以使用元组解包来获取这些值。</p>\n</li>\n<li><p><code>解构赋值</code>：元组可以在解构赋值中使用，它们可以方便地将一个序列的元素分解为多个变量。这在交换变量的值、并行迭代和函数返回多个值时非常有用。</p>\n</li>\n<li><p><code>作为字典的键</code>：字典中的键必须是可哈希的，而元组是不可变的，因此可以用作字典中的键。这对于需要将多个值映射到特定结果的情况很有用。</p>\n</li>\n<li><p><code>函数参数传递</code>：元组可以作为函数的参数进行传递，以便将多个值一起传递给函数。这对于需要将多个相关参数传递给函数的情况很有用。</p>\n</li>\n</ol>\n<p>需要注意的是，由于元组是不可变的，无法对其进行修改。如果需要在运行时修改数据，应使用列表。元组更适合用于表示静态数据和不可变的集合。</p>\n<p>总的来说，元组是一种用于存储不可变数据集合的数据结构，在多个值的组织、多个返回值的情况下以及作为字典键等方面非常有用。</p>\n<h2 id=\"元组操作\"><a href=\"#元组操作\" class=\"headerlink\" title=\"元组操作\"></a>元组操作</h2><p>元组是 Python 中的不可变序列，具有以下操作和特性：</p>\n<h3 id=\"创建元组：\"><a href=\"#创建元组：\" class=\"headerlink\" title=\"创建元组：\"></a>创建元组：</h3><ul>\n<li>使用逗号分隔的值来创建元组：<code>my_tuple = (1, 2, 3)</code></li>\n<li>使用圆括号创建元组：<code>my_tuple = tuple((1, 2, 3))</code></li>\n</ul>\n<h3 id=\"访问元组元素：\"><a href=\"#访问元组元素：\" class=\"headerlink\" title=\"访问元组元素：\"></a>访问元组元素：</h3><ul>\n<li>使用索引访问元组中的特定元素：<code>print(my_tuple[0])</code>，输出为 1</li>\n<li>可以使用负数索引从后向前访问元素：<code>print(my_tuple[-1])</code>，输出为 3</li>\n</ul>\n<h3 id=\"切片操作：\"><a href=\"#切片操作：\" class=\"headerlink\" title=\"切片操作：\"></a>切片操作：</h3><ul>\n<li>使用切片操作访问元组的子集：<code>print(my_tuple[1:3])</code>，输出为 (2, 3)</li>\n<li>可以指定步长：<code>print(my_tuple[::2])</code>，输出为 (1, 3)</li>\n</ul>\n<h3 id=\"元组拼接：\"><a href=\"#元组拼接：\" class=\"headerlink\" title=\"元组拼接：\"></a>元组拼接：</h3><ul>\n<li>使用加号操作符将两个元组拼接在一起：<code>new_tuple = my_tuple + (4, 5)</code></li>\n</ul>\n<h3 id=\"元组解包：\"><a href=\"#元组解包：\" class=\"headerlink\" title=\"元组解包：\"></a>元组解包：</h3><ul>\n<li>可以将元组的元素解包到多个变量中：<code>x, y, z = my_tuple</code></li>\n</ul>\n<h3 id=\"长度和计数：\"><a href=\"#长度和计数：\" class=\"headerlink\" title=\"长度和计数：\"></a>长度和计数：</h3><ul>\n<li>使用 <code>len()</code> 函数获取元组的长度：<code>length = len(my_tuple)</code></li>\n<li>使用 <code>count()</code> 方法计算元素在元组中的出现次数：<code>count = my_tuple.count(2)</code></li>\n</ul>\n<h3 id=\"元组不可变性：\"><a href=\"#元组不可变性：\" class=\"headerlink\" title=\"元组不可变性：\"></a>元组不可变性：</h3><ul>\n<li>元组的元素不可被修改，如果尝试修改元组中的元素，将会引发 TypeError。</li>\n</ul>\n<p>需要注意的是，元组是不可变的，一旦创建就无法修改其中的元素。如果需要修改元素，应该使用列表。元组主要用于存储静态数据和不可变的集合。</p>\n<p>以上是一些常见的元组操作和用法。通过这些操作，你可以创建、访问和操作元组中的数据。</p>\n<h2 id=\"元组内置函数\"><a href=\"#元组内置函数\" class=\"headerlink\" title=\"元组内置函数\"></a>元组内置函数</h2><p>元组是 Python 中的不可变序列，它具有一些内置函数可用于处理和操作元组。以下是一些常用的元组内置函数：</p>\n<h3 id=\"len-tuple-：返回元组中元素的个数。\"><a href=\"#len-tuple-：返回元组中元素的个数。\" class=\"headerlink\" title=\"len(tuple)：返回元组中元素的个数。\"></a>len(tuple)：返回元组中元素的个数。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_tuple &#x3D; (1, 2, 3, 4, 5)\nlength &#x3D; len(my_tuple)\nprint(length)  # 输出 5</code></pre>\n\n<h3 id=\"tuple-iterable-：将可迭代对象转换为元组。\"><a href=\"#tuple-iterable-：将可迭代对象转换为元组。\" class=\"headerlink\" title=\"tuple(iterable)：将可迭代对象转换为元组。\"></a>tuple(iterable)：将可迭代对象转换为元组。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_list &#x3D; [1, 2, 3, 4, 5]\nmy_tuple &#x3D; tuple(my_list)\nprint(my_tuple)  # 输出 (1, 2, 3, 4, 5)</code></pre>\n\n<h3 id=\"count-value-：返回元组中指定值的出现次数。\"><a href=\"#count-value-：返回元组中指定值的出现次数。\" class=\"headerlink\" title=\"count(value)：返回元组中指定值的出现次数。\"></a>count(value)：返回元组中指定值的出现次数。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_tuple &#x3D; (1, 2, 2, 3, 2, 4, 2)\ncount &#x3D; my_tuple.count(2)\nprint(count)  # 输出 4</code></pre>\n\n<h3 id=\"index-value-：返回元组中指定值第一次出现的索引位置。\"><a href=\"#index-value-：返回元组中指定值第一次出现的索引位置。\" class=\"headerlink\" title=\"index(value)：返回元组中指定值第一次出现的索引位置。\"></a>index(value)：返回元组中指定值第一次出现的索引位置。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_tuple &#x3D; (1, 2, 3, 4, 5)\nindex &#x3D; my_tuple.index(3)\nprint(index)  # 输出 2</code></pre>\n\n<p>这些是元组的一些常用内置函数，它们可用于获取元组的长度、转换为元组、计算指定值的出现次数以及查找指定值的索引位置。除了这些内置函数，元组还可以使用切片操作、拼接操作等进行处理和操作。</p>\n<h2 id=\"元组中的项无法删除？\"><a href=\"#元组中的项无法删除？\" class=\"headerlink\" title=\"元组中的项无法删除？\"></a>元组中的项无法删除？</h2><p>在 Python 中，元组是不可变的数据类型，这意味着一旦创建了元组，就无法修改或删除其中的项。元组的不可变性是其特性之一。</p>\n<p>如果你想删除元组中的特定项，你需要创建一个新的元组，并排除需要删除的项。例如，你可以使用切片操作来创建一个不包含要删除项的新元组：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_tuple &#x3D; (1, 2, 3, 4, 5)\nnew_tuple &#x3D; my_tuple[:2] + my_tuple[3:]\nprint(new_tuple)  # 输出 (1, 2, 4, 5)</code></pre>\n\n<p>在上面的例子中，我们创建了一个新的元组 <code>new_tuple</code>，通过切片操作排除了索引为 2 的项（值为 3）。这样就实现了在元组中删除特定项的效果。</p>\n<p>需要注意的是，虽然可以通过切片操作创建一个新的元组来达到删除项的目的，但实际上并没有删除原始元组中的项。由于元组的不可变性，无法直接在原始元组中删除或修改项。因此，如果需要频繁地进行删除或修改操作，可能更适合使用列表（List）数据类型，因为列表是可变的。</p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><h2 id=\"字典内置函数-amp-方法\"><a href=\"#字典内置函数-amp-方法\" class=\"headerlink\" title=\"字典内置函数&amp;方法\"></a>字典内置函数&amp;方法</h2><p>字典是 Python 中的一种数据结构，它存储键值对的映射关系。字典具有许多内置函数和方法，可以用于处理和操作字典。下面是一些常用的字典内置函数和方法：</p>\n<p>内置函数：</p>\n<h3 id=\"len-dict-：返回字典中键值对的数量。\"><a href=\"#len-dict-：返回字典中键值对的数量。\" class=\"headerlink\" title=\"len(dict)：返回字典中键值对的数量。\"></a>len(dict)：返回字典中键值对的数量。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nlength &#x3D; len(my_dict)\nprint(length)  # 输出 3</code></pre>\n\n<h3 id=\"str-dict-：将字典转换为可打印的字符串表示。\"><a href=\"#str-dict-：将字典转换为可打印的字符串表示。\" class=\"headerlink\" title=\"str(dict)：将字典转换为可打印的字符串表示。\"></a>str(dict)：将字典转换为可打印的字符串表示。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nstr_dict &#x3D; str(my_dict)\nprint(str_dict)  # 输出 &quot;&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;&quot;</code></pre>\n\n<h3 id=\"dict-：创建一个新的字典或将可迭代对象转换为字典。\"><a href=\"#dict-：创建一个新的字典或将可迭代对象转换为字典。\" class=\"headerlink\" title=\"dict()：创建一个新的字典或将可迭代对象转换为字典。\"></a>dict()：创建一个新的字典或将可迭代对象转换为字典。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">new_dict &#x3D; dict()\nprint(new_dict)  # 输出 &#123;&#125;</code></pre>\n\n<p>字典方法：</p>\n<h3 id=\"keys-：返回一个包含字典所有键的视图对象。\"><a href=\"#keys-：返回一个包含字典所有键的视图对象。\" class=\"headerlink\" title=\"keys()：返回一个包含字典所有键的视图对象。\"></a>keys()：返回一个包含字典所有键的视图对象。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nkeys &#x3D; my_dict.keys()\nprint(keys)  # 输出 dict_keys([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code></pre>\n\n<h3 id=\"values-：返回一个包含字典所有值的视图对象。\"><a href=\"#values-：返回一个包含字典所有值的视图对象。\" class=\"headerlink\" title=\"values()：返回一个包含字典所有值的视图对象。\"></a>values()：返回一个包含字典所有值的视图对象。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nvalues &#x3D; my_dict.values()\nprint(values)  # 输出 dict_values([1, 2, 3])</code></pre>\n\n<h3 id=\"items-：返回一个包含字典所有键值对的视图对象。\"><a href=\"#items-：返回一个包含字典所有键值对的视图对象。\" class=\"headerlink\" title=\"items()：返回一个包含字典所有键值对的视图对象。\"></a>items()：返回一个包含字典所有键值对的视图对象。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nitems &#x3D; my_dict.items()\nprint(items)  # 输出 dict_items([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])</code></pre>\n\n<h3 id=\"get-key-default-：获取指定键的值，如果键不存在，则返回默认值。\"><a href=\"#get-key-default-：获取指定键的值，如果键不存在，则返回默认值。\" class=\"headerlink\" title=\"get(key, default)：获取指定键的值，如果键不存在，则返回默认值。\"></a>get(key, default)：获取指定键的值，如果键不存在，则返回默认值。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nvalue &#x3D; my_dict.get(&#39;a&#39;, 0)\nprint(value)  # 输出 1\nvalue &#x3D; my_dict.get(&#39;d&#39;, 0)\nprint(value)  # 输出 0</code></pre>\n\n<h3 id=\"setdefault-key-default-：返回指定键的值，如果键不存在，则插入指定的键值对，并返回默认值。\"><a href=\"#setdefault-key-default-：返回指定键的值，如果键不存在，则插入指定的键值对，并返回默认值。\" class=\"headerlink\" title=\"setdefault(key, default)：返回指定键的值，如果键不存在，则插入指定的键值对，并返回默认值。\"></a>setdefault(key, default)：返回指定键的值，如果键不存在，则插入指定的键值对，并返回默认值。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\nvalue &#x3D; my_dict.setdefault(&#39;c&#39;, 3)\nprint(value) # 输出 3\nprint(my_dict) # 输出 &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</code></pre>\n\n<h3 id=\"clear-：清空字典中的所有键值对，使字典变为空字典。\"><a href=\"#clear-：清空字典中的所有键值对，使字典变为空字典。\" class=\"headerlink\" title=\"clear()：清空字典中的所有键值对，使字典变为空字典。\"></a>clear()：清空字典中的所有键值对，使字典变为空字典。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nmy_dict.clear()\nprint(my_dict)  # 输出 &#123;&#125;</code></pre>\n\n<h3 id=\"copy-：创建字典的浅拷贝（shallow-copy）。\"><a href=\"#copy-：创建字典的浅拷贝（shallow-copy）。\" class=\"headerlink\" title=\"copy()：创建字典的浅拷贝（shallow copy）。\"></a>copy()：创建字典的浅拷贝（shallow copy）。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nnew_dict &#x3D; my_dict.copy()\nprint(new_dict)  # 输出 &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</code></pre>\n\n<h3 id=\"update-：将一个字典的键值对添加到另一个字典中，如果键存在，则更新对应的值。\"><a href=\"#update-：将一个字典的键值对添加到另一个字典中，如果键存在，则更新对应的值。\" class=\"headerlink\" title=\"update()：将一个字典的键值对添加到另一个字典中，如果键存在，则更新对应的值。\"></a>update()：将一个字典的键值对添加到另一个字典中，如果键存在，则更新对应的值。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\nother_dict &#x3D; &#123;&#39;c&#39;: 3, &#39;d&#39;: 4&#125;\nmy_dict.update(other_dict)\nprint(my_dict)  # 输出 &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</code></pre>\n\n<h3 id=\"pop-key-default-：移除并返回指定键的值，如果键不存在，则返回默认值。如果不提供默认值且键不存在，则会引发-KeyError。\"><a href=\"#pop-key-default-：移除并返回指定键的值，如果键不存在，则返回默认值。如果不提供默认值且键不存在，则会引发-KeyError。\" class=\"headerlink\" title=\"pop(key, default)：移除并返回指定键的值，如果键不存在，则返回默认值。如果不提供默认值且键不存在，则会引发 KeyError。\"></a>pop(key, default)：移除并返回指定键的值，如果键不存在，则返回默认值。如果不提供默认值且键不存在，则会引发 KeyError。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nvalue &#x3D; my_dict.pop(&#39;a&#39;)\nprint(value)  # 输出 1\nvalue &#x3D; my_dict.pop(&#39;d&#39;, 0)\nprint(value)  # 输出 0</code></pre>\n\n<h3 id=\"popitem-：移除并返回字典中的一对键值对。字典是无序的，所以不保证具体移除的是哪个键值对。\"><a href=\"#popitem-：移除并返回字典中的一对键值对。字典是无序的，所以不保证具体移除的是哪个键值对。\" class=\"headerlink\" title=\"popitem()：移除并返回字典中的一对键值对。字典是无序的，所以不保证具体移除的是哪个键值对。\"></a>popitem()：移除并返回字典中的一对键值对。字典是无序的，所以不保证具体移除的是哪个键值对。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nkey, value &#x3D; my_dict.popitem()\nprint(key, value)  # 输出 &#39;c&#39;, 3</code></pre>\n\n<p>这些方法提供了对字典进行操作和管理的更多选项。通过它们，你可以清空字典、创建拷贝、更新键值对、移除键值对等。这些方法可以根据你的需求来选择和使用。</p>\n<h3 id=\"key-in-dict-是一个用于判断字典中是否存在指定键的成员运算符。它返回一个布尔值，如果字典中包含指定的键，则返回-True，否则返回-False。\"><a href=\"#key-in-dict-是一个用于判断字典中是否存在指定键的成员运算符。它返回一个布尔值，如果字典中包含指定的键，则返回-True，否则返回-False。\" class=\"headerlink\" title=\"key in dict 是一个用于判断字典中是否存在指定键的成员运算符。它返回一个布尔值，如果字典中包含指定的键，则返回 True，否则返回 False。\"></a><code>key in dict</code> 是一个用于判断字典中是否存在指定键的成员运算符。它返回一个布尔值，如果字典中包含指定的键，则返回 True，否则返回 False。</h3><p>下面是示例代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n\nprint(&#39;a&#39; in my_dict)  # 输出 True\nprint(&#39;d&#39; in my_dict)  # 输出 False</code></pre>\n\n<p>在上面的例子中，我们使用 <code>in</code> 运算符来判断字典 <code>my_dict</code> 中是否存在键 <code>&#39;a&#39;</code> 和 <code>&#39;d&#39;</code>。由于字典中包含键 <code>&#39;a&#39;</code>，因此第一个判断返回 True；而字典中不包含键 <code>&#39;d&#39;</code>，所以第二个判断返回 False。</p>\n<p>使用 <code>key in dict</code> 这个成员运算符是一种简洁且常用的方式来检查字典中是否存在指定的键。</p>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h2 id=\"集合使用场景\"><a href=\"#集合使用场景\" class=\"headerlink\" title=\"集合使用场景\"></a>集合使用场景</h2><p>集合（Set）是 Python 中的一种无序且不重复的数据结构。集合内的元素是唯一的，没有顺序。集合提供了一些特殊的操作，使其在某些场景下非常有用。以下是集合的一些常见使用场景：</p>\n<h3 id=\"1-去重：由于集合中的元素是唯一的，可以使用集合来快速去除列表或其他可迭代对象中的重复元素。\"><a href=\"#1-去重：由于集合中的元素是唯一的，可以使用集合来快速去除列表或其他可迭代对象中的重复元素。\" class=\"headerlink\" title=\"1. 去重：由于集合中的元素是唯一的，可以使用集合来快速去除列表或其他可迭代对象中的重复元素。\"></a>1. 去重：由于集合中的元素是唯一的，可以使用集合来快速去除列表或其他可迭代对象中的重复元素。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_list &#x3D; [1, 2, 2, 3, 4, 4, 5]\nmy_set &#x3D; set(my_list)\nprint(my_set)  # 输出 &#123;1, 2, 3, 4, 5&#125;</code></pre>\n\n<h3 id=\"2-成员检查：集合提供了高效的成员检查操作，可以快速判断一个元素是否存在于集合中。\"><a href=\"#2-成员检查：集合提供了高效的成员检查操作，可以快速判断一个元素是否存在于集合中。\" class=\"headerlink\" title=\"2. 成员检查：集合提供了高效的成员检查操作，可以快速判断一个元素是否存在于集合中。\"></a>2. 成员检查：集合提供了高效的成员检查操作，可以快速判断一个元素是否存在于集合中。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3, 4, 5&#125;\nprint(3 in my_set)  # 输出 True\nprint(6 in my_set)  # 输出 False</code></pre>\n\n<h3 id=\"3-集合运算：集合支持并集、交集、差集等常见的集合运算，可以方便地进行集合间的操作。\"><a href=\"#3-集合运算：集合支持并集、交集、差集等常见的集合运算，可以方便地进行集合间的操作。\" class=\"headerlink\" title=\"3. 集合运算：集合支持并集、交集、差集等常见的集合运算，可以方便地进行集合间的操作。\"></a>3. 集合运算：集合支持并集、交集、差集等常见的集合运算，可以方便地进行集合间的操作。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7, 8&#125;\nunion &#x3D; set1 | set2  # 并集\nintersection &#x3D; set1 &amp; set2  # 交集\ndifference &#x3D; set1 - set2  # 差集\nprint(union)  # 输出 &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;\nprint(intersection)  # 输出 &#123;4, 5&#125;\nprint(difference)  # 输出 &#123;1, 2, 3&#125;</code></pre>\n\n<h3 id=\"4-集合操作：集合支持添加元素、删除元素等操作，可以动态地修改集合内容。\"><a href=\"#4-集合操作：集合支持添加元素、删除元素等操作，可以动态地修改集合内容。\" class=\"headerlink\" title=\"4. 集合操作：集合支持添加元素、删除元素等操作，可以动态地修改集合内容。\"></a>4. 集合操作：集合支持添加元素、删除元素等操作，可以动态地修改集合内容。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.add(4)  # 添加元素\nmy_set.remove(2)  # 删除元素\nprint(my_set)  # 输出 &#123;1, 3, 4&#125;</code></pre>\n\n<p>这些是集合的一些常见使用场景。总的来说，当你需要处理无序且不重复的数据，或者需要进行成员检查、集合运算等操作时，集合是一个非常有用的数据结构。</p>\n<h2 id=\"集合内置方法完整列表-及-示例\"><a href=\"#集合内置方法完整列表-及-示例\" class=\"headerlink\" title=\"集合内置方法完整列表 及 示例\"></a>集合内置方法完整列表 及 示例</h2><p>下面是集合（Set）的完整内置方法列表以及示例：</p>\n<h3 id=\"add-element-向集合中添加一个元素。\"><a href=\"#add-element-向集合中添加一个元素。\" class=\"headerlink\" title=\"add(element): 向集合中添加一个元素。\"></a><code>add(element)</code>: 向集合中添加一个元素。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.add(4)\nprint(my_set)  # 输出 &#123;1, 2, 3, 4&#125;</code></pre>\n\n<h3 id=\"clear-清空集合中的所有元素。\"><a href=\"#clear-清空集合中的所有元素。\" class=\"headerlink\" title=\"clear(): 清空集合中的所有元素。\"></a><code>clear()</code>: 清空集合中的所有元素。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.clear()\nprint(my_set)  # 输出 set()</code></pre>\n\n<h3 id=\"copy-创建集合的浅拷贝（shallow-copy）。\"><a href=\"#copy-创建集合的浅拷贝（shallow-copy）。\" class=\"headerlink\" title=\"copy(): 创建集合的浅拷贝（shallow copy）。\"></a><code>copy()</code>: 创建集合的浅拷贝（shallow copy）。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3&#125;\nnew_set &#x3D; my_set.copy()\nprint(new_set)  # 输出 &#123;1, 2, 3&#125;</code></pre>\n\n<h3 id=\"difference-others-返回当前集合与其他集合的差集，即在当前集合中但不在其他集合中的元素组成的集合。\"><a href=\"#difference-others-返回当前集合与其他集合的差集，即在当前集合中但不在其他集合中的元素组成的集合。\" class=\"headerlink\" title=\"difference(*others): 返回当前集合与其他集合的差集，即在当前集合中但不在其他集合中的元素组成的集合。\"></a><code>difference(*others)</code>: 返回当前集合与其他集合的差集，即在当前集合中但不在其他集合中的元素组成的集合。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\ndiff &#x3D; set1.difference(set2)\nprint(diff)  # 输出 &#123;1, 2, 3&#125;</code></pre>\n\n<h3 id=\"difference-update-others-移除当前集合中与其他集合的交集，即在当前集合中同时存在于其他集合中的元素。\"><a href=\"#difference-update-others-移除当前集合中与其他集合的交集，即在当前集合中同时存在于其他集合中的元素。\" class=\"headerlink\" title=\"difference_update(*others): 移除当前集合中与其他集合的交集，即在当前集合中同时存在于其他集合中的元素。\"></a><code>difference_update(*others)</code>: 移除当前集合中与其他集合的交集，即在当前集合中同时存在于其他集合中的元素。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nset1.difference_update(set2)\nprint(set1)  # 输出 &#123;1, 2, 3&#125;</code></pre>\n\n<h3 id=\"discard-element-移除集合中指定的元素，如果元素不存在，不会引发错误。\"><a href=\"#discard-element-移除集合中指定的元素，如果元素不存在，不会引发错误。\" class=\"headerlink\" title=\"discard(element): 移除集合中指定的元素，如果元素不存在，不会引发错误。\"></a><code>discard(element)</code>: 移除集合中指定的元素，如果元素不存在，不会引发错误。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.discard(2)\nprint(my_set)  # 输出 &#123;1, 3&#125;\nmy_set.discard(4)\nprint(my_set)  # 输出 &#123;1, 3&#125;</code></pre>\n\n<h3 id=\"intersection-others-返回当前集合与其他集合的交集，即同时存在于所有集合中的元素组成的集合。\"><a href=\"#intersection-others-返回当前集合与其他集合的交集，即同时存在于所有集合中的元素组成的集合。\" class=\"headerlink\" title=\"intersection(*others): 返回当前集合与其他集合的交集，即同时存在于所有集合中的元素组成的集合。\"></a><code>intersection(*others)</code>: 返回当前集合与其他集合的交集，即同时存在于所有集合中的元素组成的集合。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nintersection &#x3D; set1.intersection(set2)\nprint(intersection)  # 输出 &#123;4, 5&#125;</code></pre>\n\n<h3 id=\"intersection-update-others-保留当前集合与其他集合的交集，移除不在交集中的元素。\"><a href=\"#intersection-update-others-保留当前集合与其他集合的交集，移除不在交集中的元素。\" class=\"headerlink\" title=\"intersection_update(*others): 保留当前集合与其他集合的交集，移除不在交集中的元素。\"></a><code>intersection_update(*others)</code>: 保留当前集合与其他集合的交集，移除不在交集中的元素。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nset1.intersection_update(set2)\nprint(set1)  # 输出 &#123;4, 5&#125;</code></pre>\n\n<h3 id=\"isdisjoint-other-判断当前集合与另一个集合是否没有共同的元素，如果没有返回-True，否则返回-False。\"><a href=\"#isdisjoint-other-判断当前集合与另一个集合是否没有共同的元素，如果没有返回-True，否则返回-False。\" class=\"headerlink\" title=\"isdisjoint(other): 判断当前集合与另一个集合是否没有共同的元素，如果没有返回 True，否则返回 False。\"></a><code>isdisjoint(other)</code>: 判断当前集合与另一个集合是否没有共同的元素，如果没有返回 True，否则返回 False。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;4, 5, 6&#125;\nprint(set1.isdisjoint(set2))  # 输出 True\nset3 &#x3D; &#123;3, 4, 5&#125;\nprint(set1.isdisjoint(set3))  # 输出 False</code></pre>\n\n<h3 id=\"issubset-other-判断当前集合是否是另一个集合的子集，如果是返回-True，否则返回-False。\"><a href=\"#issubset-other-判断当前集合是否是另一个集合的子集，如果是返回-True，否则返回-False。\" class=\"headerlink\" title=\"issubset(other): 判断当前集合是否是另一个集合的子集，如果是返回 True，否则返回 False。\"></a><code>issubset(other)</code>: 判断当前集合是否是另一个集合的子集，如果是返回 True，否则返回 False。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2&#125;\nset2 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nprint(set1.issubset(set2))  # 输出 True\nset3 &#x3D; &#123;3, 4, 5&#125;\nprint(set1.issubset(set3))  # 输出 False</code></pre>\n\n<h3 id=\"issuperset-other-判断当前集合是否是另一个集合的超集，如果是返回-True，否则返回-False。\"><a href=\"#issuperset-other-判断当前集合是否是另一个集合的超集，如果是返回-True，否则返回-False。\" class=\"headerlink\" title=\"issuperset(other): 判断当前集合是否是另一个集合的超集，如果是返回 True，否则返回 False。\"></a><code>issuperset(other)</code>: 判断当前集合是否是另一个集合的超集，如果是返回 True，否则返回 False。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;1, 2&#125;\nprint(set1.issuperset(set2))  # 输出 True\nset3 &#x3D; &#123;3, 4, 5&#125;\nprint(set1.issuperset(set3))  # 输出 True</code></pre>\n\n<h3 id=\"pop-随机移除并返回集合中的一个元素，如果集合为空会引发-KeyError-错误。\"><a href=\"#pop-随机移除并返回集合中的一个元素，如果集合为空会引发-KeyError-错误。\" class=\"headerlink\" title=\"pop(): 随机移除并返回集合中的一个元素，如果集合为空会引发 KeyError 错误。\"></a><code>pop()</code>: 随机移除并返回集合中的一个元素，如果集合为空会引发 KeyError 错误。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3, 4, 5&#125;\nelement &#x3D; my_set.pop()\nprint(element)  # 输出随机移除的元素\nprint(my_set)  # 输出移除元素后的集合</code></pre>\n\n<h3 id=\"remove-element-移除集合中指定的元素，如果元素不存在，会引发-KeyError-错误。\"><a href=\"#remove-element-移除集合中指定的元素，如果元素不存在，会引发-KeyError-错误。\" class=\"headerlink\" title=\"remove(element): 移除集合中指定的元素，如果元素不存在，会引发 KeyError 错误。\"></a><code>remove(element)</code>: 移除集合中指定的元素，如果元素不存在，会引发 KeyError 错误。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.remove(2)\nprint(my_set)  # 输出 &#123;1, 3&#125;\nmy_set.remove(4)  # 会引发 KeyError 错误</code></pre>\n\n<h3 id=\"symmetric-difference-other-返回当前集合与另一个集合的对称差集，即在当前集合或其他集合中但不同时存在的元素组成的集合。\"><a href=\"#symmetric-difference-other-返回当前集合与另一个集合的对称差集，即在当前集合或其他集合中但不同时存在的元素组成的集合。\" class=\"headerlink\" title=\"symmetric_difference(other): 返回当前集合与另一个集合的对称差集，即在当前集合或其他集合中但不同时存在的元素组成的集合。\"></a><code>symmetric_difference(other)</code>: 返回当前集合与另一个集合的对称差集，即在当前集合或其他集合中但不同时存在的元素组成的集合。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nsym_diff &#x3D; set1.symmetric_difference(set2)\nprint(sym_diff)  # 输出 &#123;1, 2, 4, 5&#125;</code></pre>\n\n<h3 id=\"symmetric-difference-update-other-更新当前集合为当前集合与另一个集合的对称差集。\"><a href=\"#symmetric-difference-update-other-更新当前集合为当前集合与另一个集合的对称差集。\" class=\"headerlink\" title=\"symmetric_difference_update(other): 更新当前集合为当前集合与另一个集合的对称差集。\"></a><code>symmetric_difference_update(other)</code>: 更新当前集合为当前集合与另一个集合的对称差集。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nset1.symmetric_difference_update(set2)\nprint(set1)  # 输出 &#123;1, 2, 4, 5&#125;</code></pre>\n\n<h3 id=\"union-others-返回当前集合与其他集合的并集，即包含所有集合中的元素的集合。\"><a href=\"#union-others-返回当前集合与其他集合的并集，即包含所有集合中的元素的集合。\" class=\"headerlink\" title=\"union(*others): 返回当前集合与其他集合的并集，即包含所有集合中的元素的集合。\"></a><code>union(*others)</code>: 返回当前集合与其他集合的并集，即包含所有集合中的元素的集合。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nunion &#x3D; set1.union(set2)\nprint(union)  # 输出 &#123;1, 2, 3, 4, 5&#125;</code></pre>\n\n<h3 id=\"update-others-将其他集合中的元素添加到当前集合中。\"><a href=\"#update-others-将其他集合中的元素添加到当前集合中。\" class=\"headerlink\" title=\"update(*others): 将其他集合中的元素添加到当前集合中。\"></a><code>update(*others)</code>: 将其他集合中的元素添加到当前集合中。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nset1.update(set2)\nprint(set1)  # 输出 &#123;1, 2, 3, 4\n\n## intersection 与 intersection_update 区别\n\n&#96;intersection&#96; 和 &#96;intersection_update&#96; 是集合（Set）的两个方法，用于计算集合间的交集。\n\n区别如下：\n\n- &#96;intersection&#96;: 该方法返回一个新的集合，包含当前集合与其他集合的交集元素。原始集合不会被修改。\n\n&#96;&#96;&#96;python\nset1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nintersection &#x3D; set1.intersection(set2)\nprint(intersection)  # 输出 &#123;4, 5&#125;\nprint(set1)  # 输出 &#123;1, 2, 3, 4, 5&#125;，原始集合不变</code></pre>\n\n<ul>\n<li><code>intersection_update</code>: 该方法会修改当前集合，使其只包含与其他集合的交集元素，原始集合会被更新。</li>\n</ul>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nset1.intersection_update(set2)\nprint(set1)  # 输出 &#123;4, 5&#125;，原始集合被修改</code></pre>\n\n<p>需要注意的是，<code>intersection</code> 方法返回一个新的集合，不会修改原始集合。而 <code>intersection_update</code> 方法会直接修改当前集合，使其变为交集结果。</p>\n<p>根据实际需求，选择合适的方法来计算集合的交集。如果需要保留原始集合，同时获得交集结果，可以使用 <code>intersection</code> 方法。如果只关心得到交集结果并修改当前集合，可以使用 <code>intersection_update</code> 方法。</p>\n<h1 id=\"条件控制\"><a href=\"#条件控制\" class=\"headerlink\" title=\"条件控制\"></a>条件控制</h1><h2 id=\"if…elif-…-else\"><a href=\"#if…elif-…-else\" class=\"headerlink\" title=\"if…elif … else\"></a>if…elif … else</h2><p>Python 3 中的条件控制主要使用 <code>if</code>、<code>elif</code> 和 <code>else</code> 语句来实现。下面是 Python 3 的条件控制语法和示例：</p>\n<p><strong>if 语句：</strong></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">if condition:\n    # 执行条件为真时的代码块\nelse:\n    # 执行条件为假时的代码块</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; 10\nif x &gt; 5:\n    print(&quot;x 大于 5&quot;)\nelse:\n    print(&quot;x 不大于 5&quot;)</code></pre>\n\n<p><strong>if-elif-else 语句：</strong></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">if condition1:\n    # 执行条件1为真时的代码块\nelif condition2:\n    # 执行条件2为真时的代码块\nelse:\n    # 执行所有条件都为假时的代码块</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; 10\nif x &gt; 10:\n    print(&quot;x 大于 10&quot;)\nelif x &lt; 10:\n    print(&quot;x 小于 10&quot;)\nelse:\n    print(&quot;x 等于 10&quot;)</code></pre>\n\n<p><strong>嵌套的 if 语句：</strong></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">if condition1:\n    # 执行条件1为真时的代码块\n    if condition2:\n        # 执行条件2为真时的代码块\nelse:\n    # 执行条件1为假时的代码块</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; 10\nif x &gt; 5:\n    print(&quot;x 大于 5&quot;)\n    if x &gt; 8:\n        print(&quot;x 大于 8&quot;)\nelse:\n    print(&quot;x 不大于 5&quot;)</code></pre>\n\n<p>以上是 Python 3 中常用的条件控制语句，可以根据具体的需求和条件编写适当的代码块来实现不同的逻辑。</p>\n<h2 id=\"match…case\"><a href=\"#match…case\" class=\"headerlink\" title=\"match…case\"></a>match…case</h2><p><code>match...case</code> 是 Python 3.10 引入的新特性，用于替代原先的 <code>if...elif...else</code> 或 <code>dict.get()</code> 实现分支语句，提高代码可读性和表达能力。<code>match...case</code> 的语法格式如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">match value:\n    case pattern1:\n        # 执行匹配 pattern1 成功时的代码块\n    case pattern2:\n        # 执行匹配 pattern2 成功时的代码块\n    ...\n    case _:\n        # 执行所有 pattern 都匹配失败时的代码块</code></pre>\n\n<p>其中 <code>value</code> 表示要匹配的值，<code>pattern</code> 表示匹配的模式。如果 <code>value</code> 和 <code>pattern</code> 匹配成功，则执行对应的代码块，否则继续匹配下一个 <code>case</code>，如果所有的 <code>case</code> 都匹配失败，则执行 <code>_</code> 对应的代码块。</p>\n<p><code>match...case</code> 支持的模式有很多种，包括常量模式、变量模式、位置模式、类型模式、结构模式等，可以根据具体的需求和数据类型选择合适的模式。下面是 <code>match...case</code> 的示例代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def get_color_name(color_code):\n    match color_code:\n        case 0:\n            return &quot;Black&quot;\n        case 1:\n            return &quot;Red&quot;\n        case 2:\n            return &quot;Green&quot;\n        case 3:\n            return &quot;Yellow&quot;\n        case _:\n            return &quot;Unknown&quot;\n\nprint(get_color_name(1))  # 输出：Red\nprint(get_color_name(4))  # 输出：Unknown</code></pre>\n\n<p>以上是 <code>match...case</code> 的基本语法和示例，需要注意的是，<code>match...case</code> 是 Python 3.10 中新增的特性，需要安装 Python 3.10 或更高版本才能使用。</p>\n<h2 id=\"常量模式、变量模式、位置模式、类型模式、结构模式-的示例\"><a href=\"#常量模式、变量模式、位置模式、类型模式、结构模式-的示例\" class=\"headerlink\" title=\"常量模式、变量模式、位置模式、类型模式、结构模式 的示例\"></a>常量模式、变量模式、位置模式、类型模式、结构模式 的示例</h2><p>下面是 <code>match...case</code> 中常见模式的示例：</p>\n<h3 id=\"常量模式：匹配特定的常量值。\"><a href=\"#常量模式：匹配特定的常量值。\" class=\"headerlink\" title=\"常量模式：匹配特定的常量值。\"></a><strong>常量模式</strong>：匹配特定的常量值。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def check_number(value):\n    match value:\n        case 0:\n            print(&quot;Zero&quot;)\n        case 1:\n            print(&quot;One&quot;)\n        case 2:\n            print(&quot;Two&quot;)\n        case _:\n            print(&quot;Other&quot;)\n\ncheck_number(1)  # 输出：One\ncheck_number(5)  # 输出：Other</code></pre>\n\n<h3 id=\"变量模式：将匹配的值绑定到一个变量，并在代码块中使用该变量。\"><a href=\"#变量模式：将匹配的值绑定到一个变量，并在代码块中使用该变量。\" class=\"headerlink\" title=\"变量模式：将匹配的值绑定到一个变量，并在代码块中使用该变量。\"></a><strong>变量模式</strong>：将匹配的值绑定到一个变量，并在代码块中使用该变量。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def check_even_odd(number):\n    match number % 2:\n        case 0:\n            print(&quot;Even&quot;)\n        case odd_number:\n            print(&quot;Odd:&quot;, odd_number)\n\ncheck_even_odd(4)  # 输出：Even\ncheck_even_odd(7)  # 输出：Odd: 1</code></pre>\n\n<h3 id=\"位置模式：匹配指定位置的元素。\"><a href=\"#位置模式：匹配指定位置的元素。\" class=\"headerlink\" title=\"位置模式：匹配指定位置的元素。\"></a><strong>位置模式</strong>：匹配指定位置的元素。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def check_coordinates(point):\n    match point:\n        case (0, 0):\n            print(&quot;Origin&quot;)\n        case (x, 0):\n            print(&quot;On x-axis:&quot;, x)\n        case (0, y):\n            print(&quot;On y-axis:&quot;, y)\n        case (x, y):\n            print(&quot;Arbitrary point:&quot;, x, y)\n\ncheck_coordinates((0, 0))   # 输出：Origin\ncheck_coordinates((3, 0))   # 输出：On x-axis: 3\ncheck_coordinates((0, 5))   # 输出：On y-axis: 5\ncheck_coordinates((2, 4))   # 输出：Arbitrary point: 2 4</code></pre>\n\n<h3 id=\"类型模式：匹配特定类型的对象。\"><a href=\"#类型模式：匹配特定类型的对象。\" class=\"headerlink\" title=\"类型模式：匹配特定类型的对象。\"></a><strong>类型模式</strong>：匹配特定类型的对象。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Person:\n    def __init__(self, name, age):\n        self.name &#x3D; name\n        self.age &#x3D; age\n\ndef check_person(obj):\n    match obj:\n        case Person(name&#x3D;&quot;Alice&quot;, age&#x3D;25):\n            print(&quot;Alice&quot;)\n        case Person(name&#x3D;&quot;Bob&quot;, age&#x3D;30):\n            print(&quot;Bob&quot;)\n        case Person(name, _):\n            print(&quot;Unknown person:&quot;, name)\n        case _:\n            print(&quot;Unknown object&quot;)\n\ncheck_person(Person(&quot;Alice&quot;, 25))  # 输出：Alice\ncheck_person(Person(&quot;Bob&quot;, 30))    # 输出：Bob\ncheck_person(Person(&quot;Charlie&quot;, 40))    # 输出：Unknown person: Charlie\ncheck_person(&quot;Invalid&quot;)    # 输出：Unknown object</code></pre>\n\n<h3 id=\"结构模式：匹配复杂数据结构的内部元素。\"><a href=\"#结构模式：匹配复杂数据结构的内部元素。\" class=\"headerlink\" title=\"结构模式：匹配复杂数据结构的内部元素。\"></a><strong>结构模式</strong>：匹配复杂数据结构的内部元素。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Point:\n    def __init__(self, x, y):\n        self.x &#x3D; x\n        self.y &#x3D; y\n\ndef check_point(p):\n    match p:\n        case Point(0, 0):\n            print(&quot;Origin&quot;)\n        case Point(x&#x3D;0, y&#x3D;y):\n            print(&quot;On y-axis:&quot;, y)\n        case Point(x, 0):\n            print(&quot;On x-axis:&quot;, x)\n        case Point(x, y):\n            print(&quot;Arbitrary point:&quot;, x, y)\n\ncheck_point(Point(0, 0))    # 输出：Origin\ncheck_point(Point(0, 5))    # 输出：On y-axis: 5\ncheck_point(Point(3, 0))    # 输出：On x-axis: 3\ncheck_point(Point(2, 4))    # 输出：Arbitrary point: 2 4</code></pre>\n\n<h3 id=\"一个-case-也可以设置多个匹配条件，条件使用-｜-隔开\"><a href=\"#一个-case-也可以设置多个匹配条件，条件使用-｜-隔开\" class=\"headerlink\" title=\"一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开\"></a>一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开</h3><p>是的，<code>match...case</code> 语句中的 <code>case</code> 子句可以使用 <code>|</code> 符号将多个匹配条件组合在一起。这样可以在一个 <code>case</code> 子句中同时匹配多个条件，只要有一个条件满足，就会执行对应的代码块。下面是使用 <code>|</code> 运算符的示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def check_number(value):\n    match value:\n        case 0 | 1 | 2:\n            print(&quot;Small number&quot;)\n        case 3 | 4 | 5:\n            print(&quot;Medium number&quot;)\n        case _:\n            print(&quot;Other number&quot;)\n\ncheck_number(2)  # 输出：Small number\ncheck_number(4)  # 输出：Medium number\ncheck_number(7)  # 输出：Other number</code></pre>\n\n<p>在上面的示例中，<code>case 0 | 1 | 2</code> 表示当 <code>value</code> 的值为 0、1 或 2 时，执行相应的代码块。同样地，<code>case 3 | 4 | 5</code> 表示当 <code>value</code> 的值为 3、4 或 5 时，执行相应的代码块。如果所有的条件都不满足，则执行最后的 <code>case _</code> 代码块。</p>\n<p>使用 <code>|</code> 运算符可以简化代码，将多个条件组合在一起，提高可读性和代码的简洁性。</p>\n<h1 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h1><p>在 Python 中，常用的循环语句有 <code>for</code> 循环和 <code>while</code> 循环。</p>\n<h3 id=\"for-循环：用于遍历可迭代对象（如列表、元组、字符串等）中的元素，或执行指定次数的循环。\"><a href=\"#for-循环：用于遍历可迭代对象（如列表、元组、字符串等）中的元素，或执行指定次数的循环。\" class=\"headerlink\" title=\"for 循环：用于遍历可迭代对象（如列表、元组、字符串等）中的元素，或执行指定次数的循环。\"></a><strong>for 循环</strong>：用于遍历可迭代对象（如列表、元组、字符串等）中的元素，或执行指定次数的循环。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">for item in iterable:\n    # 循环体，处理每个元素</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">fruits &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]\nfor fruit in fruits:\n    print(fruit)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">apple\nbanana\ncherry</code></pre>\n\n<h3 id=\"range-函数结合-for-循环：通过-range-函数生成一系列的数字，可以与-for-循环结合使用。\"><a href=\"#range-函数结合-for-循环：通过-range-函数生成一系列的数字，可以与-for-循环结合使用。\" class=\"headerlink\" title=\"range() 函数结合 for 循环：通过 range() 函数生成一系列的数字，可以与 for 循环结合使用。\"></a><strong>range() 函数结合 for 循环</strong>：通过 <code>range()</code> 函数生成一系列的数字，可以与 <code>for</code> 循环结合使用。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">for i in range(start, stop, step):\n    # 循环体，处理每个数字</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">for i in range(1, 6, 2):\n    print(i)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n3\n5</code></pre>\n\n<h3 id=\"while-循环：在指定条件为真时重复执行循环体，直到条件变为假或出现循环终止语句。\"><a href=\"#while-循环：在指定条件为真时重复执行循环体，直到条件变为假或出现循环终止语句。\" class=\"headerlink\" title=\"while 循环：在指定条件为真时重复执行循环体，直到条件变为假或出现循环终止语句。\"></a><strong>while 循环</strong>：在指定条件为真时重复执行循环体，直到条件变为假或出现循环终止语句。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">while condition:\n    # 循环体，处理条件为真时的逻辑</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">count &#x3D; 0\nwhile count &lt; 5:\n    print(count)\n    count +&#x3D; 1</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0\n1\n2\n3\n4</code></pre>\n\n<h3 id=\"循环控制语句：可以在循环中使用控制语句来控制循环的行为。常用的控制语句有-break（跳出循环）、continue（继续下一次循环迭代）和-pass（占位语句，什么都不做）。\"><a href=\"#循环控制语句：可以在循环中使用控制语句来控制循环的行为。常用的控制语句有-break（跳出循环）、continue（继续下一次循环迭代）和-pass（占位语句，什么都不做）。\" class=\"headerlink\" title=\"循环控制语句：可以在循环中使用控制语句来控制循环的行为。常用的控制语句有 break（跳出循环）、continue（继续下一次循环迭代）和 pass（占位语句，什么都不做）。\"></a><strong>循环控制语句</strong>：可以在循环中使用控制语句来控制循环的行为。常用的控制语句有 <code>break</code>（跳出循环）、<code>continue</code>（继续下一次循环迭代）和 <code>pass</code>（占位语句，什么都不做）。</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">for item in iterable:\n    if condition:\n        # 执行满足条件时的逻辑\n        break  # 跳出循环\n    if condition:\n        # 执行满足条件时的逻辑\n        continue  # 继续下一次循环迭代\n    if condition:\n        pass  # 占位语句，什么都不做\n    # 其他逻辑</code></pre>\n\n<p>循环语句是编程中常用的工具，可以重复执行特定的代码块，处理集合中的元素或根据条件执行特定的逻辑。根据具体的需求，选择合适的循环语句和循环控制语句来实现所需的逻辑。</p>\n<h1 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h1><p><code>print</code> 是 Python 中用于输出信息的内置函数。它接受一个或多个参数，并将它们打印到标准输出（通常是控制台）。</p>\n<p>语法格式如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">print(value1, value2, ..., sep&#x3D;&#39; &#39;, end&#x3D;&#39;\\n&#39;, file&#x3D;sys.stdout, flush&#x3D;False)</code></pre>\n\n<p>参数说明：</p>\n<ul>\n<li><code>value1, value2, ...</code>: 要打印的值，可以是任意个数的参数。</li>\n<li><code>sep=&#39; &#39;</code>: 用于分隔每个值的字符串，默认值是一个空格。</li>\n<li><code>end=&#39;\\n&#39;</code>: 打印完成后追加的字符串，默认值是换行符 <code>\\n</code>。</li>\n<li><code>file=sys.stdout</code>: 输出的文件对象，默认值是标准输出（控制台）。</li>\n<li><code>flush=False</code>: 是否强制刷新输出，默认值是 <code>False</code>。</li>\n</ul>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">print(&quot;Hello, World!&quot;)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Hello, World!</code></pre>\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">name &#x3D; &quot;Alice&quot;\nage &#x3D; 25\nprint(&quot;Name:&quot;, name, &quot;Age:&quot;, age, sep&#x3D;&quot; | &quot;, end&#x3D;&quot; ***\\n&quot;)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Name: Alice | Age: 25 ***</code></pre>\n\n<p><code>print</code> 函数可以输出各种类型的数据，包括字符串、数字、布尔值等。在调试代码或查看运行结果时，<code>print</code> 是一个常用的工具。可以根据需要使用不同的参数来自定义打印的格式和内容。</p>\n<h1 id=\"推导式-可以理解为行内遍历\"><a href=\"#推导式-可以理解为行内遍历\" class=\"headerlink\" title=\"推导式 (可以理解为行内遍历)\"></a>推导式 (可以理解为行内遍历)</h1><p>推导式（Comprehension）是 Python 中一种简洁而强大的语法，<strong>用于创建新的数据结构（如列表、字典、集合）或过滤、转换现有数据结构的元素</strong>。</p>\n<p>Python 中常见的推导式有列表推导式、字典推导式和集合推导式。</p>\n<p><strong>列表推导式（List Comprehension）</strong>：通过对一个可迭代对象中的每个元素进行操作，创建一个新的列表。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">new_list &#x3D; [expression for item in iterable if condition]</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">numbers &#x3D; [1, 2, 3, 4, 5]\nsquared_numbers &#x3D; [x**2 for x in numbers if x % 2 &#x3D;&#x3D; 0]\nprint(squared_numbers)  # 输出：[4, 16]</code></pre>\n\n<p><strong>字典推导式（Dictionary Comprehension）</strong>：通过对一个可迭代对象中的每个元素进行操作，创建一个新的字典。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">new_dict &#x3D; &#123;key_expression: value_expression for item in iterable if condition&#125;</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">numbers &#x3D; [1, 2, 3, 4, 5]\nsquared_dict &#x3D; &#123;x: x**2 for x in numbers if x % 2 &#x3D;&#x3D; 0&#125;\nprint(squared_dict)  # 输出：&#123;2: 4, 4: 16&#125;</code></pre>\n\n<p><strong>集合推导式（Set Comprehension）</strong>：通过对一个可迭代对象中的每个元素进行操作，创建一个新的集合。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">new_set &#x3D; &#123;expression for item in iterable if condition&#125;</code></pre>\n\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">numbers &#x3D; [1, 2, 3, 4, 5]\nsquared_set &#x3D; &#123;x**2 for x in numbers if x % 2 &#x3D;&#x3D; 0&#125;\nprint(squared_set)  # 输出：&#123;16, 4&#125;</code></pre>\n\n<p>推导式能够以简洁的方式创建新的数据结构，并且可以使用条件来过滤元素。它在处理大型数据集或需要快速生成新数据结构的情况下特别有用。</p>\n<h1 id=\"迭代器与生成器\"><a href=\"#迭代器与生成器\" class=\"headerlink\" title=\"迭代器与生成器\"></a>迭代器与生成器</h1><p>迭代器（Iterator）和生成器（Generator）是 Python 中用于处理和生成序列数据的重要概念。</p>\n<h2 id=\"迭代器是一个实现了迭代器协议的对象。\"><a href=\"#迭代器是一个实现了迭代器协议的对象。\" class=\"headerlink\" title=\"迭代器是一个实现了迭代器协议的对象。\"></a><strong>迭代器</strong>是一个实现了迭代器协议的对象。</h2><p>它通过实现 <code>__iter__</code> 和 <code>__next__</code> 方法来支持迭代，使得我们可以逐个访问容器（如列表、元组、字典等）中的元素，而无需关心底层实现。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">numbers &#x3D; [1, 2, 3, 4, 5]\niterator &#x3D; iter(numbers)\n\nprint(next(iterator))  # 输出：1\nprint(next(iterator))  # 输出：2\nprint(next(iterator))  # 输出：3</code></pre>\n\n<p>迭代器可以使用 <code>next()</code> 函数来逐个返回序列中的元素，当没有更多元素时会抛出 <code>StopIteration</code> 异常。</p>\n<h2 id=\"生成器是一种特殊的迭代器，提供了一种延迟计算的机制，可以节省内存并提高性能\"><a href=\"#生成器是一种特殊的迭代器，提供了一种延迟计算的机制，可以节省内存并提高性能\" class=\"headerlink\" title=\"生成器是一种特殊的迭代器，提供了一种延迟计算的机制，可以节省内存并提高性能\"></a><strong>生成器</strong>是一种特殊的迭代器，提供了一种延迟计算的机制，可以节省内存并提高性能</h2><p>它使用函数和 <code>yield</code> 语句来生成值。生成器函数在每次调用 <code>yield</code> 时返回一个值，并在下一次调用时从停止的位置继续执行，保持了函数的状态。</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def square_numbers(n):\n    for i in range(n):\n        yield i**2\n\nnumbers &#x3D; square_numbers(5)\nprint(next(numbers))  # 输出：0\nprint(next(numbers))  # 输出：1\nprint(next(numbers))  # 输出：4</code></pre>\n\n<p>生成器函数使用 <code>yield</code> 语句来产生值，每次调用生成器的 <code>next()</code> 方法时，生成器会从上一次 <code>yield</code> 语句停止的位置继续执行，并返回下一个值。<strong>生成器提供了一种延迟计算的机制，可以节省内存并提高性能</strong>。</p>\n<p>生成器还可以通过 <code>for</code> 循环来进行迭代，它会自动处理迭代和停止条件。</p>\n<p>迭代器和生成器提供了处理大型数据集和惰性计算的强大工具，能够有效地处理大量数据和节省资源。</p>\n<h2 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h2><p>在 Python 中，函数的参数可以分为以下几种类型：</p>\n<h3 id=\"位置参数（Positional-Arguments）：位置参数是根据参数的位置进行匹配的，调用函数时需要按照定义时的顺序传递参数。示例：\"><a href=\"#位置参数（Positional-Arguments）：位置参数是根据参数的位置进行匹配的，调用函数时需要按照定义时的顺序传递参数。示例：\" class=\"headerlink\" title=\"位置参数（Positional Arguments）：位置参数是根据参数的位置进行匹配的，调用函数时需要按照定义时的顺序传递参数。示例：\"></a><strong>位置参数</strong>（Positional Arguments）：位置参数是根据参数的位置进行匹配的，调用函数时需要按照定义时的顺序传递参数。示例：</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def greet(name, age):\n    print(f&quot;Hello, &#123;name&#125;! You are &#123;age&#125; years old.&quot;)\n\ngreet(&quot;Alice&quot;, 25)  # 输出：Hello, Alice! You are 25 years old.</code></pre>\n\n<h3 id=\"关键字参数（Keyword-Arguments）：关键字参数是根据参数的名称进行匹配的，可以任意顺序传递参数。示例：\"><a href=\"#关键字参数（Keyword-Arguments）：关键字参数是根据参数的名称进行匹配的，可以任意顺序传递参数。示例：\" class=\"headerlink\" title=\"关键字参数（Keyword Arguments）：关键字参数是根据参数的名称进行匹配的，可以任意顺序传递参数。示例：\"></a><strong>关键字参数</strong>（Keyword Arguments）：关键字参数是根据参数的名称进行匹配的，可以任意顺序传递参数。示例：</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def greet(name, age):\n    print(f&quot;Hello, &#123;name&#125;! You are &#123;age&#125; years old.&quot;)\n\ngreet(age&#x3D;25, name&#x3D;&quot;Alice&quot;)  # 输出：Hello, Alice! You are 25 years old.</code></pre>\n\n<h3 id=\"默认参数（Default-Arguments）：默认参数是在函数定义时给参数设置默认值，调用函数时如果没有提供该参数的值，则使用默认值。示例：\"><a href=\"#默认参数（Default-Arguments）：默认参数是在函数定义时给参数设置默认值，调用函数时如果没有提供该参数的值，则使用默认值。示例：\" class=\"headerlink\" title=\"默认参数（Default Arguments）：默认参数是在函数定义时给参数设置默认值，调用函数时如果没有提供该参数的值，则使用默认值。示例：\"></a><strong>默认参数</strong>（Default Arguments）：默认参数是在函数定义时给参数设置默认值，调用函数时如果没有提供该参数的值，则使用默认值。示例：</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def greet(name, age&#x3D;18):\n    print(f&quot;Hello, &#123;name&#125;! You are &#123;age&#125; years old.&quot;)\n\ngreet(&quot;Alice&quot;)  # 输出：Hello, Alice! You are 18 years old.\ngreet(&quot;Bob&quot;, 30)  # 输出：Hello, Bob! You are 30 years old.</code></pre>\n\n<h3 id=\"可变长参数：\"><a href=\"#可变长参数：\" class=\"headerlink\" title=\"可变长参数：\"></a><strong>可变长参数</strong>：</h3><p>可变长参数允许函数接受不定数量的参数。在 Python 中有两种类型的可变长参数：</p>\n<h4 id=\"可变长位置参数（Arbitrary-Arguments）：\"><a href=\"#可变长位置参数（Arbitrary-Arguments）：\" class=\"headerlink\" title=\"可变长位置参数（Arbitrary Arguments）：\"></a><strong>可变长位置参数</strong>（Arbitrary Arguments）：</h4><p>函数定义时，在参数前加上 <code>*</code>，表示该参数可以接受任意数量的位置参数。函数内部将这些参数作为元组来处理。示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def greet(*names):\n    for name in names:\n        print(f&quot;Hello, &#123;name&#125;!&quot;)\n\ngreet(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)  # 输出：Hello, Alice!  Hello, Bob!  Hello, Charlie!</code></pre>\n\n<h4 id=\"可变长关键字参数（Keyword-Arguments）：\"><a href=\"#可变长关键字参数（Keyword-Arguments）：\" class=\"headerlink\" title=\"可变长关键字参数（Keyword Arguments）：\"></a><strong>可变长关键字参数</strong>（Keyword Arguments）：</h4><p>函数定义时，在参数前加上 <code>**</code>，表示该参数可以接受任意数量的关键字参数。函数内部将这些参数作为字典来处理。示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def greet(**person):\n    for key, value in person.items():\n        print(f&quot;&#123;key&#125;: &#123;value&#125;&quot;)\n\ngreet(name&#x3D;&quot;Alice&quot;, age&#x3D;25, city&#x3D;&quot;London&quot;)  # 输出：name: Alice  age: 25  city: London</code></pre>\n\n<p>函数参数的选择取决于具体的需求。位置参数和关键字参数是最常用的参数类型，而默认参数和可变长参数可以提供更大的灵活性和可扩展性。</p>\n<h2 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h2><p>定义一个由自己想要功能的函数，以下是简单的规则：</p>\n<p>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。<br>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。<br>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>函数内容以冒号 : 起始，并且缩进。<br>return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</p>\n<h2 id=\"lamada\"><a href=\"#lamada\" class=\"headerlink\" title=\"lamada\"></a>lamada</h2><p>Python 使用 lambda 来创建匿名函数。</p>\n<p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p>\n<ol>\n<li>lambda 只是一个表达式，函数体比 def 简单很多。</li>\n<li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li>\n<li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>\n<li>虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。<br>语法<br>lambda 函数的语法只包含一个语句，如下：</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lambda [arg1 [,arg2,.....argn]]:expression</code></pre>\n\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p><strong>数据结构是计算机中存储、组织和管理数据的方式和方法。</strong>它定义了不同数据元素之间的关系，并提供了对这些数据元素进行操作和访问的接口。</p>\n<p>在 Python 中，常见的数据结构包括以下几种：</p>\n<ol>\n<li><strong>列表（List）</strong>：列表是一种有序、可变、可重复的数据结构，用于存储多个元素。列表使用方括号 <code>[]</code> 表示，元素之间使用逗号 <code>,</code> 分隔。列表支持索引和切片操作，以及添加、删除、修改等操作。</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">fruits &#x3D; [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]\nprint(fruits[0])  # 输出：apple\nfruits.append(&quot;grape&quot;)\nprint(fruits)  # 输出：[&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;, &#39;grape&#39;]</code></pre>\n\n<ol start=\"2\">\n<li><strong>元组（Tuple）</strong>：元组是一种有序、不可变的数据结构，用于存储多个元素。元组使用圆括号 <code>()</code> 表示，元素之间使用逗号 <code>,</code> 分隔。元组的元素不能被修改，但可以通过索引访问。</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">point &#x3D; (3, 5)\nprint(point[0])  # 输出：3</code></pre>\n\n<ol start=\"3\">\n<li><strong>字典（Dictionary）</strong>：字典是一种无序的键值对数据结构，用于存储和查找数据。字典使用花括号 <code>&#123;&#125;</code> 表示，每个键值对之间使用冒号 <code>:</code> 分隔。字典中的键必须是唯一的，而值可以重复。</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">person &#x3D; &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;city&quot;: &quot;London&quot;&#125;\nprint(person[&quot;name&quot;])  # 输出：Alice\nperson[&quot;age&quot;] &#x3D; 30\nprint(person)  # 输出：&#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;London&#39;&#125;</code></pre>\n\n<ol start=\"4\">\n<li><strong>集合（Set）</strong>：集合是一种无序、不重复的数据结构，用于存储唯一的元素。集合使用花括号 <code>&#123;&#125;</code> 表示，元素之间使用逗号 <code>,</code> 分隔。</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;&#125;\nprint(&quot;banana&quot; in fruits)  # 输出：True\nfruits.add(&quot;grape&quot;)\nprint(fruits)  # 输出：&#123;&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;, &#39;grape&#39;&#125;</code></pre>\n\n<p>这些数据结构在 Python 中都有对应的内置类型和方法，可以根据具体的需求选择适当的数据结构来存储和处理数据。</p>\n<h2 id=\"列表-API\"><a href=\"#列表-API\" class=\"headerlink\" title=\"列表 API\"></a>列表 API</h2><h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ol>\n<li>堆栈</li>\n<li>队列</li>\n<li>推导式</li>\n<li>嵌套</li>\n<li>del 语句：<ol>\n<li>使用 del 语句可以从一个列表中根据索引来删除一个元素，而不是值来删除元素。</li>\n<li>这与使用 pop() 返回一个值不同。</li>\n<li>可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）</li>\n</ol>\n</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&gt;&gt;&gt; a &#x3D; [-1, 1, 66.25, 333, 333, 1234.5]\n&gt;&gt;&gt; del a[0]\n&gt;&gt;&gt; a\n[1, 66.25, 333, 333, 1234.5]\n&gt;&gt;&gt; del a[2:4]\n&gt;&gt;&gt; a\n[1, 66.25, 1234.5]\n&gt;&gt;&gt; del a[:]\n&gt;&gt;&gt; a\n[]</code></pre>\n\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><h2 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h2><p>在 Python 中，使用 <code>import</code> 关键字可以导入其他模块，以便在当前模块中使用该模块提供的功能。模块是一个包含了一组相关函数、类和变量的 Python 文件。</p>\n<p>可以使用以下几种方式进行模块导入：</p>\n<ol>\n<li><strong>完整导入</strong>：导入整个模块，使用 <code>import module_name</code> 语句。在使用模块中的函数、类和变量时，需要使用模块名作为前缀。</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import math\n\nresult &#x3D; math.sqrt(16)\nprint(result)  # 输出：4.0</code></pre>\n\n<p>在上面的示例中，使用 <code>import math</code> 导入了 Python 内置的 <code>math</code> 模块。通过 <code>math.sqrt(16)</code> 调用了模块中的 <code>sqrt</code> 函数，计算了 16 的平方根。</p>\n<ol start=\"2\">\n<li><strong>别名导入</strong>：为了简化模块名的使用，可以使用 <code>import module_name as alias</code> 语句给模块指定一个别名。</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import math as m\n\nresult &#x3D; m.sqrt(16)\nprint(result)  # 输出：4.0</code></pre>\n\n<p>在上面的示例中，使用 <code>import math as m</code> 将 <code>math</code> 模块导入，并给它指定了别名 <code>m</code>。通过 <code>m.sqrt(16)</code> 调用了模块中的 <code>sqrt</code> 函数。</p>\n<ol start=\"3\">\n<li><strong>部分导入</strong>：可以只导入模块中的特定函数、类或变量，而不是整个模块。使用 <code>from module_name import name1, name2</code> 语句进行部分导入。</li>\n</ol>\n<p>示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from math import sqrt\n\nresult &#x3D; sqrt(16)\nprint(result)  # 输出：4.0</code></pre>\n\n<p>在上面的示例中，使用 <code>from math import sqrt</code> 从 <code>math</code> 模块中只导入了 <code>sqrt</code> 函数。此时可以直接使用 <code>sqrt(16)</code> 调用该函数。</p>\n<p>除了上述的导入方式，还可以使用通配符 <code>*</code> 导入模块中的所有内容，但不推荐这种做法，因为可能导致命名冲突和不可预测的行为。</p>\n<p>模块导入使得我们能够利用现有的代码和功能，提高代码的复用性和可维护性，同时也使得 Python 生态系统变得丰富和强大。</p>\n<h2 id=\"使用-“import-os”-风格而非-“from-os-import-“。\"><a href=\"#使用-“import-os”-风格而非-“from-os-import-“。\" class=\"headerlink\" title=\"使用 “import os” 风格而非 “from os import *“。\"></a>使用 “import os” 风格而非 “from os import *“。</h2><p>这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()</p>\n<h2 id=\"是否是自己执行-每个模块都有一个-name-属性，当其值是-main-时，表明该模块自身在运行，否则是被引入\"><a href=\"#是否是自己执行-每个模块都有一个-name-属性，当其值是-main-时，表明该模块自身在运行，否则是被引入\" class=\"headerlink\" title=\"是否是自己执行 每个模块都有一个__name__属性，当其值是__main__时，表明该模块自身在运行，否则是被引入\"></a>是否是自己执行 每个模块都有一个<code>__name__</code>属性，当其值是<code>__main__</code>时，表明该模块自身在运行，否则是被引入</h2><h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>在 Python 中，<strong>包</strong>（Package）是一种用于组织模块的方式。它是一个包含了一组相关模块的目录，目录中除了包含模块文件外，还可以包含其他子包和子目录。通过使用包，可以更好地组织和管理大型的 Python 项目。</p>\n<p>一个包通常包含一个特殊的文件 <code>__init__.py</code>，它用于标识该目录是一个包。这个文件可以是一个空文件，也可以包含一些初始化代码。</p>\n<p>下面是一个包的示例结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">my_package&#x2F;\n    __init__.py\n    module1.py\n    module2.py\n    subpackage&#x2F;\n        __init__.py\n        module3.py</code></pre>\n\n<p>在上述示例中，<code>my_package</code> 是一个包，它包含了两个模块 <code>module1.py</code> 和 <code>module2.py</code>，以及一个子包 <code>subpackage</code>，子包中包含了一个模块 <code>module3.py</code>。</p>\n<p>通过包的层次结构，可以更好地组织和管理代码。在其他模块中导入包中的模块时，需要使用包名作为前缀。</p>\n<p>例如，在 <code>module1.py</code> 中导入 <code>module3.py</code>：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from my_package.subpackage import module3\n\nmodule3.some_function()</code></pre>\n\n<p>在上面的示例中，通过 <code>from my_package.subpackage import module3</code> 导入了包中的模块 <code>module3</code>，然后可以调用模块中的函数 <code>some_function()</code>。</p>\n<p>包的使用使得 Python 项目能够以模块化的方式进行组织，使得代码更具结构和可维护性。同时，它也方便了模块的命名空间管理，避免了命名冲突。</p>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h2 id=\"try-语句全部内容\"><a href=\"#try-语句全部内容\" class=\"headerlink\" title=\"try 语句全部内容\"></a>try 语句全部内容</h2><p><code>try</code> 语句是 Python 中用于捕获和处理异常的语句块。它允许我们编写可能引发异常的代码，并指定如何处理这些异常。<code>try</code> 语句的完整语法如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">try:\n    # 可能引发异常的代码块\n    # ...\nexcept [异常类型1]:\n    # 异常处理块1\n    # ...\nexcept [异常类型2]:\n    # 异常处理块2\n    # ...\n...\nexcept [异常类型N]:\n    # 异常处理块N\n    # ...\nelse:\n    # 未发生异常时执行的代码块\n    # ...\nfinally:\n    # 最终执行的代码块，无论是否发生异常都会执行\n    # ...</code></pre>\n\n<p><code>try</code> 语句的各个部分的作用如下：</p>\n<ul>\n<li><code>try</code>：必需的关键字，标志着 <code>try</code> 语句的开始。</li>\n<li><code>可能引发异常的代码块</code>：在 <code>try</code> 后面的冒号后编写的代码块，可能会引发异常。</li>\n<li><code>except</code>：可选的关键字，用于捕获和处理指定类型的异常。可以有多个 <code>except</code> 语句，分别处理不同的异常类型。</li>\n<li><code>异常类型</code>：指定要捕获的异常类型，可以是内置的异常类型（如 <code>ZeroDivisionError</code>、<code>ValueError</code> 等）或自定义的异常类型。</li>\n<li><code>异常处理块</code>：在 <code>except</code> 后面的冒号后编写的代码块，用于处理指定类型的异常。</li>\n<li><code>else</code>：可选的关键字，用于指定当没有发生异常时执行的代码块。如果 <code>try</code> 代码块中没有引发任何异常，那么将执行 <code>else</code> 代码块。</li>\n<li><code>finally</code>：可选的关键字，用于指定无论是否发生异常都会执行的最终代码块。</li>\n</ul>\n<p><code>try</code> 语句的执行过程如下：</p>\n<ol>\n<li>执行 <code>try</code> 代码块中的代码。</li>\n<li>如果在 <code>try</code> 代码块中引发了异常，那么程序会跳过剩余的 <code>try</code> 代码块中的代码，并进入与引发的异常类型匹配的 <code>except</code> 代码块，执行相应的异常处理代码。</li>\n<li>如果发生了多个异常类型的异常，那么只会进入第一个与异常类型匹配的 <code>except</code> 代码块。后面的 <code>except</code> 代码块将被忽略。</li>\n<li>如果没有发生任何异常，那么将执行 <code>else</code> 代码块中的代码。</li>\n<li>无论是否发生异常，最终都会执行 <code>finally</code> 代码块中的代码。</li>\n</ol>\n<p>下面是一个示例，演示了 <code>try</code> 语句的使用：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">try:\n    # 可能引发异常的代码块\n    x &#x3D; int(input(&quot;Enter a number: &quot;))\n    result &#x3D; 10 &#x2F; x\n    print(&quot;Result:&quot;, result)\nexcept ValueError:\n    # 处理 ValueError 异常\n    print(&quot;Invalid input. Please enter a valid number.&quot;)\nexcept ZeroDivisionError:\n    # 处理 ZeroDivisionError 异常\n    print(&quot;Cannot divide by zero!&quot;)\nelse:\n    # 未发生异常时执行的代码块\n    print(&quot;No exception occurred.&quot;)\nfinally:\n    # 最终执行的代码块\n    print(&quot;Execution complete.&quot;)</code></pre>\n\n<p>在上述示例中，用户被要求输入一个数字，然后尝试将其转换为整数并进行除法运算。可能会引发 <code>ValueError</code> 异常（如果输入的不是有效的数字）或 <code>ZeroDivisionError</code> 异常（如果输入的是 0）。根据引发的异常类型，程序会执行相应的异常处理块。</p>\n<p>注意，如果输入的是有效的数字且不为 0，那么将执行 <code>else</code> 代码块。最终，无论是否发生异常，都会执行 <code>finally</code> 代码块。</p>\n<p>通过使用 <code>try-except</code> 语句，我们可以捕获和处理异常，从而保证程序的稳定性和可靠性。异常处理使得我们能够对不同类型的异常进行特定的处理，提供有用的错误信息，并在出现异常时采取适当的行动。</p>\n<h2 id=\"触发异常的几种方式\"><a href=\"#触发异常的几种方式\" class=\"headerlink\" title=\"触发异常的几种方式\"></a>触发异常的几种方式</h2><p>在 Python 中，可以通过多种方式触发异常。下面列举了几种常见的触发异常的方式：</p>\n<ol>\n<li><p><strong>使用 <code>raise</code> 语句</strong>：可以使用 <code>raise</code> 语句手动引发异常。语法为 <code>raise 异常类型</code>。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">raise ValueError(&quot;Invalid value&quot;)</code></pre>\n\n<p>上述代码引发了一个 <code>ValueError</code> 异常，并提供了一个错误消息。</p>\n</li>\n<li><p><strong>调用内置函数引发异常</strong>：Python 提供了一些内置函数，可以用于引发特定类型的异常。例如：</p>\n<ul>\n<li><code>raise ValueError(&quot;Invalid value&quot;)</code> 会引发 <code>ValueError</code> 异常。</li>\n<li><code>assert 条件, &quot;错误消息&quot;</code> 会引发 <code>AssertionError</code> 异常，当条件为假时。</li>\n</ul>\n</li>\n<li><p><strong>使用内置异常类</strong>：可以直接实例化内置的异常类来触发异常。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">raise ValueError(&quot;Invalid value&quot;)</code></pre>\n\n<p>上述代码与第一种方式是等效的。</p>\n</li>\n<li><p><strong>抛出已捕获的异常</strong>：在 <code>except</code> 块中，可以使用 <code>raise</code> 语句重新抛出已捕获的异常。这样做可以将异常传递给上层的异常处理程序。例如：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">try:\n    # 一些代码\n    raise ValueError(&quot;Invalid value&quot;)\nexcept ValueError as ve:\n    print(&quot;Caught ValueError:&quot;, ve)\n    raise  # 重新抛出已捕获的异常</code></pre>\n\n<p>上述代码在捕获 <code>ValueError</code> 异常后，先打印异常信息，然后使用 <code>raise</code> 重新抛出异常。</p>\n</li>\n</ol>\n<p>这些是常见的触发异常的方式，可以根据需要选择适合的方式来引发异常。引发异常可以用于指示错误、异常情况或自定义的特殊情况，并且可以在异常处理中进行相应的处理。</p>\n<h2 id=\"定义清理行为-与-预定义的清理行为\"><a href=\"#定义清理行为-与-预定义的清理行为\" class=\"headerlink\" title=\"定义清理行为 与 预定义的清理行为\"></a>定义清理行为 与 预定义的清理行为</h2><p>在 Python 中，我们可以使用 <code>try-finally</code> 语句来定义清理行为。<code>finally</code> 代码块中的代码无论是否发生异常，都会执行。这使得我们可以在异常发生时执行必要的清理操作，确保资源的正确释放。</p>\n<p>下面是一个使用 <code>try-finally</code> 语句定义清理行为的示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">try:\n    # 可能引发异常的代码块\n    file &#x3D; open(&quot;file.txt&quot;, &quot;r&quot;)\n    # 执行一些操作\nfinally:\n    # 清理行为\n    file.close()  # 关闭文件</code></pre>\n\n<p>在上述示例中，我们打开了一个文件进行读取操作。在 <code>finally</code> 代码块中，我们使用 <code>file.close()</code> 关闭了文件。无论是否发生异常，都会执行 <code>finally</code> 代码块，从而确保文件被正确关闭。</p>\n<p>此外，Python 还提供了一些预定义的清理行为，可以通过特定的对象方法进行处理。例如：</p>\n<ul>\n<li><p>对于文件操作，可以使用 <code>with</code> 语句来自动管理文件的打开和关闭：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">with open(&quot;file.txt&quot;, &quot;r&quot;) as file:\n    # 执行一些操作</code></pre>\n\n<p><code>with</code> 语句会在代码块结束时自动关闭文件，无需手动调用 <code>file.close()</code>。</p>\n</li>\n<li><p>对于网络连接或数据库连接等资源，可以使用相关库提供的上下文管理器或连接池来管理资源的分配和释放。这样可以确保在使用完资源后，资源会被正确关闭和释放，避免资源泄露。</p>\n</li>\n</ul>\n<p>通过使用 <code>try-finally</code> 语句和预定义的清理行为，我们可以有效地管理资源，并在发生异常时进行必要的清理操作。这有助于确保程序的正确性和可靠性，并提高代码的可维护性。</p>\n<h2 id=\"类相关全部内容\"><a href=\"#类相关全部内容\" class=\"headerlink\" title=\"类相关全部内容\"></a>类相关全部内容</h2><p>类是面向对象编程的核心概念之一，在 Python 中使用类可以创建对象，定义对象的属性和行为。下面是类相关的全部内容：</p>\n<h3 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h3><p>在 Python 中，使用<code>class</code>关键字来定义类，类的命名通常采用驼峰命名法（首字母大写）。类定义由类名、属性和方法组成，属性是类的特征，方法是类的行为。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ClassName:\n    # 属性\n    attribute &#x3D; value\n\n    # 方法\n    def method(self, parameters):\n        # 方法体\n        # 可以访问属性和其他方法</code></pre>\n\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>通过类可以创建对象，即类的实例。使用类名后面跟一对括号即可创建对象，并可将其赋值给一个变量。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">object_name &#x3D; ClassName()</code></pre>\n\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>类的属性是类的特征或数据。属性可以是实例属性（属于对象）或类属性（属于类本身）。在类中使用变量来定义属性。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ClassName:\n    attribute &#x3D; value</code></pre>\n\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>类的方法是类的行为或操作。方法是与对象相关联的函数。在类中使用<code>def</code>关键字来定义方法。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ClassName:\n    def method(self, parameters):\n        # 方法体\n        # 可以访问属性和其他方法</code></pre>\n\n<p>在方法定义中，第一个参数通常是<code>self</code>，它表示当前对象自身。通过<code>self</code>可以访问对象的属性和其他方法。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>构造方法是在创建对象时自动调用的特殊方法，用于初始化对象的属性。构造方法的名称为<code>__init__</code>，它接受参数并设置对象的初始状态。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ClassName:\n    def __init__(self, parameters):\n        # 初始化对象属性</code></pre>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承是面向对象编程中实现代码重用和扩展的机制。一个类可以继承另一个类的属性和方法。被继承的类称为父类或基类，继承的类称为子类或派生类。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ChildClassName(ParentClassName):\n    # 子类的定义</code></pre>\n\n<p>子类可以访问父类的属性和方法，并可以重写或扩展父类的方法。</p>\n<h3 id=\"方法重写\"><a href=\"#方法重写\" class=\"headerlink\" title=\"方法重写\"></a>方法重写</h3><p>子类可以对继承自父类的方法进行重写，即在子类中定义与父类方法同名的方法，从而改变方法的实现。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ChildClassName(ParentClassName):\n    def method(self, parameters):\n        # 子类方法的实现</code></pre>\n\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态是面向对象编程中的一个概念，指的是同一种操作或方法可以应用于不同的对象，产生不同的结果。多态通过继承和方法重写来实现。</p>\n<h3 id=\"私有属性和方法\"><a href=\"#私有属性和方法\" class=\"headerlink\" title=\"私有属性和方法\"></a>私有属性和方法</h3><p>在 Python 中，可以使用双下划线<code>__</code>作为前缀来定义私有属性和方法，表示</p>\n<h2 id=\"Python-多态示例\"><a href=\"#Python-多态示例\" class=\"headerlink\" title=\"Python 多态示例\"></a>Python 多态示例</h2><p>下面是一个多态的示例，展示了如何使用继承和方法重写实现多态：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Animal:\n    def sound(self):\n        pass\n\nclass Cat(Animal):\n    def sound(self):\n        print(&quot;Meow&quot;)\n\nclass Dog(Animal):\n    def sound(self):\n        print(&quot;Woof&quot;)\n\nclass Cow(Animal):\n    def sound(self):\n        print(&quot;Moo&quot;)\n\n# 创建不同的动物对象\ncat &#x3D; Cat()\ndog &#x3D; Dog()\ncow &#x3D; Cow()\n\n# 调用相同的方法，产生不同的结果\ncat.sound()  # 输出：Meow\ndog.sound()  # 输出：Woof\ncow.sound()  # 输出：Moo</code></pre>\n\n<p>在上述示例中，我们定义了一个基类 <code>Animal</code> 和三个派生类 <code>Cat</code>、<code>Dog</code> 和 <code>Cow</code>。基类 <code>Animal</code> 定义了一个名为 <code>sound</code> 的方法，但没有具体的实现。</p>\n<p>每个派生类都重写了基类的 <code>sound</code> 方法，给出了不同的实现。当我们创建不同的动物对象并调用 <code>sound</code> 方法时，每个对象会根据其自身的实现产生不同的结果。这就是多态的体现，相同的方法名在不同的对象上表现出不同的行为。</p>\n<p>多态使得我们可以编写通用的代码，不需要为每种对象类型编写特定的处理逻辑。通过继承和方法重写，我们可以在不改变基类代码的情况下，扩展和定制特定类型的对象行为。这提高了代码的灵活性和可维护性。</p>\n<h2 id=\"Python-抽象类、抽象方法、接口\"><a href=\"#Python-抽象类、抽象方法、接口\" class=\"headerlink\" title=\"Python 抽象类、抽象方法、接口\"></a>Python 抽象类、抽象方法、接口</h2><p>在 Python 中，抽象类、抽象方法和接口是面向对象编程的概念，用于实现代码的抽象和规范。</p>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类是一种不能被实例化的类，它只能作为其他类的基类。抽象类用于定义一组共同的接口和方法，但不能被直接实例化。</p>\n<p><strong>在 Python 中，我们可以使用 <code>abc</code> 模块来创建抽象类。抽象类通常包含至少一个抽象方法，即没有具体实现的方法。子类必须实现所有的抽象方法，否则子类也将被视为抽象类。</strong></p>\n<p>下面是一个抽象类的示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from abc import ABC, abstractmethod\n\nclass AbstractClass(ABC):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\nclass ConcreteClass(AbstractClass):\n    def abstract_method(self):\n        print(&quot;Implementing abstract_method&quot;)\n\n# 抽象类无法实例化\n# obj &#x3D; AbstractClass()\n\n# 创建子类对象\nobj &#x3D; ConcreteClass()\nobj.abstract_method()</code></pre>\n\n<p>在上述示例中，<code>AbstractClass</code> 是一个抽象类，其中的 <code>abstract_method</code> 是一个抽象方法，它没有具体的实现。<code>ConcreteClass</code> 是 <code>AbstractClass</code> 的子类，必须实现抽象方法。</p>\n<h3 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h3><p>抽象方法是在抽象类中声明但没有具体实现的方法。抽象方法必须在子类中被重写实现。</p>\n<p>在 Python 中，使用 <code>@abstractmethod</code> 装饰器来将方法声明为抽象方法。抽象方法通常没有方法体，只有方法签名。</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p><strong>在 Python 中，没有直接的内置接口概念。接口是一组规范，描述了类应该具有的属性和方法。在 Python 中，接口通常通过抽象类和抽象方法来实现</strong>。</p>\n<p>Python 的面向对象编程风格更倾向于”鸭子类型”，<strong>即只关注对象的行为而不关心对象的类型</strong>。因此，Python 中的接口概念更加灵活，不需要显式地声明接口。</p>\n<p>可以通过遵循特定的命名约定来表示一个类实现了某个接口，例如按照约定，类中包含 <code>__iter__</code> 方法表示它是可迭代的接口。</p>\n<p><strong>尽管 Python 没有严格的接口定义，但我们可以通过抽象类和抽象方法的组合来实现类似接口的行为</strong>。</p>\n<h3 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h3><p>在 Python 中，私有方法是指在类定义中以双下划线 <code>__</code> 开头的方法。私有方法只能在类的内部被调用，无法在类的外部直接访问。</p>\n<p>下面是一个示例，展示了如何定义和使用私有方法：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class MyClass:\n    def public_method(self):\n        print(&quot;This is a public method.&quot;)\n        self.__private_method()\n\n    def __private_method(self):\n        print(&quot;This is a private method.&quot;)\n\n# 创建对象\nobj &#x3D; MyClass()\n\n# 调用公有方法\nobj.public_method()  # 输出：This is a public method. This is a private method.\n\n# 无法直接调用私有方法\n# obj.__private_method()  # 报错：AttributeError: &#39;MyClass&#39; object has no attribute &#39;__private_method&#39;</code></pre>\n\n<p>在上述示例中，<code>MyClass</code> 类定义了一个公有方法 <code>public_method</code> 和一个私有方法 <code>__private_method</code>。公有方法可以在类的内部和外部被调用，而私有方法只能在类的内部被调用。</p>\n<p>注意，私有方法的命名约定是以双下划线开头，但实际上 Python 解释器会对私有方法进行名称修饰，将其重命名为 <code>_ClassName__private_method</code> 的形式，以避免与其他类的私有方法冲突。</p>\n<p>尽管私有方法无法在类的外部直接调用，但在类的内部，公有方法仍然可以调用私有方法。这样可以确保私有方法只在类的内部使用，起到了封装和隐藏实现细节的作用。私有方法通常用于帮助公有方法执行一些内部的、辅助性的操作。</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>在 Python 中，静态方法是类中定义的一种特殊类型的方法。静态方法与类的实例无关，它可以在类级别上直接调用，而无需创建类的实例。</p>\n<p>以下是静态方法的定义和使用示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class MyClass:\n    @staticmethod\n    def static_method():\n        print(&quot;This is a static method.&quot;)\n\n# 调用静态方法，不需要创建类的实例\nMyClass.static_method()  # 输出：This is a static method.</code></pre>\n\n<p>在上述示例中，<code>MyClass</code> 类定义了一个静态方法 <code>static_method</code>，使用 <code>@staticmethod</code> 装饰器来指示它是一个静态方法。静态方法不需要传递任何实例参数，因此在调用时不需要创建类的实例，可以直接通过类名调用。</p>\n<p>静态方法与类的状态无关，它主要用于实现与类相关但不依赖于实例的功能。静态方法在类的内部可以访问类的属性和其他静态方法，但无法访问实例属性和实例方法。</p>\n<p>与实例方法不同，静态方法无需访问或修改类的实例状态，因此它们通常用于执行通用的功能或实现独立于特定实例的逻辑。静态方法在代码中更具有模块化和独立性，可以方便地进行单元测试和重用。</p>\n<h2 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h2><p>在面向对象编程中，单例是一种设计模式，它确保一个类只有一个实例，并提供全局访问点以获取该实例。在 Python 中，实现单例模式有多种方式，其中常用的方式是使用模块级别的变量、装饰器或元类。</p>\n<p>以下是使用模块级别的变量实现单例的示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># singleton.py\nclass SingletonClass:\n    def __init__(self):\n        pass\n\n# 创建单例实例\nsingleton_instance &#x3D; SingletonClass()</code></pre>\n\n<p>在上述示例中，<code>singleton.py</code> 文件定义了一个类 <code>SingletonClass</code>，并在模块级别创建了一个名为 <code>singleton_instance</code> 的变量来保存单例实例。该变量在模块第一次导入时被创建，并在后续的导入中被重用，因此无论在哪里导入该模块，都可以获得相同的实例。</p>\n<p>使用装饰器实现单例模式的示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def singleton(class_):\n    instances &#x3D; &#123;&#125;\n\n    def wrapper(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] &#x3D; class_(*args, **kwargs)\n        return instances[class_]\n\n    return wrapper\n\n@singleton\nclass SingletonClass:\n    def __init__(self):\n        pass</code></pre>\n\n<p>在上述示例中，<code>singleton</code> 是一个装饰器函数，它接受一个类作为参数，并返回一个包装器函数。包装器函数在每次创建实例时检查该类是否已经有一个实例存在，如果存在则返回现有的实例，否则创建一个新的实例并返回。</p>\n<p>使用元类实现单例模式的示例：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class SingletonMeta(type):\n    _instances &#x3D; &#123;&#125;\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] &#x3D; super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass SingletonClass(metaclass&#x3D;SingletonMeta):\n    def __init__(self):\n        pass</code></pre>\n\n<p>在上述示例中，<code>SingletonMeta</code> 是一个元类，它继承自 <code>type</code>。元类定义了 <code>__call__</code> 方法，该方法在创建类的实例时被调用。在 <code>__call__</code> 方法中，检查类是否已经有一个实例存在，如果存在则返回现有的实例，否则创建一个新的实例并返回。</p>\n<p>以上是几种常见的实现单例模式的方式，你可以根据自己的需求选择其中一种方式来实现单例。无论使用哪种方式，单例模式都可以确保一个类只有一个实例，并提供全局访问点以获取该实例。</p>\n<h1 id=\"命名空间和作用域\"><a href=\"#命名空间和作用域\" class=\"headerlink\" title=\"命名空间和作用域\"></a>命名空间和作用域</h1><h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>命名空间（Namespace）是指用于存储和管理变量和对象名称的容器。它们在编程语言中起到了组织和隔离代码标识符的作用。在 Python 中，命名空间用于管理变量、函数、类和其他对象的名称。</p>\n<p>Python 中有多个类型的命名空间，包括：</p>\n<ol>\n<li><p>内置命名空间（Built-in Namespace）：包含内置函数和内置对象的名称，如 <code>print()</code>、<code>len()</code>、<code>list</code> 等。这些名称可以直接使用，无需导入任何模块。</p>\n</li>\n<li><p>全局命名空间（Global Namespace）：包含在全局范围内定义的名称，即在模块级别定义的变量、函数、类等。全局命名空间在整个模块中可见。</p>\n</li>\n<li><p>局部命名空间（Local Namespace）：在函数或类的定义中，每当进入一个函数或方法，都会创建一个局部命名空间。局部命名空间包含函数的参数、函数内部定义的变量、临时变量等。局部命名空间在函数或方法内部有效，函数执行结束后会被销毁。</p>\n</li>\n</ol>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>作用域（Scope）是指在程序中访问命名空间中名称的规则。作用域定义了在不同上下文中名称的可见性和可访问性。</p>\n<p>在 Python 中，有以下几种作用域：</p>\n<ol>\n<li><p>内置作用域（Built-in Scope）：包含内置函数和内置对象的名称。这些名称在任何地方都是可见的。</p>\n</li>\n<li><p>全局作用域（Global Scope）：包含在全局范围内定义的名称，即在模块级别定义的变量、函数、类等。全局作用域在整个模块中可见。</p>\n</li>\n<li><p>局部作用域（Local Scope）：在函数或类的定义中，每当进入一个函数或方法，都会创建一个局部作用域。局部作用域包含函数的参数、函数内部定义的变量、临时变量等。局部作用域在函数或方法内部有效，函数执行结束后会被销毁。</p>\n</li>\n<li><p>嵌套作用域（Enclosing Scope）：在嵌套函数中，内部函数可以访问外部函数的变量。嵌套作用域允许变量在嵌套的函数之间共享。</p>\n</li>\n</ol>\n<p>作用域链（Scope Chain）是指在程序中查找和解析名称时，按照一定的规则在命名空间中查找名称的顺序。作用域链由嵌套的作用域组成，使得内部作用域可以访问外部作用域中的变量。</p>\n<p>Python 遵循 LEGB 规则来解析名称：</p>\n<ul>\n<li>L：Local，局部作用域</li>\n<li>E：Enclosing，嵌套作用域</li>\n<li>G：Global，全局作用域</li>\n<li>B：Built-in，内置作用域</li>\n</ul>\n<p>在解析名称时，Python 会按照从内到外的顺序查找名称，直到找到第一个匹配的名称为止。如果在任何作用域中都没有找到匹配的名称，则会引发 <code>NameError</code>。</p>\n<p>以下是一个示例来说明命名空间和作用域的概念：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">x &#x3D; 10  # 全局作用域\n\ndef outer_func():\n    y &#x3D; 20  # outer_func 的局部作用域\n\n    def inner_func():\n        z &#x3D; 30  # inner_func 的局部作用域\n        print(x, y, z)  # 可以访问全局作用域和外部作用域中的变量\n\n    inner_func()\n\nouter_func()</code></pre>\n\n<p>在上述示例中，<code>x</code> 是全局作用域中定义的变量，在 <code>outer_func</code> 和 <code>inner_func</code> 的局部作用域中都可以访问到它。<code>y</code> 是 <code>outer_func</code> 的局部作用域中定义的变量，只能在 <code>outer_func</code> 和 <code>inner_func</code> 的局部作用域中访问。<code>z</code> 是 <code>inner_func</code> 的局部作用域中定义的变量，只能在 <code>inner_func</code> 的局部作用域中访问。</p>\n<p>当执行 <code>inner_func</code> 时，会按照 LEGB 规则查找并解析名称。首先在局部作用域中查找，找到 <code>z</code>；然后在外部作用域（<code>outer_func</code> 的作用域）中查找，找到 <code>y</code>；最后在全局作用域中查找，找到 <code>x</code>。因此，执行结果是 <code>10 20 30</code>。</p>\n<p>理解命名空间和作用域的概念对于编写和理解 Python 代码非常重要。它们可以帮助你组织代码、避免命名冲突，并了解变量和对象在不同上下文中的可见性和可访问性。</p>\n<h1 id=\"标准库\"><a href=\"#标准库\" class=\"headerlink\" title=\"标准库\"></a>标准库</h1><h2 id=\"time-库\"><a href=\"#time-库\" class=\"headerlink\" title=\"time 库\"></a>time 库</h2><p><code>time</code> 库提供了一些常用的函数和常量，用于处理时间和日期。以下是 <code>time</code> 库的一些常见 API：</p>\n<ul>\n<li><code>time()</code>：返回当前时间的时间戳（从 1970 年 1 月 1 日午夜开始的秒数）。</li>\n<li><code>sleep(secs)</code>：暂停执行指定秒数的时间。</li>\n<li><code>ctime([secs])</code>：将给定的时间戳（默认为当前时间戳）转换为可读的字符串表示形式。</li>\n<li><code>gmtime([secs])</code>：将给定的时间戳（默认为当前时间戳）转换为格林威治标准时间的结构化形式。</li>\n<li><code>localtime([secs])</code>：将给定的时间戳（默认为当前时间戳）转换为本地时间的结构化形式。</li>\n<li><code>asctime([t])</code>：将时间元组（默认为当前时间）转换为可读的字符串表示形式。</li>\n<li><code>strftime(format[, t])</code>：根据指定的格式字符串，将时间元组（默认为当前时间）转换为自定义格式的字符串。</li>\n<li><code>strptime(string, format)</code>：将给定格式的字符串解析为时间元组。</li>\n<li><code>perf_counter()</code>：返回一个具有高分辨率的性能计数器的值，用于测量短暂时间间隔的性能。</li>\n<li><code>process_time()</code>：返回当前进程的 CPU 时间，包括系统和用户 CPU 时间。</li>\n</ul>\n<p>这些是 <code>time</code> 库中的一些常用函数，可以在程序中根据需要使用它们来处理时间和日期。请注意，这些函数返回的时间通常是基于秒的时间戳或结构化的时间元组，你可能需要根据需要进行格式化或转换。详细的文档可以在 Python 官方文档中找到。</p>\n<h2 id=\"time-库-API-对应的示例\"><a href=\"#time-库-API-对应的示例\" class=\"headerlink\" title=\"time 库 API 对应的示例\"></a>time 库 API 对应的示例</h2><p>下面是一些示例代码，展示了如何使用 <code>time</code> 库中的一些常见 API：</p>\n<ol>\n<li>获取当前时间戳：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\ntimestamp &#x3D; time.time()\nprint(timestamp)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1621448812.5327687</code></pre>\n\n<ol start=\"2\">\n<li>暂停执行指定秒数的时间：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\nprint(&quot;Start&quot;)\ntime.sleep(3)\nprint(&quot;End&quot;)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Start\n[等待3秒]\nEnd</code></pre>\n\n<ol start=\"3\">\n<li>将时间戳转换为可读的字符串形式：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\ntimestamp &#x3D; time.time()\ntime_string &#x3D; time.ctime(timestamp)\nprint(time_string)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Sun May 19 23:07:10 2023</code></pre>\n\n<ol start=\"4\">\n<li>将时间元组转换为自定义格式的字符串：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\ntimestamp &#x3D; time.time()\ntime_tuple &#x3D; time.localtime(timestamp)\ntime_string &#x3D; time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time_tuple)\nprint(time_string)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19 23:07:10</code></pre>\n\n<ol start=\"5\">\n<li>获取 CPU 的性能计数器的值：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\nstart_time &#x3D; time.perf_counter()\n# 执行一些操作\nend_time &#x3D; time.perf_counter()\nelapsed_time &#x3D; end_time - start_time\nprint(f&quot;Elapsed time: &#123;elapsed_time&#125; seconds&quot;)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Elapsed time: 0.005839846 seconds</code></pre>\n\n<ol start=\"6\">\n<li>将时间元组转换为时间戳：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\ntime_tuple &#x3D; (2023, 5, 19, 23, 7, 10, 0, 0, 0)  # (year, month, day, hour, minute, second, weekday, Julian day, DST flag)\ntimestamp &#x3D; time.mktime(time_tuple)\nprint(timestamp)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1671413230.0</code></pre>\n\n<ol start=\"7\">\n<li>根据指定格式解析时间字符串：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\ntime_string &#x3D; &quot;2023-05-19 23:07:10&quot;\ntime_tuple &#x3D; time.strptime(time_string, &quot;%Y-%m-%d %H:%M:%S&quot;)\nprint(time_tuple)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">time.struct_time(tm_year&#x3D;2023, tm_mon&#x3D;5, tm_mday&#x3D;19, tm_hour&#x3D;23, tm_min&#x3D;7, tm_sec&#x3D;10, tm_wday&#x3D;5, tm_yday&#x3D;139, tm_isdst&#x3D;-1)</code></pre>\n\n<ol start=\"8\">\n<li>获取程序运行时间：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\nstart_time &#x3D; time.process_time()\n\n# 执行一些操作\nsum(range(1000000))\n\nend_time &#x3D; time.process_time()\nelapsed_time &#x3D; end_time - start_time\nprint(f&quot;Elapsed time: &#123;elapsed_time&#125; seconds&quot;)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Elapsed time: 0.02943952099999996 seconds</code></pre>\n\n<p>这些示例展示了更多关于 <code>time</code> 库的用法，包括时间元组与时间戳之间的转换、解析时间字符串、以及测量程序运行时间。这些功能可以在不同的场景中帮助你处理时间和日期相关的操作。记住，在实际使用中，你可以根据具体需求和情境选择适当的时间函数和方法。</p>\n<h2 id=\"datetime-模块有哪些-API\"><a href=\"#datetime-模块有哪些-API\" class=\"headerlink\" title=\"datetime 模块有哪些 API\"></a>datetime 模块有哪些 API</h2><p><code>datetime</code> 模块提供了一些常用的类和函数，用于处理日期和时间。以下是 <code>datetime</code> 模块的一些常见 API：</p>\n<ol>\n<li><p>类和对象：</p>\n<ul>\n<li><code>datetime</code>：表示日期和时间的对象，包含年、月、日、时、分、秒等信息。</li>\n<li><code>date</code>：表示日期的对象，包含年、月、日信息。</li>\n<li><code>time</code>：表示时间的对象，包含时、分、秒等信息。</li>\n<li><code>timedelta</code>：表示时间间隔的对象，可以用于日期和时间的计算。</li>\n<li><code>tzinfo</code>：表示时区信息的基类。</li>\n</ul>\n</li>\n<li><p>获取当前日期和时间：</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import datetime\n\ncurrent_datetime &#x3D; datetime.now()\nprint(current_datetime)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19 23:07:10.123456</code></pre>\n\n<ol start=\"3\">\n<li>创建特定日期和时间的对象：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import datetime, date, time\n\nspecific_date &#x3D; date(2023, 5, 19)\nspecific_time &#x3D; time(23, 7, 10)\nspecific_datetime &#x3D; datetime(2023, 5, 19, 23, 7, 10)\n\nprint(specific_date)\nprint(specific_time)\nprint(specific_datetime)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19\n23:07:10\n2023-05-19 23:07:10</code></pre>\n\n<ol start=\"4\">\n<li>格式化日期和时间：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import datetime\n\ncurrent_datetime &#x3D; datetime.now()\nformatted_datetime &#x3D; current_datetime.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)\n\nprint(formatted_datetime)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19 23:07:10</code></pre>\n\n<ol start=\"5\">\n<li>解析字符串为日期和时间对象：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import datetime\n\ndate_string &#x3D; &quot;2023-05-19&quot;\ntime_string &#x3D; &quot;23:07:10&quot;\ndatetime_string &#x3D; &quot;2023-05-19 23:07:10&quot;\n\nparsed_date &#x3D; datetime.strptime(date_string, &quot;%Y-%m-%d&quot;).date()\nparsed_time &#x3D; datetime.strptime(time_string, &quot;%H:%M:%S&quot;).time()\nparsed_datetime &#x3D; datetime.strptime(datetime_string, &quot;%Y-%m-%d %H:%M:%S&quot;)\n\nprint(parsed_date)\nprint(parsed_time)\nprint(parsed_datetime)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19\n23:07:10\n2023-05-19 23:07:10</code></pre>\n\n<p>这些是 <code>datetime</code> 模块中的一些常用 API，可以用于处理日期和时间相关的操作。你可以根据需要使用这些函数和类来获取当前日期时间、创建特定的日期时间对象、格式化和解析日期时间字符串等。详细的文档可以在 Python 官方文档中找到。</p>\n<h2 id=\"datetime-API-对应的示例\"><a href=\"#datetime-API-对应的示例\" class=\"headerlink\" title=\"datetime API 对应的示例\"></a>datetime API 对应的示例</h2><p>下面是使用 <code>datetime</code> 模块的不同类和对象的示例：</p>\n<ol>\n<li><code>datetime</code> 类示例：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import datetime\n\ncurrent_datetime &#x3D; datetime.now()\nprint(current_datetime)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19 23:07:10.123456</code></pre>\n\n<ol start=\"2\">\n<li><code>date</code> 类示例：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import date\n\nspecific_date &#x3D; date(2023, 5, 19)\nprint(specific_date)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19</code></pre>\n\n<ol start=\"3\">\n<li><code>time</code> 类示例：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import time\n\nspecific_time &#x3D; time(23, 7, 10)\nprint(specific_time)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">23:07:10</code></pre>\n\n<ol start=\"4\">\n<li><code>timedelta</code> 类示例：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import datetime, timedelta\n\ncurrent_datetime &#x3D; datetime.now()\nfuture_datetime &#x3D; current_datetime + timedelta(days&#x3D;3, hours&#x3D;2)\nprint(future_datetime)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-22 01:07:10.123456</code></pre>\n\n<ol start=\"5\">\n<li><code>tzinfo</code> 类示例（需要自定义子类）：</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from datetime import datetime, timedelta, tzinfo\n\nclass MyTimezone(tzinfo):\n    def utcoffset(self, dt):\n        return timedelta(hours&#x3D;8)  # 设置为 UTC+8\n\ncurrent_datetime &#x3D; datetime.now(tz&#x3D;MyTimezone())\nprint(current_datetime)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2023-05-19 23:07:10.123456+08:00</code></pre>\n\n<p>这些示例演示了 <code>datetime</code> 模块中不同类和对象的用法。你可以根据需要使用这些类来处理日期和时间，创建特定的日期时间对象，进行日期时间的计算和调整，以及处理时区信息等。根据实际需求，你可以灵活地使用这些类和对象来完成各种日期时间操作。</p>\n<h2 id=\"time-库与-datetime-库有什么区别\"><a href=\"#time-库与-datetime-库有什么区别\" class=\"headerlink\" title=\"time 库与 datetime 库有什么区别\"></a>time 库与 datetime 库有什么区别</h2><p><code>time</code> 库和 <code>datetime</code> 库都是 Python 中用于处理时间和日期的标准库，但它们有一些区别。</p>\n<ol>\n<li><p>功能不同：</p>\n<ul>\n<li><code>time</code> 库主要用于处理时间相关的操作，例如获取当前时间、计时等。它提供了一些函数和常量，如 <code>time()</code>、<code>sleep()</code>、<code>ctime()</code> 等，用于处理时间戳、等待一定时间、格式化时间等。</li>\n<li><code>datetime</code> 库提供了更丰富的日期和时间操作功能。它包含了 <code>date</code>、<code>time</code>、<code>datetime</code>、<code>timedelta</code> 等类，可以用于处理日期、时间、日期时间的计算、格式化等。</li>\n</ul>\n</li>\n<li><p>数据类型不同：</p>\n<ul>\n<li><code>time</code> 库主要使用时间戳（浮点数表示从 1970 年 1 月 1 日以来的秒数）来表示时间。</li>\n<li><code>datetime</code> 库使用更高级的数据类型，如 <code>datetime</code> 类表示日期和时间，<code>date</code> 类表示日期，<code>time</code> 类表示时间。</li>\n</ul>\n</li>\n<li><p>精度不同：</p>\n<ul>\n<li><code>time</code> 库提供的时间函数通常具有更高的精度，可以测量更小的时间单位，如纳秒级别。</li>\n<li><code>datetime</code> 库的精度较低，主要用于处理年、月、日、时、分、秒等常见时间单位。</li>\n</ul>\n</li>\n<li><p>功能的使用场景不同：</p>\n<ul>\n<li><code>time</code> 库适用于需要处理时间相关操作的场景，例如计时、等待、性能测试等。</li>\n<li><code>datetime</code> 库适用于处理日期和时间的常规操作，例如日期计算、日期比较、日期格式化等。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，<code>time</code> 库主要用于处理时间戳和基本的时间操作，而 <code>datetime</code> 库提供了更丰富的日期和时间操作功能。在实际开发中，根据具体的需求选择合适的库来处理时间和日期操作。</p>\n<h2 id=\"测试性能\"><a href=\"#测试性能\" class=\"headerlink\" title=\"测试性能\"></a>测试性能</h2><p><code>Timer</code> 是 Python 中用于测量代码执行时间的类。它位于 <code>timeit</code> 模块中。</p>\n<p>你提供的代码 <code>Timer(&#39;t=a; a=b; b=t&#39;, &#39;a=1; b=2&#39;).timeit()</code> 的含义如下：</p>\n<ul>\n<li><code>&#39;t=a; a=b; b=t&#39;</code> 是要测量执行时间的代码块，其中 <code>t=a; a=b; b=t</code> 表示将变量 <code>a</code> 和 <code>b</code> 的值交换。</li>\n<li><code>&#39;a=1; b=2&#39;</code> 是准备执行的设置语句，其中 <code>a=1</code> 表示将变量 <code>a</code> 的值设置为 1，<code>b=2</code> 表示将变量 <code>b</code> 的值设置为 2。</li>\n</ul>\n<p>调用 <code>Timer</code> 类的 <code>timeit()</code> 方法会执行多次给定的代码块，并返回执行时间的浮点数值。默认情况下，<code>timeit()</code> 方法会执行代码块 1,000,000 次以获取更准确的时间。</p>\n<p>因此，<code>Timer(&#39;t=a; a=b; b=t&#39;, &#39;a=1; b=2&#39;).timeit()</code> 将会测量执行代码块 <code>t=a; a=b; b=t</code> 的时间，使用变量 <code>a</code> 初始值为 1，<code>b</code> 初始值为 2。</p>\n<p>请注意，上述代码是在 <code>timeit</code> 模块的环境中执行的，而不是直接在 Python 解释器中执行。要在 Python 解释器中执行该代码，可以按照以下方式编写：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import timeit\n\ndef swap_values():\n    a &#x3D; 1\n    b &#x3D; 2\n    t &#x3D; a\n    a &#x3D; b\n    b &#x3D; t\n\nexecution_time &#x3D; timeit.timeit(swap_values, number&#x3D;1000000)\nprint(execution_time)</code></pre>\n\n<p>上述代码定义了一个名为 <code>swap_values</code> 的函数，其中包含要测量执行时间的代码块。然后使用 <code>timeit.timeit()</code> 函数传入函数名和执行次数来测量执行时间，并将结果打印出来。在这个例子中，代码块将被执行 1,000,000 次，并返回总的执行时间。</p>\n<h2 id=\"json-模块-API-及示例\"><a href=\"#json-模块-API-及示例\" class=\"headerlink\" title=\"json 模块 API 及示例\"></a>json 模块 API 及示例</h2><p><code>json</code> 模块提供了用于 JSON 数据编码和解码的函数。以下是 <code>json</code> 模块的一些常见 API 和示例：</p>\n<ol>\n<li><code>json.dumps()</code>：将 Python 对象转换为 JSON 字符串。</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import json\n\ndata &#x3D; &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;\njson_string &#x3D; json.dumps(data)\nprint(json_string)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;</code></pre>\n\n<ol start=\"2\">\n<li><code>json.loads()</code>：将 JSON 字符串转换为 Python 对象。</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import json\n\njson_string &#x3D; &#39;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#39;\ndata &#x3D; json.loads(json_string)\nprint(data)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;</code></pre>\n\n<ol start=\"3\">\n<li><code>json.dump()</code>：将 Python 对象写入 JSON 文件。</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import json\n\ndata &#x3D; &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;\n\nwith open(&quot;data.json&quot;, &quot;w&quot;) as file:\n    json.dump(data, file)</code></pre>\n\n<ol start=\"4\">\n<li><code>json.load()</code>：从 JSON 文件中读取数据并转换为 Python 对象。</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import json\n\nwith open(&quot;data.json&quot;, &quot;r&quot;) as file:\n    data &#x3D; json.load(file)\n    print(data)</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;</code></pre>\n\n<p>这些是 <code>json</code> 模块的一些常用 API。你可以使用 <code>dumps()</code> 和 <code>loads()</code> 函数进行 JSON 字符串和 Python 对象之间的转换，使用 <code>dump()</code> 和 <code>load()</code> 函数来读写 JSON 文件。这些函数提供了方便的方式来处理 JSON 数据的编码和解码操作。请注意，<code>json</code> 模块还提供其他功能，例如处理特定类型的编码和解码方式，对 JSON 数据进行格式化等。详细的文档可以在 Python 官方文档中找到。</p>\n<h2 id=\"pip-执行过程（不是我想要的答案）\"><a href=\"#pip-执行过程（不是我想要的答案）\" class=\"headerlink\" title=\"pip 执行过程（不是我想要的答案）\"></a>pip 执行过程（不是我想要的答案）</h2><p>当你在命令行中使用 <code>pip</code> 命令时，它会执行以下步骤：</p>\n<ol>\n<li><p>解析命令行参数：<code>pip</code> 命令会解析你在命令行中输入的参数，如要安装、卸载、更新或查看包等操作。</p>\n</li>\n<li><p>确定操作和目标包：根据解析的参数，<code>pip</code> 确定执行的具体操作，如安装、卸载、更新等，并确定目标包的名称和版本。</p>\n</li>\n<li><p>确定包源和依赖关系：<code>pip</code> 根据配置文件（如 <code>pip.conf</code>）中的设置，确定要从哪个源（如 PyPI）下载包，并获取包的元数据，包括包的名称、版本、依赖关系等。</p>\n</li>\n<li><p>下载和安装包：<code>pip</code> 通过网络连接到指定的包源，下载目标包的压缩文件（通常是 <code>.tar.gz</code> 或 <code>.whl</code> 格式），然后解压缩并将包的文件安装到适当的位置。</p>\n</li>\n<li><p>解决依赖关系：如果目标包有依赖关系，<code>pip</code> 会递归解析和安装这些依赖关系，确保所有依赖包都被正确安装。</p>\n</li>\n<li><p>执行操作：根据命令行参数确定的操作，<code>pip</code> 执行相应的操作，如安装、卸载、更新等。</p>\n</li>\n<li><p>完成操作：一旦操作完成，<code>pip</code> 会显示相应的结果和提示信息，告诉你操作是否成功完成。</p>\n</li>\n</ol>\n<p>注意，<code>pip</code> 还可以与虚拟环境一起使用，以便在不同的项目中管理不同的包和版本。在虚拟环境中，<code>pip</code> 会安装包到该环境的独立目录中，以避免与其他环境或全局安装的包发生冲突。</p>\n<p>总之，<code>pip</code> 是一个功能强大的包管理工具，它简化了在 Python 中安装、升级和管理包的过程，使开发者能够轻松地使用各种第三方库和工具。</p>\n<h1 id=\"协程通信\"><a href=\"#协程通信\" class=\"headerlink\" title=\"协程通信\"></a>协程通信</h1><p>协程（Coroutine）是一种轻量级的并发编程方式，它可以在一个线程内实现并发执行的效果。在 Python 中，协程通过 <code>asyncio</code> 模块来支持，使用 <code>async</code> 和 <code>await</code> 关键字来定义和管理协程。</p>\n<p>协程的特点包括：</p>\n<ol>\n<li><p>非抢占式：协程是由程序员手动控制切换的，它不会被操作系统的调度器中断，而是在遇到 <code>await</code> 关键字时主动让出执行权。</p>\n</li>\n<li><p>轻量级：协程不需要创建新的线程或进程，可以在一个线程内并发执行，节省系统资源。</p>\n</li>\n<li><p>高效：协程的切换是在代码级别完成的，切换开销较小。</p>\n</li>\n</ol>\n<p>使用协程可以实现异步编程，解决并发性能问题。在协程中，可以使用 <code>async def</code> 定义一个协程函数，其中可以使用 <code>await</code> 关键字来挂起协程的执行，等待其他协程或异步任务完成。</p>\n<p>以下是一个简单的示例，展示了如何使用协程实现异步任务的并发执行：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import asyncio\n\nasync def task(name, delay):\n    print(f&quot;Task &#123;name&#125; started&quot;)\n    await asyncio.sleep(delay)\n    print(f&quot;Task &#123;name&#125; completed&quot;)\n\nasync def main():\n    tasks &#x3D; [\n        asyncio.create_task(task(&quot;A&quot;, 2)),\n        asyncio.create_task(task(&quot;B&quot;, 1)),\n        asyncio.create_task(task(&quot;C&quot;, 3))\n    ]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())</code></pre>\n\n<p>在上面的示例中，<code>task()</code> 函数是一个协程函数，它模拟了一个耗时的异步任务。<code>main()</code> 函数是主协程，它使用 <code>asyncio.create_task()</code> 创建了多个任务，并使用 <code>asyncio.gather()</code> 并发执行这些任务。通过运行 <code>asyncio.run(main())</code> 来启动事件循环并执行协程。</p>\n<p>协程是异步编程的重要概念，它在处理高并发和 IO 密集型任务时非常有用。通过合理地利用协程，可以提升程序的性能和响应能力。</p>\n<h2 id=\"异步上下文管理器\"><a href=\"#异步上下文管理器\" class=\"headerlink\" title=\"异步上下文管理器\"></a>异步上下文管理器</h2><p>异步上下文管理器（Async Context Manager）是在异步环境下使用的上下文管理器。它提供了在进入和退出特定上下文时执行异步操作的功能。</p>\n<p>在 Python 中，常规的上下文管理器使用 <code>with</code> 语句来管理资源的获取和释放，而异步上下文管理器则使用 <code>async with</code> 语句。异步上下文管理器是通过实现 <code>__aenter__()</code> 和 <code>__aexit__()</code> 方法来定义的，这些方法可以执行异步操作。</p>\n<p>以下是一个示例，展示了如何创建和使用异步上下文管理器：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import asyncio\n\nclass AsyncContextManager:\n    async def __aenter__(self):\n        # 在进入上下文之前执行的异步操作\n        await asyncio.sleep(1)\n        print(&quot;AsyncContextManager: Enter&quot;)\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        # 在退出上下文时执行的异步操作\n        await asyncio.sleep(1)\n        print(&quot;AsyncContextManager: Exit&quot;)\n\nasync def main():\n    async with AsyncContextManager():\n        # 在上下文中执行的异步操作\n        await asyncio.sleep(2)\n        print(&quot;Inside async with&quot;)\n\nasyncio.run(main())</code></pre>\n\n<p>在上面的示例中，<code>AsyncContextManager</code> 类实现了 <code>__aenter__()</code> 和 <code>__aexit__()</code> 方法作为异步上下文管理器的定义。在 <code>__aenter__()</code> 方法中，我们可以执行一些异步操作，例如等待特定时间。在 <code>__aexit__()</code> 方法中，我们可以执行一些清理操作。</p>\n<p>在 <code>main()</code> 函数中，我们使用 <code>async with</code> 语句来使用异步上下文管理器。在进入上下文时，会调用 <code>__aenter__()</code> 方法执行异步操作。在退出上下文时，会调用 <code>__aexit__()</code> 方法执行异步操作。</p>\n<p>使用异步上下文管理器可以方便地管理异步资源，例如数据库连接、文件操作等。它们使得在异步环境中处理资源的获取和释放更加简洁和可靠。</p>\n<h2 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>异步上下文管理器在异步编程中的使用场景包括但不限于以下几个方面：</p>\n<ol>\n<li><p>异步资源管理：当需要在异步环境中管理资源的获取和释放时，可以使用异步上下文管理器。例如，异步数据库连接池的创建和释放、异步文件操作的打开和关闭等。</p>\n</li>\n<li><p>异步上下文初始化和清理：在进入和退出特定上下文时，需要执行一些异步初始化和清理操作。例如，在异步测试中，可以使用异步上下文管理器来初始化测试环境，在测试结束时清理测试数据。</p>\n</li>\n<li><p>异步锁的使用：在多个异步任务中需要共享资源时，可以使用异步上下文管理器来管理异步锁的获取和释放。这样可以确保在任务访问共享资源时的同步性。</p>\n</li>\n<li><p>异步日志记录：在异步环境中进行日志记录时，可以使用异步上下文管理器来处理日志的初始化和清理。例如，在异步请求处理中，可以使用异步上下文管理器来设置请求的上下文信息并进行日志记录。</p>\n</li>\n</ol>\n<p>总之，异步上下文管理器可以在异步编程中提供更加灵活和可控的资源管理方式。它们可以用于各种异步任务的初始化、清理和同步操作，以及对共享资源的安全访问。具体的使用场景取决于具体的异步应用和需求。</p>\n<h1 id=\"python-协程与-nodejs-async-await-区别\"><a href=\"#python-协程与-nodejs-async-await-区别\" class=\"headerlink\" title=\"python 协程与 nodejs async await 区别\"></a>python 协程与 nodejs async await 区别</h1><p>Python 协程（Coroutine）和 Node.js 的 async&#x2F;await 在概念和使用方式上有一些区别，尽管它们都是用于异步编程。</p>\n<ol>\n<li><p>语法差异：Python 使用 <code>async</code> 和 <code>await</code> 关键字来定义和管理协程，而 Node.js 使用 <code>async</code> 和 <code>await</code> 关键字来定义和处理异步函数。在 Python 中，<code>await</code> 关键字用于挂起协程的执行，等待异步操作的完成；在 Node.js 中，<code>await</code> 关键字用于等待异步函数返回的 Promise 对象。</p>\n</li>\n<li><p>底层机制：Python 协程是基于生成器（Generator）实现的，通过生成器的迭代过程来实现协程的切换；Node.js 的 async&#x2F;await 是基于 Promise 对象的，使用 Promise 对象来管理和处理异步操作。</p>\n</li>\n<li><p>事件循环差异：Python 使用 asyncio 模块提供的事件循环来管理协程的调度和执行；Node.js 使用事件驱动的非阻塞 I&#x2F;O 模型，基于事件循环机制来处理异步任务。</p>\n</li>\n<li><p>生态系统：Python 的协程生态系统主要以 asyncio 为核心，提供了丰富的异步编程工具和库；Node.js 的异步编程生态系统非常成熟，拥有大量的库和框架，配合 async&#x2F;await 可以进行灵活的异步编程。</p>\n</li>\n</ol>\n<p>需要注意的是，Python 的协程和 Node.js 的 async&#x2F;await 在使用方式和语法上有差异，但它们的目的都是为了简化异步编程，提高代码的可读性和可维护性。具体使用哪种方式取决于所使用的编程语言和开发环境，以及特定的需求和约束条件。</p>\n<h2 id=\"nodejs-async-x2F-await-是-协程？\"><a href=\"#nodejs-async-x2F-await-是-协程？\" class=\"headerlink\" title=\"nodejs async&#x2F;await 是 协程？\"></a>nodejs async&#x2F;await 是 协程？</h2><p>在 JavaScript 中，<code>async/await</code> 机制被广泛认为是一种实现协程（Coroutine）或协作式多任务的方式，但在严格的定义上，它并不是真正的协程。</p>\n<p>协程<strong>是一种轻量级的线程</strong>，可以<strong>通过协作方式进行调度</strong>，<strong>允许在执行过程中暂停和恢复</strong>。协程通常提供更加简洁、直观和可控的异步编程模型，可以减少回调嵌套、提高代码可读性。</p>\n<p><code>async/await</code> 是 ECMAScript 2017（ES8）引入的语法糖，用于简化 Promise 的使用和异步代码的编写。通过使用 <code>async</code> 关键字定义一个异步函数，并在函数内使用 <code>await</code> 关键字等待异步操作的结果，可以实现类似于协程的效果。</p>\n<p>虽然 <code>async/await</code> 机制与协程在一些方面具有相似之处，例如可以暂停和恢复执行，但它并没有完全满足协程的定义和特性。JavaScript 中的协程概念仍然处于讨论和探索阶段，并没有官方的原生支持。</p>\n<p>因此，虽然 <code>async/await</code> 在某种程度上可以被看作是一种协程的实现方式，但在严格的定义上，它并不是真正的协程。它更适合用于简化异步代码的编写和提供更直观的异步编程模型。</p>\n<h2 id=\"nodejs-实现协程\"><a href=\"#nodejs-实现协程\" class=\"headerlink\" title=\"nodejs 实现协程\"></a>nodejs 实现协程</h2><p>在 Node.js 中，可以使用第三方库来实现协程或类似的异步编程模式。以下是一些常用的库和工具，可用于实现协程或类似的机制：</p>\n<ol>\n<li><p>co：co 是一个流程控制库，基于生成器（Generator）实现了一种协程的编程模型。它允许你使用 yield 关键字来暂停和恢复协程的执行，并使用 Promise 来处理异步操作的结果。</p>\n</li>\n<li><p>Bluebird：Bluebird 是一个功能强大的 Promise 库，在其中提供了协程（coroutine）的支持。通过使用 Bluebird 的 coroutine 方法，你可以使用 async&#x2F;await 语法编写类似于协程的代码。</p>\n</li>\n<li><p>Koa：Koa 是一个轻量级的 Node.js Web 框架，它基于 Generator 实现了一套优雅的异步编程模型。你可以使用 Koa 中间件机制来编写基于协程的异步处理代码。</p>\n</li>\n<li><p>async&#x2F;await with Promise：尽管 Node.js 并没有原生的协程支持，但你可以使用 async&#x2F;await 语法结合 Promise 来编写类似于协程的代码。将异步操作封装为 Promise，然后使用 async&#x2F;await 来等待和处理 Promise 的返回值，可以实现一种类似协程的编程模式。</p>\n</li>\n</ol>\n<p>需要注意的是，这些库和工具都是基于 JavaScript 语言特性的封装，通过利用生成器、Promise、async&#x2F;await 等功能来实现类似协程的效果。它们在不同的场景和需求下具有不同的特点和适用性。你可以根据自己的需求选择合适的库，并根据相应的文档和示例来使用。</p>\n<h1 id=\"x3D-是什么？\"><a href=\"#x3D-是什么？\" class=\"headerlink\" title=\"::&#x3D; 是什么？\"></a>::&#x3D; 是什么？</h1><p>在编程语言中，<code>::=</code> 是一种符号表示语法规则中的定义或约定关系。它通常用于上下文无关文法（Context-Free Grammar）或语法规范的描述中。</p>\n<p>具体来说，<code>::=</code> 用于指示某个符号或表达式的定义。左侧是要定义的符号或表达式，右侧是该符号或表达式的定义内容。</p>\n<p>例如，假设我们有以下的语法规则：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;expr&gt; ::&#x3D; &lt;term&gt; &#39;+&#39; &lt;expr&gt;\n         | &lt;term&gt; &#39;-&#39; &lt;expr&gt;\n         | &lt;term&gt;\n&lt;term&gt; ::&#x3D; &lt;factor&gt; &#39;*&#39; &lt;term&gt;\n         | &lt;factor&gt; &#39;&#x2F;&#39; &lt;term&gt;\n         | &lt;factor&gt;\n&lt;factor&gt; ::&#x3D; &#39;(&#39; &lt;expr&gt; &#39;)&#39;\n           | &lt;number&gt;\n&lt;number&gt; ::&#x3D; &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | ...</code></pre>\n\n<p>在这个例子中，<code>::=</code> 表示定义了一系列的语法规则。例如，<code>&lt;expr&gt;</code> 的定义是可以由 <code>&lt;term&gt; &#39;+&#39; &lt;expr&gt;</code>、<code>&lt;term&gt; &#39;-&#39; &lt;expr&gt;</code> 或者 <code>&lt;term&gt;</code> 组成的。每个规则都描述了该符号或表达式的语法结构和语义。</p>\n<p>需要注意的是，<code>::=</code> 不是编程语言的一部分，而是用于语法规范的描述符号。它在文档、教程和编程语言规范中经常被使用，用于说明语法的组成和规则。</p>\n<h1 id=\"进程通信-multiprocessing-提供了三种方式进行通信\"><a href=\"#进程通信-multiprocessing-提供了三种方式进行通信\" class=\"headerlink\" title=\"进程通信 multiprocessing 提供了三种方式进行通信\"></a>进程通信 multiprocessing 提供了三种方式进行通信</h1><p>在 Python 中，有几种常见的进程间通信的方式，包括使用队列（Queue）、管道（Pipe）、共享内存和套接字（Socket）等。这些方式可以用于不同进程之间的数据传输和通信。</p>\n<p>以下是对这些进程通信方式的简要说明：</p>\n<ol>\n<li><p>队列（Queue）：多个进程可以通过共享队列来进行通信。一个进程可以将数据放入队列，另一个进程则可以从队列中获取数据。Python 提供了 <code>multiprocessing.Queue</code> 和 <code>queue.Queue</code> 等队列类来实现进程间通信。</p>\n</li>\n<li><p>管道（Pipe）：管道是一种单向通信方式，它可以在两个进程之间传递数据。一个进程将数据发送到管道的写端，另一个进程从管道的读端获取数据。Python 的 <code>multiprocessing.Pipe</code> 类提供了进程间管道通信的功能。</p>\n</li>\n<li><p>共享内存：多个进程可以通过共享内存来直接访问相同的内存区域。这种方式可以高效地传递大量的数据，但需要注意对共享内存的同步和互斥操作。Python 中的 <code>multiprocessing.Value</code> 和 <code>multiprocessing.Array</code> 等类可用于在进程间共享数据。</p>\n</li>\n<li><p>套接字（Socket）：套接字是一种用于网络通信的机制，但也可以在同一台机器上的不同进程之间进行通信。进程可以通过套接字发送和接收数据。Python 提供了 <code>socket</code> 模块来支持进程间的套接字通信。</p>\n</li>\n</ol>\n<p>这些进程间通信方式各有特点，适用于不同的场景。你可以根据具体的需求选择合适的方式来实现进程间的数据传输和通信。</p>\n<h2 id=\"队列（Queue）示例-代码增加注释\"><a href=\"#队列（Queue）示例-代码增加注释\" class=\"headerlink\" title=\"队列（Queue）示例 代码增加注释\"></a>队列（Queue）示例 代码增加注释</h2><p>当使用队列（Queue）进行进程间通信时，一个进程可以将数据放入队列，而另一个进程可以从队列中获取数据。下面是一个使用队列的示例代码，其中添加了注释以便理解每个步骤的作用：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from multiprocessing import Process, Queue\n\ndef worker(queue):\n    # 从队列中获取数据\n    data &#x3D; queue.get()\n    print(&quot;Worker received:&quot;, data)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个队列实例\n    queue &#x3D; Queue()\n\n    # 创建一个子进程，传入队列实例作为参数\n    p &#x3D; Process(target&#x3D;worker, args&#x3D;(queue,))\n    p.start()\n\n    # 主进程向队列发送数据\n    queue.put(&quot;Hello, world!&quot;)\n\n    p.join()</code></pre>\n\n<p>在上述示例中，主进程通过 <code>queue.put()</code> 方法将数据放入队列中，而子进程通过 <code>queue.get()</code> 方法从队列中获取数据。这种方式使得进程间可以安全地传递数据，而不需要显式地进行锁定或同步操作。</p>\n<p>请注意，队列是线程安全的，可以同时在多个进程中使用，以实现进程间的通信和数据共享。在示例中，我们使用 <code>multiprocessing.Queue</code> 类来创建队列实例，该类是 Python 多进程模块中提供的一个实现。</p>\n<p>需要注意的是，队列的底层实现使用了管道和锁定等机制，以确保进程间数据的安全传输。这样，你就可以在不同的进程之间传递消息和数据，实现并发和分布式处理。</p>\n<p><strong>TODO: 不看源码，我用不起来</strong></p>\n<h2 id=\"管道（Pipe）示例-加注释\"><a href=\"#管道（Pipe）示例-加注释\" class=\"headerlink\" title=\"管道（Pipe）示例 加注释\"></a>管道（Pipe）示例 加注释</h2><p>管道（Pipe）是一种用于进程间通信的机制，可以在两个进程之间传递数据。其中一个进程将数据发送到管道的写端，而另一个进程从管道的读端获取数据。下面是一个使用管道进行进程间通信的示例代码，其中添加了注释以便理解每个步骤的作用：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from multiprocessing import Process, Pipe\n\ndef worker(conn):\n    # 从管道中接收数据\n    data &#x3D; conn.recv()\n    print(&quot;Worker received:&quot;, data)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个管道，返回两个连接对象：parent_conn 为父进程的连接，child_conn 为子进程的连接\n    parent_conn, child_conn &#x3D; Pipe()\n\n    # 创建一个子进程，传入子进程的连接对象作为参数\n    p &#x3D; Process(target&#x3D;worker, args&#x3D;(child_conn,))\n    p.start()\n\n    # 主进程向管道发送数据\n    parent_conn.send(&quot;Hello, world!&quot;)\n\n    p.join()</code></pre>\n\n<p>在上述示例中，</p>\n<ol>\n<li>主进程通过 <code>parent_conn.send()</code> 方法向管道发送数据，</li>\n<li>而子进程通过 <code>conn.recv()</code> 方法从管道中接收数据。</li>\n<li>管道允许进程间的双向通信，你可以在需要时在两个连接对象之间进行发送和接收操作。</li>\n</ol>\n<p>需要注意的是，</p>\n<ol>\n<li>管道是一种单向通信方式，即数据只能从一个方向流动。</li>\n<li>在示例中，主进程将数据发送到管道的写端（<code>parent_conn</code>），而子进程从管道的读端（<code>conn</code>）接收数据。</li>\n<li>如果需要双向通信，可以创建两个管道，一个用于父进程向子进程发送数据，另一个用于子进程向父进程发送数据。</li>\n<li>使用管道进行进程间通信可以方便地实现数据的传递和共享，无需显式地进行锁定或同步操作。</li>\n<li>在示例中，我们使用 <code>multiprocessing.Pipe</code> 类来创建管道对象，该类是 Python 多进程模块中提供的一个实现。</li>\n</ol>\n<h2 id=\"管道双向通信示例加注释\"><a href=\"#管道双向通信示例加注释\" class=\"headerlink\" title=\"管道双向通信示例加注释\"></a>管道双向通信示例加注释</h2><p>在 Python 中，管道（Pipe）提供了一种双向通信的方式，可以实现父进程和子进程之间的数据传递和交互。下面是一个使用管道进行双向通信的示例代码，其中添加了注释以便理解每个步骤的作用：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from multiprocessing import Process, Pipe\n\ndef parent(conn):\n    # 向子进程发送数据\n    conn.send(&quot;Hello from parent&quot;)\n    # 从子进程接收数据\n    data &#x3D; conn.recv()\n    print(&quot;Parent received:&quot;, data)\n\ndef child(conn):\n    # 从父进程接收数据\n    data &#x3D; conn.recv()\n    print(&quot;Child received:&quot;, data)\n    # 向父进程发送数据\n    conn.send(&quot;Hello from child&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个管道，返回两个连接对象：parent_conn为父进程的连接，child_conn为子进程的连接\n    parent_conn, child_conn &#x3D; Pipe()\n\n    # 创建父进程和子进程，分别传入连接对象作为参数\n    p1 &#x3D; Process(target&#x3D;parent, args&#x3D;(parent_conn,))\n    p2 &#x3D; Process(target&#x3D;child, args&#x3D;(child_conn,))\n\n    p1.start()\n    p2.start()\n\n    p1.join()\n    p2.join()</code></pre>\n\n<p>在上述示例中，父进程和子进程通过管道进行双向通信。父进程首先向子进程发送数据，然后等待接收子进程的回复。子进程首先接收父进程发送的数据，然后向父进程发送回复数据。</p>\n<p>通过管道进行双向通信时，父进程和子进程分别使用连接对象的 <code>send()</code> 方法发送数据，并使用 <code>recv()</code> 方法接收数据。父进程创建的连接对象 <code>parent_conn</code> 用于向子进程发送数据和接收子进程的回复，而子进程创建的连接对象 <code>child_conn</code> 则相反。</p>\n<p>双向通信使得父进程和子进程可以轻松地进行数据的交互和协作。管道提供了一种方便的机制来实现进程间的双向数据传递，无需显式地进行锁定或同步操作。</p>\n<h2 id=\"共享内存示例加注释\"><a href=\"#共享内存示例加注释\" class=\"headerlink\" title=\"共享内存示例加注释\"></a>共享内存示例加注释</h2><p>在 Python 中，共享内存是一种进程间通信的方式，它允许多个进程访问和修改相同的内存空间。下面是一个使用共享内存进行进程间通信的示例代码，其中添加了注释以便理解每个步骤的作用：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from multiprocessing import Process, Value, Array\n\ndef square(n, arr):\n    # 修改共享内存中的值\n    for i in range(len(arr)):\n        arr[i] &#x3D; arr[i] ** 2\n    # 修改共享内存中的变量\n    n.value &#x3D; n.value ** 2\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个共享内存变量\n    num &#x3D; Value(&#39;i&#39;, 5)\n    # 创建一个共享内存数组\n    nums &#x3D; Array(&#39;i&#39;, [1, 2, 3, 4, 5])\n\n    # 创建一个子进程，传入共享内存变量和共享内存数组作为参数\n    p &#x3D; Process(target&#x3D;square, args&#x3D;(num, nums))\n    p.start()\n    p.join()\n\n    # 打印共享内存变量的值\n    print(&quot;Square of num:&quot;, num.value)\n    # 打印共享内存数组的值\n    print(&quot;Square of nums:&quot;, nums[:])</code></pre>\n\n<p>在上述示例中，我们使用了 <code>multiprocessing.Value</code> 和 <code>multiprocessing.Array</code> 函数来创建共享内存变量和共享内存数组。共享内存变量用于存储一个整数值，共享内存数组用于存储一组整数。</p>\n<p>子进程通过遍历共享内存数组并计算每个元素的平方，并将结果保存回共享内存数组。同时，子进程还将共享内存变量的值平方后修改为新的值。</p>\n<p>主进程等待子进程执行完毕后，打印共享内存变量和共享内存数组的值。可以看到，共享内存中的数据可以在多个进程之间共享和修改，实现了进程间的数据共享。</p>\n<p>需要注意的是，共享内存在进程间共享数据时需要谨慎操作，需要保证对共享内存的读写操作是原子的或进行合适的同步操作，以避免出现竞态条件和数据不一致的问题。</p>\n<h2 id=\"套接字（Socket）示例注释，及原理，为什么可以实现进程通信\"><a href=\"#套接字（Socket）示例注释，及原理，为什么可以实现进程通信\" class=\"headerlink\" title=\"套接字（Socket）示例注释，及原理，为什么可以实现进程通信\"></a>套接字（Socket）示例注释，及原理，为什么可以实现进程通信</h2><p>下面是一个使用套接字（Socket）进行进程通信的示例代码，并附带了注释以解释每个步骤的作用：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\nimport os\nimport time\n\n# 创建一个套接字对象\ns &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 绑定地址和端口\ns.bind((&#39;localhost&#39;, 8888))\n\n# 监听连接\ns.listen(1)\n\nprint(&quot;Server is listening for incoming connections...&quot;)\n\ndef handle_client(client_socket):\n    # 接收客户端的数据\n    data &#x3D; client_socket.recv(1024).decode()\n    print(&quot;Received data:&quot;, data)\n\n    # 发送响应给客户端\n    response &#x3D; &quot;Hello from server!&quot;\n    client_socket.send(response.encode())\n\n    # 关闭客户端连接\n    client_socket.close()\n\nwhile True:\n    # 等待客户端连接\n    client_socket, address &#x3D; s.accept()\n    print(&quot;Connected to:&quot;, address)\n\n    # 创建一个子进程来处理客户端连接\n    pid &#x3D; os.fork()\n\n    if pid &#x3D;&#x3D; 0:\n        # 子进程处理客户端连接\n        handle_client(client_socket)\n        os._exit(0)\n    else:\n        # 父进程关闭客户端连接\n        client_socket.close()</code></pre>\n\n<p>在上述示例中，我们创建了一个服务器程序，使用套接字实现进程间通信。主要的步骤如下：</p>\n<ol>\n<li><p>创建一个套接字对象：使用 <code>socket.socket()</code> 函数创建一个套接字对象，指定地址族（AF_INET）和套接字类型（SOCK_STREAM）。</p>\n</li>\n<li><p>绑定地址和端口：使用 <code>bind()</code> 方法将套接字绑定到指定的地址和端口。</p>\n</li>\n<li><p>监听连接：使用 <code>listen()</code> 方法开始监听连接请求。</p>\n</li>\n<li><p>接受客户端连接：使用 <code>accept()</code> 方法接受客户端的连接请求，并返回一个新的套接字对象和客户端地址。</p>\n</li>\n<li><p>创建子进程处理连接：使用 <code>os.fork()</code> 创建一个子进程，并在子进程中处理客户端连接。父进程则继续监听其他连接请求。</p>\n</li>\n<li><p>子进程处理客户端连接：子进程通过套接字接收客户端发送的数据，并发送响应数据给客户端。最后关闭客户端连接。</p>\n</li>\n</ol>\n<p>通过套接字，可以实现进程间的通信。套接字提供了一种基于网络的通信机制，它允许进程在不同的主机之间进行通信。在示例中，服务器通过监听和接受客户端连接，创建子进程来处理每个连接，从而实现了多个进程之间的通信。</p>\n<p>套接字使用网络协议（如 TCP&#x2F;IP）来传输数据，并通过地址和端口来标识进程。服务器绑定一个地址和端口，监听连接请求，客户端发起连接请求后，服务器接受连接并创建一个新的套接字与客户端进行通信。这样，进程间就可以通过套接字进行数据的发送和接收，实现进程间的通信和</p>\n<h2 id=\"上述进程通信方式中，哪些可以跨机器？\"><a href=\"#上述进程通信方式中，哪些可以跨机器？\" class=\"headerlink\" title=\"上述进程通信方式中，哪些可以跨机器？\"></a>上述进程通信方式中，哪些可以跨机器？</h2><p>在上述进程通信方式中，以下两种方式可以跨机器进行通信：</p>\n<ol>\n<li><p>套接字（Socket）：使用网络套接字（例如 TCP&#x2F;IP 套接字）可以在不同的主机之间进行通信。可以通过指定远程主机的 IP 地址和端口号来连接到远程主机，并在不同的机器之间传输数据。</p>\n</li>\n<li><p>网络共享：通过网络共享可以在不同的机器之间共享文件和资源。例如，可以在一个机器上创建共享文件夹，然后通过网络访问该文件夹并在不同的机器之间传输文件。</p>\n</li>\n</ol>\n<p>需要注意的是，跨机器通信需要确保网络连接和配置正确，包括正确的 IP 地址、端口号、网络设置等。此外，还需要考虑网络安全和权限管理等方面的问题，以确保通信的安全性和可靠性。</p>\n<h2 id=\"python-进程通信-方式比较优劣\"><a href=\"#python-进程通信-方式比较优劣\" class=\"headerlink\" title=\"python 进程通信 方式比较优劣\"></a>python 进程通信 方式比较优劣</h2><p>可以简单总结如下：</p>\n<ul>\n<li>队列：简单易用，支持多进程，多线程，可以实现多进程间的数据传输，但只能用于本机进程通信。</li>\n<li>管道：相对来说比较底层，但是性能较高，支持双向通信，可以用于本机多进程通信。</li>\n<li>共享内存：性能很好，可以用于本机多进程通信，但使用起来比较麻烦，需要手动管理内存。</li>\n<li>套接字：功能最为强大，可以用于本机和网络通信，但使用起来比较复杂，需要手动编写网络协议。</li>\n</ul>\n<p><strong>详细内容</strong><br>Python 中有多种进程通信方式可供选择，每种方式都有其优劣之处。下面是几种常见的进程通信方式的比较：</p>\n<ol>\n<li><p>队列（Queue）：使用<code>multiprocessing.Queue</code>可以在多个进程之间安全地传递数据。队列提供了先进先出的数据结构，适用于生产者-消费者模型。优点是简单易用、线程安全，缺点是性能相对较低。</p>\n</li>\n<li><p>管道（Pipe）：使用<code>multiprocessing.Pipe</code>可以在两个进程之间进行双向通信。它提供了一个连接的管道，允许进程之间通过发送和接收消息进行通信。优点是快速且灵活，缺点是只适用于两个进程之间的通信。</p>\n</li>\n<li><p>共享内存（Shared Memory）：使用<code>multiprocessing.Value</code>和<code>multiprocessing.Array</code>可以在多个进程之间共享内存。共享内存允许多个进程直接访问相同的内存区域，可以高效地进行数据共享。优点是性能高、实时性好，缺点是需要处理同步和互斥问题，较容易引入 bug。</p>\n</li>\n<li><p>套接字（Socket）：使用套接字进行进程通信可以在不同的主机之间实现通信，适用于分布式系统。它允许不同主机上的进程通过网络传输数据。优点是灵活性高、可扩展性好，缺点是相对复杂，需要考虑网络配置和安全性。</p>\n</li>\n</ol>\n<p>选择合适的进程通信方式取决于具体的需求和场景。如果只需要在本地进程之间进行通信，队列和管道通常是较为简单和高效的选择。如果需要在不同主机之间进行通信，套接字可能是更合适的选择。如果需要高性能和实时性，共享内存可能是较好的选择，但需要注意同步和互斥的问题。综合考虑实际需求、性能要求和开发复杂度，选择适当的进程通信方式。</p>\n<h1 id=\"线程通信-threading-模块，提供了-5-种方式进行通信\"><a href=\"#线程通信-threading-模块，提供了-5-种方式进行通信\" class=\"headerlink\" title=\"线程通信 threading 模块，提供了 5 种方式进行通信\"></a>线程通信 threading 模块，提供了 5 种方式进行通信</h1><p>在多线程编程中，常见的多线程通信方式有以下几种：</p>\n<ol>\n<li><p><code>共享内存</code>：多个线程可以访问和修改共享的内存区域来进行数据交换。需要注意的是，由于多线程同时访问共享内存可能引发竞态条件和数据不一致的问题，因此需要使用互斥锁、条件变量等机制进行线程同步和数据保护。</p>\n</li>\n<li><p><code>队列（Queue）</code>：多个线程可以通过共享的队列来传递数据。队列提供了线程安全的数据结构，可以实现线程间的数据传输，并且内部已经实现了线程同步的机制，无需手动处理线程安全问题。</p>\n</li>\n<li><p><code>条件变量（Condition）</code>：条件变量是一种线程同步的机制，它允许线程在满足特定条件时等待，或者在条件满足时被唤醒。多个线程可以通过条件变量来进行线程间的通信和同步。</p>\n</li>\n<li><p><code>信号量（Semaphore）</code>：信号量是一种用于控制多个线程对共享资源访问的机制。它可以限制同时访问某个资源的线程数量，从而实现线程间的同步和互斥。</p>\n</li>\n<li><p><code>事件（Event）</code>：事件是一种线程间通信的机制，它允许一个线程等待其他线程发出的信号。线程可以通过事件来实现等待&#x2F;通知的机制，从而实现线程间的协调和同步。</p>\n</li>\n</ol>\n<p>需要根据具体的多线程编程场景选择合适的线程通信方式。在选择过程中，需要考虑线程安全性、性能要求、代码复杂度等因素。同时，需要注意避免竞态条件、死锁等多线程编程常见的问题。</p>\n<h2 id=\"线程共享内存通信示例\"><a href=\"#线程共享内存通信示例\" class=\"headerlink\" title=\"线程共享内存通信示例\"></a>线程共享内存通信示例</h2><p>下面是一个简单的示例，演示了多个线程之间如何共享内存：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import threading\n\n# 全局变量\nshared_variable &#x3D; 0\n\n# 互斥锁\nlock &#x3D; threading.Lock()\n\n# 线程函数\ndef increment():\n    global shared_variable\n\n    # 获取互斥锁\n    lock.acquire()\n\n    try:\n        # 修改共享变量\n        shared_variable +&#x3D; 1\n        print(f&quot;Thread &#123;threading.current_thread().name&#125;: shared_variable &#x3D; &#123;shared_variable&#125;&quot;)\n    finally:\n        # 释放互斥锁\n        lock.release()\n\n# 创建线程\nthread1 &#x3D; threading.Thread(target&#x3D;increment, name&#x3D;&quot;Thread 1&quot;)\nthread2 &#x3D; threading.Thread(target&#x3D;increment, name&#x3D;&quot;Thread 2&quot;)\n\n# 启动线程\nthread1.start()\nthread2.start()\n\n# 等待线程结束\nthread1.join()\nthread2.join()\n\n# 打印最终结果\nprint(f&quot;Final shared_variable &#x3D; &#123;shared_variable&#125;&quot;)</code></pre>\n\n<p>在上述示例中，我们定义了一个全局变量<code>shared_variable</code>，多个线程通过获取互斥锁来访问和修改这个共享变量。每个线程在执行时先获取互斥锁，然后修改共享变量的值，最后释放互斥锁。这样可以保证在任意时刻只有一个线程能够修改共享变量，从而避免了竞态条件的问题。</p>\n<p>注意，在多线程编程中，对共享内存的访问需要进行适当的同步，以保证数据的一致性和正确性。互斥锁是一种常见的同步机制，可以用于保护共享资源的访问。通过使用互斥锁，我们可以确保每个线程在修改共享变量时是原子的，避免了多个线程同时修改导致的数据不一致问题。</p>\n<h2 id=\"线程队列通信示例\"><a href=\"#线程队列通信示例\" class=\"headerlink\" title=\"线程队列通信示例\"></a>线程队列通信示例</h2><p>下面是一个简单的示例，演示了多个线程之间如何使用队列进行通信：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import threading\nimport queue\n\n# 创建队列\nmessage_queue &#x3D; queue.Queue()\n\n# 线程函数\ndef producer():\n    for i in range(5):\n        # 向队列中放入数据\n        message_queue.put(f&quot;Message &#123;i&#125;&quot;)\n        print(f&quot;Producer: Message &#123;i&#125; put into queue&quot;)\n\n    # 发送结束信号\n    message_queue.put(None)\n    print(&quot;Producer: End of messages&quot;)\n\ndef consumer():\n    while True:\n        # 从队列中获取数据\n        message &#x3D; message_queue.get()\n\n        if message is None:\n            # 接收到结束信号，退出循环\n            print(&quot;Consumer: End of messages&quot;)\n            break\n\n        # 处理数据\n        print(f&quot;Consumer: Received message - &#123;message&#125;&quot;)\n\n    # 通知队列任务完成\n    message_queue.task_done()\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\n\n# 阻塞等待队列中的任务全部处理完毕\nmessage_queue.join()\n\n# 打印最终结果\nprint(&quot;All messages processed&quot;)</code></pre>\n\n<p>在上述示例中，我们创建了一个队列<code>message_queue</code>作为线程之间的通信通道。生产者线程<code>producer</code>将一些消息放入队列中，而消费者线程<code>consumer</code>从队列中获取消息进行处理。当生产者线程放入结束信号（<code>None</code>）后，消费者线程接收到结束信号后退出循环。</p>\n<p>队列提供了线程安全的数据结构，可以在多个线程之间进行数据传递。在这个示例中，我们使用了<code>queue.Queue</code>作为队列实现，它自带了线程同步的机制，无需手动处理线程安全问题。生产者线程通过<code>put</code>方法将消息放入队列中，消费者线程通过<code>get</code>方法从队列中获取消息。当队列为空时，消费者线程会自动阻塞等待，直到队列中有新的消息可用。</p>\n<p>注意，在使用线程队列通信时，需要注意线程的启动顺序和结束条件，以确保线程能够正确地进行通信和同步。在示例中，我们使用了<code>None</code>作为结束信号，以告知消费者线程已经处理完所有消息。同时，我们还使用<code>queue.join</code>方法阻塞等待队列中的任务全部处理完毕，以确保所有消息都被消费者线程处理完毕。</p>\n<h2 id=\"线程条件变量通信示例\"><a href=\"#线程条件变量通信示例\" class=\"headerlink\" title=\"线程条件变量通信示例\"></a>线程条件变量通信示例</h2><p>下面是一个简单的示例，演示了多个线程之间如何使用条件变量进行通信：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import threading\n\n# 条件变量\ncondition &#x3D; threading.Condition()\n\n# 共享资源\nresource &#x3D; None\n\n# 线程函数\ndef producer():\n    global resource\n\n    with condition:\n        # 生产资源\n        resource &#x3D; &quot;Hello, World!&quot;\n        print(&quot;Producer: Resource produced&quot;)\n\n        # 通知等待的线程\n        condition.notify()\n\ndef consumer():\n    global resource\n\n    with condition:\n        # 等待资源生产\n        while resource is None:\n            condition.wait()\n\n        # 消费资源\n        print(f&quot;Consumer: Received resource - &#123;resource&#125;&quot;)\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\nconsumer_thread.join()\n\n# 打印最终结果\nprint(&quot;All threads completed&quot;)</code></pre>\n\n<p>在上述示例中，我们使用了条件变量<code>condition</code>来实现线程之间的通信和同步。生产者线程<code>producer</code>在生产资源后，使用<code>condition.notify()</code>通知等待的线程。消费者线程<code>consumer</code>在消费资源前，使用<code>condition.wait()</code>等待生产者线程的通知。</p>\n<p><strong>条件变量提供了一种线程间的通信方式，允许线程在某个条件满足时进行通知和等待。</strong></p>\n<p>在示例中，</p>\n<ol>\n<li>生产者线程通过修改共享变量<code>resource</code>来表示资源的生产，</li>\n<li>而消费者线程通过检查<code>resource</code>是否为空来判断是否有资源可消费。</li>\n<li>通过条件变量的等待和通知操作，生产者线程和消费者线程能够实现协同工作，确保资源的正确生产和消费。</li>\n</ol>\n<p>注意，在使用条件变量时，</p>\n<ol>\n<li>需要使用<code>with</code>语句来获取条件变量的锁，以确保线程安全。</li>\n<li>使用<code>with condition</code>可以自动获取锁并在退出<code>with</code>块时自动释放锁。</li>\n<li>这样可以确保在等待和通知操作时，只有一个线程能够访问和修改共享资源，避免竞态条件的问题。</li>\n</ol>\n<h2 id=\"线程信号量通信示例\"><a href=\"#线程信号量通信示例\" class=\"headerlink\" title=\"线程信号量通信示例\"></a>线程信号量通信示例</h2><p>下面是一个简单的示例，演示了多个线程之间如何使用信号量进行通信：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import threading\n\n# 信号量\nsemaphore &#x3D; threading.Semaphore(0)\n\n# 共享资源\nresource &#x3D; None\n\n# 线程函数\ndef producer():\n    global resource\n\n    # 生产资源\n    resource &#x3D; &quot;Hello, World!&quot;\n    print(&quot;Producer: Resource produced&quot;)\n\n    # 释放信号量\n    semaphore.release()\n\ndef consumer():\n    global resource\n\n    # 等待信号量\n    semaphore.acquire()\n\n    # 消费资源\n    print(f&quot;Consumer: Received resource - &#123;resource&#125;&quot;)\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\nconsumer_thread.join()\n\n# 打印最终结果\nprint(&quot;All threads completed&quot;)</code></pre>\n\n<p>在上述示例中，<br>我们使用了信号量<code>semaphore</code>来进行线程之间的通信。</p>\n<ol>\n<li>在生产者线程<code>producer</code>中，我们首先生产资源，然后使用<code>semaphore.release()</code>释放信号量。</li>\n<li>在消费者线程<code>consumer</code>中，我们使用<code>semaphore.acquire()</code>等待信号量被释放，然后再进行资源的消费。</li>\n</ol>\n<p>信号量提供了一种线程间的通信方式，允许控制并发访问共享资源的线程数。</p>\n<ol>\n<li>在示例中，我们通过设置信号量的初始值为 0，表示一开始资源不可用，</li>\n<li>生产者线程先生产资源后释放信号量，</li>\n<li>消费者线程再等待信号量被释放后进行资源的消费。</li>\n</ol>\n<p>注意，在使用信号量时，</p>\n<ol>\n<li>需要注意合理控制信号量的释放和等待操作，</li>\n<li>以确保线程能够正确地进行同步和通信。</li>\n<li>同时，要注意使用适当的初始值来控制线程的执行顺序和互斥访问共享资源的能力。</li>\n</ol>\n<h2 id=\"线程事件通信示例\"><a href=\"#线程事件通信示例\" class=\"headerlink\" title=\"线程事件通信示例\"></a>线程事件通信示例</h2><p>下面是一个简单的示例，演示了多个线程之间如何使用事件进行通信：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import threading\n\n# 事件\nevent &#x3D; threading.Event()\n\n# 共享资源\nresource &#x3D; None\n\n# 线程函数\ndef producer():\n    global resource\n\n    # 生产资源\n    resource &#x3D; &quot;Hello, World!&quot;\n    print(&quot;Producer: Resource produced&quot;)\n\n    # 设置事件为已触发状态\n    event.set()\n\ndef consumer():\n    global resource\n\n    # 等待事件触发\n    event.wait()\n\n    # 消费资源\n    print(f&quot;Consumer: Received resource - &#123;resource&#125;&quot;)\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\nconsumer_thread.join()\n\n# 打印最终结果\nprint(&quot;All threads completed&quot;)</code></pre>\n\n<p>在上述示例中，我们使用了事件<code>event</code>来进行线程之间的通信。在生产者线程<code>producer</code>中，我们首先生产资源，然后使用<code>event.set()</code>将事件设置为已触发状态。在消费者线程<code>consumer</code>中，我们使用<code>event.wait()</code>等待事件被触发，然后再进行资源的消费。</p>\n<p>事件提供了一种线程间的通信方式，允许一个或多个线程等待某个事件的触发。在示例中，我们首先将事件设置为未触发状态，当生产者线程生产资源后，设置事件为已触发状态，消费者线程就可以被唤醒并开始消费资源。</p>\n<p>注意，在使用事件时，要注意合理设置事件的触发和等待操作，以确保线程能够正确地进行同步和通信。同时，可以通过事件的设置和清除来控制线程的执行流程和资源的可用性。</p>\n<h1 id=\"上述线程通信与进程通信的区别\"><a href=\"#上述线程通信与进程通信的区别\" class=\"headerlink\" title=\"上述线程通信与进程通信的区别\"></a>上述线程通信与进程通信的区别</h1><p>线程通信和进程通信的区别主要体现在以下几个方面：</p>\n<ol>\n<li><p><code>范围</code>：线程通信是在同一个进程内的多个线程之间进行的，而进程通信是在不同进程之间进行的。</p>\n</li>\n<li><p><code>共享资源</code>：线程通信中的多个线程可以直接共享同一份内存空间中的数据，因此可以通过共享变量等方式进行通信。而进程通信中的多个进程之间是相互独立的，每个进程有自己独立的内存空间，无法直接共享数据。</p>\n</li>\n<li><p><code>通信机制</code>：线程通信可以使用共享变量、锁、条件变量、信号量、事件等机制进行通信和同步。进程通信则需要使用特定的通信机制，如管道、队列、共享内存、套接字等。</p>\n</li>\n<li><p><code>上下文切换开销</code>：线程通信由于线程共享内存，上下文切换开销较小，通信速度相对较快。而进程通信需要通过内核提供的通信机制进行数据传输，涉及到进程间的上下文切换，开销相对较大，通信速度较慢。</p>\n</li>\n<li><p><code>跨平台性</code>：由于线程通信是在同一个进程内进行的，所以在同一平台上的不同线程通信方式基本上是一致的。而进程通信需要跨越不同的进程，因此在不同操作系统上的进程通信方式可能有所不同。</p>\n</li>\n</ol>\n<p>综上所述，线程通信更适用于在同一个进程内的多个线程之间进行数据共享和协同工作，适合处理一些相对简单的并发任务。进程通信更适用于不同进程之间的数据交换和协作，适合处理复杂的并发任务和跨平台的场景。选择合适的通信方式需要根据具体的需求和应用场景来决定。</p>\n<h1 id=\"协程、线程、进程通信，各是为了解决什么问题？\"><a href=\"#协程、线程、进程通信，各是为了解决什么问题？\" class=\"headerlink\" title=\"协程、线程、进程通信，各是为了解决什么问题？\"></a>协程、线程、进程通信，各是为了解决什么问题？</h1><p>协程、线程和进程通信都是为了解决并发编程中的数据共享和协同工作的问题，但它们在不同的层次和场景下有不同的目的和特点。</p>\n<ul>\n<li><p><code>协程通信</code>：协程通信是在单线程内的并发编程中，通过协程之间的切换和协作来实现任务的并发执行。它的目的是充分利用单线程的资源，提高程序的执行效率。协程通信适用于需要在单线程中处理大量的任务和 I&#x2F;O 操作的情况，以提高程序的响应性和并发能力。</p>\n</li>\n<li><p><code>线程通信</code>：线程通信是在多线程编程中，通过多个线程之间的数据共享和同步来实现任务的并发执行。它的目的是通过并发执行多个线程，充分利用多核处理器的资源，提高程序的执行效率。线程通信适用于多核&#x2F;多 CPU 环境下的并发任务，可以通过共享变量、锁、条件变量、队列等机制来实现线程之间的数据交换和协同工作。</p>\n</li>\n<li><p><code>进程通信</code>：进程通信是在多进程编程中，通过多个独立的进程之间的数据传输和协作来实现任务的并发执行。它的目的是通过多个独立的进程，充分利用多个计算机节点或多个计算机上的多核处理器的资源，提高程序的执行效率和扩展性。进程通信适用于分布式系统、并行计算和跨平台通信等场景，可以通过管道、消息队列、共享内存、套接字等机制来实现进程之间的数据传输和协同工作。</p>\n</li>\n</ul>\n<p>总而言之，</p>\n<ol>\n<li>协程通信适用于单线程内的并发任务，</li>\n<li>线程通信适用于多核&#x2F;多 CPU 环境下的并发任务，</li>\n<li>进程通信适用于分布式系统和跨平台通信等场景。</li>\n<li>选择合适的通信方式需要根据具体的需求和应用场景来决定。</li>\n</ol>\n<h2 id=\"Django-微应用\"><a href=\"#Django-微应用\" class=\"headerlink\" title=\"Django 微应用\"></a>Django 微应用</h2><p>Django 是一个功能强大的 Web 框架，可以用于构建各种类型的应用程序，包括微应用。微应用是指相对较小、独立的应用程序，通常用于实现特定的功能或服务。</p>\n<p>在 Django 中，可以使用以下方式来创建和组织微应用：</p>\n<ol>\n<li><p>创建应用：使用 Django 的命令行工具创建一个新的应用，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">python manage.py startapp myapp</code></pre>\n\n<p>这将创建一个名为<code>myapp</code>的新应用。</p>\n</li>\n<li><p>定义模型：在应用的<code>models.py</code>文件中定义数据模型，描述微应用的数据结构。</p>\n</li>\n<li><p>编写视图：在应用的<code>views.py</code>文件中编写视图函数或类，处理请求并返回相应的数据或页面。</p>\n</li>\n<li><p>设计 URL 模式：在应用的<code>urls.py</code>文件中定义 URL 模式，将 URL 路径与相应的视图函数或类关联起来。</p>\n</li>\n<li><p>创建模板：在应用的<code>templates</code>目录下创建 HTML 模板文件，定义微应用的页面结构和样式。</p>\n</li>\n<li><p>配置数据库：根据需要，配置 Django 与数据库的连接，选择合适的数据库引擎。</p>\n</li>\n<li><p>迁移数据库：使用 Django 的迁移工具，将模型的变化应用到数据库中，保持数据库结构与模型定义的一致性。</p>\n</li>\n<li><p>运行应用：启动 Django 开发服务器，访问微应用的 URL 路径，查看和测试应用的功能。</p>\n</li>\n</ol>\n<p>以上步骤只是一个基本的指南，具体的微应用开发流程还取决于应用的需求和功能。在 Django 中，可以使用丰富的内置功能和第三方库来简化开发过程，如表单处理、用户认证、路由处理、数据库访问等。</p>\n<p>总之，Django 是一个非常适合构建微应用的框架，它提供了强大的工具和组件，使开发过程更加高效和简便。</p>\n<h1 id=\"集成knife4j\"><a href=\"#集成knife4j\" class=\"headerlink\" title=\"集成knife4j\"></a>集成knife4j</h1><p>要在Django项目中集成Knife4j，你可以按照以下步骤进行操作：</p>\n<ol>\n<li><p>安装<code>django-knife4j</code>库：首先，在你的Django项目的虚拟环境中运行以下命令来安装<code>django-knife4j</code>库：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip install django-knife4j</code></pre>\n</li>\n<li><p>添加<code>knife4j</code>到Django的安装应用列表：打开项目的<code>settings.py</code>文件，在<code>INSTALLED_APPS</code>配置项中添加<code>knife4j</code>应用：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">INSTALLED_APPS &#x3D; [\n    # ...\n    &#39;knife4j&#39;,\n    # ...\n]</code></pre>\n</li>\n<li><p>配置Knife4j路由：在项目的<code>urls.py</code>文件中，导入<code>knife4j</code>视图，并将Knife4j的URL配置添加到项目的URL路由中。示例如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from django.urls import include, path\nfrom knife4j.views import Knife4jSchemaView\n\nurlpatterns &#x3D; [\n    # ...\n    path(&#39;api&#x2F;doc&#x2F;&#39;, Knife4jSchemaView.as_view(url&#x3D;&#39;&#x2F;api&#x2F;schema&#x2F;swagger.json&#39;), name&#x3D;&#39;knife4j_schema&#39;),\n    path(&#39;api&#x2F;&#39;, include(&#39;your_app.urls&#39;)),  # 替换为你的应用的URL配置\n    # ...\n]</code></pre>\n<p>在上述示例中，我们将Knife4j的API文档页面配置在<code>/api/doc/</code>路径下，并将Knife4j的Schema视图链接到Swagger JSON文件的URL。</p>\n</li>\n<li><p>生成Swagger文档：在你的应用中，使用Django的内置Swagger工具（如<code>drf-yasg</code>或<code>django-rest-swagger</code>）或其他Swagger生成工具，生成Swagger JSON文件。将生成的Swagger JSON文件放置在你配置的URL路径中（在上述示例中为<code>/api/schema/swagger.json</code>）。</p>\n</li>\n<li><p>运行项目并访问Knife4j页面：运行Django项目，并在浏览器中访问你配置的Knife4j路径（例如，<code>http://localhost:8000/api/doc/</code>），你将看到Knife4j生成的API文档页面，其中包含了你的API接口信息。</p>\n</li>\n</ol>\n<p>请注意，以上步骤基于<code>django-knife4j</code>库进行集成，你也可以根据自己的需求和喜好使用其他Knife4j相关的库或工具来实现集成。确保你已经生成了符合Knife4j要求的Swagger文档，并在项目中正确配置Knife4j的路由和视图。</p>\n<p>希望以上步骤能帮助你成功集成Knife4j到你的Django项目中。</p>\n","text":"动机用不用的着我就想学，咋滴～，距去年国庆学的 Python 和 Django 有半年了，原计划五一劳动节再学一遍 Python 的，结果呢–看“仙侠剧”、搓饭、遛猫（真的是遛猫不是遛狗），五一就没了，😅 理解 python 特性Python 是一个高层次的结合了解释性、编译性、...","link":"","photos":[],"count_time":{"symbolsCount":"71k","symbolsTime":"1:04"},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%9C%BA\"><span class=\"toc-text\">动机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3-python-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">理解 python 特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96-4-%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">字符串格式化 4 种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">字符串内置函数分类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84\"><span class=\"toc-text\">元组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">元组使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">元组操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84%EF%BC%9A\"><span class=\"toc-text\">创建元组：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%85%83%E7%BB%84%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">访问元组元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%EF%BC%9A\"><span class=\"toc-text\">切片操作：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E6%8B%BC%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">元组拼接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E8%A7%A3%E5%8C%85%EF%BC%9A\"><span class=\"toc-text\">元组解包：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%BF%E5%BA%A6%E5%92%8C%E8%AE%A1%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">长度和计数：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%EF%BC%9A\"><span class=\"toc-text\">元组不可变性：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">元组内置函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#len-tuple-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%85%83%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%82\"><span class=\"toc-text\">len(tuple)：返回元组中元素的个数。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#tuple-iterable-%EF%BC%9A%E5%B0%86%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%83%E7%BB%84%E3%80%82\"><span class=\"toc-text\">tuple(iterable)：将可迭代对象转换为元组。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#count-value-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%85%83%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E3%80%82\"><span class=\"toc-text\">count(value)：返回元组中指定值的出现次数。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#index-value-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%85%83%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%80%BC%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E3%80%82\"><span class=\"toc-text\">index(value)：返回元组中指定值第一次出现的索引位置。</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E4%B8%AD%E7%9A%84%E9%A1%B9%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%EF%BC%9F\"><span class=\"toc-text\">元组中的项无法删除？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">字典</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E5%85%B8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-amp-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">字典内置函数&amp;方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#len-dict-%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%AD%97%E5%85%B8%E4%B8%AD%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F%E3%80%82\"><span class=\"toc-text\">len(dict)：返回字典中键值对的数量。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#str-dict-%EF%BC%9A%E5%B0%86%E5%AD%97%E5%85%B8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%AF%E6%89%93%E5%8D%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%E3%80%82\"><span class=\"toc-text\">str(dict)：将字典转换为可打印的字符串表示。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dict-%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AD%97%E5%85%B8%E6%88%96%E5%B0%86%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E5%85%B8%E3%80%82\"><span class=\"toc-text\">dict()：创建一个新的字典或将可迭代对象转换为字典。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#keys-%EF%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E5%AD%97%E5%85%B8%E6%89%80%E6%9C%89%E9%94%AE%E7%9A%84%E8%A7%86%E5%9B%BE%E5%AF%B9%E8%B1%A1%E3%80%82\"><span class=\"toc-text\">keys()：返回一个包含字典所有键的视图对象。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#values-%EF%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E5%AD%97%E5%85%B8%E6%89%80%E6%9C%89%E5%80%BC%E7%9A%84%E8%A7%86%E5%9B%BE%E5%AF%B9%E8%B1%A1%E3%80%82\"><span class=\"toc-text\">values()：返回一个包含字典所有值的视图对象。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#items-%EF%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E5%AD%97%E5%85%B8%E6%89%80%E6%9C%89%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E8%A7%86%E5%9B%BE%E5%AF%B9%E8%B1%A1%E3%80%82\"><span class=\"toc-text\">items()：返回一个包含字典所有键值对的视图对象。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#get-key-default-%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%82\"><span class=\"toc-text\">get(key, default)：获取指定键的值，如果键不存在，则返回默认值。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setdefault-key-default-%EF%BC%9A%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8F%92%E5%85%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%82\"><span class=\"toc-text\">setdefault(key, default)：返回指定键的值，如果键不存在，则插入指定的键值对，并返回默认值。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#clear-%EF%BC%9A%E6%B8%85%E7%A9%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E4%BD%BF%E5%AD%97%E5%85%B8%E5%8F%98%E4%B8%BA%E7%A9%BA%E5%AD%97%E5%85%B8%E3%80%82\"><span class=\"toc-text\">clear()：清空字典中的所有键值对，使字典变为空字典。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#copy-%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88shallow-copy%EF%BC%89%E3%80%82\"><span class=\"toc-text\">copy()：创建字典的浅拷贝（shallow copy）。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#update-%EF%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%94%AE%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%9B%B4%E6%96%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%E3%80%82\"><span class=\"toc-text\">update()：将一个字典的键值对添加到另一个字典中，如果键存在，则更新对应的值。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pop-key-default-%EF%BC%9A%E7%A7%BB%E9%99%A4%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E9%94%AE%E7%9A%84%E5%80%BC%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%8F%90%E4%BE%9B%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%94%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%BC%9A%E5%BC%95%E5%8F%91-KeyError%E3%80%82\"><span class=\"toc-text\">pop(key, default)：移除并返回指定键的值，如果键不存在，则返回默认值。如果不提供默认值且键不存在，则会引发 KeyError。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#popitem-%EF%BC%9A%E7%A7%BB%E9%99%A4%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E9%94%AE%E5%80%BC%E5%AF%B9%E3%80%82%E5%AD%97%E5%85%B8%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%85%B7%E4%BD%93%E7%A7%BB%E9%99%A4%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9%E3%80%82\"><span class=\"toc-text\">popitem()：移除并返回字典中的一对键值对。字典是无序的，所以不保证具体移除的是哪个键值对。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-in-dict-%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E5%AD%97%E5%85%B8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%8C%87%E5%AE%9A%E9%94%AE%E7%9A%84%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%82%E5%AE%83%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E5%80%BC%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%AE%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E-True%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-False%E3%80%82\"><span class=\"toc-text\">key in dict 是一个用于判断字典中是否存在指定键的成员运算符。它返回一个布尔值，如果字典中包含指定的键，则返回 True，否则返回 False。</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88\"><span class=\"toc-text\">集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">集合使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8E%BB%E9%87%8D%EF%BC%9A%E7%94%B1%E4%BA%8E%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E6%9D%A5%E5%BF%AB%E9%80%9F%E5%8E%BB%E9%99%A4%E5%88%97%E8%A1%A8%E6%88%96%E5%85%B6%E4%BB%96%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%82\"><span class=\"toc-text\">1. 去重：由于集合中的元素是唯一的，可以使用集合来快速去除列表或其他可迭代对象中的重复元素。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%88%90%E5%91%98%E6%A3%80%E6%9F%A5%EF%BC%9A%E9%9B%86%E5%90%88%E6%8F%90%E4%BE%9B%E4%BA%86%E9%AB%98%E6%95%88%E7%9A%84%E6%88%90%E5%91%98%E6%A3%80%E6%9F%A5%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8E%E9%9B%86%E5%90%88%E4%B8%AD%E3%80%82\"><span class=\"toc-text\">2. 成员检查：集合提供了高效的成员检查操作，可以快速判断一个元素是否存在于集合中。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%EF%BC%9A%E9%9B%86%E5%90%88%E6%94%AF%E6%8C%81%E5%B9%B6%E9%9B%86%E3%80%81%E4%BA%A4%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%AD%89%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%96%B9%E4%BE%BF%E5%9C%B0%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82\"><span class=\"toc-text\">3. 集合运算：集合支持并集、交集、差集等常见的集合运算，可以方便地进行集合间的操作。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%9A%E9%9B%86%E5%90%88%E6%94%AF%E6%8C%81%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%AD%89%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E5%9C%B0%E4%BF%AE%E6%94%B9%E9%9B%86%E5%90%88%E5%86%85%E5%AE%B9%E3%80%82\"><span class=\"toc-text\">4. 集合操作：集合支持添加元素、删除元素等操作，可以动态地修改集合内容。</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8-%E5%8F%8A-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">集合内置方法完整列表 及 示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#add-element-%E5%90%91%E9%9B%86%E5%90%88%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E3%80%82\"><span class=\"toc-text\">add(element): 向集合中添加一个元素。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#clear-%E6%B8%85%E7%A9%BA%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E3%80%82\"><span class=\"toc-text\">clear(): 清空集合中的所有元素。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#copy-%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88shallow-copy%EF%BC%89%E3%80%82\"><span class=\"toc-text\">copy(): 创建集合的浅拷贝（shallow copy）。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#difference-others-%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%AE%E9%9B%86%EF%BC%8C%E5%8D%B3%E5%9C%A8%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%86%E4%B8%8D%E5%9C%A8%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%84%E6%88%90%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82\"><span class=\"toc-text\">difference(*others): 返回当前集合与其他集合的差集，即在当前集合中但不在其他集合中的元素组成的集合。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#difference-update-others-%E7%A7%BB%E9%99%A4%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%AD%E4%B8%8E%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%8C%E5%8D%B3%E5%9C%A8%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%AD%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E4%BA%8E%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E3%80%82\"><span class=\"toc-text\">difference_update(*others): 移除当前集合中与其他集合的交集，即在当前集合中同时存在于其他集合中的元素。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#discard-element-%E7%A7%BB%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%BC%95%E5%8F%91%E9%94%99%E8%AF%AF%E3%80%82\"><span class=\"toc-text\">discard(element): 移除集合中指定的元素，如果元素不存在，不会引发错误。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#intersection-others-%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%8C%E5%8D%B3%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E4%BA%8E%E6%89%80%E6%9C%89%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%84%E6%88%90%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82\"><span class=\"toc-text\">intersection(*others): 返回当前集合与其他集合的交集，即同时存在于所有集合中的元素组成的集合。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#intersection-update-others-%E4%BF%9D%E7%95%99%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%8C%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%9C%A8%E4%BA%A4%E9%9B%86%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E3%80%82\"><span class=\"toc-text\">intersection_update(*others): 保留当前集合与其他集合的交集，移除不在交集中的元素。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#isdisjoint-other-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E6%B2%A1%E6%9C%89%E5%85%B1%E5%90%8C%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E-True%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-False%E3%80%82\"><span class=\"toc-text\">isdisjoint(other): 判断当前集合与另一个集合是否没有共同的元素，如果没有返回 True，否则返回 False。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#issubset-other-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%AD%90%E9%9B%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E8%BF%94%E5%9B%9E-True%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-False%E3%80%82\"><span class=\"toc-text\">issubset(other): 判断当前集合是否是另一个集合的子集，如果是返回 True，否则返回 False。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#issuperset-other-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E8%B6%85%E9%9B%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E8%BF%94%E5%9B%9E-True%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-False%E3%80%82\"><span class=\"toc-text\">issuperset(other): 判断当前集合是否是另一个集合的超集，如果是返回 True，否则返回 False。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pop-%E9%9A%8F%E6%9C%BA%E7%A7%BB%E9%99%A4%E5%B9%B6%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9B%86%E5%90%88%E4%B8%BA%E7%A9%BA%E4%BC%9A%E5%BC%95%E5%8F%91-KeyError-%E9%94%99%E8%AF%AF%E3%80%82\"><span class=\"toc-text\">pop(): 随机移除并返回集合中的一个元素，如果集合为空会引发 KeyError 错误。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#remove-element-%E7%A7%BB%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E4%BC%9A%E5%BC%95%E5%8F%91-KeyError-%E9%94%99%E8%AF%AF%E3%80%82\"><span class=\"toc-text\">remove(element): 移除集合中指定的元素，如果元素不存在，会引发 KeyError 错误。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#symmetric-difference-other-%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%AF%B9%E7%A7%B0%E5%B7%AE%E9%9B%86%EF%BC%8C%E5%8D%B3%E5%9C%A8%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E6%88%96%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%86%E4%B8%8D%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%84%E6%88%90%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82\"><span class=\"toc-text\">symmetric_difference(other): 返回当前集合与另一个集合的对称差集，即在当前集合或其他集合中但不同时存在的元素组成的集合。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#symmetric-difference-update-other-%E6%9B%B4%E6%96%B0%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%BA%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%AF%B9%E7%A7%B0%E5%B7%AE%E9%9B%86%E3%80%82\"><span class=\"toc-text\">symmetric_difference_update(other): 更新当前集合为当前集合与另一个集合的对称差集。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#union-others-%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86%EF%BC%8C%E5%8D%B3%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82\"><span class=\"toc-text\">union(*others): 返回当前集合与其他集合的并集，即包含所有集合中的元素的集合。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#update-others-%E5%B0%86%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%BD%93%E5%89%8D%E9%9B%86%E5%90%88%E4%B8%AD%E3%80%82\"><span class=\"toc-text\">update(*others): 将其他集合中的元素添加到当前集合中。</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">条件控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#if%E2%80%A6elif-%E2%80%A6-else\"><span class=\"toc-text\">if…elif … else</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#match%E2%80%A6case\"><span class=\"toc-text\">match…case</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8F%98%E9%87%8F%E6%A8%A1%E5%BC%8F%E3%80%81%E4%BD%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%81%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F-%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">常量模式、变量模式、位置模式、类型模式、结构模式 的示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8C%B9%E9%85%8D%E7%89%B9%E5%AE%9A%E7%9A%84%E5%B8%B8%E9%87%8F%E5%80%BC%E3%80%82\"><span class=\"toc-text\">常量模式：匹配特定的常量值。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%8C%B9%E9%85%8D%E7%9A%84%E5%80%BC%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B9%B6%E5%9C%A8%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%8F%98%E9%87%8F%E3%80%82\"><span class=\"toc-text\">变量模式：将匹配的值绑定到一个变量，并在代码块中使用该变量。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8C%B9%E9%85%8D%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%E3%80%82\"><span class=\"toc-text\">位置模式：匹配指定位置的元素。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8C%B9%E9%85%8D%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82\"><span class=\"toc-text\">类型模式：匹配特定类型的对象。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8C%B9%E9%85%8D%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%85%E9%83%A8%E5%85%83%E7%B4%A0%E3%80%82\"><span class=\"toc-text\">结构模式：匹配复杂数据结构的内部元素。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA-case-%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%9D%A1%E4%BB%B6%E4%BD%BF%E7%94%A8-%EF%BD%9C-%E9%9A%94%E5%BC%80\"><span class=\"toc-text\">一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">循环语句</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for-%E5%BE%AA%E7%8E%AF%EF%BC%9A%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%A6%82%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AD%89%EF%BC%89%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E6%88%96%E6%89%A7%E8%A1%8C%E6%8C%87%E5%AE%9A%E6%AC%A1%E6%95%B0%E7%9A%84%E5%BE%AA%E7%8E%AF%E3%80%82\"><span class=\"toc-text\">for 循环：用于遍历可迭代对象（如列表、元组、字符串等）中的元素，或执行指定次数的循环。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#range-%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88-for-%E5%BE%AA%E7%8E%AF%EF%BC%9A%E9%80%9A%E8%BF%87-range-%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8E-for-%E5%BE%AA%E7%8E%AF%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E3%80%82\"><span class=\"toc-text\">range() 函数结合 for 循环：通过 range() 函数生成一系列的数字，可以与 for 循环结合使用。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#while-%E5%BE%AA%E7%8E%AF%EF%BC%9A%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%BA%E7%9C%9F%E6%97%B6%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF%E4%BD%93%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%9D%A1%E4%BB%B6%E5%8F%98%E4%B8%BA%E5%81%87%E6%88%96%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E7%BB%88%E6%AD%A2%E8%AF%AD%E5%8F%A5%E3%80%82\"><span class=\"toc-text\">while 循环：在指定条件为真时重复执行循环体，直到条件变为假或出现循环终止语句。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E6%9D%A5%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E6%9C%89-break%EF%BC%88%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%EF%BC%89%E3%80%81continue%EF%BC%88%E7%BB%A7%E7%BB%AD%E4%B8%8B%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%EF%BC%89%E5%92%8C-pass%EF%BC%88%E5%8D%A0%E4%BD%8D%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%BB%80%E4%B9%88%E9%83%BD%E4%B8%8D%E5%81%9A%EF%BC%89%E3%80%82\"><span class=\"toc-text\">循环控制语句：可以在循环中使用控制语句来控制循环的行为。常用的控制语句有 break（跳出循环）、continue（继续下一次循环迭代）和 pass（占位语句，什么都不做）。</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#print\"><span class=\"toc-text\">print</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%A8%E5%AF%BC%E5%BC%8F-%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E8%A1%8C%E5%86%85%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">推导式 (可以理解为行内遍历)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">迭代器与生成器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82\"><span class=\"toc-text\">迭代器是一个实现了迭代器协议的对象。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%99%A8%E6%98%AF%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%E5%B9%B6%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">生成器是一种特殊的迭代器，提供了一种延迟计算的机制，可以节省内存并提高性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">函数参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%EF%BC%88Positional-Arguments%EF%BC%89%EF%BC%9A%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E6%98%AF%E6%A0%B9%E6%8D%AE%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%E7%9A%84%EF%BC%8C%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E9%9C%80%E8%A6%81%E6%8C%89%E7%85%A7%E5%AE%9A%E4%B9%89%E6%97%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E3%80%82%E7%A4%BA%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">位置参数（Positional Arguments）：位置参数是根据参数的位置进行匹配的，调用函数时需要按照定义时的顺序传递参数。示例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%EF%BC%88Keyword-Arguments%EF%BC%89%EF%BC%9A%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E6%98%AF%E6%A0%B9%E6%8D%AE%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%8D%E7%A7%B0%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BB%BB%E6%84%8F%E9%A1%BA%E5%BA%8F%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E3%80%82%E7%A4%BA%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">关键字参数（Keyword Arguments）：关键字参数是根据参数的名称进行匹配的，可以任意顺序传递参数。示例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%EF%BC%88Default-Arguments%EF%BC%89%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%98%AF%E5%9C%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%97%B6%E7%BB%99%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%8C%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9B%E8%AF%A5%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%EF%BC%8C%E5%88%99%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%82%E7%A4%BA%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">默认参数（Default Arguments）：默认参数是在函数定义时给参数设置默认值，调用函数时如果没有提供该参数的值，则使用默认值。示例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">可变长参数：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E9%95%BF%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%EF%BC%88Arbitrary-Arguments%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">可变长位置参数（Arbitrary Arguments）：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%EF%BC%88Keyword-Arguments%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">可变长关键字参数（Keyword Arguments）：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">普通函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lamada\"><span class=\"toc-text\">lamada</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8-API\"><span class=\"toc-text\">列表 API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">导入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-%E2%80%9Cimport-os%E2%80%9D-%E9%A3%8E%E6%A0%BC%E8%80%8C%E9%9D%9E-%E2%80%9Cfrom-os-import-%E2%80%9C%E3%80%82\"><span class=\"toc-text\">使用 “import os” 风格而非 “from os import *“。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E5%90%A6%E6%98%AF%E8%87%AA%E5%B7%B1%E6%89%A7%E8%A1%8C-%E6%AF%8F%E4%B8%AA%E6%A8%A1%E5%9D%97%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA-name-%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%BD%93%E5%85%B6%E5%80%BC%E6%98%AF-main-%E6%97%B6%EF%BC%8C%E8%A1%A8%E6%98%8E%E8%AF%A5%E6%A8%A1%E5%9D%97%E8%87%AA%E8%BA%AB%E5%9C%A8%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%90%A6%E5%88%99%E6%98%AF%E8%A2%AB%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">是否是自己执行 每个模块都有一个__name__属性，当其值是__main__时，表明该模块自身在运行，否则是被引入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85\"><span class=\"toc-text\">包</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#try-%E8%AF%AD%E5%8F%A5%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">try 语句全部内容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E5%BC%82%E5%B8%B8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">触发异常的几种方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E6%B8%85%E7%90%86%E8%A1%8C%E4%B8%BA-%E4%B8%8E-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E6%B8%85%E7%90%86%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">定义清理行为 与 预定义的清理行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9B%B8%E5%85%B3%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">类相关全部内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E7%B1%BB\"><span class=\"toc-text\">定义类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">创建对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99\"><span class=\"toc-text\">方法重写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">私有属性和方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Python-%E5%A4%9A%E6%80%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Python 多态示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Python-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Python 抽象类、抽象方法、接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">抽象方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">私有方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B\"><span class=\"toc-text\">单例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">命名空间和作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">命名空间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E5%BA%93\"><span class=\"toc-text\">标准库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#time-%E5%BA%93\"><span class=\"toc-text\">time 库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#time-%E5%BA%93-API-%E5%AF%B9%E5%BA%94%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">time 库 API 对应的示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#datetime-%E6%A8%A1%E5%9D%97%E6%9C%89%E5%93%AA%E4%BA%9B-API\"><span class=\"toc-text\">datetime 模块有哪些 API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#datetime-API-%E5%AF%B9%E5%BA%94%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">datetime API 对应的示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#time-%E5%BA%93%E4%B8%8E-datetime-%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">time 库与 datetime 库有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">测试性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#json-%E6%A8%A1%E5%9D%97-API-%E5%8F%8A%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">json 模块 API 及示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pip-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%8D%E6%98%AF%E6%88%91%E6%83%B3%E8%A6%81%E7%9A%84%E7%AD%94%E6%A1%88%EF%BC%89\"><span class=\"toc-text\">pip 执行过程（不是我想要的答案）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">协程通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8\"><span class=\"toc-text\">异步上下文管理器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1\"><span class=\"toc-text\">使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#python-%E5%8D%8F%E7%A8%8B%E4%B8%8E-nodejs-async-await-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">python 协程与 nodejs async await 区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-async-x2F-await-%E6%98%AF-%E5%8D%8F%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">nodejs async&#x2F;await 是 协程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">nodejs 实现协程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#x3D-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">::&#x3D; 是什么？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-multiprocessing-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程通信 multiprocessing 提供了三种方式进行通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89%E7%A4%BA%E4%BE%8B-%E4%BB%A3%E7%A0%81%E5%A2%9E%E5%8A%A0%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">队列（Queue）示例 代码增加注释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89%E7%A4%BA%E4%BE%8B-%E5%8A%A0%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">管道（Pipe）示例 加注释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E9%81%93%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B%E5%8A%A0%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">管道双向通信示例加注释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%A4%BA%E4%BE%8B%E5%8A%A0%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">共享内存示例加注释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88Socket%EF%BC%89%E7%A4%BA%E4%BE%8B%E6%B3%A8%E9%87%8A%EF%BC%8C%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">套接字（Socket）示例注释，及原理，为什么可以实现进程通信</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E8%B7%A8%E6%9C%BA%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">上述进程通信方式中，哪些可以跨机器？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#python-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83%E4%BC%98%E5%8A%A3\"><span class=\"toc-text\">python 进程通信 方式比较优劣</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-threading-%E6%A8%A1%E5%9D%97%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%BA%86-5-%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">线程通信 threading 模块，提供了 5 种方式进行通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">线程共享内存通信示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">线程队列通信示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">线程条件变量通信示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">线程信号量通信示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">线程事件通信示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E8%BF%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">上述线程通信与进程通信的区别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%90%84%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">协程、线程、进程通信，各是为了解决什么问题？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Django-%E5%BE%AE%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">Django 微应用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E6%88%90knife4j\"><span class=\"toc-text\">集成knife4j</span></a>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"nodejs进程线程通信","uid":"1c1176847881d39523eab2c0cd2228ab","slug":"2023-05-08进程线程","date":"2023-05-08T02:42:06.000Z","updated":"2023-05-15T13:17:33.006Z","comments":true,"path":"api/articles/2023-05-08进程线程.json","keywords":null,"cover":null,"text":"问题 进程间通信与线程间通信的区别 ? 进程通信有哪些方式 ? 线程通信有哪些方式 ? kafaka 不属于进程通信 ? Electron 为什么使用线程通信 ? HTTP 可以替代 RPC ? 为什么出现 RPC ? 多进程，多线程，与同步是否冲突 ? Nodejs 进程之间如...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/categories/nodejs.json"}],"tags":[{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"简单了解Jest","uid":"d38ec567dd1420f161a414e047d4332c","slug":"2023-05-05jest","date":"2023-05-05T06:25:39.000Z","updated":"2023-05-15T13:17:33.003Z","comments":true,"path":"api/articles/2023-05-05jest.json","keywords":null,"cover":[],"text":"toBeFalsy 是什么意思toBeFalsy 是 Jest 和 Jasmine 中的一个匹配器（Matcher），用于判断一个值是否为假值。如果一个值可以被强制转换为 false，则该值被视为假值。 例如，以下值被视为假值： false 0 -0 0n (BigInt 0) ...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"Jest","slug":"Jest","count":1,"path":"api/categories/Jest.json"}],"tags":[{"name":"Jest","slug":"Jest","count":1,"path":"api/tags/Jest.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}