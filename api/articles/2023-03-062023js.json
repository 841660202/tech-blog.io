{"title":"2023前端面试真题之JS篇","uid":"0e8399ece48a5643474d22f61ba561e0","slug":"2023-03-062023js","date":"2023-03-06T01:49:01.000Z","updated":"2023-03-13T13:39:28.229Z","comments":true,"path":"api/articles/2023-03-062023js.json","keywords":null,"cover":[],"content":"<h2 id=\"JS-执行流程\"><a href=\"#JS-执行流程\" class=\"headerlink\" title=\"JS 执行流程\"></a>JS 执行流程</h2><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f8e16b3a2a4b7fb8d19e079d0d1b4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" style=\"width:500px;max-width:100%\" />\n\n<h2 id=\"准备工作-需要准备执行-JS-时所需要的一些基础环境\"><a href=\"#准备工作-需要准备执行-JS-时所需要的一些基础环境\" class=\"headerlink\" title=\"准备工作: 需要准备执行 JS 时所需要的一些基础环境\"></a>准备工作: 需要准备执行 JS 时所需要的一些基础环境</h2><ol>\n<li>初始化了<code>内存</code>中的<code>堆和栈</code>结构</li>\n<li><code>JS 全局执行上下文</code>: 包含了执行过程中的全局信息， 比如一些<code>内置函数</code>，<code>全局变量</code>等信息</li>\n<li><code>全局作用域</code>:包含了一些全局变量， 在执行过程中的数据都需要存放在内存中</li>\n<li>初始化<code>消息循环系统</code>: 消息驱动器, 消息队列</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c01653f6db554fb9a4f8337911f4875a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" style=\"width:500px;max-width:100%\" />\n\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d1bd569b8449f8917cf49cee35555d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" style=\"width:500px;max-width:100%\" />\n\n<ol>\n<li><code>V8</code> 接收到要执行的 JS 源代码 源代码对 V8 来说只是一堆字符串，V8 并不能直接理解这段字符串的含义</li>\n<li><code>V8</code> 结构化这段字符串,生成了<code>&#123;抽象语法树|AST&#125;</code>,同时<code>还会生成相关的作用域</code></li>\n<li><code>生成字节码</code>（介于 AST 和机器代码的中间代码）, 与特定类型的机器代码无关</li>\n<li><code>解释器(ignition)</code>，按照顺序解释执行字节码，并输出执行结果。</li>\n<li>从图中得出一个结论：<code>执行 JS 代码核心流程</code><ol>\n<li>先编译</li>\n<li>后执行</li>\n</ol>\n</li>\n</ol>\n<p>通过 V8 将 js 转换为字节码然后经过解释器执行输出结果的方式执行 JS，<code>有一个弊端就是</code>，</p>\n<p>如果在浏览器中再次打开相同的页面，当页面中的 JavaScript 文件没有被修改，再次编译之后的二进制代码也会保持不变，意味着编译这一步浪费了 CPU 资源。</p>\n<p>为了，更好的利用 CPU 资源，V8 采用<code>JIT（Just In Time）</code>技术提升效率: 而是<code>混合编译执行</code>和<code>解释执行</code>这两种手段。</p>\n<ol>\n<li><code>解释执行</code>的启动速度快，但是执行时的速度慢</li>\n<li><code>编译执行</code>的启动速度慢，但是执行时的速度快</li>\n</ol>\n<h3 id=\"Just-in-time-编译器：综合了解释器和编译器的优点\"><a href=\"#Just-in-time-编译器：综合了解释器和编译器的优点\" class=\"headerlink\" title=\"Just-in-time 编译器：综合了解释器和编译器的优点\"></a>Just-in-time 编译器：综合了解释器和编译器的优点</h3><p>为了解决解释器的低效问题，后来的浏览器把编译器也引入进来，形成混合模式。<br>在 JavaScript 引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息。</p>\n<p>如果同一行代码运行了几次，这个代码段就被标记成了 warm，如果运行了很多次，则被标记成 hot</p>\n<h2 id=\"es6-新特性\"><a href=\"#es6-新特性\" class=\"headerlink\" title=\"es6 新特性\"></a>es6 新特性</h2><p><strong>易用性</strong></p>\n<ol>\n<li>声明：const 和 let</li>\n<li>解构赋值</li>\n<li>模板字符串</li>\n<li>函数的扩展<ol>\n<li>函数的默认值</li>\n<li>rest 参数</li>\n<li>函头函数</li>\n</ol>\n</li>\n<li>数组的扩展<ol>\n<li>Array.from()将类数组转为数组</li>\n<li>find()、findIndex()找出第一个符合条件的成员&#x2F;下标</li>\n<li>entries()、keys()、values() 用于遍历数组。（配合 for…of)</li>\n<li>includes() 是否存在指定无素(返回布尔值)</li>\n</ol>\n</li>\n<li>对象的扩展<ol>\n<li>属性名可使用表达式</li>\n<li>Object.assign()</li>\n<li>Object.keys(), Object.values(), Object.entries()</li>\n</ol>\n</li>\n<li>Symbol、Set、Map、WeakSet、WeakMap</li>\n<li>Promise</li>\n<li>Iterator 和 for…of<ol>\n<li>为各种数据提供统一的，简便的访问接口</li>\n</ol>\n</li>\n<li>Generator 与 async await</li>\n</ol>\n<h2 id=\"Promise-VS-async-x2F-await\"><a href=\"#Promise-VS-async-x2F-await\" class=\"headerlink\" title=\"Promise VS async&#x2F;await\"></a>Promise VS async&#x2F;await</h2><p>动机，原理，相比较</p>\n<h3 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h3><p>Promise 对象就是为了解决回调地狱而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。</p>\n<p>分析 Promise 的调用流程：</p>\n<ol>\n<li>Promise 的构造方法接收一个 executor()，在 new Promise()时就立刻执行这个 executor 回调</li>\n<li>executor()内部的异步任务被放入宏&#x2F;微任务队列，等待执行</li>\n<li>then()被执行，收集成功&#x2F;失败回调，放入成功&#x2F;失败队列</li>\n<li>executor() 的异步任务被执行，触发 resolve&#x2F;reject，从成功&#x2F;失败队列中取出回调依次执行</li>\n</ol>\n<p><strong>其实熟悉设计模式，很容易就能意识到这是个观察者模式，这种方式，被广泛运用于观察者模式的实现，</strong></p>\n<ol>\n<li>收集依赖</li>\n<li>触发通知</li>\n<li>取出依赖执行</li>\n</ol>\n<p>在 Promise 里，执行顺序是</p>\n<ol>\n<li>then 收集依赖</li>\n<li>异步触发 resolve</li>\n<li>resolve 执行依赖。</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/7194257890893365308\" target=\"_blank\" >5K 字 由浅入深聊聊 Promise 实现原理</a></p>\n<details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7194257890893365308\n\nconst PENDING &#x3D; &quot;pending&quot;;\nconst FULFILLED &#x3D; &quot;fulfilled&quot;;\nconst REJECTED &#x3D; &quot;rejected&quot;;\n\nclass CustomPromise &#123;\n  status &#x3D; PENDING;\n  &#x2F;&#x2F; 成功之后的值\n  value &#x3D; undefined;\n  &#x2F;&#x2F; 失败之后的值\n  reason &#x3D; undefined;\n\n  &#x2F;&#x2F; 存储成功回调函数\n  onResolvedCallbacks &#x3D; [];\n  &#x2F;&#x2F; 存储失败回调函数\n  onFulfilledCallbacks &#x3D; [];\n\n  constructor(executor) &#123;\n    executor(this.resolve, this.reject);\n  &#125;\n  &#x2F;&#x2F; resolve和reject为什么要用箭头函数？\n  &#x2F;&#x2F; 如果直接调用的话，普通函数this指向的是window或者undefined\n  &#x2F;&#x2F; 用箭头函数就可以让this指向当前实例对象\n  resolve &#x3D; (value) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; promise只能从pending到rejected, 或者从pending到fulfilled\n    if (this.status &#x3D;&#x3D; PENDING) &#123;\n      this.status &#x3D; FULFILLED;\n      this.value &#x3D; value;\n      &#x2F;&#x2F; REVIEW:\n      &#x2F;&#x2F; resolve里面将所有成功的回调拿出来执行\n      console.log(&quot;this.onResolvedCallbacks.length&quot;, this.onResolvedCallbacks.length);\n      if (this.onResolvedCallbacks.length) &#123;\n        this.onResolvedCallbacks.forEach((fn) &#x3D;&gt; &#123;\n          fn();\n        &#125;);\n      &#125;\n    &#125;\n  &#125;;\n  reject &#x3D; (err) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; promise只能从pending到rejected, 或者从pending到fulfilled\n    if (this.status &#x3D;&#x3D; PENDING) &#123;\n      this.status &#x3D; REJECTED;\n      this.reason &#x3D; err;\n      &#x2F;&#x2F; reject里面将所有失败的回调拿出来执行\n      &#x2F;&#x2F; REVIEW:\n      console.log(&quot;this.onFulfilledCallbacks.length&quot;, this.onFulfilledCallbacks.length);\n      if (this.onFulfilledCallbacks.length) &#123;\n        this.onFulfilledCallbacks.forEach((fn) &#x3D;&gt; &#123;\n          fn();\n        &#125;);\n      &#125;\n    &#125;\n  &#125;;\n\n  then(onFulfilled, onRejected) &#123;\n    &#x2F;&#x2F; 如果不传，就使用默认函数,确保是函数类型\n    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onFulfilled : (value) &#x3D;&gt; value;\n    &#x2F;&#x2F; prettier-ignore\n    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onRejected : (reason) &#x3D;&gt; &#123;throw reason;&#125;;\n\n    &#x2F;&#x2F; 因为是链式调用，所以需要返回一个promise\n    const thenCustomPromise &#x3D; new CustomPromise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 将逻辑抽取为一个函数,用于执行.then中的方法，并返回\n      const resolveCustomPromise &#x3D; (callBack, value) &#x3D;&gt; &#123;\n        console.log(callBack);\n        try &#123;\n          &#x2F;&#x2F; TODO: 这里立即成执行callBack（ onFulfilled&#x2F;onRejected）的结果\n          const res &#x3D; callBack(value);\n          &#x2F;&#x2F; 如果相等了，说明return的是自己，抛出类型错误并返回\n          if (resolveCustomPromise &#x3D;&#x3D;&#x3D; res) &#123;\n            return reject(new TypeError(&quot;类型错误&quot;));\n          &#125;\n          &#x2F;&#x2F; REVIEW: 这里是假设，then这个东西可能是一个promise&#x2F;也可能是非promise\n\n          &#x2F;&#x2F; 判断x是不是 CustomPromise 实例对象\n          if (res instanceof CustomPromise) &#123;\n            &#x2F;&#x2F; 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\n            &#x2F;&#x2F; x.then(value &#x3D;&gt; resolve(value), error &#x3D;&gt; reject(reason))\n            &#x2F;&#x2F; 简化之后\n            res.then(resolve, reject);\n          &#125; else &#123;\n            &#x2F;&#x2F; 普通值\n            resolve(res);\n          &#125;\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 需要判断状态，根据状态选择处理回调函数\n      if (this.status &#x3D;&#x3D; FULFILLED) &#123;\n        resolveCustomPromise(onFulfilled, this.value);\n      &#125; else if (this.status &#x3D;&#x3D; REJECTED) &#123;\n        resolveCustomPromise(onRejected, this.reason);\n      &#125; else if (this.status &#x3D;&#x3D; PENDING) &#123;\n        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行\n\n        &#x2F;&#x2F; REVIEW: 什么时候会出现多个的情况，好像没有吧？\n\n        &#x2F;&#x2F; 哦哦哦～，这是把所有的then的回调，先都给收集了进来？\n        &#x2F;&#x2F; 1.问：为什么说是“先”？ 因为上边的status为pending状态的时候，.then的回调是没有被处理的，收集起来，之后进行处理\n        &#x2F;&#x2F; 2.问：之后怎么处理？ 因为这里被转授权的地方是个promise，那么就等它有权的时候往下执行，往下执行分为resolve和reject\n        &#x2F;&#x2F; 所以这些回调会放到实例对应的resolve和reject进行遍历处理\n        this.onResolvedCallbacks.push(() &#x3D;&gt; resolveCustomPromise(onFulfilled, this.value));\n        this.onFulfilledCallbacks.push(() &#x3D;&gt; resolveCustomPromise(onRejected, this.reason));\n      &#125;\n    &#125;);\n    return thenCustomPromise;\n  &#125;\n  catch(onFulfilled) &#123;\n    return this.then(null, onFulfilled);\n  &#125;\n  &#x2F;&#x2F; 1. 返回一个新的promise\n  &#x2F;&#x2F; 2. 不影响之前返回的promise对象\n  &#x2F;&#x2F; 3. finally为什么不返回数据，没有意义，finally返回一个promise，之后还可能继续进行其他操作，所以这时候返回数据是没有意义的\n  &#x2F;&#x2F; Promise.resolve(1)\n  &#x2F;&#x2F; .finally(()&#x3D;&gt;&#123;console.log(&#39;f1&#39;)&#125;)\n  &#x2F;&#x2F; .then(res&#x3D;&gt;&#123;console.log(res)&#125;)\n  &#x2F;&#x2F; .finally(()&#x3D;&gt;&#123;console.log(&#39;f2&#39;)&#125;)\n  &#x2F;&#x2F; 结果打印：\n  &#x2F;&#x2F; f1\n  &#x2F;&#x2F; 1\n  &#x2F;&#x2F; f2\n\n  &#x2F;&#x2F; MDN: 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况\n\n  &#x2F;&#x2F; Promise.resolve(&#39;1&#39;).finally(res&#x3D;&gt;&#123;\n  &#x2F;&#x2F;   console.log(&#39;finaly&#39;, res)\n  &#x2F;&#x2F; &#125;).then(res&#x3D;&gt; &#123;console.log(&#39;then&#39;,res)&#125;)\n  &#x2F;&#x2F; finaly undefined\n  &#x2F;&#x2F; then 1\n  finally(callBack) &#123;\n    return this.then(\n      (value) &#x3D;&gt; &#123;\n        CustomPromise.resolve(callBack(&#x2F;*这里没有数据 *&#x2F;)).then(() &#x3D;&gt; value);\n      &#125;,\n      (reason) &#x3D;&gt; &#123;\n        CustomPromise.reject(callBack(&#x2F;*这里没有数据 *&#x2F;)).then(() &#x3D;&gt; reason);\n      &#125;\n    );\n  &#125;\n\n  &#x2F;&#x2F; Promise.resolve\n  &#x2F;&#x2F; 1. 如果参数是 Promise 的实例，原封不动的返回\n  &#x2F;&#x2F; 2. 如果参数是 then()方法的对象，会将这个对象转化为promise对象，然后立即执行 thenable 对象的 then 方法\n  &#x2F;&#x2F; 3. 如果是原始值，或者是不具有 then()方法的对象，返回一个新的 promise ,状态为 resolved\n  &#x2F;&#x2F; 4. 允许不带参数，直接返回一个 resolved 状态的 Promise对象\n  static resolve(value) &#123;\n    if (value instanceof CustomPromise) return value;\n    return new CustomPromise((resolve) &#x3D;&gt; resolve(value));\n  &#125;\n  &#x2F;&#x2F; 返回一个Promise实例，并且携带reason\n  static reject(reason) &#123;\n    return new CustomPromise((_, reject) &#x3D;&gt; reject(reason));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 测试数据\nconst promise &#x3D; new CustomPromise((resolve, reject) &#x3D;&gt; &#123;\n  resolve(&quot;start&quot;);\n&#125;);\n\npromise\n  .then((res) &#x3D;&gt; &#123;\n    console.log(&quot;第1个&quot;, res);\n    return new CustomPromise((resolve, reject) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        resolve(&quot;hellow&quot;);\n      &#125;, 1000);\n    &#125;);\n  &#125;)\n  .then(\n    (res) &#x3D;&gt; &#123;\n      console.log(&quot;第2个&quot;, res);\n      return &quot;promise&quot;;\n    &#125;,\n    (err) &#x3D;&gt; &#123;\n      console.log(&quot;err&quot;, err);\n    &#125;\n  )\n  .then((res) &#x3D;&gt; &#123;\n    console.log(&quot;第3个&quot;, res);\n  &#125;);\n&#x2F;&#x2F; 尾部有个then，只不过这个是个空的\n&#x2F;&#x2F; 输出结果 start-&gt;hellow-&gt;promise</code></pre>\n\n</p>\n</details>\n<h3 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async await\"></a>async await</h3><p>async&#x2F;await 实际上是对 Generator（生成器）的封装，是一个语法糖。</p>\n<p><code>*/yield</code> 和 <code>async/await</code> 看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p>\n<ol>\n<li>async&#x2F;await 自带执行器，不需要手动调用 next()就能自动执行下一步</li>\n<li>async 函数返回值是 Promise 对象，而 Generator 返回的是生成器对象</li>\n<li>await 能够返回 Promise 的 resolve&#x2F;reject 的值</li>\n<li>不管 await 后面跟着的是什么，await 都会阻塞后面的代码</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/7195358576364224568\" target=\"_blank\" >仅“2k”字就能理解的 async&#x2F;await 原理</a></p>\n<details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><img src=\"http://t-blog-images.aijs.top/img/202303061037367.webp\" />;</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，\n&#x2F;&#x2F; 它返回一个 Generator 对象\n&#x2F;&#x2F; generator对象由生成器函数生成\n\n&#x2F;&#x2F;接受一个Generator函数作为参数\nfunction myAsync(gen) &#123;\n  &#x2F;&#x2F; 返回一个函数\n  return function () &#123;\n    &#x2F;&#x2F; 返回一个promise\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 执行Generator函数\n      &#x2F;&#x2F; generator返回什么\n      let g &#x3D; gen();\n\n      const next &#x3D; (context) &#x3D;&gt; &#123;\n        let res;\n        try &#123;\n          res &#x3D; g.next(context);\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n        if (res.done) &#123;\n          &#x2F;&#x2F; 这时候说明已经是完成了，需要返回结果\n          resolve(res.value);\n        &#125; else &#123;\n          &#x2F;&#x2F; 继续执行next函数,传入执行结果\n          return Promise.resolve(res.value).then(\n            (val) &#x3D;&gt; next(val),\n            (err) &#x3D;&gt; next(err)\n          );\n        &#125;\n      &#125;;\n      next();\n    &#125;);\n  &#125;;\n&#125;\n&#x2F;&#x2F; prettier-ignore\nconst getFetch &#x3D; (nums) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(nums + 1);\n  &#125;, 1000);\n&#125;);\n\nfunction* gen() &#123;\n  let res1 &#x3D; yield getFetch(1);\n  let res2 &#x3D; yield getFetch(res1);\n  let res3 &#x3D; yield getFetch(res2);\n  return res3;\n&#125;\n\nconst asyncGen &#x3D; myAsync(gen &#x2F;*传入generator *&#x2F;);\n\nasyncGen().then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;); &#x2F;&#x2F; 4</code></pre>\n\n</p>\n</details>\n<h3 id=\"两者的区别\"><a href=\"#两者的区别\" class=\"headerlink\" title=\"两者的区别\"></a>两者的区别</h3><p><strong>动机</strong></p>\n<ol>\n<li>Promise 的出现<ol>\n<li>解决了传统 callback 函数导致的地域回调问题，</li>\n<li>但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。</li>\n</ol>\n</li>\n<li>而 async await<ol>\n<li>代码看起来会简洁些，使得异步代码看起来像同步代码，</li>\n<li><code>await</code> 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li>\n</ol>\n</li>\n</ol>\n<p><strong>功能</strong></p>\n<ol>\n<li>async&#x2F;await 与 Promise 一样，是非阻塞的。</li>\n<li>async&#x2F;await 是基于 Promise 实现的，可以说是改良版的 Promise</li>\n</ol>\n<h2 id=\"ES6-迭代器\"><a href=\"#ES6-迭代器\" class=\"headerlink\" title=\"ES6 迭代器\"></a>ES6 迭代器</h2><ol>\n<li><code>可迭代协议</code>： 实现 Iterable 接口（可迭代协议）要求同时具备两种能力<ol>\n<li><code>支持迭代的自我识别能力</code></li>\n<li>创建实现 Iterator 接口的对象的能力</li>\n</ol>\n</li>\n<li>这意味着必须暴露一个属性作为默认迭代器,</li>\n<li>这个属性必须使用特殊的 <code>Symbol.iterator</code> 作为键,</li>\n<li>这个默认迭代器属性必须引用一个迭代器工厂函数。</li>\n<li>调用这个工厂函数必须返回一个新迭代器</li>\n</ol>\n<h3 id=\"内置类型都实现了-Iterable-接口\"><a href=\"#内置类型都实现了-Iterable-接口\" class=\"headerlink\" title=\"内置类型都实现了 Iterable 接口\"></a>内置类型都实现了 Iterable 接口</h3><ol>\n<li>字符串、数组</li>\n<li>Map、Set</li>\n<li>arguments 对象、NodeList 等 DOM 集合类型</li>\n</ol>\n<h3 id=\"迭代器协议-MDN\"><a href=\"#迭代器协议-MDN\" class=\"headerlink\" title=\"迭代器协议 MDN\"></a>迭代器协议 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\" target=\"_blank\" >MDN</a></h3><ol>\n<li><p>迭代器 API</p>\n<ol>\n<li>使用 next()方法在可迭代对象中遍历数据,</li>\n<li>每次成功调用 next(),都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。</li>\n</ol>\n</li>\n<li><p>next()方法返回的迭代器对象 IteratorResult 包含两个属性</p>\n<ol>\n<li><code>done</code>： 一个布尔值，表示是否还可以再次调用 next()取得下一个值</li>\n<li><code>value</code>：包含可迭代对象的下一个值</li>\n</ol>\n</li>\n</ol>\n<p><code>每个迭代器都表示对可迭代对象的一次性有序遍历</code></p>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><p><a href=\"https://juejin.cn/post/7202904269535887418#heading-26\" target=\"_blank\" >设计模式的分类</a></p>\n<p>总体来说设计模式分为三大类：(<code>C5S7B11</code>)</p>\n<ol>\n<li><code>创建型模式</code>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>\n<li><code>结构型模式</code>，共七种：适配器模式、装饰器模式、<code>代理模式</code>、桥接模式、组合模式、享元模式、外观模式。</li>\n<li><code>行为型模式</code>，共十一种：<code>策略模式</code>、<code>模板方法模式</code>、<code>观察者模式/发布订阅模式</code>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>\n</ol>\n<h3 id=\"单例模式（4-中实现）\"><a href=\"#单例模式（4-中实现）\" class=\"headerlink\" title=\"单例模式（4 中实现）\"></a>单例模式（4 中实现）</h3><h4 id=\"1-闭包实现-变量参数\"><a href=\"#1-闭包实现-变量参数\" class=\"headerlink\" title=\"1. 闭包实现-变量参数\"></a>1. 闭包实现-变量参数</h4><details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 闭包实现\nlet CreateSingleton &#x3D; (function () &#123;\n  let instance;\n  return function (name) &#123;\n    if (instance) return instance;\n    this.name &#x3D; name;\n    &#x2F;&#x2F;  return (instance &#x3D; this); &#x2F;&#x2F; 这个地方不是很好理解,改写为下面两行\n    instance &#x3D; this;\n    return instance;\n  &#125;;\n&#125;)();\n\nCreateSingleton.prototype.getName &#x3D; function () &#123;\n  console.log(this.name);\n&#125;;\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 测试\nlet Winner &#x3D; new CreateSingleton(&quot;Winner&quot;);\nlet Looser &#x3D; new CreateSingleton(&quot;Looser&quot;);\n\nconsole.log(Winner &#x3D;&#x3D;&#x3D; Looser); &#x2F;&#x2F; true\nconsole.log(Winner.getName()); &#x2F;&#x2F; &#39;Winner&#39;\nconsole.log(Looser.getName()); &#x2F;&#x2F; &#39;Winner&#39;</code></pre>\n\n</p>\n</details>\n<h4 id=\"2-闭包实现-函数参数\"><a href=\"#2-闭包实现-函数参数\" class=\"headerlink\" title=\"2. 闭包实现-函数参数\"></a>2. 闭包实现-函数参数</h4><p><a href=\"/#/post/2022-10-27设计模式\" target=\"_blank\" >2022-10-27 设计模式 – 单例模式</a></p>\n<h4 id=\"3-类构造函数实现\"><a href=\"#3-类构造函数实现\" class=\"headerlink\" title=\"3. 类构造函数实现\"></a>3. 类构造函数实现</h4><p><a href=\"/#/post/2022-10-27设计模式\" target=\"_blank\" >2022-10-27 设计模式 – 单例模式</a></p>\n<h4 id=\"4-类静态方法实现\"><a href=\"#4-类静态方法实现\" class=\"headerlink\" title=\"4. 类静态方法实现\"></a>4. 类静态方法实现</h4><p><a href=\"/#/post/2022-10-27设计模式\" target=\"_blank\" >2022-10-27 设计模式 – 单例模式</a></p>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p><a href=\"https://juejin.cn/post/6844904134840156168\" target=\"_blank\" >观察者模式（JavaScript 实现）</a></p>\n<details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 定义observe\nconst queuedObservers &#x3D; new Set();\nconst observe &#x3D; (fn) &#x3D;&gt; queuedObservers.add(fn);\n&#x2F;&#x2F; prettier-ignore\nconst observable &#x3D; (obj) &#x3D;&gt; new Proxy(obj, &#123;\n    set(target, key, value, receiver) &#123;\n      const result &#x3D; Reflect.set(target, key, value, receiver);\n      &#x2F;&#x2F; notify\n      queuedObservers.forEach((observer) &#x3D;&gt; observer());\n      return result;\n    &#125;,\n  &#125;);\n\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试\n\nobj &#x3D; observable(&#123;\n  name: &quot;789&quot;,\n&#125;);\n\nobserve(function test() &#123;\n  console.log(&quot;触发了&quot;);\n&#125;);\n\nobj.name &#x3D; &quot;前端柒八九&quot;;\n&#x2F;&#x2F; 触发了\n&#x2F;&#x2F; 前端柒八九</code></pre>\n\n</p>\n</details>\n<h3 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h3><p><a href=\"/#/post/2022-07-04js\" target=\"_blank\" >见：2022-07-04js</a></p>\n<details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 监听收集（on&#x2F;once）\n&#x2F;&#x2F; 2. 触发监听(emit)\n&#x2F;&#x2F; 3. 解除监听(off)\n&#x2F;&#x2F; 4. 清空监听(clear)\nclass EventBus &#123;\n  constructor() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n  &#x2F;&#x2F; 监听，给对象添加方法\n  on(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) &#123;\n      events[name] &#x3D; [];\n    &#125;\n    events[name].push(callback);\n  &#125;\n  &#x2F;&#x2F; 取出来执行\n  emit(name, ...args) &#123;\n    const handlers &#x3D; this.events[name];\n    handlers &amp;&amp;\n      handlers.forEach((fn) &#x3D;&gt; &#123;\n        fn.apply(this, args);\n      &#125;);\n  &#125;\n  &#x2F;&#x2F; 解除\n  off(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) return;\n    events[name] &#x3D; events[name].filter((fn) &#x3D;&gt; fn !&#x3D;&#x3D; callback); &#x2F;&#x2F; 引用，指向对象，直接改kv键值对\n  &#125;\n  &#x2F;&#x2F;  用完立马、解除\n  once(name, callback) &#123;\n    const handler &#x3D; function () &#123;\n      callback.apply(this, arguments); &#x2F;&#x2F; 普通函数参数\n      this.off(name, handler);\n    &#125;;\n    this.on(name, handler);\n  &#125;\n  &#x2F;&#x2F; 事件清空\n  clear() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n&#125;</code></pre>\n\n</p>\n</details>\n<h3 id=\"观察者-vs-发布订阅\"><a href=\"#观察者-vs-发布订阅\" class=\"headerlink\" title=\"观察者 vs 发布订阅\"></a>观察者 vs 发布订阅</h3><ol>\n<li>从表面上看<ol>\n<li>观察者模式里，<code>只有两个角色 —— 观察者 + 被观察者</code></li>\n<li>而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的—— {经纪人|Broker}</li>\n</ol>\n</li>\n<li>往更深层次讲<ol>\n<li>观察者和被观察者，<code>是松耦合的关系</code></li>\n<li>发布者和订阅者，则<code>完全不存在耦合</code></li>\n</ol>\n</li>\n<li>使用上<ol>\n<li>观察者模式，多用于单个应用内部</li>\n<li>发布订阅模式，则更多的是一种{跨应用的模式|cross-application pattern} ，比如我们常用的消息中间件</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"WebGL-和-canvas-的关系\"><a href=\"#WebGL-和-canvas-的关系\" class=\"headerlink\" title=\"WebGL 和 canvas 的关系\"></a>WebGL 和 canvas 的关系</h2><ol>\n<li><code>Canvas 就是画布</code>，只要浏览器支持，可以在 canvas 上获取 2D 上下文和 3D 上下文，其中 3D 上下文一般就是 WebGL，当然 WebGL 也能用于 2D 绘制，并且 WebGL 提供硬件渲染加速，性能更好。</li>\n<li><code>WEBGL 的支持性</code> caniuse 还不是特别好，所以在不支持 WebGL 的情况下，只能使用 Canvas 2D api，注意这里的降级不是降到 Canvas，它只是一个画布元素，而是降级使用 浏览器提供的 Canvas 2D Api，这就是很多库的兜底策略，如 Three.js, PIXI 等</li>\n</ol>\n<h2 id=\"声明变量的方式（2-4-）\"><a href=\"#声明变量的方式（2-4-）\" class=\"headerlink\" title=\"声明变量的方式（2 + 4 ）\"></a>声明变量的方式（2 + 4 ）</h2><ol>\n<li>ES5<ol>\n<li>var 命令</li>\n<li>function 命令</li>\n</ol>\n</li>\n<li>ES6<ol>\n<li>let</li>\n<li>const</li>\n<li>import</li>\n<li>class</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"CommonJS-和-ES6-Module-的区别\"><a href=\"#CommonJS-和-ES6-Module-的区别\" class=\"headerlink\" title=\"CommonJS 和 ES6 Module 的区别\"></a>CommonJS 和 ES6 Module 的区别</h2><ol>\n<li>CommonJS 是同步加载模块，ES6 是异步加载模块<br>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<br>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。<br>浏览器加载 ES6 模块是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本</li>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。<br>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值<br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>\n</ol>\n<h2 id=\"ADM-vs-CMD-vs-ES6-Module\"><a href=\"#ADM-vs-CMD-vs-ES6-Module\" class=\"headerlink\" title=\"ADM vs CMD vs ES6 Module\"></a>ADM vs CMD vs ES6 Module</h2><h2 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h2><p>利用 JavaScript 实现懒加载的 3 种方式,原理:</p>\n<p>判断图片是否出现在可视区后给图片赋值 src 属性。利用 HTML 提供的 data- 属性来嵌入自定义数据,自定义数据存放这个标签原本的图片地址。</p>\n<h3 id=\"利用-offsetTop-计算位置\"><a href=\"#利用-offsetTop-计算位置\" class=\"headerlink\" title=\"利用 offsetTop 计算位置\"></a>利用 offsetTop 计算位置</h3><ol>\n<li>用 JavaScript 实现当滚动滚动条时，如果图片出现在可视区，那么加载图片。</li>\n<li>加载图片其实就是给 img 标签 src 属性赋值为本来的地址，那么此时图片便会请求加载渲染出来</li>\n</ol>\n<details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;获取全部img标签\nvar images &#x3D; document.getElementsByTagName(&quot;img&quot;);\n\nwindow.addEventListener(&quot;scroll&quot;, (e) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;当发生滚动事件时调用loadPic事件\n  loadPic();\n&#125;);\n\nfunction loadPic() &#123;\n  &#x2F;&#x2F; 遍历每一张图\n  for (let i of images) &#123;\n    &#x2F;&#x2F;判断当前图片是否在可视区内\n    if (i.offsetTop &lt;&#x3D; window.innerHeight + window.scrollY) &#123;\n      &#x2F;&#x2F;获取自定义data-src属性的值\n      let trueSrc &#x3D; i.getAttribute(&quot;data-src&quot;);\n      &#x2F;&#x2F;把值赋值给图片的src属性\n      i.setAttribute(&quot;src&quot;, trueSrc);\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F;没发生滚动事件时也要先执行一次\nloadPic();\n\n&#x2F;&#x2F; offsetTop 为元素距离顶部的距离；\n&#x2F;&#x2F; window.innerHeight 为当前窗口的高度；\n&#x2F;&#x2F; window.scrollY 为滚动距离\n&#x2F;&#x2F; 当 i.offsetTop &lt;&#x3D; window.innerHeight + window.scrollY时图片就处于窗口可视区了</code></pre>\n\n</p>\n</details>\n<h3 id=\"利用-getBoundingClientRect-top-计算位置\"><a href=\"#利用-getBoundingClientRect-top-计算位置\" class=\"headerlink\" title=\"利用 getBoundingClientRect().top 计算位置\"></a>利用 getBoundingClientRect().top 计算位置</h3><details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var images &#x3D; document.getElementsByTagName(&quot;img&quot;);\n\nwindow.addEventListener(&quot;scroll&quot;, (e) &#x3D;&gt; &#123;\n  loadPic();\n&#125;);\n\nfunction loadPic() &#123;\n  for (let i of images) &#123;\n    &#x2F;&#x2F;计算方式和第一种方式不同\n    if (i.getBoundingClientRect().top &lt; window.innerHeight) &#123;\n      let trueSrc &#x3D; i.getAttribute(&quot;data-src&quot;);\n      i.setAttribute(&quot;src&quot;, trueSrc);\n    &#125;\n  &#125;\n&#125;\n\nloadPic();\n\n&#x2F;&#x2F; getBoundingClientRect().top 为元素相对于窗口的位置；\n&#x2F;&#x2F; window.innerHeight 为当前窗口的高度；\n&#x2F;&#x2F; 当元素对于窗口的位置小于当前窗口的高度时，那自然处于了窗口可视区了</code></pre>\n\n</p>\n</details>\n<h3 id=\"Intersection-Observer\"><a href=\"#Intersection-Observer\" class=\"headerlink\" title=\"Intersection Observer\"></a>Intersection Observer</h3><p><code>Intersection Observer</code> 构造函数的作用是<code>它能够观察可视窗口与目标元素产生的交叉区域</code>。<br>简单来说就是当用它观察我们的图片时，当图片出现或者消失在可视窗口，它都能知道并且会执行一个特殊的回调函数，我们就利用这个回调函数实现我们的操作</p>\n<details class=\"custom-details\">\n<summary>实现原理源代码</summary>\n<p><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var images &#x3D; document.getElementsByTagName(&quot;img&quot;);\nfunction callback(entries) &#123;\n  for (let i of entries) &#123;\n    if (i.isIntersecting) &#123;\n      let img &#x3D; i.target;\n      let trueSrc &#x3D; img.getAttribute(&quot;data-src&quot;);\n      img.setAttribute(&quot;src&quot;, trueSrc);\n      observer.unobserve(img);\n    &#125;\n  &#125;\n&#125;\n\nconst observer &#x3D; new IntersectionObserver(callback);\n\nfor (let i of images) &#123;\n  observer.observe(i);\n&#125;</code></pre>\n\n</p>\n</details>\n<h2 id=\"PromiseQueue\"><a href=\"#PromiseQueue\" class=\"headerlink\" title=\"PromiseQueue\"></a>PromiseQueue</h2><h3 id=\"tasks-是-promise-数组\"><a href=\"#tasks-是-promise-数组\" class=\"headerlink\" title=\"tasks 是 promise 数组\"></a>tasks 是 promise 数组</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 入队列\n&#x2F;&#x2F; 出队列\nclass PromiseQueue &#123;\n  constructor(tasks, limit &#x3D; 1) &#123;\n    this.tasks &#x3D; tasks;\n    this.limit &#x3D; limit;\n    this.running &#x3D; [];\n  &#125;\n  next() &#123;\n    return this.running.length &lt; this.limit &amp;&amp; this.tasks.length;\n  &#125;\n\n  run() &#123;\n    while (this.next()) &#123;\n      let promise &#x3D; this.tasks.shift(); &#x2F;&#x2F; 更改tasks数组长度\n\n      promise.then((data) &#x3D;&gt; &#123;\n        this.run();\n      &#125;);\n\n      this.running.push(promise); &#x2F;&#x2F; 更改running数组长度\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 接收一个promise数组，并发限制为3\nconst taskQueue &#x3D; new PromiseQueue(tasks, 3);\ntaskQueue.run();\n\n&#x2F;&#x2F; 清理\n&#x2F;&#x2F; taskQueue &#x3D; undefined</code></pre>\n\n<h3 id=\"task-不是默认-promise-数组\"><a href=\"#task-不是默认-promise-数组\" class=\"headerlink\" title=\"task 不是默认 promise 数组\"></a>task 不是默认 promise 数组</h3><p><a href=\"/#/post/2022-07-04js\" target=\"_blank\" >&#x2F;#&#x2F;post&#x2F;2022-07-04js LimitPromise</a></p>\n<h2 id=\"ES5、ES6-继承\"><a href=\"#ES5、ES6-继承\" class=\"headerlink\" title=\"ES5、ES6 继承\"></a>ES5、ES6 继承</h2><h3 id=\"帮助理解的文章\"><a href=\"#帮助理解的文章\" class=\"headerlink\" title=\"帮助理解的文章\"></a>帮助理解的文章</h3><p><a href=\"https://blog.csdn.net/X1432564581/article/details/107170368/\" target=\"_blank\" >JS 继承：原型继承、构造函数继承、组合继承与最佳的继承</a></p>\n<h3 id=\"ES5\"><a href=\"#ES5\" class=\"headerlink\" title=\"ES5\"></a>ES5</h3><h3 id=\"原型继承-直接式\"><a href=\"#原型继承-直接式\" class=\"headerlink\" title=\"原型继承(直接式)\"></a>原型继承(直接式)</h3><p>原型继承，顾名思义就是通过原型链来让子类继承父类的属性以及函数</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 将父类实例，赋值给子类的原型对象(prototype)\nSubClass.prototype &#x3D; new SuperClass();\n&#x2F;&#x2F; 修正因为重写子类原型， 导致子类的 constructor 属性被修改\nSubClass.prototype.constructor &#x3D; SubClass;</code></pre>\n\n<p><strong>缺点</strong></p>\n<ol>\n<li>易污染：父类中<code>引用类型的属性</code>，被子类实例公用</li>\n<li>无法传参：创建父类的时候，无法向父类传递参数</li>\n</ol>\n<h3 id=\"构造函数继承（借助-call）\"><a href=\"#构造函数继承（借助-call）\" class=\"headerlink\" title=\"构造函数继承（借助 call）\"></a>构造函数继承（借助 call）</h3><p><strong>创建即继承</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function SubClass(params) &#123;\n  SuperClass.call(this, params);\n&#125;</code></pre>\n\n<p><strong>缺点</strong> 不能继承原型属性或者方法</p>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>原型继承 + 构造函数继承</p>\n<p>组合继承其实就是将我们前面提到的原型继承与构造函数继承给结合了起来，这样能够同时解决原型继承与构造函数继承的缺点</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function SubClass(name) &#123;\n  &#x2F;&#x2F; 构造函数式继承父类name属性\n  SuperClass.call(this, name);\n&#125;\n&#x2F;&#x2F; 原型链继承 子类原型继承父类实例\nSubClass.prototype &#x3D; new SuperClass();\n&#x2F;&#x2F; 修正因为重写子类原型导致子类的constructor属性被修改\nSubClass.prototype.constructor &#x3D; SubClass;</code></pre>\n\n<p><strong>缺点</strong> 父类构造函数被调用两次</p>\n<h3 id=\"原型式继承-过渡式\"><a href=\"#原型式继承-过渡式\" class=\"headerlink\" title=\"原型式继承(过渡式)\"></a>原型式继承(过渡式)</h3><p>对原型链继承的封装，过渡对象相对于原型继承的子类</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function inheritObject(o) &#123;\n  &#x2F;&#x2F;声明一个过渡函数对象\n  function F() &#123;&#125;\n  &#x2F;&#x2F;过渡函数的原型继承父对象\n  F.prototype &#x3D; o;\n  &#x2F;&#x2F; 返回一个实例，该实例的原型继承了父对象\n  return new F();\n&#125;</code></pre>\n\n<p><strong>缺点</strong></p>\n<ol>\n<li>父类中<code>引用类型的属性</code>，被子类实例公用</li>\n<li><code>ECMAScript 5</code> 通过增加 <code>Object.create()</code>方法将原型式继承的概念规范化</li>\n</ol>\n<h3 id=\"寄生式继承-过渡方式\"><a href=\"#寄生式继承-过渡方式\" class=\"headerlink\" title=\"寄生式继承(过渡方式)\"></a>寄生式继承(过渡方式)</h3><p>对原型式继承的二次封装,在二次封装中对继承的对象进行拓展。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function createObject(obj) &#123;\n  &#x2F;&#x2F;通过原型式继承创建新对象\n  var o &#x3D; Object.create(obj);\n  &#x2F;&#x2F;拓展新对象\n  o.name &#x3D; &#96;北宸南蓁&#96;;\n  &#x2F;&#x2F;返回拓展后的对象\n  return o;\n&#125;</code></pre>\n\n<p><strong>缺点:</strong> 父类中引用类型的属性，被子类实例公用</p>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><p>所谓寄生组合继承，</p>\n<pre><code> 1. 即` 通过借用构造函数来继承属性`\n 2. 通过 `原型链的混成形式来继承方法`\n</code></pre>\n<p>其背后的思路就是：</p>\n<pre><code>1. 不必为了指定子类型的原型而调用超类型构造函数，我们所需要的无非就是超类型原型的一个副本而已。\n2. 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型\n</code></pre>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function inheritPrototype(subClass, superClass) &#123;\n  &#x2F;&#x2F;复制一份父类的原型副本, 并赋值给子类原型\n  subClass.prototype &#x3D; Object.create(superClass.prototype);\n  &#x2F;&#x2F; 修正因为重写子类原型, 导致子类的constructor属性被修改\n  subClass.prototype.constructor &#x3D; subClass;\n&#125;\n\nfunction subClass() &#123;\n  superClass.call(this);\n&#125;</code></pre>\n\n<p>ES6 的 extends 关键字 也采用这种方式</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><table>\n<thead>\n<tr>\n<th align=\"left\">分类</th>\n<th align=\"left\">动机</th>\n<th align=\"left\">缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">原型继承</td>\n<td align=\"left\">实现继承</td>\n<td align=\"left\">1. constructor 指向错误 2. 父类属性共享，会造成污染，3. 无法向父类构造函数传参</td>\n</tr>\n<tr>\n<td align=\"left\">构造函数继承</td>\n<td align=\"left\">解决污染问题</td>\n<td align=\"left\">父类中<code>引用类型的属性</code>，被子类实例公用，父类原型上的函数没有继承</td>\n</tr>\n<tr>\n<td align=\"left\">组合继承</td>\n<td align=\"left\">同时解决原型继承与构造函数继承的缺点</td>\n<td align=\"left\">父类构造函数被调用两次（一次是在创建子类型原型的时候，另一次是在子类型构造函数的内部）</td>\n</tr>\n<tr>\n<td align=\"left\">过渡原型继承</td>\n<td align=\"left\">对原型继承的封装</td>\n<td align=\"left\">避免因为修改子类的构造函数后还需要修正的现象</td>\n</tr>\n<tr>\n<td align=\"left\">过渡寄生式继承</td>\n<td align=\"left\">对原型式继承的二次封装</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">寄生组合式继承</td>\n<td align=\"left\">解决组合继承父类构造函数被调用两次的问题</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"寄生式继承为什么不会污染父类原型\"><a href=\"#寄生式继承为什么不会污染父类原型\" class=\"headerlink\" title=\"寄生式继承为什么不会污染父类原型\"></a>寄生式继承为什么不会污染父类原型</h3><p>没有实例化父类，对中间构造函数进行实例化（一个临时副本实现了相同的原型链继承）</p>\n<h3 id=\"ES6-继承\"><a href=\"#ES6-继承\" class=\"headerlink\" title=\"ES6 继承\"></a>ES6 继承</h3><p><strong>原理：ES6 类 + 寄生式组合继承</strong></p>\n<p><strong>es5 和 es6 的继承有什么区别</strong></p>\n<p><strong>本质上区别</strong></p>\n<ol>\n<li>ES5 的继承实质: <strong>是先创建子类的实例对象，然后再将父类的方法添加到 this 上（superClass.call(this)）</strong></li>\n<li>ES6 的继承实质: <strong>是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this</strong></li>\n</ol>\n<p><strong>实现上有区别</strong></p>\n<ol>\n<li>ES5 的继承时通过原型或构造函数机制来实现。</li>\n<li>ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。</li>\n</ol>\n<p><strong>使用上有区别</strong></p>\n<ol>\n<li><strong>子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。</strong></li>\n<li><strong>因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</strong></li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://blog.csdn.net/yingleiming/article/details/105688630\" target=\"_blank\" >继承方式六：寄生组合式继承</a></li>\n<li><a href=\"https://blog.csdn.net/X1432564581/article/details/107170368/\" target=\"_blank\" >JS 继承：原型继承、构造函数继承、组合继承与最佳的继承</a></li>\n<li><a href=\"https://juejin.cn/post/7206912311562174523#heading-28\" target=\"_blank\" >22023 面试真题之手写&amp;代码运行篇</a></li>\n</ol>\n","text":"JS 执行流程 准备工作: 需要准备执行 JS 时所需要的一些基础环境 初始化了内存中的堆和栈结构 JS 全局执行上下文: 包含了执行过程中的全局信息， 比如一些内置函数，全局变量等信息 全局作用域:包含了一些全局变量， 在执行过程中的数据都需要存放在内存中 初始化消息循环系统:...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"前端面试","slug":"前端面试","count":1,"path":"api/categories/前端面试.json"}],"tags":[{"name":"前端面试","slug":"前端面试","count":1,"path":"api/tags/前端面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JS-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">JS 执行流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E6%89%A7%E8%A1%8C-JS-%E6%97%B6%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">准备工作: 需要准备执行 JS 时所需要的一些基础环境</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">执行流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Just-in-time-%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9A%E7%BB%BC%E5%90%88%E4%BA%86%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">Just-in-time 编译器：综合了解释器和编译器的优点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">es6 新特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise-VS-async-x2F-await\"><span class=\"toc-text\">Promise VS async&#x2F;await</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#promise\"><span class=\"toc-text\">promise</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-await\"><span class=\"toc-text\">async await</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">两者的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">ES6 迭代器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E5%AE%9E%E7%8E%B0%E4%BA%86-Iterable-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">内置类型都实现了 Iterable 接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE-MDN\"><span class=\"toc-text\">迭代器协议 MDN</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%884-%E4%B8%AD%E5%AE%9E%E7%8E%B0%EF%BC%89\"><span class=\"toc-text\">单例模式（4 中实现）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0-%E5%8F%98%E9%87%8F%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">1. 闭包实现-变量参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2. 闭包实现-函数参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3. 类构造函数实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%B1%BB%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4. 类静态方法实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">观察者模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">发布订阅模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85-vs-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85\"><span class=\"toc-text\">观察者 vs 发布订阅</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WebGL-%E5%92%8C-canvas-%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">WebGL 和 canvas 的关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%882-4-%EF%BC%89\"><span class=\"toc-text\">声明变量的方式（2 + 4 ）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CommonJS-%E5%92%8C-ES6-Module-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">CommonJS 和 ES6 Module 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ADM-vs-CMD-vs-ES6-Module\"><span class=\"toc-text\">ADM vs CMD vs ES6 Module</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">图片懒加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8-offsetTop-%E8%AE%A1%E7%AE%97%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">利用 offsetTop 计算位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8-getBoundingClientRect-top-%E8%AE%A1%E7%AE%97%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">利用 getBoundingClientRect().top 计算位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Intersection-Observer\"><span class=\"toc-text\">Intersection Observer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PromiseQueue\"><span class=\"toc-text\">PromiseQueue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#tasks-%E6%98%AF-promise-%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">tasks 是 promise 数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#task-%E4%B8%8D%E6%98%AF%E9%BB%98%E8%AE%A4-promise-%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">task 不是默认 promise 数组</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES5%E3%80%81ES6-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">ES5、ES6 继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%AE%E5%8A%A9%E7%90%86%E8%A7%A3%E7%9A%84%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">帮助理解的文章</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES5\"><span class=\"toc-text\">ES5</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF-%E7%9B%B4%E6%8E%A5%E5%BC%8F\"><span class=\"toc-text\">原型继承(直接式)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%EF%BC%88%E5%80%9F%E5%8A%A9-call%EF%BC%89\"><span class=\"toc-text\">构造函数继承（借助 call）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">组合继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF-%E8%BF%87%E6%B8%A1%E5%BC%8F\"><span class=\"toc-text\">原型式继承(过渡式)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF-%E8%BF%87%E6%B8%A1%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">寄生式继承(过渡方式)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">寄生组合式继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E6%B1%A1%E6%9F%93%E7%88%B6%E7%B1%BB%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">寄生式继承为什么不会污染父类原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">ES6 继承</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"“位运算符”的使用场景","uid":"321b3776a189b2e51803e56cf34e14e0","slug":"2023-03-07按位操作","date":"2023-03-07T08:42:34.000Z","updated":"2023-03-13T13:39:28.230Z","comments":true,"path":"api/articles/2023-03-07按位操作.json","keywords":null,"cover":null,"text":"按位与 &amp;特点 奇数&amp;1 恒等于 1 偶数&amp;1 恒等于 0 动态规划使用场景&#x2F;&#x2F; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。 &#x2F;&#x2F; 你有多少种不同的方法可以爬到楼顶呢？ 注意：...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"Requestly 实操记录","uid":"749dde28f9332fb853106b061b92f347","slug":"2023-03-02requestly","date":"2023-03-02T02:23:04.000Z","updated":"2023-03-07T14:09:36.379Z","comments":true,"path":"api/articles/2023-03-02requestly.json","keywords":null,"cover":[],"text":"Modify API Response改变接口请求返回的结果 注意：请求正常发送，正常返回(可以在 chrome 的 network 窗口查看)，在返回给 js 的时候，会被插件处理，所以看上去有点摸不着头脑 操作介绍 查看 chrome Requestly 窗口请求记录 启用&...","link":"","photos":[],"count_time":{"symbolsCount":277,"symbolsTime":"1 mins."},"categories":[{"name":"浏览器插件","slug":"浏览器插件","count":1,"path":"api/categories/浏览器插件.json"}],"tags":[{"name":"浏览器插件","slug":"浏览器插件","count":1,"path":"api/tags/浏览器插件.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}