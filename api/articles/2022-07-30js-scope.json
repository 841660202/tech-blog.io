{"title":"前端基础-js 作用域","uid":"991fb01358aaac1abfe173de529db251","slug":"2022-07-30js-scope","date":"2022-07-30T15:52:03.000Z","updated":"2022-10-17T11:18:29.856Z","comments":true,"path":"api/articles/2022-07-30js-scope.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/作用域.png","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>var let const 区别：</p>\n<ol>\n<li>版本： var 是 es6 之前， const、let es6 之后，</li>\n<li>分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域</li>\n<li>提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使用会报错</li>\n<li>重复：var 可以重复声明、重复赋值，let 不可以重复声明，单可重复赋值，const 不可重复声明和赋值</li>\n<li>存储：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li>\n<li>默认： 默认情况下是 var 声明</li>\n<li>函数：函数声明提升优先于 var</li>\n</ol>\n<p>作用域：</p>\n<ol>\n<li>什么是执行上下文？</li>\n<li>什么是词法环境？</li>\n<li>什么是作用域？</li>\n<li>什么是作用域链？</li>\n</ol>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><img src=\"http://t-blog-images.aijs.top/img/作用域.png\" style=\"max-width: 100%; width: 600px\" />\n\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p><strong>MDN:</strong></p>\n<p><span style=\"color: red\">在当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。</span> 如果一个<strong>变量或者其他表达式</strong>,不 “在当前的作用域中”，那么它就是不可用的。</p>\n<p>作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。</p>\n<p>作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在函数之外声明的变量，叫做<code>全局变量</code>，因为它可被当前文档中的任何其他代码所访问。<br>在函数内部声明的变量，叫做<code>局部变量</code>，因为它只能在当前函数的内部访问。<br>ECMAScript 6 之前的 JavaScript 没有 <code>语句块作用域</code>；<br>es6 之后，<code>语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量</code>。</p></blockquote>\n<p>例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  var x &#x3D; 5;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 5</code></pre>\n\n<p>使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  let y &#x3D; 5;\n&#125;\nconsole.log(y); &#x2F;&#x2F; ReferenceError: y 没有被声明</code></pre>\n\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>JavaScript 在执⾏过程中, 会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了<code>作⽤域链</code>。</p>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p><code>块语句</code>（或其他语言的<code>复合语句</code>）用于组合零个或多个语句。该块由一对大括号界定，可以是 labelled</p>\n<p>其他语言中通常将语句块称为<code>复合语句</code>。它允许你使用多个语句，其中 JavaScript 只需要一个语句。将语句组合成块是 JavaScript 中的常见做法。相反的做法是可以使用一个<code>空语句(即 ;)</code>，你不提供任何语句，虽然一个是必需的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>1.通过 var 声明的变量或者非严格模式下 (non-strict mode) 创建的函数声明没有块级作用域</li>\n<li>2.使用 let 和 const 声明的变量是有块级作用域的</li>\n<li>3.使用 let 声明的变量, 在块级作用域内, 能强制执行更新变量</li>\n<li>4.使用 function 函数声明同样被限制在声明他的语句块内：</li>\n</ul></blockquote>\n<p><strong>1. 通过 var 声明的变量或者非严格模式下 (non-strict mode) 创建的函数声明没有块级作用域。</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var x &#x3D; 1;\n&#123;\n  var x &#x3D; 2;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 输出 2\n\n&#x2F;&#x2F; 输出结果是 2，因为块中的 var x语句与块前面的var x语句作用域相同。在 C 或 Java 中，这段代码会输出 1。</code></pre>\n\n<p><strong>2. 使用 let 和 const 声明的变量是有块级作用域的。</strong></p>\n<p>事例 1</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let x &#x3D; 1;\n&#123;\n  let x &#x3D; 2;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 输出 1\n&#x2F;&#x2F; x &#x3D; 2仅限在定义它的块中</code></pre>\n\n<p>事例 2</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const c &#x3D; 1;\n&#123;\n  const c &#x3D; 2;\n&#125;\nconsole.log(c); &#x2F;&#x2F; 输出 1，而且不会报错\n\n&#x2F;&#x2F; 位于块范围之内的 const c &#x3D; 2 并不会抛出SyntaxError: Identifier &#39;c&#39; has already been declared这样的语法错误，因为在它自己的块中它可能是唯一一个被声明的常量。</code></pre>\n\n<p><strong>3. 使用 let 声明的变量, 在块级作用域内, 能强制执行更新变量</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; [];\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  a[i] &#x3D; function () &#123;\n    console.log(i);\n  &#125;;\n&#125;\na[0](); &#x2F;&#x2F; 10\na[1](); &#x2F;&#x2F; 10\na[6](); &#x2F;&#x2F; 10\n\n&#x2F;********************&#x2F;\n\nvar a &#x3D; [];\nfor (let i &#x3D; 0; i &lt; 10; i++) &#123;\n  a[i] &#x3D; function () &#123;\n    console.log(i);\n  &#125;;\n&#125;\na[0](); &#x2F;&#x2F; 0\na[1](); &#x2F;&#x2F; 1\na[6](); &#x2F;&#x2F; 6</code></pre>\n\n<p><strong>4. 使用 function 函数声明同样被限制在声明他的语句块内：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">foo(&quot;outside&quot;); &#x2F;&#x2F; TypeError: foo is not a function\n&#123;\n  function foo(location) &#123;\n    console.log(&quot;foo is called &quot; + location);\n  &#125;\n  foo(&quot;inside&quot;); &#x2F;&#x2F; 正常工作并且打印 &#39;foo is called inside&#39;\n&#125;</code></pre>\n\n<h2 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h2><p>JavaScript 有三种声明方式。</p>\n<ul>\n<li>var 声明一个变量，可选初始化一个值。</li>\n<li>let 声明一个块作用域的局部变量，可选初始化一个值。</li>\n<li>const 声明一个块作用域的只读常量。</li>\n</ul>\n<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><p>变量提升: <strong>可以先使用变量稍后再声明变量而不会引发异常</strong></p>\n<p>JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。</p>\n<p>但是，<code>提升后的变量将返回 undefined 值</code>。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 例子 1\n *&#x2F;\nconsole.log(x &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; true\nvar x &#x3D; 3;\n\n&#x2F;**\n * 例子 2\n *&#x2F;\n&#x2F;&#x2F; will return a value of undefined\nvar myvar &#x3D; &quot;my value&quot;;\n\n(function () &#123;\n  console.log(myvar); &#x2F;&#x2F; undefined\n  var myvar &#x3D; &quot;local value&quot;;\n&#125;)();</code></pre>\n\n<p>上面的例子，也可写作：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 例子 1\n *&#x2F;\nvar x;\nconsole.log(x &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; true\nx &#x3D; 3;\n\n&#x2F;**\n * 例子 2\n *&#x2F;\nvar myvar &#x3D; &quot;my value&quot;;\n\n(function () &#123;\n  var myvar;\n  console.log(myvar); &#x2F;&#x2F; undefined\n  myvar &#x3D; &quot;local value&quot;;\n&#125;)();</code></pre>\n\n<p>由于存在变量提升，一个函数中所有的 var 语句应尽可能地放在接近函数顶部的地方。这个习惯将大大提升代码的清晰度。</p>\n<p>在 ECMAScript 6 中，<strong>let 和 const 同样会被提升变量到代码块的顶部</strong>, <strong>但是不会被赋予初始值</strong>。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types#:~:text=%E5%9C%A8%20ECMAScript%206%20%E4%B8%AD%EF%BC%8Clet%E5%92%8Cconst%E5%90%8C%E6%A0%B7%E4%BC%9A%E8%A2%AB%E6%8F%90%E5%8D%87%E5%8F%98%E9%87%8F%E5%88%B0%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E9%A1%B6%E9%83%A8%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E8%A2%AB%E8%B5%8B%E4%BA%88%E5%88%9D%E5%A7%8B%E5%80%BC%E3%80%82%E5%9C%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B9%8B%E5%89%8D%E5%BC%95%E7%94%A8%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B0%86%E6%8A%9B%E5%87%BA%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF%EF%BC%88ReferenceError%EF%BC%89%E3%80%82%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%B0%86%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E5%A4%84%E5%9C%A8%E4%B8%80%E4%B8%AA%E2%80%9C%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E2%80%9D%EF%BC%8C%E7%9B%B4%E5%88%B0%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E6%AD%A2\" target=\"_blank\" >原文</a></p>\n<p><code>暂时性死区</code>：程序未执行到声明处时,访问该变量都会报引用错误</p>\n<p>这个不是太好理解啊：<strong>let const 变量会提升，但是不会进行变量声明，如果在声明之前引用，将抛出错误;</strong></p>\n<h2 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h2><p>对于函数来说，<strong>只有函数声明会被提升到顶部，而函数表达式不会被提升</strong>。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;* 函数声明 *&#x2F;\n\nfoo(); &#x2F;&#x2F; &quot;bar&quot;\n\nfunction foo() &#123;\n  console.log(&quot;bar&quot;);\n&#125;\n\n&#x2F;* 函数表达式 *&#x2F;\n\nbaz(); &#x2F;&#x2F; 类型错误：baz 不是一个函数\n\nvar baz &#x3D; function () &#123;\n  console.log(&quot;bar2&quot;);\n&#125;;</code></pre>\n\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><p>全局变量是全局对象的属性。在网页中，（译注：缺省的）全局对象是 window ，所以你可以用形如 window.variable 的语法来设置和访问全局变量。</p>\n<p>因此，你可以通过指定 window 或 frame 的名字，在当前 window 或 frame 访问另一个 window 或 frame 中声明的变量。例如，在文档里声明一个叫 phoneNumber 的变量，那么你就可以在子框架里使用 parent.phoneNumber 的方式来引用它。</p>\n<h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><p>你可以用关键字 const 创建一个只读的常量。常量标识符的命名规则和变量相同：必须以字母、下划线（_）或美元符号（$）开头并可以包含有字母、数字或下划线。</p>\n<p>const PI &#x3D; 3.14;</p>\n<p>常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。它必须被初始化为某个值。</p>\n<p>常量的作用域规则与 let 块级作用域变量相同。若省略 const 关键字，则该标识符将被视为变量。</p>\n<p>在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 这会造成错误\nfunction f() &#123;&#125;\nconst f &#x3D; 5;\n\n&#x2F;&#x2F; 这也会造成错误\nfunction f() &#123;\n  const g &#x3D; 5;\n  var g;\n\n  &#x2F;&#x2F;语句\n&#125;</code></pre>\n\n<p>然而，对象属性被赋值为常量是不受保护的，所以下面的语句执行时不会产生错误。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const MY_OBJECT &#x3D; &#123; key: &quot;value&quot; &#125;;\nMY_OBJECT.key &#x3D; &quot;otherValue&quot;;</code></pre>\n\n<p>同样的，数组的被定义为常量也是不受保护的，所以下面的语句执行时也不会产生错误。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const MY_ARRAY &#x3D; [&quot;HTML&quot;, &quot;CSS&quot;];\nMY_ARRAY.push(&quot;JAVASCRIPT&quot;);\nconsole.log(MY_ARRAY); &#x2F;&#x2F;logs [&#39;HTML&#39;,&#39;CSS&#39;,&#39;JAVASCRIPT&#39;];</code></pre>\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p><a href=\"/post/2022-07-28js-closures\" target=\"_blank\" >前端基础-js 闭包</a></p>\n<h2 id=\"事例\"><a href=\"#事例\" class=\"headerlink\" title=\"事例\"></a>事例</h2><h2 id=\"es6-之前没有块级作用域\"><a href=\"#es6-之前没有块级作用域\" class=\"headerlink\" title=\"es6 之前没有块级作用域\"></a>es6 之前没有块级作用域</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; 12;\nif (a &gt; 10) &#123;\n  var c &#x3D; a + 1;\n&#125;\nconsole.log(a, c);</code></pre>\n\n<h3 id=\"有-var-和-无-var\"><a href=\"#有-var-和-无-var\" class=\"headerlink\" title=\"有 var 和 无 var\"></a>有 var 和 无 var</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function fn() &#123;\n  var a &#x3D; (b &#x3D; 30);\n  console.log(a, b); &#x2F;&#x2F; 30,30\n&#125;\nfn();\nconsole.log(b); &#x2F;&#x2F; 30\nconsole.log(a); &#x2F;&#x2F; Uncaught ReferenceError: a is not defined\n\n&#x2F;&#x2F; 解释：在非严格模式下，允许不用var声明变量，不用var声明的变量会默认为全局变量。var a &#x3D; b &#x3D;30 等价于b &#x3D; 10;b &#x3D; 10; 所以b是一个全局变量，a是个局部变量。</code></pre>\n\n<h3 id=\"变量提升，函数声明提升\"><a href=\"#变量提升，函数声明提升\" class=\"headerlink\" title=\"变量提升，函数声明提升\"></a>变量提升，函数声明提升</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fn1(); &#x2F;&#x2F; fn1\nfn2(); &#x2F;&#x2F;第一次fn2调用  &#x2F;&#x2F; 报错\n\nfunction fn1() &#123;\n  console.log(&quot;fn1&quot;);\n&#125;\n\nvar fn2 &#x3D; function () &#123;\n  console.log(&quot;fn2&quot;);\n&#125;;\n\nfn2(); &#x2F;&#x2F;第二次fn2调用\n\n&#x2F;&#x2F; 解释：第一个位置调用fn2报错，代码终止执行；如果屏蔽第一个位置调用fn2，在第二个位置调用，正常调用，并输出“fn2”。这里考察的是变量提升和函数提升。上述代码等介于：</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 函数提升和变量提升\nfunction fn1() &#123;\n  console.log(&quot;fn1&quot;);\n&#125;\nvar fn2;\n\nfn1();\nfn2();\n\nfn2 &#x3D; function () &#123;\n  console.log(&quot;fn2&quot;);\n&#125;;\n\nfn2();</code></pre>\n\n<h3 id=\"函数提升在变量之前进行\"><a href=\"#函数提升在变量之前进行\" class=\"headerlink\" title=\"函数提升在变量之前进行\"></a>函数提升在变量之前进行</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(a); &#x2F;&#x2F; f a() &#123;console.log(10)&#125;\nconsole.log(a()); &#x2F;&#x2F;  undefined\nvar a &#x3D; 3;\n\nfunction a() &#123;\n  console.log(10); &#x2F;&#x2F;10\n&#125;\nconsole.log(a); &#x2F;&#x2F;3\na &#x3D; 6;\nconsole.log(a()); &#x2F;&#x2F;a is not a function;</code></pre>\n\n<p>实际编译过程如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var a &#x3D; funtion () &#123;\n  console.log(10)\n&#125;\nvar a;\nconsole.log(a);    &#x2F;&#x2F; f a() &#123;console.log(10)&#125;\nconsole.log(a());  &#x2F;&#x2F;  undefined\n\na &#x3D; 3;\nconsole.log(a)   &#x2F;&#x2F;3\na &#x3D; 6;\nconsole.log(a());   &#x2F;&#x2F;a() is not a function;</code></pre>\n\n<h3 id=\"循环中-IIFE-函数形成的匿名空间\"><a href=\"#循环中-IIFE-函数形成的匿名空间\" class=\"headerlink\" title=\"循环中,IIFE 函数形成的匿名空间\"></a>循环中,IIFE 函数形成的匿名空间</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 代码1\nfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(function () &#123;\n    console.log(i);\n  &#125;, i * 2000);\n&#125;\n\n&#x2F;&#x2F; 代码2\nfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  (function (i) &#123;\n    setTimeout(function () &#123;\n      console.log(i);\n    &#125;, i * 2000);\n  &#125;)(i);\n&#125;</code></pre>\n\n<h3 id=\"作用域与作用域链\"><a href=\"#作用域与作用域链\" class=\"headerlink\" title=\"作用域与作用域链\"></a>作用域与作用域链</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 代码\nvar a &#x3D; 10;\nfunction fn() &#123;\n  console.log(a);\n&#125;\n\nfunction fn2(f) &#123;\n  var a &#x3D; 20;\n  f();\n&#125;\n\nfn2();\n\n&#x2F;&#x2F; 解释：考察了作用域与作用域链的相关知识。记住两点：\n&#x2F;&#x2F; 1、作用域与作用域链都是一个静态的概念，在函数定义的时候就确定了；\n&#x2F;&#x2F; 2、通过作用域链查找遍了的时候，首先要找到函数本身的作用域，从它本身的作用域开始沿着作用域链向它的上一级依次查找。</code></pre>\n\n<h3 id=\"作用域与作用域链-1\"><a href=\"#作用域与作用域链-1\" class=\"headerlink\" title=\"作用域与作用域链\"></a>作用域与作用域链</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var fn &#x3D; function () &#123;\n  console.log(fn);\n&#125;;\nfn();\n\nvar obj &#x3D; &#123;\n  fn2: function () &#123;\n    console.log(fn2);\n  &#125;,\n&#125;;\nobj.fn2();\n&#x2F;&#x2F; 解释：这里同样考察的是作用域和作用域链的知识。同时要注意：在obj中的console.log(fn2) 和 console.log(this.fn2)的区别。</code></pre>\n\n<h3 id=\"this-指向\"><a href=\"#this-指向\" class=\"headerlink\" title=\"this 指向\"></a>this 指向</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var obj &#x3D; &#123;\n  fn2: function () &#123;\n    console.log(this.fn2);\n  &#125;,\n&#125;;\nobj.fn2(); &#x2F;&#x2F;输出fn2函数</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/block\" target=\"_blank\" >MDN 块语句</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let\" target=\"_blank\" >MDN let</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var\" target=\"_blank\" >MDN var</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\" >MDN const </a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types\" target=\"_blank\" >MDN 语法和数据类型</a></p>\n<p><a href=\"https://blog.csdn.net/jingsi1991/article/details/84770480\" target=\"_blank\" >作用域相关</a></p>\n<p><a href=\"https://blog.csdn.net/liuanpingfirst/article/details/84947816\" target=\"_blank\" >let 和 const 定义的变量在哪？在 Script 这个域中</a></p>\n","text":"问题var let const 区别： 版本： var 是 es6 之前， const、let es6 之后， 分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域 提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":33,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">思维导图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">作用域链</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">块级作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">变量声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">变量提升</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">函数提升</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">全局变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">常量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BE%8B\"><span class=\"toc-text\">事例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#es6-%E4%B9%8B%E5%89%8D%E6%B2%A1%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">es6 之前没有块级作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89-var-%E5%92%8C-%E6%97%A0-var\"><span class=\"toc-text\">有 var 和 无 var</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">变量提升，函数声明提升</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E5%9C%A8%E5%8F%98%E9%87%8F%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C\"><span class=\"toc-text\">函数提升在变量之前进行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E4%B8%AD-IIFE-%E5%87%BD%E6%95%B0%E5%BD%A2%E6%88%90%E7%9A%84%E5%8C%BF%E5%90%8D%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">循环中,IIFE 函数形成的匿名空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">作用域与作用域链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-1\"><span class=\"toc-text\">作用域与作用域链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this-%E6%8C%87%E5%90%91\"><span class=\"toc-text\">this 指向</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"OA业务相关","uid":"816f51e81b001fc0ce3338816ad5683d","slug":"2022-08-01oa工具","date":"2022-08-01T10:13:29.000Z","updated":"2022-09-16T13:54:56.309Z","comments":true,"path":"api/articles/2022-08-01oa工具.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202208011824433.webp","text":"slate 钉钉文档、BOSS直聘文档、我们公司的wiki文档 都是使用 slate 开发的 我们公司的 wiki 文档 钉钉文档 思维导图 不建议直接使用百度脑图仓库进行二次开发。 需要脑图可视化需求的，可以基于 kityminder-core 进行二次开发；需要脑图编辑需求的...","link":"","photos":[],"count_time":{"symbolsCount":371,"symbolsTime":"1 mins."},"categories":[{"name":"业务相关","slug":"业务相关","count":1,"path":"api/categories/业务相关.json"}],"tags":[{"name":"业务相关","slug":"业务相关","count":1,"path":"api/tags/业务相关.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-js eventloop","uid":"2f158976ef1fb5c7b879b46326b6f72a","slug":"2022-07-29js-eventloop","date":"2022-07-29T10:04:52.000Z","updated":"2022-09-16T13:54:56.231Z","comments":true,"path":"api/articles/2022-07-29js-eventloop.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/事件循环.png","text":"思维导图 背景JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟 JavaScript 的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":33,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"生活不止眼前的苟且，还有诗和远方","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}