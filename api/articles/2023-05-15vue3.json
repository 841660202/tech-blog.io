{"title":"vue3 vs vue2","uid":"8eccc4e7c50ae11b02bb829241892974","slug":"2023-05-15vue3","date":"2023-05-15T15:24:09.000Z","updated":"2023-05-29T00:41:07.288Z","comments":true,"path":"api/articles/2023-05-15vue3.json","keywords":null,"cover":null,"content":"<h2 id=\"vue3-相对于-vue2-有哪些变化\"><a href=\"#vue3-相对于-vue2-有哪些变化\" class=\"headerlink\" title=\"vue3 相对于 vue2 有哪些变化\"></a>vue3 相对于 vue2 有哪些变化</h2><p>Vue 3 相对于 Vue 2 引入了一些重大变化和新功能。以下是 Vue 3 相对于 Vue 2 的一些主要变化：</p>\n<ol>\n<li><p><strong>更好的性能</strong>：Vue 3 经过优化，具有更高的性能表现。它引入了基于 Proxy 的响应式系统，可以更精确地跟踪状态的更改，从而提供更高效的重新渲染和更新。</p>\n</li>\n<li><p><strong>Composition API</strong>：Vue 3 引入了 Composition API，它是一种新的 API 风格，允许开发者根据逻辑功能组织和重用代码。与 Vue 2 的 Options API 相比，Composition API 更灵活、可组合和易于维护。</p>\n</li>\n<li><p><strong>更好的 TypeScript 支持</strong>：Vue 3 对 TypeScript 的支持更加出色。通过类型推断，Vue 3 可以更好地与 TypeScript 集成，并提供更准确的类型定义。</p>\n</li>\n<li><p><strong>Teleport</strong>：Vue 3 引入了 Teleport，这是一种新的组件，可以将组件的内容渲染到 DOM 中的任意位置。Teleport 使得在组件层次结构中的任何地方进行渲染成为可能，这对于实现诸如模态框、弹出菜单等功能非常有用。</p>\n</li>\n<li><p><strong>Fragments</strong>：Vue 3 引入了 Fragments，允许组件返回多个根元素，而不需要将它们包装在单个父元素中。这样可以更灵活地组织组件的结构，使得编写更清晰、简洁的模板变得更容易。</p>\n</li>\n<li><p><strong>更好的 Tree Shaking</strong>：Vue 3 的代码结构经过优化，使得 Tree Shaking（树摇）能够更好地工作，从而减少最终构建文件的大小。</p>\n</li>\n<li><p><strong>更好的递归组件</strong>：Vue 3 对递归组件的支持进行了改进，现在可以使用普通的组件选项来定义递归组件，而不需要使用特殊的<code>name</code>选项。</p>\n</li>\n</ol>\n<p>这些是 Vue 3 相对于 Vue 2 的一些主要变化。虽然这些变化带来了一些新的学习曲线和迁移工作，但也为开发者提供了更强大、高效和灵活的工具和功能。</p>\n<h2 id=\"每个组合式-API-的示例\"><a href=\"#每个组合式-API-的示例\" class=\"headerlink\" title=\"每个组合式 API 的示例\"></a>每个组合式 API 的示例</h2><p>以下是每个组合式 API 的示例：</p>\n<ol>\n<li><strong>setup()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      count: 0,\n    &#125;);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      state.count++;\n    &#125;;\n\n    return &#123; state, increment &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>setup()</code>函数创建了一个响应式数据对象<code>state</code>，并定义了一个<code>increment()</code>函数，用于将<code>count</code>属性的值加 1。最后，<code>setup()</code>函数返回了一个包含<code>state</code>和<code>increment</code>属性的对象，这些属性可以在组件中使用。</p>\n<ol start=\"2\">\n<li><strong>reactive()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      message: &#39;Hello, World!&#39;,\n    &#125;);\n\n    return &#123; state &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>reactive()</code>函数创建了一个响应式数据对象<code>state</code>，该对象包含一个<code>message</code>属性，其初始值为<code>&#39;Hello, World!&#39;</code>。在<code>setup()</code>函数中返回了一个包含<code>state</code>属性的对象，该对象可以在组件中使用。</p>\n<ol start=\"3\">\n<li><strong>ref()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      count.value++;\n    &#125;;\n\n    return &#123; count, increment &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>ref()</code>函数将 0 这个普通值转换成了响应式值，然后定义了一个<code>increment()</code>函数，用于将<code>count</code>的值加 1。最后，<code>setup()</code>函数返回了一个包含<code>count</code>和<code>increment</code>属性的对象，这些属性可以在组件中使用。</p>\n<ol start=\"4\">\n<li><strong>computed()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; ref, computed &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    const doubleCount &#x3D; computed(() &#x3D;&gt; &#123;\n      return count.value * 2;\n    &#125;);\n\n    return &#123; count, doubleCount &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>computed()</code>函数创建了一个计算属性<code>doubleCount</code>，其值是<code>count</code>的值乘以 2。<code>doubleCount</code>会根据<code>count</code>的变化自动更新。</p>\n<ol start=\"5\">\n<li><strong>watch()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; ref, watch &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    watch(count, (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(&#96;count changed from $&#123;oldValue&#125; to $&#123;newValue&#125;&#96;);\n    &#125;);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      count.value++;\n    &#125;;\n\n    return &#123; count, increment &#125;;\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>watch()</code>函数监视<code>count</code>的变化，并在<code>count</code>的值发生变化时打印日志。</p>\n<ol start=\"6\">\n<li><strong>onMounted() &#x2F; onUpdated() &#x2F; onUnmounted()</strong></li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; onMounted, onUpdated, onUnmounted &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;Component mounted&#39;);\n    &#125;);\n\n    onUpdated(() &#x3D;&gt; &#123;\n      console.log(&#39;Component updated&#39;);\n    &#125;);\n\n    onUnmounted(() &#x3D;&gt; &#123;\n      console.log(&#39;Component unmounted&#39;);\n    &#125;);\n  &#125;,\n&#125;;</code></pre>\n\n<p>在这个示例中，<code>onMounted()</code></p>\n<h2 id=\"reactive-与-ref-的区别\"><a href=\"#reactive-与-ref-的区别\" class=\"headerlink\" title=\"reactive 与 ref 的区别\"></a>reactive 与 ref 的区别</h2><p><code>reactive()</code>和<code>ref()</code>是 Vue 3 中用于创建响应式数据的两种不同方式，它们之间有一些区别。</p>\n<ol>\n<li><strong>使用场景</strong>:</li>\n</ol>\n<ul>\n<li><code>ref()</code>通常用于单个值的情况，例如计数器、表单输入等简单场景。</li>\n<li><code>reactive()</code>通常用于对象或复杂数据结构的情况，例如状态管理、组件之间共享的数据等。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>返回值类型</strong>:</li>\n</ol>\n<ul>\n<li><code>ref()</code>返回一个包含<code>value</code>属性的对象，通过修改<code>value</code>属性的值来触发更新。例如：<code>const count = ref(0);</code>，在使用时需要通过<code>count.value</code>来访问和修改值。</li>\n<li><code>reactive()</code>返回一个响应式的代理对象，可以直接访问和修改对象的属性。例如：<code>const state = reactive(&#123; count: 0 &#125;);</code>，可以直接使用<code>state.count</code>来访问和修改值。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>更新触发方式</strong>:</li>\n</ol>\n<ul>\n<li><code>ref()</code>的更新是通过修改<code>value</code>属性的值来触发的，只有修改<code>value</code>的值，才能触发更新。例如：<code>count.value = 10;</code></li>\n<li><code>reactive()</code>的更新是通过修改对象的属性值来触发的。例如：<code>state.count = 10;</code></li>\n</ul>\n<ol start=\"4\">\n<li><strong>引用传递</strong>:</li>\n</ol>\n<ul>\n<li>使用<code>ref()</code>创建的响应式值在不同地方引用时，仍然是同一个引用。这意味着如果将<code>ref()</code>的返回值作为参数传递给其他函数或组件时，传递的是同一个引用。</li>\n<li>使用<code>reactive()</code>创建的响应式对象在不同地方引用时，每个引用都是一个独立的响应式代理对象。这意味着传递给其他函数或组件的是独立的对象。</li>\n</ul>\n<p>总的来说，<code>ref()</code>适用于简单的值类型的响应式数据，而<code>reactive()</code>适用于复杂对象或数据结构的响应式数据。在使用时，可以根据具体情况选择合适的方式来创建响应式数据。</p>\n<h2 id=\"组合式-API-computed-与-watch-的区别\"><a href=\"#组合式-API-computed-与-watch-的区别\" class=\"headerlink\" title=\"组合式 API computed 与 watch 的区别\"></a>组合式 API computed 与 watch 的区别</h2><p><code>computed()</code>和<code>watch()</code>是 Vue 3 中组合式 API 中用于处理数据变化的两种不同方式，它们之间有一些区别。</p>\n<ol>\n<li><strong>用法和语法</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>用于创建计算属性，接受一个计算函数作为参数，并返回一个计算属性对象。计算属性会根据其依赖的响应式数据自动更新。使用时，可以像访问普通属性一样使用计算属性。</li>\n<li><code>watch()</code>用于监视响应式数据的变化，并在数据变化时执行回调函数。它接受两个参数，第一个参数是要监视的数据，第二个参数是回调函数。回调函数会在监视的数据发生变化时被调用。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>用途</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>适用于计算和衍生响应式数据的场景。例如，根据一组响应式数据计算出一个衍生的结果，如根据商品的数量和单价计算总价。</li>\n<li><code>watch()</code>适用于监视数据的变化并执行一些副作用的场景。例如，监听表单输入字段的变化，并在每次变化时发送网络请求。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>触发方式</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>的更新是惰性的，即只有当计算属性的依赖发生变化时，计算属性才会重新计算。在模板中访问计算属性时，会自动触发计算属性的计算过程。</li>\n<li><code>watch()</code>的更新是基于数据的实际变化的。当监视的数据发生变化时，回调函数会立即被调用。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>灵活性</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>在定义时会自动处理依赖关系，并建立起与相关数据的关联。当依赖数据发生变化时，计算属性会自动更新。这种自动管理依赖关系的特性使得计算属性非常方便和易于使用。</li>\n<li><code>watch()</code>在监视数据时，可以手动指定需要监视的数据，也可以通过函数来指定需要监视的多个数据。这种灵活性使得可以在一个回调函数中处理多个相关的数据变化。</li>\n</ul>\n<p>总的来说，<code>computed()</code>适用于计算和衍生响应式数据的场景，而<code>watch()</code>适用于监视数据的变化并执行副作用的场景。在使用时，可以根据具体需求选择合适的方式来处理数据的变化。</p>\n<h2 id=\"组合式-API-computed-与-watch-的区别-1\"><a href=\"#组合式-API-computed-与-watch-的区别-1\" class=\"headerlink\" title=\"组合式 API computed 与 watch 的区别\"></a>组合式 API computed 与 watch 的区别</h2><p><code>computed()</code>和<code>watch()</code>是 Vue 3 中组合式 API 中用于处理数据变化的两种不同方式，它们之间有一些区别。</p>\n<ol>\n<li><strong>用法和语法</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>用于创建计算属性，接受一个计算函数作为参数，并返回一个计算属性对象。计算属性会根据其依赖的响应式数据自动更新。使用时，可以像访问普通属性一样使用计算属性。</li>\n<li><code>watch()</code>用于监视响应式数据的变化，并在数据变化时执行回调函数。它接受两个参数，第一个参数是要监视的数据，第二个参数是回调函数。回调函数会在监视的数据发生变化时被调用。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>用途</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>适用于计算和衍生响应式数据的场景。例如，根据一组响应式数据计算出一个衍生的结果，如根据商品的数量和单价计算总价。</li>\n<li><code>watch()</code>适用于监视数据的变化并执行一些副作用的场景。例如，监听表单输入字段的变化，并在每次变化时发送网络请求。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>触发方式</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>的更新是惰性的，即只有当计算属性的依赖发生变化时，计算属性才会重新计算。在模板中访问计算属性时，会自动触发计算属性的计算过程。</li>\n<li><code>watch()</code>的更新是基于数据的实际变化的。当监视的数据发生变化时，回调函数会立即被调用。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>灵活性</strong>：</li>\n</ol>\n<ul>\n<li><code>computed()</code>在定义时会自动处理依赖关系，并建立起与相关数据的关联。当依赖数据发生变化时，计算属性会自动更新。这种自动管理依赖关系的特性使得计算属性非常方便和易于使用。</li>\n<li><code>watch()</code>在监视数据时，可以手动指定需要监视的数据，也可以通过函数来指定需要监视的多个数据。这种灵活性使得可以在一个回调函数中处理多个相关的数据变化。</li>\n</ul>\n<p>总的来说，<code>computed()</code>适用于计算和衍生响应式数据的场景，而<code>watch()</code>适用于监视数据的变化并执行副作用的场景。在使用时，可以根据具体需求选择合适的方式来处理数据的变化。</p>\n<h2 id=\"vue3-是倾向于函数式变成还是面向对象编程？\"><a href=\"#vue3-是倾向于函数式变成还是面向对象编程？\" class=\"headerlink\" title=\"vue3 是倾向于函数式变成还是面向对象编程？\"></a>vue3 是倾向于函数式变成还是面向对象编程？</h2><p>Vue 3 更倾向于函数式编程而不是面向对象编程。</p>\n<p>Vue 3 引入了组合式 API，其中的核心思想是将组件的逻辑拆分为一组可重用的函数。这种方式更加符合函数式编程的理念，通过函数的组合和抽象来构建复杂的逻辑。</p>\n<p>组合式 API 鼓励开发者将逻辑抽象为纯函数，使得代码更加模块化、可测试和可维护。使用函数可以更好地组织和重用代码，提高代码的可读性和可维护性。</p>\n<p>而面向对象编程通常将逻辑封装在对象中，通过对象之间的交互来实现功能。尽管 Vue 3 仍然支持面向对象编程的方式，可以通过创建类和使用类的实例来编写组件，但推荐的方式是使用组合式 API。</p>\n<p>组合式 API 倡导使用函数来编写逻辑，而不是依赖于类和对象的继承和实例化。这种方式更加简洁、灵活，并且与函数式编程的思想更加契合。</p>\n<p>总的来说，虽然 Vue 3 仍然支持面向对象编程，但更倾向于函数式编程，通过组合式 API 提供了更强大的函数式编程能力，使代码更具可读性、可维护性和可测试性。</p>\n<h2 id=\"Teleport-语法\"><a href=\"#Teleport-语法\" class=\"headerlink\" title=\"Teleport 语法\"></a>Teleport 语法</h2><p>Teleport 是通过 <code>&lt;teleport&gt;</code> 元素和 <code>to</code> 属性来实现的，它的语法如下：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;teleport to&#x3D;&quot;目标选择器&quot;&gt;\n  &lt;!-- 要渲染的内容 --&gt;\n&lt;&#x2F;teleport&gt;</code></pre>\n\n<ul>\n<li><code>&lt;teleport&gt;</code>：用于包裹要渲染的内容的容器元素。它是 Teleport 的根元素。</li>\n<li><code>to</code> 属性：指定要渲染到的目标位置。它可以是选择器字符串，表示要将内容渲染到与选择器匹配的元素内，或者是一个 DOM 元素的引用，表示要将内容渲染到该 DOM 元素内。</li>\n</ul>\n<p>在 <code>&lt;teleport&gt;</code> 元素内部，可以放置要渲染的内容，这可以是任何有效的 HTML 或 Vue 模板代码。</p>\n<p>通过使用 Teleport，你可以在组件树中的任意位置渲染内容。这对于实现全局弹窗、模态框、通知消息等功能非常有用。将内容渲染到 <code>&lt;teleport&gt;</code> 指定的目标位置后，它将脱离组件的父节点，成为目标位置的子节点。</p>\n<p>例如，在上面的示例中，我们使用 <code>&lt;teleport&gt;</code> 将模态框的内容渲染到 <code>&lt;body&gt;</code> 元素中，实现了一个全局的模态框效果。</p>\n<p>需要注意的是，为了确保 Teleport 正常工作，目标位置必须是组件所在的 DOM 树之外的一个位置。这样，Teleport 可以绕过父组件的 CSS 和样式隔离，从而在指定的目标位置渲染内容。</p>\n<p>总的来说，Teleport 提供了一种方便的方式来在组件树之外的位置渲染内容，并能够将其与其他组件进行解耦和灵活组合。</p>\n<h2 id=\"Teleport-示例\"><a href=\"#Teleport-示例\" class=\"headerlink\" title=\"Teleport 示例\"></a>Teleport 示例</h2><p>Teleport 是 Vue 3 中的一个特性，用于在组件树中的任意位置渲染内容。以下是一个 Teleport 的示例：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;showModal &#x3D; true&quot;&gt;Open Modal&lt;&#x2F;button&gt;\n\n    &lt;teleport to&#x3D;&quot;body&quot;&gt;\n      &lt;div v-if&#x3D;&quot;showModal&quot; class&#x3D;&quot;modal&quot;&gt;\n        &lt;h2&gt;Modal Content&lt;&#x2F;h2&gt;\n        &lt;p&gt;This modal is teleported to the body.&lt;&#x2F;p&gt;\n        &lt;button @click&#x3D;&quot;showModal &#x3D; false&quot;&gt;Close&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;teleport&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const showModal &#x3D; ref(false);\n\n    return &#123;\n      showModal,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.modal &#123;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  padding: 1rem;\n&#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p>在上述示例中，我们有一个按钮，点击该按钮会显示一个模态框。模态框的内容位于 <code>&lt;teleport&gt;</code> 元素内，通过设置 <code>to</code> 属性为 “body”，将模态框渲染到 <code>&lt;body&gt;</code> 元素中。</p>\n<p>使用 <code>&lt;teleport&gt;</code>，我们可以在组件的模板中声明要渲染到的位置，然后将内容放置在 <code>&lt;teleport&gt;</code> 内部。这样，我们可以轻松地将内容渲染到组件树之外的位置，例如在全局样式下方、在特定的容器中等。</p>\n<p>注意，Teleport 在 Vue 3 中取代了 Vue 2 中的 <code>&lt;component&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 的功能。</p>\n<h2 id=\"Fragments-语法及示例\"><a href=\"#Fragments-语法及示例\" class=\"headerlink\" title=\"Fragments 语法及示例\"></a>Fragments 语法及示例</h2><p>Fragments（片段）是一种在 Vue 3 中用于包裹多个子元素的语法结构，它允许你在不引入额外 DOM 元素的情况下组织和渲染多个子元素。Fragments 可以通过两种方式来使用：<code>&lt;template&gt;</code> 标签和特殊的短语法。</p>\n<ol>\n<li><strong>使用 <code>&lt;template&gt;</code> 标签</strong>：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;!-- Fragments 使用 &lt;template&gt; 标签包裹多个子元素 --&gt;\n  &lt;template&gt;\n    &lt;h1&gt;Header&lt;&#x2F;h1&gt;\n    &lt;p&gt;Paragraph&lt;&#x2F;p&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;template&gt;</code></pre>\n\n<p>在上述示例中，我们使用了一个外层的 <code>&lt;template&gt;</code> 标签来包裹多个子元素。这个外层的 <code>&lt;template&gt;</code> 标签本身不会在最终的渲染结果中产生任何额外的 DOM 元素，它只是用来作为一个容器，方便地组织和包裹多个子元素。</p>\n<ol start=\"2\">\n<li><strong>使用特殊的短语法</strong>：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;!-- Fragments 使用特殊的短语法 --&gt;\n  &lt;&gt;\n    &lt;h1&gt;Header&lt;&#x2F;h1&gt;\n    &lt;p&gt;Paragraph&lt;&#x2F;p&gt;\n  &lt;&#x2F;&gt;\n&lt;&#x2F;template&gt;</code></pre>\n\n<p>在上述示例中，我们使用了特殊的短语法 <code>&lt;&gt;</code> 和 <code>&lt;/&gt;</code> 来表示一个 Fragment，即片段。它的作用与使用 <code>&lt;template&gt;</code> 标签相同，可以包裹多个子元素，并且在最终的渲染结果中不会生成额外的 DOM 元素。</p>\n<p>使用 Fragments 可以解决在 Vue 2 中遇到的组件模板中只能有一个根元素的限制。现在，你可以使用 <code>&lt;template&gt;</code> 标签或特殊的短语法来方便地组织和渲染多个子元素，而无需引入多余的 DOM 元素。</p>\n<p>需要注意的是，Fragments 只是在编写模板时的一种语法结构，它不会被渲染成实际的 DOM 元素。它的主要作用是帮助你更好地组织和布局模板中的多个子元素。</p>\n<p>总的来说，Fragments 提供了一种在 Vue 3 中组织和渲染多个子元素的方式，可以通过 <code>&lt;template&gt;</code> 标签或特殊的短语法来使用，避免了只能有一个根元素的限制。</p>\n<h2 id=\"vue3-实现原理\"><a href=\"#vue3-实现原理\" class=\"headerlink\" title=\"vue3 实现原理\"></a>vue3 实现原理</h2><p>Vue 3 的实现原理涉及多个方面，包括模板编译、响应式系统、虚拟 DOM 和渲染过程等。以下是 Vue 3 的基本实现原理的概述：</p>\n<ol>\n<li><p><strong>模板编译</strong>：Vue 3 使用编译器将模板转换为渲染函数。编译器将模板解析为抽象语法树（AST），然后根据 AST 生成渲染函数。渲染函数是一个返回虚拟 DOM 的函数，用于描述组件的结构和数据依赖关系。</p>\n</li>\n<li><p><strong>响应式系统</strong>：Vue 3 的响应式系统使用 Proxy 对象实现。在组件初始化时，Vue 3 会将组件的数据对象转换为响应式对象，通过代理对象捕获对响应式数据的访问和修改操作。当数据发生变化时，响应式系统会通知相关的依赖项，从而更新相关的视图。</p>\n</li>\n<li><p><strong>虚拟 DOM</strong>：Vue 3 使用虚拟 DOM 来进行高效的 DOM 更新。虚拟 DOM 是一个描述真实 DOM 结构的 JavaScript 对象树，通过比较新旧虚拟 DOM 树的差异，可以高效地计算出需要进行的 DOM 更新操作，并将更新应用到实际的 DOM 中。</p>\n</li>\n<li><p><strong>渲染过程</strong>：在组件初始化时，Vue 3 会执行组件的 <code>setup()</code> 函数，其中可以进行数据的初始化、依赖的创建和副作用的设置。然后，Vue 3 会根据渲染函数生成的虚拟 DOM，将组件的初始视图渲染到真实的 DOM 中。当响应式数据发生变化时，Vue 3 会根据依赖关系重新计算虚拟 DOM 的差异，并将变化应用到实际的 DOM 中，实现局部的更新。</p>\n</li>\n</ol>\n<p>此外，Vue 3 还引入了组合式 API，通过 <code>setup()</code> 函数和一系列的 Composition 函数（如 <code>ref</code>、<code>reactive</code>、<code>computed</code>、<code>watch</code> 等）来组织和共享组件逻辑。组合式 API 提供了更灵活、模块化的方式来编写组件，使代码更可读、可维护。</p>\n<p>总的来说，Vue 3 的实现原理涵盖了模板编译、响应式系统、虚拟 DOM 和渲染过程等关键方面。通过将模板转换为渲染函数，使用响应式系统追踪数据的变化，利用虚拟 DOM 进行高效的 DOM 更新，以及使用组合式 API 组织和共享组件逻辑，Vue 3 实现了高效、灵活和易用的组件化开发框架。</p>\n<h2 id=\"vue2-用没用虚拟-dom\"><a href=\"#vue2-用没用虚拟-dom\" class=\"headerlink\" title=\"vue2 用没用虚拟 dom\"></a>vue2 用没用虚拟 dom</h2><p>是的，Vue 2 使用了虚拟 DOM（Virtual DOM）作为其渲染机制的一部分。</p>\n<p>虚拟 DOM 是一种轻量级的、以 JavaScript 对象表示的 DOM 结构。Vue 2 在进行模板编译时，将模板解析为虚拟 DOM 树，并通过比较新旧虚拟 DOM 树的差异来计算需要更新的最小操作，然后将这些操作应用到实际的 DOM 中，以实现页面的更新。</p>\n<p>使用虚拟 DOM 有以下几个优势：</p>\n<ol>\n<li><p><strong>性能优化</strong>：虚拟 DOM 可以高效地计算出需要进行的最小 DOM 更新操作，从而减少对实际 DOM 的直接操作次数，提高了性能。</p>\n</li>\n<li><p><strong>跨平台能力</strong>：虚拟 DOM 是平台无关的，可以在浏览器环境以及其他环境（如服务器端渲染、移动端开发等）中使用，使得 Vue 具备了跨平台的能力。</p>\n</li>\n<li><p><strong>简化开发流程</strong>：通过使用虚拟 DOM，开发者可以将关注点集中在组件的状态和视图的声明式描述上，而无需直接操作 DOM，简化了开发流程。</p>\n</li>\n</ol>\n<p>虽然虚拟 DOM 带来了一定的性能优势和开发便利性，但它也有一些额外的开销，包括虚拟 DOM 树的构建和比较过程。这在某些情况下可能会导致一些性能损失。为了解决这个问题，Vue 3 引入了一种名为 “静态树提升”（Static Tree Hoisting）的优化策略，进一步提升了性能。</p>\n<p>总结来说，Vue 2 使用了虚拟 DOM 作为其渲染机制的一部分，通过比较新旧虚拟 DOM 树来计算需要更新的操作，并将其应用到实际的 DOM 中。虚拟 DOM 带来了性能优化和开发便利性，但也有一些额外的开销。</p>\n<h2 id=\"静态树提升\"><a href=\"#静态树提升\" class=\"headerlink\" title=\"静态树提升\"></a>静态树提升</h2><p>静态树提升是 Vue 3 中的性能优化策略，通过将静态的、不变的部分提升为常量，减少了不必要的虚拟 DOM 比较和更新操作，提高了渲染性能。这是在编译阶段自动进行的优化，无需开发者显式操作或配置。</p>\n<details class=\"custom-details\">\n<summary>Details</summary>\n<p>静态树提升（Static Tree Hoisting）是 Vue 3 中的一个优化策略，旨在进一步提高渲染性能。</p>\n<p>在 Vue 2 中，每次组件更新时，Vue 会生成一个新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行比较，以计算出需要更新的最小操作。然而，对于静态的、不变的部分，这种比较是不必要且浪费性能的。</p>\n<p>静态树提升的思想是将静态的、不变的部分提升为常量，避免每次更新时都进行比较。这样，在组件更新时，只需要关注动态部分的比较和更新，从而减少了不必要的性能开销。</p>\n<p>具体实现静态树提升的方式是通过编译器在模板编译阶段进行优化。编译器会静态地分析模板，将静态的部分提取出来作为常量，并在渲染函数中使用这些常量，而不再参与后续的虚拟 DOM 比较和更新操作。</p>\n<p>静态树提升的优势主要体现在以下几个方面：</p>\n<ol>\n<li><p><strong>减少虚拟 DOM 的比较和更新操作</strong>：将静态的部分提升为常量，避免了不必要的虚拟 DOM 的比较和更新，从而提高了性能。</p>\n</li>\n<li><p><strong>缩短组件更新的时间</strong>：由于静态的部分不再参与比较和更新，组件的更新时间会相应缩短，提升了整体的渲染性能。</p>\n</li>\n</ol>\n<p>需要注意的是，静态树提升是在编译阶段进行的优化，开发者不需要显式地进行操作或配置。Vue 3 的编译器会自动检测静态的部分，并进行提升。</p>\n<p>总的来说，静态树提升是 Vue 3 中的一个优化策略，通过将静态的、不变的部分提升为常量，减少了不必要的虚拟 DOM 比较和更新操作，从而提高了渲染性能。这是 Vue 3 在性能优化方面的一个重要改进。</p>\n\n</details>\n","text":"vue3 相对于 vue2 有哪些变化Vue 3 相对于 Vue 2 引入了一些重大变化和新功能。以下是 Vue 3 相对于 Vue 2 的一些主要变化： 更好的性能：Vue 3 经过优化，具有更高的性能表现。它引入了基于 Proxy 的响应式系统，可以更精确地跟踪状态的更改，从...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"vue","slug":"vue","count":14,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":14,"path":"api/tags/vue.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":15,"path":"api/tags/chatGPT2021.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue3-%E7%9B%B8%E5%AF%B9%E4%BA%8E-vue2-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">vue3 相对于 vue2 有哪些变化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E7%BB%84%E5%90%88%E5%BC%8F-API-%E7%9A%84%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">每个组合式 API 的示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reactive-%E4%B8%8E-ref-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">reactive 与 ref 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E5%BC%8F-API-computed-%E4%B8%8E-watch-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">组合式 API computed 与 watch 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E5%BC%8F-API-computed-%E4%B8%8E-watch-%E7%9A%84%E5%8C%BA%E5%88%AB-1\"><span class=\"toc-text\">组合式 API computed 与 watch 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue3-%E6%98%AF%E5%80%BE%E5%90%91%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E5%8F%98%E6%88%90%E8%BF%98%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">vue3 是倾向于函数式变成还是面向对象编程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Teleport-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">Teleport 语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Teleport-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Teleport 示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fragments-%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Fragments 语法及示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">vue3 实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vue2-%E7%94%A8%E6%B2%A1%E7%94%A8%E8%99%9A%E6%8B%9F-dom\"><span class=\"toc-text\">vue2 用没用虚拟 dom</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%A0%91%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">静态树提升</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"组件库","uid":"c8e5bf059ccb884e44e277a41905094a","slug":"2023-05-16components","date":"2023-05-16T06:31:32.000Z","updated":"2023-05-29T00:41:07.269Z","comments":true,"path":"api/articles/2023-05-16components.json","keywords":null,"cover":[],"text":"目前用公司项目的几个问题组件库 组件库混乱 组件库封装的过大，依赖库过多，更有甚者，框架打包进去 组件库内部的使用的静态资源（如：字体），组件库没有引入 组件库更新不及时，项目中有用大版本依赖，组件库，大版本的低版本，ahooks 2,3 组件封装出来，没有人会用，找个组件的使用...","link":"","photos":[],"count_time":{"symbolsCount":686,"symbolsTime":"1 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"knife4j","uid":"acc57bd22d883480671c69c000337b31","slug":"2023-05-15knife4j","date":"2023-05-15T10:38:24.000Z","updated":"2023-05-15T13:17:33.012Z","comments":true,"path":"api/articles/2023-05-15knife4j.json","keywords":null,"cover":[],"text":"上图 😓，人才啊！ ","link":"","photos":[],"count_time":{"symbolsCount":14,"symbolsTime":"1 mins."},"categories":[{"name":"思考","slug":"思考","count":1,"path":"api/categories/思考.json"}],"tags":[{"name":"思考","slug":"思考","count":1,"path":"api/tags/思考.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}