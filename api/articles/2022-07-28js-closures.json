{"title":"前端基础-js 闭包","uid":"c29bc77697ff47f9bbee179892d7fe85","slug":"2022-07-28js-closures","date":"2022-07-28T10:04:36.000Z","updated":"2022-09-16T13:54:56.229Z","comments":true,"path":"api/articles/2022-07-28js-closures.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202207291656804.webp","content":"<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><img src=\"http://t-blog-images.aijs.top/img/202207291656804.webp\" />\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>一个函数 和 对其周围状态<code>（lexical environment，词法环境）</code>的引用, 捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p>\n<p>也就是说，闭包让你可以在一个内层函数中 访问到 其外层函数的<code>作用域</code>。在形式上体现为函数嵌套，内层函数有外层函数的变量引用， 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>\n<h2 id=\"词法环境\"><a href=\"#词法环境\" class=\"headerlink\" title=\"词法环境\"></a>词法环境</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.<br>翻译：词法环境： 是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个环境记录项和可能为空的外部词法环境引用构成</p></blockquote>\n<p>词法环境是: 由内部 JavaScript 引擎构造，用来保存标识符和变量&#x2F;函数的映射关系，同时，保存了对父级（词法环境- 标识符与变量映射）的引用。</p>\n<ul>\n<li><code>标识符</code> ： 指变量或者函数的名称</li>\n<li><code>变量</code>：对 <code>实际对象</code>（包括函数类型对象）或者<code>原始值</code>的引用</li>\n</ul>\n<p>词法环境组成：</p>\n<ul>\n<li><code>环境记录</code>：存储变量和函数声明的实际位置</li>\n<li><code>对外引用</code>：实际上就是对外部或者说是父级词法环境的引用</li>\n</ul>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p><strong>MDN:</strong><br>在当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。如果一个<strong>变量</strong>或者其他表达式不 “在当前的作用域中”，那么它就是不可用的。作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。</p>\n<p>作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>JavaScript 在执⾏过程中, 会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了<code>作⽤域链</code>。</p>\n<h2 id=\"可执行上下文\"><a href=\"#可执行上下文\" class=\"headerlink\" title=\"可执行上下文\"></a>可执行上下文</h2><p>当 js 引擎执行到一段可执行代码时，就会为之<code>创建对应的执行上下文(Execution Context)</code>。<br>那么因此执行上下文对应也有三种：<code>全局执行上下文</code>，<code>函数执行上下文</code>，<code>eval 执行上下文</code>。</p>\n<h2 id=\"可执行代码\"><a href=\"#可执行代码\" class=\"headerlink\" title=\"可执行代码\"></a>可执行代码</h2><p>ECMAScript 可执行代码分为三种类型：<code>全局代码</code>，<code>函数代码</code>，<code>eval 代码</code>。</p>\n<h2 id=\"可执行上下文栈\"><a href=\"#可执行上下文栈\" class=\"headerlink\" title=\"可执行上下文栈\"></a>可执行上下文栈</h2><img src=\"http://t-blog-images.aijs.top/img/202207291418098.webp\" />\n\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>分析器如何在函数嵌套的情况下解析变量名</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"http://t-blog-images.aijs.top/img/202207291656804.webp\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202207291703485.webp\" />\n\n<h2 id=\"闭包作用\"><a href=\"#闭包作用\" class=\"headerlink\" title=\"闭包作用\"></a>闭包作用</h2><ul>\n<li>用闭包模拟私有方法</li>\n<li>数据缓存</li>\n</ul>\n<h2 id=\"闭包性能\"><a href=\"#闭包性能\" class=\"headerlink\" title=\"闭包性能\"></a>闭包性能</h2><ul>\n<li>如果不是某些特定任务, 需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</li>\n</ul>\n<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。</p>\n<p><strong>示例：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function MyObject(name, message) &#123;\n  this.name &#x3D; name.toString();\n  this.message &#x3D; message.toString();\n  this.getName &#x3D; function () &#123;\n    return this.name;\n  &#125;;\n\n  this.getMessage &#x3D; function () &#123;\n    return this.message;\n  &#125;;\n&#125;</code></pre>\n\n<p><strong>可改成如下例子：</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function MyObject(name, message) &#123;\n  this.name &#x3D; name.toString();\n  this.message &#x3D; message.toString();\n&#125;\nMyObject.prototype.getName &#x3D; function () &#123;\n  return this.name;\n&#125;;\nMyObject.prototype.getMessage &#x3D; function () &#123;\n  return this.message;\n&#125;;</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/qq_42345237/article/details/120603881\" target=\"_blank\" >词法环境是什么？</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1729331413156806540&wfr=spider&for=pc\" target=\"_blank\" >词法作用域</a></p>\n<p><a href=\"https://juejin.cn/post/7019682405896175653\" target=\"_blank\" >可执行代码与执行上下文</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Scope\" target=\"_blank\" >Scope（作用域）</a></p>\n","text":"思维导图 闭包一个函数 和 对其周围状态（lexical environment，词法环境）的引用, 捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） 也就是说，闭包让你可以在一个内层函数中 访问到 其外层函数的作用域。在形式上体现为函数嵌套，内层函数有外...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">思维导图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">词法环境</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">作用域链</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">可执行上下文</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">可执行代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88\"><span class=\"toc-text\">可执行上下文栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">词法作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">闭包作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">闭包性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础-js eventloop","uid":"2f158976ef1fb5c7b879b46326b6f72a","slug":"2022-07-29js-eventloop","date":"2022-07-29T10:04:52.000Z","updated":"2022-09-16T13:54:56.231Z","comments":true,"path":"api/articles/2022-07-29js-eventloop.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/事件循环.png","text":"思维导图 背景JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟 JavaScript 的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-js 函数","uid":"d7bd88002098c0649a55dcb4db29ef28","slug":"2022-07-28js-fun","date":"2022-07-28T03:13:15.000Z","updated":"2022-09-17T07:48:05.687Z","comments":true,"path":"api/articles/2022-07-28js-fun.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/202208011605439.webp","text":"思维导图 arguments arguments 对象不是一个 Array 。它类似于 Array，但除了 length 属性和索引元素之外没有任何 Array 属性 使用数组方法&#x2F;&#x2F; Array.prototype.slice.call function m...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":29,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":31,"path":"api/tags/前端基础.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"Don't repeat yourself！Faster and better！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}