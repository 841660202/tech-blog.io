{"title":"9.Typescriptæ‰‹å†Œ æ¨¡å—","uid":"29a670518a826389296f8915224ed71e","slug":"2022-06-08ts-modules","date":"2022-06-08T14:47:47.000Z","updated":"2022-06-09T13:53:32.970Z","comments":true,"path":"api/articles/2022-06-08ts-modules.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","content":"<p>JavaScript has a long history of different ways to handle modularizing code. TypeScript having been around since 2012, has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the import&#x2F;export syntax.<br><code>JavaScript æœ‰å¾ˆé•¿çš„å†å²ï¼Œä¸åŒçš„æ–¹å¼æ¥å¤„ç†ä»£ç çš„æ¨¡å—åŒ–ã€‚TypeScript ä» 2012 å¹´å¼€å§‹ï¼Œå°±æ”¯æŒäº†å¤§é‡çš„æ¨¡å—åŒ–æ ¼å¼ï¼Œä½†æ˜¯ï¼Œåœ¨è¿‡å»çš„æ—¶é—´ï¼Œç¤¾åŒºå’Œ JavaScript è§„èŒƒä¸€è‡´åœ°èšåˆäº†ä¸€ä¸ªæ¨¡å—åŒ–æ ¼å¼ï¼Œå«åš ES Modulesï¼ˆæˆ– ES6 æ¨¡å—ï¼‰ã€‚ä½ å¯èƒ½ä¼šçŸ¥é“å®ƒå«åš import/export è¯­æ³•ã€‚</code></p>\n<p>ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes.<br><code>ES Modules åœ¨ 2015 å¹´æ·»åŠ åˆ° JavaScript è§„èŒƒï¼Œ2020 å¹´å·²ç»æœ‰å¹¿æ³›çš„æ”¯æŒåœ¨å¤§éƒ¨åˆ†çš„ web æµè§ˆå™¨å’Œ JavaScript è¿è¡Œæ—¶ã€‚</code><br>For focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS module.exports &#x3D; syntax, and you can find information about the other module patterns in the reference section under Modules.<br><code>ä¸ºäº†è·å¾—ç„¦ç‚¹ï¼Œæœ¬æ‰‹å†Œå°†ä»‹ç» ES Modules å’Œå…¶å¸¸ç”¨çš„å…ˆè¡Œæ¨¡å— CommonJS module.exports = åŒä¹‰è¯ï¼Œå¹¶ä¸”ä½ å¯ä»¥åœ¨ Modules ä¸‹çš„å‚è€ƒèŠ‚ä¸­æ‰¾åˆ°å…¶ä»–æ¨¡å—æ¨¡å¼çš„ä¿¡æ¯ã€‚</code></p>\n<h2 id=\"How-JavaScript-Modules-are-Defined\"><a href=\"#How-JavaScript-Modules-are-Defined\" class=\"headerlink\" title=\"How JavaScript Modules are Defined\"></a>How JavaScript Modules are Defined</h2><p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module.<br><code>åœ¨ TypeScript ä¸­ï¼Œåªè¦æ–‡ä»¶åŒ…å«ä¸€ä¸ªé¡¶å±‚çš„ import æˆ– export å°±è¢«è§†ä¸ºä¸€ä¸ªæ¨¡å—ã€‚</code><br>Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).<br><code>åä¹‹ï¼Œä¸€ä¸ªæ²¡æœ‰é¡¶å±‚çš„ import æˆ– export å£°æ˜çš„æ–‡ä»¶å°±è¢«è§†ä¸ºä¸€ä¸ªè„šæœ¬ï¼Œå…¶å†…å®¹å¯ä»¥åœ¨å…¨å±€ä½œç”¨åŸŸä¸­ä½¿ç”¨ï¼ˆå¹¶ä¸”ä¹Ÿå¯ä»¥ä½œä¸ºæ¨¡å—ä½¿ç”¨ï¼‰ã€‚</code><br>Modules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.<br><code>æ¨¡å—æ˜¯åœ¨è‡ªå·±çš„ä½œç”¨åŸŸä¸­æ‰§è¡Œçš„ï¼Œä¸æ˜¯åœ¨å…¨å±€ä½œç”¨åŸŸä¸­æ‰§è¡Œçš„ã€‚è¿™æ„å‘³ç€åœ¨æ¨¡å—ä¸­å£°æ˜çš„å˜é‡ï¼Œå‡½æ•°ï¼Œç±»ï¼Œæ¥å£ç­‰ç­‰ï¼Œåªæœ‰åœ¨æ˜¾å¼çš„ä½¿ç”¨ export å£°æ˜çš„æ—¶å€™æ‰èƒ½åœ¨æ¨¡å—å¤–è¢«è®¿é—®ã€‚åä¹‹ï¼Œè¦ä»å…¶ä»–æ¨¡å—ä¸­æ¶ˆè´¹ä¸€ä¸ªå˜é‡ï¼Œå‡½æ•°ï¼Œç±»ï¼Œæ¥å£ç­‰ç­‰ï¼Œå¿…é¡»ä½¿ç”¨ import å£°æ˜æ¥å¯¼å…¥ã€‚</code></p>\n<h2 id=\"Non-modules\"><a href=\"#Non-modules\" class=\"headerlink\" title=\"Non-modules\"></a>Non-modules</h2><p><code>éæ¨¡å—</code><br>Before we start, itâ€™s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an export or top-level await should be considered a script and not a module.<br><code>åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ˜ç™½ TypeScript è®¤ä¸ºä»€ä¹ˆæ˜¯æ¨¡å—ã€‚JavaScript è§„èŒƒå®šä¹‰äº†ä»»ä½•æ²¡æœ‰ export æˆ– top-level await çš„ JavaScript æ–‡ä»¶éƒ½è¢«è§†ä¸ºè„šæœ¬è€Œä¸æ˜¯æ¨¡å—ã€‚</code><br>Inside a script file variables and types are declared to be in the shared global scope, and itâ€™s assumed that youâ€™ll either use the outFile compiler option to join multiple input files into one output file, or use multiple <script> tags in your HTML to load these files (in the correct order!).<br><code>åœ¨è„šæœ¬æ–‡ä»¶ä¸­ï¼Œå˜é‡å’Œç±»å‹è¢«å£°æ˜ä¸ºå…±äº«çš„å…¨å±€ä½œç”¨åŸŸï¼Œå¹¶ä¸”æˆ‘ä»¬å‡è®¾ä½ ä¼šä½¿ç”¨ outFile ç¼–è¯‘é€‰é¡¹å°†å¤šä¸ªè¾“å…¥æ–‡ä»¶åˆå¹¶æˆä¸€ä¸ªè¾“å‡ºæ–‡ä»¶ï¼Œæˆ–è€…ä½¿ç”¨å¤šä¸ª &lt;script&gt; æ ‡ç­¾åœ¨ä½ çš„ HTML ä¸­åŠ è½½è¿™äº›æ–‡ä»¶ï¼ˆæŒ‰ç…§æ­£ç¡®çš„é¡ºåºï¼‰ã€‚</code><br>If you have a file that doesnâ€™t currently have any imports or exports, but you want to be treated as a module, add the line:<br><code>å¦‚æœä½ æœ‰ä¸€ä¸ªæ–‡ä»¶ï¼Œå®ƒç›®å‰æ²¡æœ‰ä»»ä½• import æˆ– export å£°æ˜ï¼Œä½†æ˜¯ä½ æƒ³è¢«è§†ä¸ºä¸€ä¸ªæ¨¡å—ï¼Œé‚£ä¹ˆæ·»åŠ è¿™ä¸€è¡Œï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">export &#123;&#125;;</code></pre>\n\n<p>which will change the file to be a module exporting nothing. This syntax works regardless of your module target.<br><code>è¿™ç§è¯­æ³•å¯¹äºä½ çš„æ¨¡å—ç›®æ ‡æ— è®ºå¦‚ä½•éƒ½æ˜¯å¯è¡Œçš„ã€‚</code></p>\n<h2 id=\"Modules-in-TypeScript\"><a href=\"#Modules-in-TypeScript\" class=\"headerlink\" title=\"Modules in TypeScript\"></a>Modules in TypeScript</h2><p><code>TypeScript ä¸­çš„æ¨¡å—</code><br>Additional Reading:<br><code>é™„åŠ é˜…è¯»ï¼š</code><br>Impatient JS (Modules)<br><code>ä¸çŸ¥é“æ¨¡å—çš„ TypeScript</code><br>MDN: JavaScript Modules<br><code>MDNï¼šJavaScript æ¨¡å—</code><br>There are three main things to consider when writing module-based code in TypeScript:<br><code>åœ¨ TypeScript ä¸­å†™æ¨¡å—åŸºç¡€çš„ä»£ç æ—¶ï¼Œè¦è€ƒè™‘ä¸‰ä¸ªä¸»è¦é—®é¢˜ï¼š</code><br>Syntax: What syntax do I want to use to import and export things?<br><code>è¯­æ³•ï¼šæˆ‘æƒ³è¦ä½¿ç”¨ä»€ä¹ˆè¯­æ³•æ¥å¯¼å…¥å’Œå¯¼å‡ºä¸œè¥¿ï¼Ÿ</code><br>Module Resolution: What is the relationship between module names (or paths) and files on disk?<br><code>æ¨¡å—è§£æï¼šæ¨¡å—åï¼ˆæˆ–è·¯å¾„ï¼‰å’Œç£ç›˜ä¸Šçš„æ–‡ä»¶ä¹‹é—´çš„å…³ç³»æ˜¯ä»€ä¹ˆï¼Ÿ</code><br>Module Output Target: What should my emitted JavaScript module look like?<br><code>æ¨¡å—è¾“å‡ºç›®æ ‡ï¼šæˆ‘çš„è¾“å‡ºçš„ JavaScript æ¨¡å—åº”è¯¥æ€æ ·çœ‹ï¼Ÿ</code></p>\n<h2 id=\"ES-Module-Syntax\"><a href=\"#ES-Module-Syntax\" class=\"headerlink\" title=\"ES Module Syntax\"></a>ES Module Syntax</h2><p><code>ES æ¨¡å—è¯­æ³•</code><br>A file can declare a main export via export default:<br><code>ä¸€ä¸ªæ–‡ä»¶å¯ä»¥é€šè¿‡ export default å£°æ˜ä¸€ä¸ªä¸»è¦çš„å¯¼å‡ºï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; @filename: hello.ts\nexport default function helloWorld() &#123;\n  console.log(&quot;Hello, world!&quot;);\n&#125;</code></pre>\n\n<p>This is then imported via:<br><code>è¿™æ˜¯é€šè¿‡ä»¥ä¸‹æ–¹å¼å¯¼å…¥çš„ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import helloWorld from &quot;.&#x2F;hello.js&quot;;\nhelloWorld();</code></pre>\n\n<p>In addition to the default export, you can have more than one export of variables and functions via the export by omitting default:<br><code>é™¤äº†é»˜è®¤å¯¼å‡ºï¼Œä½ è¿˜å¯ä»¥æœ‰å¤šä¸ªå¯¼å‡ºçš„å˜é‡å’Œå‡½æ•°ï¼Œé€šè¿‡å°† default å»æ‰ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; @filename: maths.ts\nexport var pi &#x3D; 3.14;\nexport let squareTwo &#x3D; 1.41;\nexport const phi &#x3D; 1.61;\n\nexport class RandomNumberGenerator &#123;&#125;\n\nexport function absolute(num: number) &#123;\nif (num &lt; 0) return num \\* -1;\n  return num;\n&#125;</code></pre>\n\n<p>These can be used in another file via the import syntax:<br><code>è¿™äº›å¯ä»¥åœ¨å¦ä¸€ä¸ªæ–‡ä»¶ä¸­é€šè¿‡å¯¼å…¥è¯­æ³•ä½¿ç”¨ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; pi, phi, absolute &#125; from &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(pi);\nconst absPhi &#x3D; absolute(phi);\n\n&#x2F;&#x2F; const absPhi: number;</code></pre>\n\n<h2 id=\"Additional-Import-Syntax\"><a href=\"#Additional-Import-Syntax\" class=\"headerlink\" title=\"Additional Import Syntax\"></a>Additional Import Syntax</h2><p><code>é™„åŠ å¯¼å…¥è¯­æ³•</code><br>An import can be renamed using a format like import {old as new}:<br><code>ä¸€ä¸ªå¯¼å…¥å¯ä»¥é€šè¿‡è¿™æ ·çš„æ ¼å¼ï¼šimport &#123;old as new&#125;ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; pi as Ï€ &#125; from &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(Ï€);\n\n&#x2F;&#x2F; (alias) var Ï€: number\n&#x2F;&#x2F; import Ï€</code></pre>\n\n<p>You can mix and match the above syntax into a single import:<br><code>ä½ å¯ä»¥æ··åˆè¿™äº›è¯­æ³•åˆ°ä¸€ä¸ªå•ç‹¬çš„å¯¼å…¥ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; @filename: maths.ts\nexport const pi &#x3D; 3.14;\nexport default class RandomNumberGenerator &#123;&#125;\n\n&#x2F;&#x2F; @filename: app.ts\nimport RandomNumberGenerator, &#123; pi as Ï€ &#125; from &quot;.&#x2F;maths.js&quot;;\n\nRandomNumberGenerator;\n\n&#x2F;&#x2F; (alias) class RandomNumberGenerator\n&#x2F;&#x2F; import RandomNumberGenerator\n\nconsole.log(Ï€);\n\n&#x2F;&#x2F; (alias) const Ï€: 3.14\n&#x2F;&#x2F; import Ï€</code></pre>\n\n<p>You can take all of the exported objects and put them into a single namespace using * as name:<br><code>ä½ å¯ä»¥å°†æ‰€æœ‰å¯¼å‡ºçš„å¯¹è±¡æ”¾åˆ°ä¸€ä¸ªå•ç‹¬çš„å‘½åç©ºé—´ï¼Œä½¿ç”¨ \\* as nameï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; @filename: app.ts\nimport \\* as math from &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(math.pi);\nconst positivePhi &#x3D; math.absolute(math.phi);\n\n&#x2F;&#x2F; const positivePhi: number</code></pre>\n\n<p>You can import a file and not include any variables into your current module via import \"./file\":<br><code>ä½ å¯ä»¥é€šè¿‡ import &quot;./file&quot; å¯¼å…¥ä¸€ä¸ªæ–‡ä»¶ï¼Œå¹¶ä¸”ä¸åŒ…å«ä»»ä½•å˜é‡åˆ°å½“å‰æ¨¡å—ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; @filename: app.ts\nimport &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(&quot;3.14&quot;);</code></pre>\n\n<p>In this case, the import does nothing. However, all of the code in maths.ts was evaluated, which could trigger side-effects which affect other objects.<br><code>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¼å…¥å¹¶æ²¡æœ‰ä»€ä¹ˆäº‹æƒ…ã€‚ä½†æ˜¯ï¼Œmaths.ts ä¸­çš„æ‰€æœ‰ä»£ç éƒ½ä¼šè¢«è¯„ä¼°ï¼Œè¿™å¯èƒ½ä¼šè§¦å‘å…¶ä»–å¯¹è±¡çš„å‰¯ä½œç”¨ã€‚</code></p>\n<h2 id=\"TypeScript-Specific-ES-Module-Syntax\"><a href=\"#TypeScript-Specific-ES-Module-Syntax\" class=\"headerlink\" title=\"TypeScript Specific ES Module Syntax\"></a>TypeScript Specific ES Module Syntax</h2><p><code>TypeScript ç‰¹å®šçš„ ES æ¨¡å—è¯­æ³•</code><br>Types can be exported and imported using the same syntax as JavaScript values:<br><code>ç±»å‹å¯ä»¥ä½¿ç”¨ç›¸åŒçš„è¯­æ³•æ¥å¯¼å‡ºå’Œå¯¼å…¥ JavaScript å€¼ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; @filename: animal.ts\nexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;\n\nexport interface Dog &#123;\n  breeds: string[];\n  yearOfBirth: number;\n&#125;\n\n&#x2F;&#x2F; @filename: app.ts\nimport &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;\ntype Animals &#x3D; Cat | Dog;</code></pre>\n\n<p>TypeScript has extended the import syntax with two concepts for declaring an import of a type:<br><code>TypeScript å·²ç»æ‰©å±•äº†å¯¼å…¥ç±»å‹çš„è¯­æ³•ï¼Œå®ƒæœ‰ä¸¤ä¸ªæ¦‚å¿µæ¥å£°æ˜å¯¼å…¥ç±»å‹ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import type\n&#x2F;&#x2F; Which is an import statement which can only import types:\n&#x2F;&#x2F; åªèƒ½å¯¼å…¥ç±»å‹çš„å¯¼å…¥è¯­å¥ï¼š\n&#x2F;&#x2F; @filename: animal.ts\nexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;\n&#x2F;&#x2F; &#39;createCatName&#39; cannot be used as a value because it was imported using &#39;import type&#39;.\n&#x2F;&#x2F; &#39;createCatName&#39; ä¸èƒ½è¢«ç”¨ä½œå€¼ï¼Œå› ä¸ºå®ƒè¢«å¯¼å…¥ä½¿ç”¨äº† &#39;import type&#39;ã€‚\nexport type Dog &#x3D; &#123; breeds: string[]; yearOfBirth: number &#125;;\nexport const createCatName &#x3D; () &#x3D;&gt; &quot;fluffy&quot;;\n\n&#x2F;&#x2F; @filename: valid.ts\nimport type &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;\nexport type Animals &#x3D; Cat | Dog;\n\n&#x2F;&#x2F; @filename: app.ts\nimport type &#123; createCatName &#125; from &quot;.&#x2F;animal.js&quot;;\nconst name &#x3D; createCatName();</code></pre>\n\n<p>Inline type imports<br><code>å†…è”ç±»å‹å¯¼å…¥</code></p>\n<p>TypeScript 4.5 also allows for individual imports to be prefixed with type to indicate that the imported reference is a type:<br><code>TypeScript 4.5 å¯ä»¥ä½¿ç”¨ type å‰ç¼€æ¥å£°æ˜å¯¼å…¥çš„å¼•ç”¨æ˜¯ä¸€ä¸ªç±»å‹ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&#x2F;&#x2F; @filename: app.ts\nimport &#123; createCatName, type Cat, type Dog &#125; from &quot;.&#x2F;animal.js&quot;;\n\nexport type Animals &#x3D; Cat | Dog;\nconst name &#x3D; createCatName();</code></pre>\n\n<p>Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.<br><code>è¿™äº›åŒæ—¶å…è®¸ä¸€ä¸ªé TypeScript ç¼–è¯‘å™¨ï¼Œå¦‚ Babelã€swc æˆ– esbuild çŸ¥é“å“ªäº›å¯¼å…¥å¯ä»¥å®‰å…¨åœ°ç§»é™¤ã€‚</code></p>\n<h2 id=\"ES-Module-Syntax-with-CommonJS-Behavior\"><a href=\"#ES-Module-Syntax-with-CommonJS-Behavior\" class=\"headerlink\" title=\"ES Module Syntax with CommonJS Behavior\"></a>ES Module Syntax with CommonJS Behavior</h2><p><code>ES æ¨¡å—è¯­æ³•ä¸ CommonJS è¡Œä¸º</code><br>TypeScript has ES Module syntax which directly correlates to a CommonJS and AMD require. Imports using ES Module are for most cases the same as the require from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:<br><code>TypeScript æœ‰ ES æ¨¡å—è¯­æ³•ï¼Œå®ƒç›¸å¯¹äº CommonJS å’Œ AMD requireã€‚ä½¿ç”¨ ES Module çš„å¯¼å…¥æ˜¯ä¸ºäº†å¤§å¤šæ•°æƒ…å†µä¸‹ä¸è¿™äº›ç¯å¢ƒçš„ require ä¸€è‡´ï¼Œä½†è¿™ç§è¯­æ³•ç¡®ä¿äº†ä½ çš„ TypeScript æ–‡ä»¶ä¸ CommonJS è¾“å‡ºæœ‰ä¸€ä¸ª 1 åˆ° 1 çš„åŒ¹é…ã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import fs &#x3D; require(&quot;fs&quot;);\nconst code &#x3D; fs.readFileSync(&quot;hello.ts&quot;, &quot;utf8&quot;);</code></pre>\n\n<p>You can learn more about this syntax in the modules reference page.<br><code>ä½ å¯ä»¥åœ¨æ¨¡å—å‚è€ƒé¡µé¢äº†è§£æ›´å¤šå…³äºè¿™ç§è¯­æ³•ã€‚</code></p>\n<h2 id=\"CommonJS-Syntax\"><a href=\"#CommonJS-Syntax\" class=\"headerlink\" title=\"CommonJS Syntax\"></a>CommonJS Syntax</h2><p><code>CommonJS è¯­æ³•</code></p>\n<p>CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.<br><code>CommonJS æ˜¯ npm ä¸Šå¤§å¤šæ•°æ¨¡å—çš„æ ¼å¼ã€‚å³ä½¿ä½ æ­£åœ¨ä½¿ç”¨ä¸Šé¢çš„ ES æ¨¡å—è¯­æ³•ï¼Œä¹Ÿä¼šæœ‰ä¸€ä¸ªç®€å•çš„äº†è§£ CommonJS è¯­æ³•çš„æ–¹å¼å¸®åŠ©ä½ è°ƒè¯•æ›´å®¹æ˜“ã€‚</code></p>\n<h2 id=\"Exporting\"><a href=\"#Exporting\" class=\"headerlink\" title=\"Exporting\"></a>Exporting</h2><p><code>å¯¼å‡º</code></p>\n<p>Identifiers are exported via setting the exports property on a global called module.<br><code>æ ‡è¯†ç¬¦é€šè¿‡è®¾ç½® module.exports å±æ€§æ¥å¯¼å‡ºã€‚</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">function absolute(num: number) &#123;\n    if (num &lt; 0) return num \\* -1;\n    return num;\n&#125;\n\nmodule.exports &#x3D; &#123;\n  pi: 3.14,\n  squareTwo: 1.41,\n  phi: 1.61,\n  absolute,\n&#125;;</code></pre>\n\n<p>Then these files can be imported via a require statement:<br><code>ç„¶åï¼Œè¿™äº›æ–‡ä»¶å¯ä»¥é€šè¿‡ require è¯­å¥æ¥å¯¼å…¥ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const maths &#x3D; require(&quot;maths&quot;);\nmaths.pi;\n\n&#x2F;&#x2F; any;</code></pre>\n\n<p>Or you can simplify a bit using the destructuring feature in JavaScript:<br><code>æˆ–è€…ï¼Œä½ å¯ä»¥ä½¿ç”¨ JavaScript çš„è§£æ„ç‰¹æ€§æ¥ç®€åŒ–ä¸€äº›ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">const &#123; squareTwo &#125; &#x3D; require(&quot;maths&quot;);\nsquareTwo;\n\n&#x2F;&#x2F; const squareTwo: any;</code></pre>\n\n<h2 id=\"CommonJS-and-ES-Modules-interop\"><a href=\"#CommonJS-and-ES-Modules-interop\" class=\"headerlink\" title=\"CommonJS and ES Modules interop\"></a>CommonJS and ES Modules interop</h2><p><code>CommonJS å’Œ ES æ¨¡å—çš„äº’æ“ä½œ</code></p>\n<p>There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop.<br><code>åœ¨ CommonJS å’Œ ES æ¨¡å—ä¹‹é—´å­˜åœ¨ä¸åŒ¹é…çš„ç‰¹æ€§ï¼Œå…³äºé»˜è®¤å¯¼å…¥å’Œæ¨¡å—å‘½åç©ºé—´å¯¹è±¡å¯¼å…¥çš„åŒºåˆ«ã€‚TypeScript æœ‰ä¸€ä¸ªç¼–è¯‘å™¨æ ‡å¿—æ¥å‡å°‘ CommonJS å’Œ ES æ¨¡å—ä¹‹é—´çš„æ‘©æ“¦ã€‚</code></p>\n<h2 id=\"TypeScriptâ€™s-Module-Resolution-Options\"><a href=\"#TypeScriptâ€™s-Module-Resolution-Options\" class=\"headerlink\" title=\"TypeScriptâ€™s Module Resolution Options\"></a>TypeScriptâ€™s Module Resolution Options</h2><p><code>TypeScript çš„æ¨¡å—è§£æé€‰é¡¹</code></p>\n<p>Module resolution is the process of taking a string from the import or require statement, and determining what file that string refers to.<br><code>æ¨¡å—è§£ææ˜¯ä» import æˆ– require è¯­å¥ä¸­è·å–å­—ç¬¦ä¸²ï¼Œå¹¶ç¡®å®šè¯¥å­—ç¬¦ä¸²æ‰€å¼•ç”¨çš„æ–‡ä»¶ã€‚</code></p>\n<p>TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option module is not commonjs, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for .ts and .d.ts.<br><code>TypeScript åŒ…å«ä¸¤ç§è§£æç­–ç•¥ï¼šç»å…¸å’Œ Nodeã€‚ç»å…¸ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå½“ç¼–è¯‘å™¨é€‰é¡¹ module ä¸æ˜¯ commonjs æ—¶ï¼ŒåŒ…å«äº†å‘åå…¼å®¹æ€§ã€‚Node ç­–ç•¥é‡å¤äº† Node.js åœ¨ CommonJS æ¨¡å¼ä¸‹å·¥ä½œçš„æ–¹å¼ï¼Œå¹¶ä¸”æ·»åŠ äº† .ts å’Œ .d.ts çš„æ£€æŸ¥ã€‚</code><br>There are many TSConfig flags which influence the module strategy within TypeScript: moduleResolution, baseUrl, paths, rootDirs.<br><code>åœ¨ TypeScript ä¸­ï¼Œæœ‰å¾ˆå¤š TSConfig æ ‡å¿—å½±å“æ¨¡å—ç­–ç•¥ï¼šmoduleResolutionã€baseUrlã€pathsã€rootDirsã€‚</code><br>For the full details on how these strategies work, you can consult the Module Resolution.<br><code>å…³äºå¦‚ä½•å·¥ä½œçš„è¯¦ç»†ä¿¡æ¯ï¼Œä½ å¯ä»¥å‚è€ƒæ¨¡å—è§£æã€‚</code></p>\n<h2 id=\"TypeScriptâ€™s-Module-Output-Options\"><a href=\"#TypeScriptâ€™s-Module-Output-Options\" class=\"headerlink\" title=\"TypeScriptâ€™s Module Output Options\"></a>TypeScriptâ€™s Module Output Options</h2><p><code>TypeScript çš„æ¨¡å—è¾“å‡ºé€‰é¡¹</code><br>There are two options which affect the emitted JavaScript output:<br><code>æœ‰ä¸¤ä¸ªå½±å“è¾“å‡ºçš„ JavaScript çš„é€‰é¡¹ï¼š</code></p>\n<ul>\n<li>target which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact<br><code>target æ˜¯æŒ‡å®šå“ªäº› JS ç‰¹æ€§è¢«ä¸‹æ¸¸ï¼ˆè½¬æ¢ä¸ºåœ¨æ—§çš„ JavaScript è¿è¡Œæ—¶è¿è¡Œï¼‰ï¼Œå“ªäº›è¢«ä¿ç•™ã€‚</code></li>\n<li>module which determines what code is used for modules to interact with each other<br><code>module æ˜¯æŒ‡å®šå“ªäº›ä»£ç ç”¨äºæ¨¡å—äº¤äº’ã€‚</code></li>\n</ul>\n<p>Which target you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.<br><code>å“ªä¸ªç›®æ ‡ä½ ä½¿ç”¨æ˜¯ç”±ä½ æœŸæœ›åœ¨ JavaScript è¿è¡Œæ—¶è¿è¡Œ TypeScript ä»£ç çš„åŠŸèƒ½å†³å®šçš„ã€‚è¿™å¯èƒ½æ˜¯ï¼šæœ€æ—§çš„ web æµè§ˆå™¨ï¼Œæœ€ä½ç‰ˆæœ¬çš„ Node.jsï¼Œæˆ–è€…æ¥è‡ªä½ è¿è¡Œæ—¶çš„å”¯ä¸€çº¦æŸ - ä¾‹å¦‚ï¼ŒElectronã€‚</code><br>All communication between modules happens via a module loader, the compiler option module determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.<br><code>æ¨¡å—ä¹‹é—´çš„é€šä¿¡éƒ½æ˜¯é€šè¿‡æ¨¡å—åŠ è½½å™¨æ¥å®Œæˆçš„ï¼Œç¼–è¯‘å™¨é€‰é¡¹ module æ˜¯æŒ‡å®šå“ªä¸ªè¢«ä½¿ç”¨ã€‚åœ¨è¿è¡Œæ—¶ï¼Œæ¨¡å—åŠ è½½å™¨è´Ÿè´£å®šä½å¹¶æ‰§è¡Œæ‰€æœ‰æ¨¡å—çš„ä¾èµ–ä¹‹å‰æ‰§è¡Œå®ƒã€‚</code><br>For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for module:<br><code>ä¾‹å¦‚ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªä½¿ç”¨ ES Modules è¯­æ³•çš„ TypeScript æ–‡ä»¶ï¼Œå±•ç¤ºäº†ä¸€äº›æ¨¡å—çš„é€‰é¡¹ï¼š</code></p>\n<pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;\n\nexport const twoPi &#x3D; valueOfPi _ 2;</code></pre>\n\n<h2 id=\"ES2020\"><a href=\"#ES2020\" class=\"headerlink\" title=\"ES2020\"></a>ES2020</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">import &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;\nexport const twoPi &#x3D; valueOfPi _ 2;</code></pre>\n\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">&quot;use strict&quot;;\nObject.defineProperty(exports, &quot;\\_\\_esModule&quot;, &#123; value: true &#125;);\nexports.twoPi &#x3D; void 0;\nconst constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);\nexports.twoPi &#x3D; constants_js_1.valueOfPi \\* 2;</code></pre>\n\n<h2 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h2><pre class=\"line-numbers language-ts\" data-language=\"ts\"><code class=\"language-ts\">(function (factory) &#123;\n  if (typeof module &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof module.exports &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;\n    var v &#x3D; factory(require, exports);\n    if (v !&#x3D;&#x3D; undefined) module.exports &#x3D; v;\n  &#125;\n  else if (typeof define &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; define.amd) &#123;\n    define([&quot;require&quot;, &quot;exports&quot;, &quot;.&#x2F;constants.js&quot;], factory);\n  &#125;\n&#125;)(function (require, exports) &#123;\n  &quot;use strict&quot;;\n  Object.defineProperty(exports, &quot;\\_\\_esModule&quot;, &#123; value: true &#125;);\n  exports.twoPi &#x3D; void 0;\n  const constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);\n  exports.twoPi &#x3D; constants_js_1.valueOfPi \\* 2;\n&#125;);\n</code></pre>\n\n<p>Note that ES2020 is effectively the same as the original index.ts.<br><code>ES2020 æ˜¯ä¸€æ ·çš„äºåŸå§‹ index.tsã€‚</code><br>You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module.<br><code>ä½ å¯ä»¥çœ‹åˆ°æ‰€æœ‰å¯ç”¨çš„é€‰é¡¹å’Œä»–ä»¬çš„è¾“å‡º JavaScript ä»£ç çš„æ ·å­åœ¨ module çš„ TSConfig å‚è€ƒä¸­ã€‚</code></p>\n<h2 id=\"TypeScript-namespaces\"><a href=\"#TypeScript-namespaces\" class=\"headerlink\" title=\"TypeScript namespaces\"></a>TypeScript namespaces</h2><p><code>TypeScript å‘½åç©ºé—´</code><br>TypeScript has its own module format called namespaces which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScriptâ€™s direction. You can learn more about namespaces in the namespaces reference page.<br><code>TypeScript æœ‰è‡ªå·±çš„æ¨¡å—æ ¼å¼å‘½åç©ºé—´ï¼Œå®ƒæ˜¯å…ˆæœŸçš„ ES Modules æ ‡å‡†ã€‚è¿™ç§è¯­æ³•å…·æœ‰å¾ˆå¤šæœ‰ç”¨çš„åŠŸèƒ½åˆ›å»ºå¤æ‚çš„å®šä¹‰æ–‡ä»¶ï¼Œä»ç„¶åœ¨ DefinitelyTyped ä¸­æœ‰æ´»è·ƒä½¿ç”¨ã€‚å°½ç®¡ä¸è¢«å¼ƒç”¨ï¼Œå¤§å¤šæ•°çš„åŠŸèƒ½åœ¨å‘½åç©ºé—´ä¸­å­˜åœ¨äº ES Modulesï¼Œæˆ‘ä»¬å»ºè®®ä½ ä½¿ç”¨å®ƒä¸ JavaScript çš„æ–¹å‘å¯¹é½ã€‚ä½ å¯ä»¥åœ¨å‘½åç©ºé—´å‚è€ƒé¡µé¢ä¸Šäº†è§£æ›´å¤šå…³äºå‘½åç©ºé—´ã€‚</code></p>\n","text":"JavaScript has a long history of different ways to handle modularizing code. TypeScript having been around since 2012, has implemented suppo...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"typescript","slug":"typescript","count":9,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":9,"path":"api/tags/typescript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-JavaScript-Modules-are-Defined\"><span class=\"toc-text\">How JavaScript Modules are Defined</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Non-modules\"><span class=\"toc-text\">Non-modules</span></a></li></ol>","author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"10.Typescript å·¥å…·ç±»å‹","uid":"effcb24e596d83e2df5140f38213b656","slug":"2022-06-09ts-util-type","date":"2022-06-08T14:49:28.000Z","updated":"2022-06-11T01:01:52.080Z","comments":true,"path":"api/articles/2022-06-09ts-util-type.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.Typescriptæä¾›äº†ä¸€äº›å¸®...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"typescript","slug":"typescript","count":9,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":9,"path":"api/tags/typescript.json"}],"author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"8.Typescriptæ‰‹å†Œ ç±»","uid":"14464d0b7865c234ecdc15847ed605ff","slug":"2022-06-08ts-classes","date":"2022-06-08T06:21:19.000Z","updated":"2022-06-11T01:01:52.078Z","comments":true,"path":"api/articles/2022-06-08ts-classes.json","keywords":null,"cover":"https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208","text":"Background Reading:èƒŒæ™¯é˜…è¯» Classes (MDN) TypeScript offers full support for the class keyword introduced in ES2015.typescript æ”¯æŒ ES2015 çš„ class...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"41 mins."},"categories":[{"name":"typescript","slug":"typescript","count":9,"path":"api/categories/typescript.json"}],"tags":[{"name":"typescript","slug":"typescript","count":9,"path":"api/tags/typescript.json"}],"author":{"name":"é™ˆæµ·é¾™","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"éœ€è¦å°±å­¦å‘—ï¼Œå¤šå¤§ç‚¹äº‹ğŸ˜‚","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}