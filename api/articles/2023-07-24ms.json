{"title":"ms","uid":"257b42f1eacc94add6ea6e75adb48c69","slug":"2023-07-24ms","date":"2023-07-24T07:41:13.000Z","updated":"2023-08-13T03:13:20.175Z","comments":true,"path":"api/articles/2023-07-24ms.json","keywords":null,"cover":null,"content":"<h2 id=\"var-let-const-区别\"><a href=\"#var-let-const-区别\" class=\"headerlink\" title=\"var let const 区别\"></a>var let const 区别</h2><ol>\n<li>使用 var 具有全局<code>或</code>函数作用域，存在变量提升，可以重复声明，变量值可修改。</li>\n<li>使用 let 具有块级作用域，不存在变量提升，不能重复声明，变量值可修改。</li>\n<li>使用 const 具有块级作用域，不存在变量提升，不能重复声明，变量值不可修改（但对象和数组的属性或元素可修改）</li>\n</ol>\n<h2 id=\"js-作用域\"><a href=\"#js-作用域\" class=\"headerlink\" title=\"js 作用域\"></a>js 作用域</h2><p>JavaScript 的作用域定义了在代码中声明的变量和函数在何处可见或可访问。作用域可以分为全局作用域和局部作用域（也称为块级作用域）。</p>\n<ol>\n<li><p>全局作用域：</p>\n<ul>\n<li>在整个程序中都可访问的作用域。</li>\n<li>可以在任何地方声明的变量和函数都具有全局作用域。</li>\n<li>使用<code>var</code>关键字声明的变量默认具有全局作用域。</li>\n<li>在浏览器环境中，全局作用域可以表示为<code>window</code>对象的属性。</li>\n</ul>\n</li>\n<li><p>局部作用域（块级作用域）：</p>\n<ul>\n<li>限定在特定代码块内部的作用域。</li>\n<li>代码块可以是函数、<code>if</code>语句、<code>for</code>循环等。</li>\n<li>在 ES6 之前，JavaScript 没有块级作用域，只有函数作用域。</li>\n<li>使用<code>let</code>和<code>const</code>关键字声明的变量在对应的块级作用域内可见。</li>\n<li>块级作用域可避免变量污染和冲突问题，提供更好的代码组织和可读性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>作用域链</strong>是在 JavaScript 中实现作用域的一种机制，它表示变量和函数的查找路径。在访问一个变量时，JavaScript 引擎会先从当前作用域开始查找，如果找不到则向上级作用域查找，直到找到该变量或到达全局作用域为止。</p>\n<p><strong>函数作用域和全局作用域</strong>：函数内部创建的变量（使用<code>var</code>或<code>function</code>关键字声明）只在函数内部可见，而全局作用域中声明的变量对整个程序都可见。</p>\n<p><strong>块级作用域</strong>：<code>let</code>和<code>const</code>关键字声明的变量在声明的块级作用域内可见，超出该作用域则不可见。</p>\n<p>JavaScript 作用域的理解对于正确声明和使用变量和函数非常重要，同时还有助于避免变量名冲突和提高代码的可维护性。</p>\n<h2 id=\"js-事件循环\"><a href=\"#js-事件循环\" class=\"headerlink\" title=\"js 事件循环\"></a>js 事件循环</h2><p>JavaScript 的事件循环是一种机制，用于处理异步操作和事件处理。它是 JavaScript 单线程执行模型的关键部分。事件循环确保代码按照预期的顺序执行，并处理异步操作的结果。</p>\n<p>事件循环包括以下几个主要组件：</p>\n<ol>\n<li><p>调用栈（Call Stack）：调用栈是一个跟踪函数调用的数据结构，它保存了当前执行的上下文和函数调用的顺序。当调用一个函数时，它会被添加到调用栈中，当函数执行完成后，它会从栈中弹出。</p>\n</li>\n<li><p>任务队列（Task Queue）：任务队列用于存储待执行的任务。当事件发生时，例如点击事件、定时器到期等，相关的回调函数被推送到任务队列中。</p>\n</li>\n<li><p>事件循环（Event Loop）：事件循环负责将任务队列中的任务逐个放入调用栈中执行，并确保代码按照正确的顺序执行。它会持续监听调用栈和任务队列的状态，一旦调用栈为空，就会检查任务队列是否有待执行的任务，如果有，则将下一个任务推送到调用栈中执行。</p>\n</li>\n<li><p>微任务队列（Microtask Queue）：微任务队列用于存储微任务，微任务是一种更高优先级的任务。在每个事件循环的末尾，在执行下一个任务之前，会检查微任务队列并将其中的任务全部执行完毕。</p>\n</li>\n</ol>\n<p>事件循环的执行顺序如下：</p>\n<ul>\n<li>当代码开始执行时，先执行同步任务，将函数调用压入调用栈中执行。</li>\n<li>当遇到异步操作时，如<code>setTimeout</code>、<code>Promise</code>的<code>then</code>方法等，相关的回调函数将被推送到任务队列中。</li>\n<li>当调用栈为空时，事件循环会从任务队列中取出一个任务，将其推送到调用栈中执行。</li>\n<li>如果任务是微任务，则会先执行微任务队列中的所有微任务。</li>\n<li>循环以上步骤，直到调用栈和任务队列都为空。</li>\n</ul>\n<p>值得注意的是，事件循环是在单线程上运行的，但通过异步操作和事件处理，可以在保持主线程空闲的同时执行并发的任务。</p>\n<h2 id=\"nodejs-事件循环\"><a href=\"#nodejs-事件循环\" class=\"headerlink\" title=\"nodejs 事件循环\"></a>nodejs 事件循环</h2><p>Node.js 的事件循环与浏览器中的事件循环有些不同，因为 Node.js 是基于服务器端的 JavaScript 运行环境。</p>\n<p>Node.js 的事件循环基于 libuv 库，采用了单线程的事件驱动模型。以下是 Node.js 事件循环的主要组件：</p>\n<ol>\n<li><p>调用栈（Call Stack）：与浏览器中的调用栈类似，调用栈跟踪函数的执行顺序。</p>\n</li>\n<li><p>事件循环（Event Loop）：Node.js 的事件循环是基于 libuv 的事件循环机制。它负责监听和处理事件，包括 I&#x2F;O 操作、定时器和回调函数等。事件循环会持续运行，并按照固定顺序处理不同的任务队列。</p>\n</li>\n<li><p>任务队列：</p>\n<ul>\n<li>定时器队列（Timers Queue）：存放定时器相关的回调函数。</li>\n<li>I&#x2F;O 队列（I&#x2F;O Queue）：存放 I&#x2F;O 操作的回调函数。</li>\n<li>空闲观察者队列（Idle Observer Queue）：存放一些由 idle 观察者（Idle Observer）注册的回调函数，这些回调函数会在事件循环空闲时执行。</li>\n<li>非空闲观察者队列（Non-Idle Observer Queue）：存放一些由非 idle 观察者（Non-Idle Observer）注册的回调函数，这些回调函数会在事件循环的各个阶段执行。</li>\n<li>微任务队列（Microtask Queue）：存放微任务，会在每个事件循环的末尾执行。</li>\n</ul>\n</li>\n</ol>\n<p>Node.js 事件循环的执行顺序如下：</p>\n<ol>\n<li><p>执行当前调用栈中的同步代码。</p>\n</li>\n<li><p>检查微任务队列，如果有微任务，则依次执行直到队列为空。</p>\n</li>\n<li><p>执行完微任务后，检查定时器队列，如果有到期的定时器，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完定时器队列后，检查 I&#x2F;O 队列，如果有 I&#x2F;O 操作的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完 I&#x2F;O 队列后，检查空闲观察者队列，如果有空闲观察者注册的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完空闲观察者队列后，检查非空闲观察者队列，如果有非空闲观察者注册的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>重复以上步骤，直到调用栈和所有任务队列都为空。</p>\n</li>\n</ol>\n<p>需要注意的是，Node.js 的事件循环是单线程的，但通过异步 I&#x2F;O 操作和事件驱动机制，可以实现高效的并发处理。</p>\n<h2 id=\"前端跨域\"><a href=\"#前端跨域\" class=\"headerlink\" title=\"前端跨域\"></a>前端跨域</h2><p>跨域是指在浏览器中运行的脚本使用不同源（域、协议、端口）的资源时产生的安全限制。在前端开发中，常常会遇到跨域的问题。以下是一些常见的前端跨域解决方案：</p>\n<ol>\n<li><p>JSONP（JSON with Padding）：JSONP 利用<code>&lt;script&gt;</code>标签可以跨域加载资源的特性，通过在请求 URL 中添加一个回调函数名称，服务器返回调用该回调函数的脚本代码。这种方法只适用于 GET 请求。</p>\n</li>\n<li><p>CORS（Cross-Origin Resource Sharing）：CORS 是一种现代浏览器支持的安全跨域解决方案。服务器通过设置响应头信息来告知浏览器是否允许跨域访问资源，并指定允许的域、方法和头部等。前端使用 CORS 时，需要发送一个跨域请求，浏览器会先发送一个 OPTIONS 请求进行预检（preflight），之后才发送实际的请求。</p>\n</li>\n<li><p>代理服务器：在开发环境中，可以使用代理服务器将前端的请求转发到后端的接口中。通过配置代理服务器，前端可以直接访问同源的接口，由代理服务器负责将请求转发到不同源的接口。</p>\n</li>\n<li><p>iframe 嵌套：通过在页面中使用<code>&lt;iframe&gt;</code>标签，将要跨域访问的资源嵌套在 iframe 中。由于同源策略限制只适用于浏览器上下文，通过 iframe 嵌套可以实现跨域访问。</p>\n</li>\n<li><p>WebSocket：WebSocket 是一种全双工的通信协议，它不受同源策略的限制，可以在浏览器与服务器之间实现跨域通信。</p>\n</li>\n</ol>\n<p>需要注意的是，以上解决方案都有各自的适用场景和限制条件。在使用跨域解决方案时，需要根据具体情况选择合适的方法，并确保安全性和可靠性。另外，一些高级特性（如 Cookie、LocalStorage 等）在跨域请求中可能受到限制，需要特别注意处理。</p>\n<h2 id=\"http1-http2-http3\"><a href=\"#http1-http2-http3\" class=\"headerlink\" title=\"http1,http2,http3\"></a>http1,http2,http3</h2><ul>\n<li>HTTP&#x2F;1.0：第一个版本，无状态协议，每次请求需建立新连接，不支持持久连接和请求头压缩。</li>\n<li>HTTP&#x2F;1.1：广泛使用的版本，引入持久连接、请求头压缩和管道化功能，增加缓存控制等。</li>\n<li>HTTP&#x2F;2：基于 SPDY 协议，采用二进制传输格式，支持多路复用，使用头部压缩和服务器推送等。</li>\n<li>HTTP&#x2F;3：最新版本，基于 QUIC 协议，提供更低的连接延迟，改善稳定性和拥塞控制问题。</li>\n</ul>\n<h2 id=\"TCP（传输控制协议）和-UDP（用户数据报协议）\"><a href=\"#TCP（传输控制协议）和-UDP（用户数据报协议）\" class=\"headerlink\" title=\"TCP（传输控制协议）和 UDP（用户数据报协议）\"></a>TCP（传输控制协议）和 UDP（用户数据报协议）</h2><p>TCP（传输控制协议）和 UDP（用户数据报协议）是互联网协议簇中的两个常见传输层协议。它们在数据传输方式、特点和适用场景上有所不同。</p>\n<p><strong>TCP</strong>：</p>\n<ul>\n<li>是一种面向连接的协议，提供可靠的数据传输。</li>\n<li>使用三次握手建立连接，并进行拥塞控制、流量控制和丢包重传等机制。</li>\n<li>采用数据流的方式传输数据，保证数据的有序性和可靠性。</li>\n<li>适用于需要可靠传输、顺序传输和重要性较高的应用场景，如网页浏览、电子邮件、文件传输等。</li>\n</ul>\n<p><strong>UDP</strong>：</p>\n<ul>\n<li>是一种无连接的协议，提供尽力而为的数据传输。</li>\n<li>没有建立连接的过程，直接发送数据包，不保证数据到达的可靠性。</li>\n<li>不提供拥塞控制和流量控制等机制，传输速度较快。</li>\n<li>适用于实时性要求较高、数据量较小、对实时性要求较高的应用场景，如音频&#x2F;视频流传输、在线游戏等。</li>\n</ul>\n<p>在选择 TCP 还是 UDP 时，需要根据应用的需求来决定。如果需要可靠的数据传输和有序性，则选择 TCP；如果对实时性要求较高，可以接受少量数据丢失，则选择 UDP。有些应用还会采取混合使用的方式，根据不同情况选择合适的传输协议。</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p><strong>Flex</strong> 是一种用于构建用户界面的开源软件开发工具集。以下是关于 Flex 的一些常见问题和答案：</p>\n<p><strong>1. 什么是 Flex？</strong><br>Flex（Flexbox）是 CSS3 引入的一种布局模型，用于进行页面元素的排列和定位。它使开发者能够更轻松地创建自适应和响应式的网页布局。</p>\n<p><strong>2. Flex 和传统的 CSS 布局有什么区别？</strong><br>传统的 CSS 布局使用盒模型和浮动来实现页面布局，而 Flex 使用一个基于弹性盒子的模型。Flex 更加简洁、灵活，并且可以轻松地对齐和分配空间。</p>\n<p><strong>3. 如何使用 Flex 进行页面布局？</strong><br>使用 Flex 进行页面布局需要以下步骤：</p>\n<ul>\n<li>将父容器的 <code>display</code> 属性设置为 <code>flex</code> 或 <code>inline-flex</code>，以启用 Flex 布局。</li>\n<li>使用 <code>flex-direction</code> 属性来定义主轴的方向（水平或垂直）。</li>\n<li>使用 <code>justify-content</code> 属性来对齐子项目在主轴上的位置。</li>\n<li>使用 <code>align-items</code> 和 <code>align-content</code> 属性来对齐子项目在交叉轴上的位置。</li>\n<li>使用 <code>flex-wrap</code> 属性来定义子项目在主轴上是否换行。</li>\n</ul>\n<p><strong>4. Flex 布局有哪些主要的属性？</strong><br>一些常用的 Flex 属性包括：</p>\n<ul>\n<li><code>flex-direction</code>：定义主轴的方向。</li>\n<li><code>justify-content</code>：定义子项目在主轴上的对齐方式。</li>\n<li><code>align-items</code>：定义子项目在交叉轴上的对齐方式。</li>\n<li><code>align-content</code>：定义多行子项目在交叉轴上的对齐方式。</li>\n<li><code>flex-wrap</code>：定义子项目在主轴上是否换行。</li>\n<li><code>flex-grow</code>：定义子项目的放大比例。</li>\n<li><code>flex-shrink</code>：定义子项目的缩小比例。</li>\n<li><code>flex-basis</code>：定义子项目在主轴上的初始大小。</li>\n</ul>\n<p><strong>5. Flex 布局有哪些优势？</strong><br>使用 Flex 布局有以下优势：</p>\n<ul>\n<li>简化和灵活性：使用少量的 CSS 代码就可以实现复杂的布局。</li>\n<li>自适应和响应式：Flex 布局使得网页可以动态适应不同屏幕尺寸和设备。</li>\n<li>对齐和分配空间：Flex 布局提供了对齐和分配空间的灵活控制。</li>\n<li>减少浮动和清除浮动的需求：Flex 布局减少了使用浮动的需要，简化了布局结构。</li>\n</ul>\n<p>这些问题和答案可以帮助您在面试时了解 Flex 布局以及它的使用和优势。</p>\n<h2 id=\"flex-缩写值\"><a href=\"#flex-缩写值\" class=\"headerlink\" title=\"flex 缩写值\"></a>flex 缩写值</h2><p>在 Flex 布局中，有一个常用的属性是 <code>flex</code>，它是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 这三个属性的缩写形式。</p>\n<p><code>flex</code> 属性的语法是 <code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;</code>，每个值都有特定的含义：</p>\n<ul>\n<li><code>&lt;flex-grow&gt;</code> 定义了弹性盒子在空间分配时的放大比例，默认为 0。这个值决定了剩余空间在主轴上分配给弹性盒子的比例。</li>\n<li><code>&lt;flex-shrink&gt;</code> 定义了弹性盒子在空间不足时的缩小比例，默认为 1。这个值决定了当弹性盒子太大以适应父容器时，它应该缩小的比例。</li>\n<li><code>&lt;flex-basis&gt;</code> 定义了弹性盒子的初始主轴大小，默认为 <code>auto</code>，即由弹性盒子的内容决定。</li>\n</ul>\n<p>这些属性可以使用单独的值进行指定，也可以使用缩写形式来同时指定三个值。具体使用哪个形式取决于您的需求。一些常用的缩写值示例包括：</p>\n<ul>\n<li><code>flex: 1;</code>：相当于 <code>flex: 1 1 0%;</code>，使弹性盒子在所有方向上等分剩余空间。</li>\n<li><code>flex: 2 1 20%;</code>：指定弹性盒子的放大比例为 2，缩小比例为 1，初始大小为 20%。</li>\n<li><code>flex: 0 0 auto;</code>：禁用弹性盒子的放大和缩小能力，并根据内容自动调整大小。</li>\n</ul>\n<p>通过使用 <code>flex</code> 属性的缩写值，可以更简洁方便地控制弹性盒子在 Flex 布局中的行为。</p>\n<h2 id=\"为什么有时候需要用-width-0-来解决-flex-问题\"><a href=\"#为什么有时候需要用-width-0-来解决-flex-问题\" class=\"headerlink\" title=\"为什么有时候需要用 width:0 来解决 flex 问题\"></a>为什么有时候需要用 width:0 来解决 flex 问题</h2><p>在某些情况下，使用 <code>width: 0;</code> 可以帮助解决 Flex 布局中的一些问题。这通常涉及到在弹性盒子中处理超出父容器宽度的内容或布局方面的需求。</p>\n<p>一种常见的情况是，当弹性盒子中的内容超过了父容器的宽度时，弹性盒子默认会根据内容自动扩展自身的宽度以适应内容，导致弹性盒子超出父容器。如果我们希望内容在父容器内部进行溢出或隐藏，而不影响弹性盒子的宽度，可以将 <code>width</code> 属性设置为 0：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.flex-container &#123;\n  display: flex;\n&#125;\n\n.flex-item &#123;\n  width: 0;\n  flex-grow: 1;\n  &#x2F;* 其他样式... *&#x2F;\n&#125;</code></pre>\n\n<p>通过将 <code>width</code> 设置为 0，我们告诉弹性盒子不要根据内容扩展自己的宽度，而是使用 <code>flex-grow</code> 的值来决定弹性盒子在剩余空间中的分配比例。这样，即使内容超出父容器宽度，弹性盒子仍会保持在父容器的范围内，而不会撑开整个布局。</p>\n<p>另一种情况是在网格布局中，当使用 Flex 布局的项目作为网格容器的子项时，有时候需要将子项的宽度设置为 0 以实现某些特定的布局需求。这是因为网格布局有自己的尺寸调整规则，通过将子项的宽度设置为 0，可以让网格布局的调整规则更好地生效。</p>\n<p>总而言之，<code>width: 0;</code> 的使用可以帮助我们解决一些与 Flex 布局相关的布局问题，特别是在控制内容溢出和在网格布局中使用 Flex 子项时。</p>\n<h2 id=\"typescript-extends-有哪些使用场景\"><a href=\"#typescript-extends-有哪些使用场景\" class=\"headerlink\" title=\"typescript extends 有哪些使用场景\"></a>typescript extends 有哪些使用场景</h2><p>在 TypeScript 中，<code>extends</code> 关键字可以应用于多种场景，包括：</p>\n<ol>\n<li>类的继承：<code>extends</code> 用于创建类的继承关系，子类可以继承父类的属性和方法，并可以覆盖或扩展它们。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  eat() &#123;\n    console.log(&#39;Animal is eating&#39;);\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  bark() &#123;\n    console.log(&#39;Dog is barking&#39;);\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog();\ndog.eat(); &#x2F;&#x2F; 输出: Animal is eating\ndog.bark(); &#x2F;&#x2F; 输出: Dog is barking</code></pre>\n\n<ol start=\"2\">\n<li>接口的继承：<code>extends</code> 用于创建接口之间的继承关系，一个接口可以继承一个或多个其他接口，从而继承它们的成员。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Shape &#123;\n  draw(): void;\n&#125;\n\ninterface ColorfulShape extends Shape &#123;\n  color: string;\n&#125;\n\nclass Circle implements ColorfulShape &#123;\n  color: string &#x3D; &#39;red&#39;;\n  draw() &#123;\n    console.log(&#96;Drawing a $&#123;this.color&#125; circle&#96;);\n  &#125;\n&#125;\n\nconst circle &#x3D; new Circle();\ncircle.draw(); &#x2F;&#x2F; 输出: Drawing a red circle</code></pre>\n\n<ol start=\"3\">\n<li>约束泛型类型参数：<code>extends</code> 用于约束泛型类型参数，通过指定泛型类型参数必须满足某个条件或继承特定接口，可以对类型参数进行更精确的约束。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Lengthwise &#123;\n  length: number;\n&#125;\n\nfunction printLength&lt;T extends Lengthwise&gt;(arg: T) &#123;\n  console.log(arg.length);\n&#125;\n\nprintLength(&#39;Hello&#39;); &#x2F;&#x2F; 输出: 5\nprintLength([1, 2, 3]); &#x2F;&#x2F; 输出: 3</code></pre>\n\n<ol start=\"4\">\n<li>确实在 TypeScript 中可以使用 <code>extends</code> 关键字来创建交叉类型，而不是 <code>&amp;</code> 运算符。</li>\n</ol>\n<p>下面是正确的例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Foo &#x3D; &#123; a: number &#125;;\ntype Bar &#x3D; &#123; b: string &#125;;\n\ntype FooBar &#x3D; Foo extends Bar ? Foo : Bar;\n\nconst fooBar: FooBar &#x3D; &#123;\n  a: 1,\n  b: &#39;Hello&#39;,\n&#125;;</code></pre>\n\n<p>在这个例子中，我们使用了 <code>extends</code> 关键字来创建交叉类型 <code>FooBar</code>。通过判断 <code>Foo</code> 是否可以赋值给 <code>Bar</code>，如果是的话则选择 <code>Foo</code> 作为交叉类型，否则选择 <code>Bar</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type FooBar &#x3D; Foo extends Bar ? Foo : Bar;</code></pre>\n\n<p>这样，<code>FooBar</code> 类型将会是 <code>Foo</code> 和 <code>Bar</code> 的交叉类型，具有 <code>Foo</code> 和 <code>Bar</code> 类型的所有成员。</p>\n<p>对于交叉类型的创建，使用 <code>extends</code> 关键字是一种常见的模式。对于继承关系的创建，我们仍然可以使用 <code>extends</code> 关键字，但它主要用于类与类之间、接口与接口之间以及类与接口之间的继承关系。对于创建交叉类型，我们使用 <code>extends</code> 关键字进行条件判断来实现。</p>\n<p>这些是 <code>extends</code> 在 TypeScript 中的几种常见使用场景。它们提供了更多的灵活性和类型安全性，帮助开发者编写更健壮和可维护的代码。</p>\n<h2 id=\"Node-是怎么部署的-pm2-守护进程的原理\"><a href=\"#Node-是怎么部署的-pm2-守护进程的原理\" class=\"headerlink\" title=\"Node 是怎么部署的? pm2 守护进程的原理?\"></a>Node 是怎么部署的? pm2 守护进程的原理?</h2><p>Node.js 应用的部署可以通过不同的方式进行，但最常见的方式是使用进程管理工具，例如 <code>pm2</code>。以下是一般的 Node.js 应用部署步骤以及 <code>pm2</code> 守护进程的原理：</p>\n<ol>\n<li><p><strong>部署步骤</strong>：</p>\n<ul>\n<li>安装 Node.js：在服务器上安装 Node.js，确保版本与应用要求一致。</li>\n<li>代码部署：将应用代码部署到服务器上，可以通过 <code>git</code> 等版本控制工具来管理代码。</li>\n<li>安装依赖：在应用目录中运行 <code>npm install</code> 或 <code>yarn</code> 安装所需的依赖。</li>\n<li>启动应用：通常使用进程管理工具来启动应用，确保应用在后台持续运行。</li>\n</ul>\n</li>\n<li><p><strong>pm2 守护进程的原理</strong>：</p>\n<ul>\n<li><code>pm2</code> 是一个进程管理工具，它可以启动、停止、重启 Node.js 进程，并提供日志管理、负载均衡等功能。</li>\n<li>当使用 <code>pm2</code> 启动应用时，<code>pm2</code> 会创建一个 Node.js 主进程，同时根据配置创建多个子进程。</li>\n<li>每个子进程独立运行一个 Node.js 应用实例，可以充分利用服务器的多核处理器。</li>\n<li><code>pm2</code> 会监控这些子进程的运行状态，如果某个子进程崩溃或出现异常，<code>pm2</code> 会自动重新启动它，确保应用的稳定运行。</li>\n<li><code>pm2</code> 提供了日志记录、性能监控、负载均衡等功能，可以方便地管理和监控应用。</li>\n</ul>\n</li>\n</ol>\n<p>通过 <code>pm2</code> 部署 Node.js 应用可以提高应用的稳定性和可靠性，同时方便管理和监控应用的运行状态。这使得 Node.js 应用的部署变得更加简单和可控。</p>\n<h2 id=\"Node-开启子进程的方法有哪些\"><a href=\"#Node-开启子进程的方法有哪些\" class=\"headerlink\" title=\"Node 开启子进程的方法有哪些?\"></a>Node 开启子进程的方法有哪些?</h2><h2 id=\"进程间如何通信\"><a href=\"#进程间如何通信\" class=\"headerlink\" title=\"进程间如何通信?\"></a>进程间如何通信?</h2><p>在 Node.js 中，进程间通信（Inter-Process Communication，IPC）可以通过以下几种方式实现：</p>\n<ol>\n<li><p><strong>子进程模块</strong>：Node.js 提供了 <code>child_process</code> 模块，可以创建和控制子进程。你可以使用 <code>spawn</code>、<code>fork</code>、<code>exec</code> 等方法来启动子进程，并通过标准输入输出流来进行通信。</p>\n</li>\n<li><p><strong>共享文件</strong>：进程可以通过读写共享文件来进行通信。这种方式适用于需要持久化数据或信息传递的场景。但要注意同步和并发控制。</p>\n</li>\n<li><p><strong>Socket</strong>：进程可以通过网络套接字（Socket）进行通信。可以使用 TCP 或 UDP 协议来实现进程间通信，例如通过 WebSocket、Socket.io 等方式。</p>\n</li>\n<li><p><strong>进程间消息传递（IPC）</strong>：Node.js 的 <code>process</code> 对象支持通过事件和信号进行进程间通信。你可以通过 <code>process.send()</code> 方法发送消息，以及监听 <code>message</code> 事件来接收消息。这种方式通常在 Node.js 的集群或子进程间通信中使用。</p>\n</li>\n<li><p><strong>共享内存</strong>：Node.js 并没有提供直接的共享内存机制，但你可以借助第三方模块如 <code>node-ipc</code> 来实现共享内存的进程间通信。</p>\n</li>\n</ol>\n<p>选择合适的进程间通信方式取决于你的需求。如果需要在 Node.js 应用内部实现进程间通信，通常可以使用 <code>child_process</code> 模块或进程间消息传递。如果需要跨网络通信，可以使用 Socket 或共享文件。</p>\n<h2 id=\"各个进程通信优缺点\"><a href=\"#各个进程通信优缺点\" class=\"headerlink\" title=\"各个进程通信优缺点\"></a>各个进程通信优缺点</h2><p>不同的进程间通信方式具有各自的优点和缺点，具体选择取决于你的应用场景和需求。以下是一些常见的进程间通信方式以及它们的优缺点：</p>\n<ol>\n<li><p><strong>子进程模块</strong>：</p>\n<ul>\n<li>优点：使用简单，适合于并发执行多个任务，每个任务在独立的子进程中执行。</li>\n<li>缺点：进程之间资源隔离较强，通信开销相对较大，无法共享内存。</li>\n</ul>\n</li>\n<li><p><strong>共享文件</strong>：</p>\n<ul>\n<li>优点：适合持久化数据或共享信息，易于实现，支持多种数据格式。</li>\n<li>缺点：不适用于高频通信,需要进行文件的读写操作，可能会引入并发和同步问题，</li>\n</ul>\n</li>\n<li><p><strong>共享内存</strong>：</p>\n<ul>\n<li>优点：高性能，多个进程可以共享同一块内存，适用于需要频繁交换大量数据的场景。</li>\n<li>缺点：实现较复杂，需要注意并发和同步问题，可能会导致资源竞争。</li>\n</ul>\n</li>\n<li><p><strong>Socket（TCP&#x2F;UDP）</strong>：</p>\n<ul>\n<li>优点：支持跨网络通信，可以在不同的机器上进行通信，性能相对较好。</li>\n<li>缺点：相对复杂，需要处理网络连接，通信开销较大，可能需要考虑安全性。</li>\n</ul>\n</li>\n<li><p><strong>进程间消息传递（IPC）</strong>：</p>\n<ul>\n<li>优点：内部通信简单，适用于 Node.js 集群或子进程间通信。</li>\n<li>缺点：只适用于 Node.js 进程内部，无法跨进程或跨网络通信。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，不同的进程间通信方式有不同的适用场景。在选择时需要综合考虑通信频率、数据大小、安全性要求、跨网络通信需求等因素。</p>\n<h2 id=\"useReducer\"><a href=\"#useReducer\" class=\"headerlink\" title=\"useReducer\"></a>useReducer</h2><p><code>useReducer</code> 是 React 提供的一个钩子函数，用于管理组件内部的状态，它可以替代 <code>useState</code> 来处理更复杂的状态逻辑。<code>useReducer</code> 接收一个 reducer 函数和一个初始状态，并返回当前的状态和一个 dispatch 函数，通过 dispatch 函数可以触发状态的更新。</p>\n<p><code>useReducer</code> 的使用方式类似于 Redux 中的 reducer，它可以帮助我们将状态的更新逻辑抽象出来，使组件逻辑更清晰。</p>\n<p>使用示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import React, &#123; useReducer &#125; from &#39;react&#39;;\n\n&#x2F;&#x2F; reducer函数接收当前的状态和action，并返回新的状态\nconst reducer &#x3D; (state, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;increment&#39;:\n      return &#123; count: state.count + 1 &#125;;\n    case &#39;decrement&#39;:\n      return &#123; count: state.count - 1 &#125;;\n    default:\n      return state;\n  &#125;\n&#125;;\n\nfunction Counter() &#123;\n  &#x2F;&#x2F; 使用useReducer定义状态和dispatch函数\n  const [state, dispatch] &#x3D; useReducer(reducer, &#123; count: 0 &#125;);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: &#123;state.count&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;Increment&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;Decrement&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nexport default Counter;</code></pre>\n\n<p>在这个例子中，<code>useReducer</code> 接收了 <code>reducer</code> 函数和初始状态 <code>&#123; count: 0 &#125;</code>，并返回了当前的状态 <code>state</code> 和一个 <code>dispatch</code> 函数，我们可以通过调用 <code>dispatch</code> 函数来触发状态的更新，更新的逻辑由 <code>reducer</code> 函数来处理。</p>\n<h2 id=\"组件外侧-let-a-1-组件内侧点击事件更改-a，渲染的-a-会发生改变吗？如果-let-a-放在组件内部，有什么变化吗？和-useState-有什么区别？\"><a href=\"#组件外侧-let-a-1-组件内侧点击事件更改-a，渲染的-a-会发生改变吗？如果-let-a-放在组件内部，有什么变化吗？和-useState-有什么区别？\" class=\"headerlink\" title=\"组件外侧 let a 1 组件内侧点击事件更改 a，渲染的 a 会发生改变吗？如果 let a 放在组件内部，有什么变化吗？和 useState 有什么区别？\"></a>组件外侧 let a 1 组件内侧点击事件更改 a，渲染的 a 会发生改变吗？如果 let a 放在组件内部，有什么变化吗？和 useState 有什么区别？</h2><p>根据你的描述，首先我们来理清一下情况：</p>\n<ol>\n<li><p>**组件外部定义的 <code>let a = 1</code>**：</p>\n<ul>\n<li>这个变量 <code>a</code> 在组件内部是不可见的，无法直接访问到。</li>\n<li>组件内部的点击事件无法直接修改外部定义的 <code>a</code>，因此渲染的 <code>a</code> 不会发生改变。</li>\n</ul>\n</li>\n<li><p>**组件内部定义的 <code>let a = 1</code>**：</p>\n<ul>\n<li>这个变量 <code>a</code> 局限于组件内部作用域，只能在组件内部访问。</li>\n<li>组件内部的点击事件可以修改内部定义的 <code>a</code>，但这个修改不会影响外部。</li>\n</ul>\n</li>\n<li><p>**使用 <code>useState</code>**：</p>\n<ul>\n<li><code>useState</code> 是 React 的钩子函数，用于在函数组件中创建状态。</li>\n<li><code>useState</code> 定义的状态变量在组件内部可见，并且每次状态发生变化时，组件会重新渲染以反映新的状态。</li>\n<li><code>useState</code> 在函数组件中代替了类组件中的 <code>this.state</code> 和 <code>this.setState</code>。</li>\n</ul>\n</li>\n</ol>\n<p>区别和总结：</p>\n<ul>\n<li>使用 <code>let a = 1</code> 外部定义变量的方式，变量的作用范围受限，无法与组件的渲染状态相互关联。</li>\n<li>在组件内部定义 <code>let a = 1</code>，这个变量的作用范围仅在组件内部，不会影响外部。</li>\n<li>使用 <code>useState</code> 定义状态变量，状态的修改会触发组件的重新渲染，因此与组件的渲染状态有关，是一种更适合 React 函数组件的状态管理方式。</li>\n</ul>\n<p>总之，如果想要在 React 组件中实现状态的动态渲染，使用 <code>useState</code> 是更为合适的选择。</p>\n","text":"var let const 区别 使用 var 具有全局或函数作用域，存在变量提升，可以重复声明，变量值可修改。 使用 let 具有块级作用域，不存在变量提升，不能重复声明，变量值可修改。 使用 const 具有块级作用域，不存在变量提升，不能重复声明，变量值不可修改（但对象和数...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">var let const 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">js 作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">js 事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">nodejs 事件循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">前端跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#http1-http2-http3\"><span class=\"toc-text\">http1,http2,http3</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%EF%BC%88%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%89%E5%92%8C-UDP%EF%BC%88%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%89\"><span class=\"toc-text\">TCP（传输控制协议）和 UDP（用户数据报协议）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flex\"><span class=\"toc-text\">flex</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#flex-%E7%BC%A9%E5%86%99%E5%80%BC\"><span class=\"toc-text\">flex 缩写值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E7%94%A8-width-0-%E6%9D%A5%E8%A7%A3%E5%86%B3-flex-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">为什么有时候需要用 width:0 来解决 flex 问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typescript-extends-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">typescript extends 有哪些使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Node-%E6%98%AF%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2%E7%9A%84-pm2-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Node 是怎么部署的? pm2 守护进程的原理?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Node-%E5%BC%80%E5%90%AF%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">Node 开启子进程的方法有哪些?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程间如何通信?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%84%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">各个进程通信优缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useReducer\"><span class=\"toc-text\">useReducer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%A4%96%E4%BE%A7-let-a-1-%E7%BB%84%E4%BB%B6%E5%86%85%E4%BE%A7%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E6%9B%B4%E6%94%B9-a%EF%BC%8C%E6%B8%B2%E6%9F%93%E7%9A%84-a-%E4%BC%9A%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C-let-a-%E6%94%BE%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F%E5%92%8C-useState-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">组件外侧 let a 1 组件内侧点击事件更改 a，渲染的 a 会发生改变吗？如果 let a 放在组件内部，有什么变化吗？和 useState 有什么区别？</span></a></li></ol>","author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"桌面级水印","uid":"cfd47c3df01979bd39595f08e8ed4f50","slug":"2023-08-04watermark","date":"2023-08-04T05:41:23.000Z","updated":"2023-08-04T06:01:56.601Z","comments":true,"path":"api/articles/2023-08-04watermark.json","keywords":null,"cover":null,"text":"背景企业级桌面打码，避免员工截图乱发 激活 windows 跳转 “设置”以激活 windows，这个水印的实现原理激活 Windows 操作系统时，有时会出现桌面右下角的水印提示，告诉用户要激活 Windows，并提供跳转链接到“设置”页面以进行激活。这个水印的实现原理是通过操...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"桌面端","slug":"桌面端","count":1,"path":"api/categories/桌面端.json"}],"tags":[{"name":"桌面端","slug":"桌面端","count":1,"path":"api/tags/桌面端.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"ModuleNotFoundError No module named 'requests'","uid":"228098f2136c9f5bb0f3c96d9e151e02","slug":"2023-07-24py","date":"2023-07-24T02:23:45.000Z","updated":"2023-07-31T06:42:49.730Z","comments":true,"path":"api/articles/2023-07-24py.json","keywords":null,"cover":[],"text":"requests 无法引入# 安装命令 python3 -m pip install requests 安装日志👑 ~&#x2F;Desktop&#x2F;lnx&#x2F;py-5 $ python3 -m pip install requests Collecting req...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"author":{"name":"十三","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>多学一点，多想一点，多做一点</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}