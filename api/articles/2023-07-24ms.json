{"title":"ms","uid":"257b42f1eacc94add6ea6e75adb48c69","slug":"2023-07-24ms","date":"2023-07-24T07:41:13.000Z","updated":"2023-07-31T06:42:49.729Z","comments":true,"path":"api/articles/2023-07-24ms.json","keywords":null,"cover":null,"content":"<h2 id=\"var-let-const-区别\"><a href=\"#var-let-const-区别\" class=\"headerlink\" title=\"var let const 区别\"></a>var let const 区别</h2><ol>\n<li>使用 var 具有全局<code>或</code>函数作用域，存在变量提升，可以重复声明，变量值可修改。</li>\n<li>使用 let 具有块级作用域，不存在变量提升，不能重复声明，变量值可修改。</li>\n<li>使用 const 具有块级作用域，不存在变量提升，不能重复声明，变量值不可修改（但对象和数组的属性或元素可修改）<!-- 1. `版本`： var 是 es6 之前， const、let es6 之后，</li>\n<li><code>分类</code>： 在 es6 之前只有<code>全局作用域</code>和<code>函数作用域</code>， const、let 块级作用域</li>\n<li><code>提升</code>：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前使用会报错</li>\n<li><code>重复</code>：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值</li>\n<li><code>存储</code>：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li>\n<li><code>默认</code>： 默认情况下是 var 声明</li>\n<li><code>函数</code>：函数声明提升优先于 var</li>\n</ol>\n<p>补充说明： const 和不变性。</p>\n<ol>\n<li>const 创建一个变量名绑定，该绑定在创建后不能重新分配。</li>\n<li>const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。</li>\n</ol>\n<p><a href=\"/#/post/2022-09-19qa\" target=\"_blank\" >见：2022-09-19qa</a> –&gt;</p>\n<h2 id=\"js-作用域\"><a href=\"#js-作用域\" class=\"headerlink\" title=\"js 作用域\"></a>js 作用域</h2><p>JavaScript 的作用域定义了在代码中声明的变量和函数在何处可见或可访问。作用域可以分为全局作用域和局部作用域（也称为块级作用域）。</p>\n<ol>\n<li><p>全局作用域：</p>\n<ul>\n<li>在整个程序中都可访问的作用域。</li>\n<li>可以在任何地方声明的变量和函数都具有全局作用域。</li>\n<li>使用<code>var</code>关键字声明的变量默认具有全局作用域。</li>\n<li>在浏览器环境中，全局作用域可以表示为<code>window</code>对象的属性。</li>\n</ul>\n</li>\n<li><p>局部作用域（块级作用域）：</p>\n<ul>\n<li>限定在特定代码块内部的作用域。</li>\n<li>代码块可以是函数、<code>if</code>语句、<code>for</code>循环等。</li>\n<li>在 ES6 之前，JavaScript 没有块级作用域，只有函数作用域。</li>\n<li>使用<code>let</code>和<code>const</code>关键字声明的变量在对应的块级作用域内可见。</li>\n<li>块级作用域可避免变量污染和冲突问题，提供更好的代码组织和可读性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>作用域链</strong>是在 JavaScript 中实现作用域的一种机制，它表示变量和函数的查找路径。在访问一个变量时，JavaScript 引擎会先从当前作用域开始查找，如果找不到则向上级作用域查找，直到找到该变量或到达全局作用域为止。</p>\n<p><strong>函数作用域和全局作用域</strong>：函数内部创建的变量（使用<code>var</code>或<code>function</code>关键字声明）只在函数内部可见，而全局作用域中声明的变量对整个程序都可见。</p>\n<p><strong>块级作用域</strong>：<code>let</code>和<code>const</code>关键字声明的变量在声明的块级作用域内可见，超出该作用域则不可见。</p>\n<p>JavaScript 作用域的理解对于正确声明和使用变量和函数非常重要，同时还有助于避免变量名冲突和提高代码的可维护性。</p>\n<h2 id=\"js-事件循环\"><a href=\"#js-事件循环\" class=\"headerlink\" title=\"js 事件循环\"></a>js 事件循环</h2><p>JavaScript 的事件循环是一种机制，用于处理异步操作和事件处理。它是 JavaScript 单线程执行模型的关键部分。事件循环确保代码按照预期的顺序执行，并处理异步操作的结果。</p>\n<p>事件循环包括以下几个主要组件：</p>\n<ol>\n<li><p>调用栈（Call Stack）：调用栈是一个跟踪函数调用的数据结构，它保存了当前执行的上下文和函数调用的顺序。当调用一个函数时，它会被添加到调用栈中，当函数执行完成后，它会从栈中弹出。</p>\n</li>\n<li><p>任务队列（Task Queue）：任务队列用于存储待执行的任务。当事件发生时，例如点击事件、定时器到期等，相关的回调函数被推送到任务队列中。</p>\n</li>\n<li><p>事件循环（Event Loop）：事件循环负责将任务队列中的任务逐个放入调用栈中执行，并确保代码按照正确的顺序执行。它会持续监听调用栈和任务队列的状态，一旦调用栈为空，就会检查任务队列是否有待执行的任务，如果有，则将下一个任务推送到调用栈中执行。</p>\n</li>\n<li><p>微任务队列（Microtask Queue）：微任务队列用于存储微任务，微任务是一种更高优先级的任务。在每个事件循环的末尾，在执行下一个任务之前，会检查微任务队列并将其中的任务全部执行完毕。</p>\n</li>\n</ol>\n<p>事件循环的执行顺序如下：</p>\n<ul>\n<li>当代码开始执行时，先执行同步任务，将函数调用压入调用栈中执行。</li>\n<li>当遇到异步操作时，如<code>setTimeout</code>、<code>Promise</code>的<code>then</code>方法等，相关的回调函数将被推送到任务队列中。</li>\n<li>当调用栈为空时，事件循环会从任务队列中取出一个任务，将其推送到调用栈中执行。</li>\n<li>如果任务是微任务，则会先执行微任务队列中的所有微任务。</li>\n<li>循环以上步骤，直到调用栈和任务队列都为空。</li>\n</ul>\n<p>值得注意的是，事件循环是在单线程上运行的，但通过异步操作和事件处理，可以在保持主线程空闲的同时执行并发的任务。</p>\n<h2 id=\"nodejs-事件循环\"><a href=\"#nodejs-事件循环\" class=\"headerlink\" title=\"nodejs 事件循环\"></a>nodejs 事件循环</h2><p>Node.js 的事件循环与浏览器中的事件循环有些不同，因为 Node.js 是基于服务器端的 JavaScript 运行环境。</p>\n<p>Node.js 的事件循环基于 libuv 库，采用了单线程的事件驱动模型。以下是 Node.js 事件循环的主要组件：</p>\n<ol>\n<li><p>调用栈（Call Stack）：与浏览器中的调用栈类似，调用栈跟踪函数的执行顺序。</p>\n</li>\n<li><p>事件循环（Event Loop）：Node.js 的事件循环是基于 libuv 的事件循环机制。它负责监听和处理事件，包括 I&#x2F;O 操作、定时器和回调函数等。事件循环会持续运行，并按照固定顺序处理不同的任务队列。</p>\n</li>\n<li><p>任务队列：</p>\n<ul>\n<li>定时器队列（Timers Queue）：存放定时器相关的回调函数。</li>\n<li>I&#x2F;O 队列（I&#x2F;O Queue）：存放 I&#x2F;O 操作的回调函数。</li>\n<li>空闲观察者队列（Idle Observer Queue）：存放一些由 idle 观察者（Idle Observer）注册的回调函数，这些回调函数会在事件循环空闲时执行。</li>\n<li>非空闲观察者队列（Non-Idle Observer Queue）：存放一些由非 idle 观察者（Non-Idle Observer）注册的回调函数，这些回调函数会在事件循环的各个阶段执行。</li>\n<li>微任务队列（Microtask Queue）：存放微任务，会在每个事件循环的末尾执行。</li>\n</ul>\n</li>\n</ol>\n<p>Node.js 事件循环的执行顺序如下：</p>\n<ol>\n<li><p>执行当前调用栈中的同步代码。</p>\n</li>\n<li><p>检查微任务队列，如果有微任务，则依次执行直到队列为空。</p>\n</li>\n<li><p>执行完微任务后，检查定时器队列，如果有到期的定时器，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完定时器队列后，检查 I&#x2F;O 队列，如果有 I&#x2F;O 操作的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完 I&#x2F;O 队列后，检查空闲观察者队列，如果有空闲观察者注册的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>执行完空闲观察者队列后，检查非空闲观察者队列，如果有非空闲观察者注册的回调函数准备就绪，则将相关的回调函数推送到调用栈。</p>\n</li>\n<li><p>重复以上步骤，直到调用栈和所有任务队列都为空。</p>\n</li>\n</ol>\n<p>需要注意的是，Node.js 的事件循环是单线程的，但通过异步 I&#x2F;O 操作和事件驱动机制，可以实现高效的并发处理。</p>\n<h2 id=\"前端跨域\"><a href=\"#前端跨域\" class=\"headerlink\" title=\"前端跨域\"></a>前端跨域</h2><p>跨域是指在浏览器中运行的脚本使用不同源（域、协议、端口）的资源时产生的安全限制。在前端开发中，常常会遇到跨域的问题。以下是一些常见的前端跨域解决方案：</p>\n<ol>\n<li><p>JSONP（JSON with Padding）：JSONP 利用<code>&lt;script&gt;</code>标签可以跨域加载资源的特性，通过在请求 URL 中添加一个回调函数名称，服务器返回调用该回调函数的脚本代码。这种方法只适用于 GET 请求。</p>\n</li>\n<li><p>CORS（Cross-Origin Resource Sharing）：CORS 是一种现代浏览器支持的安全跨域解决方案。服务器通过设置响应头信息来告知浏览器是否允许跨域访问资源，并指定允许的域、方法和头部等。前端使用 CORS 时，需要发送一个跨域请求，浏览器会先发送一个 OPTIONS 请求进行预检（preflight），之后才发送实际的请求。</p>\n</li>\n<li><p>代理服务器：在开发环境中，可以使用代理服务器将前端的请求转发到后端的接口中。通过配置代理服务器，前端可以直接访问同源的接口，由代理服务器负责将请求转发到不同源的接口。</p>\n</li>\n<li><p>iframe 嵌套：通过在页面中使用<code>&lt;iframe&gt;</code>标签，将要跨域访问的资源嵌套在 iframe 中。由于同源策略限制只适用于浏览器上下文，通过 iframe 嵌套可以实现跨域访问。</p>\n</li>\n<li><p>WebSocket：WebSocket 是一种全双工的通信协议，它不受同源策略的限制，可以在浏览器与服务器之间实现跨域通信。</p>\n</li>\n</ol>\n<p>需要注意的是，以上解决方案都有各自的适用场景和限制条件。在使用跨域解决方案时，需要根据具体情况选择合适的方法，并确保安全性和可靠性。另外，一些高级特性（如 Cookie、LocalStorage 等）在跨域请求中可能受到限制，需要特别注意处理。</p>\n<h2 id=\"http1-http2-http3\"><a href=\"#http1-http2-http3\" class=\"headerlink\" title=\"http1,http2,http3\"></a>http1,http2,http3</h2><ul>\n<li>HTTP&#x2F;1.0：第一个版本，无状态协议，每次请求需建立新连接，不支持持久连接和请求头压缩。</li>\n<li>HTTP&#x2F;1.1：广泛使用的版本，引入持久连接、请求头压缩和管道化功能，增加缓存控制等。</li>\n<li>HTTP&#x2F;2：基于 SPDY 协议，采用二进制传输格式，支持多路复用，使用头部压缩和服务器推送等。</li>\n<li>HTTP&#x2F;3：最新版本，基于 QUIC 协议，提供更低的连接延迟，改善稳定性和拥塞控制问题。</li>\n</ul>\n<h2 id=\"TCP（传输控制协议）和-UDP（用户数据报协议）\"><a href=\"#TCP（传输控制协议）和-UDP（用户数据报协议）\" class=\"headerlink\" title=\"TCP（传输控制协议）和 UDP（用户数据报协议）\"></a>TCP（传输控制协议）和 UDP（用户数据报协议）</h2><p>TCP（传输控制协议）和 UDP（用户数据报协议）是互联网协议簇中的两个常见传输层协议。它们在数据传输方式、特点和适用场景上有所不同。</p>\n<p><strong>TCP</strong>：</p>\n<ul>\n<li>是一种面向连接的协议，提供可靠的数据传输。</li>\n<li>使用三次握手建立连接，并进行拥塞控制、流量控制和丢包重传等机制。</li>\n<li>采用数据流的方式传输数据，保证数据的有序性和可靠性。</li>\n<li>适用于需要可靠传输、顺序传输和重要性较高的应用场景，如网页浏览、电子邮件、文件传输等。</li>\n</ul>\n<p><strong>UDP</strong>：</p>\n<ul>\n<li>是一种无连接的协议，提供尽力而为的数据传输。</li>\n<li>没有建立连接的过程，直接发送数据包，不保证数据到达的可靠性。</li>\n<li>不提供拥塞控制和流量控制等机制，传输速度较快。</li>\n<li>适用于实时性要求较高、数据量较小、对实时性要求较高的应用场景，如音频&#x2F;视频流传输、在线游戏等。</li>\n</ul>\n<p>在选择 TCP 还是 UDP 时，需要根据应用的需求来决定。如果需要可靠的数据传输和有序性，则选择 TCP；如果对实时性要求较高，可以接受少量数据丢失，则选择 UDP。有些应用还会采取混合使用的方式，根据不同情况选择合适的传输协议。</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p><strong>Flex</strong> 是一种用于构建用户界面的开源软件开发工具集。以下是关于 Flex 的一些常见问题和答案：</p>\n<p><strong>1. 什么是 Flex？</strong><br>Flex（Flexbox）是 CSS3 引入的一种布局模型，用于进行页面元素的排列和定位。它使开发者能够更轻松地创建自适应和响应式的网页布局。</p>\n<p><strong>2. Flex 和传统的 CSS 布局有什么区别？</strong><br>传统的 CSS 布局使用盒模型和浮动来实现页面布局，而 Flex 使用一个基于弹性盒子的模型。Flex 更加简洁、灵活，并且可以轻松地对齐和分配空间。</p>\n<p><strong>3. 如何使用 Flex 进行页面布局？</strong><br>使用 Flex 进行页面布局需要以下步骤：</p>\n<ul>\n<li>将父容器的 <code>display</code> 属性设置为 <code>flex</code> 或 <code>inline-flex</code>，以启用 Flex 布局。</li>\n<li>使用 <code>flex-direction</code> 属性来定义主轴的方向（水平或垂直）。</li>\n<li>使用 <code>justify-content</code> 属性来对齐子项目在主轴上的位置。</li>\n<li>使用 <code>align-items</code> 和 <code>align-content</code> 属性来对齐子项目在交叉轴上的位置。</li>\n<li>使用 <code>flex-wrap</code> 属性来定义子项目在主轴上是否换行。</li>\n</ul>\n<p><strong>4. Flex 布局有哪些主要的属性？</strong><br>一些常用的 Flex 属性包括：</p>\n<ul>\n<li><code>flex-direction</code>：定义主轴的方向。</li>\n<li><code>justify-content</code>：定义子项目在主轴上的对齐方式。</li>\n<li><code>align-items</code>：定义子项目在交叉轴上的对齐方式。</li>\n<li><code>align-content</code>：定义多行子项目在交叉轴上的对齐方式。</li>\n<li><code>flex-wrap</code>：定义子项目在主轴上是否换行。</li>\n<li><code>flex-grow</code>：定义子项目的放大比例。</li>\n<li><code>flex-shrink</code>：定义子项目的缩小比例。</li>\n<li><code>flex-basis</code>：定义子项目在主轴上的初始大小。</li>\n</ul>\n<p><strong>5. Flex 布局有哪些优势？</strong><br>使用 Flex 布局有以下优势：</p>\n<ul>\n<li>简化和灵活性：使用少量的 CSS 代码就可以实现复杂的布局。</li>\n<li>自适应和响应式：Flex 布局使得网页可以动态适应不同屏幕尺寸和设备。</li>\n<li>对齐和分配空间：Flex 布局提供了对齐和分配空间的灵活控制。</li>\n<li>减少浮动和清除浮动的需求：Flex 布局减少了使用浮动的需要，简化了布局结构。</li>\n</ul>\n<p>这些问题和答案可以帮助您在面试时了解 Flex 布局以及它的使用和优势。</p>\n<h2 id=\"flex-缩写值\"><a href=\"#flex-缩写值\" class=\"headerlink\" title=\"flex 缩写值\"></a>flex 缩写值</h2><p>在 Flex 布局中，有一个常用的属性是 <code>flex</code>，它是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 这三个属性的缩写形式。</p>\n<p><code>flex</code> 属性的语法是 <code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;</code>，每个值都有特定的含义：</p>\n<ul>\n<li><code>&lt;flex-grow&gt;</code> 定义了弹性盒子在空间分配时的放大比例，默认为 0。这个值决定了剩余空间在主轴上分配给弹性盒子的比例。</li>\n<li><code>&lt;flex-shrink&gt;</code> 定义了弹性盒子在空间不足时的缩小比例，默认为 1。这个值决定了当弹性盒子太大以适应父容器时，它应该缩小的比例。</li>\n<li><code>&lt;flex-basis&gt;</code> 定义了弹性盒子的初始主轴大小，默认为 <code>auto</code>，即由弹性盒子的内容决定。</li>\n</ul>\n<p>这些属性可以使用单独的值进行指定，也可以使用缩写形式来同时指定三个值。具体使用哪个形式取决于您的需求。一些常用的缩写值示例包括：</p>\n<ul>\n<li><code>flex: 1;</code>：相当于 <code>flex: 1 1 0%;</code>，使弹性盒子在所有方向上等分剩余空间。</li>\n<li><code>flex: 2 1 20%;</code>：指定弹性盒子的放大比例为 2，缩小比例为 1，初始大小为 20%。</li>\n<li><code>flex: 0 0 auto;</code>：禁用弹性盒子的放大和缩小能力，并根据内容自动调整大小。</li>\n</ul>\n<p>通过使用 <code>flex</code> 属性的缩写值，可以更简洁方便地控制弹性盒子在 Flex 布局中的行为。</p>\n<h2 id=\"为什么有时候需要用-width-0-来解决-flex-问题\"><a href=\"#为什么有时候需要用-width-0-来解决-flex-问题\" class=\"headerlink\" title=\"为什么有时候需要用 width:0 来解决 flex 问题\"></a>为什么有时候需要用 width:0 来解决 flex 问题</h2><p>在某些情况下，使用 <code>width: 0;</code> 可以帮助解决 Flex 布局中的一些问题。这通常涉及到在弹性盒子中处理超出父容器宽度的内容或布局方面的需求。</p>\n<p>一种常见的情况是，当弹性盒子中的内容超过了父容器的宽度时，弹性盒子默认会根据内容自动扩展自身的宽度以适应内容，导致弹性盒子超出父容器。如果我们希望内容在父容器内部进行溢出或隐藏，而不影响弹性盒子的宽度，可以将 <code>width</code> 属性设置为 0：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.flex-container &#123;\n  display: flex;\n&#125;\n\n.flex-item &#123;\n  width: 0;\n  flex-grow: 1;\n  &#x2F;* 其他样式... *&#x2F;\n&#125;</code></pre>\n\n<p>通过将 <code>width</code> 设置为 0，我们告诉弹性盒子不要根据内容扩展自己的宽度，而是使用 <code>flex-grow</code> 的值来决定弹性盒子在剩余空间中的分配比例。这样，即使内容超出父容器宽度，弹性盒子仍会保持在父容器的范围内，而不会撑开整个布局。</p>\n<p>另一种情况是在网格布局中，当使用 Flex 布局的项目作为网格容器的子项时，有时候需要将子项的宽度设置为 0 以实现某些特定的布局需求。这是因为网格布局有自己的尺寸调整规则，通过将子项的宽度设置为 0，可以让网格布局的调整规则更好地生效。</p>\n<p>总而言之，<code>width: 0;</code> 的使用可以帮助我们解决一些与 Flex 布局相关的布局问题，特别是在控制内容溢出和在网格布局中使用 Flex 子项时。</p>\n<h2 id=\"typescript-extends-有哪些使用场景\"><a href=\"#typescript-extends-有哪些使用场景\" class=\"headerlink\" title=\"typescript extends 有哪些使用场景\"></a>typescript extends 有哪些使用场景</h2><p>在 TypeScript 中，<code>extends</code> 关键字可以应用于多种场景，包括：</p>\n<ol>\n<li>类的继承：<code>extends</code> 用于创建类的继承关系，子类可以继承父类的属性和方法，并可以覆盖或扩展它们。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  eat() &#123;\n    console.log(&#39;Animal is eating&#39;);\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  bark() &#123;\n    console.log(&#39;Dog is barking&#39;);\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog();\ndog.eat(); &#x2F;&#x2F; 输出: Animal is eating\ndog.bark(); &#x2F;&#x2F; 输出: Dog is barking</code></pre>\n\n<ol start=\"2\">\n<li>接口的继承：<code>extends</code> 用于创建接口之间的继承关系，一个接口可以继承一个或多个其他接口，从而继承它们的成员。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Shape &#123;\n  draw(): void;\n&#125;\n\ninterface ColorfulShape extends Shape &#123;\n  color: string;\n&#125;\n\nclass Circle implements ColorfulShape &#123;\n  color: string &#x3D; &#39;red&#39;;\n  draw() &#123;\n    console.log(&#96;Drawing a $&#123;this.color&#125; circle&#96;);\n  &#125;\n&#125;\n\nconst circle &#x3D; new Circle();\ncircle.draw(); &#x2F;&#x2F; 输出: Drawing a red circle</code></pre>\n\n<ol start=\"3\">\n<li>约束泛型类型参数：<code>extends</code> 用于约束泛型类型参数，通过指定泛型类型参数必须满足某个条件或继承特定接口，可以对类型参数进行更精确的约束。</li>\n</ol>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Lengthwise &#123;\n  length: number;\n&#125;\n\nfunction printLength&lt;T extends Lengthwise&gt;(arg: T) &#123;\n  console.log(arg.length);\n&#125;\n\nprintLength(&#39;Hello&#39;); &#x2F;&#x2F; 输出: 5\nprintLength([1, 2, 3]); &#x2F;&#x2F; 输出: 3</code></pre>\n\n<ol start=\"4\">\n<li>确实在 TypeScript 中可以使用 <code>extends</code> 关键字来创建交叉类型，而不是 <code>&amp;</code> 运算符。</li>\n</ol>\n<p>下面是正确的例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Foo &#x3D; &#123; a: number &#125;;\ntype Bar &#x3D; &#123; b: string &#125;;\n\ntype FooBar &#x3D; Foo extends Bar ? Foo : Bar;\n\nconst fooBar: FooBar &#x3D; &#123;\n  a: 1,\n  b: &#39;Hello&#39;,\n&#125;;</code></pre>\n\n<p>在这个例子中，我们使用了 <code>extends</code> 关键字来创建交叉类型 <code>FooBar</code>。通过判断 <code>Foo</code> 是否可以赋值给 <code>Bar</code>，如果是的话则选择 <code>Foo</code> 作为交叉类型，否则选择 <code>Bar</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type FooBar &#x3D; Foo extends Bar ? Foo : Bar;</code></pre>\n\n<p>这样，<code>FooBar</code> 类型将会是 <code>Foo</code> 和 <code>Bar</code> 的交叉类型，具有 <code>Foo</code> 和 <code>Bar</code> 类型的所有成员。</p>\n<p>对于交叉类型的创建，使用 <code>extends</code> 关键字是一种常见的模式。对于继承关系的创建，我们仍然可以使用 <code>extends</code> 关键字，但它主要用于类与类之间、接口与接口之间以及类与接口之间的继承关系。对于创建交叉类型，我们使用 <code>extends</code> 关键字进行条件判断来实现。</p>\n<p>这些是 <code>extends</code> 在 TypeScript 中的几种常见使用场景。它们提供了更多的灵活性和类型安全性，帮助开发者编写更健壮和可维护的代码。</p>\n","text":"var let const 区别 使用 var 具有全局或函数作用域，存在变量提升，可以重复声明，变量值可修改。 使用 let 具有块级作用域，不存在变量提升，不能重复声明，变量值可修改。 使用 const 具有块级作用域，不存在变量提升，不能重复声明，变量值不可修改（但对象和数...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#var-let-const-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">var let const 区别</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"link","uid":"317fa629ebf2e28e8e30a2ac41c06f40","slug":"link","date":"2024-01-07T08:19:19.000Z","updated":"2023-03-13T13:39:28.236Z","comments":true,"path":"api/articles/link.json","keywords":null,"cover":[],"text":"认知 横向对比 纵向学习 &#x2F;#&#x2F;post&#x2F;2023-02-23 思考 第三方链接 2023 面试真题之框架篇 2023 前端面试真题之 JS 篇 2023 面试真题之 CSS 篇 2023 面试真题之浏览器篇 2023 面试真题之手写&amp;代码运...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":6,"path":"api/tags/前端.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"ModuleNotFoundError No module named 'requests'","uid":"228098f2136c9f5bb0f3c96d9e151e02","slug":"2023-07-24py","date":"2023-07-24T02:23:45.000Z","updated":"2023-07-31T06:42:49.730Z","comments":true,"path":"api/articles/2023-07-24py.json","keywords":null,"cover":[],"text":"requests 无法引入# 安装命令 python3 -m pip install requests 安装日志👑 ~&#x2F;Desktop&#x2F;lnx&#x2F;py-5 $ python3 -m pip install requests Collecting req...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"Python","slug":"Python","count":4,"path":"api/tags/Python.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}