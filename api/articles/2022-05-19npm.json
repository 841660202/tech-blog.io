{"title":"npm 版本的依赖","uid":"2bd0e979bc9d9166a8f1986cef49a4e4","slug":"2022-05-19npm","date":"2022-05-19T10:10:47.000Z","updated":"2022-09-16T13:54:56.111Z","comments":true,"path":"api/articles/2022-05-19npm.json","keywords":null,"cover":"https://www.zoo.team/images/upload/upload_f796ccd0da75ef4ac47e9e739bc7b679.png","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。</p>\n<h1 id=\"npm-安装机制\"><a href=\"#npm-安装机制\" class=\"headerlink\" title=\"npm 安装机制\"></a>npm 安装机制</h1><p>A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。</p>\n<h2 id=\"A-和-B-同时依赖-C，这个包会被安装在哪里呢？\"><a href=\"#A-和-B-同时依赖-C，这个包会被安装在哪里呢？\" class=\"headerlink\" title=\"A 和 B 同时依赖 C，这个包会被安装在哪里呢？\"></a>A 和 B 同时依赖 C，这个包会被安装在哪里呢？</h2><p>假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。\b执行完毕后，我们会看到 <code>./node_modules</code> 这层目录只含有这两个子目录：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">node_modules&#x2F; \n├─┬ A \n│ ├── C \n├─┬ B \n│ └── C </code></pre>\n<p>如果使用 npm 3 来进行安装的话，<code>./node_modules</code> 下的目录将会包含三个子目录：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">node_modules&#x2F; \n├─┬ A \n├─┬ B \n├─┬ C </code></pre>\n<p>为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：</p>\n<h2 id=\"npm-2-和-npm-3-模块安装机制的差异\"><a href=\"#npm-2-和-npm-3-模块安装机制的差异\" class=\"headerlink\" title=\"npm 2 和 npm 3 模块安装机制的差异\"></a>npm 2 和 npm 3 模块安装机制的差异</h2><p>虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异。</p>\n<p>npm 2 在安装依赖包时，采用\b简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。\b执行完毕后，我们会看到 .&#x2F;node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：</p>\n<p><img src=\"http://t-blog-images.aijs.top/img/20220519181427.webp\"></p>\n<p>这样的目录有较为明显的好处：</p>\n<p>1）层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录；</p>\n<p>2）在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置；</p>\n<p>3）如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录；</p>\n<p>但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 <code>npm install</code> 后，D 会被重复下载三次，而随着我们的项目越来越复杂，<code>node_modules</code> 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；</p>\n<p>为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。</p>\n<h2 id=\"npm-3-对于同一依赖的不同版本会怎么处理呢？\"><a href=\"#npm-3-对于同一依赖的不同版本会怎么处理呢？\" class=\"headerlink\" title=\"npm 3 对于同一依赖的不同版本会怎么处理呢？\"></a>npm 3 对于同一依赖的不同版本会怎么处理呢？</h2><p>npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):</p>\n<p><img src=\"http://t-blog-images.aijs.top/img/20220519181500.webp\"></p>\n<p>但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：</p>\n<p><img src=\"http://t-blog-images.aijs.top/img/20220519181517.webp\"></p>\n<p>由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。</p>\n<h2 id=\"为什么会出现-package-lock-json-呢？\"><a href=\"#为什么会出现-package-lock-json-呢？\" class=\"headerlink\" title=\"为什么会出现 package-lock.json 呢？\"></a>为什么会出现 package-lock.json 呢？</h2><p>为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。</p>\n<h2 id=\"package-json-的不足之处\"><a href=\"#package-json-的不足之处\" class=\"headerlink\" title=\"package.json 的不足之处\"></a>package.json 的不足之处</h2><p>npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因：</p>\n<p>1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 <code>A: &#39;^1.0.5&#39;</code> ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug；</p>\n<p>2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 <code>A: &#39;1.0.5&#39;</code> 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。</p>\n<h2 id=\"针对-package-json-不足的解决方法\"><a href=\"#针对-package-json-不足的解决方法\" class=\"headerlink\" title=\"针对 package.json 不足的解决方法\"></a>针对 package.json 不足的解决方法</h2><p>为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。</p>\n<h2 id=\"package-lock-json-文件的结构\"><a href=\"#package-lock-json-文件的结构\" class=\"headerlink\" title=\"package-lock.json 文件的结构\"></a>package-lock.json 文件的结构</h2><p>package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 <a href=\"https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires\">package-lock-json官方文档</a>，主要的结构如下：</p>\n<ul>\n<li><p>version ：包版本，即这个包当前安装在 node_modules 中的版本</p>\n</li>\n<li><p>resolved ：包具体的安装来源</p>\n</li>\n<li><p>integrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效</p>\n</li>\n<li><p>requires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同</p>\n</li>\n<li><p>dependencies ：结构和外层的 <code>dependencies</code> 结构相同，存储安装在子依赖 <code>node_modules</code> 中的依赖包</p>\n</li>\n</ul>\n<p>需要注意的是，并不是所有的子依赖都有 <code>dependencies</code> 属性，只有子依赖的依赖和当前已安装在根目录的 <code>node_modules</code> 中的依赖冲突之后，才会有这个属性。</p>\n<h2 id=\"package-lock-json-文件的作用\"><a href=\"#package-lock-json-文件的作用\" class=\"headerlink\" title=\"package-lock.json 文件的作用\"></a>package-lock.json 文件的作用</h2><p>在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；</p>\n<p>node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。</p>\n<p>由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。</p>\n<p>在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。</p>\n<h1 id=\"依赖的区别与使用场景\"><a href=\"#依赖的区别与使用场景\" class=\"headerlink\" title=\"依赖的区别与使用场景\"></a>依赖的区别与使用场景</h1><h2 id=\"npm-目前支持以下几类依赖包管理包括\"><a href=\"#npm-目前支持以下几类依赖包管理包括\" class=\"headerlink\" title=\"npm 目前支持以下几类依赖包管理包括\"></a>npm 目前支持以下几类依赖包管理包括</h2><ol>\n<li><p>dependencies</p>\n</li>\n<li><p>devDependencies</p>\n</li>\n<li><p>optionalDependencies 可选择的依赖包</p>\n</li>\n<li><p>peerDependencies 同等依赖</p>\n</li>\n<li><p>bundledDependencies 捆绑依赖包</p>\n</li>\n</ol>\n<p>下面我们来看一下这几种依赖的区别以及各自的应用场景：</p>\n<h2 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h2><p>dependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 <code>npm install XXX --save</code> 下载 dependencies 中的包；</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&quot;devDependencies&quot;:&#123;\n  &quot;eslint&quot;: &quot;^5.0.0&quot;,\n  &quot;debug&quot;: &quot;^3.1.0&quot;,\n&#125;\n</code></pre>\n\n<h2 id=\"devDependencies\"><a href=\"#devDependencies\" class=\"headerlink\" title=\"devDependencies\"></a>devDependencies</h2><p>devDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 <code>npm install packageName --save-dev</code> 下载的包都会在 devDependencies 对象中；</p>\n<p>dependencies 和 devDependencies 最大的区别是在打包运行时，执行 <code>npm install</code> 时默认会把所有依赖全部安装，但是如果使用 <code>npm install --production</code> 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。</p>\n<h2 id=\"optionalDependencies\"><a href=\"#optionalDependencies\" class=\"headerlink\" title=\"optionalDependencies\"></a>optionalDependencies</h2><p>optionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。</p>\n<p>optionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">try &#123; \n  var axios &#x3D; require(&#39;axios&#39;) \n  var fooVersion &#x3D; require(&#39;axios&#x2F;package.json&#39;).version \n&#125; catch (er) &#123; \n  foo &#x3D; null \n&#125; \n&#x2F;&#x2F; .. then later in your program .. \nif (foo) &#123; \n  foo.doFooThings() \n&#125; \n</code></pre>\n\n<h2 id=\"peerDependencies\"><a href=\"#peerDependencies\" class=\"headerlink\" title=\"peerDependencies\"></a>peerDependencies</h2><p>peerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 <code>ant-design@3.x</code> 的 <code>package.json</code> 中的配置如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&quot;peerDependencies&quot;: &#123; \n  &quot;react&quot;: &quot;&gt;&#x3D;16.9.0&quot;, \n  &quot;react-dom&quot;: &quot;&gt;&#x3D;16.9.0&quot; \n &#125;, </code></pre>\n<p>假设我们创建了一个名为 project 的项目，在此项目中我们要使用 <code>ant-design@3.x</code> 这个插件，此时我们的项目就必须先安装 React &gt;&#x3D; 16.9.0 和 React-dom &gt;&#x3D; 16.9.0 的版本。</p>\n<p>在 npm 2 中，当我们下载 <code>ant-design@3.x</code> 时，peerDependencies 中指定的依赖会随着 <code>ant-design@3.x</code> 一起被强制安装，所以我们不需要在宿主项目的 <code>package.json</code> 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖；</p>\n<h2 id=\"bundledDependencies\"><a href=\"#bundledDependencies\" class=\"headerlink\" title=\"bundledDependencies\"></a>bundledDependencies</h2><p>这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123; \n  &quot;name&quot;: &quot;project&quot;, \n  &quot;version&quot;: &quot;1.0.0&quot;, \n  &quot;bundleDependencies&quot;: [ \n    &quot;axios&quot;,  \n    &quot;lodash&quot; \n  ] \n&#125; </code></pre>\n<p>当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 <code>npm install project-1.0.0.tgz</code> 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&quot;bundleDependencies&quot;: [ \n    &quot;axios&quot;, \n    &quot;lodash&quot; \n  ], \n&quot;dependencies&quot;: &#123; \n  &quot;axios&quot;: &quot;*&quot;, \n  &quot;lodash&quot;: &quot;*&quot; \n&#125;, </code></pre>\n<p>如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://www.zoo.team/article/npm-details\">原文</a></li>\n<li><a href=\"https://docs.npmjs.com/files/package.json#peerdependencies\">package.json官方文档</a></li>\n<li><a href=\"https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires\">package-lock-json官方文档</a></li>\n<li><a href=\"https://juejin.im/post/6844903582337237006#heading-0\">npm文档总结</a></li>\n<li><a href=\"https://www.npmjs.cn/cli/pack/\">npm-pack</a></li>\n</ol>\n","text":"前言提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"npm","slug":"npm","count":4,"path":"api/categories/npm.json"}],"tags":[{"name":"工具","slug":"工具","count":7,"path":"api/tags/工具.json"},{"name":"npm","slug":"npm","count":5,"path":"api/tags/npm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#npm-%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">npm 安装机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#A-%E5%92%8C-B-%E5%90%8C%E6%97%B6%E4%BE%9D%E8%B5%96-C%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%8C%85%E4%BC%9A%E8%A2%AB%E5%AE%89%E8%A3%85%E5%9C%A8%E5%93%AA%E9%87%8C%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">A 和 B 同时依赖 C，这个包会被安装在哪里呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-2-%E5%92%8C-npm-3-%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%AE%E5%BC%82\"><span class=\"toc-text\">npm 2 和 npm 3 模块安装机制的差异</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-3-%E5%AF%B9%E4%BA%8E%E5%90%8C%E4%B8%80%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%BC%9A%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">npm 3 对于同一依赖的不同版本会怎么处理呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-package-lock-json-%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">为什么会出现 package-lock.json 呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#package-json-%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84\"><span class=\"toc-text\">package.json 的不足之处</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%92%88%E5%AF%B9-package-json-%E4%B8%8D%E8%B6%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">针对 package.json 不足的解决方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#package-lock-json-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">package-lock.json 文件的结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#package-lock-json-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">package-lock.json 文件的作用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">依赖的区别与使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-%E7%9B%AE%E5%89%8D%E6%94%AF%E6%8C%81%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%B1%BB%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86%E5%8C%85%E6%8B%AC\"><span class=\"toc-text\">npm 目前支持以下几类依赖包管理包括</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dependencies\"><span class=\"toc-text\">dependencies</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#devDependencies\"><span class=\"toc-text\">devDependencies</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#optionalDependencies\"><span class=\"toc-text\">optionalDependencies</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#peerDependencies\"><span class=\"toc-text\">peerDependencies</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bundledDependencies\"><span class=\"toc-text\">bundledDependencies</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"><span class=\"toc-text\">参考文献</span></a></li></ol>","author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"比你优秀的人，比你更努力！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"npm开发wiki编辑器问题总结","uid":"4250bd0ddd67048179ff9fddd5b6e876","slug":"2022-05-19npm-pkg","date":"2022-05-19T10:34:53.000Z","updated":"2022-09-16T13:54:56.110Z","comments":true,"path":"api/articles/2022-05-19npm-pkg.json","keywords":null,"cover":[],"text":"原架构 重构后 tsconfig.ts&#123; &#x2F;&#x2F; 编译选项 &quot;compilerOptions&quot;: &#123; &#x2F;&#x2F; 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码 &quot;targe...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"npm","slug":"npm","count":4,"path":"api/categories/npm.json"}],"tags":[{"name":"npm","slug":"npm","count":5,"path":"api/tags/npm.json"},{"name":"wiki","slug":"wiki","count":4,"path":"api/tags/wiki.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"比你优秀的人，比你更努力！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"TypeScript noEmit","uid":"72e60ad0a93fafff72edb1b0852502a0","slug":"2022-05-18ts","date":"2022-05-18T08:55:53.000Z","updated":"2022-09-17T07:48:05.584Z","comments":true,"path":"api/articles/2022-05-18ts.json","keywords":null,"cover":null,"text":"No Emit -noEmitDo not emit compiler output files like JavaScript source code, source-maps or declarations.不要发出编译器输出文件，如JavaScript源代码、源映射或声明。...","link":"","photos":[],"count_time":{"symbolsCount":410,"symbolsTime":"1 mins."},"categories":[{"name":"Typescript","slug":"Typescript","count":1,"path":"api/categories/Typescript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":12,"path":"api/tags/TypeScript.json"}],"author":{"name":"陈哈喽","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"比你优秀的人，比你更努力！","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}