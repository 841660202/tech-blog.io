{"title":"monorepo","uid":"98f521cd056816f8a9831692e48a6839","slug":"2022-05-23monorepo","date":"2022-05-23T06:45:12.000Z","updated":"2022-09-16T13:54:56.113Z","comments":true,"path":"api/articles/2022-05-23monorepo.json","keywords":null,"cover":"https://segmentfault.com/img/remote/1460000038683984","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>调试源码时候，总会遇到多包的仓库，遇到了不晓得如何调试</li>\n<li>开发个库或者是插件之类的开发的比较混乱</li>\n<li>经历多个项目的毒打，终于有时间学下<code>monorepo</code></li>\n</ul>\n<h2 id=\"lerna、yarn-workspace\"><a href=\"#lerna、yarn-workspace\" class=\"headerlink\" title=\"lerna、yarn workspace\"></a>lerna、yarn workspace</h2><ul>\n<li>和java微服务架构代码很像</li>\n<li>很多项目是 lerna+yarn workspace，如果不懂，或者了解了一点<code>lerna</code>。上去一顿操作，各种报错，在所难免（亲身经历）</li>\n</ul>\n<h2 id=\"monorepo管理\"><a href=\"#monorepo管理\" class=\"headerlink\" title=\"monorepo管理\"></a>monorepo管理</h2><p>对于维护过多个package(功能相近)的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护。Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块&#x2F;包 (package)，不同于常见的每个模块建一个 repo。</p>\n<p>目前有不少大型开源项目采用了这种方式，如 Babel，React, Meteor, Ember, Angular,Jest, Umijs, Vue, 还有 create-react-app, react-router 等。几乎我们熟知的仓库，都无一例外的采用了monorepo 的方式，可以看到这些项目的第一级目录的内容以脚手架为主，主要内容都在 packages目录中、分多个 package 进行管理。</p>\n<p>目录结构如下:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">├── packages\n|   ├── pkg1\n|   |   ├── package.json\n|   ├── pkg2\n|   |   ├── package.json\n├── package.json\n</code></pre>\n<p>monorepo 最主要的好处是统一的工作流和Code Sharing。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。</p>\n<p>一图胜千言:<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOThmNTYwZDgxZDg\"></p>\n<p>前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。</p>\n<p>虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。</p>\n<p>结合shop-service门户的实际场景和业务需要，天然的 MonoRepo ! 一个理想的开发环境可以抽象成这样：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”</p></blockquote>\n<p>在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。</p>\n<p>上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna是业界知名度最高的 Monorepo 管理工具，功能完整。</p>\n<h2 id=\"Lerna\"><a href=\"#Lerna\" class=\"headerlink\" title=\"Lerna\"></a>Lerna</h2><p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p>\n<p>2.1 安装<br>推荐全局安装，因为会经常用到 lerna 命令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm i -g lerna</code></pre>\n<p>2.2 初始化项目</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna init</code></pre>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWE5MDhiMTkyOWQ\"></p>\n<p>其中 package.json &amp; lerna.json 如下:</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true, &#x2F;&#x2F; 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦\n  &quot;devDependencies&quot;: &#123;\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;\n \n&#x2F;&#x2F; lerna.json\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;version&quot;: &quot;0.0.0&quot;\n&#125;\n</code></pre>\n\n<p>2.3 创建npm包<br>增加两个 packages</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWIyOTgzNjExZDE\"></p>\n<p>2.4 增加模块依赖<br>分别给相应的 package 增加依赖模块</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna add chalk &#x2F;&#x2F; 为所有 package 增加 chalk 模块 \nlerna add semver --scope @mo-demo&#x2F;cli-shared-utils &#x2F;&#x2F; 为 @mo-demo&#x2F;cli-shared-utils 增加 semver 模块 \nlerna add @mo-demo&#x2F;cli-shared-utils --scope @mo-demo&#x2F;cli &#x2F;&#x2F; 增加内部模块之间的依赖</code></pre>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWI2NTNmMGQ5NjQ\"></p>\n<p>2.5 发布</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna publish</code></pre>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWJiMWY4MjhjZjk\"></p>\n<p>2.6 依赖包管理<br>上述1-5步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。</p>\n<p>我们在第4步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 node_modules 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 node_modules ，也不清爽。于是我们使用 –hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna bootstrap --hoist</code></pre>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWJmNjUxZDkxMWY\"></p>\n<p>为了省去每次都输入 –hoist 参数的麻烦，可以在 lerna.json 配置：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;command&quot;: &#123;\n    &quot;bootstrap&quot;: &#123;\n      &quot;hoist&quot;: true\n    &#125;\n  &#125;,\n  &quot;version&quot;: &quot;0.0.1-alpha.0&quot;\n&#125;</code></pre>\n<p>配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna clean</code></pre>\n<img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWM2OTdjODVjMWM\" width=350 style=\"object-fit:contain\"/>\n然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 `node_modules` 中了。\n\n<h2 id=\"Lerna-Monorepo-最佳实践\"><a href=\"#Lerna-Monorepo-最佳实践\" class=\"headerlink\" title=\"Lerna + Monorepo 最佳实践\"></a>Lerna + Monorepo 最佳实践</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>lerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。</p></blockquote>\n<p>目前最常见的 monorepo 解决方案是 Lerna 和 yarn 的 workspaces 特性，基于lerna和yarn workspace的monorepo工作流。由于yarn和lerna在功能上有较多的重叠,我们采用yarn官方推荐的做法,用yarn来处理依赖问题，用lerna来处理发布问题。能用yarn做的就用yarn做吧</p>\n<h2 id=\"yarn-workspace\"><a href=\"#yarn-workspace\" class=\"headerlink\" title=\"yarn workspace\"></a>yarn workspace</h2><p>3.1.1 搭建环境<br>普通项目：clone下来后通过yarn install,即可搭建完项目，有时需要配合postinstall hooks,来进行自动编译，或者其他设置。</p>\n<p>monorepo: 各个库之间存在依赖，如A依赖于B，因此我们通常需要将B link到A的node_module里，一旦仓库很多的话，手动的管理这些link操作负担很大，因此需要自动化的link操作，按照拓扑排序将各个依赖进行link</p>\n<p>解决方式：通过使用workspace，yarn install会自动的帮忙解决安装和link问题</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn install # 等价于 lerna bootstrap --npm-client yarn --use-workspaces\n</code></pre>\n<p>3.1.2 清理环境<br>在依赖乱掉或者工程混乱的情况下，清理依赖</p>\n<p>普通项目： 直接删除node_modules以及编译后的产物。</p>\n<p>monorepo： 不仅需要删除root的node_modules的编译产物还需要删除各个package里的node_modules以及编译产物</p>\n<p>解决方式：使用lerna clean来删除所有的node_modules，使用yarn workspaces run clean来执行所有package的清理工作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna clean # 清理所有的node_modules\nyarn workspaces run clean # 执行所有package的clean操作\n</code></pre>\n<p>3.1.3 安装|删除依赖<br>普通项目： 通过yarn add和yarn remove即可简单姐解决依赖库的安装和删除问题</p>\n<p>monorepo: 一般分为三种场景</p>\n<p>给某个package安装依赖：yarn workspace packageB add packageA 将packageA作为packageB的依赖进行安装</p>\n<p>给所有的package安装依赖: 使用yarn workspaces add lodash 给所有的package安装依赖</p>\n<p>给root 安装依赖：一般的公用的开发工具都是安装在root里，如typescript,我们使用yarn add -W -D typescript来给root安装依赖</p>\n<p>对应的三种场景删除依赖如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn workspace packageB remove packageA\nyarn workspaces remove lodash\nyarn remove -W -D typescript\n</code></pre>\n\n<p>3.1.4 项目构建<br>普通项目：建立一个build的npm script，使用yarn build即可完成项目构建</p>\n<p>monorepo:区别于普通项目之处在于各个package之间存在相互依赖，如packageB只有在packageA构建完之后才能进行构建，否则就会出错，这实际上要求我们以一种拓扑排序的规则进行构建。</p>\n<p>我们可以自己构建拓扑排序规则，很不幸的是yarn的workspace暂时并未支持按照拓扑排序规则执行命令,虽然该 rfc已经被accepted，但是尚未实现, 幸运的是lerna支持按照拓扑排序规则执行命令, –sort参数可以控制以拓扑排序规则执行命令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna run --stream --sort build</code></pre>\n<p>3.1.5 版本升级及发包<br>项目测试完成后，就涉及到版本发布，版本发布一般涉及到如下一些步骤</p>\n<p>条件验证: 如验证测试是否通过，是否存在未提交的代码，是否在主分支上进行版本发布操作</p>\n<p>version_bump:发版的时候需要更新版本号，这时候如何更新版本号就是个问题，一般大家都会遵循 semVer语义，</p>\n<p>生成changelog: 为了方便查看每个package每个版本解决了哪些功能，我们需要给每个package都生成一份changelog方便用户查看各个版本的功能变化。</p>\n<p>生成git tag：为了方便后续回滚问题及问题排查通常需要给每个版本创建一个git tag</p>\n<p>git 发布版本：每次发版我们都需要单独生成一个commit记录来标记milestone</p>\n<p>发布npm包：发布完git后我们还需要将更新的版本发布到npm上，以便外部用户使用</p>\n<p>我们发现手动的执行这些操作是很麻烦的且及其容易出错，幸运的是lerna可以帮助我们解决这些问题</p>\n<p>yarn官方并不打算支持发布流程，只是想做好包管理工具，因此这部分还是需要通过lerna支持</p>\n<p>lerna提供了publish和version来支持版本的升级和发布, publish的功能可以即包含version的工作，也可以单纯的只做发布操作。</p>\n<p>3.2 优雅的提交<br>3.2.1 <code>commitizen</code> &amp;&amp; <code>cz-lerna-changelog</code><br>commitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。</p>\n<p>cz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTNmZGEyMTA3MGI\"></p>\n<p>我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。</p>\n<p>因为这是整个工程的开发依赖，所以在根目录安装：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add  -D commitizen\nyarn add  -D cz-lerna-changelog</code></pre>\n\n<p>安装完成后，在 <code>package.json</code> 中增加 <code>config</code> 字段，把 <code>cz-lerna-changelog</code> 配置给 <code>commitizen</code>。同时因为<code>commitizen</code>不是全局安全的，所以需要添加 <code>scripts</code> 脚本来执行 <code>git-cz</code></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;commit&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;\n</code></pre>\n\n<p>之后在常规的开发中就可以使用 yarn run commit 来根据提示一步一步输入，来完成代码的提交。</p>\n<p>3.2.2 commitlint &amp;&amp; husky<br>上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用<code>yarn run commit</code> 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。</p>\n<p>安装 commitlint 以及要遵守的规范</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add -D @commitlint&#x2F;cli @commitlint&#x2F;config-conventional\n</code></pre>\n<p>在工程根目录为 commitlint 增加配置文件 commitlint.config.js 为commitlint 指定相应的规范</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">module.exports &#x3D; &#123; \n\textends: [&#39;@commitlint&#x2F;config-conventional&#39;] \n&#125;\n</code></pre>\n<p>安装 husky</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add -D husky\n</code></pre>\n\n<p>在 package.json 中增加如下配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;husky&quot;: &#123; \n\t\t&quot;hooks&quot;: &#123; \n   \t\t&quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot; \n    &#125;\n&#125;\n</code></pre>\n\n<p>“commit-msg”是git提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 yarn run commit 来提交。</p>\n<p>3.2.3 eslint &amp;&amp; lint-staged<br>除了规范提交信息，代码本身肯定也少了靠规范来统一风格。</p>\n<p>安装</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add  -D standard lint-staged\n</code></pre>\n\n<p>eslint就是完整的一套 JavaScript（typescript） 代码规范，自带 linter &amp; 代码自动修正。自动格式化代码并修正，提前发现风格以及程序问题, 同时也支持typescript的代码规范校验，<code>eslintrc.json</code>配置：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;extends&quot;: [\n        &quot;yayajing&quot;,\n        &quot;plugin:@typescript-eslint&#x2F;recommended&quot;\n    ],\n    &quot;parser&quot;: &quot;typescript-eslint-parser&quot;,\n    &quot;plugins&quot;: [&quot;@typescript-eslint&quot;],\n    &quot;rules&quot;: &#123;\n        &quot;eqeqeq&quot;:&quot;off&quot;,\n        &quot;@typescript-eslint&#x2F;explicit-function-return-type&quot;: &quot;off&quot;,\n        &quot;no-template-curly-in-string&quot;: &quot;off&quot;\n    &#125;\n  &#125;\n\n</code></pre>\n<p><code>lint-staged staged</code> 是 Git 里的概念，表示暂存区，lint-staged 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。<br>package.json配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;c&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;husky&quot;: &#123;\n    &quot;hooks&quot;: &#123;\n      &quot;pre-commit&quot;: &quot;lint-staged&quot;,\n      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;\n    &#125;\n  &#125;,\n  &quot;lint-staged&quot;: &#123;\n    &quot;*.ts&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@commitlint&#x2F;cli&quot;: &quot;^8.1.0&quot;,\n    &quot;@commitlint&#x2F;config-conventional&quot;: &quot;^8.1.0&quot;,\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;husky&quot;: &quot;^3.0.0&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;,\n    &quot;lint-staged&quot;: &quot;^9.2.0&quot;\n  &#125;\n&#125;\n</code></pre>\n\n<p>安装完成后，在 package.json 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 eslint –fix 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky的配置中增加pre-commit的钩子用来执行 lint-staged 的校验操作。</p>\n<p>此时提交 ts 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。</p>\n<p>3.3 发布自动生成日志<br>有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：</p>\n<p>3.3.1 lerna version 更新版本</p>\n<ul>\n<li><p>找出从上一个版本发布以来有过变更的 package</p>\n</li>\n<li><p>提示开发者确定要发布的版本号</p>\n</li>\n<li><p>将所有更新过的的 package 中的package.json的version字段更新</p>\n</li>\n<li><p>将依赖更新过的 package 的 包中的依赖版本号更新</p>\n</li>\n<li><p>更新 lerna.json 中的 version 字段</p>\n</li>\n<li><p>提交上述修改，并打一个 tag</p>\n</li>\n<li><p>推送到 git 仓库<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTMzNTMzMzhkYTA\"></p>\n</li>\n</ul>\n<p>3.3.2 使用 npm publish 将新版本推送到 npm<br><code>CHANGELOG</code> 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数 <code>--conventional-commits</code>。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 <code>lerna.json</code>中，如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;command&quot;: &#123;\n    &quot;bootstrap&quot;: &#123;\n      &quot;hoist&quot;: true\n    &#125;,\n    &quot;version&quot;: &#123;\n      &quot;conventionalCommits&quot;: true\n    &#125;\n  &#125;,\n  &quot;ignoreChanges&quot;: [\n    &quot;**&#x2F;*.md&quot;\n  ],\n  &quot;version&quot;: &quot;0.0.1-alpha.1&quot;\n&#125;\n</code></pre>\n\n<p><code>lerna version</code> 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 <code>ignoreChanges</code> 配置排除。如上。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTM3NTQwN2Y0MzY\"></p>\n<p>实际 <code>lerna version</code>很少直接使用，因为它包含在 <code>lerna publish</code> 中了，直接使用 <code>lerna publish</code>就好了。</p>\n<p>3.4 完善的测试用例<br>monorepo项目：测试有两种方式</p>\n<ul>\n<li><p>使用统一的jest测试配置这样方便全局的跑jest即可，好处是可以方便统计所有代码的测试覆盖率，坏处是如果package比较异构（如小程序，前端，node 服务端等），统一的测试配置不太好编写</p>\n</li>\n<li><p>每个package单独支持test命令，使用yarn workspace run test，坏处是不好统一收集所有代码的测试覆盖率</p>\n</li>\n</ul>\n<p>如果采用jest编写测试用例，支持typescript的话，需要初始化配置jest.config.js：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">module.exports &#x3D; &#123;\n  preset: &#39;ts-jest&#39;,\n  moduleFileExtensions: [&#39;ts&#39;],\n  testEnvironment: &#39;node&#39;\n&#125;\n</code></pre>\n<p>4 实践总结<br>到这里，基本上已经构建了基于lerna和yarn workspace的monorepo项目的最佳实践了，该有的功能都有：</p>\n<ul>\n<li><p>完善的工作流</p>\n</li>\n<li><p>typescript支持</p>\n</li>\n<li><p>风格统一的编码</p>\n</li>\n<li><p>完整的单元测试</p>\n</li>\n<li><p>一键式的发布机制</p>\n</li>\n<li><p>完美的更新日志</p>\n</li>\n</ul>\n<p>……</p>\n<p>当然，构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/i10630226/article/details/99702447\">lerna+yarn workspace+monorepo项目的最佳实践</a><br><a href=\"https://www.jianshu.com/p/c10d0b8c5581\">5分钟搞懂Monorepo</a><br><a href=\"https://www.easemob.com/news/5948\">2021年管理Monorepo代码库的11种出色工具</a></p>\n","text":"背景 调试源码时候，总会遇到多包的仓库，遇到了不晓得如何调试 开发个库或者是插件之类的开发的比较混乱 经历多个项目的毒打，终于有时间学下monorepo lerna、yarn workspace 和java微服务架构代码很像 很多项目是 lerna+yarn workspace，...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"npm","slug":"npm","count":4,"path":"api/categories/npm.json"}],"tags":[{"name":"增效","slug":"增效","count":7,"path":"api/tags/增效.json"},{"name":"npm","slug":"npm","count":5,"path":"api/tags/npm.json"},{"name":"monorepo","slug":"monorepo","count":1,"path":"api/tags/monorepo.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lerna%E3%80%81yarn-workspace\"><span class=\"toc-text\">lerna、yarn workspace</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#monorepo%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">monorepo管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lerna\"><span class=\"toc-text\">Lerna</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lerna-Monorepo-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">Lerna + Monorepo 最佳实践</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#yarn-workspace\"><span class=\"toc-text\">yarn workspace</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><p>做好该做的，然后做自己想做的</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"flex width:0","uid":"eb38c4ce852a081263435b4198b57084","slug":"2022-05-23width0","date":"2022-05-23T09:16:21.000Z","updated":"2023-02-20T21:20:56.459Z","comments":true,"path":"api/articles/2022-05-23width0.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/flex.webp","text":"flex 嵌套内部元素宽度默认 100%，撑开父元素，父元素的根元素限制最大宽度，子元素并不受 flex 控制 遇到多次了，这次是维护其他同事的代码，又撞见了，说明这个问题很常见，一个不留神，就踩到了 根元素 …… - 父元素flex …… flex - 子元素flex(默认宽度...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"CSS","slug":"CSS","count":4,"path":"api/categories/CSS.json"}],"tags":[{"name":"bug","slug":"bug","count":6,"path":"api/tags/bug.json"},{"name":"CSS","slug":"CSS","count":4,"path":"api/tags/CSS.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><p>做好该做的，然后做自己想做的</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"信标（Beacon ）","uid":"a8dbdf02ab5e598ef229ef514965f17c","slug":"2022-05-23beacon","date":"2022-05-23T03:12:16.000Z","updated":"2022-09-16T13:54:56.112Z","comments":true,"path":"api/articles/2022-05-23beacon.json","keywords":null,"cover":null,"text":"Beacon 特点 接口用于将异步和非阻塞请求发送到服务器。 请求使用HTTP协议中的POST方法，请求通常不需要响应。 这个请求被保证在，页面的unload状态从发起到完成之前，被发送。而并不需要一个阻塞请求，例如 XMLHttpRequest 。 Beacon 场景发送异步非...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"浏览器","slug":"浏览器","count":1,"path":"api/categories/浏览器.json"}],"tags":[{"name":"浏览器","slug":"浏览器","count":1,"path":"api/tags/浏览器.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><p>做好该做的，然后做自己想做的</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}