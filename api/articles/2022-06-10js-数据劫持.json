{"title":"前端基础-劫持(函数/数据)","uid":"3cfe5c81c087dc101db23ece3358d249","slug":"2022-06-10js-数据劫持","date":"2022-06-10T07:05:21.000Z","updated":"2023-02-20T21:20:56.461Z","comments":true,"path":"api/articles/2022-06-10js-数据劫持.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fres.cloudinary.com%2Fcitiar%2Fimage%2Fupload%2Fv1611373461%2Fucamc%2Fcommon%2Fthumb_5x_Javascript-O.png&refer=http%3A%2F%2Fres.cloudinary.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1657437058&t=2169b1ec59622a8e20039841292e4d8b","content":"<h2 id=\"函数劫持\"><a href=\"#函数劫持\" class=\"headerlink\" title=\"函数劫持\"></a>函数劫持</h2><p>函数劫持，在一个函数运行之前就把它劫持下来，添加我们想要的功能。 在函数运行之前，我们可以改变函数的参数，或者改变函数的返回值。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JavaScript 中的函数劫持是一个增强原有函数的技巧，一般我们用来对原有的 JavaScript 全局方法做一些能力的增强。</p></blockquote>\n<p><strong>函数劫持原理</strong></p>\n<p>函数劫持原理，是在函数运行之前，把函数的原型改变为新的函数，并且把原函数的执行代码放到新函数的执行代码之前。</p>\n<p><strong>函数劫持实现</strong></p>\n<ol>\n<li>使用<code>新的变量</code>保存被劫持函数</li>\n<li><code>新函数中写被劫持函数</code></li>\n<li><code>新函数中</code> <code>调用原有的函数</code>（保存在变量中的函数）</li>\n</ol>\n<p><strong>基础：两个对象指向同一个地址的时候，修改某个对象的属性，另外一个对象也会随之变化</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let a &#x3D; &#123;&#125;;\nlet b &#x3D; a;\na.name &#x3D; &quot;Gopal&quot;;\n&#x2F;&#x2F; ture &#123;name: &#39;Gopal&#39;&#125;  &#123;name: &#39;Gopal&#39;&#125;\nconsole.log(b &#x3D;&#x3D;&#x3D; a, a, b);</code></pre>\n\n<p><strong>基础：将新的对象赋值给对象变量的时候，该对象变量就指向了新对象的引用地址，跟旧引用切断关联</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let a &#x3D; &#123;&#125;;\nlet b &#x3D; a;\na &#x3D; &#123; name: &quot;Gopal&quot; &#125;;\n&#x2F;&#x2F; false &#123;name: &#39;Gopal&#39;&#125; &#123;&#125;\nconsole.log(b &#x3D;&#x3D;&#x3D; a, a, b);</code></pre>\n\n<p><strong>应用场景</strong></p>\n<ul>\n<li>增强你的函数功能<ul>\n<li>如上面的第一个例子，在原有的函数之上，实现特定的逻辑。</li>\n</ul>\n</li>\n<li>追踪 XSS 攻击<ul>\n<li>一般 XSS 攻击会先利用 alert() 等方法输出信息进行测试，这个时候，我们可以对原先的 alert() 进行劫持，向其输入追踪信息的代码，最后才把原函数执行。<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function report(caller) &#123;\n  var img &#x3D; new Image();\n  img.src &#x3D; &#96;http:&#x2F;&#x2F;www.site.com&#x2F;getReport.php?caller&#x3D;$&#123;encodeURIComponent(\n    caller\n  )&#125;&#96;;\n&#125;\nvar _alert &#x3D; window.alert;\nwindow.alert &#x3D; function (s) &#123;\n  &#x2F;&#x2F; 拿到攻击者相关信息，并上报\n  report(alert.caller);\n  _alert(s);\n&#125;;\nalert(&quot;test&quot;);</code></pre></li>\n</ul>\n</li>\n</ul>\n<p><strong>劫持 ajax 请求，实现 mock 功能</strong></p>\n<ul>\n<li>mock.js 中，就是通过对原生的 XMLHttpRequest（或 ActiveXObject）进行劫持，判断有没有找到匹配的数据模板，如果找到，则拦截 XHR 请求逻辑，执行自身规则对应的逻辑。如果未找到匹配的数据模板，则采用原生 XHR 发送请求。详细代码看 <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuysoft%2FMock%2Fblob%2Frefactoring%2Fsrc%2Fmock%2Fxhr%2Fxhr.js\" target=\"_blank\" >这里</a> 。</li>\n</ul>\n<h2 id=\"数据劫持-defineProperty\"><a href=\"#数据劫持-defineProperty\" class=\"headerlink\" title=\"数据劫持 defineProperty\"></a>数据劫持 defineProperty</h2><h2 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty()\"></a>Object.defineProperty()</h2><p>通过设置对象属性 getter 和 setter 来监听属性的变化，可以实现数据劫持。getter 时候进行依赖收集，setter 时候进行数据变更时通知订阅者更新视图。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function defineReactive(obj, key, value) &#123;\n  Object.defineProperty(obj, key, &#123;\n    enumerable: true,\n    configurable: true,\n    get() &#123;\n      collectDeps(); &#x2F;&#x2F; 收集依赖\n      return value;\n    &#125;,\n    set(newVal) &#123;\n      observe(newVal); &#x2F;&#x2F; 若是新值是对象，则递归子属性\n      if (value !&#x3D;&#x3D; newVal) &#123;\n        notify(); &#x2F;&#x2F; 通知订阅者更新视图\n        console.log(&quot;数据变更了&quot;);\n        value &#x3D; newVal;\n      &#125;\n    &#125;,\n  &#125;);\n  observe(value); &#x2F;&#x2F; 递归子属性\n&#125;\n\nfunction observe(obj) &#123;\n  if (!obj || typeof obj !&#x3D;&#x3D; &quot;object&quot;) &#123;\n    return;\n  &#125;\n  Object.keys(obj).forEach((key) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 有递归\n    defineReactive(obj, key, obj[key]);\n  &#125;);\n&#125;\n\nvar data &#x3D; &#123;\n  name: &quot;Gopal&quot;,\n  sex: &quot;male&quot;,\n&#125;;</code></pre>\n\n<p><strong>缺点</strong></p>\n<ol>\n<li>无法检测到对象属性的新增或删除</li>\n<li>无法监听数组的变化</li>\n</ol>\n<p>由于 js 的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过 Object.defineProperty 方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性 或删除属性，这就需要另外处理。</p>\n<p>vue 在实现数组的响应式时，使用了一些 hack,把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的 push&#x2F;pop&#x2F;shift&#x2F;unshift&#x2F;splice&#x2F;sort&#x2F;reverse 7 个方法上，其他方法无法监听。<code>目前没读过源码，不晓得这搬来文章内容是否正确</code></p>\n<h2 id=\"数据劫持-Proxy\"><a href=\"#数据劫持-Proxy\" class=\"headerlink\" title=\"数据劫持 Proxy\"></a>数据劫持 Proxy</h2><p>Proxy,字面意思是代理，是 ES6 提供的一个新的 API,用于修改某些操作的默认行为，可以理解为在目标对象之前做一层拦截，外部所有的访问都必须通过这层拦截，通过这层拦截可以做很多事情，比如对数据进行过滤、修改或者收集信息之类</p>\n<p>ES6 原生提供的 Proxy 构造函数：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var proxy &#x3D; new Proxy(target, handler);</code></pre>\n\n<p>其中 obj 为 Proxy 要拦截的对象，handler 用来定制拦截的操作，返回一个新的代理对象 proxy；Proxy 代理特点：</p>\n<ul>\n<li>Proxy 的代理针对的是整个对象，而不是像 Object.defineProperty 针对某个属性。只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li>\n<li>Proxy 也可以监听数组的变化。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var proxy &#x3D; new Proxy([1, 2, 3], &#123;\n  get: function (target, property) &#123;\n    console.log(target, property);\n    return target[property];\n  &#125;,\n&#125;);\nproxy[0] &#x3D; 4;\nproxy.push(5);\nproxy.length;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let handler &#x3D; &#123;\n  get: function (target, key) &#123;\n    if (target[key] &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; target[key] !&#x3D;&#x3D; null) &#123;\n      return new Proxy(target[key], handler);\n    &#125;\n    collectDeps(); &#x2F;&#x2F; 收集依赖\n\n    return Reflect.get(target, key);\n  &#125;,\n  set(target, key, value) &#123;\n    if (key &#x3D;&#x3D;&#x3D; &quot;length&quot;) return true;\n    notifyRender(); &#x2F;&#x2F; 通知订阅者更新视图\n    return Reflect.set(target, key, value);\n  &#125;,\n&#125;;\n\nlet proxy &#x3D; new Proxy(data, handler);\nproxy.age &#x3D; 18; &#x2F;&#x2F; 支持新增属性\n\nlet proxy1 &#x3D; new Proxy(&#123; arr: [] &#125;, handler);\nproxy1.arr[0] &#x3D; &quot;proxy&quot;;</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://juejin.cn/post/7103837916274622494\" target=\"_blank\" >你还不知道 JavaScript 中的函数劫持么？</a><br><a href=\"https://wenku.baidu.com/view/a78cb667fd4733687e21af45b307e87101f6f8ea.html\" target=\"_blank\" >数据劫持</a></p>\n","text":"函数劫持函数劫持，在一个函数运行之前就把它劫持下来，添加我们想要的功能。 在函数运行之前，我们可以改变函数的参数，或者改变函数的返回值。 JavaScript 中的函数劫持是一个增强原有函数的技巧，一般我们用来对原有的 JavaScript 全局方法做一些能力的增强。 函数劫持原...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%8A%AB%E6%8C%81\"><span class=\"toc-text\">函数劫持</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81-defineProperty\"><span class=\"toc-text\">数据劫持 defineProperty</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-defineProperty\"><span class=\"toc-text\">Object.defineProperty()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81-Proxy\"><span class=\"toc-text\">数据劫持 Proxy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端基础- 数组对象方法实现原理","uid":"57a999928e12a5391c5331208745c7af","slug":"2022-06-10js-arr","date":"2022-06-10T07:06:40.000Z","updated":"2023-02-20T21:20:56.461Z","comments":true,"path":"api/articles/2022-06-10js-arr.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fres.cloudinary.com%2Fcitiar%2Fimage%2Fupload%2Fv1611373461%2Fucamc%2Fcommon%2Fthumb_5x_Javascript-O.png&refer=http%3A%2F%2Fres.cloudinary.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1657437058&t=2169b1ec59622a8e20039841292e4d8b","text":"提前终止循环见：2022-10-16js 哪些循环可以提前终止掉循环 for 循环 for...in some every 序号 方法 break continue return return true return false 提前终止循环 1 for 循环 成功 跳出本次循环...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":54,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":56,"path":"api/tags/前端基础.json"},{"name":"面试","slug":"面试","count":20,"path":"api/tags/面试.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"修补node_modules下源码","uid":"c3d5408da05b02828c848a49ca35cf59","slug":"2022-06-09patch-package","date":"2022-06-09T01:51:48.000Z","updated":"2022-09-16T13:54:56.137Z","comments":true,"path":"api/articles/2022-06-09patch-package.json","keywords":null,"cover":"http://t-blog-images.aijs.top/img/20220609160539.webp","text":"背景之前在简书上记录过，没迁移简书文章，所以重新记录 由于hexo-theme-aurora代码配色不是很友好，需要自定义配色，又不想改其 github 上代码，直接处理node_modules下的配色文件 安装 patch-packagepatch-package 包可以通过 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"工具","slug":"工具","count":26,"path":"api/categories/工具.json"}],"tags":[{"name":"npm","slug":"npm","count":5,"path":"api/tags/npm.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>举手向苍穹，并非一定要摘到星月</p><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}