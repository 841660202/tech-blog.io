{"title":"前端基础-js算法","uid":"b6eefb99ab4e0f88e52602483fde65dd","slug":"2022-07-04js","date":"2022-07-04T07:31:24.000Z","updated":"2023-02-20T21:20:56.464Z","comments":true,"path":"api/articles/2022-07-04js.json","keywords":null,"cover":[],"content":"<h2 id=\"实现单例\"><a href=\"#实现单例\" class=\"headerlink\" title=\"实现单例\"></a>实现单例</h2><h3 id=\"通过构造函数\"><a href=\"#通过构造函数\" class=\"headerlink\" title=\"通过构造函数\"></a>通过构造函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  constructor() &#123;\n    console.log(&quot;this&quot;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h3 id=\"通过静态方法\"><a href=\"#通过静态方法\" class=\"headerlink\" title=\"通过静态方法\"></a>通过静态方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"字符串相关\"><a href=\"#字符串相关\" class=\"headerlink\" title=\"字符串相关\"></a>字符串相关</h2><p><a href=\"/#/post/2022-05-03string\" target=\"_blank\" >见：2022-05-03string</a></p>\n<h2 id=\"深度操作\"><a href=\"#深度操作\" class=\"headerlink\" title=\"深度操作\"></a>深度操作</h2><h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><h4 id=\"structuredClone\"><a href=\"#structuredClone\" class=\"headerlink\" title=\"structuredClone\"></a>structuredClone</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/web/api/structuredClone\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Create an object with a value and a circular reference to itself.\nconst original &#x3D; &#123; name: &quot;MDN&quot; , hello: &#123;world: true&#125;&#125;;\noriginal.itself &#x3D; original;\n\n&#x2F;&#x2F; Clone it\nconst clone &#x3D; structuredClone(original);\n\nconsole.log(clone !&#x3D;&#x3D; original); &#x2F;&#x2F;  true  the objects are not the same (not same identity)\nconsole.log(clone.name &#x3D;&#x3D;&#x3D; &quot;MDN&quot;); &#x2F;&#x2F; true  they do have the same values\nconsole.log(clone.itself &#x3D;&#x3D;&#x3D; clone); &#x2F;&#x2F; true and the circular reference is preserved\nconsole.log(clone.hello &#x3D;&#x3D;&#x3D; original.hello) false</code></pre>\n\n<h4 id=\"深度克隆\"><a href=\"#深度克隆\" class=\"headerlink\" title=\"深度克隆\"></a>深度克隆</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function isBase &#x3D; (val) &#x3D;&gt; &#123;\n  return val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &quot;object&quot;\n&#125;\n\nfunction isObject(obj) &#123;\n  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Object]&quot;;\n&#125;\n\nfunction isArray(obj) &#123;\n  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Array]&quot;;\n&#125;\n\nfunction deepClone(obj) &#123;\n  let result;\n  if (isBase(obj)) &#123;\n    &#x2F;&#x2F;基本数据类型，直接赋值\n    result &#x3D; obj;\n  &#125; else &#123;\n    &#x2F;&#x2F; 非基本数据类型，遍历赋值\n    result &#x3D; isArray(obj) ? [] : &#123;&#125;; &#x2F;&#x2F; 空对象接收\n    for (let i in obj) &#123;\n      result[i] &#x3D;\n        isObject(obj[i]) || isArray(obj[i]) ? deepClone(obj[i]) : obj[i];\n    &#125;\n  &#125;\n  return result;\n&#125;</code></pre>\n\n<h4 id=\"深比较\"><a href=\"#深比较\" class=\"headerlink\" title=\"深比较\"></a>深比较</h4><p>实现一个 compare 函数，比较两个对象是否相同<a href=\"https://www.jianshu.com/p/0828ded57b19#:~:text=%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83-,%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A,-//%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 原理：\n * 1. 基本数据类型比较\n * 2. 复合类型，递归每个值依次比较\n **&#x2F;\n&#x2F;&#x2F; 基础类型&#x2F;null的数据类型，可以直接比较\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &quot;object&quot;;\n\nfunction deepCompare(a, b) &#123;\n  &#x2F;&#x2F; 基本数据类型\n  if (isBase(a) || isBase(b)) &#123;\n    return a &#x3D;&#x3D;&#x3D; b;\n  &#125;\n  &#x2F;&#x2F; Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。\n  const propsA &#x3D; Object.getOwnPropertyDescriptors(a);\n  const propsB &#x3D; Object.getOwnPropertyDescriptors(b);\n  &#x2F;&#x2F; 键是否长度一致\n  if (Object.keys(propsA).length !&#x3D;&#x3D; Object.keys(propsB).length) &#123;\n    return false;\n  &#125;\n  &#x2F;&#x2F; 键对应相等\n  return Object.keys(propsA).every((key) &#x3D;&gt; deepCompare(a[key], b[key]));\n&#125;</code></pre>\n\n<h4 id=\"深度获取差异化\"><a href=\"#深度获取差异化\" class=\"headerlink\" title=\"深度获取差异化\"></a>深度获取差异化</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 是否为基础数据类型\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &quot;object&quot;;\n\n&#x2F;&#x2F; 深度比较两个对象的差异\nfunction deepDiffCompare(a, b, diffResult, k &#x3D; &quot;root&quot;) &#123;\n  &#x2F;&#x2F; 基本数据类型\n  if (isBase(a) || isBase(b)) &#123;\n    &#x2F;&#x2F; return a &#x3D;&#x3D;&#x3D; b;\n    if (a !&#x3D;&#x3D; b) &#123;\n      diffResult[k] &#x3D; b;\n    &#125; else &#123;\n      &#x2F;&#x2F; console.log(&quot;数据一致忽略&quot;);\n    &#125;\n  &#125; else &#123;\n    const propsA &#x3D; Object.keys(a);\n    const propsB &#x3D; Object.keys(b);\n    const uukeys &#x3D; new Set([...propsA, ...propsB]);\n    &#x2F;&#x2F; 键对应相等\n    uukeys.forEach((key) &#x3D;&gt; deepDiffCompare(a[key], b[key], diffResult, key));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 必填数据\nconst requireds &#x3D; [&quot;sex&quot;];\n&#x2F;&#x2F; 模拟数据\nconst old &#x3D; &#123; name: 1, age: 2, dog: &#123; name: &quot;小狗&quot;, do: &quot;汪汪叫&quot; &#125; &#125;;\nconst newValue &#x3D; &#123; name: 1, age: 2, sex: 1 &#125;;\n&#x2F;&#x2F; 执行比较测试\nhandleCompare(old, newValue);\n\n&#x2F;&#x2F; 这里涉及到函数声明提升，写在后面不影响使用\nfunction handleCompare(old, newValue, onChange) &#123;\n  let diffResult &#x3D; &#123;&#125;;\n\n  deepDiffCompare(old, newValue, diffResult);\n\n  &#x2F;&#x2F; console.log(&quot;diffResult&quot;, diffResult);\n  &#x2F;&#x2F; 变化的数据，在必填数据中，则hasChange为true, 否则为false\n  const hasChange &#x3D; Object.keys(diffResult).some((k) &#x3D;&gt; requireds.includes(k));\n\n  &#x2F;&#x2F; console.log(&quot;hasChange&quot;, hasChange);\n  hasChange &amp;&amp; onChange?.();\n&#125;\n\n&#x2F;&#x2F; vue中使用\n&#x2F;&#x2F; watch: &#123;\n&#x2F;&#x2F;   &#39;submitForm&#39;: &#123;\n&#x2F;&#x2F;      handler(val, oldVal) &#123;\n&#x2F;&#x2F;       console.log(&#39;c changed&#39;)\n&#x2F;&#x2F;       handleCompare(oldVal, val, ()&#x3D;&gt;&#123;\n&#x2F;&#x2F;         this.clearTableData()\n&#x2F;&#x2F;       &#125;)\n&#x2F;&#x2F;     &#125;,\n&#x2F;&#x2F;     deep: true\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F;  &#125;</code></pre>\n\n<h4 id=\"深度拼接\"><a href=\"#深度拼接\" class=\"headerlink\" title=\"深度拼接\"></a>深度拼接</h4><p>实现 <code>json.stringify</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; JSON.stringify\n\nconst data &#x3D; &#123;\n  name: &#123; grades: [1, 23, 4] &#125;,\n  age: 2,\n  other: &#123; name: &#123; grades: [1, 23, 4] &#125; &#125;,\n&#125;;\n&#x2F;&#x2F; JSON.stringify(1)\n&#x2F;&#x2F; &#39;1&#39;\n\n&#x2F;&#x2F; JSON.stringify([1,2,3])\n&#x2F;&#x2F; &#39;[1,2,3]&#39;\n\n&#x2F;&#x2F; JSON.stringify(&#123;name: 1, grade: [1,2,34]&#125;)\n&#x2F;&#x2F; &#39;&#123;&quot;name&quot;:1,&quot;grade&quot;:[1,2,34]&#125;&#39;\n\n&#x2F;&#x2F; JSON.stringify(&#123;name: 1, grade: [1,2,34], obj: &#123;name: 1, grade: [1,2,34]&#125;&#125;)\n\n&#x2F;&#x2F; &#39;&#123;&quot;name&quot;:1,&quot;grade&quot;:[1,2,34],&quot;obj&quot;:&#123;&quot;name&quot;:1,&quot;grade&quot;:[1,2,34]&#125;&#125;&#39;\n\n&#x2F;&#x2F; var a &#x3D; &#39;&#123;name: 1, grade: [1,2,34], obj: &#123;name: 1, grade: [1,2,34]&#125;&#125;&#39;\n&#x2F;&#x2F; &#39;&#123;name: 1, grade: [1,2,34], obj: &#123;name: 1, grade: [1,2,34]&#125;&#125;&#39;\n\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &quot;object&quot;;\n&#x2F;&#x2F; prettier-ignore\nconst isNumber &#x3D; (val) &#x3D;&gt; Object.prototype.toString.call(val) &#x3D;&#x3D; &quot;[object Number]&quot;;\n&#x2F;&#x2F; prettier-ignore\nconst isArray &#x3D; (val) &#x3D;&gt; Object.prototype.toString.call(val) &#x3D;&#x3D; &quot;[object Array]&quot;;\n&#x2F;&#x2F; prettier-ignore\nconst isObject &#x3D; (val) &#x3D;&gt; Object.prototype.toString.call(val) &#x3D;&#x3D; &quot;[object Object]&quot;;\n\nfunction deepStr(obj) &#123;\n  let result &#x3D; &quot;&quot;;\n  &#x2F;&#x2F;  基本数据类型\n  if (isBase(obj)) &#123;\n    result &#x3D; &#96;$&#123;obj&#125;&#96;;\n    &#x2F;&#x2F; 非基本数据类型\n    &#x2F;&#x2F;  这里还有一种数据类型number是无限值时候会被处理成null\n  &#125; else &#123;\n    if (isArray(obj)) &#123;\n      const len &#x3D; obj?.length;\n      obj.forEach((element, index) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 拼左中括号\n        if (index &#x3D;&#x3D;&#x3D; 0) &#123;\n          result +&#x3D; &quot;[&quot;;\n        &#125;\n        &#x2F;&#x2F; 补逗号\n        result +&#x3D; deepStr(element) + (len - 1 &gt; index ? &quot;,&quot; : &quot;&quot;);\n\n        &#x2F;&#x2F; 拼右中括号\n        if (index &#x3D;&#x3D;&#x3D; len - 1) &#123;\n          result +&#x3D; &quot;]&quot;;\n        &#125;\n      &#125;);\n    &#125; else &#123;\n      const keys &#x3D; Object.keys(obj);\n      const len &#x3D; keys.length;\n\n      keys.forEach((key, index) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 拼左花括号\n        if (index &#x3D;&#x3D;&#x3D; 0) &#123;\n          result +&#x3D; &quot;&#123;&quot;;\n        &#125;\n        &#x2F;&#x2F; 补逗号\n        &#x2F;&#x2F; prettier-ignore\n        result +&#x3D; &#96;&quot;$&#123;key&#125;&quot;:$&#123;deepStr(obj[key]) + (len - 1 &gt; index ? &quot;,&quot; : &quot;&quot;)&#125;&#96;;\n\n        &#x2F;&#x2F; 拼右花括号\n        if (index &#x3D;&#x3D;&#x3D; len - 1) &#123;\n          result +&#x3D; &quot;&#125;&quot;;\n        &#125;\n      &#125;);\n    &#125;\n  &#125;\n  return result;\n&#125;\n\n&#x2F;&#x2F; var test_data_1 &#x3D; &#123; name: 1, age: 2, grades: [1, 2, 3] &#125;;\n&#x2F;&#x2F; console.log(&quot;deep&quot;, deepStr(test_data_1));\n&#x2F;&#x2F; console.log(&quot;json&quot;, JSON.stringify(test_data_1));\n\nconsole.log(&quot;deep&quot;, deepStr(data));\nconsole.log(&quot;json&quot;, JSON.stringify(data));</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON#polyfill\" target=\"_blank\" >MDN JSON.stringify js 实现</a></p>\n<p>MDN：有个错误的地方，是 JSON.stringify 本身处理函数的时候，会将函数给搞没了，在 polyfil 中处理的不对</p>\n<h4 id=\"深度解析\"><a href=\"#深度解析\" class=\"headerlink\" title=\"深度解析\"></a>深度解析</h4><p>实现 <code>json.parse</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"></code></pre>\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h3 id=\"uuid\"><a href=\"#uuid\" class=\"headerlink\" title=\"uuid\"></a>uuid</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const getUniqueID &#x3D; ((id) &#x3D;&gt; () &#x3D;&gt; &#123;\n  id +&#x3D; 1;\n  return id;\n&#125;)(-1);\n\n&#x2F;&#x2F; getUniqueID\n&#x2F;&#x2F; () &#x3D;&gt; &#123;\n&#x2F;&#x2F;   id +&#x3D; 1;\n&#x2F;&#x2F;   return id;\n&#x2F;&#x2F; &#125;</code></pre>\n\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 去抖动原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时.\n&#x2F;&#x2F; 方法1\nconst debounce &#x3D; function (fn, delay) &#123;\n  let timer &#x3D; null; &#x2F;&#x2F; 闭包维护一个timer\n  return (...args) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 柯里化\n    clearTimeout(timer);\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn?.apply(this, args); &#x2F;&#x2F; this指向window\n    &#125;, delay);\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; 测试\n\nlet biu &#x3D; function () &#123;\n  console.log(&quot;biu biu biu&quot;, new Date().getTime());\n&#125;;\nlet boom &#x3D; function () &#123;\n  console.log(&quot;boom boom boom&quot;, new Date().getTime());\n&#125;;\n\nvar a &#x3D; setInterval(debounce(biu, 500), 1000);\nvar b &#x3D; setInterval(debounce(boom, 2000), 1000);\nsetTimeout(() &#x3D;&gt; &#123;\n  clearInterval(a);\n  clearInterval(b);\n&#125;, 10000);</code></pre>\n\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const throttle &#x3D; (fn, delay &#x3D; 500) &#x3D;&gt; &#123;\n  let allow &#x3D; true; &#x2F;&#x2F; 守门员，delay秒钟放进去一个球\n\n  return (...args) &#x3D;&gt; &#123;\n    if (!allow) return;\n    allow &#x3D; false;\n\n    setTimeout(() &#x3D;&gt; &#123;\n      fn.apply(this, args);\n      allow &#x3D; true;\n    &#125;, delay);\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"接口数据缓存\"><a href=\"#接口数据缓存\" class=\"headerlink\" title=\"接口数据缓存\"></a>接口数据缓存</h3><h2 id=\"this-指向\"><a href=\"#this-指向\" class=\"headerlink\" title=\"this 指向\"></a>this 指向</h2><p><a href=\"https://juejin.cn/post/6977563249650696206\" target=\"_blank\" >https://juejin.cn/post/6977563249650696206</a></p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><ul>\n<li>语法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function.call(thisArg, arg1, arg2, ...)\n</code></pre>\n\n<p>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 即：可以改变当前函数的 this 指向；还会让当前函数执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 给函数原型添加mycall方法，创建一个上下文对象context，如果传入的对象不存在时，将指向全局window。\n&#x2F;&#x2F; 2. 通过给context添加fn属性，context的fn引用调用该方法的函数fun，并执行fun。\n&#x2F;&#x2F; 3. 执行完成之后删除该属性fn。\nFunction.prototype.mycall &#x3D; function (context, ...args) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  context &#x3D; context &#x3D;&#x3D; null || context &#x3D;&#x3D; undefined ? window : new Object(context);\n  context.fn &#x3D; this;\n  let r &#x3D; context.fn(...args);\n  delete context.fn;\n  return r;\n&#125;;\n\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123; name: &quot;clying&quot; &#125;;\nfun.mycall(obj, &quot;deng&quot;, &quot;deng&quot;);</code></pre>\n\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><ul>\n<li>语法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">apply(thisArg);\napply(thisArg, argsArray);</code></pre>\n\n<ol>\n<li>与 call 方法类似，call 方法接收的是一个参数列表，而 apply 方法接收的是一个包含多个参数的数组。</li>\n<li>用法 将函数中的 this 指向传入的第一个参数，第二个参数为数组</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Function.prototype.myapply &#x3D; function (context, args) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  context &#x3D; context &#x3D;&#x3D; null || context &#x3D;&#x3D; undefined ? window : new Object(context);\n\n  context.fn &#x3D; this;\n\n  if (!args) return context.fn();\n\n  let r &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;);\n  delete context.fn;\n  return r;\n&#125;;</code></pre>\n\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><ol>\n<li>bind() 方法创建一个新的函数，不自动执行，需要手动调用 bind() 。</li>\n<li>这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</li>\n<li>用法将 obj 绑定到 fun 函数的 this 上，函数 fun 可以使用 obj 内部的属性，和传入的变量。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Function.prototype.mybind &#x3D; function (context) &#123;\n  let that &#x3D; this;\n  let bindargs &#x3D; Array.prototype.slice.call(arguments, 1);\n  &#x2F;&#x2F; 产生闭包\n  function fBind() &#123;\n    let args &#x3D; Array.prototype.slice.call(arguments);\n    &#x2F;&#x2F; 1. 如果使用的是new，那么this会指向fBind实例，this作为当前实例传入\n    &#x2F;&#x2F; 2. 不是new的话，使用context上下文对象\n    &#x2F;&#x2F; prettier-ignore\n    return that.apply( this instanceof fBind ? this : context, bindargs.concat(args) &#x2F;&#x2F; 通过闭包获取更多的参数);\n  &#125;\n\n  return fBind;\n&#125;;\n\n&#x2F;&#x2F; 测试1\n\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123;\n  name: &quot;clying&quot;,\n&#125;;\nlet b &#x3D; fun.mybind(obj, 2);\nb(3);\n&#x2F;&#x2F; clying Arguments(2) [2, 3]\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F; 测试2\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123;\n  name: &quot;clying&quot;,\n&#125;;\nfun.prototype.age &#x3D; 23;\nlet b &#x3D; fun.mybind(obj, 3);\nlet instance &#x3D; new b(4);\nconsole.log(instance.age);\n&#x2F;&#x2F;undefined Arguments(2) [3, 4]\n&#x2F;&#x2F; 23</code></pre>\n\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p><a href=\"https://blog.csdn.net/weixin_45774485/article/details/122462081\" target=\"_blank\" >手写 promise 的方法（all、race、allSettled、any、finally）</a></p>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><ul>\n<li>要么返回全部 resolve 结果，要么返回一个 reject</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myAll &#x3D; function (promises) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    if (!isArray(promises)) &#123;\n      return reject(new TypeError(&quot;arguments must be an array&quot;));\n    &#125;\n\n    let res &#x3D; [];\n    var resolvedCounter &#x3D; 0;\n    var promiseNum &#x3D; promises.length;\n\n    promises.forEach((promise, index) &#x3D;&gt; &#123;\n      Promise.resolve(promise) &#x2F;&#x2F; 防止你不是一个promise\n        &#x2F;&#x2F; 如果参数是一个原始值,或者是一个不具有then方法的对象,则Promise.resolve方法返回一个新的 Promise 对象,状态为resolved\n        &#x2F;&#x2F; @link https:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html\n        .then((data) &#x3D;&gt; &#123;\n          resolvedCounter++;\n          res.push(data);\n          &#x2F;&#x2F; 所有的都没有异常\n          promiseNum &#x3D;&#x3D;&#x3D; resolvedCounter &amp;&amp; resolve(res);\n        &#125;)\n        .catch((err) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 捕获，直接返回\n          reject(err);\n        &#125;);\n    &#125;);\n  &#125;);\n&#125;;</code></pre>\n\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><ul>\n<li>不管 resolve, reject，见到就返回</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myRace &#x3D; (promises) &#x3D;&gt;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    promises?.forEach((promise) &#x3D;&gt; &#123;\n      promise.then(resolve, reject);\n    &#125;);\n  &#125;);</code></pre>\n\n<h3 id=\"Promise-allSettle\"><a href=\"#Promise-allSettle\" class=\"headerlink\" title=\"Promise.allSettle\"></a>Promise.allSettle</h3><ul>\n<li>全部结果，resolve, reject 都要</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myAllSettled &#x3D; function (promises) &#123;\n  let len &#x3D; promises.length;\n  let count &#x3D; 0;\n  let result &#x3D; new Array(len);\n\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    for (let p of promises) &#123;\n      Promise.resolve(p).then(\n        (res) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;成功：加入装状态列表\n          result[count] &#x3D; &#123;\n            &#x2F;&#x2F;记录当前promise信息\n            status: &quot;fullfilled&quot;,\n            result: res,\n          &#125;;\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F;遍历完，走resolve\n            resolve(result);\n          &#125;\n        &#125;,\n        (err) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;失败：加入状态列表\n          result[count] &#x3D; &#123;\n            &#x2F;&#x2F;记录当前promise状态信息\n            status: &quot;rejected&quot;,\n            result: err,\n          &#125;;\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F;遍历完依然走resolve\n            reject(result);\n          &#125;\n        &#125;\n      );\n    &#125;\n  &#125;);\n&#125;;</code></pre>\n\n<h3 id=\"Promise-any\"><a href=\"#Promise-any\" class=\"headerlink\" title=\"Promise.any\"></a>Promise.any</h3><ul>\n<li>要么没有 resolve 的,返回全部 reject 结果，要么有一个 resolve 的返回 resolve 结果(看上去和<code>Promise.all</code>刚好反过来了)</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.myAny &#x3D; function (promises) &#123;\n  let res &#x3D; [],\n    count &#x3D; 0,\n    len &#x3D; promises.length;\n\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    for (let p of promises) &#123;\n      Promise.resolve(p).then(\n        (res) &#x3D;&gt; &#123;\n          resolve(res); &#x2F;&#x2F; 只要有一个成功，就走resolve\n        &#125;,\n        (err) &#x3D;&gt; &#123;\n          res[count] &#x3D; err; &#x2F;&#x2F; 遇到错误先不管，继续检查\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F; 直到遇到成功的或检查完\n            reject(res);\n          &#125;\n        &#125;\n      );\n    &#125;\n  &#125;);\n&#125;;</code></pre>\n\n<h3 id=\"Promise-finally\"><a href=\"#Promise-finally\" class=\"headerlink\" title=\"Promise.finally\"></a>Promise.finally</h3><ul>\n<li>无论哪个执行完，回调下</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.prototype.myFinally &#x3D; function (cb) &#123;\n  &#x2F;&#x2F;cb就是要共同执行的逻辑\n  return this.then(\n    &#x2F;&#x2F;谁调用finally，this就是谁\n    (value) &#x3D;&gt; Promise.resolve(cb()), &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb\n    (error) &#x3D;&gt; Promise.resolve(cb()) &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb\n  );\n&#125;;</code></pre>\n\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p><a href=\"https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html\" target=\"_blank\" >见 Promise.resolve（）详解</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Promise.prototype.myResolve &#x3D; function (params) &#123;\n  return new Promise((resolve) &#x3D;&gt; resolve(params));\n&#125;;</code></pre>\n\n<h3 id=\"阻断-resolve-x2F-reject-后面代码还会执行\"><a href=\"#阻断-resolve-x2F-reject-后面代码还会执行\" class=\"headerlink\" title=\"阻断 resolve&#x2F;reject 后面代码还会执行\"></a>阻断 resolve&#x2F;reject 后面代码还会执行</h3><p><a href=\"https://www.freesion.com/article/68121031859/\" target=\"_blank\" >使用 Promise 过程中 resolve 或 reject 后，后面代码还会执行，默认加 return 较妥</a></p>\n<h3 id=\"限制并发数量\"><a href=\"#限制并发数量\" class=\"headerlink\" title=\"限制并发数量\"></a>限制并发数量</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 原理：将在用数量，限制在最大数量内的异步直接发，\n&#x2F;&#x2F; 限制外的现存到数组中，当在用数量减少时一个一个取出来运行\nexport class LimitPromise &#123;\n  private limit: number;        &#x2F;&#x2F; 最大限制数\n  private count: number;        &#x2F;&#x2F; 目前并发的数量\n  private taskQueue: any[];     &#x2F;&#x2F; 如果并发数等于最大限制，则把新加的异步操作用数组存起来\n\n  constructor(limit: number) &#123;\n    this.limit &#x3D; limit;\n    this.count &#x3D; 0;\n    this.taskQueue &#x3D; [];\n  &#125;\n  &#x2F;&#x2F; 管理任务执行\n  private createTask(\n    asyncFn: Function,\n    args: any[],\n    resolve: (value: unknown) &#x3D;&gt; void,\n    reject: (reason?: any) &#x3D;&gt; void,\n  ) &#123;\n    return () &#x3D;&gt; &#123;\n      asyncFn(...args)\n        .then(resolve)\n        .catch(reject)\n        .finally(() &#x3D;&gt; &#123;\n          this.count--; &#x2F;&#x2F; 任务结束后，对任务队列进行出列，执行\n          if (this.taskQueue.length) &#123;\n            let task &#x3D; this.taskQueue.shift();\n            task();\n          &#125;\n        &#125;);\n\n      this.count++; &#x2F;&#x2F; 在执行的数量\n    &#125;;\n  &#125;\n  &#x2F;&#x2F; 管理队列\n  public call(asyncFn: Function, ...args: any[]) &#123;\n    &#x2F;&#x2F; 这层promise令人费解，主要是为了提供resolve和reject给 limitP.call，\n    &#x2F;&#x2F; 这样limitP可以做些其他的事情，理论上没有必要\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      const task &#x3D; this.createTask(asyncFn, args, resolve, reject); &#x2F;&#x2F; 创建任务\n      if (this.count &gt;&#x3D; this.limit) &#123; &#x2F;&#x2F; 大于限制的存起来\n        this.taskQueue.push(task);\n      &#125; else &#123; &#x2F;&#x2F; 否则直接执行\n        task();\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n\nlet limitP &#x3D; new LimitPromise(3)\n\n&#x2F;&#x2F; 测试\nfunction sleep(sec: number) &#123;\n  console.log(&#39;..............&#39;);\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(&#39;等待了&#39; + sec + &#39;秒&#39;);\n      resolve(&#39;&#39;);\n    &#125;, sec * 1000);\n  &#125;);\n&#125;\n\nlimitP.call(sleep, 1);\nlimitP.call(sleep, 2);\nlimitP.call(sleep, 3);\nlimitP.call(sleep, 4);\nlimitP.call(sleep, 5);\nlimitP.call(sleep, 6);\n&#x2F;&#x2F; https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;typescript-sdhev3?file&#x3D;index.ts</code></pre>\n\n<h2 id=\"async-await-原理实现\"><a href=\"#async-await-原理实现\" class=\"headerlink\" title=\"async await 原理实现\"></a>async await 原理实现</h2><p><a href=\"https://juejin.cn/post/7007031572238958629#heading-15\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function generatorToAsync(generatorFn) &#123;\n  return function () &#123;\n    const gen &#x3D; generatorFn.apply(this, arguments); &#x2F;&#x2F; gen有可能传参\n\n    &#x2F;&#x2F; 返回一个Promise\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      function go(key, arg) &#123;\n        let res;\n        try &#123;\n          res &#x3D; gen[key](arg); &#x2F;&#x2F; 这里有可能会执行返回reject状态的Promise\n        &#125; catch (error) &#123;\n          return reject(error); &#x2F;&#x2F; 报错的话会走catch，直接reject\n        &#125;\n\n        &#x2F;&#x2F; 解构获得value和done\n        const &#123; value, done &#125; &#x3D; res;\n        if (done) &#123;\n          &#x2F;&#x2F; 如果done为true，说明走完了，进行resolve(value)\n          return resolve(value);\n        &#125; else &#123;\n          &#x2F;&#x2F; 如果done为false，说明没走完，还得继续走\n\n          &#x2F;&#x2F; value有可能是：常量，Promise，Promise有可能是成功或者失败\n          return Promise.resolve(value).then(\n            (val) &#x3D;&gt; go(&quot;next&quot;, val),\n            (err) &#x3D;&gt; go(&quot;throw&quot;, err)\n          );\n        &#125;\n      &#125;\n\n      go(&quot;next&quot;); &#x2F;&#x2F; 第一次执行\n    &#125;);\n  &#125;;\n&#125;\n\nconst asyncFn &#x3D; generatorToAsync(gen);\n\nasyncFn().then((res) &#x3D;&gt; console.log(res));</code></pre>\n\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><p><a href=\"https://blog.csdn.net/weixin_45663702/article/details/123504807\" target=\"_blank\" >常见前端面试题–数组去重</a></p>\n<p>方案 1:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function unique(arr) &#123;\n  return Array.from(new Set(arr));\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [&#39;1&#39;, &#39;true&#39;, true, 15, undefined, null, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]\n&#x2F;&#x2F;无法去掉&#39;&#123;&#125;&#39;空对象</code></pre>\n\n<p>方案 2:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function unique(arr) &#123;\n  return arr.filter(function (item, index, arr) &#123;\n    &#x2F;&#x2F; 当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;\n  &#125;);\n&#125;\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]\n&#x2F;&#x2F; &#123;&#125;不能去重</code></pre>\n\n<p>方案 3:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function unique(arr) &#123;\n  return arr.reduce(\n    (prev, cur) &#x3D;&gt; (prev.includes(cur) ? prev : [...prev, cur]),\n    []\n  );\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]</code></pre>\n\n<h3 id=\"将奇数排在前面，偶数排在后面\"><a href=\"#将奇数排在前面，偶数排在后面\" class=\"headerlink\" title=\"将奇数排在前面，偶数排在后面\"></a>将奇数排在前面，偶数排在后面</h3><p>要求时间复杂度 O(n)。空间复杂度 O(1)（不能用 splice）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var testAry &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9];\nvar newAry &#x3D; [];\n\ntestAry.forEach((item, i) &#x3D;&gt; &#123;\n  let n &#x3D; Number(item);\n  if (n % 2 &#x3D;&#x3D; 0) &#123;\n    newAry.push(n);\n  &#125; else &#123;\n    newAry.unshift(n);\n  &#125;\n&#125;);\n\nconsole.log(newAry); &#x2F;&#x2F;[&quot;9&quot;,&quot;7&quot;,&quot;5&quot;,&quot;3&quot;,&quot;1&quot;,&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]</code></pre>\n\n<h3 id=\"数组转树结构\"><a href=\"#数组转树结构\" class=\"headerlink\" title=\"数组转树结构\"></a>数组转树结构</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [\n    &#123; id: 1, pid: 0 &#125;,\n    &#123; id: 2, pid: 1 &#125;,\n    &#123; id: 3, pid: 1 &#125;,\n    &#123; id: 4, pid: 2 &#125;,\n    &#123; id: 5, pid: 2 &#125;,\n    &#123; id: 6, pid: 3 &#125;,\n];\n&#x2F;&#x2F; 要求编写一个函数 arr2tree(arr)，得到输出结果如下：\n\n&#123;\n    &quot;id&quot;: 0,\n    &quot;children&quot;: [\n        &#123;\n            &quot;id&quot;: 1,\n            &quot;children&quot;: [\n                &#123;\n                    &quot;id&quot;: 2,\n                    &quot;children&quot;: [\n                        &#123;\n                            &quot;id&quot;: 4\n                        &#125;,\n                        &#123;\n                            &quot;id&quot;: 5\n                        &#125;\n                    ]\n                &#125;,\n                &#123;\n                    &quot;id&quot;: 3,\n                    &quot;children&quot;: [\n                        &#123;\n                            &quot;id&quot;: 6\n                        &#125;\n                    ]\n                &#125;\n            ]\n        &#125;\n    ]\n&#125;</code></pre>\n\n<p><strong>实现</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function arr2tree(arr) &#123;\n  let hash &#x3D; &#123;&#125;;\n  const result &#x3D; [];\n  &#x2F;&#x2F; 放到对象中\n  for (let item of arr) &#123;\n    hash[item.id] &#x3D; item;\n  &#125;\n\n  for (let item of arr) &#123;\n    const parent &#x3D; hash[item.pid];\n    if (parent) &#123;\n      if (!parent.children) &#123;\n        parent.children &#x3D; [];\n      &#125;\n      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除\n      parent.children.push(item); &#x2F;&#x2F; 之所以能够实现，原因：使用了数组引用\n    &#125; else &#123;\n      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除\n      result.push(item); &#x2F;&#x2F; 只有第一次pid &#x3D; 0的时候，树根节点才走这里\n    &#125;\n  &#125;\n  hash &#x3D; undefined; &#x2F;&#x2F; 这里记得回收\n  return result;\n&#125;\n\nconst res &#x3D; arr2tree(arr);\nconsole.log(&quot;res&quot;, JSON.stringify(res, null, 2));</code></pre>\n\n<h2 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h2><h3 id=\"解析-URL-中所有的部分\"><a href=\"#解析-URL-中所有的部分\" class=\"headerlink\" title=\"解析 URL 中所有的部分\"></a>解析 URL 中所有的部分</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1.  拆分？后面的内容\n&#x2F;&#x2F; 2.  key\n&#x2F;&#x2F;     1.  无 value 转化成 true\n&#x2F;&#x2F;     2.  纯数字的转化成 数值\n&#x2F;&#x2F;     3.  value 是 数组&#x2F;对象\nfunction parseParam(url) &#123;\n  const paramsStr &#x3D; &#x2F;.+\\?(.+)$&#x2F;.exec(url)[1]; &#x2F;&#x2F; ?之后部分截取\n  const paramsArr &#x3D; paramsStr.split(&quot;&amp;&quot;); &#x2F;&#x2F; 拆分kv对\n  let paramsObj &#x3D; &#123;&#125;;\n\n  paramsArr.forEach((param) &#x3D;&gt; &#123;\n    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;\n      let [key, val] &#x3D; param.split(&quot;&#x3D;&quot;);\n\n      val &#x3D; decodeURIComponent(val); &#x2F;&#x2F; 解码\n\n      val &#x3D; &#x2F;^\\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 字符串数值转化\n\n      if (paramsObj.hasOwnProperty(key)) &#123;\n        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 这个没有直接push, 利用concat特性（数组concat,非数组push）\n      &#125; else &#123;\n        paramsObj[key] &#x3D; val;\n      &#125;\n    &#125; else &#123;\n      &#x2F;&#x2F; 有些没有&#x3D;号\n      paramsObj[param] &#x3D; true;\n    &#125;\n  &#125;);\n  return paramsObj;\n&#125;</code></pre>\n\n<!-- ## 使用 es5 实现 es6 的 let 关键字\n\n<a href=\"https://blog.csdn.net/weixin_44242181/article/details/124340622\" target=\"_blank\" >es5 实现 es6+新特性</a> -->\n\n<h3 id=\"中划线转大写\"><a href=\"#中划线转大写\" class=\"headerlink\" title=\"中划线转大写\"></a>中划线转大写</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var str &#x3D; &quot;get-user-by-id&quot;;\n\nvar f &#x3D; function (s) &#123;\n  return s.replace(&#x2F;-\\w&#x2F;g, function (x) &#123;\n    return x.slice(1).toUpperCase();\n  &#125;);\n&#125;;</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#:~:text=%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0-,%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%AF%E4%BB%A5%E6%8F%92%E5%85%A5%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%9A,-%E5%8F%98%E9%87%8F%E5%90%8D\" target=\"_blank\" >替换字符串可以插入下面的特殊变量名：</a></p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>代表的值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>$$</code></td>\n<td>插入一个 “$”。</td>\n</tr>\n<tr>\n<td><code>$&amp;</code></td>\n<td>插入匹配的子串。</td>\n</tr>\n<tr>\n<td>$&#96;</td>\n<td>插入当前匹配的子串左边的内容。</td>\n</tr>\n<tr>\n<td><code>$&#39;</code></td>\n<td>插入当前匹配的子串右边的内容。</td>\n</tr>\n<tr>\n<td><code>$n</code></td>\n<td>假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。</td>\n</tr>\n<tr>\n<td><code>$&lt;Name&gt;</code></td>\n<td>这里<em>Name</em> 是一个分组名称。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>$n</code> : 提示：索引是从 1 开始。如果不存在第 n 个分组，那么将会把匹配到到内容替换为字面量。比如不存在第 3 个分组，就会用“$3”替换匹配到的内容。</li>\n<li><code>$&lt;Name&gt;</code>: 如果在正则表达式中并不存在分组（或者没有匹配），这个变量将被处理为空字符串。只有在支持命名分组捕获的浏览器中才能使用。</li>\n</ol>\n<h3 id=\"金额千分\"><a href=\"#金额千分\" class=\"headerlink\" title=\"金额千分\"></a>金额千分</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function parseToMoney(num) &#123;\n  num &#x3D; parseFloat(num).toFixed(3);\n\n  let [integer, decimal] &#x3D; String.prototype.split.call(num, &quot;.&quot;);\n\n  integer &#x3D; integer.replace(&#x2F;\\d(?&#x3D;(\\d&#123;3&#125;)+$)&#x2F;g, &quot;$&amp;,&quot;);\n  &#x2F;&#x2F; 从右到左“三个数值一组” ?&#x3D; 尽可能多的去匹配\n\n  return &#96;$&#123;integer&#125;.$&#123;decimal&#125;&#96;;\n&#125;\n\nconsole.log(parseToMoney(10000000.0));\n\n&#x2F;&#x2F; $&amp; 与regexp相匹配的子串。 &#x2F;&#x2F; https:&#x2F;&#x2F;q.cnblogs.com&#x2F;q&#x2F;63769&#x2F;</code></pre>\n\n<p><a href=\"https://regexper.com/#%2F%5Cd%28%3F%3D%28%5Cd%7B3%7D%29%2B%24%29%2Fg\" target=\"_blank\" >&#x2F;\\d(?&#x3D;(\\d{3})+$)&#x2F;g</a></p>\n<h2 id=\"原理实现\"><a href=\"#原理实现\" class=\"headerlink\" title=\"原理实现\"></a>原理实现</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><p><a href=\"/#/post/2022-06-16interview#:~:text=new%20%E5%92%8C%20Object.create%20%E9%83%BD%E6%98%AF%E5%88%9B%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E6%80%9D%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F\" target=\"_blank\" >见</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; @link: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;new\n&#x2F;&#x2F; 1. 创建一个空的简单 JavaScript 对象（即 &#123;&#125;）；\n&#x2F;&#x2F; 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；\n&#x2F;&#x2F; 3. 将步骤 1 新创建的对象, 作为 this 的上下文；\n&#x2F;&#x2F; 4. 如果该函数没有返回对象，则返回 this。\nfunction myNew() &#123;\n  &#x2F;&#x2F; 1. 创建一个空的简单 JavaScript 对象（即 &#123;&#125;）；\n  let obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；\n  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数\n  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型\n  &#x2F;&#x2F; 3. 将步骤 1 新创建的对象, 作为 this 的上下文；\n  const result &#x3D; func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数\n  &#x2F;&#x2F; 4. 如果该函数没有返回对象，则返回 this。\n  return result intanceof Object ? result :  obj;\n&#125;</code></pre>\n\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;</code></pre>\n\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function instance_of(L, R) &#123;\n  var O &#x3D; R.prototype; &#x2F;&#x2F; 取R的显示原型\n  L &#x3D; L.__proto__; &#x2F;&#x2F; 取L的隐式原型\n\n  while (true) &#123;\n    &#x2F;&#x2F; 死循环，结束条件：要么找到，要么没找到\n    if (L &#x3D;&#x3D;&#x3D; null) return false;\n\n    if (O &#x3D;&#x3D;&#x3D; L) &#123;\n      &#x2F;&#x2F; 这里重点：当O严格等于L时，返回true\n      return true;\n    &#125;\n    L &#x3D; L.__proto__;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>本质是一个 hack,利用<code>&lt;script&gt;</code>标签不受同源侧露限制的特性进行跨域操作</p>\n<p><a href=\"https://blog.csdn.net/weixin_42371354/article/details/104651961\" target=\"_blank\" >参考链接</a><br><a href=\"https://blog.csdn.net/qq_38800316/article/details/120440865\" target=\"_blank\" >jsonp 函数封装</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 生成个函数名\n&#x2F;&#x2F; 2. 整理参数，生成请求url\n&#x2F;&#x2F; 3. 动态创建script标签，并挂载\n&#x2F;&#x2F; 4. 加载完成后移除script标签\nfunction jsonP(&#123; url, params, success &#125;) &#123;\n  &#x2F;&#x2F; 在参数里制定callback的名字\n  params &#x3D; params || &#123;&#125;;\n  &#x2F;&#x2F; 预留callback\n  const funcName &#x3D; &quot;func&quot; + Math.random().toString().replace(&quot;.&quot;, &quot;&quot;);\n  &#x2F;&#x2F; 这样依赖，服务器端一个req.query.callback就可以获取到动态的函数名\n  params.callback &#x3D; funcName;\n  window[funcName] &#x3D; success;\n\n  &#x2F;&#x2F; 拼接参数字符串\n  const paramKeys &#x3D; Object.keys(params);\n  const paramString &#x3D; paramKeys.map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;).join(&quot;&amp;&quot;);\n\n  &#x2F;&#x2F; 插入dom元素\n  const script &#x3D; document.createElement(&quot;script&quot;);\n\n  script.setAttribute(&quot;src&quot;, &#96;$&#123;url&#125;?$&#123;paramString&#125;&#96;);\n\n  document.body.appendChild(script);\n  &#x2F;&#x2F; 监听script标签的onload事件，当script标签执行后将其删除，避免代码结构的冗余\n  script.onload &#x3D; function () &#123;\n    &#x2F;&#x2F; 从body的删除掉添加的script标签\n    document.body.removeChild(script);\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 使用\n\njsonP(&#123;\n  url: &quot;https:&#x2F;&#x2F;example.com&#x2F;ajax&#x2F;jsonp&#x2F;suggestion&quot;,\n  params: &#123;\n    key: &quot;test&quot;,\n  &#125;,\n  success(result) &#123;\n    console.log(result.data);\n  &#125;,\n&#125;);</code></pre>\n\n<h3 id=\"实现-event-bus\"><a href=\"#实现-event-bus\" class=\"headerlink\" title=\"实现 event bus\"></a>实现 event bus</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. 监听收集（on&#x2F;once）\n&#x2F;&#x2F; 2. 触发监听(emit)\n&#x2F;&#x2F; 3. 解除监听(off)\n&#x2F;&#x2F; 4. 清空监听(clear)\nclass EventBus &#123;\n  constructor() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n  &#x2F;&#x2F; 监听，给对象添加方法\n  on(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) &#123;\n      events[name] &#x3D; [];\n    &#125;\n    events[name].push(callback);\n  &#125;\n  &#x2F;&#x2F; 取出来执行\n  emit(name, ...args) &#123;\n    const handlers &#x3D; this.events[name];\n    handlers &amp;&amp;\n      handlers.forEach((fn) &#x3D;&gt; &#123;\n        fn.apply(this, args);\n      &#125;);\n  &#125;\n  &#x2F;&#x2F; 解除\n  off(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) return;\n    events[name] &#x3D; events[name].filter((fn) &#x3D;&gt; fn !&#x3D;&#x3D; callback); &#x2F;&#x2F; 引用，指向对象，直接改kv键值对\n  &#125;\n  &#x2F;&#x2F;  用完立马、解除\n  once(name, callback) &#123;\n    const handler &#x3D; function () &#123;\n      callback.apply(this, arguments); &#x2F;&#x2F; 普通函数参数\n      this.off(name, handler);\n    &#125;;\n    this.on(name, handler);\n  &#125;\n  &#x2F;&#x2F; 事件清空\n  clear() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h2><h3 id=\"柯里化是什么\"><a href=\"#柯里化是什么\" class=\"headerlink\" title=\"柯里化是什么\"></a>柯里化是什么</h3><p><a href=\"https://article.itxueyuan.com/46m5K2\" target=\"_blank\" >见</a><br>在计算机科学中，柯里化（Currying）<code>是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</code>。这个技术以逻辑学家 Haskell Curry 命名的。</p>\n<ol>\n<li>柯里化突出一种重要思想：<code>降低适用范围</code>，<code>提高适用性</code></li>\n<li>柯里化的三个作用和特点：<code>参数复用</code>、<code>提前返回</code>、<code>延迟执行</code></li>\n<li>柯里化是闭包的一个典型应用:<ol>\n<li><code>利用闭包形成了一个保存在内存中的作用域，把接收到的部分参数保存在这个作用域中，等待后续使用</code>。</li>\n<li>并且返回一个新函数接收剩余参数</li>\n</ol>\n</li>\n</ol>\n<p><a href=\"https://juejin.cn/post/6844903814139478030\" target=\"_blank\" >函数柯里化和偏函数应用</a></p>\n<ul>\n<li><p>柯里化和偏函数都是用于将多个参数函数，转化为接受更少参数函数的方法。传入部分参数后，处于中间状态的函数可以作为固定值进行复用。但是其中不同之处在于：</p>\n</li>\n<li><p><code>柯里化</code>是将函数转化为多个嵌套的一元函数，也就是每个函数只接受一个参数。</p>\n</li>\n<li><p><code>偏函数</code>可以接受不只一个参数，它被固定了部分参数作为预设，并可以接受剩余的参数</p>\n</li>\n</ul>\n<p>作者：LanceT<br>链接：<a href=\"https://juejin.cn/post/6844903814139478030\">https://juejin.cn/post/6844903814139478030</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h3 id=\"洋葱模型\"><a href=\"#洋葱模型\" class=\"headerlink\" title=\"洋葱模型\"></a>洋葱模型</h3><p><a href=\"https://github.com/841660202/redux/blob/2edd0363271af46e327e118f3d92e78e258bf0cd/src/compose.ts#L46\" target=\"_blank\" >redux compose 源码</a></p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 1. 无函数\n&#x2F;&#x2F; 2. 1个函数\n&#x2F;&#x2F; 3. 多个函数\nexport default function compose(...funcs: Function[]) &#123;\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line\n    return &lt;T&gt;(arg: T) &#x3D;&gt; arg;\n  &#125;\n\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0];\n  &#125;\n  &#x2F;&#x2F; prettier-ignore\n  return funcs.reduce((a, b) &#x3D;&gt; (...args: any) &#x3D;&gt; a(b(...args)));\n&#125;</code></pre>\n\n<h2 id=\"数据代理-x2F-劫持\"><a href=\"#数据代理-x2F-劫持\" class=\"headerlink\" title=\"数据代理&#x2F;劫持\"></a>数据代理&#x2F;劫持</h2><p><a href=\"https://www.freesion.com/article/47611264830/\" target=\"_blank\" >数据劫持|数据代理</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" >MDN</a></p>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><p><a href=\"https://blog.csdn.net/xgangzai/article/details/128489924\" target=\"_blank\" >Proxy &amp; Reflect </a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Proxy\n&#x2F;&#x2F;  数据对象\nlet obj &#x3D; &#123;\n  name: &quot;Eason&quot;,\n  age: 30,\n&#125;;\n&#x2F;&#x2F; 处理\nlet handler &#x3D; &#123;\n  get(target, key, receiver) &#123;\n    console.log(&quot;get&quot;, key);\n    return Reflect.get(target, key, receiver);\n  &#125;,\n  set(target, key, value, receiver) &#123;\n    console.log(&quot;set&quot;, key, value);\n    return Reflect.set(target, key, value, receiver);\n  &#125;,\n&#125;;\n\nlet proxy &#x3D; new Proxy(&#123; ...obj &#125;, handler);\n\nproxy.name &#x3D; &quot;Zoe&quot;; &#x2F;&#x2F; set name Zoe\nproxy.age &#x3D; 18; &#x2F;&#x2F; set age 18\n\n&#x2F;&#x2F; defineProperty\n\nlet arr &#x3D; [1, 2, 3];\nlet obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, &quot;arr&quot;, &#123;\n  get() &#123;\n    console.log(&quot;get arr&quot;);\n    return arr;\n  &#125;,\n  set(newVal) &#123;\n    console.log(&quot;set&quot;, newVal);\n    arr &#x3D; newVal;\n  &#125;,\n&#125;);\nobj.arr.push(4); &#x2F;&#x2F; 只会打印 get arr, 不会打印 set\nobj.arr &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; 这个能正常 set</code></pre>\n\n<h3 id=\"defineProperty\"><a href=\"#defineProperty\" class=\"headerlink\" title=\"defineProperty\"></a>defineProperty</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; defineProperty\n\nlet arr &#x3D; [1, 2, 3];\nlet obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, &quot;arr&quot;, &#123;\n  get() &#123;\n    console.log(&quot;get arr&quot;);\n    return arr;\n  &#125;,\n  set(newVal) &#123;\n    console.log(&quot;set&quot;, newVal);\n    arr &#x3D; newVal;\n  &#125;,\n&#125;);\nobj.arr.push(4); &#x2F;&#x2F; 只会打印 get arr, 不会打印 set\nobj.arr &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; 这个能正常 set</code></pre>\n\n<h3 id=\"a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true\"><a href=\"#a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true\" class=\"headerlink\" title=\"(a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true\"></a>(a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true</h3><p><a href=\"https://blog.csdn.net/RedaTao/article/details/107170267\" target=\"_blank\" >a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3</a></p>\n<p>什么样的 a 可以满足 (a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true 呢？(注意是 3 个 &#x3D;，也就是严格相等)???</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let i &#x3D; 1;\nObject.defineProperty(window, &quot;a&quot;, &#123;\n  get: function () &#123;\n    return i++;\n  &#125;,\n&#125;);\n\nconsole.log(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3);</code></pre>\n\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p><strong>什么是链表</strong></p>\n<p>数据的一种存储结构，一个链表包含若干个节点，每个节点至少包含一个数据域和指针域</p>\n<p><a href=\"https://wenku.baidu.com/view/33d6ed103a68011ca300a6c30c2259010302f35b.html\" target=\"_blank\" >百度文库(收费了，只能看部分)、参考链接</a></p>\n<p><a href=\"https://blog.csdn.net/m0_47109503/article/details/117566907\" target=\"_blank\" >参考链接</a></p>\n<h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员\n    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员\n  &#125;\n&#125;\n&#x2F;&#x2F; 定义一个单向链表类\nclass singleLinked &#123;\n  constructor() &#123;\n    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数\n    this.head &#x3D; new Node(&quot;head&quot;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址\n    this.currentNode &#x3D; &quot;&quot;;\n  &#125;\n  &#x2F;&#x2F; 获取链表的长度\n  getLength() &#123;\n    return this.size;\n  &#125;\n  &#x2F;&#x2F; 判断链表是否为空\n  isEmpty() &#123;\n    return this.size &#x3D;&#x3D;&#x3D; 0;\n  &#125;\n  &#x2F;&#x2F; 遍历链表：不重复访问链表中的每个节点\n  displayList() &#123;\n    var list &#x3D; &quot;&quot;;\n    var currentNode &#x3D; this.head; &#x2F;&#x2F; 指向链表的头指针\n    while (currentNode) &#123;\n      &#x2F;&#x2F; 如果当前节点不为空，则表明当前节点中存在数据\n      list +&#x3D; currentNode.data;\n      &#x2F;&#x2F; 同时让当前节点的指针指向下一个节点\n      currentNode &#x3D; currentNode.next;\n\n      if (currentNode) &#123;\n        &#x2F;&#x2F; 如果当前节点的下一个节点不为空\n        list +&#x3D; &quot;-&gt;&quot;; &#x2F;&#x2F; 拼接后看起来像一个链表\n      &#125;\n    &#125;\n    console.log(list);\n  &#125;\n\n  &#x2F;&#x2F; 获取链表的最后一个节点\n  findLast() &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    return currentNode;\n  &#125;\n\n  &#x2F;&#x2F; 采用尾插法在链表尾部添加元素，即创建一个链表\n  appendNode(element) &#123;\n    var currentNode &#x3D; this.findLast(); &#x2F;&#x2F; 找到链表的最后一个节点\n    var newNode &#x3D; new Node(element); &#x2F;&#x2F; 创建一个新节点\n    currentNode.next &#x3D; newNode; &#x2F;&#x2F; 把新的节点放在链表里去（放在最后一个的后面）\n    newNode.next &#x3D; null; &#x2F;&#x2F; 因为新节点已经是链表最后一个节点\n    this.size++; &#x2F;&#x2F; 因为新插入一个节点，让链表的长度+1\n  &#125;\n  &#x2F;&#x2F; 删除一个节点\n  deleteNode(element) &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    &#x2F;&#x2F; 将链的节点与另一个节点连上\n    currentNode.next &#x3D; currentNode.next.next;\n    this.size--;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 上述链表代码的测试\n&#x2F;&#x2F; 最好使用循环，往里面加数据\nvar slist &#x3D; new singleLinked();\n\nvar arr &#x3D; [1001, 1234, 1006, 7788, 5512, 6129];\nfor (var i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  slist.appendNode(arr[i]);\n&#125;\nslist.displayList();\nslist.deleteNode(1001);\nslist.displayList();</code></pre>\n\n<h3 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h3><p><a href=\"https://blog.csdn.net/dingshao1114/article/details/105340579\" target=\"_blank\" >js 数据结构之双向链表 doublyLinkedList</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"></code></pre>\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/afb80e39ce7684d6330fdc66b0873abd.gif\" width=300 />\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/76339a259488423b03370e381ca5edb0.gif\" width=300/>\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/c894e22dcc48b03559e3087627e3dbb8.gif\" width=300/>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><img src=\"https://img-blog.csdnimg.cn/956f63eccd75480791c85edd8ce91658.gif\" width=300/>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><img src=\"http://t-blog-images.aijs.top/img/1940317-acc6c6f16b096794.gif\" />\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><img src=\"https://img-blog.csdnimg.cn/img_convert/4ad3b539bee9bfe9a6acdba476ceed78.gif\" width=300 />\n\n<img src=\"http://t-blog-images.aijs.top/img/20220704153839.webp\" />\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;*\n快排是冒泡的一种改进，基于分治思想\n*&#x2F;\nconst arr2 &#x3D; [2, 44, 1, 0, -22, 56, -78];\n\nfunction quickSort2(arr) &#123;\n  if (arr.length &#x3D;&#x3D;&#x3D; 0) return arr;\n\n  const pivot &#x3D; arr.pop(); &#x2F;&#x2F; 使用最后一个元素当作基准数\n  &#x2F;&#x2F; prettier-ignore\n  const left &#x3D; [], right &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; pivot) left.push(arr[i]); &#x2F;&#x2F; 小于基准数则放到left\n    else right.push(arr[i]); &#x2F;&#x2F; 大于基准数则放到right\n  &#125;\n  &#x2F;&#x2F; 合并left的快排结果，基准数和右侧的快排结果\n  return quickSort2(left).concat(pivot, quickSort2(right));\n&#125;\n\nconsole.log(quickSort2(arr2));</code></pre>\n\n<h2 id=\"LRU-算法\"><a href=\"#LRU-算法\" class=\"headerlink\" title=\"LRU 算法\"></a>LRU 算法</h2><p><code>LRU 定义</code>： 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择内存中最近最久未使用的页面予以淘汰。</p>\n<p><code>使用场景</code>：正如定义所说，如果我们想要实现缓存机制 – 满足最近最少使用淘汰原则，我们就可以使用 LRU 算法缓存机制。如：vue 中 keep-alive 中就用到了此算法。</p>\n<p><code>实现思路</code>： – 维护一个数组，提供 get 和 put 两个方法，并且限制数组元素数量（及缓存数量）</p>\n<p><code>实现方法</code>：</p>\n<pre><code>1. get 可以标记某个元素是最新使用的，提升到第一项\n2. put 可以加入一个 key-value 元素，但是需要判断是否已存在，是否超出限额\n</code></pre>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 时间复杂度 O(1)，因为 Map 既能保持键值对，还能记住插入顺序。\nvar LRUCache &#x3D; function (capacity) &#123;\n  this.cache &#x3D; new Map();\n  this.capacity &#x3D; capacity;\n&#125;;\n\nLRUCache.prototype.get &#x3D; function (key) &#123;\n  if (this.cache.has(key)) &#123;\n    &#x2F;&#x2F; 存在即更新\n    let temp &#x3D; this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, temp);\n    return temp;\n  &#125;\n  return -1;\n&#125;;\n\nLRUCache.prototype.put &#x3D; function (key, value) &#123;\n  &#x2F;&#x2F; 存在即更新（删除后加入）\n  if (this.cache.has(key)) &#123;\n    this.cache.delete(key);\n    &#x2F;&#x2F; 不存在即加入\n    &#x2F;&#x2F; 缓存超过最大值，则移除最近没有使用的\n  &#125; else if (this.cache.size &gt;&#x3D; this.capacity) &#123;\n    &#x2F;&#x2F; new Map().keys() 返回一个新的 Iterator 对象\n    this.cache.delete(this.cache.keys().next().value);\n  &#125;\n  this.cache.set(key, value);\n&#125;;</code></pre>\n\n<h2 id=\"leecode\"><a href=\"#leecode\" class=\"headerlink\" title=\"leecode\"></a>leecode</h2><h3 id=\"红包算法\"><a href=\"#红包算法\" class=\"headerlink\" title=\"红包算法\"></a>红包算法</h3><h3 id=\"括号匹配\"><a href=\"#括号匹配\" class=\"headerlink\" title=\"括号匹配\"></a>括号匹配</h3><h3 id=\"螺旋矩阵\"><a href=\"#螺旋矩阵\" class=\"headerlink\" title=\"螺旋矩阵\"></a>螺旋矩阵</h3><h3 id=\"大数相加\"><a href=\"#大数相加\" class=\"headerlink\" title=\"大数相加\"></a>大数相加</h3><p><a href=\"https://blog.csdn.net/qq_39816673/article/details/88667505\" target=\"_blank\" >JS 大数相加</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function add(str1, str2) &#123;\n  str1 &#x3D; str1.split(&quot;&quot;); &#x2F;&#x2F; 转化成数组\n  str2 &#x3D; str2.split(&quot;&quot;); &#x2F;&#x2F; 转化成数组\n\n  let result &#x3D; &quot;&quot;; &#x2F;&#x2F; 结果\n  let flag &#x3D; 0; &#x2F;&#x2F; 满10进1标记\n\n  while (str1.length || str2.length || flag) &#123;\n    &#x2F;&#x2F; 计算完\n    flag &#x3D; flag + ~~str1.pop() + ~~str2.pop(); &#x2F;&#x2F; ~~undefined &#x3D; 0, true + 0 &#x3D;1, false + 0 &#x3D; 0\n    &#x2F;&#x2F; 结果\n    result &#x3D; (flag % 10) + result;\n    &#x2F;&#x2F; 是否进位\n    flag &#x3D; flag &gt; 9;\n  &#125;\n  return result.replace(&#x2F;^0+&#x2F;, &quot;&quot;); &#x2F;&#x2F; 首部有0去除\n&#125;\n\nadd(&quot;00125&quot;, &quot;0131231231232132136&quot;);</code></pre>\n\n<h3 id=\"找出出现次数最多的英语单词\"><a href=\"#找出出现次数最多的英语单词\" class=\"headerlink\" title=\"找出出现次数最多的英语单词\"></a>找出出现次数最多的英语单词</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var paragraph &#x3D; &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;;\n\nfunction findMaxWord(paragraph) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  var p &#x3D; paragraph.replace(&#x2F;[\\W\\s]&#x2F;g, &quot; &quot;).toLowerCase().split(&quot; &quot;);\n  &#x2F;&#x2F; console.log(&quot;p&quot;, p);\n  &#x2F;&#x2F; [&#39;bob&#39;, &#39;hit&#39;, &#39;a&#39;, &#39;ball&#39;, &#39;&#39;, &#39;the&#39;, &#39;hit&#39;, &#39;ball&#39;, &#39;flew&#39;, &#39;far&#39;, &#39;after&#39;, &#39;it&#39;, &#39;was&#39;, &#39;hit&#39;, &#39;&#39;]\n  const obj &#x3D; &#123;&#125;;\n\n  for (const word of p) &#123;\n    if (!word) continue;\n    if (obj[word]) &#123;\n      obj[word]++;\n    &#125; else &#123;\n      obj[word] &#x3D; 1;\n    &#125;\n  &#125;\n\n  let max &#x3D; 0;\n  let word &#x3D; &quot;&quot;;\n  for (const k in obj) &#123;\n    if (obj[k] &gt; max) &#123;\n      max &#x3D; obj[k];\n      word &#x3D; k;\n    &#125;\n  &#125;\n\n  return &#123;\n    count: max,\n    word,\n  &#125;;\n&#125;\n\nconst res &#x3D; findMaxWord(paragraph);\nconsole.log(res);</code></pre>\n\n<h3 id=\"节点倒序（将-ul-id-x3D-list，将-ul-节点下的-10000-个-li-节点倒序。考虑性能。）【待处理】\"><a href=\"#节点倒序（将-ul-id-x3D-list，将-ul-节点下的-10000-个-li-节点倒序。考虑性能。）【待处理】\" class=\"headerlink\" title=\"节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】\"></a>节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】</h3><h3 id=\"实现一个函数计算-“1-12-31-100-93”【待处理】\"><a href=\"#实现一个函数计算-“1-12-31-100-93”【待处理】\" class=\"headerlink\" title=\"实现一个函数计算 “1+12-31+100-93”【待处理】\"></a>实现一个函数计算 “1+12-31+100-93”【待处理】</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function calc(str) &#123;\n  return eval(str);\n&#125;</code></pre>\n\n<h3 id=\"判断链表是否有环\"><a href=\"#判断链表是否有环\" class=\"headerlink\" title=\"判断链表是否有环\"></a>判断链表是否有环</h3><ul>\n<li><p>快慢指针</p>\n<p><a href=\"https://www.zhihu.com/question/23208893\" target=\"_blank\" >为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Solution &#123;\n  ...\n  hasCycle() &#123;\n    let fast &#x3D; this.head;\n    let slow &#x3D; this.head;\n    while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D;&#x3D; null) &#123;\n      fast &#x3D; fast.next.next\n      &#x2F;&#x2F; 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\n      &#x2F;&#x2F;               fast\n      &#x2F;&#x2F;               slow\n      slow &#x3D; slow.next\n      if(fast &#x3D;&#x3D;&#x3D; slow)&#123;\n        return true\n      &#125;\n    &#125;\n    return false\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"爬楼梯【待处理】\"><a href=\"#爬楼梯【待处理】\" class=\"headerlink\" title=\"爬楼梯【待处理】\"></a>爬楼梯【待处理】</h3><h3 id=\"删除单向链表中的某个节点\"><a href=\"#删除单向链表中的某个节点\" class=\"headerlink\" title=\"删除单向链表中的某个节点\"></a>删除单向链表中的某个节点</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员\n    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员\n  &#125;\n&#125;\n&#x2F;&#x2F; 定义一个单向链表类\nclass singleLinked &#123;\n  constructor() &#123;\n    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数\n    this.head &#x3D; new Node(&quot;head&quot;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址\n    this.currentNode &#x3D; &quot;&quot;;\n  &#125;\n  &#x2F;&#x2F; 删除一个节点\n  deleteNode(element) &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    &#x2F;&#x2F; 将链的节点与另一个节点连上\n    currentNode.next &#x3D; currentNode.next.next;\n    this.size--;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"五分钟学习算法\"><a href=\"#五分钟学习算法\" class=\"headerlink\" title=\"五分钟学习算法\"></a>五分钟学习算法</h2><p><a href=\"https://www.jianshu.com/p/d13fcada7c2d\" target=\"_blank\" >链接</a></p>\n<h2 id=\"其他算法\"><a href=\"#其他算法\" class=\"headerlink\" title=\"其他算法\"></a>其他算法</h2><p><a href=\"https://juejin.cn/post/7095201687421321224#heading-0\" target=\"_blank\" >待爬取</a></p>\n<h2 id=\"diffTwoDeps\"><a href=\"#diffTwoDeps\" class=\"headerlink\" title=\"diffTwoDeps\"></a>diffTwoDeps</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const diffTwoDeps &#x3D; (deps1?: DependencyList, deps2?: DependencyList) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;Let&#39;s do a reference equality check on 2 dependency list.\n  &#x2F;&#x2F;If deps1 is defined, we iterate over deps1 and do comparison on each element with equivalent element from deps2\n  &#x2F;&#x2F;As this func is used only in this hook, we assume 2 deps always have same length.\n  return deps1\n    ? deps1\n        .map((_ele, idx) &#x3D;&gt; (!Object.is(deps1[idx], deps2?.[idx]) ? idx : -1))\n        .filter((ele) &#x3D;&gt; ele &gt;&#x3D; 0)\n    : &#x2F;&#x2F; prettier-ignore\n    deps2 ? deps2.map((_ele, idx) &#x3D;&gt; idx) : [];\n&#125;;</code></pre>\n\n<h2 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is\"></a>Object.is</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (!Object.is) &#123;\n  Object.defineProperty(Object, &quot;is&quot;, &#123;\n    value: function (x, y) &#123;\n      &#x2F;&#x2F; SameValue algorithm\n      if (x &#x3D;&#x3D;&#x3D; y) &#123;\n        &#x2F;&#x2F; return true if x and y are not 0, OR\n        &#x2F;&#x2F; if x and y are both 0 of the same sign.\n        &#x2F;&#x2F; This checks for cases 1 and 2 above.\n        return x !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;\n      &#125; else &#123;\n        &#x2F;&#x2F; return true if both x AND y evaluate to NaN.\n        &#x2F;&#x2F; The only possibility for a variable to not be strictly equal to itself\n        &#x2F;&#x2F; is when that variable evaluates to NaN (example: Number.NaN, 0&#x2F;0, NaN).\n        &#x2F;&#x2F; This checks for case 3.\n        return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;\n      &#125;\n    &#125;,\n  &#125;);\n&#125;\n\n&#x2F;&#x2F;</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.cnblogs.com/pangqianjin/p/14998643.html\" target=\"_blank\" >JavaScript 手写几种常见的排序算法：冒泡、选择、插入、希尔、归并、快排</a><br><a href=\"https://blog.csdn.net/qq_44433261/article/details/117235740\" target=\"_blank\" >排序动画</a><br><a href=\"https://wenku.baidu.com/view/7f84552a6f85ec3a87c24028915f804d2b16878c.html\" target=\"_blank\" >分治思想——精选推荐</a><br><a href=\"https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B3%95/9763353?fr=aladdin\" target=\"_blank\" >归并排序法 百度百科</a><br><a href=\"https://blog.csdn.net/Sherlook_Holmes/article/details/120584469\" target=\"_blank\" >（含动画演示）搞懂归并排序 一学就会</a></p>\n<p><a href=\"https://www.jianshu.com/u/c6ad3f2ed2d6\" target=\"_blank\" >五分钟学算法(PPT 做的 gif)</a><br><a href=\"https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html\" target=\"_blank\" >Promise.resolve（）详解</a></p>\n","text":"实现单例通过构造函数class Singleton &#123; constructor() &#123; console.log(&quot;this&quot;, this); if (!Singleton.instance) &#123; &#x2F;&#x2F; 将 th...","link":"","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":47,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":49,"path":"api/tags/前端基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B\"><span class=\"toc-text\">实现单例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">通过构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">字符串相关</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">深度操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">深拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#structuredClone\"><span class=\"toc-text\">structuredClone</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86\"><span class=\"toc-text\">深度克隆</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">深比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%B7%AE%E5%BC%82%E5%8C%96\"><span class=\"toc-text\">深度获取差异化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E6%8B%BC%E6%8E%A5\"><span class=\"toc-text\">深度拼接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">深度解析</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#uuid\"><span class=\"toc-text\">uuid</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%B2%E6%8A%96\"><span class=\"toc-text\">防抖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E6%B5%81\"><span class=\"toc-text\">节流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">接口数据缓存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this-%E6%8C%87%E5%90%91\"><span class=\"toc-text\">this 指向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#apply\"><span class=\"toc-text\">apply</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bind\"><span class=\"toc-text\">bind</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise\"><span class=\"toc-text\">Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-all\"><span class=\"toc-text\">Promise.all</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-race\"><span class=\"toc-text\">Promise.race</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-allSettle\"><span class=\"toc-text\">Promise.allSettle</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-any\"><span class=\"toc-text\">Promise.any</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-finally\"><span class=\"toc-text\">Promise.finally</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-resolve\"><span class=\"toc-text\">Promise.resolve</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%BB%E6%96%AD-resolve-x2F-reject-%E5%90%8E%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">阻断 resolve&#x2F;reject 后面代码还会执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F\"><span class=\"toc-text\">限制并发数量</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#async-await-%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">async await 原理实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D\"><span class=\"toc-text\">数组去重</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E5%A5%87%E6%95%B0%E6%8E%92%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%8C%E5%81%B6%E6%95%B0%E6%8E%92%E5%9C%A8%E5%90%8E%E9%9D%A2\"><span class=\"toc-text\">将奇数排在前面，偶数排在后面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数组转树结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%88%99\"><span class=\"toc-text\">正则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%90-URL-%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E9%83%A8%E5%88%86\"><span class=\"toc-text\">解析 URL 中所有的部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%88%92%E7%BA%BF%E8%BD%AC%E5%A4%A7%E5%86%99\"><span class=\"toc-text\">中划线转大写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%91%E9%A2%9D%E5%8D%83%E5%88%86\"><span class=\"toc-text\">金额千分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">原理实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new\"><span class=\"toc-text\">new</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create\"><span class=\"toc-text\">Object.create</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#instanceof\"><span class=\"toc-text\">instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JSONP\"><span class=\"toc-text\">JSONP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-event-bus\"><span class=\"toc-text\">实现 event bus</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">柯里化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">柯里化是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">洋葱模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86-x2F-%E5%8A%AB%E6%8C%81\"><span class=\"toc-text\">数据代理&#x2F;劫持</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#proxy\"><span class=\"toc-text\">proxy</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#defineProperty\"><span class=\"toc-text\">defineProperty</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true\"><span class=\"toc-text\">(a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双向链表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LRU-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">LRU 算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#leecode\"><span class=\"toc-text\">leecode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">红包算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">括号匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">螺旋矩阵</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0\"><span class=\"toc-text\">大数相加</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%BE%E5%87%BA%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D\"><span class=\"toc-text\">找出出现次数最多的英语单词</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8A%82%E7%82%B9%E5%80%92%E5%BA%8F%EF%BC%88%E5%B0%86-ul-id-x3D-list%EF%BC%8C%E5%B0%86-ul-%E8%8A%82%E7%82%B9%E4%B8%8B%E7%9A%84-10000-%E4%B8%AA-li-%E8%8A%82%E7%82%B9%E5%80%92%E5%BA%8F%E3%80%82%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E3%80%82%EF%BC%89%E3%80%90%E5%BE%85%E5%A4%84%E7%90%86%E3%80%91\"><span class=\"toc-text\">节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97-%E2%80%9C1-12-31-100-93%E2%80%9D%E3%80%90%E5%BE%85%E5%A4%84%E7%90%86%E3%80%91\"><span class=\"toc-text\">实现一个函数计算 “1+12-31+100-93”【待处理】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF\"><span class=\"toc-text\">判断链表是否有环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%AC%E6%A5%BC%E6%A2%AF%E3%80%90%E5%BE%85%E5%A4%84%E7%90%86%E3%80%91\"><span class=\"toc-text\">爬楼梯【待处理】</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">删除单向链表中的某个节点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E5%88%86%E9%92%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">五分钟学习算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">其他算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#diffTwoDeps\"><span class=\"toc-text\">diffTwoDeps</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-is\"><span class=\"toc-text\">Object.is</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"企业微信文件预览","uid":"74208bc76768a419347d0ad3e15c33b0","slug":"2022-07-05wxfile","date":"2022-07-05T15:16:30.000Z","updated":"2022-09-16T13:54:56.210Z","comments":true,"path":"api/articles/2022-07-05wxfile.json","keywords":null,"cover":[],"text":"企业微信文件预览试错 1: const fileName &#x3D; &quot;xxxxx.jpeg&quot;; &#x2F;&#x2F; 举个例子 downloadAttachment(downloadUrl).then((res) &#x3D;&gt; &#123; v...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/categories/企业微信.json"}],"tags":[{"name":"企业微信","slug":"企业微信","count":5,"path":"api/tags/企业微信.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"授权与校验场景「简聊」","uid":"22d71efeaa5b73e832334cf42551f026","slug":"2022-07-01auth","date":"2022-07-01T09:12:26.000Z","updated":"2022-09-16T13:54:56.205Z","comments":true,"path":"api/articles/2022-07-01auth.json","keywords":null,"cover":null,"text":"最简单用变量，模拟数据 session + cookie每个用户对应一个会话 SSO 1 session + redis + cookie 觉得有点奇葩，第二份核心项目遇到 jwt + redis第二份非核心项目遇到 以下是一般公司常用的方式，面试的时候，大家都在唠这个 SSO ...","link":"","photos":[],"count_time":{"symbolsCount":914,"symbolsTime":"1 mins."},"categories":[{"name":"auth","slug":"auth","count":1,"path":"api/categories/auth.json"}],"tags":[{"name":"auth","slug":"auth","count":1,"path":"api/tags/auth.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/avatar.jpeg","link":"/","description":"眼中有光，心中有梦，脚下有路","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}