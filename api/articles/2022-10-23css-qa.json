{"title":"前端基础-css q&a","uid":"81556a3598a3ddc6cbb980694cccc8db","slug":"2022-10-23css-qa","date":"2022-10-23T06:39:57.000Z","updated":"2023-05-15T13:17:32.966Z","comments":true,"path":"api/articles/2022-10-23css-qa.json","keywords":null,"cover":[],"content":"<h2 id=\"1-获取-CDNS-的-文章标题\"><a href=\"#1-获取-CDNS-的-文章标题\" class=\"headerlink\" title=\"1. 获取 CDNS 的 文章标题\"></a>1. 获取 CDNS 的 文章标题</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var list &#x3D; document.getElementsByClassName(&#39;column_article_list&#39;)[0].children;\nArray.from(list).forEach((item) &#x3D;&gt; &#123;\n  var text &#x3D; item.children[0].children[0].children[0].innerText;\n  document.body.append(text + &#39;\\n&#39;);\n&#125;);</code></pre>\n\n<h2 id=\"1-css-的-root、var-以及-root、html、-选择器优先级\"><a href=\"#1-css-的-root、var-以及-root、html、-选择器优先级\" class=\"headerlink\" title=\"1. css 的:root、var()以及:root、html、* 选择器优先级\"></a>1. css 的:root、var()以及:root、html、<code>*</code> 选择器优先级</h2><p><a href=\"https://blog.csdn.net/qq_39706777/article/details/120025610\" target=\"_blank\" >见</a></p>\n<h3 id=\"1-1-root\"><a href=\"#1-1-root\" class=\"headerlink\" title=\"1.1. :root\"></a>1.1. :root</h3><p>代表文档的根元素，在:root 中声明的属性是全局属性，都可以通过 var()引用</p>\n<h3 id=\"1-2-var\"><a href=\"#1-2-var\" class=\"headerlink\" title=\"1.2. var( )\"></a>1.2. var( )</h3><p>var(属性名) 可以代替元素任何属性中的任何值</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">:root&#123;\n    --normal-color: pink;\n&#125;\n.bg&#123;\n    background-color: var(--normal-color);\n&#125;\n————————————————\n版权声明：本文为CSDN博主「liun_n」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39706777&#x2F;article&#x2F;details&#x2F;120025610</code></pre>\n\n<h3 id=\"1-3-var-回退值\"><a href=\"#1-3-var-回退值\" class=\"headerlink\" title=\"1.3. var( )回退值\"></a>1.3. var( )回退值</h3><p>没有声明–active-color，则回退到 blue</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">:root &#123;\n  --normal-color: pink;\n&#125;\n.bg &#123;\n  background-color: var(—active-color, blue);\n&#125;</code></pre>\n\n<h3 id=\"1-4-优先级\"><a href=\"#1-4-优先级\" class=\"headerlink\" title=\"1.4. 优先级\"></a>1.4. 优先级</h3><p>:root &gt; html &gt; <code>*</code> 选择器优先级</p>\n<h2 id=\"2-移动端总结\"><a href=\"#2-移动端总结\" class=\"headerlink\" title=\"2. 移动端总结\"></a>2. 移动端总结</h2><h3 id=\"缩放适配\"><a href=\"#缩放适配\" class=\"headerlink\" title=\"缩放适配\"></a>缩放适配</h3><h3 id=\"rem-适配\"><a href=\"#rem-适配\" class=\"headerlink\" title=\"rem 适配\"></a>rem 适配</h3><h3 id=\"vw-适配\"><a href=\"#vw-适配\" class=\"headerlink\" title=\"vw 适配\"></a>vw 适配</h3><h3 id=\"移动端点击-300ms\"><a href=\"#移动端点击-300ms\" class=\"headerlink\" title=\"移动端点击 300ms\"></a>移动端点击 300ms</h3><p>高版本 chrome 和 iOS 已经修复<br>是否引入 faskclick.js</p>\n<p>Chrome 32 对移动端进行了优化，可以不禁用缩放，也能解决延迟的问题。<br>接着 Firefox 和 IE&#x2F;Edge 紧随其后也修复了这个 BUG，<br>最后，就是 iOS 9.3 也同样修复这个 BUG</p>\n<p>在移动端，为了避免点击延迟，通常使用 <code>fastclick</code> 库来处理点击事件。<code>fastclick</code> 库的原理是，在移动端浏览器上，当用户触摸屏幕时，浏览器会等待一小段时间，以确定用户是要双击缩放还是单击操作。如果浏览器检测到用户只是单击操作，则会触发 click 事件。这个等待的时间通常是 300 毫秒，即所谓的“点击延迟”。</p>\n<p><code>fastclick</code> 库的解决方法是，</p>\n<ol>\n<li>监听 <code>touchstart</code> 事件，并在触发事件后立即触发 <code>click</code> 事件，从而避免延迟。</li>\n<li>此外，<code>fastclick</code> 还会在 <code>touchstart</code> 和 <code>touchend</code> 事件中，阻止事件的默认行为和冒泡行为，以避免事件被触发多次或被其他元素捕获。</li>\n<li>这样，可以确保 click 事件只被触发一次，并且在正确的元素上触发。</li>\n</ol>\n<h3 id=\"为什么是-300ms\"><a href=\"#为什么是-300ms\" class=\"headerlink\" title=\"为什么是 300ms\"></a>为什么是 300ms</h3><p>在移动设备早期，普遍采用的是双击缩放（Double Tap to Zoom）的交互方式，因此浏览器需要等待用户是否要执行双击缩放操作，如果用户只是单击屏幕，浏览器才会将其识别为 <code>click</code> 事件。在此期间，浏览器会将用户的单击事件缓存，等待一段时间，如果在这段时间内没有再次触发事件，就会将该事件作为 <code>click</code> 事件触发。因此，浏览器要等待一定时间才能确定是否要触发单击事件，这个时间大概为 300ms，所以这个时间间隔也被称为“300ms 延迟”。</p>\n<p>后来，由于双击缩放已经不再普遍使用，许多移动设备都取消了 300ms 延迟，但是一些设备上仍然存在，为了兼容这些设备，一些库，比如 FastClick，仍然需要处理 300ms 延迟。</p>\n<!--\n是否仍然有必要使用呢，回到开始，适合自己的才是最好的，因此，如果你的业务需求，是只需要对 iOS 9.3 以上的 WKWebView 做适配，那么强烈建议你不去使用，毕竟减少了文件请求大小，引入风险的概率\n\n<a href=\"https://juejin.cn/post/6844903850160160782\" target=\"_blank\" >移动端 300ms 延迟及 fastClick 原理解析</a>\n\n**原理：**\n\n移动端，当用户点击屏幕时，会依次触发 touchstart，touchmove(0 次或多次)，touchend，mousemove，mousedown，mouseup，click。\ntouchmove: 只有当手指在屏幕发生移动的时候才会触发 touchmove 事件。\n\n在 touchstart, touchmove 或者 touchend 事件中的任意一个调用 event.preventDefault，mouse 事件 以及 click 事件将不会触发。\n\nfastClick 在 touchend 阶段 调用 event.preventDefault，然后通过 document.createEvent 创建一个 MouseEvents，然后 通过 event​Target​.dispatch​Event 触发对应目标元素上绑定的 click 事件。 -->\n\n<h3 id=\"点击穿透\"><a href=\"#点击穿透\" class=\"headerlink\" title=\"点击穿透\"></a>点击穿透</h3><p><a href=\"https://www.cnblogs.com/shytong/p/5463673.html\" target=\"_blank\" >点击穿透原理及解决</a></p>\n<p>原理：在这 300ms 以内，因为上层元素隐藏或消失了，由于 click 事件的滞后性，同样位置的 DOM 元素触发了 click 事件（如果是 input 则触发了 focus 事件）。在代码中，给我们的感觉就是 target 发生了飘移。</p>\n<p>1、禁止页面缩放 部分浏览器不再需要等待 300ms<br>2、300+ms<br>3、阻止默认事件。<br>4、引入 faskclick.js： 原理：touch 事件先于 mouse 事件先于 click 执行，因此可以在 document.body 上绑定事件用于监听点触行为，根据需要模拟 click 触发真正需要响应的元素</p>\n<h2 id=\"3-学习-css-文本溢出显示省略号？\"><a href=\"#3-学习-css-文本溢出显示省略号？\" class=\"headerlink\" title=\"3. 学习 css 文本溢出显示省略号？\"></a>3. 学习 css 文本溢出显示省略号？</h2><h3 id=\"单行\"><a href=\"#单行\" class=\"headerlink\" title=\"单行\"></a>单行</h3><h3 id=\"多行\"><a href=\"#多行\" class=\"headerlink\" title=\"多行\"></a>多行</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* 单行 *&#x2F;\nwidth: 100px;\ndisplay: inline-block;\n\n&#x2F;* 设置文本不进行换行 *&#x2F;\nwhite-space: nowrap;\n&#x2F;* 超出部分使用省略号 *&#x2F;\ntext-overflow: ellipsis;\n&#x2F;* 让超出部分省略 *&#x2F;\noverflow: hidden;\n\n&#x2F;* 多行 *&#x2F;\nwidth: 100px;\noverflow: hidden;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 3;\n\n&#x2F;* 注意：必要时候，需要设置 *&#x2F;</code></pre>\n\n<p>两栏布局？</p>\n<h2 id=\"4-translate-x2F-position？\"><a href=\"#4-translate-x2F-position？\" class=\"headerlink\" title=\"4. translate &#x2F; position？\"></a>4. translate &#x2F; position？</h2><ol>\n<li>translate 是什么，position 是什么</li>\n</ol>\n<p><code>translate</code> 和 <code>position</code> 是 CSS 中用于控制元素位置的两个属性，它们有不同的作用和用法。</p>\n<p><code>translate</code> 属性可以用来移动元素的位置，但它不会影响元素的文档流位置，也就是说，元素的位置移动后不会影响其他元素的位置。<code>translate</code> 属性可以接受三个参数，分别是 <code>translateX()</code>、<code>translateY()</code> 和 <code>translateZ()</code>，可以分别用来控制元素在水平、竖直和深度方向上的移动。</p>\n<p>例如，以下代码会将元素向右移动 50 像素：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">div &#123;\n  transform: translateX(50px);\n&#125;</code></pre>\n\n<p>相反，<code>position</code> 属性是用来确定元素在文档流中的位置。元素的 <code>position</code> 属性可以设置为 <code>static</code>、<code>relative</code>、<code>absolute</code> 或 <code>fixed</code>。其中 <code>relative</code> 表示元素相对于自己原来的位置进行定位，而 <code>absolute</code> 则表示元素相对于它的父元素或者祖先元素进行定位。<code>fixed</code> 则是相对于浏览器窗口进行定位。</p>\n<p>例如，以下代码将元素设置为绝对定位，并将其左上角放置在距离父元素顶部和左侧各 50 像素的位置：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">div &#123;\n  position: absolute;\n  top: 50px;\n  left: 50px;\n&#125;</code></pre>\n\n<p>总之，<code>translate</code> 和 <code>position</code> 属性都可以用来控制元素的位置，但它们的作用和用法是不同的。<code>translate</code> 属性用于移动元素的位置，而不影响文档流位置；而 <code>position</code> 属性则用于确定元素在文档流中的位置。</p>\n<h2 id=\"CSS3-中-translate-x2F-position-有什么区别\"><a href=\"#CSS3-中-translate-x2F-position-有什么区别\" class=\"headerlink\" title=\"CSS3 中 translate &#x2F; position 有什么区别\"></a>CSS3 中 translate &#x2F; position 有什么区别</h2><p>除了上述区别外，<code>translate</code> 和 <code>position</code> 还有以下不同之处：</p>\n<ol>\n<li><p><code>translate</code> 属性不会影响元素的盒模型，而 <code>position</code> 属性会影响元素的盒模型。</p>\n</li>\n<li><p><code>translate</code> 属性可以使用 CSS 过渡和动画效果，以实现元素位置的平滑过渡；而 <code>position</code> 属性则不适用于过渡和动画。</p>\n</li>\n<li><p><code>translate</code> 属性可以和其他 CSS 变换属性一起使用，例如旋转、缩放等；而 <code>position</code> 属性则不支持与其他变换属性一起使用。</p>\n</li>\n<li><p><code>translate</code> 属性的性能通常比 <code>position</code> 属性更好，特别是在移动大量元素时，因为 <code>translate</code> 属性的硬件加速更有效。</p>\n</li>\n</ol>\n<p>综上所述，虽然 <code>translate</code> 和 <code>position</code> 属性都可以用于控制元素的位置，但它们的作用和用法是不同的，而且它们还有其他不同之处，需要根据具体情况选择合适的属性来实现元素的位置控制。</p>\n<h2 id=\"5-你对媒体查询的理解？\"><a href=\"#5-你对媒体查询的理解？\" class=\"headerlink\" title=\"5. 你对媒体查询的理解？\"></a>5. 你对媒体查询的理解？</h2><h3 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><ul>\n<li>媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定 CSS 样式，</li>\n<li>媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。</li>\n<li>媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。</li>\n<li>使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。</li>\n</ul>\n<!-- 作者：洞听\n链接：https://www.jianshu.com/p/eb1123d5b20b\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->\n\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 这个不属于css级别的 --&gt;\n&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&quot; &#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;m320.css&quot; media&#x3D;&quot;only screen and (max-width:320px)&quot; &#x2F;&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;m480.css&quot; media&#x3D;&quot;only screen and (min-width:321px) and (max-width:375px)&quot; &#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;*媒体查询*&#x2F;\n&#x2F;*当页面大于1200px 时，大屏幕，主要是PC 端*&#x2F;\n@media (min-width: 1200px) &#123;\n&#125;\n&#x2F;*在992 和1199 像素之间的屏幕里，中等屏幕，分辨率低的PC*&#x2F;\n@media (min-width: 992px) and (max-width: 1199px) &#123;\n&#125;\n&#x2F;*在768 和991 像素之间的屏幕里，小屏幕，主要是PAD*&#x2F;\n@media (min-width: 768px) and (max-width: 991px) &#123;\n&#125;\n&#x2F;*在480 和767 像素之间的屏幕里，超小屏幕，主要是手机*&#x2F;\n@media (min-width: 480px) and (max-width: 767px) &#123;\n&#125;\n&#x2F;*在小于480 像素的屏幕，微小屏幕，更低分辨率的手机*&#x2F;\n@media (max-width: 479px) &#123;\n&#125;</code></pre>\n\n<h3 id=\"CSS-语法\"><a href=\"#CSS-语法\" class=\"headerlink\" title=\"CSS 语法\"></a>CSS 语法</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">@media mediatype and (expression) &#123;\n  &#x2F;* CSS rules here *&#x2F;\n&#125;</code></pre>\n\n<p>其中，<br>mediatype 表示媒体类型，可以是 all（所有媒体设备）、print（打印设备）、screen（计算机屏幕）等；<br>expression 表示媒体特性，可以是设备的宽度、高度、分辨率、方向等。</p>\n<h2 id=\"6-你对-css-sprites-的理解，好处是什么\"><a href=\"#6-你对-css-sprites-的理解，好处是什么\" class=\"headerlink\" title=\"6. 你对 css sprites 的理解，好处是什么\"></a>6. 你对 css sprites 的理解，好处是什么</h2><p>使用工具(ps 之类的)将多张图片打包成一张雪碧图，并为其生成何时的 css。每张图<br>片都有相应的 css 类，该类定义了</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">background-image,\nbackground-position,\nbackground-size 属性。</code></pre>\n\n<p>使用图片时，将相应的类添加到你的元素中去即可。</p>\n<h2 id=\"7-有哪些⽅式（CSS）可以隐藏⻚⾯元素？\"><a href=\"#7-有哪些⽅式（CSS）可以隐藏⻚⾯元素？\" class=\"headerlink\" title=\"7. 有哪些⽅式（CSS）可以隐藏⻚⾯元素？\"></a>7. 有哪些⽅式（CSS）可以隐藏⻚⾯元素？</h2><ul>\n<li>不占据空间 <code>overflow:hidden</code>, <code>display: none</code>, <code>z-index: -999</code></li>\n<li>占据空间，不可操作的 <code>visibility: hidden</code>, <code>transform: scale(0,0)</code></li>\n<li>占据空间，可以操作的 <code>opacity:0</code></li>\n</ul>\n<h2 id=\"8-link-和-import-的区别？\"><a href=\"#8-link-和-import-的区别？\" class=\"headerlink\" title=\"8. link 和@import 的区别？\"></a>8. link 和@import 的区别？</h2><p>一、link 和@import 的区别？<br>1.1、<em>所属不同</em> link 属于 html 标签，而@import 是 css 提供的。<br>1.2、<em>加载</em> 页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面被加载完再加载的。<br>1.3、<em>兼容性问题：</em>@import 只在 IE5 以上才能识别，而 link 是 html 标签，无兼容性问题。<br>1.4、<em>权重问题:</em> link。的权重要高于 @import<br>1.5、<em>DOM 操作:</em> DOM 可以操作 link 中的样式，而不可以操作@import 中的样式。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/124225973\">https://blog.csdn.net/weixin_47450807/article/details/124225973</a></p>\n<p>简单了解 CSS3 的 all 属性</p>\n<h2 id=\"9-margin-和-padding-分别适合什么场景使用？\"><a href=\"#9-margin-和-padding-分别适合什么场景使用？\" class=\"headerlink\" title=\"9. margin 和 padding 分别适合什么场景使用？\"></a>9. margin 和 padding 分别适合什么场景使用？</h2><p><em>margin</em> 是用来隔开元素与元素之间的间距，padding 是用来隔开元素和内容的间距。margin 用来布局分开元素使得元素互不相干。<br><em>padding</em> 用于元素和内容之间的间隔，让内容与包裹元素之间存在一段距离。</p>\n<h3 id=\"何时使用-margin\"><a href=\"#何时使用-margin\" class=\"headerlink\" title=\"何时使用 margin\"></a>何时使用 margin</h3><p>2.1、需要在 border 外侧田间空白时。<br>2.2、空白处不需要背景色时。<br>2.3、上下相连的两个盒子之间的空白，需要相互抵消时。如 15px+20px 的 margin，将得到 20px 的空白。</p>\n<h3 id=\"何时使用-padding\"><a href=\"#何时使用-padding\" class=\"headerlink\" title=\"何时使用 padding\"></a>何时使用 padding</h3><p>3.1、需要在 border 内测添加空白时。<br>3.2、空白处需要背景（色）时。<br>3.3、上下相连的两个盒子之间的空白，希望等于两者之和时。如 15px+20px 的 padding，将得到 35px 的空白。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/124192349\">https://blog.csdn.net/weixin_47450807/article/details/124192349</a></p>\n<h2 id=\"10-浏览器是怎样解析-CSS-选择器的？\"><a href=\"#10-浏览器是怎样解析-CSS-选择器的？\" class=\"headerlink\" title=\"10. 浏览器是怎样解析 CSS 选择器的？\"></a>10. 浏览器是怎样解析 CSS 选择器的？</h2><p>当浏览器解析 HTML 文档时，如果遇到一个 CSS 样式表（CSS stylesheet）的引用，它就会根据这个样式表的内容来渲染页面。</p>\n<p>在解析 CSS 样式表时，浏览器需要分析样式表中的<code>选择器</code>和<code>声明</code>（declarations），并根据这些规则来对页面元素进行渲染。</p>\n<p>浏览器解析 CSS 选择器的过程如下：</p>\n<ol>\n<li><p><code>选择器解析</code>：浏览器首先需要解析选择器（selector），确定该规则应用于哪些元素。选择器可以是<code>标签名、类名、ID、属性</code>等。</p>\n</li>\n<li><p><code>匹配元素</code>：浏览器根据选择器匹配页面中的元素。<strong>匹配过程是从右到左进行的，也就是先匹配最右边的选择器，再逐渐向左匹配</strong>。例如，对于选择器 <code>p &gt; a:hover</code>，浏览器首先会找到所有 <code>a</code> 元素，然后再筛选出它们的父元素是 <code>p</code> 的那些元素。</p>\n</li>\n<li><p><code>继承样式</code>：<strong>如果一个元素没有定义某个样式，那么它会继承它的父元素的样式，直到找到一个明确的样式定义</strong>。</p>\n</li>\n<li><p><code>层叠样式</code>：如果多个样式规则都适用于同一个元素，那么浏览器会<strong>根据 CSS 层叠样式的规则来决定哪个样式优先级更高</strong>，以此来确定最终应用的样式。</p>\n</li>\n<li><p><code>渲染元素</code>：根据匹配的元素和样式定义，浏览器开始渲染页面。它会<strong>根据元素的盒模型（box model）计算出每个元素在页面中的位置和大小，并将样式应用到元素上</strong>。</p>\n</li>\n</ol>\n<p>以上就是浏览器解析 CSS 选择器的基本流程。不过需要注意的是，浏览器在解析 CSS 样式表时会进行优化，以提高性能和渲染速度。例如，<strong>浏览器会将选择器解析成一棵选择器树（Selector Tree），并根据需要进行缓存和重用</strong>。</p>\n<!-- 1、*样式系统*从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只\n要选择器的子树一直在工作，样式系统就会持续左移，知道和规则匹配，或者是\n因为不匹配而放弃该规则。\n\n2、如果*正向解析*，例如「div div p em」，我们首先就要检查当前元素到\nhtml 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到\n最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹\n配与否，效率很低。\n\n3、*逆向匹配则*不同，如果当前的 DOM 元素是 div，而不是 selector 最后的\nem，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。 -->\n\n<h2 id=\"11-请解释一下为什么需要清除浮动？\"><a href=\"#11-请解释一下为什么需要清除浮动？\" class=\"headerlink\" title=\"11. 请解释一下为什么需要清除浮动？\"></a>11. 请解释一下为什么需要清除浮动？</h2><p>浮动（float）是一种常用的 CSS 布局技术，它可以让元素“浮”起来，脱离文档流并向左或向右对齐。浮动元素在页面布局中具有一定的灵活性，可以实现一些复杂的布局效果。但是，浮动元素也会带来一些问题，其中最常见的问题就是浮动元素高度坍塌（clearfix）。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ol>\n<li>当一个元素浮动之后，它不再占据正常文档流中的位置，因此其他元素就会忽略它的位置，可能<code>会出现覆盖、重叠</code>等问题。</li>\n<li>此外，<code>浮动元素可能会导致其父元素的高度坍塌，导致布局混乱</code>。</li>\n</ol>\n<p>为了解决这些问题，我们需要对浮动元素进行清除。清除浮动的目的是让父元素包含浮动元素，以避免出现高度坍塌等问题。</p>\n<h3 id=\"常见的清除浮动的方法包括：\"><a href=\"#常见的清除浮动的方法包括：\" class=\"headerlink\" title=\"常见的清除浮动的方法包括：\"></a>常见的清除浮动的方法包括：</h3><ol>\n<li><p><code>使用空的块级元素清除浮动</code>。这种方法比较简单，只需要在浮动元素的父元素最后添加一个空的块级元素，并为其设置 clear: both。</p>\n</li>\n<li><p><code>使用 overflow 属性清除浮动</code>。将父元素的 overflow 属性设置为 hidden、auto 或 scroll，可以使其包含浮动元素。</p>\n</li>\n<li><p><code>使用 clearfix 技巧清除浮动</code>。这种方法是添加一个伪元素（::after）作为最后一个浮动元素的兄弟元素，然后为伪元素设置 clear: both。</p>\n</li>\n<li><p><code>使用 CSS 网格布局或弹性布局等现代布局技术</code>，可以更好地解决浮动元素带来的问题，避免使用清除浮动的方法。</p>\n</li>\n</ol>\n<p>需要注意的是，清除浮动的方法也可能会带来一些问题，如增加不必要的代码量、影响性能等，因此应该根据具体情况选择合适的方法来清除浮动。</p>\n<h3 id=\"使用空的块级元素清除浮动\"><a href=\"#使用空的块级元素清除浮动\" class=\"headerlink\" title=\"使用空的块级元素清除浮动\"></a>使用空的块级元素清除浮动</h3><p>使用空的块级元素清除浮动的代码如下所示：</p>\n<p>HTML:</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;div class&#x3D;&quot;parent&quot;&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;clearfix&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<p>CSS:</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.clearfix &#123;\n  clear: both;\n&#125;\n\n.float-left &#123;\n  float: left;\n&#125;</code></pre>\n\n<p>在上面的代码中，我们为包含浮动元素的父元素添加了一个空的 div 元素，并为其设置了 clear:both，这样就可以清除浮动了。同时，我们将浮动元素的 float 属性设置为 left，使其向左浮动。</p>\n<p>需要注意的是，使用空的块级元素清除浮动的方式，<strong>在页面中增加了无意义的 HTML 元素，可能会对页面性能产生一定的影响</strong>，因此在实际开发中，建议使用其他方式清除浮动。</p>\n<h3 id=\"使用-overflow-属性清除浮动\"><a href=\"#使用-overflow-属性清除浮动\" class=\"headerlink\" title=\"使用 overflow 属性清除浮动\"></a>使用 overflow 属性清除浮动</h3><p>使用 overflow 属性清除浮动的代码如下所示：</p>\n<p>HTML:</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;div class&#x3D;&quot;parent&quot;&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<p>CSS:</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.parent &#123;\n  overflow: hidden;\n&#125;\n\n.float-left &#123;\n  float: left;\n&#125;</code></pre>\n\n<p>在上面的代码中，我们将包含浮动元素的父元素的 overflow 属性设置为 hidden，这样就可以清除浮动了。同时，我们将浮动元素的 float 属性设置为 left，使其向左浮动。最后，我们在父元素的最后添加一个空的 div 元素，并为其设置 clear:both，以防止父元素不包含任何内容时出现高度为 0 的问题。</p>\n<p>需要注意的是，<strong>使用 overflow 属性清除浮动的方式，会影响父元素的滚动行为。如果父元素的内容溢出，它将被剪切并隐藏，除非添加了滚动条</strong>。因此，在使用这种方法时，需要注意父元素的样式和布局。</p>\n<h3 id=\"使用-clearfix-技巧清除浮动\"><a href=\"#使用-clearfix-技巧清除浮动\" class=\"headerlink\" title=\"使用 clearfix 技巧清除浮动\"></a>使用 clearfix 技巧清除浮动</h3><p>使用 clearfix 技巧清除浮动的代码如下所示：</p>\n<p>HTML:</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;div class&#x3D;&quot;clearfix&quot;&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<p>CSS:</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.clearfix::after &#123;\n  content: &#39;&#39;;\n  display: block;\n  clear: both;\n&#125;\n\n.float-left &#123;\n  float: left;\n&#125;</code></pre>\n\n<p>在上面的代码中，我们为包含浮动元素的父元素添加了一个 clearfix 类，然后为该类添加了一个伪元素(::after)，并为其设置了 clear: both，这样就可以清除浮动了。同时，我们将浮动元素的 float 属性设置为 left，使其向左浮动。</p>\n<p>需要注意的是，使用 clearfix 技巧清除浮动的方式，比较简洁和方便，不会影响父元素的滚动行为，因此在实际开发中被广泛使用。</p>\n<h3 id=\"替代方案-flex-x2F-grid-布局\"><a href=\"#替代方案-flex-x2F-grid-布局\" class=\"headerlink\" title=\"替代方案 flex&#x2F;grid 布局\"></a>替代方案 flex&#x2F;grid 布局</h3><h2 id=\"13-css-块级元素，行内元素和行内块级元素-css-三栏布局总结\"><a href=\"#13-css-块级元素，行内元素和行内块级元素-css-三栏布局总结\" class=\"headerlink\" title=\"13. css 块级元素，行内元素和行内块级元素 css 三栏布局总结\"></a>13. css 块级元素，行内元素和行内块级元素 css 三栏布局总结</h2><p><em>块级元素</em></p>\n<p>1、它独占一行。<br>2、它的宽高可以设置。<br>3、默认时，宽度是 100%</p>\n<p><code>&lt;div&gt;</code>，<code>&lt;h1-h6&gt;</code>,<code>&lt;ul&gt;</code>,<code>&lt;ol&gt;</code>,<code>li</code>等</p>\n<p><em>行内元素</em></p>\n<p>1、它的宽度有内容决定，高度有内容字体大小决定。<br>2、它不可以设置宽高。<br>3、它可以和其他行内元素位于同一行。</p>\n<p><code>&lt;span&gt;</code>,<code>&lt;label&gt;</code>,<code>&lt;i&gt;</code>,<code>&lt;e&gt;</code></p>\n<p><em>行内跨级元素</em></p>\n<p>1、它既可以和其他的行内元素位于同一行。<br>2、元素的高度及与边的间距都可以设置。</p>\n<p><code>&lt;input&gt;</code>，<code>&lt;img&gt;</code>,<code>&lt;select&gt;</code>等。</p>\n<h2 id=\"14-如何理解-margin-重叠问题？？？？\"><a href=\"#14-如何理解-margin-重叠问题？？？？\" class=\"headerlink\" title=\"14. 如何理解 margin 重叠问题？？？？\"></a>14. 如何理解 margin 重叠问题？？？？</h2><ol>\n<li>什么是 margin 重叠</li>\n<li>具体表现为</li>\n<li>为什么会出现</li>\n<li>解决方案</li>\n</ol>\n<p>CSS 中的 margin 重叠问题，指的是在两个或多个相邻的块级元素之间，它们的 margin 值会发生重叠现象，导致最终的 margin 值不是预期的值，而是取两者中的较大值。这种现象被称为 margin 重叠。</p>\n<p>margin 重叠问题的具体表现有以下几种情况：</p>\n<ol>\n<li>相邻的两个元素的 margin-top 和 margin-bottom 重叠。</li>\n<li>父元素的 margin-top 和第一个子元素的 margin-top 重叠。</li>\n<li>父元素的 margin-bottom 和最后一个子元素的 margin-bottom 重叠。</li>\n</ol>\n<p>理解 margin 重叠问题的原因可以归结为 CSS 规范中对 margin 计算的定义：如果两个相邻元素的 margin 值都是正数或都是负数，则它们的 margin 会发生重叠，取两者中的较大值作为它们之间的 margin 值。</p>\n<p>为了避免 margin 重叠问题，可以采用以下几种方式：</p>\n<ol>\n<li>将相邻的元素的 margin 值设置为负值，避免 margin 值重叠。</li>\n<li>为相邻的元素添加 border、padding 或 inline 元素，避免 margin 值重叠。</li>\n<li>为父元素添加 overflow:hidden 或 display:inline-block 属性，避免父元素与子元素的 margin 值重叠。</li>\n<li>为父元素添加 padding 或 border 属性，避免父元素与第一个子元素或最后一个子元素的 margin 值重叠。</li>\n</ol>\n<p>需要注意的是，margin 重叠问题只会发生在垂直方向上，不会在水平方向上发生。</p>\n<!-- 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。\n合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。\n\n产生折叠的必备条件：margin 必须是邻接的\n\n而根据 w3c 规范，两个 margin 是邻接的必须满足以下条件：\n\n- 必须是处于常规文档流（非 float 和绝对定位）的块级盒子,并且处于同一个 BFC 当中。\n- 没有线盒，没有空隙（clearance，下面会讲到），没有 padding 和 border 将他们分隔开\n- 都属于垂直方向上相邻的外边距，可以是下面任意一种情况\n- (上)元素的 margin-top 与其第一个常规文档流的子元素的 margin-top\n- (中)元素的 margin-bottom 与其下一个常规文档流的兄弟元素的 margin-top\n- (下)height 为 auto 的元素的 margin-bottom 与其最后一个常规文档流的子元素的 margin-bottom\n- 高度为 0 并且最小高度也为 0，不包含常规文档流的子元素，并且自身没有建立新的 BFC 的元素的 margin-top 和 margin-bottom\n\n作者：LOVE 小狼\n链接：https://www.jianshu.com/p/9c22ff05b9dd\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->\n\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><p>Block formatting contexts，译为块级格式化上下文，它是指块级元素所在的一个环境</p>\n<h3 id=\"clearance\"><a href=\"#clearance\" class=\"headerlink\" title=\"clearance\"></a>clearance</h3><p>闭合浮动的元素会在其 margin-top 以上产生一定的空隙，该空隙会阻止元素 margin-top 的折叠，并作为间距存在于元素的 margin-top 的上方。</p>\n<p>‘display‘、‘position‘和‘float‘的相互关系？</p>\n<h2 id=\"15-简单介绍使用图片-base64-编码的优点和缺点？\"><a href=\"#15-简单介绍使用图片-base64-编码的优点和缺点？\" class=\"headerlink\" title=\"15. 简单介绍使用图片 base64 编码的优点和缺点？\"></a>15. 简单介绍使用图片 base64 编码的优点和缺点？</h2><p><em>一、写在前面</em><br>base64 编码是一种图片处理格式，通过特定的算法将图片编码成一个长串字符串，在页面上显示的时候，可以用该字符串来代替图片的 url 属性。</p>\n<p><em>二、使用 base64 的优点是：</em></p>\n<p>1、减少一个图片的 http 请求。</p>\n<p><em>三、使用 base64 的缺点是：</em></p>\n<p>1、<em>体积问题</em> 根据 base64 的编码原理，编码后的大小会比原文件大 1&#x2F;3,如果把大图片编码到 html&#x2F;css 中，不仅会造<br>成文件体积增加，影响文件的加载速度，还会增加浏览器对 html 或 css 文件解析渲染的时间。<br>2、<em>缓存问题</em> 使用 base64 无法直接缓存，要缓存只能缓存包含 base64 的文件，比如 HTML 或者 CSS，这相比于直接缓存图片<br>的效果要差很多。<br>3、<em>兼容性的问题</em> ，ie8 以前的浏览器不支持。<br>一般一些网站的小图标可以使用 base64 图片来引入。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/124042418\">https://blog.csdn.net/weixin_47450807/article/details/124042418</a></p>\n<h2 id=\"15-使用图片-base64-编码的优点和缺点-chatGPT\"><a href=\"#15-使用图片-base64-编码的优点和缺点-chatGPT\" class=\"headerlink\" title=\"15. 使用图片 base64 编码的优点和缺点 chatGPT\"></a>15. 使用图片 base64 编码的优点和缺点 chatGPT</h2><p>使用图片 base64 编码的优点：</p>\n<ol>\n<li><code>减少 HTTP 请求次数，加快网页加载速度</code>。在不需要缓存的情况下，减少了服务器的负担和带宽压力。</li>\n<li><code>适合小图标和简单的图片</code>，可以减小图片大小，节省了图片的加载时间。</li>\n<li><code>适合作为 CSS 背景图片或小图片</code>，使用方便，不需要单独请求图片资源。</li>\n<li><code>可以防止图片被盗用</code>，因为使用 base64 编码后，图片无法直接下载保存到本地。</li>\n</ol>\n<p>使用图片 base64 编码的缺点：</p>\n<ol>\n<li><code>图片文件大小会变大</code>。由于 base64 编码后，每个字符代表的是 6 个二进制位，因此会将原本的二进制数据转化为更多的字符，导致文件大小增加。</li>\n<li><code>编码后的文件不能进行缓存</code>。如果同一张图片在多个页面中使用，每次都需要重新加载，影响页面加载速度。</li>\n<li><code>编码后的文件无法进行修改</code>，每次修改都需要重新编码。</li>\n<li><code>可能会影响图片质量</code>。编码后的字符串会将原本的二进制数据转换为 ASCII 字符，这种转换可能会导致部分像素的精度损失，从而影响图片质量。</li>\n</ol>\n<h2 id=\"16-绝对定位元素与非绝对定位元素的百分比计算的区别？\"><a href=\"#16-绝对定位元素与非绝对定位元素的百分比计算的区别？\" class=\"headerlink\" title=\"16. 绝对定位元素与非绝对定位元素的百分比计算的区别？\"></a>16. 绝对定位元素与非绝对定位元素的百分比计算的区别？</h2><!-- *绝对定位元素的宽高百分比*是相对于临近的 position 不为 static 的祖先元素的\npadding box 来计算的。\n\n*非绝对定位元素的宽高百分比*则是相对于父元素的 content box 来计算的。 -->\n\n<p>绝对定位元素与非绝对定位元素的百分比计算的区别<strong>在于它们的计算基准不同</strong>。</p>\n<p>对于非绝对定位元素，它们的百分比计算是相对于其父元素的宽度来计算的。例如，如果一个元素设置了宽度为 50%，那么它的宽度将会是其父元素宽度的 50%。</p>\n<p>而对于绝对定位元素，它们的百分比计算是相对于最近的具有定位属性（position 为 relative、absolute、fixed）的父元素的宽度来计算的。如果最近的定位祖先元素不存在，则相对于最外层的容器宽度计算。如果最外层的容器宽度也未知，则相对于浏览器窗口宽度计算。</p>\n<p>这个区别可以带来一些有趣的效果，比如，一个相对定位的元素可以成为绝对定位元素的父级，使得后者的百分比计算基准改变。同时，如果一个元素既是绝对定位元素的父级，又需要进行百分比计算，可以将其设置为相对定位元素，以便进行百分比计算。</p>\n<h2 id=\"17-width-100-和-width-auto-有什么区别\"><a href=\"#17-width-100-和-width-auto-有什么区别\" class=\"headerlink\" title=\"17. width: 100%和 width: auto 有什么区别\"></a>17. width: 100%和 width: auto 有什么区别</h2><p><em>设置 children 元素 margin: 0</em> , 此时设置 width：100%和 width: auto 是没有什么区别的。</p>\n<p><em>如果设置 children 元素 margin: 0 30px 时</em></p>\n<p>width: auto 的元素宽度变化，宽度 &#x3D; 父元素宽度 - 左边 margin - 右边 margin， 并且向左偏移 30px。<br>width: 100%的元素宽度不变， 位置向左偏移 30px；</p>\n<p><em>如果设置 children 元素 margin: 0 -30px 时</em></p>\n<p>width: auto 的元素宽度变化，宽度 &#x3D; 父元素宽度 - 左边 margin - 右边 margin，并且向左偏移 30px ，并且向左偏移-30px;<br>width: 100%的元素宽度不变，位置向左偏移-30px；</p>\n<p><a href=\"https://blog.csdn.net/weixin_47450807/article/details/124038254\" target=\"_blank\" >见</a></p>\n<h2 id=\"17-width-100-和-width-auto-有什么区别-1\"><a href=\"#17-width-100-和-width-auto-有什么区别-1\" class=\"headerlink\" title=\"17. width: 100%和 width: auto 有什么区别\"></a>17. width: 100%和 width: auto 有什么区别</h2><h3 id=\"计算宽度的方式不同\"><a href=\"#计算宽度的方式不同\" class=\"headerlink\" title=\"计算宽度的方式不同\"></a>计算宽度的方式不同</h3><p><code>width: 100%</code> 和 <code>width: auto</code> 都是用来设置元素的宽度的属性，它们的区别在于计算宽度的方式不同。</p>\n<ul>\n<li><code>width: 100%</code>：<strong>元素的宽度会根据父元素的宽度来计算，宽度始终是父元素宽度的百分比</strong>。例如，如果一个元素设置了 <code>width: 100%</code>，那么它的宽度将始终等于其父元素的宽度。</li>\n<li><code>width: auto</code>：<strong>元素的宽度会根据其内容的大小来计算，宽度会自动扩展以适应内容的大小</strong>。如果元素没有设置宽度，它将会默认使用 <code>width: auto</code>。</li>\n</ul>\n<p>需要注意的是，</p>\n<ol>\n<li>当一个元素使用了 <code>width: auto</code> 并且它的父元素也没有设置宽度时，元素的宽度将会被默认设置为它所包含内容的宽度。</li>\n<li>但是如果它的父元素设置了宽度，则元素的宽度将会根据其内容的大小自动调整，但不会超出其父元素的宽度。</li>\n</ol>\n<p>综上所述，<code>width: 100%</code> 和 <code>width: auto</code> 用来设置元素的宽度，计算宽度的方式不同，需要根据具体的需求来选择合适的属性。</p>\n<h3 id=\"其他差异\"><a href=\"#其他差异\" class=\"headerlink\" title=\"其他差异\"></a>其他差异</h3><p>除了上述的区别，<code>width: 100%</code> 和 <code>width: auto</code> 还有一些其他的差异：</p>\n<ul>\n<li><code>width: 100%</code>：宽度是相对于父元素的百分比计算，<strong>如果父元素的宽度改变，子元素的宽度也会相应地发生变化</strong>。</li>\n<li><code>width: auto</code>：宽度是根据元素内容自适应计算的，<strong>如果父元素的宽度改变，子元素的宽度也不会受到影响，它只会根据内容自适应调整宽度</strong>。</li>\n</ul>\n<p>此外，<code>width: auto</code> 还有一个特点就是对于一些元素，如 <code>&lt;img&gt;</code>、<code>&lt;video&gt;</code> 等内联元素或替换元素，<strong>它们的宽度默认为元素本身的宽度，即自适应计算的宽度，所以不需要设置宽度</strong>。</p>\n<p>综上所述，选择使用 <code>width: 100%</code> 还是 <code>width: auto</code> 取决于具体的情况和需求。</p>\n<ol>\n<li>如果希望元素的宽度可以随着父元素的宽度变化而自适应调整，可以使用 <code>width: 100%</code>，</li>\n<li>如果希望元素的宽度根据内容自适应调整，可以使用 <code>width: auto</code>。</li>\n</ol>\n<h3 id=\"这里有个有意思的点\"><a href=\"#这里有个有意思的点\" class=\"headerlink\" title=\"这里有个有意思的点\"></a>这里有个有意思的点</h3><p>如果想对可替换元素设置最小宽度，又想再父元素变小的时候，能够随父元素动态变化不溢出，使用上述理论进行组合</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">min-width: 400px;\nwidth: 100%;</code></pre>\n\n<h2 id=\"18-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？\"><a href=\"#18-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？\" class=\"headerlink\" title=\"18. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？\"></a>18. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？</h2><h3 id=\"visibility-属性三种值，\"><a href=\"#visibility-属性三种值，\" class=\"headerlink\" title=\"visibility 属性三种值，\"></a>visibility 属性三种值，</h3><ul>\n<li>visible，没有任何变化。</li>\n<li>hidden：相当于 opacity: 0</li>\n<li>collapse：有时候是 <code>visibility：hidden</code>， 有时候是 <code>display:none</code><ul>\n<li>对于一般元素来说 visibility：collapse 表现的样式和 hidden 一样，</li>\n<li>但是对于 table 相关的元素，比如 table group，table 列，table column group,他的表现却跟 display:none 一样，也就是说，他们占用的空间都会被释放掉。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"存在兼容性问题：\"><a href=\"#存在兼容性问题：\" class=\"headerlink\" title=\"存在兼容性问题：\"></a>存在兼容性问题：</h3><p>在谷歌浏览器里，使用 collapse 值和使用 hidden 值没有什么区别。<br>在火狐浏览器、Opera 和 IE11 里，使用 collapse 值的效果就如它的字面意思：table 的行会消失，它的下面一行<br>会补充它的位置。</p>\n<p>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/124037787\">https://blog.csdn.net/weixin_47450807/article/details/124037787</a></p>\n<h2 id=\"19-什么是包含块，对于包含块的理解？\"><a href=\"#19-什么是包含块，对于包含块的理解？\" class=\"headerlink\" title=\"19. 什么是包含块，对于包含块的理解？\"></a>19. 什么是包含块，对于包含块的理解？</h2><p>包含块（containing block）是 CSS 布局中的一个概念，<code>用于确定元素的布局和定位</code>。<br>每个元素都有一个包含块，<code>它是一个坐标系统，可以用来计算元素的位置和尺寸</code>。</p>\n<ol>\n<li><code>对于绝对定位元素来说</code>，包含块是离它最近的具有定位属性（position 属性的值为 absolute、relative、fixed 或 sticky）的祖先元素。如果没有这样的祖先元素，则包含块是初始包含块，即根元素。</li>\n<li><code>对于固定定位元素来说</code>，包含块是根元素，因为它们不会受到滚动影响，相当于永远在屏幕上的固定位置。</li>\n<li><code>对于非定位元素来说</code>，包含块是它的直接父元素。如果父元素没有定位属性，则该元素的包含块就是父元素的包含块，以此类推，一直到初始包含块为止。</li>\n</ol>\n<p>包含块在 CSS 中非常重要，因为它是元素布局和定位的关键因素之一。</p>\n<ol>\n<li>对于绝对定位元素，它们的<code>位置和尺寸是相对于包含块计算的</code>。</li>\n<li>对于相对定位元素，<code>它们的位置也是相对于包含块计算的</code>，但是它们不会改变包含块的大小和位置。</li>\n<li>对于固定定位元素，<code>它们的位置也是相对于包含块计算的</code>，但是它们不会受到包含块的滚动影响。</li>\n</ol>\n<h3 id=\"是什么-1\"><a href=\"#是什么-1\" class=\"headerlink\" title=\"是什么\"></a>是什么</h3><p>元素用来计算和定位的一个框</p>\n<h3 id=\"分情况\"><a href=\"#分情况\" class=\"headerlink\" title=\"分情况\"></a>分情况</h3><p><em>默认情况下包含块</em> 就是离当前元素最近的块级祖先元素。<br><em>对于开启绝对定位的元素来说</em> 包含块是离它最近的开启了定位(且 position 不为 static)的祖先元素。<br><em>如果所有的祖先元素都没有开启定位</em> 则其包含块就是初始包含块（根元素）。</p>\n<h2 id=\"20-为什么要初始化-CSS-的样式\"><a href=\"#20-为什么要初始化-CSS-的样式\" class=\"headerlink\" title=\"20. 为什么要初始化 CSS 的样式\"></a>20. 为什么要初始化 CSS 的样式</h2><h3 id=\"为什么？\"><a href=\"#为什么？\" class=\"headerlink\" title=\"为什么？\"></a>为什么？</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 css 初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>\n<p>初始化的目的，并不是去除边框，只是为了统一所有的浏览器，正常化</p>\n<h3 id=\"淘宝初始化\"><a href=\"#淘宝初始化\" class=\"headerlink\" title=\"淘宝初始化\"></a>淘宝初始化</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* \nbody,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend\n,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;\nbody,button,input,select,textarea&#123;font:12px&#x2F;1.5tahoma,arial,\\5b8b\\4f53;&#125;\nh1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;\naddress,cite,dfn,em,var&#123;font-style:normal;&#125;\ncode,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;\nsmall&#123;font-size:12px;&#125;\nul,ol&#123;list-style:none;&#125; &#x2F;&#x2F;常见\na&#123;text-decoration:none;&#125; &#x2F;&#x2F;常见\na:hover&#123;text-decoration:underline;&#125; &#x2F;&#x2F;常见\nsup&#123;vertical-align:text-top;&#125; &#x2F;&#x2F;常见\nsub&#123;vertical-align:text-bottom;&#125; &#x2F;&#x2F;常见\nlegend&#123;color:#000;&#125;\nfieldset,img&#123;border:0;&#125;\nbutton,input,select,textarea&#123;font-size:100%;&#125;\ntable&#123;border-collapse:collapse;border-spacing:0;&#125; \n*&#x2F;</code></pre>\n\n<h2 id=\"20-li-与-li-之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？\"><a href=\"#20-li-与-li-之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？\" class=\"headerlink\" title=\"20. li 与 li 之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？\"></a>20. li 与 li 之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><p><strong>原因</strong></p>\n<p>li 与 li 之间存在看不见的空白间隔是<strong>因为 HTML 中代码格式换行、空格或 Tab 造成的</strong>，<strong>这些空白符会被浏览器解析为文本节点，并占据一定的宽度。</strong></p>\n<p><strong>解决办法：</strong></p>\n<ol>\n<li><p><code>删除 li 标签之间的所有空白符</code>。这种方法简单粗暴，但是会破坏代码的可读性和维护性，不推荐使用。</p>\n</li>\n<li><p><code>将 li 标签的结束标记放在开始标记的下一行</code>。这种方法可以避免空白间隔的问题，同时保持代码的可读性，但是在语义上可能不太合理。</p>\n</li>\n<li><p><code>将 ul 或 ol 的 font-size 设置为 0，将 li 的 font-size 设置为需要的值</code>。这种方法可以避免空白间隔问题，同时保持语义合理，但是可能需要调整 li 中其他元素的字体大小。</p>\n</li>\n<li><p><code>将 li 的 display 属性设置为 inline-block</code>。这种方法可以将 li 元素看做行内块级元素，避免了空白间隔问题，但是可能会影响到 li 元素的布局和样式。</p>\n</li>\n</ol>\n<p>一般来说，推荐使用第三种方法，将父元素的字体大小设置为 0，然后在子元素中设置需要的字体大小，可以避免空白间隔问题，同时保持语义合理。</p>\n<h2 id=\"21-浏览器兼容性及其解决方案整理\"><a href=\"#21-浏览器兼容性及其解决方案整理\" class=\"headerlink\" title=\"21. 浏览器兼容性及其解决方案整理\"></a>21. 浏览器兼容性及其解决方案整理</h2><h2 id=\"22-CSS-多列等高如何实现\"><a href=\"#22-CSS-多列等高如何实现\" class=\"headerlink\" title=\"22. CSS 多列等高如何实现\"></a>22. CSS 多列等高如何实现</h2><ul>\n<li>table 布局实现等高</li>\n<li>使用 flex 布局</li>\n<li>grid 布局</li>\n</ul>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.box &#123;\n  width: 300px;\n  display: grid;\n  grid-auto-flow: column;\n&#125;\n.left &#123;\n  background-color: red;\n&#125;\n.right &#123;\n  background-color: gainsboro;\n&#125;\n&#x2F;* ———————————————— 版权声明：本文为CSDN博主「卖菜的小白」的原创文章，遵循CC 4.0\nBY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47450807&#x2F;article&#x2F;details&#x2F;124012215 *&#x2F;</code></pre>\n\n<h2 id=\"23-前端-css-高频面试题——em-x2F-px-x2F-rem-x2F-vw-x2F-vh-的区别？\"><a href=\"#23-前端-css-高频面试题——em-x2F-px-x2F-rem-x2F-vw-x2F-vh-的区别？\" class=\"headerlink\" title=\"23. 前端 css 高频面试题——em&#x2F;px&#x2F;rem&#x2F;vw&#x2F;vh 的区别？\"></a>23. 前端 css 高频面试题——em&#x2F;px&#x2F;rem&#x2F;vw&#x2F;vh 的区别？</h2><h2 id=\"24-一个品字布局如何设计？\"><a href=\"#24-一个品字布局如何设计？\" class=\"headerlink\" title=\"24. 一个品字布局如何设计？\"></a>24. 一个品字布局如何设计？</h2><h2 id=\"25-用纯-CSS-创建一个三角形的原理是什么？\"><a href=\"#25-用纯-CSS-创建一个三角形的原理是什么？\" class=\"headerlink\" title=\"25. 用纯 CSS 创建一个三角形的原理是什么？\"></a>25. 用纯 CSS 创建一个三角形的原理是什么？</h2><div style=\"display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;\">\n<img src=\"http://t-blog-images.aijs.top/img/202210232319912.png\" style=\"width: 100px\" />\n\n<img src=\"http://t-blog-images.aijs.top/img/202210232319463.png\" style=\"width: 100px\" />\n</div>\n\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">div &#123;\n  &#x2F;* 宽高都设置为0 *&#x2F;\n  width: 0px;\n  height: 0px;\n  &#x2F;* border的宽度设置为30px *&#x2F;\n  border-width: 30px;\n  &#x2F;* border-style设置为实线 *&#x2F;\n  border-style: solid;\n  &#x2F;* border的上左右的颜色都设置为透明 *&#x2F;\n  border-color: red transparent transparent transparent;\n  &#x2F;* border-color: transparent red transparent transparent; *&#x2F;\n  &#x2F;* border-color: transparent transparent red transparent; *&#x2F;\n  &#x2F;* border-color: transparent transparent transparent red; *&#x2F;\n  &#x2F;* 加上这一行可以让三角形顶格， 不加三角形会下移20px *&#x2F;\n  &#x2F;* border-top: none; *&#x2F; &#x2F;* 因为border有顶部宽度 *&#x2F;\n&#125;</code></pre>\n\n<p><a href=\"https://www.cnblogs.com/lidaying5/p/12605809.html\" target=\"_blank\" >见</a></p>\n<p>用纯 CSS 创建三角形通常采用 CSS 的 border 属性和 transform 属性。下面是两种常见的方法：</p>\n<p><strong>方法一：使用 border 属性和 transform 属性</strong></p>\n<p>通过设置元素的 border 属性，利用 CSS 的 transform 属性实现旋转，将一个正方形旋转 45 度，就可以得到一个等腰直角三角形。</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.triangle &#123;\n  width: 0;\n  height: 0;\n  border-top: 50px solid transparent;\n  border-right: 50px solid #333;\n  border-bottom: 50px solid transparent;\n  border-left: none;\n  transform: rotate(45deg);\n&#125;</code></pre>\n\n<p><strong>方法二：使用伪元素</strong></p>\n<p>可以通过给元素添加伪元素，然后通过伪元素的 border 属性和 transform 属性实现三角形的效果。</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.triangle &#123;\n  position: relative;\n  width: 100px;\n  height: 100px;\n  background-color: #333;\n&#125;\n\n.triangle::before &#123;\n  content: &#39;&#39;;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-top: 50px solid transparent;\n  border-right: 50px solid #333;\n  border-bottom: 50px solid transparent;\n  border-left: none;\n  transform: rotate(45deg);\n&#125;</code></pre>\n\n<p>以上两种方法都是利用 CSS 的 border 属性和 transform 属性来实现的，通过调整 border 的宽度和颜色，以及 transform 的角度和旋转中心，可以创建不同形状的三角形。</p>\n<h2 id=\"26-CSS3-的-flex-布局总结？\"><a href=\"#26-CSS3-的-flex-布局总结？\" class=\"headerlink\" title=\"26. CSS3 的 flex 布局总结？\"></a>26. CSS3 的 flex 布局总结？</h2><ol>\n<li>背景</li>\n<li>组成：容器+容器成员</li>\n<li>方向</li>\n<li>6 个属性</li>\n<li>缩写是什么意思</li>\n</ol>\n<p>一、简单介绍<br>flex 是 flexibleBox 的缩写，意为<code>弹性布局</code>，用来为盒模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 flex 布局。</p>\n<p><strong>注意，设为 flex 布局以后，子元素的 float，clear,vertical-align 属性将失效。</strong></p>\n<p>采用 flex 布局的元素，称为 <code>flex 容器</code>，简称<code>容器</code>。他的所以子元素称为<code>容器成员</code>，称为 <code>flex 元素</code>，简称<code>元素</code>。<br>容器默认存在两根轴：<code>水平的主轴（main axis）</code>和<code>垂直的辅轴（cross axis）</code>，<code>元素默认沿主轴排列</code>。</p>\n<p>二、6 个属性</p>\n<p>1、<code>flex-direction</code>:属性决定主轴的方向（即元素的排列方向），默认是横轴方向。属性值为 <code>row-reverse</code>,<code>row</code>,<code>col</code>,<code>col-reverse</code>。<br>2、<code>flex-wrap</code>:属性定义，如果一条轴线排列不下，如何换行。<code>wrap:换行</code>，<code>no-wrap:不换行</code>,<code>wrap-reverse:翻转换行</code>。<br>3、<code>flex-flow</code>:属性是 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性的简写形式，默认值为 <code>row nowrap</code>。<br>4、<code>justify-content</code>: 6 个值，属性定义了元素在主轴的对齐方式。可选值为 flex-start,flex-end,center,space-around,space-between，stretch。<br>5、<code>align-items</code>:4 个值，属性在辅线上如何对齐。存在的属性有：flex-end,flex-start,center,strech。<br>6、<code>align-content</code>:属性定义多根轴线的对其方式，如果只存在一根轴线，则不起作用。存在的属性有：center，flex-end,flex-start,space-around,space-between,stretch。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_47450807/article/details/123988959\">https://blog.csdn.net/weixin_47450807/article/details/123988959</a></p>\n<h2 id=\"27-CSS-中的-position-的值及其作用？display-有哪些值？\"><a href=\"#27-CSS-中的-position-的值及其作用？display-有哪些值？\" class=\"headerlink\" title=\"27. CSS 中的 position 的值及其作用？display 有哪些值？\"></a>27. CSS 中的 position 的值及其作用？display 有哪些值？</h2><!-- 1、`relative`: 生成固定定位的元素，相对于元素本身正常的文档流进行定位。\n2、`absolute` :生成绝对定位的元素，相对于值不为 static 的第一个父元素的 padding box 进行定位\n3、`fixed`（老 IE 不支持）:生成固定定位的元素，相对于浏览器窗口进行定位。\n4、`static`: 默认值。没有定位，元素出现在正常的流中（忽略 top,bottom,left,right,z-index 声明）。\n5、`inherit`: 表示从父元素中继承 position 中的值。 -->\n\n<p>CSS 中的 position 属性用于指定一个元素在文档中的定位方式，其可选值及作用如下：</p>\n<ol>\n<li><p><code>static（默认值）</code>：元素正常定位，即遵循文档流。</p>\n</li>\n<li><p><code>relative：相对定位</code>，元素的位置相对于其在文档流中的初始位置来定位。通过 top、right、bottom、left 属性可以调整相对定位的位置。</p>\n</li>\n<li><p><code>absolute：绝对定位</code>，元素的位置相对于其最近的非 static 定位祖先元素来定位。如果没有非 static 定位祖先元素，则相对于文档的 body 元素。通过 top、right、bottom、left 属性可以调整绝对定位的位置。</p>\n</li>\n<li><p><code>fixed：固定定位</code>，元素的位置相对于浏览器窗口固定不动。通过 top、right、bottom、left 属性可以调整固定定位的位置。</p>\n</li>\n<li><p><code>sticky：粘性定位</code>，元素在跨越特定阈值前为相对定位，之后为固定定位。通常配合 top、right、bottom、left 属性使用。</p>\n</li>\n</ol>\n<p>需要注意的是，除了 static 定位以外，其他定位方式都可以通过 top、right、bottom、left 属性来控制元素的位置。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>元素<strong>根据正常文档流进行定位</strong>，然后相对它的<strong>最近滚动祖先和最近块级祖先</strong>，<strong>包括 table-related 元素</strong>，基于 top、right、bottom 和 left 的值进行偏移。</p>\n<p>偏移值不会影响任何其他元素的位置。</p>\n<p>该值总是创建一个新的层叠上下文（stacking context）。</p>\n<p>注意，<strong>一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上</strong>（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见 Github issue on W3C CSSWG</p></blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#%E5%8F%96%E5%80%BC\" target=\"_blank\" >MDN</a></p>\n<h2 id=\"display\"><a href=\"#display\" class=\"headerlink\" title=\"display\"></a>display</h2><p>display 属性值介绍：</p>\n<ul>\n<li><p><code>none</code> 此元素不会被显示。</p>\n</li>\n<li><p><code>block</code> 此元素将显示为块级元素，此元素前后会带有换行符。</p>\n</li>\n<li><p><code>inline</code> 默认。此元素会被显示为内联元素，元素前后没有换行符。</p>\n</li>\n<li><p><code>inline-block</code> 行内块元素。（CSS2.1 新增的值）</p>\n</li>\n<li><p><code>list-item</code> 此元素会作为列表显示。</p>\n</li>\n<li><p><code>run-in</code> 此元素会根据上下文作为块级元素或内联元素显示。</p>\n</li>\n<li><p><s><code>compact</code> CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</s></p>\n</li>\n<li><p><s><code>marker</code> CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</s></p>\n</li>\n<li><p><code>table</code> 此元素会作为块级表格来显示（类似 <code>&lt;table&gt;</code>），表格前后带有换行符。</p>\n</li>\n<li><p><code>inline-table</code> 此元素会作为内联表格来显示（类似 <code>&lt;table&gt;</code>），表格前后没有换行符。</p>\n</li>\n<li><p><code>table-row-group</code> 此元素会作为一个或多个行的分组来显示（类似 <code>&lt;tbody&gt;</code>）。</p>\n</li>\n<li><p><code>table-header-group</code> 此元素会作为一个或多个行的分组来显示（类似 <code>&lt;thead&gt;</code>）。</p>\n</li>\n<li><p><code>table-footer-group</code> 此元素会作为一个或多个行的分组来显示（类似 <code>&lt;tfoot&gt;</code>）。</p>\n</li>\n<li><p><code>table-row</code> 此元素会作为一个表格行显示（类似 <code>&lt;tr&gt;</code>）。</p>\n</li>\n<li><p><code>table-column-group</code> 此元素会作为一个或多个列的分组来显示（类似 <code>&lt;colgroup&gt;</code>）。</p>\n</li>\n<li><p><code>table-column</code> 此元素会作为一个单元格列显示（类似 <code>&lt;col&gt;</code>）</p>\n</li>\n<li><p><code>table-cell</code> 此元素会作为一个表格单元格显示（类似 <code>&lt;td&gt; </code>和 <code>&lt;th&gt;</code>）</p>\n</li>\n<li><p><code>table-caption</code> 此元素会作为一个表格标题显示（类似 <code>&lt;caption&gt;</code>）</p>\n</li>\n<li><p><code>inherit</code> 规定应该从父元素继承 display 属性的值。</p>\n</li>\n</ul>\n<p><a href=\"https://www.php.cn/css-tutorial-457105.html\" target=\"_blank\" >见</a></p>\n<h2 id=\"26-如何居中-div\"><a href=\"#26-如何居中-div\" class=\"headerlink\" title=\"26. 如何居中 div\"></a>26. 如何居中 div</h2><ul>\n<li>使用 margin: 0 auto</li>\n<li>flex 布局</li>\n<li>绝对定位 + margin</li>\n<li>绝对定位 + transform</li>\n</ul>\n<h2 id=\"27-CSS3-新增伪类有哪些\"><a href=\"#27-CSS3-新增伪类有哪些\" class=\"headerlink\" title=\"27. CSS3 新增伪类有哪些\"></a>27. CSS3 新增伪类有哪些</h2><h2 id=\"28-CSS-优先级算法如何计算\"><a href=\"#28-CSS-优先级算法如何计算\" class=\"headerlink\" title=\"28. CSS 优先级算法如何计算\"></a>28. CSS 优先级算法如何计算</h2><p>注意: <em>这里针对的是一条属性 (理解这个 “一条属性” )，当某一个属性，本身就比另一属性优先级低，再怎么配置，也不会展示此属性如（max-width 和 width， media 媒体查询等)</em></p>\n<ul>\n<li>判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。<br>一条声明如果加上权重，那么他的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</li>\n<li>一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。</li>\n</ul>\n<p><em>选择器的特殊性可以分为四个等级，</em></p>\n<ul>\n<li><p>第一个等级是<code>行内样式</code>，为 1 0 0 0,</p>\n</li>\n<li><p>第二个等级是 <code>id 选择器</code>，为 0 1 0 0 ，</p>\n</li>\n<li><p>第三个等级是<code>类选择器，伪类选择器，属性选择器</code>为：0 0 1 0，</p>\n</li>\n<li><p>第四个等级是<code>元素选择器和伪元素选择器</code>：0 0 0 1。</p>\n</li>\n<li><p>规则中每出现一个选择器，就将他的特殊性进行累加，<em>这个累加只限于对应等级的累加，不会产生进位</em> 。选择器特殊性值的比较是从左向右排序的，也就是说以 1 开头的特殊性比所有 0 开头的特殊性值要大。比如说特殊性值为 1000 的规则优先级就要比特殊性值为 0999 的规则高。如果两个规则的特殊性值相等的时候，那么就会根据他们引用的顺序，后出现的规则的优先级最高。</p>\n</li>\n</ul>\n<h2 id=\"29-CSS-中的那些属性是可以继承的？\"><a href=\"#29-CSS-中的那些属性是可以继承的？\" class=\"headerlink\" title=\"29. CSS 中的那些属性是可以继承的？\"></a>29. CSS 中的那些属性是可以继承的？</h2><p>1、字体系列的属性</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">font\nfont-family 指定一个元素的字体\nfont-weight\nfont-size\nfont-style normal&#x2F;italic&#x2F;oblique\nfont-variant 浏览器会显示小型大写字母的字体。\n&#x2F;* 基本上不支持 *&#x2F;\nfont-stretch 基本上都不支持\nfont-size-adjust 除火狐，基本上不支持</code></pre>\n\n<p><a href=\"https://www.runoob.com/try/try.php?filename=trycss_font-variant\" target=\"_blank\" >font-variant</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202212181615362.webp\" style=\"width:500px;max-width:100%\" />\n\n<p>2、字体系列的属性</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">color\ndirection\nword-spacing  &#x2F;* 指定 &quot;段字&quot; 之间的空间，应该是30像素 *&#x2F;\nletter-spacing &#x2F;* 字母间距 *&#x2F;\nline-height\n&#x2F;* text *&#x2F;\ntext-indent\ntext-align\ntext-shadow\ntext-transform\n&#x2F;*\n转换不同元素中的文本：\n\nnone\t默认。定义带有小写字母和大写字母的标准的文本。\ncapitalize\t文本中的每个单词以大写字母开头。\nuppercase\t定义仅有大写字母。\nlowercase\t定义无大写字母，仅有小写字母。\n\n *&#x2F;</code></pre>\n\n<p>3、表格布局属性</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">caption-side &#x2F;* 指定表格标题的位置 *&#x2F;\nborder-collapse &#x2F;* 为表格设置合并边框模型   collapse&#x2F;separate *&#x2F;\nempty-cells  &#x2F;* 属性设置是否显示表格中的空单元格（仅用于&quot;分离边框&quot;模式）。 *&#x2F;\n</code></pre>\n\n<p>4、列表属性</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">list-style-type &#x2F;* 设置列表项标记的类型 *&#x2F;\nlist-style-image &#x2F;* 使用图像来替换列表项的标记 *&#x2F;\nlist-style-position &#x2F;* inside&#x2F;outside 设置在何处放置列表项标记 *&#x2F;\n&#x2F;* 上面三个缩写 *&#x2F;\nlist-style: list-style-type, list-style-position, list-style-image.</code></pre>\n\n<p>5、光标属性</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">cursor</code></pre>\n\n<p>6、元素可见性</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">visibility</code></pre>\n\n<h3 id=\"inhert\"><a href=\"#inhert\" class=\"headerlink\" title=\"inhert\"></a>inhert</h3><p>当一个属性不是继承属性的时候，此时可以使用 inhert 关键字来指定一个属性应该从父元素继承他的值，inhert 关键字用于显示的指定继承性，可以用于任何继承性和非继承性。</p>\n<h2 id=\"28-伪类和伪元素的区别？\"><a href=\"#28-伪类和伪元素的区别？\" class=\"headerlink\" title=\"28. 伪类和伪元素的区别？\"></a>28. 伪类和伪元素的区别？</h2><h3 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h3><p><em>伪类</em>用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。也就是说，当用户悬停指定的元素时，我们可以通过:hover 来描述这个元素的状态。<br><em>伪元素</em>用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。</p>\n<h3 id=\"常见伪类\"><a href=\"#常见伪类\" class=\"headerlink\" title=\"常见伪类\"></a>常见伪类</h3><p><a href=\"https://blog.csdn.net/weixin_43012215/article/details/113488202\" target=\"_blank\" >a 链接 love hate 原则有顺序</a></p>\n<p><em>a 链接相关</em></p>\n<ul>\n<li><p><code>:link</code>: 选取未访问过的超链接元素。如果我们注意过搜索引擎的结果的话，它里面的链接只要点过的就会变色，从而标记哪个链接是访问过的。:link 这个属性就是用来标识没访问过的链接。</p>\n</li>\n<li><p><code>:visited</code>: 选取访问过的超链接元素。和第一条相反，:visited 是用来标记哪个链接是已经访问过的，防止重复点击。</p>\n</li>\n<li><p><code>:hover</code>: 选取鼠标悬停的元素。，这个伪类经常用在 PC 端，当鼠标放在一个元素上时，可以用 :hover 来控制鼠标悬停的样式。因为在移动端里没有鼠标的概念，所以移动端里很少用这个伪类。</p>\n</li>\n<li><p><code>:active</code>: 选取点中的元素。这个伪类的作用在刚才提到过了，当我们希望按钮有操作反馈的时候，可以用它来标记操作反馈的样式。当然这个伪类也是可以通用的，并不是只能用在按钮上。</p>\n</li>\n<li><p><code>:empty</code>: 选取没有子元素的元素。比如选择空的 span，就可以用 span:empty 选择器来选择。这里要注意元素内有空格的话也不能算空，不会被这个伪类选中。</p>\n</li>\n<li><p><code>:focus</code>: 选取获得焦点的元素。这个伪类用来标识获得焦点的元素，比如搜索框在聚焦的时候有个比较明显的边框，方便用户知道当前在可输入的状态。</p>\n</li>\n<li><p><code>:checked</code>: 选取勾选状态的 input 元素， 只对 radio 和 checkbox 生效。</p>\n</li>\n<li><p><code>:disabled</code>: 选取禁用的表单元素。</p>\n</li>\n</ul>\n<p><em>选元素的</em></p>\n<ul>\n<li><code>:first-child</code>: 选取当前选择器下第一个元素。</li>\n<li><code>:last-child</code>: 和 first-child 相反，选取当前选择器下最后一个元素。</li>\n<li><code>:nth-child(an+b)</code>: 选取指定位置的元素。这个伪类是有参数的，参数可以支持 an+b 的形式，这里 a 和 b 都是可变的，n 从 0 起。使用这个伪类可以做到选择第几个，或者选择序号符合 an+b 的所有元素。比如使用 li:nth-child(2n+1)，就可以选中 li 元素中序号是 2 的整数倍加 1 的所有元素，也就是第 1、3、5、7、9、2n+1 个 li 元素。</li>\n<li><code>:nth-last-child(an+b)</code>: 这个伪类和 nth-child 相似，只不过在计数的时候，这个伪类是从后往前计数。</li>\n<li><code>:only-child</code>: 选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效。</li>\n<li><code>:only-of-type</code>: 选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以。</li>\n</ul>\n<p><strong>:only-of-type</strong><br><img src=\"http://t-blog-images.aijs.top/img/202212182018647.webp\" style=\"width:500px;max-width:100%\" /></p>\n<h3 id=\"常见伪元素\"><a href=\"#常见伪元素\" class=\"headerlink\" title=\"常见伪元素\"></a>常见伪元素</h3><ul>\n<li><code>::first-line:</code>为某个元素的第一行文字使用样式。</li>\n<li><code>::first-letter:</code>为某个元素中的文字的首字母或第一个字使用样式。</li>\n<li><code>::before:</code>在某个元素之前插入一些内容。</li>\n<li><code>::after:</code>在某个元素之后插入一些内容。</li>\n<li><code>::selection:</code>对光标选中的元素添加样式。</li>\n</ul>\n<h2 id=\"30-css-选择器有哪些？\"><a href=\"#30-css-选择器有哪些？\" class=\"headerlink\" title=\"30. css 选择器有哪些？\"></a>30. css 选择器有哪些？</h2><ul>\n<li>id 选择器 <code>#myId &#123;&#125;</code></li>\n<li>类选择器 <code>.myClass &#123;&#125;</code></li>\n<li>标签选择器 <code>p,h1 &#123;&#125;</code><div style=\"height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px\"></div></li>\n<li>后代选择器 <code>div h1 &#123;&#125;</code></li>\n<li>子选择器 <code>div&gt;h1 &#123;&#125;</code></li>\n<li>兄弟选择器 <code>ul~h1 &#123;&#125;</code></li>\n<li>相邻兄弟选择器 <code>ul+h1 &#123;&#125;</code><div style=\"height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px\"></div></li>\n<li>属性选择器 <code>li[name=&#39;sss&#39;] &#123;&#125;</code></li>\n<li>伪类选择器 <code>h1:hover &#123;&#125;</code></li>\n<li>伪元素选择器 <code>h1::before&#123;&#125;</code></li>\n<li>通配符选择器 <code>* &#123;&#125;</code></li>\n</ul>\n<h2 id=\"31-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？\"><a href=\"#31-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？\" class=\"headerlink\" title=\"31. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？\"></a>31. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h2><p>1、盒模型都是由四部分组成的，分别是 <code>margin，border， padding, content</code>。<br>2、标准和模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。</p>\n<p><em>标准盒模型的范围只有 content，</em><br><em>IE 盒模型的 width 和 height 属性的范围包含 border，padding 和 content。</em></p>\n<p>3、一般来说我们可以通过 box-sizing 属性来改变元素的盒模型，存在两个值，</p>\n<ul>\n<li><code>border-box</code> 表示 IE 盒模型，</li>\n<li><code>content-box</code> 表示标准盒模型。</li>\n</ul>\n<h2 id=\"32-未知大小的父元素，子元素水平垂直居中？\"><a href=\"#32-未知大小的父元素，子元素水平垂直居中？\" class=\"headerlink\" title=\"32. 未知大小的父元素，子元素水平垂直居中？\"></a>32. 未知大小的父元素，子元素水平垂直居中？</h2><ul>\n<li>flex</li>\n<li>table</li>\n<li>transform</li>\n</ul>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* table *&#x2F;\n.parent &#123;\n  width: 200px;\n  height: 200px;\n  display: table;\n  background-color: red;\n&#125;\n\n.child &#123;\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n&#125;\n&#x2F;* ———————————————— *&#x2F;\n&#x2F;* 版权声明：本文为CSDN博主「卖菜的小白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 *&#x2F;\n&#x2F;* 原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47450807&#x2F;article&#x2F;details&#x2F;123666444 *&#x2F;</code></pre>\n\n<h2 id=\"32-BFC\"><a href=\"#32-BFC\" class=\"headerlink\" title=\"32. BFC\"></a>32. BFC</h2><h3 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h3><p>BFC(Block Formatting Context)格式化上下文，是 web 页面中盒子模型布局的 CSS 渲染模式，指的是一个独立的渲染区域或者是一个隔离的独立容器。</p>\n<h3 id=\"如何创建-BFC\"><a href=\"#如何创建-BFC\" class=\"headerlink\" title=\"如何创建 BFC\"></a>如何创建 BFC</h3><p>1、<code>浮动元素</code>，float 除 none 以外。<br>2、<code>定位元素</code>，position(absolute, fixed)<br>3、<code>display</code> 为以下其中之一的值：inline-block,table-cell,table-caption.<br>4、<code>overflow</code> 除了 visible 以外的值(hidden,auto, scroll)</p>\n<h3 id=\"BFC-特点，能解决什么问题\"><a href=\"#BFC-特点，能解决什么问题\" class=\"headerlink\" title=\"BFC 特点，能解决什么问题\"></a>BFC 特点，能解决什么问题</h3><ul>\n<li><code>BFC中的盒子对齐</code>: 内部的 Box 会在垂直方向上一个接着一个的放置。</li>\n<li><code>外边距重叠</code>: 在正常的文档流中，两个兄弟盒子之间的具有由其外边距决定的，不是他们的外边距之和决定的，而是以较大的为准。</li>\n<li><code>不被浮动元素覆盖</code>: 两栏布局， 三栏布局</li>\n<li><code>可以防止字体环绕</code></li>\n<li><code>BFC 包含浮动的块</code>： 如果我们使用浮动，则该元素就会脱离正常的文档流，则会造成父元素高度的坍塌</li>\n</ul>\n<p><strong>总结（由外到内）：父元素塌陷问题、文字环绕问题、外边距重叠问题、不被浮动元素覆盖、BFC 内盒子对齐问题</strong></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/weixin_47450807/category_11702913.html\" target=\"_blank\" >weixin_47450807 的博客</a></p>\n","text":"1. 获取 CDNS 的 文章标题var list &#x3D; document.getElementsByClassName(&#39;column_article_list&#39;)[0].children; Array.from(list).forEach((item)...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"24 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"},{"name":"chatGPT2021","slug":"chatGPT2021","count":12,"path":"api/tags/chatGPT2021.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%8E%B7%E5%8F%96-CDNS-%E7%9A%84-%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98\"><span class=\"toc-text\">1. 获取 CDNS 的 文章标题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-css-%E7%9A%84-root%E3%80%81var-%E4%BB%A5%E5%8F%8A-root%E3%80%81html%E3%80%81-%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">1. css 的:root、var()以及:root、html、* 选择器优先级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-root\"><span class=\"toc-text\">1.1. :root</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-var\"><span class=\"toc-text\">1.2. var( )</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-var-%E5%9B%9E%E9%80%80%E5%80%BC\"><span class=\"toc-text\">1.3. var( )回退值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">1.4. 优先级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">2. 移动端总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%A9%E6%94%BE%E9%80%82%E9%85%8D\"><span class=\"toc-text\">缩放适配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rem-%E9%80%82%E9%85%8D\"><span class=\"toc-text\">rem 适配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vw-%E9%80%82%E9%85%8D\"><span class=\"toc-text\">vw 适配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%82%B9%E5%87%BB-300ms\"><span class=\"toc-text\">移动端点击 300ms</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-300ms\"><span class=\"toc-text\">为什么是 300ms</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F\"><span class=\"toc-text\">点击穿透</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AD%A6%E4%B9%A0-css-%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%EF%BC%9F\"><span class=\"toc-text\">3. 学习 css 文本溢出显示省略号？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%A1%8C\"><span class=\"toc-text\">单行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%A1%8C\"><span class=\"toc-text\">多行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-translate-x2F-position%EF%BC%9F\"><span class=\"toc-text\">4. translate &#x2F; position？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS3-%E4%B8%AD-translate-x2F-position-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">CSS3 中 translate &#x2F; position 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BD%A0%E5%AF%B9%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">5. 你对媒体查询的理解？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">如何使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CSS-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">CSS 语法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E4%BD%A0%E5%AF%B9-css-sprites-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">6. 你对 css sprites 的理解，好处是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E6%9C%89%E5%93%AA%E4%BA%9B%E2%BD%85%E5%BC%8F%EF%BC%88CSS%EF%BC%89%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E2%BB%9A%E2%BE%AF%E5%85%83%E7%B4%A0%EF%BC%9F\"><span class=\"toc-text\">7. 有哪些⽅式（CSS）可以隐藏⻚⾯元素？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-link-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">8. link 和@import 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-margin-%E5%92%8C-padding-%E5%88%86%E5%88%AB%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">9. margin 和 padding 分别适合什么场景使用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-margin\"><span class=\"toc-text\">何时使用 margin</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-padding\"><span class=\"toc-text\">何时使用 padding</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E6%9E%90-CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">10. 浏览器是怎样解析 CSS 选择器的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%EF%BC%9F\"><span class=\"toc-text\">11. 请解释一下为什么需要清除浮动？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%85%E6%8B%AC%EF%BC%9A\"><span class=\"toc-text\">常见的清除浮动的方法包括：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8\"><span class=\"toc-text\">使用空的块级元素清除浮动</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-overflow-%E5%B1%9E%E6%80%A7%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8\"><span class=\"toc-text\">使用 overflow 属性清除浮动</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-clearfix-%E6%8A%80%E5%B7%A7%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8\"><span class=\"toc-text\">使用 clearfix 技巧清除浮动</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-flex-x2F-grid-%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">替代方案 flex&#x2F;grid 布局</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-css-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%EF%BC%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-css-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">13. css 块级元素，行内元素和行内块级元素 css 三栏布局总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-margin-%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F\"><span class=\"toc-text\">14. 如何理解 margin 重叠问题？？？？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC\"><span class=\"toc-text\">BFC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#clearance\"><span class=\"toc-text\">clearance</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87-base64-%E7%BC%96%E7%A0%81%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">15. 简单介绍使用图片 base64 编码的优点和缺点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87-base64-%E7%BC%96%E7%A0%81%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9-chatGPT\"><span class=\"toc-text\">15. 使用图片 base64 编码的优点和缺点 chatGPT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E4%B8%8E%E9%9D%9E%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">16. 绝对定位元素与非绝对定位元素的百分比计算的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-width-100-%E5%92%8C-width-auto-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">17. width: 100%和 width: auto 有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-width-100-%E5%92%8C-width-auto-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-1\"><span class=\"toc-text\">17. width: 100%和 width: auto 有什么区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E5%AE%BD%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">计算宽度的方式不同</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%B7%AE%E5%BC%82\"><span class=\"toc-text\">其他差异</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9\"><span class=\"toc-text\">这里有个有意思的点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-CSS-%E9%87%8C%E7%9A%84-visibility-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%B8%AA-collapse-%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AF%E5%B9%B2%E5%98%9B%E7%94%A8%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">18. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#visibility-%E5%B1%9E%E6%80%A7%E4%B8%89%E7%A7%8D%E5%80%BC%EF%BC%8C\"><span class=\"toc-text\">visibility 属性三种值，</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%9C%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">存在兼容性问题：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85%E5%90%AB%E5%9D%97%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%8C%85%E5%90%AB%E5%9D%97%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\"><span class=\"toc-text\">19. 什么是包含块，对于包含块的理解？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88-1\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%83%85%E5%86%B5\"><span class=\"toc-text\">分情况</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96-CSS-%E7%9A%84%E6%A0%B7%E5%BC%8F\"><span class=\"toc-text\">20. 为什么要初始化 CSS 的样式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">为什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%98%E5%AE%9D%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">淘宝初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-li-%E4%B8%8E-li-%E4%B9%8B%E9%97%B4%E5%AD%98%E5%9C%A8%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E7%A9%BA%E7%99%BD%E9%97%B4%E9%9A%94%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">20. li 与 li 之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86\"><span class=\"toc-text\">21. 浏览器兼容性及其解决方案整理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-CSS-%E5%A4%9A%E5%88%97%E7%AD%89%E9%AB%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">22. CSS 多列等高如何实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23-%E5%89%8D%E7%AB%AF-css-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94em-x2F-px-x2F-rem-x2F-vw-x2F-vh-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">23. 前端 css 高频面试题——em&#x2F;px&#x2F;rem&#x2F;vw&#x2F;vh 的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-%E4%B8%80%E4%B8%AA%E5%93%81%E5%AD%97%E5%B8%83%E5%B1%80%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F\"><span class=\"toc-text\">24. 一个品字布局如何设计？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-%E7%94%A8%E7%BA%AF-CSS-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">25. 用纯 CSS 创建一个三角形的原理是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26-CSS3-%E7%9A%84-flex-%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93%EF%BC%9F\"><span class=\"toc-text\">26. CSS3 的 flex 布局总结？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27-CSS-%E4%B8%AD%E7%9A%84-position-%E7%9A%84%E5%80%BC%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9Fdisplay-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%80%BC%EF%BC%9F\"><span class=\"toc-text\">27. CSS 中的 position 的值及其作用？display 有哪些值？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#display\"><span class=\"toc-text\">display</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26-%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD-div\"><span class=\"toc-text\">26. 如何居中 div</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27-CSS3-%E6%96%B0%E5%A2%9E%E4%BC%AA%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">27. CSS3 新增伪类有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28-CSS-%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">28. CSS 优先级算法如何计算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#29-CSS-%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B1%9E%E6%80%A7%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">29. CSS 中的那些属性是可以继承的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#inhert\"><span class=\"toc-text\">inhert</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">28. 伪类和伪元素的区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%86\"><span class=\"toc-text\">区分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E4%BC%AA%E7%B1%BB\"><span class=\"toc-text\">常见伪类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E4%BC%AA%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">常见伪元素</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#30-css-%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">30. css 选择器有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#31-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%A0%87%E5%87%86%E7%9A%84-CSS-%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%BD%8E%E7%89%88%E6%9C%AC-IE-%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">31. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32-%E6%9C%AA%E7%9F%A5%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%88%B6%E5%85%83%E7%B4%A0%EF%BC%8C%E5%AD%90%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F\"><span class=\"toc-text\">32. 未知大小的父元素，子元素水平垂直居中？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32-BFC\"><span class=\"toc-text\">32. BFC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-BFC\"><span class=\"toc-text\">什么是 BFC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-BFC\"><span class=\"toc-text\">如何创建 BFC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BFC-%E7%89%B9%E7%82%B9%EF%BC%8C%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">BFC 特点，能解决什么问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"可视化埋点","uid":"0ad1ddce4e48037c2d0625fb3e573482","slug":"2022-10-24可视化埋点","date":"2022-10-24T13:00:52.000Z","updated":"2022-10-24T13:01:36.555Z","comments":true,"path":"api/articles/2022-10-24可视化埋点.json","keywords":null,"cover":null,"text":"参考链接从 0 到 1 搭建可视化埋点平台 ","link":"","photos":[],"count_time":{"symbolsCount":22,"symbolsTime":"1 mins."},"categories":[{"name":"前端基建","slug":"前端基建","count":1,"path":"api/categories/前端基建.json"}],"tags":[{"name":"前端基建","slug":"前端基建","count":1,"path":"api/tags/前端基建.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}},"next_post":{"title":"前端基础-js class","uid":"96631ce884e53e339dba9cb51900376e","slug":"2022-10-21js-class","date":"2022-10-21T05:40:31.000Z","updated":"2023-05-15T13:17:32.964Z","comments":true,"path":"api/articles/2022-10-21js-class.json","keywords":null,"cover":null,"text":"类什么是类， 有什么作用类是: 用于创建对象的模板。用代码封装数据以处理该数据。 JS 中的类建立在原型上，但与 ES5 类的语法和语义不同 类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。 与函数区别class 关键字声明一...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"前端基础","slug":"前端基础","count":53,"path":"api/categories/前端基础.json"}],"tags":[{"name":"前端基础","slug":"前端基础","count":55,"path":"api/tags/前端基础.json"}],"author":{"name":"举手摘月亮","slug":"blog-author","avatar":"http://t-blog-images.aijs.top/img/202303171118970.webp","link":"/","description":"<div><p>眼中有光，心中有梦，脚下有路</p><div>","socials":{"github":"https://github.com/841660202","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/web_longboss","juejin":"","customs":{}}}}}