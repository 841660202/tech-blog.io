[{"id":"c370dd6ecfc84fe9fdfa77b1a6f29341","title":"待办事项","content":"&#x2F;&#x2F; 1. headless-recorder\n&#x2F;&#x2F; 2. lightHouse https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangdou369098655&#x2F;article&#x2F;details&#x2F;122531766\n&#x2F;&#x2F; 3. 博客封面生成\n&#x2F;&#x2F; 4. 装饰器模式 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;decorator\n&#x2F;&#x2F; 5. iconfont自定义图标 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;decorator\n&#x2F;&#x2F; 6. 函数式编程 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;function-production\n&#x2F;&#x2F; 7. 换肤 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;theme-scss\n&#x2F;&#x2F; 8.[x] vscode setting sync 另一台电脑配置无法同步到本电脑\n&#x2F;&#x2F; 9.[x]item2本机重新配置\n&#x2F;&#x2F; 10.[x]莫名其妙的，代码片段在md上失效了\n&#x2F;&#x2F; 11. typescript 工具类型源码\n&#x2F;&#x2F; 12. react源码\n\n好的博客&#x2F;&#x2F; 1.JerryWang_汪子熙  https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;99b8712e8850\n","slug":"todo","date":"2022-12-14T03:59:59.000Z","categories_index":"Todo","tags_index":"Todo","author_index":"陈海龙"},{"id":"4d5c25949e3f0ed660e75d309fcab509","title":"typescript 工具类型源码","content":"ts 类型如何调试\n不是代码逻辑如何调试，没想到\n\nts 自定义类型如何打印\n不是 js 的结果如何打印，没想到\n\nCreating Types from Types从已有类型中创建类型\nTypeScript 的类型系统非常强大，因为它允许表达类型的另一种表达方式。最简单的方式是泛型，我们实际上有一大堆的类型操作符可用。还可以表达类型的另一种表达方式，就是把已有的值作为类型。通过合并多种类型操作符，我们可以表达复杂的操作和值，这里我们将介绍以另一个类型或值为基础如何表达一个新类型。\n简单来说：使用 范型 或 6种表达式 来创建新类型\n\n范型 - 类型需要参数\n\nKeyof Type Operator - 用 keyof 操作去创建新类型\n\nTypeof Type Operator - 用 typeof 操作去创建新类型\n\nIndexed Access Types - 使用 Type[‘a’]语法去访问一个类型的一部分\n\nConditional Types - 类型行为像 if 语句一样\n\nMapped Types - 通过映射已有类型的每个属性来创建新类型\n\nTemplate Literal Types - 通过模板字符串来改变属性的映射类型\n\n\nKeyof Type Operator\n这个操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：\n\ntype P1 &#x3D; keyof any; &#x2F;&#x2F; 提示：type P1 &#x3D; string | number | symbol\n\ntype Point &#x3D; &#123; x: number; y: number &#125;;\ntype P &#x3D; keyof Point; &#x2F;&#x2F; 提示：type P &#x3D; keyof Point，这个提示等于没提示\n\n\n如果这个类型有字符串或者数字索引，keyof 就会返回这个类型：\n\ntype Arrayish &#x3D; &#123; [n: number]: unknown &#125;;\ntype A &#x3D; keyof Arrayish; &#x2F;&#x2F;提示：type A &#x3D; number\n\ntype Mapish &#x3D; &#123; [k: string]: boolean &#125;;\ntype M &#x3D; keyof Mapish; &#x2F;&#x2F; 提示：type M &#x3D; string | number\n\n&#x2F;&#x2F; --------------------------------------------------------------\n&#x2F;&#x2F; 对于Arrayish\n\n&#x2F;&#x2F; 实例1:ok\nvar a: Arrayish &#x3D; &#123;\n  1: &quot;string&quot;,\n  2: false,\n&#125;;\n&#x2F;&#x2F; 实例2: ok\nvar a1: Arrayish &#x3D; [1, 2, 3, 4];\n\n&#x2F;&#x2F; 对于 Mapish\nvar b: Mapish &#x3D; &#123;\n  name: true,\n  age: false,\n&#125;;\n\n注意，这个例子中，M 是 string | number — 这是因为 JavaScript 对象键是总是被强制为字符串，所以 obj[0] 总是和 obj[“0”] 相同。\nkeyof 类型操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：\nTypeof type operatorJavaScript 也有一个 typeof 操作符，可以用在表达式中：\n&#x2F;&#x2F; Prints &quot;string&quot;\nconsole.log(typeof &quot;Hello world&quot;);\n\nTypeScript 增加了一个 typeof 操作符，可以用在类型上：\nlet s &#x3D; &quot;hello&quot;;\nlet n: typeof s; &#x2F;&#x2F; 提示：let n: string\n\nReturnType对于基本类型，typeof 操作符没有意义，但是与其他类型操作符结合使用，可以用 typeof 操作符来实现一些模式。例如，我们开始用 ReturnType 来表示函数的返回类型：\ntype Predicate &#x3D; (x: unknown) &#x3D;&gt; boolean;\ntype K &#x3D; ReturnType&lt;Predicate&gt;; &#x2F;&#x2F; 提示 type K &#x3D; boolean\n\n如果我们尝试使用 ReturnType 在函数名上，我们会看到一个指示性的错误：\nfunction f() &#123;\n  return &#123; x: 10, y: 3 &#125;;\n&#125;\ntype P &#x3D; ReturnType&lt;f&gt;;\n&#x2F;&#x2F; 提示：&#39;f&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof f&#39;?\n&#x2F;&#x2F; 提示：&#39;f&#39; 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof f&#39; 来代替 &#39;f&#39;？\n\n记住，值和类型不是一回事。要引用值 f 所拥有的类型，我们使用 typeof：\nfunction f() &#123;\n  return &#123; x: 10, y: 3 &#125;;\n&#125;\ntype P &#x3D; ReturnType&lt;typeof f&gt;;\n\n&#x2F;**\n * 提示\n * type P &#x3D; &#123;\n    x: number;\n    y: number;\n&#125;\n**&#x2F;\n\n限制\ntypescript 通常限制了 typeof 的表达式的类型。特殊的，typeof 的表达式只能用于标识符（即变量名）其属性。这个限制是为了避免写一些你认为是执行的代码，但实际上并不是的：\n&#x2F;&#x2F; Meant to use &#x3D; ReturnType&lt;typeof msgbox&gt;\nlet shouldContinue: typeof msgbox(&quot;Are you sure you want to continue?&quot;);\n&#x2F;&#x2F; &#39;,&#39; expected.\n\nIndexed Access Types我们可以使用索引访问类型来查找一个类型的特定属性：\ntype Person &#x3D; &#123; age: number; name: string; alive: boolean &#125;;\ntype Age &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示：type Age &#x3D; number\n\n这个索引类型本身是一个类型，所以我们可以使用联合，keyof 或者其他类型：\ntype I1 &#x3D; Person[&quot;age&quot; | &quot;name&quot;]; &#x2F;&#x2F; 提示：type I1 &#x3D; string | number\n\ntype I2 &#x3D; Person[keyof Person]; &#x2F;&#x2F; 提示：type I2 &#x3D; string | number | boolean\n\ntype AliveOrName &#x3D; &quot;alive&quot; | &quot;name&quot;;\ntype I3 &#x3D; Person[AliveOrName]; &#x2F;&#x2F; 提示：type I3 &#x3D; string | boolean\n\n你会看到一个错误，如果你尝试索引一个不存在的属性：\ntype I1 &#x3D; Person[&quot;alve&quot;];\nProperty &#39;alve&#39; does not exist on type &#39;Person&#39;.\n\n另一个例子是使用 number 来获取数组的元素类型。我们可以使用 typeof 来方便地捕获数组字面量的元素类型。\nconst MyArray &#x3D; [\n  &#123; name: &quot;Alice&quot;, age: 15 &#125;,\n  &#123; name: &quot;Bob&quot;, age: 23 &#125;,\n  &#123; name: &quot;Eve&quot;, age: 38 &#125;,\n];\n\ntype Person &#x3D; typeof MyArray[number];\n\n&#x2F;&#x2F; 提示：type Person &#x3D; &#123; name: string; age: number; &#125;\n\ntype Age &#x3D; typeof MyArray[number][&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age &#x3D; number;\n&#x2F;&#x2F; Or\ntype Age2 &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age2 &#x3D; number;\n\n你只能使用类型来索引，意味着你不能使用 const 来创建一个变量引用：\nconst key &#x3D; &quot;age&quot;;\ntype Age &#x3D; Person[key];\n&#x2F;&#x2F; Type &#39;key&#39; cannot be used as an index type.\n&#x2F;&#x2F; 这个错误是因为 key 是一个字面量，而不是一个变量。\n&#x2F;&#x2F; &#39;key&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof key&#39;?\n&#x2F;&#x2F; 这个错误是因为 key 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof key&#39; 来代替 &#39;key&#39;？\n\n然而，你可以使用一个类型别名来替换相同的风格的重构：\ntype key &#x3D; &quot;age&quot;;\ntype Age &#x3D; Person[key];\n\nConditional TypesAt the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. Conditional types help describe the relation between the types of inputs and outputs.在最常见的程序中，我们需要根据输入来做决策。 JavaScript 程序是不同的，但是给定了这个事实，那些决策是根据输入的类型来做的。条件类型帮助描述输入和输出类型之间的关系。\ninterface Animal &#123;\n  live(): void;\n&#125;\ninterface Dog extends Animal &#123;\n  woof(): void;\n&#125;\n\ntype Example1 &#x3D; Dog extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example1 &#x3D; number\n\ntype Example2 &#x3D; RegExp extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example2 &#x3D; string\n\n条件类型的表达式像 JavaScript 中的条件表达式一样：\nSomeType extends OtherType ? TrueType : FalseType;\n\n此段内容，原文保留When the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).\n当 extends 左边的类型可以赋值给右边的类型时，你会得到第一个分支的类型（“true”分支）；否则你会得到第二个分支的类型（“false”分支）。\nFrom the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not Dog extends Animal and pick number or string! But the power of conditional types comes from using them with generics.从上面的例子中可以看到条件类型可能不会立即看起来很有用，我们可以告诉自己 Dog 是否继承了 Animal，然后选择 number 或 string！但是条件类型的力量来自于使用它们与泛型。\nFor example, let’s take the following createLabel function:例如，我们可以把下面的 createLabel 函数拿来说说：\ninterface IdLabel &#123;\n  id: number &#x2F;* some fields *&#x2F;;\n&#125;\ninterface NameLabel &#123;\n  name: string &#x2F;* other fields *&#x2F;;\n&#125;\n\nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel &#123;\n  throw &quot;unimplemented&quot;;\n&#125;\n\nThese overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:这些 createLabel 的重载描述了一个单一的 JavaScript 函数，它根据输入的类型来做决策。请注意一些事情：\nIf a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.We have to create three overloads: one for each case when we’re sure of the type (one for string and one for number), and one for the most general case (taking a string | number). For every new type createLabel can handle, the number of overloads grows exponentially.如果一个库需要在其 API 中重复使用相同的选择，这就变得非常麻烦。我们需要创建三个重载：一个当我们知道类型时，一个当我们知道类型时，一个当我们不知道类型时。对于每个新的类型 createLabel 可以处理，重载的数量就会指数增长。Instead, we can encode that logic in a conditional type:反之，我们可以使用条件类型来表示逻辑：\ntype NameOrId&lt;T extends number | string&gt; &#x3D; T extends number\n  ? IdLabel\n  : NameLabel;\n\nWe can then use that conditional type to simplify our overloads down to a single function with no overloads.我们可以使用这个条件类型来简化我们的重载，只有一个函数。\nfunction createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; &#123;\n  throw &quot;unimplemented&quot;;\n&#125;\n\nlet a &#x3D; createLabel(&quot;typescript&quot;);\n\n&#x2F;&#x2F; 提示：let a: NameLabel;\n\nlet b &#x3D; createLabel(2.8);\n\n&#x2F;&#x2F; 提示：let b: IdLabel;\n\nlet c &#x3D; createLabel(Math.random() ? &quot;hello&quot; : 42);\n&#x2F;&#x2F; 提示：let c: NameLabel | IdLabel;\n\n\nConditional Type Constraints\n\n条件类型约束\nOften, the checks in a conditional type will provide us with some new information. Just like with narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.通常，在条件类型中的检查会提供我们一些新的信息。像类型检查一样，通过类型约束可以给我们更具体的类型，条件类型的 true 分支将通过我们检查的类型来约束泛型。For example, let’s take the following:例如，我们可以把下面的函数拿来说说：\ntype MessageOf&lt;T&gt; &#x3D; T[&quot;message&quot;];\n&#x2F;&#x2F; Type &#39;&quot;message&quot;&#39; cannot be used to index type &#39;T&#39;.\n\nIn this example, TypeScript errors because T isn’t known to have a property called message. We could constrain T, and TypeScript would no longer complain:\n在这个例子中，TypeScript 错误，因为 T 没有一个属性叫 message。我们可以约束 T，TypeScript 不会再报错了：\ntype MessageOf&lt;T extends &#123; message: unknown &#125;&gt; &#x3D; T[&quot;message&quot;];\n\ninterface Email &#123;\n  message: string;\n&#125;\n\ntype EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;\n\n&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string\n\nHowever, what if we wanted MessageOf to take any type, and default to something like never if a message property isn’t available? We can do this by moving the constraint out and introducing a conditional type:然而，如果我们想要 MessageOf 取任意类型，并且默认为没有 message 属性的情况，我们可以这样做：\ntype MessageOf&lt;T&gt; &#x3D; T extends &#123; message: unknown &#125; ? T[&quot;message&quot;] : never;\n\ninterface Email &#123;\n  message: string;\n&#125;\n\ninterface Dog &#123;\n  bark(): void;\n&#125;\n\ntype EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;\n\n&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string;\n\ntype DogMessageContents &#x3D; MessageOf&lt;Dog&gt;;\n\n&#x2F;&#x2F; 提示：type DogMessageContents &#x3D; never;\n\nWithin the true branch, TypeScript knows that T will have a message property.在 true 分支中，TypeScript 知道 T 有一个 message 属性。\nAs another example, we could also write a type called Flatten that flattens array types to their element types, but leaves them alone otherwise:作为另一个示例，我们还可以编写一个名为 Flatten 的类型，该类型将数组类型展平为其元素类型，但在其他情况下不使用它们：\ntype Flatten&lt;T&gt; &#x3D; T extends any[] ? T[number] : T;\n\n&#x2F;&#x2F; Extracts out the element type. 提取元素类型。\ntype Str &#x3D; Flatten&lt;string[]&gt;;\n\ntype Str &#x3D; string;\n\n&#x2F;&#x2F; Leaves the type alone. 保留该类型。\ntype Num &#x3D; Flatten&lt;number&gt;;\n\ntype Num &#x3D; number;\n\nWhen Flatten is given an array type, it uses an indexed access with number to fetch out string[]’s element type. Otherwise, it just returns the type it was given.当 Flatten 给定一个数组类型，它使用 number 下标得到 string[]元素类型，否则，仅返回所给类型\nInferring Within Conditional Types在条件类型内推断\nWe just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.\n我们只是发现自己使用条件类型来应用约束，然后提取出类型。这最终是一种常见的操作，条件类型使其更容易实现。\nConditional types provide us with a way to infer from types we compare against in the true branch using the infer keyword. For example, we could have inferred the element type in Flatten instead of fetching it out “manually” with an indexed access type:\n条件类型为我们提供了一种使用 infer 关键字从 true 分支中比较的类型推断的方法。例如，我们可以在 Flatten 中推断元素类型，而不是使用索引访问类型“手动”提取它：\ntype Flatten&lt;Type&gt; &#x3D; Type extends Array&lt;infer Item&gt; ? Item : Type;\n\nHere, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of T within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.\n在这里，我们使用 infer 关键字声明性地引入一个名为 Item 的新泛型类型变量，而不是指定如何在 true 分支中检索 T 的元素类型。这使我们不必思考如何挖掘和探索我们感兴趣的类型的结构。\nWe can write some useful helper type aliases using the infer keyword. For example, for simple cases, we can extract the return type out from function types:\n我们可以使用 infer 关键字编写一些有用的助手类型别名。例如，对于简单的情况，我们可以从函数类型中提取返回类型：\ntype GetReturnType&lt;Type&gt; &#x3D; Type extends (...args: never[]) &#x3D;&gt; infer Return\n  ? Return\n  : never;\n\ntype Num &#x3D; GetReturnType&lt;() &#x3D;&gt; number&gt;;\n\n&#x2F;&#x2F; 提示： type Num &#x3D; number\n\ntype Str &#x3D; GetReturnType&lt;(x: string) &#x3D;&gt; string&gt;;\n\n&#x2F;&#x2F; 提示：type Str &#x3D; string\n\ntype Bools &#x3D; GetReturnType&lt;(a: boolean, b: boolean) &#x3D;&gt; boolean[]&gt;;\n\n&#x2F;&#x2F; 提示： type Bools &#x3D; boolean[]\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，将从最后一个签名进行推断（这可能是最允许的一网打尽的情况）。无法基于参数类型列表执行重载解析。\ndeclare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n\ntype T1 &#x3D; ReturnType&lt;typeof stringOrNum&gt;;\n\n&#x2F;&#x2F; 提示：type T1 &#x3D; string | number;\n\nDistributive Conditional Types分布条件类型\nWhen conditional types act on a generic type, they become distributive when given a union type. For example, take the following:当条件类型作用于泛型类型时，当给定一个联合类型时，它们将成为分布式的。例如，以以下内容为例：\ntype ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;\n\nIf we plug a union type into ToArray, then the conditional type will be applied to each member of that union.如果我们将一个联合类型插入 ToArray，那么条件类型将应用于该联合的每个成员。\ntype ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;\n\ntype StrArrOrNumArr &#x3D; ToArray&lt;string | number&gt;;\n\n&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; string[] | number[];\n\nWhat happens here is that StrArrOrNumArr distributes on:这里发生了什么？\nstring | number;\n\nand maps over each member type of the union, to what is effectively:并映射到联合类型每个成员类型\nToArray&lt;string&gt; | ToArray&lt;number&gt;;\n\nwhich leaves us with:这给我们留下了：\nstring[] | number[];\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets.通常情况下，分布式是所需的行为。要避免这种行为，你可以在每边 extends 关键字之前使用方括号。\ntype ToArrayNonDist&lt;Type&gt; &#x3D; [Type] extends [any] ? Type[] : never;\n\n&#x2F;&#x2F; &#39;StrArrOrNumArr&#39; is no longer a union.\ntype StrArrOrNumArr &#x3D; ToArrayNonDist&lt;string | number&gt;;\n&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; (string | number)[];\n\nReturn模板字面量类型（Template Literal Types）模板字面量类型以字符串字面量类型为基础，可以通过联合类型扩展成多个字符串。\n它们跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。当使用模板字面量类型时，它会替换模板中的变量，返回一个新的字符串字面量：\ntype World &#x3D; &quot;world&quot;;\n\ntype Greeting &#x3D; &#96;hello $&#123;World&#125;&#96;;\n&#x2F;&#x2F; type Greeting &#x3D; &quot;hello world&quot;\n\n\n当模板中的变量是一个联合类型时，每一个可能的字符串字面量都会被表示：\n\ntype EmailLocaleIDs &#x3D; &quot;welcome_email&quot; | &quot;email_heading&quot;;\ntype FooterLocaleIDs &#x3D; &quot;footer_title&quot; | &quot;footer_sendoff&quot;;\n\ntype AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;\n&#x2F;&#x2F; type AllLocaleIDs &#x3D; &quot;welcome*email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;\n\n\n如果模板字面量里的多个变量都是联合类型，结果会交叉相乘，比如下面的例子就有 2 * 2 _ 3 一共 12 种结果：\n\ntype AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;\ntype Lang &#x3D; &quot;en&quot; | &quot;ja&quot; | &quot;pt&quot;;\n\ntype LocaleMessageIDs &#x3D; &#96;$&#123;Lang&#125;_$&#123;AllLocaleIDs&#125;&#96;;\n&#x2F;&#x2F; type LocaleMessageIDs &#x3D; &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot;\n\n\n如果真的是非常长的字符串联合类型，推荐提前生成，这种还是适用于短一些的情况。\n\n类型中的字符串联合类型（String Unions in Types）模板字面量最有用的地方在于你可以基于一个类型内部的信息，定义一个新的字符串，让我们举个例子：\n有这样一个函数 makeWatchedObject， 它会给传入的对象添加了一个 on 方法。在 JavaScript 中，它的调用看起来是这样：makeWatchedObject(baseObject)，我们假设这个传入对象为：\nconst passedObject &#x3D; &#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;;\n\n这个 on 方法会被添加到这个传入对象上，该方法接受两个参数，eventName （ string 类型） 和 callBack （function 类型）：\n&#x2F;&#x2F; 伪代码\nconst result &#x3D; makeWatchedObject(baseObject);\nresult.on(eventName, callBack);\n\n我们希望 eventName 是这种形式：attributeInThePassedObject + “Changed” ，举个例子，\n\npassedObject 有一个属性 firstName，对应产生的 eventName 为 firstNameChanged，\n同理，lastName 对应的是 lastNameChanged，\nage 对应的是 ageChanged。\n\n当这个 callBack 函数被调用的时候：\n\n应该被传入与 attributeInThePassedObject 相同类型的值。比如 passedObject 中，\nfirstName 的值的类型为 string , 对应 firstNameChanged 事件的回调函数，则接受传入一个 string 类型的值。\nage 的值的类型为 number，对应 ageChanged 事件的回调函数，则接受传入一个 number 类型的值。\n\n\n返回值类型为 void 类型。on() 方法的签名最一开始是这样的：on(eventName: string, callBack: (newValue: any) &#x3D;&gt; void)。 使用这样的签名，我们是不能实现上面所说的这些约束的，这个时候就可以使用模板字面量：\n\nconst person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\n&#x2F;&#x2F; makeWatchedObject has added &#96;on&#96; to the anonymous Object\nperson.on(&quot;firstNameChanged&quot;, (newValue) &#x3D;&gt; &#123;\n  console.log(&#96;firstName was changed to $&#123;newValue&#125;!&#96;);\n&#125;);\n\n注意这个例子里，on 方法添加的事件名为 “firstNameChanged”， 而不仅仅是 “firstName”，而回调函数传入的值 newValue ，我们希望约束为 string 类型。我们先实现第一点。\n在这个例子里，我们希望传入的事件名的类型，是对象属性名的联合，只是每个联合成员都还在最后拼接一个 Changed 字符，在 JavaScript 中，我们可以做这样一个计算：\nObject.keys(passedObject).map(x &#x3D;&gt; $&#123;x&#125;Changed)\n\n模板字面量提供了一个相似的字符串操作：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;string &amp; keyof Type&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n&#x2F;&#x2F;&#x2F; Create a &quot;watched object&quot; with an &#39;on&#39; method\n&#x2F;&#x2F;&#x2F; so that you can watch for changes to properties.\n\ndeclare function makeWatchedObject&lt;Type&gt;(\n  obj: Type\n): Type &amp; PropEventSource&lt;Type&gt;;\n\n注意，我们在这里例子中，模板字面量里我们写的是 string &amp; keyof Type，我们可不可以只写成 keyof Type 呢？如果我们这样写，会报错：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;keyof Type&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n&#x2F;&#x2F; Type &#39;keyof Type&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.\n&#x2F;&#x2F; Type &#39;string | number | symbol&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.\n&#x2F;&#x2F; ...\n\n从报错信息中，我们也可以看出报错原因，在 《TypeScript 系列之 Keyof 操作符》里，我们知道\n\nkeyof 操作符会返回 string | number | symbol 类型，\n但是模板字面量的变量要求的类型却是 string | number | bigint | boolean | null | undefined，\n\n比较一下，多了一个 symbol 类型，所以其实我们也可以这样写：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;Exclude&lt;keyof Type, symbol&gt;&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n再或者这样写：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;Extract&lt;keyof Type, string&gt;&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n使用这种方式，在我们使用错误的事件名时，TypeScript 会给出报错：\nconst person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\nperson.on(&quot;firstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);\n\n&#x2F;&#x2F; Prevent easy human error (using the key instead of the event name)\nperson.on(&quot;firstName&quot;, () &#x3D;&gt; &#123;&#125;);\n&#x2F;&#x2F; Argument of type &#39;&quot;firstName&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.\n\n&#x2F;&#x2F; It&#39;s typo-resistant\nperson.on(&quot;frstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);\n&#x2F;&#x2F; Argument of type &#39;&quot;frstNameChanged&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.\n\n模板字面量的推断（Inference with Template Literals）现在我们来实现第二点，回调函数传入的值的类型与对应的属性值的类型相同。我们现在只是简单的对 callBack 的参数使用 any 类型。实现这个约束的关键在于借助泛型函数：\n捕获泛型函数第一个参数的字面量，生成一个字面量类型\n\n该字面量类型可以被对象属性构成的联合约束\n对象属性的类型可以通过索引访问获取\n应用此类型，确保回调函数的参数类型与对象属性的类型是同一个类型\n\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on&lt;Key extends string &amp; keyof Type&gt;(\n    eventName: &#96;$&#123;Key&#125;Changed&#96;,\n    callback: (newValue: Type[Key]) &#x3D;&gt; void\n  ): void;\n&#125;;\n\ndeclare function makeWatchedObject&lt;Type&gt;(\n  obj: Type\n): Type &amp; PropEventSource&lt;Type&gt;;\n\nconst person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\nperson.on(&quot;firstNameChanged&quot;, (newName) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; (parameter) newName: string\n  console.log(&#96;new name is $&#123;newName.toUpperCase()&#125;&#96;);\n&#125;);\n\nperson.on(&quot;ageChanged&quot;, (newAge) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; (parameter) newAge: number\n  if (newAge &lt; 0) &#123;\n    console.warn(&quot;warning! negative age&quot;);\n  &#125;\n&#125;);\n\n这里我们把 on 改成了一个泛型函数。\n当一个用户调用的时候传入 “firstNameChanged”，TypeScript 会尝试着推断 Key 正确的类型。它会匹配 key 和 “Changed” 前的字符串 ，然后推断出字符串 “firstName” ，然后再获取原始对象的 firstName 属性的类型，在这个例子中，就是 string 类型。\n内置字符操作类型（Intrinsic String Manipulation Types）TypeScript 的一些类型可以用于字符操作，这些类型处于性能的考虑被内置在编译器中，你不能在 .d.ts 文件里找到它们。\nUppercase把每个字符转为大写形式：\ntype Greeting &#x3D; &quot;Hello, world&quot;;\ntype ShoutyGreeting &#x3D; Uppercase&lt;Greeting&gt;;\n&#x2F;&#x2F; type ShoutyGreeting &#x3D; &quot;HELLO, WORLD&quot;\n\ntype ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;ID-$&#123;Uppercase&lt;Str&gt;&#125;&#96;;\ntype MainID &#x3D; ASCIICacheKey&lt;&quot;my_app&quot;&gt;;\n&#x2F;&#x2F; type MainID &#x3D; &quot;ID-MY_APP&quot;\n\nLowercase把每个字符转为小写形式：\ntype Greeting &#x3D; &quot;Hello, world&quot;;\ntype QuietGreeting &#x3D; Lowercase&lt;Greeting&gt;;\n&#x2F;&#x2F; type QuietGreeting &#x3D; &quot;hello, world&quot;\n\ntype ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;id-$&#123;Lowercase&lt;Str&gt;&#125;&#96;;\ntype MainID &#x3D; ASCIICacheKey&lt;&quot;MY_APP&quot;&gt;;\n&#x2F;&#x2F; type MainID &#x3D; &quot;id-my_app&quot;\n\nCapitalize\n把字符串的第一个字符转为大写形式：\n\ntype LowercaseGreeting &#x3D; &quot;hello, world&quot;;\ntype Greeting &#x3D; Capitalize&lt;LowercaseGreeting&gt;;\n&#x2F;&#x2F; type Greeting &#x3D; &quot;Hello, world&quot;\n\nUncapitalize\n把字符串的第一个字符转换为小写形式：\n\ntype UppercaseGreeting &#x3D; &quot;HELLO WORLD&quot;;\ntype UncomfortableGreeting &#x3D; Uncapitalize&lt;UppercaseGreeting&gt;;\n&#x2F;&#x2F; type UncomfortableGreeting &#x3D; &quot;hELLO WORLD&quot;\n\n\n字符操作类型的技术细节从 TypeScript 4.1 起，这些内置函数会直接使用 JavaScript 字符串运行时函数，而不是本地化识别 (locale aware)。\n\nfunction applyStringMapping(symbol: Symbol, str: string) &#123;\n  switch (intrinsicTypeKinds.get(symbol.escapedName as string)) &#123;\n    case IntrinsicTypeKind.Uppercase:\n      return str.toUpperCase();\n    case IntrinsicTypeKind.Lowercase:\n      return str.toLowerCase();\n    case IntrinsicTypeKind.Capitalize:\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    case IntrinsicTypeKind.Uncapitalize:\n      return str.charAt(0).toLowerCase() + str.slice(1);\n  &#125;\n  return str;\n&#125;\n\n作者：冴羽链接：https://www.imooc.com/article/322215来源：慕课网本文原创发布于慕课网 ，转载请注明出处，谢谢合作\n在想一个问题为什么别人可以把文档翻译的那么准确，让读者一看就明白\n","slug":"2022-06-07typescript","date":"2022-06-07T01:20:35.000Z","categories_index":"typescript","tags_index":"typescript","author_index":"陈海龙"},{"id":"41038c8a05f130e72afb64f08ff12861","title":"https","content":"吐槽掘金\n后台有定时器在运行，一直发送请求，打开多个 web 标签页面，cpu 直接飙升到 100% +，鉴于掘金太卡，所以转载\n\n为什么要有 HTTPS在 HTTPS 出现之前，所有请求都是以明文方式送出的，那么如果有人在传输途中偷听或者抓包的话，你的所有通信内容都会泄漏。比较安全的方法是将通信内容加密在发送给对方。加密方法有两种，对称加密和非对称加密。\n对称加密\n对称加密指的是加密和解密用同一个密钥。\n但是在通信之前，客户端和服务端是不会有这样同一把密钥的。需要其中一方将密钥发送给对方。\n在整个传输过程没有任何验证操作，所以黑客也可以截取到这把密钥从而破译出加密的内容。所以纯对称加密是不安全的。\n\n非对称加密非对称加密指的是加密和解密用不同的密钥。可以是用私钥加密，公钥解密，也可以是用公钥加密，私钥解密。但是会有这种情况。\n\n服务端拥有私钥和公钥，将公钥发给客户端。既然客户端可以获得公钥，黑客也可以获得公钥。那么服务端发送给客户端的所有内容黑客也是可以解读的。\n客户端用公钥加密发送给服务端不受影响，因为黑客手上没有服务器的私钥。所以纯非对称加密也是不安全的。\n\n传输密钥的过程\n图解传输密钥的过程HTTPS 采用对称加密来加密通信内容，所用的密钥称为 A。用非对称加密来加密密钥 A 再发送给对方（有点绕）。只要密钥 A 不落入他人手中，那传输的数据就不会被别人破译。\n那么问题来了，要如何安全的将这把密钥送到对方手上呢？\n我们来看密钥的传输过程\n为什么 HTTPS 是可靠的？HTTPS 是可靠的，因为它解决了三个问题。\n\n加密通信，即使别人获取到了信息也没法复原成原来的信息。\n防止中间人攻击。黑客没法冒充服务端。因为在第 2 步，服务端给了客户端一个 CA 证书。\n\n\n如果客户端验证了这个证书，说明这个证书和公钥是由服务端发来的且真实可靠。\n如果客户端验证不了这个证书，就说明这个证书不可靠，有可能是假的。\n\n\nCA 证书的公信力CA 证书需要由公司或者个人发出申请，再通过邮箱验证等方法验证域名存在。避免了黑客冒充网站获取证书的可能。在技术层面上，CA 机构的公钥是写在操作系统或者浏览器里的。只有用 CA 机构的私钥加密的内容才能完成解密。确保了证书的确是 CA 机构发行的。\n\n密钥的作用最后让我们再来回顾一下每一把密钥的作用\nHTTPS一定安全吗非全站HTTPS并不安全\n登录页面支持HTTPS不就行了，首页又没有涉及账户信息其实这是非常不安全的行为，黑客会利用这一点进行攻击，一般是以下流程：\n1.用户在首页点击「登录」，页面跳转到有htps的网银页面，但此时由于首页是htp请求，所以是明文的，这就会被黑客劫持2.黑客劫持用户的跳转请求，将https网银页面地址转换为http的地址再发送给银行\n用户&lt;&#x3D;&#x3D;HTTP&#x3D;&#x3D;&gt;黑客&lt;&#x3D;&#x3D;HTTPS&#x3D;&#x3D;&gt;银行\n1.此时如果用户输入账户信息，那么会被中间的黑客获取，此时的账号密码就被泄露了\n好在是银行的网银页面,只支持htps,因此上述攻击暂时是无效的\n参考资料【web 安全 3】【硬核】HTTPS 原理全解析\n作者：站在书脊之上链接：https://juejin.cn/post/6844904160089882631来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","slug":"2022-06-05https","date":"2022-06-05T03:55:17.000Z","categories_index":"http","tags_index":"http","author_index":"陈海龙"},{"id":"e33992d78838483e28879a1cdf87c45e","title":"再学Vue3-7 最佳实践","content":"概览\n\n\n性能\n安全\n","slug":"2022-06-02vue-7","date":"2022-06-02T12:05:05.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"9392b2f9395b41b1da45c31165be4e75","title":"再学Vue3-8 typescript","content":"概览\n\n\n组合式\n选项式\n","slug":"2022-06-02vue-8","date":"2022-06-02T12:05:05.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"f63d02067666595ede9bc0ebd108b1ee","title":"再学Vue3-6 升级规模","content":"概览\n\n\n状态管理\n","slug":"2022-06-02vue-6","date":"2022-06-02T11:53:33.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"24ee6bb08e318ca140f4cc0224000a69","title":"再学Vue3-5 内置组件","content":"概览\n\n\nKeepAlive\nteleport·传送门\nSuspense\n过渡 \n","slug":"2022-06-02vue-5","date":"2022-06-02T11:45:19.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"2dcf5d3fa228390b9a53cb50e779c427","title":"再学Vue3-4 可重用性","content":"概览\n\n\n可重用性\n组合函数\n自定义指令\n插件","slug":"2022-06-02vue-4","date":"2022-06-02T10:49:24.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"64389360ee809707debd2fd41c5138f2","title":"再学Vue3-3 深入组件","content":"概览\n\n\n深入组件\n注册prop\n事件\n透传 Attribute\n插槽\n依赖注入\n异步组件\n可重用性\n组合函数\n自定义指令\n插件","slug":"2022-06-02vue-3","date":"2022-06-02T10:49:23.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"f9fd2a8578c770321fc9e0db644f4563","title":"再学Vue3-2 v3","content":"v3\n\n\n响应式基础\n计算属性\n生命周期\n侦听器\n模版 ref\n组件基础\n","slug":"2022-06-02vue-2","date":"2022-06-02T10:49:22.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"2620e5e38d0a5713fc7f864f91b17d5f","title":"再学Vue3-1 基础","content":"概览\n\nv2\n模版语法\n\n\n数据绑定\n\n\n事件绑定\n表单输入绑定\n插件\n","slug":"2022-06-02vue-1","date":"2022-06-02T10:49:21.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"98cc42407c73e25079ab5c02aa5f251b","title":"再学Vue3-0 概览","content":"vue3\n使用 proxy 重写了 vue2，并增加了组合式 api\n以下思维导图以vue3 文档内容为依据，在学习过程中绘制\n学习过程中对比了 vue3 和 react\n很长一段时间没看vue了，vue3一直没接触，媳妇不学。万一哪天媳妇需要用vue3了，没人带岂不是要失业，赶紧学起来～概览\n\n\n\n\n\n问题\n念叨着 渐进式 依赖收集 去学习vue指南\n\n\n","slug":"2022-06-02vue-0","date":"2022-06-02T10:49:20.000Z","categories_index":"vue","tags_index":"vue","author_index":"陈海龙"},{"id":"e7a12532b015cb78e0adb01f9bc03b9e","title":"react useState 错误使用","content":"Shareconst Share: FC&lt;ShareProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; entityType, entityCode &#125; &#x3D; props\n\n  const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;\n    value: props.value,\n    title: props.title,\n    shareId: props.shareId,\n    mappingPassword: props.mappingPassword,\n    passwordEnable: props.passwordEnable,\n    mappingState: props.mappingState,\n    expireTime: props.expireTime,\n    shortCode: props.shortCode,\n  &#125;)\n\n\n  const &#123; value &#125; &#x3D; state\n\n  ...\n\n  return (\n    &lt;div&gt;\n      &#123;renderBtn&#125;\n      &lt;ShareModal\n        entityType&#x3D;&#123;entityType&#125;\n        entityCode&#x3D;&#123;entityCode&#125;\n        &#123;...modalProps&#125;\n        state&#x3D;&#123;state&#125;\n        setState&#x3D;&#123;setState&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\n\nexport default Share\n\n\nShareModal\ninterface ShareModalProps extends ModalFuncProps &#123;\n  entityType: EntityType\n  entityCode: string\n  className?: string\n  state: StateProps\n  setState: (state: StateProps) &#x3D;&gt; void\n&#125;\n\nconst Copy &#x3D; (&#123; text, children &#125;: &#123; text: string; children: string &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;CopyToClipboard\n      text&#x3D;&#123;text&#125;\n      onCopy&#x3D;&#123;() &#x3D;&gt; &#123;\n        message.success(&#39;链接已复制&#39;)\n      &#125;&#125;\n    &gt;\n      &lt;span&gt;&#123;children&#125;&lt;&#x2F;span&gt;\n    &lt;&#x2F;CopyToClipboard&gt;\n  )\n&#125;\n\nconst ShareModal: FC&lt;ShareModalProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const [form] &#x3D; HookForm.useForm()\n\n  const &#123; state, setState, entityType, entityCode, ...restProps &#125; &#x3D; props\n\n  const &#123; value, title, mappingPassword, shortCode, expireTime &#125; &#x3D; state\n\n  const &#123;\n    onChange: toggle,\n    resetPassword: reset,\n    update,\n  &#125; &#x3D; useShare(&#123;\n    entityCode,\n    entityType,\n    state,\n    setState,\n  &#125;)\n\n\n  ....\n\n  return (\n    &lt;Modal\n      &#123;...restProps&#125;\n      className&#x3D;&#123;styles[&#39;share-modal-wrap&#39;]&#125;\n      title&#x3D;&quot;链接分享&quot;\n      destroyOnClose\n      width&#x3D;&#123;420&#125;\n      footer&#x3D;&#123;null&#125;\n    &gt;\n      &lt;ConditionComponent isShow&#x3D;&#123;value&#125;&gt;\n        ....\n        &lt;HookForm form&#x3D;&#123;form&#125; style&#x3D;&#123;&#123; marginBottom: 10, width: &#39;100%&#39; &#125;&#125; layout&#x3D;&quot;vertical&quot;&gt;\n          &lt;HookForm.Item noStyle shouldUpdate&gt;\n            &#123;() &#x3D;&gt; &#123;\n              const &#123; url, mappingPassword, expireTime &#125; &#x3D; form.getFieldsValue()\n              const text &#x3D; &#96;$&#123;url&#125;（密码：$&#123;mappingPassword&#125;）《$&#123;title&#125;》$&#123;moment(\n                expireTime,\n              ).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)&#125;过期&#96;\n              return (\n                &lt;HookForm.Item name&#x3D;&quot;url&quot; label&#x3D;&quot;&quot;&gt;\n                  &lt;Input\n                    className&#x3D;&#123;styles[&#39;share-copy&#39;]&#125;\n                    addonAfter&#x3D;&#123;&lt;Copy text&#x3D;&#123;text&#125;&gt;复制链接和密码&lt;&#x2F;Copy&gt;&#125;\n                    disabled\n                  &#x2F;&gt;\n                &lt;&#x2F;HookForm.Item&gt;\n              )\n            &#125;&#125;\n          &lt;&#x2F;HookForm.Item&gt;\n        &lt;&#x2F;HookForm&gt;\n      &lt;&#x2F;ConditionComponent&gt;\n    &lt;&#x2F;Modal&gt;\n  )\n&#125;\n\nexport default ShareModal\n\n\n用户反馈为什么分享的链接与要分享的链接对不上？\nuseCallbackuseCallback受依赖项的影响，不更新，之前改过同事的代码，这次扫了一样，没有callback，就这问题修改几个了\nuseState\n找了下数据ShareModal组件,看到两个入参state, setState ，我艹\n继续往上层找&lt;ShareModal\n  entityType&#x3D;&#123;entityType&#125;\n  entityCode&#x3D;&#123;entityCode&#125;\n  &#123;...modalProps&#125;\n  state&#x3D;&#123;state&#125; &#x2F;&#x2F; 😓\n  setState&#x3D;&#123;setState&#125; &#x2F;&#x2F;😓 \n&#x2F;&gt;\n再往上找，useState 内部只执行一次，数据初始化完成不再改变\n\n\nconst [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;\n  value: props.value,\n  title: props.title,\n  shareId: props.shareId,\n  mappingPassword: props.mappingPassword,\n  passwordEnable: props.passwordEnable,\n  mappingState: props.mappingState,\n  expireTime: props.expireTime,\n  shortCode: props.shortCode,\n&#125;)\n\n\nconst &#123; value &#125; &#x3D; state\n\n\n这里代码这么写，其他地方肯定也有这样的写法，😓\n\n改一下const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;&#125;)\n\n\nuseEffect(() &#x3D;&gt; &#123;\n  setState(&#123; ...props &#125;)\n&#125;, [props.shareId])\n","slug":"2022-05-31bug","date":"2022-05-31T02:30:47.000Z","categories_index":"bug","tags_index":"bug,react","author_index":"陈海龙"},{"id":"fa552d7ce8179aea4ff549bb83386b93","title":"编程范式-函数式编程简单了解","content":"背景js 为了实现面向对象的思想，做了很多事情，导致大家在学习 js 的时候，会遇到复杂的原型、原型链、继承，还有对人不友好的 this ；而当我们用这些东西组合起来模拟面向对象的特性的时候，就更加痛苦了。但我们可以使用一种更友好的方式，函数式编程。简单来说就是：面向对象的思想在js中不是很好用\n什么是函数式编程函数式编程（functional programing）是编程范式之一。我们常见的范式还有面向过程、面向行为、面向对象等。\n范式：我们可以认为它是一种思维模式加上它的实现方法，简单说就是编程的方法论。\n\n面向过程编程：简单解释就是按照步骤来实现。\n\n面向行为编程：它是函数式编程的衍生范型，将电脑运算平展为一系列的变化，并且避免使用程序指令以及堆叠的对象。\n\n面向对象编程：它的思维方式是把现实世界中的事物抽象成程序世界中的类和对象，然后通过封装，继承和多态来演示事物之间的联系。\n\n面向函数式编程：它的思维方式是把现实世界中的事物和事物之间的联系，抽象到程序世界中。\n\n\n函数式编程特点：\n程序的本质：就是利用计算机的计算能力将输入转化成对应的输出。\n\n函数式编程中的函数指的不是编程语言里的函数，而是数学意义上的映射关系。比如 y&#x3D;sin(x) 中 x 和 y 值的映射关系。\n\n纯函数：相同的输入获得相同的输出（无副作用）。\n\n函数式编程就是对数据(函数)映射关系的抽象。\n\n\n使用场景\n高阶函数\n闭包\n纯函数\n柯里化\n组合函数\n\n参考\n","slug":"2022-05-28func","date":"2022-05-28T07:25:33.000Z","categories_index":"理论","tags_index":"理论","author_index":"陈海龙"},{"id":"2e69f09f2b5424b80304135ea166c436","title":"wiki Laser Pen","content":"Laser PenLaser Pen 是一套用来在 web canvas 上绘制鼠标轨迹的工具集。\n使用场景wiki全屏演示时候，为了便于听众跟随演讲者进度，给鼠标轨迹加上标记。\n\n注：公司项目由于版权问题，不便演示\n初步上手首先在你的项目中添加对 Laser Pen 的依赖：\nyarn add laser-pen\n或者\nnpm i laser-pen\n\n然后监听鼠标的 move 事件，获取鼠标移动轨迹的坐标，并同时记录 move 事件触发时的时间戳。\n&#x2F;&#x2F; 获取 canvas 元素的坐标\nconst canvasDom &#x3D; document.querySelector(&#39;canvas&#39;)\nconst canvasPos &#x3D; canvasDom.getBoundingClientRect()\nconst ctx &#x3D; canvas.getContext(&#39;2d&#39;)\n&#x2F;&#x2F; 用来存储所有鼠标轨迹数据\nlet mouseTrack &#x3D; []\n&#x2F;&#x2F; 监听鼠标事件\ndocument.addEventListener(&#39;mousemove&#39;, (event) &#x3D;&gt; &#123;\n  mouseTrack.push(&#123;\n    x: event.clientX - canvasPos.x,\n    y: event.clientY - canvasPos.y,\n    time: Date.now(),\n  &#125;)\n&#125;)\n\n最后在调用 drawLaserPen 方法绘制鼠标轨迹\nimport &#123; drainPoints, drawLaserPen &#125; from &#39;laser-pen&#39;\n\nfunction draw() &#123;\n  &#x2F;&#x2F; 过滤掉一些失效的轨迹坐标\n  mouseTrack &#x3D; drainPoints(mouseTrack)\n  if (mouseTrack.length &gt;&#x3D; 3) &#123;\n    &#x2F;&#x2F; 绘制鼠标轨迹\n    drawLaserPen(ctx, mouseTrack)\n  &#125;\n  requestAnimation(draw)\n&#125;\n\n\n到这里，你应该已经可以在 canvas 上实现鼠标轨迹的绘制了。\n参数配置如果默认的轨迹效果不能满足你的要求，Laser Pen 还提供了一些接口让你可以方便的修改鼠标轨迹的样式。\n&#x2F;&#x2F; 设置延迟时间，mousemove 事件产生的坐标点在超过延迟时间后就不会被绘制，会直接影响轨迹的长度\nsetDelay: (millisecond: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最大宽度，轨迹是一条由粗变细的曲线，maxWidth 表示粗的那一头的线宽\nsetMaxWidth: (width: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最小宽度，轨迹是一条由粗变细的曲线，minWidth 表示细的那一头的线宽\nsetMinWidth: (width: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置曲线张力大小，张力越大拐点处越平滑，反之越尖锐\nsetTension: (t: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最小透明度，轨迹是一条由不透明变透明的曲线，opacity 表示轨迹末尾的不透明度\nsetOpacity: (o: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的颜色\nsetColor: (r: number, g: number, b: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹头部是否是圆形\nsetRoundCap: (b: boolean) &#x3D;&gt; void;\n\n在任何时候调用上述接口修改鼠标轨迹的样式，都会在紧接着的下一次绘制中生效。所以如果你想实现一个类似 RGB 跑马灯的鼠标轨迹也是可以的。\n定制化开发如果上面的接口都不能满足你的要求，那么你就需要做一些定制化的开发了。\n绘制鼠标轨迹的过程大概分为 5 个步骤：\n清洗轨迹坐标数据根据轨迹坐标计算每个坐标的控制点通过坐标点和控制点数据生成 Bezier 曲线将上一步生成的曲线分割为更短的 Bezier 曲线，并计算每条曲线的绘制样式依次绘制每条 Bezier 曲线这 5 个步骤对应下面的第 1 到第 5 个接口，最后的 drawLaserPen 接口是对前面 5 个接口的组合。 如果直接调用 drawLaserPen 不能满足你的要求，你可以在前 5 个接口的基础上自行组合，实现你想要的效果。\n&#x2F;&#x2F; 去掉原始鼠标坐标数据中不合理的数据，包括超过延迟时间的坐标，和一些排列不合法的坐标\ndrainPoints: (originalPoints: IOriginalPointData[]) &#x3D;&gt; IOriginalPointData[];\n&#x2F;&#x2F; 根据鼠标坐标数据计算每个坐标点的前后控制点\ncalControlPoints: (points: IPoint[]) &#x3D;&gt; IControlPoint[];\n&#x2F;&#x2F; 将鼠标坐标数据和控制点数据组合为贝塞尔曲线\ntransformPointToBezier: (\n  points: IPoint[],\n  controlPoints: IControlPoint[]\n) &#x3D;&gt; Bezier[];\n&#x2F;&#x2F; 根据原始的贝塞尔曲线数据，计算出用于绘制的数据结构\ncalDrawingData: (\n  bzArray: Bezier[],\n  totalLength: number\n) &#x3D;&gt; IDrawingBezierData[];\n&#x2F;&#x2F; 根据计算出的绘制数据，将曲线绘制到画布上\ndrawDrawingBezierData: (\n  ctx: CanvasRenderingContext2D,\n  data: IDrawingBezierData[]\n) &#x3D;&gt; void;\n&#x2F;&#x2F; 一个方便简单使用的入口方法，直接通过处理好的鼠标坐标数据，绘制鼠标轨迹\ndrawLaserPen: (ctx: CanvasRenderingContext2D, points: IPoint[]) &#x3D;&gt; void;\n\n其他\nlaser-pen\n突然有个想法：王者荣耀的拖尾效果实现原理，是不是和这个类似？\n\n","slug":"2022-05-27wiki-laserPen","date":"2022-05-27T08:07:33.000Z","categories_index":"wiki","tags_index":"wiki","author_index":"陈海龙"},{"id":"8b8288a2a8637d5beee93bb6d37a8ba8","title":"redux-logger源码","content":"redux 日志中间件.\n├── core.js\n├── defaults.js\n├── diff.js\n├── helpers.js &#x2F;&#x2F; 一些帮助函数\n└── index.js\n\n0 directories, 5 files\ndefaultLoggerv3 版本，破坏性变更\n之前\nimport createLogger from &quot;redux-logger&quot;;\n\n之后\nimport &#123; createLogger &#125; from &quot;redux-logger&quot;;\n\n源码\n&#x2F;&#x2F; src&#x2F;index.js\n\nconst defaultLogger &#x3D; (&#123; dispatch, getState &#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  if (typeof dispatch &#x3D;&#x3D;&#x3D; &quot;function&quot; || typeof getState &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n    &#x2F;&#x2F; createLogger，柯里化 工厂模式\n    return createLogger()(&#123; dispatch, getState &#125;);\n  &#125;\n  &#x2F;&#x2F; 如果没有传递dispatch和getState，打印错误信息\n  &#x2F;&#x2F; v3版本，破坏性变更, 根据《语义化版本》不看内容也知道有破坏性变更\n  &#x2F;&#x2F; Since 3.0.0 redux-logger exports by default logger with default settings\n  &#x2F;&#x2F; import createLogger from &#39;redux-logger&#39; &#x3D;&gt; import &#123; createLogger &#125; from &#39;redux-logger&#39;\n  console.error(&#96;\n[redux-logger v3] BREAKING CHANGE\n[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.\n[redux-logger v3] Change\n[redux-logger v3] import createLogger from &#39;redux-logger&#39;\n[redux-logger v3] to\n[redux-logger v3] import &#123; createLogger &#125; from &#39;redux-logger&#39;\n&#96;);\n&#125;;\n\nexport &#123; defaults, createLogger, defaultLogger as logger &#125;;\n\nexport default defaultLogger;\n\ncreateLogger\n使用传入的 options， 创建日志记录器\n\n&#x2F;**\n * Creates logger with following options\n * 创建日志记录器，配置如下：\n * @namespace\n * @param &#123;object&#125; options - options for logger\n * @param &#123;string | function | object&#125; options.level - console[level] 日志级别\n * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间\n * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳\n * @param &#123;object&#125; options.colors - custom colors 定制颜色\n * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现\n * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出\n * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组\n * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为\n * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换\n * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换\n * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换\n *\n * @returns &#123;function&#125; logger middleware 返回中间件\n *&#x2F;\nfunction createLogger(options &#x3D; &#123;&#125;) &#123;\n  const loggerOptions &#x3D; Object.assign(&#123;&#125;, defaults, options);\n\n  const &#123;\n    logger,\n    stateTransformer,\n    errorTransformer,\n    predicate,\n    logErrors,\n    diffPredicate,\n  &#125; &#x3D; loggerOptions;\n\n  &#x2F;&#x2F; Return if &#39;console&#39; object is not defined\n  &#x2F;&#x2F; 如果&#39;console&#39;对象未定义，返回\n  if (typeof logger &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);\n  &#125;\n\n  &#x2F;&#x2F; Detect if &#39;createLogger&#39; was passed directly to &#39;applyMiddleware&#39;.\n  &#x2F;&#x2F; 判断是否传递给applyMiddleware\n  if (options.getState &amp;&amp; options.dispatch) &#123;\n    &#x2F;&#x2F; eslint-disable-next-line no-console\n    console.error(&#96;[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n&#x2F;&#x2F; Logger with default options\nimport &#123; logger &#125; from &#39;redux-logger&#39;\nconst store &#x3D; createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n&#x2F;&#x2F; Or you can create your own logger with custom options http:&#x2F;&#x2F;bit.ly&#x2F;redux-logger-options\nimport &#123; createLogger &#125; from &#39;redux-logger&#39;\nconst logger &#x3D; createLogger(&#123;\n  &#x2F;&#x2F; ...options\n&#125;);\nconst store &#x3D; createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n&#96;);\n    &#x2F;&#x2F; 中间件书写套路\n    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);\n  &#125;\n\n  const logBuffer &#x3D; [];\n\n  return (&#123; getState &#125;) &#x3D;&gt;\n    (next) &#x3D;&gt;\n    (action) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; Exit early if predicate function returns &#39;false&#39; 如果predicate函数返回false，退出\n      if (typeof predicate &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; !predicate(getState, action)) &#123;\n        return next(action);\n      &#125;\n\n      const logEntry &#x3D; &#123;&#125;;\n\n      logBuffer.push(logEntry);\n\n      logEntry.started &#x3D; timer.now();\n      logEntry.startedTime &#x3D; new Date();\n      logEntry.prevState &#x3D; stateTransformer(getState());\n      logEntry.action &#x3D; action;\n\n      let returnedValue;\n      if (logErrors) &#123;\n        try &#123;\n          returnedValue &#x3D; next(action);\n        &#125; catch (e) &#123;\n          logEntry.error &#x3D; errorTransformer(e);\n        &#125;\n      &#125; else &#123;\n        returnedValue &#x3D; next(action);\n      &#125;\n\n      logEntry.took &#x3D; timer.now() - logEntry.started;\n      logEntry.nextState &#x3D; stateTransformer(getState());\n\n      const diff &#x3D;\n        loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;\n          ? diffPredicate(getState, action)\n          : loggerOptions.diff;\n\n      printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;));\n      logBuffer.length &#x3D; 0;\n\n      if (logEntry.error) throw logEntry.error;\n      return returnedValue;\n    &#125;;\n&#125;\n\ndefaults 默认配置\n&#x2F;&#x2F; src&#x2F;default.js\nexport default &#123;\n  level: &quot;log&quot;,\n  logger: console,\n  logErrors: true,\n  collapsed: undefined,\n  predicate: undefined,\n  duration: false,\n  timestamp: true,\n  stateTransformer: (state) &#x3D;&gt; state,\n  actionTransformer: (action) &#x3D;&gt; action,\n  errorTransformer: (error) &#x3D;&gt; error,\n  colors: &#123;\n    title: () &#x3D;&gt; &quot;inherit&quot;,\n    prevState: () &#x3D;&gt; &quot;#9E9E9E&quot;,\n    action: () &#x3D;&gt; &quot;#03A9F4&quot;,\n    nextState: () &#x3D;&gt; &quot;#4CAF50&quot;,\n    error: () &#x3D;&gt; &quot;#F20404&quot;,\n  &#125;,\n  diff: false,\n  diffPredicate: undefined,\n\n  &#x2F;&#x2F; Deprecated options 已废弃配置\n  transformer: undefined,\n&#125;;\n&#x2F;&#x2F; 字段释义\n&#x2F;**\n * Creates logger with following options\n * 创建日志记录器，配置如下：\n * @namespace\n * @param &#123;object&#125; options - options for logger\n * @param &#123;string | function | object&#125; options.level - console[level] 日志级别\n * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间\n * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳\n * @param &#123;object&#125; options.colors - custom colors 定制颜色\n * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现\n * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出\n * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组\n * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为\n * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换\n * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换\n * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换\n *\n * @returns &#123;function&#125; logger middleware 返回中间件\n *&#x2F;\n\n奇怪\n\n这两个配置在测试文件中，没找到相关测试代码\n\n &#x2F;&#x2F; 配置\n diff: false, &#x2F;&#x2F;\n diffPredicate: undefined,\n\n &#x2F;&#x2F; ...\n\n const diff &#x3D;\n       loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;\n         ? diffPredicate(getState, action)\n         : loggerOptions.diff;\n &#x2F;&#x2F; 打印日志中\n printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;));\n\n &#x2F;&#x2F; src&#x2F;core.js printBuffer的定义\nfunction printBuffer(buffer, options) &#123;\n   const &#123;\n     &#x2F;&#x2F; ...\n       diff,\n   &#125; &#x3D; options;\n   &#x2F;&#x2F; 如果开启\n   if (diff) &#123;\n     &#x2F;&#x2F; 执行了 diffLogger\n     diffLogger(prevState, nextState, logger, isCollapsed);\n   &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;diff.js\nexport default function diffLogger(prevState, newState, logger, isCollapsed) &#123;\n  &#x2F;&#x2F; import differ from &#39;deep-diff&#39;;计算对象差异化的包\n  const diff &#x3D; differ(prevState, newState);\n\n  try &#123;\n    if (isCollapsed) &#123;\n      logger.groupCollapsed(&#39;diff&#39;);\n    &#125; else &#123;\n      logger.group(&#39;diff&#39;);\n    &#125;\n  &#125; catch (e) &#123;\n    logger.log(&#39;diff&#39;);\n  &#125;\n  &#x2F;&#x2F; 有差异执行输出，这个差异包含类型kind E:编辑 N:新增 D:删除 A:数组\n  &#x2F;&#x2F; dictionary为对象，对kind值进行枚举\n  &#x2F;&#x2F; 遍历输出\n  if (diff) &#123;\n    diff.forEach((elem) &#x3D;&gt; &#123;\n      const &#123; kind &#125; &#x3D; elem;\n      const output &#x3D; render(elem);\n\n      logger.log(&#96;%c $&#123;dictionary[kind].text&#125;&#96;, style(kind), ...output);\n    &#125;);\n  &#125; else &#123;\n    logger.log(&#39;—— no diff ——&#39;);\n  &#125;\n\n  try &#123;\n    logger.groupEnd();\n  &#125; catch (e) &#123;\n    logger.log(&#39;—— diff end —— &#39;);\n  &#125;\n&#125;\n\n\nhelpers&#x2F;&#x2F; repeat + pad &#x3D; padLeft 左侧补零， es多少有个api\nexport const repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);\n\nexport const pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;\n&#x2F;&#x2F; 时间格式化\nexport const formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;\n\n&#x2F;&#x2F; Use performance API if it&#39;s available in order to get better precision\nexport const timer &#x3D;\n(typeof performance !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; performance !&#x3D;&#x3D; null) &amp;&amp; typeof performance.now &#x3D;&#x3D;&#x3D; &#39;function&#39; ?\n  performance :\n  Date;\n运行测试下\nconst repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);\n\nconst pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;\n\nconst formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;\n\nconsole.log(formatTime(new Date()))\n&#x2F;&#x2F; 输出\n18:58:15.667\n\n\n源码图\ndeep-diff\n看下两个对象比较的事例\n\nvar lhs &#x3D; &#123;\n\tname: &#39;my object&#39;,\n\tdescription: &#39;it\\&#39;s an object!&#39;,\n\tdetails: &#123;\n\t\tit: &#39;has&#39;,\n\t\tan: &#39;array&#39;,\n\t\twith: [&#39;a&#39;, &#39;few&#39;, &#39;elements&#39;]\n\t&#125;\n&#125;;\n\nvar rhs &#x3D; &#123;\n\tname: &#39;updated object&#39;,\n\tdescription: &#39;it\\&#39;s an object!&#39;,\n\tdetails: &#123;\n\t\tit: &#39;has&#39;,\n\t\tan: &#39;array&#39;,\n\t\twith: [&#39;a&#39;, &#39;few&#39;, &#39;more&#39;, &#39;elements&#39;, &#123; than: &#39;before&#39; &#125;]\n\t&#125;\n&#125;;\n\nvar differences &#x3D; deep.diff(lhs, rhs);\n\n\n&#x2F;&#x2F; 输出\n\n\n27 May 17:27:12 - [\n  DiffEdit &#123;\n    kind: &#39;E&#39;,\n    path: [ &#39;name&#39; ],\n    lhs: &#39;my object&#39;,\n    rhs: &#39;updated object&#39;\n  &#125;,\n  DiffArray &#123;\n    kind: &#39;A&#39;,\n    path: [ &#39;details&#39;, &#39;with&#39; ],\n    index: 4,\n    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#123; than: &#39;before&#39; &#125; &#125;\n  &#125;,\n  DiffArray &#123;\n    kind: &#39;A&#39;,\n    path: [ &#39;details&#39;, &#39;with&#39; ],\n    index: 3,\n    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#39;elements&#39; &#125;\n  &#125;,\n  DiffEdit &#123;\n    kind: &#39;E&#39;,\n    path: [ &#39;details&#39;, &#39;with&#39;, 2 ],\n    lhs: &#39;elements&#39;,\n    rhs: &#39;more&#39;\n  &#125;\n]\n","slug":"2022-05-27redux-logger","date":"2022-05-27T05:52:01.000Z","categories_index":"redux","tags_index":"redux,源码","author_index":"陈海龙"},{"id":"98e904a0d3e9702a10dc20a22eaad4dd","title":"vscode i18n-ally","content":"国际化\n大型公司的国际化需求很高，需要支持多语言，比如中文、英文、日文等等。\ni18n-ally是一个基于vscode的国际化工具，可以帮助你快速的实现国际化。\n\n背景\n如果经常做国际化的研发，应该很清楚，代码中写多语言，然而，多语言在项目中维护是非常困难的。\n当遇到大型项目，业务要做拆分成为微前端架构，多语言要在多个项目中维护，浪费时间不说，还可能造成不一致问题\n处理方式：\n将对应的多语言开发为npm包，在项目中引入\n拆多语言为一个应用平台，实现多项目共享，实现可视化交互（我们目前使用，自研localize平台，实现多语言管理）\n\n\n\n题外话应用平台\n\n动态生效： 修改多语言不需要重启、发布服务\n翻译管理：多人协同在线翻译\n版本管理： 记录翻译变更记录以及对应的操作人，方便定位与排错\n自动多区同步：只需在中国区修改，系统会自动同步到国外5区\n\n优点\n提示优雅，未处理的多语言会有提示\n编辑方便\n\n\n\n\n\n\nEnglish | 简体中文\n\n\n\n\n\n\n\n\n\n\n\n\nv2.0 is released with new Editor UI and Review System 🎉\n\n\n\nMigrate from v1.x\n\n\n\n\n\n\n\n\n\nMaintained by\n\n\nLokalise is the fastest growing language cloud technology made by developers, for developers.\nAs a collaborative productivity platform, it helps structure and automate the translation and localization process for any company in the world.\nLokalise是开发人员为开发人员开发的增长最快的语言云技术\n作为一个协作生产力平台，它可以帮助世界上任何公司构建和自动化翻译和本地化过程。\nLearn more\n\n\n\n\n\n\n\n📖 Docs 文档\n|\n💭 FAQ 问答\n|\n⚙️ Configs 配置\n|\n📜 Supported Formats 支持格式\n|\n🧱 Contribute 贡献\n\n\n\n\n\nInline Annotations 行内提示\n\n\nHover and Direct Actions 悬停和直接操作\n\n\nManage All Translations in One Place 在一个位置管理所有翻译\n\n\nEditor UI编辑界面 & Review System 预览系统\n\n\nExtract Translations from Code 从代码中提取翻译\n\n\nReport Missing Translations 报告缺失的翻译\n\n\nMachine Translation 机器翻译\n\n\nAnnotations for JSON and YAML 来源于JSON 和 YAML的提示\n\n\nGeneral Features\n\n\nSupports multi-root workspaces  支持多个工作空间\nSupports remote development 支持远程开发\nSupports numerous popular frameworks 支持多种流行框架\nSupports linked locale messages 链接的区域设置消息\nUses i18n for the extension itself, of course. 当然，将i18n用于扩展本身。 Translation List 翻译列表\n\n🌍 Multilingual Support 多语言支持This extension itself supports i18n as well. It will be auto-matched to the display language you use in your VS Code editor. We currently support the following languages.这个扩展支持多语言。它将自动匹配到你在VS Code编辑器中使用的语言。我们目前支持的语言有：\n\n\n\nLanguage\nMaintainer\nContributors\n\n\n\nEnglish   英语\n@antfu\n@rubjo, @EdRands\n\n\nSimplified Chinese (简体中文)\n@antfu\n\n\n\nTraditional Chinese (繁體中文)\n@antfu\n\n\n\nNorwegian (Norsk) 挪威语\n\n@rubjo\n\n\nSpanish (Español) 西班牙的\n\n@Baltimer\n\n\nJapanese (日本語) 日语\n\n@isdh\n\n\nDutch (Nederlands) 荷兰语\n\n@Niekvdm, @Excalibaard\n\n\nPortuguese (Brazilian) 葡萄牙语\n\n@Ibcs16\n\n\nFrench (Français) 法语\n\n@Nicoxx45, @eri\n\n\nSwedish (Svenska)瑞典语\n@vladdeSV\n\n\n\nUkrainian (Українська) 乌克兰语\n\n@uhodav\n\n\nRussian (Русский) 俄语\n\n@uhodav\n\n\nGerman (Deutsch) 德语\n@alexanderniebuhr\n\n\n\nTurkish (Türkçe) 土耳其语\n\n@eri\n\n\n帮忙翻译\n\n\n\n\n\n\n\n\n\n👨‍💻 如果您想帮助一种语言的翻译更新，请在维护者字段中输入您的姓名。我会在需要的时候提到你。非常感谢。\n❤️ 感谢此插件的灵感来源于think2011&#x2F;vscode-vue-i18n. 如果没有@think2011,i18n-ally不会存在\n对Vue单文件组件（SFC）的支持由[kazupon&#x2F;Vue-i18n-locale-message]提供支持(https://github.com/kazupon/vue-i18n-locale-message)，它是由vue-i18n的作者创建的。谢谢你做这个！\n代码共享者非常感谢所有杰出的贡献者：\n协议MIT License © 2019-PRESENT Anthony Fu\nMIT License © 2018-2019 think2011\n安装Visual Studio Code&gt;Other&gt;i18n Ally\n使用参考资料github 官网\n","slug":"2022-05-27i18n","date":"2022-05-27T02:47:24.000Z","categories_index":"","tags_index":"工具,增效,vscode","author_index":"陈海龙"},{"id":"ef136ce7ac94dd6f9c2f35712eef1e47","title":"redux-thunk源码","content":"源码版本v2.4.1\n用途\n通过redux源码applyMiddleware了解到，是对store.dispatch进行增强\n可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。\n可以在这个函数中执行一些异步的操作\n\nexport function addCount() &#123;\n  return &#123;type: ADD_COUNT&#125;\n&#125; \nexport function addCountAsync() &#123;\n  return dispatch &#x3D;&gt; &#123; &#x2F;&#x2F; dispatch对应源码的 ： action(dispatch, getState, extraArgument);的第一个参数\n    setTimeout( () &#x3D;&gt; &#123;\n      dispatch(addCount())\n    &#125;,2000)\n  &#125;\n&#125;\n\n\naddCountAsync函数就返回了一个函数，将dispatch作为函数的第一个参数传递进去，在函数内进行异步操作就可以了。\n\npackage.json\n这个文件结构与redux、react-redux相比，没有什么特别之处，这里及以后如无必要不在进行阅读\n简单扫一眼就好\n\n源码&#x2F;** A function that accepts a potential &quot;extra argument&quot; value to be injected later,\n * and returns an instance of the thunk middleware that uses that value\n *&#x2F;\n&#x2F;** 一个函数接收一个可能的&quot;extra argument&quot;值，并返回一个thunk中间件，它使用这个值 *&#x2F;\nfunction createThunkMiddleware&lt;\n  State &#x3D; any,\n  BasicAction extends Action &#x3D; AnyAction,\n  ExtraThunkArg &#x3D; undefined\n&gt;(extraArgument?: ExtraThunkArg) &#123;\n  &#x2F;&#x2F; Standard Redux middleware definition pattern:\n  &#x2F;&#x2F; 标准Redux中间件定义模式:\n  &#x2F;&#x2F; See: https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#writing-custom-middleware\n  const middleware: ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt; &#x3D;\n    (&#123; dispatch, getState &#125;) &#x3D;&gt; (next) &#x3D;&gt;  (action) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; The thunk middleware looks for any functions that were passed to &#96;store.dispatch&#96;.\n      &#x2F;&#x2F; If this &quot;action&quot; is really a function, call it and return the result.\n      &#x2F;&#x2F; 这个thunk中间件会查找store.dispatch传入的任何函数。如果这个&quot;action&quot;是一个函数，调用它并返回结果。\n      if (typeof action &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n        &#x2F;&#x2F; Inject the store&#39;s &#96;dispatch&#96; and &#96;getState&#96; methods, as well as any &quot;extra arg&quot;\n        &#x2F;&#x2F; 注入store的dispatch和getState方法，以及任意的&quot;extra arg&quot;\n        return action(dispatch, getState, extraArgument);\n      &#125;\n      &#x2F;&#x2F; 否则，像往常一样将操作传递给中间件链\n      &#x2F;&#x2F; Otherwise, pass the action down the middleware chain as usual\n      return next(action);\n    &#125;;\n  return middleware;\n&#125;\n中间件模式\n柯里化：将一个函数的参数分解成多个参数，并且返回一个新的函数，这个新的函数可以被调用，并且返回原函数的结果。\nconst anotherExampleMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;\n  &#x2F;&#x2F; Do something in here, when each action is dispatched\n\n  return next(action)\n&#125;\nstoreAPI\n&#x2F;&#x2F; storeAPI\n\nconst store &#x3D; &#123;\n  dispatch: dispatch as Dispatch&lt;A&gt;,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n工厂模式\n\nconst thunk &#x3D; createThunkMiddleware() as ThunkMiddleware &amp; &#123;\n  withExtraArgument&lt;\n    ExtraThunkArg,\n    State &#x3D; any,\n    BasicAction extends Action &#x3D; AnyAction\n  &gt;(\n    extraArgument: ExtraThunkArg\n  ): ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt;\n&#125;\n\n&#x2F;&#x2F; Attach the factory function so users can create a customized version\n&#x2F;&#x2F; with whatever &quot;extra arg&quot; they want to inject into their thunks\n&#x2F;&#x2F; 尝试将工厂函数附加到用户可以创建任何额外的&quot;extra arg&quot;的thunk中间件\nthunk.withExtraArgument &#x3D; createThunkMiddleware\n\nexport default thunk\n参考redux-thunk源码Redux中间件之redux-thunk使用详解\n","slug":"2022-05-27redux-thunk","date":"2022-05-27T01:21:50.000Z","categories_index":"redux","tags_index":"redux,源码,redux-thunk","author_index":"陈海龙"},{"id":"33a4c09d5b272c8b61a9dda679d7a5e9","title":"npm 包发布相关","content":"npm 包发布npm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; \nnpm notice name:          @tutu-fe&#x2F;wiki-ui                        \nnpm notice version:       0.1.1-beta                              \nnpm notice filename:      @tutu-fe&#x2F;wiki-ui-0.1.1-beta.tgz         \nnpm notice package size:  85.7 kB                                 \nnpm notice unpacked size: 449.9 kB                                \nnpm notice shasum:        973f5eb8d74de04c34b8e9c94536f8924b1f9570\nnpm notice integrity:     sha512-Uyo3zS0eaMOYE[...]60Ywmrmb&#x2F;brxQ&#x3D;&#x3D;\nnpm notice total files:   205                                     \nnpm notice \nnpm ERR! code E403\nnpm ERR! 403 403 Forbidden - PUT https:&#x2F;&#x2F;registry- - [maintainers_error] haotian.chen does not in maintainer list\nnpm ERR! 403 In most cases, you or one of your dependencies are requesting\nnpm ERR! 403 a package version that is forbidden by your security policy, or\nnpm ERR! 403 on a server you do not have access to.\n\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     &#x2F;Users&#x2F;haotian&#x2F;.npm&#x2F;_logs&#x2F;2022-04-28T09_58_10_365Z-debug.log\n\n\n配置package.json&quot;maintainers&quot;: [\n  &quot;davishua&quot;,å\n  &quot;haotian.chen&quot;\n],\n\n\n结果\n","slug":"2022-04-28npm","date":"2022-05-26T14:12:56.671Z","categories_index":"npm","tags_index":"npm","author_index":"陈海龙"},{"id":"0539c4f1e60b889c5708d72373a67061","title":"企业微信： 图片附件无法预览的问题","content":"\n\n背景：安卓预览正常，部分iOS预览有问题（大部分手机都是正常的）downloadAttachment(downloadUrl).then(res &#x3D;&gt; &#123;\n      if (getWechatUserAgent(navigator.userAgent)) &#123; &#x2F;&#x2F; 判断是企业微信\n        const blob &#x3D; new Blob([res]);\n        wx.previewFile(&#123;\n          url: location.origin + downloadUrl, &#x2F;&#x2F; 需要预览文件的地址(必填，可以使用相对路径)\n          name: attachment.name, &#x2F;&#x2F; 需要预览文件的文件名，必须有带文件格式的后缀，例如.doc(不填的话取url的最后部分，最后部分是个包含格式后缀的文件名)\n          size: blob.size &#x2F;&#x2F; 需要预览文件的字节大小(必填，而且大小必须正确，否则会打开失败)\n        &#125;);\n        Toast.loading(i18n.loading, false)\n        return\n      &#125;\n      var reader &#x3D; new FileReader();\n      reader.readAsDataURL(res);   &#x2F;&#x2F; 转换为base64，可以直接放入a标签href\n      reader.onload &#x3D; function (e) &#123;\n        const anchorEle &#x3D; document.createElement(&#39;a&#39;)\n        document.body.appendChild(anchorEle)\n        anchorEle.href &#x3D; e?.target?.result as any\n        anchorEle.download &#x3D; attachment.name\n        anchorEle.click()\n        document.body.removeChild(anchorEle)\n      &#125;\n      Toast.loading(i18n.loading, false)\n    &#125;).catch(() &#x3D;&gt; &#123;\n      Toast.loading(i18n.loading, false)\n    &#125;)\n自研移动端、web端、企业微信桌面端都没问题，当然喽，每一个端展示效果是不一样的，代码也不一样。排查了耗费一定时间。\n\n\n排查 企业微信版本， 比对后发现，和正常使用的微信版本一致\n排查手机版本不一致，客户iphone12和 系统版本15.1，我们开发人员是14.+，所以我把我的手机升级到最新，我的手机升级后是正常的，那么可能是数据问题，数据\n排查数据，这是老系统的数据，和新系统数据走不同的业务代码，经排查也没问题\n排查size如果不准确也会出现上述问题，由于预发环境获取票据的信息与线上是不一致的，所以无法在预发进行排查，能做的事保证代码执行到 const blob = new Blob([res]);，并且能够获取到正确的size，所以进行了alert调试，这个在手机上比较直观，当然也可以vconsole【暂不考虑,因为之前开发人员没加，部门被砍掉，很多人被裁员了，所有项目都我来维护，没时间，不整了】，调试结果是size: 88214,各个手机都一样，用户手机也是88214，故排除size\n最后可能问题在于，用户手机上版本与手机不匹配，有兼容性bug，尝试升级企业微信，最后解决\n\n\n\n总结：如果考虑直接升级用户app版本，或许在第三步就解决问题了，我的iphoneX也不用升级到15.3了\n","slug":"2022-04-19wework-preview","date":"2022-05-26T14:12:56.670Z","categories_index":"WeWork","tags_index":"WeWork","author_index":"陈海龙"},{"id":"5df43a7a7d0a76be0dcfbc13fca3f3d6","title":"js 代码注释","content":"代码注释//这种js注释代码在vscode其他地方引用时候，没有提示， 如果需要有提示，需要写成/** 提示 **/\n写法1\nexport enum ELeaveType &#123;\n  MATERNITY_ &#x3D; 17, &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),\n&#125;\n写法2\nexport enum ELeaveType &#123;\n  &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),\n  MATERNITY_ &#x3D; 17, \n&#125;\n\n有提示注释写法export enum ELeaveType &#123;\n...\n  &#x2F;**&quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),**&#x2F;\n  MATERNITY_ &#x3D; 17, \n...\n&#125;\n\n\n","slug":"2022-05-26code","date":"2022-05-26T07:31:20.000Z","categories_index":"code","tags_index":"code","author_index":"陈海龙"},{"id":"da6549350c9a9d927d67bdb10bc76a3c","title":"redux 源码 2","content":"redux 简介Predictable state container for JavaScript apps\n字面意思\njs应用可预测状态容器\n\n怎么用，为什么用看官网。。。\ncreateStore代码注释如下\n\nredux store持有state树，唯一可以改变store中数据的方式是dispatch\n在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer\n一个根据当前state和行为返回新state的函数\n初始state，\nstore中间件。可以使用第三方中间件增强store\nredux store 可以读取state，dispatch行为，订阅改变\n\n\n&#x2F;**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call &#96;dispatch()&#96; on it.\n * \n * redux store持有state树，唯一可以改变store中数据的方式是dispatch\n * \n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using &#96;combineReducers&#96;.\n *\n * 在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer\n * \n * @param reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n * \n * 一个根据当前state和行为返回新state的函数\n *\n * @param preloadedState The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use &#96;combineReducers&#96; to produce the root reducer function, this must be\n * an object with the same shape as &#96;combineReducers&#96; keys.\n *\n * 初始state，\n * \n * @param enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is &#96;applyMiddleware()&#96;.\n *\n * store中间件。可以使用第三方中间件增强store\n * \n * @returns A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n * \n * redux store 可以读取state，dispatch行为，订阅改变\n *&#x2F;\n函数声明\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt;, &#x2F;&#x2F; &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;,&#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;, &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件\n\n  &#x2F;&#x2F; 这里可以看到 preloadedState的参数| StoreEnhancer&lt;Ext, StateExt&gt; 与 enhancer类型一致， 这里处理第二参数可能是 enhancer\n  &#x2F;&#x2F; 代码主体分有做判断：\n  &#x2F;&#x2F; if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  &#x2F;&#x2F;   enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  &#x2F;&#x2F;   preloadedState &#x3D; undefined\n  &#x2F;&#x2F; &#125; \n\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;&#125;\ncreateStore 主体代码\n\n一些入参校验\n\nif (\n  (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||\n  (typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof arguments[3] &#x3D;&#x3D;&#x3D; &#39;function&#39;)\n) &#123;\n  throw new Error(\n    &#39;It looks like you are passing several store enhancers to &#39; +\n      &#39;createStore(). This is not supported. Instead, compose them &#39; +\n      &#39;together to a single function. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#creating-a-store-with-enhancers for an example.&#39;\n  )\n&#125;\n\nif (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  preloadedState &#x3D; undefined\n&#125;\n\nif (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  if (typeof enhancer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new Error(\n      &#96;Expected the enhancer to be a function. Instead, received: &#39;$&#123;kindOf(\n        enhancer\n      )&#125;&#39;&#96;\n    )\n  &#125;\n\n  return enhancer(createStore)(\n    reducer,\n    preloadedState as PreloadedState&lt;S&gt;\n  ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n&#125;\n\nif (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n  throw new Error(\n    &#96;Expected the root reducer to be a function. Instead, received: &#39;$&#123;kindOf(\n      reducer\n    )&#125;&#39;&#96;\n  )\n&#125;\n\n&#x2F;&#x2F; 当前reducer\nlet currentReducer &#x3D; reducer\n&#x2F;&#x2F; 当前状态\nlet currentState &#x3D; preloadedState as S\n&#x2F;&#x2F; 当前订阅\nlet currentListeners: (() &#x3D;&gt; void)[] | null &#x3D; []\n&#x2F;&#x2F; 新的订阅\nlet nextListeners &#x3D; currentListeners\nlet isDispatching &#x3D; false\n\n\n\n&#x2F;**\n * This makes a shallow copy of currentListeners so we can use\n * nextListeners as a temporary list while dispatching.\n *\n * This prevents any bugs around consumers calling\n * subscribe&#x2F;unsubscribe in the middle of a dispatch.\n *&#x2F;\n&#x2F;&#x2F; 浅拷贝当前currentListeners得到 nextListeners 用于 dispatching   \n\n&#x2F;&#x2F; 确定新的可变监听\nfunction ensureCanMutateNextListeners() &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 获取store的状态\nfunction getState(): S &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 传入监听，返回监听移除的函数\nfunction subscribe(listener: () &#x3D;&gt; void) &#123;\n  。。。\n\n  return function unsubscribe() &#123;\n    。。。。\n  &#125;\n&#125;\n\n\nfunction dispatch(action: A) &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 用于同构更新reducer\nfunction replaceReducer&lt;NewState, NewActions extends A&gt;(\n  nextReducer: Reducer&lt;NewState, NewActions&gt;\n): Store&lt;ExtendState&lt;NewState, StateExt&gt;, NewActions, StateExt, Ext&gt; &amp; Ext &#123;\n  。。。\n&#125;\n\n&#x2F;**\n * Interoperability point for observable&#x2F;reactive libraries.\n * @returns A minimal observable of state changes.\n * For more information, see the observable proposal:\n * https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-observable\n *&#x2F;\n&#x2F;&#x2F; 实现小型观察状态变更\nfunction observable() &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 当store被创建，初始化操作会被dispatch，，每个reducer会返回最初的state. 有效地填充初始状态树。\ndispatch(&#123; type: ActionTypes.INIT &#125; as A)\n\n\nconst store &#x3D; &#123;\n  dispatch: dispatch as Dispatch&lt;A&gt;,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nreturn store &#x2F;&#x2F; store上的api我们又熟悉了\n\n\nensureCanMutateNextListeners\n\n浅拷贝当前currentListeners得到 nextListeners 用于 dispatching\n\nfunction ensureCanMutateNextListeners() &#123;\n  if (nextListeners &#x3D;&#x3D;&#x3D; currentListeners) &#123;\n    nextListeners &#x3D; currentListeners.slice()\n  &#125;\n&#125;\n\n\n\ngetState\n\n获取store的状态\n\nfunction getState(): S &#123;\n  if (isDispatching) &#123;\n    throw new Error(\n      &#39;You may not call store.getState() while the reducer is executing. &#39; +\n        &#39;The reducer has already received the state as an argument. &#39; +\n        &#39;Pass it down from the top reducer instead of reading it from the store.&#39;\n    )\n  &#125;\n\n  return currentState as S\n&#125;\nsubscribe\n&#x2F;**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call &#96;getState()&#96; to read the current state tree inside the callback.\n   *\n   * You may call &#96;dispatch()&#96; from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every &#96;dispatch()&#96; call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the &#96;dispatch()&#96; that is currently in progress.\n   * However, the next &#96;dispatch()&#96; call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested &#96;dispatch()&#96; before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the &#96;dispatch()&#96; started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param listener A callback to be invoked on every dispatch.\n   * @returns A function to remove this change listener.\n   *&#x2F;\n  &#x2F;&#x2F; 上述注释\n  &#x2F;** 添加一个监听，在action被触发时候会调用，state会进行更新，在回调中可以用getState方法获取当前状态树\n   * 两个注意：订阅的是在每个dispatch之前的快照，\n   * 1.\n   * 订阅是在每次&#39;dispatch（）&#39;调用之前进行快照的。\n   * 如果在调用侦听器时订阅或取消订阅，这将不会对当前正在进行的“dispatch（）”产生任何影响。\n   * 但是，下一个&#39;dispatch（）&#39;调用（无论是否嵌套）将使用订阅列表的最新快照。\n   * 2。\n   * 监听器不应该期望看到所有的状态更改，因为在调用监听器之前，状态可能在嵌套的&#39;dispatch（）&#39;期间被多次更新。\n   * 但是，可以保证在“dispatch（）”启动之前注册的所有订阅者在退出时都将以最新状态调用。\n   * *&#x2F;\n  function subscribe(listener: () &#x3D;&gt; void) &#123;\n    if (typeof listener !&#x3D;&#x3D; &#39;function&#39;) &#123;\n      throw new Error(\n        &#96;Expected the listener to be a function. Instead, received: &#39;$&#123;kindOf(\n          listener\n        )&#125;&#39;&#96;\n      )\n    &#125;\n\n    if (isDispatching) &#123;\n      throw new Error(\n        &#39;You may not call store.subscribe() while the reducer is executing. &#39; +\n          &#39;If you would like to be notified after the store has been updated, subscribe from a &#39; +\n          &#39;component and invoke store.getState() in the callback to access the latest state. &#39; +\n          &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;\n      )\n    &#125;\n\n    let isSubscribed &#x3D; true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener) &#x2F;&#x2F; 增加\n\n    return function unsubscribe() &#123;\n      if (!isSubscribed) &#123;\n        return\n      &#125;\n\n      if (isDispatching) &#123;\n        throw new Error(\n          &#39;You may not unsubscribe from a store listener while the reducer is executing. &#39; +\n            &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;\n        )\n      &#125;\n\n      isSubscribed &#x3D; false\n\n      ensureCanMutateNextListeners()\n      const index &#x3D; nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1) &#x2F;&#x2F; 移除\n      currentListeners &#x3D; null\n    &#125;\n  &#125;\n\ndispatch\n&#x2F;**\n * Dispatches an action. It is the only way to trigger a state change.\n *\n * The &#96;reducer&#96; function, used to create the store, will be called with the\n * current state tree and the given &#96;action&#96;. Its return value will\n * be considered the **next** state of the tree, and the change listeners\n * will be notified.\n *\n * The base implementation only supports plain object actions. If you want to\n * dispatch a Promise, an Observable, a thunk, or something else, you need to\n * wrap your store creating function into the corresponding middleware. For\n * example, see the documentation for the &#96;redux-thunk&#96; package. Even the\n * middleware will eventually dispatch plain object actions using this method.\n *\n * @param action A plain object representing “what changed”. It is\n * a good idea to keep actions serializable so you can record and replay user\n * sessions, or use the time travelling &#96;redux-devtools&#96;. An action must have\n * a &#96;type&#96; property which may not be &#96;undefined&#96;. It is a good idea to use\n * string constants for action types.\n *\n * @returns For convenience, the same action object you dispatched.\n *\n * Note that, if you use a custom middleware, it may wrap &#96;dispatch()&#96; to\n * return something else (for example, a Promise you can await).\n *&#x2F;\nfunction dispatch(action: A) &#123;\n  if (!isPlainObject(action)) &#123; &#x2F;&#x2F; 只能是简单的对象\n    throw new Error(\n      &#96;Actions must be plain objects. Instead, the actual type was: &#39;$&#123;kindOf(\n        action\n      )&#125;&#39;. You may need to add middleware to your store setup to handle dispatching other values, such as &#39;redux-thunk&#39; to handle dispatching functions. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#middleware and https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-6-async-logic#using-the-redux-thunk-middleware for examples.&#96;\n    )\n  &#125;\n\n  if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n    throw new Error(\n      &#39;Actions may not have an undefined &quot;type&quot; property. You may have misspelled an action type string constant.&#39;\n    )\n  &#125;\n\n  if (isDispatching) &#123;\n    throw new Error(&#39;Reducers may not dispatch actions.&#39;)\n  &#125;\n\n  try &#123;\n    isDispatching &#x3D; true\n    currentState &#x3D; currentReducer(currentState, action) &#x2F;&#x2F; 传入当前状态和操作，返回新的状态\n  &#125; finally &#123;\n    isDispatching &#x3D; false\n  &#125;\n\n  const listeners &#x3D; (currentListeners &#x3D; nextListeners) &#x2F;&#x2F; 触发更新\n  for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;\n    const listener &#x3D; listeners[i]\n    listener()\n  &#125;\n\n  return action\n&#125;\ncombineReducers\n使用时候以键值对形式存在\n\n使用\nimport useInfoReducer from &#39;.&#x2F;userInfo&#39;\nimport recordReducer from &#39;.&#x2F;record&#39;\n\nconst rootReducer &#x3D; combineReducers(&#123;\n  useInfoReducer,\n  recordReducer\n&#125;)\n\nconst store &#x3D; createStore(rootReducer)\n\n源码\n\n返回不期望的state型警告信息\n\nfunction getUnexpectedStateShapeWarningMessage(\n  inputState: object,\n  reducers: ReducersMapObject,\n  action: Action,\n  unexpectedKeyCache: &#123; [key: string]: true &#125;\n) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers)\n  const argumentName &#x3D;\n    action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.INIT\n      ? &#39;preloadedState argument passed to createStore&#39;\n      : &#39;previous state received by the reducer&#39;\n\n  if (reducerKeys.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return (\n      &#39;Store does not have a valid reducer. Make sure the argument passed &#39; +\n      &#39;to combineReducers is an object whose values are reducers.&#39;\n    )\n  &#125;\n\n  if (!isPlainObject(inputState)) &#123;\n    return (\n      &#96;The $&#123;argumentName&#125; has unexpected type of &quot;$&#123;kindOf(\n        inputState\n      )&#125;&quot;. Expected argument to be an object with the following &#96; +\n      &#96;keys: &quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;&#96;\n    )\n  &#125;\n\n  const unexpectedKeys &#x3D; Object.keys(inputState).filter(\n    key &#x3D;&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach(key &#x3D;&gt; &#123;\n    unexpectedKeyCache[key] &#x3D; true\n  &#125;)\n\n  if (action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.REPLACE) return\n\n  if (unexpectedKeys.length &gt; 0) &#123;\n    return (\n      &#96;Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &#39;keys&#39; : &#39;key&#39;&#125; &#96; +\n      &#96;&quot;$&#123;unexpectedKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot; found in $&#123;argumentName&#125;. &#96; +\n      &#96;Expected to find one of the known reducer keys instead: &#96; +\n      &#96;&quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;. Unexpected keys will be ignored.&#96;\n    )\n  &#125;\n&#125;\n &#x2F;&#x2F; 对 reducer型进行断言\nfunction assertReducerShape(reducers: ReducersMapObject) &#123;\n  Object.keys(reducers).forEach(key &#x3D;&gt; &#123;\n    const reducer &#x3D; reducers[key]\n    const initialState &#x3D; reducer(undefined, &#123; type: ActionTypes.INIT &#125;)\n\n    if (typeof initialState &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n      throw new Error(\n         &#x2F;&#x2F; 初始化initialState时候可以用null,但是不可以用undefined\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined during initialization. &#96; +\n          &#96;If the state passed to the reducer is undefined, you must &#96; +\n          &#96;explicitly return the initial state. The initial state may &#96; +\n          &#96;not be undefined. If you don&#39;t want to set a value for this reducer, &#96; +\n          &#96;you can use null instead of undefined.&#96;\n      )\n    &#125;\n\n    if (\n      typeof reducer(undefined, &#123;\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      &#125;) &#x3D;&#x3D;&#x3D; &#39;undefined&#39;\n    ) &#123;\n      throw new Error( \n        &#x2F;&#x2F; 1.随机类型&#x2F; redux&#x2F;*类型 的操作类型为redux私有，不允许使用 \n        &#x2F;&#x2F; 2.初始化状态不可以是undefined, \n        &#x2F;&#x2F; 3.新状态如果是undefined的，必须返回初始状态\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. &#96; +\n          &#96;Don&#39;t try to handle &#39;$&#123;ActionTypes.INIT&#125;&#39; or other actions in &quot;redux&#x2F;*&quot; &#96; +\n          &#96;namespace. They are considered private. Instead, you must return the &#96; +\n          &#96;current state for any unknown actions, unless it is undefined, &#96; +\n          &#96;in which case you must return the initial state, regardless of the &#96; +\n          &#96;action type. The initial state may not be undefined, but can be null.&#96;\n      )\n    &#125;\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; combineReducers的实现，其实就是将多个值，合并在一个对象中\nexport default function combineReducers(reducers: ReducersMapObject) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers)\n  const finalReducers: ReducersMapObject &#x3D; &#123;&#125;\n  for (let i &#x3D; 0; i &lt; reducerKeys.length; i++) &#123;\n    const key &#x3D; reducerKeys[i]\n\n    if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n      finalReducers[key] &#x3D; reducers[key]\n    &#125;\n  &#125;\n  const finalReducerKeys &#x3D; Object.keys(finalReducers)\n\n  &#x2F;&#x2F; This is used to make sure we don&#39;t warn about the same\n  &#x2F;&#x2F; keys multiple times.\n  &#x2F;&#x2F;这用于确保我们不会多次警告相同的key。\n  let unexpectedKeyCache: &#123; [key: string]: true &#125;\n\n  return function combination(\n    state: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;,\n    action: AnyAction\n  ) &#123;\n    &#x2F;&#x2F;校验信息...\n\n    let hasChanged &#x3D; false\n    const nextState: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;\n    for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;\n      const key &#x3D; finalReducerKeys[i]\n      &#x2F;&#x2F; reducer\n      const reducer &#x3D; finalReducers[key]\n      &#x2F;&#x2F; 之前状态\n      const previousStateForKey &#x3D; state[key]\n      &#x2F;&#x2F; 新状态\n      const nextStateForKey &#x3D; reducer(previousStateForKey, action)\n\n\n\n      if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n        const actionType &#x3D; action &amp;&amp; action.type\n        throw new Error(\n          &#96;When called with an action of type $&#123;\n            actionType ? &#96;&quot;$&#123;String(actionType)&#125;&quot;&#96; : &#39;(unknown type)&#39;\n          &#125;, the slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined. &#96; +\n            &#96;To ignore an action, you must explicitly return the previous state. &#96; +\n            &#96;If you want this reducer to hold no value, you can return null instead of undefined.&#96;\n        )\n      &#125;\n      nextState[key] &#x3D; nextStateForKey\n      &#x2F;&#x2F; 判断是否发生更新\n      hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey\n    &#125;\n    hasChanged &#x3D;\n      hasChanged || finalReducerKeys.length !&#x3D;&#x3D; Object.keys(state).length\n      &#x2F;&#x2F; 更新返回新的状态，否则返回之前状态\n    return hasChanged ? nextState : state\n  &#125;\n&#125;\n\n\nbindActionCreators\n给action包裹层dispatch\naction有两种类型： 函数、键值对\n\nexport default function bindActionCreators(\n  actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject,\n  dispatch: Dispatch\n) &#123;\n  &#x2F;&#x2F; 函数类型直接bindActionCreator返回\n  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return bindActionCreator(actionCreators, dispatch)\n  &#125;\n\n  if (typeof actionCreators !&#x3D;&#x3D; &#39;object&#39; || actionCreators &#x3D;&#x3D;&#x3D; null) &#123;\n    throw new Error(\n      &#96;bindActionCreators expected an object or a function, but instead received: &#39;$&#123;kindOf(\n        actionCreators\n      )&#125;&#39;. &#96; +\n        &#96;Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?&#96;\n    )\n  &#125;\n\n  const boundActionCreators: ActionCreatorsMapObject &#x3D; &#123;&#125;\n  &#x2F;&#x2F; 对象遍历调用bindActionCreator\n  for (const key in actionCreators) &#123;\n    const actionCreator &#x3D; actionCreators[key]\n    if (typeof actionCreator &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n      boundActionCreators[key] &#x3D; bindActionCreator(actionCreator, dispatch)\n    &#125;\n  &#125;\n  return boundActionCreators\n&#125;\n使用及测试代码见\nredux/test/typescript/actionCreators.ts\nbindActionCreator\n&#x2F;&#x2F; 作用是每个actionCreator增加一个dispatch包裹\nfunction bindActionCreator&lt;A extends AnyAction &#x3D; AnyAction&gt;(\n  actionCreator: ActionCreator&lt;A&gt;,\n  dispatch: Dispatch\n) &#123;\n  return function (this: any, ...args: any[]) &#123;\n    return dispatch(actionCreator.apply(this, args)) &#x2F;&#x2F; 主要代码\n  &#125;\n&#125;\n\n\n\n\napplyMiddleware\n中间件\n对store能力进行增强\n\nexport default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer&lt;any&gt; &#123;\n  return (createStore: StoreEnhancerStoreCreator) &#x3D;&gt;\n    &lt;S, A extends AnyAction&gt;(\n      reducer: Reducer&lt;S, A&gt;,\n      preloadedState?: PreloadedState&lt;S&gt;\n    ) &#x3D;&gt; &#123;\n      const store &#x3D; createStore(reducer, preloadedState)\n\n\n      &#x2F;&#x2F; 声明\n      let dispatch: Dispatch &#x3D; () &#x3D;&gt; &#123;\n        throw new Error(\n          &#39;Dispatching while constructing your middleware is not allowed. &#39; +\n            &#39;Other middleware would not be applied to this dispatch.&#39;\n        )\n      &#125;\n\n      const middlewareAPI: MiddlewareAPI &#x3D; &#123;\n        getState: store.getState,\n                                      &#x2F;&#x2F;使用上述函数进行\n        dispatch: (action, ...args) &#x3D;&gt; dispatch(action, ...args)\n      &#125;\n      &#x2F;&#x2F; 中间件数组\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n\n\n      &#x2F;&#x2F; 增强的是dispatch\n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;\n\n\n&#96;&#96;&#96;ts\n\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n      \n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;\n\ncompose\n洋葱模型\n\n使用\ncompose(f, g, h)\n(...args) &#x3D;&gt; f(g(h(...args)))\n\n源码\nexport default function compose(...funcs: Function[]) &#123;\n  &#x2F;&#x2F; 参数长度判断\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line\n    return &lt;T&gt;(arg: T) &#x3D;&gt; arg\n  &#125;\n  &#x2F;&#x2F; 长度为1\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0]\n  &#125;\n  &#x2F;&#x2F; 主要代码一行\n  return funcs.reduce((a, b) &#x3D;&gt; (...args: any) &#x3D;&gt;  a(b(...args)))\n&#125;\n\n讲compose的文章\n这里有一篇非常好\n__DO_NOT_USE__ActionTypes\n一些私有的action被redux保留，对于不明确的action，必须返回当前state.\n如果当前状态是undefined,必须返回初始状态\n不要在代码中直接涉及这些action\n\nconst ActionTypes &#x3D; &#123;\n  INIT: &#96;@@redux&#x2F;INIT$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  REPLACE: &#96;@@redux&#x2F;REPLACE$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  PROBE_UNKNOWN_ACTION: () &#x3D;&gt; &#96;@@redux&#x2F;PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;&#96;\n&#125;\n\n\n总结\n\n回顾\n巩固\n参考最精简的Redux源码解析，看完从此再也不怕面试官Redux 源码解析github 源码\n","slug":"2022-05-25.redux2","date":"2022-05-25T13:32:54.000Z","categories_index":"redux","tags_index":"redux,源码","author_index":"陈海龙"},{"id":"af1b42282a210ca45f834a49b50349c6","title":"redux 源码 1","content":"介绍A Predictable State Container for JS Apps\npackage.json&#123;\n  &quot;name&quot;: &quot;redux&quot;,\n  &quot;version&quot;: &quot;5.0.0-alpha.0&quot;,\n  &quot;description&quot;: &quot;Predictable state container for JavaScript apps&quot;,\n\n\n  &quot;keywords&quot;: [\n    &quot;redux&quot;,\n    &quot;reducer&quot;,  &#x2F;&#x2F; reducer, redux构成组成之一\n    &quot;state&quot;,    &#x2F;&#x2F; 状态管理\n    &quot;predictable&quot;,   &#x2F;&#x2F; 可预测的\n    &quot;functional&quot;,    &#x2F;&#x2F; 纯函数的\n    &quot;immutable&quot;,     &#x2F;&#x2F; 不可变的\n    &quot;hot&quot;,\n    &quot;live&quot;,\n    &quot;replay&quot;,        &#x2F;&#x2F; 回放\n    &quot;flux&quot;,          &#x2F;&#x2F; redux对flux的改进\n    &quot;elm&quot;            &#x2F;&#x2F; Elm 是一门专注于Web前端的纯函数式语言, reducer受elm启发\n  ],\n\n\n  &#x2F;&#x2F; 入口\n  &quot;main&quot;: &quot;lib&#x2F;redux.js&quot;,\n\n\n  &#x2F;&#x2F; unpkg 是一个内容源自 npm 的全球快速 CDN, 它能以快速而简单的方式提供任意包、任意文件，通过类似这样的 URL ：unpkg.com&#x2F;:package@:version&#x2F;:file\n  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.3&#x2F;dist&#x2F;redux.min.js 是对应redux@4.0.3版本的压缩后的js文件\n  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux ——根据package.json配置的unpkg, 重定向为--—&gt; https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.4&#x2F;dist&#x2F;redux.js , 做了两次重定向\n  &#x2F;&#x2F; 如何你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux&#x2F; (注意redux后有&#x2F;), 是一个页面\n  &quot;unpkg&quot;: &quot;dist&#x2F;redux.js&quot;, &#x2F;&#x2F; 用unpkg的裸url访问时, 指定到该文件\n\n\n  &#x2F;**\n    module\n      点击 Setting up multi-platform npm packages 查看相关介绍。\n\n      就像 main 字段一样，定义一个针对 es6 模块及语法的入口文件。\n\n      构建工具在构建项目的时候，如果发现了这个字段，会首先使用这个字段指向的文件，如果未定义，则回退到 main 字段指向的文件。\n\n      支持的工具：\n\n      rollup\n      webpack\n  **&#x2F;\n  &quot;module&quot;: &quot;es&#x2F;redux.js&quot;,\n\n\n\n&#x2F;&#x2F; TypeScript是javascript 的超集, typings&#x2F;types字段, 定义了TypeScript的入口文件\n  &quot;types&quot;: &quot;types&#x2F;index.d.ts&quot;,\n\n\n\n  &#x2F;&#x2F; 发布上传内容\n  &#x2F;&#x2F; 是一个可选字段, 用来描述作将软件包作为依赖项安装时要包含的条目, 相当于白名单, 类似.gitignore类似的语法, files字段中包含的文件不能通过.npmignore或.gitignore排除\n  &quot;files&quot;: [\n    &quot;dist&quot;,\n    &quot;lib&quot;,\n    &quot;es&quot;,\n    &quot;src&quot;,\n    &quot;types&quot;\n  ],\n  &quot;scripts&quot;: &#123;\n    ...\n  &#125;,\n  &#x2F;&#x2F; 表示在生产环境下使用该依赖, 对应 npm install xx -S 或 npm install xx --save\n  &quot;dependencies&quot;: &#123;\n    &quot;@babel&#x2F;runtime&quot;: &quot;^7.16.7&quot;\n  &#125;,\n  &#x2F;&#x2F; 表示仅在开发环境下使用, 不会在生产环境中使用的依赖, 对应 npm install xx -D 或 npm install xx --save-dev\n  &quot;devDependencies&quot;: &#123;\n   ...\n  &#125;,\n  &quot;npmName&quot;: &quot;redux&quot;,\n\n\n  &#x2F;&#x2F; npm文件映射。把需要同步到 cdnjs 的文件配置在这里。\n  &quot;npmFileMap&quot;: [\n    &#123;\n      &quot;basePath&quot;: &quot;&#x2F;dist&#x2F;&quot;,\n      &quot;files&quot;: [\n        &quot;*.js&quot;\n      ]\n    &#125;\n  ],\n\n  &#x2F;&#x2F; webpack相关字段, 声明该模块是否包含 sideEffects（副作用），从而可以为 tree-shaking 提供更大的优化空间。\n  &quot;sideEffects&quot;: false\n&#125;\n\nversion字段包的版本, 必须有, 要符合semantic versioning guidelines, 参考 语义化版本控制规范, 建议仔细通读\n参考配合redux项目深度了解package.jsonsemantic versioning guidelines语义化版本控制规范\n源码目录.\n├── applyMiddleware.ts\n├── bindActionCreators.ts\n├── combineReducers.ts\n├── compose.ts\n├── createStore.ts\n├── index.ts\n├── types\n│   ├── actions.ts\n│   ├── middleware.ts\n│   ├── reducers.ts\n│   └── store.ts\n└── utils\n    ├── actionTypes.ts\n    ├── formatProdErrorMessage.ts\n    ├── isPlainObject.ts\n    ├── kindOf.ts\n    ├── symbol-observable.ts\n    └── warning.ts\n\n2 directories, 16 files\n\nindex.tsexport &#123;\n  createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose,\n  __DO_NOT_USE__ActionTypes\n&#125;","slug":"2022-05-25.redux","date":"2022-05-25T05:48:17.000Z","categories_index":"redux","tags_index":"redux,源码","author_index":"陈海龙"},{"id":"d512c56f4cbf1792b4d8bab0668985ad","title":"react-redux  源码2","content":"源码版本&quot;version&quot;: &quot;8.0.2&quot;,\nProvider\n主要作用通过subscription调用redux中store的subscription产生订阅，订阅内容是onStateChange的回调\n通过react的Provider功能，提供传递给根的store和根的subscription给后续使用了connect的组件\n\n&#x2F;* provider 组件代码 *&#x2F;\nfunction Provider(&#123; store, context, children &#125;) &#123;\n   &#x2F;* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  *&#x2F; \n  const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n      &#x2F;* 创建了一个根 Subscription 订阅器 *&#x2F;\n    const subscription &#x3D; new Subscription(store)\n    &#x2F;* subscription 的 notifyNestedSubs 方法 ，赋值给  onStateChange方法 *&#x2F;\n    &#x2F;&#x2F;onStateChange就是之后触发的listenr\n    subscription.onStateChange &#x3D; subscription.notifyNestedSubs  \n    return &#123;\n      store,\n      subscription\n    &#125; &#x2F;*  store 改变创建新的contextValue *&#x2F;\n  &#125;, [store])\n  &#x2F;*  获取更新之前的state值 ，函数组件里面的上下文要优先于组件更新渲染  *&#x2F;\n  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])\n\n  useEffect(() &#x3D;&gt; &#123;\n    const &#123; subscription &#125; &#x3D; contextValue\n    &#x2F;* 触发trySubscribe方法执行，创建listens *&#x2F;\n    subscription.trySubscribe() &#x2F;&#x2F; 发起订阅\n    if (previousState !&#x3D;&#x3D; store.getState()) &#123;\n        &#x2F;* 组件更新渲染之后，如果此时state发生改变，那么立即触发 subscription.notifyNestedSubs 方法  *&#x2F;\n        &#x2F;&#x2F;触发所有的listener\n      subscription.notifyNestedSubs() \n    &#125;\n    &#x2F;*   *&#x2F;\n    return () &#x3D;&gt; &#123;\n      subscription.tryUnsubscribe()  &#x2F;&#x2F; 卸载订阅\n      subscription.onStateChange &#x3D; null\n    &#125;\n    &#x2F;*  contextValue state 改变出发新的 effect *&#x2F;\n  &#125;, [contextValue, previousState])\n\n  &#x2F;&#x2F;若Provider没有显示传入context，则为使用React.createContext创建的上下文\n  const Context &#x3D; context || ReactReduxContext\n\n  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt;\n&#125;\n\nSubscription\n订阅消息、发起更新\n在根的Provider的作用是调用redux中store的订阅方法，将根的onStateChange进行订阅\n在子代中是收集所有被 connect 包裹的组件中的Subscription的更新函数 onstatechange，然后形成一个 callback 链表，再由父级 Subscription 统一派发执行更新，只会往上传递一层，不会一直传递使得每一个上级都有自身的更新函数\n\n&#x2F;* 发布订阅者模式 *&#x2F;\nexport default class Subscription &#123;\n  constructor(store, parentSub) &#123;\n    this.store &#x3D; store\n    this.parentSub &#x3D; parentSub\n    this.unsubscribe &#x3D; null\n    this.listeners &#x3D; nullListeners\n\n    this.handleChangeWrapper &#x3D; this.handleChangeWrapper.bind(this)\n  &#125;\n  &#x2F;* 负责检测是否该组件订阅，然后添加订阅者也就是listener *&#x2F;  \n  &#x2F;&#x2F;当父代调用过trySubscribe后，子代再调用，因为this.unsubscribe有值，所以并不会实际执行父代的trySubscribe，而只是将listener放进父代中管理\n  addNestedSub(listener) &#123;\n    this.trySubscribe()\n    return this.listeners.subscribe(listener)\n  &#125;\n  &#x2F;* 向listeners发布通知 *&#x2F;\n  notifyNestedSubs() &#123;\n    this.listeners.notify()\n  &#125;\n  &#x2F;* 对于 Provide onStateChange 就是 notifyNestedSubs 方法，\n  对于 connect 包裹接受更新的组件 ，onStateChange 就是 负责更新组件的函数 。   *&#x2F;\n  handleChangeWrapper() &#123;\n    if (this.onStateChange) &#123;\n      this.onStateChange()\n    &#125;\n  &#125;\n   &#x2F;* 判断有没有开启订阅 *&#x2F;\n  isSubscribed() &#123;\n    return Boolean(this.unsubscribe)\n  &#125;\n  &#x2F;* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 *&#x2F;\n  trySubscribe() &#123;\n    &#x2F;*\n    \tparentSub即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription\n    *&#x2F;\n    &#x2F;&#x2F;当Subscription执行过一次改方法后，再调用因为this.unsubscribe有值\n    &#x2F;&#x2F;所以该方法调用一次后就不会再被调用了\n    &#x2F;&#x2F;意味着addNestedSub中只会添加listener，而不会再调用trySubscribe，使得listener不会往上传递\n    if (!this.unsubscribe) &#123;\n      this.unsubscribe &#x3D; this.parentSub\n        ? this.parentSub.addNestedSub(this.handleChangeWrapper)\n        &#x2F;* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   *&#x2F;\n        : this.store.subscribe(this.handleChangeWrapper)\n      this.listeners &#x3D; createListenerCollection()\n    &#125;\n  &#125;\n  &#x2F;* 取消订阅 *&#x2F;\n  tryUnsubscribe() &#123;\n    if (this.unsubscribe) &#123;\n      this.unsubscribe()\n      this.unsubscribe &#x3D; null\n      this.listeners.clear()\n\n      this.listeners &#x3D; nullListeners\n    &#125;\n  &#125;\n&#125;\n\n\n\n首先Provider创建 Subscription 时候没有第二个参数，就说明provider 中的Subscription 不存在 parentSub 。\n那么再调用Provider组件中useEffect钩子中trySubscribe的时候,会触发this.store.subscribe , subscribe 就是 redux 的 subscribe ,此时真正发起了订阅\n订阅的内容是notifyNestedSubs，即通知根管理的listeners触发subscription.onStateChange &#x3D; subscription.notifyNestedSubs \n\n&#x2F;* 向listeners发布通知 *&#x2F;\nnotifyNestedSubs() &#123;\n  this.listeners.notify()\n&#125;\n\ncreateListenerCollection通过双向链表的结构管理每一个listener以链表的形式收集对应的 listeners (每一个Subscription) 的handleChangeWrapper函数即onStateChange。通过 batch 方法( react-dom 中的 unstable_batchedUpdates ) 来进行批量更新，许将一次事件循环中的所有 React 更新都一起批量处理到一个渲染过程中。import &#123; unstable_batchedUpdates as batch &#125; from &#39;.&#x2F;utils&#x2F;reactBatchedUpdates&#39;\nsetBatch(batch)\n\n\nfunction createListenerCollection() &#123;\n   &#x2F;* batch 由getBatch得到的 unstable_batchedUpdates 方法 *&#x2F;\n  const batch &#x3D; getBatch()\n  let first &#x3D; null\n  let last &#x3D; null\n\n  return &#123;\n    &#x2F;* 清除当前listeners的所有listener *&#x2F;\n    clear() &#123;\n      first &#x3D; null\n      last &#x3D; null\n    &#125;,\n    &#x2F;* 派发更新 *&#x2F;\n    notify() &#123;\n      batch(() &#x3D;&gt; &#123;\n        let listener &#x3D; first\n        while (listener) &#123;\n          listener.callback()\n          listener &#x3D; listener.next\n        &#125;\n      &#125;)\n    &#125;,\n    &#x2F;* 获取listeners的所有listener *&#x2F;\n    get() &#123;\n      let listeners &#x3D; []\n      let listener &#x3D; first\n      while (listener) &#123;\n        listeners.push(listener)\n        listener &#x3D; listener.next\n      &#125;\n      return listeners\n    &#125;,\n     &#x2F;* 接收订阅，将当前的callback（handleChangeWrapper）存到当前的链表中  *&#x2F;\n    subscribe(callback) &#123;\n      let isSubscribed &#x3D; true\n\n      let listener &#x3D; (last &#x3D; &#123;\n        callback,\n        next: null,\n        prev: last &#x2F;&#x2F;首次last为空\n      &#125;)\n\t   \t\n      if (listener.prev) &#123;\n        listener.prev.next &#x3D; listener\n      &#125; else &#123;\n        first &#x3D; listener\n      &#125;\n      &#x2F;* 取消当前 handleChangeWrapper 的订阅*&#x2F;\n      return function unsubscribe() &#123;\n        if (!isSubscribed || first &#x3D;&#x3D;&#x3D; null) return\n        isSubscribed &#x3D; false\n\t\t\n\t\t&#x2F;&#x2F;双向链表删除节点的操作\n        if (listener.next) &#123;\n          listener.next.prev &#x3D; listener.prev\n        &#125; else &#123;\n          last &#x3D; listener.prev\n        &#125;\n        if (listener.prev) &#123;\n          listener.prev.next &#x3D; listener.next\n        &#125; else &#123;\n          first &#x3D; listener.next\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nconnect基本使用function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)\n\nconst mapStateToProps &#x3D; state &#x3D;&gt; (&#123; todos: state.todos &#125;)\nconst mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;\n  return &#123;\n    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),\n    decrement: () &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;),\n    reset: () &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39; &#125;)\n  &#125;\n&#125;\n&#x2F;*\n* stateProps , state 映射到 props 中的内容\n* dispatchProps， dispatch 映射到 props 中的内容。\n* ownProps 组件本身的 props\n当未传递时，默认的合并规则为\n&#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n\n*&#x2F;\nmergeProps&#x3D;(stateProps, dispatchProps, ownProps) &#x3D;&gt; Object\n\noptions&#x3D;&#123;\n  context?: Object,   &#x2F;&#x2F; 自定义上下文\n  pure?: boolean, &#x2F;&#x2F; 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。\n  areStatesEqual?: Function, &#x2F;&#x2F; 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean\n  areOwnPropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean\n  areStatePropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) &#x3D;&gt; boolean\n  areMergedPropsEqual?: Function, &#x2F;&#x2F; 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) &#x3D;&gt; boolean\n  forwardRef?: boolean, &#x2F;&#x2F;当为true 时候,可以通过ref 获取被connect包裹的组件实例。\n&#125;\n\n\n\n&#x2F;**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior &#x2F; props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that&#39;s\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don&#39;t know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user&#39;s responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps A function that extracts values from state\n * @param mapDispatchToProps Setup for dispatching actions\n * @param mergeProps Optional callback to merge state and dispatch props together\n * @param options Options for configuring the connection\n *\n *&#x2F;\nfunction connect&lt;\n  TStateProps &#x3D; &#123;&#125;,\n  TDispatchProps &#x3D; &#123;&#125;,\n  TOwnProps &#x3D; &#123;&#125;,\n  TMergedProps &#x3D; &#123;&#125;,\n  State &#x3D; unknown\n&gt;(\n  mapStateToProps?: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;,\n  mapDispatchToProps?: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;,\n  mergeProps?: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;,\n  &#123;\n    &#x2F;&#x2F; The &#96;pure&#96; option has been removed, so TS doesn&#39;t like us destructuring this to check its existence.\n    &#x2F;&#x2F; @ts-ignore\n    pure,\n    areStatesEqual &#x3D; strictEqual,\n    areOwnPropsEqual &#x3D; shallowEqual,\n    areStatePropsEqual &#x3D; shallowEqual,\n    areMergedPropsEqual &#x3D; shallowEqual,\n\n    &#x2F;&#x2F; use React&#39;s forwardRef to expose a ref of the wrapped component\n    forwardRef &#x3D; false,\n\n    &#x2F;&#x2F; the context consumer to use\n    context &#x3D; ReactReduxContext,\n  &#125;: ConnectOptions&lt;unknown, unknown, unknown, unknown&gt; &#x3D; &#123;&#125;\n): unknown &#123;\n  \n\n  const Context &#x3D; context\n\n  &#x2F;*\n  * stateProps , state 映射到 props 中的内容\n  * dispatchProps， dispatch 映射到 props 中的内容。\n  * ownProps 组件本身的 props\n  当未传递时，默认的合并规则为\n  &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n\n  *&#x2F;\n &#x2F;* 经过代理包装后的 mapStateToProps,完成传入store等操作*&#x2F;\n  const initMapStateToProps &#x3D; mapStateToPropsFactory(mapStateToProps)\n  &#x2F;* 经过代理包装后的 mapDispatchToProps，完成传入store.dispatch等操作*&#x2F;\n  const initMapDispatchToProps &#x3D; mapDispatchToPropsFactory(mapDispatchToProps)\n  &#x2F;* 经过代理包装后的 mergeProps，用于形成真正的 mergeProps函数，合并业务组件的 props , state 映射的 props , dispatch 映射的 props *&#x2F;\n  const initMergeProps &#x3D; mergePropsFactory(mergeProps)\n\n  const shouldHandleStateChanges &#x3D; Boolean(mapStateToProps)\n\n  &#x2F;&#x2F;默认的高阶组件connectAdvanced，实际渲染的组件是其中返回的一个ConnectFunction\n\t&#x2F;&#x2F;selectorFactory为整合connect更新过程中的形成新props的主要函数\n\t&#x2F;&#x2F;selectorFactory为后面的finalPropsSelectorFactory\n  const wrapWithConnect: AdvancedComponentDecorator&lt;\n    TOwnProps,\n    WrappedComponentProps\n  &gt; &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n    ...\n  &#125;\n&#125;\n\n\n当我们不向connect传递第三个参数mergeProps 的时候，默认的defaultMergeProps如下，作为新的 props 传递给了业务组件\n\nexport function defaultMergeProps(stateProps, dispatchProps, ownProps) &#123;\n  return &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n&#125;\n\n\n\nselectorFactory\n\n首先得到真正connect 经过一层代理函数 mapStateToProps ,mapDispatchToProps ,mergeProps\n然后调用selectorFactory (在pure模式下，selectorFactory 就是 pureFinalPropsSelectorFactory )export default function finalPropsSelectorFactory(\n  dispatch,\n  &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options &#125;\n) &#123;\n  &#x2F;&#x2F; mapStateToProps mapDispatchToProps mergeProps 为真正connect 经过一层代理的 proxy 函数\n  const mapStateToProps &#x3D; initMapStateToProps(dispatch, options)\n  const mapDispatchToProps &#x3D; initMapDispatchToProps(dispatch, options)\n  const mergeProps &#x3D; initMergeProps(dispatch, options)\n\n  &#x2F;&#x2F;默认pure为true，selectorFactory默认为pureFinalPropsSelectorFactory\n  const selectorFactory &#x3D; options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory\n   &#x2F;&#x2F; 返回一个 函数用于生成新的 props \n  return selectorFactory(\n    mapStateToProps,\n    mapDispatchToProps,\n    mergeProps,\n    dispatch,\n    options\n  )\n&#125;\n\n\npureFinalPropsSelectorFactory\n\n如果是第一次，那么直接调用mergeProps合并ownProps,stateProps,dispatchProps 形成最终的props。\n如果不是第一次，那么判断到底是props还是 store.state 发生改变，然后针对那里变化，重新生成对应的props，最终合并到真正的props\n整个 selectorFactory 逻辑就是形成新的props传递给我们的业务组件。\n\n&#x2F;** pure组件处理 ， 对比 props 是否发生变化 然后 合并props *&#x2F;\nexport function pureFinalPropsSelectorFactory(\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  dispatch,\n  &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125; &#x2F;&#x2F;判断 state prop 是否相等\n) &#123;\n  let hasRunAtLeastOnce &#x3D; false\n  let state\n  let ownProps\n  let stateProps\n  let dispatchProps\n  let mergedProps\n \n  &#x2F;* 第一次 直接形成 ownProps  stateProps  dispatchProps 合并  形成新的 props *&#x2F;\n  function handleFirstCall(firstState, firstOwnProps) &#123;\n    state &#x3D; firstState\n    ownProps &#x3D; firstOwnProps\n    &#x2F;&#x2F;获取业务组件中mapStateToProps函数的返回值\n    stateProps &#x3D; mapStateToProps(state, ownProps)\n    &#x2F;&#x2F;获取业务组件中mapDispatchToProps函数的返回值\n    dispatchProps &#x3D; mapDispatchToProps(dispatch, ownProps)\n    &#x2F;&#x2F;合并state、dispatch、组件自身的props，形成最终传递给组件的props\n    mergedProps &#x3D; mergeProps(stateProps, dispatchProps, ownProps)\n    hasRunAtLeastOnce &#x3D; true\n    return mergedProps\n  &#125;\n  \n  function handleNewPropsAndNewState() &#123;\n    &#x2F;&#x2F;  props 和 state 都改变  mergeProps \n  &#125;\n\n  function handleNewProps() &#123;\n    &#x2F;&#x2F; props 改变  mergeProps\n  &#125;\n\n  function handleNewState() &#123;\n     &#x2F;&#x2F; state 改变 mergeProps\n  &#125;\n\n  &#x2F;*  不是第一次的情况 props 或者 store.state 发生改变的情况。 *&#x2F;\n  function handleSubsequentCalls(nextState, nextOwnProps) &#123;\n      &#x2F;* 判断两次 props 是否相等 *&#x2F;\n    const propsChanged &#x3D; !areOwnPropsEqual(nextOwnProps, ownProps) \n      &#x2F;* 判断两次 store.state 是否相等 *&#x2F;\n    const stateChanged &#x3D; !areStatesEqual(nextState, state)\n    state &#x3D; nextState\n    ownProps &#x3D; nextOwnProps\n    \n    &#x2F;&#x2F;根据改变的类型不同，返回对应合并策略下的props\n    if (propsChanged &amp;&amp; stateChanged) return handleNewPropsAndNewState()\n    if (propsChanged) return handleNewProps()\n    if (stateChanged) return handleNewState()\n    return mergedProps\n  &#125;\n  \n  &#x2F;&#x2F;根据是否第一次形成props，执行对应方法\n  return function pureFinalPropsSelector(nextState, nextOwnProps) &#123;\n    return hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  &#125;\n&#125;\n\nconnectHOCconst mapStateToProp &#x3D; (store) &#x3D;&gt; (&#123; userInfo: store.root.userInfo &#125;)\n\nfunction Index()&#123;\n    &#x2F;* ..... *&#x2F;\n    return &lt;div&gt; &#123; &#x2F;* .... *&#x2F; &#125; &lt;&#x2F;div&gt;\n&#125;\nexport default connect(mapStateToProp)(Index)\n\n\n\nconnect(mapStateToProp)&#x3D;&#x3D;&#x3D;connectAdvanced()\n\n\n点击查看更多\n\n这部分代码，在8.x.x版本在conncet中直接处理，并没有拆分为单独函数\n\nexport default function connectAdvanced(\n  selectorFactory, &#x2F;&#x2F; 每次 props,state改变执行 ，用于生成新的 props。\n  &#123;\n    getDisplayName &#x3D; name &#x3D;&gt; &#96;ConnectAdvanced($&#123;name&#125;)&#96;,\n    &#x2F;&#x2F;可能被包装函数（如connect（））重写\n    methodName &#x3D; &#39;connectAdvanced&#39;,\n    &#x2F;&#x2F;如果定义了，则传递给包装元素的属性的名称，指示要呈现的调用。用于监视react devtools中不必要的重新渲染。\n    renderCountProp &#x3D; undefined,\n    shouldHandleStateChanges &#x3D; true,  &#x2F;&#x2F;确定此HOC是否订阅存储更改\n    storeKey &#x3D; &#39;store&#39;,\n    withRef &#x3D; false,\n    forwardRef &#x3D; false, &#x2F;&#x2F; 是否 用 forwarRef 模式\n    context &#x3D; ReactReduxContext,&#x2F;&#x2F; Provider 保存的上下文\n    ...connectOptions\n  &#125; &#x3D; &#123;&#125;\n) &#123;\n  &#x2F;* ReactReduxContext 就是store存在的context *&#x2F;\n  const Context &#x3D; context\n   &#x2F;* WrappedComponent 为connect 包裹的组件本身  *&#x2F;   \n  return  function wrapWithConnect(WrappedComponent)&#123;\n      &#x2F;&#x2F; WrappedComponent 被 connect 的业务组件本身\n  &#125;\n&#125;\n\n拿到Provider提供的context上下文\n\n\n\nwrapWithConnectwrapWithConnect作为高阶组件，会返回一个组件，这个组件会对原有的业务组件，进行一系列增强等工作判断是否是 pure 纯组件模式，如果是用react.memo包裹,这样做的好处是，会向 pureComponent 一样对 props 进行浅比较如果 connect 有forwardRef配置项，用React.forwardRef处理\nfunction wrapWithConnect(WrappedComponent) &#123;\n\t&#x2F;&#x2F;WrappedComponent为实际传递的业务组件\n    const wrappedComponentName &#x3D;\n      WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;\n  \n    const displayName &#x3D; getDisplayName(wrappedComponentName)\n    \n    &#x2F;&#x2F;要合并都内容，connectOptions为上一步闭包拿到的内容\n    const selectorFactoryOptions &#x3D; &#123;\n      ...connectOptions,\n      getDisplayName,\n      methodName,\n      renderCountProp,\n      shouldHandleStateChanges,\n      storeKey,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent\n    &#125;\n    const &#123; pure &#125; &#x3D; connectOptions\n    \n    &#x2F;&#x2F;selectorFactory为finalPropsSelectorFactory\n    function createChildSelector(store) &#123;\n      &#x2F;&#x2F; 合并函数 mergeprops 得到最新的props\n      &#x2F;&#x2F; 及默认返回pureFinalPropsSelectorFactory，会根据是否第一次合并、修改类型等进行不同策略等合并以及返回最终都props\n      return selectorFactory(store.dispatch, selectorFactoryOptions)\n    &#125;\n    &#x2F;&#x2F;判断是否是pure纯组件模式 如果是将用 useMemo 缓存组件提升性能\n    const usePureOnlyMemo &#x3D; pure ? useMemo : callback &#x3D;&gt; callback()\n    &#x2F;&#x2F; 负责更新的容器子组件，可以看作是实际渲染的类组件\n    function ConnectFunction (props)&#123;\n        &#x2F;&#x2F; props 为 业务组件 真正的 props \n    &#125;\n    &#x2F;&#x2F;如果\n    const Connect &#x3D; pure ? React.memo(ConnectFunction) : ConnectFunction\n  \n    Connect.WrappedComponent &#x3D; WrappedComponent\n    Connect.displayName &#x3D; displayName\n    &#x2F;* forwardRef *&#x2F;\n    if (forwardRef) &#123;\n      const forwarded &#x3D; React.forwardRef(function forwardConnectRef(\n        props,\n        ref\n      ) &#123;\n      \t&#x2F;&#x2F;connect中是否传递了forwardRef选项\n        return &lt;Connect &#123;...props&#125; reactReduxForwardedRef&#x3D;&#123;ref&#125; &#x2F;&gt;\n      &#125;)\n  \n      forwarded.displayName &#x3D; displayName\n      forwarded.WrappedComponent &#x3D; WrappedComponent\n      &#x2F;&#x2F;hoistStatics为一个第三方库，负责把一个类中的静态属性拷贝到另一个类中\n      return hoistStatics(forwarded, WrappedComponent)\n    &#125;\n  \n    return hoistStatics(Connect, WrappedComponent)\n  &#125;\n&#125;\n\n为何要传递forwardRef？connect(mapStateToProp,mapDispatchToProps,mergeProps,&#123; forwardRef:true  &#125;)(Child)\n\n如果不传递，而是在其他组件中直接放ref到使用了connect的组件，则ref实际应用到的是ConncectFunction组件，而非真正的WrappedComponent组件所以react-redux提供forwardRef选项，使用React.forwardRef，将ref实际放到真正的WrappedComponent上\nConnectFunction\n实际渲染的组件\nfunction ConnectFunction(props) &#123;\n    &#x2F;* TODO:  第一步 把 context ForwardedRef props 取出来 *&#x2F;\n    &#x2F;&#x2F;取出forwardRef和传递给ConnectFunction的所有除forwardRef的props\n    &#x2F;&#x2F;除了forwardRef以外的props也就是实际业务代码中传递给conncec包裹组件都props\n    const [\n      reactReduxForwardedRef,\n      wrapperProps &#x2F;&#x2F; props 传递的props\n    ] &#x3D; useMemo(() &#x3D;&gt; &#123;\n      const &#123; reactReduxForwardedRef, ...wrapperProps &#125; &#x3D; props\n      return [reactReduxForwardedRef, wrapperProps]\n    &#125;, [props])\n \n\t  &#x2F;&#x2F; 获取上层Provider提供的context，多个Provider只会取最近的Provider\n    &#x2F;&#x2F; 获取 context内容 里面含有  redux 中store 和 subscription\n    const contextValue &#x3D; useContext(Context)\n\n    &#x2F;&#x2F;TODO: 判断 store 是否来自props  didStoreComeFromProps ,正常情况下 ，prop 中是不存在 store 所以  didStoreComeFromProps &#x3D; false\n    const didStoreComeFromProps &#x3D;\n      Boolean(props.store) &amp;&amp;\n      Boolean(props.store.getState) &amp;&amp;\n      Boolean(props.store.dispatch)\n    &#x2F;&#x2F;store是否来自Provider提供的上下文\n    const didStoreComeFromContext &#x3D;\n      Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)\n\n    &#x2F;&#x2F;根据两种情况获取store\n    const store &#x3D; didStoreComeFromProps ? props.store : contextValue.store\n     \n     &#x2F;&#x2F;返回merge函数 用于生成真正传给子组件 props\n    const childPropsSelector &#x3D; useMemo(() &#x3D;&gt; &#123;\n    \t&#x2F;&#x2F;默认情况下pure为true，返回的是pureFinalPropsSelectorFactory\n      return createChildSelector(store)\n    &#125;, [store])\n\n\n    &#x2F;&#x2F; TODO:  第二步  创建connect组件自身的subscription 监听者实例  \n    const [subscription, notifyNestedSubs] &#x3D; useMemo(() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 如果没有订阅更新，那么直接返回，默认情况下开启了订阅\n      if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY\n\t\t&#x2F;&#x2F;为每一个conncet的组件创建订阅器，获取上层Provider提供的contextValue.subscription\n\t\t&#x2F;&#x2F;connct的组件获取的是上层的Provder提供的subscription，有多个Provider，只会取层级最近的一个\n\t\t&#x2F;&#x2F;所以connect中的connect组件，获取到的是离它最近的Provider中的订阅器，通过它来管理自身的listener更新函数\n      const subscription &#x3D; new Subscription(\n        store,\n        didStoreComeFromProps ? null : contextValue.subscription &#x2F;&#x2F; 和 上级 &#96;subscription&#96; 建立起关系。 this.parentSub &#x3D; contextValue.subscription\n      )\n      &#x2F;&#x2F; notifyNestedSubs 触发 noticy 所有子代 listener 监听者 -&gt; 触发batch方法,触发 batchupdate方法 ,批量更新\n      &#x2F;&#x2F;并更新一下this指向\n      const notifyNestedSubs &#x3D; subscription.notifyNestedSubs.bind(\n        subscription\n      )\n\n      return [subscription, notifyNestedSubs]\n    &#125;, [store, didStoreComeFromProps, contextValue])\n\n    &#x2F;*  创建出一个新的contextValue ,把父级的 subscription 换成自己的 subscription   *&#x2F;\n    const overriddenContextValue &#x3D; useMemo(() &#x3D;&gt; &#123;   \n      if (didStoreComeFromProps) &#123; \n        return contextValue\n      &#125;\n      &#x2F;&#x2F;默认情况下，返回自身的订阅器以及redux中的store给自身的子代connect中获取\n      return &#123;\n        ...contextValue,\n        subscription\n      &#125;\n    &#125;, [didStoreComeFromProps, contextValue, subscription])\n    \n    &#x2F;&#x2F;定义了一个useReducer，当actualChildProps变化时，调用dispatch方法forceComponentUpdateDispatch进行组件更新\n    const [\n      [previousStateUpdateResult], &#x2F;&#x2F;调用dispatch更新后的内容\n      forceComponentUpdateDispatch  &#x2F;*  *&#x2F;\n    ] &#x3D; useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)\n\n\n    &#x2F;&#x2F; TODO: 第三步缓存组件本次的props等内容，在下一次组件更新时做比较\n    const lastChildProps &#x3D; useRef() &#x2F;&#x2F;保存上一次 合并过的 props信息（经过 ownprops ,stateProps , dispatchProps 合并过的 ）\n    const lastWrapperProps &#x3D; useRef(wrapperProps) &#x2F;&#x2F;保存本次业务组件的 props \n    const childPropsFromStoreUpdate &#x3D; useRef() &#x2F;&#x2F;用来保存更新后的最新的props\n    const renderIsScheduled &#x3D; useRef(false) &#x2F;&#x2F; 当前组件是否处于渲染阶段\n    \n    &#x2F;&#x2F; actualChildProps 为当前真正处理过后，经过合并的 props\n    const actualChildProps &#x3D; usePureOnlyMemo(() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 调用 mergeProps 进行合并，返回合并后的最新 porps\n        &#x2F;&#x2F;及调用pureFinalPropsSelectorFactory后的合并结果\n      return childPropsSelector(store.getState(), wrapperProps)\n    \n    \t &#x2F;&#x2F;会在store、调用了checkForUpdates、传递给组建的props发生变化后，重新计算获取合并后的props \n    &#125;, [store, previousStateUpdateResult, wrapperProps])\n\n   &#x2F;* 负责更新缓存变量，方便下一次更新的时候比较 *&#x2F;\n    useEffect(()&#x3D;&gt;&#123;\n      captureWrapperProps(...[\n          lastWrapperProps,\n          lastChildProps,\n          renderIsScheduled,\n          wrapperProps,\n          actualChildProps,\n          childPropsFromStoreUpdate,\n          notifyNestedSubs\n       ])\n    &#125;)\n    \n    &#x2F;&#x2F;实际订阅更新组件的地方\n    useEffect(()&#x3D;&gt;&#123;\n        subscribeUpdates(...[\n        shouldHandleStateChanges,\n        store,\n        subscription,\n        childPropsSelector,\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs,\n        forceComponentUpdateDispatch\n       ])\n    &#125;,[store, subscription, childPropsSelector])\n\n\n\n    &#x2F;&#x2F; TODO: 第四步：渲染实际挂载的组件，通过useMemo进行组件的缓存\n    const renderedWrappedComponent &#x3D; useMemo(\n      () &#x3D;&gt; (\n        &lt;WrappedComponent\n          &#123;...actualChildProps&#125;\n          ref&#x3D;&#123;reactReduxForwardedRef&#125;\n        &#x2F;&gt;\n      ),\n      &#x2F;&#x2F;当actualChildProps发生变化的时候重新渲染组件\n      &#x2F;&#x2F;这里就是组件重新渲染的原因：主要通过监听actualChildProps的变化\n      [reactReduxForwardedRef, WrappedComponent, actualChildProps]\n    )\n    &#x2F;&#x2F; 将上一步的renderedWrappedComponent包裹一层Provider\n    &#x2F;&#x2F; 提供该connect组件自身的订阅器、store给子代中的connect组件获取\n    const renderedChild &#x3D; useMemo(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F;shouldHandleStateChanges 来源 connect是否有第一个参数\n      if (shouldHandleStateChanges) &#123;\n        return (\n          &#x2F;&#x2F; ContextToUse 传递 context \n          &lt;ContextToUse.Provider value&#x3D;&#123;overriddenContextValue&#125;&gt;\n            &#123;renderedWrappedComponent&#125;\n          &lt;&#x2F;ContextToUse.Provider&gt;\n        )\n      &#125;\n\n      return renderedWrappedComponent\n    &#125;, [ContextToUse, renderedWrappedComponent, overriddenContextValue])\n\n    return renderedChild\n  &#125;\n\n\n\n创建该connect组件自身的subscription, 并使用Provider包裹，层层传递新的context(很重要)\n\n所以connect组件的子代connect组件，获取到的都是其上层最近的connect提供的Provider中的订阅器，然后将更新函数checkForUpdates放进其中管理\n\n然后通过 useMemo 创建出一个新的 contextValue ,把父级的 subscription 换成自己的 subscription。用于通过 Provider 传递新的 context\n\n接下来通过useReducer制造出真正触发更新的forceComponentUpdateDispatch 这个dispatch函数。也就是整个 state 或者是 props改变，触发组件更新的函数，这个函数放进checkForUpdates中执行\n\n\ncaptureWrapperProps\n进行内容缓存，为了下次组件更新进行比较&#x2F;&#x2F;获取包装的props \nfunction captureWrapperProps(\n  lastWrapperProps,\n  lastChildProps,\n  renderIsScheduled,\n  wrapperProps,\n  actualChildProps,\n  childPropsFromStoreUpdate,\n  notifyNestedSubs\n) &#123;\n  lastWrapperProps.current &#x3D; wrapperProps  &#x2F;&#x2F;子props \n  lastChildProps.current &#x3D; actualChildProps &#x2F;&#x2F;经过 megeprops 之后形成的新prop\n  renderIsScheduled.current &#x3D; false  &#x2F;&#x2F; 当前组件渲染完成\n&#125;\n\n\nsubscribeUpdates\n实际添加更新回调的地方\nfunction subscribeUpdates(\n  shouldHandleStateChanges,\n  store,\n  subscription,\n  childPropsSelector,\n  lastWrapperProps,  &#x2F;&#x2F;子props \n  lastChildProps, &#x2F;&#x2F;经过 megeprops 之后形成的 prop\n  renderIsScheduled,\n  childPropsFromStoreUpdate,\n  notifyNestedSubs,\n  forceComponentUpdateDispatch\n) &#123;\n  if (!shouldHandleStateChanges) return\n\n   &#x2F;&#x2F; 捕获值以检查此组件是否卸载以及何时卸载\n  let didUnsubscribe &#x3D; false\n  let lastThrownError &#x3D; null\n   &#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调\n  const checkForUpdates &#x3D; ()&#x3D;&gt;&#123;\n      &#x2F;&#x2F;....\n  &#125;\n  &#x2F;&#x2F;将checkForUpdates作为listener\n  subscription.onStateChange &#x3D; checkForUpdates\n  &#x2F;&#x2F;开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中。\n  subscription.trySubscribe()\n  &#x2F;&#x2F;在第一次呈现之后从存储中提取数据，以防存储从我们开始就改变了。\n  &#x2F;&#x2F;确保获取到的最新的store.getState,然后判断是否更新组件\n  checkForUpdates()\n  &#x2F;* 卸载订阅起 *&#x2F;\n  const unsubscribeWrapper &#x3D; () &#x3D;&gt; &#123;\n    didUnsubscribe &#x3D; true\n    subscription.tryUnsubscribe()\n    subscription.onStateChange &#x3D; null\n  &#125;\n\n  return unsubscribeWrapper\n&#125;\n\n\n首先声明 store 更新订阅传播到此组件时的回调函数checkForUpdates把它赋值给onStateChange,如果store中的state发生改变，那么在组件订阅了state内容之后，相关联的state改变就会触发当前组件的onStateChange,来合并得到新的props\n\nsubscription.trySubscribe()把订阅函数onStateChange绑定给父级subscription,进行了层层订阅\n\n为了确保拿到的store内容是最新的，所以首先执行了一次checkForUpdates\ncheckForUpdates\n判断是否需要更新的函数\n&#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调\nconst checkForUpdates &#x3D; () &#x3D;&gt; &#123;\n  if (didUnsubscribe) &#123;\n    &#x2F;&#x2F;如果取消订阅了\n    return\n  &#125;\n   &#x2F;&#x2F; 获取 store 里state\n  const latestStoreState &#x3D; store.getState()q\n  let newChildProps, error\n  try &#123;\n    &#x2F;* 得到最新的 props *&#x2F;\n    newChildProps &#x3D; childPropsSelector(\n      latestStoreState,\n      lastWrapperProps.current\n    )\n  &#125; \n  &#x2F;&#x2F;如果新的合并的 props没有更改，则此处不做任何操作-层叠订阅更新\n  if (newChildProps &#x3D;&#x3D;&#x3D; lastChildProps.current) &#123; \n    if (!renderIsScheduled.current) &#123;  \n      notifyNestedSubs() &#x2F;* 通知子代 subscription 触发 checkForUpdates 来检查是否需要更新。 *&#x2F;\n    &#125;\n  &#125; else &#123;\n    lastChildProps.current &#x3D; newChildProps\n    childPropsFromStoreUpdate.current &#x3D; newChildProps\n    renderIsScheduled.current &#x3D; true\n    &#x2F;&#x2F; 触发useReducer的dispatch来进行更新，该dispatch会改变useReducer返回的previousStateUpdateResult\n    &#x2F;&#x2F; 而previousStateUpdateResult是作为actualChildProps的依赖项引发actualChildProps的改变\n    &#x2F;&#x2F; actualChildProps又是实际渲染组件的依赖性，从而引发组件的重新渲染更新\n    forceComponentUpdateDispatch(&#123;\n      type: &#39;STORE_UPDATED&#39;,\n      payload: &#123;\n        error\n      &#125;\n    &#125;)\n  &#125;\n&#125;\n\ncheckForUpdates 通过调用 childPropsSelector来形成新的props,然后判断之前的 prop 和当前新的 prop 是否相等。如果相等，证明没有发生变化,无须更新当前组件，那么通过调用notifyNestedSubs来通知子代容器组件，检查是否需要更新。如果不相等证明订阅的store.state发生变化，那么立即执行forceComponentUpdateDispatch来触发组件的更新\n\n\n整个订阅流程整个订阅的流程是，如果被connect包裹，并且具有第一个参数。首先通过context获取最近的 subscription，然后创建一个新的subscription,并且和父级的subscription建立起关联。当第一次hoc容器组件挂在完成后，在useEffect里，进行订阅，将自己的订阅函数checkForUpdates,作为回调函数，通过trySubscribe 和this.parentSub.addNestedSub ,加入到父级subscription的listeners中。由此完成整个订阅流程\n整个发布流程整个更新流程是，当组件中调用dispatch触发了redux的state改变和redux的订阅器，从而触发根订阅器的触发listeners.notify ,也就是checkForUpdates函数，然后checkForUpdates函数首先根据mapStoretoprops，mergeprops等操作，验证该组件是否发起订阅，props 是否改变，并更新，如果发生改变，那么触发useReducer的forceComponentUpdateDispatch函数，来更新业务组件，如果没有发生更新，那么通过调用notifyNestedSubs,来通知当前subscription的listeners检查是否更新，然后尽心层层checkForUpdates,逐级向下，借此完成整个更新流程。\n总结\nconnect使用柯里化\nuseMemo缓存渲染组件的操作\n发布订阅模式以及通过双向链表来管理\n如何通过Provider进行层层订阅\nreact-redux触发更新的依据是actualChildProps是否改变\n\n参考react-redux源码解析github 源码React-redux源码解析–准备知识React-redux源码解析\n","slug":"2022-05-24react-redux2","date":"2022-05-24T13:15:31.000Z","categories_index":"react-redux","tags_index":"react-redux,redux,源码","author_index":"陈海龙"},{"id":"83401137c3fcd92a859b6d9e289c2c88","title":"react-redux 源码1","content":"react-redux官方介绍\n官方UI绑定层。 React Redux is the official React UI bindings layer for Redux. \n从redux的store读数据。 It lets your React components read data from a Redux store,\n触发行为给store来更新状态。and dispatch actions to the store to update state.\n\nreact-redux 源码.\n├── alternate-renderers.ts\n├── components\n│   ├── Context.ts\n│   ├── Provider.tsx\n│   └── connect.tsx # 大部分代码都在这里\n├── connect # 给 connect.tsx使用\n│   ├── invalidArgFactory.ts\n│   ├── mapDispatchToProps.ts\n│   ├── mapStateToProps.ts\n│   ├── mergeProps.ts\n│   ├── selectorFactory.ts\n│   ├── verifySubselectors.ts\n│   └── wrapMapToProps.ts\n├── exports.ts\n├── hooks\n│   ├── useDispatch.ts\n│   ├── useReduxContext.ts\n│   ├── useSelector.ts\n│   └── useStore.ts\n├── index.ts\n├── next.ts\n├── types.ts\n└── utils\n    ├── Subscription.ts\n    ├── batch.ts\n    ├── bindActionCreators.ts\n    ├── isPlainObject.ts\n    ├── reactBatchedUpdates.native.ts\n    ├── reactBatchedUpdates.ts\n    ├── shallowEqual.ts\n    ├── useIsomorphicLayoutEffect.native.ts\n    ├── useIsomorphicLayoutEffect.ts\n    ├── useSyncExternalStore.ts\n    ├── verifyPlainObject.ts\n    └── warning.ts\npackge.json&#x2F;&#x2F; packge.json\n&#123;\n  &quot;name&quot;: &quot;react-redux&quot;,\n  &quot;version&quot;: &quot;8.0.2&quot;,\n  &quot;description&quot;: &quot;Official React bindings for Redux&quot;,\n  &quot;keywords&quot;: [\n    &quot;react&quot;,\n    &quot;reactjs&quot;,\n    &quot;redux&quot;\n  ],\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;author&quot;: &quot;Dan Abramov &lt;dan.abramov@me.com&gt; (https:&#x2F;&#x2F;github.com&#x2F;gaearon)&quot;,\n  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&quot;,\n  &quot;repository&quot;: &quot;github:reduxjs&#x2F;react-redux&quot;,\n  &quot;bugs&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&#x2F;issues&quot;,\n  &#x2F;&#x2F; 找找入口，入口有3种：\n  &quot;main&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;, &#x2F;&#x2F; 常规操作入口\n  &quot;types&quot;: &quot;.&#x2F;es&#x2F;index.d.ts&quot;, &#x2F;&#x2F; 类型入口\n  &quot;unpkg&quot;: &quot;dist&#x2F;react-redux.js&quot;, &#x2F;&#x2F; cdn入口\n  &quot;module&quot;: &quot;es&#x2F;index.js&quot;,&#x2F;&#x2F;esm入口\n  &#x2F;&#x2F; npm发布上传的文件\n  &quot;files&quot;: [\n    &quot;dist&quot;,\n    &quot;lib&quot;,\n    &quot;src&quot;, &#x2F;&#x2F; 一般用于开发阶段代码调试,soucemap\n    &quot;es&quot;\n  ],\n  &quot;scripts&quot;: &#123;\n    &#x2F;&#x2F; 脚本不看了...\n  &#125;,\n  &#x2F;&#x2F; 配置了依赖项，这些依赖项不需要在本包安装，在项目中安装即可\n  &quot;peerDependencies&quot;: &#123;\n    &quot;@types&#x2F;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;@types&#x2F;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;react-native&quot;: &quot;&gt;&#x3D;0.59&quot;,\n    &quot;redux&quot;: &quot;^4&quot;\n  &#125;,\n  &quot;peerDependenciesMeta&quot;: &#123;\n    &quot;@types&#x2F;react&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;@types&#x2F;react-dom&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;react-dom&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;react-native&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;redux&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; 发布后，业务开发者使用，需要安装，&#x2F;&#x2F;自动安装\n  &quot;dependencies&quot;: &#123;\n    &quot;@babel&#x2F;runtime&quot;: &quot;^7.12.1&quot;,\n    &quot;@types&#x2F;hoist-non-react-statics&quot;: &quot;^3.3.1&quot;,\n    &quot;@types&#x2F;use-sync-external-store&quot;: &quot;^0.0.3&quot;,\n    &quot;hoist-non-react-statics&quot;: &quot;^3.3.2&quot;,\n    &quot;react-is&quot;: &quot;^18.0.0&quot;,\n    &quot;use-sync-external-store&quot;: &quot;^1.0.0&quot;\n  &#125;,\n  &#x2F;&#x2F; 开发阶段需要用到的，一般是examples中demo使用\n  &quot;devDependencies&quot;: &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\nexports.tsexport &#123;\n  Provider, &#x2F;&#x2F; import Provider from &#39;.&#x2F;components&#x2F;Provider&#39;\n\n  ReactReduxContext, &#x2F;&#x2F; import &#123; ReactReduxContext &#125; from &#39;.&#x2F;components&#x2F;Context&#39;\n\n  connect, &#x2F;&#x2F; import connect from &#39;.&#x2F;components&#x2F;connect&#39;\n\n  useDispatch, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;\n  createDispatchHook, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;\n\n  useSelector, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;\n  createSelectorHook, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;\n\n  useStore, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;\n  createStoreHook, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;\n\n  shallowEqual, &#x2F;&#x2F; import shallowEqual from &#39;.&#x2F;utils&#x2F;shallowEqual&#39;\n&#125;\n\n\nProvider先看下 ，最熟悉的api\n&#x2F;&#x2F; components&#x2F;Provider.tsx\n&#x2F;&#x2F; 这个组件做的事情\n&#x2F;&#x2F; 1. 合并浏览器和服务器的状态\n&#x2F;&#x2F; 2. 对于同构的应用，处理subscription订阅\nfunction Provider&lt;A extends Action &#x3D; AnyAction&gt;(&#123;\n  store,\n  context,\n  children,\n  serverState,\n&#125;: ProviderProps&lt;A&gt;) &#123;\n  &#x2F;&#x2F; 1.useMemo，对入参进行格式化「处理了store和 服务端的 serverState」\n  const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n    const subscription &#x3D; createSubscription(store)\n    return &#123;\n      store,\n      subscription,\n      getServerState: serverState ? () &#x3D;&gt; serverState : undefined,\n    &#125;\n  &#125;, [store, serverState])\n  &#x2F;&#x2F; 2.之前的state状态从store中直接获取\n  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])\n  &#x2F;&#x2F; 3.同构相关，跳过\n  useIsomorphicLayoutEffect(() &#x3D;&gt; &#123;\n    const &#123; subscription &#125; &#x3D; contextValue\n    subscription.onStateChange &#x3D; subscription.notifyNestedSubs\n    subscription.trySubscribe()\n\n    if (previousState !&#x3D;&#x3D; store.getState()) &#123;\n      subscription.notifyNestedSubs()\n    &#125;\n    return () &#x3D;&gt; &#123;\n      subscription.tryUnsubscribe()\n      subscription.onStateChange &#x3D; undefined\n    &#125;\n  &#125;, [contextValue, previousState])\n  &#x2F;&#x2F; 4.react-redux上下文\n  const Context &#x3D; context || ReactReduxContext\n\n  &#x2F;&#x2F; @ts-ignore &#39;AnyAction&#39; is assignable to the constraint of type &#39;A&#39;, but &#39;A&#39; could be instantiated with a different subtype\n  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt; &#x2F;&#x2F; 这行代码是不是非常熟悉了\n&#125;\n\nexport default Provider\n\nReactReduxContext&#x2F;&#x2F; .&#x2F;components&#x2F;Context.tsx\n&#x2F;&#x2F; 这个组件做的事情\n&#x2F;&#x2F; 1.创建个createContext\n&#x2F;&#x2F; 2.给个名字displayName\n\n&#x2F;&#x2F; ...类型代码不关注\nexport const ReactReduxContext &#x3D;&#x2F;*#__PURE__*&#x2F; React.createContext&lt;ReactReduxContextValue&gt;(null as any)\n\n&#x2F;&#x2F; ...类型代码不关注\n\nif (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;\n  ReactReduxContext.displayName &#x3D; &#39;ReactRedux&#39;\n&#125;\n\nexport default ReactReduxContext\nconnect&#x2F;&#x2F; .&#x2F;components&#x2F;connect.tsx\n&#x2F;&#x2F; 这个文件比较长，先不看\n&#x2F;&#x2F; hoist-non-react-statics这个依赖可以帮助我们自动拷贝非React的静态方法\nuseDispatch、createDispatchHook把ts类型删删，看上去更简单了\n&#x2F;&#x2F; .&#x2F;hooks&#x2F;useDispatch\n&#x2F;&#x2F; 用createDispatchHook钩子工厂创建了个钩子useDispatch\nexport function createDispatchHook(context) &#123;\n  &#x2F;&#x2F; TODO: createStoreHook下面再看，先跳过\n  const useStore &#x3D; context &#x3D;&#x3D;&#x3D; ReactReduxContext ? useDefaultStore : createStoreHook(context)\n  return function useDispatch() &#123;\n    const store &#x3D; useStore()\n    &#x2F;&#x2F; @ts-ignore\n    return store.dispatch\n  &#125;\n&#125;\n&#x2F;**\n * A hook to access the redux &#96;dispatch&#96; function.\n *\n * @returns &#123;any|function&#125; redux store&#39;s &#96;dispatch&#96; function\n *\n * @example\n *\n * import React, &#123; useCallback &#125; from &#39;react&#39;\n * import &#123; useDispatch &#125; from &#39;react-redux&#39;\n *\n * export const CounterComponent &#x3D; (&#123; value &#125;) &#x3D;&gt; &#123;\n *   const dispatch &#x3D; useDispatch()\n *   const increaseCounter &#x3D; useCallback(() &#x3D;&gt; dispatch(&#123; type: &#39;increase-counter&#39; &#125;), [])\n *   return (\n *     &lt;div&gt;\n *       &lt;span&gt;&#123;value&#125;&lt;&#x2F;span&gt;\n *       &lt;button onClick&#x3D;&#123;increaseCounter&#125;&gt;Increase counter&lt;&#x2F;button&gt;\n *     &lt;&#x2F;div&gt;\n *   )\n * &#125;\n *&#x2F;\nexport const useDispatch &#x3D; &#x2F;*#__PURE__*&#x2F; createDispatchHook()\n\nuseSelector、createSelectorHook&#x2F;&#x2F; .&#x2F;hooks&#x2F;useSelector\n&#x2F;&#x2F; 用 createSelectorHook 钩子工厂创建了个钩子 useSelector\n\nlet useSyncExternalStoreWithSelector &#x3D; notInitialized as uSESWS\nexport const initializeUseSelector &#x3D; (fn: uSESWS) &#x3D;&gt; &#123;\n  useSyncExternalStoreWithSelector &#x3D; fn\n&#125;\n\nconst refEquality: EqualityFn&lt;any&gt; &#x3D; (a, b) &#x3D;&gt; a &#x3D;&#x3D;&#x3D; b\n\n&#x2F;&#x2F; 下面的代码保留范型，Selected\nexport function createSelectorHook(\n  context &#x3D; ReactReduxContext\n): &lt;TState &#x3D; unknown, Selected &#x3D; unknown&gt;(\n  selector: (state: TState) &#x3D;&gt; Selected,\n  equalityFn?: EqualityFn&lt;Selected&gt;\n) &#x3D;&gt; Selected &#123;\n  const useReduxContext &#x3D;\n    context &#x3D;&#x3D;&#x3D; ReactReduxContext\n      ? useDefaultReduxContext\n      : () &#x3D;&gt; useContext(context)\n\n  return function useSelector(\n    selector,\n    equalityFn &#x3D; refEquality\n  ) &#123;\n\n    const &#123; store, subscription, getServerState &#125; &#x3D; useReduxContext()!\n\n    const selectedState &#x3D; useSyncExternalStoreWithSelector(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      selector,\n      equalityFn\n    )\n\n    useDebugValue(selectedState) &#x2F;&#x2F; 标记\n\n    return selectedState\n  &#125;\n&#125;\n\n&#x2F;**\n * A hook to access the redux store&#39;s state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param &#123;Function&#125; selector the selector function\n * @param &#123;Function&#x3D;&#125; equalityFn the function that will be used to determine equality\n *\n * @returns &#123;any&#125; the selected state\n *\n * @example\n *\n * import React from &#39;react&#39;\n * import &#123; useSelector &#125; from &#39;react-redux&#39;\n *\n * export const CounterComponent &#x3D; () &#x3D;&gt; &#123;\n *   const counter &#x3D; useSelector(state &#x3D;&gt; state.counter)\n *   return &lt;div&gt;&#123;counter&#125;&lt;&#x2F;div&gt;\n * &#125;\n *&#x2F;\nexport const useSelector &#x3D; &#x2F;*#__PURE__*&#x2F; createSelectorHook()\nuseStore、createStoreHook\n&#x2F;&#x2F; 1.用钩子工厂创建了个钩子\n&#x2F;&#x2F; 2.从   const &#123; store &#125; &#x3D; useReduxContext()! 获取store\n\n&#x2F;**\n * Hook factory, which creates a &#96;useStore&#96; hook bound to a given context.\n *\n * @param &#123;React.Context&#125; [context&#x3D;ReactReduxContext] Context passed to your &#96;&lt;Provider&gt;&#96;.\n * @returns &#123;Function&#125; A &#96;useStore&#96; hook bound to the specified context.\n *&#x2F;\nexport function createStoreHook&lt;\n  S &#x3D; unknown,\n  A extends BasicAction &#x3D; AnyAction\n  &#x2F;&#x2F; @ts-ignore\n&gt;(context?: Context&lt;ReactReduxContextValue&lt;S, A&gt;&gt; &#x3D; ReactReduxContext) &#123;\n  const useReduxContext &#x3D;\n    &#x2F;&#x2F; @ts-ignore\n    context &#x3D;&#x3D;&#x3D; ReactReduxContext\n      ? useDefaultReduxContext\n      : () &#x3D;&gt; useContext(context)\n  return function useStore&lt;\n    State &#x3D; S,\n    Action extends BasicAction &#x3D; A\n    &#x2F;&#x2F; @ts-ignore\n  &gt;() &#123;\n    const &#123; store &#125; &#x3D; useReduxContext()!\n    &#x2F;&#x2F; @ts-ignore\n    return store as Store&lt;State, Action&gt;\n  &#125;\n&#125;\n\n&#x2F;**\n * A hook to access the redux store.\n *\n * @returns &#123;any&#125; the redux store\n *\n * @example\n *\n * import React from &#39;react&#39;\n * import &#123; useStore &#125; from &#39;react-redux&#39;\n *\n * export const ExampleComponent &#x3D; () &#x3D;&gt; &#123;\n *   const store &#x3D; useStore()\n *   return &lt;div&gt;&#123;store.getState()&#125;&lt;&#x2F;div&gt;\n * &#125;\n *&#x2F;\nexport const useStore &#x3D; &#x2F;*#__PURE__*&#x2F; createStoreHook()\n\nconnect 见：react-redux 源码2\n","slug":"2022-05-24react-redux","date":"2022-05-24T05:58:32.000Z","categories_index":"react-redux","tags_index":"react-redux,redux,源码","author_index":"陈海龙"},{"id":"eb38c4ce852a081263435b4198b57084","title":"flex width:0","content":"flex嵌套内部元素宽度默认100%，撑开父元素，父元素的根元素限制最大宽度，子元素并不受flex控制\n遇到多次了，这次是维护其他同事的代码，又撞见了，说明这个问题很常见，一个不留神，就踩到了\n根元素\n  ……\n  - 父元素flex\n  …… flex\n   - 子元素flex(默认宽度100%)\n\n\n.doc-tree-base-title-node .doc-tree-base-title-text &gt; a &#123;\n    display: flex;\n    align-items: center;\n    color: #777;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    flex: 1;\n&#125;\n\n问题\n 观察下发现，flex是嵌套的，最外层的还是flex，一层一层，最外层的宽度，却是由最内层的宽度决定（这个调试可以看到）\n调试\n图1\n\n \n\n图2\n\n \n\n图3\n\n \n分析 图1 元素没有宽度，宽度默认是100%\n 图1到图3是由a标签子元素撑开的，宽度是100%,加上操作按钮，元素宽度超100%\n 而在侧边树结构的最外层设置了max-width: 500px,而内部子元素尺寸却是599.48 x 36\n 显然是不合理的\n修复 根元素\n  ……\n  - 父元素flex\n  …… flex\n   - 子元素flex(默认宽度设置宽度0 或者其他小点的宽度，越小越好)\n\n \n什么原因导致的MDN flex\n语法\n&#x2F;* 关键字值 *&#x2F;\nflex: auto;\nflex: initial;\nflex: none;\n\n&#x2F;* 一个值, 无单位数字: flex-grow *&#x2F;\nflex: 2;\n\n&#x2F;* 一个值, width&#x2F;height: flex-basis *&#x2F;\nflex: 10em;\nflex: 30px;\nflex: min-content;\n\n&#x2F;* 两个值: flex-grow | flex-basis *&#x2F;\nflex: 1 30px;\n\n&#x2F;* 两个值: flex-grow | flex-shrink *&#x2F;\nflex: 2 2;\n\n&#x2F;* 三个值: flex-grow | flex-shrink | flex-basis *&#x2F;\nflex: 2 2 10%;\n\n&#x2F;*全局属性值 *&#x2F;\nflex: inherit;\nflex: initial;\nflex: unset;\n\n\n\n可以使用一个，两个或三个值来指定 flex属性。\n1.单值语法: 值必须为以下其中之一:\n\n一个无单位数(&lt;number&gt;): 它会被当作flex: 1 0; 的值被假定为1，然后 的值被假定为0。\n一个有效的宽度(width)值: 它会被当作 的值。\n关键字none，auto或initial.\n\n2.双值语法: 第一个值必须为一个无单位数，并且它会被当作  的值。第二个值必须为以下之一：\n\n一个无单位数：它会被当作  的值。\n一个有效的宽度值: 它会被当作  的值。\n\n3.三值语法:\n\n第一个值必须为一个无单位数，并且它会被当作  的值。\n第二个值必须为一个无单位数，并且它会被当作   的值。\n第三个值必须为一个有效的宽度值， 并且它会被当作  的值。\n\n 可以看到单值，作为双值处理\n flex-shrink:1;\nflex-basis: 0;\n\nflex-basis 自来看下flex-base\n 查看文档后发现，文档上没说关于flex-basic: 0 的事情,给了个演示，也看不出来想表达什么\nflex-basis 属性的含义w3c flex-basis-propertyflex布局一般由flex容器（display 属性值为 flex 或 inline-flex）和其子元素（后文亦称flex子项或flex item）构成。flex-basis 属性一般作用在flex子项上，它定义了：在flex容器分配剩余空间前flex子项在主轴方向上的初始尺寸。flex子项在主轴方向上的实际尺寸是根据元素自身尺寸、flex-basis、flex-grow、flex-shrink 等属性共同决定的。如何计算实际尺寸不是本文重点，不继续展开。\nflex-basis:0px与0%\n如果 flex-basis 的值为百分数，且它flex容器的尺寸没有被显式设置，此时 flex-basis 的值会被解析为 content\n\n\n其他，值得一看flex: 1在浏览器中，flex: 1 的 flex-basis 值为什么不是W3C文档中提到的 0 ？\n当使用 flex 属性但又省略不写它其中的 flex-basis 值时，会将 flex-basis 设置为 0.\n这里的 0 单位是 px 还是 % 我们在Chrome浏览器里就能验证：\n\n\n答案是 px.\n这段是2015年修正日志里的，意思是将之前 flex 简写语法里的 flex-basis 的解析值从 0% 恢复为原来的 0.\n注意： 这个值的解析规则经历了 0px -&gt; 0% -&gt; 0px 的变化，这是W3C flex 标准文档的视角。\n简而言之就是有兼容性问题。现在已有很多网页都利用了 flex 属性的这个特性来开发。如果简写语法里 flex-basis 的解析从 0% 变为 0px 会导致部分情况下flex容器塌陷，致使很多网页异常\n建议看原文\n","slug":"2022-05-23width0","date":"2022-05-23T09:16:21.000Z","categories_index":"css3","tags_index":"bug,css3","author_index":"陈海龙"},{"id":"436e39263be04b5730d01a19facc4657","title":"CSS如何工作","content":"浏览器工作原理\n\n\n\n\n\n\n\n\n当浏览器展示一个文件的时候，它必须兼顾文件的内容和文件的样式信息\n如何加载CSS和HTML下面的步骤是浏览加载网页的简化版本:\n\n浏览器载入HTML文件（比如从网络上获取）。\n将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。\n接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。\n浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。\n上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。\n网页展示在屏幕上（这一步被称为着色）。\n\n运行图\n\n\n\n\n无法解析的CSS会发生什么\n\n\n\n\n\n\n\n\n答案就是浏览器什么也不会做，继续解析下一个CSS样式！\n以下是废话：\n\n浏览器并不会同时实现所有的新CSS，此外很多人也不会使用最新版本的浏览器。鉴于CSS一直不断的开发，因此领先于浏览器可以识别的范围，那么你也许会好奇当浏览器遇到无法解析的CSS选择器或声明的时候会发生什么呢？\n\nCSS规则： 如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的CSS声明。在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候上述的情况同样会发生（直接忽略）。\n\n选择器： 相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个CSS选择器。\n\n\n\n\n关于DOM一个DOM有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node&#x2F;DOM或DOM node）。节点由节点本身和其他DOM节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。\n对于DOM的理解会很大程度上帮助你设计、调试和维护你的CSS，因为DOM是你的CSS样式和文件内容的结合。当你使用浏览器F12调试的时候你需要操作DOM以查看使用了哪些规则。\n&lt;p&gt;\n  Let&#39;s use:\n  &lt;span&gt;Cascading&lt;&#x2F;span&gt;\n  &lt;span&gt;Style&lt;&#x2F;span&gt;\n  &lt;span&gt;Sheets&lt;&#x2F;span&gt;\n&lt;&#x2F;p&gt;\n\n\nP\n├─ &quot;Let&#39;s use:&quot;\n├─ SPAN\n|  └─ &quot;Cascading&quot;\n├─ SPAN\n|  └─ &quot;Style&quot;\n└─ SPAN\n   └─ &quot;Sheets&quot;\n\n\n\n参考MDN\n","slug":"2022-05-23css","date":"2022-05-23T07:53:28.000Z","categories_index":"浏览器原理","tags_index":"浏览器原理","author_index":"陈海龙"},{"id":"98f521cd056816f8a9831692e48a6839","title":"monorepo","content":"背景\n调试源码时候，总会遇到多包的仓库，遇到了不晓得如何调试\n开发个库或者是插件之类的开发的比较混乱\n经历多个项目的毒打，终于有时间学下monorepo\n\nlerna、yarn workspace\n和java微服务架构代码很像\n很多项目是 lerna+yarn workspace，如果不懂，或者了解了一点lerna。上去一顿操作，各种报错，在所难免（亲身经历）\n\nmonorepo管理对于维护过多个package(功能相近)的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护。Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块&#x2F;包 (package)，不同于常见的每个模块建一个 repo。\n目前有不少大型开源项目采用了这种方式，如 Babel，React, Meteor, Ember, Angular,Jest, Umijs, Vue, 还有 create-react-app, react-router 等。几乎我们熟知的仓库，都无一例外的采用了monorepo 的方式，可以看到这些项目的第一级目录的内容以脚手架为主，主要内容都在 packages目录中、分多个 package 进行管理。\n目录结构如下:\n├── packages\n|   ├── pkg1\n|   |   ├── package.json\n|   ├── pkg2\n|   |   ├── package.json\n├── package.json\n\nmonorepo 最主要的好处是统一的工作流和Code Sharing。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。\n一图胜千言:\n前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。\n虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。\n结合shop-service门户的实际场景和业务需要，天然的 MonoRepo ! 一个理想的开发环境可以抽象成这样：\n\n\n\n\n\n\n\n\n\n“只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”\n在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。\n上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna是业界知名度最高的 Monorepo 管理工具，功能完整。\nLernaLerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。\n2.1 安装推荐全局安装，因为会经常用到 lerna 命令\nnpm i -g lerna\n2.2 初始化项目\nlerna init\n\n其中 package.json &amp; lerna.json 如下:\n&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true, &#x2F;&#x2F; 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦\n  &quot;devDependencies&quot;: &#123;\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;\n \n&#x2F;&#x2F; lerna.json\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;version&quot;: &quot;0.0.0&quot;\n&#125;\n\n\n2.3 创建npm包增加两个 packages\n\n2.4 增加模块依赖分别给相应的 package 增加依赖模块\nlerna add chalk &#x2F;&#x2F; 为所有 package 增加 chalk 模块 \nlerna add semver --scope @mo-demo&#x2F;cli-shared-utils &#x2F;&#x2F; 为 @mo-demo&#x2F;cli-shared-utils 增加 semver 模块 \nlerna add @mo-demo&#x2F;cli-shared-utils --scope @mo-demo&#x2F;cli &#x2F;&#x2F; 增加内部模块之间的依赖\n\n2.5 发布\nlerna publish\n\n2.6 依赖包管理上述1-5步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。\n我们在第4步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 node_modules 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 node_modules ，也不清爽。于是我们使用 –hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本。\nlerna bootstrap --hoist\n\n为了省去每次都输入 –hoist 参数的麻烦，可以在 lerna.json 配置：\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;command&quot;: &#123;\n    &quot;bootstrap&quot;: &#123;\n      &quot;hoist&quot;: true\n    &#125;\n  &#125;,\n  &quot;version&quot;: &quot;0.0.1-alpha.0&quot;\n&#125;\n配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：\nlerna clean\n\n然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 `node_modules` 中了。\n\nLerna + Monorepo 最佳实践\n\n\n\n\n\n\n\n\nlerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。\n目前最常见的 monorepo 解决方案是 Lerna 和 yarn 的 workspaces 特性，基于lerna和yarn workspace的monorepo工作流。由于yarn和lerna在功能上有较多的重叠,我们采用yarn官方推荐的做法,用yarn来处理依赖问题，用lerna来处理发布问题。能用yarn做的就用yarn做吧\nyarn workspace3.1.1 搭建环境普通项目：clone下来后通过yarn install,即可搭建完项目，有时需要配合postinstall hooks,来进行自动编译，或者其他设置。\nmonorepo: 各个库之间存在依赖，如A依赖于B，因此我们通常需要将B link到A的node_module里，一旦仓库很多的话，手动的管理这些link操作负担很大，因此需要自动化的link操作，按照拓扑排序将各个依赖进行link\n解决方式：通过使用workspace，yarn install会自动的帮忙解决安装和link问题\nyarn install # 等价于 lerna bootstrap --npm-client yarn --use-workspaces\n\n3.1.2 清理环境在依赖乱掉或者工程混乱的情况下，清理依赖\n普通项目： 直接删除node_modules以及编译后的产物。\nmonorepo： 不仅需要删除root的node_modules的编译产物还需要删除各个package里的node_modules以及编译产物\n解决方式：使用lerna clean来删除所有的node_modules，使用yarn workspaces run clean来执行所有package的清理工作\nlerna clean # 清理所有的node_modules\nyarn workspaces run clean # 执行所有package的clean操作\n\n3.1.3 安装|删除依赖普通项目： 通过yarn add和yarn remove即可简单姐解决依赖库的安装和删除问题\nmonorepo: 一般分为三种场景\n给某个package安装依赖：yarn workspace packageB add packageA 将packageA作为packageB的依赖进行安装\n给所有的package安装依赖: 使用yarn workspaces add lodash 给所有的package安装依赖\n给root 安装依赖：一般的公用的开发工具都是安装在root里，如typescript,我们使用yarn add -W -D typescript来给root安装依赖\n对应的三种场景删除依赖如下\nyarn workspace packageB remove packageA\nyarn workspaces remove lodash\nyarn remove -W -D typescript\n\n\n3.1.4 项目构建普通项目：建立一个build的npm script，使用yarn build即可完成项目构建\nmonorepo:区别于普通项目之处在于各个package之间存在相互依赖，如packageB只有在packageA构建完之后才能进行构建，否则就会出错，这实际上要求我们以一种拓扑排序的规则进行构建。\n我们可以自己构建拓扑排序规则，很不幸的是yarn的workspace暂时并未支持按照拓扑排序规则执行命令,虽然该 rfc已经被accepted，但是尚未实现, 幸运的是lerna支持按照拓扑排序规则执行命令, –sort参数可以控制以拓扑排序规则执行命令\nlerna run --stream --sort build\n3.1.5 版本升级及发包项目测试完成后，就涉及到版本发布，版本发布一般涉及到如下一些步骤\n条件验证: 如验证测试是否通过，是否存在未提交的代码，是否在主分支上进行版本发布操作\nversion_bump:发版的时候需要更新版本号，这时候如何更新版本号就是个问题，一般大家都会遵循 semVer语义，\n生成changelog: 为了方便查看每个package每个版本解决了哪些功能，我们需要给每个package都生成一份changelog方便用户查看各个版本的功能变化。\n生成git tag：为了方便后续回滚问题及问题排查通常需要给每个版本创建一个git tag\ngit 发布版本：每次发版我们都需要单独生成一个commit记录来标记milestone\n发布npm包：发布完git后我们还需要将更新的版本发布到npm上，以便外部用户使用\n我们发现手动的执行这些操作是很麻烦的且及其容易出错，幸运的是lerna可以帮助我们解决这些问题\nyarn官方并不打算支持发布流程，只是想做好包管理工具，因此这部分还是需要通过lerna支持\nlerna提供了publish和version来支持版本的升级和发布, publish的功能可以即包含version的工作，也可以单纯的只做发布操作。\n3.2 优雅的提交3.2.1 commitizen &amp;&amp; cz-lerna-changelogcommitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。\ncz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：\n\n我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。\n因为这是整个工程的开发依赖，所以在根目录安装：\nyarn add  -D commitizen\nyarn add  -D cz-lerna-changelog\n\n安装完成后，在 package.json 中增加 config 字段，把 cz-lerna-changelog 配置给 commitizen。同时因为commitizen不是全局安全的，所以需要添加 scripts 脚本来执行 git-cz\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;commit&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;\n\n\n之后在常规的开发中就可以使用 yarn run commit 来根据提示一步一步输入，来完成代码的提交。\n3.2.2 commitlint &amp;&amp; husky上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用yarn run commit 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。\n安装 commitlint 以及要遵守的规范\nyarn add -D @commitlint&#x2F;cli @commitlint&#x2F;config-conventional\n\n在工程根目录为 commitlint 增加配置文件 commitlint.config.js 为commitlint 指定相应的规范\nmodule.exports &#x3D; &#123; \n\textends: [&#39;@commitlint&#x2F;config-conventional&#39;] \n&#125;\n\n安装 husky\nyarn add -D husky\n\n\n在 package.json 中增加如下配置\n&quot;husky&quot;: &#123; \n\t\t&quot;hooks&quot;: &#123; \n   \t\t&quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot; \n    &#125;\n&#125;\n\n\n“commit-msg”是git提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 yarn run commit 来提交。\n3.2.3 eslint &amp;&amp; lint-staged除了规范提交信息，代码本身肯定也少了靠规范来统一风格。\n安装\nyarn add  -D standard lint-staged\n\n\neslint就是完整的一套 JavaScript（typescript） 代码规范，自带 linter &amp; 代码自动修正。自动格式化代码并修正，提前发现风格以及程序问题, 同时也支持typescript的代码规范校验，eslintrc.json配置：\n&#123;\n    &quot;extends&quot;: [\n        &quot;yayajing&quot;,\n        &quot;plugin:@typescript-eslint&#x2F;recommended&quot;\n    ],\n    &quot;parser&quot;: &quot;typescript-eslint-parser&quot;,\n    &quot;plugins&quot;: [&quot;@typescript-eslint&quot;],\n    &quot;rules&quot;: &#123;\n        &quot;eqeqeq&quot;:&quot;off&quot;,\n        &quot;@typescript-eslint&#x2F;explicit-function-return-type&quot;: &quot;off&quot;,\n        &quot;no-template-curly-in-string&quot;: &quot;off&quot;\n    &#125;\n  &#125;\n\n\nlint-staged staged 是 Git 里的概念，表示暂存区，lint-staged 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。package.json配置\n&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;c&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;husky&quot;: &#123;\n    &quot;hooks&quot;: &#123;\n      &quot;pre-commit&quot;: &quot;lint-staged&quot;,\n      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;\n    &#125;\n  &#125;,\n  &quot;lint-staged&quot;: &#123;\n    &quot;*.ts&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@commitlint&#x2F;cli&quot;: &quot;^8.1.0&quot;,\n    &quot;@commitlint&#x2F;config-conventional&quot;: &quot;^8.1.0&quot;,\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;husky&quot;: &quot;^3.0.0&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;,\n    &quot;lint-staged&quot;: &quot;^9.2.0&quot;\n  &#125;\n&#125;\n\n\n安装完成后，在 package.json 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 eslint –fix 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky的配置中增加pre-commit的钩子用来执行 lint-staged 的校验操作。\n此时提交 ts 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。\n3.3 发布自动生成日志有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：\n3.3.1 lerna version 更新版本\n\n找出从上一个版本发布以来有过变更的 package\n\n提示开发者确定要发布的版本号\n\n将所有更新过的的 package 中的package.json的version字段更新\n\n将依赖更新过的 package 的 包中的依赖版本号更新\n\n更新 lerna.json 中的 version 字段\n\n提交上述修改，并打一个 tag\n\n推送到 git 仓库\n\n\n3.3.2 使用 npm publish 将新版本推送到 npmCHANGELOG 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数 --conventional-commits。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 lerna.json中，如下：\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;command&quot;: &#123;\n    &quot;bootstrap&quot;: &#123;\n      &quot;hoist&quot;: true\n    &#125;,\n    &quot;version&quot;: &#123;\n      &quot;conventionalCommits&quot;: true\n    &#125;\n  &#125;,\n  &quot;ignoreChanges&quot;: [\n    &quot;**&#x2F;*.md&quot;\n  ],\n  &quot;version&quot;: &quot;0.0.1-alpha.1&quot;\n&#125;\n\n\nlerna version 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 ignoreChanges 配置排除。如上。\n实际 lerna version很少直接使用，因为它包含在 lerna publish 中了，直接使用 lerna publish就好了。\n3.4 完善的测试用例monorepo项目：测试有两种方式\n\n使用统一的jest测试配置这样方便全局的跑jest即可，好处是可以方便统计所有代码的测试覆盖率，坏处是如果package比较异构（如小程序，前端，node 服务端等），统一的测试配置不太好编写\n\n每个package单独支持test命令，使用yarn workspace run test，坏处是不好统一收集所有代码的测试覆盖率\n\n\n如果采用jest编写测试用例，支持typescript的话，需要初始化配置jest.config.js：\nmodule.exports &#x3D; &#123;\n  preset: &#39;ts-jest&#39;,\n  moduleFileExtensions: [&#39;ts&#39;],\n  testEnvironment: &#39;node&#39;\n&#125;\n\n4 实践总结到这里，基本上已经构建了基于lerna和yarn workspace的monorepo项目的最佳实践了，该有的功能都有：\n\n完善的工作流\n\ntypescript支持\n\n风格统一的编码\n\n完整的单元测试\n\n一键式的发布机制\n\n完美的更新日志\n\n\n……\n当然，构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。\n参考lerna+yarn workspace+monorepo项目的最佳实践5分钟搞懂Monorepo2021年管理Monorepo代码库的11种出色工具\n","slug":"2022-05-23monorepo","date":"2022-05-23T06:45:12.000Z","categories_index":"npm","tags_index":"增效,npm,monorepo","author_index":"陈海龙"},{"id":"a8dbdf02ab5e598ef229ef514965f17c","title":"信标（Beacon ）","content":"Beacon  特点\n接口用于将异步和非阻塞请求发送到服务器。\n请求使用HTTP协议中的POST方法，请求通常不需要响应。\n这个请求被保证在，页面的unload状态从发起到完成之前，被发送。而并不需要一个阻塞请求，例如 XMLHttpRequest 。Beacon  场景发送异步非阻塞数据到服务端为什么是信标？Beacon 接口满足了分析和诊断代码的需要，这些代码通常会尝试在卸载文档之前将数据发送到 web服务器。发送数据的任何过早时机都可能导致错失收集数据的机会。但是，确保在卸载文档期间发送数据是开发人员难以做到的。\n\n用户代理通常会忽略卸载文档处理程序中的异步 XMLHttpRequests 请求。若要解决此问题，为了分析和诊断代码，通常会在 unload (en-US) 事件或 beforeunload (en-US) 事件中创建同步 XMLHttpRequest 请求以提交数据。同步 XMLHttpRequest 请求强制浏览器延迟卸载文档，并使下一个页面跳转看起来较慢。下一页面没有任何办法来避免这种页面加载性能不佳的感觉。\n其他技术其中一种技术是通过创建 Image 元素并在卸载文档处理程序中设置其 src 属性来延迟卸载以提交数据。由于大多数用户代理会延迟文档卸载，以完成挂起的图片加载，因此可以在卸载过程中提交数据。另一种方法是在卸载处理程序中创建一个无操作循环，花费数秒以延迟卸载并将数据提交到服务器。\n但是上述技术不仅代表了较差的编码模式，其中一些还是不可靠的，会导致下一个导航的页面加载性能较差的感觉。信标 API 提供了解决这些问题的标准方法。\n全局环境Beacon API 的 Navigator.sendBeacon() 方法用于在全局浏览上下文中向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。\n生产环境Beacon API的 WorkerNavigator.sendBeacon() 方法用于从 worker global scope 向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或 FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。\n优点\nAPI 提供了解决这些问题的标准方法\n\n缺点\n浏览器兼容性Navigator.sendBeacon().Browser_compatibility表说明了该方法具有相对广泛地实现。但是，WorkerNavigator.sendBeacon().Browser_compatibility数据显示该方法没有被实现。\n\n","slug":"2022-05-23beacon","date":"2022-05-23T03:12:16.000Z","categories_index":"浏览器","tags_index":"浏览器","author_index":"陈海龙"},{"id":"2ed8e0ec0aaa29d8d085170a13236bf8","title":"flutter Bruno","content":"BrunoBruno 是由贝壳「用户体验中心 &amp; 移动端作业组」联合打造的一套企业级移动端 Flutter 组件库，于 12 月 10 日正式开源:\n官网\nPub 地址\nGitHub 仓库\n背景贝壳自 2018 年底开始对 Flutter 的探索和实践，Flutter 落地业务有效地提升了产研效率。但跨业务线协同效率较低，重复劳动力大，代码维护成本高等问题依旧凸显。Bruno 是贝壳针对上述问题在公司内发起的提效专项，致力于打造贝壳标准 Flutter 生态。经过两年的打磨和沉淀，Bruno 现已服务贝壳 B 端全线业务，涵盖 30 多种类型 100+  组件，为近 18 个 App 服务，新增页面组件覆盖率平均达到 80% 以上。\n相信贝壳遇到的问题也是大型团队或者个人开发者不可避免的问题，目前针对该类问题的中后台解决方案层出不穷，但在 Flutter 生态中类似成熟解决方案匮乏。我们希望将贝壳在 Flutter 领域的实践经验回馈给社区，更加完善 Flutter 生态，因此 Bruno 正式开源。\n设计理念Bruno 基于生长、包容、联接的设计理念，赋予组件轻巧灵活、拥抱变化、包容万物的品质。\nBruno 的优势\n适度灵活、充分可扩展\n\nBruno 倡导标准化下的自由、简单、灵活，基于 Flutter 基础组件的封装，使其具备适度灵活，使用组件提效尤为重要。同时组件支持充分可扩展，既可满足多产品的快速接入又能包容特殊场景。\n经过两年的业务实践，我们最终产出了 102 个组件，覆盖类型有 图表、导航、数据录入、操作反馈、内容展示 等。\n2. 连接设计&lt;–&gt;开发\nBruno 基于 Sketch MeaXure 二次开发，实现组件自动识别和标注。开发者可以从设计侧产出的标注稿中清晰的看到页面涵盖的组件，信息无缝传达，高效连接设计与开发。\n3. 主题定制、品牌风格自定义\nBruno 不仅支持全局色号的替换，还支持组件圆角、字体大小、内部间距等属性的定制。在定制全局样式打造自有品牌风格的同时，支持单个组件自定义满足特异化场景需求。\n\n默认基础规范\n\n\n\n\n\n全局样式定制\n\n\n\n单组件样式定制\n\nBruno 还可支持单业务的全局配置，也就是说如果你是组件化工程结构，那么你可以定义每个业务组件的特有风格。\n\n物料承载、教程指引\n\nBruno 官网承载产品设计物料、组件配套文档、Demo 下载、搜索等基础能力，同时配有教程指引开发也可操作 Sketch 插件设计页面，实现零设计资源介入。\nBruno 官网: https://bruno.ke.com\n未来展望\n丰富和完善组件\n\n目前 Bruno 组件涵盖种类可以覆盖常见使用场景，满足企业建立自有品牌形象 App 需求。未来我们会根据业务发展和产品升级不断迭代组件，丰富产品内容提升视觉体验。\n\n提升落地效率\n\n我们不止关注组件的设计与研发，组件落地也是提升产研效率至关重要的环节，因此我们对 Sketch MeaXure 做了二次改造，实现组件自动化标注。同时贝壳产研团队把自动化标注能力线上化，进一步提升组件落地效率。\n3、UI 自动化走查\n贝壳产研团队也在探索 UI 自动化走查方向，期望解放设计侧走查人力，让设计师更多投入对产品的洞察理解，创造优质设计，提升视觉体验。\n","slug":"2022-05-20fluter-bruno","date":"2022-05-20T02:52:49.000Z","categories_index":"flutter","tags_index":"增效,flutter,mobile","author_index":"陈海龙"},{"id":"4250bd0ddd67048179ff9fddd5b6e876","title":"npm开发wiki编辑器问题总结","content":"原架构\n重构后\ntsconfig.ts&#123;\n  &#x2F;&#x2F; 编译选项\n  &quot;compilerOptions&quot;: &#123;\n    &#x2F;&#x2F; 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码\n    &quot;target&quot;: &quot;es5&quot;,\n    &#x2F;&#x2F; 指定要包含在编译中的 library\n    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;90e83adb44&#x2F;lib&#x2F;lib.dom.iterable.d.ts\n    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],\n    &#x2F;&#x2F; 允许 ts 编译器编译 js 文件\n    &quot;allowJs&quot;: true,\n    &#x2F;&#x2F; 跳过类型声明文件的类型检查\n    &quot;skipLibCheck&quot;: true,\n    &#x2F;&#x2F; es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异\n    &quot;esModuleInterop&quot;: true,\n    &#x2F;&#x2F; 允许通过 import x from &#39;y&#39; 即使模块没有显式指定 default 导出\n    &quot;allowSyntheticDefaultImports&quot;: true,\n    &#x2F;&#x2F; 开启严格模式\n    &quot;strict&quot;: true,\n    &#x2F;&#x2F; 对文件名称强制区分大小写\n    &quot;forceConsistentCasingInFileNames&quot;: true,\n    &#x2F;&#x2F; 为 switch 语句启用错误报告\n    &quot;noFallthroughCasesInSwitch&quot;: true,\n    &#x2F;&#x2F; 生成代码的模块化标准\n    &quot;module&quot;: &quot;esnext&quot;,\n    &#x2F;&#x2F; 模块解析（查找）策略\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &#x2F;&#x2F; 允许导入扩展名为.json的模块\n    &quot;resolveJsonModule&quot;: true,\n    &#x2F;&#x2F; 是否将没有 import&#x2F;export 的文件视为旧（全局而非模块化）脚本文件\n    &quot;isolatedModules&quot;: true,\n    &#x2F;&#x2F; 编译时不生成任何JS文件（只进行类型检查）\n    &quot;noEmit&quot;: true,\n    &#x2F;&#x2F; 指定将 JSX 编译成什么形式\n    &quot;jsx&quot;: &quot;react-jsx&quot;\n  &#125;,\n  &#x2F;&#x2F; 指定允许 ts 处理的目录\n  &quot;include&quot;: [&quot;src&quot;]\n&#125;\n&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_62118859&#x2F;article&#x2F;details&#x2F;124543485\nCannot read properties of nullreact.development.js:1621 Uncaught TypeError: Cannot read properties of null\n\n\nahooks  版本\nuseControlledValue\nUncaught SyntaxError: The requested module &#39;&#x2F;node_modules&#x2F;.vite&#x2F;deps&#x2F;ahooks.js?v&#x3D;a7b43f7a&#39; does not provide an export named &#39;useControlledValue&#39; (at index.tsx:2:1)\n\n\n\n\n\n\n\n\n\nDeprecated the useControlledValue naming left over from 1.0, please use useControllableValue insteadv3.0.0-alpha.4\n\n\nuseRequest\n\n\nreact_devtools_backend.js:4026 Warning: Failed prop type: The prop &#96;loadMore&#96; is marked as required in &#96;InfiniteScroll&#96;, but its value is &#96;undefined&#96;.\n\n\n\n\n\n\n\n\n\n\n\nRemoved loadMore related attributes, it is recommended to use useInfiniteScroll to achieve unlimited loading capacity.v3.0.0-alpha.4\n除了 dependencies 和 devDependencies，其他的依赖有什么作用呢\nPre-bundling dependencies:\nreact\nrecoil\nreact-dom\nreact-router-dom\nantd\n(...and 29 more)\n\n本地npm link处理不了依赖冲突\n老版本可以运行\n\n\n\n新版本报错\n原因 ahooks^3.x.x没有v2版本api\n\n\n\n发布安装到项目中测试\n发布\n\n\nnpm 脚本\n&quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;vite --port 3004&quot;,\n    &quot;start&quot;: &quot;yarn build:css &amp;&amp; webpack serve --config config&#x2F;webpack.dev.config.js&quot;,\n    &quot;copy:css&quot;: &quot;cp src&#x2F;**&#x2F;*.css dist&#x2F; &amp;&amp; rsync src&#x2F;styles&#x2F;*.css dist&#x2F;styles&#x2F;&quot;,\n    &quot;build&quot;: &quot;tsc&quot;,\n    &quot;build:css&quot;: &quot;node-sass src&#x2F; -o src&#x2F; &quot;,\n    &quot;prepublishOnly&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,\n    &quot;t&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,\n    &quot;push:beta&quot;: &quot;npm publish --tag beta&quot;\n  &#125;,\n\n执行脚本$ yarn push:beta\n\n发布结果\n\n\n\n## Current Tags\n\n\n*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           beta (a few seconds ago)\n*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           latest (a few seconds ago)\n\n\n\n\n图片没有渲染，修改，打包重新发布0.0.1-220519beta版本测试slate-wiki@0.0.1-220519beta\n\nnpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; \nnpm notice name:          @ty-fe&#x2F;slate-wiki                     \nnpm notice version:       0.0.1-220519beta                        \nnpm notice filename:      @ty-fe&#x2F;slate-wiki-0.0.1-220519beta.tgz\nnpm notice package size:  228.0 kB                                \nnpm notice unpacked size: 1.2 MB                                  \nnpm notice shasum:        a2991de4933a9e5039ceb7082c5e0a80c2db828c\nnpm notice integrity:     sha512-iHQKpR2LM+F6Z[...]XDN40tHfwMxNg&#x3D;&#x3D;\nnpm notice total files:   417                                     \nnpm notice \n+ @ty-fe&#x2F;slate-wiki@0.0.1-220519beta\n✨  Done in 16.36s.\n\n\nslate-wiki-pro@0.0.1-220519beta\n\nnpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; \nnpm notice name:          @ty-fe&#x2F;slate-wiki-pro                     \nnpm notice version:       0.0.1-220519beta                            \nnpm notice filename:      @ty-fe&#x2F;slate-wiki-pro-0.0.1-220519beta.tgz\nnpm notice package size:  83.5 kB                                     \nnpm notice unpacked size: 413.7 kB                                    \nnpm notice shasum:        85cbe6fbffafc75db16e02427d1eac9b6a906ec3    \nnpm notice integrity:     sha512-3viVco6ssb2N3[...]xxisHN9+qYnCA&#x3D;&#x3D;    \nnpm notice total files:   205                                         \nnpm notice \n+ @ty-fe&#x2F;slate-wiki-pro@0.0.1-220519beta\n✨  Done in 14.68s.\n\n\n问题\n传染性slate-wiki-pro,依赖于slate-wiki。slate-wiki改动，项目依赖slate-wiki-pro，需要发slate-wiki和slate-wiki-pro，项目要安装slate-wiki-pro\n\n是否可以让项目直接依赖slate-wiki、slate-wiki-pro改动哪个发布哪个，互不影响？\n\n项目很卡\n\n将slate、slate-wiki、slate-wiki-pro使用umd资源，避免重复编译是否可以？\n\n依赖贼多\n\n[######--------------------------------------------------] 49992&#x2F;102014\n\n\n启动没有想象中那么快了\n\nvite预编译时间过长  130262ms &#x2F; 1000 &#x2F; 60 大概两分钟，加载编译大概几分钟，慢的吓人\n\nvite v2.7.1 dev server running at:\n\n&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;\n&gt; Network: use &#96;--host&#96; to expose\n\nready in 130262ms.  #首次编译\n\n\n\nvite v2.7.1 dev server running at:\n\n&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;\n&gt; Network: use &#96;--host&#96; to expose\n\nready in 43312ms. #非首次编译\n\n\n代码放仓库\nslate-wiki\n\n\nCommand line instructionsYou can also upload existing files from your computer using the instructions below.\nGit global setup\ngit config --global user.name &quot;陈海龙&quot;\ngit config --global user.email &quot;haotian.chen@ty.com&quot;\nCreate a new repository\ngit clone ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git\ncd slate-wiki\ntouch README.md\ngit add README.md\ngit commit -m &quot;add README&quot;\nPush an existing folder\ncd existing_folder\ngit init\ngit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git\ngit add .\ngit commit -m &quot;Initial commit&quot;\nPush an existing Git repository\ncd existing_repo\ngit remote rename origin old-origin\ngit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git\n\n\nslate-wiki-pro略\n\n深入了解打包，本站请搜npm 版本的依赖\nreact-codemirror使用版本react16,插件及项目使用react18react-dom.development.js:22738 Uncaught TypeError: cm is not a function\n    at UnControlled.componentDidMount (react-codemirror.tsx:718:19)\n    at commitLayoutEffectOnFiber (react-dom.development.js:23204:30)\n    at commitLayoutMountEffects_complete (react-dom.development.js:24578:9)\n    at commitLayoutEffects_begin (react-dom.development.js:24564:7)\n    at commitLayoutEffects (react-dom.development.js:24502:3)\n    at commitRootImpl (react-dom.development.js:26779:5)\n    at commitRoot (react-dom.development.js:26638:5)\n    at performSyncWorkOnRoot (react-dom.development.js:26073:3)\n    at flushSyncCallbacks (react-dom.development.js:12009:22)\n    at flushSyncCallbacksOnlyInLegacyMode (react-dom.development.js:11988:5)\n\n\nvite 关于 global is not defined 问题react-codemirror2 源码\ndeclare let global: any;\ndeclare let require: any;\n\nconst SERVER_RENDERED &#x3D; (typeof navigator &#x3D;&#x3D;&#x3D; &#39;undefined&#39; || (typeof global !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; global[&#39;PREVENT_CODEMIRROR_RENDER&#39;] &#x3D;&#x3D;&#x3D; true));\n\nlet cm;\nif (!SERVER_RENDERED) &#123;\n  cm &#x3D; require(&#39;codemirror&#39;);\n&#125;\n\n\nvite 404Could not load content for http:&#x2F;&#x2F;localhost:3005&#x2F;node_modules&#x2F;@tuya-fe&#x2F;slate-wiki&#x2F;src&#x2F;slate&#x2F;3rd&#x2F;react-codemirror.tsx \n\n(HTTP error: status code 404, net::ERR_HTTP_RESPONSE_CODE_FAILURE)\n\ntodo\ncodemirror 在vite中运行报错，codemirror找不到，webpack打包正常\n\n","slug":"2022-05-19npm-pkg","date":"2022-05-19T10:34:53.000Z","categories_index":"npm","tags_index":"npm,wiki","author_index":"陈海龙"},{"id":"2bd0e979bc9d9166a8f1986cef49a4e4","title":"npm 版本的依赖","content":"前言提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。\nnpm 安装机制A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。\nA 和 B 同时依赖 C，这个包会被安装在哪里呢？假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。\b执行完毕后，我们会看到 ./node_modules 这层目录只含有这两个子目录：\nnode_modules&#x2F; \n├─┬ A \n│ ├── C \n├─┬ B \n│ └── C \n如果使用 npm 3 来进行安装的话，./node_modules 下的目录将会包含三个子目录：\nnode_modules&#x2F; \n├─┬ A \n├─┬ B \n├─┬ C \n为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：\nnpm 2 和 npm 3 模块安装机制的差异虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异。\nnpm 2 在安装依赖包时，采用\b简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。\b执行完毕后，我们会看到 .&#x2F;node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：\n\n这样的目录有较为明显的好处：\n1）层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录；\n2）在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置；\n3）如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录；\n但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 npm install 后，D 会被重复下载三次，而随着我们的项目越来越复杂，node_modules 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；\n为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。\nnpm 3 对于同一依赖的不同版本会怎么处理呢？npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):\n\n但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：\n\n由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。\n为什么会出现 package-lock.json 呢？为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。\npackage.json 的不足之处npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因：\n1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 A: &#39;^1.0.5&#39; ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug；\n2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 A: &#39;1.0.5&#39; 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。\n针对 package.json 不足的解决方法为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。\npackage-lock.json 文件的结构package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 package-lock-json官方文档，主要的结构如下：\n\nversion ：包版本，即这个包当前安装在 node_modules 中的版本\n\nresolved ：包具体的安装来源\n\nintegrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效\n\nrequires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同\n\ndependencies ：结构和外层的 dependencies 结构相同，存储安装在子依赖 node_modules 中的依赖包\n\n\n需要注意的是，并不是所有的子依赖都有 dependencies 属性，只有子依赖的依赖和当前已安装在根目录的 node_modules 中的依赖冲突之后，才会有这个属性。\npackage-lock.json 文件的作用在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；\nnode_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。\n由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。\n在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。\n依赖的区别与使用场景npm 目前支持以下几类依赖包管理包括\ndependencies\n\ndevDependencies\n\noptionalDependencies 可选择的依赖包\n\npeerDependencies 同等依赖\n\nbundledDependencies 捆绑依赖包\n\n\n下面我们来看一下这几种依赖的区别以及各自的应用场景：\ndependenciesdependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 npm install XXX --save 下载 dependencies 中的包；\n&quot;devDependencies&quot;:&#123;\n  &quot;eslint&quot;: &quot;^5.0.0&quot;,\n  &quot;debug&quot;: &quot;^3.1.0&quot;,\n&#125;\n\n\ndevDependenciesdevDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 npm install packageName --save-dev 下载的包都会在 devDependencies 对象中；\ndependencies 和 devDependencies 最大的区别是在打包运行时，执行 npm install 时默认会把所有依赖全部安装，但是如果使用 npm install --production 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。\noptionalDependenciesoptionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。\noptionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。\ntry &#123; \n  var axios &#x3D; require(&#39;axios&#39;) \n  var fooVersion &#x3D; require(&#39;axios&#x2F;package.json&#39;).version \n&#125; catch (er) &#123; \n  foo &#x3D; null \n&#125; \n&#x2F;&#x2F; .. then later in your program .. \nif (foo) &#123; \n  foo.doFooThings() \n&#125; \n\n\npeerDependenciespeerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 ant-design@3.x 的 package.json 中的配置如下：\n&quot;peerDependencies&quot;: &#123; \n  &quot;react&quot;: &quot;&gt;&#x3D;16.9.0&quot;, \n  &quot;react-dom&quot;: &quot;&gt;&#x3D;16.9.0&quot; \n &#125;, \n假设我们创建了一个名为 project 的项目，在此项目中我们要使用 ant-design@3.x 这个插件，此时我们的项目就必须先安装 React &gt;&#x3D; 16.9.0 和 React-dom &gt;&#x3D; 16.9.0 的版本。\n在 npm 2 中，当我们下载 ant-design@3.x 时，peerDependencies 中指定的依赖会随着 ant-design@3.x 一起被强制安装，所以我们不需要在宿主项目的 package.json 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖；\nbundledDependencies这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：\n&#123; \n  &quot;name&quot;: &quot;project&quot;, \n  &quot;version&quot;: &quot;1.0.0&quot;, \n  &quot;bundleDependencies&quot;: [ \n    &quot;axios&quot;,  \n    &quot;lodash&quot; \n  ] \n&#125; \n当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 npm install project-1.0.0.tgz 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。\n&quot;bundleDependencies&quot;: [ \n    &quot;axios&quot;, \n    &quot;lodash&quot; \n  ], \n&quot;dependencies&quot;: &#123; \n  &quot;axios&quot;: &quot;*&quot;, \n  &quot;lodash&quot;: &quot;*&quot; \n&#125;, \n如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。\n总结本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。\n参考文献\n原文\npackage.json官方文档\npackage-lock-json官方文档\nnpm文档总结\nnpm-pack\n\n","slug":"2022-05-19npm","date":"2022-05-19T10:10:47.000Z","categories_index":"npm","tags_index":"工具,npm","author_index":"陈海龙"},{"id":"72e60ad0a93fafff72edb1b0852502a0","title":"TypeScript noEmit","content":"No Emit -noEmitDo not emit compiler output files like JavaScript source code, source-maps or declarations.不要发出编译器输出文件，如JavaScript源代码、源映射或声明。\nThis makes room for another tool like Babel, or swc to handle converting the TypeScript file to a file which can run inside a JavaScript environment.\nYou can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.\n导致outDir不输出\n","slug":"2022-05-18ts","date":"2022-05-18T08:55:53.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"陈海龙"},{"id":"38b6e3ab42ce78e34a964ff2e90b3a7d","title":"Slate 学习","content":"文档slate 中文文档slate 英文文档\n是什么\n\n\n\n\n\n\n\n\nSlate 是一个 完全 可定制的富文本编辑框架。通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。\n能做什么\n\n\n\n\n\n\n\n\n通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。Slate 之所以能做到这一点，是因为它的所有逻辑都是通过一系列的插件实现的。这样，你就再也不会被某项特性 在 或 不在 编辑器【核心】边界之内的问题所困扰了。你可以将它理解为在 React 和 Immutable 基础上，一种可插拔的 contenteditable 实现。另外，它的灵感来自于 Draft.js，Prosemirror 和 Quill 等类库。\n产生的背景\n\n\n\n\n\n\n\n\n为什么发明 Slate 呢？好吧…（注意，这部分内容包含了一些我的个人观点！）\n\n\n\n\n\n\n\n\n\n在发明 Slate 之前，我尝试了许多不同的富文本编辑器。我发现虽然它们在编写简单示例时基本没有问题，但一旦想要构建一些类似 Medium、Dropbox Paper 或者 Google Docs 这样的内容，你就会发现一些深层次的问题，比如…\n\n\n\n\n\n\n\n\n\n编辑器硬编码了文档的结构规范，难以定制。类似加粗和斜体的结构可以开箱即用，但评论、嵌入内容以及更多的定制性需求呢？\n\n\n\n\n\n\n\n\n\n对文档的编程式变换非常错综复杂。用户的编写体验可能不错，但在执行编程式变更时却不必要地复杂，而这对于构建高级的编辑行为至关重要。\n\n\n\n\n\n\n\n\n\n对 HTML、Markdown 等内容的序列化支持看起来像是事后加上的。这是一个非常常见的使用场景，但要实现将文档转换为 HTML 或 Markdown 的简单功能都需要编写大量的模板代码。\n\n\n\n\n\n\n\n\n\n重新学习一个新的视图层效率不高且十分受限。各种编辑器在重新发明视图层的轮子，而非使用 React 这样已有的技术方案。你必须学习一套带着自有限制和陷阱的新系统。\n\n\n\n\n\n\n\n\n\n**对协同编辑没有预先设计好的支持**。编辑器内部的数据结构使其无法用于实时、协作的编辑场景中，除非重写编辑器。\n\n\n\n\n\n\n\n\n\n代码仓库是单体的，而非小而可复用的。许多编辑器没有对外开放本应为开发者所复用的内部工具，以至于不得不重新发明轮子。\n\n\n\n\n\n\n\n\n\n无法构建复杂而存在嵌套关系的文档。不少编辑器是围绕简单的【扁平】文档结构设计的，这使得表格、嵌入内容和字幕等内容难以理解，有时甚至无法实现。\n\n\n\n\n\n\n\n\n\n当然，并非所有的编辑器都存在以上的问题，但如果你已经尝试过一些编辑器，你可能已经踩过类似的坑了。为了摆脱它们在 API 上的限制来达到你期望的用户体验，你得使用各种奇技淫巧，有些体验甚至是完全无法实现的。\n\n\n\n\n\n\n\n\n\n如果你遇到了相似的问题，那么也许你会喜欢上 Slate。让我来介绍一下 Slate 是如何解决这些问题的吧…\n提供了什么能力\n\n\n\n\n\n\n\n\nSlate 尝试通过一些原则来解决 “Why?” 这一节中\b的问题：\n\n\n\n\n\n\n\n\n\n作为一等公民的插件。 在 Slate 中最重要的一点是，插件是一等公民（first-class）的实体——甚至连编辑器的核心逻辑都是通过插件实现的。这意味着你能够 完全地 定制编辑体验，构建出对标 Medium 和 Canvas 那样的复杂编辑器，而无需对抗各种类库的预设条件。\n\n\n\n\n\n\n\n\n\n精简 Schema 的核心。 Slate 的核心逻辑并不对你所编辑的数据结构做任何假设，这意味着你在需要应对复杂场景时不会被编辑器预置的内容所束缚（译者注：此处 Schema 可理解为类似 XML Schema 的文档结构规范）。\n\n\n\n\n\n\n\n\n\n支持嵌套的文档模型。 Slate 所使用的文档模型是一棵嵌套的、递归的树，和 DOM 本身十分接近。这使得构建表格和嵌套引用等能够满足进阶需求的复杂组件成为了可能。当然，你同样可以使用单一的层级关系以保证简单性。\n\n\n\n\n\n\n\n\n\n无状态、不可变的数据。 通过使用 React 和 Immutable.js，我们是基于不可变数据结构，以无状态的方式构建 Slate 编辑器的。这大大降低了理解代码的难度，也节约了大量开发插件的时间。\n\n\n\n\n\n\n\n\n\n直观的 changes。 Slate 中的内容是通过 “change” 来编辑的，这是一种被设计为支持高阶使用，且极其符合直觉的概念。这样，我们就能够通过它来尽可能简单地编写插件和自定义功能了。\n\n\n\n\n\n\n\n\n\n**为协同编辑准备的数据模型**。 Slate 使用的数据模型——尤其是由 change 更改文档的方式——在设计时就已考虑到对协同编辑的支持。所以，如果你决定为编辑器添加协作功能，你不需要进行彻底的重构。（当然，这还需要你投入更多的努力！）\n\n\n\n\n\n\n\n\n\n明确的【核心】边界划分。 通过插件优先的架构与精简 Schema 的内核，Slate 对于【核心】和【自定义】有着明确得多的划分，从而保证核心的编辑体验不会为各种边缘情况所困扰。\n协同编辑，这个后面会持续关注slate-yjsyjs\nslate 文档不是很多，半小时看完主要内容 \n\n插件定制化\n渲染节点定制化\n按键监听处理\n数据格式编码、反编码\n数据存储\n\n就这点东西😱竟然有些同学凭借slate的使用拿了3.75,赶紧学～\n","slug":"2022-04-29slate-lean","date":"2022-05-16T13:00:00.000Z","categories_index":"wiki","tags_index":"wiki","author_index":"陈海龙"},{"id":"deffdaaa2a24a19ee257667b3b36743c","title":"设计模式","content":"先聊用到过哪些，背后的设计模式是什么\n实例化一个 axios 实例，全局都来使用它 单例模式\n兄弟组件通信,事件监听 观察者模式\n构造函数继承、类的继承 构造函数模式\n实例化不同的实例 工厂模式\n优化中的事件代理代理模式\nesm、commonjs模块模式\n\n熟悉而又陌生：熟悉的是一直在用，陌生的是学名竟然是这些。我都有点怀疑了，这是真的吗？是真的吗？～～～\n\n   来～来～来～，我们继续。。。\n\n啥呀\n\n\n\n\n\n\n\n\n“设计模式(英语 design pattern)是对面向对象设计中反复出现的问题的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的。”\n策略模式代理模式\n作用：访问控制\n场景：事件代理、Proxy、Object.defineProperty\n\n单例模式\n定义：唯一实例，全局可访问\n场景：请求实例、全局缓存、线程池、window 对象、登录浮框\n实现：已经创建过的直接返回，不重复创建\n\n工厂模式\n作用：创建同一类对象\n分类：简单工厂_、_方法工厂\n\n1. 简单工厂\n例如：项目中根据用户权限渲染不同的页面，在不同权限等级用户的构造函数中，保存用户可以看到的页面\n优点：一个正确的参数，就可以获取到所需要的对象，无需知道其创建的具体细节\n缺点：函数会成为一个超级函数，难以维护，简单工厂适用于创建少量对象，对象的逻辑不能复杂\n\n2. 工厂方法\n本质：将创建对象的工作，推迟到子类中，这样核心类就变成抽象类\n\nlet UserFactory &#x3D; function (type) &#123;\n  if (this instanceof UserFactory) &#123;\n    return new this[type]();\n  &#125; else &#123;\n    return new UserFactory(type);\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 工厂方法，函数的原型中设置所有对象的构造函数\n\nUserFactory.prototype &#x3D; &#123;\n  SuperAdmin: function () &#123;\n    this.name &#x3D; &quot;超级管理员&quot;;\n    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;, &quot;应用管理&quot;, &quot;权限管理&quot;];\n  &#125;,\n  Admin: function () &#123;\n    this.name &#x3D; &quot;管理员&quot;;\n    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;];\n  &#125;,\n  NormalUser: function () &#123;\n    this.name &#x3D; &quot;普通用户&quot;;\n    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;];\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 调用\nlet superAdmin &#x3D; new UserFactory(&quot;SuperAdmin&quot;);\nlet admin &#x3D; new UserFactory(&quot;Admin&quot;);\nlet normalUser &#x3D; new UserFactory(&quot;NormalUser&quot;);\n\n3. 抽象工厂\n\n\n构造函数模式👀 观察者模式\n定义： 对象间的一种一对多的依赖关系\n作用：一个对象状态发生变化时，所有依赖他的对象，都将得到通知\n优点：解耦\n组成：发布者、订阅者\n场景：事件监听、eventBus\n\ndocument.body.addEventListener(&quot;click&quot;, function () &#123;&#125;, false);\n\n混合模式模块模式\n作用：避免全局污染，按需暴露\n实现：多采用闭包\n\nvar Person &#x3D; (function () &#123;\n  var name &#x3D; &quot;xxx&quot;;\n  function sayName(params) &#123;\n    console.log(name);\n  &#125;\n  return &#123;\n    name,\n    sayName,\n  &#125;;\n&#125;)();\n","slug":"2022-05-13design_mode","date":"2022-05-13T09:01:15.000Z","categories_index":"前端","tags_index":"前端,设计模式","author_index":"陈海龙"},{"id":"e2b55be84d65cc914ce2f0d3a3e083d3","title":"ant design form设置值 !== 获取值","content":"有意思的事\n今天维护项目遇到一个有意思的事，直观感受，设置值，再取出来，貌似没毛病  &#x2F;&#x2F; ...\n  const [values, setValues] &#x3D; useState&lt;Record&lt;string, any&gt;&gt;()\n\n  const &#123; applyStartTime, applyEndTime, attendanceType, staffId &#125; &#x3D; values || &#123;&#125;\n\n  const getDetail &#x3D; usePersistFn(async () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...略\n    const obj: Record&lt;string, any&gt; &#x3D; &#123;\n      staffId: applyStaff.staffId,\n      attendanceType: res.result.attendanceType,\n      applyStartTime: &#123;\n        value: moment(res.result.applyStartTime),\n        half: res.result.startDayType,\n      &#125;,\n      applyEndTime: &#123;\n        value: moment(res.result.applyEndTime),\n        half: res.result.endDayType,\n      &#125;,\n      applyReason,\n      applyAttachments,\n    &#125;\n    &#x2F;&#x2F; ...略\n    form.setFieldsValue(obj)\n    setValues(form.getFieldsValue())\n  &#125;)\n\n  &#x2F;&#x2F; ...略\n  const &#123; total, loading: totalLoading &#125; &#x3D; useCaculateDays(\n    &#123;\n      start: applyStartTime,\n      end: applyEndTime,\n    &#125;,\n    staffId,\n    attendanceType,\n  )\n  &#x2F;&#x2F; ...略\n\n  &#x2F;&#x2F; AnualForm组件\n  &lt;Form.Item name&#x3D;&quot;applyStartTime&quot; label&#x3D;&quot;起始日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;\n      &lt;HalftDatePicker predict&#x3D;&#123;&#123; lessThan: end?.value &#125;&#125; &#x2F;&gt;\n    &lt;&#x2F;Form.Item&gt;\n  &lt;Form.Item name&#x3D;&quot;applyEndTime&quot; label&#x3D;&quot;结束日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;\n    &lt;HalftDatePicker predict&#x3D;&#123;&#123; moreThan: start?.value &#125;&#125; &#x2F;&gt;\n  &lt;&#x2F;Form.Item&gt;\n\n\n  type IValue &#x3D; &#123;\n    value?: moment.Moment\n    half: 1 | 2\n  &#125;\n &#x2F;&#x2F; HalftDatePicker组件\nconst HalftDatePicker: React.ForwardRefRenderFunction&lt;any, PickerProps&lt;moment.Moment&gt; &amp; &#123;\n  value?: IValue\n  onChange?: (v?: IValue) &#x3D;&gt; void\n  predict?: &#123;\n    lessThan?: moment.Moment\n    moreThan?: moment.Moment\n    holiday?: boolean\n  &#125;\n&#125;&gt; &#x3D; (props, ref) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...略\n&#125;\n\n代码的目的是： \n\n请求详情\n装配数据，更新values\nuseCaculateDays 通过后台动态计算有效工作日，返回total请假天数，\n渲染total到表单对应位置\n\n调试经过一点一点回溯调试，发现 useCaculateDays 没请求，被判断拦截掉了，往上找找，\nform.setFieldsValue(obj)\nsetValues(form.getFieldsValue())\n\n打上日志&#x2F;&#x2F; ...略\nconsole.log(&quot;obj&quot;,obj);\nform.setFieldsValue(obj)\nconsole.log(&quot;obj1&quot;,form.getFieldsValue());\nsetValues(obj)\n\n发现obj键值内容不等于obj1\n\nobj\n\n&#123;\n    &quot;staffId&quot;: &quot;02333&quot;,\n    &quot;attendanceType&quot;: 11,\n    &quot;applyStartTime&quot;: &#123;\n        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,\n        &quot;half&quot;: 1\n    &#125;,\n    &quot;applyEndTime&quot;: &#123;\n        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,\n        &quot;half&quot;: 2\n    &#125;,\n    &quot;applyReason&quot;: &quot;&quot;,\n    &quot;applyAttachments&quot;: []\n&#125;\n\n\nobj1&#123;\n    &quot;staffId&quot;: &quot;02333&quot;,\n    &quot;attendanceType&quot;: 11,\n    &quot;applyReason&quot;: &quot;&quot;,\n    &quot;applyAttachments&quot;: []\n&#125;\n\n猜想\n\n会不会form.setFieldsValue异步？查了下api是同步的排除这种可能\n断点调试过程中，也会遇到表单渲染一半的情况，AnualForm组件是条件渲染，如果这块表单没有渲染出来，通过form.getFieldsValue就拿不到\n\n修改代码验证下猜想console.log(&quot;obj&quot;,obj);\nform.setFieldsValue(obj)\nconsole.log(&quot;obj1&quot;,form.getFieldsValue());\nsetTimeout(() &#x3D;&gt; &#123;\n  setValues(form.getFieldsValue())\n  &#125;, 5000);\n&#125;\n\n\n最终修改form.setFieldsValue(obj)\nsetValues(obj)","slug":"2022-05-13react","date":"2022-05-13T07:39:33.000Z","categories_index":"React","tags_index":"React,bug","author_index":"陈海龙"},{"id":"f31094f49d8642b9a610a9630bcdbff8","title":"ModHeader","content":"通过不同请求头字段标识请求不同的环境\n\nRequesr HeadersAccept: *&#x2F;*\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,zh-TW;q&#x3D;0.7\nCache-Control: no-cache\nConnection: keep-alive\ncontent-type: application&#x2F;json; charset&#x3D;utf-8\nCookie: perfLang&#x3D;zh; \nenvtag: ladon-1        \nHost: localhost:3119\nPragma: no-cache\nReferer: http:&#x2F;&#x2F;localhost:3119&#x2F;\nsec-ch-ua: &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Chromium&quot;;v&#x3D;&quot;101&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;101&quot;\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: &quot;macOS&quot;\n不生效了理论上是没问题，应该是由于某些原因导致这个插件内部运行出了问题，具体什么问题不知处理：将浏览器重启动后,请求头envtag: ladon-1增加成功\n","slug":"2022-05-13modeheader","date":"2022-05-13T06:59:19.000Z","categories_index":"Chrome","tags_index":"工具,Chrome","author_index":"陈海龙"},{"id":"b4153b96463af3b17371df43a1c660ca","title":"浏览器首屏优化-首屏时间获取","content":"优化的指标白屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器出现第一个元素首屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器第一屏渲染完成\n影响白屏时间的因素：网络，服务端性能，前端页面结构设计。影响首屏时间的因素：白屏时间，资源下载执行时间。\n通常在 head 解析完，body 开始渲染此时是白屏结束白屏时间 &#x3D; firstPaint - performance.timing.navigationStart || pageStartTime\n常用方法\n首屏模块标签标记， 你觉得首屏完成的地方插入脚本\n同级首屏内加载最慢的图片&#x2F;iframe\n\n这个图看不懂没关系，往下看，后面会以简书代码和掘金来验证这幅图的正确性\n\n输入 url 发生了什么\n1、当浏览器地址中输入 url 后，navigationStart如果之前有前一个网页（与当前页面不一定同域）unload 的时间戳,如果无前一个网页 unload ，则与 fetchStart 值相等,\n2、接着，是否有重定向（redirect ）\n3、接着，准备用 HTTP 抓取文档的内容（fetchStart）\n域名查询（domainLookupStart、domainLookupEnd）\nTCP 连接（connectStart、connectEnd）,如果是安全链接，在 connectEnd 之前，会有 SSL 连接(secureConnectionStart)\n\n\n4、接着，HTTP 请求（requestStart、responseStart、responseEnd）,如果有缓存，在 responseStart 之前，会有 cacheStart，如果之前有网页，还涉及到网页的 unload，在 cacheStart 之前，会有unloadStart、unloadEnd\n5、接着，dom 解析\ndomLoadingDocument.readyState 变为 loading，并将抛出 readystatechange 相关事件\ndomInteractiveDocument.readyState 变为 interactive，并将抛出 readystatechange 相关事件\ndomContentLoadedEventStart、domContentLoadedEventEnd DOM 解析完成后，\n网页内资源加载开始，并将抛出 readystatechange 相关事件\n网页内资源加载完成，并将抛出 readystatechange 相关事件\n\n\nloadEventStartload 事件发送给文档，也即 load 回调函数开始执行\nloadEventEndload 事件的回调函数执行完毕的时间\ndomCompleteDocument.readyState 变为 complete，并将抛出 readystatechange 相关事件\n说明：dom 解析过程，HTML 生成 dom 树，解析 CSS 文件生成 CSSOM 树，DOM 树和 CSSOM 树生成 render 树，也就是渲染树， render 树中对每个节点进行布局，计算每个元素的大小，确定其在屏幕中的位置，绘制。根据 render 树和布局将显示页面\n\n\n\n加载阶段左边红线代表的是网络传输层面的过程，右边红线代表了服务器传输回字节后浏览器的各种事件状态，这个阶段包含了浏览器对文档的解析，DOM 树构建，布局，绘制等等。1. prompt for unload\n\nnavigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。2. 前一个网页卸载\nunloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。\nunloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。3. 重定向\nredirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。\nredirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。4. 使用 HTTP 请求\nfetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。5. 域名解析\ndomainLookupStart&#x2F;domainLookupEnd: DNS 域名查询开始&#x2F;结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等6. tcp 链接\nconnectStart: HTTP（TCP）开始&#x2F;重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。\nconnectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。7. ssl 建立\nsecureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。8. 读取文档\nrequestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。9. 响应\nresponseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。\nresponseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。10. 解析 dom\ndomLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。11. dom 可交互\ndomInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。12. 页面内资源加载\ndomContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。\ndomContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。13. dom 树解析完成\ndomComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。14. load 事件\nloadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。\nloadEventEnd: load 事件的回调函数执行完毕的时间。\n\nPerformance 接口Performance 接口可以获取到当前页面与性能相关的信息。\n\n\n\n\n\n\nTIP\n数据先不要关注时间循序，后面我们会从多个角度来验证顺序\n\n&#123;\n  &quot;timeOrigin&quot;: 1652338539312.5,\n  &#x2F;&#x2F; 顺序已经排好了\n  &quot;timing&quot;: &#123;\n    &#x2F;&#x2F; 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等\n    &quot;navigationStart&quot;: 1652338539312,\n    &#x2F;&#x2F; 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0\n    &quot;redirectStart&quot;: 0,\n    &#x2F;&#x2F; 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0\n    &quot;redirectEnd&quot;: 0,\n    &#x2F;&#x2F; 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前\n    &quot;fetchStart&quot;: 1652338539316,\n    &#x2F;&#x2F; DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n    &quot;domainLookupStart&quot;: 1652338539353,\n    &#x2F;&#x2F; DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n    &quot;domainLookupEnd&quot;: 1652338539353,\n    &#x2F;&#x2F; HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等\n    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间\n    &quot;connectStart&quot;: 1652338539353,\n    &#x2F;&#x2F; HTTPS 连接开始的时间，如果不是安全连接，则值为 0\n    &quot;secureConnectionStart&quot;: 1652338539401,\n    &#x2F;&#x2F; HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等\n    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间\n    &#x2F;&#x2F; 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过\n    &quot;connectEnd&quot;: 1652338539504,\n    &#x2F;&#x2F; HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存\n    &#x2F;&#x2F; 连接错误重连时，这里显示的也是新建立连接的时间\n    &quot;requestStart&quot;: 1652338539505,\n    &#x2F;&#x2F; HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存\n    &quot;responseStart&quot;: 1652338539807,\n    &#x2F;&#x2F; 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0\n    &quot;unloadEventStart&quot;: 0,\n    &#x2F;&#x2F; 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳\n    &quot;unloadEventEnd&quot;: 0,\n    &#x2F;&#x2F; HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存\n    &quot;responseEnd&quot;: 1652338539828,\n    &#x2F;&#x2F; 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件\n    &quot;domLoading&quot;: 1652338539823,\n    &#x2F;&#x2F; 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件\n    &#x2F;&#x2F; 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源\n    &quot;domInteractive&quot;: 1652338540574,\n    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载开始的时间\n    &#x2F;&#x2F; 在 DOMContentLoaded 事件抛出前发生\n    &quot;domContentLoadedEventStart&quot;: 1652338540574,\n    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）\n    &quot;domContentLoadedEventEnd&quot;: 1652338540575,\n    &#x2F;&#x2F; load 事件发送给文档，也即 load 回调函数开始执行的时间\n    &#x2F;&#x2F; 注意如果没有绑定 load 事件，值为 0\n    &quot;loadEventStart&quot;: 1652338542489,\n    &#x2F;&#x2F; load 事件的回调函数执行完毕的时间\n    &quot;loadEventEnd&quot;: 1652338542492,\n    &#x2F;&#x2F; DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件\n    &quot;domComplete&quot;: 1652338542489\n  &#125;,\n  &quot;navigation&quot;: &#123;\n    &#x2F;&#x2F; 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）\n    &#x2F;&#x2F; 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面\n    &#x2F;&#x2F; 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）\n    &#x2F;&#x2F; 255 即 TYPE_UNDEFINED    非以上方式进入的页面\n    &quot;type&quot;: 0,\n    &quot;redirectCount&quot;: 0 &#x2F;&#x2F; &#x2F;&#x2F; 如果有重定向的话，页面通过几次重定向跳转而来\n  &#125;\n&#125;\n\nfunction getPerfermanceTiming() &#123;\n  let t &#x3D; performance.timing;\n\n  &#x2F;&#x2F; 重定向结束时间 - 重定向开始时间\n  let redirect &#x3D; t.redirectEnd - t.redirectStart;\n  &#x2F;&#x2F; DNS 查询开始时间 - fetech start 时间\n  let appCache &#x3D; t.domainLookupStart - t.fetchStart;\n  &#x2F;&#x2F; DNS 查询结束时间 - DNS 查询开始时间\n  let dns &#x3D; t.domainLookupEnd - t.domainLookupStart;\n  &#x2F;&#x2F; 完成 TCP 连接握手时间 - TCP 连接开始时间\n  let tcp &#x3D; t.connectEnd - t.connectStart;\n  &#x2F;&#x2F; 从请求开始到接收到第一个响应字符的时间\n  let ttfb &#x3D; t.responseStart - t.requestStart;\n  &#x2F;&#x2F; 资源下载时间，响应结束时间 - 响应开始时间\n  let contentDL &#x3D; t.responseEnd - t.responseStart;\n  &#x2F;&#x2F; 从请求开始到响应结束的时间\n  let httpTotal &#x3D; t.responseEnd - t.requestStart;\n  &#x2F;&#x2F; 从页面开始到 domContentLoadedEventEnd\n  let domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;\n  &#x2F;&#x2F; 从页面开始到 loadEventEnd\n  let loaded &#x3D; t.loadEventEnd - t.navigationStart;\n\n  let result &#x3D; [\n    &#123; key: &quot;Redirect&quot;, desc: &quot;网页重定向的耗时&quot;, value: redirect &#125;,\n    &#123; key: &quot;AppCache&quot;, desc: &quot;检查本地缓存的耗时&quot;, value: appCache &#125;,\n    &#123; key: &quot;DNS&quot;, desc: &quot;DNS查询的耗时&quot;, value: dns &#125;,\n    &#123; key: &quot;TCP&quot;, desc: &quot;TCP连接的耗时&quot;, value: tcp &#125;,\n    &#123;\n      key: &quot;Waiting(TTFB)&quot;,\n      desc: &quot;从客户端发起请求到接收到响应的时间 &#x2F; Time To First Byte&quot;,\n      value: ttfb,\n    &#125;,\n    &#123;\n      key: &quot;Content Download&quot;,\n      desc: &quot;下载服务端返回数据的时间&quot;,\n      value: contentDL,\n    &#125;,\n    &#123; key: &quot;HTTP Total Time&quot;, desc: &quot;http请求总耗时&quot;, value: httpTotal &#125;,\n    &#123;\n      key: &quot;DOMContentLoaded&quot;,\n      desc: &quot;dom加载完成的时间&quot;,\n      value: domContentloaded,\n    &#125;,\n    &#123; key: &quot;Loaded&quot;, desc: &quot;页面load的总耗时&quot;, value: loaded &#125;,\n  ];\n  return result;\n&#125;\ngetPerfermanceTiming();\n\n\n\n聊下性能计算&#x2F;&#x2F; 计算加载时间\nfunction getPerformanceTiming() &#123;\n  var performance &#x3D; window.performance;\n\n  if (!performance) &#123;\n    &#x2F;&#x2F; 当前浏览器不支持\n    console.log(&quot;你的浏览器不支持 performance 接口&quot;);\n    return;\n  &#125;\n\n  var t &#x3D; performance.timing;\n  var times &#x3D; &#123;&#125;;\n\n  &#x2F;&#x2F;【重要】页面加载完成的时间\n  &#x2F;&#x2F;【原因】这几乎代表了用户等待页面可用的时间\n  times.loadPage &#x3D; t.loadEventEnd - t.navigationStart;\n\n  &#x2F;&#x2F;【重要】解析 DOM 树结构的时间\n  &#x2F;&#x2F;【原因】反省下你的 DOM 树嵌套是不是太多了！\n  times.domReady &#x3D; t.domComplete - t.responseEnd;\n\n  &#x2F;&#x2F;【重要】重定向的时间\n  &#x2F;&#x2F;【原因】拒绝重定向！比如，http:&#x2F;&#x2F;example.com&#x2F; 就不该写成 http:&#x2F;&#x2F;example.com\n  times.redirect &#x3D; t.redirectEnd - t.redirectStart;\n\n  &#x2F;&#x2F;【重要】DNS 查询时间\n  &#x2F;&#x2F;【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？\n  &#x2F;&#x2F; 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000000633364)\n  times.lookupDomain &#x3D; t.domainLookupEnd - t.domainLookupStart;\n\n  &#x2F;&#x2F;【重要】读取页面第一个字节的时间\n  &#x2F;&#x2F;【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？\n  &#x2F;&#x2F; TTFB 即 Time To First Byte 的意思\n  &#x2F;&#x2F; 维基百科：https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Time_To_First_Byte\n  times.ttfb &#x3D; t.responseStart - t.navigationStart;\n\n  &#x2F;&#x2F;【重要】内容加载完成的时间\n  &#x2F;&#x2F;【原因】页面内容经过 gzip 压缩了么，静态资源 css&#x2F;js 等压缩了么？\n  times.request &#x3D; t.responseEnd - t.requestStart;\n\n  &#x2F;&#x2F;【重要】执行 onload 回调函数的时间\n  &#x2F;&#x2F;【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？\n  times.loadEvent &#x3D; t.loadEventEnd - t.loadEventStart;\n\n  &#x2F;&#x2F; DNS 缓存时间\n  times.appcache &#x3D; t.domainLookupStart - t.fetchStart;\n\n  &#x2F;&#x2F; 卸载页面的时间\n  times.unloadEvent &#x3D; t.unloadEventEnd - t.unloadEventStart;\n\n  &#x2F;&#x2F; TCP 建立连接完成握手的时间\n  times.connect &#x3D; t.connectEnd - t.connectStart;\n\n  return times;\n&#125;\n\n聊下性能优化假设你对 performance API 很熟悉\n\n减少重定向次数\nDNS 查询时间：HTML5 Prefetch 预查询\nTCP 连接: http1.1 开启 connect: keep-alive, http2.0， 如果可以的话 http3.0 可以看本站另一篇文章\n资源压缩：gzip、brotli、图片压缩、tree-shaking、console 移除\n资源整合：减少请求次数、减少网络请求，雪碧图（虽然 http2 提供了多路复用[多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制,单个连接上可以并行交错的请求和响应，之间互不干扰,但是数量猛增，服务器要处理，多多少少也耗性能]的能力，而且现在还有使用的常见，比聊天表情，飞书也在用）\n资源加载：CDN、强缓存和协商缓存、按需加载\nDOM 解析：自上而下，script 标签放在底部，css 放在上面，无论是 html 还是 css 的层级，应尽量少的解析，解析消耗性能\n渲染时候：回流和重绘、懒加载、虚拟列表\n\n两个事例飞书雪碧图\n\n为什么拿飞书桌端数据来说（之前开发桌面端Electron，扒拉过飞书应用包的数据)\n\n\n\n京东移动端 dns-prefetch\n\n为什么拿京东数据来说（之前爬取过京东移动端数据开发 RN)\n\n\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    window.alert &#x3D; console.log;\n  &lt;&#x2F;script&gt;\n  &lt;script&gt;\n    window._PFM_TIMING &#x3D; [[1351, new Date()]]; &#x2F;&#x2F;TODO\n  &lt;&#x2F;script&gt;\n  &lt;meta\n    name&#x3D;&quot;viewport&quot;\n    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0&quot;\n  &#x2F;&gt;\n  &lt;title&gt;多快好省，购物上京东！&lt;&#x2F;title&gt;\n  &lt;!-- 强缓存Cache-Control --&gt;\n  &lt;meta http-equiv&#x3D;&quot;Cache-Control&quot; content&#x3D;&quot;max-age&#x3D;180&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;\n  &lt;!-- 京东 &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt; 写重复了 --&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;m.360buyimg.com&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;\n  &lt;meta\n    name&#x3D;&quot;viewport&quot;\n    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0, shrink-to-fit&#x3D;no, viewport-fit&#x3D;cover&quot;\n  &#x2F;&gt;\n  &lt;!-- X-DNS-Prefetch-Control 头控制着浏览器的 DNS 预读取功能  DNS 预读取是一项使浏览器主动去执行域名解析的功能--&gt;\n  &lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot; &#x2F;&gt;\n\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img11.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img10.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img12.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img13.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img14.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img20.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img30.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;wq.360buyimg.com&quot; &#x2F;&gt;\n&lt;&#x2F;head&gt;\n\nperformance 数据能干啥用？（开发者）熟悉 Chrome 开发者工具的朋友应该知道：在开发环境下，其实我们自己打开 Chrome 的开发者工具，切换到网络面板，就能很详细的看到网页性能相关的数据。\n（网站用户）但当我们需要统计分析用户打开我们网页时的性能如何时，我们将 performance 原始信息或通过简单计算后的信息 (如上面写到的 getPerformanceTiming()) 上传到服务器，配合其他信息（如 HTTP 请求头信息），就完美啦~\n来看下简书\n链接 简书 ,打开控制台可以看到输出结果一个数组（如果简书没将此日志去除）\n简书代码\n\nwindow.addEventListener(&quot;load&quot;, function () &#123;\n  setTimeout(function () &#123;\n    var e &#x3D; window.performance;\n    if (e) &#123;\n      var t &#x3D; e.getEntriesByType(&quot;navigation&quot;)[0],\n        r &#x3D; 0;\n      t || (r &#x3D; (t &#x3D; e.timing).navigationStart);\n      var n &#x3D; [\n        &#123;\n          key: &quot;Redirect&quot;,\n          desc: &quot;\\u7f51\\u9875\\u91cd\\u5b9a\\u5411\\u7684\\u8017\\u65f6&quot;,\n          value: t.redirectEnd - t.redirectStart,\n        &#125;,\n        &#123;\n          key: &quot;AppCache&quot;,\n          desc: &quot;\\u68c0\\u67e5\\u672c\\u5730\\u7f13\\u5b58\\u7684\\u8017\\u65f6&quot;,\n          value: t.domainLookupStart - t.fetchStart,\n        &#125;,\n        &#123;\n          key: &quot;DNS&quot;,\n          desc: &quot;DNS\\u67e5\\u8be2\\u7684\\u8017\\u65f6&quot;,\n          value: t.domainLookupEnd - t.domainLookupStart,\n        &#125;,\n        &#123;\n          key: &quot;TCP&quot;,\n          desc: &quot;TCP\\u8fde\\u63a5\\u7684\\u8017\\u65f6&quot;,\n          value: t.connectEnd - t.connectStart,\n        &#125;,\n        &#123;\n          key: &quot;Waiting(TTFB)&quot;,\n          desc: &quot;\\u4ece\\u5ba2\\u6237\\u7aef\\u53d1\\u8d77\\u8bf7\\u6c42\\u5230\\u63a5\\u6536\\u5230\\u54cd\\u5e94\\u7684\\u65f6\\u95f4 &#x2F; Time To First Byte&quot;,\n          value: t.responseStart - t.requestStart,\n        &#125;,\n        &#123;\n          key: &quot;Content Download&quot;,\n          desc: &quot;\\u4e0b\\u8f7d\\u670d\\u52a1\\u7aef\\u8fd4\\u56de\\u6570\\u636e\\u7684\\u65f6\\u95f4&quot;,\n          value: t.responseEnd - t.responseStart,\n        &#125;,\n        &#123;\n          key: &quot;HTTP Total Time&quot;,\n          desc: &quot;http\\u8bf7\\u6c42\\u603b\\u8017\\u65f6&quot;,\n          value: t.responseEnd - t.requestStart,\n        &#125;,\n        &#123;\n          key: &quot;DOMContentLoaded&quot;,\n          desc: &quot;dom\\u52a0\\u8f7d\\u5b8c\\u6210\\u7684\\u65f6\\u95f4&quot;,\n          value: t.domContentLoadedEventEnd - r,\n        &#125;,\n        &#123;\n          key: &quot;Loaded&quot;,\n          desc: &quot;\\u9875\\u9762load\\u7684\\u603b\\u8017\\u65f6&quot;,\n          value: t.loadEventEnd - r,\n        &#125;,\n      ];\n      if (Math.random() &gt; 0.75) &#123;\n        var s &#x3D; window.location,\n          i &#x3D; s.href,\n          c &#x3D; s.pathname,\n          u &#x3D; navigator.userAgent,\n          d &#x3D; i.split(&quot;?&quot;)[0];\n        o.a\n          .post(&quot;https:&#x2F;&#x2F;tr.jianshu.com&#x2F;fe&#x2F;1&#x2F;mon&#x2F;atf&quot;, &#123;\n            app: &quot;shakespeare-performance&quot;,\n            url: d,\n            ua: u,\n            path: c,\n            stats_ttfb: t.responseStart - t.requestStart,\n            stats_domLoaded: t.domContentLoadedEventEnd - r,\n            stats_loaded: t.loadEventEnd - r,\n          &#125;)\n          .then(a.a)\n          .catch(a.a);\n      &#125;\n      console &amp;&amp; console.log &amp;&amp; console.log(n);\n    &#125;\n  &#125;, 0);\n&#125;);\n\n简书截图\ndomContentLoaded 与 loaded&#x2F;&#x2F; 从页面开始到 domContentLoadedEventEnd\nlet domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;\n&#x2F;&#x2F; 从页面开始到 loadEventEnd\nlet loaded &#x3D; t.loadEventEnd - t.navigationStart;\n\ndomContentLoadedEventEnd 比 loaded 先触发\n\n\n\n掘金页面\n话说已经到了 6 月 6 号，闲逛掘金，遇到面试题：从输入url到页面展示发生了什么，突然想起个 performance,就拿掘金的一个页面来验证这幅图\n\n\n\n\n\n\n\n\n\n\nWARNING\n注意：此代码放到 dayjs 网站的 Sources&#x2F;Snippets 中执行，利用全局的 dayjs，无需引入 dayjs\n\ndayjs 网站\n\n\n代码是为了对performance.timing按照时间值进行排序，排序结果大致是执行的顺序，稍微有出入，会手动做调整\n代码如下：\n\nvar timing &#x3D; &#123;\n  connectStart: 1654499041800,\n  navigationStart: 1654499041744,\n  loadEventEnd: 1654499043641,\n  domLoading: 1654499042279,\n  secureConnectionStart: 1654499041820,\n  fetchStart: 1654499041746,\n  domContentLoadedEventStart: 1654499042718,\n  responseStart: 1654499042247,\n  responseEnd: 1654499042304,\n  domInteractive: 1654499042495,\n  domainLookupEnd: 1654499041800,\n  redirectStart: 0,\n  requestStart: 1654499041849,\n  unloadEventEnd: 1654499042267,\n  unloadEventStart: 1654499042267,\n  domComplete: 1654499043640,\n  domainLookupStart: 1654499041750,\n  loadEventStart: 1654499043641,\n  domContentLoadedEventEnd: 1654499042718,\n  redirectEnd: 0,\n  connectEnd: 1654499041849,\n&#125;;\n&#x2F;&#x2F; YYYY-MM-DD HH:一定一致，这个就不看了\nvar fmt &#x3D; &quot;mm:ss:SSS&quot;;\nvar arr &#x3D; [];\nvar sort_obj &#x3D; &#123;&#125;;\n\nfunction fmt_sort_key(obj) &#123;\n  for (let [key, value] of Object.entries(obj)) &#123;\n    arr.push(&#123;\n      key,\n      value,\n    &#125;);\n  &#125;\n\n  const sortArr &#x3D; arr.sort((a, b) &#x3D;&gt; a.value - b.value);\n\n  const fmtSortArr &#x3D; sortArr.map((item) &#x3D;&gt; &#123;\n    if (!item.value) return item;\n    return &#123;\n      ...item,\n      value: dayjs(item.value).format(fmt),\n    &#125;;\n  &#125;);\n\n  console.log(fmtSortArr);\n&#125;\nfmt_sort_key(timing);\n\n非无痕首次访问const timing &#x3D; &#123;\n  connectStart: 1654391072118,\n  navigationStart: 1654391071928,\n  loadEventEnd: 1654391076402,\n  domLoading: 1654391072670,\n  secureConnectionStart: 1654391072118,\n  fetchStart: 1654391071969,\n  domContentLoadedEventStart: 1654391074189,\n  responseStart: 1654391072621,\n  responseEnd: 1654391072664,\n  domInteractive: 1654391073865,\n  domainLookupEnd: 1654391072118,\n  redirectStart: 0,\n  requestStart: 1654391072199,\n  &#x2F;&#x2F; 没有之前页面的卸载\n  unloadEventEnd: 0,\n  unloadEventStart: 0,\n\n  domComplete: 1654391076400,\n  domainLookupStart: 1654391072118,\n  loadEventStart: 1654391076400,\n  domContentLoadedEventEnd: 1654391074189,\n  redirectEnd: 0,\n  connectEnd: 1654391072199,\n&#125;;\n\n&#x2F;&#x2F; 时间戳 1654391072118： connectStart、secureConnectionStart、domainLookupStart、domainLookupEnd ，这个值是相同的\n\n&#x2F;&#x2F; 把上述 timing 使用dayjs进行转化，看下每个key对应的time,对于0是没有进行的操作，我们跳过不处理（知道没进行）\n\nvar timingfmt &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;04:31:928&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;04:31:969&quot; &#125;,\n  &#123; key: &quot;connectStart&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;04:32:199&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;04:32:199&quot; &#125;,\n\n  &#123; key: &quot;responseStart&quot;, value: &quot;04:32:621&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;04:32:664&quot; &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;04:32:670&quot; &#125;,\n  &#123; key: &quot;domInteractive&quot;, value: &quot;04:33:865&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;04:34:189&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;04:34:189&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;04:36:400&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;04:36:400&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;04:36:402&quot; &#125;,\n];\n\n我们看下结果 2022-06-05 09:04，年月日时分都是一致的，我们只关心三位的毫秒数\n非无痕第二次访问const timing2 &#x3D; &#123;\n  connectStart: 1654494048918,\n  navigationStart: 1654494048902,\n  loadEventEnd: 1654494054146,\n  domLoading: 1654494049851,\n  secureConnectionStart: 0, &#x2F;&#x2F; 走缓存\n  fetchStart: 1654494048918,\n  domContentLoadedEventStart: 1654494051380,\n  responseStart: 1654494049430,\n  responseEnd: 1654494049514,\n  domInteractive: 1654494051115,\n  domainLookupEnd: 1654494048918,\n  redirectStart: 0,\n  requestStart: 1654494048942,\n  &#x2F;&#x2F; 有之前页面卸载\n  unloadEventEnd: 1654494049537,\n  unloadEventStart: 1654494049536,\n\n  domComplete: 1654494054143,\n  domainLookupStart: 1654494048918,\n  loadEventStart: 1654494054143,\n  domContentLoadedEventEnd: 1654494051381,\n  redirectEnd: 0,\n  connectEnd: 1654494048918,\n&#125;;\n\nvar timingfmt2 &#x3D; [\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;40:48:902&quot; &#125;,\n\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;40:48:918&quot; &#125;,\n\n  &#123; key: &quot;connectStart&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;40:48:942&quot; &#125;,\n  &#123; key: &quot;responseStart&quot;, value: &quot;40:49:430&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;40:49:514&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;40:49:536&quot; &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;40:49:537&quot; &#125;,\n  &#123; key: &quot;domLoading&quot;, value: &quot;40:49:851&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;40:51:115&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;40:51:380&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;40:51:381&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;40:54:143&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;40:54:143&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;40:54:146&quot; &#125;,\n];\n\n非无痕 f5 手动刷新var timing3 &#x3D; &#123;\n  connectStart: 1654495600379,\n  navigationStart: 1654495600360,\n  loadEventEnd: 1654495604101,\n  domLoading: 1654495601005,\n  secureConnectionStart: 1654495600389,\n  fetchStart: 1654495600364,\n  domContentLoadedEventStart: 1654495601947,\n  responseStart: 1654495600935,\n  responseEnd: 1654495600989,\n  domInteractive: 1654495601794,\n  domainLookupEnd: 1654495600379,\n  redirectStart: 0,\n  requestStart: 1654495600404,\n  unloadEventEnd: 1654495600971,\n  unloadEventStart: 1654495600970,\n  domComplete: 1654495604099,\n  domainLookupStart: 1654495600379,\n  loadEventStart: 1654495604099,\n  domContentLoadedEventEnd: 1654495601947,\n  redirectEnd: 0,\n  connectEnd: 1654495600403,\n&#125;;\n\nvar timingfmt3 &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;06:40:360&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;06:40:364&quot; &#125;,\n\n  &#123; key: &quot;connectStart&quot;, value: &quot;06:40:379&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;06:40:379&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;06:40:379&quot; &#125;,\n\n  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;06:40:389&quot; &#125;,\n\n  &#123; key: &quot;connectEnd&quot;, value: &quot;06:40:403&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;06:40:404&quot; &#125;,\n\n  &#123; key: &quot;responseStart&quot;, value: &quot;06:40:935&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;06:40:970&quot; &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;06:40:971&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;06:40:989&quot; &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;06:41:005&quot; &#125;,\n  &#123; key: &quot;domInteractive&quot;, value: &quot;06:41:794&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;06:41:947&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;06:41:947&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;06:44:099&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;06:44:099&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;06:44:101&quot; &#125;,\n];\n\n无痕模式首次var timing4 &#x3D; &#123;\n  connectStart: 1654496795083,\n  navigationStart: 1654496795041,\n  loadEventEnd: 1654496799718,\n  domLoading: 1654496795428,\n  secureConnectionStart: 1654496795093,\n  fetchStart: 1654496795050,\n  domContentLoadedEventStart: 1654496796111,\n  responseStart: 1654496795420,\n  responseEnd: 1654496795469,\n  domInteractive: 1654496795680,\n  domainLookupEnd: 1654496795083,\n  redirectStart: 0,\n  requestStart: 1654496795123,\n  unloadEventEnd: 0,\n  unloadEventStart: 0,\n  domComplete: 1654496799718,\n  domainLookupStart: 1654496795057,\n  loadEventStart: 1654496799718,\n  domContentLoadedEventEnd: 1654496796111,\n  redirectEnd: 0,\n  connectEnd: 1654496795123,\n&#125;;\n\nvar timing4fmt &#x3D; [\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;26:35:041&quot; &#125;,\n\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;26:35:050&quot; &#125;,\n\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;26:35:057&quot; &#125;,\n\n  &#123; key: &quot;connectStart&quot;, value: &quot;26:35:083&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;26:35:083&quot; &#125;,\n  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;26:35:093&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;26:35:123&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;26:35:123&quot; &#125;,\n\n  &#123; key: &quot;responseStart&quot;, value: &quot;26:35:420&quot; &#125;,\n\n  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;26:35:428&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;26:35:469&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;26:35:680&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;26:36:111&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;26:36:111&quot; &#125;,\n\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;26:39:718&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;26:39:718&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;26:39:718&quot; &#125;,\n];\n\n无痕模式刷新var timing5 &#x3D; &#123;\n  connectStart: 1654496848681,\n  navigationStart: 1654496848679,\n  loadEventEnd: 1654496850263,\n  domLoading: 1654496848983,\n  secureConnectionStart: 0,\n  fetchStart: 1654496848681,\n  domContentLoadedEventStart: 1654496849277,\n  responseStart: 1654496848959,\n  responseEnd: 1654496849017,\n  domInteractive: 1654496849096,\n  domainLookupEnd: 1654496848681,\n  redirectStart: 0,\n  requestStart: 1654496848702,\n  unloadEventEnd: 1654496848979,\n  unloadEventStart: 1654496848979,\n  domComplete: 1654496850262,\n  domainLookupStart: 1654496848681,\n  loadEventStart: 1654496850262,\n  domContentLoadedEventEnd: 1654496849277,\n  redirectEnd: 0,\n  connectEnd: 1654496848681,\n&#125;;\n\nvar timing5fmt &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;27:28:679&quot; &#125;,\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;connectStart&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;27:28:681&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;requestStart&quot;, value: &quot;27:28:702&quot; &#125;,\n  &#123; key: &quot;responseStart&quot;, value: &quot;27:28:959&quot; &#125;,\n\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;27:28:979&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;27:28:979&quot; &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;27:28:983&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;27:29:017&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;27:29:096&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;27:29:277&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;27:29:277&quot; &#125;,\n\n  &#123; key: &quot;domComplete&quot;, value: &quot;27:30:262&quot; &#125;,\n\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;27:30:262&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;27:30:263&quot; &#125;,\n];\n\n无痕模式刷新 + disable-cachevar timing6 &#x3D; &#123;\n  connectStart: 1654496917781,\n  navigationStart: 1654496917780,\n  loadEventEnd: 1654496921224,\n  domLoading: 1654496918186,\n  secureConnectionStart: 0,\n  fetchStart: 1654496917781,\n  domContentLoadedEventStart: 1654496918836,\n  responseStart: 1654496918156,\n  responseEnd: 1654496918293,\n  domInteractive: 1654496918654,\n  domainLookupEnd: 1654496917781,\n  redirectStart: 0,\n  requestStart: 1654496917784,\n  unloadEventEnd: 1654496918182,\n  unloadEventStart: 1654496918182,\n  domComplete: 1654496921224,\n  domainLookupStart: 1654496917781,\n  loadEventStart: 1654496921224,\n  domContentLoadedEventEnd: 1654496918836,\n  redirectEnd: 0,\n  connectEnd: 1654496917781,\n&#125;;\nvar timing6fmt &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;28:37:780&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;28:37:781&quot; &#125;,\n\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;28:37:781&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;28:37:781&quot; &#125;,\n  &#123; key: &quot;connectStart&quot;, value: &quot;28:37:781&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;28:37:781&quot; &#125;,\n\n  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;requestStart&quot;, value: &quot;28:37:784&quot; &#125;,\n  &#123; key: &quot;responseStart&quot;, value: &quot;28:38:156&quot; &#125;,\n  &#x2F;&#x2F; 和 timing5fmt比较，之前页面的卸载，非常快\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;28:38:182&quot; &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;28:38:182&quot; &#125;,\n  &#x2F;&#x2F; 注意 domLoading 和 responseEnd,这两个，顺序不定\n  &#123; key: &quot;domLoading&quot;, value: &quot;28:38:186&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;28:38:293&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;28:38:654&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;28:38:836&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;28:38:836&quot; &#125;,\n\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;28:41:224&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;28:41:224&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;28:41:224&quot; &#125;,\n];\n\n这个操作竟然有一个 base64 编码图片依然被缓存了,浏览器 disable-cache 对于有些内存缓存的图片竟然是无效的.\nRequest URL: data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC\nRequest Method: GET\nStatus Code: 200 OK (from memory cache)\nReferrer Policy: strict-origin-when-cross-origin\n\n\n参考资料Web 性能优化-首屏和白屏时间初探 performance – 监控网页与程序性能简述浏览器渲染机制\n","slug":"2022-05-12performance","date":"2022-05-12T10:27:05.000Z","categories_index":"performance","tags_index":"前端,performance,浏览器原理","author_index":"陈海龙"},{"id":"832da5e8309651301e718ddb27ca95fd","title":"vscode插件 paste code to snippets","content":"粘贴代码，生成用户代码片段背景\n其他插件具有共性，而不具特性 ，每次写代码，要么用第三方插件，现成的代码片段，时常不能满足日常开发需要\n自定义代码片段，手写 费时费力，一般步骤，粘贴、修改、格式化\n其他插件类似vscode宏变量的使用少之又少， 要么将开源插件定制化，要么重新开发\n快捷变量记不住\n\npaste code to snippets 优点：\n高度定制化\n跨语言（任何vscode支持的语言，都可在对应类型片段文件中进行增加）\n使用简单 （复制、唤起命令、挖孔）\n快捷变量完全自定义（想怎么写就怎么写）\n\n操作GIF\n问题\n如果配置了代码片段，没有提示, 查看settings.json对应\n打开 settings.json 命令： command + shift + p, 搜 &gt;settings\n\n以markdown为例 默认只读配置在升级后变成了false\n&#x2F;&#x2F; Configure settings to be overridden for the markdown language.\n&quot;[markdown]&quot;:  &#123;\n\t&quot;editor.unicodeHighlight.ambiguousCharacters&quot;: false,\n\t&quot;editor.unicodeHighlight.invisibleCharacters&quot;: false,\n\t&quot;editor.wordWrap&quot;: &quot;on&quot;,\n\t&quot;editor.quickSuggestions&quot;: false \n&#125;,\n\n\n修改\n\n","slug":"2022-05-11vscode","date":"2022-05-11T01:38:30.000Z","categories_index":"vscode","tags_index":"增效,vscode","author_index":"陈海龙"},{"id":"8a3cd3de20e0b1971e27a9e96209af62","title":"HTTP3","content":"现状\n\n\n\n\n\n\n\n\n\nHTTP/3 的基础即谷歌多年探索的基于 UDP 的 QUIC 协议。与 TCP 相比，使用 UDP 可以提供更大的灵活性，并且可以使 QUIC 完全于用户空间中实现——对协议实现的更新不像 TCP 那样需要绑定到操作系统更新。使用 QUIC，可以简单地将 HTTP 级别的流映射到 QUIC 流的顶部，从而继承 HTTP/2 的所有优点，而不会产生队头阻塞。HTTP/3 虽仍处于草案状态，但很多用户已经跃跃欲试。\n优势\nHTTP&#x2F;3 利用 QUIC 加速 HTTP 请求，QUIC 提供比 TCP 和 TLS 更高的加密和性能\nQUIC 是一种默认加密的新传输协议，旨在加快 HTTP 传输速度以及使其更加安全\nHTTP&#x2F;3 基于 UDP，如果数据包丢失，只会中断一个流，而不会中断所有流，提高了同时获取多个对象的性能\n支持 0-RTT，消除服务器的 TLS 确认，使后续连接的启动速度更快\n\n演示下图表示 HTTP&#x2F;2 和 HTTP&#x2F;3 多路复用两个请求时，数据包丢失及其影响（请求及其相关的响应分别为深蓝和浅蓝色）\nHTTP&#x2F;2 多路复用 2 个请求。响应被分解为多个数据包，一旦一个数据包丢失了，两个请求都被阻止。HTTP&#x2F;3 复用 2 个请求。虽然浅色的数据包丢失了，但是深色的数据包传输得很好。在相同丢包率的条件下，HTTP&#x2F;3 和 HTTP&#x2F;2 性能测试对比如下测试环境：服务端（HTTP&#x2F;3 with cubic &amp; HTTP&#x2F;2 with bbr）、客户端（cubic）\n更多查看更多\n","slug":"2022-05-11http","date":"2022-05-11T01:26:00.000Z","categories_index":"工具","tags_index":"工具","author_index":"陈海龙"},{"id":"f5ccfd5f1ce5f78727a64a19669811c7","title":"Slate wiki-ui评论功能光标乱跳","content":"bug复现bug复现 (node:29) UnhandledPromiseRejectionWarning: Error: Forbidden at &amp;#x2F;code&amp;#x2F;client&amp;#x2F;.next&amp;#x2F;server&amp;#x2F;pages&amp;#x2F;_app-a05...\n\n在vite react项目上，输入汉字的同时按住删除键，光标会乱跳\n排查1:wiki（esm）组件问题，检查wiki-ui组件库，运行正常\n&quot;react&quot;: &quot;^16.8.0&quot;,\n&quot;react-dom&quot;: &quot;^16.8.0&quot;,\n排查2:vite加载wiki-ui组件时候，因为vite只能处理esm，在vite.config.ts, esbuildOptions自定义插件进行处理wiki-ui，不是很懂，换个角度\nesbuildOptions: &#123;\n  plugins: [\n    &#123;\n      name: &#39;originjs:commonjs&#39;,\n      setup(build) &#123;\n        build.onLoad(\n          &#123;\n            filter: &#x2F;@敏感数据-fe\\&#x2F;wiki-ui\\&#x2F;dist&#x2F;,\n            namespace: &#39;file&#39;,\n          &#125;,\n          async (&#123; path: id &#125;) &#x3D;&gt; &#123;\n            const code &#x3D; readFileSync(id).toString()\n            const result &#x3D; transformRequire(code, id)\n\n            return &#123;\n              contents: result,\n              loader: &#39;js&#39;,\n            &#125;\n          &#125;,\n        ),\n          build.onLoad(\n            &#123;\n              filter: &#x2F;@敏感数据-fe\\&#x2F;wiki-ui\\&#x2F;dist\\&#x2F;components\\&#x2F;iconfont&#x2F;,\n              namespace: &#39;file&#39;,\n            &#125;,\n            async (&#123; path: id &#125;) &#x3D;&gt; &#123;\n              const code &#x3D; readFileSync(id).toString()\n              const result &#x3D; transformRequire(code, id)\n\n              return &#123;\n                contents: result,\n                loader: &#39;js&#39;,\n              &#125;\n            &#125;,\n          )\n      &#125;,\n    &#125;,\n    esbuildPluginMonacoEditorNls(&#123;\n      locale: Languages.zh_hans,\n    &#125;),\n  ],\n&#125;,\n排查3:将wiki-ui组件放到umijs应用中运行\n# 搭建个项目\n# 移动demo组件到新项目\n# 运行，发现有相同的问题\n分析：1.dom输入过程中点击删除操作，那么在这个过程中，输入的内容是在contenteditable=&quot;true&quot; 中运行\n&lt;div data-gramm&#x3D;&quot;false&quot; role&#x3D;&quot;textbox&quot; spellcheck&#x3D;&quot;false&quot; class&#x3D;&quot;slash-slate-core&quot; id&#x3D;&quot;SLASH_SLATE_CORE&quot; data-app-id&#x3D;&quot;5A9BEA&quot; autocorrect&#x3D;&quot;false&quot; autocapitalize&#x3D;&quot;false&quot; data-slate-editor&#x3D;&quot;true&quot; data-slate-node&#x3D;&quot;value&quot; contenteditable&#x3D;&quot;true&quot; style&#x3D;&quot;position: relative; outline: none; white-space: pre-wrap; overflow-wrap: break-word;&quot;&gt;&lt;p data-slate-node&#x3D;&quot;element&quot;&gt;&lt;span data-slate-node&#x3D;&quot;text&quot;&gt;&lt;span data-slate-leaf&#x3D;&quot;true&quot;&gt;&lt;span data-slate-string&#x3D;&quot;true&quot;&gt;12121212哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈h h h h h h h h h h h h hs f s d f&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;\n2.合成事件应该会走合成事件，合成事件之后会执行渲染，web端走的是react-dom，比对正常运行的项目，和新项目的版本\n# react 17版本\n# react-dom 17版本\n3.react先进行react降版本 16.14.0，检查合成事件是否有问题，降版本后，运行，问题同样存在，大概可以断定是react-dom渲染出了问题，\n4.react-dom对react-dom降低版本到16.14.0, 后运行正常，那么问题应该在react-dom上\n5.github版本 16.14.0两个版本有什么不同：查看react发布日志，16.14.0之后的一个版本是17.0.0 (October 20, 2020) 看上去与事件和渲染相关的东西不多\nUse browser focusin and focusout for onFocus and onBlur. (@trueadm in #19186)\nMake all Capture events use the browser capture phase. (@trueadm in #19221)\nThrow if forwardRef or memo component returns undefined. (@gaearon in #19550)\nRemove event pooling. (@trueadm in #18969)\nFix onBeforeInput reporting an incorrect event.type. (@eps1lon in #19561)\nFix event.relatedTarget reported as undefined in Firefox. (@claytercek in #19607)\nFix rendering into a shadow root. (@Jack-Works in #15894)\nFix movementX&#x2F;Y polyfill with capture events. (@gaearon in #19672)\nArtifacts\nreact: https:&#x2F;&#x2F;unpkg.com&#x2F;react@17.0.1&#x2F;umd&#x2F;\nreact-art: https:&#x2F;&#x2F;unpkg.com&#x2F;react-art@17.0.1&#x2F;umd&#x2F;\nreact-dom: https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@17.0.1&#x2F;umd&#x2F;\nreact-is: https:&#x2F;&#x2F;unpkg.com&#x2F;react-is@17.0.1&#x2F;umd&#x2F;\nreact-test-renderer: https:&#x2F;&#x2F;unpkg.com&#x2F;react-test-renderer@17.0.1&#x2F;umd&#x2F;\nscheduler: https:&#x2F;&#x2F;unpkg.com&#x2F;scheduler@0.20.1&#x2F;umd&#x2F;\n6.github版本 18.1.0在往后找最新的版本，发现在18.1.0 (April 26, 2022)，改了一堆react-dom的bug,看上去也没相关的\nFix the false positive warning about react-dom&#x2F;client when using UMD bundle. (@alireza-molaee in #24274)\nFix suppressHydrationWarning to work in production too. (@gaearon in #24271)\nFix componentWillUnmount firing twice inside of Suspense. (@acdlite in #24308)\nFix some transition updates being ignored. (@acdlite in #24353)\nFix useDeferredValue causing an infinite loop when passed an unmemoized value. (@acdlite in #24247)\nFix throttling of revealing Suspense fallbacks. (@sunderls in #24253)\nFix an inconsistency in whether the props object is the same between renders. (@Andarist and @acdlite in #24421)\nFix a missing warning about a setState loop in useEffect. (@gaearon in #24298)\nFix a spurious hydration error. (@gnoff in #24404)\nWarn when calling setState in useInsertionEffect. (@gaearon in #24295)\nEnsure the reason for hydration errors is always displayed. (@gaearon in #24276)\n\n可用版本&quot;react&quot;: &quot;^16.14.0&quot;,\n&quot;react-dom&quot;: &quot;16.14.0&quot;,\n\n\n这个演示代码正常&lt;embed type&#x3D;&quot;text&#x2F;html&quot; src&#x3D;&quot;https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview&quot; width&#x3D;&quot;100%&quot; height&#x3D;&quot;200&quot;&gt;\n&lt;!--加载太慢，复制地址查看吧--&gt; \n&lt;!--https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview--&gt; \n\n懵逼。。。从头开始\n待办事项中的评论功能（组件问题）光标乱跳的问题；\n0. 项目 + wiki-ui 异常\n1. 单运行wiki-ui demo 正常\n2. 运行slate + umijs 正常\n3. 运行wiki-ui  + umijs 异常\n4. slate 与  wiki-ui  不一样在于slate版本\n5. wiki-ui 做了什么事情： 定制化一些节点展示，光标的渲染和wiki-ui无关\n贫僧先去slate官网化缘，回来再战slate-lean\n化缘归来问题怎么解决\n","slug":"2022-04-29slate","date":"2022-05-10T05:00:00.000Z","categories_index":"wiki","tags_index":"wiki","author_index":"陈海龙"},{"id":"1827bdebccdb6131916a11069d50f729","title":"跨域问题","content":"背景浏览器安全策略限制跨域访问\n内容安全策略是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。\n\n使用方式为使 CSP 可用, 你需要配置你的网络服务器返回 Content-Security-Policy，或者在 HTML  元素种也可配置该策略, 例如：\n\n&lt;meta\n  http-equiv&#x3D;&quot;Content-Security-Policy&quot;\n  content&#x3D;&quot;default-src &#39;self&#39;; img-src https:&#x2F;&#x2F;*; child-src &#39;none&#39;;&quot;\n&#x2F;&gt;\n\n\n配置示例（1）一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)\n\nContent-Security-Policy: default-src &#39;self&#39;\n\n（2）一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)\nContent-Security-Policy: default-src &#39;self&#39; *.trusted.com\n\n（3）一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码。\nContent-Security-Policy: default-src &#39;self&#39;;\nimg-src *;\nmedia-src media1.com media2.com; script-src userscripts.example.com\n\n在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:\n图片可以从任何地方加载(注意 “*“ 通配符)。多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。可运行脚本仅允许来自于 userscripts.example.com。\n作者：菜鸡前端链接：https://www.jianshu.com/p/a45924e99a6d来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n处理方式nginx\n脚本\n\n\nlisten 80; # 监听的端⼝\n   add_header &#39;Access-Control-Allow-Origin&#39; &#39;$http_origin&#39; ;\n   add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39; ;\n   add_header &#39;Access-Control-Allow-Methods&#39; &#39;PUT,POST,GET,DELETE,OPTIONS&#39; ;\n   add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,Content-Length,Authorization,Accept,X-Requested-With&#39; ;\n\n\n实际操作\n\n\njsonp 方式 &lt;动态 script&gt;服务端设置，类似 nginx其他（不常用）","slug":"2022-05-09cors","date":"2022-05-09T13:30:47.000Z","categories_index":"面试","tags_index":"面试","author_index":"陈海龙"},{"id":"99460a2013287be2d51642da6dd169f8","title":"面试题汇总","content":"值得收藏的链接\n码上通天\n面试完50个人后我写下这篇总结\nif 我是前端团队 Leader，怎么制定前端协作规范?\n做了一份前端面试复习计划，保熟～\n\n","slug":"2022-05-08interview","date":"2022-05-08T08:27:00.000Z","categories_index":"","tags_index":"面试","author_index":"陈海龙"},{"id":"8c2ce163d41ac846e552a207bb84d5a9","title":"js变量和作用域","content":"变量var let const区别\n变量提升：var 存在变量提升，let、const没有（let、const存在暂时性死区）\n作用域的限制：var不受作用域的限制，而let、const受当前作用域的限制\n重复声明：var可以重复声明，let、const不可以\nconst是常量，必须有初始值，否则报错，不能更改，但是可以更改对象内部属性\n\n变量分类\njs中的变量分为两种：\n全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；\n而局部变量就只能在函数的内部才能够调用的变量。\n\n\n\nvar a&#x3D;10;\nfunction show()&#123;\n  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10\n  var b&#x3D;2;\n  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;b is no defined\n　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。\n另外需要特别注意的是：\n\n\n\n\n\n\n\n\n\n如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。\nvar a&#x3D;10;\nfunction show()&#123;\n  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10\n  b&#x3D;2;\n  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;outside b:2\n对比两段代码，如果你在声明b&#x3D;2时没有写var，那么b就隐式地声明为全局变量，在函数外面还是能够被调用到的。虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了缺点：\n\n一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。\n影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，\n可移植性: 同时也降低了函数的可移植性。\n\n因此我们在定义变量时一般要尽可能少的定义全局变量。\n变量声明\n\n\n\n\n\n\n\n\n函数声明优先于变量声明\n　　下面我们通过一段代码来说明.\nvar a; \nfunction a()&#123;\n&#125;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 或许有人是认为函数声明在后面的原因，那么调换一下位置。\nfunction a()&#123;\n&#125;\nvar a; \nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。\n&#x2F;&#x2F; 因此函数声明优先于变量的声明。\n&#x2F;&#x2F; 但是如果我们在声明的同时给a进行赋值。\nfunction a()&#123;\n&#125;\nvar a&#x3D;&#39;xyf&#39;; \nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 我们将其调换一下位置再次进行验证。\nvar a&#x3D;&#39;xyf&#39;; \nfunction a()&#123;\n&#125;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：\nfunction a()&#123;\n&#125;\nvar a;\na&#x3D;&#39;xyf&#39;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; a最后被赋值为字符串，因此a的类型自然是字符串\n作用域全局作用域　js中作用域只有函数作用域和全局作用域，\n函数作用域　js中作用域只有函数作用域和全局作用域，\n块级作用域  let const有块级作用域。函数作用域是比较容易理解的，那么什么是块级作用域呢？  &#123;var a &#x3D; 1&#125;\n\nconsole.log(a)\nVM2355:1 1\n  &#123;let a &#x3D;1&#125;\n\nconsole.log(a)\nVM2079:1 Uncaught ReferenceError: a is not defined\n\n\n\n\n\n\n\n\n\n任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。\n　　理解了块级作用域，来看一下下面的小例子。\nconsole.log(v); &#x2F;&#x2F;undefined\nvar v &#x3D; &quot;world&quot;;\n　　&#x2F;&#x2F; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。\n当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明\n由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：\nvar v;\nconsole.log(v); &#x2F;&#x2F;undefined\nv &#x3D; &quot;world&quot;;\n&#x2F;&#x2F; 这样就能很清晰地理解为什么变量v是undefined的了。\n&#x2F;&#x2F;下面我们把变量v放到一个方法中去：\nif(true)&#123;\n  var v &#x3D; &quot;hello&quot;;\n&#125;\nconsole.log(v); &#x2F;&#x2F;hello\n&#x2F;&#x2F; 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，\n&#x2F;&#x2F; 并不能够“阻挡”外面的代码获取里面的变量。\n函数作用域　　我们再把变量v放到函数中去：\nfunction show()&#123;\n  var v&#x3D;&#39;world&#39;;\n&#125;\nshow();\nconsole.log(v); &#x2F;&#x2F;undefined\n　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。　　再来看下面的一段代码：\nvar v&#x3D;&#39;hello&#39;;\nfunction show()&#123;\n  console.log(v); &#x2F;&#x2F;undefined\n  var v&#x3D;&#39;world&#39;;\n&#125;\nshow();\n　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：\nvar v&#x3D;&#39;hello&#39;;\nfunction show()&#123;\n\tvar v;\n\tconsole.log(v); &#x2F;&#x2F;undefined\n\tv&#x3D;&#39;world&#39;;\n&#125;\nshow();\n　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。\nvar v &#x3D; &quot;hello&quot;;\n(function()&#123;\n  console.log(v);\n  var v &#x3D; &quot;world&quot;;\n&#125;)();\n\n　　在这里自执行函数形成了函数作用域\n需要注意的是变量提升只提升函数的声明，并不提升函数的定义\nshow(); &#x2F;&#x2F;show is not a function\nvar show&#x3D;function()&#123;\n\t&#x2F;&#x2F;...\n&#125;\nshow(); &#x2F;&#x2F;成功运行\n\n　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。\n\n\n\n\n\n\n\n\n\n函数有两种定义方式，一种是函数声明，另一种是函数表达式。那么什么是函数声明什么是函数表达式呢？\n&#x2F;&#x2F;函数声明\nfunction show()&#123;\n\t&#x2F;&#x2F;....\n&#125;\n&#x2F;&#x2F;函数表达式\nvar show&#x3D;function()&#123;\n\t&#x2F;&#x2F;...\n&#125;\n乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。\n\njs的解析器对函数声明和函数表达式并不是一视同仁的对待的，有点“种族歧视”的意思在里面。\n函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。\n而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，因此，调用函数表达式要在定义后进行使用。\n\notherhttps://juejin.cn/post/6844904019165446158\n","slug":"2022-05-08varible","date":"2022-05-08T02:00:00.000Z","categories_index":"面试","tags_index":"面试","author_index":"陈海龙"},{"id":"39b06ee79b8fd96256d44a33e065e573","title":"如何更好的沉淀","content":"背景\n工作日常经验性总结放哪？\n存电脑，电脑坏了重做系统没了，\n放到电脑备忘录，卧槽，怎么没及时更新\n放自己的服务器，没时间打理，服务器到期，嗝屁了，没来的及迁移\n\nhexo\nhexo由于有丰富的插件和主题，使用及部署方便，备受欢迎\n自己购买服务器部署，服务器到期后续费很贵\n放到第三方博客上，好一点的像简书，每天发布限制两篇，可控性太差\n\nhexo 主题这里使用 aurora\ntheme: aurora\ntridiamondAlphaHinex\n阿里云oss\n图片资源放到github上，访问较慢，为了提升体验，将资源放到oss上，权限配置为公开，可被任何用户访问\n\n阿里云域名\n域名访问比较方便，图片资源只有在使用域名的情况下，各资源可以预览，而不仅仅是下载\n\nPicGo图床「贼好用，\n思考：除此之外，因为其开源我们可以学习下作者是如何处理插件的」\n为博客中md文档提供图片链接，放到阿里云oss上\n上传成功\n因为开发过electron，第一想到的是我要debug,打开控制台\n域名配错不可访问\n遇到图片,作为程序猿第一反应要优化「压缩」compress\n插件下载\n插件启用\n插件是否生效了\n插件列表github链接\n\n书写文章 hexo页面不热重载？yarn add global browser-sync\nyarn add hexo-browsersync\n\n启用评论# For local development only!\ngitalk:\n  enable: false\n  autoExpand: true\n  clientID: &#39;&#39;\n  clientSecret: &#39;&#39;\n  repo: &#39;dev-blog-comments&#39;\n  owner: &#39;TriDiamond&#39;\n  admin: [&#39;TriDiamond&#39;]\n  id: uid\n  language: en\n  distractionFreeMode: true\n  recentComment: true\n  proxy: &#39;&#39;\n\n# Valine comment plugin (recommended!)\n# see https:&#x2F;&#x2F;valine.js.org&#x2F;quickstart.html\nvaline:\n  enable: true\n  app_id: 去申请\n  app_key: 去申请\n  avatar: &#39;http:&#x2F;&#x2F;t-blog-images.aijs.top&#x2F;img&#x2F;avatar.jpeg&#39;\n  placeholder: Leave your thoughts behind~\n  visitor: true\n  lang: en\n  avatarForce: false\n  meta: [&#39;nick&#39;, &#39;mail&#39;]\n  requiredFields: []\n  admin: &#39;海龙&#39;\n  recentComment: true\n\n\n图片增加水印配置及效果\npicgo生成代码\n可选不同的代码方式\n\n常见问题\n每次发布后，github page 自定义域名会丢失\n\n\n\n\n\n\n\n\n在_posts目录下建立CNAME文件 填写上自己的域名\n\n图床picGo，上传了图片，在oss上查看也成功了，但是picGo相册中没有展示\n\n\n\n\n\n\n\n\n/Users/chenhailong/Library/Application Support/picgo目录下，删除 rm picgo.db,重新启动见issue #781\n\n调整博客文件时间，运行后文章排序并没有改变，需要清理根目录下db.json\n\n总结：总体而言picgo已经很好了，有几点可以优化\n\n已有图片二次重新上传压缩功能\n窗口实在是太小了，正常情况下可以手动拖拽改变大小\n插件列表插件卡片部分重叠\n\n","slug":"2022-04-28博客创建","date":"2022-05-06T01:17:27.000Z","categories_index":"","tags_index":"","author_index":"陈海龙"},{"id":"4e47b6e9bf7ea41cfbf0d4f0a3fe5d3c","title":"Lerna调试开源库遇到的问题","content":"yarn install --mutex network:42424 --non-interactive\n\n👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ lerna --version\n4.0.0\n\n\n👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn global add lerna@3.19.0    \nUsage Error: The &#39;yarn global&#39; commands have been removed in 2.x - consider using &#39;yarn dlx&#39; or a third-party plugin instead\n\n$ yarn run [--inspect] [--inspect-brk] &lt;scriptName&gt; ...\n👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn --version              \n3.0.1","slug":"2022-05-05lerna","date":"2022-05-05T13:30:47.000Z","categories_index":"工具","tags_index":"工具","author_index":"陈海龙"},{"id":"80947b2a66ed033838be54dc8f90264b","title":"MAC存储空间不足问题","content":"\n","slug":"2022-05-05mac","date":"2022-05-05T13:30:47.000Z","categories_index":"工具","tags_index":"工具","author_index":"陈海龙"},{"id":"462f06ba8f007318cafbef853cf322ba","title":"String相关面试代码","content":"转化为驼峰命名\n\n\n\n\n\n\n\n\nvar s1 = &quot;get-element-by-id&quot;\nvar f &#x3D; function (s) &#123;\n  return s.replace(&#x2F;-\\w&#x2F;g, function (x) &#123;\n    return x.splice(1).toUpperCase();\n  &#125;);\n&#125;;\n\n模版引擎实现let template &#x3D; &quot;我是&#123;&#123;name&#125;&#125;,年龄&#123;&#123;age&#125;&#125;,性别&#123;&#123;sex&#125;&#125;&quot;;\nlet data &#x3D; &#123;\n  name: &quot;姓名&quot;,\n  age: 18,\n&#125;;\n\nrender(template, data); &#x2F;&#x2F;我是姓名,年龄18,性别undefined\n\nfunction render(template, data) &#123;\n  &#x2F;&#x2F; 模版字符串正则\n  const resg &#x3D; &#x2F;\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;&#x2F;;\n  &#x2F;&#x2F; 判断模版里是否有模版字符串\n  if (reg.test(template)) &#123;\n    &#x2F;&#x2F; 查找当前模版里第一个模版字符串的字符\n    const name &#x3D; reg.exec(template)[1];\n    &#x2F;&#x2F; 将第一个模版字符串渲染\n    template &#x3D; template.replace(reg, data[name]);\n    &#x2F;&#x2F; 递归的渲染并返回渲染后的结构\n    return render(template, data);\n  &#125;\n&#125;\n\n解析 URL Params 为对象let url &#x3D;\n  &quot;http:&#x2F;&#x2F;www.domain.com&#x2F;?user&#x3D;anonymouse&amp;id&#x3D;123&amp;id&#x3D;456&amp;city&#x3D;%E5%8C%97%E4%BA%AC&amp;enabled&quot;;\n\n&#x2F;**\n * 结果\n * &#123;\n *  user: &#39;anonymouse&#39;,\n *  id: [123,456], &#x2F;&#x2F; 重复出现的key，要转化成数组\n *  city: &#39;北京&#39;, &#x2F;&#x2F; 中文需要解码\n *  enabled: true &#x2F;&#x2F; 未指定值的key，约定为true\n *\n *\n * &#125;\n *\n **&#x2F;\nfunction paramParam(url) &#123;\n  const paramsStr &#x3D; &#x2F;.+\\?(.+)$&#x2F;.exec(url)[1];\n  const paramsArr &#x3D; paramsArr.split(&quot;&amp;&quot;);\n  let paramsObj &#x3D; &#123;&#125;;\n\n  paramsArr.forEach((param) &#x3D;&gt; &#123;\n    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;\n      let [key, val] &#x3D; param.split(&quot;&#x3D;&quot;); &#x2F;&#x2F; 拆分键&#x2F;值\n      val &#x3D; decodeURLComponent(val); &#x2F;&#x2F; 汉字解码\n      val &#x3D; &#x2F;^\\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 数字转化\n      if (paramsObj.hasOwnProperty(key)) &#123;\n        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 重复key转数组\n      &#125; else &#123;\n        paramsObj[key] &#x3D; val;\n      &#125;\n    &#125; else &#123;\n      paramsObj[key] &#x3D; true; &#x2F;&#x2F; 处理约定\n    &#125;\n  &#125;);\n&#125;\n\n查找字符串中，出现最多的字符和个数let str &#x3D; &quot;abcabcabcbbcccc&quot;;\nlet num &#x3D; 0;\nlet char &#x3D; &quot;&quot;;\n\n&#x2F;&#x2F; 先排序，后用正则处理个数\n\nstr &#x3D; str.split(&quot;&quot;).sort().join(&quot;&quot;);\n\nlet re &#x3D; &#x2F;(\\w)\\1+&#x2F;g;\n\nstr.replace(re, ($0, $1) &#x3D;&gt; &#123;\n  if (num &lt; $0.length) &#123;\n    num &#x3D; $0.length;\n    char &#x3D; $1;\n  &#125;\n&#125;);\n\n字符串查找a &#x3D; &quot;34&quot;;\nb &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回2\na &#x3D; &quot;35&quot;;\nb &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回 -1\na &#x3D; &quot;355&quot;;\nb &#x3D; &quot;1234355&quot;; &#x2F;&#x2F; 返回5\n\nfunction isContain(a, b) &#123;\n  for (let i in b) &#123;\n    if (a[0] &#x3D;&#x3D;&#x3D; b[i]) &#123;\n      let tmp &#x3D; true;\n      for (let j in a) &#123;\n        if (a[j] !&#x3D;&#x3D; b[~~i + ~~j]) &#123;\n          tmp &#x3D; false;\n        &#125;\n      &#125;\n      if (tmp) &#123;\n        return i;\n      &#125;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n\n实现千分位分隔符&#x2F;&#x2F; 保留三位小数\nparaseToMoney(1234.56); &#x2F;&#x2F; return &#39;1,234.56&#39;\nparaseToMoney(123456789); &#x2F;&#x2F; return 123,456,789\nparaseToMoney(1087654.321); &#x2F;&#x2F; return 1,087,654.321\n\nfunction paraseToMoney(params) &#123;\n  num &#x3D; parseFloat(num.toFixed(3));\n  let [integer, decimal] &#x3D; String.prototype.split.call(num, &quot;.&quot;);\n  integer &#x3D; integer.replace(&#x2F;\\d(?&#x3D;(\\d&#123;3&#125;))+$&#x2F;, &quot;$&amp;,&quot;);\n  return integer + &quot;.&quot; + (decimal ?? &quot;&quot;);\n&#125;\n\n判断是否是电话号码function isPhone(str) &#123;\n  let regx &#x3D; &#x2F;^1[34578]\\d&#123;9&#125;$&#x2F;;\n  return regx.test(str);\n&#125;\n\n判断是否是邮箱function isEmail(mail) &#123;\n  var regx &#x3D; &#x2F;^(a-zA-Z0-9_\\-)+@(a-zA-Z0-9_\\-)+(\\.[a-zA-Z0-9_\\-])+$&#x2F;;\n\n  return regx.test(email);\n&#125;\n\n校验身份证function isCard(number) &#123;\n  var regx &#x3D; &#x2F;(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)&#x2F;;\n\n  return regx.test(number);\n&#125;\n","slug":"2022-05-03string","date":"2022-05-04T00:00:00.000Z","categories_index":"前端","tags_index":"前端","author_index":"陈海龙"},{"id":"be2d536c56c87a429a3dc062a6c5cd1f","title":"架构设计引发的血案","content":"记录个bug,并在此文中规避此处记下 hexo-theme-aurora 源码bug，没空时候帮他改\n.article .article-content p &#123;\n    font-size: .875rem;\n    line-height: 1.25rem;\n    margin-bottom: 0.5rem;\n    padding-bottom: 1rem;\n    word-break: break-all;\n&#125;\nbug复现\n(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)\n    at async Promise.all (index 3)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\n(Use &#96;node --trace-warnings ...&#96; to show where the warning was created)\n(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 19)\n(node:29) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\n(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)\n    at async Promise.all (index 3)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\n(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 44)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)\n    at async Promise.all (index 2)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)\n    at async Promise.all (index 3)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)\n    at async Promise.all (index 2)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\n\n\n源代码const [resp] &#x3D; await Promise.all([\n  getLoginInfo(ctx),\n  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),\n  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),\n  CommonModel.effects.getDataReport(req, ctx),\n])\n\nif (resp.success) &#123;\n  UserModal.actions.setUser(resp.result, req)\n&#125;\n增加异常捕获const [resp] &#x3D; await Promise.all([\n  getLoginInfo(ctx),\n  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),\n  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),\n  CommonModel.effects.getDataReport(req, ctx),\n]).catch(e&#x3D;&gt;&#123;\n  console.log(&quot;发生错误&quot;)\n  console.log(e)\n&#125;)\n日志日志仅 Forbidden 有效信息，大概是接口\n发生错误\nError: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:13144:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:12208:22)\n\n\n\n总结：\n因为acl 企业权限整了180天（顶配），时不时就出现系统瘫痪的情况，日常、线上都有此问题这架构设计的，估计没谁了。完全可以改成离职后，系统自动将用户禁权即可\n除此之外，sso也有个通病，三个月没改过密码，用户账户无法登录，需要重新密码方可登录\n\n","slug":"2022-04-29nextjs","date":"2022-04-29T02:56:00.000Z","categories_index":"bug","tags_index":"bug","author_index":"陈海龙"},{"id":"ea6c6af45eb8fb66a729fbe0ec8cd8f3","title":"Nestjs 结合 knife4j","content":"nest-knife4jknife4j githubknife4j 文档knife4j可以理解为一套swagger皮肤，不使用knife4j默认是swagger 1版本的样式\n","slug":"2022-02-29node","date":"2022-03-01T11:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"陈海龙"},{"id":"0523d16168244c5c50ce4e647b1f2e1c","title":"Nestjs文件上传","content":"文件上传Nestjs 上传文件Nestjs 上传文件\n","slug":"2022-02-28node","date":"2022-02-28T12:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"陈海龙"},{"id":"517bb0f5aa3a9a70442efc92a9ecc4e8","title":"React 拖拽兼容","content":"拖拽在web pc 端、iframe、h5移动端存在差异\nweb pc 端支持：onMouseDown、onMouseUp、onMousemove、onDragStart、onDragEnd、nDragOver\niframe web pc 端支持：onMouseDown、onMouseUp、onMousemove\nh5移动端支持：onTouchStart、onTouchEnd、onTouchmove代码\n\nexport default function Draggable(props: Props) &#123;\n  const &#123; children, style, className, onDragFinish, onDraggingStart, onPositionGet, boundary &#x3D; &#123; x: MARGIN_TO_PAGE, y: MARGIN_TO_PAGE &#125; &#125; &#x3D; props\n  const [dragging, setDragging] &#x3D; useState(false)\n  const [attaching, setAttaching] &#x3D; useState(false)\n  const [top, setTop] &#x3D; useState(0)\n  const [left, setLeft] &#x3D; useState(0)\n  const ghostRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()\n  const elRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()\n\n  const onDragStart &#x3D; useCallback((e: DragEvent&lt;HTMLDivElement&gt; | TouchEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123;\n    let x\n    let y\n    if (isDrag(e)) &#123;\n      if (e.target !&#x3D;&#x3D; elRef.current) &#123;\n        return\n      &#125;\n      e.dataTransfer.setDragImage(emptyImg, 0, 0)\n      x &#x3D; e.clientX\n      y &#x3D; e.clientY\n    &#125; else &#123;\n      if (!e.target || !(e.target instanceof HTMLElement)) &#123;\n        return\n      &#125;\n      if (!parentHasClass(e.target, [rootStyles.feedbackRoot])) &#123;\n        return\n      &#125;\n      x &#x3D; e.touches[0].clientX\n      y &#x3D; e.touches[0].clientY\n    &#125;\n    e.stopPropagation()\n\n\n    const rect &#x3D; e.currentTarget.getBoundingClientRect()\n    const offsetX &#x3D; x - rect.x\n    const offsetY &#x3D; y - rect.y\n    setTop(rect.y)\n    setLeft(rect.x)\n    setDragging(true)\n\n    if (isDrag(e)) &#123;\n      dragoverHandle &#x3D; (event: DragEvent) &#x3D;&gt; &#123;\n        if (event.clientX || event.clientY) &#123;\n          setTop(event.clientY - offsetY)\n          setLeft(event.clientX - offsetX)\n        &#125;\n      &#125;\n      &#x2F;&#x2F; firefox 中，ondrag 拿不到鼠标的坐标，所以这里使用 document 的 dragover\n      document.addEventListener(&#39;dragover&#39;, dragoverHandle)\n    &#125; else &#123;\n      dragoverHandle &#x3D; (event: TouchEvent) &#x3D;&gt; &#123;\n        const touch &#x3D; event.touches[0]\n        if (touch.clientX || touch.clientY) &#123;\n          setTop(touch.clientY - offsetY)\n          setLeft(touch.clientX - offsetX)\n        &#125;\n      &#125;\n      document.addEventListener(&#39;touchmove&#39;, dragoverHandle)\n    &#125;\n    onDraggingStart()\n  &#125;, [])\n\n  const onDragEnd &#x3D; useCallback((event) &#x3D;&gt; &#123;\n    if (!ghostRef.current) &#123;\n      setDragging(false)\n      return\n    &#125;\n    const rect &#x3D; ghostRef.current.getBoundingClientRect()\n    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)\n\n    setTop(abs.top)\n    setLeft(abs.left)\n    setAttaching(true)\n\n    if (isDrag(event)) &#123;\n      document.removeEventListener(&#39;dragover&#39;, dragoverHandle)\n    &#125; else &#123;\n      document.removeEventListener(&#39;touchmove&#39;, dragoverHandle)\n    &#125;\n\n    &#x2F;&#x2F; onPosition &amp;&amp; onPosition(rel) &#x2F;&#x2F; 其他业务\n\n\n    dragoverHandle &#x3D; null\n\n    setTimeout(() &#x3D;&gt; &#123;\n      onDragFinish(rel)\n      setAttaching(false)\n      setDragging(false)\n    &#125;, 300)\n  &#125;, [])\n\n  const onMousedown &#x3D; useCallback((e) &#x3D;&gt; &#123;\n    const x &#x3D; e.clientX\n    const y &#x3D; e.clientY\n    const rect &#x3D; e.currentTarget.getBoundingClientRect()\n    const offsetX &#x3D; x - rect.x\n    const offsetY &#x3D; y - rect.y\n    setTop(rect.y)\n    setLeft(rect.x)\n    setDragging(true)\n    if (e.preventDefault) &#123;\n      e.preventDefault()\n    &#125; else &#123;\n      e.returnValue &#x3D; false\n    &#125;\n    document.onmousemove &#x3D; function (ev: any) &#123;\n      const _event &#x3D; ev || window.event\n      const endx &#x3D; _event.clientX - offsetX\n      const endy &#x3D; _event.clientY - offsetY\n      setTop(endy)\n      setLeft(endx)\n    &#125;\n  &#125;, [])\n\n  const onMouseup &#x3D; useCallback((e) &#x3D;&gt; &#123;\n    if (!ghostRef.current) &#123;\n      setDragging(false)\n      return\n    &#125;\n    const rect &#x3D; ghostRef.current.getBoundingClientRect()\n    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)\n\n    setTop(abs.top)\n    setLeft(abs.left)\n    setAttaching(true)\n\n    document.onmousemove &#x3D; null\n    onPositionGet &amp;&amp; onPositionGet(rel)\n    setTimeout(() &#x3D;&gt; &#123;\n      onDragFinish(rel)\n      setAttaching(false)\n      setDragging(false)\n    &#125;, 300)\n  &#125;, [])\n &#x2F;&#x2F; 能力检测\n  if (&#39;dragover&#39; in document.documentElement || &#39;ontouchstart&#39; in document.documentElement) &#123;\n    return (\n      &lt;div\n        style&#x3D;&#123;style&#125;\n        className&#x3D;&#123;className&#125;\n        draggable\n        onTouchStart&#x3D;&#123;onDragStart&#125;\n        onTouchEnd&#x3D;&#123;onDragEnd&#125;\n        onDragStart&#x3D;&#123;onDragStart&#125;\n        onDragEnd&#x3D;&#123;onDragEnd&#125;\n        onDragOver&#x3D;&#123;prevent&#125;\n        ref&#x3D;&#123;elRef&#125;\n      &gt;\n        &lt;div\n          style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;\n          className&#x3D;&#123;cn(&#123;\n            [styles.dragging]: dragging,\n            [styles.attaching]: attaching,\n          &#125;)&#125;\n          ref&#x3D;&#123;ghostRef&#125;\n        &gt;\n          &#123;children&#125;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n  return (\n    &lt;div\n      style&#x3D;&#123;style&#125;\n      className&#x3D;&#123;className&#125;\n      draggable\n      onMouseDown&#x3D;&#123;onMousedown&#125;\n      onMouseUp&#x3D;&#123;onMouseup&#125;\n      ref&#x3D;&#123;elRef&#125;\n    &gt;\n      &lt;div\n        style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;\n        className&#x3D;&#123;cn(&#123;\n          [styles.dragging]: dragging,\n          [styles.attaching]: attaching,\n        &#125;)&#125;\n        ref&#x3D;&#123;ghostRef&#125;\n      &gt;\n        &#123;children&#125;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;","slug":"2022-02-27react","date":"2022-02-27T13:30:47.000Z","categories_index":"React","tags_index":"React","author_index":"陈海龙"},{"id":"4bcdaa6034eed07b809bf3bc6eec819f","title":"React DOM","content":"17.0.0 (October 20, 2020)\n\n\n\n\n\n\n\n\nDelegate events to roots instead of document来看下原因\n\n\n\n\n\n\n\n\n\nReact自首次发布以来一直在自动执行事件委派。它直接在文档节点上为每个事件类型附加一个处理程序。\n\n\n\n\n\n\n\n\n\n虽然它提高了应用程序的性能，但由于文档节点上的事件委派，已经报告了许多问题。\n\n\n\n\n\n\n\n\n\n为了演示其中一个问题，让我们以select下拉列表为例。下面示例中的CountryDropDown是用于国家选择的React组件，它将被呈现给id为React root的div。react DOM容器封装在id为main的div中，该div有一个包含stopPropagation（）的更改事件。\n&lt;!--Div&#39;s change event contains stopPropagation()--&gt;\n&lt;div id&#x3D;&quot;main&quot;&gt;\n  &lt;!--Div where react component will be rendered --&gt;\n  &lt;div id&#x3D;&quot;react-root&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\nclass CountryDropDown extends React.Component &#123;\n  state &#x3D; &#123;\n    country: &#39;&#39;,\n  &#125;\n  const handleChange &#x3D; e &#x3D;&gt; &#123;\n    this.setState(&#123; country: e.target.value &#125;);\n  &#125;\n  render() &#123;\n    return (\n      &lt;table class&#x3D;&quot;table table-striped table-condensed&quot;&gt;\n        &lt;thead&gt;\n          &lt;tr&gt;\n            &lt;th&gt;Country&lt;&#x2F;th&gt;\n            &lt;th&gt;Selected country&lt;&#x2F;th&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;thead&gt;\n        &lt;tbody&gt;\n          &lt;tr&gt;\n            &lt;td&gt;\n              &lt;select value&#x3D;&#123;this.state.country&#125;\n                onChange&#x3D;&#123;this.handleChange&#125;\n              &gt;\n                &lt;option value&#x3D;&quot;&quot;&gt;--Select--&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;India&quot;&gt;India&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;US&quot;&gt;US&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;Dubai&quot;&gt;Dubai&lt;&#x2F;option&gt;\n              &lt;&#x2F;select&gt;\n            &lt;&#x2F;td&gt;\n            &lt;td&gt;\n              &#123;this.state.country&#125;\n            &lt;&#x2F;td&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;tbody&gt;\n      &lt;&#x2F;table&gt;\n    );\n  &#125;\n&#125;\nReactDOM.render(&lt;CountryDropDown &#x2F;&gt;, document.getElementById(&#39;react-root&#39;));\n\n\n\n\n\n\n\n\n\n\n将更改事件附加到主div\ndocument.getElementById(&quot;main&quot;).addEventListener(\n  &quot;change&quot;,\n  function (e) &#123;\n    e.stopPropagation();\n  &#125;,\n  false\n);\n\n\n\n\n\n\n\n\n\n当选择一个国家时，我们无法看到所选的国家\n\n\n\n\n\n\n\n\n\n此意外行为的原因是附加到文档节点的onChange dropdown事件。包含e.stopPropagation（）的主div的change事件阻止了下拉菜单的onChange事件。\n\n\n\n\n\n\n\n\n\n为了解决此类问题，React 17不再在文档级别附加事件处理程序。相反，它将它们附加到根DOM容器中，React树将被渲染到该容器中。\n\n\n\n\n\n\n\n\n\n在React 17中进行更改后，事件被附加到根DOM容器，React树被呈现到该容器中。在我们的示例中，onChange事件的下拉列表将附加到id为react root的div。当选择任何国家&#x2F;地区呈现预期行为时，将触发此事件。\n","slug":"2022-05-04react","date":"2022-02-27T13:30:47.000Z","categories_index":"React","tags_index":"React","author_index":"陈海龙"},{"id":"0fe71bf4ca9007e9b607927107758aa8","title":"Sentry错误日志获取","content":"\n先上图\n\n\n\nThis is a quick getting started guide. For in-depth instructions on integrating Sentry with React, view our complete documentation.\nTo instrument your React application with Sentry, first install the @sentry/react and @sentry/tracing packages:\n# Using yarn\nyarn add @sentry&#x2F;react @sentry&#x2F;tracing\n\n# Using npm\nnpm install --save @sentry&#x2F;react @sentry&#x2F;tracing\n\nNext, import and initialize the Sentry module as early as possible, before initializing React:\nimport React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport * as Sentry from &quot;@sentry&#x2F;react&quot;;\nimport &#123; Integrations &#125; from &quot;@sentry&#x2F;tracing&quot;;\nimport App from &quot;.&#x2F;App&quot;;\n\nSentry.init(&#123;\n  dsn: &quot;https:&#x2F;&#x2F;a5f1c39789b24bb7a434868b677e0c65@&#x2F;1063&quot;,\n  integrations: [new Integrations.BrowserTracing()],\n\n  &#x2F;&#x2F; Set tracesSampleRate to 1.0 to capture 100%\n  &#x2F;&#x2F; of transactions for performance monitoring.\n  &#x2F;&#x2F; We recommend adjusting this value in production\n  tracesSampleRate: 1.0,\n&#125;);\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&quot;root&quot;));\n\n&#x2F;&#x2F; Can also use with React Concurrent Mode\n&#x2F;&#x2F; ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App &#x2F;&gt;);\n\nThe above configuration captures both error and performance data. To reduce the volume of performance data captured, change tracesSampleRate to a value between 0 and 1.\nAfter this step, Sentry will report any uncaught exceptions triggered by your application.\nYou can trigger your first event from your development environment by raising an exception somewhere within your application. An example of this would be rendering a button whose onClick handler attempts to invoke a method that does not exist:\nreturn &lt;button onClick&#x3D;&#123;methodDoesNotExist&#125;&gt;Break the world&lt;&#x2F;button&gt;;\n\nOnce you’ve verified the library is initialized properly and sent a test event, consider visiting our complete React docs. There you’ll find additional instructions for surfacing valuable context from React error boundaries, React Router, Redux, and more.\n","slug":"2021-06-20sentry","date":"2021-06-20T12:12:47.000Z","categories_index":"Web","tags_index":"Web","author_index":"陈海龙"},{"id":"40c248981d4dc9431fe8a0d461ef29a9","title":"CSS 自动生成 .d.ts","content":"CSS Module Typedvscode 插件列表中有好多个，不要安装错了\n\naddresslink\nInstallInstall deps first:\nrequirenpm install typed-css-modules\nif you need lessnpm install less\nif you need scss&#x2F;sassnpm install sass\nif you need stylusnpm install stylus\n\n\n\n\n\n\n\n\n\nModules can be installed globally. yarn is supported.\n\n\n\n\n\n\n\n\n\nTo switch the package manager (npm or yarn), you need to change the settings npm.packageManager of the built-in module vscode.npm.\nConfiguringBy default, the option to automatically format .d.ts files using eslint is enabled. You can disable this feature through the setting “typed-css-modules.eslint.enable”: false.\nUsageput\n// @type\nor\n/* @type */\nahead of your .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl file, and save, you will get a d.ts file in same directory.\npreview\ndemo&#x2F;* @type *&#x2F;\n\n.root &#123;\n  padding: 16px;\n  min-height: 100%;\n\n  .empty-wrapper &#123;\n    height: 380px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n  &#125;\n\n  &gt; h3 &#123;\n    font-size: inherit;\n    margin-bottom: 4px;\n  &#125;\n\n  .toolbar-wrapper &#123;\n    position: relative;\n\n    .toolbar &#123;\n      position: absolute;\n      margin: 12px 0;\n      z-index: 1;\n\n      &amp;.static &#123;\n        position: static;\n      &#125;\n\n      &gt; *:not(:first-child) &#123;\n        margin-left: 8px;\n      &#125;\n    &#125;\n  &#125;\n  .buttons &#123;\n    button &#123;\n      margin-right: 8px;\n    &#125;\n  &#125;\n&#125;\n.use-select &#123;\n  width: 300px;\n&#125;\n\ndeclare const styles: &#123;\n  readonly root: string;\n  readonly &quot;empty-wrapper&quot;: string;\n  readonly &quot;toolbar-wrapper&quot;: string;\n  readonly toolbar: string;\n  readonly static: string;\n  readonly buttons: string;\n  readonly &quot;use-select&quot;: string;\n&#125;;\nexport &#x3D; styles;\n\nproblem\n\n\n\n\n\n\n\n\nCreates .d.ts files from css-modules .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl files.\n\n\n\n\n\n\n\n\n\nError: vscode-typed-css-modules: Cannot find global module ‘typed-css-modules’\nnpm install -g typed-css-modules\n","slug":"2021-06-10scss2type","date":"2021-06-10T13:30:47.000Z","categories_index":"工具","tags_index":"工具,增效,vscode","author_index":"陈海龙"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-03-19T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"陈海龙"},{"id":"c52c4d2131250825dcd85d4b917f6cb4","title":"vscode GitHub Copilot","content":"Copilot\n\n\n\nYour AI pair programmer\n官网\n支持开发工具\n\n\n\n\n\n\n\n\nsupport Visual Studio Code, Neovim, and IntelliJ-based IDEs like JetBrains IntelliJ IDEA, Android Studio or PyCharm.\n注册\n需要人员审批通过，等[1-2 工作日]\n\n注册&#x2F;结果查看\n我等到了5月25号才通过，好像有两周的样子😂\n\n\n\n\n\n\n\n\n\nJoin the GitHub Copilot waitlistAccess is limited to a small group of testers during the technical preview of GitHub Copilot. Sign up today for your chance to try it out and help us improve.\n\n\n\n\n\n\n\n\n\nYou’re already on the waitlist for GitHub Copilot! We’ll notify you when we’ve enabled it on your account. Make sure your primary email address is up-to-date so we can notify you.\nvscode 安装插件 Copilot\n读源码的利器\n","slug":"2022-05-08vscode","date":"2020-05-08T03:25:00.000Z","categories_index":"vscode","tags_index":"增效,vscode,AI编程","author_index":"陈海龙"},{"id":"e8f86794a8b73abb4c26e162bb1c7550","title":"Git public key","content":"[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.name &quot;hailong.chen&quot;\n[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.email &quot;841660202@qq.com&quot;\n\n\n\n\n\n\n\n\n\n\nSSHSSH keysSSH key 可以让你在你的电脑和Code服务器之间建立安全的加密连接。 先执行以下语句来判断是否已经存在本地公钥：cat ~/.ssh/id_rsa.pub如果你看到一长串以 ssh-rsa或 ssh-dsa开头的字符串, 你可以跳过 ssh-keygen的步骤。提示: 最好的情况是一个密码对应一个ssh key，但是那不是必须的。你完全可以跳过创建密码这个步骤。请记住设置的密码并不能被修改或获取。你可以按如下命令来生成ssh keyssh-keygen -t rsa -C &quot;841660202@qq.com&quot;这个指令会要求你提供一个位置和文件名去存放键值对和密码，你可以点击Enter键去使用默认值。用以下命令获取你生成的公钥：cat ~/.ssh/id_rsa.pub复制这个公钥放到你的个人设置中的SSH&#x2F;My SSH Keys下，请完整拷贝从ssh-开始直到你的用户名和主机名为止的内容。如果打算拷贝你的公钥到你的粘贴板下，请参考你的操作系统使用以下的命令：Windows:clip &lt; ~/.ssh/id_rsa.pubMac:pbcopy &lt; ~/.ssh/id_rsa.pubGNU&#x2F;Linux (requires xclip):xclip -sel clip &lt; ~/.ssh/id_rsa.pubApplicationsEclipse如何在Eclipse中添加ssh key: https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_ConfigurationTip: Non-default OpenSSH key file names or locations如果，不管你有什么理由，当你决定去用一个非默认的位置或文件名去存放你的ssh key。你必须配置好你的ssh客户端以找到你的ssh私钥去连接Code服务器，对于OpenSSH客户端，这个通常是在~&#x2F;.ssh&#x2F;config类似的位置配置的：Host my-git.company.comRSAAuthentication yesIdentityFile ~&#x2F;my-ssh-key-directory&#x2F;company-com-private-key-filename\nLast login: Sun Apr 17 16:06:15 on console\nN&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.\n\nYou need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.\nN&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.\n\nYou need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.\n\nThe default interactive shell is now zsh.\nTo update your account to use zsh, please run &#96;chsh -s &#x2F;bin&#x2F;zsh&#96;.\nFor more details, please visit https:&#x2F;&#x2F;support.apple.com&#x2F;kb&#x2F;HT208050.\nchenhailong@chenhailongdeMacBook-Pro:~$ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop \n-bash: &#x2F;Users&#x2F;chenhailong&#x2F;Desktop: is a directory\nchenhailong@chenhailongdeMacBook-Pro:~$ cd &#x2F;Users&#x2F;chenhailong&#x2F;Desktop \nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.git\nCloning into &#39;841660202.github.io&#39;...\nThe authenticity of host &#39;github.com (20.205.243.166)&#39; can&#39;t be established.\nED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF&#x2F;zLDA0zPMSvHdkr4UvCOqU.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes\nWarning: Permanently added &#39;github.com&#39; (ED25519) to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.git\nCloning into &#39;841660202.github.io&#39;...\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub\n-bash: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub\ncat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.name &quot;hailong.chen&quot;\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ \nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.email &quot;841660202@qq.com&quot;\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub\ncat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ ssh-keygen -t rsa -C &quot;841660202@qq.com&quot;\nGenerating public&#x2F;private rsa key pair.\nEnter file in which to save the key (&#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa\nYour public key has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub\nThe key fingerprint is:\nSHA256:bdtIDeRXGKxGTEa&#x2F;Ex3QdPtVoOUiwuiq7YKjKrLakbU 841660202@qq.com\nThe key&#39;s randomart image is:\n+---[RSA 3072]----+\n|         +&#x3D;.o**.o|\n|       o +o.o*.oo|\n|      . o.+.* o..|\n|     .   oo&#x3D; +  o|\n|    . . S.+ +   .|\n|   o o   o + .   |\n| .o E     o .    |\n|&#x3D;..+             |\n|@oooo            |\n+----[SHA256]-----+\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.git\nCloning into &#39;841660202.github.io&#39;...\nremote: Enumerating objects: 441, done.\nremote: Counting objects: 100% (441&#x2F;441), done.\nremote: Compressing objects: 100% (216&#x2F;216), done.\nremote: Total 441 (delta 208), reused 401 (delta 168), pack-reused 0\nReceiving objects: 100% (441&#x2F;441), 1.34 MiB | 1.05 MiB&#x2F;s, done.\nResolving deltas: 100% (208&#x2F;208), done.\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ \n\n\n设置github SSH keyshttps://github.com/settings/keys\n","slug":"2016-06-20git","date":"2019-10-30T13:30:47.000Z","categories_index":"git","tags_index":"git","author_index":"陈海龙"},{"id":"2f05eb6cd7f25d74fcf01b828267389c","title":"MAC Iterm2美化终端","content":"MAC 环境注意：以下内容仅限MAC,其他环境，请自行谷歌\noh-my-zsh 插件推荐 :\nautojump 这个没用起来，使用没什么效果🥹\nzsh-autosuggestion 命令行输入有提示，（命令下载失败，手动下载，拷贝到 ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions）\nzsh-syntax-highlighting\n\n安装zsh1.使用 brew 安装\nbrew install oh-my-zsh\n2. 手动安装\ngit clone git:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh.git ~&#x2F;.oh-my-zsh\n\ncp ~&#x2F;.oh-my-zsh&#x2F;templates&#x2F;zshrc.zsh-template ~&#x2F;.zshrc\n\n\n安装 autojump1.安装\nbrew install autojump\n2.配置code ~/.zshrc，把以下代码加到尾部\n# 使用brew安装的\n\n[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh\nsource $ZSH&#x2F;oh-my-zsh.sh\n\n# 使用git安装的\n\n[[ -s ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh\n3.刷新配置\nsource ~&#x2F;.zshrc\n安装 zsh-autosuggestiongit clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestions\n\n安装 zsh-syntax-highlightinggit clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting\n\n刷新配置最后用 source ~/.zshrc 命令更新配置文件\n.zshrc 配置如下：\n自己电脑配置，下面截图是办公电脑截图# If you come from bash you might have to change your $PATH.\n# export PATH&#x3D;$HOME&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:$PATH\n\n# Path to your oh-my-zsh installation.\nexport ZSH&#x3D;&quot;$HOME&#x2F;.oh-my-zsh&quot;\n\n# Set name of the theme to load --- if set to &quot;random&quot;, it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;Themes\nZSH_THEME&#x3D;&quot;robbyrussell&quot;\n\n# Set list of themes to pick from when loading at random\n# Setting this variable when ZSH_THEME&#x3D;random will cause zsh to load\n# a theme from this variable instead of looking in $ZSH&#x2F;themes&#x2F;\n# If set to an empty array, this variable will have no effect.\n# ZSH_THEME_RANDOM_CANDIDATES&#x3D;( &quot;robbyrussell&quot; &quot;agnoster&quot; )\n\n# Uncomment the following line to use case-sensitive completion.\n# CASE_SENSITIVE&#x3D;&quot;true&quot;\n\n# Uncomment the following line to use hyphen-insensitive completion.\n# Case-sensitive completion must be off. _ and - will be interchangeable.\n# HYPHEN_INSENSITIVE&#x3D;&quot;true&quot;\n\n# Uncomment one of the following lines to change the auto-update behavior\n# zstyle &#39;:omz:update&#39; mode disabled  # disable automatic updates\n# zstyle &#39;:omz:update&#39; mode auto      # update automatically without asking\n# zstyle &#39;:omz:update&#39; mode reminder  # just remind me to update when it&#39;s time\n\n# Uncomment the following line to change how often to auto-update (in days).\n# zstyle &#39;:omz:update&#39; frequency 13\n\n# Uncomment the following line if pasting URLs and other text is messed up.\n# DISABLE_MAGIC_FUNCTIONS&#x3D;&quot;true&quot;\n\n# Uncomment the following line to disable colors in ls.\n# DISABLE_LS_COLORS&#x3D;&quot;true&quot;\n\n# Uncomment the following line to disable auto-setting terminal title.\n# DISABLE_AUTO_TITLE&#x3D;&quot;true&quot;\n\n# Uncomment the following line to enable command auto-correction.\n# ENABLE_CORRECTION&#x3D;&quot;true&quot;\n\n# Uncomment the following line to display red dots whilst waiting for completion.\n# You can also set it to another string to have that shown instead of the default red dots.\n# e.g. COMPLETION_WAITING_DOTS&#x3D;&quot;%F&#123;yellow&#125;waiting...%f&quot;\n# Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)\n# COMPLETION_WAITING_DOTS&#x3D;&quot;true&quot;\n\n# Uncomment the following line if you want to disable marking untracked files\n# under VCS as dirty. This makes repository status check for large repositories\n# much, much faster.\n# DISABLE_UNTRACKED_FILES_DIRTY&#x3D;&quot;true&quot;\n\n# Uncomment the following line if you want to change the command execution time\n# stamp shown in the history command output.\n# You can set one of the optional three formats:\n# &quot;mm&#x2F;dd&#x2F;yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;\n# or set a custom format using the strftime function format specifications,\n# see &#39;man strftime&#39; for details.\n# HIST_STAMPS&#x3D;&quot;mm&#x2F;dd&#x2F;yyyy&quot;\n\n# Would you like to use another custom folder than $ZSH&#x2F;custom?\n# ZSH_CUSTOM&#x3D;&#x2F;path&#x2F;to&#x2F;new-custom-folder\n\n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH&#x2F;plugins&#x2F;\n# Custom plugins may be added to $ZSH_CUSTOM&#x2F;plugins&#x2F;\n# Example format: plugins&#x3D;(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\n# 插件信息\nplugins&#x3D;(\n  git\n  zsh-syntax-highlighting\n  zsh-autosuggestions\n  autojump\n)\n\nsource $ZSH&#x2F;oh-my-zsh.sh\n\n[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh\nsource $ZSH&#x2F;oh-my-zsh.sh\n\n# User configuration\nPROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d $ &quot;\n# PROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[magenta]%&#125;$ &quot;\nPROMPT+&#x3D;&#39;%&#123;$reset_color%&#125;&#39;\n\nZSH_THEME_GIT_PROMPT_PREFIX&#x3D;&quot;%&#123;$fg_bold[blue]%&#125;&quot;\nZSH_THEME_GIT_PROMPT_SUFFIX&#x3D;&quot;%&#123;$reset_color%&#125; &quot;\nZSH_THEME_GIT_PROMPT_DIRTY&#x3D;&quot;%&#123;$fg[blue]%&#125;) %&#123;$fg[yellow]%&#125;✗&quot;\nZSH_THEME_GIT_PROMPT_CLEAN&#x3D;&quot;%&#123;$fg[blue]%&#125;)&quot;\n\n# 参考 https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b84d8b7b134e\n\n# code\tvalue\n# %T\t系统时间（时：分）\n# %*\t系统时间（时：分：秒）\n# %D\t系统日期（年-月-日）\n# %n\t用户名\n# %B - %b\t开始到结束使用粗体打印\n# %U - %u\t开始到结束使用下划线打印\n# %c\t仅当前文件夹路径\n# %d\t当前目录路径完整\n# %~\t当前目录相对于～的相对路径\n# %M\t计算机的主机名\n# %m\t计算机的主机名（在第一个句号之前截断\n# %l\t当前的tty\n\n\n\n# export MANPATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;man:$MANPATH&quot;\n\n# You may need to manually set your language environment\n# export LANG&#x3D;en_US.UTF-8\n\n# Preferred editor for local and remote sessions\n# if [[ -n $SSH_CONNECTION ]]; then\n#   export EDITOR&#x3D;&#39;vim&#39;\n# else\n#   export EDITOR&#x3D;&#39;mvim&#39;\n# fi\n\n# Compilation flags\n# export ARCHFLAGS&#x3D;&quot;-arch x86_64&quot;\n\n# Set personal aliases, overriding those provided by oh-my-zsh libs,\n# plugins, and themes. Aliases can be placed here, though oh-my-zsh\n# users are encouraged to define aliases within the ZSH_CUSTOM folder.\n# For a full list of active aliases, run &#96;alias&#96;.\n#\n# Example aliases\n# alias zshconfig&#x3D;&quot;mate ~&#x2F;.zshrc&quot;\n# alias ohmyzsh&#x3D;&quot;mate ~&#x2F;.oh-my-zsh&quot;\n\n推荐博客左岸博客使用效果\n\n","slug":"2017-07-09item2","date":"2019-10-30T13:30:47.000Z","categories_index":"工具","tags_index":"工具,增效","author_index":"陈海龙"},{"id":"8efdd810acba9c22bd1fc9e846bc2c89","title":"批量删除目录","content":"删除某个目录下所有子目录的node_modules# 查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 modu 执行删除\nfind &#x2F;tmp&#x2F;test&#x2F; -type d -name modu |xargs rm -rf\n\n# 查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 node_modules 执行删除\nfind &#x2F;tmp&#x2F;test&#x2F; -type d -name node_modules |xargs rm -rf","slug":"2019-10-30shell","date":"2019-10-30T13:30:47.000Z","categories_index":"Shell","tags_index":"增效,Shell","author_index":"陈海龙"},{"id":"9898e57ef559824ae32861e6fc17d4db","title":"Layoffs","content":"一家上市公司近期「B业」人数变化\n","slug":"2022-03-25Layoffs","date":"2019-10-30T13:30:47.000Z","categories_index":"Layoffs","tags_index":"Layoffs","author_index":"陈海龙"},{"id":"fa6ca4165b8b582ff1a69b1ccf9de547","title":"Nestjs服务端技术栈","content":"NestJS中文文档NestJS中文文档NestJS中文文档github 42.2K\n\n\n\n\n\n\n\n\n\nA progressive Node.js framework for building efficient, scalable, and enterprise-grade server-side applications on top of TypeScript &amp; JavaScript (ES6, ES7, ES8) 🚀\nTypeORMTypeORM中文文档github地址 26.3K\n\n\n\n\n\n\n\n\n\nORM for TypeScript and JavaScript (ES7, ES6, ES5). Supports MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, SAP Hana, WebSQL databases. Works in NodeJS, Browser, Ionic, Cordova and Electron platforms.\n","slug":"2021-06-30node","date":"2015-11-12T02:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"陈海龙"},{"id":"6f9f700e5a026be1d86747100cd27059","title":"Web office预览","content":"第一步将文件上传到你的服务器里，并支持url下载这个文件。第二步访问：http://view.officeapps.live.com/op/view.aspx?src=要预览文件的url地址（记得url编码哦）第三步可以使用iframe嵌入你的系统更多详情查看：https://www.microsoft.com/en-us/microsoft-365/blog/2013/04/10/office-web-viewer-view-office-documents-in-a-browser/?eu=true\n","slug":"2021-09-07web","date":"2015-11-12T02:55:47.000Z","categories_index":"Web","tags_index":"Web","author_index":"陈海龙"},{"id":"038636b617c3d3d43c65b95b558e1735","title":"node-dev","content":"在幕后用ts-node调整node-dev\n作用：在幕后用ts-node调整node-dev\n优点：\n任意依赖的文件改变时候，重启node process，但是共享ts编译线程。\n因为不需要每次ts-node编译的实例化，而提升性能\n\n\n配置项：\n注意事项：\n截图：\n\n","slug":"2021-11-02node","date":"2015-11-12T02:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"陈海龙"},{"id":"c15b0fd9b66d6749d042b7d88c5bcd12","title":"简书迁移到OSS","content":"命令cat .&#x2F;* |grep uploadimages.jianshu.io &gt; image.txt\nmkdir img3d\ncd img3d\nwget -i ..&#x2F;image.txt\nsed -i&#39;&#39; -e &#39;s&#x2F;!\\[image.png\\](&#x2F;&#x2F;g&#39; image.txt\nsed -i&#39;&#39; -e &#39;s&#x2F;)&#x2F;&#x2F;g&#39; image.txt\n迁移简书图片下载后重命名#! &#x2F;bin&#x2F;sh\n\nfor eachfile in &#96;ls -B&#96;\ndo  \n  # echo $&#123;eachfile%%\\%3F*&#125; # 截掉最后.txt    # $ % https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b3bdc3b3968e\n  filename&#x3D;$&#123;eachfile%%\\%3F*&#125;\n  filehead&#x3D;&#96;echo $eachfile | awk -F \\%3F &#39;&#123;print $1 &#125;&#39;&#96;\n  filelast&#x3D;&#96;echo $eachfile | awk -F \\%3F &#39;&#123;print $2 &#125;&#39;&#96;\n  # mv $filename.txt $&#123;filelast&#125;_$filehead.txt\n  # https:&#x2F;&#x2F;baijiahao.baidu.com&#x2F;s?id&#x3D;1726788915185806701&amp;wfr&#x3D;spider&amp;for&#x3D;pc\n  echo &#39;--&#39;\n  # echo $filename\n  echo $filehead #分割字符左边部分\n  echo $filelast #分割字符右边部分\n  # 右边文件存在的情况下才处理\n  if [ &quot;$filelast&quot; !&#x3D; &quot;&quot; ]\n  then\n    echo &#39;执行rename &#39;\n    mv $eachfile $filehead\n  fi\n\ndone\n","slug":"2022-04-27mv-blog-jianshu","date":"2015-11-12T02:55:47.000Z","categories_index":"Shell","tags_index":"Shell","author_index":"陈海龙"}]