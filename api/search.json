[{"id":"c370dd6ecfc84fe9fdfa77b1a6f29341","title":"待办事项","content":"近期计划\n immerjs\n 代理\n 学习一些算法\n 了解 mobx\n react 源码运行流程复习\n vue3 语法复习\n\n未来\n注重 设计模式、算法、源码\n\n长期待办&#x2F;&#x2F; 1. headless-recorder\n&#x2F;&#x2F; 2. lightHouse https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangdou369098655&#x2F;article&#x2F;details&#x2F;122531766\n&#x2F;&#x2F; 3. 博客封面生成\n&#x2F;&#x2F;              https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7132111156554301471?share_token&#x3D;4d225658-a9a2-4288-bc4e-892ca5f361fa\n&#x2F;&#x2F; 4. 装饰器模式 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;decorator\n&#x2F;&#x2F; 5. iconfont自定义图标 （链接放错了，以后补上，先删掉了）\n&#x2F;&#x2F; 6. 函数式编程 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;function-production\n&#x2F;&#x2F; 7. 换肤 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;theme-scss\n&#x2F;&#x2F; 8.[x] vscode setting sync 另一台电脑配置无法同步到本电脑\n&#x2F;&#x2F; 9.[x]item2本机重新配置\n&#x2F;&#x2F; 10.[x]vscode 代码片段在md上失效了\n&#x2F;&#x2F; 11.[x]typescript 工具类型源码\n&#x2F;&#x2F; 12. react源码\n&#x2F;&#x2F; 13. ocr桌面端工具 可以借鉴：想使用 tauri 搞，没遇到好的截屏\n&#x2F;&#x2F;                     1. https:&#x2F;&#x2F;github.com&#x2F;wulkano&#x2F;Kap  react + Electron开发\n&#x2F;&#x2F;                     2. vscode插件 ImageToText\n&#x2F;&#x2F; 14.react源码 debugger https:&#x2F;&#x2F;blog.csdn.net&#x2F;lin_fightin&#x2F;article&#x2F;details&#x2F;125136985?spm&#x3D;1001.2014.3001.5502\n&#x2F;&#x2F; 15. [x]如何让一个知识点分析图动起来？ ppt动画\n&#x2F;&#x2F; 16. paste code to snippets 可以进一步优化\n&#x2F;&#x2F; 17. 进程的stdout信息 反应到pod上 然后被k8s的日志收集系统收集和处理后 存储在日志平台的 https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;92a4c11e77ba\n&#x2F;&#x2F; 18. [x]文件抓取缓存在指定文件夹下【优先级高】 fileName &#x3D;》download disk\n&#x2F;&#x2F; 19. node-kafka(以前我总听成 ‘卡不卡’， 我回‘不卡不卡’)\n&#x2F;&#x2F; 20. 封装公用预览组件，支持各种形式,pc、mobile\n&#x2F;&#x2F; 21. git https:&#x2F;&#x2F;blog.csdn.net&#x2F;Q1761991696&#x2F;article&#x2F;details&#x2F;123572766\n&#x2F;&#x2F; 22. [x]gif 播放控制\n&#x2F;&#x2F;                 方案1: png + gif :https:&#x2F;&#x2F;www.cnblogs.com&#x2F;volodya&#x2F;p&#x2F;15897439.html\n&#x2F;&#x2F;                 方案2: canvas : https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;d5cc47f6a998?utm_campaign&#x3D;haruki\n&#x2F;&#x2F;                 方案3: 静态图 + video 实现 知乎 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;41543963\n&#x2F;&#x2F; 23. threejs https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7112696052884439070\n&#x2F;&#x2F; 24. [x]redux中间件，自动生成action、reducer、effect\n&#x2F;&#x2F; 25. ts. 直接在js中使用 requirets 代码丢了，要重写\n&#x2F;&#x2F; 26. 业务场景chat bot机器人\n&#x2F;&#x2F; 27. umd包 https:&#x2F;&#x2F;blog.csdn.net&#x2F;Luckyzhoufangbing&#x2F;article&#x2F;details&#x2F;109221059\n&#x2F;&#x2F; 28. vscode 插件段落，自动段落序列化（待实现，可以为md编写提速）\n&#x2F;&#x2F; 29. 蜜壳组件库重构\n\n事项：\n\n\nppt\n好的博客JerryWang_汪子熙 \n其他记录 未整理\n\nahooks 中那些控制“时机”的 hook 都是怎么实现的？\nvs-utils\njson 数据格式化\nrestful path format\n\nPOST &#x2F; api &#x2F; problem;\n\n&#x2F;api&#x2F;problem POST\n\n&#x2F;api&#x2F;problem&#x2F;&#123;id&#125; POST\n\n\nrestful path to name\n\n…or create a new repository on the command line\necho &quot;# big-screen-demo&quot; &gt;&gt; README.md\ngit init\ngit add README.md\ngit commit -m &quot;first commit&quot;\ngit branch -M main\ngit remote add origin git@github.com:841660202&#x2F;big-screen-demo.git\ngit push -u origin main\n…or push an existing repository from the command line\ngit remote add origin git@github.com:841660202&#x2F;big-screen-demo.git\ngit branch -M main\ngit push -u origin main\n…or import code from another repository\nYou can initialize this repository with code from a Subversion, Mercurial, or TFS project.\n","slug":"todo","date":"2099-12-14T03:59:59.000Z","categories_index":"Todo","tags_index":"Todo","author_index":"举手摘月亮"},{"id":"317fa629ebf2e28e8e30a2ac41c06f40","title":"link","content":"认知\n横向对比\n纵向学习\n&#x2F;#&#x2F;post&#x2F;2023-02-23 思考\n\n第三方链接\n2023 面试真题之框架篇\n2023 前端面试真题之 JS 篇\n2023 面试真题之 CSS 篇\n2023 面试真题之浏览器篇\n2023 面试真题之手写&amp;代码运行篇\n金三银四，我为面试所准备的 100 道面试题以及答案，不看要遭老罪喽\n面试秘笈\n美团前端常考面试题（必备）\n京东前端二面高频手写面试题（持续更新中）\n2023 前端面试题总结\n当面试官问我前端可以做的性能优化有哪些\nRedux 与它的中间件：redux-thunk，redux-actions，redux-promise，redux-saga\n2023 高频前端面试题合集之网络篇\n面试官问我设计模式？我是这么回答的！其实你们都用过！\njs 面试题\n2023 面试真题之框架篇\n\n性能优化\n&#x2F;#&#x2F;post&#x2F;2022-07-27 性能优化\n&#x2F;#&#x2F;post&#x2F;2022-05-12performance\n&#x2F;#&#x2F;post&#x2F;2023-02-12Web_Performance\n&#x2F;#&#x2F;post&#x2F;2023-02-14web_lcp\n&#x2F;#&#x2F;post&#x2F;2023-02-14web_fid\n&#x2F;#&#x2F;post&#x2F;2023-02-14web_cls\n&#x2F;#&#x2F;post&#x2F;2023-02-19rn-performance\n&#x2F;#&#x2F;post&#x2F;2023-02-19rn-performance-o\nReact 性能分析神器 React Profiler 介绍\n\n非常重要\n&#x2F;#&#x2F;post&#x2F;2022-09-19qa\n&#x2F;#&#x2F;post&#x2F;2022-11-01 抽象相等比较\n&#x2F;#&#x2F;post&#x2F;2022-07-18 设计模式\n&#x2F;#&#x2F;post&#x2F;2022-10-27 设计模式\n&#x2F;#&#x2F;post&#x2F;2022-07-30js-scope\n&#x2F;#&#x2F;post&#x2F;2022-07-29js-eventloop\n&#x2F;#&#x2F;post&#x2F;2022-07-28js-fun\n&#x2F;#&#x2F;post&#x2F;2022-07-28js-closures\n&#x2F;#&#x2F;post&#x2F;2022-07-26http-CORS\n&#x2F;#&#x2F;post&#x2F;2022-07-26http-connect [230107]\n&#x2F;#&#x2F;post&#x2F;2022-07-19rn-架构变更\n&#x2F;#&#x2F;post&#x2F;2022-07-17html\n&#x2F;#&#x2F;post&#x2F;2022-07-17css\n&#x2F;#&#x2F;post&#x2F;2022-07-15TCP\n&#x2F;#&#x2F;post&#x2F;2022-07-15 安全\n&#x2F;#&#x2F;post&#x2F;2022-07-14webpack[undo]\n&#x2F;#&#x2F;post&#x2F;2022-06-15http\n&#x2F;#&#x2F;post&#x2F;2022-05-11http\n\n冷门知识\n&#x2F;#&#x2F;post&#x2F;2023-02-15web_storage\n\n常见面试题\n&#x2F;#&#x2F;post&#x2F;2022-11-23 面试\n&#x2F;#&#x2F;post&#x2F;2022-10-28 移动适配\n&#x2F;#&#x2F;post&#x2F;2022-10-24zhihu\n&#x2F;#&#x2F;post&#x2F;2022-10-23css-qa\n&#x2F;#&#x2F;post&#x2F;2022-10-21js-class\n&#x2F;#&#x2F;post&#x2F;2022-10-19js 表达式\n&#x2F;#&#x2F;post&#x2F;2022-10-18history\n&#x2F;#&#x2F;post&#x2F;2022-10-14useSearchParams\n&#x2F;#&#x2F;post&#x2F;2022-10-09tailwindcss\n&#x2F;#&#x2F;post&#x2F;2022-09-26react-params\n&#x2F;#&#x2F;post&#x2F;2022-09-25react 范型\n&#x2F;#&#x2F;post&#x2F;2022-08-24expirestorage\n&#x2F;#&#x2F;post&#x2F;2022-08-20ts\n&#x2F;#&#x2F;post&#x2F;2022-08-17es\n&#x2F;#&#x2F;post&#x2F;2022-07-16http\n&#x2F;#&#x2F;post&#x2F;2022-07-14js-arr\n&#x2F;#&#x2F;post&#x2F;2022-07-12cookie\n&#x2F;#&#x2F;post&#x2F;2022-06-23axios\n&#x2F;#&#x2F;post&#x2F;2022-06-23 点\n&#x2F;#&#x2F;post&#x2F;2022-06-22cos\n&#x2F;#&#x2F;post&#x2F;2022-06-22.history\n&#x2F;#&#x2F;post&#x2F;2022-06-16interview\n&#x2F;#&#x2F;post&#x2F;2022-06-10js-arr\n&#x2F;#&#x2F;post&#x2F;2022-06-10js-数据劫持\n&#x2F;#&#x2F;post&#x2F;2022-06-09ts-util-type\n&#x2F;#&#x2F;post&#x2F;2022-06-05https\n&#x2F;#&#x2F;post&#x2F;2022-05-31bug\n&#x2F;#&#x2F;post&#x2F;2022-05-28func\n&#x2F;#&#x2F;post&#x2F;2022-05-26code\n&#x2F;#&#x2F;post&#x2F;2022-05-23width0\n&#x2F;#&#x2F;post&#x2F;2022-05-23css\n&#x2F;#&#x2F;post&#x2F;2022-05-09cors\n&#x2F;#&#x2F;post&#x2F;2022-05-08varible\n&#x2F;#&#x2F;post&#x2F;2022-05-08interview\n&#x2F;#&#x2F;post&#x2F;2022-10-16js\n\n也很重要\n&#x2F;#&#x2F;post&#x2F;2022-07-17css\n&#x2F;#&#x2F;post&#x2F;2022-10-27 设计模式\n&#x2F;#&#x2F;post&#x2F;2022-05-03string\n&#x2F;#&#x2F;post&#x2F;2022-07-04js\n&#x2F;#&#x2F;post&#x2F;2022-07-16http\n&#x2F;#&#x2F;post&#x2F;2023-02-17rn-native\n&#x2F;#&#x2F;post&#x2F;2023-02-16eventloop\n&#x2F;#&#x2F;post&#x2F;2023-02-20priorities\n&#x2F;#&#x2F;post&#x2F;2023-02-05 面试\n&#x2F;#&#x2F;post&#x2F;2023-02-06 不可变\n&#x2F;#&#x2F;post&#x2F;2023-02-11 站点存储\n&#x2F;#&#x2F;post&#x2F;2023-02-08GC\n&#x2F;#&#x2F;post&#x2F;2022-07-14js-arr\n\n开放题\n&#x2F;#&#x2F;post&#x2F;2023-02-18 技术选型\n&#x2F;#&#x2F;post&#x2F;2023-02-04 工程化\n\n项目\n&#x2F;#&#x2F;post&#x2F;2023-02-12problem\n\n新技术关注度\n&#x2F;#&#x2F;post&#x2F;2023-02-19react18\n&#x2F;#&#x2F;post&#x2F;2022-07-19rn-架构变更\n\n算法\n&#x2F;#&#x2F;post&#x2F;2022-07-04js\n\n埋点&#x2F;上报\n打通大前端最后一公里之前端埋点与日志系统架构设计\n\n微前端\n2022 年 微前端技术调研- 图文并茂\n将微前端做到极致-无界微前端方案\n无界\n\nHTTPS 握手过程\n\n首先是 tcp 的三次握手建立连接\nclient 发送 client-random + 支持的加密算法集合\nserver 收到信息，返回选择一个加密算法+ server-random + 证书\nclient 验证证书有效性，并用 client-random+server-random 生成 pre-master 通过, 服务器公钥加密 发送给 server\nserver 收到 premaster，根据约定的加密算法对 client-random+server-random+pre-master（解密）生成 master-secret，然后发送预定成功\nclient 收到生成同样的 master-secert，对称加密秘钥传输完毕\n\n作者：前端小魔女链接：https://juejin.cn/post/7203504932995989560来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n浏览器验证证书在浏览器的菜单中点击“工具 or Internet 选项”，选择“内容”标签，点击“证书”按钮。当我们在访问该网站时，浏览器就会自动下载该网站的 SSL 证书，并对证书的安全性进行检查。浏览器需经过以下 5 个方面的检查后，才会在页面显示安全锁标志，正常显示部署了 SSL 证书的加密页面。\n\n检查 SSL 证书是否是由浏览器中“受信任的根证书颁发机构”颁发。\n检查 SSL 证书中的证书吊销列表。\n检查此 SSL 证书是否过期。\n检查部署此 SSL 证书的网站的域名是\n\nSI speed index 速度指数MDN Speed_index\n生成脚本var data &#x3D; &quot;&quot;;\nfor (let item of a) &#123;\n  _path &#x3D; item.filePath.replace(&quot;source&#x2F;_posts&quot;, &quot;&#x2F;#&#x2F;post&quot;).replace(&quot;.md&quot;, &quot;&quot;);\n  data +&#x3D; &#96;1. &lt;a href&#x3D;&quot;$&#123;_path&#125;&quot; target&#x3D;&quot;_blank&quot; &gt;$&#123;_path&#125;&lt;&#x2F;a&gt;\\n&#96;;\n&#125;\ncopy(data);\n","slug":"link","date":"2024-01-07T08:19:19.000Z","categories_index":"前端","tags_index":"前端","author_index":"举手摘月亮"},{"id":"8eccc4e7c50ae11b02bb829241892974","title":"vue3 vs vue2","content":"vue3 相对于 vue2 有哪些变化Vue 3 相对于 Vue 2 引入了一些重大变化和新功能。以下是 Vue 3 相对于 Vue 2 的一些主要变化：\n\n更好的性能：Vue 3 经过优化，具有更高的性能表现。它引入了基于 Proxy 的响应式系统，可以更精确地跟踪状态的更改，从而提供更高效的重新渲染和更新。\n\nComposition API：Vue 3 引入了 Composition API，它是一种新的 API 风格，允许开发者根据逻辑功能组织和重用代码。与 Vue 2 的 Options API 相比，Composition API 更灵活、可组合和易于维护。\n\n更好的 TypeScript 支持：Vue 3 对 TypeScript 的支持更加出色。通过类型推断，Vue 3 可以更好地与 TypeScript 集成，并提供更准确的类型定义。\n\nTeleport：Vue 3 引入了 Teleport，这是一种新的组件，可以将组件的内容渲染到 DOM 中的任意位置。Teleport 使得在组件层次结构中的任何地方进行渲染成为可能，这对于实现诸如模态框、弹出菜单等功能非常有用。\n\nFragments：Vue 3 引入了 Fragments，允许组件返回多个根元素，而不需要将它们包装在单个父元素中。这样可以更灵活地组织组件的结构，使得编写更清晰、简洁的模板变得更容易。\n\n更好的 Tree Shaking：Vue 3 的代码结构经过优化，使得 Tree Shaking（树摇）能够更好地工作，从而减少最终构建文件的大小。\n\n更好的递归组件：Vue 3 对递归组件的支持进行了改进，现在可以使用普通的组件选项来定义递归组件，而不需要使用特殊的name选项。\n\n\n这些是 Vue 3 相对于 Vue 2 的一些主要变化。虽然这些变化带来了一些新的学习曲线和迁移工作，但也为开发者提供了更强大、高效和灵活的工具和功能。\n每个组合式 API 的示例以下是每个组合式 API 的示例：\n\nsetup()\n\nimport &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      count: 0,\n    &#125;);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      state.count++;\n    &#125;;\n\n    return &#123; state, increment &#125;;\n  &#125;,\n&#125;;\n\n在这个示例中，setup()函数创建了一个响应式数据对象state，并定义了一个increment()函数，用于将count属性的值加 1。最后，setup()函数返回了一个包含state和increment属性的对象，这些属性可以在组件中使用。\n\nreactive()\n\nimport &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      message: &#39;Hello, World!&#39;,\n    &#125;);\n\n    return &#123; state &#125;;\n  &#125;,\n&#125;;\n\n在这个示例中，reactive()函数创建了一个响应式数据对象state，该对象包含一个message属性，其初始值为&#39;Hello, World!&#39;。在setup()函数中返回了一个包含state属性的对象，该对象可以在组件中使用。\n\nref()\n\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      count.value++;\n    &#125;;\n\n    return &#123; count, increment &#125;;\n  &#125;,\n&#125;;\n\n在这个示例中，ref()函数将 0 这个普通值转换成了响应式值，然后定义了一个increment()函数，用于将count的值加 1。最后，setup()函数返回了一个包含count和increment属性的对象，这些属性可以在组件中使用。\n\ncomputed()\n\nimport &#123; ref, computed &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    const doubleCount &#x3D; computed(() &#x3D;&gt; &#123;\n      return count.value * 2;\n    &#125;);\n\n    return &#123; count, doubleCount &#125;;\n  &#125;,\n&#125;;\n\n在这个示例中，computed()函数创建了一个计算属性doubleCount，其值是count的值乘以 2。doubleCount会根据count的变化自动更新。\n\nwatch()\n\nimport &#123; ref, watch &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const count &#x3D; ref(0);\n\n    watch(count, (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(&#96;count changed from $&#123;oldValue&#125; to $&#123;newValue&#125;&#96;);\n    &#125;);\n\n    const increment &#x3D; () &#x3D;&gt; &#123;\n      count.value++;\n    &#125;;\n\n    return &#123; count, increment &#125;;\n  &#125;,\n&#125;;\n\n在这个示例中，watch()函数监视count的变化，并在count的值发生变化时打印日志。\n\nonMounted() &#x2F; onUpdated() &#x2F; onUnmounted()\n\nimport &#123; onMounted, onUpdated, onUnmounted &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;Component mounted&#39;);\n    &#125;);\n\n    onUpdated(() &#x3D;&gt; &#123;\n      console.log(&#39;Component updated&#39;);\n    &#125;);\n\n    onUnmounted(() &#x3D;&gt; &#123;\n      console.log(&#39;Component unmounted&#39;);\n    &#125;);\n  &#125;,\n&#125;;\n\n在这个示例中，onMounted()\nreactive 与 ref 的区别reactive()和ref()是 Vue 3 中用于创建响应式数据的两种不同方式，它们之间有一些区别。\n\n使用场景:\n\n\nref()通常用于单个值的情况，例如计数器、表单输入等简单场景。\nreactive()通常用于对象或复杂数据结构的情况，例如状态管理、组件之间共享的数据等。\n\n\n返回值类型:\n\n\nref()返回一个包含value属性的对象，通过修改value属性的值来触发更新。例如：const count = ref(0);，在使用时需要通过count.value来访问和修改值。\nreactive()返回一个响应式的代理对象，可以直接访问和修改对象的属性。例如：const state = reactive(&#123; count: 0 &#125;);，可以直接使用state.count来访问和修改值。\n\n\n更新触发方式:\n\n\nref()的更新是通过修改value属性的值来触发的，只有修改value的值，才能触发更新。例如：count.value = 10;\nreactive()的更新是通过修改对象的属性值来触发的。例如：state.count = 10;\n\n\n引用传递:\n\n\n使用ref()创建的响应式值在不同地方引用时，仍然是同一个引用。这意味着如果将ref()的返回值作为参数传递给其他函数或组件时，传递的是同一个引用。\n使用reactive()创建的响应式对象在不同地方引用时，每个引用都是一个独立的响应式代理对象。这意味着传递给其他函数或组件的是独立的对象。\n\n总的来说，ref()适用于简单的值类型的响应式数据，而reactive()适用于复杂对象或数据结构的响应式数据。在使用时，可以根据具体情况选择合适的方式来创建响应式数据。\n组合式 API computed 与 watch 的区别computed()和watch()是 Vue 3 中组合式 API 中用于处理数据变化的两种不同方式，它们之间有一些区别。\n\n用法和语法：\n\n\ncomputed()用于创建计算属性，接受一个计算函数作为参数，并返回一个计算属性对象。计算属性会根据其依赖的响应式数据自动更新。使用时，可以像访问普通属性一样使用计算属性。\nwatch()用于监视响应式数据的变化，并在数据变化时执行回调函数。它接受两个参数，第一个参数是要监视的数据，第二个参数是回调函数。回调函数会在监视的数据发生变化时被调用。\n\n\n用途：\n\n\ncomputed()适用于计算和衍生响应式数据的场景。例如，根据一组响应式数据计算出一个衍生的结果，如根据商品的数量和单价计算总价。\nwatch()适用于监视数据的变化并执行一些副作用的场景。例如，监听表单输入字段的变化，并在每次变化时发送网络请求。\n\n\n触发方式：\n\n\ncomputed()的更新是惰性的，即只有当计算属性的依赖发生变化时，计算属性才会重新计算。在模板中访问计算属性时，会自动触发计算属性的计算过程。\nwatch()的更新是基于数据的实际变化的。当监视的数据发生变化时，回调函数会立即被调用。\n\n\n灵活性：\n\n\ncomputed()在定义时会自动处理依赖关系，并建立起与相关数据的关联。当依赖数据发生变化时，计算属性会自动更新。这种自动管理依赖关系的特性使得计算属性非常方便和易于使用。\nwatch()在监视数据时，可以手动指定需要监视的数据，也可以通过函数来指定需要监视的多个数据。这种灵活性使得可以在一个回调函数中处理多个相关的数据变化。\n\n总的来说，computed()适用于计算和衍生响应式数据的场景，而watch()适用于监视数据的变化并执行副作用的场景。在使用时，可以根据具体需求选择合适的方式来处理数据的变化。\n组合式 API computed 与 watch 的区别computed()和watch()是 Vue 3 中组合式 API 中用于处理数据变化的两种不同方式，它们之间有一些区别。\n\n用法和语法：\n\n\ncomputed()用于创建计算属性，接受一个计算函数作为参数，并返回一个计算属性对象。计算属性会根据其依赖的响应式数据自动更新。使用时，可以像访问普通属性一样使用计算属性。\nwatch()用于监视响应式数据的变化，并在数据变化时执行回调函数。它接受两个参数，第一个参数是要监视的数据，第二个参数是回调函数。回调函数会在监视的数据发生变化时被调用。\n\n\n用途：\n\n\ncomputed()适用于计算和衍生响应式数据的场景。例如，根据一组响应式数据计算出一个衍生的结果，如根据商品的数量和单价计算总价。\nwatch()适用于监视数据的变化并执行一些副作用的场景。例如，监听表单输入字段的变化，并在每次变化时发送网络请求。\n\n\n触发方式：\n\n\ncomputed()的更新是惰性的，即只有当计算属性的依赖发生变化时，计算属性才会重新计算。在模板中访问计算属性时，会自动触发计算属性的计算过程。\nwatch()的更新是基于数据的实际变化的。当监视的数据发生变化时，回调函数会立即被调用。\n\n\n灵活性：\n\n\ncomputed()在定义时会自动处理依赖关系，并建立起与相关数据的关联。当依赖数据发生变化时，计算属性会自动更新。这种自动管理依赖关系的特性使得计算属性非常方便和易于使用。\nwatch()在监视数据时，可以手动指定需要监视的数据，也可以通过函数来指定需要监视的多个数据。这种灵活性使得可以在一个回调函数中处理多个相关的数据变化。\n\n总的来说，computed()适用于计算和衍生响应式数据的场景，而watch()适用于监视数据的变化并执行副作用的场景。在使用时，可以根据具体需求选择合适的方式来处理数据的变化。\nvue3 是倾向于函数式变成还是面向对象编程？Vue 3 更倾向于函数式编程而不是面向对象编程。\nVue 3 引入了组合式 API，其中的核心思想是将组件的逻辑拆分为一组可重用的函数。这种方式更加符合函数式编程的理念，通过函数的组合和抽象来构建复杂的逻辑。\n组合式 API 鼓励开发者将逻辑抽象为纯函数，使得代码更加模块化、可测试和可维护。使用函数可以更好地组织和重用代码，提高代码的可读性和可维护性。\n而面向对象编程通常将逻辑封装在对象中，通过对象之间的交互来实现功能。尽管 Vue 3 仍然支持面向对象编程的方式，可以通过创建类和使用类的实例来编写组件，但推荐的方式是使用组合式 API。\n组合式 API 倡导使用函数来编写逻辑，而不是依赖于类和对象的继承和实例化。这种方式更加简洁、灵活，并且与函数式编程的思想更加契合。\n总的来说，虽然 Vue 3 仍然支持面向对象编程，但更倾向于函数式编程，通过组合式 API 提供了更强大的函数式编程能力，使代码更具可读性、可维护性和可测试性。\nTeleport 语法Teleport 是通过 &lt;teleport&gt; 元素和 to 属性来实现的，它的语法如下：\n&lt;teleport to&#x3D;&quot;目标选择器&quot;&gt;\n  &lt;!-- 要渲染的内容 --&gt;\n&lt;&#x2F;teleport&gt;\n\n\n&lt;teleport&gt;：用于包裹要渲染的内容的容器元素。它是 Teleport 的根元素。\nto 属性：指定要渲染到的目标位置。它可以是选择器字符串，表示要将内容渲染到与选择器匹配的元素内，或者是一个 DOM 元素的引用，表示要将内容渲染到该 DOM 元素内。\n\n在 &lt;teleport&gt; 元素内部，可以放置要渲染的内容，这可以是任何有效的 HTML 或 Vue 模板代码。\n通过使用 Teleport，你可以在组件树中的任意位置渲染内容。这对于实现全局弹窗、模态框、通知消息等功能非常有用。将内容渲染到 &lt;teleport&gt; 指定的目标位置后，它将脱离组件的父节点，成为目标位置的子节点。\n例如，在上面的示例中，我们使用 &lt;teleport&gt; 将模态框的内容渲染到 &lt;body&gt; 元素中，实现了一个全局的模态框效果。\n需要注意的是，为了确保 Teleport 正常工作，目标位置必须是组件所在的 DOM 树之外的一个位置。这样，Teleport 可以绕过父组件的 CSS 和样式隔离，从而在指定的目标位置渲染内容。\n总的来说，Teleport 提供了一种方便的方式来在组件树之外的位置渲染内容，并能够将其与其他组件进行解耦和灵活组合。\nTeleport 示例Teleport 是 Vue 3 中的一个特性，用于在组件树中的任意位置渲染内容。以下是一个 Teleport 的示例：\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;showModal &#x3D; true&quot;&gt;Open Modal&lt;&#x2F;button&gt;\n\n    &lt;teleport to&#x3D;&quot;body&quot;&gt;\n      &lt;div v-if&#x3D;&quot;showModal&quot; class&#x3D;&quot;modal&quot;&gt;\n        &lt;h2&gt;Modal Content&lt;&#x2F;h2&gt;\n        &lt;p&gt;This modal is teleported to the body.&lt;&#x2F;p&gt;\n        &lt;button @click&#x3D;&quot;showModal &#x3D; false&quot;&gt;Close&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;teleport&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  setup() &#123;\n    const showModal &#x3D; ref(false);\n\n    return &#123;\n      showModal,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.modal &#123;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  padding: 1rem;\n&#125;\n&lt;&#x2F;style&gt;\n\n在上述示例中，我们有一个按钮，点击该按钮会显示一个模态框。模态框的内容位于 &lt;teleport&gt; 元素内，通过设置 to 属性为 “body”，将模态框渲染到 &lt;body&gt; 元素中。\n使用 &lt;teleport&gt;，我们可以在组件的模板中声明要渲染到的位置，然后将内容放置在 &lt;teleport&gt; 内部。这样，我们可以轻松地将内容渲染到组件树之外的位置，例如在全局样式下方、在特定的容器中等。\n注意，Teleport 在 Vue 3 中取代了 Vue 2 中的 &lt;component&gt; 和 &lt;keep-alive&gt; 的功能。\nFragments 语法及示例Fragments（片段）是一种在 Vue 3 中用于包裹多个子元素的语法结构，它允许你在不引入额外 DOM 元素的情况下组织和渲染多个子元素。Fragments 可以通过两种方式来使用：&lt;template&gt; 标签和特殊的短语法。\n\n使用 &lt;template&gt; 标签：\n\n&lt;template&gt;\n  &lt;!-- Fragments 使用 &lt;template&gt; 标签包裹多个子元素 --&gt;\n  &lt;template&gt;\n    &lt;h1&gt;Header&lt;&#x2F;h1&gt;\n    &lt;p&gt;Paragraph&lt;&#x2F;p&gt;\n  &lt;&#x2F;template&gt;\n&lt;&#x2F;template&gt;\n\n在上述示例中，我们使用了一个外层的 &lt;template&gt; 标签来包裹多个子元素。这个外层的 &lt;template&gt; 标签本身不会在最终的渲染结果中产生任何额外的 DOM 元素，它只是用来作为一个容器，方便地组织和包裹多个子元素。\n\n使用特殊的短语法：\n\n&lt;template&gt;\n  &lt;!-- Fragments 使用特殊的短语法 --&gt;\n  &lt;&gt;\n    &lt;h1&gt;Header&lt;&#x2F;h1&gt;\n    &lt;p&gt;Paragraph&lt;&#x2F;p&gt;\n  &lt;&#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n在上述示例中，我们使用了特殊的短语法 &lt;&gt; 和 &lt;/&gt; 来表示一个 Fragment，即片段。它的作用与使用 &lt;template&gt; 标签相同，可以包裹多个子元素，并且在最终的渲染结果中不会生成额外的 DOM 元素。\n使用 Fragments 可以解决在 Vue 2 中遇到的组件模板中只能有一个根元素的限制。现在，你可以使用 &lt;template&gt; 标签或特殊的短语法来方便地组织和渲染多个子元素，而无需引入多余的 DOM 元素。\n需要注意的是，Fragments 只是在编写模板时的一种语法结构，它不会被渲染成实际的 DOM 元素。它的主要作用是帮助你更好地组织和布局模板中的多个子元素。\n总的来说，Fragments 提供了一种在 Vue 3 中组织和渲染多个子元素的方式，可以通过 &lt;template&gt; 标签或特殊的短语法来使用，避免了只能有一个根元素的限制。\n","slug":"2023-05-15vuee3","date":"2023-05-15T15:24:09.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"acc57bd22d883480671c69c000337b31","title":"knife4j","content":"上图\n\n\n\n😓，人才啊！\n","slug":"2023-05-15knife4j","date":"2023-05-15T10:38:24.000Z","categories_index":"思考","tags_index":"思考","author_index":"举手摘月亮"},{"id":"ad4b164a322c7a38979fb0b108e710ba","title":"fe->be","content":"为什么我觉得 Python 很难，语法内容非常多Python 是一种高级编程语言，它的语法相对于其他一些编程语言来说确实比较简洁和易读。相比于一些低级语言，Python 不需要过多关注底层细节，可以更专注于问题的解决和业务逻辑的实现。\n然而，对于初学者来说，学习任何一门编程语言都可能感到困难，包括 Python。以下是一些可能导致你觉得 Python 难以理解的原因：\n\n语法规则：学习任何编程语言都需要掌握其语法规则。尽管 Python 的语法相对简洁，但仍然需要了解变量、数据类型、条件语句、循环、函数等基本概念和语法结构。\n\n多样性和广泛性：Python 生态系统非常丰富，有许多第三方库和框架可供选择，因此你可能感到有很多内容需要学习。但不必担心，你可以根据自己的需求选择学习的内容，逐步扩展你的知识。\n\n编程思维：编程不仅仅是学习语法，还需要培养一种抽象思维和解决问题的能力。这需要时间和实践来发展，通过编写代码并解决实际问题来提升自己的编程能力。\n\n学习资源选择：有时候，选择合适的学习资源也会影响你对 Python 的学习感受。确保选择适合自己的教程、书籍或在线课程，可以帮助你更好地理解和学习 Python。\n\n\n记住，学习任何新的领域都需要时间和耐心。Python 作为一种高级编程语言，具有广泛的应用和强大的社区支持，一旦掌握了它的基本概念和语法，你会发现它是一门非常有用和灵活的语言。坚持学习，多写代码并解决实际问题，逐渐积累经验，你会越来越熟悉和自信地使用 Python。\npython 编程思维什么意思编程思维指的是一种解决问题和设计系统的思考方式和方法。它是指通过编程的思维方式来分析问题、提出解决方案并将其转化为计算机可执行的指令。具体来说，Python 编程思维包括以下几个方面：\n\n抽象化：将复杂的问题分解为更小、更简单的部分，通过定义和使用函数、类、模块等抽象概念来组织和管理代码。\n\n模块化：将大型任务划分为较小的模块，每个模块负责完成特定的功能，使得代码更易于理解、维护和复用。\n\n算法思维：思考如何设计高效的算法来解决问题，考虑时间和空间复杂度，并根据具体情况选择合适的数据结构和算法。\n\n逻辑思维：通过条件语句、循环和逻辑运算符来处理不同的情况，实现控制流程和逻辑判断。\n\n调试和问题解决：学会通过调试技巧和日志来定位和修复代码中的错误，以及解决遇到的问题。\n\n创造性思维：将问题和需求转化为创造性的解决方案，发挥创意和想象力，构建具有创新性和实用性的程序。\n\n\nPython 编程思维的核心是通过编程语言和工具来解决实际问题，并以计算机的方式思考和分析。它强调的是问题解决的方法、代码的组织结构、算法的设计和效率，以及迭代和优化的过程。通过培养良好的编程思维，你可以更加高效地解决问题，设计出更好的软件系统，并与其他开发者更好地合作和交流。\n前端转后端，编程思维应如何改变当前端开发人员转向后端开发时，编程思维需要进行一些调整和适应。虽然前端和后端都是编程任务，但两者在目标、技术栈和思考方式上存在一些差异。以下是前端转向后端时需要考虑的几个方面：\n\nAPI 开发和接口设计：后端开发通常涉及开发 API 接口，与前端进行数据交互。你需要了解 RESTful API 设计原则、HTTP 协议和常见的 API 工具和框架。\n\n安全性和权限控制：后端开发需要重视安全性和权限控制，例如用户认证、访问控制等。你需要学习如何进行安全编码和防止常见的安全漏洞，以保护用户数据和系统的安全性。\n\n逻辑和业务处理：后端开发更加注重逻辑和业务处理，需要深入理解业务需求，将其转化为后端代码逻辑。你需要熟悉后端的业务领域和相关技术，例如数据库操作、服务器端框架等。\n\n数据处理和存储：后端开发通常涉及与数据库进行交互、处理和存储数据。你需要了解数据库的基本概念和操作，掌握 SQL 查询语言，并学会使用适当的 ORM 工具进行数据操作。\n\n性能和扩展性：后端系统往往面临更大的数据量和并发请求，因此性能和扩展性变得更为重要。你需要学习如何优化数据库查询、处理大量数据和设计可扩展的系统架构。\n\n故障排查和日志记录?：后端开发需要具备故障排查和日志记录的能力，能够快速定位和修复问题。你需要学习如何使用调试工具、记录日志并进行故障排查。\n\n面向整个系统：后端开发需要考虑整个系统的架构和各个模块的协作。你需要了解系统的整体设计和不同组件之间的交互，以及如何与其他开发人员协作进行系统集成。\n\n\n在转向后端开发时，需要对这些方面进行学习和实践，并与前端开发的经验相结合。充分了解后端技术栈和相关工具，理解后端的需求和挑战，并逐步培养适应后端开发的编程思维和技能。\n如果含有 bug 的代码上线，会丢数据，bug 已经运行一段时间，怎么处理，好像解决不了了如果已经上线的代码中存在严重的 bug 并导致数据丢失，以下是一些建议来处理这种情况：\n\n紧急回滚：首先，立即回滚到一个可靠的版本，即将受影响的代码版本退回到上一个稳定的版本。这可以防止继续出现数据丢失的情况。\n\n数据恢复：如果数据丢失是由于 bug 导致的，你可以考虑从备份中恢复丢失的数据。如果没有备份，你可以尝试通过其他手段恢复数据，如与用户进行沟通、使用其他数据源等。\n\n问题分析：对于已经运行一段时间的 bug，你需要对问题进行详细的分析和排查，以找出根本原因。仔细检查代码、日志和错误报告，使用调试工具定位问题。了解问题的具体情况和影响范围对解决问题很重要。\n\n紧急修复：一旦发现了导致数据丢失的 bug，你需要尽快修复该 bug，并确保修复的代码经过充分的测试。修复后，可以进行测试环境的验证，确保问题不再重现。\n\n数据补救：如果数据丢失是不可逆转的，那么你可能需要考虑其他方法来弥补数据损失。这可能包括向用户道歉、提供补偿或手动恢复部分数据。具体的补救方法取决于问题的性质和受影响的数据。\n\n总结经验教训：从这次问题中吸取经验教训，并采取措施防止类似的问题再次发生。这可能包括改进代码审查流程、加强测试和质量保证、实施更严格的发布策略等。\n\n\n最重要的是要及时采取行动，并与团队合作解决问题。在处理这类紧急情况时，及时沟通和透明度对于与相关方保持良好的关系至关重要。同时，确保你的系统具备良好的监控和报警机制，可以及时发现和响应潜在的问题。\n后端常见的 bug 有哪些后端开发中常见的一些 bug 包括但不限于以下几种：\n\n输入验证问题：未对用户输入进行正确的验证和过滤，导致恶意用户提交恶意数据或造成系统崩溃。\n\n边界条件错误：未正确处理边界条件，例如数组越界、空指针引用等，导致程序崩溃或产生意外结果。\n\n并发和竞态条件：多个线程或进程同时访问共享资源，未进行适当的同步控制，导致数据错误或系统不稳定。\n\n内存泄漏：未正确释放申请的内存空间，导致内存占用不断增加，最终导致系统崩溃或性能下降。\n\n数据库操作问题：未正确处理数据库事务、锁定和索引，导致数据一致性问题或性能问题。\n\n跨站脚本攻击（XSS）：未正确过滤用户输入中的脚本代码，使恶意用户可以注入恶意脚本，并在其他用户浏览页面时执行。\n\nSQL 注入攻击：未正确过滤用户输入，使恶意用户可以在数据库查询中注入恶意 SQL 代码，从而获取敏感信息或破坏数据。\n\n配置错误：错误的配置文件设置、环境变量或权限设置，导致系统无法正常运行或暴露敏感信息。\n\n依赖项问题：未正确管理和更新项目所依赖的库和组件，导致版本冲突、安全漏洞或不兼容性问题。\n\n日志和异常处理问题：缺乏良好的日志记录和异常处理机制，导致问题排查困难或无法及时发现和解决问题。\n\n\n这些只是常见的一些后端 bug 类型，实际情况可能因项目和环境而异。为了尽量避免这些问题，需要进行严格的代码审查、单元测试和集成测试，同时保持良好的编码习惯和规范，以及关注安全性和性能优化。\n代码审查、单元测试和集成测试代码审查、单元测试和集成测试是常用的软件开发过程中的质量保证措施，它们有助于发现和修复潜在的问题，并确保软件的稳定性和可靠性。\n\n代码审查（Code Review）：代码审查是通过检查和评估代码质量来发现潜在问题和改进机会的过程。它通常由其他开发人员或团队成员对编写的代码进行检查。代码审查可以帮助发现潜在的错误、代码风格问题、性能问题等，提高代码的可读性和可维护性。常见的代码审查方法包括使用代码审查工具、代码走查会议等。\n\n单元测试（Unit Testing）：单元测试是针对软件中最小可测试单元（如函数、方法）的测试过程。它通过编写测试用例来验证代码的正确性，捕获潜在的错误和异常情况。单元测试应该覆盖不同的代码路径和边界条件，并对预期结果进行断言。常见的 Python 单元测试框架包括 unittest、pytest 和 nose 等。\n\n集成测试（Integration Testing）：集成测试是对多个组件或模块之间的交互进行测试的过程。它验证这些组件在一起协同工作的正确性和一致性。集成测试可以模拟真实的系统环境，并测试不同组件之间的接口和数据传递。常见的集成测试方法包括构建测试环境、使用自动化测试工具和编写集成测试用例等。\n\n\n代码审查、单元测试和集成测试在软件开发过程中都是非常重要的环节，它们有助于提高代码质量、减少 bug 和错误，并增强系统的稳定性。通过定期进行代码审查和测试，可以尽早发现和解决问题，避免问题在后续阶段扩大。此外，持续集成和自动化测试也是推动代码质量保证的重要实践，可以减少人工测试的工作量，提高开发效率。\n","slug":"2023-05-12fe_be","date":"2023-05-12T10:28:29.000Z","categories_index":"其他","tags_index":"其他","author_index":"举手摘月亮"},{"id":"c6848d81e0857e8e07365785ba422395","title":"ClickHouse","content":"clickhouse 是什么\nClickHouse® 是一个开源的面向列的数据库管理系统，允许实时生成分析数据报告\nClickHouse 是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)。\n\nClickHouse 是一个用于分析大规模数据的开源列式数据库管理系统。它专门设计用于高效地处理海量数据，并提供快速的查询和聚合功能。ClickHouse 最初由俄罗斯的 Yandex 开发，并于 2016 年开源发布。\nClickHouse 的主要特点包括：\n\n列式存储：ClickHouse 将数据按列存储在磁盘上，而不是行式存储。这种存储方式在分析工作负载下提供了更高的性能，因为它可以只读取和处理查询所需的列，而不需要读取整个行。\n\n高性能：ClickHouse 通过使用内存和磁盘的有效组合，以及针对列存储的数据压缩和编码技术，实现了快速的查询和聚合操作。它可以处理大规模数据集，并以秒级甚至毫秒级的响应时间返回查询结果。\n\n分布式架构：ClickHouse 支持分布式部署，可以在多台服务器上进行水平扩展。这使得它可以处理更大规模的数据，并提供更高的并发查询能力。\n\nSQL 兼容性：ClickHouse 支持标准 SQL 查询语言，这使得它易于使用和集成到现有的数据分析和处理流程中。它还提供了丰富的聚合函数和灵活的查询语法，以支持复杂的分析需求。\n\n实时数据插入：除了强大的查询能力，ClickHouse 还支持高吞吐量的实时数据插入。它可以接收连续流数据，并将其立即可用于查询和分析。\n\n\nClickHouse 在许多大型互联网公司和数据驱动型企业中被广泛应用于实时分析、业务智能、日志分析、时间序列分析等领域，它提供了一个可靠、高效的解决方案来处理大规模数据集的查询和分析需求。\nClickHouse 名字由来ClickHouse 这个名称的由来可以追溯到该项目的开发背景和创始团队。ClickHouse 最初是由俄罗斯的互联网公司 Yandex 开发的，Yandex 是俄罗斯最大的搜索引擎和在线服务提供商之一。\n根据 Yandex 官方的说法，ClickHouse 这个名字是在开发过程中选择的。”Click”一词暗指高效和快速的操作，而”House”则象征着数据的存储和管理。通过结合这两个词，表达了 ClickHouse 作为一个高性能数据库管理系统的核心理念。\n此外，”Click”还可以被视为一种声音效果，类似于点击鼠标或键盘的声音，这与 ClickHouse 的目标是快速响应用户查询和分析请求的特性相契合。\n因此，ClickHouse 这个名称反映了该数据库管理系统的关键特点和目标，即高性能、快速响应和数据存储。\n官方文档见\n代码仓库https://github.com/ClickHouse/ClickHouse\n\nOLAP 联机分析DBMS 数据库管理系统行式数据库常见的行式数据库系统有：MySQL、Postgres 和 MS SQL Server。\n列式数据库常见的列式数据库有： Vertica、 Paraccel (Actian Matrix，Amazon Redshift)、 Sybase IQ、 Exasol、 Infobright、 InfiniDB、 MonetDB (VectorWise， Actian Vector)、 LucidDB、 SAP HANA、 Google Dremel、 Google PowerDrill、 Druid、 kdb+。\n数据访问的场景不同的数据存储方式适用不同的业务场景\n\n进行了何种查询、多久查询一次以及各类查询的比例；\n每种类型的查询(行、列和字节)读取多少数据；\n读取数据和更新之间的关系；\n使用的数据集大小以及如何使用本地的数据集；\n是否使用事务,以及它们是如何进行隔离的；\n数据的复制机制与数据的完整性要求；\n每种类型的查询要求的延迟与吞吐量等等。\n\n大数据与非大数据，只在数据库上有区别？大数据和非大数据之间的区别不仅仅局限于数据库上，它们涉及到整个数据处理和分析生态系统的不同方面。以下是大数据和非大数据之间的一些区别：\n\n数据规模：大数据通常指数据量巨大、高速生成且多样化的数据集合。与之相对，非大数据通常是指相对较小且容易在单个系统或数据库中处理和分析的数据集。\n\n数据处理方式：由于大数据的规模庞大，传统的数据处理和分析方法可能无法有效处理它们。大数据通常需要使用分布式处理框架和技术，如 Hadoop、Spark 等，以及专门设计用于大规模数据处理的工具和算法。\n\n数据存储和管理：大数据的存储和管理需要考虑到可伸缩性、高可用性和容错性等因素。常见的大数据存储技术包括分布式文件系统（如 HDFS）和分布式数据库（如 HBase、Cassandra、ClickHouse 等），它们具备横向扩展和并行处理能力。\n\n数据处理速度：大数据处理通常需要更高的速度和实时性。大数据技术和工具旨在通过并行计算和分布式处理来提供快速的数据分析和查询响应。\n\n数据分析方法：大数据分析通常需要使用更高级的分析方法和算法，如机器学习、数据挖掘和深度学习等。这些方法可以从大数据中提取有意义的洞察，并支持预测、模式识别和智能决策等应用。\n\n\n尽管数据库在大数据处理中起着重要的角色，但大数据和非大数据之间的区别远不止于数据库。它们涉及到数据采集、存储、处理、分析和应用的整个生命周期，并需要不同的技术和方法来应对规模和复杂性的挑战。\n先了解到这里，毕竟这辈子不一定用得到","slug":"2023-05-12clickhouse","date":"2023-05-12T03:39:31.000Z","categories_index":"大数据","tags_index":"大数据","author_index":"举手摘月亮"},{"id":"2ba7b685164c0dbd4aedd1d197c6832b","title":"TypeORM 答疑","content":"背景这篇文章主要是答疑，不是参考文档，参考文档去官网查看，这里不做详细讨论\nTypeORM 是什么TypeORM 是一个用于 Node.js 和 JavaScript 的对象关系映射（ORM）库。它提供了一种将数据库中的数据映射到 JavaScript 对象的方式，使得在应用程序中使用数据库变得更加简单和方便。\nTypeORM 支持多种数据库系统，如 MySQL、PostgreSQL、SQLite、Microsoft SQL Server 等。它提供了许多功能，包括实体管理、数据查询、关系管理、事务支持等。TypeORM 使用装饰器语法来定义实体和其属性，使得实体类的定义更加直观和易于理解。\n通过 TypeORM，开发者可以使用面向对象的方式来处理数据库操作，而不需要直接编写 SQL 语句。它提供了强大的查询构建器和查询语言，可以轻松地执行复杂的数据库查询操作。\nTypeORM 还提供了数据库迁移工具，可以帮助开发者管理数据库模式的变化，并进行版本控制。这使得在开发过程中对数据库进行结构调整和更新变得更加容易。\n总之，TypeORM 是一个强大的 ORM 库，可以简化数据库操作，提高开发效率，并促进代码的可维护性。\n比较 TypeORM 和 SequelizeTypeORM 和 Sequelize 都是用于 Node.js 的 ORM 库，它们都提供了将数据库操作映射到 JavaScript 对象的能力。然而，它们在一些方面存在一些区别。\n\n语法和风格：\n\nTypeORM 使用装饰器语法来定义实体和属性，这使得代码更加直观和易于理解。\nSequelize 则使用 JavaScript 对象和函数来表示模型和查询操作，更接近传统的编程风格。\n\n\n数据库支持：\n\nTypeORM 支持多种数据库系统，包括 MySQL、PostgreSQL、SQLite、Microsoft SQL Server 等。\nSequelize 也支持多种数据库，包括 MySQL、PostgreSQL、SQLite、Microsoft SQL Server 等，但还支持 NoSQL 数据库 MongoDB。\n\n\n成熟度和社区支持：\n\nSequelize 是一个成熟的 ORM 库，已经存在较长时间，并且有着广泛的社区支持和活跃的维护者。\nTypeORM 相对较新，但也有不断增长的用户群和开发者社区。\n\n\n查询构建器：\n\nTypeORM 和 Sequelize 都提供了查询构建器，用于构建复杂的数据库查询。\nTypeORM 的查询构建器更加灵活和强大，可以支持更复杂的查询操作。\nSequelize 的查询构建器也很强大，但在某些情况下可能需要编写原生 SQL 语句来执行更高级的查询。\n\n\n数据迁移：\n\nTypeORM 和 Sequelize 都提供了数据库迁移工具，用于管理数据库模式的变化。\n它们都可以帮助开发者进行数据库结构的调整和更新。\n\n\n\n选择 TypeORM 还是 Sequelize 取决于具体的项目需求和个人偏好。如果需要多数据库支持、强大的查询构建器和装饰器语法，可以选择 TypeORM。如果需要对 NoSQL 数据库进行操作，或者更喜欢传统的 JavaScript 编程风格，可以选择 Sequelize。\n实体嵌入式实体 与 实体继承 的区别嵌入式实体（Embedded Entity）和实体继承（Entity Inheritance）是对象关系映射（ORM）中两种不同的建模技术。\n\n嵌入式实体：嵌入式实体是将一个实体对象嵌入到另一个实体对象中，作为其属性的一部分。这种关系表示了一个对象包含了另一个对象，就像一个整体。嵌入式实体通常用于表示具有紧密关联的对象，其中一个对象是另一个对象的组成部分。在数据库中，嵌入式实体的属性通常直接存储在包含它的实体的表中，而不是单独的表。\n\n例如，假设我们有一个”User”实体，它包含一个嵌入式实体”Address”。”Address”对象包含了用户的地址信息，包括街道、城市和邮政编码等。在数据库中，”User”表会包含”Address”的相关字段。\n\n实体继承：实体继承是面向对象编程中的概念，它允许一个实体从另一个实体继承属性和行为。这种关系表示了一种”是一个”的关系，子实体是父实体的特殊化。\n\n在 ORM 中，实体继承可以通过两种方式实现：单表继承（Single Table Inheritance）和类表继承（Class Table Inheritance）。\n\n单表继承将所有的实体类型存储在同一个表中，通过一个类型字段来区分不同的实体类型。\n类表继承则将每个实体类型存储在独立的表中，每个表都包含其自己的属性。\n\n例如，假设我们有一个基类实体”Animal”，它有两个子类实体”Cat”和”Dog”。在单表继承中，可以在一个表中存储所有的动物，使用一个类型字段来标识是猫还是狗。在类表继承中，可以为”Animal”、”Cat”和”Dog”分别创建三个独立的表。\n总结来说，\n\n嵌入式实体用于表示一个实体是另一个实体的组成部分，\n而实体继承用于表示一个实体是另一个实体的特殊化。选择使用哪种技术取决于具体的业务需求和数据模型的设计。\n\n注意：单表继承，在 gorm 表现为多态\n单表继承（数据库表结构，插入数据、查询数据）示例好的，以下是一个使用单表继承的完整示例，包括创建数据库表、使用 TypeORM 插入数据和查询数据的代码示例：\n\n数据库表结构：\n\nimport &#123; Entity, PrimaryGeneratedColumn, Column, TableInheritance &#125; from &#39;typeorm&#39;;\n\n@Entity()\n@TableInheritance(&#123; column: &#123; type: &#39;varchar&#39;, name: &#39;type&#39; &#125; &#125;)\nexport class Animal &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  color: string;\n&#125;\n\n@Entity()\nexport class Cat extends Animal &#123;\n  @Column()\n  breed: string;\n&#125;\n\n@Entity()\nexport class Dog extends Animal &#123;\n  @Column()\n  breed: string;\n&#125;\n\n\n插入数据：\n\nimport &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Cat, Dog &#125; from &#39;.&#x2F;models&#x2F;animal&#39;;\n\nasync function insertData() &#123;\n  const connection &#x3D; await createConnection();\n\n  const cat1 &#x3D; new Cat();\n  cat1.name &#x3D; &#39;Kitty&#39;;\n  cat1.color &#x3D; &#39;Gray&#39;;\n  cat1.breed &#x3D; &#39;Persian&#39;;\n  await connection.manager.save(cat1);\n\n  const dog1 &#x3D; new Dog();\n  dog1.name &#x3D; &#39;Buddy&#39;;\n  dog1.color &#x3D; &#39;Brown&#39;;\n  dog1.breed &#x3D; &#39;Labrador&#39;;\n  await connection.manager.save(dog1);\n\n  const cat2 &#x3D; new Cat();\n  cat2.name &#x3D; &#39;Whiskers&#39;;\n  cat2.color &#x3D; &#39;White&#39;;\n  cat2.breed &#x3D; &#39;Siamese&#39;;\n  await connection.manager.save(cat2);\n\n  await connection.close();\n&#125;\n\ninsertData().catch((error) &#x3D;&gt; console.log(error));\n\n\n查询数据：\n\nimport &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Animal, Cat, Dog &#125; from &#39;.&#x2F;models&#x2F;animal&#39;;\n\nasync function queryData() &#123;\n  const connection &#x3D; await createConnection();\n\n  &#x2F;&#x2F; 获取所有动物\n  const animals &#x3D; await connection.manager.find(Animal);\n  console.log(&#39;所有动物：&#39;, animals);\n\n  &#x2F;&#x2F; 获取所有猫\n  const cats &#x3D; await connection.manager.find(Cat);\n  console.log(&#39;所有猫：&#39;, cats);\n\n  &#x2F;&#x2F; 获取所有狗\n  const dogs &#x3D; await connection.manager.find(Dog);\n  console.log(&#39;所有狗：&#39;, dogs);\n\n  await connection.close();\n&#125;\n\nqueryData().catch((error) &#x3D;&gt; console.log(error));\n\n以上代码示例假设你已经正确安装了 TypeORM 和相关依赖，并且在你的项目中设置了数据库连接配置。你可以根据实际情况进行适当的调整和修改。\n查询结果根据前面的代码示例，查询数据的结果如下：\n获取所有动物：\n&#x2F;&#x2F; 查询结果\n[\n  &#123; id: 1, name: &#39;Kitty&#39;, color: &#39;Gray&#39;, breed: &#39;Persian&#39;, type: &#39;Cat&#39; &#125;,\n  &#123; id: 2, name: &#39;Buddy&#39;, color: &#39;Brown&#39;, breed: &#39;Labrador&#39;, type: &#39;Dog&#39; &#125;,\n  &#123; id: 3, name: &#39;Whiskers&#39;, color: &#39;White&#39;, breed: &#39;Siamese&#39;, type: &#39;Cat&#39; &#125;,\n];\n\n获取所有猫：\n&#x2F;&#x2F; 查询结果\n[\n  &#123; id: 1, name: &#39;Kitty&#39;, color: &#39;Gray&#39;, breed: &#39;Persian&#39;, type: &#39;Cat&#39; &#125;,\n  &#123; id: 3, name: &#39;Whiskers&#39;, color: &#39;White&#39;, breed: &#39;Siamese&#39;, type: &#39;Cat&#39; &#125;,\n];\n\n获取所有狗：\n&#x2F;&#x2F; 查询结果\n[&#123; id: 2, name: &#39;Buddy&#39;, color: &#39;Brown&#39;, breed: &#39;Labrador&#39;, type: &#39;Dog&#39; &#125;];\n\n以上结果展示了从数据库中查询到的动物数据。每个对象都包含了相应的属性，如 id、name、color、breed 和 type。根据查询条件不同，返回的结果集会根据类型进行筛选。\n请注意，这只是一个示例，实际的查询结果可能会根据你的具体数据和查询条件有所不同。\nTree EntitiesTree Entities（树实体）是一种用于表示层次结构数据的模型，常用于树状结构的数据存储和查询。TypeORM 提供了支持 Tree Entities 的功能，可以方便地操作和管理树形数据。\n在 TypeORM 中，可以使用@Tree装饰器和一些特定的列装饰器来定义树实体。\n下面是一个示例，展示了如何使用 TypeORM 创建和操作树实体：\n\n定义树实体类：\n\nimport &#123; Entity, PrimaryGeneratedColumn, Column, Tree, TreeParent, TreeChildren &#125; from &#39;typeorm&#39;;\n\n@Entity()\n@Tree(&#39;closure-table&#39;)\nexport class Category &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @TreeParent()\n  parent: Category;\n\n  @TreeChildren()\n  children: Category[];\n&#125;\n\n\n插入树实体数据：\n\nimport &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function insertData() &#123;\n  const connection &#x3D; await createConnection();\n\n  const root &#x3D; new Category();\n  root.name &#x3D; &#39;Root&#39;;\n\n  const child1 &#x3D; new Category();\n  child1.name &#x3D; &#39;Child 1&#39;;\n  child1.parent &#x3D; root;\n\n  const child2 &#x3D; new Category();\n  child2.name &#x3D; &#39;Child 2&#39;;\n  child2.parent &#x3D; root;\n\n  const grandchild1 &#x3D; new Category();\n  grandchild1.name &#x3D; &#39;Grandchild 1&#39;;\n  grandchild1.parent &#x3D; child1;\n\n  await connection.manager.save([root, child1, child2, grandchild1]);\n\n  await connection.close();\n&#125;\n\ninsertData().catch((error) &#x3D;&gt; console.log(error));\n\n\n查询树实体数据：\n\nimport &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function queryData() &#123;\n  const connection &#x3D; await createConnection();\n\n  &#x2F;&#x2F; 获取所有根级别的类别\n  const rootCategories &#x3D; await connection.manager.find(Category, &#123; parent: null &#125;);\n  console.log(&#39;根级别的类别：&#39;, rootCategories);\n\n  &#x2F;&#x2F; 获取指定类别的所有子类别\n  const category &#x3D; await connection.manager.findOne(Category, &#123; where: &#123; name: &#39;Child 1&#39; &#125; &#125;);\n  const children &#x3D; await connection.manager.find(Category, &#123; parent: category &#125;);\n  console.log(&#39;Child 1的子类别：&#39;, children);\n\n  await connection.close();\n&#125;\n\nqueryData().catch((error) &#x3D;&gt; console.log(error));\n\n上述代码示例定义了一个Category树实体类，其中包含了 id、name、parent 和 children 等属性。通过设置装饰器，我们定义了树结构的关系。\n通过插入数据和查询数据的代码，我们可以创建和操作树形结构的数据。通过根级别和父子关系，我们可以轻松地构建和查询树形数据的层次结构。\n请注意，以上示例只是一个简单的演示，实际使用中可能需要根据具体的业务需求和数据模型进行适当的调整和修改。\n@Tree(“closure-table”) 是什么，有什么用@Tree(&quot;closure-table&quot;) 是 TypeORM 中的一个装饰器，用于定义树实体的层次关系存储策略之一，即闭包表（Closure Table）。\n闭包表是一种用于存储和查询树形结构数据的技术。它通过在数据库中创建一个额外的表来表示树中的层次关系，这个表通常称为闭包表。闭包表记录了树中每个节点与其祖先节点之间的关系。\n在 TypeORM 中，@Tree(&quot;closure-table&quot;) 装饰器的作用是告诉 TypeORM 使用闭包表策略来存储树实体的层次关系。\n闭包表策略的优点是灵活性和查询性能。它允许对树进行高效的插入、更新和删除操作，并且可以使用递归查询来查询树中的节点及其子节点。闭包表还可以处理树的复杂结构和多层级关系。\n使用 @Tree(&quot;closure-table&quot;) 装饰器后，TypeORM 会自动生成一个闭包表，并在其中存储树实体的层次关系。\n注意，TypeORM 还提供其他存储策略，如嵌套集合（Nested Set）和路径枚举（Path Enumeration），每种策略都有其特定的用途和性能特点。选择适当的存储策略取决于你的数据模型和具体的查询需求。\n上述代码对应的数据库表结构基于前面提供的代码示例，使用 @Tree(&quot;closure-table&quot;) 装饰器来定义树实体的存储策略为闭包表。对应的数据库表结构如下：\n\nCategory 表：\n\n\n\n\nid\nname\n\n\n\n1\nRoot\n\n\n2\nChild 1\n\n\n3\nChild 2\n\n\n4\nGrandchild 1\n\n\n\nCategoryClosure 表：\n\n\n\n\nancestor\ndescendant\ndepth\n\n\n\n1\n1\n0\n\n\n2\n2\n0\n\n\n3\n3\n0\n\n\n4\n4\n0\n\n\n1\n2\n1\n\n\n1\n3\n1\n\n\n2\n4\n1\n\n\n1\n4\n2\n\n\nCategoryClosure 表用于记录树中每个节点与其祖先节点之间的关系。每一行表示一个祖先与后代之间的关系，包括祖先节点的 ID、后代节点的 ID 以及它们之间的层次深度。\n通过 Category 表和 CategoryClosure 表的组合，可以表示树形结构中的层次关系。\n请注意，上述表结构仅为了说明闭包表存储策略的概念，实际的数据库表结构可能会有一些差异，具体取决于数据库的特定实现和 TypeORM 的配置。\n如果用原生 mysql 如何写查询语句如果你使用原生 MySQL，以下是一些示例查询语句，用于检索树形结构数据（基于之前提供的树实体示例）：\n\n获取所有根级别的类别：\n\nSELECT * FROM Category WHERE parent IS NULL;\n\n\n获取指定类别的所有子类别：\n\nSELECT c.* FROM Category c\nJOIN CategoryClosure cc ON c.id &#x3D; cc.descendant\nJOIN Category pc ON pc.id &#x3D; cc.ancestor\nWHERE pc.name &#x3D; &#39;Child 1&#39;;\n\n\n获取指定类别的所有祖先类别：\n\nSELECT pc.* FROM Category c\nJOIN CategoryClosure cc ON c.id &#x3D; cc.ancestor\nJOIN Category pc ON pc.id &#x3D; cc.descendant\nWHERE c.name &#x3D; &#39;Grandchild 1&#39;;\n\n以上查询语句用于从数据库中检索树形结构的数据。根据具体的业务需求和数据模型，你可能需要根据实际情况进行调整和修改。\n请注意，以上查询语句是基于前面提供的树实体示例和假设的数据库表结构。如果你的数据模型和表结构不同，你需要相应地调整查询语句以适应你的实际情况。\n\n查询完整树的 sql\n\n要查询完整的树形结构，可以使用递归查询（Recursive Query）来检索所有的节点和它们的层次关系。在 MySQL 中，可以使用通用表表达式（CTE）和递归查询来实现。\n以下是一个示例的递归查询语句，用于检索完整的树形结构：\nWITH RECURSIVE Tree AS (\n  SELECT\n    id,\n    name,\n    parent,\n    0 AS level\n  FROM Category\n  WHERE parent IS NULL\n\n  UNION ALL\n\n  SELECT\n    c.id,\n    c.name,\n    c.parent,\n    t.level + 1\n  FROM Category c\n  JOIN Tree t ON t.id &#x3D; c.parent\n)\nSELECT * FROM Tree;\n\n上述查询语句使用了递归的方式，通过不断连接树的父节点和子节点，来逐级检索树中的节点。查询结果包含了每个节点的 ID、名称、父节点和层级（level）信息。\n请注意，以上查询语句是基于假设的树形数据模型和表结构。你需要根据实际的数据模型和表结构进行适当的调整和修改。\nfindTrees在 TypeORM 中，findTrees 是用于查询树形结构数据的一个特殊方法，它可以直接返回完整的树形结构，而不需要手动编写递归查询语句。\n使用 findTrees 方法，你可以轻松地检索整个树形结构，包括节点及其子节点的层次关系。该方法会自动处理递归查询，并将结果以树形结构的形式返回。\n以下是示例代码，演示如何使用 findTrees 方法查询树形结构数据：\nimport &#123; createConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function queryData() &#123;\n  const connection &#x3D; await createConnection();\n\n  const tree &#x3D; await connection.getRepository(Category).findTrees();\n  console.log(&#39;完整树形结构：&#39;, tree);\n\n  await connection.close();\n&#125;\n\nqueryData().catch((error) &#x3D;&gt; console.log(error));\n\n使用 findTrees 方法，它将自动执行递归查询，检索整个树形结构，并返回一个包含完整树的结果数组。每个节点对象将包含其子节点的数组，从而形成树形结构。\n需要注意的是，使用 findTrees 方法前提是你的实体类已正确定义了树形结构的关系装饰器，如 @TreeParent() 和 @TreeChildren()。\n因此，相比手动编写递归查询语句，使用 findTrees 方法可以更为方便和简洁地获取完整的树形结构数据。\n@Tree(“materialized-path”)【公司用的这种，这种做组织树懒加载挺好的】当使用 @Tree(&quot;materialized-path&quot;) 装饰器时，TypeORM 将使用”Materialized Path”（材料化路径）作为树形结构的存储策略。在”Materialized Path”模型中，每个节点都包含一个路径，该路径表示该节点与其祖先节点之间的关系。\n对于使用 @Tree(&quot;materialized-path&quot;) 的树形实体，以下是一个示例的数据库表结构，用于存储树形结构数据：\nCREATE TABLE Category (\n  id INT PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  path VARCHAR(255) NOT NULL\n);\n\n在上述表结构中，Category 表包含三个列：\n\nid：节点的唯一标识符。\nname：节点的名称。\npath：节点的材料化路径，表示该节点与其祖先节点之间的关系。\n\n例如，一个示例的 Category 表数据如下：\n\n\n\nid\nname\npath\n\n\n\n1\nRoot\n&#x2F;\n\n\n2\nChild 1\n&#x2F;1&#x2F;\n\n\n3\nChild 2\n&#x2F;1&#x2F;\n\n\n4\nGrandchild 1\n&#x2F;1&#x2F;2&#x2F;\n\n\n在这个示例中，根节点的路径为 /，Child 1 和 Child 2 节点的路径为 /1/，Grandchild 1 节点的路径为 /1/2/。通过这种路径表示方式，可以明确节点与其祖先节点之间的层次关系。\n请注意，上述的数据库表结构仅为示例，实际的表结构可能会根据具体的数据模型和 TypeORM 的配置而有所不同。材料化路径模型的具体实现可能还涉及其他列或索引，以支持更高效的查询操作。\n完整示例以下是一个使用 @Tree(&quot;materialized-path&quot;) 装饰器的完整示例：\nimport &#123; Entity, PrimaryGeneratedColumn, Column, Tree, TreeParent, TreeChildren &#125; from &#39;typeorm&#39;;\n\n@Entity()\n@Tree(&#39;materialized-path&#39;)\nexport class Category &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  path: string;\n\n  @TreeParent()\n  parent: Category;\n\n  @TreeChildren()\n  children: Category[];\n&#125;\n\n在这个示例中，Category 实体类使用了 @Tree(&quot;materialized-path&quot;) 装饰器，指定了树形结构的存储策略为材料化路径。\n实体类中定义了以下属性：\n\nid：节点的唯一标识符，使用 PrimaryGeneratedColumn 装饰器标记为自动生成。\nname：节点的名称，使用 Column 装饰器标记为数据库表的列。\npath：节点的材料化路径，使用 Column 装饰器标记为数据库表的列。\nparent：父节点，使用 TreeParent 装饰器标记为父节点关系。\nchildren：子节点数组，使用 TreeChildren 装饰器标记为子节点关系。\n\n使用上述实体类定义后，TypeORM 将根据装饰器的配置自动生成对应的数据库表结构，包括主键、列和索引。在本例中，使用材料化路径作为树形结构的存储策略，并通过 path 列来表示节点与其祖先节点之间的关系。\n请注意，上述示例仅展示了如何使用 @Tree(&quot;materialized-path&quot;) 装饰器来定义树形实体类，并不包含具体的查询或操作代码。你可以根据需要使用 TypeORM 提供的各种查询方法来检索和操作树形结构的数据。\nmaterialized-path 增删改查使用 “Materialized Path”（材料化路径）作为树形结构的存储策略时，你可以使用 TypeORM 提供的各种查询和操作方法来进行增删改查操作。下面是一些示例代码，展示了如何使用 TypeORM 来执行这些操作：\n创建节点：\nimport &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function createCategory(name: string, path: string, parentId: number | null) &#123;\n  const category &#x3D; new Category();\n  category.name &#x3D; name;\n  category.path &#x3D; path;\n\n  if (parentId) &#123;\n    const parentCategory &#x3D; await getConnection().getRepository(Category).findOne(parentId);\n    category.parent &#x3D; parentCategory;\n  &#125;\n\n  await getConnection().getRepository(Category).save(category);\n&#125;\n\n删除节点：\nimport &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function deleteCategory(id: number) &#123;\n  const categoryRepository &#x3D; getConnection().getRepository(Category);\n  const category &#x3D; await categoryRepository.findOne(id);\n\n  if (category) &#123;\n    await categoryRepository.remove(category);\n  &#125;\n&#125;\n\n更新节点：\nimport &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function updateCategory(id: number, name: string, path: string, parentId: number | null) &#123;\n  const categoryRepository &#x3D; getConnection().getRepository(Category);\n  const category &#x3D; await categoryRepository.findOne(id);\n\n  if (category) &#123;\n    category.name &#x3D; name;\n    category.path &#x3D; path;\n\n    if (parentId) &#123;\n      const parentCategory &#x3D; await categoryRepository.findOne(parentId);\n      category.parent &#x3D; parentCategory;\n    &#125; else &#123;\n      category.parent &#x3D; null;\n    &#125;\n\n    await categoryRepository.save(category);\n  &#125;\n&#125;\n\n查询节点：\nimport &#123; getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; Category &#125; from &#39;.&#x2F;models&#x2F;category&#39;;\n\nasync function getCategory(id: number) &#123;\n  const category &#x3D; await getConnection()\n    .getRepository(Category)\n    .findOne(id, &#123; relations: [&#39;children&#39;] &#125;);\n  console.log(category);\n&#125;\n\n在上述示例中，我们假设已经建立了名为 Category 的实体类，并且已经创建了与数据库的连接。\n使用这些示例代码，你可以执行相应的操作来增加、删除、更新和查询材料化路径模型的树形结构数据。需要注意的是，具体的操作方法和查询语句可能会根据你的数据模型和需求有所调整，这里提供的示例代码只是基于给出的实体类进行演示。你可以根据自己的实际情况进行适当的修改和调整。\n比较 Materialized Path 与 Closure table比较在数据库中存储树形结构数据有多种方式，常见的有 Closure Table 和 Materialized Path 两种。下面对这两种方式进行比较。\n\n存储结构\n\nClosure Table 使用一张表来存储所有节点之间的关系，每个节点与其祖先节点的关系都被记录下来。Closure Table 表结构相对简单，但随着树的深度增加，表中的数据量也会随之增加。\nMaterialized Path 则使用一个字符串字段来存储每个节点的路径信息。每个节点的路径信息包含该节点的祖先节点 ID，以及该节点自身的 ID，以某种特定的分隔符来分隔不同的节点 ID。Materialized Path 的存储方式相对简洁，但是查询和更新操作会涉及到字符串的解析和拼接。\n\n查询效率\n\nClosure Table 的查询效率相对较低，因为需要进行多次 JOIN 操作，特别是在查询节点的所有子孙节点时，性能较差。\nMaterialized Path 的查询效率相对较高，因为只需要进行基于字符串的 LIKE 匹配操作即可，而且查询所有子孙节点时只需要查询特定的路径即可。\n\n更新效率\n\nClosure Table 的更新效率相对较高，因为只需要更新与某个节点相关的部分数据，而不需要更新整个路径。\nMaterialized Path 的更新效率相对较低，因为每次更新都需要对包含该节点的所有路径进行更新。\n\n数据库复杂度\n\nClosure Table 的表结构比较简单，但需要维护大量冗余的关系数据，因此数据库的复杂度较高。\nMaterialized Path 的表结构相对简单，但需要使用字符串拼接和解析等复杂操作，因此数据库的复杂度也相对较高。\n总结\n\nClosure Table 适用于深度较浅的树形结构，或者需要频繁查询节点的祖先和子孙节点的情况。\nMaterialized Path 适用于深度较深的树形结构，或者需要频繁查询节点的路径信息的情况。\n选择哪种方式取决于具体的业务需求和数据特点。\n\n不懂让我再给你一些更简单的解释：\nClosure Table（闭包表）和 Materialized Path（材料化路径）是两种用于存储树形结构数据的方法。\nClosure Table 使用一个单独的表来存储节点之间的关系。该表记录了每个节点与其祖先节点的关系，包括所有的父节点和子节点。这种方式的表结构比较简单，但在查询和更新数据时可能需要进行多次的连接操作，导致性能较低。\nMaterialized Path 使用一个字符串字段来存储每个节点的路径信息。节点的路径信息包括该节点的祖先节点的标识和节点本身的标识，使用特定的分隔符进行分隔。这种方式的表结构相对简洁，查询数据时只需基于字符串匹配即可，性能较高。\n两种方式各有优劣。\n\nClosure Table 适合较浅的树形结构和需要频繁查询节点的祖先和子孙节点的情况。\nMaterialized Path 适合较深的树形结构和需要频繁查询节点路径信息的情况。\n\n具体选择哪种方式取决于你的业务需求和数据特点。如果你还有其他问题，我会很乐意为你解答。\n邻接表（Adjacency List）【可跳过】邻接表（Adjacency List）是一种用于表示树形结构的数据模型。在邻接表中，每个节点都包含一个指向其子节点的列表或指针。这种表示方法通过使用父节点到子节点的引用关系来描述树的结构。\n在邻接表中，每个节点通常包含以下信息：\n\n节点标识符（ID）：用于唯一标识节点的值。\n节点数据：节点所包含的实际数据。\n父节点引用：指向父节点的指针或引用。\n子节点列表：包含指向子节点的指针或引用的列表。\n\n使用邻接表表示树形结构时，可以轻松地遍历树的层次结构，查找节点的父节点、子节点以及兄弟节点。由于每个节点仅存储了与其直接相关的信息，因此在空间上相对节省。但是，当需要进行深度遍历或搜索整个树时，可能需要进行多次查询或递归操作，影响性能。\n下面是一个使用邻接表表示树形结构的示例：\nclass TreeNode &#123;\n  id: number;\n  data: string;\n  parent: TreeNode | null;\n  children: TreeNode[];\n\n  constructor(id: number, data: string, parent: TreeNode | null &#x3D; null) &#123;\n    this.id &#x3D; id;\n    this.data &#x3D; data;\n    this.parent &#x3D; parent;\n    this.children &#x3D; [];\n  &#125;\n\n  addChild(child: TreeNode) &#123;\n    this.children.push(child);\n    child.parent &#x3D; this;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建一个树形结构\nconst root &#x3D; new TreeNode(1, &#39;Root&#39;);\n\nconst child1 &#x3D; new TreeNode(2, &#39;Child 1&#39;);\nconst child2 &#x3D; new TreeNode(3, &#39;Child 2&#39;);\nconst child3 &#x3D; new TreeNode(4, &#39;Child 3&#39;);\n\nconst grandchild1 &#x3D; new TreeNode(5, &#39;Grandchild 1&#39;);\nconst grandchild2 &#x3D; new TreeNode(6, &#39;Grandchild 2&#39;);\n\nroot.addChild(child1);\nroot.addChild(child2);\nroot.addChild(child3);\n\nchild1.addChild(grandchild1);\nchild1.addChild(grandchild2);\n\n&#x2F;&#x2F; 遍历树形结构\nfunction traverseTree(node: TreeNode, depth: number &#x3D; 0) &#123;\n  const indent &#x3D; &#39;  &#39;.repeat(depth);\n  console.log(indent + node.data);\n\n  for (const child of node.children) &#123;\n    traverseTree(child, depth + 1);\n  &#125;\n&#125;\n\ntraverseTree(root);\n\n上述示例中的 TreeNode 类表示树形结构中的节点，通过 parent 和 children 属性建立父子关系。我们可以使用 addChild 方法来添加子节点，并使用 traverseTree 函数遍历整个树形结构。\n邻接表是一种常见的树形结构表示方法，它简单明了并且易于理解。但是对于大型树形结构和深度遍历操作，可能会面临性能挑战。在这种情况下，其他存储模型如 Closure Table、Materialized Path 或 Nested Set Model\nview-entities 做什么用，什么场景会用到View Entities 是 TypeORM 中的一个功能，用于创建虚拟实体类，映射到数据库中的视图。它们是基于数据库视图的概念，可以将多个表或查询的结果视为单个实体，方便进行查询和操作。\n使用 View Entities 可以解决以下场景：\n\n简化复杂查询：当需要执行多个表之间的联接查询、聚合操作或其他复杂查询时，可以创建一个 View Entity，将多个表或查询结果组合成一个虚拟的实体类。这样，你可以像操作普通实体一样对其进行查询，而不需要手动编写复杂的 SQL 查询。\n\n提供抽象视图层：有时候，你希望将数据库中的多个表或查询结果视为单个实体，以便在业务逻辑中使用。通过创建 View Entity，你可以将这些表或查询结果封装为一个高层次的抽象视图，从而简化代码逻辑。\n\n数据报表和分析：如果需要在数据库中创建视图以供报表或分析使用，View Entities 是一个很好的选择。你可以定义一个 View Entity，将相关表或查询结果映射到该实体中，然后使用 TypeORM 提供的查询功能来检索和处理报表数据。\n\n\n需要注意的是，由于 View Entities 是基于数据库视图创建的，它们通常是只读的。这意味着你不能通过 View Entity 对数据库进行插入、更新或删除操作。但你仍然可以使用它们执行查询操作，获取数据的实时快照或数据报表。\n总结来说，View Entities 是 TypeORM 提供的一个功能，用于创建虚拟实体类，映射到数据库中的视图。它们在简化复杂查询、提供抽象视图层以及数据报表和分析等场景下非常有用。\n数据库视图 的作用【新医和阿里，病例质检项目 给第三方提供数据库视图】数据库视图（Database View）是数据库中一个虚拟的表，它是基于一个或多个数据库表或查询的结果集创建的。视图并不实际存储数据，而是通过查询和计算从基本表中获取数据并将其呈现给用户。\n数据库视图的作用包括：\n\n数据抽象和安全性：视图可以提供数据的抽象层，隐藏了底层表的细节和复杂性。通过视图，可以将底层表的特定列或行筛选出来，只暴露给用户需要的数据。这样，用户无需直接访问底层表，而是通过视图来获取数据，提高了数据的安全性和隐私性。\n\n简化复杂查询：数据库视图可以将多个表的关联和联接操作抽象为一个视图，使复杂的查询变得简单。通过在视图上执行查询操作，可以避免编写复杂的 SQL 语句和多表联接操作，提高了查询的可读性和易用性。\n\n数据一致性和逻辑完整性：通过视图，可以定义计算列、虚拟列和数据转换规则，从而保持数据的一致性和逻辑完整性。视图可以对数据进行格式化、计算和转换，使得数据呈现更加准确和符合业务规则。\n\n简化应用程序开发：通过在数据库中创建视图，可以为应用程序提供简化的数据访问接口。应用程序可以直接使用视图来进行数据查询，而无需了解和处理底层表的复杂性。这简化了应用程序的开发过程，并提高了开发效率。\n\n性能优化：在某些情况下，数据库视图可以提高查询性能。通过预先定义并优化视图，数据库可以在查询执行时使用视图的缓存结果，减少了重复计算和查询的开销，提高了查询的性能。\n\n\n总的来说，数据库视图提供了数据的抽象层、简化复杂查询、数据一致性和逻辑完整性、简化应用程序开发以及性能优化等作用。通过合理使用数据库视图，可以提高数据访问的灵活性、安全性和效率，减少开发工作量，并改善数据库的性能。\n.manager 和.getRepository()简单来说Repository 与 manager 相似，增删改查更具体，会具体到传入的实体\n是什么.manager 和 .getRepository() 都是 TypeORM 中用于执行数据库操作的方法，但它们有一些不同的使用场景和用途。\n\n.manager：\n\n.manager 是 TypeORM 中的一个属性，用于获取当前数据库连接的管理器（EntityManager）。管理器是 TypeORM 中的一个核心对象，用于执行数据库操作，包括插入、更新、删除和查询等。\n通过 .manager 可以直接执行数据库操作，例如使用 .save() 方法保存实体、使用 .remove() 方法删除实体、使用 .query() 方法执行原生 SQL 查询等。\n管理器提供了更灵活的操作方式，可以进行高级的数据库操作和事务管理。\n\n\n.getRepository()：\n\n.getRepository() 是 TypeORM 中的一个方法，用于获取特定实体类（Entity）的存储库（Repository）。\n存储库是 TypeORM 中的一个概念，它提供了对实体类的常见数据库操作的封装，如插入、更新、删除和查询等。通过存储库，可以方便地执行与实体类相关的操作，而无需编写复杂的 SQL 查询。\n.getRepository() 方法接受实体类作为参数，并返回该实体类对应的存储库实例。然后可以使用存储库提供的方法进行数据库操作，如 .save()、.remove()、.findOne()、.find() 等。\n\n\n\n一般来说，使用 .manager 更适合需要执行高级数据库操作或需要自定义的复杂查询的场景。而使用 .getRepository() 更适合进行常规的实体操作，如插入、更新、删除和查询等。\n以下是两者的示例用法：\n使用 .manager 执行数据库操作的示例：\nimport &#123; getManager &#125; from &#39;typeorm&#39;;\n\nconst entityManager &#x3D; getManager();\nconst user &#x3D; new User();\nuser.name &#x3D; &#39;John Doe&#39;;\n\nawait entityManager.save(user);\nawait entityManager.remove(user);\nconst result &#x3D; await entityManager.query(&#39;SELECT * FROM users&#39;);\n\n使用 .getRepository() 执行数据库操作的示例：\nimport &#123; getRepository &#125; from &#39;typeorm&#39;;\n\nconst userRepository &#x3D; getRepository(User);\nconst user &#x3D; new User();\nuser.name &#x3D; &#39;John Doe&#39;;\n\nawait userRepository.save(user);\nawait userRepository.remove(user);\nconst result &#x3D; await userRepository.findOne(&#123; id: 1 &#125;);\n\n根据具体的需求和场景，可以选择使用 .manager 或 .getRepository() 进行适当的数据库操作。\n查询相关的配置 （Find Options） 详细文档typeorm Find Options 简单配置有哪些？在 TypeORM 中，常用的基本查询配置选项包括：\n\nwhere: 指定查询的条件表达式，可以使用实体属性、操作符和值进行比较。\n\nrelations: 指定要同时加载的关联实体。\n\norder: 指定查询结果的排序顺序。\n\nskip 和 take: 用于分页查询，指定要跳过的记录数量和要返回的记录数量。\n\nselect: 指定要返回的实体属性。\n\njoin: 指定要执行的关联查询。\n\ngroup: 指定查询结果的分组条件。\n\ncache: 指定查询是否应该使用缓存。\n\n\n这些基本配置选项可以根据具体的需求进行组合和定制，用于在查询实体时指定特定的条件、排序、关联加载、分页等操作。\n以下是一个基本的示例，展示了如何使用这些基本配置选项：\nimport &#123; getRepository &#125; from &#39;typeorm&#39;;\n\nconst userRepository &#x3D; getRepository(User);\n\nconst options &#x3D; &#123;\n  where: &#123;\n    age: 25,\n    isActive: true,\n  &#125;,\n  relations: [&#39;posts&#39;],\n  order: &#123;\n    createdDate: &#39;DESC&#39;,\n  &#125;,\n  skip: 0,\n  take: 10,\n  select: [&#39;id&#39;, &#39;name&#39;],\n  join: &#123;\n    alias: &#39;user&#39;,\n    innerJoin: &#123;\n      &#39;user.posts&#39;: &#39;post&#39;,\n    &#125;,\n  &#125;,\n  group: [&#39;category&#39;],\n  cache: true,\n&#125;;\n\nconst users &#x3D; await userRepository.find(options);\n\n根据具体的业务需求，你可以选择适当的查询选项来定制查询行为。以上列出的基本配置选项提供了一些常见的用法示例，但并不限于此，你可以根据具体情况进行进一步的定制和组合。\n高级配置可以将 typeorm 的高级配置进一步简化为以下几个方面：\n\n比较符号：用于定义在查询中使用的比较符号，例如等于、大于等。比如 Equal, MoreThan, LessThanOrEqual 等。\n\n逻辑符号：用于定义查询中的逻辑操作符，例如 AND、OR 等。比如 And, Or, Not 等。\n\n关联关系：用于在查询中包含实体之间的关联关系，例如通过外键关联的两个实体之间的关系等。比如 Join, LeftJoinAndSelect 等。\n\n其他：还有其他的高级配置，例如排序、分组、选取指定字段等。比如 OrderBy, Select 等。\n\n\n高级配置示例\nNot：用于指定查询条件的否定，即排除满足特定条件的实体。例如：\n\nimport &#123; Not &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询不满足条件的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; age: Not(25) &#125; &#125;);\n\n\nIn：用于指定一个属性值必须在给定的值数组中的查询条件。例如：\n\nimport &#123; In &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询满足条件的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; role: In([&#39;admin&#39;, &#39;manager&#39;]) &#125; &#125;);\n\n\nLike：用于在查询条件中模糊匹配字符串。例如：\n\nimport &#123; Like &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询名称以 &quot;John&quot; 开头的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; name: Like(&#39;John%&#39;) &#125; &#125;);\n\n\nBetween：用于指定一个属性值在指定的范围内的查询条件。例如：\n\nimport &#123; Between &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询年龄在 18 到 30 之间的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; age: Between(18, 30) &#125; &#125;);\n\n\nIsNull 和 IsNotNull：用于查询属性值是否为 null 或非 null。例如：\n\nimport &#123; IsNull, IsNotNull &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 查询名字为空的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; name: IsNull() &#125; &#125;);\n\n&#x2F;&#x2F; 查询名字不为空的实体\nconst users &#x3D; await userRepository.find(&#123; where: &#123; name: IsNotNull() &#125; &#125;);\n\n这些高级查询选项提供了更灵活和强大的查询能力，可以根据具体的业务需求来使用。请参考 TypeORM 的文档以获取更多关于高级查询选项的详细信息和示例。\n使用 typeorm 提供的相关 APIadvanced-options\n关联关系实体管理器 manager实体管理器 manager 上有这一系列 API 用于数据库的增删改查\n有哪些 API因为 chatGPT 给的不全，typeof 文档上也能看到，但是这里直接找源码查看\nsrc&#x2F;data-source&#x2F;DataSource.ts\n\n通过官方文档可知，manager 从 DataSource类的实例上获取，也就是 manager 是 DataSource类 的属性\n从上述连接源码可知： this.manager = this.createEntityManager()\n所以要查看 manager 有哪些 API, 只需要看 DataSource 类的 createEntityManager方法的返回值类型\n\nsrc&#x2F;entity-manager&#x2F;EntityManager.ts\n源码从 173 行开始就是想关 API 了\n\n\n图中出现多个重复的情况，可以理解为“多态”吧，参数不同，自动调用不同的方法\nmanager.incrementawait manager.increment(User, &#123; firstName: &quot;Timber&quot; &#125;, &quot;age&quot;, 3) 是 TypeORM 中用于增加实体的指定属性值的方法。\n这个方法的作用是在指定的实体中增加特定属性的值。它接受以下参数：\n\n第一个参数是实体的类名或实体对象。在这个例子中，传入的是 User 类型或者 User 实体对象。\n\n第二个参数是一个条件对象，用于确定要增加属性值的实体。在这个例子中，传入的是 &#123; firstName: &quot;Timber&quot; &#125;，表示要增加 firstName 为 “Timber” 的实体的属性值。\n\n第三个参数是要增加的属性的名称。在这个例子中，传入的是 &quot;age&quot;，表示要增加实体的 age 属性值。\n\n第四个参数是要增加的值的数量。在这个例子中，传入的是 3，表示要将 age 属性的值增加 3。\n\n\n示例中的代码表示在满足条件 &#123; firstName: &quot;Timber&quot; &#125; 的 User 实体中，将 age 属性的值增加 3。\n请注意，该方法会直接更新数据库中的对应实体的属性值，并返回一个 Promise 对象。可以使用 await 关键字等待操作完成。\nmanager.increment 返回所有更新的 id 吗？manager.increment() 方法在增加属性值时，并不会返回更新的实体的 ID。它仅仅是更新了数据库中对应实体的属性值，而不会返回任何实体或 ID。\n如果您需要获取更新后的实体或 ID，可以使用 manager.findOne() 或 manager.find() 方法来执行查询操作，以获取更新后的实体的信息。\n例如，您可以在执行 manager.increment() 后立即执行一个查询，以获取更新后的实体的 ID，如下所示：\nconst incrementedUser &#x3D; await manager.increment(User, &#123; firstName: &#39;Timber&#39; &#125;, &#39;age&#39;, 3);\nconst updatedUser &#x3D; await manager.findOne(User, &#123; firstName: &#39;Timber&#39; &#125;);\n\n&#x2F;&#x2F; 获取更新后的实体的 ID\nconst updatedUserId &#x3D; updatedUser.id;\n\n在上面的示例中，我们执行了 manager.increment() 来增加 firstName 为 “Timber” 的 User 实体的 age 属性值。然后，我们使用 manager.findOne() 查询更新后的实体，并获取其 ID。\n请注意，执行查询操作后，您将获得更新后的实体的完整信息，包括 ID 和其他属性。\nmanager.countconst count &#x3D; await manager.count(User, &#123;\n  where: &#123;\n    firstName: &#39;Timber&#39;,\n  &#125;,\n&#125;);\n\nconst count = await manager.count(User, &#123; where: &#123; firstName: &quot;Timber&quot; &#125; &#125;) 是 TypeORM 中用于计算满足指定条件的实体数量的方法。\n这个方法的作用是计算数据库中满足特定条件的实体的数量。它接受以下参数：\n\n第一个参数是实体的类名或实体对象。在这个例子中，传入的是 User 类型或者 User 实体对象。\n\n第二个参数是一个条件对象，用于确定要计算数量的实体。在这个例子中，传入的是 &#123; where: &#123; firstName: &quot;Timber&quot; &#125; &#125;，表示要计算 firstName 为 “Timber” 的实体的数量。\n\n\n示例中的代码表示计算数据库中 User 实体中 firstName 为 “Timber” 的实体数量，并将结果赋值给 count 变量。\n这个方法返回一个 Promise，解析为满足条件的实体的数量。您可以使用 await 关键字等待结果的解析。\nmanager.countByconst count &#x3D; await manager.countBy(User, &#123; firstName: &#39;Timber&#39; &#125;);\n\n在 TypeORM 中，没有名为 countBy() 的方法。但是，您可以使用 count() 方法和适当的查询条件来实现类似的功能。\n以下是使用 count() 方法计算满足指定条件的实体数量的示例：\nconst count &#x3D; await manager.count(User, &#123; where: &#123; firstName: &#39;Timber&#39; &#125; &#125;);\n\n上述代码使用 count() 方法来计算满足条件 &#123; firstName: &quot;Timber&quot; &#125; 的 User 实体的数量，并将结果赋值给变量 count。\n请注意，count() 方法返回一个 Promise，解析为满足条件的实体的数量。您可以使用 await 关键字等待结果的解析。\nmanager.count vs manager.countBymanager.*Byapi 是对 manager.*的简化，能省掉 where\nQuery Builder哈～， 建造者模式\nQuery Builder\nquery builder 属于建造者模式是的，TypeORM 中的 Query Builder 属于建造者模式（Builder Pattern）的一种实现。\n建造者模式是一种创建对象的设计模式，它将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。在 TypeORM 中，Query Builder 提供了一种流畅且可组合的方式来构建复杂的查询，同时允许以多种形式表示查询条件、关联关系、排序等。\n使用 Query Builder，您可以逐步构建查询，通过链式调用方法来添加各种查询条件和操作。它提供了一系列方法，例如 select()、where()、leftJoinAndSelect()、orderBy() 等，可以根据需要按照特定的顺序和逻辑组合这些方法，构建出复杂的查询语句。\nQuery Builder 的优势在于它提供了更灵活和可读性更好的方式来构建查询，同时还可以根据需要动态地添加、修改或删除查询条件，使得查询的构建过程更加可控和可扩展。\n需要注意的是，Query Builder 并不是强制性使用的，您也可以直接使用原生的 SQL 查询或者使用 Repository 提供的方法来执行查询操作。Query Builder 更适用于需要动态构建查询的场景或者复杂的查询需求。\n三种方式创建 QueryBuilder使用数据源 创建和使用 QueryBuilder在 TypeORM 中，您可以使用数据源（Connection）来创建和使用 QueryBuilder。以下是使用数据源创建和使用 QueryBuilder 的示例：\n\n创建 QueryBuilder 实例：\nconst connection &#x3D; await createConnection(&#123;\n  type: &#39;mysql&#39;,\n  host: &#39;localhost&#39;,\n  port: 3306,\n  username: &#39;username&#39;,\n  password: &#39;password&#39;,\n  database: &#39;database&#39;,\n&#125;);\n\nconst queryBuilder &#x3D; connection.createQueryBuilder();\n\n使用 QueryBuilder 进行查询操作：\nconst queryBuilder &#x3D; connection.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();\n\n在上述示例中，我们首先创建了一个数据源（Connection），然后使用 createQueryBuilder() 方法创建了一个 QueryBuilder 实例。接下来，我们可以使用 QueryBuilder 进行查询操作，例如选择字段、设置表名、设置查询条件等。最后，我们通过调用适当的方法（如 getMany()）来执行查询并获取结果。\n请注意，具体的数据库连接配置参数（如 type、host、port、username、password、database 等）需要根据您的实际数据库配置进行调整。\n使用数据源创建和使用 QueryBuilder 的方式与使用实体管理器（EntityManager）或自定义仓库（Custom Repository）创建和使用 QueryBuilder 的方式相似。只是在创建 QueryBuilder 时，使用的是数据源的 createQueryBuilder() 方法来创建实例。\n希望这可以帮助您理解如何使用数据源创建和使用 QueryBuilder。如有任何疑问，请随时提问。\n.from(User, &quot;user&quot;)在 TypeORM 的 QueryBuilder 中，.from(User, &quot;user&quot;) 是用于指定查询的主体表的方法。\n在这个例子中，.from(User, &quot;user&quot;) 指定了查询的主体表为名为 “user” 的表，而该表对应的实体类是 User。这样，在后续的查询操作中，我们可以使用 “user” 作为表的别名来引用该表。\n以下是一个完整的示例，演示了如何使用 .from() 方法来指定查询的主体表：\nconst queryBuilder &#x3D; connection.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;) &#x2F;&#x2F; 指定主体表为 &quot;user&quot;，对应的实体类是 User\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();\n\n在上述示例中，我们在 .from() 方法中指定了主体表为 “user”，并使用 .where() 方法来添加一个条件，判断年龄是否大于 18。这样，后续的查询操作中，可以使用 “user” 作为表的别名来引用该表的列。\n请注意，表的别名可以根据需要进行调整，只需确保在后续的查询操作中使用相应的别名即可。\n希望这可以解答您的疑问。如果还有其他问题，请随时提问。\n使用实体管理器 创建和使用 QueryBuilder在 TypeORM 中，您可以使用实体管理器（EntityManager）来创建和使用 QueryBuilder。以下是使用实体管理器创建和使用 QueryBuilder 的示例：\n\n创建 QueryBuilder 实例：\nconst entityManager &#x3D; getConnection().manager;\nconst queryBuilder &#x3D; entityManager.createQueryBuilder();\n\n使用 QueryBuilder 进行查询操作：\nconst entityManager &#x3D; getConnection().manager;\nconst queryBuilder &#x3D; entityManager.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();\n\n在上述示例中，我们首先通过 getConnection().manager 获取实体管理器实例（EntityManager），然后使用 createQueryBuilder() 方法创建一个 QueryBuilder 实例。接下来，我们可以使用 QueryBuilder 进行查询操作，例如选择字段、设置表名、设置查询条件等。最后，我们通过调用适当的方法（如 getMany()）来执行查询并获取结果。\n需要注意的是，在使用实体管理器创建 QueryBuilder 时，可以直接从 getConnection().manager 获取实体管理器实例，也可以通过 entityManager 对象的方式获取实体管理器实例。\n希望这可以帮助您理解如何使用实体管理器创建和使用 QueryBuilder。如果还有任何疑问，请随时提问。\n使用存储库 创建和使用 QueryBuilder在 TypeORM 中，您可以使用存储库（Repository）来创建和使用 QueryBuilder。以下是使用存储库创建和使用 QueryBuilder 的示例：\n\n获取实体的存储库实例：\nconst userRepository &#x3D; getConnection().getRepository(User);\n\n使用存储库的 createQueryBuilder() 方法创建 QueryBuilder 实例：\nconst queryBuilder &#x3D; userRepository.createQueryBuilder();\n\n使用 QueryBuilder 进行查询操作：\nconst userRepository &#x3D; getConnection().getRepository(User);\nconst queryBuilder &#x3D; userRepository.createQueryBuilder();\nconst result &#x3D; await queryBuilder\n  .select(&#39;user.id&#39;, &#39;userId&#39;)\n  .addSelect(&#39;user.name&#39;, &#39;userName&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .getMany();\n\n在上述示例中，我们首先通过 getConnection().getRepository(User) 获取实体 User 的存储库实例（UserRepository）。然后，使用存储库的 createQueryBuilder() 方法创建一个 QueryBuilder 实例。接下来，我们可以使用 QueryBuilder 进行查询操作，例如选择字段、设置表名、设置查询条件等。最后，通过调用适当的方法（如 getMany()）来执行查询并获取结果。\n需要注意的是，在使用存储库创建 QueryBuilder 时，我们首先获取实体的存储库实例，然后使用存储库实例的 createQueryBuilder() 方法创建 QueryBuilder 实例。\n希望这可以帮助您理解如何使用存储库创建和使用 QueryBuilder。如果还有任何疑问，请随时提问。\nuserRepository 为什么叫存储库实例，什么是存储库？在 TypeORM 中，存储库（Repository）是一种设计模式，用于封装对数据库实体的常见操作，如创建、读取、更新和删除（CRUD）操作。存储库提供了一种方便的方式来管理实体对象的持久化和查询。\n存储库的主要目的是为了解耦业务逻辑与底层数据访问层（数据库）之间的关系。它提供了一个抽象层，使业务逻辑能够以更高层次的概念与实体进行交互，而不需要直接处理底层的数据库连接和查询语句。\n在 TypeORM 中，每个实体类（Entity）都可以有一个对应的存储库（Repository），用于管理该实体的持久化和查询操作。存储库提供了一组方法，例如 find()、findOne()、save()、remove() 等，用于执行各种数据库操作。\n当我们通过 getConnection().getRepository(User) 获取到 User 实体的存储库实例时，我们就可以使用该实例来执行对 User 实体的操作，例如保存新的用户、查询用户信息、更新用户数据等。\n存储库的好处在于，它封装了与数据库的交互细节，使得业务逻辑的代码更加简洁、可维护。它还提供了一些便捷的方法和查询构建器（如 QueryBuilder）来简化常见的数据库操作。\n因此，当我们将 userRepository 称为存储库实例时，意味着它是用于管理特定实体（如 User）的存储库的一个实例。我们可以通过该实例调用存储库提供的方法，执行对实体的操作。\n希望这能够解答您的疑问。如果还有其他问题，请随时提问。\n还是不懂存储库（Repository）是一个设计模式，用于将实体（Entity）的持久化和检索操作与业务逻辑分离开来。通过将实体的 CRUD 操作封装在存储库中，可以在不影响业务逻辑的情况下，灵活地更改数据访问层的实现细节，比如更改数据库类型或者更换 ORM 框架。\n在 TypeORM 中，存储库是对实体管理器的封装，提供了与实体相关的各种操作方法，如保存（save）、删除（delete）、查找（find）等。使用存储库可以简化对实体的 CRUD 操作，提高代码的可读性和可维护性。\n存储库可以理解为，将某个实体看成一个库，可以对其做 CRUD 操作？是的，您可以将存储库理解为一个将某个实体看作一个“库”或“集合”，并提供对该实体进行 CRUD（创建、读取、更新、删除）操作的接口。存储库封装了与实体相关的数据库操作，使得在业务逻辑中使用存储库更加方便和可读。\n通过存储库，您可以对实体执行各种操作，如创建新的实体对象并保存到数据库中、从数据库中检索实体、更新现有实体的属性或关系、删除实体等。存储库提供了一组方法来执行这些操作，使您能够以面向实体的方式进行操作，而不必直接编写底层的 SQL 查询语句。\n存储库的好处之一是将数据访问层与业务逻辑层分离，使得代码结构更加清晰和可维护。通过使用存储库，您可以将数据库操作与实体的业务逻辑分离开来，使代码更易于理解、测试和扩展。\n总之，存储库可以被视为一个用于对特定实体执行 CRUD 操作的接口或抽象，它提供了一组方法来操作实体并与底层数据库进行交互。\n希望这能够帮助您理解存储库的概念。如果还有其他问题，请随时提问。\n将数据访问层与业务逻辑层分离，体现在哪，我没看出来呢将数据访问层与业务逻辑层分离体现在以下几个方面：\n\n代码结构清晰：通过使用存储库，您可以将数据访问相关的代码独立于业务逻辑代码，将它们分别放置在不同的模块或文件中。这样，代码结构更加清晰，易于理解和维护。\n\n解耦合：存储库将实体的持久化和查询操作封装起来，使得业务逻辑层不需要直接处理数据库连接和查询语句。业务逻辑层只需要通过存储库提供的接口方法来执行相应的操作，而无需关注底层的数据访问细节。这样可以实现业务逻辑层与数据访问层的解耦合，提高代码的可维护性和可测试性。\n\n抽象数据访问层：存储库提供了一组抽象的方法来执行对实体的操作，例如保存、检索、更新和删除。这些方法屏蔽了底层数据库的细节，使得业务逻辑层可以通过简单的方法调用来完成对实体的操作，而不需要编写复杂的 SQL 查询语句。\n\n可替换性：通过使用存储库，可以轻松更改底层的数据访问技术或数据库类型，而不需要修改业务逻辑层的代码。例如，如果将数据库从 MySQL 切换到 PostgreSQL，只需更改存储库的配置，而不会对业务逻辑层产生影响。\n\n\n综上所述，将数据访问层与业务逻辑层分离使得代码更加模块化、可扩展和可维护。通过使用存储库，业务逻辑层可以专注于业务逻辑的实现，而不必关心底层的数据访问细节，提高了代码的可读性和可维护性。\n希望这能够更好地解释数据访问层与业务逻辑层分离的概念。如果还有其他问题，请随时提问。\n处理关系[关联时候能够提升性能]await dataSource\n    .createQueryBuilder()\n    .relation(Post, &quot;categories&quot;)\n    .of(post)\n    .add(category)\n\n性能更高，为什么？\n\n这段代码使用 TypeORM 的 QueryBuilder 和关系操作功能来将一个特定的分类（category）与给定的帖子（post）建立关联关系。\n在性能方面，这种方法相对高效的原因有几点：\n\n直接操作关系：通过使用 .relation() 方法，可以直接在数据库中操作实体之间的关系，而无需加载整个实体对象。这样可以避免加载和更新实体本身的所有属性，减少了数据传输和数据库操作的开销。\n\n批量操作：在一次查询中，可以同时处理多个关系操作。在上述代码中，.add(category) 可以将给定的分类添加到帖子的分类列表中。这种批量操作可以减少与数据库的交互次数，提高性能。\n\n不加载整个实体：通过使用关系操作功能，可以避免加载整个实体对象，仅仅操作关系表的数据。这对于大型数据集和复杂关系的情况下尤其有效，因为不需要加载和处理整个实体的所有属性，从而减少了内存和计算资源的消耗。\n\n\n总而言之，使用 TypeORM 的关系操作功能可以提供更高的性能，因为它直接操作关系表，支持批量操作，并避免加载整个实体对象。这些优化可以减少数据库操作的次数和数据传输的开销，从而提高性能。\n需要注意的是，性能优化是一个复杂的问题，具体的性能差异可能取决于实际的数据库结构、数据量和使用的数据库引擎。在实际使用中，建议进行基准测试和性能分析，以确定最适合您特定场景的最佳性能优化方法。\n希望这能够回答您的问题。如果还有其他疑问，请随时提问。\n首先不晓得代码是什么意思await dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(&#123; firstPostId: 1, secondPostId: 3 &#125;)\n  .add(&#123; firstCategoryId: 2, secondCategoryId: 4 &#125;);\n\n上述代码使用 TypeORM 的 QueryBuilder 和关系操作功能来将多个分类与多个帖子建立关联关系。\n根据提供的代码，我们可以假设以下情况：\n\nPost 实体具有名为 categories 的关系属性，表示帖子与分类之间的关系。\nCategory 实体具有名为 id 的属性，用于标识分类的唯一性。\n\n基于这些假设，上述代码的目的是将 ID 为 2 和 4 的分类分别与 ID 为 1 和 3 的帖子建立关联关系。\n具体生成的 SQL 查询语句将类似于以下内容：\nINSERT INTO post_categories_post (postId, categoryId) VALUES (1, 2), (3, 4);\n\n上述 SQL 查询语句将在 post_categories_post 表中插入新的关联关系记录，其中 (1, 2) 表示将 ID 为 2 的分类与 ID 为 1 的帖子建立关联关系，(3, 4) 表示将 ID 为 4 的分类与 ID 为 3 的帖子建立关联关系。\n请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。\n希望这能够回答您的问题。如果还有其他疑问，请随时提问。\n如果是(1,2) (3,4) (5,6),该如何书写 queryBuilder【注意啊，这个代码关系是组合】如果要将多个帖子与多个分类建立关联关系，例如将 (1, 2)，(3, 4)，(5, 6) 这些对应的帖子和分类建立关联关系，可以使用 TypeORM 的 QueryBuilder 如下所示：\nawait dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(&#123; id: [1, 3, 5] &#125;) &#x2F;&#x2F; 传入帖子的 ID 数组\n  .add(&#123; id: [2, 4, 6] &#125;); &#x2F;&#x2F; 传入分类的 ID 数组\n\n上述代码将在 Post 实体的 categories 关系中将给定的帖子 ID 和分类 ID 建立关联关系。\n生成的 SQL 查询语句将类似于以下内容：\nINSERT INTO post_categories_post (postId, categoryId) VALUES\n  (1, 2),\n  (1, 4),\n  (1, 6),\n  (3, 2),\n  (3, 4),\n  (3, 6),\n  (5, 2),\n  (5, 4),\n  (5, 6);\n\n上述 SQL 查询语句将在 post_categories_post 表中插入多个关联关系记录，分别表示将给定的帖子和分类之间建立关联关系。\n请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。\n希望这能够回答您的问题。如果还有其他疑问，请随时提问。\n只想 1 和 2 建立关系，3 和 4 建立关系，5 和 6 建立关系如果只想将 (1, 2)，(3, 4)，(5, 6) 这些对应的帖子和分类建立关联关系，可以使用 TypeORM 的 QueryBuilder 如下所示：\nawait dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(1) &#x2F;&#x2F; 第一个帖子的 ID\n  .add(2); &#x2F;&#x2F; 第一个分类的 ID\n\nawait dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(3) &#x2F;&#x2F; 第二个帖子的 ID\n  .add(4); &#x2F;&#x2F; 第二个分类的 ID\n\nawait dataSource\n  .createQueryBuilder()\n  .relation(Post, &#39;categories&#39;)\n  .of(5) &#x2F;&#x2F; 第三个帖子的 ID\n  .add(6); &#x2F;&#x2F; 第三个分类的 ID\n\n上述代码将分别针对每对帖子和分类执行关联关系的添加操作。\n生成的 SQL 查询语句将类似于以下内容：\nINSERT INTO post_categories_post (postId, categoryId) VALUES\n  (1, 2),\n  (3, 4),\n  (5, 6);\n\n上述 SQL 查询语句将在 post_categories_post 表中插入关联关系记录，分别表示将给定的帖子和分类之间建立关联关系。\n请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。\n希望这能够回答您的问题。如果还有其他疑问，请随时提问。\n调用了三次，能简化吗可以使用 TypeORM 的 QueryBuilder 的 insert 方法来实现简化：\nawait dataSource\n  .createQueryBuilder()\n  .insert()\n  .into(&#39;post_categories_post&#39;)\n  .values([\n    &#123; postId: 1, categoryId: 2 &#125;,\n    &#123; postId: 3, categoryId: 4 &#125;,\n    &#123; postId: 5, categoryId: 6 &#125;,\n  ])\n  .execute();\n\n上述代码使用 insert 方法将多个关联关系记录一次性插入到 post_categories_post 表中。\n生成的 SQL 查询语句将类似于以下内容：\nINSERT INTO post_categories_post (postId, categoryId) VALUES\n  (1, 2),\n  (3, 4),\n  (5, 6);\n\n上述 SQL 查询语句将在 post_categories_post 表中插入关联关系记录，分别表示将给定的帖子和分类之间建立关联关系。\n这种方式通过一次数据库操作实现了多个关联关系的添加，可以更简洁地完成任务。\n希望这能够回答您的问题。如果还有其他疑问，请随时提问。\n不存在的情况才进行插入？如果只想在关联关系不存在的情况下才进行插入操作，可以使用 createQueryBuilder() 方法创建的 QueryBuilder，并使用 relation 和 of 方法来检查关联关系是否存在，然后使用 add 方法添加关联关系。\n以下是一个示例：\nconst postId &#x3D; 1;\nconst categoryId &#x3D; 2;\n\nconst queryBuilder &#x3D; dataSource.createQueryBuilder();\nconst relationExists &#x3D; await queryBuilder.relation(Post, &#39;categories&#39;).of(postId).has(categoryId);\n\nif (!relationExists) &#123;\n  await queryBuilder.relation(Post, &#39;categories&#39;).of(postId).add(categoryId);\n&#125;\n\n上述代码首先检查关联关系是否已存在，如果不存在则执行插入操作。\n这样可以确保只在关联关系不存在时才进行插入，避免重复插入已存在的关联关系。\n希望这能够回答您的问题。如果还有其他疑问，请随时提问。\n能简化吗 见可以使用 TypeORM 提供的 createQueryBuilder 的 insert 方法结合 onConflict 子句来实现插入操作时的冲突检测和条件控制。\n以下是一个示例：\nawait dataSource\n  .createQueryBuilder()\n  .insert()\n  .into(&#39;post_categories_post&#39;)\n  .values([\n    &#123; postId: 1, categoryId: 2 &#125;,\n    &#123; postId: 3, categoryId: 4 &#125;,\n    &#123; postId: 5, categoryId: 6 &#125;,\n  ])\n  .onConflict(&#96;(&quot;postId&quot;, &quot;categoryId&quot;) DO NOTHING&#96;)\n  .execute();\n\n上述代码使用 insert 方法将多个关联关系记录一次性插入到 post_categories_post 表中。onConflict 子句指定了在冲突发生时不进行任何操作，从而达到仅在关联关系不存在时才进行插入的效果。\n这样可以简化代码并确保只在关联关系不存在时才进行插入，避免重复插入已存在的关联关系。\n请注意，具体的 SQL 查询语句可能根据您的实体定义、数据库表结构和关系映射而有所不同。上述示例仅为演示目的。\n希望这能够回答您的问题。如果还有其他疑问，请随时提问。\ncreateQueryBuilder 源码DataSource 下的 createQueryBuilder 方法返回了 SelectQueryBuilder 构建器（建造者模式）\nSelectQueryBuilder\ncreateQueryBuilder 示例以下是使用 TypeORM 的 createQueryBuilder 方法的示例：\nimport &#123; createConnection, getConnection &#125; from &#39;typeorm&#39;;\nimport &#123; User &#125; from &#39;.&#x2F;entities&#x2F;User&#39;;\n\n&#x2F;&#x2F; 创建数据库连接\nawait createConnection();\n\n&#x2F;&#x2F; 获取查询构建器\nconst queryBuilder &#x3D; getConnection().createQueryBuilder();\n\n&#x2F;&#x2F; 构建查询\nconst result &#x3D; await queryBuilder\n  .select(&#39;user&#39;)\n  .from(User, &#39;user&#39;)\n  .where(&#39;user.age &gt; :age&#39;, &#123; age: 18 &#125;)\n  .orderBy(&#39;user.name&#39;, &#39;ASC&#39;)\n  .take(10)\n  .getMany();\n\n&#x2F;&#x2F; 打印查询结果\nconsole.log(result);\n\n上述示例中，首先使用 createConnection 方法创建数据库连接。然后，使用 getConnection 方法获取连接对象，并通过调用 createQueryBuilder 方法创建一个查询构建器实例。\n接下来，通过链式调用的方式使用查询构建器构建查询，包括选择要返回的实体（User），添加过滤条件（user.age &gt; :age），指定排序规则（user.name ASC），以及限制返回结果的数量（take(10)）。\n最后，通过调用 getMany 方法执行查询并获取结果。\n这只是一个简单的示例，您可以根据自己的需求使用不同的查询构建器方法来构建更复杂的查询。\n希望这个示例对您有帮助。如果有其他问题，请随时提问。\ndeleteawait myDataSource.createQueryBuilder(&#39;users&#39;).delete().from(User).where(&#39;id &#x3D; :id&#39;, &#123; id: 1 &#125;).execute();\n\n.createQueryBuilder(&#39;users&#39;) 中的 &#39;users&#39; 是给查询构建器指定一个别名，用于在查询中引用该表或实体。\n在 TypeORM 的 QueryBuilder 中，通过指定别名可以在查询过程中引用表或实体，以便于构建复杂的查询逻辑。\n在上述代码中，.createQueryBuilder(&#39;users&#39;) 为查询构建器指定了别名 &#39;users&#39;，以便在后续的查询方法中使用该别名来引用 User 实体。\n通过指定别名，您可以在查询中引用该实体的字段、关联关系等，并进行各种查询操作，如选择特定字段、添加条件、进行排序等。\n希望这解释清楚了 .createQueryBuilder(&#39;users&#39;) 的含义。如果还有其他疑问，请随时提问。\nselect-query-builder#what-are-aliases-for\nsoftdelete软删除，这里就不提了，这篇文章主要是答疑\n软删除对应的字段是哪个在 TypeORM 中，软删除（Soft Delete）是一种通过标记实体而不是直接从数据库中删除实体的技术。TypeORM 提供了一个装饰器 @DeleteDateColumn 来定义软删除相关的字段。\n软删除字段通常是一个日期时间类型的列，用于记录实体被标记为删除的时间。通过在实体类的属性上添加 @DeleteDateColumn 装饰器，可以指定软删除字段的名称和类型。\n以下是一个示例，展示如何在 TypeORM 中定义软删除字段：\nimport &#123; Entity, PrimaryGeneratedColumn, Column, DeleteDateColumn &#125; from &#39;typeorm&#39;;\n\n@Entity()\nexport class User &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @DeleteDateColumn(&#123; name: &#39;deleted_at&#39; &#125;)\n  deletedAt: Date;\n&#125;\n\n在上述示例中，User 实体类具有一个名为 deletedAt 的软删除字段，其类型为 Date。通过添加 @DeleteDateColumn 装饰器，并指定 name 参数为数据库表中的字段名（例如 deleted_at），可以定义软删除字段。\n当使用 TypeORM 的删除操作时，它会将软删除字段设置为实体的删除时间，而不是直接从数据库中删除实体记录。\n请注意，要启用软删除功能，还需要在 TypeORM 的连接配置中设置 softDelete: true。\n希望这个解释对您有所帮助！如果您有其他问题，请随时提问。\n转译，以解决安全问题我们用过 where(&quot;user.name = :name&quot;, &#123; name: &quot;Timber&quot; &#125;)。&#123; name: &quot;Timber&quot; &#125;代表什么？它是我们用来防止 SQL 注入的参数。我们可以这样写：where(&quot;user.name = &#39;&quot; + name + &quot;&#39;)，但是这并不安全，因为它打开了 SQL 注入的代码。安全的方法是使用这种特殊语法：where(&quot;user.name = :name&quot;, &#123; name: &quot;Timber&quot; &#125;)，其中:name 是参数名称，值在对象中指定：&#123; name: &quot;Timber&quot; &#125;。\n方式 1.where(&quot;user.name = :name&quot;, &#123; name: &quot;Timber&quot; &#125;)\n方式 2.where(&quot;user.name &#x3D; :name&quot;)\n.setParameter(&quot;name&quot;, &quot;Timber&quot;)\n\n注意：不要在查询构建器中对不同的值使用相同的参数名称。如果多次设置值将被覆盖。\n您还可以提供一个值数组，并通过使用特殊的扩展语法将它们转换为 SQL 语句中的值列表：\n.where(&quot;user.name IN (:...names)&quot;, &#123; names: [ &quot;Timber&quot;, &quot;Cristal&quot;, &quot;Lina&quot; ] &#125;)\n&#x2F;&#x2F; 这变成：\n\n&#x2F;&#x2F; WHERE user.name IN (&#39;Timber&#39;, &#39;Cristal&#39;, &#39;Lina&#39;)\n\n重难点在实体管理器有哪些实体相关的装饰器在 TypeORM 中，有多种实体相关的装饰器（decorators）可以用来定义和配置实体类。以下是一些常用的实体相关的装饰器：\n\n@Entity()：用于将一个类标记为 TypeORM 实体。必须将此装饰器应用于实体类的顶部。\n\n@PrimaryGeneratedColumn()：用于定义一个自动生成的主键列。通常与 @Entity() 一起使用。\n\n@Column()：用于定义一个实体属性对应的数据库列。可以指定列的类型、长度、是否可为空等选项。\n\n@CreateDateColumn()：用于定义一个在实体创建时自动设置的日期时间列。\n\n@UpdateDateColumn()：用于定义一个在实体更新时自动更新的日期时间列。\n\n@DeleteDateColumn()：用于定义一个在实体被软删除时设置的日期时间列。\n\n@JoinColumn()：用于定义实体之间的关系的连接列。通常在关系的拥有方使用。\n\n@ManyToOne()：用于定义多对一关系。指定一个实体与另一个实体的关联关系。\n\n@OneToMany()：用于定义一对多关系。指定一个实体与多个另一个实体的关联关系。\n\n@ManyToMany()：用于定义多对多关系。指定两个实体之间的多对多关联关系。\n\n@JoinTable()：用于定义多对多关系中的关联表。\n\n@Index()：用于定义数据库索引。\n\n\n这只是一小部分常用的实体相关装饰器，TypeORM 还提供了其他装饰器和选项，用于进一步定义和配置实体类与数据库之间的映射关系。\n请注意，不同的装饰器具有不同的选项和用法，具体使用方式和详细文档可以参考 TypeORM 的官方文档或相关资料。\n希望这些信息对您有所帮助！如果您有其他问题，请随时提问。\ndecorator-reference\n中文\n@CreateDateColumn 在数据库中是什么格式在数据库中，@CreateDateColumn() 装饰器所定义的日期时间列的格式是取决于所使用的数据库管理系统的。TypeORM 会根据数据库的特定规则和类型映射将日期时间值存储在相应的列中。\n以下是一些常见数据库管理系统中 @CreateDateColumn() 列的示例格式：\n\nMySQL：默认情况下，TypeORM 会使用 MySQL 的 DATETIME 类型存储创建日期时间。日期时间值的格式为 YYYY-MM-DD HH:MM:SS。\n\nPostgreSQL：TypeORM 会使用 PostgreSQL 的 TIMESTAMP WITH TIME ZONE 类型存储创建日期时间。日期时间值的格式为 YYYY-MM-DD HH:MM:SS.ssssss+TZ。\n\nSQLite：TypeORM 会使用 SQLite 的 TEXT 类型存储创建日期时间。日期时间值的格式为 YYYY-MM-DD HH:MM:SS.sss。\n\nSQL Server：TypeORM 会使用 SQL Server 的 DATETIME2 类型存储创建日期时间。日期时间值的格式为 YYYY-MM-DD HH:MM:SS.ssssss。\n\n\n请注意，数据库中存储的日期时间格式可能因数据库配置、连接选项或其他因素而有所变化。此外，TypeORM 还允许自定义日期时间列的格式和类型映射，以适应特定的需求。\n如果需要更具体的日期时间格式或类型，请参考 TypeORM 文档中关于特定数据库管理系统的配置和选项，或者根据实际情况进行定制。\n希望这个解答对您有所帮助！如果您有其他问题，请随时提问。\n能定制格式吗在 TypeORM 中，可以通过使用 @CreateDateColumn() 装饰器的选项来自定义日期时间列的格式。\n@CreateDateColumn() 装饰器接受一个选项对象，其中可以包含 type、precision、default、nullable 等属性。其中，type 属性用于指定日期时间列的数据库类型。\n要自定义日期时间列的格式，可以使用 @CreateDateColumn() 的 transformer 属性。transformer 属性允许您指定一个自定义的转换器函数，用于在将值存储到数据库和从数据库读取值时进行格式转换。\n以下是一个示例，展示如何使用 @CreateDateColumn() 的 transformer 属性自定义日期时间列的格式：\nimport &#123; Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ValueTransformer &#125; from &#39;typeorm&#39;;\n\n&#x2F;&#x2F; 自定义转换器函数\nconst dateTimeTransformer: ValueTransformer &#x3D; &#123;\n  to: (value: Date) &#x3D;&gt; value.toISOString(), &#x2F;&#x2F; 转换为 ISO 8601 格式字符串\n  from: (value: string) &#x3D;&gt; new Date(value), &#x2F;&#x2F; 转换为 Date 对象\n&#125;;\n\n@Entity()\nexport class User &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @CreateDateColumn(&#123; transformer: dateTimeTransformer &#125;)\n  createdAt: Date;\n&#125;\n\n在上述示例中，我们定义了一个名为 dateTimeTransformer 的自定义转换器函数，并将其传递给 @CreateDateColumn() 的 transformer 属性。该转换器函数将日期时间值转换为 ISO 8601 格式的字符串进行存储，并在从数据库读取值时将其转换为 Date 对象。\n通过自定义转换器函数，您可以根据需求定义任何所需的日期时间格式或转换逻辑。\n希望这个解答对您有所帮助！如果您有其他问题，请随时提问。\nISO 8601 格式是怎样的ISO 8601 是一种国际标准，用于表示日期、时间和日期时间的格式。它定义了一套通用的日期时间表示法，以确保在不同国家、不同文化和不同计算机系统之间的一致性和互操作性。\nISO 8601 格式具有以下特点：\n\n日期格式：使用年份、月份和日期表示日期。常用格式为 YYYY-MM-DD，例如 2023-05-12 表示 2023 年 5 月 12 日。\n\n时间格式：使用小时、分钟和秒表示时间。常用格式为 HH:MM:SS，例如 14:30:00 表示下午 2 点 30 分。\n\n日期时间格式：组合日期和时间，并使用一个可选的时区偏移。常用格式为 YYYY-MM-DDTHH:MM:SS±hh:mm，例如 2023-05-12T14:30:00+08:00 表示北京时间下的 2023 年 5 月 12 日下午 2 点 30 分。\n\n\nISO 8601 还支持其他格式和扩展，如毫秒、微秒、周数等。它提供了一种标准的方式来表示日期、时间和日期时间，以便于交换、存储和解析。\n在上述示例中，使用 ISO 8601 格式 YYYY-MM-DDTHH:MM:SS 来表示日期时间值。这种格式在国际化环境中广泛使用，并且被许多编程语言和数据库系统支持。\n希望这个解答对您有所帮助！如果您有其他问题，请随时提问。\n如果要存时间戳在数据库中呢如果您想将时间戳存储在数据库中而不是使用日期时间格式，您可以使用 @CreateDateColumn() 的 type 属性来指定数据库列的类型为时间戳类型。\n在 TypeORM 中，支持以下时间戳类型：\n\n&#39;timestamp&#39;：存储带有时区的时间戳。\n&#39;timestamp without time zone&#39;：存储不带时区的时间戳。\n&#39;bigint&#39;：存储大整数类型的时间戳（以毫秒为单位）。\n\n以下是使用 TypeORM 存储时间戳的示例：\nimport &#123; Entity, PrimaryGeneratedColumn, Column, CreateDateColumn &#125; from &#39;typeorm&#39;;\n\n@Entity()\nexport class User &#123;\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @CreateDateColumn(&#123; type: &#39;timestamp&#39; &#125;)\n  createdAt: Date;\n&#125;\n\n在上述示例中，我们使用 @CreateDateColumn() 的 type 属性将 createdAt 列的类型指定为 &#39;timestamp&#39;。这将在数据库中存储带有时区的时间戳。\n如果您希望存储不带时区的时间戳，可以将 type 属性设置为 &#39;timestamp without time zone&#39;。如果您希望以大整数类型（以毫秒为单位）存储时间戳，可以将 type 属性设置为 &#39;bigint&#39;。\n通过适当选择 type 属性，您可以在数据库中存储时间戳而不是日期时间格式。\n希望这个解答对您有所帮助！如果您有其他问题，请随时提问。\n@CreateDateColumn 细分析@CreateDateColumn 在文档上只有简单实用,chatGPT 给出的使用在参考文档上没有，如果遇到其他 API，也会在参考文档上查看不到，那时，就不会用了，有万金油吗？\n源码\nexport function CreateDateColumn(options?: ColumnOptions): PropertyDecorator &#123;\n  return function (object: Object, propertyName: string) &#123;\n    getMetadataArgsStorage().columns.push(&#123;\n      target: object.constructor,\n      propertyName: propertyName,\n      mode: &#39;createDate&#39;,\n      options: options || &#123;&#125;,\n    &#125; as ColumnMetadataArgs);\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 分析：\n\n&#x2F;&#x2F; 入参： ColumnOptions类型\n\n\n\nColumnOptions 源码\n由此，晓得的参数可以如何配置，再个细化，每个属性、方法各代表什么意思，如此，就掌握了一个注解的使用，同时，也就掌握了实体字段注解的所有注解的配置\n源码的注视信息，好像在哪见过\n\n见\n中文\n\nTypeScript 重载&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(): PropertyDecorator;\n\n&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(options: PrimaryGeneratedColumnNumericOptions): PropertyDecorator;\n\n&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(strategy: &#39;increment&#39;, options?: PrimaryGeneratedColumnNumericOptions): PropertyDecorator;\n\n&#x2F;**\n * Column decorator is used to mark a specific class property as a table column.\n *&#x2F;\nexport function PrimaryGeneratedColumn(strategy: &#39;uuid&#39;, options?: PrimaryGeneratedColumnUUIDOptions): PropertyDecorator;\n\n这段代码是一个函数的重载（Function Overload）\n函数重载是指在 TypeScript 中，可以定义多个具有不同参数类型或参数个数的函数签名，但相同的函数名称。\n在调用该函数时，TypeScript 会根据传入的参数类型或参数个数来选择合适的函数定义进行调用。\n在你提供的代码中，有多个函数重载定义了名为 PrimaryGeneratedColumn 的函数。每个函数重载都有不同的参数类型和参数个数。\n这种函数重载的设计可以提供更灵活的使用方式，以适应不同的调用情况。根据传入的参数，TypeScript 将会根据函数的定义来选择匹配的函数重载进行调用。这样可以在不同的情况下提供不同的选项，以便在使用装饰器时能够传递不同的配置参数。\n总的来说，函数重载是一种在 TypeScript 中定义同名函数但具有不同参数类型或参数个数的方式，用于提供灵活的函数调用选项。\nTypescript 重载\n附文档中文文档\n","slug":"2023-05-11typeorm","date":"2023-05-11T07:40:11.000Z","categories_index":"TypeORM","tags_index":"chatGPT2021,TypeORM","author_index":"举手摘月亮"},{"id":"536f5310746872e6a5c917e9332792d4","title":"开发/维护成本","content":"知道需求开发和不晓得需求读代码维护，哪个成本更高成本更高的情况取决于具体的情况和项目要求。以下是一些考虑因素：\n\n需求开发成本高：如果项目需求不明确或频繁变化，需要进行大量的需求澄清、迭代和变更管理，那么需求开发的成本可能更高。\n\n不晓得需求读代码维护成本高：如果代码质量较低、文档不完善或团队成员对项目理解不足，那么读代码和维护的成本可能更高。\n\n\n关键是要在项目中采取适当的措施来降低成本。这包括：\n\n清晰的需求沟通：确保需求明确并与项目所有相关方进行充分的沟通和共享。\n规范的开发流程：采用敏捷开发方法，包括迭代开发、自动化测试和代码审查，以降低开发成本和改进代码质量。\n文档和知识共享：编写清晰的文档，包括代码注释、API 文档和项目文档，以帮助团队成员理解和维护代码。\n持续学习和培训：为团队成员提供培训和学习机会，以提高他们的技能和理解能力。\n\n最重要的是，在项目中保持良好的沟通和团队合作，及时解决问题并确保所有团队成员对项目的需求和代码的理解保持一致。这样可以降低开发和维护过程中的成本和风险。\n如果是跨部门维护项目呢如果项目需要跨部门维护，那么成本更高的情况取决于以下因素：\n\n跨部门沟通成本：不同部门之间的沟通和协调可能会增加沟通成本。每个部门可能有不同的需求、优先级和工作方式，需要花费额外的时间和精力来进行协调和沟通。\n\n知识转移成本：当一个部门接手另一个部门的项目时，可能需要投入时间和资源来理解和熟悉原始部门的代码和需求。这可能涉及学习新的技术栈、阅读文档和与原始团队成员进行知识转移。\n\n维护责任分担成本：跨部门维护项目可能涉及到不同团队之间的责任分担和合作。需要明确各个团队的责任边界、协作方式和沟通渠道，以确保高效的项目维护。\n\n\n为了降低跨部门维护项目的成本，可以采取以下措施：\n\n明确责任和沟通渠道：明确每个部门的责任边界，确保各个团队清楚彼此的工作范围和职责。建立良好的沟通渠道，促进跨部门的信息共享和协作。\n\n文档和知识库：创建详细的文档和知识库，包括代码文档、系统架构、设计文档等，以便新团队成员能够快速理解项目并进行维护。\n\n规范的开发流程：确保采用规范的开发流程，包括代码审查、自动化测试、版本控制等。这样可以提高代码的可维护性，减少潜在的问题和错误。\n\n培训和知识共享：定期进行培训和知识共享活动，以便团队成员能够了解和学习其他部门的工作和技术，促进跨部门的合作和理解。\n\n领导支持和项目管理：确保项目有明确的领导支持和项目管理，可以协调不同部门的工作和资源，推动项目的顺利进行和维护。\n\n\n总的来说，跨部门维护项目的成本较高，但通过明确责任、良好的沟通和协作，以及规范的开发流程和知识共享，可以降低成本并提高项目的维护效率。\n","slug":"2023-05-10成本","date":"2023-05-10T09:08:49.000Z","categories_index":"其他","tags_index":"其他","author_index":"举手摘月亮"},{"id":"7f350638d22d70742cf8b0b4f449ced7","title":"MAC应用级别快捷键定制","content":"参考链接Mac 实用技巧 - 为菜单命令添加快捷键\n链接示例是备忘录添加快捷键，其他应用类似","slug":"2023-05-10mac","date":"2023-05-10T03:33:13.000Z","categories_index":"Mac","tags_index":"Mac","author_index":"举手摘月亮"},{"id":"87f7fda2bbc28a023cd312e8d321db40","title":"NestJS","content":"开箱即用\n开箱即用的应用框架就是一个已经预设好基本功能和样式的框架，可以帮助开发者快速地开发应用程序，不需要从零开始构建基础功能和样式。\n通常，这类框架提供了一些预设的组件、工具、库、样式和模板等，也提供了文档、示例和编码规范等辅助开发的资源。\n开箱即用的应用框架可以大大缩短应用程序的开发周期，降低开发成本，提高开发效率。\n\n对比 Koa、Egg 和 NestJSKoa、Egg 和 NestJS 都是 Node.js 后端框架，它们之间的区别主要在以下几个方面：\n\n设计哲学：\n\nKoa 的设计哲学是尽可能少地对开发者进行限制，给予更多的自由；\nEgg 则是在 Koa 的基础上提供了更多的企业级功能，如插件、中间件、约定等；\nNestJS 则是在传统的后端框架的基础上引入了类似于 Angular 的设计思想，提供了依赖注入、模块化、中间件等功能。\n\n\n开发难度：\n\nKoa 的学习曲线比较陡峭，需要开发者具备一定的 Node.js 基础；\nEgg 的学习曲线相对较平缓，提供了一些快速开发的工具和约定；\nNestJS 的学习曲线较为平缓，但需要开发者熟悉 Typescript。\n\n\n性能：\n\nKoa 是最轻量级的框架，性能比 Egg 和 NestJS 更高；\nEgg 的性能较 Koa 稍微低一些，但仍然足以应对大部分应用场景；\nNestJS 的性能较 Egg 低一些，但其提供的功能较为全面。\n\n\n生态系统：\n\nKoa 的生态系统相对较小，但是其灵活性比较高，可以方便地集成其他库和工具；\nEgg 的生态系统相对较为完善，有大量的插件和中间件可供使用；\nNestJS 的生态系统相对较新，但是也在不断地发展壮大。\n\n\n\n综合来看，选择哪个框架主要取决于具体的应用场景和个人偏好。如果是需要快速搭建企业级应用的话，可以考虑使用 Egg；如果是需要灵活性和自由度更高的项目，可以选择 Koa；如果是想要尝试一种新的设计思想，并且愿意接受一定的性能损失，可以尝试 NestJS。\nNestJS 重要概念区分区分部件及使用场景\n在 NestJS 中，守卫在所有中间件之后执行，但在任何拦截器或管道之前执行，这是因为守卫的主要目的是在请求到达控制器之前对请求进行验证、授权或其他操作。\n中间件是在请求到达控制器之前执行的代码，它们通常用于处理请求的前置操作，例如身份验证、日志记录等。中间件的执行顺序是按照它们在应用程序中的注册顺序依次执行的。\n拦截器和管道是用于处理控制器中的方法执行前后的操作。拦截器可以在方法执行前后进行一些额外的处理，例如日志记录、异常处理等。\n管道可以用于对请求进行转换、验证或其他处理。\n守卫的目的是在控制器之前对请求进行验证或授权，因此它们需要在中间件执行之后但在拦截器和管道执行之前执行。这样可以确保在进入控制器之前对请求进行了适当的验证和授权操作，以便控制器中的方法能够处理有效和合法的请求。\nNestjs 与 Spring BootNestJS 和 Spring Boot 都是为了帮助开发者更方便地构建 Web 应用程序的框架，它们有很多相似的地方，比如都提供了基于注解的依赖注入、MVC 架构、ORM 等功能。\n以下是它们的一些区别：\n\n编程语言：NestJS 是基于 TypeScript 的，而 Spring Boot 是基于 Java 的。这意味着使用 NestJS 可以利用 TypeScript 的一些特性，如静态类型检查和装饰器语法糖，而 Spring Boot 则可以利用 Java 的成熟生态系统和广泛的库。\n\n构建工具：NestJS 使用的是基于 Node.js 的构建工具，如 npm 和 yarn，而 Spring Boot 使用的是 Maven 或 Gradle。这意味着在构建和依赖管理方面有一些不同。\n\n性能：由于 Java 语言和 JVM 的成熟性和优化，Spring Boot 在性能方面可能会略优于 NestJS。但是，这取决于应用程序的特定需求和实现。\n\n社区：Spring Boot 拥有一个庞大的社区，这意味着有很多资源、教程和插件可供使用，而 NestJS 的社区相对较小，但正在不断增长。\n\n\n总的来说，NestJS 和 Spring Boot 都是优秀的框架，可以根据个人喜好和应用程序的需求来选择使用。如果你喜欢 TypeScript 或者想要使用 Node.js，那么 NestJS 是个不错的选择；如果你熟悉 Java 或者已经有一个庞大的 Java 应用程序生态系统，那么 Spring Boot 可能更适合你。\n依赖注入nextjs 依赖注入 Injectable 是什么意思Injectable 是 NestJS 中的一个装饰器，用于标记一个类可以被注入到其他类中。这个类通常会包含一些可重用的逻辑，例如与数据库的交互、第三方服务的调用等等。\n使用 @Injectable() 装饰器后，这个类可以通过构造函数参数或属性注入到其他类中，从而达到依赖注入的效果。例如：\n@Injectable()\nexport class UserService &#123;\n  constructor(private readonly userRepository: UserRepository) &#123;&#125;\n\n  async findAll(): Promise&lt;User[]&gt; &#123;\n    return this.userRepository.findAll();\n  &#125;\n&#125;\n\n在上面的例子中，UserService 类被标记为可注入的，并且通过构造函数注入了 UserRepository 类。这样，当我们需要在其他地方使用 UserService 时，只需要将它注入到对应的类中即可，而不需要手动创建 UserRepository 实例。\nNestJS 的依赖注入机制是基于 TypeScript 装饰器和反射机制实现的。它可以让我们以更加简洁和优雅的方式来管理应用程序中的依赖关系。\n依赖注入设计模式依赖注入（Dependency Injection，简称 DI）是一种软件设计模式，它的主要目的是将对象之间的依赖关系的创建与运行时耦合解耦。通俗地说，就是在程序运行的时候，动态地将对象所需要的其他对象的引用注入到它内部，而不是由对象自己去创建这些依赖关系。这种方式可以降低对象之间的耦合度，从而提高代码的灵活性、可扩展性和可维护性。依赖注入通常是通过构造函数参数、属性或者工厂方法实现的。\n\nDetails\n依赖注入是一种设计模式，它通过将对象之间的依赖关系从硬编码到代码之外的配置文件或者工厂类中，来降低应用程序的耦合度，从而实现了可重用性、灵活性和可维护性。\n通常，依赖注入的过程分为三个步骤：\n\n定义依赖：在类中声明需要依赖的对象，通常是通过构造函数、Setter 方法或接口等方式进行声明。\n\n注入依赖：在应用程序中创建依赖对象，并将它们注入到类中，通常是通过工厂类或配置文件进行注入。\n\n使用依赖：在类中使用依赖对象，执行业务逻辑。\n\n\n依赖注入的优点包括：\n\n可测试性：通过将依赖关系从代码中抽离出来，可以轻松地将测试替身传递给类，从而实现更好的单元测试和集成测试。\n\n可重用性：通过将依赖关系从代码中解耦出来，可以更容易地将类组合在一起创建新的对象，从而实现更高的可重用性。\n\n松耦合：通过依赖注入，对象只依赖于接口而不是具体实现，从而减少了类之间的耦合，使应用程序更加灵活和可维护。\n\n可扩展性：通过将依赖关系从代码中解耦出来，可以更容易地添加或删除功能，从而实现更高的可扩展性。\n\n\n\n\n注入和实例化看上去没区别？在依赖注入模式中，注入和实例化是不同的概念。注入是指将一个对象传递给另一个对象的过程，而实例化是指创建一个对象的过程。\n在依赖注入中，对象通常是在其依赖项中被注入的，而不是直接实例化它们。这种方法使得应用程序更加松散耦合，因为依赖关系是在运行时确定的，而不是在编译时确定的。\n@Module 的 imports 和 providers 有什么区别@Module 的 imports 和 providers 都是用来定义模块的成员的装饰器。\nimports 用于导入依赖模块。在 Nest.js 应用程序中，模块之间的依赖关系是通过导入和导出模块来管理的。如果要使用另一个模块的服务或其他提供者，则必须将其导入到当前模块中。imports 数组中可以包含其他模块、共享模块和全局模块。\nproviders 用于定义当前模块的提供者。提供者是当前模块中可被注入的任何东西，比如服务、工厂、类等。提供者可以是同步或异步的，它们可以被其他提供者或控制器使用。\n简而言之，imports 用于导入依赖模块，providers 用于定义当前模块的提供者。\n不导入，直接提供不行吗？在 NestJS 中，我们需要使用 @Module 装饰器来声明一个模块，一个模块可以包含多个 imports、providers、controllers 和 exports。其中，imports 属性用于导入其它模块，providers 属性用于提供可注入的服务。\n如果一个模块没有导入其它模块，而直接提供服务，那么这些服务仍然可以正常使用，但是如果这些服务需要依赖其它服务或模块，就需要将这些依赖项以 providers 的形式进行提供，否则依赖注入时会出现问题。\n因此，虽然在不导入其它模块的情况下，直接提供服务是可行的，但是为了确保依赖注入的正确性，建议还是将所有的服务都以 providers 的形式进行提供。\n@Module exports在 NestJS 中，@Module 装饰器还提供了 exports 选项，用于导出在当前模块中定义的 providers 和 controllers，以供其他模块使用。\n如果一个模块中的某个服务在其他模块中也需要使用，可以通过在当前模块的 exports 中导出该服务，让其他模块可以引入并使用该服务。这样的话，如果要修改该服务，只需要在当前模块中修改即可，而不用在多个模块中修改。\n举个例子，如果我们有一个 UserService，它在 UserModule 模块中定义，如下所示：\n@Module(&#123;\n  providers: [UserService],\n  exports: [UserService],\n&#125;)\nexport class UserModule &#123;&#125;\n\n在另一个模块中，如果要使用 UserService，可以通过 imports 导入 UserModule，然后通过 providers 获取它，如下所示：\n@Module(&#123;\n  imports: [UserModule],\n  providers: [SomeService],\n&#125;)\nexport class SomeModule &#123;\n  constructor(private readonly userService: UserService) &#123;&#125;\n&#125;\n\n通过这种方式，我们可以轻松地在不同的模块中共享同一个服务实例，避免重复定义和管理。\n不经过这个 UserModule ，直接用 UserService 不行吗如果您在 UserModule 中将 UserService 注册为提供者 (Provider)，那么在其他模块中可以使用 UserService，但是需要导入 UserModule 才能使用。如果不想在其他模块中导入 UserModule，可以将 UserService 导出 (export) 给其他模块使用。\n例如，在 UserModule 中:\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; UserController &#125; from &#39;.&#x2F;user.controller&#39;;\nimport &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\n\n@Module(&#123;\n  controllers: [UserController],\n  providers: [UserService],\n  exports: [UserService], &#x2F;&#x2F; 导出 UserService\n&#125;)\nexport class UserModule &#123;&#125;\n\n在其他模块中，可以直接使用 UserService，而不需要导入 UserModule：\nimport &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\n\n@Module(&#123;\n  providers: [SomeOtherService],\n&#125;)\nexport class SomeOtherModule &#123;\n  constructor(private readonly userService: UserService) &#123;&#125;\n&#125;\n\n通过将 UserService 导出 (export) 到其他模块，其他模块可以直接使用 UserService 而无需导入 UserModule。\n直接导入到其他模块不行吗直接导入到其他模块也是可以的，不一定非要通过 UserModule 来使用 UserService。但是通过模块化的方式，可以更好地管理依赖关系，让代码更加清晰和易于维护。比如，如果 UserService 依赖了其他模块的服务，我们可以在 UserModule 中导入这些模块并将它们注册为 UserModule 的提供者，这样可以方便地管理所有依赖项，并且确保它们的顺序正确。同时，如果我们需要修改 UserService 的行为，我们只需要修改 UserModule 中的 UserService 提供者即可，而不用去修改其他模块中直接使用 UserService 的代码。这种解耦的方式可以让代码更加灵活和可维护。\n这么理解 providers 和 controllers 组成了 UserModule,其他 module 如果想用 UserModule 的东西，先要再 UserModule 导出，然后其他模块导入，接着进行使用，是这样吗是的，您可以这样理解。当一个模块中定义了 providers 和 controllers 后，其他模块需要使用这些模块提供的服务时，需要将该模块导入到其他模块中。在导入后，其他模块就可以通过依赖注入的方式使用该模块中提供的服务。在 NestJS 中，导入模块的过程就是使用 imports 属性，而模块中提供的服务通过 providers 属性进行定义。\n简单来说，以前直接 require 或者 import 的方式，现在不用了，用了 nestjs 的依赖注入的方式实现同样的功能，虽然繁琐了写，但是规范了\n异常过滤器nestjs 异常全局过滤器有几种方式在 NestJS 中，可以使用全局异常过滤器（Global Exception Filters）来捕获应用程序中的所有异常，并对它们进行处理。\nNestJS 中有两种方式来创建全局异常过滤器：\n基于类的全局过滤器：创建一个实现了 ExceptionFilter 接口的类，使用 @Catch() 装饰器指定要捕获的异常类型，然后在应用程序启动时使用 app.useGlobalFilters() 方法将其注册为全局异常过滤器。\n\n函数式全局过滤器：创建一个函数，接收一个 Exception 参数，并返回一个处理结果，然后使用 app.useGlobalFilters() 方法将其注册为全局异常过滤器。\n\n\n下面是两种方式的示例代码：\n基于类的全局过滤器：import &#123; ExceptionFilter, Catch, ArgumentsHost &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; Response &#125; from &#39;express&#39;;\n\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter &#123;\n  catch(exception: unknown, host: ArgumentsHost) &#123;\n    const ctx &#x3D; host.switchToHttp();\n    const response &#x3D; ctx.getResponse&lt;Response&gt;();\n\n    response.status(500).json(&#123;\n      statusCode: 500,\n      message: &#39;Internal server error&#39;,\n    &#125;);\n  &#125;\n&#125;\n\n在 main.ts 文件中注册全局过滤器：\nimport &#123; NestFactory &#125; from &#39;@nestjs&#x2F;core&#39;;\nimport &#123; AppModule &#125; from &#39;.&#x2F;app.module&#39;;\nimport &#123; AllExceptionsFilter &#125; from &#39;.&#x2F;common&#x2F;filters&#x2F;all-exceptions.filter&#39;;\n\nasync function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n\n  app.useGlobalFilters(new AllExceptionsFilter());\n\n  await app.listen(3000);\n&#125;\nbootstrap();\n\n函数式全局过滤器：import &#123; ExceptionFilter, Catch, ArgumentsHost &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; Response &#125; from &#39;express&#39;;\n\nexport const allExceptionsFilter: ExceptionFilter &#x3D; (exception, host) &#x3D;&gt; &#123;\n  const ctx &#x3D; host.switchToHttp();\n  const response &#x3D; ctx.getResponse&lt;Response&gt;();\n\n  response.status(500).json(&#123;\n    statusCode: 500,\n    message: &#39;Internal server error&#39;,\n  &#125;);\n&#125;;\n\n在 main.ts 文件中注册全局过滤器：\nimport &#123; NestFactory &#125; from &#39;@nestjs&#x2F;core&#39;;\nimport &#123; AppModule &#125; from &#39;.&#x2F;app.module&#39;;\nimport &#123; allExceptionsFilter &#125; from &#39;.&#x2F;common&#x2F;filters&#x2F;all-exceptions.filter&#39;;\n\nasync function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n\n  app.useGlobalFilters(allExceptionsFilter);\n\n  await app.listen(3000);\n&#125;\nbootstrap();\n\n注意，无论使用哪种方式创建全局异常过滤器，都应该在应用程序启动时进行注册。\n“基于类的全局过滤器” 和 “函数式全局过滤器” 有什么区别在 Nest.js 中，异常全局过滤器可以通过基于类和基于函数两种方式来实现。\n基于类的全局过滤器是一个可注入的类，需要实现 ExceptionFilter 接口，其中包含一个 catch(exception: any, host: ArgumentsHost) 方法，用于处理异常。这种方式可以使用依赖注入来获得其他模块的服务和配置信息，并且还可以轻松地继承、重写和重用已有的过滤器。\n函数式全局过滤器则是一个简单的函数，接受两个参数 exception 和 host，同样用于处理异常。这种方式不依赖于依赖注入，更加轻量级，但缺少了继承和重用已有过滤器的功能。\n总体来说，基于类的全局过滤器更加灵活、可扩展，而函数式全局过滤器则更加轻量、简单。选择哪种方式，可以根据具体的业务场景和性能要求来决定。\n在 NestJS 中，可以在不同的层级上绑定异常过滤器，包括全局、模块、控制器和方法级别。\n全局层级：可以创建全局的异常过滤器来处理整个应用程序的异常，通过在 main.ts 中使用 app.useGlobalFilters() 方法进行绑定。\n模块层级：在一个模块中可以创建专门的异常过滤器来处理该模块中所有控制器抛出的异常，通过在模块注解中使用 @UseFilters() 进行绑定。\n控制器层级：在一个控制器中可以创建专门的异常过滤器来处理该控制器中所有方法抛出的异常，通过在控制器注解中使用 @UseFilters() 进行绑定。\n方法层级：在一个方法中可以创建专门的异常过滤器来处理该方法抛出的异常，通过在方法注解中使用 @UseFilters() 进行绑定。\n\n以下是几个示例：\n全局层级示例async function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n  app.useGlobalFilters(new HttpExceptionFilter());\n  await app.listen(3000);\n&#125;\n\n模块层级示例以下是模块层级的示例：\n假设我们有一个叫做AppModule的根模块，其中包含两个模块：UserModule和ProductModule。我们想要为这两个模块分别设置全局的异常过滤器。\n首先，我们需要创建一个基于类的异常过滤器：\nimport &#123; ExceptionFilter, Catch &#125; from &#39;@nestjs&#x2F;common&#39;;\n\n@Catch()\nexport class GlobalExceptionFilter implements ExceptionFilter &#123;\n  catch(exception: any, host: ArgumentsHost) &#123;\n    &#x2F;&#x2F; 处理异常的逻辑\n  &#125;\n&#125;\n\n然后，在UserModule中，我们可以通过@Module装饰器的providers属性来指定该模块的异常过滤器：\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; UserController &#125; from &#39;.&#x2F;user.controller&#39;;\nimport &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\nimport &#123; GlobalExceptionFilter &#125; from &#39;.&#x2F;global-exception.filter&#39;;\n\n@Module(&#123;\n  controllers: [UserController],\n  providers: [\n    UserService,\n    &#123;\n      provide: &#39;APP_FILTER&#39;,\n      useClass: GlobalExceptionFilter,\n    &#125;,\n  ],\n&#125;)\nexport class UserModule &#123;&#125;\n\n在上面的代码中，我们将GlobalExceptionFilter类作为一个提供者提供给了UserModule，并且使用provide属性指定了这是一个全局的异常过滤器。\n同样的，我们也可以在ProductModule中设置该模块的异常过滤器：\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ProductController &#125; from &#39;.&#x2F;product.controller&#39;;\nimport &#123; ProductService &#125; from &#39;.&#x2F;product.service&#39;;\nimport &#123; GlobalExceptionFilter &#125; from &#39;.&#x2F;global-exception.filter&#39;;\n\n@Module(&#123;\n  controllers: [ProductController],\n  providers: [\n    ProductService,\n    &#123;\n      provide: &#39;APP_FILTER&#39;,\n      useClass: GlobalExceptionFilter,\n    &#125;,\n  ],\n&#125;)\nexport class ProductModule &#123;&#125;\n\n在上面的代码中，我们将GlobalExceptionFilter类作为一个提供者提供给了ProductModule，并且同样使用provide属性指定了这是一个全局的异常过滤器。\n最后，在AppModule中，我们可以通过@UseFilters装饰器来绑定全局的异常过滤器，这样所有模块中没有单独设置过异常过滤器的请求都会被该全局过滤器捕获：\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; UserModule &#125; from &#39;.&#x2F;user&#x2F;user.module&#39;;\nimport &#123; ProductModule &#125; from &#39;.&#x2F;product&#x2F;product.module&#39;;\nimport &#123; APP_FILTER &#125; from &#39;@nestjs&#x2F;core&#39;;\nimport &#123; GlobalExceptionFilter &#125; from &#39;.&#x2F;global-exception.filter&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\n\n@Module(&#123;\n  imports: [UserModule, ProductModule],\n  controllers: [AppController],\n  providers: [\n    &#123;\n      provide: APP_FILTER,\n      useClass: GlobalExceptionFilter,\n    &#125;,\n  ],\n&#125;)\nexport class AppModule &#123;&#125;\n\n在上面的代码中，我们通过提供APP_FILTER的方式，将GlobalExceptionFilter类作为全局异常过滤器提供给了AppModule。这样就完成了全局异常过滤器的设置，即使有些模块没有单独设置过异常过滤器，请求也能被捕获并处理。\n绑定到一个控制器上：（控制器层级）@UseFilters(HttpExceptionFilter)\nexport class CatsController &#123;&#125;\n\n这将绑定一个基于类的过滤器 HttpExceptionFilter 到 CatsController 控制器上。\n绑定到一个自定义路由上：（方法层级）@Post()\n@UseFilters(HttpExceptionFilter)\ncreate() &#123;\n  &#x2F;&#x2F; create a cat\n&#125;\n\n这将绑定一个基于类的过滤器 HttpExceptionFilter 到 create 路由上。\n这将绑定一个基于类的过滤器 HttpExceptionFilter 到全局，以处理应用程序中所有的异常。\nNestJS 中间件为什么要使用中间件？中间件是一个常见的设计模式，它可以用于在应用程序的不同层之间进行消息传递、修改请求&#x2F;响应对象、执行身份验证和授权等操作。在 Nestjs 中，中间件是在 HTTP 请求处理流程中执行的一个函数，它可以对请求进行修改、拦截、记录和转发等操作。\n使用中间件可以帮助我们更好地组织和管理应用程序的代码。例如，可以使用中间件来处理日志记录、请求验证、错误处理等常见任务。这样可以将这些任务从控制器或服务中分离出来，使代码更易于理解、测试和维护。\n另外，使用中间件可以让我们轻松地实现一些通用的功能，例如对请求进行身份验证或对响应进行压缩等操作。这样可以使代码更具可重用性和可维护性。\n中间件属于 23 种设计模式中的哪种？中间件属于行为设计模式中的一种，具体来说是责任链模式（Chain of Responsibility Pattern）的一种实现方式。\n为什么不是过滤器模式呢？中间件和过滤器都属于软件设计模式中的行为型模式，但它们的作用有所不同。\n中间件的作用是在请求处理的过程中，对请求进行拦截和处理，并将控制权传递给下一个中间件或处理程序。中间件通常被设计成链式结构，每个中间件都负责一些特定的功能，且这些功能可以被顺序串起来以完成一系列的任务。Nest.js 中间件就是典型的中间件模式的实现。\n而过滤器的作用是对数据进行过滤和处理，通常是在数据被提交或响应之前或之后进行。过滤器可以是输入过滤器、输出过滤器或两者的结合体。过滤器模式主要是针对数据的过滤和处理，相比之下中间件模式更加通用和灵活。\n因此，虽然中间件和过滤器有些相似之处，但它们的本质不同，因此中间件不属于过滤器模式。\naxios 的拦截器也是责任链模式？是的，Axios 的拦截器实现了责任链模式。在 Axios 中，拦截器被分为请求拦截器和响应拦截器。每个拦截器都有一个处理函数，在请求或响应被发送之前或之后执行。多个拦截器可以按照一定的顺序组成一个链，每个拦截器可以选择继续传递请求或响应，或者中断并返回一个错误响应。这就是责任链模式的经典实现方式。\n中间件能做什么\n执行任何代码。\n更改请求和响应对象。\n结束请求-响应循环。\n调用堆栈中的下一个中间件函数。\n如果当前中间件函数没有结束请求-响应循环，它必须调用 next()将控制权传递给下一个中间件函数。否则，请求将被挂起。\n\n中间件分类在 Nestjs 中，中间件（Middleware）是一种在处理 HTTP 请求和响应之前或之后进行拦截和处理的机制。中间件的作用类似于拦截器（Interceptor），但是与拦截器不同的是，中间件可以针对整个应用程序，而不仅仅是某个控制器或者方法。\n在 Nestjs 中，中间件可以是全局的，也可以是局部的。全局中间件会对整个应用程序的请求进行拦截和处理，而局部中间件只会对指定的路由或控制器的请求进行拦截和处理。\nNestjs 支持使用类和函数两种方式来创建中间件。使用类创建中间件时，需要实现 NestMiddleware 接口。使用函数创建中间件时，需要返回一个函数，该函数接收三个参数：请求对象、响应对象和下一个中间件函数。\n以下是一个使用类创建中间件的示例：\nimport &#123; Injectable, NestMiddleware &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; Request, Response &#125; from &#39;express&#39;;\n\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware &#123;\n  use(req: Request, res: Response, next: Function) &#123;\n    console.log(&#96;Request...&#96;);\n    next();\n  &#125;\n&#125;\n\n该中间件将在每个请求到达应用程序时输出一个日志。\n要将全局中间件添加到应用程序中，需要在应用程序模块中调用 app.use() 方法。以下是一个示例：\nimport &#123; Module, NestModule, MiddlewareConsumer &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\nimport &#123; AppService &#125; from &#39;.&#x2F;app.service&#39;;\nimport &#123; LoggerMiddleware &#125; from &#39;.&#x2F;logger.middleware&#39;;\n\n@Module(&#123;\n  imports: [],\n  controllers: [AppController],\n  providers: [AppService],\n&#125;)\nexport class AppModule implements NestModule &#123;\n  configure(consumer: MiddlewareConsumer) &#123;\n    consumer.apply(LoggerMiddleware).forRoutes(&#39;*&#39;);\n  &#125;\n&#125;\n\n该中间件将被应用于所有的路由。\n要将局部中间件添加到控制器或者路由中，需要在相应的控制器或者路由上调用 use() 方法。以下是一个示例：\nimport &#123; Controller, Get, UseMiddleware &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; LoggerMiddleware &#125; from &#39;.&#x2F;logger.middleware&#39;;\n\n@Controller(&#39;cats&#39;)\n@UseMiddleware(LoggerMiddleware)\nexport class CatsController &#123;\n  @Get()\n  findAll() &#123;\n    return &#39;This action returns all cats&#39;;\n  &#125;\n&#125;\n\n该中间件将仅被应用于 &#x2F;cats 路由。\nNestJs 管道在 NestJS 中，管道（Pipes）是用于对输入数据进行转换和验证的机制。它们充当了请求和响应数据的过滤器，并可以在数据进入控制器之前或离开控制器之后进行处理。\n管道在数据流中的位置通常是在控制器的参数绑定和请求处理之间。它们可以用于验证和转换请求的参数、验证响应的数据、对输入数据进行预处理等。\n使用管道的好处包括：\n\n数据验证：管道可以验证输入数据的有效性，例如验证请求的参数是否符合规定的格式、是否满足自定义的业务规则等。\n\n数据转换：管道可以将输入数据转换为目标类型或格式，例如将字符串转换为数字、将日期字符串转换为日期对象等。\n\n数据预处理：管道可以在数据进入控制器之前对其进行预处理，例如清理数据、添加默认值、进行数据格式化等。\n\n统一的数据处理逻辑：通过管道，可以将数据处理逻辑集中在一个地方，提高代码的可维护性和重用性。\n\n\n在 NestJS 中，可以使用内置的管道，如 ValidationPipe、ParseIntPipe 等，也可以创建自定义的管道来满足特定的需求。管道可以应用于控制器的方法参数、方法返回值、自定义 DTO 对象等多个地方，以实现数据的验证和转换。\n主要内容\n绑定到参数上-类方式&#x2F;实例方式\n基于 joi 的 shcema 方式\nclass-validator 类方式\n全局方式【前三种可以，这个用不来】\n\nnestjs 管道属于 23 种设计模式中的哪种在设计模式中，NestJS 的管道属于”装饰器模式”。装饰器模式是一种结构型设计模式，它允许在不修改现有对象结构的情况下，通过将对象包装在装饰器对象中来动态地添加功能。\n在 NestJS 中，管道充当了装饰器的角色。它们用于包装和处理传入的请求数据，并可以在处理数据之前和之后执行各种操作，例如验证、转换、过滤等。通过使用管道，我们可以将这些处理逻辑与业务逻辑分离，并在需要时轻松地应用它们。\n类似于装饰器模式中的装饰器对象，NestJS 的管道可以应用于控制器的方法参数、方法、类等，以添加额外的功能和验证。它们可以按顺序链接在一起，形成管道链，每个管道都负责一项具体的任务。\n总之，NestJS 的管道采用了装饰器模式的概念和思想，通过在运行时动态地为对象添加功能，实现了代码的可维护性和可扩展性。\n守卫&#x2F;授权&#x2F;鉴权守卫与中间件\n守卫不是中间件\n因为中间件不知道调用该函数后将执行哪个处理 next()程序\n守卫可以访问实例 ExecutionContext，因此确切地知道接下来要执行什么。\n\n守卫与中间件、过滤器、管道、拦截器它们的设计与异常过滤器、管道和拦截器非常相似，可让您在请求&#x2F;响应周期的正确位置插入处理逻辑，并以声明方式进行。这有助于使您的代码保持干爽和声明式\n守卫执行顺序守卫在所有中间件之后执行，但在任何拦截器或管道 之前执行。\nnestjs 中 “守卫在所有中间件之后执行，但在任何拦截器或管道 之前执行”，为什么在 NestJS 中，守卫在所有中间件之后执行，但在任何拦截器或管道之前执行，这是因为守卫的主要目的是在请求到达控制器之前对请求进行验证、授权或其他操作。\n中间件是在请求到达控制器之前执行的代码，它们通常用于处理请求的前置操作，例如身份验证、日志记录等。中间件的执行顺序是按照它们在应用程序中的注册顺序依次执行的。\n拦截器和管道是用于处理控制器中的方法执行前后的操作。拦截器可以在方法执行前后进行一些额外的处理，例如日志记录、异常处理等。\n管道可以用于对请求进行转换、验证或其他处理。\n守卫的目的是在控制器之前对请求进行验证或授权，因此它们需要在中间件执行之后但在拦截器和管道执行之前执行。这样可以确保在进入控制器之前对请求进行了适当的验证和授权操作，以便控制器中的方法能够处理有效和合法的请求。\n身份验证的中间件与授权的守卫区别简化：\n\n身份验证中间件用于验证请求中的身份信息，确保请求发起者经过身份验证。\n\n授权守卫用于在进入控制器的特定路由或方法之前进行授权验证，确保请求发起者有足够的权限或角色访问受保护的资源。\n\n\n\nDetails\n身份验证中间件和授权守卫在 NestJS 中具有不同的作用和功能：\n\n身份验证中间件（Authentication Middleware）：\n\n身份验证中间件用于验证请求中的身份信息，例如用户的凭证、令牌或会话。\n它通常在请求到达控制器之前执行，用于对请求进行身份验证和身份认证。\n身份验证中间件的目的是确保请求发起者是经过身份验证和授权的用户。\n\n\n授权守卫（Authorization Guards）：\n\n授权守卫用于在进入控制器的特定路由或方法之前进行授权验证。\n它基于用户的身份信息和角色&#x2F;权限规则来决定是否允许请求继续执行。\n授权守卫的目的是确保请求发起者具有足够的权限或角色才能访问受保护的资源。\n\n\n\n总结：\n\n身份验证中间件主要负责验证请求中的身份信息，确保请求发起者经过身份验证。\n授权守卫用于在进入控制器的特定路由或方法之前进行授权验证，决定请求是否具有访问权限。\n\n这两个概念是互补的，身份验证确保用户的身份可信，授权守卫确保用户有权访问特定资源。通常，身份验证中间件会在授权守卫之前执行，以确保请求发起者经过身份验证后再进行授权验证。\n\n\nCASLCASL 是什么CASL（Capability-based Security Language）是一个用于在应用程序中实施基于能力的安全性的库。它提供了一种声明性的方式来定义和验证用户对资源的访问权限。\nCASL 提供了一个可读性强且易于使用的 DSL（领域特定语言），用于定义资源、操作和角色之间的关系。它基于资源能力列表（ACL）模型，其中每个能力表示用户可以对资源执行的操作。\n使用 CASL，您可以轻松地将访问控制逻辑集成到您的应用程序中。以下是 CASL 的一些主要特点：\n\n声明性语法：CASL 提供了一种声明性的语法，您可以使用它来定义资源、操作和角色之间的关系。这使得代码更易于理解和维护。\n\n动态授权：CASL 允许您在运行时动态计算用户的权限，以便根据不同的上下文和条件对资源的访问进行灵活控制。\n\n细粒度控制：CASL 支持对每个资源和操作进行细粒度的控制，使您能够以精确的方式定义用户的权限。\n\n支持多种框架和库：CASL 不仅适用于 Node.js 和浏览器环境，还提供了与常见框架和库（如 Angular、React、Vue.js 等）的集成。\n\n\n通过使用 CASL，您可以将安全性作为应用程序的核心设计原则，并以一种直观和灵活的方式实现访问控制。CASL 的目标是帮助您构建安全且易于扩展的应用程序，同时保持代码的清晰和可维护性。\nCASL 如何使用CASL 的使用涉及几个主要概念和步骤。下面是一个基本的 CASL 使用示例：\n\n定义资源和操作：首先，您需要定义应用程序中的资源和操作。资源可以是任何您希望进行访问控制的实体，例如用户、文章、订单等。操作表示用户可以对资源执行的操作，例如创建、读取、更新和删除。\n\n定义角色和权限：接下来，您需要定义角色和与之关联的权限。角色可以代表用户、用户组或特定角色，而权限表示角色被授予的资源操作能力。\n\n创建策略：使用 CASL，您可以创建策略来定义谁可以执行哪些操作。策略基于资源、操作和角色之间的关系来确定用户的访问权限。\n\n验证权限：一旦策略定义完毕，您可以使用 CASL 提供的验证方法来验证用户对资源的访问权限。您可以在需要进行访问控制的地方调用这些方法，并根据结果采取相应的操作。\n\n\n下面是一个简单的示例，展示了如何使用 CASL：\nimport &#123; AbilityBuilder, Ability &#125; from &#39;@casl&#x2F;ability&#39;;\n\n&#x2F;&#x2F; 定义资源和操作\nconst ArticleResource &#x3D; &#39;Article&#39;;\nconst ArticleActions &#x3D; [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;];\n\n&#x2F;&#x2F; 定义角色和权限\nconst roles &#x3D; &#123;\n  guest: [&#39;read&#39;],\n  user: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;],\n  admin: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;],\n&#125;;\n\n&#x2F;&#x2F; 创建策略\nconst ability &#x3D; AbilityBuilder.define((can) &#x3D;&gt; &#123;\n  can(&#39;read&#39;, ArticleResource);\n  can(&#39;create&#39;, ArticleResource);\n  can(&#39;update&#39;, ArticleResource);\n  can(&#39;delete&#39;, ArticleResource);\n&#125;);\n\n&#x2F;&#x2F; 验证权限\nconst userRole &#x3D; &#39;admin&#39;;\nconst userAbility &#x3D; new Ability([ability]);\nconst canCreateArticle &#x3D; userAbility.can(&#39;create&#39;, ArticleResource);\n\nconsole.log(canCreateArticle); &#x2F;&#x2F; 输出：true 或 false，表示用户是否有创建文章的权限\n\n在上述示例中，我们首先定义了一个名为 “Article” 的资源和一组操作。然后，我们定义了不同角色（guest、user、admin）以及与每个角色相关联的权限。接下来，我们使用 AbilityBuilder 创建了一个能力对象，并使用 can 方法定义了策略。最后，我们使用 Ability 类创建了用户的能力对象，并使用 can 方法验证用户是否具有创建文章的权限。\n这只是 CASL 的一个简单示例，您可以根据实际需求扩展和调整它。通过定义资源、操作、角色和策略，并使用 CASL 的验证方法，您可以轻松地实现基于能力的访问控制。详细的 CASL 文档可以在官方网站上找到，供您进一步学习和探索。\n使用 CASL 和 React 的完整示例以下是一个使用 CASL 和 React 的完整示例：\n首先，确保您已经安装了 @casl/react 和 @casl/ability：\nnpm install @casl&#x2F;react @casl&#x2F;ability\n\n接下来，让我们创建一个能力对象和一个简单的组件来演示 CASL 在 React 中的使用：\n&#x2F;&#x2F; App.js\n\nimport React from &#39;react&#39;;\nimport &#123; createContext &#125; from &#39;react&#39;;\nimport &#123; AbilityContext &#125; from &#39;@casl&#x2F;react&#39;;\nimport &#123; Ability, AbilityBuilder &#125; from &#39;@casl&#x2F;ability&#39;;\n\n&#x2F;&#x2F; 创建一个能力上下文\nconst AbilityContext &#x3D; createContext(ability);\n\n&#x2F;&#x2F; 定义资源和操作\nconst ArticleResource &#x3D; &#39;Article&#39;;\nconst ArticleActions &#x3D; [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;];\n\n&#x2F;&#x2F; 定义角色和权限\nconst roles &#x3D; &#123;\n  guest: [&#39;read&#39;],\n  user: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;],\n  admin: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;, &#39;delete&#39;],\n&#125;;\n\n&#x2F;&#x2F; &#x2F;&#x2F; 创建策略，这个没啥用，下面重写了\n&#x2F;&#x2F; const ability &#x3D; AbilityBuilder.define((can) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   can(&#39;read&#39;, ArticleResource);\n&#x2F;&#x2F;   can(&#39;create&#39;, ArticleResource);\n&#x2F;&#x2F;   can(&#39;update&#39;, ArticleResource);\n&#x2F;&#x2F;   can(&#39;delete&#39;, ArticleResource);\n&#x2F;&#x2F; &#125;);\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [userRole, setUserRole] &#x3D; useState(&#39;guest&#39;); &#x2F;&#x2F; 假设登录用户的角色是 &#39;guest&#39;\n\n  &#x2F;&#x2F; 创建能力对象并关联用户的角色权限\n  const ability &#x3D; new Ability(\n    AbilityBuilder.define((can) &#x3D;&gt; &#123;\n      const rolePermissions &#x3D; roles[userRole]; &#x2F;&#x2F; 角色转权限\n      if (rolePermissions) &#123;\n        rolePermissions.forEach((permission) &#x3D;&gt; &#123;\n          can(permission, &#39;Article&#39;);\n        &#125;);\n      &#125;\n    &#125;)\n  );\n  return (\n    &lt;AbilityContext.Provider value&#x3D;&#123;ability&#125;&gt;\n      &lt;ArticleList &#x2F;&gt;\n    &lt;&#x2F;AbilityContext.Provider&gt;\n  );\n&#125;;\n\nexport default App;\n\n在上面的代码中，我们首先创建了一个能力对象 ability，然后使用 createContext 函数创建了一个能力上下文 AbilityContext。接下来，我们定义了一个资源和一组操作，以及与角色相关联的权限。然后，我们使用 AbilityBuilder 创建了一个策略，定义了资源和操作之间的关系。\n在 App 组件中，我们将能力对象通过能力上下文提供器 &lt;AbilityContext.Provider&gt; 提供给子组件。在本例中，我们将 ArticleList 组件作为子组件。\n现在，让我们创建 ArticleList 组件，它将根据用户的能力显示不同的操作按钮：\n&#x2F;&#x2F; ArticleList.js\n\nimport React, &#123; useContext &#125; from &#39;react&#39;;\nimport &#123; AbilityContext &#125; from &#39;@casl&#x2F;react&#39;;\n\nconst ArticleList &#x3D; () &#x3D;&gt; &#123;\n  const ability &#x3D; useContext(AbilityContext);\n\n  const handleCreate &#x3D; () &#x3D;&gt; &#123;\n    if (ability.can(&#39;create&#39;, &#39;Article&#39;)) &#123;\n      &#x2F;&#x2F; 执行创建文章的逻辑\n      console.log(&#39;Creating article...&#39;);\n    &#125;\n  &#125;;\n\n  const handleDelete &#x3D; () &#x3D;&gt; &#123;\n    if (ability.can(&#39;delete&#39;, &#39;Article&#39;)) &#123;\n      &#x2F;&#x2F; 执行删除文章的逻辑\n      console.log(&#39;Deleting article...&#39;);\n    &#125;\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Article List&lt;&#x2F;h1&gt;\n      &lt;button onClick&#x3D;&#123;handleCreate&#125; disabled&#x3D;&#123;!ability.can(&#39;create&#39;, &#39;Article&#39;)&#125;&gt;\n        Create Article\n      &lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;handleDelete&#125; disabled&#x3D;&#123;!ability.can(&#39;delete&#39;, &#39;Article&#39;)&#125;&gt;\n        Delete Article\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nexport default ArticleList;\n\n在 ArticleList 组件中，我们使用 useContext 钩子从能力上下文中获取能力对象。然后，我们根据用户的能力决定是否显示\n看上去并没有比 if else 优雅CASL 是一个用于权限控制和访问控制的库，它旨在提供一种更加简洁、可读性更高的方式来定义和检查权限规则。CASL 的设计目标是让开发人员能够以一种声明式的方式描述权限规则，而不是通过复杂的 if-else 或 switch-case 来手动编写权限检查逻辑。\nCASL 提供了一种 DSL（领域专用语言），它允许您在代码中以自然的方式描述权限规则。这种声明式的语法使得代码更易于理解和维护。您可以定义角色、资源和操作，并使用 CASL 提供的方法进行权限检查。CASL 还提供了一些便利的方法和工具，使得权限控制逻辑更加简洁和灵活。\n相比之下，使用传统的 if-else 或 switch-case 来实现权限控制可能会导致代码冗长、难以理解和维护。当权限规则变得复杂时，if-else 或 switch-case 的嵌套会变得非常深，逻辑也会变得混乱。而 CASL 提供的声明式语法可以更好地组织和描述权限规则，使得代码更加清晰和可读。\n综上所述，CASL 通过提供一种声明式的权限控制方式，使得代码更加优雅、清晰和可维护。它简化了权限规则的定义和检查过程，并提供了便利的工具和方法来处理权限控制逻辑。这样，开发人员可以更专注于业务逻辑而不是权限控制的实现细节。\nability.can 和 ability.notcan 用来判断是不是有权限是的，您理解得正确。在 CASL 中，ability.can 和 ability.cannot 是用来判断当前用户是否具有某个权限的方法。\nability.can 方法接受三个参数：action（操作）、subject（资源）和可选的 field（字段）。它返回一个布尔值，表示当前用户是否有执行该操作的权限。\n示例用法：\nif (ability.can(&#39;create&#39;, &#39;Post&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户有创建 Post 的权限\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户没有创建 Post 的权限\n&#125;\n\nability.cannot 方法与 ability.can 相反，用于判断当前用户是否没有某个权限。它也接受三个参数，并返回一个布尔值。\n示例用法：\nif (ability.cannot(&#39;update&#39;, &#39;Post&#39;, &#39;title&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户没有更新 Post 的 title 字段的权限\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户有更新 Post 的 title 字段的权限\n&#125;\n\n通过使用 ability.can 和 ability.cannot 方法，您可以轻松地进行权限检查，并根据用户的权限执行相应的操作。这样，您可以在代码中清晰地表达权限控制逻辑，使代码更加可读和易于维护。\nfield 字段有什么用在 CASL 中，field 参数用于指定操作所涉及的资源的特定字段。它是可选的，用于在判断权限时进一步限制操作的范围。\n通过指定 field，您可以对资源的特定字段进行权限检查，而不仅仅是对整个资源的权限进行检查。这在某些场景下很有用，特别是当不同用户对同一资源的不同字段有不同的权限时。\n示例用法：\nif (ability.can(&#39;update&#39;, &#39;Post&#39;, &#39;title&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户有更新 Post 的 title 字段的权限\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户没有更新 Post 的 title 字段的权限\n&#125;\n\n在上述示例中，ability.can 方法检查当前用户是否具有更新 Post 资源的 title 字段的权限。如果用户有该权限，则执行相应的操作；否则，执行其他逻辑。\n通过使用 field 参数，您可以更细粒度地控制权限，并根据不同字段的权限进行相应的处理。这对于需要对资源的不同字段进行不同的权限控制的应用场景非常有用。\n关于 field 的完整示例以下是一个使用 CASL 的完整示例，其中涉及到 field 参数的使用：\n&#x2F;&#x2F; 导入 CASL 相关模块\nconst &#123; AbilityBuilder, Ability &#125; &#x3D; require(&#39;@casl&#x2F;ability&#39;);\n\n&#x2F;&#x2F; 定义角色权限规则\nconst roles &#x3D; &#123;\n  admin: [&#39;manage&#39;, &#39;read&#39;, &#39;create&#39;, &#39;update&#39;, &#39;delete&#39;],\n  editor: [&#39;read&#39;, &#39;create&#39;, &#39;update&#39;],\n  viewer: [&#39;read&#39;],\n&#125;;\n\n&#x2F;&#x2F; 定义用户权限\nconst userAbilities &#x3D; &#123;\n  admin: [&#39;User&#39;, &#39;Post&#39;],\n  editor: [&#39;Post&#39;],\n  viewer: [&#39;Post&#39;],\n&#125;;\n\n&#x2F;&#x2F; 创建权限实例\nconst ability &#x3D; new Ability();\n\n&#x2F;&#x2F; 构建角色权限规则\nconst &#123; can, rules &#125; &#x3D; AbilityBuilder.extract();\n\n&#x2F;&#x2F; 为不同角色分配权限规则\nfor (const role of Object.keys(roles)) &#123;\n  const permissions &#x3D; roles[role];\n  for (const resource of userAbilities[role]) &#123;\n    can(permissions, resource);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 将规则绑定到权限实例\nability.update(rules);\n\n&#x2F;&#x2F; 示例资源\nconst post &#x3D; &#123;\n  id: 1,\n  title: &#39;Sample Post&#39;,\n  content: &#39;This is a sample post&#39;,\n&#125;;\n\n&#x2F;&#x2F; 检查当前用户是否有更新 post 的 title 字段的权限\nif (ability.can(&#39;update&#39;, &#39;Post&#39;, &#39;title&#39;)) &#123;\n  &#x2F;&#x2F; 当前用户有更新 post 的 title 字段的权限\n  console.log(&#39;User has permission to update the title field of the post&#39;);\n&#125; else &#123;\n  &#x2F;&#x2F; 当前用户没有更新 post 的 title 字段的权限\n  console.log(&#39;User does not have permission to update the title field of the post&#39;);\n&#125;\n\n在上述示例中，我们定义了不同角色的权限规则和用户的权限。然后，我们根据角色权限规则构建了权限实例，并将其绑定到 ability 变量上。接下来，我们定义了一个示例资源 post，然后使用 ability.can 方法检查当前用户是否有更新 post 的 title 字段的权限。根据权限的结果，我们输出相应的消息。\n通过在 ability.can 方法中使用 field 参数，我们可以对资源的特定字段进行权限检查，从而更精细地控制用户的权限。这使得我们可以根据不同字段的权限执行不同的操作，确保应用程序的安全性和一致性。\n没看到 rules 的赋值操作？在上述示例中，AbilityBuilder.extract() 方法返回的对象中的 can 方法会自动更新 rules，而不需要显式的赋值操作。\n这里是示例代码中更新规则的具体部分：\nconst &#123; can, rules &#125; &#x3D; AbilityBuilder.extract();\n\n&#x2F;&#x2F; ... 角色权限规则的构建 ...\n\nability.update(rules);\n\n在这段代码中，can 方法会自动更新 rules，并将权限规则添加到 rules 中。然后，我们使用 ability.update(rules) 方法将规则绑定到 ability 实例，使其生效。\n所以，通过在循环中多次调用 can 方法，能够动态构建权限规则并自动更新 rules，最后将规则应用到 ability 实例中。\nrules 值是怎样的？在 CASL 中，rules 是一个包含所有权限规则的数组。每个权限规则由一个对象表示，该对象定义了资源类型、动作和条件。\n在上述示例中，rules 的值取决于为不同角色分配的权限规则。示例中的权限规则如下：\n[\n  &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n];\n\n这些规则定义了对 “Post” 和 “Comment” 资源的不同动作的访问权限。例如，第一个规则允许用户进行 “Post” 资源的创建、读取和更新操作，而第二个规则则要求用户是 “admin” 角色才能进行 “Post” 资源的删除操作。\n你可以根据实际需求和业务逻辑，添加、修改或删除规则来定义你的权限策略。\nrules 中各个字段是什么意思在 CASL 中，rules 数组中的每个对象表示一个权限规则，包含以下字段：\n\nsubject：规则适用的资源类型，通常是模型的名称或标识。例如，在示例中，”Post” 和 “Comment” 分别是资源类型。\nactions：规则允许的操作或动作。它是一个字符串数组，包含可以执行的操作。在示例中，”create”、”read”、”update” 和 “delete” 是允许的操作。\nconditions：规则的条件，用于限制执行操作的特定条件。它是一个对象，定义了对资源的访问限制。在示例中，”author” 字段用于限制只有 “admin” 角色可以执行删除操作。\n\n通过组合不同的资源类型、操作和条件，你可以定义丰富的权限规则来控制用户对资源的访问。\n需要注意的是，CASL 使用了类似 MongoDB 查询语法的条件语法，如 $in 操作符用于匹配数组中的任意值。你可以根据具体需求在条件中使用不同的操作符和条件逻辑来构建规则。\nCASL 是 23 种设计模式 中的哪种CASL（Capability-based Security Language）并不属于经典的 23 种设计模式中的任何一种。它是一种用于实现基于能力的安全性的库和语言。\n设计模式通常是指在软件开发中常见的解决问题的模式或范例，如单例模式、工厂模式、观察者模式等。而 CASL 是一个专注于安全性和权限控制的库，它提供了一种方便的方式来定义和管理访问控制规则。CASL 的设计目标是帮助开发者实现细粒度的访问控制，而不是遵循经典的设计模式。\n尽管 CASL 不是经典的设计模式之一，但它仍然是一个非常有用的工具，可以帮助开发者实现灵活的权限控制策略，并提供清晰的代码结构和语义。\nCASL 不是策略模式吗？抱歉，我之前的回答有误。CASL（Capability-based Security Language）可以被归类为策略模式（Strategy Pattern）的一种实现。\n策略模式是一种行为型设计模式，它允许在运行时根据不同的情况选择不同的算法或策略。在 CASL 中，你可以定义不同的规则（策略），并根据特定的条件选择要执行的规则。CASL 通过组合不同的资源类型、操作和条件，允许你灵活地定义和管理访问控制规则，实现了策略模式的概念。\n因此，你可以将 CASL 视为策略模式在权限控制领域的一种应用，它提供了一种优雅的方式来管理和应用不同的访问策略。通过定义规则和根据情况选择合适的策略，CASL 可以使你的代码更加模块化、可维护，并且具有灵活的权限控制能力。\nCan 组件源码CASL 的 Can 组件是通过 @casl/react 模块提供的，它是一个 React 组件，用于在 JSX 中进行条件渲染。\n由于 CASL 是一个开源项目，你可以在 CASL 的 GitHub 仓库中找到 @casl/react 模块的源代码。以下是 Can 组件的简化版源代码示例：\nimport React from &#39;react&#39;;\nimport &#123; AbilityContext &#125; from &#39;@casl&#x2F;react&#39;;\nimport &#123; check &#125; from &#39;@casl&#x2F;ability&#39;;\n\nconst Can &#x3D; (&#123; I, a, this: subject, children &#125;) &#x3D;&gt; &#123;\n  const ability &#x3D; React.useContext(AbilityContext);\n  const allowed &#x3D; check(ability, I, a, subject);\n\n  return allowed ? &lt;&gt;&#123;children&#125;&lt;&#x2F;&gt; : null;\n&#125;;\n\nexport default Can;\n\n在上述代码中，Can 组件接受以下参数：\n\nI：表示操作的动作（例如，’read’、’create’、’update’ 等）。\na：表示操作的实体（例如，’Article’、’User’ 等）。\nthis：表示操作的主体（即需要进行权限判断的对象）。\n\n在组件内部，我们使用 AbilityContext 来获取当前的权限对象，然后调用 CASL 的 check 方法来检查是否满足给定的权限条件。根据权限的判断结果，我们决定是否渲染 children。\n需要注意的是，上述示例为简化版的源代码，并不包含完整的错误处理和其他细节。实际使用时，你可能需要根据自己的需求进行适当的修改和定制。你可以在 CASL 的 GitHub 仓库中查看完整的 @casl/react 模块源代码：https://github.com/stalniy/casl/tree/master/packages/react\n真正的源码\nprivate _canRender(): boolean &#123;\n  const props: any &#x3D; this.props;\n  const subject &#x3D; props.of || props.a || props.an || props.this || props.on;\n  const can &#x3D; props.not ? &#39;cannot&#39; : &#39;can&#39;;\n\n  return props.ability[can](props.I || props.do, subject, props.field); &#x2F;&#x2F; 注意这里props.ability[can]是个函数\n&#125;\n\n从源码来看，CASL Can 组件内部会自动进行鉴权是的，CASL 的 Can 组件内部会自动进行鉴权。在源码中，Can 组件通过使用 AbilityContext 获取当前的权限对象，并使用 check 方法来判断是否满足给定的权限条件。\n具体而言，Can 组件会将传入的动作（I）、实体（a）和主体（this）作为参数传递给 check 方法，然后检查当前的权限对象是否允许执行该动作对应该实体的操作。如果满足权限条件，Can 组件会渲染其包裹的子组件；否则，它将返回 null，从而实现了在 JSX 中的条件渲染。\n因此，你可以在使用 Can 组件时，将需要进行鉴权的动作、实体和主体作为参数传递给组件，并根据权限的判断结果来决定是否渲染相应的内容。这样，CASL 的 Can 组件可以帮助你简化在 React 应用中的权限控制逻辑。\nability 从哪里传入的？在使用 CASL 的 Can 组件时，你需要将 Ability 对象传入组件中。Ability 对象定义了权限规则和逻辑，它决定了哪些操作可以被执行，哪些实体可以被访问。\n通常情况下，你可以在应用程序的某个地方创建和管理 Ability 对象，并将其传递给需要使用权限验证的组件。这可以在应用程序的根组件或者某个上下文提供者中完成。\n下面是一个示例，展示了如何在 React 中使用 CASL 的 Can 组件，并将 Ability 对象传递给组件：\nimport &#123; createContext, useContext &#125; from &#39;react&#39;;\nimport &#123; AbilityBuilder, Ability &#125; from &#39;@casl&#x2F;ability&#39;;\n\n&#x2F;&#x2F; 创建 Ability 对象\nconst ability &#x3D; new Ability([], &#123;\n  &#x2F;* ... *&#x2F;\n&#125;);\n\n&#x2F;&#x2F; 创建上下文\nconst AbilityContext &#x3D; createContext(ability);\n\n&#x2F;&#x2F; 创建一个自定义 Hook，用于在组件中获取 Ability 对象\nfunction useAbility() &#123;\n  return useContext(AbilityContext);\n&#125;\n\n&#x2F;&#x2F; 在应用程序的根组件中提供 Ability 对象\nfunction App() &#123;\n  &#x2F;&#x2F; &#x2F;&#x2F; prettier-ignore\n  return (\n    &lt;AbilityContext.Provider value&#x3D;&#123;ability&#125;&gt;\n      &#123;&#x2F;*ability 这里传入的 *&#x2F;&#125;\n\n      &#123;&#x2F;* 应用程序的其他组件 *&#x2F;&#125;\n    &lt;&#x2F;AbilityContext.Provider&gt;\n  );\n&#125;\n\n&#x2F;&#x2F; 在具体的组件中使用 Can 组件\nfunction MyComponent() &#123;\n  const ability &#x3D; useAbility();\n\n  return (\n    &lt;Can I&#x3D;&quot;edit&quot; a&#x3D;&quot;Post&quot; this&#x3D;&#123;post&#125;&gt;\n      &lt;button&gt;Edit Post&lt;&#x2F;button&gt;\n    &lt;&#x2F;Can&gt;\n  );\n&#125;\n\n在上述示例中，我们首先创建了一个 Ability 对象 ability，然后使用 createContext 函数创建了一个上下文 AbilityContext。接下来，我们定义了一个自定义的 Hook useAbility，用于在组件中获取 Ability 对象。在应用程序的根组件 App 中，我们将 ability 对象通过 AbilityContext.Provider 提供给其他组件。最后，在具体的组件 MyComponent 中，我们使用了 Can 组件来进行权限验证，并通过 useAbility Hook 获取了 Ability 对象。\n通过这种方式，你可以在应用程序中的任何组件中使用 Can 组件，并且能够共享同一个 Ability 对象，实现统一的权限验证。\nability 的结果rules 为\n[\n  &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n  &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n];\n\n根据你提供的 rules 值和示例代码构建的 ability 对象，其结果如下：\nconst ability &#x3D; &#123;\n  rules: [\n    &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  ],\n  can: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否有权限\n    &#x2F;&#x2F; 返回布尔值表示是否具有权限\n  &#125;,\n  cannot: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否没有权限\n    &#x2F;&#x2F; 返回布尔值表示是否不具有权限\n  &#125;,\n&#125;;\n\n上述代码展示了一个简化的 ability 对象，包含了 rules、can 和 cannot 方法。根据提供的 rules 数组，can 方法用于判断用户是否具有指定的操作权限，而 cannot 方法用于判断用户是否没有指定的操作权限。具体的权限判断逻辑需要根据你的应用程序需求进行实现。\n上述代码 ability.can 和 ability.cannot 的具体内容根据你提供的 rules 值和示例代码构建的 ability 对象，ability.can 和 ability.cannot 的具体内容如下：\nconst ability &#x3D; &#123;\n  rules: [\n    &#123; subject: &#39;Post&#39;, actions: [&#39;create&#39;, &#39;read&#39;, &#39;update&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Post&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;create&#39;], conditions: &#123;&#125; &#125;,\n    &#123; subject: &#39;Comment&#39;, actions: [&#39;delete&#39;], conditions: &#123; author: &#123; $in: [&#39;admin&#39;] &#125; &#125; &#125;,\n  ],\n  can: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否有权限\n    &#x2F;&#x2F; 返回布尔值表示是否具有权限\n    const matchedRule &#x3D; ability.rules.find(\n      (rule) &#x3D;&gt; rule.subject &#x3D;&#x3D;&#x3D; subject &amp;&amp; rule.actions.includes(action) &amp;&amp; ability._matchesConditions(rule.conditions, field)\n    );\n    return !!matchedRule;\n  &#125;,\n  cannot: (action, subject, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 根据规则判断是否没有权限\n    &#x2F;&#x2F; 返回布尔值表示是否不具有权限\n    return !ability.can(action, subject, field);\n  &#125;,\n  _matchesConditions: (conditions, field) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 判断条件是否匹配\n    &#x2F;&#x2F; 根据实际情况进行具体实现\n  &#125;,\n&#125;;\n\n在 can 方法中，我们遍历 rules 数组，根据传入的操作 action、主体 subject 和字段 field 进行匹配，同时调用 _matchesConditions 方法判断条件是否满足。如果找到匹配的规则，表示具有权限，返回 true，否则返回 false。\n在 cannot 方法中，我们直接调用 can 方法判断是否具有权限，并返回其相反值，即表示没有权限。\n_matchesConditions 方法用于根据实际的条件判断逻辑来判断条件是否满足。这个方法需要根据你的应用程序需求进行具体实现，判断条件是否满足可以涉及字段值的比较、逻辑运算等操作。\n代码用设计模式往往比不用设计模式，更难理解确实，在应用设计模式时，代码可能会更加抽象和复杂，因此阅读和理解代码的难度可能会增加。设计模式的目的是提供一种灵活、可扩展且易于维护的代码结构，以解决特定的问题或满足特定的需求。但是，设计模式并不是适用于所有情况的银弹，有时候简单的解决方案可能更为合适。\n尽管使用设计模式可能增加代码的复杂性，但它们在长期和大型项目中可以带来许多优势。设计模式可以提高代码的可读性、可维护性和可扩展性，并促进团队合作和代码重用。此外，使用设计模式可以帮助开发人员遵循行业标准和最佳实践，从而提高代码质量和可靠性。\n理解和应用设计模式需要一定的学习和实践，一开始可能会感到困惑，但随着经验的积累，你将能够更好地理解和应用它们。此外，编写清晰、注释良好的代码以及提供适当的文档和示例可以帮助其他开发人员更容易地理解和使用设计模式。\n总而言之，设计模式是一种工具，用于解决特定的问题和提高代码质量。使用设计模式时需要权衡其带来的复杂性和优势，并根据具体情况做出适当的选择。在团队合作和大型项目中，良好的代码组织和结构是非常重要的，设计模式可以成为实现这一目标的有力工具之一。\n拦截器（AOP）简化后\nAOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，用于将横切关注点与核心业务逻辑分离，提高代码的模块化和可维护性。通过定义切面来封装横切关注点的逻辑，并在特定的连接点上应用切面，实现横切逻辑的自动执行。AOP 可以帮助解决重复代码和耦合问题，提高代码的可重用性和可维护性。\n未简化\nAOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，用于通过将横切关注点（cross-cutting concerns）与核心业务逻辑分离来提高代码的模块化和可维护性。\n在传统的面向对象编程中，核心业务逻辑往往散布在多个类和方法中，同时还存在一些与核心业务逻辑相关但又与之无关的横切关注点，如日志记录、性能监测、事务管理等。这些横切关注点会导致代码的重复和耦合，使得代码难以理解、调试和维护。\nAOP 通过将这些横切关注点抽象为切面（Aspect），并将其与核心业务逻辑分离，实现了横切关注点的模块化。切面定义了在何时、何地以及如何执行横切关注点的逻辑，而核心业务逻辑则可以专注于自身的功能实现。\n在 AOP 中，切面通过特定的方式（如注解或配置）与目标对象的方法进行绑定，当目标对象的方法被调用时，切面的逻辑就会被自动触发。切面可以在方法执行前、执行后或异常抛出时执行特定的逻辑，如记录日志、进行权限验证、进行性能监测等。\nAOP 常用的概念和术语包括：\n\n切面（Aspect）：封装了与横切关注点相关的逻辑。\n连接点（Join Point）：在程序执行过程中可以插入切面的特定点，如方法调用、方法执行等。\n切点（Pointcut）：指定了在哪些连接点上应用切面逻辑。\n通知（Advice）：切面在连接点上执行的具体逻辑，包括前置通知、后置通知、异常通知等。\n织入（Weaving）：将切面应用到目标对象的过程。\n\nAOP 可以帮助我们解决一些横切关注点带来的重复代码和耦合问题，提高代码的可重用性和可维护性。它在许多框架和编程语言中得到了广泛应用，如 Spring 框架中的 AOP、AspectJ 等。\n需要注意的是，AOP 并不是适用于所有场景的解决方案，需要根据具体的业务需求和项目特点来决定是否使用 AOP。在某些情况下，使用 AOP 可能会增加代码的复杂性和理解难度，因此需要权衡利弊并合理使用。\n切面编程中使用到哪些设计模式在切面编程中，常用的设计模式包括：\n\n代理模式（Proxy Pattern）：用于创建切面的代理对象，将横切逻辑织入到目标对象中。\n装饰器模式（Decorator Pattern）：用于动态地给对象添加额外的功能或行为，可以在切面中通过装饰器模式来实现横切逻辑的添加。\n观察者模式（Observer Pattern）：用于实现切面和目标对象之间的通信，切面可以观察目标对象的状态变化并做出相应的处理。\n模板方法模式（Template Method Pattern）：用于定义切面的执行流程和顺序，可以在切面中定义模板方法，并由子类实现具体的切面逻辑。\n工厂模式（Factory Pattern）：用于创建切面对象的工厂，可以根据不同的切面类型来创建相应的切面对象。\n\n这些设计模式可以在切面编程中帮助实现横切逻辑的管理、织入和执行，提供了灵活和可扩展的方式来处理横切关注点。\nnestjs 中间件、守卫、过滤器、管道看上去都是切面编程？是的，NestJS 中间件、守卫、过滤器、管道都属于切面编程的范畴。它们都可以在请求处理的不同阶段对请求进行拦截或处理，从而实现各种切面逻辑，如日志记录、权限验证、数据校验等。在 NestJS 中，中间件、守卫、过滤器、管道各自的应用场景和实现方式有所不同，但它们都可以被视为切面编程的实现方式之一。\n过滤器和拦截器有什么区别？过滤器（Filters）和拦截器（Interceptors）在 NestJS 中都用于对请求进行拦截和处理，但它们的作用和使用方式有一些区别。\n过滤器（Filters）主要用于在处理请求的不同阶段对请求进行过滤和转换。它可以在请求处理之前、之后或异常处理阶段对请求进行拦截，并对请求的数据进行处理、转换或过滤。过滤器通常用于实现一些与请求相关的全局逻辑，例如日志记录、错误处理、数据转换等。\n拦截器（Interceptors）则更加通用且灵活，它可以在请求处理的各个阶段对请求进行拦截，并对请求进行修改、记录日志、添加额外的功能等。拦截器可以对请求的参数、响应结果、异常进行处理，也可以在请求之前或之后执行额外的逻辑。拦截器可以针对具体的控制器或路由进行设置，也可以应用于全局。\n总体而言，\n\n过滤器更加关注对请求的预处理和后处理，通常用于实现一些通用的全局逻辑；\n而拦截器则更加灵活，可用于在请求的各个阶段进行拦截和处理，包括对请求参数、响应结果和异常的处理，也可以应用于具体的控制器或路由。\n\n需要根据具体的场景和需求选择使用过滤器还是拦截器，或者两者结合使用。\n过滤器通常是通过实现 ExceptionFilter、Interceptor 或 PipeTransform 接口来定义，而拦截器则是通过实现 Interceptor 接口来定义， 那么过滤器和拦截器两个之间有什么关系过滤器（Filters）和拦截器（Interceptors）在 NestJS 中都用于对请求进行拦截和处理，但它们在实现和应用上有一些不同。\n在 NestJS 中，过滤器过滤器通常是通过实现 ExceptionFilter、Interceptor 或 PipeTransform 接口来定义。它们可以用于对请求的参数、响应结果或异常进行过滤、转换和处理。过滤器可以应用于整个请求流程，可以捕获异常、记录日志、处理错误等。过滤器的定义是更为通用的，可以应用于不同的场景和请求处理阶段。拦截器拦截器则是通过实现 Interceptor 接口来定义。它们可以在请求的不同阶段对请求进行拦截，并对请求进行修改、记录日志、添加额外的功能等。拦截器可以应用于整个请求流程，包括请求之前、请求处理过程中和请求之后。拦截器的定义相对更加专注于对请求的拦截和处理。\n在关系上，可以将拦截器视为一种特殊类型的过滤器。拦截器提供了更精细的请求拦截和处理能力，而过滤器则更为通用，可以应用于不同的场景和请求处理阶段。在实践中，可以根据具体的需求和场景选择使用过滤器还是拦截器，或者将它们结合使用以实现更复杂的请求处理逻辑。\n模版静态模版示例添加注解就可以了\nimport &#123; Get, Controller, Render &#125; from &#39;@nestjs&#x2F;common&#39;;\n\n@Controller()\nexport class AppController &#123;\n  @Get()\n  @Render(&#39;index&#39;)\n  root() &#123;\n    return &#123; message: &#39;Hello world!&#39; &#125;;\n  &#125;\n&#125;\n\n动态模版示例在 NestJS 中，res.render 方法并不直接提供，因为 NestJS 本身并不是一个传统的 Web 框架，它更专注于构建可扩展的服务器应用程序。\n如果你想在 NestJS 中实现类似于传统 Web 框架中的 res.render 的功能，可以使用模板引擎相关的库或模块。常用的模板引擎库包括 Handlebars、EJS、Pug（以前称为 Jade）等。\n以下是使用 Handlebars 模板引擎进行动态模板渲染的示例：\n\n安装 Handlebars 模板引擎和相关的依赖：\n\nnpm install handlebars hbs\n\n\n在模块中导入 Handlebars 模块和相关的服务：\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; HbsRenderer &#125; from &#39;.&#x2F;hbs.renderer&#39;;\n\n@Module(&#123;\n  providers: [HbsRenderer],\n  exports: [HbsRenderer],\n&#125;)\nexport class AppModule &#123;&#125;\n\n\n创建一个名为 hbs.renderer.ts 的文件，定义 HbsRenderer 类，用于处理模板渲染：\n\nimport &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport * as handlebars from &#39;handlebars&#39;;\nimport * as fs from &#39;fs&#39;;\n\n@Injectable()\nexport class HbsRenderer &#123;\n  render(template: string, data: any): string &#123;\n    const templateFile &#x3D; fs.readFileSync(&#96;path&#x2F;to&#x2F;templates&#x2F;$&#123;template&#125;.hbs&#96;, &#39;utf-8&#39;);\n    const compiledTemplate &#x3D; handlebars.compile(templateFile);\n    return compiledTemplate(data);\n  &#125;\n&#125;\n\n在上述示例中，我们使用 handlebars 模块加载模板文件，并编译模板，然后使用提供的数据进行渲染。\n\n在控制器中使用 HbsRenderer 进行模板渲染：\n\nimport &#123; Controller, Get, Render &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; HbsRenderer &#125; from &#39;.&#x2F;hbs.renderer&#39;;\n\n@Controller(&#39;example&#39;)\nexport class ExampleController &#123;\n  constructor(private readonly hbsRenderer: HbsRenderer) &#123;&#125;\n\n  @Get()\n  async example() &#123;\n    const data &#x3D; &#123; title: &#39;NestJS Example&#39;, message: &#39;Hello, World!&#39; &#125;;\n    const renderedTemplate &#x3D; this.hbsRenderer.render(&#39;example&#39;, data);\n    return renderedTemplate;\n  &#125;\n&#125;\n\n在上述示例中，我们在控制器中注入了 HbsRenderer，然后使用它的 render 方法进行模板渲染。\n需要注意的是，NestJS 的核心概念是处理请求和响应，它不直接提供模板渲染功能。所以在使用模板引擎时，你需要自己创建一个服务或类来处理模板渲染，然后在控制器中使用这个服务来实现模板渲染的功能。\n返回值剔除&#x2F;增加字段拦截ClassSerializerInterceptor + class-transformer\n\n@Exclude()\n@Expose()\n@Transform\n\nclass-transformer @Transform 示例class-transformer 是一个在 TypeScript 中进行对象转换的库，它提供了 @Transform 装饰器用于对属性进行转换操作。下面是一个使用 class-transformer 的示例：\n首先，确保已安装 class-transformer 和 reflect-metadata 依赖：\nnpm install class-transformer reflect-metadata\n\n然后，在要进行转换的类中使用 @Transform 装饰器：\nimport &#123; Transform, Type &#125; from &#39;class-transformer&#39;;\n\nclass User &#123;\n  @Transform((value) &#x3D;&gt; value.toUpperCase())\n  username: string;\n\n  @Type(() &#x3D;&gt; Date)\n  @Transform((value) &#x3D;&gt; new Date(value))\n  createdAt: Date;\n&#125;\n\nconst user &#x3D; new User();\nuser.username &#x3D; &#39;john&#39;;\nuser.createdAt &#x3D; &#39;2023-01-01&#39;;\n\nconst transformedUser &#x3D; plainToClass(User, user);\nconsole.log(transformedUser);\n\n在上述示例中，我们定义了一个 User 类，它有两个属性：username 和 createdAt。我们使用 @Transform 装饰器对这两个属性进行转换操作。\n对于 username 属性，我们使用一个转换函数 value =&gt; value.toUpperCase() 将用户名转换为大写。\n对于 createdAt 属性，我们使用 @Type(() =&gt; Date) 声明属性类型为 Date，并使用一个转换函数 value =&gt; new Date(value) 将传入的日期字符串转换为 Date 对象。\n最后，我们使用 plainToClass 函数将普通对象转换为 User 类的实例，并输出转换后的对象。\n注意，在使用 class-transformer 进行转换时，需要确保在项目的入口文件中引入 reflect-metadata：\nimport &#39;reflect-metadata&#39;;\n\n这是因为 class-transformer 使用了 TypeScript 的装饰器和元数据机制，需要 reflect-metadata 库的支持。\n版本控制用于移动端较多，移动客户端更新不及时\n\nurl 版本就这个常用\nheader 字段\nmediatype\n自定义\n\n调度nestjs axios 示例在 NestJS 中使用 Axios 可以通过创建一个自定义的 Axios Service 来实现。下面是一个简单的示例：\n首先，确保已安装 axios 和 @nestjs/axios 依赖：\nnpm install axios @nestjs&#x2F;axios\n\n然后，创建一个 AxiosService 来封装 Axios 请求：\nimport &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; HttpService, InjectHttpService &#125; from &#39;@nestjs&#x2F;axios&#39;;\nimport &#123; AxiosRequestConfig &#125; from &#39;axios&#39;;\nimport &#123; Observable &#125; from &#39;rxjs&#39;;\n\n@Injectable()\nexport class AxiosService &#123;\n  constructor(@InjectHttpService() private readonly httpService: HttpService) &#123;&#125;\n\n  get&lt;T&gt;(url: string, config?: AxiosRequestConfig): Observable&lt;T&gt; &#123;\n    return this.httpService.get&lt;T&gt;(url, config).pipe(map((response) &#x3D;&gt; response.data));\n  &#125;\n\n  post&lt;T&gt;(url: string, data?: any, config?: AxiosRequestConfig): Observable&lt;T&gt; &#123;\n    return this.httpService.post&lt;T&gt;(url, data, config).pipe(map((response) &#x3D;&gt; response.data));\n  &#125;\n\n  &#x2F;&#x2F; 添加其他 HTTP 方法的封装，如 put、delete 等\n&#125;\n\n在上述示例中，我们创建了一个 AxiosService，它使用 @nestjs/axios 提供的 HttpService 进行 HTTP 请求。通过在构造函数中注入 HttpService，我们可以在 AxiosService 中使用它来发起请求。\nAxiosService 中定义了几个常用的方法，如 get 和 post，它们分别对应 GET 和 POST 请求。这些方法使用了 RxJS 的 Observable，并使用 map 操作符从响应中提取出数据。\n现在，我们可以在其他模块或服务中注入 AxiosService 来使用它发送请求。例如，在一个控制器中：\nimport &#123; Controller, Get &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; AxiosService &#125; from &#39;.&#x2F;axios.service&#39;;\n\n@Controller(&#39;example&#39;)\nexport class ExampleController &#123;\n  constructor(private readonly axiosService: AxiosService) &#123;&#125;\n\n  @Get()\n  async getExampleData() &#123;\n    const response &#x3D; await this.axiosService.get(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;);\n    return response;\n  &#125;\n&#125;\n\n在上述示例中，我们在 ExampleController 中注入了 AxiosService，并使用它发送了一个 GET 请求。返回的响应数据将作为 API 的返回值。\n通过封装 Axios 请求的 AxiosService，我们可以更方便地使用 Axios 发起 HTTP 请求，并且可以在 NestJS 中享受到依赖注入和模块化开发的好处。\nObservable 与 Promise 是什么关系？Observable 和 Promise 都是用于处理异步操作的概念，但它们在使用方式和功能上有一些区别。\nPromise 是 JavaScript 原生提供的一种处理异步操作的方式。它表示一个异步操作的最终完成或失败，并可以通过链式调用 .then() 和 .catch() 来处理操作的结果。Promise 的特点是只能处理一次异步操作，并且结果是单值的，即成功或失败。\nObservable 是 RxJS 库提供的概念，它也用于处理异步操作，但具有更强大的功能和灵活性。Observable 可以表示一个异步数据流，可以发出多个值，也可以发出错误或完成信号。通过使用 Observable，我们可以对数据流进行各种操作，如映射、过滤、合并等，以及使用操作符来处理异步事件的时间窗口、并发等情况。Observable 提供了一种响应式编程的模型，可以更方便地处理复杂的异步场景。\n虽然 Promise 和 Observable 都可以用于处理异步操作，但它们的使用场景有所不同。Promise 更适合处理单次异步操作，例如获取远程数据或执行一个异步任务，并且对结果只关心成功或失败。Observable 则更适合处理连续的异步数据流，例如实时数据更新、事件流等，以及需要对数据进行多次操作和处理的情况。\n在 NestJS 中，默认使用的是基于 Promise 的异步操作，但也可以通过引入 RxJS 库来使用 Observable 来处理异步数据流。\n配置多环境配置文件 示例在 NestJS 中，可以使用不同的配置文件来实现多环境配置。以下是一个示例：\n\n创建配置文件：\n\ndevelopment.env: 开发环境配置\nproduction.env: 生产环境配置\n\n\n在每个配置文件中定义相应的配置项。例如，可以定义数据库连接、端口号等配置项。\n\n\ndevelopment.env 文件内容：\nDB_HOST&#x3D;localhost\nDB_PORT&#x3D;5432\nDB_NAME&#x3D;development_db\nPORT&#x3D;3000\n\nproduction.env 文件内容：\nDB_HOST&#x3D;prod-host\nDB_PORT&#x3D;5432\nDB_NAME&#x3D;production_db\nPORT&#x3D;8080\n\n\n安装 @nestjs/config 模块：\n\nnpm install @nestjs&#x2F;config\n\n\n在应用程序的根模块中加载配置：\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ConfigModule &#125; from &#39;@nestjs&#x2F;config&#39;;\n\n@Module(&#123;\n  imports: [\n    ConfigModule.forRoot(&#123;\n      isGlobal: true, &#x2F;&#x2F; 将配置模块全局导入\n    &#125;),\n  ],\n&#125;)\nexport class AppModule &#123;&#125;\n\n\n在需要使用配置的地方，通过 ConfigService 获取配置项的值：\n\nimport &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ConfigService &#125; from &#39;@nestjs&#x2F;config&#39;;\n\n@Injectable()\nexport class AppService &#123;\n  constructor(private configService: ConfigService) &#123;&#125;\n\n  getDatabaseConfig(): any &#123;\n    const host &#x3D; this.configService.get&lt;string&gt;(&#39;DB_HOST&#39;);\n    const port &#x3D; this.configService.get&lt;number&gt;(&#39;DB_PORT&#39;);\n    const dbName &#x3D; this.configService.get&lt;string&gt;(&#39;DB_NAME&#39;);\n\n    return &#123; host, port, dbName &#125;;\n  &#125;\n\n  getPort(): number &#123;\n    return this.configService.get&lt;number&gt;(&#39;PORT&#39;);\n  &#125;\n&#125;\n\n在开发环境中，NestJS 会自动加载 development.env 配置文件；在生产环境中，会加载 production.env 配置文件。然后，可以通过 ConfigService 来获取配置项的值，并在应用程序的其他地方使用。\n请注意，以上示例是基于 @nestjs/config 模块的配置方式。你也可以使用其他配置模块或自定义方式来加载和管理多环境配置。\nYAML 文件来实现多环境配置以下是一个示例，展示了如何使用 YAML 文件来实现多环境配置：\n\n创建不同环境的配置文件：\n\ndevelopment.yml: 开发环境配置\nproduction.yml: 生产环境配置\n\n\n在每个配置文件中定义相应的配置项。例如，可以定义数据库连接、端口号等配置项。\n\n\ndevelopment.yml 文件内容：\nDB_HOST: localhost\nDB_PORT: 5432\nDB_NAME: development_db\nPORT: 3000\n\nproduction.yml 文件内容：\nDB_HOST: prod-host\nDB_PORT: 5432\nDB_NAME: production_db\nPORT: 8080\n\n\n安装 js-yaml 模块：\n\nnpm install js-yaml\n\n\n创建一个配置服务类，用于加载和解析配置文件：\n\nimport * as yaml from &#39;js-yaml&#39;;\nimport * as fs from &#39;fs&#39;;\n\n@Injectable()\nexport class ConfigService &#123;\n  private readonly config: Record&lt;string, any&gt;;\n\n  constructor() &#123;\n    const env &#x3D; process.env.NODE_ENV || &#39;development&#39;;\n    const configFile &#x3D; fs.readFileSync(&#96;$&#123;env&#125;.yml&#96;, &#39;utf8&#39;);\n    this.config &#x3D; yaml.load(configFile);\n  &#125;\n\n  get(key: string): any &#123;\n    return this.config[key];\n  &#125;\n&#125;\n\n\n在需要使用配置的地方，通过 ConfigService 获取配置项的值：\n\nimport &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ConfigService &#125; from &#39;.&#x2F;config.service&#39;;\n\n@Injectable()\nexport class AppService &#123;\n  constructor(private configService: ConfigService) &#123;&#125;\n\n  getDatabaseConfig(): any &#123;\n    const host &#x3D; this.configService.get(&#39;DB_HOST&#39;);\n    const port &#x3D; this.configService.get(&#39;DB_PORT&#39;);\n    const dbName &#x3D; this.configService.get(&#39;DB_NAME&#39;);\n\n    return &#123; host, port, dbName &#125;;\n  &#125;\n\n  getPort(): number &#123;\n    return this.configService.get(&#39;PORT&#39;);\n  &#125;\n&#125;\n\n在开发环境中，加载的是 development.yml 文件的配置；在生产环境中，加载的是 production.yml 文件的配置。然后，可以通过 ConfigService 来获取配置项的值，并在应用程序的其他地方使用。\n请注意，以上示例是一种自定义的方式来加载和解析 YAML 配置文件。你也可以使用其他 YAML 解析库或配置模块来实现类似的功能。\n压缩压缩可以大大减小响应主体的大小，从而提高 Web 应用程序的速度。\n对于生产中的高流量网站，强烈建议从应用程序服务器卸载压缩 - 通常在反向代理（例如 Nginx）中。在那种情况下，您不应该使用压缩中间件\n文件上传单文件上传在 NestJS 中实现文件上传可以使用 multer 模块。下面是一个简单的示例：\n\n安装 multer 模块：\n\nnpm install @nestjs&#x2F;platform-express multer\n\n\n创建一个上传文件的控制器：\n\nimport &#123; Controller, Post, UseInterceptors, UploadedFile &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  uploadFile(@UploadedFile() file: Express.Multer.File) &#123;\n    &#x2F;&#x2F; 处理上传的文件，可以保存到磁盘或执行其他操作\n    console.log(file);\n\n    &#x2F;&#x2F; 返回响应\n    return &#123; message: &#39;File uploaded successfully&#39; &#125;;\n  &#125;\n&#125;\n\n\n在模块中引入 FilesController：\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesController &#125; from &#39;.&#x2F;files.controller&#39;;\n\n@Module(&#123;\n  controllers: [FilesController],\n&#125;)\nexport class FilesModule &#123;&#125;\n\n\n在根模块或其他子模块中导入 FilesModule：\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesModule &#125; from &#39;.&#x2F;files&#x2F;files.module&#39;;\n\n@Module(&#123;\n  imports: [FilesModule],\n&#125;)\nexport class AppModule &#123;&#125;\n\n现在，你可以使用任何 HTTP 客户端发送带有 file 字段的 multipart/form-data 请求到 POST /files/upload 路由，以上传文件。在控制器的 uploadFile 方法中，你可以处理上传的文件，例如保存到磁盘或执行其他自定义逻辑。\n这只是一个简单的示例，你可以根据实际需求进行更多的自定义配置，例如限制文件大小、允许的文件类型等。请查阅 multer 文档以获取更多详细信息和配置选项。\n多文件上传在 NestJS 中实现多文件上传，可以使用 multer 模块结合 @UseInterceptors() 装饰器来处理。\n下面是一个示例，展示如何实现多文件上传：\n\n安装 multer 模块：\n\nnpm install @nestjs&#x2F;platform-express multer\n\n\n创建一个上传文件的控制器：\n\nimport &#123; Controller, Post, UseInterceptors, UploadedFiles &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FilesInterceptor(&#39;files&#39;))\n  uploadFiles(@UploadedFiles() files: Express.Multer.File[]) &#123;\n    &#x2F;&#x2F; 处理上传的文件，可以保存到磁盘或执行其他操作\n    console.log(files);\n\n    &#x2F;&#x2F; 返回响应\n    return &#123; message: &#39;Files uploaded successfully&#39; &#125;;\n  &#125;\n&#125;\n\n\n在模块中引入 FilesController：\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesController &#125; from &#39;.&#x2F;files.controller&#39;;\n\n@Module(&#123;\n  controllers: [FilesController],\n&#125;)\nexport class FilesModule &#123;&#125;\n\n\n在根模块或其他子模块中导入 FilesModule：\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FilesModule &#125; from &#39;.&#x2F;files&#x2F;files.module&#39;;\n\n@Module(&#123;\n  imports: [FilesModule],\n&#125;)\nexport class AppModule &#123;&#125;\n\n现在，你可以使用任何支持多文件上传的 HTTP 客户端发送带有 files 字段的 multipart/form-data 请求到 POST /files/upload 路由，以上传多个文件。在控制器的 uploadFiles 方法中，你可以处理上传的文件数组，例如保存到磁盘或执行其他自定义逻辑。\n请注意，@UseInterceptors(FilesInterceptor(&#39;files&#39;)) 中的 &#39;files&#39; 参数指定了接收文件的字段名，你可以根据实际需求进行更改。\n这只是一个简单的示例，你可以根据实际需求进行更多的自定义配置，例如限制文件大小、允许的文件类型等。请查阅 multer 文档以获取更多详细信息和配置选项。\nDTO 验证文件大小&#x2F;类型在 NestJS 中，你可以使用 class-validator 和 class-transformer 模块结合自定义验证器来验证上传文件的大小和类型。\n以下是一个示例，展示如何在 NestJS 中验证上传文件的大小和类型：\n\n首先，安装所需的依赖模块：\n\nnpm install class-validator class-transformer\n\n\n创建一个自定义验证器来验证文件的大小和类型：\n\nimport &#123; Injectable &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments &#125; from &#39;class-validator&#39;;\n\n@ValidatorConstraint(&#123; name: &#39;file&#39;, async: false &#125;)\n@Injectable()\nexport class FileValidator implements ValidatorConstraintInterface &#123;\n  validate(value: Express.Multer.File, args: ValidationArguments) &#123;\n    const &#123; maxSize, allowedTypes &#125; &#x3D; args.constraints[0];\n    if (maxSize &amp;&amp; value.size &gt; maxSize) &#123;\n      return false; &#x2F;&#x2F; 文件大小超过最大限制\n    &#125;\n    if (allowedTypes &amp;&amp; !allowedTypes.includes(value.mimetype)) &#123;\n      return false; &#x2F;&#x2F; 文件类型不被允许\n    &#125;\n    return true;\n  &#125;\n\n  defaultMessage(args: ValidationArguments) &#123;\n    return &#39;Invalid file&#39;; &#x2F;&#x2F; 验证失败时的默认错误消息\n  &#125;\n&#125;\n\n\n在上传文件的 DTO 类中应用验证器：\n\nimport &#123; IsDefined, Validate &#125; from &#39;class-validator&#39;;\nimport &#123; FileValidator &#125; from &#39;.&#x2F;file.validator&#39;;\n\nexport class UploadFileDto &#123;\n  @IsDefined()\n  @Validate(FileValidator, &#123; maxSize: 10 * 1024 * 1024, allowedTypes: [&#39;image&#x2F;jpeg&#39;, &#39;image&#x2F;png&#39;] &#125;)\n  file: Express.Multer.File;\n&#125;\n\n在上述代码中，UploadFileDto 类使用 @Validate() 装饰器来应用自定义的 FileValidator 验证器。你可以通过传递约束选项对象来配置验证器，例如 maxSize（文件大小限制）和 allowedTypes（允许的文件类型）。\n\n在控制器中使用验证器：\n\nimport &#123; Controller, Post, UploadedFile, UseInterceptors &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\nimport &#123; UploadFileDto &#125; from &#39;.&#x2F;upload-file.dto&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  async uploadFile(@UploadedFile() uploadFileDto: UploadFileDto) &#123;\n    &#x2F;&#x2F; 处理上传的文件\n  &#125;\n&#125;\n\n在上述代码中，我们使用 @UseInterceptors() 装饰器将 FileInterceptor 应用于控制器方法。FileInterceptor 会处理文件上传并将文件保存到指定位置。然后，我们可以在方法参数中使用 @UploadedFile() 装饰器来获取上传的文件对象。\n通过在 DTO 类中应用验证器，NestJS 会在控制器方法执行之前自动验证上传的文件，如果验证失败，会抛出异常并返回相应的错误响应。\n示例中，我们将 @UploadedFile() 装饰器应用于 uploadFileDto 参数，该参数的类型是 UploadFileDto。这样，NestJS 将会在控制器方法执行之前自动验证 uploadFileDto 中的文件对象，并抛出相应的异常，如果验证通过，将会将文件对象赋值给 uploadFileDto 参数。\n在 UploadFileDto 类中定义的验证逻辑仍然有效，通过在控制器方法的参数中使用 UploadFileDto 类型，NestJS 将会自动应用验证器来验证上传的文件对象。\n请注意，上述示例只涵盖了文件大小和文件类型的验证，你可以根据实际需求扩展验证逻辑。还可以使用其他验证器装饰器（如 @IsString()、&#96;\n不使用 DTO ，无设计模式验证的示例如果你不想使用 DTO 进行验证，你可以直接在控制器方法中使用 @UploadedFile() 装饰器来获取上传的文件对象，并在方法内部进行验证。以下是一个示例：\nimport &#123; Controller, Post, UploadedFile, UseInterceptors &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  async uploadFile(@UploadedFile() file: Express.Multer.File) &#123;\n    &#x2F;&#x2F; 验证文件大小和类型\n    const maxSize &#x3D; 1024 * 1024; &#x2F;&#x2F; 1MB\n    const allowedTypes &#x3D; [&#39;image&#x2F;jpeg&#39;, &#39;image&#x2F;png&#39;];\n\n    if (file.size &gt; maxSize) &#123;\n      throw new Error(&#39;File size exceeds the maximum allowed limit&#39;);\n    &#125;\n\n    if (!allowedTypes.includes(file.mimetype)) &#123;\n      throw new Error(&#39;Invalid file type&#39;);\n    &#125;\n\n    &#x2F;&#x2F; 处理上传的文件\n  &#125;\n&#125;\n\n在上述示例中，我们直接在 uploadFile 方法中使用 @UploadedFile() 装饰器来获取上传的文件对象，并在方法内部进行文件验证。你可以根据自己的需求修改文件大小和类型的验证逻辑。如果验证不通过，可以抛出相应的错误，否则可以继续处理上传的文件。\n使用 ParseFilePipe 管道验证的示例如果你想使用管道进行文件验证，可以使用 NestJS 提供的 ParseFilePipe 管道，它可以帮助你验证文件的大小和类型。以下是一个示例：\nimport &#123; Controller, Post, UploadedFile, UseInterceptors &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; FileInterceptor &#125; from &#39;@nestjs&#x2F;platform-express&#39;;\nimport &#123; ParseFilePipe &#125; from &#39;nestjs-form-data&#39;;\n\n@Controller(&#39;files&#39;)\nexport class FilesController &#123;\n  @Post(&#39;upload&#39;)\n  @UseInterceptors(FileInterceptor(&#39;file&#39;))\n  &#x2F;&#x2F; async uploadFile(\n  &#x2F;&#x2F;   @UploadedFile(new ParseFilePipe(&#123; maxSize: 1024 * 1024, allowedTypes: [&#39;image&#x2F;jpeg&#39;, &#39;image&#x2F;png&#39;] &#125;)) file: Express.Multer.File\n  &#x2F;&#x2F; ) &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F; 处理上传的文件\n  &#x2F;&#x2F; &#125;\n  &#x2F;&#x2F; 这是查看源码后，修改的代码，上面错误代码是chatGPT的代码\n  async uploadFile(\n    @UploadedFile(\n      new ParseFilePipe(&#123;\n        validators: [new MaxFileSizeValidator(&#123; maxSize: 1000 &#125;), new FileTypeValidator(&#123; fileType: &#39;image&#x2F;jpeg&#39; &#125;)],\n      &#125;)\n    )\n    file: Express.Multer.File\n  ) &#123;\n    &#x2F;&#x2F; 处理上传的文件\n  &#125;\n&#125;\n\n在上述示例中，我们在 @UploadedFile() 装饰器中使用 ParseFilePipe 管道，并传入一个配置对象，指定文件的最大大小和允许的文件类型。如果文件不满足配置的要求，ParseFilePipe 管道会抛出相应的验证错误。你可以根据自己的需求修改配置对象的值。\n使用 ParseFilePipe 管道可以简化文件验证的代码，将验证逻辑从控制器方法中分离出来，使代码更加清晰和可维护。\nNestjs ParseFilePipe 实现原理ParseFilePipe 是 NestJS 中用于处理文件上传的管道之一。它的实现原理涉及以下几个方面：\n\n多部分表单数据解析： 当客户端发送一个多部分表单数据请求时，ParseFilePipe 首先会解析请求体，提取出其中的文件数据和其他表单字段数据。\n\n文件存储和处理： ParseFilePipe 会将解析出的文件数据保存到指定的位置，可以是本地磁盘、云存储等。它可能会生成一个唯一的文件名，并将文件相关信息（如文件名、文件类型、文件大小等）与表单字段数据一起返回。\n\n验证文件属性： 在解析文件数据后，ParseFilePipe 会对文件进行验证，例如验证文件大小、文件类型等。如果文件不符合要求，管道可能会抛出验证错误。\n\n错误处理： 如果在解析过程中发生任何错误，ParseFilePipe 会捕获并抛出相应的异常，该异常将被全局异常过滤器捕获并进行处理。\n\n\n需要注意的是，具体的实现细节可能会根据 NestJS 版本和相关的插件或库而有所不同。你可以查阅 NestJS 的官方文档或相关的代码库来了解更多关于 ParseFilePipe 的实现原理和具体用法。\nParseFilePipe 源码import &#123; Injectable, Optional &#125; from &#39;..&#x2F;..&#x2F;decorators&#x2F;core&#39;;\nimport &#123; HttpStatus &#125; from &#39;..&#x2F;..&#x2F;enums&#39;;\nimport &#123; PipeTransform &#125; from &#39;..&#x2F;..&#x2F;interfaces&#x2F;features&#x2F;pipe-transform.interface&#39;;\nimport &#123; HttpErrorByCode &#125; from &#39;..&#x2F;..&#x2F;utils&#x2F;http-error-by-code.util&#39;;\nimport &#123; isEmpty, isObject, isUndefined &#125; from &#39;..&#x2F;..&#x2F;utils&#x2F;shared.utils&#39;;\nimport &#123; FileValidator &#125; from &#39;.&#x2F;file-validator.interface&#39;;\nimport &#123; ParseFileOptions &#125; from &#39;.&#x2F;parse-file-options.interface&#39;;\n\n&#x2F;**\n * Defines the built-in ParseFile Pipe. This pipe can be used to validate incoming files\n * with &#96;@UploadedFile()&#96; decorator. You can use either other specific built-in validators\n * or provide one of your own, simply implementing it through FileValidator interface\n * and adding it to ParseFilePipe&#39;s constructor.\n *\n * @see [Built-in Pipes](https:&#x2F;&#x2F;docs.nestjs.com&#x2F;pipes#built-in-pipes)\n *\n * @publicApi\n *&#x2F;\n@Injectable()\nexport class ParseFilePipe implements PipeTransform&lt;any&gt; &#123;\n  protected exceptionFactory: (error: string) &#x3D;&gt; any;\n  private readonly validators: FileValidator[];\n  private readonly fileIsRequired: boolean;\n\n  constructor(@Optional() options: ParseFileOptions &#x3D; &#123;&#125;) &#123;\n    const &#123; exceptionFactory, errorHttpStatusCode &#x3D; HttpStatus.BAD_REQUEST, validators &#x3D; [], fileIsRequired &#125; &#x3D; options;\n    &#x2F;&#x2F; 如果使用者提供了 异常工厂使用，否则使用默认\n    this.exceptionFactory &#x3D; exceptionFactory || ((error) &#x3D;&gt; new HttpErrorByCode[errorHttpStatusCode](error));\n\n    this.validators &#x3D; validators;\n    this.fileIsRequired &#x3D; fileIsRequired ?? true;\n  &#125;\n\n  async transform(value: any): Promise&lt;any&gt; &#123;\n    const areThereAnyFilesIn &#x3D; this.thereAreNoFilesIn(value);\n\n    if (areThereAnyFilesIn &amp;&amp; this.fileIsRequired) &#123;\n      throw this.exceptionFactory(&#39;File is required&#39;);\n    &#125;\n    if (!areThereAnyFilesIn &amp;&amp; this.validators.length) &#123;\n      await this.validateFilesOrFile(value);\n    &#125;\n\n    return value;\n  &#125;\n  &#x2F;&#x2F; 校验文件\n  private async validateFilesOrFile(value: any): Promise&lt;void&gt; &#123;\n    if (Array.isArray(value)) &#123;\n      await Promise.all(value.map((f) &#x3D;&gt; this.validate(f)));\n    &#125; else &#123;\n      await this.validate(value);\n    &#125;\n  &#125;\n\n  private thereAreNoFilesIn(value: any): boolean &#123;\n    const isEmptyArray &#x3D; Array.isArray(value) &amp;&amp; isEmpty(value);\n    const isEmptyObject &#x3D; isObject(value) &amp;&amp; isEmpty(Object.keys(value));\n    return isUndefined(value) || isEmptyArray || isEmptyObject;\n  &#125;\n  &#x2F;&#x2F; 对校验器一个一个进行校验\n  protected async validate(file: any): Promise&lt;any&gt; &#123;\n    for (const validator of this.validators) &#123;\n      await this.validateOrThrow(file, validator);\n    &#125;\n    return file;\n  &#125;\n  &#x2F;&#x2F; 无效抛出异常\n  private async validateOrThrow(file: any, validator: FileValidator) &#123;\n    const isValid &#x3D; await validator.isValid(file);\n\n    if (!isValid) &#123;\n      const errorMessage &#x3D; validator.buildErrorMessage(file);\n      throw this.exceptionFactory(errorMessage);\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * @returns list of validators used in this pipe.\n   *&#x2F;\n  getValidators() &#123;\n    return this.validators;\n  &#125;\n&#125;\n\n这是 NestJS 中 ParseFilePipe 的源代码。以下是对代码的解读：\n\nParseFilePipe 是一个可注入的管道（PipeTransform）类，用于验证传入的文件。\n通过构造函数接收 ParseFileOptions 作为可选参数，可以配置异常工厂、错误的 HTTP 状态码、文件验证器等。\ntransform 方法用于转换和验证传入的值（文件）。首先，它检查是否有文件存在，如果要求文件必须存在但实际不存在，则抛出异常。接着，如果存在文件，并且定义了文件验证器，则对文件进行验证。\nvalidateFilesOrFile 方法用于验证单个文件或文件数组，根据情况调用 validate 方法。\nthereAreNoFilesIn 方法用于判断传入的值是否为空，如果是空值，则认为没有文件。\nvalidate 方法用于遍历所有的文件验证器，并验证文件是否有效，如果不符合验证规则，则抛出异常。\nvalidateOrThrow 方法用于执行单个文件的验证操作，并根据验证结果决定是否抛出异常。\ngetValidators 方法用于获取当前管道中使用的所有文件验证器。\n\n总体而言，ParseFilePipe 是一个用于验证文件的管道，可以根据配置的选项和验证器对传入的文件进行验证，并在验证不通过时抛出异常。它提供了灵活的配置和扩展选项，使开发者可以自定义文件验证规则。\nchatGPT 小插曲\nDetails\nnew ParseFilePipe({ maxSize: 1024 * 1024, allowedTypes: [‘image&#x2F;jpeg’, ‘image&#x2F;png’] }) 看上去不符合 ParseFilePipe 构造函数的入参\n您是正确的，我对 ParseFilePipe 的构造函数入参进行了错误的解释。我对此表示歉意。\n在实际的源代码中，ParseFilePipe 的构造函数入参应为一个对象，该对象具有以下可选属性：\n\nexceptionFactory: 一个用于创建异常对象的工厂函数。\nerrorHttpStatusCode: 错误的 HTTP 状态码，默认为 HttpStatus.BAD_REQUEST。\nvalidators: 一个文件验证器的数组。\nfileIsRequired: 一个布尔值，指示文件是否是必需的，默认为 true。\n\n因此，正确的使用方式应该是：\nnew ParseFilePipe(&#123;\n  exceptionFactory: (error) &#x3D;&gt; new MyCustomException(error),\n  errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY,\n  validators: [new MyCustomFileValidator()],\n  fileIsRequired: false,\n&#125;);\n\n对于 maxSize 和 allowedTypes 这样的配置，它们不是 ParseFilePipe 自带的选项，您可能需要自定义文件验证器来实现这些验证逻辑。\n上述代码写错了，应该写成 validators: [\n      new MaxFileSizeValidator(&#123; maxSize: 1000 &#125;),\n      new FileTypeValidator(&#123; fileType: &#39;image&#x2F;jpeg&#39; &#125;),\n    ],\n\n非常抱歉，我之前的回答有误。根据您提供的代码，确实可以通过将 MaxFileSizeValidator 和 FileTypeValidator 实例添加到 validators 数组中来配置文件大小和文件类型的验证。这样，ParseFilePipe 的构造函数将如下所示：\nnew ParseFilePipe(&#123;\n  validators: [new MaxFileSizeValidator(&#123; maxSize: 1000 &#125;), new FileTypeValidator(&#123; fileType: &#39;image&#x2F;jpeg&#39; &#125;)],\n&#125;);\n\n这将创建一个 ParseFilePipe 实例，并使用 MaxFileSizeValidator 验证文件大小（最大大小为 1000 字节）以及使用 FileTypeValidator 验证文件类型（仅允许 JPEG 图像）。\n\n\n源码中 transform 方法什么时候被调用，被谁调用的transform 方法是 PipeTransform 接口的一个方法，用于转换输入的值。在 ParseFilePipe 中，它被用作文件验证和转换的主要逻辑。\ntransform 方法在管道被应用时被调用，通常是在控制器中处理请求时。当使用 @UsePipes() 装饰器将管道应用到一个特定的处理程序方法或控制器类上时，NestJS 会自动调用管道的 transform 方法。\n在 ParseFilePipe 中，transform 方法首先检查输入的值是否包含文件，如果文件为必需且不存在，则抛出异常。然后，它会根据配置的验证器对文件进行验证，如果文件未通过验证，则抛出相应的异常。最后，如果文件通过了验证，它会返回原始的文件值。\n因此，transform 方法在请求到达控制器之前被调用，它可以进行文件验证和转换，确保传入的文件满足指定的条件。\nMaxFileSizeValidator 源码import &#123; FileValidator &#125; from &#39;.&#x2F;file-validator.interface&#39;;\n\nexport type MaxFileSizeValidatorOptions &#x3D; &#123;\n  maxSize: number;\n&#125;;\n\n&#x2F;**\n * Defines the built-in MaxSize File Validator\n *\n * @see [File Validators](https:&#x2F;&#x2F;docs.nestjs.com&#x2F;techniques&#x2F;file-upload#file-validation)\n *\n * @publicApi\n *&#x2F;\nexport class MaxFileSizeValidator extends FileValidator&lt;MaxFileSizeValidatorOptions&gt; &#123;\n  buildErrorMessage(): string &#123;\n    return &#96;Validation failed (expected size is less than $&#123;this.validationOptions.maxSize&#125;)&#96;;\n  &#125;\n\n  public isValid(file: any): boolean &#123;\n    if (!this.validationOptions) &#123;\n      return true;\n    &#125;\n\n    return file.size &lt; this.validationOptions.maxSize;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; packages&#x2F;common&#x2F;pipes&#x2F;file&#x2F;file-validator.interface.ts\n\n&#x2F;**\n * Interface describing FileValidators, which can be added to a ParseFilePipe\n *\n * @see &#123;ParseFilePipe&#125;\n * @publicApi\n *&#x2F;\nexport abstract class FileValidator&lt;TValidationOptions &#x3D; Record&lt;string, any&gt;&gt; &#123;\n  constructor(protected readonly validationOptions: TValidationOptions) &#123;&#125;\n\n  &#x2F;**\n   * Indicates if this file should be considered valid, according to the options passed in the constructor.\n   * @param file the file from the request object\n   *&#x2F;\n  abstract isValid(file?: any): boolean | Promise&lt;boolean&gt;;\n\n  &#x2F;**\n   * Builds an error message in case the validation fails.\n   * @param file the file from the request object\n   *&#x2F;\n  abstract buildErrorMessage(file: any): string;\n&#125;\n\n在继承抽象类的时候，需不需要实现 constructor 方法？在继承抽象类时，您不必实现构造函数。当子类继承抽象类时，它会继承父类的构造函数。如果子类自己没有显式声明构造函数，那么它将使用父类的构造函数。\n如果您需要在子类中添加额外的构造逻辑或初始化属性，您可以在子类中声明自己的构造函数，并使用 super() 调用父类的构造函数，以便继承父类的行为。例如：\nexport abstract class BaseClass &#123;\n  protected constructor(public readonly name: string) &#123;\n    &#x2F;&#x2F; 父类的构造函数逻辑\n  &#125;\n\n  abstract someMethod(): void;\n&#125;\n\nexport class DerivedClass extends BaseClass &#123;\n  constructor(name: string, public readonly age: number) &#123;\n    super(name); &#x2F;&#x2F; 调用父类的构造函数\n    &#x2F;&#x2F; 子类的构造逻辑\n  &#125;\n\n  someMethod(): void &#123;\n    &#x2F;&#x2F; 实现抽象方法\n  &#125;\n&#125;\n\n在上述示例中，DerivedClass 继承自 BaseClass 抽象类，并实现了抽象方法 someMethod。它在自己的构造函数中添加了 age 属性，并使用 super(name) 调用了父类的构造函数来初始化 name 属性。\n总结来说，您可以选择是否在子类中声明构造函数，如果声明了，则需要使用 super() 调用父类的构造函数来继承父类的行为。\n在继承抽象类的时候，哪些方法必须实现？当一个类继承自一个抽象类时，它必须实现抽象类中定义的所有抽象方法。抽象方法是在抽象类中声明但没有提供具体实现的方法。子类必须提供这些抽象方法的具体实现。\n如果子类没有实现抽象类中的所有抽象方法，那么该子类本身也必须声明为抽象类。换句话说，一个非抽象的子类继承抽象类时，必须实现所有抽象方法。\n下面是一个示例，展示了一个抽象类和子类之间的继承关系：\nabstract class AbstractClass &#123;\n  abstract abstractMethod(): void;\n\n  normalMethod(): void &#123;\n    &#x2F;&#x2F; 普通方法的具体实现\n  &#125;\n&#125;\n\nclass ConcreteClass extends AbstractClass &#123;\n  abstractMethod(): void &#123;\n    &#x2F;&#x2F; 抽象方法的具体实现\n  &#125;\n\n  &#x2F;&#x2F; 可选：可以在子类中添加其他方法或属性\n&#125;\n\n在上述示例中，AbstractClass 是一个抽象类，它声明了一个抽象方法 abstractMethod 和一个普通方法 normalMethod。ConcreteClass 继承自 AbstractClass，并提供了对抽象方法 abstractMethod 的具体实现。\n总结来说，子类必须实现抽象类中定义的所有抽象方法，否则子类自身必须声明为抽象类。\n其他语言也是 “一个非抽象的子类继承抽象类时，必须实现所有抽象方法”？不是所有的编程语言都强制要求非抽象子类实现抽象类中的所有抽象方法。这样的要求是由具体的编程语言和其对抽象类和接口的定义方式而定。\n例如，在 Java 中，如果一个类继承自一个抽象类，它必须实现所有抽象方法，否则它本身也必须声明为抽象类。这是 Java 语言的要求。\n然而，在其他编程语言中，如TypeScript 和 C#，子类可以选择性地实现抽象类中的抽象方法。这意味着子类可以是非抽象类，即使它没有实现所有抽象方法。在这种情况下，该子类仍然被视为抽象类，不能被实例化，只能被其他类继承并实现剩余的抽象方法。\n所以，是否要求非抽象子类实现所有抽象方法取决于具体的编程语言和其对抽象类和接口的规定。需要查阅特定编程语言的文档或规范以了解其要求。\nNestJS 数据库NestJS TypeormNestJS 是一个基于 TypeScript 的开发框架，而 TypeORM 是一个流行的 TypeScript&#x2F;JavaScript 的对象关系映射（ORM）库。TypeORM 提供了与数据库交互的功能，可以轻松地在 NestJS 应用程序中集成和使用。\nNestJS 和 TypeORM 的结合使用可以简化数据库操作和管理，提供强大的数据持久化能力。下面是一些使用 NestJS 和 TypeORM 的示例：\n\n安装 TypeORM：通过运行 npm install typeorm 或 yarn add typeorm 命令来安装 TypeORM。\n\n创建实体（Entity）：在 TypeORM 中，实体是映射到数据库表的对象。使用装饰器（如 @Entity、@Column）定义实体类，并指定其属性和关联关系。\n\n创建存储库（Repository）：存储库是用于执行数据库操作的对象。通过继承 Repository 类来创建自定义存储库，并使用装饰器（如 @EntityRepository）将其与实体相关联。\n\n配置数据库连接：在 NestJS 中，可以在 app.module.ts 文件中使用 TypeOrmModule.forRoot() 方法配置数据库连接，包括数据库类型、主机、端口、用户名、密码等。\n\n使用存储库进行数据库操作：在服务或控制器中，可以注入存储库并使用其方法执行数据库操作，如保存实体、查询数据、更新数据等。\n\n\n通过结合 NestJS 和 TypeORM，可以轻松地实现数据持久化和数据库操作，从而构建可靠的后端应用程序。注意，上述示例只是简单介绍了使用 TypeORM 的一些基本步骤，实际使用时可能还需要配置其他参数和选项，具体操作取决于应用程序的需求和数据库的配置。\nNestJS 连接 Typeorm 有哪些方式？在 NestJS 中连接 TypeORM，有以下几种方式：\n\n使用 TypeOrmModule.forRoot() 方法：在 NestJS 的根模块（通常是 app.module.ts）中使用 TypeOrmModule.forRoot() 方法配置数据库连接。这种方式适用于单一的数据库连接。\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; TypeOrmModule &#125; from &#39;@nestjs&#x2F;typeorm&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\nimport &#123; AppService &#125; from &#39;.&#x2F;app.service&#39;;\n\n@Module(&#123;\n  imports: [\n    TypeOrmModule.forRoot(&#123;\n      &#x2F;&#x2F; 数据库连接配置\n      type: &#39;mysql&#39;,\n      host: &#39;localhost&#39;,\n      port: 3306,\n      username: &#39;root&#39;,\n      password: &#39;password&#39;,\n      database: &#39;mydb&#39;,\n      entities: [__dirname + &#39;&#x2F;**&#x2F;*.entity&#123;.ts,.js&#125;&#39;],\n      synchronize: true,\n    &#125;),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n&#125;)\nexport class AppModule &#123;&#125;\n\n使用 TypeOrmModule.forRootAsync() 方法：如果需要动态配置数据库连接，例如从配置文件或环境变量中获取连接参数，可以使用 TypeOrmModule.forRootAsync() 方法。这种方式可以使用异步配置提供程序，如 useFactory、useClass 或 useExisting。\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; TypeOrmModule &#125; from &#39;@nestjs&#x2F;typeorm&#39;;\nimport &#123; AppController &#125; from &#39;.&#x2F;app.controller&#39;;\nimport &#123; AppService &#125; from &#39;.&#x2F;app.service&#39;;\nimport &#123; TypeOrmConfigService &#125; from &#39;.&#x2F;typeorm-config.service&#39;;\n\n@Module(&#123;\n  imports: [\n    TypeOrmModule.forRootAsync(&#123;\n      useClass: TypeOrmConfigService,\n    &#125;),\n  ],\n  controllers: [AppController],\n  providers: [AppService, TypeOrmConfigService],\n&#125;)\nexport class AppModule &#123;&#125;\n\n其中，TypeOrmConfigService 是一个自定义的配置提供程序，用于动态获取数据库连接参数。\n\n使用 TypeOrmModule.forFeature() 方法：在需要访问数据库的模块中，可以使用 TypeOrmModule.forFeature() 方法导入实体和存储库。这种方式适用于在特定模块中使用单独的数据库连接。\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; TypeOrmModule &#125; from &#39;@nestjs&#x2F;typeorm&#39;;\nimport &#123; UserController &#125; from &#39;.&#x2F;user.controller&#39;;\nimport &#123; UserService &#125; from &#39;.&#x2F;user.service&#39;;\nimport &#123; UserRepository &#125; from &#39;.&#x2F;user.repository&#39;;\n\n@Module(&#123;\n  imports: [TypeOrmModule.forFeature([UserRepository])],\n  controllers: [UserController],\n  providers: [UserService],\n&#125;)\nexport class UserModule &#123;&#125;\n\n在上述示例中，UserRepository 是一个自定义的存储库，通过 TypeOrmModule.forFeature() 方法将其导入到 UserModule 模块中。\n\n\n这些方式可以根据具体的需求和项目架构选择使用。第一种方式是最简单直接的方式，适用于单一的数据库连接；第二种方式适用于动态配置数据库连接参数；第三种方式适用于在特定模块中使用单独的数据库连接。根据实际情况选择适合的方式来连接 TypeORM\n@nestjs&#x2F;typeorm TypeOrmModule 源码TypeOrmModule\n@Module(&#123;&#125;)\nexport class TypeOrmModule &#123;\n  static forRoot(options?: TypeOrmModuleOptions): DynamicModule &#123;\n    return &#123;\n      module: TypeOrmModule,\n      imports: [TypeOrmCoreModule.forRoot(options)],\n    &#125;;\n  &#125;\n\n  static forFeature(\n    entities: EntityClassOrSchema[] &#x3D; [],\n    dataSource: DataSource | DataSourceOptions | string &#x3D; DEFAULT_DATA_SOURCE_NAME\n  ): DynamicModule &#123;\n    const providers &#x3D; createTypeOrmProviders(entities, dataSource);\n    EntitiesMetadataStorage.addEntitiesByDataSource(dataSource, [...entities]);\n    return &#123;\n      module: TypeOrmModule,\n      providers: providers,\n      exports: providers,\n    &#125;;\n  &#125;\n\n  static forRootAsync(options: TypeOrmModuleAsyncOptions): DynamicModule &#123;\n    return &#123;\n      module: TypeOrmModule,\n      imports: [TypeOrmCoreModule.forRootAsync(options)],\n    &#125;;\n  &#125;\n&#125;\n\n只暴露了 3 个 API,chatGPT2021 有时候会给出 4 个方法，有个是不存在的\n注意：这 3 个方法是静态方法，由之前方法可知，静态方法作为工具方法使用\nTypeOrmModule.forRootAsync() 与 useFactory、 useClass、 useExisting 什么关系 【可跳过】在 NestJS 中，TypeOrmModule.forRootAsync() 是用于异步配置 TypeORM 模块的方法。它允许你根据需要动态地提供 TypeORM 模块的配置。\nforRootAsync() 方法接受一个对象作为参数，该对象包含一个或多个属性来定义异步配置的选项。其中，三个常用的属性是 useFactory、useClass 和 useExisting。\n\nuseFactory 属性用于指定一个工厂函数，该函数返回一个配置对象。工厂函数可以是异步的，它可以执行任何异步操作，例如从配置文件加载配置、请求远程配置等。通过 useFactory，你可以根据自己的需求动态地生成 TypeORM 模块的配置。\n\nuseClass 属性用于指定一个提供器类，该类实现了 TypeOrmOptionsFactory 接口。这个类可以注入其他依赖，执行复杂的初始化逻辑，并返回配置对象。通过 useClass，你可以将配置的逻辑封装在一个可重用的类中。\n\nuseExisting 属性用于指定一个已经注册的提供器的标记，该提供器实现了 TypeOrmOptionsFactory 接口。通过 useExisting，你可以复用现有的提供器，避免重复定义相同的配置逻辑。\n\n\n这些属性之间的关系是，你可以根据不同的需求选择其中一个属性来定义异步配置的方式。无论是使用 useFactory、useClass 还是 useExisting，最终都要返回一个包含 TypeORM 配置的对象，供 forRootAsync() 方法使用。\n通过这种方式，你可以根据不同的场景和需求，动态地生成和提供 TypeORM 模块的配置，以适应不同的数据库连接、环境变量等情况。\nuseFactory、 useClass、 useExisting 有什么区别 【可跳过】在 NestJS 中，useFactory、useClass 和 useExisting 是用于异步配置提供器的属性。\n\nuseFactory: 使用一个工厂函数来创建提供器的实例。工厂函数可以是同步的或异步的，并且可以执行任意的逻辑来生成提供器的实例。工厂函数可以接受依赖注入，以便在创建实例时使用其他依赖项。该工厂函数必须返回一个实例化的对象作为提供器的值。\n\nuseClass: 使用一个类来创建提供器的实例。该类必须实现相应的接口或装饰器。NestJS 将会自动实例化该类，并将其用作提供器的值。类可以接受依赖注入，并在其构造函数中使用其他依赖项。使用 useClass 属性时，NestJS 将会自动解析类的依赖项并注入它们。\n\nuseExisting: 复用现有的提供器。使用该属性时，你需要提供一个已经在 NestJS 容器中注册的提供器的标记。NestJS 将会从容器中解析该提供器并将其用作提供器的值。这使得你可以复用已经定义的提供器，避免重复定义相同的配置逻辑。\n\n\n这些属性的区别在于它们用于不同的创建提供器的方式。useFactory 允许你使用自定义的工厂函数来创建提供器实例，useClass 则使用一个类来创建提供器实例，而 useExisting 则复用现有的提供器。\n通过这些属性，你可以选择最适合你需求的方式来定义提供器的创建逻辑。无论是使用工厂函数、类还是已有的提供器，最终都会创建一个实例，并将其用作提供器的值。\n这三个各自的使用场景是什么？【可跳过】以下是这三个属性的常见使用场景：\n\nuseFactory: 使用工厂函数创建提供器的实例，适用于需要动态配置或自定义实例化逻辑的情况。例如，当你需要根据一些条件决定提供器的配置参数时，可以使用工厂函数来创建实例，并根据条件进行逻辑处理。工厂函数可以包含异步操作，比如从远程服务获取配置参数。\n\nTypeOrmModule.forRootAsync(&#123;\n  useFactory: () &#x3D;&gt; &#123;\n    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;\n      return &#123;\n        &#x2F;&#x2F; 生产环境的数据库配置\n      &#125;;\n    &#125; else &#123;\n      return &#123;\n        &#x2F;&#x2F; 开发环境的数据库配置\n      &#125;;\n    &#125;\n  &#125;,\n&#125;);\n\n\nuseClass: 使用类创建提供器的实例，适用于简单的实例化场景。当你有一个类并且希望将其实例化并用作提供器时，可以使用 useClass。该类可以接受其他依赖项，并在其构造函数中使用它们。\n\nTypeOrmModule.forRootAsync(&#123;\n  useClass: TypeOrmConfigService,\n&#125;);\n\n\nuseExisting: 复用现有的提供器实例，适用于复用已定义的提供器配置的情况。当你已经在 NestJS 容器中注册了一个提供器，并希望将其用作另一个提供器的值时，可以使用 useExisting。这样可以避免重复定义相同的配置逻辑。\n\nTypeOrmModule.forRootAsync(&#123;\n  useExisting: ConfigService,\n&#125;);\n\n根据你的需求和场景，选择适合的属性来定义提供器的创建方式。使用工厂函数可以提供更高的灵活性和定制性，使用类可以更简单地创建实例，并且使用现有的提供器可以节省重复定义配置的工作。\n这么理解：要使用类就用 useClass ，要使用工厂形式 就用 useFactory， 要使用提供器就用 useExisting？基本上你的理解是正确的，这是一种常见的用法：\n\nuseClass: 当你有一个类并且希望将其实例化并用作提供器时，可以使用 useClass。这适用于简单的实例化场景。\n\nuseFactory: 当你需要根据一些条件动态创建提供器实例时，可以使用 useFactory。工厂函数可以根据需要进行自定义逻辑，并返回提供器实例。这适用于需要更高灵活性和定制性的情况。\n\nuseExisting: 当你已经在 NestJS 容器中注册了一个提供器，并希望将其用作另一个提供器的值时，可以使用 useExisting。这样可以避免重复定义相同的配置逻辑，直接复用现有的提供器实例。\n\n\n这些属性的选择取决于你的需求和设计，根据场景选择合适的方式来创建和配置提供器。\n如果 useFactory、 useClass、 useExisting 同时使用useFactory、useClass和useExisting是互斥的选项，不会同时使用。这些选项用于不同的场景和需求，根据具体情况选择其中一个。\n\n如果你想使用一个工厂函数来动态创建提供器实例，你应该使用useFactory。\n如果你想直接使用一个类的实例作为提供器，你应该使用useClass。\n如果你想复用现有的提供器实例作为另一个提供器的值，你应该使用useExisting。\n\n根据你的需求，选择合适的选项来配置提供器。不需要同时使用这三个选项。\n为什么要给用户这么多选择，直接一个类不能覆盖所有场景吗？给用户多种选择的目的是为了灵活性和可扩展性。不同的场景可能需要不同的配置方式，使用不同的选项可以满足不同的需求。\n\nuseClass允许你直接指定一个类作为提供器，这对于简单的情况很方便，但可能无法满足复杂的需求，比如需要在创建实例之前执行一些额外的逻辑或从外部获取配置参数。\n\nuseFactory允许你定义一个工厂函数来动态创建提供器实例，这样你可以在函数内部执行一些自定义逻辑，根据需要传递参数，并返回一个实例化后的对象。这提供了更大的灵活性，可以满足复杂的需求。\n\nuseExisting允许你复用现有的提供器实例作为另一个提供器的值。这在需要共享相同实例的情况下很有用，可以避免重复创建实例和共享状态的问题。\n\n\n通过提供多种选择，NestJS 允许开发者根据具体需求选择最合适的方式，以实现灵活性、可维护性和可扩展性。这样可以更好地满足不同项目和场景的需求。\n对于 entities 实体的书写查看 typeorm 实体相关文档\n","slug":"2023-05-09nestjs","date":"2023-05-09T10:25:51.000Z","categories_index":"nodejs","tags_index":"chatGPT2021,nodejs","author_index":"举手摘月亮"},{"id":"7c8d110856dc8b871f4c54e1b5f1f295","title":"虚拟列表（没想好怎么写）","content":"虚拟列表原理虚拟列表实现原理虚拟列表（Virtual List）是一种常见的前端性能优化技术，用于解决渲染大量数据时，DOM 元素过多导致页面卡顿的问题。虚拟列表通过只渲染当前可见区域的 DOM 元素，来减少页面渲染的负担，从而提高页面性能。\n虚拟列表的实现原理一般分为以下几步：\n\n计算可视区域的大小和位置。虚拟列表需要根据当前容器的大小和滚动位置，计算出可视区域的大小和位置，以便后续渲染和定位列表项。\n\n计算列表项的尺寸。虚拟列表需要根据数据源和样式信息，计算出每个列表项的高度或宽度，以便后续计算容器的滚动范围和渲染列表项。\n\n渲染可视区域的列表项。虚拟列表根据当前可视区域的位置和大小，计算出需要渲染的列表项的索引范围，然后仅渲染这些列表项的 DOM 元素，将它们插入到容器中。\n\n更新列表项的内容。虚拟列表需要根据数据源的变化，更新已经渲染的列表项的内容，以保证列表项的正确性。\n\n处理容器的滚动事件。虚拟列表需要监听容器的滚动事件，根据滚动的位置和方向，重新计算可视区域的位置和大小，从而实现列表项的滚动效果。\n\n\n总之，虚拟列表的实现原理是通过计算可视区域和列表项的尺寸，以及渲染可视区域的列表项等步骤，来实现只渲染当前可见区域的 DOM 元素，从而减少页面渲染的负担，提高页面性能。\n优化虚拟列表优化虚拟列表的性能可以从以下几个方面入手：\n\n减少 DOM 操作次数\n\n在虚拟列表中，DOM 操作是性能瓶颈之一。为了减少 DOM 操作的次数，可以使用文档片段（document fragment）来批量操作 DOM 元素，从而减少对页面的渲染次数。具体来说，可以在循环中使用文档片段来创建元素，并在创建完成后一次性将文档片段添加到容器中。\n\n使用 debounce 和 throttle 控制滚动事件\n\n滚动事件是虚拟列表中另一个性能瓶颈。为了减少滚动事件的触发次数，可以使用 debounce 和 throttle 函数来控制滚动事件的触发。debounce 函数可以延迟滚动事件的触发时间，从而减少事件的触发次数；throttle 函数可以控制滚动事件的触发频率，从而减少事件的触发次数。\n\n使用 requestAnimationFrame\n\n使用 requestAnimationFrame 可以将滚动事件的处理移到浏览器的下一帧中，从而减少事件的触发次数，提高页面的性能和响应速度。\n\n使用缓存机制\n\n在虚拟列表中，可以使用缓存机制来提高性能。具体来说，可以缓存已经渲染的元素，以避免重复渲染，从而提高渲染速度。可以使用一个对象来保存已经渲染的元素，并在渲染新元素时先检查是否已经存在缓存中。如果已经存在，就可以直接从缓存中取出元素，避免重复渲染。\n\n使用懒加载\n\n懒加载可以将元素的加载延迟到真正需要的时候再进行，从而减少页面的加载时间。在虚拟列表中，可以使用懒加载来延迟元素的加载，从而提高页面的性能和响应速度。具体来说，可以在滚动时判断当前元素是否需要加载，如果需要加载，则进行加载操作，否则不进行操作。\n以上是一些优化虚拟列表性能的方法，实际应用时需要根据具体情况进行选择。需要注意的是，在进行性能优化时，要避免过度优化，以免降低代码的可读性和可维护性。\n如何在滚动过程中，只更新可视区域内的元素，不需要重新渲染整个列表实现虚拟列表的关键就是根据可视区域的位置和大小来确定需要渲染哪些元素。一般来说，可以通过监听滚动事件，计算出当前可视区域的位置和大小，然后根据可视区域的位置和大小来确定需要渲染哪些元素。\n具体实现步骤如下：\n\n首先，需要获取列表容器和列表项的高度（或宽度），以及总共的元素数量。\n然后，可以监听列表容器的滚动事件，计算出当前可视区域的位置和大小，比如可视区域的开始索引和结束索引。\n接下来，可以根据可视区域的开始索引和结束索引来确定需要渲染哪些元素，通常会在可视区域外的元素设置一个占位符，避免出现闪动现象。\n最后，只需要更新可视区域内的元素，不需要重新渲染整个列表。\n\n在更新元素时，可以使用 DOM 操作来更新元素的内容，也可以使用虚拟 DOM 的技术来更新元素。使用虚拟 DOM 的好处是可以提高更新效率，减少 DOM 操作的次数。\n需要注意的是，在实现虚拟列表时，需要考虑到各种情况，比如滚动方向、滚动速度、元素高度不一致等因素，以确保列表的性能和渲染效果都能够满足需求。\n可视区域外的元素设置一个占位符，避免出现闪动现象？是的，为了避免出现闪动现象，通常在可视区域外的元素会设置一个占位符。\n假设可视区域开始的索引是 start，结束的索引是 end，元素的总数是 total。则在可视区域外的元素可以通过占位符来替代，这个占位符的高度（或宽度）应该与元素的高度（或宽度）相同，以确保列表的布局不会出现变化。\n具体实现步骤如下：\n\n在列表容器内部创建一个占位符元素，并设置其高度（或宽度）与列表项相同。\n在渲染列表时，根据可视区域的开始索引和结束索引，分别渲染可视区域内的元素和占位符。\n在滚动过程中，根据可视区域的位置和大小来更新可视区域内的元素和占位符的内容。\n在更新元素时，需要同时更新相应的占位符，以确保列表的布局不会出现变化。\n\n通过设置占位符，可以避免在滚动过程中出现列表元素的闪动现象，从而提高用户体验。\nreact-window 与 react-virtualized据作者说：几年前开发 react-virtualized，他刚接触 React，这个库他在设计时候并不是很好，然后又不能去做大的调整，以避免给开发者带来痛苦\n几年前我写了 react-虚拟化。当时，我对 React 和窗口概念都不熟悉。正因为如此，我做了一些后来后悔的 API 决定。其中之一是添加了太多非必要的特性和组件。一旦你向开源项目添加了一些东西，删除它对用户来说是非常痛苦的。\nReact-windows 是对 react-虚拟化的完全重写。尽可能多的实现功能。专注于使包更小、更快。花心思使 API（和留档）尽可能适合初学者（需要注意的是，窗口仍然是一种高级用例）。\n优先选用 react-windows\nreact-windows 常见问题列表或网格可以 100%填充页面的宽度或高度吗？使用 react-virtualized-auto-sizer\n\n\n滚动时列表是空白的?\n\n那么您可能忘记使用样式参数了！\n像 react-windows 这样的库通过绝对定位列表项（通过内联样式）来工作，因此不要忘记将其附加到您呈现的 DOM 元素\n\n\n延迟加载列表的数据?使用 react-window-infinite-loader\n\n\n附加自定义属性或事件处理程序？使用 outerElementType 属性\n\n\n在列表的顶部和底部添加填充？需要一些内联样式\n\n\n在物品之间添加间隙？\n\nreact-windows 代码createListComponent 代码\n","slug":"2023-05-09vr-list","date":"2023-05-09T02:23:25.000Z","categories_index":"性能优化","tags_index":"性能优化,chatGPT2021","author_index":"举手摘月亮"},{"id":"1c1176847881d39523eab2c0cd2228ab","title":"nodejs进程线程通信","content":"问题\n进程间通信与线程间通信的区别 ?\n进程通信有哪些方式 ?\n线程通信有哪些方式 ?\nkafaka 不属于进程通信 ?\nElectron 为什么使用线程通信 ?\nHTTP 可以替代 RPC ?\n为什么出现 RPC ?\n多进程，多线程，与同步是否冲突 ?\n\nNodejs 进程之间如何通信在 Node.js 中，不同的进程之间可以通过以下几种方式进行通信：\n\n子进程：可以使用 child_process 模块创建子进程，并通过标准输入输出流（stdin、stdout）进行通信。父进程可以向子进程发送消息，子进程可以从 stdin 读取消息，并将结果通过 stdout 返回给父进程。\n\nIPC：可以使用 Node.js 提供的 IPC（Inter-Process Communication）模块在不同的进程之间进行通信。IPC 模块提供了多种通信方式，例如命名管道、Socket、信号和共享内存等。\n\n远程调用：可以使用远程调用（RPC）框架在不同的进程之间进行通信。RPC 框架可以通过定义 IDL（接口定义语言）来描述接口和数据结构，从而实现进程之间的远程调用和数据传输。\n\n消息队列：可以使用消息队列在不同的进程之间进行异步通信。进程可以将消息发送到消息队列中，其他进程可以订阅该队列来接收消息。\n\n\n需要注意的是，不同的进程之间通信需要考虑数据安全性和可靠性问题。需要对数据进行加密和签名，对请求进行身份验证和授权，定期备份和监控系统，以保证系统的稳定性和可靠性。\n子进程利用标准输入输出进行通信非常抱歉，看来这个示例依赖的 MQ 库可能已经被删除了。我可以给你提供一个示例代码，使用 Node.js 的内置child_process模块创建一个子进程并在主进程和子进程之间通过标准输入输出通信。这个示例不需要任何额外的依赖库。请参考以下代码：\nparent.js\nconst &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);\nconst child &#x3D; spawn(&#39;node&#39;, [&#39;child.js&#39;]);\n\nchild.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n  console.log(&#96;Received data from child: $&#123;data&#125;&#96;);\n&#125;);\n\nchild.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;\n  console.log(&#96;Child process exited with code $&#123;code&#125;&#96;);\n&#125;);\n\nchild.stdin.write(&#39;Hello from parent\\n&#39;);\n\nchild.js\nprocess.stdin.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;\n  console.log(&#96;Received data from parent: $&#123;data&#125;&#96;);\n  process.stdout.write(&#39;Hello from child\\n&#39;);\n&#125;);\n\nprocess.on(&#39;exit&#39;, () &#x3D;&gt; &#123;\n  console.log(&#39;Child process exited&#39;);\n&#125;);\n\n在这个示例中，主进程（parent.js）创建了一个子进程（child.js），并向子进程写入一条消息。子进程接收到这个消息后，向主进程回复一条消息。主进程监听子进程的标准输出，并打印出子进程发送过来的消息。\n请注意，这个示例只是演示了如何在主进程和子进程之间进行通信。在实际应用中，您可能需要添加更多的代码来处理各种边界情况和错误处理。\nstdout stdin 为什么能够进行通信？在操作系统中，每个进程都有三个标准的输入&#x2F;输出文件描述符：\n\nstdin（标准输入）：默认指向键盘输入。\nstdout（标准输出）：默认指向终端输出。\nstderr（标准错误）：默认也指向终端输出。\n\n在进程间通信的过程中，子进程可以将标准输出重定向到管道中，而父进程则可以从管道中读取子进程输出的数据。这样就可以实现进程间通信了。\n在 Node.js 中，可以通过 child_process 模块创建子进程，并将子进程的标准输出重定向到父进程的标准输入上，实现父子进程间的通信。父进程可以使用子进程的 stdin 对象来发送数据，子进程可以使用 process.stdout 对象来发送数据。当然，也可以将子进程的标准输入重定向到管道中，父进程从管道中读取子进程的输出数据，从而实现进程间通信。\n还是不懂当你在控制台上输入命令并按下回车键时，该命令被发送到系统的标准输入（stdin）中。系统进程或应用程序可以通过读取标准输入来获取输入的命令。这样就可以实现控制台输入和进程通信了。\n同样地，进程也可以通过向标准输出（stdout）写入数据，将消息发送到控制台。控制台可以通过读取标准输出来获取进程发送的消息。这样就可以实现进程输出和控制台输出了。\n因此，在 Node.js 中，可以通过将进程的标准输入和标准输出与管道（pipe）相连来实现进程间通信。一个进程将数据写入其标准输出，并且另一个进程将其标准输入连接到另一端的管道中，就可以实现进程间通信了。\n假设有多个进程，如何确定哪个读取哪个？如果多个进程同时读取同一个管道，那么系统会将管道中的数据循环地分配给不同的进程进行读取，这样每个进程都有机会读取到管道中的数据。这种机制被称为轮询（Round-Robin）。\n轮询机制是一种公平的机制，保证了所有进程都有机会读取到管道中的数据。当然，如果某个进程需要更频繁地读取管道中的数据，可以增加该进程的调度次数，以此来提高该进程读取数据的机会。\nIPC 机制IPC 机制 是什么IPC（Inter-Process Communication，进程间通信）是指不同进程之间进行通信、交换数据的机制。\n在操作系统中，每个进程都拥有自己的地址空间和内存空间，不同进程之间无法直接访问对方的内存空间。因此，如果需要让不同进程之间进行数据交换或通信，就需要使用 IPC 机制。\n常见的 IPC 机制包括：\n\n管道（Pipe）：管道是一种半双工的通信方式，它创建一个管道文件用于进程间通信，一端用于写入数据，另一端用于读取数据。\n\n命名管道（Named Pipe）：命名管道是一种特殊的管道，它允许不同进程之间进行通信，而且不需要进程有亲缘关系（即不需要父子进程关系）。\n\n信号量（Semaphore）：信号量是一种计数器，用于控制多个进程对共享资源的访问。通过信号量，进程可以协调访问共享资源的顺序。\n\n共享内存（Shared Memory）：共享内存是一种允许不同进程之间共享内存空间的机制。进程可以将同一个内存区域映射到自己的地址空间中，从而实现共享。\n\n消息队列（Message Queue）：消息队列是一种用于在进程之间传递数据的机制。它允许进程向队列中写入数据，并从队列中读取数据。\n\n\n在不同的应用场景中，可以根据需求选择合适的 IPC 机制进行进程间通信。在 Node.js 中，也提供了多种 IPC 机制，例如使用管道、TCP、UDP 等方式进行进程间通信。\nelectron 与 html 端通信是多进程还是多线程Electron 与 HTML 端之间的通信是通过多进程实现的，具体来说，Electron 主进程和渲染进程分别运行在不同的进程中。\nElectron 主进程是 Node.js 进程，用于管理应用程序的整个生命周期，例如窗口管理、菜单管理、文件系统访问等。Electron 渲染进程则是基于 Chromium 的渲染进程，负责展示 HTML、CSS 和 JavaScript 内容。\n在 Electron 中，主进程与渲染进程之间的通信是通过 IPC（进程间通信）机制实现的。主进程和渲染进程之间可以互相发送消息，通过 ipcMain 和 ipcRenderer 模块进行监听和发送。\n在渲染进程中，我们可以使用 ipcRenderer 模块向主进程发送消息，例如：\nconst &#123; ipcRenderer &#125; &#x3D; require(&#39;electron&#39;);\n\nipcRenderer.send(&#39;message-from-renderer&#39;, &#123; data: &#39;hello from renderer&#39; &#125;);\n\nipcRenderer.on(&#39;message-from-main&#39;, (event, args) &#x3D;&gt; &#123;\n  console.log(args);\n&#125;);\n\n在主进程中，我们可以使用 ipcMain 模块来监听渲染进程发送过来的消息，并通过 event.sender.send() 方法向渲染进程发送消息，例如：\nconst &#123; ipcMain &#125; &#x3D; require(&#39;electron&#39;);\n\nipcMain.on(&#39;message-from-renderer&#39;, (event, args) &#x3D;&gt; &#123;\n  console.log(args);\n  event.sender.send(&#39;message-from-main&#39;, &#123; data: &#39;hello from main&#39; &#125;);\n&#125;);\n\n通过 IPC 机制，主进程和渲染进程可以互相发送消息并进行通信，从而实现了 Electron 应用程序的功能。需要注意的是，Electron 中的每个窗口都运行在自己的渲染进程中，因此在使用 Electron 开发应用程序时，需要考虑进程间通信的设计和优化。\nnodejs RPC 示例RPC（Remote Procedure Call）远程过程调用是一种分布式计算的通信方式，可以使得不同的进程或者机器之间进行函数调用。Node.js 中可以通过一些 RPC 框架实现 RPC，例如 zerorpc、node-rpc 等。\n以下是一个基于 node-rpc 的简单示例：\n服务端代码：\nconst rpc &#x3D; require(&#39;node-remote-ipc&#39;).connectToServer(&#39;my-rpc&#39;);\n\nfunction add(a, b, callback) &#123;\n  callback(null, a + b);\n&#125;\n\nrpc.expose(&#39;add&#39;, add);\n\n客户端代码：\nconst rpc &#x3D; require(&#39;node-remote-ipc&#39;).connectToServer(&#39;my-rpc&#39;);\n\nrpc.call(&#39;add&#39;, 2, 3, (err, result) &#x3D;&gt; &#123;\n  if (err) &#123;\n    console.error(err);\n  &#125; else &#123;\n    console.log(result); &#x2F;&#x2F; 输出 5\n  &#125;\n&#125;);\n\n这里的服务端通过 rpc.expose 方法将 add 函数暴露给客户端调用，客户端通过 rpc.call 方法调用服务端的 add 函数，并在回调函数中获取执行结果。需要注意的是，这里使用的是 node-remote-ipc 模块进行 RPC 通信，其底层实现是基于 node.js 的进程间通信机制实现的。\nRPC 与前后端请求类似是的，RPC 调用和前后端请求确实有些相似。在前后端请求中，客户端向服务器发送请求，服务器返回响应。类似地，在 RPC 中，客户端向远程服务器发送请求，远程服务器处理请求并返回响应。\n不同之处在于，RPC 是在进程或者机器之间进行通信的，而前后端请求则是在客户端和服务器之间进行通信的。此外，RPC 更加面向对象，它是对方法调用的封装，而前后端请求则更加面向资源。\nRPC 与前后端请求的区别RPC 和前后端请求确实有相似之处，但是它们的应用场景和实现方式有很大的区别。\nRPC（Remote Procedure Call）是一种进程间通信的技术，它允许客户端调用远程服务器上的某个服务或者方法，并且在客户端和服务器之间传输数据。RPC 的目的是让调用远程方法像调用本地方法一样简单。RPC 通常被用于分布式系统中，用于实现不同进程或者不同机器之间的方法调用和数据交换。\n而前后端请求则是指前端（如浏览器）向后端（如服务器）发起的请求，用于获取数据或执行某些操作。前后端请求通常采用 HTTP 协议进行通信，并且遵循 RESTful 设计原则。前后端请求通常用于 Web 应用程序中，用于实现客户端与服务器之间的数据交换和业务逻辑处理。\n总体来说，RPC 和前后端请求的区别在于应用场景和实现方式。RPC 主要用于分布式系统中不同进程或者不同机器之间的方法调用和数据交换，而前后端请求主要用于 Web 应用程序中客户端与服务器之间的数据交换和业务逻辑处理。\n用 HTTP 通信替代 RPC 可以吗可以，HTTP 通信可以用于替代 RPC 通信。事实上，一些 Web API 使用 HTTP 作为其通信协议，如 RESTful API。\n使用 HTTP 代替 RPC 通信具有一些优点和缺点。优点包括：\n\nHTTP 协议已经广泛使用，因此有很多现成的工具和库可以使用。\n\nHTTP 协议通常在防火墙中允许通过，因此可以更轻松地在不同的网络环境中使用。\n\n使用 HTTP 协议可以使用 Web 服务器处理请求，从而将负载分散到多个服务器上。\n\n\n缺点包括：\n\nHTTP 协议本质上是请求&#x2F;响应模式，需要在每个请求和响应之间建立新的连接，而 RPC 通信可以更快地建立长时间连接并传输多个请求和响应。\n\n使用 HTTP 协议时，必须处理各种 HTTP 状态码和请求头，这可能会导致一些额外的开销。\n\nHTTP 协议不支持直接序列化和反序列化复杂对象，因此需要使用额外的库来实现这些功能。\n\n\nnodejs 消息队列实现进程间通信Node.js 中的消息队列机制可以用来实现进程间通信。它的基本原理是通过在进程间传递消息，来实现数据的共享和通信。Node.js 中有多个实现消息队列的库，其中较为常见的包括：\n\nnode-ipc：一款基于 Unix 消息队列的 IPC 库。\nnanomsg：一个高性能、异步的消息队列库，支持多种通信模式和传输协议。\nzmq：又称 ZeroMQ，是一个高性能、异步的消息队列库，支持多种通信模式和传输协议。\n\n使用这些库可以非常方便地实现进程间通信。下面是一个使用 node-ipc 实现进程间通信的示例：\n&#x2F;&#x2F; 父进程\nconst ipc &#x3D; require(&#39;node-ipc&#39;);\n\nipc.config.id &#x3D; &#39;parent&#39;;\nipc.config.retry &#x3D; 1500;\nipc.config.silent &#x3D; true;\n\nipc.serve(() &#x3D;&gt; &#123;\n  ipc.server.on(&#39;message&#39;, (data, socket) &#x3D;&gt; &#123;\n    console.log(&#39;Parent received message: &#39;, data);\n    ipc.server.emit(socket, &#39;reply&#39;, &#39;Message received by parent&#39;);\n  &#125;);\n&#125;);\n\nipc.server.start();\n\n&#x2F;&#x2F; 子进程\nconst child &#x3D; require(&#39;child_process&#39;);\n\nconst childProcess &#x3D; child.fork(&#39;.&#x2F;child.js&#39;);\n\nchildProcess.on(&#39;message&#39;, (data) &#x3D;&gt; &#123;\n  console.log(&#39;Parent received message from child: &#39;, data);\n&#125;);\n\nsetInterval(() &#x3D;&gt; &#123;\n  childProcess.send(&#39;Ping from parent&#39;);\n&#125;, 3000);\n\n上述代码创建了一个父进程和一个子进程，它们之间通过 node-ipc 实现消息的收发。父进程启动一个 IPC 服务器，监听子进程发来的消息，子进程通过child_process模块的fork()方法创建，然后发送Ping from parent消息到父进程。父进程在收到子进程的消息后会打印输出，并回复一个消息给子进程，子进程也会在收到父进程的回复后打印输出。\nnode-ipc 消息队列通信与 ipc 通信的区别？node-ipc 是一个 Node.js 库，用于在进程间进行异步通信和传输数据。它可以在本地进程之间，也可以在不同主机之间传输消息。它提供了一组简单的 API，使得编写进程间通信应用变得更加容易。\n与 IPC（Inter-Process Communication，进程间通信）相比，node-ipc 的特点在于它基于消息队列实现，而 IPC 可以使用多种不同的通信方式（例如管道、信号量、共享内存等）。\n使用 node-ipc 可以方便地实现进程间通信，通过消息队列来传递数据，而无需手动处理复杂的底层通信细节。同时，它支持多种消息传输格式（例如 JSON、Buffer、字符串等），可以根据应用程序的需要选择合适的格式进行消息传递。\nnode-ipc、 nanomsg、zmq 比较node-ipc、nanomsg 和 zmq 都是可用于实现进程间通信的库，它们各自有不同的特点和适用场景。\n\nnode-ipc：这是一个专为 Node.js 设计的库，提供了易于使用的 API，可以使用不同的传输方式（如 UNIX 域套接字、TCP、UDP 等）实现进程间通信。它的设计重点是易用性和可靠性，因此适用于小型应用程序和通信需求不高的场景。\n\nnanomsg：这是一个跨平台的轻量级消息传递库，支持不同的通信模式（如 pub-sub、pair 等），可以使用不同的传输方式（如 IPC、TCP、inproc 等）实现进程间通信。它的设计重点是高性能和灵活性，适用于大型应用程序和对通信效率有要求的场景。\n\nzmq：这是一个高性能的、可扩展的消息传递库，支持不同的通信模式（如 pub-sub、req-rep 等），可以使用不同的传输方式（如 TCP、IPC、inproc 等）实现进程间通信。它的设计重点是可扩展性和高性能，适用于大型分布式系统和对通信效率有高要求的场景。\n\n\n因此，在选择这些库时，需要根据实际情况选择适合的库，例如，如果应用程序需要在 Node.js 中实现进程间通信，node-ipc 可能是更好的选择；如果应用程序需要高性能和灵活性，nanomsg 或 zmq 可能更适合。\nkafaka 属于进程间通信？Kafka 是一种分布式的消息队列系统，主要用于异步通信和处理大规模数据流。它不属于进程间通信，而是一种基于发布-订阅模式的消息传递系统，可以实现不同进程、不同系统之间的消息传递和数据共享。Kafka 使用了一些高级的分布式技术，例如分区、副本、消费者组等，保证了高吞吐量、高可靠性、高扩展性等特点。\n进程间通信与线程间通信的区别进程间通信和线程间通信都是实现多任务并发执行的方式，但是它们有以下几点区别：\n\n资源共享：进程间通信需要借助操作系统提供的 IPC 机制进行通信，资源共享相对困难。而线程间通信可以直接访问进程内的共享数据。\n\n效率：进程间通信效率相对较低，因为需要进行系统调用。而线程间通信效率较高，因为不需要跨进程调用。\n\n安全性：由于进程间的内存空间相互独立，进程间通信相对安全。而线程间通信需要注意同步和互斥，否则会引起竞态条件等问题。\n\n可扩展性：进程间通信可以在不同的机器上进行通信，因此具有很好的可扩展性。而线程间通信通常限于同一台机器上的进程内部。\n\n\n因此，进程间通信和线程间通信各有优缺点，选择合适的通信方式取决于具体应用场景。\n什么时候用线程通信，什么时候用进程通信在并发编程中，选择使用线程通信或进程通信主要取决于应用程序的特定需求和设计。以下是一些通用的指导原则：\n使用线程通信：\n\n当需要共享相同的内存空间时，例如，多个线程需要访问相同的数据结构。\n当需要高效地共享数据时，线程通信比进程通信更快。\n当应用程序需要在同一台机器上的不同部分之间进行通信时，例如，单个应用程序中的多个模块之间的通信。\n\n使用进程通信：\n\n当应用程序需要在不同的计算机上进行通信时，例如，分布式应用程序。\n当需要独立控制不同的进程时，例如，运行在一个沙箱中的应用程序。\n当进程需要使用不同的资源时，例如，一个进程需要访问数据库，另一个进程需要访问文件系统。\n\n需要注意的是，线程通信和进程通信各有优缺点，具体情况需要根据应用程序的需求进行选择。\nelectron 为什么不用线程通信的方式Electron 主要是使用 Chromium 和 Node.js 来构建跨平台的桌面应用程序，其中 Chromium 是基于多进程的架构来实现的。每个 Chromium 页面都在自己的进程中运行，称为“渲染进程”，而 Electron 应用程序本身也有自己的进程，称为“主进程”。因此，在 Electron 应用程序中使用进程间通信是一种更自然的选择。\n此外，线程间通信需要考虑同步和锁等问题，容易导致死锁和性能问题，而进程间通信则避免了这些问题。同时，使用多进程可以利用多核处理器的优势，更好地提高应用程序的性能。因此，使用进程间通信是 Electron 应用程序的一种比较合适的选择。\n线程通信方式有哪些见的线程通信方式有共享内存、消息传递、信号量、互斥量和条件变量等。\n\n其中共享内存是最快速的通信方式，但需要自行解决同步和互斥问题；\n消息传递可以采用同步或异步方式，不需要考虑同步问题，但传输数据需要进行序列化和反序列化。\n信号量、互斥量和条件变量则主要用于解决同步和互斥问题\n\nnodejs 共享内存 线程通信 SharedArrayBuffer 和 AtomicsNode.js 的线程是通过 Worker 模块来实现的，Worker 线程之间的通信可以使用共享内存来实现。具体来说，Node.js 提供了 SharedArrayBuffer 和 Atomics API 来支持多个线程之间的共享内存访问。\nSharedArrayBuffer 是一个特殊的 ArrayBuffer，它允许多个线程共享同一段内存空间。可以使用 new SharedArrayBuffer() 创建一个 SharedArrayBuffer 对象，然后使用 Worker 线程的 postMessage() 方法将这个对象发送给其他线程。\nAtomics API 是用来操作 SharedArrayBuffer 的 API。它提供了原子操作，可以确保多个线程在访问共享内存时不会互相干扰。可以使用 Atomics.load()、Atomics.store()、Atomics.add()、Atomics.sub()、Atomics.and()、Atomics.or()、Atomics.xor()、Atomics.exchange()、Atomics.compareExchange() 等方法来对共享内存中的数据进行操作。\n下面是一个使用共享内存进行线程通信的示例：\n&#x2F;&#x2F; worker.js\nconst &#123; parentPort, workerData, threadId &#125; &#x3D; require(&#39;worker_threads&#39;);\nconst &#123; SharedArrayBuffer, Atomics &#125; &#x3D; require(&#39;worker_threads&#39;);\n\n&#x2F;&#x2F; 接收主线程传来的共享内存\nconst sharedBuffer &#x3D; workerData.sharedBuffer;\n\n&#x2F;&#x2F; 从共享内存中读取数据\nconst data &#x3D; new Int32Array(sharedBuffer);\n\nconsole.log(&#96;worker $&#123;threadId&#125; got data: $&#123;data[0]&#125;, $&#123;data[1]&#125;&#96;);\n\n&#x2F;&#x2F; 修改共享内存中的数据\nAtomics.add(data, 0, 1);\nAtomics.sub(data, 1, 1);\n\n&#x2F;&#x2F; 将修改后的共享内存发送回主线程\nparentPort.postMessage(sharedBuffer);\n\n&#x2F;&#x2F; main.js\nconst &#123; Worker, isMainThread &#125; &#x3D; require(&#39;worker_threads&#39;);\nconst &#123; SharedArrayBuffer &#125; &#x3D; require(&#39;worker_threads&#39;);\n\nif (isMainThread) &#123;\n  const sharedBuffer &#x3D; new SharedArrayBuffer(8);\n\n  &#x2F;&#x2F; 在主线程中写入数据到共享内存\n  const data &#x3D; new Int32Array(sharedBuffer);\n  data[0] &#x3D; 1;\n  data[1] &#x3D; 2;\n\n  console.log(&#96;main thread send data: $&#123;data[0]&#125;, $&#123;data[1]&#125;&#96;);\n\n  &#x2F;&#x2F; 创建 Worker 线程，并将共享内存传递给它\n  const worker &#x3D; new Worker(__filename, &#123;\n    workerData: &#123;\n      sharedBuffer: sharedBuffer,\n    &#125;,\n  &#125;);\n\n  &#x2F;&#x2F; 接收 Worker 线程发送回来的共享内存，并打印出来\n  worker.on(&#39;message&#39;, (sharedBuffer) &#x3D;&gt; &#123;\n    const data &#x3D; new Int32Array(sharedBuffer);\n    console.log(&#96;main thread receive data: $&#123;data[0]&#125;, $&#123;data[1]&#125;&#96;);\n  &#125;);\n&#125; else &#123;\n  require(&#39;.&#x2F;worker.js&#39;);\n&#125;\n\n这个示例中，主线程创建了一个 SharedArrayBuffer，并将其中的数据写入到共享内存中。然后，它创建了一个 Worker 线程，并将共享内存传递给它。Worker 线程接收到共享内存后，从中读取出数据并打印出来，然后修改了其中的\nnodejs 消息传递方式进行线程通信 parentPort在 Node.js 中，可以使用消息传递方式进行线程通信。这种方式下，每个线程都拥有自己的消息队列，线程之间可以通过消息队列进行通信。\n具体而言，可以使用 worker_threads 模块创建新的线程，然后通过 worker.postMessage() 方法向线程发送消息。在接收线程中，可以监听 message 事件来处理从主线程发送过来的消息。\n以下是一个简单的示例，展示了如何在 Node.js 中使用消息传递方式进行线程通信：\n&#x2F;&#x2F; main.js\nconst &#123; Worker &#125; &#x3D; require(&#39;worker_threads&#39;);\n\n&#x2F;&#x2F; 创建新的线程\nconst worker &#x3D; new Worker(&#39;.&#x2F;worker.js&#39;);\n\n&#x2F;&#x2F; 监听 worker 线程的消息\nworker.on(&#39;message&#39;, (message) &#x3D;&gt; &#123;\n  console.log(&#96;Received message from worker: $&#123;message&#125;&#96;);\n&#125;);\n\n&#x2F;&#x2F; 向 worker 线程发送消息\nworker.postMessage(&#39;Hello from main thread!&#39;);\n\n&#x2F;&#x2F; worker.js\nconst &#123; parentPort &#125; &#x3D; require(&#39;worker_threads&#39;);\n\n&#x2F;&#x2F; 监听主线程的消息\nparentPort.on(&#39;message&#39;, (message) &#x3D;&gt; &#123;\n  console.log(&#96;Received message from main thread: $&#123;message&#125;&#96;);\n&#125;);\n\n&#x2F;&#x2F; 向主线程发送消息\nparentPort.postMessage(&#39;Hello from worker thread!&#39;);\n\n在这个示例中，主线程通过 worker.postMessage() 方法向工作线程发送消息，并监听工作线程发送的消息。工作线程也监听主线程发送的消息，并通过 parentPort.postMessage() 方法向主线程发送消息。\n需要注意的是，消息传递方式不同于共享内存和同步机制，因此需要使用序列化和反序列化来传递数据。在示例中，消息被自动序列化为字符串，然后在另一个线程中反序列化。因此，在使用消息传递方式进行线程通信时，需要注意数据类型的处理。\nnodejs 条件变量 方式进行线程通信 SharedArrayBuffer, Atomics在 Node.js 中，线程通信可以通过条件变量实现。条件变量是一种同步机制，用于在线程之间通信和协调。它允许一个或多个线程在满足某些条件之前等待，当条件满足时通知等待线程。\nNode.js 中条件变量通过 worker_threads 模块的 Atomics 和 SharedArrayBuffer API 来实现。Atomics.wait() 方法可以让线程等待在一个共享内存的地址上，直到其他线程在该地址上进行通知。\n下面是一个示例，展示了如何使用条件变量实现线程间通信。\nconst &#123; Worker, isMainThread, workerData, threadId, parentPort &#125; &#x3D; require(&#39;worker_threads&#39;);\nconst &#123; SharedArrayBuffer, Atomics &#125; &#x3D; require(&#39;worker_threads&#39;);\n\nif (isMainThread) &#123;\n  const sab &#x3D; new SharedArrayBuffer(4);\n  const ia &#x3D; new Int32Array(sab);\n  const worker &#x3D; new Worker(__filename, &#123;\n    workerData: sab,\n  &#125;);\n  Atomics.store(ia, 0, 0);\n  setInterval(() &#x3D;&gt; &#123;\n    Atomics.add(ia, 0, 1);\n    console.log(&#96;Main thread incremented value to $&#123;ia[0]&#125;&#96;);\n  &#125;, 1000);\n  worker.on(&#39;message&#39;, (msg) &#x3D;&gt; &#123;\n    console.log(&#96;Main thread received message: $&#123;msg&#125;&#96;);\n  &#125;);\n&#125; else &#123;\n  const sab &#x3D; workerData;\n  const ia &#x3D; new Int32Array(sab);\n  const cv &#x3D; new Int32Array(sab, 4, 1);\n  setInterval(() &#x3D;&gt; &#123;\n    if (Atomics.load(ia, 0) &#x3D;&#x3D;&#x3D; 5) &#123;\n      Atomics.store(cv, 0, 1);\n      parentPort.postMessage(&#39;Notified main thread&#39;);\n    &#125;\n  &#125;, 1000);\n  Atomics.store(cv, 0, 0);\n  while (Atomics.load(cv, 0) &#x3D;&#x3D;&#x3D; 0) &#123;\n    Atomics.wait(cv, 0);\n  &#125;\n&#125;\n\n这个例子中，主线程和工作线程共享了一个 4 字节的内存块，并且主线程每秒钟增加一次该值。工作线程在一个循环中等待，直到主线程将该值增加到 5，然后使用条件变量通知主线程。主线程在接收到通知后，输出一个消息。\n条件变量方式与共享内存方式看上去一样？条件变量和共享内存是两种不同的线程通信方式，它们的实现机制和使用方法有很大的不同。\n条件变量是线程同步机制的一种，用于线程之间的通信。在使用条件变量时，一般是先加锁，然后等待某个条件变量被满足，如果条件不满足，则释放锁并等待，直到条件被满足后再重新加锁。在等待过程中，线程是阻塞的，不占用 CPU 资源。条件变量常常和互斥锁一起使用，实现线程同步和互斥。\n共享内存是另一种线程通信方式，它可以使多个线程访问同一块物理内存，实现数据共享。多个线程可以在内存中读取和修改同一个变量，这种方式比较高效，但也需要注意多线程访问时的并发控制，避免数据的竞争和冲突。\n因此，条件变量和共享内存虽然都可以实现线程间通信，但是它们的实现机制和应用场景是不同的，需要根据具体的需求选择合适的方式。\n条件变量方式与共享内存 都是通过 SharedArrayBuffer, Atomics 实现的尽管条件变量和共享内存都可以使用 SharedArrayBuffer 和 Atomics 来实现，但它们的使用场景和原理是不同的。\n\n条件变量主要用于实现线程同步和通信，\n共享内存主要用于实现数据共享和同步。\n\n多进程，多线程，与同步是否冲突多进程、多线程和同步并不一定冲突。在并发编程中，进程和线程可以通过同步机制来实现协作和同步。同步机制可以保证在多个线程或进程中对共享资源的访问是有序的和互斥的，从而避免了竞态条件和数据不一致等问题。\n在实际应用中，根据需求和特点可以选择不同的并发模型和同步机制。例如，\n\n多线程适用于需要高并发、多计算任务和数据共享的场景；\n多进程适用于需要高可用性和稳定性、有多个独立的工作任务或需要利用多核 CPU 的场景；\n同步机制则可以通过锁、条件变量、信号量等来实现。\n\n虽然同步机制可以提高并发编程的安全性和正确性，但过多的同步机制也会降低程序的性能和并发度。因此，在实际应用中需要根据具体情况选择适当的并发模型和同步机制，以达到合适的并发度和性能。\n性能比较nodejs 与 java 性能比较Node.js 和 Java 都是非常流行的后端开发语言，它们都有自己的优势和特点。\n一方面，Node.js 是基于 V8 引擎的 JavaScript 运行时，其主要优势在于对 I&#x2F;O 密集型应用的处理能力非常出色，能够处理大量并发的 I&#x2F;O 操作，例如处理大量的 HTTP 请求、WebSocket 连接等。由于其单线程的特性，Node.js 也具有很好的响应能力和低延迟的优势。\n另一方面，Java 是一种编译型语言，其主要优势在于其强大的性能和多线程能力。Java 能够在多核 CPU 上运行，利用多线程技术来提高并发处理能力。Java 还具有非常丰富的库和框架，支持构建大型、复杂的分布式系统和企业应用。\n因此，Node.js 和 Java 在性能和应用场景方面存在一定的差异。对于 I&#x2F;O 密集型应用，Node.js 是非常适合的选择，而对于计算密集型应用，Java 通常会表现得更出色。同时，对于复杂的分布式系统和企业应用，Java 通常会是更好的选择，因为它有更好的支持和成熟的技术栈。\n需要注意的是，性能并不是唯一的选择标准，还需要考虑开发成本、维护成本、生态和人才等方面的因素。在实际选择时，需要根据具体的应用场景和需求进行权衡。\nnodejs 也可以多线程啊是的，Node.js 支持多线程，但是需要使用 worker_threads 模块来实现多线程。使用 worker_threads 可以在 Node.js 中创建和管理多个线程，从而提高 CPU 密集型应用程序的性能。但是需要注意，Node.js 的单线程模型是为了避免锁等并发问题，使用多线程需要开发者自己保证线程安全，同时多线程的实现也比较复杂，需要注意线程间通信和数据同步等问题。\nnodejs 多线程和 java 多线程哪个性能更高这个问题不好简单回答。性能取决于很多因素，如应用程序的特定需求，操作系统的类型和版本，硬件配置，代码实现等等。同时，多线程编程的性能比单线程编程更为复杂，因为需要考虑线程同步、锁定、上下文切换等问题，这些都可能影响应用程序的性能。\n在一些特定的场景下，Node.js 的多线程实现和 Java 的多线程实现可能会有不同的表现。例如，当涉及到大量计算密集型操作时，Java 的多线程实现可能会更快，因为 Java 中的线程是真正的操作系统线程，而 Node.js 中的线程则是通过 JavaScript 运行时模拟的线程。然而，对于一些 IO 密集型的应用程序，Node.js 的异步 I&#x2F;O 模型和事件驱动的架构可以提供更高的性能。\n综上所述，没有哪种编程语言或多线程实现是绝对更快的，性能取决于应用程序的需求和实现。\nNode.js 中的线程则是通过 JavaScript 运行时模拟的线程？在 Node.js 中，线程是由 libuv 库来实现的，这个库是一个跨平台的异步 I&#x2F;O 库，它将操作系统提供的线程、线程池、事件机制等底层机制进行封装和抽象，向上层应用程序提供了一个高效的异步 I&#x2F;O 框架。Node.js 中的线程是由 libuv 库来管理和调度的，JavaScript 运行时并不直接控制线程的创建和销毁。所以，可以说 Node.js 中的线程是通过 libuv 库来实现的。\nlibuv 不是真正的操作系统线程？是的，libuv 并不是真正的操作系统线程。libuv 实现了一种称为“线程池”的技术，可以在一个或多个操作系统线程中调度多个 JavaScript 线程。这种线程池的实现方式类似于 Java 中的线程池，线程的创建和销毁由线程池管理，从而避免了频繁的创建和销毁线程的开销，提高了应用程序的性能。\n在 libuv 的实现中，每个 JavaScript 线程都对应一个事件循环，事件循环是单线程运行的，但是它通过底层的线程池机制实现了对多个 JavaScript 线程的调度和管理。这种实现方式在保证高性能的同时，也能够充分发挥 JavaScript 单线程的优势，使得编写高性能、高并发的 Node.js 应用程序变得更加容易。\n在处理 大量计算密集型操作时，golang 和 java 哪个性能更高通常情况下，处理大量计算密集型操作时，Java 和 Golang 都可以提供高性能的解决方案。\nJava 可以通过 JIT 编译器优化代码性能，还有一些开源库提供了高效的并发编程支持。在 Java 8 中引入的 lambda 表达式和函数式编程特性也使得并发编程更加便捷。\nGolang 则是一门专为高并发而生的编程语言，具有轻量级的协程和通道，可以非常方便地进行并发编程。此外，Golang 的垃圾回收机制、并发模型和内存管理等方面的设计也有助于提高性能。\n因此，选择 Java 还是 Golang 取决于具体的应用场景和需求。如果应用需要在大量的并发请求下保持高性能，Golang 可能更适合；如果应用需要使用大量的第三方库和复杂的企业级解决方案，Java 可能更合适。\n","slug":"2023-05-08进程线程","date":"2023-05-08T02:42:06.000Z","categories_index":"nodejs","tags_index":"chatGPT2021,nodejs","author_index":"举手摘月亮"},{"id":"63b21671e504fbf555fa8354eb1a75b6","title":"Python 编程语言的基本语法","content":"动机用不用的着我就想学，咋滴～，距去年国庆学的 Python 和 Django 有半年了，原计划五一劳动节再学一遍 Python 的，结果呢–看“仙侠剧”、搓饭、遛猫（真的是遛猫不是遛狗），五一就没了，😅\n理解 python 特性Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。\nPython 的设计具有很强的可读性，它具有比其他语言更有特色语法结构。\n语法Python 是一种简单易学、可读性强的编程语言，它的语法也相对简单。下面是 Python 基本语法的介绍：\n\n注释\n\nPython 中的注释以 # 开头，可以在代码中添加说明和解释。例如：\n# 这是一条注释\n\nprint(&quot;Hello, world!&quot;)  # 这也是一条注释\n\n\n变量\n\nPython 中的变量名可以包含字母、数字和下划线，但不能以数字开头。变量名区分大小写。例如：\nx &#x3D; 1\ny &#x3D; 2\nz &#x3D; &quot;hello&quot;\n\n\n数据类型\n\nPython 支持多种数据类型，包括整数、浮点数、字符串、布尔值、列表、元组、字典等。例如：\na &#x3D; 1  # 整数\nb &#x3D; 3.14  # 浮点数\nc &#x3D; &quot;hello&quot;  # 字符串\nd &#x3D; True  # 布尔值\ne &#x3D; [1, 2, 3]  # 列表\nf &#x3D; (4, 5, 6)  # 元组\ng &#x3D; &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20&#125;  # 字典\n\n\n控制流语句\n\nPython 中的控制流语句包括条件语句和循环语句。条件语句使用 if、elif 和 else 关键字，循环语句使用 for 和 while 关键字。例如：\n# 条件语句\nx &#x3D; 10\nif x &gt; 0:\n    print(&quot;x is positive&quot;)\nelif x &#x3D;&#x3D; 0:\n    print(&quot;x is zero&quot;)\nelse:\n    print(&quot;x is negative&quot;)\n\n# 循环语句\nfor i in range(5):\n    print(i)\n\nwhile x &gt; 0:\n    x -&#x3D; 1\n    print(x)\n\n\n函数\n\nPython 中使用 def 关键字定义函数，函数可以接受参数和返回值。例如：\ndef add(x, y):\n    return x + y\n\nresult &#x3D; add(1, 2)\nprint(result)\n\n以上是 Python 编程语言的基本语法介绍，掌握这些基础语法后，可以开始编写简单的 Python 程序。\n字符串格式化 4 种方式在 Python 3 中，有多种方式可以进行字符串格式化。以下是一些常见的字符串格式化方法：\n\n使用百分号（%）格式化字符串：\n\nname &#x3D; &quot;John&quot;\nage &#x3D; 30\nmessage &#x3D; &quot;My name is %s and I am %d years old.&quot; % (name, age)\nprint(message)\n\n输出：\nMy name is John and I am 30 years old.\n\n\n使用大括号（{}）和 format() 方法格式化字符串：\n\nname &#x3D; &quot;John&quot;\nage &#x3D; 30\nmessage &#x3D; &quot;My name is &#123;&#125; and I am &#123;&#125; years old.&quot;.format(name, age)\nprint(message)\n\n输出：\nMy name is John and I am 30 years old.\n\n\n使用 f-string（格式化字符串字面值）：\n\nname &#x3D; &quot;John&quot;\nage &#x3D; 30\nmessage &#x3D; f&quot;My name is &#123;name&#125; and I am &#123;age&#125; years old.&quot;\nprint(message)\n\n输出：\nMy name is John and I am 30 years old.\n\n\n使用模板字符串：\n\nfrom string import Template\n\nname &#x3D; &quot;John&quot;\nage &#x3D; 30\ntemplate &#x3D; Template(&quot;My name is $name and I am $age years old.&quot;)\nmessage &#x3D; template.substitute(name&#x3D;name, age&#x3D;age)\nprint(message)\n\n输出：\nMy name is John and I am 30 years old.\n\n这些是 Python 3 中常用的字符串格式化方法。每种方法都有自己的特点和用法，你可以根据需要选择适合的方式来格式化字符串。请注意，f-string 是 Python 3.6 引入的新特性，它提供了一种简洁且直观的字符串格式化语法。\n字符串内置函数分类字符串在 Python 中是不可变的对象，它提供了许多内置函数来操作和处理字符串。这些内置函数可以按照功能进行分类，以下是字符串内置函数的常见分类：\n\n访问和索引：\n\n\nlen(): 返回字符串的长度。\n索引和切片操作：可以通过索引或切片来访问字符串中的单个字符或子串。\n\n\n查找和匹配：\n\n\nfind(): 在字符串中查找指定的子串，并返回第一个匹配的索引。\nindex(): 类似于 find()，但如果找不到匹配的子串，会抛出异常。\ncount(): 统计字符串中指定子串的出现次数。\nstartswith(): 检查字符串是否以指定的子串开头。\nendswith(): 检查字符串是否以指定的子串结尾。\nreplace(): 替换字符串中的子串。\nsplit(): 将字符串拆分为子串，并返回一个列表。\njoin(): 将多个字符串连接成一个字符串。\n\n\n大小写转换：\n\n\nlower(): 将字符串转换为小写。\nupper(): 将字符串转换为大写。\ncapitalize(): 将字符串首字母大写。\ntitle(): 将字符串中每个单词的首字母大写。\n\n\n格式化和对齐：\n\n\nformat(): 格式化字符串，用于替换占位符。\nstrip(): 去除字符串两端的空白字符。\nlstrip(): 去除字符串左侧的空白字符。\nrstrip(): 去除字符串右侧的空白字符。\ncenter(): 将字符串居中对齐。\nljust(): 将字符串左对齐。\nrjust(): 将字符串右对齐。\n\n\n判断字符类型：\n\n\nisdigit(): 判断字符串是否只包含数字字符。\nisalpha(): 判断字符串是否只包含字母字符。\nisalnum(): 判断字符串是否只包含字母和数字字符。\nislower(): 判断字符串中的字母是否都为小写。\nisupper(): 判断字符串中的字母是否都为大写。\nisspace(): 判断字符串是否只包含空白字符。\n\n这只是字符串内置函数的一部分，还有其他一些函数可以用于字符串操作。根据需要选择适当的函数来处理和操作字符串，可以实现各种字符串处理的需求。\n元组元组使用场景元组是 Python 中的不可变序列，它可以包含多个元素，并且元素的顺序是固定的。元组在以下场景中非常有用：\n\n定义不可变数据集合：由于元组是不可变的，它们适合用于表示不可修改的数据集合。例如，你可以使用元组来表示一组坐标点、一组配置参数或者一组常量值。\n\n函数返回多个值：函数可以返回多个值，而元组是一种便捷的方式来组织和返回多个值。函数可以将这些值封装在一个元组中，并且调用函数的代码可以使用元组解包来获取这些值。\n\n解构赋值：元组可以在解构赋值中使用，它们可以方便地将一个序列的元素分解为多个变量。这在交换变量的值、并行迭代和函数返回多个值时非常有用。\n\n作为字典的键：字典中的键必须是可哈希的，而元组是不可变的，因此可以用作字典中的键。这对于需要将多个值映射到特定结果的情况很有用。\n\n函数参数传递：元组可以作为函数的参数进行传递，以便将多个值一起传递给函数。这对于需要将多个相关参数传递给函数的情况很有用。\n\n\n需要注意的是，由于元组是不可变的，无法对其进行修改。如果需要在运行时修改数据，应使用列表。元组更适合用于表示静态数据和不可变的集合。\n总的来说，元组是一种用于存储不可变数据集合的数据结构，在多个值的组织、多个返回值的情况下以及作为字典键等方面非常有用。\n元组操作元组是 Python 中的不可变序列，具有以下操作和特性：\n创建元组：\n使用逗号分隔的值来创建元组：my_tuple = (1, 2, 3)\n使用圆括号创建元组：my_tuple = tuple((1, 2, 3))\n\n访问元组元素：\n使用索引访问元组中的特定元素：print(my_tuple[0])，输出为 1\n可以使用负数索引从后向前访问元素：print(my_tuple[-1])，输出为 3\n\n切片操作：\n使用切片操作访问元组的子集：print(my_tuple[1:3])，输出为 (2, 3)\n可以指定步长：print(my_tuple[::2])，输出为 (1, 3)\n\n元组拼接：\n使用加号操作符将两个元组拼接在一起：new_tuple = my_tuple + (4, 5)\n\n元组解包：\n可以将元组的元素解包到多个变量中：x, y, z = my_tuple\n\n长度和计数：\n使用 len() 函数获取元组的长度：length = len(my_tuple)\n使用 count() 方法计算元素在元组中的出现次数：count = my_tuple.count(2)\n\n元组不可变性：\n元组的元素不可被修改，如果尝试修改元组中的元素，将会引发 TypeError。\n\n需要注意的是，元组是不可变的，一旦创建就无法修改其中的元素。如果需要修改元素，应该使用列表。元组主要用于存储静态数据和不可变的集合。\n以上是一些常见的元组操作和用法。通过这些操作，你可以创建、访问和操作元组中的数据。\n元组内置函数元组是 Python 中的不可变序列，它具有一些内置函数可用于处理和操作元组。以下是一些常用的元组内置函数：\nlen(tuple)：返回元组中元素的个数。my_tuple &#x3D; (1, 2, 3, 4, 5)\nlength &#x3D; len(my_tuple)\nprint(length)  # 输出 5\n\ntuple(iterable)：将可迭代对象转换为元组。my_list &#x3D; [1, 2, 3, 4, 5]\nmy_tuple &#x3D; tuple(my_list)\nprint(my_tuple)  # 输出 (1, 2, 3, 4, 5)\n\ncount(value)：返回元组中指定值的出现次数。my_tuple &#x3D; (1, 2, 2, 3, 2, 4, 2)\ncount &#x3D; my_tuple.count(2)\nprint(count)  # 输出 4\n\nindex(value)：返回元组中指定值第一次出现的索引位置。my_tuple &#x3D; (1, 2, 3, 4, 5)\nindex &#x3D; my_tuple.index(3)\nprint(index)  # 输出 2\n\n这些是元组的一些常用内置函数，它们可用于获取元组的长度、转换为元组、计算指定值的出现次数以及查找指定值的索引位置。除了这些内置函数，元组还可以使用切片操作、拼接操作等进行处理和操作。\n元组中的项无法删除？在 Python 中，元组是不可变的数据类型，这意味着一旦创建了元组，就无法修改或删除其中的项。元组的不可变性是其特性之一。\n如果你想删除元组中的特定项，你需要创建一个新的元组，并排除需要删除的项。例如，你可以使用切片操作来创建一个不包含要删除项的新元组：\nmy_tuple &#x3D; (1, 2, 3, 4, 5)\nnew_tuple &#x3D; my_tuple[:2] + my_tuple[3:]\nprint(new_tuple)  # 输出 (1, 2, 4, 5)\n\n在上面的例子中，我们创建了一个新的元组 new_tuple，通过切片操作排除了索引为 2 的项（值为 3）。这样就实现了在元组中删除特定项的效果。\n需要注意的是，虽然可以通过切片操作创建一个新的元组来达到删除项的目的，但实际上并没有删除原始元组中的项。由于元组的不可变性，无法直接在原始元组中删除或修改项。因此，如果需要频繁地进行删除或修改操作，可能更适合使用列表（List）数据类型，因为列表是可变的。\n字典字典内置函数&amp;方法字典是 Python 中的一种数据结构，它存储键值对的映射关系。字典具有许多内置函数和方法，可以用于处理和操作字典。下面是一些常用的字典内置函数和方法：\n内置函数：\nlen(dict)：返回字典中键值对的数量。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nlength &#x3D; len(my_dict)\nprint(length)  # 输出 3\n\nstr(dict)：将字典转换为可打印的字符串表示。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nstr_dict &#x3D; str(my_dict)\nprint(str_dict)  # 输出 &quot;&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;&quot;\n\ndict()：创建一个新的字典或将可迭代对象转换为字典。new_dict &#x3D; dict()\nprint(new_dict)  # 输出 &#123;&#125;\n\n字典方法：\nkeys()：返回一个包含字典所有键的视图对象。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nkeys &#x3D; my_dict.keys()\nprint(keys)  # 输出 dict_keys([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\n\nvalues()：返回一个包含字典所有值的视图对象。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nvalues &#x3D; my_dict.values()\nprint(values)  # 输出 dict_values([1, 2, 3])\n\nitems()：返回一个包含字典所有键值对的视图对象。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nitems &#x3D; my_dict.items()\nprint(items)  # 输出 dict_items([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])\n\nget(key, default)：获取指定键的值，如果键不存在，则返回默认值。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nvalue &#x3D; my_dict.get(&#39;a&#39;, 0)\nprint(value)  # 输出 1\nvalue &#x3D; my_dict.get(&#39;d&#39;, 0)\nprint(value)  # 输出 0\n\nsetdefault(key, default)：返回指定键的值，如果键不存在，则插入指定的键值对，并返回默认值。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\nvalue &#x3D; my_dict.setdefault(&#39;c&#39;, 3)\nprint(value) # 输出 3\nprint(my_dict) # 输出 &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n\nclear()：清空字典中的所有键值对，使字典变为空字典。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nmy_dict.clear()\nprint(my_dict)  # 输出 &#123;&#125;\n\ncopy()：创建字典的浅拷贝（shallow copy）。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nnew_dict &#x3D; my_dict.copy()\nprint(new_dict)  # 输出 &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n\nupdate()：将一个字典的键值对添加到另一个字典中，如果键存在，则更新对应的值。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\nother_dict &#x3D; &#123;&#39;c&#39;: 3, &#39;d&#39;: 4&#125;\nmy_dict.update(other_dict)\nprint(my_dict)  # 输出 &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;\n\npop(key, default)：移除并返回指定键的值，如果键不存在，则返回默认值。如果不提供默认值且键不存在，则会引发 KeyError。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nvalue &#x3D; my_dict.pop(&#39;a&#39;)\nprint(value)  # 输出 1\nvalue &#x3D; my_dict.pop(&#39;d&#39;, 0)\nprint(value)  # 输出 0\n\npopitem()：移除并返回字典中的一对键值对。字典是无序的，所以不保证具体移除的是哪个键值对。my_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nkey, value &#x3D; my_dict.popitem()\nprint(key, value)  # 输出 &#39;c&#39;, 3\n\n这些方法提供了对字典进行操作和管理的更多选项。通过它们，你可以清空字典、创建拷贝、更新键值对、移除键值对等。这些方法可以根据你的需求来选择和使用。\nkey in dict 是一个用于判断字典中是否存在指定键的成员运算符。它返回一个布尔值，如果字典中包含指定的键，则返回 True，否则返回 False。下面是示例代码：\nmy_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n\nprint(&#39;a&#39; in my_dict)  # 输出 True\nprint(&#39;d&#39; in my_dict)  # 输出 False\n\n在上面的例子中，我们使用 in 运算符来判断字典 my_dict 中是否存在键 &#39;a&#39; 和 &#39;d&#39;。由于字典中包含键 &#39;a&#39;，因此第一个判断返回 True；而字典中不包含键 &#39;d&#39;，所以第二个判断返回 False。\n使用 key in dict 这个成员运算符是一种简洁且常用的方式来检查字典中是否存在指定的键。\n集合集合使用场景集合（Set）是 Python 中的一种无序且不重复的数据结构。集合内的元素是唯一的，没有顺序。集合提供了一些特殊的操作，使其在某些场景下非常有用。以下是集合的一些常见使用场景：\n1. 去重：由于集合中的元素是唯一的，可以使用集合来快速去除列表或其他可迭代对象中的重复元素。my_list &#x3D; [1, 2, 2, 3, 4, 4, 5]\nmy_set &#x3D; set(my_list)\nprint(my_set)  # 输出 &#123;1, 2, 3, 4, 5&#125;\n\n2. 成员检查：集合提供了高效的成员检查操作，可以快速判断一个元素是否存在于集合中。my_set &#x3D; &#123;1, 2, 3, 4, 5&#125;\nprint(3 in my_set)  # 输出 True\nprint(6 in my_set)  # 输出 False\n\n3. 集合运算：集合支持并集、交集、差集等常见的集合运算，可以方便地进行集合间的操作。set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7, 8&#125;\nunion &#x3D; set1 | set2  # 并集\nintersection &#x3D; set1 &amp; set2  # 交集\ndifference &#x3D; set1 - set2  # 差集\nprint(union)  # 输出 &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;\nprint(intersection)  # 输出 &#123;4, 5&#125;\nprint(difference)  # 输出 &#123;1, 2, 3&#125;\n\n4. 集合操作：集合支持添加元素、删除元素等操作，可以动态地修改集合内容。my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.add(4)  # 添加元素\nmy_set.remove(2)  # 删除元素\nprint(my_set)  # 输出 &#123;1, 3, 4&#125;\n\n这些是集合的一些常见使用场景。总的来说，当你需要处理无序且不重复的数据，或者需要进行成员检查、集合运算等操作时，集合是一个非常有用的数据结构。\n集合内置方法完整列表 及 示例下面是集合（Set）的完整内置方法列表以及示例：\nadd(element): 向集合中添加一个元素。my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.add(4)\nprint(my_set)  # 输出 &#123;1, 2, 3, 4&#125;\n\nclear(): 清空集合中的所有元素。my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.clear()\nprint(my_set)  # 输出 set()\n\ncopy(): 创建集合的浅拷贝（shallow copy）。my_set &#x3D; &#123;1, 2, 3&#125;\nnew_set &#x3D; my_set.copy()\nprint(new_set)  # 输出 &#123;1, 2, 3&#125;\n\ndifference(*others): 返回当前集合与其他集合的差集，即在当前集合中但不在其他集合中的元素组成的集合。set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\ndiff &#x3D; set1.difference(set2)\nprint(diff)  # 输出 &#123;1, 2, 3&#125;\n\ndifference_update(*others): 移除当前集合中与其他集合的交集，即在当前集合中同时存在于其他集合中的元素。set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nset1.difference_update(set2)\nprint(set1)  # 输出 &#123;1, 2, 3&#125;\n\ndiscard(element): 移除集合中指定的元素，如果元素不存在，不会引发错误。my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.discard(2)\nprint(my_set)  # 输出 &#123;1, 3&#125;\nmy_set.discard(4)\nprint(my_set)  # 输出 &#123;1, 3&#125;\n\nintersection(*others): 返回当前集合与其他集合的交集，即同时存在于所有集合中的元素组成的集合。set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nintersection &#x3D; set1.intersection(set2)\nprint(intersection)  # 输出 &#123;4, 5&#125;\n\nintersection_update(*others): 保留当前集合与其他集合的交集，移除不在交集中的元素。set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nset1.intersection_update(set2)\nprint(set1)  # 输出 &#123;4, 5&#125;\n\nisdisjoint(other): 判断当前集合与另一个集合是否没有共同的元素，如果没有返回 True，否则返回 False。set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;4, 5, 6&#125;\nprint(set1.isdisjoint(set2))  # 输出 True\nset3 &#x3D; &#123;3, 4, 5&#125;\nprint(set1.isdisjoint(set3))  # 输出 False\n\nissubset(other): 判断当前集合是否是另一个集合的子集，如果是返回 True，否则返回 False。set1 &#x3D; &#123;1, 2&#125;\nset2 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nprint(set1.issubset(set2))  # 输出 True\nset3 &#x3D; &#123;3, 4, 5&#125;\nprint(set1.issubset(set3))  # 输出 False\n\nissuperset(other): 判断当前集合是否是另一个集合的超集，如果是返回 True，否则返回 False。set1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;1, 2&#125;\nprint(set1.issuperset(set2))  # 输出 True\nset3 &#x3D; &#123;3, 4, 5&#125;\nprint(set1.issuperset(set3))  # 输出 True\n\npop(): 随机移除并返回集合中的一个元素，如果集合为空会引发 KeyError 错误。my_set &#x3D; &#123;1, 2, 3, 4, 5&#125;\nelement &#x3D; my_set.pop()\nprint(element)  # 输出随机移除的元素\nprint(my_set)  # 输出移除元素后的集合\n\nremove(element): 移除集合中指定的元素，如果元素不存在，会引发 KeyError 错误。my_set &#x3D; &#123;1, 2, 3&#125;\nmy_set.remove(2)\nprint(my_set)  # 输出 &#123;1, 3&#125;\nmy_set.remove(4)  # 会引发 KeyError 错误\n\nsymmetric_difference(other): 返回当前集合与另一个集合的对称差集，即在当前集合或其他集合中但不同时存在的元素组成的集合。set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nsym_diff &#x3D; set1.symmetric_difference(set2)\nprint(sym_diff)  # 输出 &#123;1, 2, 4, 5&#125;\n\nsymmetric_difference_update(other): 更新当前集合为当前集合与另一个集合的对称差集。set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nset1.symmetric_difference_update(set2)\nprint(set1)  # 输出 &#123;1, 2, 4, 5&#125;\n\nunion(*others): 返回当前集合与其他集合的并集，即包含所有集合中的元素的集合。set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nunion &#x3D; set1.union(set2)\nprint(union)  # 输出 &#123;1, 2, 3, 4, 5&#125;\n\nupdate(*others): 将其他集合中的元素添加到当前集合中。set1 &#x3D; &#123;1, 2, 3&#125;\nset2 &#x3D; &#123;3, 4, 5&#125;\nset1.update(set2)\nprint(set1)  # 输出 &#123;1, 2, 3, 4\n\n## intersection 与 intersection_update 区别\n\n&#96;intersection&#96; 和 &#96;intersection_update&#96; 是集合（Set）的两个方法，用于计算集合间的交集。\n\n区别如下：\n\n- &#96;intersection&#96;: 该方法返回一个新的集合，包含当前集合与其他集合的交集元素。原始集合不会被修改。\n\n&#96;&#96;&#96;python\nset1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nintersection &#x3D; set1.intersection(set2)\nprint(intersection)  # 输出 &#123;4, 5&#125;\nprint(set1)  # 输出 &#123;1, 2, 3, 4, 5&#125;，原始集合不变\n\n\nintersection_update: 该方法会修改当前集合，使其只包含与其他集合的交集元素，原始集合会被更新。\n\nset1 &#x3D; &#123;1, 2, 3, 4, 5&#125;\nset2 &#x3D; &#123;4, 5, 6, 7&#125;\nset1.intersection_update(set2)\nprint(set1)  # 输出 &#123;4, 5&#125;，原始集合被修改\n\n需要注意的是，intersection 方法返回一个新的集合，不会修改原始集合。而 intersection_update 方法会直接修改当前集合，使其变为交集结果。\n根据实际需求，选择合适的方法来计算集合的交集。如果需要保留原始集合，同时获得交集结果，可以使用 intersection 方法。如果只关心得到交集结果并修改当前集合，可以使用 intersection_update 方法。\n条件控制if…elif … elsePython 3 中的条件控制主要使用 if、elif 和 else 语句来实现。下面是 Python 3 的条件控制语法和示例：\nif 语句：\nif condition:\n    # 执行条件为真时的代码块\nelse:\n    # 执行条件为假时的代码块\n\n示例：\nx &#x3D; 10\nif x &gt; 5:\n    print(&quot;x 大于 5&quot;)\nelse:\n    print(&quot;x 不大于 5&quot;)\n\nif-elif-else 语句：\nif condition1:\n    # 执行条件1为真时的代码块\nelif condition2:\n    # 执行条件2为真时的代码块\nelse:\n    # 执行所有条件都为假时的代码块\n\n示例：\nx &#x3D; 10\nif x &gt; 10:\n    print(&quot;x 大于 10&quot;)\nelif x &lt; 10:\n    print(&quot;x 小于 10&quot;)\nelse:\n    print(&quot;x 等于 10&quot;)\n\n嵌套的 if 语句：\nif condition1:\n    # 执行条件1为真时的代码块\n    if condition2:\n        # 执行条件2为真时的代码块\nelse:\n    # 执行条件1为假时的代码块\n\n示例：\nx &#x3D; 10\nif x &gt; 5:\n    print(&quot;x 大于 5&quot;)\n    if x &gt; 8:\n        print(&quot;x 大于 8&quot;)\nelse:\n    print(&quot;x 不大于 5&quot;)\n\n以上是 Python 3 中常用的条件控制语句，可以根据具体的需求和条件编写适当的代码块来实现不同的逻辑。\nmatch…casematch...case 是 Python 3.10 引入的新特性，用于替代原先的 if...elif...else 或 dict.get() 实现分支语句，提高代码可读性和表达能力。match...case 的语法格式如下：\nmatch value:\n    case pattern1:\n        # 执行匹配 pattern1 成功时的代码块\n    case pattern2:\n        # 执行匹配 pattern2 成功时的代码块\n    ...\n    case _:\n        # 执行所有 pattern 都匹配失败时的代码块\n\n其中 value 表示要匹配的值，pattern 表示匹配的模式。如果 value 和 pattern 匹配成功，则执行对应的代码块，否则继续匹配下一个 case，如果所有的 case 都匹配失败，则执行 _ 对应的代码块。\nmatch...case 支持的模式有很多种，包括常量模式、变量模式、位置模式、类型模式、结构模式等，可以根据具体的需求和数据类型选择合适的模式。下面是 match...case 的示例代码：\ndef get_color_name(color_code):\n    match color_code:\n        case 0:\n            return &quot;Black&quot;\n        case 1:\n            return &quot;Red&quot;\n        case 2:\n            return &quot;Green&quot;\n        case 3:\n            return &quot;Yellow&quot;\n        case _:\n            return &quot;Unknown&quot;\n\nprint(get_color_name(1))  # 输出：Red\nprint(get_color_name(4))  # 输出：Unknown\n\n以上是 match...case 的基本语法和示例，需要注意的是，match...case 是 Python 3.10 中新增的特性，需要安装 Python 3.10 或更高版本才能使用。\n常量模式、变量模式、位置模式、类型模式、结构模式 的示例下面是 match...case 中常见模式的示例：\n常量模式：匹配特定的常量值。def check_number(value):\n    match value:\n        case 0:\n            print(&quot;Zero&quot;)\n        case 1:\n            print(&quot;One&quot;)\n        case 2:\n            print(&quot;Two&quot;)\n        case _:\n            print(&quot;Other&quot;)\n\ncheck_number(1)  # 输出：One\ncheck_number(5)  # 输出：Other\n\n变量模式：将匹配的值绑定到一个变量，并在代码块中使用该变量。def check_even_odd(number):\n    match number % 2:\n        case 0:\n            print(&quot;Even&quot;)\n        case odd_number:\n            print(&quot;Odd:&quot;, odd_number)\n\ncheck_even_odd(4)  # 输出：Even\ncheck_even_odd(7)  # 输出：Odd: 1\n\n位置模式：匹配指定位置的元素。def check_coordinates(point):\n    match point:\n        case (0, 0):\n            print(&quot;Origin&quot;)\n        case (x, 0):\n            print(&quot;On x-axis:&quot;, x)\n        case (0, y):\n            print(&quot;On y-axis:&quot;, y)\n        case (x, y):\n            print(&quot;Arbitrary point:&quot;, x, y)\n\ncheck_coordinates((0, 0))   # 输出：Origin\ncheck_coordinates((3, 0))   # 输出：On x-axis: 3\ncheck_coordinates((0, 5))   # 输出：On y-axis: 5\ncheck_coordinates((2, 4))   # 输出：Arbitrary point: 2 4\n\n类型模式：匹配特定类型的对象。class Person:\n    def __init__(self, name, age):\n        self.name &#x3D; name\n        self.age &#x3D; age\n\ndef check_person(obj):\n    match obj:\n        case Person(name&#x3D;&quot;Alice&quot;, age&#x3D;25):\n            print(&quot;Alice&quot;)\n        case Person(name&#x3D;&quot;Bob&quot;, age&#x3D;30):\n            print(&quot;Bob&quot;)\n        case Person(name, _):\n            print(&quot;Unknown person:&quot;, name)\n        case _:\n            print(&quot;Unknown object&quot;)\n\ncheck_person(Person(&quot;Alice&quot;, 25))  # 输出：Alice\ncheck_person(Person(&quot;Bob&quot;, 30))    # 输出：Bob\ncheck_person(Person(&quot;Charlie&quot;, 40))    # 输出：Unknown person: Charlie\ncheck_person(&quot;Invalid&quot;)    # 输出：Unknown object\n\n结构模式：匹配复杂数据结构的内部元素。class Point:\n    def __init__(self, x, y):\n        self.x &#x3D; x\n        self.y &#x3D; y\n\ndef check_point(p):\n    match p:\n        case Point(0, 0):\n            print(&quot;Origin&quot;)\n        case Point(x&#x3D;0, y&#x3D;y):\n            print(&quot;On y-axis:&quot;, y)\n        case Point(x, 0):\n            print(&quot;On x-axis:&quot;, x)\n        case Point(x, y):\n            print(&quot;Arbitrary point:&quot;, x, y)\n\ncheck_point(Point(0, 0))    # 输出：Origin\ncheck_point(Point(0, 5))    # 输出：On y-axis: 5\ncheck_point(Point(3, 0))    # 输出：On x-axis: 3\ncheck_point(Point(2, 4))    # 输出：Arbitrary point: 2 4\n\n一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开是的，match...case 语句中的 case 子句可以使用 | 符号将多个匹配条件组合在一起。这样可以在一个 case 子句中同时匹配多个条件，只要有一个条件满足，就会执行对应的代码块。下面是使用 | 运算符的示例：\ndef check_number(value):\n    match value:\n        case 0 | 1 | 2:\n            print(&quot;Small number&quot;)\n        case 3 | 4 | 5:\n            print(&quot;Medium number&quot;)\n        case _:\n            print(&quot;Other number&quot;)\n\ncheck_number(2)  # 输出：Small number\ncheck_number(4)  # 输出：Medium number\ncheck_number(7)  # 输出：Other number\n\n在上面的示例中，case 0 | 1 | 2 表示当 value 的值为 0、1 或 2 时，执行相应的代码块。同样地，case 3 | 4 | 5 表示当 value 的值为 3、4 或 5 时，执行相应的代码块。如果所有的条件都不满足，则执行最后的 case _ 代码块。\n使用 | 运算符可以简化代码，将多个条件组合在一起，提高可读性和代码的简洁性。\n循环语句在 Python 中，常用的循环语句有 for 循环和 while 循环。\nfor 循环：用于遍历可迭代对象（如列表、元组、字符串等）中的元素，或执行指定次数的循环。for item in iterable:\n    # 循环体，处理每个元素\n\n示例：\nfruits &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]\nfor fruit in fruits:\n    print(fruit)\n\n输出：\napple\nbanana\ncherry\n\nrange() 函数结合 for 循环：通过 range() 函数生成一系列的数字，可以与 for 循环结合使用。for i in range(start, stop, step):\n    # 循环体，处理每个数字\n\n示例：\nfor i in range(1, 6, 2):\n    print(i)\n\n输出：\n1\n3\n5\n\nwhile 循环：在指定条件为真时重复执行循环体，直到条件变为假或出现循环终止语句。while condition:\n    # 循环体，处理条件为真时的逻辑\n\n示例：\ncount &#x3D; 0\nwhile count &lt; 5:\n    print(count)\n    count +&#x3D; 1\n\n输出：\n0\n1\n2\n3\n4\n\n循环控制语句：可以在循环中使用控制语句来控制循环的行为。常用的控制语句有 break（跳出循环）、continue（继续下一次循环迭代）和 pass（占位语句，什么都不做）。for item in iterable:\n    if condition:\n        # 执行满足条件时的逻辑\n        break  # 跳出循环\n    if condition:\n        # 执行满足条件时的逻辑\n        continue  # 继续下一次循环迭代\n    if condition:\n        pass  # 占位语句，什么都不做\n    # 其他逻辑\n\n循环语句是编程中常用的工具，可以重复执行特定的代码块，处理集合中的元素或根据条件执行特定的逻辑。根据具体的需求，选择合适的循环语句和循环控制语句来实现所需的逻辑。\nprintprint 是 Python 中用于输出信息的内置函数。它接受一个或多个参数，并将它们打印到标准输出（通常是控制台）。\n语法格式如下：\nprint(value1, value2, ..., sep&#x3D;&#39; &#39;, end&#x3D;&#39;\\n&#39;, file&#x3D;sys.stdout, flush&#x3D;False)\n\n参数说明：\n\nvalue1, value2, ...: 要打印的值，可以是任意个数的参数。\nsep=&#39; &#39;: 用于分隔每个值的字符串，默认值是一个空格。\nend=&#39;\\n&#39;: 打印完成后追加的字符串，默认值是换行符 \\n。\nfile=sys.stdout: 输出的文件对象，默认值是标准输出（控制台）。\nflush=False: 是否强制刷新输出，默认值是 False。\n\n示例：\nprint(&quot;Hello, World!&quot;)\n\n输出：\nHello, World!\n\nname &#x3D; &quot;Alice&quot;\nage &#x3D; 25\nprint(&quot;Name:&quot;, name, &quot;Age:&quot;, age, sep&#x3D;&quot; | &quot;, end&#x3D;&quot; ***\\n&quot;)\n\n输出：\nName: Alice | Age: 25 ***\n\nprint 函数可以输出各种类型的数据，包括字符串、数字、布尔值等。在调试代码或查看运行结果时，print 是一个常用的工具。可以根据需要使用不同的参数来自定义打印的格式和内容。\n推导式 (可以理解为行内遍历)推导式（Comprehension）是 Python 中一种简洁而强大的语法，用于创建新的数据结构（如列表、字典、集合）或过滤、转换现有数据结构的元素。\nPython 中常见的推导式有列表推导式、字典推导式和集合推导式。\n列表推导式（List Comprehension）：通过对一个可迭代对象中的每个元素进行操作，创建一个新的列表。\nnew_list &#x3D; [expression for item in iterable if condition]\n\n示例：\nnumbers &#x3D; [1, 2, 3, 4, 5]\nsquared_numbers &#x3D; [x**2 for x in numbers if x % 2 &#x3D;&#x3D; 0]\nprint(squared_numbers)  # 输出：[4, 16]\n\n字典推导式（Dictionary Comprehension）：通过对一个可迭代对象中的每个元素进行操作，创建一个新的字典。\nnew_dict &#x3D; &#123;key_expression: value_expression for item in iterable if condition&#125;\n\n示例：\nnumbers &#x3D; [1, 2, 3, 4, 5]\nsquared_dict &#x3D; &#123;x: x**2 for x in numbers if x % 2 &#x3D;&#x3D; 0&#125;\nprint(squared_dict)  # 输出：&#123;2: 4, 4: 16&#125;\n\n集合推导式（Set Comprehension）：通过对一个可迭代对象中的每个元素进行操作，创建一个新的集合。\nnew_set &#x3D; &#123;expression for item in iterable if condition&#125;\n\n示例：\nnumbers &#x3D; [1, 2, 3, 4, 5]\nsquared_set &#x3D; &#123;x**2 for x in numbers if x % 2 &#x3D;&#x3D; 0&#125;\nprint(squared_set)  # 输出：&#123;16, 4&#125;\n\n推导式能够以简洁的方式创建新的数据结构，并且可以使用条件来过滤元素。它在处理大型数据集或需要快速生成新数据结构的情况下特别有用。\n迭代器与生成器迭代器（Iterator）和生成器（Generator）是 Python 中用于处理和生成序列数据的重要概念。\n迭代器是一个实现了迭代器协议的对象。它通过实现 __iter__ 和 __next__ 方法来支持迭代，使得我们可以逐个访问容器（如列表、元组、字典等）中的元素，而无需关心底层实现。\n示例：\nnumbers &#x3D; [1, 2, 3, 4, 5]\niterator &#x3D; iter(numbers)\n\nprint(next(iterator))  # 输出：1\nprint(next(iterator))  # 输出：2\nprint(next(iterator))  # 输出：3\n\n迭代器可以使用 next() 函数来逐个返回序列中的元素，当没有更多元素时会抛出 StopIteration 异常。\n生成器是一种特殊的迭代器，提供了一种延迟计算的机制，可以节省内存并提高性能它使用函数和 yield 语句来生成值。生成器函数在每次调用 yield 时返回一个值，并在下一次调用时从停止的位置继续执行，保持了函数的状态。\n示例：\ndef square_numbers(n):\n    for i in range(n):\n        yield i**2\n\nnumbers &#x3D; square_numbers(5)\nprint(next(numbers))  # 输出：0\nprint(next(numbers))  # 输出：1\nprint(next(numbers))  # 输出：4\n\n生成器函数使用 yield 语句来产生值，每次调用生成器的 next() 方法时，生成器会从上一次 yield 语句停止的位置继续执行，并返回下一个值。生成器提供了一种延迟计算的机制，可以节省内存并提高性能。\n生成器还可以通过 for 循环来进行迭代，它会自动处理迭代和停止条件。\n迭代器和生成器提供了处理大型数据集和惰性计算的强大工具，能够有效地处理大量数据和节省资源。\n函数参数在 Python 中，函数的参数可以分为以下几种类型：\n位置参数（Positional Arguments）：位置参数是根据参数的位置进行匹配的，调用函数时需要按照定义时的顺序传递参数。示例：def greet(name, age):\n    print(f&quot;Hello, &#123;name&#125;! You are &#123;age&#125; years old.&quot;)\n\ngreet(&quot;Alice&quot;, 25)  # 输出：Hello, Alice! You are 25 years old.\n\n关键字参数（Keyword Arguments）：关键字参数是根据参数的名称进行匹配的，可以任意顺序传递参数。示例：def greet(name, age):\n    print(f&quot;Hello, &#123;name&#125;! You are &#123;age&#125; years old.&quot;)\n\ngreet(age&#x3D;25, name&#x3D;&quot;Alice&quot;)  # 输出：Hello, Alice! You are 25 years old.\n\n默认参数（Default Arguments）：默认参数是在函数定义时给参数设置默认值，调用函数时如果没有提供该参数的值，则使用默认值。示例：def greet(name, age&#x3D;18):\n    print(f&quot;Hello, &#123;name&#125;! You are &#123;age&#125; years old.&quot;)\n\ngreet(&quot;Alice&quot;)  # 输出：Hello, Alice! You are 18 years old.\ngreet(&quot;Bob&quot;, 30)  # 输出：Hello, Bob! You are 30 years old.\n\n可变长参数：可变长参数允许函数接受不定数量的参数。在 Python 中有两种类型的可变长参数：\n可变长位置参数（Arbitrary Arguments）：函数定义时，在参数前加上 *，表示该参数可以接受任意数量的位置参数。函数内部将这些参数作为元组来处理。示例：\ndef greet(*names):\n    for name in names:\n        print(f&quot;Hello, &#123;name&#125;!&quot;)\n\ngreet(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)  # 输出：Hello, Alice!  Hello, Bob!  Hello, Charlie!\n\n可变长关键字参数（Keyword Arguments）：函数定义时，在参数前加上 **，表示该参数可以接受任意数量的关键字参数。函数内部将这些参数作为字典来处理。示例：\ndef greet(**person):\n    for key, value in person.items():\n        print(f&quot;&#123;key&#125;: &#123;value&#125;&quot;)\n\ngreet(name&#x3D;&quot;Alice&quot;, age&#x3D;25, city&#x3D;&quot;London&quot;)  # 输出：name: Alice  age: 25  city: London\n\n函数参数的选择取决于具体的需求。位置参数和关键字参数是最常用的参数类型，而默认参数和可变长参数可以提供更大的灵活性和可扩展性。\n普通函数定义一个由自己想要功能的函数，以下是简单的规则：\n函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。函数内容以冒号 : 起始，并且缩进。return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。\nlamadaPython 使用 lambda 来创建匿名函数。\n所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。\n\nlambda 只是一个表达式，函数体比 def 简单很多。\nlambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。\nlambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。\n虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。语法lambda 函数的语法只包含一个语句，如下：\n\nlambda [arg1 [,arg2,.....argn]]:expression\n\n数据结构数据结构是计算机中存储、组织和管理数据的方式和方法。它定义了不同数据元素之间的关系，并提供了对这些数据元素进行操作和访问的接口。\n在 Python 中，常见的数据结构包括以下几种：\n\n列表（List）：列表是一种有序、可变、可重复的数据结构，用于存储多个元素。列表使用方括号 [] 表示，元素之间使用逗号 , 分隔。列表支持索引和切片操作，以及添加、删除、修改等操作。\n\n示例：\nfruits &#x3D; [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]\nprint(fruits[0])  # 输出：apple\nfruits.append(&quot;grape&quot;)\nprint(fruits)  # 输出：[&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;, &#39;grape&#39;]\n\n\n元组（Tuple）：元组是一种有序、不可变的数据结构，用于存储多个元素。元组使用圆括号 () 表示，元素之间使用逗号 , 分隔。元组的元素不能被修改，但可以通过索引访问。\n\n示例：\npoint &#x3D; (3, 5)\nprint(point[0])  # 输出：3\n\n\n字典（Dictionary）：字典是一种无序的键值对数据结构，用于存储和查找数据。字典使用花括号 &#123;&#125; 表示，每个键值对之间使用冒号 : 分隔。字典中的键必须是唯一的，而值可以重复。\n\n示例：\nperson &#x3D; &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;city&quot;: &quot;London&quot;&#125;\nprint(person[&quot;name&quot;])  # 输出：Alice\nperson[&quot;age&quot;] &#x3D; 30\nprint(person)  # 输出：&#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;London&#39;&#125;\n\n\n集合（Set）：集合是一种无序、不重复的数据结构，用于存储唯一的元素。集合使用花括号 &#123;&#125; 表示，元素之间使用逗号 , 分隔。\n\n示例：\nfruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;&#125;\nprint(&quot;banana&quot; in fruits)  # 输出：True\nfruits.add(&quot;grape&quot;)\nprint(fruits)  # 输出：&#123;&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;, &#39;grape&#39;&#125;\n\n这些数据结构在 Python 中都有对应的内置类型和方法，可以根据具体的需求选择适当的数据结构来存储和处理数据。\n列表 API使用场景\n堆栈\n队列\n推导式\n嵌套\ndel 语句：\n使用 del 语句可以从一个列表中根据索引来删除一个元素，而不是值来删除元素。\n这与使用 pop() 返回一个值不同。\n可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）\n\n\n\n&gt;&gt;&gt; a &#x3D; [-1, 1, 66.25, 333, 333, 1234.5]\n&gt;&gt;&gt; del a[0]\n&gt;&gt;&gt; a\n[1, 66.25, 333, 333, 1234.5]\n&gt;&gt;&gt; del a[2:4]\n&gt;&gt;&gt; a\n[1, 66.25, 1234.5]\n&gt;&gt;&gt; del a[:]\n&gt;&gt;&gt; a\n[]\n\n模块导入在 Python 中，使用 import 关键字可以导入其他模块，以便在当前模块中使用该模块提供的功能。模块是一个包含了一组相关函数、类和变量的 Python 文件。\n可以使用以下几种方式进行模块导入：\n\n完整导入：导入整个模块，使用 import module_name 语句。在使用模块中的函数、类和变量时，需要使用模块名作为前缀。\n\n示例：\nimport math\n\nresult &#x3D; math.sqrt(16)\nprint(result)  # 输出：4.0\n\n在上面的示例中，使用 import math 导入了 Python 内置的 math 模块。通过 math.sqrt(16) 调用了模块中的 sqrt 函数，计算了 16 的平方根。\n\n别名导入：为了简化模块名的使用，可以使用 import module_name as alias 语句给模块指定一个别名。\n\n示例：\nimport math as m\n\nresult &#x3D; m.sqrt(16)\nprint(result)  # 输出：4.0\n\n在上面的示例中，使用 import math as m 将 math 模块导入，并给它指定了别名 m。通过 m.sqrt(16) 调用了模块中的 sqrt 函数。\n\n部分导入：可以只导入模块中的特定函数、类或变量，而不是整个模块。使用 from module_name import name1, name2 语句进行部分导入。\n\n示例：\nfrom math import sqrt\n\nresult &#x3D; sqrt(16)\nprint(result)  # 输出：4.0\n\n在上面的示例中，使用 from math import sqrt 从 math 模块中只导入了 sqrt 函数。此时可以直接使用 sqrt(16) 调用该函数。\n除了上述的导入方式，还可以使用通配符 * 导入模块中的所有内容，但不推荐这种做法，因为可能导致命名冲突和不可预测的行为。\n模块导入使得我们能够利用现有的代码和功能，提高代码的复用性和可维护性，同时也使得 Python 生态系统变得丰富和强大。\n使用 “import os” 风格而非 “from os import *“。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()\n是否是自己执行 每个模块都有一个__name__属性，当其值是__main__时，表明该模块自身在运行，否则是被引入包在 Python 中，包（Package）是一种用于组织模块的方式。它是一个包含了一组相关模块的目录，目录中除了包含模块文件外，还可以包含其他子包和子目录。通过使用包，可以更好地组织和管理大型的 Python 项目。\n一个包通常包含一个特殊的文件 __init__.py，它用于标识该目录是一个包。这个文件可以是一个空文件，也可以包含一些初始化代码。\n下面是一个包的示例结构：\nmy_package&#x2F;\n    __init__.py\n    module1.py\n    module2.py\n    subpackage&#x2F;\n        __init__.py\n        module3.py\n\n在上述示例中，my_package 是一个包，它包含了两个模块 module1.py 和 module2.py，以及一个子包 subpackage，子包中包含了一个模块 module3.py。\n通过包的层次结构，可以更好地组织和管理代码。在其他模块中导入包中的模块时，需要使用包名作为前缀。\n例如，在 module1.py 中导入 module3.py：\nfrom my_package.subpackage import module3\n\nmodule3.some_function()\n\n在上面的示例中，通过 from my_package.subpackage import module3 导入了包中的模块 module3，然后可以调用模块中的函数 some_function()。\n包的使用使得 Python 项目能够以模块化的方式进行组织，使得代码更具结构和可维护性。同时，它也方便了模块的命名空间管理，避免了命名冲突。\n异常try 语句全部内容try 语句是 Python 中用于捕获和处理异常的语句块。它允许我们编写可能引发异常的代码，并指定如何处理这些异常。try 语句的完整语法如下：\ntry:\n    # 可能引发异常的代码块\n    # ...\nexcept [异常类型1]:\n    # 异常处理块1\n    # ...\nexcept [异常类型2]:\n    # 异常处理块2\n    # ...\n...\nexcept [异常类型N]:\n    # 异常处理块N\n    # ...\nelse:\n    # 未发生异常时执行的代码块\n    # ...\nfinally:\n    # 最终执行的代码块，无论是否发生异常都会执行\n    # ...\n\ntry 语句的各个部分的作用如下：\n\ntry：必需的关键字，标志着 try 语句的开始。\n可能引发异常的代码块：在 try 后面的冒号后编写的代码块，可能会引发异常。\nexcept：可选的关键字，用于捕获和处理指定类型的异常。可以有多个 except 语句，分别处理不同的异常类型。\n异常类型：指定要捕获的异常类型，可以是内置的异常类型（如 ZeroDivisionError、ValueError 等）或自定义的异常类型。\n异常处理块：在 except 后面的冒号后编写的代码块，用于处理指定类型的异常。\nelse：可选的关键字，用于指定当没有发生异常时执行的代码块。如果 try 代码块中没有引发任何异常，那么将执行 else 代码块。\nfinally：可选的关键字，用于指定无论是否发生异常都会执行的最终代码块。\n\ntry 语句的执行过程如下：\n\n执行 try 代码块中的代码。\n如果在 try 代码块中引发了异常，那么程序会跳过剩余的 try 代码块中的代码，并进入与引发的异常类型匹配的 except 代码块，执行相应的异常处理代码。\n如果发生了多个异常类型的异常，那么只会进入第一个与异常类型匹配的 except 代码块。后面的 except 代码块将被忽略。\n如果没有发生任何异常，那么将执行 else 代码块中的代码。\n无论是否发生异常，最终都会执行 finally 代码块中的代码。\n\n下面是一个示例，演示了 try 语句的使用：\ntry:\n    # 可能引发异常的代码块\n    x &#x3D; int(input(&quot;Enter a number: &quot;))\n    result &#x3D; 10 &#x2F; x\n    print(&quot;Result:&quot;, result)\nexcept ValueError:\n    # 处理 ValueError 异常\n    print(&quot;Invalid input. Please enter a valid number.&quot;)\nexcept ZeroDivisionError:\n    # 处理 ZeroDivisionError 异常\n    print(&quot;Cannot divide by zero!&quot;)\nelse:\n    # 未发生异常时执行的代码块\n    print(&quot;No exception occurred.&quot;)\nfinally:\n    # 最终执行的代码块\n    print(&quot;Execution complete.&quot;)\n\n在上述示例中，用户被要求输入一个数字，然后尝试将其转换为整数并进行除法运算。可能会引发 ValueError 异常（如果输入的不是有效的数字）或 ZeroDivisionError 异常（如果输入的是 0）。根据引发的异常类型，程序会执行相应的异常处理块。\n注意，如果输入的是有效的数字且不为 0，那么将执行 else 代码块。最终，无论是否发生异常，都会执行 finally 代码块。\n通过使用 try-except 语句，我们可以捕获和处理异常，从而保证程序的稳定性和可靠性。异常处理使得我们能够对不同类型的异常进行特定的处理，提供有用的错误信息，并在出现异常时采取适当的行动。\n触发异常的几种方式在 Python 中，可以通过多种方式触发异常。下面列举了几种常见的触发异常的方式：\n\n使用 raise 语句：可以使用 raise 语句手动引发异常。语法为 raise 异常类型。例如：\nraise ValueError(&quot;Invalid value&quot;)\n\n上述代码引发了一个 ValueError 异常，并提供了一个错误消息。\n\n调用内置函数引发异常：Python 提供了一些内置函数，可以用于引发特定类型的异常。例如：\n\nraise ValueError(&quot;Invalid value&quot;) 会引发 ValueError 异常。\nassert 条件, &quot;错误消息&quot; 会引发 AssertionError 异常，当条件为假时。\n\n\n使用内置异常类：可以直接实例化内置的异常类来触发异常。例如：\nraise ValueError(&quot;Invalid value&quot;)\n\n上述代码与第一种方式是等效的。\n\n抛出已捕获的异常：在 except 块中，可以使用 raise 语句重新抛出已捕获的异常。这样做可以将异常传递给上层的异常处理程序。例如：\ntry:\n    # 一些代码\n    raise ValueError(&quot;Invalid value&quot;)\nexcept ValueError as ve:\n    print(&quot;Caught ValueError:&quot;, ve)\n    raise  # 重新抛出已捕获的异常\n\n上述代码在捕获 ValueError 异常后，先打印异常信息，然后使用 raise 重新抛出异常。\n\n\n这些是常见的触发异常的方式，可以根据需要选择适合的方式来引发异常。引发异常可以用于指示错误、异常情况或自定义的特殊情况，并且可以在异常处理中进行相应的处理。\n定义清理行为 与 预定义的清理行为在 Python 中，我们可以使用 try-finally 语句来定义清理行为。finally 代码块中的代码无论是否发生异常，都会执行。这使得我们可以在异常发生时执行必要的清理操作，确保资源的正确释放。\n下面是一个使用 try-finally 语句定义清理行为的示例：\ntry:\n    # 可能引发异常的代码块\n    file &#x3D; open(&quot;file.txt&quot;, &quot;r&quot;)\n    # 执行一些操作\nfinally:\n    # 清理行为\n    file.close()  # 关闭文件\n\n在上述示例中，我们打开了一个文件进行读取操作。在 finally 代码块中，我们使用 file.close() 关闭了文件。无论是否发生异常，都会执行 finally 代码块，从而确保文件被正确关闭。\n此外，Python 还提供了一些预定义的清理行为，可以通过特定的对象方法进行处理。例如：\n\n对于文件操作，可以使用 with 语句来自动管理文件的打开和关闭：\nwith open(&quot;file.txt&quot;, &quot;r&quot;) as file:\n    # 执行一些操作\n\nwith 语句会在代码块结束时自动关闭文件，无需手动调用 file.close()。\n\n对于网络连接或数据库连接等资源，可以使用相关库提供的上下文管理器或连接池来管理资源的分配和释放。这样可以确保在使用完资源后，资源会被正确关闭和释放，避免资源泄露。\n\n\n通过使用 try-finally 语句和预定义的清理行为，我们可以有效地管理资源，并在发生异常时进行必要的清理操作。这有助于确保程序的正确性和可靠性，并提高代码的可维护性。\n类相关全部内容类是面向对象编程的核心概念之一，在 Python 中使用类可以创建对象，定义对象的属性和行为。下面是类相关的全部内容：\n定义类在 Python 中，使用class关键字来定义类，类的命名通常采用驼峰命名法（首字母大写）。类定义由类名、属性和方法组成，属性是类的特征，方法是类的行为。\nclass ClassName:\n    # 属性\n    attribute &#x3D; value\n\n    # 方法\n    def method(self, parameters):\n        # 方法体\n        # 可以访问属性和其他方法\n\n创建对象通过类可以创建对象，即类的实例。使用类名后面跟一对括号即可创建对象，并可将其赋值给一个变量。\nobject_name &#x3D; ClassName()\n\n属性类的属性是类的特征或数据。属性可以是实例属性（属于对象）或类属性（属于类本身）。在类中使用变量来定义属性。\nclass ClassName:\n    attribute &#x3D; value\n\n方法类的方法是类的行为或操作。方法是与对象相关联的函数。在类中使用def关键字来定义方法。\nclass ClassName:\n    def method(self, parameters):\n        # 方法体\n        # 可以访问属性和其他方法\n\n在方法定义中，第一个参数通常是self，它表示当前对象自身。通过self可以访问对象的属性和其他方法。\n构造方法构造方法是在创建对象时自动调用的特殊方法，用于初始化对象的属性。构造方法的名称为__init__，它接受参数并设置对象的初始状态。\nclass ClassName:\n    def __init__(self, parameters):\n        # 初始化对象属性\n\n继承继承是面向对象编程中实现代码重用和扩展的机制。一个类可以继承另一个类的属性和方法。被继承的类称为父类或基类，继承的类称为子类或派生类。\nclass ChildClassName(ParentClassName):\n    # 子类的定义\n\n子类可以访问父类的属性和方法，并可以重写或扩展父类的方法。\n方法重写子类可以对继承自父类的方法进行重写，即在子类中定义与父类方法同名的方法，从而改变方法的实现。\nclass ChildClassName(ParentClassName):\n    def method(self, parameters):\n        # 子类方法的实现\n\n多态多态是面向对象编程中的一个概念，指的是同一种操作或方法可以应用于不同的对象，产生不同的结果。多态通过继承和方法重写来实现。\n私有属性和方法在 Python 中，可以使用双下划线__作为前缀来定义私有属性和方法，表示\nPython 多态示例下面是一个多态的示例，展示了如何使用继承和方法重写实现多态：\nclass Animal:\n    def sound(self):\n        pass\n\nclass Cat(Animal):\n    def sound(self):\n        print(&quot;Meow&quot;)\n\nclass Dog(Animal):\n    def sound(self):\n        print(&quot;Woof&quot;)\n\nclass Cow(Animal):\n    def sound(self):\n        print(&quot;Moo&quot;)\n\n# 创建不同的动物对象\ncat &#x3D; Cat()\ndog &#x3D; Dog()\ncow &#x3D; Cow()\n\n# 调用相同的方法，产生不同的结果\ncat.sound()  # 输出：Meow\ndog.sound()  # 输出：Woof\ncow.sound()  # 输出：Moo\n\n在上述示例中，我们定义了一个基类 Animal 和三个派生类 Cat、Dog 和 Cow。基类 Animal 定义了一个名为 sound 的方法，但没有具体的实现。\n每个派生类都重写了基类的 sound 方法，给出了不同的实现。当我们创建不同的动物对象并调用 sound 方法时，每个对象会根据其自身的实现产生不同的结果。这就是多态的体现，相同的方法名在不同的对象上表现出不同的行为。\n多态使得我们可以编写通用的代码，不需要为每种对象类型编写特定的处理逻辑。通过继承和方法重写，我们可以在不改变基类代码的情况下，扩展和定制特定类型的对象行为。这提高了代码的灵活性和可维护性。\nPython 抽象类、抽象方法、接口在 Python 中，抽象类、抽象方法和接口是面向对象编程的概念，用于实现代码的抽象和规范。\n抽象类抽象类是一种不能被实例化的类，它只能作为其他类的基类。抽象类用于定义一组共同的接口和方法，但不能被直接实例化。\n在 Python 中，我们可以使用 abc 模块来创建抽象类。抽象类通常包含至少一个抽象方法，即没有具体实现的方法。子类必须实现所有的抽象方法，否则子类也将被视为抽象类。\n下面是一个抽象类的示例：\nfrom abc import ABC, abstractmethod\n\nclass AbstractClass(ABC):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\nclass ConcreteClass(AbstractClass):\n    def abstract_method(self):\n        print(&quot;Implementing abstract_method&quot;)\n\n# 抽象类无法实例化\n# obj &#x3D; AbstractClass()\n\n# 创建子类对象\nobj &#x3D; ConcreteClass()\nobj.abstract_method()\n\n在上述示例中，AbstractClass 是一个抽象类，其中的 abstract_method 是一个抽象方法，它没有具体的实现。ConcreteClass 是 AbstractClass 的子类，必须实现抽象方法。\n抽象方法抽象方法是在抽象类中声明但没有具体实现的方法。抽象方法必须在子类中被重写实现。\n在 Python 中，使用 @abstractmethod 装饰器来将方法声明为抽象方法。抽象方法通常没有方法体，只有方法签名。\n接口在 Python 中，没有直接的内置接口概念。接口是一组规范，描述了类应该具有的属性和方法。在 Python 中，接口通常通过抽象类和抽象方法来实现。\nPython 的面向对象编程风格更倾向于”鸭子类型”，即只关注对象的行为而不关心对象的类型。因此，Python 中的接口概念更加灵活，不需要显式地声明接口。\n可以通过遵循特定的命名约定来表示一个类实现了某个接口，例如按照约定，类中包含 __iter__ 方法表示它是可迭代的接口。\n尽管 Python 没有严格的接口定义，但我们可以通过抽象类和抽象方法的组合来实现类似接口的行为。\n私有方法在 Python 中，私有方法是指在类定义中以双下划线 __ 开头的方法。私有方法只能在类的内部被调用，无法在类的外部直接访问。\n下面是一个示例，展示了如何定义和使用私有方法：\nclass MyClass:\n    def public_method(self):\n        print(&quot;This is a public method.&quot;)\n        self.__private_method()\n\n    def __private_method(self):\n        print(&quot;This is a private method.&quot;)\n\n# 创建对象\nobj &#x3D; MyClass()\n\n# 调用公有方法\nobj.public_method()  # 输出：This is a public method. This is a private method.\n\n# 无法直接调用私有方法\n# obj.__private_method()  # 报错：AttributeError: &#39;MyClass&#39; object has no attribute &#39;__private_method&#39;\n\n在上述示例中，MyClass 类定义了一个公有方法 public_method 和一个私有方法 __private_method。公有方法可以在类的内部和外部被调用，而私有方法只能在类的内部被调用。\n注意，私有方法的命名约定是以双下划线开头，但实际上 Python 解释器会对私有方法进行名称修饰，将其重命名为 _ClassName__private_method 的形式，以避免与其他类的私有方法冲突。\n尽管私有方法无法在类的外部直接调用，但在类的内部，公有方法仍然可以调用私有方法。这样可以确保私有方法只在类的内部使用，起到了封装和隐藏实现细节的作用。私有方法通常用于帮助公有方法执行一些内部的、辅助性的操作。\n静态方法在 Python 中，静态方法是类中定义的一种特殊类型的方法。静态方法与类的实例无关，它可以在类级别上直接调用，而无需创建类的实例。\n以下是静态方法的定义和使用示例：\nclass MyClass:\n    @staticmethod\n    def static_method():\n        print(&quot;This is a static method.&quot;)\n\n# 调用静态方法，不需要创建类的实例\nMyClass.static_method()  # 输出：This is a static method.\n\n在上述示例中，MyClass 类定义了一个静态方法 static_method，使用 @staticmethod 装饰器来指示它是一个静态方法。静态方法不需要传递任何实例参数，因此在调用时不需要创建类的实例，可以直接通过类名调用。\n静态方法与类的状态无关，它主要用于实现与类相关但不依赖于实例的功能。静态方法在类的内部可以访问类的属性和其他静态方法，但无法访问实例属性和实例方法。\n与实例方法不同，静态方法无需访问或修改类的实例状态，因此它们通常用于执行通用的功能或实现独立于特定实例的逻辑。静态方法在代码中更具有模块化和独立性，可以方便地进行单元测试和重用。\n单例在面向对象编程中，单例是一种设计模式，它确保一个类只有一个实例，并提供全局访问点以获取该实例。在 Python 中，实现单例模式有多种方式，其中常用的方式是使用模块级别的变量、装饰器或元类。\n以下是使用模块级别的变量实现单例的示例：\n# singleton.py\nclass SingletonClass:\n    def __init__(self):\n        pass\n\n# 创建单例实例\nsingleton_instance &#x3D; SingletonClass()\n\n在上述示例中，singleton.py 文件定义了一个类 SingletonClass，并在模块级别创建了一个名为 singleton_instance 的变量来保存单例实例。该变量在模块第一次导入时被创建，并在后续的导入中被重用，因此无论在哪里导入该模块，都可以获得相同的实例。\n使用装饰器实现单例模式的示例：\ndef singleton(class_):\n    instances &#x3D; &#123;&#125;\n\n    def wrapper(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] &#x3D; class_(*args, **kwargs)\n        return instances[class_]\n\n    return wrapper\n\n@singleton\nclass SingletonClass:\n    def __init__(self):\n        pass\n\n在上述示例中，singleton 是一个装饰器函数，它接受一个类作为参数，并返回一个包装器函数。包装器函数在每次创建实例时检查该类是否已经有一个实例存在，如果存在则返回现有的实例，否则创建一个新的实例并返回。\n使用元类实现单例模式的示例：\nclass SingletonMeta(type):\n    _instances &#x3D; &#123;&#125;\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] &#x3D; super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass SingletonClass(metaclass&#x3D;SingletonMeta):\n    def __init__(self):\n        pass\n\n在上述示例中，SingletonMeta 是一个元类，它继承自 type。元类定义了 __call__ 方法，该方法在创建类的实例时被调用。在 __call__ 方法中，检查类是否已经有一个实例存在，如果存在则返回现有的实例，否则创建一个新的实例并返回。\n以上是几种常见的实现单例模式的方式，你可以根据自己的需求选择其中一种方式来实现单例。无论使用哪种方式，单例模式都可以确保一个类只有一个实例，并提供全局访问点以获取该实例。\n命名空间和作用域命名空间命名空间（Namespace）是指用于存储和管理变量和对象名称的容器。它们在编程语言中起到了组织和隔离代码标识符的作用。在 Python 中，命名空间用于管理变量、函数、类和其他对象的名称。\nPython 中有多个类型的命名空间，包括：\n\n内置命名空间（Built-in Namespace）：包含内置函数和内置对象的名称，如 print()、len()、list 等。这些名称可以直接使用，无需导入任何模块。\n\n全局命名空间（Global Namespace）：包含在全局范围内定义的名称，即在模块级别定义的变量、函数、类等。全局命名空间在整个模块中可见。\n\n局部命名空间（Local Namespace）：在函数或类的定义中，每当进入一个函数或方法，都会创建一个局部命名空间。局部命名空间包含函数的参数、函数内部定义的变量、临时变量等。局部命名空间在函数或方法内部有效，函数执行结束后会被销毁。\n\n\n作用域作用域（Scope）是指在程序中访问命名空间中名称的规则。作用域定义了在不同上下文中名称的可见性和可访问性。\n在 Python 中，有以下几种作用域：\n\n内置作用域（Built-in Scope）：包含内置函数和内置对象的名称。这些名称在任何地方都是可见的。\n\n全局作用域（Global Scope）：包含在全局范围内定义的名称，即在模块级别定义的变量、函数、类等。全局作用域在整个模块中可见。\n\n局部作用域（Local Scope）：在函数或类的定义中，每当进入一个函数或方法，都会创建一个局部作用域。局部作用域包含函数的参数、函数内部定义的变量、临时变量等。局部作用域在函数或方法内部有效，函数执行结束后会被销毁。\n\n嵌套作用域（Enclosing Scope）：在嵌套函数中，内部函数可以访问外部函数的变量。嵌套作用域允许变量在嵌套的函数之间共享。\n\n\n作用域链（Scope Chain）是指在程序中查找和解析名称时，按照一定的规则在命名空间中查找名称的顺序。作用域链由嵌套的作用域组成，使得内部作用域可以访问外部作用域中的变量。\nPython 遵循 LEGB 规则来解析名称：\n\nL：Local，局部作用域\nE：Enclosing，嵌套作用域\nG：Global，全局作用域\nB：Built-in，内置作用域\n\n在解析名称时，Python 会按照从内到外的顺序查找名称，直到找到第一个匹配的名称为止。如果在任何作用域中都没有找到匹配的名称，则会引发 NameError。\n以下是一个示例来说明命名空间和作用域的概念：\nx &#x3D; 10  # 全局作用域\n\ndef outer_func():\n    y &#x3D; 20  # outer_func 的局部作用域\n\n    def inner_func():\n        z &#x3D; 30  # inner_func 的局部作用域\n        print(x, y, z)  # 可以访问全局作用域和外部作用域中的变量\n\n    inner_func()\n\nouter_func()\n\n在上述示例中，x 是全局作用域中定义的变量，在 outer_func 和 inner_func 的局部作用域中都可以访问到它。y 是 outer_func 的局部作用域中定义的变量，只能在 outer_func 和 inner_func 的局部作用域中访问。z 是 inner_func 的局部作用域中定义的变量，只能在 inner_func 的局部作用域中访问。\n当执行 inner_func 时，会按照 LEGB 规则查找并解析名称。首先在局部作用域中查找，找到 z；然后在外部作用域（outer_func 的作用域）中查找，找到 y；最后在全局作用域中查找，找到 x。因此，执行结果是 10 20 30。\n理解命名空间和作用域的概念对于编写和理解 Python 代码非常重要。它们可以帮助你组织代码、避免命名冲突，并了解变量和对象在不同上下文中的可见性和可访问性。\n标准库time 库time 库提供了一些常用的函数和常量，用于处理时间和日期。以下是 time 库的一些常见 API：\n\ntime()：返回当前时间的时间戳（从 1970 年 1 月 1 日午夜开始的秒数）。\nsleep(secs)：暂停执行指定秒数的时间。\nctime([secs])：将给定的时间戳（默认为当前时间戳）转换为可读的字符串表示形式。\ngmtime([secs])：将给定的时间戳（默认为当前时间戳）转换为格林威治标准时间的结构化形式。\nlocaltime([secs])：将给定的时间戳（默认为当前时间戳）转换为本地时间的结构化形式。\nasctime([t])：将时间元组（默认为当前时间）转换为可读的字符串表示形式。\nstrftime(format[, t])：根据指定的格式字符串，将时间元组（默认为当前时间）转换为自定义格式的字符串。\nstrptime(string, format)：将给定格式的字符串解析为时间元组。\nperf_counter()：返回一个具有高分辨率的性能计数器的值，用于测量短暂时间间隔的性能。\nprocess_time()：返回当前进程的 CPU 时间，包括系统和用户 CPU 时间。\n\n这些是 time 库中的一些常用函数，可以在程序中根据需要使用它们来处理时间和日期。请注意，这些函数返回的时间通常是基于秒的时间戳或结构化的时间元组，你可能需要根据需要进行格式化或转换。详细的文档可以在 Python 官方文档中找到。\ntime 库 API 对应的示例下面是一些示例代码，展示了如何使用 time 库中的一些常见 API：\n\n获取当前时间戳：\n\nimport time\n\ntimestamp &#x3D; time.time()\nprint(timestamp)\n\n输出：\n1621448812.5327687\n\n\n暂停执行指定秒数的时间：\n\nimport time\n\nprint(&quot;Start&quot;)\ntime.sleep(3)\nprint(&quot;End&quot;)\n\n输出：\nStart\n[等待3秒]\nEnd\n\n\n将时间戳转换为可读的字符串形式：\n\nimport time\n\ntimestamp &#x3D; time.time()\ntime_string &#x3D; time.ctime(timestamp)\nprint(time_string)\n\n输出：\nSun May 19 23:07:10 2023\n\n\n将时间元组转换为自定义格式的字符串：\n\nimport time\n\ntimestamp &#x3D; time.time()\ntime_tuple &#x3D; time.localtime(timestamp)\ntime_string &#x3D; time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time_tuple)\nprint(time_string)\n\n输出：\n2023-05-19 23:07:10\n\n\n获取 CPU 的性能计数器的值：\n\nimport time\n\nstart_time &#x3D; time.perf_counter()\n# 执行一些操作\nend_time &#x3D; time.perf_counter()\nelapsed_time &#x3D; end_time - start_time\nprint(f&quot;Elapsed time: &#123;elapsed_time&#125; seconds&quot;)\n\n输出：\nElapsed time: 0.005839846 seconds\n\n\n将时间元组转换为时间戳：\n\nimport time\n\ntime_tuple &#x3D; (2023, 5, 19, 23, 7, 10, 0, 0, 0)  # (year, month, day, hour, minute, second, weekday, Julian day, DST flag)\ntimestamp &#x3D; time.mktime(time_tuple)\nprint(timestamp)\n\n输出：\n1671413230.0\n\n\n根据指定格式解析时间字符串：\n\nimport time\n\ntime_string &#x3D; &quot;2023-05-19 23:07:10&quot;\ntime_tuple &#x3D; time.strptime(time_string, &quot;%Y-%m-%d %H:%M:%S&quot;)\nprint(time_tuple)\n\n输出：\ntime.struct_time(tm_year&#x3D;2023, tm_mon&#x3D;5, tm_mday&#x3D;19, tm_hour&#x3D;23, tm_min&#x3D;7, tm_sec&#x3D;10, tm_wday&#x3D;5, tm_yday&#x3D;139, tm_isdst&#x3D;-1)\n\n\n获取程序运行时间：\n\nimport time\n\nstart_time &#x3D; time.process_time()\n\n# 执行一些操作\nsum(range(1000000))\n\nend_time &#x3D; time.process_time()\nelapsed_time &#x3D; end_time - start_time\nprint(f&quot;Elapsed time: &#123;elapsed_time&#125; seconds&quot;)\n\n输出：\nElapsed time: 0.02943952099999996 seconds\n\n这些示例展示了更多关于 time 库的用法，包括时间元组与时间戳之间的转换、解析时间字符串、以及测量程序运行时间。这些功能可以在不同的场景中帮助你处理时间和日期相关的操作。记住，在实际使用中，你可以根据具体需求和情境选择适当的时间函数和方法。\ndatetime 模块有哪些 APIdatetime 模块提供了一些常用的类和函数，用于处理日期和时间。以下是 datetime 模块的一些常见 API：\n\n类和对象：\n\ndatetime：表示日期和时间的对象，包含年、月、日、时、分、秒等信息。\ndate：表示日期的对象，包含年、月、日信息。\ntime：表示时间的对象，包含时、分、秒等信息。\ntimedelta：表示时间间隔的对象，可以用于日期和时间的计算。\ntzinfo：表示时区信息的基类。\n\n\n获取当前日期和时间：\n\n\nfrom datetime import datetime\n\ncurrent_datetime &#x3D; datetime.now()\nprint(current_datetime)\n\n输出：\n2023-05-19 23:07:10.123456\n\n\n创建特定日期和时间的对象：\n\nfrom datetime import datetime, date, time\n\nspecific_date &#x3D; date(2023, 5, 19)\nspecific_time &#x3D; time(23, 7, 10)\nspecific_datetime &#x3D; datetime(2023, 5, 19, 23, 7, 10)\n\nprint(specific_date)\nprint(specific_time)\nprint(specific_datetime)\n\n输出：\n2023-05-19\n23:07:10\n2023-05-19 23:07:10\n\n\n格式化日期和时间：\n\nfrom datetime import datetime\n\ncurrent_datetime &#x3D; datetime.now()\nformatted_datetime &#x3D; current_datetime.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)\n\nprint(formatted_datetime)\n\n输出：\n2023-05-19 23:07:10\n\n\n解析字符串为日期和时间对象：\n\nfrom datetime import datetime\n\ndate_string &#x3D; &quot;2023-05-19&quot;\ntime_string &#x3D; &quot;23:07:10&quot;\ndatetime_string &#x3D; &quot;2023-05-19 23:07:10&quot;\n\nparsed_date &#x3D; datetime.strptime(date_string, &quot;%Y-%m-%d&quot;).date()\nparsed_time &#x3D; datetime.strptime(time_string, &quot;%H:%M:%S&quot;).time()\nparsed_datetime &#x3D; datetime.strptime(datetime_string, &quot;%Y-%m-%d %H:%M:%S&quot;)\n\nprint(parsed_date)\nprint(parsed_time)\nprint(parsed_datetime)\n\n输出：\n2023-05-19\n23:07:10\n2023-05-19 23:07:10\n\n这些是 datetime 模块中的一些常用 API，可以用于处理日期和时间相关的操作。你可以根据需要使用这些函数和类来获取当前日期时间、创建特定的日期时间对象、格式化和解析日期时间字符串等。详细的文档可以在 Python 官方文档中找到。\ndatetime API 对应的示例下面是使用 datetime 模块的不同类和对象的示例：\n\ndatetime 类示例：\n\nfrom datetime import datetime\n\ncurrent_datetime &#x3D; datetime.now()\nprint(current_datetime)\n\n输出：\n2023-05-19 23:07:10.123456\n\n\ndate 类示例：\n\nfrom datetime import date\n\nspecific_date &#x3D; date(2023, 5, 19)\nprint(specific_date)\n\n输出：\n2023-05-19\n\n\ntime 类示例：\n\nfrom datetime import time\n\nspecific_time &#x3D; time(23, 7, 10)\nprint(specific_time)\n\n输出：\n23:07:10\n\n\ntimedelta 类示例：\n\nfrom datetime import datetime, timedelta\n\ncurrent_datetime &#x3D; datetime.now()\nfuture_datetime &#x3D; current_datetime + timedelta(days&#x3D;3, hours&#x3D;2)\nprint(future_datetime)\n\n输出：\n2023-05-22 01:07:10.123456\n\n\ntzinfo 类示例（需要自定义子类）：\n\nfrom datetime import datetime, timedelta, tzinfo\n\nclass MyTimezone(tzinfo):\n    def utcoffset(self, dt):\n        return timedelta(hours&#x3D;8)  # 设置为 UTC+8\n\ncurrent_datetime &#x3D; datetime.now(tz&#x3D;MyTimezone())\nprint(current_datetime)\n\n输出：\n2023-05-19 23:07:10.123456+08:00\n\n这些示例演示了 datetime 模块中不同类和对象的用法。你可以根据需要使用这些类来处理日期和时间，创建特定的日期时间对象，进行日期时间的计算和调整，以及处理时区信息等。根据实际需求，你可以灵活地使用这些类和对象来完成各种日期时间操作。\ntime 库与 datetime 库有什么区别time 库和 datetime 库都是 Python 中用于处理时间和日期的标准库，但它们有一些区别。\n\n功能不同：\n\ntime 库主要用于处理时间相关的操作，例如获取当前时间、计时等。它提供了一些函数和常量，如 time()、sleep()、ctime() 等，用于处理时间戳、等待一定时间、格式化时间等。\ndatetime 库提供了更丰富的日期和时间操作功能。它包含了 date、time、datetime、timedelta 等类，可以用于处理日期、时间、日期时间的计算、格式化等。\n\n\n数据类型不同：\n\ntime 库主要使用时间戳（浮点数表示从 1970 年 1 月 1 日以来的秒数）来表示时间。\ndatetime 库使用更高级的数据类型，如 datetime 类表示日期和时间，date 类表示日期，time 类表示时间。\n\n\n精度不同：\n\ntime 库提供的时间函数通常具有更高的精度，可以测量更小的时间单位，如纳秒级别。\ndatetime 库的精度较低，主要用于处理年、月、日、时、分、秒等常见时间单位。\n\n\n功能的使用场景不同：\n\ntime 库适用于需要处理时间相关操作的场景，例如计时、等待、性能测试等。\ndatetime 库适用于处理日期和时间的常规操作，例如日期计算、日期比较、日期格式化等。\n\n\n\n综上所述，time 库主要用于处理时间戳和基本的时间操作，而 datetime 库提供了更丰富的日期和时间操作功能。在实际开发中，根据具体的需求选择合适的库来处理时间和日期操作。\n测试性能Timer 是 Python 中用于测量代码执行时间的类。它位于 timeit 模块中。\n你提供的代码 Timer(&#39;t=a; a=b; b=t&#39;, &#39;a=1; b=2&#39;).timeit() 的含义如下：\n\n&#39;t=a; a=b; b=t&#39; 是要测量执行时间的代码块，其中 t=a; a=b; b=t 表示将变量 a 和 b 的值交换。\n&#39;a=1; b=2&#39; 是准备执行的设置语句，其中 a=1 表示将变量 a 的值设置为 1，b=2 表示将变量 b 的值设置为 2。\n\n调用 Timer 类的 timeit() 方法会执行多次给定的代码块，并返回执行时间的浮点数值。默认情况下，timeit() 方法会执行代码块 1,000,000 次以获取更准确的时间。\n因此，Timer(&#39;t=a; a=b; b=t&#39;, &#39;a=1; b=2&#39;).timeit() 将会测量执行代码块 t=a; a=b; b=t 的时间，使用变量 a 初始值为 1，b 初始值为 2。\n请注意，上述代码是在 timeit 模块的环境中执行的，而不是直接在 Python 解释器中执行。要在 Python 解释器中执行该代码，可以按照以下方式编写：\nimport timeit\n\ndef swap_values():\n    a &#x3D; 1\n    b &#x3D; 2\n    t &#x3D; a\n    a &#x3D; b\n    b &#x3D; t\n\nexecution_time &#x3D; timeit.timeit(swap_values, number&#x3D;1000000)\nprint(execution_time)\n\n上述代码定义了一个名为 swap_values 的函数，其中包含要测量执行时间的代码块。然后使用 timeit.timeit() 函数传入函数名和执行次数来测量执行时间，并将结果打印出来。在这个例子中，代码块将被执行 1,000,000 次，并返回总的执行时间。\njson 模块 API 及示例json 模块提供了用于 JSON 数据编码和解码的函数。以下是 json 模块的一些常见 API 和示例：\n\njson.dumps()：将 Python 对象转换为 JSON 字符串。\n\nimport json\n\ndata &#x3D; &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;\njson_string &#x3D; json.dumps(data)\nprint(json_string)\n\n输出：\n&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;\n\n\njson.loads()：将 JSON 字符串转换为 Python 对象。\n\nimport json\n\njson_string &#x3D; &#39;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#39;\ndata &#x3D; json.loads(json_string)\nprint(data)\n\n输出：\n&#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;\n\n\njson.dump()：将 Python 对象写入 JSON 文件。\n\nimport json\n\ndata &#x3D; &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;\n\nwith open(&quot;data.json&quot;, &quot;w&quot;) as file:\n    json.dump(data, file)\n\n\njson.load()：从 JSON 文件中读取数据并转换为 Python 对象。\n\nimport json\n\nwith open(&quot;data.json&quot;, &quot;r&quot;) as file:\n    data &#x3D; json.load(file)\n    print(data)\n\n输出：\n&#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;\n\n这些是 json 模块的一些常用 API。你可以使用 dumps() 和 loads() 函数进行 JSON 字符串和 Python 对象之间的转换，使用 dump() 和 load() 函数来读写 JSON 文件。这些函数提供了方便的方式来处理 JSON 数据的编码和解码操作。请注意，json 模块还提供其他功能，例如处理特定类型的编码和解码方式，对 JSON 数据进行格式化等。详细的文档可以在 Python 官方文档中找到。\npip 执行过程（不是我想要的答案）当你在命令行中使用 pip 命令时，它会执行以下步骤：\n\n解析命令行参数：pip 命令会解析你在命令行中输入的参数，如要安装、卸载、更新或查看包等操作。\n\n确定操作和目标包：根据解析的参数，pip 确定执行的具体操作，如安装、卸载、更新等，并确定目标包的名称和版本。\n\n确定包源和依赖关系：pip 根据配置文件（如 pip.conf）中的设置，确定要从哪个源（如 PyPI）下载包，并获取包的元数据，包括包的名称、版本、依赖关系等。\n\n下载和安装包：pip 通过网络连接到指定的包源，下载目标包的压缩文件（通常是 .tar.gz 或 .whl 格式），然后解压缩并将包的文件安装到适当的位置。\n\n解决依赖关系：如果目标包有依赖关系，pip 会递归解析和安装这些依赖关系，确保所有依赖包都被正确安装。\n\n执行操作：根据命令行参数确定的操作，pip 执行相应的操作，如安装、卸载、更新等。\n\n完成操作：一旦操作完成，pip 会显示相应的结果和提示信息，告诉你操作是否成功完成。\n\n\n注意，pip 还可以与虚拟环境一起使用，以便在不同的项目中管理不同的包和版本。在虚拟环境中，pip 会安装包到该环境的独立目录中，以避免与其他环境或全局安装的包发生冲突。\n总之，pip 是一个功能强大的包管理工具，它简化了在 Python 中安装、升级和管理包的过程，使开发者能够轻松地使用各种第三方库和工具。\n协程通信协程（Coroutine）是一种轻量级的并发编程方式，它可以在一个线程内实现并发执行的效果。在 Python 中，协程通过 asyncio 模块来支持，使用 async 和 await 关键字来定义和管理协程。\n协程的特点包括：\n\n非抢占式：协程是由程序员手动控制切换的，它不会被操作系统的调度器中断，而是在遇到 await 关键字时主动让出执行权。\n\n轻量级：协程不需要创建新的线程或进程，可以在一个线程内并发执行，节省系统资源。\n\n高效：协程的切换是在代码级别完成的，切换开销较小。\n\n\n使用协程可以实现异步编程，解决并发性能问题。在协程中，可以使用 async def 定义一个协程函数，其中可以使用 await 关键字来挂起协程的执行，等待其他协程或异步任务完成。\n以下是一个简单的示例，展示了如何使用协程实现异步任务的并发执行：\nimport asyncio\n\nasync def task(name, delay):\n    print(f&quot;Task &#123;name&#125; started&quot;)\n    await asyncio.sleep(delay)\n    print(f&quot;Task &#123;name&#125; completed&quot;)\n\nasync def main():\n    tasks &#x3D; [\n        asyncio.create_task(task(&quot;A&quot;, 2)),\n        asyncio.create_task(task(&quot;B&quot;, 1)),\n        asyncio.create_task(task(&quot;C&quot;, 3))\n    ]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n\n在上面的示例中，task() 函数是一个协程函数，它模拟了一个耗时的异步任务。main() 函数是主协程，它使用 asyncio.create_task() 创建了多个任务，并使用 asyncio.gather() 并发执行这些任务。通过运行 asyncio.run(main()) 来启动事件循环并执行协程。\n协程是异步编程的重要概念，它在处理高并发和 IO 密集型任务时非常有用。通过合理地利用协程，可以提升程序的性能和响应能力。\n异步上下文管理器异步上下文管理器（Async Context Manager）是在异步环境下使用的上下文管理器。它提供了在进入和退出特定上下文时执行异步操作的功能。\n在 Python 中，常规的上下文管理器使用 with 语句来管理资源的获取和释放，而异步上下文管理器则使用 async with 语句。异步上下文管理器是通过实现 __aenter__() 和 __aexit__() 方法来定义的，这些方法可以执行异步操作。\n以下是一个示例，展示了如何创建和使用异步上下文管理器：\nimport asyncio\n\nclass AsyncContextManager:\n    async def __aenter__(self):\n        # 在进入上下文之前执行的异步操作\n        await asyncio.sleep(1)\n        print(&quot;AsyncContextManager: Enter&quot;)\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        # 在退出上下文时执行的异步操作\n        await asyncio.sleep(1)\n        print(&quot;AsyncContextManager: Exit&quot;)\n\nasync def main():\n    async with AsyncContextManager():\n        # 在上下文中执行的异步操作\n        await asyncio.sleep(2)\n        print(&quot;Inside async with&quot;)\n\nasyncio.run(main())\n\n在上面的示例中，AsyncContextManager 类实现了 __aenter__() 和 __aexit__() 方法作为异步上下文管理器的定义。在 __aenter__() 方法中，我们可以执行一些异步操作，例如等待特定时间。在 __aexit__() 方法中，我们可以执行一些清理操作。\n在 main() 函数中，我们使用 async with 语句来使用异步上下文管理器。在进入上下文时，会调用 __aenter__() 方法执行异步操作。在退出上下文时，会调用 __aexit__() 方法执行异步操作。\n使用异步上下文管理器可以方便地管理异步资源，例如数据库连接、文件操作等。它们使得在异步环境中处理资源的获取和释放更加简洁和可靠。\n使用场景异步上下文管理器在异步编程中的使用场景包括但不限于以下几个方面：\n\n异步资源管理：当需要在异步环境中管理资源的获取和释放时，可以使用异步上下文管理器。例如，异步数据库连接池的创建和释放、异步文件操作的打开和关闭等。\n\n异步上下文初始化和清理：在进入和退出特定上下文时，需要执行一些异步初始化和清理操作。例如，在异步测试中，可以使用异步上下文管理器来初始化测试环境，在测试结束时清理测试数据。\n\n异步锁的使用：在多个异步任务中需要共享资源时，可以使用异步上下文管理器来管理异步锁的获取和释放。这样可以确保在任务访问共享资源时的同步性。\n\n异步日志记录：在异步环境中进行日志记录时，可以使用异步上下文管理器来处理日志的初始化和清理。例如，在异步请求处理中，可以使用异步上下文管理器来设置请求的上下文信息并进行日志记录。\n\n\n总之，异步上下文管理器可以在异步编程中提供更加灵活和可控的资源管理方式。它们可以用于各种异步任务的初始化、清理和同步操作，以及对共享资源的安全访问。具体的使用场景取决于具体的异步应用和需求。\npython 协程与 nodejs async await 区别Python 协程（Coroutine）和 Node.js 的 async&#x2F;await 在概念和使用方式上有一些区别，尽管它们都是用于异步编程。\n\n语法差异：Python 使用 async 和 await 关键字来定义和管理协程，而 Node.js 使用 async 和 await 关键字来定义和处理异步函数。在 Python 中，await 关键字用于挂起协程的执行，等待异步操作的完成；在 Node.js 中，await 关键字用于等待异步函数返回的 Promise 对象。\n\n底层机制：Python 协程是基于生成器（Generator）实现的，通过生成器的迭代过程来实现协程的切换；Node.js 的 async&#x2F;await 是基于 Promise 对象的，使用 Promise 对象来管理和处理异步操作。\n\n事件循环差异：Python 使用 asyncio 模块提供的事件循环来管理协程的调度和执行；Node.js 使用事件驱动的非阻塞 I&#x2F;O 模型，基于事件循环机制来处理异步任务。\n\n生态系统：Python 的协程生态系统主要以 asyncio 为核心，提供了丰富的异步编程工具和库；Node.js 的异步编程生态系统非常成熟，拥有大量的库和框架，配合 async&#x2F;await 可以进行灵活的异步编程。\n\n\n需要注意的是，Python 的协程和 Node.js 的 async&#x2F;await 在使用方式和语法上有差异，但它们的目的都是为了简化异步编程，提高代码的可读性和可维护性。具体使用哪种方式取决于所使用的编程语言和开发环境，以及特定的需求和约束条件。\nnodejs async&#x2F;await 是 协程？在 JavaScript 中，async/await 机制被广泛认为是一种实现协程（Coroutine）或协作式多任务的方式，但在严格的定义上，它并不是真正的协程。\n协程是一种轻量级的线程，可以通过协作方式进行调度，允许在执行过程中暂停和恢复。协程通常提供更加简洁、直观和可控的异步编程模型，可以减少回调嵌套、提高代码可读性。\nasync/await 是 ECMAScript 2017（ES8）引入的语法糖，用于简化 Promise 的使用和异步代码的编写。通过使用 async 关键字定义一个异步函数，并在函数内使用 await 关键字等待异步操作的结果，可以实现类似于协程的效果。\n虽然 async/await 机制与协程在一些方面具有相似之处，例如可以暂停和恢复执行，但它并没有完全满足协程的定义和特性。JavaScript 中的协程概念仍然处于讨论和探索阶段，并没有官方的原生支持。\n因此，虽然 async/await 在某种程度上可以被看作是一种协程的实现方式，但在严格的定义上，它并不是真正的协程。它更适合用于简化异步代码的编写和提供更直观的异步编程模型。\nnodejs 实现协程在 Node.js 中，可以使用第三方库来实现协程或类似的异步编程模式。以下是一些常用的库和工具，可用于实现协程或类似的机制：\n\nco：co 是一个流程控制库，基于生成器（Generator）实现了一种协程的编程模型。它允许你使用 yield 关键字来暂停和恢复协程的执行，并使用 Promise 来处理异步操作的结果。\n\nBluebird：Bluebird 是一个功能强大的 Promise 库，在其中提供了协程（coroutine）的支持。通过使用 Bluebird 的 coroutine 方法，你可以使用 async&#x2F;await 语法编写类似于协程的代码。\n\nKoa：Koa 是一个轻量级的 Node.js Web 框架，它基于 Generator 实现了一套优雅的异步编程模型。你可以使用 Koa 中间件机制来编写基于协程的异步处理代码。\n\nasync&#x2F;await with Promise：尽管 Node.js 并没有原生的协程支持，但你可以使用 async&#x2F;await 语法结合 Promise 来编写类似于协程的代码。将异步操作封装为 Promise，然后使用 async&#x2F;await 来等待和处理 Promise 的返回值，可以实现一种类似协程的编程模式。\n\n\n需要注意的是，这些库和工具都是基于 JavaScript 语言特性的封装，通过利用生成器、Promise、async&#x2F;await 等功能来实现类似协程的效果。它们在不同的场景和需求下具有不同的特点和适用性。你可以根据自己的需求选择合适的库，并根据相应的文档和示例来使用。\n::&#x3D; 是什么？在编程语言中，::= 是一种符号表示语法规则中的定义或约定关系。它通常用于上下文无关文法（Context-Free Grammar）或语法规范的描述中。\n具体来说，::= 用于指示某个符号或表达式的定义。左侧是要定义的符号或表达式，右侧是该符号或表达式的定义内容。\n例如，假设我们有以下的语法规则：\n&lt;expr&gt; ::&#x3D; &lt;term&gt; &#39;+&#39; &lt;expr&gt;\n         | &lt;term&gt; &#39;-&#39; &lt;expr&gt;\n         | &lt;term&gt;\n&lt;term&gt; ::&#x3D; &lt;factor&gt; &#39;*&#39; &lt;term&gt;\n         | &lt;factor&gt; &#39;&#x2F;&#39; &lt;term&gt;\n         | &lt;factor&gt;\n&lt;factor&gt; ::&#x3D; &#39;(&#39; &lt;expr&gt; &#39;)&#39;\n           | &lt;number&gt;\n&lt;number&gt; ::&#x3D; &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | ...\n\n在这个例子中，::= 表示定义了一系列的语法规则。例如，&lt;expr&gt; 的定义是可以由 &lt;term&gt; &#39;+&#39; &lt;expr&gt;、&lt;term&gt; &#39;-&#39; &lt;expr&gt; 或者 &lt;term&gt; 组成的。每个规则都描述了该符号或表达式的语法结构和语义。\n需要注意的是，::= 不是编程语言的一部分，而是用于语法规范的描述符号。它在文档、教程和编程语言规范中经常被使用，用于说明语法的组成和规则。\n进程通信 multiprocessing 提供了三种方式进行通信在 Python 中，有几种常见的进程间通信的方式，包括使用队列（Queue）、管道（Pipe）、共享内存和套接字（Socket）等。这些方式可以用于不同进程之间的数据传输和通信。\n以下是对这些进程通信方式的简要说明：\n\n队列（Queue）：多个进程可以通过共享队列来进行通信。一个进程可以将数据放入队列，另一个进程则可以从队列中获取数据。Python 提供了 multiprocessing.Queue 和 queue.Queue 等队列类来实现进程间通信。\n\n管道（Pipe）：管道是一种单向通信方式，它可以在两个进程之间传递数据。一个进程将数据发送到管道的写端，另一个进程从管道的读端获取数据。Python 的 multiprocessing.Pipe 类提供了进程间管道通信的功能。\n\n共享内存：多个进程可以通过共享内存来直接访问相同的内存区域。这种方式可以高效地传递大量的数据，但需要注意对共享内存的同步和互斥操作。Python 中的 multiprocessing.Value 和 multiprocessing.Array 等类可用于在进程间共享数据。\n\n套接字（Socket）：套接字是一种用于网络通信的机制，但也可以在同一台机器上的不同进程之间进行通信。进程可以通过套接字发送和接收数据。Python 提供了 socket 模块来支持进程间的套接字通信。\n\n\n这些进程间通信方式各有特点，适用于不同的场景。你可以根据具体的需求选择合适的方式来实现进程间的数据传输和通信。\n队列（Queue）示例 代码增加注释当使用队列（Queue）进行进程间通信时，一个进程可以将数据放入队列，而另一个进程可以从队列中获取数据。下面是一个使用队列的示例代码，其中添加了注释以便理解每个步骤的作用：\nfrom multiprocessing import Process, Queue\n\ndef worker(queue):\n    # 从队列中获取数据\n    data &#x3D; queue.get()\n    print(&quot;Worker received:&quot;, data)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个队列实例\n    queue &#x3D; Queue()\n\n    # 创建一个子进程，传入队列实例作为参数\n    p &#x3D; Process(target&#x3D;worker, args&#x3D;(queue,))\n    p.start()\n\n    # 主进程向队列发送数据\n    queue.put(&quot;Hello, world!&quot;)\n\n    p.join()\n\n在上述示例中，主进程通过 queue.put() 方法将数据放入队列中，而子进程通过 queue.get() 方法从队列中获取数据。这种方式使得进程间可以安全地传递数据，而不需要显式地进行锁定或同步操作。\n请注意，队列是线程安全的，可以同时在多个进程中使用，以实现进程间的通信和数据共享。在示例中，我们使用 multiprocessing.Queue 类来创建队列实例，该类是 Python 多进程模块中提供的一个实现。\n需要注意的是，队列的底层实现使用了管道和锁定等机制，以确保进程间数据的安全传输。这样，你就可以在不同的进程之间传递消息和数据，实现并发和分布式处理。\nTODO: 不看源码，我用不起来\n管道（Pipe）示例 加注释管道（Pipe）是一种用于进程间通信的机制，可以在两个进程之间传递数据。其中一个进程将数据发送到管道的写端，而另一个进程从管道的读端获取数据。下面是一个使用管道进行进程间通信的示例代码，其中添加了注释以便理解每个步骤的作用：\nfrom multiprocessing import Process, Pipe\n\ndef worker(conn):\n    # 从管道中接收数据\n    data &#x3D; conn.recv()\n    print(&quot;Worker received:&quot;, data)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个管道，返回两个连接对象：parent_conn 为父进程的连接，child_conn 为子进程的连接\n    parent_conn, child_conn &#x3D; Pipe()\n\n    # 创建一个子进程，传入子进程的连接对象作为参数\n    p &#x3D; Process(target&#x3D;worker, args&#x3D;(child_conn,))\n    p.start()\n\n    # 主进程向管道发送数据\n    parent_conn.send(&quot;Hello, world!&quot;)\n\n    p.join()\n\n在上述示例中，\n\n主进程通过 parent_conn.send() 方法向管道发送数据，\n而子进程通过 conn.recv() 方法从管道中接收数据。\n管道允许进程间的双向通信，你可以在需要时在两个连接对象之间进行发送和接收操作。\n\n需要注意的是，\n\n管道是一种单向通信方式，即数据只能从一个方向流动。\n在示例中，主进程将数据发送到管道的写端（parent_conn），而子进程从管道的读端（conn）接收数据。\n如果需要双向通信，可以创建两个管道，一个用于父进程向子进程发送数据，另一个用于子进程向父进程发送数据。\n使用管道进行进程间通信可以方便地实现数据的传递和共享，无需显式地进行锁定或同步操作。\n在示例中，我们使用 multiprocessing.Pipe 类来创建管道对象，该类是 Python 多进程模块中提供的一个实现。\n\n管道双向通信示例加注释在 Python 中，管道（Pipe）提供了一种双向通信的方式，可以实现父进程和子进程之间的数据传递和交互。下面是一个使用管道进行双向通信的示例代码，其中添加了注释以便理解每个步骤的作用：\nfrom multiprocessing import Process, Pipe\n\ndef parent(conn):\n    # 向子进程发送数据\n    conn.send(&quot;Hello from parent&quot;)\n    # 从子进程接收数据\n    data &#x3D; conn.recv()\n    print(&quot;Parent received:&quot;, data)\n\ndef child(conn):\n    # 从父进程接收数据\n    data &#x3D; conn.recv()\n    print(&quot;Child received:&quot;, data)\n    # 向父进程发送数据\n    conn.send(&quot;Hello from child&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个管道，返回两个连接对象：parent_conn为父进程的连接，child_conn为子进程的连接\n    parent_conn, child_conn &#x3D; Pipe()\n\n    # 创建父进程和子进程，分别传入连接对象作为参数\n    p1 &#x3D; Process(target&#x3D;parent, args&#x3D;(parent_conn,))\n    p2 &#x3D; Process(target&#x3D;child, args&#x3D;(child_conn,))\n\n    p1.start()\n    p2.start()\n\n    p1.join()\n    p2.join()\n\n在上述示例中，父进程和子进程通过管道进行双向通信。父进程首先向子进程发送数据，然后等待接收子进程的回复。子进程首先接收父进程发送的数据，然后向父进程发送回复数据。\n通过管道进行双向通信时，父进程和子进程分别使用连接对象的 send() 方法发送数据，并使用 recv() 方法接收数据。父进程创建的连接对象 parent_conn 用于向子进程发送数据和接收子进程的回复，而子进程创建的连接对象 child_conn 则相反。\n双向通信使得父进程和子进程可以轻松地进行数据的交互和协作。管道提供了一种方便的机制来实现进程间的双向数据传递，无需显式地进行锁定或同步操作。\n共享内存示例加注释在 Python 中，共享内存是一种进程间通信的方式，它允许多个进程访问和修改相同的内存空间。下面是一个使用共享内存进行进程间通信的示例代码，其中添加了注释以便理解每个步骤的作用：\nfrom multiprocessing import Process, Value, Array\n\ndef square(n, arr):\n    # 修改共享内存中的值\n    for i in range(len(arr)):\n        arr[i] &#x3D; arr[i] ** 2\n    # 修改共享内存中的变量\n    n.value &#x3D; n.value ** 2\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # 创建一个共享内存变量\n    num &#x3D; Value(&#39;i&#39;, 5)\n    # 创建一个共享内存数组\n    nums &#x3D; Array(&#39;i&#39;, [1, 2, 3, 4, 5])\n\n    # 创建一个子进程，传入共享内存变量和共享内存数组作为参数\n    p &#x3D; Process(target&#x3D;square, args&#x3D;(num, nums))\n    p.start()\n    p.join()\n\n    # 打印共享内存变量的值\n    print(&quot;Square of num:&quot;, num.value)\n    # 打印共享内存数组的值\n    print(&quot;Square of nums:&quot;, nums[:])\n\n在上述示例中，我们使用了 multiprocessing.Value 和 multiprocessing.Array 函数来创建共享内存变量和共享内存数组。共享内存变量用于存储一个整数值，共享内存数组用于存储一组整数。\n子进程通过遍历共享内存数组并计算每个元素的平方，并将结果保存回共享内存数组。同时，子进程还将共享内存变量的值平方后修改为新的值。\n主进程等待子进程执行完毕后，打印共享内存变量和共享内存数组的值。可以看到，共享内存中的数据可以在多个进程之间共享和修改，实现了进程间的数据共享。\n需要注意的是，共享内存在进程间共享数据时需要谨慎操作，需要保证对共享内存的读写操作是原子的或进行合适的同步操作，以避免出现竞态条件和数据不一致的问题。\n套接字（Socket）示例注释，及原理，为什么可以实现进程通信下面是一个使用套接字（Socket）进行进程通信的示例代码，并附带了注释以解释每个步骤的作用：\nimport socket\nimport os\nimport time\n\n# 创建一个套接字对象\ns &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 绑定地址和端口\ns.bind((&#39;localhost&#39;, 8888))\n\n# 监听连接\ns.listen(1)\n\nprint(&quot;Server is listening for incoming connections...&quot;)\n\ndef handle_client(client_socket):\n    # 接收客户端的数据\n    data &#x3D; client_socket.recv(1024).decode()\n    print(&quot;Received data:&quot;, data)\n\n    # 发送响应给客户端\n    response &#x3D; &quot;Hello from server!&quot;\n    client_socket.send(response.encode())\n\n    # 关闭客户端连接\n    client_socket.close()\n\nwhile True:\n    # 等待客户端连接\n    client_socket, address &#x3D; s.accept()\n    print(&quot;Connected to:&quot;, address)\n\n    # 创建一个子进程来处理客户端连接\n    pid &#x3D; os.fork()\n\n    if pid &#x3D;&#x3D; 0:\n        # 子进程处理客户端连接\n        handle_client(client_socket)\n        os._exit(0)\n    else:\n        # 父进程关闭客户端连接\n        client_socket.close()\n\n在上述示例中，我们创建了一个服务器程序，使用套接字实现进程间通信。主要的步骤如下：\n\n创建一个套接字对象：使用 socket.socket() 函数创建一个套接字对象，指定地址族（AF_INET）和套接字类型（SOCK_STREAM）。\n\n绑定地址和端口：使用 bind() 方法将套接字绑定到指定的地址和端口。\n\n监听连接：使用 listen() 方法开始监听连接请求。\n\n接受客户端连接：使用 accept() 方法接受客户端的连接请求，并返回一个新的套接字对象和客户端地址。\n\n创建子进程处理连接：使用 os.fork() 创建一个子进程，并在子进程中处理客户端连接。父进程则继续监听其他连接请求。\n\n子进程处理客户端连接：子进程通过套接字接收客户端发送的数据，并发送响应数据给客户端。最后关闭客户端连接。\n\n\n通过套接字，可以实现进程间的通信。套接字提供了一种基于网络的通信机制，它允许进程在不同的主机之间进行通信。在示例中，服务器通过监听和接受客户端连接，创建子进程来处理每个连接，从而实现了多个进程之间的通信。\n套接字使用网络协议（如 TCP&#x2F;IP）来传输数据，并通过地址和端口来标识进程。服务器绑定一个地址和端口，监听连接请求，客户端发起连接请求后，服务器接受连接并创建一个新的套接字与客户端进行通信。这样，进程间就可以通过套接字进行数据的发送和接收，实现进程间的通信和\n上述进程通信方式中，哪些可以跨机器？在上述进程通信方式中，以下两种方式可以跨机器进行通信：\n\n套接字（Socket）：使用网络套接字（例如 TCP&#x2F;IP 套接字）可以在不同的主机之间进行通信。可以通过指定远程主机的 IP 地址和端口号来连接到远程主机，并在不同的机器之间传输数据。\n\n网络共享：通过网络共享可以在不同的机器之间共享文件和资源。例如，可以在一个机器上创建共享文件夹，然后通过网络访问该文件夹并在不同的机器之间传输文件。\n\n\n需要注意的是，跨机器通信需要确保网络连接和配置正确，包括正确的 IP 地址、端口号、网络设置等。此外，还需要考虑网络安全和权限管理等方面的问题，以确保通信的安全性和可靠性。\npython 进程通信 方式比较优劣可以简单总结如下：\n\n队列：简单易用，支持多进程，多线程，可以实现多进程间的数据传输，但只能用于本机进程通信。\n管道：相对来说比较底层，但是性能较高，支持双向通信，可以用于本机多进程通信。\n共享内存：性能很好，可以用于本机多进程通信，但使用起来比较麻烦，需要手动管理内存。\n套接字：功能最为强大，可以用于本机和网络通信，但使用起来比较复杂，需要手动编写网络协议。\n\n详细内容Python 中有多种进程通信方式可供选择，每种方式都有其优劣之处。下面是几种常见的进程通信方式的比较：\n\n队列（Queue）：使用multiprocessing.Queue可以在多个进程之间安全地传递数据。队列提供了先进先出的数据结构，适用于生产者-消费者模型。优点是简单易用、线程安全，缺点是性能相对较低。\n\n管道（Pipe）：使用multiprocessing.Pipe可以在两个进程之间进行双向通信。它提供了一个连接的管道，允许进程之间通过发送和接收消息进行通信。优点是快速且灵活，缺点是只适用于两个进程之间的通信。\n\n共享内存（Shared Memory）：使用multiprocessing.Value和multiprocessing.Array可以在多个进程之间共享内存。共享内存允许多个进程直接访问相同的内存区域，可以高效地进行数据共享。优点是性能高、实时性好，缺点是需要处理同步和互斥问题，较容易引入 bug。\n\n套接字（Socket）：使用套接字进行进程通信可以在不同的主机之间实现通信，适用于分布式系统。它允许不同主机上的进程通过网络传输数据。优点是灵活性高、可扩展性好，缺点是相对复杂，需要考虑网络配置和安全性。\n\n\n选择合适的进程通信方式取决于具体的需求和场景。如果只需要在本地进程之间进行通信，队列和管道通常是较为简单和高效的选择。如果需要在不同主机之间进行通信，套接字可能是更合适的选择。如果需要高性能和实时性，共享内存可能是较好的选择，但需要注意同步和互斥的问题。综合考虑实际需求、性能要求和开发复杂度，选择适当的进程通信方式。\n线程通信 threading 模块，提供了 5 种方式进行通信在多线程编程中，常见的多线程通信方式有以下几种：\n\n共享内存：多个线程可以访问和修改共享的内存区域来进行数据交换。需要注意的是，由于多线程同时访问共享内存可能引发竞态条件和数据不一致的问题，因此需要使用互斥锁、条件变量等机制进行线程同步和数据保护。\n\n队列（Queue）：多个线程可以通过共享的队列来传递数据。队列提供了线程安全的数据结构，可以实现线程间的数据传输，并且内部已经实现了线程同步的机制，无需手动处理线程安全问题。\n\n条件变量（Condition）：条件变量是一种线程同步的机制，它允许线程在满足特定条件时等待，或者在条件满足时被唤醒。多个线程可以通过条件变量来进行线程间的通信和同步。\n\n信号量（Semaphore）：信号量是一种用于控制多个线程对共享资源访问的机制。它可以限制同时访问某个资源的线程数量，从而实现线程间的同步和互斥。\n\n事件（Event）：事件是一种线程间通信的机制，它允许一个线程等待其他线程发出的信号。线程可以通过事件来实现等待&#x2F;通知的机制，从而实现线程间的协调和同步。\n\n\n需要根据具体的多线程编程场景选择合适的线程通信方式。在选择过程中，需要考虑线程安全性、性能要求、代码复杂度等因素。同时，需要注意避免竞态条件、死锁等多线程编程常见的问题。\n线程共享内存通信示例下面是一个简单的示例，演示了多个线程之间如何共享内存：\nimport threading\n\n# 全局变量\nshared_variable &#x3D; 0\n\n# 互斥锁\nlock &#x3D; threading.Lock()\n\n# 线程函数\ndef increment():\n    global shared_variable\n\n    # 获取互斥锁\n    lock.acquire()\n\n    try:\n        # 修改共享变量\n        shared_variable +&#x3D; 1\n        print(f&quot;Thread &#123;threading.current_thread().name&#125;: shared_variable &#x3D; &#123;shared_variable&#125;&quot;)\n    finally:\n        # 释放互斥锁\n        lock.release()\n\n# 创建线程\nthread1 &#x3D; threading.Thread(target&#x3D;increment, name&#x3D;&quot;Thread 1&quot;)\nthread2 &#x3D; threading.Thread(target&#x3D;increment, name&#x3D;&quot;Thread 2&quot;)\n\n# 启动线程\nthread1.start()\nthread2.start()\n\n# 等待线程结束\nthread1.join()\nthread2.join()\n\n# 打印最终结果\nprint(f&quot;Final shared_variable &#x3D; &#123;shared_variable&#125;&quot;)\n\n在上述示例中，我们定义了一个全局变量shared_variable，多个线程通过获取互斥锁来访问和修改这个共享变量。每个线程在执行时先获取互斥锁，然后修改共享变量的值，最后释放互斥锁。这样可以保证在任意时刻只有一个线程能够修改共享变量，从而避免了竞态条件的问题。\n注意，在多线程编程中，对共享内存的访问需要进行适当的同步，以保证数据的一致性和正确性。互斥锁是一种常见的同步机制，可以用于保护共享资源的访问。通过使用互斥锁，我们可以确保每个线程在修改共享变量时是原子的，避免了多个线程同时修改导致的数据不一致问题。\n线程队列通信示例下面是一个简单的示例，演示了多个线程之间如何使用队列进行通信：\nimport threading\nimport queue\n\n# 创建队列\nmessage_queue &#x3D; queue.Queue()\n\n# 线程函数\ndef producer():\n    for i in range(5):\n        # 向队列中放入数据\n        message_queue.put(f&quot;Message &#123;i&#125;&quot;)\n        print(f&quot;Producer: Message &#123;i&#125; put into queue&quot;)\n\n    # 发送结束信号\n    message_queue.put(None)\n    print(&quot;Producer: End of messages&quot;)\n\ndef consumer():\n    while True:\n        # 从队列中获取数据\n        message &#x3D; message_queue.get()\n\n        if message is None:\n            # 接收到结束信号，退出循环\n            print(&quot;Consumer: End of messages&quot;)\n            break\n\n        # 处理数据\n        print(f&quot;Consumer: Received message - &#123;message&#125;&quot;)\n\n    # 通知队列任务完成\n    message_queue.task_done()\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\n\n# 阻塞等待队列中的任务全部处理完毕\nmessage_queue.join()\n\n# 打印最终结果\nprint(&quot;All messages processed&quot;)\n\n在上述示例中，我们创建了一个队列message_queue作为线程之间的通信通道。生产者线程producer将一些消息放入队列中，而消费者线程consumer从队列中获取消息进行处理。当生产者线程放入结束信号（None）后，消费者线程接收到结束信号后退出循环。\n队列提供了线程安全的数据结构，可以在多个线程之间进行数据传递。在这个示例中，我们使用了queue.Queue作为队列实现，它自带了线程同步的机制，无需手动处理线程安全问题。生产者线程通过put方法将消息放入队列中，消费者线程通过get方法从队列中获取消息。当队列为空时，消费者线程会自动阻塞等待，直到队列中有新的消息可用。\n注意，在使用线程队列通信时，需要注意线程的启动顺序和结束条件，以确保线程能够正确地进行通信和同步。在示例中，我们使用了None作为结束信号，以告知消费者线程已经处理完所有消息。同时，我们还使用queue.join方法阻塞等待队列中的任务全部处理完毕，以确保所有消息都被消费者线程处理完毕。\n线程条件变量通信示例下面是一个简单的示例，演示了多个线程之间如何使用条件变量进行通信：\nimport threading\n\n# 条件变量\ncondition &#x3D; threading.Condition()\n\n# 共享资源\nresource &#x3D; None\n\n# 线程函数\ndef producer():\n    global resource\n\n    with condition:\n        # 生产资源\n        resource &#x3D; &quot;Hello, World!&quot;\n        print(&quot;Producer: Resource produced&quot;)\n\n        # 通知等待的线程\n        condition.notify()\n\ndef consumer():\n    global resource\n\n    with condition:\n        # 等待资源生产\n        while resource is None:\n            condition.wait()\n\n        # 消费资源\n        print(f&quot;Consumer: Received resource - &#123;resource&#125;&quot;)\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\nconsumer_thread.join()\n\n# 打印最终结果\nprint(&quot;All threads completed&quot;)\n\n在上述示例中，我们使用了条件变量condition来实现线程之间的通信和同步。生产者线程producer在生产资源后，使用condition.notify()通知等待的线程。消费者线程consumer在消费资源前，使用condition.wait()等待生产者线程的通知。\n条件变量提供了一种线程间的通信方式，允许线程在某个条件满足时进行通知和等待。\n在示例中，\n\n生产者线程通过修改共享变量resource来表示资源的生产，\n而消费者线程通过检查resource是否为空来判断是否有资源可消费。\n通过条件变量的等待和通知操作，生产者线程和消费者线程能够实现协同工作，确保资源的正确生产和消费。\n\n注意，在使用条件变量时，\n\n需要使用with语句来获取条件变量的锁，以确保线程安全。\n使用with condition可以自动获取锁并在退出with块时自动释放锁。\n这样可以确保在等待和通知操作时，只有一个线程能够访问和修改共享资源，避免竞态条件的问题。\n\n线程信号量通信示例下面是一个简单的示例，演示了多个线程之间如何使用信号量进行通信：\nimport threading\n\n# 信号量\nsemaphore &#x3D; threading.Semaphore(0)\n\n# 共享资源\nresource &#x3D; None\n\n# 线程函数\ndef producer():\n    global resource\n\n    # 生产资源\n    resource &#x3D; &quot;Hello, World!&quot;\n    print(&quot;Producer: Resource produced&quot;)\n\n    # 释放信号量\n    semaphore.release()\n\ndef consumer():\n    global resource\n\n    # 等待信号量\n    semaphore.acquire()\n\n    # 消费资源\n    print(f&quot;Consumer: Received resource - &#123;resource&#125;&quot;)\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\nconsumer_thread.join()\n\n# 打印最终结果\nprint(&quot;All threads completed&quot;)\n\n在上述示例中，我们使用了信号量semaphore来进行线程之间的通信。\n\n在生产者线程producer中，我们首先生产资源，然后使用semaphore.release()释放信号量。\n在消费者线程consumer中，我们使用semaphore.acquire()等待信号量被释放，然后再进行资源的消费。\n\n信号量提供了一种线程间的通信方式，允许控制并发访问共享资源的线程数。\n\n在示例中，我们通过设置信号量的初始值为 0，表示一开始资源不可用，\n生产者线程先生产资源后释放信号量，\n消费者线程再等待信号量被释放后进行资源的消费。\n\n注意，在使用信号量时，\n\n需要注意合理控制信号量的释放和等待操作，\n以确保线程能够正确地进行同步和通信。\n同时，要注意使用适当的初始值来控制线程的执行顺序和互斥访问共享资源的能力。\n\n线程事件通信示例下面是一个简单的示例，演示了多个线程之间如何使用事件进行通信：\nimport threading\n\n# 事件\nevent &#x3D; threading.Event()\n\n# 共享资源\nresource &#x3D; None\n\n# 线程函数\ndef producer():\n    global resource\n\n    # 生产资源\n    resource &#x3D; &quot;Hello, World!&quot;\n    print(&quot;Producer: Resource produced&quot;)\n\n    # 设置事件为已触发状态\n    event.set()\n\ndef consumer():\n    global resource\n\n    # 等待事件触发\n    event.wait()\n\n    # 消费资源\n    print(f&quot;Consumer: Received resource - &#123;resource&#125;&quot;)\n\n# 创建线程\nproducer_thread &#x3D; threading.Thread(target&#x3D;producer)\nconsumer_thread &#x3D; threading.Thread(target&#x3D;consumer)\n\n# 启动线程\nproducer_thread.start()\nconsumer_thread.start()\n\n# 等待生产者线程结束\nproducer_thread.join()\nconsumer_thread.join()\n\n# 打印最终结果\nprint(&quot;All threads completed&quot;)\n\n在上述示例中，我们使用了事件event来进行线程之间的通信。在生产者线程producer中，我们首先生产资源，然后使用event.set()将事件设置为已触发状态。在消费者线程consumer中，我们使用event.wait()等待事件被触发，然后再进行资源的消费。\n事件提供了一种线程间的通信方式，允许一个或多个线程等待某个事件的触发。在示例中，我们首先将事件设置为未触发状态，当生产者线程生产资源后，设置事件为已触发状态，消费者线程就可以被唤醒并开始消费资源。\n注意，在使用事件时，要注意合理设置事件的触发和等待操作，以确保线程能够正确地进行同步和通信。同时，可以通过事件的设置和清除来控制线程的执行流程和资源的可用性。\n上述线程通信与进程通信的区别线程通信和进程通信的区别主要体现在以下几个方面：\n\n范围：线程通信是在同一个进程内的多个线程之间进行的，而进程通信是在不同进程之间进行的。\n\n共享资源：线程通信中的多个线程可以直接共享同一份内存空间中的数据，因此可以通过共享变量等方式进行通信。而进程通信中的多个进程之间是相互独立的，每个进程有自己独立的内存空间，无法直接共享数据。\n\n通信机制：线程通信可以使用共享变量、锁、条件变量、信号量、事件等机制进行通信和同步。进程通信则需要使用特定的通信机制，如管道、队列、共享内存、套接字等。\n\n上下文切换开销：线程通信由于线程共享内存，上下文切换开销较小，通信速度相对较快。而进程通信需要通过内核提供的通信机制进行数据传输，涉及到进程间的上下文切换，开销相对较大，通信速度较慢。\n\n跨平台性：由于线程通信是在同一个进程内进行的，所以在同一平台上的不同线程通信方式基本上是一致的。而进程通信需要跨越不同的进程，因此在不同操作系统上的进程通信方式可能有所不同。\n\n\n综上所述，线程通信更适用于在同一个进程内的多个线程之间进行数据共享和协同工作，适合处理一些相对简单的并发任务。进程通信更适用于不同进程之间的数据交换和协作，适合处理复杂的并发任务和跨平台的场景。选择合适的通信方式需要根据具体的需求和应用场景来决定。\n协程、线程、进程通信，各是为了解决什么问题？协程、线程和进程通信都是为了解决并发编程中的数据共享和协同工作的问题，但它们在不同的层次和场景下有不同的目的和特点。\n\n协程通信：协程通信是在单线程内的并发编程中，通过协程之间的切换和协作来实现任务的并发执行。它的目的是充分利用单线程的资源，提高程序的执行效率。协程通信适用于需要在单线程中处理大量的任务和 I&#x2F;O 操作的情况，以提高程序的响应性和并发能力。\n\n线程通信：线程通信是在多线程编程中，通过多个线程之间的数据共享和同步来实现任务的并发执行。它的目的是通过并发执行多个线程，充分利用多核处理器的资源，提高程序的执行效率。线程通信适用于多核&#x2F;多 CPU 环境下的并发任务，可以通过共享变量、锁、条件变量、队列等机制来实现线程之间的数据交换和协同工作。\n\n进程通信：进程通信是在多进程编程中，通过多个独立的进程之间的数据传输和协作来实现任务的并发执行。它的目的是通过多个独立的进程，充分利用多个计算机节点或多个计算机上的多核处理器的资源，提高程序的执行效率和扩展性。进程通信适用于分布式系统、并行计算和跨平台通信等场景，可以通过管道、消息队列、共享内存、套接字等机制来实现进程之间的数据传输和协同工作。\n\n\n总而言之，\n\n协程通信适用于单线程内的并发任务，\n线程通信适用于多核&#x2F;多 CPU 环境下的并发任务，\n进程通信适用于分布式系统和跨平台通信等场景。\n选择合适的通信方式需要根据具体的需求和应用场景来决定。\n\n","slug":"2023-05-06python","date":"2023-05-06T09:44:08.000Z","categories_index":"Python","tags_index":"Python","author_index":"举手摘月亮"},{"id":"d38ec567dd1420f161a414e047d4332c","title":"简单了解Jest","content":"toBeFalsy 是什么意思toBeFalsy 是 Jest 和 Jasmine 中的一个匹配器（Matcher），用于判断一个值是否为假值。如果一个值可以被强制转换为 false，则该值被视为假值。\n例如，以下值被视为假值：\n\nfalse\n0\n-0\n0n (BigInt 0)\n&quot;&quot; (空字符串)\nnull\nundefined\nNaN\n\n使用 toBeFalsy 匹配器可以将值与假值进行比较，例如：\nexpect(false).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(0).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(&#39;&#39;).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(null).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(undefined).toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(NaN).toBeFalsy(); &#x2F;&#x2F; 通过测试\n\nexpect(true).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(1).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(&#39;hello&#39;).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect(&#123;&#125;).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\nexpect([]).not.toBeFalsy(); &#x2F;&#x2F; 通过测试\n\n注意，toBeFalsy 会将一些本来是真值的数据类型（如字符串、对象、数组等）视为假值，因此在使用时要特别小心。\njest 匹配器有哪些Jest 是一款流行的 JavaScript 测试框架，内置了许多强大的匹配器（Matcher），可以用于编写各种类型的测试用例。下面列举了一些常用的 Jest 匹配器：\n\ntoBe：比较两个值是否严格相等，即使用 Object.is 进行比较。\n\ntoEqual：比较两个值是否相等，即递归地检查对象和数组的每个字段是否相等。\n\ntoBeGreaterThan：判断一个数值是否大于另一个数值。\n\ntoBeGreaterThanOrEqual：判断一个数值是否大于或等于另一个数值。\n\ntoBeLessThan：判断一个数值是否小于另一个数值。\n\ntoBeLessThanOrEqual：判断一个数值是否小于或等于另一个数值。\n\ntoContain：判断一个数组或字符串是否包含某个元素或子串。\n\ntoMatch：判断一个字符串是否匹配某个正则表达式。\n\ntoThrow：判断一个函数是否抛出了某个异常。\n\nnot：将一个匹配器的结果取反。\n\ntoBeNull：判断一个值是否为 null。\n\ntoBeDefined：判断一个值是否已定义。\n\ntoBeUndefined：判断一个值是否为 undefined。\n\ntoBeTruthy：判断一个值是否为真值。\n\ntoBeFalsy：判断一个值是否为假值。\n\ntoHaveLength：判断一个对象的 length 属性是否等于某个值。\n\ntoHaveProperty：判断一个对象是否包含某个属性。\n\ntoHaveReturned：判断一个函数是否有返回值。\n\ntoHaveReturnedWith：判断一个函数的返回值是否等于某个值。\n\ntoHaveBeenLastCalledWith：判断一个函数最后一次调用时的参数是否符合预期。\n\n\n还有许多其他的匹配器可以用于不同的测试场景，可以在 Jest 的官方文档中查看更多详细信息。\ntoBeCloseTo 与 toEqual 区别toBeCloseTo 和 toEqual 都是 Jest 中常用的匹配器，用于比较两个值是否相等。它们之间的区别在于，toBeCloseTo 用于比较浮点数是否相等，而 toEqual 则用于比较两个值是否在递归地检查对象和数组的每个字段是否相等的情况下相等。\n具体来说，toBeCloseTo 可以在比较两个浮点数时避免由于浮点数精度问题导致的误差。例如，如果你想要比较 0.1 + 0.2 和 0.3 是否相等，使用 toBeCloseTo 匹配器可以避免精度误差导致的测试失败，例如：\ntest(&#39;0.1 + 0.2 should be close to 0.3&#39;, () &#x3D;&gt; &#123;\n  expect(0.1 + 0.2).toBeCloseTo(0.3);\n&#125;);\n\n相比之下，如果你使用 toEqual 匹配器进行比较，则测试可能会失败，因为 0.1 + 0.2 的实际结果可能会有小数精度误差，例如：\ntest(&#39;0.1 + 0.2 should equal to 0.3&#39;, () &#x3D;&gt; &#123;\n  expect(0.1 + 0.2).toEqual(0.3); &#x2F;&#x2F; This test may fail due to floating point precision error\n&#125;);\n\n总之，toBeCloseTo 匹配器用于比较浮点数是否相等，而 toEqual 匹配器用于比较两个值是否在递归地检查对象和数组的每个字段是否相等的情况下相等。\njest beforeEach 和 afterEach 执行特点beforeEach 和 afterEach 是 Jest 中用于在每个测试用例执行前和执行后执行代码的函数。beforeEach 用于初始化测试用例的状态，afterEach 用于清理测试用例的状态。它们可以在全局或局部范围内使用，支持嵌套使用和异步操作。在使用时需要注意它们的执行顺序和异常处理。\n见\n\nDetails\nbeforeEach 和 afterEach 是 Jest 中用于在每个测试用例执行之前和之后执行一些代码的函数。它们的执行特点如下：\n\nbeforeEach 函数会在每个测试用例执行之前执行一次，用于设置测试用例执行前的状态或进行一些共同的初始化操作。多个测试用例可以共享同一个 beforeEach 函数。\n\nafterEach 函数会在每个测试用例执行之后执行一次，用于清理测试用例执行后的状态或进行一些共同的清理操作。多个测试用例可以共享同一个 afterEach 函数。\n\n\n这些函数的作用类似于测试用例中的 setup 和 teardown，但是它们更加灵活，可以在全局或局部范围内使用，并且可以在多个测试用例之间共享代码。\n在使用 beforeEach 和 afterEach 函数时，需要注意以下几点：\n\nbeforeEach 和 afterEach 函数可以嵌套使用，形成多级的设置和清理操作。\n\n如果多个 beforeEach 或 afterEach 函数在同一个作用域中定义，它们的执行顺序是按照定义顺序从上到下执行的。\n\n如果在一个测试用例中使用了异步操作，可以在 beforeEach 或 afterEach 函数中使用 async/await 或者 return Promise 来处理异步操作。\n\n如果在 beforeEach 或 afterEach 函数中抛出了异常，会导致该测试用例的执行失败，而不会影响其他测试用例的执行。\n\n\n总之，beforeEach 和 afterEach 函数是 Jest 中非常实用的函数，可以用于在测试用例执行前和执行后进行初始化和清理操作，提高测试用例的可维护性和可重复性。\n\n\n执行顺序默认情况下，Jest 会按照收集阶段遇到的顺序连续运行所有测试，等待每个测试完成并在继续之前进行整理\n简单来说：就是一层一层扒皮，逐层深入进行测试\ndescribe(&#39;describe outer&#39;, () &#x3D;&gt; &#123;\n  console.log(&#39;describe outer-a&#39;);\n\n  describe(&#39;describe inner 1&#39;, () &#x3D;&gt; &#123;\n    console.log(&#39;describe inner 1&#39;);\n\n    test(&#39;test 1&#39;, () &#x3D;&gt; console.log(&#39;test 1&#39;));\n  &#125;);\n\n  console.log(&#39;describe outer-b&#39;);\n\n  test(&#39;test 2&#39;, () &#x3D;&gt; console.log(&#39;test 2&#39;));\n\n  describe(&#39;describe inner 2&#39;, () &#x3D;&gt; &#123;\n    console.log(&#39;describe inner 2&#39;);\n\n    test(&#39;test 3&#39;, () &#x3D;&gt; console.log(&#39;test 3&#39;));\n  &#125;);\n\n  console.log(&#39;describe outer-c&#39;);\n&#125;);\n\n&#x2F;&#x2F; describe outer-a\n&#x2F;&#x2F; describe inner 1\n&#x2F;&#x2F; describe outer-b\n&#x2F;&#x2F; describe inner 2\n&#x2F;&#x2F; describe outer-c\n&#x2F;&#x2F; test 1\n&#x2F;&#x2F; test 2\n&#x2F;&#x2F; test 3\n\n执行整个测试&#x2F;执行一个测试test.only(&#39;this will be the only test that runs&#39;, () &#x3D;&gt; &#123;\n  expect(true).toBe(false);\n&#125;);\n\ntest(&#39;this test will not run&#39;, () &#x3D;&gt; &#123;\n  expect(&#39;A&#39;).toBe(&#39;A&#39;);\n&#125;);\n\ntest.only 执行单个测试，未使用 test.only 的将会被 skip\n\n","slug":"2023-05-05jest","date":"2023-05-05T06:25:39.000Z","categories_index":"Jest","tags_index":"Jest","author_index":"举手摘月亮"},{"id":"0a2a2b57038aa5719495ef60739019cc","title":"Gorm的一些疑问","content":"gormgorm 中文文档\ngolang gorm 有哪些 APIGolang 的 ORM 库 GORM 是一个流行的数据库操作库，提供了丰富的 API 用于进行数据库操作。以下是 GORM 库的一些常用 API：\n\n创建连接：\n\ndb, err :&#x3D; gorm.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1:3306)&#x2F;dbname?charset&#x3D;utf8&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;)\n\n\n定义模型（定义数据库表结构）：\n\ntype User struct &#123;\n    ID   uint\n    Name string\n    Age  int\n&#125;\n\n\n创建表：\n\ndb.CreateTable(&amp;User&#123;&#125;)\n\n\n插入记录：\n\nuser :&#x3D; User&#123;Name: &quot;John&quot;, Age: 30&#125;\ndb.Create(&amp;user)\n\n\n查询记录：\n\nvar user User\ndb.First(&amp;user, 1) &#x2F;&#x2F; 查询ID为1的记录并将结果存入user变量\n\n\n更新记录：\n\ndb.Model(&amp;user).Update(&quot;Age&quot;, 40) &#x2F;&#x2F; 将user的Age字段更新为40\n\n\n删除记录：\n\ndb.Delete(&amp;user) &#x2F;&#x2F; 删除user记录\n\n\n查询多条记录：\n\nvar users []User\ndb.Find(&amp;users)\n\n\n使用条件查询：\n\ndb.Where(&quot;age &gt; ?&quot;, 30).Find(&amp;users) &#x2F;&#x2F; 查询年龄大于30的记录\n\n\n使用事务：\n\ntx :&#x3D; db.Begin()\n&#x2F;&#x2F; 在事务中执行数据库操作\ntx.Create(&amp;user)\ntx.Delete(&amp;user)\ntx.Commit() &#x2F;&#x2F; 提交事务\n\n\n使用预加载（Eager Loading）优化查询：\n\nvar users []User\ndb.Preload(&quot;Profile&quot;).Find(&amp;users) &#x2F;&#x2F; 预加载关联的Profile模型，减少查询次数\n\n以上只是 GORM 库提供的一部分 API，GORM 还提供了许多其他功能，如关联查询、分页查询、原生 SQL 执行、钩子函数等。你可以查看 GORM 官方文档（https://gorm.io）以获取更详细的API参考和示例代码。\n一对一在 GORM 中，一对一（One-to-One）关联是指两个模型之间的关联关系，其中一个模型的实例对应着另一个模型的实例。以下是 GORM 中一对一关联的常用 API：\n\n定义模型：\n\ntype User struct &#123;\n    ID       uint\n    Name     string\n    Age      int\n    Profile  Profile &#x2F;&#x2F; 与Profile模型建立一对一关联\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    UserID   uint &#x2F;&#x2F; 通过UserID字段与User模型建立外键关联\n    Address  string\n&#125;\n\n\n创建表：\n\ndb.CreateTable(&amp;User&#123;&#125;)\ndb.CreateTable(&amp;Profile&#123;&#125;)\n\n\n插入记录：\n\nprofile :&#x3D; Profile&#123;Address: &quot;1234 Main St.&quot;&#125;\nuser :&#x3D; User&#123;Name: &quot;John&quot;, Age: 30, Profile: profile&#125; &#x2F;&#x2F; 将Profile关联到User\ndb.Create(&amp;user)\n\n\n查询记录（包含关联记录）：\n\nvar user User\ndb.Preload(&quot;Profile&quot;).First(&amp;user, 1) &#x2F;&#x2F; 查询ID为1的User记录，并关联查询其对应的Profile记录\n\n\n更新关联记录：\n\ndb.Model(&amp;user).Update(&quot;Profile.Address&quot;, &quot;5678 Elm St.&quot;) &#x2F;&#x2F; 更新关联的Profile记录的Address字段\n\n\n解除关联关系：\n\ndb.Model(&amp;user).Association(&quot;Profile&quot;).Delete(&amp;user.Profile) &#x2F;&#x2F; 解除User与Profile的关联关系\n\n需要注意的是，GORM 中的一对一关联需要通过外键字段进行关联，如上面的示例中的UserID字段。GORM 还提供了其他丰富的一对一关联操作，如设置外键、设置级联关系、查询关联记录、创建关联记录等。详细的一对一关联操作请参考 GORM 官方文档（https://gorm.io/docs/associations.html#one-to-one）以获取更详细的API参考和示例代码。\n理解\nbelongto，我属于你，你给我打标记\nhasone 我拥有你，我给你打标记\nbelongto 是 hasone 的反向，从我的角度：我是你的，从你的角度：你是拥有我的\n\nbelongto 与 hasone 的区别\nbelongto: 在包含外键的模型中定义关联字段来实现\nhasone: 在包含外键的模型中定义关联字段，并在关联的模型中添加外键字段来实现\n\n在 GORM 中，BelongsTo和HasOne是两种不同的关联类型，用于建立模型之间的关联关系，分别表示一对一的反向关联和正向关联。\n\nBelongsTo关联：BelongsTo表示一对一的反向关联，即一个模型关联到另一个模型，但另一个模型没有关联回来。在数据库中，这通常通过在包含外键的模型中定义关联字段来实现。例如：\n\ntype User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; BelongsTo关联，一个User对应一个Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;\n\n在上面的示例中，Profile模型通过在其定义中添加一个UserID字段与User模型建立了BelongsTo关联，表示一个Profile对应一个User。\n\nHasOne关联：HasOne表示一对一的正向关联，即一个模型关联到另一个模型，并且另一个模型也关联回来。在数据库中，这通常通过在包含外键的模型中定义关联字段，并在关联的模型中添加外键字段来实现。例如：\n\ntype User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; HasOne关联，一个User对应一个Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    User     User &#x2F;&#x2F; 关联回User模型\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;\n\n在上面的示例中，User模型通过在其定义中添加一个Profile字段与Profile模型建立了HasOne关联，表示一个User对应一个Profile，并且Profile模型通过在其定义中添加一个UserID字段与User模型建立了外键关联，并关联回了User模型。\n总结而言，BelongsTo关联表示一对一的反向关联，只在包含外键的模型中定义关联字段；而HasOne关联表示一对一的正向关联，既在包含外键的模型中定义关联字段，也在关联的模型中添加外键字段并关联回来。\n两者在使用上略有差异，具体的选择取决于你的数据模型设计和业务需求。\ngorm BelongsTo 和 HasOne 的适用场景在 GORM 中，BelongsTo和HasOne是两种不同的关联类型，适用于不同的场景。\n\nBelongsTo适用场景：BelongsTo表示一对一的反向关联，适用于以下场景：\n\n\n当一个模型（称为子模型）属于另一个模型（称为父模型），并且子模型中包含了父模型的外键字段时。\n当你需要在查询子模型时，自动加载关联的父模型。\n\n例如，一个用户（User）模型关联一个配置文件（Profile）模型，其中配置文件（Profile）模型包含了用户（User）模型的外键字段，那么可以使用BelongsTo关联来表示这种关系。\n&#x2F;&#x2F; 父模型\ntype User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; BelongsTo关联，一个User对应一个Profile\n&#125;\n&#x2F;&#x2F; 子模型 子模型中包含了父模型的外键字段时\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;\n\n\nHasOne适用场景：HasOne表示一对一的正向关联，适用于以下场景：\n\n\n当一个模型（称为父模型）关联一个模型（称为子模型），并且子模型中包含了父模型的外键字段时。\n当你需要在查询父模型时，自动加载关联的子模型。\n\n例如，一个用户（User）模型关联一个配置文件（Profile）模型，其中用户（User）模型包含了配置文件（Profile）模型的外键字段，那么可以使用HasOne关联来表示这种关系。\n&#x2F;&#x2F; 父模型\ntype User struct &#123;\n    ID       uint\n    Profile  Profile &#x2F;&#x2F; HasOne关联，一个User对应一个Profile\n&#125;\n&#x2F;&#x2F; 子模型， 子模型中包含了父模型的外键字段时\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    User     User &#x2F;&#x2F; 关联回User模型\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到User模型\n&#125;\n\n需要根据具体的数据模型设计和业务需求来选择使用BelongsTo还是HasOne关联。如果子模型包含了父模型的外键字段，则使用BelongsTo关联；如果父模型包含了子模型的外键字段，并且需要在查询父模型时自动加载关联的子模型，则使用HasOne关联。\n两者在数据库数据查询返回有什么不同在 GORM 中，BelongsTo和HasOne在数据库数据查询返回时有一些不同。\n\nBelongsTo关联：\n\n\n当使用BelongsTo关联时，通过查询子模型（包含外键字段）可以自动加载关联的父模型。例如，当查询用户（User）模型时，可以自动加载关联的配置文件（Profile）模型，从而在结果中包含了关联的父模型的数据。\n\nvar user User\ndb.Preload(&quot;Profile&quot;).First(&amp;user)\n&#x2F;&#x2F; 上述代码中，使用了Preload方法加载了关联的Profile模型，从而在查询用户模型时自动加载了关联的父模型数据。\n\n\nHasOne关联：\n\n\n当使用HasOne关联时，通过查询父模型（包含子模型的外键字段）可以自动加载关联的子模型。例如，当查询配置文件（Profile）模型时，可以自动加载关联的用户（User）模型，从而在结果中包含了关联的子模型的数据。\n\nvar profile Profile\ndb.Preload(&quot;User&quot;).First(&amp;profile)\n&#x2F;&#x2F; 上述代码中，使用了Preload方法加载了关联的User模型，从而在查询配置文件模型时自动加载了关联的子模型数据。\n\n需要注意的是，在使用BelongsTo和HasOne关联时，都可以使用 GORM 提供的Preload方法来进行预加载，从而在查询时自动加载关联的模型数据，避免了 N+1 查询问题。具体的查询返回结果会根据你的数据模型设计和数据库查询操作而有所不同，但通过预加载关联模型，可以方便地获取关联的数据并避免额外的数据库查询。\nUser BelongsTo Profile对不起，我之前的回答中确实遗漏了 GORM 中关联关系的 tag 设置。下面是正确的示例代码：\n使用 BelongsTo 关联时的结构体定义：\ntype User struct &#123;\n    ID       uint\n    Profile  Profile   &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96; &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n    UserID   uint &#x2F;&#x2F; 外键字段，用于关联到 User 模型\n&#125;\n\nUser HasOne Profile使用 HasOne 关联时的结构体定义：\ntype User struct &#123;\n    ID       uint\n    Profile  Profile   &#96;gorm:&quot;foreignkey:UserID&quot;&#96; &#x2F;&#x2F; HasOne 关联，一个 User 拥有一个 Profile\n    ProfileID uint      &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n&#125;\n\n在以上示例代码中，使用了 gorm 的 tag 来指定外键字段的名称，通过 foreignkey tag 来显式指定外键字段的名称，从而与关联的模型建立正确的关联关系。\nBelongsTo 关联中，User 模型中的 Profile 字段的 tag 设置为 foreignkey:ProfileID，表示 ProfileID 字段在 Profile 模型中用作外键字段，关联到 User 模型的 ID 字段。\nHasOne 关联中，User 模型中的 Profile 字段的 tag 设置为 foreignkey:UserID，表示 UserID 字段在 User 模型中用作外键字段，关联到 Profile 模型的 ID 字段。\n根据具体的业务需求和数据库设计，可以根据 gorm 的 tag 设置来正确定义结构体，以建立合适的关联关系。\nBelongsTo 建表的结果在使用 GORM 中的 BelongsTo 方法建立一对一关联关系时，对应的数据库表结构通常会包含一个外键字段，用于关联到另一个表的主键。以下是一个示例：\n假设我们有两个模型 User 和 Profile，其中 User 模型通过 BelongsTo 方法与 Profile 模型建立一对一关联关系，其中 User 模型包含一个外键字段 ProfileID，用于关联到 Profile 模型的主键字段 ID。\n定义 User 和 Profile 模型如下：\ntype User struct &#123;\n    ID        uint\n    ProfileID uint     &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n    Name      string\n    Profile   Profile  &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96;  &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n&#125;\n\n在以上示例中，User 模型包含了一个名为 ProfileID 的外键字段，用于关联到 Profile 模型的主键字段 ID。通过在 User 模型的 Profile 字段上使用 gorm 的 foreignkey tag，指定了外键字段的名称为 ProfileID。\n对应的数据库表结构可能如下所示：\nusers 表：\n+----+-------------+------+\n| ID | ProfileID   | Name |\n+----+-------------+------+\n| 1  | 1           | John |\n+----+-------------+------+\n| 2  | 2           | Jane |\n+----+-------------+------+\n\nprofiles 表：\n+----+---------+\n| ID | Address |\n+----+---------+\n| 1  | Addr1   |\n+----+---------+\n| 2  | Addr2   |\n+----+---------+\n\n在以上示例中，users 表包含了一个外键字段 ProfileID，用于关联到 profiles 表的主键字段 ID，从而建立了一对一关联关系。每个 User 对应一个 Profile，通过 ProfileID 字段进行关联。通过 GORM 的 BelongsTo 方法和外键字段的定义，可以在数据库中建立一对一关联关系，并进行相应的查询和操作。\n查询的结果通过 GORM 进行查询时，使用 BelongsTo 方法建立的一对一关联关系会在查询结果中包含关联的数据。例如，使用以下的查询代码：\nvar user User\ndb.Preload(&quot;Profile&quot;).First(&amp;user, 1)\n\n其中 db 是 GORM 的数据库连接实例，User 是模型结构体，Profile 是关联的模型结构体。\n以上查询会查询 ID 为 1 的 User 记录，并将关联的 Profile 数据一并查询出来，将其填充到 User 模型的 Profile 字段中。\n查询结果会包含关联的 Profile 数据，例如：\n&#123;\n  &quot;ID&quot;: 1,\n  &quot;ProfileID&quot;: 1,\n  &quot;Name&quot;: &quot;John&quot;,\n  &quot;Profile&quot;: &#123;\n    &quot;ID&quot;: 1,\n    &quot;Address&quot;: &quot;Addr1&quot;\n  &#125;\n&#125;\n\n可以看到，查询结果中包含了 Profile 数据，它作为 User 模型的嵌套字段被填充到了 Profile 字段中。这样可以方便地获取一对一关联关系的数据，并进行操作和处理。\nsqlite 完整事例代码以下是一个完整的示例代码，演示如何使用 GORM 进行一对一关联关系的查询：\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    ID        uint\n    ProfileID uint     &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n    Name      string\n    Profile   Profile  &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96;  &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n    ID       uint\n    Address  string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;Failed to connect database&quot;)\n    &#125;\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;)  &#x2F;&#x2F; 自动迁移表结构\n\n    &#x2F;&#x2F; 创建一条 User 记录和对应的 Profile 记录\n    user :&#x3D; User&#123;Name: &quot;John&quot;&#125;\n    profile :&#x3D; Profile&#123;Address: &quot;Addr1&quot;&#125;\n    db.Create(&amp;user)\n    db.Create(&amp;profile)\n    user.ProfileID &#x3D; profile.ID\n    db.Save(&amp;user)\n\n    &#x2F;&#x2F; 查询 User 记录并包含关联的 Profile 数据\n    var result User\n    db.Preload(&quot;Profile&quot;).First(&amp;result, 1)\n\n    &#x2F;&#x2F; 输出查询结果\n    fmt.Printf(&quot;User: %+v\\n&quot;, result)\n    fmt.Printf(&quot;Profile: %+v\\n&quot;, result.Profile)\n&#125;\n\n在以上示例中，首先定义了 User 和 Profile 两个模型，并使用 BelongsTo 方法建立了一对一关联关系。然后通过 GORM 进行数据库连接，并创建了一条 User 记录和对应的 Profile 记录。接着通过 Preload 方法查询 User 记录时，包含了关联的 Profile 数据，最终将查询结果输出到控制台。\n请注意，示例中使用了 SQLite 作为数据库，需要提前安装 SQLite 并创建一个名为 test.db 的数据库文件。实际使用中，数据库连接参数和表结构定义可能需要根据具体情况进行调整。\n使用 mysql 作为数据库的代码怎么写以下是一个使用 MySQL 数据库作为存储的完整示例代码，演示如何使用 GORM 进行一对一关联关系的查询：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tID        uint\n\tProfileID uint     &#x2F;&#x2F; 外键字段，用于关联到 Profile 模型\n\tName      string\n\tProfile   Profile  &#96;gorm:&quot;foreignkey:ProfileID&quot;&#96;  &#x2F;&#x2F; BelongsTo 关联，一个 User 属于一个 Profile\n&#125;\n\ntype Profile struct &#123;\n\tID       uint\n\tAddress  string\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接数据库\n\tdsn :&#x3D; &quot;root:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;Failed to connect database&quot;)\n\t&#125;\n\tdb.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;) &#x2F;&#x2F; 自动迁移表结构\n\n\t&#x2F;&#x2F; 创建一条 User 记录和对应的 Profile 记录\n\tuser :&#x3D; User&#123;Name: &quot;John&quot;&#125;\n\tprofile :&#x3D; Profile&#123;Address: &quot;Addr1&quot;&#125;\n\tdb.Create(&amp;user)\n\tdb.Create(&amp;profile)\n\tuser.ProfileID &#x3D; profile.ID\n\tdb.Save(&amp;user)\n\n\t&#x2F;&#x2F; 查询 User 记录并包含关联的 Profile 数据\n\tvar result User\n\tdb.Preload(&quot;Profile&quot;).First(&amp;result, 1)\n\n\t&#x2F;&#x2F; 输出查询结果\n\tfmt.Printf(&quot;User: %+v\\n&quot;, result)\n\tfmt.Printf(&quot;Profile: %+v\\n&quot;, result.Profile)\n&#125;\n\n在以上示例中，我们使用了 GORM 的 MySQL 数据库驱动 gorm.io/driver/mysql，并通过 dsn 参数设置了 MySQL 数据库的连接信息，包括用户名、密码、地址、端口、数据库名称以及连接参数。接着创建了 User 和 Profile 两个模型，并使用 BelongsTo 方法建立了一对一关联关系。其余的创建记录、查询记录和输出查询结果的代码与之前的示例类似。\n请注意，在实际使用中，需要根据自己的 MySQL 数据库配置和表结构定义进行相应的调整。\n上述代码的表结构，及建表语句根据以上示例代码，对应的 MySQL 数据库表结构可以如下定义：\n-- User 表\nCREATE TABLE &#96;users&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;profile_id&#96; INT(10) UNSIGNED NOT NULL,\n  &#96;name&#96; VARCHAR(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  KEY &#96;fk_users_profile&#96; (&#96;profile_id&#96;),\n  CONSTRAINT &#96;fk_users_profile&#96; FOREIGN KEY (&#96;profile_id&#96;) REFERENCES &#96;profiles&#96; (&#96;id&#96;) ON DELETE CASCADE\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;\n\n-- Profile 表\nCREATE TABLE &#96;profiles&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;address&#96; VARCHAR(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;\n\n以上 SQL 语句创建了两张表，分别是 users 表和 profiles 表。users 表包含了 id、profile_id 和 name 三个字段，其中 id 是主键，profile_id 是外键，与 profiles 表的 id 字段关联。profiles 表包含了 id 和 address 两个字段，其中 id 是主键。\n在 users 表中，profile_id 字段与 profiles 表的 id 字段建立了外键关系，并通过 CONSTRAINT 定义了外键约束，指定了在删除 profiles 表中的记录时要执行的操作为级联删除 (ON DELETE CASCADE)，即删除 profiles 表中的记录时，会同时删除关联的 users 表中的记录。这样就实现了 User 和 Profile 之间的一对一关联关系。\ngorm 注意事项map\n注意从 map 创建时，不会调用钩子，不会保存关联，也不会重新填充主键值\n\ngorm 有哪些 taggorm 是 Go 中一款流行的 ORM（对象关系映射）库，用于操作数据库。gorm 支持使用标签（tag）来对模型（Model）的字段进行注解，以指定其在数据库中的映射行为。以下是 gorm 支持的一些常用的标签（tag）：\n\ngorm:&quot;column:column_name&quot;：指定字段在数据库表中对应的列名。\ngorm:&quot;primary_key&quot;：指定字段作为数据库表的主键。\ngorm:&quot;type:data_type&quot;：指定字段在数据库中的数据类型，如 int, varchar, text 等。\ngorm:&quot;size:size&quot;：指定字段在数据库中的大小限制，如 size:255 表示该字段最大长度为 255。\ngorm:&quot;not null&quot;：指定字段不能为空。\ngorm:&quot;unique&quot;：指定字段在数据库表中的值必须唯一。\ngorm:&quot;index&quot;：为字段创建数据库索引。\ngorm:&quot;default:default_value&quot;：指定字段在数据库中的默认值。\ngorm:&quot;auto_increment&quot;：指定字段在数据库中自增。\ngorm:&quot;precision:precision; scale:scale&quot;：指定字段的精度和小数位数，仅适用于浮点数字段。\ngorm:&quot;uniqueIndex:unique_index_name&quot;：为字段创建指定名称的唯一索引。\ngorm:&quot;index:idx_name&quot;：为字段创建指定名称的索引。\ngorm:&quot;comment:comment&quot;：为字段添加注释。\n\n以上只是 gorm 支持的一些常用的标签，实际上 gorm 还支持更多的标签，用于配置模型在数据库中的映射行为。通过使用这些标签，我们可以灵活地定义模型的字段属性，并与数据库表的列进行对应，从而实现方便的数据库操作。\n当然，还有更多的 gorm 标签可以用于进一步配置模型在数据库中的映射行为，包括但不限于以下几个：\n\ngorm:&quot;embedded&quot;：指定字段为嵌入式结构体。\ngorm:&quot;embeddedPrefix:prefix&quot;：指定嵌入式结构体在数据库表中的列名前缀。\ngorm:&quot;polymorphic:polymorphic_field;polymorphic_value&quot;：指定字段为多态关联，用于多表关联查询。\ngorm:&quot;foreignkey:foreign_key_field&quot;：指定关联的外键字段。\ngorm:&quot;association_foreignkey:association_foreign_key_field&quot;：指定关联的外键字段。\ngorm:&quot;many2many:join_table&quot;：指定多对多关联的中间表名称。\ngorm:&quot;many2many:join_table:foreignkey:foreign_key;association_foreignkey:association_foreign_key&quot;：指定多对多关联的中间表及外键字段。\ngorm:&quot;polymorphic:polymorphic_field;polymorphic_identity:polymorphic_identity_value&quot;：指定多态关联的字段及标识值。\n\n这些标签可以用于进一步配置模型在数据库中的映射行为，实现更复杂的数据库操作需求。详细的 gorm 标签用法可以参考 gorm 的官方文档：https://gorm.io/docs/models.html#field-attributes\n当然，这还不是全部，gorm 还提供了一些其他的标签，如下：\n\ngorm:&quot;unique&quot;：指定字段在数据库中为唯一值。\ngorm:&quot;not null&quot;：指定字段在数据库中不能为空。\ngorm:&quot;default:value&quot;：指定字段在数据库中的默认值。\ngorm:&quot;index&quot;：为字段创建数据库索引。\ngorm:&quot;size:value&quot;：指定字段的数据库大小。\ngorm:&quot;precision:value&quot;：指定字段的数据库精度。\ngorm:&quot;scale:value&quot;：指定字段的数据库刻度。\ngorm:&quot;comment:comment&quot;：为字段添加数据库注释。\n\n这些标签可以用于进一步定制模型在数据库中的表现形式，满足不同的业务需求。具体使用方法和示例可以参考 gorm 的官方文档：https://gorm.io/docs/models.html#field-attributes\n是的，还有一些其他的 gorm 标签，包括：\n\ngorm:&quot;createIndex&quot;：在创建表时为字段创建索引。\ngorm:&quot;updateIndex&quot;：在更新表时为字段创建索引。\ngorm:&quot;deleteIndex&quot;：在删除表时删除字段的索引。\ngorm:&quot;uniqueIndex&quot;：为字段创建唯一索引。\ngorm:&quot;fulltextIndex&quot;：为字段创建全文索引。\ngorm:&quot;compositeIndex:composite_index_name&quot;：为字段创建复合索引，并指定索引名称。\ngorm:&quot;type:column_type&quot;：指定字段在数据库中的列类型。\ngorm:&quot;column:column_name&quot;：指定字段在数据库中的列名称。\ngorm:&quot;autoCreateTime&quot;：在创建记录时自动设置字段的创建时间。\ngorm:&quot;autoUpdateTime&quot;：在更新记录时自动设置字段的更新时间。\ngorm:&quot;primaryKey&quot;：将字段设置为主键。\ngorm:&quot;uniqueIndex:unique_index_name&quot;：为字段创建唯一索引，并指定索引名称。\ngorm:&quot;check:constraint_name:constraint_expression&quot;：为字段创建检查约束，并指定约束名称和约束表达式。\n\n这些标签可以用于进一步定制模型在数据库中的映射行为和表现形式，满足更复杂的数据库操作需求。具体使用方法和示例可以参考 gorm 的官方文档：https://gorm.io/docs/models.html#field-attributes\n抱歉，以上列出的是 gorm 中比较常用的标签，目前没有其他的 gorm 标签了。如果有新的版本发布，可能会有新的标签被引入。您可以随时查阅 gorm 的官方文档，以获取最新的信息和更新。\n区别\ndb.Table\ndb.Rows\ndb.Scan\n\ndb.Tabledb.Table 是 gorm 库中用于指定查询表名的方法。通过 db.Table 方法，可以在查询时显式指定要查询的数据库表名，而不是使用 gorm 的默认表名推断规则。\n例如，下面是使用 db.Table 方法查询名为 “users” 的数据库表的示例：\n&#x2F;&#x2F; 定义 User 结构体\ntype User struct &#123;\n\tID   uint\n\tName string\n\tAge  int\n&#125;\n\n&#x2F;&#x2F; 使用 db.Table 指定表名为 &quot;users&quot; 进行查询\nvar users []User\ndb.Table(&quot;users&quot;).Find(&amp;users)\n\n在这个示例中，db.Table(&quot;users&quot;) 方法指定了查询的数据库表名为 “users”，然后使用 Find 方法执行查询操作，并将查询结果存储到 users 变量中。\n需要注意的是，使用 db.Table 方法后，gorm 将会完全按照指定的表名进行查询，而不再使用默认的表名推断规则。这可以在需要查询非默认表名的情况下使用，例如当查询多个不同表结构相似的表时，或者当需要查询不在 gorm 模型定义中的表时。\nFirstOrInit&#x2F;FirstOrCreate\ndb.FirstOrInit 有点像多态\nAttrs 不会被用于生成查询 SQL, 找不到仅用于创建，找到了无效\n不管是否找到记录，Assign 都会将属性赋值给 struct，但这些属性不会被用于生成查询 SQL，也不会被保存到数据库\n\ngorm FirstOrCreate 和 FirstOrInit 的区别：\nFirstOrCreate 和 FirstOrInit 都是 GORM 提供的查询方法，用于在数据库中查找记录。它们的区别在于：\n\nFirstOrCreate 方法会在数据库中查找符合条件的记录，如果找到了则返回该记录，否则会创建一条新记录并返回。如果创建新记录时需要设置一些默认值，可以在调用 FirstOrCreate 方法之前为相应字段设置默认值。\n\nFirstOrInit 方法也会在数据库中查找符合条件的记录，如果找到了则返回该记录，否则会返回一个未保存的新记录（即未设置主键的新实例），然后可以对新实例进行修改并保存到数据库中。\n\n\n举个例子，假设我们有一个 User 模型，要根据用户名查找用户记录，如果找到则返回该记录，否则创建一条新记录并返回。可以使用 FirstOrCreate 方法来实现：\nvar user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrCreate(&amp;user)\n\n如果数据库中已经存在用户名为 “Alice” 的用户记录，则会返回该记录，否则会创建一条新记录并返回。\n另一方面，如果我们要返回一个未保存的新用户实例（即未设置主键的新记录），可以使用 FirstOrInit 方法：\nvar user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrInit(&amp;user)\n\n如果数据库中已经存在用户名为 “Alice” 的用户记录，则会返回该记录，否则会返回一个未保存的新用户实例。我们可以对新实例进行修改并保存到数据库中：\nif user.ID &#x3D;&#x3D; 0 &#123;\n  user.Name &#x3D; &quot;Alice&quot;\n  db.Create(&amp;user)\n&#125; else &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nFirstOrCreate 和 FirstOrInit 方法还有一些注意事项：\n\nFirstOrCreate 方法不仅可以根据一个条件查找记录，还可以根据多个条件查找记录，例如：\ndb.Where(User&#123;Name: &quot;Alice&quot;, Age: 18&#125;).FirstOrCreate(&amp;user)\n\nFirstOrInit 方法只能根据一个条件查找记录，如果要根据多个条件查找记录，可以使用 Where 方法指定多个条件，例如：\ndb.Where(&quot;name &#x3D; ? AND age &#x3D; ?&quot;, &quot;Alice&quot;, 18).FirstOrInit(&amp;user)\n\nFirstOrInit 方法返回的是一个未保存的新实例，因此如果要在返回结果之后进行更新操作，需要调用 Save 方法将新实例保存到数据库中，例如：\nvar user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrInit(&amp;user)\nuser.Age &#x3D; 18\ndb.Save(&amp;user)\n\n如果只是想修改内存中的实例而不保存到数据库中，可以使用 Updates 方法，例如：\nvar user User\ndb.Where(&quot;name &#x3D; ?&quot;, &quot;Alice&quot;).FirstOrInit(&amp;user)\ndb.Model(&amp;user).Updates(User&#123;Age: 18&#125;)\n\n还有一点需要注意的是，FirstOrCreate 和 FirstOrInit 方法都是使用 SELECT ... FROM ... WHERE ... LIMIT 1 的方式查询数据库的。如果需要查询的条件有索引，这种方式可以有效地利用索引，提高查询性能。但如果需要查询的条件没有索引，这种方式可能会导致全表扫描，查询速度会比较慢。\n另外，如果需要查询的条件不唯一，即有多条记录符合条件，那么 FirstOrCreate 和 FirstOrInit 方法都只会返回其中的一条记录。如果需要返回所有符合条件的记录，可以使用 Find 方法进行查询，例如：\nvar users []User\ndb.Where(&quot;age &#x3D; ?&quot;, 18).Find(&amp;users)\n\n这样就可以返回所有年龄为 18 的用户记录了。\n零值处理\nSave 会保存所有的字段，即使字段是零值（如果保存值不包含主键，它将执行 Create，否则将执行 Update（包含所有字段））\nUpdate\n更新支持使用 struct 或 map[string]face{}更新，使用 struct 更新时默认只会更新非零字段\n注意使用 struct 更新时，GORM 只会更新非零字段。您可能希望使用 map 来更新属性或使用 Select 来指定要更新的字段\n\n\n\ngorm dryrun在 Gorm 中，DryRun 模式是一种用于调试 SQL 语句的特殊模式。当你在开发阶段使用 Gorm 时，你可能会需要查看 Gorm 生成的 SQL 语句，以便确定 Gorm 是否正确地生成了预期的 SQL 语句。DryRun 模式允许你在不实际执行 SQL 语句的情况下查看生成的 SQL 语句。\n在 Gorm 中启用 DryRun 模式非常简单。只需将 db.Session(&amp;gorm.Session&#123;DryRun: true&#125;) 作为查询的第一个参数传递给 Gorm，即可启用 DryRun 模式。例如：\ndb.Session(&amp;gorm.Session&#123;DryRun: true&#125;).Find(&amp;users)\n\n在上面的示例中，我们将 DryRun 模式启用，并通过 Find 方法查询了用户数据。由于我们启用了 DryRun 模式，Gorm 只会生成 SQL 语句，并将其打印到控制台上，而不会实际执行 SQL 语句。你可以通过查看控制台输出来检查生成的 SQL 语句是否正确。\n安全在使用 Gorm 或任何其他 ORM（对象关系映射）库时，确保 SQL 安全是非常重要的，以防止 SQL 注入攻击。下面是一些在使用 Gorm 时保持 SQL 安全的建议：\n\n使用参数化查询（Prepared Statements）：Gorm 默认使用参数化查询，这可以防止 SQL 注入攻击。参数化查询将查询参数与 SQL 查询语句分开，确保参数不会被解释为 SQL 代码。在 Gorm 中，你可以使用 db.Preload()、db.Where()、db.First() 等方法进行查询，并将查询参数作为参数传递，而不是将其直接嵌入到 SQL 查询语句中。\n\n例如：\nname :&#x3D; &quot;John&quot;\nage :&#x3D; 25\ndb.Where(&quot;name &#x3D; ?&quot;, name).Where(&quot;age &gt; ?&quot;, age).Find(&amp;users)\n\n\n不要直接拼接 SQL 查询语句：避免将用户输入或其他未经验证的数据直接拼接到 SQL 查询语句中，这可能会导致 SQL 注入攻击。相反，使用 Gorm 提供的方法来构建查询，如 db.Where()、db.Or()、db.Not() 等，这些方法会自动处理参数化查询。\n\n例如：\nname :&#x3D; &quot;John&quot;\nage :&#x3D; 25\ndb.Where(&quot;name &#x3D; ?&quot;, name).Where(&quot;age &gt; ?&quot;, age).Find(&amp;users)\n\n\n验证用户输入：在将用户输入数据传递给 SQL 查询之前，务必对其进行验证和过滤，以防止恶意 SQL 注入攻击。可以使用合适的验证库或编写自己的验证逻辑来确保用户输入数据的合法性。\n\n限制数据库权限：在使用数据库时，确保数据库用户只具有最小必需的权限，例如只允许执行特定的查询和操作，以限制潜在的攻击面。\n\n更新 Gorm 版本：定期更新 Gorm 到最新版本，以确保你使用的是最新的安全补丁和修复了可能存在的安全漏洞的版本。\n\n\n总之，确保 SQL 安全对于使用 Gorm 或任何其他 ORM 库都是至关重要的。遵循最佳实践，使用参数化查询、验证用户输入、限制数据库权限等措施，以保护你的应用程序免受 SQL 注入攻击。\n验证用户输入验证用户输入是确保应用程序安全的重要步骤，包括在使用 Gorm 或任何其他 ORM 库时。下面是一些实现验证用户输入的方法：\n\n使用 Go 的内置验证库：Go 标准库中提供了多个用于验证用户输入的包，例如 regexp、strconv、strings 等。你可以使用这些包来检查用户输入是否符合期望的格式、类型、长度等。例如，你可以使用正则表达式验证电子邮件地址的格式，使用 strconv 包将字符串转换为数字等。\n\nimport (\n    &quot;regexp&quot;\n)\n\nfunc ValidateEmail(email string) bool &#123;\n    &#x2F;&#x2F; 使用正则表达式验证电子邮件地址格式\n    pattern :&#x3D; &#96;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,&#125;$&#96;\n    return regexp.MustCompile(pattern).MatchString(email)\n&#125;\n\nfunc main() &#123;\n    email :&#x3D; &quot;user@example.com&quot;\n    if ValidateEmail(email) &#123;\n        fmt.Println(&quot;Email is valid&quot;)\n    &#125; else &#123;\n        fmt.Println(&quot;Email is invalid&quot;)\n    &#125;\n&#125;\n\n\n自定义验证逻辑：根据你的应用程序需求，你可以编写自己的验证逻辑来验证用户输入。例如，你可以检查密码的长度、检查输入是否为合法的日期等。可以通过编写自定义的验证函数或方法来实现。\n\nfunc ValidatePassword(password string) bool &#123;\n    &#x2F;&#x2F; 检查密码长度是否大于等于8\n    return len(password) &gt;&#x3D; 8\n&#125;\n\nfunc main() &#123;\n    password :&#x3D; &quot;mypassword&quot;\n    if ValidatePassword(password) &#123;\n        fmt.Println(&quot;Password is valid&quot;)\n    &#125; else &#123;\n        fmt.Println(&quot;Password is invalid&quot;)\n    &#125;\n&#125;\n\n\n使用第三方验证库：除了 Go 标准库外，还有许多第三方验证库可供选择，这些库提供了更丰富的验证功能，如 validator、go-playground/validator 等。这些库提供了各种验证规则和自定义验证功能，可以方便地在你的应用程序中使用。\n\nimport (\n    &quot;github.com&#x2F;go-playground&#x2F;validator&#x2F;v10&quot;\n)\n\ntype User struct &#123;\n    Name     string &#96;validate:&quot;required&quot;&#96;\n    Age      int    &#96;validate:&quot;gte&#x3D;18&quot;&#96;\n    Email    string &#96;validate:&quot;email&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    user :&#x3D; User&#123;Name: &quot;John&quot;, Age: 20, Email: &quot;user@example.com&quot;&#125;\n    validate :&#x3D; validator.New()\n    err :&#x3D; validate.Struct(user)\n    if err !&#x3D; nil &#123;\n        fmt.Println(&quot;Validation failed:&quot;, err)\n    &#125; else &#123;\n        fmt.Println(&quot;Validation passed&quot;)\n    &#125;\n&#125;\n\n以上只是验证用户输入的一些简单示例，实际上，验证用户输入可能会涉及更复杂的业务逻辑和多个字段的验证。根据你的应用程序需求，选择合适的验证方法，并根据最佳实践来保护应用程序免受恶意用户输入造成的安全威胁。\ngin 防 sql 注入校验在使用 Gin 进行 SQL 注入校验时，可以考虑以下几种方法：\n\n使用预处理语句：使用预处理语句来执行 SQL 查询和更新操作，而不是直接将用户输入的数据插入 SQL 查询中。预处理语句可以在 SQL 查询执行之前将用户输入的数据作为参数传递给数据库，从而防止 SQL 注入攻击。在使用 Gin 进行数据库操作时，可以使用 ? 占位符来代替直接插入用户输入的数据，然后将用户输入的数据作为参数传递给数据库库的方法，数据库库会自动使用预处理语句来执行 SQL 操作。\n\n例如，在使用 Go 自带的 database/sql 进行数据库操作时，可以使用 ? 占位符来代替直接插入用户输入的数据，并将用户输入的数据作为参数传递给 Exec 或 Query 方法，database/sql 会自动使用预处理语句来执行 SQL 操作。\nimport &quot;database&#x2F;sql&quot;\nimport _ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;\n\nfunc getUserByName(c *gin.Context) &#123;\n    &#x2F;&#x2F; 获取用户输入的用户名\n    username :&#x3D; c.Query(&quot;username&quot;)\n\n    &#x2F;&#x2F; 使用预处理语句，将用户输入作为参数传递\n    stmt, err :&#x3D; db.Prepare(&quot;SELECT * FROM users WHERE username &#x3D; ?&quot;)\n    if err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理错误\n        &#x2F;&#x2F; ...\n    &#125;\n    defer stmt.Close()\n\n    rows, err :&#x3D; stmt.Query(username)\n    if err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理错误\n        &#x2F;&#x2F; ...\n    &#125;\n\n    &#x2F;&#x2F; 处理查询结果\n    &#x2F;&#x2F; ...\n&#125;\n\n\n使用 ORM 的安全特性：一些数据库 ORM 库（如 Gorm、Xorm 等）提供了安全特性，可以防止 SQL 注入攻击。这些特性通常包括自动转义用户输入的数据，避免将用户输入的数据作为原始 SQL 查询的一部分。在使用 ORM 进行数据库操作时，尽量使用 ORM 提供的安全特性，以确保用户输入的数据不会导致 SQL 注入。\n\n例如，在使用 Gorm 进行查询时，可以使用 Find 方法，并将用户输入的数据作为参数传递给方法，Gorm 会自动转义用户输入的数据，从而防止 SQL 注入攻击。\nimport &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\nimport &quot;gorm.io&#x2F;gorm&quot;\n\nfunc getUserByName(c *gin.Context) &#123;\n    &#x2F;&#x2F; 获取用户输入的用户名\n    username :&#x3D; c.Query(&quot;username&quot;)\n\n    &#x2F;&#x2F; 使用 Gorm 进行查询，将用户输入作为参数传递，Gorm 会自动转义用户输入的数据\n    var user User\n    if err :&#x3D; db.Find(&amp;user, &quot;username &#x3D; ?&quot;, username).Error; err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理错误\n        &#x2F;&#x2F; ...\n    &#125;\n\n    &#x2F;&#x2F; 处理查询结果\n    &#x2F;&#x2F; ...\n&#125;\n\n\n自定义输入验证：根据你的应用程序需求，可以编写自定义的输入验证逻辑，对用户输入的数据进行校验。例如，可以使用正则表达式、字符串处理函数等方法对用户输入的数据进行验证，确保其符合预期的格式，从而防止 SQL 注入攻击。在使用 Gin 进行输入验证时，可以使用 regexp 包来进行正则表达式验证，或者使用字符串处理函数来对用户输入的数据进行格式化、过滤或转义。\n\n例如，可以编写一个自定义的验证函数 isValidUsername 来验证用户名是否符合预期的格式，例如只包含字母和数字，长度在 6 到 20 个字符之间：\nimport (\n    &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n    &quot;regexp&quot;\n)\n\nfunc getUserByName(c *gin.Context) &#123;\n    &#x2F;&#x2F; 获取用户输入的用户名\n    username :&#x3D; c.Query(&quot;username&quot;)\n\n    &#x2F;&#x2F; 自定义输入验证逻辑，例如使用正则表达式验证用户名格式\n    if !isValidUsername(username) &#123;\n        &#x2F;&#x2F; 处理用户名格式错误\n        &#x2F;&#x2F; ...\n    &#125;\n\n    &#x2F;&#x2F; 使用 Gorm 进行查询，将用户输入作为参数传递，Gorm 会自动转义用户输入的数据\n    &#x2F;&#x2F; ...\n&#125;\n\nfunc isValidUsername(username string) bool &#123;\n    &#x2F;&#x2F; 定义用户名格式的正则表达式\n    pattern :&#x3D; &quot;^[a-zA-Z0-9]&#123;6,20&#125;$&quot;\n\n    &#x2F;&#x2F; 使用正则表达式验证用户名格式\n    match, _ :&#x3D; regexp.MatchString(pattern, username)\n\n    return match\n&#125;\n\n以上是一些常见的防止 SQL 注入攻击的方法，在实际应用中，可以根据具体的业务场景和安全需求，结合使用这些方法或其他安全措施来确保应用程序的数据安全。同时，还应定期更新依赖库，并保持应用程序的安全最佳实践，以保护应用程序免受 SQL 注入等安全威胁。\ngorm 多态【我觉得：就算不晓得所谓的多态，我也不可能设计出后面那种表】在 Gorm 中，多态（Polymorphism）是指在一个数据库表中存储多种类型的数据，并通过一个公共的字段来标识不同的类型。这样可以在一个表中存储多种实体的数据，从而避免了创建多张表的复杂性。\nGorm 提供了多态关联（Polymorphic Associations）的功能，可以通过使用 gorm:&quot;polymorphic&quot; 标签来定义多态关联。下面是一个示例：\ntype Comment struct &#123;\n    ID           uint\n    Comment      string\n    CommentableID uint\n    CommentableType string\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;\n\n在上面的示例中，Comment 模型有一个 CommentableID 字段用来存储关联的实体的 ID，以及一个 CommentableType 字段用来存储关联实体的类型。CommentableID 字段存储了实体的 ID，CommentableType 字段存储了实体的类型（例如 “Post” 或 “Video”），用于标识关联的实体类型。\n在定义多态关联时，可以使用 gorm:&quot;polymorphic&quot; 标签来声明 CommentableID 和 CommentableType 字段的多态关联，如下所示：\ntype Comment struct &#123;\n    ID           uint\n    Comment      string\n    CommentableID uint\n    CommentableType string &#96;gorm:&quot;polymorphic:Commentable;&quot;&#96;\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;&quot;&#96;\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;&quot;&#96;\n&#125;\n\n在以上示例中，Comment 模型中的 CommentableType 字段使用了 gorm:&quot;polymorphic:Commentable;&quot; 标签，其中 “Commentable” 是关联的多态类型名，用于在数据库中存储关联实体的类型。\n使用多态关联后，可以通过 Gorm 进行查询和操作，例如：\n&#x2F;&#x2F; 查询评论的所有子评论\nvar comments []Comment\ndb.Where(&quot;CommentableID &#x3D; ? AND CommentableType &#x3D; ?&quot;, parentCommentID, &quot;Comment&quot;).Find(&amp;comments)\n\n&#x2F;&#x2F; 查询文章的评论\nvar post Post\ndb.Preload(&quot;Comments&quot;).Find(&amp;post)\n\n&#x2F;&#x2F; 查询视频的评论\nvar video Video\ndb.Preload(&quot;Comments&quot;).Find(&amp;video)\n\n通过使用多态关联，可以轻松地在一个表中存储多种类型的数据，并通过公共的字段进行关联和查询，从而实现多态的功能。\ngorm 多态与不使用多态看上去没有什么区别在某些情况下，使用多态和不使用多态的确会看上去没有什么区别，但是多态的优势在于更好的代码可读性和可维护性。\n使用多态关联的一个重要好处是，可以避免重复代码和逻辑，特别是当有多个模型需要关联到同一模型时，可以避免在每个模型中重复定义相同的关联字段和关联方法。另外，使用多态关联还可以使代码更加简洁和易于理解。\n例如，假设有一个 Comment 模型需要关联到 Post 和 Video 两个模型，如果不使用多态关联，需要在 Comment 模型中定义两个不同的外键，如下所示：\ntype Comment struct &#123;\n    ID        uint\n    Comment   string\n    PostID    uint\n    VideoID   uint\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment\n&#125;\n\n这样的代码会让数据模型变得混乱，而且在查询和操作数据时也会变得更加麻烦。\n相反，使用多态关联，可以将外键字段和关联方法定义在 Comment 模型中，从而使代码更加简洁和易于理解，如前面所示的示例。使用多态关联还可以在代码中使用多态的概念，从而使代码更加可读性和可维护性。\n因此，虽然使用多态关联可能看起来并没有显著的区别，但它确实可以提高代码的可读性和可维护性。\npolymorphicValuepolymorphicValue 是 GORM 中用于处理多态关联的字段，它允许在关联关系中使用不同的数据类型，从而实现一对多或多对多关联的灵活性。\n在 GORM 中，polymorphicValue 是一个用于表示多态关联的字段名，它通常与 polymorphicType 字段一起使用，用于指定多态关联的实际类型。 polymorphicValue 字段的值通常是一个字符串，用于表示关联的实际类型的名称或标识。\n以下是一个简单的示例，演示了如何在 GORM 中使用 polymorphicValue 字段来实现多态关联：\ntype Comment struct &#123;\n    ID              uint\n    Body            string\n    CommentableID   uint\n    CommentableType string\n    Commentable     interface&#123;&#125; &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96; &#x2F;&#x2F; 定义多态关联\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96; &#x2F;&#x2F; 定义多态关联\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96; &#x2F;&#x2F; 定义多态关联\n&#125;\n\n在上面的例子中，Comment 模型通过 Commentable 字段与 Post 和 Video 模型建立了多态关联，表示一条评论可以关联到多个不同类型的模型（即 Post 和 Video），同时通过 CommentableType 字段和 polymorphicValue 标签来标识实际关联的类型。\n在数据库中，可以通过添加 CommentableID 和 CommentableType 字段来表示多态关联的关系。同时，GORM 会自动解析 Commentable 字段和 polymorphicValue 标签，从而在查询和操作数据时可以直接通过关联字段进行操作，例如：\n&#x2F;&#x2F; 查询帖子及其评论\nvar post Post\ndb.Preload(&quot;Comments&quot;).Find(&amp;post, 1) &#x2F;&#x2F; 查询 ID 为 1 的帖子及其评论\n\n&#x2F;&#x2F; 查询视频及其评论\nvar video Video\ndb.Preload(&quot;Comments&quot;).Find(&amp;video, 1) &#x2F;&#x2F; 查询 ID 为 1 的视频及其评论\n\n&#x2F;&#x2F; 创建评论关联到帖子\npost :&#x3D; Post&#123;Title: &quot;Post 1&quot;&#125;\ncomment :&#x3D; Comment&#123;Body: &quot;Comment 1&quot;, Commentable: &amp;post&#125;\ndb.Create(&amp;post)\ndb.Create(&amp;comment)\n\n&#x2F;&#x2F; 创建评论关联到视频\nvideo :&#x3D; Video&#123;Title: &quot;Video 1&quot;&#125;\ncomment :&#x3D; Comment&#123;Body: &quot;Comment 2&quot;, Commentable: &amp;video&#125;\ndb.Create(&amp;video)\ndb.Create(&amp;comment)\n\n通过以上示例，可以看到如何在 GORM 中使用 polymorphicValue 字段来实现多态关联，从而实现模型之间的灵活关联查询和操作。\n得到的表结构上面的示例中，Comment 模型通过 Commentable 字段与 Post 和 Video 模型建立了多态关联，同时通过 CommentableType 字段和 polymorphicValue 标签指定了实际关联类型的名称为 commentable_type。\n在生成的 MySQL 表结构中，会包含 commentable_type 字段来表示实际关联类型，例如：\nCREATE TABLE &#96;comments&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;body&#96; VARCHAR(255) NOT NULL,\n  &#96;commentable_id&#96; INT(10) UNSIGNED NOT NULL,\n  &#96;commentable_type&#96; VARCHAR(255) NOT NULL, -- 多态关联类型字段\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;posts&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;title&#96; VARCHAR(255) NOT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;videos&#96; (\n  &#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n  &#96;title&#96; VARCHAR(255) NOT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\n从上面的表结构可以看到，comments 表中包含了 commentable_type 字段来表示实际关联类型，这样在查询和操作多态关联数据时，GORM 可以根据该字段来判断实际关联类型，从而实现多态关联的查询和操作。\n插入数据好的，以下是使用 GORM 插入几条数据的示例，假设我们已经定义了如下的数据模型：\ntype Comment struct &#123;\n    ID              uint\n    Body            string\n    CommentableID   uint\n    CommentableType string &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96;\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96;\n&#125;\n\ntype Video struct &#123;\n    ID       uint\n    Title    string\n    Comments []Comment &#96;gorm:&quot;polymorphic:Commentable;polymorphicValue:commentable_type&quot;&#96;\n&#125;\n\n现在我们可以通过创建实例并设置相关字段的值，然后使用 GORM 的 Create 方法插入数据到对应的表中。\n&#x2F;&#x2F; 创建 Post\npost :&#x3D; Post&#123;\n    Title: &quot;Post 1&quot;,\n    Comments: []Comment&#123;\n        &#123;Body: &quot;Comment 1 for Post 1&quot;&#125;,\n        &#123;Body: &quot;Comment 2 for Post 1&quot;&#125;,\n    &#125;,\n&#125;\ngormDB.Create(&amp;post)\n\n&#x2F;&#x2F; 创建 Video\nvideo :&#x3D; Video&#123;\n    Title: &quot;Video 1&quot;,\n    Comments: []Comment&#123;\n        &#123;Body: &quot;Comment 1 for Video 1&quot;&#125;,\n        &#123;Body: &quot;Comment 2 for Video 1&quot;&#125;,\n    &#125;,\n&#125;\ngormDB.Create(&amp;video)\n\n上面的示例中，我们分别创建了一个带有多个评论的 Post 和 Video 实例，并使用 Create 方法将它们插入到对应的表中。由于评论模型 Comment 中定义了 CommentableID 和 CommentableType 字段作为多态关联的键值对，GORM 会根据 polymorphicValue 标签自动设置 CommentableType 字段的值为 commentable_type，从而插入多态关联数据到 comments 表中。\n插入数据后，可以通过查询相关的表来验证数据是否插入成功。例如，可以使用以下代码查询 comments 表中的数据：\nvar comments []Comment\ngormDB.Find(&amp;comments)\nfmt.Println(comments)\n\n如果一切设置正确，你应该能够在输出中看到插入的评论数据，并且 CommentableType 字段的值应该与 polymorphicValue 标签中指定的值相同。\n至此数据库数据假设我们使用的是 MySQL 数据库，并且已经成功执行了上面的示例代码插入了一些数据，那么在数据库中存储的数据将类似于以下的结构：\ncomments 表：\n+----+------------------------+----------------+---------------------+------------------+\n| ID | Body                   | CommentableID  | CommentableType     | created_at       |\n+----+------------------------+----------------+---------------------+------------------+\n| 1  | Comment 1 for Post 1  | 1              | Post                | 2023-04-26 12:34 |\n| 2  | Comment 2 for Post 1  | 1              | Post                | 2023-04-26 12:34 |\n| 3  | Comment 1 for Video 1 | 1              | Video               | 2023-04-26 12:34 |\n| 4  | Comment 2 for Video 1 | 1              | Video               | 2023-04-26 12:34 |\n+----+------------------------+----------------+---------------------+------------------+\n\n非 GPT 生成：怎么看上去，像是一对多了呢\nposts 表：\n+----+--------+------------------+\n| ID | Title  | created_at       |\n+----+--------+------------------+\n| 1  | Post 1 | 2023-04-26 12:34 |\n+----+--------+------------------+\n\nvideos 表：\n+----+--------+------------------+\n| ID | Title  | created_at       |\n+----+--------+------------------+\n| 1  | Video 1| 2023-04-26 12:34 |\n+----+--------+------------------+\n\n从上面的数据表结构可以看出，comments 表中的 CommentableID 字段表示关联的评论所属的记录的 ID，CommentableType 字段表示关联的评论所属的记录类型，即 Post 或者 Video。这种方式实现了多态关联，允许一个表中的记录关联到多个不同表中的记录。\nCommentableType 是从哪里获取到的在使用 GORM 中的多态关联时，CommentableType 字段的值是由 GORM 根据模型关联的结构自动设置的。在示例中，CommentableType 是由 Comment 模型中定义的多态字段 PolymorphicType 决定的，其值是关联到的模型的名称。\n在示例中，Comment 模型中定义了 PolymorphicType 字段，其值为 gorm:&quot;polymorphic:Commentable;&quot;。这里的 Commentable 是一个字符串，表示多态关联的关联名，即关联到的模型的名称。当创建一个关联到 Comment 模型的记录时，GORM 会自动将 CommentableType 字段设置为 Post 或者 Video，具体取决于关联的模型是 Post 还是 Video。这样在数据库中就可以记录下每条评论关联到的记录类型，从而实现多态关联。\ngorm has many 自引用在 GORM 中，可以通过使用 ForeignKey 和 AssociationForeignKey 标签来实现模型的自引用关系，从而建立一个模型与自身的 “Has Many” 关联。\n下面是一个简单的示例，演示了如何在 GORM 中定义一个自引用的模型关联：\ntype User struct &#123;\n    ID        uint\n    Name      string\n    ParentID  uint\n    Children  []User &#96;gorm:&quot;foreignkey:ParentID&quot;&#96; &#x2F;&#x2F; 定义子用户的关联\n    Parent    *User  &#96;gorm:&quot;foreignkey:ID&quot;&#96;       &#x2F;&#x2F; 定义父用户的关联\n&#125;\n\n在上面的例子中，User 模型通过 ParentID 字段与自身建立了 “Has Many” 关联，表示一个用户可以有多个子用户，同时通过 Parent 字段与自身建立了 “Belongs To” 关联，表示一个用户只能有一个父用户。\n在数据库中，可以通过添加 ParentID 字段来表示用户之间的关系。同时，GORM 会自动解析模型中定义的关联字段，从而在查询和操作数据时可以直接通过关联字段进行操作，例如：\n&#x2F;&#x2F; 查询用户及其子用户\nvar user User\ndb.Preload(&quot;Children&quot;).Find(&amp;user, 1) &#x2F;&#x2F; 查询 ID 为 1 的用户及其子用户\n\n&#x2F;&#x2F; 创建父用户及其子用户\nparent :&#x3D; User&#123;Name: &quot;Parent&quot;&#125;\nchild1 :&#x3D; User&#123;Name: &quot;Child 1&quot;, Parent: &amp;parent&#125;\nchild2 :&#x3D; User&#123;Name: &quot;Child 2&quot;, Parent: &amp;parent&#125;\ndb.Create(&amp;parent)\ndb.Create(&amp;child1)\ndb.Create(&amp;child2)\n\n&#x2F;&#x2F; 查询子用户的父用户\nvar child User\ndb.Preload(&quot;Parent&quot;).Find(&amp;child, 1) &#x2F;&#x2F; 查询 ID 为 1 的子用户及其父用户\n\n通过以上示例，可以看到如何在 GORM 中使用 Has Many 和 Belongs To 关联来实现模型的自引用关系，从而实现模型之间的关联查询和操作。\n以上示例查询结果以上示例中的查询结果可能会根据具体的数据库记录和数据模型定义而有所不同。以下是可能的查询结果的示例：\n\n查询用户及其子用户：\n\nvar user User\ndb.Preload(&quot;Children&quot;).Find(&amp;user, 1)\n\n查询 ID 为 1 的用户及其子用户，结果可能如下：\nuser :&#x3D; User&#123;\n    ID:        1,\n    Name:      &quot;Parent&quot;,\n    ParentID:  0, &#x2F;&#x2F; 或者 null，表示该用户为顶级用户，没有父用户\n    Children: []User&#123;\n        &#123;ID: 2, Name: &quot;Child 1&quot;, ParentID: 1&#125;,\n        &#123;ID: 3, Name: &quot;Child 2&quot;, ParentID: 1&#125;,\n    &#125;,\n&#125;\n\n\n查询子用户的父用户：\n\nvar child User\ndb.Preload(&quot;Parent&quot;).Find(&amp;child, 1)\n\n查询 ID 为 1 的子用户及其父用户，结果可能如下：\nchild :&#x3D; User&#123;\n    ID:        1,\n    Name:      &quot;Child 1&quot;,\n    ParentID:  1,\n    Parent: &amp;User&#123;\n        ID:       1,\n        Name:     &quot;Parent&quot;,\n        ParentID: 0,\n    &#125;,\n&#125;\n\n注意：以上示例中的查询结果仅为示意，并可能因实际数据和数据模型的定义而有所不同。实际的查询结果会根据数据库中的数据以及数据模型的字段定义和标签设置而定。\ngorm .Preload() API 的作用Preload() 是 GORM 中用于预加载关联数据的 API，其作用是在查询某个模型数据时，同时预加载其关联模型的数据，以避免在渲染视图时因为 N+1 问题导致的性能问题。在使用 Preload() API 时，GORM 会发出一条 JOIN 查询语句来加载关联数据，而不是使用多条查询语句逐个加载关联数据。\n例如，假设我们有以下的模型定义：\ntype User struct &#123;\n  gorm.Model\n  Name      string\n  Age       int\n  Addresses []Address\n&#125;\n\ntype Address struct &#123;\n  gorm.Model\n  UserID    uint\n  City      string\n  Country   string\n&#125;\n\n其中，User 模型拥有多个 Address 模型的关联，即一个用户可以有多个地址。如果我们在查询用户数据时需要同时查询用户的地址数据，可以使用 Preload() API 来实现：\nvar user User\ndb.Preload(&quot;Addresses&quot;).First(&amp;user, 1)\n\n这里的 Preload(&quot;Addresses&quot;) 表示预加载 User 模型的 Addresses 关联模型数据。在执行查询时，GORM 会发出一条 JOIN 查询语句来同时查询用户和其地址数据，从而避免了 N+1 查询问题。\n需要注意的是，使用 Preload() API 时应避免过度预加载，以免查询语句过于复杂导致性能下降。可以通过设置参数来控制预加载的深度和范围，以满足具体的查询需求。\nN+1 问题 是什么意思N+1 问题（N+1 Query Problem）是指在加载关联数据时，使用了 N 条查询语句来查询 N 条主记录以及它们的关联数据，从而导致性能问题的一种情况。通常情况下，N+1 问题是由 ORM 框架的延迟加载机制所导致的。\n举个例子，假设我们有一个 User 模型和一个 Post 模型，它们之间是一对多的关联关系（即一个用户可以有多篇文章）。如果我们要查询所有用户以及他们的所有文章，可能会写出如下的查询代码：\nvar users []User\ndb.Find(&amp;users)\n\nfor _, user :&#x3D; range users &#123;\n  var posts []Post\n  db.Where(&quot;user_id &#x3D; ?&quot;, user.ID).Find(&amp;posts)\n  user.Posts &#x3D; posts\n&#125;\n\n这里的第一条查询语句会加载所有用户的数据，而在第二个循环中，我们对每个用户分别执行一次查询来加载他们的文章数据。这样就会导致 N+1 问题，即执行了 N+1 条查询语句。如果用户数据量很大，那么就会导致性能问题，因为查询语句的执行需要时间和资源。\n为了避免 N+1 问题，可以使用 GORM 中的 Preload() API 来预加载关联数据，或者手动使用 JOIN 查询语句来同时加载主记录和关联记录。这样可以将多条查询语句合并为一条查询，从而提高查询性能。\nmany2many在 GORM 中，Many-to-Many 关系可以使用 Many2Many 方法来定义。它允许您定义两个表之间的多对多关系，并使用中间表进行关联。\n以下是一个示例：\ntype User struct &#123;\n    ID       uint\n    Name     string\n    Languages []Language &#96;gorm:&quot;many2many:user_languages;&quot;&#96;\n&#125;\n\ntype Language struct &#123;\n    ID   uint\n    Name string\n    Users []User &#96;gorm:&quot;many2many:user_languages;&quot;&#96;\n&#125;\n\n在上面的代码中，User 和 Language 之间的多对多关系使用 many2many 方法定义。user_languages 是中间表的表名，它将这两个模型关联起来。\n在此示例中，每个用户可以拥有多种语言，而每种语言也可以被多个用户使用。中间表 user_languages 将两个模型之间的关系保存在一起。\n要使用此关系，您可以使用以下代码将语言添加到用户的语言列表中：\nuser :&#x3D; User&#123;&#125;\nlanguage :&#x3D; Language&#123;&#125;\n\n&#x2F;&#x2F; 通过ID获取用户和语言\ndb.First(&amp;user, 1)\ndb.First(&amp;language, 2)\n\n&#x2F;&#x2F; 添加语言到用户的语言列表\ndb.Model(&amp;user).Association(&quot;Languages&quot;).Append(&amp;language)\n\n在上面的示例中，我们从数据库中获取了一个用户和一种语言，然后将语言添加到用户的语言列表中。\n您还可以从用户的语言列表中获取所有语言：\ndb.Model(&amp;user).Association(&quot;Languages&quot;).Find(&amp;languages)\n\n上面的代码将获取用户的所有语言，并将它们存储在 languages 列表中。\n解释下 如下代码type User struct &#123;\n    gorm.Model\n    Profiles []Profile &#96;gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;&#96;\n    Refer    uint      &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\ntype Profile struct &#123;\n    gorm.Model\n    Name      string\n    UserRefer uint &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\n\n以上代码定义了两个 GORM 模型 User 和 Profile。User 模型具有多对多关系，并且使用名为 user_profiles 的中间表来定义它们之间的关系。中间表具有自定义外键列 Refer 和 UserReferID，分别用于关联 User 和 Profile 模型。Profile 模型具有 UserRefer 字段，用于关联 User 模型。\n具体来说，以下是关键代码行的解释：\n\ngorm.Model 是 GORM 提供的一个带有 ID、CreatedAt 和 UpdatedAt 字段的基本模型，可以被嵌入到自定义模型中以获得这些通用字段。\nProfiles []Profile 定义了 User 模型中的一个 Profile 切片，表示每个用户都可以拥有多个个人资料。\ngorm:&quot;many2many:user_profiles&quot; 告诉 GORM 将 User 和 Profile 模型之间的关系保存在名为 user_profiles 的中间表中。\nforeignKey:Refer 和 joinForeignKey:UserReferID 分别指定了用于关联 User 模型的外键列和用于关联中间表的外键列。\nReferences:UserRefer 和 joinReferences:ProfileRefer 分别指定了用于关联 User 模型的外键列和用于关联 Profile 模型的外键列。\nRefer uint 声明了一个自定义的外键列 Refer，它用于将 User 模型与中间表关联起来。\ngorm:&quot;index:,unique&quot; 将 Refer 列标记为唯一索引，以确保每个 User 对应一个唯一的外键值。\nUserRefer uint 是 Profile 模型中的一个字段，表示每个个人资料都与一个用户关联。\ngorm:&quot;index:,unique&quot; 将 UserRefer 列标记为唯一索引，以确保每个 Profile 对应一个唯一的外键值。\n\n总体来说，以上代码展示了如何在 GORM 中定义多对多关系，并使用自定义中间表和外键列来保存关系。\n上述代码执行后的建表语句是什么执行以上代码后，GORM 会自动创建三张数据库表：\n\nusers 表：\n\nCREATE TABLE &#96;users&#96; (\n  &#96;id&#96; bigint unsigned NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime(6) NOT NULL,\n  &#96;updated_at&#96; datetime(6) NOT NULL,\n  &#96;deleted_at&#96; datetime(6) DEFAULT NULL,\n  &#96;refer&#96; bigint unsigned NOT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;idx_users_refer&#96; (&#96;refer&#96;),\n  KEY &#96;users_deleted_at&#96; (&#96;deleted_at&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;\n\nusers 表包含一个自增主键 id、created_at 和 updated_at 字段，以及一个名为 refer 的自定义外键列。refer 列被标记为唯一索引，以确保每个用户对应一个唯一的外键值。\n\nprofiles 表：\n\nCREATE TABLE &#96;profiles&#96; (\n  &#96;id&#96; bigint unsigned NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime(6) NOT NULL,\n  &#96;updated_at&#96; datetime(6) NOT NULL,\n  &#96;deleted_at&#96; datetime(6) DEFAULT NULL,\n  &#96;name&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,\n  &#96;user_refer&#96; bigint unsigned NOT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;idx_profiles_user_refer&#96; (&#96;user_refer&#96;),\n  KEY &#96;profiles_deleted_at&#96; (&#96;deleted_at&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;\n\nprofiles 表包含一个自增主键 id、created_at 和 updated_at 字段，以及一个名为 user_refer 的自定义外键列。user_refer 列被标记为唯一索引，以确保每个个人资料对应一个唯一的外键值。\n\nuser_profiles 表：\n\nCREATE TABLE &#96;user_profiles&#96; (\n  &#96;user_refer_id&#96; bigint unsigned NOT NULL,\n  &#96;profile_refer_id&#96; bigint unsigned NOT NULL,\n  PRIMARY KEY (&#96;user_refer_id&#96;,&#96;profile_refer_id&#96;),\n  KEY &#96;idx_user_profiles_profile_refer_id&#96; (&#96;profile_refer_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;\n\nuser_profiles 表包含两个名为 user_refer_id 和 profile_refer_id 的外键列，用于关联 users 表和 profiles 表。这两个外键列被用作联合主键，以确保每个关系都是唯一的。\n上述代码的增删改查完整代码是什么样以下是对于上述代码的增删改查的完整 GORM 代码示例：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tgorm.Model\n\tProfiles []Profile &#96;gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;&#96;\n\tRefer    uint      &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\ntype Profile struct &#123;\n\tgorm.Model\n\tName      string\n\tUserRefer uint &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\tdsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;database?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\terr &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 创建用户和个人资料\n\tuser :&#x3D; User&#123;\n\t\tRefer: 1,\n\t\tProfiles: []Profile&#123;\n\t\t\t&#123;\n\t\t\t\tName: &quot;Alice&quot;,\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\tName: &quot;Bob&quot;,\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;\n\terr &#x3D; db.Create(&amp;user).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 查询用户和个人资料\n\tvar result User\n\terr &#x3D; db.Where(&quot;refer &#x3D; ?&quot;, 1).Preload(&quot;Profiles&quot;).First(&amp;result).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Printf(&quot;User: %v, Profiles: %v\\n&quot;, result, result.Profiles)\n\n\t&#x2F;&#x2F; 更新用户和个人资料\n\terr &#x3D; db.Model(&amp;result).Updates(User&#123;\n\t\tRefer: 2,\n\t\tProfiles: []Profile&#123;\n\t\t\t&#123;\n\t\t\t\tName: &quot;Charlie&quot;,\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\tName: &quot;Dave&quot;,\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\t&#x2F;&#x2F; 查询用户和个人资料\n\terr &#x3D; db.Where(&quot;refer &#x3D; ?&quot;, 2).Preload(&quot;Profiles&quot;).First(&amp;result).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Printf(&quot;User: %v, Profiles: %v\\n&quot;, result, result.Profiles)\n\n\t&#x2F;&#x2F; 删除用户和个人资料\n\terr &#x3D; db.Delete(&amp;result).Error\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n&#125;\n\n该示例中的 dsn 变量包含数据库连接的详细信息，如数据库地址、用户名、密码和数据库名称等。\n示例中使用 db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;) 自动创建表结构。\n使用 db.Create(&amp;user) 创建用户和个人资料，使用 db.Where().Preload().First() 查询用户和个人资料，使用 db.Model().Updates() 更新用户和个人资料，使用 db.Delete() 删除用户和个人资料。在查询用户时，使用 Preload() 函数来关联查询用户的个人资料。\njoinForeignKey 和 joinReferences 各是什么作用joinForeignKey 和 joinReferences 是 GORM many-to-many 关系中的两个关键属性，用于指定多对多关联表的外键关联方式。\n\njoinForeignKey: 它指定用于关联多对多关系的关联表中的外键名称。在上述示例中，joinForeignKey 的值为 UserReferID，这意味着 user_profiles 表将包含一个名为 user_refer_id 的外键，该外键将引用 users 表中的 id 列。\n\njoinReferences: 它指定用于关联多对多关系的关联表中引用的外部表和列的名称。在上述示例中，joinReferences 的值为 ProfileRefer，这意味着 user_profiles 表将引用 profiles 表中的 user_refer 列。\n\n\n这两个属性一起使用，可以定义多对多关联表的外键关联方式，以及外键关联的表和列。\n哈哈，就是相当于 rename 啊\nforeignKey 和 References 的区别foreignKey 和 References 是 GORM 模型中的两个属性，用于指定关联关系中外键和引用的列名。它们的区别如下：\n\nforeignKey: 它用于指定包含外键的模型中的列名。在 many-to-many 关系中，它指定关联模型中的外键列。在 one-to-many 和 many-to-one 关系中，它指定包含外键的模型中的列名。例如，foreignKey: UserReferID 指定 User 模型中的 UserReferID 列是一个外键。\n\nReferences: 它用于指定引用的模型中的列名。在 many-to-many 关系中，它指定关联的模型中的列名。在 one-to-many 和 many-to-one 关系中，它指定关联的模型中的主键列名。例如，References: ProfileRefer 指定 Profile 模型中的 ProfileRefer 列是被引用的列。\n\n\n因此，foreignKey 和 References 分别用于指定关联关系中的外键和引用的列名。\n在 many-to-many 关系中，\n\nforeignKey 用于指定关联模型中的外键列名，\nReferences 用于指定被关联的模型中的列名。\n\n在 one-to-many 和 many-to-one 关系中，\n\nforeignKey 用于指定包含外键的模型中的列名，\nReferences 用于指定被关联的模型中的主键列名。\n\n理解\ngorm foreignKey，可以理解成标记，References 理解成这个标记从哪来，这么理解没错吧\nforeignKey，可以理解成标记，References 理解成这个标记从哪来\n可以这么理解，foreignKey 和 References 分别用于指定关联关系中的外键和引用的列名。\n\nforeignKey 可以理解为一个标记，用于标记包含外键的模型中的列名。\n\nReferences 可以理解为标记的来源，用于指定被关联的模型中的列名或主键列名，以便 GORM 知道应该关联哪些表和列。\n\n\n在 many-to-many 关系中，foreignKey 用于标记关联模型中的外键列名，References 用于指定被关联的模型中的列名。\n在 one-to-many 和 many-to-one 关系中，foreignKey 用于标记包含外键的模型中的列名，References 用于指定被关联的模型中的主键列名。\ngorm 设计一个用户可以有多个角色，每个角色可以有多个权限下面是一个示例 GORM 模型，用于描述用户、角色和权限之间的多对多关系：\ntype User struct &#123;\n    gorm.Model\n    Roles []Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name       string\n    Permissions []Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;\n\n在上面的示例中，User 模型和 Role 模型之间是多对多关系，Role 模型和 Permission 模型之间也是多对多关系。在 User 模型中，Roles 属性定义为一个 []Role 切片，用于存储用户所拥有的角色。在 Role 模型中，Permissions 属性定义为一个 []Permission 切片，用于存储角色所拥有的权限。\n在模型定义中，many2many 标签用于定义多对多关系的关联表名。例如，在 User 模型中，gorm:&quot;many2many:user_roles&quot; 定义了一个名为 user_roles 的关联表，用于关联 User 模型和 Role 模型。在 Role 模型中，gorm:&quot;many2many:role_permissions&quot; 定义了一个名为 role_permissions 的关联表，用于关联 Role 模型和 Permission 模型。\n通过上述示例，可以实现用户和角色之间的多对多关系，以及角色和权限之间的多对多关系。在应用程序中，可以使用 GORM 提供的 API 对这些模型进行增删改查操作。例如，可以使用以下代码将一个角色添加到一个用户中：\nuser :&#x3D; &amp;User&#123;ID: 1&#125;\nrole :&#x3D; &amp;Role&#123;ID: 2&#125;\ndb.Model(user).Association(&quot;Roles&quot;).Append(role)\n\n类似地，可以使用 GORM 提供的 API 执行其他类型的操作，例如查询用户拥有的所有角色、查询拥有特定权限的所有角色等等。\n表结构根据上面给出的模型定义，GORM 可以自动创建相应的数据库表结构。下面是这些模型对应的数据库表结构示例：\nCREATE TABLE &#96;users&#96; (\n  &#96;id&#96; int NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  &#96;deleted_at&#96; datetime DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;roles&#96; (\n  &#96;id&#96; int NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  &#96;deleted_at&#96; datetime DEFAULT NULL,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;permissions&#96; (\n  &#96;id&#96; int NOT NULL AUTO_INCREMENT,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  &#96;deleted_at&#96; datetime DEFAULT NULL,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n);\n\nCREATE TABLE &#96;user_roles&#96; (\n  &#96;user_id&#96; int NOT NULL,\n  &#96;role_id&#96; int NOT NULL,\n  PRIMARY KEY (&#96;user_id&#96;,&#96;role_id&#96;),\n  KEY &#96;user_roles_role_id_foreign&#96; (&#96;role_id&#96;),\n  CONSTRAINT &#96;user_roles_user_id_foreign&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;users&#96; (&#96;id&#96;) ON DELETE CASCADE,\n  CONSTRAINT &#96;user_roles_role_id_foreign&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;roles&#96; (&#96;id&#96;) ON DELETE CASCADE\n);\n\nCREATE TABLE &#96;role_permissions&#96; (\n  &#96;role_id&#96; int NOT NULL,\n  &#96;permission_id&#96; int NOT NULL,\n  PRIMARY KEY (&#96;role_id&#96;,&#96;permission_id&#96;),\n  KEY &#96;role_permissions_permission_id_foreign&#96; (&#96;permission_id&#96;),\n  CONSTRAINT &#96;role_permissions_role_id_foreign&#96; FOREIGN KEY (&#96;role_id&#96;) REFERENCES &#96;roles&#96; (&#96;id&#96;) ON DELETE CASCADE,\n  CONSTRAINT &#96;role_permissions_permission_id_foreign&#96; FOREIGN KEY (&#96;permission_id&#96;) REFERENCES &#96;permissions&#96; (&#96;id&#96;) ON DELETE CASCADE\n);\n\n可以看到，GORM 自动生成了五个表结构，分别对应 User、Role、Permission、user_roles 和 role_permissions 这五个模型。其中，users、roles 和 permissions 分别对应 User、Role 和 Permission 这三个模型的基本信息。user_roles 表用于关联 User 和 Role 之间的多对多关系，role_permissions 表用于关联 Role 和 Permission 之间的多对多关系。\n含增删改查的完整代码以下是完整的代码示例，包含增删改查操作：\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;gorm.io&#x2F;gorm&#x2F;clause&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    err &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to migrate database&quot;)\n    &#125;\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;Name: &quot;管理员&quot;&#125;\n    role2 :&#x3D; &amp;Role&#123;Name: &quot;普通用户&quot;&#125;\n    perm1 :&#x3D; &amp;Permission&#123;Name: &quot;创建用户&quot;&#125;\n    perm2 :&#x3D; &amp;Permission&#123;Name: &quot;删除用户&quot;&#125;\n\n    db.Create(role1)\n    db.Create(role2)\n    db.Create(perm1)\n    db.Create(perm2)\n\n    &#x2F;&#x2F; 创建用户并分配角色和权限\n    user1 :&#x3D; &amp;User&#123;Name: &quot;张三&quot;&#125;\n    user2 :&#x3D; &amp;User&#123;Name: &quot;李四&quot;&#125;\n\n    user1.Roles &#x3D; append(user1.Roles, role1)\n    user1.Roles[0].Permissions &#x3D; append(user1.Roles[0].Permissions, perm1)\n    user1.Roles[0].Permissions &#x3D; append(user1.Roles[0].Permissions, perm2)\n\n    user2.Roles &#x3D; append(user2.Roles, role2)\n    user2.Roles[0].Permissions &#x3D; append(user2.Roles[0].Permissions, perm1)\n\n    db.Create(user1)\n    db.Create(user2)\n\n    &#x2F;&#x2F; 查询用户和角色信息\n    var users []*User\n    db.Preload(clause.Associations).Find(&amp;users)\n    for _, user :&#x3D; range users &#123;\n        fmt.Printf(&quot;用户 %s 的角色信息：\\n&quot;, user.Name)\n        for _, role :&#x3D; range user.Roles &#123;\n            fmt.Printf(&quot;角色 %s 的权限信息：\\n&quot;, role.Name)\n            for _, perm :&#x3D; range role.Permissions &#123;\n                fmt.Printf(&quot;- %s\\n&quot;, perm.Name)\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 更新用户角色信息\n    db.Model(user1).Association(&quot;Roles&quot;).Replace([]*Role&#123;role2&#125;)\n    db.Model(user2).Association(&quot;Roles&quot;).Clear()\n\n    &#x2F;&#x2F; 删除用户和角色信息\n    db.Delete(user1)\n    db.Delete(user2)\n    db.Delete(role1)\n    db.Delete(role2)\n    db.Delete(perm1)\n    db.Delete(perm2)\n&#125;\n\n在这个代码示例中，我们首先定义了 User、Role 和 Permission 三个模型，用于表示用户、角色和权限之间的关系。其中，User 模型中有一个 Roles 字段，表示一个用户可以拥有多个角色；Role 模型中有一个 Permissions 字段，表示一个角色可以拥有多\n简化后的代码可以，以下是一个简化版的代码示例：\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;)\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;Name: &quot;管理员&quot;&#125;\n    role2 :&#x3D; &amp;Role&#123;Name: &quot;普通用户&quot;&#125;\n    perm1 :&#x3D; &amp;Permission&#123;Name: &quot;创建用户&quot;&#125;\n    perm2 :&#x3D; &amp;Permission&#123;Name: &quot;删除用户&quot;&#125;\n\n    db.Create(role1, role2)\n    db.Create(perm1, perm2)\n\n    &#x2F;&#x2F; 创建用户并分配角色和权限\n    user1 :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Roles: []*Role&#123;role1&#125;,&#125;\n    user1.Roles[0].Permissions &#x3D; []*Permission&#123;perm1, perm2&#125;\n    user2 :&#x3D; &amp;User&#123;Name: &quot;李四&quot;, Roles: []*Role&#123;role2&#125;,&#125;\n    user2.Roles[0].Permissions &#x3D; []*Permission&#123;perm1&#125;\n\n    db.Create(user1, user2)\n\n    &#x2F;&#x2F; 查询用户和角色信息\n    var users []*User\n    db.Preload(&quot;Roles.Permissions&quot;).Find(&amp;users)\n    for _, user :&#x3D; range users &#123;\n        fmt.Printf(&quot;用户 %s 的角色信息：\\n&quot;, user.Name)\n        for _, role :&#x3D; range user.Roles &#123;\n            fmt.Printf(&quot;角色 %s 的权限信息：\\n&quot;, role.Name)\n            for _, perm :&#x3D; range role.Permissions &#123;\n                fmt.Printf(&quot;- %s\\n&quot;, perm.Name)\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 更新用户角色信息\n    db.Model(user1).Association(&quot;Roles&quot;).Replace([]*Role&#123;role2&#125;)\n    db.Model(user2).Association(&quot;Roles&quot;).Clear()\n\n    &#x2F;&#x2F; 删除用户和角色信息\n    db.Delete(user1, user2)\n    db.Delete(role1, role2)\n    db.Delete(perm1, perm2)\n&#125;\n\n这个代码示例去掉了一些冗余的代码，并且使用了链式调用的方式进行创建、查询、更新和删除操作。同时，由于 GORM 的 Preload 方法支持链式调用，因此我们可以在查询用户信息时，一次性把用户、角色和权限的信息全部查询出来，代码更加简洁。\n进一步简化后的代码可以使用简化的代码实现相同的功能：\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name  string\n    Roles []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;)\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;Name: &quot;管理员&quot;, Permissions: []*Permission&#123;&#123;Name: &quot;创建用户&quot;&#125;, &#123;Name: &quot;删除用户&quot;&#125;&#125;&#125;\n    role2 :&#x3D; &amp;Role&#123;Name: &quot;普通用户&quot;, Permissions: []*Permission&#123;&#123;Name: &quot;创建用户&quot;&#125;&#125;&#125;\n\n    db.Create(role1, role2)\n\n    &#x2F;&#x2F; 创建用户并分配角色和权限\n    user1 :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Roles: []*Role&#123;role1&#125;&#125;\n    user2 :&#x3D; &amp;User&#123;Name: &quot;李四&quot;, Roles: []*Role&#123;role2&#125;&#125;\n\n    db.Create(user1, user2)\n\n    &#x2F;&#x2F; 查询用户和角色信息\n    var users []*User\n    db.Preload(&quot;Roles.Permissions&quot;).Find(&amp;users)\n    for _, user :&#x3D; range users &#123;\n        fmt.Printf(&quot;用户 %s 的角色信息：\\n&quot;, user.Name)\n        for _, role :&#x3D; range user.Roles &#123;\n            fmt.Printf(&quot;角色 %s 的权限信息：\\n&quot;, role.Name)\n            for _, perm :&#x3D; range role.Permissions &#123;\n                fmt.Printf(&quot;- %s\\n&quot;, perm.Name)\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 更新用户角色信息\n    db.Model(user1).Association(&quot;Roles&quot;).Replace([]*Role&#123;role2&#125;)\n    db.Model(user2).Association(&quot;Roles&quot;).Clear()\n\n    &#x2F;&#x2F; 删除用户和角色信息\n    db.Delete(user1, user2)\n    db.Delete(role1, role2)\n&#125;\n\n这个简化的代码与之前的代码相比主要做了以下几点改进：\n\n在创建角色时，同时创建了相应的权限，避免了后续的额外操作；\n在创建用户时，只需要指定用户的角色，而不需要为角色添加权限，因为角色已经预设了权限；\n通过链式操作，更加简洁地实现了用户角色的增删改查操作；\n精简了查询用户角色信息的代码。\n\n上述代码中 []*Permission 什么意思[]*Permission 表示 Permission 结构体的指针数组。在这个例子中，一个 Role 可以有多个 Permission，因此 Role 结构体中的 Permissions 字段的类型是 []*Permission。指针数组的优点是可以动态地分配内存，这样可以减少内存的浪费。另外，使用指针数组还可以提高程序的效率，因为指针传递比值传递更快。\n上述代码中 更新用户角色信息，为什么用 Association在 GORM 中，使用 Association 方法可以方便地处理多对多关系的增删改查操作。当我们想要在多对多关系中更新关联记录时，可以使用 Association 方法来更新关联关系。\n具体来说，我们可以通过 Association 方法获取到某个模型的关联模型，然后使用关联模型的方法来更新关联关系。在这个例子中，我们需要更新用户和角色之间的关联关系，因此可以使用 user.Roles().Replace(roles) 方法来替换当前用户的角色列表。这个方法会把原有的角色列表清空，然后添加新的角色列表，实现了更新操作。如果需要追加角色，可以使用 Add 方法。如果需要删除角色，可以使用 Delete 方法。\n总之，使用 Association 方法可以简化多对多关系的更新操作，提高程序的可读性和可维护性。\n把原有的角色列表清空，然后添加新的角色列表，会不会出现，列表清空了，却没有添加成功的现象在使用 Association 方法更新多对多关系时，如果出现了列表清空了但没有添加成功的情况，一般有两个可能的原因：\n\n数据库事务问题。在使用 GORM 操作数据库时，通常需要开启事务来确保操作的原子性和一致性。如果更新多对多关系时没有开启事务或事务异常终止，可能会导致清空列表成功但添加新列表失败的情况。\n\n数据库字段约束问题。在多对多关系中，经常需要使用中间表来记录两个模型之间的关联关系。如果中间表中定义的外键约束或唯一约束等字段约束与当前操作不兼容，也可能导致清空列表成功但添加新列表失败的情况。\n\n\n为了避免出现这种情况，我们可以在更新多对多关系之前先检查数据库事务的状态，确保事务正常运行。此外，我们还应该仔细检查中间表的字段定义和约束，确保与当前操作相兼容。\n先检查数据库事务的状态？是的，检查数据库事务的状态可以确保事务正常运行，从而避免出现清空列表成功但添加新列表失败的情况。在 GORM 中，我们可以使用 gorm.DB 结构体的 Begin 方法开启一个数据库事务，然后使用 gorm.DB 结构体的 Commit 和 Rollback 方法来提交或回滚事务。\n具体来说，在更新多对多关系时，可以使用 DB.Begin 方法开启一个数据库事务，然后在事务中执行清空列表和添加新列表的操作，最后使用 DB.Commit 方法提交事务。如果出现异常，可以使用 DB.Rollback 方法回滚事务。\n以下是一个简单的示例代码：\nfunc UpdateUserRole(db *gorm.DB, user *User, roles []*Role) error &#123;\n    tx :&#x3D; db.Begin()\n\n    if err :&#x3D; tx.Error; err !&#x3D; nil &#123;\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Model(user).Association(&quot;Roles&quot;).Replace(roles).Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Commit().Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    return nil\n&#125;\n\n在这个示例中，我们首先使用 DB.Begin 方法开启一个事务，然后在事务中执行清空列表和添加新列表的操作。如果操作成功，就使用 DB.Commit 方法提交事务，否则使用 DB.Rollback 方法回滚事务。注意，在操作过程中，我们使用 tx.Error 方法检查事务的状态，确保事务正常运行。\n至此，完整代码以下是完整的示例代码：\npackage main\n\nimport (\n    &quot;fmt&quot;\n\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Username string &#96;gorm:&quot;uniqueIndex&quot;&#96;\n    Password string\n    Roles    []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name       string         &#96;gorm:&quot;uniqueIndex&quot;&#96;\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ntype Permission struct &#123;\n    gorm.Model\n    Name string &#96;gorm:&quot;uniqueIndex&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    if err :&#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Role&#123;&#125;, &amp;Permission&#123;&#125;); err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 创建用户\n    user1 :&#x3D; &amp;User&#123;\n        Username: &quot;user1&quot;,\n        Password: &quot;password1&quot;,\n    &#125;\n    db.Create(user1)\n\n    &#x2F;&#x2F; 创建角色和权限\n    role1 :&#x3D; &amp;Role&#123;\n        Name: &quot;role1&quot;,\n        Permissions: []*Permission&#123;\n            &#123;Name: &quot;permission1&quot;&#125;,\n            &#123;Name: &quot;permission2&quot;&#125;,\n        &#125;,\n    &#125;\n    db.Create(role1)\n    role2 :&#x3D; &amp;Role&#123;\n        Name: &quot;role2&quot;,\n        Permissions: []*Permission&#123;\n            &#123;Name: &quot;permission2&quot;&#125;,\n            &#123;Name: &quot;permission3&quot;&#125;,\n        &#125;,\n    &#125;\n    db.Create(role2)\n\n    &#x2F;&#x2F; 更新用户角色信息\n    roles :&#x3D; []*Role&#123;role1, role2&#125;\n    if err :&#x3D; UpdateUserRoles(db, user1, roles); err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 查询用户信息\n    var user User\n    db.Preload(&quot;Roles.Permissions&quot;).First(&amp;user, &quot;username &#x3D; ?&quot;, &quot;user1&quot;)\n    fmt.Printf(&quot;User: %+v\\n&quot;, user)\n&#125;\n\nfunc UpdateUserRoles(db *gorm.DB, user *User, roles []*Role) error &#123;\n    tx :&#x3D; db.Begin()\n\n    if err :&#x3D; tx.Error; err !&#x3D; nil &#123;\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Model(user).Association(&quot;Roles&quot;).Replace(roles).Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    if err :&#x3D; tx.Commit().Error; err !&#x3D; nil &#123;\n        tx.Rollback()\n        return err\n    &#125;\n\n    return nil\n&#125;\n\n在这个示例中，我们定义了 User、Role 和 Permission 三个模型，并使用 many2many 关系将它们关联起来。在 UpdateUserRoles 函数中，我们使用了 Association 方法更新用户的角色信息，并在事务中执行操作，确保操作的原子性。最后，我们查询了用户信息，并打印出来。\nprimaryKeyprimaryKey 是 GORM 中用于指定主键名称的选项之一。如果不使用此选项，则默认情况下，GORM 会将模型的 ID 字段作为主键。如果模型有多个字段组成复合主键，则可以使用 gorm:&quot;primaryKey&quot; 标签在这些字段上指定为主键。\n例如，下面的代码演示了如何在 GORM 中使用复合主键：\ntype User struct &#123;\n    Name   string &#96;gorm:&quot;primaryKey&quot;&#96;\n    Number int    &#96;gorm:&quot;primaryKey&quot;&#96;\n    Email  string\n&#125;\n\ndb.AutoMigrate(&amp;User&#123;&#125;)\n\n在上面的示例中，User 模型的主键由 Name 和 Number 两个字段组成。在 Name 和 Number 字段上都使用了 primaryKey 标签，表示它们是组成主键的一部分。执行 db.AutoMigrate(&amp;User&#123;&#125;) 后，GORM 将会在数据库中创建一个名为 users 的表，其中包含 Name 和 Number 两个字段作为主键。\n需要注意的是，使用复合主键的模型在使用 GORM 进行增删改查等操作时，需要使用 db.Session(&amp;gorm.Session&#123;FullSaveAssociations: true&#125;) 开启完整关联保存模式，以保证 GORM 能够正确地处理关联数据的更新和删除。\n完整的例子以下是一个使用 GORM 创建包含复合主键的表格的示例代码：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Book struct &#123;\n\tID    int    &#96;gorm:&quot;primaryKey;autoIncrement:false&quot;&#96;\n\tTitle string &#96;gorm:&quot;primaryKey;autoIncrement:false&quot;&#96;\n\tAuthor string\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接数据库\n\tdsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\tdb.AutoMigrate(&amp;Book&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建数据行\n\tbook1 :&#x3D; &amp;Book&#123;ID: 1, Title: &quot;GORM Basics&quot;, Author: &quot;John Doe&quot;&#125;\n\tbook2 :&#x3D; &amp;Book&#123;ID: 2, Title: &quot;Advanced GORM&quot;, Author: &quot;Jane Smith&quot;&#125;\n\n\tdb.Create(book1)\n\tdb.Create(book2)\n\n\t&#x2F;&#x2F; 查询数据行\n\tvar books []*Book\n\tdb.Find(&amp;books)\n\n\t&#x2F;&#x2F; 打印查询结果\n\tfor _, book :&#x3D; range books &#123;\n\t\tfmt.Printf(&quot;Book: %s by %s\\n&quot;, book.Title, book.Author)\n\t&#125;\n&#125;\n\n在这个例子中，我们定义了一个 Book 结构体，并为其中的 ID 和 Title 字段都添加了 primaryKey 标记，以实现复合主键。然后我们创建了两条数据行，分别为 ID 为 1 和 2 的两本书。最后我们查询了所有的书，并将结果打印出来。\n使用了 autoIncrement:false复合主键的情况下，通常不会使用自增长的方式来生成主键，而是需要手动指定主键的值。在 GORM 中，可以通过在模型中定义多个字段，并使用 primaryKey 标记来指定这些字段作为复合主键。\n下面是一个使用 GORM 定义复合主键的完整示例：\npackage main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;time&quot;\n)\n\ntype OrderItem struct &#123;\n    OrderID  int    &#96;gorm:&quot;primaryKey&quot;&#96;\n    ItemCode string &#96;gorm:&quot;primaryKey&quot;&#96;\n    Name     string\n    Price    float64\n    CreatedAt time.Time\n&#125;\n\nfunc main() &#123;\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;OrderItem&#123;&#125;)\n\n    &#x2F;&#x2F; 插入数据\n    item1 :&#x3D; &amp;OrderItem&#123;OrderID: 1, ItemCode: &quot;A001&quot;, Name: &quot;商品A&quot;, Price: 100.0, CreatedAt: time.Now()&#125;\n    item2 :&#x3D; &amp;OrderItem&#123;OrderID: 1, ItemCode: &quot;A002&quot;, Name: &quot;商品B&quot;, Price: 200.0, CreatedAt: time.Now()&#125;\n    item3 :&#x3D; &amp;OrderItem&#123;OrderID: 2, ItemCode: &quot;A003&quot;, Name: &quot;商品C&quot;, Price: 300.0, CreatedAt: time.Now()&#125;\n    db.Create(item1, item2, item3)\n\n    &#x2F;&#x2F; 查询数据\n    var items []*OrderItem\n    db.Find(&amp;items)\n    for _, item :&#x3D; range items &#123;\n        println(item.OrderID, item.ItemCode, item.Name, item.Price, item.CreatedAt)\n    &#125;\n\n    &#x2F;&#x2F; 更新数据\n    db.Model(item1).Updates(map[string]interface&#123;&#125;&#123;&quot;Price&quot;: 150.0&#125;)\n\n    &#x2F;&#x2F; 删除数据\n    db.Delete(item2)\n&#125;\n\n在这个例子中，OrderID 和 ItemCode 两个字段一起作为 OrderItem 模型的复合主键，分别使用 primaryKey 标记来指定。这里注意到 autoIncrement 参数被设置为 false，因为复合主键一般不使用自增长的方式生成主键。\n在插入数据时，需要手动指定主键的值。在查询、更新和删除数据时，也需要同时指定主键的值来定位需要操作的数据行。\n什么情况下，使用复合主键复合主键通常用于满足业务需求，例如要求某些字段的组合必须唯一。在这种情况下，单一的主键可能无法满足要求，因为其中一个字段可能不足以唯一标识一个记录。例如，在一个订单表中，一个订单可能有多个商品，因此订单编号和商品编号的组合可能是唯一的，这时候就可以使用复合主键来保证唯一性。\n关联模式在 GORM 中，关联模式有四种，分别是：\n\nBelongsTo 关联\nHasOne 关联\nHasMany 关联\nManyToMany 关联\n\n下面对每种关联模式进行简要介绍：\n\nBelongsTo 关联：\n\nBelongsTo 关联表示一个模型属于另一个模型，也就是一对一的关系。在 GORM 中，使用 BelongsTo 方法来定义关联关系，例如：\ntype User struct &#123;\n    gorm.Model\n    Name      string\n    CompanyID uint\n    Company   Company\n&#125;\n\ntype Company struct &#123;\n    gorm.Model\n    Name  string\n    Users []User\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).BelongsTo(&amp;Company&#123;&#125;)\n\n\nHasOne 关联：\n\nHasOne 关联表示一个模型拥有另一个模型，也就是一对一的关系。在 GORM 中，使用 HasOne 方法来定义关联关系，例如：\ntype User struct &#123;\n    gorm.Model\n    Name         string\n    CreditCard   CreditCard\n    CreditCardID uint\n&#125;\n\ntype CreditCard struct &#123;\n    gorm.Model\n    Number string\n    UserID uint\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).HasOne(&amp;CreditCard&#123;&#125;)\n\n\nHasMany 关联：\n\nHasMany 关联表示一个模型拥有多个另一个模型，也就是一对多的关系。在 GORM 中，使用 HasMany 方法来定义关联关系，例如：\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Orders []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID uint\n    Amount float32\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).HasMany(&amp;Order&#123;&#125;)\n\n\nManyToMany 关联：\n\nManyToMany 关联表示两个模型之间有多对多的关系。在 GORM 中，使用 Many2Many 方法来定义关联关系，例如：\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\ndb.Model(&amp;User&#123;&#125;).Many2Many(&amp;Role&#123;&#125;, &quot;user_roles&quot;)\ndb.Model(&amp;Role&#123;&#125;).Many2Many(&amp;Permission&#123;&#125;, &quot;role_permissions&quot;)\n\n以上就是 GORM 中四种关联模式的介绍。需要注意的是，使用关联模式时，应该根据实际情况选择合适的模式。\n如何区分 BelongsTo 和 HasOne在 GORM 中，BelongsTo 和 HasOne 都表示一对一的关系，但它们在语义上有所不同。\nBelongsTo 表示一个模型“属于”另一个模型，比如一个订单属于一个用户。在这种关系下，通常在从表（即属于表）中建立外键关联到主表（即拥有表）中。\nHasOne 表示一个模型“拥有”另一个模型，比如一个用户拥有一个个人资料。在这种关系下，通常在主表中建立外键关联到从表中。\n因此，可以根据语义来区分这两种关系。如果一个模型属于另一个模型，则使用 BelongsTo，如果一个模型拥有另一个模型，则使用 HasOne。\n总结：\n\n使用上看主键是在从表还是在主表：在从表 BelongsTo, 在主表 HasOne\n语义不同： 如果一个模型属于另一个模型，则使用 BelongsTo，如果一个模型拥有另一个模型，则使用 HasOne。\n\n关联操作在 GORM 中，关联操作主要包括以下几个方面：\n\n预加载（Preloading）：一般用于查询时，同时将关联对象加载到内存中，避免多次查询数据库。\n关联查询（Joins）：根据关联条件，将两个或多个表关联起来，查询相关数据。\n关联插入（Association）：将两个或多个表之间的关联关系插入到关联表中。\n关联更新（Association）：更新关联表中的关联关系。\n关联删除（Association）：删除关联表中的关联关系。\n\n这些操作涉及到不同的 GORM 方法，比如 Preload、Joins、Association 等。具体的使用方法可以查看 GORM 的官方文档。\nAssociation在 GORM 中，Association 指的是通过关联关系进行增删改查操作的方法，主要包括以下几个方法：\n\nAppend：添加关联记录\nDelete：删除关联记录\nReplace：替换关联记录\nClear：清空关联记录\n\n这些方法可以用于多对多、一对多等关联关系，可以通过关联的对象的指针或 ID 进行操作。这些方法在使用时需要注意事务的管理，避免出现数据不一致的情况。在使用时，也需要注意避免出现死循环的情况，特别是在多层级的关联关系中。\nAssociation 这四个 API 怎么用这四个 API 都是用于修改关联关系的，具体如下：\n\ndb.Model(&amp;user).Association(&quot;Roles&quot;).Append(&amp;role1, &amp;role2)：将 user 与 role1 和 role2 关联，如果关联关系已经存在，则不会进行任何操作。\ndb.Model(&amp;user).Association(&quot;Roles&quot;).Delete(&amp;role1, &amp;role2)：删除 user 与 role1 和 role2 的关联关系，如果关联关系不存在，则不会进行任何操作。\ndb.Model(&amp;user).Association(&quot;Roles&quot;).Replace(&amp;role1, &amp;role2)：将 user 与 role1 和 role2 的关联关系替换为新的关联关系，如果关联关系已经存在，则先删除旧的关联关系再进行新的关联。\ndb.Model(&amp;user).Association(&quot;Roles&quot;).Clear()：清空 user 与 Roles 的关联关系。\n\n其中，user 表示主表，Roles 表示关联表。在使用这些 API 前，需要先在主表中定义关联关系，例如：\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Roles  []*Role &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n&#125;\n\n这里的 user_roles 是中间表的名称，用于维护主表和关联表之间的关联关系。同时，在关联表中也需要定义相应的关联关系，例如：\ntype Role struct &#123;\n    gorm.Model\n    Name        string\n    Users       []*User &#96;gorm:&quot;many2many:user_roles&quot;&#96;\n    Permissions []*Permission &#96;gorm:&quot;many2many:role_permissions&quot;&#96;\n&#125;\n\n这里的 user_roles 和主表中的名称要保持一致，Users 表示与 User 表关联的字段，role_permissions 是另一个中间表的名称，用于维护 Role 表与 Permission 表之间的关联关系。\nAssociation 完整的例子以下是一个完整的例子，展示如何在 GORM 中定义和使用关联模式：\npackage main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;log&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name      string\n    Email     string\n    Profile   Profile\n    Addresses []Address\n&#125;\n\ntype Profile struct &#123;\n    gorm.Model\n    UserID uint\n    Age    int\n&#125;\n\ntype Address struct &#123;\n    gorm.Model\n    UserID  uint\n    Country string\n    City    string\n&#125;\n\nfunc main() &#123;\n    dsn :&#x3D; &quot;root:123456@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移表结构\n    err &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;, &amp;Address&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        log.Fatal(err)\n    &#125;\n\n    &#x2F;&#x2F; 创建用户和关联数据\n    user :&#x3D; User&#123;\n        Name:  &quot;张三&quot;,\n        Email: &quot;zhangsan@example.com&quot;,\n        Profile: Profile&#123;\n            Age: 18,\n        &#125;,\n        Addresses: []Address&#123;\n            &#123;Country: &quot;China&quot;, City: &quot;Shanghai&quot;&#125;,\n            &#123;Country: &quot;USA&quot;, City: &quot;New York&quot;&#125;,\n        &#125;,\n    &#125;\n\n    result :&#x3D; db.Create(&amp;user)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    &#x2F;&#x2F; 查询用户和关联数据\n    var user2 User\n    result &#x3D; db.Preload(&quot;Profile&quot;).Preload(&quot;Addresses&quot;).First(&amp;user2)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    log.Println(user2)\n\n    &#x2F;&#x2F; 更新关联数据\n    user2.Addresses[0].City &#x3D; &quot;Beijing&quot;\n    result &#x3D; db.Save(&amp;user2)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    &#x2F;&#x2F; 删除关联数据\n    result &#x3D; db.Delete(&amp;user2.Addresses[0])\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n\n    &#x2F;&#x2F; 删除用户和关联数据\n    result &#x3D; db.Delete(&amp;user2)\n    if result.Error !&#x3D; nil &#123;\n        log.Fatal(result.Error)\n    &#125;\n&#125;\n\n在这个例子中，我们定义了三个模型：User、Profile 和 Address。它们之间的关联模式分别为：\n\nUser 和 Profile：一个用户有一个个人资料，使用 BelongsTo 模式。\nUser 和 Address：一个用户有多个地址，使用 HasMany 模式。\nAddress 和 User：一个地址属于一个用户，使用 BelongsTo 模式。\n\n我们首先创建一个用户和关联数据，并通过 Create() 方法将它们存储到数据库中。接着，我们查询该用户及其关联数据，使用 Preload() 方法可以在一次查询中加载关联数据，避免了多次查询数据库的问题。我们还演示了如何更新关联数据和删除关联数据，以及如何删除用户及其关联数据。\n下面是一个完整的例子，演示如何使用 GORM 进行实体关联。\n假设有两个表：用户和订单。一个用户可以拥有多个订单，而一个订单只能属于一个用户。用户和订单之间是一对多的关系。首先，定义两个模型：\ntype User struct &#123;\n    gorm.Model\n    Name    string\n    Email   string\n    Orders  []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID  uint\n    Name    string\n    Price   float64\n&#125;\n\n在用户模型中，使用了 GORM 内置的 gorm.Model 结构体，该结构体包含了一些常用的字段，比如 ID、CreatedAt、UpdatedAt 和 DeletedAt。同时，用户模型还包含了一个名为 Orders 的字段，该字段为用户的订单列表。在订单模型中，使用了 UserID 字段来存储订单所属的用户 ID。\n然后，使用 GORM 进行实体关联：\n&#x2F;&#x2F; 创建用户和订单\nuser :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Email: &quot;zhangsan@example.com&quot;&#125;\norder1 :&#x3D; &amp;Order&#123;Name: &quot;订单1&quot;, Price: 100&#125;\norder2 :&#x3D; &amp;Order&#123;Name: &quot;订单2&quot;, Price: 200&#125;\nuser.Orders &#x3D; []Order&#123;*order1, *order2&#125;\ndb.Create(user)\n\n&#x2F;&#x2F; 查询用户及其订单信息\nvar u User\ndb.Preload(&quot;Orders&quot;).First(&amp;u)\nfmt.Println(&quot;用户信息：&quot;, u)\nfor _, order :&#x3D; range u.Orders &#123;\n    fmt.Println(&quot;订单信息：&quot;, order)\n&#125;\n\n&#x2F;&#x2F; 更新用户订单信息\ndb.Model(&amp;u).Association(&quot;Orders&quot;).Delete(order1)\ndb.Model(&amp;u).Association(&quot;Orders&quot;).Replace([]Order&#123;*order2&#125;)\ndb.Model(&amp;u).Association(&quot;Orders&quot;).Clear()\n\n&#x2F;&#x2F; 删除用户及其订单信息\ndb.Delete(&amp;u)\n\n在创建用户时，使用了用户模型的 Orders 字段来设置用户的订单列表。在查询用户时，使用了 GORM 的 Preload 方法来预加载用户的订单信息，以避免 N+1 查询的问题。在更新用户订单信息时，使用了 GORM 的 Association 方法来对用户的订单列表进行增删改查操作。在删除用户时，使用了 GORM 的 Delete 方法来同时删除用户及其订单信息。\n完整代码如下：package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name    string\n    Email   string\n    Orders  []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID  uint\n    Name    string\n    Price   float64\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 连接数据库\n    dsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n    db, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n    &#x2F;&#x2F; 自动迁移表结构\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;)\n\n    &#x2F;&#x2F; 创建用户和订单\n    user :&#x3D; &amp;User&#123;Name: &quot;张三&quot;, Email: &quot;zhangsan@example.com&quot;&#125;\n    order1 :&#x3D; &amp;Order&#123;Name: &quot;订单1&quot;, Price:\n\n&#x2F;&#x2F; 可以通过 &#96;Association&#96; 方法来进行关联操作。&#96;Association&#96; 方法接受一个关联字段的名称作为参数，返回该关联字段的关联对象，可以对该关联对象进行增删改查等操作。\n\n&#x2F;&#x2F; 例如，在上一个例子中，我们可以通过以下代码来进行关联操作：\n\n&#x2F;&#x2F; 建立关联关系\ndb.Model(&amp;user).Association(&quot;Profile&quot;).Assign(&amp;profile)\n\n&#x2F;&#x2F; 清空关联关系\ndb.Model(&amp;user).Association(&quot;Profile&quot;).Clear()\n\n&#x2F;&#x2F; 添加关联关系\ndb.Model(&amp;user).Association(&quot;Addresses&quot;).Append(&amp;address)\n\n&#x2F;&#x2F; 删除关联关系\ndb.Model(&amp;user).Association(&quot;Addresses&quot;).Delete(&amp;address)\n\n其中，\n\nAssign 方法可以用来建立关联关系，\nClear 方法可以用来清空关联关系，\nAppend 方法可以用来添加关联关系，\nDelete 方法可以用来删除关联关系。\n\n完整代码如下：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tgorm.Model\n\tName      string\n\tProfile   Profile\n\tAddresses []Address\n&#125;\n\ntype Profile struct &#123;\n\tgorm.Model\n\tUserID uint\n\tName   string\n&#125;\n\ntype Address struct &#123;\n\tgorm.Model\n\tUserID  uint\n\tCity    string\n\tCountry string\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接数据库\n\tdsn :&#x3D; &quot;user:password@tcp(127.0.0.1:3306)&#x2F;test?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, _ :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\tdb.AutoMigrate(&amp;User&#123;&#125;, &amp;Profile&#123;&#125;, &amp;Address&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建用户、资料和地址\n\tuser :&#x3D; &amp;User&#123;\n\t\tName: &quot;张三&quot;,\n\t\tProfile: Profile&#123;\n\t\t\tName: &quot;张三的资料&quot;,\n\t\t&#125;,\n\t\tAddresses: []Address&#123;\n\t\t\t&#123;City: &quot;北京&quot;, Country: &quot;中国&quot;&#125;,\n\t\t\t&#123;City: &quot;上海&quot;, Country: &quot;中国&quot;&#125;,\n\t\t&#125;,\n\t&#125;\n\n\tdb.Create(user)\n\n\t&#x2F;&#x2F; 查询用户、资料和地址\n\tvar u User\n\tdb.Preload(&quot;Profile&quot;).Preload(&quot;Addresses&quot;).Find(&amp;u)\n\n\tfmt.Printf(&quot;用户：%s\\n&quot;, u.Name)\n\tfmt.Printf(&quot;资料：%s\\n&quot;, u.Profile.Name)\n\tfmt.Println(&quot;地址：&quot;)\n\tfor _, address :&#x3D; range u.Addresses &#123;\n\t\tfmt.Printf(&quot;- %s, %s\\n&quot;, address.City, address.Country)\n\t&#125;\n\n\t&#x2F;&#x2F; 建立关联关系\n\tprofile :&#x3D; Profile&#123;\n\t\tName: &quot;新的资料&quot;,\n\t&#125;\n\tdb.Model(&amp;user).Association(&quot;Profile&quot;).Assign(&amp;profile)\n\n\t&#x2F;&#x2F; 清空关联关系\n\tdb.Model(&amp;user).Association(&quot;Addresses&quot;).Clear()\n\n\t&#x2F;&#x2F; 添加关联关系\n\taddress :&#x3D; Address&#123;\n\t\tCity:    &quot;广州&quot;,\n\t\tCountry: &quot;中国&quot;,\n\t&#125;\n\tdb.Model(&amp;user).Association(&quot;Addresses&quot;).Append(&amp;address)\n\n\t&#x2F;&#x2F; 删除关联关系\n\tdb.Model(&amp;user).Association(&quot;Addresses&quot;).Delete(&amp;address)\n&#125;\n\n建立关联关系 清空关联关系 对数据库有什么影响建立和清空关联关系对数据库都会产生影响，具体如下：\n建立关联关系：当我们使用 gorm 的关联 API （例如 Association）来建立两个实体之间的关联关系时，gorm 会自动在关联关系所对应的中间表中插入一些新的数据记录，这些记录描述了这两个实体之间的关联关系。这些新插入的数据会被持久化到数据库中。\n例如，当我们将一个用户实体与一个角色实体建立起多对多关联关系时，gorm 会自动在 user_roles 中间表中插入一个新的数据记录，记录描述了这个用户实体和这个角色实体之间的关联关系。\n清空关联关系：当我们使用 gorm 的关联 API（例如 Association）来清空两个实体之间的关联关系时，gorm 会自动从关联关系所对应的中间表中删除所有相关的数据记录。这些记录描述了这两个实体之间的关联关系。这些被删除的数据会被持久化到数据库中。\n例如，当我们清空一个用户实体与一个角色实体之间的多对多关联关系时，gorm 会自动从 user_roles 中间表中删除所有描述这个用户实体和这个角色实体之间关联关系的数据记录。\n上述，清空关联关系中的删除，是软删除还是物理删除上述代码中的 Clear() 操作是物理删除，即从关联表中删除所有关联的记录。如果需要使用软删除，可以使用 gorm.Model 提供的软删除机制，或者手动添加一个 deleted_at 字段，并在删除记录时将该字段赋值为当前时间戳，表示该记录已被删除，而不是从数据库中删除该记录。具体实现方式可以参考 GORM 的文档或者其他相关资料。\n实体关联https://gorm.io/zh_CN/docs/associations.html#%E6%9F%A5%E6%89%BE%E5%85%B3%E8%81%94\ndb.Model(&amp;user).Association(“Orders”).Find(&amp;orders) 与 db.Preload(“Orders”).Find(&amp;users) 的区别db.Model(&amp;user).Association(&quot;Orders&quot;).Find(&amp;orders) 和 db.Preload(&quot;Orders&quot;).Find(&amp;users) 两者的作用不同。\n\ndb.Model(&amp;user).Association(&quot;Orders&quot;).Find(&amp;orders)：是在已有用户实体的前提下，通过 Association 方法获取其 Orders 关联实体的值并填充到 &amp;orders 中。这种方法适用于已经查询出了用户实体并需要获取其关联实体的情况。\n\ndb.Preload(&quot;Orders&quot;).Find(&amp;users)：是在查询用户实体时预加载 Orders 关联实体的值，以避免在后续使用时需要执行额外的 SQL 查询。这种方法适用于需要查询用户实体和其关联实体的情况。\n\n\n总之，两种方法的区别在于是否在查询时进行预加载，以及获取关联实体的方式不同。选择哪种方法应根据具体情况而定。\n两者使用场景当你需要加载单个对象的关联数据时，可以使用 Association 方法。当你需要加载多个对象的关联数据时，可以使用 Preload 方法。\n使用 Association 方法时，需要先获取主对象的实例，并通过指定关联字段的名称来获取关联数据。这种方式更适用于当你只需要获取一个对象的关联数据时。\n而使用 Preload 方法时，你可以通过在 Find 或 First 方法中传递参数来加载多个对象的关联数据。这种方式更适用于当你需要一次性获取多个对象的关联数据时，因为它可以通过 SQL 查询语句的联接操作来一次性加载多个对象的关联数据，减少了对数据库的访问次数，提高了查询效率。但是，如果你只需要获取一个对象的关联数据时，使用 Preload 方法反而会浪费一定的资源，因为它会在查询主对象时将所有的关联数据都加载进来，而不管你是否需要。\ndb.Omit(“Languages.*“).Create(&amp;user) 与 db.Omit(“Languages”).Create(&amp;user)的区别db.Omit(&quot;Languages.*&quot;).Create(&amp;user) 和 db.Omit(&quot;Languages&quot;).Create(&amp;user) 都是使用 GORM 的 Omit 方法来指定忽略某个字段，不会将该字段的值插入数据库。\n但是两者的区别在于忽略的是整个 Languages 关联模型还是 Languages 模型的所有字段。具体来说：\n\ndb.Omit(&quot;Languages.*&quot;).Create(&amp;user) 忽略了 Languages 关联模型的所有字段，相当于没有创建 Languages 模型的记录。\ndb.Omit(&quot;Languages&quot;).Create(&amp;user) 只忽略了 Languages 模型本身的所有字段，不会影响到 Languages 关联模型的其他字段，例如在该例子中的 UserLanguages 表中的 user_id 和 language_id 字段。也就是说，执行该语句后仍然可以在 UserLanguages 表中插入对应的 user_id 和 language_id。\n\n因此，根据具体需求来选择使用哪种方式进行字段忽略。下面是一个完整的示例，展示如何使用 Omit 方法来避免 GORM 创建或更新时处理某些关联的字段：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Language struct &#123;\n\tgorm.Model\n\tName string\n&#125;\n\ntype User struct &#123;\n\tgorm.Model\n\tName      string\n\tLanguages []*Language &#96;gorm:&quot;many2many:user_languages&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 连接 SQLite 数据库\n\tdsn :&#x3D; &quot;test.db&quot;\n\tdb, err :&#x3D; gorm.Open(sqlite.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; 自动迁移表结构\n\tdb.AutoMigrate(&amp;User&#123;&#125;, &amp;Language&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建语言记录\n\tlang1 :&#x3D; &amp;Language&#123;Name: &quot;Go&quot;&#125;\n\tlang2 :&#x3D; &amp;Language&#123;Name: &quot;Python&quot;&#125;\n\tlang3 :&#x3D; &amp;Language&#123;Name: &quot;Java&quot;&#125;\n\tdb.Create(lang1, lang2, lang3)\n\n\t&#x2F;&#x2F; 创建用户并分配语言\n\tuser :&#x3D; &amp;User&#123;\n\t\tName: &quot;Alice&quot;,\n\t\tLanguages: []*Language&#123;\n\t\t\tlang1,\n\t\t\tlang2,\n\t\t&#125;,\n\t&#125;\n\tdb.Omit(&quot;Languages.*&quot;).Create(user)\n\n\t&#x2F;&#x2F; 查询用户信息\n\tvar users []User\n\tdb.Preload(&quot;Languages&quot;).Find(&amp;users)\n\tfor _, u :&#x3D; range users &#123;\n\t\tfmt.Printf(&quot;%s&#39;s languages:\\n&quot;, u.Name)\n\t\tfor _, l :&#x3D; range u.Languages &#123;\n\t\t\tfmt.Printf(&quot;- %s\\n&quot;, l.Name)\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 更新用户语言信息\n\tdb.Model(user).Association(&quot;Languages&quot;).Replace([]*Language&#123;lang3&#125;)\n\tdb.Save(user)\n\n\t&#x2F;&#x2F; 查询用户信息\n\tvar updatedUser User\n\tdb.Preload(&quot;Languages&quot;).First(&amp;updatedUser, user.ID)\n\tfmt.Printf(&quot;%s&#39;s updated languages:\\n&quot;, updatedUser.Name)\n\tfor _, l :&#x3D; range updatedUser.Languages &#123;\n\t\tfmt.Printf(&quot;- %s\\n&quot;, l.Name)\n\t&#125;\n\n\t&#x2F;&#x2F; 删除用户和语言记录\n\tdb.Unscoped().Delete(user)\n\tdb.Unscoped().Delete(lang1, lang2, lang3)\n&#125;\n\n在这个示例中，我们创建了三个 Language 记录并将它们分配给一个名为 Alice 的 User。在创建 User 记录时，我们使用 Omit 方法来忽略 Languages 关联的创建和更新。因此，即使我们没有为 User 记录分配任何语言，GORM 仍会成功创建该记录。\n在更新 User 记录时，我们使用 Association 和 Replace 方法来清空原有的语言分配并将其替换为另一个语言记录。最后，我们删除了所有的记录。\nmac 查看是否有 sqlitemacOS 系统默认是自带 SQLite 的，可以通过终端输入以下命令查看系统中是否已经安装了 SQLite：\nsqlite3 --version\n\n如果已经安装了 SQLite，则会返回安装的版本信息，否则会提示 command not found。\n查询语句查询语句是指用来从数据库中获取数据的命令。在关系型数据库中，通常使用 SQL（Structured Query Language）来编写查询语句。在 GORM 中，我们可以使用链式方法和原生 SQL 语句来构建查询。\n以下是一些 GORM 中常用的查询方法：\n\ndb.Find(&amp;result, conditions, params)：查询符合条件的所有记录，结果将保存到 result 中。\ndb.First(&amp;result, conditions, params)：查询符合条件的第一条记录，结果将保存到 result 中。\ndb.Last(&amp;result, conditions, params)：查询符合条件的最后一条记录，结果将保存到 result 中。\ndb.Where(conditions, params).Find(&amp;result)：使用指定的条件查询符合条件的所有记录，结果将保存到 result 中。\ndb.Order(order).Find(&amp;result)：按照指定的顺序查询所有记录，结果将保存到 result 中。\ndb.Limit(limit).Find(&amp;result)：限制查询结果的数量，并将结果保存到 result 中。\ndb.Offset(offset).Find(&amp;result)：设置查询的偏移量，并将结果保存到 result 中。\ndb.Select(columns).Find(&amp;result)：只查询指定的列，并将结果保存到 result 中。\ndb.Joins(joins).Find(&amp;result)：查询关联表的记录，并将结果保存到 result 中。\ndb.Raw(query, values).Scan(&amp;result)：使用原生 SQL 查询数据库，并将结果保存到 result 中。\n\n除了以上方法外，还有许多其他的查询方法。具体使用哪些方法取决于你的具体需求和业务逻辑。\ngorm polymorphicValue 使用完整示例下面是使用 GORM 实现多态关联的完整示例：\npackage main\n\nimport (\n    &quot;fmt&quot;\n\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Content struct &#123;\n    gorm.Model\n    PolymorphicValue interface&#123;&#125; &#96;gorm:&quot;polymorphic:Owner;&quot;&#96;\n&#125;\n\ntype Text struct &#123;\n    Content\n    Body string\n&#125;\n\ntype Image struct &#123;\n    Content\n    URL string\n&#125;\n\ntype Video struct &#123;\n    Content\n    URL string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n\n    db.AutoMigrate(&amp;Text&#123;&#125;, &amp;Image&#123;&#125;, &amp;Video&#123;&#125;)\n\n    text :&#x3D; Text&#123;\n        Body: &quot;Hello, world!&quot;,\n    &#125;\n\n    db.Create(&amp;text)\n\n    image :&#x3D; Image&#123;\n        URL: &quot;https:&#x2F;&#x2F;example.com&#x2F;image.png&quot;,\n    &#125;\n\n    db.Create(&amp;image)\n\n    video :&#x3D; Video&#123;\n        URL: &quot;https:&#x2F;&#x2F;example.com&#x2F;video.mp4&quot;,\n    &#125;\n\n    db.Create(&amp;video)\n\n    var content Content\n    db.First(&amp;content, 1)\n\n    switch owner :&#x3D; content.PolymorphicValue.(type) &#123;\n    case *Text:\n        fmt.Println(&quot;Text body:&quot;, owner.Body)\n    case *Image:\n        fmt.Println(&quot;Image URL:&quot;, owner.URL)\n    case *Video:\n        fmt.Println(&quot;Video URL:&quot;, owner.URL)\n    &#125;\n\n&#125;\n\n在这个例子中，我们定义了三个子模型 Text、Image 和 Video，它们都扩展了 Content 模型，并且都有一个特定的字段。Content 模型具有一个名为”PolymorphicValue”的字段，它可以存储对不同类型的实体的引用。”polymorphic”标记告诉 GORM 将”PolymorphicValue”字段用作多态关联。\n在这个例子中，我们创建了一个 Text、Image 和 Video 实例，并将它们保存到数据库中。我们然后获取了一个 Content 实例，并根据存储在”PolymorphicValue”字段中的值的类型进行不同的处理。\n这是一个简单的示例，演示了如何使用 GORM 实现多态关联。根据您的实际需求，可能需要使用更复杂的模型层次结构和多态关联来实现您的数据模型。\n上述例子的数据库结构上述示例中，使用了 GORM 提供的自动迁移功能来创建数据表，因此在运行程序时会自动创建以下数据表：\ntexts\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - body (text)\n\nimages\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - url (text)\n\nvideos\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - url (text)\n\ncontents\n  - id (integer, primary key)\n  - created_at (timestamp)\n  - updated_at (timestamp)\n  - deleted_at (timestamp)\n  - owner_type (varchar(255))\n  - owner_id (integer)\n\n在这个例子中，每个子模型(Text、Image、Video)都对应一个数据表(texts、images、videos)，同时 Content 模型对应了一个数据表(contents)。Content 模型中的”PolymorphicValue”字段会根据它所引用的实体的类型自动填充”owner_type”和”owner_id”字段，以便在查询时可以根据类型进行过滤。在本例中，”owner_type”字段的值将分别是”texts”、”images”、”videos”，而”owner_id”字段的值将分别是对应实体在其数据表中的主键。\nowner_type 的值为什么是复数的形式在 GORM 中，”owner_type”字段的值是引用的实体类型对应的数据表名称。对于大多数情况下，GORM 会默认使用引用的实体类型名称的复数形式作为对应的数据表名称。这是因为通常情况下，一个实体类型对应着多条记录，因此使用复数形式更符合数据表名称的语义。\n当然，在某些情况下，您可能需要自定义实体类型对应的数据表名称。在 GORM 中，您可以使用模型的”table name”标记来自定义数据表名称，例如：\ntype Product struct &#123;\n  gorm.Model\n  Name string\n  Price float64\n  OrderID uint\n  OrderType string\n&#125;\n\ntype Order struct &#123;\n  gorm.Model\n  Products []Product &#96;gorm:&quot;foreignKey:OrderID;polymorphic:OrderType;&quot;&#96;\n&#125;\n\nfunc (Product) TableName() string &#123;\n  return &quot;product&quot;\n&#125;\n\nfunc (Order) TableName() string &#123;\n  return &quot;order&quot;\n&#125;\n\n在上面的示例中，Product 和 Order 两个模型都通过 TableName 方法自定义了对应的数据表名称。这样，在定义多态关联时，对应的数据表名称就会变成单数形式了。所以，使用复数形式的数据表名称仅仅是 GORM 的默认行为，您可以根据需要自定义数据表名称。\npolymorphicValue 两个结构体的例子好的，以下是一个完整的例子：\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Animal struct &#123;\n    gorm.Model\n    Name       string\n    Toy        Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:animal&quot;&#96;\n&#125;\n\ntype Toy struct &#123;\n    gorm.Model\n    Name       string\n    OwnerID    int\n    OwnerType  string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n    &#x2F;&#x2F; 自动迁移\n    db.AutoMigrate(&amp;Animal&#123;&#125;, &amp;Toy&#123;&#125;)\n\n    dog :&#x3D; Animal&#123;Name: &quot;Dog&quot;&#125;\n    db.Create(&amp;dog)\n    toy1 :&#x3D; Toy&#123;Name: &quot;Bone&quot;, OwnerID: int(dog.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy1)\n\n    cat :&#x3D; Animal&#123;Name: &quot;Cat&quot;&#125;\n    db.Create(&amp;cat)\n    toy2 :&#x3D; Toy&#123;Name: &quot;Mouse&quot;, OwnerID: int(cat.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy2)\n\n    var toys []Toy\n    db.Preload(&quot;Owner&quot;).Find(&amp;toys)\n\n    for _, toy :&#x3D; range toys &#123;\n        fmt.Printf(&quot;Toy name: %s, Owner name: %s\\n&quot;, toy.Name, toy.Owner.Name)\n    &#125;\n&#125;\n\n这个例子中定义了两个 GORM 模型，Animal 和 Toy。Animal 模型中定义了一个 Toy 类型的字段，用于表示动物玩具的信息。在这个字段的 tag 中，使用了”polymorphic”标记来定义多态关联，并指定了”Owner”作为关联的字段名称。这样，当 Animal 模型与 Toy 模型关联时，GORM 将会将 Animal 的 ID 值赋值给 Toy 模型中的 OwnerID 字段，并将”animal”字符串赋值给 Toy 模型中的 OwnerType 字段。\n另外，在”polymorphic”标记的基础上，还使用了”polymorphicValue”标记来指定 OwnerType 字段中的值。具体来说，当 Animal 模型与 Toy 模型关联时，OwnerType 字段中的值将会被设置为”animal”。这个值用来表示动物玩具的所有者是一只动物。如果存在其他的所有者类型，例如”human”，那么它们的 OwnerType 值就可以分别设置为”human”。\n最终，在 main 函数中，我们使用 GORM 创建了两个 Animal 对象（分别代表一只狗和一只猫），并创建了两个 Toy 对象（分别代表狗和猫的玩具）。然后，我们使用 GORM 的 Preload 方法来加载 Toy 对象的 Owner 字段，以便在输出 Toy 信息时，能够同时输出它们的所有者信息。\n最终的输出结果如下：\nToy name: Bone, Owner name: Dog\nToy name: Mouse, Owner name: Cat\n\n可以看到，程序成功地创建了 Animal 和 Toy 对象，并建立了它们之间的多态关联。同时，在输出 Toy 信息时，也成功地输出了它\npolymorphicValue 三个结构体的例子如果需要实现三个结构体之间的多态关联，可以按照以下步骤进行操作：\n\n在 GORM 模型中定义多态关联的字段，例如定义一个 Owner 字段；\n在 Owner 字段的 tag 中，使用”polymorphic”标记来定义多态关联，并指定关联的字段名称，例如”Owner”；\n在 Owner 字段的 tag 中，使用”polymorphicValue”标记来指定 OwnerType 字段中的值；\n在其他两个模型中分别定义一个 HasMany 类型的字段，用于保存多态关联的信息；\n在其他两个模型的 HasMany 字段的 tag 中，使用”polymorphic”标记来定义多态关联，并指定关联的字段名称，例如”Owner”；\n在其他两个模型的 HasMany 字段的 tag 中，使用”polymorphicValue”标记来指定 OwnerType 字段中的值；\n在代码中创建和查询这三个模型时，根据需要使用 GORM 的 Preload 方法来加载关联信息。\n\n下面是一个具有三个模型之间多态关联的完整例子：\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Animal struct &#123;\n    gorm.Model\n    Name       string\n    Toys       []Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:animal&quot;&#96;\n&#125;\n\ntype Human struct &#123;\n    gorm.Model\n    Name       string\n    Toys       []Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:human&quot;&#96;\n&#125;\n\ntype Toy struct &#123;\n    gorm.Model\n    Name       string\n    OwnerID    int\n    OwnerType  string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(&quot;failed to connect database&quot;)\n    &#125;\n    &#x2F;&#x2F; 自动迁移\n    db.AutoMigrate(&amp;Animal&#123;&#125;, &amp;Human&#123;&#125;, &amp;Toy&#123;&#125;)\n&#x2F;&#x2F; 创建-&gt;返回id-&gt;拼接toy数据-&gt;保存数据库\n    dog :&#x3D; Animal&#123;Name: &quot;Dog&quot;&#125;\n    db.Create(&amp;dog)\n    toy1 :&#x3D; Toy&#123;Name: &quot;Bone&quot;, OwnerID: int(dog.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy1)\n\n    cat :&#x3D; Animal&#123;Name: &quot;Cat&quot;&#125;\n    db.Create(&amp;cat)\n    toy2 :&#x3D; Toy&#123;Name: &quot;Mouse&quot;, OwnerID: int(cat.ID), OwnerType: &quot;animal&quot;&#125;\n    db.Create(&amp;toy2)\n\n    person :&#x3D; Human&#123;Name: &quot;John&quot;&#125;\n    db.Create(&amp;person)\n    toy3 :&#x3D; Toy&#123;Name: &quot;Car&quot;, OwnerID: int(person.ID), OwnerType: &quot;human&quot;&#125;\n    db.Create(&amp;toy3)\n\n    var animals []Animal\n    db.Preload(&quot;Toys&quot;).Find(&amp;animals)\n    for _, animal :&#x3D; range animals &#123;\n        for _, toy :&#x3D; range animal.Toys &#123;\n            fmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, animal.Name, toy.Name)\n        &#125;\n    &#125;\n\n    var humans []Human\n    db.Preload(&quot;Toys&quot;).Find(&amp;humans)\n    for _, human :&#x3D; range humans &#123;\n        for _, toy :&#x3D; range human.Toys &#123;\n            fmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, human.Name, toy.Name)\n        &#125;\n    &#125;\n&#125;\n\n在这个例子中，我们定义了三个 GORM 模型：Animal、Human 和 Toy。其中 Animal 和 Human 模型都具有多个 Toy，而 Toy 模型保存了所有的多态关联信息。Animal 和 Human 模型的 Toy 字段的 tag 中都使用了”polymorphic”标记来定义多态关联，并指定了 Owner 字段作为关联字段，同时使用了”polymorphicValue”标记来指定 OwnerType 字段的值。\n在代码中，我们创建了一些 Animal、Human 和 Toy 的实例，并使用 GORM 的 Create 方法将它们保存到数据库中。然后使用 GORM 的 Preload 方法来加载所有 Animal 和 Human 实例及它们的 Toy。\n最后，我们遍历加载的 Animal 和 Human 实例，并输出每个实例的名称以及它们的 Toy 的名称。注意，这里我们使用了嵌套循环来遍历 Animal 和 Human 的 Toys，这样就可以遍历所有的多态关联信息。\n当我们运行这个程序时，输出结果如下：\nDog&#39;s toy name: Bone\nCat&#39;s toy name: Mouse\nJohn&#39;s toy name: Car\n\n这表明我们成功地实现了 Animal、Human 和 Toy 之间的多态关联。\n简化后的代码好的，这里是一个简化后的示例代码：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype Animal struct &#123;\n\tID   uint\n\tName string\n\tToy  Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:animal&quot;&#96;\n&#125;\n\ntype Human struct &#123;\n\tID   uint\n\tName string\n\tToy  Toy &#96;gorm:&quot;polymorphic:Owner;polymorphicValue:human&quot;&#96;\n&#125;\n\ntype Toy struct &#123;\n\tID        uint\n\tName      string\n\tOwnerID   uint\n\tOwnerType string\n&#125;\n\nfunc main() &#123;\n\tdb, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\tdb.AutoMigrate(&amp;Animal&#123;&#125;, &amp;Human&#123;&#125;, &amp;Toy&#123;&#125;)\n&#x2F;&#x2F; 这里直接将数据，完整化成一个Animal&#x2F;Human数据结构，创建时候，自动生成Toy数据\n\tdog :&#x3D; Animal&#123;Name: &quot;Dog&quot;, Toy: Toy&#123;Name: &quot;Bone&quot;&#125;&#125;\n\tcat :&#x3D; Animal&#123;Name: &quot;Cat&quot;, Toy: Toy&#123;Name: &quot;Mouse&quot;&#125;&#125;\n\tjohn :&#x3D; Human&#123;Name: &quot;John&quot;, Toy: Toy&#123;Name: &quot;Car&quot;&#125;&#125;\n\n\tdb.Create(&amp;dog)\n\tdb.Create(&amp;cat)\n\tdb.Create(&amp;john)\n\n\tvar animals []Animal\n\tdb.Preload(&quot;Toy&quot;).Find(&amp;animals)\n\n\tfor _, animal :&#x3D; range animals &#123;\n\t\tfmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, animal.Name, animal.Toy.Name)\n\t&#125;\n\n\tvar humans []Human\n\tdb.Preload(&quot;Toy&quot;).Find(&amp;humans)\n\n\tfor _, human :&#x3D; range humans &#123;\n\t\tfmt.Printf(&quot;%s&#39;s toy name: %s\\n&quot;, human.Name, human.Toy.Name)\n\t&#125;\n&#125;\n\n这个简化版本的代码与之前的示例类似，只是使用了 uint 类型的 ID，并将 Animal 和 Human 的 Toy 字段的类型都改为了 Toy。此外，这个版本还省略了模型定义和数据库表结构的信息，只包含了必要的字段和标记。\n这个简化版代码的运行结果与之前的示例相同：\nDog&#39;s toy name: Bone\nCat&#39;s toy name: Mouse\nJohn&#39;s toy name: Car\n\n自引用 Has One 如何理解自引用 Has One 是指在一个模型中定义一个与该模型自身相同类型的 Has One 关联关系。这种关联关系可以用来表示一个模型具有与之相关联的另一个模型，而该关联模型本身也具有与之相关联的另一个模型，因此形成了一个自我引用的关系。\n例如，我们可以考虑一个 Employee 模型，每个 Employee 模型都可能有一个 Manager 模型与之相关联。而每个 Manager 模型本身也可能有一个 Manager 模型与之相关联，因为一个 Manager 可能受另一个 Manager 管理。\n在 GORM 中，我们可以通过在模型中定义一个与该模型自身相同类型的 Has One 关联关系来实现自引用 Has One。我们可以使用 foreignkey 和 references 标记来指定关联关系的外键和引用的主键，以及使用 polymorphic 标记来支持多态关联。\n以下是一个 Employee 模型的示例代码，其中包括了一个与该模型自身相同类型的 Has One 关联关系：\ntype Employee struct &#123;\n  ID         uint\n  Name       string\n  ManagerID  *uint\n  Manager    *Employee &#96;gorm:&quot;foreignKey:ManagerID;references:ID&quot;&#96;\n&#125;\n\n在这个示例代码中，Employee 模型包含了一个 ManagerID 字段和一个指向 Manager 模型的指针类型的 Manager 字段。我们使用了 foreignKey 和 references 标记来指定 ManagerID 字段作为外键，并引用了 Employee 模型的 ID 主键。这样，每个 Employee 模型都可以与一个其他 Employee 模型相关联，形成自引用的 Has One 关联关系。\n当我们使用 GORM 创建和查询 Employee 模型时，GORM 会自动处理自引用 Has One 关联关系，并使用 JOIN 操作来加载相关联的 Manager 模型。\n例如，我们可以使用以下代码创建两个 Employee 模型，并将其中一个模型的 Manager 字段设置为另一个模型：\ndb.Create(&amp;Employee&#123;Name: &quot;Alice&quot;&#125;)\ndb.Create(&amp;Employee&#123;Name: &quot;Bob&quot;, ManagerID: &amp;[]uint&#123;1&#125;[0]&#125;)\n\n这个代码会将两个 Employee 模型保存到数据库中，其中一个模型的 Manager 字段会指向另一个模型。然后我们可以使用以下代码查询所有 Employee 模型，以及每个模型的名称和 Manager 名称：\nvar employees []Employee\ndb.Preload(&quot;Manager&quot;).Find(&amp;employees)\nfor _, employee :&#x3D; range employees &#123;\n  fmt.Printf(&quot;%s&#39;s manager: %v\\n&quot;, employee.Name, employee.Manager)\n&#125;\n\n这个代码会输出以下内容：\nAlice&#39;s manager: &lt;nil&gt;\nBob&#39;s manager: &amp;&#123;1 Alice 0xc000106320&#125;\n\n这表明我们成功地创建了两个 Employee 模型，并将其中一个模型的 Manager 字段设置为另一个模型，从而实现了自引用 Has One 关联关系。\n上面为什么使用指针类型在 GORM 中，如果我们想要定义一个与该模型自身相同类型的关联关系，通常需要使用指针类型。这是因为在关联模型中，我们通常需要引用到该模型自身的实例，而如果使用非指针类型，会导致循环依赖和递归引用的问题，进而导致程序崩溃。\n在自引用 Has One 中，我们通常使用指针类型来定义模型的关联字段，以避免这些问题。例如，在 Employee 模型中，我们使用了 ManagerID 字段和 Manager 字段来表示每个员工的上级领导。Manager 字段的类型为 *Employee，这意味着它是一个指向另一个 Employee 实例的指针类型。\n通过使用指针类型，我们可以避免循环依赖和递归引用的问题，并让 GORM 能够正确地处理关联关系。当我们查询一个 Employee 实例时，GORM 会自动加载与之相关联的 Manager 实例，以及与之相关联的 Manager 实例的 Manager 实例，以此类推，直到所有的关联关系都被加载完毕。\n总之，在 GORM 中，为了避免循环依赖和递归引用的问题，并正确地处理与该模型自身相同类型的关联关系，我们通常需要使用指针类型来定义关联字段。这适用于所有类型的关联关系，包括自引用 Has One。\n为什么指针引用可以避免 循环依赖和递归引用的问题指针引用可以避免循环依赖和递归引用的问题，是因为指针允许我们将一个类型的实例作为另一个类型的属性引用，而不是直接包含该类型的实例。这种方式可以避免出现嵌套的实例，进而避免循环依赖和递归引用的问题。\n假设我们有两个结构体类型 A 和 B，它们都有一个属性字段 a 和 b，分别指向对方的实例。如果我们使用非指针类型定义这两个结构体，那么在编译时就会发生错误，因为定义中存在循环依赖：\ntype A struct &#123;\n    a B\n&#125;\n\ntype B struct &#123;\n    b A\n&#125;\n\n相反，如果我们使用指针类型来定义这两个结构体，那么这个问题就可以得到解决：\ntype A struct &#123;\n    a *B\n&#125;\n\ntype B struct &#123;\n    b *A\n&#125;\n\n这种方式下，a 和 b 不再是实例，而是指向另一个类型的实例的指针。这样，我们就可以避免出现嵌套的实例，进而避免循环依赖和递归引用的问题。\n在 GORM 中，我们使用指针类型来定义自引用 Has One 的关联字段，以避免这些问题。例如，在 Employee 模型中，我们使用 ManagerID 字段和 Manager 字段来表示每个员工的上级领导。Manager 字段的类型为 *Employee，这意味着它是一个指向另一个 Employee 实例的指针类型。通过使用指针类型，我们可以避免循环依赖和递归引用的问题，并让 GORM 能够正确地处理关联关系。\n什么时候用指针类型，什么时候用实例在定义 GORM 模型的时候，我们应该根据具体的情况选择使用指针类型或实例类型。\n通常情况下，我们使用指针类型来定义关联关系字段，以避免循环依赖和递归引用的问题，同时也可以更好地处理关联关系。例如，如果一个员工有一个上级领导，我们可以使用 Manager 字段来表示这个关系：\ntype Employee struct &#123;\n    ID         uint\n    Name       string\n    ManagerID  uint\n    Manager    *Employee\n&#125;\n\n在这个例子中，Manager 字段的类型为 *Employee，表示这是一个指向另一个 Employee 实例的指针类型。这样，我们可以避免循环依赖和递归引用的问题，同时也可以让 GORM 能够正确地处理关联关系。\n然而，在某些情况下，我们可能需要使用实例类型来定义关联关系字段。例如，如果我们需要表示一个关联到多个 OrderItem 的 Order，我们可以使用 Items 字段来表示这个关系：\ntype Order struct &#123;\n    ID         uint\n    Name       string\n    Items      []OrderItem\n&#125;\n\ntype OrderItem struct &#123;\n    ID         uint\n    Name       string\n    OrderID    uint\n&#125;\n\n在这个例子中，Items 字段的类型为 []OrderItem，表示这是一个包含多个 OrderItem 实例的切片类型。由于一个 Order 可能关联到多个 OrderItem，所以我们需要使用实例类型来表示这个关系。\n总之，我们应该根据具体的情况选择使用指针类型或实例类型来定义 GORM 模型的关联关系字段。\n\n如果一个实例可能关联到多个实例，那么我们应该使用实例类型；\n如果一个实例只会关联到一个实例，或者存在循环依赖和递归引用的问题，那么我们应该使用指针类型。\n\n指针和实例的区别在 GORM 模型中，指针和实例都可以用来表示模型之间的关联关系。\n\n指针通常用于表示一对一或一对多的关系，\n而实例通常用于表示多对一或多对多的关系。\n\n指针类型在 GORM 模型中的用法如下：\ntype User struct &#123;\n    ID    uint\n    Name  string\n    Email string\n&#125;\n\ntype Post struct &#123;\n    ID       uint\n    Title    string\n    Content  string\n    UserID   uint\n    User     *User &#x2F;&#x2F; 指向 User 实例的指针类型\n&#125;\n\n在这个例子中，Post 模型包含一个指向 User 实例的指针类型字段 User，表示一个 Post 对象对应一个 User 对象。\n实例类型在 GORM 模型中的用法如下：\ntype User struct &#123;\n    ID       uint\n    Name     string\n    Email    string\n    Articles []Article &#x2F;&#x2F; 包含多个 Article 实例的切片类型\n&#125;\n\ntype Article struct &#123;\n    ID        uint\n    Title     string\n    Content   string\n    UserID    uint\n    User      User &#x2F;&#x2F; 关联到 User 实例\n&#125;\n\n在这个例子中，User 模型包含一个包含多个 Article 实例的切片类型字段 Articles，表示一个 User 对象关联到多个 Article 对象。而 Article 模型包含一个关联到 User 实例的实例类型字段 User，表示一个 Article 对象对应一个 User 对象。\n在使用指针和实例类型时，我们需要根据具体的场景来选择。通常来说，如果一个模型关联到多个实例，我们应该使用实例类型；如果一个模型只会关联到一个实例，或者存在循环依赖和递归引用的问题，我们应该使用指针类型。此外，我们还需要注意在使用指针类型时避免空指针错误的问题。\n如何避免空指针错误\n在创建模型实例时，为指针类型字段分配内存空间。\n在读取数据时，判断指针类型字段是否为空。\n在更新数据时，使用 Update 方法更新非空字段。\n\n在 GORM 模型中使用指针类型时，由于指针类型字段可能为空，所以需要注意避免空指针错误的问题。下面是一些避免空指针错误的建议：\n\n在创建模型实例时，为指针类型字段分配内存空间。\n\nuser :&#x3D; &amp;User&#123;Name: &quot;Alice&quot;&#125;\npost :&#x3D; &amp;Post&#123;Title: &quot;Hello&quot;, Content: &quot;World&quot;, User: user&#125;\n\n在这个例子中，我们在创建 post 实例时为 User 字段分配了内存空间，避免了空指针错误的问题。\n\n在读取数据时，判断指针类型字段是否为空。\n\nvar post Post\nif err :&#x3D; db.Preload(&quot;User&quot;).First(&amp;post, 1).Error; err !&#x3D; nil &#123;\n    if errors.Is(err, gorm.ErrRecordNotFound) &#123;\n        &#x2F;&#x2F; 处理记录不存在的情况\n    &#125; else &#123;\n        &#x2F;&#x2F; 处理其他错误\n    &#125;\n&#125; else &#123;\n    if post.User !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理 User 不为空的情况\n    &#125;\n&#125;\n\n在这个例子中，我们在读取 post 实例时，使用 Preload 方法预加载 User 字段，然后在判断 post.User 是否为空时进行了特判，避免了空指针错误的问题。\n\n在更新数据时，使用 Update 方法更新非空字段。\n\nvar post Post\nif err :&#x3D; db.First(&amp;post, 1).Error; err !&#x3D; nil &#123;\n    &#x2F;&#x2F; 处理错误\n&#125; else &#123;\n    if post.User !&#x3D; nil &#123;\n        if err :&#x3D; db.Model(&amp;post).Update(&quot;Title&quot;, &quot;New Title&quot;, &quot;User&quot;, post.User).Error; err !&#x3D; nil &#123;\n            &#x2F;&#x2F; 处理错误\n        &#125;\n    &#125; else &#123;\n        if err :&#x3D; db.Model(&amp;post).Update(&quot;Title&quot;, &quot;New Title&quot;).Error; err !&#x3D; nil &#123;\n            &#x2F;&#x2F; 处理错误\n        &#125;\n    &#125;\n&#125;\n\n在这个例子中，我们在更新 post 实例时，先判断 post.User 是否为空，然后根据情况使用 Update 方法更新相应的字段，避免了空指针错误的问题。\n总的来说，避免空指针错误需要根据具体的场景进行处理，需要注意细节问题。\n什么是外键约束，有什么用外键约束（Foreign Key Constraint）是一种数据库中的约束条件，用于保证表与表之间的数据完整性。\n具体来说，外键约束可以用于定义两个表之间的关系，使得一个表的某个字段值必须是另一个表的某个字段的值。这样，当我们在更新或删除一个表的记录时，数据库系统会自动检查该记录是否与其他表有关联，如果有，则会自动更新或删除其他表的相应记录，以保证数据完整性。\n例如，我们可以定义一个 orders 表和一个 customers 表，用于存储订单和客户信息。为了保证数据完整性，我们可以在 orders 表中定义一个外键约束，将 customer_id 字段作为外键，关联到 customers 表的 id 字段上。\nCREATE TABLE customers (\n    id INT PRIMARY KEY,\n    name VARCHAR(255)\n);\n\nCREATE TABLE orders (\n    id INT PRIMARY KEY,\n    customer_id INT,\n    order_date DATE,\n    FOREIGN KEY (customer_id) REFERENCES customers(id)\n);\n\n在这个例子中，我们定义了一个 orders 表和一个 customers 表，其中 orders 表中的 customer_id 字段作为外键，关联到 customers 表的 id 字段上。\n这样，在插入或更新 orders 表的数据时，数据库系统会自动检查 customer_id 字段的值是否存在于 customers 表中，如果不存在，则会抛出错误。\n外键约束可以保证数据的完整性和一致性，但是在使用时需要注意几点：\n\n外键约束可能会降低数据库的性能，因为数据库系统需要进行额外的检查和操作。\n\n外键约束可能会限制数据库的灵活性，因为数据库系统会强制执行特定的数据关系。\n\n外键约束需要在设计数据库时谨慎使用，需要考虑业务需求和实际情况。\n\n\ngorm 外键约束有哪些，各有什么用，举例子说明GORM 中常用的外键约束有以下几种：\n\nForeignKeyConstraint：用于定义外键约束，并指定关联的表、字段以及操作。\n\nOnDelete：用于指定删除记录时的行为，包括 CASCADE（级联删除）、SET NULL（置空）等。\n\nOnUpdate：用于指定更新记录时的行为，包括 CASCADE（级联更新）、SET NULL（置空）等。\n\n\n下面是各种外键约束的详细说明及示例：\n\nForeignKeyConstraint：用于定义外键约束，并指定关联的表、字段以及操作。例如：\n\ntype Order struct &#123;\n    ID          int\n    CustomerID  int\n    Customer    Customer &#96;gorm:&quot;foreignKey:CustomerID;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;&quot;&#96;\n&#125;\n\ntype Customer struct &#123;\n    ID      int\n    Name    string\n&#125;\n\n在这个例子中，我们定义了一个 Order 模型和一个 Customer 模型，其中 Order 模型中的 CustomerID 字段作为外键，关联到 Customer 模型的 ID 字段上。同时，我们使用 gorm:&quot;foreignKey&quot; 标签定义了外键约束，并指定了 OnUpdate 和 OnDelete 的行为。在这个例子中，当 Customer 表中的记录被更新时，与之关联的 Order 表中的 CustomerID 字段也会被更新，同时，当 Customer 表中的记录被删除时，与之关联的 Order 表中的 CustomerID 字段会被置空。\n\nOnDelete：用于指定删除记录时的行为，包括 CASCADE（级联删除）、SET NULL（置空）等。例如：\n\ntype Order struct &#123;\n    ID          int\n    CustomerID  int\n    Customer    Customer &#96;gorm:&quot;foreignKey:CustomerID;&quot;&#96;\n&#125;\n\ntype Customer struct &#123;\n    ID      int\n    Name    string\n&#125;\n\ndb.Model(&amp;Order&#123;&#125;).AddForeignKey(&quot;customer_id&quot;, &quot;customers(id)&quot;, &quot;SET NULL&quot;, &quot;CASCADE&quot;)\n\n在这个例子中，我们使用 AddForeignKey 方法添加了一个外键约束，指定了删除记录时的行为为 SET NULL。这意味着，当 customers 表中的某个记录被删除时，与之关联的 orders 表中的 customer_id 字段会被置空。\n\nOnUpdate：用于指定更新记录时的行为，包括 CASCADE（级联更新）、SET NULL（置空）等。例如：\n\ntype Order struct &#123;\n    ID          int\n    CustomerID  int\n    Customer    Customer &#96;gorm:&quot;foreignKey:CustomerID;&quot;&#96;\n&#125;\n\ntype Customer struct &#123;\n    ID      int\n    Name    string\n&#125;\n\ndb.Model(&amp;Order&#123;&#125;).AddForeignKey(&quot;customer_id&quot;, &quot;customers(id)&quot;, &quot;CASCADE&quot;, &quot;SET NULL&quot;)\n\n在这个例子中，我们使用 AddForeignKey 方法添加了一个外键约束，指定了更新记录时的行为为 CASCADE。这 4. 外键约束 - RESTRICT\n当有一个外键约束指定为 RESTRICT 时，当主表中的某一行被删除或更新时，只有在从表中没有相应的引用时才能执行这个操作。如果在从表中有相应的引用，则会抛出一个错误。\n使用 RESTRICT 可以保证在主表中的某一行被删除或更新之前，需要确保在从表中没有相应的引用。这有助于保持数据的完整性。\n例如，我们有一个商店应用，其中有一个 product 表和一个 order 表，每个订单都需要引用产品表中的一个产品，我们可以在 order 表中创建一个外键，指向 product 表中的 id 字段，并将这个外键指定为 RESTRICT，这样就可以确保在删除或更新产品之前，所有订单都已经完成或取消。\n\n外键约束 - SET NULL\n\n当有一个外键约束指定为 SET NULL 时，当主表中的某一行被删除或更新时，所有从表中的相应外键都会被设置为 NULL。\n使用 SET NULL 可以保证在主表中的某一行被删除或更新之后，从表中的相应外键不再引用一个不存在的主键。\n例如，我们有一个博客应用，其中有一个 post 表和一个 comment 表，每个评论都需要引用 post 表中的一个文章，我们可以在 comment 表中创建一个外键，指向 post 表中的 id 字段，并将这个外键指定为 SET NULL，这样就可以确保在删除或更新文章之后，所有评论都不再引用一个不存在的文章。\n\n外键约束 - SET DEFAULT\n\n当有一个外键约束指定为 SET DEFAULT 时，当主表中的某一行被删除或更新时，所有从表中的相应外键都会被设置为默认值。\n使用 SET DEFAULT 可以保证在主表中的某一行被删除或更新之后，从表中的相应外键都有一个默认值。\n例如，我们有一个用户应用，其中有一个 user 表和一个 post 表，每个文章都需要引用 user 表中的一个用户，我们可以在 post 表中创建一个外键，指向 user 表中的 id 字段，并将这个外键指定为 SET DEFAULT，这样就可以确保在删除或更新用户之后，所有文章都有一个默认的用户。\n\n外键约束 - NO ACTION\n\n当有一个外键约束指定为 NO ACTION 时，当主表中的某一行被删除或更新时，所有从表中的相应外键不受影响。\n使用 NO ACTION 可以保证在主表中的某一行被删除或更新之后，从表中的相应外键不会受到影响。但是这也意味着可能会存在从表中的外键引用一个不存在的主键或者引用一个已经被更新或删除的主键。\n需要注意的是，使用\n在 GORM 中，还有一种外键约束是 OnUpdate 和 OnDelete，它们用于定义当关联的主表数据被修改或删除时，关联的从表数据应该如何处理。\n常见的几种处理方式如下：\n\nRESTRICT：当关联的主表数据被修改或删除时，抛出一个错误，防止此操作发生。这是默认的行为。\nCASCADE：当关联的主表数据被修改或删除时，同时修改或删除关联的从表数据。\nSET NULL：当关联的主表数据被修改或删除时，将关联的从表数据的外键列设置为 NULL。\nNO ACTION：与 RESTRICT 类似，不执行任何操作，但不会抛出错误。\n\n以下是一个示例：\ntype User struct &#123;\n  ID   int\n  Name string\n\n  &#x2F;&#x2F; 声明一个 has-many 关系，一个用户可以有多篇文章\n  Articles []Article &#96;gorm:&quot;foreignKey:UserID;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;&quot;&#96;\n&#125;\n\ntype Article struct &#123;\n  ID     int\n  Title  string\n  Body   string\n  UserID int     &#x2F;&#x2F; 声明一个外键，指向 User 的 ID 字段\n  User   *User   &#x2F;&#x2F; 声明一个 belongs-to 关系，一篇文章只能属于一个用户\n&#125;\n\n在上述示例中，我们定义了一个 has-many 的关系，即一个用户可以有多篇文章，同时声明了 OnUpdate:CASCADE,OnDelete:SET NULL 外键约束。这意味着当用户被更新时，所有与之相关的文章的外键 UserID 将被更新为 NULL，当用户被删除时，与之相关的文章将被删除。\n\n\n\n\n\n\n\nWARNING\n需要注意的是，在 GORM v2.0 版本中，外键约束的声明方式发生了变化，使用 constraint 标签来声明，而不是之前的 ForeignKey。\n\n时间戳完整代码示例以下是一个完整的示例代码，展示如何使用 GORM 存储时间戳和将时间戳转换为 time.Time 对象，以及将 time.Time 对象转换为毫秒级别的 Unix 时间戳。\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n\t&quot;gorm.io&#x2F;gorm&#x2F;logger&quot;\n)\n\ntype User struct &#123;\n\tID        uint\n\tName      string\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 初始化 GORM 连接\n\tdsn :&#x3D; &quot;test.db&quot;\n\tdb, err :&#x3D; gorm.Open(sqlite.Open(dsn), &amp;gorm.Config&#123;\n\t\tLogger: logger.Default.LogMode(logger.Info),\n\t&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; 迁移数据表结构\n\tdb.AutoMigrate(&amp;User&#123;&#125;)\n\n\t&#x2F;&#x2F; 创建新用户\n\tuser :&#x3D; User&#123;Name: &quot;John Doe&quot;&#125;\n\tdb.Create(&amp;user)\n\n\t&#x2F;&#x2F; 查询用户\n\tvar savedUser User\n\tdb.First(&amp;savedUser, user.ID)\n\n\t&#x2F;&#x2F; 输出时间戳和时间对象\n\tfmt.Printf(&quot;User %d was created at time %v and updated at time %v\\n&quot;, savedUser.ID, savedUser.CreatedAt, savedUser.UpdatedAt)\n\n\t&#x2F;&#x2F; 输出时间戳（秒级别）\n\tfmt.Printf(&quot;User %d was created at timestamp %d and updated at timestamp %d\\n&quot;, savedUser.ID, savedUser.CreatedAt.Unix(), savedUser.UpdatedAt.Unix())\n\n\t&#x2F;&#x2F; 输出时间戳（毫秒级别）\n\tfmt.Printf(&quot;User %d was created at timestamp %d and updated at timestamp %d\\n&quot;, savedUser.ID, savedUser.CreatedAt.UnixMilli(), savedUser.UpdatedAt.UnixMilli())\n&#125;\n\n这个例子中，我们定义了一个 User 结构体，其中包含 CreatedAt 和 UpdatedAt 两个字段，它们的类型均为 time.Time。在使用 GORM 操作这个结构体时，GORM 会自动将这些字段转换为数据库中的时间戳格式进行存储，而在查询时，GORM 也会自动将数据库中的时间戳转换为 time.Time 对象。\n在上面的例子中，我们创建了一个新用户，并将其保存到数据库中。然后我们使用 First() 方法查询数据库中保存的用户，并输出其创建时间和更新时间。接着我们使用 Unix() 和 UnixMilli() 方法分别将时间对象转换为秒级别和毫秒级别的 Unix 时间戳，并输出它们的值。\n这里需要注意的是，在将 time.Time 对象转换为 Unix 时间戳时，需要使用 Unix() 或 UnixMilli() 方法。其中，Unix() 方法返回的是秒级别的 Unix 时间戳，而 UnixMilli() 方法返回的是毫秒级别的 Unix 时间戳。\n上述代码表结构和结果表结构：\nCREATE TABLE &#96;users&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) NOT NULL,\n  &#96;created_at&#96; datetime NOT NULL,\n  &#96;updated_at&#96; datetime NOT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci\n\n结果：\n[&#123;1 John 1641062400000 1641062400000&#125; &#123;2 Jane 1641066000000 1641066000000&#125;]\n\n其中，第一个用户的 created_at 和 updated_at 时间戳分别为 1641062400000（2022-01-02 00:00:00）和 1641062400000（2022-01-02 00:00:00），第二个用户的 created_at 和 updated_at 时间戳分别为 1641066000000（2022-01-02 01:00:00）和 1641066000000（2022-01-02 01:00:00）。\nclause.Associations下面是一个使用 clause.Associations 的完整示例，用于加载 User 对象及其关联的 Order 和 OrderItem 对象：\npackage main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;gorm.io&#x2F;gorm&#x2F;clause&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Orders []Order &#96;gorm:&quot;foreignKey:UserID&quot;&#96;\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID     uint\n    OrderItems []OrderItem &#96;gorm:&quot;foreignKey:OrderID&quot;&#96;\n&#125;\n\ntype OrderItem struct &#123;\n    gorm.Model\n    OrderID     uint\n    ProductName string\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 创建 SQLite 数据库连接\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 自动迁移数据库表结构\n    err &#x3D; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;, &amp;OrderItem&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 创建测试数据\n    orderItems :&#x3D; []OrderItem&#123;\n        &#123;ProductName: &quot;Product A&quot;&#125;,\n        &#123;ProductName: &quot;Product B&quot;&#125;,\n    &#125;\n    orders :&#x3D; []Order&#123;\n        &#123;OrderItems: orderItems&#125;,\n        &#123;OrderItems: orderItems&#125;,\n    &#125;\n    users :&#x3D; []User&#123;\n        &#123;Name: &quot;User A&quot;, Orders: orders&#125;,\n        &#123;Name: &quot;User B&quot;, Orders: orders&#125;,\n    &#125;\n    err &#x3D; db.Create(&amp;users).Error\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 查询所有用户及其关联的订单和订单项\n    var loadedUsers []User\n    err &#x3D; db.Preload(clause.Associations).Find(&amp;loadedUsers).Error\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    &#x2F;&#x2F; 打印查询结果\n    for _, user :&#x3D; range loadedUsers &#123;\n        println(&quot;User:&quot;, user.ID, user.Name)\n        for _, order :&#x3D; range user.Orders &#123;\n            println(&quot;\\tOrder:&quot;, order.ID, order.UserID)\n            for _, orderItem :&#x3D; range order.OrderItems &#123;\n                println(&quot;\\t\\tOrderItem:&quot;, orderItem.ID, orderItem.OrderID, orderItem.ProductName)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n在上述示例中，我们创建了一个 User 模型和一个 Order 模型，Order 模型有多个 OrderItem 模型。我们在 User 模型上定义了一个 Orders 字段，它表示一个用户可能有多个订单，而在 Order 模型上定义了一个 OrderItems 字段，它表示一个订单可能包含多个订单项。\n我们通过 db.Preload(clause.Associations) 来加载所有关联的订单和订单项。在查询结果中，我们可以看到每个用户及其关联的订单和订单项。\nclause.Associations 还是没有理解clause.Associations 实际上是一个 gorm.Associations 类型的常量，用于指示预加载操作要预加载哪些关联关系。\n在 GORM 中，一个模型可以与其他模型建立多种关联关系，例如一对多、多对多、多态等等。当我们查询一个模型时，通常也需要把相关联的模型数据一起查询出来，这就需要用到预加载功能。\n在使用预加载功能时，我们可以使用 Preload 方法来指定要预加载哪些关联关系。clause.Associations 就是其中一种指定方式。\n当我们使用 db.Preload(clause.Associations).Find(&amp;users) 方法时，GORM 会自动解析 User 模型定义中的所有关联关系，并将其包装在一个 gorm.Associations 类型的列表中，然后将这个列表传递给 Preload 方法。\n使用 clause.Associations 的好处是，它能够避免手动编写字符串形式的关联关系名称，从而减少人为出错的可能性。另外，当模型的关联关系发生变化时，使用 clause.Associations 可以自动地更新预加载的关联关系，而不需要手动修改代码。\nEmbedded Preloading以下是一个使用 Embedded Preloading 的完整代码示例：\npackage main\n\nimport (\n    &quot;gorm.io&#x2F;driver&#x2F;sqlite&quot;\n    &quot;gorm.io&#x2F;gorm&quot;\n    &quot;gorm.io&#x2F;gorm&#x2F;clause&quot;\n    &quot;time&quot;\n)\n\ntype User struct &#123;\n    gorm.Model\n    Name   string\n    Orders []Order\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    UserID     uint\n    OrderItems []OrderItem\n&#125;\n\ntype OrderItem struct &#123;\n    gorm.Model\n    OrderID     uint\n    ProductName string\n&#125;\n\nfunc main() &#123;\n    db, err :&#x3D; gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)\n    if err !&#x3D; nil &#123;\n        panic(err)\n    &#125;\n\n    db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;, &amp;OrderItem&#123;&#125;)\n\n    user1 :&#x3D; User&#123;\n        Name: &quot;Alice&quot;,\n        Orders: []Order&#123;\n            &#123;\n                OrderItems: []OrderItem&#123;\n                    &#123;\n                        ProductName: &quot;Product A&quot;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n    &#125;\n\n    user2 :&#x3D; User&#123;\n        Name: &quot;Bob&quot;,\n        Orders: []Order&#123;\n            &#123;\n                OrderItems: []OrderItem&#123;\n                    &#123;\n                        ProductName: &quot;Product B&quot;,\n                    &#125;,\n                    &#123;\n                        ProductName: &quot;Product C&quot;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n    &#125;\n\n    db.Create(&amp;user1)\n    db.Create(&amp;user2)\n\n    var users []User\n    db.Preload(clause.Associations).Find(&amp;users)\n\n    for _, user :&#x3D; range users &#123;\n        println(&quot;User ID:&quot;, user.ID)\n        println(&quot;User Name:&quot;, user.Name)\n        for _, order :&#x3D; range user.Orders &#123;\n            println(&quot;  Order ID:&quot;, order.ID)\n            println(&quot;  Order User ID:&quot;, order.UserID)\n            for _, orderItem :&#x3D; range order.OrderItems &#123;\n                println(&quot;    OrderItem ID:&quot;, orderItem.ID)\n                println(&quot;    OrderItem ProductName:&quot;, orderItem.ProductName)\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n该示例中使用 Embedded Preloading 预加载了 User、Order 和 OrderItem 三个模型的关联数据。最终输出了所有 User、Order 和 OrderItem 的详细信息。\n在代码中，通过 db.Preload(clause.Associations).Find(&amp;users) 对 User、Order 和 OrderItem 三个模型进行了 Embedded Preloading 预加载。这意味着，对于 User、Order 和 OrderItem 三个模型，它们的关联数据都会在一次查询中一次性加载出来。这样可以避免 N + 1 查询问题，提高查询效率。\n注意，在进行 Embedded Preloading 预加载时，需要使用 clause.Associations 这个关键字，这样才能正确地指定 Embedded Preloading 操作。\nfor range 实现原理for range 是 Go 语言中的一个迭代器语法，通常用于迭代数组、切片、映射和管道等集合类型。它的使用方法类似于 foreach 循环，可以遍历集合中的所有元素。\nfor range 的实现原理是根据集合的类型来调用不同的迭代器函数，这些函数会返回一个包含当前元素信息的 value 和一个指示迭代是否结束的 ok 值。迭代器函数根据集合的类型可以是以下几种：\n\n数组和切片：返回元素索引和值。\n映射：返回键和值。\n字符串：返回字符的索引和值。\n管道：返回管道中的值。\n\n在 for range 循环中，会通过调用集合的迭代器函数获取当前元素的 value 和 ok 值，然后判断 ok 值是否为 true。如果为 true，则表示迭代器还有元素需要遍历，将 value 赋值给循环变量；否则，表示迭代器已经遍历完所有元素，退出循环。\n需要注意的是，如果在迭代过程中修改了集合中的元素，则会导致迭代器失效，可能会引发不可预知的结果。因此，不建议在 for range 循环中修改集合的元素。\n以下是一个简单的例子，演示了如何使用 for range 循环遍历切片：\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    nums :&#x3D; []int&#123;1, 2, 3, 4, 5&#125;\n    for index, value :&#x3D; range nums &#123;\n        fmt.Printf(&quot;index: %d, value: %d\\n&quot;, index, value)\n    &#125;\n&#125;\n\n输出结果如下：\nindex: 0, value: 1\nindex: 1, value: 2\nindex: 2, value: 3\nindex: 3, value: 4\nindex: 4, value: 5\n\nfor range 原理&#x2F;源码for range 循环在 Go 语言中的实现是通过 range 关键字和具体类型的方法来实现的。range 关键字本身并不是一个迭代器，而是会自动在背后调用一个包含了迭代器逻辑的方法。\n对于数组、切片、字符串等内置类型，range 会自动调用 range 相应的方法来实现迭代。\n下面是 range 的源码实现，以数组为例：\nfor index, element :&#x3D; range array &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n相当于编译器会转换为以下代码：\nfor i :&#x3D; 0; i &lt; len(array); i++ &#123;\n    index :&#x3D; i\n    element :&#x3D; array[i]\n    &#x2F;&#x2F; ...\n&#125;\n\n可以看到，编译器会在背后自动生成循环逻辑，包括从 0 到 len(array) 的循环变量 i，以及在每次循环中自动获取当前的索引和元素值。\n对于自定义类型，需要实现 range 方法才能支持 for range 循环。具体来说，需要实现以下接口：\ntype Iterable interface &#123;\n    Iterator() Iterator\n&#125;\n\ntype Iterator interface &#123;\n    Next() bool\n    Value() interface&#123;&#125;\n&#125;\n\n其中，Iterable 接口定义了获取迭代器的方法 Iterator()，而 Iterator 接口定义了每次迭代的方法 Next() 和获取当前值的方法 Value()。当然，Value() 方法返回的类型可以是任意类型，只要在使用时能够转换为对应的目标类型即可。\n以下是一个自定义类型的例子：\ntype Person struct &#123;\n    Name string\n    Age  int\n&#125;\n\ntype People []Person\n\nfunc (p People) Iterator() Iterator &#123;\n    return &amp;peopleIterator&#123;p, -1&#125;\n&#125;\n\ntype peopleIterator struct &#123;\n    people People\n    index  int\n&#125;\n\nfunc (pi *peopleIterator) Next() bool &#123;\n    pi.index++\n    return pi.index &lt; len(pi.people)\n&#125;\n\nfunc (pi *peopleIterator) Value() interface&#123;&#125; &#123;\n    return pi.people[pi.index]\n&#125;\n\n\n这里定义了 Person 和 People 两个类型，\n其中 People 是一个包含多个 Person 的切片，实现了 Iterable 接口。\n当 People 被用于 for range 循环时，会自动调用 Iterable 接口中的 Iterator() 方法来获取迭代器，\n然后在背后自动调用 Iterator 接口中的 Next() 和 Value() 方法来实现迭代。\n\n在上述例子中，\n\nNext() 方法会自增索引并判断是否已经到达切片的末尾，\n而 Value() 方法则返回当前索引的元素值。\n\n由于切片中的元素类型是 Person，因此需要在调用 Value() 方法后将返回值转换为 Person 类型，以便在循环中使用。\nEmbedded Preloading 如何理解？使用限制：被预加载项需要唯一，能够互相区分\nEmbedded Preloading 只适用于 belongs to 关系（即属于关系），因为在数据库中，其他关系的值是相同的，我们无法区分它们。\n举个例子，假设我们有两个表：\nuser 和 order，它们的关系是一对多，即一个用户可以拥有多个订单。如果我们想要预加载订单，并将它们嵌入到用户结构体中，我们可以使用 Embedded Preloading。\n但是，如果我们还有一个表 product，和 order 的关系也是一对多，即一个订单可以包含多个商品。\n此时，如果我们想要将商品预加载，并将它们嵌入到订单结构体中，使用 Embedded Preloading 就不适用了，因为在数据库中，不同的订单可能拥有相同的商品，我们无法区分它们，所以需要使用普通的 Preloading。\n如果 product，和 order 的关系 也使用 Embedded Preloading 会怎样如果 product 和 order 之间的关系也使用 Embedded Preloading，则会出现类似于 order_items 的情况，即 product_id 和 order_id 无法区分，从而导致查询结果不准确。因此，在使用 Embedded Preloading 时，需要根据实际情况选择需要预加载的关系，避免出现这种问题。\n看不懂，举例说明好的，下面举一个简单的例子来说明 Embedded Preloading 只适用于属于关系。\n假设有以下两个模型：\ntype Product struct &#123;\n    gorm.Model\n    Name string\n    Price float64\n&#125;\n\ntype Order struct &#123;\n    gorm.Model\n    Products []Product\n&#125;\n\n在这个例子中，Order 模型有多个 Product 模型。\n如果使用 Embedded Preloading 来预加载 Products，我们将无法在数据库中区分哪个 Product 属于哪个 Order，因为所有 Product 的 OrderID 值都是相同的，这是无效的。\n因此，Embedded Preloading 仅适用于属于关系，例如 Order 属于 User，但是 Product 不属于 Order。\ndb.Table(“users”).Select(“COALESCE(age,?)”, 42).Rows() 什么意思这段代码使用了 GORM 的 Raw SQL 功能。db.Table(&quot;users&quot;) 用于指定查询的表，.Select(&quot;COALESCE(age,?)&quot;, 42) 用于执行 SQL 的 SELECT 语句，并将结果以行的形式返回。\n具体来说，这条 SQL 语句中的 COALESCE(age,?) 是一个函数，表示如果 age 不为 NULL，则返回 age 的值，否则返回 ? 的值（即 42）。因此，这个查询将返回所有用户的行，但如果某个用户的 age 字段为 NULL，则该字段的值将被替换为 42。\n最后的 .Rows() 用于返回查询结果的行集。\nCOALESCE 是什么COALESCE 是一个 SQL 函数，用于返回一组表达式中的第一个非空表达式的值。如果所有表达式的值都为 NULL，则返回 NULL。\n例如，假设有以下表格：\n\n\n\nid\nname\nage\n\n\n\n1\nTom\nNULL\n\n\n2\nJerry\n20\n\n\n3\nMike\n25\n\n\n如果执行以下 SQL 查询：\nSELECT COALESCE(age, 18) AS age FROM table_name;\n\n则会得到以下结果：\n\n\n\nage\n\n\n\n18\n\n\n20\n\n\n25\n\n\n即如果 age 字段是 NULL，则返回默认值 18，否则返回 age 字段的值。\nsqldb.Joins(“JOIN emails ON emails.user_id &#x3D; users.id AND emails.email &#x3D; ?”, “&#x6a;&#105;&#x6e;&#122;&#x68;&#x75;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x6f;&#x72;&#x67;“).Joins(“JOIN credit_cards ON credit_cards.user_id &#x3D; users.id”).Where(“credit_cards.number &#x3D; ?”, “411111111111”).Find(&amp;user)\nSELECT * FROM users\n  JOIN emails ON emails.user_id &#x3D; users.id AND emails.email &#x3D; &#39;jinzhu@example.org&#39;\n  JOIN credit_cards ON credit_cards.user_id &#x3D; users.id WHERE credit_cards.number &#x3D; &#39;411111111111&#39;\n\n\n\n\nDistinct works with Pluck and Count too 的例子假设我们有一个 User 模型，其中包含 Name 和 Age 字段，并且有多个用户具有相同的姓名，但不同的年龄。我们想要找出唯一的姓名列表。我们可以使用 Distinct 方法来执行此操作：\nvar names []string\ndb.Distinct(&quot;name&quot;).Order(&quot;name asc&quot;).Find(&amp;users).Pluck(&quot;name&quot;, &amp;names)\n\n此代码将按升序顺序返回所有唯一的姓名列表。如果我们想知道有多少个唯一的姓名，则可以使用 Count 方法：\nvar count int64\ndb.Distinct(&quot;name&quot;).Count(&amp;count)\n\n类似地，如果我们想要在计算唯一值之前应用其他条件，我们可以在 Distinct 方法之前使用 Where、Joins 和 Group 等方法。\nFind 、Scan 和 RowsScan 方法 1. 将结果扫描到结构中的工作方式与我们使用 Find 的方式类似 2. Scan 至少要求接受数据的类型是 slice 或 struct 及它们的指针类型。\nRows 方法 是执行 SQL 查询，并返回一个指向结果集的行迭代器\n.Rows() 方法为什么需要 defer close在使用 Rows() 方法时，GORM 会返回一个 *sql.Rows 对象，这个对象代表了查询返回的结果集，需要通过调用 Next() 方法迭代每一行数据，并通过调用 Scan() 方法将行数据扫描到相应的结构体字段中。\n当查询结束后，必须调用 Rows() 方法返回的结果集对象的 Close() 方法来释放相关的资源。如果不及时释放这些资源，可能会导致内存泄漏或数据库连接池耗尽等问题。\n为了确保 Close() 方法得到及时调用，GORM 的 Rows() 方法在返回结果集对象时会将其包装在一个 sql.RowsWrapper 结构体中，并将该结构体返回给调用方。这个结构体实现了 io.Closer 接口，并在 Close() 方法中调用了原始结果集对象的 Close() 方法。\n由于 sql.RowsWrapper 实现了 io.Closer 接口，因此可以通过使用 defer 关键字在函数退出时自动调用 Close() 方法，从而避免忘记释放资源的问题。\n","slug":"2023-05-04gorm","date":"2023-05-04T01:31:34.000Z","categories_index":"Gorm","tags_index":"chatGPT2021,Gorm","author_index":"举手摘月亮"},{"id":"5c7c230f682d9d5e4199756d8ecfb6e2","title":"golang 的一些疑问","content":"\n\n引用类型和值类型\nGo 中严格区分引用类型和值类型\n\ngolang appendappend 是 Go 语言中的内置函数，用于向切片中追加元素。其语法为：\nappend(slice []Type, elems ...Type) []Type\n\n其中，slice 是要追加元素的切片，elems 是要追加的元素，可以是单个元素或一个切片。append 函数会返回一个新的切片，其中包含了原有的元素以及追加的元素。\n如果追加的元素的数量超过了切片的容量，那么 append 函数会重新分配内存，并将原有的元素复制到新的内存中。在重新分配内存后，原有的切片仍然指向旧的内存，而新的切片指向新的内存。\nappend 函数的返回值是一个新的切片，因此，你需要使用新的变量来存储它。例如：\n&#x2F;&#x2F; 定义一个切片\nslice :&#x3D; []int&#123;1, 2, 3&#125;\n\n&#x2F;&#x2F; 追加元素\nslice &#x3D; append(slice, 4, 5)\n\n&#x2F;&#x2F; 输出新的切片\nfmt.Println(slice) &#x2F;&#x2F; [1 2 3 4 5]\n\n在上面的例子中，我们首先定义了一个包含三个元素的切片，然后使用 append 函数向其中追加两个元素，并将新的切片赋值给原来的变量。最后，我们输出了新的切片，其中包含了原有的元素以及追加的元素。\n上述内容中原 slice 会被怎么处理，会不会被垃圾回收在 Go 中，如果 append 函数追加元素后，超出了原有切片的容量，那么 append 函数会重新分配内存，并将原有的元素复制到新的内存中。此时，原有的切片仍然指向旧的内存，而新的切片指向新的内存。\n如果原有的切片不再被使用，那么它会被垃圾回收。垃圾回收器会自动识别不再使用的对象，并将它们从内存中删除。\n需要注意的是，如果原有的切片仍然被其它变量所引用，那么它不会被垃圾回收。只有在所有引用它的变量都被销毁后，垃圾回收器才会将其回收。\n因此，在使用 append 函数时，我们需要注意内存的使用情况，避免产生不必要的内存分配和泄漏。在需要追加元素时，最好提前分配足够的容量，避免频繁的内存分配。同时，当不再需要使用一个切片时，最好将其置为 nil，以便垃圾回收器能够及时回收它所占用的内存。\n分析下 append 的源码append 是 Go 语言内置函数之一，用于向切片中追加元素。下面是 append 函数的源码：\nfunc append(slice []Type, elems ...Type) []Type &#123;\n    &#x2F;&#x2F; 获取切片的容量和长度\n    var (\n        s &#x3D; len(slice)\n        c &#x3D; cap(slice)\n    )\n    &#x2F;&#x2F; 如果追加的元素个数超过了剩余的容量，需要重新分配内存\n    if s+len(elems) &gt; c &#123;\n        &#x2F;&#x2F; 分配新的切片，容量为原切片长度的两倍或者追加元素后的长度，取最大值\n        newCap :&#x3D; max(2*c, s+len(elems))\n        newSlice :&#x3D; makeSlice(len(slice), newCap)\n        &#x2F;&#x2F; 复制原有的元素到新的切片中\n        copy(newSlice, slice)\n        &#x2F;&#x2F; 将新的切片赋值给原变量，以实现扩容\n        slice &#x3D; newSlice\n    &#125;\n    &#x2F;&#x2F; 将新的元素追加到切片中\n    slice &#x3D; slice[:s+len(elems)]\n    for i, x :&#x3D; range elems &#123;\n        slice[s+i] &#x3D; x\n    &#125;\n    return slice\n&#125;\n\nfunc max(x, y int) int &#123;\n    if x &gt; y &#123;\n        return x\n    &#125;\n    return y\n&#125;\n\nfunc makeSlice(oldLen, newCap int) []Type &#123;\n    &#x2F;&#x2F; 分配新的内存\n    newPtr :&#x3D; mallocgc(newCap * sizeof(Type), nil, false)\n    &#x2F;&#x2F; 将原有的元素复制到新的内存中\n    if raceenabled || msanenabled &#123;\n        &#x2F;&#x2F; 开启竞态检测和内存检测\n        typ :&#x3D; sliceType(Type&#123;&#125;)\n        oldPtr :&#x3D; mallocgc(oldLen*int(typ.size), typ, false)\n        memmove(newPtr, oldPtr, uintptr(oldLen)*typ.size)\n        if raceenabled &#123;\n            racewriterangepc(unsafe.Pointer(newPtr), uintptr(oldLen)*typ.size, getcallerpc(), funcPC(append))\n        &#125;\n        if msanenabled &#123;\n            msanwrite(unsafe.Pointer(newPtr), uintptr(oldLen)*typ.size)\n        &#125;\n        typedmemmove(typ, newPtr, unsafe.Pointer(&amp;oldLen), unsafe.Pointer(&amp;newCap))\n        return *(*[]Type)(unsafe.Pointer(&amp;SliceHeader&#123;\n            Data: newPtr,\n            Len:  oldLen,\n            Cap:  newCap,\n        &#125;))\n    &#125;\n    &#x2F;&#x2F; 普通情况下，直接复制元素到新的内存中\n    typ :&#x3D; sliceType(Type&#123;&#125;)\n    newSlice :&#x3D; *(*[]Type)(unsafe.Pointer(&amp;SliceHeader&#123;\n        Data: newPtr,\n        Len:  oldLen,\n        Cap:  newCap,\n    &#125;))\n    if needmem(typ) &#123;\n        &#x2F;&#x2F; 需要进行类型转换\n        for i :&#x3D; range newSlice &#123;\n            typedmemmove(typ, unsafe.Pointer(&amp;newSlice[i]), unsafe.Pointer(&amp;slice[i]), nil)\n        &#125;\n    &#125; else &#123;\n        &#x2F;&#x2F; 直接复制元素\n        memmove(newPtr, data(slice), uintptr(len(slice))*typ.size)\n    &#125;\n    return newSlice\n&#125;\n\nfunc data(slice []Type) unsafe.Pointer &#123;\n    return unsafe.Pointer(&amp;slice[0])\n&#125;\n\n\nappend 函数的实现比较复杂，主要分为以下几个步骤：\n\n获取切片的长度和容量。\n在函数一开始，通过 len 和 cap 内置函数获取原始切片的长度和容量。\n\n判断是否需要扩容。\n如果新的元素个数超过了原切片的剩余容量，则需要扩容。这时会重新分配一个新的切片，容量为原切片长度的两倍或者追加元素后的长度，取两者中的最大值。\nif s+len(elems) &gt; c &#123;\n    &#x2F;&#x2F; 分配新的切片，容量为原切片长度的两倍或者追加元素后的长度，取最大值\n    newCap :&#x3D; max(2*c, s+len(elems))\n    newSlice :&#x3D; makeSlice(len(slice), newCap)\n    &#x2F;&#x2F; 复制原有的元素到新的切片中\n    copy(newSlice, slice)\n    &#x2F;&#x2F; 将新的切片赋值给原变量，以实现扩容\n    slice &#x3D; newSlice\n&#125;\n\n这里调用了 max 函数，用于计算新的容量。然后调用 makeSlice 函数分配新的内存，并将原有元素复制到新的切片中，最后将新的切片赋值给原变量。\n\n追加新的元素。\n在新的容量可以满足追加元素的情况下，就可以将新的元素直接追加到切片的尾部。这里使用了 slice 切片的切片操作，将 slice 的长度扩展到 s+len(elems)，然后使用 for 循环将新的元素一个一个追加到切片的尾部。\n&#x2F;&#x2F; 将新的元素追加到切片中\nslice &#x3D; slice[:s+len(elems)]\nfor i, x :&#x3D; range elems &#123;\n    slice[s+i] &#x3D; x\n&#125;\n\n返回新的切片。\n最后返回的是新的切片，其中包含了追加的新元素。\n\n\n关于内存分配和释放的问题，Go 语言使用了垃圾回收器来自动管理内存，因此在 append 函数中不需要手动释放旧的切片内存空间。当旧的切片被扩容时，Go 语言的垃圾回收器会自动回收旧的内存空间。\n上述源码中为什么要 开启竞态检测和内存检测在 append 函数中，开启了竞态检测和内存检测，是因为这两种检测可以帮助我们在编写程序时发现一些潜在的错误和问题，从而提高程序的健壮性和可靠性。\n竞态检测（Race Detector）是 Go 语言内置的一个工具，它可以用于检测多个 goroutine 之间的竞态条件，比如数据竞态、锁竞争等问题。在 append 函数中，可能存在多个 goroutine 对同一个切片进行并发的追加操作，这时如果不进行竞态检测，就有可能出现数据竞态等问题，导致程序出错或者崩溃。\n内存检测（Memory Sanitizer）是 GCC、Clang 等编译器中的一个功能，它可以用于检测程序中的内存访问越界、未初始化内存、使用已释放内存等问题。在 append 函数中，如果没有开启内存检测，就可能出现一些内存访问越界等问题，导致程序出错或者崩溃。\n因此，在开发过程中，开启竞态检测和内存检测可以帮助我们及时发现这些问题，从而及时修复，提高程序的稳定性和可靠性。当然，开启这些检测也会带来一些性能上的损失，因此在生产环境中一般不会开启这些检测。\n零值和空值在 Golang 的 Gin 框架中，可以使用以下方法来处理零值和空值：\n\n使用指针类型表示空值：在 Go 中，指针类型的零值为 nil，可以用来表示空值。因此，可以将某些变量定义为指针类型，并在需要表示空值的地方将其赋值为 nil。例如：\n\nvar myString *string\n\n&#x2F;&#x2F; 将 myString 赋值为 nil，表示为空值\nmyString &#x3D; nil\n\n&#x2F;&#x2F; 在路由处理函数中检查 myString 是否为空值\nif myString &#x3D;&#x3D; nil &#123;\n    &#x2F;&#x2F; 处理空值的情况\n&#125;\n\n\n使用零值表示默认值：在 Go 中，基本数据类型的零值是其对应类型的默认值，可以用来表示零值。例如，整数类型的零值为 0，布尔类型的零值为 false。可以在定义变量时直接赋值为零值，表示默认值。例如：\n\nvar myInt int\n\n&#x2F;&#x2F; 将 myInt 赋值为 0，表示为零值\nmyInt &#x3D; 0\n\n&#x2F;&#x2F; 在路由处理函数中检查 myInt 是否为零值\nif myInt &#x3D;&#x3D; 0 &#123;\n    &#x2F;&#x2F; 处理零值的情况\n&#125;\n\n\n使用空字符串表示空值：在 Go 中，空字符串 &quot;&quot; 可以用来表示空值。可以将某些字符串类型的变量初始化为空字符串，表示为空值。例如：\n\nvar myString string\n\n&#x2F;&#x2F; 将 myString 赋值为空字符串，表示为空值\nmyString &#x3D; &quot;&quot;\n\n&#x2F;&#x2F; 在路由处理函数中检查 myString 是否为空值\nif myString &#x3D;&#x3D; &quot;&quot; &#123;\n    &#x2F;&#x2F; 处理空值的情况\n&#125;\n\n需要注意的是，处理零值和空值时，应根据具体的业务逻辑和需求进行判断和处理。以上只是一些示例方法，实际使用时应根据实际情况选择合适的方式。同时，在处理请求参数时，应注意对参数进行合法性校验，以确保代码的健壮性和安全性。\ngin 在接收 put 请求时候如何区分 空置和零值在 Golang 的 Gin 框架中，接收 PUT 请求时，如果需要区分空置和零值，可以通过以下方法来实现：\n\n使用指针类型表示空值：将需要接收的字段定义为指针类型，例如 *string、*int 等。如果请求体中的字段值为空置，则对应的指针将为 nil，如果请求体中的字段值为零值，则对应的指针将为指向零值的指针。例如：\n\ntype MyData struct &#123;\n    MyString *string &#96;json:&quot;my_string&quot;&#96;\n    MyInt    *int    &#96;json:&quot;my_int&quot;&#96;\n&#125;\n\n在路由处理函数中使用 c.ShouldBindJSON() 方法将请求体中的 JSON 数据绑定到 MyData 结构体中，然后可以通过判断指针是否为 nil 或指向零值来区分空置和零值的情况。例如：\nfunc UpdateData(c *gin.Context) &#123;\n    var data MyData\n    if err :&#x3D; c.ShouldBindJSON(&amp;data); err !&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理绑定错误\n        c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n        return\n    &#125;\n\n    &#x2F;&#x2F; 判断字段是否为空置\n    if data.MyString &#x3D;&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理空置的情况\n    &#125; else if *data.MyString &#x3D;&#x3D; &quot;&quot; &#123;\n        &#x2F;&#x2F; 处理空字符串的情况\n    &#125;\n\n    &#x2F;&#x2F; 判断字段是否为零值\n    if data.MyInt &#x3D;&#x3D; nil &#123;\n        &#x2F;&#x2F; 处理空置的情况\n    &#125; else if *data.MyInt &#x3D;&#x3D; 0 &#123;\n        &#x2F;&#x2F; 处理零值的情况\n    &#125;\n\n    &#x2F;&#x2F; 处理其他情况\n    &#x2F;&#x2F; ...\n&#125;\n\n\n使用自定义类型并实现 UnmarshalJSON() 方法：可以自定义一个类型，并为其实现 UnmarshalJSON() 方法，在该方法中判断空置和零值的情况。例如：\n\ntype MyString string\n\nfunc (s *MyString) UnmarshalJSON(data []byte) error &#123;\n    if len(data) &#x3D;&#x3D; 0 || string(data) &#x3D;&#x3D; &#96;&quot;&quot;&#96; &#123;\n        &#x2F;&#x2F; 处理空置的情况\n        *s &#x3D; MyString(&quot;&quot;)\n    &#125; else &#123;\n        &#x2F;&#x2F; 处理其他情况\n        var str string\n        if err :&#x3D; json.Unmarshal(data, &amp;str); err !&#x3D; nil &#123;\n            return err\n        &#125;\n        *s &#x3D; MyString(str)\n    &#125;\n    return nil\n&#125;\n\n在路由处理函数中使用 c.ShouldBindJSON() 方法将请求体中的 JSON 数据绑定到结构体中，其中的自定义类型字段会自动调用 UnmarshalJSON() 方法进行解析，从而可以在其中处理空置和零值的情况。\n需要注意的是，以上只是一些示例方法，实际使用时应根据实际情况选择合适的方式，并根据业务逻辑和需求进行判断和处理。同时，在处理 PUT 请求时，应注意对请求体数据进行合法性校验，以确保代码的健壮性和安全性。\ngin 中使用 UnmarshalJSON 处理 put 请求中对象某些字段零值和空置的完整代码例子以下是一个使用 Gin 框架并结合 UnmarshalJSON 方法处理 PUT 请求中对象某些字段零值和空置的完整代码示例：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;net&#x2F;http&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype MyData struct &#123;\n\tMyString *string &#96;json:&quot;my_string&quot;&#96;\n\tMyInt    *int    &#96;json:&quot;my_int&quot;&#96;\n&#125;\n\nfunc (d *MyData) UnmarshalJSON(b []byte) error &#123;\n\tvar temp struct &#123;\n\t\tMyString *string &#96;json:&quot;my_string&quot;&#96;\n\t\tMyInt    *int    &#96;json:&quot;my_int&quot;&#96;\n\t&#125;\n\n\tif err :&#x3D; json.Unmarshal(b, &amp;temp); err !&#x3D; nil &#123;\n\t\treturn err\n\t&#125;\n\n\tif temp.MyString !&#x3D; nil &amp;&amp; *temp.MyString &#x3D;&#x3D; &quot;&quot; &#123;\n\t\td.MyString &#x3D; nil &#x2F;&#x2F; 处理空字符串的情况，设置为 nil\n\t&#125; else &#123;\n\t\td.MyString &#x3D; temp.MyString\n\t&#125;\n\n\tif temp.MyInt !&#x3D; nil &amp;&amp; *temp.MyInt &#x3D;&#x3D; 0 &#123;\n\t\td.MyInt &#x3D; nil &#x2F;&#x2F; 处理零值的情况，设置为 nil\n\t&#125; else &#123;\n\t\td.MyInt &#x3D; temp.MyInt\n\t&#125;\n\n\treturn nil\n&#125;\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\tr.PUT(&quot;&#x2F;data&quot;, UpdateData)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\nfunc UpdateData(c *gin.Context) &#123;\n\tvar data MyData\n\tif err :&#x3D; c.ShouldBindJSON(&amp;data); err !&#x3D; nil &#123;\n\t\tc.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n\t\treturn\n\t&#125;\n\n\tif data.MyString &#x3D;&#x3D; nil &#123;\n\t\tfmt.Println(&quot;MyString is empty or not provided&quot;)\n\t&#125; else &#123;\n\t\tfmt.Println(&quot;MyString:&quot;, *data.MyString)\n\t&#125;\n\n\tif data.MyInt &#x3D;&#x3D; nil &#123;\n\t\tfmt.Println(&quot;MyInt is empty or not provided&quot;)\n\t&#125; else &#123;\n\t\tfmt.Println(&quot;MyInt:&quot;, *data.MyInt)\n\t&#125;\n\n\t&#x2F;&#x2F; 处理其他情况\n\t&#x2F;&#x2F; ...\n\n\tc.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Data updated successfully&quot;&#125;)\n&#125;\n\n在这个示例中，通过自定义的 UnmarshalJSON 方法对 MyString 和 MyInt 进行了处理，可以正确处理 PUT 请求中的零值和空置的情况，并根据业务逻辑进行相应的处理。通过使用这种方式，可以在 Gin 框架中轻松地处理 PUT 请求中对象某些字段的零值和空置，并进行相应的处理。\n更好的例子抱歉，之前的例子可能并不是最佳实践。在处理 PUT 请求中对象某些字段零值和空置的情况时，通常可以直接使用 omitempty 标签来简化处理逻辑。以下是一个更为简洁的示例：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;net&#x2F;http&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype MyData struct &#123;\n\tMyString string  &#96;json:&quot;my_string,omitempty&quot;&#96;\n\tMyInt    int     &#96;json:&quot;my_int,omitempty&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\tr.PUT(&quot;&#x2F;data&quot;, UpdateData)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\nfunc UpdateData(c *gin.Context) &#123;\n\tvar data MyData\n\tif err :&#x3D; c.ShouldBindJSON(&amp;data); err !&#x3D; nil &#123;\n\t\tc.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n\t\treturn\n\t&#125;\n\n\tfmt.Println(&quot;MyString:&quot;, data.MyString)\n\tfmt.Println(&quot;MyInt:&quot;, data.MyInt)\n\n\t&#x2F;&#x2F; 处理其他情况\n\t&#x2F;&#x2F; ...\n\n\tc.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Data updated successfully&quot;&#125;)\n&#125;\n\n在这个示例中，使用了 omitempty 标签在结构体字段中，它的作用是在序列化时忽略零值和空置字段，从而避免了使用 UnmarshalJSON 方法来处理零值和空置的复杂逻辑。在处理 PUT 请求时，如果请求中未包含某些字段，那么这些字段会被置为其类型的零值，从而方便地处理了零值和空置的情况。这种方式更加简洁、直观，并且符合 Go 语言的最佳实践。\n这个事例的请求输入输出的结果假设使用以下请求体作为 PUT 请求的输入：\n&#123;\n\t&quot;my_string&quot;: &quot;&quot;,\n\t&quot;my_int&quot;: 0\n&#125;\n\n则上述示例代码的输出结果如下：\nMyString:\nMyInt: 0\n\n可以看到，请求体中的空字符串 &quot;&quot; 会被解析为空字符串 &quot;&quot;，而请求体中的零值 0 会被解析为整型字段的零值 0。这是因为在结构体字段中使用了 omitempty 标签，使得零值和空置字段在序列化时被忽略，因此在处理 PUT 请求时，字段的零值和空置会被正确地反映到结构体中，从而可以根据业务逻辑进行相应的处理。\n没传 my_string 字段的情况，输入输出如果 PUT 请求的输入没有包含 my_string 字段，那么示例代码的输出结果如下：\nMyString:\nMyInt: 0\n\n可以看到，my_string 字段被解析为空字符串 &quot;&quot;，因为在请求中并没有提供该字段的值。而 my_int 字段被解析为整型字段的零值 0，因为在请求中未指定该字段的值。这是因为在结构体字段中使用了 omitempty 标签，使得零值和空置字段在序列化时被忽略，从而在处理 PUT 请求时，字段的零值和空置会被正确地反映到结构体中，方便进行后续的业务逻辑处理。\n这样就区分不了 my_string 是不是真正的空字符串您是对的，如果请求中传递了空字符串 &quot;&quot;，而不是完全省略了 my_string 字段，那么在使用 omitempty 标签的情况下，无法区分字段的零值和空字符串。\n如果需要明确区分字段的零值和空字符串，在处理 PUT 请求时，可以通过在结构体中使用指针类型来实现，示例如下：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;net&#x2F;http&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype MyData struct &#123;\n\tMyString *string &#96;json:&quot;my_string,omitempty&quot;&#96;\n\tMyInt    int     &#96;json:&quot;my_int,omitempty&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\tr.PUT(&quot;&#x2F;data&quot;, UpdateData)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\nfunc UpdateData(c *gin.Context) &#123;\n\tvar data MyData\n\tif err :&#x3D; c.ShouldBindJSON(&amp;data); err !&#x3D; nil &#123;\n\t\tc.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n\t\treturn\n\t&#125;\n\n\tif data.MyString !&#x3D; nil &#123;\n\t\tfmt.Println(&quot;MyString:&quot;, *data.MyString)\n\t&#125; else &#123;\n\t\tfmt.Println(&quot;MyString: nil&quot;)\n\t&#125;\n\tfmt.Println(&quot;MyInt:&quot;, data.MyInt)\n\n\t&#x2F;&#x2F; 处理其他情况\n\t&#x2F;&#x2F; ...\n\n\tc.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Data updated successfully&quot;&#125;)\n&#125;\n\n在这个示例中，MyString 字段的类型更改为 *string，即指针类型，这样当请求中包含空字符串 &quot;&quot; 时，MyString 字段的值将被设置为指向一个空字符串的指针，而不是直接设置为空字符串 &quot;&quot;。这样在处理 PUT 请求时，就可以通过检查指针是否为 nil 来区分字段的零值和空字符串。需要注意的是，在使用指针类型时，需要额外处理指针的空值和解引用操作，以避免空指针引发的错误。\n结构体\n嵌套\n继承\n\n见\ngolang 结构体继承在 Go 中，结构体（struct）是一种复合数据类型，用于存储一组相关的字段。但是，Go 不支持传统的面向对象编程中的类继承。Go 语言使用组合（Composition）而不是继承（Inheritance）来实现代码的复用。\n组合（Composition）是指在一个结构体中嵌套其他结构体，从而实现结构体之间的组合关系。被嵌套的结构体可以获得嵌套结构体的字段和方法，从而实现代码的复用。\n下面是一个简单的示例，展示了在 Go 中如何使用结构体组合来实现类似继承的效果：\n&#x2F;&#x2F; 父结构体\ntype Person struct &#123;\n\tName string\n\tAge  int\n&#125;\n\n&#x2F;&#x2F; 子结构体，嵌套了父结构体\ntype Employee struct &#123;\n\tPerson   &#x2F;&#x2F; 嵌套 Person 结构体\n\tJobTitle string\n\tSalary   float64\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 创建一个 Employee 实例\n\temp :&#x3D; Employee&#123;\n\t\tPerson: Person&#123;\n\t\t\tName: &quot;John&quot;,\n\t\t\tAge:  30,\n\t\t&#125;,\n\t\tJobTitle: &quot;Software Engineer&quot;,\n\t\tSalary:   5000.0,\n\t&#125;\n\n\t&#x2F;&#x2F; 访问 Employee 的字段\n\tfmt.Println(&quot;Name:&quot;, emp.Name)\n\tfmt.Println(&quot;Age:&quot;, emp.Age)\n\tfmt.Println(&quot;Job Title:&quot;, emp.JobTitle)\n\tfmt.Println(&quot;Salary:&quot;, emp.Salary)\n&#125;\n\n在上面的示例中，Person 结构体被嵌套到 Employee 结构体中，从而实现了类似继承的效果。Employee 结构体可以访问 Person 结构体的字段 Name 和 Age，并且可以定义自己的字段和方法。\n需要注意的是，在使用结构体组合时，如果嵌套的结构体中存在字段或方法与外层结构体中的字段或方法同名，那么在访问这个字段或方法时，需要使用完整的字段或方法名称，包括结构体名称。例如，在上面的示例中，如果 Employee 结构体中也定义了 Name 字段，那么在访问 Person 结构体的 Name 字段时，应该使用 emp.Person.Name。\n区分大小写\n首字母大写的方法可以被引用\n首字母大写的结构体可以被引用\n首字母大写的键可以被转化\n\n打印日志https://www.liwenzhou.com/posts/Go/fmt/\n方法 中 值 vs 指针区别在于：\n\n值方法：可通过指针和值调用，\n指针方法：只能通过指针来调用。\n\n为什么会有这条规则？\n\n因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本， 因此任何修改都将被丢弃，因此该语言不允许这种错误。\n若该值是可寻址的， 那么该语言就会自动插入取址操作符来对付一般的通过值调用的指针方法\n\n如：变量 b 是可寻址的，因此我们只需通过 b.Write 来调用它的 Write 方法，编译器会将它重写为 (&amp;b).Write\nJSON结构体数据-&gt; string\n\n大写被转化，小写不被转化\n有标签的用标签，无标签的，用 key 名字\nChannel， complex 以及函数不能被编码 json 字符串, 循环的数据结构也不行，它会导致 marshal 陷入死循环\n有时为了通用性，或使代码简洁，我们希望有一种类型可以接受各种类型的数据，并进行 json 编码。这就用到了 interface{}类型\n\njson 字符串解析\n\njson 字符串解析时，需要一个“接收体”接受解析后的数据，且 Unmarshal 时接收体必须传递指针。否则解析虽不报错，但数据无法赋值到接受体中。如这里用的是 StuRead{}接收。\n解析时，接收体可自行定义。json 串中的 key 自动在接收体中寻找匹配的项进行赋值。匹配规则是：\n先查找与 key 一样的 json 标签，找到则赋值给该标签对应的变量(如 Name)。\n没有 json 标签的，就从上往下依次查找变量名与 key 一样的变量，如 Age。或者变量名忽略大小写后与 key 一样的变量。如 HIgh，Class。第一个匹配的就赋值，后面就算有匹配的也忽略。\n(前提是该变量必需是可导出的，即首字母大写)。\n不可导出的变量无法被解析（如 sex 变量，虽然 json 串中有 key 为 sex 的 k-v，解析后其值仍为 nil,即空值）\n当接收体中存在 json 串中匹配不了的项时，解析会自动忽略该项，该项仍保留原值。如变量 Test，保留空值 nil。\n\n\n你一定会发现，变量 Class 貌似没有解析为我们期待样子。\n因为此时的 Class 是个 interface{}类型的变量，而 json 串中 key 为 CLASS 的 value 是个复合结构，不是可以直接解析的简单类型数据（如“张三”，18，true 等）。\n所以解析时，由于没有指定变量 Class 的具体类型，json 自动将 value 为复合结构的数据解析为 map[string]interface&#123;&#125;类型的项。\n也就是说，此时的 struct Class 对象与 StuRead 中的 Class 变量没有半毛钱关系，故与这次的 json 解析没有半毛钱关系。\n\n\n\ngolang json API在 Go 语言中，处理 JSON 数据有丰富的标准库（encoding/json）提供的 API。以下是一些常用的 JSON 相关的 API：\n\njson.Marshal(v interface&#123;&#125;) ([]byte, error): 用于将 Go 数据结构转换为 JSON 字节切片。v 参数是要转换的 Go 数据结构，返回值是 JSON 格式的字节切片和可能出现的错误。\n\njson.Unmarshal(data []byte, v interface&#123;&#125;) error: 用于将 JSON 字节切片解析为 Go 数据结构。data 参数是要解析的 JSON 字节切片，v 参数是目标 Go 数据结构的指针，用于存储解析结果。返回值是可能出现的错误。\n\njson.NewEncoder(w io.Writer) *json.Encoder: 提供一个用于将 Go 数据结构编码为 JSON 格式并写入 io.Writer 接口的编码器。w 参数是用于写入 JSON 数据的 io.Writer 实例。\n\njson.NewDecoder(r io.Reader) *json.Decoder: 提供一个用于从 io.Reader 接口读取 JSON 数据并解码为 Go 数据结构的解码器。r 参数是用于读取 JSON 数据的 io.Reader 实例。\n\njson.UnmarshalJSON(data []byte, v interface&#123;&#125;) error: 类似于 json.Unmarshal，但是可以用于解析包含嵌套 JSON 数据的字段值。\n\njson.MarshalIndent(v interface&#123;&#125;, prefix, indent string) ([]byte, error): 类似于 json.Marshal，但是可以为生成的 JSON 数据添加前缀和缩进，以便更好地进行格式化和阅读。\n\njson.Valid(data []byte) bool: 用于检查 JSON 字节切片是否是有效的 JSON 格式。\n\n\n这些只是 encoding/json 包提供的一些常用 API，还有其他一些 API 用于处理 JSON 数据的细节操作，例如处理 JSON 数字精度、自定义 JSON 编码&#x2F;解码方法等。在 Go 中，encoding/json 是处理 JSON 数据的标准库，通常情况下足够满足大多数 JSON 数据处理的需求。\n每个 API 的例子当然，下面是每个 API 的简单示例：\n1 json.Marshal(v interface&#123;&#125;) ([]byte, error):type Person struct &#123;\n    Name   string &#96;json:&quot;name&quot;&#96;\n    Age    int    &#96;json:&quot;age&quot;&#96;\n    Gender string &#96;json:&quot;gender&quot;&#96;\n&#125;\n\nperson :&#x3D; Person&#123;\n    Name:   &quot;Alice&quot;,\n    Age:    30,\n    Gender: &quot;Female&quot;,\n&#125;\n\njsonData, err :&#x3D; json.Marshal(person)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Marshal error:&quot;, err)\n    return\n&#125;\n\nfmt.Println(string(jsonData))\n&#x2F;&#x2F; 输出：&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;\n\n2 json.Unmarshal(data []byte, v interface&#123;&#125;) error:type Person struct &#123;\n    Name   string &#96;json:&quot;name&quot;&#96;\n    Age    int    &#96;json:&quot;age&quot;&#96;\n    Gender string &#96;json:&quot;gender&quot;&#96;\n&#125;\n\njsonStr :&#x3D; &#96;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;&#96;\njsonData :&#x3D; []byte(jsonStr)\n\nvar person Person\nerr :&#x3D; json.Unmarshal(jsonData, &amp;person)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Unmarshal error:&quot;, err)\n    return\n&#125;\n\nfmt.Println(person.Name)\nfmt.Println(person.Age)\nfmt.Println(person.Gender)\n&#x2F;&#x2F; 输出：\n&#x2F;&#x2F; Alice\n&#x2F;&#x2F; 30\n&#x2F;&#x2F; Female\n\n3 json.NewEncoder(w io.Writer) *json.Encoder:type Person struct &#123;\n    Name   string &#96;json:&quot;name&quot;&#96;\n    Age    int    &#96;json:&quot;age&quot;&#96;\n    Gender string &#96;json:&quot;gender&quot;&#96;\n&#125;\n\nperson :&#x3D; Person&#123;\n    Name:   &quot;Alice&quot;,\n    Age:    30,\n    Gender: &quot;Female&quot;,\n&#125;\n\nfile, err :&#x3D; os.Create(&quot;person.json&quot;)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;Failed to create file:&quot;, err)\n    return\n&#125;\ndefer file.Close()\n\njsonEncoder :&#x3D; json.NewEncoder(file)\nerr &#x3D; jsonEncoder.Encode(person)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Encode error:&quot;, err)\n    return\n&#125;\n\n&#x2F;&#x2F; person.json 文件中将包含编码后的 JSON 数据：\n&#x2F;&#x2F; &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;\n\n4 json.NewDecoder(r io.Reader) *json.Decoder:type Person struct &#123;\n    Name   string &#96;json:&quot;name&quot;&#96;\n    Age    int    &#96;json:&quot;age&quot;&#96;\n    Gender string &#96;json:&quot;gender&quot;&#96;\n&#125;\n\nfile, err :&#x3D; os.Open(&quot;person.json&quot;)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;Failed to open file:&quot;, err)\n    return\n&#125;\ndefer file.Close()\n\nvar person Person\njsonDecoder :&#x3D; json.NewDecoder(file)\nerr &#x3D; jsonDecoder.Decode(&amp;person)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Decode error:&quot;, err)\n    return\n&#125;\n\nfmt.Println(person.Name)\nfmt.Println(person.Age)\nfmt.Println(person.Gender)\n&#x2F;&#x2F; 输出：\n&#x2F;&#x2F; Alice\n&#x2F;&#x2F; 30\n&#x2F;&#x2F; Female\n\n5 json.UnmarshalJSON(data []byte, v interface&#123;&#125;) error (续):type Person struct &#123;\n    Name   string &#96;json:&quot;name&quot;&#96;\n    Age    int    &#96;json:&quot;age&quot;&#96;\n    Gender string &#96;json:&quot;gender&quot;&#96;\n&#125;\n\ntype Data struct &#123;\n    RawJSON json.RawMessage &#96;json:&quot;raw_json&quot;&#96;\n&#125;\n\njsonStr :&#x3D; &#96;&#123;&quot;raw_json&quot;: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;&#125;&#96;\njsonData :&#x3D; []byte(jsonStr)\n\nvar data Data\nerr :&#x3D; json.Unmarshal(jsonData, &amp;data)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Unmarshal error:&quot;, err)\n    return\n&#125;\n\nvar person Person\nerr &#x3D; person.UnmarshalJSON(data.RawJSON)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Unmarshal error:&quot;, err)\n    return\n&#125;\n\nfmt.Println(person.Name)\nfmt.Println(person.Age)\nfmt.Println(person.Gender)\n&#x2F;&#x2F; 输出：\n&#x2F;&#x2F; Alice\n&#x2F;&#x2F; 30\n&#x2F;&#x2F; Female\n\n6 json.Compact(dst *bytes.Buffer, src []byte) error:jsonStr :&#x3D; &#96;&#123;\n    &quot;name&quot;: &quot;Alice&quot;,\n    &quot;age&quot;: 30,\n    &quot;gender&quot;: &quot;Female&quot;\n&#125;&#96;\n\njsonData :&#x3D; []byte(jsonStr)\n\nvar pretty bytes.Buffer\nerr :&#x3D; json.Indent(&amp;pretty, jsonData, &quot;&quot;, &quot;\\t&quot;)\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Indent error:&quot;, err)\n    return\n&#125;\n\nfmt.Println(pretty.String())\n&#x2F;&#x2F; 输出：\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F; \t&quot;name&quot;: &quot;Alice&quot;,\n&#x2F;&#x2F; \t&quot;age&quot;: 30,\n&#x2F;&#x2F; \t&quot;gender&quot;: &quot;Female&quot;\n&#x2F;&#x2F; &#125;\n\nvar compact bytes.Buffer\nerr &#x3D; json.Compact(&amp;compact, pretty.Bytes())\nif err !&#x3D; nil &#123;\n    fmt.Println(&quot;JSON Compact error:&quot;, err)\n    return\n&#125;\n\nfmt.Println(compact.String())\n&#x2F;&#x2F; 输出：&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;\n\n7 json.HTMLEscape(dst *bytes.Buffer, src []byte):jsonStr :&#x3D; &#96;&#123;&quot;name&quot;:&quot;&lt;Alice&gt;&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;&#96;\njsonData :&#x3D; []byte(jsonStr)\n\nvar escaped bytes.Buffer\njson.HTMLEscape(&amp;escaped, jsonData)\n\nfmt.Println(escaped.String())\n&#x2F;&#x2F; 输出：&#123;&quot;name&quot;:&quot;\\u003cAlice\\u003e&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;\n\n在 Go 语言中，json包中的HTMLEscape函数用于将特殊字符转义为 HTML 实体，以便在生成 JSON 时确保输出的字符串是安全的，不会引发 HTML 注入攻击。\n下面是json包中HTMLEscape函数的基本使用示例：\npackage main\n\nimport (\n\t&quot;encoding&#x2F;json&quot;\n\t&quot;fmt&quot;\n\t&quot;os&quot;\n)\n\nfunc main() &#123;\n\tdata :&#x3D; map[string]string&#123;\n\t\t&quot;name&quot;:     &quot;John&quot;,\n\t\t&quot;age&quot;:      &quot;25&quot;,\n\t\t&quot;location&quot;: &quot;&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt;&quot;,\n\t&#125;\n\n\t&#x2F;&#x2F; 将数据编码为JSON\n\tencoded, err :&#x3D; json.Marshal(data)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Println(&quot;JSON encoding failed:&quot;, err)\n\t\tos.Exit(1)\n\t&#125;\n\n\t&#x2F;&#x2F; 输出原始的JSON字符串\n\tfmt.Println(&quot;Original JSON:&quot;, string(encoded))\n\n\t&#x2F;&#x2F; 使用HTMLEscape函数转义特殊字符\n\tescaped :&#x3D; json.HTMLEscape(nil, encoded)\n\n\t&#x2F;&#x2F; 输出转义后的JSON字符串\n\tfmt.Println(&quot;Escaped JSON:&quot;, string(escaped))\n&#125;\n\n在以上示例中，我们定义了一个包含一些特殊字符的 JSON 数据对象，并使用json.Marshal函数将其编码为 JSON 格式的字节数组。然后，我们通过调用json.HTMLEscape函数将这些特殊字符转义为 HTML 实体，返回一个新的字节数组。最后，我们将转义后的 JSON 字符串输出到控制台。\n需要注意的是，json.HTMLEscape函数在原地修改了传入的字节数组，并返回修改后的字节数组，因此在使用时应谨慎处理原始数据。此外，json.HTMLEscape函数只会转义特定的字符，例如&lt;, &gt;, &amp;, &#39;, &quot;等，而不会对所有字符进行转义。因此，在处理用户输入或其他潜在的不受信任的数据时，应该使用其他方法来保护 JSON 数据的安全性，例如使用输入验证和输出编码等措施。\n8 json.Valid(data []byte) bool:jsonStr :&#x3D; &#96;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Female&quot;&#125;&#96;\njsonData :&#x3D; []byte(jsonStr)\n\nisValid :&#x3D; json.Valid(jsonData)\n\nfmt.Println(isValid)\n&#x2F;&#x2F; 输出：true\n\ninvalidJSON :&#x3D; []byte(&#96;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;gender&quot;&#125;&#96;)\nisValid &#x3D; json.Valid(invalidJSON)\n\nfmt.Println(isValid)\n&#x2F;&#x2F; 输出：false\n\n这些就是一些常见的 Go JSON API 的简单示例。\n内存模型Go 内存模型\nGolang（或称为 Go）是一种编程语言，其内存模型描述了程序在运行时如何管理和访问内存。理解 Golang 的内存模型对于编写高效、并发和安全的 Go 程序非常重要。\nGolang 的内存模型基于以下几个主要概念：\n\n堆（Heap）：堆是一块大的内存区域，用于分配和存储程序运行时动态分配的内存。在 Golang 中，通过 new、make 等关键字进行堆上的内存分配。\n\n栈（Stack）：栈是一块较小的内存区域，用于存储程序的局部变量和函数调用的上下文信息。在 Golang 中，每个 Goroutine 都有自己的栈空间。\n\nGoroutine：Goroutine 是 Go 中的轻量级线程，用于实现并发执行。Goroutine 的创建和销毁由 Go 运行时管理，每个 Goroutine 都可以在一个独立的栈上运行。\n\n通道（Channel）：通道是 Goroutine 之间进行通信和同步的一种机制。通道可以用来发送和接收数据，并且在读写时会自动进行同步，从而避免了显式的锁操作。\n\n内存模型：Golang 的内存模型规定了 Goroutine 之间的内存访问和同步行为。Golang 使用了基于 happens-before 原则的内存模型，通过同步操作（例如使用通道、互斥锁、原子操作等）来确保 Goroutine 之间的内存一致性。\n\n\n在 Golang 的内存模型中，Goroutine 之间的通信和同步是通过通道进行的，而不是显式的锁操作。这使得编写并发程序更加简单和安全，避免了传统多线程编程中的许多常见问题，例如竞态条件、死锁等。\n总的来说，理解 Golang 的内存模型对于编写高效、并发和安全的 Go 程序非常重要，需要熟悉堆、栈、Goroutine、通道以及 Golang 的内存模型规定的同步行为。\n并发与一致见\nGo Select 详解GO 为什么引入 select?\nselect 是一种 go 可以处理多个通道之间的机制，看起来和 switch 语句很相似，但是 select 其实和 IO 机制中的 select 一样，多路复用通道，随机选取一个进行执行。\n如果说通道(channel)实现了多个 goroutine 之前的同步或者通信，那么 select 则实现了多个通道(channel)的同步或者通信\nselect 具有阻塞的特性。\n有怎样的使用场景？\nGo Select 详解\ndefer设计动机：两点好处：\n\n第一，它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时， 这种情况往往就会发生。\n第二，它意味着“关闭”离“打开”很近， 这总比将它放在函数结尾处要清晰明了\n\n使用场景：\n\n场景：解锁互斥和关闭文件\n\n特点：\n\n被推迟的函数按照后进先出（LIFO）的顺序执行\n\n追加\nappend 会在切片末尾追加元素并返回结果\n将一个切片追加到另一个切片，必须在调用的地方使用 …\n\nx :&#x3D; []int&#123;1,2,3&#125;\ny :&#x3D; []int&#123;4,5,6&#125;\nx &#x3D; append(x, y...) &#x2F;&#x2F; 这里...不可缺少\nfmt.Println(x)\n\n区分某项是不存在还是其值为零值提及提及：区分某项是不存在还是其值为零值\n应对\nGolang 中使用 JSON 时如何区分空字段和未设置字段？\ngo 语言的 null 值问题\n仓库\n\n改变背景色var st &#x3D; document.createElement(&#39;style&#39;);\nst.innerHTML &#x3D; &#96;\n   *&#123;\n      color: #a1a1a1!important;\n      background: #000!important;\n      text-shadow: none!important;\n   &#125;\n&#96;;\ndocument.head.append(st);\n\n加密（skip）token&#x2F;cookie见\njwt 库很多了 各有各的优势 有些库是不维护了\n选择了 github.com/golang-jwt/jwt 库\n获取命令：go get -u github.com/golang-jwt/jwt/v4\nHeaderheader 典型的由两部分组成：token 的类型（“JWT”）和算法名称（比如：HMAC SHA256 或者 RSA 等等\n&#123;\n  &#39;typ&#39;: &#39;JWT&#39;,\n  &#39;alg&#39;: &#39;HS256&#39;\n&#125;\n\nPayload载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分\n标准中注册的声明公共的声明私有的声明\njwt.StandardClaims 标准中注册的声明 (建议但不强制使用) ：\n\niss: jwt 签发者\nsub: jwt 所面向的用户\naud: 接收 jwt 的一方\nexp: jwt 的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该 jwt 都是不可用的.\niat: jwt 的签发时间\njti: jwt 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。\n\n私有的声明 ：私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息\n私有定义的内容根据自己业务需要来，这里简单加了 UID\ntype AuthClaim struct &#123;\n    UID int64 &#96;json:&quot;uid&quot;&#96;\n    jwt.StandardClaims\n&#125;\n\nSignature 签名secret 是保存在服务器端的，jwt 的签发生成也是在服务器端的，secret 就是用来进行 jwt 的签发和 jwt 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个 secret, 那就意味着客户端是可以自我签发 jwt 了。\nvar Secret &#x3D; &quot;私钥&quot;\nvar hmacSampleSecret &#x3D; []byte(Secret)\n\n生成 token生成了两个小时过期时间的 token\nconst TokenExpireDuration &#x3D; 2 * time.Hour &#x2F;&#x2F;过期时间\n\nfunc New(uid int64) (tokenStr string) &#123;\n    var authClaim AuthClaim\n    authClaim.UID &#x3D; uid\n    authClaim.StandardClaims.ExpiresAt &#x3D; time.Now().Add(TokenExpireDuration).Unix()\n    token :&#x3D; jwt.NewWithClaims(jwt.SigningMethodHS256, authClaim)\n    tokenString, _ :&#x3D; token.SignedString(hmacSampleSecret) &#x2F;&#x2F;私钥加密\n    return tokenString\n&#125;\n\n解析 tokenfunc Parse(tokenString string) (auth AuthClaim, Valid bool) &#123;\n    token, _ :&#x3D; jwt.Parse(tokenString, func(token *jwt.Token) (interface&#123;&#125;, error) &#123;\n        &#x2F;&#x2F; Don&#39;t forget to validate the alg is what you expect:\n        if _, ok :&#x3D; token.Method.(*jwt.SigningMethodHMAC); !ok &#123;\n            return nil, fmt.Errorf(&quot;unexpected signing method: %v&quot;, token.Header[&quot;alg&quot;])\n        &#125;\n        &#x2F;&#x2F; hmacSampleSecret is a []byte containing your secret, e.g. []byte(&quot;my_secret_key&quot;)\n        return hmacSampleSecret, nil\n    &#125;)\n    Valid &#x3D; token.Valid&#x2F;&#x2F;token是否有效 true有效  false无效\n    if claims, ok :&#x3D; token.Claims.(jwt.MapClaims); ok &amp;&amp; Valid &#123;\n        auth.UID &#x3D; int64(claims[&quot;uid&quot;].(float64)) &#x2F;&#x2F;自定义的UID\n        auth.ExpiresAt &#x3D; int64(claims[&quot;exp&quot;].(float64)) &#x2F;&#x2F;过期时间\n    &#125;\n    return\n&#125;\n\n跨域问题见\ngin\n中间件开发 https://juejin.cn/post/7034338727883177997#heading-1\n插件开发\n数据绑定\n返回数据\n封装返回\n异常统一处理\n\ngin 中间件Gin 是一个用于构建 Web 应用程序的 Go 语言框架，它提供了一些用于处理 HTTP 请求和响应的功能。Gin 中间件是一种特殊类型的功能，它可以在请求到达路由处理器之前或之后执行一些操作。\nGin 中间件通常用于以下几个目的：\n\n路由处理前的预处理：可以在路由处理器执行之前进行一些操作，例如身份验证、权限验证、请求参数解析等。这样可以在进入路由处理器之前对请求进行预处理，从而减轻路由处理器的负担。\n\n路由处理后的后处理：可以在路由处理器执行完毕之后进行一些操作，例如日志记录、响应结果封装等。这样可以在路由处理器执行完毕后对响应进行后处理，从而实现一些共享的逻辑。\n\n错误处理：可以在发生错误时进行处理，例如错误日志记录、错误信息返回等。这样可以统一处理应用程序中可能发生的错误，避免在每个路由处理器中都进行错误处理逻辑的重复。\n\n\nGin 中间件通过注册到 Gin 的引擎（Engine）上，并按照注册的顺序依次执行。每个中间件可以通过 Gin 的上下文（Context）对象来访问请求和响应的信息，并在需要时对其进行修改。\n以下是一个使用 Gin 中间件的示例：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 自定义中间件示例\n\tr.Use(func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在请求处理前执行的操作\n\t\tfmt.Println(&quot;执行中间件操作前&quot;)\n\n\t\t&#x2F;&#x2F; 执行下一个中间件或路由处理器\n\t\tc.Next()\n\n\t\t&#x2F;&#x2F; 在请求处理后执行的操作\n\t\tfmt.Println(&quot;执行中间件操作后&quot;)\n\t&#125;)\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在路由处理器中的操作\n\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n在上面的示例中，通过 r.Use() 注册了一个自定义的中间件，它会在每次请求到达时先执行预处理操作，然后调用 c.Next() 继续执行下一个中间件或路由处理器，最后在请求处理完毕后执行后处理操作。这样可以在请求处理前后执行一些共享的操作。注意，中间件的注册顺序很重要，它们会按照注册的顺序依次执行。\nGin 中间件是一种强大的功能，可以在处理 HTTP 请求和响应时灵活地进行预处理和后处理操作，从而实现一些共享的逻辑和功能。\n返回数据 统一处理返回 事例 1在 Gin 中，可以使用中间件来实现对响应数据的统一处理和封装，从而实现一些共享的逻辑，例如格式化响应数据、添加公共响应头、处理错误等。以下是一个简单的示例：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype Response struct &#123;\n\tCode    int         &#96;json:&quot;code&quot;&#96;\n\tMessage string      &#96;json:&quot;message&quot;&#96;\n\tData    interface&#123;&#125; &#96;json:&quot;data&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 自定义中间件示例\n\tr.Use(func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在请求处理前执行的操作\n\t\t&#x2F;&#x2F; ...\n\n\t\t&#x2F;&#x2F; 执行下一个中间件或路由处理器\n\t\tc.Next()\n\n\t\t&#x2F;&#x2F; 在请求处理后执行的操作\n\t\t&#x2F;&#x2F; ...\n\n\t\t&#x2F;&#x2F; 统一处理响应数据\n\t\tcode :&#x3D; c.Writer.Status()\n\t\tmessage :&#x3D; &quot;&quot;\n\t\tdata :&#x3D; c.Keys[&quot;response_data&quot;]\n\t\tif err, ok :&#x3D; data.(error); ok &#123;\n\t\t\t&#x2F;&#x2F; 处理错误信息\n\t\t\tcode &#x3D; 500 &#x2F;&#x2F; 错误状态码\n\t\t\tmessage &#x3D; err.Error() &#x2F;&#x2F; 错误消息\n\t\t\tdata &#x3D; nil &#x2F;&#x2F; 清空数据\n\t\t&#125;\n\t\tresponse :&#x3D; Response&#123;\n\t\t\tCode:    code,\n\t\t\tMessage: message,\n\t\t\tData:    data,\n\t\t&#125;\n\t\tc.JSON(response.Code, response)\n\t&#125;)\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在路由处理器中的操作\n\t\t&#x2F;&#x2F; ...\n\n\t\t&#x2F;&#x2F; 设置响应数据到上下文中\n\t\tc.Set(&quot;response_data&quot;, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\n\t\t&#x2F;&#x2F; 抛出一个错误\n\t\t&#x2F;&#x2F; c.AbortWithError(500, fmt.Errorf(&quot;发生了一个错误&quot;))\n\n\t\tc.Next()\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n在上面的示例中，自定义的中间件会在每次请求到达时先执行预处理操作，然后调用 c.Next() 继续执行下一个中间件或路由处理器，最后在请求处理完毕后执行后处理操作。在后处理操作中，根据需要可以统一处理响应数据，例如格式化响应数据、添加公共响应头等。在路由处理器中，可以通过 c.Set() 方法将响应数据存储到 Gin 的上下文中，供后续的中间件和路由处理器使用。\n需要注意的是，如果发生错误，可以通过 c.AbortWithError() 方法终止请求处理，并传递错误信息到后续的中间件和路由处理器，从而实现统一的错误处理。在后处理操作中，可以根据错误信息进行相应的处理，例如设置合适的错误状态码和错误消息。\n这样，通过使用 Gin 中间件来统一处理和封装响应数据，可以实现对响应的格式化、公共头部的添加、错误处理等逻辑的统一管理，从而提高代码的可维护性和可扩展性。\n返回数据 统一处理返回 事例 2好的，这里是一个更详细的示例，演示了如何使用 Gin 中间件来统一处理和封装响应数据。\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype Response struct &#123;\n\tCode    int         &#96;json:&quot;code&quot;&#96;\n\tMessage string      &#96;json:&quot;message&quot;&#96;\n\tData    interface&#123;&#125; &#96;json:&quot;data&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 自定义中间件示例\n\tr.Use(func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在请求处理前执行的操作\n\t\tfmt.Println(&quot;请求处理前&quot;)\n\n\t\t&#x2F;&#x2F; 执行下一个中间件或路由处理器\n\t\tc.Next()\n\n\t\t&#x2F;&#x2F; 在请求处理后执行的操作\n\t\tfmt.Println(&quot;请求处理后&quot;)\n\n\t\t&#x2F;&#x2F; 统一处理响应数据\n\t\tcode :&#x3D; c.Writer.Status()\n\t\tmessage :&#x3D; &quot;&quot;\n\t\tdata :&#x3D; c.Keys[&quot;response_data&quot;]\n\t\tif err, ok :&#x3D; data.(error); ok &#123;\n\t\t\t&#x2F;&#x2F; 处理错误信息\n\t\t\tcode &#x3D; 500 &#x2F;&#x2F; 错误状态码\n\t\t\tmessage &#x3D; err.Error() &#x2F;&#x2F; 错误消息\n\t\t\tdata &#x3D; nil &#x2F;&#x2F; 清空数据\n\t\t&#125;\n\t\tresponse :&#x3D; Response&#123;\n\t\t\tCode:    code,\n\t\t\tMessage: message,\n\t\t\tData:    data,\n\t\t&#125;\n\t\tc.JSON(response.Code, response)\n\t&#125;)\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在路由处理器中的操作\n\t\tfmt.Println(&quot;处理请求&quot;)\n\n\t\t&#x2F;&#x2F; 设置响应数据到上下文中\n\t\tc.Set(&quot;response_data&quot;, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\n\t\t&#x2F;&#x2F; 抛出一个错误\n\t\t&#x2F;&#x2F; c.AbortWithError(500, fmt.Errorf(&quot;发生了一个错误&quot;))\n\n\t\tc.Next()\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n在这个示例中，我们定义了一个自定义的中间件，它会在每次请求到达时先执行预处理操作，然后调用 c.Next() 继续执行下一个中间件或路由处理器，最后在请求处理完毕后执行后处理操作。在后处理操作中，我们根据需要可以统一处理响应数据，例如格式化响应数据、添加公共响应头等。\n在路由处理器中，我们通过 c.Set() 方法将响应数据存储到 Gin 的上下文中，供后续的中间件和路由处理器使用。在这里，我们简单地设置了一个包含 “message” 字段的 map 作为响应数据。\n需要注意的是，如果发生错误，我们可以通过 c.AbortWithError() 方法终止请求处理，并传递错误信息到后续的中间件和路由处理器，从而实现统一的错误处理。在后处理操作中，我们可以根据错误信息进行相应的处理，例如设置合适的错误状态码和错误消息。\n通过这样的方式，我们可以在 Gin 中使用中间件来统一处理和封装响应数据，实现对响应的格式化、公共头部的添加、错误处理等逻辑的统一管理，从而提高代码的可维护性和可扩展性。\ntoken 校验中间件在 Gin 框架中，可以通过自定义中间件来实现 Token 校验功能，用于验证客户端请求中的 Token 是否合法。下面是一个简单的示例：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 自定义 Token 校验中间件示例\n\tr.Use(func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 获取请求中的 Token\n\t\ttoken :&#x3D; c.GetHeader(&quot;Authorization&quot;)\n\n\t\t&#x2F;&#x2F; 进行 Token 校验逻辑\n\t\tif token &#x3D;&#x3D; &quot;&quot; || token !&#x3D; &quot;valid_token&quot; &#123;\n\t\t\t&#x2F;&#x2F; 如果 Token 为空或者不合法，返回错误响应\n\t\t\tc.JSON(401, gin.H&#123;&quot;error&quot;: &quot;Invalid Token&quot;&#125;)\n\t\t\tc.Abort() &#x2F;&#x2F; 终止请求处理\n\t\t\treturn\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Token 校验通过，继续执行下一个中间件或路由处理器\n\t\tc.Next()\n\t&#125;)\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在路由处理器中的操作\n\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n在这个示例中，我们定义了一个自定义的中间件来进行 Token 校验。在中间件中，我们通过 c.GetHeader() 方法获取请求头中的 “Authorization” 字段，该字段用于携带 Token。然后，我们可以进行自定义的 Token 校验逻辑，例如判断 Token 是否为空、是否合法等。\n如果 Token 校验失败，我们通过 c.JSON() 方法返回错误的 JSON 响应，并通过 c.Abort() 方法终止请求处理，从而避免继续执行后续的中间件或路由处理器。\n如果 Token 校验通过，我们可以调用 c.Next() 方法继续执行下一个中间件或路由处理器。\n通过这种方式，我们可以在 Gin 中使用中间件来实现 Token 校验功能，从而实现对客户端请求中的 Token 进行统一的验证和处理，提高应用的安全性。需要根据实际需求进行相应的定制和扩展，例如可以将 Token 存储在数据库或缓存中，并在中间件中进行查询和验证。\n异常统一处理中间件在 Gin 框架中，可以通过自定义中间件来实现异常统一处理功能，用于捕获和处理路由处理器中的异常，从而对异常进行统一的处理和返回错误响应。下面是一个简单的示例：\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 自定义异常统一处理中间件示例\n\tr.Use(func(c *gin.Context) &#123;\n\t\tdefer func() &#123;\n\t\t\tif err :&#x3D; recover(); err !&#x3D; nil &#123;\n\t\t\t\t&#x2F;&#x2F; 捕获路由处理器中的异常\n\n\t\t\t\t&#x2F;&#x2F; 可以根据实际需求进行异常处理，例如记录日志、返回错误响应等\n\t\t\t\tfmt.Println(&quot;Recovered error:&quot;, err)\n\n\t\t\t\t&#x2F;&#x2F; 返回错误响应\n\t\t\t\tc.JSON(500, gin.H&#123;&quot;error&quot;: &quot;Internal Server Error&quot;&#125;)\n\t\t\t\tc.Abort() &#x2F;&#x2F; 终止请求处理\n\t\t\t&#125;\n\t\t&#125;()\n\n\t\t&#x2F;&#x2F; 继续执行下一个中间件或路由处理器\n\t\tc.Next()\n\t&#125;)\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在路由处理器中可能出现的异常\n\t\tpanic(&quot;Some error occurred&quot;)\n\n\t\t&#x2F;&#x2F; 路由处理器中的其他操作\n\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n在这个示例中，我们定义了一个自定义的中间件来进行异常统一处理。在中间件中，我们使用 recover() 函数捕获了路由处理器中的异常，并在 defer 语句中进行了处理。在处理中，我们可以根据实际需求进行异常处理，例如记录日志、返回错误响应等。\n如果发生异常，我们通过 c.JSON() 方法返回错误的 JSON 响应，并通过 c.Abort() 方法终止请求处理，从而避免继续执行后续的中间件或路由处理器。\n通过这种方式，我们可以在 Gin 中使用中间件来实现异常统一处理功能，从而对路由处理器中的异常进行捕获和处理，提高应用的可靠性和稳定性。需要根据实际需求进行相应的定制和扩展，例如可以根据不同类型的异常返回不同的错误响应或执行不同的处理逻辑。\n单个中间件管理在 Gin 框架中，可以将中间件单独放置在项目的某个目录中，以便进行组织和管理。下面是一个简单的示例：\n\n创建一个名为 middlewares 的目录，用于存放中间件文件。可以将这个目录放置在项目的任意位置，例如项目的根目录下。\n\n在 middlewares 目录中创建一个中间件文件，例如 error_handler.go，用于实现异常统一处理中间件。\n\n\npackage middlewares\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\n&#x2F;&#x2F; ErrorHandler 中间件用于捕获和处理路由处理器中的异常\nfunc ErrorHandler() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\tdefer func() &#123;\n\t\t\tif err :&#x3D; recover(); err !&#x3D; nil &#123;\n\t\t\t\t&#x2F;&#x2F; 捕获路由处理器中的异常\n\n\t\t\t\t&#x2F;&#x2F; 可以根据实际需求进行异常处理，例如记录日志、返回错误响应等\n\t\t\t\tfmt.Println(&quot;Recovered error:&quot;, err)\n\n\t\t\t\t&#x2F;&#x2F; 返回错误响应\n\t\t\t\tc.JSON(500, gin.H&#123;&quot;error&quot;: &quot;Internal Server Error&quot;&#125;)\n\t\t\t\tc.Abort() &#x2F;&#x2F; 终止请求处理\n\t\t\t&#125;\n\t\t&#125;()\n\n\t\t&#x2F;&#x2F; 继续执行下一个中间件或路由处理器\n\t\tc.Next()\n\t&#125;\n&#125;\n\n\n在项目的主文件（例如 main.go）中引入 middlewares 包，并使用其中的中间件。\n\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;yourproject&#x2F;middlewares&quot; &#x2F;&#x2F; 引入自定义中间件包\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 使用自定义异常统一处理中间件\n\tr.Use(middlewares.ErrorHandler())\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 在路由处理器中可能出现的异常\n\t\tpanic(&quot;Some error occurred&quot;)\n\n\t\t&#x2F;&#x2F; 路由处理器中的其他操作\n\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n通过将中间件单独放置在项目的某个目录中，并在需要使用中间件的地方引入和使用，可以更好地组织和管理中间件，使代码更加清晰和可维护。需要根据实际项目结构和需求进行相应的调整和扩展。\n多个中间件管理在 Gin 框架中，可以通过以下步骤来管理三个中间件：\n\n创建中间件文件：在项目的某个目录下创建三个中间件文件，例如 middleware1.go、middleware2.go 和 middleware3.go，分别实现三个中间件的逻辑。\n\n编写中间件逻辑：在每个中间件文件中，实现对应的中间件逻辑。例如，可以使用 gin.HandlerFunc 函数签名来定义中间件函数，并在其中编写处理逻辑，例如校验 token、异常处理、日志记录等。\n\n\n&#x2F;&#x2F; middleware1.go\npackage middlewares\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc Middleware1() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 中间件1的逻辑处理\n\t\t&#x2F;&#x2F; ...\n\t\tc.Next() &#x2F;&#x2F; 继续执行下一个中间件或路由处理器\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; middleware2.go\npackage middlewares\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc Middleware2() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 中间件2的逻辑处理\n\t\t&#x2F;&#x2F; ...\n\t\tc.Next() &#x2F;&#x2F; 继续执行下一个中间件或路由处理器\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; middleware3.go\npackage middlewares\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc Middleware3() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 中间件3的逻辑处理\n\t\t&#x2F;&#x2F; ...\n\t\tc.Next() &#x2F;&#x2F; 继续执行下一个中间件或路由处理器\n\t&#125;\n&#125;\n\n\n在项目中引入和使用中间件：在项目的主文件（例如 main.go）或路由文件中，通过引入中间件文件，并调用其中的中间件函数，将中间件添加到 Gin 引擎中的中间件链中。\n\npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;yourproject&#x2F;middlewares&quot; &#x2F;&#x2F; 引入自定义中间件包\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 添加三个自定义中间件到 Gin 引擎中\n\tr.Use(middlewares.Middleware1())\n\tr.Use(middlewares.Middleware2())\n\tr.Use(middlewares.Middleware3())\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 路由处理器的逻辑\n\t\t&#x2F;&#x2F; ...\n\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n通过这种方式，可以方便地管理多个中间件，将它们按照需要添加到 Gin 引擎中的中间件链中，实现各自的逻辑处理。需要根据实际项目需求进行中间件的调用顺序、添加位置等设置。\n跨域问题处理中间件在 Gin 框架中，解决跨域问题可以通过使用中间件来处理。以下是一个简单的跨域中间件示例：\npackage middlewares\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\n&#x2F;&#x2F; CorsMiddleware 是处理跨域请求的中间件\nfunc CorsMiddleware() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 设置允许的域名，* 表示允许任何域名访问，也可以设置具体的域名\n\t\tc.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)\n\t\t&#x2F;&#x2F; 设置允许的请求方法\n\t\tc.Writer.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, POST, PUT, DELETE&quot;)\n\t\t&#x2F;&#x2F; 设置允许的请求头\n\t\tc.Writer.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Authorization&quot;)\n\t\t&#x2F;&#x2F; 允许携带跨域请求中的 cookie\n\t\tc.Writer.Header().Set(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)\n\n\t\t&#x2F;&#x2F; 如果是 OPTIONS 请求，直接返回 200，表示允许该请求\n\t\tif c.Request.Method &#x3D;&#x3D; &quot;OPTIONS&quot; &#123;\n\t\t\tc.AbortWithStatus(200)\n\t\t\treturn\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 继续执行下一个中间件或路由处理器\n\t\tc.Next()\n\t&#125;\n&#125;\n\n在项目中使用这个跨域中间件：\npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;yourproject&#x2F;middlewares&quot; &#x2F;&#x2F; 引入自定义中间件包\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 使用自定义的跨域中间件\n\tr.Use(middlewares.CorsMiddleware())\n\n\t&#x2F;&#x2F; 路由处理器示例\n\tr.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 路由处理器的逻辑\n\t\t&#x2F;&#x2F; ...\n\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, Gin!&quot;&#125;)\n\t&#125;)\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n通过将跨域中间件添加到 Gin 引擎中的中间件链中，可以处理来自不同域名的跨域请求，并设置允许的请求方法、请求头等相关参数，解决跨域问题。需要根据实际项目需求进行相关设置，例如设置允许的域名、请求方法、请求头等。\n分组路由跨域问题处理中间件在 Gin 框架中，可以通过为不同的路由分组使用中间件来处理跨域问题。以下是一个使用分组路由处理跨域问题的示例：\npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;yourproject&#x2F;middlewares&quot; &#x2F;&#x2F; 引入自定义中间件包\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 定义路由组\n\tapi :&#x3D; r.Group(&quot;&#x2F;api&quot;)\n\t&#123;\n\t\t&#x2F;&#x2F; 使用自定义的跨域中间件处理 &#x2F;api 下的所有路由跨域问题\n\t\tapi.Use(middlewares.CorsMiddleware())\n\n\t\t&#x2F;&#x2F; 路由处理器示例\n\t\tapi.GET(&quot;&#x2F;users&quot;, func(c *gin.Context) &#123;\n\t\t\t&#x2F;&#x2F; 路由处理器的逻辑\n\t\t\t&#x2F;&#x2F; ...\n\t\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, users!&quot;&#125;)\n\t\t&#125;)\n\n\t\tapi.GET(&quot;&#x2F;posts&quot;, func(c *gin.Context) &#123;\n\t\t\t&#x2F;&#x2F; 路由处理器的逻辑\n\t\t\t&#x2F;&#x2F; ...\n\t\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Hello, posts!&quot;&#125;)\n\t\t&#125;)\n\n\t\t&#x2F;&#x2F; 可以在这里添加更多的路由处理器\n\t&#125;\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n在这个示例中，我们创建了一个名为 /api 的路由组，并在该路由组中使用了自定义的跨域中间件 middlewares.CorsMiddleware()。这样，该路由组下的所有路由都会经过跨域中间件的处理，从而解决了跨域问题。\n需要注意的是，在使用分组路由处理跨域问题时，中间件的顺序也很重要。例如，如果在路由组中先添加了其他中间件，再添加跨域中间件，可能会导致跨域中间件无法生效。因此，建议将跨域中间件放在路由组的最前面，以确保跨域中间件先于其他中间件执行。\n还能做什么中间件是一种在处理 HTTP 请求和响应时插入逻辑处理的机制，可以在 Gin 框架中用于实现各种功能。除了处理跨域问题和异常统一处理之外，中间件还可以用于以下几种情况：\n\n认证和授权：中间件可以用于验证请求的身份信息，例如基于 token 的认证，JWT 鉴权等。可以在中间件中进行身份验证的逻辑，如果验证失败则可以返回错误响应，否则继续处理请求。\n\n日志记录：中间件可以用于记录请求和响应的日志，包括请求方法、路径、参数、响应状态码等信息，用于监控和排查问题。\n\n参数校验和请求处理：中间件可以用于对请求参数进行校验，例如检查请求参数是否符合要求、是否为空等，可以在中间件中进行参数校验，如果不符合要求则返回错误响应，从而减轻路由处理器的负担。\n\n数据处理和转换：中间件可以用于对请求和响应的数据进行处理和转换，例如对请求数据进行解析、对响应数据进行格式化、压缩等操作。\n\n缓存和性能优化：中间件可以用于实现缓存策略，例如在中间件中判断请求是否命中缓存，如果命中则直接返回缓存数据，从而提高响应速度和性能。\n\n错误处理和异常处理：中间件可以用于捕获和处理应用程序中的错误和异常，例如处理请求过程中发生的错误，并返回相应的错误响应，用于统一的错误处理。\n\n\n需要注意的是，中间件应该按照业务逻辑的不同进行划分和组织，避免中间件过于复杂和耦合，保持中间件的单一职责和可维护性。在使用中间件时，也应该注意中间件的执行顺序，确保它们按照预期的顺序执行。\n日志中间件日志中间件是一种用于记录请求和响应的日志信息的中间件，在 Gin 框架中可以用于记录请求的方法、路径、参数、响应状态码等信息，用于监控和排查问题。以下是一个简单的日志中间件的示例：\npackage middleware\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;time&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\n&#x2F;&#x2F; LoggerMiddleware 日志中间件\nfunc LoggerMiddleware() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 记录请求开始时间\n\t\tstartTime :&#x3D; time.Now()\n\n\t\t&#x2F;&#x2F; 处理请求\n\t\tc.Next()\n\n\t\t&#x2F;&#x2F; 记录请求结束时间和耗时\n\t\tendTime :&#x3D; time.Now()\n\t\tlatencyTime :&#x3D; endTime.Sub(startTime)\n\n\t\t&#x2F;&#x2F; 获取请求信息\n\t\trequestMethod :&#x3D; c.Request.Method\n\t\trequestURI :&#x3D; c.Request.RequestURI\n\t\tstatusCode :&#x3D; c.Writer.Status()\n\n\t\t&#x2F;&#x2F; 记录日志\n\t\tfmt.Printf(&quot;[GIN] %v | %3d | %12v | %s | %s\\n&quot;,\n\t\t\tendTime.Format(&quot;2006&#x2F;01&#x2F;02 - 15:04:05&quot;),\n\t\t\tstatusCode,\n\t\t\tlatencyTime,\n\t\t\trequestMethod,\n\t\t\trequestURI,\n\t\t)\n\t&#125;\n&#125;\n\n在上面的示例中，LoggerMiddleware 是一个日志中间件，它通过在请求处理前记录请求开始时间，然后在请求处理后记录请求结束时间和耗时，再根据请求方法、请求路径、响应状态码等信息输出日志。在使用该中间件时，只需要在路由组或路由处理器中使用 Use 方法添加该中间件即可，例如：\npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;your-package&#x2F;middleware&quot;\n)\n\nfunc main() &#123;\n\tr :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 添加日志中间件\n\tr.Use(middleware.LoggerMiddleware())\n\n\t&#x2F;&#x2F; 添加路由\n\t&#x2F;&#x2F; ...\n\n\tr.Run(&quot;:8080&quot;)\n&#125;\n\n这样，每次请求处理时都会通过该日志中间件记录请求和响应的日志信息，便于监控和排查问题。当然，你还可以根据需要对日志中间件进行定制化，例如输出的日志格式、日志存储方式等，以满足项目的具体需求。\n.next()作用在 Gin 框架中，.Next() 是一个用于在中间件中传递控制权到下一个中间件或处理器函数的方法。当一个请求经过多个中间件时，每个中间件都可以执行一些操作，然后通过调用 .Next() 方法将请求传递给下一个中间件或处理器函数处理。\n使用 .Next() 方法的主要作用是将控制权传递给链中的下一个中间件或处理器函数，允许后续的中间件或处理器函数继续对请求进行处理。如果不调用 .Next() 方法，请求将被中间件截断，不会传递给后续的中间件或处理器函数，从而导致请求无法继续处理。\n在 Gin 中，中间件是按照添加的顺序执行的，通过 .Next() 方法的调用，Gin 会将请求传递给链中的下一个中间件或处理器函数，直到最后一个中间件或处理器函数处理完请求或调用了 .Next() 方法。这样，每个中间件都可以根据需要进行处理，例如校验、记录日志、修改请求或响应等，然后将请求传递给下一个中间件或处理器函数继续处理。\n认证和授权在 Web 应用程序中，认证和授权是两个关键的安全概念，用于确保用户的身份验证和控制用户对资源的访问权限。\n认证（Authentication）是指确认用户的身份是否合法，通常通过用户名和密码进行验证。认证主要用于验证用户是谁，以便在应用程序中标识用户的身份。\n授权（Authorization）是指确定用户是否有权限访问特定资源或执行特定操作。授权主要用于控制用户对应用程序中的资源的访问权限，例如访问某个页面、执行某个操作或访问某个 API 等。\n在 Gin 框架中，可以使用中间件来实现认证和授权的功能。以下是一个简单的示例，展示如何使用中间件进行基于 JWT（JSON Web Token）的认证和授权：\npackage middleware\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;your-package&#x2F;auth&quot;\n)\n\n&#x2F;&#x2F; AuthMiddleware 认证中间件\nfunc AuthMiddleware() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 获取请求头中的 Authorization\n\t\tauthorizationHeader :&#x3D; c.GetHeader(&quot;Authorization&quot;)\n\n\t\t&#x2F;&#x2F; 验证 Authorization 是否为空\n\t\tif authorizationHeader &#x3D;&#x3D; &quot;&quot; &#123;\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;Authorization header is required&quot;&#125;)\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 解析并验证 JWT\n\t\ttoken, err :&#x3D; auth.ParseJWT(authorizationHeader)\n\t\tif err !&#x3D; nil &#123;\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H&#123;&quot;error&quot;: &quot;Invalid token&quot;&#125;)\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 在上下文中保存解析后的用户信息\n\t\tc.Set(&quot;user&quot;, token.Claims.User)\n\n\t\tc.Next()\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; AuthRequired 授权中间件\nfunc AuthRequired() gin.HandlerFunc &#123;\n\treturn func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 检查上下文中是否存在用户信息\n\t\tuser, exists :&#x3D; c.Get(&quot;user&quot;)\n\t\tif !exists &#123;\n\t\t\tc.JSON(http.StatusForbidden, gin.H&#123;&quot;error&quot;: &quot;Forbidden&quot;&#125;)\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 进行授权判断，例如检查用户权限、角色等\n\t\t&#x2F;&#x2F; ...\n\n\t\tc.Next()\n\t&#125;\n&#125;\n\n在上面的示例中，AuthMiddleware 是一个认证中间件，它用于验证请求头中的 Authorization 字段中的 JWT，并将解析后的用户信息保存在上下文中，供后续的中间件或处理器函数使用。AuthRequired 是一个授权中间件，它用于检查上下文中是否存在用户信息，并根据具体的授权逻辑判断用户是否有权限访问资源。在使用这两个中间件时，可以根据需要在路由组或路由处理器中使用 Use 方法添加这两个中间件，以实现认证和授权的功能。\n认证授权使用在使用 Gin 框架中的中间件时，一般需要按照以下步骤进行：\n\n定义中间件函数：根据需求，编写一个或多个中间件函数，每个中间件函数都应该符合 gin.HandlerFunc 类型的定义，接收一个 *gin.Context 参数，用于处理请求和响应。\n\n注册中间件函数：在项目中的合适位置，将中间件函数注册到 Gin 框架中。例如，在应用程序的主函数或初始化函数中，使用 router.Use() 方法将中间件函数注册到 Gin 的路由器（*gin.Engine）中。\n\n\npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;your-package&#x2F;middleware&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 注册认证中间件\n\trouter.Use(middleware.AuthMiddleware())\n\n\t&#x2F;&#x2F; 注册授权中间件\n\trouter.Use(middleware.AuthRequired())\n\n\t&#x2F;&#x2F; 添加路由处理器函数\n\trouter.GET(&quot;&#x2F;protected&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 这里可以访问到已经经过认证和授权的用户信息\n\t\tuser :&#x3D; c.MustGet(&quot;user&quot;).(string)\n\t\tc.JSON(200, gin.H&#123;&quot;user&quot;: user&#125;)\n\t&#125;)\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n在上面的示例中，middleware.AuthMiddleware() 和 middleware.AuthRequired() 分别是认证和授权中间件函数，通过 router.Use() 方法将它们注册到 Gin 的路由器中。随后，在路由处理器函数中可以通过 c.MustGet() 方法获取中间件函数中设置的上下文值，例如获取已经经过认证和授权的用户信息。\n需要注意的是，中间件的注册顺序会影响它们的执行顺序。在使用多个中间件时，可以通过调整注册的顺序来控制它们的执行顺序，从而满足业务需求。\n发送请求使用 curl 进行请求时，可以通过 -H 参数设置请求头部，将认证令牌放入请求头部进行传递。\n以下是一个使用 curl 发送带认证令牌的请求的示例命令：\ncurl -H &quot;Authorization: my_token&quot; http:&#x2F;&#x2F;localhost:8080&#x2F;protected\n\n上面的命令中，-H 参数用于设置请求头部，将认证令牌 “my_token” 放入请求头部的 “Authorization” 字段中。然后，通过指定请求的 URL “http://localhost:8080/protected&quot; 发送请求。如果认证令牌有效，将会收到正常的响应；如果认证令牌无效，将会收到 HTTP 401 错误响应。\ngormredis如何组织项目","slug":"2023-05-04go","date":"2023-05-04T01:30:35.000Z","categories_index":"Go","tags_index":"chatGPT2021,Go","author_index":"举手摘月亮"},{"id":"92b035fc1ec1b990bc3338018d34636f","title":"工具 curl","content":"curl是什么curl 是一个用于发送 HTTP 请求的命令行工具，支持多种协议，包括 HTTP、HTTPS、FTP、SMTP 等。其基本语法如下：\ncurl [options] [URL]\n\n其中，options 是 curl 命令的选项，用于设置请求的各种参数，URL 是目标 URL，指定请求的目标地址。\n以下是一些常用的 curl 选项：\n\n-H：设置请求头部，可以指定多个头部，用逗号分隔。\n-X：指定请求方法，如 GET、POST、PUT、DELETE 等。\n-d：设置请求体数据，用于 POST 请求。\n-u：设置认证用户名和密码。\n-s：静默模式，不显示进度和错误信息。\n-o：将响应保存到文件。\n-L：自动跟随重定向。\n-k：忽略 SSL 证书验证。\n-i：显示响应头部。\n\n以下是一个示例命令，用于发送一个简单的 GET 请求：\ncurl http:&#x2F;&#x2F;example.com\n\n以下是一个示例命令，用于发送一个带自定义请求头部和请求体的 POST 请求：\ncurl -X POST -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;&#39; http:&#x2F;&#x2F;example.com\n\n这只是 curl 的基本语法和常用选项，curl 还有许多其他选项和用法，可以通过 curl --help 命令查看完整的文档。\n以下是 curl 常见的 HTTP 请求方法的示例代码：\nGET 请求：\n\ncurl http:&#x2F;&#x2F;example.com\n\n\nPOST 请求：\n\ncurl -X POST -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;&#39; http:&#x2F;&#x2F;example.com\n\n\nPUT 请求：\n\ncurl -X PUT -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;&#39; http:&#x2F;&#x2F;example.com&#x2F;1\n\n\nDELETE 请求：\n\ncurl -X DELETE http:&#x2F;&#x2F;example.com&#x2F;1\n\n\nPATCH 请求：\n\ncurl -X PATCH -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;age&quot;: 31&#125;&#39; http:&#x2F;&#x2F;example.com&#x2F;1\n\n\nHEAD 请求：\n\ncurl -I http:&#x2F;&#x2F;example.com\n\n\nOPTIONS 请求：\n\ncurl -X OPTIONS http:&#x2F;&#x2F;example.com\n\n以上示例中，-X 参数用于指定请求方法，-H 参数用于设置请求头部，-d 参数用于设置请求体数据，-I 参数用于只返回响应头部，-d 参数用于只发送请求头部并获取服务器端支持的 HTTP 方法。请注意，实际的请求 URL 需要替换为您的目标地址。\n动机curl 是一个命令行工具，用于在终端中发送 HTTP 请求并获取响应，常用于测试和调试 Web 服务。它的产生主要是为了方便地在命令行中进行 HTTP 请求，以便快速测试和调试 API 接口、验证服务器的响应、模拟客户端请求等。\n以下是一些 curl 的主要动机：\n\n简单易用：curl 提供了简单的命令行接口，可以通过简单的命令和选项来发送 HTTP 请求，无需编写复杂的代码，非常方便和易用。\n\n多协议支持：curl 支持多种协议，包括 HTTP、HTTPS、FTP、SMTP 等，可以用于测试和调试各种类型的 Web 服务。\n\n强大的选项：curl 提供了丰富的选项，可以设置请求头部、请求方法、请求体数据、认证信息、代理、SSL 证书验证等，可以满足不同的测试和调试需求。\n\n跨平台支持：curl 可以在多个平台上运行，包括 Windows、macOS、Linux 等，具有很好的跨平台支持，方便在不同的操作系统上使用。\n\n广泛应用：curl 在开发者社区中非常流行，广泛应用于 Web 开发、API 测试、网络调试等场景，被广大开发者广泛使用和推崇。\n\n\n综上所述，curl 的产生主要是为了提供一种简单、方便、跨平台的方式来发送 HTTP 请求，用于测试和调试 Web 服务，满足开发者的需求。\n","slug":"2023-05-04curl","date":"2023-05-04T01:30:00.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"d62e160e4077fd4450156ded5ae45c33","title":"tampermonkey使用","content":"动机很多网页没有适配 dark 主题，我觉得 dark 看起来更舒服些\n之前操作页面加载完成后，在控制台执行如下代码，页面成 dark 模式（自己注入脚本实现）\nvar st &#x3D; document.createElement(&#39;style&#39;);\nst.innerHTML &#x3D; &#96;\n   *&#123;\n      color: #a1a1a1!important;\n      background: #000!important;\n      text-shadow: none!important;\n   &#125;\n&#96;;\ndocument.head.append(st);\n\n有没有更好的将上述脚本，复制到 chrome 浏览器 Sources&#x2F;Sinppets 中，下次直接执行cmd + enter\n有没有更好的上述都是手动的，如果页面加载完成注入这个脚本，并执行，就可以达到效果\n找文档开发个 chrome 浏览器插件？不是不可以，但完全没有这个必要\n有没有更好的找个 chrome 插件 tampermonkey\n\n打开要更改的页面，（方便快速创建）\n新建脚本，并输入脚本\n更改配置，为了实现某个域名下的所有页面都被更改 dark 模式\n\n\n\n\n\n注意：这个删除操作有必要说一下，这个配置的所有的删除操作，需要先用鼠标点击选中要删除的记录，然后点击删除按钮，才能删除\n正则脚本&#x2F;&#x2F; 匹配 https:&#x2F;&#x2F;gorm.io所有页面的正则 js\n&#x2F;^https?:\\&#x2F;\\&#x2F;gorm\\.io(\\&#x2F;[\\w\\-\\.]+)*\\&#x2F;?$&#x2F;;\n\n\n\n举个反例\n\n更改文件名\n\n更改文件名后的效果\n\n有个注意的点用这个 tampermonkey 插件，写规则不要把所有的站点都匹配了，如果都匹配了，有可能哪天你在开发网页的时候，自己的项目也展示成 dark 模式理论上是没关系的，你知道就行，\n万一犯迷糊：项目怎么黑了，对吧，多尴尬\n","slug":"2023-04-27tampermonkey","date":"2023-04-27T09:32:00.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"c85283c353292595a12ddbaa92f14295","title":"RN bundle","content":"一个应用 有多个 react-native bundle，每个 bundle 再点击应用的时候进行加载的实现原理在 React Native 中，一个应用可以被分为多个独立的模块或页面。每个模块或页面可以被打包成一个独立的 JavaScript bundle，然后在需要时动态加载。\n实现这个功能的主要原理是使用 React Native 提供的 DynamicImport 组件。这个组件可以在运行时动态加载 JavaScript bundle，并返回一个 Promise 对象。当 Promise 被解析时，被加载的 bundle 会被执行，从而实现模块或页面的动态加载。\n具体实现步骤如下：\n\n将应用的各个模块或页面打包成独立的 JavaScript bundle。\n\n在应用启动时，加载应用的主 bundle，然后使用 DynamicImport 组件动态加载首个模块或页面的 bundle。\n\n当用户需要加载其他模块或页面时，使用 DynamicImport 组件动态加载对应的 bundle，并在加载完成后将新的模块或页面展示给用户。\n\n\n需要注意的是，动态加载的 JavaScript bundle 会在运行时解析并执行，因此需要确保加载的 bundle 中不包含任何恶意代码，以保障应用的安全性。此外，需要注意动态加载可能会影响应用的性能，因此应尽量减少动态加载的次数，以提高应用的响应速度。\n代码怎么写这里是一个简单的示例，演示如何使用 React Native 实现动态加载多个 JavaScript bundle：\nimport React, &#123; useState, useEffect &#125; from &#39;react&#39;;\nimport &#123; View, Text, Button, ActivityIndicator &#125; from &#39;react-native&#39;;\nimport DynamicImport from &#39;react-native-dynamic-import&#39;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [moduleLoaded, setModuleLoaded] &#x3D; useState(false);\n  const [module, setModule] &#x3D; useState(null);\n\n  const loadModule &#x3D; async () &#x3D;&gt; &#123;\n    setModuleLoaded(false);\n    const module &#x3D; await import(&#39;.&#x2F;path&#x2F;to&#x2F;module&#39;);\n    setModule(module.default);\n    setModuleLoaded(true);\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    loadModule();\n  &#125;, []);\n\n  return (\n    &lt;View&gt;\n      &#123;moduleLoaded ? &lt;module &#x2F;&gt; : &lt;ActivityIndicator size&#x3D;&quot;large&quot; color&#x3D;&quot;#0000ff&quot; &#x2F;&gt;&#125;\n      &lt;Button title&#x3D;&quot;Load module&quot; onPress&#x3D;&#123;loadModule&#125; &#x2F;&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;;\n\nexport default App;\n\n在这个示例中，我们首先使用 useState 钩子定义了两个状态变量 moduleLoaded 和 module，用于跟踪模块是否已经加载完成以及加载的模块内容。然后我们使用 useEffect 钩子在应用启动时自动加载首个模块，然后在渲染时根据状态变量决定是展示模块内容还是展示加载动画。最后我们添加了一个按钮，用于手动触发加载新的模块。\n在 loadModule 函数中，我们使用 import 语句动态加载指定的 JavaScript bundle，并将默认导出的模块内容保存到状态变量 module 中。在加载完成后，我们将状态变量 moduleLoaded 设为 true，从而触发重新渲染并展示模块内容。\n需要注意的是，上面的代码只是一个简单的示例，实际应用中可能需要根据具体情况进行适当修改。同时，我们还需要确保在打包应用时将各个模块或页面打包成独立的 JavaScript bundle，并在需要时使用 DynamicImport 组件动态加载这些 bundle。\nreact-native-dynamic-import （已被开发者清空）react-native-dynamic-import 是一个可以在 React Native 中实现动态加载 JavaScript 模块的第三方库，可以在 npm 上进行安装。\n安装 react-native-dynamic-import 的步骤如下：\n\n打开终端或命令行工具，进入你的 React Native 项目目录。\n\n运行以下命令来安装 react-native-dynamic-import：\nnpm install --save react-native-dynamic-import\n\n如果你使用的是 yarn 包管理器，可以使用以下命令来安装：\nyarn add react-native-dynamic-import\n\n这将在你的项目中安装 react-native-dynamic-import，并将其添加到 package.json 文件中的 dependencies 字段。\n\n在需要使用 DynamicImport 组件的代码文件中，使用以下语句导入该组件：\nimport DynamicImport from &#39;react-native-dynamic-import&#39;;\n\n然后你就可以在代码中使用 DynamicImport 组件来实现动态加载 JavaScript 模块了。\n\n\n需要注意的是，react-native-dynamic-import 是一个第三方库，使用前请确保已经熟悉了其文档和使用方法，并且按照官方推荐的方式进行使用。\n不使用 react-native-dynamic-import 如何实现如果你不想使用第三方库 react-native-dynamic-import 来实现动态加载 JavaScript 模块，你可以使用 React Native 内置的 require() 函数来手动加载模块。\n以下是一个简单的示例代码，演示了如何使用 require() 函数手动加载 JavaScript 模块：\nimport React, &#123; useState, useEffect &#125; from &#39;react&#39;;\nimport &#123; View, Text, Button, ActivityIndicator &#125; from &#39;react-native&#39;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [moduleLoaded, setModuleLoaded] &#x3D; useState(false);\n  const [module, setModule] &#x3D; useState(null);\n\n  const loadModule &#x3D; () &#x3D;&gt; &#123;\n    setModuleLoaded(false);\n    const module &#x3D; require(&#39;.&#x2F;path&#x2F;to&#x2F;module&#39;);\n    setModule(module);\n    setModuleLoaded(true);\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    loadModule();\n  &#125;, []);\n\n  return (\n    &lt;View&gt;\n      &#123;moduleLoaded ? &lt;module.default &#x2F;&gt; : &lt;ActivityIndicator size&#x3D;&quot;large&quot; color&#x3D;&quot;#0000ff&quot; &#x2F;&gt;&#125;\n      &lt;Button title&#x3D;&quot;Load module&quot; onPress&#x3D;&#123;loadModule&#125; &#x2F;&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;;\n\nexport default App;\n\n在这个示例中，我们仍然使用 useState 钩子定义了两个状态变量 moduleLoaded 和 module，用于跟踪模块是否已经加载完成以及加载的模块内容。然后我们使用 useEffect 钩子在应用启动时自动加载首个模块，然后在渲染时根据状态变量决定是展示模块内容还是展示加载动画。最后我们添加了一个按钮，用于手动触发加载新的模块。\n在 loadModule 函数中，我们使用 require 函数手动加载指定的 JavaScript 模块，并将其保存到状态变量 module 中。在加载完成后，我们将状态变量 moduleLoaded 设为 true，从而触发重新渲染并展示模块内容。\n需要注意的是，使用 require() 函数手动加载 JavaScript 模块可能会导致一些问题，例如会阻塞 UI 线程等。因此在实际应用中，我们建议使用 react-native-dynamic-import 或其他更可靠的方式来实现动态加载 JavaScript 模块。\nreact-native-dynamic-import 代码仓库空了经过进一步查证，发现 react-native-dynamic-import 似乎已经没有维护了，并且它的代码仓库也已经被删除。建议你不要使用这个库，可以考虑使用其他方式来实现动态加载模块的功能，例如使用 import() 函数或者第三方库 react-loadable 等。对于使用 import() 函数的方式，可以参考我之前的回答。如果你需要使用 react-loadable，可以参考官方文档进行使用。\n每个 bundle 对应一个应用的情况如何处理呢如果每个 bundle 对应一个独立的应用，那么你可以使用 React Native 提供的 AppRegistry API 来注册和启动这些应用。AppRegistry API 可以让你在一个 React Native 应用中同时运行多个独立的应用，并且它还提供了一些方便的方法来管理这些应用的生命周期。\n以下是一个简单的示例代码，演示了如何使用 AppRegistry API 注册和启动两个独立的应用：\nimport &#123; AppRegistry &#125; from &#39;react-native&#39;;\n\n&#x2F;&#x2F; 定义应用1\nconst App1 &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &#x2F;&#x2F; ...\n  );\n&#125;;\nAppRegistry.registerComponent(&#39;App1&#39;, () &#x3D;&gt; App1);\n\n&#x2F;&#x2F; 定义应用2\nconst App2 &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &#x2F;&#x2F; ...\n  );\n&#125;;\nAppRegistry.registerComponent(&#39;App2&#39;, () &#x3D;&gt; App2);\n\n&#x2F;&#x2F; 启动应用1\nAppRegistry.runApplication(&#39;App1&#39;, &#123;\n  initialProps: &#123;&#125;,\n  rootTag: document.getElementById(&#39;app1&#39;)\n&#125;);\n\n&#x2F;&#x2F; 启动应用2\nAppRegistry.runApplication(&#39;App2&#39;, &#123;\n  initialProps: &#123;&#125;,\n  rootTag: document.getElementById(&#39;app2&#39;)\n&#125;);\n\n在这个示例中，我们首先定义了两个独立的应用 App1 和 App2，然后分别使用 AppRegistry.registerComponent() 方法将它们注册到 AppRegistry 中。最后，我们分别使用 AppRegistry.runApplication() 方法来启动这两个应用，并且通过 rootTag 属性将它们分别渲染到不同的 HTML 元素中。\n需要注意的是，AppRegistry API 只能在 React Native 中使用，如果你要将你的 React Native 应用嵌入到一个 Web 页面中，你需要使用类似 react-native-web 的工具将其转换为 Web 可运行的形式。\n如果 app1 和 app2 不在项目中，需要从服务端加载，改如何处理如果 app1 和 app2 不在 React Native 项目中，而是需要从服务端动态加载，你可以使用动态加载 JavaScript 模块的方式来实现。\n以下是一个简单的示例代码，演示了如何通过动态加载 JavaScript 模块来从服务端加载并启动 app1 和 app2：\nimport &#123; AppRegistry &#125; from &#39;react-native&#39;;\n\n&#x2F;&#x2F; 加载并启动应用\nconst loadAndRunApp &#x3D; async (appName, rootTag) &#x3D;&gt; &#123;\n  try &#123;\n    const &#123; default: App &#125; &#x3D; await import(&#96;https:&#x2F;&#x2F;example.com&#x2F;apps&#x2F;$&#123;appName&#125;.js&#96;);\n    AppRegistry.registerComponent(appName, () &#x3D;&gt; App);\n    AppRegistry.runApplication(appName, &#123;\n      initialProps: &#123;&#125;,\n      rootTag: rootTag,\n    &#125;);\n  &#125; catch (err) &#123;\n    console.error(&#96;Failed to load app $&#123;appName&#125;: $&#123;err&#125;&#96;);\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 加载并启动应用1\nloadAndRunApp(&#39;app1&#39;, document.getElementById(&#39;app1&#39;));\n\n&#x2F;&#x2F; 加载并启动应用2\nloadAndRunApp(&#39;app2&#39;, document.getElementById(&#39;app2&#39;));\n\n在这个示例中，我们定义了一个 loadAndRunApp() 函数，它接受应用名称和根元素的 ID 作为参数，然后使用 import() 函数动态加载指定的 JavaScript 模块，并在加载完成后使用 AppRegistry API 来注册和启动这个应用。最后，我们分别调用 loadAndRunApp() 函数来加载和启动 app1 和 app2。\n需要注意的是，动态加载 JavaScript 模块可能会受到一些安全限制，例如跨域访问限制等。因此在实际应用中，我们建议在服务端将应用打包成可运行的 JavaScript 模块，并将其放置到静态资源服务器上，从而避免跨域访问等安全问题。\n如何打包出 app1.js 和 app2.js如果你要将 app1 和 app2 打包成可运行的 JavaScript 模块，你可以使用 React Native 提供的 react-native bundle 命令来进行打包。以下是一个简单的示例代码，演示了如何使用 react-native bundle 命令来打包 app1 和 app2：\nreact-native bundle --entry-file app1.js --bundle-output .&#x2F;dist&#x2F;app1.js --platform ios --dev false\nreact-native bundle --entry-file app2.js --bundle-output .&#x2F;dist&#x2F;app2.js --platform ios --dev false\n\n在这个示例中，我们分别使用 react-native bundle 命令来打包 app1 和 app2。其中，--entry-file 参数指定了入口文件，--bundle-output 参数指定了输出文件，--platform 参数指定了平台，--dev 参数指定了是否打开开发模式。\n需要注意的是，打包出的 JavaScript 模块只包含了应用的代码，如果你的应用需要使用一些第三方库或者组件，你需要将这些依赖打包到同一个 JavaScript 模块中，或者将它们单独打包成独立的 JavaScript 模块，并在运行时使用动态加载的方式来加载它们。\n","slug":"2023-04-27rn-bundle","date":"2023-04-27T06:23:10.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"be94f55e80fa4ce47d468eae65467080","title":"Go Example","content":"Panic用于抛出异常\n\n\nrecover用于捕获异常\npackage main\n\nimport &quot;fmt&quot;\n\nfunc mayPanic() &#123;\n\tpanic(&quot;a problem&quot;)\n&#125;\n\nfunc main() &#123;\n\n\tdefer func() &#123;\n\t\tif r :&#x3D; recover(); r !&#x3D; nil &#123;\n\n\t\t\tfmt.Println(&quot;Recovered. Error:\\n&quot;, r)\n\t\t&#125;\n\t&#125;()\n\n\tfmt.Println(&quot;before mayPanic()&quot;)\n\tmayPanic()\n\t&#x2F;&#x2F; 下面这个这个没有执行\n\tfmt.Println(&quot;After mayPanic()&quot;)\n&#125;\n\n\n&#x2F;&#x2F; 输出：\n&#x2F;&#x2F; before mayPanic()\n&#x2F;&#x2F; Recovered. Error:\n&#x2F;&#x2F;  a problem\n\n&#x2F;&#x2F; Program exited.\n\n参考链接golang panic 原理\n【golang】panic 详解\nDefer用于确保在程序执行的后期执行函数调用，通常是出于清理的目的。延迟经常用于例如确保和最后将在其他语言中使用。\nText Templates当模版引擎来学好了，类似 mustach 之类的玩意，一开始我还以为是 js 的字符串模版，后来发现不是\ngolang 模板(text&#x2F;template)\n","slug":"2023-04-20panic","date":"2023-04-20T10:54:32.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"b9e3c4baf5e8fc792ec5ea4b47abd686","title":"Go Rate Limiting","content":"并发数量限制见\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n)\n\nfunc main() &#123;\n\n    requests :&#x3D; make(chan int, 5)\n    for i :&#x3D; 1; i &lt;&#x3D; 5; i++ &#123;\n        requests &lt;- i\n    &#125;\n    close(requests)\n\n    limiter :&#x3D; time.Tick(200 * time.Millisecond)\n\n    for req :&#x3D; range requests &#123;\n        &lt;-limiter &#x2F;&#x2F; 卡住，每200毫秒输出下面一行\n        fmt.Println(&quot;request&quot;, req, time.Now())\n    &#125;\n\n&#x2F;&#x2F; -----------------------------------------------------------------------------------------\n&#x2F;&#x2F;  上面是没做并发限制，200毫秒一卡，\n&#x2F;&#x2F;\n&#x2F;&#x2F;  下面的是做并发限制的\n&#x2F;&#x2F; -----------------------------------------------------------------------------------------\n    burstyLimiter :&#x3D; make(chan time.Time, 3) &#x2F;&#x2F; 并发限制\n    &#x2F;&#x2F; run1\n    for i :&#x3D; 0; i &lt; 3; i++ &#123;\n        burstyLimiter &lt;- time.Now()\n    &#125;\n\n    &#x2F;&#x2F; run2\n    &#x2F;&#x2F; 继续往chan中写入数据，是不生效的\n    go func() &#123;\n        for t :&#x3D; range time.Tick(200 * time.Millisecond) &#123;\n            burstyLimiter &lt;- t\n        &#125;\n    &#125;()\n\n   &#x2F;&#x2F; 容量5的请求\n    burstyRequests :&#x3D; make(chan int, 5) &#x2F;&#x2F; 并发请求\n    for i :&#x3D; 1; i &lt;&#x3D; 5; i++ &#123;\n        burstyRequests &lt;- i\n    &#125;\n    &#x2F;&#x2F; 关闭chan\n    close(burstyRequests)\n\n    &#x2F;&#x2F; 1-5遍历一遍\n    for req :&#x3D; range burstyRequests &#123;\n        &lt;-burstyLimiter &#x2F;&#x2F; 前面三个一样是 3连续写入的，后面两个是之后run2写入的，总共五个执行完结束\n        fmt.Println(&quot;request&quot;, req, time.Now())\n    &#125;\n&#125;\n","slug":"2023-04-19go","date":"2023-04-19T16:33:01.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"86982b92d8849af6d72f26999e9eb0f2","title":"RN position","content":"背景最近在给另一个部门兜底项目，火急火燎的，在开发随贴开关面板时候遇到了 ,页面中使用多个 position\n电量告警信息在顶部，中间是开关面板主控制区域，主控制区域外部：使用了 position（主控制区域内部：还是 position）\n页面结构：\n\n电池 icon\n\n电池提示信息\n\n主控制区域\n\n之前开发的主控制区域，为什么用 position？\n\n\n为了给每个按钮添加按键按下去的效果\n\n如果我来实现\n\n我可能要用 RN 的背景了，因为它本就是增加背景的效果\nRN 多个 position Bug\n为什么说这是个 Bug？后面的 position ，会高于前面 position 的层级，无论用什么办法都解决不了（网上有：elevation, zIndex 的方案都无法解决）\n碍你啥事了？主控制区域，遮住了低电量提示不能点击，而我不想改变主控制区域\n\n之前的 web 写法一顿操作完，本以为 OK, 想了很好，打脸很快\nconst styles &#x3D; StyleSheet.create(&#123;\n  tipContent: &#123;\n    height: cy(26),\n    flexDirection: &#39;row&#39;,\n    alignItems: &#39;center&#39;,\n    borderRadius: 24.5,\n    marginTop: cy(14),\n    marginBottom: cy(18),\n    width: cx(118),\n    &#x2F;&#x2F; top: cy(36), &#x2F;&#x2F; &#123; translateY: cy(56) &#125;替换\n    left: &#39;50%&#39;,\n    transform: [&#123; translateX: -cx(56) &#125;, &#123; translateY: cy(36) &#125;],\n    position: &#39;absolute&#39;,\n  &#125;,\n&#125;);\n\n图就不放了，毕竟是客户的设计稿\n修改方案方案 1:\n放顶部，不定位，“自然放”，主控制区域往下放（如果前面人用了 flex 布局，没用定位的情况，我觉得我都不用改主控制区域，然而，并没有用，改了下高度）\n方案 2:\n把上面的电池提示信息放主控制区域后面，然后 position 到顶部\n没采用方案 2，\n\n如果电池 icon 放顶部的，电池提示信息如果放到后面，要么拆分开，复制一份逻辑，增加计算\n如果电池 icon 和 电池提示信息都放后面，进行定位，要改的地方多\n\n方案 3: 一个 view 承载，类似 web 浮动与清除浮动\n\n\n&#x2F;&#x2F; ....\n&lt;View style&#x3D;&#123;&#123; position: &#39;relative&#39;, minHeight: 60, alignItems: &#39;center&#39; &#125;&#125;&gt;\n  &#123;!overCr1 &amp;&amp; (\n    &lt;TouchableOpacity\n      activeOpacity&#x3D;&#123;0.8&#125;\n      style&#x3D;&#123;[styles.tipContentBtn]&#125;\n      onPress&#x3D;&#123;() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; this.handleTip(tipTxt, otherText);\n      &#125;&#125;\n    &gt;\n      &lt;Image style&#x3D;&#123;styles.wornIcon&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;res&#x2F;notice.png&#39;)&#125; &#x2F;&gt;\n      &lt;Text style&#x3D;&#123;[&#123; color: &#39;#FF4A4A&#39; &#125;]&#125;&gt;\n        &#123;Strings.getLang(&#39;alert&#39;)&#125; &#123;Strings.getLang(&#39;view_more&#39;)&#125; &gt;\n      &lt;&#x2F;Text&gt;\n    &lt;&#x2F;TouchableOpacity&gt;\n  )&#125;\n&lt;&#x2F;View&gt;;\n&#x2F;&#x2F; ....\n\nconst styles &#x3D; StyleSheet.create(&#123;\n  tipContentBtn: &#123;\n    height: cy(26),\n    flexDirection: &#39;row&#39;,\n    alignItems: &#39;center&#39;,\n    borderRadius: 24.5,\n    marginTop: cy(14),\n    &#x2F;&#x2F; marginBottom: cy(18),\n    minWidth: cx(118),\n    paddingRight: cx(10),\n    &#x2F;&#x2F; top: cy(36),\n    &#x2F;&#x2F; left: &#39;50%&#39;,\n    &#x2F;&#x2F; transform: [&#123; translateX: -cx(56) &#125;, &#123; translateY: cy(56) &#125;],\n    &#x2F;&#x2F; position: &#39;absolute&#39;,\n    backgroundColor: &#39;#FF898933&#39;,\n    position: &#39;absolute&#39;,\n  &#125;,\n  wornIcon: &#123;\n    width: cx(18),\n    height: cx(18),\n    marginHorizontal: cx(4),\n  &#125;,\n&#125;);\n\n总结\nposition absolute,会改变层级，后面的层级高于前面的，zIndex 会失效\n解决方案有两种： 1. 前面的放后面 2. 不进行定位\n\n参考链接Text 标签的默认宽度和 View 一样，怎么做才能自适应？?\n","slug":"2023-04-19rn","date":"2023-04-19T09:00:51.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"5cdf9e167cb5f0e4541536dd6c2982d9","title":"Go Method","content":"方法模型func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) &#123;\n  方法体\n&#125;\n\n方法中调用\n使用类型的值，调用值接收器声明的方法时，会使用值的副本来执行，因此该类型的值并不会被改变。\n使用类型的指针，调用值接收器声明的方法时，指针被解引为值的副本，因此原指针变量指向的值不会发生改变。\n使用类型的指针，调用指针接收器-声明的方法时，该方法会共享指针指向的值\n使用类型的值，调用指针接收器-声明的方法时，该方法会共享所指向的值，此时会改变指针指向的值\n\n即：\n\n值调用值，值的副本，副本变，原值不变\n指针调用值，值的副本，副本变，原值不变\n指针调用指针，同步变\n值调用指针，同步变\n\n即：\n\n调用值接收器的方法，副本变，原值不变\n调用指针接收器的方法，同步变\n\n事例 1 （值调用值）package main\n\nimport &quot;fmt&quot;\n\ntype User struct &#123;\n    Id int\n    Name string\n&#125;\nfunc (this User) SetName(name string)&#123;\n    this.Name &#x3D; name\n&#125;\nfunc (this User) print()&#123;\n    fmt.Printf(&quot;id &#x3D; %v, name &#x3D; %v\\n&quot;, this.Id, this.Name)\n&#125;\n\nfunc main() &#123;\n    user :&#x3D; User&#123;Id:1, Name:&quot;admin&quot;&#125;\n    user.SetName(&quot;root&quot;)\n    user.print()&#x2F;&#x2F;id &#x3D; 1, name &#x3D; admin\n&#125;\n\n事例 2 （指针调用值）package main\n\nimport &quot;fmt&quot;\n\ntype User struct &#123;\n    Id int\n    Name string\n&#125;\nfunc (this User) SetName(name string)&#123;\n    this.Name &#x3D; name\n&#125;\nfunc (this User) print()&#123;\n    fmt.Printf(&quot;id &#x3D; %v, name &#x3D; %v\\n&quot;, this.Id, this.Name)\n&#125;\n\nfunc main() &#123;\n    user :&#x3D; &amp;User&#123;Id:1, Name:&quot;admin&quot;&#125;\n    user.SetName(&quot;root&quot;)\n    user.print()&#x2F;&#x2F;id &#x3D; 1, name &#x3D; admin\n&#125;\n\n事例 3 （指针调用指针）package main\n\nimport &quot;fmt&quot;\n\ntype User struct &#123;\n    Id int\n    Name string\n&#125;\nfunc (this User) SetName(name string)&#123;\n    this.Name &#x3D; name\n&#125;\nfunc (this User) print()&#123;\n    fmt.Printf(&quot;id &#x3D; %v, name &#x3D; %v\\n&quot;, this.Id, this.Name)\n&#125;\n\nfunc main() &#123;\n    user :&#x3D; &amp;User&#123;Id:1, Name:&quot;admin&quot;&#125;\n    user.SetName(&quot;root&quot;)\n    user.print()&#x2F;&#x2F;id &#x3D; 1, name &#x3D; admin\n&#125;\n\n事例 4（值调用指针）package main\n\nimport &quot;fmt&quot;\n\ntype User struct &#123;\n    Id int\n    Name string\n&#125;\nfunc (this *User) SetName(name string)&#123;\n    this.Name &#x3D; name\n&#125;\nfunc (this User) print()&#123;\n    fmt.Printf(&quot;id &#x3D; %v, name &#x3D; %v\\n&quot;, this.Id, this.Name)\n&#125;\n\nfunc main() &#123;\n    user :&#x3D; User&#123;Id:1, Name:&quot;admin&quot;&#125;\n    user.SetName(&quot;root&quot;)\n    user.print()&#x2F;&#x2F;id &#x3D; 1, name &#x3D; root\n&#125;\n\n总结一下写这么多，白瞎时间\n\n调用值接收器的方法，副本变，原值不变\n调用指针接收器的方法，同步变\n\n这也很符合正常人的思考方式\n","slug":"2023-04-18go","date":"2023-04-18T15:55:37.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"477b27802f823769fb08932565755076","title":"蓝湖图标 快速转化代码","content":"蓝湖规则化下载图标批量解压缩#!&#x2F;bin&#x2F;bash\n\n# 创建保存压缩结果的文件夹\nmkdir unzipDir\n\n# 遍历当前文件夹及其子文件夹中的所有.png文件并进行压缩\nfind . -name &quot;*.zip&quot; -type f -print0 | while read -d $&#39;\\0&#39; file\ndo\n  # 获取文件所在目录相对于当前文件夹的路径，用于在输出文件夹中创建对应的文件夹\n  dir&#x3D;$(dirname &quot;$file&quot;)\n  relative_dir&#x3D;$&#123;dir#*&#x2F;&#125;\n  unzip $file  -d &quot;unzipDir&quot;\n  echo $file; # 拿到文件名批量进行编辑\ndone\n\n名字批量编辑，生成代码# step1. 去掉 _slices.zip 后缀\n# step2. 转化并格式化代码, 不会多行编辑的可以学习下vscode快捷键，见下面链接\n\n多行编辑参考文章&#x2F;#&#x2F;post&#x2F;2022-09-17vscode-shortcuts\n最终结果const s_2_bg &#x3D; require(&#39;.&#x2F;s_2_bg.png&#39;);\n\nconst rc_s_2_1 &#x3D; require(&#39;.&#x2F;rc_s_2_1.png&#39;);\nconst rc_s_2_2 &#x3D; require(&#39;.&#x2F;rc_s_2_2.png&#39;);\n\nconst rs_s_1 &#x3D; require(&#39;.&#x2F;rs_s_1.png&#39;);\nconst rs_s_2 &#x3D; require(&#39;.&#x2F;rs_s_2.png&#39;);\n\nconst setting &#x3D; require(&#39;.&#x2F;setting.png&#39;);\nconst btn_active &#x3D; require(&#39;.&#x2F;btn_active.png&#39;);\n\nconst warn_yellow &#x3D; require(&#39;.&#x2F;warn_yellow.png&#39;);\nconst warn_red &#x3D; require(&#39;.&#x2F;warn_red.png&#39;);\n\nconst step_1 &#x3D; require(&#39;.&#x2F;step_1.png&#39;);\nconst step_2 &#x3D; require(&#39;.&#x2F;step_2.png&#39;);\nconst step_3 &#x3D; require(&#39;.&#x2F;step_3.png&#39;);\n\nconst s_6_bg &#x3D; require(&#39;.&#x2F;s_6_bg.png&#39;);\n\nconst rs_s_6_5 &#x3D; require(&#39;.&#x2F;rs_s_6_5.png&#39;);\nconst rs_s_6_2 &#x3D; require(&#39;.&#x2F;rs_s_6_2.png&#39;);\nconst rs_s_6_1 &#x3D; require(&#39;.&#x2F;rs_s_6_1.png&#39;);\nconst rs_s_6_4 &#x3D; require(&#39;.&#x2F;rs_s_6_4.png&#39;);\nconst rs_s_6_3 &#x3D; require(&#39;.&#x2F;rs_s_6_3.png&#39;);\nconst rs_s_6_6 &#x3D; require(&#39;.&#x2F;rs_s_6_6.png&#39;);\n\nconst rc_s_6_5 &#x3D; require(&#39;.&#x2F;rc_s_6_5.png&#39;);\nconst rc_s_6_2 &#x3D; require(&#39;.&#x2F;rc_s_6_2.png&#39;);\nconst rc_s_6_4 &#x3D; require(&#39;.&#x2F;rc_s_6_4.png&#39;);\nconst rc_s_6_1 &#x3D; require(&#39;.&#x2F;rc_s_6_1.png&#39;);\nconst rc_s_6_6 &#x3D; require(&#39;.&#x2F;rc_s_6_6.png&#39;);\nconst rc_s_6_3 &#x3D; require(&#39;.&#x2F;rc_s_6_3.png&#39;);\n\nconst tip_1 &#x3D; require(&#39;.&#x2F;tip_1.png&#39;);\nconst tip_2 &#x3D; require(&#39;.&#x2F;tip_2.png&#39;);\n\nconst electricity_red &#x3D; require(&#39;.&#x2F;electricity_red.png&#39;);\nconst electricity_yellow &#x3D; require(&#39;.&#x2F;electricity_yellow.png&#39;);\nconst electricity_green &#x3D; require(&#39;.&#x2F;electricity_green.png&#39;);\n\nconst light_grey &#x3D; require(&#39;.&#x2F;light_grey.png&#39;);\nconst light_blue &#x3D; require(&#39;.&#x2F;light_blue.png&#39;);\n\nconst unchecked &#x3D; require(&#39;.&#x2F;unchecked.png&#39;);\nconst checked &#x3D; require(&#39;.&#x2F;checked.png&#39;);\n\nconst icons &#x3D; &#123;\n  s_2_bg,\n  rc_s_2_1,\n  rc_s_2_2,\n  rs_s_1,\n  rs_s_2,\n  setting,\n  btn_active,\n  warn_yellow,\n  warn_red,\n  step_1,\n  step_2,\n  step_3,\n  s_6_bg,\n  rs_s_6_5,\n  rs_s_6_2,\n  rs_s_6_1,\n  rs_s_6_4,\n  rs_s_6_3,\n  rs_s_6_6,\n  rc_s_6_5,\n  rc_s_6_2,\n  rc_s_6_4,\n  rc_s_6_1,\n  rc_s_6_6,\n  rc_s_6_3,\n  tip_1,\n  tip_2,\n  electricity_red,\n  electricity_yellow,\n  electricity_green,\n  light_grey,\n  light_blue,\n  unchecked,\n  checked,\n&#125;;\n","slug":"2023-04-18","date":"2023-04-18T08:09:58.000Z","categories_index":"shell","tags_index":"shell","author_index":"举手摘月亮"},{"id":"0c4a3dd6ecc4239de48c5ec997a9babe","title":"React18 四个新hook","content":"useTransition作用在不阻塞 UI 的情况下更新状态\n动机\n转换是可中断的，这让用户无需等待重新渲染完成即可单击离开。\n转换可防止不需要的加载指示器，这使用户可以避免导航时出现不和谐的跳转。\n\n场景及替换方案\n只能在组件中使用\n要开始转换以响应某些 prop 或自定义 Hook 值，使用 DeferredValue\n传递给 startTranition 的函数必须是同步的。React 会立即执行此函数，并将其执行时发生的所有状态更新标记为转换。如果您稍后尝试执行更多状态更新（例如，在超时时），它们将不会被标记为转换。\n标记为转换的状态更新将被其他状态更新中断\n转换更新不能用于控制文本输入\n如果有多个正在进行的转换，React 当前会将它们批处理在一起。这是一个限制，可能会在未来的版本中删除。\n\n注意事项\n更新转换中的输入不起作用\n传递给 startTranition 的函数必须是同步的\n您不能在组件之外调用 useTranition，因为它是一个 Hook。在这种情况下，请改用独立的 startTranition 方法。它的工作方式相同，但不提供 isPending 指示符。\n\n原理&#x2F;&#x2F; A simplified version of how React works\n\nlet isInsideTransition &#x3D; false;\n\nfunction startTransition(scope) &#123;\n  isInsideTransition &#x3D; true;\n  scope();\n  isInsideTransition &#x3D; false;\n&#125;\n\nfunction setState() &#123;\n  if (isInsideTransition) &#123;\n    &#x2F;&#x2F; 大概是一个标志，为true执行，isInsideTransition置为false, 后就不会执行了\n    &#x2F;&#x2F; ... schedule a transition state update ...\n  &#125; else &#123;\n    &#x2F;&#x2F; ... schedule an urgent state update ...\n  &#125;\n&#125;\n\nuseDeferredValue作用延迟更新部分 UI\n动机场景及替换方案\n在加载新内容时显示陈旧内容\n加一些效果表示内容陈旧\n推迟部分 UI 的重新渲染\n\n注意事项\n您传递给 useDeferredValue 的值应该是原始值（如字符串和数字）或在渲染之外创建的对象。如果您在渲染期间创建一个新对象并立即将其传递给 useDeferredValue，它将在每次渲染时有所不同，从而导致不必要的后台重新渲染。\n当 useDeferredValue 接收到不同的值（与 Object.is 相比）时，除了当前渲染（当它仍然使用以前的值时），它还会在后台使用新值安排重新渲染。后台重新渲染是可中断的：如果该值有另一个更新，React 将从头开始重新启动后台重新渲染。例如，如果用户输入输入的速度比接收其延迟值的图表重新渲染的速度快，则只有在用户停止输入后，图表才会重新渲染。\nuseDeferredValue 与&lt;Suspense&gt;集成。如果新值引起的后台更新挂起 UI，用户将看不到回退。他们会看到旧的延迟值，直到数据加载。\nuseDeferredValue 本身不会阻止额外的网络请求。\nuseDeferredValue 本身没有固定的延迟。一旦 React 完成原始的重新渲染，React 将立即开始使用新的延迟值进行后台重新渲染。由事件（如打字）引起的任何更新都会中断后台重新渲染并优先于它。\nuseDeferredValue 导致的后台重新渲染在提交到屏幕之前不会触发效果。如果后台重新渲染暂停，其效果将在数据加载和 UI 更新后运行。\n\n陷阱见\n这种优化需要将 SlowList 包装在 memo 中。这是因为每当文本发生变化时，React 都需要能够快速重新渲染父组件。在重新渲染期间，deferredText 仍然有其先前的值，因此 SlowList 能够跳过重新渲染（其道具没有改变）。如果没有 memo，它无论如何都必须重新渲染，这违背了优化的要点。\nuseInsertionEffect作用useInsertionEffects 适用于 CSS-in-JS 库作者。除非您正在开发 CSS-in-JS 库并且需要一个地方来注入样式，否则您可能需要 useEffects 或 useLayoutEffects。\n动机用于 CSS-in-JS 库作者\n场景及替换方案如果您使用 CSS-in-JS，我们建议结合前两种方法（静态样式的 CSS 文件，动态样式的内联样式）。我们不推荐运行时&lt;style&gt;标签注入，原因有两个：\n\n运行时注入迫使浏览器更频繁地重新计算样式。\n如果在 React 生命周期中的错误时间发生，运行时注入可能会非常慢。\n\n第一个问题是无法解决的，但是 useInsertionEffects 可以帮助您解决第二个问题。\n注意事项\n仅在客户端上运行。它们在服务器渲染期间不运行。\nuseInsertionEffects 内部不能更新状态。\n到 useInsertionEffects 运行时，还没有添加 ref，并且 DOM 还没有更新。\n\n这比在渲染或 useLayoutEffects 期间注入样式更好吗？\n如果您在渲染期间插入样式并且 React 正在处理非阻塞更新，浏览器将在渲染组件树时每帧重新计算样式，这可能非常慢。\n因为它确保了当其他效果在你的组件中运行时，&lt;style&gt;标签已经被插入。否则，由于样式过时，常规效果中的布局计算将是错误的。\n\nuseSyncExternalStore作用订阅外部存储\n动机useSyncExternalStore 是一个新的钩子，它允许外部存储通过强制同步对存储的更新来支持并发读取。它在实现对外部数据源的订阅时消除了对 useEffects 的需求，建议用于与 React 外部状态集成的任何库\n场景及替换方案如果可能，我们建议将内置的 React 状态与useState和useReducer一起使用。如果您需要与现有的非 React 代码集成，useSyncExternalStore API 非常有用。\n注意事项重新渲染问题\n\n如果 getSnapshot 返回值与上次不同，React 将重新渲染组件。\n如果实际发生了变化，您的 getSnapshot 对象应该只返回不同的对象。如果您的存储包含不可变数据，您可以直接返回该数据\n\n订阅函数在每次重新渲染后被调用\n此订阅函数是在组件内部定义的，因此每次重新渲染时都不同，如果在重新渲染之间传递不同的订阅功能，React 将重新订阅 store。\n\n如果这会导致性能问题并且想要避免重新订阅，请将订阅功能移到外部\n或者，将订阅包装到 useCallback 中以仅在某些参数更改时重新订阅：\n\n原理实现见 -->\n\n&#x2F;&#x2F; prettier-ignore\nexport function useSyncExternalStore&lt;T&gt;(\n  subscribe: (() &#x3D;&gt; void) &#x3D;&gt; () &#x3D;&gt; void, \n  getSnapshot: () &#x3D;&gt; T, \n  getServerSnapshot?: () &#x3D;&gt; T\n): T &#123;\n  const value &#x3D; getSnapshot();\n\n  const [&#123; inst &#125;, forceUpdate] &#x3D; useState(&#123; inst: &#123; value, getSnapshot &#125; &#125;);\n\n  useLayoutEffect(() &#x3D;&gt; &#123;\n    inst.value &#x3D; value;\n    inst.getSnapshot &#x3D; getSnapshot;\n\n    if (checkIfSnapshotChanged(inst)) &#123;\n      &#x2F;&#x2F; Force a re-render.\n      forceUpdate(&#123; inst &#125;);\n    &#125;\n  &#125;, [subscribe, value, getSnapshot]);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (checkIfSnapshotChanged(inst)) &#123;\n      &#x2F;&#x2F; Force a re-render.\n      forceUpdate(&#123; inst &#125;);\n    &#125;\n    const handleStoreChange &#x3D; () &#x3D;&gt; &#123;\n      if (checkIfSnapshotChanged(inst)) &#123;\n        &#x2F;&#x2F; Force a re-render.\n        forceUpdate(&#123; inst &#125;);\n      &#125;\n    &#125;;\n    &#x2F;&#x2F; Subscribe to the store and return a clean-up function.\n    return subscribe(handleStoreChange);\n  &#125;, [subscribe]);\n\n  useDebugValue(value);\n  return value;\n&#125;\n\nfunction checkIfSnapshotChanged&lt;T&gt;(inst: &#123; value: T, getSnapshot: () &#x3D;&gt; T &#125;): boolean &#123;\n  const latestGetSnapshot &#x3D; inst.getSnapshot;\n  const prevValue &#x3D; inst.value;\n  try &#123;\n    const nextValue &#x3D; latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  &#125; catch (error) &#123;\n    return true;\n  &#125;\n&#125;\n\n利用 React 的 useLayoutEffects 和 useEffects 执行时机来实现\n\n首先 useLayoutEffects 是调用 getSnapshot 初始化 value，并将 value 和 getSnapshot 通过 state 维护起来\n其次是 useEffects 监听 subscribe, value, getSnapshot 的变化，如果有变化，直接更新\n最后是监听 subscribe ，返回 subscribe 的调用，并将 handleStoreChange 作为形参传入，对应 callback，当监听到 online 状态时，触发 handleStoreChange 的调用，从而触发 forceUpdate\nforceUpdate 会触发 useLayoutEffect 和 useEffect 的重新执行，也就可以获取到最新的状态\n\n事例：\nexport function useOnlineStatus() &#123;\n  const isOnline &#x3D; useSyncExternalStore(subscribe, getSnapshot);\n  return isOnline;\n&#125;\n\nfunction getSnapshot() &#123;\n  return navigator.onLine;\n&#125;\n\nfunction subscribe(callback &#x2F;*handleStoreChange*&#x2F;) &#123;\n  window.addEventListener(&#39;online&#39;, callback);\n  window.addEventListener(&#39;offline&#39;, callback);\n  return () &#x3D;&gt; &#123;\n    window.removeEventListener(&#39;online&#39;, callback);\n    window.removeEventListener(&#39;offline&#39;, callback);\n  &#125;;\n&#125;\n\nfunction ChatIndicator() &#123;\n  const isOnline &#x3D; useOnlineStatus();\n  &#x2F;&#x2F; ...\n&#125;\n","slug":"2023-04-17useTansition","date":"2023-04-17T06:35:31.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"fa1eb907999aa1ab8385490fbee6a85e","title":"Module Cheatsheet","content":"动机最近在开发 RN 面板，开发完了，回顾下 react-native 官网，加深印象\n组件导出&#x2F;入\n\n&#x2F;&#x2F; Name Export | Name Import 命名导出&#x2F;入\nexport const name &#x3D; &#39;value&#39;\nimport &#123; name &#125; from &#39;...&#39;\n\n&#x2F;&#x2F; Default Export | Default Import 默认导出&#x2F;入\nexport default &#39;value&#39;\nimport anyName from &#39;...&#39;\n\n&#x2F;&#x2F; Rename Export | NameImport 重命名导出&#x2F;入\nexport &#123; name as newName &#125;\nimport &#123; newName &#125; from &#39;...&#39;\n\n&#x2F;&#x2F; Name + Default | Import All 有名字，有默认导出，导出全部\nexport const name &#x3D; &#39;value&#39;\nexport default &#39;value&#39;\nimport * as anyName from &#39;...&#39;\n\n&#x2F;&#x2F; Export List + Rename | Import List + Rename  导出多个，导入多个，可重命名\nexport &#123;\n  name1,\n  name2 as newName2\n&#125;\nimport &#123;\n  name1 as newName1,\n  newName2\n&#125; from &#39;...&#39;\n\n之后的内容，可以不用看了，讲述的是哪些写法是错误的，平时用正确写法就好了，错误示范学了，说不定容易写错哈\n参考链接module-cheatsheet\n","slug":"2023-04-11module","date":"2023-04-11T08:08:31.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"e0e18c98c586bcfe5014c7e734d90b99","title":"PS蒙版","content":"\n图层蒙版\n黑色 - 透\n白色 - 不透\n灰色 - 半透\n\n\n\n见\n\n主体抠图\n选择-主体\n套索增加选取\ncmd+j 创建，选取的区域图层\n\n\n\n见\n见\n\n[、]条件刷头大小\nctrl + t 自由变化\nalt+shift 中间点，等比例缩放\n选择两个图层。图层合并 ctrl + e\n\n抠图\n透明度抠图： 玻璃、冰块\n毛发抠图、\n通道抠图： 主体与背景相差较大\n\n见\n","slug":"2023-04-09","date":"2023-04-09T08:29:34.000Z","categories_index":"PS","tags_index":"PS","author_index":"举手摘月亮"},{"id":"6c73e119803e50b56fae60b4dcf06443","title":"rn适配","content":"动机之前有了解过 rn 适配，也有做过适配。最近在帮面板部门开发 RN，看到了相关库是开源的，这次来看看大公司是如何做适配的，学习～\nrem 适配方案tuya-panel-kittuya-panel-kit 是公司面板部门开源的 RN 工具库及 UI 包，主要用于面板开发\n适配工具convertX、convertY、convert\n -->\n\n注意啦下面还有一个默认 export default 导出\n -->\n\nexport default\nconvertX: (number: number): number &#x3D;&gt; &#123;\n    const &#123; width: actualWidth, height: actualHeight &#125; &#x3D; getDimension();\n    let hRatio &#x3D; 0;\n    if (actualWidth &gt; actualHeight) &#123;\n      hRatio &#x3D; actualWidth &#x2F; baseHeight;\n    &#125; else &#123;\n      hRatio &#x3D; actualWidth &#x2F; baseWidth;\n    &#125;\n    return number * hRatio;\n  &#125;,\n  convertY: (number: number): number &#x3D;&gt; &#123;\n    const &#123; width: actualWidth, height: actualHeight &#125; &#x3D; getDimension();\n    let vRatio &#x3D; 0;\n    if (actualWidth &gt; actualHeight) &#123;\n      vRatio &#x3D; actualHeight &#x2F; baseWidth;\n    &#125; else &#123;\n      vRatio &#x3D; actualHeight &#x2F; baseHeight;\n    &#125;\n    return number * vRatio;\n  &#125;,\n\n\n\nconvertX，convertY 计算真实设备与 UI 稿的宽高比，将设计稿要开发的尺寸，对应按照宽高比缩放\n\nconvertconvert: (number: number): number &#x3D;&gt; &#123;\n  const actualX &#x3D; Math.sqrt(height * height + width * width); &#x2F;&#x2F; 设备对角线\n  const &#123; width: actualWidth &#125; &#x3D; getDimension(); &#x2F;&#x2F;设备实际宽度\n  let actualRatio &#x3D; actualX &#x2F; baseX; &#x2F;&#x2F; 宽度比\n  if (baseWidth &#x3D;&#x3D;&#x3D; actualWidth &amp;&amp; actualRatio &gt; 1) &#123;\n    &#x2F;&#x2F; 如果 UI宽度 &#x3D; 设备宽度，不进行缩放，怎么感觉这里写的很奇怪actualRatio&gt;1没生效\n    actualRatio &#x3D; 1;\n  &#125;\n  return number * actualRatio;\n&#125;;\n\ngetDimensionconst getDimension &#x3D; () &#x3D;&gt; &#123;\n  if (isWeb) &#123;\n    try &#123;\n      &#x2F;&#x2F; @ts-ignore\n      return Dimensions.get(&#39;osWindow&#39;);\n    &#125; catch (error) &#123;\n      return Dimensions.get(&#39;window&#39;);\n    &#125;\n  &#125;\n  return Dimensions.get(&#39;window&#39;);\n&#125;;\n\n\nconvert 实际对角线\n\n代码确实有点懵逼\nexport const\nexport default\n\n查看到 tuya-panel-utilsimport RatioUtils from ‘.&#x2F;ratio’;\n代码中引用大都是 export default\npx 适配方案PixelRatio 是 react-native 提供的 API，上述内容看不到 PixelRatio 的任何信息\n\n\n\n\n\n\n\n\n\nreact-native 官方提供的是 dp 值，所以不同分辨率的设备之间会造成显示上的差异。所以可以使用前端最常用的 rem 方式来进行适配，对于个别需要真实像素的地方，可以使用 px 像素进行适配。\nRN API\ngetPixelSizeForLayoutSize 将一个布局尺寸(dp)转换为像素尺寸(px)。\nroundToNearestPixel() 将布局大小（dp）四舍五入到与整数像素对应的最接近的布局大小。例如，在 PixelRatio 为 3 的设备上，PixelRatio.roundToNearestPixel(8.4)=8.33，正好对应(8.33*3)=25 像素。\n\npx -&gt; dppx = dp / PixelRatio.get() -&gt; dp = px * PixelRatio.get()UI 一般给出的设计稿单位都是 px，那我们 RN 中的单位是 dp，那么我们就需要将 px 转换为 dp，这就需要使用像素密度了。\n参考链接react-native 不同分辨率设备适配（rem、px 解决方案）\nReact-Native 系列，关于 PixelRatio\n适配代码见 github\nimport &#123; Dimensions, Platform, StatusBar &#125; from &#39;react-native&#39;;\n\nconst &#123; height, width &#125; &#x3D; Dimensions.get(&#39;window&#39;);\nconst baseHeight &#x3D; 667;\nconst baseWidth &#x3D; 375;\nconst baseX &#x3D; Math.sqrt(baseHeight * baseHeight + baseWidth * baseWidth);\nconst x &#x3D; Math.sqrt(height * height + width * width);\nconst statusHeight &#x3D; StatusBar.currentHeight || 0;\nexport const isIos &#x3D; Platform.OS &#x3D;&#x3D;&#x3D; &#39;ios&#39;;\nexport const isWeb &#x3D; Platform.OS &#x3D;&#x3D;&#x3D; &#39;web&#39;;\nexport const isIphoneX &#x3D; isIos &amp;&amp; height &gt;&#x3D; 812;\nexport const HRatio &#x3D; width &#x2F; baseWidth;\nexport const VRatio &#x3D; height &#x2F; baseHeight;\nexport const winWidth &#x3D; width;\nexport const winHeight &#x3D; height;\nexport const viewWidth &#x3D; width;\nexport const viewHeight &#x3D; height - (isIos ? (isIphoneX ? 88 : 64) : 56 + statusHeight);\nlet finalRatio &#x3D; x &#x2F; baseX;\nif (baseWidth &#x3D;&#x3D;&#x3D; width &amp;&amp; finalRatio &gt; 1) &#123;\n  finalRatio &#x3D; 1;\n&#125;\nexport const ratio &#x3D; finalRatio;\nexport const convertX &#x3D; (width) &#x3D;&gt; (isWeb ? width : width * HRatio);\nexport const convertY &#x3D; (height) &#x3D;&gt; (isWeb ? height : height * VRatio);\nexport const convert &#x3D; (number) &#x3D;&gt; (isWeb ? number : number * ratio);\nexport const topBarHeight &#x3D; isIos ? (isIphoneX ? 88 : 64) : 56;\nexport const statusBarHeight &#x3D; isIos ? (isIphoneX ? 44 : 20) : statusHeight;\n\nexport const isSmallW &#x3D; width &lt; 375;\nexport const isSmallH &#x3D; height &lt; 667;\n\nconst getDimension &#x3D; () &#x3D;&gt; &#123;\n  if (isWeb) &#123;\n    try &#123;\n      return Dimensions.get(&#39;osWindow&#39;);\n    &#125; catch (error) &#123;\n      return Dimensions.get(&#39;window&#39;);\n    &#125;\n  &#125;\n  return Dimensions.get(&#39;window&#39;);\n&#125;;\n\n&#x2F;**\n * 安卓或 Web 环境下，屏幕宽度等参数是动态的;\n *&#x2F;\nexport default &#123;\n  get hRatio() &#123;\n    const &#123; width: actualWidth &#125; &#x3D; getDimension();\n    return actualWidth &#x2F; baseWidth;\n  &#125;,\n  get vRatio() &#123;\n    const &#123; height: actualHeight &#125; &#x3D; getDimension();\n    return actualHeight &#x2F; baseHeight;\n  &#125;,\n  get ratio() &#123;\n    const actualX &#x3D; Math.sqrt(height * height + width * width);\n    const &#123; width: actualWidth &#125; &#x3D; getDimension();\n    let actualRatio &#x3D; actualX &#x2F; baseX;\n    if (baseWidth &#x3D;&#x3D;&#x3D; actualWidth &amp;&amp; actualRatio &gt; 1) &#123;\n      actualRatio &#x3D; 1;\n    &#125;\n    return actualRatio;\n  &#125;,\n  get width() &#123;\n    return getDimension().width;\n  &#125;,\n  get height() &#123;\n    return getDimension().height;\n  &#125;,\n  get winWidth() &#123;\n    return getDimension().width;\n  &#125;,\n  get winHeight() &#123;\n    return getDimension().height;\n  &#125;,\n  get viewWidth() &#123;\n    return getDimension().width;\n  &#125;,\n  get viewHeight() &#123;\n    return getDimension().height - (isIos ? (isIphoneX ? 88 : 64) : 56 + statusHeight);\n  &#125;,\n  convertX: (number) &#x3D;&gt; &#123;\n    const &#123; width: actualWidth &#125; &#x3D; getDimension();\n    const hRatio &#x3D; actualWidth &#x2F; baseWidth;\n    return number * hRatio;\n  &#125;,\n  convertY: (number) &#x3D;&gt; &#123;\n    const &#123; height: actualHeight &#125; &#x3D; getDimension();\n    const vRatio &#x3D; actualHeight &#x2F; baseHeight;\n    return number * vRatio;\n  &#125;,\n  convert: (number) &#x3D;&gt; &#123;\n    const actualX &#x3D; Math.sqrt(height * height + width * width);\n    const &#123; width: actualWidth &#125; &#x3D; getDimension();\n    let actualRatio &#x3D; actualX &#x2F; baseX;\n    if (baseWidth &#x3D;&#x3D;&#x3D; actualWidth &amp;&amp; actualRatio &gt; 1) &#123;\n      actualRatio &#x3D; 1;\n    &#125;\n    return number * actualRatio;\n  &#125;,\n  get isSmallW() &#123;\n    return getDimension().width &lt; 375;\n  &#125;,\n  get isSmallH() &#123;\n    return getDimension().height &lt; 667;\n  &#125;,\n  isIos,\n  isIphoneX,\n  iPhoneX: isIphoneX,\n  topBarHeight,\n  statusBarHeight,\n&#125;;\n","slug":"2023-04-06rn","date":"2023-04-06T05:55:25.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"a48730f893eb3d8564a6e41f516078f2","title":"ossutil","content":"动机\n之前单张图使用 PicGo 进行上传，这次需要批量多目录处理\n阿里云 OSS 网页上传，会丢失目录层级关系\n批量将目录下的图片，及文件对应关系上传到阿里云 OSS,博客在线资源使用\n批量图片压缩，保留文件关系\n\n批量图片压缩ChatGPT 生成\n\npngquant 压缩工具pngquant\n我觉得吧，\n\n这个比 picGo，压缩效果要好，\n可以看效果是不是想要的，然后再进行上传\n\nbrew install pngquant\n\n压缩脚本\n\n\n\n脚本经过 ChatGPT 生成，加手动修正\n手动修正#!&#x2F;bin&#x2F;bash\n\n# 创建保存压缩结果的文件夹\nmkdir compressed_pngs\n\n# 遍历当前文件夹及其子文件夹中的所有.png文件并进行压缩\nfind . -name &quot;*.png&quot; -type f -print0 | while read -d $&#39;\\0&#39; file\ndo\n  # 获取文件所在目录相对于当前文件夹的路径，用于在输出文件夹中创建对应的文件夹\n  dir&#x3D;$(dirname &quot;$file&quot;)\n  relative_dir&#x3D;$&#123;dir#*&#x2F;&#125;\n  mkdir -p &quot;compressed_pngs&#x2F;$relative_dir&quot;\n\n  # 执行压缩命令，将压缩结果输出到新文件夹中对应的位置\n  # pngquant --quality&#x3D;70 --force &quot;$file&quot; --output &quot;compressed_pngs&#x2F;$relative_dir&#x2F;$(basename &quot;$file&quot;)&quot;\n\n\n  # 获取文件大小\n    size&#x3D;$(stat -f%z &quot;$file&quot;)\n    if ((size &gt; 61440)); then\n        # 文件大小大于60kb，进行压缩处理\n        echo &quot;Compressing $file...&quot;\n        pngquant --quality&#x3D;70 &quot;$file&quot; -o &quot;compressed_pngs&#x2F;$relative_dir&#x2F;$(basename &quot;$file&quot;)&quot;\n    else\n        # 文件大小小于等于60kb，直接复制到新文件夹\n        echo &quot;Copying $file...&quot;\n        cp &quot;$file&quot; &quot;compressed_pngs&#x2F;$relative_dir&#x2F;$(basename &quot;$file&quot;)&quot;\n    fi\ndone\n\nossutil安装安装\n配置\n配置\nRAM 访问控制\n访问域名和数据中心\n\n\n\n👑 ~&#x2F;Desktop $ ossutil config\n该命令创建将一个配置文件，在其中存储配置信息。\n\n请输入配置文件名,文件名可以带路径(默认为：&#x2F;Users&#x2F;haotian&#x2F;.ossutilconfig，回车将使用默认配置文件。如果用户设置为其它文件，在使用命令时需要将--config-file选项设置为该文件）：\n未输入配置文件，将使用默认配置文件：&#x2F;Users&#x2F;haotian&#x2F;.ossutilconfig。\n\n对于下述配置，回车将跳过相关配置项的设置，配置项的具体含义，请使用&quot;help config&quot;命令查看。\n请输入语言(CH&#x2F;EN，默认为：CH，该配置项将在此次config命令成功结束后生效)：\n请输入stsToken：\n请输入endpoint：   &#x2F;&#x2F; 文档：访问域名和数据中心\n请输入accessKeyID： &#x2F;&#x2F; 控制台：RAM 访问控制\n请输入accessKeySecret： &#x2F;&#x2F; 控制台：RAM 访问控制\n👑 ~&#x2F;Desktop $ code &#x2F;Users&#x2F;haotian&#x2F;.ossutilconfig\n👑 ~&#x2F;Desktop $ ossutil config\n该命令创建将一个配置文件，在其中存储配置信息。\n\n请输入配置文件名,文件名可以带路径(默认为：&#x2F;Users&#x2F;haotian&#x2F;.ossutilconfig，回车将使用默认配置文件。如果用户设置为其它文件，在使用命令时需要将--config-file选项设置为该文件）：\n未输入配置文件，将使用默认配置文件：&#x2F;Users&#x2F;haotian&#x2F;.ossutilconfig。\n\n对于下述配置，回车将跳过相关配置项的设置，配置项的具体含义，请使用&quot;help config&quot;命令查看。\n请输入endpoint：oss-cn-hangzhou.aliyuncs.com &#x2F;&#x2F; 这个查文档\n请输入accessKeyID：\n请输入accessKeySecret：\n请输入stsToken：\n\n批量上传👑 ~&#x2F;Desktop $ ossutil cp -r snapshots  oss:&#x2F;&#x2F;t-blog-images&#x2F;snapshots --update --recursive\nSucceed: Total num: 377, size: 18,455,467. OK num: 377(upload 332 files, 45 directories).\n\naverage speed 1197000(byte&#x2F;s)\n\n15.422068(s) elapsed\n👑 ~&#x2F;Desktop $\n\n\n\n可视化大屏资源👑 ~&#x2F;Desktop $ ossutil cp -r demo-html  oss:&#x2F;&#x2F;wrong --update --recursive\n\n其他图片压缩命令行pngquant --quality&#x3D;30 *.png\n","slug":"2023-03-17ossutil","date":"2023-03-17T01:12:02.000Z","categories_index":"阿里云","tags_index":"阿里云","author_index":"举手摘月亮"},{"id":"1a2c0f92af01c15fc4932e397caca413","title":"React jsx -> fiber -> dom 的转化","content":"读源码基础\n位运算\ncall、apply、bind 原理\n链表相关知识(单链表、双链表、循环链表)\n节流、防抖原理 ensureRootIsScheduled: if (existingCallbackNode !== null) &#123;\n设计模式相关知识\n安全相关知识\n栈（数组） pushProvider\nSet 合成事件存储注册\n\njsx -&gt; React.createElement\n\nReact.createElement -&gt; ReactElment 树\n\nReactElment -&gt; update -&gt; updateQueue -&gt; fiber\n\nReactElment 树 -&gt; fiber 树 -&gt; dom 树\n\n见下文 jsx 代码经 babel 到 ReactElment 树\njsx 代码经 babel 到 ReactElment 树\n\nthis.setState -&gt; fiber\n\n补 React 图解processUpdateQueue 源码解析processUpdateQueue 源码解析\n见 processUpdateQueue 源码\n如何计算新的 state见 getStateFromUpdate 源码\n\n\n到这里了\nnextProps 怎么会有 ReactElement 对象&#x2F;&#x2F; 2. 获取下级&#96;ReactElement&#96;对象\nlet nextChildren &#x3D; nextProps.children; &#x2F;&#x2F; 利用jsx的特点？\n\n见\n\n\nbeginworkstateNode: 类组件的 stateNode 是怎样的，hostElement 的 stateNode 是怎样的？\n\n父子组件的副作用, 这个与执行顺序有关，父子组件的顺序问题\n\nbubbleProperties\n\n\n\nbubbleProperties 源码\n\nbubbleProperties 根据 fiber.child 及 fiber.child.sibling 更新 subtreeFlags 和 childLanes, 主要是为了标记子树有没有更新,\n这样可以通过 fiber.subtreeFlags 快速判断子树是否有副作用钩子，不需要深度遍历.\n在 React17 版本后使用 subtreeFlags 替换了 finishWork.firstEffect 的副作用链表, 操作主要发生在 bubbleProperties 函数中, 核心代码如下\n\n作者：王八吉吉链接：https://juejin.cn/post/6977203911799406628来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\nclassInstance 的 render()\n\n\n\n如何取到次级节点第一个 fiber 的？reconcileChildren 用来向下构建 fiber 节点\n\n\nmarkUpdateLaneFromFiberToRoot 的 sourceFiber 不理解这个 sourceFiber 是如何取哪个作为 sourceFiber更新过程中，DOM 属性变化，不创建 DOM 对象，仅标记，commit 阶段会处理\n\nfiber.lanes\n如何区别 fiber.lanes 有没有渲染优先级？\n渲染优先级什么时候加到 fiber 上的？ markUpdateLaneFromFiberToRoot\n\nmarkUpdateLaneFromFiberToRoot\n\n\nprops 中有节点的标签信息？buton 变成 a 会怎样？\n\nfiber 的 flags 属性，什么时候赋值的，这里有用 fiber.flags &#x3D; 0 判断有没有副作用\nmarkUpdate\n\nmarkRef if (current.ref !== workInProgress.ref) &#123;  markRef(workInProgress);&#125;\n\n调和函数会给增、删、移动节点设置 fiber.flags\n\n\n为什么 lastEffect 指针不变呢？\n\n闭包和类的原始性能只有在极端场景下才会有明显的差别，极端情况是什么情况？Hook 什么时候与 fiber 关联的？\n\n\n\n副作用 hook 如何转化成 fiber.flags 的？\n\nhook 的 effect 什么时候形成链表的，如何形成的？TODO: 补充到自定义 ahooks（暂时不记得是哪篇需要的）\n\nupdateWorkInProgressHook 为什么是单步克隆，怎么不直接每次取一个 hook 用，所以不需要一次克隆所有\n\n\nmountState,mountReducer -&gt; dispatch -&gt; dispatchAction bind 进行 scheduleUpdateOnFiberupdateState,updateReducer -&gt; dispatch -&gt; dispatchAction bind 进行 scheduleUpdateOnFiber\n\nqueue.pending 是环形链表？ 1. 为什用环形链表？2. 如何找环形链表的入口？\n\n\n\npending -&gt; 新状态updateReducer 调用 basicStateReducer\n\n\n优先级如何产生 requestUpdateLane\n\ngetEventPriority 代码因长，放链接getEventPriority 源码\n\nDiscreteEventPriority 直接触发\nContinuousEventPriority 可能会继续触发\ncase &#39;message&#39;: 是 React 内部调度通过消息传递的调度优先级，会转化成事件优先级？\n\ncase &#39;message&#39;: &#123;\n      &#x2F;&#x2F; We might be in the Scheduler callback.\n      &#x2F;&#x2F; Eventually this mechanism will be replaced by a check\n      &#x2F;&#x2F; of the current priority on the native scheduler.\n      const schedulerPriority &#x3D; getCurrentSchedulerPriorityLevel();\n      switch (schedulerPriority) &#123;\n        case ImmediateSchedulerPriority:\n          return DiscreteEventPriority;\n        case UserBlockingSchedulerPriority:\n          return ContinuousEventPriority;\n        case NormalSchedulerPriority:\n        case LowSchedulerPriority:\n          &#x2F;&#x2F; TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\n          return DefaultEventPriority;\n        case IdleSchedulerPriority:\n          return IdleEventPriority;\n        default:\n          return DefaultEventPriority;\n      &#125;\n&#125;\ndefault:\n      return DefaultEventPriority;\n\n这个是异步的\n\n异步更新\n\n低优先级之前的高优先级被计算，放置到 baseState\n所有高优先级被计算，放置到 memoizedState\n第一个地优先级之前的高优先级，被干掉，其他的不变\n\nHook 的 state 计算有点复杂: baseQueue -&gt; newBaseState,newState 【未理解】QUES: 未理解\nhook.memoizedState &#x3D; newState; &#x2F;&#x2F; 搞不清楚这个newState的计算\nhook.baseState &#x3D; newBaseState; &#x2F;&#x2F;\nhook.baseQueue &#x3D; newBaseQueueLast;\nqueue.lastRenderedState &#x3D; newState; &#x2F;&#x2F;\n\n\n\nHook baseQueue 变化\n\n\n\n\n\n$$typeof\n\n为什么 React 元素有一个$$typeof 属性？\n动机： 验证一些不安全的可能性\n\nReact 元素（elements）是设计好的 plain object\n服务端没有办法存储 Symbol 类型的值，也无法添加。所以当原本的数据被替换成恶意的对象时，这个对象是不包含$$typeof 属性的\nReact 会检测合法的$$typeof 属性，不符合条件 React 就不会处理这个元素\n不支持 symbol 的浏览器会使用 0xeac7 (至于为什么选用0xeac7这个数字，Dan 给出的答案是，它很像 React)\n大意就是 Symbol.for()是可以在像类似 iframe 或者 worker 这种全局环境中都能独立标识一个值。所以$$typeof属性就不会影响到一些可以在全局环境中传递的React Element。或者当界面有多个副本存在时，也能agree到正确的$$typeof。\n\nReact 元素的$$typeof 属性\n验证：$$typeof\nisValidElement\nreconciliation兴趣与生活的冲突今天在思考一件非技术的事，之前在学 go 语言，后来一直在忙于“生活”，算是向生活妥协\n前些天看到有之前的同事也在朋友圈发 go 语言的代码，又勾起我的兴趣\n\n\n回归理性\ngo 语言好是好，相比于 java 来讲，“优雅知性”\n有多少家公司需要用（当然不谈云原生，没意义，因为很多公司在用 k8s，贡献的人却不多）\n除了某些巨头公司、新的创业公司，剩下的占比很大的是 java\n即使掌握了 go 语言，去创业公司？去巨头公司？可能性都不是很大，那剩下的就是自娱了，但时间和生活并不允许\n这时候就要向生活妥协了，做出让步，除了兴趣外，更重要的是生活\n\n妥协 和解妥协近义词\nreconciliation: 百度翻译为：调解;和解;协调;和谐一致\n哎～，这不就扯到 react reconciliation 了吗？(真的没想聊技术)\nreact 为什么对算法进行妥协（or 和解 or 做出让步）？原因：计算量大，谁受得了\n\n即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。\n如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂\n\n如何妥协？启发式算法\n两个不同类型的元素会产生出不同的树；\n开发者可以使用 key 属性标识哪些子元素在不同的渲染中可能是不变的\n\n小结😄 拉你回现实：技术源于生活, 服务生活\nvscode 折叠策略&quot;editor.foldingStrategy&quot;: &quot;indentation&quot;, &#x2F;&#x2F; 折叠策略，按照缩紧\n\nvsCode 代码块无法折叠收起问题&amp;代码块折叠&#x2F;展开快捷键\n为什么叫合成事件，如何合成，合成到什么样子？既然是合成事件\n\n肯定不是一一映射，如果一一映射叫：“映射事件”不是更好\n肯定不是仅作兼容，如果兼容叫：“adapt 事件”不是更好\n\n浅谈 React 合成事件\nDOMPluginEventSystem.js\nSimpleEventPlugin.registerEvents();\n&#x2F;&#x2F; 下面4组是合成事件，上面一组是事件一对一的映射\nEnterLeaveEventPlugin.registerEvents();\nChangeEventPlugin.registerEvents();\nSelectEventPlugin.registerEvents();\nBeforeInputEventPlugin.registerEvents();\n\nBeforeInputEventPlugin.js\nChangeEventPlugin.js\nEnterLeaveEventPlugin.js\nSimpleEventPluginDOMEventProperties.js\n合成事件具体表现&#x2F;&#x2F; BeforeInputEventPlugin.js\nfunction registerEvents() &#123;\n  registerTwoPhaseEvent(&#39;onBeforeInput&#39;, [&#39;compositionend&#39;, &#39;keypress&#39;, &#39;textInput&#39;, &#39;paste&#39;]);\n  registerTwoPhaseEvent(&#39;onCompositionEnd&#39;, [&#39;compositionend&#39;, &#39;focusout&#39;, &#39;keydown&#39;, &#39;keypress&#39;, &#39;keyup&#39;, &#39;mousedown&#39;]);\n  registerTwoPhaseEvent(&#39;onCompositionStart&#39;, [&#39;compositionstart&#39;, &#39;focusout&#39;, &#39;keydown&#39;, &#39;keypress&#39;, &#39;keyup&#39;, &#39;mousedown&#39;]);\n  registerTwoPhaseEvent(&#39;onCompositionUpdate&#39;, [&#39;compositionupdate&#39;, &#39;focusout&#39;, &#39;keydown&#39;, &#39;keypress&#39;, &#39;keyup&#39;, &#39;mousedown&#39;]);\n&#125;\n&#x2F;&#x2F; ChangeEventPlugin.js\nfunction registerEvents() &#123;\n  registerTwoPhaseEvent(&#39;onChange&#39;, [&#39;change&#39;, &#39;click&#39;, &#39;focusin&#39;, &#39;focusout&#39;, &#39;input&#39;, &#39;keydown&#39;, &#39;keyup&#39;, &#39;selectionchange&#39;]);\n&#125;\n&#x2F;&#x2F; EnterLeaveEventPlugin.js\nfunction registerEvents() &#123;\n  registerDirectEvent(&#39;onMouseEnter&#39;, [&#39;mouseout&#39;, &#39;mouseover&#39;]);\n  registerDirectEvent(&#39;onMouseLeave&#39;, [&#39;mouseout&#39;, &#39;mouseover&#39;]);\n  registerDirectEvent(&#39;onPointerEnter&#39;, [&#39;pointerout&#39;, &#39;pointerover&#39;]);\n  registerDirectEvent(&#39;onPointerLeave&#39;, [&#39;pointerout&#39;, &#39;pointerover&#39;]);\n&#125;\n&#x2F;&#x2F; SelectEventPlugin.js\nfunction registerEvents() &#123;\n  registerTwoPhaseEvent(&#39;onSelect&#39;, [\n    &#39;focusout&#39;,\n    &#39;contextmenu&#39;,\n    &#39;dragend&#39;,\n    &#39;focusin&#39;,\n    &#39;keydown&#39;,\n    &#39;keyup&#39;,\n    &#39;mousedown&#39;,\n    &#39;mouseup&#39;,\n    &#39;selectionchange&#39;,\n  ]);\n&#125;\n\n&#x2F;&#x2F; SimpleEventPlugin.js\n\n&#x2F;&#x2F; registerSimpleEvents -&gt;\nimport &#123; registerSimpleEvents &#125; from &#39;..&#x2F;DOMEventProperties&#39;;\nexport &#123; registerSimpleEvents as registerEvents, extractEvents &#125;;\n&#x2F;&#x2F; DOMEventProperties.js\nexport function registerSimpleEvents() &#123;\n  registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent &#x2F;*事件优先级 *&#x2F;);\n  registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent &#x2F;*事件优先级 *&#x2F;);\n  registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent &#x2F;*事件优先级 *&#x2F;);\n  setEventPriorities(otherDiscreteEvents, DiscreteEvent &#x2F;*事件优先级 *&#x2F;);\n&#125;\n\n&#x2F;*事件优先级： 见上文： getEventPriority *&#x2F;\n\nregisterSimplePluginEventsAndSetTheirPriorities\n注释说：给转化成二维数组放到 map 里面\n&#x2F;**\n * Turns\n * [&#39;abort&#39;, ...]\n *\n * into\n *\n * topLevelEventsToReactNames &#x3D; new Map([\n *   [&#39;abort&#39;, &#39;onAbort&#39;],\n * ]);\n *\n * and registers them.\n *&#x2F;\n\nfunction registerSimplePluginEventsAndSetTheirPriorities(eventTypes: Array&lt;DOMEventName | string&gt;, priority: EventPriority): void &#123;\n  &#x2F;&#x2F; 使用二维数组的好处，数据成对出现，不需要用3个数组来处理\n  for (let i &#x3D; 0; i &lt; eventTypes.length; i +&#x3D; 2) &#123;\n    const topEvent &#x3D; ((eventTypes[i]: any): DOMEventName); &#x2F;&#x2F; 见下图\n    const event &#x3D; ((eventTypes[i + 1]: any): string); &#x2F;&#x2F; 见下图\n    const capitalizedEvent &#x3D; event[0].toUpperCase() + event.slice(1);\n    const reactName &#x3D; &#39;on&#39; + capitalizedEvent; &#x2F;&#x2F; react的事件名\n    eventPriorities.set(topEvent, priority); &#x2F;&#x2F; 设置事件优先级\n    topLevelEventsToReactNames.set(topEvent, reactName);\n    registerTwoPhaseEvent(reactName, [topEvent]);\n  &#125;\n&#125;\n\n\n\n这个 nativeEvent 怎么搞进来？没发现呢bind 返回的 listener 被调用时候传进来的 nativeEvent?\n\n\n\n\n合成事件怎么晓得我操作哪个元素，进行回调？如果是 A、B 两个按钮：在使用的时候，点击 A 按钮，事件到达 根 DOM 容器，react 如何识别，使用调用了 A 按钮的 onClick,而不是 B 的 onClick\n\n\n\nAB 平级，假设也传递了其他数据的情况，怎么晓得是 A 还是 B 的回调\nA 内，B 外 嵌套，都会触发\n\n\n","slug":"2023-03-31createElement","date":"2023-03-13T05:57:13.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"072284d75a6848b3baf49e71f53b2857","title":"React StrictMode","content":"动机\nReact StrictMode 的源码长什么样子？\n执行过成是什么？为什么是标签，难道 React 内部实现了这个组件？\n\n查资料搜到的资料都是官网文档 和 React 官方博客 18 版本更新内容 的搬运\n翻源码clone react 源码， vscode 搜索一搜 😓，尴尬了，发现很多StrictMode, 硬着头皮，从第一行搜索结果，找到最后一行，嗯，没有想要的\n找入口文件import &#123;\n  ...\n  REACT_FRAGMENT_TYPE, &#x2F;&#x2F; Symbol.for(&#39;react.fragment&#39;)\n  &#x2F;&#x2F; ...\n  REACT_STRICT_MODE_TYPE, &#x2F;&#x2F; Symbol.for(&#39;react.strict_mode&#39;)\n  &#x2F;&#x2F; ...\n&#125; from &quot;shared&#x2F;ReactSymbols&quot;;\n\nexport &#123;\n  &#x2F;&#x2F; ...\n  REACT_FRAGMENT_TYPE as Fragment,\n  &#x2F;&#x2F; ...\n  REACT_STRICT_MODE_TYPE as StrictMode,\n  &#x2F;&#x2F; ...\n&#125;;\n\n\n这～～，确实没找到StrictMode组件\n我留了Fragment和StrictMode，不至于对StrictMode陌生\n\nQ&amp;A\n既然是组件，那肯定走了React.createElement方法，\nJSX 语法是看不到React.createElement调用的，中间一定存在转化\nReact 官方 和 babel 官方 合作，以去掉 React 引用\n中间执行转化的就是babel（js 语法解析器是 babel）\n\nbabel见\n时间穿梭图\n\n完整图\n\n看上去没有 ast explore（JSON 格式） 那么好看，ast explore 上没有 react 相关的，所以吧，凑合着看\n\n至此，与入口文件处的 symble 对应上了，在源码中不存在 StrictMode 组件，也说明了在源码中找组件的方式，是找不到的\n序号 1 对应 fiber 的 tag, React.createElement\n序号 2 属性 properties 相关\n序号 3 子节点\n\ncreateElement 源码也可一探究竟，其对参数 1、参数 2、参数 3 的处理\n见\nast explore\n\n总结在找StrictMode组件的过程中，\n\n学到了 babel 会将 jsx 转化啥样子\n一个变量怎么就可以当组件用了\n\n参考链接\nReact.createElement 源码\nbabel playground\ncreateelement\n18 版本更新内容\n\n","slug":"2023-03-10babel","date":"2023-03-10T09:14:04.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"547eb37eabbf2632d492b2d3c42b55d1","title":"Object.defineProperty","content":"是什么Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n&#x2F;&#x2F; 语法\nObject.defineProperty(obj, prop, descriptor);\n\n动机为了精确地添加或修改对象的属性\n赋值操作\n\n通过赋值操作添加的普通属性是\n可枚举的，在枚举对象属性时会被枚举到（for…in 或 Object.keys 方法），\n可改变这些属性的值，\n可以删除这些属性。\n\nObject.defineProperty这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。\n特点数据描述符和存取描述符对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。\n\n数据描述符：是一个具有值的属性，该值可以是可写的，也可以是不可写的。\n存取描述符：是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者\n\n描述符默认值\n拥有布尔值的键 configurable、enumerable 和 writable 的默认值都是 false。\n属性值和函数的键 value、get 和 set 字段的默认值为 undefined。\n\n\n\n\n\nconfigurable\nenumerable\nvalue\nwritable\nget\nset\n\n\n\n数据描述符(value&#x2F;writable)\n可以\n可以\n可以\n可以\n不可以\n不可以\n\n\n存取描述符(get&#x2F;set)\n可以\n可以\n不可以\n不可以\n可以\n可以\n\n\nfalse\nfalse\nfalse\nundefined\nfalse\nundefined\nundefined\n\n\n这些选项不一定是自身属性，也要考虑继承来的属性。为了确认保留这些默认值，在设置之前，可能要冻结 Object.prototype，明确指定所有的选项，或者通过 Object.create(null) 将 Object.prototype.__proto__ 属性指向 null\nObject.definePropertiesObject.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象\n&#x2F;&#x2F; 语法\nObject.defineProperties(obj, props);\n\n这里需要注意的是：props 是一个对象，而不是一个数组\nObject.defineProperties 实现原理Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象见\n\n校验传入的第一个参数需要是对象\n传入的第二个参数，先转为对象，然后处理成描述符\n遍历，将描述符添加到第一个参数对象上\n返回原对象\n\n\n实现原理源代码\nfunction defineProperties(obj, properties) &#123;\n  function convertToDescriptor(desc) &#123;\n    &#x2F;&#x2F; 是否有这个属性\n    function hasProperty(obj, prop) &#123;\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    &#125;\n    &#x2F;&#x2F; 是否可以被调用\n    function isCallable(v) &#123;\n      &#x2F;&#x2F; NB: modify as necessary if other values than functions are callable.\n      return typeof v &#x3D;&#x3D;&#x3D; &quot;function&quot;;\n    &#125;\n    &#x2F;&#x2F; 基本数据类型\n    if (typeof desc !&#x3D;&#x3D; &quot;object&quot; || desc &#x3D;&#x3D;&#x3D; null) throw new TypeError(&quot;bad desc&quot;);\n\n    var d &#x3D; &#123;&#125;;\n\n    &#x2F;*数据描述：可枚举、可配置、值、可改写*&#x2F;\n    if (hasProperty(desc, &quot;enumerable&quot;)) d.enumerable &#x3D; !!desc.enumerable;\n    if (hasProperty(desc, &quot;configurable&quot;)) d.configurable &#x3D; !!desc.configurable;\n    if (hasProperty(desc, &quot;value&quot;)) d.value &#x3D; desc.value;\n    if (hasProperty(desc, &quot;writable&quot;)) d.writable &#x3D; !!desc.writable;\n\n    &#x2F;*存储描述 *&#x2F;\n    function storeDesc(desc, key) &#123;\n      var g &#x3D; desc[key];\n      if (!isCallable(g) &amp;&amp; typeof g !&#x3D;&#x3D; &quot;undefined&quot;) throw new TypeError(&#96;bad $&#123;key&#125;&#96;);\n      d[key] &#x3D; g;\n    &#125;\n    &#x2F;&#x2F; 不再进一步封装\n    if (hasProperty(desc, &quot;get&quot;)) storeDesc(desc, &quot;get&quot;);\n    if (hasProperty(desc, &quot;set&quot;)) storeDesc(desc, &quot;set&quot;);\n\n    &#x2F;&#x2F; &#x2F;&#x2F; 如果有get，get需要是个函数\n    &#x2F;&#x2F; if (hasProperty(desc, &quot;get&quot;)) &#123;\n    &#x2F;&#x2F;   var g &#x3D; desc.get;\n    &#x2F;&#x2F;   if (!isCallable(g) &amp;&amp; typeof g !&#x3D;&#x3D; &quot;undefined&quot;) throw new TypeError(&quot;bad get&quot;);\n    &#x2F;&#x2F;   d.get &#x3D; g;\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; &#x2F;&#x2F; 如果有set，set需要是个函数\n    &#x2F;&#x2F; if (hasProperty(desc, &quot;set&quot;)) &#123;\n    &#x2F;&#x2F;   var s &#x3D; desc.set;\n    &#x2F;&#x2F;   if (!isCallable(s) &amp;&amp; typeof s !&#x3D;&#x3D; &quot;undefined&quot;) throw new TypeError(&quot;bad set&quot;);\n    &#x2F;&#x2F;   d.set &#x3D; s;\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; 描述符冲突\n    &#x2F;&#x2F; @link https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;defineProperty#:~:text&#x3D;%E4%B8%BA%20undefined%E3%80%82-,%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%AF%E6%8B%A5%E6%9C%89%E7%9A%84%E9%94%AE%E5%80%BC,-configurable\n    &#x2F;&#x2F; 1. 如果一个描述符不具有 value、writable、get 和 set 中的任意一个键，那么它将被认为是一个数据描述符。\n    &#x2F;&#x2F; 2. 如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常。\n    if ((&quot;get&quot; in d || &quot;set&quot; in d) &amp;&amp; (&quot;value&quot; in d || &quot;writable&quot; in d)) throw new TypeError(&quot;identity-confused descriptor&quot;);\n\n    return d;\n  &#125;\n  &#x2F;&#x2F; 被扩展的必须是对象\n  &#x2F;&#x2F; 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n  if (typeof obj !&#x3D;&#x3D; &quot;object&quot; || obj &#x3D;&#x3D;&#x3D; null) throw new TypeError(&quot;bad obj&quot;);\n  &#x2F;&#x2F; 转化成对象, Object是一个构造函数\n  properties &#x3D; Object(properties);\n  &#x2F;&#x2F; 遍历key\n  var keys &#x3D; Object.keys(properties);\n  var descs &#x3D; [];\n  &#x2F;&#x2F; &#x2F;&#x2F; 先转化成二维数组\n  &#x2F;&#x2F; for (var i &#x3D; 0; i &lt; keys.length; i++) descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n  &#x2F;&#x2F; &#x2F;&#x2F; 然后一个一个添加语法： Object.defineProperty(obj, prop, descriptor)\n  &#x2F;&#x2F; for (var i &#x3D; 0; i &lt; descs.length; i++) Object.defineProperty(obj, descs[i][0], descs[i][1]);\n\n  for (var i &#x3D; 0; i &lt; keys.length; i++) &#123;\n    Object.defineProperty(obj, keys[i], convertToDescriptor(properties[keys[i]]));\n  &#125;\n\n  &#x2F;&#x2F; 返回原对象\n  return obj;\n&#125;\n\n\n\nObject上面代码有行代码properties = Object(properties);\nObject 构造函数将给定的值包装为一个新对象。\n\n如果给定的值是 null 或 undefined, 它会创建并返回一个空对象。\n否则，它将返回一个和给定的值相对应的类型的对象。\n如果给定值是一个已经存在的对象，则会返回这个已经存在的值（相同地址）。\n在非构造函数上下文中调用时， Object 和 new Object()表现一致\n\n&#x2F;&#x2F; 1. 如果给定的值是 &#96;null&#96; 或 &#96;undefined&#96;, 它会创建并返回一个空对象。\nObject(null);\n&#x2F;&#x2F; &#123;&#125;\nObject(undefined);\n&#x2F;&#x2F; &#123;&#125;\n&#x2F;&#x2F; 2. &#96;否则，它将返回一个和给定的值相对应的类型的对象&#96;。\nObject(true);\n&#x2F;&#x2F; Boolean &#123;true&#125;\nObject(1);\n&#x2F;&#x2F; Number &#123;1&#125;\nObject(&quot;1212&quot;);\n&#x2F;&#x2F; String &#123;&#39;1212&#39;&#125;\n&#x2F;&#x2F; 3. &#96;如果给定值是一个已经存在的对象，则会返回这个已经存在的值（相同地址）&#96;。\nvar a &#x3D; &#123; name: 1 &#125;;\nObject(a);\n&#x2F;&#x2F; &#123;name: 1&#125;\n\nvar a &#x3D; [1, 2, 3];\nObject(a);\n&#x2F;&#x2F; [1, 2, 3]\n\n参考链接\nMDN\n&#x2F;#&#x2F;post&#x2F;2022-07-04js\n\n","slug":"2023-03-09defineProperty","date":"2023-03-09T07:09:55.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"fa1ca6ffeb14e68321654370d8f81adc","title":"vue vs react","content":"vue 对比 react动机数据驱动，提升开发体验，避免对 dom 的直接操作（原生&#x2F;jquery）\n发展上vue 由借鉴 react 和 angular，现在更多的是追逐着 react 的脚步\n\n声明周期的重命名\n新的支持：hook、suspense、Teleport\n支持 typescript\n\n目前 vue 暂时没有支持 react18 新特性如：useId、useTransition、useDeferredValue、useSyncExternalStore、useInsertionEffect\n破坏性变更\nvue2 与 vue3 不是同一个库了\nreact 是同一个库，但对 class 组件的周期进行部分废弃，以解决异步问题\nreact 本身支持 FP(面向函数) &amp; OOP(面向对象)，vue2 是 OOP(面向对象)，vue3 FP(面向函数)&#x2F;选项式 &amp; OOP(面向对象)&#x2F;组合式\n\n扩展上\nvue 即使增加组合 API 也没有 JSX 灵活\n新技术生态 css-in-js 在 react 中支持，useInsertionEffect\n\n编程体验上\nreact 在使用上 jsx，有种大开大合的感觉\nvue 语法 template 应该是借鉴了 web component, 虽然看上去 slot 是灵活，但总没有一个变量灵活吧\nvue 语法很零碎，看上去为了解决问题而临时采取的措施\n\n支持的场景\n\n\njs 库\nreact\nvue\n\n\n\nSPA\n\n\n\n\nSSR\nnextjs\nnuxtjs\n\n\nSSG\n\n\n\n\nCSR\n\n\n\n\n实现上\nreact 编码是书写，运行时分析，构建虚拟树\nvue 是编码时监听，监听更新，构建&#x2F;不构建进行更新\n\n生态上react 相较于 vue，有更强大的生态，更快的更新速度\n\n\n\njs 库\nreact\nvue\n\n\n\n状态管理\nredux、mobx、\nvuex 、pinia\n\n\n路由\nreact-router-dom\nvue-router\n\n\nUI\nantd、material-ui、antd-mobile\nantd-vue、element-ui、vuetifyjs\n\n\nhook\nahooks\nhttps://vueuse.org/\n\n\n衍生\nreact-native\nweex、uniapp\n\n\n衍生\nflutter\n各大厂小程序\n\n\n多端\ntaro\ntaro\n\n\n桌面端\nElectron\nElectron\n\n\n谈感觉\n在不考虑底层的情况下，二者 API 几乎相似，尤其是 vue3 的组合式 API 与 React 的 hook 极为相似\n当然 vue 的数据监听是拦截的，数据看上去直接改了就生效，很简单的(react+mobx 也可实现)，而 react 有点 java 的味道，改变数据需要 setXXX\n\n参考链接\n再学 Vue3-0 概览\n再学 Vue3-1 基础\n再学 Vue3-2 v3\n再学 Vue3-3 深入组件\n再学 Vue3-4 可重用性\n再学 Vue3-5 内置组件\n再学 Vue3-6 升级规模\n再学 Vue3-7 最佳实践\n再学 Vue3-8 typescript\nVue Pinia\npinia 源码分析 playground\npinia 中的 vue-demi 源码\npinia 源码\n\n脚本function getalink(_domlist) &#123;\n  var data &#x3D; &quot;&quot;;\n\n  Array.from(_domlist).forEach((li) &#x3D;&gt; &#123;\n    var a &#x3D; li.getElementsByTagName(&quot;a&quot;)[0];\n    var href &#x3D; a.href.replace(&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;&quot;, &quot;&quot;);\n    var title &#x3D; a.innerText;\n    var astr &#x3D; &#96;1. &lt;a href&#x3D;&quot;$&#123;href&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;title&#125;&lt;&#x2F;a&gt; \\n&#96;;\n    data +&#x3D; astr;\n  &#125;);\n  copy(data); &#x2F;&#x2F;控制台直接拷贝到剪切板\n&#125;\ngetalink(temp1.children);\n","slug":"2023-03-09vue_vs_react","date":"2023-03-09T06:12:58.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"321b3776a189b2e51803e56cf34e14e0","title":"“位运算符”的使用场景","content":"按位与 &amp;特点\n奇数&amp;1 恒等于 1\n偶数&amp;1 恒等于 0\n\n动态规划使用场景&#x2F;&#x2F; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。\n&#x2F;&#x2F; 你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。\n\n&#x2F;&#x2F; 在循环的过程中，不断替换其中的值， 最后的结果，就是所有的方法数\nfunction minCost(cost) &#123;\n  &#x2F;&#x2F; 定义一个变量\n  let len &#x3D; cost.length;\n  &#x2F;&#x2F; 定义两个变量\n  let dp &#x3D; [cost[0], cost[1]];\n\n  for (let i &#x3D; 2; i &lt; len; i++) &#123;\n    &#x2F;&#x2F; 0&#x2F;1 下标数组， 偶数 &amp; 1 &#x3D; 0， 奇数 &amp; 1 &#x3D;1\n    dp[i &amp; 1] &#x3D; Math.min(dp[0], dp[1]) + cost[i];\n    console.log(&#96;dp[$&#123;i &amp; 1&#125;]&#96;, i, dp[i &amp; 1], dp);\n  &#125;\n\n  &#x2F;&#x2F; 循环结束后\n  return Math.min(dp[0], dp[1]);\n&#125;\n\nvar a &#x3D; minCost([1, 2, 3, 4, 5]);\n\nconsole.log(&quot;a&quot;, a);\n\n动态规划 fibonaccifunction fibonacci(n) &#123;\n  let result &#x3D; [1, 1];\n\n  for (let i &#x3D; 2; i &lt; n; i++) &#123;\n    &#x2F;&#x2F; 当前  &#x3D; 数组的第一个+数组的第二个\n    result[i &amp; 1] &#x3D; result[(i - 2) &amp; 1] + result[(i - 1) &amp; 1];\n    console.log(&#96;$&#123;i&#125; result[$&#123;i &amp; 1&#125;] &#x3D; result[$&#123;(i - 2) &amp; 1&#125;] + result[$&#123;(i - 1) &amp; 1&#125;];&#96;, result[i &amp; 1]);\n  &#125;\n  return result[(n - 1) &amp; 1];\n&#125;\n\nvar a &#x3D; fibonacci(5);\n\nconsole.log(&quot;a&quot;, a);\n\n&#x2F;&#x2F; 输出日志， 这里不要过度关注顺序\n&#x2F;&#x2F; 2 result[0] &#x3D; result[0] + result[1]; 2\n&#x2F;&#x2F; 3 result[1] &#x3D; result[1] + result[0]; 3\n&#x2F;&#x2F; 4 result[0] &#x3D; result[0] + result[1]; 5\n&#x2F;&#x2F; a 5\n\nReact 源码中\n优先级管理 lanes 见\nflags 见\n文档\n\n总结从输出的结果来看 1 是最有用的，其他的意义不大\nconst obj &#x3D; &#123;\n  0: &quot;000&quot;,\n  1: &quot;001&quot;,\n  2: &quot;010&quot;,\n  3: &quot;011&quot;,\n  4: &quot;100&quot;,\n  5: &quot;101&quot;,\n&#125;;\n\nfunction bitwiseAnd(arr) &#123;\n  for (let i &#x3D; 0; i &lt;&#x3D; 5; i++) &#123;\n    console.log(&quot;-------------,-------------&quot;);\n    for (let j &#x3D; 0; j &lt; arr.length; j++) &#123;\n      console.log(&#96;$&#123;i&#125;进制i&#x3D;$&#123;obj[i]&#125;&#96;, &quot;j&amp;i&quot;, j &amp; i);\n    &#125;\n  &#125;\n&#125;\n\nbitwiseAnd([0, 1, 2, 3, 4, 5, 6, 7] &#x2F;*数组的元素为数组的下标0-7 *&#x2F;);\n&#x2F;&#x2F; -------------,-------------\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; 0进制i&#x3D;000 j&amp;i 0\n&#x2F;&#x2F; -------------,-------------\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 0\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 1\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 0\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 1\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 0\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 1\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 0\n&#x2F;&#x2F; 1进制i&#x3D;001 j&amp;i 1\n&#x2F;&#x2F; -------------,-------------\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 0\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 0\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 2\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 2\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 0\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 0\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 2\n&#x2F;&#x2F; 2进制i&#x3D;010 j&amp;i 2\n&#x2F;&#x2F; -------------,-------------\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 0\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 1\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 2\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 3\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 0\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 1\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 2\n&#x2F;&#x2F; 3进制i&#x3D;011 j&amp;i 3\n&#x2F;&#x2F; -------------,-------------\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 0\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 0\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 0\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 0\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 4\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 4\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 4\n&#x2F;&#x2F; 4进制i&#x3D;100 j&amp;i 4\n&#x2F;&#x2F; -------------,-------------\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 0\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 1\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 0\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 1\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 4\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 5\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 4\n&#x2F;&#x2F; 5进制i&#x3D;101 j&amp;i 5\n\n\n\n参考链接\n&#x2F;#&#x2F;post&#x2F;2023-03-062023js\n&#x2F;#&#x2F;post&#x2F;2022-07-04js\n\n","slug":"2023-03-07按位操作","date":"2023-03-07T08:42:34.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"0e8399ece48a5643474d22f61ba561e0","title":"2023前端面试真题之JS篇","content":"JS 执行流程\n\n准备工作: 需要准备执行 JS 时所需要的一些基础环境\n初始化了内存中的堆和栈结构\nJS 全局执行上下文: 包含了执行过程中的全局信息， 比如一些内置函数，全局变量等信息\n全局作用域:包含了一些全局变量， 在执行过程中的数据都需要存放在内存中\n初始化消息循环系统: 消息驱动器, 消息队列\n\n\n\n执行流程\n\n\nV8 接收到要执行的 JS 源代码 源代码对 V8 来说只是一堆字符串，V8 并不能直接理解这段字符串的含义\nV8 结构化这段字符串,生成了&#123;抽象语法树|AST&#125;,同时还会生成相关的作用域\n生成字节码（介于 AST 和机器代码的中间代码）, 与特定类型的机器代码无关\n解释器(ignition)，按照顺序解释执行字节码，并输出执行结果。\n从图中得出一个结论：执行 JS 代码核心流程\n先编译\n后执行\n\n\n\n通过 V8 将 js 转换为字节码然后经过解释器执行输出结果的方式执行 JS，有一个弊端就是，\n如果在浏览器中再次打开相同的页面，当页面中的 JavaScript 文件没有被修改，再次编译之后的二进制代码也会保持不变，意味着编译这一步浪费了 CPU 资源。\n为了，更好的利用 CPU 资源，V8 采用JIT（Just In Time）技术提升效率: 而是混合编译执行和解释执行这两种手段。\n\n解释执行的启动速度快，但是执行时的速度慢\n编译执行的启动速度慢，但是执行时的速度快\n\nJust-in-time 编译器：综合了解释器和编译器的优点为了解决解释器的低效问题，后来的浏览器把编译器也引入进来，形成混合模式。在 JavaScript 引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息。\n如果同一行代码运行了几次，这个代码段就被标记成了 warm，如果运行了很多次，则被标记成 hot\nes6 新特性易用性\n\n声明：const 和 let\n解构赋值\n模板字符串\n函数的扩展\n函数的默认值\nrest 参数\n函头函数\n\n\n数组的扩展\nArray.from()将类数组转为数组\nfind()、findIndex()找出第一个符合条件的成员&#x2F;下标\nentries()、keys()、values() 用于遍历数组。（配合 for…of)\nincludes() 是否存在指定无素(返回布尔值)\n\n\n对象的扩展\n属性名可使用表达式\nObject.assign()\nObject.keys(), Object.values(), Object.entries()\n\n\nSymbol、Set、Map、WeakSet、WeakMap\nPromise\nIterator 和 for…of\n为各种数据提供统一的，简便的访问接口\n\n\nGenerator 与 async await\n\nPromise VS async&#x2F;await动机，原理，相比较\npromisePromise 对象就是为了解决回调地狱而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。\n分析 Promise 的调用流程：\n\nPromise 的构造方法接收一个 executor()，在 new Promise()时就立刻执行这个 executor 回调\nexecutor()内部的异步任务被放入宏&#x2F;微任务队列，等待执行\nthen()被执行，收集成功&#x2F;失败回调，放入成功&#x2F;失败队列\nexecutor() 的异步任务被执行，触发 resolve&#x2F;reject，从成功&#x2F;失败队列中取出回调依次执行\n\n其实熟悉设计模式，很容易就能意识到这是个观察者模式，这种方式，被广泛运用于观察者模式的实现，\n\n收集依赖\n触发通知\n取出依赖执行\n\n在 Promise 里，执行顺序是\n\nthen 收集依赖\n异步触发 resolve\nresolve 执行依赖。\n\n5K 字 由浅入深聊聊 Promise 实现原理\n\n实现原理源代码\n&#x2F;&#x2F; https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7194257890893365308\n\nconst PENDING &#x3D; &quot;pending&quot;;\nconst FULFILLED &#x3D; &quot;fulfilled&quot;;\nconst REJECTED &#x3D; &quot;rejected&quot;;\n\nclass CustomPromise &#123;\n  status &#x3D; PENDING;\n  &#x2F;&#x2F; 成功之后的值\n  value &#x3D; undefined;\n  &#x2F;&#x2F; 失败之后的值\n  reason &#x3D; undefined;\n\n  &#x2F;&#x2F; 存储成功回调函数\n  onResolvedCallbacks &#x3D; [];\n  &#x2F;&#x2F; 存储失败回调函数\n  onFulfilledCallbacks &#x3D; [];\n\n  constructor(executor) &#123;\n    executor(this.resolve, this.reject);\n  &#125;\n  &#x2F;&#x2F; resolve和reject为什么要用箭头函数？\n  &#x2F;&#x2F; 如果直接调用的话，普通函数this指向的是window或者undefined\n  &#x2F;&#x2F; 用箭头函数就可以让this指向当前实例对象\n  resolve &#x3D; (value) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; promise只能从pending到rejected, 或者从pending到fulfilled\n    if (this.status &#x3D;&#x3D; PENDING) &#123;\n      this.status &#x3D; FULFILLED;\n      this.value &#x3D; value;\n      &#x2F;&#x2F; REVIEW:\n      &#x2F;&#x2F; resolve里面将所有成功的回调拿出来执行\n      console.log(&quot;this.onResolvedCallbacks.length&quot;, this.onResolvedCallbacks.length);\n      if (this.onResolvedCallbacks.length) &#123;\n        this.onResolvedCallbacks.forEach((fn) &#x3D;&gt; &#123;\n          fn();\n        &#125;);\n      &#125;\n    &#125;\n  &#125;;\n  reject &#x3D; (err) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; promise只能从pending到rejected, 或者从pending到fulfilled\n    if (this.status &#x3D;&#x3D; PENDING) &#123;\n      this.status &#x3D; REJECTED;\n      this.reason &#x3D; err;\n      &#x2F;&#x2F; reject里面将所有失败的回调拿出来执行\n      &#x2F;&#x2F; REVIEW:\n      console.log(&quot;this.onFulfilledCallbacks.length&quot;, this.onFulfilledCallbacks.length);\n      if (this.onFulfilledCallbacks.length) &#123;\n        this.onFulfilledCallbacks.forEach((fn) &#x3D;&gt; &#123;\n          fn();\n        &#125;);\n      &#125;\n    &#125;\n  &#125;;\n\n  then(onFulfilled, onRejected) &#123;\n    &#x2F;&#x2F; 如果不传，就使用默认函数,确保是函数类型\n    onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onFulfilled : (value) &#x3D;&gt; value;\n    &#x2F;&#x2F; prettier-ignore\n    onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onRejected : (reason) &#x3D;&gt; &#123;throw reason;&#125;;\n\n    &#x2F;&#x2F; 因为是链式调用，所以需要返回一个promise\n    const thenCustomPromise &#x3D; new CustomPromise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 将逻辑抽取为一个函数,用于执行.then中的方法，并返回\n      const resolveCustomPromise &#x3D; (callBack, value) &#x3D;&gt; &#123;\n        console.log(callBack);\n        try &#123;\n          &#x2F;&#x2F; TODO: 这里立即成执行callBack（ onFulfilled&#x2F;onRejected）的结果\n          const res &#x3D; callBack(value);\n          &#x2F;&#x2F; 如果相等了，说明return的是自己，抛出类型错误并返回\n          if (resolveCustomPromise &#x3D;&#x3D;&#x3D; res) &#123;\n            return reject(new TypeError(&quot;类型错误&quot;));\n          &#125;\n          &#x2F;&#x2F; REVIEW: 这里是假设，then这个东西可能是一个promise&#x2F;也可能是非promise\n\n          &#x2F;&#x2F; 判断x是不是 CustomPromise 实例对象\n          if (res instanceof CustomPromise) &#123;\n            &#x2F;&#x2F; 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected\n            &#x2F;&#x2F; x.then(value &#x3D;&gt; resolve(value), error &#x3D;&gt; reject(reason))\n            &#x2F;&#x2F; 简化之后\n            res.then(resolve, reject);\n          &#125; else &#123;\n            &#x2F;&#x2F; 普通值\n            resolve(res);\n          &#125;\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 需要判断状态，根据状态选择处理回调函数\n      if (this.status &#x3D;&#x3D; FULFILLED) &#123;\n        resolveCustomPromise(onFulfilled, this.value);\n      &#125; else if (this.status &#x3D;&#x3D; REJECTED) &#123;\n        resolveCustomPromise(onRejected, this.reason);\n      &#125; else if (this.status &#x3D;&#x3D; PENDING) &#123;\n        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行\n\n        &#x2F;&#x2F; REVIEW: 什么时候会出现多个的情况，好像没有吧？\n\n        &#x2F;&#x2F; 哦哦哦～，这是把所有的then的回调，先都给收集了进来？\n        &#x2F;&#x2F; 1.问：为什么说是“先”？ 因为上边的status为pending状态的时候，.then的回调是没有被处理的，收集起来，之后进行处理\n        &#x2F;&#x2F; 2.问：之后怎么处理？ 因为这里被转授权的地方是个promise，那么就等它有权的时候往下执行，往下执行分为resolve和reject\n        &#x2F;&#x2F; 所以这些回调会放到实例对应的resolve和reject进行遍历处理\n        this.onResolvedCallbacks.push(() &#x3D;&gt; resolveCustomPromise(onFulfilled, this.value));\n        this.onFulfilledCallbacks.push(() &#x3D;&gt; resolveCustomPromise(onRejected, this.reason));\n      &#125;\n    &#125;);\n    return thenCustomPromise;\n  &#125;\n  catch(onFulfilled) &#123;\n    return this.then(null, onFulfilled);\n  &#125;\n  &#x2F;&#x2F; 1. 返回一个新的promise\n  &#x2F;&#x2F; 2. 不影响之前返回的promise对象\n  &#x2F;&#x2F; 3. finally为什么不返回数据，没有意义，finally返回一个promise，之后还可能继续进行其他操作，所以这时候返回数据是没有意义的\n  &#x2F;&#x2F; Promise.resolve(1)\n  &#x2F;&#x2F; .finally(()&#x3D;&gt;&#123;console.log(&#39;f1&#39;)&#125;)\n  &#x2F;&#x2F; .then(res&#x3D;&gt;&#123;console.log(res)&#125;)\n  &#x2F;&#x2F; .finally(()&#x3D;&gt;&#123;console.log(&#39;f2&#39;)&#125;)\n  &#x2F;&#x2F; 结果打印：\n  &#x2F;&#x2F; f1\n  &#x2F;&#x2F; 1\n  &#x2F;&#x2F; f2\n\n  &#x2F;&#x2F; MDN: 由于无法知道 promise 的最终状态，所以 finally 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况\n\n  &#x2F;&#x2F; Promise.resolve(&#39;1&#39;).finally(res&#x3D;&gt;&#123;\n  &#x2F;&#x2F;   console.log(&#39;finaly&#39;, res)\n  &#x2F;&#x2F; &#125;).then(res&#x3D;&gt; &#123;console.log(&#39;then&#39;,res)&#125;)\n  &#x2F;&#x2F; finaly undefined\n  &#x2F;&#x2F; then 1\n  finally(callBack) &#123;\n    return this.then(\n      (value) &#x3D;&gt; &#123;\n        CustomPromise.resolve(callBack(&#x2F;*这里没有数据 *&#x2F;)).then(() &#x3D;&gt; value);\n      &#125;,\n      (reason) &#x3D;&gt; &#123;\n        CustomPromise.reject(callBack(&#x2F;*这里没有数据 *&#x2F;)).then(() &#x3D;&gt; reason);\n      &#125;\n    );\n  &#125;\n\n  &#x2F;&#x2F; Promise.resolve\n  &#x2F;&#x2F; 1. 如果参数是 Promise 的实例，原封不动的返回\n  &#x2F;&#x2F; 2. 如果参数是 then()方法的对象，会将这个对象转化为promise对象，然后立即执行 thenable 对象的 then 方法\n  &#x2F;&#x2F; 3. 如果是原始值，或者是不具有 then()方法的对象，返回一个新的 promise ,状态为 resolved\n  &#x2F;&#x2F; 4. 允许不带参数，直接返回一个 resolved 状态的 Promise对象\n  static resolve(value) &#123;\n    if (value instanceof CustomPromise) return value;\n    return new CustomPromise((resolve) &#x3D;&gt; resolve(value));\n  &#125;\n  &#x2F;&#x2F; 返回一个Promise实例，并且携带reason\n  static reject(reason) &#123;\n    return new CustomPromise((_, reject) &#x3D;&gt; reject(reason));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 测试数据\nconst promise &#x3D; new CustomPromise((resolve, reject) &#x3D;&gt; &#123;\n  resolve(&quot;start&quot;);\n&#125;);\n\npromise\n  .then((res) &#x3D;&gt; &#123;\n    console.log(&quot;第1个&quot;, res);\n    return new CustomPromise((resolve, reject) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        resolve(&quot;hellow&quot;);\n      &#125;, 1000);\n    &#125;);\n  &#125;)\n  .then(\n    (res) &#x3D;&gt; &#123;\n      console.log(&quot;第2个&quot;, res);\n      return &quot;promise&quot;;\n    &#125;,\n    (err) &#x3D;&gt; &#123;\n      console.log(&quot;err&quot;, err);\n    &#125;\n  )\n  .then((res) &#x3D;&gt; &#123;\n    console.log(&quot;第3个&quot;, res);\n  &#125;);\n&#x2F;&#x2F; 尾部有个then，只不过这个是个空的\n&#x2F;&#x2F; 输出结果 start-&gt;hellow-&gt;promise\n\n\n\nasync awaitasync&#x2F;await 实际上是对 Generator（生成器）的封装，是一个语法糖。\n*/yield 和 async/await 看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：\n\nasync&#x2F;await 自带执行器，不需要手动调用 next()就能自动执行下一步\nasync 函数返回值是 Promise 对象，而 Generator 返回的是生成器对象\nawait 能够返回 Promise 的 resolve&#x2F;reject 的值\n不管 await 后面跟着的是什么，await 都会阻塞后面的代码\n\n仅“2k”字就能理解的 async&#x2F;await 原理\n\n实现原理源代码\n;\n&#x2F;&#x2F; function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，\n&#x2F;&#x2F; 它返回一个 Generator 对象\n&#x2F;&#x2F; generator对象由生成器函数生成\n\n&#x2F;&#x2F;接受一个Generator函数作为参数\nfunction myAsync(gen) &#123;\n  &#x2F;&#x2F; 返回一个函数\n  return function () &#123;\n    &#x2F;&#x2F; 返回一个promise\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 执行Generator函数\n      &#x2F;&#x2F; generator返回什么\n      let g &#x3D; gen();\n\n      const next &#x3D; (context) &#x3D;&gt; &#123;\n        let res;\n        try &#123;\n          res &#x3D; g.next(context);\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n        if (res.done) &#123;\n          &#x2F;&#x2F; 这时候说明已经是完成了，需要返回结果\n          resolve(res.value);\n        &#125; else &#123;\n          &#x2F;&#x2F; 继续执行next函数,传入执行结果\n          return Promise.resolve(res.value).then(\n            (val) &#x3D;&gt; next(val),\n            (err) &#x3D;&gt; next(err)\n          );\n        &#125;\n      &#125;;\n      next();\n    &#125;);\n  &#125;;\n&#125;\n&#x2F;&#x2F; prettier-ignore\nconst getFetch &#x3D; (nums) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(nums + 1);\n  &#125;, 1000);\n&#125;);\n\nfunction* gen() &#123;\n  let res1 &#x3D; yield getFetch(1);\n  let res2 &#x3D; yield getFetch(res1);\n  let res3 &#x3D; yield getFetch(res2);\n  return res3;\n&#125;\n\nconst asyncGen &#x3D; myAsync(gen &#x2F;*传入generator *&#x2F;);\n\nasyncGen().then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;); &#x2F;&#x2F; 4\n\n\n\n两者的区别动机\n\nPromise 的出现\n解决了传统 callback 函数导致的地域回调问题，\n但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。\n\n\n而 async await\n代码看起来会简洁些，使得异步代码看起来像同步代码，\nawait 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。\n\n\n\n功能\n\nasync&#x2F;await 与 Promise 一样，是非阻塞的。\nasync&#x2F;await 是基于 Promise 实现的，可以说是改良版的 Promise\n\nES6 迭代器\n可迭代协议： 实现 Iterable 接口（可迭代协议）要求同时具备两种能力\n支持迭代的自我识别能力\n创建实现 Iterator 接口的对象的能力\n\n\n这意味着必须暴露一个属性作为默认迭代器,\n这个属性必须使用特殊的 Symbol.iterator 作为键,\n这个默认迭代器属性必须引用一个迭代器工厂函数。\n调用这个工厂函数必须返回一个新迭代器\n\n内置类型都实现了 Iterable 接口\n字符串、数组\nMap、Set\narguments 对象、NodeList 等 DOM 集合类型\n\n迭代器协议 MDN\n迭代器 API\n\n使用 next()方法在可迭代对象中遍历数据,\n每次成功调用 next(),都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。\n\n\nnext()方法返回的迭代器对象 IteratorResult 包含两个属性\n\ndone： 一个布尔值，表示是否还可以再次调用 next()取得下一个值\nvalue：包含可迭代对象的下一个值\n\n\n\n每个迭代器都表示对可迭代对象的一次性有序遍历\n设计模式设计模式的分类\n总体来说设计模式分为三大类：(C5S7B11)\n\n创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n结构型模式，共七种：适配器模式、装饰器模式、代理模式、桥接模式、组合模式、享元模式、外观模式。\n行为型模式，共十一种：策略模式、模板方法模式、观察者模式/发布订阅模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n单例模式（4 中实现）1. 闭包实现-变量参数\n实现原理源代码\n&#x2F;&#x2F; 闭包实现\nlet CreateSingleton &#x3D; (function () &#123;\n  let instance;\n  return function (name) &#123;\n    if (instance) return instance;\n    this.name &#x3D; name;\n    &#x2F;&#x2F;  return (instance &#x3D; this); &#x2F;&#x2F; 这个地方不是很好理解,改写为下面两行\n    instance &#x3D; this;\n    return instance;\n  &#125;;\n&#125;)();\n\nCreateSingleton.prototype.getName &#x3D; function () &#123;\n  console.log(this.name);\n&#125;;\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 测试\nlet Winner &#x3D; new CreateSingleton(&quot;Winner&quot;);\nlet Looser &#x3D; new CreateSingleton(&quot;Looser&quot;);\n\nconsole.log(Winner &#x3D;&#x3D;&#x3D; Looser); &#x2F;&#x2F; true\nconsole.log(Winner.getName()); &#x2F;&#x2F; &#39;Winner&#39;\nconsole.log(Looser.getName()); &#x2F;&#x2F; &#39;Winner&#39;\n\n\n\n2. 闭包实现-函数参数2022-10-27 设计模式 – 单例模式\n3. 类构造函数实现2022-10-27 设计模式 – 单例模式\n4. 类静态方法实现2022-10-27 设计模式 – 单例模式\n观察者模式观察者模式（JavaScript 实现）\n\n实现原理源代码\n&#x2F;&#x2F; 定义observe\nconst queuedObservers &#x3D; new Set();\nconst observe &#x3D; (fn) &#x3D;&gt; queuedObservers.add(fn);\n&#x2F;&#x2F; prettier-ignore\nconst observable &#x3D; (obj) &#x3D;&gt; new Proxy(obj, &#123;\n    set(target, key, value, receiver) &#123;\n      const result &#x3D; Reflect.set(target, key, value, receiver);\n      &#x2F;&#x2F; notify\n      queuedObservers.forEach((observer) &#x3D;&gt; observer());\n      return result;\n    &#125;,\n  &#125;);\n\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试\n\nobj &#x3D; observable(&#123;\n  name: &quot;789&quot;,\n&#125;);\n\nobserve(function test() &#123;\n  console.log(&quot;触发了&quot;);\n&#125;);\n\nobj.name &#x3D; &quot;前端柒八九&quot;;\n&#x2F;&#x2F; 触发了\n&#x2F;&#x2F; 前端柒八九\n\n\n\n发布订阅模式见：2022-07-04js\n\n实现原理源代码\n&#x2F;&#x2F; 1. 监听收集（on&#x2F;once）\n&#x2F;&#x2F; 2. 触发监听(emit)\n&#x2F;&#x2F; 3. 解除监听(off)\n&#x2F;&#x2F; 4. 清空监听(clear)\nclass EventBus &#123;\n  constructor() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n  &#x2F;&#x2F; 监听，给对象添加方法\n  on(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) &#123;\n      events[name] &#x3D; [];\n    &#125;\n    events[name].push(callback);\n  &#125;\n  &#x2F;&#x2F; 取出来执行\n  emit(name, ...args) &#123;\n    const handlers &#x3D; this.events[name];\n    handlers &amp;&amp;\n      handlers.forEach((fn) &#x3D;&gt; &#123;\n        fn.apply(this, args);\n      &#125;);\n  &#125;\n  &#x2F;&#x2F; 解除\n  off(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) return;\n    events[name] &#x3D; events[name].filter((fn) &#x3D;&gt; fn !&#x3D;&#x3D; callback); &#x2F;&#x2F; 引用，指向对象，直接改kv键值对\n  &#125;\n  &#x2F;&#x2F;  用完立马、解除\n  once(name, callback) &#123;\n    const handler &#x3D; function () &#123;\n      callback.apply(this, arguments); &#x2F;&#x2F; 普通函数参数\n      this.off(name, handler);\n    &#125;;\n    this.on(name, handler);\n  &#125;\n  &#x2F;&#x2F; 事件清空\n  clear() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n&#125;\n\n\n\n观察者 vs 发布订阅\n从表面上看\n观察者模式里，只有两个角色 —— 观察者 + 被观察者\n而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的—— {经纪人|Broker}\n\n\n往更深层次讲\n观察者和被观察者，是松耦合的关系\n发布者和订阅者，则完全不存在耦合\n\n\n使用上\n观察者模式，多用于单个应用内部\n发布订阅模式，则更多的是一种{跨应用的模式|cross-application pattern} ，比如我们常用的消息中间件\n\n\n\nWebGL 和 canvas 的关系\nCanvas 就是画布，只要浏览器支持，可以在 canvas 上获取 2D 上下文和 3D 上下文，其中 3D 上下文一般就是 WebGL，当然 WebGL 也能用于 2D 绘制，并且 WebGL 提供硬件渲染加速，性能更好。\nWEBGL 的支持性 caniuse 还不是特别好，所以在不支持 WebGL 的情况下，只能使用 Canvas 2D api，注意这里的降级不是降到 Canvas，它只是一个画布元素，而是降级使用 浏览器提供的 Canvas 2D Api，这就是很多库的兜底策略，如 Three.js, PIXI 等\n\n声明变量的方式（2 + 4 ）\nES5\nvar 命令\nfunction 命令\n\n\nES6\nlet\nconst\nimport\nclass\n\n\n\nCommonJS 和 ES6 Module 的区别\nCommonJS 是同步加载模块，ES6 是异步加载模块CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。浏览器加载 ES6 模块是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本\nCommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\nADM vs CMD vs ES6 Module图片懒加载利用 JavaScript 实现懒加载的 3 种方式,原理:\n判断图片是否出现在可视区后给图片赋值 src 属性。利用 HTML 提供的 data- 属性来嵌入自定义数据,自定义数据存放这个标签原本的图片地址。\n利用 offsetTop 计算位置\n用 JavaScript 实现当滚动滚动条时，如果图片出现在可视区，那么加载图片。\n加载图片其实就是给 img 标签 src 属性赋值为本来的地址，那么此时图片便会请求加载渲染出来\n\n\n实现原理源代码\n&#x2F;&#x2F;获取全部img标签\nvar images &#x3D; document.getElementsByTagName(&quot;img&quot;);\n\nwindow.addEventListener(&quot;scroll&quot;, (e) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;当发生滚动事件时调用loadPic事件\n  loadPic();\n&#125;);\n\nfunction loadPic() &#123;\n  &#x2F;&#x2F; 遍历每一张图\n  for (let i of images) &#123;\n    &#x2F;&#x2F;判断当前图片是否在可视区内\n    if (i.offsetTop &lt;&#x3D; window.innerHeight + window.scrollY) &#123;\n      &#x2F;&#x2F;获取自定义data-src属性的值\n      let trueSrc &#x3D; i.getAttribute(&quot;data-src&quot;);\n      &#x2F;&#x2F;把值赋值给图片的src属性\n      i.setAttribute(&quot;src&quot;, trueSrc);\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F;没发生滚动事件时也要先执行一次\nloadPic();\n\n&#x2F;&#x2F; offsetTop 为元素距离顶部的距离；\n&#x2F;&#x2F; window.innerHeight 为当前窗口的高度；\n&#x2F;&#x2F; window.scrollY 为滚动距离\n&#x2F;&#x2F; 当 i.offsetTop &lt;&#x3D; window.innerHeight + window.scrollY时图片就处于窗口可视区了\n\n\n\n利用 getBoundingClientRect().top 计算位置\n实现原理源代码\nvar images &#x3D; document.getElementsByTagName(&quot;img&quot;);\n\nwindow.addEventListener(&quot;scroll&quot;, (e) &#x3D;&gt; &#123;\n  loadPic();\n&#125;);\n\nfunction loadPic() &#123;\n  for (let i of images) &#123;\n    &#x2F;&#x2F;计算方式和第一种方式不同\n    if (i.getBoundingClientRect().top &lt; window.innerHeight) &#123;\n      let trueSrc &#x3D; i.getAttribute(&quot;data-src&quot;);\n      i.setAttribute(&quot;src&quot;, trueSrc);\n    &#125;\n  &#125;\n&#125;\n\nloadPic();\n\n&#x2F;&#x2F; getBoundingClientRect().top 为元素相对于窗口的位置；\n&#x2F;&#x2F; window.innerHeight 为当前窗口的高度；\n&#x2F;&#x2F; 当元素对于窗口的位置小于当前窗口的高度时，那自然处于了窗口可视区了\n\n\n\nIntersection ObserverIntersection Observer 构造函数的作用是它能够观察可视窗口与目标元素产生的交叉区域。简单来说就是当用它观察我们的图片时，当图片出现或者消失在可视窗口，它都能知道并且会执行一个特殊的回调函数，我们就利用这个回调函数实现我们的操作\n\n实现原理源代码\nvar images &#x3D; document.getElementsByTagName(&quot;img&quot;);\nfunction callback(entries) &#123;\n  for (let i of entries) &#123;\n    if (i.isIntersecting) &#123;\n      let img &#x3D; i.target;\n      let trueSrc &#x3D; img.getAttribute(&quot;data-src&quot;);\n      img.setAttribute(&quot;src&quot;, trueSrc);\n      observer.unobserve(img);\n    &#125;\n  &#125;\n&#125;\n\nconst observer &#x3D; new IntersectionObserver(callback);\n\nfor (let i of images) &#123;\n  observer.observe(i);\n&#125;\n\n\n\nPromiseQueuetasks 是 promise 数组&#x2F;&#x2F; 入队列\n&#x2F;&#x2F; 出队列\nclass PromiseQueue &#123;\n  constructor(tasks, limit &#x3D; 1) &#123;\n    this.tasks &#x3D; tasks;\n    this.limit &#x3D; limit;\n    this.running &#x3D; [];\n  &#125;\n  next() &#123;\n    return this.running.length &lt; this.limit &amp;&amp; this.tasks.length;\n  &#125;\n\n  run() &#123;\n    while (this.next()) &#123;\n      let promise &#x3D; this.tasks.shift(); &#x2F;&#x2F; 更改tasks数组长度\n\n      promise.then((data) &#x3D;&gt; &#123;\n        this.run();\n      &#125;);\n\n      this.running.push(promise); &#x2F;&#x2F; 更改running数组长度\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 接收一个promise数组，并发限制为3\nconst taskQueue &#x3D; new PromiseQueue(tasks, 3);\ntaskQueue.run();\n\n&#x2F;&#x2F; 清理\n&#x2F;&#x2F; taskQueue &#x3D; undefined\n\ntask 不是默认 promise 数组&#x2F;#&#x2F;post&#x2F;2022-07-04js LimitPromise\nES5、ES6 继承帮助理解的文章JS 继承：原型继承、构造函数继承、组合继承与最佳的继承\nES5原型继承(直接式)原型继承，顾名思义就是通过原型链来让子类继承父类的属性以及函数\n&#x2F;&#x2F; 将父类实例，赋值给子类的原型对象(prototype)\nSubClass.prototype &#x3D; new SuperClass();\n&#x2F;&#x2F; 修正因为重写子类原型， 导致子类的 constructor 属性被修改\nSubClass.prototype.constructor &#x3D; SubClass;\n\n缺点\n\n易污染：父类中引用类型的属性，被子类实例公用\n无法传参：创建父类的时候，无法向父类传递参数\n\n构造函数继承（借助 call）创建即继承\nfunction SubClass(params) &#123;\n  SuperClass.call(this, params);\n&#125;\n\n缺点 不能继承原型属性或者方法\n组合继承原型继承 + 构造函数继承\n组合继承其实就是将我们前面提到的原型继承与构造函数继承给结合了起来，这样能够同时解决原型继承与构造函数继承的缺点\nfunction SubClass(name) &#123;\n  &#x2F;&#x2F; 构造函数式继承父类name属性\n  SuperClass.call(this, name);\n&#125;\n&#x2F;&#x2F; 原型链继承 子类原型继承父类实例\nSubClass.prototype &#x3D; new SuperClass();\n&#x2F;&#x2F; 修正因为重写子类原型导致子类的constructor属性被修改\nSubClass.prototype.constructor &#x3D; SubClass;\n\n缺点 父类构造函数被调用两次\n原型式继承(过渡式)对原型链继承的封装，过渡对象相对于原型继承的子类\nfunction inheritObject(o) &#123;\n  &#x2F;&#x2F;声明一个过渡函数对象\n  function F() &#123;&#125;\n  &#x2F;&#x2F;过渡函数的原型继承父对象\n  F.prototype &#x3D; o;\n  &#x2F;&#x2F; 返回一个实例，该实例的原型继承了父对象\n  return new F();\n&#125;\n\n缺点\n\n父类中引用类型的属性，被子类实例公用\nECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化\n\n寄生式继承(过渡方式)对原型式继承的二次封装,在二次封装中对继承的对象进行拓展。\nfunction createObject(obj) &#123;\n  &#x2F;&#x2F;通过原型式继承创建新对象\n  var o &#x3D; Object.create(obj);\n  &#x2F;&#x2F;拓展新对象\n  o.name &#x3D; &#96;北宸南蓁&#96;;\n  &#x2F;&#x2F;返回拓展后的对象\n  return o;\n&#125;\n\n缺点: 父类中引用类型的属性，被子类实例公用\n寄生组合式继承所谓寄生组合继承，\n 1. 即` 通过借用构造函数来继承属性`\n 2. 通过 `原型链的混成形式来继承方法`\n\n其背后的思路就是：\n1. 不必为了指定子类型的原型而调用超类型构造函数，我们所需要的无非就是超类型原型的一个副本而已。\n2. 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型\n\nfunction inheritPrototype(subClass, superClass) &#123;\n  &#x2F;&#x2F;复制一份父类的原型副本, 并赋值给子类原型\n  subClass.prototype &#x3D; Object.create(superClass.prototype);\n  &#x2F;&#x2F; 修正因为重写子类原型, 导致子类的constructor属性被修改\n  subClass.prototype.constructor &#x3D; subClass;\n&#125;\n\nfunction subClass() &#123;\n  superClass.call(this);\n&#125;\n\nES6 的 extends 关键字 也采用这种方式\n比较\n\n\n分类\n动机\n缺点\n\n\n\n原型继承\n实现继承\n1. constructor 指向错误 2. 父类属性共享，会造成污染，3. 无法向父类构造函数传参\n\n\n构造函数继承\n解决污染问题\n父类中引用类型的属性，被子类实例公用，父类原型上的函数没有继承\n\n\n组合继承\n同时解决原型继承与构造函数继承的缺点\n父类构造函数被调用两次（一次是在创建子类型原型的时候，另一次是在子类型构造函数的内部）\n\n\n过渡原型继承\n对原型继承的封装\n避免因为修改子类的构造函数后还需要修正的现象\n\n\n过渡寄生式继承\n对原型式继承的二次封装\n\n\n\n寄生组合式继承\n解决组合继承父类构造函数被调用两次的问题\n\n\n\n寄生式继承为什么不会污染父类原型没有实例化父类，对中间构造函数进行实例化（一个临时副本实现了相同的原型链继承）\nES6 继承原理：ES6 类 + 寄生式组合继承\nes5 和 es6 的继承有什么区别\n本质上区别\n\nES5 的继承实质: 是先创建子类的实例对象，然后再将父类的方法添加到 this 上（superClass.call(this)）\nES6 的继承实质: 是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this\n\n实现上有区别\n\nES5 的继承时通过原型或构造函数机制来实现。\nES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。\n\n使用上有区别\n\n子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。\n因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。\n\n参考链接\n继承方式六：寄生组合式继承\nJS 继承：原型继承、构造函数继承、组合继承与最佳的继承\n22023 面试真题之手写&amp;代码运行篇\n\n","slug":"2023-03-062023js","date":"2023-03-06T01:49:01.000Z","categories_index":"前端面试","tags_index":"前端面试","author_index":"举手摘月亮"},{"id":"749dde28f9332fb853106b061b92f347","title":"Requestly 实操记录","content":"Modify API Response改变接口请求返回的结果\n注意：请求正常发送，正常返回(可以在 chrome 的 network 窗口查看)，在返回给 js 的时候，会被插件处理，所以看上去有点摸不着头脑\n\n\n操作介绍\n\n查看 chrome Requestly 窗口请求记录\n\n启用&#x2F;关闭\n在分组主控制启用的情况，可进行接口更细粒度的控制\n分组的主控制，主控制关闭，该组内所有接口不启用\n\n\n\n\n\n缓存问题\nget 接口是有浏览器缓存的\n当关闭 Requestly 的接口时候，需要手动刷新下浏览器，否则，请求到的数据还是浏览器缓存数据\n\n","slug":"2023-03-02requestly","date":"2023-03-02T02:23:04.000Z","categories_index":"浏览器插件","tags_index":"浏览器插件","author_index":"举手摘月亮"},{"id":"9b8922a1dbe36a3eb41d8cc6b193f5da","title":"Virtualized List","content":"为什么需要虚拟列表用于解决展示海量数据渲染时首屏渲染缓慢和滚动卡顿的问题\n非固定虚拟列表如何实现一个高度自适应的虚拟列表\nuse-virtual-listuse-virtual-list\nahooks 源码学习之 useVirtualList\n大家都能看得懂的源码之 ahooks useVirtualList 封装虚拟滚动列表\nreact virtualizedreact virtualized\nvue-virtual-scrollervue-virtual-scroller\n参考链接如何实现一个高度自适应的虚拟列表\n剖析虚拟列表实现原理\n","slug":"2023-03-01vertuallist","date":"2023-03-01T13:38:35.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"举手摘月亮"},{"id":"8649e6cab92cb169d0b5940efd5b27f4","title":"智能提示 first select outtime","content":"背景\n\nvscode\n在 0.75 版本时候出了严重 bug 导致快捷键和 Suggestion 提示废掉了，紧急发布 0.75.1 版本，\n(当前版本)0.75.1 版本发布后 Suggestion 提示不会默认选择第一个了\nvscode 之后的版本会启用 tab 来选中第一个\n\n# 173387\n原因：\n\n\n\n\n\n\n\n\n\nin 1.74.3 the box doesn’t show while in 1.75.0 it shows up with the first option not selected.\nThat change was done on purpose but it wasn’t clearly communicated. In the past we would truly suppress Intellisense when in snippet mode. Over the last years this has caused much confusion and heated debates because people believe IntelliSense is broken. The underlying conflict is that both (snippets and suggest) use Tab to either advance to next placeholder or accept a completion. They are mutually exclusive and one is given precedence making folks believe things are broken.\nSince IntelliSense has the new “no select” mode I figured it is a good compromise to use that instead of suppressing suggest. Wrt muscle memory nothing should have changed, pressing Tab still goes to the next snippet placeholder but wrt the UI are now seeing the suggest widget (as ambient offering)\n在 0.75.1 版本，第一个默认选中时灵时不灵，原本计划会有新版本在二月份更新的，然而并没有，再等等…\n\n\n\n\n\n\n\n\n\nI was OOF and this slipped a little bit. For February I will push a new command focusAndAcceptSuggestion that focuses and accepts a suggestion (#174856). By default it will not have a keybinding but you can add one like this (keybindings.json)\n&#x2F;&#x2F; Place your key bindings in this file to override the defaults\n[\n  &#123;\n    command: &quot;focusAndAcceptSuggestion&quot;,\n    when: &quot;editorTextFocus &amp;&amp; suggestWidgetVisible &amp;&amp; !suggestWidgetHasFocusedSuggestion&quot;,\n    key: &quot;Enter&quot;,\n  &#125;,\n];\n\n切换 keybindings.json\n\n新版本提供了解决方案，（当前 0.75.1 版本无效）\nchrome新版本的 chrome 也是样的现象\n\n\n\n从 vscode issue 了解到，vscode 之后的版本会启 U+00a0 用 tab 来选中第一个\n我试了下同样的方式在 chrome 的 console 是否有效，经测试，确实可以\n\nvscode 0.76.0 修复了 first select 问题，仍不尽人意\n现状：输入代码片段如遇到不能够自动选择第一个的情况，需要点击 tab+enter，生成第一个代码片段的内容，这个过程中没有任何提示&#x2F;标记\n\n体验贼差，总比没有的要好吧。妥协一下～\n","slug":"2023-03-01first-select","date":"2023-03-01T02:35:54.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"1ff3c92d43d399f4cad1a3cbd62d0b1a","title":"Object","content":"Object.assign() 方法将所有可枚举（Object.propertyIsEnumerable() 返回 true）的自有（Object.hasOwnProperty() 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象\n特点\n复制对象\n浅拷贝\n合并对象：对象为引用类型，作为 target 的原对象的值也会变\n合并具有相同属性的对象：后面的覆盖前面的\n拷贝symbol类型属性：\n原型链上的属性和不可枚举属性不能被复制\n基本类型会被包装为对象\n异常会打断后续拷贝任务\n拷贝访问器\n\njs 实现 Object.assignfunction completeAssign(target, ...sources) &#123;\n  &#x2F;&#x2F; 资源全部处理一遍\n  sources.forEach((source) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理一个资源的所有key\n    let descriptors &#x3D; Object.keys(source).reduce((descriptors, key) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 拿到key的配置信息\n      descriptors[key] &#x3D; Object.getOwnPropertyDescriptor(source, key);\n      return descriptors;\n    &#125;, &#123;&#125;);\n\n    &#x2F;&#x2F; By default, Object.assign copies enumerable Symbols, too\n    &#x2F;&#x2F; 将资源的sym信息全部拿出来，放到descriptors上\n    Object.getOwnPropertySymbols(source).forEach((sym) &#x3D;&gt; &#123;\n      let descriptor &#x3D; Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor.enumerable) &#123;\n        descriptors[sym] &#x3D; descriptor;\n      &#125;\n    &#125;);\n    &#x2F;&#x2F; 最后全部添加到target上\n    Object.defineProperties(target, descriptors);\n  &#125;);\n  return target;\n&#125;\n\nObject.entriesif (!Object.entries)\n  Object.entries &#x3D; function (obj) &#123;\n    var ownProps &#x3D; Object.keys(obj),\n      i &#x3D; ownProps.length,\n      resArray &#x3D; new Array(i); &#x2F;&#x2F; preallocate the Array\n\n    while (i--) resArray[i] &#x3D; [ownProps[i] &#x2F;*key*&#x2F;, obj[ownProps[i]] &#x2F;*value *&#x2F;];\n\n    return resArray;\n  &#125;;\n\nObject.fromEntries\nmap_转化为_object\narray_转化为_object\n对象转换\n\nObject.freeze()\n一个被冻结的对象再也不能被修改；\n冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。\n冻结一个对象后该对象的原型也不能被修改。\nfreeze() 返回和传入的参数相同的对象。\n\ndeepFreeze&#x2F;&#x2F; 深冻结函数。\nfunction deepFreeze(obj) &#123;\n  &#x2F;&#x2F; 取回定义在 obj 上的属性名\n  var propNames &#x3D; Object.getOwnPropertyNames(obj);\n\n  &#x2F;&#x2F; 在冻结自身之前冻结属性\n  propNames.forEach(function (name) &#123;\n    var prop &#x3D; obj[name];\n\n    &#x2F;&#x2F; 如果 prop 是个对象，冻结它\n    if (typeof prop &#x3D;&#x3D; &quot;object&quot; &amp;&amp; prop !&#x3D;&#x3D; null) deepFreeze(prop);\n  &#125;);\n\n  &#x2F;&#x2F; 冻结自身 (no-op if already frozen)\n  return Object.freeze(obj);\n&#125;\n\nobj2 &#x3D; &#123;\n  internal: &#123;&#125;,\n&#125;;\n\ndeepFreeze(obj2);\nobj2.internal.a &#x3D; &quot;anotherValue&quot;;\nobj2.internal.a; &#x2F;&#x2F; undefined\n\nObject.seal()Object.seal() 与 Object.freeze()的区别冻结的对象中的现有属性值是不可变的。用 Object.seal()密封的对象可以改变其现有属性值\nObject.getOwnPropertyNames法返回一个由指定对象的所有自身属性的属性名(可不可枚举的不重要，重要的是自己的)（但不包括 Symbol 值作为名称的属性）组成的数组\n\n使用_object.getownpropertynames\n只获取不可枚举的属性\n\nObject.keysObject.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致\nObject.valuesObject.values() 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for…in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）\n\n返回值\n描述\n示例\n\nvar obj &#x3D; &#123; foo: &quot;bar&quot;, baz: 42 &#125;;\nconsole.log(Object.values(obj)); &#x2F;&#x2F; [&#39;bar&#39;, 42]\n\n&#x2F;&#x2F; array like object\nvar obj &#x3D; &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125;;\nconsole.log(Object.values(obj)); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n&#x2F;&#x2F; array like object with random key ordering\n&#x2F;&#x2F; when we use numeric keys, the value returned in a numerical order according to the keys\nvar an_obj &#x3D; &#123; 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot; &#125;;\nconsole.log(Object.values(an_obj)); &#x2F;&#x2F; [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]\n\n&#x2F;&#x2F; getFoo is property which isn&#39;t enumerable\n&#x2F;&#x2F; 不可枚举\nvar my_obj &#x3D; Object.create(\n  &#123;&#125;,\n  &#123;\n    getFoo: &#123;\n      value: function () &#123;\n        return this.foo;\n      &#125;,\n    &#125;,\n  &#125;\n);\nmy_obj.foo &#x3D; &quot;bar&quot;;\nconsole.log(Object.values(my_obj)); &#x2F;&#x2F; [&#39;bar&#39;]\n\n&#x2F;&#x2F; non-object argument will be coerced to an object\n&#x2F;&#x2F; 非对象参数会被强转为对象\nconsole.log(Object.values(&quot;foo&quot;)); &#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]\n\nMDN 文章爬取标题脚本data &#x3D; &quot;&quot;;\nArray.from(temp1.getElementsByTagName(&quot;section&quot;)).forEach((item, index) &#x3D;&gt; &#123;\n  data +&#x3D; index + 1 + &quot;. &quot; + item.getAttribute(&quot;aria-labelledby&quot;) + &quot;\\n&quot;;\n&#125;);\ncopy(data);\n","slug":"2023-02-28object","date":"2023-02-28T13:10:33.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"3ba10f79d449e988902f7328033fb9f2","title":"ts代码段调试","content":"背景项目中使用 typesscript 进行开发，运行的时候是编译后的 js 脚本，有时候在项目，需要封装复杂的业务处理函数。\n最开始的方法\n先将代码在项目中编写\n出问题了，项目中不方便调试\n改为 js 代码，删除类型\n调试完毕后，增加类型\n复制到项目中\n\n后来参考 pont,写了 require-tsrequire-ts 项目丢了\n原理：\n\n将 ts 代码进行运行时编译成 js 文件，写到内存中\n在其他文件中引用\n删除 ts 编译后的.js 文件\n\n\n\n现在(这个好啊)\n写了了限制并发的 ts 代码，想测试下，如何运行？\n搜了下直接运行.ts 文件，发现可以用 ts-node 来运行\nts-node xx.ts报错error TS2304: Cannot find name &#39;setTimeout&#39; error TS2304: Cannot find name ‘setTimeout’\n需要简单的配置tsconfig.json， 配置过程中，发现这个文件是 jsonc 格式的文件\n\n\n\ntsconfig.json 简单配置&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;lib&quot;: [&quot;es6&quot;, &quot;dom&quot;]\n  &#125;\n&#125;\n\n为什么要配置代码片段为了下次使用方便，以后记住缩写，就可以happy code\n参考链接error TS2304: Cannot find name ‘setTimeout’\n","slug":"2023-02-28ts","date":"2023-02-28T06:36:23.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"cd788e373bbe9a88ec776d20b310ec2f","title":"ant DatePicker","content":"问题\n这里首次使用 datepicker 的时候， 获取到时间含有十分秒： v = 1676429917\n非第一次操作正常\n这里修改方案，将 const _v: number = e?.startOf(&quot;d&quot;).valueOf() || 0;\n\nconst onChange &#x3D; usePersistFn((e: moment.Moment | null) &#x3D;&gt; &#123;\n  const v: number &#x3D; e?.unix?.() || 0; &#x2F;&#x2F;\n  console.log(v, props.emptyValue, &quot;props.emptyValue&quot;);\n  props.onChange?.(v ? v * 1000 : props.emptyValue);\n&#125;);\n\nfixconst onChange &#x3D; usePersistFn((e: moment.Moment | null) &#x3D;&gt; &#123;\n  const _v: number &#x3D; e?.startOf(&quot;d&quot;).valueOf() || 0;\n  console.log(v, props.emptyValue, &quot;props.emptyValue&quot;);\n  props.onChange?.(v ? v : props.emptyValue);\n&#125;);\n","slug":"2023-02-28datepicker","date":"2023-02-28T03:01:54.000Z","categories_index":"Bug","tags_index":"Bug","author_index":"举手摘月亮"},{"id":"efb0473bb840c16eda737ab9fe4eecb0","title":"重新认识下 JSON.stringify","content":"JSON.stringify 是什么JSON.stringify(value[, replacer [, space]])\n\n\n将一个 JavaScript 对象或值转换为 JSON 字符串\n\nreplacer该字段决定处理哪些属性\n\n如果 replacer 是函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；\n如果如果 replacer 是数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；\n如果该参数为 null 或者未提供，则对象所有的属性都会被序列化\n\nspace\n指定缩进用的空白字符串，用于美化输出（pretty-print）；\n\n如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；\n如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；\n如果该参数没有提供（或者为 null），将没有空格\n\nJSON.stringify 能做什么\nnull 都会被处理成 &#39;null&#39;\nboolean、字符串的包装对象在序列化过程中会被转化成原始值\nnumber,NaN 和 Infinity 格式的数值会被当做 null, 其他 number 的数据会被转化成 string\n以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们\nundefined、函数、Symbol 值，在序列化过程中，会被\n数组中，会被转化成 null\n非数组对象，会被忽略\n函数、undefined 被单独转化时，会返回 undefined而不是字符串&#39;undefined&#39;\n\n\n对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误\n非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中\n被转化值有 toJSON 方法，直接调用该方法\nDate 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理\n其他类型的对象，包括 Map&#x2F;Set&#x2F;WeakMap&#x2F;WeakSet，仅会序列化可枚举的属性\n\n具体事例： 见\n如何用 js 实现 JSON.stringify&#x2F;&#x2F; 数据类型\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &quot;object&quot;;\nconst isTypeObject &#x3D; (val) &#x3D;&gt; typeof val &#x3D;&#x3D;&#x3D; &quot;object&quot;;\n&#x2F;&#x2F; Object.prototype.toString\nconst toString &#x3D; Object.prototype.toString;\nconst isBoolean &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object Boolean]&quot;;\nconst isBigInt &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object BigInt]&quot;;\nconst isSymbol &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object Symbol]&quot;;\nconst isNull &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object Null]&quot;;\nconst isString &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object String]&quot;;\nconst isUndefined &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object Undefined]&quot;;\nconst isNumber &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object Number]&quot;;\nconst isFunction &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &quot;[object Function]&quot;;\nconst isArray &#x3D; (val) &#x3D;&gt; toString.call(val) &#x3D;&#x3D;&#x3D; &quot;[object Array]&quot;;\nconst isObject &#x3D; (val) &#x3D;&gt; toString.call(val) &#x3D;&#x3D;&#x3D; &quot;[object Object]&quot;;\n\nvar escRE &#x3D; &#x2F;[\\\\&quot;\\u0000-\\u001F\\u2028\\u2029]&#x2F;g;\nvar escMap &#x3D; &#123; &#39;&quot;&#39;: &#39;\\\\&quot;&#39;, &quot;\\\\&quot;: &quot;\\\\\\\\&quot;, &quot;\\b&quot;: &quot;\\\\b&quot;, &quot;\\f&quot;: &quot;\\\\f&quot;, &quot;\\n&quot;: &quot;\\\\n&quot;, &quot;\\r&quot;: &quot;\\\\r&quot;, &quot;\\t&quot;: &quot;\\\\t&quot; &#125;;\n&#x2F;&#x2F; prettier-ignore\nvar escFunc &#x3D; function (m) &#123;return escMap[m] || &quot;\\\\u&quot; + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);&#125;;\n\nfunction stringify(value) &#123;\n  if (isNull(value)) &#123;\n    return &quot;null&quot;;\n  &#125; else if (isNumber(value)) &#123;\n    return isFinite(value) ? value.toString() : &quot;null&quot;;\n  &#125; else if (isBoolean(value)) &#123;\n    return value.toString();\n  &#125; else if (isTypeObject(value)) &#123;\n    &#x2F;&#x2F;  对象类型\n    if (isFunction(value.toJSON)) &#123;\n      &#x2F;&#x2F; .toJSON\n      return stringify(value.toJSON());\n    &#125; else if (isArray(value)) &#123;\n      &#x2F;&#x2F; 数组\n      var res &#x3D; &quot;[&quot;;\n      for (var i &#x3D; 0; i &lt; value.length; i++) &#123;\n        res +&#x3D; (i ? &quot;, &quot; : &quot;&quot;) + stringify(value[i]);\n      &#125;\n      return res + &quot;]&quot;;\n    &#125; else if (isObject(value)) &#123;\n      &#x2F;&#x2F; 对象\n      var tmp &#x3D; [];\n      for (var k in value) &#123;\n        if (value.hasOwnProperty(k)) &#123;\n          tmp.push(stringify(k) + &quot;: &quot; + stringify(value[k]));\n        &#125;\n      &#125;\n      return &quot;&#123;&quot; + tmp.join(&quot;, &quot;) + &quot;&#125;&quot;;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 非必要的空字符去除\n  return &#39;&quot;&#39; + value.toString().replace(escRE, escFunc) + &#39;&quot;&#39;;\n&#125;\n\n&#x2F;&#x2F; var test_data_1 &#x3D; &#123; name: 1, age: 2, grades: [1, 2, 3] &#125;;\n&#x2F;&#x2F; console.log(&quot;deep&quot;, stringify(test_data_1));\n&#x2F;&#x2F; console.log(&quot;json&quot;, JSON.stringify(test_data_1));\n\nconst data &#x3D; &#123;\n  name: &#123; grades: [1, 23, 4] &#125;,\n  age: 2,\n  other: &#123; name: &#123; grades: [1, 23, 4] &#125; &#125;,\n&#125;;\n\nconsole.log(&quot;deep&quot;, stringify(data));\nconsole.log(&quot;json&quot;, JSON.stringify(data));\n\njs 实现 总结\n如果是 null 直接转化成 string\n如果是有限的 number，转化成 string,否则转化成&quot;null&quot;\n如果是 boolean,转化成 string\n如果是对象\n对象有.toJSON 方法，直接调用该方法，然后进行递归处理\n如果是数组，数组外面拼接[], 数组项递归处理\n如果是非数组对象，对象键和值都要做递归处理，然后拼接&#123;&#125;字符串\n\n\n其他情况转化成 string，并去除空白字符\n\n参考链接JSON.stringify MDN\n","slug":"2023-02-27json","date":"2023-02-27T05:32:04.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"e00426eb8e20267d75c9bea1f431c2ca","title":"记一个老古董项目代码","content":"背景周五晚上去上海，周末在上海加了两天班， 做公司项目，周日晚上 9 点回到杭州帮媳妇写老古董 demo（贼充实 😭）\n\n\n事情经过\n\n媳妇公司的另一个银行项目组业务，要在原有的 java web 项目给下拉选择功能， 增加是否可选的控制，很费劲的哦：不给你看代码，只是说用的 jquery1.11.2,要你实现。哎呦我去～\n原有项目要扩展功能总要给看看吧\n重新给你实现，总要能对应的上吧\n没得办法，先帮实现几种可能，剩下的，您哎，自个改～\n。。。。。一系列操作之后，在原有的基础上扩展\n\n原项目实现方案推测\n原生实现 js\njquery 实现 jquery\n使用了插件 jquery + select2\n\n原生方式 or jquery&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n\n  &lt;body&gt;\n    &lt;select name&#x3D;&quot;tech&quot; id&#x3D;&quot;selector&quot;&gt;&lt;&#x2F;select&gt;\n    &lt;!-- jquery --&gt;\n    &lt;!-- &lt;script src&#x3D;&quot;.&#x2F;jquery1.11.2.min.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;\n    &lt;!-- &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;1.11.2&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;\n\n    &lt;script&gt;\n      &#x2F;&#x2F; 1. 模拟数据\n      var data &#x3D; [\n        &#123; id: 0, text: &quot;H5&quot; &#125;,\n        &#123; id: 1, text: &quot;JS&quot; &#125;,\n        &#123; id: 2, text: &quot;JAVA&quot; &#125;,\n        &#123; id: 3, text: &quot;Vue&quot;, remark: &quot;这是一个remark&quot; &#125;,\n        &#123; id: 4, text: &quot;React&quot; &#125;,\n      ];\n      &#x2F;&#x2F; 2. 拼接remark处理函数\n      function pinRemark(item) &#123;\n        return item.remark ? &quot;(&quot; + item.remark + &quot;)&quot; : &quot;&quot;;\n      &#125;\n      &#x2F;&#x2F; 3. 动态生成 options\n      for (var i &#x3D; 0; i &lt; data.length; i++) &#123;\n        var option &#x3D; document.createElement(&quot;option&quot;);\n        var item &#x3D; data[i];\n        option.value &#x3D; item.id;\n        &#x2F;&#x2F; 4. 动态拼接remark\n        option.innerHTML &#x3D; &#x2F;*之前的option展示的内容*&#x2F; item.text + &#x2F;*拼接的remark*&#x2F; pinRemark(item);\n        &#x2F;&#x2F; 5. 判断有remark，添加disabled属性\n        if (item.remark) &#123;\n          option.disabled &#x3D; true;\n        &#125;\n        &#x2F;&#x2F; 6. 挂载节点\n        &#x2F;&#x2F; $(&#39;#selector&#39;).append(option); &#x2F;&#x2F; jquery\n        document.getElementById(&quot;selector&quot;).append(option);\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\njquery + select2&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;dist&#x2F;css&#x2F;select2.css&quot; &#x2F;&gt; --&gt;\n    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;select2&#x2F;4.0.13&#x2F;css&#x2F;select2.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;\n    &lt;style&gt;\n      .js-example-data-array &#123;\n        width: 200px;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n\n  &lt;body&gt;\n    &lt;select class&#x3D;&quot;js-example-data-array&quot;&gt;&lt;&#x2F;select&gt;\n\n    &lt;!-- &lt;script src&#x3D;&quot;.&#x2F;jquery1.11.2.min.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;1.11.2&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;!-- &lt;script src&#x3D;&quot;.&#x2F;dist&#x2F;js&#x2F;select2.full.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;select2&#x2F;4.0.13&#x2F;js&#x2F;select2.full.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 模拟数据\n      var data &#x3D; [\n        &#123; id: 0, text: &quot;H5&quot; &#125;,\n        &#123; id: 1, text: &quot;JS&quot; &#125;,\n        &#123; id: 2, text: &quot;JAVA&quot; &#125;,\n        &#123; id: 3, text: &quot;Vue&quot;, remark: &quot;这是一个remark&quot; &#125;,\n        &#123; id: 4, text: &quot;React&quot; &#125;,\n      ];\n      &#x2F;&#x2F;  整理后的新数据\n      var list &#x3D; [];\n\n      for (var i &#x3D; 0; i &lt; data.length; i++) &#123;\n        var element &#x3D; data[i];\n        &#x2F;&#x2F; 有remark的数据，增加disabled属性，并对text进行整理\n        if (element.remark) &#123;\n          list.push(&#123;\n            id: element.id,\n            disabled: true,\n            text: element.text + &quot;(&quot; + element.remark + &quot;)&quot;,\n          &#125;);\n        &#125; else &#123;\n          list.push(element);\n        &#125;\n      &#125;\n      &#x2F;&#x2F; 初始化select2数据\n      $(&quot;.js-example-data-array&quot;).select2(&#123;\n        data: list,\n      &#125;);\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\njquery + select2 进行抽取方法&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;!-- &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;dist&#x2F;css&#x2F;select2.css&quot; &#x2F;&gt; --&gt;\n    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;select2&#x2F;4.0.13&#x2F;css&#x2F;select2.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;\n    &lt;style&gt;\n      .js-example-data-array &#123;\n        width: 200px;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n\n  &lt;body&gt;\n    &lt;select class&#x3D;&quot;js-example-data-array&quot;&gt;&lt;&#x2F;select&gt;\n\n    &lt;!-- &lt;script src&#x3D;&quot;.&#x2F;jquery1.11.2.min.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;1.11.2&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;!-- &lt;script src&#x3D;&quot;.&#x2F;dist&#x2F;js&#x2F;select2.full.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcdn.net&#x2F;ajax&#x2F;libs&#x2F;select2&#x2F;4.0.13&#x2F;js&#x2F;select2.full.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 格式化数据\n      function formatDisabledRemarkDatas(data) &#123;\n        var list &#x3D; [];\n        for (var i &#x3D; 0; i &lt; data.length; i++) &#123;\n          var element &#x3D; data[i];\n          &#x2F;&#x2F; 有remark的数据，增加disabled属性，并对text进行整理\n          if (element.remark) &#123;\n            list.push(&#123;\n              id: element.id,\n              disabled: true,\n              text: element.text + &quot;(&quot; + element.remark + &quot;)&quot;,\n            &#125;);\n          &#125; else &#123;\n            list.push(element);\n          &#125;\n        &#125;\n        return list;\n      &#125;\n    &lt;&#x2F;script&gt;\n    &lt;script&gt;\n      &#x2F;&#x2F; 模拟数据\n      var data &#x3D; [\n        &#123; id: 0, text: &quot;H5&quot; &#125;,\n        &#123; id: 1, text: &quot;JS&quot; &#125;,\n        &#123; id: 2, text: &quot;JAVA&quot; &#125;,\n        &#123; id: 3, text: &quot;Vue&quot;, remark: &quot;这是一个remark&quot; &#125;,\n        &#123; id: 4, text: &quot;React&quot; &#125;,\n      ];\n\n      &#x2F;&#x2F; 初始化select2数据\n      $(&quot;.js-example-data-array&quot;).select2(&#123;\n        &#x2F;&#x2F;  整理后的新数据\n        data: formatDisabledRemarkDatas(data),\n      &#125;);\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nul+li我猜之前的人不可能这么干～\ndemo 写完媳妇说这你怎么也会写呢（我：我前些年花的时间你想象不到）\n“大爷”搞不定了demo 给到“大爷”， 最后还是给了仓库地址，本地运行 java web 进行开发, 早这样，早就完事了\n项目中 select2，使用第二个方案处理下\n总结\njava web 项目很少见，基本上要么重构，要么是古板的公司成品基本上不需要维护（ 这项目还当成宝，丢在大街上，看都不看）\n刚毕业时候的第一家公司用的 query+angularjs\n现在基本上见不到这种项目了\n\n","slug":"2023-02-27select","date":"2023-02-27T02:56:48.000Z","categories_index":"jQuery","tags_index":"jQuery","author_index":"举手摘月亮"},{"id":"7f7a9ab6a798a1698e4fe0da6545ff5a","title":"移动端适配 - viewport","content":"postcss-px-to-viewport5W2H 法则进行复利\n为什么amfe-flexible 作者：\n\n\n\n\n\n\n\n\n\n由于 viewport 单位得到众多浏览器的兼容，lib-flexible 这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用 viewport 来替代此方。\n见：2023-02-23amfe-flexible\n是什么将 px 单位转换为视口单位的 (vw, vh, vmin, vmax) 的 PostCSS 插件.\n源码仓库https://github.com/evrone/postcss-px-to-viewport\n\n文档没用过 postcss-px-to-viewport 插件，直接看实现不太现实，这个插件用了 css 的 postcss 抽象语法树解析器，和 px2rem 的使用的 rework 解析器不同\n先看文档：postcss-px-to-viewport 官方中文文档\npostcss 解析器\n可以将 css 转化抽象语法树，\n可以将“对应的抽象语法树”转化成 css 代码\n支持插件扩展功能 postcss writing-a-plugin\n\n解析器生成的抽象语法树\n\n通过抽象语法树来学习 postcss\npostcss APIhttps://postcss.org/api/\npostcss plugin 模版见\n至此，阅读插件的储备已够\n了解了 postcss 插件，可以阅读 postcss-px-to-viewport 源码了\n\npostcss-px-to-viewport 源码参考链接\n自适应布局方案\npostcss-px-to-viewport 官方中文文档\npostcss 官方文档\npostcss writing-a-plugin\nhttps://postcss.org/api/\nhttps://postcss.org/docs/writing-a-postcss-plugin\n\n","slug":"2023-2-23viewport","date":"2023-02-23T09:27:13.000Z","categories_index":"移动端适配","tags_index":"源码,移动端适配","author_index":"举手摘月亮"},{"id":"f348d38b4d9622020eade27f316aa8e6","title":"移动端适配 - amfe-flexible","content":"amfe-flexible作用: 是动态设置根节点和 body 的 fontSize, 检测0.5px的支持情况\nhttps://github.com/amfe/lib-flexible\n\n设置 body 的原因：\nfontSize 会被继承，\nroot fontSize 被改变了，\n要把字体做还原处理\n\n触发计算的时机\n设置 body 的fontSize的时机\n脚本执行时\nDOM 内容加载完毕时\n\n\n设置根节点fontSize的时机\n脚本执行时\n页面改变时\n页面显示时\n\n\n\n(function flexible(window, document) &#123;\n  var docEl &#x3D; document.documentElement;\n  var dpr &#x3D; window.devicePixelRatio || 1;\n\n  &#x2F;&#x2F; adjust body font size\n  function setBodyFontSize() &#123;\n    if (document.body) &#123;\n      document.body.style.fontSize &#x3D; 12 * dpr + &quot;px&quot;;\n    &#125; else &#123;\n      &#x2F;&#x2F; 页面加载的一个阶段，进行触发\n      document.addEventListener(&quot;DOMContentLoaded&quot;, setBodyFontSize);\n    &#125;\n  &#125;\n  setBodyFontSize();\n\n  &#x2F;&#x2F; set 1rem &#x3D; viewWidth &#x2F; 10\n  function setRemUnit() &#123;\n    var rem &#x3D; docEl.clientWidth &#x2F; 10;\n    docEl.style.fontSize &#x3D; rem + &quot;px&quot;;\n  &#125;\n\n  setRemUnit();\n\n  &#x2F;&#x2F; reset rem unit on page resize\n  window.addEventListener(&quot;resize&quot;, setRemUnit);\n  window.addEventListener(&quot;pageshow&quot;, function (e) &#123;\n    if (e.persisted) &#123;\n      setRemUnit();\n    &#125;\n  &#125;);\n\n  &#x2F;&#x2F; detect 0.5px supports\n  &#x2F;&#x2F; 检测是否支持0.5px\n  if (dpr &gt;&#x3D; 2) &#123;\n    var fakeBody &#x3D; document.createElement(&quot;body&quot;);\n    var testElement &#x3D; document.createElement(&quot;div&quot;);\n    testElement.style.border &#x3D; &quot;.5px solid transparent&quot;;\n    fakeBody.appendChild(testElement);\n    docEl.appendChild(fakeBody);\n    if (testElement.offsetHeight &#x3D;&#x3D;&#x3D; 1) &#123;\n      docEl.classList.add(&quot;hairlines&quot;);\n    &#125;\n    docEl.removeChild(fakeBody);\n  &#125;\n&#125;)(window, document);\n\n为什么还学它\n虽然是建议用 viewport 了，但是目前很多公司用的还是 rem 进行适配\n\n","slug":"2023-02-23amfe-flexible","date":"2023-02-23T08:59:26.000Z","categories_index":"移动端适配","tags_index":"移动端适配","author_index":"举手摘月亮"},{"id":"5f5455c442e0d990b14d6a6cf267983f","title":"小插曲 prettier","content":"Prettier 是什么代码自动格式化工具\n为什么用 Prettier5W2H\n\n解决历史问题：不用浪费时间整理代码\n工具本身：简单好用，开销低\n帮助新人：学习代码书写，减少错误\n社区很热：(必聊社区)\n代码书写：\n“我想写代码。不要在格式化上花费周期。”\n“它消除了我们日常生活中 5% 的垃圾——也就是格式化”\n\n\n效果/收益：代码阅读性更高\n\n背景vscode prettier 的默认配置 80 宽度自动换行，看着贼不舒服\n之前的处理方式:\n1. 是在项目中建立 prettier 配置文件\n2. 添加注释 `// prettier-ignore`\n\n累死我了，不能再这么下去了\n预期\n项目中有 prettier 配置文件，就按照配置文件来\n项目中没有配置的，按照本地统一（vscode 配置）配置来\n\n我懒，不想改项目的配置，或者是给每个项目增加配置文件\nvscode setting.json 配置\n快捷键 cmd+p\n搜索setting.json\n打开文件（不要打开错了，可能不止一个setting.json文件）\n\nvscode 配置更改我没改这么多，只用了 &quot;prettier.printWidth&quot;: 200\n\n&#x2F;* prettier的配置 *&#x2F;\n\n &quot;prettier.printWidth&quot;: 200, &#x2F;&#x2F; 超过最大值换行\n\n &quot;prettier.tabWidth&quot;: 4, &#x2F;&#x2F; 缩进字节数\n\n &quot;prettier.useTabs&quot;: false, &#x2F;&#x2F; 缩进不使用tab，使用空格\n\n &quot;prettier.semi&quot;: true, &#x2F;&#x2F; 句尾添加分号\n\n &quot;prettier.singleQuote&quot;: true, &#x2F;&#x2F; 使用单引号代替双引号\n\n &quot;prettier.proseWrap&quot;: &quot;preserve&quot;, &#x2F;&#x2F; 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行\n\n &quot;prettier.arrowParens&quot;: &quot;avoid&quot;, &#x2F;&#x2F; (x) &#x3D;&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号\n\n &quot;prettier.bracketSpacing&quot;: true, &#x2F;&#x2F; 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;\n\n &quot;prettier.disableLanguages&quot;: [&quot;vue&quot;], &#x2F;&#x2F; 不格式化vue文件，vue文件的格式化单独设置\n\n &quot;prettier.endOfLine&quot;: &quot;auto&quot;, &#x2F;&#x2F; 结尾是 \\n \\r \\n\\r auto\n\n &quot;prettier.eslintIntegration&quot;: false, &#x2F;&#x2F;不让prettier使用eslint的代码格式进行校验\n\n &quot;prettier.htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;,\n\n &quot;prettier.ignorePath&quot;: &quot;.prettierignore&quot;, &#x2F;&#x2F; 不使用prettier格式化的文件填写在项目的.prettierignore文件中\n\n &quot;prettier.jsxBracketSameLine&quot;: false, &#x2F;&#x2F; 在jsx中把&#39;&gt;&#39; 单独放一行\n\n &quot;prettier.jsxSingleQuote&quot;: false, &#x2F;&#x2F; 在jsx中使用单引号代替双引号\n\n &quot;prettier.parser&quot;: &quot;babylon&quot;, &#x2F;&#x2F; 格式化的解析器，默认是babylon\n\n &quot;prettier.requireConfig&quot;: false, &#x2F;&#x2F; Require a &#39;prettierconfig&#39; to format prettier\n\n &quot;prettier.stylelintIntegration&quot;: false, &#x2F;&#x2F;不让prettier使用stylelint的代码格式进行校验\n\n &quot;prettier.trailingComma&quot;: &quot;es5&quot;, &#x2F;&#x2F; 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）\n\n &quot;prettier.tslintIntegration&quot;: false &#x2F;&#x2F; 不让prettier使用tslint的代码格式进行校验\n\n &quot;trailingComma&quot;: &quot;none&quot; &#x2F;&#x2F; 函数最后不需要逗号\n","slug":"2023-02-23prittier","date":"2023-02-23T03:25:03.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"051f5d5714c1620031ccda827f9d7975","title":"思维模型和思考方式","content":"背景一次面试让我发现了，我存在的问题。想了三天，才写本篇\n\n不够系统： 学的知识点比较分散，关联性太差\n对面试问题：没有问清楚就做出回答，以至于有些问题没有答到点子上，也不能将已有的东西，有效的传达\n对于面试官的总结：总结的不全面，更多总结到一个点，问我是不是，我习惯性的说是的\n\n反思：\n\n如何思考：系统的讲述，点到为止，如果被追问，我再详细描述，举例说明\n明确问题：不清楚的问题，我应该先去搞清楚问题，而不应该急躁的去回答\n主动总结：对于问题的描述，我应该主动去总结，不要等面试官来总结，他是听众，对于我的回答，get 不全，很可能给漏掉了\n心态：比较急躁，最近(好多个，一年前裁的同事维护的项目)项目，找工作诸多事，掺合在一起（既然，要找工作，我就没必要再去揽那么多活了）\n环境：不要去公司电话亭，又黑空气又不好，回答个问题，半睡半醒的状态，困的眼睛睁不开。那么简单的代码没写出来，我都有点怀疑我自己了\n自我修复：一段时间不困，一段时间又太困\n代码书写：了解东西很多，选择困难症，在写代码时候，我既想这样，又想那样\n我所传达的不应该只是知识，更应该是思考和讲述的逻辑性\n\n如何思考\n如何做到头脑清晰，思考有条理？\n如何多维度思考，从哪些维度进行思考？\n有哪些思维模型可以学习借鉴？\n\n如何去分析、回答问题\n时间&#x2F;空间比较：（性能优化）\n纵向&#x2F;横向比较：（技术选型）\n5W2H：\n（描述自己做的项目还是比较不错的）为什么、是什么、什么时间、什么地点、谁、做什么、有哪些收益\n学习新的知识的时候，有针对性的去抓重点\n\n\n整体&#x2F;局部：\n宏观&#x2F;微观：\n抽象&#x2F;具体：（举例说明）\n社会&#x2F;公司&#x2F;个人：\n\n","slug":"2023-02-23思考","date":"2023-02-22T16:38:56.000Z","categories_index":"复盘","tags_index":"复盘","author_index":"举手摘月亮"},{"id":"5589bdb9343542e072e63bc6a1f57ae5","title":"移动端适配 - px2rem","content":"5w2h\n为什么会有 px2rem?\n什么是 px2rem?\n现在？\n我？\n在理论和实现方面？\n要如何深入理解？\n理解到什么程度？\n\n移动端适配的目的移动端适配的宗旨是:\n\n让拥有不同屏幕大小的终端设备拥有一致的 UI 界面,\n让拥有更大屏幕的终端展示更多的内容\n\n几个概念\n设备像素\n设备像素比 DPR = 设备像素 / css 像素\n设计稿：按照设备像素(device pixel)为单位制作设计稿\n前端工作：参照设备像素比(device pixel ratio)进行换算成像素 = 设备像素 / 设备像素比\n\n关系因为root fontSize -&gt; rem布局，所以只需要改变 root fontSize 就可以实现适配\ndevicePixelRatio MDN -->\n\npx2rem 原理\n\n哈～，用 babel 的图改的 babel 图\npx2rem 源码https://github.com/songsiqi/px2rem\n\n文档 px2rem 执行let Px2rem &#x3D; require(&quot;.&#x2F;px2rem&quot;);\nlet px2rem &#x3D; new Px2rem(&#123;\n  remUnit: 75,\n  remPrecision: 8,\n&#125;);\nlet cssText &#x3D; &#96;\n#root&#123;\n    width:750px;\n    height:750px;\n    font-size:12px;&#x2F;*px*&#x2F;\n    border: 1px solid #ddd; &#x2F;*no*&#x2F;\n&#125;\n&#96;;\nlet newCSS &#x3D; px2rem.generateRem(cssText);\nconsole.log(newCSS);\n\n&#x2F;&#x2F; #root &#123;\n&#x2F;&#x2F;   width: 10rem;\n&#x2F;&#x2F;   height: 10rem;\n&#x2F;&#x2F;   border: 1px solid #ddd;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; [data-dpr&#x3D;&quot;1&quot;] #root &#123;\n&#x2F;&#x2F;   font-size: 6px;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; [data-dpr&#x3D;&quot;2&quot;] #root &#123;\n&#x2F;&#x2F;   font-size: 12px;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; [data-dpr&#x3D;&quot;3&quot;] #root &#123;\n&#x2F;&#x2F;   font-size: 18px;\n&#x2F;&#x2F; &#125;\n\n大概知道，它能做什么。对于现在的我来说就是个“黑盒子”，给代码，产出转化后的代码，接下来看看“黑盒子”里面都有什么\n如何调试？\n在 test&#x2F;assets 中，从 test2x.css, 新建一个 test.css 文件\n\ntest.css 文件只保留一个选择器上下各留两段注释\n&#x2F;* normal *&#x2F;\nbody &#123;\n  background: #eee;\n  color: #888; &#x2F;* color is gray *&#x2F;\n  border: 1px solid; &#x2F;*no*&#x2F;\n  height: 20px; &#x2F;* px *&#x2F;\n  padding: 6px; &#x2F;*px*&#x2F;\n  -webkit-animation: anim1 linear infinite;\n&#125;\n\n&#x2F;* hello world *&#x2F;\n\npx2rem.test.js\n&quot;use strict&quot;;\n\nvar assert &#x3D; require(&quot;assert&quot;);\nvar Px2rem &#x3D; require(&quot;..&#x2F;lib&#x2F;px2rem&quot;);\nvar path &#x3D; require(&quot;path&quot;);\nvar fs &#x3D; require(&quot;fs&quot;);\n&#x2F;&#x2F; import: 测试用例\ndescribe(&quot;should work with @2x origin css file&quot;, function () &#123;\n  var px2remIns &#x3D; new Px2rem(&#x2F;*&#123;remUnit: 75, baseDpr: 2&#125;*&#x2F;);\n  var srcPath1 &#x3D; path.join(__dirname, &quot;assets&#x2F;test.css&quot;);\n  var srcText1 &#x3D; fs.readFileSync(srcPath1, &#123; encoding: &quot;utf8&quot; &#125;);\n\n  it(&quot;[default] test&quot;, function () &#123;\n    var outputText &#x3D; px2remIns.generateThree(srcText1); &#x2F;&#x2F; 主要来看下它的执行\n    assert.equal(&quot;1&quot;, &quot;1&quot;); &#x2F;&#x2F; 这里随便写，不是重点\n  &#125;);\n&#125;);\n\ngenerateThree 方法内部打上两行日志：\n\n输入的数据\n之后的数据长什么样子要晓得（即： css.parse(cssText)）\n\n\n\ncss.parse(cssText) 生成的 ast 是什么样子？\n查看代码\n&#123;\n  &quot;type&quot;: &quot;stylesheet&quot;,\n  &quot;stylesheet&quot;: &#123;\n    &quot;rules&quot;: [\n      &#123;\n        &quot;type&quot;: &quot;comment&quot;,\n        &quot;comment&quot;: &quot; normal &quot;,\n        &quot;position&quot;: &#123;\n          &quot;start&quot;: &#123;\n            &quot;line&quot;: 1,\n            &quot;column&quot;: 1\n          &#125;,\n          &quot;end&quot;: &#123;\n            &quot;line&quot;: 1,\n            &quot;column&quot;: 13\n          &#125;\n        &#125;\n      &#125;,\n      &#123;\n        &quot;type&quot;: &quot;rule&quot;,\n        &quot;selectors&quot;: [&quot;body&quot;],\n        &quot;declarations&quot;: [\n          &#123;\n            &quot;type&quot;: &quot;declaration&quot;,\n            &quot;property&quot;: &quot;background&quot;,\n            &quot;value&quot;: &quot;#eee&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 3,\n                &quot;column&quot;: 3\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 3,\n                &quot;column&quot;: 19\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;declaration&quot;,\n            &quot;property&quot;: &quot;color&quot;,\n            &quot;value&quot;: &quot;#888&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 4,\n                &quot;column&quot;: 3\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 4,\n                &quot;column&quot;: 14\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;comment&quot;,\n            &quot;comment&quot;: &quot; color is gray &quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 4,\n                &quot;column&quot;: 16\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 4,\n                &quot;column&quot;: 35\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;declaration&quot;,\n            &quot;property&quot;: &quot;border&quot;,\n            &quot;value&quot;: &quot;1px solid&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 5,\n                &quot;column&quot;: 3\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 5,\n                &quot;column&quot;: 20\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;comment&quot;,\n            &quot;comment&quot;: &quot;no&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 5,\n                &quot;column&quot;: 22\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 5,\n                &quot;column&quot;: 28\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;declaration&quot;,\n            &quot;property&quot;: &quot;height&quot;,\n            &quot;value&quot;: &quot;20px&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 6,\n                &quot;column&quot;: 3\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 6,\n                &quot;column&quot;: 15\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;comment&quot;,\n            &quot;comment&quot;: &quot; px &quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 6,\n                &quot;column&quot;: 17\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 6,\n                &quot;column&quot;: 25\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;declaration&quot;,\n            &quot;property&quot;: &quot;padding&quot;,\n            &quot;value&quot;: &quot;6px&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 7,\n                &quot;column&quot;: 3\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 7,\n                &quot;column&quot;: 15\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;comment&quot;,\n            &quot;comment&quot;: &quot;px&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 7,\n                &quot;column&quot;: 17\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 7,\n                &quot;column&quot;: 23\n              &#125;\n            &#125;\n          &#125;,\n          &#123;\n            &quot;type&quot;: &quot;declaration&quot;,\n            &quot;property&quot;: &quot;-webkit-animation&quot;,\n            &quot;value&quot;: &quot;anim1 linear infinite&quot;,\n            &quot;position&quot;: &#123;\n              &quot;start&quot;: &#123;\n                &quot;line&quot;: 8,\n                &quot;column&quot;: 3\n              &#125;,\n              &quot;end&quot;: &#123;\n                &quot;line&quot;: 8,\n                &quot;column&quot;: 43\n              &#125;\n            &#125;\n          &#125;\n        ],\n        &quot;position&quot;: &#123;\n          &quot;start&quot;: &#123;\n            &quot;line&quot;: 2,\n            &quot;column&quot;: 1\n          &#125;,\n          &quot;end&quot;: &#123;\n            &quot;line&quot;: 9,\n            &quot;column&quot;: 2\n          &#125;\n        &#125;\n      &#125;,\n      &#123;\n        &quot;type&quot;: &quot;comment&quot;,\n        &quot;comment&quot;: &quot; hello world &quot;,\n        &quot;position&quot;: &#123;\n          &quot;start&quot;: &#123;\n            &quot;line&quot;: 11,\n            &quot;column&quot;: 1\n          &#125;,\n          &quot;end&quot;: &#123;\n            &quot;line&quot;: 11,\n            &quot;column&quot;: 18\n          &#125;\n        &#125;\n      &#125;\n    ],\n    &quot;parsingErrors&quot;: []\n  &#125;\n&#125;\n\n:::看上去很乱，不慌，换个方式看看\n源码-&gt;ast 分析节点 1\n\n节点 2\n\n节点 2 精简内容\n\n节点 3\n\n节点 4\n\nastexplorer 同样可以看到效果注意了要选择：rework 格式的，其他格式的转化结果更为复杂\nhttps://astexplorer.net/\n\n\n注释 会生成什么？&#x2F;* normal *&#x2F;\n\n转化成\n&#123;\n  &quot;type&quot;: &quot;comment&quot;,\n  &quot;comment&quot;: &quot; normal &quot;,\n  &quot;position&quot;: &#123;\n    &quot;start&quot;: &#123;\n      &quot;line&quot;:1,&quot;column&quot;: 1;\n    &#125;\n    ,\n    &quot;end&quot;: &#123;\n      &quot;line&quot;:1,&quot;column&quot;: 13;\n    &#125;\n  &#125;\n&#125;\n\n选择器 会生成什么？body &#123;\n  background: #eee;\n  color: #888; &#x2F;* color is gray *&#x2F;\n  border: 1px solid; &#x2F;*no*&#x2F;\n  height: 20px; &#x2F;* px *&#x2F;\n  padding: 6px; &#x2F;*px*&#x2F;\n  -webkit-animation: anim1 linear infinite;\n&#125;\n\n转化成\n:::details 查看代码\n&#123;\n  &quot;type&quot;: &quot;rule&quot;,\n  &quot;selectors&quot;: [&quot;body&quot;],\n  &quot;position&quot;: &#123;\n    &quot;start&quot;: &#123;\n      &quot;line&quot;: 2,\n      &quot;column&quot;: 1\n    &#125;,\n    &quot;end&quot;: &#123;\n      &quot;line&quot;: 9,\n      &quot;column&quot;: 2\n    &#125;\n  &#125;,\n  &quot;declarations&quot;: [\n    &#123;\n      &#x2F;&#x2F; background: #eee;\n      &quot;type&quot;: &quot;declaration&quot;,\n      &quot;property&quot;: &quot;background&quot;,\n      &quot;value&quot;: &quot;#eee&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 3,\n          &quot;column&quot;: 3\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 3,\n          &quot;column&quot;: 19\n        &#125;\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; color: #888; &#x2F;* color is gray *&#x2F; 会拆解成两部分 1. 属性-值  2. 注释\n    &#123;\n      &quot;type&quot;: &quot;declaration&quot;,\n      &quot;property&quot;: &quot;color&quot;,\n      &quot;value&quot;: &quot;#888&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 4,\n          &quot;column&quot;: 3\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 4,\n          &quot;column&quot;: 14\n        &#125;\n      &#125;\n    &#125;,\n    &#123;\n      &quot;type&quot;: &quot;comment&quot;,\n      &quot;comment&quot;: &quot; color is gray &quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 4,\n          &quot;column&quot;: 16\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 4,\n          &quot;column&quot;: 35\n        &#125;\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; border: 1px solid; &#x2F;*no*&#x2F;  会拆解成两部分 1. 属性-值  2. 注释\n    &#123;\n      &quot;type&quot;: &quot;declaration&quot;,\n      &quot;property&quot;: &quot;border&quot;,\n      &quot;value&quot;: &quot;1px solid&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 5,\n          &quot;column&quot;: 3\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 5,\n          &quot;column&quot;: 20\n        &#125;\n      &#125;\n    &#125;,\n    &#123;\n      &quot;type&quot;: &quot;comment&quot;,\n      &quot;comment&quot;: &quot;no&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 5,\n          &quot;column&quot;: 22\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 5,\n          &quot;column&quot;: 28\n        &#125;\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; height: 20px; &#x2F;* px *&#x2F; 会拆解成两部分 1. 属性-值  2. 注释\n    &#123;\n      &quot;type&quot;: &quot;declaration&quot;,\n      &quot;property&quot;: &quot;height&quot;,\n      &quot;value&quot;: &quot;20px&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 6,\n          &quot;column&quot;: 3\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 6,\n          &quot;column&quot;: 15\n        &#125;\n      &#125;\n    &#125;,\n    &#123;\n      &quot;type&quot;: &quot;comment&quot;,\n      &quot;comment&quot;: &quot; px &quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 6,\n          &quot;column&quot;: 17\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 6,\n          &quot;column&quot;: 25\n        &#125;\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; padding: 6px; &#x2F;*px*&#x2F; 会拆解成两部分 1. 属性-值  2. 注释\n    &#123;\n      &quot;type&quot;: &quot;declaration&quot;,\n      &quot;property&quot;: &quot;padding&quot;,\n      &quot;value&quot;: &quot;6px&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 7,\n          &quot;column&quot;: 3\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 7,\n          &quot;column&quot;: 15\n        &#125;\n      &#125;\n    &#125;,\n    &#123;\n      &quot;type&quot;: &quot;comment&quot;,\n      &quot;comment&quot;: &quot;px&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 7,\n          &quot;column&quot;: 17\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 7,\n          &quot;column&quot;: 23\n        &#125;\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; -webkit-animation: anim1 linear infinite;\n    &#123;\n      &quot;type&quot;: &quot;declaration&quot;,\n      &quot;property&quot;: &quot;-webkit-animation&quot;,\n      &quot;value&quot;: &quot;anim1 linear infinite&quot;,\n      &quot;position&quot;: &#123;\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 8,\n          &quot;column&quot;: 3\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 8,\n          &quot;column&quot;: 43\n        &#125;\n      &#125;\n    &#125;\n  ]\n&#125;\n\n\n\n总结&#x2F;* \n1. 含有注释的会被拆解成两部分，不含注释的会被拆为1部分\n2. 属性和值会被拆分成：\n    &#123;\n      &quot;type&quot;: &quot;declaration&quot;, &#x2F;&#x2F; 类型\n      &quot;property&quot;: &quot;padding&quot;, &#x2F;&#x2F; 属性\n      &quot;value&quot;: &quot;6px&quot;,        &#x2F;&#x2F; 值\n      &quot;position&quot;: &#123;          &#x2F;&#x2F; 位置： 代码开始位置（行line，列column），结束位置（行line，列column）\n        &quot;start&quot;: &#123;\n          &quot;line&quot;: 7,\n          &quot;column&quot;: 3\n        &#125;,\n        &quot;end&quot;: &#123;\n          &quot;line&quot;: 7,\n          &quot;column&quot;: 15\n        &#125;\n      &#125;\n    &#125;\n 3.  hello world 注释会被直接转化\n    \n    &#123;\n        &quot;type&quot;: &quot;comment&quot;,\n        &quot;comment&quot;: &quot; hello world &quot;,\n        &quot;position&quot;: &#123;\n          &quot;start&quot;: &#123;\n            &quot;line&quot;: 11,\n            &quot;column&quot;: 1\n          &#125;,\n          &quot;end&quot;: &#123;\n            &quot;line&quot;: 11,\n            &quot;column&quot;: 18\n          &#125;\n        &#125;\n      &#125;\n  4. 选择器与注释之间会被放置到不同的类型中\n*&#x2F;\n\npx2rem - generateThree 源码\n源码重点是 for 循环，因 ast 是树形结构必然是深度遍历\ndeclaration.type === &quot;declaration&quot; &amp;&amp; pxRegExp.test(declaration.value) 匹配到类似 2px的值进行处理\n这个处理有点意思了，它不是直接就处理，而是当后面看看后面的注释是不是注释 px 或 是去完空格是px\n最后一行，直接在语法（json）树上做值的变更declaration.value = self._getCalcValue(&quot;px&quot;, declaration.value, dpr); // common transform（因为是引用类型，直接改 value 就可以了）\n\n\n查看代码\n&#x2F;&#x2F; 根据dpr生成不同 [data-dpr&#x3D;&quot;1&quot;]、[data-dpr&#x3D;&quot;2&quot;]、[data-dpr&#x3D;&quot;3&quot;]\nPx2rem.prototype.generateThree &#x3D; function (cssText, dpr) &#123;\n  console.log(&quot;cssText&quot;, cssText);\n  dpr &#x3D; dpr || 2;\n  var self &#x3D; this;\n  var config &#x3D; self.config;\n  var astObj &#x3D; css.parse(cssText);\n  console.log(&quot;astObj&quot;, JSON.stringify(astObj, null, 2));\n\n  function processRules(rules) &#123;\n    for (var i &#x3D; 0; i &lt; rules.length; i++) &#123;\n      var rule &#x3D; rules[i];\n      &#x2F;&#x2F; 媒体查询\n      if (rule.type &#x3D;&#x3D;&#x3D; &quot;media&quot;) &#123;\n        processRules(rule.rules); &#x2F;&#x2F; recursive invocation while dealing with media queries\n        continue;\n        &#x2F;&#x2F; 动画\n      &#125; else if (rule.type &#x3D;&#x3D;&#x3D; &quot;keyframes&quot;) &#123;\n        processRules(rule.keyframes); &#x2F;&#x2F; recursive invocation while dealing with keyframes\n        continue;\n        &#x2F;&#x2F;\n      &#125; else if (rule.type !&#x3D;&#x3D; &quot;rule&quot; &amp;&amp; rule.type !&#x3D;&#x3D; &quot;keyframe&quot;) &#123;\n        continue;\n      &#125;\n\n      var declarations &#x3D; rule.declarations;\n\n      for (var j &#x3D; 0; j &lt; declarations.length; j++) &#123;\n        var declaration &#x3D; declarations[j];\n        &#x2F;&#x2F; need transform: declaration &amp;&amp; has &#39;px&#39;\n        if (\n          &#x2F;&#x2F; 这里使用了正则进行匹配\n          &#x2F;&#x2F; prettier-ignore\n          declaration.type &#x3D;&#x3D;&#x3D; &quot;declaration&quot; &amp;&amp; pxRegExp.test(declaration.value)\n        ) &#123;\n          var nextDeclaration &#x3D; rule.declarations[j + 1];\n          &#x2F;&#x2F; 注释\n          if (nextDeclaration &amp;&amp; nextDeclaration.type &#x3D;&#x3D;&#x3D; &quot;comment&quot;) &#123;\n            &#x2F;&#x2F; 不进行转化\n            &#x2F;&#x2F; next next declaration is comment\n            if (nextDeclaration.comment.trim() &#x3D;&#x3D;&#x3D; config.keepComment) &#123;\n              &#x2F;&#x2F; no transform\n              declarations.splice(j + 1, 1); &#x2F;&#x2F; delete corresponding comment &#x2F;&#x2F; 完事，把注释删掉\n              continue;\n            &#125; else if (\n              &#x2F;&#x2F; px注释？保持px\n              nextDeclaration.comment.trim() &#x3D;&#x3D;&#x3D; config.forcePxComment\n            ) &#123;\n              &#x2F;&#x2F; force px\n              declarations.splice(j + 1, 1); &#x2F;&#x2F; delete corresponding comment &#x2F;&#x2F; 完事，把注释删掉\n            &#125;\n          &#125;\n          &#x2F;&#x2F; 计算值\n          declaration.value &#x3D; self._getCalcValue(&quot;px&quot;, declaration.value, dpr); &#x2F;&#x2F; common transform\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n\n  processRules(astObj.stylesheet.rules);\n\n  return css.stringify(astObj);\n&#125;;\n\n\n\n_getCalcValue 值的计算&#x2F;&#x2F; get calculated value of px or rem\nPx2rem.prototype._getCalcValue &#x3D; function (type, value, dpr) &#123;\n  console.log(&quot;type, value, dpr&quot;, type, value, dpr);\n  var config &#x3D; this.config;\n  var pxGlobalRegExp &#x3D; new RegExp(pxRegExp.source, &quot;g&quot;);\n\n  function getValue(val) &#123;\n    &#x2F;&#x2F; 计算取多少位精度\n    val &#x3D; parseFloat(val.toFixed(config.remPrecision)); &#x2F;&#x2F; control decimal precision of the calculated value\n    return val &#x3D;&#x3D; 0 ? val : val + type;\n  &#125;\n  &#x2F;&#x2F; 值进行替换操作\n  return value.replace(pxGlobalRegExp, function ($0, $1) &#123;\n    &#x2F;&#x2F; prettier-ignore\n    return type &#x3D;&#x3D;&#x3D; &quot;px&quot; ? getValue(($1 * dpr) &#x2F; config.baseDpr) &#x2F;*保持px*&#x2F;: getValue($1 &#x2F; config.remUnit)&#x2F;*转为rem *&#x2F;;\n  &#125;);\n&#125;;\n\nconfig 的值\n查看代码\nvar defaultConfig &#x3D; &#123;\n  baseDpr: 2, &#x2F;&#x2F; base device pixel ratio (default: 2)\n  remUnit: 75, &#x2F;&#x2F; rem unit value (default: 75)\n  remPrecision: 6, &#x2F;&#x2F; rem value precision (default: 6)\n  forcePxComment: &quot;px&quot;, &#x2F;&#x2F; force px comment (default: &#96;px&#96;)\n  keepComment: &quot;no&quot;, &#x2F;&#x2F; no transform value comment (default: &#96;no&#96;)\n&#125;;\n\nfunction Px2rem(options) &#123;\n  this.config &#x3D; &#123;&#125;;\n  extend(this.config, defaultConfig, options);\n&#125;\n\n&#x2F;&#x2F; 测试代码中有实例化：  var px2remIns &#x3D; new Px2rem(&#x2F;*&#123;remUnit: 75, baseDpr: 2&#125;*&#x2F;);\n&#x2F;&#x2F; 之后执行：          var outputText &#x3D; px2remIns.generateThree(srcText1); &#x2F;&#x2F;默认baseDpr为2\n&#x2F;&#x2F; 所以按照上面运行后： 除了注释外，基本上是原样输出的，不用差异\n\n&#x2F;&#x2F; 改为 var outputText &#x3D; px2remIns.generateThree(srcText1, 1 );\n\n&#x2F;&#x2F; body &#123;\n&#x2F;&#x2F;   background: #eee;\n&#x2F;&#x2F;   color: #888;\n&#x2F;&#x2F;   &#x2F;* color is gray *&#x2F;\n&#x2F;&#x2F;   border: 1px solid;\n&#x2F;&#x2F;   height: 10px;   这个 20x-&gt;10px\n&#x2F;&#x2F;   padding: 3px;   这个 6x-&gt;3px\n&#x2F;&#x2F;   -webkit-animation: anim1 linear infinite;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; 这么改动的原因是执行了 type &#x3D; &#39;px&#39;, 即： getValue(($1 * dpr) &#x2F; config.baseDpr)\n\n&#x2F;&#x2F; 值进行替换操作\n&#x2F;&#x2F; return value.replace(pxGlobalRegExp, function ($0, $1) &#123;\n&#x2F;&#x2F;   &#x2F;&#x2F; prettier-ignore\n&#x2F;&#x2F;   return type &#x3D;&#x3D;&#x3D; &quot;px&quot; ? getValue(($1 * dpr) &#x2F; config.baseDpr) &#x2F;*保持px*&#x2F;: getValue($1 &#x2F; config.remUnit)&#x2F;*转为rem *&#x2F;;\n&#x2F;&#x2F; &#125;);\n&#x2F;&#x2F; function getValue(val) &#123;\n&#x2F;&#x2F;   &#x2F;&#x2F; 计算取多少位精度\n&#x2F;&#x2F;   val &#x3D; parseFloat(val.toFixed(config.remPrecision)); &#x2F;&#x2F; control decimal precision of the calculated value\n&#x2F;&#x2F;   return val &#x3D;&#x3D; 0 ? val : val + type;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; 按照计算逻辑应该是\n&#x2F;&#x2F;   height: 10.000000px;   这个 20x-&gt;10.000000px\n&#x2F;&#x2F;   padding: 3.000000px;   这个 6x-&gt;3.000000px\n\n&#x2F;&#x2F; parseFloat(val.toFixed(config.remPrecision)) ，parseFloat函数，在参数是小数点后都是0的，会做处理 转化成整数了\n\n&#x2F;&#x2F; 嗯到这里就对的上了\n\n:::\nast -&gt; generatecss.stringify(astObj); &#x2F;&#x2F; 将ast转化成代码输出\n\n\nPx2rem.prototype.generateRem:::details 查看代码\n&#x2F;&#x2F; generate rem version stylesheet\nPx2rem.prototype.generateRem &#x3D; function (cssText) &#123;\n  var self &#x3D; this;\n  var config &#x3D; self.config;\n  var astObj &#x3D; css.parse(cssText);\n  &#x2F;**\n   * 规则处理函数\n   * @param &#123;*&#125; rules  规则\n   * @param &#123;*&#125; noDealPx  不处理px,默认是false\n   *&#x2F;\n  function processRules(rules, noDealPx) &#123;\n    &#x2F;&#x2F; FIXME: keyframes do not support &#96;force px&#96; comment\n    for (var i &#x3D; 0; i &lt; rules.length; i++) &#123;\n      var rule &#x3D; rules[i];\n      if (rule.type &#x3D;&#x3D;&#x3D; &quot;media&quot;) &#123;\n        &#x2F;&#x2F; 处理媒体查询时的递归调用\n        processRules(rule.rules); &#x2F;&#x2F; recursive invocation while dealing with media queries\n        continue;\n      &#125; else if (rule.type &#x3D;&#x3D;&#x3D; &quot;keyframes&quot;) &#123;\n        &#x2F;&#x2F; 处理关键帧时的递归调用\n        processRules(rule.keyframes, true); &#x2F;&#x2F; recursive invocation while dealing with keyframes\n        continue;\n      &#125; else if (rule.type !&#x3D;&#x3D; &quot;rule&quot; &amp;&amp; rule.type !&#x3D;&#x3D; &quot;keyframe&quot;) &#123;\n        continue;\n      &#125;\n      &#x2F;&#x2F; 生成 [data-dpr&#x3D;\n      if (!noDealPx) &#123;\n        &#x2F;&#x2F; generate 3 new rules which has [data-dpr]\n        var newRules &#x3D; [];\n        for (var dpr &#x3D; 1; dpr &lt;&#x3D; 3; dpr++) &#123;\n          var newRule &#x3D; &#123;&#125;;\n          newRule.type &#x3D; rule.type;\n          newRule.selectors &#x3D; rule.selectors.map(function (sel) &#123;\n            return &#39;[data-dpr&#x3D;&quot;&#39; + dpr + &#39;&quot;] &#39; + sel;\n          &#125;);\n          newRule.declarations &#x3D; [];\n          newRules.push(newRule);\n        &#125;\n      &#125;\n\n      var declarations &#x3D; rule.declarations;\n      for (var j &#x3D; 0; j &lt; declarations.length; j++) &#123;\n        var declaration &#x3D; declarations[j];\n        &#x2F;&#x2F; need transform: declaration &amp;&amp; has &#39;px&#39;\n        &#x2F;&#x2F; prettier-ignore\n        if (declaration.type &#x3D;&#x3D;&#x3D; &quot;declaration&quot; &amp;&amp; pxRegExp.test(declaration.value)) &#123;\n          var nextDeclaration &#x3D; declarations[j + 1];\n          if (nextDeclaration &amp;&amp; nextDeclaration.type &#x3D;&#x3D;&#x3D; &quot;comment&quot;) &#123;\n            &#x2F;&#x2F; next next declaration is comment\n            if (nextDeclaration.comment.trim() &#x3D;&#x3D;&#x3D; config.forcePxComment) &#123;\n              &#x2F;&#x2F; force px\n              &#x2F;&#x2F; do not transform &#96;0px&#96;\n              if (declaration.value &#x3D;&#x3D;&#x3D; &quot;0px&quot;) &#123;\n                declaration.value &#x3D; &quot;0&quot;;\n                declarations.splice(j + 1, 1); &#x2F;&#x2F; delete corresponding comment\n                continue;\n              &#125;\n              if (!noDealPx) &#123;\n                &#x2F;&#x2F; generate 3 new declarations and put them in the new rules which has [data-dpr]\n                for (var dpr &#x3D; 1; dpr &lt;&#x3D; 3; dpr++) &#123;\n                  var newDeclaration &#x3D; &#123;&#125;;\n                  extend(true, newDeclaration, declaration);\n                  &#x2F;&#x2F; prettier-ignore\n                  newDeclaration.value &#x3D; self._getCalcValue(&quot;px&quot;, newDeclaration.value, dpr);\n                  newRules[dpr - 1].declarations.push(newDeclaration);\n                &#125;\n                declarations.splice(j, 2); &#x2F;&#x2F; delete this rule and corresponding comment\n                j--;\n              &#125; else &#123;\n                &#x2F;&#x2F; FIXME: keyframes do not support &#96;force px&#96; comment\n                &#x2F;&#x2F; prettier-ignore\n                declaration.value &#x3D; self._getCalcValue(&quot;rem&quot;, declaration.value); &#x2F;&#x2F; common transform\n                declarations.splice(j + 1, 1); &#x2F;&#x2F; delete corresponding comment\n              &#125;\n            &#125; else if (nextDeclaration.comment.trim() &#x3D;&#x3D;&#x3D; config.keepComment) &#123;\n              &#x2F;&#x2F; no transform\n              &#x2F;&#x2F; 删除注释\n              declarations.splice(j + 1, 1); &#x2F;&#x2F; delete corresponding comment\n            &#125; else &#123;\n              declaration.value &#x3D; self._getCalcValue(&quot;rem&quot;, declaration.value); &#x2F;&#x2F; common transform\n            &#125;\n          &#125; else &#123;\n            declaration.value &#x3D; self._getCalcValue(&quot;rem&quot;, declaration.value); &#x2F;&#x2F; common transform &#x2F;&#x2F; 普通转化\n          &#125;\n        &#125;\n      &#125;\n      &#x2F;&#x2F; 如果原始规则没有声明，请删除它\n      &#x2F;&#x2F; if the origin rule has no declarations, delete it\n      if (!rules[i].declarations.length) &#123;\n        rules.splice(i, 1);\n        i--;\n      &#125;\n\n      if (!noDealPx) &#123;\n        &#x2F;&#x2F; 添加包含强制使用px的声明的新规则\n        &#x2F;&#x2F; add the new rules which contain declarations that are forced to use px\n        if (newRules[0].declarations.length) &#123;\n          rules.splice(i + 1, 0, newRules[0], newRules[1], newRules[2]);\n          i +&#x3D; 3; &#x2F;&#x2F; skip the added new rules\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n\n  processRules(astObj.stylesheet.rules);\n  return css.stringify(astObj);\n&#125;;\n\n\n\n代码块分析\n\n\n\n\n\n工具调试写个日志，然后pn test输出太麻烦了\ndebug 配置&#123;\n  &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.\n  &#x2F;&#x2F; Hover to view descriptions of existing attributes.\n  &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387\n  &quot;version&quot;: &quot;0.2.0&quot;,\n  &quot;configurations&quot;: [\n    &#x2F;&#x2F; &#123;\n    &#x2F;&#x2F;   &quot;type&quot;: &quot;node&quot;,\n    &#x2F;&#x2F;   &quot;request&quot;: &quot;launch&quot;,\n    &#x2F;&#x2F;   &quot;name&quot;: &quot;Launch Program&quot;,\n    &#x2F;&#x2F;   &quot;skipFiles&quot;: [&quot;&lt;node_internals&gt;&#x2F;**&quot;],\n    &#x2F;&#x2F;   &#x2F;&#x2F; &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;index.js&quot;\n    &#x2F;&#x2F;   &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;test&#x2F;px2rem.test.js&quot;\n    &#x2F;&#x2F; &#125;,\n    &#123;\n      &quot;name&quot;: &quot;Run mocha&quot;,\n      &quot;type&quot;: &quot;node&quot;,\n      &quot;request&quot;: &quot;launch&quot;,\n      &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;node_modules&#x2F;mocha&#x2F;bin&#x2F;_mocha&quot;,\n      &quot;stopOnEntry&quot;: false,\n      &#x2F;&#x2F; &quot;args&quot;: [&quot;test&#x2F;index.js&quot;, &quot;--no-timeouts&quot;],\n      &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,\n      &quot;runtimeExecutable&quot;: null,\n      &quot;env&quot;: &#123;\n        &quot;NODE_ENV&quot;: &quot;testing&quot;\n      &#125;\n    &#125;\n  ]\n&#125;\n\nvscode debug 调试\n\n内部依赖包\ncss 包\nextend 包: for Node.js, 实现 深度拷贝 功能 见\n\n总结\n\n参考链接\n自适应布局方案与 px2rem-loader 加强版源码实现\nhttps://github.com/songsiqi/px2rem\nASTs - What are they and how to use them\n\n代码仓库\ngenerateThree\ngenerateRem\n\n","slug":"2023-02-22px2rem","date":"2023-02-22T12:52:58.000Z","categories_index":"移动端适配","tags_index":"源码,移动端适配","author_index":"举手摘月亮"},{"id":"6048c84185b9e926fc5bd13fc5af10cc","title":"js代码注释","content":"js 文件中的注释\n","slug":"2023-02-22comment","date":"2023-02-22T08:22:35.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"dcd1b904e1a0e1af1d4a643d739dc3fa","title":"css-in-js Emotion","content":"背景最近一段时间，维护敏捷平台的几个相关项目，都是使用 Emotion 进行开发的，所以有必要系统了解下 Emotion\nEmotion 是什么\n使用: 使用 js 编写 css 样式而设计的库\n手段: 提供可预测的样式组合, 支持字符串和对象样式\n效果: 具有源码映射、标签和测试实用程序等功能提高开发人员体验，\n\nEmotion 官网\n组成部分\n@emotion/css 框架无关\n@emotion/react 框架有关 支持css属性\n@emotion/styled 使用 styled.div 风格的 API 来创建组件\n\n@emotion&#x2F;csscss 属性有什么优势？\nstyle: 与 style 属性相似，支持额外的前缀补全，嵌套选择器，媒体查询（这就 👍）\nstyled: 可以不使用styledAPI 直接使用\n接收函数: css 属性可以接受函数，来统一样式和定制一些值\n减少模版代码\n样式覆盖: 个人觉得对于已有的样式进行样式覆盖非常灵活，完全可以用 js 来控制\n\n支持原生的样式（看上去像一个类）import &#123; css &#125; from &quot;@emotion&#x2F;css&quot;;\n\nconst app &#x3D; document.getElementById(&quot;root&quot;);\nconst myStyle &#x3D; css&#96;\n  color: rebeccapurple;\n&#96;;\n&#x2F;&#x2F; 放到了classList上\napp.classList.add(myStyle);\n\n四类 API\nGenerate Class Names — css\nGlobal Styles — injectGlobal\nAnimation Keyframes — keyframes\nComposing Class Names — cx\n\nGenerate Class Names — css1. string 形式的样式类&#x2F;&#x2F; @live\nimport &#123; css &#125; from &quot;@emotion&#x2F;css&quot;;\n\nconst color &#x3D; &quot;darkgreen&quot;;\n\nrender(\n  &#x2F;&#x2F; prettier-ignore\n  &lt;div\n    className&#x3D;&#123;css&#96;\n      background-color: hotpink;\n      &amp;:hover &#123;\n        color: $&#123;color&#125;; &#123;&#x2F;*这里可以添加变量，“字符串模版”  *&#x2F;&#125;\n      &#125;\n    &#96;&#125;\n  &gt;\n    This has a hotpink background.\n  &lt;&#x2F;div&gt;\n);\n\n2. 对象形式的样式类&#x2F;&#x2F; @live\nimport &#123; css &#125; from &#39;@emotion&#x2F;css&#39;\n\nconst color &#x3D; &#39;darkgreen&#39;\n\nrender(\n  &#x2F;&#x2F; prettier-ignore\n  &lt;div\n    className&#x3D;&#123;css(&#123;       &#123;&#x2F;*像扩展后的jsx中的 style  *&#x2F;&#125;\n      backgroundColor: &#39;hotpink&#39;,\n      &#39;&amp;:hover&#39;: &#123;\n        color\n      &#125;\n    &#125;)&#125;\n  &gt;\n    This has a hotpink background.\n  &lt;&#x2F;div&gt;\n)\n\n3. 数组对象形式的样式类&#x2F;&#x2F; @live\nimport &#123; css &#125; from &#39;@emotion&#x2F;css&#39;\n\nconst color &#x3D; &#39;darkgreen&#39;\nconst isDanger &#x3D; true\n\nrender(\n  &#x2F;&#x2F; prettier-ignore\n  &lt;div\n    className&#x3D;&#123;css([\n      &#123;\n        backgroundColor: &#39;hotpink&#39;,\n        &#39;&amp;:hover&#39;: &#123;\n          color\n        &#125;\n      &#125;,\n      &#123;&#x2F;* 动态控制 *&#x2F;&#125;\n      isDanger &amp;&amp; &#123;\n        color: &#39;red&#39;\n      &#125;\n    ])&#125;\n  &gt;\n    This has a hotpink background.\n  &lt;&#x2F;div&gt;\n)\n\nGlobal Styles — injectGlobal4. 全局样式类import &#123; injectGlobal &#125; from &quot;@emotion&#x2F;css&quot;;\n&#x2F;&#x2F; 用于全局的样式覆盖\ninjectGlobal&#96;\n  * &#123;\n    box-sizing: border-box;\n  &#125;\n  @font-face &#123;\n    font-family: &#39;Patrick Hand SC&#39;;\n    font-style: normal;\n    font-weight: 400;\n    src: local(&#39;Patrick Hand SC&#39;),\n      local(&#39;PatrickHandSC-Regular&#39;),\n      url(https:&#x2F;&#x2F;fonts.gstatic.com&#x2F;s&#x2F;patrickhandsc&#x2F;v4&#x2F;OYFWCgfCR-7uHIovjUZXsZ71Uis0Qeb9Gqo8IZV7ckE.woff2)\n        format(&#39;woff2&#39;);\n    unicode-range: U+0100-024f, U+1-1eff,\n      U+20a0-20ab, U+20ad-20cf, U+2c60-2c7f,\n      U+A720-A7FF;\n  &#125;\n&#96;;\n\nAnimation Keyframes — keyframes5. string 形式的动画帧&#x2F;&#x2F; @live\nimport &#123; css, keyframes &#125; from &quot;@emotion&#x2F;css&quot;;\n&#x2F;&#x2F; 这里是字符串模版\nconst bounce &#x3D; keyframes&#96;\n  from, 20%, 53%, 80%, to &#123;\n    transform: translate3d(0,0,0);\n  &#125;\n\n  40%, 43% &#123;\n    transform: translate3d(0, -30px, 0);\n  &#125;\n\n  70% &#123;\n    transform: translate3d(0, -15px, 0);\n  &#125;\n\n  90% &#123;\n    transform: translate3d(0,-4px,0);\n  &#125;\n&#96;;\n\nrender(\n  &lt;img\n    className&#x3D;&#123;css&#96;\n      width: 96px;\n      height: 96px;\n      border-radius: 50%;\n      animation: $&#123;bounce&#125; 1s ease infinite;\n      transform-origin: center bottom;\n    &#96;&#125;\n    src&#x3D;&#123;logoUrl&#125;\n  &#x2F;&gt;\n);\n\n6. 对象形式的动画帧&#x2F;&#x2F; @live\nimport &#123; css, keyframes &#125; from &quot;@emotion&#x2F;css&quot;;\n&#x2F;&#x2F; jsx对象风格\nconst bounce &#x3D; keyframes(&#123;\n  &quot;from, 20%, 53%, 80%, to&quot;: &#123;\n    transform: &quot;translate3d(0,0,0)&quot;,\n  &#125;,\n  &quot;40%, 43%&quot;: &#123;\n    transform: &quot;translate3d(0, -30px, 0)&quot;,\n  &#125;,\n  &quot;70%&quot;: &#123;\n    transform: &quot;translate3d(0, -15px, 0)&quot;,\n  &#125;,\n  &quot;90%&quot;: &#123;\n    transform: &quot;translate3d(0, -4px, 0)&quot;,\n  &#125;,\n&#125;);\n\nrender(\n  &lt;img\n    src&#x3D;&#123;logoUrl&#125;\n    className&#x3D;&#123;css(&#123;\n      width: 96,\n      height: 96,\n      borderRadius: &quot;50%&quot;,\n      &#123;&#x2F;* 在这里当变量使用 *&#x2F;&#125;\n      animation: &#96;$&#123;bounce&#125; 1s ease infinite&#96;,\n      transformOrigin: &quot;center bottom&quot;,\n    &#125;)&#125;\n  &#x2F;&gt;\n);\n\nComposing Class Names — cx7. cx API 合并样式类import &#123; cx, css &#125; from &#39;@emotion&#x2F;css&#39;\n\nconst cls1 &#x3D; css&#96;\n  font-size: 20px;\n  background: green;\n&#96;\nconst cls2 &#x3D; css&#96;\n  font-size: 20px;\n  background: blue;\n&#96;\n&#x2F;&#x2F; 类似 classnames的效果\n&lt;div className&#x3D;&#123;cx(cls1, cls2)&#125; &#x2F;&gt;\n\n8. cx API 按条件合并样式类const cls1 &#x3D; css&#96;\n  font-size: 20px;\n  background: green;\n&#96;;\nconst cls2 &#x3D; css&#96;\n  font-size: 20px;\n  background: blue;\n&#96;;\n\nconst foo &#x3D; true;\nconst bar &#x3D; false;\n\n&#x2F;&#x2F; classnames的效果\n&lt;div className&#x3D;&#123;cx(&#123; [cls1]: foo &#125;, &#123; [cls2]: bar &#125;)&#125; &#x2F;&gt;;\n\n9. cx API 引入其他样式类const cls1 &#x3D; css&#96;\n  font-size: 20px;\n  background: green;\n&#96;;\n\n&#123;\n  &#x2F;* profile其他文件资源 *&#x2F;\n&#125;\n&lt;div className&#x3D;&#123;cx(cls1, &quot;profile&quot;)&#125; &#x2F;&gt;;\n\n@emotion&#x2F;react代码如何书写import &#123; css &#125; from &quot;@emotion&#x2F;react&quot;;\n\nconst color &#x3D; &quot;white&quot;;\n\nrender(\n  &lt;div\n    css&#x3D;&#123;css&#96;\n      padding: 32px;\n      background-color: hotpink;\n      font-size: 24px;\n      border-radius: 4px;\n      &amp;:hover &#123;\n        color: $&#123;color&#125;;\n      &#125;\n    &#96;&#125;\n  &gt;\n    Hover to change color.\n  &lt;&#x2F;div&gt;\n);\n\n@emotion&#x2F;styled是什么使用 styled.div风格来创建组件\n代码如何书写import styled from &quot;@emotion&#x2F;styled&quot;;\n&#x2F;&#x2F; 声明一个具有这组样式的组件（组件名要大写）\nconst Button &#x3D; styled.button&#96;\n  padding: 32px;\n  background-color: hotpink;\n  font-size: 24px;\n  border-radius: 4px;\n  color: black;\n  font-weight: bold;\n  &amp;:hover &#123;\n    color: white;\n  &#125;\n&#96;;\n&#x2F;&#x2F; 使用这个新声明的组件（这不是antd的Button组件）\nrender(&lt;Button&gt;This my button component.&lt;&#x2F;Button&gt;);\n\nEmotion Snippets vscode 插件\nvscode-styled-components: code intellisense issue 447\nvscode-styled-jsx: code hightlight\nEmotion Snippets: 代码片段(我觉得手动自定义会更好些，太多的插件太笨重)\n\nEmotion Snippets\n\n改为自定义代码片段，不安装插件。。。 -->\n\nvscode-styled-components 提示效果\n横向对比优点\n\n相比less, sass 老牌的 css 预编译，更方便，功能更多\n没有tailwindcss,较为分散的诸多样式类选择器\n\n缺点：\n\n相比tailwindcss, cssinjs 会生成更多独立的 hash 类，我觉得有可能增大 css 的加载\n或许，分散的样式要统一到某个文件夹下，写成.js 或.ts 进行复用\n\n总结主要 emotion 主要部分是 emotion&#x2F;css\n\nGenerate Class Names — css\nAnimation Keyframes — keyframes\nComposing Class Names — cx\nGlobal Styles — injectGlobal\n\napi 支持字符串、对象、数组，和函数，以及逻辑判断，灵活方便\n参考链接\nemotion.sh&#x2F;docs\n@emotion&#x2F;css#api\n[Question] any editor plugins to write CSS in js #447\nVS Code syntax highlighting #1316 \n\n","slug":"2023-02-21css_in_js","date":"2023-02-21T06:20:01.000Z","categories_index":"css-in-js","tags_index":"css-in-js","author_index":"举手摘月亮"},{"id":"18f2de6f6ea6d59c8b217d81ff25660d","title":"性能优化-Preload, Prefetch And Priorities in Chrome","content":"Preload, Prefetch 是如何工作的`和``）如何在幕后工作，以便您可以更有效地使用它们 -->\n\n正如其他文章中很好地介绍的那样，preload 是一种声明式获取，允许您强制浏览器发出对资源的请求，而不会阻止文档的 onload 事件\nprefetch 是向浏览器提示可能需要资源，但将决定是否以及何时加载委托给浏览器\npreload 可以将加载事件与脚本解析时间分离。\n如果您以前没有使用过它，请阅读“预加载：它有什么好处？”Yoav Weiss\n预加载在生产中被大型站点用于许多用例，您可以在本文后面找到更多。在此之前，让我们深入了解网络堆栈实际上如何处理预加载与预取。\n什么时候用，用哪个？&lt;link rel=&quot;preload&quot;&gt;vs&lt;link rel=&quot;prefetch&quot;&gt;\n提示：\n\n您高度信任的预加载资源将在当前页面中使用。\n预取资源可能用于跨多个导航边界的未来导航\npreload 用于请求页面所需的资源（关键脚本、Web 字体、图像）\npreload 用户未来的导航（例如在视图或页面之间），其中获取的资源和请求需要跨导航保持不变。\n如果页面 A 为页面 B 所需的关键资源发起预取请求，关键资源和导航请求可以并行完成。\n如果我们对这个用例使用预加载，它将在页面 A 卸载时立即被取消。\n\n在 preload 和 prefetch 之间，我们得到了为当前导航or未来导航加载关键资源的解决方案\n&lt;link rel=&quot;preload&quot;&gt;和&lt;link rel=&quot;prefetch&quot;&gt;的缓存行为是什么？Chrome 有四个缓存：\n\nHTTP 缓存、\nService Worker 缓存\n内存缓存、\nPush 缓存。\n\n预加载和预取资源都存储在 HTTP 缓存中\n当资源被预加载或预取时，缓存过程：从网络堆栈 -&gt; HTTP 缓存 -&gt; 渲染器的内存缓存。\n\n如果资源可以被缓存（例如， valid cache-control with valid max-age），它就会存储在 HTTP 缓存中，并且可用于当前和未来的会话。\n如果资源不可缓存，它不会存储在 HTTP 缓存中。相反，它会上升到内存缓存并停留在那里，直到它被使用。\n\nChrome 的网络优先级如何处理预加载和预取？script根据它们在文档中的位置以及它们是异步、延迟还是阻塞而获得不同的优先级\n图片图像（可视且在视口中）的优先级（净：中等）高于不在视口中的图像（净：最低）\n所以在某种程度上 Chrome 最好为您伪延迟加载这些图像。图像以较低的优先级开始，布局完成后，发现它们在视口中，将获得优先级提升（但请注意，布局完成时已经在飞行中的图像不会重新排序）\n“as”属性预加载的资源预加载 as&#x3D;”style”将获得最高优先级，而 as&#x3D;”script”将获得低或中优先级。\n当页面尝试预加载已缓存在 Service Worker 缓存、HTTP 缓存或两者中的资源时会发生什么？视情况而定，但一般来说，资源不会从网络中重新获取，除非它已经从 HTTP 缓存中过期，或者 Service Worker 有意重新获取它。\n如果资源在 HTTP 缓存中（在 SW 缓存和网络之间），则预加载应该从同一资源获得缓存命中。\n是否会浪费用户带宽?使用“预加载”或“预取”，会浪费用户带宽的风险，尤其是在资源不可缓存的情况下。\n没有使用的预加载，会收到警告：\n\n\n发出此警告的原因是，您可能正在使用预加载来尝试为您需要提高性能的其他资源预热缓存，但如果这些预加载的资源没有被使用，您无缘无故地做了额外的工作。在移动设备上，这等于浪费了用户的数据计划，因此请注意您正在预加载的内容。\n什么会导致双重获取?\n\n\nprefetch作为preload的后备\nfetch（）与 preload 一起工作\n预加载的内容（例如脚本）时没有提供有效的“as”\n没有跨域的预加载字体将双重获取\n完全预加载所有内容\n\n不要使用“prefetch”作为“preload”的后备。它们再次被用于不同的目的，并且通常最终会导致双重获取，而这可能不是您的意图。如果支持为当前会话预热缓存，请使用 preload，否则为未来会话预取。不要使用一个代替另一个\n暂时不要依赖 fetch（）与 preload 一起工作。 Chrome 如果您尝试将 preload 与 fetch（）API 一起使用，您最终会触发双重下载。XHR 目前不会发生这种情况\n如果您在指定要预加载的内容（例如脚本）时没有提供有效的“as”，您最终将获取两次\n没有跨域的预加载字体将双重获取！确保在使用预加载获取字体时添加跨域属性，否则它们将被双重下载。使用匿名模式 CORS 请求它们。即使字体与页面位于同一原点，此建议也适用。这也适用于其他匿名获取（例如默认情况下的 XHR）\n不要尝试完全预加载所有内容！相反，选择您想要更早加载的特定后期发现的资源，并使用预加载告诉浏览器它们\n全部资源都预加载？有什么建议和限制？预加载可能在您的页面后期发现的资源，但在其他方面很重要的是要尽早获取。\n对于脚本，预加载您的密钥包很好，因为它以一种仅使用&lt;script async&gt;不会阻止窗口的 onload 事件的方式将获取与执行分开。您可以预加载图像、样式、字体、媒体。最重要的是，您可以更好地控制早期获取，作为页面作者，您知道您的页面肯定需要尽早获取。\nprefetch 有什么特点\n在 Chrome 中，如果用户在其他页面的预取请求仍在运行时离开页面，则这些请求不会被终止。\n此外，无论资源的可缓存性如何，预取请求都会在未指定的网络堆栈缓存中维护至少 5 分钟。\n\n使用 JS 编写的自定义“预加载”实现。这与 rel&#x3D;”preload”或 Preload 标头有何不同？预加载将获取资源与 JS 处理和执行分离。因此，标记中声明的预加载由预加载扫描器在 Chrome 进行优化。这意味着在许多情况下，预加载将在超文本标记语言解析器到达标记之前被获取（具有指定的优先级）。这使得它比自定义预加载实现更强大。\n如何功能检测对链接 rel&#x3D;preload 的支持？const preloadSupported &#x3D; () &#x3D;&gt; &#123;\n  const link &#x3D; document.createElement(&quot;link&quot;);\n  const relList &#x3D; link.relList;\n  if (!relList || !relList.supports) return false;\n  return relList.supports(&quot;preload&quot;);\n&#125;;\n\n可以立即应用预加载的 CSS 样式表吗？可以。预加载支持基于标记的异步加载。使用加载的样式表可以使用’onload’事件立即应用于当前文档，如下所示：\n&lt;!-- prettier-ignore --&gt;\n&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;style.css&quot; onload&#x3D;&quot;this.rel&#x3D;stylesheet&quot;&gt;\n\n当前浏览器对 Preload 和 Prefetch 的支持如何？&lt;link rel=&quot;preload&quot;&gt;可供全球约 50%的用户使用，并在 Safari 技术预览版中实现。&lt;link rel=&quot;prefetch&quot;&gt;可供全球 71%的用户使用。\n原文链接Preload, Prefetch And Priorities in Chrome\n","slug":"2023-02-20priorities","date":"2023-02-20T10:13:09.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"举手摘月亮"},{"id":"3badd62824c1bd78d6cf74cef1c634b2","title":"react-native性能优化","content":"性能优化\n使用 Image 缓存解决方案，使用适当大小的图片\nAnimated 库中使用 nativeDriver\n避免不必要的渲染\n不要在源代码中保留 console 表达式\n使用 Flipper 进行调试\n使用 Hermes\n不要使用 Scrollview 渲染一个大列表数据\n\n思维导图\n\nReact Native 性能优化总结\n性能分析工具\nReact Native 官方调试工具 这个官网说的很清楚了，具体内容可见 直达链接。\nreact-devtools React Native 是跑在原生 APP 上的，布局查看不能用浏览器插件，所以要用这个基于 Electron 的 react-devtools。\nXCode OS 开发 IDE，查看分析性能问题时可以用 instruments 和 Profiler 进行调试。\nAndroid Studio Android 开发 IDE，查看性能的话可以使用 Android Profiler， 官方网站写的非常详细。\niOS Simulator iOS 模拟器，它的 Debug 可以看一些分析内容\n\n参考链接React Native 性能优化：应该做和不应该做的React Native 性能优化指南\n","slug":"2023-02-19rn-performance-o","date":"2023-02-19T15:06:09.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"935f55a55c003dca5fd748af01a100e2","title":"React18 版本主要更新内容","content":"react 18\n修 bug\n\n由于并发模式可能带来破坏，所以 react18 的并发模式可选\nSuspense fallback=&#123;undefined&#125; 表现与null相同\n\n\n增加开发体验\n\n自动批处理: 之前需要使用 ReactDOM.unstable_batchedUpdates, 现在： 超时、promise、本机事件处理程序、任何其他事件被批处理\n内置 React.lazy + Suspense\nuseId: 生成唯一 ID\nuseTransition、useDeferredValue: 将紧急更新与非紧急更新分开\n2 个新的渲染api: createRoot 和 hydrateRoot ：应用的根节点也向我们暴露了出来，渲染整个应用的时候只需要调用 root 的 render 方法\n\n\n为其他框架库提供扩展\n\nuseInsertionEffect: 为 CSS-in-JS 库添加\nuseSyncExternalStore: 帮助外部存储库与 React 集成。\n\n\n为以后做准备\n\n严格模式模拟卸载和重新挂载\n\n\n\nNew Feature: Automatic Batching之前：只有React事件被批处理。\nsetTimeout(() &#x3D;&gt; &#123;\n  setCount((c) &#x3D;&gt; c + 1);\n  setFlag((f) &#x3D;&gt; !f);\n  &#x2F;&#x2F; React将渲染两次，每次状态更新一次（无批处理）\n&#125;, 1000);\n\n&#x2F;&#x2F;之后：超时、promise、本机事件处理程序或任何其他事件被批处理\nsetTimeout(() &#x3D;&gt; &#123;\n  setCount((c) &#x3D;&gt; c + 1);\n  setFlag((f) &#x3D;&gt; !f);\n&#x2F;&#x2F; React最后只会重新渲染一次（那是批处理！）\n&#125;, 1000);\n\nNew Feature: Transitions过渡是 React 中的一个新概念，用于区分: 紧急更新和非紧急更新。\n\n输入、点击或按下等紧急更新需要立即响应，以符合我们对物理对象行为的直觉。否则他们会感到“错误”。\n过渡是不同的，因为用户不期望在屏幕上看到每个中间值。\n\nimport &#123; startTransition &#125; from &#39;react&#39;;\n\n&#x2F;&#x2F; Urgent: Show what was typed\nsetInputValue(input);\n\n&#x2F;&#x2F; Mark any state updates inside as transitions\nstartTransition(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; Transition: Show the results\n  setSearchQuery(input);\n&#125;);\n\nNew Suspense FeaturesSuspense 允许您以声明方式指定组件树的一部分的加载状态，如果它还没有准备好显示\n\n之前版本：可以使用 Suspense 在客户端进行代码拆分 React.lazy.\n现在版本：Suspense支持数据请求\n未来版本：Suspense callback可以处理任何异步操作（加载代码、数据、图像等）。\n\nNew Client and Server Rendering APIs&#x2F;&#x2F; createRoot: ReactDOM.render;\n&#x2F;&#x2F; hydrateRoot: ReactDOM.hydrate;\n\n新的严格模式行为将来，我们想添加一个功能，允许 React 在保留状态的同时添加和删除 UI 的部分。\n例如，当用户离开屏幕并返回时，React 应该能够立即显示上一个屏幕。为此，React 将使用与以前相同的组件状态卸载和重新挂载树。\n此功能将为 React 应用程序提供开箱即用的更好性能，但需要组件对多次挂载和销毁的效果具有弹性。\n大多数效果无需任何更改即可工作，但有些效果假设它们只挂载或销毁一次。\n\n\n\n\n\n\n\n\n\n在官网中大概是这样解释的，&lt;React.StrictMode&gt;和 Fragment 作用相似，仅仅是作为一个容器，不会被渲染出任何的真实 UI，它为其后代元素触发额外的检查和报告。我们可以在任何地方利用此标签开启严格模式，比如在组件中和 App.js(入口文件)中。当启用检查后，会对后代元素都进行检查。\n在此更改之前，React 会挂载组件并创建效果：&#x2F;&#x2F; * React mounts the component.\n&#x2F;&#x2F;    * Layout effects are created.\n&#x2F;&#x2F;    * Effects are created.\n\n&#x2F;&#x2F; 使用React 18中的严格模式，React将在开发模式下模拟卸载和重新挂载组件：\n\n&#x2F;&#x2F; * React mounts the component. [挂在组件]\n&#x2F;&#x2F;   * Layout effects are created.\n&#x2F;&#x2F;   * Effects are created.\n&#x2F;&#x2F; * React simulates unmounting the component.【模拟卸载组件】\n&#x2F;&#x2F;   * Layout effects are destroyed.\n&#x2F;&#x2F;   * Effects are destroyed.\n&#x2F;&#x2F; * React simulates mounting the component with the previous state.【使用先前状态，模拟组件挂载】\n&#x2F;&#x2F;   * Layout effects are created.\n&#x2F;&#x2F;   * Effects are created.\n\n新的 hooks &amp; other\nuseId: 添加 useId 以生成唯一 ID\nuseTransition、useDeferredValue: 添加 useTranption 和 useDeferredValue 以将紧急更新与转换分开\nuseInsertionEffect: 为 CSS-in-JS 库添加 useInsertionEffects\nuseSyncExternalStore: 添加 useSyncExternalStore 以帮助外部存储库与 React 集成。\nStrictMode: 使&lt;StrictMode&gt;重新运行效果以检查可恢复状态。\nSuspense fallback=&#123;undefined&#125; 表现与null相同.\n\n参考资料React 的严格模式(React.StrictMode)\n","slug":"2023-02-19react18","date":"2023-02-19T11:37:57.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"a625702239d2378e2ca779050afa4d60","title":"RN performance","content":"bundle 优化bundle 优化速览\n环境预创建\n异步检测、下载\n公用资源拆包\n按需加载\n新版本\n\n一、React Native 环境预创建一个载体页一个引擎。\n通常，一个 React Native 页面从加载渲染到展示大致分为以下几步：\n【React Native 环境初始化】 -&gt; 【下载&#x2F;加载 bundle】 -&gt; 【执行 JavaScript 代码】\n\n在 Android 环境中是特别耗时的。所以，我们想到的第一个优化点就是提前将 React Native 环境创建好\n二、异步更新(rn 更新思路)原先我们进入 React Native 载体页后需要先下载最新的 JavaScript 代码包版本，若有更新，就要下载最新的包并加载。在这个过程中，我们会经历两次网络请求，即获取是否有更新，如果有下载热更新的 bundle 包。如果用户网络比较差，下载 bundle 包就会很慢，最终等待时间也会较长。\n针对部分特殊的页面，采取了异步更新的策略。异步更新策略的主要思路为:\n\n在进入页面之前选择性地提前下载 JavaScript 代码包，\n进入载体页后再看 JavaScript 代码包是否有缓存，如果有，我们就优先加载缓存并渲染；\n然后再异步检测是否有最新版本的 JavaScript 代码包，\n如果有，下载到本地并进行缓存，再等下次进入载体页时生效。\n\n优化前\n\n打开一个 RN 页面所需要经历的一些流程。流程图中可以看出，我们从进入载体页到渲染页面，需要两次网络请求，不管网速快还是慢，这个流程算是比较漫长的\n优化后渲染与版本检测进行分离，在进行异步更新后，我们的流程就会变成下图这样\n\n\n更新时机提前下载业务代码包\n在业务页面中，我们可以对 JavaScript 代码包进行提前下载并缓存，在用户跳转到 React Native 页面后，检测是否有缓存的 JavaScript 代码包，如果有我们就直接渲染页面。这样就不需要等待版本号检测网络接口以及下载最新包的网络接口，也不依赖于用户的网络情况，减少了用户等待时间。\n非必要更新，下次启动后生效\n在渲染页面的同时，我们通过异步检测 JavaScript 代码包的版本，若有新版本就进行更新并缓存，下次生效。当然，业务也可以选择更新完最新包之后，提示用户有新版本页面，以及是否选择刷新并加载最新页面。\n问题： 更新链路比较长\n\n\n\n整个流程是从 React Native 环境初始化到热更新 ，再到 JavaScript 业务代码执行，最后到业务界面展示。\n链路比较长，而且每一个步骤都依赖前一个步骤的结果。\n特别是热更新流程，最长可涉及两次网络调用，分别是检测是否需要更新与下载最新 bundle 文件。\n\n针对这种场景，我们想到一个优化点，在等待网络返回的过程中，Native 能不能把闲置的 CPU 资源利用起来呢？\n三、接口预缓存在纯客户端开发中，我们经常使用接口数据缓存策略来提升用户体验，在最新数据返回前，先使用缓存数据进行页面渲染。\n四、拆包Common + 业务 bundleReact Native 页面的 JavaScript 代码包是热更新平台根据版本号进行下发的，每次有业务改动，我们都需要通过网络请求更新代码包。不过，只要 React Native 官方版本没有发生变化，JavaScript 代码包中 React Native 源码相关的部分是不会发生变化的，所以我们不需要在每次业务包更新的时候都进行下发，在工程中内置一份就好了。\n因此，我们在对 JavaScript 代码进行打包的时候，需要讲包拆分成两个部分：\n\n一个是 Common 部分，也就是 React Native 源码部分；\n另一个是业务代码部分，也就是我们需要动态下载的部分。\n\n\n\n方案：经过上面的拆分后，Common 包内置到工程中（至少为几百 kb 的大小），业务代码包进行动态下载。然后我们利用 JSContext 环境，在进入载体页后在环境中先加载 Common 包，再加载业务代码包就可以完整的渲染出 React Native 页面\n五、按需加载问题其实我们通过前面拆包的方案，已经减少了动态下载的业务代码包的大小。但是还会存在部分业务非常庞大，拆包后业务代码包的大小依然很大的情况，依然会导致下载速度较慢，并且还会受网络情况的影响。\n因此，我们可以再次针对业务代码包进行拆分，将一个业务代码包拆分为一个主包和多个子包的方式。在进入页面后优先请求主包的 JavaScript 代码资源，能够快速地渲染首屏页面，紧接着用户点击某一个模块时，再继续下载对应模块的代码包并进行渲染，就能再进一步减少加载时间。\n\n\n按需加载前提那么，什么时候需要把业务代码包拆分成一个主包和多个子包呢？把什么模块作为主包，什么模块作为子包比较合适呢？\n其实，当业务逻辑比较简单的时候，我们并不需要对业务代码包进行拆分，当时当业务比较复杂的时候，特别是一些大型的项目就有可能需要进行拆包，而拆包的逻辑，通常是按照业务进行拆分的。举个例子，我们有一下这个包含 Tab 的业务页面\n六、其他优化数据缓存在 React Native 移动端的性能优化中，除了 React Native 环境创建、bundle 文件、接口数据等方面的优化外，还有一个大的优化点，就是 React Native 运行时优化。\n使用新版本新架构众所周知，React Native 旧版本的运行效率有两大痛点：\n\n是 JSC 引擎解释执行 JavaScript 代码效率低，引擎启动速度慢；\n是 JavaScript 与 Native 通信效率低，特别是涉及批量地 UI 交互更是如此。\n\n所以，React Native 新架构采用了 JSI 进行通信，替换了 JSBridge，无异步地序列化与反序列化操作、无内存拷贝，可以做到同步通信。\nHermes除此之外，React Native 0.60 及以后的版本开始支持 Hermes 引擎。\n对比 JSC 引擎，Hermes 引擎在启动速度、代码执行效率上都有大幅提升，所以接下来我们就来重点讲解 Hermes 引擎的特点、它的优化手段以及如何在移动端启用。\n爬取标题脚本var hlist &#x3D; temp1.getElementsByTagName(&#39;h2&#39;);\nvar data &#x3D; &#39;&#39;;\nfunction gethlist(_domlist) &#123;\n  Array.from(_domlist).forEach((li) &#x3D;&gt; &#123;\n    var title &#x3D; li.innerText;\n    data &#x3D; data + &#96;#### $&#123;title&#125; \\n\\n&#96;;\n  &#125;);\n&#125;\ngethlist(hlist);\ncopy(data);\n\nreact-native 端代码优化\n减少 re-render\n减轻渲染压力\n图片优化那些事\n对象创建调用分离\n动画性能优化\n长列表性能优化\nReact Native 性能优化用到的工具\n\n一、减少 re-render\nshouldComponentUpdate\nReact.PureComponent\nReact.memo、React.callback\n\n二、减轻渲染压力\n使用 React.Fragment 避免多层嵌套,RN 好像没有\n\n三、图片优化那些事\nImage 组件的优化项\n加载本地&#x2F;网络图片\n自动匹配 @2x&#x2F;@3x 图片\n图片加载事件：onLoadStart&#x2F;onLoad&#x2F;onLoadEnd&#x2F;onError\nloading 默认图 or loading 指示器\n\n\n使用图片管理优化库图片优化前，我们先想一下，一个基本的图片下载管理库要实现什么：\n下载管理：在加载多张图片的场景，能管理好多个请求，可以控制图片加载的优先级\n图片类型：首先你的主要职责是加载图片，你起码能加载多种图片类型\n缓存管理：做好三级缓存，不能每个图片都要请求网络，均衡好内存缓存和磁盘缓存的策略\n多图加载：大量图片同时渲染时，如何让图片迅速加载，减少卡顿\n\n\n图片服务器辅助\n\n四、对象创建调用分离\n绑定回调函数\nStyleSheet.flatten([styles.item, props.style]) &#x2F;&#x2F; &lt;&#x3D; 合并默认样式和自定义样式\n避免在 render 函数里创建新数组&#x2F;对象\n\n五、动画性能优化六、长列表性能优化React Native 有好几个列表组件，先简单介绍一下：\n\nScrollView：会把视图里的所有 View 渲染，直接对接 Native 的滚动列表\nVirtualizedList：虚拟列表核心文件，使用 ScrollView，长列表优化配置项主要是控制它\nFlatList：使用 VirtualizedList，实现了一行多列的功能，大部分功能都是 VirtualizedList 提供的\nSectionList：使用 VirtualizedList，底层使用 VirtualizedSectionList，把二维数据转为一维数据\n\nVirtualizedList 有个 debug 的配置项，开启后会在视图右侧显示虚拟列表的显示情况\n七、React Native 性能优化用到的工具参考链接React Native 如何做性能优化\nreact-native 端代码优化\n","slug":"2023-02-19rn-performance","date":"2023-02-19T09:11:10.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"6f467a9b3152eb555a0298695fd77d63","title":"技术选型-考虑因素","content":"\n\n考虑的角度\n纵向考虑：\n过去 看公司内部：现有技术积累，技术储备，人员配置\n现在 学习成本、和收益\n将来 看市场份额：市场是否普及，技术是为项目服务的，不能只顾着自己爽了，以后没人维护，或者维护成本很高\n\n\n横向对比：\n看技术本身：易用性、适用场景；能否解决什么痛点问题\n看社区生态：社区活跃度、生态完善程度\n看扩展性：有些框架、库不完善，可能在使用过程中，有些特殊需求需要定制，嗝屁了～\n\n\n\n举例说明如果一个新技术、能够解决目前的痛点，且学习成本不是很高、收益很大、是未来的一个发展趋势的情况下，会优先考虑\n反思分析问题的角度很重要\n哲学\n多维度拆解\n\n","slug":"2023-02-18技术选型","date":"2023-02-18T01:52:12.000Z","categories_index":"复盘","tags_index":"复盘","author_index":"举手摘月亮"},{"id":"bda443873131c24fe879383385449e93","title":"状态管理工具-mobx","content":"mobx 是什么\n它通过运用透明的函数式响应编程（Transparent Functional Reactive Programming，TFRP）使状态管理变得简单和可扩展\n任何可以从应用状态中派生出来的值都应该被自动派生出来\n\nmobx 有什么特点\n透明函数式响应编程\n简单无模版,很简单不用写模版代码（redux 也可以自动化生成 reducer、action）\n数据追踪：轻松实现最优渲染，对数据的变更和使用都会在运行时被追踪到\n架构自由：没有硬性的规定，低耦合、可移植性好，便于测试\n\n缺点\n过于自由，MobX 提供的约定及模版代码很少，如果团队不做一些约定，容易导致团队代码风格不统一。\n可拓展，可维护性，也许你会担心 Mobx 能不能适应后期项目发展壮大呢？确实 Mobx 更适合用在中小型项目中，但这并不表示其不能支撑大型项目，关键在于大型项目通常需要特别注意可拓展性，可维护性，相比而言，规范的 Redux 更有优势，而 Mobx 更自由，需要我们自己制定一些规则来确保项目后期拓展，维护难易程度；\n\nmobx 能解决什么问题redux 模版代码太多\nmobx 它为什么会出现redux 模版代码多，使用起来麻烦\n相比于 redux 有什么优势少写了模版代码\nmobx 浏览器开发工具MobX Developer Tools\n思考：1. redux 也可以不写模版代码： 直接用 state 自动生成 action 和 reducer（确实可行，公司内部已经在用）\n如果是这样的话，mobx 还有什么优势？\n观察性能？怎么看上去有点和 react 相背，有点倾向 vue 的感觉\n如果 mobx 真的好，为什么 react 和 flutter 都没有内置 mobx，反而两大框架都内置了 context, react 内置了 useReducer\n2. mobx 的一系列操作，很有局限性\nobservable-state.html#局限性\n使用-flow-代替-async–await- 像是在倒退\n但是不要担心， 它不会导致性能损失（我抱怀疑态度）\n有违 react 设计\n\nuseState,本身实现了更新，却要在另外系统中实现响应，react + mobx 岂不是存在两套响应在其中\n结合 useEffect 进行清理副作用，结合 react 可知道 useEffect 的返回函数，在每次 effect 执行前都会清理一次，（这不损失性能？）\n如果用 mobx 封装组件，要使用这个组件，就必须要用 mobx，这也不符合程序设计，可移植性差\n\n最后vue 作者尤雨溪如是说：\n\n\n\n\n\n\n\n\n\nMobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。\n可能更加倾向于什么都不用\nreact 只用 react 内置的状态管理\nflutter 只用官方推荐的 provider(记不太清了,getx 也挺不错的)\n\n","slug":"2023-02-18mobx","date":"2023-02-18T01:36:28.000Z","categories_index":"状态管理工具","tags_index":"状态管理工具","author_index":"举手摘月亮"},{"id":"c83d31c32f6ad912ea131cac215fb5d8","title":"RN 与原生的通信","content":"是什么RN 与原生进行数据交换\n为什么\n访问原生API: 有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；\n复用原生功能: 或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍；\n性能和线程: 又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。\nRN没有，原生有: 如果 React Native 还不支持某个你需要的原生特性，你应当可以自己实现该特性的封装\n\nhttps://reactnative.dev/docs/0.70/native-modules-android\nhttps://reactnative.dev/docs/0.70/native-modules-ios\n安卓原生模块（native module）RN 调用原生方法\n注册方法\n继承 RN 类： ReactContextBaseJavaModule\n实现方法： public String getName() &#123;\n暴露方法： public Map&lt;String, Object&gt; getConstants() &#123;\n导出方法：给 JavaScript 使用，Java 方法需要使用注解@ReactMethod\n\n\n注册模块：\nimplements ReactPackage\n重写createViewManagers, createNativeModules方法\n在MainApplication.java中 提供 getPackages返回\n\n\nRN 端使用 NativeModules 进行调用\n\nimport &#123; NativeModules &#125; from &#39;react-native&#39;;\n&#x2F;&#x2F; 下一句中的ToastExample即对应上文\n&#x2F;&#x2F; public String getName()中返回的字符串\nexport default NativeModules.ToastExample;\n\n回调参数原生模块还支持一种特殊的参数——回调函数。它提供了一个函数来把返回值传回给 JavaScript。\nimport com.facebook.react.bridge.Callback;\n\n@ReactMethod\n&#x2F;&#x2F; prettier-ignore\n  public void measureLayout( int tag, int ancestorTag, Callback errorCallback, Callback successCallback) &#123;\n    try &#123;\n      measureLayout(tag, ancestorTag, mMeasureBuffer);\n      float relativeX &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[0]);\n      float relativeY &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[1]);\n      float width &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[2]);\n      float height &#x3D; PixelUtil.toDIPFromPixel(mMeasureBuffer[3]);\n      &#x2F;&#x2F; successCallback\n      &#x2F;&#x2F; 多提句, 你看这个invoke像不像electron的invoke?\n      successCallback.invoke(relativeX, relativeY, width, height);\n    &#125; catch (IllegalViewOperationException e) &#123;\n      &#x2F;&#x2F; errorCallback\n      errorCallback.invoke(e.getMessage());\n    &#125;\n  &#125;\n\npromise\n原生模块还可以使用 promise 来简化代码，搭配 ES2016(ES7)标准的 async&#x2F;await 语法则效果更佳。\n如果桥接原生方法的最后一个参数是一个 Promise，则对应的 JS 方法就会返回一个 Promise 对象\n\nimport com.facebook.react.bridge.Promise;\n\n@ReactMethod\n  public void measureLayout( int tag, int ancestorTag, Promise promise) &#123; &#x2F;&#x2F; 这个promise类型\n    try &#123;\n      measureLayout(tag, ancestorTag, mMeasureBuffer);\n\n      WritableMap map &#x3D; Arguments.createMap();\n\n      map.putDouble(&quot;relativeX&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[0]));\n      map.putDouble(&quot;relativeY&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[1]));\n      map.putDouble(&quot;width&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[2]));\n      map.putDouble(&quot;height&quot;, PixelUtil.toDIPFromPixel(mMeasureBuffer[3]));\n\n      promise.resolve(map);\n    &#125; catch (IllegalViewOperationException e) &#123;\n      promise.reject(E_LAYOUT_ERROR, e);\n    &#125;\n  &#125;\n\n多线程如果一个过程要阻塞执行一段时间，这个工作应当分配到一个内部管理的工作线程，然后从那边可以调用任意的回调函数\nRN 监听原生事件发送事件到 JavaScript\n\n原生模块可以在没有被调用的情况下往 JavaScript 发送事件通知。\n最简单的办法就是通过RCTDeviceEventEmitter，这可以通过 ReactContext 来获得对应的引用\n\nimport &#123; NativeEventEmitter, NativeModules &#125; from &#39;react-native&#39;;\n&#x2F;&#x2F; ...\n  componentDidMount() &#123;\n    &#x2F;&#x2F; ...\n    const eventEmitter &#x3D; new NativeEventEmitter(NativeModules.ToastExample);\n    this.eventListener &#x3D; eventEmitter.addListener(&#39;EventReminder&#39;, (event) &#x3D;&gt; &#123;\n       console.log(event.eventProperty) &#x2F;&#x2F; &quot;someValue&quot;\n    &#125;);\n    &#x2F;&#x2F; ...\n  &#125;\n  componentWillUnmount() &#123;\n    this.eventListener.remove(); &#x2F;&#x2F; 组件卸载时记得移除监听事件\n  &#125;\n\n\nIOS 原生模块（native module）陌生感袭来，现在已经不晓得.m .h 文件搞啥的了\n\n为了实现 RCTBridgeModule 协议，\n你的类需要包含 RCT_EXPORT_MODULE()宏。\n这个宏也可以添加一个参数用来指定在 JavaScript 中访问这个模块的名字。\n如果你不指定，默认就会使用这个 Objective-C 类的名字。\n如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。\n\nimport &#123; NativeModules &#125; from &#39;react-native&#39;;\n\nconst CalendarManager &#x3D; NativeModules.CalendarManager;\n\nCalendarManager.addEvent(&#39;Birthday Party&#39;, &#39;4 Privet Drive, Surrey&#39;);\n\nTurbo Modulefibric 架构\nIOS RCT_REMAP_METHOD()宏\nReact Native 还定义了一个 RCT_REMAP_METHOD()宏，它可以指定 JavaScript 方法名。\n因为 JavaScript 端不能有同名不同参的方法存在，所以当原生端存在重载方法时，可以使用这个宏来避免在 JavaScript 端的名字冲突。\n\nHermes\nHermes 专为资源受限的设备而设计，并针对启动、应用程序大小和内存消耗进行了优化。\nHermes 和其他 JS 引擎之间的一个关键区别: 是它能够提前将 JavaScript 源代码编译为字节码。\n这个预编译的字节码捆绑在二进制文件中，使解释器不必在应用程序启动期间执行这一昂贵的步骤\n\n见\n","slug":"2023-02-17rn-native","date":"2023-02-17T11:12:39.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"44465ab41d804f6d7f2b3ae4f9d00825","title":"Mac 键盘错乱","content":"怎么发生的键盘脏了，将电脑置为输入密码界面，然后用酒精湿巾擦拭，擦完后“键盘乱了”，键盘输出结果乱七八糟\n&#x2F;&#x2F; 错乱后的结果\n&#x2F;&#x2F; qwfpgjluy;arstdhneizxcvbkm\n&#x2F;&#x2F; 正确的结果\n&#x2F;&#x2F; qwertyuiopasdfghjklzxcvbnm\n\n\n\n\n\n\n原因\n\n本质是键盘有多种布局见\n","slug":"2023-02-17keyboard","date":"2023-02-17T02:23:33.000Z","categories_index":"Mac","tags_index":"Mac","author_index":"举手摘月亮"},{"id":"88793370bf9630dab6991762b90e11a7","title":"浏览器与Node的事件循环(Event Loop)有何区别?","content":"microtask 任务队列的执行时机不同\n浏览器端，microtask 在事件循环的 macrotask 执行完之后执行\nNode 端，microtask 在事件循环的各个阶段之间执行\n\n\n\n参考链接浏览器与 Node 的事件循环(Event Loop)有何区别?\n","slug":"2023-02-16eventloop","date":"2023-02-16T14:07:52.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"3daa6efee784365da039127060479457","title":"Web存储","content":"\n\nWeb 存储\nSessionStorage 特定于选项卡，其作用范围涵盖选项卡的整个生存期。它对于存储 IndexedDB 键等少量会话特定信息可能很有用。\n此机制是同步的，会阻塞主线程，因此应谨慎使用。\n其大小限制约为 5MB，并且只能包含字符串。\n由于它特定于选项卡，因此无法从 web worker 或 service worker 进行访问。\n\n\nLocalStorage\n是同步的，会阻塞主线程，因此应避免使用。\n其大小限制约为 5MB，并且只能包含字符串。\n无法从 web worker 或 service worker 访问 LocalStorage。\n\n\nCookie(重点聊)\n有其用途，但不应该用于存储。\nCookie 随每个 HTTP 请求一起发送，因此只能存储少量数据，数据一多就会显著增加每个 Web 请求的大小。\nCookie 是同步的，不能从 Web worker 进行访问。\n与 LocalStorage 和 SessionStorage 一样，cookie 仅限于字符串。\n\n\n\n\n\n\n名称\n大小\n使用场景\n设置\n同步\nworker 进程\n是否跨域\n生命周期\n层级\n\n\n\nSessionStorage\n5MB\n选项卡\n前端\n是\n不可访问\n否\n选项卡生存期间\nweb 级\n\n\nLocalStorage\n5MB\n前端\n前端\n是\n不可访问\n否\n不清理，就存在\nweb 级\n\n\nCookie\n4KB\n个性化、跟踪、 前后端\n前端、服务端\n是\n不可访问\n允许跨域(配置 Domain 的情况)\n可会话、可持久\nHTTP 级\n\n\nIndexDB\n很大\n前端\n前端\n异步\n可访问\n不允许跨域\n可持久\nweb 级\n\n\n见：2023-02-11 站点存储\n如何检查有多少可用存储？\n在许多浏览器中，您可以使用 StorageManager API 来确定来源的可用存储量及其目前使用的存储量。\n它会报告 IndexedDB 和缓存 API 使用的总字节数，还可以计算近似的可用剩余存储空间。\n\nif (navigator.storage &amp;&amp; navigator.storage.estimate) &#123;\n  &#x2F;&#x2F; https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;?aldtype&#x3D;16047#en&#x2F;zh&#x2F;quota\n  const quota &#x3D; await navigator.storage.estimate(); &#x2F;&#x2F; quota：配额\n  &#x2F;&#x2F; quota.usage -&gt; 已用字节数。\n  &#x2F;&#x2F; quota.quota -&gt; 最大可用字节数。\n  const percentageUsed &#x3D; (quota.usage &#x2F; quota.quota) * 100;\n  console.log(&#96;您已使用可用存储的 $&#123;percentageUsed&#125;%。&#96;);\n  const remaining &#x3D; quota.quota - quota.usage;\n  console.log(&#96;您最多可以再写入 $&#123;remaining&#125; 个字节。&#96;);\n&#125;\n\ncookieHTTP Cookie\ncookie 主要用\n会话状态管理 (如用户登录状态、购物车、游戏分数或其它需要记录的信息)\n个性化设置（如用户自定义设置、主题和其他设置） 监听变化 cookieStore.addEventListener(&quot;change&quot;, (event) =&gt; &#123;\n行为跟踪（如跟踪分析用户行为等）\n\n创建 Cookie\n服务器收到 HTTP 请求后，服务器可以在响应标头里面添加一个或多个 Set-Cookie 选项。\n浏览器收到响应后通常会保存下 Cookie，并将其放在 HTTP Cookie 标头内，向同一服务器发出请求时一起发送\n\n定义 Cookie 的生命周期Cookie 的生命周期可以通过两种方式定义：\n\n会话期 Cookie 会在当前的会话结束之后删除。浏览器定义了“当前会话”结束的时间，一些浏览器重启时会使用会话恢复。这可能导致会话 cookie 无限延长。\n持久性 Cookie 在过期时间（Expires）指定的日期或有效期（Max-Age）指定的一段时间后被删除。\n\ncookie 安全攻击类型\nXSS攻击\n固定会话攻击 措施： 每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie\n会话劫持\n中间人攻击\n\n安全措施有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：Secure 属性和 HttpOnly 属性\n\n限制 cookie 访问 Secure 属性：\n\n使用上有限制： 本地主机 和 https 可用\nSecure 不会阻止对 cookie 中敏感信息的访问。\n例如，有权访问客户端硬盘（或，如果未设置 HttpOnly 属性，则为 JavaScript）的人可以读取和修改它\n\n\n限制 cookie 访问, HttpOnly 属性\n\n此类 Cookie 仅作用于服务器, JavaScript Document.cookie API 无法访问带有 HttpOnly 属性的 cookie。\n此预防措施有助于缓解跨站点脚本（XSS） (en-US)攻击。\n\nSet-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\n\n双 cookie 验证 如：django 表单\n\ntoken\n\n\n定义 Cookie 发送的位置Domain 和 Path 标识定义了 Cookie 的作用域：即允许 Cookie 应该发送给哪些 URL\nDomian\nDomain 指定了哪些主机可以接受 Cookie。\n如果不指定，该属性默认为同一 host 设置 cookie，不包含子域名。\n如果指定了 Domain，则一般包含子域名。\n\nPath\nPath 属性指定了一个 URL 路径，该 URL 路径必须存在于请求的 URL 中，以便发送 Cookie 标头。\n以字符 %x2F (“&#x2F;”) 作为路径分隔符，并且子路径也会被匹配\n\nSameSite\nSameSite 属性允许服务器指定是否/何时通过跨站点请求发送（其中站点由注册的域和方案定义：http 或 https）。\n这提供了一些针对跨站点请求伪造攻击（CSRF）的保护。它采用三个可能的值：\nStrict\nLax 宽松\nNone\n\n\n\n三个值\n\nStrict，cookie 仅发送到它来源的站点。\nLax 与 Strict 相似，只是在用户导航到 cookie 的源站点时发送 cookie。例如，通过跟踪来自外部站点的链接。\nNone 指定浏览器会在同站请求和跨站请求下继续发送 cookie，要求在安全的上下文中（即：如果 SameSite=None，且还必须设置 Secure 属性, 如果没有设置 SameSite 属性，则将 cookie 视为 Lax）\n协议不同：cookie 使用不同的方案（http: 或 https:）发送来自同一域的 cookie，则不再视为来自同一站点\n\n与 SameSite 相关的站点知识站点（Site）\n同一个站点结论：与协议有关、前部分+可注册域有关、端口无关\n\n站点由域名的可注册域部分确定。可注册域由公共后缀列表中的一个条目加上它之前的域名部分组成\n在区分不同的站点时，也会考虑站点的协议（scheme）。这将使 http://vpl.ca 和 https://vpl.ca 成为不同的站点\n\n例子\n同一个站点，因为 mozilla.org 的可注册域是相同的：\n\nhttps://developer.mozilla.org/zh-CN/docs/\nhttps://support.mozilla.org/zh-CN/\n\n\n这些是同一个站点，因为端口不相关：\n\nhttps://example.com:8080\nhttps://example.com\n\n\n这些不是同一个站点，因为两个 URL 的可注册域不同：\n\nhttps://developer.mozilla.org/zh-CN/docs/\nhttps://example.com\n\n\n如果考虑协议（scheme），这些可能是相同的站点或不同的站点：\n\nhttp://example.com\nhttps://example.com\n\n\n\n深度防御\n__Host-如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记、从安全来源发送、不包括 Domain 属性，并将 Path 属性设置为 / 时，它才在 Set-Cookie 标头中接受。这样，这些 cookie 可以被视为“domain-locked”。\n__Secure-如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记，是从安全来源发送的，它才在 Set-Cookie 标头中接受。该前缀限制要弱于 __Host- 前缀\n\n满足一定条件，才在 Set-Cookie 标头中接受，可以理解为是种规则约束\n\n\n\ncookie 名称\nSecure 属性标记\n从安全来源发送\nDomain 属性\nPath 属性\n\n\n\n__Host-&#123;name&#125;\n需要\n需要\n不包括\n设置为 &#x2F;\n\n\n__Secure-&#123;name&#125;\n需要\n需要\n可有可无\n可有可无\n\n\nHttpOnly 标记\n如果未设置 HttpOnly 标记，你也可以从 JavaScript 访问现有的 Cookie。\n通过 JavaScript 创建的 Cookie 不能包含 HttpOnly 标志。\nJavaScript 可以通过跨站脚本攻击（XSS）的方式来窃取 Cookie。\n当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息。\n\nCookie 相关规定涉及使用 Cookie 的法律或法规包括：\n\n欧盟通用数据隐私法规（GDPR）\n欧盟的电子隐私权指令\n加州消费者隐私法\n这些规定具有全球影响力。它们适用于这些司法管辖区的用户访问的万维网上的任何站点（欧盟和加利福尼亚，但请注意，加利福尼亚州的法律仅适用于总收入超过 2500 万美元的实体）。\n\n这些法规包括以下要求：\n\n向用户表明你的站点使用 cookie。\n允许用户选择不接收某些或所有 cookie。\n允许用户在不接收 Cookie 的情况下使用大部分服务。\n\n结合起来看从性能 、2023-02-15web_workers、和 2023-02-11 站点存储 来看\n对于 longTask 耗性能的计算要放在 web workers 中进行处理，数据可能需要放到 indexDB 进行缓存\n参考链接HTTP Cookies\nWeb 存储\n监听 cookie\n","slug":"2023-02-15web_storage","date":"2023-02-15T07:12:05.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"606d0004659da737e4ce8d55e7a861d1","title":"性能优化-Web Workers","content":"Web workers 是什么？\n为 Web 内容在后台线程中运行脚本提供了一种简单的方法\n线程可以执行任务而不干扰用户界面\n\n运行原理一个 worker 是使用一个构造函数创建的一个对象 (e.g. Worker()) 运行一个命名的 JavaScript 文件\n\n这个文件包含将在工作线程中运行的代码;\nworkers 运行在独立上下文. 在 Worker 内通过 window 获取全局作用域 (而不是 self) 将返回错误\n\n专用 worker vs 共享 worker作用域不同、脚本被使用不同\n\n专用 workers，DedicatedWorkerGlobalScope 对象代表了 worker 的上下文（专用 workers 是指标准 worker 仅在单一脚本中被使用；\n共享 worker 的上下文是 SharedWorkerGlobalScope 对象）。\n一个专用 worker 仅仅能被首次生成它的脚本使用，而共享 worker 可以同时被多个脚本使用\n\nWorker 上下文和函数Worker 在另一个全局上下文中运行，与当前的 window 不同！Window 并不直接在 worker 中可用，其中的很多方法都通过共享的混入（WindowOrWorkerGlobalScope）定义，并通过 worker 派生的 WorkerGlobalScope 上下文提供这些方法：\n\nDedicatedWorkerGlobalScope——专用 worker\nSharedWorkerGlobalScope ——共享 worker\nServiceWorkerGlobalScope——service worker\n\n一些函数在所有的 worker 和主线程中均可用（来自 WindowOrWorkerGlobalScope）：\n\nsetInterval()、setTimeout()。\nclearInterval()、clearTimeout()、\natob()、btoa()、\ndump() 非标准、\n\n以下函数仅在 worker 中可用：\n\nWorkerGlobalScope.importScripts()（所有的 worker）\nDedicatedWorkerGlobalScope.postMessage （仅专用 worker）\n\n以下 Web API 在 worker 中可用：\nBroadcast Channel API、Channel Messaging API、\nCache API、IndexedDB、\nConsole API、Crypto、CustomEvent、\nDOMRequest 和 DOMCursor、\nFetch、FileReader、FileReaderSync（仅在 worker 中可用）、\nFormData、ImageData、\nNetwork Information API、Notifications、Performance、PerformanceEntry、PerformanceMeasure、PerformanceMark、PerformanceObserver、PerformanceResourceTiming、\nPromise、Server-sent 事件、ServiceWorkerRegistration、\nTextEncoder 和 TextDecoder、URL、WebGL 中的 OffscreenCanvas（通过特性首选项 gfx.offscreencanvas.enabled 启用）、WebSocket、XMLHttpRequest（尽管 responseXML 和 channel 属性始终为 null）。\nworker 也可以创建其它的 worker，所以以下的 API 也同样可用：\nWorker、WorkerGlobalScope、WorkerLocation、WorkerNavigator。\n\nreact web workerhttps://github.com/BlueBlazin/web-worker-hooks\n\n性能监控create-react-app measuring-performance\ndemo\n","slug":"2023-02-15web_workers","date":"2023-02-15T01:44:35.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"举手摘月亮"},{"id":"fd6ac5dbf2fdaf53f897b01a2ee4dbfc","title":"性能指标 - CLS","content":"Cumulative Layout Shift (CLS)累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1. 或更少。\n什么是 CLSCLS，即 Cumulative Layout Shift 累积布局偏移\n\nCLS 测量整个页面生命周期内发生的, 所有意外布局偏移中最大一连串的布局偏移分数。\n每当一个可见元素的位置从一个已渲染帧变更到下一个已渲染帧时，就发生了布局偏移 。（有关单次布局偏移分数计算方式的详细信息，请参阅下文。）\n一连串的布局偏移，也叫会话窗口，是指一个或多个快速连续发生的单次布局偏移，每次偏移相隔的时间少于 1 秒，且整个窗口的最大持续时长为 5 秒。\n\n最常见的影响 CLS 的分数的有：\n未指定尺寸的图片\n未指定尺寸的广告、嵌入元素、iframe\n动态插入内容\n自定义字体（引发 FOIT&#x2F;FOUT）\n在更新 DOM 之前等待网络响应的操作\n\nCLS 问题有哪些影响\n在网上阅读一篇文章时，结果页面上的某些内容突然发生改变。\n文本在毫无预警的情况下移位，导致您找不到先前阅读的位置。\n或者更糟糕：正要点击一个链接或一个按钮，但在鼠标点击的瞬间，链接移位了，结果点到了别的东西！\n各搜索引擎对此类问题是比较反感的，具体表现的负面作用，就是严重影响网页权重和搜索引擎收录。\n\n如何优化 CLS可以通过遵循一些指导原则来避免所有的意外布局偏移：\n1、始终在您的图像和视频元素上包含尺寸属性，或者通过使用 CSS 长宽比容器之类的方式预留所需的空间。2、可以使用 unsized-media 功能策略, 在支持功能策略的浏览器中强制执行此行为。3、除非是对用户交互做出响应，否则切勿在现有内容的上方插入内容。这样能够确保发生的任何布局偏移都在预期之内。4、首选转换动画，而不是触发布局偏移的属性动画。动画过渡的目标是提供状态与状态之间的上下文连续性。\nother搜索引擎收录优化\n","slug":"2023-02-14web_cls","date":"2023-02-14T14:32:14.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"举手摘月亮"},{"id":"7f4dccbee0ac34fdbc8e55c8be3f50e9","title":"性能指标 - FID","content":"First Input Delay (FID)首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为 100 毫秒或更短\n\n\n如何改进 FID要了解如何改进某个特定网站的 FID，您可以运行一次灯塔性能审计，并留心查看审计建议的各种具体机会。\n虽然 FID 是一项实际指标（而灯塔是一个实验室指标工具），但改进 FID 的指导方向与改进总阻塞时间 (TBT)这项实验室指标的指导方向相同。\n如需深入了解如何改进 FID，请参阅优化 FID。有关其他能够改进 FID 的单个性能技巧的进一步指导，请参阅：\n\n减少第三方代码的影响\n减少 JavaScript 执行时间\n最小化主线程工作\n保持较低的请求数和较小的传输大小\n\n繁重的 JavaScript 执行浏览器在主线程上执行 JavaScript 时无法对大多数用户输入作出响应。换句话说，当主线程繁忙时，浏览器无法响应用户交互。要想改善这一点：\n\n分割长任务, 将长时间运行的代码拆解为更小的异步任务\n优化您的页面，做好交互准备\n使用 Web Worker\n减少 JavaScript 执行时间\n\n分割长任务\n任何阻塞主线程 50 毫秒或以上的代码都可以被称为长任务。\n长任务是 JavaScript 的执行期，这期间，用户可能会发现您的用户界面没有响应。\n将长任务拆分可以减少您网站上的输入延迟。\n\n优化您的页面，做好交互准备对于高度依赖 JavaScript 的网络应用程序来说，导致 FID 和 TBT 分数较差的常见原因有很多：\n第一方脚本执行会延迟交互准备JavaScript 体积膨胀、执行时间过长和分块效率低下会延迟页面对用户输入作出响应的时机，并影响 FID、TBT 和 TTI。渐进式加载代码和功能可以有助于分散工作量，改善交互准备。服务端渲染的应用程序在屏幕上绘制像素的速度可能看起来很快，但需要注意用户交互被大型脚本执行（例如通过数据重构来连接事件侦听器）阻塞的情况。如果使用了基于路由的代码分割，这可能会花费数百毫秒，有时甚至是数秒。请考虑将更多逻辑转移到服务器端，或在构建期间静态生成更多内容。以下是优化某应用程序的第一方脚本加载之前和之后的 TBT 分数。通过移除关键路径上消耗大量资源为非必要组件加载（和执行）的脚本，用户便能够更快地与页面进行交互。\n数据获取会影响交互准备的许多方面等待一连串的级联获取（例如组件的 JavaScript 和数据获取）会影响交互延迟。请尽量最大限度地减少对级联数据获取的依赖。大型内联数据存储会延长 HTML 解析时间并影响绘制和交互指标。请尽量最大限度地减少需要在客户端进行后处理的数据量。\n第三方脚本执行也会加剧交互延迟许多网站包括的第三方标签和分析会使网络一直处于忙碌状态，并使主线程周期性地无响应，从而影响交互延迟。请探究按需加载第三方代码的相关做法（例如，不要加载还未滚动到可视区域附近的非首屏广告）。在某些情况下，第三方脚本会在主线程的优先级和带宽方面抢占第一方脚本，并延迟页面做好交互准备的时机。请尝试优先加载您认为可以为用户提供最大价值的内容。\n使用 Web Worker被阻塞的主线程是输入延迟的主要原因之一。Web Worker 能够让 JavaScript 在后台线程上运行。将非用户界面操作移动到单独的工作线程上可以缩减主线程阻塞时间，从而改善 FID。\n请考虑使用以下库来使您更轻松地在网站上使用 Web Worker：\n\nComlink：一个助手类库，该库抽象了 postMessage，使其更易于使用\nWorkway : 一个通用的 Web Worker 导出器\nWorkerize：将模块移动到 Web Worker 中\n\n减少 JavaScript 执行时间限制页面上 JavaScript 的数量可以减少浏览器执行 JavaScript 代码所需的时间。这样能够使浏览器更迅速地开始对任何用户交互作出响应。\n要想减少在页面上执行的 JavaScript 数量：\n延迟加载未使用的 JavaScript\n最大限度减少未使用的 polyfill\n\n延迟加载未使用的 JavaScript默认情况下，所有 JavaScript 都是阻塞渲染的。当浏览器遇到链接到外部 JavaScript 文件的脚本标签时，就必须暂停正在执行的操作，转而下载、解析、编译和执行该 JavaScript。因此，您应该只加载页面所需的代码或响应用户输入所需的代码。\nChrome 开发者工具中的代码覆盖率选项卡能够告诉您网页上有多少未在使用的 JavaScript。\n参考链接optimize-fid\n","slug":"2023-02-14web_fid","date":"2023-02-14T14:04:49.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"举手摘月亮"},{"id":"c0c40ac20df205f0ad9a5f01d2cefd4b","title":"性能指标 - LCP","content":"Largest Contentful Paint (LCP)最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的 2.5 秒内发生\n\n\n导致 LCP 不佳的最常见原因是：\n缓慢的服务器响应速度\n阻塞渲染的 JavaScript 和 CSS\n缓慢的资源加载速度\n客户端渲染\n\n缓慢的服务器响应速度您可以通过多种不同的方式来改进您的 TTFB：\n\n优化您的服务器\nCDN\n缓存资产\n配置反向代理（Varnish、nginx）来提供缓存内容，或者当安装在应用程序服务器之前充当缓存服务器\n配置和管理您的云服务提供商（Firebase、AWS、Azure）的缓存行为\n使用提供边缘服务器的 CDN，以便将您的内容进行缓存并存储在离您的用户更近的地方\n\n\n优先使用缓存提供 HTML 页面\n安装好的 Service Worker 会在浏览器后台运行，并可以拦截来自服务器的请求。此级别的程序化缓存控制使得缓存部分或全部 HTML 页面内容得以实现，并且只会在内容发生更改时更新缓存。\n\n\n尽早建立第三方连接\nrel=&quot;preconnect&quot;来告知浏览器您的页面打算尽快建立连接\ndns-prefetch 来更快地完成 DNS 查找\n\n\n\n阻塞渲染的 JavaScript 和 CSS 原因分析\n浏览器在能够渲染任何内容之前，需要将 HTML 标记解析为 DOM 树。\n如果 HTML 解析器遇到任何外部样式表（&lt;link rel=&quot;stylesheet&quot;&gt;）或同步 JavaScript 标签（&lt;script src=&quot;main.js&quot;&gt;），则会暂停解析\n这些资源会使 FCP 延迟，进而导致 LCP 延迟。\n延迟加载任何非关键的 JavaScript 和 CSS，从而提高网页主要内容的加载速度。\n\n减少 CSS 阻塞时间通过以下操作确保您的网站上只有最少量的必要 CSS 会阻塞渲染：\n\n关键的 CSS 要削减\n\n对于 webpack：optimize-css-assets-webpack-plugin ,\n对于 Gulp：gulp-clean-css\n对于 Rollup：rollup-plugin-css-porter\n\n\n非关键 CSS 要延迟加载\n\n使用 Chrome 开发者工具中的代码覆盖率选项卡查找您网页上任何未使用的 CSS。\n如果是在您网站的单独页面上使用，可以将所有未使用的 CSS 完全删除或移动到另一个样式表。\n对于任何初始渲染时不需要的 CSS，请使用 loadCSS 来异步加载文件，这里运用了rel=&quot;preload&quot;和onload\n\n&lt;link\n  rel&#x3D;&quot;preload&quot;\n  href&#x3D;&quot;stylesheet.css&quot;\n  as&#x3D;&quot;style&quot;\n  onload&#x3D;&quot;this.rel&#x3D;&#39;stylesheet&#39;&quot;\n&#x2F;&gt;\n\n关键的 CSS 进行内联\n\n将重要样式进行内联后，就不再需要通过往返请求来获取关键 CSS。\n延迟加载其余部分可以最大限度地减少 CSS 阻塞时间\nCritters 是一个 webpack 插件，能够内联关键 CSS 并对其余部分进行懒加载\n\n\n\n减少 JavaScript 阻塞时间下载并向用户提供尽可能少的必要 JavaScript。减少阻塞渲染的 JavaScript 数量能够让渲染速度更快，从而获得更好的 LCP。\n这可以通过优化您的脚本来实现，有如下几种不同的方式：\n\n削减和压缩 JavaScript 文件\n延迟加载未使用的 JavaScript\n最大限度减少未使用的 polyfill\n\n其他资源的影响影响 LCP 的元素类型为：\n&lt;img&gt;元素\n内嵌在&lt;svg&gt;元素内的&lt;image&gt;元素\n&lt;video&gt;元素（使用封面图像测量 LCP）\n通过 url()函数加载的带有背景图像的元素\n包含文本节点或其他行内级文本元素的块级元素\n\n优化措施\n优化和压缩图像\n压缩文本文件\n预加载重要资源\n基于网络连接交付不同资产（自适应服务）\n使用Service Worker缓存资产\n\n优化压缩图像\n\n首先考虑不使用图像。如果图像与内容无关，请将其删除。\n压缩图像（例如使用 Imagemin）\n文件格式（JPEG 2000、JPEG XR 或 WebP）\n使用响应式图像\n考虑使用图像 CDN\n\n使用 Service Worker 缓存资产\nService Worker 可用于完成许多有用的任务，其中包括本文前面提到的提供较小的 HTML 响应。\nService Worker 还可用于缓存任何静态资源，并在收到重复请求时将资源直接提供给浏览器，而无需通过网络。\n使用 Service Worker 预缓存关键资源可以显著减少资源加载时间，特别是对于使用较弱连接重新加载网页（甚至离线访问）的用户。\n与自己编写自定义 Service Worker 来更新预缓存资产相比，诸如 Workbox 这样的库可以使整个过程更加容易。\n\n自适应服务(资源变体)当加载构成页面主要内容的资源时，根据用户的设备或网络条件按需获取不同的资源会是一个有效做法。您可以使用网络状况 API、设备内存 API 和硬件并发 API 来实现这一做法。\n如果您有对初始渲染十分关键的大型资产，那么您可以根据用户的连接或设备采用同一资源的不同变体。例如，对于任何低于 4G 的连接速度，您可以显示图像，而不是视频：\nif (navigator.connection &amp;&amp; navigator.connection.effectiveType) &#123;\n  if (navigator.connection.effectiveType &#x3D;&#x3D;&#x3D; &quot;4g&quot;) &#123;\n    &#x2F;&#x2F; 加载视频\n  &#125; else &#123;\n    &#x2F;&#x2F; 加载图像\n  &#125;\n&#125;\n\n您可以使用的一系列实用属性：\n&#x2F;&#x2F; navigator.connection.effectiveType：有效连接类型\n&#x2F;&#x2F; navigator.connection.saveData：启用&#x2F;禁用数据保护程序\n&#x2F;&#x2F; navigator.hardwareConcurrency：CPU 核心数\n&#x2F;&#x2F; navigator.deviceMemory：设备内存\n\n客户端渲染许多网站使用客户端 JavaScript 逻辑直接在浏览器中渲染页面。诸如 React、Angular 和 Vue 这类的框架和库使构建单页应用变得更加容易，这些单页应用完全在客户端（而不是在服务器）中处理网页的各个层面。\n如果您正在搭建一个主要在客户端进行渲染的网站，那么您应该特别小心网站在使用大型 JavaScript 包时可能对 LCP 产生的影响。如果您没有通过优化来加以阻止，那么在所有关键 JavaScript 完成下载和执行前，用户可能都无法看到页面上的任何内容或与之交互。\n在搭建客户端渲染的网站时，请考虑以下优化：\n\n最小化关键 JavaScript\n使用服务端渲染\n使用预渲染\n\n最小化关键 JavaScript\n削减 JavaScript\n延迟加载未使用的 JavaScript\n最大限度减少未使用的 polyfill\n请回到减少 JavaScript 阻塞时间部分，阅读有关这些优化的更多信息。\n\n使用服务端渲染\n对于主要由客户端渲染的网站来说，首先需要关注的始终应该是将 JavaScript 的数量最小化。但是，您还应该考虑结合服务端渲染体验来尽可能地改善 LCP。\n\n这个概念的实现方式是使用服务器将应用渲染为 HTML，然后客户端将所有 JavaScript 及所需数据”水合”到相同的 DOM 内容中。这个做法可以通过确保页面的主要内容首先在服务器上进行渲染（而不是仅在客户端上进行渲染）来改进 LCP，但该做法有一些弊端：\n\n在服务器和客户端上维护相同的由 JavaScript 渲染的应用会增加复杂性。\n\n与只使用服务器提供静态页面相比，在服务器上执行 JavaScript 来渲染 HTML 文件总是会增加服务器响应时间 (首字节时间 TTFB)。\n\n服务端渲染的页面可能看似具备交互性，但在所有客户端 JavaScript 执行完毕之前，页面其实无法对任何用户输入作出响应。简而言之，该做法会使 Time to Interactive 可交互时间 (TTI) 变得更糟。\n\n\n使用预渲染预渲染是一种独立的技巧，该技巧比服务端渲染简单，并且还提供了一种改进应用程序 LCP 的方法。无头浏览器是一种没有用户界面的浏览器，我们会用无头浏览器在搭建期间生成每个路由的静态 HTML 文件。然后可以将这些文件与应用程序所需的 JavaScript 包一起进行运送。\n在使用预渲染后，TTI 仍然会受到负面影响，但服务器响应时间不会像服务端渲染解决方案（仅在接到请求后才对各个页面进行动态渲染）中那样受到很大影响。\n","slug":"2023-02-14web_lcp","date":"2023-02-14T13:19:15.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"举手摘月亮"},{"id":"e2a10815e593824fa56e5bdca444887f","title":"Web performance","content":"Web_PerformanceWeb 性能\nAnimation performance and frame rateAnimation performance and frame rate\n对于动画媒体\n\n文件动画： 例如视频和动画 gif，主要的性能问题是文件大小——下载文件的速度足够快而不会对性能产生负面影响是最大的问题。\n代码动画：基于代码的动画，无论是 CSS、SVG、&lt;canvas&gt;、webGL 还是其他 JavaScript 动画，即使带宽占用很小，也会导致性能问题。这些动画会消耗 CPU 和&#x2F;或导致卡顿。\n操作不当导致更卡：动画可以让网站感觉更快、响应更快，但如果操作不当，动画也会让网站感觉更慢、更卡顿\nCSS动画优于JS动画：与使用 JavaScript 的动画元素相比，CSS 动画可以更容易地创建。它们还可以提供更好的性能，因为它们让浏览器更好地控制何时渲染帧，并在必要时丢弃帧。\n\nCSS 属性成本\n\n\n\n财产种类\n成本\n例子\n\n\n\n影响元素几何或位置的属性会触发样式重新计算、布局和重绘。\n重新计算、布局、绘制\nleft 、max-width、border-width、margin-left、font-size\n\n\n不影响几何或位置但不在其自己的层中呈现的属性不会触发布局。\n重新计算、–、绘制\ncolor\n\n\n在它们自己的层中呈现的属性甚至不会触发重绘，因为更新是在组合中处理的。\n重新计算、–、–\ntransform opacity\n\n\nCSS 动画与 JavaScript 动画的性能CSS 动画与 JavaScript 动画的性能\n多方式生成 web 动画\n\nCSS transition 和 animation\n基于 JavaScript 的动画（使用 requestAnimationFrame()）\n\n关键渲染路径Critical rendering path\n关键渲染路径\n\n关键渲染路径是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。优化关键渲染路径可提高渲染性能。\n关键渲染路径包含了 文档对象模型(DOM)，CSS 对象模型 (CSSOM)，渲染树和布局\n\n提升页面加载速度需要通过\n\n被加载资源的优先级、控制它们加载的顺序和减小这些资源的体积。性能提示包含\n异步和延迟：通过异步、延迟加载\n数量：消除非关键资源来减少关键资源的请求数量，\n体积：优化必须的请求数量和每个请求的文件体积，\n资源加载顺序：通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度。\n\n\n\n延迟加载 (懒加载)Lazy loading\n延迟加载 (懒加载)\nLazy loading 是什么延迟加载 (懒加载) 是一种将资源标识为非阻塞（非关键）资源并仅在需要时加载它们的策略。这是一种缩短关键渲染路径长度的方法，可以缩短页面加载时间\nLazy loading 策略代码拆分 可以将 JavaScript、CSS 和 HTML 分割成小块，以发送最少的代码提供关键信息，以优化页面加载时间。其余的部分可以在需要时加载\n\nJS: 脚本类型模块 任何类型为 type&#x3D;”module” 的脚本标签都被视为一个 JavaScript 模块，并且默认情况下会被延迟\nCSS: 默认情况下，CSS 被视为渲染阻塞资源，因此，在 CSSOM 被构造完成之前，浏览器不会渲染任何已处理的内容。CSS 必须很薄，才能尽快交付，建议使用媒体类型和查询实现非阻塞渲染\nFonts: 默认情况下，字体请求会延迟到构造渲染树之前，这可能会导致文本渲染延迟\nImages and iframes:\n增加 loading=&quot;lazy&quot;。 可用于指示浏览器延迟加载屏幕外的图像&#x2F;iframe，直到用户滚动到它们附近\n&lt;picture&gt; &lt;source\n图像的 srcset\n\n\nPolyfill 包含此 Polyfill 以支持较旧且当前不兼容的浏览器：\n加载属性 Polyfill\n增加 async 异步加载 见\n\n\n交叉观察者 API Intersection Observers 允许用户知道观察到的元素何时进入或退出浏览器的视口\n事件处理程序 当浏览器的兼容性至关重要时，有以下几种选择：\n支持: IntersectionObserver就用，\n不支持: 回退到低版本：以滚动，调整大小或改变方向的事件处理程序，来确定特定元素是否在视口中\n\n\n\nNavigation and resource timingsNavigation and resource timings\n2022-05-12performance\n非常重要‼️ performanceTiming API 被弃用，但被所有浏览器支持，performanceNavigationTiming 是新的 API\nperformanceTiming\n\n计算时间我们可以使用这些值来衡量感兴趣的特定时间：\n&#x2F;&#x2F; 第一个字节的时间\nconst ttfb &#x3D; time.responseStart - time.navigationStart;\n&#x2F;&#x2F; 页面加载时间\nlet pageloadtime &#x3D; time.loadEventStart - time.navigationStart;\n&#x2F;&#x2F; DNS 查找时间\nconst dns &#x3D; time.domainLookupEnd - time.domainLookupStart;\n&#x2F;&#x2F; TCP握手所花费的时间是连接开始和连接结束之间的时间：\nconst tcp &#x3D; time.connectEnd - time.connectStart;\n&#x2F;&#x2F; SSL协商\n&#x2F;&#x2F; 如果使用安全连接，secureConnectionStart则为truthysecureConnectionStart ，并且和时间requestStart差值大于 0。\nconst ssl &#x3D; time.requestStart - time.secureConnectionStart;\n\n性能输入 API上面的一般性能计时已弃用，但完全受支持。我们现在有了 Performance Entry API，它提供了在导航和资源加载过程中标记和测量时间的功能。您还可以创建标记\nperformance.getEntriesByType(&quot;navigation&quot;).forEach((navigation) &#x3D;&gt; &#123;\n  console.dir(navigation);\n&#125;);\n\nperformance.getEntriesByType(&quot;resource&quot;).forEach((resource) &#x3D;&gt; &#123;\n  console.dir(resource);\n&#125;);\n\nperformance.getEntriesByType(&quot;mark&quot;).forEach((mark) &#x3D;&gt; &#123;\n  console.dir(mark);\n&#125;);\n\nperformance.getEntriesByType(&quot;measure&quot;).forEach((measure) &#x3D;&gt; &#123;\n  console.dir(measure);\n&#125;);\n\nperformance.getEntriesByType(&quot;paint&quot;).forEach((paint) &#x3D;&gt; &#123;\n  console.dir(paint);\n&#125;);\n\nperformance.getEntriesByType(&quot;frame&quot;).forEach((frame) &#x3D;&gt; &#123;\n  console.dir(frame);\n&#125;);\n\nperformanceNavigationTiming\n\n使用const observer &#x3D; new PerformanceObserver((list) &#x3D;&gt; &#123;\n  list.getEntries().forEach((entry) &#x3D;&gt; &#123;\n    console.log(entry.toJSON());\n  &#125;);\n&#125;);\n\nobserver.observe(&#123; entryTypes: [&quot;navigation&quot;] &#125;);\n\nPerformanceNavigationTiming.toJSON()\n优化启动性能Optimizing startup performance\n\n\n优化启动性能\n异步化\n脚本异步化：在需要异步执行的脚本标签上使用 defer 或 async 属性\n多线程解码：如果你需要解码资源文件（比如，解码 JPEG 文件并将其转换为原始纹理数据，以便随后在 WebGL 中使用），最好在 workers 里做这件事\n并行数据处理：所有能并行的数据处理都应该并行化\n非关键不加载： 在你启动的 HTML 文件中，不要包含不会在关键路径下出现的脚本或样式表。只在需要时加载他们\n非关键不渲染：不要强迫 Web 引擎构建不需要的 DOM，一种简单的“hack”的方式是把你的 HTML 留在文档里，但是在外层包裹注释\n按需渲染：当文档的一部分需要被渲染时，加载被注释的 HTML\n优化程度：优化到 10s 以内\n\n数据大小\n小的启动快：尽力优化游戏数据的体积，\n小的处理快：小一些的文件下载和处理都比大文件快。\n\n下载时间\n硬件：应该考虑买个速度越快越好托管服务器。\n压缩：还应该考虑压缩数据，尽可能缩小其体积。\n拆解：合理拆分文件大小\n缓存：数据缓存\n\nGPU 因素, 如游戏帧率展示编译着色器，以及将纹理传输到 GPU 会占用时间，特别是在比较复杂的游戏中。尽管这也会发生在本地 (非 Web ) 游戏中，但还是会很恼人。不要不告诉用户游戏实际上还在启动中就这么做。\n\n编译着色器，以及将纹理传输到 GPU 会占用时间\n暗示用户，间接告诉他，换高端设备\n\n主观因素 - 转移用户注意力\n你可以在启动过程中做一些事情来使用户专注于其上，这会让时间看起来过得更快些。\n就游戏而言，可以考虑播放一些背景音乐或者显示漂亮的启动画面；\n在运算执行期间，更新你的进度提示，改变显示内容，或者做任何你想做的事情：这有助于用户知晓应用正在做一些工作，而不是一声不吭地呆在那儿。\n\n综合监控和真实用户监控Performance Monitoring: RUM vs. synthetic monitoring\n综合监控和真实用户监控 \nPerformance budgetsPerformance budgets\n性能基础知识Performance fundamentals\nPerformance fundamentals\n性能意味着效率\n三个问题\n什么是性能?\n浏览器平台如何帮助改进它?\n可以使用哪些工具和过程来测试和改进它?\n\n工具\n网络监视器 network\nJavaScript 探查器 profile\nperformance\nPerformance-Analyser\nperformance monitor\nrendering\n见\nPageSpeed Insights\nweb-vitals &amp; web-vitals-report\n\nPopulating the page: how browsers workPopulating the page: how browsers work\nRecommended Web Performance Timings: How long is too long?Recommended Web Performance Timings: How long is too long?\n了解延迟Understanding latency\n了解延迟\nDNS 预获取Using dns-prefetch\nDNS 预获取\n一些优化指标\n\n\n见：2023-02-14web_lcp\n见：2023-02-14web_fid\n见：2023-02-14web_cls\nTime to First Byte 首字节时间 (TTFB)\nTime to Interactive 可交互时间 (TTI)\n\n测量工具对比\n\n\n工具名\nLCP\nFID\nCLS\n\n\n\nweb-vitals 脚本库\n✔\n✔\n✔\n\n\nWeb 指标扩展程序 \n✔\n✔\n✔\n\n\nChrome 开发者工具\n✔\n✘（使用 TBT 代替）\n✔\n\n\n灯塔 \n✔\n✘（使用 TBT 代替）\n✔\n\n\n原型链也会搞性能在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链\n参考资料浏览器的 performance API 与页面首屏加载分析\nWeb 指标\n","slug":"2023-02-12Web_Performance","date":"2023-02-12T13:59:56.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"举手摘月亮"},{"id":"6a9933d3674afa3ae34e90758b20e9f5","title":"问题复盘","content":"技术上优化上\n包优化： wiki-ui 组件库拖慢业务项目的问题\n开发优化：webpack 在开发阶段，启动更新慢的问题，使用 vite 进行开发环境的替换，实现 vite 开发环境，webpack 生产环境\n发布更新：使用模块联邦解决微应用问题，实现业务拆分\n性能优化：immerjs 进行按需更新，实现拖拽排序卡顿的问题\n业务组件复用问题\n输入卡顿问题：\n简单模式、\n看板模式、表格模式（表格的表头实现定制化拖拽排序、左右固定，上部分是表单、表头 sticky、表格配置项 sticky 效果）组件很复杂，\n当时遇到一个问题是表格配置项被封装到了表格模式组件的内部，如何进行 sticky，熟悉 sticky 的都晓得为什么封装到内部不可以进行多级 sticky 的原因\n层级问题\nsticky 的 top 需要动态计算，并且要动态覆盖 table 样式的问题\n\n\n看板模式\n数据表头组合级联问题\n看板每列虚拟列表，列表子项 item 高度非固定\n虚拟列表加载问题\n\n\n这里涉及到 ahooks 处理问题\nahooks 之前默认的 v2, 新版本默认 v3, 在不改变源代码的情况下，如何实现 ahooksv2 默认，v3 非默认的问题\n为什么会存在这个现象，v2，v3 不兼容，一些方法在 v3 中去除了\n\n\n\n\n视图图表按需加载问题\nlongTask 图表数据，放到 webworkers 中处理\n前端报表导出，放到 webworkers 中处理\n\n提高研发效能\n傻瓜式写代码问题\nredux reducer，实现自动装配\n代码片段的自动化生成\nswagger 自动化生成 service、type 类型\n\n\n多语言方案\n实现了一整套多语言方案，降低维护成本\nnpm-cli 工具、基础平台搭建、利用一些插件进行可视化操作\n\n\n结合公司发布平台，实现灰度发布\n\n电脑空间不足\nnode_modules 过大问题，维护项目比较多，电脑空间占用极大，几乎每次剩余不到 20G 的空间\n电脑空间不足，使用 shell 命令一个命令清理掉所有项目的 node_modules\n使用 pnpm 代替 npm、和 yarn 解决磁盘占用极大的问题\n尤其是 8+256 存储空间，既要维护 RN 还要维护各种前端项目\n\nreact-native-webiew 安卓上返回无法正常监听到\n问题解决，早些时候有 java 相关技术储备，大学也学过 android,敢于尝试，\n进行 android webview 相关资料查询和 react-native-webiew 原生部分源码的解读，\n发现 react-native-webiew 在安卓部分源码，少调用了一个 api，通过增加这个 api，在 demo 中解决这个问题\n\n业务上计算复杂度\n需求：\n用户有哪些权限，支持哪些组织架构级别的查询，则返回对应的结构\n实现类似于 antd select 多选和 antd tree 树多选的组合功能的公共业务组件的封装\n\n\n\n这个地方涉及到树的路径去重问题，当时后端说解决不了，我说可以解决，放在前端处理好了\n\n同枝干不同级别的部门\n同一层级不同部门\n不同层级的不同部门\n\n流程上敏捷开发流程不够完善问题\n\n如何进行高效的交付\n需求评审\n技术评审\n前后端数据的接口字段定义\n开发阶段每天早上站立会，及时暴露风险项\n交叉测试\n验收\n\n\n\n多公司协作问题\n当时遇到的问题是：公司有块业务是病例质检功能，这块功能是向已有的院内病例系统增加新的质检，目的是为了降低医患纠纷\n涉及的公司有阿里巴巴飞天的质检引擎\n兄弟公司医疗公司的 C#开发工程师\n之前我所在的公司负责 html 的开发（暴露病例存在问题的项目）和与病例系统的对接工作\n对方院内病例系统工程师要和我们对接前端还要与阿里的对接病例质检结果落库操作\n当时遇到的问题是有些院内病例系统使用 PB 开发、有 C#开发、有 web 开发的\n我在对接的过程中，通过对相关 demo 的本地模拟，熟练掌握，解决对接过程中的一系列问题（\n对接方案不成熟 当时主要是前端对接，C#提供的动态库，后面改成数据库视图\n对接过程中加载顺序问题的排查，向兄弟公司工程师暴露问题所在，进行修改）\n对接方不积极\n当时遇到个新疆那边难缠的病例系统非技术现场实施，我跟她聊了半个多小时，不懂，最后我给公司老板讲解，公司老板远程视频，画白版给对方讲解，对方才去沟通\n\n\n\n\n\n","slug":"2023-02-12problem","date":"2023-02-12T03:15:27.000Z","categories_index":"复盘","tags_index":"复盘","author_index":"举手摘月亮"},{"id":"99dafe6a56f2f503a228c70a977846b0","title":"mouse action","content":"activeElement见\nDocument：selectionchange 事件见\nDocumentOrShadowRoot.getSelection()见\n","slug":"2023-02-12mouse","date":"2023-02-12T02:08:53.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"cf066144ab31ae65fce8b2ffb9bf08b9","title":"浏览器数据爬取","content":"copy可以直接将值复制到剪切板\n&#x2F;&#x2F; chrome控制台执行\nvar data &#x3D; &quot;hello world&quot;;\ncopy(data); &#x2F;&#x2F; 已经到剪切板了\n\ndocument.links直接获取 document 上所有链接\n处理一个列表下的链接资源&#x2F;&#x2F; 右键选取， store as global variable\nvar data &#x3D; &quot;&quot;;\nfunction getalink(_domlist) &#123;\n  Array.from(_domlist).forEach((li) &#x3D;&gt; &#123;\n    var a &#x3D; li.children[0];\n    var href &#x3D; a.href;\n    var title &#x3D; a.innerText;\n    data &#x3D; data + &#96;### $&#123;a.innerText&#125; \\n\\n&#96;;\n    var astr &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;href&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;title&#125;&lt;&#x2F;a&gt; \\n\\n&#96;;\n    data +&#x3D; astr;\n  &#125;);\n&#125;\n\n处理一个列表下的 h 资源&#x2F;&#x2F; 右键选取， store as global variable\nvar data &#x3D; &quot;&quot;;\nfunction gethlist(_domlist) &#123;\n  Array.from(_domlist).forEach((li) &#x3D;&gt; &#123;\n    var title &#x3D; li.innerText;\n    data &#x3D; data + &#96;### $&#123;title&#125; \\n\\n&#96;;\n  &#125;);\n&#125;\ncopy(data);\n","slug":"2023-02-12数据爬取","date":"2023-02-11T16:57:34.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"a837b31db4bffa654fe3b9023ed7211d","title":"Web API【watting...】","content":"爬取脚本var sects &#x3D; document.getElementById(&quot;sect1&quot;);\nvar h3s &#x3D; sects.getElementsByTagName(&quot;h3&quot;);\nvar uls &#x3D; sects.getElementsByTagName(&quot;ul&quot;);\n\nvar h3sArr &#x3D; Array.from(h3s);\nvar ulsArr &#x3D; Array.from(uls);\nlet arr &#x3D; [];\nvar result &#x3D; &quot;&quot;;\nvar data &#x3D; &quot;&quot;;\n\nh3sArr.forEach((h3, index) &#x3D;&gt; &#123;\n  const h3title &#x3D; h3.textContent;\n  const aList &#x3D; Array.from(ulsArr[index].children);\n  data &#x3D; data + &#96;## $&#123;h3title&#125; \\n\\n&#96;;\n  getalink(aList);\n&#125;);\n\nfunction getalink(_domlist) &#123;\n  Array.from(_domlist).forEach((li) &#x3D;&gt; &#123;\n    var a &#x3D; li.children[0];\n    var href &#x3D; a.href;\n    var title &#x3D; a.innerText;\n    data &#x3D; data + &#96;### $&#123;a.innerText&#125; \\n\\n&#96;;\n    var astr &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;href&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;title&#125;&lt;&#x2F;a&gt; \\n\\n&#96;;\n    data +&#x3D; astr;\n  &#125;);\n&#125;\n\n&#x2F;&#x2F; console.log(&quot;data&quot;, data);\ncopy(data); &#x2F;&#x2F;控制台直接拷贝到剪切板\n\nBBackground Fetch API (en-US)Background Fetch API (en-US)\nBackground Sync (en-US)Background Sync (en-US)\nBackground TasksBackground Tasks\nBarcode Detection API (en-US)Barcode Detection API (en-US)\nBattery APIBattery API\nBeaconBeacon\nBluetooth API (en-US)Bluetooth API (en-US)\nBroadcast Channel APIBroadcast Channel API\nCCSS Counter StylesCSS Counter Styles\nCSS Custom Highlight API (en-US)CSS Custom Highlight API (en-US)\nCSS Font Loading APICSS Font Loading API\nCSS Painting API (en-US)CSS Painting API (en-US)\nCSS Properties and Values API (en-US)CSS Properties and Values API (en-US)\nCSS Typed Object Model API (en-US)CSS Typed Object Model API (en-US)\nCSSOMCSSOM\nCanvas APICanvas API\nChannel Messaging APIChannel Messaging API\nClipboard APIClipboard API\nCompression Streams API (en-US)Compression Streams API (en-US)\nConsole APIConsole API\nContact Picker API (en-US)Contact Picker API (en-US)\nContent Index API (en-US)Content Index API (en-US)\nCookie Store API (en-US)Cookie Store API (en-US)\nCredential Management APICredential Management API\nDDOMDOM\nDevice Orientation Events (en-US)Device Orientation Events (en-US)\nEEncoding APIEncoding API\nEncrypted Media Extensions (en-US)Encrypted Media Extensions (en-US)\nEyeDropper API (en-US)EyeDropper API (en-US)\nFFetch APIFetch API\nFile API (en-US)File API (en-US)\nFile System Access API (en-US)File System Access API (en-US)\nFile and Directory Entries APIFile and Directory Entries API\nFullscreen APIFullscreen API\nGGamepad APIGamepad API\nGeolocation APIGeolocation API\nGeometry Interfaces (en-US)Geometry Interfaces (en-US)\nHHTML DOMHTML DOM\nHTML Drag and Drop APIHTML Drag and Drop API\nHTML Sanitizer API (en-US)HTML Sanitizer API (en-US)\nHistory APIHistory API\nIIdle Detection API (en-US)Idle Detection API (en-US)\nImage Capture API (en-US)Image Capture API (en-US)\nIndexedDBIndexedDB\nInk API (en-US)Ink API (en-US)\nIntersection Observer APIIntersection Observer API\nKKeyboard API (en-US)Keyboard API (en-US)\nLLayout Instability API (en-US)Layout Instability API (en-US)\nLocal Font Access API (en-US)Local Font Access API (en-US)\nMMedia Capabilities API (en-US)Media Capabilities API (en-US)\nMedia Capture and StreamsMedia Capture and Streams\nMedia Session API (en-US)Media Session API (en-US)\nMedia Source ExtensionsMedia Source Extensions\nMediaStream RecordingMediaStream Recording\nNNavigation API (en-US)Navigation API (en-US)\nNetwork Information APINetwork Information API\nPPage Visibility APIPage Visibility API\nPayment Handler API (en-US)Payment Handler API (en-US)\nPayment Request APIPayment Request API\nPerformance APIPerformance API\nPeriodic Background Sync (en-US)Periodic Background Sync (en-US)\nPermissions APIPermissions API\nPicture-in-Picture APIPicture-in-Picture API\nPointer EventsPointer Events\nPointer Lock APIPointer Lock API\nPresentation API (en-US)Presentation API (en-US)\nPrioritized Task Scheduling API (en-US)Prioritized Task Scheduling API (en-US)\nProximity Events (en-US)Proximity Events (en-US)\nPush APIPush API\nRReporting API (en-US)Reporting API (en-US)\nResize Observer APIResize Observer API\nSScreen Capture APIScreen Capture API\nScreen Orientation API (en-US)Screen Orientation API (en-US)\nScreen Wake Lock API (en-US)Screen Wake Lock API (en-US)\nSelection API (en-US)Selection API (en-US)\nSensor APISensor API\nServer Sent EventsServer Sent Events\nService Workers APIService Workers API\nStorageStorage\nStorage Access API (en-US)Storage Access API (en-US)\nStreamsStreams\nTTouch EventsTouch Events\nTrusted Types API (en-US)Trusted Types API (en-US)\nUUI Events (en-US)UI Events (en-US)\nURL APIURL API\nURL Pattern API (en-US)URL Pattern API (en-US)\nUser-Agent Client Hints API (en-US)User-Agent Client Hints API (en-US)\nVVibration APIVibration API\nVirtualKeyboard API (en-US)VirtualKeyboard API (en-US)\nVisual Viewport (en-US)Visual Viewport (en-US)\nWWeb AnimationsWeb Animations\nWeb Audio APIWeb Audio API\nWeb Authentication APIWeb Authentication API\nWeb Crypto APIWeb Crypto API\nWeb Locks API (en-US)Web Locks API (en-US)\nWeb MIDI API (en-US)Web MIDI API (en-US)\nWeb NFC API (en-US)Web NFC API (en-US)\nWeb NotificationsWeb Notifications\nWeb Share API (en-US)Web Share API (en-US)\nWeb Speech APIWeb Speech API\nWeb Storage APIWeb Storage API\nWeb Workers APIWeb Workers API\nWebCodecs API (en-US)WebCodecs API (en-US)\nWebGLWebGL\nWebHID API (en-US)WebHID API (en-US)\nWebOTP API (en-US)WebOTP API (en-US)\nWebRTCWebRTC\nWebTransport API (en-US)WebTransport API (en-US)\nWebUSB API (en-US)WebUSB API (en-US)\nWebVR APIWebVR API\nWebVTTWebVTT\nWebXR Device APIWebXR Device API\nWebsockets APIWebsockets API\nWindow Controls Overlay API (en-US)Window Controls Overlay API (en-US)\nXXMLHttpRequestXMLHttpRequest\n参考链接WEB API\n","slug":"2023-02-11webapi","date":"2023-02-11T15:36:04.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"abe1fdd233c62a53808b3cc396b5a093","title":"常聊的存储","content":"打开思维定式只要能存储，就关联起来，不要局限于 cookie，localStorage，sessionStorage，indexDB\nweb 相关的cookie&#x2F;cookieStorecookie\ncookieStore\nlocalStorage，sessionStorage\nWeb Storage API 提供机制，使浏览器能以一种比使用 Cookie 更直观的方式存储键/值对\nsessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。\nlocalStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。\n在支持的浏览器中 Window 对象实现了 WindowLocalStorage 和 WindowSessionStorage 对象并挂在其 localStorage 和 sessionStorage 属性下\n调用其中任一对象会创建 Storage 对象，通过 Storage 对象，可以设置、获取和移除数据项。\n对于每个源（origin）sessionStorage 和 localStorage 使用不同的 Storage 对象——独立运行和控制 （浏览器内容安全策略限制，禁止跨域，这里要注意一下，这里特指origin并没有说跨域三要素的事情，是跨域的必要非充分条件）\nStorageEvent当一个存储区更改时，存储事件从文档的 Window 对象上被发布\n\nindexDB 数据库web sql 弃用存到 url 上刷新不丢失history.pushState &#x2F; replaceState\nhistory.pushState() 方法向当前浏览器会话的历史堆栈中添加一个状态（state）,\n在 reactrouter源码中使用了 history 库，history 封装了 webapi history 相关方法，有replaceState这个. useSearchParams\n\n不同于 window.location从某种程度来说，调用 pushState() 和 window.location &#x3D; “#foo”基本上一样，\nwindow.location &#x2F; history.pushState &#x2F; replaceState 区别\n\n\n比较项\nhistory.pushState\nreplaceState\nwindow.location\n\n\n\n创建和激活一个新的历史记录\n是\n否\n是\n\n\n适用更广\n同源就行\n同源就行\nwindow.location 只会在你只设置锚的时候才会使当前的 URL\n\n\n修改 URL\n非强制\n非强制\n仅仅会在锚的值不是 #foo 情况下创建一条新的历史记录\n\n\n新的历史记录中关联任何数据\n可以\n可以\n将所需数据写入锚的字符串中\n\n\nhashchange 事件调用\n不调用\n不调用\n调用\n\n\nService Worker registrationsCacheStorageCache\n\nCache 接口为缓存的Request / Response 对象对提供存储机制，例如，作为 ServiceWorker 生命周期的一部分。\n请注意，Cache 接口像 workers 一样，是暴露在 window 作用域下的。\n尽管它被定义在 service worker 的标准中，但是它不必一定要配合 service worker 使用\n一个域可以有多个命名 Cache 对象。你需要在你的脚本 (例如，在 ServiceWorker 中) 中处理缓存更新的方式。\n除非明确地更新缓存，否则缓存将不会被更新；除非删除，否则缓存数据不会过期。\n使用 CacheStorage.open(cacheName) 打开一个 Cache 对象，再使用 Cache 对象的方法去处理缓存\n\nAPI Promise\nCache.match(request, options)返回一个 Promise 对象，resolve 的结果是跟 Cache 对象匹配的第一个已经缓存的请求。\nCache.matchAll(request, options) 返回一个 Promise 对象，resolve 的结果是跟 Cache 对象匹配的所有请求组成的数组。\nCache.add(request) 抓取这个 URL，检索并把返回的 response 对象添加到给定的 Cache 对象。这在功能上等同于调用 fetch(), 然后使用 Cache.put() 将 response 添加到 cache 中。\nCache.addAll(requests) 抓取一个 URL 数组，检索并把返回的 response 对象添加到给定的 Cache 对象。\nCache.put(request, response) 同时抓取一个请求及其响应，并将其添加到给定的 cache。\nCache.delete(request, options) 搜索 key 值为 request 的 Cache 条目。如果找到，则删除该 Cache 条目，并且返回一个 resolve 为 true 的 Promise 对象；如果未找到，则返回一个 resolve 为 false 的 Promise 对象。\nCache.keys(request, options) 返回一个 Promise 对象，resolve 的结果是 Cache 对象 key 值组成的数组。\n\n大多数浏览器兼容闭包、全局变量框架context、useStateredux、vuex、pinia原生相关的SQLite小程序相关 storage参考资料Storage_API\n","slug":"2023-02-11站点存储","date":"2023-02-11T14:52:27.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"842dcf974088eb6a6584ed019af3396a","title":"包管理工具","content":"npm用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。\n执行 npm init， npm install express，可以看到 node_modules 目录如下：可以看到，npm2 的 node_modules 是嵌套的。\n优点:就是模块依赖关系清晰。\n缺点：\n依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下，最多 260 多个字符。\n大量重复的包被安装，文件体积超级大。比如跟 foo 同级目录下有一个 baz，两者都依赖于同一个版本的 lodash，那么 lodash 会分别在两者的 node_modules 中被安装，也就是重复安装。\n模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug。\n\n当时 npm 还没解决这些问题，社区就出来一个新的解决方案了，那就是 yarn。\n————————————————版权声明：本文为 CSDN 博主「weikxu」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_33050575/article/details/127852993\ncnpmyarn项目初衷: 为了解决 npm 存在的问题Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。\n特点同时利用并行下载以最大化资源利用率，因此安装速度更快。\n\n扁平模式: 将依赖包的不同版本归结为单个版本，以避免创建多个副本。\n确定性 不管安装顺序如何，相同的依赖关系将在每台机器上以相同的方式安装。\n相同软件包: 从 npm 安装软件包并保持相同的包管理流程。\n离线模式: 如果你以前安装过某个包，再次安装时可以在没有任何互联网连接的情况下进行。\n网络性能: 请求队列化处理，避免发起的请求如瀑布般倾泻，以便最大限度地利用网络资源。\n重试机制: 重试机制确保单个请求失败并不会导致整个安装失败。\n\n见\nyarn2 vs yarn1pnmp项目初衷: 节约磁盘空间并提升安装速度快速的，节省磁盘空间的包管理工具\n\n快速: pnpm 比其他包管理器快 2 倍\n高效: node_modules 中的文件为复制或链接自特定的内容寻址存储库\n支持 monorepos: pnpm 内置支持单仓多包\n严格: pnpm 默认创建了一个非平铺的 node_modules，因此代码无法访问任意包\n\n见\n有个缺点：有时候 pnpm 安装不了的包，yarn 可以安装\n链接寻址\n\n\n\n\n非扁平化的 node_modules\n使用 npm 或 Yarn Classic 安装依赖项时，所有包都被提升到模块目录的根目录。 因此，项目可以访问到未被添加进当前项目的依赖。\n默认情况下，pnpm 使用软链的方式将项目的直接依赖添加进模块文件夹的根目录。\n\n\n\n比较pnpm vs yarnpnpm 优于 yarn 的点：\n\n链接寻址: 项目内 node_modules 大小进行比较  yarn 5.93 GB ， pnpm 588.8 MB\nside-effect-cache\n自动安装 peers\n管理 Node.js 版本\n\nyarn 比 pnpm 多了零安装功能\n\n -->\n\n\n\n\npnpm vs yarn vs npm\n\n\n功能\npnpm\nYarn\nnpm\n\n\n\n工作空间支持（monorepo）\n✔️\n✔️\n✔️\n\n\n隔离的 node_modules\n✔️ - 默认\n✔️\n✔️\n\n\n提升的 node_modules\n✔️\n✔️\n✔️ - 默认\n\n\n自动安装 peers\n✔️ - 通过 auto-install-peers&#x3D;true\n❌\n✔️\n\n\nPlug’n’Play 安装策略\n✔️\n✔️ - 默认\n❌\n\n\n零安装\n❌\n✔️\n❌\n\n\n修补依赖项\n✔️\n✔️\n❌\n\n\n管理 Node.js 版本\n✔️ - pnpm env &lt;cmd&gt;\n❌\n❌\n\n\n有锁文件\n✔️ - pnpm-lock.yaml\n✔️ - yarn.lock\n✔️ - package-lock.json\n\n\n支持覆盖\n✔️\n✔️ - 通过 resolutions\n✔️\n\n\n内容可寻址存储\n✔️ - 链接形式\n❌\n❌\n\n\n动态包执行(不安装，仅执行)\n✔️ - 通过 pnpm dlx 见\n✔️ - 通过 yarn dlx\n✔️ - 通过 npx\n\n\nSide-effects cache\n✔️\n❌\n❌\n\n\n罗列许可\n✔️ - Via pnpm licenses list Added in: v7.17.0\n✔️ - Via a plugin\n❌\n\n\npnpm yarn npm 功能比较\n术语零安装(yarn 独有)\n零安装将缓存存储在您项目目录中的.yarn 文件夹中,\n当使用 yarn 或 yarn add package 等命令时， Yarn 将创建一个 .pnp.cjs 文件, 该文件包含项目包的依赖关系层次结构,因此，我们几乎可以在零时间访问它们\n\nPlug’n’Playan 安装策略见见\nPnP 主要是为了解决当前依赖管理方式 安装依赖，引用依赖效率低下的问题\n软链接&#x2F;硬链接首先区分拷贝和共享的区别：\n1. 拷贝：是建立多个副本，一个副本的修改不会影响另一个。\n2. 共享：是通过链接的方式建立联系，只会存在一个真正的文件，任何改变对其他用户可见。\n\nlinux 文件链接分为两种：一种被称为硬链接；另一种为软链接。\n1）创建硬链接的 shell 命令：ln -d, 默认状态下（ln 命令不带任何选项），ln 命令产生硬链接。\n硬链接是指在 linux 中，多个文件名指向同一个 i 节点（索引节点）。它允许一个文件拥有多个有效路径名，防止用户“误删”，即文件真正删除的条件是与之相关的所有硬链接文件均被删除\n2）符号链接的 shell 命令：ln -s\n符号链接也叫软链接，类似 windows 的快捷方式，是一个特殊的文本文件（LINK 类型），里面包含所链接的文件的位置信息。只有文件的真正拥有者才有文件索引节点的指针，其他人只有路径名，这也就意味着只有文件的拥有者才拥有文件的修改权限，其他人只有只读权限\nside-effects-cache\n会让 preinstall 和 postinstall 两个脚本或 hook 执行的结果缓存，这样做会大大减少（非首次）pnpm install 执行的时间。\npnpm 本来也以缓存下载结果，加速包下载而著称 见\n\n参考链接JavaScript 包管理器比较：Npm vs Yarn vs Pnpm\npnpm-v7 正式发布！最大变化：默认开启 side-effects-cache\nshell 编程之软硬链接 ln\n","slug":"2023-02-10pkg","date":"2023-02-10T10:33:47.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"b615acafbb8ee4433c2f5fdfa0424a84","title":"博客页面/源码分离","content":"背景源码&#x2F;页面放一起暴露，太不安全\n创建新的仓库tech-blog.io\n更改 hexo 配置#  _config.yml\n\ndeploy:\n  type: git\n  repo: https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;tech-blog.io\n  branch: gh-pages\n\n\n\n执行 pn releaseyarn release\n# or\npnpm release\n\n将原仓库域名解绑定原因：\n\n同一域名不可绑定两个仓库\n如果不重新绑定，可以用域名&#x2F;仓库名访问，路径有丢丢长\n\n将新仓库域名绑定\n\n将旧仓库含源码设置私有\n","slug":"2023-02-09hexo","date":"2023-02-09T15:20:55.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"举手摘月亮"},{"id":"beed7925d3f184cc44d11ac5313f14be","title":"数据存储的复盘","content":"背景\n列表查询查询条件，需要创建筛选器进行服务端存储\n用户打开页面获取筛选器列表\n点击筛选器列表，获取筛选器详情，并用筛选器详情进行列表查询操作\n\n要点：查询条件，与筛选器条件一致性\n问题\n后端将筛选器存的数据进行非必要拆分\n筛选器与查询列表的接口条件字段对不上\n筛选器与查询列表的字段，数组类型，转化成字符串存储，返回的时候又要转化成数组去使用\n数组类型中的 number 类型，会被转化成 string 类型，无法与 select 进行选中，需要处理成 number 类型\nstartTime、endTime 时间戳类型，前端没有传入数据，被后端默认为 0 处理了\n未传入的 id 类型（如业务 id）,被后端处理成了’0’\n\n理由：\n\nmysql 数据库存一个字符串太大，会字段过长，\n项目没有使用 mongodb\n\n导致前端要转数据，查询时候还要做一些错误数据、无用字段的清理\n\nDetails\nexport const cleanFilter &#x3D; (obj) &#x3D;&gt; &#123;\n  Object.keys(obj).forEach((k) &#x3D;&gt; &#123;\n    if (&#x2F;.+Infos$&#x2F;.test(k)) &#123;\n      delete obj[k];\n    &#125;\n    if (&#x2F;^modifie*&#x2F;.test(k)) &#123;\n      delete obj[k];\n    &#125;\n    if (&#x2F;^gmt*&#x2F;.test(k)) &#123;\n      delete obj[k];\n    &#125;\n  &#125;);\n  delete obj.creator;\n  delete obj.createdBy;\n  delete obj.createStart;\n  delete obj.createEnd;\n  delete obj.id;\n  &#x2F;&#x2F;   产生的原因，后端设计表时候defaultvalue设置为 0\n  obj.startTime &#x3D;&#x3D;&#x3D; 0 &amp;&amp; delete obj.startTime;\n  obj.endTime &#x3D;&#x3D;&#x3D; 0 &amp;&amp; delete obj.endTime;\n  &#x2F;&#x2F;   产生的原因，后端代码逻辑默认值的问题\n  obj.bizId &#x3D;&#x3D;&#x3D; &quot;0&quot; &amp;&amp; delete obj.bizId;\n  !obj.customerCode &amp;&amp; delete obj.customerCode;\n  !obj.customerInfo &amp;&amp; delete obj.customerInfo;\n  !obj.searchKey &amp;&amp; delete obj.searchKey;\n  return obj;\n&#125;;\n\n\n\n对于后端存储的思考需要存储的内容&#x2F;&#x2F; id: 筛选器id\n&#x2F;&#x2F; userId: 外键id\n&#x2F;&#x2F; filterInfo: 筛选器内容信息一个json&#x2F;jsonString结构\n&#x2F;&#x2F; filterName: 筛选器名称\n&#x2F;&#x2F; filterType: 筛选器类型\n\n存储方式\nmysql,\n即使 filterInfo 很大，能大到哪里去？1M 肯定够了，再多就是不支持，\n用户会无聊搞这么大的查询条件？\nlongText？\n即使后面需要处理，再处理成 mongodb 也是没问题的\n\n\nmongodb， 不用 mysql，接入一个 mongodb 总行了吧\n接入 mongodb 比数据拆解、转化来转化去的成本更低\n可维护性更高\n\n\n\n","slug":"2023-02-09数据","date":"2023-02-09T02:06:51.000Z","categories_index":"复盘","tags_index":"复盘","author_index":"举手摘月亮"},{"id":"1e558081e29dbc1646c77a0cee4dbc74","title":"垃圾回收机制","content":"是什么清除不在使用的对象，释放所占用的内存\n当定义一个变量，给它重新赋值一个新的对象后，原来的对象就不再使用了，就可以把它清除掉\n策略\n引用计数法\n标记清除法\n\n引用计数法\n当对象被引用一次，引用数+1，\n被取消引用一次，引用数-1，\n当引用数为 0 的时候，就触发垃圾回收机制进行回收\n\n问题：这样会产生一个很严重的问题，循环引用，引用的次数永远不可能为 0，无法回收，内存无法释放\n标记清除法\n将所有的对象标记为 0\n从根对象开始遍历，将存活的对象标记为 1\n然后将标记为 0 的对象清除掉\n最后，将标记为 1 的对象重新标记为 0，方便下一次垃圾回收机制回收\n\n问题：清除之后位置是不连续的，如果进来一个新对象找位置，是一个问题\n新对象如何找合适的位置？\nfirst-fit: 找到能放置下新对象的第一个块位置（性能最好）\nbest-fit: 找到能放置下新对象的最小块\nworst-fit: 找到最大的块，切一块空间给新对象（会产生更多不连续的空间）\n\nv8 垃圾回收优化算法\n\n优化标记算法\n\n有的对象需要频繁回收，有的对象不需要频繁回收\n小的存活时间短的需要频繁回收\n大的老的，不需要频繁回收\n在堆内存中分出两个区域来，一个是新生代区，一个是老生代区，\n新生代区一般存： 小的存活时间短的需要频繁回收， 老生代区存： 大的老的，不需要频繁回收\n\n新生代区回收机制\n新生代区会分离出两个空间：from 空间、to 空间\nfrom 空间是使用空间，to 空间是闲置空间\n当 from 空间中的对象要满的时候，就开始标记，将存活的对象标记好，标记好后，将他们复制到闲置的空间中，将 form 空间清空\n\n老生代区回收机制\n标记清除算法 &amp; 标记压缩算法\n将所有的对象标记为 0\n从根对象开始遍历，将存活的对象标记为 1\n然后将标记为 0 的对象清除掉\n最后，将标记为 1 的对象重新标记为 0，\n使用压缩算法，将位置整理好\n\n\n\njs 是单线程语言，在执行垃圾回收的时候，js 执行会被暂停\nv8 多线程回收机制v8 机制，对这种情况做了一定的优化：垃圾回收机制支持多线程，并行回收，使垃圾回收机制的时间加快了，时间变短，最大化保证 js 执行，但是依然会阻塞 js 的执行\nv8 增量标记垃圾回收可以分段执行： 执行一段 js，执行一段垃圾回收机制，交叉执行，最大化保证 js 的执行\n问题：如何知道上一次标记的位置？\nv8 三色标记法将上次标记到的位置标记为灰色，当下次执行的时候从灰色开始重新标记\nv8 并发回收js 在主线程中执行，垃圾回收在辅助线程中执行\n","slug":"2023-02-08GC","date":"2023-02-08T12:22:21.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"d22bd3e2ae8312f99881c275d1b03727","title":"vscode 升级后一些问题","content":"代码片段失效了升级后，需要增加 如下配置\n&quot;editor.suggest.showSnippets&quot;: true,\n\n讲道理是不应该的：电脑配置是同步 github 的，不会出现丢失的现象\n见#173924\n代码片段之前正常的内容也会报红\n\nissues 很多反馈下班后特意看了下 vscode 的仓库：看来很普遍啊～～\n\n\nv1.75.1 版本修复Update 1.75.1: The update addresses these issues\n教训下次新版本发布，不着急升级\n","slug":"2023-02-08vscode","date":"2023-02-08T02:12:13.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"02c9defcec8ead4b797947c1373e1cfd","title":"immer","content":"什么是不可变数据范式immerjs中文官网\nhttps://github.com/immerjs/immer\n\nimmer 是什么在于 baseState 将保持不变，但 nextState 将反映对 DraftState 所做的所有更改.\n为什么需要 immer\n不可变的数据结构的变化检测：\n如果对象的引用没有改变，那么对象本身也没有改变。\n此外，它使克隆对象相对便宜：数据树的未更改部分不需要复制，并且在内存中与相同状态的旧版本共享\n\nimmer 使用场景\nImmer 可以在需要使用不可变数据结构的任何上下文中使用。\n例如与 React state、React 或 Redux reducers 或者 configuration management 结合使用\nreact-dnd 排序，防止整个列表突变\n\n工作原理只关注变更，剩下的 Immer 自动完成\n\n使用 Immer 时，将所有更改应用到临时 draft，它是 currentState 的代理。\n完成了所有的 mutations 后，Immer 根据 draft state 的 mutations 生成 nextState。\n这意味着您可以通过简单地修改数据来与数据交互，同时保留不可变数据的所有好处。\n\n\n\n特点\n遵循不可变数据范式，同时使用普通的 JavaScript 对象、数组、Sets 和 Maps。无需学习新的 API 或 “mutations patterns”！\n强类型，无基于字符串的路径选择器等\n开箱即用的结构共享\n开箱即用的对象冻结\n深度更新轻而易举\n样板代码减少。更少的噪音，更简洁的代码\n对 JSON 补丁的一流支持\n小：3KB gzip\n\n总之：过程简单，小巧方便\n使用上需要注意的地方见\n功能选用\n使用上producereact hooks见\n对象&#x2F;数组&#x2F;嵌套结构对象&#x2F;&#x2F; 没有额外的 API,同原生\nimport produce from &quot;immer&quot;;\n\nconst todosObj &#x3D; &#123;\n  id1: &#123; done: false, body: &quot;Take out the trash&quot; &#125;,\n  id2: &#123; done: false, body: &quot;Check Email&quot; &#125;,\n&#125;;\n\n&#x2F;&#x2F; 添加\nconst addedTodosObj &#x3D; produce(todosObj, (draft) &#x3D;&gt; &#123;\n  draft[&quot;id3&quot;] &#x3D; &#123; done: false, body: &quot;Buy bananas&quot; &#125;;\n&#125;);\n\n&#x2F;&#x2F; 删除\nconst deletedTodosObj &#x3D; produce(todosObj, (draft) &#x3D;&gt; &#123;\n  delete draft[&quot;id1&quot;];\n&#125;);\n\n&#x2F;&#x2F; 更新\nconst updatedTodosObj &#x3D; produce(todosObj, (draft) &#x3D;&gt; &#123;\n  draft[&quot;id1&quot;].done &#x3D; true;\n&#125;);\n\n数组&#x2F;&#x2F; 没有额外的 API,同原生\nimport produce from &quot;immer&quot;;\n\nconst todosArray &#x3D; [\n  &#123; id: &quot;id1&quot;, done: false, body: &quot;Take out the trash&quot; &#125;,\n  &#123; id: &quot;id2&quot;, done: false, body: &quot;Check Email&quot; &#125;,\n];\n\n&#x2F;&#x2F; 添加\nconst addedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.push(&#123; id: &quot;id3&quot;, done: false, body: &quot;Buy bananas&quot; &#125;);\n&#125;);\n\n&#x2F;&#x2F; 索引删除\nconst deletedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.splice(3 &#x2F;*索引 *&#x2F;, 1);\n&#125;);\n\n&#x2F;&#x2F; 索引更新\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft[3].done &#x3D; true;\n&#125;);\n\n&#x2F;&#x2F; 索引插入\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.splice(3, 0, &#123; id: &quot;id3&quot;, done: false, body: &quot;Buy bananas&quot; &#125;);\n&#125;);\n\n&#x2F;&#x2F; 删除最后一个元素\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.pop();\n&#125;);\n\n&#x2F;&#x2F; 删除第一个元素\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.shift();\n&#125;);\n\n&#x2F;&#x2F; 数组开头添加元素\nconst addedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  draft.unshift(&#123; id: &quot;id3&quot;, done: false, body: &quot;Buy bananas&quot; &#125;);\n&#125;);\n\n&#x2F;&#x2F; 根据 id 删除\nconst deletedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  const index &#x3D; draft.findIndex((todo) &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; &quot;id1&quot;);\n  if (index !&#x3D;&#x3D; -1) draft.splice(index, 1);\n&#125;);\n\n&#x2F;&#x2F; 根据 id 更新\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  const index &#x3D; draft.findIndex((todo) &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; &quot;id1&quot;);\n  if (index !&#x3D;&#x3D; -1) draft[index].done &#x3D; true;\n&#125;);\n\n&#x2F;&#x2F; 过滤\nconst updatedTodosArray &#x3D; produce(todosArray, (draft) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 过滤器实际上会返回一个不可变的状态，但是如果过滤器不是处于对象的顶层，这个依然很有用\n  return draft.filter((todo) &#x3D;&gt; todo.done);\n&#125;);\n\n嵌套数据结构import produce from &quot;immer&quot;;\n\n&#x2F;&#x2F; 复杂数据结构例子\nconst store &#x3D; &#123;\n  users: new Map([\n    &#x2F;&#x2F; 这里转化为map类型啦\n    [\n      &quot;17&quot;,\n      &#123;\n        name: &quot;Michel&quot;,\n        todos: [\n          &#123;\n            title: &quot;Get coffee&quot;,\n            done: false,\n          &#125;,\n        ],\n      &#125;,\n    ],\n  ]),\n&#125;;\n\n&#x2F;&#x2F; 深度更新\nconst nextStore &#x3D; produce(store, (draft) &#x3D;&gt; &#123;\n  draft.users.get(&quot;17&quot;).todos[0].done &#x3D; true;\n&#125;);\n\n&#x2F;&#x2F; 过滤\nconst nextStore &#x3D; produce(store, (draft) &#x3D;&gt; &#123;\n  const user &#x3D; draft.users.get(&quot;17&quot;);\n\n  user.todos &#x3D; user.todos.filter((todo) &#x3D;&gt; todo.done);\n&#125;);\n\n优化点\n请注意，许多数组操作可用于通过传递多个参数或使用展开操作来一次插入多个元素：todos.unshift(…items)。\n请注意，当处理包含通常由某个 id 标识的对象的数组时，我们建议使用基于 Map 或索引的对象（如上所示）而不是执行频繁的查找操作，查找表通常执行效率更高。\n\n源码按需深拷贝的实现见\n\n先标记出在 produce 的回调函数中对 draft 做了哪些修改\n当在 produce 的回调函数（称之为 recipe 函数）中修改 draft 数据时，\n通过 set 或 deleteProperty 中的 markChange 完成变化追踪，\n同时通过 state.copy* 来记录修改后的值，并通过 state.assigned* 来记录修改的类型\n\n\n当数据修改完成（recipe 函数执行完成）后，通过 state.copy_ 和 state.modified_ 来生成新的状态\n通过递归遍历子属性，\n通过之前的标记判断子属性部分的数据是否有被修改过，\n如果未被修改则直接使用原始状态中的引用，否则就使用 state.copy_ 中记录的更新来设置子属性数据\n\n\n\n是不是有点 react 的味道，找出变化标记-&gt;产出\nproduce\n\n参考链接48.精读《Immer.js》源码.md\n精读 Immer 源码（一）\nimmer 实现原理\n","slug":"2023-02-06不可变","date":"2023-02-06T08:24:33.000Z","categories_index":"前端工具","tags_index":"前端工具","author_index":"举手摘月亮"},{"id":"d24ff20ad1a722248c0f6ba78f471b7d","title":"前端工程化","content":"babelBabel 的原理是什么?babel 的转译过程也分为三个阶段，这三步具体是：\n\n解析 Parse: 将代码解析⽣成抽象语法树( 即 AST )，即词法分析与语法分析的过程\n转换 Transform: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在 此过程中进⾏添加、更新、移除等操作\n⽣成 Generate: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator\n\nwebpack为什么要用 webpack为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。\n在浏览器中运行 JavaScript 有两种方法。\n\n第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。\n第二种方式，使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。\n\n模块化发展过程(都是为了实现模块化)\n\n立即调用函数表达式(IIFE)\nNode.js，JavaScript 模块诞生\nnpm + Node.js + modules - 大规模分发模块\nESM - ECMAScript 模块\n依赖自动收集\n\n立即调用函数表达式(IIFE)解决的问题\n\nIIFE 解决大型项目的作用域问题；\n当脚本文件被封装在 IIFE 内部时，你可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。\nIIFE 使用方式产生出 Gulp, Grunt, Browserify 等工具。这些工具称为任务执行器，它们将所有项目文件拼接在一起。\n\n存在的问题：\n\n修改一个文件意味着必须重新构建整个文件。\n拼接可以做到很容易地跨文件重用脚本，但是却使构建结果的优化变得更加困难。\n难以判断代码是否实际被使用\n\nNode.js，JavaScript 模块诞生\nCommonJS 问世并引入了 require 机制，它允许你在当前文件中加载和使用某个模块。\n导入需要的每个模块，这一开箱即用的功能，帮助我们解决了作用域问题。\n\nnpm + Node.js + modules - 大规模分发模块\nCommonJS 没有浏览器支持。没有 live binding(实时绑定)。循环引用存在问题。同步执行的模块解析加载器速度很慢\n为了使浏览器支持模块，因而产生了 Browserify, RequireJS 和 SystemJS 等打包工具，允许我们编写能够在浏览器中运行的 CommonJS 模块。\n\nESM - ECMAScript 模块模块正在成为 ECMAScript 标准的官方功能。然而:\n\n浏览器支持不完整，\n版本迭代速度也不够快，\n\n目前还是推荐上面那些早期模块实现\n依赖自动收集\n传统的任务构建工具基于 Google 的 Closure 编译器都要求你手动在顶部声明所有的依赖。\n然而像 webpack 一类的打包工具自动构建并基于你所引用或导出的内容推断出依赖的图谱。这个特性与其它的如插件 and 加载器一道让开发者的体验更好。\n\nwebpack\n可以让我们编写模块，\n可以支持任何模块格式（至少在我们到达 ESM 之前），\n可以同时处理资源和资产\n关心性能和加载时间；\n它始终在改进或添加新功能，例如：异步地加载 chunk 和预取，以便为你的项目和用户提供最佳体验。\n\nrollup、 Parcel什么是 webpack\nwebpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。\n当 webpack 处理应用程序时，从一个或多个入口点构建一个 依赖图(dependency graph)，\n然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容\n\n核心组成部分\n入口(entry)\n输出(output)\nloader\n插件(plugin)\n模式(mode)\n浏览器兼容性(browser compatibility)\n环境(environment)\n\n什么是入口\n入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。\n进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。\n默认值是 ./src/index.js，但你可以通过在 webpack configuration 中配置 entry 属性，来指定一个（或多个）不同的入口起点\n\n什么是输出(output)\noutput 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。\n主要输出文件的默认值是 ./dist/main.js，其他生成文件\n默认放置在 ./dist 文件夹中。\n\n什么是 loader\nwebpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。(这也就决定了，最终打包出来的 bundle 只能是 js 文件，哈～，对于打包为 library 是很容易的事情)\nloader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。\n\n在 webpack 的配置中，loader 有两个属性：\n\ntest 属性，识别出哪些文件会被转换。\nuse 属性，定义出在进行转换时，应该使用哪个 loader。\n\n什么是插件(plugin)\nloader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。\n插件执行的任务，包括：打包优化，资源管理，注入环境变量。\n想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。\n多数插件可以通过选项(option)自定义。\n你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例\n\n核心原理是什么webpack 是如何执行的Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程：\n\n初始化参数：从配置⽂件和 Shell 语句中,读取与合并参数，得出最终的参数；\n开始编译：⽤上⼀步得到的参数, 初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法, 开始执⾏编译；\n确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件；\n编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；\n完成模块编译：在经过第 4 步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容，以及它们之间的依赖关系；\n输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；\n输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。\n在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，插件在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。\n\n常见的 loader 有哪些html\nhtml-loader：将 HTML 导出为字符串。当编译器需要时，将压缩 HTML 字符串。\n\n资源文件\nfile-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件\nurl-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去\nimage-loader：加载并且压缩图⽚⽂件\n\n样式\nless-loader：webpack 将 Less 编译为 CSS 的 loader。\nsass-loader：webpack 将 Sass 编译为 CSS 的 loader。\ncss-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性\nstyle-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。\n\njs 相关\nbabel-loader：把 ES6 转换成 ES5\neslint-loader：通过 ESLint 检查 JavaScript 代码\nsource-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试\nexpose-loader：expose-loader 允许暴露一个模块（整体或者部分）给全局对象（self、window 和 global）\n\n常见的 plugin 有哪些编译时\nhtml-webpack-plugin：简化 html ⽂件创建\ndefine-plugin：定义环境变量\nCopyWebpackPlugin：将已存在的单个文件或整个目录复制到生成目录。\n\n性能提升相关的\nWatchIgnorePlugin：在监视模式下忽略指定的文件，即与提供的路径或正则表达式匹配的文件。\nDllPlugin：DllPlugin 和 DllReferencePlugin，add-asset-html-webpack-plugin 用某种方法实现了拆分 bundles，同时还大幅度提升了构建的速度\nPrefetchPlugin：预先获取模块提高性能\nSplitChunksPlugin: chunks（以及内部导入的模块）是通过内部 webpack 图谱中的父子关系关联的。CommonsChunkPlugin 曾被用来避免他们之间的重复依赖，但是不可能再做进一步的优化。从 webpack v4 开始，移除了 CommonsChunkPlugin，取而代之的是 optimization.splitChunks。\n\n压缩相关的\nHtmlMinimizerWebpackPlugin：使用 html 缩小器精简器来优化和缩小 html。\nCssMinimizerWebpackPlugin：使用 cssnano 优化和压缩 CSS。\nMiniCssExtractPlugin: CSS 提取到单独的⽂件中,⽀持按需加载\nJsonMinimizerWebpackPlugin：使用JSON.stringify()缩小 JSON\nImageMinimizerWebpackPlugin：使用 imagemin 优化（压缩）所有图像\n\n工具相关的\nInstallWebpackPlugin：通过使用 Webpack 自动安装和保存依赖项来加快开发。\nEslintWebpackPlugin：使用 eslint 来查找和修复 JavaScript 代码中的问题。\nStylelintWebpackPlugin：使用 stylelint 帮助你在样式代码中避免错误并强制规范。\nProgressPlugin：ProgressPlugin 提供了一种自定义编译过程 a 中报告进度的方式。\nwebpack-build-notifier：打包完成通知提醒。\n\n优化工具\npage-skeleton-webpack-plugin: 见 骨架屏生成工具，根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中\nwebpack-bundle-analyzer: 可视化 webpack 输出⽂件的体积\nspeed-measure-webpack-plugin: 测量你的 webpack 构建速度，给出这样的输出\n\n微应用&#x2F;组件ModuleFederationPlugin：在运行时提供或使用具有其他独立构建的模块\n自定义 loader自定义 pluginwebpack 钩子compiler 钩子\nCompiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 compilation 实例。\n它扩展（extends）自 Tapable 类，用来注册和调用插件。\n大多数面向用户的插件会首先在 Compiler 上注册\n\ncompilation 钩子\nCompilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。\ncompilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。\n它会对应用程序的依赖图中所有模块， 进行字面上的编译(literal compilation)。\n在编译阶段，模块会被:\n加载(load)、\n封存(seal)、\n优化(optimize)、\n分块(chunk)、\n哈希(hash)\n重新创建(restore)\n\n\n\nwebpack 的代码分割原理当涉及到动态代码拆分时，webpack 提供了两个类似的技术。\n\n第一种，也是推荐选择的方式是，使用符合 ECMAScript 提案 的 import() 语法 来实现动态导入。\n第二种，使用 webpack 特定的 require.ensure\n\ntree-shaking是什么\ntree shaking 是一个术语，\n通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和 export。\n这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。\n\n注意什么为了利用 tree shaking 的优势， 你必须…\n\n使用 ES2015 模块语法（即 import 和 export）。\n确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的（顺带一提，这是现在常用的 @babel&#x2F;preset-env 的默认行为，详细信息请参阅文档）。\n在项目的 package.json 文件中，添加 “sideEffects” 属性。\n使用 mode 为 “production” 的配置项以启用更多优化项，包括压缩代码与 tree shaking。\n你可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。\n\nwebpack 的热更新原理？\n\n\n第⼀步，在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂ 件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。\n第⼆步是 webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API 对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。\n第三步是 webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当 我们在配置⽂件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件 的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。\n第四步也是 webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器 端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也 包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递 的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。\nwebpack-dev-server&#x2F;client 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了 webpack，webpack&#x2F;hot&#x2F;dev-server 的⼯作就是根据 webpack-dev-server&#x2F;client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。\nHotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块 的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步 骤。\n⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是 否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。\n最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。\n\n模块联邦什么是联邦联邦：由若干小社会组成的大社会，在保全小社会充分的自由之下，才有条件发展大社会\n什么是模块联邦是指：由若干小模块组成的大模块，在保全小模块充分的自由之下，才有条件发展大模块\n模块联邦执行过程\n本地模块和远程模块。\n\n本地模块即为普通模块，是当前构建的一部分。\n远程模块不属于当前构建，并在运行时从所谓的容器加载\n\n\n加载远程模块被认为是异步操作。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中\n\n容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。暴露的访问分为两个步骤：\n\n加载模块（异步的）\n\n执行模块（同步的）\n步骤 1 将在 chunk 加载期间完成。步骤 2 将在与其他（本地和远程）的模块交错执行期间完成。这样一来，执行顺序不受模块从本地转换为远程或从远程转为本地的影响。\n\n\n\n容器可以嵌套使用，容器可以使用来自其他容器的模块。容器之间也可以循环依赖。\n\n\n为什么会有模块联邦，解决了什么问题\n微应用： 多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们\n组件复用：实现不同应用的组件复用\n\n模块联邦如何暴露，如何引用\n\n\n引入信息：name、remotes 应用名@远程地址@远程入口文件\n暴露信息：name、filename、exposes 组件路径信息\n\n&#x2F;&#x2F; 引入\nnew ModuleFederationPlugin(&#123;\n  name: &quot;app1&quot;,\n  remotes: &#123;\n    app2: &quot;app2@[app2Url]&#x2F;remoteEntry.js&quot;,\n  &#125;,\n  shared: &#123;react: &#123;singleton: true&#125;, &quot;react-dom&quot;: &#123;singleton: true&#125;&#125;,\n&#125;),\n\n&#x2F;&#x2F; 暴露\nnew ModuleFederationPlugin(&#123;\n  name: &#39;app2&#39;,\n  filename: &#39;remoteEntry.js&#39;,\n  exposes: &#123;\n  &#39;.&#x2F;App&#39;: &#39;.&#x2F;src&#x2F;App&#39;,\n  &#125;,\n  shared: &#123; react: &#123; singleton: true &#125;, &#39;react-dom&#39;: &#123; singleton: true &#125; &#125;,\n&#125;),\n\n\nvite为什么有 vite\n在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。\n这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。\nwebpack、Rollup 和 Parcel 等工具的变迁，它们极大地改善了前端开发者的开发体验。\n然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈\n\nvite 解决了什么问题\n启动缓慢\n更新缓慢\n\nvite 的实现原理是怎样的\nVite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。\n依赖 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。\nVite 将会使用 esbuild 预构建依赖。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。\n源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。\nVite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作, Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理\n\nvite 为什么比 webpack 快\n在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活[1]（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。\nVite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age&#x3D;31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。\n\n为什么生产环境仍需打包\n尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP&#x2F;2）。\n为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。\n\ngitgit mergemarge\n\n特点：⾃动创建⼀个新的 commit 如果合并的时候遇到冲突，仅需要修改后重新 commit\n优点：记录了真实的 commit 情况，包括每个分⽀的详情\n缺点：因为每次 merge 会⾃动产⽣⼀个 merge commit，所以在使⽤⼀些 git 的 GUI tools，特别是 commit ⽐较频繁时，看到分⽀很杂乱。\n\ngit rebase\nrebase 特点：会合并之前的 commit 历史\n优点：得到更简洁的项⽬历史，去掉了 merge commit\n缺点：如果合并出现代码问题, 不容易定位，因为 re-write 了 history\n\n何时使用 merge&#x2F;rebase\n因此,当需要保留详细的合并信息的时候建议使⽤ git merge，特别是需要将分⽀合并进⼊ master 分⽀时；\n当发现⾃⼰修 改某个功能时，频繁进⾏了 git commit 提交时，发现其实过多的提交信息没有必要时，可以尝试 git rebase.\n\ngit rebase 与 git merge(其他摘录)见\n\n\n\nmerge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）\nrebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，\n变基是将一系列提交按照原有次序依次应用到另一分支上，\n合并是把最终结果合在一起。\n\n变基原理：\n是首先找到这两个分支的最近共同祖先 C2\n然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3\n最后以此将之前另存为临时文件的修改依序应用\n\n什么时候用哪个？这本身存在分歧，主要看团队需要，\n\n如果团队需要历史记录保留，便于追踪，可以使用 merge ,\n如果不希望保留过多的过程，只关注结果那么可以用 rebase.\n为了避免 rebase 的坑， 需要遵循原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作\n\n$ git rebase --onto master server client\n\n你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\n见\n\ngit rebase -i HEAD~4\n# s 命令压缩\n\n\n\n\n\n见\ngit reset、git revert 和 git checkout 有什么区别【不懂哟~】这个问题同样也需要先了解 git 仓库的三个组成部分：⼯作区（Working Directory）、暂存区（Stage）和历史记录区 （History）。\n\n⼯作区：在 git 管理下的正常⽬录都算是⼯作区，我们平时的编辑⼯作都是在⼯作区完成\n暂存区：临时区域。⾥⾯存放将要提交⽂件的快照\n历史记录区：git commit 后的记录区 三个区的转换关系以及转换所使⽤的命令：\n\n\n\ngit reset、git revert 和 git checkout 的\n共同点：⽤来撤销代码仓库中的某些更改。不同点：\n从 commit 层⾯来说：\n\ngit reset 可以将⼀个分⽀的末端指向之前的⼀个 commit。然后再下次 git 执⾏垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。\n\ngit reset 还⽀持三种标记，⽤来标记 reset 指令影响的范围：\n\n–mixed：会影响到暂存区和历史记录区。也是默认选项\n–soft：只影响历史记录区\n–hard：影响⼯作区、暂存区和历史记录区\n\n\n因为 git reset 是直接删除 commit 记录，从⽽会影响到其他开发⼈员的分⽀，所以不要在公共分⽀（⽐如 develop）做这个操作。\n\ngit checkout 可以将 HEAD 移到⼀个新的分⽀，并更新⼯作⽬录。因为可能会覆盖本地的修改，所以执⾏这个指令之前，需要 stash 或者 commit 暂存区和⼯作区的更改。\n\ngit revert 和 git reset 的⽬的是⼀样的，但是做法不同，它会以创建新的 commit 的⽅式来撤销 commit，这样能保 留之前的 commit 历史，⽐较安全。同样因为可能会覆盖本地的修改，所以执⾏这个指令之前，需要 stash 或者 commit 暂存区和⼯作区的更改。\n\n\n从⽂件层⾯来说：\n\ngit reset 只是把⽂件从历史记录区拿到暂存区，不影响⼯作区的内容，⽽且不⽀持 –mixed、–soft 和 –hard。\ngit checkout 则是把⽂件从历史记录拿到⼯作区，不影响暂存区的内容。\ngit revert 不⽀持⽂件层⾯的操作。\n\ngit push👑 $ git push\n# 致命错误：当前分支 hotfix&#x2F;master 没有对应的上游分支。\n# 为推送当前分支并建立与远程上游的跟踪，使用\n\n#  git push --set-upstream origin hotfix&#x2F;master&#96;\n\n# 为了让没有追踪上游的分支自动配置，参见 git help config 中的 push.autoSetupRemote。\n\n# 👑 $ git push --set-upstream origin hotfix&#x2F;master\n# 枚举对象中: 32, 完成.\n# 对象计数中: 100% (32&#x2F;32), 完成.\n# 使用 4 个线程进行压缩\n# 压缩对象中: 100% (17&#x2F;17), 完成.\n# 写入对象中: 100% (20&#x2F;20), 125.66 KiB | 289.00 KiB&#x2F;s, 完成.\n# 总共 20（差异 12），复用 0（差异 0），包复用 0\n# remote: Resolving deltas: 100% (12&#x2F;12), completed with 10 local objects.\n# remote:\n# remote: Create a pull request for hotfix&#x2F;master on GitHub by visiting:\n# remote: https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;page-skeleton-webpack-plugin&#x2F;pull&#x2F;new&#x2F;hotfix&#x2F;master\n# remote:\n# To github.com:841660202&#x2F;page-skeleton-webpack-plugin.git\n\n# - [new branch] hotfix&#x2F;master -&gt; hotfix&#x2F;master\n#   分支 hotfix&#x2F;master 设置为跟踪 origin&#x2F;hotfix&#x2F;master。\n\n# 从 git 2.37.0 开始，现在可以通过 git 配置实现。\n\n# 运行以更新您的配置：\n\ngit config --global --add --bool push.autoSetupRemote true\n\n# 然后git push将自动设置远程分支。\n\n# 注意：该--global标志意味着这将适用于您机器上的所有 git 命令（无论它是哪个 repo），您可以省略该标志以使其特定于您机器上的单个 repo。\n\n测试一下# 👑 $ git checkout -b hotfix&#x2F;master-test\n# 切换到一个新分支 &#39;hotfix&#x2F;master-test&#39;\n# 👑 $ git push\n# 总共 0（差异 0），复用 0（差异 0），包复用 0\n# remote:\n# remote: Create a pull request for &#39;hotfix&#x2F;master-test&#39; on GitHub by visiting:\n# remote:      https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;page-skeleton-webpack-plugin&#x2F;pull&#x2F;new&#x2F;hotfix&#x2F;master-test\n# remote:\n# To github.com:841660202&#x2F;page-skeleton-webpack-plugin.git\n#  * [new branch]      hotfix&#x2F;master-test -&gt; hotfix&#x2F;master-test\n# 分支 &#39;hotfix&#x2F;master-test&#39; 设置为跟踪 &#39;origin&#x2F;hotfix&#x2F;master-test&#39;。\n\n参考链接见\n","slug":"2023-02-04工程化","date":"2023-02-04T12:29:26.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"576f5f9f7495f386a7a9eae5a3e0ede8","title":"vscode md 有序列表技巧","content":"背景有时候，需要把无序列表改为有序列表，手动一个一个改太麻烦了，曾经一度想写个插件进行自动化处理，今天无意中发现，有个骚操作\n操作\n将无序列表批量改为有序\n将下面段落选中，进行批量后移\n再批量前移恢复下\n这样序号就自动生成好了\n\n\n\n更狠的操作将上述操作的 2 去掉，简化掉一步\n\n将无序列表批量改为有序\n批量前移恢复下\n这样序号就自动生成好了\n\n更更狠的操作\n将无序列表批量改为有序\n序号不连续行前移恢复下（后续编号自动编号）\n\n\n\n快捷键操作option + cmd + 上/下\n见：2022-09-17vscode-shortcuts\n","slug":"2023-02-03vs-md","date":"2023-02-03T08:02:14.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"55bae55fcf20ed40c2c35c2a5ff7ce4f","title":"混乱库处理","content":"ahooksimport &#123; useMemoizedFn &#125; from &quot;ahooks&quot;;\n&#x2F;&#x2F;社区存在ahooks-v2版本，导致无法，无法使用，新增一个私有仓库v3版本，不去更改历史版本\nimport &#123; usePersistFn &#125; from &quot;ahooks-v2&quot;;\n\n&#x2F;&#x2F; v2版本，依赖的库和项目历史代码的ahooks是v2版本\nimport &#123; useMemoizedFn &#125; from &quot;@tuya-fe&#x2F;ahooks-v3&quot;;\n\nantd&#x2F;&#x2F; @tuya-fe&#x2F;sun是antd的私有化，不同项目，有的用@tuya-fe&#x2F;sun，有的用antd，代码复用时候产生多语言失效的问题\nimport &#123; ConfigProvider &#125; from &quot;@tuya-fe&#x2F;sun&quot;;\nimport &#123; ConfigProvider as AntdConfigProvider &#125; from &quot;antd&quot;;\n\n&lt;AntdConfigProvider locale&#x3D;&#123;zhCN&#125;&gt;\n  &lt;ConfigProvider locale&#x3D;&#123;zhCN&#125;&gt;\n    &#123;&#x2F;* ... *&#x2F;&#125;\n    &#123;&#x2F;* children *&#x2F;&#125;\n    &#123;&#x2F;* ... *&#x2F;&#125;\n  &lt;&#x2F;ConfigProvider&gt;\n&lt;&#x2F;AntdConfigProvider&gt;;\n","slug":"2023-01-31antd","date":"2023-01-31T02:25:33.000Z","categories_index":"前端","tags_index":"前端","author_index":"举手摘月亮"},{"id":"87960c0852e545c2c12901d0c42ef062","title":"组件库UMD产物","content":"背景有些组件库（公司 wiki 库）依赖项，非常多，编译速度巨慢，如果能够像 echarts 一样，使用 script 标签引入，这样无需编译，浏览器还有缓存可以利用，开发体验非常可观\n一直以来在想打 umd 产物的包，以解决上述问题，没时间～，我今天又揽活了，什么时候能改掉这个坏毛病\ndumi -&gt; father见\n构建 UMD 产物如何选择只有在满足如下任意条件的情况下，才需要选择输出 UMD 产物：\n\n项目的用户可能需要将该依赖做 external 处理、并在 HTML 中通过 script 标签直接引入 CDN 上的产物（类似 React 或 antd）\n项目需要产出编译后的样式表给用户使用，例如将 Less 文件以特定的变量编译成 CSS 文件，常见于基于 antd、又需要自定义主题的组件库\n\n如何构建只需要使用 umd 配置项，再执行 father build 即可产出 UMD 产物：\n&#x2F;&#x2F; .fatherrc.js\nexport default &#123;\n  &#x2F;&#x2F; 以下为 umd 配置项启用时的默认值，有自定义需求时才需配置\n  umd: &#123;\n    entry: &quot;src&#x2F;index&quot;, &#x2F;&#x2F; 默认构建入口文件\n  &#125;,\n&#125;;\n\n更多配置项可参考 配置项\n在 father 项目中，UMD 产物以 Bundle 模式进行构建，关于 Bundle 模式的介绍可参考 构建模式 - Bundle\nwebpack见\n见\nwebpack.dev.config.js&#x2F;&#x2F; webpack.dev.config.js\nconst path &#x3D; require(&quot;path&quot;);\nconst config &#x3D; require(&quot;.&#x2F;webpack.config&quot;);\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);\n\nconst &#123; merge &#125; &#x3D; require(&quot;webpack-merge&quot;);\n\nmodule.exports &#x3D; merge(config, &#123;\n  mode: &quot;development&quot;,\n  entry: path.resolve(&quot;.&#x2F;src&#x2F;demo.tsx&quot;),\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      filename: &quot;index.html&quot;,\n      template: path.resolve(&quot;.&#x2F;index.html&quot;),\n    &#125;),\n  ],\n&#125;);\n\nwebpack.prod.config.js&#x2F;&#x2F; webpack.prod.config.js\nconst config &#x3D; require(&quot;.&#x2F;webpack.config&quot;);\nconst path &#x3D; require(&quot;path&quot;);\nconst &#123; merge &#125; &#x3D; require(&quot;webpack-merge&quot;);\n&#x2F;&#x2F; 进度条\nconst ProgressBarPlugin &#x3D; require(&quot;progress-bar-webpack-plugin&quot;);\nmodule.exports &#x3D; merge(config, &#123;\n  mode: &quot;production&quot;,\n  output: &#123;\n    library: &quot;wikiUI&quot;,\n    libraryTarget: &quot;umd&quot;,\n    libraryExport: &quot;default&quot;,\n    path: path.join(process.cwd(), &quot;lib&quot;),\n    filename: &quot;index.js&quot;,\n  &#125;,\n  plugins: [\n    &#x2F;&#x2F; 进度条\n    new ProgressBarPlugin(),\n  ],\n&#125;);\n\nwebpack.config.js&#x2F;&#x2F; webpack.config.js\nconst webpack &#x3D; require(&quot;webpack&quot;);\nconst path &#x3D; require(&quot;path&quot;);\nconst MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;);\n\nmodule.exports &#x3D; &#123;\n  mode: &quot;development&quot;,\n  entry: path.resolve(&quot;.&#x2F;src&#x2F;index.ts&quot;),\n  plugins: [new MiniCssExtractPlugin()],\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.(ts|tsx)$&#x2F;,\n        loader: &quot;babel-loader&quot;,\n        include: [path.resolve(__dirname, &quot;..&#x2F;src&quot;)],\n        exclude: [&quot;&#x2F;node_modules&#x2F;&quot;],\n      &#125;,\n      &#123;\n        test: &#x2F;.(sa|sc|c)ss$&#x2F;,\n        use: [\n          &#123;\n            loader: MiniCssExtractPlugin.loader,\n          &#125;,\n          &#123;\n            loader: &quot;css-loader&quot;,\n            options: &#123;\n              sourceMap: true,\n            &#125;,\n          &#125;,\n          &#123;\n            loader: &quot;sass-loader&quot;,\n            options: &#123;\n              sourceMap: true,\n            &#125;,\n          &#125;,\n        ],\n      &#125;,\n      &#123;\n        test: &#x2F;.(le)ss$&#x2F;,\n        use: [\n          &#123;\n            loader: MiniCssExtractPlugin.loader,\n          &#125;,\n          &#123;\n            loader: &quot;css-loader&quot;,\n            options: &#123;\n              sourceMap: true,\n            &#125;,\n          &#125;,\n          &#123;\n            loader: &quot;less-loader&quot;,\n            options: &#123;\n              sourceMap: true,\n              lessOptions: &#123;\n                javascriptEnabled: true,\n              &#125;,\n            &#125;,\n          &#125;,\n        ],\n      &#125;,\n      &#123;\n        test: &#x2F;\\.(woff(2)?|ttf|eot|svg)(\\?v&#x3D;\\d+\\.\\d+\\.\\d+)?$&#x2F;,\n        use: [\n          &#123;\n            loader: &quot;file-loader&quot;,\n            options: &#123;\n              name: &quot;[name].[ext]&quot;,\n              outputPath: &quot;fonts&#x2F;&quot;,\n            &#125;,\n          &#125;,\n        ],\n      &#125;,\n    ],\n  &#125;,\n  resolve: &#123;\n    alias: &#123;\n      &quot;@&quot;: path.resolve(__dirname, &quot;..&#x2F;src&#x2F;&quot;),\n    &#125;,\n    extensions: [&quot;.tsx&quot;, &quot;.ts&quot;, &quot;.js&quot;],\n  &#125;,\n&#125;;\n\nviteInvalid value &quot;umd&quot; for option &quot;output.format&quot; - UMD and IIFE output formats are not supported for code-splitting builds.\n中心组件库webpack 模块联邦\n见：2023-02-04 工程化\n","slug":"2023-01-29umd","date":"2023-01-29T03:32:23.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"5fabc47ffe883306098d02d0d23becda","title":"React Refs","content":"Refs &amp; DOM\n为 DOM 元素添加 ref\n为 class 组件添加 Ref\nRefs 与函数组件\n\n默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例\n如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativeHandle 结合使用），或者可以将该组件转化为 class 组件。\n将 DOM Refs 暴露给父元素有版本限制：16.3 或更高版本的 React\nRefs 转发： Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref\nRefs 转发\nrefs 将不会透传下去。这是因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。\n可以使用 React.forwardRef API 明确地将 refs 转发到内部的 FancyButton 组件。React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点\n第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref\n可以设置函数的 displayName 属性来包含被包裹组件的名称, 在 DevTools 中显示自定义名称\n使用 forwardRef 时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本\n\n参考链接Refs and the DOM\nRefs 转发\n","slug":"2023-01-28refs","date":"2023-01-28T05:36:24.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"4a39cce638cfb347201792d2fa0ff3a8","title":"Map & Set & Object","content":"MapMap 的特点\n有序： Map 对象保存键值对，并且能够记住键的原始插入顺序。\n键值随意：任何值（对象或者基本类型）都可以作为一个键或一个值。\nMap 对象是键值对的集合。\n键唯一：Map 中的一个键只能出现一次；它在 Map 的集合中是独一无二的。\n可迭代：Map 对象按键值对迭代——一个 for…of 循环在每次迭代后会返回一个形式为 [key，value] 的数组。\n迭代按插入顺序进行，即键值对按 set() 方法首次插入到集合中的顺序（也就是说，当调用 set() 时，map 中没有具有相同值的键）进行迭代。\n线性关系：平均访问时间与集合中的元素数量呈次线性关系\n可与二维数组互转\n\n二维数组转化\n将 NaN 作为 Map 的键, 所有 NAN 键相同\n使用 for...of 方法迭代 Map， 使用 forEach() 方法迭代 Map\nMap 与数组的关系(二维键值对数组 / Map 对象 使用 Array.from  -&gt; 二维键值对数组 )\n合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的。(展开语法本质上是将 Map 对象转换成数组)\n\n键的相等键的比较基于零值相等算法。（它曾经使用同值相等，将 0 和 -0 视为不同。检查浏览器兼容性。）这意味着 NaN 是与 NaN 相等的（虽然 NaN !&#x3D;&#x3D; NaN），剩下所有其它的值是根据 &#x3D;&#x3D;&#x3D; 运算符的结果判断是否相等。\nObject 和 Map 的比较相同点Object 和 Map 类似的是，按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Map 使用\n不同点\n\n\n\nMap\nObject\n\n\n\n意外的键\nMap 默认情况不包含任何键。只包含显式插入的键。\n一个 Object 有一个原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。\n\n\n键的类型\n一个 Map 的键可以是任意值，包括函数、对象或任意基本类型。\n一个 Object 的键必须是一个 String 或是 Symbol。\n\n\n键的顺序\nMap 中的键是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。\n虽然 Object 的键目前是有序的，但并不总是这样，而且这个顺序是复杂的。因此，最好不要依赖属性的顺序。\n\n\nSize\nMap 的键值对个数可以轻易地通过 size 属性获取。\nObject 的键值对个数只能手动计算。\n\n\n迭代\nMap 是 可迭代的 的，所以可以直接被迭代。\nObject 没有实现 迭代协议，所以使用 JavaSctipt 的 for…of 表达式并不能直接迭代对象。\n\n\n性能\n在频繁增删键值对的场景下表现更好。\n在频繁添加和删除键值对的场景下未作出优化。\n\n\n序列化和解析\n没有元素的序列化和解析的支持。\n原生的由 Object 到 JSON 的序列化支持，使用 JSON.stringify()。\n\n\nWeakMap\nWeakMap 是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。\nWeakMap 弱引用的只是键名，而不是键值，键值依然是正常使用的。\n\nWeakMap 特点\n只接受对象作为键名\n键名是弱引用，可以被垃圾回收\n不可遍历\nAPI 和 Map 相同\n\nMap api\nnew Map()—— 创建 map。\nmap.set(key, value)—— 根据键存储值。\nmap.get(key)—— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。\nmap.has(key)—— 如果 key 存在则返回 true，否则返回 false。\nmap.delete(key)—— 删除指定键的值。\nmap.clear()—— 清空 map。\nmap.size—— 返回当前元素个数。\nkeys values entries forEach\n\nSet（集合）Set 与 Map 类似，是一组 Key 的集合，但不存储 Value，由于 Key 不能重复，因此他最大的特点是所有的元素都是唯一的。\n\nnew Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里- 面复制值到 set 中。\nset.add(value) —— 添加一个值，返回 set 本身\nset.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。\nset.clear() —— 清空 set。\nset.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。\nset.size —— 返回元素个数。\n\n参考链接总结 ES6 中 Map 和 Set 的特点与比较\nMap\n","slug":"2023-01-21map&set","date":"2023-01-21T06:48:19.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"8a2b4fbe9c65dfb47fc690fa692de0b8","title":"position sticky 失效了","content":"原理sticky\n\n元素根据正常文档流进行定位，\n然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block（最近块级祖先 nearest block-level ancestor），包括 table-related 元素，基于 top、right、bottom 和 left 的值进行偏移。\n偏移值不会影响任何其他元素的位置。 该值总是创建一个新的层叠上下文（stacking context）。\n注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见 Github issue on W3C CSSWG）。\n\ntab图\n\n代码position: sticky;\ntop: 206px;\nz-index: 8;\nbackground: #fff;\n\nant table 表头图\n\n代码overflow: hidden;\nposition: sticky;\ntop: 268px; &#x2F;*此值需要动态计算 *&#x2F;\n&#x2F;* background: orange; *&#x2F;\nz-index: 8;\n\nsetting icon图\n\n代码right: 9px;\ntransform: translateY(55px);\nposition: absolute;\nwidth: 50px;\nheight: 36px;\nbackground: orange;\nfont-size: 12px;\n\n这个 icon 不可放到 table 的表头进行sticky定位，原因是：垂直方向是 ok 的，水平存在滚动，并不适合\nsetting icon 组件暴露到外部\n\n\n\n问题：\nsetting icon 控制表头字段展示，setting 取自上下文如下：\ntable context 并没有暴露到外部业务中，所以不能将 setting 组件直接放到 context 外部\n业务中 tab 切换 、table 的表头和 setting组件 又必须渲染到同一的 BFC，否则 sticky 不生效\n\n方案 1:将 table context 做整个 detail 页面的 context，改动很大，有一定的工作量，并且可能造成其他 bug\n方案 2（简单）:将有 table context 装配完的 setting 组件暴露到外部，作为函数的参数用到 detail 顶级组件中进行渲染，使 tab 切换 、table 的表头和 setting组件满足position: sticky的生效条件 见\n最后 useRefSize\n上面是手动调的的样式不具备灵活性\nahooks 使用 useSize 可以计算元素高度，使用时候二次封装下，将 useRef 和 useSize 封装为一个 useRefSize\n对于复杂的结构，可能需要结合css-in-js实现, 动态样式类的计算\n\n&#x2F;&#x2F; use-ref-size.ts\nimport &#123; useSize &#125; from &quot;ahooks&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\n\ntype Size &#x3D; &#123;\n  width?: number;\n  height?: number;\n&#125;;\n\nexport const useRefSize &#x3D; () &#x3D;&gt; &#123;\n  const ref &#x3D; useRef(null);\n  const size &#x3D; useSize(ref);\n  return [ref, size as Size] as const;\n&#125;;\n\n&#x2F;** @jsxRuntime classic *&#x2F;\n&#x2F;** @jsx jsx *&#x2F;\n&#x2F;** @jsxFrag React.Fragment *&#x2F;\nimport &#123; css, jsx &#125; from &quot;@emotion&#x2F;react&quot;;\n&#x2F;&#x2F; ...\n&lt;div\n  css&#x3D;&#123;css&#96;\n    padding: 0 20px;\n    width: $&#123;ContainerSize.width&#125;px;\n    .ant-table-container .ant-table-header &#123;\n      overflow: hidden;\n      position: sticky;\n      top: $&#123;pos_setting_top&#125;px;\n      z-index: 8;\n    &#125;\n  &#96;&#125;\n&gt;\n  &#123;&#x2F;* .... *&#x2F;&#125;\n&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; ....\n","slug":"2023-01-19sticky","date":"2023-01-19T09:22:16.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"举手摘月亮"},{"id":"b4cbd5b4715b471baee9e1ca3749d21c","title":"有时效性的get请求缓存","content":"背景\n避免相同 GET 请求重复发送，占用网络资源\n将数据在 service 曾进行缓存\n\n为什么是 service 层原因： 在 store 或者 context 进行缓存，处理起来麻烦，比较分散，不易维护\n思路\n闭包进行缓存\n相同get请求、有效时间内不发起请求,非 get 请求缓存没有意义\n有缓存用缓存，无缓存发请求，更新缓存\n\nts 源码type IParams &#x3D; Record&lt;string, any&gt;;\n\ninterface IGetOption &#123;\n  method: &quot;Get&quot;;\n  api: string;\n  params?: IParams;\n&#125;\n&#x2F;**\n * 使用method、api、params 生成唯一key,作为缓存的键\n * @param options\n * @returns\n *&#x2F;\nfunction genGetApiCacheKey(options: IGetOption) &#123;\n  const paramsPath &#x3D; formGetQueryParams(options.params || &#123;&#125;);\n\n  let _paramsPath &#x3D; paramsPath ? &#96;?$&#123;paramsPath&#125;&#96; : &quot;&quot;;\n\n  return &#96;$&#123;options.method || &quot;Get&quot;&#125; $&#123;options.api&#125;$&#123;_paramsPath&#125;&#96;;\n&#125;\n&#x2F;**\n *  格式get请求的查询数据\n * @param params\n * @returns\n *&#x2F;\nfunction formGetQueryParams(params: IParams) &#123;\n  const queryParams &#x3D; Object.keys(params)\n    .map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)\n    .join(&quot;&amp;&quot;);\n  return queryParams;\n&#125;\n&#x2F;**\n * 扩展Date方法 TODO 有点问题\n *&#x2F;\ninterface Date &#123;\n  add: (n: number, type: &quot;s&quot; | &quot;m&quot; | &quot;h&quot;) &#x3D;&gt; any;\n&#125;\n&#x2F;&#x2F; @ts-ignore\nDate.prototype.add &#x3D; function (n, type) &#123;\n  let timestamp &#x3D; this.getTime();\n\n  switch (type) &#123;\n    case &quot;s&quot;:\n      timestamp &#x3D; timestamp + n * 1000;\n      break;\n\n    case &quot;m&quot;:\n      timestamp &#x3D; timestamp + n * 60 * 1000;\n      break;\n\n    case &quot;h&quot;:\n      timestamp &#x3D; timestamp + n * 60 * 60 * 1000;\n      break;\n\n    default:\n      throw new Error(&quot;need type&quot;);\n  &#125;\n  return timestamp;\n&#125;;\n&#x2F;**\n * 检测时间是否有效\n * @param expire\n * @param now\n * @returns\n *&#x2F;\nfunction isValid(\n  lastTimeStamp,\n  diff &#x3D; 3.5,\n  type &#x3D; &quot;s&quot;,\n  now &#x3D; new Date().getTime()\n) &#123;\n  const valid &#x3D;\n    &#x2F;&#x2F; @ts-ignore\n    lastTimeStamp &amp;&amp; new Date(lastTimeStamp).add(diff, type).valueOf() &gt; now;\n\n  console.log(&quot;valid&quot;, valid);\n  return valid;\n&#125;\n&#x2F;**\n * 模拟请求数据\n * @param params\n * @returns\n *&#x2F;\nfunction mockApiBack(params: any) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(&#123; success: true, result: params &#125;);\n    &#125;, 500);\n  &#125;);\n&#125;\n&#x2F;**\n * 使用闭包进行数据缓存，刷新后缓存会销毁重建\n * @returns\n *&#x2F;\nexport const getCacheFunc &#x3D; () &#x3D;&gt; &#123;\n  const CACHEOBJ &#x3D; &#123;&#125;;\n\n  return (options: IGetOption) &#x3D;&gt; &#123;\n    console.log(&quot;options&quot;, options);\n\n    const cacheKey &#x3D; genGetApiCacheKey(options);\n\n    let result &#x3D; CACHEOBJ[cacheKey];\n    console.log(&quot;CACHEOBJ&quot;, CACHEOBJ);\n    if (!result || !isValid(result.timestamp)) &#123;\n      console.log(&quot;缓存失效，接口获取&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, cacheKey);\n      return mockApiBack(options).then((res: any) &#x3D;&gt; &#123;\n        CACHEOBJ[cacheKey] &#x3D; &#123;\n          ...res,\n          timestamp: new Date().getTime(),\n        &#125;;\n        result &#x3D; CACHEOBJ[cacheKey];\n        return result;\n      &#125;);\n    &#125; else &#123;\n      console.log(&quot;读缓存数据&quot;);\n      return new Promise((resolve) &#x3D;&gt; resolve(result));\n    &#125;\n  &#125;;\n&#125;;\n\nexport const getApiWithCache &#x3D; getCacheFunc();\n\n&#x2F;&#x2F; 测试数据\ngetApiWithCache(&#123; method: &quot;Get&quot;, api: &quot;&#x2F;hello&quot; &#125;);\ngetApiWithCache(&#123; method: &quot;Get&quot;, api: &quot;&#x2F;hello&#x2F;world&quot; &#125;);\n\nlet h &#x3D; setInterval(async () &#x3D;&gt; &#123;\n  const d &#x3D; await getApiWithCache(&#123;\n    method: &quot;Get&quot;,\n    api: &quot;&#x2F;hello&quot;,\n    params: &#123; name: 1, age: 2 &#125;,\n  &#125;);\n  console.log(&quot;d&quot;, d);\n&#125;, 1000 * 1);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  clearInterval(h);\n&#125;, 1000 * 4);\n\n编译产出 js&quot;use strict&quot;;\nvar __awaiter &#x3D;\n  (this &amp;&amp; this.__awaiter) ||\n  function (thisArg, _arguments, P, generator) &#123;\n    function adopt(value) &#123;\n      return value instanceof P\n        ? value\n        : new P(function (resolve) &#123;\n            resolve(value);\n          &#125;);\n    &#125;\n    return new (P || (P &#x3D; Promise))(function (resolve, reject) &#123;\n      function fulfilled(value) &#123;\n        try &#123;\n          step(generator.next(value));\n        &#125; catch (e) &#123;\n          reject(e);\n        &#125;\n      &#125;\n      function rejected(value) &#123;\n        try &#123;\n          step(generator[&quot;throw&quot;](value));\n        &#125; catch (e) &#123;\n          reject(e);\n        &#125;\n      &#125;\n      function step(result) &#123;\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected);\n      &#125;\n      step((generator &#x3D; generator.apply(thisArg, _arguments || [])).next());\n    &#125;);\n  &#125;;\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;);\nexports.getApiWithCache &#x3D; exports.getCacheFunc &#x3D; void 0;\n&#x2F;**\n * 使用method、api、params 生成唯一key,作为缓存的键\n * @param options\n * @returns\n *&#x2F;\nfunction genGetApiCacheKey(options) &#123;\n  const paramsPath &#x3D; formGetQueryParams(options.params || &#123;&#125;);\n  let _paramsPath &#x3D; paramsPath ? &#96;?$&#123;paramsPath&#125;&#96; : &quot;&quot;;\n  return &#96;$&#123;options.method || &quot;Get&quot;&#125; $&#123;options.api&#125;$&#123;_paramsPath&#125;&#96;;\n&#125;\n&#x2F;**\n *  格式get请求的查询数据\n * @param params\n * @returns\n *&#x2F;\nfunction formGetQueryParams(params) &#123;\n  const queryParams &#x3D; Object.keys(params)\n    .map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)\n    .join(&quot;&amp;&quot;);\n  return queryParams;\n&#125;\n&#x2F;&#x2F; @ts-ignore\nDate.prototype.add &#x3D; function (n, type) &#123;\n  let timestamp &#x3D; this.getTime();\n  switch (type) &#123;\n    case &quot;s&quot;:\n      timestamp &#x3D; timestamp + n * 1000;\n      break;\n    case &quot;m&quot;:\n      timestamp &#x3D; timestamp + n * 60 * 1000;\n      break;\n    case &quot;h&quot;:\n      timestamp &#x3D; timestamp + n * 60 * 60 * 1000;\n      break;\n    default:\n      throw new Error(&quot;need type&quot;);\n  &#125;\n  return timestamp;\n&#125;;\n&#x2F;**\n * 检测时间是否有效\n * @param expire\n * @param now\n * @returns\n *&#x2F;\nfunction isValid(\n  lastTimeStamp,\n  diff &#x3D; 3.5,\n  type &#x3D; &quot;s&quot;,\n  now &#x3D; new Date().getTime()\n) &#123;\n  const valid &#x3D;\n    &#x2F;&#x2F; @ts-ignore\n    lastTimeStamp &amp;&amp; new Date(lastTimeStamp).add(diff, type).valueOf() &gt; now;\n  console.log(&quot;valid&quot;, valid);\n  return valid;\n&#125;\n&#x2F;**\n * 模拟请求数据\n * @param params\n * @returns\n *&#x2F;\nfunction mockApiBack(params) &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(&#123; success: true, result: params &#125;);\n    &#125;, 500);\n  &#125;);\n&#125;\n&#x2F;**\n * 使用闭包进行数据缓存，刷新后缓存会销毁重建\n * @returns\n *&#x2F;\nconst getCacheFunc &#x3D; () &#x3D;&gt; &#123;\n  const CACHEOBJ &#x3D; &#123;&#125;;\n  return (options) &#x3D;&gt; &#123;\n    console.log(&quot;options&quot;, options);\n    const cacheKey &#x3D; genGetApiCacheKey(options);\n    let result &#x3D; CACHEOBJ[cacheKey];\n    console.log(&quot;CACHEOBJ&quot;, CACHEOBJ);\n    if (!result || !isValid(result.timestamp)) &#123;\n      console.log(&quot;缓存失效，接口获取&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, cacheKey);\n      return mockApiBack(options).then((res) &#x3D;&gt; &#123;\n        CACHEOBJ[cacheKey] &#x3D; Object.assign(Object.assign(&#123;&#125;, res), &#123;\n          timestamp: new Date().getTime(),\n        &#125;);\n        result &#x3D; CACHEOBJ[cacheKey];\n        return result;\n      &#125;);\n    &#125; else &#123;\n      console.log(&quot;读缓存数据&quot;);\n      return new Promise((resolve) &#x3D;&gt; resolve(result));\n    &#125;\n  &#125;;\n&#125;;\nexports.getCacheFunc &#x3D; getCacheFunc;\nexports.getApiWithCache &#x3D; (0, exports.getCacheFunc)();\n&#x2F;&#x2F; 测试数据\n(0, exports.getApiWithCache)(&#123; method: &quot;Get&quot;, api: &quot;&#x2F;hello&quot; &#125;);\n(0, exports.getApiWithCache)(&#123; method: &quot;Get&quot;, api: &quot;&#x2F;hello&#x2F;world&quot; &#125;);\nlet h &#x3D; setInterval(\n  () &#x3D;&gt;\n    __awaiter(void 0, void 0, void 0, function* () &#123;\n      const d &#x3D; yield (0, exports.getApiWithCache)(&#123;\n        method: &quot;Get&quot;,\n        api: &quot;&#x2F;hello&quot;,\n        params: &#123; name: 1, age: 2 &#125;,\n      &#125;);\n      console.log(&quot;d&quot;, d);\n    &#125;),\n  1000 * 1\n);\nsetTimeout(() &#x3D;&gt; &#123;\n  clearInterval(h);\n&#125;, 1000 * 4);\n\n测试数据&#x2F;*\noptions &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39; &#125;\nCACHEOBJ &#123;&#125;\n缓存失效，接口获取&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Get &#x2F;hello\noptions &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#x2F;world&#39; &#125;\nCACHEOBJ &#123;&#125;\n缓存失效，接口获取&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Get &#x2F;hello&#x2F;world\noptions &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: &#123; name: 1, age: 2 &#125; &#125;\nCACHEOBJ &#123;\n  &#39;Get &#x2F;hello&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39; &#125;,\n    timestamp: 1674116758429\n  &#125;,\n  &#39;Get &#x2F;hello&#x2F;world&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#x2F;world&#39; &#125;,\n    timestamp: 1674116758429\n  &#125;\n&#125;\n缓存失效，接口获取&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Get &#x2F;hello?name&#x3D;1&amp;age&#x3D;2\nd &#123;\n  success: true,\n  result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: &#123; name: 1, age: 2 &#125; &#125;,\n  timestamp: 1674116759431\n&#125;\noptions &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: &#123; name: 1, age: 2 &#125; &#125;\nCACHEOBJ &#123;\n  &#39;Get &#x2F;hello&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39; &#125;,\n    timestamp: 1674116758429\n  &#125;,\n  &#39;Get &#x2F;hello&#x2F;world&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#x2F;world&#39; &#125;,\n    timestamp: 1674116758429\n  &#125;,\n  &#39;Get &#x2F;hello?name&#x3D;1&amp;age&#x3D;2&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: [Object] &#125;,\n    timestamp: 1674116759431\n  &#125;\n&#125;\nvalid true\n读缓存数据\nd &#123;\n  success: true,\n  result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: &#123; name: 1, age: 2 &#125; &#125;,\n  timestamp: 1674116759431\n&#125;\noptions &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: &#123; name: 1, age: 2 &#125; &#125;\nCACHEOBJ &#123;\n  &#39;Get &#x2F;hello&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39; &#125;,\n    timestamp: 1674116758429\n  &#125;,\n  &#39;Get &#x2F;hello&#x2F;world&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#x2F;world&#39; &#125;,\n    timestamp: 1674116758429\n  &#125;,\n  &#39;Get &#x2F;hello?name&#x3D;1&amp;age&#x3D;2&#39;: &#123;\n    success: true,\n    result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: [Object] &#125;,\n    timestamp: 1674116759431\n  &#125;\n&#125;\nvalid true\n读缓存数据\nd &#123;\n  success: true,\n  result: &#123; method: &#39;Get&#39;, api: &#39;&#x2F;hello&#39;, params: &#123; name: 1, age: 2 &#125; &#125;,\n  timestamp: 1674116759431\n&#125;\n*&#x2F;\n\n编译指令tsc --module commonjs --target es2015 -w getCacheApi.ts\n\n执行指令node getCacheApi.js\n\nother 柯里化缓存export function cacheRequestHelper&lt;T &#x3D; any&gt;(): (\n  api: (...e: any) &#x3D;&gt; Promise&lt;T&gt;\n) &#x3D;&gt; (...e: any) &#x3D;&gt; Promise&lt;T&gt; &#123;\n  const fnMapper &#x3D; new Map();\n  const observer &#x3D; &#123;\n    subscribe: (key: any, fn) &#x3D;&gt; &#123;\n      const e &#x3D; fnMapper.get(key);\n      if (e) &#123;\n        e.push(fn);\n      &#125; else &#123;\n        fnMapper.set(key, [fn]);\n      &#125;\n    &#125;,\n    publish: (key: any, res) &#x3D;&gt; &#123;\n      const e &#x3D; fnMapper.get(key) || [];\n      e.map((fn) &#x3D;&gt; &#123;\n        fn.call(null, res);\n      &#125;);\n    &#125;,\n  &#125;;\n\n  const mapper &#x3D; new Map&lt;\n    any,\n    &#123;\n      result?: any;\n      fetched: boolean;\n      key: any;\n      expire?: number;\n    &#125;\n  &gt;();\n\n  function getInfo(args) &#123;\n    const keys &#x3D; Array.from(mapper.keys());\n    const key &#x3D; keys.find((item) &#x3D;&gt; &#123;\n      if (isEqual(item, args)) &#123;\n        return true;\n      &#125;\n    &#125;);\n    return mapper.get(key);\n  &#125;\n\n  return (api) &#x3D;&gt; &#123;\n    return (...args) &#x3D;&gt; &#123;\n      const info &#x3D; getInfo(args);\n      &#x2F;&#x2F; 有缓存数据\n      if (info?.result) &#123;\n        return Promise.resolve(info.result);\n      &#125;\n      &#x2F;&#x2F; 无缓存数据\n      if (!info) &#123;\n        mapper.set(args, &#123;\n          fetched: true,\n          key: args,\n        &#125;);\n        return api.apply(null, args).then((res) &#x3D;&gt; &#123;\n          const v &#x3D; mapper.get(args);\n          if (v) &#123;\n            v.result &#x3D; res;\n          &#125; else &#123;\n            mapper.set(args, &#123;\n              fetched: true,\n              result: res,\n              key: args,\n            &#125;);\n          &#125;\n          observer.publish(args, res);\n          return res;\n        &#125;);\n      &#125; else &#123;\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n          observer.subscribe(info.key, (res) &#x3D;&gt; &#123;\n            resolve(res);\n          &#125;);\n        &#125;);\n      &#125;\n    &#125;;\n  &#125;;\n&#125;\n","slug":"2023-01-19cache-get","date":"2023-01-19T07:53:50.000Z","categories_index":"前端","tags_index":"前端","author_index":"举手摘月亮"},{"id":"d8a5a38f56ece9e327645046d92ea7a7","title":"unsafe when doing server-side rendering","content":"The pseudo class &quot;:first-child&quot; is potentially unsafe when doing server-side rendering. Try changing it to &quot;:first-of-type&quot;.\n","slug":"2023-01-19","date":"2023-01-19T02:29:52.000Z","categories_index":"Bug","tags_index":"Bug","author_index":"举手摘月亮"},{"id":"f9c9013232e633dee6d45a085d233636","title":"如何平衡工作、家庭与爱好","content":"近两年陷入了怪圈子工作、家庭、爱好、遗憾\n\n工作 - 家庭：因为和媳妇是两个城市，工作限制了生活\n工作 - 爱好：工作本与爱好不冲突，但是工作的技术让我很是焦虑，学的东西用不到工作中，导致学习并不能转化成产出，进而无法间接供养生活\n工作 - 遗憾：考研没调剂，工作后，发现很多工作在卡学历，晋升也在卡，想再考个，近期时间上却不允许\n爱好 - 遗憾：爱好是计算机相关，当时报考的是通信，不是我想要的学校不愿调剂\n\n怪圈子的结果焦虑 -&gt; 失眠 -&gt; 状态不好、效率低下 -&gt; 焦虑 -&gt; 失眠 -&gt; …\n如何平衡工作、家庭与爱好胡伟清：如何平衡工作、家庭与爱好\n怪圈子的突破点如果我有份好工作，和媳妇在同一个城市\n\n工作 - 家庭： 的问题可以得到很好的解决\n工作 - 爱好： 将爱好，学到的东西，回馈工作，间接供养生活\n工作 - 遗憾： 前两者可以为我获取更多的时间，让我能有机会结束掉这个遗憾，这样以后工作就不会被卡\n\n没有遗憾我不会做噩梦，工作好，生活好，有更多的学习机会和时间\n","slug":"2023-01-17平衡","date":"2023-01-17T08:50:28.000Z","categories_index":"复盘","tags_index":"复盘","author_index":"举手摘月亮"},{"id":"0c263a6ceabee21392cfc48173688588","title":"绩效面谈","content":"回顾绩效面谈领导说要和我聊下绩效，我当时正在写代码，直到绩效面谈完，我还陶醉在代码中，对此我觉得需要做复盘，平时做的再好，绩效面谈，谈不好，这是对自己一年来付出的否定，我觉得有愧于心\n绩效面谈该如何谈，谈些什么？\n谈工作业绩\n谈行为表现\n谈改进措施\n谈新的目标\n谈自己需求\n\n此次面谈，我是否达到了彼此的目的?参考链接见\n","slug":"2023-01-16绩效","date":"2023-01-16T14:11:26.000Z","categories_index":"复盘","tags_index":"复盘","author_index":"举手摘月亮"},{"id":"b3498ee5a2b2f029db82dac3e1ffd29e","title":"优化操作","content":"连续点击触发事件interface IUseSkipTimesToTriggerOptions &#123;\n  &#x2F;**该时间间隔内点击才算连续点击（单位：ms） *&#x2F;\n  waitTime: number;\n  &#x2F;**最大连续点击次数*&#x2F;\n  maxNum: number;\n&#125;\n\nexport function useSkipTimesToTrigger(\n  fn: () &#x3D;&gt; void,\n  options: IUseSkipTimesToTriggerOptions &#x3D; &#123;\n    waitTime: 500,\n    maxNum: 5,\n  &#125;\n) &#123;\n  let timer: NodeJS.Timeout | null &#x3D; null;\n  &#x2F;&#x2F; 连续点击次数\n  let num &#x3D; 0;\n  &#x2F;&#x2F; 上次的点击时间\n  let lastTime &#x3D; new Date().getTime();\n\n  return () &#x3D;&gt; &#123;\n    const &#123; waitTime, maxNum &#125; &#x3D; options;\n    const nowTime &#x3D; new Date().getTime();\n\n    if (nowTime - lastTime &lt; waitTime) &#123;\n      num++;\n    &#125; else &#123;\n      num &#x3D; 0;\n    &#125;\n\n    lastTime &#x3D; nowTime;\n\n    if (num &gt;&#x3D; maxNum) &#123;\n      timer &amp;&amp; clearTimeout(timer);\n      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n        fn?.();\n        num &#x3D; 0;\n      &#125;, 0);\n    &#125;\n  &#125;;\n&#125;\n\n延迟 loading请求事件发出后\n\n1 秒内收到响应，不展示 loading\n超 1 秒收到响应，展示 loading\n\n缓存数据1 秒内重复发起请求，走缓存，缓存失效走接口\n自动装配 useReducer","slug":"2023-01-16","date":"2023-01-16T02:52:47.000Z","categories_index":"特殊需求","tags_index":"特殊需求","author_index":"举手摘月亮"},{"id":"add62f7c2ac2bd1e3e86c3111f29bf73","title":"vscode terminal 闪退","content":"背景vscode 用着用着，突然闪退了，重启 vscode 后，发现 terminal 闪退，无法正常使用\n遇到过两次了，几个月前处理过一次，现在又来了，记录下\n闪退现象\n\n处理措施\n\n处理后结果\n\n问题原因应该由于某些原因，vscode 闪退，电脑配置被自动更改了\n参考链接见\n","slug":"2023-01-15vscode-terminal","date":"2023-01-15T10:53:15.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"af5b4141ce97df922bc94e2b5ce44d81","title":"react-beautiful-dnd 最优","content":"react-dnd react-smooth-dnd 优劣\nreact-dnd 功能更强大，react-smooth-dnd 稍逊\nreact-smooth-dnd 交互体验更优，但仅支持水平和垂直两种情况\nreact-smooth-dnd\n\n\n\n\n比较\n易用性\n交互体验\n拖拽方向\n功能\n看板\n文档\nstart\n支持 grid\n选型\n\n\n\nreact-sortablejs\n简单\n平滑\n水平&#x2F;垂直\n\n支持\n很烂\n1.6k\n支持\n\n\n\nreact-beautiful-dnd\n简单\n平滑\n水平&#x2F;垂直\n非常多\n支持\n非常多 demo\n29k\n不支持\n\n\n\nreact-dnd\n复杂 需 immutability-helper\n生硬\n水平&#x2F;垂直\n非常多\n支持\n有些\n19k\n支持\n\n\n\nreact-smooth-dnd\n简单\n平滑\n水平&#x2F;垂直\n够用\n支持\n有些\n1.7k\n不支持\n\n\n\nreact-sortablejs见\nhttps://github.com/SortableJS/Sortable\n\nhttps://github.com/SortableJS/react-sortablejs\n\ndemo\nreact-beautiful-dndhttps://github.com/atlassian/react-beautiful-dnd\n\n中文文档\n支持水平\nreact-dnddemo\nhttps://github.com/react-dnd/react-dnd\n\nreact-smooth-dnddemo\nhttps://github.com/kutlugsahin/react-smooth-dnd\n","slug":"2023-01-15dnd","date":"2023-01-15T03:16:49.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"1315e3c48aa42a2d8052782e37da350b","title":"sqltools","content":"Select your database driverstep1\n\nstep2\n\nstep3\n\nsql 查询\n","slug":"2023-01-14sqltools","date":"2023-01-14T03:55:16.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"bb851a23d0dc32b76a55f0e588564791","title":"postwoman","content":"postman 与 postwoman相比较而言 postman 功能更强大，交互设计更友好\n但是：好用不一定就适用postman 需要安装，脱离浏览器运行，那么如果是 cookie 校验的情况，需要手动操作，而 postwoman 是网页版的，浏览器会自动带上 cookie，省事\npostwoman\n","slug":"2023-01-13postwoman","date":"2023-01-13T07:45:33.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"bde1b6e957dca5aefd70ca7596a58c26","title":"ts","content":"object 与 Record 的区别object 不能接收原始类型，而 {} 和 Object 都可以，这是它们的区别。object 一般会用 Record 代替，约束索引类型更加语义化。\nkeyof any 有何特点keyof any 可以动态获取 key 支持的类型，根据 keyofStringsOnly 的编译选项，可以用来约束索引。\n-readonly、-?映射类型语法可以创建索引类型，并且加上 readonly 或 ? 的修饰，其实也可以用 -readonly、-? 去掉。\n函数重载NOTE\n当希望传 user 参数时，不传 flag，传 para 时，传 flag。就可以这样写：\ninterface User &#123;\n  name: string;\n  age: number;\n&#125;\n\nconst user &#x3D; &#123;\n  name: &quot;Jack&quot;,\n  age: 123,\n&#125;;\n\nclass SomeClass &#123;\n  public test(para: User): number;\n  public test(para: number, flag: boolean): number;\n\n  public test(para: User | number, flag?: boolean): number &#123;\n    &#x2F;&#x2F; 具体实现\n    return 1;\n  &#125;\n&#125;\n\nconst someClass &#x3D; new SomeClass();\n\n&#x2F;&#x2F; ok\nsomeClass.test(user);\nsomeClass.test(123, false);\n\n&#x2F;&#x2F; Error\n&#x2F;&#x2F; someClass.test(123);\n&#x2F;&#x2F;Argument of type &#39;number&#39; is not assignable to parameter of type &#39;User&#39;.\n&#x2F;&#x2F; someClass.test(user, false);\n&#x2F;&#x2F;Argument of type &#39;&#123; name: string; age: number; &#125;&#39; is not assignable to parameter of type &#39;number&#39;.\n\nPartial, Readonly, Nullable, Required\nPartial 将每个属性转换为可选属性\nReadonly 将每个属性转换为只读属性\nNullable 转换为旧类型和 null 的联合类型\nRequired 将每个属性转换为必选属性\n\nPick, Record\nPick 选取一组属性指定新类型\nRecord 创建一组属性指定新类型，常用来声明普通 Object 对象\n\nExclude, Omit\n用于联合类型 Exclude 去除交集，返回剩余的部分\n用于Record&lt;.,.&gt;类型 Omit 适用于键值对对象的 Exclude，去除类型中包含的键值对\n\nReturnType获取返回值类型，一般为函数\ninfer表示在 extends 条件语句中待推断的类型变量。\ninterface [key:string]: anyenum AnimalFlags &#123;\n  None &#x3D; 0,\n  HasClaws &#x3D; 1 &lt;&lt; 0,\n  CanFly &#x3D; 1 &lt;&lt; 1,\n  HasClawsOrCanFly &#x3D; HasClaws | CanFly,\n&#125;\n\ninterface Animal &#123;\n  flags: AnimalFlags;\n  &#x2F;&#x2F; name: string 这个会报红\n  [key: string]: any; &#x2F;&#x2F; 次处不允许包含以上部分\n&#125;\n\nTS 中 enum(枚举) 和 const enum(常量枚举) 有什么区别？extends 关键字不学 extends，Exclude 和 Extract，很难理解\nextends 关键字在 TS 编程中出现的频率挺高的，而且不同场景下代表的含义不一样，特此总结一下：\n\n表示继承&#x2F;拓展的含义\n\n表示约束的含义\n\n表示分配的含义\n\n\n\n\n表示继承&#x2F;拓展extends 是 ts 里一个很常见的关键字，同时也是 es6 里引入的一个新的关键字。在 js 里，extends 一般和 class 一起使用\n\nes6 继承父类的方法和属性\n\nclass Animal &#123;\n  kind &#x3D; &quot;animal&quot;;\n  constructor(kind) &#123;\n    this.kind &#x3D; kind;\n  &#125;\n  sayHello() &#123;\n    console.log(&#96;Hello, I am a $&#123;this.kind&#125;!&#96;);\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  constructor(kind) &#123;\n    super(kind);\n  &#125;\n  bark() &#123;\n    console.log(&quot;wang wang&quot;);\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog(&quot;dog&quot;);\ndog.name; &#x2F;&#x2F;  &#x3D;&gt; &#39;dog&#39;\ndog.sayHello(); &#x2F;&#x2F; &#x3D;&gt; Hello, I am a dog!\n\n这里 Dog 继承了父类的 sayHello 方法，因为可以在 Dog 实例 dog 上调用。\n\nts 继承某个类型在 ts 里，extends 除了可以像 js 继承值，还可以继承&#x2F;扩展类型：\n\ninterface Animal &#123;\n  kind: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  bark(): void;\n&#125;\n&#x2F;&#x2F; Dog &#x3D;&gt; &#123; name: string; bark(): void &#125;\n\n\n\n泛型约束在书写泛型的时候，我们往往需要对类型参数作一定的限制，比如希望传入的参数都有 name 属性的数组我们可以这么写：\nfunction getCnames&lt;T extends &#123; name: string &#125;&gt;(entities: T[]): string[] &#123;\n  return entities.map((entity) &#x3D;&gt; entity.cname);\n&#125;\n\n这里 extends 对传入的参数作了一个限制，就是 entities 的每一项可以是一个对象，但是必须含有类型为 string 的 cname 属性。\n再比如，redux 里 dispatch 一个 action，必须包含 type 属性：\n&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;redux&#x2F;blob&#x2F;2edd0363271af46e327e118f3d92e78e258bf0cd&#x2F;src&#x2F;types&#x2F;store.ts#L83\n\n&#x2F;&#x2F; Dispatch\nexport interface Dispatch&lt;A extends Action &#x3D; AnyAction&gt; &#123;\n  &lt;T extends A&gt;(action: T, ...extraArgs: any[]): T;\n&#125;\n\n&#x2F;&#x2F; AnyAction\nexport interface AnyAction extends Action &#123;\n  &#x2F;&#x2F; Allows any extra properties to be defined in an action.\n  [extraProps: string]: any;\n&#125;\n&#x2F;&#x2F; Action\nexport interface Action&lt;T &#x3D; any&gt; &#123;\n  type: T;\n&#125;\n\n&#x2F;&#x2F; 上述代码 简化\ninterface Dispatch&lt;T extends &#123; type: string &#125;&gt; &#123;\n  (action: T): T;\n&#125;\n\n条件类型与高阶类型SomeType extends OtherType ? TrueType : FalseType;\n\n\nWhen the type on the left of the extendsis assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).当左边的类型可以赋值给右边的类型，那么你就会得到第一个分支的类型，否则你就会得到第二个分支的类型。\nextends 还有一大用途就是用来判断一个类型是不是可以分配给另一个类型，这在写高级类型的时候非常有用，举个 ????：\ntype Human &#x3D; &#123;\n  name: string;\n&#125;;\ntype Duck &#x3D; &#123;\n  name: string;\n&#125;;\ntype Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;yes&#39;\n\n在 vscode 里或者 ts playground 里输入这段代码，你会发现 Bool 的类型是’yes’。这是因为 Human 和 Duck 的类型完全相同，或者说 Human 类型的一切约束条件，Duck 都具备；换言之，类型为 Human 的值可以分配给类型为 Duck 的值（分配成功的前提是，Duck 里面得的类型得有一样的），反之亦然。需要理解的是，这里 A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集。稍微扩展下来详细说明这个问题：\ntype Human &#x3D; &#123;\n  name: string;\n  occupation: string;\n&#125;;\ntype Duck &#x3D; &#123;\n  name: string;\n&#125;;\ntype Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;no&#39;\n\n当我们给 Human 加上一个 occupation 属性，发现此时 Bool 是’no’，这是因为 Duck 没有类型为 string 的 occupation 属性，类型 Duck 不满足类型 Human 的类型约束。因此，A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集，理解 extends 在类型三元表达式里的用法非常重要。\n继续看示例\ntype A1 &#x3D; &quot;x&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; string\ntype A2 &#x3D; &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; number\n\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; ?\n\nA1 和 A2 是 extends 条件判断的普通用法，和上面的判断方法一样。\nP 是带参数 T 的泛型类型，其表达式和 A1，A2 的形式完全相同，A3 是泛型类型 P 传入参数’x’ | ‘y’得到的类型，如果将’x’ | ‘y’带入泛型类的表达式，可以看到和 A2 类型的形式是完全一样的，那是不是说明，A3 和 A2 的类型就是完全一样的呢？\n有兴趣可以自己试一试，这里就直接给结论了\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number\n\n是不是很反直觉？这个反直觉结果的原因就是所谓的分配条件类型（Distributive Conditional Types）\nWhen conditional types act on a generic type, they become distributive when given a union type当条件类型作用于泛型类型时，它们变成分配条件类型（Distributive Conditional Types）\n这句话翻译过来也还是看不懂，大白话\n\n\n\n\n\n\n\n\n\n对于使用 extends 关键字的条件类型（即上面的三元表达式类型），如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。\nIf we plug a union type into ToArray, then the conditional type will be applied to each member of that union.如果将联合类型传入 ToArray，则条件类型将会应用到联合类型的每一个成员。\n还是用上面的例子说明\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number\n\n该例中，extends 的前参为 T，T 是一个泛型参数。在 A3 的定义中，给 T 传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入 P\nP&lt;&#39;x&#39; | &#39;y&#39;&gt; &#x3D;&gt; P&lt;&#39;x&#39;&gt; | P&lt;&#39;y&#39;&gt;\n\n&#x2F;&#x2F; &#39;x&#39;代入得到\n\n&#x2F;&#x2F; &#39;x&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; string\n\n&#x2F;&#x2F; &#39;y&#39;代入得到\n\n&#x2F;&#x2F; &#39;y&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; number\n\n&#x2F;&#x2F; 然后将每一项代入得到的结果联合起来，得到 string | number\n\n\n总之，满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型\n特殊的 never\n&#x2F;&#x2F; never 是所有类型的子类型\ntype A1 &#x3D; never extends &quot;x&quot; ? string : number; &#x2F;&#x2F; string\n\ntype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;\ntype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; never\n\n上面的示例中，A2 和 A1 的结果竟然不一样，看起来 never 并不是一个联合类型，所以直接代入条件类型的定义即可，获取的结果应该和 A1 一直才对啊？\n实际上，这里还是条件分配类型在起作用。never 被认为是空的联合类型，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以 P的表达式其实根本就没有执行，所以 A2 的定义也就类似于永远没有返回的函数一样，是 never 类型的。\n防止条件判断中的分配\ntype P&lt;T&gt; &#x3D; [T] extends [&quot;x&quot;] ? string : number;\ntype A1 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; number\ntype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; string\n\n在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。\n\n\nextends 与 ts 中型变父子类\n对于索引类型，子类是父类的超集\n对于联合类型，子类是父类的子集\n\n一句话： 子类比父类更具体\n索引类型B 继承 A,B 是 A 的子类，B 拥有的索引比 A 多，B 更具体\ninterface A &#123;\n  a: 1;\n&#125;\ninterface B extends A &#123;\n  b: 2;\n&#125;\n\n联合类型可见联合类型，子类 child 是父类 parent 的子集。但 child 同样比 parent 更具体。举例：选择题 ABCD 排除掉两项后，答案所在的范围就更具体了（比如 A ｜ B）;或者 1 extends number,1 相对于 number 更具体，number 又类似 0｜1｜2｜3...。所以联合类型中子类是父类子集，且更具体\ntype child &#x3D; 1 | 2;\ntype parent &#x3D; 1 | 2 | 3;\ntype check&lt;child, parent&gt; &#x3D; child extends parent ? true : false;\ntype res &#x3D; check&lt;child, parent&gt;; &#x2F;&#x2F; type res &#x3D; true\n\n判断父子类关系名义类型系统 nominal type\n使用 extends 关键字（其他强类型语言，如 java 就是采用的这个系统）\ninterface A &#123;\n  a: 1;\n&#125;\ninterface B extends A &#123;\n  b: 2;\n&#125;\n\n结构类型系统 structual typets 使用的是结构类型\ntype A &#123;\n  a: number\n  b: string;\n  c: boolean\n&#125;\n\ntype B &#123;\n  a: number\n  b: number\n&#125;\n\ntype AisChildOfB&lt;A,B&gt; &#x3D; A extends B ? true : false\n\ntype res &#x3D; AisChildOfB&lt;A,B&gt; &#x2F;&#x2F; type res &#x3D; true\n\n\n虽然 A 和 B 并没有用关键字声明，但是 TS 还是推断出 AB 的父子关系。这样做的好处非常多，可以最大化兼容 JS，毕竟 JS 中创建对象没有约束，利用结构判断能省去很多手动的类型继承声明\n协变需要不同类型的值进行赋值，虽然类型不同，但是编译器可以在某些情况下做一些改变（变通，或者是妥协），方便的进行赋值并不出现类型错误，比如：\ninterface Person &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface Student extends Person &#123;\n  school: string;\n&#125;\n\nlet aPerson: Person &#x3D; &#123; name: &quot;Beyond&quot;, age: 20 &#125;;\nlet aStudent: Student &#x3D; &#123; school: &quot;tju&quot;, name: &quot;Beyond&quot;, age: 20 &#125;;\n\naPerson &#x3D; aStudent; &#x2F;&#x2F; 这里可以执行\naStudent &#x3D; aPerson; &#x2F;&#x2F; 报错，类型“Person”中缺失属性“school”\n\ntype check&lt;T&gt; &#x3D; T extends Student ? true : false;\n\ntype res &#x3D; check&lt;typeof aPerson&gt;; &#x2F;&#x2F; res &#x3D; false\ntype res2 &#x3D; check&lt;typeof aStudent&gt;; &#x2F;&#x2F; res2 &#x3D; true\n\nTS 知道 Student 是 Person 的子类，所以在赋值时，虽然等号左右的类型不一致，但父类有属性，子类都有，所以将子类赋值给父类是安全的，反之，将父类（属性少）赋值给子类（属性多）的操作就会报错。而子类赋值给父类的过程中，子类会（妥协）改变类型以匹配父类再赋值，但是这个改变只是赋值的过程中的，不会改变变量本身的类型。使用 check 类型能看出，赋值操作之后的两个变量，还保持着原来的类型（定义时所约束的类）\n逆变在 ts 中，函数的参数类型是逆变的。\ninterface Parent &#123;\n  a: 1;\n&#125;\n\ninterface Child extends Parent &#123;\n  b: 2;\n&#125;\n\ntype FunP &#x3D; (arg: Parent) &#x3D;&gt; any;\ntype FunC &#x3D; (arg: Child) &#x3D;&gt; any;\n\nlet funp: FunP &#x3D; () &#x3D;&gt; true;\nlet func: FunC &#x3D; () &#x3D;&gt; 1;\n\nfunc &#x3D; funp;\n\n父函数能赋值给子函数（反过来不可以），这里重点有两个：约束和调用\n先记住，对于索引类型来说，父类索引更少，子类索引更多。使用类型约束父函数时，当函数调用后，函数内部的操作对象是父类。当把这个父类约束放到子类函数去调用，此时约束是子类（提供更多索引项)，但是函数内部始终是对父类（更少索引项）的操作，所以是安全的。\n反之，如果是子类赋给父类，那么就是在约束的时候使用更多的索引项，而在调用时提供了更少的（父类）索引项，这样当然是不安全的。\n双向协变既协变又逆变 &#x3D; 双向协变目前 TS 是默认不允许双向协变的，因为这样做类型不安全。但是如果设置了&quot;strictFunctionTypes&quot;:false,TS 就不会去检查，是可以做到双向逆变的，但是不建议这么做。\ntype UnionToIntersction&lt;U&gt; &#x3D; (U extends U ? (a:U)&#x3D;&gt; any: never) extends (a:inter R)&#x3D;&gt; any ? R : never\n\ntype res &#x3D; UnionToIntersction&lt;&#123;a:1&#125;|&#123;b:3&#125;&gt;\n\n不变两个没有父子级关系的类型互相赋值时，会报类型错误，这就是不变。\n参考文档几个一看就会的 TypeScript 小技巧\n你可能不知道的 typescript 实用小技巧\n","slug":"2023-01-13ts","date":"2023-01-13T02:43:49.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"f529002cad4b9303e53cd56193414670","title":"vscode todo-tree","content":"使用评论 意义\n\nFIXME: 有缺陷的代码。我有强烈的意愿去解决它。\nDELETE: 欲删除\nIDEA: 这是一个好主意\nTODO: 该怎么办。比 FIXME 弱。要修复的功能。\nNOTE: 在强调实现的意图以及为什么要这样写的时候写。\nHACK: 我想重构。\nREVIEW: 需要审查或查看。\nWARNING: 当心。\nBUG: BUG\n\n效果图\n\n配置&#x2F;&#x2F; setting.json\n\n  &#x2F;&#x2F; 自定义的标签\n  &quot;todo-tree.general.tags&quot;: [\n    &quot;IDEA&quot;,\n    &quot;TODO&quot;,\n    &quot;FIXME&quot;,\n    &quot;TAG&quot;,\n    &quot;DONE&quot;,\n    &quot;NOTE&quot;,\n    &quot;HACK&quot;,\n    &quot;REVIEW&quot;,\n    &quot;WARNING&quot;,\n    &quot;BUG&quot;\n  ],\n  &#x2F;&#x2F; 默认标签的样式\n  &quot;todo-tree.highlights.defaultHighlight&quot;: &#123;\n    &quot;foreground&quot;: &quot;white&quot;,\n    &quot;background&quot;: &quot;yellow&quot;,\n    &quot;icon&quot;: &quot;check&quot;,\n    &quot;rulerColour&quot;: &quot;yellow&quot;,\n    &quot;type&quot;: &quot;tag&quot;,\n    &quot;iconColour&quot;: &quot;yellow&quot;\n  &#125;,\n  &quot;todo-tree.highlights.customHighlight&quot;: &#123;\n    &quot;IDEA&quot;: &#123;\n      &quot;icon&quot;: &quot;telescope&quot;,\n      &quot;background&quot;: &quot;#ffb300aa&quot;\n    &#125;,\n    &quot;TODO&quot;: &#123;\n      &quot;icon&quot;: &quot;check-circle-fill&quot;,\n      &quot;background&quot;: &quot;#51ff00aa&quot;\n    &#125;,\n    &quot;BUG&quot;: &#123;\n      &quot;icon&quot;: &quot;bug&quot;,\n      &quot;background&quot;: &quot;#ff0000aa&quot;\n    &#125;,\n    &quot;HACK&quot;: &#123;\n      &quot;icon&quot;: &quot;issue-reopened&quot;,\n      &quot;background&quot;: &quot;#ff0000aa&quot;\n    &#125;,\n    &quot;FIXME&quot;: &#123;\n      &quot;icon&quot;: &quot;flame&quot;,\n      &quot;background&quot;: &quot;#ff00bfaa&quot;\n    &#125;,\n    &quot;NOTE&quot;: &#123;\n      &quot;icon&quot;: &quot;bell-fill&quot;,\n      &#x2F;&#x2F; &quot;icon&quot;: &quot;$(close)&quot;,\n      &quot;background&quot;: &quot;#ff0000aa&quot;\n    &#125;,\n    &quot;REVIEW&quot;: &#123;\n      &quot;icon&quot;: &quot;code-review&quot;,\n      &quot;background&quot;: &quot;#0055ffaa&quot;\n    &#125;,\n    &quot;WARNING&quot;: &#123;\n      &quot;icon&quot;: &quot;shield&quot;,\n      &quot;background&quot;: &quot;#ff9900aa&quot;\n    &#125;\n  &#125; &#x2F;&#x2F; optional but recommended\n\nicon 替换https://primer.style/octicons/\n参考链接todo-tree 官网\n","slug":"2023-01-13todo-tree","date":"2023-01-13T01:37:33.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"829e58fef6f7c95dbeb167f4231498ea","title":"明天上线，惊不惊喜","content":"措手不及10 号下午突然，hr 那边同事，跑过来说，晚上要发布本次开发的内容。11 号要用，已经在 hr 大群中同步信息了。相关设计图也已经做出来。挺意外的，反复确认了几次，确实是：“发布到线上”，到了下班时间，后端走了～\n为什么会发生\n这个项目经手的人太多\n公司裁员，几乎干掉了相关的项目组成员，唯一的 hr 还在\n本次修改能容是大改（由于公司老板要求考核制度变更），涉及到绩效考核的全部内容，所有流程\n项目没验收，后端出现严重问题无法上线\n\n哪些问题存在\n技术方案是否可行（前端采用适配模式，进行兼容，可以保证之前的考核模式对应的页面内容完全不会受到影响）\n流程上是否有自测\n进度节点时间把控\n保证线上稳定性，严重问题未解决前不发布\n每日晨会并没有开，完全被忽视\n资源协调先后顺序\n已定信息同步，不应该臆想\n\n第 4 点是我无法决定的，对于此有向上同步信息， 6、7 倒逼发布，这个也有待优化\n最重要的问题责任心，可能是没年终了，所以～～\n问题解决\n把 hr 搞的很火，所有人都走了，只有我给 hr 作伴 😓。也整不了啥：干脆给 hr 评估了下工时，“小问题一会就改完了，给后端讲清楚，一会就改完了，放心回去吧”\n问题很简单，起初后端不确定要改多久\n推迟到 11 号中午发布，给后端半天改问题\n\nhr11 号上午，hr 说：昨晚睡了个好觉\n","slug":"2023-01-11反思总结","date":"2023-01-11T13:26:25.000Z","categories_index":"复盘","tags_index":"复盘","author_index":"举手摘月亮"},{"id":"0b323b28c2702d089485911093b73997","title":"普通数组/稀疏数组排序","content":"稀疏数组\n\n普通数组\n\nuseSyncTwoListState用于：同步两个数组的值，从使用的角度来看就是一个 useState 操作，逻辑完全内置\nimport &#123; isFunction, listWithKeyToObject &#125; from &quot;@&#x2F;utils&#x2F;common&quot;;\nimport &#123; useMemoizedFn &#125; from &quot;ahooks&quot;;\nimport &#123; useState &#125; from &quot;react&quot;;\n\nexport const useSyncTwoListState &#x3D; &lt;T extends Array&lt;&#123; show: boolean &#125;&gt;&gt;(\n  defaultValue\n) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 普通数组\n  const [list, setList] &#x3D; useState&lt;T&gt;(defaultValue);\n  &#x2F;&#x2F; 稀疏数组\n  const [showList, setShowList] &#x3D; useState&lt;T&gt;(defaultValue);\n  &#x2F;&#x2F; 更新普通数组\n  const onUpdateList &#x3D; useMemoizedFn(\n    (state: T | ((v: T) &#x3D;&gt; T), cb?: (v: T) &#x3D;&gt; void) &#x3D;&gt; &#123;\n      if (isFunction(state)) &#123;\n        setList((pre_val) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; @ts-ignore\n          const datas: T &#x3D; state?.(pre_val);\n          setShowList(datas.filter((item) &#x3D;&gt; item.show) as T);\n          cb?.(datas);\n          return datas;\n        &#125;);\n      &#125; else &#123;\n        setList(state);\n        &#x2F;&#x2F; @ts-ignore\n        cb?.(state);\n        setShowList((state as any[]).filter((item) &#x3D;&gt; item.show) as T);\n      &#125;\n    &#125;\n  );\n  &#x2F;&#x2F; 更新稀疏数组\n  const onUpdateShowList &#x3D; useMemoizedFn(\n    (state: T | ((v: any) &#x3D;&gt; T), cb: (v: T) &#x3D;&gt; void) &#x3D;&gt; &#123;\n      if (isFunction(state)) &#123;\n        setShowList((preShowList) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; @ts-ignore\n          const _showList: T &#x3D; state?.(preShowList);\n          setList((preList) &#x3D;&gt; &#123;\n            let idx &#x3D; 0;\n            &#x2F;&#x2F; 这个地方是重点：如何将稀疏（子）数组同步到普通（主）数组\n            return preList.map((item) &#x3D;&gt; &#123;\n              if (!item.show) &#123;\n                return item;\n              &#125; else &#123;\n                &#x2F;&#x2F; eslint-disable-next-line no-plusplus\n                return _showList[idx++];\n              &#125;\n            &#125;) as T;\n          &#125;);\n          cb?.(_showList);\n          return _showList;\n        &#125;);\n      &#125; else &#123;\n        setShowList(state);\n        const showObj &#x3D; listWithKeyToObject(state as any[], &quot;id&quot;);\n        setList((preList) &#x3D;&gt; &#123;\n          const newList &#x3D; (preList || [])?.map((item) &#x3D;&gt; (&#123;\n            ...item,\n            ...showObj[item.id],\n          &#125;)) as T;\n          cb?.(newList);\n          return newList;\n        &#125;);\n      &#125;\n    &#125;\n  );\n\n  return [list, showList, onUpdateList, onUpdateShowList] as const;\n&#125;;\n\n使用const [list, showList, setList, setShowList] &#x3D; useSyncTwoListState&lt;IDragItem[]&gt;(\n  [] as IDragItem[]\n);\n\nconst onDelete &#x3D; useMemoizedFn((v: IDragItem) &#x3D;&gt; &#123;\n  const target &#x3D; list.find((item) &#x3D;&gt; item.id &#x3D;&#x3D;&#x3D; v.id) || (&#123;&#125; as IDragItem);\n  target.show &#x3D; false;\n  const ls &#x3D; deepClone(list);\n  setList(ls);\n  handleUpdateOverviewOrders(ls, () &#x3D;&gt; &#123;\n    message.success(&quot;移除成功，可通过添加指标重新添加&quot;);\n  &#125;);\n&#125;);\n\n&#x2F;** 更新 *&#x2F;\nconst handleGetOverviewOrders &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n  try &#123;\n    setLoading(true);\n    const res &#x3D; await getOverviewOrders();\n    if (res.success) &#123;\n      let _list;\n      if (res.result?.length) &#123;\n        _list &#x3D; JSON.parse(res.result[0]).map((item) &#x3D;&gt; (&#123;\n          ...allListObj[item.id],\n          ...item,\n        &#125;));\n      &#125; else &#123;\n        _list &#x3D; allList;\n      &#125;\n      setList(_list);\n    &#125;\n  &#125; finally &#123;\n    &#x2F;* continue regardless of error *&#x2F;\n    setLoading(false);\n  &#125;\n&#125;);\n&#x2F;** 更新 *&#x2F;\nconst onUpdateOverviewOrders &#x3D; useMemoizedFn(async (datas, showTip?) &#x3D;&gt; &#123;\n  const ls &#x3D; datas.map((item) &#x3D;&gt; (&#123;\n    id: item.id,\n    code: item.code,\n    show: item.show,\n  &#125;));\n  const res &#x3D; await updateOverviewOrders([JSON.stringify(ls)]);\n  if (res.success) &#123;\n    showTip ? showTip?.() : message.success(&quot;操作成功&quot;);\n  &#125;\n&#125;);\n\nconst &#123; run: handleUpdateOverviewOrders &#125; &#x3D; useDebounceFn(\n  onUpdateOverviewOrders,\n  &#123; wait: 500 &#125;\n);\n\nconst handleUpdateOverview &#x3D; useMemoizedFn(async (values) &#x3D;&gt; &#123;\n  setList(values, (datas) &#x3D;&gt; &#123;\n    handleUpdateOverviewOrders(datas);\n  &#125;);\n&#125;);\nconst handleUpdateShowOverviews &#x3D; useMemoizedFn(async (values) &#x3D;&gt; &#123;\n  setShowList(values, (datas) &#x3D;&gt; &#123;\n    handleUpdateOverviewOrders(datas);\n  &#125;);\n&#125;);\n\nuseEffect(() &#x3D;&gt; &#123;\n  handleGetOverviewOrders();\n  &#x2F;&#x2F; handleUpdateOverviewOrders(allList)\n&#125;, []);\n\n接口设计将 updateOverviewOrders 、getOverviewOrders 设计为一个 POST 接口，传递 []数组为获取数据，传递数据[&#39;字符串&#39;]为更新数据\n这不是一个好的接口设计，工作以来第一次遇到，还是有点出乎意料的\n","slug":"2023-01-11hook","date":"2023-01-11T09:09:12.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"c3f5e3bc603af25e48391385cd8562c8","title":"客户端渲染与服务端渲染不一致","content":"有的有警告，有的没有警告\n\n修改前import &#123; ICardItem &#125; from &quot;@&#x2F;components&#x2F;drag-grid&#x2F;context&quot;;\n&#x2F;&#x2F; useNextLocalStorageState 是对 ahooks useLocalStorageState 直接使用\nimport &#123; useNextLocalStorageState &#125; from &quot;@&#x2F;hooks&#x2F;nextLocalStorageState&quot;;\nimport &#123;\n  fetchBearerOptions,\n  getBusinessLineList,\n  getClientLevelList,\n  getTechLineList,\n&#125; from &quot;@&#x2F;service&#x2F;common&quot;;\nimport &#123;\n  DownloadOutlined,\n  DownOutlined,\n  PushpinOutlined,\n  UpOutlined,\n&#125; from &quot;@ant-design&#x2F;icons&quot;;\nimport isServer from &quot;@tuya-fe&#x2F;next&#x2F;isServer&quot;;\nimport &#123; useRouter &#125; from &quot;@tuya-fe&#x2F;next&#x2F;router&quot;;\nimport &#123; useMemoizedFn &#125; from &quot;ahooks&quot;;\nimport &#123;\n  Button,\n  Checkbox,\n  Col,\n  DatePicker,\n  Form,\n  Radio,\n  Row,\n  Select,\n  Space,\n&#125; from &quot;antd&quot;;\nimport &#123; SizeType &#125; from &quot;antd&#x2F;lib&#x2F;config-provider&#x2F;SizeContext&quot;;\nimport &#123; RangePickerProps &#125; from &quot;antd&#x2F;lib&#x2F;date-picker&quot;;\nimport moment from &quot;moment&quot;;\nimport React, &#123;\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useState,\n&#125; from &quot;react&quot;;\nimport &#123; allList, workloads, dayTypes, dayRangeTypes &#125; from &quot;..&quot;;\nimport styles from &quot;.&#x2F;index.module.scss&quot;;\n\nfunction formatDateRanges(ranges: any[]) &#123;\n  const results &#x3D; [];\n  if (!ranges) &#123;\n    return [undefined, undefined];\n  &#125;\n  if (ranges[0]) &#123;\n    results.push(moment(ranges[0]).format(&quot;YYYY-MM-DD&quot;));\n  &#125; else &#123;\n    results.push(undefined);\n  &#125;\n  if (ranges[1]) &#123;\n    results.push(moment(ranges[1]).format(&quot;YYYY-MM-DD&quot;));\n  &#125; else &#123;\n    results.push(undefined);\n  &#125;\n\n  return results;\n&#125;\n\nfunction transRangesToMoments(ranges: any[]) &#123;\n  let results &#x3D; [];\n  if (!ranges) &#123;\n    results &#x3D; [undefined, undefined];\n  &#125; else &#123;\n    if (ranges[0]) &#123;\n      results.push(moment(ranges[0]));\n    &#125; else &#123;\n      results.push(undefined);\n    &#125;\n    if (ranges[1]) &#123;\n      results.push(moment(ranges[1]));\n    &#125; else &#123;\n      results.push(undefined);\n    &#125;\n  &#125;\n\n  return results;\n&#125;\n\nexport function transRangesToObject(ranges: any[], format: (v: any) &#x3D;&gt; any) &#123;\n  const obj &#x3D; &#123;\n    start: undefined,\n    end: undefined,\n  &#125;;\n  if (ranges[0]) &#123;\n    obj.start &#x3D; format ? format(ranges[0]) : ranges[0];\n  &#125;\n  if (ranges[1]) &#123;\n    obj.end &#x3D; format ? format(ranges[1]) : ranges[1];\n  &#125;\n\n  return obj;\n&#125;\n\ninterface IProps &#123;\n  manual?: boolean;\n  size?: SizeType;\n  onFormChange?: (v: any) &#x3D;&gt; void;\n  onFormSubmit?: (v: any) &#x3D;&gt; void;\n&#125;\nconst &#123; RangePicker &#125; &#x3D; DatePicker;\ninterface IRef &#123;\n  reset: () &#x3D;&gt; void;\n  submit: () &#x3D;&gt; void;\n  setForm: (v: any) &#x3D;&gt; void;\n  getFieldsValue: () &#x3D;&gt; any;\n&#125;\nconst &#123; Option &#125; &#x3D; Select;\n\nconst FormSearch &#x3D; forwardRef&lt;IRef, IProps&gt;((props, ref) &#x3D;&gt; &#123;\n  const &#123; manual &#x3D; false, size &#125; &#x3D; props;\n  const [clientStore, setClientStore] &#x3D; useState&lt;Record&lt;string, any&gt;&gt;(&#123;&#125;);\n  const router &#x3D; useRouter();\n  &#x2F;&#x2F; @ts-ignore\n  const &#123; realPathname &#125; &#x3D; router;\n  const &#123; type &#125; &#x3D; router.query;\n\n  const [activeCard, setActiveCard] &#x3D; useState&lt;ICardItem&gt;(&#123;&#125; as ICardItem);\n\n  const [pageStore, setPageStore] &#x3D; useNextLocalStorageState&lt;\n    Record&lt;string, any&gt; | undefined\n  &gt;(&#96;$&#123;realPathname&#125;_page_store&#96;, &#123;\n    defaultValue: &#123; pin: true, expand: true &#125;,\n  &#125;);\n\n  &#x2F;&#x2F; 待选项\n  const [workloadBearTypes, setWorkloadBearTypes] &#x3D; useState([]);\n  const [clientLevels, setClientLevels] &#x3D; useState([]);\n  const [buslines, setBuslines] &#x3D; useState([]);\n  const [techLineList, setTechLineList] &#x3D; useState([]);\n\n  const handleGetWorkloadBearTypes &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await fetchBearerOptions();\n    if (res.success) &#123;\n      setWorkloadBearTypes(res.result);\n    &#125;\n  &#125;);\n\n  const handleGetClientLevelList &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await getClientLevelList();\n    if (res.success) &#123;\n      setClientLevels(res.result);\n    &#125;\n  &#125;);\n\n  const handleGetBuzlines &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await getBusinessLineList();\n    if (res.success) &#123;\n      setBuslines(res.result);\n    &#125;\n  &#125;);\n\n  const handleGetTechLineList &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await getTechLineList();\n    if (res.success) &#123;\n      setTechLineList(res.result.content);\n    &#125;\n  &#125;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    handleGetWorkloadBearTypes();\n    handleGetClientLevelList();\n    handleGetBuzlines();\n    handleGetTechLineList();\n  &#125;, []);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const _active &#x3D; allList.find((item) &#x3D;&gt; item.code &#x3D;&#x3D;&#x3D; type);\n    setActiveCard(_active || (&#123;&#125; as ICardItem));\n  &#125;, [type]);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!isServer) &#123;\n      let formValues;\n      try &#123;\n        formValues &#x3D; JSON.parse(localStorage.getItem(realPathname));\n\n        formValues &#x3D; &#123;\n          ...formValues,\n          baseTimes: transRangesToMoments(formValues.baseTimes),\n          compareTimes: transRangesToMoments(formValues.compareTimes),\n        &#125;;\n      &#125; catch (error) &#123;\n        formValues &#x3D; &#123;\n          baseTimes: [undefined, undefined],\n          compareTimes: [undefined, undefined],\n        &#125;;\n      &#125;\n\n      form?.setFieldsValue(formValues);\n\n      if (!manual) &#123;\n        props.onFormSubmit?.(&#123;\n          ...formValues,\n          baseTimes: formatDateRanges(formValues.baseTimes),\n          compareTimes: formatDateRanges(formValues.compareTimes),\n        &#125;);\n      &#125;\n    &#125;\n  &#125;, [realPathname]);\n\n  const [form] &#x3D; Form.useForm();\n\n  useImperativeHandle(\n    ref,\n    () &#x3D;&gt; (&#123;\n      reset() &#123;\n        form.resetFields();\n      &#125;,\n      getFieldsValue() &#123;\n        return form.getFieldsValue();\n      &#125;,\n      submit() &#123;&#125;,\n      setForm(v) &#123;\n        form.setFieldsValue(v);\n      &#125;,\n    &#125;),\n    []\n  );\n\n  const handleFinish &#x3D; useMemoizedFn((values: any) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; delete values.baseTimes\n    &#x2F;&#x2F; TODO: 处理时间\n\n    const formValues &#x3D; &#123;\n      ...values,\n      baseTimes: formatDateRanges(values.baseTimes),\n      compareTimes: formatDateRanges(values.compareTimes),\n    &#125;;\n    console.log(&quot;数据&quot;, formValues);\n\n    props.onFormSubmit?.(formValues);\n  &#125;);\n\n  const handleChange &#x3D; useMemoizedFn((v?: any) &#x3D;&gt; &#123;\n    const formValues &#x3D; form.getFieldsValue();\n    localStorage.setItem(\n      realPathname,\n      JSON.stringify(&#123; ...formValues, pin: pageStore.pin &#125;)\n    );\n    props.onFormChange?.(formValues);\n  &#125;);\n\n  const handleChangeCompare &#x3D; useMemoizedFn((e: any) &#x3D;&gt; &#123;\n    handleChange();\n    setPageStore(&#123; ...pageStore, compare: e.target.checked &#125;);\n  &#125;);\n\n  &#x2F;&#x2F; eslint-disable-next-line arrow-body-style\n  const disabledDate: RangePickerProps[&quot;disabledDate&quot;] &#x3D; (current) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; Can not select days before today and today\n    return current &gt; moment().add(1, &quot;day&quot;).endOf(&quot;day&quot;);\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    setClientStore(pageStore);\n  &#125;, [pageStore]);\n\n  return (\n    &lt;div\n      style&#x3D;&#123;&#123;\n        padding: &quot;10px 12px 10px 12px&quot;,\n        marginBottom: 8,\n        backgroundColor: &quot;#fffffff5&quot;,\n        top: 0,\n        zIndex: 99,\n        boxShadow: &quot;rgb(0 0 0 &#x2F; 4%) 0px 2px 2px&quot;,\n        position: pageStore.pin ? &quot;sticky&quot; : &quot;static&quot;,\n      &#125;&#125;\n    &gt;\n      &lt;Form\n        form&#x3D;&#123;form&#125;\n        onFinish&#x3D;&#123;handleFinish&#125;\n        onReset&#x3D;&#123;handleChange&#125;\n        size&#x3D;&#123;size&#125;\n      &gt;\n        &lt;div style&#x3D;&#123;&#123; flex: 1, display: &quot;flex&quot; &#125;&#125;&gt;\n          &#123;activeCard?.showWorkloads &amp;&amp; (\n            &lt;Form.Item name&#x3D;&quot;dayRange&quot; label&#x3D;&quot;&quot; style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;&gt;\n              &lt;Radio.Group\n                optionType&#x3D;&quot;button&quot;\n                buttonStyle&#x3D;&quot;solid&quot;\n                size&#x3D;&#123;size&#125;\n                onChange&#x3D;&#123;handleChange&#125;\n              &gt;\n                &#123;workloads.map((item: any) &#x3D;&gt; (\n                  &lt;Radio.Button key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                    &#123;item.text&#125;\n                  &lt;&#x2F;Radio.Button&gt;\n                ))&#125;\n              &lt;&#x2F;Radio.Group&gt;\n            &lt;&#x2F;Form.Item&gt;\n          )&#125;\n          &lt;Form.Item\n            &#x2F;&#x2F; labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            name&#x3D;&quot;workloadBearType&quot;\n            label&#x3D;&quot;技术承担类型&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              onChange&#x3D;&#123;handleChange&#125;\n              size&#x3D;&#123;size&#125;\n            &gt;\n              &#123;workloadBearTypes?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                  &#123;item.label&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          &lt;Form.Item\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            name&#x3D;&quot;grades&quot;\n            label&#x3D;&quot;客户等级&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              showArrow\n              mode&#x3D;&quot;multiple&quot;\n              size&#x3D;&#123;size&#125;\n              maxTagCount&#x3D;&#123;&quot;responsive&quot;&#125;\n              onChange&#x3D;&#123;handleChange&#125;\n            &gt;\n              &#123;clientLevels?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                  &#123;item.label&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          &lt;Form.Item\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            name&#x3D;&quot;businessLineIds&quot;\n            label&#x3D;&quot;承接业务线&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              showArrow\n              mode&#x3D;&quot;multiple&quot;\n              size&#x3D;&#123;size&#125;\n              maxTagCount&#x3D;&#123;&quot;responsive&quot;&#125;\n              onChange&#x3D;&#123;handleChange&#125;\n            &gt;\n              &#123;buslines?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                  &#123;item.label&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          &lt;Form.Item\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            name&#x3D;&quot;technicalBusinessIds&quot;\n            label&#x3D;&quot;技术实施线&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              showArrow\n              mode&#x3D;&quot;multiple&quot;\n              size&#x3D;&#123;size&#125;\n              onChange&#x3D;&#123;handleChange&#125;\n              maxTagTextLength&#x3D;&#123;120&#125;\n              maxTagCount&#x3D;&#123;&quot;responsive&quot;&#125;\n            &gt;\n              &#123;techLineList?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.id&#125; value&#x3D;&#123;item.id&#125;&gt;\n                  &#123;item.parentName&#125;&#x2F;&#123;item.businessName&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n        &lt;&#x2F;div&gt;\n\n        &#123;clientStore.expand &amp;&amp; (\n          &lt;&gt;\n            &lt;Form.Item name&#x3D;&quot;dayType&quot; label&#x3D;&quot;时间&quot;&gt;\n              &lt;Radio.Group\n                optionType&#x3D;&quot;button&quot;\n                buttonStyle&#x3D;&quot;solid&quot;\n                size&#x3D;&#123;size&#125;\n                onChange&#x3D;&#123;handleChange&#125;\n              &gt;\n                &#123;(\n                  activeCard?.daytypes?.map((i) &#x3D;&gt; dayTypes[i]) || dayTypes\n                ).map((item: any) &#x3D;&gt; (\n                  &lt;Radio.Button key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                    &#123;item.text&#125;\n                  &lt;&#x2F;Radio.Button&gt;\n                ))&#125;\n              &lt;&#x2F;Radio.Group&gt;\n            &lt;&#x2F;Form.Item&gt;\n\n            &lt;div style&#x3D;&#123;&#123; display: &quot;flex&quot; &#125;&#125;&gt;\n              &lt;Form.Item name&#x3D;&quot;baseTimes&quot; label&#x3D;&quot;&quot; style&#x3D;&#123;&#123; marginLeft: 40 &#125;&#125;&gt;\n                &lt;RangePicker\n                  format&#x3D;&quot;YYYY-MM-DD&quot;\n                  placeholder&#x3D;&#123;[&quot;请选择&quot;, &quot;请选择&quot;]&#125;\n                  onChange&#x3D;&#123;handleChange&#125;\n                  disabledDate&#x3D;&#123;disabledDate&#125;\n                  allowEmpty&#x3D;&#123;[true, true]&#125;\n                &#x2F;&gt;\n              &lt;&#x2F;Form.Item&gt;\n\n              &#123;activeCard?.showCompare &amp;&amp; (\n                &lt;&gt;\n                  &lt;Form.Item\n                    style&#x3D;&#123;&#123; marginLeft: 10, marginRight: 10 &#125;&#125;\n                    name&#x3D;&quot;compare&quot;\n                    valuePropName&#x3D;&quot;checked&quot;\n                  &gt;\n                    &lt;Checkbox onChange&#x3D;&#123;handleChangeCompare&#125;&gt;\n                      对比时间段\n                    &lt;&#x2F;Checkbox&gt;\n                  &lt;&#x2F;Form.Item&gt;\n                  &#123;pageStore.compare &amp;&amp; (\n                    &lt;Form.Item name&#x3D;&quot;compareTimes&quot; label&#x3D;&quot;&quot;&gt;\n                      &lt;RangePicker\n                        format&#x3D;&quot;YYYY-MM-DD&quot;\n                        placeholder&#x3D;&#123;[&quot;请选择&quot;, &quot;请选择&quot;]&#125;\n                        onChange&#x3D;&#123;handleChange&#125;\n                        disabledDate&#x3D;&#123;disabledDate&#125;\n                        allowEmpty&#x3D;&#123;[true, true]&#125;\n                      &#x2F;&gt;\n                    &lt;&#x2F;Form.Item&gt;\n                  )&#125;\n                &lt;&#x2F;&gt;\n              )&#125;\n\n              &#123;activeCard?.showDayRangeTypes &amp;&amp; (\n                &lt;Form.Item name&#x3D;&quot;dayRange&quot; label&#x3D;&quot;&quot; style&#x3D;&#123;&#123; marginLeft: 10 &#125;&#125;&gt;\n                  &lt;Radio.Group\n                    optionType&#x3D;&quot;button&quot;\n                    buttonStyle&#x3D;&quot;solid&quot;\n                    size&#x3D;&#123;size&#125;\n                    onChange&#x3D;&#123;handleChange&#125;\n                  &gt;\n                    &#123;dayRangeTypes.map((item: any) &#x3D;&gt; (\n                      &lt;Radio.Button key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                        &#123;item.text&#125;\n                      &lt;&#x2F;Radio.Button&gt;\n                    ))&#125;\n                  &lt;&#x2F;Radio.Group&gt;\n                &lt;&#x2F;Form.Item&gt;\n              )&#125;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;&gt;\n        )&#125;\n\n        &lt;Row&gt;\n          &lt;Col span&#x3D;&#123;24&#125; style&#x3D;&#123;&#123; textAlign: &quot;right&quot; &#125;&#125;&gt;\n            &lt;Button type&#x3D;&quot;primary&quot; htmlType&#x3D;&quot;submit&quot;&gt;\n              查询\n            &lt;&#x2F;Button&gt;\n            &lt;Button\n              style&#x3D;&#123;&#123; margin: &quot;0 9px&quot; &#125;&#125;\n              onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n                form.resetFields();\n              &#125;&#125;\n            &gt;\n              重置\n            &lt;&#x2F;Button&gt;\n            &lt;a\n              style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;\n              onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n                setPageStore(&#123; ...clientStore, expand: !clientStore.expand &#125;);\n              &#125;&#125;\n            &gt;\n              &#123;clientStore.expand ? &lt;UpOutlined &#x2F;&gt; : &lt;DownOutlined &#x2F;&gt;&#125;&#123;&quot; &quot;&#125;\n              &#123;clientStore.expand ? &quot;收起&quot; : &quot;展开&quot;&#125;\n            &lt;&#x2F;a&gt;\n            &lt;span style&#x3D;&#123;&#123; padding: &quot;6px 6px 6px 12px&quot; &#125;&#125;&gt;\n              &lt;Space&gt;\n                &lt;a className&#x3D;&#123;styles.downloadBtn&#125;&gt;\n                  &lt;DownloadOutlined &#x2F;&gt;\n                  下载\n                &lt;&#x2F;a&gt;\n                &lt;a\n                  onClick&#x3D;&#123;() &#x3D;&gt;\n                    setPageStore(&#123; ...clientStore, pin: !clientStore.pin &#125;)\n                  &#125;\n                &gt;\n                  &lt;PushpinOutlined\n                    style&#x3D;&#123;&#123;\n                      color: pageStore.pin &#x3D;&#x3D;&#x3D; true ? &quot;#1890ff&quot; : &quot;#616161&quot;,\n                    &#125;&#125;\n                  &#x2F;&gt;\n                &lt;&#x2F;a&gt;\n                &#123;&#96;$&#123;pageStore.pin&#125;&#96;&#125;\n              &lt;&#x2F;Space&gt;\n            &lt;&#x2F;span&gt;\n          &lt;&#x2F;Col&gt;\n        &lt;&#x2F;Row&gt;\n      &lt;&#x2F;Form&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;);\n\nexport default FormSearch;\n\n修改方案用一个 clientStore 做 react 地状态缓存，次 clientStore 不受服务端渲染&#x2F;客户端渲染所影响\n修改后页面代码import &#123; ICardItem &#125; from &quot;@&#x2F;components&#x2F;drag-grid&#x2F;context&quot;;\nimport &#123; useNextLocalStorageState &#125; from &quot;@&#x2F;hooks&#x2F;nextLocalStorageState&quot;;\nimport &#123;\n  fetchBearerOptions,\n  getBusinessLineList,\n  getClientLevelList,\n  getTechLineList,\n&#125; from &quot;@&#x2F;service&#x2F;common&quot;;\nimport &#123;\n  DownloadOutlined,\n  DownOutlined,\n  PushpinOutlined,\n  UpOutlined,\n&#125; from &quot;@ant-design&#x2F;icons&quot;;\nimport isServer from &quot;@tuya-fe&#x2F;next&#x2F;isServer&quot;;\nimport &#123; useRouter &#125; from &quot;@tuya-fe&#x2F;next&#x2F;router&quot;;\nimport &#123; useMemoizedFn &#125; from &quot;ahooks&quot;;\nimport &#123;\n  Button,\n  Checkbox,\n  Col,\n  DatePicker,\n  Form,\n  Radio,\n  Row,\n  Select,\n  Space,\n&#125; from &quot;antd&quot;;\nimport &#123; SizeType &#125; from &quot;antd&#x2F;lib&#x2F;config-provider&#x2F;SizeContext&quot;;\nimport &#123; RangePickerProps &#125; from &quot;antd&#x2F;lib&#x2F;date-picker&quot;;\nimport moment from &quot;moment&quot;;\nimport React, &#123;\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useState,\n&#125; from &quot;react&quot;;\nimport &#123; allList, workloads, dayTypes, dayRangeTypes &#125; from &quot;..&quot;;\nimport styles from &quot;.&#x2F;index.module.scss&quot;;\n\nfunction formatDateRanges(ranges: any[]) &#123;\n  const results &#x3D; [];\n  if (!ranges) &#123;\n    return [undefined, undefined];\n  &#125;\n  if (ranges[0]) &#123;\n    results.push(moment(ranges[0]).format(&quot;YYYY-MM-DD&quot;));\n  &#125; else &#123;\n    results.push(undefined);\n  &#125;\n  if (ranges[1]) &#123;\n    results.push(moment(ranges[1]).format(&quot;YYYY-MM-DD&quot;));\n  &#125; else &#123;\n    results.push(undefined);\n  &#125;\n\n  return results;\n&#125;\n\nfunction transRangesToMoments(ranges: any[]) &#123;\n  let results &#x3D; [];\n  if (!ranges) &#123;\n    results &#x3D; [undefined, undefined];\n  &#125; else &#123;\n    if (ranges[0]) &#123;\n      results.push(moment(ranges[0]));\n    &#125; else &#123;\n      results.push(undefined);\n    &#125;\n    if (ranges[1]) &#123;\n      results.push(moment(ranges[1]));\n    &#125; else &#123;\n      results.push(undefined);\n    &#125;\n  &#125;\n\n  return results;\n&#125;\n\nexport function transRangesToObject(ranges: any[], format: (v: any) &#x3D;&gt; any) &#123;\n  const obj &#x3D; &#123;\n    start: undefined,\n    end: undefined,\n  &#125;;\n  if (ranges[0]) &#123;\n    obj.start &#x3D; format ? format(ranges[0]) : ranges[0];\n  &#125;\n  if (ranges[1]) &#123;\n    obj.end &#x3D; format ? format(ranges[1]) : ranges[1];\n  &#125;\n\n  return obj;\n&#125;\n\ninterface IProps &#123;\n  &#x2F;&#x2F; trigger?: &#39;onChange&#39;\n  manual?: boolean;\n  size?: SizeType;\n  onFormChange?: (v: any) &#x3D;&gt; void;\n  onFormSubmit?: (v: any) &#x3D;&gt; void;\n&#125;\nconst &#123; RangePicker &#125; &#x3D; DatePicker;\ninterface IRef &#123;\n  reset: () &#x3D;&gt; void;\n  submit: () &#x3D;&gt; void;\n  setForm: (v: any) &#x3D;&gt; void;\n  getFieldsValue: () &#x3D;&gt; any;\n&#125;\nconst &#123; Option &#125; &#x3D; Select;\n\nconst FormSearch &#x3D; forwardRef&lt;IRef, IProps&gt;((props, ref) &#x3D;&gt; &#123;\n  const &#123; manual &#x3D; false, size &#125; &#x3D; props;\n  const router &#x3D; useRouter();\n  &#x2F;&#x2F; @ts-ignore\n  const &#123; realPathname &#125; &#x3D; router;\n  const &#123; type &#125; &#x3D; router.query;\n\n  const [activeCard, setActiveCard] &#x3D; useState&lt;ICardItem&gt;(&#123;&#125; as ICardItem);\n\n  const [pageStore, setPageStore] &#x3D; useNextLocalStorageState&lt;\n    Record&lt;string, any&gt; | undefined\n  &gt;(&#96;$&#123;realPathname&#125;_page_store&#96;, &#123;\n    defaultValue: &#123; pin: true, expand: true &#125;,\n  &#125;);\n\n  &#x2F;&#x2F; 待选项\n  const [workloadBearTypes, setWorkloadBearTypes] &#x3D; useState([]);\n  const [clientLevels, setClientLevels] &#x3D; useState([]);\n  const [buslines, setBuslines] &#x3D; useState([]);\n  const [techLineList, setTechLineList] &#x3D; useState([]);\n\n  const handleGetWorkloadBearTypes &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await fetchBearerOptions();\n    if (res.success) &#123;\n      setWorkloadBearTypes(res.result);\n    &#125;\n  &#125;);\n\n  const handleGetClientLevelList &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await getClientLevelList();\n    if (res.success) &#123;\n      setClientLevels(res.result);\n    &#125;\n  &#125;);\n\n  const handleGetBuzlines &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await getBusinessLineList();\n    if (res.success) &#123;\n      setBuslines(res.result);\n    &#125;\n  &#125;);\n\n  const handleGetTechLineList &#x3D; useMemoizedFn(async () &#x3D;&gt; &#123;\n    const res &#x3D; await getTechLineList();\n    if (res.success) &#123;\n      setTechLineList(res.result.content);\n    &#125;\n  &#125;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    handleGetWorkloadBearTypes();\n    handleGetClientLevelList();\n    handleGetBuzlines();\n    handleGetTechLineList();\n  &#125;, []);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const _active &#x3D; allList.find((item) &#x3D;&gt; item.code &#x3D;&#x3D;&#x3D; type);\n    setActiveCard(_active || (&#123;&#125; as ICardItem));\n  &#125;, [type]);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!isServer) &#123;\n      let formValues;\n      try &#123;\n        formValues &#x3D; JSON.parse(localStorage.getItem(realPathname));\n\n        formValues &#x3D; &#123;\n          ...formValues,\n          baseTimes: transRangesToMoments(formValues.baseTimes),\n          compareTimes: transRangesToMoments(formValues.compareTimes),\n        &#125;;\n      &#125; catch (error) &#123;\n        formValues &#x3D; &#123;\n          baseTimes: [undefined, undefined],\n          compareTimes: [undefined, undefined],\n        &#125;;\n      &#125;\n\n      form?.setFieldsValue(formValues);\n\n      if (!manual) &#123;\n        props.onFormSubmit?.(&#123;\n          ...formValues,\n          baseTimes: formatDateRanges(formValues.baseTimes),\n          compareTimes: formatDateRanges(formValues.compareTimes),\n        &#125;);\n      &#125;\n    &#125;\n  &#125;, [realPathname]);\n\n  const [form] &#x3D; Form.useForm();\n\n  useImperativeHandle(\n    ref,\n    () &#x3D;&gt; (&#123;\n      reset() &#123;\n        form.resetFields();\n      &#125;,\n      getFieldsValue() &#123;\n        return form.getFieldsValue();\n      &#125;,\n      submit() &#123;&#125;,\n      setForm(v) &#123;\n        form.setFieldsValue(v);\n      &#125;,\n    &#125;),\n    []\n  );\n\n  const handleFinish &#x3D; useMemoizedFn((values: any) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; delete values.baseTimes\n    &#x2F;&#x2F; TODO: 处理时间\n\n    const formValues &#x3D; &#123;\n      ...values,\n      baseTimes: formatDateRanges(values.baseTimes),\n      compareTimes: formatDateRanges(values.compareTimes),\n    &#125;;\n    console.log(&quot;数据&quot;, formValues);\n\n    props.onFormSubmit?.(formValues);\n  &#125;);\n\n  const handleChange &#x3D; useMemoizedFn((v?: any) &#x3D;&gt; &#123;\n    const formValues &#x3D; form.getFieldsValue();\n    localStorage.setItem(\n      realPathname,\n      JSON.stringify(&#123; ...formValues, pin: pageStore.pin &#125;)\n    );\n    props.onFormChange?.(formValues);\n  &#125;);\n\n  const handleChangeCompare &#x3D; useMemoizedFn((e: any) &#x3D;&gt; &#123;\n    handleChange();\n    setPageStore(&#123; ...pageStore, compare: e.target.checked &#125;);\n  &#125;);\n\n  &#x2F;&#x2F; eslint-disable-next-line arrow-body-style\n  const disabledDate: RangePickerProps[&quot;disabledDate&quot;] &#x3D; (current) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; Can not select days before today and today\n    return current &gt; moment().add(1, &quot;day&quot;).endOf(&quot;day&quot;);\n  &#125;;\n\n  return (\n    &lt;div\n      style&#x3D;&#123;&#123;\n        padding: &quot;10px 12px 10px 12px&quot;,\n        marginBottom: 8,\n        backgroundColor: &quot;#fffffff5&quot;,\n        top: 0,\n        zIndex: 99,\n        boxShadow: &quot;rgb(0 0 0 &#x2F; 4%) 0px 2px 2px&quot;,\n        position: pageStore.pin ? &quot;sticky&quot; : &quot;static&quot;,\n      &#125;&#125;\n    &gt;\n      &lt;Form\n        form&#x3D;&#123;form&#125;\n        onFinish&#x3D;&#123;handleFinish&#125;\n        onReset&#x3D;&#123;handleChange&#125;\n        size&#x3D;&#123;size&#125;\n      &gt;\n        &lt;div style&#x3D;&#123;&#123; flex: 1, display: &quot;flex&quot; &#125;&#125;&gt;\n          &#123;activeCard?.showWorkloads &amp;&amp; (\n            &lt;Form.Item name&#x3D;&quot;dayRange&quot; label&#x3D;&quot;&quot; style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;&gt;\n              &lt;Radio.Group\n                optionType&#x3D;&quot;button&quot;\n                buttonStyle&#x3D;&quot;solid&quot;\n                size&#x3D;&#123;size&#125;\n                onChange&#x3D;&#123;handleChange&#125;\n              &gt;\n                &#123;workloads.map((item: any) &#x3D;&gt; (\n                  &lt;Radio.Button key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                    &#123;item.text&#125;\n                  &lt;&#x2F;Radio.Button&gt;\n                ))&#125;\n              &lt;&#x2F;Radio.Group&gt;\n            &lt;&#x2F;Form.Item&gt;\n          )&#125;\n          &lt;Form.Item\n            &#x2F;&#x2F; labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            name&#x3D;&quot;workloadBearType&quot;\n            label&#x3D;&quot;技术承担类型&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              onChange&#x3D;&#123;handleChange&#125;\n              size&#x3D;&#123;size&#125;\n            &gt;\n              &#123;workloadBearTypes?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                  &#123;item.label&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          &lt;Form.Item\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            name&#x3D;&quot;grades&quot;\n            label&#x3D;&quot;客户等级&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              showArrow\n              mode&#x3D;&quot;multiple&quot;\n              size&#x3D;&#123;size&#125;\n              maxTagCount&#x3D;&#123;&quot;responsive&quot;&#125;\n              onChange&#x3D;&#123;handleChange&#125;\n            &gt;\n              &#123;clientLevels?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                  &#123;item.label&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          &lt;Form.Item\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            name&#x3D;&quot;businessLineIds&quot;\n            label&#x3D;&quot;承接业务线&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              showArrow\n              mode&#x3D;&quot;multiple&quot;\n              size&#x3D;&#123;size&#125;\n              maxTagCount&#x3D;&#123;&quot;responsive&quot;&#125;\n              onChange&#x3D;&#123;handleChange&#125;\n            &gt;\n              &#123;buslines?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                  &#123;item.label&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          &lt;Form.Item\n            style&#x3D;&#123;&#123; width: &quot;33.3%&quot; &#125;&#125;\n            labelCol&#x3D;&#123;&#123; span: 9 &#125;&#125;\n            name&#x3D;&quot;technicalBusinessIds&quot;\n            label&#x3D;&quot;技术实施线&quot;\n          &gt;\n            &lt;Select\n              placeholder&#x3D;&quot;请选择&quot;\n              allowClear\n              showArrow\n              mode&#x3D;&quot;multiple&quot;\n              size&#x3D;&#123;size&#125;\n              onChange&#x3D;&#123;handleChange&#125;\n              maxTagTextLength&#x3D;&#123;120&#125;\n              maxTagCount&#x3D;&#123;&quot;responsive&quot;&#125;\n            &gt;\n              &#123;techLineList?.map((item) &#x3D;&gt; (\n                &lt;Option key&#x3D;&#123;item.id&#125; value&#x3D;&#123;item.id&#125;&gt;\n                  &#123;item.parentName&#125;&#x2F;&#123;item.businessName&#125;\n                &lt;&#x2F;Option&gt;\n              ))&#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n        &lt;&#x2F;div&gt;\n\n        &#123;pageStore.expand &amp;&amp; (\n          &lt;&gt;\n            &lt;Form.Item name&#x3D;&quot;dayType&quot; label&#x3D;&quot;时间&quot;&gt;\n              &lt;Radio.Group\n                optionType&#x3D;&quot;button&quot;\n                buttonStyle&#x3D;&quot;solid&quot;\n                size&#x3D;&#123;size&#125;\n                onChange&#x3D;&#123;handleChange&#125;\n              &gt;\n                &#123;(\n                  activeCard?.daytypes?.map((i) &#x3D;&gt; dayTypes[i]) || dayTypes\n                ).map((item: any) &#x3D;&gt; (\n                  &lt;Radio.Button key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                    &#123;item.text&#125;\n                  &lt;&#x2F;Radio.Button&gt;\n                ))&#125;\n              &lt;&#x2F;Radio.Group&gt;\n            &lt;&#x2F;Form.Item&gt;\n\n            &lt;div style&#x3D;&#123;&#123; display: &quot;flex&quot; &#125;&#125;&gt;\n              &lt;Form.Item name&#x3D;&quot;baseTimes&quot; label&#x3D;&quot;&quot; style&#x3D;&#123;&#123; marginLeft: 40 &#125;&#125;&gt;\n                &lt;RangePicker\n                  format&#x3D;&quot;YYYY-MM-DD&quot;\n                  placeholder&#x3D;&#123;[&quot;请选择&quot;, &quot;请选择&quot;]&#125;\n                  onChange&#x3D;&#123;handleChange&#125;\n                  disabledDate&#x3D;&#123;disabledDate&#125;\n                  allowEmpty&#x3D;&#123;[true, true]&#125;\n                &#x2F;&gt;\n              &lt;&#x2F;Form.Item&gt;\n\n              &#123;activeCard?.showCompare &amp;&amp; (\n                &lt;&gt;\n                  &lt;Form.Item\n                    style&#x3D;&#123;&#123; marginLeft: 10, marginRight: 10 &#125;&#125;\n                    name&#x3D;&quot;compare&quot;\n                    valuePropName&#x3D;&quot;checked&quot;\n                  &gt;\n                    &lt;Checkbox onChange&#x3D;&#123;handleChangeCompare&#125;&gt;\n                      对比时间段\n                    &lt;&#x2F;Checkbox&gt;\n                  &lt;&#x2F;Form.Item&gt;\n                  &#123;pageStore.compare &amp;&amp; (\n                    &lt;Form.Item name&#x3D;&quot;compareTimes&quot; label&#x3D;&quot;&quot;&gt;\n                      &lt;RangePicker\n                        format&#x3D;&quot;YYYY-MM-DD&quot;\n                        placeholder&#x3D;&#123;[&quot;请选择&quot;, &quot;请选择&quot;]&#125;\n                        onChange&#x3D;&#123;handleChange&#125;\n                        disabledDate&#x3D;&#123;disabledDate&#125;\n                        allowEmpty&#x3D;&#123;[true, true]&#125;\n                      &#x2F;&gt;\n                    &lt;&#x2F;Form.Item&gt;\n                  )&#125;\n                &lt;&#x2F;&gt;\n              )&#125;\n\n              &#123;activeCard?.showDayRangeTypes &amp;&amp; (\n                &lt;Form.Item name&#x3D;&quot;dayRange&quot; label&#x3D;&quot;&quot; style&#x3D;&#123;&#123; marginLeft: 10 &#125;&#125;&gt;\n                  &lt;Radio.Group\n                    optionType&#x3D;&quot;button&quot;\n                    buttonStyle&#x3D;&quot;solid&quot;\n                    size&#x3D;&#123;size&#125;\n                    onChange&#x3D;&#123;handleChange&#125;\n                  &gt;\n                    &#123;dayRangeTypes.map((item: any) &#x3D;&gt; (\n                      &lt;Radio.Button key&#x3D;&#123;item.value&#125; value&#x3D;&#123;item.value&#125;&gt;\n                        &#123;item.text&#125;\n                      &lt;&#x2F;Radio.Button&gt;\n                    ))&#125;\n                  &lt;&#x2F;Radio.Group&gt;\n                &lt;&#x2F;Form.Item&gt;\n              )&#125;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;&gt;\n        )&#125;\n\n        &lt;Row&gt;\n          &lt;Col span&#x3D;&#123;24&#125; style&#x3D;&#123;&#123; textAlign: &quot;right&quot; &#125;&#125;&gt;\n            &lt;Button type&#x3D;&quot;primary&quot; htmlType&#x3D;&quot;submit&quot;&gt;\n              查询\n            &lt;&#x2F;Button&gt;\n            &lt;Button\n              style&#x3D;&#123;&#123; margin: &quot;0 9px&quot; &#125;&#125;\n              onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n                form.resetFields();\n              &#125;&#125;\n            &gt;\n              重置\n            &lt;&#x2F;Button&gt;\n            &lt;a\n              style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;\n              onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n                setPageStore(&#123; ...pageStore, expand: !pageStore.expand &#125;);\n              &#125;&#125;\n            &gt;\n              &#123;pageStore.expand ? &lt;UpOutlined &#x2F;&gt; : &lt;DownOutlined &#x2F;&gt;&#125;&#123;&quot; &quot;&#125;\n              &#123;pageStore.expand ? &quot;收起&quot; : &quot;展开&quot;&#125;\n            &lt;&#x2F;a&gt;\n            &lt;span style&#x3D;&#123;&#123; padding: &quot;6px 6px 6px 12px&quot; &#125;&#125;&gt;\n              &lt;Space&gt;\n                &lt;a className&#x3D;&#123;styles.downloadBtn&#125;&gt;\n                  &lt;DownloadOutlined &#x2F;&gt;\n                  下载\n                &lt;&#x2F;a&gt;\n                &lt;a\n                  onClick&#x3D;&#123;() &#x3D;&gt;\n                    setPageStore(&#123; ...pageStore, pin: !pageStore.pin &#125;)\n                  &#125;\n                &gt;\n                  &lt;PushpinOutlined\n                    style&#x3D;&#123;&#123;\n                      color: pageStore.pin &#x3D;&#x3D;&#x3D; true ? &quot;#1890ff&quot; : &quot;#616161&quot;,\n                    &#125;&#125;\n                  &#x2F;&gt;\n                &lt;&#x2F;a&gt;\n                &#123;&#96;$&#123;pageStore.pin&#125;&#96;&#125;\n              &lt;&#x2F;Space&gt;\n            &lt;&#x2F;span&gt;\n          &lt;&#x2F;Col&gt;\n        &lt;&#x2F;Row&gt;\n      &lt;&#x2F;Form&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;);\n\nexport default FormSearch;\n\nuseNextLocalStorageStateimport &#123; useLocalStorageState &#125; from &quot;ahooks&quot;;\nimport &#123; useEffect, useState &#125; from &quot;react&quot;;\n\nexport type IFuncUpdater&lt;T&gt; &#x3D; (previousState?: T) &#x3D;&gt; T;\nexport type IFuncStorage &#x3D; () &#x3D;&gt; Storage;\n\nexport const isFunction &#x3D; (value: unknown): value is (...args: any[]) &#x3D;&gt; any &#x3D;&gt;\n  typeof value &#x3D;&#x3D;&#x3D; &quot;function&quot;;\nexport const isUndef &#x3D; (value: unknown): value is undefined &#x3D;&gt;\n  typeof value &#x3D;&#x3D;&#x3D; &quot;undefined&quot;;\n\nexport interface Options&lt;T&gt; &#123;\n  serializer?: (value: T) &#x3D;&gt; string;\n  deserializer?: (value: string) &#x3D;&gt; T;\n  defaultValue?: T | IFuncUpdater&lt;T&gt;;\n&#125;\n\nexport const useNextLocalStorageState &#x3D; &lt;T&gt;(\n  key: string,\n  options?: Options&lt;T&gt;\n) &#x3D;&gt; &#123;\n  const [clientState, setClientState] &#x3D; useState&lt;T&gt;(&#123;&#125; as T);\n\n  const [state, updateState] &#x3D; useLocalStorageState&lt;T&gt;(key, options);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!state) &#123;\n      if (isFunction(options?.defaultValue)) &#123;\n        setClientState(options?.defaultValue());\n      &#125; else &#123;\n        setClientState(options?.defaultValue);\n      &#125;\n    &#125; else &#123;\n      setClientState(state);\n    &#125;\n  &#125;, [options, options.defaultValue, state]);\n\n  return [clientState, updateState] as const;\n&#125;;\n","slug":"2023-01-10","date":"2023-01-10T03:29:02.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"9822ee16ec74ae728e01b626d59044ab","title":"hr谈薪套路","content":"套路 1: 报价超过上限您目前要的薪资太高了，我们可能拿不下来，或者我们没有把握上面会获批，\n分析真是情况下呢，你要的这个数，可能是在他们一个薪酬范围的一个高点，他们也不是给不起，只是有点不甘心，或者说目前可能有不止你一个人到了目前谈新的这一步，他们正在考虑挑选一个最合适的人录用，可能你是那个比较优秀的，但同时也是比较贵的，所以如果你能降薪的话，那么你就成为了他们最完美的一个选择，或者是最有可能的没有别的原因，hr 就是想先压一波价，就像是你去市场上，比如说买衣服的时候，你可能也会不管对方报价多少，你首先就会说太贵了，能不能便宜一点，对不对，希望对方能够主动的降一波价，然后你再在这个基础上继续的砍价，那么 hr 这个时候的心态也一样\n回答可以和 hr 这么说：我的期望薪酬是结合目前市场上同类职位的平均薪酬，咱们公司的规模以及实力，和这个岗位的要求以及我个人的经验和能力作出的报价，如果您觉得这个报价不合理的话，那么我想先听一听，咱们公司对于这个岗位薪酬计划以及想法，这样就把问题抛给了 hr，如果对方是一个无理由压价的话，那么这个情况下，他们也会无法回答，直接规避掉你的问题，因为他们本身就没有什么计划，也没有什么冠冕堂皇的想法，所以回答这类问题，不要被 hr 所限定的所谓上限这个思路给限定死，不要踏入他们的陷阱，因为他们所谓的薪酬下限和上限，其实只有他们自己知道，属于所有解释权归 hr 所有，所以这个时候不要去管他们所说的，公司的上限如何，你只坚持你的数是合理的，是准确的就可以了\n套路 2: 薪资不能超过某涨幅我们公司只能接受你当前薪酬的涨幅不超过 20%， 15%等等一个限定死的一个涨幅为由，理智气壮地，拒绝给你一个更高的薪酬，\n分析因为 hr 普遍认为，你当前的薪酬低并不是没有理由的，你的前一家公司就是说你当前的这家公司的薪酬不给你涨薪，说明你一定在能力上有某些欠缺，只不过他们的面试可能没有充分的暴露出来，所以说不管三七二十一，他们给你一个很有限的涨幅，能够最大限度地避免自己的公司当冤大头，如果你在前一份工作确实工作不满一年的话，确实很难证明你在这几个月的时间里边能有多大的变化和成长，所以通常这种情况下，平薪或者是给你一个微小的涨幅也是合理的除非您能够充分证明，你在这不满一年的时间里边，有了一个实质性的成长，很多公司甚至会把你上上家的工资作为起跳点给你算涨幅，直接忽略掉不满 1 年的最后一段工作经历，但是如果你在前一家公司已经工作两年以上，甚至三五年左右了，对方如果再拿涨幅说事，这个时候就很耍流氓了\n回答你可以说：我目前的薪资水平是基于我 3 年前或者五年前的职位，和我的经验能力定的薪，这么多年过去了，公司的经营状况和我的职位设定都发生了很大的变化，我的个人能力的飞速成长，也没能够很好的体现在我的薪资水平上，这就是为什么我需要在外寻求一个更好的机会，所以这个时候，如果您还拿我 3 年前的薪酬水平定薪，我觉得非常的不合理，也违背了我此次来贵公司面试的初衷\n套路 3: 以职级为由压薪有 hr 偷换概念，拿职级和工作绑定，把给不到你期望薪酬的原因，归结为说给你定的级别比较低，\n分析要知道每家公司的职级评定都是很内部很自我，并没有任何一个统一的各家公司的一个评定标准，所以怎么定级，那还不是他们说了算的吗，这种时候不管什么定级不定级，坚持自己期望的薪资，如果对方还是一口咬死了，拿级别说事，你可以这个时候建议重新定级，比如说增加面试轮数，或者是根据 jd 要求表明你当前，实际上完全符合岗位的设定要求，核心的原则还是要坚持自己的价值,不要被 hr 所谓的定级这个概念圈定住\n回答\n要知道每家公司的职级评定都是很内部很自我，并没有任何一个统一的各家公司的一个评定标准，所以怎么定级，那还不是他们说了算的吗，这种时候不管什么定级不定级，坚持自己期望的薪资，\n如果对方还是一口咬死了，拿级别说事，你可以这个时候建议重新定级，比如说增加面试轮数，或者是根据 jd 要求表明你当前，实际上完全符合岗位的设定要求，核心的原则还是要坚持自己的价值,不要被 hr 所谓的定级这个概念圈定住\n\n这里需要对自己的能力和对方的要求有准确的认识，需要自信，但是千万不能自大\n套路 4: 高年薪，低月薪\n您刚刚提到的奖金，存在着很多不确定性，如果依赖这部分提升总包的话，我觉得意义不大。\n而每个月的月薪更能够直接的体现出来， 我的日常工作表现和我不断产生的价值，所以我希望在月薪 XXXX 元的基础之上，贵司能够提供一个更合理的薪酬计划\n\n套路 5: 以能力不足压薪hr： 你在前期的面试表现不太好，你本身的实力其实并不达标，但是我们公司愿意可怜你，给你一次机会，但是你的薪水必须相应的降低，\n分析教科书级别的 PUA 了，让你自我怀疑，羞愧难当，进而接受它们开出的一个低薪，你还要觉得自己不配，但其实你要站在上帝视角想问题的话，如果我真的这么差，那为什在前面的面试没有刷掉我，而是让我现在在 hr 面前谈薪水呢，只要你通过了前面的面试，就说明你的能力已经过关了，就不存在你的实力太差，但是我们愿意可怜你，给你一次机会这么一种情况。所以自然而然以此为由压薪就是更没有依据的\n回答你可以这么说：\n\n从前面的沟通谈下来，我感觉我的个人能力还是能够满足我们的岗位需要的，否则的话，我也没有机会坐在这儿和您谈新，\n虽说人无完人，我也不敢说我的面试表现就是天衣无缝，完美无缺的，但是我有这个自信，这和我们的岗位需求以及和其他竞争者相比，算是一个瑕不掩瑜的程度。\n\n套路 6: 进来再涨薪这次虽然给不到你想要的这个数，但是在你入职以后，我们马上就会有一波涨薪，你可以到那个时候进来的话，再给你涨薪，\n分析年轻人一旦超过 20 岁，这种画大饼就不要再当真了，你还没入职的时候，是和他们谈心的最佳时机，你进来以后，如果再要钱，基本上就是没人搭理你的状态了，如果你闹得很大很难看的话，还显得你这个人欲求不满，刚入职就提要求，口碑上还落了下乘，入职以后想要超越普调的程度，获得一个大幅度的升职加薪，但凡是上过班的朋友都知道这有多难\n回答你可以和 hr 说，\n\n我很高兴咱们公司有这么多鼓励员工发展和晋升的机会，\n我也相信，以我的能力很多就可以实现下次的加薪，\n不过咱们今天谈的加薪是这次的，代表了我当前的经验和能力，带给咱们公司的价值，\n以后的加薪，反映的是我未来给咱们公司创造的额外价值，属于是一码归一码\n\n套路 7: 没钱公司目前的财务状况比较紧张，所以希望大家能够共克时艰，我们大环境呢，也不太好，所以现在我们给不到你这个好的薪酬，你去别的公司估计也是给不到\n分析谈薪阶段，hr 如果拿这种接口来装可怜，让员工主动降薪，那属于是真的没招了，有枣没枣打三杆，因为这个借口实在是太 low 了，现在已经基本上骗不到什么人了，大家都是出来工作为了挣钱的，谁是来做慈善和你共克时艰的呢，要不要我倒贴钱给你\n回答你可以和 hr 说，\n\n我倒觉得大环境好或者不好，真正有价值的商品都不会贬值，\n咱们公司的主营商品或者服务都没有因此贬值，那么我们这些人才作为市场上流通的商品，自然也没有贬值的理由，您说对不对，因此我不认为，降薪是大环境变差的一个必然结果，\n而且正因为现在有大量的人才涌入市场，挖掘到真正有价值的人才，才会更难，对于公司来说呢，遇到合适的人才会比以往更加难得，所以我觉得此时不应该用降薪的方式，把一个合适的人才推开，这样的话公司，再找到下一个合适的人才，会更加浩如烟海，难上加难\n\n套路 8: 虽然钱少，但是好工作我们虽然给的钱少，但是这次的职位机会非常的好，年轻人要抓住这个机会，努力的获得成长\n分析这种理由说实话也就骗骗刚毕业的孩子，机会好的工作难道不应该是挣得更多吗，不然什么样的机会叫机会“好”呢，机会这么好的话，你们老板怎么不亲自干呢\n回答你可以对 hr 说：我当然非常珍惜咱们公司的机会，否则我也不会来这里面试，但是您提到机会好，我相信好的机会更应该应对一个好的收入，否则的话，很难解释这个机会好在哪，就好像优质的商品从来都不会贱卖一样，那么好的机会更应该值得通过更好的薪资来体现\n","slug":"2023-01-08hr","date":"2023-01-08T01:06:53.000Z","categories_index":"面试","tags_index":"面试","author_index":"举手摘月亮"},{"id":"d2e96c261e5021c4e2a877b0e4c32466","title":"q&a","content":"es5 继承与 es6 继承的区别\nes5 里的构造函数是一个普通函数，可以使用 new 调用，也可以直接调用，es6 中 class 只能使用 new 调用\nes5 里的原型方法和静态方法可以枚举，es6 class 中的方法不可枚举。 获取不可枚举的方法，Object.getOwnPropertyNames\nclass 不存在变量提升，父类必须定义在子类之前\nes5 的继承实质是先创建子类的实例对象 this,然后再执行父类的构造函数给他添加实例方法和属性，es6 继承机制：先创建父类实例的 this,然后再调用子类的构造函数来修改 this\n\njavascript 异步控制问题\nawait new Promise\nawait &#123;then: func&#125; thenable object 形式调用\n\nasync function main() &#123;\n  await &#123;\n    then: function (resolve) &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        console.log(&quot;hello&quot;);\n        resolve();\n      &#125;, 0);\n    &#125;,\n  &#125;;\n  console.log(&quot;world&quot;);\n&#125;\nmain();\n","slug":"2023-01-07qa","date":"2023-01-07T11:59:56.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"20f0bf3c93eae96e0413417a3ffb6073","title":"a 链接 color无效","content":"背景在查看之前文章，进行完善的时候遇到了 a 标签 color无效，即使是使用了内连样式 + !important仍然无效\n实现原理 2022-11-01 抽象相等比较\n问题所在一点点调试发现是 -webkit-text-fill-color在捣蛋\n\n\n背后依据-webkit-text-fill-color\n\n\n\n\n\n\n\n\n\nThe -webkit-text-fill-color CSS property specifies the fill color of characters of text. If this property is not set, the value of the color property is used.\n意思是 -webkit-text-fill-color 优先级高，没有设置 -webkit-text-fill-color， 会展示color\n","slug":"2022-12-21a","date":"2022-12-21T09:57:01.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"举手摘月亮"},{"id":"d40bc58623f2003592cb7592af431750","title":"Tree","content":"需求按照权限进行树的渲染\n权限控制树的渲染，从根节点开始渲染\n权限 paths 为空，全部可见，权限 paths 为[&#39;/1&#39;]即根节点，全部可见\n权限 paths 非空，父子路径关系的前端需要去重，只保留父路径\n有父路径权限的，其子路径部门&#x2F;员工全部可见\n去重后，子路径没有父路径的，需要渲染，根节点…至子节点路径的所有部门，不渲染无关子节点和员工\n非叶子节点的部门不可选中\n\n处理步骤\n判断 paths 是否为空数组，如果是，全部可见\n否则，对 paths 进行整理，按照路径长度进行分组，按照分组进行去重，只保留叶子节点的部门\n对去重后的数据进行转化，找到连续的 paths 路径 如果[&#39;1/2/3/4/5&#39;] =&gt; [&#39;/1/&#39;, &#39;/1/2/&#39;, &#39;1/2/3/&#39;, &#39;1/2/3/4/&#39; , &#39;1/2/3/4/5/&#39;]\n转化成map优化后续检测\n由于 paths 的转化浪费性能，所以进行必要的必包缓存\n暴露 api:\n全部可见\n检测部门的 staffs 是否应该展示\n检测部门是否展示（对部门数据进行去重）\n部门是否为叶子节点可以被选中\n\n\n\n原数据，用于产出测试数据var data &#x3D; &#123;\n  success: true,\n  msg: &quot;请求成功&quot;,\n  errCode: null,\n  result: &#123;\n    staffs: [\n      &#123;\n        staffId: &quot;00001&quot;,\n        staffNo: &quot;00001&quot;,\n        belongToOrgs: null,\n      &#125;,\n      &#123;\n        staffId: &quot;00002&quot;,\n        staffNo: &quot;00002&quot;,\n        belongToOrgs: null,\n      &#125;,\n    ],\n    orgs: [\n      &#123;\n        orgId: 3,\n        path: &quot;&#x2F;1&#x2F;3&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n      &#123;\n        orgId: 116,\n        path: &quot;&#x2F;1&#x2F;116&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n      &#123;\n        orgId: 119,\n        path: &quot;&#x2F;1&#x2F;119&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n      &#123;\n        orgId: 28,\n        path: &quot;&#x2F;1&#x2F;28&quot;,\n        depth: 2,\n        pid: 1,\n      &#125;,\n    ],\n  &#125;,\n&#125;;\n&#x2F;&#x2F; 转化查询数据\n&#x2F;&#x2F; var result &#x3D; []\n&#x2F;&#x2F; data.result.orgs.forEach((item) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   result.push(item.path)\n&#x2F;&#x2F; &#125;)\n&#x2F;&#x2F; copy(result);\n\n两组测试数据var l2 &#x3D; [\n  &quot;&#x2F;1&#x2F;3&quot;,\n  &quot;&#x2F;1&#x2F;116&quot;,\n  &quot;&#x2F;1&#x2F;119&quot;,\n  &quot;&#x2F;1&#x2F;28&quot;,\n  &quot;&#x2F;1&#x2F;120&quot;,\n  &quot;&#x2F;1&#x2F;121&quot;,\n  &quot;&#x2F;1&#x2F;122&quot;,\n  &quot;&#x2F;1&#x2F;29&quot;,\n  &quot;&#x2F;1&#x2F;908&quot;,\n  &quot;&#x2F;1&#x2F;4&quot;,\n  &quot;&#x2F;1&#x2F;6&quot;,\n  &quot;&#x2F;1&#x2F;757&quot;,\n  &quot;&#x2F;1&#x2F;9&quot;,\n  &quot;&#x2F;1&#x2F;2974&quot;,\n  &quot;&#x2F;1&#x2F;7&quot;,\n  &quot;&#x2F;1&#x2F;8&quot;,\n  &quot;&#x2F;1&#x2F;1731&quot;,\n  &quot;&#x2F;1&#x2F;3885&quot;,\n  &quot;&#x2F;1&#x2F;10&quot;,\n  &quot;&#x2F;1&#x2F;11&quot;,\n  &quot;&#x2F;1&#x2F;4082&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;2098&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;48&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;3593&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;877&quot;,\n  &quot;&#x2F;1&#x2F;3&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;93&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;4&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&quot;,\n  &quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&quot;,\n];\n\nvar l3 &#x3D; [&quot;&#x2F;1&quot;, &quot;&#x2F;1&#x2F;3&#x2F;2098&quot;, &quot;&#x2F;1&#x2F;3&#x2F;48&quot;, &quot;&#x2F;1&#x2F;3&#x2F;3593&quot;, &quot;&#x2F;1&#x2F;3&#x2F;877&quot;, &quot;&#x2F;1&#x2F;3&#x2F;1417&quot;];\n\n数据格式化成带有 prefix 字段\nprefix 字段 可用来向前匹配\n\n&#x2F;**\n * 格式化数据，优化遍历\n * @param &#123;*&#125; paths\n * @returns\n *&#x2F;\nconst formPathsToPrefixItems &#x3D; (paths) &#x3D;&gt; &#123;\n  const path_dept &#x3D; [];\n  const deptsSet &#x3D; new Set();\n  const groupObj &#x3D; &#123;&#125;;\n  const pathArr &#x3D; paths.map((path) &#x3D;&gt; &#123;\n    const dept &#x3D; path.split(&quot;&#x2F;&quot;).length - 1;\n\n    deptsSet.add(dept);\n\n    const item &#x3D; &#123;\n      path,\n      dept,\n      prefix_path: path + &quot;&#x2F;&quot;,\n    &#125;;\n\n    groupObj[dept] &#x3D; [].concat(groupObj[dept] || []).concat(item);\n\n    return item;\n  &#125;);\n  return &#123;\n    pathArr,\n    deptArr: Array.from(deptsSet).sort(),\n    groupObj,\n  &#125;;\n&#125;;\n\nconst formPathResults &#x3D; formPathsToPrefixItems(l2);\n\nconsole.log(&quot;formPathResults&quot;, formPathResults);\n\n&#x2F;&#x2F; &#x2F;&#x2F; 清理节点\n\n&#x2F;&#x2F; &#x2F;&#x2F; - 如果有父节点，就不再进行自节点过滤\n\n&#x2F;&#x2F; const prefix_path2map &#x3D; (datas) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   const map &#x3D; new Map()\n\n&#x2F;&#x2F;   datas.forEach((item) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     map.set(item.prefix_path, item)\n&#x2F;&#x2F;   &#125;)\n\n&#x2F;&#x2F;   console.log(&#39;map&#39;, map)\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; prefix_path2map(formPathResults.pathArr)\n\n&#x2F;&#x2F; console.log(&#39;pathSet&#39;, formPathResults.deptsSet)\n\n&#x2F;&#x2F; &#x2F;&#x2F; 一级剩余的树，二级剩余的树，三级剩余的树\n\n&#x2F;&#x2F; &#x2F;&#x2F; 对paths进行分组\n\n&#x2F;&#x2F; const prefix_path2GropMap &#x3D; (datas) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   const gropMap &#x3D; new Map()\n\n&#x2F;&#x2F;   datas.forEach((item) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     map.set(item.prefix_path, item)\n&#x2F;&#x2F;   &#125;)\n\n&#x2F;&#x2F;   console.log(&#39;map&#39;, map)\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; groupObj\n&#x2F;&#x2F; deptSet\n&#x2F;&#x2F; filterData\n\n&#x2F;&#x2F; console.log(JSON.stringify(formPathResults.pathArr, null, 1))\n&#x2F;&#x2F; console.log(formPathResults.deptArr)\n&#x2F;&#x2F; console.log(JSON.stringify(formPathResults, null, 2))\n\n数据去重去重规则：[&#39;/1&#39;,&#39;/1/2&#39;, &#39;/1/3/4&#39;] &#x3D;&gt; [&#39;/1&#39;]去重规则：[&#39;/1/2&#39;, &#39;/1/3/4&#39;] &#x3D;&gt; [&#39;/1/2&#39;, &#39;/1/3/4&#39;]\n即：路径有子路径，只保留父路径\n&#x2F;**\n * 数据去重\n * @param &#123;*&#125; param0\n * @returns\n *&#x2F;\nconst filterPath &#x3D; (&#123; deptArr, groupObj &#125;) &#x3D;&gt; &#123;\n  deptArr.forEach((dept, index) &#x3D;&gt; &#123;\n    const c_arr &#x3D; groupObj[dept];\n    c_arr.forEach((pathItem) &#x3D;&gt; &#123;\n      const &#123; prefix_path &#125; &#x3D; pathItem;\n      deptArr.slice(index + 1).forEach((largeDept) &#x3D;&gt; &#123;\n        const arr &#x3D; groupObj[largeDept];\n        groupObj[largeDept] &#x3D; arr.filter(\n          (item) &#x3D;&gt; !item.prefix_path.includes(prefix_path)\n        );\n      &#125;);\n    &#125;);\n  &#125;);\n\n  return groupObj;\n&#125;;\n\nconst filterResult &#x3D; filterPath(formPathResults);\n\nconsole.log(filterResult);\n\n工具方法&#x2F;**\n * 对象转化成数组\n * @param &#123;*&#125; obj\n * @returns\n *&#x2F;\nconst obj2Arr &#x3D; (obj) &#x3D;&gt; &#123;\n  let arr &#x3D; [];\n  for (const [k, v] of Object.entries(obj)) &#123;\n    arr &#x3D; arr.concat(v);\n  &#125;\n  return arr;\n&#125;;\n\n格式化可见\npaths 未传，全部可见\npaths 有传，按照 paths 进行处理\n\nconst formatViews &#x3D; (paths) &#x3D;&gt; &#123;\n  let viewAll &#x3D; false;\n  if (Array.isArray(paths) &amp;&amp; paths.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    viewAll &#x3D; true;\n  &#125;\n  const prefix_paths &#x3D; obj2Arr(filterPath(formPathsToPrefixItems(paths))).map(\n    (item) &#x3D;&gt; item.prefix_path\n  );\n  return &#123;\n    viewAll,\n    prefix_paths,\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; console.log(&#39;formatViews(l2)&#39;, formatViews(l2))\nconsole.log(&quot;formatViews(l3)&quot;, formatViews(l3));\n&#x2F;&#x2F; console.log(&#39;formatViews([])&#39;, formatViews([]))\n\n将 path 进行转树const pathToTree &#x3D; (input) &#x3D;&gt; &#123;\n  let root &#x3D; [];\n  for (let i &#x3D; 0; i &lt; input.length; i++) &#123;\n    let chain &#x3D; input[i].split(&quot;&#x2F;&quot;);\n    let currentHierarchy &#x3D; root;\n    for (let j &#x3D; 0; j &lt; chain.length; j++) &#123;\n      let wantedNode &#x3D; chain[j];\n      if (wantedNode &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;\n        continue;\n      &#125;\n      let lastHierarchy &#x3D; currentHierarchy;\n      &#x2F;&#x2F; 遍历root是否已有该层级\n      for (let k &#x3D; 0; k &lt; currentHierarchy.length; k++) &#123;\n        if (currentHierarchy[k].orgId &#x3D;&#x3D;&#x3D; wantedNode) &#123;\n          currentHierarchy &#x3D; currentHierarchy[k].children;\n          break;\n        &#125;\n      &#125;\n      if (lastHierarchy &#x3D;&#x3D;&#x3D; currentHierarchy) &#123;\n        let path;\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          path &#x3D; input[i];\n        &#125; else &#123;\n          path &#x3D; chain.slice(0, j + 1).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n        &#125;\n        let newNode &#x3D; &#123;\n          path: path,\n          orgId: wantedNode,\n          children: [],\n        &#125;;\n        &#x2F;&#x2F; 文件，最后一个字符不是&quot;&#x2F;“符号\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          delete newNode.children;\n        &#125;\n        currentHierarchy.push(newNode);\n        currentHierarchy &#x3D; newNode.children;\n      &#125;\n    &#125;\n  &#125;\n  return root;\n&#125;;\n\n&#x2F;&#x2F; 去重（因后端数据不够准确，放到前端去重）\n&#x2F;&#x2F; console.log(\n&#x2F;&#x2F;   &#39;pathToTree(formatViews(l2).prefix_paths)&#39;,\n&#x2F;&#x2F;   JSON.stringify(pathToTree(formatViews(l2).prefix_paths), null, 2),\n&#x2F;&#x2F; )\n\nconst v_tree &#x3D; pathToTree(formatViews(l2).prefix_paths);\n\n将树转化成 map，用于后续的节点检测&#x2F;&#x2F; 匹配 对长路径进行拆分，长路径才是，有限权限，（有限权限过程可见，不可操作），对应的叶子节点可以操作\n&#x2F;&#x2F; 整合成map转化成是否有子节点情况的查询，\n&#x2F;&#x2F;    - 如果没有子节点，则：后代可见，\n&#x2F;&#x2F;    - 如果有子节点，则仅对应子节点可见\nconst treeToMap &#x3D; (tree, map) &#x3D;&gt; &#123;\n  if (Array.isArray(tree) &amp;&amp; tree.length &gt; 0) &#123;\n    tree.forEach((item) &#x3D;&gt; &#123;\n      if (item.children?.length &#x3D;&#x3D;&#x3D; 0) &#123;\n        map.set(item.path, &quot;叶子结点&quot;);\n      &#125; else &#123;\n        map.set(item.path, &quot;枝干&quot;);\n      &#125;\n\n      if (Array.isArray(item.children)) &#123;\n        treeToMap(item.children, map);\n      &#125;\n    &#125;);\n  &#125;\n&#125;;\n\n节点是否存在\n使用必包，实现数据缓存\n使用科里化优化调用\n\n&#x2F;&#x2F; 叶子结点\n\nfunction existLeafNode() &#123;\n  let leafNodeMap &#x3D; new Map();\n  treeToMap(v_tree, leafNodeMap);\n  console.log(&quot;leafNodeMap&quot;, leafNodeMap);\n  return function (path) &#123;\n    const slitpaths &#x3D; path.split(&quot;&#x2F;&quot;);\n    &#x2F;&#x2F; console.log(&#39;slitpaths&#39;, slitpaths)\n    for (let i &#x3D; slitpaths.length; i &gt; 1; i &#x3D; i - 1) &#123;\n      const s &#x3D; slitpaths.slice(0, i - 1).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n      if (s &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        continue;\n      &#125;\n      if (leafNodeMap.has(s)) return true;\n    &#125;\n    return false;\n  &#125;;\n&#125;\n\nconst existFunc &#x3D; existLeafNode();\n\nconsole.log(&quot;&#x2F;1&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;93&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;93&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;&quot;, existFunc(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;&quot;));\nconsole.log(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;1&quot;, existFunc(&quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;1&quot;));\nconsole.log(&quot;&#x2F;2&#x2F;12&quot;, existFunc(&quot;&#x2F;2&#x2F;12&quot;));\n\nconst ddd &#x3D; [&quot;&#x2F;1&#x2F;5&#x2F;6&quot;, &quot;&#x2F;1&#x2F;5&#x2F;6&#x2F;1417&#x2F;0&#x2F;1&quot;];\n\n完整去除测试代码(封装成 hook)import &#123; useMemoizedFn &#125; from &quot;ahooks&quot;;\nimport &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\n&#x2F;**\n * 格式化数据，优化遍历\n * @param &#123;*&#125; paths\n * @returns\n *&#x2F;\nconst formPathsToPrefixItems &#x3D; (paths) &#x3D;&gt; &#123;\n  const deptsSet &#x3D; new Set();\n  const groupObj &#x3D; &#123;&#125;;\n  const pathArr &#x3D; paths.map((path) &#x3D;&gt; &#123;\n    const dept &#x3D; path.split(&quot;&#x2F;&quot;).length - 1;\n\n    deptsSet.add(dept);\n\n    const item &#x3D; &#123;\n      path,\n      dept,\n      prefix_path: path + &quot;&#x2F;&quot;,\n    &#125;;\n\n    groupObj[dept] &#x3D; ([] as any).concat(groupObj[dept] || []).concat(item);\n\n    return item;\n  &#125;);\n  return &#123;\n    pathArr,\n    deptArr: Array.from(deptsSet).sort(),\n    groupObj,\n  &#125;;\n&#125;;\n&#x2F;* &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; *&#x2F;\n&#x2F;&#x2F; 1. 数据去重\n&#x2F;&#x2F; 2. 数据拆分-枝干，节点\n&#x2F;&#x2F; 3. node是否展示\n\n&#x2F;**\n * 数据去重\n * @param &#123;*&#125; param0\n * @returns\n *&#x2F;\nconst filterPath &#x3D; (&#123; deptArr, groupObj &#125;) &#x3D;&gt; &#123;\n  deptArr.forEach((dept, index) &#x3D;&gt; &#123;\n    const c_arr &#x3D; groupObj[dept];\n    c_arr.forEach((pathItem) &#x3D;&gt; &#123;\n      const &#123; prefix_path &#125; &#x3D; pathItem;\n      deptArr.slice(index + 1).forEach((largeDept) &#x3D;&gt; &#123;\n        const arr &#x3D; groupObj[largeDept];\n        groupObj[largeDept] &#x3D; arr.filter(\n          (item) &#x3D;&gt; !item.prefix_path.includes(prefix_path)\n        );\n      &#125;);\n    &#125;);\n  &#125;);\n\n  return groupObj;\n&#125;;\n\n&#x2F;**\n * 对象转化成数组\n * @param &#123;*&#125; obj\n * @returns\n *&#x2F;\nconst obj2Arr &#x3D; (obj) &#x3D;&gt; &#123;\n  let arr: any &#x3D; [];\n  for (const [k, v] of Object.entries(obj)) &#123;\n    arr &#x3D; arr.concat(v);\n  &#125;\n  return arr;\n&#125;;\n&#x2F;**\n * 全部展示\n * @param paths\n * @returns\n *&#x2F;\nconst formatViews &#x3D; (paths) &#x3D;&gt; &#123;\n  let authAll &#x3D; false;\n  if (Array.isArray(paths) &amp;&amp; paths.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    authAll &#x3D; true;\n  &#125;\n  const prefix_paths &#x3D; obj2Arr(filterPath(formPathsToPrefixItems(paths))).map(\n    (item) &#x3D;&gt; item.prefix_path\n  );\n  return &#123;\n    authAll,\n    prefix_paths,\n  &#125;;\n&#125;;\n&#x2F;**\n *\n * @param input\n * @returns\n *&#x2F;\nconst pathToTree &#x3D; (input) &#x3D;&gt; &#123;\n  let root: any[] &#x3D; [];\n  for (let i &#x3D; 0; i &lt; input.length; i++) &#123;\n    let chain &#x3D; input[i].split(&quot;&#x2F;&quot;);\n    let currentHierarchy &#x3D; root;\n    for (let j &#x3D; 0; j &lt; chain.length; j++) &#123;\n      let wantedNode &#x3D; chain[j];\n      if (wantedNode &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;\n        continue;\n      &#125;\n      let lastHierarchy &#x3D; currentHierarchy;\n      &#x2F;&#x2F; 遍历root是否已有该层级\n      for (let k &#x3D; 0; k &lt; currentHierarchy.length; k++) &#123;\n        if (currentHierarchy[k].orgId &#x3D;&#x3D;&#x3D; wantedNode) &#123;\n          currentHierarchy &#x3D; currentHierarchy[k].children;\n          break;\n        &#125;\n      &#125;\n      if (lastHierarchy &#x3D;&#x3D;&#x3D; currentHierarchy) &#123;\n        let path;\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          path &#x3D; input[i];\n        &#125; else &#123;\n          path &#x3D; chain.slice(0, j + 1).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n        &#125;\n        let newNode: any &#x3D; &#123;\n          path: path,\n          orgId: wantedNode,\n          children: [],\n        &#125;;\n        &#x2F;&#x2F; 文件，最后一个字符不是&quot;&#x2F;“符号\n        if (j &#x3D;&#x3D;&#x3D; chain.length - 1) &#123;\n          delete newNode.children;\n        &#125;\n        currentHierarchy.push(newNode);\n        currentHierarchy &#x3D; newNode.children;\n      &#125;\n    &#125;\n  &#125;\n  return root;\n&#125;;\n\n&#x2F;&#x2F; 匹配 对长路径进行拆分，长路径才是，有限权限，（有限权限过程可见，不可操作），对应的叶子节点可以操作\n&#x2F;&#x2F; 整合成map转化成是否有子节点情况的查询，\n&#x2F;&#x2F;    - 如果没有子节点，则：后代可见，\n&#x2F;&#x2F;    - 如果有子节点，则仅对应子节点可见\n\nenum EType &#123;\n  leaf &#x3D; &quot;下全可见&quot;,\n  has_child &#x3D; &quot;仍需判断&quot;,\n&#125;\n&#x2F;**\n *\n * @param tree\n * @param map\n *&#x2F;\nconst treeToMap &#x3D; (tree, map) &#x3D;&gt; &#123;\n  if (Array.isArray(tree) &amp;&amp; tree.length &gt; 0) &#123;\n    tree.forEach((item) &#x3D;&gt; &#123;\n      if (item.children?.length &#x3D;&#x3D;&#x3D; 0) &#123;\n        map.set(item.path, EType.leaf);\n      &#125; else &#123;\n        map.set(item.path, EType.has_child);\n      &#125;\n\n      if (Array.isArray(item.children)) &#123;\n        treeToMap(item.children, map);\n      &#125;\n    &#125;);\n  &#125;\n&#125;;\n&#x2F;**\n * 节点是否应该存在\n * @param leafNodeMap\n * @returns\n *&#x2F;\nfunction existLeafNode(leafNodeMap) &#123;\n  return function (path, isStaff &#x3D; false) &#123;\n    if (\n      (!isStaff &amp;&amp; leafNodeMap.has(path + &quot;&#x2F;&quot;)) ||\n      (isStaff &amp;&amp; leafNodeMap.get(path + &quot;&#x2F;&quot;) &#x3D;&#x3D;&#x3D; EType.leaf)\n    ) &#123;\n      return true;\n    &#125;\n    const slitpaths &#x3D; path.split(&quot;&#x2F;&quot;);\n    for (let i &#x3D; slitpaths.length; i &gt; 1; i &#x3D; i - 1) &#123;\n      const s &#x3D; slitpaths.slice(0, i).join(&quot;&#x2F;&quot;) + &quot;&#x2F;&quot;;\n      if (s &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        continue;\n      &#125;\n      if (leafNodeMap.has(s)) &#123;\n        return leafNodeMap.get(s) &#x3D;&#x3D;&#x3D; EType.leaf;\n      &#125;\n    &#125;\n    return false;\n  &#125;;\n&#125;\n&#x2F;**\n * 是否是可选的部门节点\n * @param leafNodeMap\n * @returns\n *&#x2F;\nfunction isLeafOrgSelectableNode(leafNodeMap) &#123;\n  return function (path) &#123;\n    return leafNodeMap.get(path + &quot;&#x2F;&quot;) &#x3D;&#x3D;&#x3D; EType.leaf;\n  &#125;;\n&#125;\n\n&#x2F;**\n * hook\n * @param list\n * @returns\n *&#x2F;\nexport const useExistNode &#x3D; (list) &#x3D;&gt; &#123;\n  const refExistNode &#x3D; useRef&lt;any&gt;();\n  const refAll &#x3D; useRef(false);\n  const refIsOrgSelectableNode &#x3D; useRef&lt;any&gt;();\n\n  useEffect(() &#x3D;&gt; &#123;\n    const &#123; prefix_paths, authAll &#125; &#x3D; formatViews(list);\n    &#x2F;&#x2F; 查看全部\n    if (authAll) &#123;\n      refAll.current &#x3D; authAll;\n\n      refExistNode.current &#x3D; () &#x3D;&gt; &#123;\n        return true;\n      &#125;;\n      refIsOrgSelectableNode.current &#x3D; () &#x3D;&gt; &#123;\n        return true;\n      &#125;;\n\n      &#x2F;&#x2F;部分可见\n    &#125; else &#123;\n      refAll.current &#x3D; false;\n\n      const v_tree &#x3D; pathToTree(prefix_paths);\n      let leafNodeMap &#x3D; new Map();\n      treeToMap(v_tree, leafNodeMap);\n\n      refExistNode.current &#x3D; existLeafNode(leafNodeMap);\n      refIsOrgSelectableNode.current &#x3D; isLeafOrgSelectableNode(leafNodeMap);\n    &#125;\n  &#125;, [list]);\n\n  const filterNodes &#x3D; useMemoizedFn((list) &#x3D;&gt;\n    list.filter((item) &#x3D;&gt; refExistNode.current(item.path))\n  );\n\n  return [\n    refAll.current,\n    refExistNode.current,\n    filterNodes,\n    refIsOrgSelectableNode.current,\n  ];\n&#125;;\n&#x2F;**\n * 对树员工数据进行编码，同一员工存在不同部门，需要保证key唯一，否则渲染会有奇葩的效果\n *&#x2F;\nexport const formatOptionStaffs &#x3D; (staffs) &#x3D;&gt; &#123;\n  if (Array.isArray(staffs)) &#123;\n    return staffs?.map((item) &#x3D;&gt; &#123;\n      const mainOrg &#x3D; item.belongToOrgs.find((item) &#x3D;&gt; item.mainDutyFlag &#x3D;&#x3D;&#x3D; 1);\n      return &#123;\n        ...item,\n        key: mainOrg?.orgId\n          ? &#96;$&#123;mainOrg?.orgId&#125;-$&#123;item.staffId&#125;&#96;\n          : &#96;$&#123;item.staffId&#125;&#96;,\n      &#125;;\n    &#125;);\n  &#125;\n  return [];\n&#125;;\n","slug":"2022-12-21tree","date":"2022-12-21T01:33:18.000Z","categories_index":"Tree","tags_index":"Tree","author_index":"举手摘月亮"},{"id":"d924cc13ecef19a5718fd1f83f8206d4","title":"jwt Bearer 的作用","content":"规范要求\nw3c 规定 Authorization: &lt;type&gt; &lt;credentials&gt;\n认证的方式type, 具体信息credentials\n\n可以不加吗可以\n\n如果是遵循规范，需要加\n如果是不遵循规范，可不加\n\n参考链接jwt token 为什么要在前面添加 Bearer 这个单词？\n","slug":"2022-12-14jwt","date":"2022-12-14T07:37:53.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"11691b6cc8ffa47c60878c0bfab16d9f","title":"Goalng lumberjack","content":"lumberjack译为： 伐木工\nLumberjack is a Go package for writing logs to rolling files.\nLumberjack 是一个用于将日志写入滚动文件的 Go 包。\n日志切割，有哪些需求\n写入路径（Filename）\n什么时候切割 时间、大小 (LocalTime, MaxSize)\n切割的日志，最多存多少份(MaxBackups)\n日志最多存多久(MaxAge)\n日志内容最好能压缩下（Compress）\n\nGolang 高性能日志库 zap + lumberjack 日志切割组件详解\n","slug":"2022-12-14go-lumberjack","date":"2022-12-14T02:01:04.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"63c74d723b51bf41f59e206371fbafb4","title":"Go 语言基础","content":"李文周的博客【置顶】Go 语言学习之路&#x2F;Go 语言教程\n\niota\n短变量声明\n匿名变量\n\nGo 语言基础之数组\nGo 语言基础之流程控制\nGo 语言基础之基本数据类型\nGo 语言基础之函数\nGo 语言基础之 time 包\nGo 语言基础之并发\nGo 语言基础之 net&#x2F;http\nGo 语言基础之接口\n\n为什么需要接口以及接口的特点?\n使用接口类型说明相比于它是什么更关心它能做什么\n接口就是规定了一个需要实现的方法列表,一个类型只要实现了接口中规定的所有方法,就称它实现了这个接口\nGo 语言中使用隐式声明的方式实现接口。只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。\n实现了接口又有什么用呢？一个接口类型的变量能够存储所有实现了该接口的类型变量\n只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗\n\nGo 语言基础之 map\nGo 语言基础之运算符\n爬取脚本var domList &#x3D; document.getElementById(&quot;s-u&quot;).children;\ngetalink(domList);\nfunction getalink(_domlist) &#123;\n  var data &#x3D; &quot;&quot;;\n\n  Array.from(_domlist).forEach((li) &#x3D;&gt; &#123;\n    var a &#x3D; li.children[0];\n    var href &#x3D; a.href;\n    var title &#x3D; a.innerText;\n    var astr &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;href&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;title&#125;&lt;&#x2F;a&gt; \\n\\n&#96;;\n    data +&#x3D; astr;\n  &#125;);\n  copy(data); &#x2F;&#x2F;控制台直接拷贝到剪切板\n&#125;\n\n参考链接Go 语言基础之接口\ngoto(跳转到指定标签)&#x2F;&#x2F; 两个break跳出两个循环\nfunc gotoDemo1() &#123;\n\tvar breakFlag bool\n\tfor i :&#x3D; 0; i &lt; 10; i++ &#123;\n\t\tfor j :&#x3D; 0; j &lt; 10; j++ &#123;\n\t\t\tif j &#x3D;&#x3D; 2 &#123;\n\t\t\t\t&#x2F;&#x2F; 设置退出标签\n\t\t\t\tbreakFlag &#x3D; true\n\t\t\t\tbreak\n\t\t\t&#125;\n\t\t\tfmt.Printf(&quot;%v-%v\\n&quot;, i, j)\n\t\t&#125;\n\t\t&#x2F;&#x2F; 外层for循环判断\n\t\tif breakFlag &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 标签可以简化书写\nfunc gotoDemo2() &#123;\n\tfor i :&#x3D; 0; i &lt; 10; i++ &#123;\n\t\tfor j :&#x3D; 0; j &lt; 10; j++ &#123;\n\t\t\tif j &#x3D;&#x3D; 2 &#123;\n\t\t\t\t&#x2F;&#x2F; 设置退出标签\n\t\t\t\tgoto breakTag\n\t\t\t&#125;\n\t\t\tfmt.Printf(&quot;%v-%v\\n&quot;, i, j)\n\t\t&#125;\n\t&#125;\n\treturn\n\t&#x2F;&#x2F; 标签\nbreakTag:\n\tfmt.Println(&quot;结束for循环&quot;)\n&#125;\n\n&#x2F;&#x2F; 0-0\n&#x2F;&#x2F; 0-1\n&#x2F;&#x2F; 结束for循环\n\n\ncontinue 到 标签func continueDemo() &#123;\nforloop1:\n\tfor i :&#x3D; 0; i &lt; 5; i++ &#123;\n\t\t&#x2F;&#x2F; forloop2:\n\t\tfor j :&#x3D; 0; j &lt; 5; j++ &#123;\n\t\t\tif i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2 &#123;\n\t\t\t\tcontinue forloop1\n\t\t\t&#125;\n\t\t\tfmt.Printf(&quot;%v-%v\\n&quot;, i, j)\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\ngolang 数组增删改查Golang 切片的使用(增删改查)\ngolang Marshal&#x2F;Unmarshal“因为 marshal 有组织编排之意，所以可以翻译 为：“编排”与“反编排”，就是序列化与反序列化的意思。”\n","slug":"2022-12-12go-interface","date":"2022-12-12T07:13:23.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"4a6cf6bee94617c665b74d794eabdd69","title":"go yaml 配置文件","content":"项目gin-vue-admin 这个没看懂\ngin-mall 见\n参考链接Golang 程序读取 yaml 配置文件\ngopkg.in&#x2F;yaml.v2\n","slug":"2022-12-11go-yaml","date":"2022-12-11T12:29:12.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"1f1a9623ce6b522ab39575958416eb6f","title":"gorm 神坑~","content":"官方文档坑 1、 generated always as run SQL syntax Error&#x2F;issues&#x2F;5914\n转化的 sql 丢 data_type\n坑 2、 .Model(&amp;User{})官网神坑\ndb.Debug().Model(&amp;User&#123;&#125;).Where(&quot;id &#x3D; ?&quot;, user.ID).Updates(user)\n\n&#x2F;&#x2F; 这又是个坑 gorm官网可是贼坑，&amp;User&#123;&#125; 这尼玛怎么写的demo，是真的狗\n&#x2F;&#x2F; 直接导致hook全零值\n\n1\n更新前\nUser BeforeSave执行了\nUser11 BeforeUpdate执行了\n&#123;\n        &quot;ID&quot;: 0,\n        &quot;DeletedAt&quot;: null,\n        &quot;Name&quot;: &quot;&quot;,\n        &quot;Email&quot;: null,\n        &quot;Age&quot;: 0,\n        &quot;Birthday&quot;: null,\n        &quot;MemberNumber&quot;: &#123;\n                &quot;String&quot;: &quot;&quot;,\n                &quot;Valid&quot;: false\n        &#125;,\n        &quot;ActivatedAt&quot;: &#123;\n                &quot;Time&quot;: &quot;0001-01-01T00:00:00Z&quot;,\n                &quot;Valid&quot;: false\n        &#125;,\n        &quot;Active&quot;: &#123;\n                &quot;Bool&quot;: false,\n                &quot;Valid&quot;: false\n        &#125;,\n        &quot;CreatedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;,\n        &quot;UpdatedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;,\n        &quot;CreditCard&quot;: &#123;\n                &quot;ID&quot;: 0,\n                &quot;CreatedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;,\n                &quot;UpdatedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;,\n                &quot;DeletedAt&quot;: null,\n                &quot;Number&quot;: &quot;&quot;,\n                &quot;UserID&quot;: 0\n        &#125;,\n        &quot;FirstName&quot;: &quot;&quot;,\n        &quot;LastName&quot;: &quot;&quot;,\n        &quot;FullName&quot;: &quot;&quot;\n&#125;更新后\n\nupdates 更新的时候 不要写 .Model, 这届导致 hook 接到空数据，空数据属性全是“零值”\npackage main\n\nimport (\n\t&quot;bytes&quot;\n\t&quot;database&#x2F;sql&quot;\n\t&quot;encoding&#x2F;json&quot;\n\t&quot;errors&quot;\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n\t&quot;os&quot;\n\t&quot;time&quot;\n\n\tspew &quot;github.com&#x2F;davecgh&#x2F;go-spew&#x2F;spew&quot;\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\n&#x2F;&#x2F; User 有一张 CreditCard，UserID 是外键\ntype User struct &#123; &#x2F;&#x2F; 拥有者\n\tgorm.Model\n\tName         string &#96;gorm:&quot;default:haotian&quot;&#96;\n\tEmail        *string\n\tAge          uint8 &#96;gorm:&quot;default:30&quot;&#96;\n\tBirthday     *time.Time\n\tMemberNumber sql.NullString\n\tActivatedAt  sql.NullTime\n\tActive       sql.NullBool &#96;gorm:&quot;default:true&quot;&#96;\n\tCreatedAt    time.Time\n\tUpdatedAt    time.Time\n\tCreditCard   CreditCard &#x2F;&#x2F; 一对一的关系\n\n\tFirstName string\n\tLastName  string\n\n\tFullName string &#96;gorm:&quot;-&gt;;type:GENERATED ALWAYS AS (concat(firstname,&#39; &#39;,lastname));default:(-);&quot;&#96;\n\n\t&#x2F;&#x2F; ALTER TABLE &#96;results&#96; add  COLUMN &#96;full_name&#96; longtext  generated always as (concat(results.first_name,&#39; &#39;,results.last_name));\n&#125;\n\n\nfunc (u *User) BeforeUpdate(tx *gorm.DB) (err error) &#123;\n\tfmt.Println(&quot;User11 BeforeUpdate执行了&quot;)\n\tJsonPrint(u)\n\n\tif u.Age &lt; 100 || u.Name &#x3D;&#x3D; &quot;&quot; &#123;\n\t\treturn errors.New(&quot;invalid Age or Name&quot;)\n\t&#125;\n\n\treturn nil\n&#125;\n\nfunc (u *User) AfterUpdate(*gorm.DB) (err error) &#123;\n\tfmt.Println(&quot;User AfterUpdate执行了&quot;)\n\treturn\n&#125;\nfunc (u *User) BeforeSave(*gorm.DB) (err error) &#123;\n\tfmt.Println(&quot;User BeforeSave执行了&quot;)\n\treturn\n&#125;\nfunc (u *User) AfterSave(*gorm.DB) (err error) &#123;\n\tfmt.Println(&quot;User AfterSave执行了&quot;)\n\treturn\n&#125;\n\n&#x2F;&#x2F; 增加信用卡结构体\ntype CreditCard struct &#123;\n\tgorm.Model\n\tNumber string\n\tUserID uint\n&#125;\n\ntype Result struct &#123;\n\tID   uint8\n\tName string\n&#125;\n\nfunc JsonPrint(val any) &#123;\n\n\tb, _ :&#x3D; json.Marshal(val)\n\n\tvar out bytes.Buffer\n\n\terr :&#x3D; json.Indent(&amp;out, b, &quot;&quot;, &quot;\\t&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatalln(err)\n\t&#125;\n\n\tout.WriteTo(os.Stdout)\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 参考 https:&#x2F;&#x2F;github.com&#x2F;go-sql-driver&#x2F;mysql#dsn-data-source-name 获取详情\n\tdsn :&#x3D; &quot;root:123456@tcp(localhost:3306)&#x2F;gorm_demo?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\tvar user User\n\n\tdb.Debug().Select(&quot;id&quot;, &quot;name&quot;).Model(&amp;user).First(&amp;user, &quot;name &#x3D; ?&quot;, &quot;hali&quot;)\n\t&#x2F;&#x2F; JsonPrint(user)\n\n\tspew.Println(user.ID)\n\n\t&#x2F;&#x2F; user.Name &#x3D; &quot;hali&quot;\n\tspew.Println(&quot;更新前&quot;)\n\n  &#x2F;&#x2F; 神坑\n\t&#x2F;&#x2F; db.Debug().Model(&amp;User&#123;&#125;).Where(&quot;id &#x3D; ?&quot;, user.ID).Updates(user) &#x2F;&#x2F; hook 获取属性全部是零值\n\n  &#x2F;&#x2F; ok 1\n\t&#x2F;&#x2F; db.Debug().Where(&quot;id &#x3D; ?&quot;, user.ID).Updates(user)\n\n\n  &#x2F;&#x2F; ok 2\n  &#x2F;&#x2F; 把有数据的user地址塞进去\n  db.Debug().Model(&amp;user).Where(&quot;id &#x3D; ?&quot;, user.ID).Updates(user)\n\n\tspew.Println(&quot;更新后&quot;)\n\n&#125;\n\n\n坑 3、 .Model(User{})db.Model(User{})\ndb.Model(User&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)\n\n\n&#x2F;&#x2F; panic: reflect.Value.Addr of unaddressable value\n\n&#x2F;&#x2F; goroutine 1 [running]:\n&#x2F;&#x2F; reflect.Value.Addr(&#123;0x13a3620?, 0xc0002aa000?, 0xc0000f3bd8?&#125;)\n&#x2F;&#x2F;         &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;reflect&#x2F;value.go:271 +0x65\n&#x2F;&#x2F; gorm.io&#x2F;gorm&#x2F;callbacks.callMethod(0xc0000754a0, 0xc0000f3c08)\n&#x2F;&#x2F;         &#x2F;Users&#x2F;chenhailong&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;gorm.io&#x2F;gorm@v1.24.2&#x2F;callbacks&#x2F;callmethod.go:20 +0xdd\n&#x2F;&#x2F; gorm.io&#x2F;gorm&#x2F;callbacks.BeforeUpdate(0xc0000754a0?)\n&#x2F;&#x2F;         &#x2F;Users&#x2F;chenhailong&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;gorm.io&#x2F;gorm@v1.24.2&#x2F;callbacks&#x2F;update.go:35 +0x67\n&#x2F;&#x2F; gorm.io&#x2F;gorm.(*processor).Execute(0xc00019c230, 0xc000194a50?)\n&#x2F;&#x2F;         &#x2F;Users&#x2F;chenhailong&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;gorm.io&#x2F;gorm@v1.24.2&#x2F;callbacks.go:130 +0x436\n&#x2F;&#x2F; gorm.io&#x2F;gorm.(*DB).Updates(0x13a3620?, &#123;0x13a3620?, 0xc0002aa1a0&#125;)\n&#x2F;&#x2F;         &#x2F;Users&#x2F;chenhailong&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;gorm.io&#x2F;gorm@v1.24.2&#x2F;finisher_api.go:382 +0x92\n&#x2F;&#x2F; main.main()\n&#x2F;&#x2F;         &#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;github&#x2F;go&#x2F;gorm-demo&#x2F;main.go:151 +0x37f\n&#x2F;&#x2F; exit status 2\n\n总结\ngorm 能解决的，代码能解决\ngorm 不能解决的，代码也能解决\n在 gorm 出现 bug 的时候，可以改为代码判断，原生 sql\n\n","slug":"2022-12-10gorm-ls","date":"2022-12-10T09:10:12.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"913ea831ec1db0086e941500c02969c4","title":"gorm 敲一敲","content":"name “date”: unsupported Scan&#x2F;&#x2F; sql: Scan error on column index 0, name &quot;date&quot;: unsupported Scan, storing driver.Value type &lt;nil&gt; into type \\*sql.Rows\n&#x2F;&#x2F; exit status 1\n\n\npackage main\n\nimport (\n\t&quot;bytes&quot;\n\t&quot;database&#x2F;sql&quot;\n\t&quot;encoding&#x2F;json&quot;\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n\t&quot;os&quot;\n\t&quot;time&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\n&#x2F;&#x2F; User 有一张 CreditCard，UserID 是外键\ntype User struct &#123; &#x2F;&#x2F; 拥有者\n\tgorm.Model\n\tName         string &#96;gorm:&quot;default:haotian&quot;&#96;\n\tEmail        *string\n\tAge          uint8 &#96;gorm:&quot;default:30&quot;&#96;\n\tBirthday     *time.Time\n\tMemberNumber sql.NullString\n\tActivatedAt  sql.NullTime\n\tActive       sql.NullBool &#96;gorm:&quot;default:true&quot;&#96;\n\tCreatedAt    time.Time\n\tUpdatedAt    time.Time\n\tCreditCard   CreditCard &#x2F;&#x2F; 一对一的关系\n\n\tFirstName string\n\tLastName  string\n\n\tFullName string &#96;gorm:&quot;-&gt;;type:GENERATED ALWAYS AS (concat(firstname,&#39; &#39;,lastname));default:(-);&quot;&#96;\n\n\t&#x2F;&#x2F; ALTER TABLE &#96;users&#96; add  COLUMN &#96;full_name&#96; longtext  generated always as (concat(users.first_name,&#39; &#39;,users.last_name));\n&#125;\n\nfunc main()  &#123;\n\n\n\tdsn :&#x3D; &quot;root:123456@tcp(localhost:3306)&#x2F;gorm_demo?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\ttype Result struct &#123;\n\t\tDate  time.Time\n\t\tTotal int\n\t&#125;\n\n\trows, _ :&#x3D; db.Debug().Table(&quot;users&quot;).Select(&quot;date(created_at) as date, sum(age) as total&quot;).Group(&quot;date(created_at)&quot;).Rows()\n  &#x2F;&#x2F; 结果承载\n\tvar results []Result\n\n\tfor rows.Next() &#123;\n\t\tvar user Result\n\t\tdb.ScanRows(rows, &amp;user)\n\t\tif err !&#x3D; nil &#123;\n\t\t\tlog.Fatal(err)\n\t\t&#125;\n    &#x2F;&#x2F; 转化成数组\n\t\tresults &#x3D; append(results, user)\n\t&#125;\n\trows.Close()\n\n  &#x2F;&#x2F; json化输出\n\n\tb, _ :&#x3D; json.Marshal(results)\n\n\tvar out bytes.Buffer\n\n\terr &#x3D; json.Indent(&amp;out, b, &quot;&quot;, &quot;\\t&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Fatalln(err)\n\t&#125;\n\n\tout.WriteTo(os.Stdout)\n  &#125;\n\n参考链接【大头在此】gin 框架学习-GORM 框架进阶之 CRUD 接口(数据库增删改查操作)\n","slug":"2022-12-10gorm","date":"2022-12-10T01:21:05.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"907b3348d3876a023645790a9362572f","title":"CssInJs emotion","content":"背景开发业务看板组件，原项目使用 @emotion 实现\n简单图\n\n简单图录制\n\n头部组合录制\n\n问题You have tried to stringify object returned from &#96;css&#96; function. It isn&#39;t supposed to be used directly (e.g. as value of the &#96;className&#96; prop), but rather handed to emotion so it can handle it (e.g. as value of &#96;css&#96; prop).\n\n问题处理链接@emotion 在 React17 的适配问题（@jsxImportSource&#x2F;@jsxRuntime 的作用）\n不继续深入CssInJs 不继续深入\n参考链接@emotion 在 React17 的适配问题（@jsxImportSource&#x2F;@jsxRuntime 的作用）\nhttps://emotion.sh/docs/css-prop\n","slug":"2022-12-06emotion","date":"2022-12-06T10:06:21.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"举手摘月亮"},{"id":"4d8952b5b21c6571debc1a230afe52fe","title":"10.系统学习 mysql 练习","content":"表结构1. 取得每个部门最高薪水的人员名称2. 哪些人的薪水在部门的平均薪水之上3.4. 不用组函数(MAX)，取得最高薪水5. 取得平均薪水最高的部门的部门编号6. 取得平均薪水最高的部门的部门名称7. 求平均薪水的等级最低的部门的部门名称8. 取得比普通员工（员工代码没有在 mgr 字段上出现）的最高薪水还要高的领导人姓名9. 取得薪水最高的前五名员工10. 取得薪水最高的第六到第十名员工11. 取得最后入职的 5 名员工12. 取得每个薪水等级有多少员工13.14. 列出所有员工及领导的新名15. 列出受雇日期早于其直接上级的所有员工的编号，姓名，部门名称16. 列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门17. 列出至少有 5 个员工的所有部门18. 列出薪金比 “SMITH”多的所有员工信息19. 列出所有“CLEARK”(办事员)的姓名及其部门名称，部门的人数20. 列出最低薪金大雨 1500 的各种工作及从事此工作的全部雇员人数，按照工作岗位分组求最小值21. 列出在部门“SALES”&lt;销售部&gt;工作的员工的姓名，假定不知道销售部的部门编号22. 列出薪金高于公司平均薪金的所有员工，所在部门，上级领导，雇员的工资等级23. 列出与“SCOTT”从事相同工作的所有员工及部门名称24. 列出薪金等于部门 30 中员工的薪金的其他员工的姓名和薪金25. 列出薪金高于在部门 30 的所有员工的薪金的员工姓名、薪金、部门名称26. 列出在每个部门工作的员工数量，平均工资和平均服务期限没有员工的部门，部门人数 027. 列出所有员工的姓名、部门名称、工资28. 列出所有部门的详细信息、人数29. 列出各种工作的最低工资、从事此工作的雇员姓名30. 列出各个部门的 MANAGER(领导)的最低薪金31. 列出所有员工的年工资，按年薪从低到高排序32. 求出员工领导的薪水超过 3000 的员工名称、领导33. 求出部门名称中，带‘s’字符的部门员工的工资合计、部门的人数34. 给任职日期超过 30 年的员工加薪 10%","slug":"2022-12-03mysql-练习","date":"2022-12-03T09:41:05.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"dc28c018138ffb8f51181fca20d04b7b","title":"9.系统学习 mysql 数据类型","content":"参考链接MySQL 数据类型——数值类型\n","slug":"2022-12-02mysql-数据类型","date":"2022-12-03T09:40:51.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"b97ebb9e0de07448d25c52574eb10e17","title":"8.系统学习 mysql 函数","content":"MySQL 聚合函数聚合函数与组连用\n\n默认情况是一组\nGROUP BY 进行分组\n\n+-------------+------------------+----------+\n| productCode | productLine      | buyPrice |\n+-------------+------------------+----------+\n| S10_1949    | Classic Cars     |    98.58 |\n| S10_2016    | Motorcycles      |    68.99 |\n| S10_4698    | Motorcycles      |    91.02 |\n| S10_4757    | Classic Cars     |    85.68 |\n| S10_4962    | Classic Cars     |   103.42 |\n| S12_1099    | Classic Cars     |    95.34 |\n| S12_1108    | Classic Cars     |    95.59 |\n| S12_1666    | Trucks and Buses |    77.90 |\n| S12_2823    | Motorcycles      |    66.27 |\n| S12_3148    | Classic Cars     |    89.14 |\n+-------------+------------------+----------+\n\nAVGAVG -计算一组值 或表达式的平均值。\n\nmysql&gt; select avg( buyPrice) from products group by productLine limit 1,10;\n+----------------+\n| avg( buyPrice) |\n+----------------+\n|      50.685385 |\n|      49.629167 |\n|      47.007778 |\n|      43.923333 |\n|      56.329091 |\n|      46.066250 |\n+----------------+\n6 rows in set (0.00 sec)\n\nCOUNTCOUNT -计算表中的行数。\n-- 不是限制了10个吗？嗯这个和sql执行顺序有关\nmysql&gt; select count( buyPrice) from products group by productLine limit 1,10;\n+------------------+\n| count( buyPrice) |\n+------------------+\n|               13 |\n|               12 |\n|                9 |\n|                3 |\n|               11 |\n|               24 |\n+------------------+\n6 rows in set (0.01 sec)\n\n-- 哎～，看到了吧，count可不管你的limit，直接扫描分组类型对应的全表\nmysql&gt; select count( buyPrice) from products group by productLine;\n+------------------+\n| count( buyPrice) |\n+------------------+\n|               38 |\n|               13 |\n|               12 |\n|                9 |\n|                3 |\n|               11 |\n|               24 |\n+------------------+\n7 rows in set (0.00 sec)\n\nINSTRINSTR -返回字符串中第一次出现的子字符串的位置。\n-- 不区分大小写\nINSTR(string1, string2)\n\n-- string1\t需要。要搜索的字符串\n-- string2\t需要。要在string1中搜索的字符串。如果未找到string2，则此函数返回0\n\nSUMSUM  -计算一组值 或表达式的总和。\n-- group by 会限制 select 提取的内容\nmysql&gt; select sum(buyPrice) total from products group by productLine limit 1,10;\n+---------+\n| total   |\n+---------+\n|  658.91 |\n|  595.55 |\n|  423.07 |\n|  131.77 |\n|  619.62 |\n| 1105.59 |\n+---------+\n\nMINMIN -在一组值中 找到最小值\nmysql&gt; select min( buyPrice) from products group by productLine limit 1,10;\n+----------------+\n| min( buyPrice) |\n+----------------+\n|          24.14 |\n|          29.34 |\n|          33.30 |\n|          26.72 |\n|          24.92 |\n|          20.61 |\n+----------------+\n6 rows in set (0.01 sec)\n\nMAXMAX -在一组值中 找到最大值\nmysql&gt; select max( buyPrice) from products group by productLine limit 1,10;\n+----------------+\n| max( buyPrice) |\n+----------------+\n|          91.02 |\n|          77.27 |\n|          82.34 |\n|          67.56 |\n|          84.76 |\n|          86.70 |\n+----------------+\n6 rows in set (0.00 sec)\n\nMySQL 字符串函数CONCATCONCAT -将两个或多个字符串组合成一个字符串。\n\nmysql&gt; SELECT CONCAT(&quot;SQL &quot;, &quot;Tutorial &quot;, &quot;is &quot;, &quot;fun!&quot;) AS ConcatenatedString;\n\n\n+----------------------+\n| ConcatenatedString   |\n+----------------------+\n| SQL Tutorial is fun! |\n+----------------------+\n1 row in set (0.00 sec)\n\nLENGTHLENGTH＆CHAR_LENGTH  -获取字符串的长度，以字节和字符为单位。\nSELECT CustomerName, LENGTH(CustomerName) AS LengthOfName FROM Customers;\n\nmysql&gt;  SELECT LENGTH(&quot;SQL Tutorial&quot;) AS LengthOfString;\n+----------------+\n| LengthOfString |\n+----------------+\n|             12 |\n+----------------+\n1 row in set (0.00 sec)\n\nCHAR_LENGTHCHARACTER_LENGTH - 函数返回字符串的长度（以字符为单位）\nmysql&gt; SELECT CHARACTER_LENGTH(&quot;SQL Tutorial&quot;) AS LengthOfString;\n+----------------+\n| LengthOfString |\n+----------------+\n|             12 |\n+----------------+\n1 row in set (0.01 sec)\n\nLEFTLEFT -获取具有指定长度的字符串的左侧部分。\nSELECT LEFT(&quot;SQL Tutorial&quot;, 3) AS ExtractString;\n\n-- ExtractString\n-- SQL\n\n\nSELECT CustomerName, LEFT(CustomerName, 5) AS ExtractString FROM Customers;\n\n-- CustomerName\t                                ExtractString\n-- Alfreds Futterkiste\t                        Alfre\n-- Ana Trujillo Emparedados y helados\t          Ana T\n-- Antonio Moreno Taquería\t                    Anton\n-- Around the Horn\t                            Aroun\n\nREPLACEREPLACE -搜索并替换字符串中的子字符串。\n-- REPLACE(string, from_string, new_string)\n\n-- string\t              必须项。原始字符串\n-- from_string\t        必须项。要替换的子字符串\n-- new_string\t          必须项。新的替换子字符串\n\nSELECT REPLACE(&quot;XYZ FGH XYZ&quot;, &quot;X&quot;, &quot;m&quot;);\n\n-- REPLACE(&quot;XYZ FGH XYZ&quot;, &quot;X&quot;, &quot;m&quot;)\n-- mYZ FGH mYZ\n\nSUBSTRINGSUBSTRING -从具有特定长度的位置开始提取子字符串。\nSELECT SUBSTRING(&quot;SQL Tutorial&quot;, 5, 3) AS ExtractString;\n\n\n-- ExtractString\n-- Tut\n\nTRIMTRIM -从字符串中删除不需要的字符。\nSELECT TRIM(&quot; SQL Tutorial &quot;) AS TrimmedString;\n\n-- TrimmedString\n-- SQL Tutorial\n\n\nFIND_IN_SETFIND_IN_SET -在以逗号分隔的字符串列表中查找字符串。\n-- 函数返回字符串列表中字符串的位置\nFIND_IN_SET(string, string_list)\n\n-- string_list 为null ,返回null\n-- string_list 为string,找得到返回下表从 1 开始，没找到返回 0\n\nFORMAT - 格式化具有特定区域设置的数字，四舍五入到小数位数\nMySQL 控制流功能CASECASE - THEN如果WHEN满足分支中的条件，则返回分支中的相应结果，否则返回ELSE分支中的结果。\n-- CASE\n  -- WHEN condition1 THEN result1\n  -- WHEN condition2 THEN result2\n  -- WHEN conditionN THEN resultN\n  -- ELSE result\n-- END;\n\n\n-- 如果没有ELSE部分且没有条件为真，则返回NULL。\n\n\nSELECT OrderID, Quantity,\n  CASE\n    WHEN Quantity &gt; 30 THEN &quot;The quantity is greater than 30&quot;\n    WHEN Quantity &#x3D; 30 THEN &quot;The quantity is 30&quot;\n    ELSE &quot;The quantity is under 30&quot;\n  END\nAS QuantityText\nFROM OrderDetails;\n\n\n以下 SQL 将按 City 排列客户。但是，如果 City 为 NULL，则按 Country 排序：\nSELECT CustomerName, City, Country\nFROM Customers\nORDER BY\n(CASE\n    WHEN City IS NULL THEN Country\n    ELSE City\nEND);\n\n\nIFIF - 根据给定条件返回值。\nSELECT IF(500&lt;1000, &quot;YES&quot;, &quot;NO&quot;);\n\nIFNULL 相当于 js ??IFNULL - 如果它不是 NULL 则返回第一个参数，否则返回第二个参数。\nSELECT IFNULL(NULL, &quot;W3Schools.com&quot;);\n\n-- IFNULL(NULL, &quot;begtut.com&quot;)\n-- begtut.com\n\n\nNULLIFNULLIF - 如果第一个参数等于第二个参数，返回 NULL，否则返回第一个参数。\n\n-- 定义和用法\nNULLIF()  -- 函数比较两个表达式，如果它们相等则返回NULL。否则，返回第一个表达式。\n\n-- 语法\nNULLIF(expr1, expr2)\n\n\nMySQL 比较功能COALESCECOALESCE - 返回第一个非 null 参数，这对于替换 null 非常方便\nmysql&gt; SELECT COALESCE(NULL, NULL, NULL, &#39;Begtut.com&#39;, NULL, &#39;Example.com&#39;);\n\n\n+---------------------------------------------------------------+\n| COALESCE(NULL, NULL, NULL, &#39;Begtut.com&#39;, NULL, &#39;Example.com&#39;) |\n+---------------------------------------------------------------+\n| Begtut.com                                                    |\n+---------------------------------------------------------------+\n1 row in set (0.00 sec)\n\nGREATESTGREATEST - 取 n 个参数的最大值\nmysql&gt; SELECT GREATEST(3, 12, 34, 8, 25);\n\n+----------------------------+\n| GREATEST(3, 12, 34, 8, 25) |\n+----------------------------+\n|                         34 |\n+----------------------------+\n1 row in set (0.01 sec)\n\nLEASTLEAST - 取 n 个参数返回最小值\nmysql&gt; SELECT LEAST(3, 12, 34, 8, 25);\n\n+-------------------------+\n| LEAST(3, 12, 34, 8, 25) |\n+-------------------------+\n|                       3 |\n+-------------------------+\n1 row in set (0.00 sec)\n\n\n\nISNULLISNULL - 如果参数为 null，则返回 1，否则返回零\nMySQL 日期和时间函数CURDATE -返回当前日期\nDATEDIFF -计算两个DATE值之间的天数\nDAY -获取指定日期的月份日期。\nDATE_ADD -将日期值添加到日期值。\nDATE_SUB -从日期值中减去时间值。\nDATE_FORMAT -根据指定的日期格式格式化日期值。\nDAYNAME -获取指定日期的工作日名称。\nDAYOFWEEK -返回日期的工作日索引。\nEXTRACT -提取日期的一部分。\nNOW -返回执行语句的当前日期和时间。\nMONTH -返回表示指定日期月份的整数。\nSTR_TO_DATE -根据指定的格式将字符串转换为日期和时间值。\nSYSDATE -返回当前日期。\nTIMEDIFF -计算两个TIME或DATETIME值之间的差异。\nTIMESTAMPDIFF -计算两个DATE或DATETIME值之间的差异。\nWEEK -返回一个星期的日期。\nWEEKDAY -返回日期的工作日索引。\nYEAR -返回日期值的年份部分。\nMySQL 数学函数(不常见)ABS - 返回数字的绝对值\nCEIL - 返回大于或等于输入数字的最小整数值\nFLOOR - 返回不大于参数的最大整数值\nMOD - 返回数字的余数除以另一个\nROUND - 将数字四舍五入到指定的小数位数\nTRUNCATE - 将数字截断为指定的小数位数\n\nmysql&gt; SELECT TRUNCATE(135.375, 2);\n+----------------------+\n| TRUNCATE(135.375, 2) |\n+----------------------+\n|               135.37 |\n+----------------------+\n1 row in set (0.02 sec)\n\n\n\n其他 MySQL 功能LAST_INSERT_IDLAST_INSERT_ID - 获取最后生成的最后一个插入记录的序列号\n-- LAST_INSERT_ID()函数返回已在表中插入或更新的最后一行的AUTO_INCREMENT标识。\n\n-- 语法\nselect LAST_INSERT_ID(expression) from table_name;\n\n-- 如果标中没有id字段，会报错\n\nCASTCAST - 将任何类型的值转换为具有指定类型的值\nSELECT CAST(150 AS CHAR);\n\nCAST(value AS datatype)\n\n\nDATE 转换 value 至今。格式：“YYYY-MM-DD”\nDATETIME 转换 value 到 DATETIME。格式：“YYYY-MM-DD HH：MM：SS”\nTIME 转换 value 到了时间。格式：“HH：MM：SS”\nCHAR 转换 value CHAR（固定长度的字符串）\nSIGNED 转换 value 签名（签名的 64 位整数）\nUNSIGNED 转换 value 到 UNSIGNED（无符号的 64 位整数）\nBINARY 转换 value 到 BINARY（二进制字符串）\n\n更多 MySQL 函数请查看访问：MySQL 函数\n","slug":"2022-12-02mysql-函数","date":"2022-12-02T02:40:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"156cde27ff1fb560c12a994aea6ee11c","title":"7.系统学习 mysql 索引","content":"索引的作用使用索引快速查找具有特定列值的行\n创建\n使用主键或唯一键创建表时，MySQL 会自动创建一个名为 PRIMARY 的特殊索引。索引称为聚簇索引\nPRIMARY 索引是特殊的，因为索引本身与数据一起存储在同一个表中。 聚簇索引强制执行表中的行顺序。\n\n-- 要为列或一组列添加索引，请使用以下CREATE INDEX语句：\n\nCREATE INDEX index_name ON table_name (column_list)\n\n-- 要为列或列列表创建索引，请指定索引名称，索引所属的表以及列列表。\n\n-- 例如，要为列c4添加新索引，请使用以下语句：\nCREATE INDEX idx_c4 ON t(c4);\n-- 默认情况下，如果未指定索引类型，MySQL将创建B-Tree索引\n\n删除-- 要从表中删除现有索引，请使用以下DROP INDEX语句：\n\nDROP INDEX index_name ON table_name\n[algorithm_option | lock_option];\n\n-- DROP PRIMARY KEY索引\n\n-- 要删除PRIMARY主键的索引，请使用以下语句：\n\nDROP INDEX &#96;PRIMARY&#96; ON table_name;\n\n原理：\n\nCOPY：表逐行复制到新表，DROP INDEX 然后在原始表的副本上执行。并发数据操作语句例如 INSERT 和 UPDATE 不允许。\nINPLACE：表被重建到位而不是复制到新表。MySQL 在索引删除操作的准备和执行阶段期间在表上发出独占元数据锁。算法允许并发数据操作语句。\nDEFAULT 与省略 ALGORITHM 子句具有相同的效果\n\n打印-- 方式1\nSHOW INDEXES FROM table_name;\n\n-- 方式2\nSHOW INDEXES FROM table_name\nIN database_name;\n-- 方式3\nSHOW INDEXES FROM database_name.table_name;\n\n-- INDEX和KEY是INDEXES同义词，IN是FROM同义词，因此，您可以在SHOW INDEXES列中使用这些同义词。例如：\n\nSHOW INDEX IN table_name\nFROM database_name;\n\n-- 或者\nSHOW KEY FROM tablename\nIN databasename;\n\n\n\n\n分类唯一索引为什么存在因为主键索引只能有一个，为了能有更多类似主键索引效果的索引\n要强制执行一列或多列的唯一性值，通常使用 PRIMARY KEY 约束。但是，每个表只能有一个主键。\n因此，如果要包含多个列或一组具有唯一值的列，则不能使用主键约束。\n幸运的是，MySQL 提供了另一种指标叫做 UNIQUE 索引，使您可以强制执行值的唯一的一列或多列。与 PRIMARY KEY 索引不同，UNIQUE 每个表可以有多个索引。\n要创建 UNIQUE 索引，请使用以下 CREATE UNIQUE INDEX 语句：\n-- 在一列或多列中强制执行值唯一性的另一种方法是使用 UNIQUE 约束。\n\n-- 方式1: 建表时增\nCREATE TABLE table_name(\n...\n   UNIQUE KEY(index_column_,index_column_2,...)\n);\n-- 方式2: 建表后增\nCREATE UNIQUE INDEX index_name\nON table_name(index_column_1,index_column_2,...);\n\n-- 方式3: 建表修改\n\nALTER TABLE table_name\nADD CONSTRAINT constraint_name UNIQUE KEY(column_1,column_2,...);\n\n前缀索引原因如果列是字符串列，则索引将占用大量磁盘空间并可能减慢 INSERT 操作速度。\n为解决此问题，MySQL 允许您使用以下语法为字符串列的列值的前导部分创建索引：\n-- 在创建表时创建列前缀键部分\nCREATE TABLE table_name(\n    column_list,\n    INDEX(column_name(length))\n);\n\n-- 向现有表添加索引\nCREATE INDEX index_name\nON table_name(column_name(length));\n\n-- 使用\nSELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;\n\n\n优化前\n\n优化后\n\n评估优化(长度如何定，试出来的)我们将使用示例数据库中的 products 表进行演示。\n+--------------------+\n| products |\n+--------------------+\n| productCode |\n| productName |\n| productLine |\n| productScale |\n| productVendor |\n| productDescription |\n| quantityInStock |\n| buyPrice |\n| MSRP |\n+--------------------+\n9 rows in set (0.02 sec)\n\n\n以下查询查找名称以字符串 1970 开头的产品：\nSELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;\n\n\n由于 productName 列没有索引 ，查询优化器必须扫描所有行以返回结果，如 EXPLAIN 下面语句的输出所示：\nEXPLAIN SELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;\n\n这是输出：\n+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | products | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  110 |    11.11 | Using where |\n+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.02 sec)\n\n如果您经常按产品名称找到产品，那么您应为此列创建索引，因为它对搜索更有效。\n产品名称列的大小为 70 个字符。我们可以使用列前缀关键部分。\n接下来的问题是你如何选择前缀的长度？为此，您可以调查现有数据。目标是在使用前缀时最大化列中值的唯一性。\n为此，请按照下列步骤操作：\n步骤 1.找到表中的行数：\nSELECT\n   COUNT(*)\nFROM\n   products;\n\n第 2 步。评估不同的前缀长度，直到您可以实现行的合理唯一性：\nSELECT\n   COUNT(DISTINCT LEFT(productName, 20)) unique_rows\nFROM\n   products;\n+-------------+\n| unique_rows |\n+-------------+\n|         110 |\n+-------------+\n1 row in set (0.30 sec)\n\n如输出中所示，在这种情况下，20 是一个良好的前缀长度，因为如果我们使用产品名称的前 20 个字符作为索引，则所有产品名称都是唯一的。\n让我们为 productName 列创建一个前缀长度为 20 的索引：\nCREATE INDEX idx_productname\nON products(productName(20));\n\n\n并执行查询，查找名称以字符串 1970 开头的产品：\nEXPLAIN SELECT\n    productName,\n    buyPrice,\n    msrp\nFROM\n    products\nWHERE\n    productName LIKE &#39;1970%&#39;;\n\n\n+----+-------------+----------+------------+-------+-----------------+-----------------+---------+------+------+----------+-------------+\n| id | select_type | table    | partitions | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+----------+------------+-------+-----------------+-----------------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | products | NULL       | range | idx_productname | idx_productname | 62      | NULL |    4 |   100.00 | Using where |\n+----+-------------+----------+------------+-------+-----------------+-----------------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.02 sec)\n\n现在，查询优化器使用新创建的索引，索引比以前更快，更高效。\n隐形索引（就当 disabled 吧）为什么存在为了将某些索引停用，来看这个索引是否对性能有影响\n不可见索引允许您将索引标记为查询优化器不可用\n\n默认可见的。\n使不可见，您必须在创建时或使用ALTER TABLE命令显式声明其可见性。MySQL 为我们提供了维护索引可见性的关键字VISIBLE和INVISIBLE关键字。\n\n要创建不可见索引，请使用以下语句：\nCREATE INDEX index_name\nON table_name( c1, c2, ...) INVISIBLE;\n\n\n-- 在这个语法中：\n\n-- 首先，在CREATE INDEX子句后指定索引的名称。\n-- 其次，列出要添加到索引的表名和列列表。INVISIBLE关键字表明您正在创建的索引是不可见的。\n-- 例如，以下语句在示例数据库extension中的employees表的列上创建索引，并将其标记为不可见索引：\n\nCREATE INDEX extension\nON employees(extension) INVISIBLE;\n\n-- 要更改现有索引的可见性，请使用以下语句：\n\nALTER TABLE table_name\nALTER INDEX index_name [VISIBLE | INVISIBLE];\n\n-- 例如，要使extension索引可见，请使用以下语句：\nALTER TABLE employees\nALTER INDEX extension VISIBLE;\n-- 您可以通过查询information_schema数据库中的statistics表来查找索引及其可见性：\n\nSELECT\n    index_name,\n    is_visible\nFROM\n    information_schema.statistics\nWHERE\n    table_schema &#x3D; &#39;mysqldemo&#39;\n        AND table_name &#x3D; &#39;employees&#39;;\n\n\n\n此外，您可以使用 SHOW INDEXES 命令显示表的所有索引：\nSHOW INDEXES FROM employees;\n\n\n\n\n如前所述，查询优化器不使用不可见索引，那么为什么首先使用不可见索引？实际上，隐形索引有许多应用程序。\n例如，您可以使索引不可见，以查看它是否对性能产生影响，并将索引再次标记为可见。\n主键索引不可隐藏降序索引\n为了对ORDER BY a DESC进行优化\n降序索引是以降序存储键值的索引。\n在 MySQL 8.0 之前，您可以 DESC 在索引定义中指定。但是，MySQL 忽略了它。\n与此同时，MySQL 可以以相反的顺序扫描索引，但成本很高。\n\n复合索引\n复合索引是多列的索引。MySQL 允许您创建一个最多包含 16 列的复合索引。\n复合索引也称为多列索引。\n查询优化器将复合索引用于测试索引中所有列的查询，或者测试第一列，前两列等的查询。\n如果在索引定义中以正确的顺序指定列，则单个复合索引可以在同一个表上加速这些类型的查询\n\n-- 要在创建表时创建复合索引，请使用以下语句：\n\nCREATE TABLE table_name (\n    c1 data_type PRIMARY KEY,\n    c2 data_type,\n    c3 data_type,\n    c4 data_type,\n    INDEX index_name (c2,c3,c4)\n);\n-- 在此语法中，复合索引由三列c2，c3和c4组成。\n\n-- 或者，您可以使用以下CREATE INDEX语句将复合索引添加到现有表：\n\nCREATE INDEX index_name\nON table_name(c2,c3,c4);\n-- 请注意，如果您在（c1，c2，c3）上有复合索引，则您将在以下列组合之一上建立索引搜索功能：\n\n(c1)\n(c1,c2)\n(c1,c2,c3)\n\n\n聚集索引\n每个 InnoDB 表始终只有一个聚簇索引\n有主键 MySQL 使用主键作为聚簇索引。\n无主键，MySQL 将搜索 UNIQUE 所有键列所在的第一个索引，NOT NULL 并将此 UNIQUE 索引用作聚簇索引\n无主键，没唯一，自动生成隐藏聚簇索引GEN_CLUST_INDEX,索引在包含行 ID 值的合成列上命名。\n除聚簇索引之外的所有索引都是非聚簇索引或二级索引\n\n索引基数（Cardinality）作用索引基数是指存储在索引中指定列中的值的唯一性。\nMySQL 基于存储为整数的统计信息生成索引基数，因此，值可能不一定精确。\n查询优化器使用索引基数为给定查询生成最佳查询计划。它还使用索引基数来决定是否在连接操作中使用索引。\n如果查询优化器选择具有低基数的索引，则它可能比不使用索引扫描行更有效。 Cardinality 越低越好\n\n\n索引统计信息仅是近似值，可能不代表表中行的实际大小。要生成更准确的统计信息，请使用 ANALYZE TABLE 命令。\nUSE INDEX指定索引，mysql 默认会自动选择索引使用，自己也可以指定自己认为的最优索引，当然也不一定就真的最优\n作用为了确定最佳可能的计划，查询优化器使用了许多参数。选择使用哪个索引的最重要参数之一是存储密钥分发，也称为基数。\n但是，基数可能不准确，例如，如果表已经被许多插入或删除严重修改。\n要解决此问题，应 ANALYZE TABLE 定期运行语句以更新基数。\n此外，MySQL 提供了一种替代方法，允许您通过使用调用的索引提示来推荐查询优化器应使用的索引 USE INDEX。\n-- 以下说明了MySQL USE INDEX提示的语法：\n\nSELECT select_list\nFROM table_name USE INDEX(index_list)\nWHERE condition;\n\n-- 在此语法中，USE INDEX指示查询优化器使用其中一个命名索引来查找表中的行。\n\n\n\n\n\n\n\n\nWARNING\n注意：当您建议使用索引时，查询优化器可能会决定是否使用它们，具体取决于它所提供的查询计划。\n\n\nUSE INDEX\nFORCE INDEX如果查询优化器忽略索引，您可以使用 FORCE INDEX 提示来指示它使用索引。\n原因查询可能会请求价格在 10 到 80 之间的产品。如果统计数据显示 80％的产品具有这些价 ​​ 格范围，那么它可能会认为全表扫描效率最高。但是，如果统计数据显示很少有产品具有这些价 ​​ 格范围，那么读取索引后跟表访问可能比全表扫描更快，更有效\n近似全表查询，mysql 会直接进行全表扫描\n可能查询优化器忽略索引，不让其忽略，需要强制指定索引\nSELECT *\nFROM table_name\nFORCE INDEX (index_list)\nWHERE condition;\n\nSHOW INDEXES FROM products;\n\n\n\n要查找价格在 10 到 80 之间的产品，请使用以下语句：\n\nSELECT\n    productName,\n    buyPrice\nFROM\n    products\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;\n\n您可以猜测，要返回产品，查询优化器必须扫描整个表，因为 buyPrice 列没有可用的索引：\nEXPLAIN SELECT\n    productName,\n    buyPrice\nFROM\n    products\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;\n\n\n\n让我们为 buyPrice 列创建一个索引：\n\nCREATE INDEX idx_buyprice ON products(buyPrice);\n\n\n然后再次执行查询：\n\nEXPLAIN SELECT\n    productName,\n    buyPrice\nFROM\n    products\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;\n\nbuyPrice 即使索引存在，查询优化也不使用列的索引。原因是查询返回 products 表中 110 行中的 94 行，因此，查询优化器决定执行全表扫描。要强制查询优化器使用 idx_buyprice 索引，请使用以下查询：\nSELECT\n    productName, buyPrice\nFROM\n    products\nFORCE INDEX (idx_buyPrice)\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;\n\n这次，索引用于查找产品，如下面的 EXPLAIN 语句所示：\nEXPLAIN SELECT\n    productName, buyPrice\nFROM\n    products\nFORCE INDEX (idx_buyprice)\nWHERE\n    buyPrice BETWEEN 10 AND 80\nORDER BY buyPrice;\n\n\n\n索引失效\nlike 语句中，复合索引可能失效\nwhere 语句中，查部分数据，索引失效（原因：mysql，查询优化器搞的鬼，自定执行全表扫描，需要使用 force index）\n查询优化器自动优化，不一定是最优的查询计划，如需指定需要使用 use index\n\n","slug":"2022-12-01mysql-索引","date":"2022-12-01T01:55:23.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"e534e8fd944f5586c5ed602b0ca27489","title":"6.系统学习 mysql 集合","content":"并集 UNIONMySQL UNION 运算符允许您将两个或多个查询结果集合并到一个结果集中要使用 UNION 运算符组合两个或多个查询的结果集，必须遵循以下基本规则：\n\n首先，所有 SELECT 语句中出现的列的数量和顺序 必须相同。\n其次，列的数据类型必须相同或可转换。\n默认情况下， 即使您未明确指定 DISTINCT 运算符，UNION 运算符也会删除 重复的行。\n\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\n\nCREATE TABLE t1 (\n    id INT PRIMARY KEY\n);\n\nCREATE TABLE t2 (\n    id INT PRIMARY KEY\n);\n\nINSERT INTO t1 VALUES (1),(2),(3);\nINSERT INTO t2 VALUES (2),(3),(4);\n\n\nSELECT id\nFROM t1\nUNION ALL -- 重复项出现在组合结果集中\nSELECT id\nFROM t2;\n\nUNION vs. JOIN\nJOIN 是水平组合结果集，\nUNION 是垂直附加结果集。下图说明了 UNION 和之间的区别 JOIN：\n\n\n\n交集(MySQL 不支持 INTERSECT 操作符)INTERSECT 运算符是一个集合运算符仅返回两个查询或多个查询的不同行。\n以下说明了 INTERSECT 运算符的语法。\n(SELECT column_list FROM table_1)\nINTERSECT\n(SELECT column_list FROM table_2);\n\n\nINTERSECT 运算符比较两个查询的结果，并返回作为由左，右输出的查询的不同的行。\n要将 INTERSECT 运算符用于两个查询，应用以下规则：\n\n列的顺序和数量必须相同。\n相应列的数据类型必须兼容。\n\n\n\nCREATE TABLE t1 (\n    id INT PRIMARY KEY\n);\n\nCREATE TABLE t2 LIKE t1;\n\nINSERT INTO t1(id) VALUES(1),(2),(3);\n\nINSERT INTO t2(id) VALUES(2),(3),(4);\n\n-- MySQL不支持INTERSECT操作符\n(SELECT id\nFROM t1)\nINTERSECT\n(SELECT id\nFROM t2);\n\ndistinct + INNER JOIN 模拟SELECT DISTINCT\n   id\nFROM t1\n   INNER JOIN t2\nUSING(id);\n\n使用 IN 运算符和子查询模拟SELECT DISTINCT\n    id\nFROM\n    t1\nWHERE\n    id IN\n    (SELECT id FROM t2);\n\n差集 MINUS (mysql 不支持 MINUS）MINUS 比较两个查询的结果，并返回第一个查询中不是由第二个查询输出的不同行。\n以下说明了 MINUS 运算符的语法：\nSELECT column_list_1 FROM table_1\nMINUS\nSELECT columns_list_2 FROM table_2;\n\n使用 MINUS 运算符的查询的基本规则如下：\n\n数量和两列的顺序 column_list_1 和 column_list_2 必须相同。\n两个查询中相应列的数据类型必须兼容。\n\n\n\n假设我们有两个表 t1 并 t2 具有以下结构和数据：\nCREATE TABLE t1 (\n    id INT PRIMARY KEY\n);\n\nCREATE TABLE t2 (\n    id INT PRIMARY KEY\n);\n\nINSERT INTO t1 VALUES (1),(2),(3);\nINSERT INTO t2 VALUES (2),(3),(4);\n\n以下查询返回 t1 表的查询中的不同值，这些值在表的查询结果中找不到 t2。\nSELECT id FROM t1\nMINUS\nSELECT id FROM t2;\n\n模拟 1SELECT id\nFROM t1\n\tLEFT JOIN t2 USING (id)\nWHERE t2.id IS NULL;\n\n模拟 2","slug":"2022-11-30mysql-set","date":"2022-11-30T13:28:00.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"50df4ae65a1c6c2ab192fc07c4455498","title":"5.系统学习 mysql erd","content":"ERER 实体关系 Entity RelationshipER 图鱼尾符号demo1\n\n见\ndemo2\n\n见\nvscode vuerd-vscode 插件自动生成这个图是自动生成的，\n1 对多0&#x2F;1 对多\n这些事如何在 sql 中体现的？难道是对数据进行分析\n\n\nvuerd-vscode golang 实体生成（需要自己写脚本）vuerd-vscode 源码看下，是否有搂表的代码\n\n\n以下内容不完整，我还没改呢，暂时先放着，有空的时候来写\n[DATA]\n  .reduce((buffer, data) &#x3D;&gt; &#123;\n    const state &#x3D; data.state;\n    const helper &#x3D; data.helper;\n    const dataTypes &#x3D; data.dataTypes;\n\n    const tableState &#x3D; state.tableState;\n    const canvasState &#x3D; state.canvasState;\n    &#x2F;&#x2F; 类型映射\n    const convertTypeMap &#x3D; &#123;\n      int: &quot;number&quot;,\n      long: &quot;number&quot;,\n      float: &quot;number&quot;,\n      double: &quot;number&quot;,\n      decimal: &quot;number&quot;,\n      boolean: &quot;boolean&quot;,\n      string: &quot;string&quot;,\n      lob: &quot;string&quot;,\n      date: &quot;string&quot;,\n      dateTime: &quot;string&quot;,\n      time: &quot;string&quot;,\n    &#125;;\n\n    const getType &#x3D; (name) &#x3D;&gt; &#123;\n      const dataType &#x3D; dataTypes.find(\n        (dataType) &#x3D;&gt;\n          name.toLowerCase().indexOf(dataType.name.toLowerCase()) &#x3D;&#x3D;&#x3D; 0\n      );\n      return dataType ? dataType.type : &quot;string&quot;;\n    &#125;;\n\n    const getNameCase &#x3D; (name, nameCase) &#x3D;&gt; &#123;\n      let changeName &#x3D; name;\n      switch (nameCase) &#123;\n        case &quot;camelCase&quot;:\n          changeName &#x3D; helper.camelCase(name);\n          break;\n        case &quot;pascalCase&quot;:\n          changeName &#x3D; helper.pascalCase(name);\n          break;\n        case &quot;snakeCase&quot;:\n          changeName &#x3D; helper.snakeCase(name);\n          break;\n      &#125;\n      return changeName;\n    &#125;;\n\n    const orderByNameASC &#x3D; (tables) &#x3D;&gt;\n      tables.sort((a, b) &#x3D;&gt; &#123;\n        const nameA &#x3D; a.name.toLowerCase();\n        const nameB &#x3D; b.name.toLowerCase();\n        if (nameA &lt; nameB) &#123;\n          return -1;\n        &#125; else if (nameA &gt; nameB) &#123;\n          return 1;\n        &#125;\n        return 0;\n      &#125;);\n    &#x2F;&#x2F; 格式化表\n    function formatTable(table) &#123;\n      const tableName &#x3D; getNameCase(table.name, canvasState.tableCase);\n      if (table.comment.trim() !&#x3D;&#x3D; &quot;&quot;) &#123;\n        buffer.push(&#96;&#x2F;&#x2F; $&#123;table.comment&#125;&#96;);\n      &#125;\n      buffer.push(&#96;type $&#123;tableName&#125; &#123;&#96;);\n      table.columns.forEach((column) &#x3D;&gt; &#123;\n        formatColumn(column);\n      &#125;);\n      buffer.push(&#96;&#125;&#96;);\n    &#125;\n    &#x2F;&#x2F; 格式化列\n    function formatColumn(column) &#123;\n      const columnName &#x3D; getNameCase(column.name, canvasState.columnCase);\n      &#x2F;&#x2F; 生成类型\n      const typeName &#x3D; getType(column.dataType);\n      if (column.comment.trim() !&#x3D;&#x3D; &quot;&quot;) &#123;\n        buffer.push(&#96;  &#x2F;&#x2F; $&#123;column.comment&#125;&#96;);\n      &#125;\n      buffer.push(\n        &#96;  $&#123;columnName&#125;: $&#123;convertTypeMap[typeName]&#125;$&#123;\n          column.option.notNull ? &quot;&quot; : &quot; | null&quot;\n        &#125;;&#96;\n      );\n    &#125;\n\n    orderByNameASC(tableState.tables);\n\n    tableState.tables.forEach((table) &#x3D;&gt; &#123;\n      formatTable(table);\n      buffer.push(&quot;&quot;);\n    &#125;);\n\n    return buffer;\n  &#125;, [])\n  .join(&quot;\\n&quot;);\n\n参考链接ER 图鱼尾符号\nER 图的表示法\n","slug":"2022-11-30mysql-erd","date":"2022-11-30T09:13:32.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"968e01e6b4020ddd66a1e79ae770349d","title":"4.系统学习 mysql 事务","content":"事务为什么需要事务MySQL 事务允许您执行一组 MySQL 操作，以确保数据库永远不会包含部分操作的结果。\n\n在一组操作中，如果其中一个操作失败，则会发生回滚以将数据库还原到其原始状态。\n如果没有发生错误，则将整个语句集提交给数据库。\n\n事务特点事务是必须满足 4 个条件(ACID)：\n原子性(Atomicity): 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。\n一致性(Consistency):在事务开始之前和事务结束以后，数据库的完整性没有被破坏。应用系统应该从一个正确的状态到另一个正确的状态,这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n隔离性(Isolation):数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。防止出现：脏读、幻读、不可重复读。\n持久性(Durability):事务处理结束后，对数据的修改就是永久的。————————————————版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xyy1028/article/details/106165503\nmysql 隔离机制为了实现事务隔离性\n\n\n见\n并发导致事务隔离性出问题a.如果两个事务并发的修改则必须隔离开。\nb.如果两个事务并发的查询则完全不用隔离。\nc.如果一个事务修改，另一个事务查询，则可能出现脏读、不可重复读、幻读的情况，隔离级别主要针对这种情况。\n脏读、不可重复读、幻读\n脏读：一个事务读取到另一个事务未提交的数据。\n\n不可重复读：一个事务读取到另一个事务已经提交的数据。例如事务 A 读取了一条记录，此时事务 B 修改了该条数据并提交成功，事务 A 再次查询该条数据发现与第一次读取的不一样，即为不可重复度（同一个事务内重复读取的数据不一样，则理解成不可重复读）。\n\n幻读：一个事务读取到另一个事务已经提交的数据，但与不可重复读不同的是，不可重复读的原因在于 update，而幻读源于其他事务 insert 或 delete 了记录导致记录条数不一致。\n\n\n\n不可重复读的原因在于 update，\n幻读源于其他事务 insert 或 delete 了记录导致记录条数不一致。\n\n见\n针对上面的三个问题，四大隔离级别：读未提交(read uncommitted) : 不作任何隔离，具有脏读、不可重复读、幻读问题\n读已提交(read committed) : 可防止脏读，不能防止不可重复读和幻读问题\n可重复读(repeatable read) : 可以防止脏读、不可重复读，不能防止幻读问题（mysql 默认是这个隔离级别）\n串行化(serializable) : 数据库运行在串行化，上述问题都可以防止，只是性能非常低————————————————版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xyy1028/article/details/106165503\n\n\n这几个级别是什么意思，为什么这么命名？\n读未提交(read uncommitted) 事务 A 读到了事务 B 未提交的数据\n读已提交(read committed)  事务 A 读到了事务 B 已提交的数据\n可重复读(repeatable read) ，事务 A 读到了快照，与事务 B 操作无关\n\n可重复读级别出现读不到，但却可更新为什么是这样呢？\n要了解这个原因,则还需要知道另一个概念:MVCC\nMVCC为什么存在是为了解决rc和rr现象，效率高开销低，避免加锁，设计的\n\n\n\n\n\n\n\n\n\nMVCC 全称 Mutli Version Concurreny Control，多版本并发控制，是 MySQL 中基于乐观锁理论实现隔离级别的方式，用于实现读已提交(read committed)和可重复读(repeatable read)隔离级别的实现。它通过行的多版本控制方式来读取当前执行时间数据库中的行数据。原理是将数据保存在某个时间点(版本号)的快照来实现的，MySQL 中 MVCC 的实现方式是在数据库保存最新版本的数据，但是会在使用 undo 时动态重构旧版本数据。这样就可以实现不加锁读。\nMVCC 可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此效率高开销低。MVCC 实现了非阻塞的读操作，写操作也只锁定必要的行。\nInnoDB 的 MVCC 实现机制\n\n\n\n\n\n\n\n\nInnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。\n当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在可重复读(repeatable read)隔离级别下，MVCC 具体是如何操作的：\nMySQL 中，会在表中每一条数据后面添加两个隐藏字段:创建版本号： 创建一行数据时，将当前系统版本号作为创建版本号赋值删除版本号： 删除一行数据时，将当前系统版本号作为删除版本号赋值\n在 RR 隔离级别下，MVCC 的操作如下:select 读取数据的规则必须同时满足以下两个条件：\na. 创建版本号 &lt;&#x3D; 当前事务版本号:\nInnoDB 只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务本身插入或者修改过的。（这也是我们为什么在可重复读隔离级别下,读操作不会查到其他事务新增的数据,但是进行修改操作后却读出了三条数据的原因）\nb. 删除版本号为空 或 &gt; 当前事务版本号:\n这可以确保事务读取到的行，在事务开始之前未被删除。\ninsert 操作:InnoDB 为新插入的每一行保存当前系统版本号作为行的创建版本号。\ndelete 操作:InnoDB 为删除的每一行保存当前系统版本号作为行的删除版本号。\nupdate 操作:插入一条新记录，保存当前系统版本号为行创建版本号，同时保存当前系统版本号到原来的行删除版本号，实际上这里的更新是通过 delete 和 insert 实现的。\n快照读和当前读MVCC 机制虽然让数据可重复读\n\n有时我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读(snapshot read)，\n而读取数据库最新版本数据的方式，叫当前读 (current read)。\n\n快照读：当执行 select 操作时 innodb 默认会执行快照读，会记录下这次 select 后的结果，之后 select 的时候就会返回这次快照的数据，即使其他事务提交了也不会影响当前 select 的数据，这就实现了可重复读了。\n如上所示，开启了事务 A、B、C，\n\n这时候事务 A 插入了一条数据然后提交,\n然后事务 C 这时候执行 select，那么返回的数据中就会有事务 A 添加的那条数据。\n但是之后无论再有其他事务插入并提交数据都没有关系，因为快照已经生成了，事务 C 后面的 select 都是根据快照来的。\n\n当前读：对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要更新一条记录，但是在另一个事务中已经删除掉这条数据并且提交了，如果更新就会产生冲突，所以在 update 的时候需要知道最新的数据。\nselect 的当前读需要手动的加锁：select _ from user lock in share mode;\nselect _ from user for update;\n\n综上所述，在快照读读情况下，MySQL 通过 MVCC 可以避免幻读。但是在当前读情况下幻读依然存在，所以说 MVCC 对于幻读的解决是不彻底的\n————————————————版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xyy1028/article/details/106165503\n那么如何彻底解决幻读法一：使用串行化读的隔离级别，但该方法效率太低。\n法二：我们先大概看看 mysql InnoDB 引擎下的行锁:\nRecord lock：单个行记录上的锁Gap lock：间隙锁，锁定一个范围，不包括记录本身Next-key lock：Record + Gap 锁定一个范围，包含记录本身 【可能导致死锁现象】\n在纯粹的读操作时,Innodb 用 MVCC 解决幻读问题,新的 insert 和 update 不会阻塞。在涉及到写操作时,Innodb 用 MVCC 和 Next-key lock 解决幻读问题,新的 insert 和 update 会阻塞。\n当我们为 select 后加上 for update 或者 lock in share mode,则查找到的行会被加上 Next-key lock\n表锁定\n读锁是“共享”锁，它可以防止正在获取写锁，但不能锁定其他读锁。\n写锁是“独占”锁，可以防止任何其他类型的锁。\n如果会话正常或异常终止，MySQL 将隐式释放所有锁。此功能也与 WRITE 锁相关。\n\n-- 要锁定表，请在LOCK TABLES关键字后指定其名称。此外，您可以指定锁的类型，可以是   READ或  WRITE。\nLOCK TABLES table_name [READ | WRITE]\n-- 要释放表的锁，请使用以下语句：\nUNLOCK TABLES;\n\n-- SHOW PROCESSLIST查看详细信息。\n\nmysql&gt; SHOW PROCESSLIST;\n+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+\n| Id   | User | Host            | db        | Command | Time | State                        | Info                            |\n+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+\n| 4884 | root | localhost:64108 | mysqldemo | Sleep   | 1479 |                              | NULL                            |\n| 4892 | root | localhost       | mysqldemo | Query   |    0 | init                         | SHOW PROCESSLIST                |\n| 4896 | root | localhost       | mysqldemo | Query   |   97 | Waiting for table level lock | INSERT INTO tbl(col) VALUES(20) |\n+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+\n3 rows in set (0.00 sec)\n\n\n行锁&#x2F;记录锁&#x2F;间隙锁&#x2F;表锁\n行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。\n\nselect * from performance_schema.data_locks\\G;\n-- 这条语句，查看事务执行 SQL 过程中加了什么锁\n\nLOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，\n通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：\n\n如果 LOCK_MODE 为 X，说明是 X 型的 next-key 锁；\n如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是 X 型的记录锁；\n如果 LOCK_MODE 为 X, GAP，说明是 X 型的间隙锁；\n\n作者：小林 coding链接：https://www.zhihu.com/question/437140380/answer/2619527535来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n锁的退化\n如果表中最后一个记录的 order_no 为 1005，那么等值查询 order_no &#x3D; 1006（不存在），就是 next key lock，如上面事务 A 的情况。\n如果表中最后一个记录的 order_no 为 1010，那么等值查询 order_no &#x3D; 1006（不存在），就是间隙锁\n\n-- 当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id &#x3D; 1008 的记录就会被锁住：\n--\nInsert into t_order (order_no, create_date) values (1008, now());\n\n而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 select … for update 语句并不会相互影响。\n作者：小林 coding链接：https://www.zhihu.com/question/437140380/answer/2619527535来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nMySQL 死锁产生的原因和解决方法产生的条件因争夺资源而造成的一种互相等待的现象\n死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。\nMySQL 死锁产生的原因和解决方法\n规避措施在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：\n\n设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。\n开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。\n\n作者：小林 coding链接：https://www.zhihu.com/question/437140380/answer/2619527535来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n参考链接Mysql 事务\n","slug":"2022-11-30mysql-事务","date":"2022-11-30T06:04:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"c0939ae244a4c8b0accf26e60862ce5e","title":"3.系统学习 mysql CRUD","content":"增INSERT &#x2F; INSERT INTO SELECT\n单行插入\n多行插入\n默认值插入\n日期值插入\n\n-- 单行&#x2F;多行插入\nINSERT INTO table_name(c1,c2,...)\nVALUES(v1,v2,..);\n\n\n-- 多行插入\nINSERT INTO table_name(column_list)\nSELECT\n   select_list\nFROM\n   another_table;\n\nDELETE &#x2F; ON DELETE CASCADE &#x2F; DELETE JOIN\n从表中删除数据外，DELETE 语句还返回已删除的行数\n要使用单个 DELETE 语句从多个表中删除数据，请使用 DELETE JOIN 我们将在下一个教程中介绍的语句。\n要删除表中的所有行而不需要知道删除了多少行，应使用 TRUNCATE TABLE 语句来获得更好的性能。\n对于具有外键约束的表，当从父表中删除行时，将使用 ON DELETE CASCADE 选项自动删除子表中的行。\n\n\n\n\n\n\n\n\nWARNING\n注意：WHERE 子句是可选项。如果省略 WHERE 子句，DELETE 语句将删除表中的所有行。\n\nDELETE FROM table_name\nWHERE condition;\n\n-- DELETE语句选择客户France，按信用额度从低到高对其进行排序，并删除前5个客户：\nDELETE FROM customers\nWHERE country &#x3D; &#39;France&#39;\nORDER BY creditLimit\nLIMIT 5;\n\n\n跨表删除\n-- ON DELETE CASCADE\n-- 关联表父表删除，子表也删除\n-- 多个相关表的单个DELETE语句，子表具有对外键的 ON DELETE CASCADE引用操作\n\n-- 使用INNER JOIN语句中的子句DELETE删除表中的行和另一个表中的匹配行\n\n\n关联表删除DROP TABLE IF EXISTS t1, t2;\n\nCREATE TABLE t1 (\n    id INT PRIMARY KEY AUTO_INCREMENT\n);\n\nCREATE TABLE t2 (\n    id VARCHAR(20) PRIMARY KEY,\n    ref INT NOT NULL\n);\n\nINSERT INTO t1 VALUES (1),(2),(3);\n\nINSERT INTO t2(id,ref) VALUES(&#39;A&#39;,1),(&#39;B&#39;,2),(&#39;C&#39;,3);\n\n-- 删除t1表中id为1的行，并使用DELETE...INNER JOIN语句删除在t2表中ref &#x3D; 1的行\nDELETE t1,t2\n   FROM t1\n      INNER JOIN t2 ON t2.ref &#x3D; t1.id\nWHERE\n    t1.id &#x3D; 1;\n\n-- 声明返回以下消息：\n\n-- 2 row(s) affected\n\n-- 它表明已删除了两行。\n\n使用 LEFT JOIN 删除 JOIN语法\n-- 使用SELECT语句中的 LEFT JOIN子句来查找左表中的行，这些行在右表中有或没有匹配的行。\n-- 使用DELETE语句中的LEFT JOIN子句删除表（左表）中的行，这些行在另一个表（右表）中没有匹配的行\n\nDELETE T1\nFROM T1\n   LEFT JOIN T2 ON T1.key &#x3D; T2.key\nWHERE\n    T2.key IS NULL;\n\n例子\n-- 每个客户都有零个或多个订单。但是，每个订单属于一个且只有一个客户。\n\n-- 我们可以使用DELETE和 LEFT JOIN子句来清理客户主数据。以下语句删除未下订单的客户：\n\nDELETE customers\nFROM customers\n        LEFT JOIN\n    orders ON customers.customerNumber &#x3D; orders.customerNumber\nWHERE\n    orderNumber IS NULL;\n\n\n在这个声明中：\n\n首先，指定从中删除数据的表。\n其次，使用条件指定 WHERE 子句中要删除的行。如果行符合条件，则将删除行。\n注意：WHERE 子句是可选项。如果省略 WHERE 子句，DELETE 语句将删除表中的所有行。\n返回删除行: 除了从表中删除数据外，DELETE 语句还返回已删除的行数。\n多表删除: 要使用单个 DELETE 语句从多个表中删除数据，请使用 DELETE JOIN 将在下一个教程中介绍的语句。\n提高删除性能: 要删除表中的所有行而不需要知道删除了多少行，应使用 TRUNCATE TABLE 语句来获得更好的性能。\n约束删除: 对于具有外键约束的表，当从父表中删除行时，将使用 ON DELETE CASCADE 选项自动删除子表中的行。\n\n这里有个问题，\n\n不自动删除子表: 如果不想删除对应的子表，应该先取消关联，然后执行删除\n自动删除子表: ON DELETE CASCADE 选项自动删除子表中的行\n\n查找受 MySQL ON DELETE CASCADE 操作影响的表的提示, 没懂(TODO:)\nUPDATE &#x2F; UPDATE JOINUPDATE感觉不是很懂(TODO:)\n-- 用UPDATE语句更新表中的现有数据\nUPDATE [LOW_PRIORITY] [IGNORE] table_name\nSET\n    column_name1 &#x3D; expr1,\n    column_name2 &#x3D; expr2,\n    ...\n[WHERE\n    condition];\n\n\n\nUPDATE 声明：\n\n首先，指定要在 UPDATE 关键字后更新数据的表名。\n其次，SET 子句指定要修改的列和新值。要更新多个列，请使用逗号分隔的分配列表。可以以文字值，表达式或子查询的形式在每列的赋值中提供值。\n第三，使用 WHERE 子句中的条件指定要更新的行。WHERE 子句是可选项。如果省略 WHERE 子句，UPDATE 语句将更新表中的所有行。\n\n\n\n\n\n\n\n\nWARNING\n注意： WHERE 子句非常重要，可能只想改变一行; 但是，可能会忘记 WHERE 子句并意外更新表的所有行。\n\nMySQL 在 UPDATE 语句中支持两个修饰符。\n\nLOW_PRIORITY 修正指示 UPDATE 延迟更新，直到没有连接从表中读取数据的语句。\nLOW_PRIORITY 只对表级锁的存储引擎使用生效，例如，MyISAM 数据，MERGE，MEMORY。\nIGNORE 修改使 UPDATE 语句继续更新，即使发生错误的行。导致错误（例如重复键冲突）的行不会更新。\n\n使用查询结果作为更新后的值(找现成的用)UPDATE customers\nSET\n    salesRepEmployeeNumber &#x3D; (SELECT\n            employeeNumber\n        FROM\n            employees\n        WHERE\n            jobtitle &#x3D; &#39;Sales Rep&#39;\n        LIMIT 1)\nWHERE\n    salesRepEmployeeNumber IS NULL;\n\nUPDATE JOIN跨表更新\nUPDATE T1, T2,\n[INNER JOIN | LEFT JOIN] T1 ON T1.C1 &#x3D; T2. C1\nSET T1.C2 &#x3D; T2.C2,\n    T2.C3 &#x3D; expr\nWHERE condition\n\n\n\n-- 这个与下面那个等效（骚操作？）\nUPDATE T1, T2\nSET T1.c2 &#x3D; T2.c2,\n      T2.c3 &#x3D; expr\nWHERE T1.c1 &#x3D; T2.c1 AND condition\n-- 此UPDATE  语句UPDATE JOIN  与隐式INNER JOIN  子句的作用相同\n\n\nUPDATE T1,T2\nINNER JOIN T2 ON T1.C1 &#x3D; T2.C1 --这句\nSET T1.C2 &#x3D; T2.C2,\n      T2.C3 &#x3D; expr\nWHERE condition\n-- 让我们看一下使用UPDATE JOIN  语句进行更好理解的一些示例\n\n\n-- INNER JOIN\nUPDATE employees\n        INNER JOIN\n       merits\n        ON employees.performance &#x3D; merits.performance\nSET\n    salary &#x3D; salary + salary * percentage;\n\n-- LEFT JOIN\nUPDATE\n  employees\n  LEFT JOIN merits ON employees.performance &#x3D; merits.performance\nSET\n  salary &#x3D; salary + salary * 0.015\nWHERE\n  merits.percentage IS NULL;\n\n\nREPLACEMySQL REPLACE 语句是标准 SQL 的 MySQL 扩展。MySQL REPLACE 语句的工作原理如下：\n\n如果新行已不存在，则 MySQL REPLACE 语句将插入新行。\n如果新行已存在，则 REPLACE 语句首先删除旧行，然后插入新行。在某些情况下，REPLACE 语句仅更新现有行。\n要确定表中是否已存在新行，MySQL 使用 PRIMARY KEY 或 UNIQUE KEY 索引。如果表没有这些索引之一，则 REPLACE 语句等同于 INSERT 语句。\n\n使用 MySQL REPLACE 的语句，你需要有至少两个 INSERT 和 DELETE 权限。\n注意：有一个 REPLACE 字符串函数 ，它不是 REPLACE 本教程中介绍的语句。\n\n和插入语法类似， 除了关键字 INSERT 被关键字替换 REPLACE\n未出现在 REPLACE 语句中的列的默认值将插入到相应的列中。如果列具有 NOT NULL 属性且没有默认值，并且未在 REPLACE 语句中指定值，则 MySQL 将引发错误\n\n类似于 INSERTREPLACE 语句的第一种形式类似于 INSERT 语句，除了关键字 INSERT 被关键字替换 REPLACE 如下：\nREPLACE INTO table_name(column_list)\nVALUES(value_list);\n\n例如，如果要在 cities 表中插入新行，请使用以下查询：\nREPLACE INTO cities(name,population)\nVALUES(&#39;Phoenix&#39;,1321523);\n\n\n\n\n\n\n\n\n\nWARNING\n注意：\nREPLACE 和 INSERT 语句之间的区别。\n\n未出现在 REPLACE 语句中的列的默认值将插入到相应的列中。\n如果列具有 NOT NULL 属性且没有默认值，并且未在 REPLACE 语句中指定值，则 MySQL 将引发错误。\n\n\n\n例如，在以下语句中，我们仅指定 name 列的值，而不是 population 列。MySQL 引发错误消息。因为 population 列不接受 NULL 值，所以我们在定义 cities 表时没有为它指定默认值。\nREPLACE INTO cities(name)\nVALUES(&#39;Houston&#39;);\n\n这是 MySQL 发出的错误消息：\nError Code: 1364. Field &#39;population&#39; doesn&#39;t have a default value\n\nUPDATE-- 例如，如果要更新Phoenix城市的人口1768980，请使用以下REPLACE语句：\n\nREPLACE INTO cities\nSET id &#x3D; 4,\n    name &#x3D; &#39;Phoenix&#39;, -- 如果注释这里也会出现null\n    population &#x3D; 1768980;\n\n-- 与UPDATE语句不同，如果未在SET子句中指定列的值，则REPLACE语句将使用列的默认值。\n\n\n\nmysql&gt; select * from cities;\n+----+-----------+------------+\n| id | name      | population |\n+----+-----------+------------+\n|  1 | New York  |    1008256 |\n|  2 | hello     |        120 |\n|  3 | San Diego |    1223405 |\n|  4 | Phoenix   |    1321523 |\n|  5 | New York  |    1008256 |\n+----+-----------+------------+\n5 rows in set (0.00 sec)\n\nmysql&gt; REPLACE INTO cities SET id &#x3D; 4,      population &#x3D; 1768980; ;\nQuery OK, 2 rows affected (0.02 sec)\n\nERROR:\nNo query specified\n\nmysql&gt; select * from cities;\n+----+-----------+------------+\n| id | name      | population |\n+----+-----------+------------+\n|  1 | New York  |    1008256 |\n|  2 | hello     |        120 |\n|  3 | San Diego |    1223405 |\n|  4 | NULL      |    1768980 |\n|  5 | New York  |    1008256 |\n+----+-----------+------------+\n5 rows in set (0.00 sec)\n\nREPLACE INTO 和 SELECTREPLACE INTO table_1(column_list)\nSELECT column_list\nFROM table_2\nWHERE where_condition;\n\n\n-- 假设要复制id值为1的城市，请将REPLACE INTO SELECT语句用作以下查询：\n\nREPLACE INTO cities(name,population)\nSELECT name,population FROM cities\nWHERE id &#x3D; 1;\n","slug":"2022-11-30mysql-crud","date":"2022-11-30T01:32:15.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"6a629baafba13a0aeb236b74ca7f009f","title":"2.系统学习 mysql 约束","content":"约束非空 not nullNOT NULL 约束是列约束，迫使一列的值非 NULL 值。\nNOT NULL 约束的语法如下：\ncolumn_name data_type NOT NULL DEFAULT value;\n-- 列 NOT NULL 只包含一个约束，它指定列不得包含任何 NULL 值的规则。\n\n-- 建表语句非空约束\nCREATE TABLE tasks (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    start_date DATE NOT NULL,\n    end_date DATE\n);\n\n\n-- 第三，将NOT NULL约束添加到end_date列。为此，您使用以下ALTER TABLE语句：\nALTER TABLE table_name\nCHANGE old_column_name new_column_name new_column_definition;\n\n主键 primary key （1 个、可组合）-- 列尾增加主键约束\nCREATE TABLE users(\n   user_id INT AUTO_INCREMENT PRIMARY KEY,\n   username VARCHAR(40),\n   password VARCHAR(255),\n   email VARCHAR(255)\n);\n-- 语句尾部增加约束\nCREATE TABLE roles(\n   role_id INT AUTO_INCREMENT,\n   role_name VARCHAR(50),\n   PRIMARY KEY(role_id)\n);\n\n-- 组合主键\nCREATE TABLE user_roles(\n   user_id INT NOT NULL,\n   role_id INT NOT NULL,\n  --  组合\n   PRIMARY KEY(user_id,role_id),\n   FOREIGN KEY(user_id) REFERENCES users(user_id),\n   FOREIGN KEY(role_id) REFERENCES roles(role_id)\n);\n\n-- 增加主键约束\nALTER TABLE table_name\nADD PRIMARY KEY(primary_key_column);\n\n-- 与PRIMARY索引不同\n-- MySQL允许UNIQUE索引中有NULL值。\n-- 表可以有多个UNIQUE索引。\n\n\n\n-- 为username列添加 UNIQUE 索引。\nALTER TABLE users\nADD UNIQUE INDEX username_unique (username ASC) ;\n\n-- 为email列添加 UNIQUE 索引。\nALTER TABLE users\nADD UNIQUE INDEX email_unique (email ASC) ;\n\n外键 foreign key （可多个、可组合）不同表外键\n\ncustomers 表和 orders 表之间的关系是一对多\ncustomers 表称为父表，orders 表称为子表\n\n相同表外键\n\n子表和父表是相同的,自关联\n\n存在形式\n\n外键可以是一个列或一组列。子表中的列通常引用父表中的主键列。\n表可以具有多个外键，子表中的每个外键可以引用不同的父表。\n\n操作\n\n建表时外键约束语句\n加列时外键约束语句\n增加外键约束\n删除外键约束\n组合外键约束\n\nON DELETE&#x2F;ON UPDATE\n\nON DELETE 子句允许您定义删除父表中的记录时子表中记录的内容。如果省略 ON DELETE 子句并删除父表中包含子表中记录的记录，MySQL 将拒绝删除。此外，MySQL 还为您提供操作，以便您可以使用其他选项，例如 - ON DELETE CASCADE要求 MySQL 删除子表中的记录，当父表中的记录被删除时，记录将引用父表中的记录\nON DELETE SET NULL 不希望删除子表中的相关记录。MySQL 会将子表中的外键列值设置为 NULL 删除父表中的记录时，条件是子表中的外键列必须接受 NULL 值\nON DELETE NO ACTION 或 ON DELETE RESTRICT 操作，MySQL 将拒绝删除。\n\nON UPDATE 子句使您可以指定更新父表中的行时子表中的行会发生什么。您可以省略 ON UPDATE 子句，以便在更新父表中的行时让 MySQL 拒绝对子表中行的任何更新。\nON UPDATE CASCADE 操作允许您执行跨表更新，并且当更新父表\nON UPDATE SET NULL 中的行时，操作会将子表中的行中的值重置为值 NULL\nON UPDATE NO ACTION 或 ON UPDATE RESTRICT 行动拒绝任何更新。\n\n\nCREATE DATABASE IF NOT EXISTS dbdemo;\n\nUSE dbdemo;\n\nCREATE TABLE categories(\n   cat_id int not null auto_increment primary key,\n   cat_name varchar(255) not null,\n   cat_description text\n) ENGINE&#x3D;InnoDB;\n-- 建表增加约束\nCREATE TABLE products(\n   prd_id int not null auto_increment primary key,\n   prd_name varchar(355) not null,\n   prd_price decimal,\n   cat_id int not null,\n  --  以下为外键约束\n   FOREIGN KEY fk_cat(cat_id)\n   REFERENCES categories(cat_id)\n   ON UPDATE CASCADE\n   ON DELETE RESTRICT\n)ENGINE&#x3D;InnoDB;\n\n-- 改表语句增加外键约束\nALTER TABLE table_name\nADD CONSTRAINT constraint_name\nFOREIGN KEY foreign_key_name(columns)\nREFERENCES parent_table(columns)\nON DELETE action\nON UPDATE action;\n\n-- 查看建表语句\n\nSHOW CREATE TABLE products;\n\n-- 删除外键约束\nALTER TABLE table_name\nDROP FOREIGN KEY constraint_name;\n\n-- 数据导入，避免外键因顺序问题存在的约束\n\n-- 要禁用外键检查，请使用以下语句：\n\nSET foreign_key_checks &#x3D; 0;\n-- 当然，您可以使用以下语句启用它：\n\nSET foreign_key_checks &#x3D; 1;\n\nunique 唯一 （可多个、可组合）\n创建时候添加（单个&#x2F;组合约束）\n删除约束（单个&#x2F;组合约束）\n添加约束（单个&#x2F;组合约束）\n查看表中的约束SHOW INDEX FROM 数据库.表名字\n\n-- 建表增加约束\n\n-- 单个列约束 方式1\nCREATE TABLE table_1(\n    column_name_1  data_type UNIQUE,\n);\n\n-- 单个列约束 方式2\n\nCREATE TABLE table_1(\n   ...\n   column_name_1 data_type,\n   ...\n   UNIQUE(column_name_1)\n);\n-- 组合约束\n\nCREATE TABLE table_1(\n\n   ...\n   column_name_1 data_type,\n   column_name_2 data type,\n   ...\n   UNIQUE(column_name_1,column_name_2)\n);\n-- 组合约束（指定名字）\nCREATE TABLE table_1(\n   ...\n   column_name_1 data_type,\n   column_name_2 data type,\n   ...\n   CONSTRAINT constraint_name UNIQUE(column_name_1,column_name_2)\n);\n\n-- 查看表中的所有约束\n\nSHOW INDEX FROM 数据库.表名字\n\n\n\n-- 删除约束\n-- 方式1\nDROP INDEX index_name ON table_name;\n\n-- 方式2\nALTER TABLE table_name\nDROP INDEX index_name;\n\n-- 删除组合约束\nDROP INDEX uc_name_address ON suppliers;\n\n-- 添加约束\nALTER TABLE table_name\nADD CONSTRAINT constraint_name UNIQUE (column_list);\n\n-- 添加组合约束\nALTER TABLE suppliers\nADD CONSTRAINT uc_name_address UNIQUE (name,address);\n\nCHECK 约束(MySQL 不支持 CHECK 约束)CHECK 约束，允许您在插入和更新之前验证列或列组的数据\n-- 要确保价格始终大于或等于成本，请使用以下CHECK约束：\n\n-- MySQL不支持CHECK约束\nCREATE TABLE IF NOT EXISTS parts (\n    part_no VARCHAR(18) PRIMARY KEY,\n    description VARCHAR(40),\n    cost DECIMAL(10 , 2 ) NOT NULL CHECK (cost &gt; 0),\n    price DECIMAL(10 , 2 ) NOT NULL CHECK (price &gt; 0),\n    CHECK (price &gt;&#x3D; cost)\n);\n\n使用触发器模拟-- 首先，创建一个新表parts 演示：\n\nCREATE TABLE IF NOT EXISTS parts (\n    part_no VARCHAR(18) PRIMARY KEY,\n    description VARCHAR(40),\n    cost DECIMAL(10 , 2 ) NOT NULL,\n    price DECIMAL(10,2) NOT NULL\n);\n-- 接下来，创建一个存储过程以检查cost和price列中的值。\n-- 存储过程的基本语法： https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_45856289&#x2F;article&#x2F;details&#x2F;116665243\n-- 存储过程文档： https:&#x2F;&#x2F;www.begtut.com&#x2F;mysql&#x2F;introduction-to-sql-stored-procedures.html\nDELIMITER $\n\nCREATE PROCEDURE &#96;check_parts&#96;(IN cost DECIMAL(10,2), IN price DECIMAL(10,2)) -- 两个入参\nBEGIN\n    IF cost &lt; 0 THEN\n        SIGNAL SQLSTATE &#39;45000&#39;\n           SET MESSAGE_TEXT &#x3D; &#39;check constraint on parts.cost failed&#39;;\n    END IF;\n\n    IF price &lt; 0 THEN\n      SIGNAL SQLSTATE &#39;45001&#39;\n    SET MESSAGE_TEXT &#x3D; &#39;check constraint on parts.price failed&#39;;\n    END IF;\n\n    IF price &lt; cost THEN\n SIGNAL SQLSTATE &#39;45002&#39;\n           SET MESSAGE_TEXT &#x3D; &#39;check constraint on parts.price &amp; parts.cost failed&#39;;\n    END IF;\nEND\n\n$ DELIMITER ;\n\n\n-- 然后，创建  BEFORE INSERT 并BEFORE UPDATE触发。在触发器内部，调用check_parts()存储过程。\n\n-- before insert\nDELIMITER $\nCREATE TRIGGER &#96;parts_before_insert&#96; BEFORE INSERT ON &#96;parts&#96;\nFOR EACH ROW\nBEGIN\n    CALL check_parts(new.cost,new.price);\nEND$\nDELIMITER ;\n-- before update\nDELIMITER $\nCREATE TRIGGER &#96;parts_before_update&#96; BEFORE UPDATE ON &#96;parts&#96;\nFOR EACH ROW\nBEGIN\n    CALL check_parts(new.cost,new.price);\nEND$\nDELIMITER ;\n\n使用视图模拟\n-- 创建一个带有基表检查选项的视图。在SELECT视图的语句中，我们只选择满足CHECK条件的有效行。如果对视图进行任何插入或更新，将导致新行不显示在视图中。\n\n-- 首先，删除parts表以删除所有关联的触发器并创建一个新的表，如parts表，但具有不同的名称parts_data：\n\nDROP TABLE IF EXISTS parts;\n\nCREATE TABLE IF NOT EXISTS parts_data (\n    part_no VARCHAR(18) PRIMARY KEY,\n    description VARCHAR(40),\n    cost DECIMAL(10 , 2 ) NOT NULL,\n    price DECIMAL(10,2) NOT NULL\n);\n-- 接下来，创建parts基于parts_data表命名的视图。通过这样做，我们可以保持使用parts表的应用程序的代码保持不变。此外，旧parts表的所有权限保持不变。\n\nCREATE VIEW parts AS\n    SELECT\n        part_no, description, cost, price\n    FROM\n        parts_data\n    WHERE\n        cost &gt; 0 AND price &gt; 0 AND price &gt;&#x3D; cost\nWITH CHECK OPTION;\n-- 然后，通过parts视图在parts_data表中插入一个新行：\n\nINSERT INTO parts(part_no, description, cost, price)\nVALUES(&#39;A-001&#39;,&#39;Cooler&#39;,100,120);\n\n参考链接非空约束\n主键约束\n外键约束\n唯一约束\nCHECK 约束\n","slug":"2022-11-26mysql-约束","date":"2022-11-26T03:02:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"2dc569547b91ee92b16da7ef33c8ec1b","title":"1.系统学习 mysql 操作","content":"库操作--  创建\nCREATE DATABASE [IF NOT EXISTS] database_name\n[CHARACTER SET charset_name]\n[COLLATE collation_name]\n-- 查看建库语句\nSHOW CREATE DATABASE testdb;\n--  显示\nSHOW DATABASES;\n--  选择\nUSE database_name;\n--  删除\n-- 数据库中的所有表并永久删除数据库\nDROP DATABASE [IF EXISTS] database_name;\n\n\n表操作-- 建表语句\nCREATE TABLE [IF NOT EXISTS] table_name(\n    column_list\n) ENGINE&#x3D;storage_engine\n-- 为表定义列 字段设置\ncolumn_name data_type(length) [NOT NULL] [DEFAULT value] [AUTO_INCREMENT]\n\n-- 查询建表语句\nSHOW CREATE TABLE table_name;\n\nALTER TABLE 语句修改现有表的结构。它允许您添加列，删除列，更改列的数据类型，添加主键，重命名表等等。\n以下说明了 ALTER TABLE 语句语法：\nALTER TABLE table_name action1[,action2,…]\n\n要更改现有表的结构：\n\n首先，在 ALTER TABLE 子句后指定要更改的表名。\n其次，列出要应用于表的一组操作。操作可以是任何操作，例如添加新列，添加主键或重命名表。\nALTER TABLE 语句允许您在单个 ALTER TABLE 语句中应用多个操作，操作由逗号（，）分隔。\n\nCREATE TABLE tasks (\n    task_id INT NOT NULL,\n    subject VARCHAR(45) NULL,\n    start_date DATE NULL,\n    end_date DATE NULL,\n    description VARCHAR(200) NULL,\n    PRIMARY KEY (task_id),\n    UNIQUE INDEX task_id_unique (task_id ASC)\n);\n\n-- ALTER TABLE语句为列设置自动增量属性\nALTER TABLE tasks\nCHANGE COLUMN task_id task_id INT(11) NOT NULL AUTO_INCREMENT;\n\n-- ALTER TABLE语句将新列添加到表示例中\nALTER TABLE tasks\nADD COLUMN complete DECIMAL(2,1) NULL\nAFTER description;\n\n-- ALTER TABLE从表示例中删除列\nALTER TABLE tasks\nDROP COLUMN description,\nDROP COLUMN description;\n\n-- ALTER TABLE 语句重命名表\nALTER TABLE tasks\nRENAME TO work_items;\n\n改表名&#x2F;视图名\n在执行 RENAME TABLE 语句之前，我们必须确保没有活动事务或锁定表。\n注意：不能使用 RENAME TABLE 语句重命名临时表，但可以使用 ALTER TABLE 语句 重命名临时表。\n重命名表，需要同步更新：\n视图引用的表\n存储过程引用的表\n手动删除并重新创建外键\n\n\n\n\n\n\n\n\n\n\nWARNING\n重命名视图引用的表如果要重命名的表由视图引用，则在重命名表时视图将变为无效，并且您必须手动调整视图。\n\n-- 要更改一个或多个表，我们使用RENAME TABLE如下语句：\n\nRENAME TABLE old_table_name TO new_table_name;\n-- 旧表（old_table_name）必须存在，新表（new_table_name）必须不存在。如果新表new_table_name存在，则语句将失败。\n\n\n-- 重命名临时表示例\n\nCREATE TEMPORARY TABLE lastnames\nSELECT DISTINCT last_name from employees;\n\n\n-- 其次，我们使用RENAME TABLE重命名lastnames表：\n\nRENAME TABLE lastnames TO unique_lastnames;\n-- MySQL返回以下错误消息：\n\n-- ERROR 1017 (HY000): Can&#39;t find file: &#39;.&#x2F;hr&#x2F;lastnames.frm&#39; (errno: 2 - No such file or directory)\n-- 第三，我们使用ALTER TABLE 语句重命名lastnames表。\n\nALTER TABLE lastnames\nRENAME TO unique_lastnames;\n\n-- 创建一个v_employee_info基于employees和departments表命名的视图\nCREATE VIEW v_employee_info as\n    SELECT\n        id, first_name, last_name, dept_name\n    from\n        employees\n            inner join\n        departments USING (department_id);\n\n-- 可以使用CHECK TABLE语句来检查v_employee_info视图的状态\nCHECK TABLE v_employee_info;\n\n\n\n临时表要创建临时表，只需将 TEMPORARY 关键字添加到 CREATE TABLE 语句中\n特点\nCREATE TEMPORARY TABLE 创建临时表。请注意，TEMPORARY 关键字是在 CREATE 和 TABLE 关键字之间添加的。\n当会话结束或连接终止时，MySQL 会自动删除临时表。当然，您可以使用 DROP TABLE 语句在不再使用它时显式删除临时表。\n临时表仅可供创建它的客户端访问。不同的客户端可以创建具有相同名称的临时表而不会导致错误，因为只有创建临时表的客户端才能看到它。但是，在同一会话中，两个临时表不能共享相同的名称。\n临时表可以与数据库中的普通表具有相同的名称。例如，如果创建一个名为 employees 临时表为示例数据库，现有的 employees 表变得不可访问。您针对 employees 表发出的每个查询现在都引用临时 employees 表。删除 employees 临时表时，employees 表可用并可再次访问。\n不建议临时表与普通表重名。因为这可能会导致混淆并可能导致意外的数据丢失。\n\n防误删\n\n\n\n\n\n\nWARNING\n建表 CREATE TEMPORARY TABLE删除 DROP TEMPORARY TABLE table_name;\n不要丢了 TEMPORARY，防止误删普通表\n\n\n防持久化\n\n\n\n\n\n\nWARNING\n如果您开发使用连接池或持久连接的应用程序，则无法保证在应用程序终止时自动删除临时表。\n因为应用程序使用的数据库连接可能仍处于打开状态并放置在连接池中供其他客户端使用。因此，最好在不再使用临时表时始终删除它们。\n\n列操作-- 新列添加到表\nALTER TABLE tasks\nADD COLUMN complete DECIMAL(2,1) NULL\nAFTER description;\n\n-- 从表示例中删除列\nALTER TABLE tasks\nDROP COLUMN description;\n\n-- 重命名表\nALTER TABLE tasks\nRENAME TO work_items;\n\n-- 变更表属性 -- 更多见约束 &#x2F;post&#x2F;2022-11-30mysql-约束\nALTER TABLE table_name\nCHANGE old_column_name new_column_name new_column_definition;\n\n\n\n序列为什么需要序列特点使用 AUTO_INCREMENT 属性时将应用以下规则 ：\n\n每个表只有一 AUTO_INCREMENT 列，其数据类型通常是整数。\nAUTO_INCREMENT 列必须编入索引，这意味着它可以是索引 PRIMARY KEY 或 UNIQUE 索引。\nAUTO_INCREMENT 列必须具有 NOT NULL 约束。将 AUTO_INCREMENT 属性设置为列时，MySQL 会自动将 NOT NULL 约束隐式添加 到列中\n\n序列工作AUTO_INCREMENT 列具有以下属性：\n\nAUTO_INCREMENT 列的起始值为 1，当您 NULL 向列中插入值或在 INSERT 语句中省略其值时，它会增加 1 。\n要获取最后生成的序列号，请使用 LAST_INSERT_ID() 函数。我们经常使用后续语句的最后一个插入 ID，例如，将数据插入表中。最后生成的序列在会话中是唯一的。换句话说，如果另一个连接生成序列号，则可以通过连接使用 LAST_INSERT_ID()函数获取序列号。\n如果在表中插入新行并为序列列指定值，则如果列中不存在序列号，则 MySQL 将插入序列号，\n如果已存在则发出错误。\n如果插入一个大于下一个序列号的新值，MySQL 将使用新值作为起始序列号，并生成一个大于当前序列号的唯一序列号，以供下次使用。这会在序列中产生间隙。\n如果使用 UPDATE 语句将 AUTO_INCREMENT 列中的值更新 为已存在的值，则\n如果列具有唯一索引，MySQL 将发出重复键错误。\n如果将 AUTO_INCREMENT 列更新为大于列中现有值的值，MySQL 将使用下一行的最后一个插入序列号的下一个数字。例如，如果最后一个插入序列号为 3，则将其更新为 10，新行的序列号为 4。\n如果使用 DELETE 语句删除最后插入的行，MySQL 可能会也可能不会重复使用已删除的序列号，具体取决于表的存储引擎。\n如果删除一行，MyISAM 表不会重复使用已删除的序列号，例如，表中的最后一个插入 ID 是 10，如果删除它，MySQL 仍会生成下一个序列号，即新行的序列号为 11。与 MyISAM 表类似，InnoDB 表在删除行时不重用序列号。\n为列设置 AUTO_INCREMENT 属性后，可以通过各种方式重置自动增量值，例如，使用 ALTER TABLE 语句。\n\n参考链接\n\n\n\n库操作\n创建数据库\n删除数据库\n\n\n\n表操作\n创建表\n修改表\n删除表\n临时表操作\n清理表\n\n\n\n列操作\n添加列\n删除列\n更改列\n序列\n\n\n\n","slug":"2022-11-26mysql-操作","date":"2022-11-26T01:00:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"9322ab91805d186b28cb967a708e37ed","title":"useGetLastState","content":"背景有时候，我们想要利用 useState 来更新数据，并且有时候，我们需要不断的拿到最新的值，来继续进行数据更新，频率很高～\n简单场景：同时我们晓得用setState(preState=&gt; newState)，来继续更新最新的值，这种用法在简单业务中使用没问题，复杂业务场景，无法应对复杂场景：比如我们需要用 preState 进行复杂的逻辑运算, 这时候我们可能将setState进行函数剥离，如果在这个函数中我们还要进行其他 state 计算，&#x3D;&#x3D;\n之前处理在组件中使用useRef存一份数据，计算时候使用useRef数据，渲染时候使用useState,之前没有封装，用起来存在维护多条数据的情况\nuseGetStatesetState 使用的是 useState 的第二解构，那么 stateRef，后面也就没维护，因此：useGetState 并不满足需要，我想，这应该是此勾子设计缺陷，可能作者没考虑到上面的背景\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;\n\ntype GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;\n\nfunction useGetState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];\nfunction useGetState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,\n  GetStateAction&lt;S | undefined&gt;\n];\nfunction useGetState&lt;S&gt;(initialState?: S) &#123;\n  const [state, setState] &#x3D; useState(initialState);\n  const stateRef &#x3D; useRef(state);\n  stateRef.current &#x3D; state;\n\n  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);\n  &#x2F;&#x2F; setState使用的是useState的第二解构，那么stateRef，后面也就没维护\n  return [state, setState, getState];\n&#125;\n\nexport default useGetState;\n\nuseGetLastState这里，将_setState 设置为私有，对外提供 setState，更新 useRef 和 useState 的值\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;\n\ntype GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;\n\nfunction useGetLastState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];\nfunction useGetLastState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,\n  GetStateAction&lt;S | undefined&gt;\n];\nfunction useGetLastState&lt;S&gt;(initialState?: S) &#123;\n  const [state, _setState] &#x3D; useState(initialState);\n  const stateRef &#x3D; useRef(state);\n  stateRef.current &#x3D; state;\n\n  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);\n  &#x2F;&#x2F; 这里，将_setState设置为私有，对外提供setState，更新useRef和useState的值\n  const setState &#x3D; useCallback((value) &#x3D;&gt; &#123;\n    stateRef.current &#x3D; value;\n    _setState(stateRef.current);\n  &#125;, []);\n\n  return [state, setState, getState];\n&#125;\n\nexport default useGetLastState;\n\n贡献代码？想了下，又要提 pre，又要测试…\n嗯～，哈～，一个字总结：懒\n参考链接https://ahooks.js.org/zh-CN/hooks/use-get-state\nuseGetState 源码\n","slug":"2022-11-25useGetLastState","date":"2022-11-25T05:49:23.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"2f2a1dbb480f2860f9722fc87c8a2adf","title":"组件库开发 Storybook(待补)","content":"背景最近维护一个项目，项目中的业务组件是单独维护的，至于为什么，不是很清楚。\n疑问优点\n\n难道只是为了开发方便，项目用的公司内定的 nextjs 3.x.x 的版本？webpack 编译速度太慢？\n\n缺点\n\n难复用：因为接口是写到业务组件中的，其他项目要想复，有一定的难度（虽然公司应用使用网关授权的方式进行调用）\n高冗余：假设其他项目用，其他业务组件会出现冗余情况\nstorybook：需要一定的学习成本\n成本高：对于业务组件与业务项目拆分，发布时候，要先发布组件，然后项目再获取新的依赖进行发布\n不确定性：中间还可能出现差异\n\nstorybook问题网络的普遍性将更多的复杂性推向了前端。它始于响应式网页设计，将每个用户界面从一个变成了 10、100、1000 个不同的用户界面。随着时间的推移，更多的需求堆积在设备、浏览器、可访问性、性能和异步状态等方面。\n组件驱动的工具，如 React、Vue 和 Angular，有助于将复杂的 UI 分解为简单的组件，但它们不是灵丹妙药。随着前端的增长，组件的数量也在膨胀。成熟的项目可能包含数百个组件，这些组件会产生数千种离散的变体。\n更复杂的是，这些 UI 很难调试，因为它们纠缠在业务逻辑、交互状态和应用上下文中。\n现代前端的广度压倒了现有的工作流程。开发人员必须考虑无数的 UI 变体，但还没有准备好开发或组织它们。您最终会遇到这样一种情况，即 UI 更难构建、使用起来不太令人满意并且很脆弱。\n用户界面多元宇宙\n解决方案独立构建 UI每一个 UI 现在都是一个零件. 组件的强大之处在于，您无需为了查看它们的呈现方式而启动整个应用程序。您可以通过传入道具、模拟数据或伪造事件来单独呈现特定的变体。\nStorybook 被打包成一个小型的，仅供开发，作坊与您的应用程序一起生活。它提供了一个独立的 iframe 来呈现组件，而不受应用程序业务逻辑和上下文的干扰。这有助于您将开发重点放在组件的每个变体上，甚至是难以触及的边缘情况。\nhttps://github.com/storybookjs/storybook\n\n优点当您为组件编写故事时，您会免费获得许多额外的好处。\n📝 开发更耐用的 UI隔离组件和页面并跟踪它们的用例故事. 验证难以触及的 UI 边缘情况。使用插件来模拟组件所需的一切——上下文、API 请求、设备功能等。\n✅ 更轻松地测试 UI，没有问题故事是一种实用的、可重现的跟踪 UI 状态的方式。在开发过程中使用它们对 UI 进行现场测试。Storybook 提供了内置的自动化工作流程辅助功能,相互作用， 和视觉的测试。或者通过将故事导入其他 JavaScript 测试工具来将故事用作测试用例。\n📚 文档 UI 供您的团队重用Storybook 是您 UI 的唯一真实来源。故事为您的所有组件及其各种状态编制索引，使您的团队可以轻松找到并重用现有的 UI 模式。Storybook 也会自动生成文档从那些故事中。\n📤 分享 UI 的实际工作原理故事展示了 UI 的实际工作方式，而不仅仅是它们应该如何工作的图片。这使每个人都了解当前正在生产的内容。出版故事书得到队友的签字。或者嵌入他们在 wikis、Markdown 和 Figma 中以简化协作。\n🚦 自动化 UI 工作流程Storybook 与您的持续集成工作流程兼容。将其添加为 CI 步骤以自动化用户界面测试、与团队成员一起审查实施并获得利益相关者的签署。\nstories\n.stories 文件可以认为是页面，所有封装的组件都可以在.stories 文件中使用\n.stories 使用 title 进行目录划分\n\nstorybook 中间件.storybook\n├── main.js\n├── middleware.js # 中间件，可以进行接口代理到日常环境\n├── preview-head.html\n└── preview.js\n\n参考案例按钮https://6195b518b76f57003aa69b4c-dzkgzotbvz.chromatic.com/?path=/docs/buttons-icontextbutton-coloredicontextbutton--default\n仓库https://github.com/phork/phorkit/tree/develop/src/components/Button\nMDXvscocde MDX 插件\n参考链接storybook React 教程\n[Storybook] 使用 Vue Storybook addon-docs 创建文档\ndocz\n","slug":"2022-11-24storybook","date":"2022-11-24T01:37:43.000Z","categories_index":"Npm","tags_index":"Npm","author_index":"举手摘月亮"},{"id":"2ca18facf08aecc1df3a76171b2916fc","title":"组件库开发 yalc","content":"背景使用 npm link&#x2F;yarn link&#x2F;yalc 等工具，通过软链接的方式进行调试，影响 node_modules 中原本的包;\n\n\n\n\n\n\n\n\n\nyalc 在开发和创作多个包（私有或公共）时，您通常会发现自己需要在本地环境中正在处理的其他项目中使用最新的&#x2F;WIP 版本，而无需将这些包发布到远程注册表。NPM 和 Yarn 通过一种类似的对称链接包（NPM&#x2F;纱线链接）解决了这个问题。尽管这在许多情况下可能有效，但它经常会带来严重的约束和依赖关系解决、文件系统之间的符号链接互操作性等问题。\nyalc\n\n\n\n\n\n\n\n\n对包开发者而言，一种比 yarn&#x2F;npm link 更好的开发流程\nhttps://github.com/wclr/yalc\n\n实战&#x2F;&#x2F; ui 库\n👑 ~&#x2F;haotian&#x2F;tuya&#x2F;code&#x2F;cds&#x2F;delivery-ui git:(feature_staff_dept) $ git checkout -b feature_staff_dept_2\n切换到一个新分支 &#39;feature_staff_dept_2&#39;\n👑 ~&#x2F;haotian&#x2F;tuya&#x2F;code&#x2F;cds&#x2F;delivery-ui git:(feature_staff_dept_2) $ yalc publish\n@tuya-fe&#x2F;delivery-ui@0.0.4-beta19 published in store.\n👑 ~&#x2F;haotian&#x2F;tuya&#x2F;code&#x2F;cds&#x2F;delivery-ui git:(feature_staff_dept_2) ✗ $\n\n&#x2F;&#x2F; 项目中\n👑 ~&#x2F;haotian&#x2F;tuya&#x2F;code&#x2F;cds&#x2F;ty-delivery git:(feature_20221117_filter) ✗ $ yalc add @tuya-fe&#x2F;delivery-ui\nCould not find package &#96;@tuya-fe&#x2F;delivery-ui&#96; in store (&#x2F;Users&#x2F;haotian&#x2F;.yalc&#x2F;packages&#x2F;@tuya-fe&#x2F;delivery-ui), skipping.\n👑 ~&#x2F;haotian&#x2F;tuya&#x2F;code&#x2F;cds&#x2F;ty-delivery git:(feature_20221117_filter) ✗ $ yalc add @tuya-fe&#x2F;delivery-ui\nPackage @tuya-fe&#x2F;delivery-ui@0.0.4-beta19 added &#x3D;&#x3D;&gt; &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;tuya&#x2F;code&#x2F;cds&#x2F;ty-delivery&#x2F;node_modules&#x2F;@tuya-fe&#x2F;delivery-ui\n👑 ~&#x2F;haotian&#x2F;tuya&#x2F;code&#x2F;cds&#x2F;ty-delivery git:(feature_20221117_filter) ✗ $\n\n\n\n没更新1. 没更新打包产物页面还是老代码，查查原因，原来是 dist 目录，dist 是 ui 库打包产物，没有打包\n\n\n2. 更新版本号ui build 时候更改版本号,yalc push 新版本\n3. 应用到的项目有缓存# 我的是公司定制的 nextjs项目\n# 清理next 缓存\n#  rm -rf .&#x2F;client&#x2F;.next\n\n\n4. 项目中 yalc update5. 刷新页面.gitignore# 忽略调试的文件\n.yalc\n\n\n\n参考链接yalc: 可能是最好的前端 link 调试方案（\n","slug":"2022-11-24yalc","date":"2022-11-24T01:29:26.000Z","categories_index":"Npm","tags_index":"Npm","author_index":"举手摘月亮"},{"id":"3658bc969a0a36d2986a0fd02f9eefb3","title":"面试开放题","content":"几个问题1、麻烦你自我介绍一下\n\n2、你对加班怎么看\n\n3、说说你的优点\n\n4、说说你的缺点5、你的职业规划是什么？\n\n6、你的核心竞争力是什么？7、你怎么处理和上级的冲突？\n\n8、你离职的原因是什么\n\n8、你的期望薪资是多少？\n\n9、你有什么要反问我的吗？参考链接迄今为止，最靠谱的面试问题（附答案）合集\n","slug":"2022-11-23面试","date":"2022-11-23T08:10:10.000Z","categories_index":"面试","tags_index":"面试","author_index":"举手摘月亮"},{"id":"8250f55f16ffdb06f383087abaea36b7","title":"0.系统学习 mysql刷课","content":"文档链接BEGTUT.COM Mysql 教程\n排序视频链接MySQL 入门基础,mysql 基础视频+数据库实战,老杜带你学（829 万播放量）\n视频对应的文档\n爬取 B 站视频导航function getTitles() &#123;\n  var datas &#x3D; &quot;&quot;;\n  var list &#x3D; Array.from(\n    document.getElementsByClassName(&quot;list-box&quot;)[0].children\n  );\n  &#x2F;&#x2F; 去重\n  var lset &#x3D; new Set();\n  list.forEach((li, index) &#x3D;&gt; &#123;\n    var item &#x3D; li.getElementsByTagName(&quot;a&quot;)[0].innerText;\n    var arr &#x3D; item.split(&quot;-&quot;);\n    var titles &#x3D; arr[1].split(&quot;\\n&quot;);\n    lset.add(titles[0]);\n  &#125;);\n  Array.from(lset).forEach((item, index) &#x3D;&gt; &#123;\n    datas +&#x3D; &#96;## $&#123;index + 1&#125;. $&#123;item&#125;\\n&#96;;\n  &#125;);\n  &#x2F;&#x2F; 拷贝\n  copy(datas);\n&#125;\ngetTitles();\n\n1. 数据库概述2. 什么是 SQL3. 安装 MySQL4. 卸载 MySQL5. 查看 MySQL 服务6. MySQL 服务启停7. 登录 MySQL8. MySQL 常用命令9. 表的理解10. SQL 分类11. 导入演示数据12. 查看表结构13. 简单查询14. 查询多个字段15. 查询所有字段16. 列起别名17. 列参与数学运算18. 条件查询19. 模糊查询20. 排序21. 多个字段排序22. 根据字段位置排序23. 综合案例24. 单行处理函数25. 分组函数26. 分组查询27. 单表查询总结28. 大概总结今日内容29. 回顾昨天内容30. distinct 关键字31. 连接查询概述32. 笛卡尔积现象33. 尽量降低表连接的次数34. 内连接之等值连接35. 内连接之非等值连接36. 内连接之自连接37. 外连接38. 三张表连接39. 子查询概述40. where 中的子查询41. from 中的子查询42. select 后的子查询43. union 的用法44. limit 概述45. limit 的使用46. 通用分页47. 表的创建及数据类型48. mysql 数据类型49. 模拟选用数据类型50. 删除表51. insert 语句52. insert 插入日期53. date_format 日期格式化54. date 和 datetime 的区别55. update 语句56. delete 语句57. 表是怎么进行连接的58. insert 插入多条记录59. 快速复制表60. 将查询结果插入一张表61. 删除大表62. 对表结构的增删改63. 约束概述64. 约束包括哪些65. 非空约束66. 非空约束测试67. 唯一性约束68. 两个字段联合唯一69. not null 和 unique 联合70. 主键概述71. 添加主键约束72. 主键数量73. 主键值建议类型74. 自然主键和业务主键75. 外键约束\n\n76. 存储引擎什么是存储引擎，用处？存储引擎是 mysql 中特有的术语，其它数据库中一般没有。（oracle 有，但不是这个名字）\n存储引擎实际上是一个表存储&#x2F;组织数据的方式\n怎么给表添加&#x2F;指定“存储引擎”show create table t_student;\n\n可以在建表的时候被表指定存储引擎,建表的时候可以在最后小括号的“)”的右边使用：\n\nENGINE 来指定存储引擎。\n\nCHARSET 来指定这张表的字符编码方式\n\n\n结论：\n\nmysql 默认的存储引擎是：InnoDB\n\nmysql 默认的字符编码方式：utf8\n\n\n建表时指定存储引擎和字符编码方式：\ncreate table t_product(\n\nid int primary key,\n\nname varchar(255)\n\n)engine&#x3D;InnoDB default charset &#x3D; gbk\n\n77. mysql 支持哪些存储引擎命令：　 show engines \\G\n78. mysql 常用存储引擎79. InnoDB 存储引擎80. MEMORY 存储引擎81. 事务概述82. 和事务有关的是 DML 语句83. 对事务的理解84. 事务是如何实现的85. 怎么提交和回滚事务86. 事务特性87. 事务隔离级别88. 事务隔离级别演示89. 回顾一下90. 索引概述91. 索引实现原理92. 索引的创建和删除93. 索引的失效94. 索引的分类95. 视图的概述96. 视图的作用97. DBA 的命令98. 数据库设计三范式99. 数据库设计第一范式100. 数据库设计第二范式101. 数据库设计第三范式102. 总结数据库表的设计103. 以满足客户需求为准104. 34 道作业题is 的用法boolean-- MySQL BOOLEAN 运算符\n-- 要获取tasks表中的所有已完成任务，您可能会提出以下查询：\n\nSELECT\n    id, title, completed\nFROM\n    tasks\nWHERE\n    completed &#x3D; TRUE;\n-- +----+---------------------------+-----------+\n-- | id | title                     | completed |\n-- +----+---------------------------+-----------+\n-- |  1 | Master MySQL Boolean type |         1 |\n-- +----+---------------------------+-----------+\n-- 1 row in set (0.00 sec)\n\n\n-- 如您所见，它只返回completed值为1 的任务。要修复它，您必须使用IS运算符：\n\nSELECT\n    id, title, completed\nFROM\n    tasks\nWHERE\n    completed IS TRUE;\n-- +----+----------------------------+-----------+\n-- | id | title                      | completed |\n-- +----+----------------------------+-----------+\n-- |  1 | Master MySQL Boolean type  |         1 |\n-- |  3 | Test Boolean with a number |         2 |\n-- +----+----------------------------+-----------+\n-- 2 rows in set (0.00 sec)\n\n\n\n-- 在此示例中，我们使用IS运算符针对布尔值测试值。\n\n-- 要获取待处理的任务，请使用IS FALSE或IS NOT TRUE如下：\n\nSELECT\n    id, title, completed\nFROM\n    tasks\nWHERE\n    completed IS NOT TRUE;\n-- +----+-----------------------+-----------+\n-- | id | title                 | completed |\n-- +----+-----------------------+-----------+\n-- |  2 | Design database table |         0 |\n-- +----+-----------------------+-----------+\n-- 1 row in set (0.00 sec)\n\nORDER BY 使用自定义排序顺序-- MySQL ORDER BY 使用自定义排序顺序\n-- ORDER BY 子句可以使用FIELD()  函数为列中的值定义自己的自定义排序顺序。\n\n-- 请参orders见下表。\n\n-- +----------------+\n-- | orders         |\n-- +----------------+\n-- | orderNumber    |\n-- | orderDate      |\n-- | requiredDate   |\n-- | shippedDate    |\n-- | status         |\n-- | comments       |\n-- | customerNumber |\n-- +----------------+\n-- 7 rows in set (0.03 sec)\n-- 例如，如果要按以下顺序基于以下状态对订单进行排序：\n--\n-- In Process\n-- On Hold\n-- Canceled\n-- Resolved\n-- Disputed\n-- Shipped\n-- 您可以使用 FIELD 函数将这些值映射到数值列表，并使用这些数字进行排序;\n--\n-- 请参阅以下查询：\n\nSELECT\n\torderNumber, status\nFROM\n\torders\nORDER BY FIELD(status,\n\t&#39;In Process&#39;,\n\t&#39;On Hold&#39;,\n\t&#39;Cancelled&#39;,\n\t&#39;Resolved&#39;,\n\t&#39;Disputed&#39;,&#39;Shipped&#39;);\n\n\n-- 运行结果：\n--\n-- +-------------+------------+\n-- | orderNumber | status     |\n-- +-------------+------------+\n-- |       10420 | In Process |\n-- |       10421 | In Process |\n-- |       10422 | In Process |\n-- |       10423 | In Process |\n-- |       10424 | In Process |\n-- |       10425 | In Process |\n-- |       10334 | On Hold    |\n-- |       10401 | On Hold    |\n-- ...\n\nBoolean 遇到 nullAND\n\n\n\nTRUE\nFALSE\nNULL\n\n\n\nTRUE\nTRUE\nFALSE\nNULL\n\n\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nNULL\nNULL\nFALSE\nNULL\n\n\n短路结果：\n\ntrue AND null 结果为 null\nnull AND null 结果为 null\n\nOR\n\n\n\nTRUE\nFALSE\nNULL\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nFALSE\nTRUE\nFALSE\nNULL\n\n\nNULL\nTRUE\nNULL\nNULL\n\n\n短路结果：\n\nfalse or null 结果为 null\nnull or null 结果为 null\n\n运算符优先级当您在表达式中使用多个逻辑运算符时，MySQL 始终会在 AND 运算符之后计算 OR 运算符。这称为运算符优先级，它确定运算符的执行顺序。MySQL 首先评估具有更高优先级的运算符。\n请参阅以下示例。\nSELECT true OR false AND false;\n-- 运行结果：\n--\n-- | true OR false AND false |\n-- +-------------------------+\n-- |                       1 |\n-- +-------------------------+\n-- 1 row in set (0.00 sec)\n\n\n这个怎么运作\n\n首先，MySQL 评估 AND 运算符，因此表达式 false AND false 返回 false。\n其次，MySQL 评估 OR 运算符，因此表达式 true OR false 返回 true。\n要更改评估顺序，请使用括号，例如：\n\nSELECT (true OR false) AND false;\n-- 运行结果：\n\n-- +---------------------------+\n-- | (true OR false) AND false |\n-- +---------------------------+\n-- | 0 |\n-- +---------------------------+\n-- 1 row in set (0.00 sec)\n\n这个怎么运作\n\n首先，MySQL 评估括号中的表达式(true OR false)返回 true\n其次，MySQL 评估语句的剩余部分，true AND false 返回 false。\n\n日期转化CAST 运算符将文字字符串’2013-01-01’和’2013-12-31’转换为 DATE 值。\nSELECT\n   orderNumber,\n   requiredDate,\n   status\nFROM\n   orders\nWHERE\n   requireddate BETWEEN\n     CAST(&#39;2013-01-01&#39; AS DATE) AND\n     CAST(&#39;2013-01-31&#39; AS DATE);\n\nLIKE通配符MySQL 提供了两个通配符供 LIKE 使用：百分号%和下划线_。\n\n百分号（%）通配符匹配任何零个或多个字符的字符串。\n下划线（_）通配符匹配任何单个字符。\n\n包含&#x2F;以什么开始&#x2F;以什么结束--  &#39;%s%&#39;\n--  &#39;s%&#39;\n--  &#39;%s&#39;\n\n--  &#39;_s%&#39;\n--  &#39;%s_&#39;\n\nLIKE 与 ESCAPE 子句-- 例如，如果要查找产品代码包含字符串的产品_20，可以使用%\\_20%以下查询中显示的模式：\n\nSELECT\n    productCode,\n    productName\nFROM\n    products\nWHERE\n    productCode LIKE &#39;%\\_20%&#39;;\n\n-- 或者我们可以指定不同的转义字符，例如，以下ESCAPE子句使用$：\n\nSELECT\n    productCode,\n    productName\nFROM\n    products\nWHERE\n    productCode LIKE &#39;%$_20%&#39; ESCAPE &#39;$&#39;;\n\nlimit 能做什么\n分页\n最大&#x2F;小值\n第几个最值\n\nCONCAT_WS以下查询选择员工的名字和姓氏，并将它们组合在一起以生成全名。CONCAT_WS 函数用于连接名字和姓氏。\nSELECT\n    CONCAT_WS(&#39;, &#39;, lastName, firstname)\nFROM\n    employees;\n\n运行结果：\n+--------------------------------------+\n| CONCAT_WS(&#39;, &#39;, lastName, firstname) |\n+--------------------------------------+\n| Murphy, Diane                        |\n| Patterson, Mary                      |\n| Firrelli, Jeff                       |\n| Patterson, William                   |\n| Bondur, Gerard                       |\n...\n\n别名\nMySQL 支持两种别名，称为列别名和表别名\n注意：不能在 WHERE 子句中使用列别名。原因是当 MySQL 评估 WHERE 子句时，SELECT 子句中指定的列的值可能尚未确定。\nAS 关键字是可选的，因此您可以省略它。\n经常在 INNER JOIN，LEFT JOIN，self JOIN 子句和子查询的语句中使用表别名\n\n时间函数1. NOW()1、NOW()，用于获取当前日期和时间函数\nselect now() as &#39;当前日期和时间&#39; from dual;\n\n-- 返回：2020-05-26 20:27:21\n\n2. CURDATE()2、CURDATE()，用于获取当前日期，同 CURRENT_DATE()\nselect curdate() as &#39;当前日期&#39; from dual;\n\n-- 返回：2020-05-26\n\n\n3. CURTIME()3、CURTIME()，用于获取当前时间，同 CURRENT_TIME()\nselect curtime() as &#39;当前时间&#39; from dual;\n\n-- 返回：20:27:57\n\n\n4. CURRENT_TIMESTAMP()4、CURRENT_TIMESTAMP()，用于获取当前日期和时间函数\nselect CURRENT_TIMESTAMP() from dual;\n\n-- 返回：2020-05-26 20:29:21\n\n-- 另外，在创建表时，可以为时间字段指定创建时间和更新时间\n\n-- 例如：\n\nCREATE TABLE &#96;t01&#96; (\n\n&#96;name&#96; varchar(64) DEFAULT &#39;&#39; COMMENT &#39;名字&#39;,\n\n&#96;ctime&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n-- ON UPDATE CURRENT_TIMESTAMP, 在更新时候用什么时间\n&#96;utime&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;\n\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n-- 如果使用 Navicat，在设置时间字段时，要勾选&quot;根据当前时间戳更新&quot;，还要在默认栏中填上&quot;CURRENT_TIMESTAMP&quot;\n\n5. DATE()5、DATE()函数，用于提取时间字段的日期，\n\n-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;YYYY-mm-dd&quot;\n\nselect date(tdate) from t01;\n\n-- 返回：2020-05-26\n\n6. YEAR()6、YEAR()函数，用于提取时间字段的年，\n-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;YYYY&quot;\n\nselect year(tdate) from t01;\n\n-- 返回：2020\n\n7. MONTH()7、MONTH()函数，用于提取时间字段的月，\n-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;mm&quot;，若月份前有 0 会忽略\n\nselect month(tdate) from t01;\n\n-- 返回：5\n\n8. DAY()8、DAY()函数，用于提取时间字段的日期，\n-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;dd&quot;，若日期前有 0 会忽略\n\nselect day(tdate) from t01;\n\n-- 返回：26\n\n9. TIME()9、TIME()函数，用于提取时间字段的时间，例如 t01 的 tdate 为’2020-05-26 11:11:11’，返回的格式为”HH:ii:ss”\nselect time(tdate) from t01;\n\n-- 返回：11:11:11\n\n10. HOUR()10、HOUR()函数，用于提取时间字段的小时，\n-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;HH&quot;，若小时前有 0 会忽略，如 08 则返回 8\n\nselect hour(tdate) from t01;\n\n-- 返回：11\n\n11. MINUTE()11、MINUTE()函数，用于提取时间字段的分钟，例如 t01 的 tdate 为’2020-05-26 11:11:11’，返回的格式为”ii”，若分钟前有 0 会忽略，如 08 则返回 8\nselect minute(tdate) from t01;\n-- 返回：11\n\n\n12. SECOND()12、SECOND()函数，用于提取时间字段的秒，例如 t01 的 tdate 为’2020-05-26 11:11:11’，返回的格式为”ss”，若秒前有 0 会忽略，如 08 则返回 8\nselect HOUR(tdate) from t01;\n\n返回：11\n13. UNIX_TIMESTAMP()13、UNIX_TIMESTAMP()函数，获取当前时间戳，还可以将时间字段转换成时间戳\nselect unix_timestamp()\n\n返回：当前时间的时间戳\nselect unix_timestamp(tdate) from t01;\n-- 返回：1590462671\n\n14. 时间格式化函数DATE_FORMAT()和 TIME_FORMAT()功能相同\nselect date_format(tdate,&#39;%Y-%m-%d %H:%i:%s&#39;) from t01;\n-- 返回：2020-05-26 11:11:11\n\nselect date_format(tdate,&#39;%Y-%m-%d&#39;) from t01;\n-- 返回：2020-05-26\n\n唯一约束\n字段级约束\n\n表级约束\n\n\n主键约束结论：一张表，主键约束只能添加 1 个。（主键只能有 1 个。）主键值建议使用：int、bigint、char、等类型。不建议使用：varchar 来做主键。主键值一般都是数字，一般都是定长的！\n主键除了：单一主键和符合主键之外，还可以分类成：\n自然主键：主键值是一个自然数，和业务没关系\n业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。\n实际开发业务自然主键使用比较多，因为主键一旦和业务挂钩，当业务发生变动的时候，可能会影响到主键值，\n所以业务主键不建议使用\n在 myslq 当中，有一种机制，可以帮助我们自动维护一个主键值？\ndrop table if exists t_vip;\n\ncreate table t_vip(\n\n　　id int primary key auto_increment,&#x2F;&#x2F;aotu_increment 表示自增，从1开始\n\n　　name varchar(255)\n\n);\n\ninsert into t_vip(name) values(&#39;zhangsan&#39;);\n\ninsert into t_vip(name) values(&#39;zhangsan&#39;);\n\ninsert into t_vip(name) values(&#39;zhangsan&#39;);\n\ninsert into t_vip(name) values(&#39;zhangsan&#39;);\n\nselect * from t_vip;\n\n\n自然主键和业务主键\n参考链接自然主键和业务主键\nBEGTUT.COM Mysql 教程(注意部分内容直译过来的，有误)\nMysql 事务\n","slug":"2022-11-23mysql","date":"2022-11-23T07:50:52.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"b0cb34e426203acdf9ee0474befb19d2","title":"git commit --amend","content":"$ git status\n位于分支 feature&#x2F;2023-1\n您的分支与上游分支 &#39;origin&#x2F;feature&#x2F;2023-1&#39; 一致。\n\n无文件要提交，干净的工作区\n$ git push\nEverything up-to-date\n$ git status\n位于分支 feature&#x2F;2023-1\n您的分支与上游分支 &#39;origin&#x2F;feature&#x2F;2023-1&#39; 一致。\n\n# 无文件要提交，干净的工作区\n$ git commit --amend\n[feature&#x2F;2023-1 ec3665e8] fix transI18nK2Value\n Date: Fri Nov 18 16:12:02 2022 +0800\n 1 file changed, 1 insertion(+), 2 deletions(-)\n#  遇到冲突了，😓，这能遇到冲突，之前从来没有过，并且这个仓库只有我在维护\n$ git push\nTo ssh:&#x2F;&#x2F;registry.code.tt.top:10023&#x2F;fe-efficacy&#x2F;performance.git\n ! [rejected]          feature&#x2F;2023-1 -&gt; feature&#x2F;2023-1 (non-fast-forward)\n错误：无法推送一些引用到 &#39;ssh:&#x2F;&#x2F;registry.code.tt.top:10023&#x2F;fe-efficacy&#x2F;performance.git&#39;\n提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。\n提示：再次推送前，先与远程变更合并（如 &#39;git pull ...&#39;）。详见\n提示：&#39;git push --help&#39; 中的 &#39;Note about fast-forwards&#39; 小节。\n$ git pull\n提示：您有偏离的分支，需要指定如何调和它们。您可以在执行下一次\n提示：pull 操作之前执行下面一条命令来抑制本消息：\n提示：\n提示：  git config pull.rebase false  # 合并\n提示：  git config pull.rebase true   # 变基\n提示：  git config pull.ff only       # 仅快进\n提示：\n提示：您可以将 &quot;git config&quot; 替换为 &quot;git config --global&quot; 以便为所有仓库设置\n提示：缺省的配置项。您也可以在每次执行 pull 命令时添加 --rebase、--no-rebase，\n提示：或者 --ff-only 参数覆盖缺省设置。\n致命错误：需要指定如何调和偏离的分支。\n$  git config pull.ff only\n$ git pull\n致命错误：无法快进，终止。\n$ git merge origin&#x2F;feature&#x2F;2023-1\nMerge made by the &#39;ort&#39; strategy.\n","slug":"2022-11-18git--amend","date":"2022-11-18T08:18:28.000Z","categories_index":"Git","tags_index":"Git","author_index":"举手摘月亮"},{"id":"6a4942ee97deb4752e5ca5382eb30450","title":"Flutter 热更新 Fair","content":"Fair 全称Flutter Over the Air\n58 热更新https://github.com/wuba/fair\n\n官方文档\nFair 是为 Flutter 设计的动态化框架，通过 Fair Compiler 工具对原生 Dart 源文件的自动转化，使项目获得动态更新 Widget 的能力。\n\n\n -->\n\n58 热更新服务器FairPushy\n58 react-native 分包https://github.com/wuba/metro-code-split\n","slug":"2022-11-17fair","date":"2022-11-17T05:44:35.000Z","categories_index":"Flutter","tags_index":"Flutter","author_index":"举手摘月亮"},{"id":"feba4ef9a66046c06860005632a037b6","title":"云原生 系统学习shell脚本","content":"#!#! 它告诉系统这个脚本需要什么解释器来执行\n#!&#x2F;bin&#x2F;sh，它同样也可以改为 #!&#x2F;bin&#x2F;bash\n\n之前因为不晓得啥意思，一直记不住这个东西。为此还写个 vscode sippets 来自动生成 😓\n执行方式\nbash 文件\nsh 文件\nchmod +x 文件路径（相对&#x2F;绝对&#x2F;文件执行运行）,现将文件改为可执行文件\nsource 文件\n. 文件\n\n变量\n命名：命名只能使用英文字母，数字和下划线，首个字符不能以数字开头（通用标准：非关键字、非标点符号、非空格）\n使用：$variable_name 或 ${variable_name}\n只读：readonly variable_name\n删除：unset variable_name\n\n字符串单引号\n单引号里的任何字符都会原样输出\n单引号字符串中的变量是无效的\n单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行）\n\n双引号\n双引号里可以有变量\n双引号里可以有转义字符\n\n反引号运算符&lt;!-- $&#123; 导致 hexo 无法编译,用md承载 --&gt;\n\n- &#96;获取长度&#96; 变量为数组时，&#96;$&#123;#string&#125;&#96; 等价于 &#96;$&#123;#string[0]&#125;&#96;\n- &#96;提取子串&#96; 从字符串第 2 个字符开始截取 4 个字符 &#96;$&#123;string:1:4&#125;&#96;\n- &#96;查找子串&#96; 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： &#96;expr index &quot;$string&quot; io&#96;\n\n数组- &#96;初始化语法&#96;： 1. 数组名&#x3D;(值 1 值 2 ... 值 n) 数组元素用&quot;空格&#x2F;回车&quot;符号分割开 2.元素单独赋值\n- &#96;读取单个元素&#96;：&#96;valuen&#x3D;$&#123;array_name[n]&#125;&#96; 下标\n- &#96;读取全部元素&#96;：&#96;valuen&#x3D;$&#123;array_name[@]&#125;&#96; @符号\n- &#96;获取数组的长度&#96;：&#96;$&#123;#array_name[@]&#125;&#96; &#96;$&#123;#array_name[*]&#125;&#96;,单元素长度&#96;$&#123;#array_name[n]&#125;&#96;\n- &#96;关联数组&#96; 使用任意的字符串、或者整数作为下标&#96;declare -A array_name&#96;\n\n参数传递\n$# 传递到脚本的参数个数\n$* 以一个单字符串显示所有向脚本传递的参数。如”$*“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。\n$@ 多个参数，与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。\n\n\n\n\n$$ 脚本运行的当前进程 ID 号\n$! 后台运行的最后一个进程的 ID 号\n$- 显示 Shell 使用的当前选项，与 set 命令功能相同。\n$? 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。\n\n基本运算算数运算原生 bash 不支持简单的数学运算，借助expr工具实现\n#!&#x2F;bin&#x2F;bash\n\nval&#x3D;&#96;expr 2 + 2&#96;\necho &quot;两数之和为 : $val&quot;\n\n\n+ 加法 expr $a + $b 结果为 30。\n- 减法 expr $a - $b 结果为 -10。\n* 乘法 expr $a \\* $b 结果为 200。 乘号(*)前边必须加反斜杠(\\)才能实现乘法运算；\n/ 除法 expr $b / $a 结果为 2。\n% 取余 expr $b % $a 结果为 0。\n= 赋值 a&#x3D;$b 把变量 b 的值赋给 a。\n== 相等。用于比较两个数字，相同则返回 true。 [ $a &#x3D;&#x3D; $b ] 返回 false。\n!= 不相等。用于比较两个数字，不相同则返回 true。 [ $a !&#x3D; $b ] 返回 true。\n\n注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a&#x3D;&#x3D;$b] 是错误的，必须写成 [ $a &#x3D;&#x3D; $b ]。\n关系运算关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n\n-eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。\n-ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。\n-gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。\n-lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。\n-ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。\n-le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。\n\n布尔运算\n! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。\n-o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。\n-a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。\n\n逻辑运算这里效果上同布尔运算 ， 用了两层括号\n\n&amp;&amp; 逻辑的 AND [[$a -lt 100 &amp;&amp; $b -gt 100]] 返回 false\n|| 逻辑的 OR [[$a -lt 100 || $b -gt 100]] 返回 true\n\n字符串运算\n= 检测两个字符串是否相等，相等返回 true。 [ $a &#x3D; $b ] 返回 false。\n!= 检测两个字符串是否不相等，不相等返回 true。 [ $a !&#x3D; $b ] 返回 true。\n-z 检测字符串长度是否为 0，为 0 返回 true。 [ -z $a ] 返回 false。\n-n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n “$a” ] 返回 true。\n$ 检测字符串是否不为空，不为空返回 true。 [ $a ] 返回 true。\n\n文件测试运算\n-d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。\n-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。\n-r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。\n-w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。\n-x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。\n-s file 检测文件是否为空（文件大小是否大于 0），不为空返回 true。 [ -s $file ] 返回 true。\n-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。\n\n\n\n以下不晓得啥东西\n\n-b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。\n-c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。\n-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。\n-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。\n-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。\n-p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。\n\nprintf格式化输出\n％s 输出一个字符串\n％d 整型输出\n％c 输出一个字符\n％f 输出实数，以小数形式输出\n%-10s 指一个宽度为 10 个字符（- 表示左对齐，默认：右对齐）\n\n\nprintf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg\nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234\nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543\nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876\n\n转译\n\\a 不换行\n\\b 后退\n\\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略\n\\f 换页（formfeed）\n\\n 换行\n\\r 回车（Carriage return）\n\\t 水平制表符\n\\v 垂直制表符\n\\\\ 一个字面上的反斜杠字符\n\n\n\n不晓得什么意思\n\n\\ddd 表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效\n\\0ddd 表示 1 到 3 位的八进制值字符\n\ntest 是命令\n命令也能直接当脚本用 🤔\n这个 命令好像等价上文操作符中的[]\n\n\n\n数值测试#!&#x2F;bin&#x2F;sh\n\nnum1&#x3D;100\nnum2&#x3D;100\nif test $[num1] -eq $[num2]\nthen\n    echo &#39;两个数相等！&#39;\nelse\n    echo &#39;两个数不相等！&#39;\nfi\n\n\n-eq 等于则为真\n-ne 不等于则为真\n-gt 大于则为真\n-ge 大于等于则为真\n-lt 小于则为真\n-le 小于等于则为真\n\n字符串测试= 等于则为真!= 不相等则为真-z 字符串 字符串的长度为零则为真-n 字符串 字符串的长度不为零则为真\n文件测试-e 文件名 如果文件存在则为真-r 文件名 如果文件存在且可读则为真-w 文件名 如果文件存在且可写则为真-x 文件名 如果文件存在且可执行则为真-s 文件名 如果文件存在且至少有一个字符则为真-d 文件名 如果文件存在且为目录则为真-f 文件名 如果文件存在且为普通文件则为真-c 文件名 如果文件存在且为字符型特殊文件则为真-b 文件名 如果文件存在且为块特殊文件则为真\n流程控制if ((…)) then else if# if else 的 [...] 判断语句中大于使用 -gt，小于使用 -lt。\n\nif [ &quot;$a&quot; -gt &quot;$b&quot; ]; then\n    ...\nfi\n# 如果使用 ((...)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。\n\nif (( a &gt; b )); then\n    ...\nfi\n\nif testfor in do done#!&#x2F;bin&#x2F;bash\n\nfor str in This is a string\ndo\n    echo $str\ndone\n\nwhile#!&#x2F;bin&#x2F;bash\nint&#x3D;1\nwhile(( $int&lt;&#x3D;5 ))\ndo\n    echo $int\n    let &quot;int++&quot;\n    # let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，\n    # 变量计算中不需要加上 $ 来表示变量。\n    # 如果表达式中包含了空格或其他特殊字符，则必须引起来。\ndone\n\n无限循环# 无限循环语法格式：\nwhile :\ndo\n    command\ndone\n\n# 或者\nwhile true\ndo\n    command\ndone\n\n\n# TODO: 上面这两句有点奇怪，：代表 true吗？\n\n# 或者\nfor (( ; ; ))\n\nutil# condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。\n# 执行循环语句，直到满足条件停下来\nuntil condition\ndo\n    command\ndone\n\ncase …esac\n# case ... esac 为多选择语句，与其他语言中的 switch ... case 语句类似，是一种多分支选择结构，\n\n# 每个 case 分支用右圆括号开始\n# 用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。\n# 可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。\n\n# case ... esac 语法格式如下：\n\n# *) 可以理解为default语句\n# 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。\n\ncase 值 in\n模式1)\n    command1\n    command2\n    ...\n    commandN\n    ;;\n模式2)\n    command1\n    command2\n    ...\n    commandN\n    ;;\nesac\n\nbreak&#x2F;continuecontinue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。\n函数声明\n[ function ] funname ()\n&#123;\n\n    action;\n\n    [return int;]\n\n&#125;\n\n# 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n# 2、参数返回\n#   可以显示加：return 返回，\n#   如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255\n\n# 1. 函数返回值: 在调用该函数后通过 $? 来获得\n# 2. 先定义后使用，注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。\n# 3. 调用函数仅使用其函数名即可\n\n参数\n$10 不能获取第十个参数，获取第十个参数需要$&#123;10&#125;。当 n&gt;&#x3D;10 时，需要使用${n}来获取参数\n\n\n$# 传递到脚本或函数的参数个数\n$* 以一个单字符串显示所有向脚本传递的参数\n$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n$$ 脚本运行的当前进程 ID 号\n$! 后台运行的最后一个进程的 ID 号\n$- 显示 Shell 使用的当前选项，与 set 命令功能相同。\n$? 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。\n\n输入&#x2F;输出重定向输出重定向\ncommand &gt; file 将输出重定向到 file。\ncommand &gt;&gt; file 将输出以追加的方式重定向到 file。\n\n输入重定向\ncommand &lt; file 将输入重定向到 file。\n&lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。\n\n测试无效的几个\nn &gt; file 将文件描述符为 n 的文件重定向到 file。\nn &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。\nn &gt;&amp; m 将输出文件 m 和 n 合并。\nn &lt;&amp; m 将输入文件 m 和 n 合并。\n\n文件包含文件级连执行\nvar.sh\n#!&#x2F;bin&#x2F;bash\n\nw1&#x3D;&quot;world&quot;\n\n#!&#x2F;bin&#x2F;bash\n\n#使用 . 号来引用var.sh文件\n. .&#x2F;var.sh\n\n# 或者使用以下包含文件代码\n# source .&#x2F;var.sh\n\necho $w1\necho &quot;hello $w1&quot;\n\n参考链接见\n","slug":"2022-11-14shell语法","date":"2022-11-14T08:20:26.000Z","categories_index":"云原生","tags_index":"云原生","author_index":"举手摘月亮"},{"id":"ecabbc2a042ed135e8c399618871b1ec","title":"云原生 系统学习vim","content":"vim 键盘图见\n\n\n单词u undo # 撤销\nf follow # 向下\nb back # 向上\ni insert # 插入\nc copy # 拷贝\nn next # 下一\np paste # 粘贴\nj join # 合并\nr repeat # 重复\nh hight # 顶部\nm middle # 中间\nl low # 底部\ng goto # 跳转\nd down # 向下\nu upper # 向上\nc confirm # 确认\n\n常用操作vim&#x2F;vi三种模式及切换\n\n\n一般模式 复制&#x2F;粘贴&#x2F;删除&#x2F;撤销\n\n\n语法\n功能描述\n\n\n\nyy\n复制光标当前一行!\n\n\ny 数字 y\n复制一段（从光标当前行到后 n 行)!\n\n\np\n箭头移动到目的行粘贴\n\n\nu\n撤销上一步\n\n\ndd\n删除光标当前行\n\n\nd 数字 d\n删除光标（含）后多少行!\n\n\nx\n剪切一个字符(当前光标)，相当于 dek\n\n\nX\n剪切一个字符(当前光标的前一个)，相当于 Backspace\n\n\nyw\n复制一个词。\n\n\ndw\n删除一个词~\n\n\nshift+6(^)\n移动到行头口\n\n\nshift+4($)\n移动到行尾\n\n\nw\n移动到下一个词（词头位置）\n\n\nen\n移动到当前词尾\n\n\n1+G\n移动到页头，数字\n\n\nG\n移动到页尾\n\n\n数字 N+G\n移动到目标行\n\n\n编辑模式进入编辑模式\n\n\n\n按键\n功能\n\n\n\na\n当前光标后\n\n\ni\n当前光标前\n\n\n0\n当前光标行的下一行\n\n\nI\n光标所在行最前\n\n\nA\n光标所在行最后\n\n\nO\n当前光标行的上一行\n\n\n命令模式\n\n\n命令\n功能\n\n\n\n:w\n保存\n\n\n:qu\n退出\n\n\n:wq\n保存并退出\n\n\n:q!\n不保存强制退出 e\n\n\n&#x2F;要查找的词\nn 查找下一个，N 往上查找\n\n\n:noh\n取消高亮显示\n\n\n:set nu\n显示行号\n\n\n:set nonu\n关闭行号\n\n\n:s&#x2F;old&#x2F;new\n替换当前行匹配到的第一个 old 为 new\n\n\n:s&#x2F;old&#x2F;new&#x2F;g\n替换当前行配到的所有 old 为 new\n\n\n:%s&#x2F;old&#x2F;new\n替换文档中每一行,配到的第一个 old 为 new\n\n\n\n\nvim 一般模式光标移动上下左右\n上 / h\n下 / j\n左 / k\n右 / l\n\n首尾跳转\n0 或功能键[Home] 移动到这一行的最前面字符处 (常用)\n$ 或功能键[End] 移动到这一行的最后面字符处(常用)\nn + space 行中某处\n\n行号跳转\nnG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg 移动到这个档案的第一行，相当于 1G 啊！ (常用) gg 是什么的缩写？\nn + 回车 n 为数字。光标向下移动 n 行(常用)\n\n屏幕跳转\nH 光标移动到这个屏幕的最上方 那一行的第一个字符\nM 光标移动到这个屏幕的中央处 那一行的第一个字符\nL 光标移动到这个屏幕的最下方 那一行的第一个字符\n\n分页跳转\nctrl + f 向下一页\nctrl + b 向上一页\nctrl + d 向下半页\nctrl + u 向上半页\n\n搜索&#x2F;替换搜索\n/word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)\n?word 向光标之上寻找一个字符串名称为 word 的字符串。\nn 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\nN 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n替换\n:n1,n2s/word1/word2/gn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)\n:1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\n:1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)\n\n上面第一个比第二个的多了 s，好像没什么区别\n删除&#x2F;复制&#x2F;粘贴删除\nnx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\nx 为向后删除一个字符 (相当于 [del] 按键)，\nX 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\nd$ 删除游标所在处，到该行的最后一个字符\nd0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\ndG 删除光标所在到最后一行的所有数据\nd1G 删除光标所在到第一行的所有数据\n\n剪切\ndd 剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。\nndd n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。\n\n复制\nyy 复制游标所在的那一行(常用)\nnyy 向下复制 n 行，例如 20yy 则是复制 20 行(常用)\ny$ 复制光标所在的那个字符到该行行尾的所有数据\ny0 复制光标所在的那个字符到该行行首的所有数据\nyG 复制游标所在行到最后一行的所有数据\ny1G 复制游标所在行到第一行的所有数据\n\n粘贴\np p 为将已复制的数据在光标下一行贴上，\nP 则为贴在游标上一行！\n\n举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)\n行合并\nJ 将光标所在行与下一行的数据结合成同一行\n\n重复上一个动作\nctrl + r 与 u 操作相反\n. 继续刚才的操作,即使被 undo 了之后，还会进行 undo…undo 之前的操作\n\nvim 一般模式&#x2F;编辑模式\ni 为『从目前光标所在处输入』，\nI 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\na 为『从目前光标所在的下一个字符处开始输入』，\nA 为『从光标所在行的最后一个字符处开始输入』。(常用)\no 为在目前光标所在的下一行处输入新的一行；\nO 为在目前光标所在的上一行处输入新的一行！(常用)\nr 只会取代光标所在的那一个字符一次；\nR 会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\nEsc 退出编辑模式，回到一般模式中(常用)\n\nvim 一般模式&#x2F;指令行模式存储惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n:w 将编辑的数据写入硬盘档案中(常用)\n:w!若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n:q 离开 vi (常用)\n:q!若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n:wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n存文件\n:w [filename] 将编辑的数据储存成另一个档案（类似另存新档）\n:n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。(这个操作咋没效果呢)\n\n读取其他文件\n:r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n显示行号\n:set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号\n:set nonu 与 set nu 相反，为取消行号！\n\n问题\n:n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。**(这个操作咋没效果呢)**\n\n参考链接Linux vi&#x2F;vim\nyum:command not found 解决办法\n","slug":"2022-11-14vim语法","date":"2022-11-14T06:05:35.000Z","categories_index":"云原生","tags_index":"云原生","author_index":"举手摘月亮"},{"id":"8bd4973cdea9ff1c139a5de6209c8f7b","title":"manage","content":"背景2022-11-09\n…\n媳妇说：领导要她主导一个项目，不晓得怎么搞，让我给她罗列下\n聊天记录我看了，确实是主导，而不是你 “先对接下，先把前端页面能开发的部分，先开发下”\n…\n2022-11-11，弯弯绕，整完，最后来句：后端没资源前端先开发 😂\n…\nAre you kidding with me?\n…\n胡闹归胡闹，既然都整理出来，就加到文章中\n项目负责流程\n需求背景\n\n需求对接\n\n需求评审（会）\n\n可能要需求方跟（前端、后端、测试、也可能涉及到领导啥的）来讲这次需求\n\n\n技术评审（会）\n\n研发排期（会）\n\n不是说，一批需求直接定一个月，两个月的排期要一点一点排\n比如 两周一个迭代，这期需求要 2&#x2F;n 个迭代做完，之后倒推出来大概要到什么时候可以提测，验收、上线\n\n\n研发集成自测（会）交叉测试等\n\n提测（如果有测试的情况）\n\nbug 修改\n\n产品验收\n\n发布上线\n\n\n画个简图辅助理解\n\n反思\n自己平时有没有表达不当，让人误解\n之前自己就有想过总结下，结果“忙其他的，给忘了”（偷懒，不要找借口！）\n\n","slug":"2022-11-10manage","date":"2022-11-10T02:08:55.000Z","categories_index":"Manage","tags_index":"Manage","author_index":"举手摘月亮"},{"id":"b33166a6f9ce7189daf49bf95de988cb","title":"云原生 Shell 命令（持续补充）","content":"echo 内容到文件写入内容$ echo &quot;hello&quot; &gt; hw.md # 写入hello\n$ cat hw.md # 查看\nhello\n$ echo &quot;world&quot; &gt; hw.md  # 插写入world\n$ cat hw.md # 查看\nworld\n\n追加内容$ echo &quot;hello&quot; &gt; hw.md  # 写入hello\n$ cat hw.md # 查看\nhello\n$ echo &quot;world&quot; &gt;&gt; hw.md  # 追加world\n$ cat hw.md # 查看\nhello\nworld\n\ncat 内容到文件\n将 file1 文件里的内容追加到 file2：cat file1 &gt;&gt; file2\n将 file1 文件里的内容写入到 file2，写入前清空 file2（即覆盖）：cat file1 &gt; file2\n将多个文件的内容追加到另一个文件（合并 file1 和 file2 的内容写入到 file3）：cat file1 file2 &gt;&gt; file3\n\n重定向输出内容 &gt;$ rm -f hw.md\n$ cat &gt; .&#x2F;hw.md &lt;&lt; EOF\nheredoc&gt; hello\nheredoc&gt; EOF\n$ ls\nhw.md\n$ cat hw.md\nhello\n\n重定向追加内容 &gt;&gt;$ cat &gt;&gt; .&#x2F;hw.md &lt;&lt; EOF\nhello\nEOF\n$ cat hw.md\nhello\nhello\n\n文件内容合并到一个# 查看文件内容\n$ cat hw.md\nhello\nhello\n# 再整一个文件\n$ cat &gt;&gt; .&#x2F;hw1.md &lt;&lt; EOF\nword\nEOF\n# 查看文件列表\n$ ls\nhw.md  hw1.md\n# 文件内容合并到  .&#x2F;hw3.md\n$ cat .&#x2F;hw1.md .&#x2F;hw.md &gt;&gt; .&#x2F;hw3.md\n$ ls\nhw.md  hw1.md hw3.md\n# 查看合并后的内容\n$ cat hw3.md\nword\nhello\nhello\n\nmkdir用法用法：mkdir [选项]… 目录…若指定目录不存在则创建目录。\n长选项必须使用的参数对于短选项时也是必需使用的。\n\n-m, –mode&#x3D;模式 设置权限模式(类似 chmod)，而不是 rwxrwxrwx 减 umask\n-p, –parents 需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理\n-v, –verbose 每次创建新目录都显示信息\n-Z, –context&#x3D;CTX 将每个创建的目录的 SELinux 安全环境设置为 CTX\n–help 显示此帮助信息并退出\n–version 显示版本信息并退出\n\nhttp://linux.51yip.com/search/mkdir\n批量创建文件夹mkdir -p &#x2F;ms&#x2F;&#123;sales,hr,web&#125;    #创建一个名为&#x2F;ms的目录，其中有sales、hr、web的子目录\n\n#批量创建文件夹\n$ mkdir -pv &#x2F;tmp&#x2F;test&#x2F;&#123;a1,b1&#125;&#x2F;&#123;c1,d1&#125;\nmkdir: created directory &#39;&#x2F;tmp&#x2F;test&#39;\nmkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;a1&#39;\nmkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;a1&#x2F;c1&#39;\nmkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;a1&#x2F;d1&#39;\nmkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;b1&#39;\nmkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;b1&#x2F;c1&#39;\nmkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;b1&#x2F;d1&#39;\n\n$ tree &#x2F;tmp&#x2F;test&#x2F;\n&#x2F;tmp&#x2F;test&#x2F;\n├── a1\n│   ├── c1\n│   └── d1\n└── b1\n    ├── c1\n    └── d1\n\n6 directories, 0 files\n\n显示目录命令 ls参数:\n-a :显示包括隐藏文件和目录在内的所有目录和文件\n-l :显示文件的详细信息\n-h :配合-l 以人性化的方式显示文件大小\n-t :按文件最后修改时间排序文件\nls -lhat\n\n权限组合\nr 可读\nw 可写\nx 可执行\n\n不可\n\n\n\n\n\n\n组合\n释义\n权限值\n\n\n\nrwx\n可读、可写、可执行\n4+2+1&#x3D;7\n\n\nr-x\n可读、不可写、可执行\n4+1&#x3D;5\n\n\nrw-\n可读、可写、不可执行\n4+2&#x3D;6\n\n\n-wx\n不可读、可写、可执行\n2+1&#x3D;3\n\n\n文件权限修改 chmod\n-u user 用户\n-g grop 用户组\n-o others 其他人\n-a all 所有人\n\n# 字符\nchmod u+x a.txt 用户增加执行权限\n# 用数值\nchmod 777 a.txt 所有人增加所有权限\n\n管道\n前|后：前面处理完，后面直接处理\n\n例子：\n# 造点数据\n$ echo &#123;1..15&#125; &gt; 1.txt\n$ echo &#123;a..z&#125; &gt;&gt; 1.txt\n$ echo 它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来. &gt;&gt; 1.txt\n$ echo 它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:. &gt;&gt; 1.txt\n\n\n# 找1.text倒数3行内容，之后grep 查找日志关键字并高亮及显示所在行上下文\n$ tail -n 3 1.txt | grep -1 -n official\n# 输出\n1-a b c d e f g h i j k l m n o p q r s t u v w x y z\n2:它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.\n3:它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.\n\n## 清场\nrm -f 1.txt\n\ntouch更新文档时间$ ls -lh  1.txt\n# 时间 10:41\n-rw-r--r--  1 haotian  staff   377B 11 11 10:41 1.txt\n$ touch 1.txt\n$ ls -lh  1.txt\n# 时间 11:00\n-rw-r--r--  1 haotian  staff   377B 11 11 11:00 1.txt\n\n创建新文件zip&#x2F;unzip基本使用# 压缩所有.txt文件\n$ zip  txt.zip *.txt\n  adding: 1.txt (deflated 35%)\n  adding: 2.txt (stored 0%)\n$ ls\n1.txt   2.txt   txt.zip\n# 解压缩所有\n$ unzip txt.zip\nArchive:  txt.zip\n# 提示相同文件怎么处理\nreplace 1.txt? [y]es, [n]o, [A]ll, [N]one, [r]ename: r\nnew name: hello\n  inflating: hello\n# 提示相同文件怎么处理\nreplace 2.txt? [y]es, [n]o, [A]ll, [N]one, [r]ename: r\nnew name: world\n extracting: world\n$ ls\n1.txt   2.txt   hello   txt.zip world\n# 查看解压后的内容\n$ cat hello\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\na b c d e f g h i j k l m n o p q r s t u v w x y z\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.\n# 查看解压后的内容\n$ cat world\n123\n$\n\n# 不解压，仅看看\n$ unzip -v txt.zip\nArchive:  txt.zip\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n     377  Defl:N      244  35% 11-11-2022 11:00 8d413fc0  1.txt\n       4  Stored        4   0% 11-11-2022 11:10 5a82fd08  2.txt\n--------          -------  ---                            -------\n     381              248  35%                            2 files\n\ntail&#x2F;head查文档日志\n$ cat 1.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\na b c d e f g h i j k l m n o p q r s t u v w x y z\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.\n$ head 1.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\na b c d e f g h i j k l m n o p q r s t u v w x y z\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.\n# 头部 2行\n$ head -2 1.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\na b c d e f g h i j k l m n o p q r s t u v w x y z\n# 头部 3行\n$ head -3 1.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\na b c d e f g h i j k l m n o p q r s t u v w x y z\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.\n# 头部 1行\n$ head -1 1.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n# 头部 2行\n$ head -n 2  1.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\na b c d e f g h i j k l m n o p q r s t u v w x y z\n# 等效 tail -n 2 1.txt 简写 tail -2  1.txt\n$ tail -2  1.txt\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.\n它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.\n$\n\n注意 -f是循环获取，不存在-w\n见\nscp本地到远程scp local_file remote_username@remote_ip:remote_folder\n# 或者\nscp local_file remote_username@remote_ip:remote_file\n# 或者\nscp local_file remote_ip:remote_folder\n# 或者\nscp local_file remote_ip:remote_file\n# 第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；\n# 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；\n\n远程到本地# 从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例\nscp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3\nscp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;\n\ncommand not found: ipbrew install iproute2mac\n\n删除某个目录下所有子目录的 node_modules\n查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 modu 执行删除\n\nfind &#x2F;tmp&#x2F;test&#x2F; -type d -name modu |xargs rm -rf\n\n\n查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 node_modules 执行删除\n\nfind &#x2F;tmp&#x2F;test&#x2F; -type d -name node_modules |xargs rm -rf\n\n\n查找 当前目录下 子目录下所有 node_modules 执行删除\n\nfind .&#x2F; -type d -name node_modules |xargs rm -rf\n\n见 find 命令\n按照文件大小查询# 查找path路径下，大雨10m的文件\nfind path -size +10m\n\nlocate# 先更新\n\nupdatedb\n\nlocate name\n\n\n主机名主机名命名与业务相关 如： master work-node1 work-node2\n方案 1: vim /etc/hostname + 重启服务器方案 2:hostnamectl set- hostname 你要的名字\n主机名单vim /etc/hosts\n修改 linux ip配置位置vim letclsysconfig&#x2F;network-scripts&#x2F;ifcfg-ens334\n以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。\n\n\n为什么要修改 ipip 动态分配，登录时候，不易发现（连接）服务器\n可能会遇到的问题\n物理机能 ping 通虚拟机，但是虚拟机 ping 不通物理机，一般都是因为物理机的防火墙问题，把防火墙关闭就行\n\n虚拟机能 Ping 通物理机，但是虛拟机 Ping 不通外网，一般都是因为 DNS 的设置有问题\n\n虛拟机 Ping www.baidu. com 品示域名未知等信息，一般查看 GATEWAY 和 DNS 设置是否正确\n\n如果以上全部设置完还是不行，需要关闭 NetworkManager 服务。\nsystemctl stop NetworkManager 关闭\nsystemct1 disable NetworkManager 禁用\n\n如果检查发现 systemct1 status network 有问题 需要检查 ifcfg-ens33\n\n\nservice 服务管理 （Centos6）。基本语法service 服务名 start &#x2F; stop &#x2F; restart &#x2F; status经验技巧杳看服务的方法：letclinit.d&#x2F;服务名发现只有两个服务保留在 service[root@test init.d]# pwd&#x2F;etc&#x2F;init.d[root@test init.d]# ls\nsystemctl(Centos 7）基本语法systemctl start| stop | restart | status 服务名经验技巧\n查看服务的方法：usr&#x2F;lib&#x2F;systemd&#x2F;system\n[root@test system]# pwo&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system[root@test init.d]# ls-al\nlinux 进程运行级别\n\n配置服务开机自启动&#x2F;关闭服务器防火墙# Centos6\nchkconfig --list\nchkconfig --level 3 network off # 3级别的network关闭\nchkconfig --level 3 network on # 3级别的network开启\n\n\n\n\n# Centos7\n\n\niptables&#x2F;firewalldsystemctl stop firewalld.service\nsystemctl start firewalld.service\nsystemctl disable firewalld.service\nsystemctl enable firewalld.service\n\nsystemctl status firewalld\n\n关机永无止境的，除非特殊情况下，不得已才会关机。1）基本语法(1) sync (功能描述：将数据由内存同先到硬盘中）(2) halt (功能描述：停机，关闭系统，但不断电）(3) poweroff (功能描述：关机，断电）(3) reboot (功能描述：就是重启，等同于 shutdown -r now)(4） shutdown【选项】 1 时间\n选项\n\n-H 相当于 –halt 停机\n-r 等于 reboot 重启\n\n参数\n\nnow 立刻关机\n时间 等待多久之后关机\n\n清空\nclear\nctrl + l\nreset\n\n这三个命令只是将屏幕滚动，并不是真的清理\n当前工作目录的绝对路径\npwd: print working directory 打印工作目录\n\ngrep# 查询 filename 文件中  something 的行号\ngrep -n something filename\n\n\ncp\\cp 强制覆盖不提示\nmore 命令 比 cat 更好Linux more 命令\nless 命令 比 more 更好Linux less 命令\nln 软连接删除方式同文件&#x2F;文件夹删除\nrm -rf foldername # 删除软连接文件夹\n# 区别是尾部&#x2F;\nrm -rf foldername&#x2F; #删除真实文件夹\n\n见\ndate&#x2F;ntpdate&#x2F;calntpdate # 联网更新时间，可能需要安装工具\n\n♠ &#x2F;Users&#x2F;chenhailong $ cal -y\n                            2022\n         一月                    二月                    三月\n日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六\n                   1         1  2  3  4  5         1  2  3  4  5\n 2  3  4  5  6  7  8   6  7  8  9 10 11 12   6  7  8  9 10 11 12\n 9 10 11 12 13 14 15  13 14 15 16 17 18 19  13 14 15 16 17 18 19\n16 17 18 19 20 21 22  20 21 22 23 24 25 26  20 21 22 23 24 25 26\n23 24 25 26 27 28 29  27 28                 27 28 29 30 31\n30 31\n\n         四月                    五月                    六月\n日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六\n                1  2   1  2  3  4  5  6  7            1  2  3  4\n 3  4  5  6  7  8  9   8  9 10 11 12 13 14   5  6  7  8  9 10 11\n10 11 12 13 14 15 16  15 16 17 18 19 20 21  12 13 14 15 16 17 18\n17 18 19 20 21 22 23  22 23 24 25 26 27 28  19 20 21 22 23 24 25\n24 25 26 27 28 29 30  29 30 31              26 27 28 29 30\n\n\n         七月                    八月                    九月\n日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六\n                1  2      1  2  3  4  5  6               1  2  3\n 3  4  5  6  7  8  9   7  8  9 10 11 12 13   4  5  6  7  8  9 10\n10 11 12 13 14 15 16  14 15 16 17 18 19 20  11 12 13 14 15 16 17\n17 18 19 20 21 22 23  21 22 23 24 25 26 27  18 19 20 21 22 23 24\n24 25 26 27 28 29 30  28 29 30 31           25 26 27 28 29 30\n31\n\n         十月                   十一月                   十二月\n日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六\n                   1         1  2  3  4  5               1  2  3\n 2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10\n 9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 17\n16 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 24\n23 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 31\n30 31\n♠ &#x2F;Users&#x2F;chenhailong $ cal\n      十一月 2022\n日 一 二 三 四 五 六\n       1  2  3  4  5\n 6  7  8  9 10 11 12\n13 14 15 16 17 18 19\n20 21 22 23 24 25 26\n27 28 29 30\n\n♠ &#x2F;Users&#x2F;chenhailong $ cal -3\n                            2022\n         十月                   十一月                   十二月\n日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六\n                   1         1  2  3  4  5               1  2  3\n 2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10\n 9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 17\n16 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 24\n23 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 31\n30 31\n\nyum\n\n\n\n压缩&#x2F;解压缩gzip&#x2F;guuzipgzip&#x2F;gunzip 压缩\n\n1）基本语法gzip 文件 (功能描述：压缩文件，只能将文件压缩为*.gz 文件）gunzip 文件.gz （功能描述：解压缩文件命令）\n2）经验技巧(1）只能压缩文件不能压缩目录(2）不保留原来的文件(3）同时名个文件会产生名个压缩包\n3）案例实操(1 gzip 压缩\n\nzip&#x2F;unzip1）基本语法zip 选项 1XXX.zip 将要压缩的内容 (功能描述：压缩文件和目录的命令）unzip[选项]xxx.zip (功能描述：解压缩文件）\n2）选项说明\n\n\n\nzip 选项\n功能\n\n\n\n-r\n压缩目录\n\n\n\n\n\nunzip 选项\n功能\n\n\n\n-d &lt;目录&gt;\n指定解压后文件的存放目录\n\n\n3）经验技巧zip 压缩命令在 window&#x2F;inux 都通用，可以压缩目录且保留源文件\n4） 案例实操(1）压缩 houge.txt 和 bailongma.txt，压缩后的名称为 mypackage.zip\ntar 打包1）基本语法\ntar[选项]XXX.tar.gz 将要打包进去的内容 （功能描述：打包目录，压缩后的文件格式.tar.gz）\n2）选项说明\n\n\n\n选项\n功能\n\n\n\n-c\n产生.tar 打包文件\n\n\n-v\n显示详细信息\n\n\n-f\n指定压缩后的文件名\n\n\n-z\n打向同时压缩\n\n\n-X\n解包.tar 文件\n\n\n-C\n解压到指定目录\n\n\n3）案例实操~(1）压缩多个文件\n# 压缩\ntar -zcvf name.tar.gz houge.txt bailonama.txt\n# 解压缩\ntar -zxvf temp.tar.gz -C &#x2F; tmp\n\n克隆虚拟机\n\n\n\n更改 ip\n\n更改 hostname\n\n磁盘查看和分区类duLinux du 命令\ndffree# 查看内存\nfree -h\n\nlsblk查看设备（硬盘&#x2F;光盘）挂载情况\n挂载\n\n如何进行磁盘分区进程管理ps&#x2F;pstree\n\n见\nlinux 各目录含义？见\nshell 脚本查看支持的脚本cat &#x2F;etc&#x2F;shells\n\n脚本执行方式\nbash 文件\nsh 文件\nchmod +x 文件路径（相对&#x2F;绝对&#x2F;文件执行运行）\nsource 文件\n. 文件\n\nrm -rf *$ rm -rf *\nzsh: sure you want to delete all 3 files in &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;log [yn]?\n# 虽然是强制，但是还是有提示的\n\n参考链接shell 常见命令\n3 天搞定 Linux，1 天搞定 Shell\nyum 软件包管理\n","slug":"2022-11-07shell命令","date":"2022-11-07T08:15:03.000Z","categories_index":"云原生","tags_index":"云原生","author_index":"举手摘月亮"},{"id":"492312f2926ba8445ea0e3998e226f61","title":"云原生 给自己科普 k8s","content":"满脑子问题k8s 是什么k8s 如何安装k8s 为什么最少 3 个 masterk8s 如何控制 node如何进行 iterm 多服务器操作scp 命令如何使用？有教程吗？sz 命令如何安装环境为什么要配置 host如何安装 yumlkind 种类有几个？应该用哪个？思维导图爬取博客园标签脚本var data &#x3D; &quot;&quot;;\nArray.from(document.getElementsByClassName(&quot;PostList&quot;))\n  .sort(() &#x3D;&gt; -1)\n  .forEach((li) &#x3D;&gt; &#123;\n    let linkdom &#x3D; li.children[0].children[0];\n    let text &#x3D; linkdom.children[0].innerText;\n    const lk &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;linkdom.href&#125;&quot; target&#x3D;&quot;_blank&quot; &gt;$&#123;text&#125;&lt;&#x2F;a&gt;\\n&#96;;\n    data +&#x3D; lk;\n  &#125;);\nconsole.log(data);\ncopy(data);\n\n\n\n（一）Kubernetes 概述\n（二）Kubernetes 组件说明\n（三）Kubernetes-Pod 概念\n（四）Kubernetes 网络通讯方式\n（五）Kubernetes 集群安装\n（六）Kubernetes 集群安装-配置私有仓库\n（七）Kubernetes 资源清单\n（八）Kubernetes 资源清单-探针\n（九）Kubernetes 资源清单-start、stop、相位\n（十）Kubernetes-资源控制器-控制器说明\n（十一）Kubernetes-Service\n概念kubernetes 的主从架构\nK8S 文章收录此系列文章，是我最近三天看到的最好的文章\n1. 《k8s 集群搭建》不要让贫穷扼杀了你学 k8s 的兴趣！2. 万字警告 - k8s 入门，理应 Pod 先行！3. 《Kubernetes》- 认识下 Pod 的管理者？4. 后端学运维- k8s 之数据存储5. 《Kubernetes》，你需要掌握的 Service 和 Ingress\nhttps://blog.csdn.net/bearstarx/category_9759043.html\nKubernetes 入门篇(一)：Kubernetes 概述\nKubernetes 入门篇(二)：Kubernetes 资源对象\nKubernetes 虚拟机搭建 (一) : Master 节点与 Node 节点整体配置\nKubenetes 虚拟机搭建 (二) : Master 节点专属配置\nKubenetes 虚拟机搭建 (三) : Node 节点注册配置\nKubenetes 虚拟机搭建 (四) : Kubernetes-Dashboard 平台部署\nKubernetes 入门篇 (三) : kubectl 常用运维命令应用\nKubernetes 入门篇 (四) : 通过 yaml 创建资源对象\nKubernetes 入门篇 (五) : Pod 生命周期与创建过程\nKubernetes 入门篇 (六) : Kubernetes 设计理念\nKubernetes 入门篇 (七) : Kubernetes 核心组件与通信端口\nKubernetes 核心组件篇 (一) : Kubernetes 核心组件组成\nKubernetes 核心组件篇 (二) : 核心组件 Kube-ApiServer\nKubernetes 核心组件篇 (三) : 核心组件 Kube-Scheduler\nKubernetes 核心组件篇 (四) : 核心组件 Controller Manager\nKubernetes 核心组件篇 (五) : 核心组件 Kubelet\nServicePod 会因为伸缩、更新、故障等情况发生变化，而 Service 会对这些变化进行跟踪。同时 Service 的名字、IP 和端口都不会发生变化。\nDeployment什么是服务发现服务发现是指使用一个注册中心来记录分布式系统中的全部服务的信息，以便其他服务能够快速的找到这些已注册的服务。服务发现\n什么是集群选举Ingress不好理解，单独拎出来\n通常情况下，service 和 pod 的 ip 仅可以在集群内部访问；集群外部的请求需要通过负载均衡转发到 service 在 Node 上暴露的 NodePort 上，然后再由 kube-proxy 通过边缘路由器(edge router)将其转发给相关的 Pod 或者丢弃，而 Ingress 就是为进入集群的请求提供路由规则的集合\ningress 可以给 service 提供集群外部访问的 url、负载均衡、ssl 终止、http 路由等。为了配置这些 ingress 规则，集群管理员需要部署一个 ingress controller，它监听 ingress 和 service 的变化，根据规则配置负载均衡并提供访问入口————————————————版权声明：本文为 CSDN 博主「devops_sre」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_42715225/article/details/109775528\nKubernetes Ingress 解析\nk8s——Service 和 Ingress\nk8s 学习（六）– 服务发现\n链路追踪https://github.com/jaegertracing/jaeger-ui\n\nprometheus+Grafana\nprometheus 以 HTTP 协议周期性抓取被监控组件状态\nGrafana 数据分析和可视化工具\n\nk8s 监控 prometheus+Grafana\n在 k8s 中部署 Prometheus 和 Grafana\nhttps://github.com/prometheus/prometheus\n\nhttps://github.com/grafana/grafana\n\nloki 工具使用Grafana Loki 查询语言 LogQL 使用\n网课视频网课避坑有些视频，从头到尾，安装这个，安装那个，从头到尾一直在安装～，真的很“劝退”\n周末两天除了刷视频、文章、吃饭、睡觉，啥事没做，也没搞个明白 😓\n不过也难怪在安装，因为除了 docker 镜像+ yaml 是自定义的，yml 还很模版化（套路一样），其他的主要在整 k8s 集群、权限、日志、监控、数据卷。还有吗？\n好像没了(哈～，跟你没完，还有多呢)。再有估计像 golang 调用 api 实现用户可视化操作，就像公司那套自己定制的一套发布系统\n尚硅谷 k8s视频文档有人整理了，爬它\n第一课 2020 尚硅谷 K8s 学习-k8s kubeadm 安装\n第一课:k8s 介绍安装\n第二课:尚硅谷 K8s 学习-k8s 资源清单和 Pod 生命周期\n第三课:尚硅谷 K8s 学习-k8s 资源控制器学习\n第四课:尚硅谷 K8s 学习-Service 网络学习\n第五课:尚硅谷 K8s 学习-存储机制\n第六课:尚硅谷 K8s 学习-k8s 资源调度器和安全认证\n第七课:尚硅谷 K8s 学习- Prometheus、Grafana 和 EFK、证书年限\n第八课:尚硅谷 K8s 学习-k8s 集群的高可用\n以下为视频内容摘要\n\n\n\n\n\nK8S 的内置资源\nPod:K8S 最小的调度单元，可以将一组密切关联的容器组成一个逻辑单元，在这个单元里容器之间可以更好的共享资源。\n\nDeployment:主要用于无状态应用，用来部署多个副本的 Pod,并且在 Pod 出现异常时帮助应用及时恢复正常。\n\nStatefulset:主要用于有状态应用，可以控制 Pod 的启动顺序，为 Pod 绑定不同的存储等。\n\nJob/CronJob:用于一次性和周期性的任务。\n\nDaemonset：通常用来部署后台常驻任务，会在每台 Vorker 节点启\n\nService:应用的访问入口，通过 selector 选择具有指定 labelf 的 Pod,为其提供服务发现和负载均衡的功能，每个 Service 都可以通过 CoreDNS 获取到其对应的 IP。\n\nIngress:提供 K8S 集群外部访问应用。\n\nConfigmap、Secret:描述应用的配置和密钥等数据。\n\nPV、PVC、HostPath、EmptyDir:描述应用的各类存储。\n\n\n控制器逻辑\n\n观察：通过监控 kubernetes 资源对象变化的事件来获取当前对象状态，我们只需要注入 EventHandler 让 client-go 将变化的事件对象信息放入 WorkQueue 中。\n分析：确定当前状态和期望状态的不同，由 Vorker 完成。\n执行：执行能够驱动对象当前状态变化的操作，由 Worker 完成。\n更新：更新对象的当前状态，由 Vorker 完成。\n\nClient 类型\n\nRESTClient：最基础的客户端，提供最基本的封装\nClientset:是一个 Client 的集合，在 Clientset 中包含了所有 K8S 内置资源的 Client,通过 Clientset 便可以很方便的操作如 Pod、Service 这些资源\ndynamicclient 动态客户端，可以操作任意 K8S 的资源，包括 CRD 定义的资源\nDiscoveryClient：用于发现 K8S 提供的资源组、资源版本和资源信息，比如：kubectl api-resources\n\n使用一条命令创建 k8s 单机集群，低配置的电脑也可以运行 k8s 集群\n基础概念: 什么是 Pod 控制器类型 K8S 网络通迅模式k8s: 构建 K8S 集群资源清单：资源 资源清单的语法 编写 Pod Pod 的生命周期Pod 控制器：各种控制器的特点以及使用定义方式服务发现：SVC 原理及其构建方式\n存储：黨握多种存储类型的特点 并且能够在不同环境中选择合适的存储方案（有自己的简众）调度器：黨握调度器原理 能够根据要求把 Pod 定义到想要的范点运行\n安全：集群的认证 鉴权 访问控制原理及其流程HELM: linux yum 黨握 HELM 原理 HELM 模板自定义 HELM 部署一些常用插件\n运维：修改 Kubeadm 达到证书可用期限为 10 年 能够构建高可用的 Kubernet 集群\n高可用集群副节点数据最好是&gt;&#x3D;3 奇数个\n\nAPISERVER:所有服务访问统一入口\nCrontrollerManager:维待副本期望数目\nScheduler:负责介绍任务选择合适的节点进行分配任务\nETCD:键值对数据库储存 K8S 集群所有重要信息（持久化）\nkubelet:直接跟容器引擎交互实现容器的生命周期管理\nKube-proxy:负责写入规则至 IPTABLES、IPVS 实现服务映射访问的\nCOREDNS:可以为集群中的 SVC 创建一个域名 IP 的对应关系解析\nDASHBOARD:给 K8S 集群提供个 B&#x2F;S 结构访间体系\nINGRESS CONTROLLER:官方只能实现四层代理，INGRESS 可以实现七层代理\nFEDERATION:提供一个可以跨集群中心多 K8S 统一管理功能\nPROMETHEUS:提供 K8S 集群的监控能力\nELK:提供 K8S 集群只志统一分析介入平台\n\n控制器类型ReplicationController 用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收。\n在新版本的 Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationControlle\nReplicaSet 跟 ReplicationController 没有本质的不同，只是名字不一样，并且 ReplicaSet 支持集合式的 selector。虽然 ReplicaSet 可以独立使用，但一般还是建议使用 Deployment 来自动管理 ReplicaSet,这样就无需担心跟其他机制的不兼容问题（比如 ReplicaSet 不支持 rolling-update 但 Deployment 支持)\nHorizontal Pod Autoscaling 仅适用于 Deployment 和 ReplicaSet,在 V1 版本中仅支持根据 Pod 的 CPU 利用率扩所容，在 vlalpha 版本中，支持根据内存和用户自定义的 metric 扩缩容\nStatefulSet 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计)，其应用场景包括：\n\n稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现\n稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service(即没有 Cluster IP 的 Service)来实现\n有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从 0 到 N-l,在下一个 Pod 运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现\n有序收缩，有序删除（即从 N-1 到 0）\n\nDaemonSet 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod使用 DaemonSet 的一些典型用法：\n\n运行集群存储 daemon,例如在每个 Node 上运行 glusterd、ceph。\n在每个 Node 上运行日志收集 daemon,例如 fluentd、logstash。\n在每个 Node 上运行监控 daemon,例如 Prometheus Node Exporter\n\nJob 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束Cron Job 管理基于时间的 Job,即：\n\n在给定时间点只运行一次\n周期性地在给定时间点运行\n\n网络通信\nKubernetes 的网络模型假定了所有 Pod 都在一个可以直接连通的扁平的网络空间中，这在 GCE(Google Compute Engine)里面是现成的网络模型，Kubernetes 假定这个网络己经存在。而在私有云里搭建 Kubernetes 集群，就不能假定这个网络已经存在了。我们需要自己实现这个网络假设，将不同节点上的 Docker 容器之间的互相访问先打通，然后运行 Kubernetes\n\n同一个 Pod 内的多个容器之间：IO\n各 Pod 之间的通讯：Overlay Network\nPod 与 Service 之间的通讯：各节点的 Iptables 规则\n\n\n\n\n什么是 4 层负载\n\n\n四层负载均衡工作在 OSI 模型的传输层，由于在传输层，只有 TCP&#x2F;UDP 协议，这两种协议中除了包含源 IP、目标 IP 以外，还包含源端口号及目的端口号。\n四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器\n\n什么是 7 层负载\n七层负载均衡工作在 OSI 模型的应用层，应用层协议较多，常用 http、radius、dns 等。\n七层负载就可以基于这些协议来负载。\n这些应用层协议中会包含很多有意义的内容。比如同一个 Web 服务器的负载均衡，除了根据 IP 加端口进行负载外，还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。\n\n4 层&#x2F;7 层负载关系\n四层即传输层，就是基于 IP + 端口的负载均衡；\n七层即应用层，就是基于 URL 等应用层信息的负载均衡；\n\n四层、七层负载均衡的区别 \n蓝绿发布、金丝雀发布、灰度发布、滚动发布、A&#x2F;B 测试\n蓝绿发布： 绿的为线上，蓝的为线上测试版本\n金丝雀发布(灰度发布)：灰度，对部分用户可见，使用 7 层代理的内容进行流量控制\n滚动发布：单个 pod 逐步替换的过程，保证了可用性\nA/B 测试：多个版本放到线上，观察哪了用户体验更好\n\n蓝绿发布、滚动发布、灰度发布，有什么区别？\nk8s 使用 Nginx Ingress 实现灰度发布和蓝绿发布\n以下为微服务相关东西sidecar 是什么什么是服务治理istio 与服务治理有什么关系\nservice mesh 服务网格\nistio 就是我们上述提到的 service mesh 架构的一种实现\nistio 就是为了解决微服务的这些问题才出现的\n\nistio 解决的问题\n\n\n\n微服务存在的问题\nistio 处理措施\n\n\n\n故障排查\nTraffic Management\n\n\n应用容错\nObservability\n\n\n发布升级\nPolicy Enforcement\n\n\n系统安全\nService Identity an Security\n\n\n -->\n\n服务之间的通信（比如这里的 Service A 访问 Service B）会通过代理（默认是 envoy）来进行，而且中间的网络协议支持 HTTP&#x2F;1.1，HTTP&#x2F;2，gRPC 或者 TCP，可以说覆盖了主流的通信协议。控制中心做了进一步的细分，分成了 Pilot、Mixer、和 Citadel，它们的各自功能如下：\n\nPilot：为 envoy 提供了服务发现，流量管理和智能路由（AB 测试、金丝雀发布等），以及错误处理（超时、重试、熔断）功能。用户通过 pilot 的 API 管理网络相关的资源对象，pilot 会根据用户的配置和服务的信息把网络流量管理变成 envoy 能识别的格式分发到各个 sidecar 代理中。\n\nMixer：为整个集群执行访问控制（哪些用户可以访问哪些服务）和 policy 管理（rate limit，quota 等），并且收集代理观察到的服务之间的流量统计数据\n\nCitadel：为服务之间提供认证和证书管理，可以让服务自动升级成 TLS 协议\n\n\n————————————————版权声明：本文为 CSDN 博主「DarkIce」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_40274679/article/details/106232119\nIstio 是啥？一文带你彻底了解\nIstio 架构原理\nIngress 与 istio 有很多重合的功能,两者有什么区别Service Mesh 的出现，弥补了 Kubernetes 在微服务的连接、管理和监控方面的短板，为 Kubernetes 提供更好的应用和服务管理。因此，Service Mesh 的代表 Istio 一经推出，就被认为是可以和 Kubernetes 形成双剑合璧效果的微服务管理的利器，受到了业界的推崇。\n\n\n\n\n\n\n\n\n\nIstio 与 Kubernetes 极为互补。“K8S 实际上只是负责基本的调度和编排，负责主机上容器的运行，Istio 做的是互补，因为它主要做的是服务发现。当用容器来实现不同的服务时，需要发现服务、动态连接服务、进行服务升级，甚至还会产生一些安全性、可靠性、性能方面的功能需求，实际上这些功能都是 K8S 原生没有或者要用手动的方法才能实现的。Istio 就是一个可以在 K8S 上，把这些应用、服务进行较好管理的框架。\n这篇文章之后的内容，看上去像是在打广告～，不看也罢————————————————版权声明：本文为 CSDN 博主「科技峰行者」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/sunhf_csdn/article/details/84257923\n什么是流量控制，什么是熔断可能的需求\n部署软件\n扩缩容\n可视化监控\n灰度\n回滚\n高并发\n高可用\n\nConfigmapconfigMap 描述信息ConfigMap 功能在 Kubernetes1.2 版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。ConfigMap API 给我们提供了向容器中注入配置信息的机制，ConfigMap 可以被用来保存单个属性，也可以用来保存整个配置文件或者 JSON 二进制大对象\nSecretSecret 解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 PodSpec 中。Secret 可以以 Volume 或者环境变量的方式使用\nk8s API 调用哈～，顿悟了，用这些 API 就能实现 devops 平台开发了\nPod\nCNCF 毕业项目项目毕业意味着，这项技术已经展现出强劲的采用率势头，开放的治理流程，以及对社区，可持续性和包容性的承诺\n见\nKubernetes开源容器编排系统，主要应用与自动化容器化应用程序的部署、扩展和管理。它已经是事实上的容器编排标准。\nPrometheus一套开源系统监控&amp;报警&amp;时间序列数据库工具包\nEnvoy被广泛采用的开源网络代理，被设计为云原生应用程序的第 7 层边缘和服务代理\nCoreDNSCoreDNS 是 DNS 服务器解决方案，它既能作为独立的 DNS 服务器，也作为 Kubernetes 的默认向前的 DNS 服务器\nContainerdDocker 引擎的底层运行时（runtime）管理器。目前，Containerd 作为业界标准的容器运行时被广泛采用。\nFluentd用于统一日志记录层的数据收集器，它会将数据源与后端系统分离\nJaegerJaeger 作为端到端的分布式跟踪平台，帮助企业监控云原生架构并进行故障排除\nVitessVitess 是用于 MySQL 水平扩展的数据库集群系统\nHelm（中文）掌舵\nhttps://helm.sh/zh/\nHelm 帮助您管理 Kubernetes 应用—— Helm Chart，即使是最复杂的 Kubernetes 应用程序，都可以帮助您定义，安装和升级。\nHelm Chart 易于创建、发版、分享和发布，所以停止复制粘贴，开始使用 Helm 吧。\nHelm 是 CNCF 的毕业项目，由 Helm 社区维护。\nHarborHarbor 是个开源制品（artifact）仓库，是首个原创于中国、并且成为 CNCF 毕业级的开源项目。用户可通过策略和基于角色的访问控制来保护制品（如容器镜像、Helm Chart 等），扫描镜像并避免受安全漏洞的危害。Harbor 扩展了开源项目 Docker Distribution，添加了用户所需的功能（例如安全性，身份，漏洞扫描和管理）。在环境中部署 Harbor 可以提高镜像传输效率，便于就近构建和运行容器应用。Harbor 支持在制品仓库之间复制镜像、Chart 等制品，并提供高级安全功能，例如用户管理、访问控制和操作审计等。\n首个中国原创项目 Harbor 毕业 \nhttps://goharbor.io/\nApollo一款可靠的分布式配置管理中心，诞生于携程框架研发部，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景见\nHelm 可以使用 Harbor 仓库？什么是 EFKEFK 组件： Elasticsearch (分布式集群搜索) Fluentd (日志收集转发) Kibana (面板操作查询)\n日志收集：Elasticsearch 是分析引擎，Kibana 是可视化面板，前面这两个是一伙的，Fluentd 是收集日志的\n监控： Prometheus 和 Grafana\n第四篇 kubernetes 部署 EFK 日志平台\n文档Kubernetes 中文社区 | 中文文档\n官网\n选择性消化官方文档，从自己感兴趣的部分开始\nhttps://github.com/guangzhengli/k8s-tutorials\n在线 k8s 集群no 马内，也可以玩\nPlay with KubernetesA simple, interactive and fun playground to learn Kubernetes\nhttps://labs.play-with-k8s.com\n有效时间 4 小时\netcdhttps://www.zhaowenyu.com/etcd-doc/\netcd 在 k8s 中存储哪些信息k8s 术语https://www.zhaowenyu.com/etcd-doc/\ningress-nginxhttps://kubernetes.github.io/ingress-nginx/\nlinux 系统根目录各文件夹的作用tgz 格式解压docker load i xx.tark8s 探针\n存活探针 希望容器在探测失败时被杀死并重新启动\n就绪探针 区分已经失败的应用和仍在处理其启动数据的应用\n启动探针 容器需要在启动期间加载大型数据、配置文件或执行迁移\n\n认证&#x2F;鉴权&#x2F;准入控制\nAuthentication 认证\nAuthorization 鉴权\nAdmission Control 准入控制\n\ndronehttps://github.com/jenkinsci/jenkins\n\nhttps://github.com/harness/drone\n\ndrone 官网底部 github 链接 跳转 Drone by Harness。找到了 drone-ui 和 drone-go 仓库，star 数 200 多，我怀疑整个世界了。 在 github 上搜 drone 找到了，star 数超过 jenkins，这就正常，此项目在 Harness 下\n嗯 我们公司用 drone\nDrone makes advanced customization easy. Implement custom access controls,approval workflows, secret management, yaml syntax extensions and more.\n没找到中文文档\nhttps://www.drone.io/\n官方文档\ndrone 学习一 几个核心组件\ndrone 插件开发https://www.jianshu.com/p/478c4524a1ce\njsonnet\nJsonnet - json 数据模板语言\n\nhttps://juejin.cn/post/6988819621956550669\n注：这篇文章里有个 Shuttle 工具，看上去很酷\nk8s dronenode&#x2F;clone 日志Cloning with 5 retries\nInitialized empty Git repository in &#x2F;code&#x2F;.git&#x2F;\n+ git fetch origin +refs&#x2F;heads&#x2F;hotfix&#x2F;1.4-part-solve:\nFrom https:&#x2F;&#x2F;registry.code.yy.top&#x2F;fe-efficacy&#x2F;socrates-admin\n* branch            hotfix&#x2F;1.4-part-solve -&gt; FETCH_HEAD\n* [new branch]      hotfix&#x2F;1.4-part-solve -&gt; origin&#x2F;hotfix&#x2F;1.4-part-solve\n+ git checkout 67deb4c0d6a8217f86f4564f33ed1545ddac1a6a -b hotfix&#x2F;1.4-part-solve\nSwitched to a new branch &#39;hotfix&#x2F;1.4-part-solve&#39;\n+ git submodule update --init --recursive\n\ndrone 自定义插件注入流水线中服务器之间免登Linux——配置服务器间的免密登录\nSSH 配置—Linux 下实现免密码登录\nNode 节点注册配置Node 节点注册配置\nk8s 集群准备\n看了下，阿里云按小时算，一个月也要点钱\n自己电脑 16G 的内存 i5 配置，搞个 1+2 集群应该也还行吧\n\n部署 k8s 集群（k8s 集群搭建详细实践版）\ndocker见\n云服务器是如何将内网暴露到外网的？如果我有一组台式机，是不是可以实现云服务器的效果\n","slug":"2022-11-05k8s","date":"2022-11-05T06:50:49.000Z","categories_index":"云原生","tags_index":"云原生","author_index":"举手摘月亮"},{"id":"66c41c8c78c6433d94dadc3b731a3d3d","title":"Redis 命令及分区","content":"爬取脚本var data &#x3D; &quot;&quot;;\nArray.from(document.getElementsByClassName(&quot;left&quot;)[0].children[1].children).forEach((li) &#x3D;&gt; &#123;\n  var a &#x3D; li.children[0];\n  data +&#x3D; &#96;\\&#96;$&#123;a.innerText&#125;\\&#96;: \\n&#96;.replace(&quot;Redis &quot;, &quot;&quot;).replace(&quot; 命令&quot;, &quot;&quot;);\n&#125;);\ncopy(data);\n\n最最基本\nredis 是数据库，具备增删改查\nredis 数据“分类型储存”，命令进行类型操作\n\n安装懒得安装了，直接用在线的吧 https://try.redis.io/\nNumber 数值加\nIncr:\nIncrby:\nIncrbyfloat:\n\n减\nDecr:\nDecrby:\n\nString 字符串增\nSET: 设置指定 key 的值 SET KEY_NAME VALUE\nMset: 同时设置一个或多个 key-value 对 MSET key1 value1 key2 value2 .. keyN valueN\nSetnx: 只有在 key 不存在时设置 key 的值 SETNX KEY_NAME VALUE\nMsetnx: 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在 MSETNX key1 value1 key2 value2 .. keyN valueN\nSetex: 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) SETEX KEY_NAME TIMEOUT VALUE\nSetbit: 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit) Setbit KEY_NAME OFFSET 对 redis 中 setbit 命令的理解\nSetrange: 从偏移量 offset 开始,用 value 参数覆写给定 key 所储存的字符串值 SETRANGE KEY_NAME OFFSET VALUE\nPsetex: 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位PSETEX key1 EXPIRY_IN_MILLISECONDS value1 \n\n查\nGetrange: 返回 key 中字符串值的子字符 GETRANGE KEY_NAME start end\nGet: 获取指定 key 的值 GET KEY_NAME\nGetbit: 对 key 所储存的字符串值，获取指定偏移量上的位(bit) GETBIT KEY_NAME OFFSET\nGetset: 将给定 key 的值设为 value ，并返回 key 的旧值(old value) GETSET KEY_NAME VALUE\nMget: 获取所有(一个或多个)给定 key 的值 MGET KEY1 KEY2 .. KEYN\nStrlen: 返回 key 所储存的字符串值的长度 STRLEN KEY_NAME\nAppend: 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾,不存在新增 APPEND KEY_NAME NEW_VALUE\n\nHash 对象存储描述对象存储，对象的 k-v 编辑\nHash 增\nHmset: 同时将多个 field-value (域-值)对设置到哈希表 key 中 HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN\nHmget: 获取所有给定字段的值 HMGET KEY_NAME FIELD1...FIELDN\nHset: 将哈希表 key 中的字段 field 的值设为 value HSET KEY_NAME FIELD VALUE \nHsetnx: 只有在字段 field 不存在时，设置哈希表字段的值。HSETNX KEY_NAME FIELD VALUE\n\nHash 删\nHdel: 删除一个或多个哈希表字段 HDEL KEY_NAME FIELD1.. FIELDN \n\nHash 改\nHincrbyfloat: Redis Hincrbyfloat 命令 - 为哈希表 key 中的指定字段的浮点数值加上增量 increment HINCRBYFLOAT KEY_NAME FIELD_NAME INCR_BY_NUMBER \nHincrby: 为哈希表 key 中的指定字段的整数值加上增量 increment HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER\n\nHash 查\nHget: 获取存储在哈希表中指定字段的值 HGET KEY_NAME FIELD_NAME\nHgetall: 获取在哈希表中指定 key 的所有字段和值 HGETALL KEY_NAME \nHkeys: 获取所有哈希表中的字段 HKEYS KEY_NAME\nHvals: 获取哈希表中所有值 HVALS KEY_NAME FIELD VALUE \nHexists: 查看哈希表 key 中，指定的字段是否存在 HEXISTS KEY_NAME FIELD_NAME\nHlen: 获取哈希表中字段的数量 HLEN KEY_NAME\n\nLIST 列表存储描述有点像数组的增删“改”查，没看到有改的方法\nLIST 增\nLset: 通过索引设置列表元素的值 LSET KEY_NAME INDEX VALUE\nLinsert: 在列表的元素前或者后插入元素 LINSERT KEY_NAME BEFORE EXISTING_VALUE NEW_VALUE \nLpushx: 将一个或多个值插入到已存在的列表头部 LPUSHX KEY_NAME VALUE1.. VALUEN\nRpushx: 为已存在的列表添加值 RPUSHX KEY_NAME VALUE1..VALUEN\nLpush:在列表头部添加一个或多个值 LPUSH KEY_NAME VALUE1.. VALUEN\nRpush: 在列表尾部添加一个或多个值 RPUSH KEY_NAME VALUE1..VALUEN\n\nLIST 删\nLrem: 移除列表元素 LREM KEY_NAME COUNT VALUE\nLtrim: 只保留指定区间内的元素 LTRIM KEY_NAME START STOP\nRpoplpush: 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME\nBrpoplpush: 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；\nBRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT \nBlpop: 移出并获取列表的第一个元素 BLPOP LIST1 LIST2 .. LISTN TIMEOUT\nBrpop: 移出并获取列表的最后一个元素 BRPOP LIST1 LIST2 .. LISTN TIMEOUT \nLpop: 移出并获取列表的第一个元素 LPOP KEY_NAME\nRpop: 移除并获取列表最后一个元素 RPOP KEY_NAME\n\n注意：带有 TIMEOUT 的命令。如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n技巧\n清空列表 ltrim key start end 中的 start 要比 end 大即可，数值且都为正数。如：ltrim key 1 0\n\nLIST 改LIST 查Lindex 命令 通过索引获取列表中的元素 LINDEX KEY_NAME INDEX_POSITIONLrange 命令 获取列表指定范围内的元素 LRANGE KEY_NAME START ENDLlen 命令 获取列表长度 LLEN KEY_NAME \n集合增\nSadd: 向集合添加一个或多个成员 SADD KEY_NAME VALUE1..VALUEN\n\n删\nSrem: 移除集合中一个或多个成员 SREM KEY MEMBER1..MEMBERN\nSpop: 移除并返回集合中的一个随机元素 SPOP KEY\n\n改\nSmove: 将 member 元素从 source 集合移动到 destination 集合 SMOVE SOURCE DESTINATION MEMBER\n\n查\nSmembers: 返回集合中的所有成员 SMEMBERS KEY VALUE \nScard: 获取集合的成员数 SCARD KEY_NAME 你用个 scount 也比 scard 好啊\nSscan: 迭代集合中的元素 SSCAN KEY [MATCH pattern] [COUNT count] 没看懂\nSrandmember: 返回集合中一个或多个随机数 SRANDMEMBER KEY [count]\nSismember: 判断 member 元素是否是集合 key 的成员 SISMEMBER KEY VALUE\n\n交集\nSinter: 返回给定所有集合的交集 SINTER KEY KEY1..KEYN \nSinterstore: 返回给定所有集合的交集并存储在 destination SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN\n\n并集\nSunion: 返回所有给定集合的并集 SUNION KEY KEY1..KEYN\nSunionstore: 所有给定集合的并集存储在 destination SUNIONSTORE DESTINATION KEY KEY1..KEYN\n\n差集\nSdiff: 返回给定所有集合的差集 SDIFF KEY KEY1..KEYN\nSdiffstore: 返回给定所有集合的差集并存储在 destination SDIFFSTORE DESTINATION_KEY KEY1..KEYN\n\n有序集合\n每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。\n有序集合的成员是唯一的,但分数(score)却可以重复\n\n增\nZadd: 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN\n\n删\nZrem: 移除有序集合中的一个或多个成员 ZRANK key member\nZremrangebyrank: 移除有序集合中给定的分数区间的所有成员 ZREMRANGEBYSCORE key min max\nZremrangebylex: 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYLEX key min max 这里原文档书写有误\n\n\n\n改\nZincrby: 有序集合中对指定成员的分数加上增量 increment ZINCRBY key increment member\n\n查\nZcard: 获取有序集合的成员数 ZCARD KEY_NAME\nZrange: 通过索引区间返回有序集合成指定区间内的成员 ZRANGE key start stop [WITHSCORES] # 显示有序集下标区间 start 至 stop 的成员\nZrangebylex: 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYLEX key min max\nZrangebyscore: 通过分数返回有序集合指定区间内的成员 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # -inf +inf 正负无穷大\nZcount: 计算在有序集合中指定区间分数的成员数 ZCOUNT key min max\nZlexcount:在有序集合中计算指定字典区间内成员数量 ZLEXCOUNT KEY MIN MAX\nZrank: 获得成员按分数值递增(从小到大)排列的排名 ZRANK key member\nZrevrank: 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZREVRANK key member\n\n交集\nZinterstore: 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\n\n并集\nZunionstore: 计算给定的一个或多个有序集的并集，并存储在新的 key 中 ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\n\n差集\nZscore: 返回有序集中，成员的分数值 ZSCORE key member\nZscan: 迭代有序集合中的元素（包括元素成员和元素分值） ZSCAN key cursor [MATCH pattern] [COUNT count] ???\nZremrangebylex: 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYLEX key min max\nZrevrangebyscore: 移除有序集合中给定的分数区间的所有成员 ZREMRANGEBYSCORE key min max\nZrevrange: 返回有序集中指定区间内的成员，通过索引，分数从高到底 ZREVRANGE key start stop [WITHSCORES]\n\nRedis 发布订阅? 有啥用Redis 事务【一损俱损】Redis 事务三个阶段一个事务从开始到执行会经历以下三个阶段：\n\n开始事务。\n命令入队。\n执行事务。\n\nRedis 事务命令\nMULTI 标记一个事务块的开始。\nEXEC 执行所有事务块内的命令。\nDISCARD 取消事务，放弃执行事务块内的所有命令。\nUNWATCH 取消 WATCH 命令对所有 key 的监视。\nWATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\nRedis 脚本eval 呃怎么和 js eval 那么像Redis 脚本使用 Lua 解释器来执行脚本 Redis 脚本使用 Lua 解释器来执行脚本\n【暂时跳过】没时间整这个\n连接命令\nAUTH password 验证密码是否正确\nECHO message 打印字符串\nPING 查看服务是否运行\nQUIT 关闭当前连接\nSELECT index 切换到指定的数据库\n\n分区分区的优势【容量大，速度快】\n通过利用多台计算机内存的和值，允许我们构造更大的数据库。\n通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。\n\n分区的不足【复杂度高，操作、事务受限】redis 的一些特性在分区方面表现的不是很好：\n\n涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的 redis 实例上时，你就不能对这两个 set 执行交集操作。\n涉及多个 key 的 redis 事务不能使用。\n当使用分区时，数据处理较为复杂\n\n分区类型Redis 有两种类型分区。 假设有 4 个 Redis 实例 R0，R1，R2，R3，和类似 user:1，user:2 这样的表示用户的多个 key，对既定的 key 有多种不同方式来选择这个 key 存放在哪个实例中。也就是说，有不同的系统来映射某个 key 到某个 Redis 服务。\n范围分区最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。\n比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用户会保存到 R1，以此类推。\n这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对 Redis 来说并非是好的方法。\n哈希分区【这个更优】另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是 object_name:这种形式，像下面描述的一样简单：\n用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key foobar 执行 crc32(foobar)会输出类似 93024922 的整数。对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个 Redis 实例中的一个了。93024922 % 4 &#x3D; 2，就是说 key foobar 应该被存到 R2 实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。\n参考链接https://www.redis.net.cn/order/3573.html\nhttps://try.redis.io/\n吐槽：某些云厂家卖人家的东西，也不给社区捐钱，啊呸\n","slug":"2022-11-04redis","date":"2022-11-04T09:09:30.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"举手摘月亮"},{"id":"b629fbc3034174b0bda5cbb3b1a0e487","title":"Graphql","content":"文章背景中文官网废话太多，语句也有些不通顺的地方\nGraphql 是什么GraphQL 全称叫 Graph Query Language，官方宣传语是“为你的 API 量身定制的查询语言”。\n用传统的方式来解释就是：相当于将你所有后端 API 组成的集合看成一个数据库，用户终端发送一个查询语句，你的 GraphQL 服务解析这条语句并通过一系列规则从你的“ API 数据库”里面将查询的数据结果返回给终端，而 GraphQL 就相当于这个系统的一个查询语言。\n作者：倩倩_a570链接：https://www.jianshu.com/p/05e405eef8fa来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n注意：GraphQL 不是数据库\nGraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时\n简单来说：提供了 schema 结构的数据，按照规则，填写相应的字段就可以获取到对应的字段内容，不多不少，刚刚好\n在什么背景下提出的GraphQL 在 rest 背景下提出\nREST API ：服务端决定有哪些数据返回，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理；而数据不能满足需求则需要请求更多的接口。以上就是我们常说的“过渡获取”和“欠缺获取”\n由于”过度”和”欠缺”的获取问题及其对客户端应用程序性能的影响，促进有效获取的 API 技术才有机会在市场上引起轰动 —— GraphQL 大胆地介入并填补了这一空白。\n作者：倩倩_a570链接：https://www.jianshu.com/p/05e405eef8fa来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n简单来说：相比较 Rest 风格来讲，GraphQL，相当于在 Rest 返回时候有选择的进行聚合字段进行返回\n特点：\n请求你所要的数据不多不少\n获取多个资源只用一个请求\n描述所有的可能类型系统\n更倾向于查询\n\n使用查询GitHub GraphQL APIhttps://docs.github.com/cn/graphql/overview/explorer\n描述# 涉及到知识点如下：\n# 查询\n# 字段（Fields）\n# 参数（Arguments）\n# 别名（Aliases）\n# 操作名称（Operation Name）\n# 变量（Variables）\n# 指令（Directives）\n# 元字段（Meta fields）\nquery myquery(\n  $if: Boolean &#x3D; false\n  $withUpdateAt: Boolean!\n  $withUser: Boolean!\n) &#123;\n  viewer &#123;\n    __typename # 元字段 ，查看类型\n    uuid: id # 给id更改别名为uuid\n    status &#123;\n      __typename\n      createdAt @skip(if: $if) # $if变量为true的时候，不返回 createdAt\n      updatedAt @include(if: $withUpdateAt) # $withUpdateAt变量为false的时候，不返回 updatedAt\n      user @include(if: $withUser) &#123;\n        __typename\n        id\n        email\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n参数值&#123;\n  &quot;skipCreatedAt&quot;: false,\n  &quot;withUpdateAt&quot;: true,\n  &quot;withUser&quot;: true\n&#125;\n\n结果&#123;\n  &quot;data&quot;: &#123;\n    &quot;viewer&quot;: &#123;\n      &quot;__typename&quot;: &quot;User&quot;,\n      &quot;uuid&quot;: &quot;MDQ6VXNlcjE4MzA1MzYx&quot;,\n      &quot;status&quot;: &#123;\n        &quot;__typename&quot;: &quot;UserStatus&quot;,\n        &quot;createdAt&quot;: &quot;2019-01-11T14:57:43Z&quot;,\n        &quot;updatedAt&quot;: &quot;2019-09-24T08:56:23Z&quot;,\n        &quot;user&quot;: &#123;\n          &quot;__typename&quot;: &quot;User&quot;,\n          &quot;id&quot;: &quot;MDQ6VXNlcjE4MzA1MzYx&quot;,\n          &quot;email&quot;: &quot;&quot;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nschemaGraphQL 查询语言基本上就是关于选择对象上的字段\nGraphQL 查询的结构和结果非常相似，因此即便不知道服务器的情况，你也能预测查询会返回什么结果\n为什么引入 schema?需要的数据的确切描述依然很有意义，我们能选择什么字段？服务器会返回哪种对象？这些对象下有哪些字段可用？\nGraphQL 服务都会定义一套类型，用以描述从那个服务查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询\n对象类型和字段GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段例如：\n# 嗯， 看上去有点像 golang 的结构体\ntype Character &#123;\n  name: String!\n  appearsIn: [Episode!]!\n&#125;\n\n\n对象类型 拥有一些字段的类型\n字段 对象类型的次级选项\n标量 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择\n非空 String!\n数组 [Episode!]\n\n参数type Starship &#123;\n  id: ID!\n  name: String!\n  length(unit: LengthUnit &#x3D; METER): Float\n&#125;\n\n在 GraphQL 中，所有参数必须具名传递\n参数可能是必选或者可选的，当一个参数是可选的，我们可以定义一个默认值 —— 如果 unit 参数没有传递，那么它将会被默认设置为 METER\n要么可选，要么必选，可选的必须有默认值！\n查询和变更类型schema 中大部分是普通对象类型，schema 内有两个特殊类型：\nschema &#123;\n  query: Query\n  mutation: Mutation\n&#125;\n\n例如：\n服务端：schema\ntype Query &#123;\n  hero(episode: Episode): Character\n  droid(id: ID!): Droid\n&#125;\n\n客户端\nquery &#123;\n  hero &#123;\n    name\n  &#125;\n  droid(id: &quot;2000&quot;) &#123;\n    name\n  &#125;\n&#125;\n\n标量类型标量类型的来源：表示 GraphQL 查询的叶子节点\n默认标量类型GraphQL 默认标量类型：\n\nInt：有符号 32 位整数。\nFloat：有符号双精度浮点值。\nString：UTF‐8 字符序列。\nBoolean：true 或者 false。\nID：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。\n\n自定义标量类型例如，我们可以定义一个 Date 类型：\nscalar Date\n\n然后就取决于我们的实现中如何定义将其序列化、反序列化和验证\n枚举类型枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内\nenum Episode &#123;\n  NEWHOPE\n  EMPIRE\n  JEDI\n&#125;\n\n无论在 schema 的哪处 使用了 Episode，都可以肯定它返回的是 NEWHOPE、EMPIRE 和 JEDI 之一。\n列表和非空类型修饰符\ntype Character &#123;\n  name: String! # 英文!表示非空\n  appearsIn: [Episode]! # 在 GraphQL schema 语言中，我们通过将类型包在方括号中来标记列表\n&#125;\n\n非空和列表修饰符可以组合使用。例如你可以要求一个非空字符串的数组：这表示数组本身可以为空，但是其不能有任何空值成员。用 JSON 举例如下：\nmyField: null &#x2F;&#x2F; 有效\nmyField: [] &#x2F;&#x2F; 有效\nmyField: [&#39;a&#39;, &#39;b&#39;] &#x2F;&#x2F; 有效\nmyField: [&#39;a&#39;, null, &#39;b&#39;] &#x2F;&#x2F; 错误\n\n\n接口接口是一个抽象类型，它包含某些字段，对象类型必须包含这些字段，才能算实现了这个接口\n与 typescript 不同的是这里的implements关键字来实现接口，把接口字段又罗列了一遍\n接口\ninterface Character &#123; # 接口interface定义\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n&#125;\n\n实现了 Character 的类型：\n# 实现接口\ntype Human implements Character &#123;\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n\n  starships: [Starship]\n  totalCredits: Int\n&#125;\n# 实现接口\ntype Droid implements Character &#123;\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n\n  primaryFunction: String\n&#125;\n\n# 引入了其他的字段 totalCredits、starships 和 primaryFunction，这都属于特定的类型的角色\n\n如果要查询一个只存在于特定对象类型上的字段，你需要使用内联片段：\n查询语句\nquery HeroForEpisode($ep: Episode!) &#123;\n  hero(episode: $ep) &#123;\n    name\n    ... on Droid &#123;\n      primaryFunction\n    &#125;\n  &#125;\n&#125;\n\n参数：\n&#123;\n  &quot;ep&quot;: &quot;JEDI&quot;\n&#125;\n\n返回：\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;hero&quot;: &#123;\n      &quot;name&quot;: &quot;R2-D2&quot;,\n      &quot;primaryFunction&quot;: &quot;Astromech&quot;\n    &#125;\n  &#125;\n&#125;\n\n联合类型# 与typescript 的联合类型相似\nunion SearchResult &#x3D; Human | Droid | Starship\n\n注意，联合类型的成员需要是具体对象类型；不能使用接口或者其他联合类型来创造一个联合类型。\n由于 Human 和 Droid 共享一个公共接口（Character），你可以在一个地方查询它们的公共字段，而不必在多个类型中重复相同的字段：\n&#123;\n  search(text: &quot;an&quot;) &#123;\n    __typename\n    ... on Character &#123;\n      # 使用了接口\n      name\n    &#125;\n    ... on Human &#123;\n      height\n    &#125;\n    ... on Droid &#123;\n      primaryFunction\n    &#125;\n    ... on Starship &#123;\n      name #Starship不是接口，要获取类型，还是要作为对象属性来写\n      length\n    &#125;\n  &#125;\n&#125;\n# 这里的Starship 是上文的对象类型\n# type Starship &#123;\n#   id: ID!\n#   name: String!\n#   length(unit: LengthUnit &#x3D; METER): Float\n# &#125;\n\n输入类型枚举和字符串等标量值作为参数传递给字段，也能很容易地传递复杂对象。这在变更（mutation）中特别有用，因为有时候你需要传递一整个对象作为新建对象。\n输入对象看上去和常规对象一模一样，除了关键字是 input 而不是 type:\ninput ReviewInput &#123;\n  stars: Int!\n  commentary: String\n&#125;\n\n语句# $review为参数对象\nmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;\n  createReview(episode: $ep, review: $review) &#123;\n    stars\n    commentary\n  &#125;\n&#125;\n\n参数&#123;\n  &quot;ep&quot;: &quot;JEDI&quot;,\n  &quot;review&quot;: &#123;\n    &quot;stars&quot;: 5,\n    &quot;commentary&quot;: &quot;This is a great movie!&quot;\n  &#125;\n&#125;\n\n结果&#123;\n  &quot;data&quot;: &#123;\n    &quot;createReview&quot;: &#123;\n      &quot;stars&quot;: 5,\n      &quot;commentary&quot;: &quot;This is a great movie!&quot;\n    &#125;\n  &#125;\n&#125;\n\n验证（规则限制）什么是验证？谁来验证？\n通过使用类型系统，你可以预判一个查询是否有效。这让服务器和客户端可以在无效查询创建时就有效地通知开发者，而不用依赖运行时检查。\n助解：\n\n有问题，提示，不执行查询，有点像浏览器 Option 预检的味道；好像不是 typescript 那种静态校验\n类型系统来校验\n这部分内容，更像是使用限制，你不能这么干，你要那么干\n\n死循环有个问题：如果是树状结构的组织架构，咋整了？组织架构是递归结构\n\n\n对象类型不存在的字段\n\n返回的不是标量&#x2F;枚举类型\n\n特定类型的特定字段如果对应的 Character 是 Droid，我们希望获取 primaryFunction 字段，而在其他情况下，则忽略此字段。我们可以使用之前引入的“片段”来解决这个问题。先在 Droid 上定义一个片段，然后在查询中引入它，这样我们就能在定义了 primaryFunction 的地方查询它\n错误示范\n\n具名片段\n\n匿名片段\n\n更多内容GraphQL.js 的 validation 目录包含了规范兼容的 GraphQL 验证器实现代码。\n执行一个 GraphQL 查询在被验证后，GraphQL 服务器会将之执行，并返回与请求的结构相对应的结果，该结果通常会是 JSON 的格式。\n一个查询请求被执行的全过程GraphQL 查询中的每个字段视为返回子类型的父类型函数或方法。事实上，这正是 GraphQL 的工作原理。\n\n每个类型的每个字段都由一个 resolver 函数支持，该函数由 GraphQL 服务器开发人员提供。\n\n当一个字段被执行时，相应的 resolver 被调用以产生下一个值。\n\n如果字段产生标量值，例如字符串或数字，则执行完成。\n\n如果一个字段产生一个对象，则该查询将继续执行该对象对应字段的解析器，直到生成标量值。\n\nGraphQL 查询始终以标量值结束。\n\n\n根字段 &amp; 解析器#\nRoot 类型或 Query 类型 代表着所有进入 GraphQL API 可能的入口点\n\nQuery: &#123;\n  human(obj, args, context, info) &#123;\n    return context.db.loadHumanByID(args.id).then(\n      userData &#x3D;&gt; new Human(userData)\n    )\n  &#125;\n&#125;\n\n\nobj 上一级对象，如果字段属于根节点查询类型通常不会被使用。\nargs 可以提供在 GraphQL 查询中传入的参数。\ncontext 会被提供给所有解析器，并且持有重要的上下文信息比如当前登入的用户或者数据库访问对象。\ninfo 一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值\n\n异步解析器human(obj, args, context, info) &#123;\n  return context.db.loadHumanByID(args.id).then(\n    userData &#x3D;&gt; new Human(userData)\n  )\n&#125;\n\n\ncontext 提供了一个数据库访问对象，用来通过查询中传递的参数 id 来查询数据，因为从数据库拉取数据的过程是一个异步操作，该方法返回了一个 Promise 对象，在 JavaScript 语言中 Promise 对象用来处理异步操作，但在许多语言中存在相同的概念，通常称作 Futures、Tasks 或者 Defferred。\n当数据库返回查询结果，我们就能构造并返回一个新的 Human 对象。\n等返回：这里要注意的是，只有解析器能感知到 Promise 的进度，GraphQL 查询只关注一个包含着 name 属性的 human 字段是否返回，在执行期间如果异步操作没有完成，则 GraphQL 会一直等待下去，因此在这个环节需要关注异步处理上的优化。\n\n不重要的解析器标量强制&#123;\n  human(id: 1002) &#123;\n    name      # 先处理name\n    appearsIn # appearsIn,starships同步执行， appearsIn 是枚举类型\n    starships &#123;\n      name\n    &#125;\n  &#125;\n&#125;\n\nappearsIn 字段，因为类型系统已经被设定，所以解析器函数的返回值必须符合与类型系统对应的 API 规则的约束\n列表解析器返回一个 Promises 列表，并发执行这些 Promise，当执行结束返回一个对象列表后，它将继续并发加载列表中每个对象的 name 字段。\n产生结果当每个字段被解析时，结果被放置到键值映射中，字段名称（或别名）作为键值映射的键，解析器的值作为键值映射的值。这个过程从查询字段的底部叶子节点开始返回，直到根 Query 类型的起始节点。（为什么这么设计？）最后合并成为能够镜像到原始查询结构的结果，然后可以将其发送（通常为 JSON 格式）到请求的客户端。\n自省有时候会需要去问 GraphQL Schema 它支持哪些查询。GraphQL 通过内省系统让我们可以做到这点！\n助解：这个与 elastic 有点类似了，我们在不晓得有哪些东西的时候，自省关键字语句，就会给提示，这个对象有哪些东西\n语句&#123;\n  __schema &#123;\n    types &#123;\n      name\n    &#125;\n  &#125;\n&#125;\n\n返回&#123;\n  &quot;data&quot;: &#123;\n    &quot;__schema&quot;: &#123;\n      &quot;types&quot;: [\n        &#123;\n          &quot;name&quot;: &quot;Query&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;String&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;ID&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Mutation&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Episode&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Character&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Int&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;LengthUnit&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Human&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Float&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Droid&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;FriendsConnection&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;FriendsEdge&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;PageInfo&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Boolean&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Review&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;ReviewInput&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;Starship&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;SearchResult&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Schema&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Type&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__TypeKind&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Field&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__InputValue&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__EnumValue&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__Directive&quot;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;__DirectiveLocation&quot;\n        &#125;\n      ]\n    &#125;\n  &#125;\n&#125;\n\n有好多类型！它们都是什么？我们来总结一下：\n\nQuery, Character, Human, Episode, Droid - 这些是我们在类型系统中定义的类型。对象类型\nString, Boolean - 这些是内建的标量，由类型系统提供。\n__Schema, __Type, __TypeKind, __Field, __InputValue, __EnumValue, __Directive - 这些有着两个下划线的类型是内省系统的一部分。\n\n这里有点要注意的是：__TypeKind, __Field, __InputValue, __EnumValue, __Directive ,这些是 __Type 与 kind、field 等的组合\n现在，来试试找到一个可以探索出有哪些可用查询的地方。\n当我们设计类型系统的时候，我们确定了一个所有查询开始的地方，来问问内省系统它是什么！\n&#123;\n  __schema &#123;\n    queryType &#123;\n      name\n    &#125;\n  &#125;\n&#125;\n\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;__schema&quot;: &#123;\n      &quot;queryType&quot;: &#123;\n        &quot;name&quot;: &quot;Query&quot;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n类型 __type&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n  &#125;\n&#125;\n\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;\n    &#125;\n  &#125;\n&#125;\n\n种类例 1\n&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    kind # 是一个接口还是一个对象？\n  &#125;\n&#125;\n\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;,\n      &quot;kind&quot;: &quot;OBJECT&quot;\n    &#125;\n  &#125;\n&#125;\n\n例 2\n&#123;\n  __type(name: &quot;Character&quot;) &#123;\n    name\n    kind # 这里\n  &#125;\n&#125;\n\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Character&quot;,\n      &quot;kind&quot;: &quot;INTERFACE&quot; # 它是一个接口\n    &#125;\n  &#125;\n&#125;\n\n对象的字段&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    # 这里\n    fields &#123;\n      name\n      type &#123;\n        name\n        kind\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;,\n      &quot;fields&quot;: [\n        &#123;\n          &quot;name&quot;: &quot;id&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;name&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;friends&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;LIST&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;friendsConnection&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;appearsIn&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: null,\n            &quot;kind&quot;: &quot;NON_NULL&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;name&quot;: &quot;primaryFunction&quot;,\n          &quot;type&quot;: &#123;\n            &quot;name&quot;: &quot;String&quot;,\n            &quot;kind&quot;: &quot;SCALAR&quot;\n          &#125;\n        &#125;\n      ]\n    &#125;\n  &#125;\n&#125;\n\n查看包装类型 ofType&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    fields &#123;\n      name\n      type &#123;\n        name\n        kind\n        # 这里\n        ofType &#123;\n          name\n          kind\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n文档描述 description&#123;\n  __type(name: &quot;Droid&quot;) &#123;\n    name\n    description #这里\n  &#125;\n&#125;\n\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;__type&quot;: &#123;\n      &quot;name&quot;: &quot;Droid&quot;,\n      &quot;description&quot;: &quot;An autonomous mechanical character in the Star Wars universe&quot;\n    &#125;\n  &#125;\n&#125;\n\n分页复数复数类型字段对应的数据\n切片&#123;\n  hero &#123;\n    name\n    friends(first: 2) &#123;\n      # 前两个\n      name\n    &#125;\n  &#125;\n&#125;\n\n分页和边我们可以像这样 friends(first:2 offset:2) 来请求列表中接下来的两个结果。 &#x2F;&#x2F; 跳过 2 个，取 2 个我们可以像这样 friends(first:2 after:$friendId), 来请求我们上一次获取到的最后一个朋友之后的两个结果。&#x2F;&#x2F; 在某个id对应的数据之后取2个我们可以像这样 friends(first:2 after:$friendCursor), 从最后一项中获取一个游标并使用它来分页。 &#x2F;&#x2F; 在某个游标之后取 2 个\n完整链接模式&#123;\n  hero &#123;\n    name\n    friendsConnection(first: 2, after: &quot;Y3Vyc29yMQ&#x3D;&#x3D;&quot;) &#123;\n      totalCount\n      edges &#123;\n        node &#123;\n          name\n        &#125;\n        cursor\n      &#125;\n      pageInfo &#123;\n        # 列表的结尾、计数及连接，晓得什么时候结束\n        endCursor\n        hasNextPage\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n&#123;\n  &quot;data&quot;: &#123;\n    &quot;hero&quot;: &#123;\n      &quot;name&quot;: &quot;R2-D2&quot;,\n      &quot;friendsConnection&quot;: &#123;\n        &quot;totalCount&quot;: 3,\n        &quot;edges&quot;: [\n          &#123;\n            &quot;node&quot;: &#123;\n              &quot;name&quot;: &quot;Han Solo&quot;\n            &#125;,\n            &quot;cursor&quot;: &quot;Y3Vyc29yMg&#x3D;&#x3D;&quot;\n          &#125;,\n          &#123;\n            &quot;node&quot;: &#123;\n              &quot;name&quot;: &quot;Leia Organa&quot;\n            &#125;,\n            &quot;cursor&quot;: &quot;Y3Vyc29yMw&#x3D;&#x3D;&quot;\n          &#125;\n        ],\n        &quot;pageInfo&quot;: &#123;\n          &quot;endCursor&quot;: &quot;Y3Vyc29yMw&#x3D;&#x3D;&quot;,\n          &quot;hasNextPage&quot;: false\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n","slug":"2022-11-03graphql","date":"2022-11-03T09:51:55.000Z","categories_index":"Graphql","tags_index":"Graphql","author_index":"举手摘月亮"},{"id":"005b684f59380abe36489fcebc43072f","title":"pdf 添加水印并下载","content":"页面渲染React-PDF + Canvas 实现预览水印效果\n需求变更用户下载 pdf 也要加载水印\n方案\n方案 1. 后端 在 pdf 上传时候水印\n方案 2. 后端 pdf 增加水印\n方案 3. 前端在文件上传时候增加水印\n方案 4. 前端在文件下载的时候增加水印\n\n现在场景是：文件直接存储到 COS 上面，没有经过后端\n那么只能采用前端实现方案，或者是前端把链接给后端，后端对文件下载，加完水印再给前端，肯定是前者更优\n前端实现方式用到两个库 pdf-lib + @pdf-lib&#x2F;fontkit\nhttps://github.com/Hopding/pdf-lib\n\nhttps://github.com/foliojs/fontkit\n\n不支持中文是 fontkit 使用问题，不是 pdf-lib 问题\nhttps://github.com/Hopding/pdf-lib/issues/494\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;pdf-lib&#x2F;1.14.1&#x2F;pdf-lib.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;@pdf-lib&#x2F;fontkit&#x2F;dist&#x2F;fontkit.umd.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;downloadjs@1.4.7&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n\n  &lt;style&gt;\n    body &#123;\n      width: 100vw;\n      height: 100vh;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      flex-direction: column;\n    &#125;\n\n    p &#123;\n      font-family: helvetica;\n      font-size: 24px;\n      text-align: center;\n      margin: 25px;\n    &#125;\n\n    .small &#123;\n      font-family: helvetica;\n      font-size: 18px;\n      text-align: center;\n      margin: 25px;\n    &#125;\n\n    button &#123;\n      background-color: #315efb;\n      border: none;\n      color: white;\n      padding: 14px 32px;\n      border-radius: 10px;\n      text-align: center;\n      font-size: 16px;\n      cursor: pointer;\n    &#125;\n  &lt;&#x2F;style&gt;\n\n  &lt;body&gt;\n    &lt;p&gt;点击这个按钮通过&lt;code&gt;pdf-lib&lt;&#x2F;code&gt;给原来的pdf文件添加水印&lt;&#x2F;p&gt;\n    &lt;button onclick&#x3D;&quot;modify()&quot;&gt;Modify PDF&lt;&#x2F;button&gt;\n    &lt;p class&#x3D;&quot;small&quot;&gt;(点击后自动下载修改完成后的pdf文件)&lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F;1. 引入相关对象和方法\n    const &#123; degrees, PDFDocument, rgb, StandardFonts &#125; &#x3D; PDFLib; &#x2F;&#x2F;引入PDFLib相关方法\n    const fontkit &#x3D; window.fontkit; &#x2F;&#x2F;引入自定义字体工具包\n\n    &#x2F;&#x2F; pdf浏览\n    async function modify() &#123;\n      &#x2F;*2. 获取pdf文件的arrarybuffer文件流\n         可请求后台接口返回的base64文件流，然后转成arrayBuffer类型\n         可访问前端项目中的本地文件\n         不能直接访问服务器链接文件，会有跨域问题*&#x2F;\n      const url &#x3D; &quot;.&#x2F;1.pdf&quot;;\n      const existingPdfBytes &#x3D; await fetch(url).then((res) &#x3D;&gt;\n        res.arrayBuffer()\n      );\n      &#x2F;&#x2F; 将arraybuffer数据转成pdf文档\n      const pdfDoc &#x3D; await PDFDocument.load(existingPdfBytes);\n\n      &#x2F;&#x2F;3. 自定义字体，如不需要使用自定义字体可以将这一段全部注释掉，也不用下载自定义字体文件和自定义字体工具fontkit\n      &#x2F;&#x2F;将自己下载好的.ttf文件放置项目中，然后访问文件路径\n      const fonturl &#x3D; &quot;.&#x2F;fangzhengkaiti.ttf&quot;;\n      const fontBytes &#x3D; await fetch(fonturl).then((res) &#x3D;&gt; res.arrayBuffer());\n      &#x2F;&#x2F; 自定义字体挂载、fontkit为自定义字体注册工具\n      pdfDoc.registerFontkit(fontkit);\n      const customFont &#x3D; await pdfDoc.embedFont(fontBytes);\n\n      &#x2F;&#x2F; 内置字体（不支持中文）, 如果水印中不包含中文可直接用内置字体，本次这里没用到内置字体\n      const helveticaFont &#x3D; await pdfDoc.embedFont(StandardFonts.Helvetica);\n\n      &#x2F;&#x2F;4. 添加水印\n      &#x2F;&#x2F;为每页pdf添加文字水印\n      const pages &#x3D; pdfDoc.getPages();\n      for (let i &#x3D; 0; i &lt; pages.length; i++) &#123;\n        const noPage &#x3D; pages[i];\n        const &#123; width, height &#125; &#x3D; noPage.getSize();\n        for (let i &#x3D; 0; i &lt; 10; i++) &#123;\n          for (let j &#x3D; 0; j &lt; 3; j++) &#123;\n            noPage.drawText(&quot;版权所有，侵权不究！&quot;, &#123;\n              x: 230 * j,\n              y: (height &#x2F; 5) * i,\n              size: 16,\n              font: customFont, &#x2F;&#x2F;这里使用的是自定义字体\n              &#x2F;&#x2F;使用上面定义好的内置字体\n              &#x2F;&#x2F; font: helveticaFont,\n              color: rgb(0.46, 0.53, 0.6),\n              rotate: degrees(30),\n              opacity: 0.3,\n            &#125;);\n          &#125;\n        &#125;\n      &#125;\n\n      &#x2F;&#x2F;5. 保存pdf文件的unit64Arrary文件流\n      const pdfBytes &#x3D; await pdfDoc.save();\n      download(pdfBytes, &quot;test.pdf&quot;, &quot;application&#x2F;pdf&quot;); &#x2F;&#x2F;下载带水印的pdf\n\n      &#x2F;&#x2F;6. 新标签页预览、打印\n      let blobData &#x3D; new Blob([pdfBytes], &#123; type: &quot;application&#x2F;pdf;Base64&quot; &#125;);\n      let a &#x3D; document.createElement(&quot;a&quot;);\n      a.target &#x3D; &quot;_blank&quot;;\n      a.href &#x3D; window.URL.createObjectURL(blobData);\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n    &#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\n效果图\n\n字体选用\n\n参考链接https://github.com/Hopding/pdf-lib\n\nhttps://github.com/foliojs/fontkit\n\nhttps://github.com/Hopding/pdf-lib/issues/494\npdf-lib 给 pdf 添加水印并预览、下载、打印\n字体天下\n","slug":"2022-11-02pdf-watermark","date":"2022-11-02T03:37:47.000Z","categories_index":"PDF","tags_index":"PDF","author_index":"举手摘月亮"},{"id":"be1feee4446fde975b05a1617d4cbc8b","title":"云原生 了解elastic","content":"背景很有意思ElasticSearch 的由来\nelasticElasticSearch 实时搜索、分析引擎\nElasticSearch 基础入门篇\nElasticsearch 中文文档 7.3 \nElasticsearch Guide: 8.5\n在做 wiki 全文检索的时候，用到了这个/globalsearch/es/query,这是前端页面调用的接口，注意里面的es是 Elasticsearch的简写，后端对数据进行转化处理，调用 restful 风格的 elastic 进行查询，然后返回给前端\nKibana 用户手册（中文的，很友好）Kibana 用户手册\n在做 RN 移动端时候，公司用的这套东西，查看 ATOP 接口日志。当时不会用，现在嘛-还不会用，之后就会了 😂\nelastic 与 mysql 对比\n\n\n释义\nmysql\nElasticSearch\n\n\n\n数据库\nDatabase\nIndex\n\n\n表\nTable\nType\n\n\n行\nRow\nDocument\n\n\n列&#x2F;字段\ncolumn\nField\n\n\n关系\nschema\nMapping\n\n\n索引\nindex\nEverythis is indexed\n\n\nsql 语句\nsql\nQuery DSL\n\n\n查询\nselect * from table\nGET http:&#x2F;&#x2F;…\n\n\n更新\nupdate table set\nGET http:&#x2F;&#x2F;…\n\n\n\nMySQL 中的数据库（DataBase），等价于 ES 中的索引（Index）。\nMySQL 中一个数据库下面有 N 张表（Table），等价于 1 个索引 Index 下面有 N 多类型（Type）。\nMySQL 中一个数据库表（Table）下的数据由多行（Row）多列（column，属性）组成，等价于 1 个 Type 由多个文档（Document）和多 Field 组成。\nMySQL 中定义表结构、设定字段类型等价于 ES 中的 Mapping。举例说明，在一个关系型数据库里面，Schema 定义了表、每个表的字段，还有表和字段之间的关系。与之对应的，在 ES 中，Mapping 定义索引下的 Type 的字段处理规则，即索引如何建立、索引类型、是否保存原始索引 JSON 文档、是否压缩原始 JSON 文档、是否需要分词处理、如何进行分词处理等。\nMySQL 中的增 insert、删 delete、改 update、查 search 操作等价于 ES 中的增 PUT&#x2F;POST、删 Delete、改 _update、查 GET。其中的修改指定条件的更新 update 等价于 ES 中的 update_by_query，指定条件的删除等价于 ES 中的 delete_by_query。\nMySQL 中的 group by、avg、sum 等函数类似于 ES 中的 Aggregations 的部分特性。\nMySQL 中的去重 distinct 类似 ES 中的 cardinality 操作。\nMySQL 中的数据迁移等价于 ES 中的 reindex 操作。\n\n作者：PhoenixWong链接：https://juejin.cn/post/6844903938550939661来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n查询数据Search your data\n查询语法Query DSL\n\n\ngo-elasticsearchgo-elasticsearch\n其他Elasticsearch 专栏\nElasticsearch 中文文档 7.3 \nElasticsearch Guide: 8.5\n","slug":"2022-11-02elastic","date":"2022-11-02T01:57:44.000Z","categories_index":"云原生","tags_index":"云原生","author_index":"举手摘月亮"},{"id":"05496899eea5e85a89886906e98004b9","title":"前端基础 - 抽象相等比较","content":"背景本来是当一个很小的知识点来写的，发现越写越多，所以拆出来，单独做一篇文章，文章标题看上去很抽象\njs 关于 valueOf()和 toString()js 关于 valueOf()和 toString()\n链接内部有错误，\nvar a &#x3D; [];\nconsole.log(![]); &#x2F;&#x2F;false\n\n&#x2F;&#x2F; 注意\n\n[] &#x3D;&#x3D; false; &#x2F;&#x2F; true\n![]; &#x2F;&#x2F; false\n\n&#x2F;&#x2F; 上面不能推出：\n[] &#x3D;&#x3D; ![]; &#x2F;&#x2F; true\n[] !&#x3D; []; &#x2F;&#x2F; true\n&#x2F;&#x2F; 费脑子\n\n把下面的看完来分析下：\n[] == false;:\n\n对象与 boolean 比较，会将[]执行 ToPrimitive,\nToPrimitive 第一参数非 Date 第二参数默认是 number 类型，执行 [].valueOf,返回[]非基本数据类型，执行.toString 返回 &#39;&#39;，\n转化成了：字符串与false比较,\n都要转化成 number， 0 &#x3D;&#x3D; 0， 返回 true\n\n![] 这个怎么理解了按照之前那种理解 !’’,就变成 true 了， 错了错了，，\n\n根据 Falsy 的规则, []是 true, ![]就是 false\n\n[] == ![];,\n\n! 优先级高于比较运算符， ![] 转化成 boolean 是 false ,\n对象和 false 比较，[].valueOf().toString() &#x3D;&#x3D; false, 也就是 ‘’ &#x3D;&#x3D;&#x3D; false,\n都要转化成 number 类型 ToNumber(‘’) &#x3D;&#x3D;&#x3D; ToNumber(false),\n0&#x3D;&#x3D;0 最终是 true\n\n[] != [];\n满足抽象相等表格对角线比较，转化成 [] !== [],所以是 true\n严格等 &#x3D;&#x3D;&#x3D;\n对于除了数值之外的值，全等操作符使用明确的语义进行比较：一个值只与自身全等。\n对于数值，全等操作符使用略加修改的语义来处理两个特殊情况：\n第一个情况是，浮点数 0 是不分正负的。区分 +0 和 -0 在解决一些特定的数学问题时是必要的，但是大部分情况下我们并不用关心。全等操作符认为这两个值是全等的。\n第二个情况是，浮点数包含了 NaN 值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。全等操作符认为 NaN 与其他任何值都不全等，包括它自己\n\n\n\n（等式 (x !== x) 成立的唯一情况是 x 的值为 NaN） 我想说 MDN 写错了，\n&#x2F;&#x2F; 数值类型比较的才是值，单有NaN这个奇葩存在\nNaN !&#x3D;&#x3D; NaN &#x2F;&#x2F; true\n&#x2F;&#x2F; 引用数据类型比较的不是值，而是其引用\n[] !&#x3D;&#x3D; [] &#x2F;&#x2F; true\n&#123;&#125; !&#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; true\n\n[]&#x3D;&#x3D;false 为什么是 true?\n首先因为 &#x3D;&#x3D; 号有强制转换功能，右边 false 先变为 0，而接下来左边先会执行[].valueOf()返回本身还是[]\n因为执行 valueOf()不返回原始值（Number,String,Boolean,Underfined,Null),[]是个 Object，是引用类型，所以还会执行[].toString()方法返回” “，一个空字符串，最终空字符串在转换为 0，所以[]&#x3D;&#x3D;false，返回的是 true。\n\n为什么会执行 valueOf()和 toString(),他们又是什么东西？打印 Object 的 prototype 可以发现对象原型里有 valueOf()和 toString()这两个方法，数组也是对象所以说它也能调用这个方法\n那为什么会调用这个方法呢？涉及到：抽象相等比较算法\n抽象相等比较 &#x3D;&#x3D;表格内容出自 MDN,因为 MDN 有滚动，看着不方便，然后调整了下样式，这个截下来了\n\n\n在上面的表格中，\n\nToNumber(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符 +）的效果相同。\nToPrimitive(A)通过尝试调用 A 的 A.toString() 和 A.valueOf() 方法，将参数 A 转换为原始值（Primitive）。\nIsFalsy,充当效仿 undefined 的角色的对象会 等于 undefined/null 对应上文 javascript Falsy\n\n表格数据怎么看\n横着看 图 1，看 undefined,null 两横行\n看对角线 图 2，同类型比较，看严格等 &#x3D;&#x3D;&#x3D;\n看对角线以下，\nnumber 类型与其他类型（非 1,2）的 es5 基本类型比较,转化成 number,引用类型使用 ToPrimitive 转化后比较 （here1）\nstring 类型与其他类型（非 1,2）的 es5 基本类型比较,转化成 number,引用类型使用 ToPrimitive 转化后比较 （here1）\nboolean 类型与其他类型（非 1,2）的 es5 基本类型比较转化成 number,引用类型使用 ToPrimitive 转化后比较 （here1）\n引用 类型与其他类型（非 1,2）的 es5 基本类型比较，boolean 类型会转化成 number，引用类型使用 ToPrimitive 转化后比较 （here1）\n总结：对角线以下的比较，基本上都要转化成 number 进行比较，引用类型会使用 ToPrimitive 转化成基本数据类型， 中间过程中如果可以转化成对角线比较，直接进行 &#x3D;&#x3D;&#x3D;比较\n\n\n（here1）位置，根据 ToPrimitive 在进行比较 ，ToPrimitive 是 number&#x2F;string 的，按照 number&#x2F;string 进行比较\n\n注意点:\n\nnumber 和 string，在与对象进行比较时候，并不是立即就转化的，要看 ToPrimitive 的执行结果，如果 ToPrimitive 转化结果刚好是同类型不用转化了，如果不是同类型，非 string,boolean 要转化成 number\n这里排除了 Symbol 和 Bigint, 排除的原因 Symbol 在一些转化中，会报错，所以上文限制了 es5 基本数据类型\n\n图 1 横着看\n图 2 看对角线\n一般而言，根据 ECMAScript 规范，\n\n所有的对象都与 undefined 和 null 不相等。\n但是大部分浏览器允许非常窄的一类对象（即，所有页面中的 document.all 对象），在某些情况下，充当效仿 undefined 的角色。\n相等操作符就是在这样的一个背景下。因此，IsFalsy(A) 方法的值为 true，当且仅当 A 效仿 undefined。\n在其他所有情况下，一个对象都不会等于 undefined 或 null。\n\n这幅图看上去很多，其实吧，背后的东西更多\n\nFalsy\nToNumber\nToString\nToPrimitive\n\nFalsy当 JavaScript 期望一个布尔值，并被给与下面值中的一个时，它总是会被当做 false。\n\n\n\n序号\n值\n说明\n\n\n\n1\nundefined\nundefined - 原始值\n\n\n2\nnull\nnull - 缺少值\n\n\n5\nfalse\nfalse 关键字\n\n\n4\n“”,’’,&#96;&#96;\n空字符串\n\n\n3\n0 ,+0,-0, 0n, NaN\n数值 ,Bigint 0\n\n\nToNumber\n\n\ninput\nresult\n\n\n\nundefined\nNaN\n\n\nnull\n+0\n\n\nboolean\n+0 或 1\n\n\nnumber\n不转换\n\n\nstring\n参照§7.1.3.1 \n\n\nsymbol\nTypeError\n\n\nBigint\nTypeError\n\n\nobject\nToNumber(ToPrimitive(input,Number))\n\n\n\n把字符串转换成数字，不是简单地“去掉引号”，具体规则参照§7.1.3.1。\n\nNumber(&#39;123&#39;); &#x2F;&#x2F;123\nNumber(&#39;&#39;); &#x2F;&#x2F;0\nNumber(&#39; 123 &#39;); &#x2F;&#x2F;123\nNumber(&#39;a123&#39;); &#x2F;&#x2F;NaN\n\n\n把 symbol 转换成数字，会直接抛出类型错误。\n把对象转换成数字，会先进行 ToPrimitive(input,Number)，然后把得到的值进行转换\n\nToString注意：要和对象的.toString 方法区分开，这两个完全没关系\nhttps://tc39.es/ecma262/#sec-tostring\n\n\n\ninput\nresult\n\n\n\nnull\n‘null’\n\n\nundefined\n‘undefined’\n\n\nnumber\nReturn Number::toString(argument, 10) 链接就不放了，打击人\n\n\nboolean\n‘true’或’false’\n\n\nstring\n不转换\n\n\nsymbol\nTypeError\n\n\nsymbol\nReturn BigInt::toString(argument, 10) 链接就不放了，打击人\n\n\nobject\nToString(ToPrimitive(input,String))\n\n\nToPrimitive&#x2F;&#x2F; ToPrimitive api\nToPrimitive(input [, PreferredType])\n\n\n\n\ninputTpye\nresult\n\n\n\nNull\n不转换，直接返回\n\n\nUndefined\n不转换，直接返回\n\n\nNumber\n不转换，直接返回\n\n\nBoolean\n不转换，直接返回\n\n\nString\n不转换，直接返回\n\n\nSymbol\n不转换，直接返回\n\n\nObject\n按照下列步骤进行转换\n\n\n在没有改写或自定义@@toPrimitive 方法的条件下，\n\n如果是 Date 求原值，则 PreferredType 是 String，其他均为 Number。\nPreferredType 是 String，则先调用 toString()，结果不是原始值的话再调用 valueOf()，还不是原始值的话则抛出错误；\nPreferredType 是 Number，则 先调用 valueOf(),结果不是原始值的话再调用 toString() ，还不是原始值的话则抛出错误；\n\n一元运算符+一元运算符“+”是用来把目标转化成数字类型的。\n&#x2F;&#x2F; UnaryExpression: +UnaryExpression;\n\n\n把 UnaryExpression 的 result 赋值给 expr\n返回 ToNumber(GetValue(expr)).\n\n在一元“+”运算过程中，把目标直接转化成数字类型。一共涉及了一个方法：ToNumber()。\n+[]; &#x2F;&#x2F; 0\n\n&#x2F;&#x2F; 转化过程\n&#x2F;&#x2F; 1. [] 执行ToPrimitive([], &#39;number&#39;)\n&#x2F;&#x2F; 2. 首先会执行[].valueOf(),返回 []，不是基本数据类型，\n&#x2F;&#x2F; 执行 [].toString() 返回 &#39;&#39;， 是基本数据类型返回 &#39;&#39;\n&#x2F;&#x2F; +&#39;&#39; &#x3D;&gt; 0 ，所以结果为0\n\n装箱&#x2F;拆箱见\necma 文档还是别看了吧，不建议去看\n抽象操作\n参考链接JavaScript 中的相等性判断\njs 隐式装箱-ToPrimitive\n","slug":"2022-11-01抽象相等比较","date":"2022-11-01T07:33:16.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"97b3539570c7a7e3061d80de5bc34fae","title":"前端基础 技巧","content":"链接2022 年你需要了解的 13 种 JavaScript 代码技巧\n如何用一行 CSS 实现 10 种现代布局\nhttps://1linelayouts.glitch.me/\n","slug":"2022-10-31js技巧","date":"2022-10-31T09:26:36.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"a03d410eec3e63ae5b6746e1792d1f46","title":"go knife","content":"效果图\n\n参考参考\n初始化项目mkdir src\ntouch main.go\ngo mod init go-localize\ngo mod tidy\nmkdir config controller dao middleware model router service tmp util constant internet\n...\n\n\nair安装参考 issues 135\n$ curl -sSfL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cosmtrek&#x2F;air&#x2F;master&#x2F;install.sh | sh -s -- -b $(go env GOPATH)&#x2F;bin\n$ air -v\n\n---\n\n&#x2F; &#x2F;\\ | | | |_)\n&#x2F;_&#x2F;--\\ |_| |_| \\_ 1.40.4, built with Go 1.18.3\n\n\n配置 aliasalias air&#x3D;&#39;$(go env GOPATH)&#x2F;bin&#x2F;air&#39;\n\n注意：比较奇怪的是 air -v 可输出， air 命令颜色为红色， 非绿色\n使用注意：终端需要重启\n最简单的方法是执行\n\n# 优先在当前路径查找 &#96;.air.toml&#96; 后缀的文件，如果没有找到，则使用默认的\n\nair -c .air.toml\n\n您可以运行以下命令初始化，把默认配置添加到当前路径下的.air.toml 文件。\n\nair init\n\n在这之后，你只需执行 air 命令，无需添加额外的变量，它就能使用 .air.toml 文件中的配置了。\n\nair\n\n\n\n出错了写了 you.go 文件，空文件，没有写 package\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize $ air\n\n  __    _   ___\n &#x2F; &#x2F;\\  | | | |_)\n&#x2F;_&#x2F;--\\ |_| |_| \\_ 1.40.4, built with Go 1.18.3\n\nwatching .\nwatching config\nwatching controller\nwatching controller&#x2F;v1\nwatching dao\nwatching middleware\nwatching model\nwatching router\nwatching service\n!exclude tmp\nwatching util\nbuilding...\ncontroller&#x2F;v1&#x2F;you.go:1:1: expected &#39;package&#39;, found &#39;EOF&#39;\nfailed to build, error: exit status 1\n\n起来了♠ &#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize $ air\n\n  __    _   ___\n &#x2F; &#x2F;\\  | | | |_)\n&#x2F;_&#x2F;--\\ |_| |_| \\_ 1.40.4, built with Go 1.18.3\n\nwatching .\nwatching config\nwatching controller\nwatching controller&#x2F;v1\nwatching dao\nwatching middleware\nwatching model\nwatching router\nwatching service\n!exclude tmp\nwatching util\nbuilding...\nrunning...\n[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.\n\n[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.\n - using env:   export GIN_MODE&#x3D;release\n - using code:  gin.SetMode(gin.ReleaseMode)\n\n[GIN-debug] GET    &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.GetMe (3 handlers)\n[GIN-debug] POST   &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.PostMe (3 handlers)\n[GIN-debug] PUT    &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.PutMe (3 handlers)\n[GIN-debug] DELETE &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.DeleteMe (3 handlers)\n[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\nPlease check https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;gin-gonic&#x2F;gin#readme-don-t-trust-all-proxies for details.\n[GIN-debug] Listening and serving HTTP on :8001\n\n重启耗时如何查看？监听文件有点多，应该需要限制下范围\n[GIN-debug] Listening and serving HTTP on :8001\nevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: CHMOD\nevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: WRITE\nevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: CHMOD\nevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: WRITE\nevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: CHMOD\n\n文件范围缩小创建文件夹，将所有代码移动到 src 目录下，监听 src 目录\n&#x2F;&#x2F; .air.toml\nroot &#x3D; &quot;.&#x2F;src&quot;\n\ngit&#x2F;&#x2F; 空文件夹上传\nfind .&#x2F; -type d -empty -execdir touch &#123;&#125;&#x2F;.gitkeep &#123;&#125; \\;\ngit init\ngit add .\ngit commit -m &quot;first commit&quot;\ngit branch -M main\ngit remote add origin git@github.com:841660202&#x2F;go-localize.git\ngit push -u origin main\n\nginswag安装 swag&#x2F;&#x2F; 1. 安装 swagger\n&#x2F;&#x2F; go install github.com&#x2F;swaggo&#x2F;swag&#x2F;cmd&#x2F;swag@latest\n\n&#x2F;&#x2F; 2. 配置~&#x2F;.zshrc  注意：引号 github 上引号没写\n&#x2F;&#x2F; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;swaggo&#x2F;swag&#x2F;issues&#x2F;197&quot; target&#x3D;&quot;_blank&quot; &gt;issues197&lt;&#x2F;a&gt;\n&#x2F;&#x2F; export PATH&#x3D;&quot;$(go env GOPATH)&#x2F;bin:$PATH&quot;\n\n&#x2F;&#x2F; $ swag -v\n&#x2F;&#x2F; swag version v1.8.7\n\n&#x2F;&#x2F; swag init  &#x2F;&#x2F; 注意，一定要和main.go处于同一级目录\n\n&#x2F;&#x2F; 访问地址\n&#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8080&#x2F;swagger&#x2F;index.html\n\n\nknife注意\n\n\n\n\n\n\nWARNING\n注意：必须要有@ID 注解，生成 operationId，点击菜单才能正常打开id 用于标识操作的唯一字符串。在所有 API 操作中必须唯一。\n\n&#x2F;swaggo&#x2F;swag&#x2F;pull&#x2F;732\n&#x2F;&#x2F; 访问链接\n&#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8080&#x2F;knife&#x2F;doc.html#&#x2F;home\n\n参考\nknife 优化点\n刷新页面，菜单没默认打开对应的链接\n复制接口&#x2F;文档&#x2F;地址，点击一次提示两次\n后续：自动生成前端代码\n\ngin knife 例子\n\n\n\n\n\n\nWARNING\n注意：必须要有@ID 注解，生成 operationId，点击菜单才能正常打开id 用于标识操作的唯一字符串。在所有 API 操作中必须唯一。\n\n&#x2F;swaggo&#x2F;swag\n","slug":"2022-10-31go-knife","date":"2022-10-31T04:20:11.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"492ad8fe5c882da5782b1a12ae580fb4","title":"go 知识积累","content":"strconv见\nsync.WaitGrouphttp://c.biancheng.net/view/108.html\n包&#x2F;&#x2F; redis\ngo get github.com&#x2F;go-redis&#x2F;redis\n\n&#x2F;&#x2F; .ini\ngo get gopkg.in&#x2F;ini.v1 v1.64.0\n\n&#x2F;&#x2F; gorm\ngo get github.com&#x2F;jinzhu&#x2F;gorm\n\n&#x2F;&#x2F; gin\ngo get github.com&#x2F;gin-gonic&#x2F;gin\n\n&#x2F;&#x2F; jwt\ngo get github.com&#x2F;dgri.jalva&#x2F;jwt-go\n\n&#x2F;&#x2F; log\ngo get github.com&#x2F;sirupsen&#x2F;logrus\n\n&#x2F;&#x2F; 参数绑定\n\n&#x2F;&#x2F; 验证器\n&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;go-playground&#x2F;validator\n&#x2F;&#x2F; [学会使用validator库，看这一篇就够用了](https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;194319694)\n\n&#x2F;&#x2F; favicon\ngo get github.com&#x2F;thinkerou&#x2F;favicon\n\n&#x2F;&#x2F; knife4go\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;gitee.com&#x2F;youbeiwuhuan&#x2F;knife4go#https:&#x2F;&#x2F;gitee.com&#x2F;xiaoym&#x2F;knife4j\n\n&#x2F;&#x2F; uuid\n&#x2F;&#x2F; github.com&#x2F;gofrs&#x2F;uuid\n\n&#x2F;&#x2F; example https:&#x2F;&#x2F;github.com&#x2F;swaggo&#x2F;swag&#x2F;blob&#x2F;master&#x2F;example&#x2F;celler&#x2F;model&#x2F;account.go\n\n&#x2F;&#x2F;gojson, 有什么用？前后端约定好字段，生成结构体？\n&#x2F;&#x2F; gojson generates go struct definitions from json or yaml documents.\n&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ChimeraCoder&#x2F;gojson\n\n&#x2F;&#x2F; 在线转化\n&#x2F;&#x2F; https:&#x2F;&#x2F;mholt.github.io&#x2F;json-to-go&#x2F;\n\n源码https://github.com/CocaineCong/gin-mall\n\n刷课程go 重点语法\nGin 框架全套实战\n【Go 语言 web 开发】经典项目电子商城\ngo 包\n文档&#x2F;资料下载&#x2F;零碎知识点.html\nelasticElasticsearch 全文检索数据库\n\n分布式、高扩展、近实时的搜索引擎，主要用于海量数据快速存储，实时检索，高效分析的场景\n通过简单易用的 RESTful API，隐藏 Lucene 的复杂性，让全文搜索变得简单\nES 不是什么新技术，主要是将全文检索、数据分析以及分布式技术结合在一起，形成了独一无二的 ES；\n\nGo Elasticsearch 快速入门\n爬取 CSDN 专栏Elasticsearch 基本概念\nElasticsearch 简介\nGo Elasticsearch index CRUD\nGo Elasticsearch 删除快速入门\nGo Elasticsearch 更新快速入门\nGo Elasticsearch 增加快速入门\nGo Elasticsearch 查询快速入门\nGo Elasticsearch 快速入门\nvar data &#x3D; &quot;&quot;;\nArray.prototype.slice\n  .call(document.getElementsByClassName(&quot;column_article_list&quot;))\n  .forEach((ul) &#x3D;&gt; &#123;\n    Array.from(ul.children).forEach((li) &#x3D;&gt; &#123;\n      var a &#x3D; li.children[0];\n      console.log(a);\n      var href &#x3D; a.href;\n      var title &#x3D; a.getElementsByClassName(&quot;title&quot;)[0].innerText;\n      var astr &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;href&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;title&#125;&lt;&#x2F;a&gt; \\n\\n&#96;;\n      data +&#x3D; astr;\n    &#125;);\n  &#125;);\ncopy(data); &#x2F;&#x2F;控制台直接拷贝到剪切板\n","slug":"2022-10-29go-proj","date":"2022-10-29T04:47:02.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"196672c6a68ef10b6c449876bc5af600","title":"nextjs13 turbopack","content":"官方链接https://turbo.build/\nhttps://nextjs.org/\n比较一组数据\n \n  1000个组件量级，启动\n \n\n \n \n \n 10000个组件量级，文件变动\n\n\n \n\n\n实际开发中，组件个数可能远超过 10000\n从结果来看 vite 还强，速度快不是 next.js13 多牛叉，技术基本上早就成型，而是因为背靠 turbopack，想想 vite 诞生对 vue 的支持力度较大，react 资源较少，不过也够用的了，在2022-09-07vite-react 公司线上项目试了，确实快乐很多。\n现在 next.js13 内置，turbopack，想想也带劲，公司一直在用 next.js 进行项目开发，在内部还整了个前端基建。那速度，使用过的同事，都能体会龟速，被喷的不要不要的，比自己搭建的还慢,有些部门直接弃用\n尤其是公司内部 wiki 编辑器的集成。直接导致，整个项目间歇式工作， Mac 8G 内存， CPU 给你顶飞\n现在，重拾信心，毕竟服务端渲染 SEO 的优势摆在那的\n体验一把启动 1👑 ~&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app git:(main) $ pn dev\n\n&gt; my-app@0.1.0 dev &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app\n&gt; next dev\n\nwarn  - Port 3000 is in use, trying 3001 instead.\nwarn  - Port 3001 is in use, trying 3002 instead.\nready - started server on 0.0.0.0:3002, url: http:&#x2F;&#x2F;localhost:3002\nevent - compiled client and server successfully in 2.1s (150 modules)\nwait  - compiling...\nevent - compiled client and server successfully in 161 ms (150 modules)\n\n哎呦我去～，这么久，配个端口重来\n启动 2电脑启动多个项目，端口占用了，重来～\n👑 ~&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app git:(main) ✗ $ pn dev\n\n&gt; my-app@0.1.0 dev &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app\n&gt; next dev --port 3005\n\nready - started server on 0.0.0.0:3005, url: http:&#x2F;&#x2F;localhost:3005\nevent - compiled client and server successfully in 812 ms (150 modules)\n\n总感觉怪怪的查看了下根目录下生成的.next，在.next/cache/下依然是 webpack\n\n\n被骗了吗？，不应该啊\n这才是正确姿势$ pn turbo\n\n&gt; my-app@0.1.0 turbo &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app\n&gt; next dev --turbo --port 3005\n\n&gt;&gt;&gt; TURBOPACK (alpha)\n\nThank you for trying Next.js v13 with Turbopack! As a reminder,\nTurbopack is currently in alpha and not yet ready for production.\nWe appreciate your ongoing support as we work to make it ready\nfor everyone.\n\nWarning: You are using configuration that may require additional\nsetup with Turbopack. If you already made these changes please\nignore this warning.\n\n- PostCSS detected (postcss.config.js)\n  PostCSS is not yet supported by Next.js v13 with Turbopack.\n  To use with Turbopack, see: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-postcss\n\n- Tailwind detected (tailwind.config.js)\n  Tailwind is not yet supported by Next.js v13 with Turbopack.\n  To use with Turbopack, see: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-tailwind\n\nLearn more about Next.js v13 and Turbopack: https:&#x2F;&#x2F;nextjs.link&#x2F;with-turbopack\nPlease direct feedback to: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-feedback\n\nready - started server on 0.0.0.0:3005, url: http:&#x2F;&#x2F;localhost:3005\nevent - initial compilation 5.974ms\nerror - [rendering] [root of the dev server]&#x2F;\n  Error during SSR Rendering\n  timed out waiting for the Node.js process to connect\n\nevent - updated in 2125ms\nevent - updated in 1521ms\n\n报错了跑不起来 升级 nodejs 16+nextjs 官方 blog 只说了：The minimum Node.js version has been bumped from 12.22.0 to 14.6.0, since 12.x has reached end-of-life (PR).issue 41859\n\n$ sudo n\nPassword:\n   installed : v16.13.1 (with npm 8.1.2)\n\n\nnext.js 图片报错应该是 turbo 的原因导致的，没用之前正常\n&#x2F;&#x2F; next.config.js\n&#x2F;** @type &#123;import(&#39;next&#39;).NextConfig&#125; *&#x2F;\nconst nextConfig &#x3D; &#123;\n  reactStrictMode: true,\n  swcMinify: true,\n  images: &#123;\n    remotePatterns: [\n      &#123;\n        protocol: &quot;https&quot;,\n        hostname: &quot;images.unsplash.com&quot;,\n        port: &quot;&quot;,\n        pathname: &quot;&#x2F;**&#x2F;*&quot;,\n      &#125;,\n    ],\n  &#125;,\n&#125;;\n\nmodule.exports &#x3D; nextConfig;\n\n解决方案next-13#breaking-changes\n\n\n\n\n\n\n\n\n\nThe next&#x2F;image import was renamed to next&#x2F;legacy&#x2F;image. The next&#x2F;future&#x2F;image import was renamed to next&#x2F;image. A codemod is available to safely and automatically rename your imports.\ntailwind css 全部失效目前还不支持\n\n- PostCSS detected (postcss.config.js)\n  PostCSS is not yet supported by Next.js v13 with Turbopack.\n  To use with Turbopack, see: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-postcss\n\n\n总结\nnext.js13 turbo 问题还不少，暂时不适合用到正式项目\n正如开头说的，没有 turbo 的 next.js13 速度还是慢\n\n","slug":"2022-10-28nextjs13","date":"2022-10-28T06:50:11.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"ae7214e6b6b6dc80cfe5f43a5613e628","title":"前端基础-移动端适配","content":"网易精品课移动端适配方案\n小红书网页代码&lt;script&gt;\n  function setPixel() &#123;\n    var e &#x3D; parseFloat(\n      window\n        .getComputedStyle(document.documentElement, null)\n        .getPropertyValue(&quot;font-size&quot;)\n    );\n    function n() &#123;\n      var n &#x3D; Math.min(60, (document.documentElement.clientWidth &#x2F; 375) * 50);\n      document.documentElement.style.fontSize &#x3D; (n &#x2F; e) * 16 + &quot;px&quot;;\n    &#125;\n    &quot;boolean&quot; !&#x3D; typeof window.isResponsive || window.isResponsive\n      ? (n(),\n        window.addEventListener(\n          &quot;orientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;,\n          n,\n          !1\n        ))\n      : (document.documentElement.style.fontSize &#x3D; &quot;50px&quot;);\n  &#125;\n  &quot;undefined&quot; !&#x3D; typeof window &amp;&amp; setPixel();\n&lt;&#x2F;script&gt;\n","slug":"2022-10-28移动适配","date":"2022-10-28T02:03:07.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"21c81236c6b792525b47c142ae6ad187","title":"前端基础-设计模式","content":"旧文章链接post&#x2F;2022-07-18 设计模式\n《JavaScript 设计模式与开发实践》chatGPT误区：为何使用设计模式后，会感觉将代码复杂化了使用设计模式是为了提高代码的可维护性、可扩展性、可读性、可测试性等方面的优点，但这并不代表使用设计模式后代码一定会变得简单。\n设计模式的使用通常需要引入额外的类和对象，从而增加代码的复杂度。另外，设计模式并不是万能的，不同的场景需要选择不同的设计模式，正确地选择和应用设计模式也需要一定的经验和技巧。\n因此，在使用设计模式时需要权衡利弊，根据实际情况选择合适的设计模式，以提高代码的质量和可维护性。\nJavaScript 设计模式JavaScript 设计模式是一种解决软件设计问题的通用方法，这些问题可能涉及代码复杂性、可维护性、可扩展性等等。下面是一些常见的 JavaScript 设计模式：\n\n工厂模式（Factory Pattern）：用于创建对象的模式，通过调用工厂方法或者构造函数来创建对象。\n单例模式（Singleton Pattern）：确保一个类只有一个实例，提供一个全局访问点。\n原型模式（Prototype Pattern）：用于创建对象的一种模式，通过复制一个已经存在的对象来创建新的对象。\n观察者模式（Observer Pattern）：定义了对象之间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知。\n订阅发布模式（Publish-Subscribe Pattern）：类似于观察者模式，但是不同的是，订阅者需要明确地向发布者订阅通知，而不是被动地接收通知。\n装饰者模式（Decorator Pattern）：允许向一个现有的对象添加新的功能，同时又不改变其结构。\n策略模式（Strategy Pattern）：定义了一系列算法，将每个算法封装起来，并使它们可以相互替换，使得算法可以独立于使用它的客户而变化。\n代理模式（Proxy Pattern）：提供了一个代理对象来控制对另一个对象的访问，可以用于实现延迟加载、权限控制等功能。\n\n这些模式是设计模式中最常见的几种，但是并不是全部。在实际应用中，可能会涉及到更多的模式。\njs 工厂模式工厂模式（Factory Pattern）是一种创建对象的设计模式，它提供了一种通过调用工厂方法或者构造函数来创建对象的方式，而不需要在代码中直接实例化对象。\n工厂模式的主要思想是将对象的创建过程抽象出来，将其封装在一个工厂类中。这个工厂类负责根据不同的条件来创建不同的对象，而客户端代码只需要通过调用工厂类的方法来获得所需要的对象，而不需要关心对象的创建过程。\n工厂模式的优点是可以将对象的创建过程与客户端代码分离开来，这样可以降低代码的耦合度，使代码更易于维护和扩展。另外，工厂模式还可以隐藏对象的实现细节，提高代码的安全性。\n常见的工厂模式包括简单工厂模式、工厂方法模式和抽象工厂模式。其中，\n\n简单工厂模式是最基础的工厂模式，它通过一个工厂类来创建所有需要的对象，客户端只需要传递相应的参数即可；\n工厂方法模式将对象的创建过程交给不同的子工厂来完成，每个子工厂负责创建一类对象；\n抽象工厂模式则是针对不同产品族的对象进行创建，每个工厂可以创建一组相互依赖的对象。\n\njs 简单工厂模式 代码示例以下是一个简单的 JavaScript 工厂模式的代码示例，用于创建不同类型的汽车对象：\n&#x2F;&#x2F; 定义一个 Car 工厂类\nclass CarFactory &#123;\n  createCar(type) &#123;\n    let car;\n    switch (type) &#123;\n      case &#39;suv&#39;:\n        car &#x3D; new SuvCar();\n        break;\n      case &#39;sedan&#39;:\n        car &#x3D; new SedanCar();\n        break;\n      case &#39;hatchback&#39;:\n        car &#x3D; new HatchbackCar();\n        break;\n      default:\n        throw new Error(&#96;Invalid car type: $&#123;type&#125;&#96;);\n    &#125;\n    return car;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义不同类型的汽车类\nclass SuvCar &#123;\n  constructor() &#123;\n    this.type &#x3D; &#39;SUV&#39;;\n    this.price &#x3D; 30000;\n  &#125;\n&#125;\n\nclass SedanCar &#123;\n  constructor() &#123;\n    this.type &#x3D; &#39;Sedan&#39;;\n    this.price &#x3D; 25000;\n  &#125;\n&#125;\n\nclass HatchbackCar &#123;\n  constructor() &#123;\n    this.type &#x3D; &#39;Hatchback&#39;;\n    this.price &#x3D; 20000;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用 Car 工厂类创建不同类型的汽车对象\nconst carFactory &#x3D; new CarFactory();\nconst suvCar &#x3D; carFactory.createCar(&#39;suv&#39;);\nconst sedanCar &#x3D; carFactory.createCar(&#39;sedan&#39;);\nconst hatchbackCar &#x3D; carFactory.createCar(&#39;hatchback&#39;);\n\nconsole.log(suvCar); &#x2F;&#x2F; SuvCar &#123; type: &#39;SUV&#39;, price: 30000 &#125;\nconsole.log(sedanCar); &#x2F;&#x2F; SedanCar &#123; type: &#39;Sedan&#39;, price: 25000 &#125;\nconsole.log(hatchbackCar); &#x2F;&#x2F; HatchbackCar &#123; type: &#39;Hatchback&#39;, price: 20000 &#125;\n\n在这个例子中，CarFactory 是一个工厂类，它提供了一个 createCar 方法，根据传入的参数来创建不同类型的汽车对象。SuvCar、SedanCar 和 HatchbackCar 是不同类型的汽车类，它们的构造函数分别设置了 type 和 price 属性。客户端代码只需要通过 CarFactory 类的 createCar 方法来获得所需要的汽车对象，而不需要关心具体的对象创建过程。\njs 方法工厂代码示例以下是一个简单的 JavaScript 方法工厂模式的代码示例，用于创建不同类型的运算方法：\n&#x2F;&#x2F; 定义一个方法工厂类\nclass OperationFactory &#123;\n  static createOperation(operator) &#123;\n    switch (operator) &#123;\n      case &#39;+&#39;:\n        return new AddOperation();\n      case &#39;-&#39;:\n        return new SubtractOperation();\n      case &#39;*&#39;:\n        return new MultiplyOperation();\n      case &#39;&#x2F;&#39;:\n        return new DivideOperation();\n      default:\n        throw new Error(&#39;Unsupported operator!&#39;);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义不同类型的运算方法类\nclass AddOperation &#123;\n  operate(num1, num2) &#123;\n    return num1 + num2;\n  &#125;\n&#125;\n\nclass SubtractOperation &#123;\n  operate(num1, num2) &#123;\n    return num1 - num2;\n  &#125;\n&#125;\n\nclass MultiplyOperation &#123;\n  operate(num1, num2) &#123;\n    return num1 * num2;\n  &#125;\n&#125;\n\nclass DivideOperation &#123;\n  operate(num1, num2) &#123;\n    if (num2 &#x3D;&#x3D;&#x3D; 0) &#123;\n      throw new Error(&#39;Divisor can not be 0!&#39;);\n    &#125;\n    return num1 &#x2F; num2;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用方法工厂类创建不同类型的运算方法对象\nconst add &#x3D; OperationFactory.createOperation(&#39;+&#39;);\nconst subtract &#x3D; OperationFactory.createOperation(&#39;-&#39;);\nconst multiply &#x3D; OperationFactory.createOperation(&#39;*&#39;);\nconst divide &#x3D; OperationFactory.createOperation(&#39;&#x2F;&#39;);\n\nconsole.log(add.operate(1, 2)); &#x2F;&#x2F; 3\nconsole.log(subtract.operate(5, 3)); &#x2F;&#x2F; 2\nconsole.log(multiply.operate(2, 3)); &#x2F;&#x2F; 6\nconsole.log(divide.operate(10, 2)); &#x2F;&#x2F; 5\n\n在这个例子中，OperationFactory 是一个方法工厂类，它定义了一个静态方法 createOperation，根据传入的 operator 参数来创建不同类型的运算方法对象。AddOperation、SubtractOperation、MultiplyOperation 和 DivideOperation 是具体的运算方法类，它们的 operate 方法分别实现了加法、减法、乘法和除法运算。客户端代码只需要通过方法工厂类来创建所需要的运算方法对象，而不需要关心具体的对象创建过程。\njs 抽象工厂代码示例以下是一个简单的 JavaScript 抽象工厂模式的代码示例，用于创建不同类型的电子产品：\n&#x2F;&#x2F; 定义一个抽象工厂类\nclass ElectronicFactory &#123;\n  createPhone() &#123;&#125;\n  createComputer() &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个具体的工厂类，用于创建华为品牌的电子产品\nclass HuaweiFactory extends ElectronicFactory &#123;\n  createPhone() &#123;\n    return new HuaweiPhone();\n  &#125;\n  createComputer() &#123;\n    return new HuaweiComputer();\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个具体的工厂类，用于创建苹果品牌的电子产品\nclass AppleFactory extends ElectronicFactory &#123;\n  createPhone() &#123;\n    return new iPhone();\n  &#125;\n  createComputer() &#123;\n    return new MacBook();\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义不同类型的电子产品类\nclass HuaweiPhone &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Huawei&#39;;\n    this.type &#x3D; &#39;Phone&#39;;\n    this.price &#x3D; 5000;\n  &#125;\n&#125;\n\nclass HuaweiComputer &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Huawei&#39;;\n    this.type &#x3D; &#39;Computer&#39;;\n    this.price &#x3D; 8000;\n  &#125;\n&#125;\n\nclass iPhone &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Apple&#39;;\n    this.type &#x3D; &#39;Phone&#39;;\n    this.price &#x3D; 8000;\n  &#125;\n&#125;\n\nclass MacBook &#123;\n  constructor() &#123;\n    this.brand &#x3D; &#39;Apple&#39;;\n    this.type &#x3D; &#39;Computer&#39;;\n    this.price &#x3D; 12000;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用抽象工厂类创建不同品牌的电子产品对象\nconst huaweiFactory &#x3D; new HuaweiFactory();\nconst appleFactory &#x3D; new AppleFactory();\n\nconst huaweiPhone &#x3D; huaweiFactory.createPhone();\nconst huaweiComputer &#x3D; huaweiFactory.createComputer();\nconst iPhone &#x3D; appleFactory.createPhone();\nconst macBook &#x3D; appleFactory.createComputer();\n\nconsole.log(huaweiPhone); &#x2F;&#x2F; HuaweiPhone &#123; brand: &#39;Huawei&#39;, type: &#39;Phone&#39;, price: 5000 &#125;\nconsole.log(huaweiComputer); &#x2F;&#x2F; HuaweiComputer &#123; brand: &#39;Huawei&#39;, type: &#39;Computer&#39;, price: 8000 &#125;\nconsole.log(iPhone); &#x2F;&#x2F; iPhone &#123; brand: &#39;Apple&#39;, type: &#39;Phone&#39;, price: 8000 &#125;\nconsole.log(macBook); &#x2F;&#x2F; MacBook &#123; brand: &#39;Apple&#39;, type: &#39;Computer&#39;, price: 12000 &#125;\n\n在这个例子中，ElectronicFactory 是一个抽象工厂类，它定义了两个抽象方法 createPhone 和 createComputer，用于创建不同类型的电子产品。HuaweiFactory 和 AppleFactory 是具体的工厂类，它们分别继承了 ElectronicFactory 类，并实现了这两个抽象方法来创建不同品牌的电子产品。HuaweiPhone、HuaweiComputer、iPhone 和 MacBook 是具体的电子产品类，它们的构造函数分别设置了 brand、type 和 price 属性。客户端代码只需要通过具体的工厂类来创建所需要的电子产品对象，而不需要关心具体的对象创建过程。\njs 单例模式构造函数实现单例模式以下是一个简单的 JavaScript 单例模式的代码示例，用于创建唯一的日志记录器对象：\n&#x2F;&#x2F; 定义一个日志记录器类\nclass Logger &#123;\n  constructor() &#123;\n    if (Logger.instance) &#123;\n      return Logger.instance;\n    &#125;\n\n    this.logs &#x3D; [];\n    Logger.instance &#x3D; this;\n  &#125;\n\n  log(message) &#123;\n    this.logs.push(message);\n    console.log(&#96;[INFO] $&#123;message&#125;&#96;);\n  &#125;\n\n  printLogs() &#123;\n    console.log(&#39;Logs:&#39;);\n    this.logs.forEach((log) &#x3D;&gt; console.log(log));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用单例模式创建日志记录器对象\nconst logger1 &#x3D; new Logger();\nconst logger2 &#x3D; new Logger();\n\nlogger1.log(&#39;Message 1&#39;);\nlogger2.log(&#39;Message 2&#39;);\n\nlogger1.printLogs();\nlogger2.printLogs();\n\n在这个例子中，Logger 是一个日志记录器类，它使用单例模式来保证只创建一个日志记录器对象。在 Logger 的构造函数中，如果已经存在 Logger 的实例对象，那么就直接返回该实例对象，否则就创建一个新的实例对象。同时，也使用静态属性 Logger.instance 来存储日志记录器的唯一实例对象。客户端代码只需要创建日志记录器对象，并调用其 log 和 printLogs 方法来记录和输出日志，而不需要关心实例对象的创建和管理。\n静态方法实现单例模式以下是使用静态方法实现的 JavaScript 单例模式的代码示例，仍然用于创建唯一的日志记录器对象：\n&#x2F;&#x2F; 定义一个日志记录器类\nclass Logger &#123;\n  constructor() &#123;\n    this.logs &#x3D; [];\n  &#125;\n\n  log(message) &#123;\n    this.logs.push(message);\n    console.log(&#96;[INFO] $&#123;message&#125;&#96;);\n  &#125;\n\n  printLogs() &#123;\n    console.log(&#39;Logs:&#39;);\n    this.logs.forEach((log) &#x3D;&gt; console.log(log));\n  &#125;\n\n  static getInstance() &#123;\n    if (!Logger.instance) &#123;\n      Logger.instance &#x3D; new Logger();\n    &#125;\n\n    return Logger.instance;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用单例模式创建日志记录器对象\nconst logger1 &#x3D; Logger.getInstance();\nconst logger2 &#x3D; Logger.getInstance();\n\nlogger1.log(&#39;Message 1&#39;);\nlogger2.log(&#39;Message 2&#39;);\n\nlogger1.printLogs();\nlogger2.printLogs();\n\n在这个例子中，Logger 类中新增了一个静态方法 getInstance，用于获取日志记录器的唯一实例对象。在 getInstance 方法中，如果不存在 Logger 的实例对象，就创建一个新的实例对象并存储在静态属性 Logger.instance 中，否则就直接返回 Logger.instance。客户端代码只需要调用 Logger 的静态方法 getInstance 来获取日志记录器对象，并调用其 log 和 printLogs 方法来记录和输出日志，而不需要直接创建日志记录器对象或关心实例对象的管理。\n类的静态方法中，为什么可以直接 new 类在 JavaScript 中，类的静态方法中可以直接使用 new 关键字创建类的实例对象，因为静态方法和实例对象方法的作用域是不同的。静态方法属于类本身而不是类的实例对象，因此在静态方法中无法访问实例对象的属性和方法，同时也不能使用 this 关键字来引用实例对象。相反，静态方法可以访问类的静态属性和方法，而且可以通过 new 关键字来创建类的实例对象。\n在静态方法中使用 new 关键字创建类的实例对象时，实际上是在静态方法的作用域内创建了一个新的实例对象，并将其返回。这个新的实例对象与通过普通的实例化方式创建的实例对象是不同的，因为它没有被存储在类的实例属性中，也没有被绑定到类的原型链上。因此，在静态方法中使用 new 关键字创建实例对象时，需要将创建的实例对象返回给调用者，以便进行进一步的操作。\nES5 实现 class在 ES5 中，可以通过构造函数和原型对象的组合来实现类的功能，以下是一个简单的 ES5 实现类的代码示例：\n&#x2F;&#x2F; 定义一个 Person 类\nfunction Person(name, age) &#123;\n  &#x2F;&#x2F; 构造函数中定义实例属性\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 在原型对象中定义实例方法\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;, and I am $&#123;this.age&#125; years old.&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建 Person 的实例对象\nvar person &#x3D; new Person(&#39;Tom&#39;, 20);\n\n&#x2F;&#x2F; 调用实例方法\nperson.sayHello();\n\n在这个例子中，Person 是一个构造函数，它接受两个参数 name 和 age，并使用 this 关键字来定义实例属性。同时，在 Person 的原型对象中定义实例方法 sayHello，该方法可以通过 this 关键字访问实例属性。通过 new 关键字调用构造函数 Person 可以创建 Person 的实例对象 person，然后可以调用实例方法 sayHello 输出实例对象的属性值。\n需要注意的是，ES5 实现类时存在一些限制和问题，例如无法继承静态属性和方法、不能使用 super 关键字、原型链继承可能会出现问题等，因此在 ES6 中引入了 class 关键字来简化和统一类的定义和使用。\njs 原型模式原型模式示例示例以下是使用 JavaScript 原型模式创建对象的代码示例：\n&#x2F;&#x2F; 定义一个人类构造函数\nfunction Person(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 在原型对象中定义方法\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;, and I am $&#123;this.age&#125; years old.&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建 Person 的实例对象\nvar person1 &#x3D; new Person(&#39;Tom&#39;, 20);\nvar person2 &#x3D; new Person(&#39;Jerry&#39;, 25);\n\n&#x2F;&#x2F; 调用实例方法\nperson1.sayHello();\nperson2.sayHello();\n\n在这个例子中，我们使用构造函数 Person 定义了一个人类，构造函数中定义了实例属性 name 和 age，然后在 Person 的原型对象中定义了方法 sayHello，该方法可以通过 this 关键字访问实例属性。通过使用 new 关键字调用构造函数 Person 可以创建 Person 的实例对象 person1 和 person2，并分别调用实例方法 sayHello 来输出实例对象的属性值。\n使用原型模式创建对象的优点是可以避免在每个实例对象中重复定义方法，从而节省内存空间和提高代码的复用性。同时，修改原型对象中的方法会对所有的实例对象生效，使得程序更加简洁和易于维护。\nES6 实现原型模式ES6 中的类可以看作是一种基于原型的面向对象编程范式，因此实际上我们在使用 ES6 的类时，就是在使用原型模式。\n下面是一个使用 ES6 实现原型模式的代码示例：\n&#x2F;&#x2F; 定义一个 Animal 类\nclass Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n\n  &#x2F;&#x2F; 定义 Animal 的方法\n  eat() &#123;\n    console.log(&#96;$&#123;this.name&#125; is eating.&#96;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个 Cat 类，继承自 Animal 类\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n\n  &#x2F;&#x2F; 定义 Cat 的方法\n  meow() &#123;\n    console.log(&#96;$&#123;this.name&#125; is meowing.&#96;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建一个 Cat 实例\nconst cat &#x3D; new Cat(&#39;Tom&#39;);\n\n&#x2F;&#x2F; 调用 Cat 的方法\ncat.eat(); &#x2F;&#x2F; Tom is eating.\ncat.meow(); &#x2F;&#x2F; Tom is meowing.\n\n在这个例子中，我们定义了一个 Animal 类，它有一个属性 name 和一个方法 eat。然后我们又定义了一个 Cat 类，它继承自 Animal 类，并且还有一个方法 meow。最后我们创建了一个 Cat 实例 cat，并且调用了它的 eat 和 meow 方法。\n在使用 ES6 实现原型模式时，我们可以直接使用 class 和 extends 关键字来定义类和继承关系，而不必使用构造函数和原型链。此外，我们还可以使用 super 关键字来调用父类的构造函数和方法，从而更方便地实现面向对象编程。\njs 观察者模式示例原型方式示例以下是使用 JavaScript 观察者模式实现一个简单的例子：\n&#x2F;&#x2F; 定义一个主题对象\nfunction Subject() &#123;\n  &#x2F;&#x2F; 存储观察者列表\n  this.observers &#x3D; [];\n&#125;\n\n&#x2F;&#x2F; 定义添加观察者方法\nSubject.prototype.addObserver &#x3D; function (observer) &#123;\n  this.observers.push(observer);\n&#125;;\n\n&#x2F;&#x2F; 定义通知观察者方法\nSubject.prototype.notifyObservers &#x3D; function (data) &#123;\n  &#x2F;&#x2F; 遍历观察者列表，调用观察者的 update 方法\n  this.observers.forEach(function (observer) &#123;\n    observer.update(data);\n  &#125;);\n&#125;;\n\n&#x2F;&#x2F; 定义一个观察者对象\nfunction Observer(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\n&#x2F;&#x2F; 定义观察者的 update 方法\nObserver.prototype.update &#x3D; function (data) &#123;\n  console.log(&#96;$&#123;this.name&#125; received the data: $&#123;data&#125;&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建主题对象\nvar subject &#x3D; new Subject();\n\n&#x2F;&#x2F; 创建观察者对象\nvar observer1 &#x3D; new Observer(&#39;Observer 1&#39;);\nvar observer2 &#x3D; new Observer(&#39;Observer 2&#39;);\n\n&#x2F;&#x2F; 添加观察者到主题对象中\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\n&#x2F;&#x2F; 通知观察者\nsubject.notifyObservers(&#39;Hello World&#39;);\n\n在这个例子中，我们定义了一个主题对象 Subject 和一个观察者对象 Observer。Subject 对象包含了一个 observers 数组，用于存储所有注册的观察者。Subject 对象有一个 addObserver 方法，用于添加观察者到 observers 数组中；还有一个 notifyObservers 方法，用于遍历 observers 数组并调用每个观察者的 update 方法来通知观察者。\nObserver 对象包含一个名为 name 的属性，和一个 update 方法，当主题对象调用 notifyObservers 方法时，Observer 对象的 update 方法将被调用，输出接收到的数据。\n在例子的最后，我们创建了一个主题对象 subject，和两个观察者对象 observer1 和 observer2，将观察者添加到主题对象中，然后通过调用主题对象的 notifyObservers 方法来通知所有的观察者。在控制台输出的信息中可以看到，两个观察者都成功接收到了通知。\nES6 类方式示例使用 ES6 可以更简洁地实现观察者模式，以下是一个使用 ES6 实现的代码示例：\n&#x2F;&#x2F; 定义一个主题对象\nclass Subject &#123;\n  constructor() &#123;\n    &#x2F;&#x2F; 存储观察者列表\n    this.observers &#x3D; [];\n  &#125;\n\n  &#x2F;&#x2F; 添加观察者方法\n  addObserver(observer) &#123;\n    this.observers.push(observer);\n  &#125;\n\n  &#x2F;&#x2F; 通知观察者方法\n  notifyObservers(data) &#123;\n    &#x2F;&#x2F; 遍历观察者列表，调用观察者的 update 方法\n    this.observers.forEach((observer) &#x3D;&gt; observer.update(data));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个观察者对象\nclass Observer &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n\n  &#x2F;&#x2F; 定义观察者的 update 方法\n  update(data) &#123;\n    console.log(&#96;$&#123;this.name&#125; received the data: $&#123;data&#125;&#96;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建主题对象\nconst subject &#x3D; new Subject();\n\n&#x2F;&#x2F; 创建观察者对象\nconst observer1 &#x3D; new Observer(&#39;Observer 1&#39;);\nconst observer2 &#x3D; new Observer(&#39;Observer 2&#39;);\n\n&#x2F;&#x2F; 添加观察者到主题对象中\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\n&#x2F;&#x2F; 通知观察者\nsubject.notifyObservers(&#39;Hello World&#39;);\n\n在这个例子中，我们使用了 ES6 的 class 和箭头函数来实现观察者模式。与 ES5 中的代码相比，ES6 中使用 class 定义类的语法更加简洁明了，使用箭头函数也可以避免 this 关键字指向的问题。\n在例子的最后，我们创建了一个主题对象 subject，和两个观察者对象 observer1 和 observer2，将观察者添加到主题对象中，然后通过调用主题对象的 notifyObservers 方法来通知所有的观察者。在控制台输出的信息中可以看到，两个观察者都成功接收到了通知。\njs 订阅发布模式ES5 代码实现订阅发布模式又称为观察者模式，可以通过一种松散的耦合方式来构建对象间的一对多关系。在 ES5 中可以使用原型和构造函数来实现订阅发布模式。\n下面是一个使用 ES5 实现订阅发布模式的代码示例：\n&#x2F;&#x2F; 定义一个主题对象\nfunction Subject() &#123;\n  &#x2F;&#x2F; 存储观察者列表\n  this.observers &#x3D; [];\n&#125;\n\n&#x2F;&#x2F; 添加观察者方法\nSubject.prototype.addObserver &#x3D; function (observer) &#123;\n  this.observers.push(observer);\n&#125;;\n\n&#x2F;&#x2F; 通知观察者方法\nSubject.prototype.notifyObservers &#x3D; function (data) &#123;\n  &#x2F;&#x2F; 遍历观察者列表，调用观察者的 update 方法\n  this.observers.forEach(function (observer) &#123;\n    observer.update(data);\n  &#125;);\n&#125;;\n\n&#x2F;&#x2F; 定义一个观察者对象\nfunction Observer(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\n&#x2F;&#x2F; 定义观察者的 update 方法\nObserver.prototype.update &#x3D; function (data) &#123;\n  console.log(this.name + &#39; received the data: &#39; + data);\n&#125;;\n\n&#x2F;&#x2F; 创建主题对象\nvar subject &#x3D; new Subject();\n\n&#x2F;&#x2F; 创建观察者对象\nvar observer1 &#x3D; new Observer(&#39;Observer 1&#39;);\nvar observer2 &#x3D; new Observer(&#39;Observer 2&#39;);\n\n&#x2F;&#x2F; 添加观察者到主题对象中\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\n&#x2F;&#x2F; 通知观察者\nsubject.notifyObservers(&#39;Hello World&#39;);\n\n在这个例子中，我们定义了一个 Subject 对象，它有一个 observers 属性来存储观察者列表，并且有一个 addObserver 方法用来添加观察者，有一个 notifyObservers 方法用来通知所有的观察者。然后我们定义了一个 Observer 对象，它有一个 name 属性和一个 update 方法用来接收通知。最后我们创建了一个 Subject 实例 subject 和两个 Observer 实例 observer1 和 observer2，将观察者添加到主题对象中，并且通过调用主题对象的 notifyObservers 方法来通知所有的观察者。在控制台输出的信息中可以看到，两个观察者都成功接收到了通知。\n需要注意的是，在 ES5 中实现订阅发布模式时，我们需要手动维护观察者列表，并且要使用原型和构造函数来定义对象。与 ES6 中的代码相比，ES5 中的代码更为冗长，但是在一些特定的情况下，ES5 中的实现方式可能更加灵活和方便。\n观察者模式与订阅发布模式有何区别观察者模式和订阅发布模式都是用来构建对象间的一对多关系，它们之间的主要区别在于实现的方式和使用的场景。\n观察者模式的核心是一个被观察者对象和若干个观察者对象，当被观察者对象的状态发生变化时，所有的观察者对象都会接收到通知并且做出相应的响应。观察者模式通常使用事件来实现，被观察者对象会触发一个事件，观察者对象会监听这个事件并且在事件发生时做出响应。\n订阅发布模式的核心是一个事件中心对象和若干个订阅者对象，订阅者对象可以向事件中心对象订阅某个事件，并且在事件发生时做出响应。事件中心对象在事件发生时会向所有订阅者对象发送通知。订阅发布模式通常使用回调函数来实现，订阅者对象会向事件中心对象注册一个回调函数，并且在事件发生时事件中心对象会调用所有注册的回调函数。\n观察者模式和订阅发布模式在实现上有一些区别，但是它们都可以用来构建对象间的一对多关系。在使用时，\n\n观察者模式更适用于一些状态变化较为频繁的场景，\n订阅发布模式则更适用于一些事件驱动的场景。\n\nredux 是订阅发布模式还是观察者模式Redux 是一个状态管理库，它是基于订阅发布模式实现的。\n在 Redux 中，应用的状态被存储在一个称为”Store”的对象中，这个对象允许开发者通过”dispatch”方法来触发状态的变化。当状态发生变化时，Redux 会调用所有已经注册的回调函数，并且将新的状态传递给它们。这个过程类似于订阅发布模式中的事件中心向所有订阅者对象发送通知。\n因此，Redux 可以被看作是基于订阅发布模式实现的状态管理库，它将应用的状态和状态变化的处理逻辑进行了封装，并且提供了一些 API 来方便开发者使用。\njs 装饰者模式装饰者模式（Decorator Pattern）是一种结构型设计模式，它允许我们动态地向一个对象添加新的行为，而不需要使用子类来扩展对象的功能。\n具体表现为：在装饰者模式中，我们将对象包装在一个装饰器中，并且将新的行为添加到装饰器中，从而实现了动态地扩展对象的功能。\n装饰者模式的核心是装饰器类和被装饰对象，装饰器类包含了一个指向被装饰对象的引用，并且实现了与被装饰对象相同的接口。装饰器类可以动态地向被装饰对象添加新的行为，而不需要直接修改被装饰对象的代码。\n在 JavaScript 中，装饰者模式通常通过函数来实现。我们可以将被装饰对象作为参数传递给装饰器函数，装饰器函数会返回一个新的函数或对象，这个新的函数或对象包含了被装饰对象的所有行为，并且添加了新的行为。\n装饰者模式代码示例以下是一个使用装饰者模式实现日志功能的示例代码：\n&#x2F;&#x2F; 被装饰对象\nclass Foo &#123;\n  doSomething() &#123;\n    console.log(&#39;doing something&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器函数\nfunction withLogging(target) &#123;\n  const originalMethod &#x3D; target.doSomething;\n\n  target.doSomething &#x3D; function () &#123;\n    console.log(&#39;before doSomething&#39;);\n    originalMethod.call(this);\n    console.log(&#39;after doSomething&#39;);\n  &#125;;\n\n  return target;\n&#125;\n\n&#x2F;&#x2F; 使用装饰器扩展对象功能\nconst decoratedFoo &#x3D; withLogging(new Foo());\n\n&#x2F;&#x2F; 调用扩展后的对象方法\ndecoratedFoo.doSomething();\n\n在上面的示例中，我们定义了一个被装饰对象Foo和一个装饰器函数withLogging。withLogging函数接受一个target参数，这个参数是一个被装饰对象。在withLogging函数中，我们将target对象的doSomething方法保存到originalMethod变量中，并且将一个新的函数赋值给target.doSomething，这个新的函数在调用originalMethod之前和之后都会打印一些日志。最后，withLogging函数返回被装饰后的target对象。\n我们可以通过调用withLogging(new Foo())来获得一个新的对象decoratedFoo，这个对象包含了被装饰对象Foo的所有行为，并且添加了打印日志的新行为。最后，我们调用decoratedFoo.doSomething()来触发新的函数，这个函数会先打印一些日志，然后调用原始的doSomething方法，最后再打印一些日志。\njs 代理模式代理模式（Proxy Pattern）是一种结构型设计模式，它允许我们在不改变对象原始接口的情况下，为对象提供一个代理，用于控制对对象的访问。代理模式通常用于延迟对象的创建、远程访问、权限控制等场景。\n在代理模式中，我们定义一个代理对象，它与原始对象具有相同的接口，并且维护一个对原始对象的引用。代理对象可以接受对原始对象的请求，并且可以对请求进行处理，也可以将请求转发给原始对象进行处理。通过代理对象，我们可以对原始对象的访问进行控制，例如可以限制对某些方法的访问、记录日志、缓存结果等。\n代码示例在 JavaScript 中，代理模式通常使用 ES6 的 Proxy 对象来实现。Proxy 对象可以用来代理 JavaScript 中的任何对象，并且可以重载访问对象的属性和方法，从而实现对对象的控制和定制。以下是一个使用代理模式实现缓存功能的示例代码：\n&#x2F;&#x2F; 原始对象\nclass Calculator &#123;\n  constructor() &#123;\n    this.cache &#x3D; &#123;&#125;;\n  &#125;\n\n  add(x, y) &#123;\n    const key &#x3D; &#96;$&#123;x&#125;+$&#123;y&#125;&#96;;\n    if (key in this.cache) &#123;\n      console.log(&#39;cache hit&#39;);\n      return this.cache[key];\n    &#125; else &#123;\n      console.log(&#39;cache miss&#39;);\n      const result &#x3D; x + y;\n      this.cache[key] &#x3D; result;\n      return result;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 代理对象\nclass CachedCalculator &#123;\n  constructor() &#123;\n    this.calculator &#x3D; new Calculator();\n  &#125;\n\n  add(x, y) &#123;\n    return this.calculator.add(x, y);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用代理对象\nconst calculator &#x3D; new CachedCalculator();\nconsole.log(calculator.add(1, 2));\nconsole.log(calculator.add(1, 2));\n\n在上面的示例中，我们定义了一个原始对象Calculator和一个代理对象CachedCalculator。\n\nCalculator对象实现了一个简单的加法方法，并且使用一个缓存对象来缓存计算结果。\nCachedCalculator对象代理了Calculator对象，并且使用Calculator对象来实现自己的add方法。\n\n我们可以通过创建一个CachedCalculator对象来使用代理对象，例如可以使用calculator.add(1, 2)来计算 1+2 的结果。当第一次调用add方法时，Calculator对象会执行计算操作并将结果缓存到内存中，当第二次调用add方法时，代理对象会从缓存中获取计算结果，并且不会再次执行计算操作。\n代理模式可以用于许多场景，例如控制对对象的访问、实现远程调用、记录日志、实现延迟初始化等。通过使用代理对象，我们可以实现更加灵活和可控的对象访问方式。\nES6 proxy 实现代理模式ES6 中的Proxy对象是一种通用的代理对象，可以用来代理任何 JavaScript 对象，并且可以通过重载对象的属性和方法来实现对对象的控制和定制。以下是一个使用Proxy对象实现代理模式的示例代码：\n&#x2F;&#x2F; 原始对象\nclass Calculator &#123;\n  add(x, y) &#123;\n    return x + y;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 代理对象\nclass CachedCalculator &#123;\n  constructor() &#123;\n    this.cache &#x3D; &#123;&#125;;\n    this.calculator &#x3D; new Calculator();\n  &#125;\n\n  add(x, y) &#123;\n    const key &#x3D; &#96;$&#123;x&#125;+$&#123;y&#125;&#96;;\n    if (key in this.cache) &#123;\n      console.log(&#39;cache hit&#39;);\n      return this.cache[key];\n    &#125; else &#123;\n      console.log(&#39;cache miss&#39;);\n      const result &#x3D; this.calculator.add(x, y);\n      this.cache[key] &#x3D; result;\n      return result;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用代理对象\nconst calculator &#x3D; new CachedCalculator();\nconst proxy &#x3D; new Proxy(calculator, &#123;\n  get: function (target, name) &#123;\n    if (name in target) &#123;\n      return target[name];\n    &#125; else &#123;\n      throw new Error(&#96;Undefined property: $&#123;name&#125;&#96;);\n    &#125;\n  &#125;,\n&#125;);\n\nconsole.log(proxy.add(1, 2));\nconsole.log(proxy.add(1, 2));\nconsole.log(proxy.sub(1, 2));\n\n在上面的示例中，我们定义了一个原始对象Calculator和一个代理对象CachedCalculator。Calculator对象实现了一个简单的加法方法，而CachedCalculator对象代理了Calculator对象，并且实现了一个缓存功能。我们使用Proxy对象来创建一个代理对象proxy，并且通过get方法重载了代理对象的属性访问，当访问一个不存在的属性时，代理对象会抛出一个错误。\n我们可以通过调用代理对象的add方法来实现加法运算，并且该方法会被代理对象拦截并且实现缓存功能。当第一次调用add方法时，代理对象会执行计算操作并将结果缓存到内存中，当第二次调用add方法时，代理对象会从缓存中获取计算结果，并且不会再次执行计算操作。当调用sub方法时，由于该方法不存在于代理对象中，代理对象会抛出一个错误。\n通过使用Proxy对象，我们可以实现更加灵活和可控的对象访问方式，从而实现代理模式的功能。\n装饰器模式与代理模式的区别装饰器模式和代理模式在某些场景下可以实现相似的功能，但它们有不同的用途和目的。\n装饰器模式是一种结构型设计模式，它允许你在不修改对象自身的基础上，动态地添加行为或修改行为。它是为了给对象添加功能而设计的，即扩展一个类的功能，而不是改变它。通常情况下，装饰器模式用于处理对象的行为和责任分离问题，它使得在不影响到其他对象的情况下，能够动态地给一个对象添加新的功能。装饰器模式是一种基于对象组合的设计模式，它使用了对象的组合关系来达到其目的。\n代理模式也是一种结构型设计模式，它在不改变对象的情况下，为其他对象提供一种代理以控制对这个对象的访问。代理模式用于控制访问，而不是扩展对象的功能。代理模式通过在对象之间引入一个代理对象来间接访问对象，从而保证了对象的访问控制和权限管理。\n简而言之，装饰器模式用于添加对象的功能，而代理模式则用于控制对象的访问。\njs 建造者模式（有点像我最讨厌的 JAVA 样子）建造者模式是一种创建型设计模式，用于将复杂对象的构建过程和其表示相分离，以便可以使用相同的构建过程来创建不同的表示。\n在 JavaScript 中，建造者模式可以用于创建复杂的对象，例如包含多个属性和方法的组合对象。以下是一个使用建造者模式创建复杂对象的示例代码：\n代码示例class Car &#123;\n  constructor() &#123;\n    this.color &#x3D; null;\n    this.wheels &#x3D; null;\n    this.engine &#x3D; null;\n    this.seats &#x3D; null;\n  &#125;\n\n  setColor(color) &#123;\n    this.color &#x3D; color;\n    return this;\n  &#125;\n\n  setWheels(wheels) &#123;\n    this.wheels &#x3D; wheels;\n    return this;\n  &#125;\n\n  setEngine(engine) &#123;\n    this.engine &#x3D; engine;\n    return this;\n  &#125;\n\n  setSeats(seats) &#123;\n    this.seats &#x3D; seats;\n    return this;\n  &#125;\n\n  build() &#123;\n    return &#123;\n      color: this.color,\n      wheels: this.wheels,\n      engine: this.engine,\n      seats: this.seats,\n    &#125;;\n  &#125;\n&#125;\n\nconst carBuilder &#x3D; new Car();\nconst car &#x3D; carBuilder.setColor(&#39;blue&#39;).setWheels(4).setEngine(&#39;V8&#39;).setSeats(5).build();\n\nconsole.log(car);\n\n在上面的示例中，我们定义了一个Car类，该类包含了多个属性和方法来创建一个复杂的汽车对象。其中，setColor、setWheels、setEngine和setSeats方法用于设置汽车对象的不同属性，而build方法用于返回最终创建的汽车对象。我们使用建造者模式来创建一个Car对象，首先创建一个Car对象实例，然后使用链式调用来设置汽车的属性，最后调用build方法来返回最终创建的汽车对象。\n使用建造者模式可以将复杂对象的构建过程与其表示相分离，从而实现更加灵活和可扩展的对象创建方式。建造者模式还可以简化代码，提高代码的可读性和可维护性。\n其他场景Nestjs 中的建造者除此之外，在 fultter、java 中也很常见\n如何理解“将复杂对象的构建过程与其表示相分离”“将复杂对象的构建过程与其表示相分离”是建造者模式的核心思想之一。\n它的意思是将对象的构建过程和最终对象的表示分离开来，也就是说，将对象的构建过程交给一个专门的”建造者”来负责，而最终的表示由客户端决定。\n具体来说，\n\n“构建过程”包括对象属性的初始化、赋值、检验等操作，以及对象方法的调用等操作；\n而”表示”指的是最终的对象形态，包括属性的值和对象方法的实现等。\n\n在建造者模式中，通过将对象的构建过程和最终的表示分离，可以使得对象的创建更加灵活和可扩展。因为可以在不改变对象表示的前提下，通过改变构建过程来创建不同的对象。\n举个例子，假设有一个复杂的汽车对象，它包括多个属性（比如颜色、型号、座位数等）和多个方法（比如加速、刹车、转弯等）。如果不使用建造者模式，那么我们可能需要在客户端中直接构建这个复杂的对象，这样就会让客户端代码变得非常复杂和难以维护。而使用建造者模式，我们可以将构建过程交给专门的”建造者”来负责，客户端只需要调用建造者提供的方法来设置属性和方法即可，这样就能够使得客户端代码更加简洁和易于维护。同时，由于建造者可以自由地改变构建过程，因此可以轻松地创建不同的汽车对象，比如不同颜色、不同型号、不同座位数等等。\n建造者模式 怎么看上去像是 JAVA 的 set 方法和 get 方法呢建造者模式中的属性设置方法更加专注于对象的构建过程，而 Java 中的 get 和 set 方法通常只是简单地用于获取和设置属性的值。虽然它们有一些相似之处，但建造者模式的属性设置方法还提供了一些额外的特性，比如链式调用。\n\n详细内容\n你提到的 Java 中的 set 和 get 方法，确实有一些类似建造者模式中的属性设置方法。\n在 Java 中，通常将属性设置为私有的，然后通过 public 的 get 和 set 方法来设置和获取属性的值。这种方式可以保证属性的访问控制和封装性，并且可以在设置属性值时进行一些额外的检验和逻辑处理。\n而在建造者模式中，也是通过一些方法来设置属性值，但它们通常都是专门为对象的构建而设计的，而不仅仅是为了简单地设置属性。\n不过，建造者模式和 Java 中的 get 和 set 方法还是有一些不同之处的。\n建造者模式\n\n通常将构建过程抽象出来，用一个专门的类来负责构建对象，并提供一些方法来设置属性和方法。这些方法通常都是和对象的构建过程相关的，而不仅仅是为了设置属性。此外，\n建造者模式还可以通过链式调用来设置属性，这样可以让代码更加简洁和易于使用。\n\n而在 Java 中，get 和 set 方法通常只是简单的用于获取和设置属性的值，并且不具备链式调用的特点。\n因此，虽然 Java 中的 get 和 set 方法有一些类似建造者模式中的属性设置方法，但它们还是存在一些区别的。建造者模式的属性设置方法更加专注于对象的构建过程，并且提供了一些额外的特性，比如链式调用。\n\n\njs 适配器模式在 JavaScript 中，适配器模式可以用来将一个不兼容的接口转换成另一个接口，以便我们可以在不修改原始代码的情况下重用已有的代码。\n适配器模式通常包含三个角色：客户端、适配器和适配者。其中，客户端使用适配器来调用适配者提供的方法。适配器则负责将适配者的方法转换成客户端期望的接口形式。\n适配器代码示例下面是一个简单的 JavaScript 适配器模式的示例：\n&#x2F;&#x2F; 定义适配者\nclass Adaptee &#123;\n  specificRequest() &#123;\n    return &#39;适配者中的业务代码被调用&#39;;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义适配器\nclass Adapter &#123;\n  constructor() &#123;\n    this.adaptee &#x3D; new Adaptee();\n  &#125;\n\n  request() &#123;\n    let result &#x3D; this.adaptee.specificRequest();\n    result &#x3D; &#96;适配器：$&#123;result&#125;，已经被适配成客户端所需要的接口形式&#96;;\n    return result;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义客户端\nclass Client &#123;\n  constructor(adapter) &#123;\n    this.adapter &#x3D; adapter;\n  &#125;\n\n  execute() &#123;\n    console.log(this.adapter.request());\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 测试代码\nconst adapter &#x3D; new Adapter();\nconst client &#x3D; new Client(adapter);\nclient.execute();\n\n在上面的示例中，我们定义了一个适配者 Adaptee，它提供了一个不兼容的接口 specificRequest。然后我们定义了一个适配器 Adapter，它包含一个适配者的实例，并将其转换成客户端需要的接口形式。最后，我们定义了一个客户端 Client，它使用适配器来调用适配者的方法。\n当我们执行测试代码时，会输出一段字符串，其中包含了适配者的业务代码和适配器转换后的接口形式。这说明适配器模式已经成功地将不兼容的接口转换成了客户端需要的接口形式。\n适配器使用场景适配器模式可以将不兼容的接口转换成我们需要的接口形式，使得我们可以重用已有的代码，并提高代码的可重用性和灵活性。它通常应用于需要集成已有的代码库或第三方库，或者需要使用不兼容接口的情况。\n\nDetails\n适配器模式通常在以下两种场景中使用：\n\n在使用一些已有的代码库或第三方库时，这些库的接口可能与我们当前的代码不兼容。这时可以使用适配器模式，将这些不兼容的接口转换成我们需要的接口形式，以便我们可以在不修改原始代码的情况下重用已有的代码。\n\n当我们需要使用一些已有的类，但它们的接口不符合我们的需求时，也可以使用适配器模式。我们可以定义一个适配器类，实现我们所需要的接口，并在适配器类中包含一个已有的类的实例。这样，我们就可以通过适配器来调用已有的类的方法，并将它们转换成我们需要的接口形式。\n\n\n具体来说，适配器模式在以下情况中可能会特别有用：\n\n当我们需要将一个已有的代码库或第三方库集成到我们的应用程序中，并且它们的接口与我们的应用程序不兼容时。\n\n当我们需要使用一些已有的类或对象，并且它们的接口不符合我们的需求时。\n\n当我们需要将一些不同的接口统一成一个共同的接口时，可以使用适配器模式来将这些不同的接口转换成我们需要的接口形式。\n\n\n总之，适配器模式可以帮助我们在不修改原始代码的情况下重用已有的代码，并将不兼容的接口转换成我们需要的接口形式，从而提高代码的可重用性和灵活性。\n\n\njs 过滤器模式【缓存】过滤器模式（Filter Pattern）是一种结构型设计模式，它可以通过定义一系列过滤器来筛选出符合条件的数据。在 JavaScript 中，过滤器模式通常应用于处理大量数据时的数据筛选和过滤。\n过滤器模式通常包含以下角色：\n\nFilter：定义一个过滤器接口，提供一个过滤方法，用于对数据进行筛选和过滤。\n\nConcreteFilter：实现具体的过滤器，对数据进行具体的筛选和过滤。\n\nFilterChain：定义一个过滤器链，将多个过滤器组合成一个过滤器链，并提供一个过滤方法，用于对数据进行链式过滤。\n\nClient：使用过滤器模式的客户端，在客户端中创建一个过滤器链，并使用过滤器链对数据进行筛选和过滤。\n\n\n代码示例以下是一个 JavaScript 过滤器模式的示例：\n&#x2F;&#x2F; 定义一个过滤器接口\nclass Filter &#123;\n  filter(data) &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; 实现具体的过滤器\nclass AgeFilter extends Filter &#123;\n  constructor(minAge, maxAge) &#123;\n    super();\n    this.minAge &#x3D; minAge;\n    this.maxAge &#x3D; maxAge;\n  &#125;\n  filter(data) &#123;\n    return data.filter((item) &#x3D;&gt; item.age &gt;&#x3D; this.minAge &amp;&amp; item.age &lt;&#x3D; this.maxAge);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 定义一个过滤器链\nclass FilterChain &#123;\n  constructor() &#123;\n    this.filters &#x3D; [];\n  &#125;\n  addFilter(filter) &#123;\n    this.filters.push(filter);\n  &#125;\n  filter(data) &#123;\n    return this.filters.reduce((result, filter) &#x3D;&gt; filter.filter(result), data);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用过滤器模式的客户端\nconst data &#x3D; [\n  &#123; name: &#39;Tom&#39;, age: 20 &#125;,\n  &#123; name: &#39;Jack&#39;, age: 30 &#125;,\n  &#123; name: &#39;Mike&#39;, age: 25 &#125;,\n  &#123; name: &#39;Lucy&#39;, age: 18 &#125;,\n  &#123; name: &#39;Jane&#39;, age: 35 &#125;,\n];\n\nconst ageFilter &#x3D; new AgeFilter(20, 30);\nconst filterChain &#x3D; new FilterChain();\nfilterChain.addFilter(ageFilter);\n\nconst result &#x3D; filterChain.filter(data);\nconsole.log(result);\n&#x2F;&#x2F; Output: [&#123; name: &#39;Tom&#39;, age: 20 &#125;, &#123; name: &#39;Mike&#39;, age: 25 &#125;]\n\n在这个例子中，\n\n我们首先定义了一个过滤器接口 Filter，\n然后实现了一个具体的过滤器 AgeFilter，用于筛选出年龄在[minAge, maxAge]范围内的数据。\n接下来，我们定义了一个过滤器链 FilterChain，它可以将多个过滤器组合成一个过滤器链，并提供一个过滤方法，用于对数据进行链式过滤。\n最后，我们使用客户端创建了一个过滤器链，并使用过滤器链对数据进行筛选和过滤，得到了符合条件的数据。\n\n使用场景过滤器模式通常用于从一个大的数据集合中选择符合特定条件的数据，或者将数据按照一定的规则进行分类或聚合。它可以帮助我们将数据处理逻辑与业务逻辑分离，提高代码的可复用性和可维护性。常见的应用场景包括数据筛选、分页、聚合等，同时也可以用于实现缓存或者数据预处理等。\n过滤器实现缓存的示例以下是一个使用过滤器模式实现缓存的简单示例：\n&#x2F;&#x2F; 定义一个数据过滤器类\nclass Filter &#123;\n  constructor(data, rules) &#123;\n    this.data &#x3D; data;\n    this.rules &#x3D; rules;\n  &#125;\n\n  filterData() &#123;\n    &#x2F;&#x2F; 检查缓存是否命中\n    const cacheKey &#x3D; JSON.stringify(this.rules);\n    if (Filter.cache[cacheKey]) &#123;\n      console.log(&#39;从缓存中读取数据&#39;);\n      return Filter.cache[cacheKey];\n    &#125;\n\n    &#x2F;&#x2F; 进行数据筛选\n    let result &#x3D; this.data.filter((item) &#x3D;&gt; &#123;\n      for (let rule of this.rules) &#123;\n        if (!rule(item)) &#123;\n          return false;\n        &#125;\n      &#125;\n      return true;\n    &#125;);\n\n    &#x2F;&#x2F; 将结果缓存起来\n    Filter.cache[cacheKey] &#x3D; result;\n    console.log(&#39;数据已缓存&#39;);\n    return result;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 静态属性用于存储缓存数据\nFilter.cache &#x3D; &#123;&#125;;\n\n&#x2F;&#x2F; 示例代码\nconst data &#x3D; [\n  &#123; name: &#39;Alice&#39;, age: 20, gender: &#39;F&#39; &#125;,\n  &#123; name: &#39;Bob&#39;, age: 30, gender: &#39;M&#39; &#125;,\n  &#123; name: &#39;Charlie&#39;, age: 25, gender: &#39;M&#39; &#125;,\n  &#123; name: &#39;David&#39;, age: 28, gender: &#39;M&#39; &#125;,\n  &#123; name: &#39;Eve&#39;, age: 22, gender: &#39;F&#39; &#125;,\n];\n\nconst filter &#x3D; new Filter(data, [(item) &#x3D;&gt; item.age &gt;&#x3D; 25, (item) &#x3D;&gt; item.gender &#x3D;&#x3D;&#x3D; &#39;M&#39;]);\n\nconsole.log(filter.filterData());\nconsole.log(filter.filterData());\n\n在上述示例中，我们定义了一个 Filter 类来实现数据过滤的功能。其中，构造函数接收一个数据集合和一组筛选规则，并将它们保存在实例属性中。filterData 方法则负责进行数据筛选，并且在命中缓存的情况下直接从缓存中读取结果，否则就进行数据筛选并将结果缓存起来。通过这种方式，我们可以避免对相同的数据集合和筛选规则进行重复的计算和查询，提高代码的执行效率。\n过滤器聚合场景示例过滤器模式可以和聚合模式结合使用，用于对聚合对象进行筛选或过滤，只返回符合条件的子集合。\n以下是一个使用 JavaScript 实现过滤器和聚合模式结合的示例：\nclass Product &#123;\n  constructor(name, price) &#123;\n    this.name &#x3D; name;\n    this.price &#x3D; price;\n  &#125;\n&#125;\n\nclass Cart &#123;\n  constructor() &#123;\n    this.products &#x3D; [];\n  &#125;\n\n  addProduct(product) &#123;\n    this.products.push(product);\n  &#125;\n\n  filterProducts(filter) &#123;\n    return this.products.filter(filter);\n  &#125;\n\n  getTotalPrice() &#123;\n    return this.products.reduce((total, product) &#x3D;&gt; total + product.price, 0);\n  &#125;\n&#125;\n\nclass Order &#123;\n  constructor(customer) &#123;\n    this.customer &#x3D; customer;\n    this.cart &#x3D; new Cart(); &#x2F;&#x2F; 对象内部有products\n  &#125;\n\n  addProductToCart(product) &#123;\n    &#x2F;&#x2F; 将商品加入购物车的products中\n    this.cart.addProduct(product);\n  &#125;\n\n  filterProducts(filter) &#123;\n    &#x2F;&#x2F; 购物车的过滤方法\n    return this.cart.filterProducts(filter);\n  &#125;\n\n  getTotalPrice() &#123;\n    &#x2F;&#x2F; 购物车总价\n    return this.cart.getTotalPrice();\n  &#125;\n&#125;\n\nconst customer &#x3D; &#39;John&#39;;\nconst order &#x3D; new Order(customer);\n\nconst product1 &#x3D; new Product(&#39;Laptop&#39;, 1000);\norder.addProductToCart(product1);\n\nconst product2 &#x3D; new Product(&#39;Phone&#39;, 500);\norder.addProductToCart(product2);\n\nconst expensiveFilter &#x3D; (product) &#x3D;&gt; product.price &gt; 600;\n&#x2F;&#x2F; 订单中大于N的商品，内部调用的是购物车的方法\nconst expensiveProducts &#x3D; order.filterProducts(expensiveFilter);\n\nconsole.log(&#96;Expensive products for $&#123;customer&#125;:&#96;);\nexpensiveProducts.forEach((product) &#x3D;&gt; &#123;\n  console.log(&#96;$&#123;product.name&#125; ($&#123;product.price&#125;)&#96;);\n&#125;);\n\nconsole.log(&#96;Total price for $&#123;customer&#125; is $&#123;order.getTotalPrice()&#125;&#96;);\n\n在这个示例中，\n\n我们新增了 filterProducts 方法，用于过滤购物车中的产品。\n在 Order 类中也新增了 filterProducts 方法，用于从购物车中获取符合条件的产品子集。\n主程序中，我们定义了一个只选取价格超过 600 的产品过滤器，并获取了符合条件的产品。\n最后，输出了选中产品的名称和价格，以及订单总价。\n\n这个设计有点麻烦啊：看上去 Order 没什么太大的用的样子，可又不得不存在的样子\njs 桥接模式桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与实现部分分离开来，以便它们可以独立地变化。\n在桥接模式中，有两个独立的类层次结构，一个是抽象部分，另一个是实现部分。抽象部分包含高层次的业务逻辑，而实现部分负责具体的实现。\n桥接模式的核心思想是抽象部分与实现部分分离，通过将抽象部分与实现部分解耦，可以灵活地组合它们，从而达到扩展和复用的目的。\n代码示例下面是一个简单的 JavaScript 桥接模式的示例，假设有一个形状类 Shape 和一个颜色类 Color，我们可以使用桥接模式将它们分离，实现一个可以随意组合形状和颜色的对象。代码如下：\nclass Shape &#123;\n  constructor(color) &#123;\n    this.color &#x3D; color;\n  &#125;\n  draw() &#123;\n    console.log(&#96;Drawing $&#123;this.color&#125; $&#123;this.name&#125;&#96;);\n  &#125;\n&#125;\n\nclass Circle extends Shape &#123;\n  constructor(color) &#123;\n    super(color);\n    this.name &#x3D; &#39;Circle&#39;;\n  &#125;\n&#125;\n\nclass Square extends Shape &#123;\n  constructor(color) &#123;\n    super(color);\n    this.name &#x3D; &#39;Square&#39;;\n  &#125;\n&#125;\n\nclass Color &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nclass Red extends Color &#123;\n  constructor() &#123;\n    super(&#39;Red&#39;);\n  &#125;\n&#125;\n\nclass Blue extends Color &#123;\n  constructor() &#123;\n    super(&#39;Blue&#39;);\n  &#125;\n&#125;\n\nclass ShapeWithColor &#123;\n  constructor(shape, color) &#123;\n    this.shape &#x3D; shape;\n    this.color &#x3D; color;\n  &#125;\n  draw() &#123;\n    console.log(&#96;Drawing $&#123;this.color.name&#125; $&#123;this.shape.name&#125;&#96;);\n  &#125;\n&#125;\n\nconst redCircle &#x3D; new ShapeWithColor(new Circle(), new Red());\nredCircle.draw(); &#x2F;&#x2F; Drawing Red Circle\n\nconst blueSquare &#x3D; new ShapeWithColor(new Square(), new Blue());\nblueSquare.draw(); &#x2F;&#x2F; Drawing Blue Square\n\n在上面的示例中，我们将 Shape 和 Color 类分别作为抽象部分和实现部分，然后使用 ShapeWithColor 类将它们组合起来，从而实现了可以随意组合形状和颜色的对象。\n简化后桥接模式（Bridge Pattern）是一种结构型设计模式，它可以将一个大类或者一系列紧密相关的类拆分成抽象和实现两个独立的层次，从而能在开发过程中分别使用它们。\n桥接模式主要用于分离抽象与实现，以便两者可以独立地变化。它通过使用聚合关系（而不是继承关系）将两个独立变化的维度分离出来，使它们可以独立地扩展，提高了系统的灵活性和可维护性。\n在桥接模式中，抽象部分定义了一个接口，它包含一个指向实现部分的引用。抽象部分中的方法将调用实现部分的方法，从而完成具体的业务逻辑。\n常见的桥接模式应用场景包括图形用户界面设计中的窗口管理器，以及多媒体应用程序中的播放器控制器等。\n没理解桥接模式的目的是分离抽象和实现，通过这种方式可以使它们各自独立变化，从而提高系统的灵活性和可维护性。\n举个例子，我们可以把一个程序分为抽象部分和实现部分，其中抽象部分定义了一个接口，并包含一个指向实现部分的引用。抽象部分中的方法将调用实现部分的方法，从而完成具体的业务逻辑。这样，当我们需要扩展系统时，只需要修改实现部分而不用修改抽象部分，从而减少了对系统的影响范围。\n在实际应用中，桥接模式经常用于图形用户界面设计中的窗口管理器和多媒体应用程序中的播放器控制器等。例如，在窗口管理器中，我们可以将窗口的抽象部分定义为一个接口，包含打开、关闭、最小化等方法，然后通过实现部分来实现这些方法。在实现部分中，我们可以使用不同的技术来实现这些方法，比如使用 Win32 API、Qt 或者 Java Swing 等不同的 GUI 工具包。\n总之，桥接模式可以帮助我们将一个复杂的系统分解成简单的部分，从而降低系统的复杂性和耦合度，提高系统的可维护性和可扩展性。\n桥接模式和组合模式的区别桥接模式是为了解决抽象和实现之间的耦合问题，而组合模式是为了表示部分-整体的层次结构。\njs 享元模式【缓存】享元模式（Flyweight Pattern）是一种结构型设计模式，它主要是用来优化性能和内存占用。它通过共享对象的方式来减少内存中对象的数量，从而提高程序的性能和效率。\n该模式的核心思想是将一个类中的一些属性和方法拆分成多个可复用的对象，这些可复用的对象可以被多个不同的对象所共享使用，从而减少内存中的重复对象的数量。\n在 JavaScript 中，享元模式的一个常见应用场景是通过共享对象来优化性能，例如在 DOM 操作中使用对象池，或者在游戏开发中使用纹理缓存等。\n好的，以下是一个简单的示例：\n假设有一个网站需要展示多张图片，并且每张图片都有相同的一些属性，例如宽度、高度和类型等。我们可以使用享元模式来避免创建大量相同的图片对象。\n首先，我们定义一个 Image 类，它包含宽度、高度和类型等属性：\nclass Image &#123;\n  constructor(width, height, type) &#123;\n    this.width &#x3D; width;\n    this.height &#x3D; height;\n    this.type &#x3D; type;\n  &#125;\n  display(x, y) &#123;\n    console.log(&#96;Displaying $&#123;this.type&#125; image ($&#123;this.width&#125; x $&#123;this.height&#125;) at ($&#123;x&#125;, $&#123;y&#125;)&#96;);\n  &#125;\n&#125;\n\n接下来，我们定义一个 ImageFactory 工厂类，它可以创建并管理图片对象。这个工厂类包含一个 images 对象，用于缓存已创建的图片对象。如果请求创建的图片已存在，则直接返回缓存中的图片对象，否则创建一个新的图片对象并加入缓存：\nclass ImageFactory &#123;\n  constructor() &#123;\n    this.images &#x3D; &#123;&#125;;\n  &#125;\n  getImage(width, height, type) &#123;\n    const key &#x3D; &#96;$&#123;width&#125;x$&#123;height&#125;_$&#123;type&#125;&#96;;\n    if (!this.images[key]) &#123;\n      this.images[key] &#x3D; new Image(width, height, type);\n    &#125;\n    return this.images[key];\n  &#125;\n&#125;\n\n最后，我们可以使用 ImageFactory 工厂类来创建并展示多张图片。由于相同属性的图片对象被缓存起来了，因此我们只需要创建一次即可，可以大大减少创建对象的数量：\nconst factory &#x3D; new ImageFactory();\nconst image1 &#x3D; factory.getImage(100, 100, &#39;png&#39;);\nimage1.display(0, 0);\n\nconst image2 &#x3D; factory.getImage(100, 100, &#39;png&#39;);\nimage2.display(100, 0);\n\nconst image3 &#x3D; factory.getImage(200, 200, &#39;jpg&#39;);\nimage3.display(0, 100);\n\nconst image4 &#x3D; factory.getImage(200, 200, &#39;jpg&#39;);\nimage4.display(200, 100);\n\n输出结果为：\nDisplaying png image (100 x 100) at (0, 0)\nDisplaying png image (100 x 100) at (100, 0)\nDisplaying jpg image (200 x 200) at (0, 100)\nDisplaying jpg image (200 x 200) at (200, 100)\n\n可以看到，虽然我们创建了 4 张图片，但实际上只有 2 个不同的图片对象被创建并缓存，可以减少内存的使用。\njs 外观模式JavaScript 外观模式（Facade Pattern）是一种结构型设计模式，用于为复杂系统提供简化的界面。它通过隐藏系统的复杂性，并提供一个易于使用的接口，使得客户端更容易使用系统。\n在外观模式中，我们定义一个简单的接口，该接口隐藏了复杂的系统，并将其暴露给客户端。这使得客户端可以使用一个简单的接口来与系统交互，而不需要了解系统内部的复杂性。\n代码示例 1以下是一个简单的 JavaScript 外观模式的示例，它封装了一个音频播放器的复杂性，为客户端提供了一个简单的接口来控制音频播放。\nclass AudioPlayer &#123;\n  constructor() &#123;\n    this.audio &#x3D; new Audio();\n  &#125;\n\n  play() &#123;\n    this.audio.play();\n  &#125;\n\n  pause() &#123;\n    this.audio.pause();\n  &#125;\n\n  setVolume(volume) &#123;\n    this.audio.volume &#x3D; volume;\n  &#125;\n\n  setSource(source) &#123;\n    this.audio.src &#x3D; source;\n  &#125;\n&#125;\n\nclass AudioPlayerFacade &#123;\n  constructor() &#123;\n    this.audioPlayer &#x3D; new AudioPlayer();\n  &#125;\n\n  play(source, volume) &#123;\n    this.audioPlayer.setSource(source);\n    this.audioPlayer.setVolume(volume);\n    this.audioPlayer.play();\n  &#125;\n\n  pause() &#123;\n    this.audioPlayer.pause();\n  &#125;\n\n  stop() &#123;\n    this.audioPlayer.pause();\n    this.audioPlayer.setSource(&#39;&#39;);\n  &#125;\n\n  setVolume(volume) &#123;\n    this.audioPlayer.setVolume(volume);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nconst audioPlayerFacade &#x3D; new AudioPlayerFacade();\naudioPlayerFacade.play(&#39;audio.mp3&#39;, 0.5);\n\n在上面的示例中，我们创建了一个 AudioPlayer 类，它封装了 HTML5 audio 元素的复杂性，提供了 play、pause、setVolume 和 setSource 等方法。\n然后我们创建了一个 AudioPlayerFacade 类，它使用 AudioPlayer 类的实例作为其内部对象，并提供了一个简单的接口来控制音频播放。AudioPlayerFacade 类的 play 方法调用 AudioPlayer 类的 setSource 和 setVolume 方法，并调用 play 方法来开始播放音频。\n最后，我们创建了一个 AudioPlayerFacade 的实例，并调用其 play 方法，这个方法接受音频源和音量作为参数，然后开始播放音频。由于 AudioPlayerFacade 封装了 AudioPlayer 类的复杂性，因此客户端不需要了解内部的实现细节，只需要调用 play 方法并传递参数即可。\n代码示例 2下面是一个简单的外观模式示例：\n假设我们有一个计算器对象，可以进行加减乘除等运算，但是每种运算都需要调用不同的方法，代码可能会比较复杂。这时我们可以使用外观模式，创建一个外观对象，封装这些方法，使得客户端可以简单地使用这些方法进行计算。\n&#x2F;&#x2F; 计算器对象\nconst Calculator &#x3D; &#123;\n  add: function (num1, num2) &#123;\n    return num1 + num2;\n  &#125;,\n  subtract: function (num1, num2) &#123;\n    return num1 - num2;\n  &#125;,\n  multiply: function (num1, num2) &#123;\n    return num1 * num2;\n  &#125;,\n  divide: function (num1, num2) &#123;\n    return num1 &#x2F; num2;\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 外观对象，封装计算器对象的方法\nconst CalculatorFacade &#x3D; &#123;\n  add: function (num1, num2) &#123;\n    return Calculator.add(num1, num2);\n  &#125;,\n  subtract: function (num1, num2) &#123;\n    return Calculator.subtract(num1, num2);\n  &#125;,\n  multiply: function (num1, num2) &#123;\n    return Calculator.multiply(num1, num2);\n  &#125;,\n  divide: function (num1, num2) &#123;\n    return Calculator.divide(num1, num2);\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 客户端代码，可以直接使用外观对象提供的简单方法进行计算\nconsole.log(CalculatorFacade.add(2, 3)); &#x2F;&#x2F; 输出 5\nconsole.log(CalculatorFacade.multiply(2, 3)); &#x2F;&#x2F; 输出 6\n\n在上面的例子中，Calculator对象是具体的计算器实现，包含了加减乘除等方法。CalculatorFacade对象是外观对象，封装了Calculator对象的方法，客户端代码可以直接使用外观对象提供的简单方法进行计算。\n这样，客户端代码就不需要直接与具体的计算器实现打交道，而是通过外观对象来简单地使用计算器功能。这就是外观模式的作用。\nES6 export 也是外观模式？在 ES6 中，export 并不是外观模式。export 用于将模块内的内容导出，使得其他模块可以引用这些内容。它并没有对模块内的实现进行封装，也没有提供简化接口的功能。\n而外观模式的主要作用是对复杂的子系统进行封装，提供简单的接口给客户端使用，隐藏子系统的复杂性和实现细节，让客户端更加方便地使用子系统。\n策略模式策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，将它们封装起来，并且使它们可以相互替换。策略模式让算法的变化独立于使用它们的客户端。\n在策略模式中，一般会有一个 Context（上下文）类，它包含一个 Strategy（策略）接口的引用，这个引用指向具体的算法实现类。客户端可以通过 Context 来使用这些算法，而不需要直接与算法实现类进行交互。\n策略模式示例 1下面是一个 JavaScript 的策略模式示例：\n&#x2F;&#x2F; 策略接口\nclass Strategy &#123;\n  doOperation(num1, num2) &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; 具体策略类\nclass OperationAdd extends Strategy &#123;\n  doOperation(num1, num2) &#123;\n    return num1 + num2;\n  &#125;\n&#125;\n\nclass OperationSubtract extends Strategy &#123;\n  doOperation(num1, num2) &#123;\n    return num1 - num2;\n  &#125;\n&#125;\n\nclass OperationMultiply extends Strategy &#123;\n  doOperation(num1, num2) &#123;\n    return num1 * num2;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 上下文类\nclass Context &#123;\n  constructor(strategy) &#123;\n    this.strategy &#x3D; strategy;\n  &#125;\n\n  executeStrategy(num1, num2) &#123;\n    return this.strategy.doOperation(num1, num2);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用\nconst contextAdd &#x3D; new Context(new OperationAdd());\nconsole.log(contextAdd.executeStrategy(1, 2)); &#x2F;&#x2F; 输出 3\n\nconst contextSubtract &#x3D; new Context(new OperationSubtract());\nconsole.log(contextSubtract.executeStrategy(1, 2)); &#x2F;&#x2F; 输出 -1\n\nconst contextMultiply &#x3D; new Context(new OperationMultiply());\nconsole.log(contextMultiply.executeStrategy(2, 3)); &#x2F;&#x2F; 输出 6\n\n在上面的示例中，Strategy是策略接口，定义了一个doOperation方法。具体的算法实现类（如OperationAdd）继承自Strategy并实现了doOperation方法。Context是上下文类，它包含一个对Strategy接口的引用，这个引用可以指向任何实现了Strategy接口的具体类。Context类中有一个executeStrategy方法，它调用了Strategy接口的方法，实现了不同算法之间的相互替换。\n策略模式和桥接模式的区别虽然策略模式和桥接模式都涉及到对象的组合和分离，但它们的主要区别在于解决的问题不同。\n桥接模式主要用于解决多维度变化的情况，例如一个类的多个维度（例如颜色、大小、形状等）都可能变化，这些维度之间可以互相组合，而桥接模式可以将这些维度分离出来，使得它们可以独立变化，而不影响其他维度。\n策略模式主要用于解决算法的多样性问题，例如需要根据不同的场景或条件选择不同的算法来实现相同的功能，策略模式可以将算法封装成不同的策略类，通过切换不同的策略类来改变算法的行为。\n因此，虽然策略模式和桥接模式都涉及到组合和分离，但它们的目的和解决的问题不同。\n策略模式例子 2一个简单的策略模式的例子是实现一个排序函数，可以根据不同的排序算法进行排序。\n首先，我们定义一个 Sort 类，该类将包含一组排序算法的策略：\nclass Sort &#123;\n  constructor(strategy) &#123;\n    this.strategy &#x3D; strategy;\n  &#125;\n\n  setStrategy(strategy) &#123;\n    this.strategy &#x3D; strategy;\n  &#125;\n\n  sort(data) &#123;\n    return this.strategy.sort(data);\n  &#125;\n&#125;\n\n然后，我们可以定义一组排序策略，比如插入排序、冒泡排序和快速排序：\nclass InsertionSort &#123;\n  sort(data) &#123;\n    console.log(&#39;Sorting using insertion sort&#39;);\n    &#x2F;&#x2F; 插入排序实现代码\n    return data;\n  &#125;\n&#125;\n\nclass BubbleSort &#123;\n  sort(data) &#123;\n    console.log(&#39;Sorting using bubble sort&#39;);\n    &#x2F;&#x2F; 冒泡排序实现代码\n    return data;\n  &#125;\n&#125;\n\nclass QuickSort &#123;\n  sort(data) &#123;\n    console.log(&#39;Sorting using quick sort&#39;);\n    &#x2F;&#x2F; 快速排序实现代码\n    return data;\n  &#125;\n&#125;\n\n现在，我们可以使用 Sort 类来排序一个数组。例如，我们可以使用插入排序策略来对数组进行排序：\nconst data &#x3D; [3, 1, 4, 2];\nconst sort &#x3D; new Sort(new InsertionSort());\nconsole.log(sort.sort(data)); &#x2F;&#x2F; 输出 [1, 2, 3, 4]\n\n也可以在运行时更改策略，比如我们在排序后决定使用快速排序：\nsort.setStrategy(new QuickSort());\nconsole.log(sort.sort(data)); &#x2F;&#x2F; 输出 [1, 2, 3, 4]\n\n这里的关键是将不同的排序算法封装为不同的策略类，使得它们可以相互替换，同时使用 Sort 类来调用不同的策略类实现不同的排序算法。\n策略模式例子 3好的，以下是另一个策略模式的例子：\n假设你正在开发一个电商网站，需要计算商品的价格。每个商品的价格计算方式可能不同，比如有些商品是按照重量计算价格，有些商品是按照数量计算价格，还有些商品可能是按照尺寸、颜色等多种因素计算价格。这就可以使用策略模式来实现。\n首先，定义一个价格计算策略的接口 PriceStrategy，该接口有一个方法 calculatePrice，用于计算商品的价格：\n&#x2F;&#x2F; 价格计算策略接口\nclass PriceStrategy &#123;\n  calculatePrice(product) &#123;\n    throw new Error(&#39;calculatePrice method must be implemented&#39;);\n  &#125;\n&#125;\n\n然后，定义不同的价格计算策略，比如按照重量计算价格的策略 WeightPriceStrategy：\n&#x2F;&#x2F; 按照重量计算价格的策略\nclass WeightPriceStrategy extends PriceStrategy &#123;\n  calculatePrice(product) &#123;\n    return product.weight * product.pricePerKg;\n  &#125;\n&#125;\n\n还可以定义按照数量计算价格的策略 QuantityPriceStrategy：\n&#x2F;&#x2F; 按照数量计算价格的策略\nclass QuantityPriceStrategy extends PriceStrategy &#123;\n  calculatePrice(product) &#123;\n    return product.quantity * product.pricePerUnit;\n  &#125;\n&#125;\n\n最后，定义一个 Product 类，它包含商品的信息和使用的价格计算策略：\nclass Product &#123;\n  constructor(name, pricePerUnit, pricePerKg, weight, quantity, priceStrategy) &#123;\n    this.name &#x3D; name;\n    this.pricePerUnit &#x3D; pricePerUnit;\n    this.pricePerKg &#x3D; pricePerKg;\n    this.weight &#x3D; weight;\n    this.quantity &#x3D; quantity;\n    this.priceStrategy &#x3D; priceStrategy;\n  &#125;\n\n  getPrice() &#123;\n    return this.priceStrategy.calculatePrice(this);\n  &#125;\n&#125;\n\n使用策略模式的好处在于，你可以很方便地添加新的价格计算策略，只需要定义一个新的策略类，实现 PriceStrategy 接口即可。同时，每个商品对象都可以使用不同的价格计算策略，方便灵活地处理各种计价方式。\njs 模版模式模板模式是一种行为设计模式，它定义了一个算法的骨架，将一些步骤的实现留给子类来完成。这样可以在不改变算法结构的前提下，通过子类的实现来定制算法的具体实现。\n下面是一个简单的 JavaScript 示例，展示了如何使用模板模式：\nclass AbstractClass &#123;\n  templateMethod() &#123;\n    this.doStep1();\n    this.doStep2();\n    this.doStep3();\n  &#125;\n&#125;\n\nclass ConcreteClass extends AbstractClass &#123;\n  doStep1() &#123;\n    console.log(&#39;ConcreteClass doStep1&#39;);\n  &#125;\n\n  doStep2() &#123;\n    console.log(&#39;ConcreteClass doStep2&#39;);\n  &#125;\n\n  doStep3() &#123;\n    console.log(&#39;ConcreteClass doStep3&#39;);\n  &#125;\n&#125;\n\nconst concrete &#x3D; new ConcreteClass();\nconcrete.templateMethod();\n\n在上面的示例中，AbstractClass 是一个抽象类，其中 templateMethod 是模板方法，它定义了算法的基本骨架，ConcreteClass 是一个具体子类，它通过实现 AbstractClass 中定义的抽象方法来完成算法中的具体步骤。在 ConcreteClass 中实现的具体步骤会被模板方法按照预定的顺序调用，从而完成整个算法的执行。最后，我们通过创建一个 ConcreteClass 对象来调用算法。\n需要注意的是，在模板模式中，模板方法应该是不可被子类修改的，只有抽象方法才应该由子类来实现，以保证算法的整体结构不被破坏。\n在抽象类方法中, 为什么可以通过 this 调用到子类的方法在 JavaScript 中并不存在抽象类，但是可以通过使用函数、对象、类等方式来实现类似于抽象类的效果。\n在模板方法模式中，我们定义了一个抽象基类，它提供了一个模板方法，该方法定义了一系列抽象操作的执行顺序，并在其中调用了一些具体的操作方法，这些具体的操作方法由子类去实现。在 JavaScript 中，我们可以使用函数来实现这样的模板方法。\n在 JavaScript 中，函数的 this 指向调用该函数的对象。\n在模板方法模式中，模板方法定义在抽象基类中，而具体的操作方法则在子类中实现。当我们调用抽象基类中的模板方法时，其实是通过子类对象去调用的，此时的 this 指向的就是子类对象，因此可以通过 this 调用子类实现的方法。\n子类对象为什么可以调用到抽象基类的方法？子类对象之所以可以调用到抽象基类的方法，是因为子类通过继承了抽象基类，获得了基类的所有成员，包括方法。在 JavaScript 中，子类可以使用 extends 关键字继承父类，这样子类就可以访问父类的方法和属性。\n在抽象基类中，可以定义抽象方法，即只有方法名称、参数和返回类型，没有具体的实现代码。子类必须实现抽象方法，否则会在编译期间报错。当子类调用基类中的抽象方法时，会自动调用子类中实现的具体方法，这也是实现多态的一种方式。\n总之，子类通过继承抽象基类获得了基类的方法和属性，也可以在子类中实现基类中定义的抽象方法，从而实现多态。\nextends 关键字 有哪些作用在 JavaScript 中，extends 是一个用于创建子类的关键字，它有以下几个作用：\n\n实现继承：使用 extends 关键字可以让一个类继承另一个类的所有属性和方法，从而避免了重复编写相同的代码。\n\n父类调用：在子类的构造函数中，可以使用 super 关键字来调用父类的构造函数，从而初始化父类中的属性。\n\n方法重写：子类可以重写父类中的方法，从而实现自己的业务逻辑。\n\n父类访问限制：通过 super 关键字，子类可以访问到父类中的 public 和 protected 属性和方法，但无法访问 private 属性和方法。\n\n\n使用 extends 关键字可以让我们更加方便地实现面向对象编程中的继承和多态。\njs 责任链模式责任链模式是一种行为设计模式，它允许你将请求沿着处理者链进行发送，直到其中一个处理者对其进行处理为止。责任链模式中的处理者对象组成一条链，请求在这条链上传递，直到有一个处理者处理该请求。如果当前处理者不能处理请求，则将请求传递给下一个处理者进行处理，直到请求被处理或者所有处理者都无法处理为止。\n代码示例在 JavaScript 中，可以通过构造函数和原型链的方式来实现责任链模式。具体实现方式如下：\n&#x2F;&#x2F; 抽象处理者\nclass Handler &#123;\n  constructor() &#123;\n    this.nextHandler &#x3D; null;\n  &#125;\n  setNext(handler) &#123;\n    this.nextHandler &#x3D; handler;\n    return handler;\n  &#125;\n  handle(request) &#123;\n    if (this.nextHandler) &#123;\n      return this.nextHandler.handle(request);\n    &#125;\n    return null;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 具体处理者A\nclass ConcreteHandlerA extends Handler &#123;\n  handle(request) &#123;\n    if (request &#x3D;&#x3D;&#x3D; &#39;A&#39;) &#123;\n      return &#96;Request $&#123;request&#125; handled by ConcreteHandlerA&#96;;\n    &#125; else &#123;\n      return super.handle(request);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 具体处理者B\nclass ConcreteHandlerB extends Handler &#123;\n  handle(request) &#123;\n    if (request &#x3D;&#x3D;&#x3D; &#39;B&#39;) &#123;\n      return &#96;Request $&#123;request&#125; handled by ConcreteHandlerB&#96;;\n    &#125; else &#123;\n      return super.handle(request);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 具体处理者C\nclass ConcreteHandlerC extends Handler &#123;\n  handle(request) &#123;\n    if (request &#x3D;&#x3D;&#x3D; &#39;C&#39;) &#123;\n      return &#96;Request $&#123;request&#125; handled by ConcreteHandlerC&#96;;\n    &#125; else &#123;\n      return super.handle(request);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 客户端代码\nconst handlerA &#x3D; new ConcreteHandlerA();\nconst handlerB &#x3D; new ConcreteHandlerB();\nconst handlerC &#x3D; new ConcreteHandlerC();\n\nhandlerA.setNext(handlerB).setNext(handlerC);\n\nconsole.log(handlerA.handle(&#39;B&#39;)); &#x2F;&#x2F; 输出: Request B handled by ConcreteHandlerB\nconsole.log(handlerA.handle(&#39;D&#39;)); &#x2F;&#x2F; 输出: null\n\n在上面的示例中，我们定义了抽象处理者 Handler 和具体处理者 ConcreteHandlerA、ConcreteHandlerB、ConcreteHandlerC。每个具体处理者都可以处理特定的请求，如果无法处理则将请求传递给下一个处理者进行处理，最终如果所有的处理者都无法处理该请求，则返回 null。\n客户端代码中，我们创建了具体处理者的实例，并将它们组成责任链。当请求传递到责任链上时，责任链中的处理者依次尝试处理该请求，直到有一个处理者能够处理该请求或者所有的处理者都无法处理该请求。\n上述代码 nextHandler 是链的指针？是的，nextHandler 变量指向下一个处理请求的对象，通过链式调用，实现请求在链上传递的效果。当一个处理者处理完请求后，会将请求传递给 nextHandler 处理，如果当前处理者没有后继者，则直接结束请求。\n注意 thisjs 备忘录模式假设我们正在开发一个记事本应用程序，我们想要实现一个可以撤销和重做操作的功能。这时候就可以使用备忘录模式。\n下面是一个简单的示例：\nclass TextEditor &#123;\n  constructor() &#123;\n    this.text &#x3D; &#39;&#39;;\n    this.history &#x3D; [];\n    this.historyIndex &#x3D; -1;\n  &#125;\n\n  write(text) &#123;\n    this.text +&#x3D; text;\n  &#125;\n\n  undo() &#123;\n    if (this.historyIndex &gt; 0) &#123;\n      this.historyIndex--;\n      this.text &#x3D; this.history[this.historyIndex];\n    &#125;\n  &#125;\n\n  redo() &#123;\n    if (this.historyIndex &lt; this.history.length - 1) &#123;\n      this.historyIndex++;\n      this.text &#x3D; this.history[this.historyIndex];\n    &#125;\n  &#125;\n\n  save() &#123;\n    this.historyIndex++;\n    this.history[this.historyIndex] &#x3D; this.text;\n  &#125;\n&#125;\n\nconst editor &#x3D; new TextEditor();\neditor.write(&#39;Hello, &#39;);\neditor.write(&#39;world!&#39;);\neditor.save();\nconsole.log(editor.text); &#x2F;&#x2F; &#39;Hello, world!&#39;\neditor.undo();\nconsole.log(editor.text); &#x2F;&#x2F; &#39;Hello, &#39;\neditor.redo();\nconsole.log(editor.text); &#x2F;&#x2F; &#39;Hello, world!&#39;\n\n在上面的示例中，TextEditor 类表示一个文本编辑器，它有 write 方法可以向编辑器中添加文本，undo 和 redo 方法可以撤销和重做操作，save 方法可以保存当前状态到历史记录中。\n每次调用 save 方法时，都会将当前文本的状态保存到历史记录中。当调用 undo 方法时，会将当前文本的状态恢复到上一个历史记录中保存的状态；当调用 redo 方法时，会将当前文本的状态恢复到下一个历史记录中保存的状态。\n在这个示例中，历史记录的状态就是备忘录对象，TextEditor 类就是负责管理备忘录对象的负责人。\njs 命令模式好的，以下是一个更简单的示例：\n假设我们有一个遥控器，可以控制一盏灯的开关，同时遥控器还有一个撤销按钮，可以撤销最近一次的操作。\n我们可以使用命令模式来实现这个遥控器，具体实现如下：\nclass Light &#123;\n  turnOn() &#123;\n    console.log(&#39;Light is on&#39;);\n  &#125;\n\n  turnOff() &#123;\n    console.log(&#39;Light is off&#39;);\n  &#125;\n&#125;\n\nclass LightOnCommand &#123;\n  constructor(light) &#123;\n    this.light &#x3D; light;\n  &#125;\n\n  execute() &#123;\n    this.light.turnOn();\n  &#125;\n\n  undo() &#123;\n    this.light.turnOff();\n  &#125;\n&#125;\n\nclass LightOffCommand &#123;\n  constructor(light) &#123;\n    this.light &#x3D; light;\n  &#125;\n\n  execute() &#123;\n    this.light.turnOff();\n  &#125;\n\n  undo() &#123;\n    this.light.turnOn();\n  &#125;\n&#125;\n\nclass RemoteControl &#123;\n  constructor() &#123;\n    this.commands &#x3D; [];\n    this.undoCommand &#x3D; null;\n  &#125;\n\n  setCommand(command) &#123;\n    this.commands.push(command);\n  &#125;\n\n  pressButton() &#123;\n    if (this.commands.length &gt; 0) &#123;\n      const command &#x3D; this.commands[this.commands.length - 1];\n      command.execute();\n      this.undoCommand &#x3D; command;\n      this.commands.pop();\n    &#125; else &#123;\n      console.log(&#39;No commands to execute&#39;);\n    &#125;\n  &#125;\n\n  pressUndo() &#123;\n    if (this.undoCommand) &#123;\n      this.undoCommand.undo();\n    &#125; else &#123;\n      console.log(&#39;No command to undo&#39;);\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; usage\nconst light &#x3D; new Light();\nconst lightOnCommand &#x3D; new LightOnCommand(light);\nconst lightOffCommand &#x3D; new LightOffCommand(light);\n\nconst remoteControl &#x3D; new RemoteControl();\n\nremoteControl.setCommand(lightOnCommand);\nremoteControl.pressButton(); &#x2F;&#x2F; &quot;Light is on&quot;\nremoteControl.pressUndo(); &#x2F;&#x2F; &quot;Light is off&quot;\n\nremoteControl.setCommand(lightOffCommand);\nremoteControl.pressButton(); &#x2F;&#x2F; &quot;Light is off&quot;\nremoteControl.pressUndo(); &#x2F;&#x2F; &quot;Light is on&quot;\n\n在上述示例中，Light 表示灯的类，LightOnCommand 和 LightOffCommand 分别表示灯的开和关的命令，RemoteControl 表示遥控器类。\n我们可以通过遥控器的 setCommand 方法来设置要执行的命令，然后通过 pressButton 方法执行最近的命令，同时也可以通过 pressUndo 方法撤销最近的一次操作。\njs 中介者模式中介者模式是一种行为型设计模式，它可以让对象之间不直接相互交互，而是通过一个中介对象进行沟通。在这种模式下，对象之间不需要知道彼此的存在，只需要和中介者对象进行通信即可。\n举个简单的例子，假设我们有一个聊天室，里面有多个用户，这些用户都可以相互发送消息。当一个用户发送消息时，它需要将这个消息发送给聊天室中的所有其他用户，这时候就可以使用中介者模式。\n在这个例子中，聊天室就是中介者对象，用户之间不直接进行通信，而是通过聊天室进行消息的发送和接收。这样可以将聊天室作为一个单独的模块进行维护，避免了多个用户之间直接交互所带来的复杂性。\n以下是一个简单的 JavaScript 中介者模式的示例：\nclass ChatRoom &#123;\n  showMessage(user, message) &#123;\n    console.log(&#96;[$&#123;user.getName()&#125;]: $&#123;message&#125;&#96;);\n  &#125;\n&#125;\n\nclass User &#123;\n  constructor(name, chatRoom) &#123;\n    this.name &#x3D; name;\n    this.chatRoom &#x3D; chatRoom;\n  &#125;\n\n  getName() &#123;\n    return this.name;\n  &#125;\n\n  sendMessage(message) &#123;\n    this.chatRoom.showMessage(this, message);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 创建一个聊天室\nconst chatRoom &#x3D; new ChatRoom();\n\n&#x2F;&#x2F; 创建多个用户，并将它们加入到聊天室中\nconst user1 &#x3D; new User(&#39;Alice&#39;, chatRoom);\nconst user2 &#x3D; new User(&#39;Bob&#39;, chatRoom);\nconst user3 &#x3D; new User(&#39;Charlie&#39;, chatRoom);\n\n&#x2F;&#x2F; 用户发送消息\nuser1.sendMessage(&#39;Hello, Bob!&#39;);\nuser2.sendMessage(&#39;Hi, Alice!&#39;);\nuser3.sendMessage(&#39;What are you guys doing?&#39;);\n\n在这个例子中，ChatRoom 是中介者对象，User 是具体的同事对象。当一个用户发送消息时，它会将消息发送给 ChatRoom 对象，由 ChatRoom 对象将消息广播给其他用户。\n需要注意的是，在这个例子中，每个用户都持有一个对中介者对象的引用。这是因为它们需要将消息发送给中介者对象，而中介者对象则需要知道所有同事对象的存在。\njs 迭代器模式迭代器模式是一种行为设计模式，它提供了一种方法来遍历复杂数据结构中的每个元素，而不必暴露其内部实现。它允许我们在不了解数据结构的底层细节的情况下进行迭代操作。\n在 JavaScript 中，迭代器模式通常通过 Symbol.iterator 接口实现。Symbol.iterator 是一个内置的符号，表示一个可迭代对象的迭代器方法。实现了 Symbol.iterator 方法的对象可以使用 for…of 循环或者使用内置的迭代器方法来进行遍历。\n下面是一个使用迭代器模式遍历数组的示例：\nconst numbers &#x3D; [1, 2, 3, 4, 5];\nconst iterator &#x3D; numbers[Symbol.iterator]();\n\nfor (const number of iterator) &#123;\n  console.log(number);\n&#125;\n\n在这个示例中，我们通过获取数组的内置迭代器方法（通过 Symbol.iterator）来创建一个迭代器对象。然后，我们使用 for…of 循环来遍历这个迭代器对象，输出数组中的每个元素。\n在 JavaScript 中，除了数组，还有很多其他的内置可迭代对象，例如字符串、Set、Map、NodeList 等。我们也可以自己实现可迭代对象，并在其中实现 Symbol.iterator 方法来支持迭代器模式的使用。\n示例代码假设有一个数组对象，我们需要编写一个迭代器来遍历该数组并执行一些操作。可以使用以下代码实现一个简单的迭代器：\nclass Iterator &#123;\n  constructor(items) &#123;\n    this.items &#x3D; items;\n    this.index &#x3D; 0;\n  &#125;\n  &#x2F;&#x2F; 是否有下一个\n  hasNext() &#123;\n    return this.index &lt; this.items.length;\n  &#125;\n  &#x2F;&#x2F; 获取下一个\n  next() &#123;\n    return this.items[this.index++];\n  &#125;\n&#125;\n\nconst colors &#x3D; new Iterator([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);\n\nwhile (colors.hasNext()) &#123;\n  console.log(colors.next());\n&#125;\n\n输出：\n&#39;red&#39;\n&#39;green&#39;\n&#39;blue&#39;\n\n在此示例中，\n\n我们定义了一个Iterator类，该类将数组对象作为构造函数的参数。\nhasNext方法检查是否还有下一个元素，\n而next方法返回下一个元素，并将索引增加 1。\n我们可以使用while循环遍历数组并打印每个元素。\n\n什么是设计模式设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用\n使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性\n为什么要学习设计模式学习设计模式，有助于写出可复用和可维护性高的程序\n设计模式原则设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构\n创建型模式 5一、工厂模式\n工厂模式：将创建对象的过程单独封装\n\n使用场景：有构造函数的地方、写了大量构造函数、调用了大量的 new 的情况下\n见\n\n\n二、抽象工厂模式工厂模式与抽象工厂模式区别抽象工厂（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性具体工厂（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。\n见\n三、单例模式\n定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点\n核心：确保只有一个实例，并提供全局访问\n实现单例的方式：单例函数, 类的构造方法 ,类的静态方法\n\n&#x2F;&#x2F; 提取出通用的单例\nfunction getSingleton(fn) &#123;\n  var instance &#x3D; null;\n\n  return function () &#123;\n    if (!instance) &#123;\n      instance &#x3D; fn.apply(this, arguments);\n    &#125;\n\n    return instance;\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 通过构造函数\nclass Singleton &#123;\n  &#x2F;&#x2F; static instance; 加不加都可，类中可以直接赋值和获取静态属性\n  constructor() &#123;\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this; &#x2F;&#x2F; this，是新创建的对象，new关键字原理中，this指向new出的对象\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n&#x2F;&#x2F;  通过静态方法\nclass Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n&#x2F;#&#x2F;post&#x2F;2022-09-19qa\n四、建造者模式五、原型模式见 见\n\n为什么出现：直接创建对象代价较大，所以采用这种模式\n要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 - 对象会记住它的原型。\n原型模式是用于创建对象的一种模式。我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象\n注意：使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据&#x2F;方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的\nJavaScript 本身是一门基于原型的面向对象语言，Object.create 方法就是原型模式的天然实现—––准确地说，只要我们还在借助 Prototype 来实现对象的创建和原型的继承，那么我们就是在应用原型模式\n当对象 a 需 要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的 效果，Object.create的原理体现\n\nvar obj &#x3D; &#123; name: &#39;zyy&#39; &#125;;\n\nvar A &#x3D; function () &#123;&#125;;\nA.prototype &#x3D; obj;\n\nvar a &#x3D; new A();\n\n&#x2F;&#x2F;a.name &#x3D; zyy\n\n&#x2F;&#x2F; 执行这段代码的时候，引擎做的事：\n\n&#x2F;&#x2F; 1. 尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。\n\n&#x2F;&#x2F; 2. 查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.proto 记录着并且指向 A.prototype，而 A.prototype 被设置为对象 obj。\n\n&#x2F;&#x2F; 3. 在对象 obj 中找到了 name 属性，并返回它的值。\n\n&#x2F;&#x2F; 提问自测\n\n&#x2F;&#x2F; 1、为什么说 ES6 的 Class 只是语法糖\n\n&#x2F;&#x2F; 起源上说，JavaScript是基于原型的面向对象系统。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来， 一个对象是通过克隆另外一个对象所得到的。\n\n&#x2F;&#x2F; ES6的 Class 语法,让 JavaScript 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。\n\n&#x2F;&#x2F; 2、上面使用了new A() ，所以A属于类吗？\n\n&#x2F;&#x2F; 在这里 A 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。\n\n&#x2F;&#x2F; 3、存在没有原型的对象吗？\n\n&#x2F;&#x2F; 通过设置构造器的 prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个 原型。而通过 Object.create( null )可以创建出没有原型的对象。\n\n结构型模式 8适配器模式 “包装模式”适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够 使它们协同作用。\n个人总结场景：之前一种设计，后来想到了一种更好的设计，要让现在的兼容之前的，并且只保留一份同等功能的代码，就需要在两种设计之间增加适配器\njavascript 设计模式之适配器模式\n装饰器模式 “包装模式”\n解决问题：继承会破坏封装性，装饰器模式，比起继承，更具有封装型\nES7 中的 decorator 同样借鉴了这个语法糖，不过依赖于 ES5 的 Object.defineProperty 方法\n装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时\n\n\n\n\n\n\n\n\n\n\n给对象动态地增加职责的方式称为装 饰器(decorator)模式。装饰器模式能够在不改 变对象自身的基础上，在程序运行期间给对象 动态地添加职责。\nES7 为我们提供了语法糖可以给一个类装上装饰器，继续改造上面的代码\n&#x2F;&#x2F; 装饰器函数，它的第一个参数是目标类\nfunction Decorator(target) &#123;\n    target.control &#x3D; function() &#123;\n        console.log(&#39;我是新的逻辑&#39;)\n    &#125;\n    return target\n&#125;\n\n\n&#x2F;&#x2F; 将装饰器“安装” 到HorribleCode上\n@Decorator\nclass HorribleCode () &#123;\n    &#x2F;&#x2F;老代码逻辑\n&#125;\n\n\nHorribleCode.control()\n\n过滤器模式&#x2F;标准模式&#x2F;挑三拣四目的：使用不同标准来过滤一组对象实现：制定不同的规则来实现过滤，然后对过滤结果进行分组见\n代理模式 “包装模式”\n作用：实现访问主体的控制，简单来说就是增加了一层，进行访问控制\n三种：保护代理,虚拟代理,缓存代理\n\n桥接模式抽象部分与实现部分的分离，使得二者可以独立的变化，而不必拘泥于形式\n在封装开源库的组件时候，经常会用到这种设计模式。\n例如，对外提供暴露一个 complete 函数,如果用户有传入此函数, 那么就会在某一段代码逻辑中调用。\n这个过程中，组件起到了“桥”的作用，而具体实现是用户自定义。\nJavaScript 中桥接模式的典型应用是：Array 对象上的 forEach 函数。\n使用场景：\n\n最简单模拟 forEach 方法：\n桥接模式在事件监听中的应用 elem.addEventListener(&#39;click&#39;, getBeerByIdBridge, false);\n桥接模式用于组件开发\n\n作者：Sky 飞羽链接：https://www.jianshu.com/p/ceb82afe828d来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n享元模式\n一种用于性能优化的模式，它的目标是尽量减少共享对象的数量\n内部共享，外部剥离(能够共用的封装在能不，不能够共用的封装在外部)\n\n见\n外观模式（模块化开发）\n增加一层，让从外部看来，像是一个（一致对外）\n使用：模块汇总后统一导出\n\n见\n组合模式&#x2F;部分整体模式\n用相同的方式处理一组相似对象 例如： 文件目录显示，多级目录呈现等树形结构数据的操作\n\n见\n行为型模式 10 CG MD ZB MZ策略模式\n策略模式的出现是为了解决多重判断的问题\n组成：组策略，组策略的实现\n可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护\n\n使用场景：规则校验,权限操作\n观察者模式&#x2F;发布订阅模式\n也叫观察者模式\n解耦：1. 时间上的解耦，2. 为对象之间的解耦\n\n模板模式\n模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。\n简单理解为：规划好了蓝图，照着蓝图去具体实现\n\n迭代器模式\n在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素\n在 javascript 中，实现了[Symbol.iterator]属性的类数组，返回一个函数，就可以使用迭代器\n\nJavaScript 设计模式（九）-迭代器模式Iterator 和 for…of 循环\n责任链模式\n为请求创建了一个接收者对象的链。多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。\n这些对象连接成为“链式结构”，每个节点转发请求，直到有对象处理请求为止\n使用场景：不同日志输出&#x2F;记录\n区别于过滤模式，过滤是满足就执行，责任链模式：满足执行并终止\n\n见\n备忘录模式\n保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。\n历史记录这玩意就是备忘录模式\n\n命令模式\n用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系\n\n中介者模式\n中介者模式的作用：就是解除对象与对象之间的紧耦合关系。\n增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可\n如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。\n\n见\n访问者模式\n意图：主要将数据结构与数据操作分离。\n主要解决：稳定的数据结构和易变的操作耦合问题。\n何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中菜鸟教程-设计模式-访问者模式见\n\n状态模式\n发布—订阅模式的优点： 时间上的解耦，对象之间的解耦\n避免了 Context 无限膨胀，状态切换的逻辑分布在状态类中，也避免了大量的 if-else 语句。\n用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。\nContext 中的请求动作和状态类中封装的行为相互独立切互不影响，也使得修改更加容易。\n\n实现方式：\n\n类似 java 中一个 State 抽象类，其他状态类继承并重写其方法，实现自己的状态类方法\nJavaScript 可以非常方便利用委托技术， 通过 Function.prototype.call 方法直接把请求委托给某个对象字面来执行\n\nJavaScript 版本的状态机\n解释器模式\n这个比较难理解\n\n空对象模式未对该类做任何实现的空对象类\n分类创建型模式 原建工抽单&#x2F;&#x2F; 原型模式、建造者模式、工厂模式、抽象工厂模式、单例模式、\n&#x2F;&#x2F; 记忆口诀：原建工抽单（原来建工立业的人要抽单【交税】）\n\n\n\n\n简\n原\n建\n工\n抽\n单\n\n\n\n全\n原型模式\n建造者模式\n工厂模式\n抽象工厂模式\n单例模式\n\n\n结构型模式&#x2F;&#x2F; 享元模式、桥接模式、外观模式、适配器模式、组合模式、装饰者模式、代理模式、\n&#x2F;&#x2F; 记忆口诀（7）：享桥外适组装代【想桥外试、租装戴】\n\n\n\n\n简\n享\n桥\n外\n适\n组\n装\n代\n\n\n\n全\n享元模式\n桥接模式\n外观模式\n适配器模式\n组合模式\n装饰者模式\n代理模式\n\n\n行为型模式&#x2F;&#x2F; 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式\n&#x2F;&#x2F; 记忆口诀（11）：观察者、访问者、中介者；命令、解释、模版、状态；策略、责任、迭代、备忘\n\n记忆口诀行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）\n\n\n问题\n中间件是什么设计模式？（1. 中间人？不像 2. 过滤器？像又不像 3.代理模式，像又不像）\n\n代码用设计模式往往比不用设计模式，更难理解确实，在应用设计模式时，代码可能会更加抽象和复杂，因此阅读和理解代码的难度可能会增加。设计模式的目的是提供一种灵活、可扩展且易于维护的代码结构，以解决特定的问题或满足特定的需求。但是，设计模式并不是适用于所有情况的银弹，有时候简单的解决方案可能更为合适。\n尽管使用设计模式可能增加代码的复杂性，但它们在长期和大型项目中可以带来许多优势。设计模式可以提高代码的可读性、可维护性和可扩展性，并促进团队合作和代码重用。此外，使用设计模式可以帮助开发人员遵循行业标准和最佳实践，从而提高代码质量和可靠性。\n理解和应用设计模式需要一定的学习和实践，一开始可能会感到困惑，但随着经验的积累，你将能够更好地理解和应用它们。此外，编写清晰、注释良好的代码以及提供适当的文档和示例可以帮助其他开发人员更容易地理解和使用设计模式。\n总而言之，设计模式是一种工具，用于解决特定的问题和提高代码质量。使用设计模式时需要权衡其带来的复杂性和优势，并根据具体情况做出适当的选择。在团队合作和大型项目中，良好的代码组织和结构是非常重要的，设计模式可以成为实现这一目标的有力工具之一。\nReact hook 属于 23 种设计模式中的哪种React Hook 不属于传统的 23 种设计模式中的任何一种。它是一种特定于 React 的编程模式，用于在函数组件中引入和管理状态、副作用等功能。\n传统的设计模式是一种通用的设计思想和解决方案，用于解决软件开发中的常见问题。这些设计模式包括单例模式、工厂模式、观察者模式、策略模式等等，它们在面向对象编程中起到了重要的作用。\nReact Hook 的出现改变了 React 组件开发的方式，它提供了一种函数式的方式来处理状态和副作用，使得组件逻辑更加简洁和可复用。它并不是传统意义上的设计模式，而是一种新的编程模式，更准确地说是一种函数组件的编程范式。\n虽然 React Hook 不属于传统的设计模式，但它在 React 社区中获得了广泛的认可和应用，成为了 React 开发中的重要工具和范式。它使得 React 组件更易于编写、测试和维护，并带来了许多性能优化和开发效率上的改进。\n设计模式更适用于面向对象编程，而不适用于函数式编程？设计模式的概念确实最初是在面向对象编程中引入的，并且设计模式的一些原则和概念更直接适用于面向对象编程。然而，设计模式的一些基本原则和思想也可以在函数式编程中得到应用。\n虽然函数式编程和面向对象编程有一些不同的特点和思想，但设计模式的目的是解决通用的软件设计问题，无论是哪种编程范式。设计模式的一些原则，如单一职责原则、开放封闭原则、依赖倒置原则等，仍然适用于函数式编程。\n在函数式编程中，设计模式的应用可能会有所不同，因为函数式编程更强调纯函数、不可变性和无副作用。函数式编程中更常见的是一些特定的函数式编程模式，如高阶函数、纯函数组合、函数柯里化等。\n虽然设计模式在函数式编程中的应用可能会有所不同，但仍然可以从设计模式的一些原则和思想中获益，帮助解决函数式编程中的设计问题和优化代码结构。\n因此，虽然设计模式的概念最初是在面向对象编程中引入的，但一些设计模式的基本原则和思想仍然可以在函数式编程中得到应用，并且可以帮助解决通用的软件设计问题。\n参考链接设计模式简介\njavascript 的 23 种设计模式\n","slug":"2022-10-27设计模式","date":"2022-10-27T05:59:49.000Z","categories_index":"前端基础","tags_index":"前端基础,chatGPT2021","author_index":"举手摘月亮"},{"id":"03a0cd201b7e39fe38e7f2e815b3009b","title":"css theme","content":"mdn 主题切换\n\n -->\n\n\n\nlight&#x2F;dark&#x2F;os-default_theme.scss&#x2F;&#x2F; _theme.scss\n@use &quot;sass:color&quot;;\n@use &quot;..&#x2F;vars.scss&quot; as *; &#x2F;&#x2F; 这个见下面的\n@use &quot;..&#x2F;color-palette&quot; as *; &#x2F;&#x2F; 这个没找到\n\n&#x2F;* 浅色主题 *&#x2F;\n@mixin light-theme &#123;\n  --text-primary: #&#123;$mdn-theme-light-text-primary&#125;;\n  --text-secondary: #&#123;$mdn-theme-light-text-secondary&#125;;\n  --text-inactive: #&#123;$mdn-theme-light-text-inactive&#125;;\n  --text-link: #&#123;$mdn-theme-light-text-link&#125;;\n  --text-invert: #&#123;$mdn-theme-light-text-invert&#125;;\n\n  --background-primary: #&#123;$mdn-theme-light-background-primary&#125;;\n  --background-secondary: #&#123;$mdn-theme-light-background-secondary&#125;;\n  --background-tertiary: #&#123;$mdn-theme-light-background-tertiary&#125;;\n  --background-toc-active: #&#123;$mdn-theme-light-background-toc-active&#125;;\n  --background-mark-yellow: #&#123;color.adjust(\n      $mdn-color-light-theme-yellow-30,\n      $alpha: -0.6\n    )&#125;;\n  --background-mark-green: #&#123;color.adjust(\n      $mdn-color-light-theme-green-30,\n      $alpha: -0.6\n    )&#125;;\n  --background-information: #&#123;color.adjust(\n      $mdn-theme-light-icon-information,\n      $alpha: -0.9\n    )&#125;;\n  --background-warning: #&#123;color.adjust(\n      $mdn-theme-light-icon-warning,\n      $alpha: -0.9\n    )&#125;;\n  --background-critical: #&#123;color.adjust(\n      $mdn-theme-light-icon-critical,\n      $alpha: -0.9\n    )&#125;;\n  --background-success: #&#123;color.adjust(\n      $mdn-theme-light-icon-success,\n      $alpha: -0.9\n    )&#125;;\n\n  --border-primary: #&#123;$mdn-theme-light-border-primary&#125;;\n  --border-secondary: #&#123;$mdn-theme-light-border-secondary&#125;;\n\n  --button-primary-default: #&#123;$mdn-theme-light-button-primary-default&#125;;\n  --button-primary-hover: #&#123;$mdn-theme-light-button-primary-hover&#125;;\n  --button-primary-active: #&#123;$mdn-theme-light-button-primary-active&#125;;\n  --button-primary-inactive: #&#123;$mdn-theme-light-button-primary-inactive&#125;;\n\n  --button-secondary-default: #&#123;$mdn-theme-light-button-secondary-default&#125;;\n  --button-secondary-hover: #&#123;$mdn-theme-light-button-secondary-hover&#125;;\n  --button-secondary-active: #&#123;$mdn-theme-light-button-secondary-active&#125;;\n  --button-secondary-inactive: #&#123;$mdn-theme-light-button-secondary-inactive&#125;;\n  --button-secondary-border-focus: #&#123;$mdn-theme-light-button-secondary-border-focus&#125;;\n  --button-secondary-border-red: #&#123;$mdn-theme-light-button-secondary-border-red&#125;;\n  --button-secondary-border-red-focus: #&#123;$mdn-theme-light-button-secondary-border-red-focus&#125;;\n\n  --icon-primary: #&#123;$mdn-theme-light-icon-primary&#125;;\n  --icon-secondary: #&#123;$mdn-theme-light-icon-secondary&#125;;\n  --icon-information: #&#123;$mdn-theme-light-icon-information&#125;;\n  --icon-warning: #&#123;$mdn-theme-light-icon-warning&#125;;\n  --icon-critical: #&#123;$mdn-theme-light-icon-critical&#125;;\n  --icon-success: #&#123;$mdn-theme-light-icon-success&#125;;\n\n  --accent-primary: #&#123;$mdn-theme-light-accent-primary&#125;;\n  --accent-primary-engage: #&#123;color.adjust(\n      $mdn-theme-light-accent-primary,\n      $alpha: -0.9\n    )&#125;;\n\n  --accent-secondary: #&#123;$mdn-theme-light-accent-secondary&#125;;\n  --accent-tertiary: #&#123;color.adjust(\n      $mdn-color-light-theme-blue-50,\n      $alpha: -0.9\n    )&#125;;\n\n  --shadow-01: #&#123;$mdn-theme-light-shadow-01&#125;;\n  --shadow-02: #&#123;$mdn-theme-light-shadow-02&#125;;\n  --focus-01: #&#123;$mdn-theme-light-focus-01&#125;;\n  --field-focus-border: #&#123;$mdn-theme-light-field-focus-border&#125;;\n\n  --code-token-tag: #&#123;$mdn-theme-light-code-token-tag&#125;;\n  --code-token-punctuation: #&#123;$mdn-theme-light-code-token-punctuation&#125;;\n  --code-token-attribute-name: #&#123;$mdn-theme-light-code-token-attribute-name&#125;;\n  --code-token-attribute-value: #&#123;$mdn-theme-light-code-token-attribute-value&#125;;\n  --code-token-comment: #&#123;$mdn-theme-light-code-token-comment&#125;;\n  --code-token-default: #&#123;$mdn-theme-light-code-token-default&#125;;\n  --code-token-selector: #&#123;$mdn-theme-light-code-token-selector&#125;;\n  --code-background-inline: #&#123;$mdn-theme-light-code-background-inline&#125;;\n  --code-background-block: #&#123;$mdn-theme-light-code-background-block&#125;;\n\n  --notecard-link-color: #&#123;$mdn-color-neutral-80&#125;;\n\n  --scrollbar-bg: transparent;\n  --scrollbar-color: rgba(0, 0, 0, 0.25);\n\n  --category-color: #&#123;$mdn-color-light-theme-blue-50&#125;;\n  --category-color-background: #&#123;$mdn-color-light-theme-blue-50&#125;10;\n  --code-color: #&#123;$mdn-color-light-theme-blue-40&#125;;\n  --mark-color: #&#123;$mdn-color-light-theme-blue-10&#125;;\n\n  --plus-accent-color: #&#123;$mdn-color-dark-theme-red-60&#125;;\n  --html-accent-color: #&#123;$mdn-color-light-theme-red-60&#125;;\n  --css-accent-color: #&#123;$mdn-color-light-theme-blue-60&#125;;\n  --js-accent-color: #&#123;$mdn-color-light-theme-yellow-40&#125;;\n  --http-accent-color: #&#123;$mdn-color-light-theme-green-60&#125;;\n  --apis-accent-color: #&#123;$mdn-color-light-theme-violet-60&#125;;\n  --learn-accent-color: #&#123;$mdn-color-light-theme-pink-60&#125;;\n\n  --plus-code-color: #&#123;$mdn-color-light-theme-blue-60&#125;;\n  --html-code-color: #&#123;$mdn-color-light-theme-red-70&#125;;\n  --css-code-color: #&#123;$mdn-color-light-theme-blue-60&#125;;\n  --js-code-color: #&#123;$mdn-color-light-theme-yellow-60&#125;;\n  --http-code-color: #&#123;$mdn-color-light-theme-green-60&#125;;\n  --apis-code-color: #&#123;$mdn-color-light-theme-violet-60&#125;;\n  --learn-code-color: #&#123;$mdn-color-light-theme-pink-60&#125;;\n\n  --plus-mark-color: #&#123;$mdn-color-light-theme-red-10&#125;;\n  --html-mark-color: #&#123;$mdn-color-light-theme-red-10&#125;;\n  --css-mark-color: #&#123;$mdn-color-light-theme-blue-10&#125;;\n  --js-mark-color: #&#123;$mdn-color-light-theme-yellow-10&#125;;\n  --http-mark-color: #&#123;$mdn-color-light-theme-green-10&#125;;\n  --apis-mark-color: #&#123;$mdn-color-light-theme-violet-10&#125;;\n  --learn-mark-color: #&#123;$mdn-color-light-theme-pink-10&#125;;\n\n  --plus-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;\n  --html-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;\n  --css-accent-background-color: #&#123;$mdn-color-light-theme-blue-50&#125;30;\n  --js-accent-background-color: #&#123;$mdn-color-light-theme-yellow-50&#125;30;\n  --http-accent-background-color: #&#123;$mdn-color-light-theme-green-50&#125;30;\n  --apis-accent-background-color: #&#123;$mdn-color-light-theme-violet-50&#125;30;\n  --learn-accent-background-color: #&#123;$mdn-color-light-theme-pink-50&#125;30;\n\n  --plus-accent-engage: #&#123;color.adjust(\n      $mdn-color-light-theme-red-50,\n      $alpha: -0.3\n    )&#125;;\n  --html-accent-engage: #&#123;color.adjust(\n      $mdn-color-light-theme-red-50,\n      $alpha: -0.3\n    )&#125;;\n  --css-accent-engage: #&#123;color.adjust(\n      $mdn-color-light-theme-blue-50,\n      $alpha: -0.3\n    )&#125;;\n  --js-accent-engage: #&#123;color.adjust(\n      $mdn-color-light-theme-yellow-50,\n      $alpha: -0.3\n    )&#125;;\n  --http-accent-engage: #&#123;color.adjust(\n      $mdn-color-light-theme-green-50,\n      $alpha: -0.3\n    )&#125;;\n  --apis-accent-engage: #&#123;color.adjust(\n      $mdn-color-light-theme-violet-50,\n      $alpha: -0.3\n    )&#125;;\n  --learn-accent-engage: #&#123;color.adjust(\n      $mdn-color-light-theme-pink-50,\n      $alpha: -0.3\n    )&#125;;\n\n  --modal-backdrop-color: #&#123;rgba($mdn-theme-dark-background-primary, 0.1)&#125;;\n  --blend-color: #&#123;$mdn-color-white&#125;80;\n\n  --text-primary-red: #&#123;$mdn-color-light-theme-red-60&#125;;\n  --text-primary-green: #&#123;$mdn-color-light-theme-green-60&#125;;\n  --text-primary-blue: #&#123;$mdn-color-light-theme-blue-60&#125;;\n  --text-primary-yellow: #&#123;$mdn-color-light-theme-yellow-60&#125;;\n  color-scheme: light;\n&#125;\n&#x2F;* 深色主题 *&#x2F;\n@mixin dark-theme &#123;\n  --text-primary: #&#123;$mdn-theme-dark-text-primary&#125;;\n  --text-secondary: #&#123;$mdn-theme-dark-text-secondary&#125;;\n  --text-inactive: #&#123;$mdn-theme-dark-text-inactive&#125;;\n  --text-link: #&#123;$mdn-theme-dark-text-link&#125;;\n  --text-invert: #&#123;$mdn-theme-dark-text-invert&#125;;\n\n  --background-primary: #&#123;$mdn-theme-dark-background-primary&#125;;\n  --background-secondary: #&#123;$mdn-theme-dark-background-secondary&#125;;\n  --background-tertiary: #&#123;$mdn-theme-dark-background-tertiary&#125;;\n  --background-toc-active: #&#123;$mdn-theme-dark-background-toc-active&#125;;\n  --background-mark-yellow: #&#123;color.adjust(\n      $mdn-color-dark-theme-yellow-30,\n      $alpha: -0.6\n    )&#125;;\n  --background-mark-green: #&#123;color.adjust(\n      $mdn-color-light-theme-green-30,\n      $alpha: -0.6\n    )&#125;;\n  --background-information: #&#123;color.adjust(\n      $mdn-theme-light-icon-information,\n      $alpha: -0.9\n    )&#125;;\n  --background-warning: #&#123;color.adjust(\n      $mdn-theme-light-icon-warning,\n      $alpha: -0.9\n    )&#125;;\n  --background-critical: #&#123;color.adjust(\n      $mdn-theme-light-icon-critical,\n      $alpha: -0.9\n    )&#125;;\n  --background-success: #&#123;color.adjust(\n      $mdn-theme-light-icon-success,\n      $alpha: -0.9\n    )&#125;;\n\n  --border-primary: #&#123;$mdn-theme-dark-border-primary&#125;;\n  --border-secondary: #&#123;$mdn-theme-dark-border-secondary&#125;;\n\n  --button-primary-default: #&#123;$mdn-theme-dark-button-primary-default&#125;;\n  --button-primary-hover: #&#123;$mdn-theme-dark-button-primary-hover&#125;;\n  --button-primary-active: #&#123;$mdn-theme-dark-button-primary-active&#125;;\n  --button-primary-inactive: #&#123;$mdn-theme-dark-button-primary-inactive&#125;;\n\n  --button-secondary-default: #&#123;$mdn-theme-dark-button-secondary-default&#125;;\n  --button-secondary-hover: #&#123;$mdn-theme-dark-button-secondary-hover&#125;;\n  --button-secondary-active: #&#123;$mdn-theme-dark-button-secondary-active&#125;;\n  --button-secondary-inactive: #&#123;$mdn-theme-dark-button-secondary-inactive&#125;;\n  --button-secondary-border-focus: #&#123;$mdn-theme-light-button-secondary-border-focus&#125;;\n  --button-secondary-border-red: #&#123;$mdn-theme-light-button-secondary-border-red&#125;;\n  --button-secondary-border-red-focus: #&#123;$mdn-theme-light-button-secondary-border-red-focus&#125;;\n\n  --icon-primary: #&#123;$mdn-theme-dark-icon-primary&#125;;\n  --icon-secondary: #&#123;$mdn-theme-dark-icon-secondary&#125;;\n  --icon-information: #&#123;$mdn-theme-dark-icon-information&#125;;\n  --icon-warning: #&#123;$mdn-theme-dark-icon-warning&#125;;\n  --icon-critical: #&#123;$mdn-theme-dark-icon-critical&#125;;\n  --icon-success: #&#123;$mdn-theme-dark-icon-success&#125;;\n\n  --accent-primary: #&#123;$mdn-theme-dark-accent-primary&#125;;\n  --accent-primary-engage: #&#123;color.adjust(\n      $mdn-theme-dark-accent-primary,\n      $alpha: -0.9\n    )&#125;;\n  --accent-secondary: #&#123;$mdn-theme-dark-accent-secondary&#125;;\n  --accent-tertiary: #&#123;color.adjust(\n      $mdn-color-light-theme-blue-50,\n      $alpha: -0.9\n    )&#125;;\n\n  --shadow-01: #&#123;$mdn-theme-dark-shadow-01&#125;;\n  --shadow-02: #&#123;$mdn-theme-dark-shadow-02&#125;;\n  --focus-01: #&#123;$mdn-theme-dark-focus-01&#125;;\n  --field-focus-border: #&#123;$mdn-theme-dark-field-focus-border&#125;;\n\n  --code-token-tag: #&#123;$mdn-theme-dark-code-token-tag&#125;;\n  --code-token-punctuation: #&#123;$mdn-theme-dark-code-token-punctuation&#125;;\n  --code-token-attribute-name: #&#123;$mdn-theme-dark-code-token-attribute-name&#125;;\n  --code-token-attribute-value: #&#123;$mdn-theme-dark-code-token-attribute-value&#125;;\n  --code-token-comment: #&#123;$mdn-theme-dark-code-token-comment&#125;;\n  --code-token-default: #&#123;$mdn-theme-dark-code-token-default&#125;;\n  --code-token-selector: #&#123;$mdn-theme-dark-code-token-selector&#125;;\n  --code-background-inline: #&#123;$mdn-theme-dark-code-background-inline&#125;;\n  --code-background-block: #&#123;$mdn-theme-dark-code-background-block&#125;;\n\n  --notecard-link-color: #&#123;$mdn-color-neutral-10&#125;;\n\n  --scrollbar-bg: transparent;\n  --scrollbar-color: rgba(255, 255, 255, 0.25);\n\n  --category-color: #&#123;$mdn-color-dark-theme-blue-30&#125;;\n  --category-color-background: #&#123;$mdn-color-dark-theme-blue-30&#125;70;\n  --code-color: #&#123;$mdn-color-dark-theme-blue-20&#125;;\n  --mark-color: #&#123;$mdn-color-dark-theme-blue-70&#125;;\n\n  --plus-accent-color: #&#123;$mdn-color-dark-theme-red-30&#125;;\n  --html-accent-color: #&#123;$mdn-color-dark-theme-red-40&#125;;\n  --css-accent-color: #&#123;$mdn-color-dark-theme-blue-30&#125;;\n  --js-accent-color: #&#123;$mdn-color-dark-theme-yellow-40&#125;;\n  --http-accent-color: #&#123;$mdn-color-dark-theme-green-40&#125;;\n  --apis-accent-color: #&#123;$mdn-color-dark-theme-violet-40&#125;;\n  --learn-accent-color: #&#123;$mdn-color-dark-theme-pink-40&#125;;\n\n  --plus-code-color: #&#123;$mdn-color-dark-theme-blue-20&#125;;\n  --html-code-color: #&#123;$mdn-color-neutral-light-70&#125;;\n  --css-code-color: #&#123;$mdn-color-dark-theme-blue-20&#125;;\n  --js-code-color: #&#123;$mdn-color-dark-theme-yellow-30&#125;;\n  --http-code-color: #&#123;$mdn-color-dark-theme-green-30&#125;;\n  --apis-code-color: #&#123;$mdn-color-dark-theme-violet-30&#125;;\n  --learn-code-color: #&#123;$mdn-color-dark-theme-pink-30&#125;;\n\n  --plus-mark-color: #&#123;$mdn-color-dark-theme-red-70&#125;;\n  --html-mark-color: #&#123;$mdn-color-dark-theme-red-70&#125;;\n  --css-mark-color: #&#123;$mdn-color-dark-theme-blue-70&#125;;\n  --js-mark-color: #&#123;$mdn-color-dark-theme-yellow-70&#125;;\n  --http-mark-color: #&#123;$mdn-color-dark-theme-green-70&#125;;\n  --apis-mark-color: #&#123;$mdn-color-dark-theme-violet-70&#125;;\n  --learn-mark-color: #&#123;$mdn-color-dark-theme-pink-70&#125;;\n\n  --plus-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;\n  --html-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;\n  --css-accent-background-color: #&#123;$mdn-color-light-theme-blue-50&#125;30;\n  --js-accent-background-color: #&#123;$mdn-color-light-theme-yellow-50&#125;30;\n  --http-accent-background-color: #&#123;$mdn-color-light-theme-green-50&#125;30;\n  --apis-accent-background-color: #&#123;$mdn-color-light-theme-violet-50&#125;30;\n  --learn-accent-background-color: #&#123;$mdn-color-light-theme-pink-50&#125;30;\n\n  --plus-accent-engage: #&#123;color.adjust(\n      $mdn-color-dark-theme-red-40,\n      $alpha: -0.3\n    )&#125;;\n  --html-accent-engage: #&#123;color.adjust(\n      $mdn-color-dark-theme-red-40,\n      $alpha: -0.3\n    )&#125;;\n  --css-accent-engage: #&#123;color.adjust(\n      $mdn-color-dark-theme-blue-30,\n      $alpha: -0.3\n    )&#125;;\n  --js-accent-engage: #&#123;color.adjust(\n      $mdn-color-dark-theme-yellow-40,\n      $alpha: -0.3\n    )&#125;;\n  --http-accent-engage: #&#123;color.adjust(\n      $mdn-color-dark-theme-green-40,\n      $alpha: -0.3\n    )&#125;;\n  --apis-accent-engage: #&#123;color.adjust(\n      $mdn-color-dark-theme-violet-40,\n      $alpha: -0.3\n    )&#125;;\n  --learn-accent-engage: #&#123;color.adjust(\n      $mdn-color-dark-theme-pink-40,\n      $alpha: -0.3\n    )&#125;;\n\n  --modal-backdrop-color: #&#123;rgba($mdn-theme-dark-background-primary, 0.7)&#125;;\n  --blend-color: #&#123;$mdn-color-black&#125;80;\n\n  --text-primary-red: #&#123;$mdn-color-dark-theme-red-30&#125;;\n  --text-primary-green: #&#123;$mdn-color-dark-theme-green-30&#125;;\n  --text-primary-blue: #&#123;$mdn-color-dark-theme-blue-30&#125;;\n  --text-primary-yellow: #&#123;$mdn-color-dark-theme-yellow-30&#125;;\n  color-scheme: dark;\n&#125;\n\nbody,\n:root &#123;\n  --mdn-color-white: #&#123;$mdn-color-white&#125;;\n  --mdn-color-black: #&#123;$mdn-color-black&#125;;\n  --mdn-color-dark-grey: #&#123;$mdn-color-neutral-70&#125;;\n  --mdn-background-dark: #&#123;$mdn-theme-dark-background-primary&#125;;\n  --mdn-background-light: #&#123;$mdn-theme-light-background-primary&#125;;\n  --mdn-background-light-grey: #&#123;$mdn-color-neutral-10&#125;;\n  --color-announcement-banner-accent: #&#123;$mdn-color-light-theme-pink-40&#125;;\n&#125;\n\n.light &#123;\n  @include light-theme;\n&#125;\n\n.dark &#123;\n  @include dark-theme;\n&#125;\n&#x2F;* 默认主题 *&#x2F;\n&#x2F;&#x2F; OS Default.\n:root:not(.light):not(.dark) &#123;\n  @media (prefers-color-scheme: light) &#123;\n    @include light-theme;\n  &#125;\n\n  @media (prefers-color-scheme: dark) &#123;\n    @include dark-theme;\n  &#125;\n&#125;\n\n..&#x2F;vars.scss@use &quot;.&#x2F;color-palette&quot; as *;\n\n$mdn-color-neutral-light-70: #f9f9fb;\n$mdn-color-neutral-light-80: #f2f1f1;\n$mdn-color-neutral-light-90: #ebeaea;\n\n$mdn-color-neutral-10: #e2e2e2;\n$mdn-color-neutral-20: #cdcdcd;\n$mdn-color-neutral-30: #b3b3b3;\n$mdn-color-neutral-40: #9e9e9e;\n$mdn-color-neutral-50: #858585;\n$mdn-color-neutral-60: #696969;\n$mdn-color-neutral-70: #4e4e4e;\n$mdn-color-neutral-80: #343434;\n$mdn-color-neutral-90: #1b1b1b;\n\n$mdn-color-light-theme-blue: #0085f2;\n$mdn-color-light-theme-green: #009a46;\n$mdn-color-light-theme-yellow: #928700;\n$mdn-color-light-theme-red: #d30038;\n$mdn-color-light-theme-violet: #9b65ff;\n$mdn-color-light-theme-pink: #d00058;\n\n$mdn-color-dark-theme-blue: $mdn-color-light-theme-blue;\n$mdn-color-dark-theme-green: $mdn-color-light-theme-green;\n$mdn-color-dark-theme-yellow: $mdn-color-light-theme-yellow;\n$mdn-color-dark-theme-red: $mdn-color-light-theme-red;\n$mdn-color-dark-theme-violet: $mdn-color-light-theme-violet;\n$mdn-color-dark-theme-pink: $mdn-color-light-theme-pink;\n\n$mdn-color-light-theme-blue-10: #dce2f2;\n$mdn-color-light-theme-blue-20: #c1cff1;\n$mdn-color-light-theme-blue-30: #8cb4ff;\n$mdn-color-light-theme-blue-40: #5e9eff;\n$mdn-color-light-theme-blue-50: #0085f2;\n$mdn-color-light-theme-blue-60: #0069c2;\n$mdn-color-light-theme-blue-70: #004d92;\n$mdn-color-light-theme-blue-80: #003465;\n$mdn-color-light-theme-blue-90: #001b3a;\n\n$mdn-color-dark-theme-blue-10: $mdn-color-light-theme-blue-10;\n$mdn-color-dark-theme-blue-20: $mdn-color-light-theme-blue-20;\n$mdn-color-dark-theme-blue-30: $mdn-color-light-theme-blue-30;\n$mdn-color-dark-theme-blue-40: $mdn-color-light-theme-blue-40;\n$mdn-color-dark-theme-blue-50: $mdn-color-light-theme-blue-50;\n$mdn-color-dark-theme-blue-60: $mdn-color-light-theme-blue-60;\n$mdn-color-dark-theme-blue-70: $mdn-color-light-theme-blue-70;\n$mdn-color-dark-theme-blue-80: $mdn-color-light-theme-blue-80;\n$mdn-color-dark-theme-blue-90: $mdn-color-light-theme-blue-90;\n\n$mdn-color-light-theme-green-10: #a9f3ba;\n$mdn-color-light-theme-green-20: #73e693;\n$mdn-color-light-theme-green-30: #00d061;\n$mdn-color-light-theme-green-40: #00b755;\n$mdn-color-light-theme-green-50: #009a46;\n$mdn-color-light-theme-green-60: #007936;\n$mdn-color-light-theme-green-70: #005a26;\n$mdn-color-light-theme-green-80: #003d18;\n$mdn-color-light-theme-green-90: #00210a;\n\n$mdn-color-dark-theme-green-10: $mdn-color-light-theme-green-10;\n$mdn-color-dark-theme-green-20: $mdn-color-light-theme-green-20;\n$mdn-color-dark-theme-green-30: $mdn-color-light-theme-green-30;\n$mdn-color-dark-theme-green-40: $mdn-color-light-theme-green-40;\n$mdn-color-dark-theme-green-50: $mdn-color-light-theme-green-50;\n$mdn-color-dark-theme-green-60: $mdn-color-light-theme-green-60;\n$mdn-color-dark-theme-green-70: $mdn-color-light-theme-green-70;\n$mdn-color-dark-theme-green-80: $mdn-color-light-theme-green-80;\n$mdn-color-dark-theme-green-90: $mdn-color-light-theme-green-90;\n\n$mdn-color-light-theme-yellow-10: #f0e498;\n$mdn-color-light-theme-yellow-20: #dfd172;\n$mdn-color-light-theme-yellow-30: #c7b700;\n$mdn-color-light-theme-yellow-40: #afa100;\n$mdn-color-light-theme-yellow-50: #938700;\n$mdn-color-light-theme-yellow-60: #746a00;\n$mdn-color-light-theme-yellow-70: #564e00;\n$mdn-color-light-theme-yellow-80: #3a3500;\n$mdn-color-light-theme-yellow-90: #1f1c00;\n\n$mdn-color-dark-theme-yellow-10: $mdn-color-light-theme-yellow-10;\n$mdn-color-dark-theme-yellow-20: $mdn-color-light-theme-yellow-20;\n$mdn-color-dark-theme-yellow-30: $mdn-color-light-theme-yellow-30;\n$mdn-color-dark-theme-yellow-40: $mdn-color-light-theme-yellow-40;\n$mdn-color-dark-theme-yellow-50: $mdn-color-light-theme-yellow-50;\n$mdn-color-dark-theme-yellow-60: $mdn-color-light-theme-yellow-60;\n$mdn-color-dark-theme-yellow-70: $mdn-color-light-theme-yellow-70;\n$mdn-color-dark-theme-yellow-80: $mdn-color-light-theme-yellow-80;\n$mdn-color-dark-theme-yellow-90: $mdn-color-light-theme-yellow-90;\n\n$mdn-color-light-theme-red-10: #ffd9dc;\n$mdn-color-light-theme-red-20: #ffc0c4;\n$mdn-color-light-theme-red-30: #ff97a0;\n$mdn-color-light-theme-red-40: #ff707f;\n$mdn-color-light-theme-red-50: #ff2a51;\n$mdn-color-light-theme-red-60: #d30038;\n$mdn-color-light-theme-red-70: #9e0027;\n$mdn-color-light-theme-red-80: #6f0019;\n$mdn-color-light-theme-red-90: #40000a;\n\n$mdn-color-dark-theme-red-10: $mdn-color-light-theme-red-10;\n$mdn-color-dark-theme-red-20: $mdn-color-light-theme-red-20;\n$mdn-color-dark-theme-red-30: $mdn-color-light-theme-red-30;\n$mdn-color-dark-theme-red-40: $mdn-color-light-theme-red-40;\n$mdn-color-dark-theme-red-50: $mdn-color-light-theme-red-50;\n$mdn-color-dark-theme-red-60: $mdn-color-light-theme-red-60;\n$mdn-color-dark-theme-red-70: $mdn-color-light-theme-red-70;\n$mdn-color-dark-theme-red-80: $mdn-color-light-theme-red-80;\n$mdn-color-dark-theme-red-90: $mdn-color-light-theme-red-90;\n\n$mdn-color-light-theme-violet-10: #e6deff;\n$mdn-color-light-theme-violet-20: #d4c5ff;\n$mdn-color-light-theme-violet-30: #bea5ff;\n$mdn-color-light-theme-violet-40: #ae8aff;\n$mdn-color-light-theme-violet-50: #9b65ff;\n$mdn-color-light-theme-violet-60: #872bff;\n$mdn-color-light-theme-violet-70: #6800cf;\n$mdn-color-light-theme-violet-80: #480091;\n$mdn-color-light-theme-violet-90: #280056;\n\n$mdn-color-dark-theme-violet-10: $mdn-color-light-theme-violet-10;\n$mdn-color-dark-theme-violet-20: $mdn-color-light-theme-violet-20;\n$mdn-color-dark-theme-violet-30: $mdn-color-light-theme-violet-30;\n$mdn-color-dark-theme-violet-40: $mdn-color-light-theme-violet-40;\n$mdn-color-dark-theme-violet-50: $mdn-color-light-theme-violet-50;\n$mdn-color-dark-theme-violet-60: $mdn-color-light-theme-violet-60;\n$mdn-color-dark-theme-violet-70: $mdn-color-light-theme-violet-70;\n$mdn-color-dark-theme-violet-80: $mdn-color-light-theme-violet-80;\n$mdn-color-dark-theme-violet-90: $mdn-color-light-theme-violet-90;\n\n$mdn-color-light-theme-pink-10: #ffd9df;\n$mdn-color-light-theme-pink-20: #ffbbc8;\n$mdn-color-light-theme-pink-30: #ff93aa;\n$mdn-color-light-theme-pink-40: #ff6d91;\n$mdn-color-light-theme-pink-50: #ff1f72;\n$mdn-color-light-theme-pink-60: #d00058;\n$mdn-color-light-theme-pink-70: #9e0041;\n$mdn-color-light-theme-pink-80: #6d002b;\n$mdn-color-light-theme-pink-90: #3f0015;\n\n$mdn-color-dark-theme-pink-10: $mdn-color-light-theme-pink-10;\n$mdn-color-dark-theme-pink-20: $mdn-color-light-theme-pink-20;\n$mdn-color-dark-theme-pink-30: $mdn-color-light-theme-pink-30;\n$mdn-color-dark-theme-pink-40: $mdn-color-light-theme-pink-40;\n$mdn-color-dark-theme-pink-50: $mdn-color-light-theme-pink-50;\n$mdn-color-dark-theme-pink-60: $mdn-color-light-theme-pink-60;\n$mdn-color-dark-theme-pink-70: $mdn-color-light-theme-pink-70;\n$mdn-color-dark-theme-pink-80: $mdn-color-light-theme-pink-80;\n$mdn-color-dark-theme-pink-90: $mdn-color-light-theme-pink-90;\n\n$mdn-color-black: #000;\n$mdn-color-white: #fff;\n\n$mdn-theme-light-text-primary: $mdn-color-neutral-90;\n$mdn-theme-light-text-secondary: $mdn-color-neutral-70;\n$mdn-theme-light-text-inactive: #&#123;$mdn-color-neutral-40&#125;a6;\n$mdn-theme-light-text-link: $mdn-color-light-theme-blue-60;\n$mdn-theme-light-text-invert: $mdn-color-white;\n$mdn-theme-light-background-primary: $mdn-color-white;\n$mdn-theme-light-background-secondary: $mdn-color-neutral-light-70;\n$mdn-theme-light-background-tertiary: $mdn-color-white;\n$mdn-theme-light-background-toc-active: $mdn-color-neutral-light-90;\n$mdn-theme-light-border-primary: $mdn-color-neutral-20;\n$mdn-theme-light-border-secondary: $mdn-color-neutral-20;\n$mdn-theme-light-button-primary-default: $mdn-color-neutral-90;\n$mdn-theme-light-button-primary-hover: $mdn-color-neutral-60;\n$mdn-theme-light-button-primary-active: $mdn-color-neutral-40;\n$mdn-theme-light-button-primary-inactive: $mdn-color-neutral-90;\n$mdn-theme-light-button-secondary-default: $mdn-color-white;\n$mdn-theme-light-button-secondary-hover: $mdn-color-neutral-20;\n$mdn-theme-light-button-secondary-active: $mdn-color-neutral-20;\n$mdn-theme-light-button-secondary-inactive: $mdn-color-neutral-light-70;\n$mdn-theme-light-button-secondary-border-focus: $mdn-color-light-theme-blue-50;\n$mdn-theme-light-button-secondary-border-red: $mdn-color-light-theme-red-30;\n$mdn-theme-light-button-secondary-border-red-focus: $mdn-color-light-theme-red-10;\n$mdn-theme-light-icon-primary: $mdn-color-neutral-60;\n$mdn-theme-light-icon-secondary: $mdn-color-neutral-30;\n$mdn-theme-light-icon-information: $mdn-color-light-theme-blue-50;\n$mdn-theme-light-icon-warning: $mdn-color-light-theme-red-50;\n$mdn-theme-light-icon-critical: $mdn-color-light-theme-red-60;\n$mdn-theme-light-icon-success: $mdn-color-light-theme-green-60;\n$mdn-theme-light-accent-primary: $mdn-color-light-theme-blue-50;\n$mdn-theme-light-accent-secondary: $mdn-color-light-theme-blue-50;\n$mdn-theme-light-field-focus-border: $mdn-color-light-theme-blue-50;\n$mdn-theme-light-focus-01: 0 0 0 3px rgba(0, 144, 237, 0.4);\n$mdn-theme-light-shadow-01: 0 1px 2px rgba(43, 42, 51, 0.05);\n$mdn-theme-light-shadow-02: 0 1px 6px rgba(43, 42, 51, 0.1);\n\n$mdn-theme-light-code-token-tag: $mdn-color-light-theme-blue-60;\n$mdn-theme-light-code-token-punctuation: $mdn-color-neutral-50;\n$mdn-theme-light-code-token-attribute-name: $mdn-color-light-theme-red-60;\n$mdn-theme-light-code-token-attribute-value: $mdn-color-light-theme-green-60;\n$mdn-theme-light-code-token-comment: $mdn-color-neutral-50;\n$mdn-theme-light-code-token-default: $mdn-color-neutral-90;\n$mdn-theme-light-code-token-selector: $mdn-color-light-theme-violet-60;\n$mdn-theme-light-code-background-inline: $mdn-color-neutral-light-80;\n$mdn-theme-light-code-background-block: $mdn-color-neutral-light-80;\n\n$mdn-theme-dark-text-primary: $mdn-color-white;\n$mdn-theme-dark-text-secondary: $mdn-color-neutral-20;\n$mdn-theme-dark-text-inactive: #&#123;$mdn-color-neutral-20&#125;a6;\n$mdn-theme-dark-text-link: $mdn-color-dark-theme-blue-30;\n$mdn-theme-dark-text-invert: $mdn-color-neutral-90;\n$mdn-theme-dark-background-primary: $mdn-color-neutral-90;\n$mdn-theme-dark-background-secondary: $mdn-color-neutral-80;\n$mdn-theme-dark-background-tertiary: $mdn-color-neutral-70;\n$mdn-theme-dark-background-toc-active: $mdn-color-neutral-80;\n$mdn-theme-dark-border-primary: $mdn-color-neutral-50;\n$mdn-theme-dark-border-secondary: $mdn-color-neutral-60;\n$mdn-theme-dark-button-primary-default: $mdn-color-white;\n$mdn-theme-dark-button-primary-hover: $mdn-color-neutral-20;\n$mdn-theme-dark-button-primary-active: $mdn-color-neutral-40;\n$mdn-theme-dark-button-primary-inactive: $mdn-color-white;\n$mdn-theme-dark-button-secondary-default: $mdn-color-neutral-70;\n$mdn-theme-dark-button-secondary-hover: $mdn-color-neutral-50;\n$mdn-theme-dark-button-secondary-active: $mdn-color-neutral-40;\n$mdn-theme-dark-button-secondary-inactive: $mdn-color-neutral-70;\n$mdn-theme-dark-shadow-01: 0 1px 2px rgba(251, 251, 254, 0.2);\n$mdn-theme-dark-shadow-02: 0 1px 6px rgba(251, 251, 254, 0.2);\n$mdn-theme-dark-icon-primary: $mdn-color-white;\n$mdn-theme-dark-icon-secondary: $mdn-color-neutral-30;\n$mdn-theme-dark-icon-information: $mdn-color-dark-theme-blue-40;\n$mdn-theme-dark-icon-warning: $mdn-color-dark-theme-yellow-40;\n$mdn-theme-dark-icon-critical: $mdn-color-dark-theme-red-40;\n$mdn-theme-dark-icon-success: $mdn-color-dark-theme-green-40;\n$mdn-theme-dark-accent-primary: $mdn-color-dark-theme-blue-40;\n$mdn-theme-dark-accent-secondary: $mdn-color-dark-theme-blue-40;\n$mdn-theme-dark-field-focus-border: $mdn-color-white;\n$mdn-theme-dark-focus-01: 0 0 0 3px rgba(251, 251, 254, 0.5);\n\n$mdn-theme-dark-code-token-tag: $mdn-color-dark-theme-blue-20;\n$mdn-theme-dark-code-token-punctuation: $mdn-color-neutral-30;\n$mdn-theme-dark-code-token-attribute-name: $mdn-color-dark-theme-red-30;\n$mdn-theme-dark-code-token-attribute-value: $mdn-color-dark-theme-green-30;\n$mdn-theme-dark-code-token-comment: $mdn-color-neutral-30;\n$mdn-theme-dark-code-token-default: $mdn-color-white;\n$mdn-theme-dark-code-token-selector: $mdn-color-dark-theme-violet-30;\n$mdn-theme-dark-code-background-inline: $mdn-color-neutral-80;\n$mdn-theme-dark-code-background-block: $mdn-color-neutral-80;\n\n$screen-sm: 426px;\n$screen-md: 769px;\n$screen-lg: 992px;\n$screen-xl: 1200px;\n$screen-xxl: 1441px;\n\n&#x2F;*\n * z-index scale\n *&#x2F;\n$send-to-back: -1;\n$bring-to-front: 9999;\n$bottom-layer: 100;\n$middle-layer: 200;\n$top-layer: 300;\n\n知乎 theme 实现方案通过\n&lt;!--   data-theme&#x3D;&quot;light --&gt;\n&lt;html\n  lang&#x3D;&quot;zh&quot;\n  data-hairline&#x3D;&quot;true&quot;\n  data-theme&#x3D;&quot;light&quot;\n  data-rh&#x3D;&quot;data-theme&quot;\n  style&#x3D;&quot;&quot;\n&gt;&lt;&#x2F;html&gt;\n\nThe simplest CSS variable dark mode theme\n","slug":"2022-10-26theme","date":"2022-10-26T07:58:01.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"f806b0ce6fb2f43b93c3ab8035d48439","title":"知乎网站找到面试题","content":"爬取脚本Array.from(document.getElementsByTagName(&quot;h3&quot;)).forEach((item) &#x3D;&gt; &#123;\n  document.body.append(item.innerText + &quot;\\n&quot;);\n&#125;);\n\n1.🌟 介绍 js 的基本数据类型。2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？3. 什么是堆？什么是栈？它们之间有什么区别和联系？4.🌟 内部属性 [[Class]] 是什么？\n值等于 加上 toStringTag 属性\nNull()和 Undefined()这样的原生构造函数并不存在,但是内部[[class]]属性值仍然是&quot;Null&quot;和&quot;Undefined&quot;.\n\n&#x2F;&#x2F; 方式1\nclass myClass &#123;\n  get [Symbol.toStringTag]() &#123;\n    return &quot;myClass1&quot;;\n  &#125;\n&#125;\nObject.prototype.toString.call(new myClass()); &#x2F;&#x2F; &quot;[object myClass1]&quot;\n\n&#x2F;&#x2F; 方式2\nconst obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, Symbol.toStringTag, &#123; value: &quot;CustomObject&quot; &#125;); &#x2F;&#x2F; &quot;[object CustomObject]&quot;\n\n见\n5. 介绍 js 有哪些内置对象？undeclared&#x2F;undefined&#x2F;null6.🌟 undefined 与 undeclared 的区别？\n已在作用域中声明但还没有赋值的变量，是 undefined 的。\n还没有在作用域中声明过的变量，是 undeclared 的。\n\n7.🌟 null 和 undefined 的区别？- 基本数据类型 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 &#96;undefined&#96; 和 &#96;null&#96;\n- 含义不同\n- undefined 不是保留字\n- typeof null 为“object”\n- null 计算中被转化成 &#96;0&#96;, undefined 被转化成 &#96;NaN&#96;\n- undefined 是一个标识符,undefined 是全局对象的一个属性\n\n8. 如何获取安全的 undefined 值？因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。\nundefined 是全局对象的一个属性\n表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。\n按惯例我们用 void 0 来获得 undefined。\n9. 说几条写 JavaScript 的基本规范？原型&#x2F;原型链10.🌟 JavaScript 原型，原型链？ 有什么特点？11. js 获取原型的方法？数值12. 在 js 中不同进制数字的表示方式13. js 中整数的安全范围是多少？14. typeof NaN 的结果是什么？15.🌟 isNaN 和 Number.isNaN 函数的区别？\n函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也可能会返回 true ，会影响 NaN 的判断。\n\n函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确\n\n\n16. Array 构造函数只有一个参数值时的表现？补充var a &#x3D; Array(); &#x2F;&#x2F; []\nvar b &#x3D; Array(1); &#x2F;&#x2F; [empty]\nb &#x3D;&#x3D; a; &#x2F;&#x2F; false\na[0] &#x3D;&#x3D; b[0]; &#x2F;&#x2F; true\n\nempty 是个什么东西？ empty 是个什么东西？\n数据转换规则17. 其他值到字符串的转换规则？ ToString前端基础 - 抽象相等比较\n补充Infinity.toString(); &#x2F;&#x2F; &quot;Infinity&quot;\nNaN.toString(); &#x2F;&#x2F; &quot;NaN&quot;\n\n基本数据类型使用 Object.prototype.toString()基本数据类型全部返回 [object Object]\n18. 其他值到数字值的转换规则？ ToNumber前端基础 - 抽象相等比较\n19. 其他值到布尔类型的值的转换规则？ ToBoolean前端基础 - 抽象相等比较\n20. {} 和 [] 的 valueOf 和 toString 的结果是什么？前端基础 - 抽象相等比较\n&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;\n\n21.🌟 什么是假值对象？前端基础 - 抽象相等比较\n充当效仿 undefined 的角色\n22. ~ 操作符的作用？23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？\n解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。\n而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN\n\n24. + 操作符什么时候用于字符串的拼接？根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。\n前端基础 - 抽象相等比较\n25. 什么情况下会发生布尔值的隐式强制类型转换？26. || 和 &amp;&amp; 操作符的返回值？27. Symbol 值的强制类型转换？28. &#x3D;&#x3D; 操作符的强制类型转换规则？29. 如何将字符串转化为数字，例如 ‘12.3b’?（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。\n（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。\n（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。\n（4）使用 + 操作符的隐式转换。 结果NaN\n30.🌟 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?见\n&#x2F;\\B(?&#x3D;(\\d&#123;3&#125;)+(?!\\d))&#x2F;g;\n&#x2F;&#x2F; \\B非单词边界\n&#x2F;&#x2F; ?&#x3D; 先行断言   后面是  --\n&#x2F;&#x2F; ?! 后行断言， 后面不是 --\n\n31. 常用正则表达式32. 生成随机数的各种方法？33. 如何实现数组的随机排序？34. javascript 创建对象的几种方式？35. JavaScript 继承的几种实现方式？36. 寄生式组合继承的实现？37.🌟 Javascript 的作用域链？作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n作用域链的本质：上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。\n作用域链的前端:始终都是当前执行上下文的变量对象。\n作用域链的最后一个对象: 始终是全局执行上下文的变量对象（也就是全局对象)。\n\n当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。\n作用域链的创建过程跟执行上下文的建立有关….\n38.🌟 谈谈 This 对象的理解。this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n\n构造函数调用\n显示绑定调用 apply、call、bind\n属性方法调用\n函数调用，严格模式 undefined,非严格模式指向 window\n\n39. eval 是做什么的？DOM 事件40. 什么是 DOM 和 BOM？41. 写一个通用的事件侦听器函数。42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？43. 🌟 三种事件模型是什么？事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。\n\n第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。\n\n第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\n\n第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，\n\n第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。\n后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n\n\nDOM2 级事件执行过程\n\n绑定在被点击元素的事件是按照代码顺序发生。\n其他元素通过冒泡或者捕获“感知”的事件。\n按照 W3C 的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 。\n\n44. 事件委托是什么？45. [“1”, “2”, “3”].map(parseInt) 答案是多少？46. 🌟 什么是闭包，为什么要用它？闭包: 是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n闭包有两个常用的用途。\n闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。\n设立”严格模式”的目的，主要有以下几个：\n\n消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;\n消除代码运行的一些不安全之处，保证代码运行的安全；\n提高编译器效率，增加运行速度；\n为未来新版本的 Javascript 做好铺垫\n\n48. 如何判断一个对象是否属于某个类？\n第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\n第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。\n\n第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。\n\n\n49.🌟 instanceof 的作用？instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置\n50.🌟 new 操作符具体干了什么呢？如何实现？（1）首先创建了一个新的空对象（2）设置原型，将对象的原型设置为函数的 prototype 对象。（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？hasOwnProperty\n所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。\n52. 对于 JSON 的了解？JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。\n在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。\n因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 _JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等_，因此大多数的 js 对象是不符合 JSON 对象的格式的。\n在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。\n另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。\n53. [].forEach.call($$(“”),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？54. js 延迟加载的方式有哪些？js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。\n几种方式：\n\n第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n\n第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n\n第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n\n第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n\n\n55.🌟 Ajax 是什么? 如何创建一个 Ajax？缓存56. 谈一谈浏览器的缓存机制？57. Ajax 解决浏览器缓存问题？1.在 XMLHttpRequest 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。\n2.在 XMLHttpRequest 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。\n3.在 URL 后面加上一个随机数： &quot;fresh&#x3D;&quot; + Math.random();。\n4.在 URL 后面加上时间戳：&quot;nowtime&#x3D;&quot; + new Date().getTime();。\n5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup(&#123;cache:false&#125;)。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。\n\n\n58. 同步和异步的区别？安全59. 什么是浏览器的同源策略？浏览器的同源策略的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。\n同源政策主要限制了三个方面\n\n第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。\n\n第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。\n\n第三个是当前域下 ajax 无法发送跨域请求。\n\n\n同源政策的目的: 主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。\n60.🌟 如何解决跨域问题？解决跨域的方法我们可以根据我们想要实现的目的来划分。\n如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。\n（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。\n如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。\n（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。\n（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。\n（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。\n如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。\n（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。\n（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。\n非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。\n（7）使用 websocket 协议，这个协议没有同源限制。\n（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。\n61. 服务器代理转发时，该如何处理 cookie？62. 简单谈一下 cookie ？\n我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。\n\n服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条 cookie 包括了 5 个属性值 expires、domain、path、secure、HttpOnly。\n\n其中 expires 指定了 cookie 失效的时间\ndomain 是域名、path 是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。\nsecure 规定了 cookie 只能在确保安全的情况下传输，\nHttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。\n\n\n在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。\n\n\n模块加载63. 模块化开发怎么做？64. js 的几种模块规范？js 中现在比较成熟的有四种模块加载方案。\n第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式 加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适\n第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。\n第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。\n第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。\n65. AMD 和 CMD 规范的区别？66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。\n68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。\n在 class 中添加的方法，其实是添加在类的原型上的。\n70. documen.write 和 innerHTML 的区别？document.write 的内容会代替整个文档内容，会重写整个页面。\ninnerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。\n71.🌟 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？&#x2F;&#x2F; (1）创建新节点\ncreateDocumentFragment(node);\ncreateElement(node);\ncreateTextNode(text);\n&#x2F;&#x2F; （2）添加、移除、替换、插入\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n&#x2F;&#x2F; （3）查找\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n&#x2F;&#x2F; （4）属性操作\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);\n\n72. innerHTML 与 outerHTML 的区别？&#x2F;&#x2F; 对于这样一个 HTML 元素：&lt;div&gt;content&lt;br&#x2F;&gt;&lt;&#x2F;div&gt;。\n\n&#x2F;&#x2F; innerHTML：内部 HTML，content&lt;br&#x2F;&gt;；\n&#x2F;&#x2F; outerHTML：外部 HTML，&lt;div&gt;content&lt;br&#x2F;&gt;&lt;&#x2F;div&gt;；\n&#x2F;&#x2F; innerText：内部文本，content ；\n&#x2F;&#x2F; outerText：内部文本，content ；\n\n73. .call() 和 .apply() 的区别？它们的作用一模一样，区别仅在于传入参数的形式的不同。\napply 接受两个参数 ,第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\ncall 传入的参数数量不固定 ,跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。\n74. 🌟JavaScript 类数组对象的定义？一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法\n常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。\n&#x2F;&#x2F; 常见的类数组转换为数组的方法有这样几种：\n\n&#x2F;&#x2F; （1）通过 call 调用数组的 slice 方法来实现转换\nArray.prototype.slice.call(arrayLike);\n\n&#x2F;&#x2F; （2）通过 call 调用数组的 splice 方法来实现转换\nArray.prototype.splice.call(arrayLike, 0);\n\n&#x2F;&#x2F; （3）通过 apply 调用数组的 concat 方法来实现转换\nArray.prototype.concat.apply([], arrayLike);\n\n&#x2F;&#x2F; （4）通过 Array.from 方法来实现转换\nArray.from(arrayLike);\n\n75.🌟 数组和对象有哪些原生方法，列举一下？76. 数组的 fill 方法？77.🌟 [,,,] 的长度？长度为 3\n尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。\nJavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。\n如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。\n78.🌟 JavaScript 中的作用域与变量声明提升？变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。\n造成变量声明提升的本质原因:是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。\n79. 如何编写高性能的 Javascript ？\n避免使用过深的嵌套循环。\n当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找\n循环能提前终止，要提前终止\n对象&#x2F;map 可以代替数组遍历\n\n80. 简单介绍一下 V8 引擎的垃圾回收机制81. 哪些操作会造成内存泄漏？82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？按照 HTML5 标准中的 HTML 语法规则，如果在 &lt;/body&gt;后再出现&lt;script&gt;或任何元素的开始标签，都是 parse error，浏览器会忽略之前的&lt;/body&gt;，即视作仍旧在 body 内。\n所以实际效果和写在&lt;/body&gt;之前是没有区别的。总之，这种写法虽然也能 work，但是并没有带来任何额外好处，实际上出现这样的写法很可能是误解了“将 script 放在页面最末端”的教条。所以还是不要这样写为好。\n作者：贺师俊链接：https://www.zhihu.com/question/20027966/answer/13727164来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n85. 移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？86. 什么是“前端路由”？ 什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？87. 如何测试前端代码么？知道 BDD, TDD, Unit Test 么？知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？88. 检测浏览器版本版本有哪些方式？检测浏览器版本一共有两种方式：\n_一种是检测 window.navigator.userAgent 的值_，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。\n_第二种方式是功能检测_，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。\n89. 什么是 Polyfill ？Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。\n90. 使用 JS 实现获取文件扩展名？&#x2F;&#x2F; String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。\n\n&#x2F;&#x2F; 对于 &#39;filename&#39; 和 &#39;.hiddenfile&#39; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。\n\n&#x2F;&#x2F; String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。\n\nfunction getFileExtension(filename) &#123;\n  return filename.slice(((filename.lastIndexOf(&quot;.&quot;) - 1) &gt;&gt;&gt; 0) + 2);\n&#125;\n\n91. 介绍一下 js 的节流与防抖？92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？两等号判等，会在比较时进行类型转换。三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回 false）。\nObject.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.\nObject.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。\n93. escape,encodeURI,encodeURIComponent 有什么区别？encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。\nencodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。\nescape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。\n94. Unicode 和 UTF-8 之间的关系？utf8优点\n\nUTF-8 编码可以通过屏蔽位和移位操作快速读写。\n字符串比较时 strcmp()和 wcscmp()的返回结果相同，因此使排序变得更加容易。\n字节 FF 和 FE 在 UTF-8 编码中永远不会出现，因此他们可以用来区分 UTF-16 或 UTF-32 文本。\nUTF-8 是字节顺序无关的。它的字节顺序在所有系统中都是一样的，因此它实际上并不需要 BOM。 [1]\n同时兼容 ASCII 编码\n\n缺点你无法从 UNICODE 字符数判断出 UTF-8 文本的字节数，因为 UTF-8 采用的是不定长的编码方式。\n百度百科 UTF-8\n95. js 的事件循环是什么？96. js 中的深浅拷贝实现？浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。\n深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。\n97. 手写 call、apply 及 bind 函数98. 函数柯里化的实现99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？100. 原码、反码和补码的介绍 101. toPrecision 和 toFixed 和 Math.round 的区别？102. 什么是 XSS 攻击？如何防范 XSS 攻击？注意点 SQL 注入不属于 XSS 攻击原因：SQL 注入，执行是在服务端执行，XSS 攻击是在客户端执行\n103. 什么是 CSP？104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？105. 什么是 Samesite Cookie 属性？106. 什么是点击劫持？如何防范点击劫持？107. SQL 注入攻击？108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？109. vue 双向数据绑定原理？110. Object.defineProperty 介绍？111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？113. 如何比较两个 DOM 树的差异？114. 什么是 requestAnimationFrame ？115. 谈谈你对 webpack 的看法 116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？117. 谈一谈你理解的函数式编程？118. 异步编程的实现方式？119. Js 动画与 CSS 动画区别及相应实现120. get 请求传参长度的误区121. URL 和 URI 的区别？122. get 和 post 请求在缓存方面的区别123. 图片的懒加载和预加载124. mouseover 和 mouseenter 的区别？区别\nmouseenter: 当鼠标指针从它后代的物理空间移动到它自己的物理空间时，它不会冒泡，也不会发送给它的任何后代\nmouseover: 可能会存在性能问题。层次结构很深，发送到 mouseover 事件可能相当多，并导致严重的性能问题。在这种情况下，最好是监听 mouseenter 事件。\nmouseleave（当鼠标退出其内容区域时向元素触发），mouseenter 事件的作用与 CSS 伪类 :hover 非常相似\n\n对应关系\nmouseenter&#x2F;mouseleave\nmouseover&#x2F;mouseout 冒泡\n\nMDN mouseenter_event\n125. js 拖拽功能的实现126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？本质setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。\n现象所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。\n解决方案针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。\n127. let 和 const 的注意点？128. 什么是 rest 参数？129. 什么是尾调用，使用尾调用有什么好处？是什么尾调用指的是函数的最后一步调用另一个函数。\n本质我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。\n使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。\n注意点但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n130. Symbol 类型的注意点？\nSymbol 函数前不能使用 new 命令，否则会报错。\nSymbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\nSymbol 作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。\nObject.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\nSymbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。\nSymbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。\n获取 Symbol 括号内的值(description)，用 Symbol.prototype.description\n\n131. Set 和 WeakSet 结构？\nWeakSet 弱引用，假设，除了 WeakSet 之外没有其他的引用，那么垃圾回收机制，可能被回收\n\n132. Map 和 WeakMap 结构？Map 与 Object 的区别\nObject 本质上是哈希结构的键值对的集合，它只能用字符串、数字或者 Symbol 等简单数据类型\nMap 类继承了 Object，并对 Object 功能做了一些拓展，Map 的键可以是任意的数据类型。\nMap 技高一筹,他的 key 既可以是基本数据类型，也可以是引用数据类型\nMap 实现了迭代器，可用 for…of 遍历，而 Object 不行。\nMap 可以直接拿到长度，而 Object 不行。 填入 Map 的元素，会保持原有的顺序，而 Object\n\n这篇文章，“同名碰撞写的有问题”\nobj[key] &#x3D; value 实际上是\nfunction processingKey(key) &#123;\n  if (key &#x3D;&#x3D;&#x3D; undefined) &#123;\n    return &quot;undefined&quot;;\n  &#125; else if (key &#x3D;&#x3D;&#x3D; null) &#123;\n    return &quot;null&quot;;\n  &#125; else &#123;\n    return key.toString();\n  &#125;\n&#125;\nobj[processingKey(key)] &#x3D; value;\n\n[js 行为研究] 对象作为对象的键会发生什么？\n133. 什么是 Proxy ？&#x2F;#&#x2F;post&#x2F;2022-06-10js-数据劫持\n&#x2F;#&#x2F;post&#x2F;2022-07-04js 数据劫持\n134. Reflect 对象创建目的？问题： ES6 Proxy 里面为什么要用 Reflect？Proxy &amp; Reflect 的话题\n\nProxy 代理，它内置了一系列”陷阱“用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\nReflect 反射，它提供拦截 JavaScript 操作的方法。这些方法与 Proxy 的方法相同。\n\n简单来说，我们可以通过 Proxy 创建对于原始对象的代理对象，从而在代理对象中使用 - Reflect 达到对于 JavaScript 原始操作的拦截。\n\n\n作者：WangHaoyu链接：https://www.zhihu.com/question/460133198/answer/2416115070来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n为什么 Proxy &amp; Reflect 联合使用\n是为了和 Proxy 的 API 对应上，是为触发代理对象的劫持时保证正确的 this 上下文指向\nProxy 中 receiver 存在的意义就是为了正确的在陷阱中传递上下文\nReflect.get(target, key, receiver) 可理解成为 target[key].call(receiver)\n\n135. require 模块引入的查找方式？当 Node 遇到 require(X) 时，按下面的顺序处理。\n（1）如果 X 是内置模块（比如 require(‘http’)）　　 a. 返回该模块。　　 b. 不再继续执行。\n（2）如果 X 以 “.&#x2F;“ 或者 “&#x2F;“ 或者 “..&#x2F;“ 开头　　 a. 根据 X 所在的父模块，确定 X 的绝对路径。　　 b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。\n&#x2F;&#x2F; X\n&#x2F;&#x2F; X.js\n&#x2F;&#x2F; X.json\n&#x2F;&#x2F; X.node\nc. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。\n&#x2F;&#x2F; X&#x2F;package.json（main 字段）\n&#x2F;&#x2F; X&#x2F;index.js\n&#x2F;&#x2F; X&#x2F;index.json\n&#x2F;&#x2F; X&#x2F;index.node\n\n（3）如果 X 不带路径　　 a. 根据 X 所在的父模块，确定 X 可能的安装目录。　　 b. 依次在每个目录中，将 X 当成文件名或目录名加载。\n（4）抛出 “not found”\n136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises&#x2F;A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。\nPromise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。\n状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。\n137. 手写一个 Promiseconst PENDING &#x3D; &quot;pending&quot;;\nconst RESOLVED &#x3D; &quot;resolved&quot;;\nconst REJECTED &#x3D; &quot;rejected&quot;;\n\nfunction MyPromise(fn) &#123;\n  &#x2F;&#x2F; 保存初始化状态\n  var self &#x3D; this;\n\n  &#x2F;&#x2F; 初始化状态\n  this.state &#x3D; PENDING;\n\n  &#x2F;&#x2F; 用于保存 resolve 或者 rejected 传入的值\n  this.value &#x3D; null;\n\n  &#x2F;&#x2F; 用于保存 resolve 的回调函数\n  this.resolvedCallbacks &#x3D; [];\n\n  &#x2F;&#x2F; 用于保存 reject 的回调函数\n  this.rejectedCallbacks &#x3D; [];\n\n  &#x2F;&#x2F; 状态转变为 resolved 方法\n  function resolve(value) &#123;\n    &#x2F;&#x2F; 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变\n    if (value instanceof MyPromise) &#123;\n      return value.then(resolve, reject);\n    &#125;\n\n    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 只有状态为 pending 时才能转变，\n      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;\n        &#x2F;&#x2F; 修改状态\n        self.state &#x3D; RESOLVED;\n\n        &#x2F;&#x2F; 设置传入的值\n        self.value &#x3D; value;\n\n        &#x2F;&#x2F; 执行回调函数\n        self.resolvedCallbacks.forEach((callback) &#x3D;&gt; &#123;\n          callback(value);\n        &#125;);\n      &#125;\n    &#125;, 0);\n  &#125;\n\n  &#x2F;&#x2F; 状态转变为 rejected 方法\n  function reject(value) &#123;\n    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 只有状态为 pending 时才能转变\n      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;\n        &#x2F;&#x2F; 修改状态\n        self.state &#x3D; REJECTED;\n\n        &#x2F;&#x2F; 设置传入的值\n        self.value &#x3D; value;\n\n        &#x2F;&#x2F; 执行回调函数\n        self.rejectedCallbacks.forEach((callback) &#x3D;&gt; &#123;\n          callback(value);\n        &#125;);\n      &#125;\n    &#125;, 0);\n  &#125;\n\n  &#x2F;&#x2F; 将两个方法传入函数执行\n  try &#123;\n    fn(resolve, reject);\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; 遇到错误时，捕获错误，执行 reject 函数\n    reject(e);\n  &#125;\n&#125;\n\nMyPromise.prototype.then &#x3D; function (onResolved, onRejected) &#123;\n  &#x2F;&#x2F; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数\n  onResolved &#x3D;\n    typeof onResolved &#x3D;&#x3D;&#x3D; &quot;function&quot;\n      ? onResolved\n      : function (value) &#123;\n          return value;\n        &#125;;\n\n  onRejected &#x3D;\n    typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot;\n      ? onRejected\n      : function (error) &#123;\n          throw error;\n        &#125;;\n\n  &#x2F;&#x2F; 如果是等待状态，则将函数加入对应列表中\n  if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;\n    this.resolvedCallbacks.push(onResolved);\n    this.rejectedCallbacks.push(onRejected);\n  &#125;\n\n  &#x2F;&#x2F; 如果状态已经凝固，则直接执行对应状态的函数\n\n  if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;\n    onResolved(this.value);\n  &#125;\n\n  if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;\n    onRejected(this.value);\n  &#125;\n&#125;;\n\n138. 如何检测浏览器所支持的最小字体大小？function isSupportFontSize(size) &#123;\n  &#x2F;&#x2F; 创建dom，设置字体大小，挂在dom,获取字体\n  let pdom &#x3D; document.createElement(&quot;p&quot;);\n  pdom.style.fontSize &#x3D; size + &quot;px&quot;;\n\n  document.body.append(pdom);\n\n  function getstyle(obj, key) &#123;\n    if (obj.currentStyle) &#123;\n      return obj.currentStyle[key];\n    &#125; else &#123;\n      return getComputedStyle(obj, false)[key];\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 验证是否一致\n  return parseFloat(getstyle(pdom, &quot;fontSize&quot;)) &#x3D;&#x3D; size;\n&#125;\n\nisSupportFontSize(10);\n\n139. 怎么做 JS 代码 Error 统计？error 统计使用浏览器的 window.error 事件。\n140. 单例模式模式是什么？单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。\n141. 策略模式是什么？策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。主要在 MVP 模式解耦的时候用来将视图层的方法定义和方法调用分离。\n142. 代理模式是什么？代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。\n143. 中介者模式是什么？中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦\n144. 适配器模式是什么？适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。\n145. 观察者模式和发布订阅模式有什么不同？发布订阅模式其实属于广义上的观察者模式\n\n在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。\n\n而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。\n\n\n146. Vue 的生命周期是什么？147. Vue 的各个生命阶段是什么？148. Vue 组件间的参数传递方式？149. computed 和 watch 的差异？150. vue-router 中的导航钩子函数151. $route 和 $router 的区别？152. vue 常用的修饰符？153. vue 中 key 值的作用？154. computed 和 watch 区别？155. keep-alive 组件有什么作用？156. vue 中 mixin 和 mixins 区别？157. 开发中常用的几种 Content-Type ？158. 如何封装一个 javascript 的类型判断函数？159. 如何判断一个对象是否为空对象？160. 使用闭包实现每隔一秒打印 1,2,3,4161. 手写一个 jsonp162. 手写一个观察者模式？163. EventEmitter 实现164. 一道常被人轻视的前端 JS 面试题165. 如何确定页面的可用性时间，什么是 Performance API？166. js 中的命名规则167. js 语句末尾分号是否可以省略？168. Object.assign()169. Math.ceil 和 Math.floor170. js for 循环注意点171. 一个列表，假设有 100000 个数据，这个该怎么办？172. js 中倒计时的纠偏实现？173. 进程间通信的方式？174. 如何查找一篇英文文章中出现频率最高的单词？其他JS 为什么不能直接赋值 undefined ？JS 为什么不能直接赋值 undefined ？\n低级浏览器可以被改写，不安全\n进制表示\n十六进制 hexadecimal 0x\n八进制 octal 0O\n二进制 binary 0b\n十进制 decimal\n\n见\nCommonJS,AMD,CMD 全称全称\nAMD 规范:全称Asynchronous Module Definition，称为 异步模块加载规范 。一般应用在浏览器端。流行的浏览器端异步加载库 RequireJS 实现的就是 AMD 规范。\n\nCMD 规范，全称Common Module Definition，称为 通用模块加载规范。一般也是用在浏览器端。浏览器端异步加载库 Sea.js 实现的就是 CMD 规范。\n\nCommonJS: 称为同步模块加载规范，也就是说，只有加载完成，才能执行后面的操作。\n\n\nAMD 特点: 依赖前置，提前执行!CMD 特点: 依赖就近，延迟执行!\nCMD 与 AMD 区别对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。CMD 推崇依赖就近，AMD 推崇依赖前置。\nnodejs 为什么使用 commonjs 规范因为 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式。但如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范\n作者：一点代码链接：https://www.jianshu.com/p/65ab05d3cdeb来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nclass 是 prototype 的语法糖？\n两者如何增加属性？\n两者如何实现继承？\n既然是语法糖，那么父类是 class，子类是 prototype 能否继承？\n既然是语法糖，这个糖如何实现的？\nprototype 如何实现 class 的 static\n\n是不是属于自身属性\n实例.hasOwnProperty(属性) 查看该属性是否来自本身。\nObject.getOwnPropertyNames(obj) 返回所有对象本身属性名数组，无论是否能枚举\n属性 in 对象 判断能否通过该对象访问该属性，无论是在本身还是原型上\n\n获取一个对象的 prototype\nObject.getPrototypeOf(obj) 方法，他返回对象的 prototype\nObject.setPrototypeOf(object, prototype) 方法，设置对象的 prototype\n还可以使用对象的__proto__属性获取和修改对象的 prototype（不推荐）\n\n作者：羽月链接：https://juejin.cn/post/6844903788642484237来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n见\n为什么 JavaScript 最大安全整数是 2^53-1这个 53 是怎么得到的？\nIEEE 754 规定了四种表示浮点数值的方式：\n单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）。\nNumber 类型使用的便是其中的双精确度（64 位）。\n\n\n\n\n\n位置\n位数\n作用\n表示\n\n\n\n0-51\n52\n尾数位\n原码表示\n\n\n52-62\n11\n指数位\n移码表示\n\n\n63\n1\n符号位\n0,1\n\n\n因为： 此时就不安全了;\n2 ** 53 &#x3D;&#x3D;&#x3D; 2 ** 53 + 1; &#x2F;&#x2F;true\n\n在 2^53-1 之后的数中，只要指数相同，并且尾数前 52 位相同，则这个两个数数值相同。\n为什么 JavaScript 最大安全整数是 2^53-1\n, 没你想象的那么简单对它的每个操作数求值（从左到右），并返回最后一个操作数的值。\nlet x &#x3D; 1;\n\nx &#x3D; (x++, x);\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 2\n\nx &#x3D; (2, 3);\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 3\n\n这也太难了吧\n参考链接170 道 JavaScript 面试题及知识点总结（上）170 道 JavaScript 面试题及知识点总结（下）\n","slug":"2022-10-24zhihu","date":"2022-10-24T13:38:58.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"0ad1ddce4e48037c2d0625fb3e573482","title":"可视化埋点","content":"参考链接从 0 到 1 搭建可视化埋点平台\n","slug":"2022-10-24可视化埋点","date":"2022-10-24T13:00:52.000Z","categories_index":"前端基建","tags_index":"前端基建","author_index":"举手摘月亮"},{"id":"81556a3598a3ddc6cbb980694cccc8db","title":"前端基础-css q&a","content":"1. 获取 CDNS 的 文章标题var list &#x3D; document.getElementsByClassName(&#39;column_article_list&#39;)[0].children;\nArray.from(list).forEach((item) &#x3D;&gt; &#123;\n  var text &#x3D; item.children[0].children[0].children[0].innerText;\n  document.body.append(text + &#39;\\n&#39;);\n&#125;);\n\n1. css 的:root、var()以及:root、html、* 选择器优先级见\n1.1. :root代表文档的根元素，在:root 中声明的属性是全局属性，都可以通过 var()引用\n1.2. var( )var(属性名) 可以代替元素任何属性中的任何值\n:root&#123;\n    --normal-color: pink;\n&#125;\n.bg&#123;\n    background-color: var(--normal-color);\n&#125;\n————————————————\n版权声明：本文为CSDN博主「liun_n」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39706777&#x2F;article&#x2F;details&#x2F;120025610\n\n1.3. var( )回退值没有声明–active-color，则回退到 blue\n:root &#123;\n  --normal-color: pink;\n&#125;\n.bg &#123;\n  background-color: var(—active-color, blue);\n&#125;\n\n1.4. 优先级:root &gt; html &gt; * 选择器优先级\n2. 移动端总结缩放适配rem 适配vw 适配移动端点击 300ms高版本 chrome 和 iOS 已经修复是否引入 faskclick.js\nChrome 32 对移动端进行了优化，可以不禁用缩放，也能解决延迟的问题。接着 Firefox 和 IE&#x2F;Edge 紧随其后也修复了这个 BUG，最后，就是 iOS 9.3 也同样修复这个 BUG\n在移动端，为了避免点击延迟，通常使用 fastclick 库来处理点击事件。fastclick 库的原理是，在移动端浏览器上，当用户触摸屏幕时，浏览器会等待一小段时间，以确定用户是要双击缩放还是单击操作。如果浏览器检测到用户只是单击操作，则会触发 click 事件。这个等待的时间通常是 300 毫秒，即所谓的“点击延迟”。\nfastclick 库的解决方法是，\n\n监听 touchstart 事件，并在触发事件后立即触发 click 事件，从而避免延迟。\n此外，fastclick 还会在 touchstart 和 touchend 事件中，阻止事件的默认行为和冒泡行为，以避免事件被触发多次或被其他元素捕获。\n这样，可以确保 click 事件只被触发一次，并且在正确的元素上触发。\n\n为什么是 300ms在移动设备早期，普遍采用的是双击缩放（Double Tap to Zoom）的交互方式，因此浏览器需要等待用户是否要执行双击缩放操作，如果用户只是单击屏幕，浏览器才会将其识别为 click 事件。在此期间，浏览器会将用户的单击事件缓存，等待一段时间，如果在这段时间内没有再次触发事件，就会将该事件作为 click 事件触发。因此，浏览器要等待一定时间才能确定是否要触发单击事件，这个时间大概为 300ms，所以这个时间间隔也被称为“300ms 延迟”。\n后来，由于双击缩放已经不再普遍使用，许多移动设备都取消了 300ms 延迟，但是一些设备上仍然存在，为了兼容这些设备，一些库，比如 FastClick，仍然需要处理 300ms 延迟。\n移动端 300ms 延迟及 fastClick 原理解析\n\n**原理：**\n\n移动端，当用户点击屏幕时，会依次触发 touchstart，touchmove(0 次或多次)，touchend，mousemove，mousedown，mouseup，click。\ntouchmove: 只有当手指在屏幕发生移动的时候才会触发 touchmove 事件。\n\n在 touchstart, touchmove 或者 touchend 事件中的任意一个调用 event.preventDefault，mouse 事件 以及 click 事件将不会触发。\n\nfastClick 在 touchend 阶段 调用 event.preventDefault，然后通过 document.createEvent 创建一个 MouseEvents，然后 通过 event​Target​.dispatch​Event 触发对应目标元素上绑定的 click 事件。 -->\n\n点击穿透点击穿透原理及解决\n原理：在这 300ms 以内，因为上层元素隐藏或消失了，由于 click 事件的滞后性，同样位置的 DOM 元素触发了 click 事件（如果是 input 则触发了 focus 事件）。在代码中，给我们的感觉就是 target 发生了飘移。\n1、禁止页面缩放 部分浏览器不再需要等待 300ms2、300+ms3、阻止默认事件。4、引入 faskclick.js： 原理：touch 事件先于 mouse 事件先于 click 执行，因此可以在 document.body 上绑定事件用于监听点触行为，根据需要模拟 click 触发真正需要响应的元素\n3. 学习 css 文本溢出显示省略号？单行多行&#x2F;* 单行 *&#x2F;\nwidth: 100px;\ndisplay: inline-block;\n\n&#x2F;* 设置文本不进行换行 *&#x2F;\nwhite-space: nowrap;\n&#x2F;* 超出部分使用省略号 *&#x2F;\ntext-overflow: ellipsis;\n&#x2F;* 让超出部分省略 *&#x2F;\noverflow: hidden;\n\n&#x2F;* 多行 *&#x2F;\nwidth: 100px;\noverflow: hidden;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 3;\n\n&#x2F;* 注意：必要时候，需要设置 *&#x2F;\n\n两栏布局？\n4. translate &#x2F; position？\ntranslate 是什么，position 是什么\n\ntranslate 和 position 是 CSS 中用于控制元素位置的两个属性，它们有不同的作用和用法。\ntranslate 属性可以用来移动元素的位置，但它不会影响元素的文档流位置，也就是说，元素的位置移动后不会影响其他元素的位置。translate 属性可以接受三个参数，分别是 translateX()、translateY() 和 translateZ()，可以分别用来控制元素在水平、竖直和深度方向上的移动。\n例如，以下代码会将元素向右移动 50 像素：\ndiv &#123;\n  transform: translateX(50px);\n&#125;\n\n相反，position 属性是用来确定元素在文档流中的位置。元素的 position 属性可以设置为 static、relative、absolute 或 fixed。其中 relative 表示元素相对于自己原来的位置进行定位，而 absolute 则表示元素相对于它的父元素或者祖先元素进行定位。fixed 则是相对于浏览器窗口进行定位。\n例如，以下代码将元素设置为绝对定位，并将其左上角放置在距离父元素顶部和左侧各 50 像素的位置：\ndiv &#123;\n  position: absolute;\n  top: 50px;\n  left: 50px;\n&#125;\n\n总之，translate 和 position 属性都可以用来控制元素的位置，但它们的作用和用法是不同的。translate 属性用于移动元素的位置，而不影响文档流位置；而 position 属性则用于确定元素在文档流中的位置。\nCSS3 中 translate &#x2F; position 有什么区别除了上述区别外，translate 和 position 还有以下不同之处：\n\ntranslate 属性不会影响元素的盒模型，而 position 属性会影响元素的盒模型。\n\ntranslate 属性可以使用 CSS 过渡和动画效果，以实现元素位置的平滑过渡；而 position 属性则不适用于过渡和动画。\n\ntranslate 属性可以和其他 CSS 变换属性一起使用，例如旋转、缩放等；而 position 属性则不支持与其他变换属性一起使用。\n\ntranslate 属性的性能通常比 position 属性更好，特别是在移动大量元素时，因为 translate 属性的硬件加速更有效。\n\n\n综上所述，虽然 translate 和 position 属性都可以用于控制元素的位置，但它们的作用和用法是不同的，而且它们还有其他不同之处，需要根据具体情况选择合适的属性来实现元素的位置控制。\n5. 你对媒体查询的理解？是什么\n媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定 CSS 样式，\n媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。\n媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。\n使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。\n\n\n\n如何使用&lt;!-- 这个不属于css级别的 --&gt;\n&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&quot; &#x2F;&gt;\n\n&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;m320.css&quot; media&#x3D;&quot;only screen and (max-width:320px)&quot; &#x2F;&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;m480.css&quot; media&#x3D;&quot;only screen and (min-width:321px) and (max-width:375px)&quot; &#x2F;&gt;\n\n&#x2F;*媒体查询*&#x2F;\n&#x2F;*当页面大于1200px 时，大屏幕，主要是PC 端*&#x2F;\n@media (min-width: 1200px) &#123;\n&#125;\n&#x2F;*在992 和1199 像素之间的屏幕里，中等屏幕，分辨率低的PC*&#x2F;\n@media (min-width: 992px) and (max-width: 1199px) &#123;\n&#125;\n&#x2F;*在768 和991 像素之间的屏幕里，小屏幕，主要是PAD*&#x2F;\n@media (min-width: 768px) and (max-width: 991px) &#123;\n&#125;\n&#x2F;*在480 和767 像素之间的屏幕里，超小屏幕，主要是手机*&#x2F;\n@media (min-width: 480px) and (max-width: 767px) &#123;\n&#125;\n&#x2F;*在小于480 像素的屏幕，微小屏幕，更低分辨率的手机*&#x2F;\n@media (max-width: 479px) &#123;\n&#125;\n\nCSS 语法@media mediatype and (expression) &#123;\n  &#x2F;* CSS rules here *&#x2F;\n&#125;\n\n其中，mediatype 表示媒体类型，可以是 all（所有媒体设备）、print（打印设备）、screen（计算机屏幕）等；expression 表示媒体特性，可以是设备的宽度、高度、分辨率、方向等。\n6. 你对 css sprites 的理解，好处是什么使用工具(ps 之类的)将多张图片打包成一张雪碧图，并为其生成何时的 css。每张图片都有相应的 css 类，该类定义了\nbackground-image,\nbackground-position,\nbackground-size 属性。\n\n使用图片时，将相应的类添加到你的元素中去即可。\n7. 有哪些⽅式（CSS）可以隐藏⻚⾯元素？\n不占据空间 overflow:hidden, display: none, z-index: -999\n占据空间，不可操作的 visibility: hidden, transform: scale(0,0)\n占据空间，可以操作的 opacity:0\n\n8. link 和@import 的区别？一、link 和@import 的区别？1.1、所属不同 link 属于 html 标签，而@import 是 css 提供的。1.2、加载 页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面被加载完再加载的。1.3、兼容性问题：@import 只在 IE5 以上才能识别，而 link 是 html 标签，无兼容性问题。1.4、权重问题: link。的权重要高于 @import1.5、DOM 操作: DOM 可以操作 link 中的样式，而不可以操作@import 中的样式。————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/124225973\n简单了解 CSS3 的 all 属性\n9. margin 和 padding 分别适合什么场景使用？margin 是用来隔开元素与元素之间的间距，padding 是用来隔开元素和内容的间距。margin 用来布局分开元素使得元素互不相干。padding 用于元素和内容之间的间隔，让内容与包裹元素之间存在一段距离。\n何时使用 margin2.1、需要在 border 外侧田间空白时。2.2、空白处不需要背景色时。2.3、上下相连的两个盒子之间的空白，需要相互抵消时。如 15px+20px 的 margin，将得到 20px 的空白。\n何时使用 padding3.1、需要在 border 内测添加空白时。3.2、空白处需要背景（色）时。3.3、上下相连的两个盒子之间的空白，希望等于两者之和时。如 15px+20px 的 padding，将得到 35px 的空白。————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/124192349\n10. 浏览器是怎样解析 CSS 选择器的？当浏览器解析 HTML 文档时，如果遇到一个 CSS 样式表（CSS stylesheet）的引用，它就会根据这个样式表的内容来渲染页面。\n在解析 CSS 样式表时，浏览器需要分析样式表中的选择器和声明（declarations），并根据这些规则来对页面元素进行渲染。\n浏览器解析 CSS 选择器的过程如下：\n\n选择器解析：浏览器首先需要解析选择器（selector），确定该规则应用于哪些元素。选择器可以是标签名、类名、ID、属性等。\n\n匹配元素：浏览器根据选择器匹配页面中的元素。匹配过程是从右到左进行的，也就是先匹配最右边的选择器，再逐渐向左匹配。例如，对于选择器 p &gt; a:hover，浏览器首先会找到所有 a 元素，然后再筛选出它们的父元素是 p 的那些元素。\n\n继承样式：如果一个元素没有定义某个样式，那么它会继承它的父元素的样式，直到找到一个明确的样式定义。\n\n层叠样式：如果多个样式规则都适用于同一个元素，那么浏览器会根据 CSS 层叠样式的规则来决定哪个样式优先级更高，以此来确定最终应用的样式。\n\n渲染元素：根据匹配的元素和样式定义，浏览器开始渲染页面。它会根据元素的盒模型（box model）计算出每个元素在页面中的位置和大小，并将样式应用到元素上。\n\n\n以上就是浏览器解析 CSS 选择器的基本流程。不过需要注意的是，浏览器在解析 CSS 样式表时会进行优化，以提高性能和渲染速度。例如，浏览器会将选择器解析成一棵选择器树（Selector Tree），并根据需要进行缓存和重用。\n\n\n11. 请解释一下为什么需要清除浮动？浮动（float）是一种常用的 CSS 布局技术，它可以让元素“浮”起来，脱离文档流并向左或向右对齐。浮动元素在页面布局中具有一定的灵活性，可以实现一些复杂的布局效果。但是，浮动元素也会带来一些问题，其中最常见的问题就是浮动元素高度坍塌（clearfix）。\n原因\n当一个元素浮动之后，它不再占据正常文档流中的位置，因此其他元素就会忽略它的位置，可能会出现覆盖、重叠等问题。\n此外，浮动元素可能会导致其父元素的高度坍塌，导致布局混乱。\n\n为了解决这些问题，我们需要对浮动元素进行清除。清除浮动的目的是让父元素包含浮动元素，以避免出现高度坍塌等问题。\n常见的清除浮动的方法包括：\n使用空的块级元素清除浮动。这种方法比较简单，只需要在浮动元素的父元素最后添加一个空的块级元素，并为其设置 clear: both。\n\n使用 overflow 属性清除浮动。将父元素的 overflow 属性设置为 hidden、auto 或 scroll，可以使其包含浮动元素。\n\n使用 clearfix 技巧清除浮动。这种方法是添加一个伪元素（::after）作为最后一个浮动元素的兄弟元素，然后为伪元素设置 clear: both。\n\n使用 CSS 网格布局或弹性布局等现代布局技术，可以更好地解决浮动元素带来的问题，避免使用清除浮动的方法。\n\n\n需要注意的是，清除浮动的方法也可能会带来一些问题，如增加不必要的代码量、影响性能等，因此应该根据具体情况选择合适的方法来清除浮动。\n使用空的块级元素清除浮动使用空的块级元素清除浮动的代码如下所示：\nHTML:\n&lt;div class&#x3D;&quot;parent&quot;&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;clearfix&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\nCSS:\n.clearfix &#123;\n  clear: both;\n&#125;\n\n.float-left &#123;\n  float: left;\n&#125;\n\n在上面的代码中，我们为包含浮动元素的父元素添加了一个空的 div 元素，并为其设置了 clear:both，这样就可以清除浮动了。同时，我们将浮动元素的 float 属性设置为 left，使其向左浮动。\n需要注意的是，使用空的块级元素清除浮动的方式，在页面中增加了无意义的 HTML 元素，可能会对页面性能产生一定的影响，因此在实际开发中，建议使用其他方式清除浮动。\n使用 overflow 属性清除浮动使用 overflow 属性清除浮动的代码如下所示：\nHTML:\n&lt;div class&#x3D;&quot;parent&quot;&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\nCSS:\n.parent &#123;\n  overflow: hidden;\n&#125;\n\n.float-left &#123;\n  float: left;\n&#125;\n\n在上面的代码中，我们将包含浮动元素的父元素的 overflow 属性设置为 hidden，这样就可以清除浮动了。同时，我们将浮动元素的 float 属性设置为 left，使其向左浮动。最后，我们在父元素的最后添加一个空的 div 元素，并为其设置 clear:both，以防止父元素不包含任何内容时出现高度为 0 的问题。\n需要注意的是，使用 overflow 属性清除浮动的方式，会影响父元素的滚动行为。如果父元素的内容溢出，它将被剪切并隐藏，除非添加了滚动条。因此，在使用这种方法时，需要注意父元素的样式和布局。\n使用 clearfix 技巧清除浮动使用 clearfix 技巧清除浮动的代码如下所示：\nHTML:\n&lt;div class&#x3D;&quot;clearfix&quot;&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;float-left&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\nCSS:\n.clearfix::after &#123;\n  content: &#39;&#39;;\n  display: block;\n  clear: both;\n&#125;\n\n.float-left &#123;\n  float: left;\n&#125;\n\n在上面的代码中，我们为包含浮动元素的父元素添加了一个 clearfix 类，然后为该类添加了一个伪元素(::after)，并为其设置了 clear: both，这样就可以清除浮动了。同时，我们将浮动元素的 float 属性设置为 left，使其向左浮动。\n需要注意的是，使用 clearfix 技巧清除浮动的方式，比较简洁和方便，不会影响父元素的滚动行为，因此在实际开发中被广泛使用。\n替代方案 flex&#x2F;grid 布局13. css 块级元素，行内元素和行内块级元素 css 三栏布局总结块级元素\n1、它独占一行。2、它的宽高可以设置。3、默认时，宽度是 100%\n&lt;div&gt;，&lt;h1-h6&gt;,&lt;ul&gt;,&lt;ol&gt;,li等\n行内元素\n1、它的宽度有内容决定，高度有内容字体大小决定。2、它不可以设置宽高。3、它可以和其他行内元素位于同一行。\n&lt;span&gt;,&lt;label&gt;,&lt;i&gt;,&lt;e&gt;\n行内跨级元素\n1、它既可以和其他的行内元素位于同一行。2、元素的高度及与边的间距都可以设置。\n&lt;input&gt;，&lt;img&gt;,&lt;select&gt;等。\n14. 如何理解 margin 重叠问题？？？？\n什么是 margin 重叠\n具体表现为\n为什么会出现\n解决方案\n\nCSS 中的 margin 重叠问题，指的是在两个或多个相邻的块级元素之间，它们的 margin 值会发生重叠现象，导致最终的 margin 值不是预期的值，而是取两者中的较大值。这种现象被称为 margin 重叠。\nmargin 重叠问题的具体表现有以下几种情况：\n\n相邻的两个元素的 margin-top 和 margin-bottom 重叠。\n父元素的 margin-top 和第一个子元素的 margin-top 重叠。\n父元素的 margin-bottom 和最后一个子元素的 margin-bottom 重叠。\n\n理解 margin 重叠问题的原因可以归结为 CSS 规范中对 margin 计算的定义：如果两个相邻元素的 margin 值都是正数或都是负数，则它们的 margin 会发生重叠，取两者中的较大值作为它们之间的 margin 值。\n为了避免 margin 重叠问题，可以采用以下几种方式：\n\n将相邻的元素的 margin 值设置为负值，避免 margin 值重叠。\n为相邻的元素添加 border、padding 或 inline 元素，避免 margin 值重叠。\n为父元素添加 overflow:hidden 或 display:inline-block 属性，避免父元素与子元素的 margin 值重叠。\n为父元素添加 padding 或 border 属性，避免父元素与第一个子元素或最后一个子元素的 margin 值重叠。\n\n需要注意的是，margin 重叠问题只会发生在垂直方向上，不会在水平方向上发生。\n\n\nBFCBlock formatting contexts，译为块级格式化上下文，它是指块级元素所在的一个环境\nclearance闭合浮动的元素会在其 margin-top 以上产生一定的空隙，该空隙会阻止元素 margin-top 的折叠，并作为间距存在于元素的 margin-top 的上方。\n‘display‘、‘position‘和‘float‘的相互关系？\n15. 简单介绍使用图片 base64 编码的优点和缺点？一、写在前面base64 编码是一种图片处理格式，通过特定的算法将图片编码成一个长串字符串，在页面上显示的时候，可以用该字符串来代替图片的 url 属性。\n二、使用 base64 的优点是：\n1、减少一个图片的 http 请求。\n三、使用 base64 的缺点是：\n1、体积问题 根据 base64 的编码原理，编码后的大小会比原文件大 1&#x2F;3,如果把大图片编码到 html&#x2F;css 中，不仅会造成文件体积增加，影响文件的加载速度，还会增加浏览器对 html 或 css 文件解析渲染的时间。2、缓存问题 使用 base64 无法直接缓存，要缓存只能缓存包含 base64 的文件，比如 HTML 或者 CSS，这相比于直接缓存图片的效果要差很多。3、兼容性的问题 ，ie8 以前的浏览器不支持。一般一些网站的小图标可以使用 base64 图片来引入。————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/124042418\n15. 使用图片 base64 编码的优点和缺点 chatGPT使用图片 base64 编码的优点：\n\n减少 HTTP 请求次数，加快网页加载速度。在不需要缓存的情况下，减少了服务器的负担和带宽压力。\n适合小图标和简单的图片，可以减小图片大小，节省了图片的加载时间。\n适合作为 CSS 背景图片或小图片，使用方便，不需要单独请求图片资源。\n可以防止图片被盗用，因为使用 base64 编码后，图片无法直接下载保存到本地。\n\n使用图片 base64 编码的缺点：\n\n图片文件大小会变大。由于 base64 编码后，每个字符代表的是 6 个二进制位，因此会将原本的二进制数据转化为更多的字符，导致文件大小增加。\n编码后的文件不能进行缓存。如果同一张图片在多个页面中使用，每次都需要重新加载，影响页面加载速度。\n编码后的文件无法进行修改，每次修改都需要重新编码。\n可能会影响图片质量。编码后的字符串会将原本的二进制数据转换为 ASCII 字符，这种转换可能会导致部分像素的精度损失，从而影响图片质量。\n\n16. 绝对定位元素与非绝对定位元素的百分比计算的区别？\n\n绝对定位元素与非绝对定位元素的百分比计算的区别在于它们的计算基准不同。\n对于非绝对定位元素，它们的百分比计算是相对于其父元素的宽度来计算的。例如，如果一个元素设置了宽度为 50%，那么它的宽度将会是其父元素宽度的 50%。\n而对于绝对定位元素，它们的百分比计算是相对于最近的具有定位属性（position 为 relative、absolute、fixed）的父元素的宽度来计算的。如果最近的定位祖先元素不存在，则相对于最外层的容器宽度计算。如果最外层的容器宽度也未知，则相对于浏览器窗口宽度计算。\n这个区别可以带来一些有趣的效果，比如，一个相对定位的元素可以成为绝对定位元素的父级，使得后者的百分比计算基准改变。同时，如果一个元素既是绝对定位元素的父级，又需要进行百分比计算，可以将其设置为相对定位元素，以便进行百分比计算。\n17. width: 100%和 width: auto 有什么区别设置 children 元素 margin: 0 , 此时设置 width：100%和 width: auto 是没有什么区别的。\n如果设置 children 元素 margin: 0 30px 时\nwidth: auto 的元素宽度变化，宽度 &#x3D; 父元素宽度 - 左边 margin - 右边 margin， 并且向左偏移 30px。width: 100%的元素宽度不变， 位置向左偏移 30px；\n如果设置 children 元素 margin: 0 -30px 时\nwidth: auto 的元素宽度变化，宽度 &#x3D; 父元素宽度 - 左边 margin - 右边 margin，并且向左偏移 30px ，并且向左偏移-30px;width: 100%的元素宽度不变，位置向左偏移-30px；\n见\n17. width: 100%和 width: auto 有什么区别计算宽度的方式不同width: 100% 和 width: auto 都是用来设置元素的宽度的属性，它们的区别在于计算宽度的方式不同。\n\nwidth: 100%：元素的宽度会根据父元素的宽度来计算，宽度始终是父元素宽度的百分比。例如，如果一个元素设置了 width: 100%，那么它的宽度将始终等于其父元素的宽度。\nwidth: auto：元素的宽度会根据其内容的大小来计算，宽度会自动扩展以适应内容的大小。如果元素没有设置宽度，它将会默认使用 width: auto。\n\n需要注意的是，\n\n当一个元素使用了 width: auto 并且它的父元素也没有设置宽度时，元素的宽度将会被默认设置为它所包含内容的宽度。\n但是如果它的父元素设置了宽度，则元素的宽度将会根据其内容的大小自动调整，但不会超出其父元素的宽度。\n\n综上所述，width: 100% 和 width: auto 用来设置元素的宽度，计算宽度的方式不同，需要根据具体的需求来选择合适的属性。\n其他差异除了上述的区别，width: 100% 和 width: auto 还有一些其他的差异：\n\nwidth: 100%：宽度是相对于父元素的百分比计算，如果父元素的宽度改变，子元素的宽度也会相应地发生变化。\nwidth: auto：宽度是根据元素内容自适应计算的，如果父元素的宽度改变，子元素的宽度也不会受到影响，它只会根据内容自适应调整宽度。\n\n此外，width: auto 还有一个特点就是对于一些元素，如 &lt;img&gt;、&lt;video&gt; 等内联元素或替换元素，它们的宽度默认为元素本身的宽度，即自适应计算的宽度，所以不需要设置宽度。\n综上所述，选择使用 width: 100% 还是 width: auto 取决于具体的情况和需求。\n\n如果希望元素的宽度可以随着父元素的宽度变化而自适应调整，可以使用 width: 100%，\n如果希望元素的宽度根据内容自适应调整，可以使用 width: auto。\n\n这里有个有意思的点如果想对可替换元素设置最小宽度，又想再父元素变小的时候，能够随父元素动态变化不溢出，使用上述理论进行组合\nmin-width: 400px;\nwidth: 100%;\n\n18. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？visibility 属性三种值，\nvisible，没有任何变化。\nhidden：相当于 opacity: 0\ncollapse：有时候是 visibility：hidden， 有时候是 display:none\n对于一般元素来说 visibility：collapse 表现的样式和 hidden 一样，\n但是对于 table 相关的元素，比如 table group，table 列，table column group,他的表现却跟 display:none 一样，也就是说，他们占用的空间都会被释放掉。\n\n\n\n存在兼容性问题：在谷歌浏览器里，使用 collapse 值和使用 hidden 值没有什么区别。在火狐浏览器、Opera 和 IE11 里，使用 collapse 值的效果就如它的字面意思：table 的行会消失，它的下面一行会补充它的位置。\n————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/124037787\n19. 什么是包含块，对于包含块的理解？包含块（containing block）是 CSS 布局中的一个概念，用于确定元素的布局和定位。每个元素都有一个包含块，它是一个坐标系统，可以用来计算元素的位置和尺寸。\n\n对于绝对定位元素来说，包含块是离它最近的具有定位属性（position 属性的值为 absolute、relative、fixed 或 sticky）的祖先元素。如果没有这样的祖先元素，则包含块是初始包含块，即根元素。\n对于固定定位元素来说，包含块是根元素，因为它们不会受到滚动影响，相当于永远在屏幕上的固定位置。\n对于非定位元素来说，包含块是它的直接父元素。如果父元素没有定位属性，则该元素的包含块就是父元素的包含块，以此类推，一直到初始包含块为止。\n\n包含块在 CSS 中非常重要，因为它是元素布局和定位的关键因素之一。\n\n对于绝对定位元素，它们的位置和尺寸是相对于包含块计算的。\n对于相对定位元素，它们的位置也是相对于包含块计算的，但是它们不会改变包含块的大小和位置。\n对于固定定位元素，它们的位置也是相对于包含块计算的，但是它们不会受到包含块的滚动影响。\n\n是什么元素用来计算和定位的一个框\n分情况默认情况下包含块 就是离当前元素最近的块级祖先元素。对于开启绝对定位的元素来说 包含块是离它最近的开启了定位(且 position 不为 static)的祖先元素。如果所有的祖先元素都没有开启定位 则其包含块就是初始包含块（根元素）。\n20. 为什么要初始化 CSS 的样式为什么？因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 css 初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。\n初始化的目的，并不是去除边框，只是为了统一所有的浏览器，正常化\n淘宝初始化&#x2F;* \nbody,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend\n,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;\nbody,button,input,select,textarea&#123;font:12px&#x2F;1.5tahoma,arial,\\5b8b\\4f53;&#125;\nh1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;\naddress,cite,dfn,em,var&#123;font-style:normal;&#125;\ncode,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;\nsmall&#123;font-size:12px;&#125;\nul,ol&#123;list-style:none;&#125; &#x2F;&#x2F;常见\na&#123;text-decoration:none;&#125; &#x2F;&#x2F;常见\na:hover&#123;text-decoration:underline;&#125; &#x2F;&#x2F;常见\nsup&#123;vertical-align:text-top;&#125; &#x2F;&#x2F;常见\nsub&#123;vertical-align:text-bottom;&#125; &#x2F;&#x2F;常见\nlegend&#123;color:#000;&#125;\nfieldset,img&#123;border:0;&#125;\nbutton,input,select,textarea&#123;font-size:100%;&#125;\ntable&#123;border-collapse:collapse;border-spacing:0;&#125; \n*&#x2F;\n\n20. li 与 li 之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？原因\nli 与 li 之间存在看不见的空白间隔是因为 HTML 中代码格式换行、空格或 Tab 造成的，这些空白符会被浏览器解析为文本节点，并占据一定的宽度。\n解决办法：\n\n删除 li 标签之间的所有空白符。这种方法简单粗暴，但是会破坏代码的可读性和维护性，不推荐使用。\n\n将 li 标签的结束标记放在开始标记的下一行。这种方法可以避免空白间隔的问题，同时保持代码的可读性，但是在语义上可能不太合理。\n\n将 ul 或 ol 的 font-size 设置为 0，将 li 的 font-size 设置为需要的值。这种方法可以避免空白间隔问题，同时保持语义合理，但是可能需要调整 li 中其他元素的字体大小。\n\n将 li 的 display 属性设置为 inline-block。这种方法可以将 li 元素看做行内块级元素，避免了空白间隔问题，但是可能会影响到 li 元素的布局和样式。\n\n\n一般来说，推荐使用第三种方法，将父元素的字体大小设置为 0，然后在子元素中设置需要的字体大小，可以避免空白间隔问题，同时保持语义合理。\n21. 浏览器兼容性及其解决方案整理22. CSS 多列等高如何实现\ntable 布局实现等高\n使用 flex 布局\ngrid 布局\n\n.box &#123;\n  width: 300px;\n  display: grid;\n  grid-auto-flow: column;\n&#125;\n.left &#123;\n  background-color: red;\n&#125;\n.right &#123;\n  background-color: gainsboro;\n&#125;\n&#x2F;* ———————————————— 版权声明：本文为CSDN博主「卖菜的小白」的原创文章，遵循CC 4.0\nBY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47450807&#x2F;article&#x2F;details&#x2F;124012215 *&#x2F;\n\n23. 前端 css 高频面试题——em&#x2F;px&#x2F;rem&#x2F;vw&#x2F;vh 的区别？24. 一个品字布局如何设计？25. 用纯 CSS 创建一个三角形的原理是什么？\n\n\n\n\n\ndiv &#123;\n  &#x2F;* 宽高都设置为0 *&#x2F;\n  width: 0px;\n  height: 0px;\n  &#x2F;* border的宽度设置为30px *&#x2F;\n  border-width: 30px;\n  &#x2F;* border-style设置为实线 *&#x2F;\n  border-style: solid;\n  &#x2F;* border的上左右的颜色都设置为透明 *&#x2F;\n  border-color: red transparent transparent transparent;\n  &#x2F;* border-color: transparent red transparent transparent; *&#x2F;\n  &#x2F;* border-color: transparent transparent red transparent; *&#x2F;\n  &#x2F;* border-color: transparent transparent transparent red; *&#x2F;\n  &#x2F;* 加上这一行可以让三角形顶格， 不加三角形会下移20px *&#x2F;\n  &#x2F;* border-top: none; *&#x2F; &#x2F;* 因为border有顶部宽度 *&#x2F;\n&#125;\n\n见\n用纯 CSS 创建三角形通常采用 CSS 的 border 属性和 transform 属性。下面是两种常见的方法：\n方法一：使用 border 属性和 transform 属性\n通过设置元素的 border 属性，利用 CSS 的 transform 属性实现旋转，将一个正方形旋转 45 度，就可以得到一个等腰直角三角形。\n.triangle &#123;\n  width: 0;\n  height: 0;\n  border-top: 50px solid transparent;\n  border-right: 50px solid #333;\n  border-bottom: 50px solid transparent;\n  border-left: none;\n  transform: rotate(45deg);\n&#125;\n\n方法二：使用伪元素\n可以通过给元素添加伪元素，然后通过伪元素的 border 属性和 transform 属性实现三角形的效果。\n.triangle &#123;\n  position: relative;\n  width: 100px;\n  height: 100px;\n  background-color: #333;\n&#125;\n\n.triangle::before &#123;\n  content: &#39;&#39;;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-top: 50px solid transparent;\n  border-right: 50px solid #333;\n  border-bottom: 50px solid transparent;\n  border-left: none;\n  transform: rotate(45deg);\n&#125;\n\n以上两种方法都是利用 CSS 的 border 属性和 transform 属性来实现的，通过调整 border 的宽度和颜色，以及 transform 的角度和旋转中心，可以创建不同形状的三角形。\n26. CSS3 的 flex 布局总结？\n背景\n组成：容器+容器成员\n方向\n6 个属性\n缩写是什么意思\n\n一、简单介绍flex 是 flexibleBox 的缩写，意为弹性布局，用来为盒模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 flex 布局。\n注意，设为 flex 布局以后，子元素的 float，clear,vertical-align 属性将失效。\n采用 flex 布局的元素，称为 flex 容器，简称容器。他的所以子元素称为容器成员，称为 flex 元素，简称元素。容器默认存在两根轴：水平的主轴（main axis）和垂直的辅轴（cross axis），元素默认沿主轴排列。\n二、6 个属性\n1、flex-direction:属性决定主轴的方向（即元素的排列方向），默认是横轴方向。属性值为 row-reverse,row,col,col-reverse。2、flex-wrap:属性定义，如果一条轴线排列不下，如何换行。wrap:换行，no-wrap:不换行,wrap-reverse:翻转换行。3、flex-flow:属性是 flex-direction 和 flex-wrap 属性的简写形式，默认值为 row nowrap。4、justify-content: 6 个值，属性定义了元素在主轴的对齐方式。可选值为 flex-start,flex-end,center,space-around,space-between，stretch。5、align-items:4 个值，属性在辅线上如何对齐。存在的属性有：flex-end,flex-start,center,strech。6、align-content:属性定义多根轴线的对其方式，如果只存在一根轴线，则不起作用。存在的属性有：center，flex-end,flex-start,space-around,space-between,stretch。————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/123988959\n27. CSS 中的 position 的值及其作用？display 有哪些值？\n\nCSS 中的 position 属性用于指定一个元素在文档中的定位方式，其可选值及作用如下：\n\nstatic（默认值）：元素正常定位，即遵循文档流。\n\nrelative：相对定位，元素的位置相对于其在文档流中的初始位置来定位。通过 top、right、bottom、left 属性可以调整相对定位的位置。\n\nabsolute：绝对定位，元素的位置相对于其最近的非 static 定位祖先元素来定位。如果没有非 static 定位祖先元素，则相对于文档的 body 元素。通过 top、right、bottom、left 属性可以调整绝对定位的位置。\n\nfixed：固定定位，元素的位置相对于浏览器窗口固定不动。通过 top、right、bottom、left 属性可以调整固定定位的位置。\n\nsticky：粘性定位，元素在跨越特定阈值前为相对定位，之后为固定定位。通常配合 top、right、bottom、left 属性使用。\n\n\n需要注意的是，除了 static 定位以外，其他定位方式都可以通过 top、right、bottom、left 属性来控制元素的位置。\n\n\n\n\n\n\n\n\n\n元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级祖先，包括 table-related 元素，基于 top、right、bottom 和 left 的值进行偏移。\n偏移值不会影响任何其他元素的位置。\n该值总是创建一个新的层叠上下文（stacking context）。\n注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见 Github issue on W3C CSSWG\nMDN\ndisplaydisplay 属性值介绍：\n\nnone 此元素不会被显示。\n\nblock 此元素将显示为块级元素，此元素前后会带有换行符。\n\ninline 默认。此元素会被显示为内联元素，元素前后没有换行符。\n\ninline-block 行内块元素。（CSS2.1 新增的值）\n\nlist-item 此元素会作为列表显示。\n\nrun-in 此元素会根据上下文作为块级元素或内联元素显示。\n\ncompact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。\n\nmarker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。\n\ntable 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。\n\ninline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。\n\ntable-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。\n\ntable-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。\n\ntable-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。\n\ntable-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。\n\ntable-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。\n\ntable-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;）\n\ntable-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;）\n\ntable-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）\n\ninherit 规定应该从父元素继承 display 属性的值。\n\n\n见\n26. 如何居中 div\n使用 margin: 0 auto\nflex 布局\n绝对定位 + margin\n绝对定位 + transform\n\n27. CSS3 新增伪类有哪些28. CSS 优先级算法如何计算注意: 这里针对的是一条属性 (理解这个 “一条属性” )，当某一个属性，本身就比另一属性优先级低，再怎么配置，也不会展示此属性如（max-width 和 width， media 媒体查询等)\n\n判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上权重，那么他的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。\n一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。\n\n选择器的特殊性可以分为四个等级，\n\n第一个等级是行内样式，为 1 0 0 0,\n\n第二个等级是 id 选择器，为 0 1 0 0 ，\n\n第三个等级是类选择器，伪类选择器，属性选择器为：0 0 1 0，\n\n第四个等级是元素选择器和伪元素选择器：0 0 0 1。\n\n规则中每出现一个选择器，就将他的特殊性进行累加，这个累加只限于对应等级的累加，不会产生进位 。选择器特殊性值的比较是从左向右排序的，也就是说以 1 开头的特殊性比所有 0 开头的特殊性值要大。比如说特殊性值为 1000 的规则优先级就要比特殊性值为 0999 的规则高。如果两个规则的特殊性值相等的时候，那么就会根据他们引用的顺序，后出现的规则的优先级最高。\n\n\n29. CSS 中的那些属性是可以继承的？1、字体系列的属性\nfont\nfont-family 指定一个元素的字体\nfont-weight\nfont-size\nfont-style normal&#x2F;italic&#x2F;oblique\nfont-variant 浏览器会显示小型大写字母的字体。\n&#x2F;* 基本上不支持 *&#x2F;\nfont-stretch 基本上都不支持\nfont-size-adjust 除火狐，基本上不支持\n\nfont-variant\n\n\n2、字体系列的属性\ncolor\ndirection\nword-spacing  &#x2F;* 指定 &quot;段字&quot; 之间的空间，应该是30像素 *&#x2F;\nletter-spacing &#x2F;* 字母间距 *&#x2F;\nline-height\n&#x2F;* text *&#x2F;\ntext-indent\ntext-align\ntext-shadow\ntext-transform\n&#x2F;*\n转换不同元素中的文本：\n\nnone\t默认。定义带有小写字母和大写字母的标准的文本。\ncapitalize\t文本中的每个单词以大写字母开头。\nuppercase\t定义仅有大写字母。\nlowercase\t定义无大写字母，仅有小写字母。\n\n *&#x2F;\n\n3、表格布局属性\ncaption-side &#x2F;* 指定表格标题的位置 *&#x2F;\nborder-collapse &#x2F;* 为表格设置合并边框模型   collapse&#x2F;separate *&#x2F;\nempty-cells  &#x2F;* 属性设置是否显示表格中的空单元格（仅用于&quot;分离边框&quot;模式）。 *&#x2F;\n\n\n4、列表属性\nlist-style-type &#x2F;* 设置列表项标记的类型 *&#x2F;\nlist-style-image &#x2F;* 使用图像来替换列表项的标记 *&#x2F;\nlist-style-position &#x2F;* inside&#x2F;outside 设置在何处放置列表项标记 *&#x2F;\n&#x2F;* 上面三个缩写 *&#x2F;\nlist-style: list-style-type, list-style-position, list-style-image.\n\n5、光标属性\ncursor\n\n6、元素可见性\nvisibility\n\ninhert当一个属性不是继承属性的时候，此时可以使用 inhert 关键字来指定一个属性应该从父元素继承他的值，inhert 关键字用于显示的指定继承性，可以用于任何继承性和非继承性。\n28. 伪类和伪元素的区别？区分伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。也就是说，当用户悬停指定的元素时，我们可以通过:hover 来描述这个元素的状态。伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。\n常见伪类a 链接 love hate 原则有顺序\na 链接相关\n\n:link: 选取未访问过的超链接元素。如果我们注意过搜索引擎的结果的话，它里面的链接只要点过的就会变色，从而标记哪个链接是访问过的。:link 这个属性就是用来标识没访问过的链接。\n\n:visited: 选取访问过的超链接元素。和第一条相反，:visited 是用来标记哪个链接是已经访问过的，防止重复点击。\n\n:hover: 选取鼠标悬停的元素。，这个伪类经常用在 PC 端，当鼠标放在一个元素上时，可以用 :hover 来控制鼠标悬停的样式。因为在移动端里没有鼠标的概念，所以移动端里很少用这个伪类。\n\n:active: 选取点中的元素。这个伪类的作用在刚才提到过了，当我们希望按钮有操作反馈的时候，可以用它来标记操作反馈的样式。当然这个伪类也是可以通用的，并不是只能用在按钮上。\n\n:empty: 选取没有子元素的元素。比如选择空的 span，就可以用 span:empty 选择器来选择。这里要注意元素内有空格的话也不能算空，不会被这个伪类选中。\n\n:focus: 选取获得焦点的元素。这个伪类用来标识获得焦点的元素，比如搜索框在聚焦的时候有个比较明显的边框，方便用户知道当前在可输入的状态。\n\n:checked: 选取勾选状态的 input 元素， 只对 radio 和 checkbox 生效。\n\n:disabled: 选取禁用的表单元素。\n\n\n选元素的\n\n:first-child: 选取当前选择器下第一个元素。\n:last-child: 和 first-child 相反，选取当前选择器下最后一个元素。\n:nth-child(an+b): 选取指定位置的元素。这个伪类是有参数的，参数可以支持 an+b 的形式，这里 a 和 b 都是可变的，n 从 0 起。使用这个伪类可以做到选择第几个，或者选择序号符合 an+b 的所有元素。比如使用 li:nth-child(2n+1)，就可以选中 li 元素中序号是 2 的整数倍加 1 的所有元素，也就是第 1、3、5、7、9、2n+1 个 li 元素。\n:nth-last-child(an+b): 这个伪类和 nth-child 相似，只不过在计数的时候，这个伪类是从后往前计数。\n:only-child: 选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效。\n:only-of-type: 选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以。\n\n:only-of-type\n常见伪元素\n::first-line:为某个元素的第一行文字使用样式。\n::first-letter:为某个元素中的文字的首字母或第一个字使用样式。\n::before:在某个元素之前插入一些内容。\n::after:在某个元素之后插入一些内容。\n::selection:对光标选中的元素添加样式。\n\n30. css 选择器有哪些？\nid 选择器 #myId &#123;&#125;\n类选择器 .myClass &#123;&#125;\n标签选择器 p,h1 &#123;&#125;\n后代选择器 div h1 &#123;&#125;\n子选择器 div&gt;h1 &#123;&#125;\n兄弟选择器 ul~h1 &#123;&#125;\n相邻兄弟选择器 ul+h1 &#123;&#125;\n属性选择器 li[name=&#39;sss&#39;] &#123;&#125;\n伪类选择器 h1:hover &#123;&#125;\n伪元素选择器 h1::before&#123;&#125;\n通配符选择器 * &#123;&#125;\n\n31. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？1、盒模型都是由四部分组成的，分别是 margin，border， padding, content。2、标准和模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。\n标准盒模型的范围只有 content，IE 盒模型的 width 和 height 属性的范围包含 border，padding 和 content。\n3、一般来说我们可以通过 box-sizing 属性来改变元素的盒模型，存在两个值，\n\nborder-box 表示 IE 盒模型，\ncontent-box 表示标准盒模型。\n\n32. 未知大小的父元素，子元素水平垂直居中？\nflex\ntable\ntransform\n\n&#x2F;* table *&#x2F;\n.parent &#123;\n  width: 200px;\n  height: 200px;\n  display: table;\n  background-color: red;\n&#125;\n\n.child &#123;\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n&#125;\n&#x2F;* ———————————————— *&#x2F;\n&#x2F;* 版权声明：本文为CSDN博主「卖菜的小白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 *&#x2F;\n&#x2F;* 原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47450807&#x2F;article&#x2F;details&#x2F;123666444 *&#x2F;\n\n32. BFC什么是 BFCBFC(Block Formatting Context)格式化上下文，是 web 页面中盒子模型布局的 CSS 渲染模式，指的是一个独立的渲染区域或者是一个隔离的独立容器。\n如何创建 BFC1、浮动元素，float 除 none 以外。2、定位元素，position(absolute, fixed)3、display 为以下其中之一的值：inline-block,table-cell,table-caption.4、overflow 除了 visible 以外的值(hidden,auto, scroll)\nBFC 特点，能解决什么问题\nBFC中的盒子对齐: 内部的 Box 会在垂直方向上一个接着一个的放置。\n外边距重叠: 在正常的文档流中，两个兄弟盒子之间的具有由其外边距决定的，不是他们的外边距之和决定的，而是以较大的为准。\n不被浮动元素覆盖: 两栏布局， 三栏布局\n可以防止字体环绕\nBFC 包含浮动的块： 如果我们使用浮动，则该元素就会脱离正常的文档流，则会造成父元素高度的坍塌\n\n总结（由外到内）：父元素塌陷问题、文字环绕问题、外边距重叠问题、不被浮动元素覆盖、BFC 内盒子对齐问题\n参考链接weixin_47450807 的博客\n","slug":"2022-10-23css-qa","date":"2022-10-23T06:39:57.000Z","categories_index":"前端基础","tags_index":"前端基础,chatGPT2021","author_index":"举手摘月亮"},{"id":"96631ce884e53e339dba9cb51900376e","title":"前端基础-js class","content":"类什么是类， 有什么作用类是: 用于创建对象的模板。用代码封装数据以处理该数据。\nJS 中的类建立在原型上，但与 ES5 类的语法和语义不同\n类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。\n与函数区别class 关键字声明一个类。函数声明会提升，类声明不会\n类表达式是定义类的另一种方法。类表达式可以命名或不命名。命名类表达式的名称是该类体的局部名称。\n类体和方法定义一个类的类体: 是一对花括号/大括号 &#123;&#125; 中的部分。这是你定义类成员的位置，如方法或构造函数。\n严格模式类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter 和 setter 都在严格模式下执行。\nclass Animal &#123;\n  speak() &#123;\n    return this;\n  &#125;\n  static eat() &#123;\n    return this;\n  &#125;\n&#125;\n\nlet obj &#x3D; new Animal();\nobj.speak(); &#x2F;&#x2F; Animal &#123;&#125; &#x2F;&#x2F; 实例化后，指向的是类的实例\nlet speak &#x3D; obj.speak;\nspeak(); &#x2F;&#x2F; undefined &#x2F;&#x2F;严格执行\n\nAnimal.eat(); &#x2F;&#x2F; class Animal &#x2F;&#x2F; 类的静态方法中指向类\nlet eat &#x3D; Animal.eat;\neat(); &#x2F;&#x2F; undefined\n\n构造方法constructor 是一种用于 创建和初始化（ class 创建的）对象 的特殊方法\n哪里特殊了？\n构造函数中的 this 指向实例，其他类体中的 this 指向 undefined\n语法constructor([arguments]) &#123; ... &#125;\n\n\n特点\n只能出现一次 constructor，出现多次报错\nconstructor 内部可以使用 super 调用父类构造方法\n不指定构造方法，会有一个默认构造方法（有两种：非派生、派生类的构造函数）\nsetPrototypeOf 只一个类的原型，不改变这个基类的构造函数\n\n默认构造方法\n如前所述，如果不指定构造方法，则使用默认构造函数。对于基类，默认构造函数是：\nconstructor() &#123;&#125;\n\n对于派生类，默认构造函数是：\nconstructor(...args) &#123;\n  super(...args);\n&#125;\n\nextendsextends关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。\n\nclass ChildClass extends ParentClass &#123; ... &#125;\n\n\nextends 关键字用来创建一个普通类或者内建对象的子类。\n\n什么是普通类：没有父类，非内置对象的类\n什么是派生类：父类也叫超类、基类，子类也叫派生类。 见\n什么是内置对象： Date\n扩展 null\n\n&#x2F;&#x2F; 扩展 null 这是什么骚操作，有什么用？\n&#x2F;&#x2F; 新对象的原型将不会继承 Object.prototype\nclass nullExtends extends null &#123;\n  constructor() &#123;&#125;\n&#125;\n\nObject.getPrototypeOf(nullExtends); &#x2F;&#x2F; Function.prototype\nObject.getPrototypeOf(nullExtends.prototype); &#x2F;&#x2F; null\n\nnew nullExtends(); &#x2F;&#x2F;ReferenceError: this is not defined\n\n类私有域\n类属性在默认情况下是公有的\n前缀 # 的方式来定义私有类字段，这一隐秘封装的类特性由 JavaScript 自身强制执行。\n\n私有字段私有字段包括私有实例字段和私有静态字段。\n私有实例字段\n私有字段在类声明的构造方法中就可被访问。\n类似于公有字段，私有字段在构造（construction）基类或调用子类的 super() 方法时被添加到类实例中\n作用域之外引用、未声明引用、删除都会报错\n\n私有静态字段\n私有静态字段： 在解析类结构时被添加到类的构造方法（constructor）中。\n静态变量：只能被静态方法调用\n\n私有方法私有实例方法\n私有实例方法是类实例上可用的方法，它们的访问方式与私有实例字段相同。\n私有实例方法可以是生成器方法、异步方法或异步生成器方法，也可以是私有的 getter 和 setter。\n\n私有静态方法私有静态方法可以是生成器方法，异步方法或异步生成器方法。\n前面提到的私有静态字段的限制同样适用于私有静态方法。\n同样地，使用 this 可能会出现意想不到的行为。在下方的例子中，this 是 Derived 类（而不是 Base 类）的引用，所以尝试调用 Derived.publicStaticMethod2() 会抛出 TypeError。\nclass Base &#123;\n  static #privateStaticMethod() &#123;\n    return 42;\n  &#125;\n  static publicStaticMethod1() &#123;\n    return Base.#privateStaticMethod();\n  &#125;\n  static publicStaticMethod2() &#123;\n    return this.#privateStaticMethod();\n  &#125;\n&#125;\n\nclass Derived extends Base &#123;&#125;\n\nconsole.log(Derived.publicStaticMethod1());\n&#x2F;&#x2F; 42\nconsole.log(Derived.publicStaticMethod2());\n&#x2F;&#x2F; TypeError: Cannot read private member #privateStaticMethod\n&#x2F;&#x2F; from an object whose class did not declare it\n\n公有类字段公有静态字段和公有实例字段都是可编辑、可枚举和可配置的属性。因此，不同于私有对应值（private counterpart）的是，它们参与原型的继承。\n公有静态字段在类里面存数据，只有一份，其他实例不存，可被其他实例共享\n\n公有静态字段是使用关键字 static 声明的。\n我们在声明一个类的时候，使用 Object.defineProperty() 方法将公有静态字段添加到类的构造函数中。\n在类被声明之后，可以从类的构造函数访问公有静态字段。\n\nclass ClassWithStaticField &#123;\n  static staticField &#x3D; &#39;static field&#39;; &#x2F;&#x2F; 如果没有初始化，默认是undefined\n&#125;\n\nconsole.log(ClassWithStaticField.staticField);\n&#x2F;&#x2F; 预期输出值：&quot;static field&quot;​\n\n公有静态字段不会在子类中重复初始化，可以通过原型链访问它们。\nclass ClassWithStaticField &#123;\n  static baseStaticField &#x3D; &#39;base field&#39;;\n&#125;\n\nclass SubClassWithStaticField extends ClassWithStaticField &#123;\n  static subStaticField &#x3D; &#39;sub class field&#39;;\n&#125;\n\nconsole.log(SubClassWithStaticField.subStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;sub class field&quot;\n\nconsole.log(SubClassWithStaticField.baseStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;base field&quot;\n\n在初始化字段时，this 指向的是类的实例 见你也可以通过名字引用构造函数，并使用 super 获取到存在的父类的构造函数。\nclass ClassWithStaticField &#123;\n  static baseStaticField &#x3D; &#39;base static field&#39;;\n  &#x2F;&#x2F; 这里可以论证 在初始化字段时，this 指向的是类\n  static anotherBaseStaticField &#x3D; this.baseStaticField;\n\n  static baseStaticMethod() &#123;\n    return &#39;base static method output&#39;;\n  &#125;\n&#125;\n\nclass SubClassWithStaticField extends ClassWithStaticField &#123;\n  static subStaticField &#x3D; super.baseStaticMethod();\n&#125;\n\nconsole.log(ClassWithStaticField.anotherBaseStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;base static field&quot;\n\nconsole.log(SubClassWithStaticField.subStaticField);\n&#x2F;&#x2F; 预期输出值：&quot;base static method output&quot;\n\n公有实例字段公有实例字段存在于类的每一个实例中。是对类模型的描述（这个类模型产出的实例对象的特点）\n公有实例字段可以在基类的构造过程中（构造函数主体运行前）使用 Object.defineProperty() 添加，也可以在子类构造函数中的 super() 函数结束后添加。\n\n公有实例字段默认 undefined。\n公有实例字段名可以由计算得出。\n在初始化字段时，this 指向的是类正在构造中的实例。和公有实例方法相同的是：你可以在子类中使用 super 来访问父类的原型。\n因为类的实例字段是在对应的构造函数运行之前添加的，所以你可以在构造函数中访问字段的值。（现有字段，而后有构造函数）\n因为派生类的实例字段是在 super() 返回之后定义的，所以基类的构造函数无法访问派生类的字段。\n因为类字段是通过 [[Define]] 语义（本质上是 Object.defineProperty()）添加的，所以派生类中的字段声明并不会调用基类中的 setter。此行为不同于在构造函数中使用 this.field &#x3D; …\n\n公有静态方法关键字 static 将为一个类定义一个静态方法。静态方法不是在一个实例之上被调用，而是在类自身之上被调用\n静态方法是在类的声明阶段用 Object.defineProperty() 方法添加到类的构造函数中的。静态方法是可编辑、不可枚举和可配置的。\n公有实例方法正如其名，公有实例方法是可以在类的实例中使用的。公有实例方法是在类的声明阶段用 Object.defineProperty() 方法添加到类中的。静态方法是可编辑、不可枚举和可配置的。实例的方法中，this 指向的是实例本身，你可以使用 super 访问到父类的原型，由此你可以调用父类的方法。getter 和 setter 是和类的属性绑定的特殊方法，分别会在其绑定的属性被取值、赋值时调用。使用 get 和 set 语法定义实例的公有 getter 和 setter。\nstatic静态方法调用直接在类上进行，不能在类的实例上调用。静态方法通常用于创建实用程序函数。\nstatic methodName() &#123; ... &#125;\n\n调用静态方法\n从另一个静态方法: 静态方法调用同一个类中的其他静态方法，可使用 this 关键字。\n\n从类的构造函数和其他方法: 非静态方法中，不能直接使用 this 关键字来访问静态方法。\n\n要用类名来调用：CLASSNAME.STATIC_METHOD_NAME()\n用构造函数的属性来调用该方法： this.constructor.STATIC_METHOD_NAME().\n\n\n\nclass StaticMethodCall &#123;\n  constructor() &#123;\n    console.log(StaticMethodCall.staticMethod());\n    &#x2F;&#x2F; &#39;static method has been called.&#39;\n    console.log(this.constructor.staticMethod());\n    &#x2F;&#x2F; &#39;static method has been called.&#39;\n  &#125;\n  static staticMethod() &#123;\n    return &#39;static method has been called.&#39;;\n  &#125;\n&#125;\n\n为什么要设计 static 方法在 JavaScript 中，class 是 ES6 引入的一种面向对象编程的语法糖，可以方便地定义一个构造函数和一个原型对象，并将它们组合成一个类。在 class 中，我们可以定义实例方法、静态方法和实例属性，而静态方法是在类上定义的方法，而不是在实例上定义的方法。\n静态方法的一个主要用途是为类创建工具函数。它们通常与实例方法配合使用，提供一种在类级别上操作数据的方法。在一些常见的应用场景中，静态方法经常被用来作为工具函数，进行一些通用的数据处理，或者对类的静态属性进行操作。举例来说，对于一些数学计算，我们可以使用静态方法来实现一个数学工具库，如下面的例子：\nclass MathUtils &#123;\n  static sum(x, y) &#123;\n    return x + y;\n  &#125;\n\n  static subtract(x, y) &#123;\n    return x - y;\n  &#125;\n&#125;\n\nconsole.log(MathUtils.sum(1, 2)); &#x2F;&#x2F; 3\nconsole.log(MathUtils.subtract(3, 2)); &#x2F;&#x2F; 1\n\n上面的代码定义了一个 MathUtils 类，其中包含了两个静态方法 sum 和 subtract，它们可以直接通过类名调用。这样，我们就可以把这个类当做一个工具库来使用了。\n另外，静态方法还有一个好处，就是可以提高类的性能。因为静态方法是在类上定义的，不需要实例化就可以直接访问，这样就可以避免在实例化时多次创建相同的方法，节省内存开销。\n总之，静态方法的出现，使得开发者能够在类级别上操作数据，并且能够有效地提高类的性能，提供更好的代码可读性和可维护性。\n类中的 this类声明和类表达式的主体都执行在严格模式下 同样遵循谁调用指向谁：\n\n实例调用实例方法，指向实例\n类调用静态方法，指向类\n实例方法、类的静态在全局调用，由于是严格模式，所以 this 是 undefined\n\n","slug":"2022-10-21js-class","date":"2022-10-21T05:40:31.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"1269a76e445b052b3fd7442cae906b92","title":"gorm migrate 注意点","content":"等效语句添加、删除会报错\n&#x2F;&#x2F; ...\n\ntype User struct &#123;\n\tgorm.Model\n\tName string &#96;gorm:&quot;size:255;index:idx_name,unique&quot;&#96;\n&#125;\n\n&#x2F;&#x2F; ....\n\n&#x2F;&#x2F; 方式1\ndb.Debug().AutoMigrate(&amp;User&#123;&#125;)\n\n&#x2F;&#x2F; 方式2\ndb.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;Name&quot;) &#x2F;&#x2F; 重复操作\n&#x2F;&#x2F; 2022&#x2F;10&#x2F;21 09:52:36 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;migrator.go:18 Error 1061: Duplicate key name &#39;idx_name&#39;\n&#x2F;&#x2F; [2.300ms] [rows:0] CREATE UNIQUE INDEX &#96;idx_name&#96; ON &#96;users&#96;(&#96;name&#96;)\n\n&#x2F;&#x2F; 方式3\ndb.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;) &#x2F;&#x2F; 重复操作\n&#x2F;&#x2F; 2022&#x2F;10&#x2F;21 09:52:59 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;migrator.go:19 Error 1061: Duplicate key name &#39;idx_name&#39;\n&#x2F;&#x2F; [1.194ms] [rows:0] CREATE UNIQUE INDEX &#96;idx_name&#96; ON &#96;users&#96;(&#96;name&#96;)\n\n\n\nAutoMigrateAutoMigrate 用于自动迁移您的 schema，保持您的 schema 是最新的。\n注意： AutoMigrate 会创建表、缺失的外键、约束、列和索引。 如果大小、精度、是否为空可以更改，则 AutoMigrate 会改变列的类型。 出于保护您数据的目的，它 不会 删除未使用的列\ndb.AutoMigrate(&amp;User&#123;&#125;)\n\ndb.AutoMigrate(&amp;User&#123;&#125;, &amp;Product&#123;&#125;, &amp;Order&#123;&#125;)\n\n&#x2F;&#x2F; 创建表时添加后缀, 注意：文档上没说，操作mysql时候，即使你不添加 ENGINE&#x3D;InnoDB ,默认自动添加\ndb.Set(&quot;gorm:table_options&quot;, &quot;ENGINE&#x3D;InnoDB&quot;).AutoMigrate(&amp;User&#123;&#125;)\n\n&#x2F;&#x2F; 注意 AutoMigrate 会自动创建数据库外键约束，您可以在初始化时禁用此功能，例如：\ndb, err :&#x3D; gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;\n  DisableForeignKeyConstraintWhenMigrating: true,\n&#125;)\n\n\nMigrator 接口GORM 提供了 Migrator 接口，该接口为每个数据库提供了统一的 API 接口，可用来为您的数据库构建独立迁移，例如：\nSQLite 不支持 ALTER COLUMN、DROP COLUMN，当你试图修改表结构，GORM 将创建一个新表、复制所有数据、删除旧表、重命名新表。\n一些版本的 MySQL 不支持 rename 列，索引。GORM 将基于您使用 MySQL 的版本执行不同 SQL\ntype Migrator interface &#123;\n  &#x2F;&#x2F; AutoMigrate 自动迁移\n  AutoMigrate(dst ...interface&#123;&#125;) error\n\n  &#x2F;&#x2F; Database 数据哭\n  CurrentDatabase() string\n  FullDataTypeOf(\\*schema.Field) clause.Expr\n\n  &#x2F;&#x2F; Tables 表\n  CreateTable(dst ...interface&#123;&#125;) error\n  DropTable(dst ...interface&#123;&#125;) error\n  HasTable(dst interface&#123;&#125;) bool\n  RenameTable(oldName, newName interface&#123;&#125;) error\n  GetTables() (tableList []string, err error)\n\n  &#x2F;&#x2F; Columns 列\n  AddColumn(dst interface&#123;&#125;, field string) error\n  DropColumn(dst interface&#123;&#125;, field string) error\n  AlterColumn(dst interface&#123;&#125;, field string) error\n  MigrateColumn(dst interface&#123;&#125;, field \\*schema.Field, columnType ColumnType) error\n  HasColumn(dst interface&#123;&#125;, field string) bool\n  RenameColumn(dst interface&#123;&#125;, oldName, field string) error\n  ColumnTypes(dst interface&#123;&#125;) ([]ColumnType, error)\n\n  &#x2F;&#x2F; Constraints 外键约束\n  CreateConstraint(dst interface&#123;&#125;, name string) error\n  DropConstraint(dst interface&#123;&#125;, name string) error\n  HasConstraint(dst interface&#123;&#125;, name string) bool\n\n  &#x2F;&#x2F; Indexes 索引\n  CreateIndex(dst interface&#123;&#125;, name string) error\n  DropIndex(dst interface&#123;&#125;, name string) error\n  HasIndex(dst interface&#123;&#125;, name string) bool\n  RenameIndex(dst interface&#123;&#125;, oldName, newName string) error\n&#125;\n\n当前数据库返回当前使用的数据库名\ndb.Migrator().CurrentDatabase()\n\n表&#x2F;&#x2F; 为 &#96;User&#96; 创建表\ndb.Migrator().CreateTable(&amp;User&#123;&#125;)\n\n&#x2F;&#x2F; 将 &quot;ENGINE&#x3D;InnoDB&quot; 添加到创建 &#96;User&#96; 的 SQL 里去\ndb.Set(&quot;gorm:table_options&quot;, &quot;ENGINE&#x3D;InnoDB&quot;).Migrator().CreateTable(&amp;User&#123;&#125;)\n\n&#x2F;&#x2F; 检查 &#96;User&#96; 对应的表是否存在\ndb.Migrator().HasTable(&amp;User&#123;&#125;)\ndb.Migrator().HasTable(&quot;users&quot;)\n\n&#x2F;&#x2F; 如果存在表则删除（删除时会忽略、删除外键约束)\n&#x2F;&#x2F; 下面两个等效，同时操作报错\ndb.Migrator().DropTable(&amp;User&#123;&#125;)\ndb.Migrator().DropTable(&quot;users&quot;)\n\n&#x2F;&#x2F; 重命名表\ndb.Migrator().RenameTable(&amp;User&#123;&#125;, &amp;UserInfo&#123;&#125;)\ndb.Migrator().RenameTable(&quot;users&quot;, &quot;user_infos&quot;)\n\n列type User struct &#123;\n  Name string\n&#125;\n\n&#x2F;&#x2F; 添加 name 字段\ndb.Migrator().AddColumn(&amp;User&#123;&#125;, &quot;Name&quot;)\n&#x2F;&#x2F; 删除 name 字段\ndb.Migrator().DropColumn(&amp;User&#123;&#125;, &quot;Name&quot;)\n&#x2F;&#x2F; 修改 name 字段\ndb.Migrator().AlterColumn(&amp;User&#123;&#125;, &quot;Name&quot;)\n&#x2F;&#x2F; 检查 name 字段是否存在\ndb.Migrator().HasColumn(&amp;User&#123;&#125;, &quot;Name&quot;)\n\ntype User struct &#123;\n  Name    string\n  NewName string\n&#125;\n\n&#x2F;&#x2F; 字段重命名  注意： 下面两个等效，同时使用报错\ndb.Migrator().RenameColumn(&amp;User&#123;&#125;, &quot;Name&quot;, &quot;NewName&quot;)\ndb.Migrator().RenameColumn(&amp;User&#123;&#125;, &quot;name&quot;, &quot;new_name&quot;)\n\n&#x2F;&#x2F; 字段类型\ndb.Migrator().ColumnTypes(&amp;User&#123;&#125;) ([]gorm.ColumnType, error)\n\ntype ColumnType interface &#123;\n    Name() string\n    DatabaseTypeName() string                 &#x2F;&#x2F; varchar\n    ColumnType() (columnType string, ok bool) &#x2F;&#x2F; varchar(64)\n    PrimaryKey() (isPrimaryKey bool, ok bool)\n    AutoIncrement() (isAutoIncrement bool, ok bool)\n    Length() (length int64, ok bool)\n    DecimalSize() (precision int64, scale int64, ok bool)\n    Nullable() (nullable bool, ok bool)\n    Unique() (unique bool, ok bool)\n    ScanType() reflect.Type\n    Comment() (value string, ok bool)\n    DefaultValue() (value string, ok bool)\n&#125;\n\n约束\n&#x2F;&#x2F;  表自带约束，之后重复创建约束报错\ntype UserIndex struct &#123;\n  Name  string &#96;gorm:&quot;check:name_checker,name &lt;&gt; &#39;jinzhu&#39;&quot;&#96;\n&#125;\n&#x2F;&#x2F; 创建约束\ndb.Migrator().CreateConstraint(&amp;User&#123;&#125;, &quot;name_checker&quot;)\n\n&#x2F;&#x2F; 删除约束\ndb.Migrator().DropConstraint(&amp;User&#123;&#125;, &quot;name_checker&quot;)\n\n&#x2F;&#x2F; 检查约束是否存在\ndb.Migrator().HasConstraint(&amp;User&#123;&#125;, &quot;name_checker&quot;)\n\n&#x2F;&#x2F; 为 relation 创建外键\ntype User struct &#123;\n  gorm.Model\n  CreditCards []CreditCard\n&#125;\n\ntype CreditCard struct &#123;\n  gorm.Model\n  Number string\n  UserID uint\n&#125;\n\n&#x2F;&#x2F; 为 user &amp; credit_cards 创建 db 外键\n&#x2F;&#x2F; 以下两行代码等效，同时使用，报错\ndb.Migrator().CreateConstraint(&amp;User&#123;&#125;, &quot;CreditCards&quot;)\ndb.Migrator().CreateConstraint(&amp;User&#123;&#125;, &quot;fk_users_credit_cards&quot;)\n&#x2F;&#x2F; ALTER TABLE &#96;credit_cards&#96; ADD CONSTRAINT &#96;fk_users_credit_cards&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;users&#96;(&#96;id&#96;)\n\n&#x2F;&#x2F; 检查 user &amp; credit_cards 的外键是否存在\n&#x2F;&#x2F; 以下两行代码等效，\ndb.Migrator().HasConstraint(&amp;User&#123;&#125;, &quot;CreditCards&quot;)\ndb.Migrator().HasConstraint(&amp;User&#123;&#125;, &quot;fk_users_credit_cards&quot;)\n\n&#x2F;&#x2F; 删除 user &amp; credit_cards 的 db 外键\n&#x2F;&#x2F; 以下两行代码等效，同时使用，报错\ndb.Migrator().DropConstraint(&amp;User&#123;&#125;, &quot;CreditCards&quot;)\ndb.Migrator().DropConstraint(&amp;User&#123;&#125;, &quot;fk_users_credit_cards&quot;)\n\n索引type User struct &#123;\n  gorm.Model\n  Name string &#96;gorm:&quot;size:255;index:idx_name,unique&quot;&#96;\n&#125;\n\n&#x2F;&#x2F; 为 Name 字段创建索引\n&#x2F;&#x2F; 以下两行代码等效，同时使用，报错\ndb.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;Name&quot;)\ndb.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;)\n\n&#x2F;&#x2F; 为 Name 字段删除索引\n&#x2F;&#x2F; 以下两行代码等效，同时使用，报错\ndb.Migrator().DropIndex(&amp;User&#123;&#125;, &quot;Name&quot;)\ndb.Migrator().DropIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;)\n\n&#x2F;&#x2F; 检查索引是否存在\ndb.Migrator().HasIndex(&amp;User&#123;&#125;, &quot;Name&quot;)\ndb.Migrator().HasIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;)\n\ntype User struct &#123;\n  gorm.Model\n  Name  string &#96;gorm:&quot;size:255;index:idx_name,unique&quot;&#96;\n  Name2 string &#96;gorm:&quot;size:255;index:idx_name_2,unique&quot;&#96;\n&#125;\n&#x2F;&#x2F; 修改索引名\n&#x2F;&#x2F; 以下两行代码等效\ndb.Migrator().RenameIndex(&amp;User&#123;&#125;, &quot;Name&quot;, &quot;Name2&quot;)\ndb.Migrator().RenameIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;, &quot;idx_name_2&quot;)\n\n注意具有相同意义的语句，在创建/删除时候会报错重复/不存在\n参考链接gorm migration\ngorm 数据库迁移\n","slug":"2022-10-21gorm-migrate","date":"2022-10-21T02:04:16.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"1e93951633e1850ed62331ad3c63ff79","title":"gorm 关联","content":"打开认知belong to 属于\n\nhas one 拥有\n\nbelong to vs has one\nB belong to A : B 结构体和 B 的 ID 都 A 在结构体中\nA has one B: A 的 id 在 B 结构体中，B 的结构体在 A 结构体中\n\nHas many\n\nbelong to &#x2F; has one &#x2F; has many 总结belong to, has one, has many, id 在哪个结构体中，那么这个结构体对应的数据库表就有外键约束\nMany to many\n\nMany to many 总结\nmany2many 在哪个结构体中，哪个结构体就能创建全部的表\n外键约束都在关联表中，非关联表，各自为简单表\n\nplaygroundplayground\npackage main\n\nimport (\n\t&quot;database&#x2F;sql&quot;\n\t&quot;time&quot;\n\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\n&#x2F;&#x2F; User has one &#96;Account&#96; (has one), many &#96;Pets&#96; (has many) and &#96;Toys&#96; (has many - polymorphic)\n&#x2F;&#x2F; He works in a Company (belongs to), he has a Manager (belongs to - single-table), and also managed a Team (has many - single-table)\n&#x2F;&#x2F; He speaks many languages (many to many) and has many friends (many to many - single-table)\n&#x2F;&#x2F; His pet also has one Toy (has one - polymorphic)\n\n&#x2F;&#x2F;用户有一个“帐户”（有一个），多个“宠物”（有很多）和“玩具”（有许多多态性）\n&#x2F;&#x2F;他在一家公司工作（属于），他有一个经理（属于-单表），还管理一个团队（有多-单表）\n&#x2F;&#x2F;他会说多种语言（多对多），有许多朋友（多对多-单表）\n&#x2F;&#x2F;他的宠物也有一个玩具（有一个多态性）\ntype User struct &#123;\n\tgorm.Model\n\tName      string\n\tAge       uint\n\tBirthday  *time.Time\n  &#x2F;&#x2F; has one\n\tAccount   Account &#x2F;&#x2F; 有一个“帐户”（有一个）\n  &#x2F;&#x2F; has many 这两个怎么不一样？\n  &#x2F;&#x2F; 反向引用\n\tPets      []*Pet &#x2F;&#x2F; 有多个宠物\n  &#x2F;&#x2F; has many\n\tToys      []Toy &#96;gorm:&quot;polymorphic:Owner&quot;&#96; &#x2F;&#x2F; 有多个玩具\n  &#x2F;&#x2F; belong to\n\tCompanyID *int &#x2F;&#x2F; 在一家公司工作（属于）\n\tCompany   Company &#x2F;&#x2F; 在一家公司工作（属于）\n  &#x2F;&#x2F; belong to\n\tManagerID *uint &#x2F;&#x2F; 他有一个经理（属于-单表）\n\tManager   *User &#x2F;&#x2F; 他有一个经理（属于-单表）\n  &#x2F;&#x2F; has many\n\tTeam      []User     &#96;gorm:&quot;foreignkey:ManagerID&quot;&#96; &#x2F;&#x2F; 还管理一个团队（有多个单表）\n  &#x2F;&#x2F; many 2 many\n\tLanguages []Language &#96;gorm:&quot;many2many:UserSpeak&quot;&#96; &#x2F;&#x2F; 他会说多种语言（多对多）\n  &#x2F;&#x2F; many 2 many\n\tFriends   []*User    &#96;gorm:&quot;many2many:user_friends&quot;&#96; &#x2F;&#x2F; 有许多朋友（多对多-单表）\n\tActive    bool\n&#125;\n&#x2F;&#x2F; 账号表\ntype Account struct &#123;\n\tgorm.Model\n\tUserID sql.NullInt64\n\tNumber string\n&#125;\n &#x2F;&#x2F; 宠物表\ntype Pet struct &#123;\n\tgorm.Model\n\tUserID *uint\n\tName   string\n\tToy    Toy &#96;gorm:&quot;polymorphic:Owner;&quot;&#96; &#x2F;&#x2F; polymorphic 处理多态，多态\n  &#x2F;&#x2F; 主键放到 OwnerID ，表名放到 OwnerType\n  &#x2F;&#x2F; link: https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;gorm&#x2F;v2&#x2F;has_one&#x2F;9737#85d280\n&#125;\n&#x2F;&#x2F; 玩具表\ntype Toy struct &#123;\n\tgorm.Model\n\tName      string\n\tOwnerID   string\n\tOwnerType string\n&#125;\n&#x2F;&#x2F; 公司表\ntype Company struct &#123; &#x2F;&#x2F; 属于\n\tID   int\n\tName string\n&#125;\n&#x2F;&#x2F; 语言表\ntype Language struct &#123; &#x2F;&#x2F; 多种语言\n\tCode string &#96;gorm:&quot;primarykey&quot;&#96;\n\tName string\n&#125;\n\nBelong tobelong to 属于\n\nhas one 拥有见\n谁是拥有者&#x2F;&#x2F; User 有一张 CreditCard，UserID 是外键\ntype User struct &#123; &#x2F;&#x2F; 拥有者\n  gorm.Model\n  CreditCard CreditCard\n&#125;\n\ntype CreditCard struct &#123;\n  gorm.Model\n  Number string\n  UserID uint &#x2F;&#x2F; 拥有者模型的主键\n&#125;\n\n\n -->\n\n什么是外键外键是某个表中的一列，它包含在另一个表的主键中。外键也是索引的一种，是通过一张表中的一列指向另一张表中的主键，来对两张表进行关联。\n重写外键（给外键改名字，数据库并没有发生变化）type User struct &#123;\n  gorm.Model\n  CreditCard CreditCard &#96;gorm:&quot;foreignKey:UserName&quot;&#96; &#x2F;&#x2F; 使用 UserName 作为外键\n&#125;\n\ntype CreditCard struct &#123;\n  gorm.Model\n  Number   string\n  UserName string &#x2F;&#x2F; 这里是外键\n&#125;\n\n -->\n\n重写引用 注意 官方文档存在问题，已提 issue重写引用，子表发生变化\ntype User struct &#123;\n  gorm.Model\n  Name       string     &#96;gorm:&quot;index&quot;&#96; &#x2F;&#x2F; 这个是引用，对应 references\n  CreditCard CreditCard &#96;gorm:&quot;foreignkey:UserName;references:name&quot;&#96;\n&#125;\n\ntype CreditCard struct &#123;\n  gorm.Model\n  Number   string\n  UserName string\n&#125;\n\n#5793\nHas oneHas many\n\nMany to many\n\n外键约束type User struct &#123;\n  gorm.Model\n  Languages []Language &#96;gorm:&quot;many2many:user_speaks;&quot;&#96;\n&#125;\n\ntype Language struct &#123;\n  Code string &#96;gorm:&quot;primarykey&quot;&#96;\n  Name string\n&#125;\n\n&#x2F;&#x2F; CREATE TABLE &#96;user_speaks&#96; (&#96;user_id&#96; integer,&#96;language_code&#96; text,PRIMARY KEY (&#96;user_id&#96;,&#96;language_code&#96;),CONSTRAINT &#96;fk_user_speaks_user&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;users&#96;(&#96;id&#96;) ON DELETE SET NULL ON UPDATE CASCADE,CONSTRAINT &#96;fk_user_speaks_language&#96; FOREIGN KEY (&#96;language_code&#96;) REFERENCES &#96;languages&#96;(&#96;code&#96;) ON DELETE SET NULL ON UPDATE CASCADE);\n\n重写外键，重写引用Gorm 中的重写外键和重写引用\n\n&#x2F;&#x2F; 重写前\n\ntype User struct &#123;\n  gorm.Model\n  Languages []Language &#96;gorm:&quot;many2many:user_languages;&quot;&#96;\n&#125;\n\ntype Language struct &#123;\n  gorm.Model\n  Name string\n&#125;\n\n&#x2F;&#x2F; 连接表：user_languages\n&#x2F;&#x2F;   foreign key: user_id, reference: users.id\n&#x2F;&#x2F;   foreign key: language_id, reference: languages.id\n\n&#x2F;&#x2F; id       user_id          language_id\n\ntype User struct &#123;\n    gorm.Model\n    Profiles []Profile &#96;gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;&#96;\n\t\t&#x2F;&#x2F; many2many:user_profiles; user_profile 多对多连接表名，默认gorm加s -&gt; user_profiles\n\n\t\t&#x2F;&#x2F; foreignKey:Refer;            &#x2F;&#x2F; 当前表的描述信息\n\t\t&#x2F;&#x2F; joinForeignKey:UserReferID;  &#x2F;&#x2F; 中间表的描述信息\n\t\t&#x2F;&#x2F; References:UserRefer 重写引用 &#x2F;&#x2F; 另一表的描述信息\n\t\t&#x2F;&#x2F; joinReferences:ProfileRefer &#x2F;&#x2F; 中间表的描述信息\n\t\t&#x2F;&#x2F; 以上分析结果参考自：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;gorm.io&#x2F;zh_CN&#x2F;docs&#x2F;many_to_many.html#%E5%A4%8D%E5%90%88%E5%A4%96%E9%94%AE&quot; target&#x3D;&quot;_blank&quot; &gt;复合外键&lt;&#x2F;a&gt;\n\n\n    Refer    uint      &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\ntype Profile struct &#123;\n    gorm.Model\n    Name      string\n    UserRefer uint &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\n\n\n\n&#x2F;&#x2F; 重写后\n\n&#x2F;&#x2F; 会创建连接表：user_profiles\n&#x2F;&#x2F;   foreign key: user_refer_id, reference: users.refer\n&#x2F;&#x2F;   foreign key: profile_refer, reference: profiles.user_refer\n\n&#x2F;&#x2F; id         user_refer_id          profile_refer\n\n\nCREATE TABLE &#96;user_speaks&#96; (\n\t&#96;user_id&#96;  integer,\n\t&#96;language_code&#96; text,\n\t-- 没有id，使用联合主键，还能进行主键索引优化\n\tPRIMARY KEY(&#96;user_id&#96;, &#96;language_code&#96;),\n\t-- user表的约束\n\tCONSTRAINT &#96;fk_user_speaks_user&#96; FOREIGN KEY(&#96;user_id&#96;) REFERENCES &#96;users&#96; (&#96;id&#96;) ON DELETE SET NULL ONUPDATE CASCADE,\n\t-- Language表的约束\n  CONSTRAINT &#96;fk_user_speaks_language&#96;  FOREIGN KEY(&#96;language_code&#96;) REFERENCES &#96;languages&#96; (&#96;code&#96;) ON DELETE SET NULL ONUPDATE CASCADE\n);\n\n看不懂撸代码重写外键（前）清理现场DROP DATABASE IF EXISTS gorm_many2many;\nCREATE DATABASE IF NOT EXISTS gorm_many2many;\n\n结构体代码package main\n\nimport (\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tgorm.Model\n\tLanguages []Language &#96;gorm:&quot;many2many:user_languages;&quot;&#96;\n&#125;\n\ntype Language struct &#123;\n\tgorm.Model\n\tName string\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 参考 https:&#x2F;&#x2F;github.com&#x2F;go-sql-driver&#x2F;mysql#dsn-data-source-name 获取详情\n\tdsn :&#x3D; &quot;root:123456@tcp(localhost:3306)&#x2F;gorm_many2many?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Language&#123;&#125;)\n\tdb.Debug().AutoMigrate(&amp;User&#123;&#125;)\n\n&#125;\n\n重写外键（后）清理现场DROP DATABASE IF EXISTS gorm_many2many;\nCREATE DATABASE IF NOT EXISTS gorm_many2many;\n\n结构体代码package main\n\nimport (\n\t&quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tgorm.Model\n\tProfiles []Profile &#96;gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;&#96;\n\tRefer    uint      &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\ntype Profile struct &#123;\n\tgorm.Model\n\tName      string\n\tUserRefer uint &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 参考 https:&#x2F;&#x2F;github.com&#x2F;go-sql-driver&#x2F;mysql#dsn-data-source-name 获取详情\n\tdsn :&#x3D; &quot;root:123456@tcp(localhost:3306)&#x2F;gorm_many2many?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\n\tdb, err :&#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n\tif err !&#x3D; nil &#123;\n\t\tpanic(&quot;failed to connect database&quot;)\n\t&#125;\n\n\t&#x2F;&#x2F; db.AutoMigrate(&amp;User&#123;&#125;, &amp;Language&#123;&#125;)\n\tdb.Debug().AutoMigrate(&amp;User&#123;&#125;)\n\n&#125;\n\n\n代码演示结果前后对比图\n\n总结\n\ntype User struct &#123;\n    gorm.Model\n    Profiles []Profile &#96;gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;&#96;\n\t\t&#x2F;&#x2F; many2many:user_profiles; user_profile 多对多连接表名，默认gorm加s -&gt; user_profiles\n\n\t\t&#x2F;&#x2F; foreignKey:Refer;            &#x2F;&#x2F; 当前表的描述信息\n\t\t&#x2F;&#x2F; joinForeignKey:UserReferID;  &#x2F;&#x2F; 中间表（连接表）的描述信息\n\t\t&#x2F;&#x2F; References:UserRefer 重写引用 &#x2F;&#x2F; 另一表（引用表）的描述信息\n\t\t&#x2F;&#x2F; joinReferences:ProfileRefer &#x2F;&#x2F; 中间表的描述信息\n\t\t&#x2F;&#x2F; 以上分析结果参考自：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;gorm.io&#x2F;zh_CN&#x2F;docs&#x2F;many_to_many.html#%E5%A4%8D%E5%90%88%E5%A4%96%E9%94%AE&quot; target&#x3D;&quot;_blank&quot; &gt;复合外键&lt;&#x2F;a&gt;\n\n\n    Refer    uint      &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\ntype Profile struct &#123;\n    gorm.Model\n    Name      string\n    UserRefer uint &#96;gorm:&quot;index:,unique&quot;&#96;\n&#125;\n\n\n\n如何理解 foreignKey&#x2F;references&#x2F;joinForeignKey&#x2F;joinReferences容易混的点容易混的点是：\n\n建表语句中外键约束的部分的 references 与 gorm 关联标签 references 毫无关系\n建表语句中外键约束的部分的 FOREIGN KEY 与 gorm 关联标签 foreignKey 毫无关系\n不是一个维度的东西\n\n理解：当前表&#x2F;引用表&#x2F;连接表\n当前表也就是父表\n引用表也就是子表\n关联表也就是连接表\n\n简单的讲:当两个表建立一对多关系的时候,”一”的那一端是父表,”多”的那一端是子表.\n\n父表设置一个主键\n子表设置一个外键\n外键与主键相关联\n\nB 表引用 A 表的字段作为外键，那么 A 表是主表，B 表是从表。就像 A 是 B 的父亲一样，儿子可以继承父亲的遗产，可以将父亲的东西拿来自己用。用继承的思想想这个问题就会比较明了。\n\n\n\nB\nA\n\n\n\nB_id\nA_id\n\n\nB_name\nA_name\n\n\nA_id\n\n\n\n简单的理解是，子表中的记录使用了父表中的某些字段，通过这些字段可以找到父表中关于这条记录的所有信息，\n例如：有学生表、课程表、选课表，由于选课表中用到了学生表中的学生 ID 字段（用来与学生表进行关联，获得学生的信息），并且用到了课程表中的课程 ID 字段（用来与课程表进行关联，获得课程的信息），\n通过上面的分析我们知道，选课表是子表，学生表与课程表都是它的父表\n参考\n关联标签\n\n\n标签\n描述\n理解\n\n\n\nmany2many\n指定连接表表名\n起个名字\n\n\nforeignKey\n指定当前模型的列作为连接表的外键\n父表提供什么字段\n\n\nreferences\n指定引用表的列名，其将被映射为连接表外键\n子表提供什么字段\n\n\njoinForeignKey\n指定连接表的外键列名，其将被映射到当前表\n连接表提供什么字段与（父表提供的字段）关联\n\n\njoinReferences\n指定连接表的外键列名，其将被映射到引用表\n连接表提供什么字段与（子表提供的字段）关联\n\n\n再加一个例子：golang 代码&#x2F;&#x2F; 当前表（父表）\ntype CCreditCard struct &#123;\n\tID     uint\n\tNumber string &#96;gorm:&quot;index:unique;size:255&quot;&#96;\n\t&#x2F;&#x2F; 在当前表中引用了（子表）\n\tInfos  []Info &#96;gorm:&quot;many2many:card_infos;foreignKey:Number;joinForeignKey:card_number;references:Name;joinReferences:name&quot;&#96;\n&#125;\n\n&#x2F;&#x2F; 当前表：foreignKey Number 字段 -&gt; 链接表 joinForeignKey card_number 字段\n&#x2F;&#x2F; 引用表：references Name -&gt; 链接表 joinReferences name 字段\n\n&#x2F;&#x2F; 引用表（子表）\ntype Info struct &#123;\n\tID   uint\n\tName string &#96;gorm:&quot;index:unique;size:255&quot;&#96;\n\tAge  int\n&#125;\n\nfunc main() &#123;\n\tdb.AutoMigrate(&amp;CreditCard&#123;&#125;, &amp;Info&#123;&#125;)\n\tdb.Create(&amp;CreditCard&#123;\n\t\tNumber: &quot;123456&quot;,\n\t\tInfos: []Info&#123;\n\t\t\t&#123;\n\t\t\t\tID:   1,\n\t\t\t\tName: &quot;linzy&quot;,\n\t\t\t\tAge:  18,\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;)\n\n\tdb.Create(&amp;CreditCard&#123;\n\t\tNumber: &quot;456789&quot;,\n\t\tInfos: []Info&#123;\n\t\t\t&#123;\n\t\t\t\tID:   2,\n\t\t\t\tName: &quot;slyyy&quot;,\n\t\t\t\tAge:  66,\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\tID:   3,\n\t\t\t\tName: &quot;qhgwueiq&quot;,\n\t\t\t\tAge:  1,\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;)\n&#125;\n\n\n\n查询到的键表语句-- 查询语句\nshow create table 表名 \\G\n\nCREATE TABLE &#96;c_credit_cards&#96; (\n\t  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n\t  &#96;number&#96; varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n\t  PRIMARY KEY (&#96;id&#96;),\n\t  KEY &#96;unique&#96; (&#96;number&#96;)\n\t) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci\n\n\n\nCREATE TABLE &#96;infos&#96; (\n\t  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n\t  &#96;name&#96; varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n\t  &#96;age&#96; bigint(20) DEFAULT NULL,\n\t  PRIMARY KEY (&#96;id&#96;),\n\t  KEY &#96;unique&#96; (&#96;name&#96;)\n\t) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci\n\n\n\n CREATE TABLE &#96;card_infos&#96; (\n\n\t\t&#96;card_number&#96; varchar(255) COLLATE utf8_unicode_ci NOT NULL,\n\t\t&#96;name&#96; varchar(255) COLLATE utf8_unicode_ci NOT NULL,\n\t\tPRIMARY KEY (&#96;card_number&#96;,&#96;name&#96;),\n\t\tKEY &#96;fk_card_infos_info&#96; (&#96;name&#96;),\n\t\t-- fk  card_infos  c_credit_card\n\t\t-- FOREIGN KEY REFERENCES 与 gorm 中的关联标签无关\n\t\tCONSTRAINT &#96;fk_card_infos_c_credit_card&#96; FOREIGN KEY (&#96;card_number&#96;) REFERENCES &#96;c_credit_cards&#96; (&#96;number&#96;),\n\t\t-- fk  card_infos  info\n\t\t-- FOREIGN KEY REFERENCES 与 gorm 中的关联标签无关\n\n    -- 理解：\n\t\t-- 关联表的 FOREIGN KEY 描述的是 关联表 的字段\n\t\t-- gorm 中的关联标签描述的是 父表 的字段\n\n    -- 理解：\n\t\t-- 关联表的 REFERENCES 描述的是 关联表 与哪张表的哪个字段建立关系\n\t\t-- gorm中的 REFERENCES  描述的是 引用表的 字段与连接表的映射字段\n\n\n\t\tCONSTRAINT &#96;fk_card_infos_info&#96; FOREIGN KEY (&#96;name&#96;) REFERENCES &#96;infos&#96; (&#96;name&#96;)\n\n\t) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci\n\n\n\n关联标签顺序可随意经测试，随便放都是 OK 的\n&#x2F;&#x2F; 顺序无关\nInfos []Info &#96;gorm:&quot;many2many:card_infos;joinForeignKey:card_number;joinReferences:namem;foreignKey:Number;references: Name&quot;&#96;\n","slug":"2022-10-20gorm关联","date":"2022-10-20T08:46:50.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"5920bc0e327b10c465c146c4b5f81619","title":"前端基础-js表达式","content":"1. 逗号操作符, 没你想象的那么简单对它的每个操作数求值（从左到右），并返回最后一个操作数的值。\nlet x &#x3D; 1;\n\nx &#x3D; (x++, x); &#x2F;&#x2F; x++  等价于 x+&#x3D;1\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 2\n\nx &#x3D; (2, 3);\n\nconsole.log(x);\n&#x2F;&#x2F; expected output: 3\n\n2. super\n在类中使用 super\n调用父类上的静态方法\n删除 super 上的属性将抛出异常\nsuper.prop 不能覆写不可写属性\n\n\n在对象字面量中使用 super.prop (先用 Object.setPrototypeOf() 建立关系)\n\n见\n3. voidvoid 运算符对给定的表达式进行求值，然后返回 undefined。const output &#x3D; void 1;\nconsole.log(output);\n&#x2F;&#x2F; expected output: undefined\n\nvoid console.log(&#39;expression evaluated&#39;);\n&#x2F;&#x2F; expected output: &quot;expression evaluated&quot;\n\nvoid (function iife() &#123;\n  console.log(&#39;iife is executed&#39;);\n&#125;)();\n&#x2F;&#x2F; expected output: iife is executed\n\nvoid function test() &#123;\n  console.log(&#39;test function executed&#39;);\n&#125;;\ntry &#123;\n  test();\n&#125; catch (e) &#123;\n  console.log(&#39;test function is not defined&#39;);\n  &#x2F;&#x2F; expected output: &quot;test function is not defined&quot;\n&#125;\n\n&#x2F;&#x2F; &gt; undefined\n&#x2F;&#x2F; &gt; &quot;expression evaluated&quot;\n&#x2F;&#x2F; &gt; &quot;iife is executed&quot;\n&#x2F;&#x2F; &gt; &quot;test function is not defined&quot;\n\n优先级高于比较运算符void 2 &#x3D;&#x3D;&#x3D; &#39;2&#39;; &#x2F;&#x2F; (void 2) &#x3D;&#x3D;&#x3D; &#39;2&#39;，返回 false\nvoid (2 &#x3D;&#x3D;&#x3D; &#39;2&#39;); &#x2F;&#x2F; void (2 &#x3D;&#x3D;&#x3D; &#39;2&#39;)，返回 undefined\n\n立即调用的函数表达式\n在所有的一元运算符中，void 提供了最好的语义，因为它明确表示函数调用的返回值应该被丢弃\n比用圆括号包裹函数表达式要长一些，圆括号的作用是强迫 function 关键字被解析为表达式的开始，而不是语句\n\njavascript url当用户点击一个以 javascript: 开头的 URI 时，它会执行 URI 中的代码，然后用返回的值替换页面内容，除非返回的值是 undefined。void 运算符可用于返回 undefined\n&lt;a href&#x3D;&quot;javascript:void(0);&quot;&gt; 这个链接点击之后不会做任何事情 &lt;&#x2F;a&gt;\n\n&lt;a href&#x3D;&quot;javascript:void(document.body.style.backgroundColor&#x3D;&#39;green&#39;);&quot;&gt; 点击这个链接会让页面背景变成绿色。 &lt;&#x2F;a&gt;\n\n\n\n\n\n\n\n\nWARNING\n利用 javascript: 伪协议来执行 JavaScript 代码是不推荐的，推荐的做法是为链接元素绑定事件\n\n在箭头函数中避免泄漏箭头函数标准中，允许在函数体不使用括号来直接返回值。如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用。安全起见，当函数返回值不会被使用到的时候，应该使用 void 运算符，来确保 API 改变时，并不会改变箭头函数的行为。\nbutton.onclick &#x3D; () &#x3D;&gt; void doSomething();\n&#x2F;&#x2F; 这确保了当 doSomething 的返回值从 undefined 变为 true 的时候，不会改变代码的行为。\n\nvoid 运算符\n4. await\nawait 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。\n\n若 Promise 正常处理 (fulfilled)，其回调的 resolve 函数参数作为 await 表达式的值，继续执行 async function。\n\n若 Promise 处理异常 (rejected)，await 表达式会把 Promise 的异常原因抛出\n\n若 await 操作符后的表达式的值不是一个 Promise，则返回该值本身\n\n\n&#x2F;&#x2F; 例1\nasync function f3() &#123;\n  var z &#x3D; await Promise.reject(30);\n&#125;\nf3(); &#x2F;&#x2F; 报错  Uncaught (in promise)\n\n&#x2F;&#x2F; 例2 try catch\nasync function f3() &#123;\n  try &#123;\n    var z &#x3D; await Promise.reject(30);\n  &#125; catch (e) &#123;\n    console.log(e); &#x2F;&#x2F; 30\n  &#125;\n&#125;\nf3(); &#x2F;&#x2F; 报错  Uncaught (in promise)\n\n&#x2F;&#x2F; 例3 .catch捕获\nasync function f3() &#123;\n  var z &#x3D; await Promise.reject(30);\n&#125;\nf3().catch((e) &#x3D;&gt; &#123;\n  console.log(&#39;e&#39;, e); &#x2F;&#x2F; e 30\n&#125;);\n\n5. 解构赋值解构赋值语法是一种 Javascript 表达式。通过解构赋值，可以将“属性&#x2F;值”从对“象&#x2F;数组”中取出，赋值给其他变量。\n数组\n变量声明并赋值时的解构\n变量先声明后赋值时的解构\n默认值 （为了防止从数组中取出一个值为 undefined 的对象，可以在表达式左边的数组中为任意对象预设默认值。）\n交换变量\n解析一个从函数返回的数组\n忽略某些返回值 [,,] = f();\n将剩余数组赋值给一个变量\n用正则表达式匹配提取值\n\n对象\n基本赋值\n无声明赋值 var a, b; (&#123;a, b&#125; = &#123;a: 1, b: 2&#125;); 括号必须\n给新的变量名赋值\n默认值\n给新的变量命名并提供默认值 var &#123;a:aa = 10, b:bb = 5&#125; = &#123;a: 3&#125;;\n对象属性计算名和解构let key = &quot;z&quot;;let &#123; [key]: foo &#125; = &#123; z: &quot;bar&quot; &#125;;\n对象解构中的 Rest\n解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）\n\n&#x2F;&#x2F; 声明对象 和 自身 self 属性\nvar obj &#x3D; &#123; self: &#39;123&#39; &#125;;\n&#x2F;&#x2F; 在原型链中定义一个属性 prot\nobj.__proto__.prot &#x3D; &#39;456&#39;;\n&#x2F;&#x2F; test\nconst &#123; self, prot &#125; &#x3D; obj;\n&#x2F;&#x2F; self &quot;123&quot;\n&#x2F;&#x2F; prot &quot;456&quot;（访问到了原型链）\n\n函数\n函数参数默认值\n从作为函数实参的对象中提取数据\n\n解构嵌套对象和数组let &#123;\n  title: englishTitle, &#x2F;&#x2F; rename\n  translations: [\n    &#123;\n      title: localeTitle, &#x2F;&#x2F; rename\n    &#125;,\n  ],\n&#125; &#x3D; metadata;\n\nFor of 迭代和解构for (var &#123;\n  name: n,\n  family: &#123; father: f &#125;,\n&#125; of people) &#123;\n  console.log(&#39;Name: &#39; + n + &#39;, Father: &#39; + f);\n&#125;\n\n6. nullnull 的作用\n值 null 是一个字面量，不像 undefined，它不是全局对象的一个属性。\nnull 表示缺少的标识，表示变量未指向任何对象。\n把 null 作为尚未创建的对象，也许更好理解。\n在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。\n\nnull 与 undefined 的不同点：当检测 null 或 undefined 时\ntypeof null; &#x2F;&#x2F; &quot;object&quot; (因为一些以前的原因而不是&#39;null&#39;)\ntypeof undefined; &#x2F;&#x2F; &quot;undefined&quot;\n\nnull &#x3D;&#x3D;&#x3D; undefined; &#x2F;&#x2F; false\n\n&#x2F;&#x2F; 1 + null &#x3D; 1\n&#x2F;&#x2F; 1 + undefined &#x3D; NaN\n\nisNaN(1 + null); &#x2F;&#x2F; false\nisNaN(1 + undefined); &#x2F;&#x2F; true\n\nNumber.isNaN(1 + null); &#x2F;&#x2F; false\nNumber.isNaN(1 + undefined); &#x2F;&#x2F; true\n\nNumber.isNaN 与 isNaN 的区别在 JavaScript 中，isNaN() 函数可以用来判断一个值是否为 NaN。然而，该函数有一个不足之处，就是它会先将参数转换为数字类型再进行判断，因此可能会得出错误的结果。\n为了解决这个问题，ES6 引入了 Number.isNaN() 静态方法。它与 isNaN() 不同的地方在于，它只对数字类型的值且为 NaN 时返回 true，其他情况均返回 false。\n示例代码：\nisNaN(&#39;hello&#39;); &#x2F;&#x2F; true，因为 &quot;hello&quot; 被转换成了 NaN\nNumber.isNaN(&#39;hello&#39;); &#x2F;&#x2F; false，因为 &quot;hello&quot; 不是数字类型的 NaN\n\nisNaN(NaN); &#x2F;&#x2F; true\nNumber.isNaN(NaN); &#x2F;&#x2F; true\n\nisNaN(&#39;100&#39;); &#x2F;&#x2F; false，因为 &quot;100&quot; 能转换成数字 100\nNumber.isNaN(&#39;100&#39;); &#x2F;&#x2F; false，因为 &quot;100&quot; 不是数字类型的 NaN\n\nisNaN(true); &#x2F;&#x2F; false，因为 true 能转换成数字 1\nNumber.isNaN(true); &#x2F;&#x2F; false，因为 true 不是数字类型的 NaN\n\nisNaN(undefined); &#x2F;&#x2F; true\nNumber.isNaN(undefined); &#x2F;&#x2F; false，因为 undefined 不是数字类型\n\nisNaN(&#123;&#125;); &#x2F;&#x2F; true\nNumber.isNaN(&#123;&#125;); &#x2F;&#x2F; false，因为 &#123;&#125; 不是数字类型\n\n因此，当需要检查一个值是否为数字类型的 NaN 时，应该使用 Number.isNaN() 方法。\n7. newnew 关键字做了什么见 -->\n\nnew 操作符创建一个新的对象，将其 __proto__ 属性指向构造函数的原型，然后执行构造函数并将 this 指向新的对象，最后将新的对象返回。\n手写一个简单的 new 方法示例：\nfunction myNew(constructor, ...args) &#123;\n  &#x2F;&#x2F; 创建一个空对象并将其 __proto__ 属性指向构造函数的原型\n  const obj &#x3D; Object.create(constructor.prototype);\n\n  &#x2F;&#x2F; 执行构造函数并将 this 指向新对象\n  const result &#x3D; constructor.apply(obj, args);\n\n  &#x2F;&#x2F; 返回新对象或构造函数返回的对象\n  return result instanceof Object ? result : obj;\n&#125;\n\n这里的 ...args 表示使用了剩余参数语法，可以将传入 myNew 方法的第二个参数及以后的参数都存储到一个数组中。在执行构造函数时，将这个数组作为参数传入，可以让我们在不知道构造函数参数个数的情况下也能使用 myNew 方法来创建对象。\n自定义对象创建一个用户自定义的对象需要两步：\n\n通过编写函数来定义对象类型。（创建一个指定其名称和属性的函数）\n通过 new 来创建对象实例。\n\n8. new.targetnew.target 是一个在构造函数中使用的元属性(meta property)，它返回被 new 关键字调用的构造函数的引用。\n当一个构造函数被直接调用时，new.target 为 undefined，但当它通过 new 关键字调用时，new.target 将是指向该构造函数本身。这个特性可以在构造函数中判断是否被 new 关键字调用，并根据情况采取不同的行为，例如：\nfunction Foo() &#123;\n  if (!new.target) &#123;\n    throw new Error(&#39;Foo() must be called with new&#39;);\n  &#125;\n  console.log(&#39;Foo instantiated with new&#39;);\n&#125;\n\nFoo(); &#x2F;&#x2F; Throws an error\nnew Foo(); &#x2F;&#x2F; Logs &quot;Foo instantiated with new&quot;\n\n使用 new.target，开发者可以编写出更加灵活和健壮的构造函数，并更好地控制程序的行为。\n\nDetails\n组成\nnew.target 语法由一个关键字”new”，一个点，和一个属性名”target”组成。\n作用\n通常”new.”的作用: 是提供属性访问的上下文，但这里&quot;new.&quot;其实不是一个真正的对象。\nnew.target属性允许你检测函数或构造方法是否是通过 new 运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。\n不同函数中的区别\n不过在构造方法调用中，new.target 指向被 new 调用的构造函数，所以”new.”成为了一个虚拟上下文。\n在普通的函数调用中， new.target 的值是 undefined。\n在 arrow functions 中，new.target 指向最近的外层函数的 new.target\n见\n\n9. window&#x2F;&#x2F; 这个恒成立\nwindow.window.window.(无论多少个.window).window &#x3D;&#x3D;&#x3D; window\n&#x2F;&#x2F; 全局\n&#x2F;&#x2F; this.window &#x3D;&#x3D;&#x3D; window\n&#x2F;&#x2F; this &#x3D;&#x3D;&#x3D; window\n\n为什么 window.window &#x3D;&#x3D;&#x3D; window\n因为在浏览器环境下，全局对象 window 是唯一的，且每个 window 对象都是它自身的全局对象，所以 window.window 即为 window。\n将 window 属性指向该 window 对象本身的目的，是为了更容易引用全局对象\n\n10. this在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）this 不能在执行期间被赋值, 并且在每次函数被调用时 this 的值也可能会不同。\nES5 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。ES2015 引入了箭头函数，箭头函数不提供自身的 this 绑定（this 的值将保持为闭合词法上下文的值）。\n全局上下文函数上下文eval 上下文 中执行同普通函数几种情况函数上下文中的 thisvar obj &#x3D; &#123;\n  bar: function () &#123;\n    var x &#x3D; () &#x3D;&gt; this;\n    return x;\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 作为 obj 对象的一个方法来调用 bar，把它的 this 绑定到 obj。\n&#x2F;&#x2F; 将返回的函数的引用赋值给 fn。\nvar fn &#x3D; obj.bar();\n\n&#x2F;&#x2F; 直接调用 fn 而不设置 this，\n&#x2F;&#x2F; 通常 (即不使用箭头函数的情况) 默认为全局对象\n&#x2F;&#x2F; 若在严格模式则为 undefined\nconsole.log(fn() &#x3D;&#x3D;&#x3D; obj); &#x2F;&#x2F; true\n\n箭头函数作为构造函数当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。\n派生类在调用 super() 之前引用 this 会抛出错误。\n原因：\n派生类的构造函数没有初始的 this 绑定。在构造函数中调用 super() 会生成一个 this 绑定，并相当于执行如下代码，Base 为基类：\nthis &#x3D; new Base();\n\nthis 和对象转换 call&#x2F;applybind 方法作为对象的方法当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象。\n原型链中的 this如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样\ngetter 与 setter 中的 this用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。\n如：\nObject.defineProperty(o, &#39;sum&#39;, &#123;\n  get: sum,\n  enumerable: true,\n  configurable: true,\n&#125;);\n\n作为一个 DOM 事件处理函数当函数被用作事件处理函数时，它的 this 指向触发事件的元素\n（一些浏览器在使用非addEventListener 的函数动态地添加监听函数时不遵守这个约定）\n作为一个内联事件处理函数当代码被内联 on-event 处理函数 (en-US) 调用时，它的 this 指向监听器所在的 DOM 元素：\n类中的 this(补充)类声明和类表达式的主体都执行在严格模式下 同样遵循谁调用指向谁：\n\n实例调用实例方法，指向实例\n类调用静态方法，指向类\n实例方法、类的静态方法， 在全局调用，由于是严格模式，所以 this 是 undefined\n\n综上总结如下：\n\n11. Error当运行时错误产生时，Error 对象会被抛出。Error 对象也可用于用户自定义的异常的基础对象\n构造函数Error创建一个新的 Error 对象\n错误类型\nTypeError 变量或参数不属于有效类型\nRangeError 数值变量或参数超出其有效范围\nReferenceError 无效引用\nSyntaxError 语法错误\nEvalError 与 eval() 有关\nURLError 给 encodeURI() 或 decodeURI() 传递的参数无效。\nInternalError 代表 Javascript 引擎内部错误的异常抛出的实例。如：递归太多\nAggregateError 包裹了由一个操作产生且需要报告的多个错误 如：Promise.any() 产生的错误\n\n可使用 instanceof 关键字，处理特定错误\n组成部分\n错误文件路径 Error.prototype.fileName\n错误行号 Error.prototype.lineNumber\n错误列号 Error.prototype.columnNumber\n错误原因 Error.prototype.cause\n错误名 Error.prototype.name\n错误消息 Error.prototype.message\n错误堆栈跟踪 Error.prototype.stack\n\n助记忆\n\n在哪里产生的错误： filename、lineNumber、columnNumber\n错误栈是什么：stack\n错误信息有哪些：name、message、cause\n\n","slug":"2022-10-19js表达式","date":"2022-10-19T10:00:07.000Z","categories_index":"前端基础","tags_index":"前端基础,chatGPT2021","author_index":"举手摘月亮"},{"id":"42065b7e430b2dd22177e0c97bc4c0bd","title":"Mysql 刚好遇到","content":"数据库密码修改# 登陆 原密码 12345678,为了保证同一份代码可以在两台电脑上，无差别运行，密码改成一致的123456\n👑 ~ $ mysql -u root -p\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 9\nServer version: 5.7.18 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2017, Oracle and&#x2F;or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and&#x2F;or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n# 修改密码\nmysql&gt; set password for root@localhost &#x3D; password(&#39;123456&#39;)\n    -&gt; ;\nQuery OK, 0 rows affected, 1 warning (0.01 sec)\n\nmysql&gt; quit\nBye\n# 重新登陆\n👑 ~ $ mysql -u root -p\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 10\nServer version: 5.7.18 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2017, Oracle and&#x2F;or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and&#x2F;or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt;\n\n基本操作命令查看、删除，比管理工具要方便\n# 查看数据库\nmysql&gt; show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| api_data           |\n| basic_platform     |\n| cache_data         |\n| cnpmcore           |\n| cnpmjs             |\n| cnpmjs_test        |\n| learn-gorm         |\n| mysql              |\n| nest-app           |\n| performance_schema |\n| sys                |\n| test               |\n| ty_feedback      |\n| ty_rms           |\n+--------------------+\n15 rows in set (0.00 sec)\n# 使用数据库\nmysql&gt; use learn-gorm;\nDatabase changed\nmysql&gt; show tables;\nEmpty set (0.01 sec)\n# 查看表\nmysql&gt; show tables;\n+----------------------+\n| Tables_in_learn-gorm |\n+----------------------+\n| dogs                 |\n| girl_gods            |\n+----------------------+\n2 rows in set (0.00 sec)\n# 查看表信息\nmysql&gt; desc dogs;\n+-------------+---------------------+------+-----+---------+----------------+\n| Field       | Type                | Null | Key | Default | Extra          |\n+-------------+---------------------+------+-----+---------+----------------+\n| id          | bigint(20) unsigned | NO   | PRI | NULL    | auto_increment |\n| created_at  | datetime(3)         | YES  |     | NULL    |                |\n| updated_at  | datetime(3)         | YES  |     | NULL    |                |\n| deleted_at  | datetime(3)         | YES  | MUL | NULL    |                |\n| name        | longtext            | YES  |     | NULL    |                |\n| girl_god_id | bigint(20) unsigned | YES  | MUL | NULL    |                |\n+-------------+---------------------+------+-----+---------+----------------+\n6 rows in set (0.01 sec)\n\nmysql&gt;\n\nkey、primary key、unique key、index 区别见， 没看懂\nmysql 命令行清屏linux\nctrl + l\n\nselect … for update 查询select 查询是不加锁的，select…for update 是会加锁的，而且是悲观锁，但是在不同查询条件时候加的锁的类型（行锁，表锁）是不同的。\nselect * from t_user where id &#x3D; 1 for update；\n\n\n在 where 后面查询条件是主键索引，唯一索引时候是行锁查询条件是普通字段时候加的是表锁\n数据库锁sql 语句对数据库表进行加锁和解锁, 一脸懵逼\nMySQL HAVING 用法使用gorm 子查询\nMySQL HAVING 用法\n什么时候用什么时候用 WHERE 什么时候使用 HAVING 呢？\n\nWHERE 子句 &#x3D; 指定行所对应的条件\nHAVING 子句 &#x3D; 指定组所对应的条件\nWHERE 处理速度比 HAVING 处理速度高\n聚合键所对应的条件不应该书写在 HAVING 子句当中，而应该书写在 WHERE 子句当中。\n\n作者：RicherYY链接：https://www.jianshu.com/p/7701bf10167b来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nmysql insert ignore into见\ninsert ignore into : 忽略重复的记录，直接插入数据。\n1、插入的数据是主键冲突时\ninsert ignore into 会给出 warnings，show warnings 就可以看到提示主键冲突；并且本次插入无效\nQuery OK, 0 rows affected, 3 warnings (0.01 sec)\n2、没有主键冲突时，直接插入数据\ninsert into 与 insert ignore into 都是直接插入数据\nmysql 如何对多个行数据，执行不同的更新操作TODO：? 只能用循环执行多次 Update? 有没有并发执行？\nmysql 命令行执行命令加上注释mysql&gt; show create table  users \\G; #hello\n-- *************************** 1. row ***************************\n--        Table: users\n-- Create Table: CREATE TABLE &#96;users&#96; (\n--   &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n--   &#96;created_at&#96; datetime(3) DEFAULT NULL,\n--   &#96;updated_at&#96; datetime(3) DEFAULT NULL,\n--   &#96;deleted_at&#96; datetime(3) DEFAULT NULL,\n--   &#96;name&#96; varchar(255) DEFAULT NULL,\n--   PRIMARY KEY (&#96;id&#96;),\n--   KEY &#96;idx_users_deleted_at&#96; (&#96;deleted_at&#96;)\n-- ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4\n-- 1 row in set (0.00 sec)\n\n索引条件是辅助索引，先找到主索引，通过主索引找到数据记录\n\n\n这里涉及到一个优化：\n如果通过辅助索引，查到覆盖索引相关字段，就不用做二次查询，也就是上图的 ②，省了一次查询自然快很多；\n如果 select 的内容不在覆盖索引字段中，会启动二次查询，所以吧，不要用select *\ngorm 索引不是很懂，抱着怀疑态度，学习下mysql 索引相关Mysql 底层原理系列\n什么是 B 树 B+树 B-树+号，-号什么意思？\n为什不用 hash 而用 b+树演示链接： https://www.cs.usfca.edu/~galles&#x2F;visualization&#x2F;Algorithms.html\n\nhash 无序，查询中&gt;、&lt; 等无效，值不同 hash 可能相同\n\n比较&#x2F;进化平衡树：左子树个数 几乎等于 右子树个数，随数据量增加，查询越来越慢 （存在回旋查找）\nData Structure Visualizations 平衡树\nB 树：相对 平衡树，高度变矮，查询速度自然快（存在回旋查找）Data Structure Visualizations B 树\nB+树：为了解决 B 树回旋查找的问题Data Structure Visualizations B+树\n\n非叶子节点：存 K\n叶子节点：存 K-V\n查询节点 1 与查询节点 10，会比 B 树多一步，其他节点与 B 查询次数一致\n回旋问题：直接通过叶子节点解决（因为叶子节点的链表是有序的）\n\nSQL_NO_CACHE不使用缓存来查询数据\n百万数据 sql 优化优化前\n\n优化后\n\n最左原则\n\n破坏最左原则\n\n\n\n不对索引做一些运算操作\n\n索引不要放在范围查询右侧\n\n减少select *\n\nlike 没用到索引这种索引失效\n\n\n失效的索引也可以进行优化，使用覆盖索引\n时间介于无索引和有索引之间\n\n\n索引有效\n\n\norder by优化前\n优化后\n这种适用范围小，视频说要在代码中放内存中进行排序\nmysql 中的坑https://www.bilibili.com/video/BV1pg411A7p3\n\n遇到字段 null 值，count 数据丢失 解决: 用主键，或数字\ndistinct 数据丢失，也是 null 引起\n执行&lt;&gt; 、!=查询，遇到 null 丢数据， 解决:需要 or isNull(column名)\nnull 会导致 sum 求和时候，返回 null 而非 0， 会发生异常， 这个看需求把 null 做 0 处理，避开 null,视频讲错了，视频统计值最终为 0\n!=null 和 &lt;&gt;null的查询不到数据，应该使用 !isNull(column名)\n\nexplain 来分析查询计划\n\n查看连接数show PROCESSLIST\n\n参考链接MySQL 数据库的基础操作MySQL 修改密码的 3 种方式\n","slug":"2022-10-19mysql","date":"2022-10-19T01:13:08.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"举手摘月亮"},{"id":"ef92ce33f7630db6de42bc09728ad0ae","title":"Web api history","content":"historyhttps://developer.mozilla.org/en-US/docs/Web/API/History\nreplaceState 不刷新页面更改页面参数不刷新页面\n\n用来存 hash\n用来存页面查询参数\n\n&#x2F;#&#x2F;post&#x2F;2022-10-14useSearchParams\nscrollRestoration 滚动恢复属性auto将恢复用户已滚动到的页面上的位置。\nmanual未还原页上的位置。用户必须手动滚动到该位置\n主要来说下这个东西，直接拿 《菜鸟教程》 演示\n\n\n参考链接https://developer.mozilla.org/en-US/docs/Web/API/History\n","slug":"2022-10-18history","date":"2022-10-18T08:36:43.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"abbf797f56f759efd8b49b85ff4481ae","title":"js面试题","content":"B 站爬取脚本var list &#x3D; document.getElementsByClassName(&quot;video-list&quot;)[0];\n\nArray.from(list.children).forEach((item) &#x3D;&gt; &#123;\n  var t &#x3D; item.children[1].innerText;\n  document.body.append(t);\n\n  var br &#x3D; document.createElement(&quot;br&quot;);\n  document.body.append(br);\n&#125;);\n\njsjs 的 typeof 返回哪些数据类型string, boolean, number, undefined, function, object。\ntypeof console;\n&#x2F;&#x2F; &#39;object&#39;\ntypeof console.log;\n&#x2F;&#x2F; &#39;function&#39;\ntypeof console.log();\n&#x2F;&#x2F; &#39;undefined&#39;\n\n首先在 JS 中，分两种数据类型：\n基本数据类型： Number、String、Boolean、Null、 Undefined、Symbol（ES6），这些类型可以直接操作保存在变量中的实际值。同时要记住，这这些值他是存放在栈中的。\n引用数据类型： Object（在 JS 中除了基本数据类型以外的都是对象 )\n\n函数-Function 是对象\n数据-Array 是对象\n日期时间-Date 是对象\n正则表达式-Reg 是对象\n\n到目前为止，ECMAScript 标准中定义了 8 种数据类型，它们分别是 Undefined、Null、Number、Boolean、String、Symbol、BigInt、Object。————————————————版权声明：本文为 CSDN 博主「伍文亮」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_44963070/article/details/124046875\nJS 中 this 相关问题ajax、axios、fetch 的区别参考答案：\n（1）AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。\n\n它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。\n这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\n\n其缺点如下：\n\n本身是针对 MVC 编程，不符合前端 MVVM 的浪潮\n基于原生 XHR 开发，XHR 本身的架构不清晰\n不符合关注分离（Separation of Concerns）的原则\n配置和调用方式非常混乱，而且基于事件的异步模型不友好。\n\n（2）Fetch\n\nfetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。\nfetch 号称是 XMLHttpRequest 的替代品\nfetch 是基于 promise 设计的。\nfetch 的代码结构比起 ajax 简单多。\n\nfetch 的优点：\n\n脱离了 XHR，是 ES 规范里新的实现方式\n更加底层，提供的 API 丰富（request, response）\n基于标准 Promise 实现，支持 async&#x2F;await\n语法简洁，更加语义化\n\nfetch 的缺点：\n\nfetch 没有办法原生监测请求的进度，而 XHR 可以\n\nHTTP 404 状态并不被认为是网络错误。\n\nfetch 只对网络请求报错才会被 reject,其他情况会被 resolved 掉\n\n当遇到网络错误时，fetch() 返回的 promise 会被 reject，并传回 TypeError，虽然这也可能因为权限或其它问题导致。\n成功的 fetch() 检查不仅要包括 promise 被 resolve，还要包括 Response.ok 属性为 true。\n\n\nfetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: &#39;include&#39;})\n\nfetch 支持 abort（利用 signal 结合 AbortController），不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 见\n\nAbortError： 请求被 AbortController.abort()终止。\n\nTypeError ：\n\nmethod 为get head 方法, 配置 body non-null 或者不是 undefined 时候\nurl 有误\n如果 fetch()接收到含有用户名和密码的 URL（例如 http://user:password@example.com），它将会抛出一个 TypeError 。\n请求头配置有误\ncache 字段为only-if-cached， mode不是 same-origin\nno-cors 非 get、head、post 时候会报错\n\n\n\n（3）Axios Axios 是一种基于 Promise 封装的 HTTP 客户端，其特点如下：\n\n浏览器端发起 XMLHttpRequests 请求, node 端发起 http 请求\n支持 Promise API\n监听请求和返回\n对请求和返回进行转化\n取消请求\n自动转换 json 数据\n客户端支持抵御 CSRF 攻击\n\nfor…in 和 for…of 的区别\nfor…of 循环是 ES6 新增的遍历方法。\n\nfor…of 循环可用于数组/类数组，包括字符串、数组、Set 和 Map 结构、某些类似数组的对象(比如 arguments 对象、DOM NodeList 对象)、Generator 对象；\n\n对于普通的对象，for...of 循环不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。for...of 循环遍历得到键值。\n\nfor…in 循环不适用于遍历数组，主要是为了遍历对象而生，但是只能获得对象的键名，不能直接获得键值。\n\n对于数组的遍历，for…in 循环会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)；for…of 循环只返回数组的下标对应的属性值。\n\nfor…in 循环会遍历对象的整个原型链，性能非常差不推荐使用；而 for…of 循环只遍历当前对象不会遍历原型链。\n\n\n作者：光头络腮胡链接：https://juejin.cn/post/7148367249257005086来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\njavascript 提前终止循环哪些循环可以提前终止掉循环\n\nfor 循环\nfor...in\nsome\nevery\n\n\n\n\n序号\n方法\nbreak\ncontinue\nreturn\nreturn true\nreturn false\n结论\n\n\n\n1\nfor 循环\n成功\n跳出本次循环\n不合法\n不合法\n不合法\n√\n\n\n2\nArray.forEach()\n不合法\n不合法\n跳出本次循环\n跳出本次循环\n跳出本次循环\n×\n\n\n3\nfor…in\n成功\n跳出本次循环\n不合法\n不合法\n不合法\n√\n\n\n4\nArray.map()\n不合法\n不合法\n跳出本次循环\n跳出本次循环\n跳出本次循环\n×\n\n\n5\nArray.some()\n不合法\n不合法\n跳出本次循环\n成功\n跳出本次循环\n√\n\n\n6\nArray.every()\n不合法\n不合法\n成功\n跳出本次循环\n成功\n√\n\n\n7\nArray.filter()\n不合法\n不合法\n跳出本次循环\n跳出本次循环\n跳出本次循环\n×\n\n\n如何判断一个对象是否属于某个类？instanceof\nObject.prototype.toString.call()\n谈谈尾调用及其好处？是什么尾调用指的是函数的最后一步调用另一个函数。\n我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。\n好处使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。\n但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\nescape、encodeURI、encodeURIComponent 的区别\nencodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。\nencodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。\nescape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，\nescape 是直接在字符的 unicode 编码前加上 %u，\nencodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。\n\n\n\nisNaN 和 Number.isNaN 函数的区别？isNaN 接收参数，会尝试将这个参数转化成数值，任何不能被转换为数值的值都会返回 true,因此非数字值传入也会返回 true,会影响 NaN 的判断。\nNumber.isNaN 也会首先判断传入的参数是否为数字，如果是数字再继续判断是否为 NaN，不会进行数据类型的转化，这种方法对 NaN 的判断更准确\n说说你对堆区和栈区的理解数据结构：(1)、栈：栈在数据结构中的特性是后进先出的特性。(2)、堆：对在数据结构中是一个优先队列，按照优先级进行排序，其中完全二叉树是堆数据结构的一个实现。\n操作系统：在操作系统中将内存分为栈区和堆区。(1)、栈：基本的数据类型，函数参数等存放在栈中，是计算机自动分配的内存空间(2)、堆：一些函数，对象等数据类型的数据存放在堆中，堆中的内存程序员自己进行分配和释放，如果程序员不释放，在程序执行结束后，系统会自动释放。————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/122503152\n说说 Ajax 组成部分Asynchronous JavaScript and XML\nJavaScript 中 BOM 与 DOM 的区别BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器\nDOM（document object model）：文档对象模型，提供操作页面元素的方法和属性\nJavascript 由三部分构成，ECMAScript，DOM 和 BOM\n\nECMAScript(核心) , 描述了 JS 的语法和基本对象\nBOM 是浏览器对象模型 , 提供与浏览器交互的方法和接口。各个浏览器厂商根据 DOM 在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同]\nDOM 是文档对象模型 , 处理网页内容的方法和接口。是 W3C 的标准； [所有浏览器公共遵守的标准]\n\nBOM\n比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数\nWindow 对象包含属性：document、location、navigator、screen、history、framesDocument 根节点包含子节点：forms、embeds、anchors、images、links\n从 window.document 已然可以看出，DOM 的最根本的对象是 BOM 的 window 对象的子对象。\n由于 BOM 的 window 包含了 document，因此可以直接使用 window 对象的 document 属性，通过 document 属性就可以访问、检索、修改 XHTML 文档内容与结构。\n因为 document 对象又是 DOM（Document Object Model）模型的根节点。\n可以说，BOM 包含了 DOM(对象)，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象，从而 js 可以操作浏览器以及浏览器读取到的文档。\nDOM\n这个 DOM 定义了一个 HTMLDocument 和 HTMLElement 做为这种实现的基础,就是说为了能以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素）\n总结：\n\n描述的范围不同: BOM 包含了 DOM(对象)，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象\n描述的内容不同: DOM 以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素），BOM 比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数\n\n作者：王小端 coder链接：https://juejin.cn/post/6844903939008102413来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n你是怎么理解闭包的？说下 JS 的基本数据类型use strict 及其作用？MDN use strict\n背景es5 的严格模式:\n在不使用严格模式时，程序猿开发的代码会有 sloppy 现象，严格模式是为了让程序员避免 sloppy 模式。\n为了形成与正常代码不同的语义，为此对正常的 JavaScript 语义做了一些更改从而使代码隐式地脱离“马虎模式/稀松模式/懒散模式“（sloppy）模式\n特点\n浏览器支持程度不同：\n不支持严格模式与支持严格模式的浏览器，在执行严格模式代码时会采用不同行为。\n不支持严格模式的浏览器，即使代码设置了严格模式，严格模式也不生效\n\n\n代码可混合共存：严格模式代码和非严格模式代码可以共存\n\n作用\n严格模式（对过去）：通过抛出错误来消除了一些原有静默错误。\n严格模式（对过去）：修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。\n严格模式（对未来）：为未来的 ECMAScript 版本铺平道路,禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。\n\n体现：将过失错误转成异常\n\n严格模式下无法再意外创建全局变量\n在严格模式下，试图删除不可删除的属性时会抛出异常\n严格模式会使引起静默失败 (silently fail，注：不报错也没有任何效果) 的赋值操作抛出异常 如：（给 NaN 赋值会抛出一个异常、给不可写属性赋值）\nGecko 版本 34 之前，严格模式要求一个对象内的所有属性名在对象内必须唯一\n严格模式要求函数的参数名唯一\n严格模式禁止八进制数字语法（ECMAScript 并不包含八进制语法， ECMAScript 6 中支持为一个数字加”0o”的前缀来表示八进制数）\n\n简化变量使用\n\n在严格模式下 eval 仅仅为被运行的代码创建变量，所以 eval 不会使得名称映射到外部变量或者其他局部变量：\n\n让 eval 和 arguments 变的简单\n\n\narguments\n名称 eval 和 arguments 不能通过程序语法被绑定 (be bound) 或赋值严格模式下，参数的值不会随 arguments 对象的值的改变而变化不再支持 arguments.callee\n更安全（有性能&#x2F;安全问题的不予实现）\n\n严格模式下，通过 this 传递给一个函数的值不会被强制转换为一个对象，对一个普通的函数来说，this 总会是一个对象，这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患\n\n在严格模式下，那么 fun.caller 和 fun.arguments 都是不可删除的属性而且在存值、取值时都会报错\n\n严格模式下的 arguments 不会再提供访问与调用这个函数相关的变量的途径，旧时的 ECMAScript 实现中 arguments.caller 曾经是一个对象，里面存储的属性指向那个函数的变量，有安全隐患，还会有性能问题。现在的浏览器没有实现这个\n\n\n继承原型链new 做了什么JavaScript 实际上执行的是：\n&#x2F;&#x2F; 这里并没有像很多面试题实现new那样，注意问题，new做了什么，而不是如何实现\nvar o &#x3D; new Object();\n&#x2F;&#x2F; 私有属性（称之为 __proto__）指向它的构造函数的原型对象（prototype\n&#x2F;&#x2F; 这里要注意下，实例对象的属性能不能改是配置决定，而不是是不是私有决定\no.__proto__ &#x3D; Foo.prototype;\nFoo.call(o);\n\n并发模型与事件循环为什么 js 是单线程这主要和 js 的用途有关，js 是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作 dom ；这决定了它只能是单线程，否则会带来很复杂的同步问题。举个例子：如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，此时浏览器就会一脸茫然，不知所措 。所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n进程、线程什么是进程:进程：是 cpu 分配资源的最小单位；（是能拥有资源和独立运行的最小单位）\n什么是线程:线程：是 cpu 调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n浏览器是多进程的？放在浏览器中，每打开一个 tab 页面，其实就是新开了一个进程，在这个进程中，还有 ui 渲染线程 、 js 引擎线程 、 http 请求线程等。 所以，浏览器是一个多进程的。\n为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准 ，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。\n宏微任务以及执行顺序JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队。1、宏任务: 用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调2、微任务: 用来保存待执行的微任务（回调），比如：promise 的回调、MutationObserver 的回调\nJS 执行时会区别这 2 个队列1、JS 引擎首先必须先执行所有的初始化同步任务代码2、每次在准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行 ，也就是微任务优先级比宏任务高，且与微任务所处的代码位置无关————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/124533748\n暂时性死区参考答案:暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取 , 直到声明变量的那一行代码出现 , 才可以获取和使用该变量。\nlet 、const 与暂时性死区let 或 const 声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。\n首先看看不具有暂时性死区的 var：当进入 var 变量的作用域（包围它的函数），立即为它创建（绑定）存储空间。变量会立即被初始化并赋值为 undefined。当执行到变量声明的时候，如果变量定义了值则会被赋值。\n通过 let 声明的变量拥有暂时性死区，生命周期如下：当进入 let 变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是未初始化的。获取或设置未初始化的变量将抛出异常 ReferenceError。当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为 undefined。\nconst 工作方式与 let 类似，但是定义的时候必须赋值并且不能改变\n闭包B 站：小甲鱼 鱼 C，讲闭包讲的很好\n闭包：不是 js 特有的，几乎所有的变成语言中，都存在闭包\n闭包包含自由（未绑定到特定对象）变量，这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在学过的编程语言中 js、oc、swift、android、kotlin、dart、golang、python 以及 Java（Java8 及以上）等语言中都能找到对闭包不同程度的支持。\n见百度百科\n面向对象的三大特性，分别说一下什么意思?1、封装: 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。\n对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。\n2、继承: 继承可以解决代码复用，让编程更加靠近人类思维。\n当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。\n3、多态: 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的引用，来调用在不同子类中实现的方法。\nPromise 和 async await 的区别1、概念:Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大\n简单地说，Promise 好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的。\nasync await也是异步编程的一种解决方案，他遵循的是 Generator 函数的语法糖 ，他拥有内置执行器 ，不需要额外的调用直接会自动执行并输出结果，它返回的是一个 Promise 对象。\n两者的区别:\n相同点\n\nasync await 与 Promise 一样，是非阻塞的\n\n不同点\n\n版本不同: promise 是 ES6，async&#x2F;await 是 ES7\n\n背景不同:2.1.  Promise 的出现是为了解决了传统 callback 函数导致的“地域回调”问题,语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。\n\n\n2.2.  而 async await 代码看起来会简洁些,使得异步代码看起来像同步代码, await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。\n\nasync await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数\n\n错误捕获 Promise 有.catch,async await 既可以用.then 又可以用 try-catch 捕捉\n\n\n补充： 2022-10-19js 表达式\nsetTimeout 值打印&#x2F;&#x2F; 输出 10个10\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(i);\n  &#125;, 100);\n&#125;\n\n&#x2F;&#x2F; 打印出0 - 9;\n\n&#x2F;&#x2F; var -&gt; let\nfor (let i &#x3D; 0; i &lt; 10; i++) &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(i);\n  &#125;, 100);\n&#125;\n&#x2F;&#x2F; 立即执行函数\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  (function (i) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(i);\n    &#125;, 100);\n  &#125;)(i);\n&#125;\n&#x2F;&#x2F; setTimeout传入参数的方式\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  setTimeout(\n    (n) &#x3D;&gt; &#123;\n      console.log(n);\n    &#125;,\n    100,\n    i\n  );\n&#125;\n\n立即执行函数有什么用，作用域是怎样的只有一个作用：创建一个独立的作用域。\n这个作用域里面的变量，外面访问不到（即避免「变量污染」）。\n什么是立即执行函数？有什么作用？\n默认类型转化？&#x2F;&#x2F; 打印出 1\nlet a &#x3D; ?\nif (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;\n  console.log(&#39;1&#39;)\n&#125;\n\nlet a &#x3D; &#123;\n  i: 1,\n  [Symbol.toPrimitive]() &#123;\n    return this.i++\n  &#125;\n&#125;\nif (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;\n  console.log(&#39;hhhhhh&#39;)\n&#125;\n\n\n\n实现原理 2022-11-01 抽象相等比较\nrequire 和 import 的区别？遵循规范：require 是 Commonjs 规范引入方式import 是 ES6 的一个语法标准，如果要兼容浏览器的话必须转化成 ES5 的语法\n调用时间：require 是运行时调用，所以 require 理论上可以运用在代码的任何地方import 是编译时调用，所以必须放在文件开头\n本质：require 是赋值过程。 module.exports 后面的内容是什么，require 的结果就是什么，比如对象、数字、字符串、函数等，然后再把 require 的结果赋值给某个变量，它相当于 module.exports 的传送门\nimport 是解构过程, 但是目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require\n导入导出require() | exports 的用法通过 require 引入基础数据类型时，属于复制该变量。通过 require 引入复杂数据类型时，属于浅拷贝该对象。\n导入模块 require() 的用法require() 函数用于在当前模块中加载别的模块。在函数内写入模块的路径即可（相对路径和绝对路径都行）\nexports 是 module.exports 的一种简写形式，不能直接给 exports 赋值。\n注意当直接给 module.exports 赋值时，exports 会失效。\n见\nsrc 和 href 的区别，并且 img 中的 srcset 的作用是什么src 和 href 的区别总结：\n\n资源：src 会将资源加载到标签所在的位置；href 用来建立与当前元素/文档之间的链接\n元素：src 用于 js 脚本、img、frame 等标签；href 用与 link、a 标签\n阻塞：src 会暂停其他资源的下载和处理，一般放到底部；link 会并行下载，不会阻塞\n\nsrc 是指向外部资源的位置，\n\n指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，如 js 脚本，img 图⽚和 frame 等元素。\n当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在底部⽽不是头部。\n\nhref 是指网络资源所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。比如 link 标签。\n知道 img 的 srcset 的作用是什么？可以设计响应式图片,我们可以使⽤两个新的属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择正确的⼀个资源。srcset 定义了我们允许浏览器选择的图像集，以及每个图像的⼤⼩。\n&lt;img\n  src&#x3D;&quot;.&#x2F;img&#x2F;1.jpg&quot;\n  srcset&#x3D;&quot;.&#x2F;img&#x2F;2.jpg 500w, .&#x2F;img&#x2F;3.jpg 1000w, .&#x2F;img&#x2F;4.jpg 1200w&quot;\n  sizes&#x3D;&quot;(max-width:500px) 600px, (max-width: 1000px) 1500px&quot;\n  alt&#x3D;&quot;&quot;\n&#x2F;&gt;\n&lt;!-- 这里size中max-width:500px表示最大为500px时,将其当做600px,然后和srcset进行匹配 --&gt;\n\n————————————————版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47450807/article/details/124214601\n还有哪⼀个标签能起到跟 srcset 相似作⽤？&lt;picture&gt;元素通过包含零或多个&lt;source&gt;元素和一个&lt;img&gt;元素来为不同的显示&#x2F;设备场景提供图像版本。\n浏览器会选择最匹配的⼦ &lt;source&gt; 元素，\n如果没有匹配的，就选择 &lt;img&gt; 元素的 src 属性中的 URL。\n然后，所选图像呈现在 &lt;img&gt; 元素占据的空间中。\n&lt;picture&gt;\n  &lt;source\n    srcset&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;surfer-240-200.jpg&quot;\n    media&#x3D;&quot;(min-width: 800px)&quot;\n  &#x2F;&gt;\n  &lt;img src&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;painted-hand-298-332.jpg&quot; &#x2F;&gt;\n&lt;&#x2F;picture&gt;\n\n存在哪些常用的 meta 标签？有哪些常⽤的 meta 标签？\n客户端渲染 与 服务器渲染 的区别？区分依据\nDOM 树在服务端生成还是在客户端生成的。\n服务端渲染的优点：\n1、尽量不占用前端的资源，前端这块耗时少，速度快。\n2、有利于 SEO（search engine optimization）优化，因为在后端有完整的 html 页面，所以爬虫更容易爬取信息。\n服务端渲染的缺点：\n1、不利于前后端分离，开发的效率降低了。\n2、对 html 的解析，对前端来说加快了速度，但是加大了服务器的压力。\n客户端渲染的优点：\n1、前后端分离，开发效率高。\n2、用户体验更好，我们将网站做成 SPA（单页面应用）或者部分内容做成 SPA，当用户点击时，不会形成频繁的跳转。\n客户端渲染的缺点：\n1、首屏响应速度慢。\n2、不利于 SEO 优化，因为爬虫不认识 SPA，所以它只是记录了一个页面。\n实际开发中\n见\n如何选择\n我们要根据业务场景去选择渲染的方式。\n如果是企业级网站，主要功能是页面展示，它没有复杂的交互，并且需要良好的 SEO，那我们应该使用服务端渲染。\n如果是后台管理页面，交互性很强，它不需要考虑到 SEO，那我们应该使用客户端渲染。\n具体使用哪种渲染方式也不是绝对的，现在很多网站使用服务端渲染和客户端渲染结合的方式：首屏使用服务端渲染，其他页面使用客户端渲染。这样可以保证首屏的加载速度，也完成了前后端分离。\n参考链接 escape、encodeURI、encodeURIComponent 的区别\n","slug":"2022-10-16js","date":"2022-10-16T15:17:54.000Z","categories_index":"js","tags_index":"js","author_index":"举手摘月亮"},{"id":"9e2838a04929d964c7bc52054867739d","title":"gorm","content":"githubhttps://github.com/go-gorm/gorm\n\nORM\n\norm 解决的问题专注于语言，弱化 sql\n\n\n\n\ngorm 内部如何实现GORM 内部使用 SQL builder 生成 SQL。\n对于每个操作，GORM 都会创建一个 *gorm.Statement 对象，所有的 GORM API 都是在为 statement 添加、修改 子句，最后，GORM 会根据这些子句生成 SQL\n自定义操作表名自定义外键自定义gorm 关系\n\n\n\ngorm First、Take、Last 区别\nFirst 获取第一条记录 （主键升序）\nTake 获取一条记录，没有指定排序字段\nLast 获取最后一条记录 （主键降序）\n\nFirst 和 Last 的使用有条件限制\n只有在目标 struct 是指针或者通过 db.Model() 指定 model 时，该方法才有效\n如果相关 model 没有定义主键，那么将按 model 的第一个字段进行排序\ngorm Find 与 Scan 的区别&#x2F;&#x2F; 超过一列的查询，应该使用 &#96;Scan&#96; 或者 &#96;Find&#96;，例如：\ndb.Select(&quot;name&quot;, &quot;age&quot;).Scan(&amp;users)\ndb.Select(&quot;name&quot;, &quot;age&quot;).Find(&amp;users)\n\ngorm Struct 与 Map 的区别相同点：\n都可做查询条件\n\n不同点：\n是否含有零值： struct 不包含零值查询条件 &amp;User&#123;键值对&#125;，map 包含零值查询条件 map[string]interface&#123;&#125;&#123;键值对&#125;\n指定查询 通过向 Where() 传入 struct 来指定查询条件的字段、值、表名（这个地方要注意拼接后的 sql 是否正常执行）\n\ndb.Where(&amp;User&#123;Name: &quot;jinzhu&quot;&#125;, &quot;name&quot;, &quot;Age&quot;).Find(&amp;users)\n&#x2F;&#x2F; SELECT * FROM users WHERE name &#x3D; &quot;jinzhu&quot; AND age &#x3D; 0;\n\ndb.Where(&amp;User&#123;Name: &quot;jinzhu&quot;&#125;, &quot;Age&quot;).Find(&amp;users)\n&#x2F;&#x2F; SELECT * FROM users WHERE age &#x3D; 0;\n\ngorm 哪些类型语句可以作查询\n主键\nsql 语句\nstruct 结构体\nmap\n\ngorm 哪些不会触发查询\nwhere 条件\nnot 条件\nor 条件\nselect 选择\norder 排序\nlimit &amp; offset (这里要注意 mysql 不支持 offset 单独使用)\n\ngorm 哪些会触发查询\nFirst 主键排序第一个\nLast 主键排序最后一个\nTake 无主键排序第一个\nFind\nScan\nPluck 只返回单列\nCount\n批查询，一次查询多少个，允许多次查询\nFirstOrInit 不更新数据库\nFirstOrCreate 查不到更新数据库\n\n\nvar user User\n\tdb.Debug().FirstOrInit(&amp;user, User&#123;Name: &quot;non_existing&quot;&#125;)\n\tdb.Debug().FirstOrCreate(&amp;user, User&#123;Name: &quot;non_create&quot;&#125;)\n\n\t&#x2F;&#x2F; 第一次查询\n\t&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:29:38 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:431\n\t&#x2F;&#x2F; [7.830ms] [rows:0] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_existing&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1\n\n\t&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:29:38 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:432\n\t&#x2F;&#x2F; [2.192ms] [rows:0] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_create&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1\n\n\t&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:29:38 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:432\n\t&#x2F;&#x2F; [38.437ms] [rows:1] INSERT INTO &#96;users&#96; (&#96;name&#96;,&#96;age&#96;,&#96;email&#96;,&#96;birthday&#96;,&#96;member_number&#96;,&#96;activated_at&#96;,&#96;created_at&#96;,&#96;updated_at&#96;,&#96;active&#96;) VALUES (&#39;non_create&#39;,18,NULL,NULL,NULL,NULL,&#39;2022-10-20 10:29:38.008&#39;,&#39;2022-10-20 10:29:38.008&#39;,true)\n\n\n\t&#x2F;&#x2F; 第二次查询\n\t&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:30:07 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:431\n\t&#x2F;&#x2F; [8.054ms] [rows:0] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_existing&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1\n\t&#x2F;&#x2F;\n\t&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:30:07 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:432\n\t&#x2F;&#x2F; [0.680ms] [rows:1] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_create&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1\n\n\t&#x2F;&#x2F; | 19 | galeone                           | NULL  |   18 | 2022-10-19 11:21:56.089 | NULL          | NULL         | 2022-10-19 11:21:56.090 | 2022-10-19 11:21:56.090 |      1 |\n\t&#x2F;&#x2F; | 20 | galeone                           | NULL  |   18 | 2022-10-19 11:26:50.011 | NULL          | NULL         | 2022-10-19 11:26:50.012 | 2022-10-19 11:26:50.012 |      1 |\n\t&#x2F;&#x2F; | 21 | 我要存false，不要默认true         | NULL  |   18 | 2022-10-19 11:28:52.852 | NULL          | NULL         | 2022-10-19 11:28:52.852 | 2022-10-19 11:28:52.852 |      0 |\n\t&#x2F;&#x2F; | 22 | non_create                        | NULL  |   18 | NULL                    | NULL          | NULL         | 2022-10-20 10:29:38.008 | 2022-10-20 10:29:38.008 |      1 |\n\t&#x2F;&#x2F; +----+-----------------------------------+-------+------+-------------------------+---------------+--------------+-------------------------+-------------------------+--------+\n\t&#x2F;&#x2F; 22 rows in set (0.01 sec)\n\nmysql offset &amp; limit 与 where &amp;limit\n\ngorm Model 与 Table 的区别GORM 允许扫描结果至 map[string]interface{} 或 []map[string]interface{}，此时别忘了指定 Model 或 Table\nresult :&#x3D; map[string]interface&#123;&#125;&#123;&#125;\ndb.Model(&amp;User&#123;&#125;).First(&amp;result, &quot;id &#x3D; ?&quot;, 1)\n\nvar results []map[string]interface&#123;&#125;\ndb.Table(&quot;users&quot;).Find(&amp;results)\n\ngorm 删除先了解这个，这个简单，不会太受 👊\n\n主键删除\n条件删除\n批量删除\n全局删除(规避)\n返回删除行的数据\n软删除\n查询被软删记录\n永久删除\n删除标记 Flag\n勾子暂时跳过\n\n主键删除\n传入一个实例地址 &amp;user\n结构体：db.Delete(&amp;User&#123;&#125;, string/number) // 结构体\n批量主键 db.Delete(&amp;users, []int&#123;1,2,3&#125;) // &amp;users\n\n条件删除db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete(&amp;email)\n批量删除\nlike 条件删除\n\n&#x2F;&#x2F; 这种叫啥，先where, 后删除\ndb.Where(&quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;).Delete(&amp;Email&#123;&#125;)\n&#x2F;&#x2F; DELETE from emails where email LIKE &quot;%jinzhu%&quot;;\n&#x2F;&#x2F; 结构体删除？\ndb.Delete(&amp;Email&#123;&#125;, &quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;)\n&#x2F;&#x2F; DELETE from emails where email LIKE &quot;%jinzhu%&quot;;\n\n全局删除(规避)\n有条件，且查到的结果是全部数据 Where 条件为&quot;true&quot; 都会清空\n原生 sql\nAllowGlobalUpdate\n\ndb.Delete(&amp;User&#123;&#125;).Error &#x2F;&#x2F; gorm.ErrMissingWhereClause\n\n&#x2F;&#x2F; 会清表\ndb.Where(&quot;1 &#x3D; 1&quot;).Delete(&amp;User&#123;&#125;)\n&#x2F;&#x2F; DELETE FROM &#96;users&#96; WHERE 1&#x3D;1\n\n&#x2F;&#x2F; Where条件为&quot;true&quot; 都会清空\nvar users []User\ndb.Debug().Where(&quot;1 &#x3D; 1&quot;).Find(&amp;users)\n&#x2F;&#x2F; [4.435ms] [rows:22] SELECT * FROM &#96;users&#96; WHERE 1 &#x3D; 1\ndb.Debug().Where(&quot;true&quot;).Find(&amp;users)\n\n&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:54:53 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:459\n&#x2F;&#x2F; [3.312ms] [rows:22] SELECT * FROM &#96;users&#96; WHERE true\n\ndb.Debug().Where(&quot;2&#x3D;2&quot;).Find(&amp;users)\n&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:54:53 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:460\n&#x2F;&#x2F; [0.305ms] [rows:22] SELECT * FROM &#96;users&#96; WHERE 2&#x3D;2\n\n\n\n&#x2F;&#x2F; 会清表\ndb.Exec(&quot;DELETE FROM users&quot;)\n&#x2F;&#x2F; DELETE FROM users\n&#x2F;&#x2F; 会清表\ndb.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: true&#125;).Delete(&amp;User&#123;&#125;)\n&#x2F;&#x2F; DELETE FROM users\n\n返回删除行的数据Clauses(clause.Returning&#123;&#125;) 仅适用于支持 Returning 的数据库\n&#x2F;&#x2F; 返回所有列\nvar users []User\nDB.Clauses(clause.Returning&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Delete(&amp;users)\n&#x2F;&#x2F; DELETE FROM &#96;users&#96; WHERE role &#x3D; &quot;admin&quot; RETURNING *\n&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 1, Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Salary: 100&#125;, &#123;ID: 2, Name: &quot;jinzhu.2&quot;, Role: &quot;admin&quot;, Salary: 1000&#125;&#125;\n\n&#x2F;&#x2F; 返回指定的列\nDB.Clauses(clause.Returning&#123;Columns: []clause.Column&#123;&#123;Name: &quot;name&quot;&#125;, &#123;Name: &quot;salary&quot;&#125;&#125;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Delete(&amp;users)\n&#x2F;&#x2F; DELETE FROM &#96;users&#96; WHERE role &#x3D; &quot;admin&quot; RETURNING &#96;name&#96;, &#96;salary&#96;\n&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 0, Name: &quot;jinzhu&quot;, Role: &quot;&quot;, Salary: 100&#125;, &#123;ID: 0, Name: &quot;jinzhu.2&quot;, Role: &quot;&quot;, Salary: 1000&#125;&#125;\n\n软删除\n引入 gorm.Model\n不引入 gorm.Model ， Deleted gorm.DeletedAt\n\n查询被软删记录Unscoped 译为： 未限定范围\ndb.Unscoped().Where(&quot;age &#x3D; 20&quot;).Find(&amp;users)\n&#x2F;&#x2F; SELECT * FROM users WHERE age &#x3D; 20;\n\n\n\n永久删除db.Unscoped().Delete(&amp;order)\n&#x2F;&#x2F; DELETE FROM orders WHERE id&#x3D;10;\n\n\n删除标记 Flag\nunix 时间戳\n1&#x2F;0 标记\n混合模式\n\nunix 时间戳type User struct &#123;\n  ID    uint\n  Name  string\n  &#x2F;&#x2F; DeletedAt *time.Time &#x2F;&#x2F; 我觉得吧还是使用这个，有删除时间，前端想展示就展示，不想展示就当false&#x2F;true处理\n  DeletedAt soft_delete.DeletedAt &#96;gorm:&quot;softDelete:milli&quot;&#96;\n  &#x2F;&#x2F; DeletedAt soft_delete.DeletedAt &#96;gorm:&quot;softDelete:nano&quot;&#96;\n&#125;\n\n&#x2F;&#x2F; 查询\nSELECT * FROM users WHERE deleted_at &#x3D; 0;\n\n&#x2F;&#x2F; 删除\nUPDATE users SET deleted_at &#x3D; &#x2F;* 当前毫秒、纳秒时间戳 *&#x2F; WHERE ID &#x3D; 1;\n\n\n1&#x2F;0 标记\nimport &quot;gorm.io&#x2F;plugin&#x2F;soft_delete&quot; &#x2F;&#x2F; 这里引入了个插件\n\ntype User struct &#123;\n  ID    uint\n  Name  string\n  IsDel soft_delete.DeletedAt &#96;gorm:&quot;softDelete:flag&quot;&#96; &#x2F;&#x2F; 这里使用tab进行标记\n&#125;\n\n&#x2F;&#x2F; 查询\nSELECT * FROM users WHERE is_del &#x3D; 0;\n\n&#x2F;&#x2F; 删除\nUPDATE users SET is_del &#x3D; 1 WHERE ID &#x3D; 1;\n\n混合模式type User struct &#123;\n  ID        uint\n  Name      string\n  DeletedAt time.Time &#x2F;&#x2F; 这个\n  IsDel     soft_delete.DeletedAt &#96;gorm:&quot;softDelete:flag,DeletedAtField:DeletedAt&quot;&#96; &#x2F;&#x2F; 使用 &#96;1&#96; &#96;0&#96; 标识\n  &#x2F;&#x2F; IsDel     soft_delete.DeletedAt &#96;gorm:&quot;softDelete:,DeletedAtField:DeletedAt&quot;&#96; &#x2F;&#x2F; 使用 &#96;unix second&#96; 标识\n  &#x2F;&#x2F; IsDel     soft_delete.DeletedAt &#96;gorm:&quot;softDelete:nano,DeletedAtField:DeletedAt&quot;&#96; &#x2F;&#x2F; 使用 &#96;unix nano second&#96; 标识\n&#125;\n\n&#x2F;&#x2F; 查询\nSELECT * FROM users WHERE is_del &#x3D; 0; &#x2F;&#x2F; 一个查询条件就够了\n&#x2F;&#x2F; 在gorm中，这里有个问题，如果find，在不加Unscoped会不会查不到呢？ TODO:\n\n&#x2F;&#x2F; 删除，比较两个都要改啊，这么用的场景是什么\nUPDATE users SET is_del &#x3D; 1, deleted_at &#x3D; &#x2F;* current unix second *&#x2F; WHERE ID &#x3D; 1;\n\n原生 SQL 和 SQL 生成器这个比较有用\n\ndb.Raw + Scan Raw：译为原生\ndb.Exec Exec： 执行\n\n&#x2F;&#x2F; db.Raw + Scan\ndb.Raw(&quot;SELECT id, name, age FROM users WHERE name &#x3D; ?&quot;, 3).Scan(&amp;result)\n\n&#x2F;&#x2F; db.Exec\ndb.Exec(&quot;UPDATE orders SET shipped_at &#x3D; ? WHERE id IN ?&quot;, time.Now(), []int64&#123;1, 2, 3&#125;)\n\n&#x2F;&#x2F; Exec with SQL Expression\ndb.Exec(&quot;UPDATE users SET money &#x3D; ? WHERE name &#x3D; ?&quot;, gorm.Expr(&quot;money * ? + ?&quot;, 10000, 1), &quot;jinzhu&quot;)\n\n\n命名参数GORM 支持 sql.NamedArg、map[string]interface{}{} 或 struct 形式的命名参数\n\ndb.Where(&quot;name1 &#x3D; @name OR name2 &#x3D; @name&quot;, sql.Named(&quot;name&quot;, &quot;jinzhu&quot;)).Find(&amp;user) &#x2F;&#x2F; name 替换前面的@name\n&#x2F;&#x2F; SELECT * FROM &#96;users&#96; WHERE name1 &#x3D; &quot;jinzhu&quot; OR name2 &#x3D; &quot;jinzhu&quot;\n\n&#x2F;&#x2F; map[string]interface&#123;&#125;&#123;&#125;\ndb.Where(&quot;name1 &#x3D; @name OR name2 &#x3D; @name&quot;, map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu2&quot;&#125;).First(&amp;result3)\n&#x2F;&#x2F; SELECT * FROM &#96;users&#96; WHERE name1 &#x3D; &quot;jinzhu2&quot; OR name2 &#x3D; &quot;jinzhu2&quot; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1\n\n&#x2F;&#x2F; struct 形式的命名参数\ntype NamedArgument struct &#123;\n    Name string\n    Name2 string\n&#125;\n\ndb.Raw(\n  &quot;SELECT * FROM users WHERE (name1 &#x3D; @Name AND name3 &#x3D; @Name) AND name2 &#x3D; @Name2&quot;,\n  NamedArgument&#123;Name: &quot;jinzhu&quot;, Name2: &quot;jinzhu2&quot;&#125;\n).Find(&amp;user)\n\n预检 DryRun 模式生成语句不执行\nstmt :&#x3D; db.Session(&amp;Session&#123;DryRun: true&#125;).First(&amp;user, 1).Statement\nstmt.SQL.String() &#x2F;&#x2F;&#x3D;&gt; SELECT * FROM &#96;users&#96; WHERE &#96;id&#96; &#x3D; $1 ORDER BY &#96;id&#96;\nstmt.Vars         &#x2F;&#x2F;&#x3D;&gt; []interface&#123;&#125;&#123;1&#125;\n\n\nToSql生成语句不执行\nGORM 使用 database&#x2F;sql 的参数占位符来构建 SQL 语句，它会自动转义参数以避免 SQL 注入\nsql :&#x3D; DB.ToSQL(func(tx *gorm.DB) *gorm.DB &#123;\n  return tx.Model(&amp;User&#123;&#125;).Where(&quot;id &#x3D; ?&quot;, 100).Limit(10).Order(&quot;age desc&quot;).Find(&amp;[]User&#123;&#125;)\n&#125;)\nsql &#x2F;&#x2F;&#x3D;&gt; SELECT * FROM &quot;users&quot; WHERE id &#x3D; 100 AND &quot;users&quot;.&quot;deleted_at&quot; IS NULL ORDER BY age desc LIMIT 10\n\n\nRow &amp; Rows&#x2F;&#x2F; 使用 GORM API 构建 SQL\nrow :&#x3D; db.Table(&quot;users&quot;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Select(&quot;name&quot;, &quot;age&quot;).Row()\nrow.Scan(&amp;name, &amp;age)\n\n&#x2F;&#x2F; 使用原生 SQL\nrow :&#x3D; db.Raw(&quot;select name, age, email from users where name &#x3D; ?&quot;, &quot;jinzhu&quot;).Row()\nrow.Scan(&amp;name, &amp;age, &amp;email)\n\n获取 *sql.Rows 结果\n&#x2F;&#x2F; 使用 GORM API 构建 SQL\nrows, err :&#x3D; db.Model(&amp;User&#123;&#125;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Select(&quot;name, age, email&quot;).Rows()\ndefer rows.Close()\n\n&#x2F;&#x2F; 数据情况，需要用到循环\nfor rows.Next() &#123; &#x2F;&#x2F; 这个是while循环， 在go中为简化版for\n  rows.Scan(&amp;name, &amp;age, &amp;email)\n\n  &#x2F;&#x2F; 业务逻辑...\n&#125;\n\n&#x2F;&#x2F; 原生 SQL\nrows, err :&#x3D; db.Raw(&quot;select name, age, email from users where name &#x3D; ?&quot;, &quot;jinzhu&quot;).Rows()\ndefer rows.Close()\nfor rows.Next() &#123;\n  rows.Scan(&amp;name, &amp;age, &amp;email)\n\n  &#x2F;&#x2F; 业务逻辑...\n&#125;\n\n&#x2F;&#x2F; sql.rows 扫描至 model\n\nrows, err :&#x3D; db.Model(&amp;User&#123;&#125;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Select(&quot;name, age, email&quot;).Rows() &#x2F;&#x2F; (*sql.Rows, error)\ndefer rows.Close()\n\nvar user User\nfor rows.Next() &#123;\n  &#x2F;&#x2F; ScanRows 将一行扫描至 user\n  db.ScanRows(rows, &amp;user)\n\n  &#x2F;&#x2F; 业务逻辑...\n&#125;\n\n单连接,多操作&#x2F;&#x2F; 在一条 tcp DB 连接中运行多条 SQL (不是事务)\n\ndb.Connection(func(tx *gorm.DB) error &#123;\n  tx.Exec(&quot;SET my.role &#x3D; ?&quot;, &quot;admin&quot;)\n\n  tx.First(&amp;User&#123;&#125;)\n&#125;)\n\n子句TODO： 先不学\nStatementModifier 语句修改器TODO： 先不学\n\n\ngorm 更新保存所有字段Save 会保存所有的字段，即使字段是零值\ndb.First(&amp;user)\n\nuser.Name &#x3D; &quot;jinzhu 2&quot;\nuser.Age &#x3D; 100\ndb.Save(&amp;user)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;jinzhu 2&#39;, age&#x3D;100, birthday&#x3D;&#39;2016-01-01&#39;, updated_at &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;\n\n\n更新单个列这里直接用的键值对\n&#x2F;&#x2F; 条件更新\ndb.Model(&amp;User&#123;&#125;).Where(&quot;active &#x3D; ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE active&#x3D;true;\n\n&#x2F;&#x2F; User 的 ID 是 &#96;111&#96;\ndb.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;\n\n&#x2F;&#x2F; 根据条件和 model 的值进行更新\ndb.Model(&amp;user).Where(&quot;active &#x3D; ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111 AND active&#x3D;true;\n\n\n更新多列\nstruct 更新非零值字段\nmap[string]interface&#123;&#125;\n\n&#x2F;&#x2F; 根据 &#96;struct&#96; 更新属性，只会更新非零值的字段\ndb.Model(&amp;user).Updates(User&#123;Name: &quot;hello&quot;, Age: 18, Active: false&#125;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18, updated_at &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE id &#x3D; 111;\n\n&#x2F;&#x2F; 根据 &#96;map&#96; 更新属性\ndb.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18, active&#x3D;false, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;\n\n\n更新选定字段\nSelect 选择字段\nOmit 剔除字段\n\n&#x2F;&#x2F; 使用 Map 进行 Select\n&#x2F;&#x2F; User&#39;s ID is &#96;111&#96;:\n\n&#x2F;&#x2F;只更新name\ndb.Model(&amp;user).Select(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39; WHERE id&#x3D;111;\n\n\n&#x2F;&#x2F; 不更新name\ndb.Model(&amp;user).Omit(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)\n&#x2F;&#x2F; UPDATE users SET age&#x3D;18, active&#x3D;false, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;\n\n&#x2F;&#x2F; 使用 Struct 进行 Select（会 select 零值的字段） 这么特殊的吗？哦，大概晓得了： 默认是不更新，但Select要更新\ndb.Model(&amp;user).Select(&quot;Name&quot;, &quot;Age&quot;).Updates(User&#123;Name: &quot;new_name&quot;, Age: 0&#125;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;new_name&#39;, age&#x3D;0 WHERE id&#x3D;111;\n\n&#x2F;&#x2F; Select 所有字段（查询包括零值字段的所有字段）\n&#x2F;&#x2F; 还支持 *呢\ndb.Model(&amp;user).Select(&quot;*&quot;).Update(User&#123;Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Age: 0&#125;)\n\n&#x2F;&#x2F; Select 除 Role 外的所有字段（包括零值字段的所有字段）\n&#x2F;&#x2F; 组合使用\ndb.Model(&amp;user).Select(&quot;*&quot;).Omit(&quot;Role&quot;).Update(User&#123;Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Age: 0&#125;)\n\n\n更新 Hook勾子无非就是校验和改变\n批量更新不指定主键就是批更新\n&#x2F;&#x2F; 根据 struct 更新\n&#x2F;&#x2F; 给gorm个模型，让它来找表\ndb.Model(User&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE role &#x3D; &#39;admin&#39;;\n\n&#x2F;&#x2F; 根据 map 更新\n&#x2F;&#x2F; db.Table 选择某个表\ndb.Table(&quot;users&quot;).Where(&quot;id IN ?&quot;, []int&#123;10, 11&#125;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18&#125;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE id IN (10, 11);\n\n\n阻止全局更新db.Model(&amp;User&#123;&#125;).Update(&quot;name&quot;, &quot;jinzhu&quot;).Error &#x2F;&#x2F; gorm.ErrMissingWhereClause\n\n\n&#x2F;&#x2F; .Where(&quot;true&quot;) 模式\ndb.Model(&amp;User&#123;&#125;).Where(&quot;1 &#x3D; 1&quot;).Update(&quot;name&quot;, &quot;jinzhu&quot;)\n&#x2F;&#x2F; UPDATE users SET &#96;name&#96; &#x3D; &quot;jinzhu&quot; WHERE 1&#x3D;1\n\n&#x2F;&#x2F; 原生\ndb.Exec(&quot;UPDATE users SET name &#x3D; ?&quot;, &quot;jinzhu&quot;)\n&#x2F;&#x2F; UPDATE users SET name &#x3D; &quot;jinzhu&quot;\n\n&#x2F;&#x2F; AllowGlobalUpdate\ndb.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: true&#125;).Model(&amp;User&#123;&#125;).Update(&quot;name&quot;, &quot;jinzhu&quot;)\n&#x2F;&#x2F; UPDATE users SET &#96;name&#96; &#x3D; &quot;jinzhu&quot;\n\n更新的受影响数&#x2F;&#x2F; 通过 &#96;RowsAffected&#96; 得到更新的记录数\nresult :&#x3D; db.Model(User&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)\n&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE role &#x3D; &#39;admin&#39;;\n\nresult.RowsAffected &#x2F;&#x2F; 更新的记录数\nresult.Error        &#x2F;&#x2F; 更新的错误\n\n高级选项使用 SQL 表达式更新\n&#x2F;&#x2F; product 的 ID 是 &#96;3&#96;\ndb.Model(&amp;product).Update(&quot;price&quot;, gorm.Expr(&quot;price * ? + ?&quot;, 2, 100))\n&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;price&quot; &#x3D; price * 2 + 100, &quot;updated_at&quot; &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE &quot;id&quot; &#x3D; 3;\n\ndb.Model(&amp;product).Updates(map[string]interface&#123;&#125;&#123;&quot;price&quot;: gorm.Expr(&quot;price * ? + ?&quot;, 2, 100)&#125;)\n&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;price&quot; &#x3D; price * 2 + 100, &quot;updated_at&quot; &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE &quot;id&quot; &#x3D; 3;\n\ndb.Model(&amp;product).UpdateColumn(&quot;quantity&quot;, gorm.Expr(&quot;quantity - ?&quot;, 1))\n&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;quantity&quot; &#x3D; quantity - 1 WHERE &quot;id&quot; &#x3D; 3;\n\ndb.Model(&amp;product).Where(&quot;quantity &gt; 1&quot;).UpdateColumn(&quot;quantity&quot;, gorm.Expr(&quot;quantity - ?&quot;, 1))\n&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;quantity&quot; &#x3D; quantity - 1 WHERE &quot;id&quot; &#x3D; 3 AND quantity &gt; 1;\n\n&#x2F;&#x2F; 将链式调用拆解\n\n  &#x2F;&#x2F; db.Model(&amp;product) 选表\n  &#x2F;&#x2F; .UpdateColumn(&quot;quantity&quot;, &#x2F;&#x2F; 更新操作\n  &#x2F;&#x2F; .Where(&quot;quantity &gt; 1&quot;) &#x2F;&#x2F; 判断条件\n\n&#x2F;&#x2F; 我有个疑问：gorm 是如何进行链式调用而保证顺序的？\n\n&#x2F;&#x2F; func (db *DB) Model(value interface&#123;&#125;) (tx *DB) &#123;\n&#x2F;&#x2F; \ttx &#x3D; db.getInstance()\n&#x2F;&#x2F; \ttx.Statement.Model &#x3D; value\n&#x2F;&#x2F; \treturn\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; 把所有的.节点 都放到Statement上，UpdateColumn是执行 tx.callbacks.Update().Execute， 最后怎么组织的 Execute执行了啥？往下好像看不懂了\n\n&#x2F;&#x2F; func (db *DB) UpdateColumn(column string, value interface&#123;&#125;) (tx *DB) &#123;\n&#x2F;&#x2F; \ttx &#x3D; db.getInstance()\n&#x2F;&#x2F; \ttx.Statement.Dest &#x3D; map[string]interface&#123;&#125;&#123;column: value&#125;\n&#x2F;&#x2F; \ttx.Statement.SkipHooks &#x3D; true\n&#x2F;&#x2F; \treturn tx.callbacks.Update().Execute(tx)\n&#x2F;&#x2F; &#125;\n\n\n&#x2F;&#x2F; for _, f :&#x3D; range p.fns &#123; &#x2F;&#x2F; p *processor\n&#x2F;&#x2F; \t\tf(db)\n&#x2F;&#x2F; \t&#125;\n\nTODO:这里有个自定义数据类型，在下面章节里有，先跳过\n根据子查询进行更新db.Model(&amp;user)\n.Update(\n  &quot;company_name&quot;,\n  db.Model(&amp;Company&#123;&#125;).Select(&quot;name&quot;).Where(&quot;companies.id &#x3D; users.company_id&quot;)\n)\n&#x2F;&#x2F; UPDATE &quot;users&quot; SET &quot;company_name&quot; &#x3D; (SELECT name FROM companies WHERE companies.id &#x3D; users.company_id);\n\n&#x2F;&#x2F; 表明是复数\ndb.Table(&quot;users as u&quot;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;)\n.Update(\n  &quot;company_name&quot;,\n  db.Table(&quot;companies as c&quot;).Select(&quot;name&quot;).Where(&quot;c.id &#x3D; u.company_id&quot;)\n)\n\ndb.Table(&quot;users as u&quot;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;)\n.Updates(map[string]interface&#123;&#125;&#123;\n  &quot;company_name&quot;: db.Table(&quot;companies as c&quot;).Select(&quot;name&quot;).Where(&quot;c.id &#x3D; u.company_id&quot;)\n&#125;)\n\n不使用 Hook 和时间追踪官方文档上是错误的， 没有主键，没有查询条件，不会更新注意：下面这几个 不追踪更新时间\nvar user User\ndb.Debug().Model(&amp;user).Where(&quot;id &#x3D; ?&quot;,1).UpdateColumn(&quot;name&quot;, &quot;hello&quot;)\n&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 14:52:17 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:468 WHERE conditions required\n&#x2F;&#x2F; [0.496ms] [rows:0] UPDATE &#96;users&#96; SET &#96;name&#96;&#x3D;&#39;hello&#39; where &#96;id&#96;&#x3D;1\n\n&#x2F;&#x2F; 更新多个列\ndb.Model(&amp;user).Where(&quot;id &#x3D; ?&quot;,1).UpdateColumns(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)\n&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 14:53:09 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:473 WHERE conditions required\n&#x2F;&#x2F; [0.567ms] [rows:0] UPDATE &#96;users&#96; SET &#96;name&#96;&#x3D;&#39;hello&#39;,&#96;age&#96;&#x3D;18 where &#96;id&#96;&#x3D;1\n\n&#x2F;&#x2F; 更新选中的列\ndb.Model(&amp;user).Select(&quot;name&quot;, &quot;age&quot;).Where(&quot;id &#x3D; ?&quot;,1).UpdateColumns(User&#123;Name: &quot;hello&quot;, Age: 0&#125;)\n&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 14:53:59 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:478 WHERE conditions required\n&#x2F;&#x2F; [0.539ms] [rows:0] UPDATE &#96;users&#96; SET &#96;name&#96;&#x3D;&#39;hello&#39;,&#96;age&#96;&#x3D;0 where &#96;id&#96;&#x3D;1\n\n\n返回修改行的数据这个有用，可以给前端同步数据，而不需要前端再发个请求到后端查询数据，\n&#x2F;&#x2F; 返回所有列\nvar users []User\nDB.Model(&amp;users).Clauses(clause.Returning&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Update(&quot;salary&quot;, gorm.Expr(&quot;salary * ?&quot;, 2))\n&#x2F;&#x2F; UPDATE &#96;users&#96; SET &#96;salary&#96;&#x3D;salary * 2,&#96;updated_at&#96;&#x3D;&quot;2021-10-28 17:37:23.19&quot; WHERE role &#x3D; &quot;admin&quot; RETURNING *\n&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 1, Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Salary: 100&#125;, &#123;ID: 2, Name: &quot;jinzhu.2&quot;, Role: &quot;admin&quot;, Salary: 1000&#125;&#125;\n\n&#x2F;&#x2F; 返回指定的列\nDB.Model(&amp;users).Clauses(clause.Returning&#123;Columns: []clause.Column&#123;&#123;Name: &quot;name&quot;&#125;, &#123;Name: &quot;salary&quot;&#125;&#125;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Update(&quot;salary&quot;, gorm.Expr(&quot;salary * ?&quot;, 2))\n&#x2F;&#x2F; UPDATE &#96;users&#96; SET &#96;salary&#96;&#x3D;salary * 2,&#96;updated_at&#96;&#x3D;&quot;2021-10-28 17:37:23.19&quot; WHERE role &#x3D; &quot;admin&quot; RETURNING &#96;name&#96;, &#96;salary&#96;\n&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 0, Name: &quot;jinzhu&quot;, Role: &quot;&quot;, Salary: 100&#125;, &#123;ID: 0, Name: &quot;jinzhu.2&quot;, Role: &quot;&quot;, Salary: 1000&#125;&#125;\n\n\n检查字段是否有变更？在 Update 时修改值&#x2F;&#x2F; 给谁加的勾子？ 给user?,加勾子都加载字段上的吗\nfunc (user *User) BeforeSave(tx *gorm.DB) (err error) &#123;\n  if pw, err :&#x3D; bcrypt.GenerateFromPassword(user.Password, 0); err &#x3D;&#x3D; nil &#123;\n    tx.Statement.SetColumn(&quot;EncryptedPassword&quot;, pw)\n  &#125;\n\n  if tx.Statement.Changed(&quot;Code&quot;) &#123;\n    user.Age +&#x3D; 20\n    tx.Statement.SetColumn(&quot;Age&quot;, user.Age)\n  &#125;\n&#125;\n\ndb.Model(&amp;user).Update(&quot;Name&quot;, &quot;jinzhu&quot;)\n\n\n\ngorm 安全gorm SQL 注入应对\nGORM 使用 database&#x2F;sql 的参数占位符来构造 SQL 语句，这可以自动转义参数，避免 SQL 注入数据\n查询条件内联条件当通过用户输入的整形主键检索记录时，你应该对变量进行类型检查。\n避免 Sql 注入的原则：\n避免 SQL 注入的一般原则是，不信任用户提交的数据。\n您可以进行白名单验证来测试用户的输入是否为已知安全的、已批准、已定义的输入 TODO: 如何实现？\n在使用用户的输入时，仅将它们作为参数。\n\n默认值零值 || 默认值\n方式 1: 指针\n方式 2: sql 结构体\n\nmap[string]interface&#123;&#125;&#123;&#125;啥意思？.Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)\n\n软删除后查询全量数据&#x2F;&#x2F; Unscoped 翻译为：无范围\n\n&#x2F;&#x2F; Unscoped 方法可以查询被软删除的记录\ndb.Unscoped().Where(&quot;age &#x3D; 20&quot;).Find(&amp;users)\n&#x2F;&#x2F;&#x2F;&#x2F; SELECT * FROM users WHERE age &#x3D; 20;\n\n实战学习找个项目瞅瞅，\n见\n项目架构\n\n博客收集liwenzhou.com golang 菜单\nliwenzhou.com 创建\nliwenzhou.com 查询\nliwenzhou.com 更新\nliwenzhou.com 删除\nliwenzhou.com 链式调用\nB 站视频 gorm\n课程代码\n学高级的都要钱，呜呜～，有钱真好\n哪位老哥有买此课程，借阅,三克油了\n","slug":"2022-10-16gorm","date":"2022-10-16T10:34:17.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"857139c827e07a054648ff4832e5a476","title":"B站播放速度修改","content":"背景B 站视频播放速度可选项太少了，有的视频被转化的语速快，有的视频被转化的特慢，不能忍～\n更改 dom&lt;ul class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu&quot;&gt;\n  &lt;!-- 增加个三倍速选项，B站没做校验，所以3倍速也是有效的 --&gt;\n  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;3&quot;&gt;3.0x&lt;&#x2F;li&gt;\n  &lt;li\n    class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item bpx-state-active&quot;\n    data-value&#x3D;&quot;2&quot;\n  &gt;\n    2.0x\n  &lt;&#x2F;li&gt;\n  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;1.5&quot;&gt;1.5x&lt;&#x2F;li&gt;\n  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;1.25&quot;&gt;\n    1.25x\n  &lt;&#x2F;li&gt;\n  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;1&quot;&gt;1.0x&lt;&#x2F;li&gt;\n  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;0.75&quot;&gt;\n    0.75x\n  &lt;&#x2F;li&gt;\n  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;0.5&quot;&gt;0.5x&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n测试\n\n视频演示\n书写脚本var value &#x3D; &quot;4&quot;; &#x2F;&#x2F; 几倍速\n\nvar pvaldoms1 &#x3D; document.getElementsByClassName(\n  &quot;bpx-player-ctrl-playbackrate-menu&quot;\n)[0];\n\nvar newItemDom &#x3D; document.createElement(&quot;li&quot;);\nnewItemDom.className &#x3D; &quot;bpx-player-ctrl-playbackrate-menu-item&quot;;\nnewItemDom.dataset.value &#x3D; value;\n\nnewItemDom.innerHTML &#x3D; &#96;$&#123;value&#125;.0x&#96;;\n\npvaldoms1.prepend(newItemDom);\n\n更改结果\n","slug":"2022-10-16Bplayer-rate","date":"2022-10-16T07:55:58.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"208d2e5dd21527c04afdea8f15a73969","title":"Gin Examples","content":"运行记录[GIN-debug] [WARNING] Running in “debug” mode. Switch to “release” mode in production.\n生产环境切到 release 模式\n[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\n不安全警告\n[Running] go run &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;github&#x2F;go&#x2F;gin-examples&#x2F;app-engine&#x2F;go11x&#x2F;hello.go&quot;\n2022&#x2F;10&#x2F;16 07:50:16 Defaulting to port 8080\n2022&#x2F;10&#x2F;16 07:50:16 Listening on port 8080\n[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.\n - using env:\texport GIN_MODE&#x3D;release\n - using code:\tgin.SetMode(gin.ReleaseMode)\n\n[GIN-debug] GET    &#x2F;                         --&gt; main.main.func1 (1 handlers)\n[GIN-debug] GET    &#x2F;ping                     --&gt; main.main.func2 (1 handlers)\n[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\nPlease check https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;gin-gonic&#x2F;gin#readme-don-t-trust-all-proxies for details.\n[GIN-debug] Listening and serving HTTP on :8080\n\n\n报红\n\n路由匹配错误\n","slug":"2022-10-16gin-examples","date":"2022-10-15T23:55:43.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"8b5c76f2c2d760e600f1319758a156a6","title":"Go vscode","content":"go 配置代理♠ &#x2F;Users&#x2F;chenhailong $ go version\ngo version go1.19.2 darwin&#x2F;amd64\n♠ &#x2F;Users&#x2F;chenhailong $ go install golang.org&#x2F;x&#x2F;tools&#x2F;gopls@latest\ngo: golang.org&#x2F;x&#x2F;tools&#x2F;gopls@latest: module golang.org&#x2F;x&#x2F;tools&#x2F;gopls: Get &quot;https:&#x2F;&#x2F;proxy.golang.org&#x2F;golang.org&#x2F;x&#x2F;tools&#x2F;gopls&#x2F;@v&#x2F;list&quot;: dial tcp 172.217.163.49:443: i&#x2F;o timeout\n♠ &#x2F;Users&#x2F;chenhailong $ go env\nGO111MODULE&#x3D;&quot;&quot;\nGOARCH&#x3D;&quot;amd64&quot;\nGOBIN&#x3D;&quot;&quot;\nGOCACHE&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;Library&#x2F;Caches&#x2F;go-build&quot;\nGOENV&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;Library&#x2F;Application Support&#x2F;go&#x2F;env&quot;\nGOEXE&#x3D;&quot;&quot;\nGOEXPERIMENT&#x3D;&quot;&quot;\nGOFLAGS&#x3D;&quot;&quot;\nGOHOSTARCH&#x3D;&quot;amd64&quot;\nGOHOSTOS&#x3D;&quot;darwin&quot;\nGOINSECURE&#x3D;&quot;&quot;\nGOMODCACHE&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;go&#x2F;pkg&#x2F;mod&quot;\nGONOPROXY&#x3D;&quot;&quot;\nGONOSUMDB&#x3D;&quot;&quot;\nGOOS&#x3D;&quot;darwin&quot;\nGOPATH&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;go&quot;\nGOPRIVATE&#x3D;&quot;&quot;\nGOPROXY&#x3D;&quot;https:&#x2F;&#x2F;proxy.golang.org,direct&quot;\nGOROOT&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;go&quot;\nGOSUMDB&#x3D;&quot;sum.golang.org&quot;\nGOTMPDIR&#x3D;&quot;&quot;\nGOTOOLDIR&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;go&#x2F;pkg&#x2F;tool&#x2F;darwin_amd64&quot;\nGOVCS&#x3D;&quot;&quot;\nGOVERSION&#x3D;&quot;go1.19.2&quot;\nGCCGO&#x3D;&quot;gccgo&quot;\nGOAMD64&#x3D;&quot;v1&quot;\nAR&#x3D;&quot;ar&quot;\nCC&#x3D;&quot;clang&quot;\nCXX&#x3D;&quot;clang++&quot;\nCGO_ENABLED&#x3D;&quot;1&quot;\nGOMOD&#x3D;&quot;&#x2F;dev&#x2F;null&quot;\nGOWORK&#x3D;&quot;&quot;\nCGO_CFLAGS&#x3D;&quot;-g -O2&quot;\nCGO_CPPFLAGS&#x3D;&quot;&quot;\nCGO_CXXFLAGS&#x3D;&quot;-g -O2&quot;\nCGO_FFLAGS&#x3D;&quot;-g -O2&quot;\nCGO_LDFLAGS&#x3D;&quot;-g -O2&quot;\nPKG_CONFIG&#x3D;&quot;pkg-config&quot;\nGOGCCFLAGS&#x3D;&quot;-fPIC -arch x86_64 -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length&#x3D;0 -fdebug-prefix-map&#x3D;&#x2F;var&#x2F;folders&#x2F;qk&#x2F;bj_mbvq54zs663fjmkykq4cc0000gn&#x2F;T&#x2F;go-build1271542645&#x3D;&#x2F;tmp&#x2F;go-build -gno-record-gcc-switches -fno-common&quot;\n♠ &#x2F;Users&#x2F;chenhailong $\n\ngoproxy\n打开你的终端并执行\n$ go env -w GO111MODULE&#x3D;on\n$ go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct\n\ngopls 安装\ngo install golang.org&#x2F;x&#x2F;tools&#x2F;gopls@latest\n\n -->\n\n\n\n\n\n\n\ncode run\n\n参考链接https://goproxy.cn/\n","slug":"2022-10-15go-vscode","date":"2022-10-15T15:35:13.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"b21d66657c866de8629862fe6f5e2c48","title":"Go Gin","content":"背景\n巩固 go 语言学习\n听说很多大公司用 go 来开发服务器，我特来看看\n了解 go web 开发\n\nGin选这个框架原因如下：\n社区活跃\n\nGo 官网推荐Tutorial: Developing a RESTful API with Go and Gin\ngithub 上 star 多 https://github.com/gin-gonic/gin\nGin 官网支持多语言有中文版的文档，本着爱国，我还是爱看中文文档的\nB 站 “七米” 视频 播放速度太慢？帮你解决\n\nGin 官网简介很厉害的样子\nGin Web Framework\nThe fastest full-featured web framework for Go. Crystal clear.\nWhat is Gin?\nGin is a web framework written in Golang.\nIt features a Martini-like API, but with performance up to 40 times faster than Martini.\nIf you need performance and productivity, you will love Gin.\n优点\n快： 基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。 httprouter\n中间件：传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。\nCrash 处理： Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！\nJSON 验证： Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。\n路由组： Gin 帮助您更好地组织您的路由，例如，按照需要授权和不需要授权和不同 API 版本进行分组。此外，路由分组可以无限嵌套而不降低性能。\n错误管理：Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。\n内置渲染：Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。\n扩展性好： 新建一个中间件非常简单（不信能比 Django 中间件还简单，你是来捣乱的吧～）\n\n参考事例见\n这么直接，也没个 API 文档，害的我找了半天没找到～\nweb 服务组成根据以往经验服务端涵盖如下内容：\n\n启动个端口监听请求\n静态资源路径\nGET、POST、Delete、PUT、PATCH、OPTIONS 等请求处理\n参数接收 urlparams、body\n返回渲染 html\n返回 JSON\n用户登录\n登录信息管理 cookie 、 redis 、session\n身份校验、权限校验\n日志信息\n数据持久化 DB 系列、ORM\n\n还是看README.md比较方便，官网要是能好好写写就好了\nvscode相关配置\nGin API 文档找不到 API 文档，有 examples 文档和 examples 项目，不像 nestjs、Django 文档一堆\n这两天学习总结到：大致了解 gin 的相关东西，真正开发时候会有语法提示，也可以点进去看看源码，这样也就了解了对应接口&#x2F;结构体的 API\n睡了一觉略有所感：中午看了点视频，又睡了一觉，醒来一想为什么没有 API 文档,或许是作者认为太简单了，根本不需要，我觉得是这样\n闲逛 gorm 发现了 Gin 的 api 文档了：https://pkg.go.dev/github.com/gin-gonic/gin\n看下 Gin Example 带来的 API将 https://github.com/gin-gonic/examples fork 到自己 github ,clone 到本地，对照文档运行起来看看效果\n请求方法Using GET, POST, PUT, PATCH, DELETE and OPTIONSpackage main\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n  &#x2F;&#x2F; Creates a gin router with default middleware:\n  &#x2F;&#x2F; logger and recovery (crash-free) middleware\n  &#x2F;&#x2F; 默认中间件情况下，创建 gin router\n  router :&#x3D; gin.Default()\n\n  router.GET(&quot;&#x2F;someGet&quot;, getting)\n  router.POST(&quot;&#x2F;somePost&quot;, posting)\n  router.PUT(&quot;&#x2F;somePut&quot;, putting)\n  router.DELETE(&quot;&#x2F;someDelete&quot;, deleting)\n  router.PATCH(&quot;&#x2F;somePatch&quot;, patching)\n  router.HEAD(&quot;&#x2F;someHead&quot;, head)\n  router.OPTIONS(&quot;&#x2F;someOptions&quot;, options)\n\n  &#x2F;&#x2F; By default it serves on :8080 unless a\n  &#x2F;&#x2F; PORT environment variable was defined.\n  &#x2F;&#x2F; 运行服务，默认启用的是8080端口\n  router.Run()\n  &#x2F;&#x2F; router.Run(&quot;:3000&quot;) for a hard coded port\n  &#x2F;&#x2F; 可以使用 router.Run(&quot;:3000&quot;)， 硬编码的方式改变端口\n&#125;\n\n\n获取参数Parameters in path获取路径中的参数\nParam\npackage main\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n  router :&#x3D; gin.Default()\n\n  &#x2F;&#x2F; This handler will match &#x2F;user&#x2F;john but will not match &#x2F;user&#x2F; or &#x2F;user\n  &#x2F;&#x2F; 这个处理器会匹配  &#x2F;user&#x2F;john ，但不会匹配  &#x2F;user&#x2F; 或者 &#x2F;user这种\n  router.GET(&quot;&#x2F;user&#x2F;:name&quot;, func(c *gin.Context) &#123;\n    name :&#x3D; c.Param(&quot;name&quot;) &#x2F;&#x2F; 通过指针.Param获取路径中的参数\n    c.String(http.StatusOK, &quot;Hello %s&quot;, name)\n  &#125;)\n\n  &#x2F;&#x2F; However, this one will match &#x2F;user&#x2F;john&#x2F; and also &#x2F;user&#x2F;john&#x2F;send\n  &#x2F;&#x2F; If no other routers match &#x2F;user&#x2F;john, it will redirect to &#x2F;user&#x2F;john&#x2F;\n\n  &#x2F;&#x2F; 这个会匹配到 &#x2F;user&#x2F;john&#x2F; 、  &#x2F;user&#x2F;john&#x2F;send， 对于&#x2F;user&#x2F;john 这样一个路径，如果没有其他路径匹配到，会重定向到 &#x2F;user&#x2F;john&#x2F;\n  router.GET(&quot;&#x2F;user&#x2F;:name&#x2F;*action&quot;, func(c *gin.Context) &#123; &#x2F;&#x2F; 这里的 :name 和 *action 怎么不一样呢？\n    name :&#x3D; c.Param(&quot;name&quot;)\n    action :&#x3D; c.Param(&quot;action&quot;)\n    message :&#x3D; name + &quot; is &quot; + action\n    c.String(http.StatusOK, message)\n  &#125;)\n\n  &#x2F;&#x2F; For each matched request Context will hold the route definition\n  &#x2F;&#x2F; 对于每个匹配的请求，Context将保存路由定义\n  router.POST(&quot;&#x2F;user&#x2F;:name&#x2F;*action&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; FullPath方法可以获取到路由定义\n    b :&#x3D; c.FullPath() &#x3D;&#x3D; &quot;&#x2F;user&#x2F;:name&#x2F;*action&quot; &#x2F;&#x2F; true\n    c.String(http.StatusOK, &quot;%t&quot;, b)\n  &#125;)\n\n  &#x2F;&#x2F; This handler will add a new router for &#x2F;user&#x2F;groups.\n  &#x2F;&#x2F; Exact routes are resolved before param routes, regardless of the order they were defined.\n  &#x2F;&#x2F; Routes starting with &#x2F;user&#x2F;groups are never interpreted as &#x2F;user&#x2F;:name&#x2F;... routes\n\n  &#x2F;&#x2F; 这个处理，会为&#x2F;user&#x2F;groups 增加一个新路径\n  &#x2F;&#x2F; 精确路由在参数路由之前解析，而不管它们的定义顺序如何。\n  &#x2F;&#x2F; 以&#x2F;user&#x2F;groups开头的路由永远不会解释为&#x2F;user&#x2F;:name&#x2F;…路由\n  router.GET(&quot;&#x2F;user&#x2F;groups&quot;, func(c *gin.Context) &#123;\n    c.String(http.StatusOK, &quot;The available groups are [...]&quot;)\n  &#125;)\n\n  router.Run(&quot;:8080&quot;)\n&#125;\n\nQuerystring parametersDefaultQuery、Query\npackage main\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n  router :&#x3D; gin.Default()\n\n  &#x2F;&#x2F; Query string parameters are parsed using the existing underlying request object.\n  &#x2F;&#x2F; The request responds to a url matching:  &#x2F;welcome?firstname&#x3D;Jane&amp;lastname&#x3D;Doe\n\n  &#x2F;&#x2F; 查询字符串参数使用现有的底层请求对象进行解析。\n  &#x2F;&#x2F; 请求响应一个匹配的url：&#x2F;welcome?firstname&#x3D;Jane&amp;lastname&#x3D;Doe\n  router.GET(&quot;&#x2F;welcome&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; 带有默认值，取参数（如果firstname，没有，则用第二参数Guest）\n    firstname :&#x3D; c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)\n    &#x2F;&#x2F; 这个是简写\n    lastname :&#x3D; c.Query(&quot;lastname&quot;) &#x2F;&#x2F; shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)\n\n    c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)\n  &#125;)\n  router.Run(&quot;:8080&quot;)\n&#125;\n\nMultipart&#x2F;Urlencoded Form表单参数\nDefaultPostForm、PostForm\npackage main\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\trouter.POST(&quot;&#x2F;form_post&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; message参数\n\t\tmessage :&#x3D; c.PostForm(&quot;message&quot;)\n    &#x2F;&#x2F; form表单，带有默认值\n\t\tnick :&#x3D; c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;)\n\n\t\tc.JSON(http.StatusOK, gin.H&#123;\n\t\t\t&quot;status&quot;:  &quot;posted&quot;,\n\t\t\t&quot;message&quot;: message,\n\t\t\t&quot;nick&quot;:    nick,\n\t\t&#125;)\n\n\t&#125;)\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n\nquery + post formPOST &#x2F;post?id&#x3D;1234&amp;page&#x3D;1 HTTP&#x2F;1.1\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nname&#x3D;manu&amp;message&#x3D;this_is_great\n\nfunc main() &#123;\n  router :&#x3D; gin.Default()\n\n  router.POST(&quot;&#x2F;post&quot;, func(c *gin.Context) &#123;\n      &#x2F;&#x2F; query参数\n      id :&#x3D; c.Query(&quot;id&quot;)\n      page :&#x3D; c.DefaultQuery(&quot;page&quot;, &quot;0&quot;)\n      &#x2F;&#x2F; form参数\n      name :&#x3D; c.PostForm(&quot;name&quot;)\n      message :&#x3D; c.PostForm(&quot;message&quot;)\n\n      fmt.Printf(&quot;id: %s; page: %s; name: %s; message: %s&quot;, id, page, name, message)\n\n  &#125;)\n  router.Run(&quot;:8080&quot;)\n&#125;\n&#x2F;&#x2F; id: 1234; page: 1; name: manu; message: this_is_great\n\nMap as querystring or postform parametersPOST &#x2F;post?ids[a]&#x3D;1234&amp;ids[b]&#x3D;hello HTTP&#x2F;1.1\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nnames[first]&#x3D;thinkerou&amp;names[second]&#x3D;tianou\n\n\nfunc main() &#123;\n  router :&#x3D; gin.Default()\n\n  router.POST(&quot;&#x2F;post&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; query map\n    ids :&#x3D; c.QueryMap(&quot;ids&quot;)\n    &#x2F;&#x2F; form map\n    names :&#x3D; c.PostFormMap(&quot;names&quot;)\n\n    fmt.Printf(&quot;ids: %v; names: %v&quot;, ids, names)\n  &#125;)\n  router.Run(&quot;:8080&quot;)\n&#125;\n&#x2F;&#x2F; ids: map[b:hello a:1234]; names: map[second:tianou first:thinkerou]\n\n\n文件上传Single file uploadfile.Filename 获取的文件名不可信\n\nfunc main() &#123;\n  router :&#x3D; gin.Default()\n  &#x2F;&#x2F; Set a lower memory limit for multipart forms (default is 32 MiB)\n  &#x2F;&#x2F; 默认 multipart forms  是 32MB, 设个低点的值的8M，是缓存不是上传大小限制\n  router.MaxMultipartMemory &#x3D; 8 &lt;&lt; 20  &#x2F;&#x2F; 8 MiB\n  router.POST(&quot;&#x2F;upload&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; Single file\n    file, _ :&#x3D; c.FormFile(&quot;file&quot;)\n    log.Println(file.Filename)\n\n    &#x2F;&#x2F; Upload the file to specific dst.\n    &#x2F;&#x2F; 上传文件到具体的目的地\n    c.SaveUploadedFile(file, dst)\n\n    c.String(http.StatusOK, fmt.Sprintf(&quot;&#39;%s&#39; uploaded!&quot;, file.Filename))\n  &#125;)\n  router.Run(&quot;:8080&quot;)\n&#125;\n\n&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;localhost:8080&#x2F;upload \\\n&#x2F;&#x2F;   -F &quot;file&#x3D;@&#x2F;Users&#x2F;appleboy&#x2F;test.zip&quot; \\\n&#x2F;&#x2F;   -H &quot;Content-Type: multipart&#x2F;form-data&quot;\n\nMultiple filesSee the detail example code.\nfunc main() &#123;\n  router :&#x3D; gin.Default()\n  &#x2F;&#x2F; Set a lower memory limit for multipart forms (default is 32 MiB)\n  &#x2F;&#x2F; 默认 multipart forms  是 32MB, 设个低点的值的8M\n  router.MaxMultipartMemory &#x3D; 8 &lt;&lt; 20 &#x2F;&#x2F; 8 MiB\n\n  router.POST(&quot;&#x2F;upload&quot;, func(c *gin.Context) &#123;\n\n  &#x2F;&#x2F; Multipart form\n  form, _ :&#x3D; c.MultipartForm()\n\n  &#x2F;&#x2F; 多文件上传\n  files :&#x3D; form.File[&quot;upload[]&quot;]\n\n      for _, file :&#x3D; range files &#123;\n        log.Println(file.Filename)\n        &#x2F;&#x2F; Upload the file to specific dst.\n        c.SaveUploadedFile(file, dst)\n      &#125;\n\n      c.String(http.StatusOK, fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)))\n\n  &#125;)\n  router.Run(&quot;:8080&quot;)\n&#125;\n\n\n&#x2F;&#x2F; How to curl:\n\n&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;localhost:8080&#x2F;upload \\\n&#x2F;&#x2F;  -F &quot;upload[]&#x3D;@&#x2F;Users&#x2F;appleboy&#x2F;test1.zip&quot; \\\n&#x2F;&#x2F;  -F &quot;upload[]&#x3D;@&#x2F;Users&#x2F;appleboy&#x2F;test2.zip&quot; \\\n&#x2F;&#x2F;  -H &quot;Content-Type: multipart&#x2F;form-data&quot;\n\n路由分组Grouping routesfunc main() &#123;\n  router :&#x3D; gin.Default()\n    &#x2F;&#x2F; 以版本分组，也就移动端用的到，我记得java,有个包可以自动降级处理接口版本\n  &#x2F;&#x2F; Simple group: v1\n  v1 :&#x3D; router.Group(&quot;&#x2F;v1&quot;)\n  &#123;\n    v1.POST(&quot;&#x2F;login&quot;, loginEndpoint)\n    v1.POST(&quot;&#x2F;submit&quot;, submitEndpoint)\n    v1.POST(&quot;&#x2F;read&quot;, readEndpoint)\n  &#125;\n\n  &#x2F;&#x2F; Simple group: v2\n  v2 :&#x3D; router.Group(&quot;&#x2F;v2&quot;)\n  &#123;\n    v2.POST(&quot;&#x2F;login&quot;, loginEndpoint)\n    v2.POST(&quot;&#x2F;submit&quot;, submitEndpoint)\n    v2.POST(&quot;&#x2F;read&quot;, readEndpoint)\n  &#125;\n\n  router.Run(&quot;:8080&quot;)\n&#125;\n\n\n中间件Blank Gin without middleware by default只是用默认的中间件，无其他中间件\nr :&#x3D; gin.New() &#x2F;&#x2F; 不使用任何中间件\n\n&#x2F;&#x2F; Default With the Logger and Recovery middleware already attached\nr :&#x3D; gin.Default() &#x2F;&#x2F; 使用默认中间件\n\nUsing middlewarefunc main() &#123;\n  &#x2F;&#x2F; Creates a router without any middleware by default\n  r :&#x3D; gin.New() &#x2F;&#x2F; 创建无中间件的路由\n\n  &#x2F;&#x2F; Global middleware\n  &#x2F;&#x2F; Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE&#x3D;release.\n  &#x2F;&#x2F; 记录器中间件将日志写入gin。即使您使用GIN_MODE&#x3D;release设置了DefaultWriter。\n  &#x2F;&#x2F; By default gin.DefaultWriter &#x3D; os.Stdout\n  &#x2F;&#x2F; 默认情况，只是打印\n\n  &#x2F;&#x2F; 全局中间件\n  r.Use(gin.Logger())\n\n  &#x2F;&#x2F; Recovery middleware recovers from any panics and writes a 500 if there was one.\n  &#x2F;&#x2F; recovery 中间件用于从 panic 中恢复, 并返回 500 响应. 还是不懂啥意思\n  r.Use(gin.Recovery())\n\n  &#x2F;&#x2F; Per route middleware, you can add as many as you desire.\n  &#x2F;&#x2F; 根据路由中间件，您可以添加任意数量的中间件。\n  r.GET(&quot;&#x2F;benchmark&quot;, MyBenchLogger(), benchEndpoint)\n\n  &#x2F;&#x2F; Authorization group\n  &#x2F;&#x2F; authorized :&#x3D; r.Group(&quot;&#x2F;&quot;, AuthRequired())\n  &#x2F;&#x2F; exactly the same as:\n  authorized :&#x3D; r.Group(&quot;&#x2F;&quot;)\n  &#x2F;&#x2F; per group middleware! in this case we use the custom created\n  &#x2F;&#x2F; AuthRequired() middleware just in the &quot;authorized&quot; group.\n\n  &#x2F;&#x2F;每组中间件！在本例中，我们使用自定义创建的\n  &#x2F;&#x2F;AuthRequired（）中间件仅位于“授权”组中。\n  authorized.Use(AuthRequired())\n  &#123;\n    authorized.POST(&quot;&#x2F;login&quot;, loginEndpoint)\n    authorized.POST(&quot;&#x2F;submit&quot;, submitEndpoint)\n    authorized.POST(&quot;&#x2F;read&quot;, readEndpoint)\n\n    &#x2F;&#x2F; nested group\n    &#x2F;&#x2F; 级联分组\n    testing :&#x3D; authorized.Group(&quot;testing&quot;)\n    &#x2F;&#x2F; visit 0.0.0.0:8080&#x2F;testing&#x2F;analytics\n    testing.GET(&quot;&#x2F;analytics&quot;, analyticsEndpoint)\n  &#125;\n\n  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080\n  r.Run(&quot;:8080&quot;)\n&#125;\n\n\nCustom Recovery behaviorfunc main() &#123;\n  &#x2F;&#x2F; Creates a router without any middleware by default\n  r :&#x3D; gin.New()\n\n  &#x2F;&#x2F; Global middleware\n  &#x2F;&#x2F; Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE&#x3D;release.\n  &#x2F;&#x2F; By default gin.DefaultWriter &#x3D; os.Stdout\n  r.Use(gin.Logger())\n\n  &#x2F;&#x2F; Recovery middleware recovers from any panics and writes a 500 if there was one.\n  r.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface&#123;&#125;) &#123;\n    if err, ok :&#x3D; recovered.(string); ok &#123; &#x2F;&#x2F; 这个地方怎么是分号？\n      c.String(http.StatusInternalServerError, fmt.Sprintf(&quot;error: %s&quot;, err))\n    &#125;\n    &#x2F;&#x2F; 丢弃\n    c.AbortWithStatus(http.StatusInternalServerError)\n  &#125;))\n\n  r.GET(&quot;&#x2F;panic&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; panic with a string -- the custom middleware could save this to a database or report it to the user\n    &#x2F;&#x2F; 定义中间件，将 panic 保存到数据库。或者是向用户报告问题\n    panic(&quot;foo&quot;)\n  &#125;)\n\n  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n    c.String(http.StatusOK, &quot;ohai&quot;)\n  &#125;)\n\n  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080\n  r.Run(&quot;:8080&quot;)\n&#125;\n\n日志How to write log filefunc main() &#123;\n    &#x2F;&#x2F; Disable Console Color, you don&#39;t need console color when writing the logs to file.\n    &#x2F;&#x2F; 关闭console颜色，向文件中写入日志不需要颜色\n    gin.DisableConsoleColor()\n\n    &#x2F;&#x2F; Logging to a file.\n    f, _ :&#x3D; os.Create(&quot;gin.log&quot;) &#x2F;&#x2F; 创建文件\n\n\n    gin.DefaultWriter &#x3D; io.MultiWriter(f) &#x2F;&#x2F; 写入日志\n    &#x2F;&#x2F; Use the following code if you need to write the logs to file and console at the same time.\n\n    &#x2F;&#x2F; 如果既要写日志到文件，也要打印，就需要用到下面的代码\n    &#x2F;&#x2F; gin.DefaultWriter &#x3D; io.MultiWriter(f, os.Stdout)\n\n    router :&#x3D; gin.Default()\n    router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n        c.String(http.StatusOK, &quot;pong&quot;)\n    &#125;)\n\n    router.Run(&quot;:8080&quot;)\n&#125;\n\nCustom Log Formatfunc main() &#123;\n  router :&#x3D; gin.New()\n\n  &#x2F;&#x2F; LoggerWithFormatter middleware will write the logs to gin.DefaultWriter\n  &#x2F;&#x2F; By default gin.DefaultWriter &#x3D; os.Stdout\n  router.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string &#123;\n\n    &#x2F;&#x2F; your custom format\n    return fmt.Sprintf(&quot;%s - [%s] \\&quot;%s %s %s %d %s \\&quot;%s\\&quot; %s\\&quot;\\n&quot;,\n        param.ClientIP,\n        param.TimeStamp.Format(time.RFC1123),\n        param.Method,\n        param.Path,\n        param.Request.Proto, &#x2F;&#x2F; HTTP&#x2F;1.1\n        param.StatusCode, &#x2F;&#x2F; 200\n        param.Latency, &#x2F;&#x2F;  122.767µs\n        param.Request.UserAgent(), &#x2F;&#x2F; &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.80 Safari&#x2F;537.36&quot;\n        param.ErrorMessage,\n    )\n  &#125;))\n  router.Use(gin.Recovery())\n\n  router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n    c.String(http.StatusOK, &quot;pong&quot;)\n  &#125;)\n\n  router.Run(&quot;:8080&quot;)\n&#125;\n\n&#x2F;&#x2F; ::1 - [Fri, 07 Dec 2018 17:04:38 JST] &quot;GET &#x2F;ping HTTP&#x2F;1.1 200 122.767µs &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.80 Safari&#x2F;537.36&quot; &quot;\n\nControlling Log output coloringBy default, logs output on console should be colorized depending on the detected TTY.\n默认情况下，控制台上的日志输出应根据检测到的 TTY 进行着色。\nNever colorize logs:\nfunc main() &#123;\n&#x2F;&#x2F; Disable log&#39;s color\ngin.DisableConsoleColor()\n\n    &#x2F;&#x2F; Creates a gin router with default middleware:\n    &#x2F;&#x2F; logger and recovery (crash-free) middleware\n    router :&#x3D; gin.Default()\n\n    router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n        c.String(http.StatusOK, &quot;pong&quot;)\n    &#125;)\n\n    router.Run(&quot;:8080&quot;)\n\n&#125;\n\nAlways colorize logs:\n通常会定制颜色\n\nfunc main() &#123;\n    &#x2F;&#x2F; Force log&#39;s color\n    gin.ForceConsoleColor()\n\n    &#x2F;&#x2F; Creates a gin router with default middleware:\n    &#x2F;&#x2F; logger and recovery (crash-free) middleware\n    router :&#x3D; gin.Default()\n\n    router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n        c.String(http.StatusOK, &quot;pong&quot;)\n    &#125;)\n\n    router.Run(&quot;:8080&quot;)\n&#125;\n\n\n\n数据校验Model binding and validation ?要将请求体绑定到结构体中，使用模型绑定。 Gin 目前支持 JSON、XML、YAML 和标准表单值的绑定（foo&#x3D;bar＆boo&#x3D;baz）。\nGin 使用 go-playground&#x2F;validator&#x2F;v10 进行验证。 查看标签用法的全部文档.\n使用时，需要在要绑定的所有字段上，设置相应的 tag。 例如，使用 JSON 绑定时，设置字段标签为 json:”fieldname”。\nGin 提供了两类绑定方法：\nType - Must bind\nMethods - Bind, BindJSON, BindXML, BindQuery, BindYAMLBehavior - 这些方法属于 MustBindWith 的具体调用。 如果发生绑定错误，则请求终止，并触发 c.AbortWithError(400, err).SetType(ErrorTypeBind)。响应状态码被设置为 400 并且 Content-Type 被设置为 text&#x2F;plain; 太死板，不好用charset&#x3D;utf-8。 如果您在此之后尝试设置响应状态码，Gin 会输出日志 [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422。 如果您希望更好地控制绑定，考虑使用 ShouldBind 等效方法。\nType - Should bind\nMethods - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAMLBehavior - 这些方法属于 ShouldBindWith 的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。\n使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定。 如果你明确知道要绑定什么，可以使用 MustBindWith 或 ShouldBindWith。\n你也可以指定必须绑定的字段。 如果一个字段的 tag 加上了 binding:”required”，但绑定时是空值, Gin 会报错。\n&#x2F;&#x2F; 绑定 JSON\ntype Login struct &#123;\n\tUser     string &#96;form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot;  binding:&quot;required&quot;&#96;\n\tPassword string &#96;form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 绑定 JSON (&#123;&quot;user&quot;: &quot;manu&quot;, &quot;password&quot;: &quot;123&quot;&#125;)\n\trouter.POST(&quot;&#x2F;loginJSON&quot;, func(c *gin.Context) &#123;\n\n\t\tvar json Login &#x2F;&#x2F; Login结构体\n\n\n    &#x2F;&#x2F; if initialization; condition &#123;\n    &#x2F;&#x2F;     &#x2F;&#x2F; do something\n    &#x2F;&#x2F; &#125;\n\n    &#x2F;&#x2F; 例如:\n\n    &#x2F;&#x2F; val :&#x3D; 10\n    &#x2F;&#x2F; if val &gt; max &#123;\n    &#x2F;&#x2F;     &#x2F;&#x2F; do something\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; 你也可以这样写:\n\n    &#x2F;&#x2F; if val :&#x3D; 10; val &gt; max &#123;\n    &#x2F;&#x2F;     &#x2F;&#x2F; do something\n    &#x2F;&#x2F; &#125;\n\n    &#x2F;&#x2F; ————————————————\n    &#x2F;&#x2F; 原文作者：Go 技术论坛文档：《Go 入门指南（）》\n    &#x2F;&#x2F; 转自链接：https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;the-way-to-go&#x2F;if-else-structure&#x2F;3592\n    &#x2F;&#x2F; 版权声明：翻译文档著作权归译者和 LearnKu 社区所有。转载请保留原文链接\n\t\tif err :&#x3D; c.ShouldBindJSON(&amp;json); err !&#x3D; nil &#123;\n\t\t\tc.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\tif json.User !&#x3D; &quot;manu&quot; || json.Password !&#x3D; &quot;123&quot; &#123;\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\tc.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)\n\t&#125;)\n\n\t&#x2F;&#x2F; 绑定 XML (\n\t&#x2F;&#x2F;\t&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n\t&#x2F;&#x2F;\t&lt;root&gt;\n\t&#x2F;&#x2F;\t\t&lt;user&gt;manu&lt;&#x2F;user&gt;\n\t&#x2F;&#x2F;\t\t&lt;password&gt;123&lt;&#x2F;password&gt;\n\t&#x2F;&#x2F;\t&lt;&#x2F;root&gt;)\n\trouter.POST(&quot;&#x2F;loginXML&quot;, func(c *gin.Context) &#123;\n\t\tvar xml Login\n\t\tif err :&#x3D; c.ShouldBindXML(&amp;xml); err !&#x3D; nil &#123;\n\t\t\tc.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\tif xml.User !&#x3D; &quot;manu&quot; || xml.Password !&#x3D; &quot;123&quot; &#123;\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\tc.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)\n\t&#125;)\n\n\t&#x2F;&#x2F; 绑定 HTML 表单 (user&#x3D;manu&amp;password&#x3D;123)\n\trouter.POST(&quot;&#x2F;loginForm&quot;, func(c *gin.Context) &#123;\n\t\tvar form Login\n\t\t&#x2F;&#x2F; 根据 Content-Type Header 推断使用哪个绑定器。\n\t\tif err :&#x3D; c.ShouldBind(&amp;form); err !&#x3D; nil &#123;\n\t\t\tc.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\tif form.User !&#x3D; &quot;manu&quot; || form.Password !&#x3D; &quot;123&quot; &#123;\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\tc.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)\n\t&#125;)\n\n\t&#x2F;&#x2F; 监听并在 0.0.0.0:8080 上启动服务\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n请求测试\n\n$ curl -v -X POST \\\n  http:&#x2F;&#x2F;localhost:8080&#x2F;loginJSON \\\n  -H &#39;content-type: application&#x2F;json&#39; \\\n  -d &#39;&#123; &quot;user&quot;: &quot;manu&quot; &#125;&#39;\n&gt; POST &#x2F;loginJSON HTTP&#x2F;1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl&#x2F;7.51.0\n&gt; Accept: *&#x2F;*\n&gt; content-type: application&#x2F;json\n&gt; Content-Length: 18\n&gt;\n* upload completely sent off: 18 out of 18 bytes\n&lt; HTTP&#x2F;1.1 400 Bad Request\n&lt; Content-Type: application&#x2F;json; charset&#x3D;utf-8\n&lt; Date: Fri, 04 Aug 2017 03:51:31 GMT\n&lt; Content-Length: 100\n&lt;\n&#123;&quot;error&quot;:&quot;Key: &#39;Login.Password&#39; Error:Field validation for &#39;Password&#39; failed on the &#39;required&#39; tag&quot;&#125;\n\nCustom Validatorspackage main\n\nimport (\n  &quot;net&#x2F;http&quot;\n  &quot;time&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&#x2F;binding&quot;\n  &quot;github.com&#x2F;go-playground&#x2F;validator&#x2F;v10&quot;\n)\n\n&#x2F;&#x2F; Booking contains binded and validated data.\ntype Booking struct &#123;\n  CheckIn  time.Time &#96;form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;&#96;\n  CheckOut time.Time &#96;form:&quot;check_out&quot; binding:&quot;required,gtfield&#x3D;CheckIn&quot; time_format:&quot;2006-01-02&quot;&#96;\n&#125;\n&#x2F;&#x2F; 校验函数\nvar bookableDate validator.Func &#x3D; func(fl validator.FieldLevel) bool &#123;\n  date, ok :&#x3D; fl.Field().Interface().(time.Time)\n  if ok &#123;\n    today :&#x3D; time.Now()\n    if today.After(date) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;\n\nfunc main() &#123;\n  route :&#x3D; gin.Default()\n\n  if v, ok :&#x3D; binding.Validator.Engine().(*validator.Validate); ok &#123;\n    &#x2F;&#x2F; 注册校验函数\n    v.RegisterValidation(&quot;bookabledate&quot;, bookableDate)\n  &#125;\n\n  route.GET(&quot;&#x2F;bookable&quot;, getBookable)\n  route.Run(&quot;:8085&quot;)\n&#125;\n\nfunc getBookable(c *gin.Context) &#123;\n  var b Booking\n  if err :&#x3D; c.ShouldBindWith(&amp;b, binding.Query); err &#x3D;&#x3D; nil &#123;\n    c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Booking dates are valid!&quot;&#125;)\n  &#125; else &#123;\n    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n  &#125;\n&#125;\n\n测试\n$ curl &quot;localhost:8085&#x2F;bookable?check_in&#x3D;2030-04-16&amp;check_out&#x3D;2030-04-17&quot;\n&#123;&quot;message&quot;:&quot;Booking dates are valid!&quot;&#125;\n\n$ curl &quot;localhost:8085&#x2F;bookable?check_in&#x3D;2030-03-10&amp;check_out&#x3D;2030-03-09&quot;\n&#123;&quot;error&quot;:&quot;Key: &#39;Booking.CheckOut&#39; Error:Field validation for &#39;CheckOut&#39; failed on the &#39;gtfield&#39; tag&quot;&#125;\n\n$ curl &quot;localhost:8085&#x2F;bookable?check_in&#x3D;2000-03-09&amp;check_out&#x3D;2000-03-10&quot;\n&#123;&quot;error&quot;:&quot;Key: &#39;Booking.CheckIn&#39; Error:Field validation for &#39;CheckIn&#39; failed on the &#39;bookabledate&#39; tag&quot;&#125;%\n\n忽略验证\n使用上述的 curl 命令运行上面的示例时会返回错误。因为示例中 Password 使用了 binding:&quot;required&quot;。如果 Password 使用 binding:&quot;-&quot;， 再次运行上面的示例就不会返回错误。\nStruct 级别的校验可以用另一种方式来注册 struct-lvl-validation example\n数据绑定Only Bind Query StringShouldBindQuery function only binds the query params and not the post data. See the detail information.\nShouldBindQuery 函数只绑定 url 查询参数而忽略 post 数据。参阅详细信息.\npackage main\nimport (\n  &quot;log&quot;\n  &quot;net&#x2F;http&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype Person struct &#123;\n  Name    string &#96;form:&quot;name&quot;&#96;\n  Address string &#96;form:&quot;address&quot;&#96;\n&#125;\n\nfunc main() &#123;\n  route :&#x3D; gin.Default()\n  route.Any(&quot;&#x2F;testing&quot;, startPage)\n  route.Run(&quot;:8085&quot;)\n&#125;\n\nfunc startPage(c *gin.Context) &#123;\n  var person Person\n  if c.ShouldBindQuery(&amp;person) &#x3D;&#x3D; nil &#123;\n    log.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Only Bind By Query String &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    log.Println(person.Name)\n    log.Println(person.Address)\n  &#125;\n  c.String(http.StatusOK, &quot;Success&quot;)\n&#125;\n\nBind Query String or Post Data ?package main\n\nimport (\n  &quot;log&quot;\n  &quot;net&#x2F;http&quot;\n  &quot;time&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype Person struct &#123;\n        Name       string    &#96;form:&quot;name&quot;&#96;\n        Address    string    &#96;form:&quot;address&quot;&#96;\n        Birthday   time.Time &#96;form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;&#96;\n        CreateTime time.Time &#96;form:&quot;createTime&quot; time_format:&quot;unixNano&quot;&#96;\n        UnixTime   time.Time &#96;form:&quot;unixTime&quot; time_format:&quot;unix&quot;&#96;\n&#125;\n\nfunc main() &#123;\n  route :&#x3D; gin.Default()\n  route.GET(&quot;&#x2F;testing&quot;, startPage)\n  route.Run(&quot;:8085&quot;)\n&#125;\n\nfunc startPage(c *gin.Context) &#123;\n  var person Person\n  &#x2F;&#x2F; If &#96;GET&#96;, only &#96;Form&#96; binding engine (&#96;query&#96;) used.\n  &#x2F;&#x2F; If &#96;POST&#96;, first checks the &#96;content-type&#96; for &#96;JSON&#96; or &#96;XML&#96;, then uses &#96;Form&#96; (&#96;form-data&#96;).\n  &#x2F;&#x2F; See more at https:&#x2F;&#x2F;github.com&#x2F;gin-gonic&#x2F;gin&#x2F;blob&#x2F;master&#x2F;binding&#x2F;binding.go#L88\n  if c.ShouldBind(&amp;person) &#x3D;&#x3D; nil &#123;\n          log.Println(person.Name)\n          log.Println(person.Address)\n          log.Println(person.Birthday)\n          log.Println(person.CreateTime)\n          log.Println(person.UnixTime)\n  &#125;\n\n  c.String(http.StatusOK, &quot;Success&quot;)\n&#125;\n\nBind Uripackage main\n\nimport (\n  &quot;net&#x2F;http&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype Person struct &#123;\n  ID string &#96;uri:&quot;id&quot; binding:&quot;required,uuid&quot;&#96; &#x2F;&#x2F; uri:&quot;id&quot; 映射到ID\n  Name string &#96;uri:&quot;name&quot; binding:&quot;required&quot;&#96; &#x2F;&#x2F;  uri:&quot;name&quot; 映射到 Name\n&#125;\n\nfunc main() &#123;\n  route :&#x3D; gin.Default()\n  route.GET(&quot;&#x2F;:name&#x2F;:id&quot;, func(c *gin.Context) &#123;\n    var person Person\n    if err :&#x3D; c.ShouldBindUri(&amp;person); err !&#x3D; nil &#123;\n      c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: err.Error()&#125;)\n      return\n    &#125;\n    c.JSON(http.StatusOK, gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;)\n  &#125;)\n  route.Run(&quot;:8088&quot;)\n&#125;\n\ntest\ncurl -v localhost:8088&#x2F;thinkerou&#x2F;987fbc97-4bed-5078-9f07-9141ba07c9f3\ncurl -v localhost:8088&#x2F;thinkerou&#x2F;not-uuid\n\nBind Headerpackage main\n\nimport (\n  &quot;fmt&quot;\n  &quot;net&#x2F;http&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype testHeader struct &#123;\n  Rate   int    &#96;header:&quot;Rate&quot;&#96; &#x2F;&#x2F; header中 Rate字段\n  Domain string &#96;header:&quot;Domain&quot;&#96; &#x2F;&#x2F; header中 Domain字段\n&#125;\n\nfunc main() &#123;\n  r :&#x3D; gin.Default()\n  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n    h :&#x3D; testHeader&#123;&#125;\n\n    if err :&#x3D; c.ShouldBindHeader(&amp;h); err !&#x3D; nil &#123;\n      c.JSON(http.StatusOK, err)\n    &#125;\n\n    fmt.Printf(&quot;%#v\\n&quot;, h)\n    c.JSON(http.StatusOK, gin.H&#123;&quot;Rate&quot;: h.Rate, &quot;Domain&quot;: h.Domain&#125;)\n  &#125;)\n\n  r.Run()\n\n&#x2F;&#x2F; client\n&#x2F;&#x2F; curl -H &quot;rate:300&quot; -H &quot;domain:music&quot; 127.0.0.1:8080&#x2F;\n&#x2F;&#x2F; output\n&#x2F;&#x2F; &#123;&quot;Domain&quot;:&quot;music&quot;,&quot;Rate&quot;:300&#125;\n&#125;\n\nBind HTML checkboxes参见 详细信息\npackage main\n\nimport (\n    &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype myForm struct &#123;\n    Colors []string &#96;form:&quot;colors[]&quot;&#96; &#x2F;&#x2F; 表单中的colors字段\n&#125;\n\nfunc main() &#123;\n    r :&#x3D; gin.Default()\n\n    r.LoadHTMLGlob(&quot;views&#x2F;*&quot;)\n    r.GET(&quot;&#x2F;&quot;, indexHandler)\n    r.POST(&quot;&#x2F;&quot;, formHandler)\n\n    r.Run(&quot;:8080&quot;)\n&#125;\n\nfunc indexHandler(c *gin.Context) &#123;\n    c.HTML(200, &quot;form.html&quot;, nil)\n&#125;\n\nfunc formHandler(c *gin.Context) &#123;\n    var fakeForm myForm\n    c.Bind(&amp;fakeForm)\n    c.JSON(200, gin.H&#123;&quot;color&quot;: fakeForm.Colors&#125;)\n&#125;\n\n\nAnd the form (“views&#x2F;form.html”) :\n&lt;form action&#x3D;&quot;&#x2F;&quot; method&#x3D;&quot;POST&quot;&gt;\n  &lt;p&gt;Check some colors&lt;&#x2F;p&gt;\n  &lt;label for&#x3D;&quot;red&quot;&gt;Red&lt;&#x2F;label&gt;\n  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;colors[]&quot; value&#x3D;&quot;red&quot; id&#x3D;&quot;red&quot; &#x2F;&gt;\n  &lt;label for&#x3D;&quot;green&quot;&gt;Green&lt;&#x2F;label&gt;\n  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;colors[]&quot; value&#x3D;&quot;green&quot; id&#x3D;&quot;green&quot; &#x2F;&gt;\n  &lt;label for&#x3D;&quot;blue&quot;&gt;Blue&lt;&#x2F;label&gt;\n  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;colors[]&quot; value&#x3D;&quot;blue&quot; id&#x3D;&quot;blue&quot; &#x2F;&gt;\n  &lt;input type&#x3D;&quot;submit&quot; &#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n&#123;&quot;color&quot;:[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]&#125;\n\n返回数据XML, JSON, YAML and ProtoBuf renderingfunc main() &#123;\n  r :&#x3D; gin.Default()\n\n  &#x2F;&#x2F; gin.H is a shortcut for map[string]interface&#123;&#125;\n  r.GET(&quot;&#x2F;someJSON&quot;, func(c *gin.Context) &#123;\n    c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)\n  &#125;)\n\n  r.GET(&quot;&#x2F;moreJSON&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; You also can use a struct\n    var msg struct &#123;\n      Name    string &#96;json:&quot;user&quot;&#96; &#x2F;&#x2F; 前面的会转化成后面的\n      Message string\n      Number  int\n    &#125;\n    msg.Name &#x3D; &quot;Lena&quot;\n    msg.Message &#x3D; &quot;hey&quot;\n    msg.Number &#x3D; 123\n    &#x2F;&#x2F; Note that msg.Name becomes &quot;user&quot; in the JSON\n    &#x2F;&#x2F; Will output  :   &#123;&quot;user&quot;: &quot;Lena&quot;, &quot;Message&quot;: &quot;hey&quot;, &quot;Number&quot;: 123&#125;\n    c.JSON(http.StatusOK, msg)\n  &#125;)\n\n  r.GET(&quot;&#x2F;someXML&quot;, func(c *gin.Context) &#123;\n    c.XML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)\n  &#125;)\n\n  r.GET(&quot;&#x2F;someYAML&quot;, func(c *gin.Context) &#123;\n    c.YAML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)\n  &#125;)\n\n  r.GET(&quot;&#x2F;someProtoBuf&quot;, func(c *gin.Context) &#123;\n    reps :&#x3D; []int64&#123;int64(1), int64(2)&#125;\n    label :&#x3D; &quot;test&quot;\n    &#x2F;&#x2F; The specific definition of protobuf is written in the testdata&#x2F;protoexample file.\n    &#x2F;&#x2F; protobuf的具体定义写在testdata&#x2F;protoexample文件中。\n    data :&#x3D; &amp;protoexample.Test&#123;\n      Label: &amp;label,\n      Reps:  reps,\n    &#125;\n    &#x2F;&#x2F; Note that data becomes binary data in the response\n    &#x2F;&#x2F; Will output protoexample.Test protobuf serialized data\n    &#x2F;&#x2F; 二进制数据返回\n    c.ProtoBuf(http.StatusOK, data)\n  &#125;)\n\n  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080\n  r.Run(&quot;:8080&quot;)\n&#125;\n\nJSON 数据大小写问题\n\n\n\nJSONSecureJSON ??Using SecureJSON to prevent json hijacking. Default prepends “while(1),” to response body if the given struct is array values.\n使用 SecureJSON 防止 json 劫持。如果给定的结构是数组值，则默认在响应正文前面加上“while（1）”。\nfunc main() &#123;\n  r :&#x3D; gin.Default()\n\n  &#x2F;&#x2F; You can also use your own secure json prefix\n  &#x2F;&#x2F; r.SecureJsonPrefix(&quot;)]&#125;&#39;,\\n&quot;)\n\n  r.GET(&quot;&#x2F;someJSON&quot;, func(c *gin.Context) &#123;\n    names :&#x3D; []string&#123;&quot;lena&quot;, &quot;austin&quot;, &quot;foo&quot;&#125;\n\n    &#x2F;&#x2F; Will output  :   while(1);[&quot;lena&quot;,&quot;austin&quot;,&quot;foo&quot;]\n    c.SecureJSON(http.StatusOK, names)\n  &#125;)\n\n  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080\n  r.Run(&quot;:8080&quot;)\n&#125;\n\nJSONPUsing JSONP to request data from a server in a different domain.Add callback to response body if the query parameter callback exists.\nfunc main() &#123;\n  r :&#x3D; gin.Default()\n\n  r.GET(&quot;&#x2F;JSONP&quot;, func(c *gin.Context) &#123;\n    data :&#x3D; gin.H&#123;\n      &quot;foo&quot;: &quot;bar&quot;,\n    &#125;\n\n    &#x2F;&#x2F; callback is x\n    &#x2F;&#x2F; Will output  :   x(&#123;\\&quot;foo\\&quot;:\\&quot;bar\\&quot;&#125;) &#x2F;&#x2F; 回调形式\n    c.JSONP(http.StatusOK, data)\n  &#125;)\n\n  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080\n  r.Run(&quot;:8080&quot;)\n\n        &#x2F;&#x2F; client\n        &#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;JSONP?callback&#x3D;x\n&#125;\n\nAsciiJSONUsing AsciiJSON to Generates ASCII-only JSON with escaped non-ASCII characters.\nfunc main() &#123;\n  r :&#x3D; gin.Default()\n\n  r.GET(&quot;&#x2F;someJSON&quot;, func(c *gin.Context) &#123;\n    data :&#x3D; gin.H&#123;\n      &quot;lang&quot;: &quot;GO语言&quot;,\n      &quot;tag&quot;:  &quot;&lt;br&gt;&quot;,\n    &#125;\n\n    &#x2F;&#x2F; will output : &#123;&quot;lang&quot;:&quot;GO\\u8bed\\u8a00&quot;,&quot;tag&quot;:&quot;\\u003cbr\\u003e&quot;&#125;\n    c.AsciiJSON(http.StatusOK, data)\n  &#125;)\n\n  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080\n  r.Run(&quot;:8080&quot;)\n&#125;\n\nPureJSONNormally, JSON replaces special HTML characters with their unicode entities, e.g. &lt; becomes \\u003c. If you want to encode such characters literally, you can use PureJSON instead. This feature is unavailable in Go 1.6 and lower.\n通常，JSON 使用 unicode 替换特殊 HTML 字符，例如 &lt; 变为 \\ u003c。\n如果要按字面对这些字符进行编码，则可以使用 PureJSON。Go 1.6 及更低版本无法使用此功能。\nfunc main() &#123;\n  r :&#x3D; gin.Default()\n\n  &#x2F;&#x2F; Serves unicode entities\n  r.GET(&quot;&#x2F;json&quot;, func(c *gin.Context) &#123;\n    c.JSON(http.StatusOK, gin.H&#123;\n      &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;&#x2F;b&gt;&quot;,\n    &#125;)\n  &#125;)\n\n  &#x2F;&#x2F; Serves literal characters\n  r.GET(&quot;&#x2F;purejson&quot;, func(c *gin.Context) &#123;\n    c.PureJSON(http.StatusOK, gin.H&#123;\n      &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;&#x2F;b&gt;&quot;,\n    &#125;)\n  &#125;)\n\n  &#x2F;&#x2F; listen and serve on 0.0.0.0:8080\n  r.Run(&quot;:8080&quot;)\n&#125;\n\n文件资源Serving static filesfunc main() &#123;\n  router :&#x3D; gin.Default()\n  &#x2F;&#x2F; 下面这几个有什么区别\n  &#x2F;&#x2F; router.Static 指定某个目录为静态资源目录，可直接访问这个目录下的资源，url 要具体到资源名称。\n  &#x2F;&#x2F; router.StaticFS 比前面一个多了个功能，当目录下不存 index.html 文件时，会列出该目录下的所有文件。\n  &#x2F;&#x2F; router.StaticFile 指定某个具体的文件作为静态资源访问。\n  &#x2F;&#x2F; router.StaticFileFS 指定某个具体的文件作为静态资源访问,文件不存在，会列出该目录下的所有文件。\n\n\n  &#x2F;&#x2F; 作者：gentyxiao\n  &#x2F;&#x2F; 链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;09175c17419c\n  &#x2F;&#x2F; 来源：简书\n  &#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n  router.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;assets&quot;)\n  router.StaticFS(&quot;&#x2F;more_static&quot;, http.Dir(&quot;my_file_system&quot;))\n  router.StaticFile(&quot;&#x2F;favicon.ico&quot;, &quot;.&#x2F;resources&#x2F;favicon.ico&quot;)\n  router.StaticFileFS(&quot;&#x2F;more_favicon.ico&quot;, &quot;more_favicon.ico&quot;, http.Dir(&quot;my_file_system&quot;))\n\n  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080\n  router.Run(&quot;:8080&quot;)\n&#125;\n\nServing data from filefunc main() &#123;\n  router :&#x3D; gin.Default()\n\n  router.GET(&quot;&#x2F;local&#x2F;file&quot;, func(c *gin.Context) &#123;\n    c.File(&quot;local&#x2F;file.go&quot;)\n  &#125;)\n\n  var fs http.FileSystem &#x3D; &#x2F;&#x2F; ...\n\n  router.GET(&quot;&#x2F;fs&#x2F;file&quot;, func(c *gin.Context) &#123;\n    c.FileFromFS(&quot;fs&#x2F;file.go&quot;, fs)\n  &#125;)\n&#125;\n\n\nServing data from readerfunc main() &#123;\n  router :&#x3D; gin.Default()\n  router.GET(&quot;&#x2F;someDataFromReader&quot;, func(c *gin.Context) &#123;\n    response, err :&#x3D; http.Get(&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gin-gonic&#x2F;logo&#x2F;master&#x2F;color.png&quot;)\n    if err !&#x3D; nil || response.StatusCode !&#x3D; http.StatusOK &#123;\n      c.Status(http.StatusServiceUnavailable)\n      return\n    &#125;\n\n    reader :&#x3D; response.Body\n     defer reader.Close()\n    contentLength :&#x3D; response.ContentLength\n    contentType :&#x3D; response.Header.Get(&quot;Content-Type&quot;)\n\n    extraHeaders :&#x3D; map[string]string&#123;\n      &quot;Content-Disposition&quot;: &#96;attachment; filename&#x3D;&quot;gopher.png&quot;&#96;,\n    &#125;\n\n    c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)\n  &#125;)\n  router.Run(&quot;:8080&quot;)\n&#125;\n\n渲染HTML renderingCustom Template rendererCustom DelimitersCustom Template FuncsMultitemplate重定向RedirectsHTTP 重定向很容易。 内部、外部重定向均支持。\n\nr.GET(&quot;&#x2F;test&quot;, func(c *gin.Context) &#123;\n  c.Redirect(http.StatusMovedPermanently, &quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;)\n&#125;)\n\n\n通过 POST 方法进行 HTTP 重定向。请参考 issue：#444\nr.POST(&quot;&#x2F;test&quot;, func(c *gin.Context) &#123;\n  c.Redirect(http.StatusFound, &quot;&#x2F;foo&quot;)\n&#125;)\n\n路由重定向，使用 HandleContext：\nr.GET(&quot;&#x2F;test&quot;, func(c *gin.Context) &#123;\n    c.Request.URL.Path &#x3D; &quot;&#x2F;test2&quot;\n    r.HandleContext(c)\n&#125;)\n\nr.GET(&quot;&#x2F;test2&quot;, func(c *gin.Context) &#123;\n    c.JSON(http.StatusOK, gin.H&#123;&quot;hello&quot;: &quot;world&quot;&#125;)\n&#125;)\n\n自定义中间件洋葱模型，不是 koa 原创啊\n图 1： 中间件执行顺序\n -->\n\n\n续图 1，图 2: 中间件执行顺序\n图 3: 阻止中间件往后执行\n\n\n图 4：阻止中间件往后、往下执行\n全局中间件\n  \n  \n  \n\n\n跨中间件存取值Custom MiddlewareUsing BasicAuth() middlewareGoroutines inside a middlewareCustom HTTP configuration加密Support Let’s Encrypt 没看懂多服务器See the question and try the following example:\n\npackage main\n\nimport (\n  &quot;log&quot;\n  &quot;net&#x2F;http&quot;\n  &quot;time&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n  &quot;golang.org&#x2F;x&#x2F;sync&#x2F;errgroup&quot;\n)\n\nvar (\n  g errgroup.Group\n)\n&#x2F;&#x2F; 服务器1的路由\nfunc router01() http.Handler &#123;\n  e :&#x3D; gin.New()\n  e.Use(gin.Recovery())\n  e.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n    c.JSON(\n      http.StatusOK,\n      gin.H&#123;\n        &quot;code&quot;:  http.StatusOK,\n        &quot;error&quot;: &quot;Welcome server 01&quot;,\n      &#125;,\n    )\n  &#125;)\n\n  return e\n&#125;\n&#x2F;&#x2F; 服务器2的路由\nfunc router02() http.Handler &#123;\n  e :&#x3D; gin.New()\n  e.Use(gin.Recovery())\n  e.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n    c.JSON(\n      http.StatusOK,\n      gin.H&#123;\n        &quot;code&quot;:  http.StatusOK,\n        &quot;error&quot;: &quot;Welcome server 02&quot;,\n      &#125;,\n    )\n  &#125;)\n\n  return e\n&#125;\n\nfunc main() &#123;\n  &#x2F;&#x2F; 服务器1\n  server01 :&#x3D; &amp;http.Server&#123;\n    Addr:         &quot;:8080&quot;,\n    Handler:      router01(),\n    ReadTimeout:  5 * time.Second,\n    WriteTimeout: 10 * time.Second,\n  &#125;\n  &#x2F;&#x2F; 服务器2\n  server02 :&#x3D; &amp;http.Server&#123;\n    Addr:         &quot;:8081&quot;,\n    Handler:      router02(),\n    ReadTimeout:  5 * time.Second,\n    WriteTimeout: 10 * time.Second,\n  &#125;\n  &#x2F;&#x2F; 错误监听处理， 启动并发？\n  g.Go(func() error &#123;\n    err :&#x3D; server01.ListenAndServe()\n    if err !&#x3D; nil &amp;&amp; err !&#x3D; http.ErrServerClosed &#123;\n      log.Fatal(err)\n    &#125;\n    return err\n  &#125;)\n\n  g.Go(func() error &#123;\n    err :&#x3D; server02.ListenAndServe()\n    if err !&#x3D; nil &amp;&amp; err !&#x3D; http.ErrServerClosed &#123;\n      log.Fatal(err)\n    &#125;\n    return err\n  &#125;)\n\n  if err :&#x3D; g.Wait(); err !&#x3D; nil &#123;\n    log.Fatal(err)\n  &#125;\n&#125;\n\n正常关机&#x2F;重启 ? 可能在部署时候会用？你想优雅地重启或停止 web 服务器吗？有一些方法可以做到这一点。\n我们可以使用 fvbock&#x2F;endless 来替换默认的 ListenAndServe。更多详细信息，请参阅 issue #296。\nrouter :&#x3D; gin.Default()\nrouter.GET(&quot;&#x2F;&quot;, handler)\n&#x2F;&#x2F; [...]\nendless.ListenAndServe(&quot;:4242&quot;, router)\n\n替代方案:\nmanners：可以优雅关机的 Go Http 服务器。graceful：Graceful 是一个 Go 扩展包，可以优雅地关闭 http.Handler 服务器。grace：Go 服务器平滑重启和零停机时间部署。如果你使用的是 Go 1.8，可以不需要这些库！考虑使用 http.Server 内置的 Shutdown() 方法优雅地关机. 请参阅 gin 完整的 graceful-shutdown 示例。\n&#x2F;&#x2F; +build go1.8\npackage main\n\nimport (\n\t&quot;context&quot;\n\t&quot;log&quot;\n\t&quot;net&#x2F;http&quot;\n\t&quot;os&quot;\n\t&quot;os&#x2F;signal&quot;\n\t&quot;time&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\trouter.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n\t\ttime.Sleep(5 * time.Second)\n\t\tc.String(http.StatusOK, &quot;Welcome Gin Server&quot;)\n\t&#125;)\n\n\tsrv :&#x3D; &amp;http.Server&#123;\n\t\tAddr:    &quot;:8080&quot;,\n\t\tHandler: router,\n\t&#125;\n\n\tgo func() &#123;\n\t\t&#x2F;&#x2F; 服务连接\n\t\tif err :&#x3D; srv.ListenAndServe(); err !&#x3D; nil &amp;&amp; err !&#x3D; http.ErrServerClosed &#123;\n\t\t\tlog.Fatalf(&quot;listen: %s\\n&quot;, err)\n\t\t&#125;\n\t&#125;()\n\n\t&#x2F;&#x2F; 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）\n\tquit :&#x3D; make(chan os.Signal)\n\tsignal.Notify(quit, os.Interrupt)\n\t&lt;-quit\n\tlog.Println(&quot;Shutdown Server ...&quot;)\n\n\tctx, cancel :&#x3D; context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tif err :&#x3D; srv.Shutdown(ctx); err !&#x3D; nil &#123;\n\t\tlog.Fatal(&quot;Server Shutdown:&quot;, err)\n\t&#125;\n\tlog.Println(&quot;Server exiting&quot;)\n&#125;\n\n模版Build a single binary with templatesYou can build a server into a single binary containing templates by using go-assets.\nfunc main() &#123;\n  r :&#x3D; gin.New()\n  &#x2F;&#x2F; 加载模版\n  t, err :&#x3D; loadTemplate()\n  if err !&#x3D; nil &#123;\n    panic(err)\n  &#125;\n  &#x2F;&#x2F; 设置模版\n  r.SetHTMLTemplate(t)\n\n  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n    &#x2F;&#x2F; 返回html\n    c.HTML(http.StatusOK, &quot;&#x2F;html&#x2F;index.tmpl&quot;,nil)\n  &#125;)\n  r.Run(&quot;:8080&quot;)\n&#125;\n\n&#x2F;&#x2F; loadTemplate加载go资产生成器嵌入的模板\nfunc loadTemplate() (*template.Template, error) &#123;\n  t :&#x3D; template.New(&quot;&quot;)\n  for name, file :&#x3D; range Assets.Files &#123;\n    defer file.Close()\n    if file.IsDir() || !strings.HasSuffix(name, &quot;.tmpl&quot;) &#123;\n      continue\n    &#125;\n    h, err :&#x3D; ioutil.ReadAll(file)\n    if err !&#x3D; nil &#123;\n      return nil, err\n    &#125;\n    t, err &#x3D; t.New(name).Parse(string(h))\n    if err !&#x3D; nil &#123;\n      return nil, err\n    &#125;\n  &#125;\n  return t, nil\n&#125;\n\nSee a complete example in the https://github.com/gin-gonic/examples/tree/master/assets-in-binary directory.\n数据绑定Bind form-data request with custom structTry to bind body into different structsBind form-data request with custom struct and custom tag服务端推送http2 server push实际项目中很少用到\nhttp.Pusher is supported only go1.8+. See the golang blog for detail information.\n\npackage main\n\nimport (\n  &quot;html&#x2F;template&quot;\n  &quot;log&quot;\n  &quot;net&#x2F;http&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nvar html &#x3D; template.Must(template.New(&quot;https&quot;).Parse(&#96;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Https Test&lt;&#x2F;title&gt;\n  &lt;script src&#x3D;&quot;&#x2F;assets&#x2F;app.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;h1 style&#x3D;&quot;color:red;&quot;&gt;Welcome, Ginner!&lt;&#x2F;h1&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n&#96;))\n\nfunc main() &#123;\n  r :&#x3D; gin.Default()\n  &#x2F;&#x2F; 静态文件目录\n  r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;assets&quot;)\n  &#x2F;&#x2F;设置html模版\n  r.SetHTMLTemplate(html)\n\n  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n    if pusher :&#x3D; c.Writer.Pusher(); pusher !&#x3D; nil &#123;\n      &#x2F;&#x2F; use pusher.Push() to do server push\n      if err :&#x3D; pusher.Push(&quot;&#x2F;assets&#x2F;app.js&quot;, nil); err !&#x3D; nil &#123;\n        log.Printf(&quot;Failed to push: %v&quot;, err)\n      &#125;\n    &#125;\n    c.HTML(http.StatusOK, &quot;https&quot;, gin.H&#123;\n      &quot;status&quot;: &quot;success&quot;,\n    &#125;)\n  &#125;)\n\n  &#x2F;&#x2F; Listen and Server in https:&#x2F;&#x2F;127.0.0.1:8080\n  &#x2F;&#x2F; https 证书\n  r.RunTLS(&quot;:8080&quot;, &quot;.&#x2F;testdata&#x2F;server.pem&quot;, &quot;.&#x2F;testdata&#x2F;server.key&quot;)\n&#125;\n\n日志Define format for the log of routesThe default log of routes is:\n[GIN-debug] POST &#x2F;foo --&gt; main.main.func1 (3 handlers)\n[GIN-debug] GET &#x2F;bar --&gt; main.main.func2 (3 handlers)\n[GIN-debug] GET &#x2F;status --&gt; main.main.func3 (3 handlers)\n\nIf you want to log this information in given format (e.g. JSON, key values or something else), then you can define this format with gin.DebugPrintRouteFunc. In the example below, we log all routes with standard log package but you can use another log tools that suits of your needs.\nimport (\n  &quot;log&quot;\n  &quot;net&#x2F;http&quot;\n\n  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n  r :&#x3D; gin.Default()\n  gin.DebugPrintRouteFunc &#x3D; func(httpMethod, absolutePath, handlerName string, nuHandlers int) &#123;\n    log.Printf(&quot;endpoint %v %v %v %v\\n&quot;, httpMethod, absolutePath, handlerName, nuHandlers)\n  &#125;\n\n  r.POST(&quot;&#x2F;foo&quot;, func(c *gin.Context) &#123;\n    c.JSON(http.StatusOK, &quot;foo&quot;)\n  &#125;)\n\n  r.GET(&quot;&#x2F;bar&quot;, func(c *gin.Context) &#123;\n    c.JSON(http.StatusOK, &quot;bar&quot;)\n  &#125;)\n\n  r.GET(&quot;&#x2F;status&quot;, func(c *gin.Context) &#123;\n    c.JSON(http.StatusOK, &quot;ok&quot;)\n  &#125;)\n\n  &#x2F;&#x2F; Listen and Server in http:&#x2F;&#x2F;0.0.0.0:8080\n  r.Run()\n&#125;\n\ncookieSet and get a cookieimport (\n    &quot;fmt&quot;\n\n    &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\n    router :&#x3D; gin.Default()\n\n    router.GET(&quot;&#x2F;cookie&quot;, func(c *gin.Context) &#123;\n        &#x2F;&#x2F; 获取cookie, 没设置“gin_cookie”会报错\n        cookie, err :&#x3D; c.Cookie(&quot;gin_cookie&quot;)\n        &#x2F;&#x2F; 遇到错误设置cookie\n        if err !&#x3D; nil &#123;\n            cookie &#x3D; &quot;NotSet&quot;\n            &#x2F;&#x2F; 设置cookie\n            c.SetCookie(&quot;gin_cookie&quot;, &quot;test&quot;, 3600, &quot;&#x2F;&quot;, &quot;localhost&quot;, false, true)\n        &#125;\n\n        fmt.Printf(&quot;Cookie value: %s \\n&quot;, cookie)\n    &#125;)\n\n    router.Run()\n&#125;\n\n表名规则db.logMode(true)来显示日志\n\n表名规则，根据 struct 名称改成小写，并且加上复数形式\n\n例子： struct 名为：\n\nTest，对应表名为 tests\nTopicClass,表名为 topic_classes 注意复数，英文基础：ch、sh、x、s 结尾时，加 es 变成复数\n\n可以使用db.SingularTable(true)来使其不为复数\n其他的session、redis、orm、数据库链接热重载https://github.com/cosmtrek/air \n\nhttps://github.com/oxequa/realize\n\nhttps://github.com/codegangsta/gin\n\nhttps://github.com/gravityblast/fresh\n\nhttps://github.com/beego/bee\n\nhttps://github.com/silenceper/gowatch\n\ndocker 部署路很长https://github.com/overnote/over-golang\n\n\n\n参考链接gin-gonic&#x2F;gin\nTutorial: Developing a RESTful API with Go and Gin\ngin_book\nGitHub Repo stars\n博客收录https://liwenzhou.com/\n","slug":"2022-10-15gin","date":"2022-10-15T06:57:18.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"cc6337a39cba986d99843e70d56686e5","title":"Go 语言 特殊语法","content":"目前所遇到最好的教程go 教程\nhttps://studygolang.com/pkgdoc\n🤔 -->\n\n\n下载安装 go官方安装包地址\n\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ go version\ngo version go1.19.2 darwin&#x2F;amd64\n\n\nTour 教程之前没找到到这文档，看了菜鸟教程的 go，傻白白地以为没教程\nhttps://tour.go-zh.org/welcome/1\n\n \n命名返回见\n实现\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。\n\n功能\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n优缺点：直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n函数 -->\n\npackage main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 返回多个返回值，有形参名称的\nfunc foo3(a string, b int) (r1 int, r2 int) &#123;\n\tfmt.Println(&quot;----foo3 ----&quot;)\n\tfmt.Println(&quot;a &#x3D;&quot;, a)\n\tfmt.Println(&quot;b &#x3D;&quot;, b)\n\t&#x2F;&#x2F; r1r2属于foo3的形参，初始化默认的值是0\n\t&#x2F;&#x2F; r1r2作用域空间是foo3整个函数体的&#123;&#125;空间\n\tfmt.Println(&quot;r1 &#x3D;&quot;, r1)\n\tfmt.Println(&quot;r2 &quot;, r2)\n\t&#x2F;&#x2F; 给有名称的返回值变量赋值\n\tr1 &#x3D; 1000\n\tr2 &#x3D; 2000\n\treturn\n&#125;\n\n\n\nIfif 的简短语句同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。\nif 和 else在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;math&quot;\n)\n\nfunc pow(x, n, lim float64) float64 &#123;\n\tif v :&#x3D; math.Pow(x, n); v &lt; lim &#123;\n\t\treturn v\n\t&#125; else &#123;\n\t\tfmt.Printf(&quot;%g &gt;&#x3D; %g\\n&quot;, v, lim)\n\t&#125;\n\t&#x2F;&#x2F; 这里开始就不能使用 v 了\n\treturn lim\n&#125;\n\nfunc main() &#123;\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n&#125;\n\n\nif initialization; condition &#123;\n    &#x2F;&#x2F; do something\n&#125;\n\n&#x2F;&#x2F; 例如:\n\nval :&#x3D; 10\nif val &gt; max &#123;\n    &#x2F;&#x2F; do something\n&#125;\n&#x2F;&#x2F; 你也可以这样写:\n\nif val :&#x3D; 10; val &gt; max &#123;\n    &#x2F;&#x2F; do something\n&#125;\n\n&#x2F;&#x2F; ————————————————\n&#x2F;&#x2F; 原文作者：Go 技术论坛文档：《Go 入门指南（）》\n&#x2F;&#x2F; 转自链接：https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;the-way-to-go&#x2F;if-else-structure&#x2F;3592\n&#x2F;&#x2F; 版权声明：翻译文档著作权归译者和 LearnKu 社区所有。转载请保留原文链接\n\n\nswitchswitch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n与众不同Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。除非以 fallthrough 语句结束，否则分支会自动终止 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\nswitch 的求值顺序switch 的求值顺序switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n&#x2F;&#x2F; （例如，\n\nswitch i &#123;\ncase 0:\ncase f():\n&#125;\n&#x2F;&#x2F; 在 i&#x3D;&#x3D;0 时 f 不会被调用。）\n\n没有条件的 switch没有条件的 switch 同 switch true 一样。\n这种形式能将一长串 if-then-else 写得更加清晰。\n\n\ndefer推迟到外函数执行&#x2F;&#x2F; defer\n&#x2F;&#x2F; defer 语句会将函数推迟到外层函数返回之后执行。\n&#x2F;&#x2F; 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\tdefer fmt.Println(&quot;world&quot;)\n\n\tfmt.Println(&quot;hello&quot;)\n&#125;\n\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world\n\n哦～原来如此，defer db.Close()\n执行推迟时候，出栈推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用\n数组数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型\n语法：\nvar variable_name [SIZE] variable_type\n\n数组初始化\n基本操作&#x2F;&#x2F; [] 被用于限定大小，&#123;&#125; 用于内容，与其他语言不同\nvar balance &#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n\n:&#x3D;&#x2F;&#x2F; 我们也可以通过字面量在声明数组的同时快速初始化数组：\nbalance :&#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; &#x2F;&#x2F; :&#x3D; 声明赋值运算符\n\n长度不定&#x2F;&#x2F; 如果数组长度不确定，可以使用 ... 代替数组的长度，\n&#x2F;&#x2F; 编译器会根据元素个数自行推断数组的长度：\nvar balance &#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F; 或\nbalance :&#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n&#x2F;&#x2F; 如果设置了数组的长度，我们还可以通过指定下标来初始化元素：\n\n指定索引赋值&#x2F;&#x2F; 将索引为 1 和 3 的元素初始化\nbalance :&#x3D; [5]float32&#123;1:2.0,3:7.0&#125;\n&#x2F;&#x2F; 初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。\n\n自动推断&#x2F;&#x2F; 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：\n\nbalance[4] &#x3D; 50.0\n\n\n多维数组语法var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    &#x2F;&#x2F; Step 1: 创建数组\n    values :&#x3D; [][]int&#123;&#125; &#x2F;&#x2F; 这里要注意下，目前见到的例子都是空值初始化\n\n    &#x2F;&#x2F; Step 2: 使用 append() 函数向空的二维数组添加两行一维数组\n    row1 :&#x3D; []int&#123;1, 2, 3&#125;\n    row2 :&#x3D; []int&#123;4, 5, 6&#125;\n    values &#x3D; append(values, row1)\n    values &#x3D; append(values, row2)\n\n    &#x2F;&#x2F; Step 3: 显示两行数据\n    fmt.Println(&quot;Row 1&quot;)\n    fmt.Println(values[0])\n    fmt.Println(&quot;Row 2&quot;)\n    fmt.Println(values[1])\n\n    &#x2F;&#x2F; Step 4: 访问第一个元素\n    fmt.Println(&quot;第一个元素为：&quot;)\n    fmt.Println(values[0][0])\n&#125;\n\n\n指针指针的指针指向指针的指针如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。\n当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：\n指向指针的指针变量声明格式如下：\nvar ptr **int;\n\n\n例子：\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n\n   var a int\n   var ptr *int\n   var pptr **int\n\n   a &#x3D; 3000\n\n   &#x2F;* 指针 ptr 地址 *&#x2F;\n   ptr &#x3D; &amp;a\n\n   &#x2F;* 指向指针 ptr 地址 *&#x2F;\n   pptr &#x3D; &amp;ptr\n\n   &#x2F;* 获取 pptr 的值 *&#x2F;\n   fmt.Printf(&quot;变量 a &#x3D; %d\\n&quot;, a )\n   fmt.Printf(&quot;指针变量 *ptr &#x3D; %d\\n&quot;, *ptr )\n   fmt.Printf(&quot;指向指针的指针变量 **pptr &#x3D; %d\\n&quot;, **pptr)\n&#125;\n\n\n结构体\n其他语言对比：go 语言保留了，OC 中的结构体？可以理解为类的另一种写法\n\n自身数组区别：Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。\n\n构造函数有没有联系：我在想：结构体里的构是不是，构造函数的 构\n\n\n函数传值：传值：直接结构体生成的变量，传引用：变量前* *user\n -->\n\n\n -->\n\n\n -->\n\n\n结构体继承子类实现\n -->\n\n\n实例化\n两种赋值方式， 第一种没见过吧，～～\n -->\n\n\n万能类型 与 断言 -->\n\n\n大小写 -->\n\n\n语法&#x2F;&#x2F; 结构体定义需要使用 type 和 struct 语句。\n&#x2F;&#x2F; struct 语句定义一个新的数据类型，结构体中有一个或多个成员。\n&#x2F;&#x2F; type 语句设定了结构体的名称。结构体的格式如下：\n\ntype struct_variable_type struct &#123;\n   member definition\n   member definition\n   ...\n   member definition\n&#125;\n\n一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：\nvariable_name :&#x3D; structure_variable_type &#123;value1, value2...valuen&#125;\n或\nvariable_name :&#x3D; structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;\n\nexamplepackage main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n\n    &#x2F;&#x2F; 创建一个新的结构体\n    fmt.Println(Books&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)\n\n    &#x2F;&#x2F; 也可以使用 key &#x3D;&gt; value 格式\n    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;, subject: &quot;Go 语言教程&quot;, book_id: 6495407&#125;)\n\n    &#x2F;&#x2F; 忽略的字段为 0 或 空\n   fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;&#125;)\n&#125;\n\n结构体指针你可以定义指向结构体的指针类似于其他指针变量，格式如下：\nvar struct_pointer *Books\n\n&#x2F;&#x2F; 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：\nstruct_pointer &#x3D; &amp;Book1\n\n&#x2F;&#x2F; 使用结构体指针访问结构体成员，使用 &quot;.&quot; 操作符：\nstruct_pointer.title\n\nexample\npackage main\n\nimport &quot;fmt&quot;\n\ntype Books struct &#123;\n   title string\n   author string\n   subject string\n   book_id int\n&#125;\n\nfunc main() &#123;\n   var Book1 Books        &#x2F;* 声明 Book1 为 Books 类型 *&#x2F;\n   var Book2 Books        &#x2F;* 声明 Book2 为 Books 类型 *&#x2F;\n\n   &#x2F;* book 1 描述 *&#x2F;\n   Book1.title &#x3D; &quot;Go 语言&quot;\n   Book1.author &#x3D; &quot;www.runoob.com&quot;\n   Book1.subject &#x3D; &quot;Go 语言教程&quot;\n   Book1.book_id &#x3D; 6495407\n\n   &#x2F;* book 2 描述 *&#x2F;\n   Book2.title &#x3D; &quot;Python 教程&quot;\n   Book2.author &#x3D; &quot;www.runoob.com&quot;\n   Book2.subject &#x3D; &quot;Python 语言教程&quot;\n   Book2.book_id &#x3D; 6495700\n\n   &#x2F;* 打印 Book1 信息 *&#x2F;\n   printBook(&amp;Book1)\n\n   &#x2F;* 打印 Book2 信息 *&#x2F;\n   printBook(&amp;Book2)\n&#125;\nfunc printBook( book *Books ) &#123;\n   fmt.Printf( &quot;Book title : %s\\n&quot;, book.title)\n   fmt.Printf( &quot;Book author : %s\\n&quot;, book.author)\n   fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject)\n   fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id)\n&#125;\n\n切片\npython 中也有切片，与 go 很像，又与 python 区别很大\n\nGo 语言切片是对数组的抽象。\n切片出现的原因：go 数组长度固定，不够灵活\nGo 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。\n语法&#x2F;&#x2F; 方式1\nvar identifier []type\n&#x2F;&#x2F; 方式2 使用 make() 函数来创建切片\nvar slice1 []type &#x3D; make([]type, len)\n&#x2F;&#x2F; 方式3 也可以简写为\nslice1 :&#x3D; make([]type, len)\n\n初始化类 python\n&#x2F;&#x2F; 直接初始化切片，[] 表示是切片类型，&#123;1,2,3&#125; 初始化值依次是 1,2,3，其 cap&#x3D;len&#x3D;3。\ns :&#x3D;[] int &#123;1,2,3 &#125;\n\n&#x2F;&#x2F; 初始化切片 s，是数组 arr 的引用。\ns :&#x3D; arr[:]\n\n&#x2F;&#x2F; 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。\ns :&#x3D; arr[startIndex:endIndex] &#x2F;&#x2F; 左闭右开\n\n&#x2F;&#x2F; 默认 endIndex 时将表示一直到arr的最后一个元素。\ns :&#x3D; arr[startIndex:]\n\n&#x2F;&#x2F; 默认 startIndex 时将表示从 arr 的第一个元素开始。\ns :&#x3D; arr[:endIndex]\n\n&#x2F;&#x2F; 通过切片 s 初始化切片 s1。\ns1 :&#x3D; s[startIndex:endIndex]\n\n&#x2F;&#x2F; 通过内置函数 make() 初始化切片s，[]int 标识为其元素类型为 int 的切片。\ns :&#x3D;make([]int,len,cap)\n\nlen() 和 cap() 函数make([]T, length, capacity/*可选参数，容量*/)\n切片是可索引的，并且可以由 len() 方法获取长度。\n切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。\n&#x2F;&#x2F; 以下为具体实例：\n&#x2F;&#x2F; 实例\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var numbers &#x3D; make([]int,3&#x2F;**长度 *&#x2F;,5&#x2F;**容量 *&#x2F;)\n\n   printSlice(numbers)\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;\n&#x2F;&#x2F; 以上实例运行输出结果为:\n\nlen&#x3D;3 cap&#x3D;5 slice&#x3D;[0 0 0]\n\n空(nil)切片一个切片在未初始化之前默认为 nil，长度为 0，实例如下：\n切片截取注意点：切片声明时候赋值用&#123;&#125;，在切片赋值和打印时候都是数组[item1,item2, ...]\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   &#x2F;* 创建切片 *&#x2F;\n   numbers :&#x3D; []int&#123;0,1,2,3,4,5,6,7,8&#125;\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;9 cap&#x3D;9 slice&#x3D;[0 1 2 3 4 5 6 7 8]\n\n   &#x2F;* 打印原始切片 *&#x2F;\n   fmt.Println(&quot;numbers &#x3D;&#x3D;&quot;, numbers) &#x2F;&#x2F; numbers &#x3D;&#x3D; [0 1 2 3 4 5 6 7 8]\n\n   &#x2F;* 打印子切片从索引1(包含) 到索引4(不包含)*&#x2F;\n   fmt.Println(&quot;numbers[1:4] &#x3D;&#x3D;&quot;, numbers[1:4]) &#x2F;&#x2F; numbers[1:4] &#x3D;&#x3D; [1 2 3]\n\n   &#x2F;* 默认下限为 0*&#x2F;\n   fmt.Println(&quot;numbers[:3] &#x3D;&#x3D;&quot;, numbers[:3]) &#x2F;&#x2F; numbers[:3] &#x3D;&#x3D; [0 1 2]\n\n   &#x2F;* 默认上限为 len(s)*&#x2F;\n   fmt.Println(&quot;numbers[4:] &#x3D;&#x3D;&quot;, numbers[4:]) &#x2F;&#x2F; numbers[4:] &#x3D;&#x3D; [4 5 6 7 8]\n\n   numbers1 :&#x3D; make([]int,0,5)\n   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;5 slice&#x3D;[]\n\n   &#x2F;* 打印子切片从索引  0(包含) 到索引 2(不包含) *&#x2F;\n   number2 :&#x3D; numbers[:2]\n   printSlice(number2) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;9 slice&#x3D;[0 1]\n\n   &#x2F;* 打印子切片从索引 2(包含) 到索引 5(不包含) *&#x2F;\n   number3 :&#x3D; numbers[2:5]\n   printSlice(number3) &#x2F;&#x2F; len&#x3D;3 cap&#x3D;7 slice&#x3D;[2 3 4]\n\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;\n\nappend() 和 copy() 函数这个又何 python很像，python 中，有些申请的变量是不能更改的，更改操作是对原来的拷贝再处理过程\n如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。\n下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var numbers []int\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;0 slice&#x3D;[]\n\n   &#x2F;* 允许追加空切片 *&#x2F;\n   numbers &#x3D; append(numbers, 0)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;1 cap&#x3D;1 slice&#x3D;[0]\n\n   &#x2F;* 向切片添加一个元素 *&#x2F;\n   numbers &#x3D; append(numbers, 1)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;2 slice&#x3D;[0 1]\n\n   &#x2F;* 同时添加多个元素 *&#x2F;\n   numbers &#x3D; append(numbers, 2,3,4)\n   printSlice(numbers) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;6 slice&#x3D;[0 1 2 3 4]\n\n   &#x2F;* 创建切片 numbers1 是之前切片的两倍容量*&#x2F;\n   numbers1 :&#x3D; make([]int, len(numbers), (cap(numbers))*2)\n\n   &#x2F;* 拷贝 numbers 的内容到 numbers1 *&#x2F;\n   copy(numbers1,numbers)\n   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;12 slice&#x3D;[0 1 2 3 4]\n&#125;\n\nfunc printSlice(x []int)&#123;\n   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\\n&quot;,len(x),cap(x),x)\n&#125;\n\n\nRange注意： 这玩意和 python 很不一样，这个是标识符， python 的 range 是个函数\nGo 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素\n\n数组和切片中它返回元素的索引和索引对应的值\n集合中返回 key-value 对\n\n语法for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：\n&#x2F;&#x2F; 语法1\nfor key, value :&#x3D; range oldMap &#123;\n    newMap[key] &#x3D; value\n&#125;\n&#x2F;&#x2F; 语法2\nfor key :&#x3D; range oldMap\n\n&#x2F;&#x2F; 语法3\nfor key, _ :&#x3D; range oldMap\n\n&#x2F;&#x2F; 语法4\nfor _, value :&#x3D; range oldMap\n\nMapgo map 没有 javascript 那么多 api,简单来说就一个，那就是像对象一样赋值\n语法&#x2F;* 声明变量，默认 map 是 nil *&#x2F;\nvar map_variable map[key_data_type]value_data_type\n\n&#x2F;* 使用 make 函数 *&#x2F;\nmap_variable :&#x3D; make(map[key_data_type]value_data_type)\n\nexamplepackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    var countryCapitalMap map[string]string &#x2F;*创建集合 *&#x2F;\n    countryCapitalMap &#x3D; make(map[string]string)\n\n    &#x2F;* map插入key - value对,各个国家对应的首都 *&#x2F;\n    countryCapitalMap [ &quot;France&quot; ] &#x3D; &quot;巴黎&quot;\n    countryCapitalMap [ &quot;Italy&quot; ] &#x3D; &quot;罗马&quot;\n    countryCapitalMap [ &quot;Japan&quot; ] &#x3D; &quot;东京&quot;\n    countryCapitalMap [ &quot;India &quot; ] &#x3D; &quot;新德里&quot;\n\n    &#x2F;*使用键输出地图值 *&#x2F;\n    for country :&#x3D; range countryCapitalMap &#123;\n        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])\n    &#125;\n\n    &#x2F;*查看元素在集合中是否存在 *&#x2F;\n    capital, ok :&#x3D; countryCapitalMap [ &quot;American&quot; ] &#x2F;*如果确定是真实的,则存在,否则不存在 *&#x2F;\n    &#x2F;*fmt.Println(capital) *&#x2F;\n    &#x2F;*fmt.Println(ok) *&#x2F;\n    if (ok) &#123;\n        fmt.Println(&quot;American 的首都是&quot;, capital)\n    &#125; else &#123;\n        fmt.Println(&quot;American 的首都不存在&quot;)\n    &#125;\n&#125;\n\ndeletego map 删除元素用的是 delete 方法\ndelete() 函数用于删除集合的元素, 参数为 map 和其对应的 key\ndelete(countryCapitalMap, &quot;France&quot;)\n\nexample\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n        &#x2F;* 创建map *&#x2F;\n        countryCapitalMap :&#x3D; map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;\n\n        fmt.Println(&quot;原始地图&quot;)\n\n        &#x2F;* 打印地图 *&#x2F;\n        for country :&#x3D; range countryCapitalMap &#123;\n                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])\n        &#125;\n\n        &#x2F;*删除元素*&#x2F; delete(countryCapitalMap, &quot;France&quot;)\n        fmt.Println(&quot;法国条目被删除&quot;)\n\n        fmt.Println(&quot;删除元素后地图&quot;)\n\n        &#x2F;*打印地图*&#x2F;\n        for country :&#x3D; range countryCapitalMap &#123;\n                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])\n        &#125;\n&#125;\n\n类型转换类型转换用于将一种数据类型的变量转换为另外一种类型的变量\n语法type_name(expression) &#x2F;&#x2F; type_name 为类型，expression 为表达式。\n\nexamplepackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n   var sum int &#x3D; 17\n   var count int &#x3D; 5\n   var mean float32\n\n   mean &#x3D; float32(sum)&#x2F;float32(count) &#x2F;&#x2F; 这里\n   fmt.Printf(&quot;mean 的值为: %f\\n&quot;,mean)\n&#125;\n\n接口 interfaceGo 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。\n语法&#x2F;* 定义接口 *&#x2F;\ntype interface_name interface &#123;\n   method_name1 [return_type]\n   method_name2 [return_type]\n   method_name3 [return_type]\n   ...\n   method_namen [return_type]\n&#125;\n\n&#x2F;* 定义结构体 *&#x2F;\ntype struct_name struct &#123;\n   &#x2F;* variables *&#x2F;\n&#125;\n\n&#x2F;* 实现接口方法 *&#x2F;\nfunc (struct_name_variable struct_name) method_name1() [return_type] &#123;\n   &#x2F;* 方法实现 *&#x2F;\n&#125;\n...\nfunc (struct_name_variable struct_name) method_namen() [return_type] &#123;\n   &#x2F;* 方法实现*&#x2F;\n&#125;\n\nexamplepackage main\n\nimport (\n    &quot;fmt&quot;\n)\n\ntype Phone interface &#123;\n    call()\n&#125;\n\ntype NokiaPhone struct &#123;\n&#125;\n\nfunc (nokiaPhone NokiaPhone) &#x2F;**前面这块 *&#x2F;call() &#123;\n    fmt.Println(&quot;I am Nokia, I can call you!&quot;)\n&#125;\n\ntype IPhone struct &#123;\n&#125;\n\nfunc (iPhone IPhone)&#x2F;**前面这块 *&#x2F; call() &#123;\n    fmt.Println(&quot;I am iPhone, I can call you!&quot;)\n&#125;\n\nfunc main() &#123;\n    var phone Phone &#x2F;&#x2F; interface 类型变量\n    &#x2F;&#x2F; 我本以为没有new 关键字，原来有啊\n    &#x2F;&#x2F; 不明白这里为什么 NokiaPhone的实例可以赋值给 phone，原因：**其他类型只要实现了这些方法就是实现了这个接口**\n    phone &#x3D; new(NokiaPhone)\n    phone.call()\n\n    phone &#x3D; new(IPhone)\n    phone.call()\n\n&#125;\n\n\nreflectreflect 数据结构 -->\n\n\n获取字段、类型、值 -->\n\n -->\n\n\n结构体数据转 json -->\n\n\njson 转结构体数据\n\n结构体标签\n\n -->\n\nReflect api 及作用 ?&#x2F;&#x2F; - 获取类型信息：reflect.TypeOf，是静态的 &#x2F;&#x2F; 结构体\n&#x2F;&#x2F; - 获取值信息：reflect.ValueOf，是动态的 &#x2F;&#x2F; &#123;1 zs 20&#125;\n&#x2F;&#x2F; - 遍历探测其 属性 &#x2F;&#x2F; NumField()\n&#x2F;&#x2F; - 遍历探测其 方法 &#x2F;&#x2F; NumMethod()   &#x2F;&#x2F;  &#123;&quot;Name&quot;: &quot;Hello&quot;, &quot;Type&quot;: func(main.User)&#125;\n&#x2F;&#x2F; reflect.Value提供了Elem()方法，可以获得指针向指向的value，设置的是指针所指向的内容 https:&#x2F;&#x2F;www.topgoer.cn&#x2F;docs&#x2F;gozhuanjia&#x2F;chapter066.1-reflect\n&#x2F;&#x2F; 其他api见文档 https:&#x2F;&#x2F;pkg.go.dev&#x2F;reflect\n\n\n代码\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;reflect&quot;\n)\n\n&#x2F;&#x2F; 定义结构体\ntype User struct &#123;\n\tId   int\n\tName string\n\tAge  int\n&#125;\n\n&#x2F;&#x2F; 绑方法\nfunc (u User) Hello() &#123;\n\tfmt.Println(&quot;Hello&quot;)\n&#125;\n\n&#x2F;&#x2F; 传入interface&#123;&#125;\nfunc Poni(o interface&#123;&#125;) &#123;\n\tt :&#x3D; reflect.TypeOf(o) &#x2F;&#x2F; 结构体\n\tfmt.Println(&quot;类型：&quot;, t)\n\tfmt.Println(&quot;字符串类型：&quot;, t.Name())\n\t&#x2F;&#x2F; 获取值\n\tv :&#x3D; reflect.ValueOf(o)\n\tfmt.Println(v)\n\t&#x2F;&#x2F; 可以获取所有属性\n\t&#x2F;&#x2F; 获取结构体字段个数：t.NumField()\n\tfor i :&#x3D; 0; i &lt; t.NumField(); i++ &#123; &#x2F;&#x2F; 遍历探测其Filed\n\t\t&#x2F;&#x2F; 取每个字段\n\t\tf :&#x3D; t.Field(i)\n\t\tfmt.Printf(&quot;%s : %v&quot;, f.Name, f.Type) &#x2F;&#x2F; Id : int\n\t\t&#x2F;&#x2F; 获取字段的值信息\n\t\t&#x2F;&#x2F; Interface()：获取字段对应的值\n\t\tval :&#x3D; v.Field(i).Interface() &#x2F;&#x2F; 奇怪，Interface竟然能拿到值\n\n\t\t&#x2F;&#x2F; fmt.Println(&quot;  val :&quot;, val) &#x2F;&#x2F;   val : 1\n\n    &#x2F;&#x2F; fmt.Println(&quot;Name Type  val :&quot;, f.Name, f.Type, val)\n\n    &#x2F;&#x2F; Name Type  val : Id int 1\n    &#x2F;&#x2F; Name Type  val : Name string zs\n    &#x2F;&#x2F; Name Type  val : Age int 20\n\t&#125;\n\tfmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n\tfor i :&#x3D; 0; i &lt; t.NumMethod(); i++ &#123;\n\t\tm :&#x3D; t.Method(i)\n\t\tfmt.Println(m.Name)\n\t\tfmt.Println(m.Type)\n\t&#125;\n\n&#125;\nfunc main() &#123;\n\tu :&#x3D; User&#123;1, &quot;zs&quot;, 20&#125;\n\tPoni(u)\n&#125;\n\n&#x2F;&#x2F; 类型： main.User\n&#x2F;&#x2F; 字符串类型： User\n&#x2F;&#x2F; &#123;1 zs 20&#125;\n&#x2F;&#x2F; Id : int  val : 1\n&#x2F;&#x2F; Name : string  val : zs\n&#x2F;&#x2F; Age : int  val : 20\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; Hello\n&#x2F;&#x2F; func(main.User)\n\n&#x2F;&#x2F; Program exited.\n\n\n参考\notherGolang 的反射 reflect 深入理解和示例\nGo 的 json 解析：Marshal 与 Unmarshal\njson.Marshal 结构体转 json\njson.Unmarshal json 转结构体\n\njson.Marshalimport (\n    &quot;encoding&#x2F;json&quot;\n    &quot;fmt&quot;\n)\n\ntype User struct &#123;\n    Name  string &#96;json:&quot;user_name&quot;&#96;\n    Age   int    &#96;json:&quot;age&quot;&#96;\n    sex   string\n    Work1 *Work1\n    Work2 *Work2\n    Work3 Work3\n    Work4 interface&#123;&#125; &#96;json:&quot;work4&quot;&#96;\n&#125;\n\ntype Work1 struct &#123;\n    Name   string &#96;json:&quot;work1_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work2 struct &#123;\n    Name   string &#96;json:&quot;work2_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work3 struct &#123;\n    Name   string &#96;json:&quot;work3_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work4 struct &#123;\n    Name    string &#96;json:&quot;work4_name&quot;&#96;\n    Salary  float32\n    Address string &#96;json:&quot;work4_add&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F; 实例化User\n    u1 :&#x3D; User&#123;\n        Name: &quot;ares&quot;,\n        Age:  18,\n        sex:  &quot;男&quot;,\n    &#125;\n    &#x2F;&#x2F; 指针\n    w1 :&#x3D; Work1&#123;\n        Name:   &quot;god1&quot;,\n        Salary: 100,\n    &#125;\n    u1.Work1 &#x3D; &amp;w1\n    &#x2F;&#x2F; 指针\n    w2 :&#x3D; new(Work2)\n    w2.Name &#x3D; &quot;god2&quot;\n    w2.Salary &#x3D; 200\n    u1.Work2 &#x3D; w2\n    &#x2F;&#x2F; 非指针\n    w3 :&#x3D; Work3&#123;\n        Name:   &quot;god3&quot;,\n        Salary: 300,\n    &#125;\n    u1.Work3 &#x3D; w3\n    &#x2F;&#x2F; 非指针\n    w4 :&#x3D; Work4&#123;\n        Name:    &quot;god4&quot;,\n        Salary:  400,\n        Address: &quot;cbd&quot;,\n    &#125;\n    u1.Work4 &#x3D; w4\n    &#x2F;&#x2F;Marshal失败时err!&#x3D;nil\n    jsonU, err :&#x3D; json.Marshal(u1)\n    if err !&#x3D; nil &#123;\n        fmt.Println(&quot;生成json字符串错误&quot;)\n    &#125;\n\n    &#x2F;&#x2F; jsonU是[]byte类型，转化成string类型便于查看\n    &#x2F;**\n    &#123;\n        &quot;user_name&quot;: &quot;ares&quot;,\n        &quot;age&quot;: 18,\n        &quot;Work1&quot;: &#123;\n            &quot;work1_name&quot;: &quot;god1&quot;,\n            &quot;Salary&quot;: 100\n        &#125;,\n        &quot;Work2&quot;: &#123;\n            &quot;work2_name&quot;: &quot;god2&quot;,\n            &quot;Salary&quot;: 200\n        &#125;,\n        &quot;Work3&quot;: &#123;\n            &quot;work3_name&quot;: &quot;god3&quot;,\n            &quot;Salary&quot;: 300\n        &#125;,\n        &quot;work4&quot;: &#123;\n            &quot;work4_name&quot;: &quot;god4&quot;,\n            &quot;Salary&quot;: 400,\n            &quot;work4_add&quot;: &quot;cbd&quot;\n        &#125;\n    &#125;\n    *&#x2F;\n    fmt.Println(string(jsonU))\n&#125;\n\n\nJson Unmarshal&#x2F;&#x2F; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;aresxin&#x2F;p&#x2F;go-json.html&quot; target&#x3D;&quot;_blank&quot; &gt;Go 的 json 解析:Marshal 与 Unmarshal&lt;&#x2F;a&gt;\nimport (\n    &quot;encoding&#x2F;json&quot;\n    &quot;fmt&quot;\n    &quot;reflect&quot;\n)\n\ntype User struct &#123;\n    Name  string &#96;json:&quot;user_name&quot;&#96;\n    Age   int    &#96;json:&quot;age&quot;&#96;\n    sex   string\n    Work1 *Work1\n    Work2 json.RawMessage\n    Work3 Work3\n    Work4 interface&#123;&#125; &#96;json:&quot;work4&quot;&#96;\n    Work5 interface&#123;&#125;\n&#125;\n\ntype Work1 struct &#123;\n    Name   string &#96;json:&quot;work1_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work2 struct &#123;\n    Name   string &#96;json:&quot;work2_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work3 struct &#123;\n    Name   string &#96;json:&quot;work3_name&quot;&#96;\n    Salary float32\n&#125;\n\ntype Work4 struct &#123;\n    Name    string &#96;json:&quot;work4_name&quot;&#96;\n    Salary  float32\n    Address string &#96;json:&quot;work4_add&quot;&#96;\n&#125;\n\nfunc main() &#123;\n    &#x2F;&#x2F;json字符中的&quot;引号，需用\\进行转义，否则编译出错\n    data :&#x3D; &quot;&#123;\\&quot;user_name\\&quot;:\\&quot;ares\\&quot;,\\&quot;sex\\&quot;:\\&quot;男\\&quot;,\\&quot;age\\&quot;:18,\\&quot;Work1\\&quot;:&#123;\\&quot;work1_name\\&quot;:\\&quot;god1\\&quot;,\\&quot;Salary\\&quot;:100&#125;,\\&quot;Work2\\&quot;:&#123;\\&quot;work2_name\\&quot;:\\&quot;god2\\&quot;,\\&quot;Salary\\&quot;:200&#125;,\\&quot;Work3\\&quot;:&#123;\\&quot;work3_name\\&quot;:\\&quot;god3\\&quot;,\\&quot;Salary\\&quot;:300&#125;,\\&quot;work4\\&quot;:&#123;\\&quot;work4_name\\&quot;:\\&quot;god4\\&quot;,\\&quot;Salary\\&quot;:400,\\&quot;work4_add\\&quot;:\\&quot;cbd\\&quot;&#125;&#125;&quot;\n    str :&#x3D; []byte(data)\n    u1 :&#x3D; User&#123;&#125;\n    &#x2F;&#x2F; Unmarshal的第一个参数是json字符串，第二个参数是接受json解析的数据结构.第二个参数必须是指针，否则无法接收解析的数据，\n    err :&#x3D; json.Unmarshal(str, &amp;u1)\n    if err !&#x3D; nil &#123;\n        fmt.Println(&quot;Unmarshal err,&quot;, err)\n    &#125;\n    &#x2F;&#x2F; &#123;ares 18  0xc0000a41c8 0xc0000a41e0 &#123;god3 300&#125; map[Salary:400 work4_add:cbd work4_name:god4]&#125;  Work2 为*Work2类型\n    &#x2F;&#x2F;  Work2 为json.RawMessage类型  &#123;ares 18  0xc0000a4198 [123 34 119 111 114 107 50 95 110 97 109 101 34 58 34 103 111 100 50 34 44 34 83 97 108 97 114 121 34 58 50 48 48 125] &#123;god3 300&#125; map[Salary:400 work4_add:cbd work4_name:god4] &lt;nil&gt;&#125;\n\n    fmt.Println(u1)\n    &#x2F;&#x2F; 查看类型\n    nameType :&#x3D; reflect.TypeOf(u1.Name)\n    ageType :&#x3D; reflect.TypeOf(u1.Age)\n    sexType :&#x3D; reflect.TypeOf(u1.sex)\n    work1Type :&#x3D; reflect.TypeOf(u1.Work1)\n    work2Type :&#x3D; reflect.TypeOf(u1.Work2)\n    work3Type :&#x3D; reflect.TypeOf(u1.Work3)\n    work4Type :&#x3D; reflect.TypeOf(u1.Work4)\n    work5Type :&#x3D; reflect.TypeOf(u1.Work5)\n    fmt.Println(nameType)  &#x2F;&#x2F; string\n    fmt.Println(ageType)   &#x2F;&#x2F; int\n    fmt.Println(sexType)   &#x2F;&#x2F; string\n    fmt.Println(work1Type) &#x2F;&#x2F; *main.Work1\n    fmt.Println(work2Type) &#x2F;&#x2F; json.RawMessage\n    fmt.Println(work3Type) &#x2F;&#x2F; main.Work3\n    fmt.Println(work4Type) &#x2F;&#x2F; map[string]interface &#123;&#125;\n    fmt.Println(work5Type) &#x2F;&#x2F; &lt;nil&gt;\n&#125;\n\n\njson 字符串解析时，需要一个“接收体”接受解析后的数据，且 Unmarshal 时接收体必须传递指针。解析时，接收体可自行定义。json 串中的 key 自动在接收体中寻找匹配的项进行赋值。匹配规则：\n\n先查找与 key 一样的 json 标签，找到则赋值给该标签对应的变量；\n没有 json 标签的，就从上往下依次查找变量名与 key 一样的变量，或者变量名忽略大小写后与 key 一样的变量，第一个匹配的就赋值，后面就算有匹配的也忽略（变量可导出，首字母大写）。\n当接收体中存在 json 串中匹配不了的项时，解析会自动忽略该项，该项仍保留原值。\n如变量 Work5，保留空值 nil。\njson 解析后，json 串中 value，只要是”简单数据”，都会按照默认的类型赋值。\n简单数据：是指不能再进行二次 json 解析的数据，例如 name\n复合数据：是可进行二次甚至多次 json 解析的，因为它的 value 也是个可被解析的独立 json，例如 work1-5。\n\n\n对于”复合数据”，如果接收体中配的项被声明为 interface{}类型，go 都会默认解析成 map[string]interface{}类型。\n如果想直接解析到 struct Class 对象中，可以将接受体对应的项定义为该 struct 类型。\n如果不想指定 work 变量为具体的类型，仍想保留 interface{}类型，但又希望该变量可以解析到 struct work 对象中，可以将该变量定义为 json.RawMessage 类型。\n被声明为 json.RawMessage 类型的变量在 json 解析时，变量值仍保留 json 的原值，即未被自动解析为 map[string]interface{}类型,可以对该变量进行二次 json 解析，因为其值仍是个独立且可解析的完整 json 串,只需再定义一个新的接受体即可。\n\ngoroutine\n\n\n\ngoroutine 数据通信\n\nchannel\n\n两个 channel 执行过程，及阻塞\n\n无缓存\n\n\n有缓存\n关闭 特点\n\n当 channel 已经满，再向里面写数据，会阻塞当 channel 为空，从里面取数据也会阻塞\n死锁读阻塞\n\n\n\n写阻塞\n\n\n\nchannel range\n\nchannel select\n\n\n\n管理工具\n\n\n\n\n\n\n\n\n\n错误处理通过内置的错误接口提供了非常简单的错误处理机制。\n语法error 类型是一个接口类型，这是它的定义：\ntype error interface &#123;\n  Error() string\n&#125;\n\n\n我们可以在编码中通过实现 error 接口类型来生成错误信息。\n函数通常在最后的返回值中返回错误信息。使用 errors.New 可返回一个错误信息：\nfunc Sqrt(f float64) (float64, error) &#123;\n    if f &lt; 0 &#123;\n        return 0, errors.New(&quot;math: square root of negative number&quot;)\n    &#125;\n    &#x2F;&#x2F; 实现\n&#125;\n\nexamplepackage main\n\nimport (\n    &quot;fmt&quot;\n)\n\n&#x2F;&#x2F; 定义一个 DivideError 结构\n&#x2F;&#x2F; 定义 xxx 结构体\ntype DivideError struct &#123;\n    dividee int\n    divider int\n&#125;\n\n&#x2F;&#x2F; 实现 &#96;error&#96; 接口\nfunc (de *DivideError&#x2F;**指针 *&#x2F;) Error() string &#123;\n    strFormat :&#x3D; &#96;\n    Cannot proceed, the divider is zero.\n    dividee: %d\n    divider: 0\n&#96;\n&#x2F;&#x2F; fmt.Sprintf这个api, 有点面熟，先定义模版，再替换模版中的变量值\n    return fmt.Sprintf(strFormat, de.dividee)\n&#125;\n\n&#x2F;&#x2F; 定义 &#96;int&#96; 类型除法运算的函数\nfunc Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;\n    if varDivider &#x3D;&#x3D; 0 &#123;\n        &#x2F;&#x2F; 结构体\n        dData :&#x3D; DivideError &#123;\n                dividee: varDividee,\n                divider: varDivider,\n        &#125;\n        &#x2F;&#x2F; 定义了一个结构体，直接调用结构体的方法，这也太直接了吧？\n        errorMsg &#x3D; dData.Error()\n        return\n    &#125; else &#123;\n        return varDividee &#x2F; varDivider, &quot;&quot;\n    &#125;\n\n&#125;\n\nfunc main() &#123;\n\n    &#x2F;&#x2F; 正常情况\n    &#x2F;** :&#x3D; 前面两个、后面两个，分别赋值 *&#x2F;\n    &#x2F;&#x2F; result 有值，执行if内容\n    if result, errorMsg :&#x3D; Divide(100, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;\n            fmt.Println(&quot;100&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 100&#x2F;10 &#x3D;  10\n    &#125;\n    &#x2F;&#x2F; result 为 0 ,执行if内容打印了\n    if result, errorMsg :&#x3D; Divide(0, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;\n      fmt.Println(&quot;0&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 0&#x2F;10 &#x3D;  0\n    &#125;\n\n    &#x2F;&#x2F; 当除数为零的时候会返回错误信息\n    &#x2F;&#x2F; errorMsg 有值，执行if内容\n    if _, errorMsg :&#x3D; Divide(100, 0); errorMsg !&#x3D; &quot;&quot; &#123;\n            fmt.Println(&quot;errorMsg is: &quot;, errorMsg)\n    &#x2F;&#x2F; errorMsg is:\n    &#x2F;&#x2F;   Cannot proceed, the divider is zero.\n    &#x2F;&#x2F;   dividee: 100\n    &#x2F;&#x2F;   divider: 0\n    &#x2F;&#x2F; 这个返回有点意思，前面格式化错误打印，第一个变量是通过 &#96;&#96;运算得来的，和javascript 有点类似，原样的格式输出\n    &#125;\n\n&#125;\n\n -->\n\n\n并发go 支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。\ngoroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。\n语法go 函数名( 参数列表 )\n\n&#x2F;&#x2F; 例如：\n\ngo f(x, y, z)\n&#x2F;&#x2F; 开启一个新的 goroutine:f(x, y, z)\n\n\n&#x2F;&#x2F; Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，\n&#x2F;&#x2F; 以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。\n\npackage main\n\nimport (\n        &quot;fmt&quot;\n        &quot;time&quot;\n)\n\nfunc say(s string) &#123;\n        for i :&#x3D; 0; i &lt; 5; i++ &#123;\n                time.Sleep(100 * time.Millisecond)\n                fmt.Println(s)\n        &#125;\n&#125;\n\nfunc main() &#123;\n        go say(&quot;world&quot;)\n        say(&quot;hello&quot;)\n&#125;\n\n&#x2F;&#x2F; 执行以上代码，你会看到输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行：\n\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; world\n&#x2F;&#x2F; world\n&#x2F;&#x2F; hello\n\n通道用来：打通 goroutine，进行数据传输的\n通道（channel）是用来传递数据的一个数据结构。\n通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;- 用于指定通道的方向，发送或接收。\n如果未指定方向，则为双向通道。\nch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch\nv :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据\n           &#x2F;&#x2F; 并把值赋给 v\n&#x2F;&#x2F; 声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：\n\nch :&#x3D; make(chan int)\n\n注意：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。\n以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：\nexamplepackage main\n\nimport &quot;fmt&quot;\n\nfunc sum(s []int, c chan int) &#123;\n        sum :&#x3D; 0\n        for _, v :&#x3D; range s &#123;\n                sum +&#x3D; v\n        &#125;\n        c &lt;- sum &#x2F;&#x2F; 把 sum 发送到通道 c\n&#125;\n\nfunc main() &#123;\n        s :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;\n\n        c :&#x3D; make(chan int)\n        go sum(s[:len(s)&#x2F;2], c) &#x2F;&#x2F; s[:len(s)&#x2F;2] [ -9, 4, 0]\n        go sum(s[len(s)&#x2F;2:], c) &#x2F;&#x2F; s[len(s)&#x2F;2:] [7, 2, 8]\n        x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收\n\n        fmt.Println(x, y, x+y)\n\n        &#x2F;&#x2F; -5 17 12\n&#125;\n\n\n\n -->\n\n\n&#x2F;&#x2F; 小改下\nfunc main() &#123;\n\ts :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;\n\n    c :&#x3D; make(chan int)\n    go sum(s[:len(s)&#x2F;2], c)\n    go sum(s[len(s)&#x2F;2:], c)\n\n    &#x2F;&#x2F; 下面这两个比goroutine先执行\n    fmt.Println(&quot;c&quot;)\n    fmt.Println(c)\n\n    x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收\n\n    a :&#x3D; &lt;-c &#x2F;&#x2F; 这里会报错\n\n    fmt.Println(a)\n\n    fmt.Println(x, y, x+y)\n\n&#125;\n\n&#x2F;&#x2F; c\n&#x2F;&#x2F; 0xc00006e060\n&#x2F;&#x2F; [-9 4 0]\n&#x2F;&#x2F; [7 2 8]\n&#x2F;&#x2F; fatal error: all goroutines are asleep - deadlock!\n\n&#x2F;&#x2F; goroutine 1 [chan receive]:\n&#x2F;&#x2F; main.main()\n&#x2F;&#x2F; &#x2F;tmp&#x2F;sandbox2040469662&#x2F;prog.go:26 +0x249\n\n&#x2F;&#x2F; Program exited.\n\n\n通道缓冲区通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：\nch :&#x3D; make(chan int, 100)\n\n带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\n不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。\n注意：\n\n如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。\n如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；\n如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\n\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n&#x2F;&#x2F; 这里我们定义了一个可以存储整数类型的带缓冲通道\n&#x2F;&#x2F; 缓冲区大小为2\n  ch :&#x3D; make(chan int, 2)\n\n  &#x2F;&#x2F; 因为 ch 是带缓冲的通道，我们可以同时发送两个数据\n  &#x2F;&#x2F; 而不用立刻需要去同步读取数据\n  ch &lt;- 1\n  ch &lt;- 2\n\n  &#x2F;&#x2F; 获取这两个数据\n  fmt.Println(&lt;-ch)\n  fmt.Println(&lt;-ch)\n\n&#x2F;&#x2F; 执行输出结果为：\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#125;\n\n\nGo 遍历通道与关闭通道Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：\n语法v, ok :&#x3D; &lt;-ch\n\n\nexamplepackage main\n\nimport (\n        &quot;fmt&quot;\n)\n\nfunc fibonacci(n int, c chan int) &#123;\n        x, y :&#x3D; 0, 1\n        for i :&#x3D; 0; i &lt; n; i++ &#123;\n                c &lt;- x\n                x, y &#x3D; y, x+y\n        &#125;\n        close(c)\n&#125;\n\nfunc main() &#123;\n        c :&#x3D; make(chan int, 10)\n        go fibonacci(cap(c), c)\n        &#x2F;&#x2F; range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个\n        &#x2F;&#x2F; 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据\n        &#x2F;&#x2F; 之后就结束了。\n        &#x2F;&#x2F; 如果上面的 c 通道不关闭，那么 range 函数就不会结束，从而在接收第 11 个数据的时候就阻塞了。\n        for i :&#x3D; range c &#123;\n                fmt.Println(i)\n        &#125;\n&#125;\n\n&#x2F;&#x2F; 执行输出结果为：\n\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 5\n&#x2F;&#x2F; 8\n&#x2F;&#x2F; 13\n&#x2F;&#x2F; 21\n&#x2F;&#x2F; 34\n\n\n如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。\nexample 不关闭 -->\n\n\nfatal error: all goroutines are asleep - deadlock!\n\n模块中大写见\n模块中大些的函数是被导出。\n\n缓存，取代产生文件\n绝对路径导入使用 import ( &quot;packagepath&quot;)\n安装go install packagepath\n\n参考链接runoob\ngolang play\ngin-gonic&#x2F;gin\nTutorial: Developing a RESTful API with Go and Gin\n博客收录这个文档比较好\nhttps://pkg.go.dev/\n待看见\nNonEnglish 文档go 中文文档中文文档\n导航分类\nhttps://www.topgoer.com/\n","slug":"2022-10-15go","date":"2022-10-15T01:54:03.000Z","categories_index":"Go","tags_index":"Go","author_index":"举手摘月亮"},{"id":"9a1d323e88658104fe9c4ac04b72ebe7","title":"nextjs useSearchParams","content":"背景需求\n列表切换详情，返回列表，要求查询表单参数不丢失，\n思路\n\n记录参数到 url 上，在记录的过程中，列表页面不刷新\n返回时候列表页只作为一个 history 栈中的一个记录\n\nMDN\n直接点：history.replaceState\nhistory.replaceState\nhistory.replaceState(stateObj, &quot;page 3&quot;, &quot;bar2.html&quot;);\n&#x2F;&#x2F; 注意点 history.replaceState, 会向url追加第三个参数，即使是相同的id,也会被追加。\n&#x2F;&#x2F; 例如：\n&#x2F;&#x2F; 初始 location.query 为 &#39;?time&#x3D;123456789&#39;\n&#x2F;&#x2F; history.replaceState(null, &quot;page 3&quot;, &quot;&amp;id&#x3D;1&quot;); &#x2F;&#x2F; 第一次调用\n\n&#x2F;&#x2F; location.query 为 &#39;?time&#x3D;123456789&amp;id&#x3D;1&#39;\n\n&#x2F;&#x2F; history.replaceState(null, &quot;page 3&quot;, &quot;&amp;id&#x3D;1&quot;); &#x2F;&#x2F; 第二次调用\n\n&#x2F;&#x2F; location.query 为 &#39;?time&#x3D;123456789&amp;id&#x3D;1&amp;id&#x3D;1&#39;\n\n&#x2F;&#x2F; history.replaceState(null, &quot;page 3&quot;, &quot;&amp;id&#x3D;1&quot;); &#x2F;&#x2F; 第三次调用\n\n&#x2F;&#x2F; location.query 为 &#39;?time&#x3D;123456789&amp;id&#x3D;1&amp;id&#x3D;1&amp;id&#x3D;1&#39;\n\nnextjs在 nextjs 中没有提供类似 react-router-dom 中 useSearchParams这样的勾子\nuseSearchParams\n假装我们不知道 replaceState如果要在 nextjs 中实现 useSearchParams 如何做呢？\n会想到参考 useSearchParams 的源码实现\n下载源码搜下实现useSearchParams\n\n -->\n -->\n\n&#x2F;&#x2F; packages&#x2F;react-router-dom&#x2F;index.tsx\n&#x2F;&#x2F; 调用 &#96;setSearchParams&#96; -&gt;  &#96;navigate&#96;-&gt;  &#96;let navigate &#x3D; useNavigate()&#96; -&gt; &#96;import &#123;  useNavigate&#125; from &quot;react-router&quot;;&#96;;\n\n到这里，要去找 react-router 包中的 useNavigate， 同一个代码仓库，不用切换项目\nuseNavigate同样方式，找到如下内容\n\n\n要去找下NavigationContext, React 的 context，我们了解到，是NavigationContext.Provider提供的数据\nNavigationContext.Provider同样方式，找到如下内容\n\n\n&#x2F;&#x2F; packages&#x2F;react-router&#x2F;lib&#x2F;components.tsx\n\n&#x2F;&#x2F; 这里要注意，这是一个组件，再找下去要找 &lt;Router了，由React-router-dom包暴露的组件，可知道暴露了几个组件：\n\nreact-router-dom 暴露的组件\n\nimport &#123; createBrowserHistory, createHashHistory &#125; from &quot;history&quot;; &#x2F;&#x2F; 这里 4\n&#x2F;&#x2F; ...\nexport function BrowserRouter(&#123;\n  basename,\n  children,\n  window,\n&#125;: BrowserRouterProps) &#123;\n  let historyRef &#x3D; React.useRef&lt;BrowserHistory&gt;();\n  if (historyRef.current &#x3D;&#x3D; null) &#123;\n    historyRef.current &#x3D; createBrowserHistory(&#123; window &#125;); &#x2F;&#x2F; 这里 3\n  &#125;\n\n  let history &#x3D; historyRef.current; &#x2F;&#x2F; 这里 2\n  let [state, setState] &#x3D; React.useState(&#123;\n    action: history.action,\n    location: history.location,\n  &#125;);\n\n  React.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);\n\n  return (\n    &lt;Router\n      basename&#x3D;&#123;basename&#125;\n      children&#x3D;&#123;children&#125;\n      location&#x3D;&#123;state.location&#125;\n      navigationType&#x3D;&#123;state.action&#125;\n      navigator&#x3D;&#123;history&#125; &#x2F;&#x2F; 这里 1\n    &#x2F;&gt;\n  );\n&#125;\n\n最终发现到了 history库中\ncreateBrowserHistory同样方式，找到如下内容\nexport function createBrowserHistory(&#123; window &#x3D; document.defaultView &#125; &#x3D; &#123;&#125;) &#123;\n  let globalHistory &#x3D; window.history; &#x2F;&#x2F; &#x2F;&#x2F; 这里 4\n  &#x2F;&#x2F; 获取第几个，和 location 信息\n  &#x2F;&#x2F; ...\n  function replace(to, state) &#123;\n    &#x2F;&#x2F; 这里 2\n    let nextAction &#x3D; ReplaceAction;\n    let nextLocation &#x3D; getNextLocation(to, state);\n    function retry() &#123;\n      replace(to, state);\n    &#125;\n\n    if (allowTx(nextAction, nextLocation, retry)) &#123;\n      let [historyState, url] &#x3D; getHistoryStateAndUrl(nextLocation, index);\n\n      &#x2F;&#x2F; TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url); &#x2F;&#x2F; 这里 3\n\n      applyTx(nextAction);\n    &#125;\n  &#125;\n\n  function go(n) &#123;\n    globalHistory.go(n);\n  &#125;\n\n  let history &#x3D; &#123;\n    get action() &#123;\n      return action;\n    &#125;,\n    get location() &#123;\n      return location;\n    &#125;,\n    createHref,\n    push,\n    replace, &#x2F;&#x2F; 这里 1\n    go,\n    back() &#123;\n      go(-1);\n    &#125;,\n    forward() &#123;\n      go(1);\n    &#125;,\n    listen(fn) &#123;\n      return listeners.push(fn);\n    &#125;,\n    block(fn) &#123;\n      let unblock &#x3D; blockers.push(fn);\n\n      if (blockers.length &#x3D;&#x3D;&#x3D; 1) &#123;\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      &#125;\n\n      return function () &#123;\n        unblock();\n\n        &#x2F;&#x2F; Remove the beforeunload listener so the document may\n        &#x2F;&#x2F; still be salvageable in the pagehide event.\n        &#x2F;&#x2F; See https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;#unloading-documents\n        if (!blockers.length) &#123;\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        &#125;\n      &#125;;\n    &#125;,\n  &#125;;\n\n  return history;\n&#125;\n\n最终发现调用的是  window.history.replaceState(historyState, null, url)\n假装我们刚知道Oh~,原来如此呀\n其他useNavigate\n这个 hook 内部获取了  let &#123; basename, navigator &#125; = React.useContext(NavigationContext);,\nNavigationContext.Provider是最外层提供的，所以，在其他地方使用 useNavigate 直接能拿到 navigator,不需要通过React.useContext(NavigationContext)的方式获取\n最后，实现 nextjs 中该勾子useSearchParams&#x2F;&#x2F; hooks&#x2F;useSearchParams.tsx\nimport &#123; useRouter &#125; from &quot;next&#x2F;router&quot;;\nimport React from &quot;react&quot;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;blob&#x2F;main&#x2F;packages&#x2F;react-router-dom&#x2F;index.tsx\n\nexport type ParamKeyValuePair &#x3D; [string, string];\nexport type URLSearchParamsInit &#x3D;\n  | string\n  | ParamKeyValuePair[]\n  | Record&lt;string, string | string[]&gt;\n  | URLSearchParams;\n\ntype SetURLSearchParams &#x3D; (\n  nextInit?:\n    | URLSearchParamsInit\n    | ((prev: URLSearchParams) &#x3D;&gt; URLSearchParamsInit),\n  navigateOpts?: NavigateOptions\n) &#x3D;&gt; void;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;blob&#x2F;d9d233c7fbb6f712915e8b0a7c916a69064bfdb9&#x2F;packages&#x2F;react-router&#x2F;lib&#x2F;context.ts#L92\nexport interface NavigateOptions &#123;\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n&#125;\n\nexport type RelativeRoutingType &#x3D; &quot;route&quot; | &quot;path&quot;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;blob&#x2F;main&#x2F;packages&#x2F;react-router-dom&#x2F;dom.ts\n&#x2F;**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to &#96;new URLSearchParams(init)&#96; except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don&#39;t want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams &#x3D; new URLSearchParams([\n *     [&#39;sort&#39;, &#39;name&#39;],\n *     [&#39;sort&#39;, &#39;price&#39;]\n *   ]);\n *\n * you can do:\n *\n *   let searchParams &#x3D; createSearchParams(&#123;\n *     sort: [&#39;name&#39;, &#39;price&#39;]\n *   &#125;);\n *&#x2F;\n\nexport function createSearchParams(\n  init: URLSearchParamsInit &#x3D; &quot;&quot;\n): URLSearchParams &#123;\n  return new URLSearchParams(\n    typeof init &#x3D;&#x3D;&#x3D; &quot;string&quot; ||\n    Array.isArray(init) ||\n    init instanceof URLSearchParams\n      ? init\n      : Object.keys(init).reduce((memo, key) &#x3D;&gt; &#123;\n          const value &#x3D; init[key];\n          return memo.concat(\n            Array.isArray(value) ? value.map((v) &#x3D;&gt; [key, v]) : [[key, value]]\n          );\n        &#125;, [] as ParamKeyValuePair[])\n  );\n&#125;\n\nexport function getSearchParamsForLocation(\n  locationSearch: string,\n  defaultSearchParams: URLSearchParams\n) &#123;\n  const searchParams &#x3D; createSearchParams(locationSearch);\n  &#x2F;&#x2F; @ts-ignore\n  for (const key of defaultSearchParams.keys()) &#123;\n    if (!searchParams.has(key)) &#123;\n      defaultSearchParams.getAll(key).forEach((value) &#x3D;&gt; &#123;\n        searchParams.append(key, value);\n      &#125;);\n    &#125;\n  &#125;\n\n  return searchParams;\n&#125;\n\nexport function useSearchParams(\n  defaultInit?: URLSearchParamsInit\n): [URLSearchParams, SetURLSearchParams] &#123;\n  const defaultSearchParamsRef &#x3D; React.useRef(createSearchParams(defaultInit));\n  const router &#x3D; useRouter();\n  let searchParams &#x3D;\n    typeof window &#x3D;&#x3D;&#x3D; &quot;undefined&quot;\n      ? defaultSearchParamsRef.current\n      : getSearchParamsForLocation(\n          &#x2F;&#x2F; 参数\n          window?.location?.search || &quot;&quot;,\n          defaultSearchParamsRef.current\n        );\n\n  const setSearchParams &#x3D; React.useCallback&lt;SetURLSearchParams&gt;(\n    (nextInit, navigateOptions) &#x3D;&gt; &#123;\n      const newSearchParams &#x3D; createSearchParams(\n        typeof nextInit &#x3D;&#x3D;&#x3D; &quot;function&quot; ? nextInit(searchParams) : nextInit\n      );\n      window.history.replaceState(null, &quot;&quot;, &#96;?$&#123;newSearchParams&#125;&#96;);\n    &#125;,\n    [searchParams]\n  );\n\n  return [searchParams, setSearchParams];\n&#125;\n\nDemo&#x2F;&#x2F; pages&#x2F;test&#x2F;replacestate.tsx\nimport React, &#123; useCallback, useEffect, useState &#125; from &quot;react&quot;;\nimport &#123; useSearchParams &#125; from &quot;..&#x2F;..&#x2F;hooks&#x2F;useSearchParams&quot;;\ninterface IProps &#123;&#125;\nconst TestReplaceState: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const [searchParams, setSearchParams] &#x3D; useSearchParams();\n\n  &#x2F;&#x2F; url数据放到state（数据恢复）\n  useEffect(() &#x3D;&gt; &#123;\n    setCount(Number(searchParams.get(&quot;id&quot;)));\n  &#125;, []);\n\n  &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;URLSearchParams\n  if (typeof window !&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n    const searchParams &#x3D; new URLSearchParams(location.href);\n    &#x2F;&#x2F; @ts-ignore\n    for (let p of searchParams) &#123;\n      console.log(p);\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 模拟查询表单提交\n  const handleSubmitQuery &#x3D; useCallback(() &#x3D;&gt; &#123;\n    const newValue &#x3D; count + 1;\n    &#x2F;&#x2F; 更新url数据，不刷新页面\n    setSearchParams(&#123; id: &#96;$&#123;newValue&#125;&#96; &#125;);\n    setCount(newValue);\n  &#125;, [count, setSearchParams]);\n\n  return (\n    &lt;div style&#x3D;&#123;&#123; padding: 50 &#125;&#125;&gt;\n      &lt;span\n        style&#x3D;&#123;&#123;\n          cursor: &quot;pointer&quot;,\n          background: &quot;#1980ff&quot;,\n          color: &quot;#fff&quot;,\n          padding: &quot;4px 6px&quot;,\n          borderRadius: 4,\n        &#125;&#125;\n        onClick&#x3D;&#123;handleSubmitQuery&#125;\n      &gt;\n        模拟查询表单提交数据 &#123;count&#125;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nexport default TestReplaceState;\n\n效果演示\n\n详情-&gt;列表, 在 nextjs 上有时候不能被检测到url 切换成功，但是 nextjs 有时候检测不到 偶现\n之后看下源码，到底是什么原因\nnextjs 提供了浅路由&#x2F;&#x2F; ....\n&#x2F;&#x2F; 需要有顺序的加载，否则 antd table pagination current当前页数存在问题，\n&#x2F;&#x2F; 原因是： pagination被封装到一个hook中，与table不在一个地方，table的，更新不及时\nuseEffect(() &#x3D;&gt; &#123;\n  if (router.pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;my&#x2F;list&quot;) &#123;\n    setShowCreator(false);\n    refShowCreator.current &#x3D; false;\n  &#125; else &#123;\n    setShowCreator(true);\n    refShowCreator.current &#x3D; true;\n  &#125;\n  const urlparam &#x3D; router.query;\n  form.setFieldsValue(&#123;\n    ...urlparam,\n    states: (urlparam.states || [])?.map((item) &#x3D;&gt; Number(item)),\n  &#125;);\n\n  fetchCurrentData(+urlparam.pageIndex, +urlparam.limit);\n  &#x2F;&#x2F; eslint-disable-next-line react-hooks&#x2F;exhaustive-deps\n&#125;, [router.query.activeTab, pageOption, router.pathname, form]);\n&#x2F;&#x2F; ....\n&#x2F;&#x2F; 更新 queryparams\nconst handleReplaceState &#x3D; (_params) &#x3D;&gt; &#123;\n  const urlparams &#x3D; qs.stringify(\n    filterEmptyVal(_params, &#123; cleanKeys: [], emptyString: true &#125;)\n  );\n  if (countref.current) &#123;\n    const _path &#x3D;\n      router.query.activeTab !&#x3D;&#x3D; undefined\n        ? &#96;$&#123;router.pathname&#125;?activeTab&#x3D;$&#123;router.query.activeTab&#125;&amp;$&#123;urlparams&#125;&#96;\n        : &#96;$&#123;router.pathname&#125;?$&#123;urlparams&#125;&#96;;\n    router?.push(_path, undefined, &#123; shallow: true &#125;);\n  &#125;\n  countref.current &#x3D; countref.current + 1;\n  return getProblems(_params);\n&#125;;\n","slug":"2022-10-14useSearchParams","date":"2022-10-14T08:57:11.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"e9f36f04acce2f8eb8772b8cbe654522","title":"React Cache","content":"暂时没空看，先记录react-router saveScrollPositionsaveScrollPosition\nreact-router-cache-routehttps://github.com/CJY0208/react-router-cache-route\nreact-activation&lt;KeepAlive /&gt; only\nhttps://github.com/CJY0208/react-activation\n","slug":"2022-10-14react-cache","date":"2022-10-14T08:42:18.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"2bccffee84b946de8f4dcf6a90a9884c","title":"好记性不如“实时笔记”","content":"背景看视频、音频，再发散一点如会议、需求对接、老师授课课堂笔记等，很多场景我们可能遇到做笔记啊。\n_上学时候_，做课堂笔记是一件耗费心神的事情，既想要把内容听进去，又想之后能够很快的复习。真的很难。\n_现在，累了半辈子，这辈子是不可能再“那么记了”_，\n程序员 !&#x3D; &quot;偷懒&quot;;\n程序员 &#x3D;&#x3D; &quot;高效率做事&quot;;\n\n需求\n需要实时笔记，这样我就能快速复习了\n不想手动记笔记，不想那么低效做事\n\n实现要在手机上&#x2F;电脑上，实现后台录音，之后把录音转化成文字，然后就可以整理笔记，把音频删除（节约存储空间）\n工具选取大前提最最要免费（我没钱）\n印象笔记\n\n收费，果断放弃\n体验不好。之前也有试过印象笔记记东西，感觉体验不好，有 Mac 用备忘录就比印象笔记方便太多\n\n其他工具\n其他的工具也了解了下，不能满足需要\n\n_飞书_：会议记录功能（飞书妙记）非常不错，\n\n最重要的事免费\n满足手机上后台录音功能\n可以实时录制，转化成文字笔记，\n转化后的文字点击，自动切换到音频位置，非常不错\n\n题外话：飞书妙记功能不止于此\n\n演示\n  \n  \n  \n\n\n总结\n“好记性不如烂笔头”已经过时，把烂笔头省下来也是件不错的事情吧；\n同时节约更多时间，即使聊聊天刷刷视频，也不会丢重点\n\n注意“飞书妙记”，也是机器，转译的过程中难免也会有误，“修改”总比“完全写”要来\n","slug":"2022-10-13record","date":"2022-10-13T03:25:25.000Z","categories_index":"工具","tags_index":"工具,增效","author_index":"举手摘月亮"},{"id":"a6739a5e648fed592221272a951b5783","title":"React 源码解析收录","content":"收录链接 1\nReact17 源码解析(开篇) —— 搭建 react 源码调试环境\nReact17 源码解析(1) —— 源码目录及 react 架构\nReact17 源码解析(2) —— jsx 转换及 React.createElement\nReact17 源码解析(3) —— 深入理解 fiber\nReact17 源码解析(4) —— 详解 render 阶段(scheduler 和 reconciler)\nReact17 源码解析(5) —— 全面理解 diff 算法\nReact17 源码解析(6) —— commit 阶段\nReact17 源码解析(7) —— 一文搞懂 hooks 原理\n🚀 万字好文 —— 手把手教你实现史上功能最丰富的简易版 react\n\n从上面了解到：\n\n几种数据类型之间的关系Fiber、 Effect、 Hook、 Update、 UpdateQueue\n“如何触发 React 调度更新”\n“diff 算法”的大概是什么\n“React Fiber 树如何被更新成 DOM 的”\n\n收录链接 2看完上面的文章，会有这个疑惑：\n我们的代码是如何进入 React 调度流程的（例如：写了一个组件，这个组件如何变成 workInProgressFiber 的一部分）\nReact17 源码解析(3) —— 深入理解 fiber仅有一行描述：“每个节点开始创建时，执行 beginWork 流程，直至该节点的所有子孙节点都创建(更新)完成后，执行 completeWork 流程”。 因跳过了太多的细节，即使最后给了下面这么一幅图，也看的云里雾里\n\n\n下面这两个链接详细阐述了整个过程\n\nReact Fiber 架构原理：关于 Fiber 树的一切\nFiber 树的构建\n\n爬取掘金专栏收录文章脚本\nvar data &#x3D; &quot;&quot;;\nconst list &#x3D; document.getElementsByClassName(&quot;title-row&quot;);\n\nArray.from(list)\n  &#x2F;&#x2F; .sort(() &#x3D;&gt; 1) &#x2F;*反向排序 *&#x2F;\n  .forEach((item) &#x3D;&gt; &#123;\n    const linkdom &#x3D; item.children[0];\n    const lk &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;linkdom.href&#125;&quot; target&#x3D;&quot;_blank&quot; &gt;$&#123;linkdom.title&#125;&lt;&#x2F;a&gt;\\n&#96;;\n    data +&#x3D; lk;\n  &#125;);\n\ncopy(data);\n\n\n\n收录链接 3\nreact-structure\nlilixikun\n\nupdateQueue 环形链表为什么使用环形链表：\n普通链表\n\n如果只保存首节点的指针，则每次插入时需要先进行一次遍历找到尾节点，再进行插入。\n要么就需要保存首尾节点的指针。\n环形链表\n\n而环形链表的尾节点的下一个节点就是首节点，因此只需要保存一个尾节点就可以做到既方便插入、又方便访问首节点\nUpdateQueue&lt;State&gt; &#x3D; &#123;\n  &#x2F;&#x2F; 这三个baseState是有更新被跳过时候才产生\n  baseState: State, &#x2F;&#x2F; baseState 指向被跳过的首个元素之前的所有 update 计算出的最终状态\n  firstBaseUpdate: Update&lt;State&gt;, &#x2F;&#x2F; firstBaseUpdate 指向被跳过的首个 update\n  lastBaseUpdate: Update&lt;State&gt;, &#x2F;&#x2F; lastBaseUpdate，只要有 update 被跳过，那么它一定指向本次更新的 update 中的最后一个\n\n  shared: SharedQueue&lt;State&gt;, &#x2F;&#x2F; 单环链表 真正存放 update 的链表的属性\n  effects: Array&lt;Update&lt;State&gt;&gt;,\n&#125;;\n\ntype SharedQueue&lt;State&gt; &#x3D; &#123;\n  pending: Update&lt;State&gt; | null;\n&#125;;\n\nfirstBaseUpdate 以及 lastBaseUpdate 形成的单链表let pendingQueue &#x3D; queue.shared.pending; &#x2F;&#x2F;  (取一个节点)\n\n&#x2F;&#x2F; 将 pending 设为空，表示这些 pending 已经处理过\nqueue.shared.pending &#x3D; null;\nconst lastPendingUpdate &#x3D; pendingQueue; &#x2F;&#x2F; pending 的最后一个 udpdate\nconst firstPendingUpdate &#x3D; lastPendingUpdate.next; &#x2F;&#x2F; pending 的第一个 update\n&#x2F;&#x2F; 剪开环，使最后一个 update 不再指向第一个 update\nlastPendingUpdate.next &#x3D; null;\nif (lastBaseUpdate &#x3D;&#x3D;&#x3D; null) &#123;\n  &#x2F;&#x2F;\n  firstBaseUpdate &#x3D; firstPendingUpdate;\n&#125; else &#123;\n  &#x2F;&#x2F; 如果上一次有跳过的 update，那么 baseUpdate 链表不为空\n  &#x2F;&#x2F; 需要将 pending 的第一个 update 接上 baseUpdate\n  lastBaseUpdate.next &#x3D; firstPendingUpdate;\n&#125;\n&#x2F;&#x2F; 将 lastBaseUpdate 赋值为 lastPendingUpdate\n&#x2F;&#x2F; 此时已经形成了 以 firstBaseUpdate 为头以 lastBaseUpdate 为尾的新链表\n&#x2F;&#x2F; 也即为本次需要处理的 update 链表\nlastBaseUpdate &#x3D; lastPendingUpdate;\n\nReact 总结图\n\n源码文件\n参考链接React Fiber - updateQueue 原理分析\nReact17 源码解析(4) —— 详解 render 阶段(scheduler 和 reconciler)见\n待学习源码react-source-study, 这老铁掘金文章写跑题了，蹭热度，不晓得，代码如何～，先收着\n","slug":"2022-10-10react-link","date":"2022-10-10T05:39:46.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"9635a6b254011f1f62378c1d84830a04","title":"Antd Tree drag","content":"属性解释dropToGap：boolean类型，true代表拖拽到节点之间的缝隙中，false代表拖拽到节点上，即节点的内容区。dropPosition：拖拽的时候，针对一个节点有三种情况，即拖拽到节点之上，拖拽到节点上，拖拽到节点之下。\n三种情况其值有所不同。antd 依赖了 rc-tree，\nrc-tree \n在 rc-tree 里 dropPosition 是一个相对地址。如果拖到了目标节点的上面则当前元素 -1，下面则是 1（* rc-tree这块不确定具体情况*）。\nantd\n antd里则是相对于目标节点的 index针对拖动情况计算出来。\n\n拖拽到节点之上(节点上边缘间隙位置)： 该节点的 index-1\n拖拽到节点上面(上边缘与下边缘之间的区域)：dropPosition 就是该节点的 index。\n拖拽到节点之下(节点下边缘间隙位置)：该节点的 index+1\n\n如下图所示：\n图解\n\n官方代码 onDrop &#x3D; info &#x3D;&gt; &#123;\n    console.log(info);\n    const dropKey &#x3D; info.node.props.eventKey;\n    const dragKey &#x3D; info.dragNode.props.eventKey;\n    const dropPos &#x3D; info.node.props.pos.split(&#39;-&#39;);\n   &#x2F;&#x2F; 这里计算的差值 上面分析了info.dropPosition的含义   dropPosition有3种情况 \n   &#x2F;&#x2F; &#x3D;0 表示拖拽到元素上\n  &#x2F;&#x2F; &#x3D;1 表示拖拽到元素下面   那么放置元素的时候  应该放到这个位置+1的位置上\n  &#x2F;&#x2F; &#x3D;-1 表示拖拽到元素上面   那么放置元素的时候 直接放到这个位置即可\n    const dropPosition &#x3D; info.dropPosition - Number(dropPos[dropPos.length - 1]);\n\n&#x2F;&#x2F; 递归查到元素所在树中的位置\n    const loop &#x3D; (data, key, callback) &#x3D;&gt; &#123;\n      data.forEach((item, index, arr) &#x3D;&gt; &#123;\n        if (item.key &#x3D;&#x3D;&#x3D; key) &#123;\n          &#x2F;&#x2F;在回调函数中将此元素，位置，以及元数组都返回\n          return callback(item, index, arr);\n        &#125;\n        if (item.children) &#123;\n          return loop(item.children, key, callback);\n        &#125;\n      &#125;);\n    &#125;;\n    &#x2F;&#x2F; 浅拷贝整个树 此处有疑问  不过不影响功能  因为怕操作data 我觉得应该深拷贝 \n    const data &#x3D; [...this.state.gData];\n\n    &#x2F;&#x2F; Find dragObject 查找获取到拖拽开始的元素对象\n    let dragObj;\n    loop(data, dragKey, (item, index, arr) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 查找到后删除此元素  这里相当于直接操作了data 所以我认为应该深拷贝\n      arr.splice(index, 1);\n      dragObj &#x3D; item;\n    &#125;);\n\n    if (!info.dropToGap) &#123;\n      &#x2F;&#x2F; Drop on the content  拖拽到内容上 \n      loop(data, dropKey, item &#x3D;&gt; &#123;\n        item.children &#x3D; item.children || [];\n        &#x2F;&#x2F; where to insert 示例添加到尾部，可以是随意位置\n        item.children.push(dragObj);\n      &#125;);\n    &#125;\n    &#x2F;&#x2F; 拖拽到元素之下的缝隙中，元素有子节点，并且当前元素子节点展开。此时元素放到了子节点的第一位。（当然可以根据具体情况随意位置） \n    else if (\n      (info.node.props.children || []).length &gt; 0 &amp;&amp; &#x2F;&#x2F; Has children\n      info.node.props.expanded &amp;&amp; &#x2F;&#x2F; Is expanded\n      dropPosition &#x3D;&#x3D;&#x3D; 1 &#x2F;&#x2F; On the bottom gap\n    ) &#123;\n      loop(data, dropKey, item &#x3D;&gt; &#123;\n        item.children &#x3D; item.children || [];\n        &#x2F;&#x2F; where to insert 示例添加到头部，可以是随意位置\n        item.children.unshift(dragObj);\n      &#125;);\n    &#125; else &#123;\n      let ar;\n      let i;\n      loop(data, dropKey, (item, index, arr) &#x3D;&gt; &#123;\n        ar &#x3D; arr;\n        i &#x3D; index;\n      &#125;);\n      if (dropPosition &#x3D;&#x3D;&#x3D; -1) &#123;\n        ar.splice(i, 0, dragObj);\n      &#125; else &#123;\n        ar.splice(i + 1, 0, dragObj);\n      &#125;\n    &#125;\n\n    this.setState(&#123;\n      gData: data,\n    &#125;);\n  &#125;;\n\n作者：黎明的叶子链接：https://www.jianshu.com/p/0e8bf11cd2dc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n参考链接ant-design拖动属性dropToGap,dropPosition\n","slug":"2022-10-10antd-tree-drag","date":"2022-10-10T01:19:14.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"853c3aaf44fd16a1c74c495f59970a3a","title":"tailwindcss","content":"https://github.com/tailwindlabs/tailwindcss\n\nCSS 发展第一个阶段，原生写法\n是类似于编程中面向过程的写法，需要什么样式，自己在 css 中写什么样式。对代码有洁癖的程序员会进行简单的 css 复用。但是也只是简单的复用，大多数时候还是需要什么写什么，想怎么写怎么写。\n第二个阶段，CSS 组件化。\n类似于编程中面向对象的写法，将相同视觉的 UI 封装成一个组件。比如一个按钮，整个项目中，这个按钮被多次使用，并且样式一致。那么就可以封装成一个按钮类。使用的时候直接使用这个类名称就 OK。\n这也是的做法。\n这种框架的优势在于，。比如你需要一个表单，，需要一个导航，需要一个弹窗，Card 卡片。有现成的 class。直接拿过来用，就可以快速的完成效果。完全不需要动手写 css。\n这也是目前比较流行的方法。这几年几乎很少有项目是自己一点一点手写样式的了，多多少少都会使用到一些 css 框架。\n对于一些需要快速交付的项目，非常适合使用这种组件化 css 框架。\n第三个阶段，CSS 零件化。\n也叫做。和上面第一个阶段第二个阶段都有类似的地方。依旧是组件，只是每个组件都是一个单一功能的 css 属性。\n上面第一个阶段的时候，我们讲了有些有对代码有追求的人，会开始复用 css。比如页面中大量的用到 float:left。那么就可以封装一个类，比如是这样\n.left &#123;\n  float: left;\n&#125;\n\n然后需要使用 float:left 的时候，直接使用.left 就可以。\n但是我们自己写 css 的时候，仅仅是封装一些常用的简单的类，绝大多数的 css，都需要动手去写 css。比如你要写个宽度 12 像素。你就得老老实实的去写 width:12px，逃避不了，不过估计也没人想过逃避。\nTailwind CSS 就是第三个阶段的产物，它做了什么呢？它将所有的 css 属性全部封装成语义化的类，比如你想要一个 float:left，它已经帮你封装好了，你直接使用一个 float-left 就可以。需要一个宽度为 12 像素，只需要写 w-3 就可以。\ntailwindcss 是什么像是 CSS 行内样式的另一种实现，有自己的语法，又和 CSS 有些关联【如 修饰符速查表、伪类速查表】\n实现了 CSS 行内样式不支持的一些 CSS 属性\ntailwindcss 工作原理是什么Tailwind CSS 的工作原理是扫描所有 HTML 文件、JavaScript 组件和任何其他模板以查找类名，生成相应的样式，然后将其写入静态 CSS 文件。\n它快速、灵活、可靠，运行时间为零。\ntailwindcss 解决了什么问题见\n见\ntailwindcss 好乱啊\n\n\n\n\n\n\n\n\n“this is an atrocity, what a horrible mess!”\n现在我知道你在想什么了，“这是一场暴行，多么可怕的混乱！”你说得对，它有点丑。事实上，当你第一次看到它时，几乎不可能认为这是一个好主意——你必须真正尝试一下。但一旦你真的以这种方式构建了一些东西，你会很快发现一些真正重要的好处：\n\n您没有为了给类命名而浪费精力。 不需要仅仅为了设置一些样式而额外添加一些像 sidebar-inner-wrapper 这样愚蠢的类名，不必再为了一个 flex 容器的完美抽象命名而倍受折磨。\n您的 CSS 停止增长。 使用传统方法，每次添加新功能时 CSS 文件都会变大。使用功能类，所有内容都是可重用的，因此您几乎不需要编写新的 CSS。\n更改会更安全。 CSS 是全局性的，您永远不知道当您进行更改时会破坏掉什么。您 HTML 中的类是本地的，因此您可以更改它们而不必担心其他问题。\n\ntailwindcss 打包后会不会太大见\nTailwind CSS 非常注重性能，旨在通过只生成项目中实际使用的 CSS 来生成尽可能小的 CSS 文件。\n再加上缩小和网络压缩，这通常会导致 CSS 文件小于 10kB，即使对于大型项目也是如此。例如，Netflix 将 Tailwind 用于 Netflix Top 10，而整个网站仅通过网络提供 6.5kB 的 CSS。\n有了这么小的 CSS 文件，您就不必担心复杂的解决方案，比如代码分割每个页面的 CSS，而只需发送一个小 CSS 文件即可下载并缓存，直到您重新部署站点。\n对于最小的生产版本，我们建议使用 cssnano 之类的工具缩小 CSS，并使用 Brotli 压缩 CSS。\ntailwindcss 看起来像是行内，为什么不用行内样式对这种方式的一个普遍反应是, “这不就是内联样式吗？” 在某些方面是 — 您是将样式直接应用于元素，而不是为元素分配一个类，然后在这个类中设置样式。\n但是使用功能类比内联样式具有一些重要的优点：\n\n基于约束的设计. 使用内联样式, 每个值都是一个魔术数字。 使用功能类, 您是从预定义的设计系统中选择样式，这使得构建统一的 UI 变得更加容易。\n响应式的设计. 在内联样式中您不能使用媒体查询, 但您可以使用 Tailwind 的响应式功能类非常容易的构建完全响应式的界面。\nHover, focus, 以及其它状态. 内联样式无法设置 hover 或者 focus 这样的状态, 但 Tailwind 的状态变体使用功能类可以非常容易的为这些状态设置样式。\n\n可维护性在使用功能优先的方式时，最大的可维护性问题是管理通用的可重复使用的功能类组合。\n通过提取组件（通常做为模板片断或者组件），可以轻松解决此问题。\n如果您想了解其他人使用此方法的经验，请查看以下资源：\n见\ntailwindcss 修饰速查表默认情况下，Tailwind 中包含的每个修改器的快速 参考表。\ntailwindcss 伪类速查表Pseudo-class reference\n额 主要使用 antd 库，tailwindcss 能混着用？可以混着用，而且还可能有问题 😓\n见\ntailwindcss 可能更适合业务不复杂，展示要求高的场景\n如果 B 端系统，不用 antd , 使用 tailwindcss 来开发，要自定义多少组件 😓\n\n官网之类偏展示性的到非常适合（移动优先）\n\n一些模版引擎需要借助一些插件，如 Django（django-tailwind）见\n\n设计软件支持 tailwindcss 语法的代码吗？\n\n\n注意点：Responsive Design\n这种方法最让人惊讶的地方是，要为移动设备设计样式，您需要使用未经修改的实用程序版本，而不是 sm:前缀版本。不要把 sm 看作是“在小屏幕上”的意思，而要把它看作“在小断点上”。见\n请注意，我们不必为 sm 断点或 xl 断点指定背景色-您只需要指定实用程序何时开始生效，而不是何时停止。见\n\n\nNote that if you’re using Sass&#x2F;SCSS, you’ll need to use Sass’ interpolation feature to get this to work:\n见\n\n\n在每个组件 CSS 中使用@apply 不生效，要用插件的形式，作者说了，你不要搞这些奇葩的操作 见\n见\n\n\n由于 Tailwind 使用嵌套对象语法来定义其默认调色板，因此请确保使用点符号来访问嵌套颜色。\n见\nUsing with Preprocessors\n见\n最佳实践Reusing Styles\n利用编辑器和语言的特点 见\n利用循环，进行组件复用 见\n提取组件和部分组件 见\n不要依赖 CSS 类来提取复杂组件，使用 js 来处理 见\n使用@apply 提取类 见\n避免过早抽象 见 无论你做什么，不要仅仅为了让事情看起来“干净”而使用@apply。是的，充斥着 Tailwind 类的 HTML 模板有点难看。在拥有大量定制 CSS 的项目中进行更改会更糟糕。\n如果您开始使用@apply 来处理所有事情，那么您基本上只是再次编写 CSS，并抛弃了 Tailwind 为您提供的所有工作流和可维护性优势，例如：\n\n你必须时时刻刻想出类名——没有什么比为不值得命名的东西想出类名更能让你慢下来或耗尽你的精力。\n您必须在多个文件之间跳转以进行更改-这是一个比您在将所有内容放在一起之前想象的更大的工作流杀手。\n改变样式更可怕——CSS 是全球性的，你确定你可以在不破坏网站其他部分的情况下改变该类的最小宽度值吗？\n你的 CSS 包会更大。\n\n如果您打算使用@apply，请将其用于非常小的、高度可重用的东西，如按钮和表单控件，没用组件框架时候，你可以这么搞，甚至只有在您没有使用像 React(组件才是更好的选择)这样的框架时。\n总之@apply 非常不建议用， 少用\n核心概念工具 -最基础伪类伪元素响应式设计Dark Mode复用样式增加自定义样式函数和指令看看视频巩固下有时间在继续学吧～，现在也用不到\n参考链接tailwindcss 中文文档， 内容不全\ntailwindcss\n见\nTailwind CSS v3——核心思想（三）自定义样式\n","slug":"2022-10-09tailwindcss","date":"2022-10-09T08:30:51.000Z","categories_index":"前端","tags_index":"前端","author_index":"举手摘月亮"},{"id":"caa824bced9b699073234ee0cec471c8","title":"Chrome Extension","content":"动机ModHeader，交互丑也就罢了，用Cookie还要收费,多大点事～ 还跟我要钱\n\n\nchrome extension官网chrome extension官网\n收集\n原生\nvite + vue3\nvite + react\ncreate-react-app 见\n\n原生的优点：是容易调试\n框架的优点：写pupup交互方便， chrome相关api不能像开发网页一样直接调用，需要打包出dist\n原生&#x2F;框架产物 \n\n\nchrome插件调试技巧chrome插件调试技巧\nmanifest.json见\n成为chrome商店开发者虽然，现在不是为了赚钱，可以后就说不定了～，先备着\nGoogle Chrome商店开发者认证支付$5【图解认证支付成功】\n如何支付：可以去淘宝搜搜～\n报错记录报错1Cannot find module ‘react&#x2F;jsx-runtime’ or its corresponding type declarations\nhttps://bobbyhadz.com/blog/react-cannot-find-module-react-jsx-runtime\n404For a Chrome Extension, you should be using a hash or memory history. You’ll run into problems otherwise.\nin Chrome Extension #4309 \ncookies\n\n\n\n\n\n\n半成品\n\n\n","slug":"2022-09-27chrome-extension","date":"2022-09-27T14:12:28.000Z","categories_index":"Chrome","tags_index":"Chrome","author_index":"举手摘月亮"},{"id":"6ed47af3bfb605ace618e0b5ed2afe7c","title":"React 页面传参数","content":"刷新不丢失更改浏览器url\n方案1: input type&#x3D;”search”\n方案2: 直接操作location.href \n方案3:\n\nstorage刷新丢失，不刷新保留contextredux","slug":"2022-09-26react-params","date":"2022-09-26T02:45:19.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"f3f72853c8b7c10482dbb43fb811bec2","title":"React TS 范型组件","content":"泛型类型TypeScript 中，类型（interface, type）是可以声明成泛型的，这很常见。\ninterface Props&lt;T&gt; &#123;\n  content: T;\n&#125;\n\n这表明 Props 接口定义了这么一种类型：\n它是包含一个 content 字段的对象, 该 content 字段的类型由使用时的泛型 T 决定\n使用时候 ts 自动推断\ntype StringProps &#x3D; Props&lt;string&gt;;\n\nlet props: StringProps;\n\nprops &#x3D; &#123;\n  &#x2F;&#x2F;   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322)\n  content: 42,\n&#125;;\n\nprops &#x3D; &#123;\n  &#x2F;&#x2F; ✅\n  content: &#39;hello&#39;,\n&#125;;\n\nTypeScript 能够跟使用时候提供的值自动推断出类型 T，无需显式指定：\ninterface Props&lt;T&gt; &#123;\n  content: T;\n&#125;\n\nfunction Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  console.log(props);\n&#125;\n\n&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;number&gt;(props: Props&lt;number&gt;): void *&#x2F;\nFoo(&#123; content: 42 &#125;);\n\n&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;string&gt;(props: Props&lt;string&gt;): void *&#x2F;\nFoo(&#123; content: &#39;hello&#39; &#125;);\n\n上面因为 Foo 函数接收 Props&lt;T&gt; 作为入参，意味着我们在调用 Foo 的时候需要传递类型 T 以确定 Props&lt;T&gt;，所以 Foo 函数也变成了泛型。\n当调用 Foo(&#123; content: 42 &#125;) 的时候，TypeScript 自动解析出 T 为 number，此时对应的函数签名为：\nfunction Foo&lt;number&gt;(props: Props&lt;number&gt;): void;\n\n而我们并没有显式地指定其中的类型 T，像这样 Foo&lt;number&gt;(&#123; content: 42 &#125;);。\n泛型组件将上面的 Foo 函数返回 JSX 元素，就成了一个 React 组件。因为它是泛型函数，它所形成的组件也就成了 泛型组件&#x2F;Generic Components。\nfunction Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  return &lt;div&gt; &#123;props.content&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;\n      &lt;Foo&lt;string&gt; &#x2F;**真的有点奇葩，理却是这个理 *&#x2F; content&#x3D;&#123;&#39;hello&#39;&#125;&gt;&lt;&#x2F;Foo&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n因为 TypeScript 可根据传入的实际值解析泛型类型，所以 &lt;Foo&lt;string&gt; content=&#123;&quot;hello&quot;&#125;&gt;&lt;/Foo&gt; 中 string 是可选的，这里只为展示，让你看到其实 React 组件还可以这么玩。\n为了进一步理解泛型组件，再看下非泛型情况下上面的组件是长怎样的。\ninterface Props &#123;\n  content: string;\n&#125;\n\nfunction Foo(props: Props) &#123;\n  return &lt;div&gt;&#123;props.content&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &#123;&#x2F;*   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322) *&#x2F;&#125;\n      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;\n      &lt;Foo content&#x3D;&#123;&#39;hello&#39;&#125;&gt;&lt;&#x2F;Foo&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n以上，便是一个 React 组件常规的写法。它定义的入参 Props 只接收 string 类型。由此也看出泛型的优势，即大部分代码可复用的情况下，将参数变成泛型后，不同类型的入参可复用同一组件，不用为新类型新写一个组件。\n除了函数组件，对于类类型的组件来说，也是一样可泛型化的。\ninterface Props&lt;T&gt; &#123;\n  content: T;\n&#125;\n\nclass Bar&lt;T&gt; extends React.Component&lt;Props&lt;T&gt;&gt; &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.content&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Bar content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Bar&gt;\n      &lt;Bar&lt;string&gt; content&#x3D;&#123;&#39;hello&#39;&#125;&gt;&lt;&#x2F;Bar&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n一个更加真实的示例一个更加实用的示例是列表组件。列表中的分页加载，滚动刷新逻辑等，对于所有列表数据都是通用的，将这个列表组件书写成泛型便可和任意类型列表数据结合，而无须通过其他方式来达到复用的目的，将列表元素声明成 any 或 Record&lt;string,any&gt; 等类型。\n先看不使用泛型情况下，如何实现这么一个列表组件。此处只看列表元素的展示以阐述泛型的作用，其他逻辑比如数据加载等先忽略。\n列表组件 List.tsx\ninterface Item &#123;\n  [prop: string]: any;\n&#125;\n\ninterface Props &#123;\n  list: Item[];\n  children: (item: Item, index: number) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List(&#123; list, children &#125;: Props) &#123;\n  &#x2F;&#x2F; 列表中其他逻辑...\n  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;\n&#125;\n\n上面，为了尽可能满足大部分数据类型，将列表的元素类型定义成了 [prop: string]: any; 的形式，其实和 Record&lt;string,any&gt; 没差。在这里已经可以看到类型的丢失了，因为出现了 any，而我们使用 TypeScript 的首要准则是尽量避免 any。\n然后是使用上面所定义的列表组件：\ninterface User &#123;\n  id: number;\n  name: string;\n&#125;\nconst data: User[] &#x3D; [\n  &#123;\n    id: 1,\n    name: &#39;wayou&#39;,\n  &#125;,\n  &#123;\n    id: 1,\n    name: &#39;niuwayong&#39;,\n  &#125;,\n];\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;List list&#x3D;&#123;data&#125;&gt;\n        &#123;(item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item.name&#96; 类型为 &#96;any&#96;\n          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n这里使用时，item.name 的类型已经成了 any。对于简单数据来说，还可以接收这样类型的丢失，但对于复杂类型，类型的丢失就完全享受不到 TypeScript 所带来的类型便利了。\n上面的实现还有个问题是它规定了列表元素必需是对象，理所应当地就不能处理元始类型数组了，比如无法渲染 [‘wayou’,’niuwayong’] 这样的输入。\n下面使用泛型改造上面的列表组件，让它支持外部传入类型。\ninterface Props&lt;T&gt; &#123;\n  list: T[];\n  children: (item: T, index: number) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List&lt;T&gt;(&#123; list, children &#125;: Props&lt;T&gt;) &#123;\n  &#x2F;&#x2F; 列表中其他逻辑...\n  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;\n&#125;\n\n改造后，列表元素的类型完全由使用的地方决定，作为列表组件，内部它无须关心，同时对于外部传递的 children 回调中 item 入参，类型也没有丢失。\n使用改造后的泛型列表：\ninterface User &#123;\n  id: number;\n  name: string;\n&#125;\nconst data: User[] &#x3D; [\n  &#123;\n    id: 1,\n    name: &#39;wayou&#39;,\n  &#125;,\n  &#123;\n    id: 1,\n    name: &#39;niuwayong&#39;,\n  &#125;,\n];\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;List list&#x3D;&#123;data&#125;&gt;\n        &#123;(item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;User&#96;\n          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n      &lt;List list&#x3D;&#123;[&#39;wayou&#39;, &#39;niuwayong&#39;]&#125;&gt;\n        &#123;(item) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;string&#96;\n          return &lt;div key&#x3D;&#123;item&#125;&gt;&#123;item&#125;&lt;&#x2F;div&gt;;\n        &#125;&#125;\n      &lt;&#x2F;List&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n范型组件的优势泛型的优势，即大部分代码可复用的情况下，将参数变成泛型后，不同类型的入参可复用同一组件，不用为新类型新写一个组件\nantd Table有人说：“表格那个真心体会到泛型组件”\n&#x2F;&#x2F; &#x2F;code&#x2F;源码&#x2F;ant-design&#x2F;components&#x2F;table&#x2F;Table.tsx\n...\nexport &#123; ColumnsType, TablePaginationConfig &#125;;\n...\n\nexport interface TableProps&lt;RecordType&gt;extends Omit&lt;\n    RcTableProps&lt;RecordType&gt;,\n    | &#39;transformColumns&#39;\n    | &#39;internalHooks&#39;\n    | &#39;internalRefs&#39;\n    | &#39;data&#39;\n    | &#39;columns&#39;\n    | &#39;scroll&#39;\n    | &#39;emptyText&#39;\n  &gt; &#123;\n  ...\n  columns?: ColumnsType&lt;RecordType&gt;;\n  ...\n  &#125;\n\nfunction Table&lt;RecordType extends object &#x3D; any&gt;(props: TableProps&lt;RecordType&gt;) &#123;\n  ...\n  const &#123;\n    ...\n    columns,\n    ...\n  &#125; &#x3D; props;\n  &#x2F;&#x2F; 转化后的，之后直接用于 RcTable\n  const mergedColumns &#x3D; React.useMemo(() &#x3D;&gt; &#123;\n    const matched &#x3D; new Set(Object.keys(screens).filter((m: Breakpoint) &#x3D;&gt; screens[m]));\n\n    return (columns || convertChildrenToColumns(children)).filter(\n      (c: ColumnType&lt;RecordType&gt;) &#x3D;&gt;\n        !c.responsive || c.responsive.some((r: Breakpoint) &#x3D;&gt; matched.has(r)),\n    );\n  &#125;, [children, columns, screens]);\n&#125;\n\nReact typescript 范型组件 chatGPT在 React 中使用 TypeScript，可以使用范型（Generics）来定义组件的类型，以适应不同的数据类型和数据结构。\n具体来说，如果需要定义一个可以接受任意数据类型的 props 的组件，可以使用范型来定义 props 的类型。例如：\nimport React from &#39;react&#39;;\n\ninterface Props&lt;T&gt; &#123;\n  data: T[];\n  renderItem: (item: T) &#x3D;&gt; React.ReactNode;\n&#125;\n\nfunction List&lt;T&gt;(props: Props&lt;T&gt;) &#123;\n  const &#123; data, renderItem &#125; &#x3D; props;\n\n  return (\n    &lt;ul&gt;\n      &#123;data.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;renderItem(item)&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;\n\n在上面的代码中，我们使用 Props&lt;T&gt; 来定义 props 的类型，其中 T 是范型参数，表示可以接受任意数据类型的数据。然后在组件中使用这个范型参数来定义 data 属性的类型，以及 renderItem 方法的参数类型和返回值类型。\n当使用这个组件时，需要传入一个具体的数据类型作为 T 的值，例如：\ninterface User &#123;\n  id: number;\n  name: string;\n  age: number;\n&#125;\n\nfunction App() &#123;\n  const users: User[] &#x3D; [\n    &#123; id: 1, name: &#39;Alice&#39;, age: 20 &#125;,\n    &#123; id: 2, name: &#39;Bob&#39;, age: 25 &#125;,\n    &#123; id: 3, name: &#39;Charlie&#39;, age: 30 &#125;,\n  ];\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User List&lt;&#x2F;h1&gt;\n      &lt;List&lt;User&gt;\n        data&#x3D;&#123;users&#125;\n        renderItem&#x3D;&#123;(user) &#x3D;&gt; (\n          &lt;div&gt;\n            &lt;p&gt;Name: &#123;user.name&#125;&lt;&#x2F;p&gt;\n            &lt;p&gt;Age: &#123;user.age&#125;&lt;&#x2F;p&gt;\n          &lt;&#x2F;div&gt;\n        )&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n在上面的代码中，我们传入一个类型为 User[] 的数组作为 data 属性的值，并定义一个渲染方法，用来渲染每个用户的信息。由于我们在组件中使用了范型参数 T，因此 TypeScript 可以根据传入的数据类型自动推导出 data 和 renderItem 的类型，从而确保类型安全。\n相关链接见\nReact——table 泛型\nReact 箭头函数组件使用泛型\n","slug":"2022-09-25react范型","date":"2022-09-25T11:24:31.000Z","categories_index":"React","tags_index":"React,chatGPT2021","author_index":"举手摘月亮"},{"id":"b3aebf06f866bf48f5b4df028fe75c8a","title":"python","content":"Python3 升级官网\nhttps://github.com/python/cpython\n\nhttps://github.com/golang/go\n\n$ python --version\nPython 2.7.15\n$ python3 --version\nPython 3.7.2\n$ brew upgrade python@3.10\n\n大概是 2019 年安装的 python 3.7.2 版本，看了下文档，有少数内容是需要 3.8 版本才可以使用，所以升级下\n&#x2F;&#x2F; 尝试的方案就不提了，最后是使用brew更新的，我印象中也是使用brew进行安装的 Python 3.7.2\n\n&#x2F;&#x2F;  1. brew升级问题\n$ brew update\nError:\n  homebrew-core is a shallow clone.\n  homebrew-cask is a shallow clone.\nTo &#96;brew update&#96;, first run:\n&#x2F;&#x2F; 提示更新 homebrew-core 、 homebrew-cask\n  git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core fetch --unshallow\n  git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask fetch --unshallow\nThese commands may take a few minutes to run due to the large size of the repositories.\nThis restriction has been made on GitHub&#39;s request because updating shallow\nclones is an extremely expensive operation due to the tree layout and traffic of\nHomebrew&#x2F;homebrew-core and Homebrew&#x2F;homebrew-cask. We don&#39;t do this for you\nautomatically to avoid repeatedly performing an expensive unshallow operation in\nCI systems (which should instead be fixed to not use shallow clones). Sorry for\nthe inconvenience!\n\n$  git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core fetch --unshallow\nremote: Enumerating objects: 554589, done.\nremote: Counting objects: 100% (554579&#x2F;554579), done.\nremote: Compressing objects: 100% (203589&#x2F;203589), done.\nremote: Total 545216 (delta 349940), reused 533974 (delta 338772), pack-reused 0\nReceiving objects: 100% (545216&#x2F;545216), 185.96 MiB | 3.35 MiB&#x2F;s, done.\nResolving deltas: 100% (349940&#x2F;349940), completed with 7224 local objects.\nFrom https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core\n   ec1cfdae42e..44f9ecb1cc9  master     -&gt; origin&#x2F;master\n\n$ git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask fetch --unshallow\n\nremote: Enumerating objects: 183139, done.\nremote: Counting objects: 100% (170633&#x2F;170633), done.\nremote: Compressing objects: 100% (52991&#x2F;52991), done.\nremote: Total 157830 (delta 118189), reused 144193 (delta 104700), pack-reused 0\nReceiving objects: 100% (157830&#x2F;157830), 74.85 MiB | 3.34 MiB&#x2F;s, done.\nResolving deltas: 100% (118189&#x2F;118189), completed with 6886 local objects.\nFrom https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-cask\n   372fbf30e9..91f5fb626d  master     -&gt; origin&#x2F;master\n\n&#x2F;&#x2F; python3.10安装\n\n$ brew upgrade python@3.10\n\nRunning &#96;brew update --preinstall&#96;...\n\n&#x3D;&#x3D;&gt; Upgrading 1 outdated package:\npython@3.10 3.10.2 -&gt; 3.10.6_2\nError: python@3.10: the bottle needs the Apple Command Line Tools to be installed.\n  You can install them, if desired, with:\n    xcode-select --install\nYou can try to install from source with:\n  brew install --build-from-source python@3.10\nPlease note building from source is unsupported. You will encounter build\nfailures with some formulae. If you experience any issues please create pull\nrequests instead of asking for help on Homebrew&#39;s GitHub, Twitter or any other\nofficial channels.\n\n&#x2F;&#x2F; 失败提示\n\n$ xcode-select --install\nxcode-select: note: install requested for command line developer tools\n\n&#x2F;&#x2F; 从source安装\n$  brew install --build-from-source python@3.10\n...\n\n&#x2F;&#x2F; 安装 98.4% 失败\n######################################################################    98.4%curl: (56) LibreSSL SSL_read: error:02FFF03C:system library:func(4095):Operation timed out, errno 60\n\nError: python@3.10: Failed to download resource &quot;python@3.10&quot;\nDownload failed: https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.10.6&#x2F;Python-3.10.6.tgz\n\n&#x2F;&#x2F; 重新执行命令再次安装\n\n$  brew install --build-from-source python@3.10\nRunning &#96;brew update --auto-update&#96;...\npython@3.10 3.7.2_2 is already installed but outdated (so it will be upgraded).\n\n\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.10.6&#x2F;Python-3.10.6.tgz\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Upgrading python@3.10\n  3.10.2 -&gt; 3.10.6_2\n\n\n\n&#x2F;&#x2F; 整个过程很长，还需要vpn加持\n\nLast login: Sat Sep 24 17:31:07 on ttys008\n $ python3 --version\nPython 3.10.6\n $ python\nzsh: command not found: python &#x2F;&#x2F; 是真的狗啊\n $\n\n&#x2F;&#x2F; 发现又在下载了，我确认了下安装日志，之前是有2.7.15的\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;2.7.15&#x2F;Python-2.7.15.tar.xz\n######                                                                     8.6%\n\n\n\n$ brew install --build-from-source python@2.7.15\nWarning: No available formula with the name &quot;python@2.7.15&quot;. Did you mean python@3.7?\n&#x3D;&#x3D;&gt; Searching for similarly named formulae...\nThis similarly named formula was found:\npython@3.7\nTo install it, run:\n  brew install python@3.7\n&#x3D;&#x3D;&gt; Searching for a previously deleted formula (in the last month)...\nError: No previously deleted formula found.\n&#x3D;&#x3D;&gt; Searching taps on GitHub...\nError: No formulae found in taps.\n$ brew install --build-from-source python@2.7\nWarning: No available formula with the name &quot;python@2.7&quot;. Did you mean python@3.7, python@3.9, python@3.8, python@3.10 or python-yq?\n&#x3D;&#x3D;&gt; Searching for similarly named formulae...\nThese similarly named formulae were found:\npython@3.7                   python@3.9                   python@3.8                   python@3.10 ✔                python-yq\nTo install one of them, run (for example):\n  brew install python@3.7\n&#x3D;&#x3D;&gt; Searching for a previously deleted formula (in the last month)...\nError: No previously deleted formula found.\n&#x3D;&#x3D;&gt; Searching taps on GitHub...\nError: No formulae found in taps.\n$ brew link --overwrite python@2\n\nLinking &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15... 33 symlinks created.\n$ brew link --overwrite python@2\nWarning: Already linked: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15\nTo relink, run:\n  brew unlink python@2 &amp;&amp; brew link python@2\n\n&#x2F;&#x2F; unlink、link\n$ brew unlink python@2 &amp;&amp; brew link python@2\nUnlinking &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15... 33 symlinks removed.\nLinking &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15... 33 symlinks created.\n\n&#x2F;&#x2F; 终于好了\n$ python --version\nPython 2.7.15\n$ python3 --version\nPython 3.10.6\n$\n\n\npython 官网对于 python 官网，我特意和 java、go、rust、nodejs 做了下比较，虽然 python 的官网也显得老旧，我甚至一度怀疑我看的是不是 python 文档。没 go 官网看的那么舒服。可毕竟人家是编程语言排名第一。嗯～，就这一点，都可以忍。学～\n见 python\n见 runoob\n\n\n\n\n\n\nTIP\n对于菜鸟教程上的例子，可以选择更改页面样式img &#123;display: none&#125;来查看，gif 文件跳来跳去，看的眼花，而且每个图占据那么大的空间，文章结构感被破坏了\n\npython web 框架选择去 boss 搜了下，主要是 django 和 Flask\nDjango vs Flask: 到底应该选哪个?\n我选了 django ,原因\n\ndjango star 多一点\nDjango vs Flask: 到底应该选哪个? 让我觉得，django 更稳\nDjango 官网比 Flask 看着舒服\n\n见 pythondjangoDjango 的由来及名字如何发音如何读Django 由来\n我的感受在感受了 python， django 和 Flask。 我觉得，这比 java 简单多了，和 js 比较，python api 也更多，虽然，一开始有点抵触语法，习惯就好～\njava 这玩意，生态再好，我都不想下手（虽然之前也有学过 😓，迷途小书童）\npipLast login: Sat Sep 24 18:45:11 on ttys009$ pip install Django&#x3D;&#x3D;4.1.1zsh: command not found: pip$ brew install pipRunning brew update --auto-update…&#x3D;&#x3D;&gt; Auto-updated Homebrew!Updated 1 tap (homebrew&#x2F;core).\nYou have 22 outdated formulae installed.You can upgrade them with brew upgradeor list them with brew outdated.\nWarning: No available formula with the name “pip”. Did you mean pipx, pig, pit, php, pcp, pup, zip, sip or vip?&#x3D;&#x3D;&gt; Searching for similarly named formulae…These similarly named formulae were found:aespipe libpipeline pipe-rename pipes-sh pyenv-pip-migrate pit zipbrew-pip pip-audit pipebench pipeviewer spiped php sipgrepip pip-completion pipemeter pipgrip xpipe pcp viplesspipe pip-tools pipenv pipx pig pupTo install one of them, run (for example):brew install aespipepip is part of the python formula:brew install python\n安装 Django$ python3 -m pip install Django\nCollecting Django\n  Downloading Django-4.1.1-python-none-any.whl (8.1 MB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 8.1&#x2F;8.1 MB 2.0 MB&#x2F;s eta 0:00:00\nCollecting sqlparse&gt;&#x3D;0.2.2\n  Downloading sqlparse-0.4.3-python-none-any.whl (42 kB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 42.8&#x2F;42.8 kB 238.6 kB&#x2F;s eta 0:00:00\nCollecting asgiref&lt;4,&gt;&#x3D;3.5.2\n  Downloading asgiref-3.5.2-python-none-any.whl (22 kB)\nInstalling collected packages: sqlparse, asgiref, Django\nSuccessfully installed Django-4.1.1 asgiref-3.5.2 sqlparse-0.4.3\n\nrunoob\n事例Django ORMModels\n正反向区别\n一对一、一对多、多对多区别\n单划线、双划线区别\n\nclass Book(models.Model):\n    title &#x3D; models.CharField(max_length&#x3D;32)\n    price &#x3D; models.DecimalField(max_digits&#x3D;5, decimal_places&#x3D;2)\n    pub_date &#x3D; models.DateField()\n    # 暂且理解 关联\n    publish &#x3D; models.ForeignKey(&quot;Publish&quot;, on_delete&#x3D;models.CASCADE)\n    # 多对多，\n    # 从Book往Author看，为正向，\n    # 从Author往Book看，为反向\n    authors &#x3D; models.ManyToManyField(&quot;Author&quot;)\n\n\nclass Publish(models.Model):\n    name &#x3D; models.CharField(max_length&#x3D;32)\n    city &#x3D; models.CharField(max_length&#x3D;64)\n    email &#x3D; models.EmailField()\n\n\nclass Author(models.Model):\n    name &#x3D; models.CharField(max_length&#x3D;32)\n    age &#x3D; models.SmallIntegerField()\n    # 一对一\n    au_detail &#x3D; models.OneToOneField(&quot;AuthorDetail&quot;, on_delete&#x3D;models.CASCADE)\n\n\nclass AuthorDetail(models.Model):\n    gender_choices &#x3D; (\n        (0, &quot;女&quot;),\n        (1, &quot;男&quot;),\n        (2, &quot;保密&quot;),\n    )\n    gender &#x3D; models.SmallIntegerField(choices&#x3D;gender_choices)\n    tel &#x3D; models.CharField(max_length&#x3D;32)\n    addr &#x3D; models.CharField(max_length&#x3D;64)\n    birthday &#x3D; models.DateField()\n\n说明：\n1、EmailField 数据类型是邮箱格式，底层继承 CharField，进行了封装，相当于 MySQL 中的 varchar。\n2、Django1.1 版本不需要联级删除：on_delete&#x3D;models.CASCADE，Django2.2 需要。\n3、一般不需要设置联级更新.\n4、外键在一对多的多中设置：models.ForeignKey(“关联类名”, on_delete&#x3D;models.CASCADE)。\n5、OneToOneField &#x3D; ForeignKey(…，unique&#x3D;True)设置一对一。\n6、若有模型类存在外键，创建数据时，要先创建外键关联的模型类的数据，不然创建包含外键的模型类的数据时，外键的关联模型类的数据会找不到。\n表结构书籍表 Book：title 、 price 、 pub_date 、 publish（外键，多对一） 、 authors（多对多）\n出版社表 Publish：name 、 city 、 email\n作者表 Author：name 、 age 、 au_detail（一对一）\n作者详情表 AuthorDetail：gender 、 tel 、 addr 、 birthday\n表关系\n\n插入数据INSERT INTO app01_publish ( name, city, email )\nVALUES\n ( &quot;华山出版社&quot;, &quot;华山&quot;, &quot;hs@163.com&quot; ),\n ( &quot;明教出版社&quot;, &quot;黑木崖&quot;, &quot;mj@163.com&quot; )\n\n# 先插入 authordetail 表中多数据\nINSERT INTO app01_authordetail ( gender, tel, addr, birthday )\nVALUES\n ( 1, 13432335433, &quot;华山&quot;, &quot;1994-5-23&quot; ),\n ( 1, 13943454554, &quot;黑木崖&quot;, &quot;1961-8-13&quot; ),\n ( 0, 13878934322, &quot;黑木崖&quot;, &quot;1996-5-20&quot; )\n\n# 再将数据插入 author，这样 author 才能找到 authordetail\nINSERT INTO app01_author ( name, age, au_detail_id )\nVALUES\n ( &quot;令狐冲&quot;, 25, 1 ),\n ( &quot;任我行&quot;, 58, 2 ),\n ( &quot;任盈盈&quot;, 23, 3 )\n\n在 MySQL 中执行以下 SQL 插入操作：\nORM - 添加数据一对多(外键 ForeignKey)方式一: 传对象的形式，返回值的数据类型是对象，书籍对象。\n步骤：\na. 获取出版社对象b. 给书籍的出版社属性 pulish 传出版社对象\n# app01&#x2F;views.py 文件代码：\ndef add_book(request):\n    #  获取出版社对象\n    pub_obj &#x3D; models.Publish.objects.filter(pk&#x3D;1).first() # pk 缩写 primary key\n    #  给书籍的出版社属性publish传出版社对象\n    book &#x3D; models.Book.objects.create(title&#x3D;&quot;菜鸟教程&quot;, price&#x3D;200, pub_date&#x3D;&quot;2010-10-10&quot;, publish&#x3D;pub_obj)\n    print(book, type(book))\n    return HttpResponse(book)\n\n方式二: 传对象 ID 的形式（传对象 id 常用）\n一对多中，设置外键属性的类(多的表)中，MySQL 中显示的字段名是:外键属性名_id。\n返回值的数据类型是对象，书籍对象。\n步骤：\na. 获取出版社对象的 idb. 给书籍的关联出版社字段 pulish_id 传出版社对象的 id\n# app01&#x2F;views.py 文件代码：\ndef add_book(request):\n    #  获取出版社对象\n    pub_obj &#x3D; models.Publish.objects.filter(pk&#x3D;1).first()\n    #  获取出版社对象的id\n    pk &#x3D; pub_obj.pk\n    #  给书籍的关联出版社字段 publish_id 传出版社对象的id\n    book &#x3D; models.Book.objects.create(title&#x3D;&quot;冲灵剑法&quot;, price&#x3D;100, pub_date&#x3D;&quot;2004-04-04&quot;, publish_id&#x3D;pk)\n    print(book, type(book))\n    return HttpResponse(book)\n\n多对多(ManyToManyField)：在第三张关系表中新增数据方式一: 传对象形式，无返回值。\n步骤：\na. 获取作者对象b. 获取书籍对象c. 给书籍对象的 authors 属性用 add 方法传作者对象\n# app01&#x2F;views.py 文件代码：\ndef add_book(request):\n    #  获取作者对象\n    chong &#x3D; models.Author.objects.filter(name&#x3D;&quot;令狐冲&quot;).first()\n    ying &#x3D; models.Author.objects.filter(name&#x3D;&quot;任盈盈&quot;).first()\n    #  获取书籍对象\n    book &#x3D; models.Book.objects.filter(title&#x3D;&quot;菜鸟教程&quot;).first()\n    #  给书籍对象的 authors 属性用 add 方法传作者对象\n    book.authors.add(chong, ying)\n    return HttpResponse(book)\n\n方式二: 传对象 id 形式，无返回值。\n步骤：\na. 获取作者对象的 idb. 获取书籍对象c. 给书籍对象的 authors 属性用 add 方法传作者对象的 id\n# app01&#x2F;views.py 文件代码：\ndef add_book(request):\n    #  获取作者对象\n    chong &#x3D; models.Author.objects.filter(name&#x3D;&quot;令狐冲&quot;).first()\n    #  获取作者对象的id\n    pk &#x3D; chong.pk\n    #  获取书籍对象\n    book &#x3D; models.Book.objects.filter(title&#x3D;&quot;冲灵剑法&quot;).first()\n    #  给书籍对象的 authors 属性用 add 方法传作者对象的id\n    book.authors.add(pk) # 这个不能理解了，authors这个字段接受了pk\n\n关联管理器(对象调用)前提：\n多对多（双向均有关联管理器）一对多（只有多的那个类的对象有关联管理器，即反向才有）语法格式：\n正向：属性名反向：小写类名加 _set\n注意：一对多只能反向\n常用方法：\nadd()：用于多对多，把指定的模型对象添加到关联对象集（关系表）中。\n注意：add() 在一对多(即外键)中，只能传对象（ QuerySet 数据类型），不能传 id（[id 表]）。\n*[ ] 的使用:\n方式一：传对象book_obj &#x3D; models.Book.objects.get(id&#x3D;10)\nauthor_list &#x3D; models.Author.objects.filter(id__gt&#x3D;2)\nbook_obj.authors.add(*author_list)  # 将 id 大于2的作者对象添加到这本书的作者集合中\n\n方式二：传对象 idbook_obj.authors.add(*[1,3]) # 将 id&#x3D;1 和 id&#x3D;3 的作者对象添加到这本书的作者集合中\nreturn HttpResponse(&quot;ok&quot;)\n\n反向：小写表名_set\nying &#x3D; models.Author.objects.filter(name&#x3D;&quot;任盈盈&quot;).first()\nbook &#x3D; models.Book.objects.filter(title&#x3D;&quot;冲灵剑法&quot;).first()\nying.book_set.add(book)\nreturn HttpResponse(&quot;ok&quot;)\n\ncreate()：创建一个新的对象，并同时将它添加到关联对象集之中。\n返回新创建的对象。\npub &#x3D; models.Publish.objects.filter(name&#x3D;&quot;明教出版社&quot;).first()\nwo &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).first()\nbook &#x3D; wo.book_set.create(title&#x3D;&quot;吸星大法&quot;, price&#x3D;300, pub_date&#x3D;&quot;1999-9-19&quot;, publish&#x3D;pub)\nprint(book, type(book))\nreturn HttpResponse(&quot;ok&quot;)\n\nremove()：从关联对象集中移除执行的模型对象。\n对于 ForeignKey 对象，这个方法仅在 null&#x3D;True（可以为空）时存在，无返回值。\n实例\nauthor_obj &#x3D;models.Author.objects.get(id&#x3D;1)\nbook_obj &#x3D; models.Book.objects.get(id&#x3D;11)\nauthor_obj.book_set.remove(book_obj)\nreturn HttpResponse(&quot;ok&quot;)\n\nclear()：从关联对象集中移除一切对象，删除关联，不会删除对象。\n对于 ForeignKey 对象，这个方法仅在 null&#x3D;True（可以为空）时存在。\n无返回值。\n# 清空独孤九剑关联的所有作者\nbook &#x3D; models.Book.objects.filter(title&#x3D;&quot;菜鸟教程&quot;).first()\nbook.authors.clear()\n\nORM 查询 _set 语法基于对象的跨表查询。\n正向：属性名称反向：小写类名_set\n一对多正向查询主键为 1 的书籍的出版社所在的城市（正向）。\n实例\nbook &#x3D; models.Book.objects.filter(pk&#x3D;1).first()\nres &#x3D; book.publish.city\nprint(res, type(res))\nreturn HttpResponse(&quot;ok&quot;)\n\n反向查询明教出版社出版的书籍名（反向）。\n反向：对象.小写类名_set(pub.book_set) 可以跳转到关联的表(书籍表)。\npub.book_set.all()：取出书籍表的所有书籍对象，在一个 QuerySet 里，遍历取出一个个书籍对象。\n实例\npub &#x3D; models.Publish.objects.filter(name&#x3D;&quot;明教出版社&quot;).first()\nres &#x3D; pub.book_set.all()\nfor i in res:\n    print(i.title)\nreturn HttpResponse(&quot;ok&quot;)\n\n\n一对一查询令狐冲的电话（正向）\n正向正向：对象.属性 (author.au_detail) 可以跳转到关联的表(作者详情表)\n实例\nauthor &#x3D; models.Author.objects.filter(name&#x3D;&quot;令狐冲&quot;).first()\nres &#x3D; author.au_detail.tel\nprint(res, type(res))\nreturn HttpResponse(&quot;ok&quot;)\n\n反向查询所有住址在黑木崖的作者的姓名（反向）。\n一对一的反向，用 对象.小写类名 即可，不用加 _set。（这个比较特别）\n反向：对象.小写类名(addr.author)可以跳转到关联的表(作者表)。\n实例\naddr &#x3D; models.AuthorDetail.objects.filter(addr&#x3D;&quot;黑木崖&quot;).first()\nres &#x3D; addr.author.name\nprint(res, type(res))\nreturn HttpResponse(&quot;ok&quot;)\n\n多对多菜鸟教程所有作者的名字以及手机号（正向）。\n正向正向：对象.属性(book.authors)可以跳转到关联的表(作者表)。\n作者表里没有作者电话，因此再次通过对象.属性(i.au_detail)跳转到关联的表（作者详情表）。\n实例\nbook &#x3D; models.Book.objects.filter(title&#x3D;&quot;菜鸟教程&quot;).first()\nres &#x3D; book.authors.all()\nfor i in res:\n    print(i.name, i.au_detail.tel) # au_detail 为author类的一个字段\nreturn HttpResponse(&quot;ok&quot;)\n\n反向查询任我行出过的所有书籍的名字（反向）。\n实例\nauthor &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).first()\nres &#x3D; author.book_set.all()\nfor i in res:\n    print(i.title)\nreturn HttpResponse(&quot;ok&quot;)\n\nORM 查询 基于双下划线的跨表查询 语法正向：属性名称跨表的属性名称反向：小写类名跨表的属性名称（有个问题，如果类名和属性名一样，呃呃呃～～～？）\n一对多查询菜鸟出版社出版过的所有书籍的名字与价格。\n正向res &#x3D; models.Book.objects.filter(publish__name&#x3D;&quot;菜鸟出版社&quot;).values_list(&quot;title&quot;, &quot;price&quot;)\n\n反向反向：通过 小写类名跨表的属性名称（booktitle，book__price） 跨表获取数据。\nres &#x3D; models.Publish.objects.filter(name&#x3D;&quot;菜鸟出版社&quot;).\n# Book 中有publish，从Publish 找Book为反向查找\nvalues_list(&quot;book__title&quot;,&quot;book__price&quot;) # 模型与表：只要存在模型关系，就可以获取相关表中数据\nreturn HttpResponse(&quot;ok&quot;)\n\n多对多查询任我行出过的所有书籍的名字。\n正向正向：通过 属性名称跨表的属性名称(authorsname) 跨表获取数据：\nres &#x3D; models.Book.objects.filter(authors__name&#x3D;&quot;任我行&quot;).values_list(&quot;title&quot;)\n\n反向反向：通过 小写类名跨表的属性名称（booktitle） 跨表获取数据：\nres &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).values_list(&quot;book__title&quot;)\n\n一对一查询任我行的手机号。\n正向正向：通过 属性名称跨表的属性名称(au_detailtel) 跨表获取数据。（Author 中 au_detail 字段）\nres &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).values_list(&quot;au_detail__tel&quot;)\n\n反向反向：通过 小写类名跨表的属性名称（authorname） 跨表获取数据。\nres &#x3D; models.AuthorDetail.objects.filter(author__name&#x3D;&quot;任我行&quot;).values_list(&quot;tel&quot;)\n\nORM – 多表实例（聚合与分组查询）聚合查询（aggregate）聚合查询函数是对一组值执行计算，并返回单个值。\nDjango 使用聚合查询前要先从 django.db.models 引入 Avg、Max、Min、Count、Sum（首字母大写）。\nfrom django.db.models import Avg,Max,Min,Count,Sum  #   引入函数\n\n\n\n\n\n\n\nTIP\n\n聚合查询返回值的数据类型是字典。\n\n聚合函数 aggregate() 是 QuerySet 的一个终止子句， 生成的一个汇总值，相当于 count()。\n\n使用 aggregate() 后，数据类型就变为字典，不能再使用 QuerySet 数据类型的一些 API 了。\n\n日期数据类型(DateField)可以用 Max 和 Min。\n\n返回的字典中：键的名称默认是（属性名称加上__聚合函数名），值是计算出来的聚合值。\n\n如果要自定义返回字典的键的名称，可以起别名：\n\naggregate(别名 &#x3D; 聚合函数名(“属性名称”))\n\n\n\n计算所有图书的平均价格:\n实例\nfrom django.db.models import Avg,Max,Min,Count,Sum  #   引入函数\n...\nres &#x3D; models.Book.objects.aggregate(Avg(&quot;price&quot;))\nprint(res, type(res))\n...\n\n计算所有图书的数量、最贵价格和最便宜价格:\n实例\nres&#x3D;models.Book.objects.aggregate(c&#x3D;Count(&quot;id&quot;),max&#x3D;Max(&quot;price&quot;),min&#x3D;Min(&quot;price&quot;))\nprint(res,type(res)\n\n\n分组查询（annotate）分组查询一般会用到聚合函数，所以使用前要先从 django.db.models 引入 Avg,Max,Min,Count,Sum（首字母大写）。\nfrom django.db.models import Avg,Max,Min,Count,Sum # 引入函数\n返回值：\n分组后，用 values 取值，则返回值是 QuerySet 数据类型里面为一个个字典；分组后，用 values_list 取值，则返回值是 QuerySet 数据类型里面为一个个元组。MySQL 中的 limit 相当于 ORM 中的 QuerySet 数据类型的切片。\n注意：\nannotate 里面放聚合函数。\nvalues 或者 values_list 放在 annotate 前面：values 或者 values_list 是声明以什么字段分组，annotate 执行分组。\nvalues 或者 values_list 放在 annotate 后面： annotate 表示直接以当前表的 pk 执行分组，values 或者 values_list 表示查询哪些字段， 并且要将 annotate 里的聚合函数起别名，在 values 或者 values_list 里写其别名。\n准备数据和创建模型\n# models.py\nclass Emp(models.Model):\n    name &#x3D; models.CharField(max_length&#x3D;32)\n    age &#x3D; models.IntegerField()\n    # 外键\n    salary &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)\n    dep &#x3D; models.CharField(max_length&#x3D;32)\n    province &#x3D; models.CharField(max_length&#x3D;32)\n\nclass Emps(models.Model):\n    name &#x3D; models.CharField(max_length&#x3D;32)\n    age &#x3D; models.IntegerField()\n    salary &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)\n    # 外键\n    dep &#x3D; models.ForeignKey(&quot;Dep&quot;, on_delete&#x3D;models.CASCADE)\n    province &#x3D; models.CharField(max_length&#x3D;32)\n\nclass Dep(models.Model):\n    title &#x3D; models.CharField(max_length&#x3D;32)\n\n数据:\n在 MySQL 命令行中执行：\n-- app01_emp数据\nINSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;1&#39;, &#39;令狐冲&#39;, &#39;24&#39;, &#39;6000.00&#39;, &#39;销售部&#39; , &#39;河南&#39;);\nINSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;2&#39;, &#39;任盈盈&#39;, &#39;18&#39;, &#39;8000.00&#39;, &#39;关公部&#39; , &#39;广东&#39;);\nINSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;3&#39;, &#39;任我行&#39;, &#39;56&#39;, &#39;10000.00&#39;, &#39;销售部&#39; , &#39;广东&#39;);\nINSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;4&#39;, &#39;岳灵珊&#39;, &#39;19&#39;, &#39;6000.00&#39;, &#39;关公部&#39; , &#39;河南&#39;);\nINSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;5&#39;, &#39;小龙女&#39;, &#39;20&#39;, &#39;8000.00&#39;, &#39;关公部&#39; , &#39;河北&#39;);\n-- app01_dep数据\nINSERT INTO &#96; app01_dep &#96; (&#96; id &#96;, &#96; title &#96;) VALUES (&#39;1&#39;, &#39;销售部&#39;);\nINSERT INTO &#96; app01_dep &#96; (&#96; id &#96;, &#96; title &#96;) VALUES (&#39;2&#39;, &#39;关公部&#39;);\n-- app01_emps 数据\nINSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;2&#39;, &#39;令狐冲&#39;, &#39;24&#39;, &#39;8000.00&#39;, &#39;河南&#39; , &#39;1&#39;);\nINSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;3&#39;, &#39;任盈盈&#39;, &#39;18&#39;, &#39;9000.00&#39;, &#39;广东&#39; , &#39;2&#39;);\nINSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;4&#39;, &#39;任我行&#39;, &#39;57&#39;, &#39;10000.00&#39;, &#39;广东&#39; , &#39;1&#39;);\nINSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;5&#39;, &#39;岳灵珊&#39;, &#39;19&#39;, &#39;6000.00&#39;, &#39;河南&#39; , &#39;2&#39;);\nINSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;6&#39;, &#39;小龙女&#39;, &#39;20&#39;, &#39;8000.00&#39;, &#39;河北&#39; , &#39;2&#39;);\n\n统计每一个出版社的最便宜的书的价格：\n实例\nres &#x3D; models.Publish.objects.values(&quot;name&quot;).annotate(in_price &#x3D; Min(&quot;book__price&quot;))\nprint(res)\n\n命令行中可以看到以下输出：\n&lt;QuerySet [&#123;&#39;name&#39;: &#39;菜鸟出版社&#39;, &#39;in_price&#39;: Decimal(&#39;100.00&#39;)&#125;, &#123;&#39;name&#39;: &#39;明教出版社&#39;, &#39;in_price&#39;: Decimal(&#39;300.00&#39;)&#125;]&gt;\n\n统计每一本书的作者个数：\n实例\nres &#x3D; models.Book.objects.annotate(c &#x3D; Count(&quot;authors__name&quot;)).values(&quot;title&quot;,&quot;c&quot;)\nprint(res)\n\n命令行中可以看到以下输出：\n&lt;QuerySet [&#123;&#39;title&#39;: &#39;菜鸟教程&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;吸星大法&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;冲灵剑法&#39;, &#39;c&#39;: 1&#125;]&gt;\n\n统计每一本以”菜”开头的书籍的作者个数：\n实例\nres &#x3D; models.Book.objects.filter(title__startswith&#x3D;&quot;菜&quot;).annotate(c &#x3D; Count(&quot;authors__name&quot;)).values(&quot;title&quot;,&quot;c&quot;)\nprint(res)\n\n统计不止一个作者的图书名称：\n实例\nres &#x3D; models.Book.objects.annotate(c &#x3D; Count(&quot;authors__name&quot;)).filter(c__gt&#x3D;0).values(&quot;title&quot;,&quot;c&quot;)\nprint(res)\n\n命令行中可以看到以下输出：\n&lt;QuerySet [&#123;&#39;title&#39;: &#39;菜鸟教程&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;吸星大法&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;冲灵剑法&#39;, &#39;c&#39;: 1&#125;]&gt;\n\n根据一本图书作者数量的多少对查询集 QuerySet 进行降序排序:\n实例\nres &#x3D; models.Book.objects.annotate(c &#x3D; Count(&quot;authors__name&quot;)).order_by(&quot;-c&quot;).values(&quot;title&quot;,&quot;c&quot;)\nprint(res)\n\n查询各个作者出的书的总价格:\n实例\nres &#x3D; models.Author.objects.annotate(all &#x3D; Sum(&quot;book__price&quot;)).values(&quot;name&quot;,&quot;all&quot;)\nprint(res)\n\nF() 查询F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。\n之前构造的过滤器都只是将字段值与某个常量做比较，如果想要对两个字段的值做比较，就需要用到 F()。\n使用前要先从 django.db.models 引入 F:\nfrom django.db.models import F用法：\nF(“字段名称”)F 动态获取对象字段的值，可以进行运算。\nDjango 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取余的操作。\n修改操作（update）也可以使用 F() 函数。\n查询工资大于年龄的人：\n实例\nfrom django.db.models import F\n...\nbook&#x3D;models.Emp.objects.filter(salary__gt&#x3D;F(&quot;age&quot;)).values(&quot;name&quot;,&quot;age&quot;)\n...\n\n将每一本书的价格提高 100 元:\n实例\nres &#x3D; models.Book.objects.update(price&#x3D;F(&quot;price&quot;)+100)\nprint(res)\n\nQ() 查询 （与 或 非）操作符使用前要先从 django.db.models 引入 Q:from django.db.models import Q用法：\nQ(条件判断)\n例如：\nQ(title__startswith&#x3D;”菜”)之前构造的过滤器里的多个条件的关系都是 and，如果需要执行更复杂的查询（例如 or 语句），就可以使用 Q 。\nQ 对象可以使用 &amp; | ~ （与 或 非）操作符进行组合。\n优先级从高到低：~ &amp; |。\n可以混合使用 Q 对象和关键字参数，Q 对象和关键字参数是用”and”拼在一起的（即将逗号看成 and ），但是 Q 对象必须位于所有关键字参数的前面。\n查询价格大于 350 或者名称以菜开头的书籍的名称和价格。\nfrom django.db.models import Q实例\n...\nres&#x3D;models.Book.objects.filter(Q(price__gt&#x3D;350)|Q(title__startswith&#x3D;&quot;菜&quot;)).values(&quot;title&quot;,&quot;price&quot;)\nprint(res)\n...\n\n查询以”菜”结尾或者不是 2010 年 10 月份的书籍:\n实例\nres &#x3D; models.Book.objects.filter(Q(title__endswith&#x3D;&quot;菜&quot;) | ~Q(Q(pub_date__year&#x3D;2010) &amp; Q(pub_date__month&#x3D;10)))\nprint(res)\n\n查询出版日期是 2004 或者 1999 年，并且书名中包含有”菜”的书籍。\nQ 对象和关键字混合使用，Q 对象要在所有关键字的前面:\n实例\nres &#x3D; models.Book.objects.filter(Q(pub_date__year&#x3D;2004) | Q(pub_date__year&#x3D;1999), title__contains&#x3D;&quot;菜&quot;)\nprint(res)\n\n分页查询见 django 中 orm 分页功能（内置分页）\n\nfrom django.core.paginator import Paginator,Page#导入模块\n\n\ndef custom(request):\n  #获取当前页\n  current_page &#x3D; request.GET.get(&#39;page&#39;)\n  current_page &#x3D; int(current_page)\n  #每页显示10条\n  per_page &#x3D; 10\n  #1,0-10\n  #2，10-20\n  #3,20-30\n  start_page &#x3D; (current_page -1) * per_page\n  end_page &#x3D; current_page * per_page\n  user_list &#x3D; models.Uinfo.objects.all()[start_page:end_page]\n  return render(request,&#39;custom.html&#39;,&#123;&#39;user_list&#39;:user_list&#125;)\n\n\n接口文档\n不支持 knif4j\nswagger 不维护了\ndrf-yasg 不好用，而且还有 bug（仅仅点了几下就发现 bug,不能忍～）\n\n个人感受生态不全：经过两天学习，觉得 python 生态没想象中的那么优秀，Django 也没有想象中的那么好，生态最起码比不上 java 和 nodejs\n语言简化：java 强语言，nodejs 有 typescipt 夹持，看起来 Django 优点弱鸡，python 更像是脚本语言\n不好理解：Django ORM 用起来没有 Typeorm 或者 mybatis 那么好理解，有些单划线&#x2F;双划线的东西，为了简化而简化，失去语义话\n有个问题：怎么就语言排行榜排到第一了，费解～\n我又安装了一遍 python\nWARNING: Python 2.7 is not recommended.\nThis version is included in macOS for compatibility with legacy software.\n&#x2F;&#x2F; macOS 以后默认是 python3\nFuture versions of macOS will not include Python 2.7.\nInstead, it is recommended that you transition to using &#39;python3&#39; from within Terminal.\n\n👑 ~ $ python --version\nPython 2.7.18\n👑 ~ $\n👑 ~ $\n👑 ~ $\n👑 ~ $\n👑 ~ $ brew update\nUpdated 2 taps (homebrew&#x2F;core and homebrew&#x2F;cask).\n&#x3D;&#x3D;&gt; New Formulae\nadamstark-audiofile           gaze                          lunar-date                    rdb\nage-plugin-yubikey            gcc@11                        mabel                         redis@6.2\nagg                           gcem                          maclaunch                     release-it\nantidote                      gdrive-downloader             mailsy                        req\napophenia                     gebug                         manifest-tool                 ripsecrets\narxiv_latex_cleaner           ghc@8.10                      mariadb@10.7                  rome\nastro                         ghorg                         markdown-toc                  rush-parallel\nautocorrect                   git-codereview                mbt                           sambamba\naws-nuke                      git-delete-merged-branches    mbw                           scala@2.13\naws2-wrap                     git-machete                   mcap                          schemathesis\naztfy                         git-sync                      meek                          sdl2_sound\nbazarr                        git-workspace                 mesheryctl                    sftpgo\nbdftopcf                      glibc@2.13                    metalang99                    sgn\nberkeley-db@5                 glider                        metview                       sgr\nbfgminer                      gnustep-base                  micro_inetd                   shaderc\nbore-cli                      go-camo                       minimap2                      slither-analyzer\nburst                         go@1.18                       mkfontscale                   smap\nc                             goctl                         mkp224o                       snapcast\nc2rust                        gokart                        mle                           snowball\ncamlp-streams                 got                           monika                        snowflake\ncargo-bundle                  groestlcoin                   mprocs                        solc-select\ncargo-crev                    gum                           mqttui                        spirv-headers\ncargo-depgraph                has                           mxnet                         spr\ncargo-nextest                 hatch                         mycorrhiza                    sqlcmd\ncargo-udeps                   helix                         mypaint-brushes               sse2neon\ncargo-zigbuild                helmify                       nali                          stanc3\ncbindgen                      highway                       naml                          stencil\ncensys                        hof                           nb                            svt-av1\ncfonts                        hpp-fcl                       neovide                       swiftdraw\nchain-bench                   hwatch                        netcdf-cxx                    swtpm\ncircumflex                    hyx                           netcdf-fortran                synergy-core\ncommitlint                    iir1                          nftables                      taplo\ncpi                           ijq                           nmrpflash                     tbls\ncpp-httplib                   install-peerdeps              nuraft                        tea\ncql-proxy                     interface99                   oak                           teller\ncreate-api                    iptables                      objconv                       tere\ncrytic-compile                jackett                       ocl-icd                       terramate\ncurlcpp                       jaq                           octosql                       textract\ncxgo                          jj                            ohdear-cli                    tfel\nczg                           json2tsv                      onlykey-agent                 tinysearch\ndart-sdk                      jupp                          open62541                     tlsx\ndatatype99                    kalign                        opencl-headers                toml-test\ndbml-cli                      kics                          opencl-icd-loader             toxcore\ndistrobox                     ksh93                         opentelemetry-cpp             tradcpp\ndocker-buildx                 kt-connect                    openvi                        treefmt\ndoggo                         kubesess                      ouch                          tremor-runtime\ndooit                         leapp-cli                     pacmc                         trezor-bridge\ndotdrop                       levant                        page                          trzsz-go\ndronedb                       lexicon                       pax                           ttdl\ndsda-doom                     lgeneral                      pg_cron                       ttmath\ndtrx                          libabw                        pg_partman                    tuc\ndump1090-mutability           libapplewm                    pget                          tuntox\ndumpling                      libbpf                        phrase-cli                    tygo\ndunamai                       libeatmydata                  pint                          typewritten\ndura                          libff                         pipe-rename                   unisonlang\ndynein                        liblbfgs                      pixie                         uthash\nechidna                       libnetfilter_conntrack        pixiewps                      vectorscan\nedencommon                    libnftnl                      pkcs11-tools                  verapdf\neditorconfig-checker          libnl                         poac                          verovio\neget                          libobjc2                      pocl                          vile\nenex2notion                   libplacebo                    podman-compose                vineyard\nerlang@24                     libpython-tabulate            popeye                        virt-manager\nevernote-backup               libtpms                       primecount                    vsce\nfastfetch                     liburing                      protobuf@3                    vulkan-loader\nfastnetmon                    libvatek                      prql-compiler                 wasm-micro-runtime\nfclones                       libxcvt                       prr                           wb32-dfu-updater_cli\nfelinks                       libxfont2                     purescript-language-server    weasyprint\nfend                          licenseplist                  pymol                         webkitgtk\nferium                        licensor                      pymupdf                       x86_64-linux-gnu-binutils\nflix                          linux-headers@5.15            python-build                  xcode-kotlin\nflock                         livekit                       python-typing-extensions      xctesthtmlreport\nfonts-encodings               livekit-cli                   pyyaml                        xdg-ninja\nfortls                        llvm@13                       qbe                           xkbcomp\nfred                          llvm@14                       qsv                           xpipe\nfreebayes                     lmfit                         quilt-installer               xwin\nfuego-firestore               lndir                         quran                         yorkie\ngator                         lucky-commit                  railway                       zx\n&#x3D;&#x3D;&gt; New Casks\naethersx2                                                   mbcord\nakiflow                                                     medis\naliwangwang                                                 mega\namazon-luna                                                 metadatics\napifox                                                      miaoyan\napipost                                                     micromamba\napp-fair                                                    mighty-mike\naptakube                                                    miln-movie-splitter\narchy                                                       miniwol\narduino-ide                                                 mints\nastrofox                                                    moderndeck\navifquicklook                                               mp3tag\nbattery                                                     mx-power-gadget\nbeast2                                                      nanoem\nbetterandbetter                                             nitro-pdf-pro\nbetterdisplay                                               notesnook\nbike                                                        opencore-patcher\nbili-downloader                                             orangedrangon-android-messages\nbing-wallpaper                                              orion\nblack-light                                                 orka-vm-tools\nblack-light-pro                                             oso-cloud\nbluebubbles                                                 osu\nbookwright                                                  oxwu\nbridge                                                      phpwebstudy\ncalhash                                                     pictureview\ncardinal                                                    playcover-community\ncardpresso                                                  plex-htpc\nchromium-gost                                               plugdata\ncider                                                       plus42-binary\ncisdem-duplicate-finder                                     plus42-decimal\ncleaneronepro                                               podman-desktop\ncloud189                                                    polypad\ncontour                                                     postman-cli\ncro-mag-rally                                               protokol\ndcp-o-matic-combiner                                        psst\ndcp-o-matic-disk-writer                                     qspace-pro\ndcp-o-matic-editor                                          qwerty-fr\ndcp-o-matic-playlist-editor                                 random-mouse-clicker\ndecentr                                                     readdle-spark\ndetail                                                      reflect\ndevcleaner                                                  reverso\ndiffusionbee                                                rnnoise\ndixa                                                        roam-research\ndmg-canvas                                                  rockboxutility\ndoll                                                        rustdesk\ndouyin                                                      sanesidebuttons\ndrawpile                                                    shop-different\nduckduckgo                                                  snapmaker-luban\necamm-live                                                  sol\nelectrum-grs                                                sonixd\nelephicon                                                   spline\nferdium                                                     squash\nfertigt-slate                                               swiftcord\nfilen                                                       tailscale\nfly-key                                                     tdr-kotelnikov\nfresh                                                       tdr-nova\ngama                                                        tdr-vos-slickeq\ngama-jdk                                                    tempbox\ngamemaker                                                   texifier\ngamma-control                                               ti-smartview-ce-for-the-ti-84-plus-family\ngittyup                                                     tl-legacy\nglance-chamburr                                             tmpdisk\ngoxel                                                       tomatobar\ngroestlcoin-core                                            tqsl\ngyroflow                                                    trivial\nhdfview                                                     trunk-io\nheadlamp                                                    twitch-studio\nhttpie                                                      typcn-bilibili\nimhex                                                       ui\ninput-source-pro                                            ukrainian-typographic-keyboard\niqmol                                                       universal-android-debloater\njpc-qlcolorcode                                             v2ray-unofficial\njquake                                                      ved\njuice                                                       vieb\nkeet                                                        virtualbuddy\nlaconvolver                                                 weektodo\nlanguagetool                                                whist-browser\nlectrote                                                    wirecast\nlemonlime                                                   workman\nlivebook                                                    wow\nlocalxpose                                                  xiv-on-mac\nlookingglassbridge                                          xprocheck\nlookingglassstudio                                          yandex-music-unofficial\nlunacy                                                      yattee\nmacforge                                                    yousician\nmanila                                                      yubihsm2-sdk\n&#x3D;&#x3D;&gt; Outdated Formulae\nboost               gdbm                jpeg                ncurses             redis               zsh-completions\nca-certificates     gettext             libidn2             nginx               sqlite              zstd\ncocoapods           git                 libpng              openssl@1.1         tree\ndouble-conversion   glog                libtiff             pcre2               watchman\nfmt                 graphicsmagick      libtool             python@3.10         webp\nfolly               icu4c               little-cms2         python@3.9          xz\nfreetype            jasper              lz4                 readline            zsh\n\nYou have 37 outdated formulae installed.\nYou can upgrade them with brew upgrade\nor list them with brew outdated.\n\n\n\n👑 ~ $ brew upgrade python@3.10\n&#x3D;&#x3D;&gt; Upgrading 1 outdated package:\npython@3.10 3.10.0_2 -&gt; 3.10.7\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;gdbm&#x2F;manifests&#x2F;1.23\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;gdbm&#x2F;blobs&#x2F;sha256:0d0aeea95f9e7b4ccfa1e8d7f3a83b3b4d604eac1178e4f88ad\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:0d0aeea95f9e7b4ccfa1e8d7f3a83b3b4\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;ca-certificates&#x2F;manifests&#x2F;2022-10-11\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;ca-certificates&#x2F;blobs&#x2F;sha256:1b264e579e31b3041a87ff91f09d5f7cc0d51fea\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:1b264e579e31b3041a87ff91f09d5f7cc\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;openssl&#x2F;1.1&#x2F;manifests&#x2F;1.1.1r\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;openssl&#x2F;1.1&#x2F;blobs&#x2F;sha256:7b4469b13c9dccfaf9a239b8fad644e3bd31d1bba474\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:7b4469b13c9dccfaf9a239b8fad644e3b\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;readline&#x2F;manifests&#x2F;8.2.1\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;readline&#x2F;blobs&#x2F;sha256:19e6b02f577010a1a33c6ae6f09e40772d6ab22d94b6cf3\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:19e6b02f577010a1a33c6ae6f09e40772\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;sqlite&#x2F;manifests&#x2F;3.39.4\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;sqlite&#x2F;blobs&#x2F;sha256:43b72d87a55f57496284e1028986373e918f382b8381e6b29\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:43b72d87a55f57496284e1028986373e9\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;xz&#x2F;manifests&#x2F;5.2.7\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;xz&#x2F;blobs&#x2F;sha256:02ed422191f81ca5c476f82264b6662a1ebcf95b90fb3ee10b524\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:02ed422191f81ca5c476f82264b6662a1\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.10&#x2F;manifests&#x2F;3.10.7\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.10&#x2F;blobs&#x2F;sha256:710e2e28077bf203fd50929bb094cb142e26f6ffd666\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:710e2e28077bf203fd50929bb094cb142\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Upgrading python@3.10\n  3.10.0_2 -&gt; 3.10.7\n\n&#x3D;&#x3D;&gt; Installing dependencies for python@3.10: gdbm, ca-certificates, openssl@1.1, readline, sqlite and xz\n&#x3D;&#x3D;&gt; Installing python@3.10 dependency: gdbm\n&#x3D;&#x3D;&gt; Pouring gdbm--1.23.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;gdbm&#x2F;1.23: 24 files, 956.7KB\n&#x3D;&#x3D;&gt; Installing python@3.10 dependency: ca-certificates\n&#x3D;&#x3D;&gt; Pouring ca-certificates--2022-10-11.all.bottle.tar.gz\n&#x3D;&#x3D;&gt; Regenerating CA certificate bundle from keychain, this may take a while...\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;ca-certificates&#x2F;2022-10-11: 3 files, 225.5KB\n&#x3D;&#x3D;&gt; Installing python@3.10 dependency: openssl@1.1\n&#x3D;&#x3D;&gt; Pouring openssl@1.1--1.1.1r.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openssl@1.1&#x2F;1.1.1r: 8,097 files, 18.5MB\n&#x3D;&#x3D;&gt; Installing python@3.10 dependency: readline\n&#x3D;&#x3D;&gt; Pouring readline--8.2.1.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;readline&#x2F;8.2.1: 50 files, 1.7MB\n&#x3D;&#x3D;&gt; Installing python@3.10 dependency: sqlite\n&#x3D;&#x3D;&gt; Pouring sqlite--3.39.4.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;sqlite&#x2F;3.39.4: 11 files, 4.4MB\n&#x3D;&#x3D;&gt; Installing python@3.10 dependency: xz\n&#x3D;&#x3D;&gt; Pouring xz--5.2.7.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;xz&#x2F;5.2.7: 95 files, 1.4MB\n&#x3D;&#x3D;&gt; Installing python@3.10\n&#x3D;&#x3D;&gt; Pouring python@3.10--3.10.7.monterey.bottle.tar.gz\nError: The &#96;brew link&#96; step did not complete successfully\nThe formula built, but is not symlinked into &#x2F;usr&#x2F;local\nCould not symlink bin&#x2F;2to3\nTarget &#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3\nalready exists. You may want to remove it:\n  rm &#39;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3&#39;\n\nTo force the link and overwrite all conflicting files:\n  brew link --overwrite python@3.10\n\nTo list all files that would be deleted:\n  brew link --overwrite --dry-run python@3.10\n\nPossible conflicting files are:\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;2to3\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3-3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;2to3-3.10\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;idle3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;idle3\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;idle3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;idle3.10\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pydoc3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;pydoc3\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pydoc3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;pydoc3.10\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3-config -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3-config\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3.10\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10-config -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3.10-config\n&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7&#x2F;bin&#x2F;python3.10 -m ensurepip\n&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7&#x2F;bin&#x2F;python3.10 -m pip install -v --no-deps --no-index --upgrade --isolated --target&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.10&#x2F;site-packages &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7&#x2F;Fr\n&#x3D;&#x3D;&gt; Summary\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7: 3,112 files, 56.5MB\n&#x3D;&#x3D;&gt; Running &#96;brew cleanup python@3.10&#96;...\nDisable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.\nHide these hints with HOMEBREW_NO_ENV_HINTS (see &#96;man brew&#96;).\nRemoving: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.0_2... (3,134 files, 55.8MB)\n&#x3D;&#x3D;&gt; Upgrading 5 dependents of upgraded formulae:\nDisable this behaviour by setting HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK.\nHide these hints with HOMEBREW_NO_ENV_HINTS (see &#96;man brew&#96;).\nfolly 2021.10.18.00 -&gt; 2022.10.03.00, nginx 1.21.5 -&gt; 1.23.1, python@3.9 3.9.7_1 -&gt; 3.9.15, redis 6.2.6 -&gt; 7.0.5, watchman 2021.10.18.00 -&gt; 2022.10.03.00\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;icu4c&#x2F;manifests&#x2F;71.1\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;icu4c&#x2F;blobs&#x2F;sha256:87617a04333c53236f5174f5a3fa70458d61d735024ed477c0\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:87617a04333c53236f5174f5a3fa70458\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;lz4&#x2F;manifests&#x2F;1.9.4\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;lz4&#x2F;blobs&#x2F;sha256:88b369cea90a0a119c24aa96a614fe7d77de58d18cb1803023dc\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:88b369cea90a0a119c24aa96a614fe7d7\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;zstd&#x2F;manifests&#x2F;1.5.2-3\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;zstd&#x2F;blobs&#x2F;sha256:b0eabfa556c5aed039a5b22cd7e2e3dd52c7d2416c1141e4a8e\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:b0eabfa556c5aed039a5b22cd7e2e3dd5\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;boost&#x2F;manifests&#x2F;1.80.0\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;boost&#x2F;blobs&#x2F;sha256:cc487497f5beaa3726ed3e8772e8066e968ad494917b35c58c\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:cc487497f5beaa3726ed3e8772e8066e9\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;double-conversion&#x2F;manifests&#x2F;3.2.1\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;double-conversion&#x2F;blobs&#x2F;sha256:ab33e3194744d91e611c402d1f5ed5243ffa7b\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:ab33e3194744d91e611c402d1f5ed5243\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fmt&#x2F;manifests&#x2F;9.1.0\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fmt&#x2F;blobs&#x2F;sha256:324344e5048ea4bf92352dcdfae63832d447c0d27cc01d45eecc\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:324344e5048ea4bf92352dcdfae63832d\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;glog&#x2F;manifests&#x2F;0.6.0\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;glog&#x2F;blobs&#x2F;sha256:04b418eda3d8089e64ab902d265dd935245c815b19933173f67\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:04b418eda3d8089e64ab902d265dd9352\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;folly&#x2F;manifests&#x2F;2022.10.03.00\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;folly&#x2F;blobs&#x2F;sha256:98bfca5e3fb0a99e08f7bd7336ae3984eb4ca5cee7a716885a\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:98bfca5e3fb0a99e08f7bd7336ae3984e\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;pcre2&#x2F;manifests&#x2F;10.40\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;pcre2&#x2F;blobs&#x2F;sha256:3d2707e8d5a80e1a28875e3b9c7b47cebaf5fd420049d6f1a7\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:3d2707e8d5a80e1a28875e3b9c7b47ceb\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;nginx&#x2F;manifests&#x2F;1.23.1\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;nginx&#x2F;blobs&#x2F;sha256:7e05d8658f1e2c264028530fc70ba4c87e6c152b85b3f014f2\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:7e05d8658f1e2c264028530fc70ba4c87\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.9&#x2F;manifests&#x2F;3.9.15\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.9&#x2F;blobs&#x2F;sha256:15e10e163d4e24b12ba288b00bc9a7d4c4369a42dbbec\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:15e10e163d4e24b12ba288b00bc9a7d4c\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;redis&#x2F;manifests&#x2F;7.0.5\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;redis&#x2F;blobs&#x2F;sha256:34957c1e8e932793ff3d356fe5ae0e1bb36d9f0b6418ef25f0\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:34957c1e8e932793ff3d356fe5ae0e1bb\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;edencommon&#x2F;manifests&#x2F;2022.10.03.00\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;edencommon&#x2F;blobs&#x2F;sha256:9d84be36d7c4ac1ae077fa732233e86fc2e11ef3511c0\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:9d84be36d7c4ac1ae077fa732233e86fc\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;libsodium&#x2F;manifests&#x2F;1.0.18_1\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;libsodium&#x2F;blobs&#x2F;sha256:522ac3f26c646f3d276b0c997e1a2771559d4766362d28\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:522ac3f26c646f3d276b0c997e1a27715\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fizz&#x2F;manifests&#x2F;2022.10.03.00\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fizz&#x2F;blobs&#x2F;sha256:8c0a984b2701acfe0d03f5b8c6e407367fef65f9a55540681ea\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:8c0a984b2701acfe0d03f5b8c6e407367\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;wangle&#x2F;manifests&#x2F;2022.10.03.00\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;wangle&#x2F;blobs&#x2F;sha256:eabcfc7dd5dbf84488847e008559e5259ce11a534726f2f7f\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:eabcfc7dd5dbf84488847e008559e5259\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fbthrift&#x2F;manifests&#x2F;2022.10.03.00\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fbthrift&#x2F;blobs&#x2F;sha256:32977a7a9420533f6de58dd1734e9e42a5aba22d624bff5\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:32977a7a9420533f6de58dd1734e9e42a\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fb303&#x2F;manifests&#x2F;2022.10.03.00\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fb303&#x2F;blobs&#x2F;sha256:ade782f9844e6f1a96a5a8bec6f582b6aaae0a39b01bbdd3e5\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:ade782f9844e6f1a96a5a8bec6f582b6a\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;watchman&#x2F;manifests&#x2F;2022.10.03.00\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;watchman&#x2F;blobs&#x2F;sha256:a5974893885c994eb31772fa0eeccd016cfa9b1e31c7f7a\n&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:a5974893885c994eb31772fa0eeccd016\n######################################################################## 100.0%\n&#x3D;&#x3D;&gt; Upgrading folly\n  2021.10.18.00 -&gt; 2022.10.03.00\n\n&#x3D;&#x3D;&gt; Installing dependencies for folly: icu4c, lz4, zstd, boost, double-conversion, fmt and glog\n&#x3D;&#x3D;&gt; Installing folly dependency: icu4c\n&#x3D;&#x3D;&gt; Pouring icu4c--71.1.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;icu4c&#x2F;71.1: 262 files, 76.2MB\n&#x3D;&#x3D;&gt; Installing folly dependency: lz4\n&#x3D;&#x3D;&gt; Pouring lz4--1.9.4.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;lz4&#x2F;1.9.4: 22 files, 685.2KB\n&#x3D;&#x3D;&gt; Installing folly dependency: zstd\n&#x3D;&#x3D;&gt; Pouring zstd--1.5.2.monterey.bottle.3.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zstd&#x2F;1.5.2: 31 files, 2.4MB\n&#x3D;&#x3D;&gt; Installing folly dependency: boost\n&#x3D;&#x3D;&gt; Pouring boost--1.80.0.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;boost&#x2F;1.80.0: 15,568 files, 472MB\n&#x3D;&#x3D;&gt; Installing folly dependency: double-conversion\n&#x3D;&#x3D;&gt; Pouring double-conversion--3.2.1.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;double-conversion&#x2F;3.2.1: 26 files, 242.3KB\n&#x3D;&#x3D;&gt; Installing folly dependency: fmt\n&#x3D;&#x3D;&gt; Pouring fmt--9.1.0.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fmt&#x2F;9.1.0: 27 files, 1MB\n&#x3D;&#x3D;&gt; Installing folly dependency: glog\n&#x3D;&#x3D;&gt; Pouring glog--0.6.0.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;glog&#x2F;0.6.0: 22 files, 315.7KB\n&#x3D;&#x3D;&gt; Installing folly\n&#x3D;&#x3D;&gt; Pouring folly--2022.10.03.00.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;folly&#x2F;2022.10.03.00: 839 files, 24.5MB\n&#x3D;&#x3D;&gt; Running &#96;brew cleanup folly&#96;...\nRemoving: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;folly&#x2F;2021.10.18.00... (795 files, 23.6MB)\n&#x3D;&#x3D;&gt; Upgrading nginx\n  1.21.5 -&gt; 1.23.1\n\n&#x3D;&#x3D;&gt; Installing dependencies for nginx: pcre2\n&#x3D;&#x3D;&gt; Installing nginx dependency: pcre2\n&#x3D;&#x3D;&gt; Pouring pcre2--10.40.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;pcre2&#x2F;10.40: 230 files, 6.4MB\n&#x3D;&#x3D;&gt; Installing nginx\n&#x3D;&#x3D;&gt; Pouring nginx--1.23.1.monterey.bottle.tar.gz\n&#x3D;&#x3D;&gt; Caveats\nDocroot is: &#x2F;usr&#x2F;local&#x2F;var&#x2F;www\n\nThe default port has been set in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf to 8080 so that\nnginx can run without sudo.\n\nnginx will load all files in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;.\n\nTo restart nginx after an upgrade:\n  brew services restart nginx\nOr, if you don&#39;t want&#x2F;need a background service you can just run:\n  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;\n&#x3D;&#x3D;&gt; Summary\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.23.1: 26 files, 2.2MB\n&#x3D;&#x3D;&gt; Running &#96;brew cleanup nginx&#96;...\nRemoving: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.21.5... (26 files, 2.2MB)\n&#x3D;&#x3D;&gt; Upgrading python@3.9\n  3.9.7_1 -&gt; 3.9.15\n\n&#x3D;&#x3D;&gt; Pouring python@3.9--3.9.15.monterey.bottle.tar.gz\n&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15&#x2F;bin&#x2F;python3.9 -m ensurepip\n&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15&#x2F;bin&#x2F;python3.9 -m pip install -v --no-deps --no-index --upgrade --isolated --target&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.9&#x2F;site-packages &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15&#x2F;Framew\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15: 3,069 files, 55.5MB\n&#x3D;&#x3D;&gt; Running &#96;brew cleanup python@3.9&#96;...\nRemoving: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.7_1... (3,080 files, 54.6MB)\n&#x3D;&#x3D;&gt; Upgrading redis\n  6.2.6 -&gt; 7.0.5\n\n&#x3D;&#x3D;&gt; Pouring redis--7.0.5.monterey.bottle.tar.gz\n&#x3D;&#x3D;&gt; Caveats\nTo restart redis after an upgrade:\n  brew services restart redis\nOr, if you don&#39;t want&#x2F;need a background service you can just run:\n  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis.conf\n&#x3D;&#x3D;&gt; Summary\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;redis&#x2F;7.0.5: 14 files, 2.6MB\n&#x3D;&#x3D;&gt; Running &#96;brew cleanup redis&#96;...\nRemoving: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;redis&#x2F;6.2.6... (14 files, 2.0MB)\n&#x3D;&#x3D;&gt; Upgrading watchman\n  2021.10.18.00 -&gt; 2022.10.03.00\n\n&#x3D;&#x3D;&gt; Installing dependencies for watchman: edencommon, libsodium, fizz, wangle, fbthrift and fb303\n&#x3D;&#x3D;&gt; Installing watchman dependency: edencommon\n&#x3D;&#x3D;&gt; Pouring edencommon--2022.10.03.00.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;edencommon&#x2F;2022.10.03.00: 15 files, 294.7KB\n&#x3D;&#x3D;&gt; Installing watchman dependency: libsodium\n&#x3D;&#x3D;&gt; Pouring libsodium--1.0.18_1.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;libsodium&#x2F;1.0.18_1: 73 files, 1MB\n&#x3D;&#x3D;&gt; Installing watchman dependency: fizz\n&#x3D;&#x3D;&gt; Pouring fizz--2022.10.03.00.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fizz&#x2F;2022.10.03.00: 184 files, 3.8MB\n&#x3D;&#x3D;&gt; Installing watchman dependency: wangle\n&#x3D;&#x3D;&gt; Pouring wangle--2022.10.03.00.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;wangle&#x2F;2022.10.03.00: 117 files, 3.3MB\n&#x3D;&#x3D;&gt; Installing watchman dependency: fbthrift\n&#x3D;&#x3D;&gt; Pouring fbthrift--2022.10.03.00.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fbthrift&#x2F;2022.10.03.00: 755 files, 20.9MB\n&#x3D;&#x3D;&gt; Installing watchman dependency: fb303\n&#x3D;&#x3D;&gt; Pouring fb303--2022.10.03.00.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fb303&#x2F;2022.10.03.00: 56 files, 3.6MB\n&#x3D;&#x3D;&gt; Installing watchman\n&#x3D;&#x3D;&gt; Pouring watchman--2022.10.03.00.monterey.bottle.tar.gz\n🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;watchman&#x2F;2022.10.03.00: 22 files, 13.6MB\n&#x3D;&#x3D;&gt; Running &#96;brew cleanup watchman&#96;...\nRemoving: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;watchman&#x2F;2021.10.18.00... (23 files, 5.4MB)\n&#x3D;&#x3D;&gt; Checking for dependents of upgraded formulae...\n&#x3D;&#x3D;&gt; No broken dependents found!\n&#x3D;&#x3D;&gt; Caveats\n&#x3D;&#x3D;&gt; nginx\nDocroot is: &#x2F;usr&#x2F;local&#x2F;var&#x2F;www\n\nThe default port has been set in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf to 8080 so that\nnginx can run without sudo.\n\nnginx will load all files in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;.\n\nTo restart nginx after an upgrade:\n  brew services restart nginx\nOr, if you don&#39;t want&#x2F;need a background service you can just run:\n  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;\n&#x3D;&#x3D;&gt; redis\nTo restart redis after an upgrade:\n  brew services restart redis\nOr, if you don&#39;t want&#x2F;need a background service you can just run:\n  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis.conf\n👑 ~ $ python3 -V\nPython 3.10.0\n👑 ~ $\n\n\n\n命令行 python 换行在命令行中“&gt;&gt;&gt;”是 python 的输入提示符，按回车键则表示输入结束。那么如何在命令行中换行呢？\n换行方法：\\\n如：变量换行 需要;\\\n&gt;&gt;&gt; print &#39;aaa&#39;; \\\n... print &#39;bbb&#39;; \\\n... print &#39;ccc&#39;\n\n注意“;”的使用。python 本身语句结束和间隔都是不需要“;”的，但是在换行时要使用“;”，最后一行不要求必须有“;”，加上也不会出错。\n函数不需要;\\换行\n&gt;&gt;&gt; def fun(params):\n...   print(params); &#x2F;&#x2F; 注意前面有两个空格\n...\n&gt;&gt;&gt; fun(&#39;hello wolrd&#39;)\nhello wolrd\n\n查看数据类型\n&gt;&gt;&gt; type(a)\n&lt;class &#39;list&#39;&gt;\n\npip官网\n👑 ~ $ curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py | python3\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 2500k  100 2500k    0     0   278k      0  0:00:08  0:00:08 --:--:--  297k\nCollecting pip\n  Downloading pip-22.2.2-py3-none-any.whl (2.0 MB)\n     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.0&#x2F;2.0 MB 3.1 MB&#x2F;s eta 0:00:00\nCollecting wheel\n  Downloading wheel-0.37.1-py2.py3-none-any.whl (35 kB)\nInstalling collected packages: wheel, pip\n  WARNING: The script wheel is installed in &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#39; which is not on PATH.\n  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n  Attempting uninstall: pip\n    Found existing installation: pip 21.2.3\n    Uninstalling pip-21.2.3:\n      Successfully uninstalled pip-21.2.3\n  WARNING: The scripts pip, pip3 and pip3.10 are installed in &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#39; which is not on PATH.\n  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\nSuccessfully installed pip-22.2.2 wheel-0.37.1\n\nffmpegbrew install ffmpeg\nffmpeg -version\n\n视频推荐B 站：小甲鱼（鱼 C）的 python 视频，视频质量不错。\n即使是学习 js 的盆友，看这个视频也会有一定的收获，毕竟“语言”与“语言”在创作的过程中，多少都有些互相借鉴的味道\n","slug":"2022-09-24python","date":"2022-09-24T10:21:22.000Z","categories_index":"Python","tags_index":"Python","author_index":"举手摘月亮"},{"id":"cda500a4ad158422b10e6e0aa3af923f","title":"React warning","content":"没有意义属性非 html 没有意义的属性向下传递,会被 react 检测到\n\n\n移除属性移除属性，避免向下传递\n","slug":"2022-09-21react","date":"2022-09-21T06:57:49.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"4cfbb91d77b5df4256b735640b2a3f88","title":"React中的术语","content":"浅合并this.setState 会进行浅合并\nfalsyfalsy 表达式 \nMDN 8 个 falsy 值\n&#x2F;&#x2F; | 值        | 说明                                                                                                      |\n&#x2F;&#x2F; | :-------- | :-------------------------------------------------------------------------------------------------------- |\n&#x2F;&#x2F; | 0         | 数值 zero                                                                                                 |\n&#x2F;&#x2F; | -0        | 数值 负 zero                                                                                              |\n&#x2F;&#x2F; | 0n        | 当 BigInt 作为布尔值使用时，遵从其作为数值的规则. 0n 是 falsy 值。                                        |\n&#x2F;&#x2F; | false     | false 关键字                                                                                              |\n&#x2F;&#x2F; | undefined | undefined - 原始值                                                                                        |\n&#x2F;&#x2F; | null      | null - 缺少值                                                                                             |\n&#x2F;&#x2F; | &quot;&quot;, &#39;&#39;, &#96; | 这是一个空字符串 (字符串的长度为零). JavaScript 中的字符串可用双引号 &quot;&quot;, 单引号 &#39;&#39;, 或 模板字面量&#96; 定义。 |\n&#x2F;&#x2F; | NaN       | NaN - 非数值 |\n\n\n\n\n\n\n\n\nWARNING\nrn 中 尽量先转 boolean 类型，否则 falsy 很有可能渲染到 View 组件中，引起崩溃\n\nkey 会传递信息给 React ，但不会传递给你的组件key 会传递信息给 React ，但不会传递给你的组件\nES6 计算属性名称计算属性名称\nthis.setState(&#123;\n  [name]: value,\n&#125;);\n\nformikformik\nBuild forms in React, without the tears\nFormik is the world&#39;s most popular open source form library for React and React Native.\n\n启发式算法这个玩意在实现 React 的 “diffing” 算法过程中所作出的设计决策，\n\n以保证组件更新可预测，\n且在繁杂业务场景下依然保持应用的高性能\n\n动机：\n在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。\n此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。\n如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：\n\n两个不同类型的元素会产生出不同的树；\n开发者可以使用 key 属性标识哪些子元素，在不同的渲染中可能是不变的。\n\n在实践中，我们发现以上假设在几乎所有实用的场景下都成立。\ndiffing 算法\n对比不同类型的元素\n对比同一类型的元素 ， React 会保留 DOM 节点，仅比对及更新有改变的属性。\n对比同类型的组件元素， 当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致\n对子节点进行递归，默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。\nKeys ， 为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高\n\n","slug":"2022-09-19react","date":"2022-09-19T12:42:20.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"d55ac1d91034293bfc294fd694ca97c4","title":"前端基础-qa","content":"var let const 区别：\n\n什么是执行上下文？当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。\n\n全局上下文：默认&#x2F;基础的上下文，任何不在函数内部的代码都在全局上下文中，一个程序中只有一个全局执行上下文\n函数执行上下文：一个函数被调用时，会为该函数创建一个上下文，每个函数都有自己的函数上下文，函数上下文可以有任意多个\neval上下文：执行在 eval 函数内部的代码也会有属于它自己的执行上下文\n\njavascript 的执行顺序\n\nJavaScript 中的代码执行顺序是基于事件循环模型的，其大致流程如下：\n\n执行全局代码。在这个过程中，JavaScript 引擎会创建全局执行上下文，并将其中的全局变量、函数等定义在全局作用域中。\n\n执行函数代码。当遇到函数调用时，JavaScript 引擎会创建函数执行上下文，并将其中的变量、函数等定义在函数作用域中。\n\n添加任务到任务队列。如果在函数执行过程中遇到异步操作，如定时器、网络请求等，JavaScript 引擎会将这些操作封装成一个任务，并将任务添加到任务队列中。\n\n等待执行。在任务添加完成之后，JavaScript 引擎会一直等待，直到当前代码执行完成并且所有任务的依赖关系得到满足。\n\n从任务队列中取出任务并执行。当任务的依赖关系满足后，JavaScript 引擎会从任务队列中取出任务，并将任务中的回调函数放入调用栈中执行。在执行任务的过程中，如果遇到新的异步操作，会将其添加到任务队列中，然后继续等待。\n\n\n需要注意的是，JavaScript 是单线程的语言，即在任何时刻只能有一个任务在执行。这就意味着，如果某个任务的执行时间过长，会阻塞后续任务的执行，导致页面失去响应。因此，开发人员需要注意控制任务的执行时间，避免长时间的计算和循环等操作。\njavascript 的执行顺序 与事件循环是什么一个概念吗JavaScript 的执行顺序与事件循环是相关的，但不是完全相同的概念。\nJavaScript 中的执行顺序是基于事件循环模型的，即在执行代码时，JavaScript 引擎会不断地从任务队列中取出任务并执行，然后再继续等待下一个任务。这个过程就是事件循环。\n事件循环是 JavaScript 引擎处理异步任务的一种机制，其中异步任务包括定时器、网络请求、用户交互等。这些异步任务在执行时，不会阻塞主线程的执行，而是在任务完成后，将回调函数放入任务队列中，等待 JavaScript 引擎处理。\n因此，JavaScript 的执行顺序和事件循环密切相关，但并不完全相同。JavaScript 的执行顺序包括了全局代码、函数代码等的执行顺序，而事件循环则是异步任务的执行顺序。同时，JavaScript 引擎还需要控制调用栈、作用域链等多种因素，来保证代码的正确执行。\n作用域【精】MDN:\n在当前的执行上下文。值和表达式在其中 \"可见\" 或可被访问到的上下文。 如果一个**变量或者其他表达式**,不 \"在当前的作用域中\"，那么它就是不可用的。\n\n作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。\n\n作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。\n\n> 在函数之外声明的变量，叫做`全局变量`，因为它可被当前文档中的任何其他代码所访问。\n> 在函数内部声明的变量，叫做`局部变量`，因为它只能在当前函数的内部访问。\n> ECMAScript 6 之前的 JavaScript 没有 `语句块作用域`；\n> es6 之后，`语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量`。 -->\n\n\n是什么\n如何分类\n如何实现作用域\n如何控制作用域\n\n作用域是指在程序中定义变量的区域，它规定了变量的可见性和生命周期。在 JavaScript 中，作用域可以分为全局作用域和局部作用域，其中全局作用域指的是在整个程序中都可见的变量，局部作用域指的是在函数或代码块内定义的变量。\n具体来说，JavaScript 中的作用域是通过作用域链实现的。作用域链是由多个执行上下文（Execution Context）的变量对象组成的链表结构，它决定了变量的查找顺序和可见性。\n当代码在执行时，JavaScript 引擎会创建执行上下文，并将其推入执行栈中。每个执行上下文都有一个变量对象，用于存储变量、函数声明和函数参数等信息。当查找变量时，JavaScript 引擎会先在当前执行上下文的变量对象中查找，如果没有找到，则会向上一级执行上下文的变量对象中查找，直到找到该变量或到达全局执行上下文为止。\n在 JavaScript 中，变量的作用域可以通过关键字 var、let、const 来控制。\n\n使用 var 关键字声明的变量具有函数作用域，即在函数内部声明的变量在函数外部无法访问。\n而使用 let 或 const 关键字声明的变量具有块级作用域，即在代码块内部声明的变量只能在该代码块内访问。\n\n因此，理解作用域是很重要的，它可以帮助我们正确地声明变量，避免命名冲突，提高代码的可读性和可维护性。同时，也可以帮助我们更好地理解 JavaScript 的执行机制和运行时环境。\n例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。\nif (true) &#123;\n  var x &#x3D; 5;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 5\n\n使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。\nif (true) &#123;\n  let y &#x3D; 5;\n&#125;\nconsole.log(y); &#x2F;&#x2F; ReferenceError: y 没有被声明\n\n作用域链【精】\n\n什么是作用域链\n作用域链（Scope Chain）是由多个执行上下文的变量对象组成的链表结构，用于决定变量的查找顺序和可见性。在 JavaScript 中，每个函数都有一个作用域链，它由当前函数的变量对象和所有包含它的父函数的变量对象组成。\n当 JavaScript 引擎在执行一个函数时，会首先在该函数的变量对象中查找要访问的变量。如果找到了，则直接使用该变量；否则，会沿着作用域链依次向上查找，直到找到该变量或到达全局执行上下文的变量对象为止。如果在最后都没有找到该变量，则会抛出“ReferenceError”异常。\n举个例子，假设我们有以下代码：\nfunction foo() &#123;\n  var x &#x3D; 10;\n\n  function bar() &#123;\n    var y &#x3D; 20;\n    console.log(x + y);\n  &#125;\n\n  bar();\n&#125;\n\nfoo();\n\n在执行函数 bar 时，JavaScript 引擎会先在 bar 函数的变量对象中查找变量 y，找到后直接使用。但是，当它需要访问变量 x 时，会沿着作用域链向上查找，在 foo 函数的变量对象中找到该变量，因此可以正常访问并输出 30。\n需要注意的是，作用域链是在函数创建时确定的，与函数的调用方式无关。\n\n因此，在一个函数内部定义的变量只能在该函数内部访问，而不能在外部访问。\n此外，由于闭包的存在，一个函数可以访问其定义时的作用域链上的所有变量，这也是 JavaScript 中一种强大的编程技巧。\n\nJavaScript 执行机制二（深入之闭包） -->\n\n词法作用域\n词法作用域是由代码声明的位置决定的，所以词法作用域是静态作用域，通过它能预测代码在执行过程中如何查找标识。\n对于代码中存在块级作用域的情况，作用域链首先在词法环境中查找，没找到才会到变量环境中查找\n\n\n\n闭包在 JavaScript 中，根据词法作用域的规则，内部函数总能访问外部函数声明的变量，当通过调用外部函数返回内部函数时，即使外部函数执行完毕，内部函数引用外部函数的变量仍存在内存中，我们就把这些变量的集合称为闭包\n那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？\n如果一个函数内有闭包，javascript 在执行这个函数时候，会预扫描内部函数是否有使用的 foo 函数中声明的变量；\n预扫描过程中，在内层函数 showName 中找到了外部函数 foo 中声明的变量 name，因此在 JavaScript 中判断这是一个闭包，\n此时会在堆中开辟一个空间创建 closure(foo)对象，将 name 值存到里面。\n而执行栈中的 foo 执行上下文中的 name 存的值是 closure(foo)的地址，因此当 foo 函数执行完成并销毁，name 值仍然存在堆的 closure(foo)的对象中，具体如下图所示：\n\n\n作者：chicABoo链接：https://juejin.cn/post/7023259995219165214来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n闭包是如何回收的\n如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭。但如果这个变量之后不在使用，就会造成内存泄露\n如果引用闭包的函数是一个局部变量，等函数销毁后，在下一次执行垃圾回收时，判断闭包这块内容不再使用，那么 JavaScript 引擎的垃圾回收器就会回收这块内容\n\n闭包使用原则\n如果该闭包会一直使用，那么它可以作为全局变量而存在；\n但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用\n\n总结\n作用域链：每个执行上下文都有一个指向外部的 outer，这个指向外部的引用 outer 在编译时就决定了，也就是说，根据声明的位置就能确定外部引用 outer，这就是词法作用域（静态作用域），它能预测代码执行过程中如何查找标识。通过它就能确定作用域链。\n闭包：外部函数声明的变量，在内部函数中调用，当调用外部函数返回内部函数时，外部函数中声明的变量并不会随着外部函数执行完成而销毁，这些变量构成的集合就是外部函数的闭包。\n栈和堆空间：基本数据类型是存在栈空间中的，引用数据类型是存在堆空间中的。当形成闭包时，外部函数声明的变量存放在调用栈中，对于外部函数中的变量被内部函数所使用，在堆中就会创建一个 closure(函数名)的对象，用于存放闭包的变量集合，而外部函数中存的只是堆中的地址。所以说，当外部函数执行完成销毁时，JavaScript 引擎并不会回收堆中的地址。\n正确使用闭包：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用。\n\n作者：chicABoo链接：https://juejin.cn/post/7023259995219165214来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n什么是作用域？通俗点来讲就是：指变量的可使用范围\n一般有三种作用域：全局作用域、函数作用域、块级作用域\n\n全局作用域：声明的变量，全局可见\n函数作用域：声明的变量在当前函数内部可见\n块级作用域：{},条件语句，循环语句中\n\n原型与原型链原型（prototype）是 JavaScript 中的一个重要概念，用于实现继承和共享属性。每个 JavaScript 对象都有一个原型对象，即通过 constructor 构造函数创建该对象的模板对象。可以通过对象的 __proto__ 属性来访问该对象的原型对象。\n原型链（prototype chain）是由一系列原型对象组成的链式结构。每个对象都有一个指向其原型对象的指针，即 __proto__ 属性。当访问对象的某个属性时，如果该对象本身没有该属性，则会沿着原型链向上查找，直到找到该属性或者到达原型链的末端（Object.prototype）。如果一直找不到该属性，则返回 undefined。\n下面是一个例子，用于说明原型与原型链的概念：\n&#x2F;&#x2F; 定义一个构造函数 Person\nfunction Person(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 给 Person 的原型对象添加方法 sayHello\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;.&#96;);\n&#125;;\n\n&#x2F;&#x2F; 创建一个 Person 对象\nconst person &#x3D; new Person(&#39;Alice&#39;, 18);\n\n&#x2F;&#x2F; 访问 person 的属性和方法\nconsole.log(person.name); &#x2F;&#x2F; &quot;Alice&quot;\nconsole.log(person.age); &#x2F;&#x2F; 18\nperson.sayHello(); &#x2F;&#x2F; &quot;Hello, my name is Alice.&quot;\n\n&#x2F;&#x2F; 查看 person 的原型对象\nconsole.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true\nconsole.log(Person.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true\nconsole.log(Object.prototype.__proto__); &#x2F;&#x2F; null\n\n在上面的例子中，Person 是一个构造函数，它的原型对象（即 Person.prototype）定义了一个方法 sayHello。通过 new 操作符创建一个 Person 对象时，JavaScript 引擎会将该对象的原型指向 Person.prototype，从而实现了继承和共享属性。在访问 person 的属性和方法时，JavaScript 引擎会先查找该对象本身是否有该属性或方法，如果没有，则沿着原型链向上查找，直到找到为止。\n\nDetails\n原型\n什么是原型\n在 js 面向对象编程的实现 中, 原型是一个 prototype 对象，用于表示类型之间的关系。每一个对象都与另一个对象相关联，那个关联的对象就称为原型\n为什么使用原型\n\n原型对象的用途： 是为每个实例对象 “存储” 共享的方法和属性，它仅仅是一个普通对象而已。\n所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。\n\n原型分类\n显示原型和隐式原型\n\n显示原型： prototype 关键字标识\n隐式原型： __proto__表示\n一个构造函数显示原型 &#x3D;&#x3D;&#x3D; 该构造函数一个实例的隐式原型 即： （构造函数.prototype &#x3D;&#x3D;&#x3D; 构造函数实例.__proto__）\n\n什么是原型链\n\n每个实例对象的__proto__​ 属性, 指向它的构造函数的原型对象（prototype）。\n该原型对象也有一个自己的原型对象（__proto__​），层层向上直到一个对象的原型对象为 null​。\n根据定义，null​ 没有原型，并作为这个原型链中的最后一个环节\n\n简单来说，原型链是： 一个对象 找原型对象 的依据\n见原型链\n\n\n创建对象的几种方式\n对象字面量\n构造函数\nnew 关键字\nObject.create\nclass\n\n继承，原型链当谈到继承时，JavaScript 只有一种结构：对象。\n每个实例对象（object）都有一个私有属性（称之为 __proto__）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节\n继承属性JavaScript 对象是动态的属性“包”（指其自己的属性）。\n\nJavaScript 对象有一个指向一个原型对象的链。\n当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾\n\n继承方法函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）\nvar o &#x3D; &#123;\n  a: 2,\n  m: function () &#123;\n    return this.a + 1;\n  &#125;,\n&#125;;\n\nconsole.log(o.m()); &#x2F;&#x2F; 3\n&#x2F;&#x2F; 当调用 o.m 时，&#39;this&#39; 指向了 o.\n\nvar p &#x3D; Object.create(o);\n&#x2F;&#x2F; p 是一个继承自 o 的对象\n\np.a &#x3D; 4; &#x2F;&#x2F; 创建 p 的自身属性 &#39;a&#39;\nconsole.log(p.m()); &#x2F;&#x2F; 5 &#x2F;&#x2F; 属性屏蔽\n&#x2F;&#x2F; 调用 p.m 时，&#39;this&#39; 指向了 p\n&#x2F;&#x2F; 又因为 p 继承了 o 的 m 函数\n&#x2F;&#x2F; 所以，此时的 &#39;this.a&#39; 即 p.a，就是 p 的自身属性 &#39;a&#39;\n\n使用语法结构创建的对象var o &#x3D; &#123; a: 1 &#125;;\n\n&#x2F;&#x2F; o 这个对象继承了 Object.prototype 上面的所有属性\n&#x2F;&#x2F; o 自身没有名为 hasOwnProperty 的属性\n&#x2F;&#x2F; hasOwnProperty 是 Object.prototype 的属性\n&#x2F;&#x2F; 因此 o 继承了 Object.prototype 的 hasOwnProperty\n&#x2F;&#x2F; Object.prototype 的原型为 null\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; o ---&gt; Object.prototype ---&gt; null\n\nvar a &#x3D; [&#39;yo&#39;, &#39;whadup&#39;, &#39;?&#39;];\n\n&#x2F;&#x2F; 数组都继承于 Array.prototype\n&#x2F;&#x2F; (Array.prototype 中包含 indexOf, forEach 等方法)\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null\n\nfunction f() &#123;\n  return 2;\n&#125;\n\n&#x2F;&#x2F; 函数都继承于 Function.prototype\n&#x2F;&#x2F; (Function.prototype 中包含 call, bind 等方法)\n&#x2F;&#x2F; 原型链如下：\n&#x2F;&#x2F; f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null\n\n使用构造器创建的对象在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。\nfunction Graph() &#123;\n  this.vertices &#x3D; [];\n  this.edges &#x3D; [];\n&#125;\n\nGraph.prototype &#x3D; &#123;\n  addVertex: function (v) &#123;\n    this.vertices.push(v);\n  &#125;,\n&#125;;\n\nvar g &#x3D; new Graph();\n&#x2F;&#x2F; g 是生成的对象，他的自身属性有 &#39;vertices&#39; 和 &#39;edges&#39;。\n&#x2F;&#x2F; 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。\n\n使用 Object.create 创建的对象ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：\nvar a &#x3D; &#123; a: 1 &#125;;\n&#x2F;&#x2F; a ---&gt; Object.prototype ---&gt; null\n\nvar b &#x3D; Object.create(a);\n&#x2F;&#x2F; b ---&gt; a ---&gt; Object.prototype ---&gt; null\nconsole.log(b.a); &#x2F;&#x2F; 1 (继承而来)\n\nvar c &#x3D; Object.create(b);\n&#x2F;&#x2F; c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null\n\nvar d &#x3D; Object.create(null);\n&#x2F;&#x2F; d ---&gt; null\nconsole.log(d.hasOwnProperty); &#x2F;&#x2F; undefined，因为 d 没有继承 Object.prototype\n\nNumber、Boolean 包装类型的原型链是怎样的？包装类型是构造函数 -&gt; 构造函数的原型是函数原型 -&gt; 对象的原型-&gt; null\n简单数据类型，为什么可以调用方法见\nvar s1 &#x3D; &#39;some text&#39;;\nvar s2 &#x3D; s1.substring(2); &#x2F;&#x2F;&#39;me text&#39;\n\n基本类型不是对象，因而从逻辑上讲他们不该有方法，其实为了让我们实现这种操作，后台已经完成了一系列的处理。\n第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台会完成如下处理：\n\n创建 String/Boolean/Number 类的一个实例。var s1=new String(&#39;some text&#39;);\n调用在实例上调用指定的方法。var s2=s1.substring(2);//&#39;me text&#39;\n销毁这个实例。s1=null\n\n引用类型与基本包装类型的主要区别就是对象的生存期：\n\n使用 new 操作符创建的引用类型的实例 ，在执行完离开当前作用域之前都一直保存在内存中。\n自动创建的基本包装类型的对象 ，只存在于代码执行的一瞬间，然后被立即销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。\n\ninstanceofinstanceof 运算符\n\n判断一个对象是否是另一个对象的实例\n用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n\n实例与构造函数之间的关系实例.__proto__ &#x3D;&#x3D;&#x3D; 该实例的构造函数.prototype\nES6 语法中的 class、extends 与 super 的原理见\nthis聊下 this 指向问题以下皆对普通函数而言，箭头函数可不是这么玩的\n为什要有 this简单来说：this,被放到作用域中， 为了简化代码\nthis 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。\nthis 是如何定义的简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的\n我们简单总结一下 this 的特点：\n\nthis 是在运行时绑定的，不是在编写时绑定\nthis 的绑定与函数的声明和位置没有任何关系\n函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。\n\n所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。\n简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\nthis 绑定规则\n判断函数调用时是否使用了 new，如果使用了 new 绑定，则 this 绑定的是新创建的对象。\n函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。\n函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。\n以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，4.1 在严格模式下，默认绑定的 this 是 undefined，4.2 非严格模式下绑定到全局对象。\n\n类声明和类表达式的主体都执行在严格模式下\n前端基础-class\n作者：小猪课堂链接：https://juejin.cn/post/7115390077353590792来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nthis 绑定的优先级&#x2F;&#x2F; 默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定\n\nnew 做了哪些事情\n创建一个空对象；\n将空对象的原型，指向于构造函数的原型；\n将空对象作为构造函数的上下文（改变 this 指向）；\n对有返回值的构造函数做判断处理\n\n&#x2F;&#x2F;定义构造函数\nfunction Fun(age, name) &#123;\n  this.age &#x3D; age;\n  this.name &#x3D; name;\n  return 1;\n&#125;\n\nfunction myNew(fn, ...args) &#123;\n  &#x2F;&#x2F;1、先创造空对象\n  &#x2F;&#x2F;其实等于var obj &#x3D; Object.create(&#123;&#125;)\n  var obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F;2、obj的__proto__指向原型\n  Object.setPrototypeOf(obj, fn.prototype);\n  &#x2F;&#x2F;3、改变this指向，执行构造函数内部函数\n  var result &#x3D; fn.apply(obj, args);\n  &#x2F;&#x2F;4、判断return\n  return result instanceof Object ? result : obj;\n&#125;\n\n见\nObject.create()function myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;\n\nObject.create 与 new 的区别&#x2F;&#x2F; new Object() 方式创建\nvar obj &#x3D; &#123; name: &#39;jack&#39; &#125;;\nvar b &#x3D; new Object(obj);\nconsole.log(b.name);\nconsole.log(b.__proto__.name); &#x2F;&#x2F;undefined\n\n&#x2F;&#x2F; Object.create() 方式创建\nvar obj2 &#x3D; &#123; name: &#39;apple&#39; &#125;;\nvar c &#x3D; Object.create(obj2);\nconsole.log(c.name);\nconsole.log(c.__proto__.name); &#x2F;&#x2F;apple\n\nnew 出来的 b 对象，通过原型链无法访问到 name 属性，而 Object.create 出来的 c 却可以\n箭头函数与普通函数区别\n声明具名箭头函数可以用 var let const , 普通函数除这些之外还可用 function 关键字\n\n使用简单：箭头函数使用起来简单，更适合匿名函数; 比较特殊的对象方法，可以简写()&#123;&#125;,这个不是箭头函数\n\n立即执行 普通函数可以声明立即执行函数，箭头函数也可void (()=&gt; &#123;console.log(1)&#125;)()\n\n运算上 在使用短路运算符的时候，箭头函数要用()括起来，否则因解析顺序导致错误\n\n拥有 箭头函数没有自己的 this， prototype，arguments, super, new.target,\n\n基于此：箭头函数不适用于构造函数、new、yeild 等场合\n\n在 apply,call,bind 中第一个参数会被忽略\n\n箭头函数没有 arguments，可以使用…rest, （这里有个注意的点：普通函数 arguments，在非严格模式下，有默认参数、剩余参数和结构赋值的情况会出现： arguments 与形参不一致的情况）\n\n\n事件循环背景：js 是单线程的，同一时间 dom 的操作不允许并行\n出现的原因：单线程，如果出现耗时的情况会一直等待，以浏览器为例： 浏览器分为 5 大线程，定时器线程和网络线程\n解决了什么问题：在单线程中，可以跳过一些耗时的操作，先去做其他的事情，待到需要执行的时候，再执行，而这一策略被称为 事件循环\n执行过程： 宿主环境：以浏览器环境来说\n\n在 javascript 中，将任务放到执行栈中执行，执行完成的会出栈；未执行的会依次压入栈底，\n先执行同步任务（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部），直至同步任务都被执行完\n然后执行微任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）直至微任务队列都被执行完\n然后执行宏任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）\n会再去检测微任务队列，之后，再以相同的方式去执行宏任务队列\n\n闭包类 class单例模式通过构造函数class Singleton &#123;\n  constructor() &#123;\n    console.log(&#39;this&#39;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n通过静态方法class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n为什么类名上可以直接添加属性在 JavaScript 中，类是一种特殊的对象，可以像普通对象一样添加属性和方法。类名本身也是一个对象，可以直接添加静态属性和方法。如果要添加实例属性和方法，应该在类的构造函数中添加。\n\n更多内容\n在 JavaScript 中，类是一种特殊的对象，可以像普通对象一样添加属性和方法。当我们定义一个类时，实际上是在定义一个函数，该函数会被用作构造函数，用于创建类的实例对象。在类的定义中，我们可以通过类名来访问类本身，这个类本身也是一个对象，可以直接添加属性和方法。\n举个例子，假设我们定义了一个名为 Person 的类，可以通过下面的代码为这个类添加一个静态属性 type：\nclass Person &#123;\n  static type &#x3D; &#39;human&#39;;\n  &#x2F;&#x2F; ...\n&#125;\nconsole.log(Person.type); &#x2F;&#x2F; &#39;human&#39;\n\n在这个例子中，我们通过 static 关键字为 Person 类添加了一个静态属性 type。这个属性是通过类名直接访问的，而不是通过类的实例对象访问的。当我们调用 console.log(Person.type) 时，会输出 &#39;human&#39;，因为类名 Person 本身也是一个对象，可以直接添加属性和方法。\n需要注意的是，如果要在类中添加实例属性和方法，应该在类的构造函数中添加，而不是在类名上添加。例如：\nclass Person &#123;\n  constructor(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n  &#125;\n  sayHello() &#123;\n    console.log(&#96;Hello, my name is $&#123;this.name&#125;.&#96;);\n  &#125;\n&#125;\n\nconst person &#x3D; new Person(&#39;Alice&#39;, 18);\nconsole.log(person.name); &#x2F;&#x2F; &#39;Alice&#39;\nconsole.log(person.age); &#x2F;&#x2F; 18\nperson.sayHello(); &#x2F;&#x2F; &#39;Hello, my name is Alice.&#39;\n\n在这个例子中，我们在 Person 类的构造函数中添加了两个实例属性 name 和 age，以及一个实例方法 sayHello。在创建 Person 对象时，这些属性和方法会被添加到实例对象中，可以通过实例对象访问。\n\n\n类是特殊的对象，哪里特殊了？类是一种特殊的对象，它具有一些特殊的行为和属性：\n\n类可以使用 class 关键字定义，而对象不能。\n类可以用 new 关键字创建实例对象，而对象不能。\n类的属性和方法都是在原型对象上定义的，而对象的属性和方法都是直接在对象上定义的。\n类可以拥有静态属性和方法，这些属性和方法不需要通过类的实例对象访问，而对象只能拥有实例属性和方法。\n类定义的方法都是不可枚举的，而对象的方法默认是可枚举的。\n类的构造函数是特殊的方法，它在创建实例对象时自动调用，而对象没有构造函数。\n\n因此，类是一种特殊的对象，具有一些只有类才有的行为和属性。\n编程方法论见\n\n### 特点\n\n函数式编程有些重要的概念：\n\n1. `纯函数`： 给定相同的输入，总是得到相同的输出，没有副作用\n2. `函数组合`：将两个或两个以上的函数组合起来以产生一个新函数或进行某种计算的过程\n3. `避免状态共享`：共享作用域中存在的任何变量、对象或内存空间，或者是在作用域之间传递的对象的属性。共享作用域可以包括全局作用域或闭包作用域。通常，在面向对象编程中，通过向其他对象添加属性，在作用域之间共享对象。\n4. `避免可变数据`： 不可变对象是指创建后不能修改的对象。相反，可变对象是在创建后可以修改的对象， 可以通过：Object.freeze 进行冻结\n5. `避免副作用`：副作用是指：除了返回值之外，任何应用程序状态的改变都是可以在被调用函数之外观察到的\n\n见 -->\n\n什么是函数式编程\n函数式编程是一种编程范式，\n它的核心思想是将计算过程，视为函数应用的连续组合，避免使用可变状态和数据，强调函数的纯粹性和不可变性。\n在函数式编程中，函数是一等公民，可以作为参数传递给其他函数，也可以作为返回值返回。\n函数式编程中的函数通常都是无副作用的，即函数执行不会对外部环境产生任何影响。\n\n函数式编程可以带来很多好处，例如：\n\n简化代码：函数式编程可以用更少的代码实现同样的功能，因为函数可以复用和组合。\n易于测试：由于函数式编程中的函数是无副作用的，所以可以很容易地编写测试用例。\n可读性高：函数式编程代码通常比较简洁，容易阅读和理解。\n易于并发：由于函数式编程中的函数没有副作用，所以可以很容易地并发执行。\n\n在 JavaScript 中，函数式编程可以使用函数的高阶特性、柯里化、纯函数、不可变性等特性实现。\n什么是面向对象编程\n面向对象编程（Object-Oriented Programming，简称 OOP）是一种编程范式，\n它的核心思想是将数据和操作数据的方法（函数）作为一个整体，通过封装、继承和多态等机制来组织代码和数据，以实现更高的抽象和重用性。\n\n在面向对象编程中，一个程序由多个对象组成，每个对象包含数据和对数据进行操作的方法。对象之间可以通过消息传递来进行通信，从而实现协作和交互。\n面向对象编程有很多优点，例如：\n\n简化代码：通过封装机制，可以将数据和行为打包在一起，从而简化代码实现和维护。\n提高可靠性：通过封装机制，可以将内部细节隐藏起来，减少代码中的错误和不必要的干扰。\n易于扩展：通过继承和多态机制，可以在不影响原有代码的情况下扩展功能和适应需求变化。\n代码重用：通过继承和多态机制，可以在不重复编写代码的情况下实现功能扩展和模块化。\n易于理解：通过面向对象的抽象和封装，可以将复杂问题分解为简单的对象和方法，使代码更易于理解和维护。\n\n在 JavaScript 中，面向对象编程可以通过对象、构造函数、原型、继承等机制实现。\n什么是面向过程编程\n面向过程编程（Procedural Programming）是一种基于过程的编程范式，\n它的核心思想是通过定义一系列的函数（过程），将程序分解为一系列的步骤，然后按照步骤顺序执行这些函数来完成任务。\n\n在面向过程编程中，程序的执行是从上到下、从头到尾依次执行的，没有对象、类、继承等概念。程序员需要手动管理变量的生命周期、函数的调用关系等问题，这会导致程序难以扩展和维护。\n面向过程编程适用于一些简单的问题和小型项目，它的优点是代码简单、运行速度快，缺点是难以扩展和维护，可读性较差。\n与面向过程编程相对应的是面向对象编程，面向对象编程将程序分解为一些对象，并通过封装、继承、多态等机制来组织代码和数据，具有更好的可扩展性和可维护性。\nCICD 的自动化流水线，是面向过程编程？CICD 的自动化流水线不是面向过程编程，而是面向工具和流程的编程范式。CICD 流水线是一个工具链，可以自动化执行一系列任务，例如代码构建、测试、打包、部署等，以实现软件的快速、高质量发布。CICD 流水线通常使用脚本编写，包括构建脚本、测试脚本、部署脚本等，这些脚本通常使用一些特定的工具和语言编写，例如 Jenkins、Gitlab CI、Travis CI、Python 等。\nCICD 流水线的设计和实现需要考虑很多方面，包括流程规划、工具选择、脚本编写等，需要综合考虑工具的可用性、可扩展性、易用性等方面，因此更加关注工具链和流程的设计，而不是程序的具体实现。因此，CICD 的自动化流水线不是面向过程编程，而是面向工具和流程的编程范式。\ntypescripttypescript 中 type 与 interface 的区别TypeScript 中 type 和 interface 都用于定义类型，但它们的用法和语法略有不同。以下是它们的主要区别：\n\ntype 可以定义基本类型、联合类型、交叉类型和元组类型，而 interface 只能定义对象类型。\n\ntype 可以使用 extends 关键字来继承另一个类型或联合另一个类型，而 interface 只能通过继承其他接口来扩展自己的成员。\n\ninterface 可以声明合并，即多个同名接口可以自动合并为一个接口，而 type 不支持这种合并。\n\n\n以下是 type 和 interface 的使用示例：\n&#x2F;&#x2F; 使用 type 定义类型\ntype Name &#x3D; string;\ntype Age &#x3D; number;\n\ntype Person &#x3D; &#123;\n  name: Name;\n  age: Age;\n&#125;;\n\ntype PersonOrUndefined &#x3D; Person | undefined;\n\n&#x2F;&#x2F; 使用 interface 定义类型\ninterface User &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface Employee extends User &#123;\n  jobTitle: string;\n&#125;\n\ninterface User &#123;\n  email: string;\n&#125;\n\n&#x2F;&#x2F; User 接口会被自动合并为包含 name、age 和 email 三个属性的接口\n\n总的来说，type 和 interface 都有自己的用途和优势，开发者可以根据实际需求选择使用哪种方式来定义类型。\n\n定义元组类型\n在 TypeScript 中，可以使用元组类型来表示固定长度和固定类型的数组。元组类型使用方括号 [] 来定义，其中方括号中按顺序列出了每个元素的类型。\n以下是一个示例，其中定义了一个元组类型 Person，包含了一个字符串类型的姓名和一个数字类型的年龄：\ntype Person &#x3D; [string, number];\n\n&#x2F;&#x2F; 定义一个元组变量，按顺序依次是姓名和年龄\nconst john: Person &#x3D; [&#39;John&#39;, 30];\nconst mary: Person &#x3D; [&#39;Mary&#39;, 25];\n\n&#x2F;&#x2F; 错误示例，元素数量必须匹配\nconst jane: Person &#x3D; [&#39;Jane&#39;]; &#x2F;&#x2F; 缺少年龄\nconst tom: Person &#x3D; [40, &#39;Tom&#39;]; &#x2F;&#x2F; 类型不匹配\n\n需要注意的是，元组类型的长度是固定的，一旦定义后就不能再增加或减少元素的个数。在使用元组类型时，需要确保每个元素的类型和顺序都是正确的，否则会导致类型错误。\n\n\n\n废弃\n描述上：1. 都可以描述一个对象或者函数\n&#x2F;&#x2F; interface\ninterface User &#123;\n  name: string\n  age: number\n&#125;\n\ninterface SetUser &#123;\n  (name: string, age: number): void;\n&#125;\n\n&#x2F;&#x2F; type\n\ntype User &#x3D; &#123;\n  name: string\n  age: number\n&#125;;\n\ntype SetUser &#x3D; (name: string, age: number)&#x3D;&gt; void;\n\n\n扩展上： 2. 都允许拓展（extends\ninterface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。\n&#x2F;&#x2F; interface extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ninterface User extends Name &#123;\n  age: number;\n&#125;\n\n&#x2F;&#x2F; type extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ntype User &#x3D; Name &amp; &#123; age: number &#125;;\n\n&#x2F;&#x2F; interface extends type\ntype Name &#x3D; &#123;\n  name: string;\n&#125;;\ninterface User extends Name &#123;\n  age: number;\n&#125;\n\n&#x2F;&#x2F; type extends interface\ninterface Name &#123;\n  name: string;\n&#125;\ntype User &#x3D; Name &amp; &#123;\n  age: number;\n&#125;;\n\n不同点\n\ntype 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)\n\n&#x2F;&#x2F; 基本类型别名\ntype Name &#x3D; string;\n\n&#x2F;&#x2F; 联合类型\ninterface Dog &#123;\n  wong();\n&#125;\ninterface Cat &#123;\n  miao();\n&#125;\n\ntype Pet &#x3D; Dog | Cat;\n\n&#x2F;&#x2F; 具体定义数组每个位置的类型\ntype PetList &#x3D; [Dog, Pet];\n\n\ntype 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)\n\n&#x2F;&#x2F; 当你想获取一个变量的类型时，使用 typeof\nlet div &#x3D; document.createElement(&#39;div&#39;);\ntype B &#x3D; typeof div;\n\n其他骚操作\ntype StringOrNumber &#x3D; string | number;\ntype Text &#x3D; string | &#123; text: string &#125;;\ntype NameLookup &#x3D; Dictionary&lt;string, Person&gt;;\ntype Callback&lt;T&gt; &#x3D; (data: T) &#x3D;&gt; void;\ntype Pair&lt;T&gt; &#x3D; [T, T];\ntype Coordinates &#x3D; Pair&lt;number&gt;;\ntype Tree&lt;T&gt; &#x3D; T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;\n\n\ninterface 能够声明合并(type 不行)\ninterface User &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface User &#123;\n  sex: string;\n&#125;\n\n&#x2F;*\nUser 接口为 &#123;\n  name: string\n  age: number\n  sex: string\n&#125;\n*&#x2F;\n\n\n\nTypescript 中 extends 的作用1、接口继承可以继承父类接口的方法和属性\ninterface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; dog 具有 Animal 的 name 属性。\nconst dog: Dog &#x3D; &#123;\n  name: &#39;tom&#39;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\n2、普通条件判断 表示 能够分配用来判断一个类型是否可以分配给另外一个类型\nA extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。\ninterface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n\nconst dog: Dog &#x3D; &#123;\n  name: &#39;tom&#39;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\ntype bool &#x3D; Animal extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;\ntype bool1 &#x3D; Dog extends Animal ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;\n\n3、泛型条件判断对于使用 extends 关键字的条件类型，如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。\n分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。\n满足两个要点即可适用分配律：\n参数是泛型类型，\n代入参数的是联合类型在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。\ntype Animal&lt;T&gt; &#x3D; T;\ntype Animal1&lt;T&gt; &#x3D; [T];\ntype Dog &#x3D; Animal&lt;&#39;x&#39; | &#39;y&#39;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;\ntype Dog1 &#x3D; Animal1&lt;&#39;x&#39; | &#39;y&#39;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]\n\ntype A &#x3D; &#39;x&#39; extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;\ntype B &#x3D; &#39;x&#39; extends Dog1 ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;\ntype C &#x3D; [&#39;x&#39; | &#39;y&#39;] extends Dog1 ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;\ntype D &#x3D; &#39;x&#39; | &#39;y&#39; extends Dog ? &#39;yes&#39; : &#39;no&#39;; &#x2F;&#x2F; D &#x3D; &#39;yes&#39;\n\n4、泛型约束在书写泛型时，往往需要对类型参数作一定对限制。\nfunction getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;\n  return obj[key];\n&#125;\n\nconst obj &#x3D; &#123;\n  name: &#39;tom&#39;,\n  age: 12,\n&#125;;\n\ngetInfo(obj, &#39;age&#39;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。\n\n5. ES6 类继承什么是联合类型联合类型在 TypeScript 中非常有用，可以让我们更加灵活地定义类型，处理多种类型的数据，提高代码的可重用性和可扩展性。但是在使用联合类型时需要注意，如果一个变量或参数的类型是联合类型，那么它只能使用所有类型中的公共属性和方法，不能使用特定类型的属性和方法。因此，在编写代码时需要谨慎使用联合类型，避免出现类型错误\n什么是交叉类型在 TypeScript 中，交叉类型是一种将多个类型合并为一个类型的方式。交叉类型使用 &amp; 运算符来连接多个类型，表示同时具有这些类型的特征。例如：\ninterface A &#123;\n  name: string;\n&#125;\n\ninterface B &#123;\n  age: number;\n&#125;\n\ntype C &#x3D; A &amp; B;\n\nconst person: C &#x3D; &#123; name: &#39;Tom&#39;, age: 18 &#125;;\n\n在上面的示例中，我们定义了两个接口 A 和 B，分别具有 name 和 age 属性。然后，我们使用 &amp; 运算符将它们合并为一个新的类型 C，表示具有 name 和 age 属性的类型。最后，我们创建了一个类型为 C 的对象 person，它具有 name 和 age 属性。\n交叉类型可以让我们更加灵活地组合不同类型的特征，从而创建出更加复杂的类型。例如，我们可以将一个类型 A 和一个类型 B 合并为一个新类型 C，表示同时具有 A 和 B 的特征。然后，我们可以将类型 C 用于函数参数、变量类型等场景中，从而使程序更加灵活和健壮。\n需要注意的是，交叉类型只能表示同时具有多个类型的特征，而不能表示只具有某个类型的特征。如果需要表示某个类型的特征，可以使用联合类型。例如，如果一个变量可以是字符串类型或者数字类型，可以使用联合类型 string | number 表示。\n交叉类型与联合类型的区别\n交叉类型使用 &amp; 运算符合并多个类型，表示同时具有这些类型的特征，适用于将多个类型合并为一个类型的场景。\n联合类型使用 | 运算符连接多个类型，表示具有这些类型中至少一个类型的特征，适用于表示一个变量、参数、返回值等可以具有多种类型的场景。\n\nReact什么是 React\nReact 是一个用于构建用户界面的 JavaScript 库。\n它由 Facebook 开发并开源，现在已经成为了前端开发中最受欢迎的框架之一。\nReact 的主要思想是将 UI 拆分成可重用的组件，这些组件可以随时进行组合和嵌套，以构建复杂的用户界面。\nReact 使用虚拟 DOM（Virtual DOM）来实现高效的更新和渲染，通过仅更新实际更改的部分，避免了不必要的 DOM 操作和重新渲染整个页面的成本。\nReact 还具有单向数据流（One-Way Data Binding）的特性，使得组件的状态和行为更加可控和易于维护。\n总的来说，React 是一个强大而灵活的工具，可以帮助开发人员构建快速、高效和易于维护的现代 Web 应用程序。\n\n聊下 key为什么引入 keykey 帮助 React 识别出被修改、添加或删除的 item\n深入解析为什么 key 是必须的\n引入 key 的背景对子节点进行递归\n默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。\n在子元素列表末尾新增元素时，更新开销比较小。比如：\n&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n  &lt;li&gt;third&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact 会先匹配两个 &lt;li&gt;first&lt;/li&gt; 对应的树，然后匹配第二个元素 &lt;li&gt;second&lt;/li&gt; 对应的树，最后插入第三个元素的 &lt;li&gt;third&lt;/li&gt; 树。\n如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：\n&lt;ul&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact 并不会意识到应该保留 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt;，而是会重建每一个子元素。这种情况会带来性能问题。\nkey 解决这个问题为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：\n&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2014&quot;&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n\n现在 React 知道只有带着 ‘2014’ key 的元素是新元素，带着 ‘2015’ 以及 ‘2016’ key 的元素仅仅移动了。\n实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：\n&lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n\n当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。\nkey 有什么要求当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。\n通常情况 key 不会用 index原因：\n\n使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。\n\n由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，\n\n\n什么时候使用 key\n子元素列表时候需要用 key\n同级元素比如两个按钮，在使用三目运算符进行条件处理时候，也需要加 key，不加会出现，按钮事件被错误触发的现象，（这是由于 React 可中断渲染和合成事件共同作用引起的）\n\nkey 在源码单节点、多节点中的diff [单节点、多节点]hooks 产生的原因Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题\n在组件之间复用状态逻辑很难复杂组件变得难以理解在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。）\n难以理解的 class(除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。\n为了解决这些问题，\n\nHook 使你在非 class 的情况下可以使用更多的 React 特性。\n从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。\nHook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。\n\nuseEffect 执行特点1. useEffect 做了什么？(通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。)\n2. 为什么在组件内部调用 useEffect？(将 useEffect 放在组件内部,让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。)\n3. useEffect 会在每次渲染后都执行吗？(是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。)\n4. 传递给 useEffect 的函数在每次渲染中都会有所不同(经验丰富的 JavaScript 开发人员可能会注意到，传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。)\n5. effect 异步执行不需要同步地执行, 如果需要同步用 useLayoutEffect\n6. 为什么要在 effect 中返回一个函数？(这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。)\n7. React 何时清除 effect？(\n\nReact 会在组件卸载的时候执行清除操作。\n正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。)\n\nuseEffect 使用特点上？\n提示: 使用多个 Effect 实现关注点分离\n解释：为什么每次更新的时候都要运行 Effect(此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug。)\n提示: 通过跳过 Effect 进行性能优化（使用第二参数，未来版本，可能会在构建时自动添加第二个参数。）\n\nuseEffect 实现原理useEffect 是 React 提供的一个用于处理副作用的 Hook，它的实现原理可以大致分为以下两步：\n\n在组件渲染时，React 将 useEffect 中的回调函数加入到“副作用队列”中。这个副作用队列是一个全局的任务队列，存储了所有需要处理的副作用任务。\n\n在浏览器完成页面的渲染后，React 会开始处理副作用队列。React 会依次执行队列中的每个副作用任务，并将执行结果保存在内部的状态中。如果队列中有新的任务加入，React 会将新的任务加入队列的尾部，等待下一次处理。\n\n\n在 useEffect 的实现中，React 会使用一个链表数据结构来管理副作用队列，每个链表节点代表一个副作用任务。当组件卸载时，React 会遍历这个链表，将所有的副作用任务进行清理。\n需要注意的是，在函数式组件中，由于每次渲染都会创建新的函数作用域，所以 useEffect 中的回调函数也会被重新创建。因此，当使用 useEffect 时，应该确保回调函数中不会引用过期的变量，否则会导致意外的结果。为了避免这种问题，可以使用 useCallback 或 useMemo 来缓存函数。\nHook 使用规则Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：\n\n只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。\n只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。\n在自定义的 Hook 中\n\n生命周期\n挂载：constructor()、static getDerivedStateFromProps()、render()、componentDidMount()\n更新：static getDerivedStateFromProps()、shouldComponentUpdate()、render()、getSnapshotBeforeUpdate()、componentDidUpdate()\n错误处理：static getDerivedStateFromError()、componentDidCatch()\n卸载：componentWillUnmount()\n\nreact 生命周期函数：\n\nconstructor()：组件构造函数，在组件挂载之前调用；仅用于初始化内部 state 以及为事件处理函数绑定实例；\n\nstatic getDerivedStateFromProps()：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用，此方法适用于 state 的值在任何时候都取决于 props；\n\nrender()：是 class 组件中唯一必须实现的方法；\n\ncomponentDidMount：会在组件挂载后（插入 DOM 树中）立即调用；\n\nshouldComponentUpdate()：根据该函数的返回值，来确定组件是否重新渲染；\n\ngetSnapshotBeforeUpdate()：在最近一次渲染输出（提交到 DOM 节点）之前调用；此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()；\n\ncomponentDidUpdate()：会在更新后会被立即调用，首次渲染不会执行此方法；\n\ncomponentWillUnmount()：会在组件卸载及销毁之前直接调用；\n\nstatic getDerivedStateFromError()：此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state；它会在渲染阶段调用，因此不允许出现副作用\n\ncomponentDidCatch()：此生命周期在后代组件抛出错误后被调用，会在“提交”阶段被调用，因此允许执行副作用。\n\n\n父子组件生命周期函数执行顺序：父子组件生命周期函数执行顺序：\n类组件\n进入页面：\nparent-constructor -&gt;\nparent-getDerivedStateFromProps -&gt;\nparent-render -&gt;\n\nchild-constructor -&gt;\nchild-getDerivedStateFromProps -&gt;\nchild-render -&gt;\nchild-componentDidMount -&gt;\n\nparent-componentDidMount\n&#x2F;&#x2F; （子组件先挂载，父组件后挂载）\n\n更新页面：\nparent-getDerivedStateFromProps -&gt;\nparent-shouldComponentUpdate -&gt;\nparent-render -&gt;\n\nchild-getDerivedStateFromProps -&gt;\nchild-shouldComponentUpdate -&gt;\nchild-render -&gt;\nchild-componentDidUpdate -&gt;\n\nparent-componentDidUpdate\n&#x2F;&#x2F; （子组件先更新，父组件后更新）\n\n销毁页面：\nparent-componentWillUnmount -&gt;\nchild-componentWillUnmount\n\n&#x2F;&#x2F;（父组件先 willUnmount，子组件后 willlUnmount）\n\n见\n函数组件\n子组件先于父组件\n见\n严格模式 StrictMode\n环境： 严格模式检查仅在开发模式下运行；它们不会影响生产构建\n范围：它为其后代元素触发额外的检查和警告\n作用：突出显示应用程序中潜在问题的工具，不会渲染任何可见的 UI\n\n作用具体表现：\n\n识别不安全的生命周期（使用了第三方库，很难确保它们不使用这些生命周期方法）\n使用过时字符串 ref API、 context API\n使用废弃的 findDOMNode 方法的警告\n检测意外的副作用\n确保可复用状态（在未来，我们希望增加一个功能，允许 React 在保留 state 的同时对 UI 进行增删）\n\n协调当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。\n什么是“协调”\n是什么： 是 React 中一种用于更新视图的机制\n原理是： 协调算法采用了一种称为“双缓存技术”的方式\n执行过程：diff 启发式算法进行比较、构建虚拟 dom 树，进行更新\n收益：React 可以在避免大量 DOM 操作的同时，高效地更新视图\n\n“协调”（reconciliation）是 React 中一种用于更新视图的机制。它是 React 实现高效更新的核心算法，也是 React 的重要特性之一。\n在 React 中，当组件的状态（state）或属性（props）发生变化时，会触发重新渲染。在重新渲染之前，React 会先通过协调算法对新旧虚拟 DOM 树进行比较，找出需要更新的部分，然后才会重新渲染这些部分。\n协调算法采用了一种称为“双缓存技术”的方式，它会创建两个虚拟 DOM 树，一个是当前的虚拟 DOM 树，另一个是新的虚拟 DOM 树。当需要更新时，React 会先将新的虚拟 DOM 树与当前的虚拟 DOM 树进行比较，找出需要更新的部分，并在新的虚拟 DOM 树上进行修改。然后，React 会将新的虚拟 DOM 树渲染成真实的 DOM 树，并将其与当前的 DOM 树进行比较，找出需要更新的部分。最后，React 将需要更新的部分更新到浏览器中，完成一次渲染。\n通过协调算法，React 可以在避免大量 DOM 操作的同时，高效地更新视图。这也是 React 能够在大型应用程序中表现出色的原因之一。\nreact17 版本前后合成事件执行顺序有什么变化在 React 17 版本之前，合成事件和原生事件的执行顺序有所不同。具体来说，React 16 及以下版本中的事件处理过程如下：\n\n当一个合成事件和一个原生事件都绑定在同一个元素上时，React 会先调用组件上的事件处理函数，执行合成事件。\n\n如果在合成事件处理函数中调用了 event.stopPropagation() 方法阻止事件冒泡，那么原生事件不会被触发。\n\n如果合成事件处理函数执行完成后，没有调用 event.stopPropagation() 方法，则 React 会直接触发原生事件。\n\n原生事件系统按照事件冒泡的方式，从当前元素开始，逐级向上执行所有元素的事件处理函数，直到文档根节点。\n\n\nReact 17 版本中的事件处理过程有所改变。具体来说，React 17 中的事件处理过程如下：\n\n当一个合成事件和一个原生事件都绑定在同一个元素上时，React 会先调用组件上的事件处理函数，执行合成事件。\n\n如果在合成事件处理函数中调用了 event.stopPropagation() 方法阻止事件冒泡，那么原生事件也不会被触发。\n\n如果合成事件处理函数执行完成后，没有调用 event.stopPropagation() 方法，则 React 会将事件传递给原生事件系统，但是不会立即触发原生事件。\n\n当 React 完成整个更新过程后，会统一处理原生事件。在这个过程中，React 会按照事件冒泡的方式，从当前元素开始，逐级向上执行所有元素的事件处理函数，直到文档根节点。\n\n\n因此，React 17 中的事件处理过程更符合开发者的直觉，也更加安全和可靠。\n\n\n合成事件\n是什么\n为什么\n实现原理\n17 版本前后有什么区别\n\n合成事件的捕获和冒泡如何实现数组正反序遍历\n父子组件合成事件的捕获和冒泡执行顺序V17 之前，合成事件和原生事件的执行顺序与冒泡/捕获模式无关,\n原生事件恒早于合成事件\nV17 后，合成事件和原生事件的执行顺序与冒泡/捕获模式相关，\n\n捕获模式，合成事件早于原生事件。\n冒泡模式，原生事件早于合成事件，\nReact 17 将事件委托放在了 root 上而不是以前的 document 上\n\n&#x2F;&#x2F; V17.0.2 document 原生事件 &gt; 合成事件（父 -&gt; 子） &gt; 原生事件（父 -&gt; 子）\n&#x2F;&#x2F; 原生事件：document DOM 事件监听！\n&#x2F;&#x2F; React 事件：父元素事件监听！\n&#x2F;&#x2F; React 事件：子元素事件监听！\n&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！\n&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！\n\n&#x2F;&#x2F; V16.14.0 document 原生事件 &gt; 原生事件（父 -&gt; 子）&gt; 合成事件（父 -&gt; 子）\n&#x2F;&#x2F; 原生事件：document DOM 事件监听！\n&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！\n&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！\n&#x2F;&#x2F; React 事件：父元素事件监听！\n&#x2F;&#x2F; React 事件：子元素事件监听！\n\n作者：活抓一只小机灵链接：https://juejin.cn/post/7005129812981317668来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n合成事件在 React 中，合成事件是指在浏览器原生事件基础上封装出来的一种事件系统，React 在组件的根节点上注册事件监听器，然后将事件通过事件池（Event Pool）传递给组件，供组件内部使用。\n优点相比原生事件，合成事件具有如下优点：\n\n跨浏览器兼容性好：React 的合成事件系统可以跨浏览器兼容，无需考虑浏览器兼容性问题。\n\n性能更好：React 会在事件池中重复利用合成事件对象，避免了频繁创建和销毁事件对象的开销，从而提高了性能。\n\n更好的事件处理机制：React 的合成事件系统可以将事件处理函数中的 this 指向组件实例，避免了使用 bind 方法或箭头函数绑定 this 的麻烦。\n\n更好的事件委托机制：React 的合成事件系统可以方便地进行事件委托，将事件绑定在父组件上，从而避免了给每个子组件都绑定事件监听器的开销。\n\n\n注意事项需要注意的是，\n\n由于合成事件是在组件根节点上注册的，因此如果事件的目标元素被更新或卸载，而组件根节点没有被更新或卸载，那么事件处理函数可能会出现错误。\n为了避免这种情况，应该在组件卸载时，手动将组件的事件监听器从组件根节点上卸载。\n\n是什么？是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口。\n要使用浏览器的底层事件？需要使用 nativeEvent 属性来获取\n变化？从 v17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中。\n在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。\n事件委托的变更\nReact v17 中，React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中\n原因：经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。\n\n全新的 JSX 转换此时源代码无需引入 React 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）\n此变化与所有现有 JSX 代码兼容，所以你无需修改组件。如果你对此感兴趣，你可以查看 RFC 了解全新转换工作的具体细节。\n特点：\n\n新的 JSX 转换不依赖 React 环境\n\n优点：\n\n不需要引入 React 使用全新的转换，你可以单独使用 JSX 而无需引入 React。\n改善 bundle 根据你的配置，JSX 的编译输出可能会略微改善 bundle 的大小。\n以备未来之需 它将减少你需要学习 React 概念的数量，以备未来之需。\n\n副作用清理时间\nReact 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。\nReact 16 只对组件内的 effect 保证这种顺序。\n\nReact17 重大更改\n更改事件委托\n对标浏览器，对事件系统进行小改\n去除事件池 不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水 （因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。）\n副作用清理时间\n\nReact 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。\n\n\n\nReact 16 只对组件内的 effect 保证这种顺序。）\n\n\n\n\n返回一致的 undefined 错误，（算是改 bug 了，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错）\n原生组件栈 （生产环境提示更友好。\n在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。React 实现这一点的方式有点非常规 。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。\n因此，当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息 ）\n\n\n移除私有导出（与 react 关联不是很大的部分被移出）\n\nreact18 新特性\n修 bug\n\n由于并发模式可能带来破坏，所以 react18 的并发模式可选\nSuspense fallback=&#123;undefined&#125; 表现与null相同\n\n\n增加开发体验\n\n自动批处理: 之前需要使用 ReactDOM.unstable_batchedUpdates, 现在： 超时、promise、本机事件处理程序、任何其他事件被批处理\n内置 React.lazy + Suspense\nuseId: 生成唯一 ID\nuseTransition、useDeferredValue: 将紧急更新与非紧急更新分开\n2 个新的渲染api: createRoot 和 hydrateRoot ：应用的根节点也向我们暴露了出来，渲染整个应用的时候只需要调用 root 的 render 方法\n\n\n为其他框架库提供扩展\n\nuseInsertionEffect: 为 CSS-in-JS 库添加 见\nuseSyncExternalStore: 帮助外部存储库与 React 集成。 见\n\n\n为以后做准备\n\n严格模式模拟卸载和重新挂载\n\n\n\n错误处理componentDidCatchReact 的开发和生产构建版本在 componentDidCatch() 的方式上有轻微差别。\n\n在开发模式下，错误会冒泡至 window，这意味着任何 window.onerror 或 window.addEventListener(‘error’, callback) 会中断这些已经被 componentDidCatch() 捕获的错误。\n在生产模式下，错误不会冒泡\n\nstatic getDerivedStateFromError()\ngetDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。\n\nclass ErrorBoundary extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; hasError: false &#125;;\n  &#125;\n\n  static getDerivedStateFromError(error) &#123;\n    &#x2F;&#x2F; 更新 state 使下一次渲染可以显降级 UI\n    return &#123; hasError: true &#125;;\n  &#125;\n\n  render() &#123;\n    if (this.state.hasError) &#123;\n      &#x2F;&#x2F; 你可以渲染任何自定义的降级  UI\n      return &lt;h1&gt;Something went wrong.&lt;&#x2F;h1&gt;;\n    &#125;\n\n    return this.props.children;\n  &#125;\n&#125;\n\n使用 Redux 与不使用 Redux 有什么区别Redux 是一个状态管理库，它提供了一种规范化的方式来管理应用程序的状态。使用 Redux 和不使用 Redux 之间的区别在于应用程序的状态管理方式和应用程序的复杂度。\n\n状态管理方式：在没有 Redux 的情况下，应用程序的状态通常存储在组件的本地状态中，而且需要通过 props 将状态传递给子组件，这种方式通常称为“自上而下”（Top-down）的数据流。而使用 Redux，应用程序的状态存储在全局的 store 中，每个组件都可以访问 store 中的状态，这种方式称为“单向数据流”（Unidirectional data flow）。\n\n应用程序的复杂度：当应用程序的状态变得复杂时，使用 Redux 可以使应用程序更易于管理。Redux 提供了一种规范化的状态管理方式，可以使状态的变化更加可预测和可控，也方便了状态的调试和测试。而在简单的应用程序中，使用 Redux 可能会增加代码的复杂度和维护成本。\n\n开发效率：使用 Redux 可以提高开发效率，因为 Redux 提供了一些工具和中间件，可以方便地处理异步操作、路由和调试等问题。同时，使用 Redux 也可以使应用程序的代码更具可读性和可维护性。\n\n\n总之，使用 Redux 和不使用 Redux 之间的区别在于状态管理方式和应用程序的复杂度。Redux 可以使应用程序更易于管理和调试，提高开发效率，但在简单的应用程序中可能会增加代码的复杂度和维护成本。需要根据具体应用场景来选择是否使用 Redux。\nRedux 常用的中间件有哪些Redux 是一个状态管理库，它本身并没有提供异步处理、日志记录、路由等额外的功能，但是它提供了一个灵活的中间件（Middleware）机制，允许开发者在 Redux 的 Action 被发起之后，到达 Reducer 之前，对 Action 进行拦截、解释或者修改等处理。\n下面是一些常用的 Redux 中间件：\n\nRedux Thunk：Redux Thunk 是一个允许 Action Creator 返回函数的中间件，这样我们就可以在 Action Creator 内部执行异步操作（例如发送 AJAX 请求），并且在异步操作结束后再去派发真正的 Action。使用 Redux Thunk 可以简化异步 Action 的处理。\n\nRedux Saga：Redux Saga 是一个基于 Generator 的中间件，它提供了一种基于 ES6 Generator 的异步处理方式。使用 Redux Saga 可以将异步操作转化为同步的、可测试的代码，它使用简洁的语法和强大的控制流来处理异步操作。\n\nRedux Promise：Redux Promise 是一个允许 Action Creator 返回 Promise 的中间件，它将 Promise 解析成值，并将其作为 Action 发送到 Reducer。\n\nRedux Logger：Redux Logger 是一个记录 Redux Action 和状态变化的中间件，它可以帮助开发者更好地了解应用程序中发生的事情。\n\nRedux Immutable State Invariant：Redux Immutable State Invariant 是一个用于检测不可变状态（Immutable State）的中间件，它可以在开发过程中帮助开发者发现可能存在的状态变异问题。\n\nRedux-Thunk-Saga：Redux-Thunk-Saga 是一个结合了 Redux Thunk 和 Redux Saga 的中间件，它提供了一种同时支持同步和异步 Action 的处理方式。\n\n\n总之，Redux 中间件提供了一种简单、灵活的方式来扩展 Redux 功能，开发者可以根据需要选择适合自己的中间件。以上仅是一些常用的中间件，实际使用时还可以根据具体需求进行选择和扩展。\n如何简化 Action 和 Reducer 的定义使用 redux-actions: createAction、 createReducer、 handleActions\nredux-action 的动机： Redux 使数据存储突变变得可预测，但它也使它们变得冗长。这个工具是考虑到这一点而制作的。大量的样板可能会让编写和阅读变得痛苦。在动作创建者和简化器中跟踪动作字符串常量对初学者来说可能是压倒性的。redux-action 是 Redux 中符合 FSA 的动作的实用工具带。有了处理和创建动作的助手，每个人都可以更轻松地在 Redux 中使用 FSA\nRedux 提供了一些辅助函数来简化 Action 和 Reducer 的定义，下面介绍一些常用的函数：\n\ncreateAction: createAction是一个用于创建 Action Creator 的函数，它接收一个字符串类型的 Action 类型和一个处理函数，并返回一个 Action Creator。使用createAction函数可以简化 Action 的定义，同时可以使 Action Creator 具备可读性。\n\nimport &#123; createAction &#125; from &#39;redux-actions&#39;;\n\nconst increment &#x3D; createAction(&#39;INCREMENT&#39;, (value) &#x3D;&gt; (&#123; payload: value &#125;));\n\n&#x2F;&#x2F; 上面代码等价于\nconst increment &#x3D; (value) &#x3D;&gt; (&#123;\n  type: &#39;INCREMENT&#39;,\n  payload: value,\n&#125;);\n\n\ncreateReducer: createReducer是一个用于创建 Reducer 的函数，它接收一个初始状态和一组 Action 处理函数，返回一个 Reducer。使用createReducer函数可以简化 Reducer 的定义，同时可以使 Reducer 具备可读性。\n\nimport &#123; createReducer &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; createReducer(0, &#123;\n  INCREMENT: (state, action) &#x3D;&gt; state + action.payload,\n  DECREMENT: (state, action) &#x3D;&gt; state - action.payload,\n&#125;);\n\n&#x2F;&#x2F; 上面代码等价于\nconst counterReducer &#x3D; (state &#x3D; 0, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;INCREMENT&#39;:\n      return state + action.payload;\n    case &#39;DECREMENT&#39;:\n      return state - action.payload;\n    default:\n      return state;\n  &#125;\n&#125;;\n\n\nhandleActions: handleActions是一个用于创建 Reducer 的函数，它接收一个 Action 处理函数的对象和一个初始状态，返回一个 Reducer。使用handleActions函数可以简化 Reducer 的定义，同时可以使 Reducer 具备可读性。\n\nimport &#123; handleActions &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleActions(\n  &#123;\n    INCREMENT: (state, action) &#x3D;&gt; state + action.payload,\n    DECREMENT: (state, action) &#x3D;&gt; state - action.payload,\n  &#125;,\n  0\n);\n\n&#x2F;&#x2F; 上面代码等价于\nconst counterReducer &#x3D; (state &#x3D; 0, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;INCREMENT&#39;:\n      return state + action.payload;\n    case &#39;DECREMENT&#39;:\n      return state - action.payload;\n    default:\n      return state;\n  &#125;\n&#125;;\n\n通过使用 Redux 提供的辅助函数，我们可以简化 Action 和 Reducer 的定义，使其更具可读性和可维护性。同时，这些辅助函数还可以帮助我们避免一些常见的错误。\nredux-actions 有哪些 APIredux-actions 是一个用于简化 Redux Action 和 Reducer 定义的工具库，其提供了以下几个 API：\n\ncreateAction(type, payloadCreator, metaCreator): 一个用于创建 action creator 的工厂函数，接收一个 action 类型字符串以及一个 payloadCreator 函数和一个 metaCreator 函数（可选）。payloadCreator 和 metaCreator 函数都是可选的，但至少需要提供一个。\n\nimport &#123; createAction &#125; from &#39;redux-actions&#39;;\n\nconst increment &#x3D; createAction(&#39;INCREMENT&#39;, (value) &#x3D;&gt; (&#123; payload: value &#125;));\nconst decrement &#x3D; createAction(&#39;DECREMENT&#39;, (value) &#x3D;&gt; (&#123; payload: value &#125;));\n\n\ncreateActions(actionMap, ...identityActions): 一个用于创建多个 action creator 的工厂函数，接收一个 action 创建器对象和任意数量的 action 类型字符串，它将返回一个包含所有创建的 action creator 的对象。\n\nimport &#123; createActions &#125; from &#39;redux-actions&#39;;\n\nconst &#123; increment, decrement &#125; &#x3D; createActions(&#123;\n  INCREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n  DECREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n&#125;);\n\n&#x2F;&#x2F; 使用 identityActions 选项添加额外的 action creator\nconst &#123; increment, decrement, reset &#125; &#x3D; createActions(\n  &#123;\n    INCREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n    DECREMENT: (value) &#x3D;&gt; (&#123; payload: value &#125;),\n  &#125;,\n  &#39;RESET&#39;\n);\n\n\nhandleAction(type, reducer, initialState): 一个用于创建 reducer 的工厂函数，接收一个 action 类型字符串、一个 reducer 函数以及一个初始状态，它将返回一个 reducer 函数。\n\nimport &#123; handleAction &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleAction(&#39;INCREMENT&#39;, (state, action) &#x3D;&gt; state + action.payload, 0);\n\n\nhandleActions(reducerMap, initialState): 一个用于创建多个 reducer 的工厂函数，接收一个 reducer 函数对象和一个初始状态，它将返回一个 reducer 函数。\n\nimport &#123; handleActions &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleActions(\n  &#123;\n    INCREMENT: (state, action) &#x3D;&gt; state + action.payload,\n    DECREMENT: (state, action) &#x3D;&gt; state - action.payload,\n  &#125;,\n  0\n);\n\n\ncombineActions(...types): 一个用于将多个 action 类型字符串组合成一个字符串的函数，通常用于在 reducer 中处理多个 action。\n\nimport &#123; combineActions &#125; from &#39;redux-actions&#39;;\n\nconst counterReducer &#x3D; handleAction(combineActions(&#39;INCREMENT&#39;, &#39;DECREMENT&#39;), (state, action) &#x3D;&gt; state + action.payload, 0);\n\n除此之外，redux-actions 还提供了一些实用工具函数，例如：createSelector, createAsyncAction, createActionWithReducer, createCurriedAction 等。这些工具函数可以根据需要在项目中灵活使用。\nReact 与 Vue 的区别React 和 Vue 都是现代的 JavaScript 框架，用于构建用户界面。它们有很多相似的特性，例如组件化、虚拟 DOM 和响应式数据绑定，但也有\n一些重要的区别：\n数据绑定\n模版语法\n组件设计\n社区生态\n性能表现\n开发工具\n\n详细信息\n\n响应式数据绑定：\n\n在 Vue 中，数据绑定是双向的，意味着当数据发生变化时，视图也会相应地更新；而在 React 中，数据流是单向的，即数据的更改只能从父组件传递到子组件。\nReact 更强调单向数据流的思想，以及数据的不可变性，这有助于降低复杂度和提高性能。\n\n\n模板语法：\n\nVue 使用模板语法来描述界面，类似于 HTML，让开发人员可以直接看到界面结构；\n而 React 则使用 JSX 语法，将组件的结构、行为和样式都组合在一起，以更加灵活和自由的方式构建界面。\n\n\n组件设计：\n\nVue 的组件通常是一个组合了模板、样式和行为的单元，其中模板和逻辑部分的组合方式更为紧密；\n而 React 更注重组件的设计，以实现高度复用性和可测试性。React 的组件更像是一个纯粹的函数，接收 props 参数，然后渲染出对应的 UI。\n\n\n社区生态：\n\nVue 在国内拥有更为庞大和活跃的社区，支持中文文档和教程，更容易上手和学习；\n\n而 React 则更加国际化，其社区在全球范围内都很活跃，拥有更多的第三方库和插件，也更容易与其他技术栈集成。\n\n学习曲线：\n\nVue 在学习上相对于 React 更加容易，其文档和教程更加易于理解和上手。Vue 也更像传统的 MVVM 框架，对于从后端开发转型前端的开发人员来说更为友好。\n\n而 React 则需要更多的 JavaScript 知识和函数式编程思想的理解，需要一定的学习曲线。\n\n性能表现：\n\nReact 对于大型应用程序的性能表现更好，因为它使用了虚拟 DOM 技术，可以更快速地更新 UI。\n而 Vue 的性能表现在小型应用程序中较为优秀。\n\n\n开发者工具：Vue 开发者工具提供了比 React 更好的调试和排查工具，能够更好地帮助开发人员定位和解决问题。\n\n\n总之，React 和 Vue 都是优秀的前端框架，选择哪一个取决于具体项目需求、开发团队的技能水平和偏好等因素。在大型应用程序中，React 更为适用；而对于小型应用程序和快速原型开发，则更建议使用 Vue。\nReact 和 Vue 的实现原理有一些区别React使用虚拟DOM（Virtual DOM）实现高效的UI更新。每个 React 组件都有一个对应的虚拟 DOM 树，当组件的状态发生变化时，React 会重新生成虚拟 DOM 树，并比较前后两棵树的差异，然后只更新变化的部分，最后将变化的部分应用到真实 DOM 上。这种方式避免了频繁的 DOM 操作，提高了 UI 更新的效率。\nVue使用模板和响应式数据绑定来实现UI的更新。Vue 将数据绑定到视图上，当数据发生变化时，Vue 会自动更新视图。Vue 使用一个 Observer 来监听数据的变化，同时也使用了异步批量更新的机制，以最小化 DOM 操作次数，从而提高性能。\n另外，React 和 Vue 的组件化方式也略有不同。React 的组件通常是一个函数，输入一些参数，输出一个对应的 UI 组件。而 Vue 的组件则是一个对象，包含了模板、样式和行为等多个部分。React 更加强调单向数据流，组件间数据的传递一般都是从父组件到子组件。而 Vue 则支持双向数据绑定，可以让组件更加灵活。\n从原理上讲，Vue 和 React 哪个性能更好，为什么从原理上讲，React 的性能更好。主要原因是 React 使用了虚拟 DOM 技术。\n虚拟 DOM 是一种轻量级的、基于内存的、抽象的 DOM 表示方式。每个 React 组件都有一个对应的虚拟 DOM 树，当组件的状态发生变化时，React 会重新生成虚拟 DOM 树，并比较前后两棵树的差异，然后只更新变化的部分，最后将变化的部分应用到真实 DOM 上。这种方式避免了频繁的 DOM 操作，提高了 UI 更新的效率。\n相比之下，Vue 使用模板和响应式数据绑定来实现 UI 的更新。当数据发生变化时，Vue 会自动更新视图。Vue 的数据绑定机制相对于 React 的虚拟 DOM 机制更为简单，但是在大量数据和复杂的 UI 组件场景下，性能表现可能不如 React。\n当然，这并不是说 Vue 的性能不好，Vue 在小型应用程序中性能表现非常优秀。而在大型应用程序中，React 的虚拟 DOM 机制可以更快速地更新 UI，因此在性能方面更具优势。但是，性能的表现还受到很多因素的影响，如应用程序的复杂度、数据量、代码质量等，具体性能表现需要根据具体情况来评估。\ngitgit rebase 与 git merge\n\n\n命令\n缩写\n含义\n\n\n\npick\np\n保留该 commit\n\n\nreword\nr\n保留该 commit，但需要修改该 commit 的注释\n\n\nedit\ne\n保留该 commit , 但我要停下来修改该提交(不仅仅修改注释)\n\n\nsquash\ns\n将该 commit 合并到前一个 commit\n\n\nfixup\nf\n将该 commit 合并到前一个 commit，但不要保留该提交的注释信息\n\n\nexec\nx\n执行 shell 命令\n\n\ndrop\nd\n丢弃该 commit\n\n\n见\n\n\n\nmerge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）\nrebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，\n变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n变基原理：\n是首先找到这两个分支的最近共同祖先 C2\n然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3\n最后以此将之前另存为临时文件的修改依序应用\n\n小姐姐用动图展示 10 个 Git 命令\n什么时候用哪个？这本身存在分歧，主要看团队需要，\n\n如果团队需要历史记录保留，便于追踪，可以使用 merge ,\n如果不希望保留过多的过程，只关注结果那么可以用 rebase.无论用哪个，为了避免 rebase 的坑， 需要遵循以下原则：\n\n原则总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。\n$ git rebase --onto master server client\n\n你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\n见\n\ngit rebase -i HEAD~4\n# s 命令压缩\n\n\n\n\n\n见\n见\n🤔\n\n\n\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~3\nThe previous cherry-pick is now empty, possibly due to conflict resolution.\nIf you wish to commit it anyway, use:\n\n    git commit --allow-empty\n\nOtherwise, please use &#39;git reset&#39;\ninteractive rebase in progress; onto e1a52d3\nLast commands done (2 commands done):\n   pick 78c1fd9 应对github bug s 压缩\n   pick 8935665 应对github bug\nNext commands to do (4 remaining commands):\n   pick 421821a update\n   pick 4eff6a3 update\nYou are currently rebasing branch &#39;main&#39; on &#39;e1a52d3&#39;.\n\nnothing to commit, working tree clean\nCould not apply 8935665... 应对github bug\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~2\n\nIt seems that there is already a rebase-merge directory, and\nI wonder if you are in the middle of another rebase.  If that is the\ncase, please try\n        git rebase (--continue | --abort | --skip)\nIf that is not the case, please\n        rm -fr &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;.git&#x2F;rebase-merge&quot;\nand run me again.  I am stopping in case you still have something\nvaluable there.\n$ git rebase --abort\n\n掘金小猪课堂for…in 和 for…of 的区别\nfor…in 可以遍历对象和数组，for…of 不能遍历对象\nfor…in 循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键\nfor…in 遍历的索引为字符串类型\nfor..of 适用遍历数组&#x2F;字符串&#x2F;map&#x2F;set 等拥有迭代器对象的集合，但是不能遍历对象\nfor…of 与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句\n具有迭代器对象才可以使用 for…of\n\n作者：小猪课堂链接：https://juejin.cn/post/7002484014414037000来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nJavaScript 中可迭代对象\nString、Array、Set、Map\nNodeList、Arguments\n\n几种获取 URL 参数\n通过正则匹配的方式\n利用 split 方法分割法\n使用 URLSearchParams 方法\n利用 a 标签内置方法\n\n&#x2F;&#x2F; - 通过正则匹配的方式\n&#x2F;&#x2F; 利用正则表达式\nlet url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&#39;;\n&#x2F;&#x2F; &#x2F;&#x2F; 返回参数对象\nfunction queryURLParams(url) &#123;\n  let pattern &#x3D; &#x2F;(\\w+)&#x3D;(\\w+)&#x2F;gi; &#x2F;&#x2F;定义正则表达式\n  let parames &#x3D; &#123;&#125;; &#x2F;&#x2F; 定义参数对象\n  url.replace(pattern, ($, $1, $2) &#x3D;&gt; &#123;\n    parames[$1] &#x3D; $2;\n  &#125;);\n  return parames;\n&#125;\nconsole.log(queryURLParams(url));\n\n&#x2F;&#x2F; - 使用 URLSearchParams 方法\nlet URL &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&#39;;\nfunction queryURLParams(URL) &#123;\n  let url &#x3D; URL.split(&#39;?&#39;)[1];\n  const urlSearchParams &#x3D; new URLSearchParams(url);\n  const params &#x3D; Object.fromEntries(urlSearchParams.entries());\n  return params;\n&#125;\nconsole.log(queryURLParams(URL));\n\n&#x2F;&#x2F; 作者：小猪课堂\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7075305529903415304\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\nclientHeight、offsetHeight、scrollHeight 的区别三个属性虽然都很类似，但是每一个又有一些不一样的地方，总结起来就下面三点：\nclientHeight、offsetHeight和scrollHeight是 HTML 元素对象的属性，用于获取元素的高度。\n\nclientHeight属性用于获取元素的可视高度，即元素内容的高度加上内边距（padding）的高度，但不包括边框（border）和外边距（margin）的高度。\noffsetHeight属性用于获取元素在文档中的高度，包括元素的可视高度、内边距、边框和滚动条（如果存在）的高度，但不包括外边距的高度。\nscrollHeight属性用于获取元素的滚动高度，即元素的总高度，包括元素内容的高度、内边距、边框和任何溢出内容的高度（如果存在），但不包括外边距的高度。\n\n这些属性的值可能会受到 CSS 样式、文档流和父元素的影响，因此在使用时需要谨慎考虑它们的差异和适用场景。例如，\n\n当元素的内容溢出时，scrollHeight属性可以用于检测滚动条是否滚动到底部；\n而在计算元素的可见高度时，应该使用clientHeight属性。\n\nchildNodes 和 children 有什么区别？\n获取节点上: childNodes返回的是包含所有子节点的动态列表，包括元素节点、文本节点、注释节点等，而children返回的是包含所有子元素节点的静态集合。\n节点遍历：同时，childNodes支持索引访问每个子节点，而children则需要使用item()方法或类似数组的length属性和迭代器进行访问。\n兼容性：需要注意的是，children在某些浏览器版本中可能不被支持。\n\n\nDetails\nchildNodes和children都是 DOM 节点对象的属性，用于获取子节点。\n\nchildNodes属性用于获取所有子节点，包括文本节点、注释节点等，它返回的是一个包含所有子节点的列表（NodeList）对象。\nchildren属性用于获取所有子元素节点，不包括文本节点、注释节点等，它返回的是一个包含所有子元素节点的 HTML 集合（HTMLCollection）对象。\n\n因此，children属性仅返回元素节点，而childNodes属性返回所有类型的子节点。此外，它们还有以下区别：\n\nchildNodes属性返回的是一个动态的节点列表，即它会随着 DOM 结构的变化而变化；而children属性返回的是一个静态的 HTML 集合，即它不会随着 DOM 结构的变化而变化。\nchildNodes属性返回的是一个列表对象，可以使用索引访问每个子节点；而children属性返回的是一个 HTML 集合对象，不能使用索引访问每个子元素节点，只能使用item()方法或类似数组的length属性和迭代器访问。\n\n需要注意的是，children属性在 IE8 及以下版本中不支持，因此在编写跨浏览器的 JavaScript 代码时需要进行兼容性处理。\n\n\nAjaxAjax\n全称： Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。特点 局部刷新页面，无需重载整个页面。简单来说 Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。\nAjax 名字的由来“Ajax”这个词并非一个正式的缩写或首字母缩写，而是一个缩写词。它代表”Asynchronous JavaScript and XML”（异步 JavaScript 和 XML），是一种使用 JavaScript、XMLHttpRequest 对象和一些其他技术来创建异步 Web 应用程序的开发技术。\n在 2005 年的一篇名为”Ajax: A New Approach to Web Applications”的文章中，Jesse James Garrett 将这种技术称为 Ajax。这个名字的原因是，这种技术使用 JavaScript 和 XMLHttpRequest 对象在后台异步地向服务器发送请求和接收响应，从而可以实现无需刷新整个 Web 页面而更新部分内容的动态 Web 应用程序。Ajax 技术在 Web 开发中广泛应用，例如在实现无限滚动、搜索框提示、自动保存等功能上都有应用。\nXMLHttpRequest 示例&lt;script&gt;\n  function ajax(url) &#123;\n    &#x2F;&#x2F; 实例\n    const xhr &#x3D; new XMLHttpRequest();\n    &#x2F;&#x2F; 方法\n    xhr.open(&quot;get&quot;, url, false);\n    &#x2F;&#x2F; 监听\n    xhr.onreadystatechange &#x3D; function () &#123;\n      &#x2F;&#x2F; 异步回调函数\n      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;\n        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n          console.info(&quot;响应结果&quot;, xhr.response)\n        &#125;\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 发送\n    xhr.send(null);\n  &#125;\n\n  ajax(&#39;https:&#x2F;&#x2F;smallpig.site&#x2F;api&#x2F;category&#x2F;getCategory&#39;)\n&lt;&#x2F;script&gt;\n\nXMLHttpRequest 实例有哪些属性XMLHttpRequest 对象有以下一些常用的属性：\n\nreadyState：表示 XMLHttpRequest 对象的状态，具体取值为 0-4，分别对应 0: 未初始化、1: 已打开、2: 已发送、3:接收中、4：完成。\n\nresponseText：表示响应数据的文本内容，通常用于处理文本和 XML 数据。\n\nresponseXML：表示响应数据的 XML 文档对象，通常用于处理 XML 数据。\n\nstatus：表示响应状态码，通常用于判断请求是否成功。\n\nstatusText：表示响应状态码的文本描述。\n\ntimeout：表示 XMLHttpRequest 对象的超时时间，通常用于处理请求超时等情况。\n\nwithCredentials：表示 XMLHttpRequest 对象是否需要跨域访问凭证，通常用于处理跨域请求等情况。\n\n\n这些属性可以帮助我们对 HTTP 请求和响应进行更加精细化的控制和处理，从而提高应用程序的效率和可靠性。\nXMLHttpRequest 实例有哪些方法XMLHttpRequest 实例有以下一些常用的方法：\n\nopen(method, url, async)：初始化一个 HTTP 请求。参数 method 指定请求的方法（GET、POST 等），url 指定请求的 URL 地址，async 指定是否使用异步方式发送请求。\n\nsetRequestHeader(name, value)：设置 HTTP 请求头信息。参数 name 指定请求头的名称，value 指定请求头的值。\n\nsend(body)：发送 HTTP 请求。参数 body 指定请求的主体内容（在使用 POST 方法时会用到），如果不需要主体内容，则传递 null 即可。\n\nabort()：取消 HTTP 请求。\n\ngetAllResponseHeaders()：获取所有的 HTTP 响应头信息。\n\ngetResponseHeader(name)：获取指定的 HTTP 响应头信息。参数 name 指定响应头的名称。\n\noverrideMimeType(type)：覆盖 HTTP 响应的 MIME 类型。常用于解决一些浏览器不支持的 MIME 类型问题。\n\nsetResponseType(type)：设置 HTTP 响应的类型。常用于处理二进制数据或文本数据。\n\naddEventListener(event, listener, useCapture)：为 XMLHttpRequest 对象添加事件监听器。参数 event 指定事件类型（如 load、error 等），listener 指定事件处理函数，useCapture 指定事件是否使用捕获模式。\n\n\n这些方法可以帮助我们创建、发送和处理 HTTP 请求和响应，并且提供了很多的灵活性和可定制性，以满足各种不同的需求。\nXMLHttpRequest 有哪些事件XMLHttpRequest 对象有以下一些常用的事件：\n\nonreadystatechange：该事件在 XMLHttpRequest 对象的状态发生变化时触发，可以通过监听该事件实现异步请求。\n\nonload：该事件在 XMLHttpRequest 对象成功接收到完整的响应数据时触发，通常用于处理文本和 XML 数据。\n\nonerror：该事件在 XMLHttpRequest 对象遇到错误时触发，通常用于处理网络连接问题等异常情况。\n\nonabort：该事件在 XMLHttpRequest 对象被中止时触发，通常用于处理取消 HTTP 请求等情况。\n\nontimeout：该事件在 XMLHttpRequest 对象超时时触发，通常用于处理请求超时等情况。\n\n\n这些事件可以帮助我们对 HTTP 请求和响应进行更加精细化的控制和处理，从而提高应用程序的效率和可靠性。\nXMLHttpRequest open 方法中 async在 XMLHttpRequest 的 open()方法中，async 参数用于设置请求是否异步。当 async 为 true 时表示异步请求，当 async 为 false 时表示同步请求。默认情况下，async 为 true，即默认为异步请求。\n异步请求的好处在于不会阻塞 JavaScript 的执行，从而可以提高应用程序的响应速度和用户体验。当异步请求发送后，JavaScript 可以继续执行其他代码，等到服务器响应后再通过回调函数来处理响应结果。\n但是，异步请求也存在一些问题。比如，由于异步请求是异步执行的，所以无法保证请求的顺序性。同时，由于 JavaScript 和异步请求是并发执行的，所以需要特别注意并发问题，比如请求过多导致服务器繁忙或者响应数据不一致等。\n因此，在实际开发中，我们需要根据实际需求来选择是使用异步请求还是同步请求。通常情况下，我们会选择异步请求来提高应用程序的响应速度和用户体验，同时需要注意并发问题和请求顺序性。\nXMLHttpRequest 上传进度、下载进度XMLHttpRequest 对象提供了多个事件来监听 HTTP 请求的进度，其中包括上传进度和下载进度。这些事件包括：\n\nloadstart：当请求开始发送时触发。\nprogress：当请求正在发送或接收数据时，每隔一段时间触发一次，可以用来监听上传进度和下载进度。\nabort：当请求被终止时触发。\nerror：当请求出错时触发。\nload：当请求成功完成时触发。\ntimeout：当请求超时时触发。\nloadend：当请求完成（无论成功或失败）时触发。\n\n其中，可以使用 progress 事件来监听上传进度和下载进度。当进行文件上传时，可以使用 XMLHttpRequest 对象的 upload 属性来监听上传进度。示例如下：\nvar xhr &#x3D; new XMLHttpRequest();\nxhr.upload.addEventListener(\n  &#39;progress&#39;,\n  function (event) &#123;\n    if (event.lengthComputable) &#123;\n      var percentComplete &#x3D; event.loaded &#x2F; event.total;\n      console.log(percentComplete);\n    &#125;\n  &#125;,\n  false\n);\nxhr.open(&#39;POST&#39;, &#39;upload.php&#39;, true);\nxhr.send(formData);\n\n当进行文件下载时，可以使用 XMLHttpRequest 对象本身来监听下载进度。示例如下：\nvar xhr &#x3D; new XMLHttpRequest();\nxhr.addEventListener(\n  &#39;progress&#39;,\n  function (event) &#123;\n    if (event.lengthComputable) &#123;\n      var percentComplete &#x3D; event.loaded &#x2F; event.total;\n      console.log(percentComplete);\n    &#125;\n  &#125;,\n  false\n);\nxhr.open(&#39;GET&#39;, &#39;file.zip&#39;, true);\nxhr.responseType &#x3D; &#39;blob&#39;;\nxhr.send();\n\n在这两个示例中，我们使用了 XMLHttpRequest 对象的 addEventListener()方法来添加事件监听器。在 progress 事件中，我们可以通过 event.loaded 和 event.total 属性来获取已经下载或上传的数据量和总数据量，从而计算出当前的进度百分比。\nXMLHttpRequest 上传&#x2F;下载换种写法以下是使用 Promise 封装的示例：\nfunction downloadFile(url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest();\n    xhr.open(&#39;GET&#39;, url, true);\n    xhr.responseType &#x3D; &#39;blob&#39;;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        const blob &#x3D; new Blob([this.response]);\n        const fileName &#x3D; xhr.getResponseHeader(&#39;Content-Disposition&#39;).match(&#x2F;filename&#x3D;(.*)&#x2F;)[1];\n        const link &#x3D; document.createElement(&#39;a&#39;);\n        link.href &#x3D; window.URL.createObjectURL(blob);\n        link.download &#x3D; fileName;\n        link.click();\n        resolve();\n      &#125; else &#123;\n        reject(new Error(this.statusText));\n      &#125;\n    &#125;;\n    xhr.onerror &#x3D; function () &#123;\n      reject(new Error(&#39;XMLHttpRequest Error: &#39; + this.statusText));\n    &#125;;\n    xhr.onprogress &#x3D; function (event) &#123;\n      if (event.lengthComputable) &#123;\n        const percentComplete &#x3D; (event.loaded &#x2F; event.total) * 100;\n        console.log(&#39;Download progress: &#39; + percentComplete.toFixed(2) + &#39;%&#39;);\n      &#125;\n    &#125;;\n    xhr.send();\n  &#125;);\n&#125;\n\nfunction uploadFile(url, file) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest();\n    xhr.open(&#39;POST&#39;, url, true);\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve();\n      &#125; else &#123;\n        reject(new Error(this.statusText));\n      &#125;\n    &#125;;\n    xhr.onerror &#x3D; function () &#123;\n      reject(new Error(&#39;XMLHttpRequest Error: &#39; + this.statusText));\n    &#125;;\n    xhr.upload.onprogress &#x3D; function (event) &#123;\n      if (event.lengthComputable) &#123;\n        const percentComplete &#x3D; (event.loaded &#x2F; event.total) * 100;\n        console.log(&#39;Upload progress: &#39; + percentComplete.toFixed(2) + &#39;%&#39;);\n      &#125;\n    &#125;;\n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, file);\n    xhr.send(formData);\n  &#125;);\n&#125;\n\n使用 Promise 封装后，可以更加方便地处理异步操作，并且可以链式调用。\nFetch注意：不应该和 Ajax 做比较, 应该和 XMLHttpRequest做比较， Ajax 一个是思想，Fetch 一个是真实存在的 API\n特点\n\nFetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象\n内置的 API，使用上更简单\n使用 promise, 不使用回调\n数据流对象处理数据常用res.json()转化成json数据\n\nFetch 有哪些属性、方法、事件Fetch 是一个现代的 Web API，用于在 JavaScript 中进行网络请求。它提供了一组方法来完成基于网络的操作，包括获取和发送数据，可以用于替代早期的 XMLHttpRequest。\nFetch 的常用属性、方法、事件包括：\nFetch 方法\n\nfetch()：用于发起网络请求，并返回一个 Promise 对象。\nRequest()：用于创建一个请求对象，包括请求的 URL、请求方法、请求头等信息。\nHeaders()：用于创建请求头对象，包括设置请求头的名称和值。\nResponse()：用于创建响应对象，包括响应状态码、响应头、响应体等信息。\n\nFetch 属性\n\nHeaders.append()：用于向请求头中添加新的键值对。\nHeaders.delete()：用于从请求头中删除指定键名的键值对。\nHeaders.entries()：返回一个迭代器，用于迭代请求头中的键值对。\nHeaders.get()：用于获取指定键名的键值对。\nHeaders.has()：用于检查指定键名是否存在于请求头中。\nHeaders.keys()：返回一个迭代器，用于迭代请求头中的键名。\nHeaders.set()：用于设置请求头中指定键名的键值对。\nHeaders.values()：返回一个迭代器，用于迭代请求头中的键值。\n\nFetch 事件\n\nfetch：在发起网络请求后触发，表示请求已经被发送到服务器。\nabort：在请求被取消时触发。\nerror：在发生网络错误时触发。\nprogress：在上传或下载进度发生变化时触发。\n\nFetch 方法\n\nfetch()：用于发起网络请求，并返回一个 Promise 对象。\nRequest()：用于创建一个请求对象，包括请求的 URL、请求方法、请求头等信息。\nHeaders()：用于创建请求头对象，包括设置请求头的名称和值。\nResponse()：用于创建响应对象，包括响应状态码、响应头、响应体等信息。\n\nFetch 选项\n\nmethod：HTTP 请求方法，默认为 GET。\nheaders：请求头对象，可以使用 Headers 或者对象字面量创建。\nbody：请求体，可以是字符串、Blob 对象、FormData 对象等。\nmode：请求模式，决定请求跨域时使用的方式，有 cors、no-cors、same-origin 和 navigate。\ncache：请求缓存模式，有 default、no-store、reload、no-cache、force-cache 和 only-if-cached。\nredirect：重定向模式，有 follow、error、manual。\nreferrer：请求的 Referrer，可以是空字符串、URL 或者 no-referrer。\nreferrerPolicy：Referrer 策略，有 no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin 和 unsafe-url。\nintegrity：用于验证响应是否被篡改的 Subresource Integrity\n\nFetch 上传进度、下载进度Fetch API 提供了 fetch 方法的扩展，支持上传进度和下载进度的监控。\n上传进度的监控：\nfetch(url, &#123;\n  method: &#39;POST&#39;,\n  body: formData,\n&#125;)\n  .then((response) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...\n  &#125;);\n\nconst progress &#x3D; (event) &#x3D;&gt; &#123;\n  if (event.lengthComputable) &#123;\n    const percent &#x3D; Math.round((event.loaded &#x2F; event.total) * 100);\n    console.log(&#96;Upload Progress: $&#123;percent&#125;%&#96;);\n  &#125;\n&#125;;\n\nformData.addEventListener(&#39;progress&#39;, progress);\n\n下载进度的监控：\nfetch(url)\n  .then((response) &#x3D;&gt; &#123;\n    const reader &#x3D; response.body.getReader();\n    const contentLength &#x3D; +response.headers.get(&#39;content-length&#39;);\n\n    const read &#x3D; () &#x3D;&gt; &#123;\n      reader.read().then((&#123; done, value &#125;) &#x3D;&gt; &#123;\n        if (done) &#123;\n          console.log(&#39;Download Complete&#39;);\n        &#125; else &#123;\n          const downloadedLength &#x3D; value.byteLength;\n          const percent &#x3D; Math.round((downloadedLength &#x2F; contentLength) * 100);\n          console.log(&#96;Download Progress: $&#123;percent&#125;%&#96;);\n          read();\n        &#125;\n      &#125;);\n    &#125;;\n\n    read();\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...\n  &#125;);\n\n以上代码中，\n\n我们通过监听 FormData 的 progress 事件来监控上传进度，\n通过监听 Response 的 body 属性上的 Reader 对象的 read() 方法返回的 Promise 来监控下载进度。\n在上传和下载的回调函数中，可以根据已上传或已下载的数据大小和总大小计算出进度百分比并输出到控制台。\n\nFetch 与 XMLHttpRequest 区别Fetch 和 XMLHttpRequest（以下简称 XHR）都是用于发送 HTTP 请求的客户端 API，但是它们之间有以下不同点：\n\n语法差异：Fetch 使用 Promise 实现异步请求，语法更加简洁易懂，XHR 使用回调函数的方式实现异步请求。\n\n跨域策略：Fetch 在跨域请求时默认不会携带 Cookie，需要手动设置，而 XHR 会自动携带 Cookie。\n\n请求和响应的处理方式：Fetch 的请求和响应对象都是基于 Stream 对象实现的，支持更加灵活的请求和响应处理方式，而 XHR 的请求和响应对象都是基于文本和二进制数据实现的。\n\n缓存处理：Fetch 对于请求的缓存处理更加方便，可以通过设置 Request 对象的 cache 属性控制缓存策略，XHR 只能通过设置请求头中的 If-Modified-Since 或者 If-None-Match 来控制缓存策略。\n\n错误处理：Fetch 对于网络错误和请求超时的处理更加方便，支持 Promise 中的 reject 方法处理错误，XHR 需要手动设置 onerror 和 ontimeout 事件处理错误。\n\n其他：Fetch 支持 Service Worker，支持 Request 和 Response 对象的 clone 方法，XHR 不支持。\n\nFetch 的返回值是 Promise，而 XMLHttpRequest 的返回值是 XMLHttpRequest 对象。\n\nFetch 不会自动将接收到的 JSON、XML 等数据解析成 JavaScript 对象，需要手动解析；而 XMLHttpRequest 支持设置响应类型，可以自动解析为 JavaScript 对象。\n\nFetch 默认不携带 Cookie，需要设置 credentials 选项为 ‘include’ 才会携带 Cookie，而 XMLHttpRequest 在跨域请求时会自动携带 Cookie。\n\nFetch 不支持超时设置，需要使用 Promise.race() 实现超时处理，而 XMLHttpRequest 支持通过设置 timeout 属性实现超时。\n\nFetch 的错误处理需要使用 catch()，而 XMLHttpRequest 可以通过 onerror、ontimeout 等事件处理错误。\n\n\n需要注意的是，Fetch 的兼容性不如 XHR 好，在一些老版本浏览器中可能无法使用，需要进行 polyfill 或者 fallback 处理。\nFetch 不支持超时设置Fetch API 默认是不支持超时设置的，但是可以使用 Promise.race() 实现超时处理。比如，以下示例中，在 5 秒内如果 Fetch 请求没有响应，就会返回超时错误：\nconst controller &#x3D; new AbortController();\nconst timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;\n  controller.abort();\n&#125;, 5000);\n\nfetch(&#39;https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;data&#39;, &#123; signal: controller.signal &#125;)\n  .then((response) &#x3D;&gt; response.json())\n  .then((data) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理返回的数据\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    if (error.name &#x3D;&#x3D;&#x3D; &#39;AbortError&#39;) &#123;\n      console.log(&#39;Fetch 请求超时&#39;);\n    &#125; else &#123;\n      console.error(&#39;Fetch 请求错误:&#39;, error);\n    &#125;\n  &#125;)\n  .finally(() &#x3D;&gt; &#123;\n    clearTimeout(timeout);\n  &#125;);\n\n在这个示例中，使用 AbortController 实例创建一个信号(signal)，然后将该信号传递给 Fetch API。同时，使用 setTimeout() 函数在 5 秒后中断 Fetch 请求。最后，使用 Promise.race() 将 Fetch 请求 Promise 和超时 Promise 一起包装，如果其中一个 Promise 被 resolve 或 reject，整个 Promise 链都会被 resolve 或 reject。如果超时，Fetch 请求的 Promise 会被 reject，并抛出 AbortError 错误。\nFetch 不支持自动取消请求是的，Fetch API 不支持自动取消请求。如果要手动取消一个 Fetch 请求，需要使用 AbortController 和 AbortSignal 对象。具体做法是在发送 Fetch 请求时创建一个 AbortController 对象，然后将它的 signal 属性赋值给 Fetch 请求的 signal 属性。当需要取消请求时，可以调用 AbortController 对象的 abort() 方法，这会向 AbortSignal 对象发送一个中止信号，使得 Fetch 请求中止。\nAxiosAxios是一个基于 promise 和 XHR 封装的网络请求库\n特点：\n\n从浏览器中创建 XMLHttpRequests，从 node.js 创建 http 请求\n支持 Promise API\n能够拦截请求和响应，转换请求数据和响应数据\n具备 取消请求，自动转换 JSON 数据，客户端支持防御 XSRF 的特点\n\n\n\nAxios 实现原理Axios 是一个基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 环境中使用。Axios 提供了一个简单易用的 API，能够帮助我们发送 HTTP 请求、处理响应数据等。\nAxios 的实现原理可以大致分为以下几个部分：\n\n创建 Axios 实例：通过 Axios.create() 方法创建一个 Axios 实例，可以设置一些默认的配置参数，如请求头、响应类型、请求超时等。\n\n发送请求：Axios 支持多种请求方法，如 GET、POST、PUT、DELETE 等。每个请求方法都返回一个 Promise 对象，我们可以通过 .then() 和 .catch() 方法处理请求的响应数据和错误信息。\n\n处理请求配置：Axios 将请求配置对象作为参数传递给请求方法。在请求发送之前，Axios 会对请求配置进行处理和合并，包括请求 URL、请求参数、请求头等。\n\n发送请求前的拦截器：Axios 支持请求和响应的拦截器，可以在请求发送之前或者响应返回之后进行拦截和处理。拦截器是通过 interceptors 属性实现的，interceptors 包括 request 和 response 两个对象，分别代表请求和响应的拦截器。\n\n发送请求：Axios 使用底层的 XMLHttpRequest 或者 fetch API 发送请求。发送请求的过程中，Axios 支持请求的取消、请求进度的监测等功能。\n\n处理响应数据：在请求成功后，Axios 会对响应数据进行处理和转换，可以通过 transformResponse 和 transformRequest 配置项自定义响应数据的处理方式。在处理响应数据的过程中，Axios 也支持响应的拦截器，可以对响应数据进行统一的处理。\n\n发送请求后的拦截器：Axios 支持请求和响应的拦截器，可以在请求发送之前或者响应返回之后进行拦截和处理。拦截器是通过 interceptors 属性实现的，interceptors 包括 request 和 response 两个对象，分别代表请求和响应的拦截器。\n\n处理错误：在请求过程中，可能会出现一些错误，如网络错误、请求超时等。Axios 会对这些错误进行处理和封装，然后抛出一个统一的错误对象。\n\n\n以上就是 Axios 的大致实现原理，Axios 在底层使用了 Promise 和异步编程技术，能够帮助我们更加方便地处理 HTTP 请求和响应数据。\nAxios 执行过程Axios 是一个基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 中使用，用于发送 HTTP 请求和处理响应。Axios 执行的过程可以简要概括为以下几个步骤：\n\n创建 Axios 实例：使用 Axios.create() 方法创建一个 Axios 实例，并配置默认请求参数和拦截器等。\n\n发送请求：使用 Axios 实例的 HTTP 请求方法（如 axios.get、axios.post 等）发送请求，参数包括请求 URL、请求参数、请求头等。\n\n发送请求前拦截：在发送请求前，Axios 可以对请求参数、请求头等进行拦截处理，可以通过 Axios 实例的 interceptors.request.use() 方法添加拦截器。\n\n执行请求：Axios 会根据请求方法、请求 URL、请求参数等信息生成一个 HTTP 请求对象，并使用浏览器内置的 XMLHttpRequest 对象或 Node.js 中的 http 模块发送请求。\n\n接收响应：当服务器返回响应时，Axios 接收到响应并对其进行处理，包括解析响应数据、响应头等。可以通过 Axios 实例的 interceptors.response.use() 方法添加响应拦截器。\n\n处理响应数据：Axios 会根据响应状态码等信息判断请求是否成功，如果成功会返回响应数据，否则会抛出异常。Axios 还会根据响应数据的 Content-Type 头信息将响应数据转换为合适的数据格式，如 JSON 对象、XML 对象等。\n\n处理异常：如果请求发生异常，如网络错误、请求超时等，Axios 会抛出异常并中断请求。可以使用 try-catch 语句捕获异常并进行处理。\n\n\n总的来说，Axios 执行过程中的重要步骤包括创建实例、发送请求、拦截请求、执行请求、接收响应、处理响应数据和处理异常。\nAxios 拦截器的实现原理Axios 拦截器的实现原理是基于 Promise 的链式调用。Axios 中的拦截器包括请求拦截器和响应拦截器。\n当我们发送请求时，Axios 会将请求拦截器中的回调函数按照添加顺序依次执行。请求拦截器可以修改请求头、请求数据等内容，也可以通过返回 Promise 来实现异步操作，例如异步获取 token 等。\n然后，Axios 将经过请求拦截器处理后的请求发送到服务器，并等待服务器的响应。当服务器响应后，Axios 会将响应拦截器中的回调函数按照添加顺序依次执行。响应拦截器可以修改响应数据、响应头等内容，也可以通过返回 Promise 来实现异步操作，例如根据响应状态码进行特定的错误处理等。\nAxios 的拦截器使用了 Promise 的链式调用，每个拦截器中的回调函数都是一个 Promise 对象。通过 Promise.resolve 方法将每个回调函数包装成一个 Promise 对象，并使用 then 方法将它们串联起来，形成了一个 Promise 链。Axios 通过执行这个 Promise 链来实现拦截器的调用。\nAxios 的拦截器实现可以帮助我们实现很多通用的功能，例如请求前的 token 鉴权、请求后的响应数据处理等，这些功能可以在拦截器中统一实现，避免了代码的重复编写。同时，Axios 也提供了取消请求等高级功能，使得网络请求变得更加灵活和可控。\nAjax、XMLHttpRequest、Fetch、Axios 四者的区别判断两个对象是否相等在 JavaScript 中，判断两个对象是否相等可以使用以下方法：\n\n相等运算符 == 或全等运算符 === ：用于比较两个对象的值是否相等。如果两个对象的引用地址不同，则会返回 false。\nJSON.stringify() 方法：将两个对象转换为字符串后再进行比较。如果两个对象的属性名称、属性顺序和属性值都相等，则它们被视为相等。\nLodash 库的 isEqual() 方法：这是一个专门用于比较两个对象是否相等的方法。它会递归地比较两个对象的属性，如果两个对象的属性名称、属性顺序和属性值都相等，则它们被视为相等。\n\n需要注意的是，如果对象中包含函数或循环引用，则以上方法可能会产生不正确的结果。此时可以考虑对函数进行特殊处理，或使用第三方库来处理循环引用问题。\n将类数组转为数组类数组特点：\n\n类数组是一个对象， 带有 length 属性\n没有数组方法，即不可调用数组的原型方法\n\n类数组：\n\narguments\nHTMLCollection\nNodeList\n\n实现方案\n\nArray.from ES6 提供的方法，只能实现浅拷贝\n扩展运算符 不能使用在非迭代对象上\n数组 slice 方法 在不改变原数组的情况下返回数组中的某些元素并形成新的数组。\n\n判断数据类型\ntypeof 能判断基本数据类型，不能判断引用数据类型\ninstanceof 可以判断引用数据类型, 不能判断基本数据类型\n\n虽然上面两个结合可以处理，但是过于复杂\n每个对象都有一个 toString()  方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()  方法被每个  Object  对象继承。\n如果此方法在自定义对象中未被覆盖，toString()  返回  &quot;[object type]&quot;，其中  type  是对象的类型\n在 JavaScript 中，我们可以使用 typeof 操作符来判断变量的数据类型。typeof 可以返回以下结果：\n\n“undefined”：如果这个值未定义。\n“boolean”：如果这个值是布尔值。\n“number”：如果这个值是数字。\n“bigint”：如果这个值是大整数，是 ES6 新增的类型。\n“string”：如果这个值是字符串。\n“symbol”：如果这个值是符号，是 ES6 新增的类型。\n“object”：如果这个值是对象或 null。\n“function”：如果这个值是函数。\n\n另外，我们还可以使用 instanceof 操作符来判断一个对象是否属于某个类。例如，可以使用以下语句来判断一个对象是否是数组：\nconst arr &#x3D; [1, 2, 3];\nconsole.log(arr instanceof Array); &#x2F;&#x2F; true\n\n还可以使用 Object.prototype.toString.call() 方法来获取变量的类型字符串，例如：\nconsole.log(Object.prototype.toString.call([])); &#x2F;&#x2F; &quot;[object Array]&quot;\nconsole.log(Object.prototype.toString.call(&#123;&#125;)); &#x2F;&#x2F; &quot;[object Object]&quot;\nconsole.log(Object.prototype.toString.call(123)); &#x2F;&#x2F; &quot;[object Number]&quot;\nconsole.log(Object.prototype.toString.call(null)); &#x2F;&#x2F; &quot;[object Null]&quot;\nconsole.log(Object.prototype.toString.call(undefined)); &#x2F;&#x2F; &quot;[object Undefined]&quot;\nconsole.log(Object.prototype.toString.call(&#39;string&#39;)); &#x2F;&#x2F; &quot;[object String]&quot;\nconsole.log(Object.prototype.toString.call(true)); &#x2F;&#x2F; &quot;[object Boolean]&quot;\nconsole.log(Object.prototype.toString.call(function () &#123;&#125;)); &#x2F;&#x2F; &quot;[object Function]&quot;\nconsole.log(Object.prototype.toString.call(new Date())); &#x2F;&#x2F; &quot;[object Date]&quot;\nconsole.log(Object.prototype.toString.call(&#x2F;[a-z]&#x2F;)); &#x2F;&#x2F; &quot;[object RegExp]&quot;\n\n通过使用 Object.prototype.toString.call()，可以得到更加准确的类型信息，尤其是在处理引用类型时更为有用。\nObject.prototype.toString.call 封装可以将 Object.prototype.toString.call 封装成一个函数，方便使用，例如：\nfunction getType(obj) &#123;\n  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n&#125;\n\n这样，我们就可以直接使用 getType 函数来获取对象的类型，例如：\nconsole.log(getType([])); &#x2F;&#x2F; &quot;array&quot;\nconsole.log(getType(&#123;&#125;)); &#x2F;&#x2F; &quot;object&quot;\nconsole.log(getType(new Date())); &#x2F;&#x2F; &quot;date&quot;\nconsole.log(getType(null)); &#x2F;&#x2F; &quot;null&quot;\nconsole.log(getType(undefined)); &#x2F;&#x2F; &quot;undefined&quot;\nconsole.log(getType(&#39;&#39;)); &#x2F;&#x2F; &quot;string&quot;\nconsole.log(getType(1)); &#x2F;&#x2F; &quot;number&quot;\nconsole.log(getType(true)); &#x2F;&#x2F; &quot;boolean&quot;\nconsole.log(getType(function () &#123;&#125;)); &#x2F;&#x2F; &quot;function&quot;\n\nsession、cookie、token 的区别？1.为什么会有它们？\n无状态我们都知道 HTTP 协议是无状态的，所谓的无状态就是客户端每次想要与服务端通信，都必须重新与服务端链接，意味着请求一次客户端和服务端就连接一次，下一次请求与上一次请求是没有关系的。\n区分用户这种无状态的方式就会存在一个问题：如何判断两次请求的是同一个人？就好比用户在页面 A 发起请求获取个人信息，然后在另一个页面同样发起请求获取个人信息，我们如何确定这俩个请求是同一个人发的呢？\n为了解决这种问题，我们就迫切需要一种方式知道发起请求的客户端是谁？此时，cookie、token、session 就出现了，它们就可以解决客户端标识的问题，在扩大一点就是解决权限问题。\n它们就好比让每个客户端或者说登录用户有了自己的身份证，我们可以通过这个身份证确定发请求的是谁！\n作者：小猪课堂链接：https://juejin.cn/post/7090503270447185951来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\ncookie 的缺点：\n\n增加请求体积，浪费性能，因为每次请求都会携带 cookie。\n增加服务端资源消耗，因为每个客户端连接进来都需要生成 session，会占用服务端资源的。\n容易遭受 CSRF 攻击，即跨站域请求伪造。\n\nnew 做了哪些操作？手写一个 new 方法！new 操作符\n\n创建一个新的对象，\n将其 __proto__ 属性指向构造函数的原型，\n然后执行构造函数并将 this 指向新的对象，\n最后将新的对象返回。\n\n手写一个简单的 new 方法示例：\nfunction myNew(constructor, ...args) &#123;\n  &#x2F;&#x2F; 创建一个空对象并将其 __proto__ 属性指向构造函数的原型\n  const obj &#x3D; Object.create(constructor.prototype);\n\n  &#x2F;&#x2F; 执行构造函数并将 this 指向新对象\n  const result &#x3D; constructor.apply(obj, args);\n\n  &#x2F;&#x2F; 返回新对象或构造函数返回的对象\n  return result instanceof Object ? result : obj;\n&#125;\n\n这里的 ...args 表示使用了剩余参数语法，可以将传入 myNew 方法的第二个参数及以后的参数都存储到一个数组中。在执行构造函数时，将这个数组作为参数传入，可以让我们在不知道构造函数参数个数的情况下也能使用 myNew 方法来创建对象。\n跨标签页的通讯方式有哪些为什么需要跨标签页通信一个标签页的数据，要同步给另一个标签页\n列举同源\n广播模式：Broadcast Channel &#x2F; LocalStorage + StorageEvent &#x2F; Service Worker &#x2F;\n存储模式：Shared Worker &#x2F; IndexedDB &#x2F; cookie\n传递模式：window.open + window.opener 有局限性：只有从一个 tab 打开新 tab,新 tab 才可以拿到之前 tab 的引用\n基于服务端：Websocket &#x2F; Comet &#x2F; SSE 等\nvisibilitychange 监听 tab 展示\n\n非同源：\n可以使用一个用户不可见的 iframe 作为“桥”。\n由于 iframe 与父页面间， 通过指定 origin 来忽略同源限制，&#96;因此可以在每个页面中嵌入一个 iframe （例如：http://sample.com/bridge.html），\n而这些 iframe 由于使用的是一个 url，因此属于同源页面&#96;，其通信方式可以复用上面第一部分提到的各种方式\n\n作者：AlienZHOU链接：https://juejin.cn/post/6844903811232825357来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n参考资料\nBroadcast_Channel_API\nPage_Visibility_API\n面试官：前端跨页面通信，你知道哪些方法？\n\n演示&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;alienzhou.github.io&#x2F;cross-tab-communication&#x2F;&quot; style&#x3D;&quot;width: 100%; height: 800px&quot;&gt;&lt;&#x2F;iframe&gt;\n\n源码见\n非同源见\n实现原理：http://localhost:3000/bbb.html（简称 bbb 页面）嵌入 iframe 页面 http://localhost:3001/a.html（简称 iframe 页面）iframe 能够接受父级页面 bbb.html 发送过来的数据与此同时 iframe 与实际需要接受数据的 http://localhost:3001/b.html(简称 b 页面)同源，所以可以通过同源通信的 Broadcast Channel 方式将 iframe 接受到的数据发送给 b 页面实现 bbb 页面与 b 页面之间的数据发送\n作者：Tsuki_链接：https://juejin.cn/post/6869686782942773255来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\ndemo 代码&#x2F;&#x2F; 父传子\n\niframe.contentWindow.postMessage(&#39;父页面传送的数据&#39;, &#39;*&#39;);\n\n&#x2F;&#x2F; 父接子\n\nwindow.addEventListener(&#39;message&#39;, function (data) &#123;\n  console.log(data);\n&#125;);\n\n&#x2F;&#x2F; 子接父\nwindow.addEventListener(&#39;message&#39;, function (obj) &#123;\n  console.log(&#39;子页面&#39;);\n  console.log(obj);\n  let parentWindow &#x3D; obj.source;\n  parentWindow.postMessage(&#39;子页面传送的数据&#39;, &#39;*&#39;);\n&#125;);\n&#x2F;&#x2F; 子传父\nfunction sendMesg() &#123;\n  window.parent.window.postMessage(&#39;子页面传送的数据&#39;, &#39;*&#39;);\n&#125;\n\n见\ntransition 和 animation 的属性分别有哪些见\n\n\n\n对比点\ntransition\nanimation\n\n\n\n侧重点\n单一动画属性的过度效果,其过程是简单，由开始到结束的过程，中间不存在可能的动画转折\n强调的是多种动画属性的结合，按时间轴线出现周折性动画变换的动画过程，其过程是复杂的\n\n\n状态\n开始状态 和 结束状态\n多个状态，有帧的概念\n\n\n功能更强大\n\n“播放次数”、“播放方向”、“播放状态”\n\n\n触发\n选择器&#x2F;js 来触发\n自动触发\n\n\n使用规则\n\n需 @keyframes &#x2F;animation-name\n\n\n动效控制\n“持续时间”、“延迟时间” 、“时间缓动函数”\n同前者\n\n\nCSS3 animation 属性中的 steps 功能符深入介绍\n\n状态：CSS 的 transition 只有两个状态：开始状态 和 结束状态；但 animation 可能是多个状态，有帧的概念\n\n触发：CSS 的 transition 需要借助别的方式来触发，比如 CSS 的状态选择器（如:hover）或 借助 JavaScript 来触发；animation 可以自动触发\n\n动效控制：CSS transition 和 animation 虽然实现动效方式不同，但他们之间有些概念是相同的。比如他们都有“持续时间”、“延迟时间” 和“时间缓动函数”等概念，这些都是用来控制动效的效果。\n\nCSS 的 animation 是离不开 @keyframes 的，换句话说，我们需要先使用 @keyframes 来注册一个动画效果，即帧来描述动画效果。当然，只注册也不见得有效果，还是需要使用 animation-name 属性引用 @keyframes 注册好的动画效果。\n\nanimation 控制动效上要比 transition 强，因为它具备一些控制动效的属性，比如“播放次数”、“播放方向”、“播放状态”等。\n\nCSS transition 强调的是单一动画属性的过度效果,其过程是简单的，由开始到结束的过程，中间不存在可能的动画转折，只有 0 到 1，比喻：渐隐，渐显;\n\nCSS animation 强调的是多种动画属性的结合，按时间轴线出现周折性动画变换的动画过程，其过程是复杂的，由开始——&gt;结束的过程中，存在可能的动画转折，其过程可能是开始—0—1—2—3&gt;结束的过程。\n\n\n综合来说：CSS animation 可以包括 CSS transition 的动画形式。感觉两者之间,transition 像是 animation 的子集。\nCSS3 font\n必须要先有字体文件\n@font-face声明字体&lt;style&gt;\n  @font-face &#123;\n    font-family: myFirstFont;\n    src: url(&#39;你自己的字体文件路径.ttf&#39;);\n  &#125;\n&lt;&#x2F;style&gt;\ncss 选择器中使用 font-family\n\n柯里化是什么柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的技术。\n函数柯里化，是可以用来慢慢凑齐参数，延迟函数的执行。（先分期交钱，后交货！）\n实现原理函数有记忆功能（多次接受参数，记忆历史参数信息），累积接受参数个数函数小于定义参数个数时返回一个函数，继续接受参数，典型的闭包 + 递归\n为什么会出现柯里化const curry &#x3D; (fn, ...rest) &#x3D;&gt; &#123;\n  return (...args) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;判断参数总数是否和fn参数个数相等\n    if ([...rest, ...args].length &#x3D;&#x3D;&#x3D; fn.length) &#123;\n      return fn(...rest, ...args); &#x2F;&#x2F;拓展参数，调用fn\n    &#125; else &#123;\n      return curry(fn, [...rest, ...args]); &#x2F;&#x2F;迭代，传入现有的所有参数\n    &#125;\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; const curry &#x3D; (fn, ...args1) &#x3D;&gt; (...args2) &#x3D;&gt; ((arg) &#x3D;&gt; (arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, ...arg)))([\n&#x2F;&#x2F;       ...args1,\n&#x2F;&#x2F;       ...args2,\n&#x2F;&#x2F;     ]);\n\n&#x2F;&#x2F; 调用\nconst foo &#x3D; (a, b, c) &#x3D;&gt; a * b * c;\ncurry(foo)(2, 3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2)(3, 4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3)(4); &#x2F;&#x2F; -&gt; 24\ncurry(foo, 2, 3, 4)(); &#x2F;&#x2F; -&gt; 24\n\n见\n异步编程 promise 与 async 的区别async 特点为什么\nasync 解决了什么问题 promise 链式调用的烦恼\nasync 和 await 关键字,让我们可以用一种更简洁的方式， 写出基于 Promise 的异步行为，而无需刻意地链式调用 promise\n\n构成\nasync 函数是 AsyncFunction 构造函数的实例 见\n\n是什么\nasync 函数可能包含 0 个或者多个 await 表达式。\nawait 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。\npromise 的解决值会被当作该 await 表达式的返回值\n\n注意点\n从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。\n一个不含 await 表达式的 async 函数是会同步运行的。\n如果函数体内有一个 await 表达式，async 函数就一定会异步执行。\n\n返回值\nasync 返回值一定为 promise, 如果返回值不是 promise，将会被隐式包装在一个 promise 中\n\nasync function foo() &#123;\n  return 1;\n&#125;\n&#x2F;&#x2F; 等价于\nfunction foo() &#123;\n  return Promise.resolve(1);\n&#125;\n\nconsole.log(1);\nasync function foo() &#123;\n  console.log(2);\n  await 1;\n  console.log(3);\n&#125;\nfoo();\nconsole.log(4);\n\n&#x2F;&#x2F; 结果：1243\n\n两个 await, 执行说明async function foo() &#123;\n  const result1 &#x3D; await new Promise((resolve) &#x3D;&gt; setTimeout(() &#x3D;&gt; resolve(&#39;1&#39;)));\n  const result2 &#x3D; await new Promise((resolve) &#x3D;&gt; setTimeout(() &#x3D;&gt; resolve(&#39;2&#39;)));\n&#125;\nfoo();\n\n\nfoo 函数的第一行将会同步执行，await 将会等待 promise 的结束。然后暂停通过 foo 的进程，并将控制权交还给调用 foo 的函数。(控制权转出)\n一段时间后，当第一个 promise 完结的时候，控制权将重新回到 foo 函数内。示例中将会将 1（promise 状态为 fulfilled）作为结果返回给 await 表达式的左边即 result1。 (控制权转入)\n接下来函数会继续进行，到达第二个 await 区域，此时 foo 函数的进程将再次被暂停。(控制权转出)\n一段时间后，同样当第二个 promise 完结的时候，result2 将被赋值为 2，之后函数将会正常同步执行，将默认返回 undefined (控制权转入)\n\n注意： promise 链不是一次就构建好的，相反，promise 链是分阶段构造的，因此在处理异步函数时必须注意对错误函数的处理。\nasync&#x2F;await 和 Promise&#x2F;then 对比以及错误处理\n大多数 async 函数也可以使用 Promises 编写。但是，在错误处理方面，async 函数更容易捕获异常错误\n如果任一 awaited 调用失败，它将自动捕获异常，async 函数执行中断，并通过隐式返回 Promise 将错误传递给调用者\nasync 函数仍有可能然可能错误地忽略错误. 在 async 中， 没有等待 await 返回，则不会传播任何错误\n\n总结\n简单：promise 链式调用繁杂，async&#x2F;await 相对来说，更简单\n并发：promise api 能够实现并发， async&#x2F;await 只会顺序执行\n返回：async&#x2F;await 的返回值，一定是一个 promise，会进行隐式的包装（如果在发生错误时候进行，捕获处理然后返回一个值，之后真正返回并不是这个值，而是被 promise 包装了）\n错误：async&#x2F;await 在处理错误方面更容易（任意一个 await 出错，会自动捕获异常，执行中断，隐式返回 promise 错误，这几个环环相扣）,如果没有等待返回的情况下，async 可能错误的忽略错误，不进行传播错误\n错误捕获：因 async&#x2F;await 一定返回的是 promise,所以 async&#x2F;await 既可以用try catch， 也可以用.catch (try catch是 js 语法，.catch是promise.catch语法)\n\n包装对象&#x2F;原型与原型链包装对象的含义（Number&#x2F;String）经过封装，能够处理（number&#x2F;string）的对象\n继承关系\n\n\n\n\n\n细品 原型与原型链关系图：\n竖着看分为三栏：左侧为实例对象，中间为构造函数，右侧为原型对象\n\n\n\n序号\n实例\n构造函数 created by Function\n原型对象\n\n\n\n1\nnew Foo&#x2F;Number&#x2F;String\nfunction Foo&#x2F;Number&#x2F;String()\nFoo&#x2F;Number&#x2F;String.prototype\n\n\n2\nnew Object\nfunction Object()\nObject.prototype\n\n\n3\n\nfunction Function()\nFunction.prototype\n\n\n注意：序号 1从 MDN Number 包装对象的目录接口也可以看出：Number 的原型链： Function.prototype -&gt; Object.prototype -&gt; null\n&#x2F;&#x2F; .__proto__ 表示：隐式原型\n&#x2F;&#x2F; .prototype 表示：显示原型\n实例.__proto__ &#x3D;&#x3D; 实例的原型对象\n构造函数的.__proto__ &#x3D;&#x3D; Function 的原型对象\n原型对象的.constructor &#x3D;&#x3D; 对应的构造函数\n构造函数的.prototype &#x3D;&#x3D; 对应的原型对象\n非(Object 和 null)的.__proto__ &#x3D;&#x3D; Object.prototype\nObject.__proto__ &#x3D;&#x3D; null\n\n&#x2F;&#x2F; 有意思的是 Function\nFunction.__proto__ &#x3D;&#x3D; Function.prototype\n\n\nObject.freeze() vs Object.seal() vs Object.preventExtensions()Object.freeze()\n不增加新属性、不删除已有属性、不赋值\n子属性对象可编辑\n\nObject.seal()\n不增加新属性、不删除已有属性\n可赋值\n\nObject.preventExtensions()\n不增加新属性\n可改已有属性\n\n区分\n\n\n特性\n默认\npreventExtensions\nseal\nfreeze\n\n\n\n增加新属性\n可\n\n\n\n\n\n移除属性\n可\n可\n\n\n\n\n更改属性\n可\n可\n可\n\n\n\n子对象属性操作\n可\n可\n可\n可\n\n\n见\n前端工程化是什么\n通过制定规范、借助工具和框架, 解决前端开发, 以及前后端协作过程中的痛点和难度问题,提高研发效率\n\n为什么\n随着需求的增加，前端也变成大前端，还要做 App、小程序以及各种端。\n在这种需求日增的情况下，必须得考虑一种新的方式，优化前端的开发工作，\n例如，解决代码冗余，项目可维护性，提升版本迭代速度等等一系列的问题。前端工程化的概念也就是在这中情况下被提出了。\n\n如何实施前端工程化\n前端后分离\n使用 webpack 实现项目构建\n使用 babel 完成 javascript 编译\nCSS 预编译\n组件化\n模块化开发\n本地开发环境&#x2F;模拟数据\n规范化约束\n项目部署\n\nnpm run 做了什么&#x2F;&#x2F; package.json; -&gt; node_modules&#x2F;.bin&#x2F; -&gt;对应的可执行文件执行\n\n&#x2F;&#x2F; 在安装依赖的时候，是通过npm install xxx来执行的，\n&#x2F;&#x2F; 例如npm install @vue&#x2F;cli-service,npm在安装这个依赖的时候，\n&#x2F;&#x2F; 就会在node_modules&#x2F;.bin&#x2F;目录中创建好vue-cli-service为名的几个可执行文件了【不同系统对应不同的可执行文件】\n&#x2F;&#x2F; .bin目录下的文件不是任何一个npm包。目录下的文件，表示这是一个个软连接，打开文件可以看到文件顶部写着#!&#x2F;bin&#x2F;sh,表示这是一个脚本\n\n&#x2F;&#x2F; 当使用 npm run serve 执行 vue-cli-service serve时，\n&#x2F;&#x2F; 虽然没有安装 vue-cli-service的全局命令，但是npm 会到 .&#x2F;node_modules&#x2F;.bin中找到 vue-cli-service 文件作为 脚本来执行，\n&#x2F;&#x2F; 则相当于执行了 .&#x2F;node_modules&#x2F;.bin&#x2F;vue-cli-service serve（最后的 serve 作为参数传入）\n\nnpm install1. 检查配置\n\n项目级别的.npmrc 文件 &gt;\n用户级别的.npmrc 文件 &gt;\n全局的.npmrc 文件 &gt;\nnpm 内置的.npmrc 文件;\n\n2、没有 lock 文件\n\n分析：分析依赖关系，这是因为我们包会依赖其他的包，并且会多个包之间产生相同的依赖的关系。\n下载：从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）。\n缓存：获取到压缩包后会对压缩包进行缓存（从 npm5 开始有的）。\n解压缩：将压缩包解压到项目的 node_modules 文件夹中（前面我们讲过，require 的查找顺序会在该包下面查找）。\n\n3、有 lock 文件\n\n比对：检测 lock 中包的版本是否和 package.json 中一致（会按照 semver 版本规范检测）。\n无缓存：不一致，那么会重新构建依赖关系，直接会走顶层的流程。\n有缓存：一致的情况下，会去优先查找缓存。没有找到，会从 registry 仓库下载，直接走顶层流程。\n查找到：会获取缓存中的压缩文件，并且将压缩文件解压到 node_modules 文件夹中。\n\n实现 jsonp，传入 URL，callback 和 callbackName 三个参数function jsonp(url, callbackName, callback) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    try &#123;\n      let str &#x3D; &#96;$&#123;url&#125;?callback&#x3D;$&#123;callbackName&#125;&#96;;\n      &#123;\n        &#x2F;* 创建标签 *&#x2F;\n      &#125;\n      let scriptEle &#x3D; document.createElement(&#39;script&#39;);\n      scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;;\n      scriptEle.src &#x3D; str;\n      &#123;\n        &#x2F;* 监听加载 *&#x2F;\n      &#125;\n      scriptEle.addEventListener(&#39;load&#39;, callback);\n      &#123;\n        &#x2F;* 回调清理 *&#x2F;\n      &#125;\n      window[callbackName] &#x3D; function (data) &#123;\n        resolve(data);\n        document.body.removeChild(scriptEle);\n      &#125;;\n      document.body.appendChild(scriptEle);\n    &#125; catch (err) &#123;\n      reject(err);\n    &#125;\n  &#125;);\n&#125;\n\njsonp(&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;home&#39;, &#39;fun1&#39;, () &#x3D;&gt; &#123;\n  console.log(&#39;加载成功&#39;);\n&#125;).then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);\n\n原生 js 实现动态加载 js 文件?function loadScript(src, attrs) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    try &#123;\n      &#x2F;&#x2F; 创建标签\n      let scriptEle &#x3D; document.createElement(&#39;script&#39;);\n      &#x2F;&#x2F; 类型\n      scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;;\n      &#x2F;&#x2F; src\n      scriptEle.src &#x3D; src;\n      &#x2F;&#x2F; 增加属性\n      for (let key in attrs) &#123;\n        scriptEle.setAttribute(key, attrs[key]);\n      &#125;\n      &#x2F;&#x2F; 监听完成\n      scriptEle.addEventListener(&#39;load&#39;, function () &#123;\n        resolve(&#39;成功&#39;);\n      &#125;);\n      &#x2F;&#x2F; 挂载后加载\n      document.body.appendChild(scriptEle);\n    &#125; catch (err) &#123;\n      reject(err);\n    &#125;\n  &#125;);\n&#125;\nloadScript(&#39;http:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.6.2&#x2F;jquery.min.js&#39;, &#123; async: true &#125;).then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);\n\njs 中的 for 循环注意点？&#x2F;&#x2F; 多个判断条件以最后一个为准\n&#x2F;&#x2F; 最后一个是 j &lt; 9\nfor (var i &#x3D; 0, j &#x3D; 0; i &lt; 5, j &lt; 9; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4\n&#x2F;&#x2F; 5 5\n&#x2F;&#x2F; 6 6\n&#x2F;&#x2F; 7 7\n&#x2F;&#x2F; 8 8\n&#x2F;&#x2F; 最后一个是  i &lt; 5\nfor (var i &#x3D; 0, j &#x3D; 0; j &lt; 9, i &lt; 5; i++, j++) &#123;\n  console.log(i, j);\n&#125;\n&#x2F;&#x2F; 0 0\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; 2 2\n&#x2F;&#x2F; 3 3\n&#x2F;&#x2F; 4 4\n\nnew 操作符和点运算符的优先级function Foo() &#123;\n  getName &#x3D; function () &#123;\n    console.log(1);\n  &#125;; &#x2F;&#x2F;会修改全局的下的getName\n  return this; &#x2F;&#x2F; 构造函数的返回值值得注意，如果是引用类型，则得到引用数据，null除外\n&#125;\nFoo.getName &#x3D; function () &#123;\n  console.log(2);\n&#125;;\nFoo.prototype.getName &#x3D; function () &#123;\n  console.log(3);\n&#125;;\nvar getName &#x3D; function () &#123;\n  console.log(4);\n&#125;;\nfunction getName() &#123;\n  console.log(5);\n&#125;\n\n&#x2F;&#x2F;请写出以下输出结果：\nFoo.getName(); &#x2F;&#x2F;2\ngetName(); &#x2F;&#x2F; 4\nFoo().getName(); &#x2F;&#x2F; 1\ngetName(); &#x2F;&#x2F; 1\nnew Foo.getName(); &#x2F;&#x2F; 2 这里是new了一个Foo.getName函数，并没有先执行Foo.getName()在去执行new操作\nnew Foo().getName(); &#x2F;&#x2F; 3 (new Foo()).getName() 此时的getName是找到Foo构造函数的原型对象上的getName属性\nnew new Foo().getName(); &#x2F;&#x2F; 3  new ((new Foo()).getName)();\n&#x2F;*******************升级版********************&#x2F;\n&#x2F;&#x2F; function Foo() &#123;\n&#x2F;&#x2F; \t\tthis.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(3);\n&#x2F;&#x2F; \t\t\treturn &#123;\n&#x2F;&#x2F; \t\t\t\tgetName: getName&#x2F;&#x2F;这个就是第六问中涉及的构造函数的返回值问题\n&#x2F;&#x2F; \t\t\t&#125;\n&#x2F;&#x2F; \t\t&#125;;&#x2F;&#x2F;这个就是第六问中涉及到的， JS 构造函数公有方法和原型链方法的优先级\n&#x2F;&#x2F; \t\tgetName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\t\tconsole.log(1);\n&#x2F;&#x2F; \t\t&#125;;\n&#x2F;&#x2F; \t\treturn this\n&#x2F;&#x2F; \t&#125;\n&#x2F;&#x2F; \tFoo.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(2);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tFoo.prototype.getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(6);\n&#x2F;&#x2F; \t&#125;;\n&#x2F;&#x2F; \tvar getName &#x3D; function() &#123;\n&#x2F;&#x2F; \t\tconsole.log(4);\n&#x2F;&#x2F; \t&#125;;\n\n&#x2F;&#x2F; \tfunction getName() &#123;\n&#x2F;&#x2F; \t\tconsole.log(5);\n&#x2F;&#x2F; \t&#125; &#x2F;&#x2F;答案：\n&#x2F;&#x2F; \tFoo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;4\n&#x2F;&#x2F; \tconsole.log(Foo())\n&#x2F;&#x2F; \tFoo().getName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tgetName(); &#x2F;&#x2F;1\n&#x2F;&#x2F; \tnew Foo.getName(); &#x2F;&#x2F;2\n&#x2F;&#x2F; \tnew Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F;             &#x2F;&#x2F;多了一问\n&#x2F;&#x2F; \tnew Foo().getName().getName(); &#x2F;&#x2F;3 1\n&#x2F;&#x2F; \tnew new Foo().getName(); &#x2F;&#x2F;3\n&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_34146986&#x2F;article&#x2F;details&#x2F;92386841\n\nnew 一个构造函数，如果函数返回不同类型的值，结果会如何?new 的原理： 最后要判断构造函数返回值是不是个对象，不是对象是对象返回这个值，不是对象，返回构造函数的实例\nnull instanceof Object; &#x2F;&#x2F; false\nObject instanceof null; &#x2F;&#x2F; 报错，instanceof 的右侧必须是一个对象\n&#x2F;&#x2F; Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object\n\n什么都不返回function Person() &#123;&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;Person &#123;&#125;\n\n返回一个新的对象function Person() &#123;\n  return &#123;\n    name: &#39;1234&#39;,\n  &#125;;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F;&#123;name: &#39;1234&#39;&#125;\n\n返回一个原始值function Person() &#123;\n  return 111;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;\n\n返回 nullfunction Person() &#123;\n  return null;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;\n\n返回 truefunction Person() &#123;\n  return true;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1); &#x2F;&#x2F; Person &#123;&#125;\n\n返回 thisfunction Person() &#123;\n  &#x2F;&#x2F; 构造函数this指的是对象实例\n  return this;\n&#125;\n\nlet p1 &#x3D; new Person();\nconsole.log(p1);\n&#x2F;&#x2F; Person &#123;&#125;\n\n&#x2F;&#x2F; 但是 this instanceof Object true, 这里涉及到this指向问题\n\n为什么要用 apply&#x2F;call 这两个函数\n说白了就是“拿来主义”、“借刀杀人”的功效，\n比如我想做什么事，我不会不要紧，只要有人会就可以实现。\n在程序里面就是，现在假如你想用什么方法，但是当前对象没有，你可以选择拓展，自己造一个这样的方法，但是你也可以直接拿来用\n\n有时候这样使用更方便，我们只需要对象和回调方法即可，按照一般的说法就是：call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。\n讲真，为什么要用 apply 和 call 这两个函数？\nCSSheight&#x2F;widthwidth 中的 max-content,min-content,fit-content 的区别\n\nmax-content 实验性 设置为允许的最大高度。\nmin-content 实验性 设置为允许的最小高度。\navailable 实验性 包含块高度减去当前元素的边距，边框和填充。\nfit-content 实验性 将 fill-content 公式中的可用位置替换为特定的参数以进行使用，如：min(max-content, max(min-content, ))\n\nwidth 属性 100%和 auto 的区别\nwidth：100%100%表示子元素的宽度和父元素的宽度相等，其中并不包括子元素内外边距以及边框的值，为子元素真正的宽度\n\nwidth：autoauto 表示子元素的 宽度+内边距+外边距+边框 才等于父元素的宽度\n\n\n注意：上述父元素的宽度都是父元素真正的宽度，即父元素 width 属性值————————————————版权声明：本文为 CSDN 博主「Tie_may」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Tie_may/article/details/113761173\nvertical-align: middleVertical-align 被用于垂直对齐 inline 元素，也就是 display 值为 inline 和 inline-block 的元素\nCSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。\nMDN\nwill-change\n不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。\n有节制地使用：通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。\n不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。\n给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。\n\nz-index\nauto盒子不会创建一个新的本地堆叠上下文。在当前堆叠上下文中生成的盒子的堆叠层级和父级盒子相同。\n\n&lt;integer&gt;&lt;integer&gt;（整型数字）是生成的盒子在当前堆叠上下文中的堆叠层级。\n\n\n此盒子也会创建一个堆叠层级为 0 的本地堆叠上下文。这意味着后代（元素）的 z-indexes 不与此元素的外部元素的 z-indexes 进行对比。\n介绍下盒模型\n\n见\nCSS 是怎么工作的\n浏览器载入 HTML 文件（比如从网络上获取）。\n将 HTML 文件转化成一个 DOM（Document Object Model），DOM 是文件在计算机内存中的表现形式，下一节将更加详细的解释 DOM。\n接下来，浏览器会拉取该 HTML 相关的大部分资源，比如嵌入到页面的图片、视频和 CSS 样式。JavaScript 则会稍后进行处理，简单起见，同时此节主讲 CSS，所以这里对如何加载 JavaScript 不会展开叙述。\n浏览器拉取到 CSS 之后会进行解析，根据选择器的不同类型（比如 element、class、id 等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。\n上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。\n网页展示在屏幕上（这一步被称为着色）。\n\n\n见\n\n当浏览器遇到无法解析的 CSS 代码会发生什么浏览器什么也不会做，继续解析下一个 CSS 样式！\n见\n层叠、优先级和继承层叠相关因素：资源顺序、优先级 、重要程度\n\n样式表层叠——简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。\n优先级 浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度：越具体优先级越高,权重越大，优先级越高\n继承也需要在上下文中去理解——一些设置在父元素上的 CSS 属性是可以被子元素继承的，有些则不能\n\n!important强烈建议除了非常情况不要使用它覆盖 !important 唯一的办法就是另一个 !important 具有相同优先级而且顺序靠后，或者更高优先级。\n优化从 performanceAPI 来讲一大堆…,简单说要个几分钟，展开来讲几十分钟，几个小时\n协议优化\nhttp2 优于 http1\nhttp3 优于 http2\n\n加载优化\n预加载\n懒加载 Intersection Observer\n按需加载\n延迟加载、异步加载\n压缩（webpack 来讲 html、css、js、json、image 都可以压缩）\nCDN\n\n渲染优化\ncss、htm 嵌套减少\nreact-native 里有个视图拍平优化\n回流和重绘\n按需渲染\nuseCallback、useMemo、shouldComponentUpdate 浅比较\n局部渲染、局部刷新\n\n缓存优化\n强缓存\n协商缓存\n闭包数据缓存\n\n更新优化\n虚拟 dom,批量更新\n按需更新 immutable.js、immerjs\n\n上线后收集用户信息\nperformanceAPI\nweb-vital\n\n收集后分析处理\n浏览器 performance 窗口 分析 longtask\n浏览器 mermory monitor 分析内存的释放情况\n浏览器 Record coverage while performance tracing 见\nlighthouse 插件\nWeb Vitals 插件\n\n页面可见性 APIdocument.hidden&#x2F;visibilitychange\n\n网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片。\n显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。\n页面想要检测是否正在渲染，以便可以准确的计算网页浏览量\n当设备进入待机模式时，网站想要关闭设备声音（用户按下电源键关闭屏幕）\n\n按需拷贝immerjs\n原生 js 深拷贝&#x2F;浅拷贝浅拷贝\n所有标准的内置对象复制操作创建的是浅拷贝而不是深拷贝\n展开语法\nArray.prototype.concat()、Array.prototype.slice()、Array.from()\nObject.assign() 和 Object.create()\n\n\n\n深拷贝\n对象的深拷贝是指其属性与其拷贝的源对象的属性不共享相同的引用（指向相同的底层值）的副本。\n因此，当你更改源或副本时，可以确保不会导致其他对象也发生更改；\n不会出现无意中对源或副本造成意料之外的更改\n\n深拷贝\nwindow.structuredClone\nwindow.structuredClonestructuredClone 是浏览器提供的一个用于深度复制对象的方法，可以将包括 JavaScript 对象、TypedArray、ArrayBuffer 等数据类型在内的大多数对象进行复制，并且还支持复制一些浏览器 API 对象（如 File、Blob、ImageBitmap 等）。\n与传统的 JSON.parse() 和 JSON.stringify() 相比，structuredClone 更加强大，可以复制更多类型的对象，而且支持复制对象的内部循环引用。\nstructuredClone 方法只能在主线程中使用，不能在 Worker 中使用。并且由于该方法是浏览器独有的，不能在 Node.js 环境中使用。\nreact-nativereact-native 新特性\n恢复 PropTypes\n默认情况下为 TypeScript\n使用 Flexbox Gap 简化布局\n受 Web 启发,对可访问性、样式和事件进行增强\n开发者体验改进\n新架构更新\n\n\n\nhttps://reactnative.dev/blog\nreact-native 与原生的通信见：2023-02-17rn-native\n数组\n数组中有哪些方法\n\n构造方法在 JavaScript 中，数组有两种构造方法：\n\n使用 Array() 构造函数\n\n可以使用 Array() 构造函数来创建一个新的空数组，或者使用 Array() 构造函数并提供一个初始化数组的列表来创建一个新的数组。\n示例：\n&#x2F;&#x2F; 创建一个空数组\nlet arr1 &#x3D; new Array();\n\n&#x2F;&#x2F; 创建一个包含 3 个元素的数组\nlet arr2 &#x3D; new Array(3);\n\n&#x2F;&#x2F; 创建一个包含 3 个元素的数组，并进行初始化\nlet arr3 &#x3D; new Array(1, 2, 3);\n\n\n使用数组字面量（Array Literals）\n\n使用数组字面量是创建数组的一种简单方式，使用一对方括号 []，其中包含用逗号分隔的数组元素列表。\n示例：\n&#x2F;&#x2F; 创建一个包含 3 个元素的数组，并进行初始化\nlet arr &#x3D; [1, 2, 3];\n\n静态方法\n\nArray.from()： 从数组类对象或可迭代对象创建一个新的 Array 实例。\nArray.isArray()：如果参数是数组则返回 true ，否则返回 false 。\nArray.of()： 创建一个新的 Array 实例，具有可变数量的参数，而不管参数的数量或类型。\n\n\n在访问索引之前执行 in 检查，并且不将空槽与 undefined 合并：\n\nconcat()\nevery()\nsome()\nflat()\nflatMap()\nindexOf()\nforEach()\nlastIndexOf()\nmap()\nfilter()\nreduce()\nreduceRight()\nslice()\nreverse()\nsort()\ncopyWithin()\n\n\n将空槽视为 undefined：\n\njoin()\nkeys()\nvalues()\nentries()\nfill()\nfind()\nfindIndex()\nfindLast()\nfindLastIndex()\nincludes()\ngroup() (en-US)\ngroupToMap() (en-US)\ntoLocaleString()\n\n\n创建新数组的\n\nconcat()\nmap()\nfilter()\nslice()\nsplice()（构造返回的已删除元素数组）\nflat()\nflatMap()\n\n\n可以对原数组进行修改：\n\nshift() &#x2F;&#x2F; 去掉\nunshift() &#x2F;&#x2F; 增加\npush()\npop()\nsplice()\nfill()\nreverse()\nsort()\ncopyWithin()\n\n\n\n\n\n数组 groupJavaScript 中的数组没有内置的 group 方法，但可以通过编写自定义函数来实现类似的功能。\n通常实现数组分组的方法有两种：\n\n基于 reduce 方法实现分组\nfunction groupBy(array, func) &#123;\n  return array.reduce((result, item) &#x3D;&gt; &#123;\n    const group &#x3D; func(item);\n    if (!result[group]) &#123;\n      result[group] &#x3D; [];\n    &#125;\n    result[group].push(item);\n    return result;\n  &#125;, &#123;&#125;);\n&#125;\n\n上述函数接受两个参数，第一个参数是要进行分组的数组，第二个参数是一个函数，用于返回指定项的分组键。该函数内部使用 reduce 方法，遍历数组，将每个元素根据分组键进行分组，返回一个对象，键为分组键，值为对应的元素数组。\n\n基于 forEach 方法实现分组\nfunction groupBy(array, func) &#123;\n  const result &#x3D; &#123;&#125;;\n  array.forEach((item) &#x3D;&gt; &#123;\n    const group &#x3D; func(item);\n    if (!result[group]) &#123;\n      result[group] &#x3D; [];\n    &#125;\n    result[group].push(item);\n  &#125;);\n  return result;\n&#125;\n\n该函数与前一种实现方式类似，但使用 forEach 方法代替了 reduce 方法。\n\n\n使用方式如下：\nconst data &#x3D; [\n  &#123; name: &#39;apple&#39;, category: &#39;fruit&#39; &#125;,\n  &#123; name: &#39;banana&#39;, category: &#39;fruit&#39; &#125;,\n  &#123; name: &#39;carrot&#39;, category: &#39;vegetable&#39; &#125;,\n];\n\nconst result &#x3D; groupBy(data, (item) &#x3D;&gt; item.category);\nconsole.log(result);\n&#x2F;&#x2F; Output:\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;   fruit: [\n&#x2F;&#x2F;     &#123; name: &#39;apple&#39;, category: &#39;fruit&#39; &#125;,\n&#x2F;&#x2F;     &#123; name: &#39;banana&#39;, category: &#39;fruit&#39; &#125;\n&#x2F;&#x2F;   ],\n&#x2F;&#x2F;   vegetable: [&#123; name: &#39;carrot&#39;, category: &#39;vegetable&#39; &#125;]\n&#x2F;&#x2F; &#125;\n\n数组 api 实现原理&#x2F;#&#x2F;post&#x2F;2022-06-10js-arr\n比较 koa express nestjsKoa、Express 和 NestJS 都是常用的 Node.js Web 框架，它们各有特点：\n\nExpress：是目前最流行的 Node.js Web 框架之一，它简单易学、易用、灵活，生态圈也非常强大，适用于小型的 Web 应用和 API 服务。Express 的定位是一个基础框架，它提供了很多构建 Web 应用的中间件，比如 body-parser、cookie-parser、compression 等等。\n\nKoa：Koa 是由 Express 原班人马打造的一个轻量级 Web 框架，它的设计思想是基于 async&#x2F;await 实现中间件的洋葱模型，提供了更为简洁的 API，使得编写代码更加舒适、清晰。Koa 没有内置的中间件，而是需要手动选择和引入，可以更加灵活地定制和控制 Web 应用的行为。\n\nNestJS：是一个使用 TypeScript 构建的 Web 应用框架，它结合了 Express 和 Angular 的设计理念，提供了更为现代化和优雅的 API 和架构，适用于构建大型 Web 应用和企业级应用。NestJS 提供了基于类和装饰器的开发方式，使得代码结构更加清晰和易于维护，同时还提供了丰富的功能和插件，如异常处理、ORM、GraphQL 等等。\n\n\n总之，Koa 是一个轻量级的框架，提供了简洁的 API，适用于构建小型的 Web 应用和 API 服务；Express 是一个基础框架，提供了大量的中间件和插件，适用于构建中小型的 Web 应用和 API 服务；而 NestJS 是一个现代化的框架，提供了丰富的功能和插件，适用于构建大型的 Web 应用和企业级应用。选择框架需要根据实际需求进行权衡。\nService WorkerService Worker 与 主线程通信Service Worker 可以与页面的主线程进行通信，但是不能直接访问 DOM，因为它运行在另一个线程中。\n主线程和 Service Worker 之间的通信可以通过消息传递来实现，\n\nService Worker 可以使用 postMessage() 方法向主线程发送消息，主线程则可以使用 navigator.serviceWorker.onmessage 事件来监听这些消息并作出响应。\n另外，主线程也可以使用 ServiceWorker.postMessage() 方法向 Service Worker 发送消息，Service Worker 则可以使用 self.addEventListener(&#39;message&#39;, function (event) &#123;&#125;) 来监听并处理这些消息。\n\n在 Service Worker 中，还可以使用 importScripts() 方法加载其他 JavaScript 文件，这些文件可以与 Service Worker 进行通信。通常，这些 JavaScript 文件包含一些工具函数或库，用于实现 Service Worker 的一些功能。\nService Worker 与 主线程通信Service Worker 是运行在浏览器后台的一个线程，用于提供一些强大的特性，如离线缓存、推送通知和后台同步等。与其他 JavaScript 线程不同，Service Worker 运行在与网页不同的上下文中，不能直接访问 DOM。但是，Service Worker 可以与 JavaScript 在网页上下文中通信，例如通过 postMessage() 方法和 message 事件。\n在网页上下文中，可以通过 navigator.serviceWorker.controller.postMessage() 方法向 Service Worker 发送消息，例如：\nnavigator.serviceWorker.controller.postMessage(&#123;\n  type: &#39;update-cache&#39;,\n&#125;);\n\n在 Service Worker 中，可以通过监听 message 事件来接收消息：\nself.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;\n  if (event.data &amp;&amp; event.data.type &#x3D;&#x3D;&#x3D; &#39;update-cache&#39;) &#123;\n    &#x2F;&#x2F; 执行更新缓存的操作\n  &#125;\n&#125;);\n\n需要注意的是，Service Worker 的生命周期与网页不同，可能会在网页关闭后仍然继续运行。因此，在网页中向 Service Worker 发送消息时，需要判断 Service Worker 是否已经启动并处于活动状态，例如：\nif (navigator.serviceWorker.controller) &#123;\n  navigator.serviceWorker.controller.postMessage(&#123;\n    type: &#39;update-cache&#39;,\n  &#125;);\n&#125; else &#123;\n  &#x2F;&#x2F; Service Worker 未启动或处于等待状态\n&#125;\n\nService Worker 与主线程通信的完整示例下面是一个简单的示例，展示了如何在 Service Worker 和主线程之间进行通信：\n在 Service Worker 中：\n&#x2F;&#x2F; 添加消息事件监听器，等待主线程的消息\nself.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 接收到主线程发来的消息\n  const &#123; data &#125; &#x3D; event;\n\n  if (data.type &#x3D;&#x3D;&#x3D; &#39;FETCH&#39;) &#123;\n    &#x2F;&#x2F; 执行异步操作\n    fetch(data.url)\n      .then((response) &#x3D;&gt; response.json())\n      .then((data) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 将结果返回给主线程\n        self.postMessage(&#123; type: &#39;FETCH_RESULT&#39;, result: data &#125;);\n      &#125;)\n      .catch((error) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 将错误返回给主线程\n        self.postMessage(&#123; type: &#39;FETCH_ERROR&#39;, error &#125;);\n      &#125;);\n  &#125;\n&#125;);\n\n在主线程中：\n&#x2F;&#x2F; 注册 Service Worker\nnavigator.serviceWorker.register(&#39;sw.js&#39;);\n\n&#x2F;&#x2F; 发送消息给 Service Worker\nnavigator.serviceWorker.controller.postMessage(&#123;\n  type: &#39;FETCH&#39;,\n  url: &#39;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;todos&#x2F;1&#39;,\n&#125;);\n\n&#x2F;&#x2F; 添加消息事件监听器，等待 Service Worker 的响应\nnavigator.serviceWorker.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;\n  const &#123; data &#125; &#x3D; event;\n\n  if (data.type &#x3D;&#x3D;&#x3D; &#39;FETCH_RESULT&#39;) &#123;\n    &#x2F;&#x2F; 接收到 Service Worker 的结果\n    console.log(data.result);\n  &#125; else if (data.type &#x3D;&#x3D;&#x3D; &#39;FETCH_ERROR&#39;) &#123;\n    &#x2F;&#x2F; 接收到 Service Worker 的错误信息\n    console.error(data.error);\n  &#125;\n&#125;);\n\n在主线程中，我们使用 navigator.serviceWorker.controller.postMessage 发送消息给 Service Worker，然后添加了一个 message 事件监听器，等待 Service Worker 的响应。在 Service Worker 中，我们添加了一个 message 事件监听器，等待主线程发送消息。当接收到消息后，Service Worker 执行异步操作，然后将结果或错误信息发送回主线程。\nserviceWorker 为什么设计在 Navigator 上，而不是在 window 上\n窗口无关： serviceWorker 设计在 Navigator 上是因为它是浏览器中的一个独立线程，不受窗口生命周期的影响，\n全局对象：而 Navigator 是浏览器中的全局对象，可以在整个页面范围内访问。\n因此，将 serviceWorker 添加到 Navigator 上，使得它可以在整个页面中被访问和控制。\n\n很多情况下的通信是将“子实例”暴露在“父实例”中，实现通信","slug":"2022-09-19qa","date":"2022-09-18T09:13:05.000Z","categories_index":"前端基础","tags_index":"前端基础,面试,chatGPT2021","author_index":"举手摘月亮"},{"id":"5380d0b3be253a4f070c3aa29aef0cf7","title":"vscode 常用快捷键（持续更新...）","content":"直接换行cmd + enter;\n\n选中多个相同的元素cmd + d; &#x2F;&#x2F; 每次向后多选一个相同的\n\n选中相同内容cmd + shift + L; &#x2F;&#x2F; 全文，选相同内容\n\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;   &quot;key&quot;: &quot;shift+cmd+l&quot;,\n&#x2F;&#x2F;   &quot;command&quot;: &quot;addCursorsAtSearchResults&quot;,\n&#x2F;&#x2F;   &quot;when&quot;: &quot;fileMatchOrMatchFocus &amp;&amp; searchViewletVisible&quot;\n&#x2F;&#x2F; &#125;\n\n选中多个相同单词双击选中所要选中单词 快捷键 ctrl + d 按住 ctrl 不动 点击 d 他会 按着顺序 去寻找 你所选中 一样单词\n光标位置的单词选中 cmd + d\n\n多位置同时编辑cmd + 点击;\n\n选择一块内容cmd + shift + 上; &#x2F;&#x2F; 当前行光标 左侧至顶部 全部内容\ncmd + shift + 下; &#x2F;&#x2F; 当前行光标 右侧至顶部 全部内容\ncmd + shift + 左; &#x2F;&#x2F; 当前行光标 左侧 全部内容\ncmd + shift + 右; &#x2F;&#x2F; 当前行光标 右侧 全部内容\n\nshift + option + 左; &#x2F;&#x2F; 当前行光标 左侧 选择一个单词\nshift + option + 右; &#x2F;&#x2F; 当前行光标 右侧 选择一个单词\n\n选择一段内容alt + shift + 左; &#x2F;&#x2F; 当前行光标 左侧 一段内容\nalt + shift + 右; &#x2F;&#x2F; 当前行光标 右侧 一段内容\n\n复制当前行到alt + shift + 上; &#x2F;&#x2F; 向上复制一行\nalt + shift + 下; &#x2F;&#x2F; 向下复制一行\n\n向上插入空行cmd + shift + enter;\n\n向下插入空行cmd + enter;\n\n底部窗口显示隐藏cmd + j;\n\n左侧窗口显示隐藏cmd + B;\n\n切换顶部 tab 文件cmd + alt + 左; &#x2F;&#x2F; 打开向左面一个\ncmd + alt + 右; &#x2F;&#x2F; 打开右面一个\n\n文件内容切换到左侧导航cmd + shift + E;\ncmd + down; &#x2F;&#x2F; 进入文件，光标定位到顶部\n\nexplorecmd + up; &#x2F;&#x2F; 向上滚动\ncmd + down; &#x2F;&#x2F; 进入文件，光标定位到顶部\n\n切换 outline可以快速地浏览代码，在代码中跳转，在长代码、长文档中还可以充当目录的功能\nshift + cmd + . &#x2F;&#x2F; 快速地浏览代码\n\n\n\n最近打开的文件cmd + p; &#x2F;&#x2F; 最近打开的文件\n\n最近打开的项目ctrl + R; &#x2F;&#x2F; 最近打开的项目\n\n跳转到代码实现位置cmd + fn + f12; &#x2F;&#x2F; 跳转到代码实现位置\n\n跳回上次光标位置ctrl - &#x2F;&#x2F;跳回上次光标位置\nctrl + shift + - &#x2F;&#x2F;跳回下次光标位置\ncmd + right &#x2F;&#x2F; 跳转行尾部\ncmd + left &#x2F;&#x2F; 跳转行首部\nctrl + b &#x2F;&#x2F; 光标左侧一个\nctrl+f &#x2F;&#x2F; 光标右侧一个\noption + right &#x2F;&#x2F; 右侧一个单词\noption + left &#x2F;&#x2F; 左侧一个单词\n\n\n关闭 tabcmd + W; &#x2F;&#x2F; 关闭当前tab\ncmd + K, cmd + W; &#x2F;&#x2F; 关闭所有tab\n\n文件内容替换cmd + F;\n\n全局内容替换cmd + shift + F;\n\n跳转到下一个相同内容cmd + F; &#x2F;&#x2F; 先搜索该内容\nenter &#x2F; cmd + G; &#x2F;&#x2F; 下翻查找\nenter + shift; &#x2F;&#x2F; 上翻查找\n\n快速删除行cmd + shift + K; &#x2F;&#x2F; 快速删除行\n&#x2F;&#x2F; or\nctrl + e; &#x2F;&#x2F; 跳到行未\ncmd + DELETE; &#x2F;&#x2F; 删除当前行光标前的内容\n\n上行插入内容shift + cmd + enter; &#x2F;&#x2F; 上行插入内容\n\n下行插入内容cmd + enter; &#x2F;&#x2F; 下行插入内容\n\n代码重构f12; &#x2F;&#x2F; 代码重构 重命名\n\n代码缩进cmd + ] &#x2F;&#x2F;代码向右缩进\ncmd + [ &#x2F;&#x2F;代码向左缩进\n\n自定义打开 outlineshift + cmd + 2; &#x2F;&#x2F; 打开outline\n\n\n\n跳转侧边栏cmd + shift + e;\n\n多文件保存cmd + S; &#x2F;&#x2F;但文件保存\noption + cmd + S; &#x2F;&#x2F; 批量文件保存\n\n终端显示&#x2F;隐藏ctrl + &#96; &#x2F;&#x2F; 注意 不要听网上瞎扯说配置“mac隐私安全&#x2F;开发工具&#x2F;vscode” 打勾，如果打不开vscode terminal 可以查看是否被打勾了 （一定不要打勾！！！）\n\n光标行选中1. 光标位置选到行首 &#x2F;&#x2F; ctrl + shift + A\n2. 光标位置跳到行首 &#x2F;&#x2F; ctrl + A\n3. 光标位置选到行尾 &#x2F;&#x2F; ctrl + shift + E\n4. 光标位置跳到行尾 &#x2F;&#x2F; ctrl + E\n5. 选择附近一段内容 &#x2F;&#x2F; ctrl + shift + right\n\n打开文件1. 需先自定义 &#x2F;&#x2F; cmd + k,cmd + o\n2. 文件搜索   &#x2F;&#x2F; cmd + e\n\n\n\n扩展链接（非参考链接）见见\n待研究见见\n","slug":"2022-09-17vscode-shortcuts","date":"2022-09-17T13:55:58.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"f54d504d52d1875fefca7d88d3a6e051","title":"Hexo 源码","content":"项目依赖\n\n#  tree -L 2 -I .pnpm\n.\n├── hexo -&gt; .pnpm&#x2F;hexo@6.2.0&#x2F;node_modules&#x2F;hexo\n├── hexo-browsersync -&gt; .pnpm&#x2F;hexo-browsersync@0.3.0&#x2F;node_modules&#x2F;hexo-browsersync\n├── hexo-deployer-git -&gt; .pnpm&#x2F;hexo-deployer-git@3.0.0&#x2F;node_modules&#x2F;hexo-deployer-git\n├── hexo-generator-archive -&gt; .pnpm&#x2F;hexo-generator-archive@1.0.0&#x2F;node_modules&#x2F;hexo-generator-archive\n├── hexo-generator-category -&gt; .pnpm&#x2F;hexo-generator-category@1.0.0&#x2F;node_modules&#x2F;hexo-generator-category\n├── hexo-generator-index -&gt; .pnpm&#x2F;hexo-generator-index@2.0.0&#x2F;node_modules&#x2F;hexo-generator-index\n├── hexo-generator-search -&gt; .pnpm&#x2F;hexo-generator-search@2.4.3&#x2F;node_modules&#x2F;hexo-generator-search\n├── hexo-generator-tag -&gt; .pnpm&#x2F;hexo-generator-tag@1.0.0&#x2F;node_modules&#x2F;hexo-generator-tag\n├── hexo-renderer-ejs -&gt; .pnpm&#x2F;hexo-renderer-ejs@2.0.0&#x2F;node_modules&#x2F;hexo-renderer-ejs\n├── hexo-renderer-marked -&gt; .pnpm&#x2F;hexo-renderer-marked@5.0.0&#x2F;node_modules&#x2F;hexo-renderer-marked\n├── hexo-renderer-stylus -&gt; .pnpm&#x2F;hexo-renderer-stylus@2.1.0&#x2F;node_modules&#x2F;hexo-renderer-stylus\n├── hexo-server -&gt; .pnpm&#x2F;hexo-server@3.0.0&#x2F;node_modules&#x2F;hexo-server\n├── hexo-theme-aurora -&gt; .pnpm&#x2F;hexo-theme-aurora@1.5.5&#x2F;node_modules&#x2F;hexo-theme-aurora\n├── hexo-theme-landscape -&gt; .pnpm&#x2F;hexo-theme-landscape@0.0.3&#x2F;node_modules&#x2F;hexo-theme-landscape\n└── patch-package -&gt; .pnpm&#x2F;patch-package@6.4.7&#x2F;node_modules&#x2F;patch-package\n\n\n","slug":"2022-09-16hexo源码","date":"2022-09-16T01:15:22.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"举手摘月亮"},{"id":"c80e8e10d9dca59bf6892c0788404a9e","title":"AbortController 取消请求","content":"取消请求在网上胡乱翻翻，无意中又翻到 MDN 看到了\nAbortControllerAbortController 接口表示一个控制器对象，允许你根据需要中止一个或多个 Web 请求。\n构造函数\nAbortController.AbortController();\n&#x2F;&#x2F; 创建一个新的 AbortController 对象实例。\n\n属性\nAbortController.signal; &#x2F;&#x2F; 只读\n&#x2F;&#x2F; 返回一个 AbortSignal 对象实例，它可以用来 with&#x2F;abort 一个 Web（网络）请求。\n\n方法\nAbortController.abort();\n&#x2F;&#x2F; 中止一个尚未完成的 Web（网络）请求。这能够中止 fetch 请求及任何响应体的消费和流。\n\n对于取消请求，我之前理解的优点偏差，我之前理解的是：promise 提前返回就把请求取消掉了，类似 race,然而并非如此\n\n\n当一个 fetch request 初始化，我们把 AbortSignal 作为一个选项传递到到请求对象（如下 { signal }）。这将 signal 和 controller 与这个 fetch request 相关联，然后允许我们通过调用 AbortController.abort() 中止请求，如下第二个事件监听函数。\nlet controller;\nconst url &#x3D; &quot;video.mp4&quot;;\n\nconst downloadBtn &#x3D; document.querySelector(&quot;.download&quot;);\nconst abortBtn &#x3D; document.querySelector(&quot;.abort&quot;);\n\ndownloadBtn.addEventListener(&quot;click&quot;, fetchVideo);\n\nabortBtn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;\n  if (controller) &#123;\n    controller.abort();\n    console.log(&quot;中止下载&quot;);\n  &#125;\n&#125;);\n\nfunction fetchVideo() &#123;\n  controller &#x3D; new AbortController();\n  const signal &#x3D; controller.signal;\n  fetch(url, &#123; signal &#125;)\n    .then((response) &#x3D;&gt; &#123;\n      console.log(&quot;下载完成&quot;, response);\n    &#125;)\n    .catch((err) &#x3D;&gt; &#123;\n      console.error(&#96;下载错误：$&#123;err.message&#125;&#96;);\n    &#125;);\n&#125;\n\n\n\n\n\n\n\nTIP\n备注： 当 abort() 被调用时，这个 fetch() promise 将 reject 一个名为 AbortError 的 DOMException。\n\naxios\n\n\n\naxios adapters xhr\n\n\n参考链接AbortController\naxios-http.com\ngithub axios\n","slug":"2022-09-14cancel","date":"2022-09-14T13:06:23.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"ed5cd7890f7f44ca244b6e91a3c180a3","title":"webview应用","content":"h5 webview应用很广啊，平时还真没感觉到是 h5 页面渲染的内容，报错了才知道\n支付宝会员\n\nB 站 直播\n\n掘金文章详情\n","slug":"2022-09-13webview","date":"2022-09-13T14:10:02.000Z","categories_index":"h5","tags_index":"h5","author_index":"举手摘月亮"},{"id":"d3e5b4328c1c4f541cc62a16265ea877","title":"react-i18next 实战","content":"问题对于常量的数据，当 i18n 语言改变时候，顶部菜单，和侧边栏菜单没有发生改变\n有问题代码\n&#x2F;&#x2F; 仅仅是为了使用 useTranslation 而进行组件封装\nimport React from &quot;react&quot;;\nimport &#123; useTranslation &#125; from &quot;react-i18next&quot;;\ninterface IProps &#123;\n  children: string;\n&#125;\nconst Trans: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; t &#125; &#x3D; useTranslation();\n  return t(props.children);\n&#125;;\n\nexport default Trans;\n\n&#x2F;&#x2F; 语言变化，不可有效更新例子\n&#x2F;&#x2F; Trans 为了翻译写的react组件\nexport const topRoutes: MenuConfig[] &#x3D; [\n  &#123;\n    name: &lt;Trans&gt;tconfig&lt;&#x2F;Trans&gt;,\n    path: &quot;&#x2F;tconfig&quot;,\n    redirect: &quot;&#x2F;tconfig&#x2F;products&quot;,\n    routes: [\n      &#123;\n        name: &lt;Trans&gt;products&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;tconfig&#x2F;products&quot;,\n        component: &lt;TargetConfProducts &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n      &#123;\n        name: &lt;Trans&gt;devices&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;tconfig&#x2F;devices&quot;,\n        component: &lt;TargetConfDevices &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n      &#123;\n        name: &lt;Trans&gt;category&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;tconfig&#x2F;category&quot;,\n        component: &lt;TargetConfCategory &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n    ],\n  &#125;,\n  &#123;\n    name: &lt;Trans&gt;mconfig&lt;&#x2F;Trans&gt;,\n    path: &quot;&#x2F;mconfig&quot;,\n    redirect: &quot;&#x2F;mconfig&#x2F;list&quot;,\n    routes: [\n      &#123;\n        name: &lt;Trans&gt;config&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;mconfig&#x2F;list&quot;,\n        component: &lt;ModConfPage &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n    ],\n  &#125;,\n  &#123;\n    name: &lt;Trans&gt;tmonitor&lt;&#x2F;Trans&gt;,\n    path: &quot;&#x2F;tmonitor&quot;,\n    redirect: &quot;&#x2F;tmonitor&#x2F;overview&quot;,\n    routes: [\n      &#123;\n        name: &lt;Trans&gt;tmonitor-overview&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;tmonitor&#x2F;overview&quot;,\n        component: &lt;MonitorOverview &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n      &#123;\n        name: &lt;Trans&gt;tmonitor-product&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;tmonitor&#x2F;product&quot;,\n        component: &lt;MonitorProduct &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n      &#123;\n        name: &lt;Trans&gt;tmonitor-device&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;tmonitor&#x2F;device&quot;,\n        component: &lt;MonitorDevice &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n      &#123;\n        name: &lt;Trans&gt;tmonitor-cere&lt;&#x2F;Trans&gt;,\n        path: &quot;&#x2F;tmonitor&#x2F;cere&quot;,\n        component: &lt;MonitorCere &#x2F;&gt;,\n        icon: &lt;LoginOutlined &#x2F;&gt;,\n      &#125;,\n    ],\n  &#125;,\n];\n\n\n\n\n\n原因分析原因分析：数据并没有重新计算 topRoutes 数据仍然是旧的数据\n解决方案方案\n刷新浏览器的方案不考虑，用户体验极差，以下仅考虑不刷新方案\n方案 1： 强制渲染（顶层 key 方案，这个方案利用 react diff 首先比较 key，key 不同不复用的规则），缺点：1. 部分页面可能会触发重新请求， 2. Trans 组件有割裂感 3. 有性能损耗\n方案 2： i18n.language 变化时候进行重新计算（useMemo/useCallback），缺点: 1. 比较分散,难以维护， 2. Trans 组件有割裂感\n方案 3： 将 t 传入，不使用组件，利用函数，计算返回的是一个新的数组的特点， 并且直接用 t(&quot;tconfig&quot;)形式, 优点： 直观，没有割裂感\n需要随语言变化的数据，可以不使用常量的数据， 换成函数\n方案 3修改后\nexport const topRoutesFun &#x3D; (t: Function) &#x3D;&gt; &#123;\n  return [\n    &#123;\n      name: t(&quot;tconfig&quot;),\n      path: &quot;&#x2F;tconfig&quot;,\n      redirect: &quot;&#x2F;tconfig&#x2F;products&quot;,\n      routes: [\n        &#123;\n          name: t(&quot;products&quot;),\n          path: &quot;&#x2F;tconfig&#x2F;products&quot;,\n          component: &lt;TargetConfProducts &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n        &#123;\n          name: t(&quot;devices&quot;),\n          path: &quot;&#x2F;tconfig&#x2F;devices&quot;,\n          component: &lt;TargetConfDevices &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n        &#123;\n          name: t(&quot;category&quot;),\n          path: &quot;&#x2F;tconfig&#x2F;category&quot;,\n          component: &lt;TargetConfCategory &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n      ],\n    &#125;,\n    &#123;\n      name: t(&quot;mconfig&quot;),\n      path: &quot;&#x2F;mconfig&quot;,\n      redirect: &quot;&#x2F;mconfig&#x2F;list&quot;,\n      routes: [\n        &#123;\n          name: t(&quot;config&quot;),\n          path: &quot;&#x2F;mconfig&#x2F;list&quot;,\n          component: &lt;ModConfPage &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n      ],\n    &#125;,\n    &#123;\n      name: t(&quot;tmonitor&quot;),\n      path: &quot;&#x2F;tmonitor&quot;,\n      redirect: &quot;&#x2F;tmonitor&#x2F;overview&quot;,\n      routes: [\n        &#123;\n          name: t(&quot;tmonitor-overview&quot;),\n          path: &quot;&#x2F;tmonitor&#x2F;overview&quot;,\n          component: &lt;MonitorOverview &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n        &#123;\n          name: t(&quot;tmonitor-product&quot;),\n          path: &quot;&#x2F;tmonitor&#x2F;product&quot;,\n          component: &lt;MonitorProduct &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n        &#123;\n          name: t(&quot;tmonitor-device&quot;),\n          path: &quot;&#x2F;tmonitor&#x2F;device&quot;,\n          component: &lt;MonitorDevice &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n        &#123;\n          name: t(&quot;tmonitor-cere&quot;),\n          path: &quot;&#x2F;tmonitor&#x2F;cere&quot;,\n          component: &lt;MonitorCere &#x2F;&gt;,\n          icon: &lt;LoginOutlined &#x2F;&gt;,\n        &#125;,\n      ],\n    &#125;,\n  ];\n&#125;;\n\n结果展示\n\n生活～去刷鲍鱼，还有六只，好像死翘翘了\n","slug":"2022-09-11react-i18next","date":"2022-09-11T09:52:12.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"f16e7439b5860073efd517d55c41d5e5","title":"vite react antd","content":"技术选型方案 1: nextjs + sun (antd)\n之前部门用的公司（前端基建二次封装）的这套组合，被现在的部门嫌弃\n方案 2: @umijs&#x2F;max\n试用了 umijs&#x2F;max MFSU, 在开发更新体验上还是觉得慢\n方案 3: vite + react + antd + ahooks + axios + antv + canvas(svg) + ts + i18next\n\nreact 读 hook 部分源码\nahooks 读过源码\naxios 读过源码\ncanvas(svg) 部分可视化定制要求高，antv 无法实现\ni18next 对外系统需要多语言，没有使用公司多语言平台的原因，项目不大，没必要，更何况，当前部门希望创新\n\n最终选择了这套方案\n没用 redux 原因：全局使用 context，局部使用 hooks 组合的方式\nts 全局声明配置proxyalias&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ESNext&quot;,\n    &quot;useDefineForClassFields&quot;: true,\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;DOM.Iterable&quot;, &quot;ESNext&quot;],\n    &quot;allowJs&quot;: false,\n    &quot;skipLibCheck&quot;: true,\n    &quot;esModuleInterop&quot;: false,\n    &quot;allowSyntheticDefaultImports&quot;: true,\n    &quot;strict&quot;: true,\n    &quot;forceConsistentCasingInFileNames&quot;: true,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;moduleResolution&quot;: &quot;Node&quot;,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;noEmit&quot;: true,\n    &quot;jsx&quot;: &quot;react-jsx&quot;,\n    &quot;paths&quot;: &#123;\n      &quot;@&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;*&quot;],\n      &quot;@&#x2F;components&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;components&#x2F;*&quot;]\n    &#125;\n  &#125;,\n  &quot;include&quot;: [&quot;src&quot;],\n  &quot;references&quot;: [&#123; &quot;path&quot;: &quot;.&#x2F;tsconfig.node.json&quot; &#125;]\n&#125;\n\n配置完成仍然提示\nCannot find module &#39;@&#x2F;components&#x2F;test&#39; or its corresponding type declarations.\n\n解决： vscode 重新启动\n终极解决 TS 或者 Vetur 报错，Cannot find module ‘@&#x2F;xx&#x2F;xxx‘，找不到*.vue 等编译问题\n打包优化\n\n\n\n见完整配置\n\n移除日志\n移除 debuger\n集成 lodash 测试下打包优化\nantd 按需加载\nantd 定制主题\n请求工具封装\n\n打包分析open .&#x2F;stats.html -a Google\\ Chrome\n\n\n\n考虑到项目中仅用到图表\n所以将 @ant-design/charts 替换为 @ant-design/plots 子包试用\n包大小降低了一丢丢，感觉不对\n如何部署这是一个问题，之前我看有同事，用 vite 开发，用 webpack 打包部署\n打包问题，最终变成vite 产物 dist 部署问题。\n我也尝试了多次使用 next 部署方案，进行部署，由于不晓得运维内部是如何写 dockerfile 的，所以是各种报错\n\n\n\nDockerfile\nFROM nginx:1.15.0\n\nADD .docker&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf\nADD .docker &#x2F;\n\nCOPY  .&#x2F;dist &#x2F;www&#x2F;\n\nRUN chmod -R 755 &#x2F;www\n\nCMD [ &quot;sh&quot;, &quot;&#x2F;start.sh&quot; ]\n\n\nstart.sh\n# 注入环境变量\nsed -i &quot;s&#x2F;\\(&lt;head&gt;\\)&#x2F;\\1&lt;script&gt;window.ENV&#x3D;&#39;$TYA_ENV&#39;;window.REGION&#x3D;&#39;$TYA_REGION&#39;&lt;\\&#x2F;script&gt;&#x2F;&quot; &quot;&#x2F;www&#x2F;index.html&quot;\n\nnginx -g &quot;daemon off;&quot;\n\n\nnginx\nserver &#123;\n    listen       80;\n    server_name  localhost;\n\n    location &#x3D;&#x2F;health &#123;\n        return 200 ok;\n    &#125;\n\n    # 这个路径是业务方自己要加的，在上传组件的时候，他们希望直接使用脚本上传组件，通过这个接口获取 token数据\n    location &#x2F;_&#x2F;token &#123;\n         add_header Content-Type &#39;text&#x2F;html&#39;;\n         add_header Cache-Control &#39;no-store&#39;; &#x2F;&#x2F; 缓存\n         return 200 $cookie_SSO_USER_TOKEN;\n    &#125;\n\n    location &#x2F; &#123;\n        add_header Cache-Control &#39;no-store&#39;; &#x2F;&#x2F; 缓存\n        if_modified_since off; &#x2F;&#x2F; 缓存\n        etag off; &#x2F;&#x2F; 缓存\n        expires -1; &#x2F;&#x2F; 缓存\n        root &#x2F;www&#x2F;;\n        index          index.html;\n        try_files $uri &#x2F;index.html;\n    &#125;\n\n    gzip on;\n    gzip_min_length 1k;\n    gzip_buffers 4 16k;\n    gzip_comp_level 2;\n    gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png;\n    gzip_vary off;\n    gzip_disable &quot;MSIE [1-6]\\.&quot;;\n    error_page   500 502 503 504  &#x2F;50x.html;\n&#125;\n\n记录\n\n打包预览 404预览默认启动 index.html,肯定没有这个 react-router-dom 的路径 ，会走到 404\n修改 index.html 代码\n\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;Keywords&quot; content&#x3D;&quot;项目&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;Description&quot; content&#x3D;&quot;项目&quot; &#x2F;&gt;\n    &lt;!-- &lt;link rel&#x3D;&quot;icon&quot; type&#x3D;&quot;image&#x2F;svg+xml&quot; href&#x3D;&quot;&#x2F;vite.svg&quot; &#x2F;&gt; --&gt;\n    &lt;link\n      rel&#x3D;&quot;shortcut icon&quot;\n      href&#x3D;&quot;https:&#x2F;&#x2F;images.com&#x2F;rms-static&#x2F;4d08a150-2f4a-11ed-acd5-2f6ea556a3fd-1662623168485.ico&quot;\n      type&#x3D;&quot;image&#x2F;x-icon&quot;\n    &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;碳项目&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.tsx&quot;&gt;&lt;&#x2F;script&gt;\n\n    &lt;!-- fix代码，将&#x2F;index.html 改为 &#x2F; --&gt;\n    &lt;script&gt;\n      if (window.location.pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;index.html&quot;) &#123;\n        window.location.pathname &#x3D; &quot;&#x2F;&quot;;\n      &#125;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n项目结构\ntree -L 2 -I node_modules\n.\n├── dist\n│   ├── index.html\n│   ├── static\n│   └── vite.svg\n├── index.html\n├── package.json\n├── pnpm-lock.yaml\n├── public\n│   └── vite.svg\n├── src\n│   ├── @types &#x2F;&#x2F; ts全局类型\n│   ├── App.css\n│   ├── App.tsx &#x2F;&#x2F; 入口\n│   ├── assets &#x2F;&#x2F; 资源\n│   ├── components &#x2F;&#x2F; 组件\n│   ├── consts &#x2F;&#x2F; 常量\n│   ├── context &#x2F;&#x2F; react context\n│   ├── hooks &#x2F;&#x2F; react hooks\n│   ├── i18n &#x2F;&#x2F; 多语言 i18n\n│   ├── index.css\n│   ├── layout &#x2F;&#x2F; 布局\n│   ├── main.tsx\n│   ├── pages &#x2F;&#x2F; 页面\n│   ├── router &#x2F;&#x2F; 路由\n│   ├── services &#x2F;&#x2F; 接口\n│   ├── temp &#x2F;&#x2F; 临时测试\n│   ├── utils &#x2F;&#x2F; 工具函数\n│   └── vite-env.d.ts\n├── stats.html &#x2F;&#x2F; 打包分析产物\n├── tsconfig.json &#x2F;&#x2F; ts 配置\n├── tsconfig.node.json\n└── vite.config.ts &#x2F;&#x2F; vite 配置\n\n17 directories, 15 files\n\n\n\n\ntree -L 2 src\nsrc\n├── @types\n│   ├── index.d.ts\n│   └── react-i18next\n├── App.css\n├── App.tsx\n├── assets\n│   ├── favicon.ico\n│   └── react.svg\n├── components\n│   ├── auth\n│   ├── bar.tsx\n│   ├── condition\n│   ├── error\n│   ├── iconfont\n│   ├── loading\n│   ├── login\n│   ├── pageContainer\n│   ├── test.module.less\n│   ├── test.tsx\n│   └── trans\n├── consts\n├── context\n│   └── global-context.ts\n├── hooks\n├── i18n\n│   ├── config.ts\n│   ├── en\n│   └── zh\n├── index.css\n├── layout\n│   ├── base-layout\n│   └── bread\n├── main.tsx\n├── pages\n│   ├── home\n│   ├── mod-conf\n│   ├── switchlogin\n│   ├── target-conf\n│   └── target-monitor\n├── router\n│   ├── index.tsx\n│   └── routerGuard.tsx\n├── services\n├── temp\n│   └── App\\ copy.tsx\n├── utils\n│   └── request.ts\n└── vite-env.d.ts\n\n31 directories, 17 files\n\n\n\n完整配置\npackage.json\n&#123;\n  &quot;name&quot;: &quot;smart-carbon&quot;,\n  &quot;private&quot;: true,\n  &quot;version&quot;: &quot;0.0.0&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;vite&quot;,\n    &quot;build&quot;: &quot;tsc &amp;&amp; vite build&quot;,\n    &quot;preview&quot;: &quot;vite preview&quot; &#x2F;&#x2F; 注意避坑 404\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;@ant-design&#x2F;icons&quot;: &quot;^4.7.0&quot;,\n    &quot;@ant-design&#x2F;plots&quot;: &quot;^1.2.2&quot;, &#x2F;&#x2F; @ant-design&#x2F;charts的一个子包，还是有点大； 之后可以学习下svg、canvas绘图，这样打出的内容非常小\n    &quot;ahooks&quot;: &quot;^3.7.0&quot;,\n    &quot;antd&quot;: &quot;^4.23.0&quot;,\n    &quot;axios&quot;: &quot;^0.27.2&quot;,\n    &quot;classnames&quot;: &quot;^2.3.1&quot;,\n    &quot;i18next&quot;: &quot;^21.9.1&quot;,\n    &quot;lodash&quot;: &quot;^4.17.21&quot;, &#x2F;&#x2F; 这个依赖完全是为了测试vite lodash 打成bundle\n    &quot;moment&quot;: &quot;^2.29.4&quot;,\n    &quot;react&quot;: &quot;^18.2.0&quot;,\n    &quot;react-dom&quot;: &quot;^18.2.0&quot;,\n    &quot;react-i18next&quot;: &quot;^11.18.6&quot;,\n    &quot;react-router-dom&quot;: &quot;^6.3.0&quot;,\n    &quot;rollup-plugin-external-globals&quot;: &quot;^0.6.1&quot;,\n    &quot;vite-plugin-imp&quot;: &quot;^2.3.0&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@types&#x2F;lodash&quot;: &quot;^4.14.184&quot;,\n    &quot;@types&#x2F;node&quot;: &quot;^18.7.15&quot;,\n    &quot;@types&#x2F;react&quot;: &quot;^18.0.17&quot;,\n    &quot;@types&#x2F;react-dom&quot;: &quot;^18.0.6&quot;,\n    &quot;@vitejs&#x2F;plugin-react&quot;: &quot;^2.1.0&quot;,\n    &quot;less&quot;: &quot;^4.1.3&quot;,\n    &quot;rollup&quot;: &quot;^2.79.0&quot;,\n    &quot;rollup-plugin-terser&quot;: &quot;^7.0.2&quot;,\n    &quot;rollup-plugin-visualizer&quot;: &quot;^5.8.1&quot;,\n    &quot;typescript&quot;: &quot;^4.6.4&quot;,\n    &quot;vite&quot;: &quot;^3.1.0&quot;,\n    &quot;vite-plugin-compression&quot;: &quot;^0.5.1&quot;\n  &#125;\n&#125;\n\n\n\n\nvite.config.ts\n&#x2F;&#x2F; vite.config.ts\nimport &#123; defineConfig &#125; from &quot;vite&quot;;\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\n&#x2F;&#x2F;@ts-ignore\nimport path from &quot;path&quot;;\nimport vitePluginImp from &quot;vite-plugin-imp&quot;;\nimport externalGlobals from &quot;rollup-plugin-external-globals&quot;;\nimport viteCompression from &quot;vite-plugin-compression&quot;;\nimport &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;\nimport &#123; visualizer &#125; from &quot;rollup-plugin-visualizer&quot;;\nconst __dirname &#x3D; path.resolve();\n&#x2F;&#x2F; 一些需要单独打成bundle的文件\nconst chunk1 &#x3D; [&quot;react&quot;, &quot;react-router-dom&quot;, &quot;react-dom&quot;];\nconst chunk2 &#x3D; [&quot;moment&quot;, &quot;@ant-design&#x2F;icons&quot;, &quot;ahooks&quot;];\nconst chunk3 &#x3D; [&quot;lodash&quot;];\nconst chunk4 &#x3D; [&quot;axios&quot;];\nconst antdChunk &#x3D; [&quot;antd&quot;];\nconst plotsChunk &#x3D; [&quot;@ant-design&#x2F;plots&quot;];\n\nconst build &#x3D; &#123;\n  rollupOptions: &#123;\n    output: &#123;\n      &#x2F;&#x2F; 文件指纹\n      chunkFileNames: &quot;static&#x2F;js&#x2F;[name].[hash].js&quot;,\n      entryFileNames: &quot;static&#x2F;js&#x2F;[name].[hash].js&quot;,\n      &#x2F;&#x2F; 分类输出\n      assetFileNames: &quot;static&#x2F;[ext]&#x2F;[name].[hash].[ext]&quot;,\n      &#x2F;&#x2F; 手动chunk\n      manualChunks: &#123;\n        vendor: chunk1,\n        vendor2: chunk2,\n        vendor3: chunk3,\n        vendor4: chunk4,\n        plots: plotsChunk,\n        antd: antdChunk,\n      &#125;,\n    &#125;,\n  &#125;,\n  chunkSizeWarningLimit: 1024,\n&#125;;\n\nconst server &#x3D; &#123;\n  port: 3006,\n  open: &quot;&#x2F;index.html&quot;,\n  proxy: &#123;\n    &quot;&#x2F;api&quot;: &#123;\n      target: &quot;http:&#x2F;&#x2F;localhost:3032&quot;,\n      changeOrigin: true,\n      &#x2F;&#x2F; rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^\\&#x2F;api&#x2F;, &#39;&#39;)\n    &#125;,\n  &#125;,\n&#125;;\n\nconst plugins &#x3D; [\n  react(),\n  vitePluginImp(&#123;\n    libList: [\n      &#x2F;&#x2F; antd 按需引入\n      &#123;\n        libName: &quot;antd&quot;,\n        style: (name) &#x3D;&gt; &#96;antd&#x2F;es&#x2F;$&#123;name&#125;&#x2F;style&#96;,\n      &#125;,\n    ],\n  &#125;),\n  externalGlobals(&#123;\n    &#x2F;&#x2F; &quot;@ant-design&#x2F;charts&quot;: &quot;window.charts&quot;\n  &#125;),\n  &#x2F;&#x2F; vite打包优化 - 压缩\n  viteCompression(&#123;\n    verbose: true,\n    disable: false,\n    threshold: 10240,\n    algorithm: &quot;gzip&quot;,\n    ext: &quot;.gz&quot;,\n  &#125;),\n  &#x2F;&#x2F; vite 打包优化 - 移除 日志&#x2F;debugger\n  terser(&#123;\n    compress: &#123;\n      defaults: false,\n      &#x2F;&#x2F; drop_console: true,\n    &#125;,\n    mangle: &#123;\n      eval: true,\n      module: true,\n      toplevel: true,\n      safari10: true,\n      properties: false,\n    &#125;,\n    &#x2F;&#x2F; 不输出注释\n    output: &#123;\n      comments: false,\n    &#125;,\n  &#125;),\n  &#x2F;&#x2F; vite 打包分析\n  visualizer(),\n];\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;\nexport default defineConfig(&#123;\n  plugins,\n  css: &#123;\n    &#x2F;&#x2F; 配置antd主题\n    preprocessorOptions: &#123;\n      less: &#123;\n        javascriptEnabled: true,\n        modifyVars: &#123;\n          &#x2F;&#x2F; 在这里自定义主题色等样式\n          &quot;@primary-color&quot;: &quot;#646cff&quot;, &#x2F;&#x2F;设置antd主题色\n        &#125;,\n      &#125;,\n    &#125;,\n    &#x2F;&#x2F; 模块化样式，启用小驼峰\n    modules: &#123;\n      localsConvention: &quot;camelCase&quot;,\n    &#125;,\n  &#125;,\n  &#x2F;&#x2F; 路径别名，简化长路径引入，看着不舒服\n  resolve: &#123;\n    alias: &#123;\n      &quot;~&quot;: path.resolve(__dirname, &quot;.&#x2F;&quot;), &#x2F;&#x2F; 根路径\n      &quot;@&quot;: path.resolve(__dirname, &quot;src&quot;), &#x2F;&#x2F; src 路径\n    &#125;,\n  &#125;,\n  server,\n  build,\n&#125;);\n\n\n\n\nts 全局声明配置\n优点：必要的全局声明，可以极大减少 typescipt 类型的引入\n&#x2F;src&#x2F;@types\n.\n├── index.d.ts\n└── react-i18next\n    └── index.d.ts\n\n1 directory, 2 files\n\n\n&#x2F;&#x2F; react-i18next\n&#x2F;&#x2F;     └── index.d.ts\nimport &quot;react-i18next&quot;;\nimport &#123; resources &#125; from &quot;..&#x2F;..&#x2F;src&#x2F;i18n&#x2F;config&quot;;\n\ndeclare module &quot;react-i18next&quot; &#123;\n  type DefaultResources &#x3D; typeof resources[&quot;en&quot;];\n  interface Resources extends DefaultResources &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; index.d.ts\ndeclare interface MenuConfig &#123;\n  name: string | React.ReactNode;\n  icon?: React.ReactNode;\n  path?: string;\n  asPath?: string;\n  pattern?: RegExp;\n  isMenu?: boolean;\n  hidden?: boolean;\n  routes?: MenuConfig[];\n  onClick?: () &#x3D;&gt; void;\n  layout?: React.ReactNode;\n  component?: React.ReactNode;\n  icon?: React.ReactNode;\n  isShow?: boolean;\n  pageName?: string;\n  redirect?: string;\n&#125;\n\ndeclare interface IResultData&lt;T&gt; &#123;\n  code: string; &#x2F;&#x2F; 响应码\n  result?: T; &#x2F;&#x2F; 数据\n  data?: T;\n  success: boolean; &#x2F;&#x2F; 是否成功(true：成功，false：失败)\n  msg?: string; &#x2F;&#x2F; 错误信息(请求成功时无该字段)\n  errorMsg?: string;\n  message?: string;\n&#125;\n\n\n\ni18n-ally 插件插件之前安装好的，大概在几个月前，使用还是正常的，经历过几次 vscode 升级，嗝屁了\n试着重新安装了几次，确定不行，断定是配置出的问题，可视化配置，直接搜 i18n\n\n\n以下为setting.json统一配置（不在每个项目中建立啥的配置文件，麻烦）， 直接在setting.json中配置如下\n&quot;i18n-ally.extract.autoDetect&quot;: true,\n&quot;i18n-ally.extract.keyMaxLength&quot;: 1,\n&quot;i18n-ally.theme.annotation&quot;: &quot;rgba(153, 153, 153, .8)&quot;,\n&quot;i18n-ally.theme.annotationBorder&quot;: &quot;rgba(153, 153, 153, .8)&quot;,\n&quot;i18n-ally.theme.annotationMissing&quot;: &quot;#d37070&quot;,\n&quot;i18n-ally.theme.annotationMissingBorder&quot;: &quot;#d37070&quot;,\n&quot;i18n-ally.extract.parsers.html&quot;: &#123;\n\n&#125;,\n&quot;i18n-ally.displayLanguage&quot;: &quot;zh&quot;,\n&quot;i18n-ally.enabledFrameworks&quot;: [\n  &quot;react&quot;,\n  &quot;vue&quot;\n],\n&quot;i18n-ally.extract.ignoredByFiles&quot;: &#123;\n\n&#125;\n\neslint + primtter&quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^5.38.0&quot;,\n&quot;@typescript-eslint&#x2F;parser&quot;: &quot;^5.0.1&quot;,\n&quot;eslint&quot;: &quot;^8.7.0&quot;,\n&quot;eslint-config-prettier&quot;: &quot;^8.5.0&quot;,\n&quot;eslint-plugin-import&quot;: &quot;^2.26.0&quot;,\n&quot;eslint-plugin-prettier&quot;: &quot;^4.2.1&quot;,\n&quot;eslint-plugin-react&quot;: &quot;^7.31.8&quot;,\n&quot;eslint-plugin-react-hooks&quot;: &quot;^4.6.0&quot;,\n&quot;eslint-plugin-simple-import-sort&quot;: &quot;^8.0.0&quot;,\n&quot;prettier&quot;: &quot;^2.5.1&quot;,\n\n\n.eslintignore.eslintrc.cjs这个要注意下，.eslintrc.js会报错，vscode eslint 插件会有异常抛出，配的时候如果没有生效，可以查下原因\n\nvscode项目重启\nvscode eslint插件报错\n.eslintrc.cjs内容 有误\n\n.prettierignore.prettierrc这个找文档配配就行\n.editor不用配置安装插件\n\n\n效果\n\n源码github 私有仓库\n","slug":"2022-09-07vite-react","date":"2022-09-07T08:44:51.000Z","categories_index":"前端工程化","tags_index":"vite","author_index":"举手摘月亮"},{"id":"86597b4f3663d14f1511e64b4a45dce2","title":"nest 413","content":"有问题的项目import &#123; NestFactory &#125; from &quot;@nestjs&#x2F;core&quot;;\nimport &#123; NestExpressApplication &#125; from &quot;@nestjs&#x2F;platform-express&quot;;\nimport &#123; AppModule &#125; from &quot;.&#x2F;app.module&quot;;\nimport &#123; join &#125; from &quot;path&quot;;\nimport &#123; rootDir &#125; from &quot;.&#x2F;utils&#x2F;path&quot;;\nimport &#123; config &#125; from &quot;.&#x2F;config&quot;;\nimport * as bodyParser from &quot;body-parser&quot;;\n\nasync function bootstrap() &#123;\n  &#x2F;&#x2F; const app &#x3D; await NestFactory.create(AppModule);\n  const app &#x3D; await NestFactory.create&lt;NestExpressApplication&gt;(AppModule, &#123;\n    cors: true,\n  &#125;);\n  app.setGlobalPrefix(&quot;api&quot;);\n  app.useStaticAssets(join(rootDir, &quot;public&quot;), &#123;\n    prefix: config.static, &#x2F;&#x2F;设置虚拟路径\n  &#125;);\n\n  &#x2F;&#x2F; limit\n  app.use(bodyParser.urlencoded(&#123; extended: true, limit: &quot;8mb&quot; &#125;));\n  app.use(bodyParser.json(&#123; limit: &quot;8mb&quot; &#125;));\n\n  app.enableCors();\n  await app.listen(config.port);\n&#125;\nbootstrap();\n\n新构建的项目 413在一个项目中试了 n 遍都报同样的错误\nimport &#123; NestFactory &#125; from &quot;@nestjs&#x2F;core&quot;;\nimport &#123; AppModule &#125; from &quot;.&#x2F;app.module&quot;;\n\nasync function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n\n  await app.listen(8000);\n&#125;\nbootstrap();\n\n&#x2F;&#x2F;\n\n\n\n新构建的项目 200&#x2F;&#x2F; it&#39;s ok\nimport &#123; NestFactory &#125; from &quot;@nestjs&#x2F;core&quot;;\nimport &#123; AppModule &#125; from &quot;.&#x2F;app.module&quot;;\nimport * as bodyParser from &quot;body-parser&quot;;\nasync function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create(AppModule);\n  &#x2F;&#x2F; 配置limit\n  app.use(bodyParser.json(&#123; limit: &quot;50mb&quot; &#125;));\n  app.use(bodyParser.urlencoded(&#123; limit: &quot;50mb&quot;, extended: true &#125;));\n\n  await app.listen(8000);\n&#125;\nbootstrap();\n\n\n\n新构建的项目 使用 NestExpressApplication配置如下，src 相关代码完全一致\n&#123;\n  &quot;name&quot;: &quot;nest-413&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;private&quot;: true,\n  &quot;license&quot;: &quot;UNLICENSED&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;prebuild&quot;: &quot;rimraf dist&quot;,\n    &quot;build&quot;: &quot;nest build&quot;,\n    &quot;format&quot;: &quot;prettier --write \\&quot;src&#x2F;**&#x2F;*.ts\\&quot; \\&quot;test&#x2F;**&#x2F;*.ts\\&quot;&quot;,\n    &quot;start&quot;: &quot;nest start&quot;,\n    &quot;start:dev&quot;: &quot;nest start --watch&quot;,\n    &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,\n    &quot;start:prod&quot;: &quot;node dist&#x2F;main&quot;,\n    &quot;lint&quot;: &quot;eslint \\&quot;&#123;src,apps,libs,test&#125;&#x2F;**&#x2F;*.ts\\&quot; --fix&quot;,\n    &quot;test&quot;: &quot;jest&quot;,\n    &quot;test:watch&quot;: &quot;jest --watch&quot;,\n    &quot;test:cov&quot;: &quot;jest --coverage&quot;,\n    &quot;test:debug&quot;: &quot;node --inspect-brk -r tsconfig-paths&#x2F;register -r ts-node&#x2F;register node_modules&#x2F;.bin&#x2F;jest --runInBand&quot;,\n    &quot;test:e2e&quot;: &quot;jest --config .&#x2F;test&#x2F;jest-e2e.json&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;@nestjs&#x2F;common&quot;: &quot;^9.0.0&quot;,\n    &quot;@nestjs&#x2F;core&quot;: &quot;^9.0.0&quot;,\n    &quot;@nestjs&#x2F;platform-express&quot;: &quot;^9.0.11&quot;,\n    &quot;@nestjs&#x2F;typeorm&quot;: &quot;^9.0.1&quot;,\n    &quot;body-parser&quot;: &quot;^1.20.0&quot;,\n    &quot;mysql2&quot;: &quot;^2.3.3&quot;,\n    &quot;reflect-metadata&quot;: &quot;^0.1.13&quot;,\n    &quot;request&quot;: &quot;^2.88.2&quot;,\n    &quot;rimraf&quot;: &quot;^3.0.2&quot;,\n    &quot;rxjs&quot;: &quot;^7.2.0&quot;,\n    &quot;typeorm&quot;: &quot;^0.3.9&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@nestjs&#x2F;cli&quot;: &quot;^9.0.0&quot;,\n    &quot;@nestjs&#x2F;schematics&quot;: &quot;^9.0.0&quot;,\n    &quot;@nestjs&#x2F;testing&quot;: &quot;^9.0.0&quot;,\n    &quot;@types&#x2F;express&quot;: &quot;^4.17.13&quot;,\n    &quot;@types&#x2F;jest&quot;: &quot;28.1.8&quot;,\n    &quot;@types&#x2F;node&quot;: &quot;^16.0.0&quot;,\n    &quot;@types&#x2F;supertest&quot;: &quot;^2.0.11&quot;,\n    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^5.0.0&quot;,\n    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^5.0.0&quot;,\n    &quot;eslint&quot;: &quot;^8.0.1&quot;,\n    &quot;eslint-config-prettier&quot;: &quot;^8.3.0&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^4.0.0&quot;,\n    &quot;jest&quot;: &quot;28.1.3&quot;,\n    &quot;prettier&quot;: &quot;^2.3.2&quot;,\n    &quot;source-map-support&quot;: &quot;^0.5.20&quot;,\n    &quot;supertest&quot;: &quot;^6.1.3&quot;,\n    &quot;ts-jest&quot;: &quot;28.0.8&quot;,\n    &quot;ts-loader&quot;: &quot;^9.2.3&quot;,\n    &quot;ts-node&quot;: &quot;^10.0.0&quot;,\n    &quot;tsconfig-paths&quot;: &quot;4.1.0&quot;,\n    &quot;typescript&quot;: &quot;^4.7.4&quot;\n  &#125;,\n  &quot;jest&quot;: &#123;\n    &quot;moduleFileExtensions&quot;: [\n      &quot;js&quot;,\n      &quot;json&quot;,\n      &quot;ts&quot;\n    ],\n    &quot;rootDir&quot;: &quot;src&quot;,\n    &quot;testRegex&quot;: &quot;.*\\\\.spec\\\\.ts$&quot;,\n    &quot;transform&quot;: &#123;\n      &quot;^.+\\\\.(t|j)s$&quot;: &quot;ts-jest&quot;\n    &#125;,\n    &quot;collectCoverageFrom&quot;: [\n      &quot;**&#x2F;*.(t|j)s&quot;\n    ],\n    &quot;coverageDirectory&quot;: &quot;..&#x2F;coverage&quot;,\n    &quot;testEnvironment&quot;: &quot;node&quot;\n  &#125;\n&#125;\n\n\n有问题项目配置&#123;\n  &quot;name&quot;: &quot;mitm-cache&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;private&quot;: true,\n  &quot;license&quot;: &quot;UNLICENSED&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;prebuild&quot;: &quot;rimraf dist&quot;,\n    &quot;build&quot;: &quot;nest build&quot;,\n    &quot;format&quot;: &quot;prettier --write \\&quot;src&#x2F;**&#x2F;*.ts\\&quot; \\&quot;test&#x2F;**&#x2F;*.ts\\&quot;&quot;,\n    &quot;start&quot;: &quot;nest start&quot;,\n    &quot;start:dev&quot;: &quot;nest start --watch&quot;,\n    &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,\n    &quot;start:prod&quot;: &quot;node dist&#x2F;main&quot;,\n    &quot;lint&quot;: &quot;eslint \\&quot;&#123;src,apps,libs,test&#125;&#x2F;**&#x2F;*.ts\\&quot; --fix&quot;,\n    &quot;test&quot;: &quot;jest&quot;,\n    &quot;test:watch&quot;: &quot;jest --watch&quot;,\n    &quot;test:cov&quot;: &quot;jest --coverage&quot;,\n    &quot;test:debug&quot;: &quot;node --inspect-brk -r tsconfig-paths&#x2F;register -r ts-node&#x2F;register node_modules&#x2F;.bin&#x2F;jest --runInBand&quot;,\n    &quot;test:e2e&quot;: &quot;jest --config .&#x2F;test&#x2F;jest-e2e.json&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;@nestjs&#x2F;common&quot;: &quot;^8.0.0&quot;,\n    &quot;@nestjs&#x2F;core&quot;: &quot;^8.0.0&quot;,\n    &quot;@nestjs&#x2F;platform-express&quot;: &quot;^8.4.7&quot;,\n    &quot;@nestjs&#x2F;typeorm&quot;: &quot;^8.1.4&quot;,\n    &quot;mysql2&quot;: &quot;^2.3.3&quot;,\n    &quot;reflect-metadata&quot;: &quot;^0.1.13&quot;,\n    &quot;request&quot;: &quot;^2.88.2&quot;,\n    &quot;rimraf&quot;: &quot;^3.0.2&quot;,\n    &quot;rxjs&quot;: &quot;^7.2.0&quot;,\n    &quot;typeorm&quot;: &quot;^0.3.6&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@nestjs&#x2F;cli&quot;: &quot;^8.0.0&quot;,\n    &quot;@nestjs&#x2F;schematics&quot;: &quot;^8.0.0&quot;,\n    &quot;@nestjs&#x2F;testing&quot;: &quot;^8.0.0&quot;,\n    &quot;@types&#x2F;express&quot;: &quot;^4.17.13&quot;,\n    &quot;@types&#x2F;jest&quot;: &quot;27.5.0&quot;,\n    &quot;@types&#x2F;node&quot;: &quot;^16.0.0&quot;,\n    &quot;@types&#x2F;supertest&quot;: &quot;^2.0.11&quot;,\n    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^5.0.0&quot;,\n    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^5.0.0&quot;,\n    &quot;eslint&quot;: &quot;^8.0.1&quot;,\n    &quot;eslint-config-prettier&quot;: &quot;^8.3.0&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^4.0.0&quot;,\n    &quot;jest&quot;: &quot;28.0.3&quot;,\n    &quot;prettier&quot;: &quot;^2.3.2&quot;,\n    &quot;source-map-support&quot;: &quot;^0.5.20&quot;,\n    &quot;supertest&quot;: &quot;^6.1.3&quot;,\n    &quot;ts-jest&quot;: &quot;28.0.1&quot;,\n    &quot;ts-loader&quot;: &quot;^9.2.3&quot;,\n    &quot;ts-node&quot;: &quot;^10.0.0&quot;,\n    &quot;tsconfig-paths&quot;: &quot;4.0.0&quot;,\n    &quot;typescript&quot;: &quot;^4.3.5&quot;\n  &#125;,\n  &quot;jest&quot;: &#123;\n    &quot;moduleFileExtensions&quot;: [\n      &quot;js&quot;,\n      &quot;json&quot;,\n      &quot;ts&quot;\n    ],\n    &quot;rootDir&quot;: &quot;src&quot;,\n    &quot;testRegex&quot;: &quot;.*\\\\.spec\\\\.ts$&quot;,\n    &quot;transform&quot;: &#123;\n      &quot;^.+\\\\.(t|j)s$&quot;: &quot;ts-jest&quot;\n    &#125;,\n    &quot;collectCoverageFrom&quot;: [\n      &quot;**&#x2F;*.(t|j)s&quot;\n    ],\n    &quot;coverageDirectory&quot;: &quot;..&#x2F;coverage&quot;,\n    &quot;testEnvironment&quot;: &quot;node&quot;\n  &#125;\n&#125;\n\n\n猜测在 src 代码一致的情况下，nest 相关版本使用最新的，可以断定 nest v8 有问题\n公司电脑验证启动的端口一直是修改前的端口，执行 项目中 yarn prebuild 会清理 dist 目录，清理完成后重启可以了\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;prebuild&quot;: &quot;rimraf dist&quot;, &#x2F;&#x2F; 这个\n    &quot;build&quot;: &quot;nest build&quot;,\n    &quot;format&quot;: &quot;prettier --write \\&quot;src&#x2F;**&#x2F;*.ts\\&quot; \\&quot;test&#x2F;**&#x2F;*.ts\\&quot;&quot;,\n    &quot;start&quot;: &quot;nest start&quot;,\n    &quot;start:dev&quot;: &quot;nest start --watch&quot;,\n    &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,\n    &quot;start:prod&quot;: &quot;node dist&#x2F;main&quot;,\n    &quot;lint&quot;: &quot;eslint \\&quot;&#123;src,apps,libs,test&#125;&#x2F;**&#x2F;*.ts\\&quot; --fix&quot;,\n    &quot;test&quot;: &quot;jest&quot;,\n    &quot;test:watch&quot;: &quot;jest --watch&quot;,\n    &quot;test:cov&quot;: &quot;jest --coverage&quot;,\n    &quot;test:debug&quot;: &quot;node --inspect-brk -r tsconfig-paths&#x2F;register -r ts-node&#x2F;register node_modules&#x2F;.bin&#x2F;jest --runInBand&quot;,\n    &quot;test:e2e&quot;: &quot;jest --config .&#x2F;test&#x2F;jest-e2e.json&quot;\n  &#125;\n&#125;\n","slug":"2022-09-06nestjs","date":"2022-09-06T12:44:35.000Z","categories_index":"nest","tags_index":"nest","author_index":"举手摘月亮"},{"id":"89201434f3db3df07b7bcb0835c2df9a","title":"React useImperativeHandle","content":"小插曲vscode 把 js 代码做做了 ts 校验\n\n\n问题处理\n\n\nuseImperativeHandleuse Imperative Handle 使用命令句柄\nuseImperativeHandle(ref, createHandle, [deps])\nuseImperativeHandle  可以让你在使用 ref 时自定义暴露给父组件的实例值。\n在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle  应当与 forwardRef 一起使用：\nfunction FancyInput(props, ref) &#123;\n  const inputRef &#x3D; useRef();\n  useImperativeHandle(ref, () &#x3D;&gt; (&#123;\n    focus: () &#x3D;&gt; &#123;\n      inputRef.current.focus();\n    &#125;,\n  &#125;));\n  return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;*...*&#x2F; &#x2F;&gt;;\n&#125;\n\nFancyInput &#x3D; forwardRef(FancyInput);\n\n在本例中，渲染  &lt;FancyInput ref=&#123;inputRef&#125; /&gt;  的父组件可以调用  inputRef.current.focus()。\nantd form看下组件中是如何使用的\n&#x2F;&#x2F; ...\nconst [wrapForm] &#x3D; useForm(form);\n&#x2F;&#x2F; ...\nReact.useImperativeHandle(ref, () &#x3D;&gt; wrapForm);\n\nuseImperativeHandle 源码Type ‘MutableRefObject&lt;IOrgStaffSelectRef | undefined&gt;’ is not assignable to type ‘Ref | undefined’.How to use useRef with TypeScript\n参考链接vscode 中对 JS 文件使用了 typeScript 检测\nuseImperativeHandle 笔记\n为什么 React 源码中有 new.js 和 old.js ？\nuseEffect 和 useLayoutEffect 源码浅析\n最陌生的 hooks: useImperativeHandle\n","slug":"2022-09-06useImperativeHandle","date":"2022-09-06T03:21:11.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"1ad99506e723aeb106287f0014b15cda","title":"vscode react-javascript-snippets源码","content":"背景要分享自己开发的代码片段工具 vs-snippets，正所谓：没有对比，就没有伤害,了解下别人是如何开发代码片段插件的思路，做个对比\n不得不说，react-javascript-snippets 无论从源代码组织还是支持的代码片段来讲都非常优秀，对于大众化来讲非常 nice。 然而项目开发总有那么多定制化，作为一款代码片段插件来讲，私有定制化却并不是那么灵活\npackage.json.json 文件不能增加注释\n&#123;\n  &quot;name&quot;: &quot;es7-react-js-snippets&quot;,\n  &quot;displayName&quot;: &quot;ES7+ React&#x2F;Redux&#x2F;React-Native snippets&quot;,\n  &quot;description&quot;: &quot;Extensions for React, React-Native and Redux in JS&#x2F;TS with ES7+ syntax. Customizable. Built-in integration with prettier.&quot;,\n  &quot;version&quot;: &quot;4.4.3&quot;,\n  &quot;publisher&quot;: &quot;dsznajder&quot;,\n  &quot;icon&quot;: &quot;images&#x2F;logo.png&quot;,\n  &quot;browser&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;,\n  &quot;main&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;,\n  &quot;keywords&quot;: [\n    &quot;snippets&quot;,\n    &quot;react&quot;,\n    &quot;redux&quot;,\n    &quot;react-native&quot;,\n    &quot;customizable&quot;,\n    &quot;javascript&quot;,\n    &quot;typescript&quot;,\n    &quot;prettier&quot;\n  ],\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;repository&quot;: &#123;\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;dsznajder&#x2F;vscode-es7-javascript-react-snippets&quot;\n  &#125;,\n  &quot;engines&quot;: &#123;\n    &quot;vscode&quot;: &quot;^1.60.0&quot;\n  &#125;,\n  &#x2F;&#x2F; https:&#x2F;&#x2F;code.visualstudio.com&#x2F;api&#x2F;references&#x2F;extension-manifest#combining-extension-contributions\n  &quot;categories&quot;: [&quot;Snippets&quot;],\n  &quot;extensionKind&quot;: [&quot;ui&quot;, &quot;workspace&quot;],\n  &quot;capabilities&quot;: &#123;\n    &quot;virtualWorkspaces&quot;: true,\n    &quot;untrustedWorkspaces&quot;: &#123;\n      &quot;supported&quot;: true\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; https:&#x2F;&#x2F;code.visualstudio.com&#x2F;api&#x2F;references&#x2F;extension-manifest\n  &quot;activationEvents&quot;: [\n    &quot;onLanguage:typescript&quot;,\n    &quot;onLanguage:typescriptReact&quot;,\n    &quot;onLanguage:javascript&quot;,\n    &quot;onLanguage:javascriptReact&quot;,\n    &quot;onCommand:reactSnippets.search&quot;,\n    &quot;onStartupFinished&quot;\n  ],\n  &quot;contributes&quot;: &#123;\n    &#x2F;&#x2F; 查询命令\n    &quot;commands&quot;: [\n      &#123;\n        &quot;command&quot;: &quot;reactSnippets.search&quot;,\n        &quot;title&quot;: &quot;Snippet search&quot;\n      &#125;\n    ],\n    &#x2F;&#x2F; 绑定快捷键\n    &quot;keybindings&quot;: [\n      &#123;\n        &quot;command&quot;: &quot;reactSnippets.search&quot;,\n        &quot;key&quot;: &quot;ctrl+alt+r&quot;,\n        &quot;mac&quot;: &quot;shift+cmd+r&quot;,\n        &quot;when&quot;: &quot;editorTextFocus&quot;\n      &#125;\n    ],\n    &#x2F;&#x2F; 配置信息\n    &quot;configuration&quot;: &#123;\n      &quot;title&quot;: &quot;ES React&#x2F;React-Native&#x2F;Redux snippets&quot;,\n      &quot;properties&quot;: &#123;\n        &#x2F;&#x2F; 是否启用prettier格式代码\n        &quot;reactSnippets.settings.prettierEnabled&quot;: &#123;\n          &quot;type&quot;: &quot;boolean&quot;,\n          &quot;markdownDescription&quot;: &quot;[EXPERIMENTAL: MIGHT NOT WORK]: Integrate prettier settings with code generated from snippets.&quot;,\n          &quot;default&quot;: false\n        &#125;,\n        &#x2F;&#x2F; 是否在顶部引入 react importReactOnTop\n        &quot;reactSnippets.settings.importReactOnTop&quot;: &#123;\n          &quot;type&quot;: &quot;boolean&quot;,\n          &quot;markdownDescription&quot;: &quot;Controls if snippets should add &#96;import React from &#39;react&#39;;&#96; at the top of components.\\nUse if you have React +17 and use jsx transform.&quot;,\n          &quot;default&quot;: true\n        &#125;,\n        &#x2F;&#x2F; 是否使用typescript\n        &quot;reactSnippets.settings.typescript&quot;: &#123;\n          &quot;type&quot;: &quot;boolean&quot;,\n          &quot;markdownDescription&quot;: &quot;Controls if React components have typescript Props typing.&quot;,\n          &quot;default&quot;: true\n        &#125;,\n        &#x2F;&#x2F; 语言范围\n        &quot;reactSnippets.settings.languageScopes&quot;: &#123;\n          &quot;type&quot;: &quot;string&quot;,\n          &quot;markdownDescription&quot;: &quot;defines the language scopes for which the snippets will be available.\\nUse comma separated values.\\nFor example: &#96;typescript,typescriptreact,javascript,javascriptreact&#96;&quot;,\n          &quot;default&quot;: &quot;typescript,typescriptreact,javascript,javascriptreact&quot;\n        &#125;,\n        &#x2F;&#x2F; props&#x2F;state. 使用type还是interface\n        &quot;reactSnippets.settings.typescriptPropsStatePrefix&quot;: &#123;\n          &quot;type&quot;: &quot;string&quot;,\n          &quot;markdownDescription&quot;: &quot;Controls which prefix for typescript snippets should use for props&#x2F;state.&quot;,\n          &quot;default&quot;: &quot;type&quot;,\n          &quot;enum&quot;: [&quot;type&quot;, &quot;interface&quot;]\n        &#125;\n      &#125;\n    &#125;,\n    &quot;snippets&quot;: [\n      &#x2F;&#x2F; js语言\n      &#123;\n        &quot;language&quot;: &quot;javascript&quot;,\n        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;\n      &#125;,\n      &#x2F;&#x2F; jsx语言\n      &#123;\n        &quot;language&quot;: &quot;javascriptreact&quot;,\n        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;\n      &#125;,\n      &#x2F;&#x2F; ts语言\n      &#123;\n        &quot;language&quot;: &quot;typescript&quot;,\n        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;\n      &#125;,\n      &#x2F;&#x2F; tsx语言\n      &#123;\n        &quot;language&quot;: &quot;typescriptreact&quot;,\n        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;\n      &#125;\n    ]\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;vscode:prepublish&quot;: &quot;yarn compile&quot;,\n    &quot;compile&quot;: &quot;rm -rf lib; tsc -p .&#x2F; --noEmit false --module commonjs --outDir lib&quot;,\n    &quot;compile:dev&quot;: &quot;rm -rf lib; tsc -p .&#x2F; --noEmit false --module commonjs --outDir lib&quot;,\n    &quot;lint&quot;: &quot;eslint --ext .js,.ts,.tsx .&#x2F;src&#x2F;&quot;,\n    &quot;watch&quot;: &quot;tsc -watch -p .&#x2F;&quot;,\n    &quot;typescript&quot;: &quot;tsc --noEmit&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;prettier&quot;: &quot;2.5.1&quot;\n  &#125;,\n  &quot;peerDependencies&quot;: &#123;\n    &quot;prettier&quot;: &quot;^2&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;prettier&quot;: &quot;2.5.1&quot;,\n    &quot;typescript&quot;: &quot;4.5.5&quot;\n  &#125;,\n  &#x2F;&#x2F; prettier  配置\n  &quot;prettier&quot;: &#123;\n    &quot;bracketSameLine&quot;: false,\n    &quot;bracketSpacing&quot;: true,\n    &quot;printWidth&quot;: 80,\n    &quot;semi&quot;: true,\n    &quot;singleQuote&quot;: true,\n    &quot;tabWidth&quot;: 2,\n    &quot;trailingComma&quot;: &quot;all&quot;,\n    &quot;useTabs&quot;: false,\n    &quot;endOfLine&quot;: &quot;auto&quot;\n  &#125;\n&#125;\n\ntsrcredux 命令举例import &#123;\n  exportDefault,\n  innerComponent,\n  innerComponentReturn,\n  propsStateInterface,\n  propsTypeInterface,\n  react,\n  reactComponent,\n  reactPureComponent,\n  reduxComponentExport,\n&#125; from &quot;.&#x2F;sharedSnippets&quot;;\n\n&#x2F;&#x2F; src&#x2F;sourceSnippets&#x2F;typescript.ts\n&#x2F;&#x2F; 源码链接：https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;typescript.ts#L175\nconst typescriptReactClassComponentRedux: TypescriptSnippet &#x3D; &#123;\n  key: &quot;typescriptReactClassComponentRedux&quot;,\n  prefix: &quot;tsrcredux&quot;,\n  body: [\n    &quot;import &#123; connect &#125; from &#39;react-redux&#39;&quot;,\n    ...reactComponent, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L18 &#x2F;&#x2F; 复用 import React, &#123; Component &#125; from &#39;react&#39;\n    &quot;&quot;,\n    ...propsStateInterface, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L52 type Props &#x3D; &#123;&#125; type State &#x3D; &#123;&#125;\n    &#96;export class $&#123;Placeholders.FileName&#125; extends Component&lt;Props, State&gt; &#123;&#96;,\n    &quot;  state &#x3D; &#123;&#125;&quot;,\n    &quot;&quot;,\n    ...innerComponentReturn, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L40\n    &quot;&#125;&quot;,\n    ...reduxComponentExport, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L25\n  ],\n  description:\n    &quot;Creates a React component class with connected redux and ES7 module system and TypeScript interfaces&quot;,\n&#125;;\n\n测试结果\nimport &#123; connect &#125; from &quot;react-redux&quot;;\nimport React, &#123; Component &#125; from &quot;react&quot;;\n\ntype Props &#x3D; &#123;&#125;;\n\ntype State &#x3D; &#123;&#125;;\n\nexport class tsrcredux&#x2F;**文件名 *&#x2F; extends Component&lt;Props, State&gt; &#123;\n  state &#x3D; &#123;&#125;;\n\n  render() &#123;\n    return &lt;div&gt;tsrcreduxx&lt;!--文件名 --&gt;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nconst mapStateToProps &#x3D; (state) &#x3D;&gt; (&#123;&#125;);\n\nconst mapDispatchToProps &#x3D; &#123;&#125;;\n\nexport default connect(mapStateToProps, mapDispatchToProps)(tsrcreduxx&#x2F;**文件名 *&#x2F;);\n\n\n\n源码解读👑 ~&#x2F;haotian&#x2F;github&#x2F;vscode-plugins&#x2F;vscode-react-javascript-snippets&#x2F;src git:(master) $ tree -l\n.\n├── helpers &#x2F;&#x2F; 工具\n│   ├── extensionConfig.ts &#x2F;&#x2F; 获取工作空间的配置信息\n│   ├── formatters.ts &#x2F;&#x2F; 从配置工作空间中拿到配置信息对代码片段进行格式化，对代码片段进行解析，转化成vscode支持的语法\n│   ├── generateSnippets.ts &#x2F;&#x2F; 获取sourceSnippets 目录下的代码片段，进行格式化输出到 __dirname + &#39;&#x2F;..&#x2F;snippets&#x2F;generated.json&#39;\n│   ├── getPrettierConfig.ts &#x2F;&#x2F;  获取prettier的配置信息\n│   ├── parseSnippetToBody.ts &#x2F;&#x2F; 将代码片段放到body中，中间过程处理了是否需要引入react\n│   ├── replaceOrRemoveReactImport.ts &#x2F;&#x2F; 有引入react得前缀枚举, 对于不需要引入react得行进行替换除去\n│   ├── snippetPlaceholders.ts &#x2F;&#x2F; 1.Mappings 键转化成值， 2.Mappings 值转化成键\n│   └── snippetSearch.ts &#x2F;&#x2F;获取代码片段，格式化成 vscode showQuickPick 可以使用的数据\n├── index.ts &#x2F;&#x2F; 插件入口， 插件激活时候，1.工作空间配置更改监听， window.showWarningMessage提示是否需要重启插件；2.命令注册\n├── snippets\n│   └── generated.json &#x2F;&#x2F; generateSnippets 生成目录，以及package.json snippets字段 用于语言域配置\n├── sourceSnippets &#x2F;&#x2F; 源代码片段目录\n│   ├── components.ts &#x2F;&#x2F; react组件相关\n│   ├── console.ts &#x2F;&#x2F; 日志相关\n│   ├── hooks.ts &#x2F;&#x2F; react hooks相关\n│   ├── imports.ts &#x2F;&#x2F; 提供了不同的引入方式\n│   ├── others.ts &#x2F;&#x2F; 其他乱七八糟的归为一类 js 函数、数组、结构、class、声明周期、react createRef 叭啦叭啦一堆\n│   ├── propTypes.ts &#x2F;&#x2F; 属性相关的\n│   ├── reactNative.ts &#x2F;&#x2F; rn 相关的\n│   ├── redux.ts &#x2F;&#x2F; redux相关的\n│   ├── sharedSnippets.ts &#x2F;&#x2F; 被其他代码片段共享复用的部分\n│   ├── tests.ts &#x2F;&#x2F; 测试代码片段，非测试文件\n│   └── typescript.ts &#x2F;&#x2F; ts语法的的代码片段\n└── types.ts &#x2F;&#x2F; 与vsocde可识别语法的 映射关系\n\n3 directories, 22 files\n\n详细源码注释github fork\n片段语法见 visualstudio见 博客extension-manifest categoriesactivationEvents\n","slug":"2022-09-05vscode","date":"2022-09-05T02:35:51.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"624f5234ec8cf95d8c13811af9eb0639","title":"企业微信 下载/导出","content":"浏览器环境a 标签方式一般情况\n&#x2F;**\n * @param &#123; String &#125; target 下载对象\n * @param &#123; String &#125; type 类型 url &#x2F; blob\n *&#x2F;\nexport const downloadFile &#x3D; (target, filename &#x3D; &quot;&quot;, type &#x3D; &quot;url&quot;) &#x3D;&gt; &#123;\n  const link &#x3D; document.createElement(&quot;a&quot;);\n  const body &#x3D; document.querySelector(&quot;body&quot;);\n  if (!body) return;\n\n  &#x2F;&#x2F; 需下载的文件类型\n  if (type &#x3D;&#x3D;&#x3D; &quot;url&quot;) &#123;\n    link.href &#x3D; target;\n  &#125; else if (type &#x3D;&#x3D;&#x3D; &quot;blob&quot;) &#123;\n    link.href &#x3D; window.URL.createObjectURL(target);\n  &#125;\n\n  &#x2F;&#x2F; 文件名\n  if (filename) link.download &#x3D; filename;\n\n  link.style.display &#x3D; &quot;none&quot;;\n  body.appendChild(link);\n\n  link.click();\n\n  window.URL.revokeObjectURL(link.href); &#x2F;&#x2F; 释放 URL 对象\n  body.removeChild(link);\n&#125;;\n\nwindow api 方式window.open 、window.location.href\n通过 name 形式\nwindow.open(&quot;url?name&#x3D;资源文件&quot;);\nwindow.location.href &#x3D; &quot;url?name&#x3D;资源文件&quot;;\n\n企业微信环境不支持上述两种方式更改，完全由后台接口返回控制\n\n\n\n并且企业微信下载，需要二次确认，下载之后，并不像浏览器那样提示在底部提示已下载的文件\n\n如果这个地方 Content-Disposition 后台没有塞 filename 字段，企业微信提示二次确认时候的重命名 输入框默认是空的\n\n企业微信文件API理论上可以用，但是有些IOS手机还是坑多多\n\n\n","slug":"2022-09-02wx-download","date":"2022-09-02T08:59:24.000Z","categories_index":"企业微信","tags_index":"企业微信","author_index":"举手摘月亮"},{"id":"847fdfbf845470be05a2ff27391aae0c","title":"ahooks源码","content":"背景随意看看，了解下，无固定顺序，全凭兴趣\nuseUpdate\n\n\n\n\n\n\n\n\nuseUpdate 会返回一个函数，调用该函数会强制组件重新渲染。\nimport &#123; useCallback, useState &#125; from &quot;react&quot;;\n\nconst useUpdate &#x3D; () &#x3D;&gt; &#123;\n  const [, setState] &#x3D; useState(&#123;&#125;);\n\n  return useCallback(() &#x3D;&gt; setState(&#123;&#125;), []); &#x2F;&#x2F; setState(&#123;&#125;) 每次置为新的对象，即使页面没有用到该useState的返回值，也会更新\n&#125;;\n\nexport default useUpdate;\n\nuseControllableValue\n\n\n\n\n\n\n\n\n在某些组件开发时，我们需要组件的状态既可以自己管理，也可以被外部控制，useControllableValue 就是帮你管理这种状态的 Hook。\n简单来说，默认情况下,外层组件有 value, onChange 就用外层的，外层没有，自己处理\n\n\n虽然是复用，可这里这么写有点奇怪\nimport &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport type &#123; SetStateAction &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport useUpdate from &quot;..&#x2F;useUpdate&quot;;\n\nexport interface Options&lt;T&gt; &#123;\n  defaultValue?: T;\n  defaultValuePropName?: string;\n  valuePropName?: string;\n  trigger?: string;\n&#125;\n\nexport type Props &#x3D; Record&lt;string, any&gt;;\n\nexport interface StandardProps&lt;T&gt; &#123;\n  value: T;\n  defaultValue?: T;\n  onChange: (val: T) &#x3D;&gt; void;\n&#125;\n\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props: StandardProps&lt;T&gt;\n): [T, (v: SetStateAction&lt;T&gt;) &#x3D;&gt; void];\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props?: Props,\n  options?: Options&lt;T&gt;\n): [T, (v: SetStateAction&lt;T&gt;, ...args: any[]) &#x3D;&gt; void];\nfunction useControllableValue&lt;T &#x3D; any&gt;(\n  props: Props &#x3D; &#123;&#125;,\n  options: Options&lt;T&gt; &#x3D; &#123;&#125;\n) &#123;\n  &#x2F;&#x2F; 这里一堆，是函数重写？\n  const &#123;\n    defaultValue,\n    defaultValuePropName &#x3D; &quot;defaultValue&quot;,\n    valuePropName &#x3D; &quot;value&quot;,\n    trigger &#x3D; &quot;onChange&quot;,\n  &#125; &#x3D; options;\n\n  const value &#x3D; props[valuePropName] as T;\n  &#x2F;&#x2F; options 默认情况， 如果 props 有 value 字段，则由父级接管控制 state\n  const isControlled &#x3D; props.hasOwnProperty(valuePropName);\n\n  const initialValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (isControlled) &#123;\n      &#x2F;&#x2F; 如果是受控，返回受控的value\n      return value;\n    &#125;\n    if (props.hasOwnProperty(defaultValuePropName)) &#123;\n      &#x2F;&#x2F; 非受控，props有默认值，返回默认值\n      return props[defaultValuePropName];\n    &#125;\n    return defaultValue;\n  &#125;, []);\n\n  const stateRef &#x3D; useRef(initialValue); &#x2F;&#x2F; 存的是父组件的值\n\n  if (isControlled) &#123;\n    stateRef.current &#x3D; value;\n  &#125;\n\n  const update &#x3D; useUpdate(); &#x2F;&#x2F; 上面了解到，该组件会强制react进行重渲染\n\n  &#x2F;&#x2F; options 默认情况，state变化时候，会触发onChange\n  function setState(v: SetStateAction&lt;T&gt;, ...args: any[]) &#123;\n    const r &#x3D; isFunction(v) ? v(stateRef.current) : v;\n\n    if (!isControlled) &#123;\n      &#x2F;&#x2F; 非受控，重渲染\n      stateRef.current &#x3D; r;\n      update();\n    &#125;\n    if (props[trigger]) &#123;\n      &#x2F;&#x2F; 有回调，执行回调\n      props[trigger](r, ...args);\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 返回存的值, 对setState进行缓存\n  return [stateRef.current, useMemoizedFn(setState)] as const;\n&#125;\n\nexport default useControllableValue;\n\nuseLatest闭包陷阱将值放到 ref 上，并返回，可以防“闭包陷阱”，\n见\n\n\n\n\n\n\n\n\n\nuseRef 每次 render 时都会返回同一个引用类型的对象，我们设置值和读取值都在这个对象上处理，这样就能获取到最新的 value 值了。“闭包陷阱” 最大的问题就是在函数数内无法获取的最新的 state 的值，那 React 提供了哪些方法来解决呢？\n\nuseRef 上面已有介绍\nuseState 更新值时传入回调函数\n\nimport &#123; useRef &#125; from &quot;react&quot;;\n\nfunction useLatest&lt;T&gt;(value: T) &#123;\n  const ref &#x3D; useRef(value);\n  ref.current &#x3D; value;\n\n  return ref;\n&#125;\n\nexport default useLatest;\n\nuseMemoizedFn\n2+版本，为usePersistFn, 使用时候最好，将这些 hooks 放到一个文件中作为引用的过度文件。以防以后全局搜 usePersistFn 替换为 useMemoizedFn\n\nuseMemoizedFn 如何实现 useCallback 效果，却不用使用第二参数 deps 呢？\nimport &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\ntype noop &#x3D; (this: any, ...args: any[]) &#x3D;&gt; any;\n\ntype PickFunction&lt;T extends noop&gt; &#x3D; (\n  this: ThisParameterType&lt;T&gt;,\n  ...args: Parameters&lt;T&gt;\n) &#x3D;&gt; ReturnType&lt;T&gt;;\n\nfunction useMemoizedFn&lt;T extends noop&gt;(fn: T) &#123;\n  const fnRef &#x3D; useRef&lt;T&gt;(fn);\n\n  &#x2F;&#x2F; why not write &#96;fnRef.current &#x3D; fn&#96;?\n  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;728\n  fnRef.current &#x3D; useMemo(() &#x3D;&gt; fn, [fn]); &#x2F;&#x2F; 为了兼容 react devtool\n\n  const memoizedFn &#x3D; useRef&lt;PickFunction&lt;T&gt;&gt;();\n\n  if (!memoizedFn.current) &#123;\n    &#x2F;&#x2F; 不存在，则重新生成函数， 这里用于缓存优化，但是函数执行的时候上下文中的参数是最新的，见下面模拟（出于这点，所以不需要deps）\n    memoizedFn.current &#x3D; function (this, ...args) &#123;\n      return fnRef.current.apply(this, args);\n    &#125;;\n  &#125;\n\n  return memoizedFn.current as T;\n&#125;\n\nexport default useMemoizedFn;\n\n模拟函数声明，函数内变量更新\n\n\nuseToggleimport &#123; useMemo, useState &#125; from &quot;react&quot;;\n\nexport interface Actions&lt;T&gt; &#123;\n  setLeft: () &#x3D;&gt; void;\n  setRight: () &#x3D;&gt; void;\n  set: (value: T) &#x3D;&gt; void;\n  toggle: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; 1\nfunction useToggle&lt;T &#x3D; boolean&gt;(): [boolean, Actions&lt;T&gt;];\n&#x2F;&#x2F; 2\nfunction useToggle&lt;T&gt;(defaultValue: T): [T, Actions&lt;T&gt;];\n&#x2F;&#x2F; 3\nfunction useToggle&lt;T, U&gt;(\n  defaultValue: T,\n  reverseValue: U\n): [T | U, Actions&lt;T | U&gt;];\n&#x2F;&#x2F; 4\nfunction useToggle&lt;D, R&gt;(\n  defaultValue: D &#x3D; false as unknown as D,\n  reverseValue?: R\n) &#123;\n  &#x2F;&#x2F; 可以理解为缓存吧\n  const [state, setState] &#x3D; useState&lt;D | R&gt;(defaultValue);\n\n  const actions &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 最初的相反值 &#x3D; 设置的相反值 or 是初始值的取反\n    const reverseValueOrigin &#x3D; (\n      reverseValue &#x3D;&#x3D;&#x3D; undefined ? !defaultValue : reverseValue\n    ) as D | R;\n    &#x2F;&#x2F; 默认值取反\n    const toggle &#x3D; () &#x3D;&gt;\n      setState((s) &#x3D;&gt; (s &#x3D;&#x3D;&#x3D; defaultValue ? reverseValueOrigin : defaultValue));\n    &#x2F;&#x2F; 设置值\n    const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);\n    &#x2F;&#x2F; 设置初始值\n    const setLeft &#x3D; () &#x3D;&gt; setState(defaultValue);\n    &#x2F;&#x2F; 设置为相反值\n    const setRight &#x3D; () &#x3D;&gt; setState(reverseValueOrigin);\n    &#x2F;&#x2F; 这就有点意思了，左边右边，反过来，再翻过去，刚好 toggle\n    return &#123;\n      toggle,\n      set,\n      setLeft,\n      setRight,\n    &#125;;\n    &#x2F;&#x2F; useToggle ignore value change\n    &#x2F;&#x2F; &#125;, [defaultValue, reverseValue]);\n  &#125;, []);\n\n  return [state, actions &#x2F;**这里是对象，却用了s结尾，乍一看还以为数组 *&#x2F;];\n&#125;\n\nexport default useToggle;\n\nuseBooleanimport &#123; useMemo &#125; from &quot;react&quot;;\nimport useToggle from &quot;..&#x2F;useToggle&quot;;\n\n&#x2F;&#x2F; 这里与 useToggle很像\nexport interface Actions &#123;\n  setTrue: () &#x3D;&gt; void;\n  setFalse: () &#x3D;&gt; void;\n  set: (value: boolean) &#x3D;&gt; void;\n  toggle: () &#x3D;&gt; void;\n&#125;\n\n&#x2F;&#x2F; 主要用toggle整了点事，然后暴露更具有语义话的api\nexport default function useBoolean(defaultValue &#x3D; false): [boolean, Actions] &#123;\n  const [state, &#123; toggle, set &#125;] &#x3D; useToggle(defaultValue);\n\n  const actions: Actions &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);\n    const setTrue &#x3D; () &#x3D;&gt; set(true);\n    const setFalse &#x3D; () &#x3D;&gt; set(false);\n    return &#123;\n      toggle,\n      set: (v) &#x3D;&gt; set(!!v),\n      setTrue,\n      setFalse,\n    &#125;;\n  &#125;, []);\n\n  return [state, actions];\n&#125;\n\nuseMountimport &#123; useEffect &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\nconst useMount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 删减\n  useEffect(() &#x3D;&gt; &#123;\n    fn?.();\n  &#125;, []);\n&#125;;\n\nexport default useMount;\n\nuseUnmountimport &#123; useEffect &#125; from &quot;react&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\n\nconst useUnmount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 删减\n  const fnRef &#x3D; useLatest(fn);\n\n  useEffect(\n    () &#x3D;&gt; () &#x3D;&gt; &#123;\n      fnRef.current();\n    &#125;,\n    []\n  );\n&#125;;\n\nexport default useUnmount;\n\nuseUnmountedRef\n\n\n\n\n\n\n\n\n获取当前组件是否已经卸载的 Hook。\n什么业务场景会使用？？\nimport &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\nconst useUnmountedRef &#x3D; () &#x3D;&gt; &#123;\n  const unmountedRef &#x3D; useRef(false); &#x2F;&#x2F; 默认没有卸载\n  useEffect(() &#x3D;&gt; &#123;\n    unmountedRef.current &#x3D; false; &#x2F;&#x2F; 挂载\n    return () &#x3D;&gt; &#123;\n      unmountedRef.current &#x3D; true; &#x2F;&#x2F; 卸载\n    &#125;;\n  &#125;, []);\n  return unmountedRef;\n&#125;;\n\nexport default useUnmountedRef;\n\nuseUpdateEffect (有依赖项)\n\n\n\n\n\n\n\n\nuseUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。\n如何实现忽略首次执行的\nimport &#123; useEffect &#125; from &quot;react&quot;;\nimport &#123; createUpdateEffect &#125; from &quot;..&#x2F;createUpdateEffect&quot;; &#x2F;&#x2F; 见下面源码\n\nexport default createUpdateEffect(useEffect);\n\ncreateUpdateEffectimport &#123; useRef &#125; from &quot;react&quot;;\nimport type &#123; useEffect, useLayoutEffect &#125; from &quot;react&quot;;\n\ntype EffectHookType &#x3D; typeof useEffect | typeof useLayoutEffect;\n\n&#x2F;&#x2F; export const createUpdateEffect: (hook: EffectHookType) &#x3D;&gt; EffectHookType &#x3D; (hook) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;\nexport const createUpdateEffect &#x3D; (hook &#x2F;** useEffect *&#x2F;) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 柯里化\n  const isMounted &#x3D; useRef(false);\n\n  &#x2F;&#x2F; for react-refresh react刷新时候执行卸载\n  hook(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F;卸载\n    return () &#x3D;&gt; &#123;\n      isMounted.current &#x3D; false;\n    &#125;;\n  &#125;, []);\n\n  hook(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 挂在\n    if (!isMounted.current) &#123;\n      &#x2F;&#x2F; 非第一次， isMounted.current &#x3D; true , 此时走  effect()\n      isMounted.current &#x3D; true;\n    &#125; else &#123;\n      return effect();\n    &#125;\n  &#125;, deps);\n&#125;;\n\nexport default createUpdateEffect;\n\nuseHistoryTravel\n\n\n\n\n\n\n\n\n管理状态历史变化记录，方便在历史记录中前进与后退。\nimport &#123; useRef, useState &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport &#123; isNumber &#125; from &quot;..&#x2F;utils&quot;;\n\ninterface IData&lt;T&gt; &#123;\n  present?: T;\n  past: T[];\n  future: T[];\n&#125;\n\nconst dumpIndex &#x3D; &lt;T&gt;(step: number, arr: T[]) &#x3D;&gt; &#123;\n  let index &#x3D;\n    step &gt; 0\n      ? step - 1 &#x2F;&#x2F; move forward\n      : arr.length + step; &#x2F;&#x2F; move backward\n  if (index &gt;&#x3D; arr.length - 1) &#123;\n    index &#x3D; arr.length - 1;\n  &#125;\n  if (index &lt; 0) &#123;\n    index &#x3D; 0;\n  &#125;\n  return index;\n&#125;;\n\nconst split &#x3D; &lt;T&gt;(step: number, targetArr: T[]) &#x3D;&gt; &#123;\n  const index &#x3D; dumpIndex(step, targetArr);\n  return &#123;\n    _current: targetArr[index],\n    _before: targetArr.slice(0, index),\n    _after: targetArr.slice(index + 1),\n  &#125;;\n&#125;;\n\nexport default function useHistoryTravel&lt;T&gt;(initialValue?: T) &#123;\n  const [history, setHistory] &#x3D; useState&lt;IData&lt;T | undefined&gt;&gt;(&#123;\n    present: initialValue, &#x2F;&#x2F; 当前\n    past: [], &#x2F;&#x2F; 历史记录\n    future: [], &#x2F;&#x2F; 未来记录\n  &#125;);\n\n  const &#123; present, past, future &#125; &#x3D; history;\n\n  const initialValueRef &#x3D; useRef(initialValue);\n\n  const reset &#x3D; (...params: any[]) &#x3D;&gt; &#123;\n    const _initial &#x3D; params.length &gt; 0 ? params[0] : initialValueRef.current;\n    initialValueRef.current &#x3D; _initial;\n\n    setHistory(&#123;\n      present: _initial,\n      future: [],\n      past: [],\n    &#125;);\n  &#125;;\n\n  const updateValue &#x3D; (val: T) &#x3D;&gt; &#123;\n    setHistory(&#123;\n      present: val,\n      future: [],\n      past: [...past, present],\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 向前\n  const _forward &#x3D; (step: number &#x3D; 1) &#x3D;&gt; &#123;\n    if (future.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n    const &#123; _before, _current, _after &#125; &#x3D; split(step, future);\n    setHistory(&#123;\n      past: [...past, present, ..._before],\n      present: _current,\n      future: _after,\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 向后\n  const _backward &#x3D; (step: number &#x3D; -1) &#x3D;&gt; &#123;\n    if (past.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n\n    const &#123; _before, _current, _after &#125; &#x3D; split(step, past);\n    setHistory(&#123;\n      past: _before,\n      present: _current,\n      future: [..._after, present, ...future],\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 可进，可退，可不动\n  const go &#x3D; (step: number) &#x3D;&gt; &#123;\n    const stepNum &#x3D; isNumber(step) ? step : Number(step);\n    if (stepNum &#x3D;&#x3D;&#x3D; 0) &#123;\n      return;\n    &#125;\n    if (stepNum &gt; 0) &#123;\n      return _forward(stepNum);\n    &#125;\n    _backward(stepNum);\n  &#125;;\n\n  return &#123;\n    value: present, &#x2F;&#x2F; 当前\n    backLength: past.length, &#x2F;&#x2F; 可后退长度\n    forwardLength: future.length, &#x2F;&#x2F; 可前进长度\n    setValue: useMemoizedFn(updateValue), &#x2F;&#x2F; 跳转到哪个记录\n    go: useMemoizedFn(go), &#x2F;&#x2F; 回退到哪个\n    back: useMemoizedFn(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 回退一个\n      go(-1);\n    &#125;),\n    forward: useMemoizedFn(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 前进一个\n      go(1);\n    &#125;),\n    reset: useMemoizedFn(reset), &#x2F;&#x2F; 重置\n  &#125;;\n&#125;\n\nuseInfiniteScrolluseInfiniteScroll 封装了常见的无限滚动逻辑。\nconst &#123; data, loading, loadingMore, loadMore &#125; &#x3D; useInfiniteScroll(service);\n\nuseInfiniteScroll 的第一个参数 service 是一个异步函数，对这个函数的入参和出参有如下 约定：\nservice 返回的数据必须包含 list 数组，类型为 &#123; list: any[], ...rest &#125;service 的入参为整合后的最新 data假如第一次请求返回数据为 &#123; list: [1, 2, 3], nextId: 4 &#125;, 第二次返回的数据为 &#123; list: [4, 5, 6], nextId: 7 &#125;, 则我们会自动合并 list，整合后的的 data 为 &#123; list: [1, 2, 3, 4, 5, 6], nextId: 7 &#125;。\nimport &#123; useMemo, useState &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;; &#x2F;&#x2F; 简化版useCallback\nimport useRequest from &quot;..&#x2F;useRequest&quot;; &#x2F;&#x2F; 请求封装的hook\n&#x2F;&#x2F; useUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。\nimport useUpdateEffect from &quot;..&#x2F;useUpdateEffect&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getClientHeight, getScrollHeight, getScrollTop &#125; from &quot;..&#x2F;utils&#x2F;rect&quot;;\nimport type &#123; Data, InfiniteScrollOptions, Service &#125; from &quot;.&#x2F;types&quot;;\n\nconst useInfiniteScroll &#x3D; &lt;TData extends Data&gt;(\n  service: Service&lt;TData&gt;,\n  options: InfiniteScrollOptions&lt;TData&gt; &#x3D; &#123;&#125;\n) &#x3D;&gt; &#123;\n  const &#123;\n    target,\n    isNoMore,\n    threshold &#x3D; 100,\n    reloadDeps &#x3D; [],\n    manual,\n    onBefore,\n    onSuccess,\n    onError,\n    onFinally,\n  &#125; &#x3D; options;\n\n  const [finalData, setFinalData] &#x3D; useState&lt;TData&gt;();\n  const [loadingMore, setLoadingMore] &#x3D; useState(false);\n\n  const noMore &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (!isNoMore) return false;\n    return isNoMore(finalData);\n  &#125;, [finalData]);\n\n  const &#123; loading, run, runAsync, cancel &#125; &#x3D; useRequest(\n    async (lastData?: TData) &#x3D;&gt; &#123;\n      const currentData &#x3D; await service(lastData);\n      if (!lastData) &#123;\n        setFinalData(currentData);\n      &#125; else &#123;\n        setFinalData(&#123;\n          ...currentData,\n          &#x2F;&#x2F; @ts-ignore\n          list: [...lastData.list, ...currentData.list],\n        &#125;);\n      &#125;\n      return currentData;\n    &#125;,\n    &#123;\n      manual,\n      onFinally: (_, d, e) &#x3D;&gt; &#123;\n        setLoadingMore(false);\n        onFinally?.(d, e);\n      &#125;,\n      onBefore: () &#x3D;&gt; onBefore?.(),\n      onSuccess: (d) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n          &#x2F;&#x2F; eslint-disable-next-line @typescript-eslint&#x2F;no-use-before-define\n          scrollMethod();\n        &#125;);\n        onSuccess?.(d);\n      &#125;,\n      onError: (e) &#x3D;&gt; onError?.(e),\n    &#125;\n  );\n\n  const loadMore &#x3D; () &#x3D;&gt; &#123;\n    if (noMore) return;\n    setLoadingMore(true);\n    run(finalData);\n  &#125;;\n\n  const loadMoreAsync &#x3D; () &#x3D;&gt; &#123;\n    if (noMore) return Promise.reject();\n    setLoadingMore(true);\n    return runAsync(finalData);\n  &#125;;\n\n  const reload &#x3D; () &#x3D;&gt; run();\n  const reloadAsync &#x3D; () &#x3D;&gt; runAsync();\n\n  &#x2F;&#x2F; scrollMethod会尝试去检测是否满足加载条件\n  const scrollMethod &#x3D; () &#x3D;&gt; &#123;\n    const el &#x3D; getTargetElement(target);\n    if (!el) &#123;\n      return;\n    &#125;\n\n    const scrollTop &#x3D; getScrollTop(el);\n    const scrollHeight &#x3D; getScrollHeight(el);\n    const clientHeight &#x3D; getClientHeight(el);\n\n    if (scrollHeight - scrollTop &lt;&#x3D; clientHeight + threshold) &#123;\n      loadMore();\n    &#125;\n  &#125;;\n  &#x2F;&#x2F; 监听滚动，加载中的会被拦掉，\n  useEventListener(\n    &quot;scroll&quot;,\n    () &#x3D;&gt; &#123;\n      if (loading || loadingMore) &#123;\n        return;\n      &#125;\n      scrollMethod();\n    &#125;,\n    &#123; target &#125;\n  );\n\n  useUpdateEffect(() &#x3D;&gt; &#123;\n    run();\n  &#125;, [...reloadDeps]);\n\n  return &#123;\n    &#x2F;&#x2F; 数据\n    data: finalData,\n    loading: !loadingMore &amp;&amp; loading,\n    loadingMore,\n    noMore,\n    &#x2F;&#x2F; 一些方法\n    loadMore: useMemoizedFn(loadMore),\n    loadMoreAsync: useMemoizedFn(loadMoreAsync),\n    &#x2F;&#x2F; 这两个声明的函数直接返回\n    &#x2F;&#x2F; const reload &#x3D; () &#x3D;&gt; run();\n    &#x2F;&#x2F; const reloadAsync &#x3D; () &#x3D;&gt; runAsync();\n    reload: useMemoizedFn(reload),\n    reloadAsync: useMemoizedFn(reloadAsync),\n    mutate &#x2F;**数据突变 *&#x2F;: setFinalData,\n    cancel,\n  &#125;;\n&#125;;\n\nexport default useInfiniteScroll;\n\ngetTargetElementimport type &#123; MutableRefObject &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;.&#x2F;index&quot;;\nimport isBrowser from &quot;.&#x2F;isBrowser&quot;;\n\ntype TargetValue&lt;T&gt; &#x3D; T | undefined | null;\n\ntype TargetType &#x3D; HTMLElement | Element | Window | Document;\n\nexport type BasicTarget&lt;T extends TargetType &#x3D; Element&gt; &#x3D;\n  | (() &#x3D;&gt; TargetValue&lt;T&gt;) &#x2F;&#x2F; 函数\n  | TargetValue&lt;T&gt; &#x2F;&#x2F; 直接dom\n  | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;; &#x2F;&#x2F; ref\n\nexport function getTargetElement&lt;T extends TargetType&gt;(\n  target: BasicTarget&lt;T&gt;,\n  defaultElement?: T\n) &#123;\n  &#x2F;&#x2F; 服务端渲染情况\n  if (!isBrowser) &#123;\n    return undefined;\n  &#125;\n  &#x2F;&#x2F; 假设，一定存在\n  if (!target) &#123;\n    return defaultElement;\n  &#125;\n\n  let targetElement: TargetValue&lt;T&gt;;\n  &#x2F;&#x2F; 函数\n  if (isFunction(target)) &#123;\n    targetElement &#x3D; target();\n    &#x2F;&#x2F; ref\n  &#125; else if (&quot;current&quot; in target) &#123;\n    targetElement &#x3D; target.current;\n    &#x2F;&#x2F; 直接dom\n  &#125; else &#123;\n    targetElement &#x3D; target;\n  &#125;\n\n  return targetElement;\n&#125;\n\ngetClientHeight, getScrollHeight, getScrollTop使用Math.max，对 rect 的计算进行兼容性处理\nconst getScrollTop &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  if (el &#x3D;&#x3D;&#x3D; document || el &#x3D;&#x3D;&#x3D; document.body) &#123;\n    &#x2F;&#x2F; 处理浏览器兼容性\n    &#x2F;&#x2F; IE6&#x2F;7&#x2F;8：\n    &#x2F;&#x2F; 可以使用 document.documentElement.scrollTop；\n    &#x2F;&#x2F; IE9及以上：\n    &#x2F;&#x2F; 可以使用window.pageYOffset或者document.documentElement.scrollTop\n    &#x2F;&#x2F; Safari:\n    &#x2F;&#x2F; safari： window.pageYOffset 与document.body.scrollTop都可以；\n    &#x2F;&#x2F; Firefox:\n    &#x2F;&#x2F; 火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset 或者 document.documentElement.scrollTop ；\n    &#x2F;&#x2F; Chrome：\n    &#x2F;&#x2F; 谷歌浏览器只认识document.body.scrollTop;\n    return Math.max(\n      window.pageYOffset,\n      document.documentElement.scrollTop,\n      document.body.scrollTop\n    );\n  &#125;\n  return (el as Element).scrollTop;\n&#125;;\n\n\n\nJS 基础篇– body.scrollTop 与 documentElement.scrollTop\nconst getScrollHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  return (\n    (el as Element).scrollHeight ||\n    Math.max(document.documentElement.scrollHeight, document.body.scrollHeight)\n  );\n&#125;;\n\nconst getClientHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;\n  return (\n    (el as Element).clientHeight ||\n    Math.max(document.documentElement.clientHeight, document.body.clientHeight)\n  );\n&#125;;\n\nexport &#123; getScrollTop, getScrollHeight, getClientHeight &#125;;\n\nuseEventListenerimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\ntype noop &#x3D; (...p: any) &#x3D;&gt; void;\n\nexport type Target &#x3D; BasicTarget&lt;HTMLElement | Element | Window | Document&gt;;\n\ntype Options&lt;T extends Target &#x3D; Target&gt; &#x3D; &#123;\n  target?: T;\n  capture?: boolean;\n  once?: boolean;\n  passive?: boolean;\n&#125;;\n\nfunction useEventListener&lt;K extends keyof HTMLElementEventMap&gt;(\n  eventName: K,\n  handler: (ev: HTMLElementEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;HTMLElement&gt;\n): void;\nfunction useEventListener&lt;K extends keyof ElementEventMap&gt;(\n  eventName: K,\n  handler: (ev: ElementEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Element&gt;\n): void;\nfunction useEventListener&lt;K extends keyof DocumentEventMap&gt;(\n  eventName: K,\n  handler: (ev: DocumentEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Document&gt;\n): void;\nfunction useEventListener&lt;K extends keyof WindowEventMap&gt;(\n  eventName: K,\n  handler: (ev: WindowEventMap[K]) &#x3D;&gt; void,\n  options?: Options&lt;Window&gt;\n): void;\nfunction useEventListener(\n  eventName: string,\n  handler: noop,\n  options: Options\n): void;\n\nfunction useEventListener(\n  eventName: string,\n  handler: noop,\n  options: Options &#x3D; &#123;&#125;\n) &#123;\n  const handlerRef &#x3D; useLatest(handler);\n\n  useEffectWithTarget(\n    &#x2F;&#x2F; 做了缓存\n    &#x2F;&#x2F; effect\n    () &#x3D;&gt; &#123;\n      const targetElement &#x3D; getTargetElement(options.target, window);\n      if (!targetElement?.addEventListener) &#123;\n        return;\n      &#125;\n\n      const eventListener &#x3D; (event: Event) &#x3D;&gt; &#123;\n        return handlerRef.current(event);\n      &#125;;\n\n      targetElement.addEventListener(eventName, eventListener, &#123;\n        capture: options.capture,\n        once: options.once,\n        passive: options.passive,\n      &#125;);\n\n      return () &#x3D;&gt; &#123;\n        targetElement.removeEventListener(eventName, eventListener, &#123;\n          capture: options.capture,\n        &#125;);\n      &#125;;\n    &#125;,\n    &#x2F;&#x2F; deps 依赖项\n    [eventName, options.capture, options.once, options.passive],\n    &#x2F;&#x2F; target\n    options.target\n  );\n&#125;\n\nexport default useEventListener;\n\nuseEffectWithTargetimport &#123; useEffect &#125; from &quot;react&quot;;\nimport createEffectWithTarget from &quot;.&#x2F;createEffectWithTarget&quot;;\n&#x2F;&#x2F; createEffectWithTarget将useEffect进行包裹\nconst useEffectWithTarget &#x3D; createEffectWithTarget(useEffect);\n\nexport default useEffectWithTarget;\n\ncreateEffectWithTargetimport type &#123;\n  DependencyList,\n  EffectCallback,\n  useEffect,\n  useLayoutEffect,\n&#125; from &quot;react&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\nimport depsAreSame from &quot;.&#x2F;depsAreSame&quot;;\nimport type &#123; BasicTarget &#125; from &quot;.&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;.&#x2F;domTarget&quot;;\n\nconst createEffectWithTarget &#x3D; (\n  useEffectType: typeof useEffect | typeof useLayoutEffect\n) &#x3D;&gt; &#123;\n  &#x2F;**\n   *\n   * @param effect\n   * @param deps\n   * @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom\n   *&#x2F;\n  const useEffectWithTarget &#x3D; (\n    effect: EffectCallback,\n    deps: DependencyList,\n    target: BasicTarget&lt;any&gt; | BasicTarget&lt;any&gt;[]\n  ) &#x3D;&gt; &#123;\n    const hasInitRef &#x3D; useRef(false);\n\n    const lastElementRef &#x3D; useRef&lt;(Element | null)[]&gt;([]);\n    const lastDepsRef &#x3D; useRef&lt;DependencyList&gt;([]);\n\n    const unLoadRef &#x3D; useRef&lt;any&gt;();\n    &#x2F;&#x2F; 类型 useEffectType: typeof useEffect | typeof useLayoutEffect\n    useEffectType(() &#x3D;&gt; &#123;\n      const targets &#x3D; Array.isArray(target) ? target : [target];\n      const els &#x3D; targets.map((item) &#x3D;&gt; getTargetElement(item));\n\n      &#x2F;&#x2F; init run\n      if (!hasInitRef.current) &#123;\n        hasInitRef.current &#x3D; true;\n        lastElementRef.current &#x3D; els;\n        lastDepsRef.current &#x3D; deps;\n\n        unLoadRef.current &#x3D; effect(); &#x2F;&#x2F; 执行结果\n        return;\n      &#125;\n      &#x2F;&#x2F; 如上文注释： @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom\n      &#x2F;&#x2F; 存在不等情况会执行赋值\n      if (\n        els.length !&#x3D;&#x3D; lastElementRef.current.length ||\n        !depsAreSame(els, lastElementRef.current) ||\n        !depsAreSame(deps, lastDepsRef.current)\n      ) &#123;\n        unLoadRef.current?.(); &#x2F;&#x2F; 执行\n\n        lastElementRef.current &#x3D; els;\n        lastDepsRef.current &#x3D; deps;\n        unLoadRef.current &#x3D; effect();\n      &#125;\n    &#125;);\n    &#x2F;&#x2F; 卸载\n    useUnmount(() &#x3D;&gt; &#123;\n      unLoadRef.current?.();\n      &#x2F;&#x2F; for react-refresh\n      hasInitRef.current &#x3D; false;\n    &#125;);\n  &#125;;\n\n  return useEffectWithTarget;\n&#125;;\n\nexport default createEffectWithTarget;\n\nuseWhyDidYouUpdate见\n原理：useEffect 在组件更新时候会执行， 将之前的 props 存在 ref 上，之后会将所有的 key 比较，找到变更的 key 的 changedProps\nimport &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\nexport type IProps &#x3D; Record&lt;string, any&gt;;\n\nexport default function useWhyDidYouUpdate(\n  componentName: string,\n  props: IProps\n) &#123;\n  const prevProps &#x3D; useRef&lt;IProps&gt;(&#123;&#125;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (prevProps.current) &#123;\n      const allKeys &#x3D; Object.keys(&#123; ...prevProps.current, ...props &#125;);\n      const changedProps: IProps &#x3D; &#123;&#125;;\n\n      allKeys.forEach((key) &#x3D;&gt; &#123;\n        if (!Object.is(prevProps.current[key], props[key])) &#123;\n          changedProps[key] &#x3D; &#123;\n            from: prevProps.current[key],\n            to: props[key],\n          &#125;;\n        &#125;\n      &#125;);\n\n      if (Object.keys(changedProps).length) &#123;\n        console.log(&quot;[why-did-you-update]&quot;, componentName, changedProps);\n      &#125;\n    &#125;\n\n    prevProps.current &#x3D; props;\n  &#125;);\n&#125;\n\nuseUrlStateimport &#123; useMemoizedFn, useUpdate &#125; from &quot;ahooks&quot;;\nimport &#123; parse, stringify &#125; from &quot;query-string&quot;;\nimport type &#123; ParseOptions, StringifyOptions &#125; from &quot;query-string&quot;;\nimport &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport type * as React from &quot;react&quot;;\nimport * as tmp from &quot;react-router&quot;;\n\n&#x2F;&#x2F; ignore waring &#96;&quot;export &#39;useNavigate&#39; (imported as &#39;rc&#39;) was not found in &#39;react-router&#39;&#96;\nconst rc &#x3D; tmp as any;\n\nexport interface Options &#123;\n  navigateMode?: &quot;push&quot; | &quot;replace&quot;;\n  parseOptions?: ParseOptions;\n  stringifyOptions?: StringifyOptions;\n&#125;\n\nconst baseParseConfig: ParseOptions &#x3D; &#123;\n  parseNumbers: false,\n  parseBooleans: false,\n&#125;;\n\nconst baseStringifyConfig: StringifyOptions &#x3D; &#123;\n  skipNull: false,\n  skipEmptyString: false,\n&#125;;\n\ntype UrlState &#x3D; Record&lt;string, any&gt;;\n\nconst useUrlState &#x3D; &lt;S extends UrlState &#x3D; UrlState&gt;(\n  initialState?: S | (() &#x3D;&gt; S),\n  options?: Options\n) &#x3D;&gt; &#123;\n  type State &#x3D; Partial&lt;&#123; [key in keyof S]: any &#125;&gt;;\n  const &#123;\n    navigateMode &#x3D; &quot;push&quot;, &#x2F;&#x2F; 状态变更时切换 history 的方式\n    parseOptions,\n    stringifyOptions,\n  &#125; &#x3D; options || &#123;&#125;;\n\n  const mergedParseOptions &#x3D; &#123; ...baseParseConfig, ...parseOptions &#125;;\n  const mergedStringifyOptions &#x3D; &#123;\n    ...baseStringifyConfig,\n    ...stringifyOptions,\n  &#125;;\n\n  const location &#x3D; rc.useLocation();\n\n  &#x2F;&#x2F; react-router v5\n  const history &#x3D; rc.useHistory?.();\n  &#x2F;&#x2F; react-router v6\n  const navigate &#x3D; rc.useNavigate?.();\n\n  const update &#x3D; useUpdate();\n\n  const initialStateRef &#x3D; useRef(\n    typeof initialState &#x3D;&#x3D;&#x3D; &quot;function&quot;\n      ? (initialState as () &#x3D;&gt; S)()\n      : initialState || &#123;&#125;\n  );\n  &#x2F;&#x2F; 解析出 query\n  const queryFromUrl &#x3D; useMemo(() &#x3D;&gt; &#123;\n    return parse(location.search, mergedParseOptions);\n  &#125;, [location.search]);\n\n  &#x2F;&#x2F; 更改后的 query\n  const targetQuery: State &#x3D; useMemo(\n    () &#x3D;&gt; (&#123;\n      ...initialStateRef.current,\n      ...queryFromUrl,\n    &#125;),\n    [queryFromUrl]\n  );\n\n  const setState &#x3D; (s: React.SetStateAction&lt;State&gt;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果是函数，则将上一个值，作为参数传入\n    const newQuery &#x3D; typeof s &#x3D;&#x3D;&#x3D; &quot;function&quot; ? s(targetQuery) : s;\n\n    &#x2F;&#x2F; 1. 如果 setState 后，search 没变化，就需要 update 来触发一次更新。比如 demo1 直接点击 clear，就需要 update 来触发更新。\n    &#x2F;&#x2F; 2. update 和 history 的更新会合并，不会造成多次更新\n    update(); &#x2F;&#x2F; 担心不更新\n    if (history) &#123;\n      history[navigateMode](&#123;\n        hash: location.hash,\n        search:\n          stringify(&#123; ...queryFromUrl, ...newQuery &#125;, mergedStringifyOptions) ||\n          &quot;?&quot;,\n      &#125;);\n    &#125;\n    if (navigate) &#123;\n      navigate(\n        &#123;\n          hash: location.hash,\n          search:\n            stringify(\n              &#123; ...queryFromUrl, ...newQuery &#125;,\n              mergedStringifyOptions\n            ) || &quot;?&quot;,\n        &#125;,\n        &#123;\n          replace: navigateMode &#x3D;&#x3D;&#x3D; &quot;replace&quot;,\n        &#125;\n      );\n    &#125;\n  &#125;;\n\n  return [targetQuery &#x2F;**url query 对象 *&#x2F;, useMemoizedFn(setState)] as const;\n&#125;;\n\nexport default useUrlState;\n\nuseSafeState\n\n\n\n\n\n\n\n\n用法与 React.useState 完全一样，但是在组件卸载后异步回调内的 setState 不再执行，避免因组件卸载后更新状态而导致的内存泄漏。\nimport &#123; useCallback, useState &#125; from &quot;react&quot;;\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\n&#x2F;&#x2F; &gt; 获取当前组件是否已经卸载的 Hook。\nimport useUnmountedRef from &quot;..&#x2F;useUnmountedRef&quot;;\n\nfunction useSafeState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];\n\nfunction useSafeState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;\n];\n\nfunction useSafeState&lt;S&gt;(initialState?: S | (() &#x3D;&gt; S)) &#123;\n  const unmountedRef &#x3D; useUnmountedRef();\n  const [state, setState] &#x3D; useState(initialState);\n  const setCurrentState &#x3D; useCallback((currentState) &#x3D;&gt; &#123;\n    &#x2F;** if component is unmounted, stop update *&#x2F;\n    &#x2F;&#x2F; 组件卸载停止更新\n    if (unmountedRef.current) return;\n    setState(currentState);\n  &#125;, []);\n\n  return [state, setCurrentState] as const;\n&#125;\n\nexport default useSafeState;\n\nuseGetState内部使用 useRef 缓存了值，在调用 getState 时候，将 ref 值返回.\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;\n\ntype GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;\n\nfunction useGetState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];\nfunction useGetState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,\n  GetStateAction&lt;S | undefined&gt;\n];\nfunction useGetState&lt;S&gt;(initialState?: S) &#123;\n  const [state, setState] &#x3D; useState(initialState);\n\n  const stateRef &#x3D; useRef(state);\n  stateRef.current &#x3D; state;\n\n  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);\n\n  return [state, setState, getState];\n&#125;\n\nexport default useGetState;\n\nuseResetStateinitialState的值，用于重置\nimport &#123; useState &#125; from &quot;react&quot;;\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\n\ntype ResetState &#x3D; () &#x3D;&gt; void;\n\nconst useResetState &#x3D; &lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, ResetState] &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(initialState);\n\n  const resetState &#x3D; useMemoizedFn(() &#x3D;&gt; &#123;\n    setState(initialState);\n  &#125;);\n\n  return [state, setState, resetState];\n&#125;;\n\nexport default useResetState;\n\nuseRafState\n\n\n\n\n\n\n\n\n只在 requestAnimationFrame callback 时更新 state，一般用于性能优化。\nimport &#123; useCallback, useRef, useState &#125; from &quot;react&quot;;\nimport type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\n\nfunction useRafState&lt;S&gt;(\n  initialState: S | (() &#x3D;&gt; S)\n): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];\nfunction useRafState&lt;S &#x3D; undefined&gt;(): [\n  S | undefined,\n  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;\n];\n\nfunction useRafState&lt;S&gt;(initialState?: S | (() &#x3D;&gt; S)) &#123;\n  &#x2F;&#x2F; 先前调用window.requestAnimationFrame()方法时返回的 ID.\n  const ref &#x3D; useRef(0); &#x2F;&#x2F; requestID\n  const [state, setState] &#x3D; useState(initialState);\n\n  const setRafState &#x3D; useCallback((value: S | ((prevState: S) &#x3D;&gt; S)) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; cancelAnimationFrame 取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。\n    cancelAnimationFrame(ref.current &#x2F;**requestID *&#x2F;);\n\n    ref.current &#x3D; requestAnimationFrame(() &#x3D;&gt; &#123;\n      setState(value);\n    &#125;);\n  &#125;, []);\n\n  &#x2F;&#x2F; 卸载，取消动画镇\n  useUnmount(() &#x3D;&gt; &#123;\n    cancelAnimationFrame(ref.current &#x2F;**requestID *&#x2F;);\n  &#125;);\n\n  return [state, setRafState] as const;\n&#125;\n\nexport default useRafState;\n\nusePrevious先猜下，又用了 ref 进行缓存\n悄悄源码\nimport &#123; useRef &#125; from &quot;react&quot;;\n\nexport type ShouldUpdateFunc&lt;T&gt; &#x3D; (prev: T | undefined, next: T) &#x3D;&gt; boolean;\n\nconst defaultShouldUpdate &#x3D; &lt;T&gt;(a?: T, b?: T) &#x3D;&gt; !Object.is(a, b); &#x2F;&#x2F; 默认比较\n\nfunction usePrevious&lt;T&gt;(\n  state: T,\n  shouldUpdate: ShouldUpdateFunc&lt;T&gt; &#x3D; defaultShouldUpdate\n): T | undefined &#123;\n  const prevRef &#x3D; useRef&lt;T&gt;(); &#x2F;&#x2F; 存前一个\n  const curRef &#x3D; useRef&lt;T&gt;(); &#x2F;&#x2F; 存当前，🤔，存当前的，相当于中介，如：把两瓶水交换，借助第三个瓶子\n\n  if (shouldUpdate(curRef.current, state)) &#123;\n    &#x2F;&#x2F; 不一样，更新值\n    prevRef.current &#x3D; curRef.current;\n    curRef.current &#x3D; state;\n  &#125;\n\n  return prevRef.current; &#x2F;&#x2F; 最终返回之前的值\n&#125;\n\nexport default usePrevious;\n\nuseMapimport &#123; useState &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\n\nfunction useMap&lt;K, T&gt;(initialValue?: Iterable&lt;readonly [K, T]&gt;) &#123;\n  &#x2F;&#x2F; 初始值\n  const getInitValue &#x3D; () &#x3D;&gt; &#123;\n    return initialValue &#x3D;&#x3D;&#x3D; undefined ? new Map() : new Map(initialValue);\n  &#125;;\n\n  const [map, setMap] &#x3D; useState&lt;Map&lt;K, T&gt;&gt;(() &#x3D;&gt; getInitValue());\n\n  &#x2F;&#x2F; 设置， 新旧合并，新的属性会覆盖旧的\n  const set &#x3D; (key: K, entry: T) &#x3D;&gt; &#123;\n    setMap((prev) &#x3D;&gt; &#123;\n      const temp &#x3D; new Map(prev); &#x2F;&#x2F; 将之前的值拷贝，切断 temp 与 prev之间联系？\n      temp.set(key, entry);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 完全重新赋值\n  const setAll &#x3D; (newMap: Iterable&lt;readonly [K, T]&gt;) &#x3D;&gt; &#123;\n    setMap(new Map(newMap));\n  &#125;;\n  &#x2F;&#x2F; 删除某个key对应的值\n  const remove &#x3D; (key: K) &#x3D;&gt; &#123;\n    setMap((prev) &#x3D;&gt; &#123;\n      const temp &#x3D; new Map(prev);\n      temp.delete(key);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 重置，恢复为初始值\n  const reset &#x3D; () &#x3D;&gt; setMap(getInitValue());\n  &#x2F;&#x2F; 根据key返回值， map 是useState上的map\n  const get &#x3D; (key: K) &#x3D;&gt; map.get(key);\n\n  return [\n    map,\n    &#123;\n      &#x2F;&#x2F; 一些方法，包裹后，暴露出去\n      set: useMemoizedFn(set),\n      setAll: useMemoizedFn(setAll),\n      remove: useMemoizedFn(remove),\n      reset: useMemoizedFn(reset),\n      get: useMemoizedFn(get),\n    &#125;,\n  ] as const;\n&#125;\n\nexport default useMap;\n\nuseSetimport &#123; useState &#125; from &quot;react&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\n\nfunction useSet&lt;K&gt;(initialValue?: Iterable&lt;K&gt;) &#123;\n  const getInitValue &#x3D; () &#x3D;&gt; &#123;\n    return initialValue &#x3D;&#x3D;&#x3D; undefined ? new Set&lt;K&gt;() : new Set(initialValue);\n  &#125;;\n\n  const [set, setSet] &#x3D; useState&lt;Set&lt;K&gt;&gt;(() &#x3D;&gt; getInitValue());\n  &#x2F;&#x2F; 已经有的，不会重复添加，set存值，保证唯一，没必要重复插入\n  const add &#x3D; (key: K) &#x3D;&gt; &#123;\n    if (set.has(key)) &#123;\n      return;\n    &#125;\n    setSet((prevSet) &#x3D;&gt; &#123;\n      const temp &#x3D; new Set(prevSet);\n      temp.add(key);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 没有不继续执行，有继续之前，将prevSet，生成一个新的Set,然后删除key,并返回新的map，\n  const remove &#x3D; (key: K) &#x3D;&gt; &#123;\n    if (!set.has(key)) &#123;\n      return;\n    &#125;\n    setSet((prevSet) &#x3D;&gt; &#123;\n      const temp &#x3D; new Set(prevSet);\n      temp.delete(key);\n      return temp;\n    &#125;);\n  &#125;;\n  &#x2F;&#x2F; 重置到最初值\n  const reset &#x3D; () &#x3D;&gt; setSet(getInitValue());\n\n  return [\n    set,\n    &#123;\n      &#x2F;&#x2F; 方法，缓存下\n      add: useMemoizedFn(add),\n      remove: useMemoizedFn(remove),\n      reset: useMemoizedFn(reset),\n    &#125;,\n  ] as const;\n&#125;\n\nexport default useSet;\n\nuseMap&#x2F;useSet 返回的都是新的 Map&#x2F;Set 对象, 所以每次变化都会触发更新。之前开发中进行突变，不会触发页面更新\nuseMemoizedFn持久化 function 的 Hook，理论上，可以使用 useMemoizedFn 完全代替 useCallback。\n在某些场景中，我们需要使用 useCallback 来记住一个函数，但是在第二个参数 deps 变化时，会重新生成函数，导致函数地址变化。\nconst [state, setState] &#x3D; useState(&quot;&quot;);\n\n&#x2F;&#x2F; 在 state 变化时，func 地址会变化\nconst func &#x3D; useCallback(() &#x3D;&gt; &#123;\n  console.log(state);\n&#125;, [state]);\n\n使用 useMemoizedFn，可以省略第二个参数 deps，同时保证函数地址永远不会变化。\n\n\n\n\n\n\n\nWARNING\n如果以地址变化的更新，不可用 useMemoizedFn\n\nconst [state, setState] &#x3D; useState(&quot;&quot;);\n\n&#x2F;&#x2F; func 地址永远不会变化\nconst func &#x3D; useMemoizedFn(() &#x3D;&gt; &#123;\n  console.log(state);\n&#125;);\n\nimport &#123; useMemo, useRef &#125; from &quot;react&quot;;\nimport &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;\nimport isDev from &quot;..&#x2F;utils&#x2F;isDev&quot;;\n\ntype noop &#x3D; (this: any, ...args: any[]) &#x3D;&gt; any;\n\ntype PickFunction&lt;T extends noop&gt; &#x3D; (\n  this: ThisParameterType&lt;T&gt;,\n  ...args: Parameters&lt;T&gt;\n) &#x3D;&gt; ReturnType&lt;T&gt;;\n\nfunction useMemoizedFn&lt;T extends noop&gt;(fn: T) &#123;\n  if (isDev) &#123;\n    if (!isFunction(fn)) &#123;\n      console.error(\n        &#96;useMemoizedFn expected parameter is a function, got $&#123;typeof fn&#125;&#96;\n      );\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 下面这两行代码看上去确实有点奇怪\n  &#x2F;&#x2F; 为了解决 usePersistFn（useMemoizedFn）不能兼容react devtool\n  const fnRef &#x3D; useRef&lt;T&gt;(fn);\n  &#x2F;&#x2F; why not write &#96;fnRef.current &#x3D; fn&#96;?\n  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;728\n  fnRef.current &#x3D; useMemo(() &#x3D;&gt; fn, [fn]);\n\n  &#x2F;&#x2F; 缓存函数地址\n  const memoizedFn &#x3D; useRef&lt;PickFunction&lt;T&gt;&gt;();\n  if (!memoizedFn.current) &#123;\n    memoizedFn.current &#x3D; function (this, ...args) &#123;\n      &#x2F;&#x2F; 没有函数的时候，这里重新生成了一个函数，并将执行结果作为新函数的结果\n      return fnRef.current.apply(this, args); &#x2F;&#x2F; fnRef.current, 从缓存里取的\n    &#125;;\n  &#125;\n\n  return memoizedFn.current as T;\n&#125;\n\nexport default useMemoizedFn;\n\nuseFocusWithin监听当前焦点是否在某个区域之内，同 css 属性 :focus-within\n可用于： 聚焦发送请求，以保证用户获取最新数据\nimport &#123; useState &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\n\nexport interface Options &#123;\n  onFocus?: (e: FocusEvent) &#x3D;&gt; void;\n  onBlur?: (e: FocusEvent) &#x3D;&gt; void;\n  onChange?: (isFocusWithin: boolean) &#x3D;&gt; void;\n&#125;\n\nexport default function useFocusWithin(target: BasicTarget, options?: Options) &#123;\n  const [isFocusWithin, setIsFocusWithin] &#x3D; useState(false);\n  const &#123; onFocus, onBlur, onChange &#125; &#x3D; options || &#123;&#125;;\n\n  useEventListener(\n    &quot;focusin&quot;,\n    (e: FocusEvent) &#x3D;&gt; &#123;\n      if (!isFocusWithin) &#123;\n        onFocus?.(e);\n        onChange?.(true);\n        setIsFocusWithin(true); &#x2F;&#x2F; 聚焦\n      &#125;\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n\n  useEventListener(\n    &quot;focusout&quot;,\n    (e: FocusEvent) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; contains 原生\n      if (\n        isFocusWithin &amp;&amp;\n        !(e.currentTarget as Element)?.contains?.(e.relatedTarget as Element)\n      ) &#123;\n        onBlur?.(e);\n        onChange?.(false);\n        setIsFocusWithin(false); &#x2F;&#x2F; 失去焦点\n      &#125;\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n\n  return isFocusWithin;\n&#125;\n\n问题：我记得有个间隔多久之后，再次聚焦才发送请求的，之后看看是哪个 api\nuseTitle这个 api 在nextjs中或许不是那么好用，因为 nextjs 有自己的 api，useTitle更新后，会被 nextjs&lt;Title&gt;&lt;/Title&gt;给覆盖掉\nimport &#123; useEffect, useRef &#125; from &quot;react&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\nimport isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;\n\nexport interface Options &#123;\n  restoreOnUnmount?: boolean;\n&#125;\n\nconst DEFAULT_OPTIONS: Options &#x3D; &#123;\n  restoreOnUnmount: false,\n&#125;;\n\nfunction useTitle(title: string, options: Options &#x3D; DEFAULT_OPTIONS) &#123;\n  const titleRef &#x3D; useRef(isBrowser ? document.title : &quot;&quot;);\n  &#x2F;&#x2F; 额，这里在服务端可以拿到 document吗？如果拿不到会报错的，没加 isBrowser 判断，那么在服务端可以拿到\n  useEffect(() &#x3D;&gt; &#123;\n    document.title &#x3D; title;\n  &#125;, [title]);\n\n  useUnmount(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; restoreOnUnmount\t组件卸载时，是否恢复上一个页面标题\n    if (options.restoreOnUnmount) &#123;\n      &#x2F;&#x2F; 卸载恢复\n      document.title &#x3D; titleRef.current;\n    &#125;\n  &#125;);\n&#125;\n\nexport default useTitle;\n\nuseFavicon实现：link 标签更改&#x2F;动态创建标签放到 head 尾部\nimport &#123; useEffect &#125; from &quot;react&quot;;\n&#x2F;&#x2F; shortcut icon 类型限制\nconst ImgTypeMap &#x3D; &#123;\n  SVG: &quot;image&#x2F;svg+xml&quot;,\n  ICO: &quot;image&#x2F;x-icon&quot;,\n  GIF: &quot;image&#x2F;gif&quot;,\n  PNG: &quot;image&#x2F;png&quot;,\n&#125;;\n\ntype ImgTypes &#x3D; keyof typeof ImgTypeMap;\n\nconst useFavicon &#x3D; (href: string) &#x3D;&gt; &#123;\n  useEffect(() &#x3D;&gt; &#123;\n    if (!href) return;\n    &#x2F;&#x2F; 截取后缀判断是否满足\n    const cutUrl &#x3D; href.split(&quot;.&quot;);\n    const imgSuffix &#x3D; cutUrl[cutUrl.length - 1].toLocaleUpperCase() as ImgTypes;\n\n    &#x2F;&#x2F;存在获取，不存在\n    const link: HTMLLinkElement &#x3D;\n      document.querySelector(&quot;link[rel*&#x3D;&#39;icon&#39;]&quot;) ||\n      document.createElement(&quot;link&quot;);\n\n    link.type &#x3D; ImgTypeMap[imgSuffix];\n    link.href &#x3D; href;\n    link.rel &#x3D; &quot;shortcut icon&quot;;\n\n    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(link);\n  &#125;, [href]);\n&#125;;\n\nexport default useFavicon;\n\nuseFullscreenimport &#123; useState &#125; from &quot;react&quot;;\nimport screenfull from &quot;screenfull&quot;; &#x2F;&#x2F; @link https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;main&#x2F;index.js\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport useUnmount from &quot;..&#x2F;useUnmount&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\n\nexport interface Options &#123;\n  onExit?: () &#x3D;&gt; void;\n  onEnter?: () &#x3D;&gt; void;\n&#125;\n\nconst useFullscreen &#x3D; (target: BasicTarget, options?: Options) &#x3D;&gt; &#123;\n  const &#123; onExit, onEnter &#125; &#x3D; options || &#123;&#125;;\n  &#x2F;&#x2F; 退出\n  const onExitRef &#x3D; useLatest(onExit);\n  &#x2F;&#x2F; 进入\n  const onEnterRef &#x3D; useLatest(onEnter);\n  &#x2F;&#x2F; 是否全屏\n  const [state, setState] &#x3D; useState(false);\n\n  const onChange &#x3D; () &#x3D;&gt; &#123;\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; 支持全屏\n      const &#123; isFullscreen &#125; &#x3D; screenfull;\n      if (isFullscreen) &#123;\n        onEnterRef.current?.();\n      &#125; else &#123;\n        screenfull.off(&quot;change&quot;, onChange);\n        onExitRef.current?.();\n      &#125;\n      setState(isFullscreen);\n    &#125;\n  &#125;;\n\n  const enterFullscreen &#x3D; () &#x3D;&gt; &#123;\n    const el &#x3D; getTargetElement(target);\n    if (!el) &#123;\n      return;\n    &#125;\n\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; 支持全屏\n      try &#123;\n        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;991e917bffc818c5367186c6ec5e70ae7a37cfc5&#x2F;index.js#L80\n        screenfull.request(el);\n        screenfull.on(&quot;change&quot;, onChange);\n      &#125; catch (error) &#123;\n        console.error(error);\n      &#125;\n    &#125;\n  &#125;;\n\n  const exitFullscreen &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 支持全屏\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;991e917bffc818c5367186c6ec5e70ae7a37cfc5&#x2F;index.js#L96\n      &#x2F;&#x2F; 奇怪了，这里怎么返回了一个promise\n      screenfull.exit();\n    &#125;\n  &#125;;\n\n  const toggleFullscreen &#x3D; () &#x3D;&gt; &#123;\n    if (state) &#123;\n      exitFullscreen();\n    &#125; else &#123;\n      enterFullscreen();\n    &#125;\n  &#125;;\n\n  useUnmount(() &#x3D;&gt; &#123;\n    if (screenfull.isEnabled) &#123;\n      &#x2F;&#x2F; 支持全屏\n      screenfull.off(&quot;change&quot;, onChange);\n    &#125;\n  &#125;);\n\n  return [\n    state,\n    &#123;\n      enterFullscreen: useMemoizedFn(enterFullscreen),\n      exitFullscreen: useMemoizedFn(exitFullscreen),\n      toggleFullscreen: useMemoizedFn(toggleFullscreen),\n      isEnabled: screenfull.isEnabled,\n    &#125;,\n  ] as const;\n&#125;;\n\nexport default useFullscreen;\n\nscreenfullhttps://github.com/sindresorhus/screenfull/blob/991e917bffc818c5367186c6ec5e70ae7a37cfc5/index.js#L50\nconst nativeAPI &#x3D; (() &#x3D;&gt; &#123;\n  if (typeof document &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n    return false;\n  &#125;\n\n  const unprefixedMethods &#x3D; methodMap[0];\n  const returnValue &#x3D; &#123;&#125;;\n\n  for (const methodList of methodMap &#x2F;**二维数组 *&#x2F;) &#123;\n    const exitFullscreenMethod &#x3D; methodList?.[1];\n    if (exitFullscreenMethod in document) &#123;\n      &#x2F;&#x2F; 支持的方法，都给提取出来，放到 nativeAPI,之后使用nativeAPI上的方法\n      for (const [index, method] of methodList.entries()) &#123;\n        returnValue[unprefixedMethods[index]] &#x3D; method;\n      &#125;\n\n      return returnValue;\n    &#125;\n  &#125;\n\n  return false;\n&#125;)();\n\n&#x2F;&#x2F; ....\n\nlet screenfull &#x3D; &#123;\n  &#x2F;&#x2F; eslint-disable-next-line default-param-last\n  request(element &#x3D; document.documentElement, options) &#123;&#125;,\n  &#x2F;&#x2F; 退出全屏\n  exit() &#123;&#125;,\n  &#x2F;&#x2F; 全屏&#x2F;非全屏切换\n  toggle(element, options) &#123;&#125;,\n  &#x2F;&#x2F; 更改\n  onchange(callback) &#123;&#125;,\n  &#x2F;&#x2F; 错误处理\n  onerror(callback) &#123;&#125;,\n  &#x2F;&#x2F; 事件监听\n  on(event, callback) &#123;&#125;,\n  &#x2F;&#x2F; 移除监听\n  off(event, callback) &#123;&#125;,\n  &#x2F;&#x2F; 原生api\n  raw: nativeAPI,\n&#125;;\n\n&#x2F;&#x2F; 扩展三个方法\nObject.defineProperties(screenfull, &#123;\n  isFullscreen: &#123;\n    get: () &#x3D;&gt; Boolean(document[nativeAPI.fullscreenElement]),\n  &#125;,\n  element: &#123;\n    enumerable: true,\n    get: () &#x3D;&gt; document[nativeAPI.fullscreenElement] ?? undefined,\n  &#125;,\n  isEnabled: &#123;\n    enumerable: true,\n    &#x2F;&#x2F; Coerce to boolean in case of old WebKit.\n    get: () &#x3D;&gt; Boolean(document[nativeAPI.fullscreenEnabled]),\n  &#125;,\n&#125;);\n&#x2F;&#x2F; nativeAPI为&#123;&#125; , 不支持原生 isEnabled 为 false, 所以在用screenfull上api时候都要先用isEnabled判断下\nif (!nativeAPI) &#123;\n  screenfull &#x3D; &#123; isEnabled: false &#125;;\n&#125;\n\nexport default screenfull;\n\nuseExternal\n\n\n\n\n\n\n\n\n动态注入 JS 或 CSS 资源，useExternal 可以保证资源全局唯一。\n实现原理：通过 useEffect,deps 不改变，逻辑不会重复执行的特点\nimport &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;\n\nexport interface Options &#123;\n  type?: &quot;js&quot; | &quot;css&quot;;\n  js?: Partial&lt;HTMLScriptElement&gt;;\n  css?: Partial&lt;HTMLStyleElement&gt;;\n&#125;\n\n&#x2F;&#x2F; &#123;[path]: count&#125;\n&#x2F;&#x2F; remove external when no used\nconst EXTERNAL_USED_COUNT: Record&lt;string, number&gt; &#x3D; &#123;&#125;;\n\nexport type Status &#x3D; &quot;unset&quot; | &quot;loading&quot; | &quot;ready&quot; | &quot;error&quot;;\n\ninterface loadResult &#123;\n  ref: Element;\n  status: Status;\n&#125;\n&#x2F;&#x2F; 加载js\nconst loadScript &#x3D; (path: string, props &#x3D; &#123;&#125;): loadResult &#x3D;&gt; &#123;\n  const script &#x3D; document.querySelector(&#96;script[src&#x3D;&quot;$&#123;path&#125;&quot;]&#96;);\n\n  if (!script) &#123;\n    const newScript &#x3D; document.createElement(&quot;script&quot;);\n    newScript.src &#x3D; path;\n\n    Object.keys(props).forEach((key) &#x3D;&gt; &#123;\n      newScript[key] &#x3D; props[key];\n    &#125;);\n\n    newScript.setAttribute(&quot;data-status&quot;, &quot;loading&quot;);\n    document.body.appendChild(newScript);\n\n    return &#123;\n      ref: newScript,\n      status: &quot;loading&quot;,\n    &#125;;\n  &#125;\n\n  return &#123;\n    ref: script,\n    status: (script.getAttribute(&quot;data-status&quot;) as Status) || &quot;ready&quot;,\n  &#125;;\n&#125;;\n&#x2F;&#x2F; 加载css\nconst loadCss &#x3D; (path: string, props &#x3D; &#123;&#125;): loadResult &#x3D;&gt; &#123;\n  const css &#x3D; document.querySelector(&#96;link[href&#x3D;&quot;$&#123;path&#125;&quot;]&#96;);\n  if (!css) &#123;\n    const newCss &#x3D; document.createElement(&quot;link&quot;);\n\n    newCss.rel &#x3D; &quot;stylesheet&quot;;\n    newCss.href &#x3D; path;\n    Object.keys(props).forEach((key) &#x3D;&gt; &#123;\n      newCss[key] &#x3D; props[key];\n    &#125;);\n    &#x2F;&#x2F; IE9+\n    const isLegacyIECss &#x3D; &quot;hideFocus&quot; in newCss;\n    &#x2F;&#x2F; use preload in IE Edge (to detect load errors)\n    if (isLegacyIECss &amp;&amp; newCss.relList) &#123;\n      newCss.rel &#x3D; &quot;preload&quot;;\n      newCss.as &#x3D; &quot;style&quot;;\n    &#125;\n    newCss.setAttribute(&quot;data-status&quot;, &quot;loading&quot;);\n    document.head.appendChild(newCss);\n\n    return &#123;\n      ref: newCss,\n      status: &quot;loading&quot;,\n    &#125;;\n  &#125;\n\n  return &#123;\n    ref: css,\n    status: (css.getAttribute(&quot;data-status&quot;) as Status) || &quot;ready&quot;,\n  &#125;;\n&#125;;\n\nconst useExternal &#x3D; (path?: string, options?: Options) &#x3D;&gt; &#123;\n  const [status, setStatus] &#x3D; useState&lt;Status&gt;(path ? &quot;loading&quot; : &quot;unset&quot;);\n\n  const ref &#x3D; useRef&lt;Element&gt;();\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!path) &#123;\n      &#x2F;&#x2F; 没有资源，直接拦截掉\n      setStatus(&quot;unset&quot;);\n      return;\n    &#125;\n    const pathname &#x3D; path.replace(&#x2F;[|#].*$&#x2F;, &quot;&quot;);\n\n    &#x2F;&#x2F; css\n    if (\n      options?.type &#x3D;&#x3D;&#x3D; &quot;css&quot; ||\n      (!options?.type &amp;&amp; &#x2F;(^css!|\\.css$)&#x2F;.test(pathname))\n    ) &#123;\n      const result &#x3D; loadCss(path, options?.css);\n      ref.current &#x3D; result.ref;\n      setStatus(result.status);\n      &#x2F;&#x2F; js\n    &#125; else if (\n      options?.type &#x3D;&#x3D;&#x3D; &quot;js&quot; ||\n      (!options?.type &amp;&amp; &#x2F;(^js!|\\.js$)&#x2F;.test(pathname))\n    ) &#123;\n      const result &#x3D; loadScript(path, options?.js);\n      ref.current &#x3D; result.ref;\n      setStatus(result.status);\n    &#125; else &#123;\n      &#x2F;&#x2F; 其他情况不处理\n      &#x2F;&#x2F; do nothing\n      console.error(\n        &quot;Cannot infer the type of external resource, and please provide a type (&#39;js&#39; | &#39;css&#39;). &quot; +\n          &quot;Refer to the https:&#x2F;&#x2F;ahooks.js.org&#x2F;hooks&#x2F;dom&#x2F;use-external&#x2F;#options&quot;\n      );\n    &#125;\n    &#x2F;&#x2F; 非js&#x2F;css，这里会阻止掉继续执行\n    if (!ref.current) &#123;\n      return;\n    &#125;\n\n    if (EXTERNAL_USED_COUNT[path] &#x3D;&#x3D;&#x3D; undefined) &#123;\n      EXTERNAL_USED_COUNT[path] &#x3D; 1;\n    &#125; else &#123;\n      EXTERNAL_USED_COUNT[path] +&#x3D; 1;\n    &#125;\n\n    const handler &#x3D; (event: Event) &#x3D;&gt; &#123;\n      const targetStatus &#x3D; event.type &#x3D;&#x3D;&#x3D; &quot;load&quot; ? &quot;ready&quot; : &quot;error&quot;;\n      ref.current?.setAttribute(&quot;data-status&quot;, targetStatus);\n      setStatus(targetStatus);\n    &#125;;\n    &#x2F;&#x2F; 监听资源加载情况\n    ref.current.addEventListener(&quot;load&quot;, handler);\n    ref.current.addEventListener(&quot;error&quot;, handler);\n\n    &#x2F;&#x2F; 卸载\n    return () &#x3D;&gt; &#123;\n      ref.current?.removeEventListener(&quot;load&quot;, handler);\n      ref.current?.removeEventListener(&quot;error&quot;, handler);\n\n      EXTERNAL_USED_COUNT[path] -&#x3D; 1;\n\n      if (EXTERNAL_USED_COUNT[path] &#x3D;&#x3D;&#x3D; 0) &#123;\n        ref.current?.remove(); &#x2F;&#x2F; 这里通过remove方法移除 对应的dom\n      &#125;\n\n      ref.current &#x3D; undefined;\n    &#125;;\n  &#125;, [path]);\n\n  return status;\n&#125;;\n\nexport default useExternal;\n\ndom.remove()移除 dom 测试\n\n\nuseHover监听 DOM 元素是否有鼠标悬停。\nimport useBoolean from &quot;..&#x2F;useBoolean&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\n\nexport interface Options &#123;\n  onEnter?: () &#x3D;&gt; void;\n  onLeave?: () &#x3D;&gt; void;\n  onChange?: (isHovering: boolean) &#x3D;&gt; void;\n&#125;\n\nexport default (target: BasicTarget, options?: Options): boolean &#x3D;&gt; &#123;\n  const &#123; onEnter, onLeave, onChange &#125; &#x3D; options || &#123;&#125;;\n\n  const [state, &#123; setTrue, setFalse &#125;] &#x3D; useBoolean(false);\n  &#x2F;&#x2F; 监听鼠标进入\n  useEventListener(\n    &quot;mouseenter&quot;,\n    () &#x3D;&gt; &#123;\n      onEnter?.();\n      setTrue();\n      onChange?.(true);\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n  &#x2F;&#x2F; 监听鼠标离开\n  useEventListener(\n    &quot;mouseleave&quot;,\n    () &#x3D;&gt; &#123;\n      onLeave?.();\n      setFalse();\n      onChange?.(false);\n    &#125;,\n    &#123;\n      target,\n    &#125;\n  );\n  &#x2F;&#x2F; isHovering 鼠标元素是否处于 hover\n  return state;\n&#125;;\n\nuseInViewport\n\n\n\n\n\n\n\n\n观察元素是否在可见区域，以及元素可见比例。更多信息参考 Intersection Observer API。\n\nIntersectionObserver\n\n\n\n\n\n\n\n\n\nIntersection Observer API 提供了一种异步检测目标元素与祖先元素或 viewport 相交情况变化的方法。\n过去，要检测一个元素是否可见或者两个元素是否相交并不容易，很多解决办法不可靠或性能很差。然而，随着互联网的发展，这种需求却与日俱增，比如，下面这些情况都需要用到相交检测：\n\n图片懒加载——当图片滚动到可见时才进行加载\n内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉\n检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况\n在用户看见某个区域时执行任务或播放动画\n\n\n\n\n\n\n\n\n\n\n假如有一个无限滚动的网页，开发者使用了一个第三方库来管理整个页面的广告，又用了另外一个库来实现消息盒子和点赞，并且页面有很多动画（译注：动画往往意味着较高的性能消耗）。两个库都有自己的相交检测程序，都运行在主线程里，而网站的开发者对这些库的内部实现知之甚少，所以并未意识到有什么问题。但当用户滚动页面时，这些相交检测程序就会在页面滚动回调函数里不停触发调用，造成性能问题，体验效果让人失望。\nIntersection observer 的概念和用法Intersection Observer API 允许你配置一个回调函数，当以下情况发生时会被调用\n每当目标 (target) 元素与设备视窗或者其他指定元素发生交集的时候执行。设备视窗或者其他元素我们称它为根元素或根 (root)。Observer 第一次监听目标元素的时候通常，您需要关注文档最接近的可滚动祖先元素的交集更改，如果元素不是可滚动元素的后代，则默认为设备视窗。如果要观察相对于根 (root) 元素的交集，请指定根 (root) 元素为 null。\n无论您是使用视口还是其他元素作为根，API 都以相同的方式工作，只要目标元素的可见性发生变化，就会执行您提供的回调函数，以便它与所需的交叉点交叉。\n目标 (target) 元素与根 (root) 元素之间的交叉度是交叉比 (intersection ratio)。这是目标 (target) 元素相对于根 (root) 的交集百分比的表示，它的取值在 0.0 和 1.0 之间。\n创建一个 intersection observer创建一个 IntersectionObserver 对象，并传入相应参数和回调用函数，该回调函数将会在目标 (target) 元素和根 (root) 元素的交集大小超过阈值 (threshold) 规定的大小时候被执行。\nlet options &#x3D; &#123;\n  root: document.querySelector(&quot;#scrollArea&quot;),\n  rootMargin: &quot;0px&quot;,\n  threshold: 1.0,\n&#125;;\n\nlet observer &#x3D; new IntersectionObserver(callback, options);\n\n阈值为 1.0 意味着目标元素完全出现在 root 选项指定的元素中可见时，回调函数将会被执行。\nIntersection observer options传递到 IntersectionObserver() 构造函数的 options 对象，允许您控制观察者的回调函数的被调用时的环境。它有以下字段：\nroot指定根 (root) 元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为 null，则默认为浏览器视窗。\nrootMargin根 (root) 元素的外边距。类似于 CSS 中的 margin 属性，比如 “10px 20px 30px 40px” (top, right, bottom, left)。如果有指定 root 参数，则 rootMargin 也可以使用百分比来取值。该属性值是用作 root 元素和 target 发生交集时候的计算交集的区域范围，使用该属性可以控制 root 元素每一边的收缩或者扩张。默认值为 0。\nthreshold可以是单一的 number 也可以是 number 数组，target 元素和 root 元素相交程度达到该值的时候 IntersectionObserver 注册的回调函数将会被执行。如果你只是想要探测当 target 元素的在 root 元素中的可见性超过 50% 的时候，你可以指定该属性值为 0.5。如果你想要 target 元素在 root 元素的可见程度每多 25% 就执行一次回调，那么你可以指定一个数组 [0, 0.25, 0.5, 0.75, 1]。默认值是 0 (意味着只要有一个 target 像素出现在 root 元素中，回调函数将会被执行)。该值为 1.0 含义是当 target 完全出现在 root 元素中时候 回调才会被执行。\nTargeting an element to be observed创建一个 observer 后需要给定一个目标元素进行观察。\nlet target &#x3D; document.querySelector(&quot;#listItem&quot;);\nobserver.observe(target);\n\n每当目标满足该 IntersectionObserver 指定的 threshold 值，回调被调用。\n只要目标满足为 IntersectionObserver 指定的阈值，就会调用回调。回调接收 IntersectionObserverEntry 对象和观察者的列表：\nlet callback &#x3D; (entries, observer) &#x3D;&gt; &#123;\n  entries.forEach((entry) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; Each entry describes an intersection change for one observed target element:\n    &#x2F;&#x2F; entry.boundingClientRect\n    &#x2F;&#x2F; entry.intersectionRatio\n    &#x2F;&#x2F; entry.intersectionRect\n    &#x2F;&#x2F; entry.isIntersecting\n    &#x2F;&#x2F; entry.rootBounds\n    &#x2F;&#x2F; entry.target\n    &#x2F;&#x2F; entry.time\n  &#125;);\n&#125;;\n\n请留意，你注册的回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 Window.requestIdleCallback() 方法。\n\n\nimport &quot;intersection-observer&quot;;\nimport &#123; useState &#125; from &quot;react&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\nexport interface Options &#123;\n  rootMargin?: string;\n  threshold?: number | number[];\n  root?: BasicTarget&lt;Element&gt;;\n&#125;\n\nfunction useInViewport(target: BasicTarget, options?: Options) &#123;\n  &#x2F;&#x2F; inViewport\t是否可见\n  const [state, setState] &#x3D; useState&lt;boolean&gt;();\n  &#x2F;&#x2F; ratio\t当前可见比例，在每次到达 options.threshold 设置节点时更新\n  const [ratio, setRatio] &#x3D; useState&lt;number&gt;();\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target);\n      if (!el) &#123;\n        return;\n      &#125;\n\n      const observer &#x3D; new IntersectionObserver(\n        (entries) &#x3D;&gt; &#123;\n          for (const entry of entries) &#123;\n            setRatio(entry.intersectionRatio);\n            setState(entry.isIntersecting);\n          &#125;\n        &#125;,\n        &#123;\n          ...options,\n          root: getTargetElement(options?.root),\n        &#125;\n      );\n\n      observer.observe(el);\n\n      return () &#x3D;&gt; &#123;\n        observer.disconnect();\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n\n  return [state, ratio] as const;\n&#125;\n\nexport default useInViewport;\n\nuseMutationObserverimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useDeepCompareEffectWithTarget from &quot;..&#x2F;utils&#x2F;useDeepCompareWithTarget&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\n\nconst useMutationObserver &#x3D; (\n  callback: MutationCallback,\n  target: BasicTarget,\n  options: MutationObserverInit &#x3D; &#123;&#125;\n): void &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 拿到最新的回调函数，useLatest内部使用useRef实现\n  const callbackRef &#x3D; useLatest(callback);\n\n  useDeepCompareEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const element &#x3D; getTargetElement(target); &#x2F;&#x2F; 被观察的dom对象\n      if (!element) &#123;\n        return;\n      &#125;\n      &#x2F;&#x2F; 实例化一个（突变观察者）观察对象\n      const observer &#x3D; new MutationObserver(callbackRef.current);\n      &#x2F;&#x2F; 开始观察\n      observer.observe(element, options);\n\n      &#x2F;&#x2F; 卸载停止观察\n      return () &#x3D;&gt; &#123;\n        if (observer) &#123;\n          observer.disconnect();\n        &#125;\n      &#125;;\n    &#125;,\n    [options],\n    target\n  );\n&#125;;\n\nexport default useMutationObserver;\n\n\nMutationObserver\nMutationObserver 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。\n构造函数MutationObserver()创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。\n方法disconnect()阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe() 方法，该观察者对象包含的回调函数都不会再被调用。\nobserve()配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。\ntakeRecords()从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。\n示例改编自 这篇博客\n&#x2F;&#x2F; 选择需要观察变动的节点\nconst targetNode &#x3D; document.getElementById(&quot;some-id&quot;);\n\n&#x2F;&#x2F; 观察器的配置（需要观察什么变动）\nconst config &#x3D; &#123; attributes: true, childList: true, subtree: true &#125;;\n\n&#x2F;&#x2F; 当观察到变动时执行的回调函数\nconst callback &#x3D; function (mutationsList, observer) &#123;\n  &#x2F;&#x2F; Use traditional &#39;for loops&#39; for IE 11\n  for (let mutation of mutationsList) &#123;\n    if (mutation.type &#x3D;&#x3D;&#x3D; &quot;childList&quot;) &#123;\n      console.log(&quot;A child node has been added or removed.&quot;);\n    &#125; else if (mutation.type &#x3D;&#x3D;&#x3D; &quot;attributes&quot;) &#123;\n      console.log(&quot;The &quot; + mutation.attributeName + &quot; attribute was modified.&quot;);\n    &#125;\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 创建一个观察器实例并传入回调函数\nconst observer &#x3D; new MutationObserver(callback);\n\n&#x2F;&#x2F; 以上述配置开始观察目标节点\nobserver.observe(targetNode, config);\n\n&#x2F;&#x2F; 之后，可停止观察\nobserver.disconnect();\n\n\n\nuseKeyPress【不是很理解】代码有点长，也不是很重要\n\nuseKeyPress 源码\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport &#123; isFunction, isNumber, isString &#125; from &quot;..&#x2F;utils&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useDeepCompareEffectWithTarget from &quot;..&#x2F;utils&#x2F;useDeepCompareWithTarget&quot;;\n\nexport type KeyPredicate &#x3D; (event: KeyboardEvent) &#x3D;&gt; boolean;\nexport type keyType &#x3D; number | string;\nexport type KeyFilter &#x3D;\n  | keyType\n  | keyType[]\n  | ((event: KeyboardEvent) &#x3D;&gt; boolean);\nexport type EventHandler &#x3D; (event: KeyboardEvent) &#x3D;&gt; void;\nexport type KeyEvent &#x3D; &quot;keydown&quot; | &quot;keyup&quot;;\n\nexport type Target &#x3D; BasicTarget&lt;HTMLElement | Document | Window&gt;;\n\nexport type Options &#x3D; &#123;\n  events?: KeyEvent[];\n  target?: Target;\n  exactMatch?: boolean;\n&#125;;\n\n&#x2F;&#x2F; 键盘事件 keyCode 别名\nconst aliasKeyCodeMap &#x3D; &#123;\n  &quot;0&quot;: 48,\n  &quot;1&quot;: 49,\n  &quot;2&quot;: 50,\n  &quot;3&quot;: 51,\n  &quot;4&quot;: 52,\n  &quot;5&quot;: 53,\n  &quot;6&quot;: 54,\n  &quot;7&quot;: 55,\n  &quot;8&quot;: 56,\n  &quot;9&quot;: 57,\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  ctrl: 17,\n  alt: 18,\n  pausebreak: 19,\n  capslock: 20,\n  esc: 27,\n  space: 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  leftarrow: 37,\n  uparrow: 38,\n  rightarrow: 39,\n  downarrow: 40,\n  insert: 45,\n  delete: 46,\n  a: 65,\n  b: 66,\n  c: 67,\n  d: 68,\n  e: 69,\n  f: 70,\n  g: 71,\n  h: 72,\n  i: 73,\n  j: 74,\n  k: 75,\n  l: 76,\n  m: 77,\n  n: 78,\n  o: 79,\n  p: 80,\n  q: 81,\n  r: 82,\n  s: 83,\n  t: 84,\n  u: 85,\n  v: 86,\n  w: 87,\n  x: 88,\n  y: 89,\n  z: 90,\n  leftwindowkey: 91,\n  rightwindowkey: 92,\n  selectkey: 93,\n  numpad0: 96,\n  numpad1: 97,\n  numpad2: 98,\n  numpad3: 99,\n  numpad4: 100,\n  numpad5: 101,\n  numpad6: 102,\n  numpad7: 103,\n  numpad8: 104,\n  numpad9: 105,\n  multiply: 106,\n  add: 107,\n  subtract: 109,\n  decimalpoint: 110,\n  divide: 111,\n  f1: 112,\n  f2: 113,\n  f3: 114,\n  f4: 115,\n  f5: 116,\n  f6: 117,\n  f7: 118,\n  f8: 119,\n  f9: 120,\n  f10: 121,\n  f11: 122,\n  f12: 123,\n  numlock: 144,\n  scrolllock: 145,\n  semicolon: 186,\n  equalsign: 187,\n  comma: 188,\n  dash: 189,\n  period: 190,\n  forwardslash: 191,\n  graveaccent: 192,\n  openbracket: 219,\n  backslash: 220,\n  closebracket: 221,\n  singlequote: 222,\n&#125;;\n\n&#x2F;&#x2F; 修饰键\nconst modifierKey &#x3D; &#123;\n  ctrl: (event: KeyboardEvent) &#x3D;&gt; event.ctrlKey,\n  shift: (event: KeyboardEvent) &#x3D;&gt; event.shiftKey,\n  alt: (event: KeyboardEvent) &#x3D;&gt; event.altKey,\n  meta: (event: KeyboardEvent) &#x3D;&gt; event.metaKey,\n&#125;;\n\n&#x2F;&#x2F; 根据 event 计算激活键数量\nfunction countKeyByEvent(event: KeyboardEvent) &#123;\n  const countOfModifier &#x3D; Object.keys(modifierKey).reduce((total, key) &#x3D;&gt; &#123;\n    if (modifierKey[key](event)) &#123;\n      return total + 1;\n    &#125;\n\n    return total;\n  &#125;, 0);\n\n  &#x2F;&#x2F; 16 17 18 91 92 是修饰键的 keyCode，如果 keyCode 是修饰键，那么激活数量就是修饰键的数量，如果不是，那么就需要 +1\n  return [16, 17, 18, 91, 92].includes(event.keyCode)\n    ? countOfModifier\n    : countOfModifier + 1;\n&#125;\n\n&#x2F;**\n * 判断按键是否激活\n * @param [event: KeyboardEvent]键盘事件\n * @param [keyFilter: any] 当前键\n * @returns Boolean\n *&#x2F;\nfunction genFilterKey(\n  event: KeyboardEvent,\n  keyFilter: keyType,\n  exactMatch: boolean\n) &#123;\n  &#x2F;&#x2F; 浏览器自动补全 input 的时候，会触发 keyDown、keyUp 事件，但此时 event.key 等为空\n  if (!event.key) &#123;\n    return false;\n  &#125;\n\n  &#x2F;&#x2F; 数字类型直接匹配事件的 keyCode\n  if (isNumber(keyFilter)) &#123;\n    return event.keyCode &#x3D;&#x3D;&#x3D; keyFilter;\n  &#125;\n\n  &#x2F;&#x2F; 字符串依次判断是否有组合键\n  const genArr &#x3D; keyFilter.split(&quot;.&quot;);\n  let genLen &#x3D; 0;\n\n  for (const key of genArr) &#123;\n    &#x2F;&#x2F; 组合键\n    const genModifier &#x3D; &#x2F;** 修饰键*&#x2F; modifierKey[key];\n    &#x2F;&#x2F; keyCode 别名\n    const aliasKeyCode &#x3D;\n      &#x2F;**键盘事件 keyCode 别名*&#x2F; aliasKeyCodeMap[key.toLowerCase()];\n\n    if (\n      (genModifier &amp;&amp; genModifier(event)) ||\n      (aliasKeyCode &amp;&amp; aliasKeyCode &#x3D;&#x3D;&#x3D; event.keyCode)\n    ) &#123;\n      genLen++;\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * 需要判断触发的键位和监听的键位完全一致，判断方法就是触发的键位里有且等于监听的键位\n   * genLen &#x3D;&#x3D;&#x3D; genArr.length 能判断出来触发的键位里有监听的键位\n   * countKeyByEvent(event) &#x3D;&#x3D;&#x3D; genArr.length 判断出来触发的键位数量里有且等于监听的键位数量\n   * 主要用来防止按组合键其子集也会触发的情况，例如监听 ctrl+a 会触发监听 ctrl 和 a 两个键的事件。\n   *&#x2F;\n  if (exactMatch) &#123;\n    return genLen &#x3D;&#x3D;&#x3D; genArr.length &amp;&amp; countKeyByEvent(event) &#x3D;&#x3D;&#x3D; genArr.length;\n  &#125;\n  return genLen &#x3D;&#x3D;&#x3D; genArr.length;\n&#125;\n\n&#x2F;**\n * 键盘输入预处理方法\n * @param [keyFilter: any] 当前键\n * @returns () &#x3D;&gt; Boolean\n *&#x2F;\nfunction genKeyFormatter(\n  keyFilter: KeyFilter,\n  exactMatch: boolean\n): KeyPredicate &#123;\n  if (isFunction(keyFilter)) &#123;\n    return keyFilter;\n  &#125;\n  if (isString(keyFilter) || isNumber(keyFilter)) &#123;\n    return (event: KeyboardEvent) &#x3D;&gt; genFilterKey(event, keyFilter, exactMatch);\n  &#125;\n  if (Array.isArray(keyFilter)) &#123;\n    return (event: KeyboardEvent) &#x3D;&gt;\n      keyFilter.some((item) &#x3D;&gt; genFilterKey(event, item, exactMatch));\n  &#125;\n  return keyFilter ? () &#x3D;&gt; true : () &#x3D;&gt; false;\n&#125;\n\nconst defaultEvents: KeyEvent[] &#x3D; [&quot;keydown&quot;];\n\nfunction useKeyPress(\n  keyFilter: KeyFilter, &#x2F;&#x2F; 支持 keyCode、别名、组合键、数组，自定义函数\n  eventHandler: EventHandler, &#x2F;&#x2F; 回调函数\n  option?: Options &#x2F;&#x2F; 可选配置项\n) &#123;\n  const &#123; events &#x3D; defaultEvents, target, exactMatch &#x3D; false &#125; &#x3D; option || &#123;&#125;;\n  const eventHandlerRef &#x3D; useLatest(eventHandler); &#x2F;&#x2F; 缓存了下\n  const keyFilterRef &#x3D; useLatest(keyFilter); &#x2F;&#x2F; 缓存了下\n\n  useDeepCompareEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target, window);\n      if (!el) &#123;\n        return;\n      &#125;\n\n      const callbackHandler &#x3D; (event: KeyboardEvent) &#x3D;&gt; &#123;\n        const genGuard: KeyPredicate &#x3D; genKeyFormatter(\n          keyFilterRef.current,\n          exactMatch\n        );\n        if (genGuard(event)) &#123;\n          &#x2F;&#x2F; 是不是匹配到了，匹配到了执行回调\n          return eventHandlerRef.current?.(event);\n        &#125;\n      &#125;;\n\n      for (const eventName of events) &#123;\n        el?.addEventListener?.(eventName, callbackHandler);\n      &#125;\n      return () &#x3D;&gt; &#123;\n        for (const eventName of events) &#123;\n          el?.removeEventListener?.(eventName, callbackHandler);\n        &#125;\n      &#125;;\n    &#125;,\n    [events],\n    target\n  );\n&#125;\n\nexport default useKeyPress;\n\n\n\nuseDrop &amp; useDrag\n\n\n\n\n\n\n\n\n处理元素拖拽的 Hook。\nuseDrop 可以单独使用来接收文件、文字和网址的拖拽。\nuseDrag 允许一个 DOM 节点被拖拽，需要配合 useDrop 使用。\n向节点内触发粘贴动作也会被视为拖拽。\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\nexport interface Options &#123;\n  onDragStart?: (event: React.DragEvent) &#x3D;&gt; void;\n  onDragEnd?: (event: React.DragEvent) &#x3D;&gt; void;\n&#125;\n\nconst useDrag &#x3D; &lt;T&gt;(data: T, target: BasicTarget, options: Options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  const optionsRef &#x3D; useLatest(options);\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const targetElement &#x3D; getTargetElement(target);\n      &#x2F;&#x2F; 不具备增加监听的方法\n      if (!targetElement?.addEventListener) &#123;\n        return;\n      &#125;\n\n      const onDragStart &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        optionsRef.current.onDragStart?.(event);\n        event.dataTransfer.setData(&quot;custom&quot;, JSON.stringify(data));\n      &#125;;\n\n      const onDragEnd &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        optionsRef.current.onDragEnd?.(event);\n      &#125;;\n\n      targetElement.setAttribute(&quot;draggable&quot;, &quot;true&quot;);\n      &#x2F;&#x2F; 绑定\n      targetElement.addEventListener(&quot;dragstart&quot;, onDragStart as any);\n      targetElement.addEventListener(&quot;dragend&quot;, onDragEnd as any);\n\n      return () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 解绑定\n        targetElement.removeEventListener(&quot;dragstart&quot;, onDragStart as any);\n        targetElement.removeEventListener(&quot;dragend&quot;, onDragEnd as any);\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n&#125;;\n\nexport default useDrag;\n\nuseDrop\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\n\nexport interface Options &#123;\n  onFiles?: (files: File[], event?: React.DragEvent) &#x3D;&gt; void;\n  onUri?: (url: string, event?: React.DragEvent) &#x3D;&gt; void;\n  onDom?: (content: any, event?: React.DragEvent) &#x3D;&gt; void;\n  onText?: (text: string, event?: React.ClipboardEvent) &#x3D;&gt; void;\n  onDragEnter?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onDragOver?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onDragLeave?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onDrop?: (event?: React.DragEvent) &#x3D;&gt; void;\n  onPaste?: (event?: React.ClipboardEvent) &#x3D;&gt; void;\n&#125;\n\nconst useDrop &#x3D; (target: BasicTarget, options: Options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  const optionsRef &#x3D; useLatest(options);\n\n  &#x2F;&#x2F; https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;26459269\n  const dragEnterTarget &#x3D; useRef&lt;any&gt;();\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const targetElement &#x3D; getTargetElement(target);\n      if (!targetElement?.addEventListener) &#123;\n        return;\n      &#125;\n\n      const onData &#x3D; (\n        dataTransfer: DataTransfer, &#x2F;&#x2F; 拖数据\n        event: React.DragEvent | React.ClipboardEvent\n      ) &#x3D;&gt; &#123;\n        const uri &#x3D; dataTransfer.getData(&quot;text&#x2F;uri-list&quot;);\n        const dom &#x3D; dataTransfer.getData(&quot;custom&quot;);\n\n        if (dom &amp;&amp; optionsRef.current.onDom) &#123;\n          let data &#x3D; dom;\n          try &#123;\n            data &#x3D; JSON.parse(dom);\n          &#125; catch (e) &#123;\n            data &#x3D; dom;\n          &#125;\n          optionsRef.current.onDom(data, event as React.DragEvent);\n          return;\n        &#125;\n        &#x2F;&#x2F; uri数据类型\n        if (uri &amp;&amp; optionsRef.current.onUri) &#123;\n          optionsRef.current.onUri(uri, event as React.DragEvent);\n          return;\n        &#125;\n        &#x2F;&#x2F; 文件数据类型\n        if (\n          dataTransfer.files &amp;&amp;\n          dataTransfer.files.length &amp;&amp;\n          optionsRef.current.onFiles\n        ) &#123;\n          optionsRef.current.onFiles(\n            Array.from(dataTransfer.files),\n            event as React.DragEvent\n          );\n          return;\n        &#125;\n        &#x2F;&#x2F; 文本数据类型\n        if (\n          dataTransfer.items &amp;&amp;\n          dataTransfer.items.length &amp;&amp;\n          optionsRef.current.onText\n        ) &#123;\n          dataTransfer.items[0].getAsString((text) &#x3D;&gt; &#123;\n            optionsRef.current.onText!(text, event as React.ClipboardEvent);\n          &#125;);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 拖拽进入\n      const onDragEnter &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        event.preventDefault();\n        event.stopPropagation();\n\n        dragEnterTarget.current &#x3D; event.target;\n        optionsRef.current.onDragEnter?.(event);\n      &#125;;\n      &#x2F;&#x2F; 拖拽中\n      const onDragOver &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        event.preventDefault();\n        optionsRef.current.onDragOver?.(event);\n      &#125;;\n      &#x2F;&#x2F; 拖拽出去\n      const onDragLeave &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        if (event.target &#x3D;&#x3D;&#x3D; dragEnterTarget.current) &#123;\n          optionsRef.current.onDragLeave?.(event);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 放下\n      const onDrop &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;\n        event.preventDefault();\n        onData(event.dataTransfer, event);\n        optionsRef.current.onDrop?.(event);\n      &#125;;\n      &#x2F;&#x2F; 粘贴\n      const onPaste &#x3D; (event: React.ClipboardEvent) &#x3D;&gt; &#123;\n        onData(event.clipboardData, event);\n        optionsRef.current.onPaste?.(event);\n      &#125;;\n\n      targetElement.addEventListener(&quot;dragenter&quot;, onDragEnter as any);\n      targetElement.addEventListener(&quot;dragover&quot;, onDragOver as any);\n      targetElement.addEventListener(&quot;dragleave&quot;, onDragLeave as any);\n      targetElement.addEventListener(&quot;drop&quot;, onDrop as any);\n      targetElement.addEventListener(&quot;paste&quot;, onPaste as any);\n\n      return () &#x3D;&gt; &#123;\n        targetElement.removeEventListener(&quot;dragenter&quot;, onDragEnter as any);\n        targetElement.removeEventListener(&quot;dragover&quot;, onDragOver as any);\n        targetElement.removeEventListener(&quot;dragleave&quot;, onDragLeave as any);\n        targetElement.removeEventListener(&quot;drop&quot;, onDrop as any);\n        targetElement.removeEventListener(&quot;paste&quot;, onPaste as any);\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n&#125;;\n\nexport default useDrop;\n\n原生事件\nuseDocumentVisibilityimport &#123; useState &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;\n\ntype VisibilityState &#x3D; &quot;hidden&quot; | &quot;visible&quot; | &quot;prerender&quot; | undefined;\n\nconst getVisibility &#x3D; () &#x3D;&gt; &#123;\n  if (!isBrowser) &#123;\n    return &quot;visible&quot;;\n  &#125;\n  return document.visibilityState;\n&#125;;\n\nfunction useDocumentVisibility(): VisibilityState &#123;\n  const [documentVisibility, setDocumentVisibility] &#x3D; useState(() &#x3D;&gt;\n    getVisibility()\n  );\n\n  useEventListener(\n    &quot;visibilitychange&quot;,\n    () &#x3D;&gt; &#123;\n      setDocumentVisibility(getVisibility());\n    &#125;,\n    &#123;\n      target: () &#x3D;&gt; document,\n    &#125;\n  );\n\n  return documentVisibility;\n&#125;\n\nexport default useDocumentVisibility;\n\n见\n\n\n\n\n\n\n\n\n\n典型用法是防止当页面正在渲染时加载资源，或者当页面在背景中或窗口最小化时禁止某些活动。\n猜想：首页prerender后visible前，可以作为performance上报点？\nuseResponsiveimport &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;\n\ntype Subscriber &#x3D; () &#x3D;&gt; void;\n&#x2F;&#x2F; set类型，保证唯一性，因为useEffect可能存在重复执行的情况\nconst subscribers &#x3D; new Set&lt;Subscriber&gt;();\n\ntype ResponsiveConfig &#x3D; Record&lt;string, number&gt;;\ntype ResponsiveInfo &#x3D; Record&lt;string, boolean&gt;;\n\nlet info: ResponsiveInfo;\n\nlet responsiveConfig: ResponsiveConfig &#x3D; &#123;\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n&#125;;\n&#x2F;&#x2F; 处理size变更\nfunction handleResize() &#123;\n  &#x2F;&#x2F; 这里缓存上次的info\n  const oldInfo &#x3D; info;\n  &#x2F;&#x2F; 这里计算新的info\n  calculate();\n  &#x2F;&#x2F; 前后发生变化，就会实行订阅的方法\n  if (oldInfo &#x3D;&#x3D;&#x3D; info) return;\n  &#x2F;&#x2F; 将收集到的观察者统统执行一遍\n  for (const subscriber of subscribers) &#123;\n    subscriber();\n  &#125;\n&#125;\n&#x2F;&#x2F; 避免重复执行\nlet listening &#x3D; false;\n&#x2F;&#x2F; 计算\nfunction calculate() &#123;\n  const width &#x3D; window.innerWidth;\n  const newInfo &#x3D; &#123;&#125; as ResponsiveInfo;\n  let shouldUpdate &#x3D; false;\n  for (const key of Object.keys(responsiveConfig)) &#123;\n    newInfo[key] &#x3D; width &gt;&#x3D; responsiveConfig[key];\n    if (newInfo[key] !&#x3D;&#x3D; info[key]) &#123;\n      shouldUpdate &#x3D; true;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 需要更新\n  if (shouldUpdate) &#123;\n    info &#x3D; newInfo;\n  &#125;\n&#125;\n&#x2F;&#x2F; 配置响应\n&#x2F;&#x2F; 只需配置一次，请勿在组件中重复调用该方法\n&#x2F;&#x2F; 每次调用都会重新计算\nexport function configResponsive(config: ResponsiveConfig) &#123;\n  responsiveConfig &#x3D; config;\n  if (info) calculate();\n&#125;\n\nexport function useResponsive() &#123;\n  &#x2F;&#x2F; 客户端渲染\n  if (isBrowser &amp;&amp; !listening) &#123;\n    info &#x3D; &#123;&#125;;\n    calculate();\n    window.addEventListener(&quot;resize&quot;, handleResize);\n    listening &#x3D; true;\n  &#125;\n  const [state, setState] &#x3D; useState&lt;ResponsiveInfo&gt;(info);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 非客户端渲染，直接拦掉\n    if (!isBrowser) return;\n    &#x2F;&#x2F; 定义一个订阅者函数\n    const subscriber &#x3D; () &#x3D;&gt; &#123;\n      setState(info);\n    &#125;;\n    &#x2F;&#x2F; 加入订阅\n    subscribers.add(subscriber);\n    return () &#x3D;&gt; &#123;\n      subscribers.delete(subscriber);\n      if (subscribers.size &#x3D;&#x3D;&#x3D; 0) &#123;\n        window.removeEventListener(&quot;resize&quot;, handleResize);\n        listening &#x3D; false;\n      &#125;\n    &#125;;\n  &#125;, []);\n\n  return state;\n&#125;\n\n小插曲：github octotree loading\n.octotree-show\n  .octotree-sidebar.octotree-github-sidebar\n  .octotree-spin\n  .octotree-spin--loader &#123;\n  width: 16px;\n  height: 16px;\n  border-radius: 50%;\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent rgb(106, 115, 125) rgb(106, 115, 125) transparent;\n  border-image: initial;\n  border-top: 2px solid transparent;\n  border-left: 2px solid transparent;\n  animation: 0.5s linear 0s infinite normal none running loading;\n&#125;\n\nuseScrollimport useRafState from &quot;..&#x2F;useRafState&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;\n\ntype Position &#x3D; &#123; left: number; top: number &#125;;\n&#x2F;&#x2F; 我把 BasicTarget 拿过来放在这里，不会有太多割裂感\n&#x2F;&#x2F; export type BasicTarget&lt;T extends TargetType &#x3D; Element&gt; &#x3D;\n&#x2F;&#x2F;   | (() &#x3D;&gt; TargetValue&lt;T&gt;) &#x2F;&#x2F; 函数\n&#x2F;&#x2F;   | TargetValue&lt;T&gt; &#x2F;&#x2F; 直接dom\n&#x2F;&#x2F;   | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;; &#x2F;&#x2F; ref\nexport type Target &#x3D; BasicTarget&lt;Element | Document&gt;;\nexport type ScrollListenController &#x3D; (val: Position) &#x3D;&gt; boolean;\n\nfunction useScroll(\n  target?: Target,\n  shouldUpdate: ScrollListenController &#x3D; () &#x3D;&gt; true\n): Position | undefined &#123;\n  const [position, setPosition] &#x3D; useRafState&lt;Position&gt;();\n\n  const shouldUpdateRef &#x3D; useLatest(shouldUpdate);\n\n  useEffectWithTarget(\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target, document &#x2F;**兜底值 *&#x2F;);\n      if (!el) &#123;\n        return;\n      &#125;\n      const updatePosition &#x3D; () &#x3D;&gt; &#123;\n        let newPosition: Position;\n        &#x2F;&#x2F; 是不是document\n        if (el &#x3D;&#x3D;&#x3D; document) &#123;\n          &#x2F;&#x2F; ？scrollingElement啥玩意\n          &#x2F;&#x2F; @link https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Document&#x2F;scrollingElement\n          &#x2F;&#x2F; scrollingElement （ Document 的只读属性）返回滚动文档的 Element 对象的引用。\n          &#x2F;&#x2F; 在标准模式下，这是文档的根元素， document.documentElement.\n          &#x2F;&#x2F; 当在怪异模式下， scrollingElement 属性返回 HTML body 元素（若不存在返回 null ）。\n          if (document.scrollingElement) &#123;\n            newPosition &#x3D; &#123;\n              left: document.scrollingElement.scrollLeft,\n              top: document.scrollingElement.scrollTop,\n            &#125;;\n          &#125; else &#123;\n            &#x2F;&#x2F; When in quirks mode, the scrollingElement attribute returns the HTML body element if it exists and is potentially scrollable, otherwise it returns null.\n            &#x2F;&#x2F; 在quirks模式下，scrollingElement属性返回HTML主体元素（如果它存在并且可能是可滚动的），否则返回null。\n            &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Document&#x2F;scrollingElement\n            &#x2F;&#x2F; https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;28633221&#x2F;document-body-scrolltop-firefox-returns-0-only-js\n            newPosition &#x3D; &#123;\n              left: Math.max(\n                &#x2F;&#x2F; 兼容写法\n                window.pageXOffset,\n                document.documentElement.scrollLeft,\n                document.body.scrollLeft\n              ),\n              top: Math.max(\n                &#x2F;&#x2F; 兼容写法\n                window.pageYOffset,\n                document.documentElement.scrollTop,\n                document.body.scrollTop\n              ),\n            &#125;;\n          &#125;\n        &#125; else &#123;\n          newPosition &#x3D; &#123;\n            left: (el as Element).scrollLeft,\n            top: (el as Element).scrollTop,\n          &#125;;\n        &#125;\n        &#x2F;&#x2F; 默认直接返回true\n        if (shouldUpdateRef.current(newPosition)) &#123;\n          setPosition(newPosition);\n        &#125;\n      &#125;;\n      &#x2F;&#x2F; 立即执行一次\n      updatePosition();\n      &#x2F;&#x2F; 监听到scroll执行\n      el.addEventListener(&quot;scroll&quot;, updatePosition);\n      return () &#x3D;&gt; &#123;\n        el.removeEventListener(&quot;scroll&quot;, updatePosition);\n      &#125;;\n    &#125;,\n    [],\n    target\n  );\n\n  return position;\n&#125;\n\nexport default useScroll;\n\nuseSize&#x2F;&#x2F; 这里用了polyfill\nimport ResizeObserver from &quot;resize-observer-polyfill&quot;;\nimport useRafState from &quot;..&#x2F;useRafState&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport useIsomorphicLayoutEffectWithTarget from &quot;..&#x2F;utils&#x2F;useIsomorphicLayoutEffectWithTarget&quot;;\n\ntype Size &#x3D; &#123; width: number; height: number &#125;;\n\nfunction useSize(target: BasicTarget): Size | undefined &#123;\n  const [state, setState] &#x3D; useRafState&lt;Size&gt;();\n\n  useIsomorphicLayoutEffectWithTarget(\n    &#x2F;&#x2F; useEffect第一个函数\n    () &#x3D;&gt; &#123;\n      const el &#x3D; getTargetElement(target);\n\n      if (!el) &#123;\n        return;\n      &#125;\n\n      const resizeObserver &#x3D; new ResizeObserver((entries) &#x3D;&gt; &#123;\n        entries.forEach((entry) &#x3D;&gt; &#123;\n          const &#123; clientWidth, clientHeight &#125; &#x3D; entry.target;\n          setState(&#123;\n            width: clientWidth,\n            height: clientHeight,\n          &#125;);\n        &#125;);\n      &#125;);\n      &#x2F;&#x2F; 开始观察某个dom\n      resizeObserver.observe(el);\n      return () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 停止观察dom\n        resizeObserver.disconnect();\n      &#125;;\n    &#125;,\n    &#x2F;&#x2F; useEffect的依赖项\n    [],\n    target &#x2F;&#x2F; 也参与依赖项计算 depsAreSame\n  );\n\n  return state;\n&#125;\n\nexport default useSize;\n\nuseIsomorphicLayoutEffectWithTargetimport isBrowser from &quot;.&#x2F;isBrowser&quot;;\nimport useEffectWithTarget from &quot;.&#x2F;useEffectWithTarget&quot;;\nimport useLayoutEffectWithTarget from &quot;.&#x2F;useLayoutEffectWithTarget&quot;;\n&#x2F;&#x2F; 对用不同的执行环境，进行区分\nconst useIsomorphicLayoutEffectWithTarget &#x3D; isBrowser\n  ? useLayoutEffectWithTarget\n  : useEffectWithTarget;\n\nexport default useIsomorphicLayoutEffectWithTarget;\n\nuseReactive （这个比较特别）提供一种数据响应式的操作体验，定义数据状态不需要写 useState，直接修改属性即可刷新视图。\nimport &#123; useRef &#125; from &quot;react&quot;;\nimport useCreation from &quot;..&#x2F;useCreation&quot;;\nimport useUpdate from &quot;..&#x2F;useUpdate&quot;;\nimport &#123; isObject &#125; from &quot;..&#x2F;utils&quot;;\n\n&#x2F;&#x2F; k:v 原对象:代理过的对象\nconst proxyMap &#x3D; new WeakMap();\n&#x2F;&#x2F; k:v 代理过的对象:原对象\nconst rawMap &#x3D; new WeakMap();\n\nfunction observer&lt;T extends Record&lt;string, any&gt;&gt;(\n  initialVal: T,\n  cb: () &#x3D;&gt; void\n): T &#123;\n  const existingProxy &#x3D; proxyMap.get(initialVal);\n\n  &#x2F;&#x2F; 添加缓存 防止重新构建proxy\n  &#x2F;&#x2F; 如果重复构建，会怎样？\n  if (existingProxy) &#123;\n    return existingProxy;\n  &#125;\n\n  &#x2F;&#x2F; 防止代理已经代理过的对象 浏览器奔溃\n  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;839\n  if (rawMap.has(initialVal)) &#123;\n    return initialVal;\n  &#125;\n\n  const proxy &#x3D; new Proxy&lt;T&gt;(initialVal, &#123;\n    get(target, key, receiver) &#123;\n      const res &#x3D; Reflect.get(target, key, receiver);\n      &#x2F;&#x2F; 把所有的嵌套对象都给监听\n      return isObject(res) ? observer(res, cb) : Reflect.get(target, key);\n    &#125;,\n    set(target, key, val) &#123;\n      const ret &#x3D; Reflect.set(target, key, val);\n      cb();\n      return ret;\n    &#125;,\n    deleteProperty(target, key) &#123;\n      const ret &#x3D; Reflect.deleteProperty(target, key);\n      cb();\n      return ret;\n    &#125;,\n  &#125;);\n\n  proxyMap.set(initialVal, proxy);\n  rawMap.set(proxy, initialVal);\n\n  return proxy;\n&#125;\n\nfunction useReactive&lt;S extends Record&lt;string, any&gt;&gt;(initialState: S): S &#123;\n  const update &#x3D; useUpdate();\n  const stateRef &#x3D; useRef&lt;S&gt;(initialState);\n  &#x2F;&#x2F; useCreation，非必要不更新\n  const state &#x3D; useCreation(\n    &#x2F;**工厂*&#x2F; () &#x3D;&gt; &#123;\n      return observer(\n        stateRef.current &#x2F;**initialVal *&#x2F;,\n        &#x2F;**回调*&#x2F; () &#x3D;&gt; &#123;\n          update(); &#x2F;&#x2F; 刷新，我比较好奇，这么刷新，react傻呆呆又要重新计算一遍吗\n        &#125;\n      );\n    &#125;,\n    []\n  );\n\n  return state;\n&#125;\n\nexport default useReactive;\n\nuseCreation\n\n\n\n\n\n\n\n\nuseCreation 是 useMemo 或 useRef 的替代品。\n因为 useMemo 不能保证被 memo 的值一定不会被重计算，而 useCreation 可以保证这一点。以下为 React 官方文档中的介绍\nimport type &#123; DependencyList &#125; from &quot;react&quot;;\nimport &#123; useRef &#125; from &quot;react&quot;;\nimport depsAreSame from &quot;..&#x2F;utils&#x2F;depsAreSame&quot;;\n\nexport default function useCreation&lt;T&gt;(factory: () &#x3D;&gt; T, deps: DependencyList) &#123;\n  const &#123; current &#125; &#x3D; useRef(&#123;\n    deps,\n    obj: undefined as undefined | T,\n    initialized: false,\n  &#125;);\n  &#x2F;&#x2F; 发生变化时候，就会重新计算\n  if (current.initialized &#x3D;&#x3D;&#x3D; false || !depsAreSame(current.deps, deps)) &#123;\n    current.deps &#x3D; deps;\n    current.obj &#x3D; factory(); &#x2F;&#x2F; 工厂\n    current.initialized &#x3D; true;\n  &#125;\n  return current.obj as T;\n&#125;\n\nuseTrackedEffectimport type &#123; DependencyList &#125; from &quot;react&quot;;\nimport &#123; useEffect, useRef &#125; from &quot;react&quot;;\n\ntype Effect &#x3D; (\n  changes?: number[],\n  previousDeps?: DependencyList, &#x2F;&#x2F; 之前的依赖\n  currentDeps?: DependencyList &#x2F;&#x2F; 之后的依赖\n) &#x3D;&gt; void | (() &#x3D;&gt; void);\n\nconst diffTwoDeps &#x3D; (deps1?: DependencyList, deps2?: DependencyList) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;Let&#39;s do a reference equality check on 2 dependency list.\n  &#x2F;&#x2F;If deps1 is defined, we iterate over deps1 and do comparison on each element with equivalent element from deps2\n  &#x2F;&#x2F;As this func is used only in this hook, we assume 2 deps always have same length.\n  return deps1\n    ? &#x2F;&#x2F; deps1（缓存）有， deps2 有 则用Object.is比较\n      deps1\n        .map((_ele, idx) &#x3D;&gt; (!Object.is(deps1[idx], deps2?.[idx]) ? idx : -1))\n        .filter((ele) &#x3D;&gt; ele &gt;&#x3D; 0)\n    : &#x2F;&#x2F; deps1（缓存）没有， deps2 有 则把第二个取个遍，否则，返回[]\n    deps2\n    ? deps2.map((_ele, idx) &#x3D;&gt; idx)\n    : [];\n&#125;;\n\nconst useTrackedEffect &#x3D; (effect: Effect, deps?: DependencyList) &#x3D;&gt; &#123;\n  const previousDepsRef &#x3D; useRef&lt;DependencyList&gt;();\n\n  useEffect(() &#x3D;&gt; &#123;\n    const changes &#x3D; diffTwoDeps(\n      previousDepsRef.current &#x2F;**之前的依赖缓存了 *&#x2F;,\n      deps\n    );\n    const previousDeps &#x3D; previousDepsRef.current;\n    previousDepsRef.current &#x3D; deps;\n    return effect(changes, previousDeps, deps);\n  &#125;, deps);\n&#125;;\n\nexport default useTrackedEffect;\n\nuseVirtualListimport &#123; useEffect, useMemo, useState, useRef &#125; from &quot;react&quot;;\nimport useEventListener from &quot;..&#x2F;useEventListener&quot;;\nimport useLatest from &quot;..&#x2F;useLatest&quot;;\nimport useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;\nimport useSize from &quot;..&#x2F;useSize&quot;;\nimport &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;\nimport &#123; isNumber &#125; from &quot;..&#x2F;utils&quot;;\n\ntype ItemHeight&lt;T&gt; &#x3D; (index: number, data: T) &#x3D;&gt; number;\n\nexport interface Options&lt;T&gt; &#123;\n  containerTarget: BasicTarget; &#x2F;&#x2F; 外面容器，支持 DOM 节点或者 Ref 对象\n  wrapperTarget: BasicTarget; &#x2F;&#x2F; 内部容器，支持 DOM 节点或者 Ref 对象\n  itemHeight: number | ItemHeight&lt;T&gt;; &#x2F;&#x2F; 行高度，静态高度可以直接写入像素值，动态高度可传入函数， 这里的动态是假动态，净骗我，意思是你算好了给 useVirtualList ，就认为你的是动态，并非 “完全自动计算高度”\n  overscan?: number; &#x2F;&#x2F; 视区上、下额外展示的 DOM 节点数量\n&#125;\n\nconst useVirtualList &#x3D; &lt;T &#x3D; any&gt;(list: T[], options: Options&lt;T&gt;) &#x3D;&gt; &#123;\n  const &#123; containerTarget, wrapperTarget, itemHeight, overscan &#x3D; 5 &#125; &#x3D; options;\n\n  &#x2F;&#x2F; 缓存了下\n  const itemHeightRef &#x3D; useLatest(itemHeight);\n  &#x2F;&#x2F; 计算容器宽高\n  const size &#x3D; useSize(containerTarget);\n  &#x2F;&#x2F; 是不是scrollToFunc 触发的滚动\n  const scrollTriggerByScrollToFunc &#x3D; useRef(false);\n  &#x2F;&#x2F; 展示的数据\n  const [targetList, setTargetList] &#x3D; useState&lt;&#123; index: number; data: T &#125;[]&gt;(\n    []\n  );\n  &#x2F;&#x2F; 可见数量\n  const getVisibleCount &#x3D; (containerHeight: number, fromIndex: number) &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      &#x2F;&#x2F; 容器高度&#x2F;每个元素高度\n      return Math.ceil(\n        &#x2F;**天花板，向上取整*&#x2F; containerHeight &#x2F; itemHeightRef.current\n      );\n    &#125;\n\n    let sum &#x3D; 0;\n    let endIndex &#x3D; 0;\n    for (let i &#x3D; fromIndex; i &lt; list.length; i++) &#123;\n      const height &#x3D; itemHeightRef.current(i, list[i]);\n      sum +&#x3D; height;\n      endIndex &#x3D; i;\n      if (sum &gt;&#x3D; containerHeight) &#123;\n        break;\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 最后一个可见元素 - 开始元素 &#x3D;  可见元素数量\n    return endIndex - fromIndex;\n  &#125;;\n  &#x2F;&#x2F; 获取间隔数量\n  const getOffset &#x3D; (scrollTop: number) &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      return Math.floor(scrollTop &#x2F; itemHeightRef.current) + 1;\n    &#125;\n    let sum &#x3D; 0;\n    let offset &#x3D; 0;\n    for (let i &#x3D; 0; i &lt; list.length; i++) &#123;\n      const height &#x3D; itemHeightRef.current(i, list[i]);\n      sum +&#x3D; height;\n      if (sum &gt;&#x3D; scrollTop) &#123;\n        offset &#x3D; i;\n        break;\n      &#125;\n    &#125;\n    return offset + 1;\n  &#125;;\n\n  &#x2F;&#x2F; 获取顶部距离\n  const getDistanceTop &#x3D; (index: number) &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      const height &#x3D; index * itemHeightRef.current;\n      return height;\n    &#125;\n    const height &#x3D; list\n      .slice(0, index)\n      .reduce(\n        (sum, _, i) &#x3D;&gt;\n          sum +\n          (itemHeightRef.current as ItemHeight&lt;T&gt;)(\n            i,\n            list[i]\n          ) &#x2F;**这块是个函数，参数是 i, item *&#x2F;,\n        0\n      );\n    return height;\n  &#125;;\n  &#x2F;&#x2F; 高度和\n  const totalHeight &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (isNumber(itemHeightRef.current)) &#123;\n      return list.length * itemHeightRef.current;\n    &#125;\n    return list.reduce(\n      (sum, _, index) &#x3D;&gt;\n        sum + (itemHeightRef.current as ItemHeight&lt;T&gt;)(index, list[index]),\n      0\n    );\n  &#125;, [list]);\n  &#x2F;&#x2F;\n  const calculateRange &#x3D; () &#x3D;&gt; &#123;\n    const container &#x3D; getTargetElement(containerTarget);\n    const wrapper &#x3D; getTargetElement(wrapperTarget) as HTMLElement;\n\n    if (container &amp;&amp; wrapper) &#123;\n      const &#123; scrollTop, clientHeight &#125; &#x3D; container;\n\n      const offset &#x3D; getOffset(scrollTop);\n      const visibleCount &#x3D; getVisibleCount(clientHeight, offset);\n\n      const start &#x3D; Math.max(0, offset - overscan);\n      const end &#x3D; Math.min(list.length, offset + visibleCount + overscan);\n\n      const offsetTop &#x3D; getDistanceTop(start);\n      &#x2F;&#x2F; 这里是计算内部容器上边距（用margin和height看来对未渲染的元素进行占位） 下面放个图：\n      &#x2F;&#x2F; http:&#x2F;&#x2F;t-blog-images.aijs.top&#x2F;img&#x2F;202209021833942.webp\n      wrapper.style.height &#x3D; totalHeight - offsetTop + &quot;px&quot;;\n      wrapper.style.marginTop &#x3D; offsetTop + &quot;px&quot;;\n      &#x2F;&#x2F; 可见元素\n      setTargetList(\n        list.slice(start, end).map((ele, index) &#x3D;&gt; (&#123;\n          data: ele,\n          index: index + start,\n        &#125;))\n      );\n    &#125;\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!size?.width || !size?.height) &#123;\n      return;\n    &#125;\n    calculateRange();\n  &#125;, [size?.width, size?.height, list]);\n  &#x2F;&#x2F; 监听滚动，进行不断的计算\n  useEventListener(\n    &quot;scroll&quot;,\n    (e) &#x3D;&gt; &#123;\n      if (scrollTriggerByScrollToFunc.current) &#123;\n        scrollTriggerByScrollToFunc.current &#x3D; false;\n        return;\n      &#125;\n      e.preventDefault();\n      calculateRange();\n    &#125;,\n    &#123;\n      target: containerTarget,\n    &#125;\n  );\n  &#x2F;&#x2F; 滚动到某个下标\n  const scrollTo &#x3D; (index: number) &#x3D;&gt; &#123;\n    const container &#x3D; getTargetElement(containerTarget);\n    if (container) &#123;\n      scrollTriggerByScrollToFunc.current &#x3D; true;\n      container.scrollTop &#x3D; getDistanceTop(index);\n      calculateRange();\n    &#125;\n  &#125;;\n\n  return [targetList, useMemoizedFn(scrollTo)] as const;\n&#125;;\n\nexport default useVirtualList;\n\n这里是计算内部容器上边距（用 margin 和 height 来对未渲染的元素进行占位）\n\n\nuseRequest 难搞哦 有点多总结\nhooks 设计目标导向，拿到哪些值 和 api\n\n","slug":"2022-08-24ahooks","date":"2022-08-24T09:16:49.000Z","categories_index":"源码","tags_index":"源码","author_index":"举手摘月亮"},{"id":"b204c24ab6e396e5de06d4bc0adf7d2a","title":"有过期机制的localStorage","content":"场景对于一些数据不经常更新的数据，保持一定时间的新鲜的时候可以用于缓存\nlocalStorage见原文\n把原文代码改了下，主要对JSON.parse进行 fixed\nStorage.prototype.setStorageWithAge &#x3D; (key, value, expires &#x3D; 60 * 1000) &#x3D;&gt; &#123;\n  if (isNaN(expires) || expires &lt; 1)\n    throw new Error(&quot;expires must be a number&quot;);\n  const obj &#x3D; &#123;\n    data: value,\n    &#x2F;&#x2F;存储值\n    time: Date.now(),\n    &#x2F;&#x2F;存值时间戳\n    maxExpires: expires,\n    &#x2F;&#x2F;过期时间\n  &#125;;\n  localStorage.setItem(key, JSON.stringify(obj));\n&#125;;\n\nStorage.prototype.getStorageWithAge &#x3D; (key) &#x3D;&gt; &#123;\n  try &#123;\n    const &#123; data, time, maxExpires &#125; &#x3D; JSON.parse(localStorage.getItem(key));\n    if (time + maxExpires &lt; Date.now()) &#123;\n      localStorage.removeItem(key);\n      return undefined;\n    &#125;\n    return data;\n  &#125; catch (error) &#123;\n    return undefined; &#x2F;&#x2F; JSON.parse解析undefined时候直接返回\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 测试数据\nlocalStorage.setStorageWithAge(&quot;amingxiansen&quot;, &quot;测试过期时间&quot;, 5000);\nlocalStorage.getStorageWithAge(&quot;amingxiansen&quot;);\n\n\n\n注意：对于一些敏感数据，需要加密\n","slug":"2022-08-24expirestorage","date":"2022-08-24T08:49:06.000Z","categories_index":"存储","tags_index":"存储","author_index":"举手摘月亮"},{"id":"66abc3dc4231aab7cbe8387d3c356301","title":"react hook 如何增加依赖更新","content":"背景想将，业务逻辑按钮组封装为 hook,在移动端和 pc 端之间进行逻辑复用。在详情页面使用时候，发现并没有生效\n原因： 无法给 useActions，增加依赖项，类似 useEffect 的第二参数一样。\n查询了 ahooks 的 hook，了解类似解决方案\nuseActionsimport &#123; EUserType, EnumProblemStatus &#125; from &quot;@&#x2F;const&quot;;\nimport &#123; CommonModel &#125; from &quot;@&#x2F;models&quot;;\nimport &#123; useMemo &#125; from &quot;react&quot;;\nimport &#123; useSelector &#125; from &quot;react-redux&quot;;\n\nexport const useActions &#x3D; (detail) &#x3D;&gt; &#123;\n  const user &#x3D; useSelector(CommonModel.selectors.getUser);\n  const &#123; state: status &#125; &#x3D; detail;\n\n  const userType &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (detail?.creatorPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;\n      return EUserType.creator;\n    &#125;\n    if (detail?.solverStaffPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;\n      return EUserType.operator;\n    &#125;\n    if (\n      detail?.cooperationStaffs?.findIndex(\n        (item) &#x3D;&gt; item.personId &#x3D;&#x3D;&#x3D; user.staffId\n      ) &gt; -1\n    ) &#123;\n      return EUserType.helper;\n    &#125;\n    return EUserType.other;\n  &#125;, [\n    detail?.cooperationStaffs,\n    detail.creatorPerson?.personId,\n    detail?.solverStaffPerson?.personId,\n    user?.staffId,\n  ]);\n  const btnComps &#x3D; useMemo(\n    () &#x3D;&gt; (&#123;\n      &#x2F;&#x2F; edit: &#123;\n      &#x2F;&#x2F;   text: &#39;编辑&#39;,\n      &#x2F;&#x2F;   key: &#39;edit&#39;,\n      &#x2F;&#x2F; &#125;,\n      start_solve: &#123;\n        text: &quot;开始处理&quot;,\n        key: &quot;start_solve&quot;,\n        value: 2,\n      &#125;,\n      cancel: &#123;\n        text: &quot;撤销&quot;,\n        icon: &quot;icon-huifu&quot;,\n        disabledMessage: &quot;非创建人不可撤销&quot;,\n        key: &quot;cancel&quot;,\n        type: &quot;default&quot;,\n        confirm: true,\n        value: 7,\n        disabled: user.staffId !&#x3D;&#x3D; detail?.creatorPerson?.personId,\n      &#125;,\n      trans: &#123;\n        text: &quot;转交&quot;,\n        icon: &quot;icon-transfer&quot;,\n        key: &quot;trans&quot;,\n        message: &quot;请选择转交人&quot;,\n        required: true,\n        contact: true,\n        limit: 1,\n        allowType: [&quot;staff&quot;],\n        defaultValue: [],\n        disabledValues: [user.staffId],\n        value: 8,\n      &#125;,\n      finish: &#123;\n        text: &quot;完结&quot;,\n        icon: &quot;icon-guangbo&quot;,\n        key: &quot;finish&quot;,\n        confirm: true,\n        value: 6,\n      &#125;,\n      cuiBan: &#123;\n        text: &quot;催办&quot;,\n        key: &quot;cuiBan&quot;,\n        confirm: true,\n        value: 12,\n      &#125;,\n      solved: &#123;\n        text: &quot;已解决&quot;,\n        icon: &quot;icon-yiwancheng&quot;,\n        key: &quot;solved&quot;,\n        confirm: true,\n        value: 5,\n      &#125;,\n      changer: &#123;\n        text: &quot;变更经办人&quot;,\n        key: &quot;changer&quot;,\n        contact: true,\n        limit: 1,\n        allowType: [&quot;staff&quot;],\n        defaultValue: [],\n        message: &quot;请选择转变更经办人&quot;,\n        required: true,\n        value: 8,\n        disabledValues: [user.staffId],\n      &#125;,\n      add_helper: &#123;\n        text: &quot;添加协作人&quot;,\n        key: &quot;add_helper&quot;,\n        icon: &quot;icon-teamwork&quot;,\n        contact: true,\n        allowType: [&quot;staff&quot;],\n        defaultValue: [],\n        message: &quot;请选择协作人&quot;,\n        required: true,\n        value: 9,\n      &#125;,\n      notify_creator: &#123;\n        text: &quot;提醒确认&quot;,\n        key: &quot;notify_creator&quot;,\n        icon: &quot;icon-querentixing&quot;,\n        confirm: true,\n        value: 13,\n      &#125;,\n      receiver: &#123;\n        text: &quot;认领处理&quot;,\n        key: &quot;receiver&quot;,\n        icon: &quot;icon-receiver&quot;,\n        confirm: true,\n        value: 8,\n      &#125;,\n      exit_helper: &#123;\n        text: &quot;退出协作&quot;,\n        key: &quot;exit_helper&quot;,\n        confirm: true,\n        value: 11,\n      &#125;,\n      join: &#123;\n        text: &quot;加入协作&quot;,\n        confirm: true,\n        key: &quot;join&quot;,\n        value: 9,\n      &#125;,\n      continue: &#123;\n        text: &quot;继续处理&quot;,\n        key: &quot;continue&quot;,\n        value: 2,\n      &#125;,\n      end: &#123;\n        text: &quot;完结&quot;,\n        key: &quot;end&quot;,\n        confirm: true,\n        value: 6,\n      &#125;,\n    &#125;),\n    [detail.problemId]\n  );\n  const actionBtns &#x3D; useMemo(() &#x3D;&gt; &#123;\n    const btns &#x3D; [];\n    switch (status) &#123;\n      case EnumProblemStatus.waiting:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            btns.push(btnComps.cancel);\n            btns.push(btnComps.cuiBan);\n            btns.push(btnComps.changer);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.start_solve);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.processing:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.solved);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.delay:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            btns.push(btnComps.cancel);\n            btns.push(btnComps.cuiBan);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.solved);\n            btns.push(btnComps.continue);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.overdue:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            btns.push(btnComps.cancel);\n            btns.push(btnComps.cuiBan);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.solved);\n            btns.push(btnComps.continue);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.solved:\n        switch (userType) &#123;\n          case EUserType.creator:\n            btns.push(btnComps.end);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.notify_creator);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.finish:\n        break;\n\n      case EnumProblemStatus.cancel:\n        break;\n\n      default:\n        break;\n    &#125;\n    return btns;\n  &#125;, [detail.status, userType]);\n\n  return actionBtns;\n&#125;;\n\nahooks 中 依赖刷新见\nuseRequest 提供了一个 options.refreshDeps 参数，当它的值变化后，会重新触发请求。\nconst [userId, setUserId] &#x3D; useState(&quot;1&quot;);\n\nconst &#123; data, run &#125; &#x3D; useRequest(() &#x3D;&gt; getUserSchool(userId), &#123;\n  refreshDeps: [userId],\n&#125;);\n\n上面的示例代码，useRequest 会在初始化和 userId 变化时，触发函数执行。\n与下面代码实现功能完全一致\nconst [userId, setUserId] &#x3D; useState(&quot;1&quot;);\n\nconst &#123; data, refresh &#125; &#x3D; useRequest(() &#x3D;&gt; getUserSchool(userId));\n\nuseEffect(() &#x3D;&gt; &#123;\n  refresh();\n&#125;, [userId]);\n\nuseRequest 源码找找 options?: Options&lt;TData, TParams&gt;,\n refreshDeps type\n const fetchInstance &#x3D; useCreation(() &#x3D;&gt; {\nexport default function useCreation&lt;T&gt;(factory: () =&gt; T, deps: DependencyList) &#123;\nuseCreation usecreation\n\n\nfunction useCreation&lt;T&gt;(factory: () &#x3D;&gt; T, deps: any[]): T;\n\nimport React, &#123; useState &#125; from &quot;react&quot;;\nimport &#123; useCreation &#125; from &quot;ahooks&quot;;\n\nclass Foo &#123;\n  constructor() &#123;\n    this.data &#x3D; Math.random();\n  &#125;\n\n  data: number;\n&#125;\n\nexport default function () &#123;\n  const foo &#x3D; useCreation(() &#x3D;&gt; new Foo(), []); &#x2F;&#x2F; 依赖项没变化， 不会重复执行 factory\n  const [, setFlag] &#x3D; useState(&#123;&#125;);\n  return (\n    &lt;&gt;\n      &lt;p&gt;&#123;foo.data&#125;&lt;&#x2F;p&gt;\n      &lt;button\n        type&#x3D;&quot;button&quot;\n        onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n          setFlag(&#123;&#125;); &#x2F;&#x2F; 对象更新\n        &#125;&#125;\n      &gt;\n        Rerender\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n\n至此，这里的实例化也好理解了\n以上内容想歪了\n中途试用了useCreation, eslint不能够提示依赖项，所以又回到了useMemo\n\n&#x2F;&#x2F; useActions\nimport &#123; EnumProblemStatus, EUserType &#125; from &quot;@&#x2F;const&quot;;\nimport &#123; IProblemDetail &#125; from &quot;@&#x2F;services&#x2F;problems&quot;;\nimport &#123; useMemo &#125; from &quot;react&quot;;\n\nexport const useActions &#x3D; (\n  detail: IProblemDetail,\n  user: Staff,\n  mobile &#x3D; false\n) &#x3D;&gt; &#123;\n  const userType &#x3D; useMemo(() &#x3D;&gt; &#123;\n    if (detail?.creatorPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;\n      return EUserType.creator;\n    &#125;\n    if (detail?.solverStaffPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;\n      return EUserType.operator;\n    &#125;\n    if (\n      detail?.cooperationStaffs?.findIndex(\n        (item) &#x3D;&gt; item.personId &#x3D;&#x3D;&#x3D; user.staffId\n      ) &gt; -1\n    ) &#123;\n      return EUserType.helper;\n    &#125;\n    return EUserType.other;\n  &#125;, [\n    detail?.cooperationStaffs,\n    detail.creatorPerson?.personId,\n    detail?.solverStaffPerson?.personId,\n    user?.staffId,\n  ]);\n\n  const btnComps &#x3D; useMemo(() &#x3D;&gt; &#123;\n    const &#123; creatorPerson, solverStaffPerson, cooperationStaffs &#x3D; [] &#125; &#x3D; detail;\n    if (!creatorPerson) return;\n\n    const disabled_solverStaffPersonIds &#x3D; []\n      .concat(creatorPerson.personId)\n      .concat(solverStaffPerson.personId || []);\n\n    const disabled_cooperationStaffsIds &#x3D; []\n      .concat(creatorPerson.personId)\n      .concat(solverStaffPerson.personId || [])\n      .concat(cooperationStaffs.map((item) &#x3D;&gt; item.personId));\n\n    return &#123;\n      &#x2F;&#x2F; edit: &#123;\n      &#x2F;&#x2F;   title: &#39;编辑&#39;,\n      &#x2F;&#x2F;   key: &#39;edit&#39;,\n      &#x2F;&#x2F; &#125;,\n      comment: &#123;\n        title: &quot;评论&quot;,\n        key: &quot;comment&quot;,\n        icon: &quot;icon-kuaisuhuifu&quot;,\n        keep: true,\n      &#125;,\n      start_solve: &#123;\n        title: &quot;开始处理&quot;,\n        key: &quot;start_solve&quot;,\n        icon: &quot;icon-kaishi&quot;,\n        value: 2,\n      &#125;,\n      cancel: &#123;\n        title: &quot;撤销&quot;,\n        icon: &quot;icon-huifu&quot;,\n        disabledMessage: &quot;非创建人不可撤销&quot;,\n        key: &quot;cancel&quot;,\n        type: &quot;default&quot;,\n        confirm: true,\n        value: 7,\n      &#125;,\n      trans: &#123;\n        title: &quot;转交&quot;,\n        icon: &quot;icon-transfer&quot;,\n        key: &quot;trans&quot;,\n        message: &quot;请选择转交人&quot;,\n        required: true,\n        contact: true,\n        limit: 1,\n        allowType: [&quot;staff&quot;],\n        defaultValue: [],\n        disabledValues: disabled_solverStaffPersonIds,\n        value: 8,\n      &#125;,\n      finish: &#123;\n        title: &quot;完结&quot;,\n        icon: &quot;icon-guangbo&quot;,\n        key: &quot;finish&quot;,\n        confirm: true,\n        value: 6,\n      &#125;,\n      cuiBan: &#123;\n        title: &quot;催办&quot;,\n        key: &quot;cuiBan&quot;,\n        icon: &quot;icon-guangbo&quot;,\n        confirm: true,\n        value: 12,\n      &#125;,\n      solved: &#123;\n        title: &quot;已解决&quot;,\n        icon: &quot;icon-yiwancheng&quot;,\n        key: &quot;solved&quot;,\n        confirm: true,\n        value: 5,\n      &#125;,\n      changer: &#123;\n        title: &quot;变更经办人&quot;,\n        key: &quot;changer&quot;,\n        contact: true,\n        icon: &quot;icon-transfer&quot;,\n        limit: 1,\n        allowType: [&quot;staff&quot;],\n        defaultValue: [],\n        message: &quot;请选择转变更经办人&quot;,\n        required: true,\n        value: 8,\n        disabledValues: disabled_solverStaffPersonIds,\n      &#125;,\n      add_helper: &#123;\n        title: &quot;添加协作人&quot;,\n        key: &quot;add_helper&quot;,\n        icon: &quot;icon-teamwork&quot;,\n        contact: true,\n        allowType: [&quot;staff&quot;],\n        defaultValue: [],\n        message: &quot;请选择协作人&quot;,\n        required: true,\n        value: 9,\n        disabledValues: disabled_cooperationStaffsIds,\n      &#125;,\n      notify_creator: &#123;\n        title: &quot;提醒确认&quot;,\n        key: &quot;notify_creator&quot;,\n        icon: &quot;icon-querentixing&quot;,\n        confirm: true,\n        value: 13,\n      &#125;,\n      receiver: &#123;\n        title: &quot;认领处理&quot;,\n        key: &quot;receiver&quot;,\n        icon: &quot;icon-receiver&quot;,\n        confirm: true,\n        value: 8,\n      &#125;,\n      exit_helper: &#123;\n        title: &quot;退出协作&quot;,\n        key: &quot;exit_helper&quot;,\n        confirm: true,\n        icon: &quot;icon-tuichu&quot;,\n        value: 11,\n      &#125;,\n      join: &#123;\n        title: &quot;加入协作&quot;,\n        confirm: true,\n        key: &quot;join&quot;,\n        icon: &quot;icon-join&quot;,\n        value: 9,\n      &#125;,\n      continue: &#123;\n        title: &quot;继续处理&quot;,\n        key: &quot;continue&quot;,\n        value: 2,\n      &#125;,\n      end: &#123;\n        title: &quot;完结&quot;,\n        key: &quot;end&quot;,\n        confirm: true,\n        icon: &quot;icon-jieshu&quot;,\n        value: 6,\n      &#125;,\n    &#125;;\n  &#125;, [detail]);\n\n  const actions &#x3D; useMemo(() &#x3D;&gt; &#123;\n    const btns &#x3D; [];\n    const solverId &#x3D; detail.solverStaffPerson?.personId;\n    if (!btnComps) return [];\n\n    mobile &amp;&amp; btns.push(btnComps.comment);\n    switch (detail.state) &#123;\n      case EnumProblemStatus.waiting:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            btns.push(btnComps.cancel);\n            btns.push(btnComps.cuiBan);\n            btns.push(btnComps.changer);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.start_solve);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.processing:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            !solverId &amp;&amp; btns.push(btnComps.changer);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.solved);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.delay:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            btns.push(btnComps.cancel);\n            btns.push(btnComps.cuiBan);\n            !solverId &amp;&amp; btns.push(btnComps.changer);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.solved);\n            btns.push(btnComps.continue);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.overdue:\n        switch (userType) &#123;\n          case EUserType.creator:\n            &#x2F;&#x2F; btns.push(btnComps.edit)\n            btns.push(btnComps.cancel);\n            btns.push(btnComps.cuiBan);\n            !solverId &amp;&amp; btns.push(btnComps.changer);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.trans);\n            btns.push(btnComps.solved);\n            btns.push(btnComps.continue);\n            btns.push(btnComps.add_helper);\n            break;\n          case EUserType.helper:\n            btns.push(btnComps.exit_helper);\n            break;\n          case EUserType.other:\n            btns.push(btnComps.receiver);\n            btns.push(btnComps.join);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.solved:\n        switch (userType) &#123;\n          case EUserType.creator:\n            btns.push(btnComps.end);\n            break;\n          case EUserType.operator:\n            btns.push(btnComps.notify_creator);\n            break;\n          default:\n        &#125;\n        break;\n      case EnumProblemStatus.finish:\n        break;\n\n      case EnumProblemStatus.cancel:\n        break;\n\n      default:\n        break;\n    &#125;\n    return btns;\n  &#125;, [\n    detail.solverStaffPerson?.personId,\n    detail.state,\n    btnComps,\n    mobile,\n    userType,\n  ]);\n  return actions;\n&#125;;\n\n&#x2F;&#x2F; 使用\nconst actionBtns &#x3D; useActions(detail, user);\n","slug":"2022-08-23react-hook","date":"2022-08-23T08:25:15.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"c362c8649d871624a90f1e24b5ef0828","title":"tree","content":"mysql 存储的几种方式见\n\n\n1,4 用过， 2 见过（当前公司 DHR 系统组织架构在用）\njs 获取树某个节点场景：编辑树节点，刷新树数据，进行编辑节点回显，某些情况下，树节点被转移他人，当前节点不需要回显\n代码&#x2F;**\n *\n * @param &#123;要查询的节点key&#125; targetValue\n * @param &#123;数组形式，树数据&#125; data\n * @returns\n *&#x2F;\nconst findTreeNodeByKey &#x3D; (\n  tree: TreeNode[],\n  targetValue: string | number,\n  options &#x3D; &#123;\n    find_field: &quot;id&quot;,\n    children: &quot;children&quot;,\n  &#125;\n) &#x3D;&gt; &#123;\n  let result &#x3D; null;\n  const ffindeNodeByKey &#x3D; (\n    data: TreeNode[],\n    skey: string | number,\n    options\n  ) &#x3D;&gt; &#123;\n    const loop &#x3D; (_data, options) &#x3D;&gt; &#123;\n      _data.forEach((item) &#x3D;&gt; &#123;\n        if (item[find_field] &#x3D;&#x3D;&#x3D; skey) &#123;\n          result &#x3D; item;\n        &#125;\n        if (item[options.children]) &#123;\n          loop(item[options.children], options);\n        &#125;\n      &#125;);\n    &#125;;\n\n    return loop(data, options);\n  &#125;;\n  ffindeNodeByKey(tree, targetValue, options);\n  return result;\n&#125;;\n\n测试数据\n测试数据详情\nconst data &#x3D; [\n  &#123;\n    id: 0,\n    parentId: null,\n    bizName: &quot;所有业务&quot;,\n    child: [\n      &#123;\n        id: 1,\n        parentId: 0,\n        bizName: &quot;APP项目组1&quot;,\n        child: [\n          &#123;\n            id: 2,\n            parentId: 1,\n            bizName: &quot;APP项目组-1&quot;,\n          &#125;,\n          &#123;\n            id: 27,\n            parentId: 1,\n            bizName: &quot;测试&quot;,\n          &#125;,\n        ],\n      &#125;,\n      &#123;\n        id: 3,\n        parentId: 0,\n        bizName: &quot;0-APP项目组&quot;,\n        child: [\n          &#123;\n            id: 29,\n            parentId: 3,\n            bizName: &quot;测试业务线&quot;,\n          &#125;,\n          &#123;\n            id: 42,\n            parentId: 3,\n            bizName: &quot;测试acl&quot;,\n          &#125;,\n        ],\n      &#125;,\n      &#123;\n        id: 5,\n        parentId: 0,\n        bizName: &quot;测试的业务线4&quot;,\n        child: [\n          &#123;\n            id: 23,\n            parentId: 5,\n            bizName: &quot;业务线测试&quot;,\n          &#125;,\n        ],\n      &#125;,\n      &#123;\n        id: 6,\n        parentId: 0,\n        bizName: &quot;测试的业务线5&quot;,\n        child: [\n          &#123;\n            id: 24,\n            parentId: 6,\n            bizName: &quot;测试测试业务线报错&quot;,\n          &#125;,\n        ],\n      &#125;,\n      &#123;\n        id: 8,\n        parentId: 0,\n        bizName: &quot;测试的业务线8&quot;,\n        child: [\n          &#123;\n            id: 25,\n            parentId: 8,\n            bizName: &quot;开发测试的业务线21&quot;,\n          &#125;,\n          &#123;\n            id: 26,\n            parentId: 8,\n            bizName: &quot;开发测试的业务线22&quot;,\n          &#125;,\n        ],\n      &#125;,\n      &#123;\n        id: 9,\n        parentId: 0,\n        bizName: &quot;测试的业务线9&quot;,\n      &#125;,\n    ],\n  &#125;,\n];\n\n\n测试结果console.log(&quot;res - 2&quot;, findTreeNodeByKey(2, data));\nconsole.log(&quot;res - 1326&quot;, findTreeNodeByKey(13, data));\n&#x2F;&#x2F; console.log(&quot;res - 0&quot;, findTreeNodeByKey(0, data));\nconsole.log(&quot;res - 996&quot;, findTreeNodeByKey(996, data));\n\njs 获取某个节点, 对应的路径\n路径 type&#x3D;path\n父节点组 type&#x3D;item\n\n代码\n&#x2F;**\n *\n * @param &#123;数组：树data&#125; tree\n * @param &#123;目标值&#125; targetValue\n * @param &#123;配置信息&#125; options\n * @returns\n *&#x2F;\nfunction findNodePaths(tree, targetValue, options) &#123;\n  const defaultOptions &#x3D; &#123;\n    find_field: &quot;id&quot;, &#x2F;&#x2F; 与 targetValue匹配的字段\n    path_field: &quot;id&quot;, &#x2F;&#x2F; 生成路径的字段\n    separator: &quot;,&quot;, &#x2F;&#x2F; 路径字段分隔符\n    type: &quot;path&quot;, &#x2F;&#x2F; path &#x2F; item\n    children: &quot;children&quot;,\n  &#125;;\n  console.log(&#39;options&#39;,options)\n  options &#x3D; &#123;\n    ...defaultOptions,\n    ...options,\n  &#125;;\n  &#x2F;&#x2F; 首先我们先定义个数组，用来保存路径节点id\n  let nodePathArray &#x3D; [];\n\n  &#x2F;&#x2F; (tree为目标树，targetId为目标节点id)\n  function getNodeRoute(tree, targetValue, options) &#123;\n    for (let index &#x3D; 0; index &lt; tree.length; index++) &#123;\n      if (tree[index][options.children]) &#123;\n        let endRecursiveLoop &#x3D; getNodeRoute(\n          tree[index][options.children],\n          targetValue,\n          options\n        );\n        console.log(&quot;endRecursiveLoop&quot;, endRecursiveLoop);\n        if (endRecursiveLoop) &#123;\n          if (options.type &#x3D;&#x3D;&#x3D; &quot;path&quot;) &#123;\n            nodePathArray.push(tree[index][options.path_field]);\n          &#125; else &#123;\n            nodePathArray.push(tree[index]);\n          &#125;\n          return true;\n        &#125;\n      &#125;\n      if (tree[index][options.find_field] &#x3D;&#x3D;&#x3D; targetValue) &#123;\n        if (options.type &#x3D;&#x3D;&#x3D; &quot;path&quot;) &#123;\n          nodePathArray.push(tree[index][options.path_field]);\n        &#125; else &#123;\n          nodePathArray.push(tree[index]);\n        &#125;\n        return true;\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 转化成数组\n  let _tree &#x3D; [];\n  if (Array.isArray(tree)) &#123;\n    _tree &#x3D; tree;\n  &#125; else &#123;\n    _tree &#x3D; [tree];\n  &#125;\n\n  getNodeRoute(_tree, targetValue, options);\n  console.log(&quot;nodePathArray&quot;, nodePathArray);\n\n  if (options.type &#x3D;&#x3D;&#x3D; &quot;path&quot;) &#123;\n    return nodePathArray.reverse().join(options.separator);\n  &#125; else &#123;\n    return nodePathArray.reverse();\n  &#125;\n&#125;\n\n测试const paths &#x3D; findNodePaths(data, 81); &#x2F;&#x2F;查找id为112的节点路径\nconsole.log(paths);\n\nconst pathItems &#x3D; findNodePaths(treeArray, 81, &#123; type: &quot;item&quot; &#125;); &#x2F;&#x2F;查找id为112的节点路径\nconsole.log(pathItems);\n","slug":"2022-08-23tree","date":"2022-08-23T07:31:09.000Z","categories_index":"tree","tags_index":"tree","author_index":"举手摘月亮"},{"id":"9ca59950df988675bcde5e82f2244716","title":"移动端问题（待补充）","content":"【移动端】移动端点击可点击元素时，出现蓝色默认背景色见\n\nweb页面放在移动端，点击button 标签或者添加了cursor:pointer 样式的标签，会出现 蓝色背景色， 解决方案：\n\n给相应标签 或者直接在body 标签上添加 样式：\n\n&#96;&#96;&#96;css\n-webkit-tap-highlight-color: transparent;\n\n或者\n-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n\n横竖屏检测见\n@media screen and (orientation: portrait) &#123;\n  &#x2F;* 竖屏 *&#x2F;\n&#125;\n@media screen and (orientation: landscape) &#123;\n  &#x2F;* 横屏 *&#x2F;\n&#125;\n\nvar d &#x3D; window.matchMedia(&quot;(orientation: portrait)&quot;);\nonMatchMeidaChange(d);\nd.addListener(onMatchMeidaChange);\nfunction onMatchMeidaChange(d) &#123;\n  if (d.matches) &#123;\n    &#x2F;&#x2F; 竖屏\n  &#125; else &#123;\n    &#x2F;&#x2F;横屏\n  &#125;\n&#125;\n","slug":"2022-08-22mb","date":"2022-08-22T10:55:01.000Z","categories_index":"移动端适配","tags_index":"移动端适配","author_index":"举手摘月亮"},{"id":"aef30b8bcd5723729d853e982cc988b5","title":"antd-mobile 源码","content":"Mask 组件 getContainer见\n&#x2F;&#x2F; renderToContainer\nimport &#123; createPortal &#125; from &quot;react-dom&quot;;\nimport &#123; ReactElement, ReactPortal &#125; from &quot;react&quot;;\nimport &#123; resolveContainer &#125; from &quot;.&#x2F;get-container&quot;;\nimport &#123; canUseDom &#125; from &quot;.&#x2F;can-use-dom&quot;;\n\nexport type GetContainer &#x3D; HTMLElement | (() &#x3D;&gt; HTMLElement) | null;\n&#x2F;&#x2F; 将节点挂在到 getContainer\nexport function renderToContainer(\n  getContainer: GetContainer,\n  node: ReactElement\n) &#123;\n  if (canUseDom &amp;&amp; getContainer) &#123;\n    const container &#x3D; resolveContainer(getContainer);\n    return createPortal(node, container) as ReactPortal; &#x2F;&#x2F; React portal\n  &#125;\n  return node;\n&#125;\n\nexport function resolveContainer(\n  getContainer: HTMLElement | (() &#x3D;&gt; HTMLElement) | undefined | null\n) &#123;\n  const container &#x3D;\n    typeof getContainer &#x3D;&#x3D;&#x3D; &quot;function&quot; ? getContainer() : getContainer;\n  &#x2F;&#x2F; 按照这个默认应该挂在到body上，我在IOS上发现并不是这样，浏览器和安卓没问题\n  &#x2F;&#x2F; nextjs IOS有兼容问题\n  return container || document.body;\n&#125;\n\nrenderToBody见\nimport &#123; ReactElement &#125; from &quot;react&quot;;\nimport &#123; render, unmount as reactUnmount &#125; from &quot;.&#x2F;render&quot;;\n\nexport function renderToBody(element: ReactElement) &#123;\n  const container &#x3D; document.createElement(&quot;div&quot;);\n  document.body.appendChild(container); &#x2F;&#x2F; 挂在到body底部\n  function unmount() &#123;\n    const unmountResult &#x3D; reactUnmount(container);\n    if (unmountResult &amp;&amp; container.parentNode) &#123;\n      container.parentNode.removeChild(container);\n    &#125;\n  &#125;\n  render(element, container);\n  return unmount;\n&#125;\n\n见 Unmount\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Render &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; 有点没看懂\n\n&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Unmount &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nfunction legacyUnmount(container: ContainerType) &#123;\n  return unmountComponentAtNode(container);\n&#125;\n\nasync function concurrentUnmount(container: ContainerType) &#123;\n  &#x2F;&#x2F; Delay to unmount to avoid React 18 sync warning\n  return Promise.resolve().then(() &#x3D;&gt; &#123;\n    container[MARK]?.unmount();\n    delete container[MARK];\n  &#125;);\n&#125;\n\nexport function unmount(container: ContainerType) &#123;\n  if (createRoot as unknown) &#123;\n    return concurrentUnmount(container);\n  &#125;\n\n  return legacyUnmount(container); &#x2F;&#x2F; 服务端渲染处理\n&#125;\n\nrenderToBody 主要用于： 见, unmount 我猜应该是为了关闭时候卸载组件\n客户端渲染判断export const canUseDom &#x3D; !!(\n  typeof window !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;\n  typeof document !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;\n  window.document &amp;&amp;\n  window.document.createElement\n);\n\nsleep见\nexport const sleep &#x3D; (time: number) &#x3D;&gt;\n  new Promise((resolve) &#x3D;&gt; setTimeout(resolve, time))&#96;&#96;;\n\nSpace&#x2F;&#x2F; mergeProps\n\nimport assignWith from &quot;lodash&#x2F;assignWith&quot;;\n\nexport function mergeProps&lt;A, B&gt;(a: A, b: B): B &amp; A;\nexport function mergeProps&lt;A, B, C&gt;(a: A, b: B, c: C): C &amp; B &amp; A;\nexport function mergeProps(...items: any[]) &#123;\n  function customizer(objValue: any, srcValue: any) &#123;\n    return srcValue &#x3D;&#x3D;&#x3D; undefined ? objValue : srcValue;\n  &#125;\n\n  let ret &#x3D; &#123; ...items[0] &#125;;\n  for (let i &#x3D; 1; i &lt; items.length; i++) &#123;\n    ret &#x3D; assignWith(ret, items[i], customizer);\n  &#125;\n  return ret;\n&#125;\n\nimport React, &#123; FC &#125; from &quot;react&quot;;\nimport classNames from &quot;classnames&quot;;\nimport &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;\nimport &#123; mergeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;with-default-props&quot;;\n\nconst classPrefix &#x3D; &#96;adm-space&#96;;\n\nexport type SpaceProps &#x3D; &#123;\n  direction?: &quot;horizontal&quot; | &quot;vertical&quot;;\n  align?: &quot;start&quot; | &quot;end&quot; | &quot;center&quot; | &quot;baseline&quot;;\n  justify?:\n    | &quot;start&quot;\n    | &quot;end&quot;\n    | &quot;center&quot;\n    | &quot;between&quot;\n    | &quot;around&quot;\n    | &quot;evenly&quot;\n    | &quot;stretch&quot;;\n  wrap?: boolean;\n  block?: boolean;\n  onClick?: (event: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) &#x3D;&gt; void;\n  children?: React.ReactNode;\n&#125; &amp; NativeProps&lt;&quot;--gap&quot; | &quot;--gap-vertical&quot; | &quot;--gap-horizontal&quot;&gt;;\n\nconst defaultProps &#x3D; &#123;\n  direction: &quot;horizontal&quot;,\n&#125;;\n\nexport const Space: FC&lt;SpaceProps&gt; &#x3D; (p) &#x3D;&gt; &#123;\n  const props &#x3D; mergeProps(defaultProps, p);\n  const &#123; direction, onClick &#125; &#x3D; props;\n  return withNativeProps(\n    props,\n    &lt;div\n      className&#x3D;&#123;classNames(classPrefix, &#123;\n        [&#96;$&#123;classPrefix&#125;-wrap&#96;]: props.wrap,\n        [&#96;$&#123;classPrefix&#125;-block&#96;]: props.block,\n        [&#96;$&#123;classPrefix&#125;-$&#123;direction&#125;&#96;]: true,\n        [&#96;$&#123;classPrefix&#125;-align-$&#123;props.align&#125;&#96;]: !!props.align,\n        [&#96;$&#123;classPrefix&#125;-justify-$&#123;props.justify&#125;&#96;]: !!props.justify,\n      &#125;)&#125;\n      onClick&#x3D;&#123;onClick&#125;\n    &gt;\n      &#123;React.Children.map(props.children, (child) &#x3D;&gt; &#123;\n        return (\n          child !&#x3D;&#x3D; null &amp;&amp;\n          child !&#x3D;&#x3D; undefined &amp;&amp; (\n            &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-item&#96;&#125;&gt;&#123;child&#125;&lt;&#x2F;div&gt; &#x2F;&#x2F; 这里由下面样式，使用margin-right &#x2F; margin-bottom 实现间隔\n          )\n        );\n      &#125;)&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n见\n&#x2F;&#x2F; space.less\n\n@class-prefix-space: ~&quot;adm-space&quot;;\n\n.@&#123;class-prefix-space&#125;-item &#123;\n  flex: none;\n&#125;\n\n.@&#123;class-prefix-space&#125; &#123;\n  display: inline-flex;\n  --gap: 8px;\n  --gap-vertical: var(--gap);\n  --gap-horizontal: var(--gap);\n  &amp;-vertical &#123;\n    flex-direction: column;\n    &gt; .@&#123;class-prefix-space&#125;-item &#123;\n      margin-bottom: var(--gap-vertical);\n      &amp;:last-child &#123;\n        margin-bottom: 0;\n      &#125;\n    &#125;\n  &#125;\n  &amp;-horizontal &#123;\n    flex-direction: row;\n    &gt; .@&#123;class-prefix-space&#125;-item &#123;\n      margin-right: var(--gap-horizontal);\n      &amp;:last-child &#123;\n        margin-right: 0;\n      &#125;\n    &#125;\n    &amp;.@&#123;class-prefix-space&#125;-wrap &#123;\n      flex-wrap: wrap;\n      margin-bottom: calc(var(--gap-vertical) * -1);\n      &gt; .@&#123;class-prefix-space&#125;-item &#123;\n        padding-bottom: var(--gap-vertical);\n      &#125;\n    &#125;\n  &#125;\n  &amp;.@&#123;class-prefix-space&#125;-block &#123;\n    display: flex;\n  &#125;\n  &amp;-align &#123;\n    &amp;-center &#123;\n      align-items: center;\n    &#125;\n    &amp;-start &#123;\n      align-items: flex-start;\n    &#125;\n    &amp;-end &#123;\n      align-items: flex-end;\n    &#125;\n    &amp;-baseline &#123;\n      align-items: baseline;\n    &#125;\n  &#125;\n  &amp;-justify &#123;\n    &amp;-center &#123;\n      justify-content: center;\n    &#125;\n    &amp;-start &#123;\n      justify-content: flex-start;\n    &#125;\n    &amp;-end &#123;\n      justify-content: flex-end;\n    &#125;\n    &amp;-between &#123;\n      justify-content: space-between;\n    &#125;\n    &amp;-around &#123;\n      justify-content: space-around;\n    &#125;\n    &amp;-evenly &#123;\n      justify-content: space-evenly;\n    &#125;\n    &amp;-stretch &#123;\n      justify-content: stretch;\n    &#125;\n  &#125;\n&#125;\n\nImage\n\nimport &#123; mergeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;with-default-props&quot;;\nimport React, &#123; ReactNode, useState, useRef &#125; from &quot;react&quot;;\nimport &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;\nimport &#123; PictureOutline, PictureWrongOutline &#125; from &quot;antd-mobile-icons&quot;;\nimport &#123; useInViewport &#125; from &quot;ahooks&quot;;\nimport &#123; useInitialized &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;use-initialized&quot;;\nimport &#123; staged &#125; from &quot;staged-components&quot;;\nimport &#123; toCSSLength &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;to-css-length&quot;;\n\nconst classPrefix &#x3D; &#96;adm-image&#96;;\n\nexport type ImageProps &#x3D; &#123;\n  src: string;\n  alt?: string;\n  width?: number | string;\n  height?: number | string;\n  fit?: &quot;contain&quot; | &quot;cover&quot; | &quot;fill&quot; | &quot;none&quot; | &quot;scale-down&quot;;\n  placeholder?: ReactNode;\n  fallback?: ReactNode;\n  lazy?: boolean;\n  onClick?: (event: React.MouseEvent&lt;HTMLImageElement, Event&gt;) &#x3D;&gt; void;\n  onError?: (event: React.SyntheticEvent&lt;HTMLImageElement, Event&gt;) &#x3D;&gt; void;\n&#125; &amp; NativeProps&lt;&quot;--width&quot; | &quot;--height&quot;&gt; &amp;\n  Pick&lt;\n    React.ImgHTMLAttributes&lt;HTMLImageElement&gt;,\n    | &quot;crossOrigin&quot;\n    | &quot;decoding&quot;\n    | &quot;loading&quot;\n    | &quot;referrerPolicy&quot;\n    | &quot;sizes&quot;\n    | &quot;srcSet&quot;\n    | &quot;useMap&quot;\n  &gt;;\n\nconst defaultProps &#x3D; &#123;\n  fit: &quot;fill&quot;,\n  placeholder: (\n    &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-tip&#96;&#125;&gt;\n      &lt;PictureOutline &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  ),\n  fallback: (\n    &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-tip&#96;&#125;&gt;\n      &lt;PictureWrongOutline &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  ),\n  lazy: false,\n&#125;;\n\nexport const Image &#x3D; staged&lt;ImageProps&gt;((p) &#x3D;&gt; &#123;\n  const props &#x3D; mergeProps(defaultProps, p); &#x2F;&#x2F; 属性合并\n  const [loaded, setLoaded] &#x3D; useState(false);\n  const [failed, setFailed] &#x3D; useState(false);\n\n  const ref &#x3D; useRef&lt;HTMLDivElement&gt;(null);\n\n  let src: string | undefined &#x3D; props.src;\n  let srcSet: string | undefined &#x3D; props.srcSet;\n  &#x2F;&#x2F; 非懒加载\n  if (!props.lazy) &#123;\n    return render();\n  &#125;\n  &#x2F;&#x2F; 懒加载\n  return () &#x3D;&gt; &#123;\n    const inViewport &#x3D; useInViewport(ref); &#x2F;&#x2F; 当出现在视口中时，将\n\n    const initialized &#x3D; useInitialized(inViewport); &#x2F;&#x2F; inViewport为true时候进行初始化\n    &#x2F;&#x2F; useInitialized 源码\n    &#x2F;&#x2F; import &#123; useRef &#125; from &#39;react&#39;\n\n    &#x2F;&#x2F; export function useInitialized(check?: boolean) &#123; &#x2F;&#x2F; check为true的时候执行初始化\n    &#x2F;&#x2F;   const initializedRef &#x3D; useRef(check)\n    &#x2F;&#x2F;   if (check) &#123;\n    &#x2F;&#x2F;     initializedRef.current &#x3D; true\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F;   return !!initializedRef.current\n    &#x2F;&#x2F; &#125;\n\n    &#x2F;&#x2F; 初始化时候，设置真实src、srcSet\n    src &#x3D; initialized ? props.src : undefined;\n    srcSet &#x3D; initialized ? props.srcSet : undefined;\n    return render();\n  &#125;;\n\n  function renderInner() &#123;\n    if (failed) &#123;\n      return props.fallback;\n    &#125;\n    return (\n      &lt;&gt;\n        &#x2F;&#x2F; 未加载完成的情况，展示placeholder\n        &#123;!loaded &amp;&amp; props.placeholder&#125;\n        &lt;img\n          className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-img&#96;&#125;\n          src&#x3D;&#123;src&#125;\n          alt&#x3D;&#123;props.alt&#125;\n          onClick&#x3D;&#123;props.onClick&#125;\n          onLoad&#x3D;&#123;() &#x3D;&gt; &#123;\n            setLoaded(true);\n          &#125;&#125;\n          onError&#x3D;&#123;(e) &#x3D;&gt; &#123;\n            setFailed(true);\n            props.onError?.(e);\n          &#125;&#125;\n          style&#x3D;&#123;&#123;\n            objectFit: props.fit,\n            display: loaded ? &quot;block&quot; : &quot;none&quot;,\n          &#125;&#125;\n          crossOrigin&#x3D;&#123;props.crossOrigin&#125; &#x2F;&#x2F; 跨域\n          decoding&#x3D;&#123;props.decoding&#125;\n          loading&#x3D;&#123;props.loading&#125;\n          referrerPolicy&#x3D;&#123;props.referrerPolicy&#125;\n          sizes&#x3D;&#123;props.sizes&#125;\n          srcSet&#x3D;&#123;srcSet&#125;\n          useMap&#x3D;&#123;props.useMap&#125; &#x2F;&#x2F; ????\n        &#x2F;&gt;\n      &lt;&#x2F;&gt;\n    );\n  &#125;\n\n  function render() &#123;\n    const style: ImageProps[&quot;style&quot;] &#x3D; &#123;&#125;;\n    if (props.width) &#123;\n      style[&quot;--width&quot;] &#x3D; toCSSLength(props.width);\n    &#125;\n    if (props.height) &#123;\n      style[&quot;--height&quot;] &#x3D; toCSSLength(props.height);\n    &#125;\n    return withNativeProps(\n      &#x2F;&#x2F; 组件增加属性\n      props,\n      &lt;div ref&#x3D;&#123;ref&#125; className&#x3D;&#123;classPrefix&#125; style&#x3D;&#123;style&#125;&gt;\n        &#123;renderInner()&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;);\n\n见 withNativeProps\n&#x2F;&#x2F; toCSSLength, 只是为了增加 px 单位\n\nexport function toCSSLength(val: string | number) &#123;\n  return typeof val &#x3D;&#x3D;&#x3D; &quot;number&quot; ? &#96;$&#123;val&#125;px&#96; : val;\n&#125;\n\nFloating-panel\n\n源码\nimport React, &#123;\n  forwardRef,\n  ReactNode,\n  useImperativeHandle,\n  useRef,\n  useState,\n&#125; from &quot;react&quot;;\nimport &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;\nimport &#123; useDrag &#125; from &quot;@use-gesture&#x2F;react&quot;;\n&#x2F;&#x2F;@link: https:&#x2F;&#x2F;github.com&#x2F;pmndrs&#x2F;react-spring\nimport &#123; useSpring, animated &#125; from &quot;@react-spring&#x2F;web&quot;;\nimport &#123; supportsPassive &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;supports-passive&quot;;\nimport &#123; nearest &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;nearest&quot;;\n\nexport type FloatingPanelProps &#x3D; &#123;\n  anchors: number[];\n  children: ReactNode;\n&#125; &amp; NativeProps&lt;&quot;--border-radius&quot; | &quot;--z-index&quot;&gt;;\n\nexport type FloatingPanelRef &#x3D; &#123;\n  setHeight: (\n    height: number,\n    options?: &#123;\n      immediate?: boolean;\n    &#125;\n  ) &#x3D;&gt; void;\n&#125;;\n\nexport const FloatingPanel &#x3D; forwardRef&lt;FloatingPanelRef, FloatingPanelProps&gt;(\n  (props, ref) &#x3D;&gt; &#123;\n    const &#123; anchors &#125; &#x3D; props;\n    &#x2F;&#x2F;@link: https:&#x2F;&#x2F;mobile.ant.design&#x2F;zh&#x2F;components&#x2F;floating-panel#floatingpanel\n    &#x2F;*这里取最后一个为最大高度，[300,50,200],取的是200,😓，文档没说啊 *&#x2F;\n    const maxHeight &#x3D; anchors[anchors.length - 1] ?? window.innerHeight;\n\n    const possibles &#x3D; anchors.map((x) &#x3D;&gt; -x); &#x2F;&#x2F; 顶部是负值\n\n    const elementRef &#x3D; useRef&lt;HTMLDivElement&gt;(null);\n    const headerRef &#x3D; useRef&lt;HTMLDivElement&gt;(null);\n    const contentRef &#x3D; useRef&lt;HTMLDivElement&gt;(null);\n    const [pulling, setPulling] &#x3D; useState(false);\n    const pullingRef &#x3D; useRef(false);\n\n    const bounds &#x3D; &#123;\n      top: possibles[possibles.length - 1], &#x2F;&#x2F; 顶部是负值\n      bottom: possibles[0], &#x2F;&#x2F; 底部取0， 0位不一定是最小的😓\n    &#125;;\n\n    const [&#123; y &#125;, api] &#x3D; useSpring(() &#x3D;&gt; (&#123;\n      &#x2F;&#x2F; useSpring\n      y: bounds.bottom,\n      config: &#123; tension: 300 &#125;,\n    &#125;));\n\n    useDrag(\n      (state) &#x3D;&gt; &#123;\n        const [, offsetY] &#x3D; state.offset;\n        if (state.first) &#123;\n          const target &#x3D; state.event.target as Element;\n          const header &#x3D; headerRef.current;\n          if (header &#x3D;&#x3D;&#x3D; target || header?.contains(target)) &#123;\n            pullingRef.current &#x3D; true;\n          &#125; else &#123;\n            const reachedTop &#x3D; y.goal &lt;&#x3D; bounds.top;\n            const content &#x3D; contentRef.current;\n            if (!content) return;\n            if (reachedTop) &#123;\n              if (content.scrollTop &lt;&#x3D; 0 &amp;&amp; state.direction[1] &gt; 0) &#123;\n                pullingRef.current &#x3D; true;\n              &#125;\n            &#125; else &#123;\n              pullingRef.current &#x3D; true;\n            &#125;\n          &#125;\n        &#125;\n        setPulling(pullingRef.current);\n        if (!pullingRef.current) return;\n        const &#123; event &#125; &#x3D; state;\n        if (event.cancelable) &#123;\n          event.preventDefault();\n        &#125;\n        event.stopPropagation();\n        let nextY &#x3D; offsetY;\n        if (state.last) &#123;\n          pullingRef.current &#x3D; false;\n          setPulling(false);\n          nextY &#x3D; nearest(possibles, offsetY);\n        &#125;\n        api.start(&#123;\n          y: nextY,\n        &#125;);\n      &#125;,\n      &#123;\n        axis: &quot;y&quot;,\n        bounds,\n        rubberband: true,\n        from: () &#x3D;&gt; [0, y.get()],\n        pointer: &#123; touch: true &#125;,\n        target: elementRef,\n        eventOptions: supportsPassive ? &#123; passive: false &#125; : false,\n      &#125;\n    );\n\n    useImperativeHandle(\n      ref,\n      () &#x3D;&gt; (&#123;\n        setHeight: (\n          height: number,\n          options?: &#123;\n            immediate?: boolean;\n          &#125;\n        ) &#x3D;&gt; &#123;\n          api.start(&#123;\n            y: -height,\n            immediate: options?.immediate,\n          &#125;);\n        &#125;,\n      &#125;),\n      [api]\n    );\n\n    return withNativeProps(\n      props,\n      &lt;animated.div\n        ref&#x3D;&#123;elementRef&#125;\n        className&#x3D;&quot;adm-floating-panel&quot;\n        style&#x3D;&#123;&#123;\n          height: maxHeight,\n          y,\n        &#125;&#125;\n      &gt;\n        &#x2F;&#x2F; 遮照， 怎么没看到效果呢？？？？\n        &lt;div\n          className&#x3D;&quot;adm-floating-panel-mask&quot;\n          style&#x3D;&#123;&#123;\n            display: pulling ? &quot;block&quot; : &quot;none&quot;,\n          &#125;&#125;\n        &#x2F;&gt;\n        &#x2F;&#x2F; bar内容\n        &lt;div className&#x3D;&quot;adm-floating-panel-header&quot; ref&#x3D;&#123;headerRef&#125;&gt;\n          &lt;div className&#x3D;&quot;adm-floating-panel-bar&quot; &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div className&#x3D;&quot;adm-floating-panel-content&quot; ref&#x3D;&#123;contentRef&#125;&gt;\n          &#123;props.children&#125;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;animated.div&gt;\n    );\n  &#125;\n);\n\nuseImperativeHandle\n\n\n\n\n\n\n\n\n\n正常情况下 ref 是不能挂在到函数组件上的，因为函数组件没有实例，但是 useImperativeHandle 为我们提供了一个类似实例的东西。它帮助我们通过 useImperativeHandle 的第 2 个参数，所返回的对象的内容挂载到 父组件的 ref.current 上。\nforwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。\n作者：机智的狮老师链接：https://www.jianshu.com/p/bf9f66ac3f9c来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nimport React, &#123;\n  forwardRef,\n  useImperativeHandle,\n  useEffect,\n  useRef,\n&#125; from &quot;react&quot;;\n\nconst TestRef &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  useImperativeHandle(ref, () &#x3D;&gt; (&#123;\n    open() &#123;\n      console.log(&quot;open&quot;);\n    &#125;,\n  &#125;));\n&#125;);\n\nfunction App() &#123;\n  const ref &#x3D; useRef();\n  useEffect(() &#x3D;&gt; &#123;\n    ref.current.open();\n  &#125;, []);\n\n  return (\n    &lt;&gt;\n      &lt;div&gt;石小阳&lt;&#x2F;div&gt;\n      &lt;TestRef ref&#x3D;&#123;ref&#125;&gt;&lt;&#x2F;TestRef&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\nexport default App;\n\n另一种实现：可以使用 hooks 把子组件数据绑定到一个 ref 上（这个 ref 是父组件传入的）如下：\n子组件\n\n\n父组件\n\n\n\n\n可见 useImperativeHandle方式更优雅\ntabs 与 内容联动\n\n见\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport &#123; Tabs &#125; from &quot;antd-mobile&quot;;\nimport &#123; DemoBlock, lorem &#125; from &quot;demos&quot;;\nimport styles from &quot;.&#x2F;demo4.less&quot;;\nimport &#123; useThrottleFn &#125; from &quot;ahooks&quot;;\n\nconst tabItems &#x3D; [\n  &#123; key: &quot;1&quot;, title: &quot;第一项&quot;, text: lorem.generateParagraphs(8) &#125;,\n  &#123; key: &quot;2&quot;, title: &quot;第二项&quot;, text: lorem.generateParagraphs(8) &#125;,\n  &#123; key: &quot;3&quot;, title: &quot;第三项&quot;, text: lorem.generateParagraphs(8) &#125;,\n  &#123; key: &quot;4&quot;, title: &quot;第四项&quot;, text: lorem.generateParagraphs(8) &#125;,\n];\n\nconst tabHeight &#x3D; 42;\n\nexport default () &#x3D;&gt; &#123;\n  const [activeKey, setActiveKey] &#x3D; useState(&quot;1&quot;);\n\n  const &#123; run: handleScroll &#125; &#x3D; useThrottleFn(\n    () &#x3D;&gt; &#123;\n      let currentKey &#x3D; tabItems[0].key;\n      for (const item of tabItems) &#123;\n        const element &#x3D; document.getElementById(&#96;anchor-$&#123;item.key&#125;&#96;);\n        if (!element) continue;\n        const rect &#x3D; element.getBoundingClientRect();\n        if (rect.top &lt;&#x3D; tabHeight) &#123;\n          &#x2F;&#x2F; 通过滚动设置key\n          currentKey &#x3D; item.key;\n        &#125; else &#123;\n          break;\n        &#125;\n      &#125;\n      setActiveKey(currentKey);\n    &#125;,\n    &#123;\n      leading: true,\n      trailing: true,\n      wait: 100,\n    &#125;\n  );\n\n  useEffect(() &#x3D;&gt; &#123;\n    window.addEventListener(&quot;scroll&quot;, handleScroll);\n    return () &#x3D;&gt; &#123;\n      window.removeEventListener(&quot;scroll&quot;, handleScroll);\n    &#125;;\n  &#125;, []);\n\n  return (\n    &lt;&gt;\n      &lt;DemoBlock title&#x3D;&quot;作为页面滚动的导航&quot; padding&#x3D;&quot;0&quot;&gt;\n        &lt;div className&#x3D;&#123;styles.tabsContainer&#125;&gt;\n          &lt;Tabs\n            activeKey&#x3D;&#123;activeKey&#125; &#x2F;&#x2F; 滚动时候设置 activeKey\n            onChange&#x3D;&#123;(key) &#x3D;&gt; &#123;\n              document.getElementById(&#96;anchor-$&#123;key&#125;&#96;)?.scrollIntoView(); &#x2F;&#x2F; 滚动到视口\n              window.scrollTo(&#123;\n                &#x2F;&#x2F; 点击时候滚动的位置\n                top: window.scrollY - tabHeight,\n              &#125;);\n            &#125;&#125;\n          &gt;\n            &#123;tabItems.map((item) &#x3D;&gt; (\n              &lt;Tabs.Tab title&#x3D;&#123;item.title&#125; key&#x3D;&#123;item.key&#125; &#x2F;&gt;\n            ))&#125;\n          &lt;&#x2F;Tabs&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div className&#x3D;&#123;styles.content&#125;&gt;\n          &#123;tabItems.map((item) &#x3D;&gt; (\n            &lt;div key&#x3D;&#123;item.key&#125;&gt;\n              &#x2F;&#x2F; 这里设置id\n              &lt;h2 id&#x3D;&#123;&#96;anchor-$&#123;item.key&#125;&#96;&#125;&gt;&#123;item.title&#125;&lt;&#x2F;h2&gt;\n              &#123;item.text&#125;\n            &lt;&#x2F;div&gt;\n          ))&#125;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;DemoBlock&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;\n\n见\nimport &quot;.&#x2F;tabs.less&quot;;\nimport &#123; TabPane, Tabs &#125; from &quot;.&#x2F;tabs&quot;;\nimport &#123; attachPropertiesToComponent &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;attach-properties-to-component&quot;;\n\nexport type &#123; TabsProps, TabPaneProps &#125; from &quot;.&#x2F;tabs&quot;;\n\nexport default attachPropertiesToComponent(Tabs, &#123;\n  &#x2F;&#x2F; 之后可以使用 Tabs.TabPane提示\n  TabPane,\n&#125;);\n\nbadge 看个简单的放松下import &quot;.&#x2F;badge.less&quot;;\nimport &#123; Badge, dot &#125; from &quot;.&#x2F;badge&quot;;\nimport &#123; attachPropertiesToComponent &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;attach-properties-to-component&quot;;\nexport type &#123; BadgeProps &#125; from &quot;.&#x2F;badge&quot;;\n\nexport default attachPropertiesToComponent(Badge, &#123;\n  dot, &#x2F;&#x2F; Badge 增加 dot属性\n&#125;);\n\nimport classNames from &quot;classnames&quot;;\nimport React from &quot;react&quot;;\nimport &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;\nimport &#123; withDefaultProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;with-default-props&quot;;\n\nconst classPrefix &#x3D; &#96;adm-badge&#96;;\n\nexport const dot &#x3D; Symbol(); &#x2F;&#x2F; ????\n\nexport type BadgeProps &#x3D; &#123;\n  content?: React.ReactNode | typeof dot;\n  color?: string;\n&#125; &amp; NativeProps&lt;&quot;--right&quot; | &quot;--top&quot;&gt;;\n\nexport const Badge &#x3D; withDefaultProps(&#123;\n  color: &quot;#FF411C&quot;,\n&#125;)&lt;BadgeProps&gt;((props) &#x3D;&gt; &#123;\n  const &#123; content, color, children &#125; &#x3D; props;\n\n  const isDot &#x3D; content &#x3D;&#x3D;&#x3D; dot; &#x2F;&#x2F; 判断是不是 dot\n\n  const badgeCls &#x3D; classNames(classPrefix, &#123;\n    [&#96;$&#123;classPrefix&#125;-fixed&#96;]: !!children,\n    [&#96;$&#123;classPrefix&#125;-dot&#96;]: isDot,\n  &#125;);\n  &#x2F;&#x2F; 有内容不是dot 渲染内容，是dot 不渲染内容\n  const element &#x3D; content\n    ? withNativeProps(\n        props,\n        &lt;div &#x2F;&#x2F; dot 是元素，不是伪元素\n          className&#x3D;&#123;badgeCls&#125;\n          style&#x3D;&#123;&#123;\n            backgroundColor: color,\n          &#125;&#125;\n        &gt;\n          &#123;!isDot &amp;&amp; content&#125;\n        &lt;&#x2F;div&gt;\n      )\n    : null;\n  &#x2F;&#x2F; 有子节点， 无子节点，直接渲染\n  return children ? (\n    &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-wrap&#96;&#125;&gt;\n      &#123;children&#125;\n      &#123;element&#125;\n    &lt;&#x2F;div&gt;\n  ) : (\n    element\n  );\n&#125;);\n\n@class-prefix-badge: ~&quot;adm-badge&quot;;\n\n.@&#123;class-prefix-badge&#125;-wrap &#123;\n  display: inline-block;\n  position: relative;\n&#125;\n\n.@&#123;class-prefix-badge&#125; &#123;\n  display: inline-block;\n  color: #fff;\n  font-weight: normal;\n  text-align: center;\n  vertical-align: middle;\n  box-sizing: border-box;\n  min-width: 16px;\n  border-radius: 100px;\n  padding: 0 4px;\n  font-size: 9px;\n  line-height: 1.2;\n  white-space: nowrap;\n  --right: 0;\n  --top: 0;\n\n  &amp;-fixed &#123;\n    position: absolute;\n    right: var(--right);\n    top: var(--top);\n    transform: translate(50%, -50%);\n  &#125;\n\n  &amp;-dot &#123;\n    &#x2F;&#x2F;  元素dot\n    min-width: 10px;\n    width: 10px;\n    height: 10px;\n    border-radius: 5px;\n  &#125;\n&#125;\n\n暂时放下 需删除 -->\n","slug":"2022-08-20antd","date":"2022-08-20T14:28:11.000Z","categories_index":"源码","tags_index":"源码","author_index":"举手摘月亮"},{"id":"e0a73b928a5d52222483c493ebd5de2e","title":"TypeScript-实操","content":"对于不能穷举的处理interface Option &#123;\n  label: string;\n  value: any;\n&#125;\n\ninterface EnumOption &#123;\n  &#x2F;** 价值观成绩 *&#x2F;\n  valuesGrade: Option[];\n  &#x2F;** 绩效成绩 *&#x2F;\n  perfLevel: Option[];\n  &#x2F;** 户口状态 *&#x2F;\n  censusRegister: Option[];\n  [key: string]: Option[]; &#x2F;&#x2F; 这里\n&#125;\n\ntype OfferOption &#x3D; EnumOption;\n\n这个还没想好\n\ninterface IMBOrgStaffContext &#123;\n  orgs: Org[];\n  setOrgs?: (orgs: Org[]) &#x3D;&gt; void;\n  staffs: Staff[];\n  setStaffs?: (staffs: Staff[]) &#x3D;&gt; void;\n  values: OrgStaff;\n  setValues?: (staffs: OrgStaff) &#x3D;&gt; void;\n&#125;\n\n\n\nEnum 的注释/** 开始处理 */ 不要写成 //开始处理\nexport enum EOperator &#123;\n  &#x2F;** 开始处理 *&#x2F;\n  processing &#x3D; 2,\n  &#x2F;** 已解决 *&#x2F;\n  solved &#x3D; 5,\n  &#x2F;** 完结 *&#x2F;\n  finish &#x3D; 6,\n  &#x2F;** 取消 *&#x2F;\n  cancel &#x3D; 7,\n  &#x2F;** 经办人变更 *&#x2F;\n  solver &#x3D; 1008,\n  &#x2F;** 协作人添加 *&#x2F;\n  add_helper &#x3D; 1009,\n  &#x2F;** 协作人移除 *&#x2F;\n  &#x2F;&#x2F;  无\n  &#x2F;** 退出协作 *&#x2F;\n  exit_helper &#x3D; 1011,\n  &#x2F;** 催办 *&#x2F;\n  remind &#x3D; 1012,\n  &#x2F;** 提醒确认 *&#x2F;\n  notify_creator &#x3D; 1013,\n  &#x2F;** 指派经办人 *&#x2F;\n  assign_operator &#x3D; 1014,\n  &#x2F;** 添加关注人 *&#x2F;\n  add_follower &#x3D; 1015,\n  &#x2F;** 关注问题 *&#x2F;\n  to_follow &#x3D; 1016,\n&#125;\n\n\n","slug":"2022-08-20ts","date":"2022-08-20T03:07:56.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"8fccc11bb8bff3e49fb035b6c0baca2d","title":"包管理工具-pnpm","content":"pnpm TODO:del-->\n\n官网\n\n\npnpm 安装路径👑 ~ $ which pnpm\n&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pnpm\n👑 ~ $ which pn\npn: aliased to pnpm\n\n使用较短的别名pnpm 可能很难输入，因此您可以使用较短的别名，例如 pn。 只需将下面这行放入 .bashrc、 .zshrc 或 config.fish 中：\nalias pn&#x3D;pnpm\n\n我的.zshrc路径：/Users/haotian/.zshrc\n同理，我们可以将其他命令也简化\n\nalias yn&#x3D;yarn\n\n♠ &#x2F;Users&#x2F;chenhailong $ which pn\npn: aliased to pnpm\n♠ &#x2F;Users&#x2F;chenhailong $ which yn\nyn: aliased to yarn\n♠ &#x2F;Users&#x2F;chenhailong $\n\n命令行有关更多信息，请参阅各个 CLI 命令的文档。 以下是简便的 npm 命令等效列表，可帮助您入门：\nnpm 命令 pnpm 等效\nnpm install pnpm install\nnpm i &lt;pkg&gt; [pnpm add &lt;pkg&gt;]\nnpm run &lt;cmd&gt; [pnpm &lt;cmd&gt;]\n\n升级","slug":"2022-08-19pnpm","date":"2022-08-19T02:38:25.000Z","categories_index":"包管理工具","tags_index":"包管理工具","author_index":"举手摘月亮"},{"id":"a1c8da0653d05a3bca517b77d6bf6809","title":"前端基础-es6+","content":"old1.5 万字概括 ES6 全部特性(已更新 ES2020)\nES6+最新到 ES 几ES6（ECMAScript 2015）是 JavaScript 的第六个主要版本，而 ES2021（ECMAScript 2021）是 JavaScript 的最新版本。因此，ES6+是指从 ES6 版本开始的所有后续版本，包括 ES7（ECMAScript 2016）、ES8（ECMAScript 2017）、ES9（ECMAScript 2018）、ES10（ECMAScript 2019）、ES11（ECMAScript 2020）、ES12（ECMAScript 2021）等。\nES12ES12（ECMAScript 2021）是 JavaScript 的最新版本，它于 2021 年 6 月正式发布。它引入了一些新的语言特性和功能，包括：\n\nString.prototype.replaceAll()：可以用于替换字符串中所有匹配项的方法。\n\nPromise.any()：返回一组 Promise 对象中最快完成的那个 Promise 的结果。\n\nLogical Assignment Operators：包括 &amp;&amp;=, ||=, 和 ??=，用于对变量进行逻辑运算和赋值。\n\nWeakRefs：通过弱引用来跟踪对象，以避免内存泄漏。\n\nNumeric Separators：可以在数字中使用下划线 _ 分隔符，以增加数字的可读性。\n\nFinalizationRegistry：允许在对象被垃圾回收前执行清理操作。\n\n\n还有其他一些小的改进和新的语言特性，这些改进和特性都旨在提高 JavaScript 的开发效率和可靠性。\nNumeric Separators(很久很久以前不能用吗？我记得前些年就可以了难道是 TS？)Numeric Separators 是 ES2021（ECMAScript 2021）中的一项新特性，它允许在数字常量中使用下划线 _ 分隔符，以增加数字的可读性。\n在以前的 JavaScript 版本中，对于较长的数字常量，可能很难确定数字的确切值，这可能导致代码的阅读和理解变得困难。例如，一个十六进制数字常量可能长成这样：\nconst num &#x3D; 0xaabbccddeeff0011;\n\n这个数字常量虽然并不长，但它可能需要一些时间才能弄清它的确切值是多少。通过使用 Numeric Separators，我们可以将数字分成更易于阅读的部分，例如：\nconst num &#x3D; 0xaa_bb_cc_dd_ee_ff_00_11;\n\n这个数字常量使用了下划线作为分隔符，每四个十六进制数字就会被分成一组。这使得数字常量更易于阅读和理解。\nNumeric Separators 不仅可以用于十六进制数字常量，还可以用于二进制、八进制和十进制数字常量。例如：\nconst binNum &#x3D; 0b1010_1100_0011_0000; &#x2F;&#x2F; 43920\nconst octNum &#x3D; 0o12_3456; &#x2F;&#x2F; 5342\nconst decNum &#x3D; 1_000_000; &#x2F;&#x2F; 1000000\n\n需要注意的是，Numeric Separators 只是在代码中增加了可读性，实际上它们在数字常量的值方面没有任何影响。\nFinalizationRegistryFinalizationRegistry 是 ES2021（ECMAScript 2021）中引入的一项新特性，它允许在对象被垃圾回收前执行清理操作。\n在 JavaScript 中，垃圾回收器负责自动回收不再被引用的对象，以释放内存。在某些情况下，当对象被垃圾回收时，可能需要执行一些清理操作，例如关闭文件或释放其他资源。在 ES2021 之前，这通常需要手动实现一个类似于“终结器”（finalizer）的机制，以在对象被垃圾回收时执行清理操作。\nFinalizationRegistry 通过提供一个回调函数，在对象被垃圾回收时自动执行清理操作，来简化这个过程。它的基本用法如下：\n&#x2F;&#x2F; 创建一个FinalizationRegistry实例\nconst registry &#x3D; new FinalizationRegistry((key) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 在对象被垃圾回收时执行清理操作\n  console.log(&#96;Object with key $&#123;key&#125; is garbage collected.&#96;);\n&#125;);\n\n&#x2F;&#x2F; 创建一个需要进行清理操作的对象\nconst obj &#x3D; &#123; name: &#39;John&#39; &#125;;\nconst key &#x3D; &#123; id: 1 &#125;;\n\n&#x2F;&#x2F; 注册对象和其对应的key\nregistry.register(obj, key);\n\n&#x2F;&#x2F; 取消对象的注册\n&#x2F;&#x2F; registry.unregister(obj);\n\n&#x2F;&#x2F; 对象不再被引用，将会被垃圾回收\nobj &#x3D; null;\n\n在这个例子中，我们创建了一个 FinalizationRegistry 实例，并使用 register()方法将对象和其对应的 key 注册到 registry 中。当对象不再被引用并被垃圾回收时，FinalizationRegistry 会自动调用回调函数，并将对象的 key 作为参数传递给它。\n需要注意的是，FinalizationRegistry 只能用于跟踪弱引用（weak references）对象。弱引用对象是指不会阻止垃圾回收器回收对象的引用，因此可以使用 FinalizationRegistry 来跟踪这些对象，并在它们被垃圾回收时执行清理操作。\nES11ES11，全称 ECMAScript 2020，是 JavaScript 的一个重要版本，于 2020 年正式发布。它引入了一些新的语言特性和 API，包括：\n\n可选链操作符（Optional Chaining Operator）这个特性允许开发者使用 ?. 操作符来简化访问嵌套对象的代码，避免了深层次的嵌套和 null 异常的问题。\n\n空值合并操作符（Nullish Coalescing Operator）这个特性允许开发者使用 ?? 操作符来判断一个值是否为 null 或 undefined，如果是，则使用默认值。\n\n动态导入（Dynamic Import）这个特性允许开发者在运行时异步加载模块，而不是在编译时加载。这使得 JavaScript 应用程序可以更加动态和灵活。\n\nBigInt这个特性允许开发者使用大于 2^53-1 的整数，这对于处理需要高精度数学的场景非常有用。\n\nglobalThis这个特性提供了一个标准的方式来访问全局对象，无论在哪个环境下运行。\n\nPromise.allSettled()这个特性返回一个 Promise，当所有 Promise 都已解决或拒绝时，它将解决并返回一个包含所有 Promise 结果的数组，无论它们是否被解决或拒绝。\n\nString.prototype.matchAll()这个特性允许开发者在一个字符串中查找所有匹配的子字符串，并返回一个迭代器。\n\n\n总之，ES11 引入的这些新特性和 API，可以让开发者更加方便地编写高效的 JavaScript 代码，提高开发效率和应用程序的性能。\nES11，全称 ECMAScript 2020，是 JavaScript 的第十一个正式版本，于 2020 年 6 月发布。ES11 引入了一些新特性和改进，其中一些重要的特性包括：\n可选链操作符（Optional chaining）可选链操作符（?.）可以简化访问嵌套对象或数组的代码，当访问的属性或方法不存在时，返回 undefined 而不是抛出错误。\n例如：\nconst person &#x3D; &#123;\n  name: &#39;John&#39;,\n  address: &#123;\n    city: &#39;New York&#39;,\n  &#125;,\n&#125;;\n\nconsole.log(person.address?.city); &#x2F;&#x2F; 输出 &#39;New York&#39;\nconsole.log(person.address?.zipCode); &#x2F;&#x2F; 输出 undefined\n\n空值合并操作符（Nullish coalescing）空值合并操作符（??）用于处理 undefined 或 null 值的情况，它只在左侧操作数的值为 undefined 或 null 时返回右侧操作数的值，否则返回左侧操作数的值。\n例如：\nconst value1 &#x3D; undefined;\nconst value2 &#x3D; null;\nconst value3 &#x3D; 0;\n\nconsole.log(value1 ?? &#39;default value&#39;); &#x2F;&#x2F; 输出 &#39;default value&#39;\nconsole.log(value2 ?? &#39;default value&#39;); &#x2F;&#x2F; 输出 &#39;default value&#39;\nconsole.log(value3 ?? &#39;default value&#39;); &#x2F;&#x2F; 输出 0\n\nPromise.allSettled()Promise.allSettled() 方法返回一个 Promise，该 Promise 在所有 Promise 对象都已经 fulfilled 或 rejected 后解决。与 Promise.all() 不同的是，即使其中某个 Promise 被 rejected，Promise.allSettled() 仍然会等待其他 Promise 的完成，并且会返回所有 Promise 的状态和值。\n例如：\nconst promises &#x3D; [Promise.resolve(&#39;value1&#39;), Promise.reject(new Error(&#39;error message&#39;)), Promise.resolve(&#39;value3&#39;)];\n\nPromise.allSettled(promises).then((results) &#x3D;&gt; console.log(results));\n\n输出结果为：\n[\n  &#123; status: &#39;fulfilled&#39;, value: &#39;value1&#39; &#125;,\n  &#123; status: &#39;rejected&#39;, reason: Error: error message at ... &#125;,\n  &#123; status: &#39;fulfilled&#39;, value: &#39;value3&#39; &#125;\n]\n\n除了以上三个特性，ES11 还引入了 String.prototype.matchAll() 方法、globalThis 对象、BigInt 类型和 import() 函数等新特性和改进。\n动态导入（Dynamic Import）动态导入（Dynamic Import）是 ECMAScript 2020（ES2020 &#x2F; ES11）中引入的一个新特性，它允许在运行时异步地加载 ES 模块。与静态导入不同，动态导入并不在模块内部执行，而是在代码运行时才执行。\n动态导入的语法如下：\nimport(moduleSpecifier)\n  .then((module) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 使用加载的模块\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理错误\n  &#125;);\n\n其中 moduleSpecifier 参数是一个字符串，用于指定需要加载的模块。它可以是相对路径或绝对路径，也可以是一个 URL。返回的是一个 Promise，用于异步加载指定的模块。当加载成功时，then 方法将传递一个包含导出对象的模块对象，否则 catch 方法将会捕捉错误并进行处理。\n动态导入可以用于按需加载模块，避免一次性加载过多的代码，提高应用程序的性能。例如，在使用 Webpack 打包应用程序时，可以将代码分割成多个小的代码块，然后在需要时动态地加载它们，而不是在一开始就加载所有的代码。\n需要注意的是，动态导入是 ECMAScript 2020 中引入的新特性，因此需要使用支持该特性的 JavaScript 引擎才能运行。\nES5 实现动态导入功能ES5 并没有官方的动态导入功能，但是可以使用一些工具或者编写一些代码来模拟实现类似的功能。下面是一个简单的实现示例：\nfunction importModule(modulePath, callback) &#123;\n  var script &#x3D; document.createElement(&#39;script&#39;);\n  script.onload &#x3D; function () &#123;\n    callback(window[modulePath]);\n  &#125;;\n  script.src &#x3D; modulePath + &#39;.js&#39;;\n  document.head.appendChild(script);\n&#125;\n\n&#x2F;&#x2F; 使用示例\nimportModule(&#39;module1&#39;, function (module1) &#123;\n  &#x2F;&#x2F; 使用模块1\n&#125;);\n\nimportModule(&#39;module2&#39;, function (module2) &#123;\n  &#x2F;&#x2F; 使用模块2\n&#125;);\n\n在上面的示例中，importModule 函数接受两个参数，一个是模块路径 modulePath，另一个是加载完成后的回调函数 callback。当函数被调用时，它会动态地创建一个 &lt;script&gt; 标签，然后将其添加到 &lt;head&gt; 元素中。当该脚本加载完成时，回调函数将被调用，并将加载的模块作为参数传递给它。\n需要注意的是，这种方式存在一些限制。例如，加载的脚本必须是同源的，否则会因为跨域问题而导致加载失败。此外，如果需要加载的模块较多，就会产生大量的 HTTP 请求，影响应用程序的性能。因此，如果需要在 ES5 中实现类似动态导入的功能，建议使用一些工具或框架，例如 RequireJS 或者 SystemJS。\nES11 动态导入（Dynamic Import）可以加载非同源？ES11 动态导入（Dynamic Import）可以加载非同源的模块，但这涉及到跨域资源共享（CORS）策略的限制。\n根据 CORS 策略，Web 浏览器只允许从同一源加载的资源进行跨域访问，也就是说，如果在一个网站上使用动态导入来加载另一个域的模块，那么这个请求将会被浏览器拦截。\n为了解决这个问题，开发者可以使用一些工具或技术来绕过 CORS 策略。例如，在服务端设置 CORS 头部，将需要访问的域名添加到许可的列表中，或者使用代理服务器进行转发。此外，一些第三方库，例如 SystemJS 和 Webpack，也提供了一些解决跨域访问的方法，可以在前端代码中使用动态导入加载非同源的模块。需要注意的是，这些方法都需要开发者根据自己的需求进行选择和配置。\nES11 动态导入（Dynamic Import） 自动添加？ES11 动态导入（Dynamic Import）会自动在 HTML 页面中添加对应的 &lt;script&gt; 标签，用于加载指定的模块。\n在使用动态导入时，可以直接在 JavaScript 代码中指定需要加载的模块路径，例如：\nimport(&#39;.&#x2F;module.js&#39;)\n  .then((module) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 使用加载的模块\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理加载失败的情况\n  &#125;);\n\n在上面的代码中，import 函数会根据指定的模块路径动态加载对应的 JavaScript 模块。当模块加载完成后，then 回调函数将会被调用，并将加载的模块作为参数传递给它。如果加载过程中出现错误，catch 回调函数将会被调用，并将错误信息作为参数传递给它。\n需要注意的是，当使用动态导入时，浏览器会自动在 HTML 页面中添加对应的 &lt;script&gt; 标签，用于加载指定的模块。这个标签会被添加到 &lt;head&gt; 元素中，并且会使用异步加载的方式进行加载，不会阻塞其他的页面内容的加载。这种自动添加 &lt;script&gt; 标签的机制可以使得开发者更方便地使用动态导入功能，并且不需要手动添加 &lt;script&gt; 标签，从而提高了代码的可读性和维护性。\nES10ECMAScript 2019，也称为 ES10，是 JavaScript 语言的第十个版本，于 2019 年 6 月发布。它引入了几个新的语言特性和功能，包括：\n\nArray.prototype.flat() 和 Array.prototype.flatMap() 方法：用于扁平化数组和映射数组元素。\n\nString.prototype.trimStart() 和 String.prototype.trimEnd() 方法：用于去除字符串的首尾空格。\n\nObject.fromEntries() 方法：用于将键值对数组转换为对象。\n\nSymbol.prototype.description 属性：用于获取 Symbol 对象的描述字符串。\n\n可选的 catch 绑定：允许在 try-catch 语句中省略 catch 块中的异常绑定，从而使得代码更加简洁。\n\nBigInt 类型：用于表示任意精度的整数，可以解决 JavaScript 中对大整数的精度问题。\n\n动态 import() 函数：可以实现动态地导入模块。\n\n\n总之，ES10 引入了一些实用的新特性和功能，使得 JavaScript 语言更加现代化和强大。这些新特性和功能可以帮助开发者更加方便地编写复杂的 JavaScript 应用程序，并提高代码的可读性和可维护性。\nES10 与 ES11 动态 import() 函数有什么区别？ES10 引入了动态 import() 函数，而 ES11 对它进行了一些改进。\n在 ES10 中，import() 函数是一个异步函数，它可以动态地导入 JavaScript 模块。它返回一个 Promise 对象，可以通过 Promise 的 then 方法获取导入的模块。\n在 ES11 中，import() 函数被更新，它可以在任何地方调用，而不仅仅是在顶级作用域中。这使得我们可以动态地导入模块，并将其赋值给变量或常量。\nES11 还增加了一个新的特性，即顶级的 await 关键字。它允许我们在顶级作用域中使用 await，从而使得我们可以在模块加载完成之前阻塞 JavaScript 解释器。这意味着我们可以在模块加载完成之后再执行其他的代码，而不需要使用回调函数或 Promise 链。\n例如，下面的代码演示了如何使用顶级的 await 和动态 import() 函数：\n&#x2F;&#x2F; 在顶级作用域中使用 await 和 import()\nconst module &#x3D; await import(&#39;.&#x2F;module.js&#39;);\n\n&#x2F;&#x2F; 在模块加载完成之后再执行其他的代码\nconsole.log(module.foo());\n\n需要注意的是，顶级的 await 关键字只能在 ES2017+ 的 JavaScript 模块中使用，并且只能在模块的顶级作用域中使用。如果在其他地方使用，会导致语法错误。\nES9ECMAScript 2018，也称为 ES9，是 JavaScript 语言的第九个版本，于 2018 年 6 月发布。它引入了几个新的语言特性和功能，包括：\n\nPromise.prototype.finally() 方法：用于在 Promise 结束时执行一些操作，无论 Promise 成功还是失败。\n\nRest/Spread 属性：用于对象和数组的解构赋值语法中，可以轻松地获取对象和数组的剩余部分。\n\n正则表达式的命名捕获组：可以在正则表达式中使用命名捕获组，从而使得正则表达式的匹配更加直观和易于理解。\n\n正则表达式的 dotAll 标志：可以匹配任何字符，包括行终止符。\n\nAsync Iteration：可以使用 for-await-of 循环来遍历异步迭代器。\n\n\n总之，ES9 引入了一些实用的新特性和功能，使得 JavaScript 语言更加现代化和强大。这些新特性和功能可以帮助开发者更加方便地编写复杂的 JavaScript 应用程序，并提高代码的可读性和可维护性。\n正则表达式的命名捕获组在 ES9 中，正则表达式新增了命名捕获组（Named Capture Groups）功能，它允许给正则表达式中的捕获组起一个名称，使得正则表达式的匹配结果更加直观和易于理解。\n命名捕获组可以通过 (?&lt;name&gt;pattern) 的语法来定义，其中 name 是捕获组的名称，pattern 是捕获组的正则表达式。在匹配成功后，可以使用 match.groups 属性来获取命名捕获组的结果，例如：\nconst regex &#x3D; &#x2F;(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)&#x2F;;\nconst result &#x3D; regex.exec(&#39;2021-05-18&#39;);\n\nconsole.log(result.groups.year); &#x2F;&#x2F; &quot;2021&quot;\nconsole.log(result.groups.month); &#x2F;&#x2F; &quot;05&quot;\nconsole.log(result.groups.day); &#x2F;&#x2F; &quot;18&quot;\n\n在上面的代码中，正则表达式 /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/ 匹配日期字符串，并定义了三个命名捕获组，分别对应年、月、日。在匹配成功后，可以通过 result.groups 属性获取命名捕获组的结果。\n命名捕获组的优点在于，可以用更加直观和自然的方式来访问捕获组的结果，而不需要记住捕获组的编号。同时，命名捕获组还可以提高代码的可读性和可维护性，使得正则表达式更加易于理解和修改。\n正则表达式的 dotAll 标志当使用正则表达式进行匹配时，默认情况下，. 只能匹配除了行终止符以外的任意字符。如果需要匹配包括行终止符在内的任意字符，就可以使用 dotAll 标志。\n在正则表达式中，dotAll 标志使用 s 表示，它可以通过在正则表达式末尾添加 s 来启用。\n以下是一个简化的例子：\nconst regex &#x3D; &#x2F;hello.world&#x2F;s;\nconst str1 &#x3D; &#39;hello\\nworld&#39;;\nconst str2 &#x3D; &#39;hello world&#39;;\n\nconsole.log(regex.test(str1)); &#x2F;&#x2F; true\nconsole.log(regex.test(str2)); &#x2F;&#x2F; false\n\n如果正则表达式需要匹配包括行终止符在内的任意字符，就可以添加 s 标志来启用 dotAll 功能。\nAsync IterationES2018 引入了异步迭代器（Async Iteration）功能，它可以用于在异步环境下遍历数据集合，如异步操作返回的集合。异步迭代器通过 Symbol.asyncIterator 来定义，并使用 for-await-of 语句进行迭代。\n异步迭代器与普通迭代器的主要区别在于，它的 next() 方法返回的是一个 Promise 对象。当异步迭代器完成遍历时，它会返回一个 resolved 状态的 Promise 对象，并将 value 属性设置为 undefined。\n以下是一个简单的例子，演示了如何使用异步迭代器：\nasync function* asyncGenerator() &#123;\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n&#125;\n\n(async function () &#123;\n  for await (const item of asyncGenerator()) &#123;\n    console.log(item);\n  &#125;\n&#125;)();\n\n在上面的代码中，asyncGenerator() 函数定义了一个异步生成器，它通过 yield 关键字生成两个字符串。for-await-of 语句通过异步迭代器遍历异步生成器返回的数据集合，并依次打印每个元素的值。\n需要注意的是，在异步环境下，数据集合的获取和遍历过程都是异步的，因此需要使用 async/await 来处理异步操作。\nES8ES8（也称为 ECMAScript 2017）是 ECMAScript 标准的第八个版本，于 2017 年发布。ES8 引入了一些新功能和语言特性，包括：\n\n异步函数（Async Functions）：ES8 引入了异步函数的概念，通过 async/await 关键字，可以更方便地进行异步编程。\n\nObject.values() 和 Object.entries() 方法：这两个方法用于获取对象的属性值和键值对数组，便于对对象进行遍历。\n\n字符串填充方法 padStart() 和 padEnd()：这两个方法可以用于在字符串前面或后面添加指定数量的填充字符。\n\nObject.getOwnPropertyDescriptors() 方法：该方法返回指定对象所有自身属性（非继承属性）的描述符。\n\n函数参数列表和调用语法中的尾逗号：在函数参数列表和函数调用语句的参数列表中，允许添加末尾的逗号，这使得代码的变更更加方便。\n\nSharedArrayBuffer 对象：该对象用于创建可以被共享的缓冲区。\n\n\n以上是 ES8 引入的一些新功能和语言特性。这些特性的引入使得 JavaScript 编程更加简洁和高效。\nES7ES7（也称为 ECMAScript 2016）是 ECMAScript 标准的第七个版本，于 2016 年发布。ES7 引入了一些新功能和语言特性，包括：\n\n数组的 includes() 方法：该方法用于检查数组是否包含指定的值。\n\n幂运算符（Exponentiation Operator）：使用 ** 运算符可以进行幂运算，例如 2 ** 3 表示 2 的 3 次方。\n\nAsync 函数中的 Await 关键字可以在普通函数中使用：这意味着可以在普通函数中使用异步操作。\n\n函数绑定运算符（Function Binding Operator）：使用 :: 运算符可以将函数绑定到指定的对象上。\n\n\n以上是 ES7 引入的一些新功能和语言特性。这些特性的引入使得 JavaScript 编程更加方便和灵活。\n函数绑定运算符（Function Binding Operator）函数绑定运算符（Function Binding Operator）是 ES7（ECMAScript 2016）引入的一个新特性，它使用双冒号（::）作为运算符，可以将函数绑定到指定的对象上，形成一个新的绑定函数。\n使用函数绑定运算符可以简化代码，使代码更加简洁易懂。例如，使用函数绑定运算符可以将以下代码：\nconst boundFn &#x3D; fn.bind(obj);\n\n简化为：\nconst boundFn &#x3D; obj::fn;\n\n其中，fn 是要绑定的函数，obj 是要绑定到的对象。绑定后的 boundFn 函数与 fn 函数相同，但它的 this 指向了 obj 对象。\n需要注意的是，函数绑定运算符只是一个语法糖，它本质上还是通过 bind 方法实现的，因此在使用函数绑定运算符时，需要保证该方法的可用性。此外，函数绑定运算符还存在一些语法限制，例如无法与箭头函数一起使用。\n完整示例以下是一个使用函数绑定运算符的完整示例：\n&#x2F;&#x2F; 定义一个对象\nconst obj &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  sayHi() &#123;\n    console.log(&#96;Hi, my name is $&#123;this.name&#125;.&#96;);\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 绑定函数到对象上\nconst boundFn &#x3D; obj::obj.sayHi;\n\n&#x2F;&#x2F; 调用绑定函数\nboundFn(); &#x2F;&#x2F; 输出：Hi, my name is Tom.\n\n在上面的示例中，我们首先定义了一个包含 name 属性和 sayHi 方法的对象 obj。然后，使用函数绑定运算符将 sayHi 方法绑定到 obj 对象上，得到一个新的绑定函数 boundFn。最后，调用绑定函数 boundFn，输出 Hi, my name is Tom.。\n需要注意的是，obj::obj.sayHi 中的第一个 obj 是绑定的对象，第二个 obj.sayHi 则是要绑定的函数。\n直接写 const boundFn = obj.sayHi; 不是更简单吗？是的，你说得没错，直接写 const boundFn = obj.sayHi 也能得到一个指向 obj.sayHi 方法的函数。但是，在这种情况下，boundFn 函数的 this 指向将是调用该函数的上下文（即函数调用时所在的对象），而不是绑定到 obj 对象上。\n使用函数绑定运算符的优点在于，它可以显式地将函数绑定到指定的对象上，避免了由于函数调用时上下文的不确定性导致的错误。此外，它还能让代码更加简洁易懂，减少代码冗余。\n已经有了 bind 为什么还要设计 :::: 函数绑定运算符的主要优势在于语法更加简洁，特别是在使用函数嵌套时，可以有效地减少代码的嵌套深度，使代码更加清晰易懂。相比之下，使用 bind 方法时需要手动指定函数的 this 值和任意多个参数，语法相对繁琐。\n此外，函数绑定运算符还可以在更大程度上保留函数原本的语义，而不是通过 bind 方法显式地创建一个新的函数。这种方式在函数柯里化和函数组合等场景中特别有用。\n当然，如果你更喜欢使用 bind 方法或其他方式进行函数绑定，完全没有问题。这只是 JavaScript 提供的一种语法糖，你可以根据自己的喜好和代码风格选择使用。\nES6ES6（ECMAScript 2015）是 JavaScript 语言的一个重大更新版本，引入了许多新特性和语法糖，使得 JavaScript 编程更加简单、直观和高效。\n一些 ES6 新特性包括：\n\nlet 和 const 关键字，用于声明块级作用域的变量和常量。\n箭头函数，简化了函数定义的语法，并自动绑定了函数体内部的 this 指向。\n模板字符串，使得字符串拼接和格式化更加直观和方便。\n解构赋值，可以从对象或数组中快速提取值并赋给变量。\n默认参数和剩余参数，可以为函数的参数设置默认值或接受任意数量的参数。\n类和继承，提供了面向对象编程的语法和机制。\nPromise，为异步编程提供了更加方便和可靠的解决方案。\n模块化，可以方便地定义和导出模块，使得代码更加模块化和可重用。\n\n除此之外，ES6 还引入了很多其他的新特性和语法糖，如迭代器和生成器、Symbol、Proxy 和 Reflect 等，这些特性极大地拓展了 JavaScript 的功能和应用范围，使得它可以更好地应对现代 Web 开发的需求。\n","slug":"2022-08-17es","date":"2022-08-17T14:46:14.000Z","categories_index":"前端基础","tags_index":"前端基础,chatGPT2021","author_index":"举手摘月亮"},{"id":"d81dd412709b6fc04e7a6fd5be173494","title":"企业微信- 授权","content":"背景\n项目：已经有一个项目了，又整一个新项目共存\n域名：一级相同，二级域名不同\n\n微信授权回调限制, 回调可信域名只能配置一个\n\n\n变更后的授权流程\n\ndraw.io\n增加调试 - 强制内网强制 本地&#x2F;日常&#x2F;预发环境 走内网，方便在企业微信进行适配\n&#x2F;&#x2F; Config 为nextjs， 运行时配置信息\n\n&#x2F;&#x2F; 方便 日常&#x2F;预发环境 到企业微信中调试\nlet forceInNetwork &#x3D; true;\n\nif (isServer &amp;&amp; Config.env &#x3D;&#x3D;&#x3D; &quot;pro&quot;) &#123;\n  &#x2F;&#x2F; 线上环境 + 服务端渲染，不强制走内网\n  forceInNetwork &#x3D; false;\n&#125; else if (!isServer &amp;&amp; window.__NEXT_DATA__.runtimeConfig.env &#x3D;&#x3D;&#x3D; &quot;pro&quot;) &#123;\n  &#x2F;&#x2F; 线上环境 + 客户端渲染，不强制走内网\n  forceInNetwork &#x3D; false;\n&#125;\n\nif (\n  !forceInNetwork &amp;&amp; &#x2F;&#x2F; 非强制内网 + 微信环境，请求头设置 x-ty-auth-type\n  getWechatUserAgent(\n    isServer ? ctx.req.headers[&quot;user-agent&quot;] : navigator.userAgent\n  )\n) &#123;\n  options.headers[&quot;x-ty-auth-type&quot;] &#x3D; &quot;wx&quot;;\n&#125;\n\n&#x2F;&#x2F; ....\n\nlet apiUrl &#x3D; &quot;&quot;;\n&#x2F;&#x2F; 非强制内网 + 服务端 + 企业微信环境， 走企业微信授权\nif (\n  !forceInNetwork &amp;&amp;\n  isServer &amp;&amp;\n  getWechatUserAgent(options.headers[&quot;user-agent&quot;])\n) &#123;\n  apiUrl &#x3D; Config.wechatAuthProviderOrigin;\n&#125; else &#123;\n  apiUrl &#x3D; Config.api;\n&#125;\n\n增加调试 - 设置 cookieimport &#123; useRouter &#125; from &quot;@ty-fe&#x2F;next&#x2F;router&quot;;\nimport &#123; usePersistFn &#125; from &quot;ahooks&quot;;\nimport &#123; AutoCenter, Button, Card, Input, Space &#125; from &quot;antd-mobile&quot;;\nimport React, &#123; useState &#125; from &quot;react&quot;;\ninterface IProps &#123;&#125;\nconst SetCookie: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const router &#x3D; useRouter();\n  const [cookie, setCookie] &#x3D; useState(\n    &quot;ss_pweTnTjCiU_1bVtt6GNbd4UT2B7nK87S8xCXE3t0xuqMqDmlu7mH7PoBQ_HwwCYA616QM_9d_2yUsduiNyRrXrXQWZG1TtD7ZNNI1k3XMBx-wsYq59DKsv3Bh6nnZ9zkG-NCHsSdxbHZZ-2bCQIZ-oZ9eGiXEIo&quot;\n  );\n  const handleSetCookie &#x3D; usePersistFn(() &#x3D;&gt; &#123;\n    document.cookie &#x3D; &quot;SSO_USER_TOKEN&quot; + &quot;&#x3D;&quot; + cookie;\n  &#125;);\n  const handleChange &#x3D; usePersistFn((v) &#x3D;&gt; &#123;\n    setCookie(v);\n  &#125;);\n\n  const handleGoMbHome &#x3D; usePersistFn(() &#x3D;&gt; &#123;\n    router.push(&quot;&#x2F;my&#x2F;mobile?activeTab&#x3D;1&quot;);\n  &#125;);\n  return (\n    &lt;Card&gt;\n      &lt;p&gt;设置cookie&lt;&#x2F;p&gt;\n      &lt;Input\n        style&#x3D;&#123;&#123; border: &quot;1px solid #000&quot; &#125;&#125;\n        value&#x3D;&#123;cookie&#125;\n        placeholder&#x3D;&quot;输入cookie&quot;\n        onChange&#x3D;&#123;handleChange&#125;\n      &#x2F;&gt;\n      &lt;br&gt;&lt;&#x2F;br&gt;\n      &lt;Space&gt;\n        &lt;Button color&#x3D;&quot;primary&quot; fill&#x3D;&quot;solid&quot; onClick&#x3D;&#123;handleSetCookie&#125;&gt;\n          设置cookie\n        &lt;&#x2F;Button&gt;\n        &lt;Button color&#x3D;&quot;primary&quot; fill&#x3D;&quot;solid&quot; onClick&#x3D;&#123;handleGoMbHome&#125;&gt;\n          移动端首页\n        &lt;&#x2F;Button&gt;\n      &lt;&#x2F;Space&gt;\n    &lt;&#x2F;Card&gt;\n  );\n&#125;;\n\nexport default SetCookie;\n\n注意事项No.1对于某些需要使用到当前用户数据的页面，在作为入口的时候需要特别注意\n会出现拿不到当前登录用户信息的情况\n过程如下\n\n开始是没有授权的\n授权之后，页面被重定向回到该页面\n由于已加载了，有缓存，服务端不会再走一遍，在服务端往redux塞数据的时候，不会再次触发\n如果服务端有些接口设计的时候不是从 cookie 中获取用户信息，前端在传当前用户信息的时候，很有可能redux中没有该用户信息\n\n解决方案： 在一些入口页面，redux 取不到用户信息时候，客户端渲染时候再次获取用户信息\nNo.2部分企业微信 pc 客户端不支持[].at()方法, 避免使用此 api 的时候， polyfill 是解决不了问题的 见\ncode\n\n\n2022-07-14js-arr\n经测试发现 polyfill 无效, 应该是被企业微信限制了\n\n\n企业微信限制了Array，为何有的企业微信客户端可以，我猜是企业微信的一个 bug\n\n\nNo.3","slug":"2022-08-17wx-auth","date":"2022-08-17T08:02:43.000Z","categories_index":"企业微信","tags_index":"企业微信","author_index":"举手摘月亮"},{"id":"0c749d9dc89621b4e02fc2ff0a775bfc","title":"备份插件排查code helper","content":"codegen_anything\ncodegen_mock\ncodegen_sinipets\n\nCSS Module Typed\n\nCSS Modules\n\nColor Highlight\n\nES7+ React&#x2F;Redux&#x2F;React-Native snippets\n\nLeetCode\n\nReact Native Snippet\n\nReact Native Tools\n\nReact-Native&#x2F;React&#x2F;Redux snippets for es6&#x2F;es7\n\nXML\n\nPaste JSON as Code\n\nNested Comments\n\nMaterial Icon Theme\n\nAuto Rename Tag\n\nbackground-cover\n\nESLint\n\nImport Cost\n\nBookmarks\n\nCode Runner\n\nFavorites\n\ngitignore\n\nImageToText\n\nGit Graph\n\nTodo Tree\n\nLive Server\n\nES7+ React&#x2F;Redux&#x2F;React-Native snippets\n\nPath Intellisense\n\nSettings Sync\n\nSort JS object keys\n\ni18n Ally\n\n\n\nGit History插件引起内存泄漏,导致 code helper cpu 超负荷运行\nGitLens\n\n新学的几个\nProject Manager : 还是比较需要的，目前维护上个部门所有任务，recent open找项目确实有点头大\nTemplate String Converter: 字符串转字符串模版，TODO: 源码：可以学习下这个项目是如何实现的\n合并行: 这个是 vscode 快捷键，不是插件\n\n","slug":"2022-08-11vscode-plugins","date":"2022-08-11T01:31:40.000Z","categories_index":"vscode","tags_index":"vscode","author_index":"举手摘月亮"},{"id":"dc16287a60c57ad74473292227a086e1","title":"React使用swiper","content":".maskBody &#123;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100vh;\n  width: 100vw;\n&#125;\n\n.swiperItem &#123;\n  height: calc(100vh - 48px);\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n&#125;\n\n&lt;Swiper activeSlideKey&#x3D;&#123;activeSlideKey&#125; &#123;...params&#125;&gt;\n  &#123;files.map((item) &#x3D;&gt; (\n    &lt;div key&#x3D;&#123;item.fileKey&#125; className&#x3D;&#123;styles.swiperItem&#125;&gt; &lt;!--不写此处,无法滚动--&gt;\n      &lt;ImageViewer url&#x3D;&#123;item.signaturedUrls&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  ))&#125;\n&lt;&#x2F;Swiper&gt;\n","slug":"2022-08-05swiper","date":"2022-08-05T03:22:25.000Z","categories_index":"swiper","tags_index":"swiper","author_index":"举手摘月亮"},{"id":"816f51e81b001fc0ce3338816ad5683d","title":"OA业务相关","content":"slatehttps://github.com/ianstormtaylor/slate\n\n\n\n钉钉文档、BOSS直聘文档、我们公司的wiki文档 都是使用 slate 开发的\n我们公司的 wiki 文档\n\n\n钉钉文档\n思维导图\n\n\n\n\n\n\n\n\n\n\n不建议直接使用百度脑图仓库进行二次开发。\n需要脑图可视化需求的，可以基于 kityminder-core 进行二次开发；需要脑图编辑需求的，可以使用 kityminder-editor 进行二次开发。\nworkflow\n\nhttps://github.com/StavinLi/Workflow\"\n\nlogicflowlogic-flow\n\n  \n\n\n\n\nexcalidraw\n\nexcalidraw\nhttps://github.com/excalidraw/excalidraw\n\ntldraw\n\nhttps://github.com/tldraw/tldraw\n\ntldraw\nwfd\n\nhttps://github.com/guozhaolong/wfd\n\nbutterflyhttps://github.com/alibaba/butterfly\n\n小蝴蝶官网\n绘图le5le-com&#x2F;topology\ngithub 搜索\nreact-data-flowhttps://github.com/chicAboo/react-data-flow\n\n\n\nn8n免费且源代码可用的公平代码授权工作流自动化工具。跨不同服务轻松执行自动任务。\nhttps://github.com/n8n-io/n8n\n\n\n\nflowyhttps://github.com/alyssaxuu/flowy\n\nexcelschedule timehttps://github.com/neuronetio/gantt-schedule-timeline-calendar\n\n\n\nGantthttps://frappe.io/gantt\nhttps://github.com/frappe/gantt\n\n任意两个点的曲线连接 JS 算法任意两个点的曲线连接 JS 算法\n滑块验证码 与 点选验证码https://api.gitee.com/tianai/tianai-captcha\n滑动验证功能实现原理是什么？\n滑动验证码是服务端随机生成滑块和带有滑块阴影的背景图片，然后将其随机的滑块位置坐标保存。\n前端实现互动的交互，将滑块把图拼上，获取用户的相关行为值。\n然后服务端进行相应值的校验。其背后的逻辑是使用机器学习中的深度学习，根据鼠标滑动轨迹，坐标位置，计算拖动速度，重试次数等多维度来判断是否人为操作。\n滑动验证码对机器的判断，不只是完成拼图，前端用户看不见的是——验证码后台针对用户产生的行为轨迹数据进行机器学习建模，结合访问频率、地理位置、历史记录等多个维度信息，快速、准确的返回人机判定结果，故而机器识别+模拟不易通过。\n滑动验证码也不是万无一失，但对滑动行为的模拟需要比较强的破解能力，毕竟还是大幅提升了攻击成本，而且技术也会在攻防转换中不断进步\n\n滑动验证码的优势：\n用户体验佳，用户无需识别复杂的验证码，只需轻轻一滑，秒速通过验证，更加便捷；\n安全性高，基于强大的后台分析，结合大量的维度行为值进行对比；\n种类多样，企业可以根据自身产品的风格，灵活定制滑动模块。\n\n","slug":"2022-08-01oa工具","date":"2022-08-01T10:13:29.000Z","categories_index":"业务相关","tags_index":"业务相关","author_index":"举手摘月亮"},{"id":"991fb01358aaac1abfe173de529db251","title":"前端基础-js 作用域","content":"问题var let const 区别：\n\n\n在 JavaScript 中，var、let 和 const 是用于声明变量的关键字，它们之间有以下几点区别：sckzb\n\n重复声明：\n\n\nvar：可以重复声明同名变量，后面的声明会覆盖前面的声明。\nlet 和 const：不能重复声明同名变量，否则会抛出 SyntaxError 错误。\n\n\n初始值：\n\n\nvar 和 let：可以不进行初始化，即声明时不赋初值。\nconst：必须进行初始化，即声明时必须进行赋值，否则会抛出 SyntaxError 错误。\n\n\n可变性：\n\n\nvar 和 let：声明的变量可以修改。\nconst：声明的变量是常量，不可修改。\n\n\n作用域：\n\n\nvar：变量的作用域是函数级别的或全局级别的，在函数内部声明的变量在函数外部也可以访问到，这就是所谓的变量提升。\nlet 和 const：变量的作用域是块级别的，即在代码块内部声明的变量只能在该代码块内访问，包括 if、for、while 等块级作用域语句。\n\n\n变量提升：\n\n\nvar：声明的变量会被提升到函数或全局作用域的顶部，即可以在变量声明之前访问到该变量，但其值为 undefined。\nlet 和 const：不存在变量提升，即变量必须先声明后使用，否则会抛出 ReferenceError 错误。\n\n总之，var、let 和 const 都是用于声明变量的关键字，但它们在作用域、变量提升、重复声明、初始值和可变性等方面存在差异。在实际编程中，应根据需要选择合适的关键字来声明变量。通常情况下，建议使用 let 和 const 来代替 var，以避免由变量提升和重复声明带来的一些问题。\n作用域：\n\n什么是执行上下文？\n什么是词法环境？\n什么是作用域？\n什么是作用域链？\n\n思维导图\n\n作用域【精】MDN:\n在当前的执行上下文。值和表达式在其中 \"可见\" 或可被访问到的上下文。 如果一个**变量或者其他表达式**,不 \"在当前的作用域中\"，那么它就是不可用的。\n\n作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。\n\n作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。\n\n> 在函数之外声明的变量，叫做`全局变量`，因为它可被当前文档中的任何其他代码所访问。\n> 在函数内部声明的变量，叫做`局部变量`，因为它只能在当前函数的内部访问。\n> ECMAScript 6 之前的 JavaScript 没有 `语句块作用域`；\n> es6 之后，`语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量`。 -->\n\n\n是什么\n如何分类\n如何实现作用域\n如何控制作用域\n\n作用域是指在程序中定义变量的区域，它规定了变量的可见性和生命周期。在 JavaScript 中，作用域可以分为全局作用域和局部作用域，其中全局作用域指的是在整个程序中都可见的变量，局部作用域指的是在函数或代码块内定义的变量。\n具体来说，JavaScript 中的作用域是通过作用域链实现的。作用域链是由多个执行上下文（Execution Context）的变量对象组成的链表结构，它决定了变量的查找顺序和可见性。\n当代码在执行时，JavaScript 引擎会创建执行上下文，并将其推入执行栈中。每个执行上下文都有一个变量对象，用于存储变量、函数声明和函数参数等信息。当查找变量时，JavaScript 引擎会先在当前执行上下文的变量对象中查找，如果没有找到，则会向上一级执行上下文的变量对象中查找，直到找到该变量或到达全局执行上下文为止。\n在 JavaScript 中，变量的作用域可以通过关键字 var、let、const 来控制。\n\n使用 var 关键字声明的变量具有函数作用域，即在函数内部声明的变量在函数外部无法访问。\n而使用 let 或 const 关键字声明的变量具有块级作用域，即在代码块内部声明的变量只能在该代码块内访问。\n\n因此，理解作用域是很重要的，它可以帮助我们正确地声明变量，避免命名冲突，提高代码的可读性和可维护性。同时，也可以帮助我们更好地理解 JavaScript 的执行机制和运行时环境。\n例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。\nif (true) &#123;\n  var x &#x3D; 5;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 5\n\n使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。\nif (true) &#123;\n  let y &#x3D; 5;\n&#125;\nconsole.log(y); &#x2F;&#x2F; ReferenceError: y 没有被声明\n\n作用域链【精】\n\n什么是作用域链\n作用域链（Scope Chain）是由多个执行上下文的变量对象组成的链表结构，用于决定变量的查找顺序和可见性。在 JavaScript 中，每个函数都有一个作用域链，它由当前函数的变量对象和所有包含它的父函数的变量对象组成。\n当 JavaScript 引擎在执行一个函数时，会首先在该函数的变量对象中查找要访问的变量。如果找到了，则直接使用该变量；否则，会沿着作用域链依次向上查找，直到找到该变量或到达全局执行上下文的变量对象为止。如果在最后都没有找到该变量，则会抛出“ReferenceError”异常。\n举个例子，假设我们有以下代码：\nfunction foo() &#123;\n  var x &#x3D; 10;\n\n  function bar() &#123;\n    var y &#x3D; 20;\n    console.log(x + y);\n  &#125;\n\n  bar();\n&#125;\n\nfoo();\n\n在执行函数 bar 时，JavaScript 引擎会先在 bar 函数的变量对象中查找变量 y，找到后直接使用。但是，当它需要访问变量 x 时，会沿着作用域链向上查找，在 foo 函数的变量对象中找到该变量，因此可以正常访问并输出 30。\n需要注意的是，作用域链是在函数创建时确定的，与函数的调用方式无关。\n\n因此，在一个函数内部定义的变量只能在该函数内部访问，而不能在外部访问。\n此外，由于闭包的存在，一个函数可以访问其定义时的作用域链上的所有变量，这也是 JavaScript 中一种强大的编程技巧。\n\n块级作用域块语句（或其他语言的复合语句）用于组合零个或多个语句。该块由一对大括号界定，可以是 labelled\n其他语言中通常将语句块称为复合语句。它允许你使用多个语句，其中 JavaScript 只需要一个语句。将语句组合成块是 JavaScript 中的常见做法。相反的做法是可以使用一个空语句(即 ;)，你不提供任何语句，虽然一个是必需的。\n\n\n\n\n\n\n\n\n\n\n1.通过 var 声明的变量或者非严格模式下 (non-strict mode) 创建的函数声明没有块级作用域\n2.使用 let 和 const 声明的变量是有块级作用域的\n3.使用 let 声明的变量, 在块级作用域内, 能强制执行更新变量\n4.使用 function 函数声明同样被限制在声明他的语句块内：\n\n1. 通过 var 声明的变量或者非严格模式下 (non-strict mode) 创建的函数声明没有块级作用域。\nvar x &#x3D; 1;\n&#123;\n  var x &#x3D; 2;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 输出 2\n\n&#x2F;&#x2F; 输出结果是 2，因为块中的 var x语句与块前面的var x语句作用域相同。在 C 或 Java 中，这段代码会输出 1。\n\n2. 使用 let 和 const 声明的变量是有块级作用域的。\n事例 1\nlet x &#x3D; 1;\n&#123;\n  let x &#x3D; 2;\n&#125;\nconsole.log(x); &#x2F;&#x2F; 输出 1\n&#x2F;&#x2F; x &#x3D; 2仅限在定义它的块中\n\n事例 2\nconst c &#x3D; 1;\n&#123;\n  const c &#x3D; 2;\n&#125;\nconsole.log(c); &#x2F;&#x2F; 输出 1，而且不会报错\n\n&#x2F;&#x2F; 位于块范围之内的 const c &#x3D; 2 并不会抛出SyntaxError: Identifier &#39;c&#39; has already been declared这样的语法错误，因为在它自己的块中它可能是唯一一个被声明的常量。\n\n3. 使用 let 声明的变量, 在块级作用域内, 能强制执行更新变量\nvar a &#x3D; [];\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n  a[i] &#x3D; function () &#123;\n    console.log(i);\n  &#125;;\n&#125;\na[0](); &#x2F;&#x2F; 10\na[1](); &#x2F;&#x2F; 10\na[6](); &#x2F;&#x2F; 10\n\n&#x2F;********************&#x2F;\n\nvar a &#x3D; [];\nfor (let i &#x3D; 0; i &lt; 10; i++) &#123;\n  a[i] &#x3D; function () &#123;\n    console.log(i);\n  &#125;;\n&#125;\na[0](); &#x2F;&#x2F; 0\na[1](); &#x2F;&#x2F; 1\na[6](); &#x2F;&#x2F; 6\n\n4. 使用 function 函数声明同样被限制在声明他的语句块内：\nfoo(&#39;outside&#39;); &#x2F;&#x2F; TypeError: foo is not a function\n&#123;\n  function foo(location) &#123;\n    console.log(&#39;foo is called &#39; + location);\n  &#125;\n  foo(&#39;inside&#39;); &#x2F;&#x2F; 正常工作并且打印 &#39;foo is called inside&#39;\n&#125;\n\n变量声明JavaScript 有三种声明方式。\n\nvar 声明一个变量，可选初始化一个值。\nlet 声明一个块作用域的局部变量，可选初始化一个值。\nconst 声明一个块作用域的只读常量。\n\n变量提升变量提升: 可以先使用变量稍后再声明变量而不会引发异常\nJavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。\n但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。\n&#x2F;**\n * 例子 1\n *&#x2F;\nconsole.log(x &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; true\nvar x &#x3D; 3;\n\n&#x2F;**\n * 例子 2\n *&#x2F;\n&#x2F;&#x2F; will return a value of undefined\nvar myvar &#x3D; &#39;my value&#39;;\n\n(function () &#123;\n  console.log(myvar); &#x2F;&#x2F; undefined\n  var myvar &#x3D; &#39;local value&#39;;\n&#125;)();\n\n上面的例子，也可写作：\n&#x2F;**\n * 例子 1\n *&#x2F;\nvar x;\nconsole.log(x &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; true\nx &#x3D; 3;\n\n&#x2F;**\n * 例子 2\n *&#x2F;\nvar myvar &#x3D; &#39;my value&#39;;\n\n(function () &#123;\n  var myvar;\n  console.log(myvar); &#x2F;&#x2F; undefined\n  myvar &#x3D; &#39;local value&#39;;\n&#125;)();\n\n由于存在变量提升，一个函数中所有的 var 语句应尽可能地放在接近函数顶部的地方。这个习惯将大大提升代码的清晰度。\n在 ECMAScript 6 中，let 和 const 同样会被提升变量到代码块的顶部, 但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。\n原文\n暂时性死区：程序未执行到声明处时,访问该变量都会报引用错误\n这个不是太好理解啊：let const 变量会提升，但是不会进行变量声明，如果在声明之前引用，将抛出错误;\n函数提升对于函数来说，函数声明会被提升到顶部，函数表达式也会被提升。\n&#x2F;* 函数声明 *&#x2F;\n\nfoo(); &#x2F;&#x2F; &quot;bar&quot;\n\nfunction foo() &#123;\n  console.log(&#39;bar&#39;);\n&#125;\n\n&#x2F;* 函数表达式 *&#x2F;\n\nbaz(); &#x2F;&#x2F; 类型错误：baz 不是一个函数\n\nvar baz &#x3D; function () &#123;\n  console.log(&#39;bar2&#39;);\n&#125;;\n\n全局变量全局变量是全局对象的属性。在网页中，（译注：缺省的）全局对象是 window ，所以你可以用形如 window.variable 的语法来设置和访问全局变量。\n因此，你可以通过指定 window 或 frame 的名字，在当前 window 或 frame 访问另一个 window 或 frame 中声明的变量。例如，在文档里声明一个叫 phoneNumber 的变量，那么你就可以在子框架里使用 parent.phoneNumber 的方式来引用它。\n常量你可以用关键字 const 创建一个只读的常量。常量标识符的命名规则和变量相同：必须以字母、下划线（_）或美元符号（$）开头并可以包含有字母、数字或下划线。\nconst PI &#x3D; 3.14;\n常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。它必须被初始化为某个值。\n常量的作用域规则与 let 块级作用域变量相同。若省略 const 关键字，则该标识符将被视为变量。\n在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。例如：\n&#x2F;&#x2F; 这会造成错误\nfunction f() &#123;&#125;\nconst f &#x3D; 5;\n\n&#x2F;&#x2F; 这也会造成错误\nfunction f() &#123;\n  const g &#x3D; 5;\n  var g;\n\n  &#x2F;&#x2F;语句\n&#125;\n\n然而，对象属性被赋值为常量是不受保护的，所以下面的语句执行时不会产生错误。\nconst MY_OBJECT &#x3D; &#123; key: &#39;value&#39; &#125;;\nMY_OBJECT.key &#x3D; &#39;otherValue&#39;;\n\n同样的，数组的被定义为常量也是不受保护的，所以下面的语句执行时也不会产生错误。\nconst MY_ARRAY &#x3D; [&#39;HTML&#39;, &#39;CSS&#39;];\nMY_ARRAY.push(&#39;JAVASCRIPT&#39;);\nconsole.log(MY_ARRAY); &#x2F;&#x2F;logs [&#39;HTML&#39;,&#39;CSS&#39;,&#39;JAVASCRIPT&#39;];\n\n什么是闭包【精】前端基础-js 闭包\n闭包是指在一个函数内部定义的函数，并且这个内部函数可以访问其外部函数的变量，即使外部函数已经执行结束并被销毁了，也仍然可以访问这些变量。\n在 JavaScript 中，每个函数都是一个闭包。当一个函数被定义时，它就会创建一个执行上下文（Execution Context），其中包含一个变量对象和一个作用域链。当这个函数返回时，它的执行上下文会被销毁，但是如果这个函数内部定义了其他函数并返回了它们，那么这些函数将形成一个闭包，可以访问它们父函数的变量和作用域链。\n闭包在 JavaScript 中非常重要，它可以帮助我们实现一些高级的编程技巧，例如封装变量、实现私有成员、缓存中间结果等。举个例子，我们可以使用闭包来实现一个简单的计数器：\nfunction createCounter() &#123;\n  var count &#x3D; 0;\n\n  return function () &#123;\n    count++;\n    console.log(count);\n  &#125;;\n&#125;\n\nvar counter1 &#x3D; createCounter();\nvar counter2 &#x3D; createCounter();\n\ncounter1(); &#x2F;&#x2F; 输出 1\ncounter1(); &#x2F;&#x2F; 输出 2\ncounter2(); &#x2F;&#x2F; 输出 1\ncounter2(); &#x2F;&#x2F; 输出 2\n\n在上面的代码中，我们定义了一个 createCounter 函数，它返回一个内部函数，这个内部函数可以访问外部函数的变量 count。每次调用这个内部函数时，都会将 count 的值加 1 并输出结果。由于每次调用 createCounter 都会返回一个新的函数，因此我们可以创建多个计数器，并且它们之间互不影响。\n需要注意的是，由于闭包会维护外部函数的作用域链，因此在使用闭包时要注意内存泄漏问题。\n内存过高：如果闭包中引用了外部函数的大量变量，而这些变量又是对象或函数等占用内存较大的数据类型，那么可能会导致内存占用过高。\n解决方案：在这种情况下，我们可以考虑将需要保留的变量封装成一个对象，然后将这个对象作为参数传递给闭包函数，从而避免闭包对外部作用域链的过度依赖。\n事例es6 之前没有块级作用域var a &#x3D; 12;\nif (a &gt; 10) &#123;\n  var c &#x3D; a + 1;\n&#125;\nconsole.log(a, c);\n\n有 var 和 无 varfunction fn() &#123;\n  var a &#x3D; (b &#x3D; 30);\n  console.log(a, b); &#x2F;&#x2F; 30,30\n&#125;\nfn();\nconsole.log(b); &#x2F;&#x2F; 30\nconsole.log(a); &#x2F;&#x2F; Uncaught ReferenceError: a is not defined\n\n&#x2F;&#x2F; 解释：在非严格模式下，允许不用var声明变量，“不用var声明的变量会默认为全局变量”。\n&#x2F;&#x2F; var a &#x3D; b &#x3D;30 等价于b &#x3D; 10;b &#x3D; 10; 所以b是一个全局变量，a是个局部变量。\n\n区分 变量提升，函数声明提升fn1(); &#x2F;&#x2F; fn1\nfn2(); &#x2F;&#x2F;第一次fn2调用  &#x2F;&#x2F; 报错\n\nfunction fn1() &#123;\n  console.log(&#39;fn1&#39;);\n&#125;\n\nvar fn2 &#x3D; function () &#123;\n  &#x2F;&#x2F; 这个是变量声明，而不是函数声明\n  console.log(&#39;fn2&#39;);\n&#125;;\n\nfn2(); &#x2F;&#x2F;第二次fn2调用\n\n&#x2F;&#x2F; 解释：第一个位置调用fn2报错，代码终止执行；如果屏蔽第一个位置调用fn2，在第二个位置调用，正常调用，并输出“fn2”。这里考察的是变量提升和函数提升。上述代码等介于：\n\n&#x2F;&#x2F; 函数提升和变量提升\nfunction fn1() &#123;\n  console.log(&#39;fn1&#39;);\n&#125;\nvar fn2;\n\nfn1();\nfn2();\n\nfn2 &#x3D; function () &#123;\n  console.log(&#39;fn2&#39;);\n&#125;;\n\nfn2();\n\n函数提升在变量之前进行console.log(a); &#x2F;&#x2F; f a() &#123;console.log(10)&#125;\nconsole.log(a()); &#x2F;&#x2F;  undefined\nvar a &#x3D; 3;\n\nfunction a() &#123;\n  console.log(10); &#x2F;&#x2F;10\n&#125;\nconsole.log(a); &#x2F;&#x2F;3\na &#x3D; 6;\nconsole.log(a()); &#x2F;&#x2F;a is not a function;\n\n实际编译过程如下：\nvar a &#x3D; funtion () &#123;\n  console.log(10)\n&#125;\n&#x2F;&#x2F; var a;\nconsole.log(a);    &#x2F;&#x2F; f a() &#123;console.log(10)&#125;\nconsole.log(a());  &#x2F;&#x2F;  undefined\n\na &#x3D; 3;\nconsole.log(a)   &#x2F;&#x2F;3\na &#x3D; 6;\nconsole.log(a());   &#x2F;&#x2F;a() is not a function;\n\n循环中,IIFE 函数形成的匿名空间&#x2F;&#x2F; 代码1\nfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(function () &#123;\n    console.log(i);\n  &#125;, i * 2000);\n&#125;\n\n&#x2F;&#x2F; 代码2\nfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  (function (i) &#123;\n    setTimeout(function () &#123;\n      console.log(i);\n    &#125;, i * 2000);\n  &#125;)(i);\n&#125;\n\n作用域与作用域链&#x2F;&#x2F; 代码\nvar a &#x3D; 10;\nfunction fn() &#123;\n  console.log(a);\n&#125;\n\nfunction fn2() &#123;\n  var a &#x3D; 20;\n  fn();\n&#125;\n\nfn2();\n\n&#x2F;&#x2F; 解释：考察了作用域与作用域链的相关知识。记住两点：\n&#x2F;&#x2F; 1、作用域与作用域链都是一个静态的概念，在函数定义的时候就确定了；\n&#x2F;&#x2F; 2、通过作用域链查找遍了的时候，首先要找到函数本身的作用域，从它本身的作用域开始沿着作用域链向它的上一级依次查找。\n&#x2F;&#x2F; 输出结果为10\n\n作用域与作用域链var fn &#x3D; function () &#123;\n  console.log(fn);\n&#125;;\nfn();\n\nvar obj &#x3D; &#123;\n  fn2: function () &#123;\n    console.log(fn2); &#x2F;&#x2F; 会报错\n  &#125;,\n&#125;;\nobj.fn2();\n&#x2F;&#x2F; 解释：这里同样考察的是作用域和作用域链的知识。\n&#x2F;&#x2F; 同时要注意：在obj中的console.log(fn2) 和 console.log(this.fn2)的区别。\n\n如果不改写会报错，为什么会报错【精】如果不改写 console.log(fn2) 为 console.log(this.fn2)，那么在执行 obj.fn2() 时会报错，因为在 fn2 函数内部，fn2 并没有被定义。这是因为在 JavaScript 中，函数内部的作用域链中包含了函数的父级作用域，但并不包含其它对象的作用域。\n在这个例子中，fn2 只是一个对象的属性，它并没有被定义在 fn2 函数内部的作用域中，因此直接访问 fn2 会抛出一个 ReferenceError 异常。\n为了访问对象的属性，需要使用 this 关键字来引用对象本身，即通过 this.fn2 来访问对象的 fn2 方法。这样在函数内部就可以正确地访问对象的属性了。\nthis 指向var obj &#x3D; &#123;\n  fn2: function () &#123;\n    console.log(this.fn2);\n  &#125;,\n&#125;;\nobj.fn2(); &#x2F;&#x2F;输出fn2函数\n\nthis 的指向是比较复杂的，需要结合函数的调用方式和执行上下文等因素来理解和判断\nthis 绑定规则\n判断函数调用时是否使用了 new，如果使用了 new 绑定，则 this 绑定的是新创建的对象。\n函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。\n函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。\n以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，4.1 在严格模式下，默认绑定的 this 是 undefined，4.2 非严格模式下绑定到全局对象。\n\n&#x2F;#&#x2F;post&#x2F;2022-09-19qa\n参考链接MDN 块语句\nMDN let\nMDN var\nMDN const \nMDN 语法和数据类型\n作用域相关\nlet 和 const 定义的变量在哪？在 Script 这个域中\n","slug":"2022-07-30js-scope","date":"2022-07-30T15:52:03.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"2f158976ef1fb5c7b879b46326b6f72a","title":"前端基础-js eventloop","content":"思维导图\n\n背景JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事\n为什么要这么设计，跟 JavaScript 的应用场景有关\nJavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？\n为了解决单线程运行阻塞问题，JavaScript 用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）\n运行环境js 运行的环境,被称为宿主环境，目前有三种运行环境，\n\n一种运行在浏览器(javaScript)\n一种运行在服务端(nodejs)\n另一种是运行在我们的客户端(比如 Vscode 客户端就是使用 js 写的)\n\n其他的比如：IOS 中jscore，Android JavascriptInterace, C++ JSI\n因此只要给 js 配备的相应的执行引擎，js 可以运行在任何环境\n浏览器宿主环境\n\nJS 线程负责执行执行栈的最顶层 JS 代码和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。\nGUI 线程负责渲染页面,解析 HTML、CSS 构成 渲染树等，当页面重绘或者由于某种操作引起回流都会调起该线程。和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。\n事件监听线程(DOM 事件，window 窗口事件等等)\n当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到事件队列的队尾，等待 JS 引擎处理。\n计时线程（SetTimeout、setInterval 计时器）\n开启定时器触发线程来计时并触发计时，计时完毕后，将计时器结束的回调函数添加到事件队列中，等待 JS 引擎空闲后执行，等待 JS 引擎处理。浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。\n网络线程（ajax 网络请求）\nhttp 请求的时候会开启一条请求线程。请求完成有结果了之后，将请求的 http 回调函数添加到任务队列中，等待 JS 引擎处理。\n两个概念\n栈是先进后出\n\n队列先进先出\n\n\n事件队列事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：\n宏任务（队列）macroTack：计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列微任务（队列）microTack：MutationObserver,Promise 产生的回调进入微队列\n当执行栈清空时、JS 引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，执行宏任务\n事件循环(Event Loop)JavaScript 事件循环（Event Loop）是 JavaScript 运行时的一种机制，用于处理异步事件和回调函数。在 JavaScript 中，很多操作都是异步执行的，比如网络请求、定时器等等。这些异步操作会被放置到任务队列中，而不会立即执行。当主线程执行完同步任务后，会进入事件循环，从任务队列中取出待执行的任务，并按照顺序执行。执行完一个任务后，JavaScript 引擎会重新进入事件循环，继续取出待执行的任务并执行，直到所有任务都执行完成。\nJavaScript 事件循环的基本流程如下：\n\n执行同步任务。\n查看任务队列中是否有任务，如果有则取出最先进入队列的任务。\n执行任务。\n重复步骤 2 和步骤 3，直到任务队列为空。\n\n在事件循环中，任务队列被分为两种：宏任务（Macro Task）和微任务（Micro Task）。宏任务包括 setTimeout、setInterval、ajax 等等，而微任务包括 Promise、process.nextTick 等等。浏览器环境：在事件循环中，每个宏任务执行完成后，都会执行所有的微任务，然后才会执行下一个宏任务。\nJavaScript 事件循环的概念对于理解 JavaScript 的异步编程非常重要。同时，也需要注意避免事件循环中可能出现的一些问题，比如过度使用异步操作、回调函数嵌套等等，以免导致程序出现性能问题或难以维护。\n执行栈\n\nJavaScript 执行栈是一种数据结构，用于存储执行上下文（Execution Context）的堆栈。执行上下文是 JavaScript 代码执行时创建的一个内部数据结构，其中包含变量、函数、对象以及代码执行的环境信息。\n\n当 JavaScript 引擎开始执行代码时，它会首先创建一个全局执行上下文，并将其推入执行栈的顶部。\n然后，当 JavaScript 引擎执行函数时，它会创建一个新的执行上下文，并将其推入执行栈的顶部。\n当函数执行完成后，执行上下文将从栈中弹出，JavaScript 引擎将继续执行上一个执行上下文，直到最终弹出全局执行上下文。\n\n执行栈是一个重要的概念，因为它决定了 JavaScript 代码的执行顺序。\n\n如果执行栈中有多个执行上下文，那么 JavaScript 引擎将按照它们的顺序依次执行，直到栈中没有剩余的执行上下文为止。\n如果执行栈中有太多的执行上下文，可能会导致栈溢出错误，这通常是由于无限递归调用函数造成的。\n因此，在编写 JavaScript 代码时，需要注意避免出现无限递归和过度嵌套函数等问题，以确保执行栈能够正常工作。\n\n什么是全局上执行下文，什么是函数执行上下文在 JavaScript 中，每当代码开始执行时，都会创建一个执行上下文（Execution Context）。执行上下文是一个内部数据结构，它包含了代码执行所需要的环境信息，包括变量、函数、对象等等。\n全局执行上下文是在 JavaScript 代码开始执行时创建的第一个执行上下文。它是整个程序的最外层作用域，包含了全局变量、函数、对象等等。全局执行上下文只有一个，直到程序运行结束都不会被销毁。\n函数执行上下文是在函数被调用时创建的执行上下文。每次函数被调用时，都会创建一个新的执行上下文，并将其推入执行栈的顶部。函数执行上下文包含了函数的参数、局部变量、内部函数等等。\n全局执行上下文和函数执行上下文的主要区别在于它们的作用域和生命周期。全局执行上下文是整个程序的最外层作用域，其生命周期贯穿整个程序的执行过程。而函数执行上下文只在函数被调用时创建，当函数执行完成后就会被销毁。在函数执行上下文中，作用域链会包含外部函数的执行上下文和全局执行上下文，可以访问它们中定义的变量、函数等等。\n理解全局执行上下文和函数执行上下文的概念对于理解 JavaScript 的作用域、闭包、作用域链等概念非常重要。同时，在编写 JavaScript 代码时，需要注意避免出现变量命名冲突等问题，以确保执行上下文能够正常工作。\nEvent Loop 在浏览器与 node 环境中的区别：浏览器环境每次执行一个宏任务，再去检查微任务node 会清空当前所处阶段的队列，即执行所有 task，再去检查微任务\n浏览器环境 事例事例 1&lt;script&gt;\n    function a() &#123;\n        console.log(&quot;a&quot;)\n        b();\n    &#125;\n\n    function b() &#123;\n        console.log(&quot;b&quot;);\n        c();\n    &#125;\n\n    function c() &#123;\n        console.log(&quot;c&quot;)\n    &#125;\n\n    console.log(&quot;global&quot;);\n    a();\n&lt;&#x2F;script&gt;\n\n\n事例 2console.log(1);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(2);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(3);\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(4);\n    &#125;, 0);\n  &#125;, 0);\n&#125;, 0);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(5);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(6);\n  &#125;, 0);\n&#125;, 0);\n\nconsole.log(&#39;ok&#39;);\n\n事例 3console.log(1);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;setTimeout&#39;);\n&#125;, 0);\n\nlet promise &#x3D; new Promise((resolve) &#x3D;&gt; &#123;\n  console.log(3);\n  resolve();\n&#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(100);\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(200);\n  &#125;);\n\nconsole.log(2);\n\n参考链接Event Loop 这个循环你晓得么？(附 GIF 详解)\n[回顾]事件循环机制 (Event-loop)\n","slug":"2022-07-29js-eventloop","date":"2022-07-29T10:04:52.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"c29bc77697ff47f9bbee179892d7fe85","title":"前端基础-js 闭包","content":"思维导图\n\n闭包一个函数 和 对其周围状态（lexical environment，词法环境）的引用, 捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）\n\n闭包让你可以在一个内层函数中 访问到 其外层函数的作用域。\n在形式上体现为函数嵌套，内层函数有外层函数的变量引用\n在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n词法环境\n\n\n\n\n\n\n\n\nA Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.翻译：词法环境： 是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个环境记录项和可能为空的外部词法环境引用构成\n词法环境是: 由内部 JavaScript 引擎构造，用来保存标识符和变量&#x2F;函数的映射关系，同时，保存了对父级（词法环境- 标识符与变量映射）的引用。\n\n标识符 ： 指变量或者函数的名称\n变量：对 实际对象（包括函数类型对象）或者原始值的引用\n\n词法环境组成：\n\n环境记录：存储变量和函数声明的实际位置\n对外引用：实际上就是对外部或者说是父级词法环境的引用\n\n作用域MDN:在当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。如果一个变量或者其他表达式不 “在当前的作用域中”，那么它就是不可用的。作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。\n作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。\n作用域链JavaScript 在执⾏过程中, 会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了作⽤域链。\n可执行上下文当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。那么因此执行上下文对应也有三种：全局执行上下文，函数执行上下文，eval 执行上下文。\n可执行代码ECMAScript 可执行代码分为三种类型：全局代码，函数代码，eval 代码。\n可执行上下文栈\n\n词法作用域分析器如何在函数嵌套的情况下解析变量名\n总结\n\n\n\n闭包作用\n用闭包模拟私有方法\n数据缓存\n\n闭包性能\n如果不是某些特定任务, 需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。\n\n例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。\n示例：\nfunction MyObject(name, message) &#123;\n  this.name &#x3D; name.toString();\n  this.message &#x3D; message.toString();\n  this.getName &#x3D; function () &#123;\n    return this.name;\n  &#125;;\n\n  this.getMessage &#x3D; function () &#123;\n    return this.message;\n  &#125;;\n&#125;\n\n可改成如下例子：\nfunction MyObject(name, message) &#123;\n  this.name &#x3D; name.toString();\n  this.message &#x3D; message.toString();\n&#125;\nMyObject.prototype.getName &#x3D; function () &#123;\n  return this.name;\n&#125;;\nMyObject.prototype.getMessage &#x3D; function () &#123;\n  return this.message;\n&#125;;\n\n参考链接词法环境是什么？\n词法作用域\n可执行代码与执行上下文\nScope（作用域）\n","slug":"2022-07-28js-closures","date":"2022-07-28T10:04:36.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"d7bd88002098c0649a55dcb4db29ef28","title":"前端基础-js 函数","content":"思维导图\n\n\narguments\n\n\n\n\n\n\n\n\narguments 对象不是一个 Array 。它类似于 Array，但除了 length 属性和索引元素之外没有任何 Array 属性\n使用数组方法&#x2F;&#x2F; Array.prototype.slice.call\nfunction myConcat(separator) &#123;\n  var args &#x3D; Array.prototype.slice.call(arguments, 1);\n  return args.join(separator);\n&#125;\n\n转化成真实数组可以使用Array.from()方法或扩展运算符将参数转换为真实数组：\nvar args &#x3D; Array.from(arguments);\nvar args &#x3D; [...arguments];\n\n参数影响严格模式下， 无影响在严格模式下，剩余参数、默认参数和解构赋值参数的存在, 不会改变 arguments 对象的行为, 不跟踪。示例 1\n&quot;use strict&quot;;\nfunction func(a) &#123;\n  arguments[0] &#x3D; 34;\n\n  console.log(a); &#x2F;&#x2F; 1\n  console.log(arguments[0]); &#x2F;&#x2F; 34\n&#125;\n\nfunc(1);\n\n示例 2\n&quot;use strict&quot;;\n\nfunction func(a &#x3D; 2) &#123;\n  arguments[0] &#x3D; 34;\n\n  console.log(arguments[0]); &#x2F;&#x2F;34\n  console.log(a); &#x2F;&#x2F; 3\n&#125;\n\nfunc(3);\n\n非严格模式，没有…，跟踪非严格模式中, 函数 没有包含 剩余参数、默认参数、解构赋值， arguments 对象中的值会跟踪参数的值\n示例 1:\nfunction func(a) &#123;\n  arguments[0] &#x3D; 99; &#x2F;&#x2F; 更新了 arguments[0] 同样更新了 a\n  console.log(a); &#x2F;&#x2F; 99\n  console.log(arguments[0]); &#x2F;&#x2F; 9\n&#125;\nfunc(10);\n\n示例 2:\nfunction func(a) &#123;\n  a &#x3D; 99; &#x2F;&#x2F; 更新了 a 同样更新了 arguments[0]\n  console.log(a); &#x2F;&#x2F; 99\n  console.log(arguments[0]); &#x2F;&#x2F; 99\n&#125;\nfunc(10);\n\n非严格模式，有…，不跟踪当非严格模式中的函数, 有包含 剩余参数、默认参数、解构赋值， arguments 对象中的值不会跟踪参数的值\n示例 1:\nfunction func(a &#x3D; 55) &#123;\n  arguments[0] &#x3D; 99; &#x2F;&#x2F; updating arguments[0] does not also update a\n  console.log(a); &#x2F;&#x2F; 10\n  console.log(arguments[0]); &#x2F;&#x2F; 99\n&#125;\nfunc(10);\n\n示例 2:\nfunction func(a &#x3D; 55) &#123;\n  a &#x3D; 99; &#x2F;&#x2F; updating a does not also update arguments[0]\n  console.log(a); &#x2F;&#x2F; 99\n  console.log(arguments[0]); &#x2F;&#x2F; 10\n&#125;\nfunc(10);\n\n示例 3:\nfunction func(a &#x3D; 55) &#123;\n  console.log(a); &#x2F;&#x2F; 55\n  console.log(arguments[0]); &#x2F;&#x2F; undefined\n&#125;\nfunc();\n\nuse strict\n\n\n\n\n\n\n\n\n\n消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;\n消除代码运行的一些不安全之处，保证代码运行的安全；\n提高编译器效率，增加运行速度；\n为未来新版本的 Javascript 做好铺垫。\n\n箭头函数箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 this，arguments，super, new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。解析顺序也有区别。\n箭头函数与普通函数区别\n语法比函数表达式更简洁\n没有自己的 this，arguments，super, new.target\n不能用 new 操作符号\n不能用作构造函数\n不能用 yield\n无 prototype 属性\n解析顺序也有区别\n\n基础语法&#x2F;&#x2F; 多参数\n(param1, param2, …, paramN) &#x3D;&gt; &#123; statements &#125;\n\n(param1, param2, …, paramN) &#x3D;&gt; expression\n&#x2F;&#x2F;相当于：(param1, param2, …, paramN) &#x3D;&gt;&#123; return expression; &#125;\n\n\n&#x2F;&#x2F; 单参数\n\n&#x2F;&#x2F; 当只有一个参数时，圆括号是可选的：\n(singleParam) &#x3D;&gt; &#123; statements &#125;\nsingleParam &#x3D;&gt; &#123; statements &#125;\n\n&#x2F;&#x2F; 无参数\n\n&#x2F;&#x2F; 没有参数的函数应该写成一对圆括号。\n() &#x3D;&gt; &#123; statements &#125;\n\n\n高级语法&#x2F;&#x2F;加括号的函数体, 返回对象字面量表达式：\nparams &#x3D;&gt; (&#123;foo: bar&#125;) &#x2F;&#x2F; 返回 &#123;foo: bar&#125;， 不加 () 函数默认返回undefine\n\n&#x2F;&#x2F;支持剩余参数、默认参数\n(param1, param2, ...rest) &#x3D;&gt; &#123; statements &#125;\n(param1 &#x3D; defaultValue1, param2, …, paramN &#x3D; defaultValueN) &#x3D;&gt; &#123;statements &#125;\n\n&#x2F;&#x2F;同样支持参数列表解构\nlet f &#x3D; ([a, b] &#x3D; [1, 2], &#123;x: c&#125; &#x3D; &#123;x: a + b&#125;) &#x3D;&gt; a + b + c;\nf();  &#x2F;&#x2F; 6\n\n没有单独的 this在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：\n\n如果该函数是一个构造函数，this 指针指向一个新的对象\n在严格模式下的函数调用下，this 指向 undefined\n如果该函数是一个对象的方法，则它的 this 指针指向这个对象\n等等\n\n不受限严格模式的 this 规则鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。\n箭头函数中 this 是语法层面的\nvar f &#x3D; () &#x3D;&gt; &#123;\n  &quot;use strict&quot;;\n  return this;\n&#125;;\nf() &#x3D;&#x3D;&#x3D; window; &#x2F;&#x2F; 或者 global\n\n通过 call 或 apply 调用由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this—译者注），他们的第一个参数会被忽略。（这种现象对于 bind 方法同样成立 — 译者注）\n不绑定 arguments箭头函数不绑定 Arguments 对象。\n可以使用剩余参数\n使用箭头函数作为方法&quot;use strict&quot;;\nvar obj &#x3D; &#123;\n  i: 10,\n  b: () &#x3D;&gt; console.log(this.i, this), &#x2F;&#x2F; 并不指向对象\n  c: function () &#123;\n    console.log(this.i, this);\n  &#125;,\n&#125;;\nobj.b();\n&#x2F;&#x2F; undefined, Window&#123;...&#125;\nobj.c();\n&#x2F;&#x2F; 10, Object &#123;...&#125;\n\nObject.defineProperty&quot;use strict&quot;;\nvar obj &#x3D; &#123;\n  a: 10,\n&#125;;\n\nObject.defineProperty(obj, &quot;b&quot;, &#123;\n  get: () &#x3D;&gt; &#123;\n    console.log(this.a, typeof this.a, this);\n    return this.a + 10;\n    &#x2F;&#x2F; 代表全局对象 &#39;Window&#39;, 因此 &#39;this.a&#39; 返回 &#39;undefined&#39;\n  &#125;,\n&#125;);\n\nobj.b; &#x2F;&#x2F; undefined   &quot;undefined&quot;   Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;\n\n使用 new 操作符箭头函数不能用作构造器，和 new 一起用会抛出错误。\nvar Foo &#x3D; () &#x3D;&gt; &#123;&#125;;\nvar foo &#x3D; new Foo(); &#x2F;&#x2F; TypeError: Foo is not a constructor\n\n使用 prototype 属性箭头函数没有 prototype 属性。\nvar Foo &#x3D; () &#x3D;&gt; &#123;&#125;;\nconsole.log(Foo.prototype); &#x2F;&#x2F; undefined\n\n使用 yield 关键字yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。\n函数体箭头函数可以有一个“简写体”或常见的“块体”。\nvar func &#x3D; (x) &#x3D;&gt; x * x;\n&#x2F;&#x2F; 简写函数 省略 return\n\nvar func &#x3D; (x, y) &#x3D;&gt; &#123;\n  return x + y;\n&#125;;\n&#x2F;&#x2F;常规编写 明确的返回值\n\n返回对象字面量var func &#x3D; () &#x3D;&gt; &#123; foo: 1 &#125;;\n&#x2F;&#x2F; Calling func() returns undefined!\n\nvar func &#x3D; () &#x3D;&gt; &#123; foo: function() &#123;&#125; &#125;;\n&#x2F;&#x2F; SyntaxError: function statement requires a name\n\n\n花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。\nvar func &#x3D; () &#x3D;&gt; (&#123; foo: 1 &#125;);\n\n注意换行幸运的是：vscode Prettier - Code formatter 插件，自动格式化代码\n箭头函数在参数和箭头之间不能换行。\nvar func &#x3D; ()\n           &#x3D;&gt; 1;\n&#x2F;&#x2F; SyntaxError: expected expression, got &#39;&#x3D;&gt;&#39;\n\n可以通过在 ‘&#x3D;&gt;’ 之后换行，或者用 ‘( )’、’{ }’来实现换行，如下：\nvar func &#x3D; (a, b, c) &#x3D;&gt;\n  1;\n\nvar func &#x3D; (a, b, c) &#x3D;&gt; (\n  1\n);\n\nvar func &#x3D; (a, b, c) &#x3D;&gt; &#123;\n  return 1\n&#125;;\n\nvar func &#x3D; (\n  a,\n  b,\n  c\n) &#x3D;&gt; 1;\n\n&#x2F;&#x2F; 不会有语法错误\n\n\n不同于普通函数的解析顺序let callback;\n\ncallback &#x3D; callback || function() &#123;&#125;; &#x2F;&#x2F; ok\n\ncallback &#x3D; callback || () &#x3D;&gt; &#123;&#125;;\n&#x2F;&#x2F; SyntaxError: invalid arrow-function arguments\n\ncallback &#x3D; callback || (() &#x3D;&gt; &#123;&#125;);    &#x2F;&#x2F; ok\n\n箭头函数可以使用条件（三元）运算符箭头函数可以使用闭包参考链接Web 开发技术&#x2F;JavaScript&#x2F;JavaScript 参考&#x2F;函数&#x2F;arguments 对象\nJavascript 严格模式详解\nWeb 开发技术&#x2F;JavaScript&#x2F;JavaScript 参考&#x2F;函数&#x2F;箭头函数\n","slug":"2022-07-28js-fun","date":"2022-07-28T03:13:15.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"0ba6682e606bc81869a1a00491028270","title":"前端基础-性能优化2","content":"为什么速度很重要\n用户要求变高，爱挑毛病\n性能是留住用户的关键\n性能意味着提高转化率\n性能关乎用户体验\n性能影响人们\n\n\n查看更多\n消费者越来越依赖移动设备来访问数字内容和服务，如果您查看自己站点的分析，可能会看到这个故事正在您自己的数据中上演。消费者也比以往任何时候都要求更高，当他们权衡您网站上的体验时，他们不仅仅将您与您的竞争对手进行比较，他们还会根据他们每天使用的一流服务对您进行评级。\n性能是留住用户的关键\n性能直接影响公司的命运. 性能在任何在线企业的成功中都起着至关重要的作用。高性能网站比低性能网站更能吸引和留住用户。\n研究还表明，性能不佳会对业务目标产生负面影响。例如，\n\nPinterest 将感知等待时间减少了 40%，这将搜索引擎流量和注册量增加了 15% 。\nCOOK 将页面平均加载时间减少了 850 毫秒，从而将转化次数提高了 7%，将跳出率降低了 7%，并将每个会话的页面增加了 10% 。\nBBC 发现他们的网站加载时间每增加一秒，他们就会失去 10% 的用户。\n\n性能意味着提高转化率\n留住用户对于提高转化率至关重要。慢速网站对收入有负面影响，而快速网站显示可以提高转化率。\n例如：\n\n对于 Mobify 而言，主页加载速度每提高 100 毫秒，基于会话的转化率就会增加 1.11%，平均年收入增加近 380,000 美元。此外，结账页面加载速度每提高 100 毫秒，基于会话的转化率就会增加 1.55%，从而使年均收入增加近 530,000 美元。\n\n当 AutoAnything 将页面加载时间减少一半时，他们的销售额增长了 12% 到 13%。\n\n零售商 Furniture Village 审核了他们的网站速度，并制定了解决他们发现的问题的计划，导致页面加载时间降低了 20%，转化率提高了 10%。\n\n\n性能关乎用户体验\n性能是良好用户体验的基础。当网站发布大量代码时，浏览器必须使用用户数以百万计的数据计算才能下载代码。移动设备的 CPU 能力和内存有限。它们经常被我们认为所谓的“少量”未优化的代码所淹没。这会导致性能不佳，从而导致无响应。了解我们人类的行为后就会知道，用户只有对低性能的应用程序忍无可忍时才会选择放弃。\n性能影响人们\n性能不佳的网站和应用程序也会给使用它们的人们带来实际成本\n随着移动用户继续在全球互联网用户中占据更大比例，请务必记住，其中许多用户通过移动 LTE、4G、3G 甚至 2G 网络访问互联网。正如 Calibre 的 Ben Schwarz 在关于现实世界性能的研究中指出的那样，预付费数据计划的成本正在下降，这反过来又使得过去无法负担的地方开始有能力访问互联网。移动设备和互联网接入不再是奢侈品。它们是日益互联的世界中导航和发挥作用所必需的常用工具。\n至少自 2011 年以来，总页面大小一直在稳步增加，而且这种趋势似乎还在继续。随着典型页面发送更多数据，用户必须更频繁地补充他们的计量数据计划，这会花费他们的资金。\n除了为用户节省资金外，快速和轻量级的用户体验对于处于危机中的用户也至关重要。医院、诊所和危机中心等公共资源拥有在线资源，可为用户提供他们在危机期间所需的重要和具体信息。虽然设计对于在压力时刻有效地呈现重要信息至关重要，但不能低估快速传递这些信息的重要性。这是我们工作的一部分。\n\n性能优化基础最佳实践（个人觉得按照performance API 来聊性能优化更贴切）\n\n从学习浏览器的 关键渲染路径(CRP- Critical rendering path) 开始。了解这些会帮助你通晓如何提升浏览器的性能。\n使用 资源提示（resource hints） 例如 （预连接、预获取、预加载） rel=preconnect, rel=dns-prefetch, rel=prefetch, and rel=preload\n压缩 Js 代码至最小。只为当前页面加载需要使用到的 js 代码\nCSS 性能因素\n在你的服务器（或者 CDN）上使用 HTTP/2 协议\n使用 CDN 托管静态资源，这样可以显著减少加载时间\n使用 gzip, Brotli 或者 Zopfli 压缩您的资源\n图片优化（如果可以，尽可能使用 css 动画或者 svg）\n在超出应用视口范围的部分使用懒加载，如果你这么做了，为 SEO 制定一个后备计划（例如为 bot traffic 渲染整个页面）\n\nCSS 性能优化\n阻塞渲染优化\n\n在 GPU 上呈现动画\n\nwill-change 属性\n\nfont-display 属性\n\ncontain 属性\n\n\n\n\n\n\n\n\n\n\n\n页面在样式没有渲染完毕的情况下被绘制，在样式渲染完毕后又被刷新，这大概是很糟糕的用户体验 FOUC - Flash Of Unstyled Content 文档样式闪烁。因此，除非浏览器知道当前不需要 该 CSS，否则 该 CSS 将阻止渲染。浏览器只会在下载 CSS 和构建 CSSOM 之后绘制页面。浏览器遵循特定的渲染路径：绘制 paint 仅在布局 layout 之后进行，布局 layout 则在创建渲染树 render tree 之后进行，创建渲染树则需要在 DOM 和 CSSOM 树解析完成后进行。\n浏览器遵循特定的渲染路径\n\n下载 CSS\nDOM 和 CSSOM 树解析完成\n创建渲染树 render tree\n布局 layout\n绘制 paint\n\n优化方向\n为了优化 CSSOM 的构造，请删除不必要的样式，对 CSS 进行最小化，压缩和缓存，并将页面加载时不需要的 CSS 拆分为其他文件，以减少 CSS 渲染阻塞。\n阻塞渲染优化CSS 可以使用媒体查询将样式应用在特定条件下。媒体查询对于响应式 Web 设计非常重要，可以帮助我们优化关键渲染路径。浏览器会阻塞渲染，直到它解析完全部的样式，但不会阻塞渲染它认为不会使用的样式，例如打印样式表。通过基于媒体查询将 CSS 分成多个文件，可以防止在下载未使用的 CSS 期间阻止渲染。为了创建非阻塞 CSS 链接，将不会立即使用的样式（例如打印样式）移动到单独的文件中，将  添加到 HTML 中，并添加媒体查询，在这种情况下说明它是打印样式表。\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;styles.css&quot; &#x2F;&gt;\n&lt;!-- blocking --&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;print.css&quot; media&#x3D;&quot;print&quot; &#x2F;&gt;\n&lt;!-- not blocking --&gt;\n&lt;link\n  rel&#x3D;&quot;stylesheet&quot;\n  href&#x3D;&quot;mobile.css&quot;\n  media&#x3D;&quot;screen and (max-width: 480px)&quot;\n&#x2F;&gt;\n&lt;!-- not blocking on large screens --&gt;\n\n默认情况下，浏览器假设每个指定的样式表都是阻塞渲染的。通过添加 media 属性附加媒体查询，告诉浏览器何时应用样式表。当浏览器看到一个它知道只会用于特定场景的样式表时，它仍会下载样式，但不会阻塞渲染。通过将 CSS 分成多个文件，主要的 阻塞渲染 文件（本例中为 styles.css）的大小变得更小，从而减少了渲染被阻塞的时间。\n在 GPU 上呈现动画浏览器针对处理 CSS 动画和不会很好地触发重排（因此也导致重新绘制）的动画属性进行了优化。为了提高性能，可以将被动画化的节点从主线程移到 GPU 上。将导致合成的属性包括 3D transforms (transform: translateZ(), rotate3d()，etc.)，animating transform 和 opacity, position: fixed，will-change，和 filter。一些元素，例如 &lt;video&gt;, &lt;canvas&gt; 和 &lt;iframe&gt;，也位于各自的图层上。 将元素提升为图层（也称为合成）时，动画转换属性将在 GPU 中完成，从而改善性能，尤其是在移动设备上。\n额～，怎么看像与“层叠上下文”有关呢， 7 阶层叠 ？ 见\nwill-change 属性CSS will-change 属性告诉浏览器元素的哪些属性需要修改，使浏览器能够在元素实际更改之前设置优化，通过在实际更改前执行耗时的工作以提升性能。\nwill-change: opacity, transform;\n\n与“层叠上下文”有关\nfont-display 属性根据 @font-face 规则，font-display 属性定义了浏览器如何加载和显示字体文件，允许文本在字体加载或加载失败时显示回退字体。可以通过依靠折中无样式文本闪现使文本可见替代白屏来提高性能。\n@font-face &#123;\n  font-family: someFont;\n  src: url(&#x2F;path&#x2F;to&#x2F;fonts&#x2F;someFont.woff) format(&quot;woff&quot;);\n  font-weight: 400;\n  font-style: normal;\n  font-display: fallback; &#x2F;&#x2F; 回滚\n&#125;\n\ncontain 属性CSS 的 contain 属性允许作者指示元素及其内容尽可能独立于文档树的其余部分。这允许浏览器针对 DOM 的有限区域而不是整个页面重新计算布局，样式，绘画，大小或它们的任意组合。\n伪元素\n性能衡量前端基础-性能优化 1\n参考链接火狐家的 MDN CSS 性能优化\ngoogle 家的 web.dev why-speed-matters\n(十三) 性能优化 CRP \n什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？\n","slug":"2022-07-27性能优化","date":"2022-07-27T05:55:15.000Z","categories_index":"前端基础","tags_index":"前端基础,performance","author_index":"举手摘月亮"},{"id":"28bb441cd50232946d7be5a33559cd7e","title":"前端基础-http 连接管理","content":"HTTP&#x2F;1.x 的连接管理\n\n短连接\nHTTP&#x2F;1.0 默认是短连接(冷连接),每一个 HTTP 请求都由它自己独立的连接完成,\nTCP 协议握手耗费时间,TCP 可以保持更多的热连接来适应负载\n\n\n查看更多\nHTTP 最早期的模型，也是 HTTP&#x2F;1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。\nTCP 协议握手本身就是耗费时间的，所以 TCP 可以保持更多的热连接来适应负载。短连接破坏了 TCP 具备的能力，新的冷连接降低了其性能。\n这是 HTTP&#x2F;1.0 的默认模型 (如果没有指定 Connection 协议头，或者是值被设置为 close)。而在 HTTP&#x2F;1.1 中，只有当 Connection 被设置为 close 时才会用到这个模型。\n\n\n\n\n\n\n\nTIP\n除非是要兼容一个非常古老的，不支持长连接的系统，没有一个令人信服的理由继续使用这个模型。\n\n长连接优点：\n解决短连接的两个比较大的问题：\n\n创建新连接耗费的时间尤为明显，\nTCP 连接的性能只有在该连接被使用一段时间后 (热连接) 才能得到改善。\n\n缺点\n\n空闲状态，它还是会消耗服务器资源，\n在重负载时，还有可能遭受 DoS attacks 攻击。\n\n\n查看更多\n为了缓解这些问题，长连接 的概念便被设计出来了，甚至在 HTTP&#x2F;1.1 之前。或者这被称之为一个 keep-alive 连接。\n优点\n一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭 (服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。\n缺点\n长连接也还是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 DoS attacks 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。\nHTTP&#x2F;1.0 里默认并不使用长连接。把 Connection 设置成 close 以外的其它参数都可以让其保持长连接，通常会设置为 retry-after。(TODO:没懂)\n\n\n\n\n\n\n\n\n\nWARNING\n在 HTTP&#x2F;1.1 里，默认就是长连接的，协议头都不用再去声明它 (但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP&#x2F;1.0 呢)\n\n\n流水线\n\n\n\n\n\nTIP\n流水线已经被更好的算法给代替，如 multiplexing 多路复用，已经用在 HTTP&#x2F;2\n\n\n同一条长连接上发出连续的请求，不用等待应答返回\n打包成消息包提升性能\n幂等请求支持流水线\n浏览器默认关闭\n\n\n查看更多\n默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。\n流水线是 在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟 。\n打包成消息包提升性能\n理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续，尺寸会增加，但设置 TCP 的 MSS(Maximum Segment Size) 选项，仍然足够包含一系列简单的请求。\n幂等 请求支持流水线并不是所有类型的 HTTP 请求都能用到流水线：只有 idempotent(幂等) 方式，比如 GET、HEAD、PUT 和 DELETE 能够被安全的重试：如果有故障发生时，流水线的内容要能被轻易的重试。\n浏览器默认关闭今天，所有遵循 HTTP&#x2F;1.1 的代理和服务器都应该支持流水线，虽然实际情况中还是有很多限制：一个很重要的原因是，目前没有现代浏览器默认启用这个特性。\n\n域名分片\n\n\n\n\n\n\nWARNING\n除非你有紧急而迫切的需求，不要使用这一过时的技术，升级到 HTTP&#x2F;2 就好了。在 HTTP&#x2F;2 里，做域名分片就没必要了：HTTP&#x2F;2 的连接可以很好的处理并发的无优先级的请求。域名分片甚至会影响性能。大多数 HTTP&#x2F;2 的实现还会使用一种称作连接凝聚的技术去尝试合并被分片的域名。\n\n\n作为 HTTP/1.x 的连接，请求是序列化的，哪怕本来是无序的，在没有足够庞大可用的带宽时，也无从优化。\n一个解决方案是，浏览器为每个域名建立多个连接，以实现并发请求。\n如果服务器端想要更快速的响应网站或应用程序的应答，它可以迫使客户端建立更多的连接。\n\n曾经默认的连接数量为 2 到 3 个，现在比较常用的并发连接数已经增加到 6 条。如果尝试大于这个数字，就有触发服务器 DoS 保护的风险。\n例如，不要在同一个域名下获取所有资源，假设有个域名是 www.example.com，我们可以把它拆分成好几个域名：`www1.example.com`、`www2.example.com`、`www3.example.com`。所有这些域名都指向同一台服务器，浏览器会同时为每个域名建立 6 条连接 (在我们这个例子中，连接数会达到 18 条)。这一技术被称作域名分片。\n\n\nHTTP&#x2F;2见\n二进制分帧\n帧：HTTP&#x2F;2 数据通信的最⼩单位\n消息：指 HTTP&#x2F;2 中逻辑上的 HTTP 消息。例如: 请求和响应等，消息由⼀个或多个帧 组成。\n流：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数 ID\n采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议解析起来更⾼效。\n\n头部压缩压缩的原因HTTP&#x2F;1.x 会在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。\n压缩的原理\n\nHTTP&#x2F;2 在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，\n对于相同的数据，不再通过每次请求和响应发送\n⾸部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。\n你可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量\n\n\n\n服务器推送\n服务端可以在发送⻚⾯ HTML 时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。例如服务端 可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。\n服务端可以主动推送，客户端也有权利选择是否接收。\n如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送 RST_STREAM 帧来拒收。\n主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端\n\n多路复用出现的背景\nHTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制。\n如何解决\n\n同域名下所有通信都在单个连接上完成。\n单个连接可以承载任意数量的双向数据流。\n数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可以重新组装\n\nHTTP&#x2F;3HTTP/3是第三个主要版本的 HTTP 协议。与其前任 HTTP&#x2F;1.1 和 HTTP&#x2F;2 不同，在 HTTP&#x2F;3 中，将弃用TCP协议，改为使用基于UDP协议的QUIC协议实现。\n出现的背景\n此变化主要为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了多路复用，受到 TCP拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。\nQUIC（快速UDP网络连接）是一种实验性的网络传输协议，由 Google 开发，该协议旨在使网页传输更快。在 2018 年 10 月 28 日的邮件列表讨论中，互联网工程任务组（IETF） HTTP 和 QUIC 工作组主席 Mark Nottingham 提出了将 HTTP-over-QUIC 更名为 HTTP&#x2F;3 的正式请求，以“明确地将其标识为 HTTP 语义的另一个绑定……使人们理解它与 QUIC 的不同”，并在最终确定并发布草案后，将 QUIC 工作组继承到 HTTP 工作组。 在随后的几天讨论中，Mark Nottingham 的提议得到了 IETF 成员的接受，他们在 2018 年 11 月给出了官方批准，认可 HTTP-over-QUIC 成为 HTTP&#x2F;3。\n2019 年 9 月，HTTP&#x2F;3 支持已添加到 Cloudflare 和 Google Chrome（Canary build）。Firefox Nightly 在 2019 年秋季之后添加支持。\n2022 年 6 月 6 日，IETF 正式标准化 HTTP&#x2F;3 为 RFC9114。\nQUIC虽然 QUIC 的名称最初是“快速 UDP 互联网连接”（Fast UDP Internet Connection）的首字母缩写，但 IETF 指定的标准中 QUIC 并不是任何内容的缩写。QUIC 提高了目前使用 TCP 的面向连接的网络应用的性能。它通过使用用户数据报协议（UDP）在两个端点之间创建若干个多路连接来实现这一目标，其目的是为了在网络层淘汰 TCP，以满足许多应用的需求，因此该协议偶尔也会获得 “TCP&#x2F;2”的昵称。\nQUIC 与 HTTP&#x2F;2 的多路复用连接协同工作，允许多个数据流独立到达所有端点，因此不受涉及其他数据流的丢包影响。相反，HTTP&#x2F;2 创建在传输控制协议（TCP）上，如果任何一个 TCP 数据包延迟或丢失，所有多路数据流都会遭受队头阻塞延迟。\n\nQUIC 的次要目标包括降低连接和传输时延，以及每个方向的带宽估计以避免拥塞。\n将拥塞控制算法移到了两个端点的用户空间，而不是内核空间，据称这将使这些算法得到更快的改进。\n该协议还可以扩展前向纠错（FEC），以进一步提高预期错误时的性能，这被视为协议演进的下一步。\n\n介绍QUIC 旨在提供几乎等同于 TCP 连接的可靠性，但延迟大大减少。它主要通过两个理解 HTTP 流量的行为来实现这一点。\nTODO：没懂\n第一个变化是在连接创建期间大大减少开销。由于大多数 HTTP 连接都需要 TLS，因此 QUIC 使协商密钥和支持的协议成为初始握手过程的一部分。 当客户端打开连接时，服务器响应的数据包包括将来的数据包加密所需的数据。这消除了 TCP 上的先连接并通过附加数据包协商安全协议的需要。其他协议可以以相同的方式进行服务，并将多个步骤组合到一个请求中。 然后，这些数据既可用于初始设置中的后续请求，也可用于未来的请求。\nQUIC 流是单独控制的\nQUIC 使用 UDP 协议作为其基础，不包括丢失恢复。相反，每个 QUIC 流是单独控制的，并且在 QUIC 级别而不是 UDP 级别重传丢失的数据。这意味着如果在一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务。 这在提高易出错链路的性能方面非常有用，因为在大多数情况下 TCP 协议通知数据包丢失或损坏之前可能会收到大量的正常数据，但是在纠正错误之前其他的正常请求都会等待甚至重发。 QUIC 在修复单个流时可以自由处理其他数据，也就是说即使一个请求发生了错误也不会影响到其他的请求。\n每个数据包单独加密、单个握手过程\nQUIC 包括许多其他更普通的更改，这些更改也可以优化整体延迟和吞吐量。例如，每个数据包是单独加密的，因此加密数据时不需要等待部分数据包。 在 TCP 下通常不可能这样做，其中加密记录在字节流中，并且协议栈不知道该流中的更高层边界。这些可以由运行在更上层的协议进行协商，但 QUIC 旨在通过单个握手过程完成这些。\n提高网络切换期间的性能\nQUIC 的另一个目标是提高网络切换期间的性能，例如当移动设备的用户从 WiFi 热点切换到移动网络时发生的情况。 当这发生在 TCP 上时，一个冗长的过程开始了：每个现有连接一个接一个地超时，然后根据需要重新创建。期间存在较高延迟，因为新连接需要等待旧连接超时后才会创建。 为解决此问题，QUIC 包含一个连接标识符(是不是 MAC 地址？)，该标识符唯一地标识客户端与服务器之间的连接，而无论源 IP 地址是什么。这样只需发送一个包含此 ID 的数据包即可重新创建连接，因为即使用户的 IP 地址发生变化，原始连接 ID 仍然有效。\nQUIC 在应用程序空间中实现，而不是在操作系统内核中实现，容易扩展QUIC 在应用程序空间中实现，而不是在操作系统内核中实现。当数据在应用程序之间移动时，这通常会由于上下文切换而调用额外的开销。 但是在 QUIC 下协议栈旨在由单个应用程序使用，每个应用程序使用 QUIC 在 UDP 上托管自己的连接。最终差异可能非常小，因为整个 HTTP&#x2F;2 堆栈的大部分已经存在于应用程序（或更常见的库）中。 将剩余部分放在这些库中，基本上是纠错，对 HTTP&#x2F;2 堆栈的大小或整体复杂性几乎没有影响。\nQUIC 允许更容易地进行未来更改，因为它不需要更改内核就可以进行更新。 QUIC 的长期目标之一是添加前向纠错和改进的拥塞控制。\n关于从 TCP 迁移到 UDP 的一个问题是 TCP 被广泛采用，并且互联网基础设施中的许多中间设备被调整为 UDP 速率限制甚至阻止 UDP。 Google 进行了一些探索性实验来描述这一点，发现只有少数连接存在此问题。所以 Chromium 的网络堆栈同时打开 QUIC 和传统 TCP 连接，并在 QUIC 连接失败时以零延迟回退到 TCP 连接。\n流量控制注意：流量控制是 QUICK 实现的，UDP 并没有\n与大多数传输协议一样，QUIC 具有流量控制以保护接收端免受缓冲器 overflow 的影响。QUIC 是基于 UDP 传输，而 UDP 没有流量控制，因此 QUIC 实现了自己的流量控制机制。与 TCP 不同，QUIC 并非通过 ACK 回应目前接收到第几笔资料，而是通过 control frame 实现类似于 HTTP&#x2F;2 的基于信用的方案。\nHTTP 的发展历史先后经历了：\n\n万维网的发明\nHTTP&#x2F;0.9 - 单行协议\nHTTP&#x2F;1.0 - 构建可扩展性\nHTTP&#x2F;1.1 - 标准化的协议\n超过 15 年的发展（restful api、Server-send events、WebSocket、跨域资源共享 CORS、内容安全策略 CSP、隐私控制 DNT、X-Frame-Options）\nHTTP2 - 为了更优异的表现\nHTTP3 - 弃用 TCP 协议\n\n见\nX-Frame-OptionsX-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 &lt;frame&gt; 、&lt;iframe&gt;、&lt;embed&gt; 或者 &lt;object&gt; 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持攻击。\n\nX-Frame-Options: DENY\nX-Frame-Options: SAMEORIGIN\n\n见\n参考链接MDN HTTP 连接管理\n维基百科 QUIC\n维基百科 HTTP&#x2F;3\n","slug":"2022-07-26http-connect","date":"2022-07-26T13:53:35.000Z","categories_index":"前端基础","tags_index":"前端基础,面试,http","author_index":"举手摘月亮"},{"id":"ed5ec0392ecb18ec3bd3ba76435a94c5","title":"前端基础-http CORS","content":"思维导图 -->\n\n\n跨源资源共享（CORS）CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。\n存在的背景同源安全策略 默认阻止“跨域”获取资源。出于安全性(应对CSRF攻击)，浏览器限制脚本内发起的跨源 HTTP 请求。\n例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。\n\n\n作用跨源资源共享 (CORS)（或通俗地译为跨域资源共享）是一种基于 HTTP 头的机制, CORS 给了 web 服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。\n\n该机制通过允许服务器标示，除了它自己以外的其它 origin（域，协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。\n跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的”预检”请求。\n在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。\n\n跨源域资源共享（CORS）机制, 允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch）使用 CORS，以降低跨源 HTTP 请求所带来的风险。\n什么情况下需要 CORS？\nHTTP请求\nWeb字体\n使用 drawImage 将 Images&#x2F;video 画面绘制到 canvas。\n来自图像的 CSS 图形 见\nWebGL贴图\n\n功能概述\n跨源资源共享 新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。\n对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型 的 POST 请求），\n浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。\n服务器确认允许之后，才发起实际的 HTTP 请求。\n在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证 相关数据）。\n\n\n\n\n\n\n\n\nWARNING\nCORS 请求失败会产生错误，但是为了安全，在 JavaScript 代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。\n\nHTTP 访问控制场景简单请求某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch（其中定义了 CORS）规范。若请求 满足所有下述条件，则该请求可视为“简单请求”：\n\n使用下列方法之一：GET、HEAD、POST\n\n除了被用户代理自动设置的首部字段（例如 Connection，User-Agent）和在 Fetch 规范中定义为 禁用首部名称 的其他首部，允许人为设置 对 CORS 安全的首部字段集合Accept、Accept-Language、Content-Language、Content-Type（需要注意额外的限制）\n\nContent-Type 的值仅限于下列三者之一：text/plain、 multipart/form-data、application/x-www-form-urlencoded\n\n请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；（除了： XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问)\n\n请求中没有使用 ReadableStream 对象\n\n\n比如说，假如站点 https://foo.example 的网页应用想要访问 https://bar.other 的资源。foo.example 的网页中可能包含类似于下面的 JavaScript 代码：\nconst xhr &#x3D; new XMLHttpRequest();\nconst url &#x3D; &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;public-data&#x2F;&quot;;\n\nxhr.open(&quot;GET&quot;, url);\nxhr.onreadystatechange &#x3D; someHandler;\nxhr.send();\n\n客户端和服务器之间使用 CORS 首部字段来处理权限：\n以下是浏览器发送给服务器的请求报文：\n/resources/public-data/ HTTP/1.1Host: bar.other\nUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko&#x2F;20100101 Firefox&#x2F;71.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-us,en;q&#x3D;0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nOrigin: https:&#x2F;&#x2F;foo.example\n\n请求首部字段 Origin 表明该请求来源于 http://foo.example\nHTTP&#x2F;1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache&#x2F;2\nAccess-Control-Allow-Origin: *\nKeep-Alive: timeout&#x3D;2, max&#x3D;100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application&#x2F;xml\n\n[XML Data]\n\n本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被 任意 外域访问。\nAccess-Control-Allow-Origin: *\n\n使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。如果服务端仅允许来自 https://foo.example 的访问，该首部字段的内容如下：\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;foo.example\n\n\n\n\n\n\n\nTIP\n备注： 当响应的是附带身份凭证的请求时，服务端 必须 明确 Access-Control-Allow-Origin 的值，而不能使用通配符“*”。不过可以是$http_origin $http_XXX 这个格式是 nginx 取请求中 header 的 XXX 的值的\n\n预检请求\n与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\n&quot;预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n如下是一个需要执行预检请求的 HTTP 请求：预检是浏览器主动发起的，研发都不用做\n\nconst xhr &#x3D; new XMLHttpRequest();\nxhr.open(&quot;POST&quot;, &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;post-here&#x2F;&quot;);\nxhr.setRequestHeader(&quot;X-PINGOTHER&quot;, &quot;pingpong&quot;);\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;xml&quot;);\nxhr.onreadystatechange &#x3D; handler;\nxhr.send(&quot;&lt;person&gt;&lt;name&gt;Arun&lt;&#x2F;name&gt;&lt;&#x2F;person&gt;&quot;);\n\n上面的代码使用 POST 请求发送一个 XML 文档，该请求包含了一个自定义的请求首部字段（X-PINGOTHER: pingpong）。另外，该请求的 Content-Type 为 application/xml。因此，该请求需要首先发起“预检请求”。\n\n\n\n\n\n\n\n\nTIP\n备注： 如下所述，实际的 POST 请求不会携带 Access-Control-Request-* 首部，它们仅用于 OPTIONS 请求。\n\n\n下面是服务端和客户端完整的信息交互。首次交互是 预检请求&#x2F;响应：\nOPTIONS &#x2F;doc HTTP&#x2F;1.1 # 这里\nHost: bar.other\nUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko&#x2F;20100101 Firefox&#x2F;71.0\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\nAccept-Language: en-us,en;q&#x3D;0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nOrigin: https:&#x2F;&#x2F;foo.example # 这里\nAccess-Control-Request-Method: POST # 这里\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type # 这里\n\nHTTP&#x2F;1.1 204 No Content\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache&#x2F;2\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\nAccess-Control-Max-Age: 86400\nVary: Accept-Encoding, Origin\nKeep-Alive: timeout&#x3D;2, max&#x3D;100\nConnection: Keep-Alive\n\n浏览器检测到，从 JavaScript 中发起的请求需要被预检。从上面的报文中，我们看到，第 1~10 行发送了一个使用 OPTIONS 方法 的“预检请求”。OPTIONS 是 HTTP&#x2F;1.1 协议中定义的方法，用以从服务器获取更多信息。该方法不会对服务器资源产生影响。 预检请求中同时携带了下面两个首部字段：\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type # X-PINGOTHER 是自定义的\n\n首部字段 Access-Control-Request-Method 告知服务器，实际请求将使用 POST 方法。首部字段 Access-Control-Request-Headers 告知服务器，实际请求将携带两个自定义请求首部字段：X-PINGOTHER 与 Content-Type。服务器据此决定，该实际请求是否被允许。\n第 13-22 行为预检请求的响应，表明服务器将接受后续的实际请求。重点看第 16-19 行：\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\nAccess-Control-Max-Age: 86400\n\n服务器的响应携带了 Access-Control-Allow-Origin: https://foo.example，从而限制请求的源域。同时，携带的 Access-Control-Allow-Methods 表明服务器允许客户端使用 POST 和 GET 方法发起请求（与 Allow 响应首部类似，但其具有严格的访问控制）。\n首部字段 Access-Control-Allow-Headers 表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type。与 Access-Control-Allow-Methods 一样，Access-Control-Allow-Headers 的值为逗号分割的列表。\n最后，首部字段 Access-Control-Max-Age 表明该响应的有效时间为 86400 秒，也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。 请注意，浏览器自身维护了一个 最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。\n预检会拖慢速度类似要去看病，先预检台、挂号、分诊。。。对于“急诊的”咋整？\nAccess-Control-Max-Age整个上限，对于不同的浏览器上限要区别对待， 见\n附带身份凭证的请求\n\n\n\n\n\nTIP\n当发出跨源请求时，第三方 cookie 策略仍将适用。无论如何改变本章节中描述的服务器和客户端的设置，该策略都会强制执行\n\nXMLHttpRequest 或 Fetch 与 CORS 的一个有趣的特性是，可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。一般而言，对于跨源 XMLHttpRequest 或 Fetch 请求，浏览器 不会 发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。\n本例中，https://foo.example 的某脚本向 https://bar.other 发起一个 GET 请求，并设置 Cookies：\nconst invocation &#x3D; new XMLHttpRequest();\nconst url &#x3D; &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;credentialed-content&#x2F;&quot;;\n\nfunction callOtherDomain() &#123;\n  if (invocation) &#123;\n    invocation.open(&quot;GET&quot;, url, true);\n    invocation.withCredentials &#x3D; true; &#x2F;&#x2F; 这里\n    invocation.onreadystatechange &#x3D; handler;\n    invocation.send();\n  &#125;\n&#125;\n\n第 7 行将 XMLHttpRequest 的 withCredentials 标志设置为 true，从而向服务器发送 Cookies。因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”。但是，如果服务器端的响应中未携带 Access-Control-Allow-Credentials: true，浏览器将不会把响应内容返回给请求的发送者。\n\n\nCORS 预检请求不能包含凭据。预检请求的 响应 必须指定 Access-Control-Allow-Credentials: true 来表明可以携带凭据进行实际的请求。\n附带身份凭证的请求与通配符\n在响应附带身份凭证的请求时：\n\n服务器不能将 Access-Control-Allow-Origin 的值设为通配符“*”，而应将其设置为特定的域，如：Access-Control-Allow-Origin: https://example.com。\n服务器不能将 Access-Control-Allow-Headers的值设为通配符“*”，而应将其设置为首部名称的列表，如：Access-Control-Allow-Headers: X-PINGOTHER, Content-Type\n服务器不能将 Access-Control-Allow-Methods 的值设为通配符“*”，而应将其设置为特定请求方法名称的列表，如：Access-Control-Allow-Methods: POST, GET\n对于附带身份凭证的请求（通常是 Cookie），服务器不得设置 Access-Control-Allow-Origin 的值为“*”。\n\n这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为“*”，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 https://example.com，则请求将成功执行。另外，响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败(SameSite限制)，将会抛出异常。\n第三方 cookies\n在 CORS 响应中设置的 cookies 适用一般性第三方 cookie 策略, Cookie 策略受 SameSite 属性控制\nhttp 响应首部字段\nAccess-Control-Allow-Origin: &lt;origin&gt; | *, 对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符\nAccess-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*, 其指明了实际请求中允许携带的首部字段\nAccess-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*,其指明了实际请求中允许携带的首部字段\nAccess-Control-Allow-Credentials, 它指定了实际的请求是否可以使用 credentials\nAccess-Control-Max-Age: &lt;delta-seconds&gt;, 指定了 preflight 请求的结果能够被缓存多久\nAccess-Control-Expose-Headers , 让服务器把允许浏览器访问的头放入白名单\n\n\n查看更多\n本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。\nAccess-Control-Allow-Origin\n响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下：\nAccess-Control-Allow-Origin: &lt;origin&gt; | *\n\n其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。\n例如，下面的字段值将允许来自 https://mozilla.org 的请求：\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;mozilla.org\nVary: Origin\n\n_如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容_。\nAccess-Control-Expose-Headers译者注：在跨源访问时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到一些最基本的响应头，\n\nCache-Control、\nContent-Language、\nContent-Type、\nExpires、\nLast-Modified、\nPragma见 Access-Control-Expose-Headers如果要访问其他头，则需要服务器设置本响应头。\n\nAccess-Control-Expose-Headers 头, 让服务器把允许浏览器访问的头放入白名单，例如：\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\n\n这样浏览器就能够通过 getResponseHeader 访问 X-My-Custom-Header 和 X-Another-Custom-Header 响应头了。\nAccess-Control-Max-AgeAccess-Control-Max-Age 头指定了 preflight 请求的结果能够被缓存多久，请参考本文在前面提到的 preflight 例子。\nAccess-Control-Max-Age: &lt;delta-seconds&gt;\n\ndelta-seconds 参数表示 preflight 预检请求的结果在多少秒内有效。\n\n在 Firefox 中，上限是 24 小时 （即 86400 秒）。\n在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。\n从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。\nChromium 同时规定了一个默认值 5 秒。\n如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。见 Access-Control-Max-Age\n\nAccess-Control-Allow-CredentialsAccess-Control-Allow-Credentials 头指定了当浏览器的 credentials 设置为 true 时是否允许浏览器读取 response 的内容。当用在对 preflight 预检测请求的响应中时，它指定了实际的请求是否可以使用 credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。\nAccess-Control-Allow-Credentials: true\n\n上文已经讨论了附带身份凭证的请求。\nAccess-Control-Allow-MethodsAccess-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。\nAccess-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*\n\n有关 preflight request 的示例已在上方给出。\nAccess-Control-Allow-HeadersAccess-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。\nAccess-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*\n\n\n\nhttp 请求首部字段可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。\n\nOrigin 首部字段表明预检请求或实际请求的源站\nAccess-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。\nAccess-Control-Request-Headers 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。\n\nCORS 错误及处理见\n在 nestjs 中本地调试async function bootstrap() &#123;\n  const app &#x3D; await NestFactory.create&lt;NestExpressApplication&gt;(\n    ApplicationModule,\n  )\n  &#x2F;&#x2F; 允许跨域\n  app.enableCors(&#123;\n    origin: &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#39;,\n    credentials: true,\n  &#125;)\n\n\n正确结果\n\n去掉 credentials: true, 测试\n\napp.enableCors(&#123;\n  origin: &quot;http:&#x2F;&#x2F;127.0.0.1:5501&quot;,\n  &#x2F;&#x2F; credentials: true,\n&#125;);\n\n\n\n\n去掉 origin: &#39;http://127.0.0.1:5501&#39;, 测试\n\napp.enableCors(&#123;\n  &#x2F;&#x2F; origin: &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#39;,\n  credentials: true,\n&#125;);\n\n\n\n阿里云 COS 跨域配置\n\n\n\n参考链接Web 开发技术&gt;HTTP&gt;跨源资源共享（CORS）\nWeb 开发技术&gt;HTTP&gt;跨源资源共享（CORS）&gt;CORS errors\n","slug":"2022-07-26http-CORS","date":"2022-07-26T06:46:35.000Z","categories_index":"前端基础","tags_index":"前端基础,面试,http","author_index":"举手摘月亮"},{"id":"4afe9cca9efcce45bab52ea3fe738dfb","title":"React V17.0 候选版本：无新功能","content":"无新特性React 17 的版本是非比寻常的，因为它没有添加任何面向开发人员的新功能。而主要侧重于升级简化 React 本身。\n我们正在积极开发 React 的新功能，但它们并不属于此版本。React 17 是我们进行深度推广战略的关键所在。\n此版本之所以特殊，你可以认为 React 17 是 “垫脚石” 版本，它会使得由一个 React 版本管理的 tree 嵌入到另一个 React 版本管理的 tree 中时会更加安全。\n逐步升级在过去 7 年里，React 一直遵循 “all-or-nothing” 的升级策略。你可以继续使用旧版本，也可以将整个应用程序升级至新版本。但没有介于两者之间的情况。\n此方式持续至今，但是我们遇到了 “all-or-nothing” 升级策略的局限性。许多 API 的变更，例如，弃用旧版 context API 时，并不能以自动化的方式来完成。至今可能大多数应用程序从未使用过它们，但我们仍然选择在 React 中支持它们。我们必须在无限期支持过时的 API 或针对某些应用仍使用旧版本 React 间进行选择。但这两个方案都不合适。\n因此，我们想提供另一种方案。\nReact 17 开始支持逐步升级 React 版本。当从 React 15 升级至 16 时（或者从 React 16 升级至 17 时），通常会一次升级整个应用程序。这适用于大部分应用程序。但是，如果代码库是在几年前编写的，并且并没有得到很好的维护，那么升级它会变得越来越有挑战性。尽管可以在页面上使用两个版本的 React，但是直到 React 17 依旧有事件问题出现。\n我们使用 React 17 解决了许多诸如此类的问题。这将意味着当 React 18 或未来版本问世时，你将有更多选择。首选还是像以前一样，一次升级整个应用程序。但你也可以选择逐步升级你的应用程序。例如，你可能会将大部分应用程序迁移至 React 18，但在 React 17 上保留一些延迟加载的对话框或子路由。\n但这不意味着你必须逐步升级。对于大部分应用程序来说，一次全量升级仍是最好的解决方案。加载两个 React 版本，即使其中一个是按需延迟加载的，仍然不太理想。但是，对于没有积极维护的大型应用来说，可以考虑此种方案，并且 React 17 开始可以保证这些应用程序不落伍。\n为了实现逐步升级，我们需要对 React 事件系统进行一些更改。而这些更改可能会对代码产生影响，这也是 React 17 成为主要版本的原因。实际上，10 万个以上的组件中受影响的组件不超过 20 个，因此，我们希望大多数应用程序都可以升级到 React 17，而不会产生太多影响。如果你遇到问题，请联系我们。\n更改事件委托从技术上讲，始终可以在应用程序中嵌套不同版本的 React。但是，由于 React 事件系统的工作原理，这很难实现。\n在 React 组件中，通常会内联编写事件处理：\n&lt;button onClick&#x3D;&#123;handleClick&#125;&gt;\n\n\n与此代码等效的原生 DOM 操作如下：\nmyButton.addEventListener(&quot;click&quot;, handleClick);\n\n但是，对大多数事件来说，React 实际上并不会将它们附加到 DOM 节点上。相反，React 会直接在 document 节点上为每种事件类型附加一个处理器。这被称为事件委托。除了在大型应用程序上具有性能优势外，它还使添加类似于 replaying events 这样的新特性变得更加容易。\n自从其发布以来，React 一直自动进行事件委托。当 document 上触发 DOM 事件时，React 会找出调用的组件，然后 React 事件会在组件中向上 “冒泡”。但实际上，原生事件已经冒泡出了 document 级别，React 在其中安装了事件处理器。\n但是，这就是逐步升级的困难所在。\n如果页面上有多个 React 版本，他们都将在顶层注册事件处理器。这会破坏 e.stopPropagation()：如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本 React 嵌套变得困难重重。这种担忧并不是没有根据的 —— 例如，四年前 Atom 编辑器就遇到了相同的问题。\n这也是我们为什么要改变 React 底层附加事件方式的原因。\n在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中：\nconst rootNode &#x3D; document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App &#x2F;&gt;, rootNode);\n\n在 React 16 或更早版本中，React 会对大多数事件执行 document.addEventListener()。React 17 将会在底层调用 rootNode.addEventListener()。\n\n\n由于此更改，现在可以更加安全地进行新旧版本 React 树的嵌套。请注意，要使其正常工作，两个版本都必须为 17 或更高版本，这就是为什么强烈建议升级到 React 17 的根本原因。从某种意义上讲，React 17 是一个 “垫脚石” 版本，使逐步升级成为可能。\n此更改还使得将 React 嵌入使用其他技术构建的应用程序变得更加容易。例如，如果应用程序的“外壳”是用 jQuery 编写的，但其中较新的代码是用 React 编写的，则 React 代码中的 e.stopPropagation() 会阻止它影响 jQuery 的代码 —— 这符合预期。换个角度来说，如果你不再喜欢 React 并想重写应用程序（比如，用 jQuery），则可以从外壳开始将 React 转换为 jQuery，而不会破坏事件冒泡。\n经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，这些问题大多都与将 React 与非 React 代码集成有关。\n\n\n\n\n\n\n\nWARNING\n你可能想知道这是否会破坏根 DOM 容器之外的 Portals。答案是 React 还会监听 portals 容器上的事件，所以这不是问题。\n\n解决隐患\n与其他重大更改一样，可能需要对代码进行调整。在 Facebook，我们在成千上万个模块中，大约调整了 10 个模块以适应此更改。\n例如，如果模块中使用 document.addEventListener(...) 手动添加了 DOM 监听，你可能希望能捕获到所有 React 事件。在 React 16 或更早版本中，即使你在 React 事件处理器中调用 e.stopPropagation()，你创建的 DOM 监听仍会触发，这是因为原生事件已经处于 document 级别。使用 React 17 冒泡将被阻止（按需），因此你的 document 级别的事件监听不会触发：\ndocument.addEventListener(&quot;click&quot;, function () &#123;\n  &#x2F;&#x2F; This custom handler will no longer receive clicks\n  &#x2F;&#x2F; from React components that called e.stopPropagation()\n&#125;);\n\n你可以将监听转换为使用捕获来修复此类代码。为此，你可以将 &#123; capture: true &#125; 作为 document.addEventListener 的第三个参数传递：\ndocument.addEventListener(\n  &quot;click&quot;,\n  function () &#123;\n    &#x2F;&#x2F; Now this event handler uses the capture phase,\n    &#x2F;&#x2F; so it receives *all* click events below!\n  &#125;,\n  &#123; capture: true &#125;\n);\n\n请注意，此策略在全局上具有更好的适应性。例如，它可能会修复代码中现有的错误，这些错误在 React 事件处理器外部调用 e.stopPropagation() 发生。换句话说，React 17 的事件冒泡更接近常规 DOM。\n其他重大更改我们将 React 17 中的重大更改保持在最低水平。例如，它不会删除以前版本中弃用的任务方法。但是，它的确包含一些其他重大更改，根据经验，这些更改会相对安全。总体而言，由于这些因素的存在，在 10 万个以上的组件中受影响的组件不超过 20 个。\n对标浏览器我们对事件系统进行了一些较小的更改：\n\nonScroll 事件不再冒泡，以防止出现常见的混淆。\nReact 的 onFocus 和 onBlur 事件已在底层切换为原生的 focusin 和 focusout 事件。它们更接近 React 现有行为，有时还会提供额外的信息。\n捕获事件（例如，onClickCapture）现在使用的是实际浏览器中的捕获监听器。\n\n这些更改会使 React 与浏览器行为更接近，并提高了互操作性。\n\n\n\n\n\n\n\nWARNING\n注意：\n尽管 React 17 底层已将 onFocus 事件从 focus 切换为 focusin，但请注意，这并未影响冒泡行为。在 React 中，onFocus 事件总是冒泡的，在 React 17 中会继续保持，因为通常它是一个更有用的默认值\n\n去除事件池React 17 中移除了 “event pooling（事件池）“。它并不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水：\nfunction handleChange(e) &#123;\n  setData((data) &#x3D;&gt; (&#123;\n    ...data,\n    &#x2F;&#x2F; This crashes in React 16 and earlier:\n    text: e.target.value,\n  &#125;));\n&#125;\n\n这是因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。\n在 React 17 中，此代码可以按照预期效果执行。旧的事件池优化操作已被完成删除，因此，使用者可以在需要时读取事件字段。\n这改变了行为，因此我们将其标记为重大更改，但在实践中我们没有看到它在 Facebook 上造成影响。（甚至还修复了一些错误！）请注意，e.persist() 在 React 事件对象中仍然可用，只是无效果罢了。\n副作用清理时间我们将使 useEffect 和清理函数的时间保持一致。\nuseEffect(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; This is the effect itself.\n  return () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; This is its cleanup.\n  &#125;;\n&#125;);\n\n大多数副作用（effect）不需要延迟屏幕更新，因此 React 在屏幕上反映出更新后立即异步执行它们。（在极少数情况下，你需要一种副作用来阻止绘制，例如，如果需要获取尺寸和位置，请使用 useLayoutEffect。）\n然而，当组件被卸载时，副作用清理函数（类似于在 class 组件中同步调用 componentWillUnmount）同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。\n在 React 17 中，副作用清理函数总会异步执行 —— 如果要卸载组件，则清理会在屏幕更新后运行。\n这反映了副作用本身如何更紧密地运行。在极少数情况下，你可能希望依靠同步执行，可以改用 useLayoutEffect。\n\n\n\n\n\n\n\nWARNING\n注意\n你可能想知道这是否意味着你现在将无法修复有关未挂载组件上的 setState 的警告。不必担心，React 专门处理了这种情况，并且不会在卸载和清理之间短暂间隔内发出 setState 的警告。因此，取消代码的请求或间隔几乎总是可以保存不变的。\n\n\n此外，React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。React 16 只对组件内的 effect 保证这种顺序。\n隐患可复用的库可能需要对此情况进行深度测试，但我们只遇到了几个组件会因为这次改变出现问题。有问题的代码的其中一个示例如下所示：\nuseEffect(() &#x3D;&gt; &#123;\n  someRef.current.someSetupMethod();\n  return () &#x3D;&gt; &#123;\n    someRef.current.someCleanupMethod();\n  &#125;;\n&#125;);\n\n问题在于 someRef.current 是可变的，因此在运行清除函数时，它可能已经设置为 null。解决方案是在副作用内部存储会发生变化的值：\nuseEffect(() &#x3D;&gt; &#123;\n  const instance &#x3D; someRef.current;\n  instance.someSetupMethod();\n  return () &#x3D;&gt; &#123;\n    instance.someCleanupMethod();\n  &#125;;\n&#125;);\n\n我们不希望此问题对大家造成影响，我们提供了 eslint-plugin-react-hooks/exhaustive-deps 的 lint 规则（请确保在项目中使用它）会对此情况发出警告。\n返回一致的 undefined 错误在 React 16 及更早版本中，返回 undefined 始终是一个错误：\nfunction Button() &#123;\n  return; &#x2F;&#x2F; Error: Nothing was returned from render\n&#125;\n\n部分原因是这很容易无意间返回 undefined：\nfunction Button() &#123;\n  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.\n  &#x2F;&#x2F; React surfaces this as an error instead of ignoring it.\n  &lt;button &#x2F;&gt;;\n&#125;\n\n以前，React 只对 class 和函数组件执行此操作，但并不会检查 forwardRef 和 memo 组件的返回值。这是由于编码错误导致。\n在 React 17 中，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错\nlet Button &#x3D; forwardRef(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.\n  &#x2F;&#x2F; React 17 surfaces this as an error instead of ignoring it.\n  &lt;button &#x2F;&gt;;\n&#125;);\n\nlet Button &#x3D; memo(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.\n  &#x2F;&#x2F; React 17 surfaces this as an error instead of ignoring it.\n  &lt;button &#x2F;&gt;;\n&#125;);\n\n对于不想进行任何渲染的情况，请返回 null。\n原生组件栈当你在浏览器中遇到错误时，浏览器会为你提供带有 JavaScript 函数的名称及位置的调用栈信息。然而，JavaScript 调用栈通常不足以诊断问题，因为 React 树的层次结构可能同样重要。你不仅要知道哪个 Button 抛出了错误，而且还想知道 Button 在 React 树中的哪个位置。\n为了解决这个问题，当你遇到错误时，从 React 16 开始会打印 “组件栈” 信息。尽管如此，它们仍然不如原生的 JavaScript 调用栈。特别是，它们在控制台中不可点击，因为 React 不知道函数在源代码中的声明位置。此外，它们在生产中几乎无用。不同于常规压缩后的 JavaScript 调用栈，它们可以通过 sourcemap 的形式自动恢复到原始函数的位置，而使用 React 组件栈，在生产环境下必须在调用栈信息和 bundle 大小间进行选择。\n在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。\nReact 实现这一点的方式有点非常规。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。_因此，当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息。这会增加崩溃时的性能损失，但每个组件类型只会发生一次_。\n如果你对此感兴趣，可以在这个 PR 中阅读更多详细信息，但是在大多数情况下，这种机制不会影响你的代码。从使用者的角度来看，新功能就是可以单击组件调用栈（因为它们依赖于本机浏览器调用栈框架），并且可以像常规 JavaScript 错误那样在生产中进行解码。\n构成重大变化的部分是，要使此功能正常工作，React 将在捕获错误后在调用栈中重新执行上面某些函数和某些 class 构造函数的部分。由于渲染函数和 class 构造函数不应具有副作用（这对于 SSR 也很重要），因此这不会造成任何实际问题。\n移除私有导出最后，值得注意的重大变化时我们删除了一些以前暴露给其他项目的 React 内部组件。特别是，React Native for Web 过去常常依赖于事件系统的某些内部组件，但这种依赖关系很脆弱且经常被破坏。\n在 React 17 中，这些私有导出已被移除。据我们所知，React Native for Web 是唯一使用它们的项目，它们已经完成了向不依赖那些私有导出函数的其他方法迁移。\n这意味着旧版本的 React Native for Web 不会与 React 17 兼容，但是新版本可以使用它。实际上，并没有太大的变化，因为 React Native for Web 必须发布新版本以适应其内部 React 的变化。\n另外，我们删除了 ReactTestUtils.SimulateNative 的 helper 方法。他们从未被记录，没有按照他们名字所暗示的那样去做，也没有处理我们对事件系统所做的更改。如果你想要一种简便的方式来触发测试中原生浏览器的事件，请改用 React Testing Library。\n","slug":"2022-07-25React-v17","date":"2022-07-25T06:54:43.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"7914c7b61758cb63e0d9afa98b764a25","title":"React@16、17 杂货","content":"注意版本哈从前有座山之 react 源码解读之 ReactContext\nReact 源码解析————ReactContext.js,ReactLazy.js\nReact 的 React.createRef()&#x2F;forwardRef()源码解析(三)\nReact 的 React.createElement 源码解析(一)\nReact 源码解析(三) requestWork 之前的的准备工作\nreact 源码解析 7.Fiber 架构\n前后版本差异expirationTimeexpirationTime 越小优先级越高，而现在是 expirationTime 越大优先级越高\nReact16 与 17 版本合成事件的区别\nreact16 时事件委托的对象是 document，react17 时事件委托的对象是容器组件\nreact16 时原生事件与 react 事件执行时，冒泡阶段与捕获阶段没有区分开（捕获-&gt; 冒泡 -&gt; 捕获）；\nreact17 时优化了合成事件的执行，当与原生事件一起调用时，捕获阶段总是先于冒泡阶段（捕获 -&gt; 冒泡）\nreact17 废弃了事件池\n\n\n\n更改事件委托从技术上讲，始终可以在应用程序中嵌套不同版本的 React。但是，由于 React 事件系统的工作原理，这很难实现。\n自从其发布以来，React 一直自动进行事件委托。当 document 上触发 DOM 事件时，React 会找出调用的组件，然后 React 事件会在组件中向上 “冒泡”。但实际上，原生事件已经冒泡出了 document 级别，React 在其中安装了事件处理器。\n但是，这就是逐步升级的困难所在。\n如果页面上有多个 React 版本，他们都将在顶层注册事件处理器。这会破坏 e.stopPropagation()：如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本 React 嵌套变得困难重重。这种担忧并不是没有根据的 —— 例如，四年前 Atom 编辑器就遇到了相同的问题。\n基于此： 在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中：\nconst rootNode &#x3D; document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App &#x2F;&gt;, rootNode);\n\n在 React 16 或更早版本中，React 会对大多数事件执行 document.addEventListener()。React 17 将会在底层调用 rootNode.addEventListener()。\nHooks 的实现原理React 会维护俩个链表，一个是 currentHook，另外一个是 WorkInProgressHook,每一个节点类型都是 Hooks，每当 hooks 函数被调用，react 就会创建一个 hooks 对象，并挂在链表的尾部，函数组件之所以能做一些类组件不能做的事儿，就是因为 hook 对象，函数组件的状态，计算值，缓存等都是交给 hook 去完成的，这样组件通过 Fiber.memoizedState 属性指向 hook 链表的头部来关联 hook 对象和当前组件，这样就发挥了 hooks 的作用。每次调用 hooks API 的时候，就会首先调用 createWorkInProgressHook 函数。得到 hooks 的串联不是一个数组，而是一个链式结构，从根节点 workInProgressHook 向下通过 next 进行串联，这也是为什么 Hooks 不能嵌套使用，不能在条件判断中使用，不能在循环中使用，否则链式就会被破坏。\n\n\ncreateSyntheticEvent 源码function createSyntheticEvent(Interface: EventInterfaceType) &#123;\n  function SyntheticBaseEvent(\n    reactName: string | null,\n    reactEventType: string,\n    targetInst: Fiber,\n    nativeEvent: &#123;[propName: string]: mixed&#125;,\n    nativeEventTarget: null | EventTarget,\n  ) &#123;\n\n  Object.assign(SyntheticBaseEvent.prototype, &#123;\n    preventDefault: function() &#123;&#125;,\n\n    stopPropagation: function() &#123;&#125;,\n\n    &#x2F;**\n     * We release all dispatched &#96;SyntheticEvent&#96;s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won&#39;t be added back into the pool.\n     *&#x2F;\n    &#x2F;**\n    *我们在每个事件循环后释放所有调度的&#39;SyntheticEvent&#39;，添加\n    *他们回到水池里。这允许一种保持引用的方法\n    *不会被添加回池中。\n    *&#x2F;\n    persist: function() &#123;\n      &#x2F;&#x2F; Modern event system doesn&#39;t use pooling.\n      &#x2F;&#x2F; 现代事件系统不使用池。\n    &#125;,\n\n    &#x2F;**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return &#123;boolean&#125; True if this should not be released, false otherwise.\n     *&#x2F;\n    isPersistent: functionThatReturnsTrue,\n  &#125;);\n  return SyntheticBaseEvent;\n&#125;\n\npersist是个空函数，因为现在的事件系统不使用事件池机制\n事件池可以形象地理解为有个池子里装满了 SyntheticEvent 对象，程序有需要时会从池中取出一些使用，使用完后再放回池中。\n事件池机制意味着 SyntheticEvent 对象会被缓存且反复使用，目的是提高性能，减少创建不必要的对象。当 SyntheticEvent 对象被收回到事件池中时，属性会被抹除、重置为 null。\n因此，我们在写 React 事件回调函数的时候切记不能将 event 用于异步操作 —— 当异步操作真正执行的时候，SyntheticEvent 对象有可能已经被重置了\n有事件池的情况下，如何处理异步事件\n\n解决方案一： 使用 event.persist() 方法\n解决方案二： 及时缓存所需的 event 属性值\n\n&#x2F;&#x2F; 解决方案一：\nhandleChange &#x3D; (event) &#x3D;&gt; &#123;\n  event.persist(); &#x2F;&#x2F; 持久化\n  this.setState((prevState) &#x3D;&gt; (&#123;\n    value: event.target.value,\n    editionCounter: prevState.editionCounter + 1,\n  &#125;));\n&#125;;\n&#x2F;&#x2F; 解决方案二：\nhandleChange &#x3D; (event) &#x3D;&gt; &#123;\n  const value &#x3D; event.target.value; &#x2F;&#x2F; value这个本地变量已经保存了目标值\n  this.setState((prevState) &#x3D;&gt; (&#123;\n    value,\n    editionCounter: prevState.editionCounter + 1,\n  &#125;));\n&#125;;\n\n见\n移除版本在 17.0.0 (October 20, 2020)，React DOM，Remove event pooling. (@trueadm in #18969)\n移除原因\n见 Event Pooling\n\n虽然建立事件池是为了提高性能，但在现代浏览器中并没有提高性能。\n事件池也让开发人员感到困惑。例如，无法访问eventx.target。设置状态更新程序中的目标。\n\n\n\n\n\n\n\n\n\n\nWith React 16 and earlier, we have to call event.persist() to properly use the event, or read the property we need.\nhandleChange(event) &#123;\n  console.log(event.target.value);\n  event.persist();\n  this.setState(() &#x3D;&gt; (&#123;\n    text: event.target.value\n  &#125;));\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nIn React 17, the same code works as expected allowing us to fetch event.target.value without calling event.persist().The old event pooling optimization has been fully removed, so we can read the event fields whenever we need them.\nexport class App extends React.Component &#123;\n  constructor() &#123;\n    super();\n    this.state &#x3D; &#123; text: &quot;&quot; &#125;;\n    this.handleChange &#x3D; this.handleChange.bind(this);\n  &#125;\n  handleChange(event) &#123;\n    console.log(event.target.value);\n    this.setState(() &#x3D;&gt; (&#123;\n      text: event.target.value,\n    &#125;));\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;span&gt;Text: &lt;&#x2F;span&gt;\n        &lt;input onChange&#x3D;&#123;this.handleChange&#125; value&#x3D;&#123;this.state.text&#125; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n为什么原生事件的 stopPropagation 可以阻止合成事件的传递？因为合成事件是在原生事件触发之后才开始收集并触发的，所以当原生事件调用 stopPropagation 阻止传递后，根本到不到 root 节点，触发不了 React 绑定的处理函数，自然合成事件也不会触发，所以原生事件不是阻止了合成事件的传递，而是阻止了 React 中绑定的事件函数的执行。\nreact 基础知识总结见\nReact17 源码见\n参考链接react 基础知识总结\nReact 事件机制源码解析 17.0.1\n更改事件委托\n","slug":"2022-07-23react-杂货","date":"2022-07-22T16:25:08.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"591f2a8f52aa8db4f8ec9853d594cc54","title":"React@16.5.0 diffing algorithm","content":"说明\n\n\n\n\n\n\n\n\nReact provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React’s “diffing” algorithm so that component updates are predictable while being fast enough for high-performance apps.\n嗯，这里使用了英文原文，我觉得中文版本，翻译的不够准确\n撇开中文版官方不谈，译文如下：\nReact 提供了响应式 API,所以你不用担心每次更新都会发生什么变化。这使得开发应用更点单，但在 React 中如何实现这一点可能并不明显。这篇文章解释了我们在 React 的 diffing 算法的选择，因此，组件更新是可预测的，同时对高性能应用程序来说足够快。\n设计动机在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。\n在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。\nReact 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。\n此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。\n如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的 启发式算法：\n\n两个不同类型的元素会产生出不同的树；\n开发者可以使用 key 属性标识哪些子元素在不同的渲染中可能是不变的。\n\n在实践中，我们发现以上假设在几乎所有实用的场景下都成立。\n\n启发式算法定义\n启发式算法（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计\n\nDiffing 算法当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。\n对比不同类型的元素当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树\n\n当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 componentWillUnmount() 方法。\n\n当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 UNSAFE_componentWillMount() 方法，紧接着 componentDidMount() 方法。\n\n\n所有与之前的树相关联的 state 也会被销毁。\n在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时：\n&lt;div&gt;\n  &lt;Counter &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n&lt;span&gt;\n  &lt;Counter &#x2F;&gt;\n&lt;&#x2F;span&gt;\n\n\nReact 会销毁 Counter 组件并且重新装载一个新的组件。\n对比同一类型的元素当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如：\n&lt;div className&#x3D;&quot;before&quot; title&#x3D;&quot;stuff&quot; &#x2F;&gt;\n\n&lt;div className&#x3D;&quot;after&quot; title&#x3D;&quot;stuff&quot; &#x2F;&gt;\n\n通过对比这两个元素，React 知道只需要修改 DOM 元素上的 className 属性。\n\n\n\n当更新 style 属性时，React 仅更新有所更变的属性。比如：\n&lt;div style&#x3D;&#123;&#123;color: &#39;red&#39;, fontWeight: &#39;bold&#39;&#125;&#125; &#x2F;&gt;\n\n&lt;div style&#x3D;&#123;&#123;color: &#39;green&#39;, fontWeight: &#39;bold&#39;&#125;&#125; &#x2F;&gt;\n\n通过对比这两个元素，React 知道只需要修改 DOM 元素上的 color 样式，无需修改 fontWeight。\n在处理完当前节点之后，React 继续对子节点进行递归。\n对比同类型的组件元素当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 UNSAFE_componentWillReceiveProps()、UNSAFE_componentWillUpdate() 以及 componentDidUpdate()方法。\n下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。\n对子节点进行递归默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation变化。\n在子元素列表末尾新增元素时，更新开销比较小。比如：\n&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;first&lt;&#x2F;li&gt;\n  &lt;li&gt;second&lt;&#x2F;li&gt;\n  &lt;li&gt;third&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact 会先匹配两个 first 对应的树，然后匹配第二个元素 second 对应的树，最后插入第三个元素的 third 树。\n如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：\n&lt;ul&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\nReact 并不会意识到应该保留 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt;，而是会重建每一个子元素。这种情况会带来性能问题。\nKeys为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：\n&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n&lt;ul&gt;\n  &lt;li key&#x3D;&quot;2014&quot;&gt;Connecticut&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;\n  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n\n现在 React 知道只有带着 &#39;2014&#39; key 的元素是新元素，带着 &#39;2015&#39; 以及 &#39;2016&#39; key 的元素仅仅移动了。\n实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：\n&lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n\n当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。\n最后，_你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢_。\n\n\n\n\n\n\n\nWARNING\n当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动。\n\n\n在 Codepen 有两个例子，分别为 展示使用下标作为 key 时导致的问题，以及 不使用下标作为 key 的例子的版本，修复了重新排列，排序，以及在列表头插入的问题。\n修复前\n\n\n修复后\n\n\n权衡请谨记协调算法是一个实现细节。\nReact 可以在每个 action 之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用 render 方法，这不代表 React 会卸载或装载它们。React 只会基于以上提到的规则来决定如何进行差异的合并。\n我们定期优化启发式算法，让常见用例更高效地执行。在当前的实现中，可以理解为一棵子树能在其兄弟之间移动，但不能移动到其他位置。在这种情况下，算法会重新渲染整棵子树。\n由于 React 依赖启发式算法，因此当以下假设没有得到满足，性能会有所损耗。\n\n该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题。\n\nKey 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。\n\ndiffing algorithm见\n\n\n\n\n\n\n\nWARNING\n注意：React 技术揭秘讲的内容并不一定是全面且正确的，可能你在读的源码版本不一致，但可借鉴\n\nreconcileChildFibers\n\n读源码中…\n参考链接reconciliation\n代码调试\n探索 React 源码：Reconciler\n","slug":"2022-07-22react-diffing","date":"2022-07-22T01:16:00.000Z","categories_index":"react_1650","tags_index":"react_1650","author_index":"举手摘月亮"},{"id":"d6e3ef07929a629e78ad737d602fe838","title":"React@16.5.0 PureComponent","content":"串串\n\nPureComponent 继承 Component,添加 isPureReactComponent 标记\n&#x2F;&#x2F; ComponentDummy 是典型的 JavaScript 原型模拟继承的做法，\nfunction ComponentDummy() &#123;&#125;\nComponentDummy.prototype &#x3D; Component.prototype;\n\n&#x2F;**\n * Convenience component with default shallow equality check for sCU.\n * 具有sCU默认浅相等检查的便利组件。\n *&#x2F;\nfunction PureComponent(props, context, updater) &#123;\n  this.props &#x3D; props;\n  this.context &#x3D; context;\n  &#x2F;&#x2F; If a component has string refs, we will assign a different object later.\n  &#x2F;&#x2F; 如果组件具有字符串引用，我们将稍后指定其他对象。\n  this.refs &#x3D; emptyObject;\n  this.updater &#x3D; updater || ReactNoopUpdateQueue;\n&#125;\n\nconst pureComponentPrototype &#x3D; (PureComponent.prototype &#x3D; new ComponentDummy());\npureComponentPrototype.constructor &#x3D; PureComponent;\n&#x2F;&#x2F; Avoid an extra prototype jump for these methods.  避免这些方法的额外原型跳转。\n&#x2F;&#x2F; 为了避免原型链拉长导致方法查找的性能开销，还用 Object.assign 把方法从 ReactComponent 拷贝过来了\nObject.assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent &#x3D; true; &#x2F;&#x2F; checkShouldComponentUpdate中有浅比较&#96;shallowEqual&#96;\n\n&#x2F;&#x2F; packages&#x2F;react&#x2F;src&#x2F;ReactBaseClasses.js\n&#x2F;&#x2F; PureComponent-&gt;继承Component, 添加 isPureReactComponent &#x3D; true\n\n&#x2F;&#x2F; packages&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js\n&#x2F;&#x2F; checkShouldComponentUpdate-&gt;\n&#x2F;&#x2F; shallowEqual\n\ncheckShouldComponentUpdatefunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextLegacyContext\n) &#123;\n  const instance &#x3D; workInProgress.stateNode;\n  &#x2F;&#x2F; 实例上有shouldComponentUpdate，走实例的判断\n  if (typeof instance.shouldComponentUpdate &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n    startPhaseTimer(workInProgress, &quot;shouldComponentUpdate&quot;);\n    const shouldUpdate &#x3D; instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextLegacyContext\n    );\n    stopPhaseTimer();\n\n    if (__DEV__) &#123;\n      warningWithoutStack(\n        shouldUpdate !&#x3D;&#x3D; undefined,\n        &quot;%s.shouldComponentUpdate(): Returned undefined instead of a &quot; +\n          &quot;boolean value. Make sure to return true or false.&quot;,\n        getComponentName(ctor) || &quot;Component&quot;\n      );\n    &#125;\n\n    return shouldUpdate; &#x2F;&#x2F; 返回了\n  &#125;\n  &#x2F;&#x2F; 实例没有看看组件是不是PureComponent,如果是进行浅比较\n  &#x2F;&#x2F; 浅比较\n  if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  &#125;\n\n  return true;\n&#125;\n\nshallowEqualfunction shallowEqual(objA: mixed, objB: mixed): boolean &#123;\n  if (is(objA, objB)) &#123;\n    return true;\n  &#125;\n\n  if (\n    typeof objA !&#x3D;&#x3D; &quot;object&quot; ||\n    objA &#x3D;&#x3D;&#x3D; null ||\n    typeof objB !&#x3D;&#x3D; &quot;object&quot; ||\n    objB &#x3D;&#x3D;&#x3D; null\n  ) &#123;\n    return false;\n  &#125;\n\n  const keysA &#x3D; Object.keys(objA);\n  const keysB &#x3D; Object.keys(objB);\n\n  if (keysA.length !&#x3D;&#x3D; keysB.length) &#123;\n    return false;\n  &#125;\n\n  &#x2F;&#x2F; Test for A&#39;s keys different from B.\n  &#x2F;&#x2F; 只是对键对应的值进行比较，从MDN Object.is Api了解到 都是相同对象（意味着都是同一个对象的值引用）\n  &#x2F;&#x2F; 如果这里进行递归处理，就变成了deepCompare\n\n  for (let i &#x3D; 0; i &lt; keysA.length; i++) &#123;\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) &#123;\n      return false;\n    &#125;\n  &#125;\n\n  return true;\n&#125;\n\nis&#x2F;**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;is\n *&#x2F;\nfunction is(x, y) &#123;\n  &#x2F;&#x2F; SameValue algorithm\n  if (x &#x3D;&#x3D;&#x3D; y) &#123;\n    &#x2F;&#x2F; Steps 1-5, 7-10\n    &#x2F;&#x2F; Steps 6.b-6.e: +0 !&#x3D; -0\n    &#x2F;&#x2F; Added the nonzero y check to make Flow happy, but it is redundant\n    return x !&#x3D;&#x3D; 0 || y !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;\n  &#125; else &#123;\n    &#x2F;&#x2F; Step 6.a: NaN &#x3D;&#x3D; NaN\n    return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;\n  &#125;\n&#125;\n\nend and start其实上到这个地方，PureComponent 就聊完了\n与 beginWork 串串\n\n&#x2F;&#x2F; beginWork-&gt;\n&#x2F;&#x2F; updateClassComponent(到这里就与@link: &#x2F;posts&#x2F;2022-07-21react-createElement 串起来了)-&gt;\n&#x2F;&#x2F; resumeMountClassInstance-&gt; | updateClassInstance-&gt;\n&#x2F;&#x2F; checkShouldComponentUpdate-&gt;\n&#x2F;&#x2F; shallowEqual\n\nresumeMountClassInstance如果已经创建实例，则重用实例\nfunction resumeMountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime\n): boolean &#123;\n  &#x2F;&#x2F; 是否应该更新，两种情况：forceUpdate 或者 checkShouldComponentUpdate 返回true\n  const shouldUpdate &#x3D;\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextLegacyContext\n    );\n\n  if (shouldUpdate) &#123;\n    &#x2F;&#x2F; In order to support react-lifecycles-compat polyfilled components,\n    &#x2F;&#x2F; Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &amp;&amp;\n      (typeof instance.UNSAFE_componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot; ||\n        typeof instance.componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;)\n    ) &#123;\n      startPhaseTimer(workInProgress, &quot;componentWillMount&quot;);\n      if (typeof instance.componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n        instance.componentWillMount();\n      &#125;\n      if (typeof instance.UNSAFE_componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n        instance.UNSAFE_componentWillMount();\n      &#125;\n      stopPhaseTimer();\n    &#125;\n    &#x2F;&#x2F; 这里进行标记了\n    if (typeof instance.componentDidMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n      workInProgress.effectTag |&#x3D; Update;\n    &#125;\n  &#125; else &#123;\n  &#125;\n\n  &#x2F;&#x2F; Update the existing instance&#39;s state, props, and context pointers even\n  &#x2F;&#x2F; if shouldComponentUpdate returns false.\n  instance.props &#x3D; newProps;\n  instance.state &#x3D; newState;\n  instance.context &#x3D; nextLegacyContext;\n\n  return shouldUpdate;\n&#125;\n\nstartPhaseTimerpackages/react-reconciler/src/ReactDebugFiberPerf.js文件中，性能测量相关，不用关心\nupdateClassComponentfunction updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps,\n  renderExpirationTime: ExpirationTime\n) &#123;\n  let shouldUpdate;\n  if (current &#x3D;&#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F;  如果还没创建实例，初始化\n    if (workInProgress.stateNode &#x3D;&#x3D;&#x3D; null) &#123;\n    &#125; else &#123;\n      &#x2F;&#x2F;  如果已经创建实例，则重用实例\n      &#x2F;&#x2F; In a resume, we&#39;ll already have an instance we can reuse.\n      shouldUpdate &#x3D; resumeMountClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n    &#125;\n  &#125; else &#123;\n    &#x2F;&#x2F; 更新类实例\n    shouldUpdate &#x3D; updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime\n    );\n  &#125;\n  return finishClassComponent(\n    &#x2F;&#x2F; 调用组件实例的render函数获取需渲染的子元素，并把子元素进行处理为Fiber类型，处理state和props：\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime\n  );\n&#125;\n","slug":"2022-07-21react-PureComponent","date":"2022-07-21T08:28:39.000Z","categories_index":"react_1650","tags_index":"react_1650","author_index":"举手摘月亮"},{"id":"f07658ed4d8d481756bfa8b0d656b104","title":"React@16.5.0 unsafe_","content":"我整理这篇文章的目的很多时候，我在学技术时候更多关注的是教程和文档,原因有三：时间紧、任务重、新技术很多\n最近手头无事，刚好搜源码搜到了，希望闲暇之余，你也能了解 React 变更过程，加深 React 的理解\n过时的组件生命周期往往会带来不安全的编码实践\ncomponentWillMount\ncomponentWillReceiveProps\ncomponentWillUpdate\n\n这些生命周期方法经常被误解和滥用；此外，React 团队预计到，在异步渲染中，它们潜在的误用问题可能更大。所以在 March 27, 2018 提出\n\n\n\n\n\n\n\n\n\n我们将在即将发布的版本中为这些生命周期添加 UNSAFE_ 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。）\n遵循语义版本控制React 遵循语义版本控制，因此这种变化将是逐步的。我们目前的计划是：\n\n16.3：为不安全的生命周期引入别名，UNSAFE_componentWillMount``、UNSAFE_componentWillReceiveProps 和 UNSAFE_componentWillUpdate。（旧的生命周期名称和新的别名都可以在此版本中使用。）未来\n16.x 版本：为 componentWillMount``、componentWillReceiveProps 和 componentWillUpdate 启用废弃告警。（旧的生命周期名称和新的别名都将在这个版本中工作，但是旧的名称在开发模式下会产生一个警告。）\n17.0：删除 componentWillMount、componentWillReceiveProps 和 componentWillUpdate。（在此版本之后，只有新的 “UNSAFE_” 生命周期名称可以使用。）\n\n\n\n\n\n\n\n\nWARNING\n注意，如果你是 React 应用程序开发人员，则无需对这些过时的方法执行任何操作。即将发布的 16.3 版本的主要目的是使开源项目维护人员能够在任何废弃警告之前更新他们的库。在未来的 16.x 版本发布之前，不会启用这些警告。\n\n迁移过时的生命周期在开始之前，下面是关于 16.3 版本计划的生命周期变更的快速概述：\n\n添加以下生命周期别名：UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps 和 UNSAFE_componentWillUpdate。（将同时支持旧的生命周期名称和新别名。）\n引入两个新的生命周期，静态的 getDerivedStateFromProps 和 getSnapshotBeforeUpdate。\n\ngetDerivedStateFromPropsclass Example extends React.Component &#123;\n  static getDerivedStateFromProps(props, state) &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\n新的静态 getDerivedStateFromProps 生命周期方法在组件实例化之后以及重新渲染之前调用。它可以返回一个对象来更新 state，或者返回 null 来表示新的 props 不需要任何 state 的更新。\n与 componentDidUpdate 一起，这个新的生命周期涵盖过时的 componentWillReceiveProps 的所有用例。\n\n\n\n\n\n\n\nWARNING\n注意：\n旧的 componentWillReceiveProps 和新的 getDerivedStateFromProps 方法都会增加组件的复杂性。这经常会导致 bug。考虑使用 派生 state 的简单替代方法 让组件可预测且可维护。\n\ngetSnapshotBeforeUpdateclass Example extends React.Component &#123;\n  getSnapshotBeforeUpdate(prevProps, prevState) &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\n新的 getSnapshotBeforeUpdate 生命周期方法在更新之前（如：更新 DOM 之前）被调用。此生命周期的返回值将作为第三个参数传递给 componentDidUpdate。（通常不需要，但在重新渲染过程中手动保留滚动位置等情况下非常有用。）\n与 componentDidUpdate 一起，这个新的生命周期涵盖过时的 componentWillUpdate 的所有用例。\n示例初始化 state这个例子显示了组件在 componentWillMount 中调用 setState：\n&#x2F;&#x2F; Before\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;&#125;;\n\n  componentWillMount() &#123;\n    this.setState(&#123;\n      currentColor: this.props.defaultColor,\n      palette: &quot;rgb&quot;,\n    &#125;);\n  &#125;\n&#125;\n\n对于这种类型的组件，最简单的重构是将 state 的初始化，移到构造函数或属性的初始化器内，\n&#x2F;&#x2F; After\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    currentColor: this.props.defaultColor,\n    palette: &quot;rgb&quot;,\n  &#125;;\n&#125;\n\n获取外部数据以下是使用 componentWillMount 获取外部数据的组件的示例：\n&#x2F;&#x2F; Before\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    externalData: null,\n  &#125;;\n\n  componentWillMount() &#123;\n    this._asyncRequest &#x3D; loadMyAsyncData().then((externalData) &#x3D;&gt; &#123;\n      this._asyncRequest &#x3D; null;\n      this.setState(&#123; externalData &#125;);\n    &#125;);\n  &#125;\n\n  componentWillUnmount() &#123;\n    if (this._asyncRequest) &#123;\n      this._asyncRequest.cancel();\n    &#125;\n  &#125;\n\n  render() &#123;\n    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;\n      &#x2F;&#x2F; 渲染加载状态 ...\n    &#125; else &#123;\n      &#x2F;&#x2F; 渲染真实 UI ...\n    &#125;\n  &#125;\n&#125;\n\n上述代码对于服务器渲染（不使用外部数据）和即将推出的异步渲染模式（可能多次启动请求）都存在问题。\n大多数用例推荐的升级方式是将数据获取移到 componentDidMount：\n&#x2F;&#x2F; After\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    externalData: null,\n  &#125;;\n\n  componentDidMount() &#123;\n    this._asyncRequest &#x3D; loadMyAsyncData().then((externalData) &#x3D;&gt; &#123;\n      this._asyncRequest &#x3D; null;\n      this.setState(&#123; externalData &#125;);\n    &#125;);\n  &#125;\n\n  componentWillUnmount() &#123;\n    if (this._asyncRequest) &#123;\n      this._asyncRequest.cancel();\n    &#125;\n  &#125;\n\n  render() &#123;\n    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;\n      &#x2F;&#x2F; 渲染加载状态 ...\n    &#125; else &#123;\n      &#x2F;&#x2F; 渲染真实 UI ...\n    &#125;\n  &#125;\n&#125;\n\n误解 1有一个常见的误解是，在 componentWillMount 中获取数据可以避免第一次渲染为空的状态。实际上，这是不对的，因为 React 总是在 componentWillMount 之后立即执行 render。如果在 componentWillMount 触发时数据不可用，那么第一次 render 仍然会显示加载的状态，而不管你在哪里初始化获取数据。这就是为什么在绝大多数情况下，将获取数据移到 componentDidMount 没有明显效果的原因。\n\n\n\n\n\n\n\nWARNING\n注意\n一些高级用例（如：Relay 库）可能尝试提前获取异步数据。这里提供了一个如何实现的示例。\n从长远来看，在 React 组件中获取数据的标准方法应该基于 “suspense” API 在冰岛 JSConf 提出。无论是简单的数据获取解决方案，还是像 Apollo 和 Relay 这样的库，都可以在内部使用它。它比上面的任何一个解决方案都要简洁，但是不会在 16.3 版本发布之前完成。\n当支持服务器渲染时，需要同步获取数据——componentWillMount 经常用于此目的，也可以用构造函数替代。即将推出的 suspense API 将使异步数据获取对于客户端和服务器渲染都是完全有可能的。\n\n\n添加事件监听器（或订阅）下面是一个示例，在组件挂载时订阅了外部事件：\n&#x2F;&#x2F; Before\nclass ExampleComponent extends React.Component &#123;\n  componentWillMount() &#123;\n    this.setState(&#123;\n      subscribedValue: this.props.dataSource.value,\n    &#125;);\n    &#x2F;&#x2F; 这是不安全的，它会导致内存泄漏！\n    this.props.dataSource.subscribe(this.handleSubscriptionChange);\n  &#125;\n\n  componentWillUnmount() &#123;\n    this.props.dataSource.unsubscribe(this.handleSubscriptionChange);\n  &#125;\n\n  handleSubscriptionChange &#x3D; (dataSource) &#x3D;&gt; &#123;\n    this.setState(&#123;\n      subscribedValue: dataSource.value,\n    &#125;);\n  &#125;;\n&#125;\n\n遗憾的是，这可能导致服务器渲染（永远不会调用 componentWillUnmount）和异步渲染（在渲染完成之前可能被中断，导致不调用 componentWillUnmount）的内存泄漏。\n误解 2人们通常认为 componentWillMount 和 componentWillUnmount 是成对出现的，但这并不能保证。只有调用了 componentDidMount 之后，React 才能保证稍后调用 componentWillUnmount 进行清理。\n因此，添加监听器&#x2F;订阅的推荐方法是使用 componentDidMount 生命周期：\n&#x2F;&#x2F; After\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    subscribedValue: this.props.dataSource.value,\n  &#125;;\n  componentDidMount() &#123;\n    &#x2F;&#x2F; 事件监听器只有在挂载后添加才是安全的，\n    &#x2F;&#x2F; 因此，如果挂载中断或错误，它们不会泄漏。\n    this.props.dataSource.subscribe(this.handleSubscriptionChange);\n    &#x2F;&#x2F; 外部值可能在渲染和挂载期间改变，\n    &#x2F;&#x2F; 在某些情况下，处理这种情况很重要。\n    if (this.state.subscribedValue !&#x3D;&#x3D; this.props.dataSource.value) &#123;\n      this.setState(&#123;\n        subscribedValue: this.props.dataSource.value,\n      &#125;);\n    &#125;\n  &#125;\n\n  componentWillUnmount() &#123;\n    this.props.dataSource.unsubscribe(this.handleSubscriptionChange);\n  &#125;\n\n  handleSubscriptionChange &#x3D; (dataSource) &#x3D;&gt; &#123;\n    this.setState(&#123;\n      subscribedValue: dataSource.value,\n    &#125;);\n  &#125;;\n&#125;\n\n有时，更新订阅来响应属性变更非常重要。如果你正在使用像 Redux 或 MobX 这样的库，库的容器组件应该为你处理了这个问题。对于应用程序作者，我们创建了一个小型库，create-subscription，来帮助解决这个问题。我们将它与 React 16.3 一起发布。\n我们可以使用 create-subscription 来传递订阅的值，而不是像上面示例那样传递一个可订阅的 dataSource prop：\nimport &#123; createSubscription &#125; from &quot;create-subscription&quot;;\n\nconst Subscription &#x3D; createSubscription(&#123;\n  getCurrentValue(sourceProp) &#123;\n    &#x2F;&#x2F; 返回订阅的当前值（sourceProp）。\n    return sourceProp.value;\n  &#125;,\n\n  subscribe(sourceProp, callback) &#123;\n    function handleSubscriptionChange() &#123;\n      callback(sourceProp.value);\n    &#125;\n\n    &#x2F;&#x2F; 订阅（例如：向订阅（sourceProp）添加事件监听器。\n    &#x2F;&#x2F; 每当订阅发生变化时，调用回调函数（新值）。\n    sourceProp.subscribe(handleSubscriptionChange);\n\n    &#x2F;&#x2F; 返回取消订阅方法。\n    return function unsubscribe() &#123;\n      sourceProp.unsubscribe(handleSubscriptionChange);\n    &#125;;\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; 我们可以直接传递订阅的值，\n&#x2F;&#x2F; 而不是将可订阅的源传递给我们的 ExampleComponent：\n&lt;Subscription source&#x3D;&#123;dataSource&#125;&gt;\n  &#123;(value) &#x3D;&gt; &lt;ExampleComponent subscribedValue&#x3D;&#123;value&#125; &#x2F;&gt;&#125;\n&lt;&#x2F;Subscription&gt;;\n\n\n\n\n\n\n\n\nWARNING\n注意：\n像 Relay/Apollo 这样的库，内部应该使用了与 create-subscription 相同的技术，用最适合他们库使用的方式手动管理订阅（参考这里）。\n\n基于 props 更新 state\n\n\n\n\n\n\nWARNING\n注意：\n旧的 componentWillReceiveProps 和新的 getDerivedStateFromProps 方法都会给组件增加明显的复杂性。这通常会导致 bug。考虑 派生 state 的简单替代方法 使组件可预测且可维护。\n\n这是一个示例，组件使用过时的 componentWillReceiveProps 生命周期基于新的 props 更新 state：\n&#x2F;&#x2F; Before\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    isScrollingDown: false,\n  &#125;;\n\n  componentWillReceiveProps(nextProps) &#123;\n    if (this.props.currentRow !&#x3D;&#x3D; nextProps.currentRow) &#123;\n      this.setState(&#123;\n        isScrollingDown: nextProps.currentRow &gt; this.props.currentRow,\n      &#125;);\n    &#125;\n  &#125;\n&#125;\n\n尽管上面的代码本身没有问题，但是 componentWillReceiveProps 生命周期经常被误用，会产生问题。因此，该方法将被废弃。\n从 16.3 版本开始，当 props 变化时，建议使用新的 static getDerivedStateFromProps 生命周期更新 state。创建组件以及每次组件由于 props 或 state 的改变而重新渲染时都会调用该生命周期：\n&#x2F;&#x2F; After\nclass ExampleComponent extends React.Component &#123;\n  &#x2F;&#x2F; 在构造函数中初始化 state，\n  &#x2F;&#x2F; 或者使用属性初始化器。\n  state &#x3D; &#123;\n    isScrollingDown: false,\n    lastRow: null,\n  &#125;;\n\n  static getDerivedStateFromProps(props, state) &#123;\n    if (props.currentRow !&#x3D;&#x3D; state.lastRow) &#123;\n      return &#123;\n        isScrollingDown: props.currentRow &gt; state.lastRow,\n        lastRow: props.currentRow,\n      &#125;;\n    &#125;\n\n    &#x2F;&#x2F; 返回 null 表示无需更新 state。\n    return null;\n  &#125;\n&#125;\n\n在上面的示例中，你可能会注意到 props.currentRow 在 state 中的镜像（state.lastRow）。这使得 getDerivedStateFromProps 能够像在 componentWillReceiveProps 中相同的方式访问上一个 props 的值。\n你可能想知道为什么我们不将上一个 props 作为参数传递给 getDerivedStateFromProps。我们在设计 API 时考虑过这个方案，但最终决定不采用它，原因有两个：\n\nprevProps 参数在第一次调用 getDerivedStateFromProps（实例化之后）时为 null，需要在每次访问 prevProps 时添加 if-not-null 检查。\n\n在 React 的未来版本中，不传递上一个 props 给这个方法是为了释放内存。（如果 React 无需传递上一个 props 给生命周期，那么它就无需保存上一个 props 对象在内存中。）\n\n\n\n\n\n\n\n\n\nWARNING\n注意\n如果你正在编写共享组件，react-lifecycles-compat polyfill 可以在旧版本的 React 里面使用新的 getDerivedStateFromProps 生命周期。在下面了解更多如何使用。\n\n\n调用外部回调调用外部回调下面是一个组件的示例，它在内部 state 发生变化时调用了外部函数：\n&#x2F;&#x2F; Before\nclass ExampleComponent extends React.Component &#123;\n  componentWillUpdate(nextProps, nextState) &#123;\n    if (this.state.someStatefulValue !&#x3D;&#x3D; nextState.someStatefulValue) &#123;\n      nextProps.onChange(nextState.someStatefulValue);\n    &#125;\n  &#125;\n&#125;\n\n误解 3有时人们使用 componentWillUpdate 是出于一种错误的担心，即当 componentDidUpdate 触发时，更新其他组件的 state 已经”太晚”了。事实并非如此。React 可确保在用户看到更新的 UI 之前，刷新在 componentDidMount 和 componentDidUpdate 期间发生的任何 setState 调用。通常，最好避免这样的级联更新，但在某些情况下，这些更新是必需的（例如：如果你需要在测量渲染的 DOM 元素后，定位工具的提示）。\n不管怎样，在异步模式下使用 componentWillUpdate 都是不安全的，因为外部回调可能会在一次更新中被多次调用。相反，应该使用 componentDidUpdate 生命周期，因为它保证每次更新只调用一次：\n&#x2F;&#x2F; After\nclass ExampleComponent extends React.Component &#123;\n  componentDidUpdate(prevProps, prevState) &#123;\n    if (this.state.someStatefulValue !&#x3D;&#x3D; prevState.someStatefulValue) &#123;\n      this.props.onChange(this.state.someStatefulValue);\n    &#125;\n  &#125;\n&#125;\n\nprops 更新的副作用类似于上面的例子，有时候组件在 props 发生变化时会产生副作用。\n&#x2F;&#x2F; Before\nclass ExampleComponent extends React.Component &#123;\n  componentWillReceiveProps(nextProps) &#123;\n    if (this.props.isVisible !&#x3D;&#x3D; nextProps.isVisible) &#123;\n      logVisibleChange(nextProps.isVisible);\n    &#125;\n  &#125;\n&#125;\n\n与 componentWillUpdate 类似，componentWillReceiveProps 可能在一次更新中被多次调用。因此，避免在此方法中产生副作用非常重要。相反，应该使用 componentDidUpdate，因为它保证每次更新只调用一次：\n&#x2F;&#x2F; After\nclass ExampleComponent extends React.Component &#123;\n  componentDidUpdate(prevProps, prevState) &#123;\n    if (this.props.isVisible !&#x3D;&#x3D; prevProps.isVisible) &#123;\n      logVisibleChange(this.props.isVisible);\n    &#125;\n  &#125;\n&#125;\n\nprops 更新时获取外部数据下面是一个组件的示例，它根据 props 的值获取外部数据：\n&#x2F;&#x2F; Before\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    externalData: null,\n  &#125;;\n\n  componentDidMount() &#123;\n    this._loadAsyncData(this.props.id);\n  &#125;\n\n  componentWillReceiveProps(nextProps) &#123;\n    if (nextProps.id !&#x3D;&#x3D; this.props.id) &#123;\n      this.setState(&#123; externalData: null &#125;);\n      this._loadAsyncData(nextProps.id);\n    &#125;\n  &#125;\n\n  componentWillUnmount() &#123;\n    if (this._asyncRequest) &#123;\n      this._asyncRequest.cancel();\n    &#125;\n  &#125;\n\n  render() &#123;\n    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;\n      &#x2F;&#x2F; 渲染加载状态 ...\n    &#125; else &#123;\n      &#x2F;&#x2F; 渲染真实 UI ...\n    &#125;\n  &#125;\n\n  _loadAsyncData(id) &#123;\n    this._asyncRequest &#x3D; loadMyAsyncData(id).then((externalData) &#x3D;&gt; &#123;\n      this._asyncRequest &#x3D; null;\n      this.setState(&#123; externalData &#125;);\n    &#125;);\n  &#125;\n&#125;\n\n此组件的推荐升级路径是将数据更新移动到 componentDidUpdate。你还可以使用新的 getDerivedStateFromProps 生命周期，在渲染新的 props 之前清除旧数据：\n&#x2F;&#x2F; After\nclass ExampleComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    externalData: null,\n  &#125;;\n\n  static getDerivedStateFromProps(props, state) &#123;\n    &#x2F;&#x2F; 保存 prevId 在 state 中，以便我们在 props 变化时进行对比。\n    &#x2F;&#x2F; 清除之前加载的数据（这样我们就不会渲染旧的内容）。\n    if (props.id !&#x3D;&#x3D; state.prevId) &#123;\n      return &#123;\n        externalData: null,\n        prevId: props.id,\n      &#125;;\n    &#125;\n    &#x2F;&#x2F; 无需更新 state\n    return null;\n  &#125;\n\n  componentDidMount() &#123;\n    this._loadAsyncData(this.props.id);\n  &#125;\n\n  componentDidUpdate(prevProps, prevState) &#123;\n    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;\n      this._loadAsyncData(this.props.id);\n    &#125;\n  &#125;\n\n  componentWillUnmount() &#123;\n    if (this._asyncRequest) &#123;\n      this._asyncRequest.cancel();\n    &#125;\n  &#125;\n\n  render() &#123;\n    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;\n      &#x2F;&#x2F; 渲染加载状态 ...\n    &#125; else &#123;\n      &#x2F;&#x2F; 渲染真实 UI ...\n    &#125;\n  &#125;\n\n  _loadAsyncData(id) &#123;\n    this._asyncRequest &#x3D; loadMyAsyncData(id).then((externalData) &#x3D;&gt; &#123;\n      this._asyncRequest &#x3D; null;\n      this.setState(&#123; externalData &#125;);\n    &#125;);\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\nWARNING\n注意\n如果你正在使用支持取消的 HTTP 库，例如 axios 那么在卸载时取消正在进行的请求非常简单。对于原生的 Promise，你可以使用类似此处所示的方法。\n\n更新前读取 DOM 属性下面是一个组件的示例，该组件在更新之前从 DOM 中读取属性，以便在列表中保持滚动的位置\nclass ScrollingList extends React.Component &#123;\n  listRef &#x3D; null;\n  previousScrollOffset &#x3D; null;\n\n  componentWillUpdate(nextProps, nextState) &#123;\n    &#x2F;&#x2F; 我们正在向列表中添加新项吗？\n    &#x2F;&#x2F; 捕获滚动位置，以便我们稍后可以调整滚动位置。\n    if (this.props.list.length &lt; nextProps.list.length) &#123;\n      this.previousScrollOffset &#x3D;\n        this.listRef.scrollHeight - this.listRef.scrollTop;\n    &#125;\n  &#125;\n\n  componentDidUpdate(prevProps, prevState) &#123;\n    &#x2F;&#x2F; 如果我们刚刚添加了新项，并且设置了 previousScrollOffset。\n    &#x2F;&#x2F; 调整滚动位置，以便这些新项不会把旧项挤出视图。\n    if (this.previousScrollOffset !&#x3D;&#x3D; null) &#123;\n      this.listRef.scrollTop &#x3D;\n        this.listRef.scrollHeight - this.previousScrollOffset;\n      this.previousScrollOffset &#x3D; null;\n    &#125;\n  &#125;\n\n  render() &#123;\n    return &lt;div ref&#x3D;&#123;this.setListRef&#125;&gt;&#123;&#x2F;* ...内容... *&#x2F;&#125;&lt;&#x2F;div&gt;;\n  &#125;\n\n  setListRef &#x3D; (ref) &#x3D;&gt; &#123;\n    this.listRef &#x3D; ref;\n  &#125;;\n&#125;\n\n在上面的示例中，componentWillUpdate 用于读取 DOM 属性。但是，对于异步渲染，“渲染”阶段的生命周期（如 componentWillUpdate 和 render）和”提交”阶段的生命周期（如 componentDidUpdate）之间可能存在延迟。如果用户在这段时间内调整窗口大小，那么从 componentWillUpdate 读取的 scrollHeight 值将过时。\n这个问题的解决方案是使用新的“提交”阶段生命周期 getSnapshotBeforeUpdate。这个方法在发生变化 前立即 被调用（例如在更新 DOM 之前）。它可以返回一个 React 的值作为参数传递给 componentDidUpdate 方法，该方法在发生变化 后立即 被调用。\n这两个生命周期可以像这样一起使用：\nclass ScrollingList extends React.Component &#123;\n  listRef &#x3D; null;\n\n  getSnapshotBeforeUpdate(prevProps, prevState) &#123;\n    &#x2F;&#x2F; 我们正在向列表中添加新项吗？\n    &#x2F;&#x2F; 捕获滚动位置，以便我们稍后可以调整滚动位置。\n    if (prevProps.list.length &lt; this.props.list.length) &#123;\n      return this.listRef.scrollHeight - this.listRef.scrollTop;\n    &#125;\n    return null;\n  &#125;\n\n  componentDidUpdate(prevProps, prevState, snapshot) &#123;\n    &#x2F;&#x2F; 如果我们刚刚添加了新项，并且有了快照值。\n    &#x2F;&#x2F; 调整滚动位置，以便这些新项不会把旧项挤出视图。\n    &#x2F;&#x2F; （此处的快照是从 getSnapshotBeforeUpdate 返回的值）\n    if (snapshot !&#x3D;&#x3D; null) &#123;\n      this.listRef.scrollTop &#x3D; this.listRef.scrollHeight - snapshot;\n    &#125;\n  &#125;\n\n  render() &#123;\n    return &lt;div ref&#x3D;&#123;this.setListRef&#125;&gt;&#123;&#x2F;* ...内容... *&#x2F;&#125;&lt;&#x2F;div&gt;;\n  &#125;\n\n  setListRef &#x3D; (ref) &#x3D;&gt; &#123;\n    this.listRef &#x3D; ref;\n  &#125;;\n&#125;\n\n\n\n\n\n\n\n\nWARNING\n注意\n如果你正在编写共享组件，那么 react-lifecycles-compat polyfill 可以使新的 getSnapshotBeforeUpdate 生命周期与旧版本的 React 一起使用。在下面了解更多如何使用。\n\n\n总结误解、滥用、异步中老 API 多次调用\n\n误解 componentWillMount 中初始化 state\n\n\n\n误解 componentWillMount 中获取数据，在 componentWillMount 之后立即执行 render。如果在 componentWillMount 触发时数据不可用，那么第一次 render 仍然会显示加载的状态，而不管你在哪里初始化获取数据\n\n\n\n误解 componentWillMount 中订阅，在服务端不会调用componentWillUnMount,导致内存泄漏,\n\n\n\n使用 componentWillUpdate 是出于一种错误的担心，即当 componentDidUpdate 触发时，更新其他组件的 state 已经”太晚”了。事实并非如此。React 可确保在用户看到更新的 UI 之前，刷新在 componentDidMount 和 componentDidUpdate 期间发生的任何 setState 调用。通常，最好避免这样的级联更新，但在某些情况下，这些更新是必需的（例如：如果你需要在测量渲染的 DOM 元素后，定位工具的提示）。 异步中，多次调用\n\n\n\ncomponentWillReceiveProps 可能在一次更新中被多次调用。因此，避免在此方法中产生副作用非常重要\n\n\n参考链接异步渲染之更新\n","slug":"2022-07-21react-unsafe","date":"2022-07-21T06:23:16.000Z","categories_index":"react_1650","tags_index":"react_1650","author_index":"举手摘月亮"},{"id":"5d9b43eaa4875051b6cba337b4fe23d2","title":"React@16.5.0 createElement","content":"项目开发时候书写代码某个页面或者是组件\n&#x2F;&#x2F;  class ReactComponent extends React.Component &#123;\n&#x2F;&#x2F;      render() &#123;\n&#x2F;&#x2F;          return &lt;p className&#x3D;&quot;class&quot;&gt;Hello React&lt;&#x2F;p&gt;;\n&#x2F;&#x2F;      &#125;\n&#x2F;&#x2F;  &#125;\n&#x2F;&#x2F;  以上代码会编译为：\nclass ReactComponent extends React.Component &#123;\n  render() &#123;\n    React.createElement(&quot;p&quot;, &#123; className: &quot;class&quot; &#125;, &quot;Hello React&quot;); &#x2F;&#x2F; 之前看到蜜壳代码是这个样子，我还以为是研发手写的呢\n  &#125;\n&#125;\n\n&#x2F;&#x2F;  &lt;ReactComponent someProp&#x3D;&quot;prop&quot; &#x2F;&gt;\nReact.createElement(ReactComponent, &#123; someProp: &quot;prop&quot; &#125;, null);\n\n以上代码 api 在packages/react/src/React.js\nconst React &#x3D; &#123;\n  createElement: createElement, &#x2F;&#x2F; packages&#x2F;react&#x2F;src&#x2F;ReactElement.js  createElement -&gt; ReactElement\n  version: ReactVersion,\n&#125;;\nexport default React;\n\nReact 是如何将虚拟 DOM 转换为真实 DOM\n首先我们要通过 React.createElement 函数来将我们定义好的组件进行转换为 React 元素\n将创建好的 React 元素通过调用 ReactDom.render 来进行渲染\nReactDom.render 调用后先创建根对象 root，然后调用 root.render\n然后经过若干函数调用，来到 workLoop 函数，它将遍历虚拟 DOM 树，将下一个需要处理的虚拟 DOM 传给 performUnitOfWork，performUnitOfWork 再将虚拟 DOM 传给 beginWork 后，beginWork根据虚拟 DOM 的类型不同进行相应处理，并对子节点进行处理为 Fiber 类型，为 Fiber 类型虚拟 DOM , 添加父节点、兄弟节点等细节，以方便遍历树。\nbeginWork 处理完后返回需要处理的子元素再继续处理，直到没有子元素（即返回 null），此时 performUnitOfWork 调用 completeUnitOfWork 处理这颗虚拟 DOM 子树，将其转换为真实 DOM。\n最后所有的虚拟 DOM 都将转为真实 DOM。\n\n函数调用过程root.render(children, callback) -&gt;\nDOMRenderer.updateContainer(children, root, null, work._onCommit) -&gt;\nupdateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    expirationTime,\n    callback,\n) -&gt;\nscheduleRootUpdate(current, element, expirationTime, callback) -&gt;\nscheduleWork(current, expirationTime) -&gt;\nrequestWork(root, rootExpirationTime) -&gt;\nperformWorkOnRoot(root, Sync, false) -&gt;\nrenderRoot(root, false) -&gt;\nworkLoop(isYieldy) -&gt;\nperformUnitOfWork(nextUnitOfWork: Fiber) &#x3D;&gt; Fiber | null -&gt;\nbeginWork(current, workInProgress, nextRenderExpirationTime)\n\n\n使用 ReactDom 渲染到 页面上\nReactDom.render(React.createElement(App), document.getElementById(&quot;root&quot;));\n\n我艹，有点懵～待补，先写个其他的压压惊\n参考链接React 源码阅读：虚拟 DOM 的初始化\nReact 16 源码瞎几把解读 【一】 从jsx到一个react 虚拟dom对象\nReact 16 源码瞎几把解读 【二】 react组件的解析过程\nReact 16 源码瞎几把解读 【三 点 一】 把react组件对象弄到dom中去(矛头指向fiber，fiber不解读这个过程也不知道) \nReact 16 源码瞎几把解读 【三 点 二】 react中的fiberRoot\n","slug":"2022-07-21react-createElement","date":"2022-07-21T03:18:50.000Z","categories_index":"react_1650","tags_index":"react_1650","author_index":"举手摘月亮"},{"id":"8cd3fa1949a115d76dd37b87c1175bed","title":"React@16.5.0 syntheticEvent","content":"本文说明本文主要内容是 React v16.5.0, 部分内容会涉及到 React v17+, React v17+合成事件与 React16 有很大差异\nReact 和事件系统概述见\n&#x2F;**\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.---&gt;|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.---&gt;|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter&#x2F;Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n *&#x2F;\n\n为什么 React 需要自己实现一套事件系统？\n\n这个问题主要是为了性能和复用两个方面来考虑。\n首先对于性能来说React 作为一套 View 层面的框架，通过渲染得到 vDOM，再由 diff 算法决定 DOM 树那些结点需要新增、替换或修改，假如直接在 DOM 结点插入原生事件监听，则会导致频繁的调用 addEventListener 和 removeEventListener，造成性能的浪费。所以 React 采用了事件代理的方法，对于大部分事件 1 而言都在 document 上做监听，然后根据Event中的target来判断事件触发的结点。\n其次 React 合成的 SyntheticEvent 采用了池的思想，从而达到节约内存，避免频繁的创建和销毁事件对象的目的。这也是“如果我们需要异步使用一个 syntheticEvent，需要执行 event.persist()才能防止事件对象被释放”的原因。\n最后在 React 源码中随处可见 batch 做批量更新，基本上凡是可以批量处理的事情（最普遍的 setState）React 都会将中间过程保存起来，留到最后面 flush（渲染，并最终提交到 DOM 树上）掉。就如浏览器对 DOM 树进行 Style，Layout，Paint 一样，都不会在操作 ele.style.color=&#39;red&#39;;之后马上执行，只会将这些操作打包起来并最终在需要渲染的时候再做渲染,。队列机制来批量更新布局 (1000ms&#x2F;60 &#x3D; 16.6ms 进行一次渲染)\nele.style.color &#x3D; &quot;red&quot;;\nele.style.color &#x3D; &quot;blue&quot;;\nele.style.color &#x3D; &quot;red&quot;;\n&#x2F;&#x2F; 浏览器只会渲染一次;\n\n而对于复用来说React 看到在不同的浏览器和平台上，用户界面上的事件其实非常相似，例如普通的 click，change 等等。React 希望通过封装一层事件系统，将不同平台的原生事件都封装成 SyntheticEvent。\n\n使得不同平台只需要通过加入EventEmitter以及对应的Renderer就能使用相同的一个事件系统，WEB 平台上加入 ReactBrowserEventEmitter，Native 上加入 ReactNativeEventEmitter。如下图，对于不同平台，React 只需要替换掉左边部分，而右边 EventPluginHub 部分可以保持复用。\n\n而对于不同的浏览器而言，React帮我们统一了事件，做了浏览器的兼容，例如对于 transitionEnd,webkitTransitionEnd,MozTransitionEnd 和 oTransitionEnd, React 都会集合成 topAnimationEnd，所以我们只用处理这一个标准的事件即可。\n\n\n\n\nReact 的事件系统是怎么运作起来的？事件绑定我们来看一下我们在 JSX 中写的 onClickhandler 是怎么被记录到 DOM 结点上，并且在 document 上做监听的。\n\n\nReact 对于大部分事件的绑定都是使用trapBubbledEvent和trapCapturedEvent这两个函数来注册的。如上图所示，当我们执行了 render 或者 setState 之后，React 的 Fiber 调度系统，会在最后 commit 到 DOM 树之前, 执行trapBubbledEvent或trapCapturedEvent，在document节点上绑定回调（通过执行addEventListener在 document 结点上绑定对应的dispatch函数,作为回调负责监听类型为topLevelType的事件）。\n这里面的 dispatchInteractiveEvent 和 dispatchEvent 两个回调函数的区别为，React16 开始换掉了原本 Stack Reconciliation 成 Fiber 希望实现异步渲染（React16 仍未默认打开，仍需使用 unstable_开头的 api，此特性与例子 2 有关，将在文章最后配图解释），所以异步渲染的情况下假如我点了两次按钮，那么第二次按钮响应的时候，可能第一次按钮的 handlerA 中调用的 setState 还未最终被 commit 到 DOM 树上，这时需要把第一次按钮的结果先给 flush 掉并 commit 到 DOM 树，才能够保持一致性。这个时候就会用到 dispatchInteractiveEvent。可以理解成 dispatchInteractiveEvent 在执行前都会确保之前所有操作都已最总 commit 到 DOM 树，再开始自己的流程，并最终触发 dispatchEvent。但由于 React16 仍是同步渲染的，所以这两个函数在目前的表现是一致的，React17 默认打开的异步渲染功能。\n到现在我们已经在 document 结点上监听了事件了，现在需要来看如何将我们在 jsx 中写的 handler 存起来对应到相应的结点上。\n在我们每次新建或者更新结点时，React 会调用 createInstance 或者 commitUpdate 这两个函数，而这两个函数都会最终调用 updateFiberProps 这个函数，将 props 也就是我们的 onClick，onChange 等 handler 给存到 DOM 结点上。\n至此，我们我们已经在 document 上监听了事件，并且将 handler 存在对应 DOM 结点。接下来需要看 React 怎么监听并处理浏览器的原生事件，最终触发对应的 handler 了。\n事件触发动画见原文 Hype 动画\n动画应该是使用 Hype 工具 制作的\n以简单的 click 事件为例，通过事件绑定我们已经在 document 上监听了 click 事件，当我们真正点击了这个按钮的时候，原生的事件是如何进入 React 的管辖范围的？如何合成 SyntheticEvent 以及如何模拟捕获和冒泡的？以及最后我们在 jsx 中写的 onClickhandler 是如何被最终触发的？带着这些问题，我们一起来看一下事件触发阶段。\n大概用下图这种方式来解析代码，左边是我点击一个绑定了 handleClick 的按钮后的 js 调用栈，右边是每一步的代码，均已删除部分不影响理解的代码。希望通过这种方式能使大家更易理解 React 的事件触发机制。\n\n\n当我们点击一个按钮是，click 事件将会最终冒泡至 document，并触发我们监听在 document 上的 handler dispatchEvent，接着触发 batchedUpdates。batchedUpdates 这个格式的代码在 React 的源码里面会频繁的出现，基本上 React 将所有能够批量处理的事情都会先收集起来，再一次性处理。\n可以看到默认的 isBatching 是 false 的，当调用了一次 batchedUpdates，isBatching 的值将会变成 true，此时如果在接下来的调用中有执行 batchedUpdates 的话，就会直接执行 handleTopLevel,此时的 setState 等不会被更新到 DOM 上。直到调用栈重新回到第一次调用 batchedUpdates 的时候，才会将所有结果一起 flush 掉（更新到 DOM 上）。\n\n\n调用栈中的 BatchedUpdates$1 是什么？或者浏览器的 renderer 和 Native 的 renderer 是如果挂在到 React 的事件系统上的?\n其实 React 事件系统里面提供了一个函数 setBatchingImplementation，用来动态挂载不同平台的 renderer，这个也体现了 React 事件系统的复用。（如图右边所示，在 DOM Renderer 里面和 Native Renderer 里面分别调用这个函数动态注入相应的实现）\n这里的 interactiveUpdates 交互式更新是用户交互的结果 和 batchedUpdates 的区别在上文已经解释过，这里就不再赘述。\n\n\nhandleTopLevel 会调用 runExtractedEventsInBatch()，这是 React 事件处理最重要的函数。如上面动画我们看到的，在 EventEmitter 里面做的事，其实主要就是这个函数的两步。\n\n第一步是根据原生事件合成为合成事件，并且在 vDOM 上模拟捕获冒泡，收集所有需要执行的事件回调构成回调数组。\n第二步是遍历回调数组，触发回调函数。\n\n\n\n首先调用 extractEvents，传入原生事件 e，React 事件系统根据可能的事件插件合成合成事件 Synthetic e。 这里我们可以看到调用了 EventConstructor.getPooled()，从事件池中去取一个合成事件对象，如果事件池为空，则新创建一个合成事件对象，这体现了 React 为了性能实现了池的思想。\n\n\n然后传入 Propagator，在 vDOM 上模拟捕获和冒泡，并收集所有需要执行的事件回调和对应的结点。traverseTwoPhase 模拟了捕获和冒泡的两个阶段，这里实现很巧妙，简单而言就是正向和反向遍历了一下数组。接着对每一个结点，调用 listenerAtPhase 取出事件绑定时挂载在结点上的回调函数，把它加入回调数组中。\n\n\n接着executeDispatchesAndRelease遍历所有合成事件。这里可以看到当一个事件处理完的时候，React 会调用 event.isPersistent()来查看这个合成事件是否需要被持久化，如果不需要就会释放这个合成事件，这也就是为什么当我们需要异步读取操作一个合成事件的时候，需要执行 event.persist()，不然 React 就是在这里释放掉这个事件。\n\n\n最后executeDispatchesInOrder这里就是回调函数被真正触发的时候了，取出回调数组 event._dispatchListeners，遍历触发回调函数。并通过 event.isPropagationStopped()这一步来模拟停止冒泡。这里我们可以看到，React 在收集回调数组的时候并不会去管我们是否调用了 stopPropagation，而是会在触发的阶段才会去检查是否需要停止冒泡。\n至此，一个事件回调函数就被触发了，里面如果执行了 setState 等就会等到调用栈弹回到最低部的 interactiveUpdate 中的被最终 flush 掉，构造 vDOM，和好，并最终被 commit 到 DOM 上。\n这就是事件触发的整个过程了，可以回去再看一下 动画，相信你会更加理解这个过程的。\n合成事件与原生事件有怎样的执行顺序？原生事件\n\n\n原生+合成事件\n\n在 V17 版本前，原生事件的执行时机是恒早于合成事件的执行时机的。\n\nV17 版本后，合成事件和原生事件的执行顺序与冒泡/捕获模式相关，\n\n捕获模式，合成事件早于原生事件，\n冒泡模式，原生事件早于合成事件。\n\n\n\n\nReact 合成事件与原生事件执行顺序\n\n合成事件和原生事件的执行顺序\n例子 1class App extends React.Component &#123;\n  innerClick &#x3D; (e) &#x3D;&gt; &#123;\n    console.log(&quot;A: react inner click.&quot;);\n    &#x2F;&#x2F; e.stopPropagation();\n  &#125;;\n\n  outerClick &#x3D; () &#x3D;&gt; &#123;\n    console.log(&quot;B: react outer click.&quot;);\n  &#125;;\n\n  componentDidMount() &#123;\n    document\n      .getElementById(&quot;outer&quot;)\n      .addEventListener(&quot;click&quot;, () &#x3D;&gt; console.log(&quot;C: native outer click&quot;));\n\n    window.addEventListener(&quot;click&quot;, () &#x3D;&gt;\n      console.log(&quot;D: native window click&quot;)\n    );\n  &#125;\n\n  render() &#123;\n    return (\n      &lt;div id&#x3D;&quot;outer&quot; onClick&#x3D;&#123;this.outerClick&#125;&gt;\n        &lt;button id&#x3D;&quot;inner&quot; onClick&#x3D;&#123;this.innerClick&#125;&gt;\n          BUTTON\n        &lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n相信看完这篇文章，如果你已经对 React 事件系统有所理解，这道题应该是不难了。\n\n因为 React 事件监听是挂载在 document 上的，所以原生系统在#outer 上监听的回调 C 会最先被输出；接着原生事件冒泡至 document 进入 React 事件系统，React 事件系统模拟捕获冒泡输出 A 和 B；最后 React 事件系统执行完毕回到浏览器继续冒泡到 window，输出 D。\n\n浏览器在#outer 上监听原生事件的回调 C 会最先被执行；接着原生事件冒泡至 document 进入 React 事件系统，输出 A，在 React 事件处理中#inner 调用了 stopPropagation，事件被停止冒泡。\n\n\n&#x2F;&#x2F; 1. 不阻止合成事件冒泡\n&#x2F;&#x2F;     C: native outer click\n&#x2F;&#x2F;     A: react inner click.\n&#x2F;&#x2F;     B: react outer click.\n&#x2F;&#x2F;     D: native window click\n&#x2F;&#x2F; 2. 阻止合成事件冒泡\n&#x2F;&#x2F;     C: native outer click\n&#x2F;&#x2F;     A: react inner click.\n\n\n\n\n\n\n\nTIP\n所以，最好不要混用 React 事件系统和原生事件系统，如果混用了，请保证你清楚知道会发生什么。\n\n例子 2import React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\n\nclass App extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;\n      editable: false,\n    &#125;;\n  &#125;\n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    console.log(&quot;edit button click!!&quot;);\n    this.setState(&#123; editable: true &#125;);\n  &#125;;\n  handleSubmit &#x3D; (e) &#x3D;&gt; &#123;\n    console.log(&quot;submit event!!&quot;);\n    e.preventDefault();\n  &#125;;\n  render() &#123;\n    return (\n      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;\n        &#123;this.state.editable ? (\n          &lt;button type&#x3D;&quot;submit&quot;&gt;submit&lt;&#x2F;button&gt;\n        ) : (\n          &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;this.handleClick&#125;&gt;\n            edit\n          &lt;&#x2F;button&gt;\n        )&#125;\n      &lt;&#x2F;form&gt;\n    );\n  &#125;\n&#125;\n\nconst rootElement &#x3D; document.getElementById(&quot;root&quot;);\nReactDOM.render(&lt;App &#x2F;&gt;, rootElement);\n\n首先我们点击 edit 按钮浏览器触发一个 click 事件，冒泡至 document 进入 React 事件系统，React 执行回调调用 setState，此时 React 事件系统对事件的处理执行完毕。由于目前 React 是同步渲染的，所以接着 React 执行 performSyncWork 将该 button 改成 type=&quot;submit&quot;，由于同个位置的结点并且 tag 都为 button，所以 React 复用了这个 button 结点 2，并更新到 DOM 上。此时浏览器对 click 事件执行继续，其发现该结点的 type&#x3D;”submit”，则触发 submit 事件。\n解决的办法就有很多种了，给 button 加上 key；两个按钮分开写，不要用三元等都可以解决问题。\ne.stopPropagation() 如何阻止合成事件冒泡？executeDispatchesInOrder这里就是回调函数被真正触发的时候了，取出回调数组 event._dispatchListeners，遍历触发回调函数。并通过 event.isPropagationStopped()这一步来模拟停止冒泡。这里我们可以看到，React 在收集回调数组的时候并不会去管我们是否调用了 stopPropagation，而是会在触发的阶段才会去检查是否需要停止冒泡。\n同级别的两个按钮，使用三元运算符，会出问题？渲染后按钮的事件是否会触发\nReact16 例子 2 一定触发 submit, 原因：同步更新\n\n\nReact17+ 例子 2 不一定触发 submit 原因：异步更新\n\n\nReact 提示 event.persist() ，为什么会提示？React 在executeDispatchesAndRelease遍历所有合成事件，会调用 event.isPersistent()来查看这个合成事件是否需要被持久化，如果不需要就会释放这个合成事件，这也就是为什么当我们需要异步读取操作一个合成事件的时候，需要执行 event.persist()，不然 React 就是在这里释放掉这个事件。\nsetState 有时候是异步的，setState 相对于浏览器而言是同步的，如何理解？setState 在生命周期以及事件回调中是异步的，也就是会收集起来批量处理。在其它情况下如 promise，setTimeout 中都是同步执行的，也就是调用一次 setState 就会 render 一次并更新到 DOM 上面\n且在 JS 调用栈被弹空时候，必定是已经将结果更新到 DOM 上面了（同步渲染）。这也就是 setState 相对于浏览器是同步的含义。如下图所示\n\n\n异步渲染的流程图大概如下图所示，最近一次思考这个问题的时候，发现如果现在是异步渲染的话，那我们的例子二将变成偶现的坑 😂，因为如果 setState 的结果还没被更新到 DOM 上，浏览器就不会触发 submit 事件。\n\n\n异步渲染使用不安全的生命周期会有怎样的现象？例子 2 变成偶现\n之前将事件监听挂载到 document 上，现在为何挂载到 root 上？当同个项目里，有多个 React 根节点时（也可能是 React 多版本共存），避免可能的一些操作（如阻止冒泡）会影响到其他 React 节点的正常工作。\n\n\nDelegate events to roots instead of document\nReact 17 delegates events to root instead of document\n为了演示其中一个问题，让我们以 select 下拉列表为例。\n&lt;!--Div&#39;s change event contains stopPropagation()--&gt;\n&lt;div id&#x3D;&quot;main&quot;&gt;\n  &lt;!--Div where react component will be rendered --&gt;\n  &lt;div id&#x3D;&quot;react-root&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\nclass CountryDropDown extends React.Component &#123;\n  state &#x3D; &#123;\n    country: &#39;&#39;,\n  &#125;\n  const handleChange &#x3D; e &#x3D;&gt; &#123;\n    this.setState(&#123; country: e.target.value &#125;);\n  &#125;\n  render() &#123;\n    return (\n      &lt;table class&#x3D;&quot;table table-striped table-condensed&quot;&gt;\n        &lt;thead&gt;\n          &lt;tr&gt;\n            &lt;th&gt;Country&lt;&#x2F;th&gt;\n            &lt;th&gt;Selected country&lt;&#x2F;th&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;thead&gt;\n        &lt;tbody&gt;\n          &lt;tr&gt;\n            &lt;td&gt;\n              &lt;select value&#x3D;&#123;this.state.country&#125;\n                onChange&#x3D;&#123;this.handleChange&#125;\n              &gt;\n                &lt;option value&#x3D;&quot;&quot;&gt;--Select--&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;India&quot;&gt;India&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;US&quot;&gt;US&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;Dubai&quot;&gt;Dubai&lt;&#x2F;option&gt;\n              &lt;&#x2F;select&gt;\n            &lt;&#x2F;td&gt;\n            &lt;td&gt;\n              &#123;this.state.country&#125;\n            &lt;&#x2F;td&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;tbody&gt;\n      &lt;&#x2F;table&gt;\n    );\n  &#125;\n&#125;\nReactDOM.render(&lt;CountryDropDown &#x2F;&gt;, document.getElementById(&#39;react-root&#39;));\n\n\n\n给main-div增加一个阻止冒泡的事件\ndocument.getElementById(&quot;main&quot;).addEventListener(\n  &quot;change&quot;,\n  function (e) &#123;\n    e.stopPropagation();\n  &#125;,\n  false\n);\n\n附加到文档节点的 onChange 下拉事件出现意外行为，原因是：包含 e.stopPropagation（）的主 div 的 change 事件阻止了下拉的 onChange 事件。\n合成事件的冒泡捕获机制如何实现？traverseTwoPhase 模拟了捕获和冒泡的两个阶段，这里实现很巧妙，简单而言就是正向和反向遍历了一下数组\n合成事件源码函数调用关系图\n\nv17.0.1React 中事件分为委托事件（DelegatedEvent）和不需要委托事件（NonDelegatedEvent），\n\n委托事件在 fiberRoot 创建的时候，就会在 root 节点的 DOM 元素上绑定几乎所有事件的处理函数，\n而不需要委托事件只会将处理函数绑定在 DOM 元素本身。\n\n同时，React 将事件分为 3 种类型——discreteEvent(离散事件，对应discreteEventPairsForSimpleEventPlugin)、userBlockingEvent(用户阻止事件，对应userBlockingPairsForSimpleEventPlugin)、continuousEvent(连续事件，对应continuousPairsForSimpleEventPlugin)，它们拥有不同的优先级，在绑定事件处理函数时会使用不同的回调函数。\nReact 事件建立在原生基础上，模拟了一套冒泡和捕获的事件机制，当某一个 DOM 元素触发事件后，会冒泡到 React 绑定在 root 节点的处理函数，通过 target 获取触发事件的 DOM 对象和对应的 Fiber 节点，由该 Fiber 节点向上层父级遍历，收集一条事件队列，再遍历该队列触发队列中每个 Fiber 对象对应的事件处理函数，正向遍历模拟冒泡，反向遍历模拟捕获，所以合成事件的触发时机是在原生事件之后的。\nFiber 对象对应的事件处理函数依旧是储存在 props 里的，收集只是从 props 里取出来，它并没有绑定到任何元素上。\ncreateRootImpl(委托事件绑定)-&gt;\nlistenToAllSupportedEvents(监听所有支持的事件)-&gt;\nlistenToNativeEvent(冒泡,捕获)-&gt;\ngetEventListenerSet,getListenerSetKey,addTrappedEventListener（函数会通过事件名取得对应优先级的listener函数，再交由下层函数处理事件绑定）-&gt;\ncreateEventListenerWrapperWithPriority(根据优先级取得对应listener)-&gt;\ndispatchDiscreteEvent,dispatchUserBlockingUpdate,dispatchEvent(触发事件)-&gt;\nattemptToDispatchEvent(触发事件)-&gt;\n.....略.....-&gt;\ndispatchEventsForPlugins(函数里会收集触发事件开始各层级的节点对应的处理函数，也就是我们实际传入JSX中的函数，并且执行它们)-&gt;\nextractEvents(针对不同类型的事件创建对应的合成事件，并且将各层级节点的listener收集起来，用来模拟冒泡或者捕获)-&gt;\naccumulateSinglePhaseListeners(函数里就是在向上层遍历来收集一个列表后面会用来模拟冒泡)-&gt;\nprocessDispatchQueue(遍历dispatchQueue,在processDispatchQueueItemsInOrder函数里遍历执行)-&gt;\nprocessDispatchQueueItemsInOrder(根据判断来正向、反向的遍历来模拟冒泡和捕获)-&gt;\nexecuteDispatch(会执行listener)-&gt;\n\n参考链接动画浅析 REACT 事件系统和源码\n小前端读源码 - React16.7.0(合成事件)\nReact16 的 interactiveUpdates\nReact 17 All In One \n深入 React 合成事件机制原理\nReact 合成事件详解\nReact 17 delegates events to root instead of document\nReact 事件机制源码解析 17.0.1\nReact 事件 | 4. React 事件监听\nReact 源码解析-事件系统\n","slug":"2022-07-20react-syntheticEvent","date":"2022-07-20T01:18:53.000Z","categories_index":"react_1650","tags_index":"react_1650","author_index":"举手摘月亮"},{"id":"6f92233bb9cb3976c3ae6f34c3be87e6","title":"react-native 架构变更","content":"Fabric 渲染器Fabric 渲染器\n\n发展历程\n一开始直接看 react-native 官网，对于 Fabric 渲染器的介绍看的我一脸懵逼，在 Google 扒拉下，发现了 2018 年的一个提案。\n我觉得从过去来看更符合事物的发展规律。直接拿到结果倒着看，不是很好理解。\n这么搜搜到的\n\n2018 年提案React Native Fabric (UI-Layer Re-architecture) #4\n\n\n\n\n\n\n\n\n\nIn the current architecture, all UI operations (like creating native views, managing children, etc). are handled by a native module called UIManagerModule. The React Reconciller sends UI commands over the bridge, which are eventually handled by this module and delegated to UIImplementation. This in turn creates shadow nodes that represent the layout tree and are passed to Yoga to determine the relative co-ordinates based on the Flex box styles that are passed in from JS.\nIn the new system, the UI operations are directly exposed to JavaScript as functions using the JSI interface described above. The new UI manager can then create ComponentDescriptors and the Shadow Nodes for specific view types (like Text, View or Images), and then communicate with Java&#x2F;ObjC to draw platform specific UI.\n大概意思是：回到 2018 年 7 月 31 日 年，当时的 fabric，在 react-native-community 中还只是个讨论和提案，\n站在 2018 年 7 月 31 日这个时间点,看待这个提案：\n在当前架构中，\n\n所有的 UI 操作（像创建原生视图，管理子组件），被一个叫作UIManagerModule原生模块所处理，\nReact 协调器通过网桥发送 UI 命令，这些命令最终由该模块处理并委托给UIImplementation。\n这反过来会创建表示布局树的影子节点，并将其传递给 Yoga，以根据从 JS 传递的 Flex box 样式确定相对坐标。\n\n在新系统中，\n\n用户界面操作作为函数使用上述 JSI 接口直接暴露给 JavaScript。\n然后，新的 UI 管理器可以为特定的视图类型（如文本、视图或图像）创建组件描述符和影子节点，\n然后与 Java/ObjC 通信以绘制特定于平台的 UI\n\n\n\nfabric 是什么为了更好的用户体验，而这种新体验是在老架构上是不可能实现的,所以开发了新的渲染架构 fabric\n\n\n\nDetails\n设计的初忠\n开发新的渲染架构的初衷是为了更好的用户体验，而这种新体验是在老架构上是不可能实现的\n\n提升宿主视图（host views）和 React 视图（React views）的互操作性，渲染器必须有能力同步地测量和渲染 React 界面。在老架构中，React Native 布局是异步的，这导致在宿主视图中渲染嵌套的 React Native 视图，会有布局“抖动”的问题。\n多优先级&amp;同步事件 借助多优先级和同步事件的能力，渲染器可以提高用户交互的优先级，来确保他们的操作得到及时的处理(React schedule 调度，lan 模型)\nReact Suspense React Suspense 的集成，允许你在 React 中更符合直觉地写请求数据代码。\n可中断 允许你在 React Native 使用 React Concurrent 模式 可中断渲染功能。 Concurrent 究竟是什么？ 异步可中断\n更容易实现 React Native 的服务端渲染。？打个问号，是不是 RN 代码可以部署在云端？进行 SSR?\n\n设计的收益\n\n类型安全：代码生成工具（code generation）确保了 JS 和宿主平台两方面的类型安全。\n代码生成工具使用 JavaScript 组件声明作为唯一事实源，生成 C++ 结构体来持有 props 属性。\n不会因为 JavaScript 和原生组件 props 属性不匹配而出现构建错误。\n\n\n共享 C++：渲染器是用 C++ 实现的，其核心 core 在平台之间是共享的。这增加了一致性并且使得新的平台能够更容易采用 React Native。（译注：例如 VR 新平台）\n更好的宿主平台互操作性：当宿主组件集成到 React Native 时，\n同步和线程安全的布局计算提升了用户体验（译注：没有异步的抖动）。\n对于需要同步 API 的宿主平台库，变得更容易集成了。\n\n\n一致性：新的渲染系统的实现是跨平台的，不同平台之间更容易保持一致。以前是在 yoga 中计算的，现在是在 fabric 中进行计算\n性能提升：新的渲染系统的实现是跨平台的，每个平台都从那些原本只在某个特定平台的实现的性能优化中，得到了收益。比如拍平视图层级，原本只是 Android 上的性能优化方案，现在 Android 和 iOS 都直接有了。\n更快的启动速度：默认情况下，宿主组件的初始化是懒执行的。？以前不是\nJS 和宿主平台之间的数据序列化更少：&#96;\n以前&#96;：React 使用序列化 JSON 在 JavaScript 和宿主平台之间传递数据。\n现在：新的渲染器用 JSI（JavaScript Interface）直接获取 JavaScript 数据。\n\n\n\n\n\n\n\n\n\n\n\n\nWARNING\nnodejs 是什么语言写的“ Node.js 是用 C ++编写、开发的。 Node.js 底层是 C++(V8 也是 C++写的)\n\n术语表术语表\n宿主平台（Host platform）\nReact Native 嵌入的平台，比如 Android、iOS、Windows、macOS。\n宿主视图树（Host View Tree）\n\n宿主视图树就是一系列的宿主视图。宿主平台有 Android 平台、iOS 平台等等。在 Android 上，\n宿主视图就是 android.view.ViewGroup 实例、 android.widget.TextView 实例等等。\n宿主视图就像积木一样地构成了宿主视图树。\n每个宿主视图的大小和坐标位置基于的是 LayoutMetrics，而 LayoutMetrics 是通过布局引擎 Yoga 计算出来的。\n宿主视图的样式和内容信息，是从 React 影子树中得到的。\n\n一句话概括：\n&#x2F;&#x2F;  react 组件 -&gt; react 影子树  -&gt;   Yoga 布局计算到宿主视图   -&gt;  宿主视图树\n\nJavaScript Interfaces (JSI)一个轻量级的 API，给在 C++ 应用中嵌入的 JavaScript 引擎用的。Fabric 使用它在 Fabric 的 C++ 核心和 React 之间进行通信。\nJava Native Interface (JNI)Java Native Interface (JNI)：一个用于在 Java 中写 原生(译注：指调用 C++) 方法的 API。作用是实现 Fabric 的 C++ 核心和 Android 的通信。\n怎么没有提IOS的ObjC ? ObjC可以直接调用C++ ?\nReact 组件（React Component)React 组件就是 JavaScript 函数或者类，描述如何创建 React 元素。这篇博文中有更多介绍。\nReact 复合组件（React Composite Components)React 组件的 render 方法中，包括其他 React 复合组件和 React 宿主组件。\nReact 宿主组件（React Host Components or Host Components)React 组件的视图是通过宿主视图，比如 &lt;View&gt;、&lt;Text&gt;实现的。在 Web 中，ReactDOM 的宿主组件就是 &lt;p&gt;标签、&lt;div&gt;标签代表的组件。\nReact 元素树（React Element Trees)React 元素树是通过 JavaScript 中的 React 创建的，该树由一系类 React 元素组成。一个 React 元素就是一个普通的 JavaScript 对象，它描述了应该在屏幕中展示什么。一个元素包括属性 props、样式 styles、子元素 children。React 元素分为两类：React 复合组件实例（React Composite Components）和 React 宿主组件（React Host Components）实例，并且它只存在于 JavaScript 中。\nReact 影子树（React Shadow Tree and React Shadow Node)React 影子树是通过 Fabric 渲染器创建的，树由一系列 React 影子节点组成。一个 React 影子节点是一个对象，代表一个已经挂载的 React 宿主组件，其包含的属性 props 来自 JavaScript。它也包括布局信息，比如坐标系 x、y，宽高 width、height。\n\n在新渲染器 Fabric 中，React 影子节点对象只存在于 C++ 中。\n而在老架构中，它存在于手机运行时的堆栈中，比如 Android 的 JVM。\n\nFabric 渲染器（Fabric Renderer）：\nReact Native 执行的 React 框架代码，和 React 在 Web 中执行代码是同一份。\nReact Native 渲染的是通用平台视图（宿主视图）而不是 DOM 节点（可以认为 DOM 是 Web 的宿主视图）。\n\nFabric 渲染器使得渲染宿主视图变得可行。\n\nFabric 让 React 与各个平台直接通信并直接管理其宿主视图实例。\nFabric 渲染器存在于 JavaScript 中，并且它调用的是由 C++ 代码暴露的接口。在这篇文章中有更多关于 React 渲染器的信息。\n\nReact 源码目录Renderer 相关的文件夹如下几个文件夹为对应的 Renderer\n\nreact-art\nreact-dom # 注意这同时是 DOM 和 SSR（服务端渲染）的入口\nreact-native-renderer\nreact-noop-renderer # 用于 debug fiber（后面会介绍 fiber）\nreact-test-renderer\n\nreact-dom 与 react-native-renderer 属于同一级别,Fabric 取代了 react-native-renderer, 可以理解为Fabric是 react-dom级别的渲染器\n源码\n&#x2F;&#x2F; Libaries&#x2F;ReactNative&#x2F;renderApplication.js\n\nif (fabric) &#123;\n  require(&quot;..&#x2F;Renderer&#x2F;shims&#x2F;ReactFabric&quot;).render(\n    renderable,\n    rootTag,\n    null,\n    useConcurrentRoot\n  );\n&#125; else &#123;\n  require(&quot;..&#x2F;Renderer&#x2F;shims&#x2F;ReactNative&quot;).render(renderable, rootTag);\n&#125;\n\nfabricFabric is an all-embracing code generation framework for Java, C and C++.\n\n\nFabric 是一个适用于 Java、C 和 C++的包罗万象的代码生成框架。\n问题来了&#x2F;&#x2F; 以前 jsx -&gt; 原生\n\n&#x2F;&#x2F; 现在 jsx -&gt; JSI C++ -&gt; 原生\n\n多了一层，竟然不慢反快? 我猜应该在 JSI C++ -&gt; 原生\n跨平台实现中有对此说明\n\n在上一代 React Native 渲染器中，React 影子树、布局逻辑、视图拍平算法是在各个平台单独实现的。\n当前的渲染器的设计上采用的是跨平台的解决方案，共享了核心的 C++ 实现。\n\n使用 C++ 作为核心渲染系统有几个优点\n\n降低成本单一实现降低了开发和维护成本\n影子树的性能它提升了创建 React 影子树的性能\n渲染性能在 Android 上，也因为不再使用 JNI for Yoga，降低了 Yoga 渲染引擎的开销，布局计算的性能也有所提升\n内存占用小每个 React 影子节点在 C++ 中占用的内存，比在 Kotlin 或 Swift 中占用的要小。\n并发安全强制不可变的 C++ 特性，来确保并发访问时共享资源即便不加锁保护，也不会有问题。\n\n在 Android 端还有两种例外，渲染器依然会有 JNI 的开销：\n\n复杂视图，比如 Text、TextInput 等，依然会使用 JNI 来传输属性 props。\n在挂载阶段依然会使用 JNI 来发送变更操作。\n\nReact Native 团队在探索使用 ByteBuffer 序列化数据这种新的机制，来替换 ReadableMap，减少 JNI 的开销。目标是将 JNI 的开销减少 35~50%。\nfabric 提供了 C++ 与两边通信的 API\n\n\nReact 与渲染器的通信，\n包括渲染（render） React 树\n监听事件（event），比如 onLayout、onKeyPress、touch 等。\n\n\nReact Native 渲染器与宿主平台的通信，\n包括在屏幕上挂载（mount）宿主视图，包括 create、insert、update、delete 宿主视图，\n监听用户在宿主平台产生的事件。\n\n\n\n视图拍平视图拍平（View Flattening）是 React Native 渲染器避免布局嵌套太深的优化手段\nReact API 在设计上希望通过组合的方式，实现组件声明和重用，这为更简单的开发提供了一个很好的模型。但是在实现中，API 的这些特性会导致一些 React 元素会嵌套地很深，而其中大部分 React 元素节点只会影响视图布局，并不会在屏幕中渲染任何内容。这就是所谓的“只参与布局”类型节点。\n从概念上讲，React 元素树的节点数量和屏幕上的视图数量应该是 1:1 的关系。但是，渲染一个很深的“只参与布局”的 React 元素会导致性能变慢。\n\n\n\n\n\n\n\n\n\n大概意思：因为 React 组合设计实现组件复用。 组件复用嵌套多了，会出现很多无内容的布局节点，这些布局节点没啥用，多个连续嵌套的节点，在 fabric 中被一巴掌拍死打成一个肉饼，嗯～\n例子举个很常见的例子，例子中“只参与布局”视图导致了性能损耗。\n想象一下，你要渲染一个标题。你有一个应用，应用中拥有外边距 ContainerComponent 的容器组件，容器组件的子组件是 TitleComponent 标题组件，标题组件包括一个图片和一行文字。React 代码示例如下：\nfunction MyComponent() &#123;\n  return (\n    &lt;View&gt;                          &#x2F;&#x2F; ReactAppComponent\n      &lt;View style&#x3D;&#123;&#123;margin: 10&#125;&#125; &#x2F;&gt; &#x2F;&#x2F; ContainerComponent\n        &lt;View style&#x3D;&#123;&#123;margin: 10&#125;&#125;&gt; &#x2F;&#x2F; TitleComponent\n          &lt;Image &#123;...&#125; &#x2F;&gt;\n          &lt;Text &#123;...&#125;&gt;This is a title&lt;&#x2F;Text&gt;\n        &lt;&#x2F;View&gt;\n      &lt;&#x2F;View&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;\n\n拍平前React Native 在渲染时，会生成以下三棵树：\n\n\n为了提升 React 元素树中“只参与布局”类型的性能，渲染器实现了一种视图拍平的机制来合并或拍平这类节点，减少屏幕中宿主视图的层级深度。该算法考虑到了如下属性，比如 margin, padding, backgroundColor, opacity 等等。\n视图拍平算法是渲染器的对比（diffing）阶段的一部分，这样设计的好处是我们不需要额外的 CPU 耗时(不需要再遍历了，但是绝对是有 CPU 损耗的)，来拍平 React 元素树中“只参与布局”的视图。此外，作为 C++ 核心的一部分，视图拍平算法默认是全平台共用的。\n在前面的例子中，视图 2 和视图 3 会作为“对比算法”（diffing algorithm）的一部分被拍平，而它们的样式结果会被合并到视图 1 中。\n\n\n虽然，这种优化让渲染器少创建和渲染两个宿主视图，但从用户的角度看屏幕内容没有任何区别。\n拍平拍平后线程模型React Native 渲染器在多个线程之间分配 渲染流水线（render pipeline）任务。接下来我们会给线程模型下定义，并提供一些示例来说明渲染流水线的线程用法。\nReact Native 渲染器是线程安全的。\n从更高的视角看，在框架内部线程安全是通过不可变的数据结果保障的，其使用的是 C++ 的 const correctness 特性。这意味着，在渲染器中 React 的每次更新都会重新创建或复制新对象，而不是更新原有的数据结构。这是框架把线程安全和同步 API 暴露给 React 的前提。\n渲染器使用三个不同的线程：\n\nUI 线程（主线程）：唯一可以操作宿主视图的线程。\nJavaScript 线程：这是执行 React 渲染阶段的地方。\n后台线程：专门用于布局的线程。\n\n渲染场景在后台线程中渲染这是最常见的场景，大多数的渲染流水线发生在 JavaScript 线程和后台线程。\n\n\n在主线程中渲染当 UI 线程上有高优先级事件时，渲染器能够在 UI 线程上同步执行所有渲染流水线。\n\n\n默认或连续事件中断在这个场景中，UI 线程的低优先级事件中断了渲染步骤。React 和 React Native 渲染器能够中断渲染步骤，并把它的状态和一个在 UI 线程执行的低优先级事件合并。在这个例子中渲染过程会继续在后台线程中执行。\n\n\n不相干的事件中断渲染步骤是可中断的。在这个场景中， UI 线程的高优先级事件中断了渲染步骤。React 和渲染器是能够打断渲染步骤的，并把它的状态和 UI 线程执行的高优先级事件合并。在 UI 线程渲染步骤是同步执行的。\n\n\n来自 JavaScript 线程的后台线程批量更新在后台线程将更新分派给 UI 线程之前，它会检查是否有新的更新来自 JavaScript。 这样，当渲染器知道新的状态要到来时，它就不会直接渲染旧的状态。\n\n\nC++ 状态更新更新来自 UI 线程，并会跳过渲染步骤。更多细节请参考 React Native 渲染器状态更新。\n\n\nTurbo Modules\nTurbo Modules 基本上是对这些旧的 Native 模块的增强\n现在 JS 将能够持有这些模块的引用，所以 JS 代码可以仅在需要时才加载对应模块，这样可以将显着缩短 RN 应用的启动时间\n\nCodegenJavaScript 是一门动态语言，而 JSI 是用 C++写的，C++是一门静态语言，因此需要保证两者间的顺利通信。\n这就是新架构还包括一个名为 CodeGen 的静态类型检查器的原因。\nCodeGen 使用类型确定后的 JavaScript 来为 Turbo Modules 和 Fabric 定义供他们使用的接口元素，它会在构建时生成更多的 native 代码，而非运行时。\n————————————————版权声明：本文为 CSDN 博主「Lvan 的前端笔记」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43972437/article/details/122901903\n参考链接React Native Fabric (UI-Layer Re-architecture) #4\nFabric 渲染器\nReact Native 架构解析 - 一张图了解 Fabric\nReact 技术揭秘\n","slug":"2022-07-19rn-架构变更","date":"2022-07-19T02:33:57.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"21c81236c6b792525b47c142ae6ad187","title":"前端基础-设计模式","content":"为什么需要设计模式\n有助于写出可复用&#x2F;可维护性更高的程序\n原则：找出程序中变化的地方，并将变化封装起来，它的关键是意图，而不是结构\n\nSOLID 设计原则S: Single Responsibility Principle 单一职责原则\n对象应该仅具有一种单一功能\nO: OpenClosed Principle 开放&#x2F;封闭原则\n对扩展开放，对修改封闭\nL: 里氏替换原则\n子类能覆盖父类，父类能出现的地方，子类也能出现\nI: interface Segregation Principle 接口隔离原则\n保持接口的单一独立，避免出现“胖接口”。这点目前在 TS 中运用到\n有一个用户服务的接口，里面有注册，登录，查询，删除几个函数暴露给客户端，但是很明显删除函数只有后台管理模块可以用到，而且其他模块如果都可以使用的话就有可能照成误删用户。这就违背了接口隔离原则，我们需要把删除函数单独抽离出来给后台管理模块使用。\n作者：猫清扬链接：https://www.jianshu.com/p/63bd557f6ca4来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nD: Dependency Inversion Principle 依赖倒转原则\n面向接口编程，依赖于抽象而不依赖于具体。使用方只专注接口而不用关注具体类的实现。俗称“鸭子类型”\n常见的设计模式\n创建型：单例模式、工厂模式、原型模式\n结构型：装饰器模式、代理模式\n行为型：策略模式、模块方法模式、发布订阅模式。\n\n单例模式单例模式的思路是：保证一个类只能被实例一次，每次获取的时候，如果该类已经创建过实例则直接返回该实例，否则创建一个实例保存并返回。\n优点\n内存中只有一个实例，减少了内存的开销。\n避免了对资源多重的占用。\n\n缺点违反了单一职责，一个类应该只关心内部逻辑，而不用去关心外部的实现\n工厂模式工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂\n其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品\n举个例子：\n编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联(耦合)\n后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事;\n这种情况下，就需要将创建实例的工作从调用方(A 类)中分离，与调用方「解耦」，也就是使用工厂方法创建实例的工作封装起来(「减少代码重复」)，由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，「而降低调用者因为创建逻辑导致的错误」;\n优点\n调用者创建对象时只要知道其名称即可\n扩展性高，如果要新增一个产品，直接扩展一个工厂类即可。\n隐藏产品的具体实现，只关心产品的接口。\n\n缺点每次增加一个产品时，都需要增加一个具体类，这无形增加了系统内存的压力和系统的复杂度，也增加了具体类的依赖\n实现工厂模式根据抽象程度的不同可以分为：\n\n简单工厂模式(Simple Factory)\n工厂方法模式(Factory Method)\n抽象工厂模式(Abstract Factory)\n\n简单工厂模式简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例\n假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致\nfunction Factory(career) &#123;\n  function User(career, work) &#123;\n    this.career &#x3D; career;\n    this.work &#x3D; work;\n  &#125;\n  let work;\n  switch (career) &#123;\n    case &quot;coder&quot;:\n      work &#x3D; [&quot;写代码&quot;, &quot;修Bug&quot;];\n      return new User(career, work);\n      break;\n    case &quot;hr&quot;:\n      work &#x3D; [&quot;招聘&quot;, &quot;员工信息管理&quot;];\n      return new User(career, work);\n      break;\n    case &quot;driver&quot;:\n      work &#x3D; [&quot;开车&quot;];\n      return new User(career, work);\n      break;\n    case &quot;boss&quot;:\n      work &#x3D; [&quot;喝茶&quot;, &quot;开会&quot;, &quot;审批文件&quot;];\n      return new User(career, work);\n      break;\n  &#125;\n&#125;\n\nlet coder &#x3D; new Factory(&quot;coder&quot;);\nconsole.log(coder);\n\nlet boss &#x3D; new Factory(&quot;boss&quot;);\nconsole.log(boss);\n\n简单工厂方法工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的 prototype 中\n这样一来，扩展产品种类就不必修改工厂函数了，变成抽象类，也可以随时重写某种具体的产品\n也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产;但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产\n&#x2F;&#x2F; 工厂方法\nfunction Factory(career) &#123;\n  if (this instanceof Factory) &#123;\n    return new this[career]();\n  &#125; else &#123;\n    return new Factory(career);\n  &#125;\n&#125;\n&#x2F;&#x2F; 工厂方法函数的原型中设置所有对象的构造函数\nFactory.prototype &#x3D; &#123;\n  coder: function () &#123;\n    this.careerName &#x3D; &quot;程序员&quot;;\n    this.work &#x3D; [&quot;写代码&quot;, &quot;修Bug&quot;];\n  &#125;,\n  hr: function () &#123;\n    this.careerName &#x3D; &quot;HR&quot;;\n    this.work &#x3D; [&quot;招聘&quot;, &quot;员工信息管理&quot;];\n  &#125;,\n  driver: function () &#123;\n    this.careerName &#x3D; &quot;司机&quot;;\n    this.work &#x3D; [&quot;开车&quot;];\n  &#125;,\n  boss: function () &#123;\n    this.careerName &#x3D; &quot;老板&quot;;\n    this.work &#x3D; [&quot;喝茶&quot;, &quot;开会&quot;, &quot;审批文件&quot;];\n  &#125;,\n&#125;;\n\nlet coder &#x3D; new Factory(&quot;coder&quot;);\nconsole.log(coder);\n\nlet hr &#x3D; new Factory(&quot;hr&quot;);\nconsole.log(hr);\n\n抽象工厂模式上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建\n通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的\n由于 JavaScript 中并没有抽象类的概念，只能模拟，可以分成四部分：\n\n用于创建抽象类的函数\n抽象类\n具体类\n实例化具体类\n\n上面的例子中有 coder、hr、boss、driver 四种岗位，其中 coder 可能使用不同的开发语言进行开发，比如 JavaScript、Java 等等。那么这两种语言就是对应的类簇\nfunction CareerAbstractUserFactory(type) &#123;\n  switch (type) &#123;\n    case &quot;coder&quot;:\n      return UserOfCoder;\n    case &quot;hr&quot;:\n      return UserOfHR;\n    case &quot;driver&quot;:\n      return UserOfDriver;\n    case &quot;boss&quot;:\n      return UserOfBoss;\n    default:\n      throw new Error(&quot;参数错误, 可选参数:coder、hr、driver、boss&quot;);\n  &#125;\n&#125;\n\n上面代码中 CareerAbstractFactory 就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承\n应用场景工厂模式适用场景如下：\n\n如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择 flutter接口返回json数据转化成实例\n将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式;\n需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性\n\n说说你对工厂模式的理解？应用场景？JavaScript 设计模式与实践–工厂模式\n原型模式原型模式是指原型实例指向创建对象的种类，通过拷贝这些原型来创建新的对象，说白了就是克隆自己，生成一个新的对象。\n优点不再依赖构造函数或者类创建对象，可以将这个对象作为一个模板生成更多的新对象。\n缺点对于包含引用类型值的属性来说，所有实例在默认的情况下都会取得相同的属性值。\n&#x2F;&#x2F; Object.create\nconst user &#x3D; &#123;\n  name: &quot;小明&quot;,\n  age: &quot;30&quot;,\n  getInfo() &#123;\n    console.log(&#96;姓名：$&#123;this.name&#125;，年龄：$&#123;this.age&#125;&#96;);\n  &#125;,\n&#125;;\nconst xiaozhang &#x3D; Object.create(user);\nxiaozhang.name &#x3D; &quot;小张&quot;;\nxiaozhang.age &#x3D; 18;\n\nxiaozhang.getInfo(); &#x2F;&#x2F; 姓名：小张，年龄：18\nuser.getInfo(); &#x2F;&#x2F; 姓名：小明，年龄：30\n\n代理模式场景HTML 元 素事件代理\n&lt;ul id&#x3D;&quot;ul&quot;&gt;\n  &lt;li&gt;1&lt;&#x2F;li&gt;\n  &lt;li&gt;2&lt;&#x2F;li&gt;\n  &lt;li&gt;3&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n&lt;script&gt;\n  let ul &#x3D; document.querySelector(&#39;#ul&#39;);\n  ul.addEventListener(&#39;click&#39;, event &#x3D;&gt; &#123;\n    console.log(event.target);\n  &#125;);\n&lt;&#x2F;script&gt;\n\n优点\n代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。\n代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用\n代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；\n\n缺点处理请求速度可能有差别，非直接访问存在开销\n作者：四叶舟链接：https://www.jianshu.com/p/19a8c1d76257来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n发布订阅模式（eventbus）模块方法模式模块方法模式是一种基于继承的设计模式，\n在 javascript 中没有真正意义上的继承，所有继承都来自原型(prototype)上的继承，随着 ES6 的 class 到来，实现了继承的“概念”，让我们可以以一种很方便简洁的方式继承，但其本质上还是原型继承。\n模板方法模式由两部分组成，第一部分是抽象父类，第二部分是具体的实现子类。\n\n抽象父类主要封装了子类的算法框架，以及实现了一些公共的方法和其他方法的执行顺序。\n子类通过继承父类，继承了父类的算法框架，并进行重写。\n\n优点提供公共的代码便于维护。行为由父类控制，具体由子类来实现。\n缺点其每一个具体实现都需要继承的子类来实现，这无疑导致类的个数增加，使得系统庞大。\n策略模式装饰器模式https://www.bilibili.com/video/BV1WK411G7QH?spm_id_from=333.337.search-card.all.click\n参考链接前端常见的 9 种设计模式\njavascript 的 23 种设计模式\n","slug":"2022-07-18设计模式","date":"2022-07-18T06:53:04.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"04f522a5377d4d5450ce4cf8a54e76ff","title":"前端基础-CSS3","content":"浏览器工作原理\n\n\n\n\n\n\n\n\n当浏览器展示一个文件的时候，它必须兼顾文件的内容和文件的样式信息\n如何加载 CSS 和 HTML下面的步骤是浏览加载网页的简化版本:\n\n浏览器载入 HTML 文件（比如从网络上获取）。\n将 HTML 文件转化成一个 DOM（Document Object Model），DOM 是文件在计算机内存中的表现形式，下一节将更加详细的解释 DOM。\n接下来，浏览器会拉取该 HTML 相关的大部分资源，比如嵌入到页面的图片、视频和 CSS 样式。JavaScript 则会稍后进行处理，简单起见，同时此节主讲 CSS，所以这里对如何加载 JavaScript 不会展开叙述。\n浏览器拉取到 CSS 之后会进行解析，根据选择器的不同类型（比如 element、class、id 等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。\n上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。\n网页展示在屏幕上（这一步被称为着色）。\n\n运行图\n\n\n\n\n无法解析的 CSS 会发生什么\n\n\n\n\n\n\n\n\n答案就是浏览器什么也不会做，继续解析下一个 CSS 样式！\n以下是废话：\n\n浏览器并不会同时实现所有的新 CSS，此外很多人也不会使用最新版本的浏览器。鉴于 CSS 一直不断的开发，因此领先于浏览器可以识别的范围，那么你也许会好奇当浏览器遇到无法解析的 CSS 选择器或声明的时候会发生什么呢？\nCSS 规则： 如果一个浏览器在解析你所书写的 CSS 规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的 CSS 声明。在你书写了错误的 CSS 代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的 CSS 代码的时候上述的情况同样会发生（直接忽略）。\n选择器： 相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个 CSS 选择器。\n\n为什么要理解 DOM对于 DOM 的理解会很大程度上帮助你设计、调试和维护你的 CSS，因为 DOM 是你的 CSS 样式和文件内容的结合。当你使用浏览器 F12 调试的时候你需要操作 DOM 以查看使用了哪些规则。\n关于 DOM\n一个 DOM 有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node&#x2F;DOM 或 DOM node）。\n节点由节点本身和其他 DOM 节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。\n\n&lt;p&gt;\n  Let&#39;s use:\n  &lt;span&gt;Cascading&lt;&#x2F;span&gt;\n  &lt;span&gt;Style&lt;&#x2F;span&gt;\n  &lt;span&gt;Sheets&lt;&#x2F;span&gt;\n&lt;&#x2F;p&gt;\n\nP\n├─ &quot;Let&#39;s use:&quot;\n├─ SPAN\n|  └─ &quot;Cascading&quot;\n├─ SPAN\n|  └─ &quot;Style&quot;\n└─ SPAN\n   └─ &quot;Sheets&quot;\n\n\n参考MDN\nCSS 选择器的优先级是怎样的CSS 选择器的优先级是：（标签选择器 &lt; 类选择器 &lt; ID 选择器） &lt; 内联 &lt; !important &lt; 特殊情况 \n到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：\n\nA 的值等于 1 的前提是存在内联样式, 否则 A &#x3D; 0;\nB 的值等于 ID 选择器 出现的次数;\nC 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;\nD 的值等于 标签选择器 和 伪元素 出现的总次数 。\n\n就⽐如下⾯的选择器，它不存在内联样式，所以 A&#x3D;0,不存在 id 选择器 B&#x3D;0,存在⼀个类选择器 C&#x3D;1,存在三个标签选择器 D&#x3D;3，那么最终计算结果为:\nul ol li .red &#123; ... &#125;\n &#x2F;* &#123;0, 0, 1 ,3&#125; *&#x2F;\n\n按照这个结算⽅式，下⾯的计算结果为:\n#red &#123; &#125;\n &#x2F;* &#123;0, 1, 0, 0&#125; *&#x2F;\n\n\n⽐较优先级的⽅式是从 A 到 D 去⽐较值的⼤⼩，A、B、C、D 权重从左到右，依次减⼩。判断优先级时，从左到右，⼀⼀⽐较，直到⽐较出最⼤值，即可停⽌。\n⽐如第⼆个例⼦的 B 与第⼀个例⼦的 B 相⽐，1&gt;0,接下来就不需要⽐较了，第⼆个选择器的优先级更⾼。\n比!important更高的优先级从三个方面来说： H5 标签、CSS3 样式、媒体查询、文件关系\n\npicture source\nimage srcset\nmax-width、min-width\nmedia媒体查询\n同是!important，内部文件优先于外部文件， link 优先于@import\nantd :global 样式覆盖(CSS Modules 的基本原理很简单，就是对每个类名（非 :global 声明的）按照一定规则进行转换，保证它的唯一性)\n\n见 antd\nlink 和@import 的区别\nlink 属于 XHTML 标签，⽽@import 是 CSS 提供的。\n⻚⾯被加载时，link 会同时被加载，⽽@import 引⽤的 CSS 会等到⻚⾯被加载完再加载。\nimport 只在 IE 5 以上才能识别，⽽ link 是 XHTML 标签，⽆兼容问题。\nlink ⽅式的样式权重⾼于@import 的权重。\n使⽤ dom 控制样式时的差别。当使⽤ javascript 控制 dom 去改变样式的时候，只能使⽤ link 标签，因为@import 不是 dom 可以控制的。\n\nCSS 隐藏⻚⾯元素占据空间可交互\nopacity:0 ：本质上是将元素的透明度将为 0，就看起来隐藏了，但是依然占据空间可交互\n\n占据空间不可交互\nvisibility:hidden : 与上⼀个⽅法类似的效果，占据空间不可交互\noverflow:hidden : 这个只隐藏元素溢出的部分，占据空间不可交互\ntransform: scale(0,0) : 平⾯变换，将元素缩放为 0，占据空间不可交互\ntransform: : 移出可视区域占据空间不可交互\nposition: relative: 移出可视区域占据空间不可交互\n\n不占据空间不交互\ndisplay:none : 这个是彻底隐藏了元素，元素从⽂档流中消失，不占据空间不交互\nz-index:-9999 : 原理是将层级放到底部，这样就被覆盖了，不占据空间不交互\n\n\n\n\n分类\n属性\n\n\n\n占据空间可交互\nopacity:0 \n\n\n占据空间不可交互\n1. visibility:hidden、overflow:hidden 、  2. transform: scale(0,0)、transform: 移出可视区域 、 3. position: relative + left 负值 \n\n\n不占据空间不交互\ndisplay:none、 z-index:-9999 \n\n\nem\\px\\rem 区别\npx：绝对单位，⻚⾯按精确像素展示。\nem：相对单位，基准点为⽗节点字体的⼤⼩，如果⾃身定义了 font-size 按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内 1em 不是⼀个固定的值。\nrem：相对单位，可理解为”root em”, 相对根节点 html 的字体⼤⼩来计算，CSS3 新加属性，chrome&#x2F;firefox&#x2F;IE9+⽀ 持\n\n块级元素⽔平居中的⽅法如果使⽤ Hack 的话，⽔平居中的⽅法⾮常多，主流的，奇葩的⻅拓展阅读\n\nmargin:0 auto ⽅法\n\n&lt;style&gt;\n  .center &#123;\n    height: 200px;\n    width: 200px;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;\n\n\nflex 布局，⽬前主流⽅法\n\n&lt;style&gt;\n  .center&#123; display:flex; justify-content:center; 9 &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;1&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;flex-div&quot;&gt;2&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\ntable ⽅法 标签打印时候遇到\n\n&lt;style&gt;\n  .center &#123;\n    display: table;\n    margin: 0 auto;\n    border: 1px solid red;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;\n\n还有⼀些通过 position+(margin|transform)等⽅法的不⼀样列举了，⾮重点没必要\nCSS 5 种定位⽅式见：2022-06-16interview\n\n\n\n\n\n\n\nWARNING\n需要注意 BFC 的影响，position:fixed 没有相对浏览器窗口定位的原因 transform 冲突,注：在虚拟列表时候会遇到\n\n层叠上下文是什么\n层叠上下⽂是 HTML 元素的三维概念，\nHTML 元素在⼀条假想的，相对于⾯向（电脑屏幕的）视窗或者⽹⻚的， z 轴上延伸，\nHTML 元素依据其⾃身属性,按照优先级顺序, 占⽤层叠上下⽂的空间。\n\n可以理解为 JS 中的作用域，一个页面中往往不仅仅只有一个层叠上下文\n如何产⽣？触发以下条件则会产⽣层叠上下⽂：\n默认创建层叠上下文\n\n根元素 (HTML)\n\n需要配合 z-index 触发创建层叠上下文\n\nz-index + position值不为 “auto”的 绝对&#x2F;相对定位\nz-index + flex ⼀个 z-index 值不为 “auto”的 flex 项⽬ (flex item)，即：⽗元素 display: flex|inline-flex\n\n不需要配合 z-index 触发创建层叠上下文\n\nopacity 属性值⼩于 1 的元素（参考 the specification for opacity）\n\n元素的以下属性的值不是 none：\n\ntransform\nfilter 滤镜\nperspective 3D 元素距视图的距离,以像素计\nclip-path 裁剪图片\n mask / mask-image / mask-border\n\n\nisolation 属性被设置为 “isolate”的元素 使用 isolation:isolate 进行阻断，形成一个混合组。组以外的其他元素不会发生层叠。\n\n在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇⽂章）\n\n-webkit-overflow-scrolling 属性被设置 “touch”的元素 (使用滚动回弹效果), 在 iOS 13 之后，不需要 见\n\n\n\n深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 \n\n有什么特点向上、向下、平级、跨层级上下文\n\n创建了层叠上下文的元素只影响其子孙代元素，它自身的层叠水平是由它的父层叠上下文所决定的\n当两个元素层叠级别相同的时候，这时候就要遵循下面两个准则：\n后来居上原则\n谁 z-index 大，谁在上的准则\n\n\n对于 z-index 属性而言:\nz-index 属性控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，可以修改 z-index 来控制元素的图层 位置，⽽且 z-index 只能影响设置了 position 值的元素 和 flex元素\nz-index 属性是个“拼爹”的属性。(如果父元素层级低，那么子元素再怎么努力都没有用 )\n\n\n是否同一上下文：\n如果是在不同的层叠上下文中，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下, 这个两个元素所在的局部层叠上下文的层叠水平。\n如果是在相同的层叠上下文，按照层叠水平的规则来显示元素; 层叠级别相同，后来居上\n\n\n\n如何理解 z-index？CSS 中的 z-index 属性控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，可以修改 z-index 来控制元素的图层 位置，⽽且 z-index 只能影响设置了 position 值的元素。这个属性是个“拼爹”的属性。(如果父元素层级低，那么子元素再怎么努力都没有用 )见\n7 阶层叠 -->\n\n\n上图从底到上：\n背景 ---------&gt; 布局相关 -------&gt; 内容相关 ---------------------------------&gt;\n      |                                   |                    ｜\nz-index负值                            z-index0&#x2F;不依赖z-index   z-index正值\n\n\n如果元素的层叠级别一样，没有别的因素干扰，则遵循后来者居上原则。见\n\nCSS 7 阶层叠水平\n如何比较两个 DOM 元素的显示顺序呢\n\n\n如果是在不同的层叠上下文中，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下, 这个两个元素所在的局部层叠上下文的层叠水平。\n如果是在相同的层叠上下文，按照层叠水平的规则来显示元素; 层叠级别相同，后来居上\n\n为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？\n因为 float 和块级元素一般都作布局，内联元素都是内容。\n而一个网页中最重要的就是内容，所以一定要让内容的层叠顺序相当高，这样可以在发生层叠时，重要的图片、文字内容可以优先暴露在屏幕上。\n\n重学前端之 CSS(三)BFC 与层叠上下文\n块级格式化上下文BFC 是什么?书⾯解释：BFC(Block Formatting Context)这⼏个英⽂拆解\n\nBox: CSS 布局的基本单位，Box 是 CSS 布局的对象和基本单位， 直观点来说，就是⼀个⻚⾯是由很多个 Box 组成的，实际就是上个问题说的盒模型\nFormatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤\n简⽽⾔之，它是⼀块独⽴的区域，让处于 BFC 内部的元素与外部的元素互相隔离\n\nMDN 说法:\n\nWeb 页面的可视 CSS 渲染的一部分，\n是块级盒子的布局过程发生的区域，\n也是浮动元素与其他元素交互的区域\n\n如何形成?BFC 触发条件:\n\n\n\n根元素（&lt;html&gt;）\n布局相关\n浮动元素（float 值不为 none）\n绝对定位元素（position 值为 absolute 或 fixed）\n行内块元素（display 值为 inline-block）\ndisplay 值为 flow-root 的元素\noverflow 值不为 visible、clip 的块元素\ncontain 值为 layout、content、paint 的元素\n\n\n表格展示\n表格单元格（display 值为 table-cell，HTML 表格单元格默认值）\n表格标题（display 值为 table-caption，HTML 表格标题默认值）\n匿名表格单元格元素（display 值为\ntable、\ntable-row、\ntable-row-group、\ntable-header-group、\ntable-footer-group （分别是 HTML: table、tr、tbody、thead、tfoot 的默认值）或 inline-table）\n\n\n\n\n内盒子\n弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身不是 flex、grid、table 容器\n网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身不是 flex、grid、table 容器\n\n\ncolumn 相关的\n多列容器（column-count 或 column-width (en-US) 值不为 auto，包括 column-count 为 1）\ncolumn-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中\n\n\n\nBFC 特点BFC 的特点\n\n在一个 BFC 内部，\n(垂直方向)盒子会在垂直方向上排列，相邻的 margin-bottom 和 margin-top 叠加\n(水平方向)每个元素左边紧贴着包含盒子的左边，如果有一个内部元素是一个新的 BFC，则新 BFC 区域不会与 float 元素的区域重叠\n\n\n计算一个 BFC 高度时，内部浮动元素的高度也会参与计算\n\n作⽤是什么？格式化上下文影响布局，通常，我们会为定位和清除浮动创建新的 BFC，而不是更改布局\n\n包含 内部浮动\n排除 外部浮动\n阻止 外边距重叠\n\n盒模型介绍下盒模型\n\n见\n盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。\n标准盒模型&#x2F;怪异盒模型在 W3C 标准下，我们定义元素的 width 值即为盒模型中的 content 的宽度值，height 值即为盒模型中的 content 的⾼度值。 因此，\n标准盒模型下：\n元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right\n\n\nIE 怪异盒模型\n（IE8 以下）width 的宽度并不是 content 的宽度，⽽是\n元素的宽度 = margin-left + width + margin-right\n对于 width,\nwidth = border-left + padding-left + content 的宽度值 + padding-right + border-right，height 同理。\n\n\n现代浏览器默认使⽤ W3C 的标准盒模型，在不少情况下怪异盒模型更好⽤，于是 W3C 在 css3 中加⼊ box-sizing 。\nbox-sizing: content-box &#x2F;&#x2F; 标准盒模型box-sizing: border-box &#x2F;&#x2F; 怪异盒模型box-sizing: padding-box &#x2F;&#x2F; ⽕狐的私有模型，没⼈⽤\nflex可以使用一个，两个或三个值来指定 flex 属性。\nnone&#x2F;initial&#x2F;auto\n\n\n单值\n等效于\n作用\n\n\n\nnone\nflex: 0 0 auto\n既不会缩短，也不会伸长\n\n\ninitial\nflex: 0 1 auto\n会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中额外的自由空间\n\n\nauto\nflex: 1 1 auto\n会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应\n\n\nnumber\nflex: number 1 0\n会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应\n\n\nwidth\nflex: 1 1 width\n会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应\n\n\n&#x2F;#&#x2F;post&#x2F;2022-05-23width0\nnone\n元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长 来适应 flex 容器。相当于将属性设置为&quot;flex: 0 0 auto&quot;。\ninitial\n元素会根据自身宽高设置尺寸。它 会缩短自身以适应 flex 容器，但不会伸长并吸收  flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为&quot;flex: 0 1 auto&quot;。\nauto\n元素会根据自身的宽度与高度来确定尺寸，但是 会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 &quot;flex: 1 1 auto&quot;.\n默认值flex-grow: 0\nflex-shrink: 1\nflex-basis: auto\n\n单值语法:值必须为以下其中之一:\n\n一个无单位数(&lt;number&gt;): 它会被当作 flex:&lt;number&gt; 1 0; 解释：&lt;flex-shrink&gt;的值被假定为 1，然后&lt;flex-basis&gt; 的值被假定为 0。\n一个有效的宽度(width)值: 它会被当作 &lt;flex-basis&gt;的值。\n关键字 none，auto 或 initial.\n\n双值语法:\n第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。\n第二个值：无单位数：它会被当作 &lt;flex-shrink&gt; 的值。\n第二个值：有效的宽度值: 它会被当作 &lt;flex-basis&gt; 的值。\n\n三值语法:\n第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。\n第二个值必须为一个无单位数，并且它会被当作 &lt;flex-shrink&gt; 的值。\n第三个值必须为一个有效的宽度值， 并且它会被当作 &lt;flex-basis&gt; 的值。\n\n见\n介绍下 flexflex 出现解决了什么问题长久以来，CSS 布局中唯一可靠且跨浏览器兼容的创建工具只有 float 和 position。这两个工具大部分情况下都很好使，但是在某些方面它们具有一定的局限性，让人难以完成任务\n\n在父内容里面垂直居中一个块内容。\n使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度&#x2F;高度可用。\n使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。\n\n弹性盒子使得很多布局任务变得更加容易\nflex 布局的特点\n\n\n主轴\n交叉轴\nflex 容器（flex container）\nflex 项(flex item)\n\n行还是列flex-direction\n\n换行flex-wrap: wrap; &#x2F;**换行 *&#x2F;\n\nflex-flowflex-direction: row;\nflex-wrap: wrap;\n\n&#x2F;* 简写 *&#x2F;\nflex-flow: row wrap;\n\nalign-items\n默认值：stretch, 会使 flex 项沿着交叉轴的方向拉伸，以填充父容器\ncenter\nflex-start,flex-end,在交叉轴开始&#x2F;结束处对齐\n\njustify-content\n默认值：flex-start, 会使所有的 flex 项都位于主轴开始处\nflex-end 使 flex 项位于结尾处\ncenter, 让 flex 项在主轴中居中\nspace-around 使所有 flex 项在主轴均匀分布，任意一端会留一点空间\nspace-between 与 space-around 类似，两端不留空间\n\nflex 项排序可以改变 flex 项的布局位置的功能，而不会影响 dom 树里元素的顺序\n\n默认 order 使 0\norder 越大越靠后\n相同 order，按 dom 树顺序排布（也就是没啥影响）\n\n媒体查询深入理解 CSS Media 媒体查询\n是什么媒体查询包含⼀个可选的媒体类型和，满⾜ CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为 true 或 false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式 的值都是 true，那么该媒体查询的结果为 true.那么媒体查询内的样式将会⽣效。媒体查询，用于响应适配。\n如何使⽤？\n\n\n\n\n\n\nWARNING\n媒体属性必须用括号()包起来，否则无效\n\n&lt;!-- link元素中的CSS媒体查询 --&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;(max-width: 800px)&quot; href&#x3D;&quot;example.css&quot; &#x2F;&gt;\n&lt;!-- 样式表中的CSS媒体查询 --&gt;\n&lt;style&gt;\n  @media (max-width: 600px) &#123;\n    .facet_sidebar &#123;\n      display: none;\n    &#125;\n  &#125;\n&lt;&#x2F;style&gt;\n\n常见媒体属性\n设备宽度（device-width）\n设备高度（device-height）\n方向（orientation）值：landscape(横屏)、portrait(竖屏)\n设备宽高比（device-aspect-ratio）\n分辨率（resolution）像素密度\n\nprint&#x2F;screen不用括号\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot; media&#x3D;&quot;print&quot; &#x2F;&gt;\n\n&lt;style&gt;\n  @media print &#123;\n  &#125;\n&lt;&#x2F;style&gt;\n\n逻辑操作符操作符 not、and、only 和逗号(,)可以用来构建复杂的媒体查询\n相对单位如果媒体查询@media 使用的是相对单位，如 rem，这里有一个坑需要着重强调一下\n一般而言，rem 是相对于 HTML 的字体大小的。但是，由于媒体查询的级别非常高，它并不是 HTML 的子元素，不是相对于 HTML，而是相对于浏览器的，而浏览器的默认字体大小是 16px\n如果 HTML 设置字体大小为 12px，设置如下媒体查询\nmedia&#x3D;&quot;only screen and (max-width:1rem)&quot;\n\n实际上，max-width 等于 16px，而不是 12px\n而正是由于媒体查询是相对于浏览器的， 所以使用 rem 就没有必要，完全可以使用 em 来替代\nmedia&#x3D;&quot;only screen and (max-width:1em)&quot;\n\n回流和重绘\n\n浏览器渲染机制\n浏览器采用流式布局\n浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就形成渲染树\n有了渲染树，我们就知道所有节点的样式，然后计算他们在页面上的大小和位置，把它们绘制到页面上\n\n\n\n\n\n\n\n\n\n\n注意：浏览器采用流式布局，对渲染树的计算只需要遍历一次就能完成，但 table 布局除外，他需要花费 3 倍的时间 ，所以我们要尽量避免使用 table 布局\n回流\n影响部分或全部页面的布局时，会进行回流，回流的代价比重绘高\n回流一定会引起重绘，但重绘不一定会引起回流\n\n重绘元素样式发生变化，但是不影响页面整个布局的情况下会进行重绘，如：\n\noutline\nvisibility\nopacity\ncolor\nbackground-color 等\n\n浏览器优化更新机制\n浏览器是通过队列机制,来批量更新布局，浏览器刷新频率为（60 帧&#x2F;s）,每刷新一次需要 16.6ms，也就是说 16.6ms 浏览器会清空队列，\n但是在我们获取布局信息的时候，有一些属性或方法会强制浏览器刷新，触发重绘和回流并且清空队列，比如：\n\n触发回流&#x2F;重绘的 API\n\nwidth、height\noffset 相关：offsetTop、offsetLeft、offsetWidth、offsetHeight 距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent 为 body\nscroll 相关： scrollTop、scrollLeft、scrollWidth、scrollHeight 方法返回或设置匹配元素的滚动条的偏移位置\nclient 相关：clientTop、clientLeft、clientWidth、clientHeight clientTop、clientLeft 获取的是上边框、左边框的宽度 见 MDN\ngetComputedStyle() 用于获取指定元素的 CSS 样式\ngetBoundingClientRect() 用于获取某个元素相对于视窗的位置集合。集合中有 top, right, bottom, left 等属性。\n\n\n强制触发浏览器刷新,所以我们要尽量少使用以上属性和方法\n减少重绘和回流\nDOM嵌套层级\n尽可能在 DOM 树的末端改变样式类 class，影响尽量少的节点\ncss 选择器尽量不要嵌套过深，从右往左匹配\n\n\n使用 documentFragment,批量更新，虚拟 dom\n替代方案\n使用 transform 代替 top\n使用 visibility(只触发重绘)代替 display(触发回流)\n\n\ncss 表达式避免使用 css 表达式，calc()会引发回流\n设为图层将频繁重绘或回流的节点设置为图层，如：will-change，video，iframe，cavas，防止影响别的节点\n动画\n动画效果最好添加到 position：absolute 或 fixed 的元素上，不影响其他元素，只引发重绘，不引发回流，\n控制动画的速度可以使用 requestAnimationFrame()\n\n\nCSS3 硬件加速，transform，opacity 等不会引起回流重绘\n\n参考链接\n层叠、优先级和继承决定着如何将 CSS 应用到 HTML 中，以及如何解决冲突。\n层叠\n简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。\n\n三要素：资源顺序，优先级，重要程度\n优先级\n高的优先级——它范围更小\n覆盖 !important 唯一的办法就是另一个 !important 具有相同优先级而且顺序靠后，或者更高优先级。\n!important 非必要不使用，影响调试\n\n见\n继承\n表单元素默认不会继承字体样式\n\n见\ndisplay: inline-block在内联和块之间提供了一个中间状态。这对于以下情况非常有用：您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠\n当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。 是像  一样的内联元素；你可以使用 display: inline-block 来设置内边距，让用户更容易点击链接\n见\n百分比使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的内联尺寸进行计算的，也就是元素的水平宽度。在我们的示例中，所有的外边距或填充都是宽度的 10%。请记住一个事实，当你使用百分比作为元素外边距或填充的单位时，你将得到一个相同尺寸的外边距或填充。\nmax-width 的常见用法在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。\n作为示例，如果你设定一个图像的属性为 width: 100%，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。\n如果你使用了 max-width: 100%，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的 100%。\n见\n这个技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放\nobject-fit替换元素 与 普通元素的区别什么是替换元素图像和视频被描述为替换元素\n与普通区别\nCSS 不能影响它们的内部布局, 仅影响它们在页面上相对于其它元素的位置\nflex 或者 grid 布局中，默认情况下元素会被拉伸到充满整块区域。但是图像不会被拉伸，而会对齐到网格区域或者弹性容器的起始处。\n\n介绍下 Web 字体声明及使用CSS 有一个@font-face 块，它指定要下载的字体文件：\n@font-face &#123;\n  font-family: &quot;myFont&quot;;\n  src: url(&quot;myFont.ttf&quot;);\n&#125;\n\n&#x2F;* 使用 *&#x2F;\nhtml &#123;\n  font-family: &quot;myFont&quot;, &quot;Bitstream Vera Serif&quot;, serif;\n&#125;\n\n&#x2F;* 详细使用 *&#x2F;\n@font-face &#123;\n  font-family: &quot;ciclefina&quot;;\n  src: url(&quot;fonts&#x2F;cicle_fina-webfont.eot&quot;);\n  &#x2F;* 字体路径及文件格式 *&#x2F;\n  src: url(&quot;fonts&#x2F;cicle_fina-webfont.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.woff2&quot;) format(&quot;woff2&quot;),\n    url(&quot;fonts&#x2F;cicle_fina-webfont.woff&quot;) format(&quot;woff&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.ttf&quot;) format(&quot;truetype&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.svg#ciclefina&quot;) format(&quot;svg&quot;);\n  font-weight: normal;\n  font-style: normal;\n&#125;\n\n字体使用注意点兼容性例如，\n\n大多数现代浏览器都支持 WOFF &#x2F; WOFF2(Web Open Font Format versions 1 and 2，Web 开放字体格式版本 1 和 2)，它是最有效的格式，\n但是旧版本 IE 只支持 EOT (Embedded Open Type，嵌入式开放类型) 的字体，\n你可能需要包括一个 SVG 版本的字体支持旧版本的 iPhone 和 Android 浏览器。\n\n付费字体一般都不能自由使用。您必须为他们付费，或者遵循其他许可条件，比如在代码中 (或者在您的站点上) 提供字体创建者。你不应该在没有适当的授权的情况下偷窃字体。\n字体查找见\nfloat产生的背景\n引入 float 属性是为了能让 Web 开发人员实现简单的布局，\n包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面上看到过\n\n浮动是如何工作的\n浮动元素 (这个例子中的 &lt;div&gt; 元素) 会脱离正常的文档布局流，\n并吸附到其父容器的左边（这个例子中的 &lt;body&gt; 元素）。\n位于该浮动元素之下的正常布局中内容，此时会围绕着浮动元素，填满其右侧的空间\n\n清除浮动 3 中方式\n伪元素方法\n形成 BFC\n使用 overflow : 将包裹元素的 overflow 属性设置为除 visible 外的其他值\ndisplay: flow-root: 一个较为现代的方案是使用 display 属性的 flow-root 值\n\n\n\n&#x2F;* 伪元素方法 *&#x2F;\n.wrapper::after &#123;\n  content: &quot;&quot;;\n  clear: both;\n  display: block;\n&#125;\n&#x2F;* 将包裹元素的 overflow 属性设置为除 visible 外的其他值 *&#x2F;\n.wrapper &#123;\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  overflow: auto;\n&#125;\n\n.wrapper &#123;\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  display: flow-root;\n&#125;\n\n\n\n响应式设计响应式 Web 设计不是单独的技术，它是描述 Web 设计的一种方式、或者是一组最佳实践的一个词，它是用来建立可以响应查看内容的设备的样式的一个词\n出现的背景响应式设计之前的灵活布局，根据不同屏幕分辨率进行探测，载入对应的 css\n响应式设计包含三部分\n液态网格\n液态图像\n媒体查询\n\n响应式设计\n断点：媒体查询，以及样式改变时的点，被叫做断点（breakpoints）\n移动优先：为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局\n\n响应式图像\n可以用一张有着所需最大尺寸的图像。然后缩放它\n响应式图像，使用了&lt;picture&gt;元素和&lt;img&gt; srcset 和 sizes 特性，解决了这两个问题\n\n&#x2F;* 方案1 *&#x2F;\nimg &#123;\n  max-width: 100%:\n&#125;\n\n&#x2F;* 方案2，响应式图像 *&#x2F;\n\n\n视口元标签&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1&quot; &#x2F;&gt;\n\n为什么需要视口元标签\n因为移动端浏览器倾向于在它们的视口宽度上说谎。\n由于原来 iPhone 发布以后，人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为 960 像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本\n其他的移动端浏览器（例如谷歌安卓上的）也是这么做的\n没有做响应式的网站，依然可以看到，不过，很少见了\n\n媒体查询仅在浏览器和设备的环境与你指定的规则相匹配的时候 CSS 才会真的被应用\n语法规则&#x2F;* 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕） *&#x2F;\n&#x2F;* 媒体类型： all、print、screen、speech *&#x2F;\n&#x2F;* 一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试； *&#x2F;\n&#x2F;* 宽和高，orientation portrait：竖屏 landscape 横屏 *&#x2F;\n&#x2F;* 一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。 *&#x2F;\n@media media-type and (media-feature-rule) &#123;\n  &#x2F;* CSS rules go here *&#x2F;\n&#125;\n\n与&#x2F;或&#x2F;非&#x2F;* 与：使用and *&#x2F;\n@media screen and (min-width: 400px) and (orientation: landscape) &#123;\n  body &#123;\n    color: blue;\n  &#125;\n&#125;\n&#x2F;* 或：使用逗号 *&#x2F;\n@media screen and (min-width: 400px), screen and (orientation: landscape) &#123;\n  body &#123;\n    color: blue;\n  &#125;\n&#125;\n&#x2F;* 非：使用not *&#x2F;\n@media not all and (orientation: landscape) &#123;\n  body &#123;\n    color: blue;\n  &#125;\n&#125;\n\n选择断点开发工具响应式设计模式能很好地帮助弄清楚断点应该设置在哪里。你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。\n参考链接深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 \nCSS 7 阶层叠水平\nBFC 的特点\n深入理解 CSS Media 媒体查询\nflex width:0\n","slug":"2022-07-17css","date":"2022-07-17T07:39:25.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"2854d1d5923e1e62aed568f709662bf4","title":"前端基础-html","content":"doctype 的作⽤是什么？DOCTYPE 是 html5 标准⽹⻚声明，且必须声明在 HTML ⽂档的第⼀⾏。\n来告知浏览器的解析器⽤什么⽂档标准解析这个⽂档，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析\n⽂档解析类型有：\n\nBackCompat：怪异模式，浏览器使⽤⾃⼰的怪异模式解析渲染⻚⾯。（如果没有声明 DOCTYPE，默认就是这个 模式）\nCSS1Compat：标准模式，浏览器使⽤ W3C 的标准解析渲染⻚⾯。\n\n这三种模式的区别是什么？\n标准模式(standards mode)：⻚⾯按照 HTML 与 CSS 的定义渲染\n怪异模式(quirks mode)模式： 会模拟更旧的浏览器的⾏为\n近乎标准(almost standards)模式： 会实施了⼀种表单元格尺⼨的怪异⾏为（与 IE7 之前的单元格布局⽅式⼀致）， 除此之外符合标准定义\n\nHTML、XHTML、XML 有什么区别\nHTML(超⽂本标记语⾔): 在 html4.0 之前 HTML 先有实现再有标准，导致 HTML ⾮常混乱和松散\nXML(可扩展标记语⾔): 主要⽤于存储数据和结构，可扩展，⼤家熟悉的 JSON 也是相似的作⽤，但是更加轻量⾼ 效，所以 XML 现在市场越来越⼩了\nXHTML(可扩展超⽂本标记语⾔): 基于上⾯两者⽽来，W3C 为了解决 HTML 混乱问题⽽⽣，并基于此诞⽣了 HTML5，开头加⼊ &lt;!DOCTYPE html&gt; 的做法因此⽽来，如果不加就是兼容混乱的 HTML，加了就是标准模式。\n\n什么是 data-属性？HTML 的数据属性，⽤于将数据储存于标准的 HTML 元素中作为额外信息,可以通过 js 访问并操作它，来达到操作数据的⽬的。\n&lt;article\n  id&#x3D;&quot;electriccars&quot;\n  data-columns&#x3D;&quot;3&quot;\n  data-index-number&#x3D;&quot;12314&quot;\n  data-parent&#x3D;&quot;cars&quot;\n&gt;\n  ...\n&lt;&#x2F;article&gt;\n\n你对 HTML 语义化的理解？语义化是指使⽤恰当语义的 html 标签，让⻚⾯具有良好的结构与含义，⽐如 &lt;p&gt; 标签就代表段落， &lt;article&gt; 代表正⽂ 内容等等。 语义化的好处主要有两点：\n\n开发者友好：使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构，也更为便于团队的开发和维护\n机器友好：带有语义的⽂字表现⼒丰富，更适合搜索引擎的爬⾍爬取有效信息，语义类还可以⽀持读屏软件，根据 ⽂章可以⾃动⽣成⽬录 这对于简书、知乎这种富⽂本类的应⽤很重要，语义化对于其⽹站的内容传播有很⼤的帮助\n\n有哪些常⽤的 meta 标签？http加载相关 -&gt; 编码相关 -&gt; 文档描述相关的 -&gt; 适配相关的 -&gt; 网页内容检测相关\nNo1. http-equiv（http 等效），顾名思义，相当于 http 的⽂件头作⽤,⽐如下⾯的代码就可以设置 http 的缓存过期⽇期 HTML\n&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot; &#x2F;&gt;\n\nNo2. charset，⽤于描述 HTML ⽂档的编码形式 &lt;meta charset=&quot;UTF-8&quot; &gt;\nNo3. meta 标签由name和content两个属性来定义，来描述⼀个 HTML ⽹⻚⽂档的属性，例如\n\n作者: &lt;meta name=&quot;author&quot; content=&quot;lyralee&quot;&gt;\n关键词: &lt;meta name=&quot;keywords&quot; content=&quot;js,html&quot;&gt;\n⽹⻚描述: &lt;meta name=&quot;description&quot; content=&quot;this is a websit&quot;&gt;\n⽇期和时间:\n⻚⾯刷新 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;1&quot;&gt;\n等，除了⼀些 http 标准规定了⼀些 name 作为⼤家使⽤的共识，\n开发者也可以⾃定义 name。\n\nNo4. viewport，移动前端最熟悉不过，Web 开发⼈员可以控制视⼝的⼤⼩和⽐例\n&lt;meta\n  name&#x3D;&quot;viewport&quot;\n  content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1, minimum-scale&#x3D;1 &quot;\n&#x2F;&gt;\n\nNo5. apple-mobile-web-app-status-bar-style,开发过 PWA 应⽤的开发者应该很熟悉，为了⾃定义评估⼯具栏的颜⾊。\n&lt;meta\n  name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot;\n  content&#x3D;&quot;black-translucent&quot;\n&#x2F;&gt;\n\nNo6. iphoneX适配的 viewport-fit=cover\n&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width...... viewport-fit&#x3D;cover&quot; &#x2F;&gt;\n&lt;style&gt;\n  @supports (bottom: env(safe-area-inset-bottom)) &#123;\n    body,\n    .footer（底部栏） &#123;\n      padding-bottom: constant(safe-area-inset-bottom);\n      padding-bottom: env(safe-area-inset-bottom);\n    &#125;\n  &#125;\n&lt;&#x2F;style&gt;\n\nNo7. format-detection\n&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;  &#x2F;&#x2F; telephone&#x3D;no 就禁止了把数字转化为拨号链接！\n&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;email&#x3D;no&quot;  &#x2F;&gt; &#x2F;&#x2F; email&#x3D;*no 禁止作为邮箱地址！\n&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;adress&#x3D;no&quot; &#x2F;&gt; &#x2F;&#x2F; adress&#x3D;*no 禁止跳转至地图！\n\n作者：优瑞囧链接：https://www.jianshu.com/p/82a85a53d5b4来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n爬取脚本document.body.append(location.origin + &quot;\\n&quot;);\nArray.from(document.getElementsByTagName(&quot;meta&quot;)).forEach((item) &#x3D;&gt; &#123;\n  document.body.append(&#96;$&#123;item.name&#125; : $&#123;item.content&#125;标记&#96;);\n&#125;);\n\n掘金&#x2F;&#x2F; https:&#x2F;&#x2F;juejin.cn\n&#x2F;&#x2F; viewport : width&#x3D;device-width, initial-scale&#x3D;1, user-scalable&#x3D;*no,* viewport-fit&#x3D;cover\n&#x2F;&#x2F; apple-itunes-app : app-id&#x3D;987739104\n&#x2F;&#x2F; theme-color : #ffffff\n&#x2F;&#x2F; msapplication-TileColor : #da532c\n&#x2F;&#x2F; description : zoomdong的收藏集：面经 —— 共收录了13篇文章，有0人关注了该收藏。\n&#x2F;&#x2F; keywords : 面经,面经zoomdong,zoomdong的收藏,面经掘金,掘金\n\nsrc 和 href 的区别？src 是指向外部资源的位置，\n\n资源插入到：指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，如 js 脚本，img 图⽚和 frame 等元素。\n\n阻塞其他资源：当浏览器解析到该元素时，会暂停其他资源的下载和处理，指导将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在底部⽽不是头部。\n\n指向资源：href 是指向⽹络资源所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，\n\n并行下载：当浏览器识别到它他指向的 ⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。\n\n\n知道 img 的 srcset 的作⽤是什么？可以设计响应式图⽚，我们可以使⽤两个新的属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择 正确的⼀个资源。\nsrcset 定义了我们允许浏览器选择的图像集，以及每个图像的⼤⼩。\nsizes 定义了⼀组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图⽚尺⼨是最佳选择。\n所以，有了这些属性，浏览器会： 查看设备宽度 检查 sizes 列表中哪个媒体条件是第⼀个为真 查看给予该媒体查询的槽⼤⼩ 加载 srcset 列表中引⽤的最接近所选的槽⼤⼩的图像\n&lt;picture&gt; 元素通过包含零或多个&lt;source&gt;元素和⼀个 &lt;img&gt; 元素来为不同的显示&#x2F;设备场景提供图像版本。浏览器会选择最匹配的⼦ &lt;source&gt; 元素，如果没有匹配的，就选择 &lt;img&gt; 元素的 src 属性中的 URL。然后，所选图像呈现 在 &lt;img&gt; 元素占据的空间中\n&lt;picture&gt;\n  &lt;source\n    srcset&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;surfer-240-200.jpg&quot;\n    media&#x3D;&quot;(min-width: 800px)&quot;\n  &#x2F;&gt;\n  &lt;img src&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;painted-hand-298-332.jpg&quot; &#x2F;&gt;\n&lt;&#x2F;picture&gt;\n\nscript 标签中 defer 和 async 的区别？\ndefer：浏览器指示脚本在⽂档被解析后执⾏，script 被异步加载后并不会⽴刻执⾏，⽽是等待⽂档被解析完毕后执⾏。\nasync：异步加载脚本，区别是脚本加载完毕后⽴即执⾏，这导致 async 属性下的脚本是乱序的，对于 script 有先后依赖关系的情况，并不适⽤。\n\n\n\n有⼏种前端储存的⽅式？cookies、localstorage、sessionstorage、Web SQL、IndexedDB 这些⽅式的区别是什么？\n\ncookies：优点: 是兼容性好，请求头⾃带 cookie ⽅便，缺点: 是⼤⼩只有 4k， ⾃动请求头加⼊ cookie 浪费流量，每个 domain 限制 20 个 cookie\n\nlocalStorage：HTML5 加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删 除），⼤⼩为 5M，兼容 IE8+\n\nsessionStorage：与 localStorage 基本类似，区别是 sessionStorage 当⻚⾯关闭后会被清理，⽽且与 cookie、 localStorage 不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式\n\nWeb SQL：2010 年被 W3C 废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实 现，web sql 类似于 SQLite，是真正意义上的关系型数据库，⽤ sql 进⾏操作，当我们⽤ JavaScript 时要进⾏转换， 较为繁琐。\n\nIndexedDB： 是被正式纳⼊ HTML5 标准的数据库储存⽅案，它是 NoSQL 数据库，⽤键值对进⾏储存，可以进⾏快 速读取操作，⾮常适合 web 场景，同时⽤ JavaScript 进⾏操作会⾮常⽅便。\n\n\n两个 Tab 页面的通信方式两个 Tab 页面的通信方式\n\n\n参考链接移动端 H5 适配 iphoneX 底部栏，css 快速解决方案\nwww.w3.org\n@viewport 已废弃\n","slug":"2022-07-17html","date":"2022-07-17T01:44:42.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"2467747971f59a01619a9d5abd6f99a3","title":"前端基础-http","content":"HTTP ⽅法HTTP1.0 定义了三种请求⽅法： GET, POST 和 HEAD ⽅法HTTP1.1 新增了五种请求⽅法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT\nHTTP ⽅法的理论作⽤\nGET: 通常⽤于请求服务器发送某些资源\nPOST: 发送数据给服务器\nPUT: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式\nPATCH: ⽤于对资源进⾏部分修改\nDELETE: ⽤于删除指定的资源\nHEAD: 请求资源的头部信息, 使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源\nOPTIONS: ⽤于获取⽬的资源所⽀持的通信选项 （在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。浏览器自动发起）\nTRACE: 回显服务器收到的请求，主要⽤于测试或诊断\nCONNECT: HTTP&#x2F;1.1 协议中预留给能够将连接改为管道⽅式的代理服务器\n\n\n\n\n\n\n\n\nWARNING\n理论上是这么回事，可有些研发并不一定这么操作\n这些方法是约定\n是的，这些 HTTP 方法都是在 HTTP 协议中约定的，用于表示客户端请求的不同操作。HTTP 协议规定了客户端可以使用哪些方法，以及这些方法在服务器上应该如何处理。例如，GET 方法表示请求获取资源，而 POST 方法表示提交数据到服务器进行处理。这些方法的约定是为了使客户端和服务器之间的通信更加明确和标准化。\n\n\nGET 和 POST 有什么区别？浏览器\n\n收藏标签 GET 请求可以收藏为书签，POST 请求不可以收藏为书签；\n重新提交无害 GET 请求在浏览器回退和刷新时是无害的，而 POST 请求会告知用户数据会被重新提交；\n请求缓存 GET 请求可以被缓存，POST 请求不可以被缓存，除非在响应头中包含合适的 Cache-Control&#x2F;Expires 字段，但是不建议缓存 POST 请求，其不满足幂等性，每次调用都会对服务器资源造成影响；\n\n请求特点\n\n安全性GET 请求的安全性较差，数据被暴露在浏览器的 URL 中，所以不能用来传递敏感信息，POST 请求的安全性较好，数据不会暴露在 URL 中；\n幂等性 GET 请求具有幂等性(多次请求不会对资源造成影响)，POST 请求不幂等；\n长度限制GET 请求因为是向 URL 添加数据，不同的浏览器厂商，代理服务器，web 服务器都可能会有自己的长度限制，而 POST 请求无长度限制；\n参数缓存GET 请求的参数可以被保留在浏览器的历史中，POST 请求不会被保留；\n数据类型不同 GET 请求只允许 ASCII 字符，POST 请求无限制，支持二进制数据；\n数据传输⽅式不同GET 请求一般不具有请求体，因此只能进行 url 编码，而 POST 请求支持多种编码方式。\n\nPUT 和 POST 有什么区别？\n幂等 PUT ⽅法是幂等的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽ POST ⽅法是⾮幂 等的。\n单一资源 PUT 的 URI 指向是具体单⼀资源，⽽ POST 可以指向资源集合。\n\n举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤\n\nPOST https://www.jianshu.com/articles ， 这个请求的语义是，在 articles 的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。\nPUT https://www.jianshu.com/articles/1 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI 指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘华』修改成『刘德华』，提交多少次都是修改成『刘德华』\n\nPUT 和 PATCH 的区别？\nPUT 和 PATCH 都是更新资源，\n⽽ PATCH ⽤来对已知资源进⾏局部更新，PATCH可以理解为打补丁\n\n⽐如我们有⼀篇⽂章的地址 https://www.jianshu.com/articles/1 ,这篇⽂章的可以表示为:\narticle &#x3D; &#123;\n  author: &#39;dxy&#39;,\n  creationDate: &#39;2019-6-12&#39;,\n  content: &#39;我写⽂章像刘德华&#39;,\n  id: 1,\n&#125;;\n\n当我们要修改⽂章的作者时，我们可以直接发送\nPUT https://www.jianshu.com/articles/1 ，数据是:\n&#123;\n  author:&#39;刘德华&#39;,\n  creationDate: &#39;2019-6-12&#39;,\n  content: &#39;我写⽂章像刘德华&#39;,\n  id: 1\n&#125;\n\n\n这种直接覆盖资源的修改⽅式应该⽤ put，但是你觉得每次都带有这么多⽆⽤的信息，那么可以发送\nPATCH https://www.jianshu.com/articles/1 ，这个时候只需要:\n&#123; author:&#39;刘德华&#39;, &#125;\n\nHTTP 的状态码有哪些？Web 开发技术&gt;HTTP&gt;HTTP 响应状态码\n\n100 Continue,信息型状态响应码表示目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略\n101 SwitchingProtocols，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议(h5的websocket使用时，会出现101状态码)\n103 Early Hints,信息状态响应码，一般和 Link header（首部）一起使用，来允许用户在服务器还在准备响应数据的时候预加载一些资源。\n\n2XX 成功\n\n200 OK，表示从客户端发来的请求在服务器端被正确处理\n201 Created 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴\n202 Accepted 请求已接受，但是还没执⾏，不保证完成请求\n204 No content，表示请求成功，但响应报⽂不含实体的主体部分 客户端不做更改(浏览器不会刷新页面，也不会导向别的页面。对客户端说好了，你别管了)\n206 Partial Content，进⾏范围请求 B 站视频播放时候会发起请求\n\n3XX 重定向\n\n301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n302 found，临时性重定向，表示资源临时被分配了新的 URL\n303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源\n304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况\n307 temporary redirect，临时重定向，和 302 含义相同\n\n4XX 客户端错误\n\n400 bad request，请求报⽂存在语法错误\n401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n403 forbidden，表示对请求资源的访问被服务器拒绝\n404 not found，表示在服务器上没有找到请求的资源\n408 Request timeout, 客户端请求超时\n409 Confict, 请求的资源可能引起冲突\n\n5XX 服务器错误\n\n500 internal sever error，表示服务器端在执⾏请求时发⽣了错误\n501 Not Implemented 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务器不⽀持的某个⽅法\n502 Bad Gateway 网关错误\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求\n504 Gateway timeout 网关超时\n505 http version not supported 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本\n\n后台一个服务器挂了，重启后正常\n302,307,303 的区别？\n302 是 http1.0 的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。\n303 明确表示客户端应当采⽤get⽅法获取资源，会把POST请求变为GET请求进⾏重定向。\n307 会遵照浏览器标准， 不会从 post 变为 get。\n\n详细内容见下文，HTTP 状态码目录\nAPI 网关是什么API 网关\n是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而 安全、性能、监控 可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性\nKong 网关\nHTTP 的 keep-alive 是⼲什么的？在早期的 HTTP&#x2F;1.0 中，每次 http 请求都要创建⼀个连接，⽽创建连接的过程需要消耗资源和时间，为了减少资源消耗， 缩短响应时间，需要重⽤连接。\n在后来的 HTTP&#x2F;1.0 中以及 HTTP&#x2F;1.1 中，引⼊了重⽤连接的机制，就是在 http 请求头中加⼊ Connection: keep-alive 来告诉对⽅这个请求响应完成后不要关闭，下⼀次咱们还⽤这个请求继续交流。\nHTTP&#x2F;1.0 如果想要保持⻓连接，需要在请求头中加上 Connection: keep-alive。\nkeep-alive 是什么，有什么优缺点HTTP Keep-Alive 是一种 HTTP 协议中的连接保持机制，也称为持久连接（persistent connection）或复用连接（reusable connection）。在使用 HTTP Keep-Alive 机制时，客户端和服务器之间的 TCP 连接会保持一段时间不关闭，以便在后续的请求中复用这个连接，从而避免了建立和关闭连接的开销，提高了网络传输的效率。\nHTTP Keep-Alive 机制的优点包括：\n\n减少连接的建立和关闭开销，提高传输效率；\n可以在一个 TCP 连接上复用多个 HTTP 请求和响应，降低网络延迟；\n可以避免一些负载均衡设备在连接建立和关闭时的干扰；\n支持流式数据传输，可以在响应过程中实时更新数据，提高交互性能。\n\nHTTP Keep-Alive 机制的缺点包括：\n\n可能占用服务器的连接资源，如果连接过多可能会导致服务器的负载过高；\n可能会造成一些安全问题，如持久连接的过程中可能会出现未经授权的请求或响应；\n在一些场景下可能会导致一些不稳定性或兼容性问题，如 HTTP Keep-Alive 机制不适用于某些代理服务器或防火墙等网络设备。\n\n总的来说，HTTP Keep-Alive 机制在网络传输效率和性能方面都具有明显的优势，但在使用时需要考虑到其可能引发的一些安全和兼容性问题。\n为什么有了 HTTP 为什么还要 HTTPS？https 是安全版的 http，因为 http 协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS 就 是为了解决 HTTP 的不安全⽽⽣的。\nHTTPS 是如何保证安全的？过程⽐较复杂: 对称加密、非对称加密、中间人、CA证书、数字签名\n对称加密即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。\n⾮对称加密\n私钥 + 公钥&#x3D; 密钥对\n即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密\n因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅\n然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密\n\n⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。\n解决⽅案：\n那么结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密 得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。\n中间⼈此时⼜带来⼀个问题，中间⼈问题：\n如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。(偷换)\nCA 证书所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。\n证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的 HASH 算法、证书到期时间等\n类似一个驾驶证：签发机构、驾驶车辆型号、使用者信息、证件有效期\n证书篡改但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。\n数字签名数字签名: 就是⽤ CA ⾃带的 HASH 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。 这个时候就能最⼤程度保证通信的安全了。\nHTTP2 特点？\n二进制分帧: 二进制解析起来更高效\n头部压缩：在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担\n服务端推送：不⽤等到浏览器解析到相应位置，发起请求再响应\n多路复用：同域名下所有通信都在单个连接上完成。 单个连接可以承载任意数量的双向数据流\n\n\n点击查看更多\n⼆进制分帧\n\n帧：HTTP&#x2F;2 数据通信的最⼩单位\n消息：指 HTTP&#x2F;2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由⼀个或多个帧 组成。\n流：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数 ID HTTP&#x2F;2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议解析起来更⾼效。\n\n头部压缩\nHTTP&#x2F;1.x 会在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。\nHTTP&#x2F;2 在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 ⾸部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量\n服务器推送\n服务端可以在发送⻚⾯ HTML 时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。\n场景:\n例如服务端 可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端。\n多路复⽤\nHTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制。HTTP2 中： 同域名下所有通信都在单个连接上完成。 单个连接可以承载任意数量的双向数据流。 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可以重新组装\n\n\n\n\nHTTP2 的缺点HTTP2 是 HTTP 协议的新一代版本，相对于 HTTP1.1，它带来了许多优点，如多路复用、服务器推送等。但是，HTTP2 也存在一些缺点，主要包括以下几个方面：\n\n首字节延迟：虽然 HTTP2 通过多路复用等技术提高了并发性能，但是由于头部压缩等机制的引入，HTTP2 的首字节延迟（Time to First Byte，TTFB）可能会更长。\n\n资源消耗：HTTP2 使用了更多的资源来处理请求和响应，例如使用 HPACK 算法进行头部压缩，增加了服务器的计算和内存消耗。此外，HTTP2 使用 TLS 加密，会增加一定的 CPU 和内存消耗。\n\n服务端推送滥用：HTTP2 支持服务器推送，但是如果滥用这个功能，可能会导致性能下降和资源浪费。\n\n缓存问题：由于 HTTP2 中的请求和响应使用了二进制协议，使得缓存变得更加复杂。与 HTTP1.1 相比，HTTP2 的缓存不再是简单的文本匹配，而是需要进行二进制匹配，这可能会影响缓存效率。\n\n\n总的来说，HTTP2 在性能和安全方面有很多优点，但也存在一些缺点，需要在实际应用中进行权衡和优化。\n\nHPACK 算法\nHPACK 算法\nHPACK 是 HTTP&#x2F;2 协议中的一种压缩算法，用于减少 HTTP 请求头的传输大小，从而提高数据传输的效率。HPACK 算法的具体实现过程如下：\n\n通过静态表和动态表来存储请求头字段，其中静态表包含 HTTP 协议中预定义的请求头字段，动态表则存储请求头字段的变量部分。\n\n对于每个请求头字段，HPACK 算法通过哈希算法生成一个整数索引，然后将其与静态表和动态表中的索引进行比较，以确定请求头字段的类型和值。\n\n对于动态表中的请求头字段，HPACK 算法可以通过索引号来快速查找和更新，从而实现更高效的压缩和解压缩操作。\n\n\n通过 HPACK 算法的压缩，HTTP&#x2F;2 协议可以将原始请求头数据大小压缩到原来的 1&#x2F;10 左右，从而提高数据传输的效率。同时，HPACK 算法的压缩和解压缩也是可逆的，不会导致请求头信息的丢失或损坏。\nHPACK 算法 示例\n假设我们有如下 HTTP&#x2F;2 请求头：\nGET &#x2F;index.html HTTP&#x2F;2.0\nHost: www.example.com\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;58.0.3029.81 Safari&#x2F;537.3\nAccept-Language: en-US,en;q&#x3D;0.8\n\n使用 HPACK 算法进行压缩的过程如下：\n\n对于第一个请求头字段 “GET &#x2F;index.html HTTP&#x2F;2.0”，我们可以使用 HTTP&#x2F;2 协议中预定义的索引号 “2” 来表示，因为它是一个请求方法和请求路径的组合。所以，我们可以将 “2” 编码为二进制 “82”。\n\n对于第二个请求头字段 “Host: www.example.com&quot;，我们可以使用HPACK算法的动态表，将该字段插入到动态表的最前面，并为其分配一个索引号，例如 “62”，然后将索引号和该字段的值一起编码为二进制 “BE 81 9D 7D 7F 81 84 61 64 64 72 65 73 73 2E 63 6F 6D”。\n\n对于第三个请求头字段 “User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;58.0.3029.81 Safari&#x2F;537.3”，我们可以使用 HPACK 算法的动态表，将该字段插入到动态表的最前面，并为其分配一个索引号，例如 “63”，然后将索引号和该字段的值一起编码为二进制 “BF 84 A1 97 A8 41 A5 0F 44 4C 15 4D B4 4B D4 C4 35 05 D8 D6 27 95 98 50 D4 D7 C9 AB 5C 70 1F”。\n\n对于第四个请求头字段 “Accept-Language: en-US,en;q&#x3D;0.8”，我们可以使用 HTTP&#x2F;2 协议中预定义的索引号 “38” 来表示，因为它是一个可接受的自然语言列表。所以，我们可以将 “38” 编码为二进制 “AE”。\n\n\n最终，经过 HPACK 算法压缩后的请求头数据为：\n82 BE 81 9D 7D 7F 81 84 61 64 64 72 65 73 73 2E 63 6F 6D BF 84 A1 97 A8 41 A5 0F 44 4C 15 4D B4 4B D4 C4 35 05 D8 D6 27 95 98 50 D4 D7 C9 AB 5C 70 1F AE\n\n使用 HPACK 算法解压缩的过程与上述过程相反，具体实现可参考 RFC 7541 中的规定。\n\n\nHTTP3 解决了 HTTP2 哪些问题HTTP3 是 HTTP 协议的新一代版本，相对于 HTTP2，它解决了一些 HTTP2 存在的问题，包括以下几个方面：\n\n首字节延迟：HTTP3 使用了 QUIC 协议作为底层传输协议，通过将 TLS 加密和传输协议合并到一起，可以减少握手和连接建立的延迟，从而降低首字节延迟。\n\n多路复用：HTTP3 仍然支持多路复用，但采用了更为先进的方式。HTTP3 中的数据流（Stream）可以独立进行流控和错误恢复，避免了因一个数据流出现问题而影响整个连接的问题。\n\n服务端推送：HTTP3 中的服务端推送（Server Push）更加高效和灵活，可以动态调整推送的内容和优先级。\n\n可靠性：HTTP3 中的 QUIC 协议采用了更加先进的错误恢复机制，可以快速检测和修复错误，从而提高连接的可靠性。\n\n安全性：HTTP3 仍然使用 TLS 加密，但是通过将传输和加密合并在一起，可以提高安全性和隐私保护。\n\n\n综上所述，HTTP3 在延迟、多路复用、服务端推送、可靠性和安全性等方面都有所提升，可以更好地满足现代网络应用的需求。\nQUIC 协议将 TLS 加密和传输协议合并到一起，如何理解QUIC 协议将 TLS（Transport Layer Security）加密和传输协议合并到了一起，具体来说，QUIC 的安全性和传输协议都是基于 TLS 1.3 协议实现的，而且在 QUIC 协议的实现中，TLS 协议是以数据包为单位进行加密和解密的，也就是说，QUIC 协议中传输层的加密和传输过程是同时进行的。\n这种设计使得 QUIC 协议的加密和传输过程更为高效，因为 TLS 协议的握手和密钥交换等过程通常会占用比较长的时间，而 QUIC 协议可以通过 0-RTT 握手等技术实现更快的连接建立和数据传输。此外，将加密和传输协议合并到一起，也可以提高协议的灵活性和可扩展性，使得 QUIC 协议更容易适应不同的应用场景和网络环境。\nHTTP2 与 HTTP3 的区别HTTP&#x2F;2 和 HTTP&#x2F;3 是 HTTP 协议的两个版本。它们的主要区别在于底层传输协议的不同。HTTP&#x2F;2 使用的是基于 TCP 的传输协议，而 HTTP&#x2F;3 使用的是基于 QUIC 的传输协议。\n下面是 HTTP&#x2F;2 和 HTTP&#x2F;3 的一些主要区别：\n\n底层传输协议：HTTP&#x2F;2 使用的是基于 TCP 的传输协议，而 HTTP&#x2F;3 使用的是基于 QUIC 的传输协议。HTTP&#x2F;3 的底层协议具有更快的连接建立时间和更高的性能，因为它可以将 TLS 和传输协议合并在一起，同时还具有更好的错误恢复机制。\n\n多路复用：HTTP&#x2F;2 和 HTTP&#x2F;3 都支持多路复用，但是它们的实现方式不同。HTTP&#x2F;3 的数据流可以独立进行流控和错误恢复，而 HTTP&#x2F;2 中一个数据流出现问题可能会影响整个连接的性能。\n\n服务端推送：HTTP&#x2F;2 和 HTTP&#x2F;3 都支持服务端推送，但是 HTTP&#x2F;3 中的服务端推送更加高效和灵活。HTTP&#x2F;3 的服务端推送可以动态调整推送的内容和优先级。\n\n首字节延迟：HTTP&#x2F;3 的首字节延迟比 HTTP&#x2F;2 更低。这是因为 HTTP&#x2F;3 使用了 QUIC 协议，可以减少握手和连接建立的延迟，从而降低首字节延迟。\n\n安全性：HTTP&#x2F;2 和 HTTP&#x2F;3 都使用 TLS 加密协议，但是 HTTP&#x2F;3 通过将 TLS 和传输协议合并在一起，可以提高安全性和隐私保护。\n\n\n综上所述，HTTP&#x2F;3 相对于 HTTP&#x2F;2 来说，在性能、可靠性和安全性等方面都有所提升，可以更好地满足现代网络应用的需求。\nQUIC 协议，为什么可以减少握手和连接建立的延迟QUIC 协议可以减少握手和连接建立的延迟，主要是因为它基于 UDP 协议，支持 0-RTT 握手，使用多路复用技术，以及具有快速恢复机制。这些特性可以降低连接的建立次数，提高数据传输效率和可靠性。\n详细内容：\nQUIC 协议可以减少握手和连接建立的延迟，主要有以下几个原因：\n\n基于 UDP 协议：QUIC 协议是基于 UDP 协议实现的，UDP 协议相比 TCP 协议，不需要进行握手过程和拥塞控制等复杂的功能，因此可以减少握手和连接建立的延迟。\n\n0-RTT 握手：QUIC 协议支持 0-RTT 握手，这意味着客户端可以在第一次连接时发送数据，而不需要等待服务器的确认。这样可以减少握手和连接建立的时间，提高数据传输的效率。\n\n多路复用：QUIC 协议使用多路复用技术，可以将多个数据流合并在一个连接中传输，这样可以减少连接的建立次数，降低延迟和网络负载。\n\n快速恢复：QUIC 协议中有一个快速恢复机制，可以在数据包丢失时快速恢复数据传输，减少连接的中断时间。\n\n\n综上所述，QUIC 协议的设计使得它可以减少握手和连接建立的延迟，并且具有更高的数据传输效率和可靠性，因此被广泛应用于 HTTP&#x2F;3 等应用协议的底层传输协议。\nQUIC 协议支持 0-RTT 握手 是什么0-RTT 握手是指客户端在第一次连接服务器时就可以发送数据，而不需要等待服务器确认，从而减少握手和连接建立的时间，提高数据传输的效率。具体实现方式是客户端在第一次连接时就将加密后的请求数据发送给服务器，并附带一个已知的密钥，以便服务器能够快速地解密并验证客户端身份。如果服务器能够验证客户端身份并接受请求，则可以立即发送响应，从而实现了 0-RTT 握手。需要注意的是，0-RTT 握手存在一定的安全风险，因为攻击者可以通过伪造密钥来模拟客户端身份，因此需要谨慎使用。\n\n\nHTTP 的缓存的过程通常情况下的步骤是:\n\n客户端向服务器发出请求，请求资源\n服务器返回资源，并通过响应头决定缓存策略\n客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来\n在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断 是直接读取本地缓存还是与服务器协商缓存\n\n强缓存强缓存离不开两个响应头 Expires 与 Cache-Control\nExpiresExpires 是 http1.0 提出的⼀个表示资源过期时间的 header，它描述的是⼀个绝对时间，由服务器返回， Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效\nExpires:Wed, 11 May 2018 07:20:00 GMT GMT 时间戳\nCache-ControlCache-Control 出现于 HTTP &#x2F; 1.1，优先级⾼于 Expires ,表示的是相对时间\nCache-Control: max-age=315360000\n⽬前主流的做法使⽤ Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有：\nCache-Control: public 可以被所有⽤户缓存，允许终端和 CDN 等中间代理服务器Cache-Control: private 只能被终端浏览器缓存，不允许中继缓存服务器进⾏缓存Cache-Control: no-cache,先缓存本地,要验证，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤Cache-Control: no-store，不会产⽣任何缓存\n在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商。\n服务器判断缓存是否是新鲜的⽅法就是依靠 HTTP 的另外两组信息\n协商缓存Last-Modified&#x2F;If-Modified-Since客户端⾸次请求资源时，服务器会把资源的最新修改时间\nLast-Modified:Thu, 19 Feb 2019 08:20:55 GMT 通过响应部⾸发送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头\nIf-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT 发送给服务器，服务器再跟服务器上的对应资源进⾏⽐对，\n如果服务器的资源更新，那么返回最新的资源，此时状态码 200，当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回 304 状态码， 表示客户端直接⽤缓存即可。\nETag&#x2F;If-None-MatchETag 的流程跟 Last-Modified 是类似的，区别就在于 ETag 是根据资源内容进⾏ hash，⽣成⼀个信息摘要，只要资源内容有变化，这个摘要就会发⽣巨变，通过这个摘要信息⽐对，即可确定客户端的缓存资源是否为最新，⽐ Last-Modified 的精确度要更⾼。 响应头\n\n\n整体的缓存流程图如下：\n\n\nHTTP 状态码目录\n1xx 消息\n\n2xx 成功\n\n3xx 重定向\n\n4xx 客户端错误\n\n5xx 服务端错误\n\n\n100 Continue响应状态码100 Continue 信息型状态响应码表示：目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略。\n为了让服务器检查请求的首部，客户端必须在发送请求实体前，在初始化请求中发送 Expect: 100-continue 首部并接收 100 Continue 响应状态码。\n101 Switching Protocol响应状态码101 Switching Protocol（协议切换）状态码表示服务器应客户端升级协议的请求（Upgrade (en-US)请求头）正在切换协议。\n服务器会发送一个 Upgrade (en-US)响应头来表明其正在切换过去的协议。\n该过程在协议升级机制（Protocol upgrade mechanism）中详细描述。\n在使用 WebSockets 时会用到协议切换。\nHTTP&#x2F;1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\n\n\n102 Processing\n请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。\n该代码表示服务器已经收到并正在处理请求，但无响应可用。\n这样可以防止客户端超时，并假设请求丢失。\n\n103 Early Hints响应状态码 103 Early Hints 信息状态响应码，一般和 Link header（首部）一起使用，来允许用户在服务器还在准备响应数据的时候预加载一些资源\n\n\n\n\n\n\n\n\n\nHTTP 实体报头 Link 提供了序列化 HTTP 头部链接的方法。它在语义上与 HTML 元素  相等\n&#x2F;&#x2F; link 头部包含以 ; 分隔的参数，这些参数与 HTML 元素 &lt;link&gt; 的属性一致。\n&#x2F;&#x2F; URI 必须要用 &lt; 和 &gt; 来关闭：\n&#x2F;&#x2F; Link: &lt;https:&#x2F;&#x2F;example.com&gt;; rel&#x3D;&quot;preload&quot;\n\n\nDetails\nHTTP 状态码 103 Early Hints 是一个比较新的状态码，它在 HTTP&#x2F;2 和 HTTP&#x2F;3 协议中被引入。它的作用是在服务器处理请求时，提前向客户端发送一些提示信息，让客户端可以在等待服务器响应时进行一些优化处理。\n103 Early Hints 状态码在服务器处理请求时，可以提前向客户端发送一些提示信息，比如可能要返回的资源类型、缓存控制策略等。客户端可以根据这些提示信息，提前进行一些资源的请求和加载，以优化用户的体验。\n为了使用 103 Early Hints 状态码，服务器需要在响应头中设置 Link 头信息，如下所示：\nLink: &lt;&#x2F;styles.css&gt;; rel&#x3D;preload; as&#x3D;style,\n      &lt;&#x2F;script.js&gt;; rel&#x3D;preload; as&#x3D;script,\n      &lt;&#x2F;image.png&gt;; rel&#x3D;preload; as&#x3D;image\n\n这个 Link 头信息指定了一些资源，告诉客户端这些资源是要在响应中返回的，可以预先加载。其中，rel&#x3D;preload 表示这是一个预加载的资源，as 指定了资源的类型，比如 style、script 或 image 等。\n客户端收到 103 Early Hints 状态码后，可以根据 Link 头信息提前加载资源，以提高页面的响应速度和用户体验。需要注意的是，客户端在收到 103 Early Hints 状态码时，仍然需要等待服务器返回完整的响应，这只是一个提前的提示信息，不代表响应的完成。\n使用的场景\n103 Early Hints 状态码可以在一些需要优化页面加载速度的项目中使用，比如：\n\n首页加载优化\n\n在网站首页中，可以使用 103 Early Hints 状态码来预加载一些重要的资源，如 CSS 样式表、JavaScript 文件和页面头部图片等。这些资源可以在服务器处理请求时，提前使用 Link 头信息告诉客户端需要预加载的资源，以加快页面加载速度和提升用户体验。\n\n移动端 Web 应用\n\n移动端 Web 应用对页面加载速度有着很高的要求，使用 103 Early Hints 状态码可以在请求完成前，提前加载页面所需的关键资源，比如核心 JavaScript 文件、CSS 样式表等。这可以让页面在客户端请求完成后，立即呈现给用户，提升用户体验。\n\nCDN 缓存控制\n\n使用 103 Early Hints 状态码可以在 CDN 缓存控制中，提前告诉客户端需要缓存的资源和缓存策略。这可以提高客户端对资源的缓存命中率，减少服务器压力，同时提升用户访问体验。\n需要注意的是，103 Early Hints 状态码在 HTTP&#x2F;2 和 HTTP&#x2F;3 协议中才被支持，对于老版本的 HTTP 协议，不支持使用该状态码。在使用该状态码时，也需要注意浏览器和服务器的兼容性，以确保项目的正常运行。\n\n\n200 OK响应状态码 200 OK 表明请求已经成功。默认情况下状态码为 200 的响应可以被缓存。\n不同请求方式对于请求成功的意义如下：\n\nHEAD: 响应的消息体为头部信息。\nGET: 已经取得资源，并将资源添加到响应的消息体中。\nPOST: 响应的消息体中包含此次请求的结果。\nTRACE: 响应的消息体中包含服务器接收到的请求信息。\nPUT 和 DELETE 的请求成功通常并不是响应200 OK的状态码, 而是 204 No Content 表示无内容（或者 201 Created表示一个资源首次被创建成功）。\n\n\n\n201 Created响应状态码201 Created 是一个代表成功的应答状态码，表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 Location 首部的值。(TODO：后半句没搞懂)\n使用场景\n这个状态码的常规使用场景是作为 POST 请求的返回值\n202 Accepted响应状态码202 Accepted 表示服务器端已经收到请求消息，但是尚未进行处理。\n但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。\n使用场景\n这个状态码被设计 用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。\n203 Non-Authoritative Information响应状态码 203 Non-Authoritative Information 表示请求已经成功被响应，但是获得的负载与源头服务器的状态码为200 (OK)的响应相比，经过了拥有转换功能的 proxy（代理服务器）的修改。\nTODO:不懂响应状态码 203 状态码有点类似于 Warning 首部的 214（Transformation Applied）警告码，后者的优势在于可以应用于任何状态码的响应之中。\n204 No Content响应状态码204 No Content 成功状态响应码，表示该请求已经成功了，但是客户端客户不需要离开当前页面。默认情况下 204 响应是可缓存的。一个 ETag 标头包含在此类响应中。\n使用场景\n使用惯例是: 在 PUT 请求中进行资源更新，但是\n\n不需要改变当前展示给用户的页面，那么返回 204 No Content。\n如果创建了资源，则返回 201 Created 。\n如果应将页面更改为新更新的页面，则应改用 200 。\n\n205 Reset Content响应状态码205 Reset Content 用来通知客户端重置文档视图，比如清空表单内容、重置 canvas 状态或者刷新用户界面。\n206 Partial Content响应状态码206 Partial Content成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range 首部指定的。\n\n如果只包含一个数据区间，那么整个响应的 Content-Type 首部的值为所请求的文件的类型，同时包含 Content-Range 首部。\n如果包含多个数据区间，那么整个响应的 Content-Type 首部的值为 multipart/byteranges ，其中一个片段对应一个数据区间，并提供 Content-Range 和 Content-Type 描述信息。\n\n只包含一个数据区间的响应：\nHTTP&#x2F;1.1 206 Partial Content\nDate: Wed, 15 Nov 2015 06:25:24 GMT\nLast-Modified: Wed, 15 Nov 2015 04:58:08 GMT\n# 这里\nContent-Range: bytes 21010-47021&#x2F;47022\nContent-Length: 26012\nContent-Type: image&#x2F;gif\n\n... 26012 bytes of partial image data ...\n\n包含多个数据区间的响应：\nHTTP&#x2F;1.1 206 Partial Content\nDate: Wed, 15 Nov 2015 06:25:24 GMT\nLast-Modified: Wed, 15 Nov 2015 04:58:08 GMT\nContent-Length: 1741\nContent-Type: multipart&#x2F;byteranges; boundary&#x3D;String_separator\n\n--String_separator\nContent-Type: application&#x2F;pdf # 这里\nContent-Range: bytes 234-639&#x2F;8000 # 这里\n\n...the first range...\n--String_separator\nContent-Type: application&#x2F;pdf # 这里\nContent-Range: bytes 4590-7999&#x2F;8000 # 这里\n\n...the second range\n--String_separator--\n\n300 Multiple Choices响应状态码300 Multiple Choices 是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。由于没有如何进行选择的标准方法，这个状态码极少使用。\n假如服务器可以提供一个优先选择，那么它应该生成一个 Location 首部。\n301 Moved Permanently响应状态码301 永久重定向 说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。\n搜索引擎会根据该响应修正。\n\n\n\n\n\n\n\nWARNING\n尽管标准要求浏览器在收到该响应并进行重定向时, 不应该修改http method 和 body，但是有一些浏览器可能会有问题。所以最好是在应对 GET 或 HEAD 方法时使用 301，其他情况使用 308 来替代 301。\n\n302 Found\n响应状态码302 Found 重定向状态码,表明请求的资源被暂时的移动到了由该 HTTP 响应的响应头 Location 指定的 URL 上。\n浏览器会重定向到这个 URL，\n但是搜索引擎不会对该资源的链接进行更新 (In SEO-speak, it is said that the link-juice is not sent to the new URL)。\n\n\n\n\n\n\n\n\nWARNING\n即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。\n所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。\n\n在确实需要将重定向请求的方法转换为 GET 的场景下，可以使用 303 See Other。\n例如:\n在使用 PUT 方法进行文件上传操作时，需要返回确认信息（例如“你已经成功上传了 xyz”）而不是上传的资源本身，就可以使用这个状态码。\n303 See Other响应状态码303 See Other 重定向状态码，通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET\n304 Not Modified响应状态码304 未改变说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如 GET 或 HEAD 或在请求中附带了头部信息： If-None-Match 或 If-Modified-Since。\n如果是 200 OK ，响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary.\n\nDetails\n304 状态码是协商缓存？\n是的，HTTP 状态码 304 Not Modified 通常被称为“协商缓存”（Conditional Cache）。协商缓存是一种缓存机制，客户端和服务器之间通过某些条件进行协商，以决定是否使用缓存的资源。\n客户端在请求资源时，可以使用 If-Modified-Since 或 If-None-Match 等头信息告诉服务器上一次请求中返回的标识符（如资源的修改时间或 ETag），服务器根据这些标识符来判断该资源是否有更新。如果服务器判断资源没有更新，就会返回 304 Not Modified 状态码，客户端可以使用本地缓存中的资源，避免了重复下载和浪费网络带宽，提高了页面加载速度和用户体验。\n需要注意的是，协商缓存是一种高效的缓存机制，但也存在一些限制和注意事项。例如，如果服务器端使用的是 Last-Modified 标识符，那么客户端的本地时间必须与服务器端的时间一致，否则可能会导致缓存失效；另外，某些代理服务器可能会阻止协商缓存机制，从而导致客户端无法使用缓存资源等。\n总之，304 状态码是一种协商缓存机制，用于优化资源加载并减少网络流量，提高用户体验。\n\n305 Use Proxy被请求的资源必须通过指定的代理才能被访问\n306 Switch Proxy 废弃306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”\n307 Temporary Redirect响应状态码307 Temporary Redirect，临时重定向响应状态码，表示请求的资源暂时地被移动到了响应的 Location 首部所指向的 URL 上。\n原始请求中的请求方法和消息主体会在重定向请求中被重用。在确实需要将重定向请求的方法转换为 GET 的场景下，可以考虑使用 303 See Other 状态码。例如，在使用 PUT 方法进行文件上传操作时，如果需要返回一条确认信息（例如“你已经成功上传了 XYZ”），而不是返回上传的资源本身，就可以使用这个状态码。\n307,302 的区别当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。\n\n如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET：也就是说，在 Web 中，如果使用了 GET 以外的请求方法，且返回了 302 状态码，则重定向后的请求方法是不可预测的；\n\n但如果使用 307 状态码，之后的请求方法就是可预测的。对于 GET 请求来说，两种情况没有区别。\n\n\nDetails\n307 Temporary Redirect 和 302 Found 状态码都表示重定向，但两者之间有一些细微的区别。\n302 Found 状态码表示临时重定向，客户端请求的资源已经被暂时转移到了另一个 URL 地址。使用 302 状态码的情况比较多，例如，当用户登录后需要跳转到个人主页时，可以使用 302 状态码。另外，搜索引擎爬虫也会使用 302 状态码来暂时性重定向一些网页。\n307 Temporary Redirect 状态码表示临时重定向，客户端请求的资源已经被暂时转移到了另一个 URL 地址。307 状态码与 302 状态码的区别在于，307 状态码要求客户端在下一次请求时保持请求方法不变，也就是说，如果客户端使用 POST 方法请求一个 URL 地址，服务器在返回 307 状态码时会要求客户端在下一次请求时继续使用 POST 方法，而不是转换为 GET 方法。\n因此，\n\n如果客户端请求的资源被临时重定向到另一个 URL 地址，并且需要在下一次请求时继续使用原始的请求方法，可以使用 307 Temporary Redirect 状态码。\n而如果客户端请求的资源被临时重定向到另一个 URL 地址，但请求方法可以变化，可以使用 302 Found 状态码。\n\n需要注意的是，302 状态码在 HTTP&#x2F;1.0 协议中被定义为“Moved Temporarily”，但在 HTTP&#x2F;1.1 协议中则被重新定义为“Found”，而 307 状态码则在 HTTP&#x2F;1.1 协议中被定义为“Temporary Redirect”。\n\n\n301 与 308 状态码的区别\nDetails\n301 Moved Permanently 和 308 Permanent Redirect 状态码都表示永久重定向，但两者之间也有一些区别。\n301 Moved Permanently 状态码表示请求的资源被永久性地移动到了另一个 URL 地址，客户端应该使用新的 URL 地址访问该资源。使用 301 状态码的情况比较多，例如，当网站的域名发生变化或者网页的 URL 地址发生变化时，可以使用 301 状态码将旧的 URL 地址重定向到新的 URL 地址。\n308 Permanent Redirect 状态码也表示请求的资源被永久性地移动到了另一个 URL 地址，客户端应该使用新的 URL 地址访问该资源。与 301 状态码不同的是，308 状态码要求客户端在下一次请求时保持请求方法不变，也就是说，如果客户端使用 POST 方法请求一个 URL 地址，服务器在返回 308 状态码时会要求客户端在下一次请求时继续使用 POST 方法，而不是转换为 GET 方法。\n因此，\n\n如果需要将请求的资源永久性地移动到另一个 URL 地址，并且需要在下一次请求时继续使用原始的请求方法，可以使用 308 Permanent Redirect 状态码。\n而如果只需要将请求的资源永久性地移动到另一个 URL 地址，而请求方法可以变化，可以使用 301 Moved Permanently 状态码。\n\n需要注意的是，301 状态码在 HTTP&#x2F;1.0 协议中被定义为“Moved Permanently”，而在 HTTP&#x2F;1.1 协议中则被重新定义为“Permanent Redirect”，而 308 状态码则是在 HTTP&#x2F;1.1 协议中新增加的状态码。\n\n\n308 Permanent Redirect在 HTTP 协议中， 308 Permanent Redirect（永久重定向）是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是“链接汁”（link juice）被传递到了新的 URL）。\n在重定向过程中，请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法。\n\n\n\n\n\n\n\nWARNING\n一些 Web 应用可能会将 308 Permanent Redirect 以一种非标准的方式使用以及用作其他用途。例如，Google Drive 会使用 308 Resume Incomplete 状态码来告知客户端文件上传终止且不完整\n\n301,308,302,307,303 区别301,308 永久重定向(有兼容问题)\n\n请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法\nGoogle Drive 会使用 308 Resume Incomplete 状态码来告知客户端文件上传终止且不完整\n\n302,307,303 临时重定向,\n\n对应 GET 方法，302 和 307 没有区别，\n对于 HEAD，302 不会改变,307 会变\n其他请求方法，302 会改成 GET 请求，303 表示都要变成 GET，307 保持请求方法不变\n\n变 GET: 302(保留GET,HEAD) &lt; 307(保留HEAD) &lt; 303(全部)\n400 Bad Request响应状态码400 Bad Request 响应状态码表示: 由于语法无效，服务器无法理解该请求。 客户端不应该在未经修改的情况下重复此请求。\n401 Unauthorized响应状态码 401 Unauthorized 代表客户端错误，指的是: 由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。\n这个状态码会与 WWW-Authenticate 首部一起发送，其中包含有如何进行验证的信息。\n这个状态类似于 403， 但是在该情况下，依然可以进行身份验证。\n响应样例\nHTTP&#x2F;1.1 401 Unauthorized\nDate: Wed, 21 Oct 2015 07:28:00 GMT\nWWW-Authenticate: Basic realm&#x3D;&quot;Access to staging site&quot;\n\n\n402 Payment Required响应状态码 402 Payment Required 是一个被保留使用的非标准客户端错误状态响应码。\n有时， 这个状态码表明直到客户端付费之后请求才会被处理。402 状态码被创建最初目的是用于数字现金或微型支付系统， 表明客户端请求的内容只有付费之后才能获取。目前还不存在标准的使用约定，不同的实体可以在不同的环境下使用。\n\n\n\n\n\n\n\nWARNING\nExperimental: 这是一个实验中的功能此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。\n\n响应样例\nHTTP&#x2F;1.1 402 Payment Required\nDate: Wed, 21 Oct 2015 07:28:00 GMT\n\n403 Forbidden响应状态码403 Forbidden，指的是: 服务器端有能力处理该请求，但是拒绝授权访问。\n这个状态类似于 401，但进入 403状态后, 即使重新验证也不会改变该状态。该访问是长期禁止的，并且与应用逻辑密切相关（例如没有足够的权限访问该资源）。\n404 Not Found响应状态码 404 Not Found 指的是: 服务器无法找到所请求的资源。返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理（link rot）页面。\n404 状态码并不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 410（Gone）而不是 404 。\n405 Method Not Allowed响应状态码 405 Method Not Allowed 表明服务器禁止了使用当前 HTTP 方法的请求。\n事例\nrestful 风格 API,使用中会出现 见\n406 Not Acceptable\n响应状态码 406 Not Acceptable表示: 客户端错误，\n指代服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应。\n\n在实际应用中，_这个错误状态码极少使用_：不是给用户返回一个晦涩难懂（且难以更正）的错误状态码，而是将相关的消息头忽略，同时给用户提供一个看得见摸得着的页面。这种做法基于这样一个假设：即便是不能达到用户十分满意，也强于返回错误状态码。\n如果服务器返回了这个错误状态码，那么消息体中应该包含所能提供的资源表现形式的列表，允许用户手动进行选择。\n407 Proxy Authentication Required响应状态码 407 Proxy Authentication Required 代表客户端错误，指的是: 由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器（proxy server ）要求的身份验证凭证，发送的请求尚未得到满足。\n这个状态码会与 Proxy-Authenticate 首部一起发送，其中包含有如何进行验证的信息。\nHTTP&#x2F;1.1 407 Proxy Authentication Required\nDate: Wed, 21 Oct 2015 07:28:00 GMT\nProxy-Authenticate: Basic realm&#x3D;&quot;Access to internal site&quot;\n\n408 Request Timeout响应状态码 408 Request Timeout 表示: 服务器想要将没有在使用的连接关闭。一些服务器会在空闲连接上发送此信息，即便是在客户端没有发送任何请求的情况下。\n服务器应该在此类响应中将 Connection 首部的值设置为 “close”，因为 408 意味着服务器已经决定将连接关闭，而不是继续等待。\n这类响应出现的比较频繁，源于一些浏览器——例如 Chrome, Firefox 27+, 或者 IE9 等——使用 HTTP 协议中的预连接机制来加速上网体验。同时应该注意到，某些服务器会直接关闭连接，而不发送此类消息。\n409 Conflict响应状态码 409 Conflict表示: 请求与服务器端目标资源的当前状态相冲突。\n冲突最有可能发生在对 PUT 请求的响应中。例如，当上传文件的版本比服务器上已存在的要旧，从而导致版本冲突的时候，那么就有可能收到状态码为 409 的响应。\n410 Gone响应状态码 410 Gone 说明请求的目标资源在原服务器上不存在了，并且是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用 404\n\n\n\n\n\n\n\nWARNING\n410 响应默认会被缓存\n\n411 Length Required响应状态码 411 Length Required 属于客户端错误，表示: 由于缺少确定的 Content-Length 首部字段，服务器拒绝客户端的请求。\n注意，按照规范，当使用分块模式传输数据的时候， Content-Length 首部是不存在的，但是需要在每一个分块的开始添加该分块的长度，用十六进制数字表示。参见 Transfer-Encoding 获取更多细节信息。\n412 Precondition Failed响应状态码 412 Precondition Failed（先决条件失败）, 这通常发生于: 采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 If-Unmodified-Since 或 If-None-Match 规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。\n413 Payload Too Large响应状态码 413 Payload Too Large 表示: 请求主体的大小超过了服务器的能力处理，base64 编码会增大数据体积。\n如果“超出限度”是暂时性的，服务器应该返回 Retry-After 首部字段，说明这是暂时性的，以及客户端可以在什么时间（after what time）后重试。\n414 URI Too Long响应状态码 414 URI Too Long 表示客户端所请求的 URI 超过了服务器允许的范围。\n以下是造成这种罕见情况的几种可能原因：\n\n当客户端误将 POST 请求当作 GET 请求时，会带有一个较长的查询字符串 (query)；\n当客户端堕入重定向循环黑洞时，例如，指向自身后缀的重定向 URI 前缀 (a redirected URI prefix that points to a suffix of itself)；\n当客户端对服务器进行攻击，试图寻找潜在的漏洞时。（反射型XSS攻击）\n\n\nDetails\n413 与 414 状态码\n413 Payload Too Large 和 414 URI Too Long 状态码都表示请求过程中出现了某些错误，导致服务器无法处理该请求。\n413 Payload Too Large 状态码表示客户端发送的请求超出了服务器所能处理的范围。这个错误通常发生在客户端发送的请求体过大时，比如上传的文件大小超过了服务器所允许的最大值。服务器在返回 413 状态码时还可以返回一个“Retry-After”头部，指示客户端在多长时间之后重新尝试请求。\n414 URI Too Long 状态码表示请求的 URL 地址过长，超出了服务器所能处理的范围。这个错误通常发生在客户端发送的 URL 地址过长时，比如在使用 GET 方法请求 API 接口时，请求参数过多或者过长，导致 URL 地址过长。服务器在返回 414 状态码时还可以返回一个“Retry-After”头部，指示客户端在多长时间之后重新尝试请求。\n需要注意的是，413 和 414 状态码是在 HTTP&#x2F;1.1 协议中定义的，而在 HTTP&#x2F;1.0 协议中并没有这两个状态码。如果客户端使用的是 HTTP&#x2F;1.0 协议，服务器在遇到 413 或 414 错误时可能会返回其他的状态码，比如 400 Bad Request 或 500 Internal Server Error。\n\n\n415 Unsupported Media Type响应状态码 415 Unsupported Media Type 表示: 服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。\n格式问题的出现有可能源于客户端在 Content-Type 或 Content-Encoding 首部中指定的格式，也可能源于直接对负载数据进行检测的结果\n\nDetails\n415 Unsupported Media Type 状态码表示客户端发送的请求包含了服务器无法处理的媒体类型。这个错误通常发生在客户端向服务器发送的请求中包含了服务器无法处理的媒体类型，比如客户端发送了一个使用了未知编码的请求体。\nHTTP 协议中规定了一些标准的媒体类型，例如 text&#x2F;plain、text&#x2F;html、application&#x2F;json 等等。服务器在处理请求时会根据请求头部中的 Content-Type 字段来判断客户端发送的请求的媒体类型，如果请求的媒体类型不符合服务器的要求，服务器就会返回 415 状态码。\n需要注意的是，客户端在发送请求时需要指定正确的 Content-Type 字段，以确保请求的媒体类型被正确识别。如果客户端不确定服务器所能处理的媒体类型，可以向服务器发送一个 OPTIONS 请求，服务器会在响应中返回支持的媒体类型。\n另外，服务器也可以在返回 415 状态码时附带一个“Accept”头部，指示客户端可以使用的媒体类型。客户端可以根据服务器返回的“Accept”头部来调整请求的媒体类型，以便服务器可以正确处理请求。\n\n\n416 Range Not Satisfiable响应状态码416 Range Not Satisfiable 错误状态码意味着: 服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。\n416 响应报文包含一个 Content-Range 首部，提示无法满足的数据区间（用星号 _ 表示），后面紧跟着一个“&#x2F;”，再后面是当前资源的长度。例如：Content-Range: */12777\n遇到这一错误状态码时，浏览器一般有两种策略：要么终止操作（例如，一项中断的下载操作被认为是不可恢复的），要么再次请求整个文件。\n417 Expectation Failed响应状态码 417 Expectation Failed 状态码表示客户端错误，意味着: 服务器无法满足 Expect 请求消息头中的期望条件。\n参考 Expect 消息头获得更多的相关细节信息\n示例\n418 I’m a teapot响应状态码 418 I&#39;m a teapot 客户端错误响应代码表示: 服务器拒绝冲泡咖啡，因为它是个茶壶。\n该错误是超文本咖啡壶控制协议的参考，和 1998 年愚人节的玩笑。用作彩蛋\n出自RFC 2324 Hyper Text Coffee Pot Control Protocol (HTCPCP&#x2F;1.0)文档\n文档中定义的一种返回值，协议定义“如果想用茶壶制作咖啡，就会返回一个错误码418 I&#39;m tea pot”\n2014年4.1发布的恶搞RFC 7168是此协议的扩展，正式支持茶壶\n\n作者：chanyi\n链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;cdefc3afd7ea\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\nRFC（request for commits） 征求意见修订书\n是一个互联网技术标准文档\n422 Unprocessable Entity响应状态码 422 状态码表示: 服务器理解请求实体的内容类型，并且请求实体的语法是正确的，但是服务器无法处理所包含的指令。\n例子：见\nHttpRequest中所带cookie和服务器端接收的 cookie名称不一致 ，导致返回422错误代码。\n\n423 Locked当前资源被锁定。（RFC 4918 WebDAV）,网上查到更多是和 SVN 相关\n\nDetails\n423 Locked 状态码表示由于资源被锁定而导致请求失败。这个状态码通常用于 WebDAV 协议中，用来防止多个用户同时对同一个资源进行修改而导致冲突。\n当一个资源被锁定时，其他用户就无法对该资源进行修改操作，这时如果其他用户发起了修改请求，服务器就会返回 423 Locked 状态码。服务器在返回 423 状态码时通常还会在响应中附带一个“Lock-Token”头部，指示当前资源被锁定的令牌。\n423 状态码可以使用 PROPFIND 方法来获取当前资源的锁定状态信息。如果请求的资源没有被锁定，服务器会返回 200 OK 状态码，否则会返回 423 Locked 状态码和锁定信息。\n需要注意的是，423 状态码只适用于被锁定的资源，对于未被锁定的资源应当使用其他的状态码。\n数据库死锁报错什么状态码\n数据库死锁并不是一个 HTTP 协议中定义的错误，因此没有专门的 HTTP 状态码来表示数据库死锁。数据库死锁是指多个并发的事务同时请求数据库中的资源，并且这些请求形成了一个死循环，导致所有事务都被阻塞无法继续执行。\n在应用程序中可以通过捕获数据库异常来检测到死锁情况，并采取相应的处理措施，比如等待一段时间后重试、回滚事务等等。常见的数据库异常错误码包括 ORA-00060（Deadlock detected）、1213（Deadlock found when trying to get lock）、40001（Serialization failure）等等，不同的数据库系统会有不同的错误码和错误信息来表示死锁情况。\n\n424 Failed Dependency由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）\n425 Too Early～～服务器拒绝处理在 Early Data 中的请求，以规避可能的重放攻击, 重放攻击- 中间人攻击的一种～～\n～～是一种恶意或欺诈的重复或延迟有效数据的网络攻击形式～～\n\nDetails\n103 和 425 有什么区别\n103 Early Hints 和 425 Too Early 状态码的作用和含义比较相似，都是用来优化 HTTP 响应速度的，但它们之间有一些区别。\n103 Early Hints 状态码表示服务器已经开始处理客户端的请求，并且已经有一些响应数据可以返回给客户端，但是由于某些原因（比如需要等待某些资源加载完成），服务器无法立即返回完整的响应，因此会在响应头部中附加一些预加载的信息，告诉客户端一些即将到来的响应内容。客户端可以根据这些预加载信息来提前做一些处理，加速页面加载等操作。\n425 Too Early 状态码也是类似的，它表示服务器已经开始处理客户端的请求，但是由于某些原因（比如需要等待某些资源加载完成），服务器无法立即返回完整的响应，因此会返回一个空的响应体，但是在响应头部中附加一些预加载的信息，告诉客户端一些即将到来的响应内容。客户端可以根据这些预加载信息来提前做一些处理，加速页面加载等操作。\n两个状态码之间的区别在于返回的响应体不同。103 状态码返回的响应体中包含了一些预加载的信息，而 425 状态码返回的响应体是空的，只有响应头部中包含了一些预加载的信息。因此，客户端需要根据实际情况来选择使用哪种状态码。\n需要注意的是，这两个状态码目前还比较新，不是所有的 HTTP 客户端和服务器都支持，因此在使用时需要谨慎。\n425 Too Early 不是错误码吗？\n425 Too Early 状态码是 HTTP 协议定义中的一种状态码，它并不一定代表错误，而是表示服务器已经开始处理请求，但是还没有准备好发送完整的响应，需要客户端稍后再次发送请求。\n一般情况下，客户端在发送 HTTP 请求后，服务器会立即返回响应。但是在某些情况下，服务器需要更长的时间来准备完整的响应，例如在处理大量数据、计算密集型任务或等待外部资源时。在这种情况下，服务器可以返回 425 Too Early 状态码，告诉客户端需要稍后再次发送请求来获取完整的响应。\n需要注意的是，425 状态码是 HTTP&#x2F;2 协议中引入的一个新状态码，在旧版本的 HTTP 协议中并不支持。因此，如果您的应用程序需要支持 425 状态码，需要确保您的服务器和客户端都支持 HTTP&#x2F;2 协议。\n\n\n426 Upgrade Required426 Upgrade Required 表示: 服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。\n服务器会在响应中使用 Upgrade (en-US) 首部来指定要求的协议。\n\nDetails\n425 Too Early 不是为了响应重放攻击吗？\n您说的是 426 Upgrade Required 状态码，它是为了防止重放攻击而引入的状态码，而不是 425 Too Early 状态码。\n426 Upgrade Required 状态码表示客户端请求的资源需要通过升级协议的方式来访问，比如从 HTTP&#x2F;1.1 协议升级到 HTTP&#x2F;2 协议。这个状态码的主要作用是防止重放攻击，即攻击者通过重复发送相同的请求来消耗服务器资源。\n服务器在返回 426 状态码时，会在响应头部中包含一个 Upgrade 头部字段，告诉客户端应该使用哪种协议来访问资源。客户端在收到 426 状态码后，需要根据 Upgrade 头部字段中的信息升级协议，并重新发送请求来访问资源。\n需要注意的是，425 Too Early 状态码和 426 Upgrade Required 状态码虽然都是比较新的 HTTP 状态码，但是它们的作用和含义是不同的。425 状态码是用来优化 HTTP 响应速度的，而 426 状态码是用来防止重放攻击的。\n\n\n428 Precondition Required响应状态码 428 Precondition Required 表示: 服务器端要求发送条件请求。\n一般的，这种情况意味着必要的条件首部——如If-Match ——的缺失。\n当一个条件首部的值不能匹配服务器端的状态的时候，应答的状态码应该是 412 Precondition Failed，前置条件验证失败。\n412 与 428 区别\n412 一个条件首部的值不能匹配服务器端的状态的时候，应答的状态码应该是 412 Precondition Failed，前置条件验证失败。\n428 必要的条件首部的缺失——如If-Match\n\n\nDetails\n412 Precondition Failed 和 428 Precondition Required 都是 HTTP 协议定义中的状态码，它们都表示客户端请求的资源无法满足服务器的某些先决条件，但是它们的使用场景和含义是不同的。\n具体来说：\n\n412 Precondition Failed 状态码通常在使用条件请求方法（例如，使用 HTTP 中的 If-Match 或 If-None-Match 头部字段）时返回，表示服务器已经理解了客户端的请求，但是请求中包含的某些条件不满足，导致服务器无法处理请求。例如，如果客户端发送了一个更新资源的请求，但是请求中包含的 ETag 值与服务器上的当前 ETag 值不匹配，服务器就会返回 412 状态码，告诉客户端需要先获取最新的资源版本。\n428 Precondition Required 状态码通常在服务器要求客户端在请求资源时包含某些条件时返回，表示服务器要求客户端在请求资源时必须包含某些特定的请求头部字段，否则服务器无法处理请求。例如，如果服务器要求客户端在更新资源时必须包含 If-Match 头部字段，但是客户端没有发送该请求头部字段，服务器就会返回 428 状态码，告诉客户端需要先包含必要的请求头部字段。\n\n因此，尽管 412 和 428 状态码都表示请求无法满足服务器的先决条件，但是它们的使用场景和含义是不同的，需要根据具体的场景来选择使用哪种状态码。\n\n\n429 Too Many Requests响应状态码 429 Too Many Requests 表示在一定的时间内用户发送了太多的请求，即超出了“频次限制”。\n在响应中，可以提供一个 Retry-After 首部来提示用户需要等待多长时间之后再发送新的请求。\nHTTP&#x2F;1.1 429 Too Many Requests\nContent-Type: text&#x2F;html\nRetry-After: 3600\n\n\n\nDetails\n429 Too Many Requests 是 HTTP 协议定义中的状态码，它表示客户端在指定的时间内发送了过多的请求，超出了服务器的处理能力。\n在实际应用中，为了防止客户端发送过多的请求导致服务器负载过重，通常会对客户端的请求频率进行限制。当客户端发送的请求数量超出了服务器允许的范围时，服务器就会返回 429 状态码，告诉客户端暂时无法处理该请求。\n429 状态码通常伴随着 Retry-After 头部字段一起返回，用于告诉客户端需要等待多长时间之后才可以再次发送请求。Retry-After 头部字段可以是一个 HTTP 日期，也可以是一个相对时间（以秒为单位），客户端可以根据该字段来决定何时重新发送请求。\n需要注意的是，429 状态码只是一个暂时的错误码，客户端可以稍后重新发送请求，直到服务器能够正常处理请求为止。但是客户端需要注意调整请求频率，避免再次触发 429 状态码。\n\n\n431 Request Header Fields Too Large服务器不愿处理请求，因为一个或多个头字段过大\n刚整理完，就收到反馈了，这也太神奇了吧\n\n\n\n\n\n\n\n440 Login Time-out客户端 session 超时失效，需要重新登录。\n451 Unavailable For Legal Reasons因法律的要求而被拒绝\n\nDetails\n451 Unavailable For Legal Reasons 是 HTTP 协议定义中的状态码，它表示服务器因为法律原因无法提供请求的资源。\n例如，当一个政府机构需要阻止某些具有敏感性质的内容（如色情内容、侵权内容等）时，就可以使用 451 状态码来提示客户端该资源已被屏蔽。在这种情况下，服务器应该在响应中包含一个可读性强的错误消息，以便客户端了解资源不可用的原因。\n需要注意的是，使用 451 状态码并不是强制要求，具体使用与否要根据实际情况进行判断。如果服务器因为法律原因无法提供请求的资源，那么返回 451 状态码是合理的；但是如果服务器因为其他原因无法提供请求的资源（例如，服务器宕机、网络故障等），那么使用其他适当的状态码（例如 503 Service Unavailable）更为恰当。\n\n\n500 Internal Server Error500 Internal Server Error 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。\n这个错误代码是一个通用的“万能”响应代码。有时候，对于类似于 500 这样的错误，服务器管理员会更加详细地记录相关的请求信息来防止以后同样错误的出现。\n501 Not Implemented响应状态码 501 Not Implemented 服务器错误响应码表示: 请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。\n请注意，你无法修复 501 错误，需要被访问的 web 服务器去修复该问题。\n502 Bad Gateway响应状态码 502 Bad Gateway 是一种 HTTP 协议的服务端错误状态代码，它表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的。\n\n\n\n\n\n\n\nWARNING\n备注： 网关在计算机网络体系中可以指代不同的设备，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。\n\n\n一般会有 链路追踪, 通过trackId可以查询到什么地方出的问题\n503 Service Unavailable响应状态码503 Service Unavailable 是一种 HTTP 协议的服务器端错误状态代码，它表示服务器尚未处于可以接受请求的状态。\n通常造成这种情况的原因是: 由于服务器停机维护或者已超载。\n注意在发送该响应的时候，应该同时发送一个对用户友好的页面来解释问题发生的原因。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 Retry-After 首部字段中包含服务恢复的预期时间。\n缓存相关的首部在与该响应一同发送时应该小心使用，因为 503 状态码通常应用于临时状况下，而此类响应一般不应该进行缓存。\n504 Gateway Timeout响应状态码504 Gateway Timeout 是一种 HTTP 协议的服务器端错误状态代码，表示: 扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。\nGateway（网关）在计算机网络体系中可以指代不同的设备，504 错误通常不是在客户端可以修复的，而是需要由途径的 Web 服务器或者代理服务器对其进行修复。\n505 HTTP Version Not Supported响应状态码505 HTTP Version Not Supported 是一种 HTTP 协议的服务器端错误状态代码，表示: 服务器不支持请求所使用的 HTTP 版本。\n506 Variant Also Negotiates506 码表示: 内部服务器配置错误，其中所选变量&#x2F;变元自身被配置为参与内容协商，因此并不是合适的协商端点。\n507 Insufficient Storage响应状态码 507 Insufficient Storage 响应状态码 可以在 WebDAV 协议（基于 web 的分布式创作和版本控制，参见 RFC 4918）中给出。\n507 码表示服务器不能存储相关内容。准确地说，一个方法可能没有被执行，因为服务器不能存储其表达形式，这里的表达形式指：方法所附带的数据，而且其请求必需已经发送成功。\n\nchatGPT\n507 Insufficient Storage 是 HTTP 协议定义中的状态码，表示服务器无法完成请求，因为它没有足够的存储空间来完成该请求。这通常发生在服务器存储空间已满的情况下。\n在实际应用中，服务器通常会对存储空间进行限制，以防止存储空间被耗尽导致系统崩溃。当服务器存储空间不足时，就会返回 507 状态码，告诉客户端无法完成请求。此时，客户端可以尝试通过删除一些不必要的文件或增加存储空间来解决该问题。\n需要注意的是，507 状态码通常表示服务器无法处理请求，因此客户端不应该重试相同的请求，而是应该尝试其他的解决方法。如果客户端继续发送相同的请求，可能会导致服务器存储空间进一步耗尽，最终导致服务器崩溃。\n\n\n508 Loop Detected响应状态码 508 Loop Detected 状态码可以在 WebDAV 协议（基于 Web 的分布式创作和版本控制）中给出。\n508 码表示服务器中断一个操作，因为它在处理具有“Depth: infinity”的请求时遇到了一个无限循环。508 码表示整个操作失败。\n510 Not Extended响应状态码 510 Not Extended 响应状态码在 HTTP 扩展框架协议（参见 RFC 2774）中发送。\n在 HTTP 扩展框架协议中 ，一个客户端可以发送一个包含扩展声明的请求，该声明描述了要使用的扩展。如果服务器接收到这样的请求，但是请求不支持任何所描述的扩展，那么服务器将使用 510 状态码进行响应。\n511 Network Authentication Required响应状态码511 Network Authentication Required 表示客户端需要通过验证才能使用该网络。\n该状态码不是由源头服务器生成的，而是由控制网络访问的拦截代理服务器生成的。\n网络运营商们有时候会在准许使用网络之前要求用户进行身份验证、接受某些条款，或者进行其他形式的与用户之间的互动（例如在网络咖啡厅或者机场）。他们通常用用户设备的 MAC 地址来进行识别。\n\nchatGPT\n511 Network Authentication Required 是 HTTP 协议定义中的状态码，表示客户端需要进行身份验证以便继续访问请求的资源，同时需要进行网络认证。\n在实际应用中，当客户端访问某些资源时，服务器可能会要求客户端进行身份验证，以确认客户端的身份。此外，为了保护网络安全，服务器可能还要求客户端进行网络认证，以确保客户端的请求是合法的。\n当服务器返回 511 状态码时，客户端必须提供适当的凭据，以便服务器确认客户端的身份和请求的合法性。例如，客户端可以提供用户名和密码，或者提供数字证书等。\n需要注意的是，\n511 状态码与 401 Unauthorized 状态码的区别在于，\n\n511 状态码要求客户端进行网络认证，而 401 状态码只要求客户端进行身份验证。\n此外，511 状态码通常与 VPN 等虚拟专用网络相关，用于保护网络安全\n\n\n\nHTTP 状态码什么意思参考链接深入剖析 HTTP3 协议\nWeb 开发技术&gt;HTTP&gt;HTTP 响应状态码\nHTTP Error 431：修复请求标头字段太大的 3 种方法\nHTTP 状态码含义\n维基百科 HTTP 状态码\n","slug":"2022-07-16http","date":"2022-07-16T04:47:18.000Z","categories_index":"前端基础","tags_index":"前端基础,面试,http","author_index":"举手摘月亮"},{"id":"ca603a006bae6531fc585f1adf1fac4c","title":"前端基础-TCP","content":"TCP 的特性\nTCP 提供⼀种⾯向连接的、可靠的、字节流 服务\n在⼀个 TCP 连接中，仅双⽅进⾏彼此通信。⼴播和多播不能⽤于 TCP\nTCP 使⽤校验、确认和重传机制来保证可靠传输\nTCP 使用分节排序和累积确认，来保证数据的顺序不变, 和⾮重复\nTCP 使⽤滑动窗⼝来实现流量控制，通过动态改变窗⼝的⼤⼩，进⾏拥塞控制\n\nTCP、UDP 的区别 -->\n\n\nTCP 是一种面向连接的单播协议,在 TCP 中,并不存在多播、广播的这种行为，因为 TCP 报文段中能明确发送方和接受方的 IP 地址。\nUDP 是无连接的 ,因为使用 UDP 协议的发送者和接受者之间不必存在任何长期的关系。它们没有建立连接过程，简单来说就是发送即结束\n\n\n\n\n协议\n可靠性\n双⼯性\n连接性\n有序性\n有界性\n拥塞控制\n传输速度\n量级\n头部⼤⼩\n\n\n\nTCP\n可靠(重传机 制)\n全双⼯(1:1)\n⾯向连接\n有序(通过 SYN 排 序)\n⽆, 有粘包情况\n有\n慢\n低\n20~60 字节\n\n\nUDP\n不可靠(丢包后 数据丢 失)\nn:m\n⽆连接\n⽆序\n有 ⽆粘包\n⽆\n快\n⾼\n8 字节\n\n\n意义不同\n\nTCP: Transmission Control Protocol,传输控制协议\nUDP: User Datagram Protocol,用户数据报协议\n\n双工、连接、可靠\n\n双⼯性：TCP 全双工（1:1），UDP(n:m)\n连接性：TCP 面向连接，UDP 无链接\n可靠性：TCP 可靠，有重传机制，UDP 不可靠，丢了就丢了\n\n有序、有界、有控制\n\n有序性：TCP 有序，通过 SYN 排序，UDP 无序\n有界性：TCP 无界，有粘包情况，UDP 有消息边界，无粘包\n有控制：TCP 有拥塞控制，UDP 没有拥塞控制\n\n有内容，也要有速度\n\n头⼤：TCP 头部大小 20-60 字节，UDP 头部大小 8 个字节\n量小：TCP 传输量级低于 UDP\n传的慢：TCP 相对于 UDP 而言要慢\n\n如何理解 UDP 的“无连接”特性？如何理解 UDP 的“无连接”特性？\nTCP 粘包是怎么回事，如何处理?是什么可以参⻅⽹上流传⽐较⼴的⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:\n\n先接收到 data1, 然后接收到 data2 .\n先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.\n先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.\n⼀次性接收到了 data1 和 data2 的全部数据.\n\n其中的 2,3,4 就是我们常⻅的粘包的情况.\n为什么\n默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.\n如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了.\n但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.\n\n对于处理粘包的问题, 常⻅的解决⽅案有:\n关闭 Nagle 算法 （场景：数据较大，频率不是特别高的场景）\n多次发送之前间隔⼀个等待时间 （场景：交互频率低的场景）\n进⾏封包&#x2F;拆包（场景：发送特征数据，收到后按特征数据进行分割）\n\n为什么 udp 不会粘包？\n消息提取位 TCP 协议是⾯向流的协议，UDP 是⾯向消息的协议 UDP 段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据\n消息边界 UDP具有保护消息边界，在每个 UDP 包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易 进⾏区分处理了。\n数据丢了不管 传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息&#96;。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收\n\nTCP 三次握手所谓三次握⼿(Three-way Handshake)，是指建⽴⼀个 TCP 连接时，需要客户端和服务器总共发送3个包。\n三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信息。\n\n客户端：SYN标志+序列号,进入SYN_SEND状态\n服务端：SYN标志+序列号+确认标识+确认序号, 进入SYN_RCVD状态\n客户端：确认标识+确认序号，进入ESTABLISHED状态\n\n\n点击查看更多\n在 socket 编程中，客户端执⾏ connect() 时。将触发三次握⼿。\n\n第⼀次握⼿(SYN=1, seq=x): 客户端发送⼀个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X,保存在包头 的序列号(Sequence Number)字段⾥。 发送完毕后，客户端进⼊ SYN_SEND 状态。 SYN标志+序列号+SYN_SEND\n\n第⼆次握⼿(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域 ⾥，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进⼊ SYN_RCVD 状态。\n\n第三次握⼿(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确 定字段中发送给对⽅，并且在数据段放写 ISN 的+1 发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿ 结束。 三次握⼿的过程的示意图如下：\n\n\n\n\n\n\nTCP 四次握手✨ TCP 的连接的拆除需要发送四个包，因此称为四次挥⼿(Four-way handshake)，也叫做改进的三次握⼿。客户端或服务器均可主动发起挥⼿动作，在 socket 编程中，任何⼀⽅执⾏ close() 操作即可产⽣挥⼿操作。\n\n客户端：结束标识+序列号,进⼊ FIN_WAIT_1 状态\n服务端：确认标识+确认序号,进⼊ FIN_WAIT_1 状态\n服务端：结束标识+序列号,进⼊ FIN_WAIT_2 状态\n客户端：确认标识+确认序号,进⼊ TIME_WAIT 状态\n后 续：服务端：进⼊ CLOSED 状态，客户端：两个最⼤段⽣命周期, 进⼊ CLOSED 状态\n\n\n点击查看更多\n\n第⼀次挥⼿(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为 1 的包，表示⾃⼰已经没有数据可以发送了，但是仍然 可以接受数据。 发送完毕后，客户端进⼊ FIN_WAIT_1 状态。\n第⼆次挥⼿(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭 连接。 发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务 器端关闭连接。\n第三次挥⼿(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。 TCP ⾯试题 54 发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个 ACK。\n第四次挥⼿(ACK=1，ACKnum=y+1) 客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。\n客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。 四次挥⼿的示意图如下：\n\n\n\n\n\n请求连接是三次，断开连接是四次简言之：收到后的确认应答，和结束应答是分开的\n\n服务端：确认标识+确认序号,进⼊ FIN_WAIT_1 状态\n服务端：结束标识+序列号,进⼊ FIN_WAIT_2 状态\n\n分为两个，目的是在服务端发送完数据后，然后进行发送关闭信号\n三次握手改为两次采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。\n失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。\n考虑这样一种特殊情况：主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。\n采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。\n不是很恰当的例子\n\n例子 1（3 次握手）：朋友：来吃饭 -&gt; 你：好咧，等我哈 -&gt; 朋友：👌。\n例子 2（2 次握手）：朋友：来吃饭 -&gt; 你（第二天你看到了）：好咧，等我哈。 朋友不在家（吃闭门羹）\n\n参考链接TCP 三次握手如果使用二次握手代替则会出现的问题\n","slug":"2022-07-15TCP","date":"2022-07-15T07:23:46.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"63e60c5ff1f2bb6bee35b8ec5818fb3b","title":"前端基础-安全","content":"前端安全问题?\n跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS. 早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚ ⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; VBScript &#x2F; CSS &#x2F; Flash 等\n跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤ 户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击\niframe 的滥⽤: iframe 中的内容是由第三⽅来提供的，默认情况下他们不受我们的控制，他们可以在 iframe 中运⾏ JavaScirpt 脚本、Flash 插件、弹出对话框等等，这可能会破坏前端⽤户体验\n恶意第三⽅库: 【这个就需要我们在使用一些库之前，最好能够阅读其源码】⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候我们都是在借助开发框架和各种类库进⾏ 快速开发,⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题,⽐如 event-stream 的恶意代码事件,2018 年 11 ⽉ 21 ⽇， 名为 FallingSnow 的⽤户在知名 JavaScript 应⽤库 event-stream 在 github Issuse 中发布了针对植⼊的恶意代码的疑 问，表示 event-stream 中存在⽤于窃取⽤户数字钱包的恶意代码\nDDoS 攻击， DDos全名Distributed Denial of Service，翻译成中文就是分布式拒绝服务\n中间人攻击， (Man-in-the-middle attack, MITM)\n原型攻击 防止原型污染攻击\n\nXSS 分为哪⼏类?根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM型三种。\n存储型：\n恶意代码存放的位置。 插⼊点：由谁取得恶意代码，并插⼊到⽹⻚上。 存储型 XSS 存储型 XSS 的攻击步骤：\n\n\n攻击者将恶意代码提交到⽬标⽹站的数据库中。\n⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n场景\n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。\n反射型反射型 XSS 的攻击步骤：\n\n攻击者构造出特殊的 URL，其中包含恶意代码。\n⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从URL中取出，拼接在 HTML 中返回给浏览器。\n⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。\n场景\n反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。\nPOST 的内容也可以触发反射型 XSS，只不过其触发条件⽐较苛刻（需要构造表单提交⻚⾯，并引导⽤户点击），所 以⾮常少⻅。\nDOM 型XSS DOM 型 XSS 的攻击步骤：\n\n攻击者构造出特殊的 URL，其中包含恶意代码。\n⽤户打开带有恶意代码的 URL。\n⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\nDOM 型 XSS 跟前两种 XSS 的区别：\nDOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端 JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。\n如何预防 XSS?XSS 攻击有两⼤要素：\n\n攻击者提交恶意代码。\n浏览器执⾏恶意代码。\n\n针对第⼀个要素：我们是否能够在⽤户输⼊的过程，过滤掉⽤户输⼊的恶意代码呢？\n输⼊过滤\n防⽌ HTML 中出现注⼊\n防⽌ JavaScript 执⾏时，执⾏恶意代码\n\n存储型和反射型 XSS如何产生？\n存储型和反射型 XSS 都是在服务端取出恶意代码后，插⼊到响应 HTML ⾥的，攻击者刻意编写的“数据”被内嵌到“代 码”中，被浏览器所执⾏。\n预防这两种漏洞，有两种常⻅做法：\n\n改成纯前端渲染，把代码和数据分隔开\n对 HTML 做充分转义。\n\nDOM 型 XSSDOM 型 XSS 攻击，实际上就是⽹站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执⾏了。\n\n&lt;a&gt; 标签的 href 属 性，\n在使⽤ .innerHTML 、 .outerHTML 、 document.write() 时要特别⼩⼼，不要把不可信的数据作为 HTML 插到⻚⾯上，⽽应尽量使⽤ .textContent 、 .setAttribute() 等。\n如果⽤ Vue&#x2F;React 技术栈，并且不使⽤ v-html &#x2F; dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML 、 outerHTML 的 XSS 隐患。\nDOM 中的内联事件监听器，如 location 、 onerror 、 onload、 onclick 、 onmouseover 等，\nJavaScript 的 eval() 、 setTimeout() 、 setInterval() 等，都能把字符串作为代码运⾏。\n\n如果不可信的数据拼接 到字符串中传递给这些 API，很容易产⽣安全隐患，请务必避免。\n&lt;!-- 内联事件监听器中包含恶意代码 --&gt;\n![](https:&#x2F;&#x2F;awps-assets.meituan.net&#x2F;mit-x&#x2F;blog-images-bundle-2018b&#x2F;3e724ce0.data:image&#x2F;png,)\n\n&lt;!-- 链接内包含恶意代码 --&gt;\n&lt;a href&#x3D;&quot;UNTRUSTED&quot;&gt;1&lt;&#x2F;a&gt;\n\n&lt;script&gt;\n  &#x2F;&#x2F; setTimeout()&#x2F;setInterval() 中调⽤恶意代码\n\n  setTimeout(&quot;UNTRUSTED&quot;);\n  setInterval(&quot;UNTRUSTED&quot;);\n\n  &#x2F;&#x2F; location 调⽤恶意代码\n\n  location.href &#x3D; &quot;UNTRUSTED&quot;;\n\n  &#x2F;&#x2F; eval() 中调⽤恶意代码\n  eval(&quot;UNTRUSTED&quot;);\n&lt;&#x2F;script&gt;\n\n其他 XSS 防范措施虽然在渲染⻚⾯和执⾏ JavaScript 时，通过谨慎的转义可以防⽌ XSS 的发⽣，但完全依靠开发的谨慎仍然是不够的。\n以下介绍⼀些通⽤的⽅案，可以降低 XSS 带来的⻛险和后果。\n\nContent Security Policy 严格的 CSP 在 XSS 的防范中可以起到以下的作⽤： 禁⽌加载外域代码，防⽌复杂的攻击逻辑 禁⽌外域提交，⽹站被攻击后，⽤户的数据不会泄露到外域\n禁⽌内联脚本执⾏（规则较严格，⽬前发现 GitHub 使⽤） 禁⽌未授权的脚本执⾏（新特性，Google Map 移动版在使⽤）\n合理使⽤上报可以及时发现 XSS，利于尽快修复问题 输⼊内容⻓度控制 对于不受信任的输⼊，都应该限定⼀个合理的⻓度。虽然⽆法完全防⽌ XSS 发⽣，但可以增加 XSS 攻击的难度。\n其他安全措施 HTTP-only Cookie: 禁⽌ JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注⼊后也⽆法窃取此 Cookie。 验证码：防⽌脚本冒充⽤户提交危险操作。\n\nCSRF 是什么?CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹ 站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证，绕过后台的⽤户验证，达到冒充⽤户对被攻击的⽹站 执⾏某项操作的⽬的。 ⼀个典型的 CSRF 攻击有着如下的流程：\n\n受害者登录 a.com ，并保留了登录凭证（Cookie）\n攻击者引诱受害者访问了 b.com b.com 向 a.com 发送了⼀个请求： a.com&#x2F;act&#x3D;xx\n浏览器会默认携带 a.com 的 Cookie a.com 接收到请求后，对请求进⾏验证，并确认是受害者的凭证，误以为是受害者⾃⼰发送的请求\na.com 以受害者的名义执⾏了 act&#x3D;xx\n攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执⾏了⾃⼰定义的操作\n\nCSRF 的攻击类型?\nGET 类型的 CSRF\nPOST 类型的 CSRF\n链接类型的 CSRF\n\nCSRF 的两个特点：\nCSRF（通常）发⽣在第三⽅域名\nCSRF 攻击者不能获取到 Cookie 等信息，只是使⽤。\n\n如何预防 CSRF?CSRF 通常从第三⽅⽹站发起，被攻击的⽹站⽆法防⽌攻击发⽣，只能通过增强⾃⼰⽹站针对 CSRF 的防护能⼒来提升安全性。\n针对这两点，我们可以专⻔制定防护策略，如下：\n防护思路\n阻⽌不明外域的访问 同源检测、 Samesite Cookie\n提交时要求附加本域才能获取的信息 CSRF Token、双重 Cookie 验证\n\n因此我们可以针对性得进⾏预防\n同源检测既然 CSRF ⼤多来⾃第三⽅⽹站，那么我们就直接禁⽌外域（或者不受信任的域名）对我们发起请求:\n\n使⽤ Origin Header 确定来源域名: 在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段,如果 Origin 存在，那么直接使⽤ Origin 中的字段确认来源域名就可以\n使⽤ Referer Header 确定来源域名: 根据 HTTP 协议，在 HTTP 头中有⼀个字段叫 Referer，记录了该 HTTP 请求的来 源地址\n\nCSRF TokenCSRF 的另⼀个特征是，攻击者⽆法直接窃取到⽤户的信息（Cookie，Header，⽹站内容等），仅仅是冒⽤ Cookie 中的 信息。\n⽽ CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了⽤户⾃⼰的请求。那么我们可以要求所有的 ⽤户请求都携带⼀个 CSRF 攻击者⽆法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求 和攻击的请求区分开，也可以防范 CSRF 的攻击:\nCSRF Token 的防护策略分为三个步骤：\n\n将 CSRF Token 输出到⻚⾯中\n⻚⾯提交的请求携带这个 Token\n服务器验证 Token 是否正确\n\n双重 Cookie 验证在会话中存储 CSRF Token ⽐较繁琐，⽽且不能在通⽤的拦截上统⼀处理所有的接⼝ 那么另⼀种防御措施是使⽤双重提交 Cookie。利⽤ CSRF 攻击不能获取到⽤户 Cookie 的特点，我们可以要求 Ajax 和表单 请求携带⼀个 Cookie 中的值\n双重 Cookie 采⽤以下流程：\n\n在⽤户访问⽹站⻚⾯时，向请求域名注⼊⼀个 Cookie，内容为随机字符串（例如 csrfcookie&#x3D;v8g9e4ksfhw ）。\n在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例 POST https://www.a.com/comment? csrfcookie&#x3D;v8g9e4ksfhw ）。\n后端接⼝验证 Cookie 中的字段与 URL 参数中的字段是否⼀致，不⼀致则拒绝。\n\nSamesite Cookie 属性Google 起草了⼀份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samesite 属性，它⽤来标明这个 Cookie 是 个“同站 Cookie”，同站 Cookie 只能作为第⼀⽅ Cookie，不能作为第三⽅ Cookie，Samesite 有两个属性值:\n\nSamesite=Strict: 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三⽅ Cookie\nSamesite=Lax: 这种称为宽松模式，⽐ Strict 放宽了点限制,假如这个请求是这种请求且同时是个 GET 请求，则这个 Cookie 可以作为第三⽅ Cookie\n\n⽹络劫持⽹络劫持⼀般分为两种:\n\nDNS 劫持: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持) DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器\n302 跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起 302 跳转的回复，引导⽤户获取内容\nHTTP 劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于 http 明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)\n\n如何应对⽹络劫持?\nDNS 劫持由于涉嫌违法,已经被监管起来,现在很少会有 DNS 劫持,⽽ http 劫持依然⾮常盛⾏.\n最有效的办法就是全站 HTTPS,将 HTTP 加密,这使得运营商⽆法获取明⽂,就⽆法劫持你的响应内容.\n\n中间⼈攻击中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制. 在中间⼈攻击中, 攻击者可以拦截通讯双⽅的通话并插⼊新的内容.\n⼀般的过程如下:\n\n客户端发送请求到服务端，请求被中间⼈截获服务器向客户端发送公钥中间⼈截获公钥，保留在⾃⼰⼿上。\n然后⾃⼰⽣成⼀个【伪造的】公钥，发给客户端\n客户端收到伪造的公钥后，⽣成加密 hash 值发给服务器\n中间⼈获得加密 hash 值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密 hash 值，发给服务器\n服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端\n\n重放攻击重放攻击- 中间人攻击的一种\nDDoS 攻击\n\n\n\n\n\n\n\n\nDDos全名Distributed Denial of Service，翻译成中文就是分布式拒绝服务。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，\n\n它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，\n使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，\n导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。\n\n攻击方式很多，比如UDP Flood、SYN Flood、DNS Query Flood等等。\n下面是 SYN Flood 进行 DDoS 攻击的实现原理\nSYN Flood 是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。\n一次正常的建立 TCP 连接，需要三次握手：客户端发送 SYN 报文，服务端收到请求并返回报文表示接受，客户端也返回确认，完成连接。\nSYN Flood 就是用户向服务器发送报文后突然死机或掉线，那么服务器在发出应答报文后就无法收到客户端的确认报文（第三次握手无法完成），这时服务器端一般会重试并等待一段时间后再丢弃这个未完成的连接。\n一个用户出现异常导致服务器的一个线程等待一会儿并不是大问题，但恶意攻击者大量模拟这种情况，服务器端为了维护数以万计的半连接而消耗非常多的资源，结果往往是无暇理睬客户的正常请求，甚至崩溃。从正常客户的角度看来，网站失去了响应，无法访问。\nDDOS 防御三种方案：\n挡 高防服务器、黑名单\n杀 DDos 清洗\n承受 CDN\n\n高防服务器还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。\n高防服务器: 主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~\n黑名单面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。\nDDoS 清洗DDos 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。\nDDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。\nCDN 加速CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。\n\n在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，\n另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。\n\n参考链接DDoS 攻击原理\n","slug":"2022-07-15安全","date":"2022-07-15T06:32:30.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"1e83d022f4eb1c3b94dc11a21715ce7c","title":"前端基础-webpack系列","content":"webpack 与 grunt、gulp 的不同？\nGrunt、Gulp 是基于任务运⾏的⼯具： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插 件，能⽅便的打造各种⼯作流。\n\nWebpack 是基于模块化打包的⼯具: ⾃动化处理模块,webpack 把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。 因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤ npm script 代替 Grunt、Gulp,npm script 同样可以打造任务流\n\n\nwebpack、rollup、parcel、vite 优劣？\nwebpack 适⽤于⼤型复杂的前端站点构建: webpack 有强⼤的 loader 和插件⽣态,打包后的⽂件实际上就是⼀个⽴即 执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执 ⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发.\n\n\n\n\n\n\n\n\n\n\nwebpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n\nRollup\n\n\n\n\n\n\n\n\n\n\n是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。\n\nparcel 极速零配置 Web 应用打包工具\n\n\n\n\n\n\n\n\n\n\n🚀 极速打包: Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。📦 将你所有的资源打包: Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。🐠 自动转换: 如若有需要，Babel, PostCSS, 和 PostHTML 甚至 node_modules 包会被用于自动转换代码.✂️ 零配置代码分拆: 使用动态 import() 语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。🔥 热模块替换: Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。🚨 友好的错误日志:当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题。\n\nvite 下一代前端开发与构建工具\n\n\n\n\n\n\n\n\n\n\n📦 极速的服务启动: 使用原生 ESM 文件，无需打包!⚡️ 轻量快速的热重载: 无论应用程序大小如何，都始终极快的模块热重载（HMR）🛠️ 丰富的功能: 对 TypeScript、JSX、CSS 等支持开箱即用。📦 优化的构建: 可选 “多页应用” 或 “库” 模式的预配置 Rollup 构建🔩 通用的插件: 在开发和构建之间共享 Rollup-superset 插件接口。🔑 完全类型化的 API: 灵活的 API 和完整 TypeScript 类型。\n有哪些常⻅的 Loader？更多\n文件相关的\n\n\n\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)\nurl-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)\nsource-map-loader：加载额外的 Source Map 文件，以方便断点调试\nsvg-inline-loader：将压缩后的 SVG 内容注入代码中\nimage-loader：加载并且压缩图片文件\njson-loader 加载 JSON 文件（默认包含）\nhandlebars-loader: 将 Handlebars 模版编译成函数并返回\n\n脚本相关的\n\nbabel-loader：把 ES6 转换成 ES5\nts-loader: 将 TypeScript 转换成 JavaScript\nawesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader\n\n样式相关的\n\nsass-loader：将 SCSS&#x2F;SASS 代码转换成 CSS\ncss-loader：加载 CSS，支持模块化、压缩、文件导入等特性\nstyle-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS\npostcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀\n\n校验相关的\n\neslint-loader：通过 ESLint 检查 JavaScript 代码\ntslint-loader：通过 TSLint 检查 TypeScript 代码\n\n测试相关的\n\nmocha-loader：加载 Mocha 测试用例的代码\ncoverjs-loader：计算测试的覆盖率\n\n框架相关的\n\nvue-loader：加载 Vue.js 单文件组件\n\n语言相关的\n\ni18n-loader: 国际化\n\n性能相关的\n\ncache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里\n\n见 webpack cache-loader\n有哪些常⻅的 Plugin？基本\n\ndefine-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)\nhtml-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)\nweb-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用\nclean-webpack-plugin: 目录清理\n\n编译范围优化相关\n\nignore-plugin：忽略部分文件\n\n压缩优化相关\n\nuglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)\nterser-webpack-plugin: 支持压缩 ES6 (Webpack4)\nwebpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度\n\n其他优化相关\n\nmini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)\nserviceworker-webpack-plugin：为网页应用增加离线缓存功能\nModuleConcatenationPlugin: 开启 Scope Hoisting\n\n分析相关\n\nspeed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)\nwebpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)\n\n分别介绍 bundle，chunk，module 是什么\nbundle：是由 webpack 打包出来的⽂件\nchunk：代码块，⼀个 chunk 由多个模块组合⽽成，⽤于代码的合并和分割\nmodule：是开发中的单个模块，在 webpack 的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack 会从配置的 entry 中递归开始找出所有依赖的模块\n\nLoader 和 Plugin 的不同？作用\n\nLoader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。\nPlugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\n\n使用\n\nLoader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。\nPlugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。\n\nwebpack 的构建流程是什么?Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n\n初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\n开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译\n确定入口：根据配置中的 entry 找出所有的入口文件\n编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\n完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系\n输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\n输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统\n\n在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。简单说\n\n初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler\n编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理\n输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中\n\n描述下编写 loader 的思路Loader 像⼀个”翻译官”把读到的源⽂件内容转义成新的⽂件内容，并且每个 Loader 通过链式操作，将源⽂件⼀步步翻译 成想要的样⼦。 编写 Loader 时要遵循单⼀原则，每个 Loader 只做⼀种”转义”⼯作。 每个 Loader 的拿到的是源⽂件内容（ source ），可 以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给 webpack。 还可以通过 this.async() ⽣成⼀个 callback 函数，再⽤这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了 开发 loader 的⼯具函数集—— loader-utils 。注意\n\nLoader 是无状态的，我们不应该在 Loader 中保留状态\n使用 loader-utils 和 schema-utils 为我们提供的实用工具\n加载本地 Loader 方法Npm link\n\n编写一个 loader\nloader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loader API，并通过 this 上下文访问。\nimport &#123; getOptions &#125; from &quot;loader-utils&quot;;\nimport validateOptions from &quot;schema-utils&quot;;\n\nconst schema &#x3D; &#123;\n  type: &quot;object&quot;,\n  properties: &#123;\n    test: &#123;\n      type: &quot;string&quot;,\n    &#125;,\n  &#125;,\n&#125;;\n\nexport default function (source) &#123;\n  const options &#x3D; getOptions(this);\n\n  validateOptions(schema, options, &quot;Example Loader&quot;);\n\n  &#x2F;&#x2F; 对资源应用一些转换……\n\n  return &#96;export default $&#123;JSON.stringify(source)&#125;&#96;;\n&#125;\n\n&#123;\n  test: &#x2F;\\.js$&#x2F;;\n  use: [\n    &#123;\n      loader: path.resolve(&quot;path&#x2F;to&#x2F;loader.js&quot;), &#x2F;&#x2F;直接使用本地loader\n      options: &#123;\n        &#x2F;* ... *&#x2F;\n      &#125;,\n    &#125;,\n  ];\n&#125;\n\n描述下编写 plugin 的思路？插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！\n插件目的在于解决 loader 无法实现的其他事。\nwebpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。\n&#x2F;&#x2F; ConsoleLogOnBuildWebpackPlugin.js\nconst pluginName &#x3D; &quot;ConsoleLogOnBuildWebpackPlugin&quot;;\n\nclass ConsoleLogOnBuildWebpackPlugin &#123;\n  apply(compiler) &#123;\n    &#x2F;&#x2F; 注意这个compiler\n    compiler.hooks.run.tap(pluginName, (compilation) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 注意这个compilation\n      console.log(&quot;webpack 构建过程开始！&quot;);\n    &#125;);\n  &#125;\n&#125;\n\ncompiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。\n见 plugin 剖析\nwebpack 的热更新原理Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。\nHMR 的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。\n客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。\n后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。\n见\n⽤ webpack 来优化前端性能原则：更小、更少、更近\n⽤ webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。\n更小\n\n压缩代码:删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS ⽂件，\n利⽤ cssnano （css-loader?minimize）来压缩 css\nTree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现\n\n更少\n\nCode Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存\n提取公共第三⽅库: SplitChunksPlugin 插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的 公共代码\n\n更近\n\n利⽤ CDN 加速: 在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤ webpack 对 于 output 参数和各 loader 的 publicPath 参数来修改资源路径\n\n提⾼ webpack 的打包速度打个比方：\n一期需求时间紧任务重，领导来了，说要明天上线。如何做到更快上线？（需要：更多的研发资源（并行）；之前有的功能组件直接用（不重复做事）；砍几个需求吧（更小的范围））\n用更厉害的\n\n高版本node和webpack\n\n并行\n\nhappypack: 利⽤进程并⾏编译 loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类 似的替代者是thread-loader\n\n不重复做事\n\n外部扩展(externals): 将不怎么需要更新的第三⽅库脱离 webpack 打包，不被打⼊ bundle 中，从⽽减少打包时间,⽐ 如 jQuery ⽤ script 标签引⼊\ndll: 采⽤ webpack 的 DllPlugin 和 DllReferencePlugin 引⼊ dll，让⼀些基本不会改动的代码先打包成静态资源,避免 反复编译浪费时间\n利⽤缓存: webpack.cache 、babel-loader.cacheDirectory、 HappyPack.cache 都可以利⽤缓存提⾼ rebuild 效率\n\n更小的范围\n\n缩⼩⽂件搜索范围: ⽐如 babel-loader 插件,如果你的⽂件仅存在于 src 中,那么可以 include: path.resolve(__dirname, ‘src’) ,当然绝⼤多数情况下这种操作的提升有限,除⾮不⼩⼼ build 了 node_modules ⽂件\n\n提⾼ webpack 的构建速度\n高版本node和webpack\n多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码\n通过 externals 配置来提取常⽤库\n利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。\n使⽤ Happypack 实现多线程加速编译\n使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏ 压缩来提升压缩速度\n使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码\n\n怎么配置单⻚应⽤？怎么配置多⻚应⽤？\n单⻚应⽤可以理解为 webpack 的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述\n\n\n\n多⻚应⽤的话，可以使⽤ webpack 的 AutoWebPlugin 来完成简单⾃动化的构建，但是前提是项⽬的⽬录结构必须遵守他预设的规范。 多⻚应⽤中要注意的是： 每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载。⽐如，每个⻚⾯都引⽤了同⼀套 css 样式表随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让⼊⼝的配置⾜够灵活，避免每次添加新⻚⾯还需要修改构建配置\n\n\nsource map 是什么？生产环境怎么用？source map 是将编译、打包、压缩后的代码映射回源代码的过程。\n\n打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。\nmap 文件只要不打开开发者工具，浏览器是不会加载的。\n\n线上环境一般有三种处理方案：\n\nhidden-source-map：借助第三方错误监控平台 Sentry 使用\nnosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高\nsourcemap：通过nginx 设置将 .map 文件只对白名单开放(公司内网)\n\n注意：避免在生产中使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。\n[webpack] devtool 里的 7 种 SourceMap 模式是什么鬼？\nsourcemap 关键字如下\neval\n使用 eval 包裹代码模块（这个代码块是转译后的代码，并未进行打包和压缩）eval 包裹每个代码块时候，会在后面增加”sourceURL”（和 sourcemap 里的”sourceMappingURL”不同）用来定位到原文件。\neval 模式优势在于，它是将每个模块单独 eval 执行，因此如果配合 source-map 使用，就可以单独缓存每个模块的 sourcemap，这样就可以在重新构建时候实现增量修改 sourcemap，节省时间。\n如果不使用 eval 模式，就是一个文件（chunk）对应一个 sourcemap，重新构建时候需要将整个 chunk 的 sourcemap 重新生成，更耗费时间。\n因此 eval 模式的优势就在于重新构建的速度更快\nsource-map\n产生 source map\ncheap\n用来修饰 source-map让 sourcemap 只保存行信息，不保存列信息让 sourcemap 只将打包后的代码映射到转换过的代码，不映射到原始源代码【由于源代码到转译后的代码的映射关系由相应的 loader 提供，因此 cheap 模式应该不需要关心这部分的 sourcemap】\nmodule\n用来修饰 cheap-source-map让 sourcemap 可以映射到原始源代码【由于源代码到转译后的代码的映射关系由相应的 loader 提供，因此 module 模式应该会处理这部分 sourcemap，以最终得到到原始源代码的映射】\ninline\n用来修饰 source-map将.map 作为 DataURI 嵌入，不单独生成.map 文件\nwebpack 的 sourcemap 各种参数详解\n\n\n\ndevtool\n构建速度\n重新构建速度\n生产环境\n品质\n\n\n\n(none)\n+++\n+++\nyes\n打包后的代码\n\n\neval\n+++\n+++\nno\n生成后的代码\n\n\nsource-map\n–\n–\nyes\n原始源代码\n\n\neval-source-map\n–\n+\nno\n原始源代码\n\n\ncheap-source-map\n+\no\nno\n转换过的代码（仅限行）\n\n\ncheap-module-source-map\no\n-\nno\n原始源代码（仅限行）\n\n\ncheap-eval-source-map\n+\n++\nno\n转换过的代码（仅限行）\n\n\ncheap-module-eval-source-map\no\n++\nno\n原始源代码（仅限行）\n\n\ninline-source-map\n–\n–\nno\n原始源代码\n\n\ninline-cheap-source-map\n+\no\nno\n转换过的代码（仅限行）\n\n\ninline-cheap-module-source-map\no\n-\nno\n原始源代码（仅限行）\n\n\nhidden-source-map\n–\n–\nyes\n原始源代码\n\n\nnosources-source-map\n–\n–\nyes\n无源代码内容\n\n\n模块打包原理知道吗？Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。\n文件指纹是什么？怎么用？文件指纹是打包后输出的文件名的后缀。\n\nHash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改\nChunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash\nContenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变\n\nJS 的文件指纹设置module.exports &#x3D; &#123;\n  entry: &#123;\n    app: &quot;.&#x2F;scr&#x2F;app.js&quot;,\n    search: &quot;.&#x2F;src&#x2F;search.js&quot;,\n  &#125;,\n  output: &#123;\n    filename: &quot;[name][chunkhash:8].js&quot;,\n    path: __dirname + &quot;&#x2F;dist&quot;,\n  &#125;,\n&#125;;\n\nCSS 的文件指纹设置设置 MiniCssExtractPlugin 的 filename，使用 contenthash。\nmodule.exports &#x3D; &#123;\n  entry: &#123;\n    app: &quot;.&#x2F;scr&#x2F;app.js&quot;,\n    search: &quot;.&#x2F;src&#x2F;search.js&quot;,\n  &#125;,\n  output: &#123;\n    filename: &quot;[name][chunkhash:8].js&quot;,\n    path: __dirname + &quot;&#x2F;dist&quot;,\n  &#125;,\n  plugins: [\n    new MiniCssExtractPlugin(&#123;\n      filename: &#96;[name][contenthash:8].css&#96;,\n    &#125;),\n  ],\n&#125;;\n\n图片的文件指纹设置设置file-loader的name，使用hash。占位符名称及含义\n\next 资源后缀名\nname 文件名称\npath 文件的相对路径\nfolder 文件所在的文件夹\ncontenthash 文件的内容 hash，默认是 md5 生成\nhash 文件内容的 hash，默认是 md5 生成\nemoji 一个随机的指代文件内容的 emoj\n\nconst path &#x3D; require(&quot;path&quot;);\n\nmodule.exports &#x3D; &#123;\n  entry: &quot;.&#x2F;src&#x2F;index.js&quot;,\n  output: &#123;\n    filename: &quot;bundle.js&quot;,\n    path: path.resolve(__dirname, &quot;dist&quot;),\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.(png|svg|jpg|gif)$&#x2F;,\n        use: [\n          &#123;\n            loader: &quot;file-loader&quot;, &#x2F;&#x2F; 这里\n            options: &#123;\n              name: &quot;img&#x2F;[name][hash:8].[ext]&quot;, &#x2F;&#x2F; 这里\n            &#125;,\n          &#125;,\n        ],\n      &#125;,\n    ],\n  &#125;,\n&#125;;\n\n如何对 bundle 体积进行监控和分析？\nVSCode 中有一个插件 Import Cost 可以帮助我们对引入模块的大小进行实时监测，\n还可以使用 webpack-bundle-analyzer 生成 bundle 的模块组成图，显示所占体积。\n\n参考链接吐血整理」再来一打 Webpack 面试题\n最近两周出去面试遇到的面试题（前端初级、长更）\n","slug":"2022-07-14webpack","date":"2022-07-14T14:19:31.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"12cc7106661c51633c97f9b1ac94a946","title":"前端基础-数组","content":"思维导图\n创建\n取值\n查找\n扁平化\n遍历\n返回 boolean\n返回字符串\n增&#x2F;删&#x2F;改&#x2F;拷贝&#x2F;解构\n\n\n详细内容\n\n\n\n查看数组 proto[1, 2, 3]; &#x2F;&#x2F; 将结果展开后，见下图\n\n\n\n哎呦 [].__proto__Object.getOwnPropertyDescriptors([].__proto__);\n\n\n\n\n查看 json 数据\n&#123;\n  &quot;at&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;concat&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;constructor&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;copyWithin&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;entries&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;every&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;fill&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;filter&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;find&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;findIndex&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;findLast&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;findLastIndex&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;flat&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;flatMap&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;forEach&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;includes&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;indexOf&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;join&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;keys&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;lastIndexOf&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;length&quot;: &#123;\n    &quot;configurable&quot;: false,\n    &quot;enumerable&quot;: false,\n    &quot;value&quot;: 0,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;map&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;pop&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;push&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;reduce&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;reduceRight&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;reverse&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;shift&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;slice&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;some&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;sort&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;splice&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;toLocaleString&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;toString&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;unshift&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;,\n  &quot;values&quot;: &#123;\n    &quot;configurable&quot;: true,\n    &quot;enumerable&quot;: false,\n    &quot;writable&quot;: true\n  &#125;\n&#125;\n\n\n\n一点想法Object.keys(Object.getOwnPropertyDescriptors([].__proto__));\n\n\n\natat() 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。\nvar a &#x3D; [1, 2, 3];\na[-1]; &#x2F;&#x2F; undefined\na.at(-1); &#x2F;&#x2F; 3\n\npolyfill\nif (Array.at) &#123;\n  Array.proptotype.at &#x3D; function (index) &#123;\n    if (index &gt;&#x3D; 0) &#123;\n      return this[index];\n    &#125; else &#123;\n      return this.slice(index, index + 1)?.[0];\n    &#125;\n  &#125;;\n&#125;\n\nconcat&#x2F;&#x2F; 语法\nvar new_array &#x3D; old_array.concat(value1[, value2[, ...[, valueN]]])\n\n\n\n\n\n\n\n\n\n\nconcat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。数组和&#x2F;或值，将被合并到一个新的数组中。如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝\n\n对象引用（而不是实际对象）：concat 将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。\n数据类型如字符串，数字和布尔（不是 String，Number 和 Boolean 对象）：concat 将字符串和数字的值复制到新数组中。\n\n使用：见 MDN 示例\nconstructorconstructor 属性返回 Object 的构造函数（用于创建实例对象）。见\n注意\n\n\n\n\n\n\nWARNING\n\n注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。\n\n可以为除了 null 和 undefined（因为这两者没有相应的构造函数）之外的任何类型指定\n\n每当把这样的基本类型当成对象使用时，其对应的构造函数的实例就会在语句执行后立即被创建和丢弃。\n\n任何对象都可以更改 constructor 属性的值，请注意，改变 constructor 的属性不会影响 instanceof 运算符\n\n如果对象被密封或冻结，那么更改 constructor 将不会起作用，也不会抛出异常：\n\n\n\n\nconst a &#x3D; new Array();\na.constructor &#x3D;&#x3D;&#x3D; Array; &#x2F;&#x2F; true\n\ncopyWithin左闭右开\ncopyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。\nconst array1 &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];\n\n&#x2F;&#x2F; 把下标3的元素拷贝到下标为0的位置\nconsole.log(array1.copyWithin(0, 3, 4));\n&#x2F;&#x2F; [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]\n\n&#x2F;&#x2F; 把下标从3开始到结束的元素，拷贝到1的位置\nconsole.log(array1.copyWithin(1, 3));\n&#x2F;&#x2F; [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;]\n\nentriesentries() 方法返回一个新的 Array Iterator 对象，该对象包含数组中每个索引的键&#x2F;值对。\n示例见\neveryfill左闭右开\nfill() 方法用一个固定值填充一个数组中, 从 起始索引 到 终止索引 内的全部元素。不包括 终止索引。\n语法\narr.fill(value[, start[, end]])\n[1, 2, 3].fill(4); &#x2F;&#x2F; [4, 4, 4]\n[1, 2, 3].fill(4, 1); &#x2F;&#x2F; [1, 4, 4]\n[1, 2, 3].fill(4, 1, 2); &#x2F;&#x2F; [1, 4, 3]\n[1, 2, 3].fill(4, 1, 1); &#x2F;&#x2F; [1, 2, 3]\n[1, 2, 3].fill(4, 3, 3); &#x2F;&#x2F; [1, 2, 3]\n[1, 2, 3].fill(4, -3, -2); &#x2F;&#x2F; [4, 2, 3]\n[1, 2, 3].fill(4, NaN, NaN); &#x2F;&#x2F; [1, 2, 3]\n[1, 2, 3].fill(4, 3, 5); &#x2F;&#x2F; [1, 2, 3]\nArray(3).fill(4); &#x2F;&#x2F; [4, 4, 4]\n[].fill.call(&#123; length: 3 &#125;, 4); &#x2F;&#x2F; &#123;0: 4, 1: 4, 2: 4, length: 3&#125;\n\n注意\n\n\n\n\n\n\nWARNING\n&#x2F;&#x2F; Objects by reference.\nvar arr &#x3D; Array(3).fill(&#123;&#125;); &#x2F;&#x2F; [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n&#x2F;&#x2F; 需要注意如果 fill 的参数为引用类型，会导致都执行同一个引用类型\n&#x2F;&#x2F; 如 arr[0] &#x3D;&#x3D;&#x3D; arr[1] 为 true\narr[0].hi &#x3D; &quot;hi&quot;; &#x2F;&#x2F; [&#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;]\n\n\n\nfilterfindfindIndexfindLastfindLastIndexflatflatMapforEachincludesindexOfjoinkeyslastIndexOflengthmappoppushreducereduceRightreverseshiftslice左闭右开\nslice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）。原始数组不会被改变。\n&#x2F;&#x2F; 语法\narr.slice([begin[, end]])\n\nsomesortsort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的\nconst months &#x3D; [&quot;March&quot;, &quot;Jan&quot;, &quot;Feb&quot;, &quot;Dec&quot;];\nmonths.sort();\nconsole.log(months);\n&#x2F;&#x2F;  [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]\n\nconst array1 &#x3D; [1, 30, 4, 21, 100000];\narray1.sort();\nconsole.log(array1);\n&#x2F;&#x2F; [1, 100000, 21, 30, 4]\n\n\n\n\n\n\n\n\nWARNING\nES10（EcmaScript 2019）以前没有要求稳定性，意味着你可能会得到以下结果：\nconst students &#x3D; [\n  &#123; name: &quot;Alex&quot;, grade: 15 &#125;,\n  &#123; name: &quot;Devlin&quot;, grade: 15 &#125;,\n  &#123; name: &quot;Eagle&quot;, grade: 13 &#125;,\n  &#123; name: &quot;Sam&quot;, grade: 14 &#125;,\n];\n\nstudents.sort((firstItem, secondItem) &#x3D;&gt; firstItem.grade - secondItem.grade);\n\n&#x2F;&#x2F; es10 +\n\n&#x2F;&#x2F; [\n&#x2F;&#x2F;   &#123; name: &quot;Eagle&quot;,  grade: 13 &#125;,\n&#x2F;&#x2F;   &#123; name: &quot;Sam&quot;,    grade: 14 &#125;,\n&#x2F;&#x2F;   &#123; name: &quot;Alex&quot;,   grade: 15 &#125;, &#x2F;&#x2F; grade 相同时维持原先的顺序 (稳定排序)\n&#x2F;&#x2F;   &#123; name: &quot;Devlin&quot;, grade: 15 &#125;, &#x2F;&#x2F; grade 相同时维持原先的顺序 (稳定排序)\n&#x2F;&#x2F; ];\n\n&#x2F;&#x2F; - es9\n\n&#x2F;&#x2F; [\n&#x2F;&#x2F;   &#123; name: &quot;Eagle&quot;,  grade: 13 &#125;,\n&#x2F;&#x2F;   &#123; name: &quot;Sam&quot;,    grade: 14 &#125;,\n&#x2F;&#x2F;   &#123; name: &quot;Devlin&quot;, grade: 15 &#125;, &#x2F;&#x2F; 没有维持原先的顺序\n&#x2F;&#x2F;   &#123; name: &quot;Alex&quot;,   grade: 15 &#125;, &#x2F;&#x2F; 没有维持原先的顺序\n&#x2F;&#x2F; ];\n\n\n\nsplicesplice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。\n示例见\ntoLocaleStringtoStringunshiftvaluesvar a &#x3D; [1, 2, 3];\n\nArray.from(a.keys()); &#x2F;&#x2F; [0, 1, 2]\n\na.fill(10); &#x2F;&#x2F;  [10, 10, 10]\n\na.fill(1, 0, 1); &#x2F;&#x2F;  [1, 10, 10]\n\nArray.from(a.entries()); &#x2F;&#x2F; [[0,1],[1,10],[2,10]]\n\n几个非原型链上的方法isArray\nArray.prototype 也是一个数组\n\nArray.isArray(Array.prototype); &#x2F;&#x2F; 鲜为人知的事实：其实 Array.prototype 也是一个数组。\n\n\ninstanceof_和_isArray当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能检测 iframes\npolyfill\n\nif (!Array.isArray) &#123;\n  Array.isArray &#x3D; function (arg) &#123;\n    return Object.prototype.toString.call(arg) &#x3D;&#x3D;&#x3D; &quot;[object Array]&quot;;\n  &#125;;\n&#125;\n\nofArray.of(7); &#x2F;&#x2F; [7]\nArray.of(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]\n\nArray(7); &#x2F;&#x2F; [ , , , , , , ]\nArray(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]\n\n参考链接MDN Array\n","slug":"2022-07-14js-arr","date":"2022-07-14T07:40:32.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"4d4a2baebc5a8e28d7b1ee35ff588bdb","title":"cookie注入问题","content":"问题注入的 cookie 怎么没有啦，在vconsole中调试查看，storage有cookie信息,接口调用，发现没有 cookie 被SSO校验拦截住了\n抓包结果服务端渲染，中间有代理转发，nextjs 服务端自适应\n\n\n接口请求\n\n\n问题分析通过 chrome,手动注入调试发现正常。手动注入一般情况是默认/,字段不是很多，cookie 注入有问题，问题大概出现在 path\n\n\n\n\n直接搜了下cookie path就把问题解决了\n修改前代码(function () &#123;\n  document.cookie &#x3D; &quot;SSO_USER_TOKEN&#x3D;值;&quot;;\n&#125;)();\n\n调试默认path\n\n\npath=/\n\n\ncookie 的 path 值的默认规则\n\n\n\n\n\n\n\n\ncookie 的 path 值的默认规则当 cookie 的 path 设置了值不为 null 的时候，以设置的值为准。(满足当前场景需要)当 cookie 的 path 为 null 时候，获取请求的 URI 的 path 值1). 当 URI 的 path 值是以“&#x2F;”结尾的时候，直接设置为 cookie 的 path 值2). 当 URI 的 path 值不是以“&#x2F;”结尾的时候，查看 path 里面是否有“&#x2F;”2.1). 如果有“&#x2F;”的话，直接截取到最后一个“&#x2F;”，然后设置为 cookie 的 path 值。2.2). 如果没有“&#x2F;”的话，将 cookie 的 path 设置为”&#x2F;”。\n对于 1).测试结果如下：并不满足本次业务需要\n\n\n修改后代码将 cookie 注入到/,代码path=/;\n(function () &#123;\n  document.cookie &#x3D; &quot;SSO_USER_TOKEN&#x3D;值;path&#x3D;&#x2F;;&quot;;\n&#125;)();\n\nNOTE 各字段含义百度百科\nCookie 是一段不超过 4KB 的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。其中 ：\n\nName&#x2F;Value：设置 Cookie 的名称及相对应的值，对于认证 Cookie，Value 值包括 Web 服务器所提供的访问令牌 。\n\nExpires 属性：设置 Cookie 的生存期。有两种存储类型的 Cookie：会话性与持久性。\n2.1 Expires 属性缺省时，为会话性 Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效;2.2 持久性 Cookie 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。\n\nDomain 属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie 受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围 。\n\nPath 属性：定义了 Web 站点上可以访问该 Cookie 的目录 。\n\nSecure 属性：指定是否使用 HTTPS 安全协议发送 Cookie。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。该方法也可用于 Web 站点的身份鉴别，即在 HTTPS 的连接建立阶段，浏览器会检查 Web 网站的 SSL 证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到 SSL 证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。由于许多用户缺乏安全意识，因而仍可能连接到 Pharming 攻击所伪造的网站 。\n\nHTTPOnly 属性 ：用于防止客户端脚本通过 document.cookie 属性访问 Cookie，有助于保护 Cookie 不被跨站脚本攻击窃取或篡改。但是，HTTPOnly 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 Cookie 的读操作，但允许写操作；此外大多数浏览器仍允许通过 XMLHTTP 对象读取 HTTP 响应中的 Set-Cookie 头 。\n\n\n参考链接cookie 的 path 值的默认规则\n百度百科\n","slug":"2022-07-12cookie","date":"2022-07-12T07:37:09.000Z","categories_index":"webview","tags_index":"webview,cookie","author_index":"举手摘月亮"},{"id":"74208bc76768a419347d0ad3e15c33b0","title":"企业微信文件预览","content":"企业微信文件预览试错 1:\nconst fileName &#x3D; &quot;xxxxx.jpeg&quot;; &#x2F;&#x2F; 举个例子\ndownloadAttachment(downloadUrl).then((res) &#x3D;&gt; &#123;\n  var reader &#x3D; new FileReader();\n  reader.readAsDataURL(res); &#x2F;&#x2F; 转换为base64，可以直接放入a标签href\n  reader.onload &#x3D; function (e) &#123;\n    const anchorEle &#x3D; document.createElement(&quot;a&quot;);\n    document.body.appendChild(anchorEle);\n    anchorEle.href &#x3D; e?.target?.result as any;\n    anchorEle.download &#x3D; fileName;\n    anchorEle.click();\n    setTimeout(() &#x3D;&gt; &#123;\n      document.body.removeChild(anchorEle);\n    &#125;);\n  &#125;;\n&#125;);\n\n试错 2: file-saver\n试错 3: file-saver\nexport const downloadFile &#x3D; (target, filename &#x3D; &quot;&quot;, type &#x3D; &quot;url&quot;) &#x3D;&gt; &#123;\n  const link &#x3D; document.createElement(&quot;a&quot;);\n  const body &#x3D; document.querySelector(&quot;body&quot;);\n  if (!body) return;\n\n  &#x2F;&#x2F; 需下载的文件类型\n  if (type &#x3D;&#x3D;&#x3D; &quot;url&quot;) &#123;\n    link.href &#x3D; target;\n  &#125; else if (type &#x3D;&#x3D;&#x3D; &quot;blob&quot;) &#123;\n    link.href &#x3D; window.URL.createObjectURL(target);\n  &#125;\n\n  &#x2F;&#x2F; 文件名\n  if (filename) link.download &#x3D; filename;\n\n  link.style.display &#x3D; &quot;none&quot;;\n  body.appendChild(link);\n\n  link.click();\n\n  window.URL.revokeObjectURL(link.href); &#x2F;&#x2F; 释放 URL 对象\n  body.removeChild(link);\n&#125;;\n\n在浏览器上没问题，在企业微信上嗝屁～，有人要说了，直接window.open(downloadUrl),通常来说没毛病。\n可是，要在请求downloadUrl接口时候要加一个请求头，这尼玛整的～\n\n\n这场景真 🐶为什么有这么奇葩的事情呢？—— 继之前，对同一个域名，以请求头区分是企业微信、非企业微信，两种环境的授权校验方式不同。本身涉及没使用 userAgent,设计缺陷，导致一连串问题。\n问：你怎么不重构？ 答：部门都被裁了，我再努力有用吗？\n解决方案方案 1: 按照之前的设计，再申请个域名，按照域名把应用拆分（这个要走审核）\n方案 2: 后端处理用userAgent处理下，其他地方逻辑不动，只处理 a 标签下载的情况（这个要后端改---没权限我觉得我自己改或许更快）\n方案 3: 把 API 改了，哪里出问题改哪里 api/wx/download 给这个增加请求头， 代理到 api/download（这里应该会带过来请求头）\nlet fileUrl &#x3D;\n  &quot;themis&#x2F;attach&#x2F;download?cloudKey&#x3D;&quot; +\n  attachment.themisCloudKey +\n  &quot;&amp;fileName&#x3D;&quot; +\n  encodeURIComponen(attachment.name);\n&#x2F;&#x2F; 企业微信\nif (getWechatUserAgent(navigator.userAgent)) &#123;\n  downloadFile(&#96;&#x2F;api&#x2F;redline&#x2F;wx&#x2F;$&#123;fileUrl&#125;&#96;);\n  &#x2F;&#x2F; 非企业微信\n&#125; else &#123;\n  downloadFile(&#96;&#x2F;api&#x2F;redline&#x2F;$&#123;fileUrl&#125;&#96;);\n&#125;\n\n\n\n\n\n哈哈～，开心～\n","slug":"2022-07-05wxfile","date":"2022-07-05T15:16:30.000Z","categories_index":"企业微信","tags_index":"企业微信","author_index":"举手摘月亮"},{"id":"b6eefb99ab4e0f88e52602483fde65dd","title":"前端基础-js算法","content":"实现单例通过构造函数class Singleton &#123;\n  constructor() &#123;\n    console.log(&#39;this&#39;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n通过静态方法class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; Singleton.getInstance();\nconst b &#x3D; Singleton.getInstance();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);\n\n字符串相关见：2022-05-03string\n深度操作深拷贝structuredClone见\n&#x2F;&#x2F; Create an object with a value and a circular reference to itself.\nconst original &#x3D; &#123; name: &quot;MDN&quot; , hello: &#123;world: true&#125;&#125;;\noriginal.itself &#x3D; original;\n\n&#x2F;&#x2F; Clone it\nconst clone &#x3D; structuredClone(original);\n\nconsole.log(clone !&#x3D;&#x3D; original); &#x2F;&#x2F;  true  the objects are not the same (not same identity)\nconsole.log(clone.name &#x3D;&#x3D;&#x3D; &quot;MDN&quot;); &#x2F;&#x2F; true  they do have the same values\nconsole.log(clone.itself &#x3D;&#x3D;&#x3D; clone); &#x2F;&#x2F; true and the circular reference is preserved\nconsole.log(clone.hello &#x3D;&#x3D;&#x3D; original.hello) false\n\n深度克隆function isBase &#x3D; (val) &#x3D;&gt; &#123;\n  return val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &quot;object&quot;\n&#125;\n\nfunction isObject(obj) &#123;\n  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Object]&quot;;\n&#125;\n\nfunction isArray(obj) &#123;\n  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Array]&quot;;\n&#125;\n\nfunction deepClone(obj) &#123;\n  let result;\n  if (isBase(obj)) &#123;\n    &#x2F;&#x2F;基本数据类型，直接赋值\n    result &#x3D; obj;\n  &#125; else &#123;\n    &#x2F;&#x2F; 非基本数据类型，遍历赋值\n    result &#x3D; isArray(obj) ? [] : &#123;&#125;; &#x2F;&#x2F; 空对象接收\n    for (let i in obj) &#123;\n      &#x2F;&#x2F; prettier-ignore\n      result[i] &#x3D; isObject(obj[i]) || isArray(obj[i]) ? deepClone(obj[i]) : obj[i];\n    &#125;\n  &#125;\n  return result;\n&#125;\n\n深比较实现一个 compare 函数，比较两个对象是否相同见\n&#x2F;**\n * 原理：\n * 1. 基本数据类型比较\n * 2. 复合类型，递归每个值依次比较\n **&#x2F;\n&#x2F;&#x2F; 基础类型&#x2F;null的数据类型，可以直接比较\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &#39;object&#39;;\n\nfunction deepCompare(a, b) &#123;\n  &#x2F;&#x2F; 基本数据类型\n  if (isBase(a) || isBase(b)) &#123;\n    return a &#x3D;&#x3D;&#x3D; b || (isNaN(a) &amp;&amp; isNaN(b));\n  &#125;\n  &#x2F;&#x2F; Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。\n  const propsA &#x3D; Object.getOwnPropertyDescriptors(a);\n  const propsB &#x3D; Object.getOwnPropertyDescriptors(b);\n  &#x2F;&#x2F; 键是否长度一致\n  if (Object.keys(propsA).length !&#x3D;&#x3D; Object.keys(propsB).length) &#123;\n    return false;\n  &#125;\n  &#x2F;&#x2F; 键对应相等\n  return Object.keys(propsA).every((key) &#x3D;&gt; deepCompare(a[key], b[key]));\n&#125;\n\n深度获取差异化&#x2F;&#x2F; 是否为基础数据类型\nconst isBase &#x3D; (val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; null || typeof val !&#x3D;&#x3D; &#39;object&#39;;\nconst isNumber &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &#39;[object Number]&#39;;\n&#x2F;&#x2F; 深度比较两个对象的差异\nfunction deepDiffCompare(a, b, diffResult, k &#x3D; &#39;root&#39;) &#123;\n  &#x2F;&#x2F; 基本数据类型\n  if (isBase(a) || isBase(b)) &#123;\n    &#x2F;&#x2F; return a &#x3D;&#x3D;&#x3D; b;\n    if (a !&#x3D;&#x3D; b) &#123;\n      diffResult[k] &#x3D; b;\n    &#125; else &#123;\n      &#x2F;&#x2F; console.log(&quot;数据一致忽略&quot;);\n    &#125;\n  &#125; else &#123;\n    const propsA &#x3D; Object.keys(a);\n    const propsB &#x3D; Object.keys(b);\n    const uukeys &#x3D; new Set([...propsA, ...propsB]);\n    &#x2F;&#x2F; 键对应相等\n    uukeys.forEach((key) &#x3D;&gt; deepDiffCompare(a[key], b[key], diffResult, key));\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 必填数据\nconst requireds &#x3D; [&#39;sex&#39;];\n&#x2F;&#x2F; 模拟数据\nconst old &#x3D; &#123; name: 1, age: 2, dog: &#123; name: &#39;小狗&#39;, do: &#39;汪汪叫&#39; &#125; &#125;;\nconst newValue &#x3D; &#123; name: 1, age: 2, sex: 1 &#125;;\n&#x2F;&#x2F; 执行比较测试\nhandleCompare(old, newValue);\n\n&#x2F;&#x2F; 这里涉及到函数声明提升，写在后面不影响使用\nfunction handleCompare(old, newValue, onChange) &#123;\n  let diffResult &#x3D; &#123;&#125;;\n\n  deepDiffCompare(old, newValue, diffResult);\n\n  &#x2F;&#x2F; console.log(&quot;diffResult&quot;, diffResult);\n  &#x2F;&#x2F; 变化的数据，在必填数据中，则hasChange为true, 否则为false\n  const hasChange &#x3D; Object.keys(diffResult).some((k) &#x3D;&gt; requireds.includes(k));\n\n  &#x2F;&#x2F; console.log(&quot;hasChange&quot;, hasChange);\n  hasChange &amp;&amp; onChange?.();\n&#125;\n\n&#x2F;&#x2F; vue中使用\n&#x2F;&#x2F; watch: &#123;\n&#x2F;&#x2F;   &#39;submitForm&#39;: &#123;\n&#x2F;&#x2F;      handler(val, oldVal) &#123;\n&#x2F;&#x2F;       console.log(&#39;c changed&#39;)\n&#x2F;&#x2F;       handleCompare(oldVal, val, ()&#x3D;&gt;&#123;\n&#x2F;&#x2F;         this.clearTableData()\n&#x2F;&#x2F;       &#125;)\n&#x2F;&#x2F;     &#125;,\n&#x2F;&#x2F;     deep: true\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F;  &#125;\n\n深度拼接实现 json.stringify\nMDN JSON.stringify js 实现\n见：2023-02-27json\n深度解析实现 json.parse\nfunction parse(sJSON) &#123;\n  return eval(&#39;(&#39; + sJSON + &#39;)&#39;);\n&#125;\n\n闭包uuidconst getUniqueID &#x3D; ((id) &#x3D;&gt; () &#x3D;&gt; &#123;\n  id +&#x3D; 1;\n  return id;\n&#125;)(-1);\n\n&#x2F;&#x2F; getUniqueID\n&#x2F;&#x2F; () &#x3D;&gt; &#123;\n&#x2F;&#x2F;   id +&#x3D; 1;\n&#x2F;&#x2F;   return id;\n&#x2F;&#x2F; &#125;\n\n操作后防抖&#x2F;&#x2F; 去抖动原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时.\n&#x2F;&#x2F; 方法1\nconst debounce &#x3D; function (fn, delay) &#123;\n  let timer &#x3D; null; &#x2F;&#x2F; 闭包维护一个timer\n  return (...args) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 柯里化\n    clearTimeout(timer);\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn?.apply(this, args); &#x2F;&#x2F; this指向window\n    &#125;, delay);\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; 测试\n\nlet biu &#x3D; function () &#123;\n  console.log(&#39;biu biu biu&#39;, new Date().getTime());\n&#125;;\nlet boom &#x3D; function () &#123;\n  console.log(&#39;boom boom boom&#39;, new Date().getTime());\n&#125;;\n\nvar a &#x3D; setInterval(debounce(biu, 500), 1000);\nvar b &#x3D; setInterval(debounce(boom, 2000), 1000);\nsetTimeout(() &#x3D;&gt; &#123;\n  clearInterval(a);\n  clearInterval(b);\n&#125;, 10000);\n\n执行一次后防抖function debounceStart(fn, delay &#x3D; 0) &#123;\n  let immediate &#x3D; true;\n  let timerId &#x3D; null;\n  return function (...args) &#123;\n    if (immediate) &#123;\n      fn.apply(this, args);\n      immediate &#x3D; false;\n    &#125;\n    clearTimeout(timerId);\n    timerId &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      immediate &#x3D; true;\n    &#125;, delay);\n  &#125;;\n&#125;\n\n节流const throttle &#x3D; (fn, delay &#x3D; 500) &#x3D;&gt; &#123;\n  let allow &#x3D; true; &#x2F;&#x2F; 守门员，delay秒钟放进去一个球\n\n  return (...args) &#x3D;&gt; &#123;\n    if (!allow) return;\n    allow &#x3D; false;\n\n    setTimeout(() &#x3D;&gt; &#123;\n      fn.apply(this, args);\n      allow &#x3D; true;\n    &#125;, delay);\n  &#125;;\n&#125;;\n\n接口数据缓存this 指向https://juejin.cn/post/6977563249650696206\ncall\n语法\n\nfunction.call(thisArg, arg1, arg2, ...)\n\n\ncall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 即：可以改变当前函数的 this 指向；还会让当前函数执行。\n&#x2F;&#x2F; 1. 给函数原型添加mycall方法，创建一个上下文对象context，如果传入的对象不存在时，将指向全局window。\n&#x2F;&#x2F; 2. 通过给context添加fn属性，context的fn引用调用该方法的函数fun，并执行fun。\n&#x2F;&#x2F; 3. 执行完成之后删除该属性fn。\nFunction.prototype.mycall &#x3D; function (context, ...args) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  context &#x3D; context &#x3D;&#x3D; null || context &#x3D;&#x3D; undefined ? window : new Object(context);\n  context.fn &#x3D; this;\n  let r &#x3D; context.fn(...args);\n  delete context.fn;\n  return r;\n&#125;;\n\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123; name: &#39;clying&#39; &#125;;\nfun.mycall(obj, &#39;deng&#39;, &#39;deng&#39;);\n\napply\n语法\n\napply(thisArg);\napply(thisArg, argsArray);\n\n\n与 call 方法类似，call 方法接收的是一个参数列表，而 apply 方法接收的是一个包含多个参数的数组。\n用法 将函数中的 this 指向传入的第一个参数，第二个参数为数组\n\nFunction.prototype.myapply &#x3D; function (context, args) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  context &#x3D; context &#x3D;&#x3D; null || context &#x3D;&#x3D; undefined ? window : new Object(context);\n\n  context.fn &#x3D; this;\n\n  if (!args) return context.fn();\n  &#x2F;&#x2F; args 数组被转化成字符串\n  let r &#x3D; eval(&#39;context.fn(&#39; + args + &#39;)&#39;);\n  delete context.fn;\n  return r;\n&#125;;\n\nbind更像是数据收集，通过柯里化，减少参数，方便后续调用\n\nbind() 方法创建一个新的函数，不自动执行，需要手动调用 bind() 。\n这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用\n用法将 obj 绑定到 fun 函数的 this 上，函数 fun 可以使用 obj 内部的属性，和传入的变量。\n\n&#x2F;&#x2F; 应用于curry，要理解\nFunction.prototype.mybind &#x3D; function (context) &#123;\n  let that &#x3D; this;\n  let bindargs &#x3D; Array.prototype.slice.call(arguments, 1);\n  &#x2F;&#x2F; 产生闭包\n  function fBind() &#123;\n    let args &#x3D; Array.prototype.slice.call(arguments);\n    &#x2F;&#x2F; 1. 如果使用的是new，那么this会指向fBind实例，this作为当前实例传入\n    &#x2F;&#x2F; 2. 不是new的话，使用context上下文对象\n    &#x2F;&#x2F; prettier-ignore\n    return that.apply( this instanceof fBind ? this : context, bindargs.concat(args)) &#x2F;&#x2F; 通过闭包获取更多的参数;\n  &#125;\n\n  return fBind;\n&#125;;\n\n&#x2F;&#x2F; 测试1\n\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123;\n  name: &#39;clying&#39;,\n&#125;;\nlet b &#x3D; fun.mybind(obj, 2);\nb(3);\n&#x2F;&#x2F; clying Arguments(2) [2, 3]\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F; 测试2\nfunction fun() &#123;\n  console.log(this.name, arguments);\n&#125;\nlet obj &#x3D; &#123;\n  name: &#39;clying&#39;,\n&#125;;\nfun.prototype.age &#x3D; 23;\nlet b &#x3D; fun.mybind(obj, 3);\nlet instance &#x3D; new b(4);\nconsole.log(instance.age);\n&#x2F;&#x2F;undefined Arguments(2) [3, 4]\n&#x2F;&#x2F; 23\n\nPromise手写 promise 的方法（all、race、allSettled、any、finally）\n手写 promise5K 字 由浅入深聊聊 Promise 实现原理\nPromise.all\n要么返回全部 resolve 结果，要么返回一个 reject\n\nPromise.myAll &#x3D; function (promises) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    if (!isArray(promises)) &#123;\n      return reject(new TypeError(&#39;arguments must be an array&#39;));\n    &#125;\n\n    let res &#x3D; [];\n    var resolvedCounter &#x3D; 0;\n    var promiseNum &#x3D; promises.length;\n\n    promises.forEach((promise, index) &#x3D;&gt; &#123;\n      Promise.resolve(promise) &#x2F;&#x2F; 防止你不是一个promise\n        &#x2F;&#x2F; 如果参数是一个原始值,或者是一个不具有then方法的对象,则Promise.resolve方法返回一个新的 Promise 对象,状态为resolved\n        &#x2F;&#x2F; @link https:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html\n        .then((data) &#x3D;&gt; &#123;\n          resolvedCounter++;\n          res.push(data);\n          &#x2F;&#x2F; 所有的都没有异常\n          promiseNum &#x3D;&#x3D;&#x3D; resolvedCounter &amp;&amp; resolve(res);\n        &#125;)\n        .catch((err) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 捕获，直接返回\n          reject(err);\n        &#125;);\n    &#125;);\n  &#125;);\n&#125;;\n\nPromise.race\n不管 resolve, reject，见到就返回\n\nPromise.myRace &#x3D; (promises) &#x3D;&gt;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    promises?.forEach((promise) &#x3D;&gt; &#123;\n      promise.then(resolve, reject);\n    &#125;);\n  &#125;);\n\nPromise.allSettle\n全部结果，resolve, reject 都要\n\nPromise.myAllSettled &#x3D; function (promises) &#123;\n  let len &#x3D; promises.length;\n  let count &#x3D; 0;\n  let result &#x3D; new Array(len);\n\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    for (let p of promises) &#123;\n      Promise.resolve(p).then(\n        (res) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;成功：加入装状态列表\n          result[count] &#x3D; &#123;\n            &#x2F;&#x2F;记录当前promise信息\n            status: &#39;fullfilled&#39;,\n            result: res,\n          &#125;;\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F;遍历完，走resolve\n            resolve(result);\n          &#125;\n        &#125;,\n        (err) &#x3D;&gt; &#123;\n          &#x2F;&#x2F;失败：加入状态列表\n          result[count] &#x3D; &#123;\n            &#x2F;&#x2F;记录当前promise状态信息\n            status: &#39;rejected&#39;,\n            result: err,\n          &#125;;\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F;遍历完依然走resolve\n            reject(result);\n          &#125;\n        &#125;\n      );\n    &#125;\n  &#125;);\n&#125;;\n\nPromise.any\n要么没有 resolve 的,返回全部 reject 结果，要么有一个 resolve 的返回 resolve 结果(看上去和Promise.all刚好反过来了)\n\nPromise.myAny &#x3D; function (promises) &#123;\n  let res &#x3D; [],\n    count &#x3D; 0,\n    len &#x3D; promises.length;\n\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    for (let p of promises) &#123;\n      Promise.resolve(p).then(\n        (res) &#x3D;&gt; &#123;\n          resolve(res); &#x2F;&#x2F; 只要有一个成功，就走resolve\n        &#125;,\n        (err) &#x3D;&gt; &#123;\n          res[count] &#x3D; err; &#x2F;&#x2F; 遇到错误先不管，继续检查\n          if (++count &#x3D;&#x3D; len) &#123;\n            &#x2F;&#x2F; 直到遇到成功的或检查完\n            reject(res);\n          &#125;\n        &#125;\n      );\n    &#125;\n  &#125;);\n&#125;;\n\nPromise.finally\n无论哪个执行完，回调下\n\nPromise.prototype.myFinally &#x3D; function (cb) &#123;\n  &#x2F;&#x2F;cb就是要共同执行的逻辑\n  return this.then(\n    &#x2F;&#x2F;谁调用finally，this就是谁\n    (value) &#x3D;&gt; Promise.resolve(cb()), &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb\n    (error) &#x3D;&gt; Promise.resolve(cb()) &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb\n  );\n&#125;;\n\nPromise.resolve见 Promise.resolve（）详解\nPromise.prototype.myResolve &#x3D; function (params) &#123;\n  return new Promise((resolve) &#x3D;&gt; resolve(params));\n&#125;;\n\n阻断 resolve&#x2F;reject 后面代码还会执行使用 Promise 过程中 resolve 或 reject 后，后面代码还会执行，默认加 return 较妥\n限制并发数量&#x2F;&#x2F; 原理：将在用数量，限制在最大数量内的异步直接发，\n&#x2F;&#x2F; 限制外的现存到数组中，当在用数量减少时一个一个取出来运行\nexport class LimitPromise &#123;\n  private limit: number;        &#x2F;&#x2F; 最大限制数\n  private runningcount: number;        &#x2F;&#x2F; 目前并发的数量\n  private taskQueue: any[];     &#x2F;&#x2F; 如果并发数等于最大限制，则把新加的异步操作用数组存起来\n\n  constructor(limit: number) &#123;\n    this.limit &#x3D; limit;\n    this.runningcount &#x3D; 0;\n    this.taskQueue &#x3D; [];\n  &#125;\n  &#x2F;&#x2F; 出队列\n  private createTask(\n    asyncFn: Function,\n    args: any[],\n    resolve: (value: unknown) &#x3D;&gt; void,\n    reject: (reason?: any) &#x3D;&gt; void,\n  ) &#123;\n    return () &#x3D;&gt; &#123;\n      asyncFn(...args)\n        .then(resolve)\n        .catch(reject)\n        .finally(() &#x3D;&gt; &#123;\n          this.runningcount--; &#x2F;&#x2F; 任务结束后，对任务队列进行出列，执行\n          if (this.taskQueue.length) &#123;\n            let task &#x3D; this.taskQueue.shift();\n            task();\n          &#125;\n        &#125;);\n\n      this.runningcount++; &#x2F;&#x2F; 在执行的数量\n    &#125;;\n  &#125;\n  &#x2F;&#x2F; 入队列\n  public call(asyncFn: Function, ...args: any[]) &#123;\n    &#x2F;&#x2F; 这层promise令人费解，主要是为了提供resolve和reject给 limitP.call，\n    &#x2F;&#x2F; 这样limitP可以做些其他的事情，理论上没有必要\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      const task &#x3D; this.createTask(asyncFn, args, resolve, reject); &#x2F;&#x2F; 创建任务\n      if (this.runningcount &gt;&#x3D; this.limit) &#123; &#x2F;&#x2F; 大于限制的存起来\n        this.taskQueue.push(task);\n      &#125; else &#123; &#x2F;&#x2F; 否则直接执行\n        task();\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n\nlet limitP &#x3D; new LimitPromise(3)\n\n\n\n&#x2F;&#x2F; 测试\nfunction sleep(sec: number) &#123;\n  console.log(&#39;..............&#39;);\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(&#39;等待了&#39; + sec + &#39;秒&#39;);\n      resolve(&#39;&#39;);\n    &#125;, sec * 1000);\n  &#125;);\n&#125;\n\nlimitP.call(sleep, 1);\nlimitP.call(sleep, 2);\nlimitP.call(sleep, 3);\nlimitP.call(sleep, 4);\nlimitP.call(sleep, 5);\nlimitP.call(sleep, 6);\n&#x2F;&#x2F; https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;typescript-sdhev3?file&#x3D;index.ts\n\nPromiseQueue&#x2F;&#x2F; 入队列\n&#x2F;&#x2F; 出队列\nclass PromiseQueue &#123;\n  constructor(tasks, limit &#x3D; 1) &#123;\n    this.tasks &#x3D; tasks;\n    this.limit &#x3D; limit;\n    this.running &#x3D; [];\n  &#125;\n  next() &#123;\n    return this.running.length &lt; this.limit &amp;&amp; this.tasks.length;\n  &#125;\n\n  run() &#123;\n    while (this.next()) &#123;\n      let promise &#x3D; this.tasks.shift(); &#x2F;&#x2F; 更改tasks数组长度\n\n      promise.then((data) &#x3D;&gt; &#123;\n        this.run();\n      &#125;);\n\n      this.running.push(promise); &#x2F;&#x2F; 更改running数组长度\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 接收一个promise数组，并发限制为3\nconst taskQueue &#x3D; new PromiseQueue(tasks, 3);\ntaskQueue.run();\n\n&#x2F;&#x2F; 清理\n&#x2F;&#x2F; taskQueue &#x3D; undefined\n\nasync await 原理实现见\n仅“2k”字就能理解的 async&#x2F;await 原理，摸个鱼的时间搞定它\n&#x2F;&#x2F; function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，\n&#x2F;&#x2F; 它返回一个 Generator 对象\n&#x2F;&#x2F; generator对象由生成器函数生成\n\n&#x2F;&#x2F;接受一个Generator函数作为参数\nfunction myAsync(gen) &#123;\n  &#x2F;&#x2F; 返回一个函数\n  return function () &#123;\n    &#x2F;&#x2F; 返回一个promise\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 执行Generator函数\n      &#x2F;&#x2F; generator返回什么\n      let g &#x3D; gen();\n\n      const next &#x3D; (context) &#x3D;&gt; &#123;\n        let res;\n        try &#123;\n          res &#x3D; g.next(context);\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n        if (res.done) &#123;\n          &#x2F;&#x2F; 这时候说明已经是完成了，需要返回结果\n          resolve(res.value);\n        &#125; else &#123;\n          &#x2F;&#x2F; 继续执行next函数,传入执行结果\n          return Promise.resolve(res.value).then(\n            (val) &#x3D;&gt; next(val),\n            (err) &#x3D;&gt; next(err)\n          );\n        &#125;\n      &#125;;\n      next();\n    &#125;);\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nconst getFetch &#x3D; (nums) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(nums + 1);\n  &#125;, 1000);\n&#125;);\n\nfunction* gen() &#123;\n  let res1 &#x3D; yield getFetch(1);\n  let res2 &#x3D; yield getFetch(res1);\n  let res3 &#x3D; yield getFetch(res2);\n  return res3;\n&#125;\n\nconst asyncGen &#x3D; myAsync(gen &#x2F;*传入generator *&#x2F;);\n\nasyncGen().then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;); &#x2F;&#x2F; 4\n\n数组数组去重常见前端面试题–数组去重\n方案 1:\nfunction unique(arr) &#123;\n  return Array.from(new Set(arr));\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [&#39;1&#39;, &#39;true&#39;, true, 15, undefined, null, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]\n&#x2F;&#x2F;无法去掉&#39;&#123;&#125;&#39;空对象\n\n方案 2:\nfunction unique(arr) &#123;\n  return arr.filter(function (item, index, arr) &#123;\n    &#x2F;&#x2F; 当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;\n  &#125;);\n&#125;\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]\n&#x2F;&#x2F; &#123;&#125;不能去重\n\n方案 3:\nfunction unique(arr) &#123;\n  return arr.reduce((prev, cur) &#x3D;&gt; (prev.includes(cur) ? prev : [...prev, cur]), []);\n&#125;\n\n&#x2F;&#x2F; prettier-ignore\nlet arr &#x3D; [ 1, 1, &quot;true&quot;, true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, &#123;&#125;, &#123;&#125;,];\n\nconsole.log(unique(arr));\n&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]\n\n将奇数排在前面，偶数排在后面要求时间复杂度 O(n)。空间复杂度 O(1)（不能用 splice）\nvar testAry &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9];\nvar newAry &#x3D; [];\n\ntestAry.forEach((item, i) &#x3D;&gt; &#123;\n  let n &#x3D; Number(item);\n  if (n % 2 &#x3D;&#x3D; 0) &#123;\n    newAry.push(n);\n  &#125; else &#123;\n    newAry.unshift(n);\n  &#125;\n&#125;);\n\nconsole.log(newAry); &#x2F;&#x2F;[&quot;9&quot;,&quot;7&quot;,&quot;5&quot;,&quot;3&quot;,&quot;1&quot;,&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]\n\n数组转树结构const arr &#x3D; [\n    &#123; id: 1, pid: 0 &#125;,\n    &#123; id: 2, pid: 1 &#125;,\n    &#123; id: 3, pid: 1 &#125;,\n    &#123; id: 4, pid: 2 &#125;,\n    &#123; id: 5, pid: 2 &#125;,\n    &#123; id: 6, pid: 3 &#125;,\n];\n&#x2F;&#x2F; 要求编写一个函数 arr2tree(arr)，得到输出结果如下：\n\n&#123;\n    &quot;id&quot;: 0,\n    &quot;children&quot;: [\n        &#123;\n            &quot;id&quot;: 1,\n            &quot;children&quot;: [\n                &#123;\n                    &quot;id&quot;: 2,\n                    &quot;children&quot;: [\n                        &#123;\n                            &quot;id&quot;: 4\n                        &#125;,\n                        &#123;\n                            &quot;id&quot;: 5\n                        &#125;\n                    ]\n                &#125;,\n                &#123;\n                    &quot;id&quot;: 3,\n                    &quot;children&quot;: [\n                        &#123;\n                            &quot;id&quot;: 6\n                        &#125;\n                    ]\n                &#125;\n            ]\n        &#125;\n    ]\n&#125;\n\n实现\nfunction arr2tree(arr) &#123;\n  let hash &#x3D; &#123;&#125;;\n  const result &#x3D; [];\n  &#x2F;&#x2F; 放到对象中\n  for (let item of arr) &#123;\n    hash[item.id] &#x3D; item;\n  &#125;\n\n  for (let item of arr) &#123;\n    const parent &#x3D; hash[item.pid];\n    if (parent) &#123;\n      if (!parent.children) &#123;\n        parent.children &#x3D; [];\n      &#125;\n      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除\n      parent.children.push(item); &#x2F;&#x2F; 之所以能够实现，原因：使用了数组引用\n    &#125; else &#123;\n      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除\n      result.push(item); &#x2F;&#x2F; 只有第一次pid &#x3D; 0的时候，树根节点才走这里\n    &#125;\n  &#125;\n  hash &#x3D; undefined; &#x2F;&#x2F; 这里记得回收\n  return result;\n&#125;\n\nconst res &#x3D; arr2tree(arr);\nconsole.log(&#39;res&#39;, JSON.stringify(res, null, 2));\n\n地址数据处理&#x2F;&#x2F; input &#x3D; [\n&#x2F;&#x2F;   &#123;id:1,city:&#39;北京&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:2,city:&#39;河南&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:3,city:&#39;山西&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:4,city:&#39;洛阳&#39;,pid:2&#125;,\n&#x2F;&#x2F;   &#123;id:5,city:&#39;晋中&#39;,pid:3&#125;,\n&#x2F;&#x2F;   &#123;id:6,city:&#39;榆次&#39;,pid:5&#125;,\n&#x2F;&#x2F; ]\n&#x2F;&#x2F; result &#x3D; [\n&#x2F;&#x2F;   &#123;id:1,city:&#39;北京&#39;,pid:0&#125;,\n&#x2F;&#x2F;   &#123;id:2,city:&#39;河南&#39;,pid:0,\n&#x2F;&#x2F;     children:[&#123;id:4,city:&#39;洛阳&#39;,pid:2&#125;]\n&#x2F;&#x2F;   &#125;,\n&#x2F;&#x2F;   &#123;id:3,city:&#39;山西&#39;,pid:0,\n&#x2F;&#x2F;      children:[\n&#x2F;&#x2F;        &#123;id:5,city:&#39;晋中&#39;,pid:3,\n&#x2F;&#x2F;          children:[&#123;id:6,city:&#39;榆次&#39;,pid:5&#125;]\n&#x2F;&#x2F;       &#125;\n&#x2F;&#x2F;      ]\n&#x2F;&#x2F;   &#125;,\n&#x2F;&#x2F; ]\n&#x2F;&#x2F; 1. 转hash\n&#x2F;&#x2F; 2. 利用引用数据类型的特点，直接在原数据上操作\nfunction toTree(arr) &#123;\n  arr.forEach(function (it) &#123;\n    delete it.children;\n  &#125;);\n  &#x2F;&#x2F; 定义map&#x2F;\n  let map &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 这里可以重构数据类型，放回字段值\n  arr.forEach(function (item) &#123;\n    map[item.id] &#x3D; item;\n  &#125;);\n\n  &#x2F;&#x2F; 定义返回集合\n  let val &#x3D; [];\n  arr.forEach(function (item) &#123;\n    let parent &#x3D; map[item.pid];\n    if (parent) &#123;\n      &#x2F;&#x2F; 有数据说明不是顶级节点，将数据放到该 children 子节点下\n      (parent.children || (parent.children &#x3D; [])).push(item);\n    &#125; else &#123;\n      &#x2F;&#x2F; 没有数据说明是顶级节点放到val中\n      val.push(item);\n    &#125;\n  &#125;);\n  return val;\n&#125;\n\n如何找到数组中出现次数最多的字符串const findCountMax &#x3D; (arr) &#x3D;&gt; &#123;\n  let obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 转hash\n  arr.forEach((item) &#x3D;&gt; &#123;\n    if (obj[item]) &#123;\n      obj[item]++;\n    &#125; else &#123;\n      obj[item] &#x3D; 1;\n    &#125;\n  &#125;);\n  &#x2F;&#x2F; 遍历找最大值\n  let result &#x3D; &#123; count: 0, str: &#39;&#39; &#125;;\n  for (let item in obj) &#123;\n    if (obj[item] &gt; result.count) &#123;\n      result.count &#x3D; obj[item];\n      result.str &#x3D; item;\n    &#125;\n  &#125;\n  return result.str;\n&#125;;\n\n数组扁平化&#x2F;&#x2F; 没有深度控制的，不好\n&#x2F;&#x2F; 1. 对数组进行遍历，元素是数组的，递归遍历\nconst flattenArr &#x3D; (arr) &#x3D;&gt; &#123;\n  let result &#x3D; [];\n  &#x2F;&#x2F; iife ，直接执行，不用下面再写调用了\n  (function helper(arr) &#123;\n    arr.forEach((item) &#x3D;&gt; &#123;\n      if (Array.isArray(item)) &#123;\n        helper(item);\n      &#125; else &#123;\n        result.push(item);\n      &#125;\n    &#125;);\n  &#125;)(arr);\n  return result;\n&#125;;\n\n指定展开 N 层const flattenArrN &#x3D; (arr, depth &#x3D; 1) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 这里可以看作是闭包，将result进行缓存\n  let result &#x3D; [];\n  &#x2F;&#x2F; iife 立即执行，传入多个参数\n  (function helper(arr, depth) &#123;\n    arr.forEach((item) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 限制在某一层级\n      if (Array.isArray(item) &amp;&amp; depth &gt; 0) &#123;\n        &#x2F;&#x2F; 这里每次depth都会递减\n        helper(item, depth - 1);\n      &#125; else &#123;\n        result.push(item);\n      &#125;\n    &#125;);\n  &#125;)(arr, depth);\n\n  return result;\n&#125;;\n\n对象const obj &#x3D; &#123;\n  a: 1,\n  b: [1, 2, &#123; c: true &#125;],\n  c: &#123; e: 2, f: 3 &#125;,\n  g: null,\n&#125;;\n\nconst result &#x3D; &#123;\n  a: 1,\n  &#39;b[0]&#39;: 1,\n  &#39;b[1]&#39;: 2,\n  &#39;b[2].c&#39;: true,\n  &#39;c.e&#39;: 2,\n  &#39;c.f&#39;: 3,\n  g: null,\n&#125;;\n\n&#x2F;&#x2F; 实现\nconst isArray &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;\nconst isObject &#x3D; (val) &#x3D;&gt; toString.call(v) &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;;\nfunction ObjFlat(obj) &#123;\n  let result &#x3D; &#123;&#125;;\n  (function helper(obj, prekey &#x2F;*利用闭包进行传递 *&#x2F;) &#123;\n    if (!obj) return;\n\n    Object.entries(obj)?.forEach(([key, value]) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 重点是合成key\n      const keyStr &#x3D; isArray(obj) ? &#96;$&#123;prekey&#125;[$&#123;key&#125;]&#96; : &#96;$&#123;prekey&#125;$&#123;key&#125;&#96;;\n\n      if (isArray(value)) &#123;\n        helper(value, keyStr);\n      &#125; else if (isObject(value)) &#123;\n        helper(value, &#96;$&#123;keyStr&#125;.&#96;);\n      &#125; else &#123;\n        &#x2F;&#x2F; 直接给keyStr赋值\n        result[keyStr] &#x3D; value;\n      &#125;\n    &#125;);\n  &#125;)(obj, &#39;&#39;);\n  console.log(&#39;result&#39;, result);\n  return result;\n&#125;\nconst obj &#x3D; &#123;\n  a: 1,\n  b: [1, 2, &#123; c: true &#125;],\n  c: &#123; e: 2, f: 3 &#125;,\n  g: null,\n&#125;;\n\nObjFlat(obj);\n\n对象扁平化正则解析 URL 中所有的部分&#x2F;&#x2F; 1.  拆分？后面的内容\n&#x2F;&#x2F; 2.  key\n&#x2F;&#x2F;     1.  无 value 转化成 true\n&#x2F;&#x2F;     2.  纯数字的转化成 数值\n&#x2F;&#x2F;     3.  value 是 数组&#x2F;对象\nfunction parseParam(url) &#123;\n  const paramsStr &#x3D; &#x2F;.+\\?(.+)$&#x2F;.exec(url)[1]; &#x2F;&#x2F; ?之后部分截取\n  const paramsArr &#x3D; paramsStr.split(&#39;&amp;&#39;); &#x2F;&#x2F; 拆分kv对\n  let paramsObj &#x3D; &#123;&#125;;\n\n  paramsArr.forEach((param) &#x3D;&gt; &#123;\n    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;\n      let [key, val] &#x3D; param.split(&#39;&#x3D;&#39;);\n\n      val &#x3D; decodeURIComponent(val); &#x2F;&#x2F; 解码\n\n      val &#x3D; &#x2F;^\\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 字符串数值转化\n\n      if (paramsObj.hasOwnProperty(key)) &#123;\n        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 这个没有直接push, 利用concat特性（数组concat,非数组push）\n      &#125; else &#123;\n        paramsObj[key] &#x3D; val;\n      &#125;\n    &#125; else &#123;\n      &#x2F;&#x2F; 有些没有&#x3D;号\n      paramsObj[param] &#x3D; true;\n    &#125;\n  &#125;);\n  return paramsObj;\n&#125;\n\nes5 实现 es6+新特性 -->\n\n中划线转大写var str &#x3D; &#39;get-user-by-id&#39;;\n\nvar f &#x3D; function (s) &#123;\n  return s.replace(&#x2F;-\\w&#x2F;g, function (x) &#123;\n    return x.slice(1).toUpperCase();\n  &#125;);\n&#125;;\n\n替换字符串可以插入下面的特殊变量名：\n\n\n\n变量名\n代表的值\n\n\n\n$$\n插入一个 “$”。\n\n\n$&amp;\n插入匹配的子串。\n\n\n$&#96;\n插入当前匹配的子串左边的内容。\n\n\n$&#39;\n插入当前匹配的子串右边的内容。\n\n\n$n\n假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。\n\n\n$&lt;Name&gt;\n这里Name 是一个分组名称。\n\n\n\n$n : 提示：索引是从 1 开始。如果不存在第 n 个分组，那么将会把匹配到到内容替换为字面量。比如不存在第 3 个分组，就会用“$3”替换匹配到的内容。\n$&lt;Name&gt;: 如果在正则表达式中并不存在分组（或者没有匹配），这个变量将被处理为空字符串。只有在支持命名分组捕获的浏览器中才能使用。\n\n金额千分function parseToMoney(num) &#123;\n  num &#x3D; parseFloat(num).toFixed(3);\n\n  let [integer, decimal] &#x3D; String.prototype.split.call(num, &#39;.&#39;);\n\n  integer &#x3D; integer.replace(&#x2F;\\d(?&#x3D;(\\d&#123;3&#125;)+$)&#x2F;g, &#39;$&amp;,&#39;);\n  &#x2F;&#x2F; 从右到左“三个数值一组” ?&#x3D; 尽可能多的去匹配\n\n  return &#96;$&#123;integer&#125;.$&#123;decimal&#125;&#96;;\n&#125;\n\nconsole.log(parseToMoney(10000000.0));\n\n&#x2F;&#x2F; $&amp; 与regexp相匹配的子串。 &#x2F;&#x2F; https:&#x2F;&#x2F;q.cnblogs.com&#x2F;q&#x2F;63769&#x2F;\n\n&#x2F;\\d(?&#x3D;(\\d{3})+$)&#x2F;g\nIntl.NumberFormat&#x2F;&#x2F; example1\nconst options &#x3D; &#123;\n  style: &#39;currency&#39;,\n  currency: &#39;CNY&#39;,\n&#125;;\nconsole.log((999999.1212).toLocaleString(&#39;zh-CN&#39;, options)); &#x2F;&#x2F; ¥999,999.12\n\n&#x2F;&#x2F; example2\nvar val &#x3D; Intl.NumberFormat(&#39;zh-CN&#39;, &#123; maximumSignificantDigits: 18 &#125;).format(999999.1212);\n\nconsole.log(&#39;val&#39;, val); &#x2F;&#x2F; val 999,999.1212\n\n原理实现new见\n&#x2F;&#x2F; @link: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;new\n&#x2F;&#x2F; 1. 创建一个空的简单 JavaScript 对象（即 &#123;&#125;）；\n&#x2F;&#x2F; 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；\n&#x2F;&#x2F; 3. 将步骤 1 新创建的对象, 作为 this 的上下文；\n&#x2F;&#x2F; 4. 如果该函数没有返回对象，则返回 this。\nfunction myNew() &#123;\n  &#x2F;&#x2F; 1. 创建一个空的简单 JavaScript 对象（即 &#123;&#125;）；\n  let obj &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 2. 为步骤 1 新创建的对象, 添加属性 __proto__，将该属性链接至构造函数的原型对象；\n  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数\n  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型\n  &#x2F;&#x2F; 3. 将步骤 1 新创建的对象, 作为 this 的上下文；\n  const result &#x3D; func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数\n  &#x2F;&#x2F; 4. 如果该函数没有返回对象，则返回 this。\n  return result intanceof Object ? result :  obj;\n&#125;\n\nObject.createObject.myCreate &#x3D; function (proto, propertyObj &#x3D; undefined) &#123;\n  &#x2F;&#x2F; propertyObj 不可以时null，因为 Object.Create规定第二参数不可以时undefined和 null\n  if (propertyObj &#x3D;&#x3D;&#x3D; null) throw &quot;TypeError&quot;;\n  &#x2F;&#x2F; 23模式-原型模式，使用寄生继承，用现有对象作为新创建对象的原型\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; proto;\n  let obj &#x3D; new F();\n  &#x2F;&#x2F; 对象的自有可枚举属性，将为新创建的对象添加指定的属性值和对应的属性描述符\n  if (propertyObj !&#x3D;&#x3D; undefined) &#123;\n    Object.defineProperties(obj, propertyObj);\n  &#125;\n  &#x2F;&#x2F; null创建无原型的对象\n  if (proto &#x3D;&#x3D;&#x3D; null) &#123;\n    obj.__proto__ &#x3D; null;\n  &#125;\n  &#x2F;&#x2F; 一个新对象，带着指定的原型对象及其属性\n  return obj;\n&#125;;\n\n\n\n&#x2F;&#x2F; 示例\n&#x2F;&#x2F; 第二个参数为null时，抛出TypeError\n&#x2F;&#x2F; const throwErr &#x3D; Object.myCreate(&#123;a: &#39;aa&#39;&#125;, null)  &#x2F;&#x2F; Uncaught TypeError\n&#x2F;&#x2F; 构建一个以\nconst obj1 &#x3D; Object.myCreate(&#123;a: &#39;aa&#39;&#125;)\nconsole.log(obj1)  &#x2F;&#x2F; &#123;&#125;, obj1的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;\nconst obj2 &#x3D; Object.myCreate(&#123;a: &#39;aa&#39;&#125;, &#123;\n  b: &#123;\n    value: &#39;bb&#39;,\n    enumerable: true\n  &#125;\n&#125;)\nconsole.log(obj2)  &#x2F;&#x2F; &#123;b: &#39;bb&#39;&#125;, obj2的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;\n\n作者：李永宁\n链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904174983872519\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\ninstanceofinstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\nfunction instance_of(L, R) &#123;\n  var O &#x3D; R.prototype; &#x2F;&#x2F; 取R的显示原型\n  L &#x3D; L.__proto__; &#x2F;&#x2F; 取L的隐式原型\n\n  while (true) &#123;\n    &#x2F;&#x2F; 死循环，结束条件：要么找到，要么没找到\n    if (L &#x3D;&#x3D;&#x3D; null) return false;\n\n    &#x2F;&#x2F; 这里重点：当O严格等于L时，返回true\n    if (O &#x3D;&#x3D;&#x3D; L) return true;\n\n    L &#x3D; L.__proto__;\n  &#125;\n&#125;\n\nJSONP本质是一个 hack,利用&lt;script&gt;标签不受同源侧露限制的特性进行跨域操作\n参考链接jsonp 函数封装\n&#x2F;&#x2F; 1. 生成个函数名\n&#x2F;&#x2F; 2. 整理参数，生成请求url\n&#x2F;&#x2F; 3. 动态创建script标签，并挂载\n&#x2F;&#x2F; 4. 加载完成后移除script标签\nfunction jsonP(&#123; url, params, success &#125;) &#123;\n  &#x2F;&#x2F; 在参数里制定callback的名字\n  params &#x3D; params || &#123;&#125;;\n  &#x2F;&#x2F; 预留callback\n  const funcName &#x3D; &#39;func&#39; + Math.random().toString().replace(&#39;.&#39;, &#39;&#39;);\n  &#x2F;&#x2F; 这样依赖，服务器端一个req.query.callback就可以获取到动态的函数名\n  params.callback &#x3D; funcName;\n  window[funcName] &#x3D; success;\n\n  &#x2F;&#x2F; 拼接参数字符串\n  const paramKeys &#x3D; Object.keys(params);\n  const paramString &#x3D; paramKeys.map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;).join(&#39;&amp;&#39;);\n\n  &#x2F;&#x2F; 插入dom元素\n  const script &#x3D; document.createElement(&#39;script&#39;);\n\n  script.setAttribute(&#39;src&#39;, &#96;$&#123;url&#125;?$&#123;paramString&#125;&#96;);\n\n  document.body.appendChild(script);\n  &#x2F;&#x2F; 监听script标签的onload事件，当script标签执行后将其删除，避免代码结构的冗余\n  script.onload &#x3D; function () &#123;\n    &#x2F;&#x2F; 从body的删除掉添加的script标签\n    document.body.removeChild(script);\n    delete window[funcName];\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 使用\n\njsonP(&#123;\n  url: &#39;https:&#x2F;&#x2F;example.com&#x2F;ajax&#x2F;jsonp&#x2F;suggestion&#39;,\n  params: &#123;\n    key: &#39;test&#39;,\n  &#125;,\n  success(result) &#123;\n    console.log(result.data);\n  &#125;,\n&#125;);\n\n实现 event bus作用：\n1. 简化了应用程序内各个组件之间进行通信的复杂度，尤其是碎片之间进行通信的问题，可以避免由于使用广播通信而带来的诸多不便\n&#x2F;&#x2F; 1. 监听收集（on&#x2F;once）\n&#x2F;&#x2F; 2. 触发监听(emit)\n&#x2F;&#x2F; 3. 解除监听(off)\n&#x2F;&#x2F; 4. 清空监听(clear)\nclass EventBus &#123;\n  constructor() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n  &#x2F;&#x2F; 监听，给对象添加方法\n  on(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) &#123;\n      events[name] &#x3D; [];\n    &#125;\n    events[name].push(callback);\n  &#125;\n  &#x2F;&#x2F; 取出来执行\n  emit(name, ...args) &#123;\n    const handlers &#x3D; this.events[name];\n    handlers?.forEach((fn) &#x3D;&gt; &#123;\n      fn.apply(this, args);\n    &#125;);\n  &#125;\n  &#x2F;&#x2F; 解除\n  off(name, callback) &#123;\n    const &#123; events &#125; &#x3D; this;\n    if (!events[name]) return;\n    events[name] &#x3D; events[name].filter((fn) &#x3D;&gt; fn !&#x3D;&#x3D; callback); &#x2F;&#x2F; 引用，指向对象，直接改kv键值对\n  &#125;\n  &#x2F;&#x2F;  用完立马、解除\n  once(name, callback) &#123;\n    const handler &#x3D; function () &#123;\n      callback.apply(this, arguments); &#x2F;&#x2F; 普通函数参数\n      this.off(name, handler);\n    &#125;;\n    this.on(name, handler);\n  &#125;\n  &#x2F;&#x2F; 事件清空\n  clear() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n&#125;\n\n实现发布订阅class Observer &#123;\n  caches &#x3D; &#123;&#125;; &#x2F;&#x2F; 事件中心\n\n  &#x2F;&#x2F; eventName事件名-独一无二, fn订阅后执行的自定义行为\n  on(eventName, fn) &#123;\n    this.caches[eventName] &#x3D; this.caches[eventName] || [];\n    this.caches[eventName].push(fn);\n  &#125;\n\n  &#x2F;&#x2F; 发布 &#x3D;&gt; 将订阅的事件进行统一执行\n  emit(eventName, data) &#123;\n    if (this.caches[eventName]) &#123;\n      this.caches[eventName].forEach((fn) &#x3D;&gt; fn(data));\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 取消订阅 &#x3D;&gt; 若fn不传, 直接取消该事件所有订阅信息\n  off(eventName, fn) &#123;\n    if (this.caches[eventName]) &#123;\n      const newCaches &#x3D; fn ? this.caches[eventName].filter((e) &#x3D;&gt; e !&#x3D;&#x3D; fn) : [];\n      this.caches[eventName] &#x3D; newCaches;\n    &#125;\n  &#125;\n&#125;\n\nObject.defineProperties 实现原理Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象见\n&#x2F;#&#x2F;post&#x2F;2023-03-09defineProperty\nfunction defineProperties(obj, properties) &#123;\n  function convertToDescriptor(desc) &#123;\n    &#x2F;&#x2F; 是否有这个属性\n    function hasProperty(obj, prop) &#123;\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    &#125;\n    &#x2F;&#x2F; 是否可以被调用\n    function isCallable(v) &#123;\n      &#x2F;&#x2F; NB: modify as necessary if other values than functions are callable.\n      return typeof v &#x3D;&#x3D;&#x3D; &#39;function&#39;;\n    &#125;\n    &#x2F;&#x2F; 基本数据类型\n    if (typeof desc !&#x3D;&#x3D; &#39;object&#39; || desc &#x3D;&#x3D;&#x3D; null) throw new TypeError(&#39;bad desc&#39;);\n\n    var d &#x3D; &#123;&#125;;\n\n    &#x2F;*数据描述：可枚举、可配置、值、可改写*&#x2F;\n    if (hasProperty(desc, &#39;enumerable&#39;)) d.enumerable &#x3D; !!desc.enumerable;\n    if (hasProperty(desc, &#39;configurable&#39;)) d.configurable &#x3D; !!desc.configurable;\n    if (hasProperty(desc, &#39;value&#39;)) d.value &#x3D; desc.value;\n    if (hasProperty(desc, &#39;writable&#39;)) d.writable &#x3D; !!desc.writable;\n\n    &#x2F;*存储描述 *&#x2F;\n    function storeDesc(desc, key) &#123;\n      var g &#x3D; desc[key];\n      if (!isCallable(g) &amp;&amp; typeof g !&#x3D;&#x3D; &#39;undefined&#39;) throw new TypeError(&#96;bad $&#123;key&#125;&#96;);\n      d[key] &#x3D; g;\n    &#125;\n    &#x2F;&#x2F; 不再进一步封装\n    if (hasProperty(desc, &#39;get&#39;)) storeDesc(desc, &#39;get&#39;);\n    if (hasProperty(desc, &#39;set&#39;)) storeDesc(desc, &#39;set&#39;);\n\n    &#x2F;&#x2F; 描述符冲突\n    &#x2F;&#x2F; @link https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;defineProperty#:~:text&#x3D;%E4%B8%BA%20undefined%E3%80%82-,%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%AF%E6%8B%A5%E6%9C%89%E7%9A%84%E9%94%AE%E5%80%BC,-configurable\n    &#x2F;&#x2F; 1. 如果一个描述符不具有 value、writable、get 和 set 中的任意一个键，那么它将被认为是一个数据描述符。\n    &#x2F;&#x2F; 2. 如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常。\n    if ((&#39;get&#39; in d || &#39;set&#39; in d) &amp;&amp; (&#39;value&#39; in d || &#39;writable&#39; in d)) throw new TypeError(&#39;identity-confused descriptor&#39;);\n\n    return d;\n  &#125;\n  &#x2F;&#x2F; 被扩展的必须是对象\n  &#x2F;&#x2F; 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n  if (typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) throw new TypeError(&#39;bad obj&#39;);\n  &#x2F;&#x2F; 转化成对象, Object是一个构造函数\n  properties &#x3D; Object(properties);\n  &#x2F;&#x2F; 遍历key\n  var keys &#x3D; Object.keys(properties);\n  var descs &#x3D; [];\n\n  for (var i &#x3D; 0; i &lt; keys.length; i++) &#123;\n    Object.defineProperty(obj, keys[i], convertToDescriptor(properties[keys[i]]));\n  &#125;\n\n  &#x2F;&#x2F; 返回原对象\n  return obj;\n&#125;\n\n柯里化柯里化是什么见在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术以逻辑学家 Haskell Curry 命名的。\n\n柯里化突出一种重要思想：降低适用范围，提高适用性\n柯里化的三个作用和特点：参数复用、提前返回、延迟执行\n柯里化是闭包的一个典型应用:\n利用闭包形成了一个保存在内存中的作用域，把接收到的部分参数保存在这个作用域中，等待后续使用。\n并且返回一个新函数接收剩余参数\n\n\n\n函数柯里化和偏函数应用\n\n柯里化和偏函数都是用于将多个参数函数，转化为接受更少参数函数的方法。传入部分参数后，处于中间状态的函数可以作为固定值进行复用。但是其中不同之处在于：\n\n柯里化是将函数转化为多个嵌套的一元函数，也就是每个函数只接受一个参数。\n\n偏函数可以接受不只一个参数，它被固定了部分参数作为预设，并可以接受剩余的参数\n\n\n作者：LanceT链接：https://juejin.cn/post/6844903814139478030来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n实现柯里化function sum(a, b, c, d, e) &#123;\n  return a + b + c + d + e;\n&#125;\n\nlet resFunc &#x3D; curry(sum);\nconsole.log(resFunc(1, 3, 4)(1)(23));\n&#x2F;&#x2F; 方式2，利用bind的数据积累特性\nfunction curry(fn, ...args) &#123;\n  if (args.length &gt;&#x3D; fn.length) &#123;\n    return fn(...args);\n  &#125; else &#123;\n    &#x2F;&#x2F; bind绑定，不执行，\n    &#x2F;&#x2F; bind返回一个函数\n    &#x2F;&#x2F; bind会将之前的参数和之后的参数进行合并\n    &#x2F;&#x2F; 这里涉及bind和apply的实现原理\n    return curry.bind(null, fn, ...args);\n  &#125;\n  &#x2F;&#x2F; return fn.length &#x3D;&#x3D; args.length ? fn(...args) : curry.bind(null, fn, ...args);\n&#125;\n\n洋葱模型redux compose 源码\n&#x2F;&#x2F; 1. 无函数\n&#x2F;&#x2F; 2. 1个函数\n&#x2F;&#x2F; 3. 多个函数\nexport default function compose(...funcs: Function[]) &#123;\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line\n    return &lt;T&gt;(arg: T) &#x3D;&gt; arg;\n  &#125;\n\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0];\n  &#125;\n  &#x2F;&#x2F; prettier-ignore\n  return funcs.reduce((a, b) &#x3D;&gt; (...args: any) &#x3D;&gt; a(b(...args)));\n&#125;\n\n数据代理&#x2F;劫持数据劫持|数据代理\nMDN\nproxyProxy &amp; Reflect \n&#x2F;&#x2F; Proxy\n&#x2F;&#x2F;  数据对象\nlet obj &#x3D; &#123;\n  name: &#39;Eason&#39;,\n  age: 30,\n&#125;;\n&#x2F;&#x2F; 处理\nlet handler &#x3D; &#123;\n  get(target, key, receiver) &#123;\n    console.log(&#39;get&#39;, key);\n    return Reflect.get(target, key, receiver);\n  &#125;,\n  set(target, key, value, receiver) &#123;\n    console.log(&#39;set&#39;, key, value);\n    return Reflect.set(target, key, value, receiver);\n  &#125;,\n&#125;;\n\nlet proxy &#x3D; new Proxy(&#123; ...obj &#125;, handler);\n\nproxy.name &#x3D; &#39;Zoe&#39;; &#x2F;&#x2F; set name Zoe\nproxy.age &#x3D; 18; &#x2F;&#x2F; set age 18\n\n&#x2F;&#x2F; defineProperty\n\nlet arr &#x3D; [1, 2, 3];\nlet obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, &#39;arr&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get arr&#39;);\n    return arr;\n  &#125;,\n  set(newVal) &#123;\n    console.log(&#39;set&#39;, newVal);\n    arr &#x3D; newVal;\n  &#125;,\n&#125;);\nobj.arr.push(4); &#x2F;&#x2F; 只会打印 get arr, 不会打印 set\nobj.arr &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; 这个能正常 set\n\ndefineProperty&#x2F;&#x2F; defineProperty\n\nlet arr &#x3D; [1, 2, 3];\nlet obj &#x3D; &#123;&#125;;\nObject.defineProperty(obj, &#39;arr&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get arr&#39;);\n    return arr;\n  &#125;,\n  set(newVal) &#123;\n    console.log(&#39;set&#39;, newVal);\n    arr &#x3D; newVal;\n  &#125;,\n&#125;);\nobj.arr.push(4); &#x2F;&#x2F; 只会打印 get arr, 不会打印 set\nobj.arr &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; 这个能正常 set\n\n(a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; truea &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3\n什么样的 a 可以满足 (a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true 呢？(注意是 3 个 &#x3D;，也就是严格相等)???\nlet i &#x3D; 1;\nObject.defineProperty(window, &#39;a&#39;, &#123;\n  get: function () &#123;\n    return i++;\n  &#125;,\n&#125;);\n\nconsole.log(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3);\n\n链表什么是链表\n数据的一种存储结构，一个链表包含若干个节点，每个节点至少包含一个数据域和指针域\n百度文库(收费了，只能看部分)、参考链接\n参考链接\n单向 vs 双向单向链表：只有一个指向下一个节点的指针。\n\n优点：单向链表增加删除节点简单。遍历时候不会死循环；\n缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。\n\n适用于节点的增加删除。\n双向链表：有两个指针，一个指向前一个节点，一个后一个节点。\n\n优点：可以找到前驱和后继，可进可退；\n缺点：增加删除节点复杂，需要多分配一个指针存储空间。\n\n适用于需要双向查找节点值的情况\n单向链表和双向链表的优缺点及使用场景\n单链表\n链表的节点为「数据 data、指针 next」的数据接口， 节点通过指针串联起来的数据结构：拥有 节点的增、删、改功能，还可以进行遍历\n链表的最后一个节点的 next&#x3D;null\n\n\n\n\n&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员\n    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员\n  &#125;\n&#125;\n&#x2F;&#x2F; 定义一个单向链表类\nclass singleLinked &#123;\n  constructor() &#123;\n    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数\n    this.head &#x3D; new Node(&#39;head&#39;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址\n    this.currentNode &#x3D; &#39;&#39;;\n  &#125;\n  &#x2F;&#x2F; 获取链表的长度\n  getLength() &#123;\n    return this.size;\n  &#125;\n  &#x2F;&#x2F; 判断链表是否为空\n  isEmpty() &#123;\n    return this.size &#x3D;&#x3D;&#x3D; 0;\n  &#125;\n  &#x2F;&#x2F; 遍历链表：不重复访问链表中的每个节点\n  displayList() &#123;\n    var list &#x3D; &#39;&#39;;\n    var currentNode &#x3D; this.head; &#x2F;&#x2F; 指向链表的头指针\n    while (currentNode) &#123;\n      &#x2F;&#x2F; 如果当前节点不为空，则表明当前节点中存在数据\n      list +&#x3D; currentNode.data;\n      &#x2F;&#x2F; 同时让当前节点的指针指向下一个节点\n      currentNode &#x3D; currentNode.next;\n\n      if (currentNode) &#123;\n        &#x2F;&#x2F; 如果当前节点的下一个节点不为空\n        list +&#x3D; &#39;-&gt;&#39;; &#x2F;&#x2F; 拼接后看起来像一个链表\n      &#125;\n    &#125;\n    console.log(list);\n  &#125;\n\n  &#x2F;&#x2F; 获取链表的最后一个节点\n  findLast() &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    return currentNode;\n  &#125;\n\n  &#x2F;&#x2F; 采用尾插法在链表尾部添加元素，即创建一个链表\n  appendNode(element) &#123;\n    var currentNode &#x3D; this.findLast(); &#x2F;&#x2F; 找到链表的最后一个节点\n    var newNode &#x3D; new Node(element); &#x2F;&#x2F; 创建一个新节点\n    currentNode.next &#x3D; newNode; &#x2F;&#x2F; 把新的节点放在链表里去（放在最后一个的后面）\n    &#x2F;&#x2F; newNode.next &#x3D; null; &#x2F;&#x2F; 因为新节点已经是链表最后一个节点\n    this.size++; &#x2F;&#x2F; 因为新插入一个节点，让链表的长度+1\n  &#125;\n  &#x2F;&#x2F; 删除一个节点\n  deleteNode(element) &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    &#x2F;&#x2F; 将链的节点与另一个节点连上\n    currentNode.next &#x3D; currentNode.next.next;\n    this.size--;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 上述链表代码的测试\n&#x2F;&#x2F; 最好使用循环，往里面加数据\nvar slist &#x3D; new singleLinked();\n\nvar arr &#x3D; [1001, 1234, 1006, 7788, 5512, 6129];\nfor (var i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  slist.appendNode(arr[i]);\n&#125;\nslist.displayList();\nslist.deleteNode(1001);\nslist.displayList();\n\n双向链表《不是环》js 数据结构之双向链表 doublyLinkedList\n\n\n&#x2F;**\n * 双向链表节点\n * 包含三个值: 当前节点的值和分别指向前后节点的指针\n *&#x2F;\nclass Node &#123;\n  constructor(element) &#123;\n    this.element &#x3D; element;\n    this.next &#x3D; null;\n    this.prev &#x3D; null;\n  &#125;\n&#125;\n\n&#x2F;** 双向链表 *&#x2F;\nclass DoublyLinkedList &#123;\n  constructor() &#123;\n    this.head &#x3D; null;\n  &#125;\n\n  &#x2F;** 在链表末尾添加一个元素 *&#x2F;\n  add(element) &#123;\n    &#x2F;&#x2F; 链表是否已有节点\n    const node &#x3D; new Node(element);\n    &#x2F;&#x2F; 没有节点\n    if (this.head &#x3D;&#x3D;&#x3D; null) &#123;\n      this.head &#x3D; node;\n      return;\n    &#125;\n    &#x2F;&#x2F; 有节点\n    let current &#x3D; this.head;\n    while (current.next) &#123;\n      current &#x3D; current.next;\n    &#125;\n    current.next &#x3D; node;\n    node.prev &#x3D; current;\n  &#125;\n\n  &#x2F;** 删除 *&#x2F;\n  remove(element) &#123;\n    &#x2F;&#x2F; 链表无数据\n    if (this.head &#x3D;&#x3D;&#x3D; null) &#123;\n      return false;\n    &#125;\n    let current &#x3D; this.head;\n    &#x2F;&#x2F; 链表有数据\n    if (current.element &#x3D;&#x3D;&#x3D; element) &#123;\n      &#x2F;&#x2F; 有2个\n      if (this.head.next) &#123;\n        this.head &#x3D; this.head.next;\n        this.head.prev &#x3D; null;\n      &#x2F;&#x2F; 只有一个\n      &#125; else &#123;\n        this.head &#x3D; null;\n      &#125;\n      return true;\n    &#125;\n    let prev;\n    while (current !&#x3D;&#x3D; null &amp;&amp; current.element !&#x3D;&#x3D; element) &#123;\n      prev &#x3D; current;\n      current &#x3D; current.next;\n    &#125;\n    if (current) &#123;\n      prev.next &#x3D; current.next || null;\n      &#x2F;&#x2F; 与之前的节点建立pre链接\n      if (current.next) &#123;\n        current.next.prev &#x3D; prev;\n      &#125;\n      return true;\n    &#125;\n    return false;\n  &#125;\n\n  &#x2F;** 反向遍历 *&#x2F;\n  reverse() &#123;\n    let current &#x3D; this.head;\n    let prev &#x3D; null;\n    let tail &#x3D; null;\n    &#x2F;&#x2F; step1: 调序重排\n    while (current !&#x3D;&#x3D; null) &#123;\n      prev &#x3D; current.prev;\n      &#x2F;&#x2F; pre 指向后面，next指向前面\n      current.prev &#x3D; current.next;\n      current.next &#x3D; prev;\n\n      tail &#x3D; current;\n      current &#x3D; current.prev;\n    &#125;\n    this.head &#x3D; tail;\n    &#x2F;&#x2F; step2: 正序遍历\n    current &#x3D; this.head;\n    while (current !&#x3D;&#x3D; null) &#123;\n      yield current.element;\n      current &#x3D; current.next;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 示例\nconst list &#x3D; new DoublyLinkedList();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nlist.add(&quot;5&quot;);\nlist.add(&quot;3&quot;);\n\nlist.remove(&quot;5&quot;);\n\nconst reverseList &#x3D; list.reverse();\n\nconsole.log(reverseList.next());\nconsole.log(reverseList.next());\nconsole.log(reverseList.next());\n\n链表反转function reverseList(head) &#123;\n  &#x2F;&#x2F; 初始化prev&#x2F;cur指针\n  let prev &#x3D; null; &#x2F;&#x2F; pre指针（新链表的头指针）\n  let cur &#x3D; head; &#x2F;&#x2F; cur指针\n  &#x2F;&#x2F; 开始遍历链表\n  while (cur) &#123;\n    let next &#x3D; cur.next; &#x2F;&#x2F; 暂存，之后用于cur指针移动\n    cur.next &#x3D; prev; &#x2F;&#x2F; 建立新的链表关系\n    prev &#x3D; cur; &#x2F;&#x2F; pre 指针移动\n    cur &#x3D; next; &#x2F;&#x2F; cur 指针移动\n  &#125;\n  return prev;\n&#125;\n\n链表有环&#x2F;&#x2F; 1. 终止条件：\n&#x2F;&#x2F;    有环快慢指针相遇\n&#x2F;&#x2F;    无环遍历结束的时候\nfunction hasCycle(head) &#123;\n  let fast &#x3D; head;\n  let slow &#x3D; head;\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n    &#x2F;&#x2F; 有环终止的条件\n    if (fast &#x3D;&#x3D;&#x3D; slow) return true;\n  &#125;\n  return false;\n&#125;\n\n链表中点链表有中点，则链表没有环,快指针式慢指针的两倍速度，快指针到链表尾部时候，慢指针刚好到临近中间位置\n\n链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null, fast &#x3D;&#x3D;&#x3D; null 结束时, 已完成情况：fast:1,3,5,null, slow: 1,2,3\n链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null, fast.next &#x3D;&#x3D;&#x3D; null 结束时,已完成情况： fast: 1,3,5,7, slow: 1,2,3, 这里慢指针并没有到达中间点，还差一步\n\nfunction middleNode(head) &#123;\n  &#x2F;&#x2F; body\n  let fast &#x3D; head;\n  let slow &#x3D; head;\n\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n  &#125;\n  &#x2F;&#x2F; 看是fast结束的还是fast.next结束的\n  &#x2F;&#x2F; 处理链表节点为奇数的情况\n  if (fast) &#123;\n    &#x2F;&#x2F; 也就是fast.next &#x3D;&#x3D;&#x3D; null的情况\n    slow &#x3D; slow.next;\n  &#125;\n  return slow;\n&#125;\n\n链表中环的入口节点\n理解：快慢指针相遇点\n理解：什么是环的入口\n\n\n\n链表中环的入口节点\n&#x2F;&#x2F; 阶段1: 快指针走两步，慢指针走一步，找到相遇点\n&#x2F;&#x2F; 阶段2: 快指针从头一步一步走，慢指针从相遇点一步一步走（为什么成立：因为方程式有解）\nfunction detectCycle(head) &#123;\n  let fast &#x3D; head;\n  let slow &#x3D; head;\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n    &#x2F;&#x2F; prettier-ignore\n    if (fast &#x3D;&#x3D; slow) &#123; &#x2F;&#x2F; 相遇点\n      fast &#x3D; head; &#x2F;&#x2F; 快指针从头走\n      while (fast !&#x3D; slow) &#123;\n        fast &#x3D; fast.next;\n        slow &#x3D; slow.next;\n      &#125;\n      return slow;\n    &#125;\n  &#125;\n  return null;\n&#125;\n\n判断链表是否相交 相交链表（双指针，清晰图解）\n\n\nfunction intersectionNode(headA, headB) &#123;\n  let [curA, curB] &#x3D; [headA, headB];\n  while (curA !&#x3D;&#x3D; curB) &#123;\n    curA &#x3D; curA.next &#x3D;&#x3D;&#x3D; null ? headB : curA.next;\n    curB &#x3D; curB.next &#x3D;&#x3D;&#x3D; null ? headA : curB.next;\n  &#125;\n  return curA;\n&#125;\n\n&#x2F;&#x2F; 测试----------------------------------\n\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data;\n    this.next &#x3D; null;\n  &#125;\n&#125;\n\nclass SingleLink &#123;\n  constructor() &#123;\n    this.size &#x3D; 0;\n    this.head &#x3D; new Node(&#39;head&#39;);\n  &#125;\n  &#x2F;&#x2F; 找到链表的最后一个节点\n  findLastNode() &#123;\n    let curNode &#x3D; this.head;\n    while (curNode.next) &#123;\n      curNode &#x3D; curNode.next;\n    &#125;\n    return curNode;\n  &#125;\n  &#x2F;&#x2F; 追加节点\n  appendNode(node) &#123;\n    const lastNode &#x3D; this.findLastNode();\n    lastNode.next &#x3D; node;\n    node.next &#x3D; null; &#x2F;&#x2F; 这个必须加，否则有循环\n    this.size++;\n  &#125;\n&#125;\n\nvar a &#x3D; [1, 11];\n\nvar b &#x3D; [0, 2, 3];\n\nvar common &#x3D; [&#39;a&#39;, &#39;b&#39;];\n&#x2F;&#x2F; 链表A\nconst linka &#x3D; new SingleLink();\nfor (let i &#x3D; 0; i &lt; a.length; i++) &#123;\n  linka.appendNode(new Node(a[i]));\n&#125;\n\n&#x2F;&#x2F; 链表B\nconst linkb &#x3D; new SingleLink();\nfor (let i &#x3D; 0; i &lt; b.length; i++) &#123;\n  linkb.appendNode(new Node(b[i]));\n&#125;\n\n&#x2F;&#x2F; 共节点链表\nfor (let i &#x3D; 0; i &lt; common.length; i++) &#123;\n  const cNode &#x3D; new Node(common[i]);\n  linka.appendNode(cNode);\n  linkb.appendNode(cNode);\n&#125;\n\nconsole.log(&#39;linka&#39;, linka);\n\nvar cNodeLink &#x3D; intersectionNode(linka.head, linkb.head);\nconsole.log(&#39;cNodeLink&#39;, JSON.stringify(cNodeLink, null, 2));\n\n&#x2F;&#x2F; cNodeLink &#123;\n&#x2F;&#x2F;   &quot;data&quot;: &quot;a&quot;,\n&#x2F;&#x2F;   &quot;next&quot;: &#123;\n&#x2F;&#x2F;     &quot;data&quot;: &quot;b&quot;,\n&#x2F;&#x2F;     &quot;next&quot;: null\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F; &#125;\n\n堆最小堆\n见\nReact 的小顶堆排序法\n\n&#x2F;&#x2F; 最小堆\nlet heap &#x3D; [];\n\nfunction push(heap, node) &#123;\n  const index &#x3D; heap.length; &#x2F;&#x2F; 新的数据放置的位置\n  heap.push(node);\n  siftUp(heap, node, index); &#x2F;&#x2F; 增：自下而上\n&#125;\n\nfunction peek(heap) &#123;\n  return heap.length &#x3D;&#x3D;&#x3D; 0 ? null : heap[0];\n&#125;\n\nfunction pop(heap) &#123;\n  if (heap.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return null;\n  &#125;\n  const first &#x3D; heap[0]; &#x2F;&#x2F; 取堆顶\n  const last &#x3D; heap.pop(); &#x2F;&#x2F; 取最后一个元素\n  if (last !&#x3D;&#x3D; first) &#123;\n    &#x2F;&#x2F; 两者不等\n    heap[0] &#x3D; last; &#x2F;&#x2F; 换位\n    siftDown(heap, last, 0); &#x2F;&#x2F; 删：自上而下，对于尾部置换过来的数据，进行下沉处理\n  &#125;\n  return first;\n&#125;\n&#x2F;&#x2F; 上浮处理\nfunction siftUp(heap, node &#x2F;*数据 *&#x2F;, i &#x2F;*数据位置 *&#x2F;) &#123;\n  let index &#x3D; i;\n  while (index &gt; 0) &#123;\n    const parentIndex &#x3D; (index - 1) &gt;&gt;&gt; 1; &#x2F;&#x2F; (index-1)&#x2F;2后取整  等价于 &gt;&gt;&gt;无符号右移\n    const parent &#x3D; heap[parentIndex];\n    if (compare(parent, node) &gt; 0) &#123;\n      &#x2F;&#x2F; 如果parent大，交换\n      heap[parentIndex] &#x3D; node;\n      heap[index] &#x3D; parent;\n      index &#x3D; parentIndex;\n    &#125; else &#123;\n      &#x2F;&#x2F; 如果parent小，退出循环\n      return;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; 下沉处理\nfunction siftDown(heap, node, i) &#123;\n  let index &#x3D; i;\n  const length &#x3D; heap.length; &#x2F;&#x2F; 堆全长\n  const halfLength &#x3D; length &gt;&gt;&gt; 1; &#x2F;&#x2F; 堆半长\n  while (index &lt; halfLength) &#123;\n    const leftIndex &#x3D; (index + 1) * 2 - 1;\n    const left &#x3D; heap[leftIndex];\n    const rightIndex &#x3D; leftIndex + 1;\n    const right &#x3D; heap[rightIndex];\n\n    &#x2F;&#x2F; 如果左侧或右侧节点较小，请使用其中较小的节点进行交换。\n    &#x2F;&#x2F; left &lt; node\n    if (compare(left, node) &lt; 0) &#123;\n      &#x2F;&#x2F; right &lt; left\n      if (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; 0) &#123;\n        heap[index] &#x3D; right;\n        heap[rightIndex] &#x3D; node;\n        index &#x3D; rightIndex;\n        &#x2F;&#x2F; right &gt; left\n      &#125; else &#123;\n        heap[index] &#x3D; left;\n        heap[leftIndex] &#x3D; node;\n        index &#x3D; leftIndex;\n      &#125;\n      &#x2F;&#x2F; left &gt; node &gt; right\n    &#125; else if (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; 0) &#123;\n      heap[index] &#x3D; right;\n      heap[rightIndex] &#x3D; node;\n      index &#x3D; rightIndex;\n    &#125; else &#123;\n      &#x2F;&#x2F; Neither child is smaller. Exit.\n      return;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; a&gt;b\nfunction compare(a, b) &#123;\n  &#x2F;&#x2F; Compare sort index first, then task id.\n  &#x2F;&#x2F; react源码\n  &#x2F;&#x2F; const diff &#x3D; a.sortIndex - b.sortIndex;\n  &#x2F;&#x2F; return diff !&#x3D;&#x3D; 0 ? diff : a.id - b.id;\n  return a - b;\n&#125;\n&#x2F;&#x2F; 循环插入节点\nvar arr &#x3D; [5, 8, 0, 10, 4, 6, 1];\nfor (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  push(heap, arr[i]);\n&#125;\n\nconsole.log(&#39;heap&#39;, heap);\n&#x2F;&#x2F;      0\n&#x2F;&#x2F;   4    1\n&#x2F;&#x2F; 10 8  6 5\n&#x2F;&#x2F; heap [\n&#x2F;&#x2F;   0, 4, 1, 10, 8, 6, 5\n&#x2F;&#x2F; ]\n&#x2F;&#x2F;\n&#x2F;&#x2F; pop(heap);\nconsole.log(&#39;heap&#39;, heap);\n\n&#x2F;&#x2F;      1\n&#x2F;&#x2F;   4    5\n&#x2F;&#x2F; 10 8  6\n\n&#x2F;&#x2F; heap [ 1, 4, 5, 10, 8, 6 ]\n\nfunction printHeap(heap) &#123;\n  if (!heap.length) &#123;\n    console.log(&#39;Heap is empty&#39;);\n  &#125; else &#123;\n    printHeapRecursively(heap, 0, 0);\n  &#125;\n&#125;\nconsole.log(&#39;---------------------------&#39;);\n&#x2F;&#x2F; 这里有个非常重要的点\n&#x2F;&#x2F; 右子树的根节点下标 &#x3D;  index * 2 + 2\n&#x2F;&#x2F; 当前节点的下标 &#x3D; index\n&#x2F;&#x2F; 左子树的根节点下标 &#x3D;  index * 2 + 1\nfunction printHeapRecursively(heap, index, depth) &#123;\n  if (index &lt; heap.length) &#123;\n    printHeapRecursively(heap, index * 2 + 2, depth + 1); &#x2F;&#x2F; 右子树递归\n    console.log(&#96;$&#123;&#39; &#39;.repeat(depth * 4)&#125;[$&#123;heap[index]&#125;]&#96;); &#x2F;&#x2F; 当前节点打印\n    printHeapRecursively(heap, index * 2 + 1, depth + 1); &#x2F;&#x2F; 左子树递归\n  &#125;\n&#125;\n\n堆打印function printHeap(heap) &#123;\n  if (!heap.length) &#123;\n    console.log(&#39;Heap is empty&#39;);\n  &#125; else &#123;\n    printHeapRecursively(heap, 0, 0);\n  &#125;\n&#125;\nconsole.log(&#39;---------------------------&#39;);\n&#x2F;&#x2F; 这里有个非常重要的点\n&#x2F;&#x2F; 右子树的根节点下标 &#x3D;  index * 2 + 2\n&#x2F;&#x2F; 当前节点的下标 &#x3D; index\n&#x2F;&#x2F; 左子树的根节点下标 &#x3D;  index * 2 + 1\nfunction printHeapRecursively(heap, index, depth) &#123;\n  if (index &lt; heap.length) &#123;\n    printHeapRecursively(heap, index * 2 + 2, depth + 1); &#x2F;&#x2F; 右子树递归\n    console.log(&#96;$&#123;&#39; &#39;.repeat(depth * 4)&#125;[$&#123;heap[index]&#125;]&#96;); &#x2F;&#x2F; 当前节点打印\n    printHeapRecursively(heap, index * 2 + 1, depth + 1); &#x2F;&#x2F; 左子树递归\n  &#125;\n&#125;\n\n排序冒泡排序\n\n总图了解到：冒泡路径越来越短: n n-1 n-2 … 2 1\n&#x2F;&#x2F; 解构方式进行赋值\nconst swap &#x3D; (arr, i, j) &#x3D;&gt; ([arr[i], arr[j]] &#x3D; [arr[j], arr[i]]);\n\n&#x2F;&#x2F; 外层遍历负责次数 i&lt;len-1\n&#x2F;&#x2F; 内层遍历处理数据对比 j&#x3D;0 ,j&lt;len-i-1\nfunction BubbleSort(arr) &#123;\n  let len &#x3D; arr.length;\n  if (len &lt; 2) return arr; &#x2F;&#x2F; 没有排序价值\n  for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n    for (let j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n      &#x2F;&#x2F; 是否需要冒泡，这里的冒泡是冒泡到尾部\n      if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1);\n    &#125;\n  &#125;\n  return arr;\n&#125;\n\n选择排序\n\n总图了解到：冒泡路径越来越短: n n-1 n-2 … 2 1\nconst swap &#x3D; (arr, i, j) &#x3D;&gt; ([arr[i], arr[j]] &#x3D; [arr[j], arr[i]]);\n\n&#x2F;&#x2F; 同向比较\nconst SelectSort &#x3D; (arr) &#x3D;&gt; &#123;\n  let len &#x3D; arr.length;\n  let i &#x2F;*一重遍历 *&#x2F;, j &#x2F;*二重遍历 *&#x2F;, minIndex &#x2F;*最小元素的下标 *&#x2F;;\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    &#x2F;&#x2F; 每次找最小的进行交换，直至结束\n    minIndex &#x3D; i;\n    for (let j &#x3D; i + 1; j &lt; len; j++) &#123;\n      &#x2F;&#x2F;每次找最小的\n      if (arr[j] &lt; arr[minIndex]) minIndex &#x3D; j;\n    &#125;\n    swap(arr, i, minIndex);\n  &#125;\n  return arr;\n&#125;;\n\n插入排序\n\n被遍历元素与前面的元素逐个相比较，前面的元素挪位给它\n&#x2F;&#x2F; sential &#x3D; arr[i] 外层\n&#x2F;&#x2F; 内存循环条件 j&#x3D;i-1\nfunction insertSort(arr) &#123;\n  if (arr.length &lt;&#x3D; 0) return arr;\n  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;\n    let temp &#x3D; arr[i];\n    let j &#x3D; i - 1; &#x2F;&#x2F; 取前一个位置元素\n    &#x2F;&#x2F; prettier-ignore\n    for (; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j--) &#123;   &#x2F;&#x2F; 挪位置\n      arr[j + 1] &#x3D; arr[j];\n    &#125;\n    &#x2F;&#x2F; 将元素放置到这个位置\n    arr[j + 1] &#x3D; temp;\n  &#125;\n\n  return result;\n&#125;\n\n归并排序\n\nconst arr &#x3D; [2, 44, 1, 0, -22, 56, -78];\n&#x2F;&#x2F; 分-合过程，分：递 、合：归\nfunction mergeSort(arr) &#123;\n  if (arr.length &lt;&#x3D; 1) return arr;\n\n  const middle &#x3D; Math.floor(arr.length &#x2F; 2);\n  const left &#x3D; arr.slice(0, middle);\n  const right &#x3D; arr.slice(middle);\n  &#x2F;&#x2F; 递\n  return merge(mergeSort(left), mergeSort(right));\n  &#x2F;&#x2F; 归\n  &#x2F;&#x2F; 辅助函数，用于将两个数组合并为一个有序数组，并返回\n  function merge(left, right) &#123;\n    const result &#x3D; [];\n    while (left.length &amp;&amp; right.length) &#123;\n      &#x2F;&#x2F; 放入较小的元素，并从头部移出\n      result.push(left[0] &lt;&#x3D; right[0] ? left.shift() : right.shift());\n    &#125;\n    result.push(...left, ...right); &#x2F;&#x2F; 放入剩余元素\n    return result;\n  &#125;\n&#125;\n\nconsole.log(mergeSort(arr));\n\n希尔排序\n\n快速排序\n\n\n\n找基点，小于的排左侧，大于的排右侧\n&#x2F;*\n快排是冒泡的一种改进，基于分治思想\n*&#x2F;\nconst arr2 &#x3D; [2, 44, 1, 0, -22, 56, -78];\n\nfunction quickSort(arr) &#123;\n  if (arr.length &lt;&#x3D; 1) return arr;\n\n  const pivot &#x3D; arr.pop(); &#x2F;&#x2F; 使用最后一个元素当作基准数\n  &#x2F;&#x2F; prettier-ignore\n  const left &#x3D; [], right &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; pivot) left.push(arr[i]); &#x2F;&#x2F; 小于基准数则放到left\n    else right.push(arr[i]); &#x2F;&#x2F; 大于基准数则放到right\n  &#125;\n  &#x2F;&#x2F; 合并left的快排结果，基准数和右侧的快排结果\n  return quickSort(left).concat(pivot, quickSort(right));\n&#125;\n\nconsole.log(quickSort(arr2));\n\nLRU 算法LRU 定义： 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择内存中最近最久未使用的页面予以淘汰。\n使用场景：正如定义所说，如果我们想要实现缓存机制 – 满足最近最少使用淘汰原则，我们就可以使用 LRU 算法缓存机制。如：vue 中 keep-alive 中就用到了此算法。\n实现思路： – 维护一个数组，提供 get 和 put 两个方法，并且限制数组元素数量（及缓存数量）\n实现方法：\n1. get 可以标记某个元素是最新使用的，提升到第一项\n2. put 可以加入一个 key-value 元素，但是需要判断是否已存在，是否超出限额\n\n&#x2F;&#x2F; 时间复杂度 O(1)，因为 Map 既能保持键值对，还能记住插入顺序。\nvar LRUCache &#x3D; function (capacity) &#123;\n  this.cache &#x3D; new Map();\n  this.capacity &#x3D; capacity;\n&#125;;\n\nLRUCache.prototype.get &#x3D; function (key) &#123;\n  if (this.cache.has(key)) &#123;\n    &#x2F;&#x2F; 存在即更新\n    let temp &#x3D; this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, temp);\n    return temp;\n  &#125;\n  return -1;\n&#125;;\n\nLRUCache.prototype.put &#x3D; function (key, value) &#123;\n  &#x2F;&#x2F; 存在即更新（删除后加入）,这种情况肯定不会溢出\n  if (this.cache.has(key)) &#123;\n    this.cache.delete(key);\n    &#x2F;&#x2F; 不存在即加入\n    &#x2F;&#x2F; 缓存超过最大值，则移除最近没有使用的\n  &#125; else if (this.cache.size &gt;&#x3D; this.capacity) &#123;\n    &#x2F;&#x2F; new Map().keys() 返回一个新的 Iterator 对象\n    this.cache.delete(this.cache.keys().next().value);\n  &#125;\n  this.cache.set(key, value);\n&#125;;\n\n&#x2F;&#x2F; var map &#x3D; new Map()\n&#x2F;&#x2F; map.set(1,1)\n&#x2F;&#x2F; Map(1) &#123;1 &#x3D;&gt; 1&#125;\n&#x2F;&#x2F; map.set(2,2)\n&#x2F;&#x2F; Map(2) &#123;1 &#x3D;&gt; 1, 2 &#x3D;&gt; 2&#125;\n&#x2F;&#x2F; map.set(3,3)\n&#x2F;&#x2F; Map(3) &#123;1 &#x3D;&gt; 1, 2 &#x3D;&gt; 2, 3 &#x3D;&gt; 3&#125;\n\n&#x2F;&#x2F; map.keys().next()\n&#x2F;&#x2F; &#123;value: 1, done: false&#125;\n\n&#x2F;&#x2F; 类实现\n\nclass LRU &#123;\n  constructor(capacity) &#123;\n    this.capacity &#x3D; capacity;\n    this.cache &#x3D; new Map();\n  &#125;\n  &#x2F;&#x2F; 获取\n  get(key) &#123;\n    if (this.cache.has(key)) &#123;\n      &#x2F;&#x2F; 删除后新增\n      const temp &#x3D; this.cache.get(key);\n      this.cache.delete(key);\n      this.cache.set(key, temp);\n      return temp;\n    &#125;\n    return -1;\n  &#125;\n  &#x2F;&#x2F; 设置\n  put(key, value) &#123;\n    if (this.cache.has(key)) &#123;\n      this.cache.delete(key);\n    &#125;else (this.cache.size&gt;&#x3D;this.capacity)&#123;\n      this.cache.delete(this.cache.keys().next().value)\n    &#125;\n\n    this.cache.set(key, value);\n  &#125;\n&#125;\n\nleecode红包算法括号匹配&#x2F;&#x2F; 左匹配进栈\n&#x2F;&#x2F; 右匹配出栈\n&#x2F;&#x2F; 进栈&#x3D;&#x3D;出栈数量\nfunction isValid(s) &#123;\n  let stack &#x3D; new Stack();\n  &#x2F;&#x2F; 遍历 字符串\n  for (let c of s) &#123;\n    &#x2F;&#x2F; 遇到左括号，将与其匹配的右括号入栈处理\n\n    if (c &#x3D;&#x3D;&#x3D; &#39;(&#39;) &#123;\n      stack.push(&#39;)&#39;);\n    &#125; else if (c &#x3D;&#x3D;&#x3D; &#39;[&#39;) &#123;\n      stack.push(&#39;]&#39;);\n    &#125; else if (c &#x3D;&#x3D;&#x3D; &#39;&#123;&#39;) &#123;\n      stack.push(&#39;&#125;&#39;);\n      &#x2F;&#x2F; 遇到右括号\n      &#x2F;&#x2F; 1. 判断栈内是否有括号，如果没有，那说明此时匹配不了\n      &#x2F;&#x2F; 2. 满足①的情况下，判断此时字符是否和栈顶元素匹配\n    &#125; else if (stack.isEmpty() || stack.pop() !&#x3D;&#x3D; c) &#123;\n      return false;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最后再验证一下，栈是否为空，如果不为空，说明还有未匹配的括号\n  return stack.isEmpty();\n&#125;\n&#x2F;&#x2F; 原理：数组的 push 和 pop\nclass Stack &#123;\n  constructor() &#123;\n    this.items &#x3D; [];\n  &#125;\n  &#x2F;&#x2F; 进栈\n  push(element) &#123;\n    this.items.push(element);\n  &#125;\n  &#x2F;&#x2F; 出栈\n  pop() &#123;\n    return this.items.pop();\n  &#125;\n  &#x2F;&#x2F; 是否为空\n  isEmpty() &#123;\n    return this.items.length &#x3D;&#x3D;&#x3D; 0;\n  &#125;\n&#125;\n\n螺旋矩阵大数相加JS 大数相加\nfunction add(str1, str2) &#123;\n  str1 &#x3D; str1.split(&#39;&#39;); &#x2F;&#x2F; 转化成数组\n  str2 &#x3D; str2.split(&#39;&#39;); &#x2F;&#x2F; 转化成数组\n\n  let result &#x3D; &#39;&#39;; &#x2F;&#x2F; 结果\n  let flag &#x3D; 0; &#x2F;&#x2F; 满10进1标记\n\n  while (str1.length || str2.length || flag) &#123;\n    &#x2F;&#x2F; 计算完\n    const val &#x3D; flag + ~~str1.pop() + ~~str2.pop(); &#x2F;&#x2F; ~~undefined &#x3D; 0, true + 0 &#x3D;1, false + 0 &#x3D; 0\n    &#x2F;&#x2F; 结果\n    result &#x3D; (val % 10) + result;\n    &#x2F;&#x2F; 是否进位\n    flag &#x3D; val &gt; 9 ? val % 10 : 0;\n  &#125;\n  return result.replace(&#x2F;^0+&#x2F;, &#39;&#39;); &#x2F;&#x2F; 首部有0去除\n&#125;\n\nconsole.log(add(&#39;00125&#39;, &#39;0131231231232132136&#39;));\n\n找出出现次数最多的英语单词var paragraph &#x3D; &#39;Bob hit a ball, the hit BALL flew far after it was hit.&#39;;\n\nfunction findMaxWord(paragraph) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  var p &#x3D; paragraph.replace(&#x2F;[\\W\\s]&#x2F;g, &quot; &quot;).toLowerCase().split(&quot; &quot;);\n  &#x2F;&#x2F; console.log(&quot;p&quot;, p);\n  &#x2F;&#x2F; [&#39;bob&#39;, &#39;hit&#39;, &#39;a&#39;, &#39;ball&#39;, &#39;&#39;, &#39;the&#39;, &#39;hit&#39;, &#39;ball&#39;, &#39;flew&#39;, &#39;far&#39;, &#39;after&#39;, &#39;it&#39;, &#39;was&#39;, &#39;hit&#39;, &#39;&#39;]\n  const obj &#x3D; &#123;&#125;;\n\n  for (const word of p) &#123;\n    if (!word) continue;\n    if (obj[word]) &#123;\n      obj[word]++;\n    &#125; else &#123;\n      obj[word] &#x3D; 1;\n    &#125;\n  &#125;\n\n  let max &#x3D; 0;\n  let word &#x3D; &#39;&#39;;\n  for (const k in obj) &#123;\n    if (obj[k] &gt; max) &#123;\n      max &#x3D; obj[k];\n      word &#x3D; k;\n    &#125;\n  &#125;\n\n  return &#123;\n    count: max,\n    word,\n  &#125;;\n&#125;\n\nconst res &#x3D; findMaxWord(paragraph);\nconsole.log(res);\n\n节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）【待处理】实现一个函数计算 “1+12-31+100-93”【待处理】function calc(str) &#123;\n  return eval(str);\n&#125;\n\nfunction calcStr(str) &#123;\n  var newStr &#x3D; a.replace(&#x2F;-\\d+&#x2F;g, (x) &#x3D;&gt; &#123;\n    return &#39;+&#39; + x;\n  &#125;);\n  let result &#x3D; newStr.split(&#39;+&#39;).reduce((pre, crt) &#x3D;&gt; pre + parseFloat(crt), 0);\n  console.log(&#39;eval(a)&#39;, eval(str));\n  console.log(&#39;result&#39;, result);\n  return result;\n&#125;\nvar a &#x3D; &#39;1+12-31+100-93&#39;;\n&#x2F;&#x2F; var a &#x3D; &quot;1+12+(-31)+100+(-93)&quot;;\n\ncalcStr(a);\n\n判断链表是否有环\n快慢指针\n为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？\n\n\nclass Solution &#123;\n  ...\n  hasCycle() &#123;\n    let fast &#x3D; this.head; &#x2F;&#x2F; 每次走两步\n    let slow &#x3D; this.head; &#x2F;&#x2F; 每次走一步\n    while (fast &amp;&amp; fast.next) &#123;\n      fast &#x3D; fast.next.next\n      &#x2F;&#x2F; 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\n      &#x2F;&#x2F;               fast\n      &#x2F;&#x2F;               slow\n      slow &#x3D; slow.next\n      &#x2F;&#x2F; 如果最终两人相遇了，则有环\n      if(fast &#x3D;&#x3D;&#x3D; slow)&#123;\n        return true\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 如果结束了，说明无环\n    return false\n  &#125;\n&#125;\n\n爬楼梯【动态规划】百度百科-动态规划\n多阶段决策问题\n\n如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题\n各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果\n\n动态规划问题中的术语\n阶段：\n1. 把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．\n2. 描述阶段的变量称为阶段变量。\n3. 在多数情况下，阶段变量是离散的，用 k 表示。此外，也有阶段变量是连续的情形。\n4. 如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的\n\n状态：\n1. 状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。\n2. 在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点\n\n决策：\n1. 一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。\n2. 在最优控制中，也称为控制。\n3. 在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。\n4. 描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史\n\n最优化原理：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”最优性原理：实际上是要求问题的最优策略的子策略也是最优\n&#x2F;&#x2F; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。\n\n&#x2F;&#x2F; 在循环的过程中，不断替换其中的值， 最后的结果，就是所有的方法数\nfunction minCost(cost) &#123;\n  &#x2F;&#x2F; 定义一个变量\n  let len &#x3D; cost.length;\n  &#x2F;&#x2F; 定义两个变量\n  let dp &#x3D; [cost[0], cost[1]];\n\n  for (let i &#x3D; 2; i &lt; len; i++) &#123;\n    &#x2F;&#x2F; 0&#x2F;1 下标数组， 偶数 &amp; 1 &#x3D; 0， 奇数 &amp; 1 &#x3D;1\n    dp[i &amp; 1] &#x3D; Math.min(dp[0], dp[1]) + cost[i];\n    console.log(&#96;dp[$&#123;i &amp; 1&#125;]&#96;, i, dp[i &amp; 1], dp);\n  &#125;\n\n  &#x2F;&#x2F; 循环结束后\n  return Math.min(dp[0], dp[1]);\n&#125;\n\nvar a &#x3D; minCost([1, 2, 3, 4, 5]);\n\nconsole.log(&#39;a&#39;, a);\n\n&#x2F;&#x2F; 作者：前端小魔女\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7206912311562174523\n&#x2F;&#x2F; 来源：稀土掘金\n&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n什么是时间复杂度&amp;计算什么是空间复杂度&amp;计算删除单向链表中的某个节点&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类\nclass Node &#123;\n  constructor(data) &#123;\n    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员\n    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员\n  &#125;\n&#125;\n&#x2F;&#x2F; 定义一个单向链表类\nclass singleLinked &#123;\n  constructor() &#123;\n    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数\n    this.head &#x3D; new Node(&#39;head&#39;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址\n    this.currentNode &#x3D; &#39;&#39;;\n  &#125;\n  &#x2F;&#x2F; 删除一个节点\n  deleteNode(element) &#123;\n    var currentNode &#x3D; this.head;\n    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;\n      currentNode &#x3D; currentNode.next;\n    &#125;\n    &#x2F;&#x2F; 将链的节点与另一个节点连上\n    currentNode.next &#x3D; currentNode.next.next;\n    this.size--;\n  &#125;\n&#125;\n\n数组中找数之和排序数组中的两个数字之和的下标&#x2F;&#x2F; 输入一个递增排序的数组和一个值target,在数组中找出两个和为target的数字并返回它们的下标\n&#x2F;&#x2F; 提示：\n&#x2F;&#x2F; 数组中有且只有一对符合要求\n&#x2F;&#x2F; 同时一个数字不能使用两次\n\n&#x2F;&#x2F; 示例：输入数组： [1,2,4,6,10],k的值为8 输出[1,3]\n\nfunction twoSum4SortedArray(nums, target) &#123;\n  &#x2F;&#x2F; prettier-ignore\n  let left &#x3D; 0, right &#x3D; nums.length - 1; &#x2F;&#x2F; 初始化指针left,right\n  while (left &lt; right &amp;&amp; nums[left] + nums[right] !&#x3D; target) &#123;\n    if (nums[left] + nums[right] &lt; target) &#123;\n      left++;\n    &#125; else &#123;\n      right--;\n    &#125;\n  &#125;\n  return [left, right];\n&#125;\n\n非排序数组找两数之和function twoSum(nums, target) &#123;\n  let map &#x3D; new Map(); &#x2F;&#x2F; 用于，存储[nums[i],i]之间的关系\n  for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;\n    let expectValue &#x3D; target - nums[i];\n    &#x2F;&#x2F; 先从map中找，是否存在指定值\n    if (map.has(expectValue)) &#123;\n      &#x2F;&#x2F; 如果有，直接返回与值相对于的下标\n      return [map.get(expectValue), i];\n    &#125;\n    &#x2F;&#x2F; 存储[nums[i],i]之间的关系\n    &#x2F;&#x2F; 存 值&#x3D;下标\n    map.set(nums[i], i);\n  &#125;\n  return null;\n&#125;\n\n数组中和为 target 的 3 个数字【难搞哦】&#x2F;&#x2F; 输入一个数组，找出数组中所有和为target的3个数字的三元组\n&#x2F;&#x2F; 提示：\n&#x2F;&#x2F; 返回值不得包含重复的三元组\n\n&#x2F;&#x2F; 示例：输入数组： [-1,0,1,2,-1,-4],target的值为0 输出[[-1,0,1],[-1,-1,2]]\n\nfunction threeSum(nums, target) &#123;\n  let result &#x3D; [];\n  if (nums.length &lt; 3) return [];\n\n  &#x2F;&#x2F; 人工对数据进行排序处理\n  nums.sort((a, b) &#x3D;&gt; a - b);\n\n  let i &#x3D; 0;\n  while (i &lt; nums.length - 2) &#123;\n    twoSum(nums, i, target, result);\n    let temp &#x3D; nums[i];\n    &#x2F;&#x2F; 剔除，重复元祖中第一个数值\n    while (i &lt; nums.length &amp;&amp; nums[i] &#x3D;&#x3D; temp) i++;\n  &#125;\n  return result;\n&#125;\n\nfunction twoSum(nums, i, target, result) &#123;\n  &#x2F;&#x2F; 初始化指针left,right\n  &#x2F;&#x2F; prettier-ignore\n  let left &#x3D; i + 1, right &#x3D; nums.length - 1;\n\n  while (left &lt; right) &#123;\n    &#x2F;&#x2F; 求和\n    let sum &#x3D; nums[i] + nums[left] + nums[right];\n    &#x2F;&#x2F; 指针移动过程 (if&#x2F;else)\n    if (sum &#x3D;&#x3D;&#x3D; target) &#123;\n      result.push([nums[i], num[left], nums[right]]);\n\n      let temp &#x3D; nums[left];\n      &#x2F;&#x2F; 剔除，重复元祖第二个数值\n      while (nums[left] &#x3D;&#x3D;&#x3D; temp &amp;&amp; left &lt; right) left++;\n    &#125; else if (sum &lt; 0) &#123;\n      left++;\n    &#125; else &#123;\n      right--;\n    &#125;\n  &#125;\n&#125;\n\nN 进制加法&#x2F;&#x2F; 二进制加法\n&#x2F;&#x2F; Nsum(&#39;10&#39;,&#39;01&#39;,2)\n&#x2F;&#x2F; 结果为 11\n&#x2F;&#x2F; 十进制加法(十进制大数相加)\n&#x2F;&#x2F; Nsum(&#39;7&#39;,&#39;8&#39;,10)\n&#x2F;&#x2F; 结果为 15\n\n&#x2F;&#x2F; 原理：\n&#x2F;&#x2F; 1. 从数据尾部开始遍历\n&#x2F;&#x2F; 2. 通过字符串减法，获取对应位置的值\n&#x2F;&#x2F; 3. 对应位置数相加，+ 进位\n&#x2F;&#x2F; 4. 当前位置的值，进位的值\n&#x2F;&#x2F; 循环遍历\n&#x2F;&#x2F; 5. 遍历完成后是否还存在进位\nfunction Nsum(a, b, n) &#123;\n  let result &#x3D; &#39;&#39;; &#x2F;&#x2F; 用来存储结果\n  let i &#x3D; a.length - 1; &#x2F;&#x2F; 是为了倒着遍历\n  let j &#x3D; b.length - 1; &#x2F;&#x2F; 是为了倒着遍历\n  let carry &#x3D; 0; &#x2F;&#x2F; 进位\n\n  while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) &#123;\n    &#x2F;*这个减法有意思，会直接计算出来字符串与字符串的差值后的整数 *&#x2F;\n    let digitA &#x3D; i &gt;&#x3D; 0 ? a[i--] - &#39;0&#39; : 0;\n    let digitB &#x3D; j &gt;&#x3D; 0 ? b[j--] - &#39;0&#39; : 0;\n    let sum &#x3D; digitA + digitB + carry; &#x2F;&#x2F; 对应位数之和 + 进位\n    carry &#x3D; sum &gt;&#x3D; n ? 1 : 0; &#x2F;&#x2F; 是否有进位\n    sum &#x3D; sum &gt;&#x3D; n ? sum - n : sum; &#x2F;&#x2F; 去掉进位后该位置的值\n    result &#x3D; sum + result;\n  &#125;\n  &#x2F;&#x2F; 最后是否有进位\n  if (carry) &#123;\n    result &#x3D; &#39;1&#39; + result;\n  &#125;\n  return result;\n&#125;\n\nNsum(&#39;10&#39;, &#39;01&#39;, 2);\n\n只出现一次的数字某个元素仅出现 一次 外，其余每个元素都恰出现 N 次(看不懂)&#x2F;&#x2F; 出现2次，找出现一次的 singleNumber([1,1,2,2,3],2); 结果为 3\n&#x2F;&#x2F; 出现3次，找出现一次的 singleNumber([1,1,1,2,2,2,3],3) 结果为 3\n&#x2F;&#x2F; 同理其他\nfunction singleNumber(nums, n) &#123;\n  &#x2F;&#x2F; 构建一个用于存储数组所有数字位数之和的数组\n  let bitSums &#x3D; new Array(32).fill(0);\n  for (let num of nums) &#123;\n    for (let i &#x3D; 0; i &lt; 32; i++) &#123;\n      &#x2F;&#x2F; 求num在i位置的位数，并将其与指定位置的位数相加\n      bitSums[i] +&#x3D; (num &gt;&gt; (31 - i)) &amp; 1;\n    &#125;\n  &#125;\n  let result &#x3D; 0;\n  for (let i &#x3D; 0; i &lt; 32; i++) &#123;\n    &#x2F;&#x2F;从最地位(0)位开始遍历\n    result &#x3D; (result &lt;&lt; 1) + (bitSums[i] % n);\n  &#125;\n  return result;\n&#125;\n\n某个元素仅出现 一次 外，其余每个元素都恰出现 2 次的另外解法function singleNumber(nums) &#123;\n  let result &#x3D; 0;\n  for (let i of nums) &#123;\n    result ^&#x3D; i;\n    console.log(i, result);\n  &#125;\n  return result;\n&#125;\n\nsingleNumber([1, 3, 1, 2, 2], 2);\n\n&#x2F;&#x2F; 过程如下：\n&#x2F;&#x2F; 1 001\n&#x2F;&#x2F; 1 001\n&#x2F;&#x2F; 2 011\n&#x2F;&#x2F; 2 011\n&#x2F;&#x2F; 3 111 -&gt; 111\n\nfibonic斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……\n常规方式function fibonacci(n) &#123;\n  if (n &lt;&#x3D; 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n&#125;\n&#x2F;&#x2F; fibonacci(1000) &#x2F;&#x2F;  浏览器卡死\n\n尾调用方式原理： 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了\n&#x2F;&#x2F; 执行顺序\n&#x2F;&#x2F; 将 _next的结果作为fibonacci的值\nfunction fibonacci(n, pre &#x3D; 1, next &#x3D; 1) &#123;\n  if (n &lt;&#x3D; 1) return next;\n  const _pre &#x3D; next; &#x2F;&#x2F; 移动位置\n  const _next &#x3D; next + pre;\n  return fibonacci(n - 1, _pre, _next &#x2F;*值放到这里 *&#x2F;);\n  &#x2F;&#x2F; 上面三行等价于下面一行\n  &#x2F;&#x2F; return fibonacci(n - 1, next, next + pre);\n&#125;\n\nfibonacci(4);\n&#x2F;&#x2F; 执行过程分析\n&#x2F;&#x2F; 4 fibonacci(3, 1, 2)\n&#x2F;&#x2F; 3 fibonacci(2, 2, 3)\n&#x2F;&#x2F; 2 fibonacci(1, 3, 5)\n&#x2F;&#x2F; 1 return 5\n\n迭代方式阶乘普通递归function factorial(n) &#123;\n  if (n &#x3D;&#x3D;&#x3D; 1) return 1;\n  return n * factorial(n - 1);\n&#125;\n\nfactorial(5); &#x2F;&#x2F; 120\n\n尾调用递归&#x2F;&#x2F; 尾调用是倒着处理的\nfunction factorial(n, total) &#123;\n  if (n &#x3D;&#x3D;&#x3D; 1) return total;\n  return factorial(n - 1, n * total &#x2F;*值放到这里，算法在这里 *&#x2F;); &#x2F;&#x2F; 尾部返回函数\n&#125;\n\nfactorial(5, 1); &#x2F;&#x2F; 120\n\n五分钟学习算法链接\n其他算法待爬取\ndiffTwoDepsconst diffTwoDeps &#x3D; (deps1?: DependencyList, deps2?: DependencyList) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;Let&#39;s do a reference equality check on 2 dependency list.\n  &#x2F;&#x2F;If deps1 is defined, we iterate over deps1 and do comparison on each element with equivalent element from deps2\n  &#x2F;&#x2F;As this func is used only in this hook, we assume 2 deps always have same length.\n  return deps1\n    ? deps1.map((_ele, idx) &#x3D;&gt; (!Object.is(deps1[idx], deps2?.[idx]) ? idx : -1)).filter((ele) &#x3D;&gt; ele &gt;&#x3D; 0)\n    : &#x2F;&#x2F; prettier-ignore\n    deps2 ? deps2.map((_ele, idx) &#x3D;&gt; idx) : [];\n&#125;;\n\nObject.isif (!Object.is) &#123;\n  Object.defineProperty(Object, &#39;is&#39;, &#123;\n    value: function (x, y) &#123;\n      &#x2F;&#x2F; SameValue algorithm\n      if (x &#x3D;&#x3D;&#x3D; y) &#123;\n        &#x2F;&#x2F; return true if x and y are not 0, OR\n        &#x2F;&#x2F; if x and y are both 0 of the same sign.\n        &#x2F;&#x2F; This checks for cases 1 and 2 above.\n        &#x2F;&#x2F; 相等的情况，需要处理正负零\n        return x !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;\n      &#125; else &#123;\n        &#x2F;&#x2F; return true if both x AND y evaluate to NaN.\n        &#x2F;&#x2F; The only possibility for a variable to not be strictly equal to itself\n        &#x2F;&#x2F; is when that variable evaluates to NaN (example: Number.NaN, 0&#x2F;0, NaN).\n        &#x2F;&#x2F; This checks for case 3.\n        &#x2F;&#x2F; 不相等，排除NaN\n        return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;\n      &#125;\n    &#125;,\n  &#125;);\n&#125;\n\n&#x2F;&#x2F;\n\n三点是否共线&#x2F;&#x2F; 三点是否共线可以通过判断斜率来判断：\n&#x2F;&#x2F; 设有 p1,p2,q三点，判断三点是否共线:\n&#x2F;&#x2F; 公式：\n\n&#x2F;&#x2F; k1 &#x3D; (p2.y - p1.y)&#x2F;(p2.x - p1.x)\n\n&#x2F;&#x2F; k2 &#x3D; (q.y - p1.y)&#x2F;(q.x - p1.x)\n\n&#x2F;&#x2F; 如果k1 &#x3D;&#x3D;&#x3D; k2就表示三点共线\n\nfunction isOnLine(p1, p2, q) &#123;\n  return (p2.y - p1.y) &#x2F; (p2.x - p1.x) &#x3D;&#x3D;&#x3D; (q.y - p1.y) &#x2F; (q.x - p1.x);\n  &#x2F;&#x2F; 如果，指定q是否在线段内部，还需要判断q的范围大小\n&#125;\n\n参考链接\nJavaScript 手写几种常见的排序算法：冒泡、选择、插入、希尔、归并、快排\n排序动画\n分治思想——精选推荐\n归并排序法 百度百科\n（含动画演示）搞懂归并排序 一学就会\n五分钟学算法(PPT 做的 gif)\nPromise.resolve（）详解\n22023 面试真题之手写&amp;代码运行篇\n&#x2F;#&#x2F;post&#x2F;2023-03-062023js\n&#x2F;#&#x2F;post&#x2F;2023-03-07 按位操作\n&#x2F;#&#x2F;post&#x2F;2023-03-09defineProperty\n\n","slug":"2022-07-04js","date":"2022-07-04T07:31:24.000Z","categories_index":"前端基础","tags_index":"前端基础","author_index":"举手摘月亮"},{"id":"22d71efeaa5b73e832334cf42551f026","title":"授权与校验场景「简聊」","content":"最简单用变量，模拟数据\nsession + cookie每个用户对应一个会话\nSSO 1\nsession + redis + cookie\n\n觉得有点奇葩，第二份核心项目遇到\njwt + redis第二份非核心项目遇到\n以下是一般公司常用的方式，面试的时候，大家都在唠这个\nSSO 2\njwt + redis + cookie\n\n第三方\n授权 + SSO（ jwt + redis + cookie）\n扫码授权 + SSO（ jwt + redis + cookie）\n\n第三方使用最多的微信、支付宝、QQ、飞书，第三方授权一般通过回调的形式，把授权结果code返回个开发者\n企业合规\napp 扫码+企业 web + SSO(jwt + redis + cookie)\n\n大公司需要做合规，尤其是上市公司要这些东东，所有用户数据全部来自公司内部系统，面试的时候，大家基本上不会谈这个，如果你给面试官唠了，肯定觉得你在胡说八道，因为下面的很灵活,场景和微信类似，你说扫码，面试官肯定认为你说的是上面第三方那套东西，然而完全不一样\n在扫码登录和确认登陆时候这个点分了多种（长链接、Websocket、MQTT、厂家通道推送，都可以实现）\n以我第三份工作为例：\n\nFlutter桌面端VPN + 移动端用了 MQTT\nElectron桌面端 + 移动端, Electron 桌面端用定时器调,移动端MQTT\n扫码打开链接，直接注入 cookie，而不是通过回调或者redirect重定向\n\n之所以没用厂家通道，因为公司原生部门的厂家通道需要改造才能用，由于改造成本的存在，不提供。总之麻烦～，换了个 MQTT 方案\nmobile 原生(「RN、Flutter、IOS、安卓、Weex、uniapp、ionic」)分的细点,我遇到过的都列出来了，简单来说就是 IOS 和安卓，至于鸿蒙啥的就不说了\n总结：这个吧，就相当于，公司开发了自己的微信桌面window/mac + 微信手机\nwebview cookie 注入react-native-webview向 h5 应用注入 cookie，走 SSO 验证实现免登， 原生当然也OK的\n","slug":"2022-07-01auth","date":"2022-07-01T09:12:26.000Z","categories_index":"auth","tags_index":"auth","author_index":"举手摘月亮"},{"id":"e5dbf22be09b32f376c35e2a002b6557","title":"react hook 使用 bug","content":"问题Rendered more hooks than during the previous render.\n\n\n解决\n\n两种方式解决：\n\n勾子前置\n不用这个勾子\n\n总结勾子不能在条件语句中使用 这个要注意并不是一定这种形式\nif (条件) &#123;\n  &#x2F;&#x2F; 如果条件用于是true，相当于没有外层的if，\n  勾子;\n&#125;\n\n\n这个勾子放在了 if 的后面 条件语句如果在第一次命中的是提前结束，下次渲染没命中 if，走了后面的代码就会出这个问题\n如果测试不全面，这个 bug 就可能到线上了， 因为你测试的有可能每次命中 if 而不会到 else，下面这种模式一不注意就错了\n\nif () &#123;\n  return 渲染\n&#125;\n勾子\n\n原因react 收集勾子的时候，需要保证勾子数量是一致的，不多不少，刚刚好\n\n\n\n\n\n\n\n\n\nHook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。React官方提供了一个 eslint-plugin-react-hooks 插件来强制执行这些规则：\n续。。。源码找这个日志\n参考链接Hook 规则\n","slug":"2022-07-01bug","date":"2022-07-01T03:16:39.000Z","categories_index":"bug","tags_index":"React,bug","author_index":"举手摘月亮"},{"id":"da1169afdf41f1a24b458b57385fca2d","title":"react-native-webview中处理外网链接","content":"背景之前公司移动端是使用 vpn 连接到内网，由于某些原因，IOS 企业证书即将到期，应用需要上架，vpn 不满足上架要求，所以：\n\nvpn 要从 iOS 包中移除\nvpn 移除导致不能直接访问内网\n需要通过外网域名访问内网资源\n\n不同环境的请求\n\n原生及 RN 代码，接口访问走 ATOP 接口访问\n内网应用嵌入到 react-native-webview 中，使用 cookie 注入的方式进行授权，\n\n已有的域名：\n\n之前已经做了企业微信工作台功能，考虑到申请外网域名需要走安全、合规审核比较麻烦\n我们的企业微信授权是根据请求头区分的，同时应用中也有是否是微信环境的判断, 所以：只要在项目中避开微信授权，走 SSO 授权（cookie 注入）\n\n\n\n顺便说句：这里的判断是采用(nextjs)服务端渲染，所以能直接在请求头中判断，如果不是服务端渲染，可能要考虑其他 rn 注入的方式\n改造RN 改造\n\n\nh5 项目改造\n -->\n\n\nconst lang &#x3D; cookie.parse(req.headers.cookie || &#39;&#39;).gTyPlatLang || &#39;en&#39;\nconst ua &#x3D; parser(req.headers[&#39;user-agent&#39;])\nCommonModel.actions.setDevice(ua.device.type, req)\n\nif (!getWechatUserAgent(req.headers[&#39;user-agent&#39;]) &amp;&amp; req.headers[&#39;x-public&#39;]) &#123;\n  const isMobile &#x3D; ua.device.type &#x3D;&#x3D;&#x3D; &#39;mobile&#39;\n  if(!(isMobile &amp;&amp; !!req.headers.tyxz))&#123;  &#x2F;&#x2F; 移动端不是企业微信的\n    redirect(Config.tyHost + join(&#39;&#x2F;&#39;, req.url), ctx) &#x2F;&#x2F; 移动端是rnxz的重定向到内网\n  &#125;\n&#125;\n\n\n\n\n\n本篇文章针对的是非企业微信授权的情况，即：图第一行从左到右（有cookie信息的情况）\n总结下按照原有的设计缺陷：\n\n域名是给企业微信用的，是在nginx那边配置的请求头，这本身不够灵活\n代码中逻辑：1.先获取用户信息，获取不到，2.检测状态码（fetch工具对于后台返回的401状态码，如果是401，默认是走微信授权，后台业务校验授权信息不通过的），3.对于不满足上述条件的，检测客户端是否是企业微信，4.如果不是重定向到内网（还是过于依赖域名配置）\n\n重新设计：\n\n正常业务逻辑，应该先判断是环境，决定走哪套授权验证（这样不会因为一套授权，一个域名了）\n\nvconsole对于 react-native-webview 调试，使用了 vconsole调试，可以简单查看一些控制台信息，包括 cookie 相关的查看、复制、编辑操作\n\n\n\n\n","slug":"2022-06-29rn-web","date":"2022-06-29T09:11:44.000Z","categories_index":"react-native","tags_index":"react-native","author_index":"举手摘月亮"},{"id":"240950b163de231df264068b4d1b9085","title":"企业微信授权流程","content":"准备工作\n确保本地已经正确配置了 HOST，能够从工作台入口打开本地的开发服务\n确保已获取到当前企业的唯一 ID：corp_id，在【管理后台】- 【我的企业】-【企业信息】页面，最下面找到【企业 ID】\n已经通过接口调用获取到当前应用的 access_token，请参考 二：如何获取应用接口凭证\n\n配置可信域名企业微信提供了 OAuth 的授权登录方式，可以让从企业微信终端打开的网页获取成员的身份信息，从而免去登录的环节。\n为了保证访问授权的安全性，需要配置授权链接 URL 所在域名为可信域名。在【应用详情】-【开发者接口】-【网页授权及 JS-SDK】，点击【设置可信域名】\n\n\n在【设置可信域名】弹窗，填写网页授权功能的回调域名\n\n\n网页授权回调域名的配置须与实际访问链接的域名完全一致，详细要求请参考文档 关于网页授权的可信域名。\n构造网页授权链接在我们当前的教程中，我们有几个 URL 需要注意和区分：\n\n应用主页 URL从工作台点击打开的页面 URL ，在创建应用是配置填写的，用来向授权链接 URL 跳转。\n重定向 URL当用户授权成功后，会带着成员授权 code 跳转的 URL，用来接收 code 并获取成员身份。\n授权链接 URL企业微信域名下的 URL，包含了 suite_id、重定向 URL 等信息，当企业微信服务参数验证成功后，会跳转到重定向 URL。\n\n我们在上节课程中配置企业的主页 URL 为 http://myapp.com:300/home，我们在这个 URL 访问逻辑里面根据约定构造授权链接 URL，并向这个链接跳转：\n关于 OAuth 的详细内容，请参考 网页授权登录。关于授权链接更多的内容，请参考 构造网页授权链接。\n解析成员授权 code企业成员从工作台点击应用，打开应用主页 URL，向授权链接 URL 跳转；企业微信对授权链接上的信息进行校验之后，会重定向 URL 跳转，并以 query 的形式带上当前访问成员的 code 信息。\n在上一步，我们定义了重定向 URL 为  http://myapp.com/app，在这个 URL 的访问里我们解析出 code 参数。\n&#x2F;&#x2F; 重定向 URL\nrouter.get(&quot;&#x2F;app&quot;, async function (req, res, next) &#123;\n  &#x2F;&#x2F; 从 query 参数中解析 code\n  let &#123; code &#125; &#x3D; req.query;\n  &#x2F;&#x2F; 展示登录后的页面\n  res.render(&quot;home&quot;);\n&#125;);\n\n获取访问用户身份信息在解析出成员授权 code 之后，使用 access_token ，调用 获取访问用户身份 接口，即可得到访问用户的基本信息 user_id，如果想要访问用户更详细的信息，则需要通过 读取成员 得到用户的姓名、头像等完整信息。\nrouter.get(&quot;&#x2F;app&quot;, async function (req, res, next) &#123;\n  let &#123; code &#125; &#x3D; req.query;\n  &#x2F;&#x2F; 从缓存中读取出 access_token\n  let access_token &#x3D; Tool.GetAccessToken();\n  if (access_token) &#123;\n    &#x2F;&#x2F; 获取用户基本信息\n    let &#123; data: user_data &#125; &#x3D; await axios.get(\n      &#96;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;getuserinfo?access_token&#x3D;$&#123;access_token&#125;&amp;code&#x3D;$&#123;code&#125;&#96;\n    );\n    console.log(&quot;获取 user_data 成功&quot;, user_data);\n    &#x2F;&#x2F; 获得用户的 user_id\n    let user_id &#x3D; user_data.UserId;\n    &#x2F;&#x2F; 获取用户的详细信息\n    let &#123; data: user_detail_data &#125; &#x3D; await axios.get(\n      &#96;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;get?access_token&#x3D;$&#123;access_token&#125;&amp;userid&#x3D;$&#123;user_id&#125;&#96;\n    );\n    console.log(&quot;获取成员详细信息成功&quot;, user_detail_data);\n    &#x2F;&#x2F; 将用户信息展示在页面上\n    res.render(&quot;home&quot;, user_detail_data);\n  &#125; else &#123;\n    res.render(&quot;error&quot;);\n  &#125;\n&#125;);\n\n在前端页面中展示用户的基本信息：\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Hello World&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello World!&lt;&#x2F;h1&gt;\n    &lt;div&gt;\n      &lt;img src&#x3D;&quot;&lt;%&#x3D;avatar %&gt;&quot; &#x2F;&gt;&lt;span&gt;&lt;%&#x3D;name %&gt;(&lt;%&#x3D;english_name %&gt;) &lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n效果展示\n\n关于获取用户的详细信息内容以及接口返回的完整字段信息，请参考 读取成员。如果想要成员在系统浏览器中打开应用时也能进行企业微信授权登录，请参考 构造扫码登录 。\n授权流程企业微信官网有授权流程，看上去没那么直接，结合项目画个草图\n\n\n本篇文章针对的是企业微信授权的情况，即：图第一行走到没授权，往下走（没有 cookie 信息的情况）\n更好的方案方案 1: 对于企业微信授权和 SSO 授权，本质上并无区别，最终的目的是注入 cookie,对于我当前所在公司的情况（企业微信授权，单独维护到 redies 中，独立于 SSO,是没有必要的）。\n方案 2: 如果把企业微信授权的返回用于换取 SSO 的（token）注入 cookie 实现授权，最终每次校验都是 SSO,会节省不少成本。\n我在上家做钉钉 ISV 第三方供应商开发时候，实现效果类似方案 2\n更优方案 3: 在方案 2 的基础，将请求头标记去掉（让后端自行处理）。请求到后端，后端能拿到请求头userAgent字段，可以知道到此请求是从哪个应用过来的，后端自己判断下就好了（完全没必要域名加配置，尤其是那种nginx配置后，代码又乱写的）\n微信环境判断前端代码\n&#x2F;**\n * （服务端+客户端）渲染：根据req headers中user-agent判断是否来自微信端（桌面端和手机端）\n *&#x2F;\nexport default function getWechatUserAgent(userAgent?: string): boolean &#123;\n  const agent &#x3D;\n    userAgent || (typeof navigator &#x3D;&#x3D;&#x3D; &quot;undefined&quot; ? &quot;&quot; : navigator.userAgent);\n  const user_agent &#x3D; agent ? agent.toLowerCase() : &quot;&quot;;\n  return !!(\n    user_agent &amp;&amp;\n    (user_agent.includes(&quot;wechat&quot;) ||\n      user_agent.includes(&quot;wxwork&quot;) ||\n      user_agent.includes(&quot;windowswechat&quot;))\n  );\n&#125;\n\n环境判断也放后端\n公司设计的加请求头标记是不是企业微信，完全没必要 服务端接到请求可以拿到user-agent\n注意\n\n\n\n\n\n\nWARNING\n&lt;a&gt;标签下载\n因为后端是通过前端给的额外标识判断环境的，有个很致命的问题 通过 &lt;a&gt;标签下载的没办法加请求头，需要将&lt;a&gt;标签方式的下载改为 http 请求下载\n\n\n参考链接如何获取登录用户信息\n构造网页授权链接\n","slug":"2022-06-29wx-auth","date":"2022-06-29T08:27:52.000Z","categories_index":"企业微信","tags_index":"企业微信","author_index":"举手摘月亮"},{"id":"e1c1013f78e2c9e4246458e52acbd895","title":"hexo-theme-aurora源码修改","content":"背景hexo-theme-aurora是一款不错的主题，在使用过程无疑会遇到一些问题。遇到问题首先去 github 上找 issue 来处理，有些问题需要改源码，之前使用patch进行简单的修改，这次遇到了 tag 查不到，本地是有的，发布后找不到了，导致文章在tag情况下不可见，之前作者在详情页留了categories，但是没有入口。等了几周，作者没有 fix,动手改～\n\n\n源码node-sass安装要注意了，可能会报错\n查询 node-sass 对应的 node.js 版本。见\n源码已经 fork\n源码使用：vue3 + pinia + cli，理想组合是：vue3 + pinia + vite\n\n\n\n\n\n\nTIP\nhexo-theme-aurora运行起来会开启 http://localhost:9666/端口，会与你的 hexo 打通 9966端口 访问的是你的hexo博客项目4000端口，主题资源是hexo-theme-aurora,厉害～\n\n主要改 categories 相关功能\n\n\n\n\n\ncategoriesCommit:        b1e1d23ed1bf320b1151db3a7708f3ea6078d5ba\nAuthor:        昊天 &lt;haotian.chen@ty.com&gt;\nAuthorDate:    Fri Jun 24 11:51:04 2022\nCommit:        昊天 &lt;haotian.chen@ty.com&gt;\nCommitDate:    Fri Jun 24 11:51:04 2022\n\nfix categories\n\n-----------------------------\n\n _config.yml                                |   1 +\n 新增部分\n src&#x2F;components&#x2F;Category&#x2F;CategoryItem.vue   | 110 +++++++++++++++++++++++++++++\n src&#x2F;components&#x2F;Category&#x2F;CategoryList.vue   |  13 ++++\n src&#x2F;components&#x2F;Category&#x2F;index.ts           |   2 +\n 修改为可点击\n src&#x2F;components&#x2F;Sidebar&#x2F;src&#x2F;CategoryBox.vue |  47 ++++--------\n categories空多语言提示\n src&#x2F;locales&#x2F;languages&#x2F;cn.json              |   1 +\n src&#x2F;locales&#x2F;languages&#x2F;en.json              |   1 +\n 配置导航\n src&#x2F;models&#x2F;ThemeConfig.class.ts            |   8 +++\n 增加新的category查询结果\n src&#x2F;router&#x2F;index.ts                        |   7 ++\n fix 分类展示数据\n src&#x2F;views&#x2F;Category.vue                     |  75 ++++++++++++++------\n 3中情况，展示不同维度的数据内容\n src&#x2F;views&#x2F;Result.vue                       |  10 +++\n 11 files changed, 220 insertions(+), 55 deletions(-)\n\n\n\n\n具体修改内容见\n\n\nAuthor 信息不展示\n\n\n见 fix author 接口\n\n\n代码配色见 opt 配色\n样式错乱\n\n.article .article-content p &#123;\n  font-size: 1rem;\n  line-height: 1.5rem;\n  margin-bottom: 0.5rem;\n  padding-bottom: 1.5rem;\n  word-break: break-all; &#x2F;&#x2F; 这里\n&#125;\n\n见 fix p style\na 标签标记标签的 target &#x3D; ‘_blank’ 属性的元素\n\n\n见 含 a target&#x3D;_blank 属性的增加标记\npatch不了解patch，更多\n\n修改后的hexo-theme-aurora项目打包，\n博客中之前补丁移除，之后重新生成新的补丁\n\npackage.json\n-    &quot;patch:hexo-theme-aurora&quot;: &quot;yarn patch-package hexo-theme-aurora&quot;,\n-    &quot;postinstall&quot;: &quot;yarn patch-package&quot;\n\n\n删除 technology-blog/patches/hexo-theme-aurora+1.5.5.patch 补丁\n\n拷贝hexo-theme-aurora打包后的代码\n\n\nsource&#x2F;static 目录\nsource&#x2F;layout 目录（hash改变，这个也要换新的）\n\n\n\n生成补丁, 执行yarn patch-package hexo-theme-aurora\n\npackage.json\n\n\n+    &quot;patch:hexo-theme-aurora&quot;: &quot;yarn patch-package hexo-theme-aurora&quot;,\n+    &quot;postinstall&quot;: &quot;yarn patch-package&quot;\n\n部分路由刷新后 404\n\n\n\n404 坑你没话说，本地一切正常，部署后 404 找不到\n网上解决方案是：配置 git config ignorecase = true,部分文件没问题，但是部分还是有问题的\n这个问题有点恶心～\n\n\n# 全局配置区分大小写\ngit config core.ignorecase false\n\n\n\n\ngit push origin --delete gh-pages\n\ngit branch -D gh-pages\n\n\n删除分支，再打包发布会报错，按照提示，删除 node_modules，重新安装，然后打包部署，之后，github 会创建新的分支\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git branch -d gh-pages\nerror: The branch &#39;gh-pages&#39; is not fully merged.\nIf you are sure you want to delete it, run &#39;git branch -D gh-pages&#39;.\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git branch -D gh-pages\nDeleted branch gh-pages (was 7a873693).\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ pn release\n\n&gt; hexo-site@0.0.0 release &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io\n&gt; git push &amp;&amp; hexo clean &amp;&amp; hexo deploy\n\nEverything up-to-date\nERROR Cannot find module &#39;hexo&#39; from &#39;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#39;\nERROR Local hexo loading failed in ~&#x2F;Desktop&#x2F;841660202.github.io\nERROR Try running: &#39;rm -rf node_modules &amp;&amp; npm install --force&#39;\n ELIFECYCLE  Command failed with exit code 2.\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ hexo clean\nERROR Cannot find module &#39;hexo&#39; from &#39;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#39;\nERROR Local hexo loading failed in ~&#x2F;Desktop&#x2F;841660202.github.io\nERROR Try running: &#39;rm -rf node_modules &amp;&amp; npm install --force&#39;\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ rm -rf node_modules\n♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ pn i\nLockfile is up to date, resolution step is skipped\nPackages: +437\n\n# 。。。。\n\nWriting objects: 100% (2320&#x2F;2320), 2.98 MiB | 1.26 MiB&#x2F;s, done.\nTotal 2320 (delta 1870), reused 0 (delta 0)\nremote: Resolving deltas: 100% (1870&#x2F;1870), done.\nremote:\nremote: Create a pull request for &#39;gh-pages&#39; on GitHub by visiting:\nremote:      https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io&#x2F;pull&#x2F;new&#x2F;gh-pages\nremote:\nTo https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io\n * [new branch]      HEAD -&gt; gh-pages\nBranch &#39;master&#39; set up to track remote branch &#39;gh-pages&#39; from &#39;https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io&#39;.\nINFO  Deploy done: git\nINFO Thanks for using Aurora v1.5.5\nINFO Check out the repo at: https:&#x2F;&#x2F;github.com&#x2F;auroral-ui&#x2F;hexo-theme-aurora\n\n\n\n\n\nshell 拷贝打包产物$ cp -rf .&#x2F;hexo-theme-aurora&#x2F;layout .&#x2F;841660202.github.io&#x2F;node_modules&#x2F;hexo-theme-aurora&#x2F;\n\n$ cp -rf .&#x2F;hexo-theme-aurora&#x2F;source .&#x2F;841660202.github.io&#x2F;node_modules&#x2F;hexo-theme-aurora&#x2F;\n\n\n可以断定是 github 的 bug\n\nol , ul 列表顶部对齐\n\nvertical-align: top;\n\n\n\naxios 超时时间由 5000 改为 10000\n超时情况，请求会被取消\n","slug":"2022-06-24aurora","date":"2022-06-24T03:43:51.000Z","categories_index":"工具","tags_index":"hexo","author_index":"举手摘月亮"},{"id":"e9a180d03e63743825beabe89becedc8","title":"点","content":"\n\n\n记得之前在哪看到过是js解析时候的问题\n&#x2F;&#x2F; 比如 \n1.toString() &#x2F;&#x2F; 会被解析认为这个.是数字1的点，即：1. 这个含小数的数\n\nNumber(1).toString() &#x2F;&#x2F; ok\n1 .toString() &#x2F;&#x2F; ok\n\n\n&#x2F;&#x2F; 那么 \n\n&#123;&#125;.__proto__ &#x2F;&#x2F; 先执行 &#123;&#125;. 就会报错，而且报错一样 如下图\n\n(&#123;&#125;).__proto__ &#x2F;&#x2F; ok\n","slug":"2022-06-23点","date":"2022-06-23T09:53:22.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"举手摘月亮"},{"id":"5878c07e39be3e6af6ed1f1edce82a5a","title":"axios 1.0.0-alpha.1 源码","content":"官网官网首页官方文档介绍中文文档\nPromise based HTTP client for the browser and node.js基于 promise 可以用于浏览器和 node.js 的网络请求库\nAxios is a promise-based HTTP Client for node.js and the browser. It is isomorphic (&#x3D; it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js http module, while on the client (browser) it uses XMLHttpRequests.Axios 是一个基于 promise 网络请求库，作用于 node.js 和浏览器中。 它是 isomorphic「同构」 的(即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。\n特性\n从浏览器创建 XMLHttpRequests (从 node.js 创建 http 请求)\n支持 Promise API\n拦截请求和响应\n转换请求和响应数据\n取消请求\n自动转换 JSON 数据\n客户端支持防御 XSRF\n\n使用及 Axios APIget example 使用post example 使用API\n\n\n\n\n\n\nTIP\n请求方式别名为了方便起见，已经为所有支持的请求方法提供了别名。\n\naxios.request(config)\naxios.get(url[, config])\naxios.delete(url[, config])\naxios.head(url[, config]) ?\naxios.options(url[, config]) 预检\naxios.post(url[, data[, config]])\naxios.put(url[, data[, config]])\naxios.patch(url[, data[, config]])? patch 方法用来更新局部资源\n\n注意在使用别名方法时， url、method、data 这些属性都不必在配置中指定。\nrestful 只是标准，标准的意思是如果在大家都依此行事的话，沟通成本会很低，开发效率就高。但并非强制(也没人强制得了)，所以你说在你的程序里把方法名从 put 改成 patch 没有任何影响，那是自然，因为你的后端程序并没有按照标准对两个方法做不同处理，她的表现自然是一样的\n即约定，但并不是所有的人都这么干，具体项目如何实现，还需要前后端一致（打个比方：有的后端用 post 做删除，用 post 做查询，用 post 做更新，再举个例子三脚插头有大有小不知道你晓不晓得？只要对应的插孔是对应的大小也就可以运行，要不然连不上）\n\n\n…\naxios.options(url[, config])\naxios 中为什么会有 OPTIONS 请求\n\n\n\n\n\n\n\n\n\n浏览器限制跨域浏览器限制跨域请求一般有两种方式：1、限制发起跨域请求2、跨域请求可以正常发起，但是返回的结果会被浏览器拦截\n\n\n\n\n\n\n\n\n\n一般情况下，浏览器会以第二种方式限制跨域请求。这种存在一种情况，_请求已经到达服务器并响应了某些操作，改变了数据库数据，但是返回的结果会被浏览器拦截，用户就不能取到相应的结果进行后续的操作_。所以为了避免这种情况，浏览器就会通过 OPTIONS 方法对请求进行预检，通过询问服务器是否允许这次请求，允许之后，服务器才会响应真实请求，否则就阻止真实请求。\n\n\n\n\n\n\n\n\n\n项目中需要 OPTIONS 预检吗？用户登陆之后，我们会获取 token 值，在每一次发起请求时，请求头都会携带这个 token 值，所以会触发预检请求。因为目前除了登录，其他请求接口请求头都携带了 token，而且我们的 Content-Type 绝大多数是 application&#x2F;json，所以预检总会存在。如果不想发起 OPTIONS 预检请求，建议后端在请求的返回头部添加：Access-Control-Max-Age:(number)。\nAccess-Control-Max-Age 是什么\n\n\n\n\n\n\n\n\n\n浏览器的同源策略，就是出于安全考虑，浏览器会限制从脚本发起的跨域 HTTP 请求（比如异步请求 GET, POST, PUT, DELETE, OPTIONS 等等），所以浏览器会向所请求的服务器发起两次请求，第一次是浏览器使用 OPTIONS 方法发起一个预检请求，第二次才是真正的异步请求，第一次的预检请求获知服务器是否允许该跨域请求：如果允许，才发起第二次真实的请求；如果不允许，则拦截第二次请求。\nAccess-Control-Max-Age 用来指定本次预检请求的有效期，单位为秒，在此期间不用发出另一条预检请求。\n例如：\nresp.addHeader(“Access-Control-Max-Age”, “0”)，表示每次异步请求都发起预检请求，也就是说，发送两次请求。\nresp.addHeader(“Access-Control-Max-Age”, “1800”)，表示隔 30 分钟才发起预检请求。也就是说，发送两次请求\n注意点\n配置的优先级配置将会按优先级进行合并。它的顺序是：在 lib/defaults.js 中找到的库默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后面的优先级要高于前面的。下面有一个例子。\n&#x2F;&#x2F; 使用库提供的默认配置创建实例\n&#x2F;&#x2F; 此时超时配置的默认值是 &#96;0&#96;\nconst instance &#x3D; axios.create();\n&#x2F;&#x2F; 重写库的超时默认值\n&#x2F;&#x2F; 现在，所有使用此实例的请求都将等待 2.5 秒，然后才会超时\ninstance.defaults.timeout &#x3D; 2500;\n\n&#x2F;&#x2F; 重写此请求的超时时间，因为该请求需要很长时间\ninstance.get(&quot;&#x2F;longRequest&quot;, &#123;\n  timeout: 5000,\n&#125;);\n\n版本发布没有遵守语义化版本\n\n\n在 redux 章节曾聊过包的版本, 必须有, 要符合semantic versioning guidelines, 参考 语义化版本控制规范, 建议仔细通读\n\n\n假设已经通过官方文档对 axios 的使用和 api 已经有了初步的了解\n源码\n了解特性的实现过程\n了解 api 的实现过程\n看看代码靠不靠谱，有没有“彩蛋”(蛙去～，我早上突然冒的想法，竟然在下午真的遇到了，直觉～)\n\n.\n├── CHANGELOG.md\n├── CODE_OF_CONDUCT.md\n├── COLLABORATOR_GUIDE.md\n├── CONTRIBUTING.md\n├── ECOSYSTEM.md\n├── LICENSE\n├── README.md\n├── SECURITY.md\n├── UPGRADE_GUIDE.md\n├── bin\n├── bower.json # 用于bower install\n├── dist\n├── examples\n├── gulpfile.js # gulp任务\n├── index.d.ts\n├── index.js\n├── karma.conf.cjs\n├── lib\n├── package-lock.json\n├── package.json # &quot;build&quot;: &quot;gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m&quot;,\n├── rollup.config.js # rollup 打包配置\n├── sandbox # 一个前后端测试demo\n├── test\n├── tsconfig.json\n├── tslint.json\n└── webpack.config.js # webpack配置，没有使用的样子\n\n6 directories, 20 files\n\n\ngulpfile.jsgulpfile 现在项目很少见，上次见是在 2017 年的时候了，一开始，我看到有 根目录bower.json gulpfile.js rollup.config.js webpack.config.js,有点懵逼～\n\n\nbower.json了解下，有这么个东西，以后估计也用不到\nbower 介绍见github 仓库\nBower 是一个客户端的软件包管理器，它可用于搜索、安装和卸载如 JavaScript、HTML、CSS之类的网络资源，Bower 是 Web 开发中的一个前端文件包管理器，类似于 Node 模块的npm 包管理器，bower 依赖于 Git、Node 和 npm。\npackage.json看完上述几个文件有点懵，工具像是重复的样子\n&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;npm run test:eslint &amp;&amp; npm run test:mocha &amp;&amp; npm run test:karma &amp;&amp; npm run test:dtslint&quot;,\n  &quot;test:eslint&quot;: &quot;node bin&#x2F;ssl_hotfix.js eslint lib&#x2F;**&#x2F;*.js&quot;,\n  &quot;test:dtslint&quot;: &quot;node bin&#x2F;ssl_hotfix.js dtslint&quot;,\n  &quot;test:mocha&quot;: &quot;node bin&#x2F;ssl_hotfix.js mocha test&#x2F;unit&#x2F;**&#x2F;*.js --timeout 30000 --exit&quot;,\n  &quot;test:karma&quot;: &quot;node bin&#x2F;ssl_hotfix.js cross-env LISTEN_ADDR&#x3D;:: karma start karma.conf.cjs --single-run&quot;,\n  &quot;test:karma:server&quot;: &quot;node bin&#x2F;ssl_hotfix.js cross-env karma start karma.conf.cjs&quot;,\n  &quot;start&quot;: &quot;node .&#x2F;sandbox&#x2F;server.js&quot;,\n  &quot;preversion&quot;: &quot;gulp version &amp;&amp; npm test&quot;,\n  &quot;version&quot;: &quot;npm run build &amp;&amp; git add dist &amp;&amp; git add package.json&quot;,\n  &quot;prepublishOnly&quot;: &quot;npm test&quot;,\n  &quot;postpublish&quot;: &quot;git push &amp;&amp; git push --tags &quot;,\n  &quot;build&quot;: &quot;gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m&quot;, &#x2F;&#x2F; 打包只用到了gulp 和 rollup，没有用到webpack,webpack.config.js是多余的\n  &quot;examples&quot;: &quot;node .&#x2F;examples&#x2F;server.js&quot;,\n  &quot;coveralls&quot;: &quot;cat coverage&#x2F;lcov.info | .&#x2F;node_modules&#x2F;coveralls&#x2F;bin&#x2F;coveralls.js&quot;,\n  &quot;fix&quot;: &quot;eslint --fix lib&#x2F;**&#x2F;*.js&quot;\n&#125;,\n\nrollup.config.jsimport resolve from &quot;@rollup&#x2F;plugin-node-resolve&quot;;\nimport commonjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\nimport &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;\nimport json from &quot;@rollup&#x2F;plugin-json&quot;;\nimport &#123; babel &#125; from &quot;@rollup&#x2F;plugin-babel&quot;;\nimport autoExternal from &quot;rollup-plugin-auto-external&quot;;\n\nconst lib &#x3D; require(&quot;.&#x2F;package.json&quot;);\nconst outputFileName &#x3D; &quot;axios&quot;;\nconst name &#x3D; &quot;axios&quot;;\nconst input &#x3D; &quot;.&#x2F;lib&#x2F;axios.js&quot;; &#x2F;&#x2F; 源码入口\n&#x2F;&#x2F; minifiedVersion参数最小化，默认true，下面三处调用都没有传，这个文件与webpack.config.js无关\nconst buildConfig &#x3D; (&#123;\n  es5,\n  browser &#x3D; true,\n  minifiedVersion &#x3D; true,\n  ...config\n&#125;) &#x3D;&gt; &#123;\n  const build &#x3D; (&#123; minified &#125;) &#x3D;&gt; (&#123;\n    input,\n    ...config,\n    output: &#123;\n      ...config.output, &#x2F;&#x2F; 里面有banner信息\n      file: &#96;$&#123;config.output.file&#125;.$&#123;minified ? &quot;min.js&quot; : &quot;js&quot;&#125;&#96;,\n    &#125;,\n    plugins: [\n      json(),\n      resolve(&#123; browser &#125;),\n      commonjs(),\n      minified &amp;&amp; terser(),\n      ...(es5\n        ? [\n            babel(&#123;\n              babelHelpers: &quot;bundled&quot;,\n              presets: [&quot;@babel&#x2F;preset-env&quot;],\n            &#125;),\n          ]\n        : []),\n      ...(config.plugins || []),\n    ],\n  &#125;);\n\n  const configs &#x3D; [build(&#123; minified: false &#125;)];\n\n  if (minifiedVersion) &#123;\n    build(&#123; minified: true &#125;);\n  &#125;\n\n  return configs;\n&#125;;\n\nexport default async () &#x3D;&gt; &#123;\n  const year &#x3D; new Date().getFullYear();\n  const banner &#x3D; &#96;&#x2F;&#x2F; Axios v$&#123;lib.version&#125; Copyright (c) $&#123;year&#125; $&#123;lib.author&#125; and contributors&#96;;\n\n  return [\n    ...buildConfig(&#123;\n      es5: true,\n      output: &#123;\n        file: &#96;dist&#x2F;$&#123;outputFileName&#125;&#96;,\n        name,\n        format: &quot;umd&quot;, &#x2F;&#x2F; umd格式\n        exports: &quot;default&quot;,\n        banner,\n      &#125;,\n    &#125;),\n\n    ...buildConfig(&#123;\n      output: &#123;\n        file: &#96;dist&#x2F;esm&#x2F;$&#123;outputFileName&#125;&#96;,\n        format: &quot;esm&quot;, &#x2F;&#x2F; esm格式\n        preferConst: true,\n        exports: &quot;named&quot;,\n        banner,\n      &#125;,\n    &#125;),\n    &#x2F;&#x2F; Node.js commonjs build\n    &#123;\n      input,\n      output: &#123;\n        file: &#96;dist&#x2F;node&#x2F;$&#123;name&#125;.cjs&#96;,\n        format: &quot;cjs&quot;, &#x2F;&#x2F; commonjs格式\n        preferConst: true,\n        exports: &quot;default&quot;,\n        banner,\n      &#125;,\n      plugins: [autoExternal(), resolve(), commonjs()],\n    &#125;,\n  ];\n&#125;;\n\n注意\n\n\n\n\n\n\nWARNING\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn build\nyarn run v1.4.0\n$ gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m\n[14:19:33] Using gulpfile ~&#x2F;Desktop&#x2F;axios&#x2F;gulpfile.js\n[14:19:33] Starting &#39;clear&#39;...\n[14:19:33] Finished &#39;clear&#39; after 5.74 ms\n[!] Error: Cannot find module &#39;@babel&#x2F;core&#39;\nRequire stack:\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;@rollup&#x2F;plugin-babel&#x2F;dist&#x2F;index.js\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;rollup.config.js\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;rollup&#x2F;dist&#x2F;shared&#x2F;loadConfigFile.js\n- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;rollup&#x2F;dist&#x2F;bin&#x2F;rollup\nError: Cannot find module &#39;@babel&#x2F;core&#39;\n\n解决：\n\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn add @babel&#x2F;core -D\nyarn add v1.4.0\n[1&#x2F;4] 🔍  Resolving packages...\n[2&#x2F;4] 🚚  Fetching packages...\nwarning Pattern [&quot;@definitelytyped&#x2F;typescript-versions@latest&quot;] is trying to unpack in the same destination &quot;&#x2F;Users&#x2F;haotian&#x2F;Library&#x2F;Caches&#x2F;Yarn&#x2F;v1&#x2F;npm-@definitelytyped&#x2F;typescript-versions-0.0.118-de13fb755c5181443860c3c74b6730f47f6541fc&quot; as pattern [&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;,&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;,&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;]. This could result in non-deterministic behavior, skipping.\n[3&#x2F;4] 🔗  Linking dependencies...\nwarning &quot; &gt; @rollup&#x2F;plugin-babel@5.3.1&quot; has unmet peer dependency &quot;@types&#x2F;babel__core@^7.1.9&quot;.\nwarning &quot; &gt; istanbul-instrumenter-loader@3.0.1&quot; has unmet peer dependency &quot;webpack@^2.0.0 || ^3.0.0 || ^4.0.0&quot;.\nwarning &quot;karma &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.\nwarning &quot;karma &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.\nwarning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; node-fetch@2.6.7&quot; has unmet peer dependency &quot;encoding@^0.1.0&quot;.\nwarning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; ws@7.5.8&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.\nwarning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; ws@7.5.8&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.\nwarning &quot; &gt; terser-webpack-plugin@4.2.3&quot; has unmet peer dependency &quot;webpack@^4.0.0 || ^5.0.0&quot;.\n[4&#x2F;4] 📃  Building fresh packages...\nsuccess Saved lockfile.\nsuccess Saved 5 new dependencies.\n├─ @ampproject&#x2F;remapping@2.2.0\n├─ @babel&#x2F;core@7.18.5\n├─ @babel&#x2F;helpers@7.18.2\n├─ gensync@1.0.0-beta.2\n└─ json5@2.2.1\n✨  Done in 37.80s.\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn build\nyarn run v1.4.0\n$ gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m\n[14:20:32] Using gulpfile ~&#x2F;Desktop&#x2F;axios&#x2F;gulpfile.js\n[14:20:32] Starting &#39;clear&#39;...\n[14:20:32] Finished &#39;clear&#39; after 48 ms\n\n.&#x2F;lib&#x2F;axios.js → dist&#x2F;axios.js...\ncreated dist&#x2F;axios.js in 3.5s\n\n.&#x2F;lib&#x2F;axios.js → dist&#x2F;esm&#x2F;axios.js...\ncreated dist&#x2F;esm&#x2F;axios.js in 711ms\n\n.&#x2F;lib&#x2F;axios.js → dist&#x2F;node&#x2F;axios.cjs...\ncreated dist&#x2F;node&#x2F;axios.cjs in 1.1s\n✨  Done in 9.39s.\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $\n\n\n\n打包产物.\n├── axios.js\n├── axios.js.map\n├── esm\n│   ├── axios.js\n│   └── axios.js.map\n└── node\n    ├── axios.cjs\n    └── axios.cjs.map\n\n2 directories, 6 files\n\n哎？咋滴回事，我们在rollup.config.js见到minifiedVersion默认是true,传给 minified咋的没见min.js\nconst configs &#x3D; [build(&#123; minified: false &#125;)];\n\nif (minifiedVersion) &#123;\n  build(&#123; minified: true &#125;); &#x2F;&#x2F; 这么些应该是为了开发调试，在sandbox中 &lt;script src&#x3D;&quot;&#x2F;axios.js&quot;&gt;&lt;&#x2F;script&gt;\n&#125;\n\nreturn configs;\n&#x2F;&#x2F; 这里暴露的是configs， build(&#123;minified: true&#125;)完全没搞事情，\n&#x2F;&#x2F; 这代码应该是用 build(&#123;minified: true&#125;) 替换   build(&#123;minified: false&#125;) 才对\n\n修改下，然后运行yarn build\n\n\naxios.js&quot;use strict&quot;;\n\nimport utils from &quot;.&#x2F;utils.js&quot;;\nimport bind from &quot;.&#x2F;helpers&#x2F;bind.js&quot;;\nimport Axios from &quot;.&#x2F;core&#x2F;Axios.js&quot;;\nimport mergeConfig from &quot;.&#x2F;core&#x2F;mergeConfig.js&quot;;\nimport defaults from &quot;.&#x2F;defaults&#x2F;index.js&quot;;\nimport formDataToJSON from &quot;.&#x2F;helpers&#x2F;formDataToJSON.js&quot;;\nimport CanceledError from &quot;.&#x2F;cancel&#x2F;CanceledError.js&quot;;\nimport CancelToken from &quot;.&#x2F;cancel&#x2F;CancelToken.js&quot;;\nimport isCancel from &quot;.&#x2F;cancel&#x2F;isCancel.js&quot;;\nimport &#123; VERSION &#125; from &quot;.&#x2F;env&#x2F;data.js&quot;;\nimport toFormData from &quot;.&#x2F;helpers&#x2F;toFormData.js&quot;;\nimport AxiosError from &quot;..&#x2F;lib&#x2F;core&#x2F;AxiosError.js&quot;;\nimport spread from &quot;.&#x2F;helpers&#x2F;spread.js&quot;;\nimport isAxiosError from &quot;.&#x2F;helpers&#x2F;isAxiosError.js&quot;;\n\n&#x2F;**\n * Create an instance of Axios\n *\n * @param &#123;Object&#125; defaultConfig The default config for the instance\n *\n * @returns &#123;Axios&#125; A new instance of Axios\n *&#x2F;\nfunction createInstance(defaultConfig) &#123;\n  const context &#x3D; new Axios(defaultConfig);\n  const instance &#x3D; bind(Axios.prototype.request, context);\n\n  &#x2F;&#x2F; Copy axios.prototype to instance\n  &#x2F;&#x2F; 拷贝原型到实例\n  utils.extend(instance, Axios.prototype, context, &#123; allOwnKeys: true &#125;);\n\n  &#x2F;&#x2F; Copy context to instance\n  &#x2F;&#x2F; 拷贝上下文到实例\n  utils.extend(instance, context, &#123; allOwnKeys: true &#125;);\n\n  &#x2F;&#x2F; Factory for creating new instances\n  &#x2F;&#x2F; 用于创建新实例的工厂\n  instance.create &#x3D; function create(instanceConfig) &#123;\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  &#125;;\n\n  return instance;\n&#125;\n\n&#x2F;&#x2F; Create the default instance to be exported\n&#x2F;&#x2F; 使用默认配置创建实例\nconst axios &#x3D; createInstance(defaults);\n\n&#x2F;&#x2F; Expose Axios class to allow class inheritance\n&#x2F;&#x2F; 暴露Axios类，允许类被继承\naxios.Axios &#x3D; Axios;\n\n&#x2F;&#x2F; Expose Cancel &amp; CancelToken\naxios.CanceledError &#x3D; CanceledError;\naxios.CancelToken &#x3D; CancelToken;\naxios.isCancel &#x3D; isCancel;\naxios.VERSION &#x3D; VERSION; &#x2F;&#x2F; gulp的env任务会将package.json的版本信息读取并写入 .&#x2F;lib&#x2F;env&#x2F;data.js，见下面代码：\n&#x2F;&#x2F; const env &#x3D; gulp.task(&#39;env&#39;, async function () &#123;\n&#x2F;&#x2F;   var npm &#x3D; JSON.parse(await fs.readFile(&#39;package.json&#39;));\n\n&#x2F;&#x2F;   await fs.writeFile(&#39;.&#x2F;lib&#x2F;env&#x2F;data.js&#39;, Object.entries(&#123;\n&#x2F;&#x2F;     VERSION: npm.version\n&#x2F;&#x2F;   &#125;).map(([key, value]) &#x3D;&gt; &#123;\n&#x2F;&#x2F;     return &#96;export const $&#123;key&#125; &#x3D; $&#123;JSON.stringify(value)&#125;;&#96;\n&#x2F;&#x2F;   &#125;).join(&#39;\\n&#39;));\n&#x2F;&#x2F; &#125;);\naxios.toFormData &#x3D; toFormData;\n\n&#x2F;&#x2F; Expose AxiosError class\n&#x2F;&#x2F; 暴露AxuosError错误类\naxios.AxiosError &#x3D; AxiosError;\n\n&#x2F;&#x2F; alias for CanceledError for backward compatibility\n&#x2F;&#x2F; CanceledError的别名用于向后兼容\naxios.Cancel &#x3D; axios.CanceledError;\n\n&#x2F;&#x2F; Expose all&#x2F;spread\n&#x2F;&#x2F; 暴露并发\naxios.all &#x3D; function all(promises) &#123;\n  return Promise.all(promises);\n&#125;;\n&#x2F;&#x2F; 暴露spread\naxios.spread &#x3D; spread; &#x2F;&#x2F; 使用尾部调用柯里化，执行的结果还是一个函数\n\n&#x2F;&#x2F; Expose isAxiosError\n&#x2F;&#x2F; 暴露判断AxiosError的方法\naxios.isAxiosError &#x3D; isAxiosError;\n\naxios.formToJSON &#x3D; (thing) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 调用工具，将thing进行json化\n  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n&#125;;\n\nexport default axios;\n\n其他细节不看\n运行 sandboxyarn start\n\n\n👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn start\nyarn run v1.4.0\n$ node .&#x2F;sandbox&#x2F;server.js\nListening on localhost:3009...\n[Thu Jun 23 2022 16:16:31 GMT+0800 (中国标准时间)] GET &#x2F;\nfile:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:14\n  fs.createReadStream(path.join(__dirname, file)).pipe(res);\n                                ^\n\nReferenceError: __dirname is not defined\n    at pipeFileToResponse (file:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:14:33)\n    at Server.&lt;anonymous&gt; (file:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:30:5)\n    at Server.emit (node:events:390:28)\n    at parserOnIncoming (node:_http_server:951:12)\n    at HTTPParser.parserOnHeadersComplete (node:_http_common:128:17)\nerror An unexpected error occurred: &quot;Command failed.\\nExit code: 1\\nCommand: sh\\nArguments: -c node .&#x2F;sandbox&#x2F;server.js\\nDirectory: &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios\\nOutput:\\n&quot;.\ninfo If you think this is a bug, please open a bug report with the information provided in &quot;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;yarn-error.log&quot;.\ninfo Visit https:&#x2F;&#x2F;yarnpkg.com&#x2F;en&#x2F;docs&#x2F;cli&#x2F;run for documentation about this command.\n\n\n修改\nconst __filename &#x3D; url.fileURLToPath(import.meta.url); &#x2F;&#x2F; 增加这行 @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;import.meta\nconst __dirname &#x3D; path.dirname(__filename); &#x2F;&#x2F; 增加这行\n\nfunction pipeFileToResponse(res, file, type) &#123;\n  if (type) &#123;\n    res.writeHead(200, &#123;\n      &quot;Content-Type&quot;: type,\n    &#125;);\n  &#125;\n\n  fs.createReadStream(path.join(__dirname, file)).pipe(res);\n&#125;\n\n\n\ncore 目录axios 执行流程执行流程\n先看看整体执行流程，有大体的概念，后面会细说整体流程有以下几点：\n\naxios.create 创建单独实例，或直接使用 axios 实例(axios&#x2F;axios.get…)\nrequest 方法是入口，axios&#x2F;axios.get 等调用都会走进 request 进行处理\n请求拦截器\n请求数据转换器，对传入的参数 data 和 header 做数据处理，比如 JSON.stringify(data)\n适配器，判断是浏览器端还是 node 端，执行不同的方法\n响应数据转换器，对服务端的数据进行处理，比如 JSON.parse(data)\n响应拦截器，对服务端数据做处理，比如 token 失效退出登陆，报错 dialog 提示\n返回数据给开发者\n\n\n\n入口文件file:lib/axios.js\n从下面这段代码可以得出，导出的 axios 就是实例化后的对象，还在其上挂载 create 方法，以供创建独立实例，从而达到实例之间互不影响，互相隔离。\n...\n&#x2F;&#x2F; 创建实例过程的方法\nfunctioncreateInstance(defaultConfig) &#123;return instance;&#125;&#x2F;&#x2F; 实例化\nvar axios &#x3D; createInstance(defaults);&#x2F;&#x2F; 创建独立的实例，隔离作用域\naxios.create &#x3D; functioncreate(instanceConfig) &#123;return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;...\n&#x2F;&#x2F; 导出实例\nmodule.exports &#x3D; axios; &#x2F;&#x2F; 可能大家对 createInstance 方法感到好奇，下面一探究竟。\n\nfunctioncreateInstance(defaultConfig) &#123;\n  &#x2F;&#x2F; 实例化，创建一个上下文\nvar context &#x3D; new Axios(defaultConfig);\n&#x2F;&#x2F; 平时调用的 get&#x2F;post 等等请求，底层都是调用 request 方法\n&#x2F;&#x2F; 将 request 方法的 this 指向 context(上下文)，形成新的实例\nvar instance &#x3D; bind(Axios.prototype.request, context);\n&#x2F;&#x2F; Axios.prototype 上的方法 (get&#x2F;post...)挂载到新的实例 instance 上，\n&#x2F;&#x2F; 并且将原型方法中 this 指向\ncontext utils.extend(instance, Axios.prototype, context);\n&#x2F;&#x2F; Axios 属性值挂载到新的实例 instance 上\n&#x2F;&#x2F; 开发中才能使用 axios.default&#x2F;interceptors\nutils.extend(instance, context);return instance;&#125;\n&#x2F;&#x2F; 从上面代码可以看得出，Axios 不是简单的创建实例 context，而且进行一系列的上下文绑定和属性方法挂载，从而去支持 axios()，也支持 axios.get() 等等用法；\n\ncreateInstance 函数是一个核心入口，我们在把上面流程梳理一下：\n\n通过构造函数 Axios 创建实例 context，作为下面 request 方法的上下文（this 指向）\n将 Axios.prototype.request 方法作为实例使用，并把 this 指向 context，形成新的实例 instance\n将构造函数 Axios.prototype 上的方法挂载到新的实例 instance 上，然后将原型各个方法中的 this 指向 context，开发中才能使用 axios.get&#x2F;post… 等等\n将构造函数 Axios 的实例属性挂载到新的实例 instance 上，我们开发中才能使用下面属性 axios.default.baseUrl &#x3D; ‘https:&#x2F;&#x2F;…’axios.interceptors.request.use(resolve,reject)大家可能对上面第 2 点 request 方法感到好奇，createInstance 方法明明可以写一行代码 return new Axios() 即可，为什么大费周章使用 request 方法绑定新实例，其实就只是为了支持 axios() 写法，开发者可以写少几行代码。。。\n\n默认配置file:lib/defaults.js\n从 createInstance 方法调用发现有个默认配置，主要是内置的属性和方法，可对其进行覆盖\nvar defaults &#x3D; &#123;\n  ...\n  &#x2F;&#x2F; 请求超时时间，默认不超时\n  timeout: 0,\n   &#x2F;&#x2F; 请求数据转换器\n  transformRequest: [functiontransformRequest(data, headers) &#123;...&#125;],\n  &#x2F;&#x2F; 响应数据转换器\n  transformResponse: [functiontransformResponse(data) &#123;...&#125;], ...&#125;;\n  ...\n\n主要有两点：\n\n配置：外部传入，可覆盖内部默认配置\n拦截器：实例后，开发者可通过 use 方法注册成功和失败的钩子函数，比如\n\naxios.interceptors.request.use((config)&#x3D;&gt;config,(error)&#x3D;&gt;error);\nfunctionAxios(instanceConfig) &#123;\n  &#x2F;&#x2F; 配置\n  this.defaults &#x3D; instanceConfig;\n  &#x2F;&#x2F; 拦截器实例\n  this.interceptors &#x3D; &#123;request: new InterceptorManager(),response: new InterceptorManager() &#125;;&#125;\n\n在看看原型方法 request 做了什么\n支持多类型传参配置优先级定义通过 promise 链式调用，依次顺序执行\n&#x2F;&#x2F; 伪代码\nAxios.prototype.request &#x3D; functionrequest(config) &#123;\n  &#x2F;&#x2F; 为了支持\n  request(url, &#123;...&#125;), request(&#123;url, ...&#125;)if (typeof config &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123; config &#x3D; arguments[1] || &#123;&#125;; config.url &#x3D; arguments[0]; &#125; else &#123; config &#x3D; config || &#123;&#125;; &#125;\n  &#x2F;&#x2F; 配置优先级： 调用方法的配置 &gt; 实例化 axios 的配置 &gt; 默认配置\n  &#x2F;&#x2F; 举个例子，类似：\n  axios.get(url, &#123;&#125;) &gt; axios.create(url, &#123;&#125;) &gt; 内部默认设置 config &#x3D; mergeConfig(this.defaults, config);\n  &#x2F;&#x2F; 拦截器（请求和响应）\n  var requestInterceptorChain &#x3D; [&#123;fulfilled: interceptor.request.fulfilled,rejected: interceptor.request.rejected &#125;];\n  var responseInterceptorChain &#x3D; [&#123;fulfilled: interceptor.response.fulfilled,rejected: interceptor.response.rejected &#125;];\n  var promise;&#x2F;&#x2F; 形成一个 promise 链条的数组\n  var chain &#x3D; [].concat(requestInterceptorChain, chain, responseInterceptorChain);\n  &#x2F;&#x2F; 传入配置\n  promise &#x3D; Promise.resolve(config);\n  &#x2F;&#x2F; 形成 promise 链条调用\n   while (chain.length) &#123; promise &#x3D; promise.then(chain.shift(), chain.shift()); &#125; ... return promise;&#125;;\n\n通过对数组的遍历，形成一条异步的 promise 调用链，是 axios 对 promise 的巧妙运用，用一张图表示\n\n\n拦截器file:lib/core/InterceptorManager.js\n上面说到的 promise 调用链，里面涉及到拦截器，拦截器比较简单，挂载一个属性和三个原型方法\n\nhandler: 存放 use 注册的回调函数\nuse: 注册成功和失败的回调函数\neject: 删除注册过的函数\nforEach: 遍历回调函数，一般内部使用多，比如：promise 调用链那个方法里，循环遍历回调函数，存放到 promise 调用链的数组中\n\nclass InterceptorManager &#123;\n  constructor() &#123;\n    this.handlers &#x3D; [];\n  &#125;\n\n  &#x2F;**\n   * Add a new interceptor to the stack\n   * &#x2F;&#x2F; 注册成功和失败的回调函数\n   * @param &#123;Function&#125; fulfilled The function to handle &#96;then&#96; for a &#96;Promise&#96;\n   * @param &#123;Function&#125; rejected The function to handle &#96;reject&#96; for a &#96;Promise&#96;\n   *\n   * @return &#123;Number&#125; An ID used to remove interceptor later\n   *&#x2F;\n  use(fulfilled, rejected, options) &#123;\n    this.handlers.push(&#123;\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null,\n    &#125;);\n    return this.handlers.length - 1;\n  &#125;\n\n  &#x2F;**\n   * Remove an interceptor from the stack\n   * &#x2F;&#x2F; 删除注册过的函数\n   * @param &#123;Number&#125; id The ID that was returned by &#96;use&#96;\n   *\n   * @returns &#123;Boolean&#125; &#96;true&#96; if the interceptor was removed, &#96;false&#96; otherwise\n   *&#x2F;\n  eject(id) &#123;\n    if (this.handlers[id]) &#123;\n      this.handlers[id] &#x3D; null;\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * Clear all interceptors from the stack\n   * 调用栈清空所有拦截器\n   * @returns &#123;void&#125;\n   *&#x2F;\n  clear() &#123;\n    if (this.handlers) &#123;\n      this.handlers &#x3D; [];\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become &#96;null&#96; calling &#96;eject&#96;.\n   * &#x2F;&#x2F; 遍历回调函数，一般内部使用多\n   * @param &#123;Function&#125; fn The function to call for each interceptor\n   *\n   * @returns &#123;void&#125;\n   *&#x2F;\n  forEach(fn) &#123;\n    utils.forEach(this.handlers, function forEachHandler(h) &#123;\n      if (h !&#x3D;&#x3D; null) &#123;\n        fn(h);\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n\nexport default InterceptorManager;\n\ndispatchRequestfile: lib/core/dispatchRequest.js\n上面说到的 promise 调用链中的 dispatchRequest 方法，主要做了以下操作：以 transformData.call方式调用\n\ntransformRequest: 对 config 中的 data 进行加工，比如对 post 请求的 data 进行字符串化 （JSON.stringify(data)）\nadapter：适配器，包含浏览器端 xhr 和 node 端的 http\ntransformResponse: 对服务端响应的数据进行加工，比如 JSON.parse(data)\n\ndispatchRequest 局部图\n\n\nmodule.exports &#x3D; functiondispatchRequest(config) &#123;\n  ...\n  &#x2F;&#x2F; transformRequest 方法，上下文绑定 config，对 data 和 headers 进行加工\n  config.data &#x3D; transformData.call( config,\n  &#x2F;&#x2F; 上下文环境，即 this 指向 config.data,\n  &#x2F;&#x2F; 请求 body 参数 config.headers,\n  &#x2F;&#x2F; 请求头 config.transformRequest\n  &#x2F;&#x2F; 转换数据方法\n  );\n  &#x2F;&#x2F; adapter 是一个适配器，包含浏览器端 xhr 和 node 端的 http\n  &#x2F;&#x2F; 内置有 adapter，也可外部自定义去发起 ajax 请求\n  var adapter &#x3D; config.adapter || defaults.adapter;return adapter(config).then(\n    functiononAdapterResolution(response) &#123;\n    &#x2F;&#x2F; transformResponse 方法，上下文绑定 config，对 data 和 headers 进行加工\n      response.data &#x3D; transformData.call( config,\n      &#x2F;&#x2F; 上下文环境，即 this 指向\n      response.data, &#x2F;&#x2F; 服务端响应的 data\n      config.transformResponse &#x2F;&#x2F; 转换数据方法\n      );\n\n      response.headers, &#x2F;&#x2F; 服务端响应的 headers\n\n      return response;\n     &#125;,\n    functiononAdapterRejection(reason) &#123;\n     ...\n     return Promise.reject(reason);\n    &#125;);\n  &#125;;\n\n数据转换器file:lib/core/transformData.js\n上面说到的数据转换器，比较好理解，源码如下\n&#x2F;&#x2F; fns 方法即（请求或响应）数据转换器方法，在刚开始 defaults 文件里定义的默认配置，也可外部自定义方法，源码如下：\n\n&#x2F;**\n * Transform the data for a request or a response\n * 转换请求或响应的数据\n * @param &#123;Array|Function&#125; fns 一个数组，包含一个或多个方法转换器方法\n * @param &#123;?Object&#125; response The response object\n *\n * @returns &#123;*&#125; The resulting transformed data\n *&#x2F;\nexport default function transformData(fns, response) &#123;\n  const config &#x3D; this || defaults;\n  const context &#x3D; response || config;\n  const headers &#x3D; AxiosHeaders.from(context.headers);\n  let data &#x3D; context.data;\n\n  utils.forEach(fns, function transform(fn) &#123;\n    data &#x3D; fn.call(\n      config,\n      data,\n      headers.normalize(),\n      response ? response.status : undefined\n    );\n  &#125;);\n\n  headers.normalize();\n\n  return data;\n&#125;\n\nAxiosfile: lib/defaults.js\n\nconst defaults &#x3D; &#123;\n  ...\n  &#x2F;&#x2F; 返回转化后的请求参数\n  transformRequest: [function transformRequest(data, headers) &#123;\n    const contentType &#x3D; headers.getContentType() || &#39;&#39;;\n    const hasJSONContentType &#x3D; contentType.indexOf(&#39;application&#x2F;json&#39;) &gt; -1;\n    const isObjectPayload &#x3D; utils.isObject(data);\n\n    if (isObjectPayload &amp;&amp; utils.isHTMLForm(data)) &#123;\n      data &#x3D; new FormData(data);\n    &#125;\n\n    const isFormData &#x3D; utils.isFormData(data);\n\n    if (isFormData) &#123;\n      if (!hasJSONContentType) &#123;\n        return data;\n      &#125;\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    &#125;\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) &#123;\n      return data;\n    &#125;\n    if (utils.isArrayBufferView(data)) &#123;\n      return data.buffer;\n    &#125;\n    if (utils.isURLSearchParams(data)) &#123;\n      headers.setContentType(&#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8&#39;, false);\n      return data.toString();\n    &#125;\n\n    let isFileList;\n\n    if (isObjectPayload) &#123;\n      if (contentType.indexOf(&#39;application&#x2F;x-www-form-urlencoded&#39;) &gt; -1) &#123;\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      &#125;\n\n      if ((isFileList &#x3D; utils.isFileList(data)) || contentType.indexOf(&#39;multipart&#x2F;form-data&#39;) &gt; -1) &#123;\n        const _FormData &#x3D; this.env &amp;&amp; this.env.FormData;\n\n        return toFormData(\n          isFileList ? &#123;&#39;files[]&#39;: data&#125; : data,\n          _FormData &amp;&amp; new _FormData(),\n          this.formSerializer\n        );\n      &#125;\n    &#125;\n\n    if (isObjectPayload || hasJSONContentType ) &#123;\n      headers.setContentType(&#39;application&#x2F;json&#39;, false);\n      return stringifySafely(data);\n    &#125;\n\n    return data;\n  &#125;],\n  &#x2F;&#x2F; 返回转化后的响应数据\n  transformResponse: [function transformResponse(data) &#123;\n    const transitional &#x3D; this.transitional || defaults.transitional;\n    const forcedJSONParsing &#x3D; transitional &amp;&amp; transitional.forcedJSONParsing;\n    const JSONRequested &#x3D; this.responseType &#x3D;&#x3D;&#x3D; &#39;json&#39;;\n\n    if (data &amp;&amp; utils.isString(data) &amp;&amp; ((forcedJSONParsing &amp;&amp; !this.responseType) || JSONRequested)) &#123;\n      const silentJSONParsing &#x3D; transitional &amp;&amp; transitional.silentJSONParsing;\n      const strictJSONParsing &#x3D; !silentJSONParsing &amp;&amp; JSONRequested;\n\n      try &#123;\n        return JSON.parse(data); &#x2F;&#x2F; 解析数据\n      &#125; catch (e) &#123;\n        if (strictJSONParsing) &#123;\n          if (e.name &#x3D;&#x3D;&#x3D; &#39;SyntaxError&#39;) &#123;\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          &#125;\n          throw e;\n        &#125;\n      &#125;\n    &#125;\n\n    return data;\n  &#125;],\n\n\n&#125;;\n\n适配器file:lib/defaults.js\n主要包含两部分源码，即浏览器端 xhr 和 node 端的 http 请求，通过判断环境，执行不同端的 api。\nimport utils from &quot;..&#x2F;utils.js&quot;;\nimport httpAdapter from &quot;.&#x2F;http.js&quot;;\nimport xhrAdapter from &quot;.&#x2F;xhr.js&quot;;\n\nconst adapters &#x3D; &#123;\n  http: httpAdapter,\n  xhr: xhrAdapter,\n&#125;;\n\nexport default &#123;\n  getAdapter: (nameOrAdapter) &#x3D;&gt; &#123;\n    if (utils.isString(nameOrAdapter)) &#123;\n      const adapter &#x3D; adapters[nameOrAdapter];\n\n      if (!nameOrAdapter) &#123;\n        throw Error(\n          utils.hasOwnProp(nameOrAdapter)\n            ? &#96;Adapter &#39;$&#123;nameOrAdapter&#125;&#39; is not available in the build&#96;\n            : &#96;Can not resolve adapter &#39;$&#123;nameOrAdapter&#125;&#39;&#96;\n        );\n      &#125;\n\n      return adapter;\n    &#125;\n\n    if (!utils.isFunction(nameOrAdapter)) &#123;\n      throw new TypeError(&quot;adapter is not a function&quot;);\n    &#125;\n\n    return nameOrAdapter;\n  &#125;,\n  adapters,\n&#125;;\n\n&#x2F;&#x2F; 注：&#x2F;axios&#x2F;lib&#x2F;core&#x2F;dispatchRequest.js\n&#x2F;&#x2F; const adapter &#x3D; config.adapter || defaults.adapter; 中调用 defaults.adapter\n&#x2F;&#x2F; file: &#x2F;axios&#x2F;lib&#x2F;defaults&#x2F;index.js\n&#x2F;&#x2F; export const default &#x3D; &#123;\n&#x2F;&#x2F;   adapter: getDefaultAdapter(),\n&#x2F;&#x2F; &#125;\n\n对外提供统一 api，但底层兼容浏览器端和 node 端，类似 sdk，底层更改不影响上层 api，保持向后兼容\n发起请求file: lib/adapters/xhr.js平时用得比较多的是浏览器端，这里只讲 XMLHttpRequest 的封装，node 端有兴趣的同学自行查看源码(lib&#x2F;adapters&#x2F;http.js)\n简易版流程图表示大致内容：\n\n注意：新版本有改动\n\nsetCancelToken 没啦，有 cancelToken 和 signal\nisSetCookie 没有这个\nonreadystatechange 不一定有, onloadend方法一定会被调用\n\nif (&quot;onloadend&quot; in request) &#123;\n  &#x2F;&#x2F; Use onloadend if available\n  request.onloadend &#x3D; onloadend;\n&#125; else &#123;\n  &#x2F;&#x2F; Listen for ready state to emulate onloadend\n  request.onreadystatechange &#x3D; function handleLoad() &#123;\n    if (!request || request.readyState !&#x3D;&#x3D; 4) &#123;\n      return;\n    &#125;\n\n    &#x2F;&#x2F; The request errored out and we didn&#39;t get a response, this will be\n    &#x2F;&#x2F; handled by onerror instead\n    &#x2F;&#x2F; With one exception: request that using file: protocol, most browsers\n    &#x2F;&#x2F; will return status as 0 even though it&#39;s a successful request\n    if (\n      request.status &#x3D;&#x3D;&#x3D; 0 &amp;&amp;\n      !(request.responseURL &amp;&amp; request.responseURL.indexOf(&quot;file:&quot;) &#x3D;&#x3D;&#x3D; 0)\n    ) &#123;\n      return;\n    &#125;\n    &#x2F;&#x2F; readystate handler is calling before onerror or ontimeout handlers,\n    &#x2F;&#x2F; so we should call onloadend on the next &#39;tick&#39;\n    setTimeout(onloadend);\n  &#125;;\n&#125;\n\n参考链接Axios 源码解析-完整篇\n一步一步解析 Axios 源码，从入门到原理\naxios 源码中的 10 多个工具函数，值得一学~\n","slug":"2022-06-23axios","date":"2022-06-23T01:22:54.000Z","categories_index":"Http","tags_index":"源码","author_index":"举手摘月亮"},{"id":"a154738b9ff4f1409237a2b3abef8f87","title":"react-router v0.6.4 依赖 history 5.0.0-beta.5源码","content":"介绍Documentation for version 5 can be found in the docs directory. This is the current stable release. Version 5 is used in React Router version 6.history 5 对应 React Router 6\nDocumentation for version 4 can be found on the v4 branch. Version 4 is used in React Router versions 4 and 5.history 4 对应 React Router 4 和 5\nThe history library provides history tracking and navigation primitives for JavaScript applications that run in browsers and other stateful environments.历史库为在浏览器和其他有状态环境中运行的 JavaScript 应用程序提供历史跟踪和导航。If you haven’t yet, please take a second to read through the Installation guide to get the library installed and running on your system.如果尚未安装，请花几秒钟阅读安装指南，以便在系统上安装并运行库。\nWe provide 3 different methods for working with history, depending on your environment:根据您的环境，我们提供了 3 种不同的历史处理方法：\n\nA “browser history” is for use in modern web browsers that support the HTML5 history API (see cross-browser compatibility)“浏览器历史记录”用于支持 HTML5 历史记录 API 的现代 web 浏览器（请参阅跨浏览器兼容性）\n\nA “hash history” is for use in web browsers where you want to store the location in the hash portion of the current URL to avoid sending it to the server when the page reloads“哈希历史记录”用于 web 浏览器中，您希望将位置存储在当前 URL 的哈希部分中，以避免在页面重新加载时将其发送到服务器\n\nA “memory history” is used as a reference implementation that may be used in non-browser environments, like React Native or tests“内存历史记录”用作参考实现，可在非浏览器环境中使用，如 React Native 或 tests\n\n\n\n\n\n\n\n\nTIP\n常用的是 “browser history” ，使用 “hash history”，会有用户反馈怎么有#号，要你去除，除此之外，有时候需要用到hash滚动到页面具体某个位置，所以为了hash只做定位，通常用 browser history，进行导航\n以 github 为例：\nhttps://github.com/841660202/history/blob/dev/docs/getting-started.md#basic-usage\n“memory history” 这个基本上没见到过有用的，react-native使用react-navigation进行导航,react-navigation的package.json种未见到history依赖\n\nThe main bundle exports one method for each environment: createBrowserHistory for browsers, createHashHistory for using hash history in browsers, and createMemoryHistory for creating an in-memory history.\n主捆绑包为每个环境导出一个方法：createBrowserHistory 用于浏览器，CreateBhashHistory 用于在浏览器中使用哈希历史，createMemoryHistory 用于创建内存中的历史。\nIn addition to the main bundle, the library also includes history&#x2F;browser and history&#x2F;hash bundles that export singletons you can use to quickly get a history instance for the current document (web page).除了主捆绑包之外，该库还包括 history&#x2F;browser 和 history&#x2F;hash 包，这些捆绑包导出可以用于快速获取当前文档（网页）的历史实例的单例。\n基本使用见\napi 参考见\n源码注意\npackage.json种 workspaces 格式错误，无法 yarn\n\n&#x2F;&#x2F; 改前\n&quot;workspaces&quot;: &#123;\n    &quot;packages&quot;: [\n      &quot;packages&#x2F;history&quot;\n    ]\n  &#125;\n&#x2F;&#x2F; 改后\n&quot;workspaces&quot;: [\n  &quot;packages&#x2F;*&quot;\n]\n\n\n在yarn test前，需要yarn build,执行打包输出，因为 test 会引用 build 的产物\n\n&#123;\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;build&quot;: &quot;node .&#x2F;scripts&#x2F;build.js&quot;,\n    &quot;size&quot;: &quot;filesize&quot;,\n    &quot;clean&quot;: &quot;git clean -fdX .&quot;,\n    &quot;lint&quot;: &quot;eslint .&quot;,\n    &quot;prepublishOnly&quot;: &quot;yarn build&quot;,\n    &quot;test&quot;: &quot;node .&#x2F;scripts&#x2F;test.js&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;@ampproject&#x2F;filesize&quot;: &quot;^2.1.1&quot;,\n    &quot;@ampproject&#x2F;rollup-plugin-closure-compiler&quot;: &quot;0.21.0&quot;,\n    &quot;@babel&#x2F;core&quot;: &quot;^7.1.2&quot;,\n    &quot;@babel&#x2F;plugin-transform-runtime&quot;: &quot;^7.7.6&quot;,\n    &quot;@babel&#x2F;preset-env&quot;: &quot;^7.1.0&quot;,\n    &quot;@babel&#x2F;preset-modules&quot;: &quot;^0.1.1&quot;,\n    &quot;@rollup&#x2F;plugin-replace&quot;: &quot;^2.2.1&quot;,\n    &quot;babel-core&quot;: &quot;^7.0.0-bridge.0&quot;,\n    &quot;babel-eslint&quot;: &quot;^7.0.0&quot;,\n    &quot;babel-loader&quot;: &quot;^8.0.4&quot;,\n    &quot;babel-plugin-dev-expression&quot;: &quot;^0.2.1&quot;,\n    &quot;eslint&quot;: &quot;^3.3.0&quot;,\n    &quot;eslint-plugin-import&quot;: &quot;^2.0.0&quot;,\n    &quot;expect&quot;: &quot;^21.0.0&quot;,\n    &quot;express&quot;: &quot;^4.17.1&quot;,\n    &quot;jest-mock&quot;: &quot;^21.0.0&quot;,\n    &quot;karma&quot;: &quot;^3.1.3&quot;,\n    &quot;karma-browserstack-launcher&quot;: &quot;^1.3.0&quot;,\n    &quot;karma-chrome-launcher&quot;: &quot;^2.2.0&quot;,\n    &quot;karma-firefox-launcher&quot;: &quot;^1.1.0&quot;,\n    &quot;karma-mocha&quot;: &quot;^1.3.0&quot;,\n    &quot;karma-mocha-reporter&quot;: &quot;^2.2.5&quot;,\n    &quot;karma-sourcemap-loader&quot;: &quot;^0.3.7&quot;,\n    &quot;karma-webpack&quot;: &quot;^3.0.5&quot;,\n    &quot;mocha&quot;: &quot;^5.2.0&quot;,\n    &quot;rollup&quot;: &quot;^1.27.9&quot;,\n    &quot;rollup-plugin-babel&quot;: &quot;^4.0.3&quot;,\n    &quot;rollup-plugin-copy&quot;: &quot;^3.1.0&quot;,\n    &quot;rollup-plugin-prettier&quot;: &quot;^0.6.0&quot;,\n    &quot;rollup-plugin-terser&quot;: &quot;^5.1.2&quot;,\n    &quot;webpack&quot;: &quot;^3.12.0&quot;\n  &#125;,\n  &quot;filesize&quot;: &#123;\n    &quot;build&#x2F;history&#x2F;history.production.min.js&quot;: &#123;\n      &quot;none&quot;: &quot;5 kB&quot;\n    &#125;,\n    &quot;build&#x2F;history&#x2F;umd&#x2F;history.production.min.js&quot;: &#123;\n      &quot;none&quot;: &quot;6 kB&quot;\n    &#125;\n  &#125;,\n  &quot;workspaces&quot;: [&quot;packages&#x2F;*&quot;]\n&#125;\n\n查看文件我们可以了解到,该项目依赖种没有history包，由于是yarn workspaces 项目，test 下引入history的都是产物\n\n测试 yarn test, 浏览器会运行开启，页面历史栈 进栈 出栈 操作，最终浏览器历史会完全出栈。大概是使用了karma-chrome-launcher\n\n打包使用 rollup\nimport babel from &quot;rollup-plugin-babel&quot;;\nimport compiler from &quot;@ampproject&#x2F;rollup-plugin-closure-compiler&quot;;\nimport copy from &quot;rollup-plugin-copy&quot;; &#x2F;&#x2F; 有些不需要改变的直接拷贝\nimport prettier from &quot;rollup-plugin-prettier&quot;;\nimport replace from &quot;@rollup&#x2F;plugin-replace&quot;;\nimport &#123; terser &#125; from &quot;rollup-plugin-terser&quot;; &#x2F;&#x2F; deadcode\n\nconst PRETTY &#x3D; !!process.env.PRETTY;\nconsole.log(&quot;PRETTY&quot;, PRETTY); &#x2F;&#x2F; false\nconst SOURCE_DIR &#x3D; &quot;packages&#x2F;history&quot;;\nconst OUTPUT_DIR &#x3D; &quot;build&#x2F;history&quot;;\n&#x2F;&#x2F; 模块化，应该是按需的东西，产出esm格式, 产出 browser、hash\nconst modules &#x3D; [\n  &#123;\n    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,\n    output: &#123;\n      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;history.js&#96;,\n      format: &quot;esm&quot;,\n      sourcemap: !PRETTY,\n    &#125;,\n    external: [&quot;@babel&#x2F;runtime&#x2F;helpers&#x2F;esm&#x2F;extends&quot;],\n    plugins: [\n      babel(&#123;\n        exclude: &#x2F;node_modules&#x2F;,\n        presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],\n        plugins: [\n          &quot;babel-plugin-dev-expression&quot;,\n          [&quot;@babel&#x2F;plugin-transform-runtime&quot;, &#123; useESModules: true &#125;],\n        ],\n        runtimeHelpers: true,\n      &#125;),\n      compiler(),\n      copy(&#123;\n        targets: [\n          &#123; src: &quot;README.md&quot;, dest: OUTPUT_DIR &#125;,\n          &#123; src: &quot;LICENSE&quot;, dest: OUTPUT_DIR &#125;,\n          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;package.json&#96;, dest: OUTPUT_DIR &#125;,\n          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.d.ts&#96;, dest: OUTPUT_DIR &#125;,\n          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;browser.d.ts&#96;, dest: OUTPUT_DIR &#125;,\n          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;hash.d.ts&#96;, dest: OUTPUT_DIR &#125;,\n        ],\n        verbose: true,\n      &#125;),\n    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),\n  &#125;,\n  ...[&quot;browser&quot;, &quot;hash&quot;].map((env) &#x3D;&gt; &#123;\n    return &#123;\n      input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;$&#123;env&#125;.js&#96;,\n      output: &#123;\n        file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;$&#123;env&#125;.js&#96;,\n        format: &quot;esm&quot;,\n        sourcemap: !PRETTY,\n      &#125;,\n      plugins: [\n        babel(&#123;\n          exclude: &#x2F;node_modules&#x2F;,\n          presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],\n          plugins: [&quot;babel-plugin-dev-expression&quot;],\n        &#125;),\n        compiler(),\n      ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),\n    &#125;;\n  &#125;),\n];\n&#x2F;&#x2F; web浏览器esm结构，只处理history\nconst webModules &#x3D; [\n  &#123;\n    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,\n    output: &#123;\n      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;history.development.js&#96;,\n      format: &quot;esm&quot;,\n      sourcemap: !PRETTY,\n    &#125;,\n    plugins: [\n      babel(&#123;\n        exclude: &#x2F;node_modules&#x2F;,\n        presets: [&quot;@babel&#x2F;preset-modules&quot;],\n        plugins: [&quot;babel-plugin-dev-expression&quot;],\n      &#125;),\n      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;),\n      compiler(),\n    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),\n  &#125;,\n  &#123;\n    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,\n    output: &#123;\n      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;history.production.min.js&#96;,\n      format: &quot;esm&quot;,\n      sourcemap: !PRETTY,\n    &#125;,\n    plugins: [\n      babel(&#123;\n        exclude: &#x2F;node_modules&#x2F;,\n        presets: [&quot;@babel&#x2F;preset-modules&quot;],\n        plugins: [&quot;babel-plugin-dev-expression&quot;],\n      &#125;),\n      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) &#125;),\n      compiler(),\n      terser(&#123; ecma: 8, safari10: true &#125;),\n    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),\n  &#125;,\n];\n&#x2F;&#x2F; 浏览器、服务端 umd格式\nconst globals &#x3D; [\n  &#123;\n    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,\n    output: &#123;\n      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;umd&#x2F;history.development.js&#96;,\n      format: &quot;umd&quot;,\n      sourcemap: !PRETTY,\n      name: &quot;HistoryLibrary&quot;,\n    &#125;,\n    plugins: [\n      babel(&#123;\n        exclude: &#x2F;node_modules&#x2F;,\n        presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],\n        plugins: [&quot;babel-plugin-dev-expression&quot;],\n      &#125;),\n      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;),\n      compiler(),\n    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),\n  &#125;,\n  &#123;\n    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,\n    output: &#123;\n      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;umd&#x2F;history.production.min.js&#96;,\n      format: &quot;umd&quot;,\n      sourcemap: !PRETTY,\n      name: &quot;HistoryLibrary&quot;,\n    &#125;,\n    plugins: [\n      babel(&#123;\n        exclude: &#x2F;node_modules&#x2F;,\n        presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],\n        plugins: [&quot;babel-plugin-dev-expression&quot;],\n      &#125;),\n      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) &#125;),\n      compiler(),\n      terser(),\n    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),\n  &#125;,\n];\n&#x2F;&#x2F; 服务端common.js\nconst node &#x3D; [\n  &#123;\n    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;node-main.js&#96;,\n    output: &#123;\n      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;main.js&#96;,\n      format: &quot;cjs&quot;,\n    &#125;,\n    plugins: [compiler()].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),\n  &#125;,\n];\n\nexport default [...modules, ...webModules, ...globals, ...node];\n\nhistory.js&#x2F;&#x2F; history&#x2F;packages&#x2F;history&#x2F;history.js\n&#x2F;&#x2F; 取中间值\nfunction clamp(n, lowerBound, upperBound) &#123;\n  return Math.min(Math.max(n, lowerBound), upperBound);\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; UTILS\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; 卸载前提示\nfunction promptBeforeUnload(event) &#123;\n  &#x2F;&#x2F; Cancel the event.\n  event.preventDefault();\n  &#x2F;&#x2F; Chrome (and legacy IE) requires returnValue to be set.\n  event.returnValue &#x3D; &quot;&quot;;\n&#125;\n&#x2F;&#x2F; 创建事件\nfunction createEvents() &#123;\n  let handlers &#x3D; [];\n\n  return &#123;\n    get length() &#123;\n      return handlers.length;\n    &#125;,\n    push(fn) &#123;\n      handlers.push(fn);\n      return function () &#123;\n        handlers &#x3D; handlers.filter((handler) &#x3D;&gt; handler !&#x3D;&#x3D; fn);\n      &#125;;\n    &#125;,\n    call(arg) &#123;\n      handlers.forEach((fn) &#x3D;&gt; fn &amp;&amp; fn(arg));\n    &#125;,\n  &#125;;\n&#125;\n&#x2F;&#x2F; 创建唯一key\nfunction createKey() &#123;\n  return Math.random().toString(36).substr(2, 8);\n&#125;\n&#x2F;&#x2F; 生成path\nexport function createPath(&#123; pathname &#x3D; &quot;&#x2F;&quot;, search &#x3D; &quot;&quot;, hash &#x3D; &quot;&quot; &#125;) &#123;\n  return pathname + search + hash;\n&#125;\n&#x2F;&#x2F; 解析path\nexport function parsePath(path) &#123;\n  &#x2F;&#x2F; &#39;https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;?aldtype&#x3D;16047#ast&#x2F;zh&#x2F;promptBeforeUnload&#39;\n  let pieces &#x3D; &#123;&#125;;\n\n  if (path) &#123;\n    let hashIndex &#x3D; path.indexOf(&quot;#&quot;);\n    if (hashIndex &gt;&#x3D; 0) &#123;\n      pieces.hash &#x3D; path.substr(hashIndex); &#x2F;&#x2F; #ast&#x2F;zh&#x2F;promptBeforeUnload\n      path &#x3D; path.substr(0, hashIndex); &#x2F;&#x2F; https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;?aldtype&#x3D;16047\n    &#125;\n\n    let searchIndex &#x3D; path.indexOf(&quot;?&quot;);\n    if (searchIndex &gt;&#x3D; 0) &#123;\n      pieces.search &#x3D; path.substr(searchIndex); &#x2F;&#x2F; ?aldtype&#x3D;16047\n      path &#x3D; path.substr(0, searchIndex); &#x2F;&#x2F; https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;\n    &#125;\n\n    if (path) &#123;\n      pieces.pathname &#x3D; path;\n    &#125;\n  &#125;\n\n  return pieces;\n&#125;\n\ncreateBrowserHistory&#x2F;&#x2F; 对象只读\nconst readOnly &#x3D; __DEV__ ? (obj) &#x3D;&gt; Object.freeze(obj) : (obj) &#x3D;&gt; obj;\n\n&#x2F;**\n * Browser history stores the location in regular URLs. This is the\n * standard for most web apps, but it requires some configuration on\n * the server to ensure you serve the same app at multiple URLs.\n * 浏览器历史记录将位置存储在常规URL中。这是\n * 大多数web应用程序的标准配置，但它需要在\n * 确保您在多个URL上为同一应用程序提供服务的服务器。\n *&#x2F;\nexport function createBrowserHistory(&#123; window &#x3D; document.defaultView &#125; &#x3D; &#123;&#125;) &#123;\n  let globalHistory &#x3D; window.history;\n  &#x2F;&#x2F; 获取第几个，和 location 信息\n  function getIndexAndLocation() &#123;\n    let &#123; pathname, search, hash &#125; &#x3D; window.location;\n    let state &#x3D; globalHistory.state || &#123;&#125;;\n    return [\n      state.idx,\n      readOnly(&#123;\n        &#x2F;&#x2F; 对象只读\n        pathname,\n        search,\n        hash,\n        state: state.usr || null,\n        key: state.key || &quot;default&quot;,\n      &#125;),\n    ];\n  &#125;\n\n  let blockedPopTx &#x3D; null;\n  function handlePop() &#123;\n    &#x2F;&#x2F; 出栈\n    if (blockedPopTx) &#123;\n      blockers.call(blockedPopTx);\n      blockedPopTx &#x3D; null;\n    &#125; else &#123;\n      let nextAction &#x3D; PopAction;\n      let [nextIndex, nextLocation] &#x3D; getIndexAndLocation();\n\n      if (blockers.length) &#123;\n        if (nextIndex !&#x3D; null) &#123;\n          let n &#x3D; index - nextIndex;\n          if (n) &#123;\n            &#x2F;&#x2F; Revert the POP 还原POP\n            blockedPopTx &#x3D; &#123;\n              action: nextAction,\n              location: nextLocation,\n              retry() &#123;\n                go(n * -1);\n              &#125;,\n            &#125;;\n\n            go(n);\n          &#125;\n        &#125; else &#123;\n          &#x2F;&#x2F; Trying to POP to a location with no index. We did not create\n          &#x2F;&#x2F; this location, so we can&#39;t effectively block the navigation.\n          &#x2F;&#x2F; 正在尝试弹出到没有索引的位置。我们没有创建此位置，因此无法有效阻止导航。\n          warning(\n            false,\n            &#x2F;&#x2F; TODO: Write up a doc that explains our blocking strategy in\n            &#x2F;&#x2F; detail and link to it here so people can understand better\n            &#x2F;&#x2F; what is going on and how to avoid it.\n            &#96;You are trying to block a POP navigation to a location that was not &#96; +\n              &#96;created by the history library. The block will fail silently in &#96; +\n              &#96;production, but in general you should do all navigation with the &#96; +\n              &#96;history library (instead of using window.history.pushState directly) &#96; +\n              &#96;to avoid this situation.&#96;\n          );\n        &#125;\n      &#125; else &#123;\n        applyTx(nextAction);\n      &#125;\n    &#125;\n  &#125;\n\n  window.addEventListener(PopStateEventType &#x2F;* popstate *&#x2F;, handlePop);\n\n  let action &#x3D; PopAction;\n  let [index, location] &#x3D; getIndexAndLocation();\n  let blockers &#x3D; createEvents();\n  let listeners &#x3D; createEvents();\n\n  if (index &#x3D;&#x3D; null) &#123;\n    index &#x3D; 0;\n    globalHistory.replaceState(&#123; ...globalHistory.state, idx: index &#125;, null);\n  &#125;\n\n  function createHref(to) &#123;\n    return typeof to &#x3D;&#x3D;&#x3D; &quot;string&quot; ? to : createPath(to);\n  &#125;\n\n  function getNextLocation(to, state &#x3D; null) &#123;\n    return readOnly(&#123;\n      ...location,\n      ...(typeof to &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(to) : to),\n      state,\n      key: createKey(),\n    &#125;);\n  &#125;\n  &#x2F;&#x2F; 获取history state 和 url\n  function getHistoryStateAndUrl(nextLocation, index) &#123;\n    return [\n      &#123;\n        usr: nextLocation.state,\n        key: nextLocation.key,\n        idx: index,\n      &#125;,\n      createHref(nextLocation),\n    ];\n  &#125;\n  &#x2F;&#x2F; 执行观察者\n  function allowTx(action, location, retry) &#123;\n    return (\n      !blockers.length || (blockers.call(&#123; action, location, retry &#125;), false)\n    );\n  &#125;\n  &#x2F;&#x2F; 执行观察者\n  function applyTx(nextAction) &#123;\n    action &#x3D; nextAction;\n    [index, location] &#x3D; getIndexAndLocation();\n    listeners.call(&#123; action, location &#125;);\n  &#125;\n  &#x2F;&#x2F; 进栈\n  function push(to, state) &#123;\n    let nextAction &#x3D; PushAction;\n    let nextLocation &#x3D; getNextLocation(to, state);\n    function retry() &#123;\n      push(to, state);\n    &#125;\n\n    if (allowTx(nextAction, nextLocation, retry)) &#123;\n      let [historyState, url] &#x3D; getHistoryStateAndUrl(nextLocation, index + 1);\n\n      &#x2F;&#x2F; TODO: Support forced reloading\n      &#x2F;&#x2F; try...catch because iOS limits us to 100 pushState calls :&#x2F;\n      try &#123;\n        globalHistory.pushState(historyState, null, url);\n      &#125; catch (error) &#123;\n        &#x2F;&#x2F; They are going to lose state here, but there is no real\n        &#x2F;&#x2F; way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      &#125;\n\n      applyTx(nextAction);\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 替换\n  function replace(to, state) &#123;\n    let nextAction &#x3D; ReplaceAction;\n    let nextLocation &#x3D; getNextLocation(to, state);\n    function retry() &#123;\n      replace(to, state);\n    &#125;\n\n    if (allowTx(nextAction, nextLocation, retry)) &#123;\n      let [historyState, url] &#x3D; getHistoryStateAndUrl(nextLocation, index);\n\n      &#x2F;&#x2F; TODO: Support forced reloading\n      globalHistory.replaceState(historyState, null, url);\n\n      applyTx(nextAction);\n    &#125;\n  &#125;\n\n  function go(n) &#123;\n    globalHistory.go(n);\n  &#125;\n\n  let history &#x3D; &#123;\n    get action() &#123;\n      return action;\n    &#125;,\n    get location() &#123;\n      return location;\n    &#125;,\n    createHref,\n    push,\n    replace,\n    go,\n    back() &#123;\n      go(-1);\n    &#125;,\n    forward() &#123;\n      go(1);\n    &#125;,\n    listen(fn) &#123;\n      &#x2F;&#x2F; react-router使用listen监听变化，并进行匹配渲染\n      return listeners.push(fn);\n    &#125;,\n    block(fn) &#123;\n      let unblock &#x3D; blockers.push(fn);\n\n      if (blockers.length &#x3D;&#x3D;&#x3D; 1) &#123;\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      &#125;\n\n      return function () &#123;\n        unblock();\n        &#x2F;&#x2F;页面undload之前清空监听，避免内存泄漏\n        &#x2F;&#x2F; Remove the beforeunload listener so the document may\n        &#x2F;&#x2F; still be salvageable in the pagehide event.\n        &#x2F;&#x2F; See https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;#unloading-documents\n        if (!blockers.length) &#123;\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        &#125;\n      &#125;;\n    &#125;,\n  &#125;;\n  &#x2F;&#x2F; 最终返回一个history对象，有一系列方法\n  return history;\n&#125;\n\ncreateHashHistory先不看了…\n参考链接remix-run&#x2F;history\n","slug":"2022-06-22.history","date":"2022-06-22T10:40:45.000Z","categories_index":"React","tags_index":"React,源码,react-router","author_index":"举手摘月亮"},{"id":"229017905bfbb779fea0f9efffb5a64c","title":"腾讯云COS,docx无法在浏览器预览","content":"背景其他部门项目接入我们部门 wfc 审批流，有附件需要预览，附件种类非常多：图片、office(doc、ppt…)、代码文件（css、html、js…）\n\n图片预览：使用第三方插件&#x2F;自己开发\npdf: 使用第三方插件&#x2F;iframe 具备浏览器预览 pdf 功能\noffice 预览：office预览地址 + iframe\n\n\nfunction getOfficeUrl(fileUrl: string) &#123;\n  if(!fileUrl) &#123;\n    throw new Error(&quot;fileUrl is required&quot;);\n  &#125;\n  return &#96;https:&#x2F;&#x2F;view.officeapps.live.com&#x2F;op&#x2F;view.aspx?src&#x3D;$&#123;encodeURIComponent(fileUrl))&#125;&#96;;\n&#125;\n\ngetOfficeUrl(&#39;https:&#x2F;&#x2F;hello-1257881288.cos.ap-shanghai.myqcloud.com&#x2F;demo.docx&#39;)\n&#x2F;&#x2F; 结果\n&#x2F;&#x2F; https:&#x2F;&#x2F;view.officeapps.live.com&#x2F;op&#x2F;view.aspx?src&#x3D;https%3A%2F%2Fhello-1257881288.cos.ap-shanghai.myqcloud.com%2Fdemo.docx\n\n注意：一个月内有效（仅买了一个月）\n\n\n\n\n\n\n\n\nTIP\n顺便提句: 使用 https://view.officeapps.live.com/op/view.aspx?src=预览失败后返回的是一个新的 url 错误地址，这并不意味着是 iframe 加载错误\n&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;view.officeapps.live.com&#x2F;op&#x2F;view.aspx?src&#x3D;https%3A%2F%2Fhello-1257881288.cos.ap-shanghai.myqcloud.com%2Fdemo.docx&quot; height&#x3D;300 width&#x3D;&#39;100%&#39;&gt;\n  加载失败了，提醒我（这个永远不会走到，除非&#96;https:&#x2F;&#x2F;view.officeapps.live.com&#96;挂了）\n&lt;&#x2F;iframe&gt;\n\n\n\n遇到坑通过 fileKey 获取预览地址\n汗～,文件存储同学给的解释\n\n在通过 fileKey 获取预览地址时候，由于业务方的 pdf 类型 fileKey 有两种情况：\n\nfileKey有.pdf 结尾：获取到的临时预览地址是可以预览\nfileKey无.pdf 结尾：获取到的临时预览地址是不可以预览，仅支持下载\n\n腾讯云文档\n\nContent-Disposition: attachment; filename*&#x3D;”abc.txt”， 中有 attachment 即下载\n\n每个文件详情自定义 Headers部分\n\n\n\n\n文档的意思是：要想浏览器预览：上传文件需满足响应头正确\n\n方式 1: 上传文件带后缀，自动生成响应头\n\n方式 1: 上传文件，需要配置文件的 content-type\n\n\n通过 fileKey 获取预览地址为 office 类型文件\n前面说了，office 预览借助iframe,仅此即可实现，阿里云 OSS，妥妥滴没问题（阿里云我不贴图了，测试文件已被删除）\n\n\n\n\n\n\n\nWARNING\n阿里云上上传文件，测试后，删除，几分钟内，文件还可以访问，第二天再访问不可访问了\n贴下不可访问的地址：（想着能访问，就不贴了，原因是：这是公司的一个模版文件，敏不敏感，我不晓得，我只是用来测试）\nhttps://view.officeapps.live.com/op/view.aspx?src=http%3A%2F%2Ft-blog-images.aijs.top%2FTYZN-XPPZ-04-006%252B%25E4%25BE%259B%25E5%25BA%2594%25E5%2595%2586%25E4%25BA%25A7%25E5%2593%2581%25E8%25B4%25A8%25E9%2587%258F%25E4%25BF%259D%25E8%25AF%2581%25E5%258D%258F%25E8%25AE%25AE_B1.docx\n如果是非常敏感的数据，不建议拿来测试，因为即使你删除文件，短时间内该文件地址还是可以访问的\n\n对于腾讯 COS，我特地花了 0.85RMB 买了一个月\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;hello-1257881288.cos.ap-shanghai.myqcloud.com&#x2F;demo.docx\n\n\n\n可到了腾讯云可就不一样了，昨天腾讯云，慢的要死，官网打开速度竟然比简书一篇文章还慢\n第二天询问公司附件存储方我们 wfc 项目 office 预览怎么又可以了，之前 6（预发环境）6 个文件 1 个可以预览，（线上环境）6 个都不能预览\n回答：\n\n\n汗～， 我说昨天访问怎么那么慢\n复测昨天买的 COS，docx 文件预览,今天确实又可以了\n\n\n昨天确实不行，我测了几百遍\n\n\n期间怀疑过响应头,网上各种乱七八糟的内容还需要自己辨别\n\n\n续 数据万象解绑我测试一下，继续扣费，关掉\n\n\n\n\n微软的链接不稳定2022-12-1 16:13 嗝屁了\nhttps://view.officeapps.live.com/op/view.aspx?src=http://t-blog-images.oss-cn-hangzhou.aliyuncs.com/demo.xlsx\n谷歌在线链接不能编辑\n\n\nhttps://drive.google.com/viewer?url=http://t-blog-images.oss-cn-hangzhou.aliyuncs.com/demo.xlsx\n总结有时后真的不是你的方式错误，第三方出的问题，奇葩的一笔，（预发环境）6 个文件 1 个可以预览，（线上环境）6 个都不能预览,备注：相同的数据.\n这个问题搞了大半天，下午收到内部系统反馈工单，到晚上近 8 点，问题一直存在。 由于盲目相信腾讯，一直以为是内部系统文件或是项目代码书写问题，排查了那么久测试了那么长时间（每次都要发到预发测试，因为日常公司存储服务不支持 office 预览，两周前已反馈了没给解决）。这么严重的问题，腾讯内部竟然也那么久才解决吗？没有黑任何平台的意思，我被腾讯 COS 害苦了～\n","slug":"2022-06-22cos","date":"2022-06-22T01:21:46.000Z","categories_index":"对象存储","tags_index":"对象存储","author_index":"举手摘月亮"},{"id":"72ce6d94dd6a62c447ee1fdb4516d01c","title":"react-router v6.4.0 源码","content":"背景整了半天上一篇看的竟然是概念，我还以为是原理呢\n最近看到了，面试题 react-router 原理，查了下答案，内容不是很多\nReact Router 原理浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理\nReact Router 源码解析\n之前没看过实现原理，现在看到也没那么难 从小被吓大的， 带着好奇心看下仓库代码：4+1（index.ts）个文件没看错\n\n\nindex.ts&#x2F;&#x2F; 暴露出的api\nexport &#123;\n  MemoryRouter,\n  Navigate,\n  NavigationType,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  createPath,\n  createRoutesFromChildren,\n  generatePath,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  renderMatches,\n  resolvePath,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigate,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n&#125;;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; DANGER! PLEASE READ ME! 危险！请读这个！\n&#x2F;&#x2F; We provide these exports as an escape hatch in the event that you need any\n&#x2F;&#x2F; routing data that we don&#39;t provide an explicit API for. With that said, we\n&#x2F;&#x2F; want to cover your use case if we can, so if you feel the need to use these\n&#x2F;&#x2F; we want to hear from you. Let us know what you&#39;re building and we&#39;ll do our\n&#x2F;&#x2F; best to make sure we can support you!\n&#x2F;&#x2F; 我们提供这些导出作为一个逃逸引用，以防你需要我们没有提供明确 API 的任何路由数据。也就是说，\n&#x2F;&#x2F; 如果你需要这些，我们希望能够为你提供支持，所以如果你有需要，请告诉我们你的需求，我们会尽可能地为你提供支持。\n&#x2F;&#x2F; We consider these exports an implementation detail and do not guarantee\n&#x2F;&#x2F; against any breaking changes, regardless of the semver release. Use with\n&#x2F;&#x2F; extreme caution and only if you understand the consequences. Godspeed.\n&#x2F;&#x2F; 我们考虑这些导出是一个实现细节，并且不保证对任何变更不会有任何影响，无论是在 semver 版本发布前或者后。\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\nhistory源码中使用了一个 history 库\nThe history library lets you easily manage session history anywhere JavaScript runs. A history object abstracts away the differences in various environments and provides a minimal API that lets you manage the history stack, navigate, and persist state between sessions.这个库让你在任何 JavaScript 运行的地方都能方便地管理会话历史记录。一个历史对象抽象了不同环境的差异，并提供了一个最小的 API，让你管理历史堆栈，导航，并在会话间保持状态。\nreact-router-dom\n\n\n\n\n\n\n\n\n对react-router进行了扩展，\nreact-router-dom,在react-router的核心基础上，添加了用于跳转的Link组件，和histoy模式下的BrowserRouter和 hash 模式下的HashRouter组件等。所谓 BrowserRouter和HashRouter，也只不过用了history库中createBrowserHistory和createHashHistory方法\n找个 demo 从头看import React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;\n\nimport &quot;.&#x2F;index.css&quot;;\nimport App from &quot;.&#x2F;App&quot;;\n\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &lt;BrowserRouter&gt; &#x2F;&#x2F; react-router-dom\n      &lt;App &#x2F;&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  &lt;&#x2F;React.StrictMode&gt;,\n  document.getElementById(&quot;root&quot;)\n\nBrowserRouterexport function BrowserRouter(&#123;\n  basename,\n  children,\n  window,\n&#125;: BrowserRouterProps) &#123;\n  let historyRef &#x3D; React.useRef&lt;BrowserHistory&gt;();\n  if (historyRef.current &#x3D;&#x3D; null) &#123;\n    historyRef.current &#x3D; createBrowserHistory(&#123; window &#125;);\n  &#125;\n\n  let history &#x3D; historyRef.current;\n  let [state, setState] &#x3D; React.useState(&#123;\n    action: history.action,\n    location: history.location,\n  &#125;);\n  &#x2F;&#x2F; 监听url变化， 改变state，更新Router的location，location更新后会触发Router内部重新渲染\n  React.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);\n\n  return (\n    &lt;Router &#x2F;&#x2F; react-router &quot;.&#x2F;lib&#x2F;components&quot;\n      basename&#x3D;&#123;basename&#125;\n      children&#x3D;&#123;children&#125;\n      location&#x3D;&#123;state.location&#125;\n      navigationType&#x3D;&#123;state.action&#125;\n      navigator&#x3D;&#123;history&#125;\n    &#x2F;&gt;\n  );\n&#125;\n\nreact-router “.&#x2F;lib&#x2F;components”\n&#x2F;**\n * Provides location context for the rest of the app.\n * 为应用程序的其余部分提供位置上下文。\n * Note: You usually won&#39;t render a &lt;Router&gt; directly. Instead, you&#39;ll render a\n * router that is more specific to your environment such as a &lt;BrowserRouter&gt;\n * in web browsers or a &lt;StaticRouter&gt; for server rendering.\n * 注意：通常不会直接渲染&lt;Router&gt;。相反，您将渲染\n * 更特定于您的环境的路由器，如&lt;BrowserRouter&gt;\n * 在web浏览器中或用于服务器渲染的&lt;StaticRouter&gt;。\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;routers&#x2F;router\n *&#x2F;\nexport function Router(&#123;\n  basename: basenameProp &#x3D; &quot;&#x2F;&quot;,\n  children &#x3D; null,\n  location: locationProp, &#x2F;&#x2F; Location\n  navigationType &#x3D; NavigationType.Pop,\n  navigator,\n  static: staticProp &#x3D; false,\n&#125;: RouterProps): React.ReactElement | null &#123;\n  invariant(\n    !useInRouterContext(),\n    &#96;You cannot render a &lt;Router&gt; inside another &lt;Router&gt;.&#96; +\n      &#96; You should never have more than one in your app.&#96;\n  );\n\n  let basename &#x3D; normalizePathname(basenameProp);\n  let navigationContext &#x3D; React.useMemo(\n    () &#x3D;&gt; (&#123; basename, navigator, static: staticProp &#125;),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    locationProp &#x3D; parsePath(locationProp);\n  &#125;\n\n  let &#123;\n    pathname &#x3D; &quot;&#x2F;&quot;,\n    search &#x3D; &quot;&quot;,\n    hash &#x3D; &quot;&quot;,\n    state &#x3D; null,\n    key &#x3D; &quot;default&quot;,\n  &#125; &#x3D; locationProp;\n\n  let location &#x3D; React.useMemo(() &#x3D;&gt; &#123;\n    let trailingPathname &#x3D; stripBasename(pathname, basename);\n\n    if (trailingPathname &#x3D;&#x3D; null) &#123;\n      return null;\n    &#125;\n\n    return &#123;\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    &#125;;\n  &#125;, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location !&#x3D; null,\n    &#96;&lt;Router basename&#x3D;&quot;$&#123;basename&#125;&quot;&gt; is not able to match the URL &#96; +\n      &#96;&quot;$&#123;pathname&#125;$&#123;search&#125;$&#123;hash&#125;&quot; because it does not start with the &#96; +\n      &#96;basename, so the &lt;Router&gt; won&#39;t render anything.&#96;\n  );\n\n  if (location &#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n\n  return (\n    &lt;NavigationContext.Provider value&#x3D;&#123;navigationContext&#125;&gt;\n      &#123;&quot; &quot;&#125;\n      &#x2F;&#x2F; React.createContext使用， 一般情况这里会单独抽取 NavigationContext， 并写成useNavigationContext\n      &lt;LocationContext.Provider &#x2F;&#x2F; 一般情况这里会单独抽取 LocationContext, 并写成useLocationContext\n        children&#x3D;&#123;children&#125; &#x2F;&#x2F; 是这种以属性形式写入的，不是在标签中包裹的， 即example&#x2F;basic &lt;App &#x2F;&gt;\n        value&#x3D;&#123;&#123; location, navigationType &#125;&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;NavigationContext.Provider&gt;\n  );\n&#125;\n\nNavigationContext\n&#x2F;**\n * A Navigator is a &quot;location changer&quot;; it&#39;s how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level &lt;Router&gt; API\n * where both the location and a navigator must be provided separately in order\n * to avoid &quot;tearing&quot; that may occur in a suspense-enabled app if the action\n * and&#x2F;or location were to be read directly from the history instance.\n *&#x2F;\nexport type Navigator &#x3D; Pick&lt;History, &quot;go&quot; | &quot;push&quot; | &quot;replace&quot; | &quot;createHref&quot;&gt;;\n\ninterface NavigationContextObject &#123;\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n&#125;\n\nexport const NavigationContext &#x3D; React.createContext&lt;NavigationContextObject&gt;(\n  null!\n);\n\nLocationContext\ninterface LocationContextObject &#123;\n  location: Location;\n  navigationType: NavigationType;\n&#125;\n\nexport const LocationContext &#x3D; React.createContext&lt;LocationContextObject&gt;(\n  null!\n);\n\nApp.tsx\nimport * as React from &quot;react&quot;;\nimport &#123; Routes, Route, Outlet, Link &#125; from &quot;react-router-dom&quot;;\n\nexport default function App() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Basic Example&lt;&#x2F;h1&gt;\n\n      &lt;p&gt;\n        This example demonstrates some of the core features of React Router\n        including nested &lt;code&gt;&lt;Route&gt;&lt;&#x2F;code&gt;s,&#123;&quot; &quot;&#125;\n        &lt;code&gt;&lt;Outlet&gt;&lt;&#x2F;code&gt;s, &lt;code&gt;&lt;Link&gt;&lt;&#x2F;code&gt;s, and using a\n        &quot;*&quot; route (aka &quot;splat route&quot;) to render a &quot;not found&quot; page when someone\n        visits an unrecognized URL.\n      &lt;&#x2F;p&gt;\n\n      &#123;&#x2F;* Routes nest inside one another. Nested route paths build upon\n            parent route paths, and nested route elements render inside\n            parent route elements. See the note about &lt;Outlet&gt; below. *&#x2F;&#125;\n      &#123;&#x2F;* 管线相互嵌套。嵌套布线路径基于\n      线路径和嵌套管线元素在内部渲染\n      父管线元素。请参见下面关于&lt;Outlet&gt;的注释。*&#x2F;&#125;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n          &#123;&quot; &quot;&#125;\n          &#x2F;&#x2F; Route在createRoutesFromChildren中进行处理 element.type &#x3D;&#x3D;&#x3D; Route\n          &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;dashboard&quot; element&#x3D;&#123;&lt;Dashboard &#x2F;&gt;&#125; &#x2F;&gt;\n          &#123;&#x2F;* Using path&#x3D;&quot;*&quot;&quot; means &quot;match anything&quot;, so this route\n                acts like a catch-all for URLs that we don&#39;t have explicit\n                routes for. *&#x2F;&#125;\n          &#123;&#x2F;* 啥都没捞着，走匹配*&#x2F;&#125;\n          &lt;Route path&#x3D;&quot;*&quot; element&#x3D;&#123;&lt;NoMatch &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;&#x2F;Route&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Layout() &#123;\n  return (\n    &lt;div&gt;\n      &#123;&#x2F;* A &quot;layout route&quot; is a good place to put markup you want to\n          share across all the pages on your site, like navigation. *&#x2F;&#125;\n      &lt;nav&gt;\n        &lt;ul&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;dashboard&quot;&gt;Dashboard&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;nothing-here&quot;&gt;Nothing Here&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;nav&gt;\n\n      &lt;hr &#x2F;&gt;\n\n      &#123;&#x2F;* An &lt;Outlet&gt; renders whatever child route is currently active,\n          so you can think about this &lt;Outlet&gt; as a placeholder for\n          the child routes we defined above. *&#x2F;&#125;\n      &lt;Outlet &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Home() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Home&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction About() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;About&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Dashboard() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Dashboard&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction NoMatch() &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Nothing to see here!&lt;&#x2F;h2&gt;\n      &lt;p&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Go to the home page&lt;&#x2F;Link&gt;\n      &lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nimport &#123; Routes, Route, Outlet, Link &#125; from &quot;react-router-dom&quot;;\nRoutes传入一个路由的数组，返回对应要展示的组件，有点类似于 vue 的路由的配置，可以在别的文件夹配置好路由，然后传入 APP.tsx 中\n&#x2F;**\n * A container for a nested tree of &lt;Route&gt; elements that renders the branch\n * that best matches the current location.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;routes\n *&#x2F;\nexport function Routes(&#123;\n  children,\n  location,\n&#125;: RoutesProps): React.ReactElement | null &#123;\n  return useRoutes(createRoutesFromChildren(children), location);\n&#125;\n\ncreateRoutesFromChildren看大概意思，怎么实现不管\n大意是从 Children 中创建路由\n&#x2F;**\n * Creates a route config from a React &quot;children&quot; object, which is usually\n * either a &#96;&lt;Route&gt;&#96; element or an array of them. Used internally by\n * &#96;&lt;Routes&gt;&#96; to create a route config from its children.\n * 从React“children”对象创建路由配置，通常\n * 一个&#96;&lt;路由&gt;&#96;元素或它们的数组。内部使用人\n * &#96;&lt;路由&gt;&#96;从其子级创建路由配置。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;create-routes-from-children\n *&#x2F;\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] &#123;\n  let routes: RouteObject[] &#x3D; [];\n\n  React.Children.forEach(children, (element) &#x3D;&gt; &#123;\n    if (!React.isValidElement(element)) &#123;\n      &#x2F;&#x2F; Ignore non-elements. This allows people to more easily inline\n      &#x2F;&#x2F; conditionals in their route config.\n      return;\n    &#125;\n\n    if (element.type &#x3D;&#x3D;&#x3D; React.Fragment) &#123;\n      &#x2F;&#x2F; Transparently support React.Fragment and its children.\n      &#x2F;&#x2F; 递归\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    &#125;\n\n    invariant(\n      element.type &#x3D;&#x3D;&#x3D; Route,\n      &#96;[$&#123;\n        typeof element.type &#x3D;&#x3D;&#x3D; &quot;string&quot; ? element.type : element.type.name\n      &#125;] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;&#96;\n    );\n\n    let route: RouteObject &#x3D; &#123;\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n    &#125;;\n\n    if (element.props.children) &#123;\n      &#x2F;&#x2F; 递归\n      route.children &#x3D; createRoutesFromChildren(element.props.children);\n    &#125;\n\n    routes.push(route);\n  &#125;);\n\n  return routes;\n&#125;\n\nuseRoutes&#x2F;**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an &lt;Outlet&gt; to render their child route&#39;s\n * element.\n * 返回与当前位置匹配的路由元素，已准备就绪\n * 使用正确的上下文渲染路由树的其余部分。路线\n * 树中的元素必须渲染一个&lt;Outlet&gt;，才能渲染其子路由的\n * 元素。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-routes\n *&#x2F;\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial&lt;Location&gt; | string\n): React.ReactElement | null &#123;\n  &#x2F;&#x2F; invariant(\n  &#x2F;&#x2F;   useInRouterContext(),\n  &#x2F;&#x2F;   &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n  &#x2F;&#x2F;   &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n  &#x2F;&#x2F;   &#96;useRoutes() may be used only in the context of a &lt;Router&gt; component.&#96;\n  &#x2F;&#x2F; );\n\n  let &#123; matches: parentMatches &#125; &#x3D; React.useContext(RouteContext);\n  let routeMatch &#x3D; parentMatches[parentMatches.length - 1];\n  let parentParams &#x3D; routeMatch ? routeMatch.params : &#123;&#125;;\n  let parentPathname &#x3D; routeMatch ? routeMatch.pathname : &quot;&#x2F;&quot;;\n  let parentPathnameBase &#x3D; routeMatch ? routeMatch.pathnameBase : &quot;&#x2F;&quot;;\n  let parentRoute &#x3D; routeMatch &amp;&amp; routeMatch.route;\n\n  &#x2F;&#x2F; if (__DEV__) &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F; You won&#39;t get a warning about 2 different &lt;Routes&gt; under a &lt;Route&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F; without a trailing *, but this is a best-effort warning anyway since we\n  &#x2F;&#x2F;   &#x2F;&#x2F; cannot even give the warning unless they land at the parent route.\n  &#x2F;&#x2F;   &#x2F;&#x2F;\n  &#x2F;&#x2F;   &#x2F;&#x2F; Example:\n  &#x2F;&#x2F;   &#x2F;&#x2F;\n  &#x2F;&#x2F;   &#x2F;&#x2F; &lt;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   &#123;&#x2F;* This route path MUST end with &#x2F;* because otherwise\n  &#x2F;&#x2F;   &#x2F;&#x2F;       it will never match &#x2F;blog&#x2F;post&#x2F;123 *&#x2F;&#125;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   &lt;Route path&#x3D;&quot;blog&quot; element&#x3D;&#123;&lt;Blog &#x2F;&gt;&#125; &#x2F;&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   &lt;Route path&#x3D;&quot;blog&#x2F;feed&quot; element&#x3D;&#123;&lt;BlogFeed &#x2F;&gt;&#125; &#x2F;&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F; &lt;&#x2F;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;\n  &#x2F;&#x2F;   &#x2F;&#x2F; function Blog() &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   return (\n  &#x2F;&#x2F;   &#x2F;&#x2F;     &lt;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;       &lt;Route path&#x3D;&quot;post&#x2F;:id&quot; element&#x3D;&#123;&lt;Post &#x2F;&gt;&#125; &#x2F;&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;     &lt;&#x2F;Routes&gt;\n  &#x2F;&#x2F;   &#x2F;&#x2F;   );\n  &#x2F;&#x2F;   &#x2F;&#x2F; &#125;\n  &#x2F;&#x2F;   let parentPath &#x3D; (parentRoute &amp;&amp; parentRoute.path) || &quot;&quot;;\n  &#x2F;&#x2F;   warningOnce(\n  &#x2F;&#x2F;     parentPathname,\n  &#x2F;&#x2F;     !parentRoute || parentPath.endsWith(&quot;*&quot;),\n  &#x2F;&#x2F;     &#96;You rendered descendant &lt;Routes&gt; (or called \\&#96;useRoutes()\\&#96;) at &#96; +\n  &#x2F;&#x2F;       &#96;&quot;$&#123;parentPathname&#125;&quot; (under &lt;Route path&#x3D;&quot;$&#123;parentPath&#125;&quot;&gt;) but the &#96; +\n  &#x2F;&#x2F;       &#96;parent route path has no trailing &quot;*&quot;. This means if you navigate &#96; +\n  &#x2F;&#x2F;       &#96;deeper, the parent won&#39;t match anymore and therefore the child &#96; +\n  &#x2F;&#x2F;       &#96;routes will never render.\\n\\n&#96; +\n  &#x2F;&#x2F;       &#96;Please change the parent &lt;Route path&#x3D;&quot;$&#123;parentPath&#125;&quot;&gt; to &lt;Route &#96; +\n  &#x2F;&#x2F;       &#96;path&#x3D;&quot;$&#123;parentPath &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ? &quot;*&quot; : &#96;$&#123;parentPath&#125;&#x2F;*&#96;&#125;&quot;&gt;.&#96;\n  &#x2F;&#x2F;   );\n  &#x2F;&#x2F; &#125;\n\n  let locationFromContext &#x3D; useLocation();\n\n  let location;\n  if (locationArg) &#123;\n    let parsedLocationArg &#x3D;\n      typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;\n\n    &#x2F;&#x2F; invariant(\n    &#x2F;&#x2F;   parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ||\n    &#x2F;&#x2F;     parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n    &#x2F;&#x2F;   &#96;When overriding the location using \\&#96;&lt;Routes location&gt;\\&#96; or \\&#96;useRoutes(routes, location)\\&#96;, &#96; +\n    &#x2F;&#x2F;     &#96;the location pathname must begin with the portion of the URL pathname that was &#96; +\n    &#x2F;&#x2F;     &#96;matched by all parent routes. The current pathname base is &quot;$&#123;parentPathnameBase&#125;&quot; &#96; +\n    &#x2F;&#x2F;     &#96;but pathname &quot;$&#123;parsedLocationArg.pathname&#125;&quot; was given in the \\&#96;location\\&#96; prop.&#96;\n    &#x2F;&#x2F; );\n\n    location &#x3D; parsedLocationArg;\n  &#125; else &#123;\n    location &#x3D; locationFromContext;\n  &#125;\n\n  let pathname &#x3D; location.pathname || &quot;&#x2F;&quot;;\n  let remainingPathname &#x3D;\n    parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || &quot;&#x2F;&quot;;\n  let matches &#x3D; matchRoutes(routes, &#123; pathname: remainingPathname &#125;);\n\n  &#x2F;&#x2F; if (__DEV__) &#123;\n  &#x2F;&#x2F;   warning(\n  &#x2F;&#x2F;     parentRoute || matches !&#x3D; null,\n  &#x2F;&#x2F;     &#96;No routes matched location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; &#96;\n  &#x2F;&#x2F;   );\n\n  &#x2F;&#x2F;   warning(\n  &#x2F;&#x2F;     matches &#x3D;&#x3D; null ||\n  &#x2F;&#x2F;       matches[matches.length - 1].route.element !&#x3D;&#x3D; undefined,\n  &#x2F;&#x2F;     &#96;Matched leaf route at location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; does not have an element. &#96; +\n  &#x2F;&#x2F;       &#96;This means it will render an &lt;Outlet &#x2F;&gt; with a null value by default resulting in an &quot;empty&quot; page.&#96;\n  &#x2F;&#x2F;   );\n  &#x2F;&#x2F; &#125;\n\n  return _renderMatches(\n    matches &amp;&amp;\n      matches.map((match) &#x3D;&gt;\n        Object.assign(&#123;&#125;, match, &#123;\n          params: Object.assign(&#123;&#125;, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        &#125;)\n      ),\n    parentMatches\n  );\n&#125;\n\nmatchRoutes&#x2F;**\n * Matches the given routes to a location and returns the match data.\n * 将给定路由匹配到某个位置并返回匹配数据。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;match-routes\n *&#x2F;\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial&lt;Location&gt; | string,\n  basename &#x3D; &quot;&#x2F;&quot;\n): RouteMatch[] | null &#123;\n  let location &#x3D;\n    typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;\n\n  let pathname &#x3D; stripBasename(location.pathname || &quot;&#x2F;&quot;, basename);\n\n  if (pathname &#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n\n  let branches &#x3D; flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches &#x3D; null;\n  for (let i &#x3D; 0; matches &#x3D;&#x3D; null &amp;&amp; i &lt; branches.length; ++i) &#123;\n    matches &#x3D; matchRouteBranch(branches[i], pathname);\n  &#125;\n\n  return matches;\n&#125;\n\n_renderMatchesexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] &#x3D; []\n): React.ReactElement | null &#123;\n  if (matches &#x3D;&#x3D; null) return null;\n\n  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;\n    return (\n      &lt;RouteContext.Provider\n        children&#x3D;&#123;\n          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet\n        &#125;\n        value&#x3D;&#123;&#123;\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        &#125;&#125;\n      &#x2F;&gt;\n    );\n  &#125;, null as React.ReactElement | null);\n&#125;\n\nRouteContextinterface RouteContextObject &#123;\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n&#125;\n\nexport const RouteContext &#x3D; React.createContext&lt;RouteContextObject&gt;(&#123;\n  outlet: null,\n  matches: [],\n&#125;);\n\nif (__DEV__) &#123;\n  RouteContext.displayName &#x3D; &quot;Route&quot;;\n&#125;\n\nLinkexport interface LinkProps\n  extends Omit&lt;React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt;, &quot;href&quot;&gt; &#123;\n  &#x2F;&#x2F; 剔除 href 属性，代码中内部使用useHref(to)生成\n  reloadDocument?: boolean;\n  replace?: boolean;\n  state?: any;\n  to: To;\n&#125;\n\n&#x2F;**\n * The public API for rendering a history-aware &lt;a&gt;.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;link\n *&#x2F;\nexport const Link &#x3D; React.forwardRef&lt;HTMLAnchorElement, LinkProps&gt;(\n  function LinkWithRef(\n    &#123; onClick, reloadDocument, replace &#x3D; false, state, target, to, ...rest &#125;,\n    ref\n  ) &#123;\n    let href &#x3D; useHref(to);\n    let internalOnClick &#x3D; useLinkClickHandler(to, &#123; replace, state, target &#125;);\n    function handleClick(\n      event: React.MouseEvent&lt;HTMLAnchorElement, MouseEvent&gt;\n    ) &#123;\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented &amp;&amp; !reloadDocument) &#123;\n        internalOnClick(event);\n      &#125;\n    &#125;\n\n    return (\n      &#x2F;&#x2F; eslint-disable-next-line jsx-a11y&#x2F;anchor-has-content\n      &lt;a\n        &#123;...rest&#125;\n        href&#x3D;&#123;href&#125;\n        onClick&#x3D;&#123;handleClick&#125;\n        ref&#x3D;&#123;ref&#125;\n        target&#x3D;&#123;target&#125;\n      &#x2F;&gt;\n    );\n  &#125;\n);\n\nuseHref&#x2F;**\n * Returns the full href for the given &quot;to&quot; value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n * 返回给定“to”值的完整href。这对于构建也可访问并保留右键单击行为的自定义链接非常有用。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-href\n *&#x2F;\nexport function useHref(to: To): string &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useHref() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; hash, pathname, search &#125; &#x3D; useResolvedPath(to);\n\n  let joinedPathname &#x3D; pathname;\n  if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n    let toPathname &#x3D; getToPathname(to);\n    let endsWithSlash &#x3D; toPathname !&#x3D; null &amp;&amp; toPathname.endsWith(&quot;&#x2F;&quot;);\n    joinedPathname &#x3D;\n      pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n        ? basename + (endsWithSlash ? &quot;&#x2F;&quot; : &quot;&quot;)\n        : joinPaths([basename, pathname]);\n  &#125;\n\n  return navigator.createHref(&#123; pathname: joinedPathname, search, hash &#125;);\n&#125;\n\nuseLinkClickHandleruseLinkClickHandler\n&#x2F;**\n * Handles the click behavior for router &#96;&lt;Link&gt;&#96; components. This is useful if\n * you need to create custom &#96;&lt;Link&gt;&#96; components with the same click behavior we\n * use in our exported &#96;&lt;Link&gt;&#96;.\n * 处理&#96;&lt;Link&gt;&#96;组件的单击行为。如果\n * 您需要创建具有与我们相同的单击行为的自定义&#96;&lt;Link&gt;&#96;组件\n * 在导出的&#96;&lt;Link&gt;&#96;中使用。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-link-click-handler\n *&#x2F;\nexport function useLinkClickHandler&lt;E extends Element &#x3D; HTMLAnchorElement&gt;(\n  to: To,\n  &#123;\n    target,\n    replace: replaceProp,\n    state,\n  &#125;: &#123;\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n  &#125; &#x3D; &#123;&#125;\n): (event: React.MouseEvent&lt;E, MouseEvent&gt;) &#x3D;&gt; void &#123;\n  let navigate &#x3D; useNavigate();\n  let location &#x3D; useLocation();\n  let path &#x3D; useResolvedPath(to);\n\n  return React.useCallback(\n    (event: React.MouseEvent&lt;E, MouseEvent&gt;) &#x3D;&gt; &#123;\n      if (\n        event.button &#x3D;&#x3D;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; Ignore everything but left clicks\n        (!target || target &#x3D;&#x3D;&#x3D; &quot;_self&quot;) &amp;&amp; &#x2F;&#x2F; Let browser handle &quot;target&#x3D;_blank&quot; etc.\n        !isModifiedEvent(event) &#x2F;&#x2F; Ignore clicks with modifier keys\n      ) &#123;\n        event.preventDefault();\n\n        &#x2F;&#x2F; If the URL hasn&#39;t changed, a regular &lt;a&gt; will do a replace instead of\n        &#x2F;&#x2F; a push, so do the same here.\n        &#x2F;&#x2F; url没有改变，做replace操作，而不是push操作\n        let replace &#x3D;\n          !!replaceProp || createPath(location) &#x3D;&#x3D;&#x3D; createPath(path);\n\n        navigate(to, &#123; replace, state &#125;);\n      &#125;\n    &#125;,\n    [location, navigate, path, replaceProp, state, target, to]\n  );\n&#125;\n\nuseNavigate&#x2F;**\n * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but\n * may also be used by other elements to change the location.\n * 返回更改位置的命令式方法。由s使用，但\n * 也可由其他元素用于更改位置。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate\n *&#x2F;\nexport function useNavigate(): NavigateFunction &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  let activeRef &#x3D; React.useRef(false);\n  React.useEffect(() &#x3D;&gt; &#123;\n    activeRef.current &#x3D; true;\n  &#125;);\n\n  let navigate: NavigateFunction &#x3D; React.useCallback(\n    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n      warning(\n        activeRef.current,\n        &#96;You should call navigate() in a React.useEffect(), not when &#96; +\n          &#96;your component is first rendered.&#96;\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n        navigator.go(to);\n        return;\n      &#125;\n\n      let path &#x3D; resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        path.pathname &#x3D; joinPaths([basename, path.pathname]);\n      &#125;\n      &#x2F;&#x2F; 这行代码写法，没见过，函数执行\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    &#125;,\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n&#125;\n\nresolveToexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path &#123;\n  let to &#x3D; typeof toArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(toArg) : toArg;\n  let toPathname &#x3D; toArg &#x3D;&#x3D;&#x3D; &quot;&quot; || to.pathname &#x3D;&#x3D;&#x3D; &quot;&quot; ? &quot;&#x2F;&quot; : to.pathname;\n\n  &#x2F;&#x2F; If a pathname is explicitly provided in &#96;to&#96;, it should be relative to the\n  &#x2F;&#x2F; route context. This is explained in &#96;Note on &#96;&lt;Link to&gt;&#96; values&#96; in our\n  &#x2F;&#x2F; migration guide from v5 as a means of disambiguation between &#96;to&#96; values\n  &#x2F;&#x2F; that begin with &#96;&#x2F;&#96; and those that do not. However, this is problematic for\n  &#x2F;&#x2F; &#96;to&#96; values that do not provide a pathname. &#96;to&#96; can simply be a search or\n  &#x2F;&#x2F; hash string, in which case we should assume that the navigation is relative\n  &#x2F;&#x2F; to the current location&#39;s pathname and *not* the route pathname.\n  &#x2F;&#x2F; 如果在“to”中显式提供了路径名，则它应该相对于路由上下文。这在我们的v5迁移指南中的“关于&#96;&lt;Link&gt;&#96;值&#39;的注释”中有解释，\n  &#x2F;&#x2F; 作为消除以&#96;&#x2F;&#96;开头的&#96;到&#96;值与不以&#96;&#x2F;&#96;开头的&#96;到&#96;值之间歧义的一种方法。但是，对于不提供路径名的“to”值来说，\n  &#x2F;&#x2F; 这是有问题的&#96;to &#96;可以是一个搜索或哈希字符串，在这种情况下，我们应该假设导航相对于当前位置的路径名，而不是路径名。\n\n  let from: string;\n  if (toPathname &#x3D;&#x3D; null) &#123;\n    from &#x3D; locationPathname;\n  &#125; else &#123;\n    let routePathnameIndex &#x3D; routePathnames.length - 1;\n\n    if (toPathname.startsWith(&quot;..&quot;)) &#123;\n      let toSegments &#x3D; toPathname.split(&quot;&#x2F;&quot;);\n\n      &#x2F;&#x2F; Each leading .. segment means &quot;go up one route&quot; instead of &quot;go up one\n      &#x2F;&#x2F; URL segment&quot;.  This is a key difference from how &lt;a href&gt; works and a\n      &#x2F;&#x2F; major reason we call this a &quot;to&quot; value instead of a &quot;href&quot;.\n      while (toSegments[0] &#x3D;&#x3D;&#x3D; &quot;..&quot;) &#123;\n        toSegments.shift();\n        routePathnameIndex -&#x3D; 1;\n      &#125;\n\n      to.pathname &#x3D; toSegments.join(&quot;&#x2F;&quot;);\n    &#125;\n\n    &#x2F;&#x2F; If there are more &quot;..&quot; segments than parent routes, resolve relative to\n    &#x2F;&#x2F; the root &#x2F; URL.\n    from &#x3D; routePathnameIndex &gt;&#x3D; 0 ? routePathnames[routePathnameIndex] : &quot;&#x2F;&quot;;\n  &#125;\n\n  let path &#x3D; resolvePath(to, from);\n\n  &#x2F;&#x2F; Ensure the pathname has a trailing slash if the original to value had one.\n  &#x2F;&#x2F; 如果原始to值有斜杠，请确保路径名后面有斜杠。\n  if (\n    toPathname &amp;&amp;\n    toPathname !&#x3D;&#x3D; &quot;&#x2F;&quot; &amp;&amp;\n    toPathname.endsWith(&quot;&#x2F;&quot;) &amp;&amp;\n    !path.pathname.endsWith(&quot;&#x2F;&quot;)\n  ) &#123;\n    path.pathname +&#x3D; &quot;&#x2F;&quot;;\n  &#125;\n\n  return path;\n&#125;\n\nuseInRouterContext判断是否在某个 React.createContext 的上下文\nexport function useInRouterContext(): boolean &#123;\n  return React.useContext(LocationContext) !&#x3D; null;\n&#125;\n\n&#x2F;&#x2F; invariant(\n&#x2F;&#x2F;   useInRouterContext(),\n&#x2F;&#x2F;   &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n&#x2F;&#x2F;   &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n&#x2F;&#x2F;   &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n&#x2F;&#x2F; );\n\n\n\n以上部分，是如何生成路由的源码部分。有个问题，路由生成出来了，如何进行配对渲染？走的太快了，回去看下\n&#x2F;&#x2F; 这块代码我们上面有看过的\n\n&#x2F;&#x2F; BrowserRouter\nReact.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);\n&#x2F;&#x2F;  history.listen(setState) 去找下history的api\n&#x2F;&#x2F; @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;blob&#x2F;dev&#x2F;docs&#x2F;api-reference.md#historylistenlistener-listener\nreturn (\n  &lt;Router &#x2F;&#x2F; react-router &quot;.&#x2F;lib&#x2F;components&quot;\n    basename&#x3D;&#123;basename&#125;\n    children&#x3D;&#123;children&#125;\n    location&#x3D;&#123;state.location&#125;\n    navigationType&#x3D;&#123;state.action&#125;\n    navigator&#x3D;&#123;history&#125;\n  &#x2F;&gt;\n);\n\n&#x2F;&#x2F; 直接在这里堆积下，上文是有的\n\nlet &#123;\n  pathname &#x3D; &quot;&#x2F;&quot;,\n  search &#x3D; &quot;&quot;,\n  hash &#x3D; &quot;&quot;,\n  state &#x3D; null,\n  key &#x3D; &quot;default&quot;,\n&#125; &#x3D; locationProp;\n\n&lt;LocationContext.Provider &#x2F;&#x2F; 一般情况这里会单独抽取 LocationContext, 并写成useLocationContext\n  children&#x3D;&#123;children&#125; &#x2F;&#x2F; 是这种以属性形式写入的，不是在标签中包裹的， 即example&#x2F;basic &lt;App &#x2F;&gt;\n  value&#x3D;&#123;&#123; location, navigationType &#125;&#125;\n&#x2F;&gt;;\n\n文档内容\ninterface Listener &#123;\n  (update: Update): void;\n&#125;\n\ninterface Update &#123;\n  action: Action;\n  location: Location; &#x2F;&#x2F; 由 Location,结合Router\n&#125;\n\nLocation 类型&#x2F;**\n * A URL pathname, beginning with a &#x2F;.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n *&#x2F;\nexport type Pathname &#x3D; string;\n\n&#x2F;**\n * A URL search string, beginning with a ?.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n *&#x2F;\nexport type Search &#x3D; string;\n\n&#x2F;**\n * The pathname, search, and hash values of a URL.\n *&#x2F;\nexport interface Path &#123;\n  &#x2F;**\n   * A URL pathname, beginning with a &#x2F;.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n   *&#x2F;\n  pathname: Pathname;\n\n  &#x2F;**\n   * A URL search string, beginning with a ?.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n   *&#x2F;\n  search: Search;\n\n  &#x2F;**\n   * A URL fragment identifier, beginning with a #.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash\n   *&#x2F;\n  hash: Hash;\n&#125;\n\n&#x2F;**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location\n *&#x2F;\nexport interface Location extends Path &#123;\n  &#x2F;**\n   * A value of arbitrary data associated with this location.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.state\n   *&#x2F;\n  state: unknown;\n\n  &#x2F;**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like &#96;localStorage&#96;.\n   *\n   * Note: This value is always &quot;default&quot; on the initial location.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.key\n   *&#x2F;\n  key: Key;\n&#125;\n\nhistory&#x2F;index.ts 源码&#x2F;**\n * A function that receives notifications about location changes.\n *&#x2F;\nexport interface Listener &#123;\n  (update: Update): void;\n&#125;\n\nStarts listening for location changes and calls the given callback with an Update when it does.开始侦听位置更改，并在更改时使用更新调用给定回调。\n阶段性总结BrowserRouter + App.tsx（Routes、Route 生成路由组件关系）\nBrowserRouter：内部 history 监听路由变化，将 location 进行结构，并使用 useMemo 进行环境，传递给 LocationContext.Provider 的 value，驱动子组件 children 渲染，代码 1\nLocationContext.Provider 子组件 &#x3D; 也就是 BrowserRouter 的子组件 &#x3D; App.tsx， 内部，获取 locationFromContext，进行匹配渲染 代码 2（见下述堆积代码「上文以贴过源码，再贴一遍」）\n这里要注意下：useRoutes TOC 写法，最终应该是\n代码 2&#x2F;**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you&#39;re using this it may mean you&#39;re doing some of your own\n * &quot;routing&quot; in your app, and we&#39;d like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-location\n *&#x2F;\nexport function useLocation(): Location &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useLocation() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  return React.useContext(LocationContext).location;\n&#125;\n\n&#x2F;&#x2F; hooks.ts useRoutes中\n\nlet locationFromContext &#x3D; useLocation(); &#x2F;&#x2F; 这里\n\nlet location;\nif (locationArg) &#123;\n  let parsedLocationArg &#x3D;\n    typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;\n\n  invariant(\n    parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ||\n      parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n    &#96;When overriding the location using \\&#96;&lt;Routes location&gt;\\&#96; or \\&#96;useRoutes(routes, location)\\&#96;, &#96; +\n      &#96;the location pathname must begin with the portion of the URL pathname that was &#96; +\n      &#96;matched by all parent routes. The current pathname base is &quot;$&#123;parentPathnameBase&#125;&quot; &#96; +\n      &#96;but pathname &quot;$&#123;parsedLocationArg.pathname&#125;&quot; was given in the \\&#96;location\\&#96; prop.&#96;\n  );\n\n  location &#x3D; parsedLocationArg;\n&#125; else &#123;\n  location &#x3D; locationFromContext; &#x2F;&#x2F; 这里\n&#125;\n\nlet pathname &#x3D; location.pathname || &quot;&#x2F;&quot;;\nlet remainingPathname &#x3D;\n  parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n    ? pathname\n    : pathname.slice(parentPathnameBase.length) || &quot;&#x2F;&quot;;\nlet matches &#x3D; matchRoutes(routes, &#123; pathname: remainingPathname &#125;);\n&#x2F;&#x2F; 开发提醒 跳过\n&#x2F;&#x2F; if (__DEV__) &#123;\n&#x2F;&#x2F;   warning(\n&#x2F;&#x2F;     parentRoute || matches !&#x3D; null,\n&#x2F;&#x2F;     &#96;No routes matched location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; &#96;\n&#x2F;&#x2F;   );\n\n&#x2F;&#x2F;   warning(\n&#x2F;&#x2F;     matches &#x3D;&#x3D; null || matches[matches.length - 1].route.element !&#x3D;&#x3D; undefined,\n&#x2F;&#x2F;     &#96;Matched leaf route at location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; does not have an element. &#96; +\n&#x2F;&#x2F;       &#96;This means it will render an &lt;Outlet &#x2F;&gt; with a null value by default resulting in an &quot;empty&quot; page.&#96;\n&#x2F;&#x2F;   );\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; 渲染\nreturn _renderMatches(\n  matches &amp;&amp;\n    matches.map((match) &#x3D;&gt;\n      Object.assign(&#123;&#125;, match, &#123;\n        params: Object.assign(&#123;&#125;, parentParams, match.params),\n        pathname: joinPaths([parentPathnameBase, match.pathname]),\n        pathnameBase:\n          match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n            ? parentPathnameBase\n            : joinPaths([parentPathnameBase, match.pathnameBase]),\n      &#125;)\n    ),\n  parentMatches\n);\n\n&#x2F;&#x2F; _renderMatches\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] &#x3D; []\n): React.ReactElement | null &#123;\n  if (matches &#x3D;&#x3D; null) return null;\n  &#x2F;&#x2F; 这是一个递归 reduceRight，与reduce类似，不过reduceRight是从右到左\n  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;\n    return (\n      &lt;RouteContext.Provider &#x2F;&#x2F; 需要看下 RouteContext在什么地方使用的，为什要看它，因为这个Context距离渲染组件的chilren最近，看他是如何驱动组件更新的【element、outlet】\n        children&#x3D;&#123;\n          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet\n        &#125;\n        value&#x3D;&#123;&#123;\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        &#125;&#125;\n      &#x2F;&gt;\n    );\n  &#125;, null as React.ReactElement | null);\n&#125;\n\nRouteContext 在源码中的使用\nuseNavigate\nuseOutlet\nuseParams\nuseResolvedPath\nuseRoutes\n\nuseNavigate&#x2F;**\n * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but\n * may also be used by other elements to change the location.\n * 返回更改位置的命令式方法。由&lt;Link&gt;s使用，但也可由其他元素用于更改位置。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate\n *&#x2F;\nexport function useNavigate(): NavigateFunction &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  let activeRef &#x3D; React.useRef(false);\n  React.useEffect(() &#x3D;&gt; &#123;\n    activeRef.current &#x3D; true;\n  &#125;);\n\n  let navigate: NavigateFunction &#x3D; React.useCallback(\n    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n      warning(\n        activeRef.current,\n        &#96;You should call navigate() in a React.useEffect(), not when &#96; +\n          &#96;your component is first rendered.&#96;\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n        navigator.go(to);\n        return;\n      &#125;\n\n      let path &#x3D; resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        path.pathname &#x3D; joinPaths([basename, path.pathname]);\n      &#125;\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    &#125;,\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n&#125;\n\n&#x2F;**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by &lt;Outlet&gt; to render child routes.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-outlet\n *&#x2F;\nexport function useOutlet(context?: unknown): React.ReactElement | null &#123;\n  let outlet &#x3D; React.useContext(RouteContext).outlet; &#x2F;&#x2F; 这里\n  if (outlet) &#123;\n    return (\n      &lt;OutletContext.Provider value&#x3D;&#123;context&#125;&gt;&#123;outlet&#125;&lt;&#x2F;OutletContext.Provider&gt;\n    );\n  &#125;\n  return outlet;\n&#125;\n\nexport function useParams&lt;\n  ParamsOrKey extends string | Record&lt;string, string | undefined&gt; &#x3D; string\n&gt;(): Readonly&lt;\n  [ParamsOrKey] extends [string] ? Params&lt;ParamsOrKey&gt; : Partial&lt;ParamsOrKey&gt;\n&gt; &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);&#x2F;&#x2F; 这里\n  let routeMatch &#x3D; matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : &#123;&#125;;\n&#125;\n\n&#x2F;**\n * Resolves the pathname of the given &#96;to&#96; value against the current location.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;api#useresolvedpath\n *&#x2F;\nexport function useResolvedPath(to: To): Path &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () &#x3D;&gt; resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n&#125;\n\n&#x2F;**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an &lt;Outlet&gt; to render their child route&#39;s\n * element.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-routes\n *&#x2F;\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial&lt;Location&gt; | string\n): React.ReactElement | null &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useRoutes() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; matches: parentMatches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里\n  let routeMatch &#x3D; parentMatches[parentMatches.length - 1];\n  let parentParams &#x3D; routeMatch ? routeMatch.params : &#123;&#125;;\n  let parentPathname &#x3D; routeMatch ? routeMatch.pathname : &quot;&#x2F;&quot;;\n  let parentPathnameBase &#x3D; routeMatch ? routeMatch.pathnameBase : &quot;&#x2F;&quot;;\n  let parentRoute &#x3D; routeMatch &amp;&amp; routeMatch.route;\n\n\n最终发现，又回到 useRoutes，也确实是在尾部调用 TOC,如下抽取部分代码片段\n代码 2&#x2F;&#x2F; 1 useRoutes尾部调用\nlet locationFromContext &#x3D; useLocation(); &#x2F;&#x2F; 这里\nreturn _renderMatches(\n  matches &amp;&amp;\n    matches.map((match) &#x3D;&gt;\n      Object.assign(&#123;&#125;, match, &#123;\n        params: Object.assign(&#123;&#125;, parentParams, match.params),\n        pathname: joinPaths([parentPathnameBase, match.pathname]),\n        pathnameBase:\n          match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;\n            ? parentPathnameBase\n            : joinPaths([parentPathnameBase, match.pathnameBase]),\n      &#125;)\n    ),\n  parentMatches\n);\n\n&#x2F;&#x2F; 2\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] &#x3D; []\n): React.ReactElement | null &#123;\n  if (matches &#x3D;&#x3D; null) return null;\n  &#x2F;&#x2F; 这是一个递归 reduceRight，与reduce类似，不过reduceRight是从右到左\n  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;\n    return (\n      &lt;RouteContext.Provider &#x2F;&#x2F; 需要看下 RouteContext在什么地方使用的，为什要看它，因为这个Context距离渲染组件的chilren最近，看他是如何驱动组件更新的【element、outlet】\n        children&#x3D;&#123;\n          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet &#x2F;&#x2F; 这里的return相当于将 上述1的代码全部塞在RouteContext.Provider中  注意：因为react.context只能在对应的provider中使用\n          &#x2F;&#x2F; 这里拿了 Route的element的属性（组件渲染）据说，Route的形式有好多种，下面看看去\n        &#125;\n        value&#x3D;&#123;&#123;\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        &#125;&#125;\n      &#x2F;&gt;\n    );\n  &#125;, null as React.ReactElement | null);\n&#125;\n\nRoute&#x2F;**\n * Declares an element that should be rendered at a certain URL path.\n * 声明在某个URL路径渲染的元素\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;route\n *&#x2F;\nexport function Route( &#x2F;&#x2F; 这个看上去就一个函数声明，啥都没有\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null &#123;\n  invariant(\n    false,\n    &#96;A &lt;Route&gt; is only ever to be used as the child of &lt;Routes&gt; element, &#96; +\n      &#96;never rendered directly. Please wrap your &lt;Route&gt; in a &lt;Routes&gt;.&#96;\n  );\n&#125;\n\ncreateRoutesFromChildren&#x2F;**\n * Creates a route config from a React &quot;children&quot; object, which is usually\n * either a &#96;&lt;Route&gt;&#96; element or an array of them. Used internally by\n * &#96;&lt;Routes&gt;&#96; to create a route config from its children.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;create-routes-from-children\n *&#x2F;\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] &#123;\n  let routes: RouteObject[] &#x3D; [];\n\n  React.Children.forEach(children, (element) &#x3D;&gt; &#123;\n    if (!React.isValidElement(element)) &#123;\n      &#x2F;&#x2F; 不是react组件返回undefined,结束\n      &#x2F;&#x2F; Ignore non-elements. This allows people to more easily inline\n      &#x2F;&#x2F; conditionals in their route config.\n      return;\n    &#125;\n\n    if (element.type &#x3D;&#x3D;&#x3D; React.Fragment) &#123;\n      &#x2F;&#x2F; React.Fragment\n      &#x2F;&#x2F; Transparently support React.Fragment and its children.\n      &#x2F;&#x2F; 支持React.Fragment及其子级。\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    &#125;\n\n    invariant(\n      element.type &#x3D;&#x3D;&#x3D; Route,\n      &#96;[$&#123;\n        typeof element.type &#x3D;&#x3D;&#x3D; &quot;string&quot; ? element.type : element.type.name\n      &#125;] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;&#96;\n    );\n\n    let route: RouteObject &#x3D; &#123;\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element, &#x2F;&#x2F; 这里直接把组件给了route，上面   match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet  渲染时候渲染就是它\n      index: element.props.index,\n      path: element.props.path,\n    &#125;;\n\n    if (element.props.children) &#123;\n      &#x2F;&#x2F; 有children\n      route.children &#x3D; createRoutesFromChildren(element.props.children);\n    &#125;\n\n    routes.push(route);\n  &#125;);\n\n  return routes;\n&#125;\n\n至此我们了解到了，react-router 监听，渲染整个过程\n余下的勾子\nuseNavigate\nuseOutlet\nuseParams\nuseResolvedPath\n\nuseNavigate独立功能块，提供 navigate 用于跳转两个参数，第一个参数接受数字和路径\n&#x2F;**\n * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but\n * may also be used by other elements to change the location.\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate\n *&#x2F;\nexport function useNavigate(): NavigateFunction &#123;\n  invariant(\n    useInRouterContext(),\n    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the\n    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.\n    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;\n  );\n\n  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  let activeRef &#x3D; React.useRef(false);\n  React.useEffect(() &#x3D;&gt; &#123;\n    activeRef.current &#x3D; true;\n  &#125;);\n\n  &#x2F;&#x2F; 声明一个函数\n  let navigate: NavigateFunction &#x3D; React.useCallback(\n    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n      warning(\n        activeRef.current,\n        &#96;You should call navigate() in a React.useEffect(), not when &#96; +\n          &#96;your component is first rendered.&#96;\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n        &#x2F;&#x2F; 支持数字\n        navigator.go(to);\n        return;\n      &#125;\n\n      let path &#x3D; resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;\n        path.pathname &#x3D; joinPaths([basename, path.pathname]);\n      &#125;\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path, &#x2F;&#x2F; 支持路径跳转\n        options.state\n      );\n    &#125;,\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n  &#x2F;&#x2F; 返回这个函数\n  return navigate;\n&#125;\n\nuseOutlet&#x2F;**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by &lt;Outlet&gt; to render child routes.\n * 返回路由层次结构此级别的子路由的元素。由&lt;Outlet&gt;内部使用以渲染子路由。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-outlet\n *&#x2F;\nexport function useOutlet(context?: unknown): React.ReactElement | null &#123;\n  let outlet &#x3D; React.useContext(RouteContext).outlet;\n  if (outlet) &#123;\n    return (\n      &lt;OutletContext.Provider value&#x3D;&#123;context&#125;&gt;&#123;outlet&#125;&lt;&#x2F;OutletContext.Provider&gt;\n    );\n  &#125;\n  return outlet;\n&#125;\n\n&#x2F;&#x2F; 使用\n\n&#x2F;**\n * Renders the child route&#39;s element, if there is one.\n * 渲染子路由的元素（如果有）。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;outlet\n *&#x2F;\nexport function Outlet(props: OutletProps): React.ReactElement | null &#123;\n  return useOutlet(props.context);\n&#125;\n\nuseParams&#x2F;**\n * Returns an object of key&#x2F;value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n * 返回由路由路径匹配的当前URL中的动态参数的键&#x2F;值对组成的对象。\n *\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-params\n *&#x2F;\nexport function useParams&lt;\n  ParamsOrKey extends string | Record&lt;string, string | undefined&gt; &#x3D; string\n&gt;(): Readonly&lt;\n  [ParamsOrKey] extends [string] ? Params&lt;ParamsOrKey&gt; : Partial&lt;ParamsOrKey&gt;\n&gt; &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let routeMatch &#x3D; matches[matches.length - 1];\n  &#x2F;&#x2F; 最后一个就是当前页面对应参数：怎么理解\n  &#x2F;&#x2F; 1. push情况，最后一个是当前页面\n  &#x2F;&#x2F; 2. replace情况，最后一个是当前页面\n  &#x2F;&#x2F; 3. pop 返回情况，最后一个是当前页面\n\n  &#x2F;&#x2F; 所以最后一个就是当前页面\n  return routeMatch ? (routeMatch.params as any) : &#123;&#125;;\n&#125;\n\nuseResolvedPath具体使用见\n&#x2F;**\n * Resolves the pathname of the given &#96;to&#96; value against the current location.\n * 根据当前位置解析给定“to”值的路径名。\n * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;api#useresolvedpath\n *&#x2F;\nexport function useResolvedPath(to: To): Path &#123;\n  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);\n  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();\n\n  let routePathnamesJson &#x3D; JSON.stringify(\n    matches.map((match) &#x3D;&gt; match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () &#x3D;&gt; resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n&#125;\n\n&#x2F;&#x2F; Path\n\nexport interface Path &#123;\n  &#x2F;**\n   * A URL pathname, beginning with a &#x2F;.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n   *&#x2F;\n  pathname: Pathname;\n\n  &#x2F;**\n   * A URL search string, beginning with a ?.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n   *&#x2F;\n  search: Search;\n\n  &#x2F;**\n   * A URL fragment identifier, beginning with a #.\n   *\n   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash\n   *&#x2F;\n  hash: Hash;\n&#125;\n\n&#x2F;**\n * A URL pathname, beginning with a &#x2F;.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname\n *&#x2F;\nexport type Pathname &#x3D; string;\n\n&#x2F;**\n * A URL search string, beginning with a ?.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search\n *&#x2F;\nexport type Search &#x3D; string;\n\n&#x2F;**\n * A URL fragment identifier, beginning with a #.\n *\n * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash\n *&#x2F;\nexport type Hash &#x3D; string;\n\n参考链接fork 的 react-router 代码「源码解析 」这一次彻底弄懂 react-router 路由原理React Router 教程\n","slug":"2022-06-21react-router-code","date":"2022-06-21T01:06:50.000Z","categories_index":"React","tags_index":"源码,react-router","author_index":"举手摘月亮"},{"id":"3d2993e7928f66556e52e3c255cfa133","title":"react-router v6.4.0 主要概念","content":"官网React Router v6 is Here\n\n\n\n\n\n\n\n\n\nReact Router v6 在客户端路由十年的基础上，采用了以前版本及其姐妹项目 Reach Router 的最佳功能，采用了迄今为止最小和最强大的软件包。\n\n\n\n\n\n\nTIP\n或许某一天，再见时，已不是 v6\n\n官网分为两块内容 核心概念 实践指导,本章内容主要是主要概念\nYou might be wondering what exactly React Router does. How can it help you build your app? What exactly is a router, anyway?你可能会感到困惑，什么是路由？如何构建你的应用？什么是一个路由？。。。If you’ve ever had any of these questions, or you’d just like to dig into the fundamental pieces of routing, you’re in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router.如果你有过这些问题，或者你想要深入了解路由的核心概念，你就在正确的位置了。本文档包含了 React Router 的实现中所有核心概念的详细解释。\nPlease don’t let this document overwhelm you! For everyday use, React Router is pretty simple. You don’t need to go this deep to use it.请不要让这份文档击败你！对于每日使用，React Router 是非常简单的。你不需要去深入到这里来使用它。\nReact Router isn’t just about matching a url to a function or component: it’s about building a full user interface that maps to the URL, so it might have more concepts in it than you’re used to. We’ll go into detail on the three main jobs of React Router:React Router 不仅仅是匹配一个 url 到一个函数或组件：它是构建一个完整的用户界面，它可能有更多概念在里面，你可能不会感到。我们将从三个主要的工作中去解释 React Router：\n\nSubscribing and manipulating the history stack 订阅和操作历史堆栈\nMatching the URL to your routes 匹配 URL 到你的路由\nRendering a nested UI from the route matches 在路由匹配中渲染嵌套的 UI\n\nDefinitions定义\nBut first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.首先，有一些定义！有很多不同的理念在路由的后端和前端框架。有时一个单词在一个上下文中可能有不同的意思。\nHere are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.这里有一些我们经常使用的词汇，React Router 的其他部分将会以每个词汇为题来讲述。\nURL - The URL in the address bar. A lot of people use the term “URL” and “route” interchangeably, but this is not a route in React Router, it’s just a URL.URL - 地址栏中的 URL。很多人使用“URL”和“路由”可交换使用，但这不是 React Router 的路由，它只是一个 URL。\nLocation - This is a React Router specific object that is based on the built-in browser’s window.location object. It represents “where the user is at”. It’s mostly an object representation of the URL but has a bit more to it than that.位置- 这是一个基于浏览器的 window.location 对象的React Router特定对象。它表示“用户在哪里”。它主要是一个对 URL 的对象表示，但有更多的事情。\nLocation State - A value that persists with a location that isn’t encoded in the URL. Much like hash or search params (data encoded in the URL), but stored invisibly in the browser’s memory.位置状态 - 一个值，在不在 URL 中编码的位置保持。类似于哈希或搜索参数（在 URL 中编码的数据），但存储在浏览器的内存中。\nHistory Stack - As the user navigates, the browser keeps track of each location in a stack. If you click and hold the back button in a browser you can see the browser’s history stack right there.历史堆栈 - 当用户导航时，浏览器会记录每个位置在一个堆栈中。如果你点击并保持后退按钮在浏览器，你可以看到浏览器的历史堆栈在那里。\nClient Side Routing (CSR) - A plain HTML document can link to other documents and the browser handles the history stack itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.客户端端路由 (CSR) - 只需要一个 HTML 文档，可以链接到其他文档，浏览器会自己处理历史堆栈。客户端端路由使开发人员能够操作浏览器历史堆栈，而不需要请求文档。\nHistory - An object that allows React Router to subscribe to changes in the URL as well as providing APIs to manipulate the browser history stack programmatically.历史 - 一个对象，允许 React Router 订阅 URL 的变化，同时提供一个 API，用于手动操作浏览器历史堆栈。\nHistory Action - One of POP, PUSH, or REPLACE. Users can arrive at a URL for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.历史动作 - POP、PUSH 或 REPLACE 之一。用户可以到达这三个原因的 URL。一个 push 当添加一个新条目到历史堆栈时（通常是链接点击或程序员强制导航）。一个 replace 类似，但它替换当前条目而不是添加一个新的。最后，一个 pop 发生在用户点击浏览器窗口的后退或前进按钮。\nSegment - The parts of a URL or path pattern between the &#x2F; characters. For example, “&#x2F;users&#x2F;123” has two segments.分段 - URL 或路径模式中的 &#x2F; 字符之间的部分。例如，”&#x2F;users&#x2F;123” 有两个分段。\nPath Pattern - These look like URLs but can have special characters for matching URLs to routes, like dynamic segments (“&#x2F;users&#x2F;:userId”) or star segments (“&#x2F;docs&#x2F;*“). They aren’t URLs, they’re patterns that React Router will match.路径模式 - 这样看起来像 URL，但它们可以包含特殊字符来匹配 URL 到路由，例如动态分段 (“&#x2F;users&#x2F;:userId”) 或星号分段 (“&#x2F;docs&#x2F;*“)。它们不是 URL，它们是 React Router 将匹配的模式。\nDynamic Segment - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern &#x2F;users&#x2F;:userId will match URLs like &#x2F;users&#x2F;123动态分段 - 路径模式中的一个分段，它可以匹配分段中的任何值。例如，路径模式 &#x2F;users&#x2F;:userId 将匹配 URL 类似 &#x2F;users&#x2F;123\nURL Params - The parsed values from the URL that matched a dynamic segment.URL 参数 - 从 URL 中解析出的值。\nRouter - Stateful, top-level component that makes all the other components and hooks work.路由 - 一个状态为组件，用于让所有其他组件和钩子工作。\nRoute Config - A tree of routes objects that will be ranked and matched (with nesting) against the current location to create a branch of route matches.路由配置 - 一个路由对象的树，将会排序和匹配（包含嵌套）与当前位置来创建一个路由匹配的分支。\nRoute - An object or Route Element typically with a shape of { path, element } or . The path is a path pattern. When the path pattern matches the current URL, the element will be rendered.路由 - 一个对象或路由元素通常是 { path, element } 或 。路径是路径模式。当路径模式与当前 URL 匹配时，将会渲染该元素。\nRoute Element - Or . This element’s props are read to create a route by , but otherwise does nothing.路由元素 - 或 。这个元素的 props 被读取来创建一个路由，但是不做任何事情。\nNested Routes - Because routes can have children and each route defines a portion of the URL through segments, a single URL can match multiple routes in a nested “branch” of the tree. This enables automatic layout nesting through outlet, relative links, and more.嵌套路由 - 因为路由可以有子路由，每个路由都定义一部分 URL 的路径段，一个 URL 可以匹配多个路由在树的嵌套 “分支” 中。这使得通过 outlet、相对链接和更多的功能来实现布局嵌套。\nRelative links - Links that don’t start with &#x2F; will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.相对链接 - 不以 &#x2F; 开头的链接会继承最近渲染的路由。这使得它很容易链接到更深的 URL，而不需要知道和建立整个路径。\nMatch - An object that holds information when a route matches the URL, like the url params and pathname that matched.匹配 - 当路由匹配 URL 时，匹配信息会保存在这个对象中，例如匹配的 URL 参数和路径名。\nMatches - An array of routes (or branch of the route config) that matches the current location. This structure enables nested routes.匹配 - 当前位置匹配的路由（或路由配置的分支）的数组。这个结构可以嵌套路由。\nParent Route - A route with child routes.父路由 - 有子路由的路由。\nOutlet - A component that renders the next match in a set of matches.啥玩意？出口 - 一个组件，它渲染一组匹配中的下一个匹配。\nIndex Route - A child route with no path that renders in the parent’s outlet at the parent’s URL.首页路由 - 一个子路由，没有路径，它渲染在父路由的出口，在父路由的 URL 中。\nLayout Route - A parent route without a path, used exclusively for grouping child routes inside a specific layout.布局路由 - 一个没有路径的父路由，用于将子路由分组在特定布局中。\nHistory and LocationsBefore React Router can do anything, it has to be able to subscribe to changes in the browser history stack.在 React Router 可以做任何事情之前，它需要能够订阅浏览器历史堆栈的变化。\nBrowsers maintain their own history stack as the user navigates around. That’s how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.在一个纯粹的网站（没有 JavaScript 的 HTML 文档）中，浏览器会每次点击链接、提交表单或点击后退和前进按钮时，都会向服务器发送请求。\nFor example, consider the user:例如，考虑用户：\n\nclicks a link to &#x2F;dashboard\nclicks a link to &#x2F;accounts\nclicks a link to &#x2F;customers&#x2F;123\nclicks the back button\nclicks a link to &#x2F;dashboard\n\nThe history stack will change as follows where bold entries denote the current URL:如下的地方历史堆栈将改变，加粗的条目表示当前 URL：\n\n&#x2F;dashboard\n&#x2F;dashboard, &#x2F;accounts\n&#x2F;dashboard, &#x2F;accounts**, &#x2F;customers&#x2F;123**\n&#x2F;dashboard, &#x2F;accounts, &#x2F;customers&#x2F;123\n&#x2F;dashboard, &#x2F;accounts, &#x2F;dashboard\n\nHistory ObjectWith client side routing, developers are able to manipulate the browser history stack programmatically. For example, we can write some code like this to change the URL without the browsers default behavior of making a request to the server:使用客户端路由，开发人员可以通过编程方式改变浏览器历史堆栈，例如，我们可以这样写，改变 URL，而不会执行浏览器的默认行为，即向服务器发送请求：\n&lt;a\n  href&#x3D;&quot;&#x2F;contact&quot;\n  onClick&#x3D;&#123;(event) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; stop the browser from changing the URL and requesting the new document\n    &#x2F;&#x2F; 阻止浏览器改变 URL 并请求新文档\n    event.preventDefault();\n    &#x2F;&#x2F; push an entry into the browser history stack and change the URL\n    &#x2F;&#x2F; 将一个条目推入浏览器历史堆栈并改变 URL\n    window.history.pushState(&#123;&#125;, undefined, &quot;&#x2F;contact&quot;);\n  &#125;&#125;\n&#x2F;&gt;\n\n\n\n\n\n\n\n\nWARNING\nFor illustration only, don’t use window.history.pushState directly in React Router仅供参考，不要使用 window.history.pushState 直接在 React Router 中使用\n\nThis code changes the URL but doesn’t do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn’t give us a way to “listen to the URL” and subscribe to changes like this.这段代码改变 URL 但不会对 UI 有任何影响。我们需要写一些代码，改变某些状态，使 UI 变为联系页面。问题是，浏览器没有提供这样的方式，“监听 URL”，订阅变化。\nWell, that’s not totally true. We can listen for changes to the URL via pop events:这不是完全正确的。我们可以监听 URL 变化的事件，通过弹出事件：\nwindow.addEventListener(&quot;popstate&quot;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; URL changed!\n&#125;);\n\nBut that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called window.history.pushState or window.history.replaceState.但是，只有当用户点击后退或前进按钮时，才会触发这个事件。没有调用 window.history.pushState 或 window.history.replaceState 的事件。That’s where a React Router specific history object comes into play. It provides a way to “listen for URL” changes whether the history action is push, pop, or replace.这里是 React Router 特定的历史对象的事件。它提供一种方式，“监听 URL”变化，无论历史操作是 push、pop 或 replace。\nlet history &#x3D; createBrowserHistory();\nhistory.listen((&#123; location, action &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; this is called whenever new locations come in\n  &#x2F;&#x2F; the action is POP, PUSH, or REPLACE\n&#125;);\n\nApps don’t need to set up their own history objects–that’s job of . It sets up one of these objects, subscribe to changes in the history stack, and finally updates its state when the URL changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a location, everything else works from that single object.应用不需要设置自己的历史对象，这是 &lt;Router&gt; 的工作。它设置一个这样的对象，订阅历史堆栈的变化，并且最终更新它的状态，当 URL 变化时。这会导致应用重新渲染并显示正确的 UI。它只需要把状态放在状态中，其他都可以从这个单一对象中获取。\nLocationsThe browser has a location object on window.location. It tells you information about the URL but also has some methods to change it:浏览器有一个 location 对象在 window.location 上。它告诉你关于 URL 的信息，但也有一些方法可以改变它：\nwindow.location.pathname; &#x2F;&#x2F; &#x2F;getting-started&#x2F;concepts&#x2F;\nwindow.location.hash; &#x2F;&#x2F; #location\nwindow.location.reload(); &#x2F;&#x2F; force a refresh w&#x2F; the server\n&#x2F;&#x2F; and a lot more\n\n\n\n\n\n\n\n\nWARNING\nFor illustration. You don’t typically work with window.location in a React Router app在 React Router 应用中通常不使用 window.location\n\nInstead of using window.location, React Router has the concept of a location that’s patterned after window.location but is much simpler. It looks like this:而不是使用 window.location，React Router 有一个像 window.location 一样的location，但更简单。它看起来像这样：\n&#123;\n  &quot;pathname&quot;: &quot;&#x2F;bbq&#x2F;pig-pickins&quot;,\n  &quot;search&quot;: &quot;?campaign&#x3D;instagram&quot;,\n  &quot;hash&quot;: &quot;#menu&quot;,\n  &quot;state&quot;: null,\n  &quot;key&quot;: &quot;aefz24ie&quot;\n&#125;\n\nThe first three: { pathname, search, hash } are exactly like window.location. If you just add up the three you’ll get the URL the user sees in the browser:前三个：{ pathname, search, hash } 相当于 window.location。如果把三个加起来就等于用户在浏览器中看到的 URL：\nlocation.pathname + location.search + location.hash;\n&#x2F;&#x2F; &#x2F;bbq&#x2F;pig-pickins?campaign&#x3D;instagram#menu\n\nThe last two, { state, key }, are React Router specific.最后两个，{ state, key }，是 React Router 特定的。\nLocation Pathname\nThis is the part of URL after the origin, so for https://example.com/teams/hotspurs the pathname is &#x2F;teams&#x2F;hotspurs. This is the only part of the location that routes match against.这是 URL 的部分，在 origin 之后，所以 https://example.com/teams/hotspurs 的 pathname 是 &#x2F;teams&#x2F;hotspurs。这是 location 的唯一部分，它匹配路由。\nLocation Search\nPeople use a lot of different terms for this part of the URL:人们使用很多不同的词来表达这部分 URL：\n\nlocation search\nsearch params\nURL search params\nquery string\n\nIn React Router we call it the “location search”. However, location search is a serialized version of URLSearchParams. So sometimes we might call it “URL search params” as well.在 React Router 中我们称它为 “location search”。但是，location search 是一个序列化的 URLSearchParams 的版本。所以有时候我们可能称它 “URL search params”。\n&#x2F;&#x2F; given a location like this:\nlet location &#x3D; &#123;\n  pathname: &quot;&#x2F;bbq&#x2F;pig-pickins&quot;,\n  search: &quot;?campaign&#x3D;instagram&amp;popular&#x3D;true&quot;,\n  hash: &quot;&quot;,\n  state: null,\n  key: &quot;aefz24ie&quot;,\n&#125;;\n\n&#x2F;&#x2F; we can turn the location.search into URLSearchParams\n&#x2F;&#x2F; 我们可以把 location.search 转换成 URLSearchParams\nlet params &#x3D; new URLSearchParams(location.search);\nparams.get(&quot;campaign&quot;); &#x2F;&#x2F; &quot;instagram&quot;\nparams.get(&quot;popular&quot;); &#x2F;&#x2F; &quot;true&quot;\nparams.toString(); &#x2F;&#x2F; &quot;campaign&#x3D;instagram&amp;popular&#x3D;true&quot;,\n\nWhen being precise, refer to the serialized string version as “search” and the parsed version as “search params”, but it’s common to use the terms interchangeably when precision isn’t important.当精确时，参考序列化的字符串版本为 “search”，解析版本为 “search params”，但是通常使用时可以使用交换的词来表达。\nLocation Hash\nHashes in URLs indicate a scroll position on the current page. Before the window.history.pushState API was introduced, web developers did client side routing exclusively with the hash portion of the URL, it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.URL 中的 hash 可以表示当前页面的滚动位置。在 window.history.pushState API 尚未引入前，web 开发者只能在 URL 中的 hash 部分进行客户端路由，它是我们只能在不需要请求服务器的情况下操作它。但是，现在我们可以用它来实现它的提供的功能。\nLocation State\nYou may have wondered why the window.history.pushState() API is called “push state”. State? Aren’t we just changing the URL? Shouldn’t it be history.push? Well, we weren’t in the room when the API was designed, so we’re not sure why “state” was the focus, but it is a cool feature of browsers nonetheless.你可能会问为什么 window.history.pushState() API 被称为 “push state”。状态？我们不是改变 URL 吗？应该不是 history.push？我们不是在房间里面，所以我们不知道为什么 “state” 是焦点，但是它是浏览器的一个酷功能。Browsers let us persist information about a transition by passing a value to pushState. When the user clicks back, the value on history.state changes to whatever was “pushed” before.浏览器让我们保持一个过渡的信息，通过传递一个值来 pushState。当用户点击后，history.state 将变成什么时候 “pushed”。\n\nwindow.history.pushState(&quot;look ma!&quot;, undefined, &quot;&#x2F;contact&quot;);\nwindow.history.state; &#x2F;&#x2F; &quot;look ma!&quot;\n&#x2F;&#x2F; user clicks back\nwindow.history.state; &#x2F;&#x2F; undefined\n&#x2F;&#x2F; user clicks forward\nwindow.history.state; &#x2F;&#x2F; &quot;look ma!&quot;\n\n\n\n\n\n\n\n\n\n\nWARNING\nFor illustration. You don’t read history.state directly in React Router apps为了演示。你不要直接读取 history.state 在 React Router 应用中。\n\nReact Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the location instead of history.React Router 利用这个浏览器功能，抽象它点，而不是把值放在 history 上。\nYou can think about location.state just like location.hash or location.search except instead of putting the values in the URL it’s hidden–like a super secret piece of the URL only the programmer knows about.你可以想象 location.state 像 location.hash 或 location.search，只不过它放在 URL 中是隐藏的–只有程序员知道的秘密。\nA couple of great use-cases for location state are:一些好的使用场景是 location state：\nTelling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).如果用户点击一个 item 在 grid 视图，那么我们可以在 modal 中显示记录，但如果用户直接访问 URL，那么我们可以在它的自己的布局中显示记录（pinterest，旧 instagram）。\nSending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.从列表发送一个部分记录到下一个屏幕，以便它可以立即渲染部分数据，然后再次获取其余的数据。\nYou set location state in two ways: on  or navigate:你可以在  或 navigate 中设置 location state：\n&lt;Link to&#x3D;&quot;&#x2F;pins&#x2F;123&quot; state&#x3D;&#123;&#123; fromDashboard: true &#125;&#125; &#x2F;&gt;;\n\nlet navigate &#x3D; useNavigate();\nnavigate(&quot;&#x2F;users&#x2F;123&quot;, &#123; state: partialUser &#125;);\n\nAnd on the next page you can access it with useLocation:在下一个页面中，你可以使用 useLocation 来访问它：\nlet location &#x3D; useLocation();\nlocation.state;\n\nLocation state values will get serialized, so something like new Date() will be turned into a string.Location state 值将会被序列化，所以 something like new Date() 将会被转换成字符串。\nLocation Key\nEach location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, new Map(), or even locationStorage.每个 location 可以获得一个唯一的 key。这是一个高级的情况，比如 location-based scroll management，客户端数据缓存，以及更多。因为每个新的 location 可以获得一个唯一的 key，所以你可以把信息存储在一个普通对象，new Map()，或者 locationStorage。\nFor example, a very basic client side data cache could store values by location key (and the fetch URL) and skip fetching the data when the user clicks back into it:例如，一个非常基础的客户端数据缓存可以通过 location key（和 fetch URL）来存储值，并且当用户点击回到它时跳过 fetch 数据：\nlet cache &#x3D; new Map();\n\nfunction useFakeFetch(URL) &#123;\n  let location &#x3D; useLocation();\n  let cacheKey &#x3D; location.key + URL;\n  let cached &#x3D; cache.get(cacheKey);\n\n  let [data, setData] &#x3D; useState(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; initialize from the cache\n    return cached || null;\n  &#125;);\n\n  let [state, setState] &#x3D; useState(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; avoid the fetch if cached\n    return cached ? &quot;done&quot; : &quot;loading&quot;;\n  &#125;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (state &#x3D;&#x3D;&#x3D; &quot;loading&quot;) &#123;\n      let controller &#x3D; new AbortController();\n      fetch(URL, &#123; signal: controller.signal &#125;)\n        .then((res) &#x3D;&gt; res.json())\n        .then((data) &#x3D;&gt; &#123;\n          if (controller.signal.aborted) return;\n          &#x2F;&#x2F; set the cache\n          cache.set(cacheKey, data);\n          setData(data);\n        &#125;);\n      return () &#x3D;&gt; controller.abort();\n    &#125;\n  &#125;, [state, cacheKey]);\n\n  useEffect(() &#x3D;&gt; &#123;\n    setState(&quot;loading&quot;);\n  &#125;, [URL]);\n\n  return data;\n&#125;\n\nMatchingOn the initial render, and when the history stack changes, React Router will match the location against your route config to come up with a set of matches to render.在初始渲染和当 history stack 变化时，React Router 将会匹配 location 与你的路由配置来得到一组匹配来渲染。\nDefining RoutesA route config is a tree of routes that looks something like this:一个路由配置是一个树状结构，比如这样：\n&lt;Routes&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;\n    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Route&gt;\n  &lt;&#x2F;Route&gt;\n  &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;\n  &lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;&#x2F;Routes&gt;\n\nThe &lt;Routes&gt; component recurses through its props.children, strips their props, and generates an object like this: 组件递归遍历其 props.children，并且生成一个像这样的对象：\nlet routes &#x3D; [\n  &#123;\n    element: &lt;App &#x2F;&gt;,\n    path: &quot;&#x2F;&quot;,\n    children: [\n      &#123;\n        index: true,\n        element: &lt;Home &#x2F;&gt;,\n      &#125;,\n      &#123;\n        path: &quot;teams&quot;,\n        element: &lt;Teams &#x2F;&gt;,\n        children: [\n          &#123;\n            index: true,\n            element: &lt;LeagueStandings &#x2F;&gt;,\n          &#125;,\n          &#123;\n            path: &quot;:teamId&quot;,\n            element: &lt;Team &#x2F;&gt;,\n          &#125;,\n          &#123;\n            path: &quot;:teamId&#x2F;edit&quot;,\n            element: &lt;EditTeam &#x2F;&gt;,\n          &#125;,\n          &#123;\n            path: &quot;new&quot;,\n            element: &lt;NewTeamForm &#x2F;&gt;,\n          &#125;,\n        ],\n      &#125;,\n    ],\n  &#125;,\n  &#123;\n    element: &lt;PageLayout &#x2F;&gt;,\n    children: [\n      &#123;\n        element: &lt;Privacy &#x2F;&gt;,\n        path: &quot;&#x2F;privacy&quot;,\n      &#125;,\n      &#123;\n        element: &lt;Tos &#x2F;&gt;,\n        path: &quot;&#x2F;tos&quot;,\n      &#125;,\n    ],\n  &#125;,\n  &#123;\n    element: &lt;Contact &#x2F;&gt;,\n    path: &quot;&#x2F;contact-us&quot;,\n  &#125;,\n];\n\nIn fact, instead of  you can use the hook useRoutes(routesGoHere) instead. That’s all  is doing.在实际上， 的作用是，把 routesGoHere 传递给 useRoutes。\nAs you can see, routes can define multiple segments like :teamId&#x2F;edit, or just one like :teamId. All of the segments down a branch of the route config are added together to create a final path pattern for a route.你可以看到，路由可以定义多个分段，比如 :teamId&#x2F;edit，或者只有一个 :teamId。所有从路由配置的分支下面的分段都会组合在一起，来创建一个最终的路径模式。\nMatch ParamsNote the :teamId segments. This is what we call a dynamic segment of the path pattern, meaning it doesn’t match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for :teamId. Both &#x2F;teams&#x2F;123 or &#x2F;teams&#x2F;cupcakes will match. We call the parsed values URL params. So in this case our teamId param would be “123” or “cupcakes”. We’ll see how to use them in your app in the Rendering section.注意，这里有 :teamId 分段。这是一个动态分段，意味着它不是静态的，而是动态的。任何值都可以填充 :teamId。&#x2F;teams&#x2F;123 或 &#x2F;teams&#x2F;cupcakes 均可匹配。我们称这些解析后的值为 URL 参数。所以，在这种情况下，我们的 teamId 参数将是 “123” 或 “cupcakes”。我们会在渲染部分看到如何使用它们。\nRanking RoutesIf we add up all the segments of all the branches of our route config, we end up with the following path patterns that our app responds to:如果我们把所有路由配置的分支的所有分段相加，我们就会得到以下路径模式，我们的应用程序会响应：\n[\n  &quot;&#x2F;&quot;,\n  &quot;&#x2F;teams&quot;,\n  &quot;&#x2F;teams&#x2F;:teamId&quot;,\n  &quot;&#x2F;teams&#x2F;:teamId&#x2F;edit&quot;,\n  &quot;&#x2F;teams&#x2F;new&quot;,\n  &quot;&#x2F;privacy&quot;,\n  &quot;&#x2F;tos&quot;,\n  &quot;&#x2F;contact-us&quot;,\n];\n\nNow this is where things get really interesting. Consider the URL &#x2F;teams&#x2F;new. Which pattern in that list matches the URL?考虑一下这个 URL &#x2F;teams&#x2F;new，它在那个列表中匹配哪个模式？That’s right, two of them!对的，两个！\n&#x2F;teams&#x2F;new\n&#x2F;teams&#x2F;:teamId\n\nReact Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match &#x2F; and render the  component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it’s much smarter.React Router 在这里需要做一个决定，只有一个路由器，客户端和服务器端都会简单地处理模式。第一个匹配的优先。在这种情况下，我们会匹配 &#x2F; 并呈现  组件。这不是我们想要的。这种类型的路由器需要我们按照定义的顺序来排列路由，以便得到预期的结果。这是 React Router 的 v6 前的工作，现在它更加智能。\nLooking at those patterns, you intuitively know that we want &#x2F;teams&#x2F;new to match the URL &#x2F;teams&#x2F;new. It’s a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You’ll never have to think about ordering your routes.看这些模式，你感觉到我们想要 &#x2F;teams&#x2F;new 匹配 URL &#x2F;teams&#x2F;new。这是一个完美的匹配！React Router 也知道。当匹配时，它会按照分段数，静态分段，动态分段，星号模式，等等来排列路由，并选择最有用的匹配。你永远不会必须想象路由的顺序。\nPathless RoutesYou may have noticed the weird routes from earlier:你可能注意到以前的奇怪路由：\n&lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125; &#x2F;&gt;\n\nThey don’t even have a path, how can they be a route? This is where the word “route” in React Router is used pretty loosely. &lt;Home/&gt; and &lt;LeagueStandings/&gt; are index routes and &lt;PageLayout/&gt; is a layout route. We’ll discuss how they work in the Rendering section. Neither really has much to do with matching.它们也没有路径，怎么可能是路由？这是 React Router 中的“路由”词的使用很模糊。 和  是索引路由， 是布局路由。我们会在渲染部分讨论如何使用它们。 和  不是真正的路由， 是真正的路由。\nRoute MatchesWhen a route matches the URL, it’s represented by a match object. A match for &lt;Route path=&quot;:teamId&quot; element=&#123;&lt;Team/&gt;&#125;/&gt; would look something like this:\n&#123;\n  pathname: &quot;&#x2F;teams&#x2F;firebirds&quot;,\n  params: &#123;\n    teamId: &quot;firebirds&quot;\n  &#125;,\n  route: &#123;\n    element: &lt;Team &#x2F;&gt;,\n    path: &quot;:teamId&quot;\n  &#125;\n&#125;\n\npathname holds the portion of the URL that matched this route (in our case it’s all of it). params holds the parsed values from any dynamic segments that matched. Note that the param’s object keys map directly to the name of the segment: :teamId becomes params.teamId.match.pathname 存放匹配到的 URL 的部分（在我们的例子中它是全部）。params 存放从任何动态分段匹配的解析值。注意，参数的对象键映射到动态分段的名称：:teamId 变成 params.teamId。Because our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL &#x2F;teams&#x2F;firebirds, it would be the following route branch:因为我们的路由是一棵树，一个 URL 可以匹配整个树的一个分支。考虑 URL &#x2F;teams&#x2F;firebirds，它将是以下路由分支：\n&lt;Routes&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;\n    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt; &#x2F;&#x2F; +\n    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n      &#123;&quot; &quot;&#125;\n      &#x2F;&#x2F;+\n      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt; &#x2F;&#x2F;+\n      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Route&gt;\n  &lt;&#x2F;Route&gt;\n  &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;\n  &lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;&#x2F;Routes&gt;\n\nReact Router will create an array of matches from these routes and the url so it can render a nested UI that matches the route nesting.React Router 将从这些路由创建一个匹配数组，并将 url 传递给它，以便它可以渲染一个嵌套的 UI，匹配路由嵌套。\n[\n  &#123;\n    pathname: &quot;&#x2F;&quot;,\n    params: null,\n    route: &#123;\n      element: &lt;App &#x2F;&gt;,\n      path: &quot;&#x2F;&quot;,\n    &#125;,\n  &#125;,\n  &#123;\n    pathname: &quot;&#x2F;teams&quot;,\n    params: null,\n    route: &#123;\n      element: &lt;Teams &#x2F;&gt;,\n      path: &quot;teams&quot;,\n    &#125;,\n  &#125;,\n  &#123;\n    pathname: &quot;&#x2F;teams&#x2F;firebirds&quot;,\n    params: &#123;\n      teamId: &quot;firebirds&quot;,\n    &#125;,\n    route: &#123;\n      element: &lt;Team &#x2F;&gt;,\n      path: &quot;:teamId&quot;,\n    &#125;,\n  &#125;,\n];\n\nRenderingThe final concept is rendering. Consider that the entry to your app looks like this:最后一个概念是渲染。考虑你的应用程序的入口如下：\nconst root &#x3D; ReactDOM.createRoot(document.getElementById(&quot;root&quot;));\nroot.render(\n  &lt;BrowserRouter&gt;\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;\n        &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n          &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;&#x2F;Route&gt;\n      &lt;&#x2F;Route&gt;\n      &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n      &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  &lt;&#x2F;BrowserRouter&gt;\n);\n\nLet’s use the &#x2F;teams&#x2F;firebirds URL as an example again.  will match the location to your route config, get a set of matches, and then render a React element tree like this:使用 /teams/firebirds URL 作为一个例子，&lt;Routes&gt; 将匹配位置到你的路由配置，获取一组匹配，然后渲染一个 React 元素树，如下：\n&lt;App&gt;\n  &lt;Teams&gt;\n    &lt;Team &#x2F;&gt;\n  &lt;&#x2F;Teams&gt;\n&lt;&#x2F;App&gt;\n\nEach match rendered inside the parent route’s element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.每个匹配在父路由的元素中都是一个非常强大的抽象。大多数网站和应用程序都共享这种特性：盒子里面盒子里面盒子，每个盒子都有一个导航区域，它改变页面的子区域。\nOutletsThis nested element tree won’t happen automatically.  will render the first match’s element for you (In our case that’s ). The next match’s element is . In order to render that, App needs to render an outlet.这个嵌套元素树不会自动发生。&lt;Routes&gt; 将会渲染第一个匹配的元素（在我们的例子中是 &lt;App/&gt;）。下一个匹配的元素是 &lt;Teams&gt;。为了渲染这个，App 需要渲染一个出口。\nfunction App() &#123;\n  return (\n    &lt;div&gt;\n      &lt;GlobalNav &#x2F;&gt;\n      &lt;Outlet &#x2F;&gt;\n      &lt;GlobalFooter &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nThe Outlet component will always render the next match. That means  also needs an outlet to render .Outlet 元素将始终渲染下一个匹配。这意味着 &lt;Teams&gt; 需要一个出口来渲染 &lt;Team/&gt;。If the URL were &#x2F;contact-us, the element tree would change to:如果 URL 是 /contact-us，元素树会变成：\n&lt;App&gt;\n  &lt;Teams&gt;\n    &lt;EditTeam &#x2F;&gt;\n  &lt;&#x2F;Teams&gt;\n&lt;&#x2F;App&gt;\n\nThe outlet swaps out the child for the new child that matches, but the parent layout persists. It’s subtle but very effective at cleaning up your components.出口将交换子组件，但父布局仍然存在。它很巧妙，但十分有效地清理你的组件。\nIndex RoutesRemember the route config for &#x2F;teams:\n&lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n  &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n  &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;\n  &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;&#x2F;Route&gt;\n\nIf the URL were /teams/firebirds, the element tree would be:如果 URL 是 /teams/firebirds，元素树会是：\n&lt;App&gt;\n  &lt;Teams&gt;\n    &lt;Team &#x2F;&gt;\n  &lt;&#x2F;Teams&gt;\n&lt;&#x2F;App&gt;\n\nBut if the URL were /teams, the element tree would be:如果 URL 是 /teams，元素树会是：\n&lt;App&gt;\n  &lt;Teams&gt;\n    &lt;LeagueStandings &#x2F;&gt;\n  &lt;&#x2F;Teams&gt;\n&lt;&#x2F;App&gt;\n\nLeague standings? How the heck did &lt;Route index element=&#123;&lt;LeagueStandings&gt;&#125;/&gt; pop in there? It doesn’t even have a path! The reason is that it’s an index route. Index routes render in their parent route’s outlet at the parent route’s path.排名？ 为什么 &lt;Route index element=&#123;&lt;LeagueStandings&gt;&#125;/&gt; 不能出现在它的父路由的出口？ 它不是一个路径！ 原因是它是一个索引路由。 索引路由渲染在它的父路由的出口，在父路由的路径。Think of it this way, if you’re not at one of the child routes’ paths, the  will render nothing in the UI:如果你不在子路由的路径上，&lt;Outlet&gt; 将不会渲染任何 UI：\n&lt;App&gt;\n  &lt;Teams &#x2F;&gt;\n&lt;&#x2F;App&gt;\n\nIf all the teams are in a list on the left then an empty outlet means you’ve got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.如果所有成员都在左边的列表中，空的出口意味着你有一个空白页在右边！ 你的 UI 需要一些东西来填充空白：索引路由。Another way to think of an index route is that it’s the default child route when the parent matches but none of its children do.另一种思考索引路由是，它是父路由匹配，但没有任何子路由的默认子路由。Depending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you’ll most likely want index route to fill the space when the user hasn’t clicked one of the items yet.根据用户界面，你可能不需要索引路由，但如果父路由有持久的导航，你将最有可能需要索引路由来填充空白，当用户还没有点击一个项目。\nLayout RoutesHere’s a part of our route config we haven’t matched yet: /privacy. Let’s look at the route config again, highlighting the matched routes:这里是我们还没有匹配的路由配置的一部分：/privacy。我们再看一下路由配置，高亮匹配的路由：\n&lt;Routes&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;\n    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Route&gt;\n  &lt;&#x2F;Route&gt;\n  &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;\n  &lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;&#x2F;Routes&gt;\n\nAnd the resulting element tree rendered will be:根据结果，渲染出来的元素树会是：\n&lt;App&gt;\n  &lt;PageLayout&gt;\n    &lt;Privacy &#x2F;&gt;\n  &lt;&#x2F;PageLayout&gt;\n&lt;&#x2F;App&gt;\n\nThe PageLayout route is admittedly weird. We call it a layout route because it doesn’t participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn’t allow this then you’d have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:这个PageLayout路由是不友好的。 我们调用它是一个 layout route，因为它不参与匹配（但它的子路由却是）。 它只是为了让包裹多个子路由在一个布局上更加简单。 如果我们不允许这样做，那么你就需要在你的应用中手动处理布局，有时候你的路由会自动做这件事，有时候你需要手动处理布局，通过重复布局组件来实现：\n\n\n\n\n\n\nTIP\nYou can do it like this, but we recommend using a layout route你可以这样做，但我们建议使用一个布局路由\n\n&lt;Routes&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;\n    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Route&gt;\n  &lt;&#x2F;Route&gt;\n  &lt;Route\n    path&#x3D;&quot;&#x2F;privacy&quot;\n    element&#x3D;&#123;\n      &lt;PageLayout&gt;\n        &lt;Privacy &#x2F;&gt;\n      &lt;&#x2F;PageLayout&gt;\n    &#125;\n  &#x2F;&gt;\n  &lt;Route\n    path&#x3D;&quot;&#x2F;tos&quot;\n    element&#x3D;&#123;\n      &lt;PageLayout&gt;\n        &lt;Tos &#x2F;&gt;\n      &lt;&#x2F;PageLayout&gt;\n    &#125;\n  &#x2F;&gt;\n  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;&#x2F;Routes&gt;\n\nSo, yeah, the semantics of a layout “route” is a bit silly since it has nothing to do with the URL matching, but it’s just too convenient to disallow.因此，嘿，布局“路由”的语义是一点点蛋疼，因为它没有什么关系到 URL 匹配，但它是太方便了。\nNavigatingWhen the URL changes we call that a “navigation”. There are two ways to navigate in React Router:在 URL 变化时调用这个方法“navigation”：有两种方式：\n\n&lt;Link&gt;\nnavigate\n\nLinkThis is the primary means of navigation. Rendering a  allows the user to change the URL when they click it. React Router will prevent the browser’s default behavior and tell the history to push a new entry into the history stack. The location changes and the new matches will render.这是主要的导航方式，渲染一个允许用户点击它时变更 URL。 React Router 将阻止浏览器的默认行为，并告诉历史记录推入一个新条目到历史堆栈中。 地点变化了，新匹配的元素会渲染。\nHowever, links are accessible in that they:但是，链接是可访问的，它：\nStill render a &lt;a href&gt; so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)仍然渲染一个，这样所有默认的访问性问题都会被满足（如键盘，可聚焦性，SEO 等等）\nDon’t prevent the browser’s default behavior if it’s a right click or command&#x2F;control click to “open in new tab”如果是右键点击或命令&#x2F;控制点击“在新标签页中打开”，那么不要阻止浏览器的默认行为\nNested routes aren’t just about rendering layouts; they also enable “relative links”. Consider our teams route from before:嵌套路由不仅仅是渲染布局，它也可以启用“相对链接”。 考虑我们的 teams 路由从前面：\n&lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n  &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n&lt;&#x2F;Route&gt;\n\nThe  component can render links like:组件可以渲染链接，如：\n&lt;Link to&#x3D;&quot;psg&quot; &#x2F;&gt;\n&lt;Link to&#x3D;&quot;new&quot; &#x2F;&gt;\n\nThe full path it links to will be /teams/psg and /teams/new. They inherit the route within which they are rendered. This makes it so your route components don’t have to really know anything about the rest of the routes in the app. A very large amount of links just go one more segment deeper. You can rearrange your whole route config and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.它们链接到的完整路径是 /teams/psg 和 /teams/new。 它们继承渲染时的路由。 这使得你的路由组件不需要真的知道应用中的其他路由。 一大堆链接只需要一个更深一层。 你可以重新排列你的整个路由配置，这些链接可能仍然能工作。 这在开始建站时非常有用，因为设计和布局会移动。\nNavigate FunctionThis function is returned from the useNavigate hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:这个函数是由 useNavigate 钩子返回的，允许你，程序员，在你想要的时候改变 URL。 你可以做一个延迟：\nlet navigate &#x3D; useNavigate();\nuseEffect(() &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    navigate(&quot;&#x2F;logout&quot;);\n  &#125;, 30000);\n&#125;, []);\n\nOr after a form is submitted:或者，在表单提交后：\n&lt;form onSubmit&#x3D;&#123;event &#x3D;&gt; &#123;\n  event.preventDefault();\n  let data &#x3D; new FormData(event.target)\n  let urlEncoded &#x3D; new URLSearchParams(data)\n  navigate(&quot;&#x2F;create&quot;, &#123; state: urlEncoded &#125;)\n&#125;&#125;&gt;\n\n\nLike Link, navigate works with nested “to” values as well.像 Link 一样，navigate 也可以用嵌套的“to”值。\nnavigate(&quot;psg&quot;);\n\nYou should have a good reason to use navigate instead of . This makes us very sad:你应该有一个好的理由使用 navigate 而不是 。 这使我们很伤心：\n&lt;li onClick&#x3D;&#123;() &#x3D;&gt; navigate(&quot;&#x2F;somewhere&quot;)&#125; &#x2F;&gt;\n\nAside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.除了链接和表单之外，很少应该改变 URL，因为它会引入一些关于访问性和用户期望的复杂性。\nData AccessFinally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks最后，应用程序需要要求 React 路由来获取一些信息，以便建立完整的 UI。\nlet location &#x3D; useLocation();\nlet urlParams &#x3D; useParams();\nlet [urlSearchParams] &#x3D; useSearchParams();\n\nReviewLet’s put it all together from the top!从顶部一起来看！\n\nYou render your app:\n\nconst root &#x3D; ReactDOM.createRoot(document.getElementById(&quot;root&quot;));\nroot.render(\n  &lt;BrowserRouter&gt;\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;\n        &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;\n          &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;&#x2F;Route&gt;\n      &lt;&#x2F;Route&gt;\n      &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n      &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  &lt;&#x2F;BrowserRouter&gt;\n);\n\n&lt;BrowserRouter&gt; creates a history, puts the initial location in to state, and subscribes to the URL.&lt;BrowserRouter&gt; 创建一个历史，将初始位置放入状态，并订阅 URL。\n&lt;Routes&gt; recurses its child routes to build a route config, matches those routes against the location, creates some route matches, and renders the first match’s route element.&lt;Routes&gt; 递归子路由来建立路由配置，匹配这些路由与位置，创建一些路由匹配，并呈现第一个匹配的路由元素。\nYou render an  in each parent route.你在每个父路由中渲染一个 &lt;Outlet/&gt;。\nThe outlets render the next match in the route matches.路由匹配中的下一个匹配渲染。\nThe user clicks a link用户点击一个链接\nThe link calls navigate()链接调用 navigate()\nThe history changes the URL and notifies &lt;BrowserRouter&gt;.历史改变 URL，并通知 &lt;BrowserRouter&gt;。\n&lt;BrowserRouter&gt; rerenders, start over at (2)! 重新渲染，从 (2) 开始！\nThat’s it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.这就是了！我们希望这个指南有能帮助你深入理解 React 路由的主要概念。\n背景最近看到了，面试题 react-router 原理，查了下答案，内容不是很多\nReact Router 原理浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理\nReact Router 源码解析\n之前没看过实现原理，现在看到也没那么难 从小被吓大的， 带着好奇心看下仓库代码：4+1（index.ts）个文件没看错\n\n\nindex.ts&#x2F;&#x2F; 暴露出的api\nexport &#123;\n  MemoryRouter,\n  Navigate,\n  NavigationType,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  createPath,\n  createRoutesFromChildren,\n  generatePath,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  renderMatches,\n  resolvePath,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigate,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n&#125;;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; DANGER! PLEASE READ ME! 危险！请读这个！\n&#x2F;&#x2F; We provide these exports as an escape hatch in the event that you need any\n&#x2F;&#x2F; routing data that we don&#39;t provide an explicit API for. With that said, we\n&#x2F;&#x2F; want to cover your use case if we can, so if you feel the need to use these\n&#x2F;&#x2F; we want to hear from you. Let us know what you&#39;re building and we&#39;ll do our\n&#x2F;&#x2F; best to make sure we can support you!\n&#x2F;&#x2F; 我们提供这些导出作为一个逃逸引用，以防你需要我们没有提供明确 API 的任何路由数据。也就是说，\n&#x2F;&#x2F; 如果你需要这些，我们希望能够为你提供支持，所以如果你有需要，请告诉我们你的需求，我们会尽可能地为你提供支持。\n&#x2F;&#x2F; We consider these exports an implementation detail and do not guarantee\n&#x2F;&#x2F; against any breaking changes, regardless of the semver release. Use with\n&#x2F;&#x2F; extreme caution and only if you understand the consequences. Godspeed.\n&#x2F;&#x2F; 我们考虑这些导出是一个实现细节，并且不保证对任何变更不会有任何影响，无论是在 semver 版本发布前或者后。\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\nreact-router-dom\n\n\n\n\n\n\n\n\n对react-router进行了扩展，\n","slug":"2022-06-21react-router","date":"2022-06-21T01:06:50.000Z","categories_index":"React","tags_index":"react-router","author_index":"举手摘月亮"},{"id":"99460a2013287be2d51642da6dd169f8","title":"面试题汇总","content":"\n\n小红书前端面经\n前端两年经验，历时一个月的面经和总结\n【面试题】CSS 知识点整理(附答案)\nHTTP 与 TCPHTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 对 HTTP 的改进\nTCP 三次握手\nTCP 四次挥手\nTCP 重传机制\n流量控制\nHTTP 请求和 TCP 链接的对应关系\n彻底搞懂进程与线程之间的联系\nTLS&#x2F;SSL\nTLS&#x2F;SSL\nCDN\nwebsocket 面试题\nwebsocket 使用\n状态码的含义\n101 SwitchingProtocols，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议\n204 状态码的含义\n206 partial Content, 进行范围请求，打开 B 站的视频可以看到 206 请求\n身份信息JWT 史上最全面试题(大厂常问) -->\n\nJWT\n单站点登录\nES6总结 ES6 中 Map 和 Set 的特点与比较\n从 async&#x2F;await 面试题看宏观任务和微观任务\n箭头函数和普通函数的区别\njsjs 堆和栈的区别什么是闭包tail 调用:尾调用优化（Tail Call Optimization，TCO）\nPromise 实现原理数据劫持 ……^_^\n\n\nnew 和 Object.create 都是创造一个对象的意思，二者有啥区别呢？\nnew &#x2F; Object.create()的实现原理\n\n用 Object.create()方法创建新对象,并使用现有对象提供新对象的 proto。\nObject.create() 是 es5 组合继承的 es6 api\nObject.create 克隆的对象也只能实现一级对象的深拷贝\n使用：创建子对象，让子对象继承父对象的同时，为子对象添加自有属性\n\nfunction myNew() &#123;\n  let obj &#x3D; &#123;&#125;;\n\n  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数\n\n  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型\n\n  var result &#x3D; func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数\n\n  return  result intanceof Object ? result :  obj;\n&#125;\n\n\n\nfunction myCreate(obj) &#123;\n  let F &#x3D; function () &#123;&#125;;\n  F.prototype &#x3D; obj;\n  return new F();\n&#125;\n\n  \n  \n对着图看\n\n\n\n\n浏览器 强缓存、协商缓存发生在 8 中的哪些阶段\n泄漏JavaScript 内存泄漏防范之道\n\n意外的全局变量：全局变量一直处于可访问状态，不会被 GC 回收\n闭包：函数作用域变量在函数执行完后会被清理，前提是在函数外部没有引用它\n定时器： 在 setTimeout 或 setInterval 的回调函数中引用某些对象\n事件监听器：活动的事件监听器会阻止作用域内的变量被 GC 回收\n缓存： 持续不断地往缓存里增加数据，没有定时清除无用的对象，也没有限制缓存大小，那么缓存就会像滚雪球一样越来越大\n分离的 DOM 元素：如果 DOM 节点被 JavaScript 代码直接引用，即使从 DOM 树分离，也不会被 GC 回收\n\nhtmlHTML 如何禁用缓存\n&lt;meta\n  http-equiv&#x3D;&quot;Cache-Control&quot;\n  content&#x3D;&quot;no-cache, no-store, must-revalidate&quot;\n&#x2F;&gt;\n&lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot; &#x2F;&gt;\n&lt;meta http-equiv&#x3D;&quot;Expires&quot; content&#x3D;&quot;0&quot; &#x2F;&gt;\n\nonload、DOMContentLoaded 区别\n\nonload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了.\nDOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片(譬如如果有 async 加载的脚本就不一定完成)\n\n&#x2F;&#x2F; onload\nwindow.onload &#x3D; function () &#123;\n  var span &#x3D; document.querySelector(&quot;span&quot;);\n  console.log(span, &quot;onload&quot;);\n&#125;;\n&#x2F;&#x2F; DOMConetentLoaded\ndocument.addEventListener(&quot;DOMConetentLoaded&quot;, function () &#123;\n  var span &#x3D; document.querySelector(&quot;span&quot;);\n  console.log(span, &quot;DOMConetentLoaded&quot;);\n&#125;);\n\nCSS3BFCBFC 与清除浮动根节点、浮动、定位[]、display[相关]、表格、网格、多列，总之是把一些子元素圈起来形成封闭的盒子，践行 BFC 的原则[独立、对外不影响（不重叠）]\n.clearfix::after(清除浮动)中各个属性及值详细解说\n单行多行文字截断css 中实现单行多行文字截断\n&#x2F;* 单行 *&#x2F;\ndiv &#123;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n&#125;\n\ndiv &#123;\n  display: -webkit-box;\n  overflow: hidden;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2; &#x2F;* 最多2行，2行装不下就用...省略 *&#x2F;\n&#125;\n\ncss-modulescss module\n原理: 开启了 css module 后，css-loader 会将样式中的类名进行转换，转换为一个唯一的 hash 值。\nflexflex 布局\n0.5px怎么画一条 0.5px 的边（更新）\n总结伪类与伪元素总结伪类与伪元素\n\n\n  \n\n  \n\n\n:first-child :first-of-type :nth-child :nth-of-type 区别\n\n:first-child 匹配元素的第一个子元素。\n\n:first-of-type 匹配属于其父元素的首个特定类型的子元素的每个元素。\n\n:nth-child  根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素示例如下：1n+0，或 n，匹配每一个子元素。2n+0，或 2n，匹配位置为 2、4、6、8… 的子元素，该表达式与关键字 even 等价。2n+1 匹配位置为 1、3、5、7… 的子元素、该表达式与关键字 odd 等价。3n+4 匹配位置为 4、7、10、13… 的子元素。:nth-of-type\n\n:nth-of-type 与 nth-child 相似，不同之处在于它是只匹配特定类型的元素。\n\n\npositionposition 的几个属性和含义\nstatic该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。\nrelative\n该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。\nposition:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。\n\nabsolute\n元素会被移出正常文档流，并不为元素预留空间，\n通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。\n绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。\n\nfixed\n元素会被移出正常文档流，并不为元素预留空间，\n而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。\n打印时，元素会出现在的每页的固定位置。\nfixed 属性会创建新的层叠上下文。\n并非永远以视口进行定位 当元素祖先的 transform、perspective、filter 或 backdrop-filter 属性非 none 时，容器由视口改为该祖先。\n\nsticky\n元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block（最近块级祖先 nearest block-level ancestor），包括 table-related 元素，基于 top、right、bottom 和 left 的值进行偏移。\n偏移值不会影响任何其他元素的位置。\n该值总是创建一个新的层叠上下文（stacking context）。\n注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见 Github issue on W3C CSSWG）\n\n说一下盒模型&gt;_&lt;\nvertical-align 到底怎么用\n六种常用的 css 三栏布局方法\n响应式前端响应式布局原理与方案（详细版）\n对于需要保持宽高比的图，应该用 padding-top 实现(一种为了解决，图片未加载出来，高度为 0 加载完后，有了内容发生跳变的现象)\n1 物理像素线\n算法刷算法\n前端面试之手写代码\n安全防盗刷怎么实现接口防刷怎么实现接口防刷\n两种情况\n\n恶意访问：使用工具进行不停的循环访问，占用系统资源，影响系统正常的对外服务\n支付接口、发短信接口等： 这种接口直接会导致企业的损失，更要注意。\n\n应对措施：\n\n限制访问的频率：每访问一次就给这个 IP+1，比如限制 1w 次，加到 1W 次就拒绝访问，直到过期，这种方式简单粗暴，对于恶意攻击、爬虫抓取很有效果，但难免会有误伤，影响正常的访问请求。\n人机校验，验证码\n限制发送频率：验证码发送频率 1 次&#x2F;分钟\n后端逻辑验证：避免重放攻击。如：已处理的订单不重复处理，增加时间戳，对于过期的请求不再进行处理\n接口访问监控：ip 访问频率异常，如果达到一定数量，进行系统报警，通知管理员，以降低损失\n\nvuecomputed 与 watch 的区别\n\n功能上：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。\n是否调用 缓存：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。\n是否调用 return：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。\n初次计算 computed 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）\n使用场景：\ncomputed—-当一个属性受多个属性影响的时候，使用 computed—–购物车商品结算。\nwatch–当一条数据影响多条数据的时候，使用 watch—–搜索框.\n\n\n\nreactReact Router 原理React Router 原理浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理React Router 源码解析\n合成事件机制React 合成事件机制web 前端培训 React 合成事件原理解析\nReact 事件机制 – 合成事件\n\n原生事件当某个元素触发某个事件（如 onclick ），顶层对象 Document 就会发出一个事件流，随着 DOM 树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。\n事件目标当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。\n事件冒泡从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。\n事件委托&#x2F;事件代理\n简单理解就是将一个响应事件委托到另一个元素。\n当子节点被点击时，click 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。\n\n\n合成事件与原生事件区别\n事件名称命名方式不同\n事件处理函数写法不同\n阻止默认行为方式不同\n\n\nReact 合成事件与原生事件执行顺序 react 父级 => react 子级 => 父级原生 => 子级原生`\n  冒泡：`document \n阻止冒泡\n原生: 使用 e.stopPropagation() 或者 e.cancelBubble=true（IE）来阻止\nreact 中，阻止冒泡的方式有三种：\n阻止合成事件与非合成事件（除了 document）之间的冒泡，以上两种方式都不适用，需要用到 e.target 判断。\n阻止合成事件与最外层 document 上的事件间的冒泡，用 e.nativeEvent.stopImmediatePropagation();\n阻止合成事件间的冒泡，用 e.stopPropagation();\n\n\n\n阻止事件冒泡\n\n\n\n\n\nTIP\nreact 阻止事件冒泡\n\ne.stopPropagation用来阻止 React 模拟的事件冒泡\ne.stopImmediatePropagation 没这个函数\ne.nativeEvent.stopPropagation 原生事件对象的用于阻止 DOM 事件的进一步捕获或者冒泡\ne.nativeEvent.stopImmediatePropagation 原生事件对象用于阻止 dom 事件的进一步捕获或者冒泡，且该元素的后续绑定相同事件类型的事件，都会被阻止\n\n\n\nsetStatesetState 返回一样的引用，render 会执行吗\nuseEffectuseEffect 的使用方法？useEffect 的 return 会在什么时候执行？useEffect 原理是什么？\nPureComponent 和 Component 的区别PureComponent 和 Component 的区别是什么？ \n区别\n1、和 Component 的一个最大的区别在于 PureComponent 会自动执行 shouldComponentUpdate 函数，通过 shallowEqual 的浅对比，实现 react 的性能优化。而 Component 必须要通过自己去调用生命周期函数 shouldComponentUpdate 来实现 react 组件的优化。\n2、PureComponent 不仅会影响本身，而且会影响子组件，所以 PureComponent 最佳情况是展示组件\n（1）父子组件都是继承 Component 那么就是只要有更新，那么都会去重新渲染\n（2）父组件是继承 Component，而子组件是继承 PureComponent 那么就是看各自的 props 和 state\n（3）父子组件均继承 PureComponent，父子组件的更新就会依赖各自的 props 和 state\n（4）父组件继承 PureComponent,子组件是继承 Component，那么如果当父组件的 props 或者是 state 没有变化, 而子组件的 props 或者 state 有变化，那么此时子组件也不会有更新，因为子组件受到父组件的影响，父组件没有更新。\n3、如果是数组和对象等引用类型，则要引用不同，才会渲染\n4、如果 prop 和 state 每次都会变，那么 PureComponent 的效率还不如 Component，因为进行浅比较也是需要时间\n5、如果有 shouldComponentUpdate，则执行它，若没有这个方法会判断是不是 PureComponent，若是，进行浅比较\ndiff单节点 Diff单节点 diff\n多节点 Diff第一轮遍历\n第二轮遍历\n手动实现 useEffectReact Hook：手动实现 useEffect\n&#x2F;&#x2F; 用来存储每次调用useEffect时传入的依赖数组\nlet prevDepsAry &#x3D; [];\n&#x2F;&#x2F; 用索引记录每个回调函数对应的依赖数组\nlet effectIndex &#x3D; 0;\n\nfunction useEffect(callback, depsAry) &#123;\n  &#x2F;&#x2F; 先判断参数类型是否正确\n  &#x2F;&#x2F; 如果callback不是函数类型，直接报错\n  if (Object.prototype.toString.call(callback) !&#x3D;&#x3D; &quot;[object Function]&quot;)\n    throw new Error(&#96;$&#123;callback&#125; 必须是一个函数类型&#96;);\n  &#x2F;&#x2F; 判断依赖数组有没有传入\n  if (depsAry &#x3D;&#x3D;&#x3D; undefined) &#123;\n    &#x2F;&#x2F; 没传入则每次函数重新调用都要执行回调函数\n    callback();\n  &#125; else &#123;\n    &#x2F;&#x2F; 判断depsAry是否是一个数组类型，如果不是，直接报错\n    if (Object.prototype.toString.call(depsAry) !&#x3D;&#x3D; &quot;[object Array]&quot;)\n      throw new Error(&#96;$&#123;depsAry&#125; 必须是一个数组类型&#96;);\n    &#x2F;&#x2F; 是数组类型，则需要获取上一次的依赖数组，逐项对比是否发生改变\n    let prevDeps &#x3D; prevDepsAry[effectIndex];\n    &#x2F;&#x2F; 判断是否发生改变，判断prevDeps是否存在\n    const hasChanged &#x3D; prevDeps\n      ? depsAry.every((dep, index) &#x3D;&gt; dep &#x3D;&#x3D;&#x3D; prevDeps[index]) &#x3D;&#x3D;&#x3D; false\n      : true;\n    if (hasChanged) &#123;\n      &#x2F;&#x2F; 有依赖发生改变，调用callback\n      callback();\n    &#125;\n    &#x2F;&#x2F; 同步本次更改后的依赖数组\n    prevDepsAry[effectIndex] &#x3D; depsAry;\n    effectIndex++;\n  &#125;\n&#125;\n\n手动实现 useStateReact Hook: 手动实现 useState\n&#x2F;&#x2F; 存储状态的数组\nlet state &#x3D; [];\n&#x2F;&#x2F; 存储更改状态方法的数组\nlet setters &#x3D; [];\n&#x2F;&#x2F; 用来记录状态和更改状态方法对应关系的下标\nlet stateIndex &#x3D; 0;\n\nfunction createSetter(index) &#123;\n  return function (newState) &#123;\n    state[index] &#x3D; newState;\n    render();\n  &#125;;\n&#125;\n\nfunction useState(initialState) &#123;\n  state[stateIndex] &#x3D; state[stateIndex] ? state[stateIndex] : initialState;\n  &#x2F;&#x2F; 采用闭包缓存每个state对应的setState\n  setters.push(createSetter(stateIndex));\n  const value &#x3D; state[stateIndex];\n  const setter &#x3D; setters[stateIndex];\n  &#x2F;&#x2F; 每创建完一组都要+1，用来作为下一组状态的索引\n  stateIndex++;\n  return [value, setter];\n&#125;\n\n⽣命周期react 生命周期图谱\n\n\n\n\n -->\n\nContext 原理Context 原理\n\nProvider 传递流程：Provider 的更新，会 深度遍历子代 fiber，消费 context 的 fiber 和父级链都会 提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。\nContext 订阅流程： contextType ， useContext， Consumer 会内部调用 readContext ，readContext 会把 fiber 上的 dependencies 属性 和 context 对象 建立起关联。\n\nHooks 的实现原理Hooks 的实现原理\n类组件和纯函数组件的区别类组件和纯函数组件的区别\n\n函数式编程，面向对象编程角度来说\n回到组件上，react hook 产生的原因 角度来说\n组件状态复用艰难，\n让人无奈的 this 问题，\n高阶组件和函数组件的嵌套层次太深，\n复杂组件变得难以理解，\n以及难以记忆的生命周期等问题很让人头大\n\n\n\nReact dom 绑定事件和原生事件React dom 绑定事件和原生事件有什么区别\nuseState 的源码解析useState 的源码解析\n什么是 Virtual DOM？Virtual DOM 是一种编程概念。在这个概念里， UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫做协调\n什么是 “React Fiber”？Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染\n稳操胜券看完这篇文章保你面试稳操胜券 ——（必考题）javaScript 篇\n看完这篇文章保你面试稳操胜券——基础篇（html&#x2F;css)\n看完这篇文章保你面试稳操胜券-vue 篇\n读完这篇保你面试稳操胜券——前端面试题“骨灰级”总结\nwebpackWebpack | TreeShaking 工作原理什么是 tree-shakingWebpack 优化——将你的构建效率提速翻倍\nWebpack 揭秘——走向高阶前端的必经之路\nwebpack（四）——webpack 里面的 plugin 和 loader 的区别\n跟着源码了解 Webpack 编译流程\n说一下对 tree-shaking 的了解，对 CommonJS 和 ESM 都可以用 tree-shaking 吗\n编写一个 loader\n编写一个插件\nWebpack5 的事件流和插件机制\npx2rem-loader[9], 或者 pxrem-loader[10]原理 ^_^\nWebpack 4 教程 - 第四部分，使用 SplitChunksPlugin 分离代码\nWebpack 4 教程 - 第七部分 减少打包体积与 Tree Shaking\n优化 Webpack 构建性能的几点建议\n\n```js\n{\n  体积小： 合适的 source-map、减少代码体积、 webpack-bundle-analyzer进行分析\n  范围小：目录检索范围、检索路径\n  缓存：开启 loader、plugin 缓存\n  不重复打包：DLLPlugin + DLLRefrencePlugin 、 externals\n}\n``` -->\n\n常见 loader 使用 , 不好看，有乱七八糟图片，img 样式设置 display: none;\n\n文件相关：\nJSON 相关：\nJS&#x2F;TS 转译:\n模版：\n样式：\nlint 校验：\n测试：\n框架：\n\n性能网站性能优化实战——从 12.67s 到 1.06s 的故事\n浏览器首屏优化-首屏时间获取\n博客推荐几何心凉\n","slug":"2022-06-16interview","date":"2022-06-16T02:00:46.000Z","categories_index":"面试","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"5b104c45df830a680c682d4e4b65c048","title":"http错误信息","content":"http 错误信息Request URL: http:&#x2F;&#x2F;localhost:8888&#x2F;api&#x2F;redline&#x2F;content_management&#x2F;api&#x2F;kbs&#x2F;search&#x2F;contentList\nRequest Method: POST\nStatus Code: 403 Forbidden\nRemote Address: [::1]:8888\nReferrer Policy: strict-origin-when-cross-origin\n\n&#123;\n  &quot;code&quot;: &quot;102&quot;,\n  &quot;message&quot;: &quot;ACL not allowed!&quot;,\n  &quot;rs&quot;: &#123;\n    &quot;possessionApplyUrl&quot;: &quot;https:&#x2F;&#x2F;acl.fast-inside.xxxxxx:7799&#x2F;#&#x2F;dataPermission&#x2F;roleApplication?projectCode&#x3D;content-management&amp;resourceCode&#x3D;POST:&#x2F;api&#x2F;kbs&#x2F;search&#x2F;contentList&quot;,\n    &quot;resourceName&quot;: &quot;api_kbs_search_contentList&quot;\n  &#125;,\n  &quot;failure&quot;: true,\n  &quot;success&quot;: false\n&#125;\n\nreturn fetch(API_URL, options)\n  .then(checkStatus)\n  .then(parseJSON)\n  .then((result) &#x3D;&gt; &#123;\n    const &#123; success &#125; &#x3D; result;\n    if (!success &amp;&amp; !&#x2F;\\&#x2F;api\\&#x2F;jira&#x2F;.test(API_URL)) &#123;\n      return Promise.reject(result);\n    &#125;\n    return result;\n  &#125;)\n  .catch((e) &#x3D;&gt; &#123;\n    console.log(&#96;error API_URL :::$&#123;url&#125; $&#123;API_URL&#125;&#96;);\n    logger.info(&#96;API_URL :::$&#123;url&#125; $&#123;API_URL&#125;&#96;);\n    logger.info(&#96;Error ::: $&#123;e&#125;&#96;);\n\n    &#x2F;&#x2F; 会走到这里，这里只能获取到403相关信息，获取不到响应的内容\n  &#125;);\n","slug":"2022-06-15http","date":"2022-06-15T06:27:41.000Z","categories_index":"bug","tags_index":"bug,http","author_index":"举手摘月亮"},{"id":"5a6ede004598b1b2a7c46059e37dbd43","title":"pinia源码","content":"背景了解了 playground，现在我们来看看 pinia 源码，那些 api 和方法。这么用做了什么事情\nthis.$patchplaygound\ndefineStore\n\n第一个参数是唯一字符串，用来标识 store，第二个参数是一个函数，返回一个 store 对象 playground\n第一个参数直接是配置项 playgound\n\n组件中直接通过useXXStore获取store playground\nstate怎么就是个函数，而且这个函数可以让我们自定义 store 的初始值$dispose playgound\nonUnmounted(() &#x3D;&gt; &#123;\n  userStore.$dispose();\n  cartStore.$dispose();\n  counterStore.$dispose();\n&#125;);\n\nimport &#123; storeToRefs &#125; from &#39;pinia&#39;\n以及 playground 没没有用到的 api\nconst partialStore &#x3D; &#123;\n  _p: pinia,\n  &#x2F;&#x2F; _s: scope,\n  $id,\n  $onAction: addSubscription.bind(null, actionSubscriptions),\n  $patch,\n  $reset,\n  $subscribe,\n  $dispose,\n&#125; as _StoreWithState&lt;Id, S, G, A&gt;;\nconst store: Store&lt;Id, S, G, A&gt; &#x3D; reactive(partialStore); &#x2F;&#x2F; 简化了，不考虑中间任何细节\npinia._s.set($id, store);\n\n\n$reset:该api是$patch的语法糖，只不过传递的参数是初始的state函数的执行结果，源码中const newState = state? state() : &#123;&#125;\n$patch：patch就是一次递归对value覆盖的过程\n$subscribe： 有点类似观察者，当调用subscribe时，会将当前的状态信息保存到subscriptions\n\n源码解读pinia源码解读–实现流程\n参考链接pinia 源码解读–实现流程pinia\n","slug":"2022-06-14vue-pinia","date":"2022-06-15T02:22:49.000Z","categories_index":"vue","tags_index":"源码,vue","author_index":"举手摘月亮"},{"id":"a2db94377c4f0ef1a22f18cb45800737","title":"pinia中的vue-demi源码","content":"pinia 中的 vue-demiVue Demi 是一个让你可以开发同时支持 Vue2 和 3 的通用的 Vue 库的开发工具，而无需担心用户安装的版本。\n当用户要创建一个 Vue 插件&#x2F;库时，只需将 vue-demi 安装为依赖项并将其导入，然后像之前一样发布你的插件&#x2F;库，用户的软件包就会变得通用。\nVue Demi 使用了 NPM 钩子 postinstall。当用户安装所有包后，脚本将开始检查已安装的 Vue 版本，并根据 Vue 版本返回对应的代码。在使用 Vue 2 时，如果没有安装@vue&#x2F;composition-api，它也会自动安装.\n以前\n以前，要创建支持两个目标版本的 Vue 库，我们会使用不同的分支来分离对每个版本的支持。对于现有库来说，这是一个很好的方法，因为它们的代码库通常更稳定。缺点是，你需要维护两个代码库，这让你的工作量翻倍。对于想要支持 Vue 的两个目标版本的新 Vue 库来说，我不推荐这种方法。实施两次功能请求和错误修复根本就不理想。\n现在\n这就是 Vue Demi 的用武之地。Vue Demi 通过为两个目标版本提供通用支持来解决这个问题，这意味着您只需构建一次即可获得两个目标版本的所有优点，从而获得两全其美的优势。\n核心代码目录├── lib\n│   ├── index.cjs\n│   ├── index.d.ts\n│   ├── index.iife.js\n│   ├── index.mjs\n│   ├── v2\n│   │   ├── index.cjs\n│   │   ├── index.d.ts\n│   │   └── index.mjs\n│   ├── v2.7\n│   │   ├── index.cjs\n│   │   ├── index.d.ts\n│   │   └── index.mjs\n│   └── v3\n│       ├── index.cjs\n│       ├── index.d.ts\n│       └── index.mjs\n├── package.json\n└── scripts\n    ├── postinstall.js\n    ├── switch-cli.js\n    └── utils.js\n\n核心代码package.json\n&#123;\n  &quot;name&quot;: &quot;vue-demi&quot;,\n  &quot;version&quot;: &quot;0.13.1&quot;,\n\n  &quot;scripts&quot;: &#123;\n    &quot;postinstall&quot;: &quot;node .&#x2F;scripts&#x2F;postinstall.js&quot;, &#x2F;&#x2F; 钩子npm install结束后会执行\n    &quot;release&quot;: &quot;npx bumpp --tag --commit --push &amp;&amp; npm publish&quot;\n  &#125;,\n  &quot;peerDependencies&quot;: &#123;\n    &quot;@vue&#x2F;composition-api&quot;: &quot;^1.0.0-rc.1&quot;,\n    &quot;vue&quot;: &quot;^3.0.0-0 || ^2.6.0&quot;\n  &#125;,\n  &quot;peerDependenciesMeta&quot;: &#123;\n    &quot;@vue&#x2F;composition-api&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;\n  &#125;\n&#125;\n\nscripts&#x2F;postinstall.js\nconst &#123; switchVersion, loadModule &#125; &#x3D; require(&quot;.&#x2F;utils&quot;);\n\nconst Vue &#x3D; loadModule(&quot;vue&quot;); &#x2F;&#x2F; 加载vue, 通过Vue.version获取版本\n\nif (!Vue || typeof Vue.version !&#x3D;&#x3D; &quot;string&quot;) &#123;\n  console.warn(\n    &#39;[vue-demi] Vue is not found. Please run &quot;npm install vue&quot; to install.&#39;\n  );\n&#125; else if (Vue.version.startsWith(&quot;2.7.&quot;)) &#123;\n  switchVersion(2.7); &#x2F;&#x2F; 切换到2.7版本，拷贝内容到lib&#x2F;v2.7目录\n&#125; else if (Vue.version.startsWith(&quot;2.&quot;)) &#123;\n  switchVersion(2); &#x2F;&#x2F; 切换到2.7版本，拷贝内容到lib&#x2F;v2目录，并执行安装@vue&#x2F;composition-api，更新相关内容,执行v2api更新\n&#125; else if (Vue.version.startsWith(&quot;3.&quot;)) &#123;\n  &#x2F;&#x2F; 切换到3.0版本，拷贝内容到lib&#x2F;v3目录\n  switchVersion(3);\n&#125; else &#123;\n  console.warn(&#96;[vue-demi] Vue version v$&#123;Vue.version&#125; is not suppported.&#96;);\n&#125;\n\nloadModule与switchVersion\nconst fs &#x3D; require(&quot;fs&quot;);\nconst path &#x3D; require(&quot;path&quot;);\n\nconst dir &#x3D; path.resolve(__dirname, &quot;..&quot;, &quot;lib&quot;);\n&#x2F;&#x2F; loadModule\nfunction loadModule(name) &#123;\n  try &#123;\n    return require(name);\n  &#125; catch (e) &#123;\n    return undefined;\n  &#125;\n&#125;\n\nfunction copy(name, version, vue) &#123;\n  vue &#x3D; vue || &quot;vue&quot;;\n  const src &#x3D; path.join(dir, &#96;v$&#123;version&#125;&#96;, name);\n  const dest &#x3D; path.join(dir, name);\n  let content &#x3D; fs.readFileSync(src, &quot;utf-8&quot;);\n  content &#x3D; content.replace(&#x2F;&#39;vue&#39;&#x2F;g, &#96;&#39;$&#123;vue&#125;&#39;&#96;);\n  &#x2F;&#x2F; unlink for pnpm, #92\n  try &#123;\n    fs.unlinkSync(dest); &#x2F;&#x2F; 删除旧的文件\n  &#125; catch (error) &#123;&#125;\n  &#x2F;&#x2F; 写入新的文件\n  fs.writeFileSync(dest, content, &quot;utf-8&quot;);\n&#125;\n&#x2F;&#x2F; 更新vue2api\nfunction updateVue2API() &#123;\n  const ignoreList &#x3D; [&quot;version&quot;, &quot;default&quot;];\n  const VCA &#x3D; loadModule(&quot;@vue&#x2F;composition-api&quot;);\n  if (!VCA) &#123;\n    console.warn(\n      &#39;[vue-demi] Composition API plugin is not found. Please run &quot;npm install @vue&#x2F;composition-api&quot; to install.&#39;\n    );\n    return;\n  &#125;\n\n  const exports &#x3D; Object.keys(VCA).filter((i) &#x3D;&gt; !ignoreList.includes(i));\n\n  const esmPath &#x3D; path.join(dir, &quot;index.mjs&quot;);\n  let content &#x3D; fs.readFileSync(esmPath, &quot;utf-8&quot;);\n  &#x2F;&#x2F;源码仓库结果 @link https:&#x2F;&#x2F;github.com&#x2F;vueuse&#x2F;vue-demi&#x2F;blob&#x2F;813a8dadf3a8f12b3b4a1369ff2b8da6c813d97e&#x2F;lib&#x2F;v2&#x2F;index.mjs#L2\n  content &#x3D; content.replace(\n    &#x2F;\\&#x2F;\\*\\*VCA-EXPORTS\\*\\*\\&#x2F;[\\s\\S]+\\&#x2F;\\*\\*VCA-EXPORTS\\*\\*\\&#x2F;&#x2F;m,\n    &#96;&#x2F;**VCA-EXPORTS**&#x2F;\nexport &#123; $&#123;exports.join(\n      &quot;, &quot;\n    )&#125; &#125; from &#39;@vue&#x2F;composition-api&#x2F;dist&#x2F;vue-composition-api.mjs&#39;\n&#x2F;**VCA-EXPORTS**&#x2F;&#96;\n  );\n\n  fs.writeFileSync(esmPath, content, &quot;utf-8&quot;);\n&#125;\n&#x2F;&#x2F; switchVersion 拷贝入口到对应的版本目录\nfunction switchVersion(version, vue) &#123;\n  copy(&quot;index.cjs&quot;, version, vue);\n  copy(&quot;index.mjs&quot;, version, vue);\n  copy(&quot;index.d.ts&quot;, version, vue);\n  &#x2F;&#x2F; 如果是v2还需要更新api\n  if (version &#x3D;&#x3D;&#x3D; 2) updateVue2API();\n&#125;\n\nmodule.exports.loadModule &#x3D; loadModule;\nmodule.exports.switchVersion &#x3D; switchVersion;\n\n再来看下暴露的 apipinia 中源码引用\npinia&#x2F;packages&#x2F;pinia&#x2F;src&#x2F;storeToRefs.ts\nimport &#123;\n  isReactive,\n  isRef,\n  isVue2,\n  toRaw,\n  toRef,\n  ToRefs,\n  toRefs,\n&#125; from &quot;vue-demi&quot;;\n\npinia&#x2F;packages&#x2F;pinia&#x2F;src&#x2F;rootStore.ts\nimport &#123;\n  App,\n  EffectScope,\n  getCurrentInstance,\n  inject,\n  InjectionKey,\n  Ref,\n&#125; from &quot;vue-demi&quot;;\n\n&#x2F;&#x2F; @link https:&#x2F;&#x2F;github.com&#x2F;vueuse&#x2F;vue-demi&#x2F;blob&#x2F;813a8dadf3a8f12b3b4a1369ff2b8da6c813d97e&#x2F;lib&#x2F;index.mjs#L27\nexport * from &quot;vue&quot;;\n&#x2F;&#x2F; 除了暴露版本vue-demi产生的api还将vue的api也暴露了出来，在开发第三方包的时候，可以按照不同的版本，调用不同的api\nexport &#123; Vue, Vue2, isVue2, isVue3, install &#125;;\n\n由上面的源码export * from &quot;vue&quot;;,我们可以从vue-demi中获取所有的api，这也是pinia中频繁使用vue-demi，却不见vue的原因\n参考链接vue Demi 同时支持 vue2 和 vue3https://madewith.cn/502vue-demi\n","slug":"2022-06-15vue-demi","date":"2022-06-15T01:46:31.000Z","categories_index":"vue","tags_index":"源码,vue","author_index":"举手摘月亮"},{"id":"cb01f973e2d0f78b875308680dd29577","title":"pinia源码分析 playground","content":"playground 运行是一个标准的 vue 项目\npackage.json&quot;scripts&quot;: &#123;\n  &quot;release&quot;: &quot;node scripts&#x2F;release.mjs&quot;,\n  &quot;size&quot;: &quot;pnpm run -r size&quot;,\n  &quot;build&quot;: &quot;pnpm run -r build&quot;,\n  &quot;docs:build&quot;: &quot;pnpm run docs:api &amp;&amp; pnpm run -r docs:build --filter .&#x2F;packages&#x2F;docs&quot;,\n  &quot;play&quot;: &quot;pnpm run -r play&quot;,\n  &quot;build:dts&quot;: &quot;pnpm run -r build:dts --parallel&quot;,\n  &quot;lint&quot;: &quot;prettier -c --parser typescript \\&quot;packages&#x2F;*&#x2F;&#123;src,__tests__,e2e&#125;&#x2F;**&#x2F;*.[jt]s?(x)\\&quot;&quot;,\n  &quot;lint:fix&quot;: &quot;pnpm run lint --write&quot;,\n  &quot;test&quot;: &quot;pnpm run test:types &amp;&amp; pnpm run test:jest &amp;&amp; pnpm run -r test &amp;&amp; pnpm run build &amp;&amp; pnpm run build:dts &amp;&amp; pnpm test:dts&quot;,\n  &quot;test:jest&quot;: &quot;jest --coverage&quot;,\n  &quot;test:types&quot;: &quot;tsc --build .&#x2F;tsconfig.json&quot;,\n  &quot;test:dts&quot;: &quot;pnpm run -r test:dts&quot;,\n  &quot;docs:api&quot;: &quot;pnpm run -r docs:api --filter .&#x2F;packages&#x2F;docs&quot;\n&#125;\n\n\n安装\n\n\n\n\n\n\nWARNING\n注意 node 版本 The engine &quot;node&quot; is incompatible with this module. Expected version &quot;^12.20.0 || ^14.13.1 || &gt;=16.0.0&quot;.\n👑 ~&#x2F;Desktop&#x2F;pinia git:(v2) $ yarn\n yarn install v1.4.0\n\n     node&#x2F;14.17.4\n   ο node&#x2F;15.14.0\n     node&#x2F;16.13.1\n\n Use up&#x2F;down arrow keys to select a version, return key to install, d to delete, q to quit\n info No lockfile found.\n [1&#x2F;4] 🔍  Resolving packages...\n warning conventional-changelog-cli &gt; tempfile &gt; uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;math-random for details.\n warning workspace-aggregator-d3702d10-5118-458d-9b17-8c5b340f31d0 &gt; @pinia&#x2F;nuxt &gt; @nuxt&#x2F;types &gt; @types&#x2F;autoprefixer &gt; @types&#x2F;browserslist@4.15.0: This is a stub types definition. browserslist provides its own type definitions, so you do not need this installed.\n warning workspace-aggregator-d3702d10-5118-458d-9b17-8c5b340f31d0 &gt; @pinia&#x2F;nuxt &gt; @nuxt&#x2F;types &gt; @types&#x2F;webpack &gt; @types&#x2F;anymatch@3.0.0: This is a stub types definition. anymatch provides its own type definitions, so you do not need this installed.\n [2&#x2F;4] 🚚  Fetching packages...\n error execa@6.1.0: The engine &quot;node&quot; is incompatible with this module. Expected version &quot;^12.20.0 || ^14.13.1 || &gt;&#x3D;16.0.0&quot;.\n error An unexpected error occurred: &quot;Found incompatible module&quot;.\n info If you think this is a bug, please open a bug report with the information provided in &quot;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;pinia&#x2F;yarn-error.log&quot;.\n info Visit https:&#x2F;&#x2F;yarnpkg.com&#x2F;en&#x2F;docs&#x2F;cli&#x2F;install for documentation about this command.\n 👑 ~&#x2F;Desktop&#x2F;pinia git:(v2) $ sudo n\n Password:\n   installed : v16.13.1 (with npm 8.1.2)\n\n\n\n# 全局安装pnpm\nnpm install -g pnpm\n\n# 根目录\nyarn\n\n运行yarn build &amp;&amp; yarn play\n\n\n\n\n\n\n\nTIP\n如果不运行 yarn build,你将看到如下报错信息，原因是playgound/vite.config.ts，内部写了copyPiniaPlugin\n[plugin:vite:import-analysis] Failed to resolve entry for package “pinia”. The package may have incorrect main&#x2F;module&#x2F;exports specified in its package.json: Failed to resolve entry for package “pinia”. The package may have incorrect main&#x2F;module&#x2F;exports specified in its package.json\n\nplaygound&#x2F;vite.config.tsimport &#123; defineConfig, Plugin &#125; from &quot;vite&quot;;\nimport vue from &quot;@vitejs&#x2F;plugin-vue&quot;;\nimport &#123; promises as fs &#125; from &quot;fs&quot;;\nimport path from &quot;path&quot;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;\nexport default defineConfig(&#123;\n  plugins: [vue(), copyPiniaPlugin()],\n  define: &#123;\n    &#x2F;&#x2F; __DEV__: &#39;true&#39;,\n    &#x2F;&#x2F; __BROWSER__: &#39;true&#39;,\n    __TEST__: &quot;false&quot;,\n  &#125;,\n  resolve: &#123;\n    &#x2F;&#x2F; alias: &#123;\n    &#x2F;&#x2F;   &#39;@vue&#x2F;composition-api&#39;: &#39;vue-demi&#39;,\n    &#x2F;&#x2F; &#125;,\n    dedupe: [&quot;vue-demi&quot;, &quot;vue&quot;],\n  &#125;,\n  optimizeDeps: &#123;\n    &#x2F;&#x2F; pinia项排除\n    exclude: [&quot;vue-demi&quot;, &quot;@vueuse&#x2F;shared&quot;, &quot;@vueuse&#x2F;core&quot;, &quot;pinia&quot;],\n  &#125;,\n&#125;);\n&#x2F;&#x2F; 拷贝pinia到项目中，避免编译\nfunction copyPiniaPlugin(): Plugin &#123;\n  return &#123;\n    name: &quot;copy-pinia&quot;,\n    async generateBundle() &#123;\n      const filePath &#x3D; path.resolve(__dirname, &quot;..&#x2F;pinia&#x2F;dist&#x2F;pinia.mjs&quot;); &#x2F;&#x2F; 注意这里，不执行 yarn build 这里是没有数据的，yarn play会报错\n\n      &#x2F;&#x2F; throws if file doesn&#39;t exist\n      await fs.access(filePath);\n\n      this.emitFile(&#123;\n        type: &quot;asset&quot;,\n        fileName: &quot;pinia.mjs&quot;,\n        source: await fs.readFile(filePath, &quot;utf-8&quot;),\n      &#125;);\n    &#125;,\n  &#125;;\n&#125;\n\n\nplayground&#x2F;index.html&lt;!DOCTYPE html&gt;\n&lt;!-- html解析规则--&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;!-- 关键字符集 --&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;!-- 方便手机端调整分辨率 --&gt;\n    &lt;title&gt;🍍 Pinia playground&lt;&#x2F;title&gt;\n\n    &lt;link\n      rel&#x3D;&quot;stylesheet&quot;\n      href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;@exampledev&#x2F;new.css@1&#x2F;new.min.css&quot;\n    &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;fonts.xz.style&#x2F;serve&#x2F;inter.css&quot; &#x2F;&gt;\n    &lt;!-- 一开始以为是 首屏优化，加载动画 运行后发现，并不是，仅仅是样式而已，代码中使用v-if 或v-else-if渲染加载动画--&gt;\n    &lt;!-- \n      JokesPromised.vue \n      NasaPOD.vue \n      NasaPODwrc.vue \n    --&gt;\n    &lt;style&gt;\n      @keyframes spinner &#123;\n        to &#123;\n          transform: rotate(360deg);\n        &#125;\n      &#125;\n\n      .spinner:before &#123;\n        content: &quot;&quot;;\n        box-sizing: border-box;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        width: 30px;\n        height: 30px;\n        margin-top: -15px;\n        margin-left: -15px;\n        border-radius: 50%;\n        border: 1px solid #ccc;\n        border-top-color: #07d;\n        animation: spinner 0.6s linear infinite;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- vue根节点 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- 模块加载 --&gt;\n    &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.ts&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\napi 目录一些小练习，demo 之类的东西，我有点不明白的是，pinia/packages/playground/src/api下使用了mande,不能直接用fetch吗?\n\nmandeRequires fetch support.\nWeekly Downloads 530 😓\nUnpacked Size 47.3 kB\n\n\n\n\n\n\n\n\n为了炫技而写的，所以我没有用fetch，而是用了mande。——此处 AI 自动生成\n\n\ncomposables 目录&#x2F;&#x2F; useCachedRequest.ts\n&#x2F;&#x2F; pinia&#x2F;packages&#x2F;playground&#x2F;src&#x2F;composables&#x2F;useCachedRequest.ts\n\nexport function useCachedRequest&lt;T, U&gt;(\n  keySource: Ref&lt;U&gt;,\n  getter: (key: U) &#x3D;&gt; Promise&lt;T&gt; &#x2F;&#x2F; 这应该是一个接口\n) &#123;\n  const data &#x3D; ref&lt;T&gt;(); &#x2F;&#x2F; 存数据\n  const isLoading &#x3D; ref(false); &#x2F;&#x2F; 加载动画\n  const isReady &#x3D; ref(false); &#x2F;&#x2F; 是否已加载数据\n  const error &#x3D; ref&lt;Error | undefined&gt;(); &#x2F;&#x2F; 有没有出错\n\n  const cache &#x3D; new Map&lt;U, T&gt;(); &#x2F;&#x2F; 使用map实现缓存\n\n  onScopeDispose(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 清理缓存\n    cache.clear();\n  &#125;);\n\n  watchEffect(async () &#x3D;&gt; &#123;\n    const key &#x3D; unref(keySource);\n    isReady.value &#x3D; false; &#x2F;&#x2F; 是不是已拿到数据\n    isLoading.value &#x3D; true; &#x2F;&#x2F; 加载动画\n\n    if (cache.has(key)) &#123;\n      data.value &#x3D; cache.get(key)!;\n      isReady.value &#x3D; true;\n    &#125;\n\n    getter(key)\n      .then((newData) &#x3D;&gt; &#123;\n        cache.set(key, newData);\n        data.value &#x3D; newData;\n        isReady.value &#x3D; true;\n      &#125;)\n      .catch((err) &#x3D;&gt; &#123;\n        error.value &#x3D; err;\n      &#125;)\n      .finally(() &#x3D;&gt; &#123;\n        isLoading.value &#x3D; false;\n      &#125;);\n  &#125;);\n\n  return &#123; data, error, isLoading, isReady &#125;; &#x2F;&#x2F; 最后将这些值返回\n&#125;\n\n\n\n小插曲\n\nonScopeDispose\n这个 api 没见过，搜下其他人是怎么理解的\n在 vue3.2 中新增了一个属性 EffectScope，官方文档的解释比较简单，只说是一个高级属性，并没有具体的示例。\nantfu 大神的 vueuse 框架源码，里面大量使用 EffectScope，所以研究了一下这个属性的使用方法。\n什么是 EffectScope?下面是官方文档解释，感觉有点敷衍\nEffect scope is an advanced API primarily intended for library authors. For details on how to leverage this API, please consult its corresponding RFC(opens new window).这个 api 是高级的，主要用于库的开发者。更多详情，请参考其对应的 RFC(新窗口打开)。\nRFC 关于 EffectScopeApi 的解释\n在 Vue 的 setup 中，响应会在开始初始化的时候被收集，在实例被卸载的时候，响应就会自动的被取消追踪了，这时一个很方便的特性。但是，当我们在组件外使用或者编写一个独立的包时，这会变得非常麻烦。当在单独的文件中，我们该如何停止 computed &amp; watch 的响应式依赖呢？\n实际上 EffectScope 按我的理解就是副作用生效的作用域。\nvue3 对响应式的监听是通过 effect 实现的，当我们的组件销毁的时候 vue 会自动取消该组件的 effect。\n那么如果我们想要自己控制 effect 生效与否呢？ 比如我只想在莫种特定情况下才监听摸个 ref，其他情况下不想监听该怎么做？\nvue3.2 之前\n&#x2F;&#x2F;（vue-RFC示例代码）\nconst disposables &#x3D; [];\n\nconst counter &#x3D; ref(0);\nconst doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);\n\ndisposables.push(() &#x3D;&gt; stop(doubled.effect));\n\nconst stopWatch1 &#x3D; watchEffect(() &#x3D;&gt; &#123;\n  console.log(&#96;counter: $&#123;counter.value&#125;&#96;);\n&#125;);\n\ndisposables.push(stopWatch1);\n\nconst stopWatch2 &#x3D; watch(doubled, () &#x3D;&gt; &#123;\n  console.log(doubled.value);\n&#125;);\n\ndisposables.push(stopWatch2);\n\nEffectScope 如何实现&#x2F;&#x2F; effect, computed, watch, watchEffect created inside the scope will be collected\n\nconst scope &#x3D; effectScope();\n\nscope.run(() &#x3D;&gt; &#123;\n  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);\n\n  watch(doubled, () &#x3D;&gt; console.log(doubled.value));\n\n  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));\n&#125;);\n\n&#x2F;&#x2F; to dispose all effects in the scope\nscope.stop();\n\n示例;\nconst scope &#x3D; effectScope();\nlet counter &#x3D; ref(0);\nsetInterval(() &#x3D;&gt; &#123;\n  counter.value++;\n&#125;, 1000);\nscope.run(() &#x3D;&gt; &#123;\n  watchEffect(() &#x3D;&gt; console.log(&#96;counter: $&#123;counter.value&#125;&#96;));\n&#125;);\n&#x2F;*log:\ncounter: 0\ncounter: 1\ncounter: 2\ncounter: 3\ncounter: 4\ncounter: 5\n*&#x2F;\n\nconst scope &#x3D; effectScope();\nlet counter &#x3D; ref(0);\nsetInterval(() &#x3D;&gt; &#123;\n  counter.value++;\n&#125;, 1000);\nscope.run(() &#x3D;&gt; &#123;\n  watchEffect(() &#x3D;&gt; console.log(&#96;counter: $&#123;counter.value&#125;&#96;));\n&#125;);\nscope.stop();\n&#x2F;*log:\ncounter: 0\n*&#x2F;\n\n基本使用新建一个 scope:\nconst scope &#x3D; effectScope();\n\n一个 scope 可以执行一个 run 函数（接受一个函数作为参数，并返回该函数的返回值），并且捕获所有在该函数执行过程中创建的 effect ，包括可以创建 effect 的 API，例如 computed , watch , watchEffect :\nscope.run(() &#x3D;&gt; &#123;\n  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);\n\n  watch(doubled, () &#x3D;&gt; console.log(doubled.value));\n\n  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));\n&#125;);\n\n&#x2F;&#x2F; the same scope can run multiple times\nscope.run(() &#x3D;&gt; &#123;\n  watch(counter, () &#x3D;&gt; &#123;\n    &#x2F;*...*&#x2F;\n  &#125;);\n&#125;);\n\n当调用 scope.stop(), 所有被捕获的 effect 都会被取消，包括 nested Scopes 也会被递归取消\nNested Scopes嵌套 scope 也会被他们的父级 scope 收集。并且当父级 scope 销毁的时候，所有的后代 scope 也会被递归销毁。\nconst scope &#x3D; effectScope();\n\nscope.run(() &#x3D;&gt; &#123;\n  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);\n\n  &#x2F;&#x2F; not need to get the stop handler, it will be collected by the outer scope\n  effectScope().run(() &#x3D;&gt; &#123;\n    watch(doubled, () &#x3D;&gt; console.log(doubled.value));\n  &#125;);\n\n  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));\n&#125;);\n\n&#x2F;&#x2F; dispose all effects, including those in the nested scopes\nscope.stop();\n\nDetached Nested ScopeseffectScope 接受一个参数可以在分离模式（detached mode）下创建。 detached scope 不会被父级 collect。\n这一特性同时解决了一个 Issues lazy Initialization。\nlet nestedScope;\n\nconst parentScope &#x3D; effectScope();\n\nparentScope.run(() &#x3D;&gt; &#123;\n  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);\n\n  &#x2F;&#x2F; with the detected flag,\n  &#x2F;&#x2F; the scope will not be collected and disposed by the outer scope\n  nestedScope &#x3D; effectScope(true &#x2F;* detached *&#x2F;);\n  nestedScope.run(() &#x3D;&gt; &#123;\n    watch(doubled, () &#x3D;&gt; console.log(doubled.value));\n  &#125;);\n\n  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));\n&#125;);\n\n&#x2F;&#x2F; disposes all effects, but not &#96;nestedScope&#96;\nparentScope.stop();\n\n&#x2F;&#x2F; stop the nested scope only when appropriate\nnestedScope.stop();\n\nonScopeDispose全局钩子函数 onScopeDispose 提供了类似于 onUnmounted 的功能，不同的是它工作在 scope 中而不是当前 instance。\n这使得 composable functions 可以通过他们的 scope 清除他们的副作用。\n由于 setup() 默认会为当前 instance 创建一个 scope，所以当没有明确声明一个 scope 的时候，onScopeDispose 等同于 onUnmounted。\nimport &#123; onScopeDispose &#125; from &quot;vue&quot;;\n\nconst scope &#x3D; effectScope();\n\nscope.run(() &#x3D;&gt; &#123;\n  onScopeDispose(() &#x3D;&gt; &#123;\n    console.log(&quot;cleaned!&quot;);\n  &#125;);\n&#125;);\n\nscope.stop(); &#x2F;&#x2F; logs &#39;cleaned!&#39;\n\nGetting the current Scope\n通过 getCurrentScope() 可以获取当前 scope\nimport &#123; getCurrentScope &#125; from &quot;vue&quot;;\n\ngetCurrentScope(); &#x2F;&#x2F; EffectScope | undefined\n\n实战示例：Shared Composable一些 composables 会设置全局副作用，例如如下的 useMouse() function:\nfunction useMouse() &#123;\n  const x &#x3D; ref(0);\n  const y &#x3D; ref(0);\n\n  window.addEventListener(&quot;mousemove&quot;, handler);\n\n  function handler(e) &#123;\n    x.value &#x3D; e.x;\n    y.value &#x3D; e.y;\n  &#125;\n\n  onUnmounted(() &#x3D;&gt; &#123;\n    window.removeEventListener(&quot;mousemove&quot;, handler);\n  &#125;);\n\n  return &#123; x, y &#125;;\n&#125;\n\n如果在多个组件中调用 useMouse () ，则每个组件将附加一个 mouseemove 监听器，并创建自己的 x 和 y refs 副本。我们应该能够通过在多个组件之间共享相同的侦听器集和 refs 来提高效率，但是我们做不到，因为每个 onUnmounted 调用都耦合到一个组件实例。\n我们可以使用分离作用域和 onScopeDispose 来实现这一点, 首先，我们需要用 onScopeDispose 替换 onUnmounted\n- onUnmounted(() &#x3D;&gt; &#123;\n\n* onScopeDispose(() &#x3D;&gt; &#123;\n  window.removeEventListener(&#39;mousemove&#39;, handler)\n  &#125;)\n\n这仍然有效，因为 Vue 组件现在也在作用域内运行其 setup () ，该作用域将在组件卸载时释放。\n然后，我们可以创建一个工具函数来管理父范围订阅:\nfunction createSharedComposable(composable) &#123;\n  let subscribers &#x3D; 0;\n  let state, scope;\n\n  const dispose &#x3D; () &#x3D;&gt; &#123;\n    if (scope &amp;&amp; --subscribers &lt;&#x3D; 0) &#123;\n      scope.stop();\n      state &#x3D; scope &#x3D; null;\n    &#125;\n  &#125;;\n  &#x2F;&#x2F; 这里只有在第一次运行的时候创建一个 state, 后面所有的组件就不会再创建新的 state，而是共用一个 state\n  return (...args) &#x3D;&gt; &#123;\n    subscribers++;\n    if (!state) &#123;\n      scope &#x3D; effectScope(true);\n      state &#x3D; scope.run(() &#x3D;&gt; composable(...args));\n    &#125;\n    onScopeDispose(dispose);\n    return state;\n  &#125;;\n&#125;\n\n现在我们就可以使用这个 shared 版本的 useMouse\nconst useSharedMouse &#x3D; createSharedComposable(useMouse);\n\n通过这个例子，不禁想到，是否可以通过这种模式模拟 vuex 的能力？我们是否可以通过 shared composables 更加灵活的达到全局状态管理的目的呢？\n作者：zifeiyu链接：https://juejin.cn/post/7019241635942760455\n总结：说了一大堆，大概意思是提供在组件外进行副作用清理的 api，这也是为什么说给库的开发者使用\n\n\nstores 目录，对应 v2 的 vuex一个购物车的例子\n&#x2F;&#x2F; .\n&#x2F;&#x2F; ├── cart.ts\n&#x2F;&#x2F; ├── counter.ts\n&#x2F;&#x2F; ├── counterSetup.ts\n&#x2F;&#x2F; ├── demo-counter.ts\n&#x2F;&#x2F; ├── jokes-swrv.ts\n&#x2F;&#x2F; ├── jokes.ts\n&#x2F;&#x2F; ├── jokesUsePromised.ts\n&#x2F;&#x2F; ├── nasa-pod.ts\n&#x2F;&#x2F; ├── nasa.ts\n&#x2F;&#x2F; └── user.ts\n\nuser.ts\n定义 useUserStore，id 为‘user’, state 两个字段，actions 1. 登录，调用的是 apiLogin 接口，调用成功后进行数据this.$patch批量更新actions 2. 退出登录\nimport &#123; defineStore &#125; from &quot;pinia&quot;;\n\nexport const useUserStore &#x3D; defineStore(&quot;user&quot;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    name: &quot;Eduardo&quot;,\n    isAdmin: true,\n  &#125;),\n  actions: &#123;\n    &#x2F;**\n     * Attempt to login a user\n     *&#x2F;\n    async login(user: string, password: string) &#123;\n      const userData &#x3D; await apiLogin(user, password);\n\n      this.$patch(&#123;\n        name: user,\n        ...userData,\n      &#125;);\n    &#125;,\n    logout() &#123;\n      this.$patch(&#123;\n        name: &quot;&quot;,\n        isAdmin: false,\n      &#125;);\n\n      &#x2F;&#x2F; we could do other stuff like redirecting the user\n    &#125;,\n  &#125;,\n&#125;);\n\n&#x2F;**\n * Simulate a login 模拟登录\n *&#x2F;\nfunction apiLogin(a: string, p: string) &#123;\n  if (a &#x3D;&#x3D;&#x3D; &quot;ed&quot; &amp;&amp; p &#x3D;&#x3D;&#x3D; &quot;ed&quot;) return Promise.resolve(&#123; isAdmin: true &#125;); &#x2F;&#x2F; 管理员\n  if (p &#x3D;&#x3D;&#x3D; &quot;ed&quot;) return Promise.resolve(&#123; isAdmin: false &#125;); &#x2F;&#x2F; 非管理员\n  return Promise.reject(new Error(&quot;invalid credentials&quot;)); &#x2F;&#x2F; 游客未认证\n&#125;\n\n&#x2F;&#x2F; counter.ts\nimport &#123; acceptHMRUpdate, defineStore &#125; from &quot;pinia&quot;;\n\nconst delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t));\n\nexport const useCounter &#x3D; defineStore(&#123;\n  id: &quot;counter&quot;,\n\n  state: () &#x3D;&gt; (&#123;\n    n: 2,\n    incrementedTimes: 0,\n    decrementedTimes: 0,\n    numbers: [] as number[],\n  &#125;),\n\n  getters: &#123;\n    double: (state) &#x3D;&gt; state.n * 2,\n  &#125;,\n\n  actions: &#123;\n    increment(amount &#x3D; 1) &#123;\n      if (typeof amount !&#x3D;&#x3D; &quot;number&quot;) &#123;\n        amount &#x3D; 1;\n      &#125;\n      this.incrementedTimes++;\n      this.n +&#x3D; amount;\n    &#125;,\n\n    changeMe() &#123;\n      console.log(&quot;change me to test HMR&quot;);\n    &#125;,\n\n    async fail() &#123;\n      const n &#x3D; this.n;\n      await delay(1000);\n      this.numbers.push(n);\n      await delay(1000);\n      if (this.n !&#x3D;&#x3D; n) &#123;\n        throw new Error(&quot;Someone changed n!&quot;);\n      &#125;\n\n      return n;\n    &#125;,\n\n    async decrementToZero(interval: number &#x3D; 300, usePatch &#x3D; true) &#123;\n      if (this.n &lt;&#x3D; 0) return;\n\n      while (this.n &gt; 0) &#123;\n        if (usePatch) &#123;\n          this.$patch(&#123;\n            &#x2F;&#x2F; 这个就比较奇怪了，我严重怀疑这里的(usePatch &#x3D; true 与 usePatch &#x3D; false)数据不一致\n            n: this.n - 1,\n            decrementedTimes: this.decrementedTimes + 1,\n          &#125;);\n          &#x2F;&#x2F; this.$patch(state &#x3D;&gt; &#123;\n          &#x2F;&#x2F;   state.n--\n          &#x2F;&#x2F;   state.decrementedTimes++\n          &#x2F;&#x2F; &#125;)\n        &#125; else &#123;\n          this.n -&#x3D; 1;\n        &#125;\n        await delay(interval);\n      &#125;\n    &#125;,\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; 这个地方没看懂.\n\nif (import.meta.hot) &#123;\n  &#x2F;&#x2F; @link: https:&#x2F;&#x2F;www.jb51.net&#x2F;article&#x2F;244749.htm\n  &#x2F;&#x2F; import.meta 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象，它包含了这个模块的信息。\n  &#x2F;&#x2F; Pinia 是 vuex 新替代方案。Pinia 中热更新实现，借助 import.meta。\n  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot));\n&#125;\n\ncounterSetup.ts 结合 vue 做了很多操作，最后只返回了一个 state,没有 getters,actions以下为 state 上的方法\n\ndouble,\nincrement,\nfail,\nchangeMe,\ndecrementToZero,\n\n&#x2F;&#x2F; counterSetup\nimport &#123; computed, toRefs, reactive &#125; from &quot;vue&quot;;\nimport &#123; acceptHMRUpdate, defineStore &#125; from &quot;pinia&quot;;\n\nconst delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t));\n\nexport const useCounter &#x3D; defineStore(&quot;counter-setup&quot;, () &#x3D;&gt; &#123;\n  const state &#x3D; reactive(&#123;\n    &#x2F;&#x2F; vue\n    n: 0,\n    incrementedTimes: 0,\n    decrementedTimes: 0,\n    numbers: [] as number[],\n  &#125;);\n\n  const double &#x3D; computed(() &#x3D;&gt; state.n * 2); &#x2F;&#x2F; vue\n\n  function increment(amount &#x3D; 1) &#123;\n    if (typeof amount !&#x3D;&#x3D; &quot;number&quot;) &#123;\n      amount &#x3D; 1;\n    &#125;\n    state.incrementedTimes++;\n    state.n +&#x3D; amount;\n  &#125;\n\n  function changeMe() &#123;\n    console.log(&quot;change me to test HMR&quot;);\n  &#125;\n  &#x2F;&#x2F;\n  async function fail() &#123;\n    const n &#x3D; state.n;\n    await delay(1000);\n    state.numbers.push(n);\n    await delay(1000);\n    if (state.n !&#x3D;&#x3D; n) &#123;\n      throw new Error(&quot;Someone changed n!&quot;);\n    &#125;\n\n    return n;\n  &#125;\n  &#x2F;&#x2F; 定时器直到减少到0\n  async function decrementToZero(interval: number &#x3D; 300) &#123;\n    if (state.n &lt;&#x3D; 0) return;\n\n    while (state.n &gt; 0) &#123;\n      state.n -&#x3D; 1;\n      state.decrementedTimes +&#x3D; 1;\n      await delay(interval);\n    &#125;\n  &#125;\n\n  return &#123;\n    ...toRefs(state), &#x2F;&#x2F; vue将 state 转换为 refs， TODO：toRefs这个之后可以看下源码做了怎样的处理\n    double,\n    increment,\n    fail,\n    changeMe,\n    decrementToZero,\n  &#125;;\n&#125;);\n\nif (import.meta.hot) &#123;\n  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot));\n&#125;\ndemo-counter.ts 只返回一个箭头函数简写的state\n&#x2F;&#x2F; demo-counter.ts\nimport &#123; defineStore, acceptHMRUpdate &#125; from &#39;pinia&#39;\n\nconst delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t))\n&#x2F;&#x2F; just to ignore the not used error\ndelay(0)\n\nexport const useCounter &#x3D; defineStore(&#39;demo-counter&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    n: 0,\n  &#125;),\n&#125;)\n\nif (import.meta.hot) &#123;\n  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot))\n&#125;\n\n\n&#x2F;&#x2F; jokes-swrv.ts\n\nimport &#123; ref, toRaw, watch &#125; from &#39;vue&#39;\nimport &#123; acceptHMRUpdate, defineStore &#125; from &#39;pinia&#39;\nimport &#123; getRandomJoke, Joke &#125; from &#39;..&#x2F;api&#x2F;jokes&#39;\nimport useSWRV from &#39;swrv&#39; &#x2F;&#x2F; @link https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;swrv\n\nexport const useJokesSetup &#x3D; defineStore(&#39;jokes-swrv-setup&#39;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; const current &#x3D; ref&lt;null | Joke&gt;(null)\n  const history &#x3D; ref&lt;Joke[]&gt;([])\n  &#x2F;&#x2F; useSWRV vue组合式网络请求，之前了解代码&#96;pinia&#x2F;packages&#x2F;playground&#x2F;src&#x2F;api&#96; 中使用了‘mande’，做网络请求，我想这应该是作者为了给开发者提供更多的场景来学习pinia\n  const &#123; data, error, mutate &#125; &#x3D; useSWRV(&#39;jokes&#39;, getRandomJoke)\n  &#x2F;&#x2F; 监听data变化\n  watch(data, (joke) &#x3D;&gt; &#123;\n    console.log(&#39;changed from within the store&#39;, joke)\n    if (joke) &#123;\n      &#x2F;&#x2F; 响应式数据，  history是响应式的，需要用.value来操作\n      history.value.push(toRaw(joke))\n    &#125;\n  &#125;)\n\n  return &#123; current: data, error, history, fetchJoke: mutate &#125;\n&#125;)\n\nif (import.meta.hot) &#123;\n  &#x2F;&#x2F; import.meta.hot.accept(acceptHMRUpdate(useJokes, import.meta.hot))\n  import.meta.hot.accept(acceptHMRUpdate(useJokesSetup, import.meta.hot))\n&#125;\n\n\n jokes.ts 文件下，写了useJokes 和 useJokesSetup\n&#x2F;&#x2F; jokes.ts\nimport &#123; ref, unref &#125; from &#39;vue&#39;\nimport &#123; acceptHMRUpdate, defineStore &#125; from &#39;pinia&#39;\nimport &#123; getRandomJoke, Joke &#125; from &#39;..&#x2F;api&#x2F;jokes&#39;\n\nexport const useJokes &#x3D; defineStore(&#39;jokes&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    current: null as null | Joke,\n    jokes: [] as Joke[],\n    &#x2F;&#x2F; hello: true,\n  &#125;),\n  actions: &#123;\n    async fetchJoke() &#123;\n      if (\n        this.current &amp;&amp;\n        &#x2F;&#x2F; if the request below fails, avoid adding it twice\n        &#x2F;&#x2F; 如果请求失败，就不要添加进历史记录\n        !this.jokes.includes(this.current)\n      ) &#123;\n        this.jokes.push(this.current)\n      &#125;\n\n      &#x2F;&#x2F; NOTE: Avoid patching an object because it&#39;s recursive\n      &#x2F;&#x2F; 注意：不要更新一个对象，因为它是递归的\n      &#x2F;&#x2F; this.$patch(&#123; current: await getRandomJoke() &#125;)\n      this.current &#x3D; await getRandomJoke()\n    &#125;,\n  &#125;,\n&#125;)\n\nexport const useJokesSetup &#x3D; defineStore(&#39;jokes-setup&#39;, () &#x3D;&gt; &#123;\n  const current &#x3D; ref&lt;null | Joke&gt;(null)\n  const history &#x3D; ref&lt;Joke[]&gt;([])\n\n  async function fetchJoke() &#123;\n    const cur &#x3D; unref(current.value)\n    if (\n      cur &amp;&amp;\n      &#x2F;&#x2F; if the request below fails, avoid adding it twice\n      !history.value.find((joke) &#x3D;&gt; joke.id &#x3D;&#x3D;&#x3D; cur.id)\n    ) &#123;\n      history.value.push(cur)\n    &#125;\n\n    current.value &#x3D; await getRandomJoke()\n    return current.value\n  &#125;\n\n  return &#123; current, history, fetchJoke &#125;\n&#125;)\n\nif (import.meta.hot) &#123;\n  import.meta.hot.accept(acceptHMRUpdate(useJokes, import.meta.hot))\n  &#x2F;&#x2F; import.meta.hot.accept(acceptHMRUpdate(useJokesSetup, import.meta.hot))\n&#125;\n","slug":"2022-06-13vue-pinia","date":"2022-06-13T07:27:26.000Z","categories_index":"vue","tags_index":"源码,vue","author_index":"举手摘月亮"},{"id":"30090ec9fe2f3c6d588fdab6524f755c","title":"javascript event","content":"现象描述react_devtools_backend.js:4026 Warning: This synthetic event is reused for performance reasons. If you&#39;re seeing this, you&#39;re accessing the property &#96;target&#96; on a released&#x2F;nullified synthetic event. This is set to null. If you must keep the original synthetic event around, use event.persist(). See https:&#x2F;&#x2F;fb.me&#x2F;react-event-pooling for more information.\n\nevent.persist();\n\n代码描述及修改&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nconst handleConfirmUpload &#x3D; useCallback(async (event, index: number) &#x3D;&gt; &#123;\n  event.persist(); &#x2F;&#x2F; 不加此处，导致上述问题\n  setConfirmFileReplace(true);\n  fileReplaceCache.current &#x3D; &#123;\n    event,\n    index,\n  &#125;;\n&#125;, []);\n&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nconst handleCloseFileReplace &#x3D; useCallback(async () &#x3D;&gt; &#123;\n  setConfirmFileReplace(false);\n  fileReplaceCache.current &#x3D; null;\n&#125;, []);\n&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nconst handleConfirmFileReplace &#x3D; useCallback(async () &#x3D;&gt; &#123;\n  if (fileReplaceCache.current) &#123;\n    handleUploadChange(\n      fileReplaceCache.current?.event,\n      fileReplaceCache.current?.index\n    );\n  &#125;\n&#125;, [fileReplaceCache.current]);\n\n&#x2F;&#x2F; 为了保证此函数内部不变\nconst handleUploadChange &#x3D; useCallback(async (event, index: number) &#x3D;&gt; &#123;\n  const files &#x3D; event.target?.files;\n  if (!files || files?.length &#x3D;&#x3D;&#x3D; 0) return;\n&#125;, []);\n\n原因分析点击 查看链接提示\nEvent Pooling\n\n\n\n\n\n\n\nWARNING\nThis page is only relevant for React 16 and earlier, and for React Native.这个页面只适用于 React 16 和更早的版本，以及 React Native。React 17 on the web does not use event pooling.React17 在web中没有使用事件循环Read more about this change in React 17.\n\nThe SyntheticEvent objects are pooled. This means that the SyntheticEvent object will be reused and all properties will be nullified after the event handler has been called. For example, this won’t work:SyntheticEvent对象被合并。这意味着将重用SyntheticEvent对象，并且在调用事件处理程序后，所有属性都将为null。例如，这将不起作用：\nfunction handleChange(e) &#123;\n  &#x2F;&#x2F; This won&#39;t work because the event object gets reused.\n  &#x2F;&#x2F; 这不起作用，因为事件对象被重用了。\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(e.target.value); &#x2F;&#x2F; Too late! 太迟了\n  &#125;, 100);\n&#125;\n\nIf you need to access event object’s properties after the event handler has run, you need to call e.persist():如果需要在事件处理程序运行后访问事件对象的属性，则需要调用e.persist()：\nfunction handleChange(e) &#123;\n  &#x2F;&#x2F; Prevents React from resetting its properties:\n  &#x2F;&#x2F; 阻止React重置其属性\n  e.persist();\n\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(e.target.value); &#x2F;&#x2F; Works 没问题\n  &#125;, 100);\n&#125;\n","slug":"2022-06-13event","date":"2022-06-13T02:31:04.000Z","categories_index":"javascript","tags_index":"javascript","author_index":"举手摘月亮"},{"id":"77d580d0d304de3429cbd4fdc2ebd7c6","title":"Vue Pinia","content":"Pinia 特点💡 Intuitive直观的Stores are as familiar as components. API designed to let you write well organized stores.存储和组件是一样的。API设计了让你写好组织的存储。\n🔑 Type Safe类型安全的Types are inferred, which means stores provide you with autocompletion even in JavaScript!类型可推测，这意味着存储提供了你在JavaScript中自动完成的功能！\n⚙️ Devtools support开发工具支持Pinia hooks into Vue devtools to give you an enhanced development experience in both Vue 2 and Vue 3.Pinia钩子进入Vue开发工具，让你在Vue 2和Vue 3中获得强化开发经验。\n🔌 Extensible可扩展的React to store changes to extend Pinia with transactions, local storage synchronization, etc.通过事务、本地存储同步等来响应存储更改以扩展Pinia。\n🏗 Modular by design设计模块化Build multiple stores and let your bundler code split them automatically.构建多个存储，让你的bundler代码分开它们自动。\n📦 Extremely light非常轻量的Pinia weighs around 1kb, you will forget it’s even there!Pinia约1kb，你会忘记它在那里！\nIntroduction介绍\n\nPinia started as an experiment to redesign what a Store for Vue could look like with the Composition API around November 2019. Since then, the initial principles are still the same, but Pinia works for both Vue 2 and Vue 3 and doesn’t require you to use the composition API. The API is the same for both except for installation and SSR, and these docs are targeted to Vue 3 with notes about Vue 2 whenever necessary so it can be read by Vue 2 and Vue 3 users!\n译：Pinia 从 2019 年 11 月左右开始尝试重新设计 Vue store 的合成 API。从那时起，最初的原则仍然是一样的，但 Pinia 同时适用于 Vue 2 和 Vue 3，不需要您使用合成 API。除了安装和 SSR 之外，这两个 API 都是相同的，这些文档针对 Vue 3，并在必要时提供有关 Vue 2 的说明，以便 Vue 2 和 Vue 3 用户可以阅读！\nWhy should I use Pinia?\n为什么我应该使用Pinia？\nPinia is a store library for Vue, it allows you to share a state across components&#x2F;pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple export const state = reactive(&#123;&#125;). This is true for single page applications but exposes your application to security vulnerabilities if it is server side rendered. But even in small single page applications, you get a lot from using Pinia:\n译：Pinia 是一个 Vue 的存储库，它允许你在组件&#x2F;页面之间共享状态。如果你熟悉合成 API，你可能会认为你可以通过简单的export const state = reactive(&#123;&#125;)共享全局状态。这是对于单页应用的真实情况，但 **如果它是服务器端渲染，它会暴露您的应用程序到安全漏洞**。但即使是小的单页应用，使用 Pinia 也很多：\n\nDevtools support 开发工具支持\nA timeline to track actions, mutations 追踪行动、突变的时间表\nStores appear in components where they are used 存储出现在使用它们的组件中\nTime travel and easier debugging 时间旅行和更容易调试\n\n\nHot module replacement 快速更新\nModify your stores without reloading your page 在不重新加载页面的情况下修改你的存储\nKeep any existing state while developing 在开发时保持任何现有状态\n\n\nPlugins: extend Pinia features with plugins 功能扩展：使用插件扩展 Pinia 功能\nProper TypeScript support or autocompletion for JS users *对于 JS 用户的正确的 TypeScript 支持或自动完成*\nServer Side Rendering Support 完美的服务器端渲染支持\n\nBasic example\n基本示例This is what using pinia looks like in terms of API (make sure to check the Getting Started for complete instructions). You start by creating a store:译：这是为什么使用 pinia 看起来像 API（请检查开始以获取完整的指令）。你首先创建一个存储：\n&#x2F;&#x2F; stores&#x2F;counter.js\nimport &#123; defineStore &#125; from &quot;pinia&quot;;\n\nexport const useCounterStore &#x3D; defineStore(&quot;counter&quot;, &#123;\n  state: () &#x3D;&gt; &#123;\n    return &#123; count: 0 &#125;;\n  &#125;,\n  &#x2F;&#x2F; could also be defined as\n  &#x2F;&#x2F; state: () &#x3D;&gt; (&#123; count: 0 &#125;)\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n  &#125;,\n&#125;);\n\nAnd then you use it in a component:译：然后你在组件中使用它：\nimport &#123; useCounterStore &#125; from &quot;@&#x2F;stores&#x2F;counter&quot;;\n\nexport default &#123;\n  setup() &#123;\n    const counter &#x3D; useCounterStore();\n\n    counter.count++;\n    &#x2F;&#x2F; with autocompletion ✨\n    counter.$patch(&#123; count: counter.count + 1 &#125;);\n    &#x2F;&#x2F; or using an action instead\n    counter.increment();\n  &#125;,\n&#125;;\n\nYou can even use a function (similar to a component setup()) to define a Store for more advanced use cases:译：你也可以使用函数（与组件setup()相似）来定义一个存储以更高级的使用情况：\nexport const useCounterStore &#x3D; defineStore(&quot;counter&quot;, () &#x3D;&gt; &#123;\n  const count &#x3D; ref(0);\n  function increment() &#123;\n    count.value++;\n  &#125;\n\n  return &#123; count, increment &#125;;\n&#125;);\n\nIf you are still not into setup() and Composition API, don’t worry, Pinia also support a similar set of map helpers like Vuex. You define stores the same way but then use mapStores(), mapState(), or mapActions():译：如果你还不是setup()和 Composition API 的熟悉，不用担心，Pinia 也支持Vuex 的map helpers（如 Vuex）。你定义存储的方式相同，然后使用mapStores(), mapState(),或mapActions()：\nconst useCounterStore &#x3D; defineStore(&quot;counter&quot;, &#123;\n  state: () &#x3D;&gt; (&#123; count: 0 &#125;),\n  getters: &#123;\n    double: (state) &#x3D;&gt; state.count * 2,\n  &#125;,\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n  &#125;,\n&#125;);\n\nconst useUserStore &#x3D; defineStore(&quot;user&quot;, &#123;\n  &#x2F;&#x2F; ...\n&#125;);\n\nexport default &#123;\n  computed: &#123;\n    &#x2F;&#x2F; other computed properties\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; gives access to this.counterStore and this.userStore\n    ...mapStores(useCounterStore, useUserStore),\n    &#x2F;&#x2F; gives read access to this.count and this.double\n    ...mapState(useCounterStore, [&quot;count&quot;, &quot;double&quot;]),\n  &#125;,\n  methods: &#123;\n    &#x2F;&#x2F; gives access to this.increment()\n    ...mapActions(useCounterStore, [&quot;increment&quot;]),\n  &#125;,\n&#125;;\n\nYou will find more information about each map helper in the core concepts.译：你将找到更多关于每个map helper的信息。\nWhy Pinia\n为什么叫 Pinia\nPinia (pronounced /piːnjʌ/, like “peenya” in English) is the closest word to piña (pineapple in Spanish) that is a valid package name. A pineapple is in reality a group of individual flowers that join together to create a multiple fruit. Similar to stores, each one is born individually, but they are all connected at the end. It’s also a delicious tropical fruit indigenous to South America.\nPinia 发音 /piːnjʌ/，类似于英语中的“柠檬”，它是一个有效的包名。一个柠檬是实际上是一组单个花朵结合在一起，以创建多个水果。与存储相似，每一个都是单独出生的，但是他们都是最终连接在一起的。它也是一个在南美洲的美食。\nA more realistic example\n译：更真实的例子Here is a more complete example of the API you will be using with Pinia with types even in JavaScript. For some people, this might be enough to get started without reading further but we still recommend checking the rest of the documentation or even skipping this example and coming back once you have read about all of the Core Concepts.译：这是一个更完整的例子，你将使用 Pinia类型在 JavaScript。对于一些人，这可能是足够开始而不需要阅读更多，但我们仍然建议检查其余的文档或跳过这个例子，然后回来一次你已经阅读了所有的核心概念。\nimport &#123; defineStore &#125; from &quot;pinia&quot;;\n\nexport const todos &#x3D; defineStore(&quot;todos&quot;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    &#x2F;** @type &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125; *&#x2F;\n    todos: [],\n    &#x2F;** @type &#123;&#39;all&#39; | &#39;finished&#39; | &#39;unfinished&#39;&#125; *&#x2F;\n    filter: &quot;all&quot;,\n    &#x2F;&#x2F; type will be automatically inferred to number\n    &#x2F;&#x2F; 类型将自动推断为number\n    nextId: 0,\n  &#125;),\n  getters: &#123;\n    finishedTodos(state) &#123;\n      &#x2F;&#x2F; autocompletion! ✨\n      &#x2F;&#x2F; 自动完成\n      return state.todos.filter((todo) &#x3D;&gt; todo.isFinished);\n    &#125;,\n    unfinishedTodos(state) &#123;\n      return state.todos.filter((todo) &#x3D;&gt; !todo.isFinished);\n    &#125;,\n    &#x2F;**\n     * @returns &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125;\n     *&#x2F;\n    filteredTodos(state) &#123;\n      if (this.filter &#x3D;&#x3D;&#x3D; &quot;finished&quot;) &#123;\n        &#x2F;&#x2F; call other getters with autocompletion ✨\n        &#x2F;&#x2F; 调用其他getters自动完成\n        return this.finishedTodos;\n      &#125; else if (this.filter &#x3D;&#x3D;&#x3D; &quot;unfinished&quot;) &#123;\n        return this.unfinishedTodos;\n      &#125;\n      return this.todos;\n    &#125;,\n  &#125;,\n  actions: &#123;\n    &#x2F;&#x2F; any amount of arguments, return a promise or not\n    &#x2F;&#x2F; 任意数量的参数，返回一个promise或不\n    addTodo(text) &#123;\n      &#x2F;&#x2F; you can directly mutate the state\n      &#x2F;&#x2F; 你可以直接修改状态\n      this.todos.push(&#123; text, id: this.nextId++, isFinished: false &#125;);\n    &#125;,\n  &#125;,\n&#125;);\n\nComparison with Vuex\n译：与 Vuex 比较\nPinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.译：Pinia 开始了一个探索 Vuex 的下一个迭代，并且将大量的想法从 Vuex 5 的核心团队讨论中提取。最终，我们认为 Pinia 已经实现了大部分我们想要的 Vuex 5，并且决定改变它的推荐。Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.译：与 Vuex 比较，Pinia 提供了更简单的 API，提供了组合 API 的 API，并且在使用 TypeScript 时有实体类型支持。\nRFCs\n译：RFCs\n\n\n\n\n\n\n\n\n\nRFCs 涵盖了 Vue 的最基本的四个部分，截至目前为止，已经有 38 个 PR 提交（26 个仍在讨论中），这些提议中既有 Vue 作者自己的提议，也有开发者的提议。\n\nVue core\nVue Router\nVuex\nVue CLI\n\nInitially Pinia didn’t go through any RFC. I tested out ideas based on my experience developing applications, reading other people’s code, working for clients who use Pinia, and answering questions on Discord.This allowed me to provide a solution that works and is adapted to a variety of cases and application sizes. I used to publish often and made the library evolve while keeping its core API the same.译：初始 Pinia 没有通过任何 RFC。我测试了基于我的经验开发应用程序，阅读其他人的代码，为使用 Pinia 的客户工作，并在 Discord 上回答问题。这让我提供了一个解决方案，它工作并适合各种情况和应用程序大小。我经常发布，并在保持核心 API 相同的情况下，使库发展。Now that Pinia has become the default state management solution, it is subject to the same RFC process as other core libraries in the Vue ecosystem and its API has entered a stable state.译：现在，Pinia 已经成为 Vue 的核心状态管理解决方案，它与 Vue 社区中其他核心库的 RFC 进行了相同的处理，并且它的 API 已经进入了一个稳定状态。\nComparison with Vuex 3.x&#x2F;4.x\n译：与 Vuex 3.x&#x2F;4.x 比较\n\n\n\n\n\n\n\n\n\nVuex 3.x is Vuex for Vue 2 while Vuex 4.x is for Vue 3Vuex 3.x 是 Vuex 2 的 Vuex，而 Vuex 4.x 是 Vue 3 的 VuexPinia API is very different from Vuex ≤4, namely:译：Pinia API 与 Vuex 3.x&#x2F;4.x 比较，主要区别是：\n\nmutations no longer exist. They were very often perceived as extremely verbose. They initially brought devtools integration but that is no longer an issue.- mutations 不再存在。它们初始上抛了开发工具集成，但这不再是问题。\nNo need to create custom complex wrappers to support TypeScript, everything is typed and the API is designed in a way to leverage TS type inference as much as possible.- 没有需要创建自定义复杂的包装来支持TypeScript，所有的都是类型化的，API设计了一个让你最大限度地利用TS类型推断的方式。\nNo more magic strings to inject, import the functions, call them, enjoy autocompletion!- 没有更多的魔法字符串注入，导入函数，调用它们，享受自动完成！\nNo need to dynamically add stores, they are all dynamic by default and you won’t even notice. Note you can still manually use a store to register it whenever you want but because it is automatic you don’t need to worry about it.- 没有需要动态添加存储，它们都是默认的动态的，你也不会发现。请注意，你仍然可以手动使用存储来注册它，但是因为它是自动的，你不需要担心它。\nNo more nested structuring of modules. You can still nest stores implicitly by importing and using a store inside another but Pinia offers a flat structuring by design while still enabling ways of cross composition among stores. You can even have circular dependencies of stores.- 没有更多的嵌套结构的_模块_。你仍然可以嵌套存储通过导入并使用存储在另一个存储中，但Pinia提供了一个平面的结构，而且还允许在存储之间跨越组合。**你还可以有圆形依赖的存储**。\nNo namespaced modules. Given the flat architecture of stores, “namespacing” stores is inherent to how they are defined and you could say all stores are namespaced.- 没有_命名空间模块_。给定存储的平面建构，“命名空间”存储是因为它们定义的方式而具有的，你可以说所有的存储都是命名空间。For more detailed instructions on how to convert an existing Vuex ≤4 project to use Pinia, see the Migration from Vuex Guide.译：为了更加详细的指导如何将现有的 Vuex ≤4 项目转换为使用 Pinia，请参阅Migration from Vuex Guide。\n\n起步InstallationInstall pinia with your favorite package manager:译：使用你喜欢的包管理器安装 pinia ：\nyarn add pinia\n# or with npm\nnpm install pinia\n\n\n\n\n\n\n\nTIP\nIf your app is using Vue 2, you also need to install the composition api: @vue/composition-api. If you are using Nuxt, you should follow these instructions.译：如果你的应用使用 Vue 2，你还需要安装组合 api：@vue/composition-api。如果你使用 Nuxt，你应该遵循这些指导。\n\nIf you are using the Vue CLI, you can instead give this unofficial plugin a try._译：如果你使用 Vue CLI，你可以试试这个 [非官方插件](\nCreate a pinia (the root store) and pass it to the app:译：创建一个 pinia （根存储）并将其传递给应用：\nimport &#123; createPinia &#125; from &quot;pinia&quot;;\n\napp.use(createPinia());\n\nIf you are using Vue 2, you also need to install a plugin and inject the created pinia at the root of the app:译：如果你使用 Vue 2，你还需要安装一个插件并将创建的 pinia 注入到应用的根中：\nimport &#123; createPinia, PiniaVuePlugin &#125; from &quot;pinia&quot;;\n\nVue.use(PiniaVuePlugin);\nconst pinia &#x3D; createPinia();\n\nnew Vue(&#123;\n  el: &quot;#app&quot;,\n  &#x2F;&#x2F; other options...\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; note the same &#96;pinia&#96; instance can be used across multiple Vue apps on the same page\n  &#x2F;&#x2F; 注意，同一个 &#96;pinia&#96; 实例可以在同一个页面上的多个 Vue 应用中使用\n  pinia,\n&#125;);\n\nThis will also add devtools support. In Vue 3, some features like time traveling and editing are still not supported because vue-devtools doesn’t expose the necessary APIs yet but the devtools have way more features and the developer experience as a whole is far superior. In Vue 2, Pinia uses the existing interface for Vuex (and can therefore not be used alongside it).译：这也会添加 devtools 支持。在 Vue 3 中，某些功能（例如时间旅行和编辑）仍然不支持，因为 vue-devtools 不暴露了必要的 API，但是 devtools 有更多的功能，开发者体验整体更优。在 Vue 2 中，Pinia 使用现有的 Vuex 接口（因此不能与它一起使用）。\nWhat is a Store?A Store (like Pinia) is an entity holding state and business logic that isn’t bound to your Component tree. In other words, it hosts global state. It’s a bit like a component that is always there and that everybody can read off and write to. It has three concepts, the state, getters and actions and it’s safe to assume these concepts are the equivalent of data, computed and methods in components.译：一个存储（像 Pinia）是一个持有状态和业务逻辑的实体，它不是绑定到你的组件树上的。也就是说，它持有全局状态。它是一个总是存在的组件，每个人都可以读取并写入。它有 三个概念，state，getters 和 actions，并且我们假设这三个概念是组件的 data，computed 和 methods 的等价。\nWhen should I use a StoreA store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.译：一个存储应该包含可以在整个应用程序中访问的数据。这包括在多个地方使用的数据，例如在导航栏中显示的用户信息，以及需要在页面中保留的数据，例如一个复杂的多步骤表单。On the other hand, you should avoid including in the store local data that could be hosted in a component instead, e.g. the visibility of an element local to a page.译：另一方面，你应该避免在存储中包含在组件中存储的本地数据，例如页面中的一个元素的可见性。Not all applications need access to a global state, but if yours need one, Pinia will make your life easier.译：不是所有应用都需要访问全局状态，但如果你的应用需要一个，Pinia 将使你的生活更加方便。\n核心概念StoreDefining a Store\n\nBefore diving into core concepts, we need to know that a store is defined using defineStore() and that it requires a unique name, passed as the first argument:译：在深入核心概念之前，我们需要知道一个存储由 defineStore() 定义并且需要一个 唯一的 名称作为第一个参数：\nimport &#123; defineStore &#125; from &quot;pinia&quot;;\n\n&#x2F;&#x2F; useStore could be anything like useUser, useCart\n&#x2F;&#x2F; the first argument is a unique id of the store across your application\nexport const useStore &#x3D; defineStore(&quot;main&quot;, &#123;\n  &#x2F;&#x2F; other options...\n&#125;);\n\nThis name, also referred as id, is necessary and is used by Pinia to connect the store to the devtools. Naming the returned function use… is a convention across composables to make its usage idiomatic._译：这个名称，也称为 id_，是必需的并且用于连接存储到 devtools。命名返回的函数 use… 是一个组合使用的惯例，使用它的用法简单易懂。Using the store\nWe are defining a store because the store won’t be created until useStore() is called inside of setup():译：我们正在定义一个存储，因为只有在setup（）内部调用useStore（）才能创建该存储\nimport &#123; useStore &#125; from &quot;@&#x2F;stores&#x2F;counter&quot;;\n\nexport default &#123;\n  setup() &#123;\n    const store &#x3D; useStore();\n\n    return &#123;\n      &#x2F;&#x2F; you can return the whole store instance to use it in the template\n      &#x2F;&#x2F; 你可以在模板中返回整个存储实例来使用它\n      store,\n    &#125;;\n  &#125;,\n&#125;;\n\nYou can define as many stores as you want and you should define each store in a different file to get the most out of pinia (like automatically allow your bundle to code split and TypeScript inference).译 ：你可以定义多个存储，你应该在不同的文件中定义每个存储来获得 pinia 的最大效用（例如自动允许你的 bundle 分割和 TypeScript 推断）。If you are not using setup components yet, you can still use Pinia with map helpers.译：如果你还没有使用 setup 组件，你仍然可以使用 Pinia 与 [map 助手]（https://pinia.vuejs.org/cookbook/options-api.html）。Once the store is instantiated, you can access any property defined in state, getters, and actions directly on the store. We will see these in detail in the next pages but autocompletion will help you.译：一旦存储被实例化，你可以直接在存储上访问 state，getters 和 actions 中定义的属性。我们将在下一页中详细讲解，但是自动补全将帮助你。Note that store is an object wrapped with reactive, meaning there is no need to write .value after getters but, like props in setup, we cannot destructure it:译：请注意，存储是一个 reactive 包装的对象，因此不需要写 .value 后面的 getters，但是，像 setup 中的 props，我们不能解构它\nexport default defineComponent(&#123;\n  setup() &#123;\n    const store &#x3D; useStore();\n    &#x2F;&#x2F; ❌ This won&#39;t work because it breaks reactivity it&#39;s the same as destructuring from &#96;props&#96;\n    &#x2F;&#x2F; 这不会工作，因为它会破坏可观察性，它是相同的为 &#96;props&#96; 构造的\n    const &#123; name, doubleCount &#125; &#x3D; store;\n\n    name; &#x2F;&#x2F; &quot;eduardo&quot;\n    doubleCount; &#x2F;&#x2F; 2\n\n    return &#123;\n      &#x2F;&#x2F; will always be &quot;eduardo&quot;\n      &#x2F;&#x2F; 将始终是 &quot;eduardo&quot;\n      name,\n      &#x2F;&#x2F; will always be 2\n      &#x2F;&#x2F; 将始终是 2\n      doubleCount,\n      &#x2F;&#x2F; this one will be reactive\n      &#x2F;&#x2F; 这个将是可观察的\n      doubleValue: computed(() &#x3D;&gt; store.doubleCount),\n    &#125;;\n  &#125;,\n&#125;);\n\nIn order to extract properties from the store while keeping its reactivity, you need to use storeToRefs(). It will create refs for every reactive property. This is useful when you are only using state from the store but not calling any action. Note you can destructure actions directly from the store as they are bound to the store itself too:译：为了从存储中提取属性而保持其可观察性，你需要使用 storeToRefs()。它会创建每个可观察属性的 ref。这对于只使用存储中的状态但不调用任何行为时非常有用。请注意，你可以直接从存储中解构 actions，因为它们都是绑定到存储本身的。\nimport &#123; storeToRefs &#125; from &quot;pinia&quot;;\n\nexport default defineComponent(&#123;\n  setup() &#123;\n    const store &#x3D; useStore();\n    &#x2F;&#x2F; &#96;name&#96; and &#96;doubleCount&#96; are reactive refs\n    &#x2F;&#x2F; This will also create refs for properties added by plugins\n    &#x2F;&#x2F; but skip any action or non reactive (non ref&#x2F;reactive) property\n    const &#123; name, doubleCount &#125; &#x3D; storeToRefs(store);\n    &#x2F;&#x2F; the increment action can be just extracted\n    const &#123; increment &#125; &#x3D; store;\n\n    return &#123;\n      name,\n      doubleCount,\n      increment,\n    &#125;;\n  &#125;,\n&#125;);\n\nState\nThe state is, most of the time, the central part of your store. People often start by defining the state that represents their app. In Pinia the state is defined as a function that returns the initial state. This allows Pinia to work in both Server and Client Side.大多数时候，state是你store的中心。人们通常从定义代表其应用程序的状态开始。在Pinia中，状态定义为返回初始状态的函数。这允许Pinia在服务器端和客户端都工作。\nimport &#123; defineStore &#125; from &quot;pinia&quot;;\n\nconst useStore &#x3D; defineStore(&quot;storeId&quot;, &#123;\n  &#x2F;&#x2F; arrow function recommended for full type inference\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      &#x2F;&#x2F; all these properties will have their type inferred automatically\n      counter: 0,\n      name: &quot;Eduardo&quot;,\n      isAdmin: true,\n    &#125;;\n  &#125;,\n&#125;);\n\n\n\n\n\n\n\nTIP\nIf you are using Vue 2, the data you create in state follows the same rules as the data in a Vue instance, ie the state object must be plain and you need to call Vue.set() when adding new properties to it. See also: Vue#data.如果你使用 Vue 2，在 state 中创建的数据遵循 Vue 实例中的 data 的规则，即 state 对象必须是纯粹的，并且需要在 添加新的 属性时调用 Vue.set()。请参见 Vue#data。\n\nAccessing the state\nBy default, you can directly read and write to the state by accessing it through the store instance:默认情况下，你可以直接读取和写入状态，通过访问 store 实例来访问它：\nconst store &#x3D; useStore();\n\nstore.counter++;\n\nResetting the state\nYou can reset the state to its initial value by calling the $reset() method on the store:你可以通过调用 $reset() 方法来重置状态：\nconst store &#x3D; useStore();\n\nstore.$reset();\n\nUsage with the Options API\n\nFor the following examples, you can assume the following store was created:为了下面的例子，你可以假设以下的存储已创建：\n&#x2F;&#x2F; Example File Path:\n&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.js\n\nimport &#123; defineStore &#125; from &quot;pinia&quot;;\n\nconst useCounterStore &#x3D; defineStore(&quot;counterStore&quot;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0,\n  &#125;),\n&#125;);\n\nIf you are not using the Composition API, and you are using computed, methods, …, you can use the mapState() helper to map state properties as readonly computed properties:如果你不使用 Composition API，并且使用 computed、methods 等，你可以使用 mapState() 帮助器来映射状态属性为只读的计算属性：\nimport &#123; mapState &#125; from &#39;pinia&#39;\nimport &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;\n\nexport default &#123;\n  computed: &#123;\n    &#x2F;&#x2F; gives access to this.counter inside the component\n    &#x2F;&#x2F; same as reading from store.counter\n    ...mapState(useCounterStore, [&#39;counter&#39;])\n    &#x2F;&#x2F; same as above but registers it as this.myOwnName\n    ...mapState(useCounterStore, &#123;\n      myOwnName: &#39;counter&#39;,\n      &#x2F;&#x2F; you can also write a function that gets access to the store\n      double: store &#x3D;&gt; store.counter * 2,\n      &#x2F;&#x2F; it can have access to &#96;this&#96; but it won&#39;t be typed correctly...\n      magicValue(store) &#123;\n        return store.someGetter + this.counter + this.double\n      &#125;,\n    &#125;),\n  &#125;,\n&#125;\n\nModifiable state\nIf you want to be able to write to these state properties (e.g. if you have a form), you can use mapWritableState() instead. Note you cannot pass a function like with mapState():如果你想要写入这些状态属性（例如，如果你有一个表单），你可以使用 mapWritableState()。注意，你不能传递一个函数类似于 mapState()：\nimport &#123; mapWritableState &#125; from &#39;pinia&#39;\nimport &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;\n\nexport default &#123;\n  computed: &#123;\n    &#x2F;&#x2F; gives access to this.counter inside the component and allows setting it\n    &#x2F;&#x2F; this.counter++\n    &#x2F;&#x2F; same as reading from store.counter\n    ...mapWritableState(useCounterStore, [&#39;counter&#39;])\n    &#x2F;&#x2F; same as above but registers it as this.myOwnName\n    ...mapWritableState(useCounterStore, &#123;\n      myOwnName: &#39;counter&#39;,\n    &#125;),\n  &#125;,\n&#125;\n\n\n\n\n\n\n\nTIP\nYou don’t need mapWritableState() for collections like arrays unless you are replacing the whole array with cartItems = [], mapState() still allows you to call methods on your collections.注意，你不需要 mapWritableState() 为集合类型（例如数组），除非你想要替换整个数组为 cartItems = []，mapState() 仍然允许你调用集合的方法。\n\nMutating the state\n\n\nApart from directly mutating the store with store.counter++, you can also call the $patch method. It allows you to apply multiple changes at the same time with a partial state object:除了直接通过 store.counter++ 来修改存储，你也可以调用 $patch() 方法。它允许你同时使用一个部分 state 对象来应用多个变更：\nstore.$patch(&#123;\n  counter: store.counter + 1,\n  name: &quot;Abalam&quot;,\n&#125;);\n\nHowever, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the $patch method also accepts a function to group this kind of mutations that are difficult to apply with a patch object:但是，一些变更非常难或者昂贵地应用，因为它们需要创建一个新的集合。因此，$patch 方法也接受一个函数来组织这种难以应用的变更：\ncartStore.$patch((state) &#x3D;&gt; &#123;\n  state.items.push(&#123; name: &quot;shoes&quot;, quantity: 1 &#125;);\n  state.hasChanged &#x3D; true;\n&#125;);\n\n\n\nThe main difference here is that $patch() allows you to group multiple changes into one single entry in the devtools. Note both, direct changes to state and $patch() appear in the devtools and can be time travelled (not yet in Vue 3)._主要的区别是，$patch() 允许你将多个变更组成一个单独的条目在 devtools 中。注意 **两者都会在 devtools 中出现，并且可以被时间轴追踪（尚未在 Vue 3 中）。_Replacing the state\nYou can replace the whole state of a store by setting its $state property to a new object:你可以通过设置存储的 $state 属性来替换它的状态：\nstore.$state &#x3D; &#123; counter: 666, name: &quot;Paimon&quot; &#125;;\n\nYou can also replace the whole state of your application by changing the state of the pinia instance. This is used during SSR for hydration.你也可以通过更改 pinia 实例的 state 来替换整个应用的状态。这用于 SSR for hydration。\npinia.state.value &#x3D; &#123;&#125;;\n\nSubscribing to the state\nYou can watch the state and its changes through the $subscribe() method of a store, similar to Vuex’s subscribe method. The advantage of using $subscribe() over a regular watch() is that subscriptions will trigger only once after patches (e.g. when using the function version from above).你可以通过存储的 $subscribe() 方法来订阅状态，与 Vuex 的 subscribe 方法 类似。使用 $subscribe() 方法来订阅状态，优势在于它会在变更后只触发一次订阅（例如，使用上面的函数版本）。\ncartStore.$subscribe((mutation, state) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; import &#123; MutationType &#125; from &#39;pinia&#39;\n  mutation.type; &#x2F;&#x2F; &#39;direct&#39; | &#39;patch object&#39; | &#39;patch function&#39;\n  &#x2F;&#x2F; same as cartStore.$id\n  mutation.storeId; &#x2F;&#x2F; &#39;cart&#39;\n  &#x2F;&#x2F; only available with mutation.type &#x3D;&#x3D;&#x3D; &#39;patch object&#39;\n  mutation.payload; &#x2F;&#x2F; patch object passed to cartStore.$patch()\n\n  &#x2F;&#x2F; persist the whole state to the local storage whenever it changes\n  localStorage.setItem(&quot;cart&quot;, JSON.stringify(state));\n&#125;);\n\nBy default, state subscriptions are bound to the component where they are added (if the store is inside a component’s setup()). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass &#123; detached: true &#125; as the second argument to detach the state subscription from the current component:默认情况下，_状态订阅_会绑定到添加它的组件（如果存储在组件的 setup() 中）。意味着，它会在组件卸载后自动删除。如果你想要在组件卸载后保持它们，可以将 &#123; detached: true &#125; 作为第二个参数传递给 detach 状态订阅 从当前组件：\nexport default &#123;\n  setup() &#123;\n    const someStore &#x3D; useSomeStore();\n\n    &#x2F;&#x2F; this subscription will be kept after the component is unmounted\n    someStore.$subscribe(callback, &#123; detached: true &#125;);\n\n    &#x2F;&#x2F; ...\n  &#125;,\n&#125;;\n\n\n\n\n\n\n\nTIP\nYou can watch the whole state on the pinia instance:你可以监听整个pinia实例的状态，这个状态是一个对象，包含了所有的store的状态。\nwatch(\n  pinia.state,\n  (state) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; persist the whole state to the local storage whenever it changes\n    localStorage.setItem(&quot;piniaState&quot;, JSON.stringify(state));\n  &#125;,\n  &#123; deep: true &#125;\n);\n\n\n\nGetters\nGetters are exactly the equivalent of computed values for the state of a Store. They can be defined with the getters property in defineStore(). They receive the state as the first parameter to encourage the usage of arrow function:获取器是状态的计算值。它们可以通过 defineStore() 中的 getters 属性来定义。它们会接收 state（使用箭头函数） 作为第一个参数，：\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0,\n  &#125;),\n  getters: &#123;\n    doubleCount: (state) &#x3D;&gt; state.counter * 2,\n  &#125;,\n&#125;)\n\nMost of the time, getters will only rely on the state, however, they might need to use other getters. Because of this, we can get access to the whole store instance through this when defining a regular function but it is necessary to define the type of the return type (in TypeScript). This is due to a known limitation in TypeScript and doesn’t affect getters defined with an arrow function nor getters not using this:大多数情况下，获取器只依赖于状态，但它们可能需要使用其他获取器。因此，我们可以通过 this 访问到整个存储实例（但是需要在TypeScript中定义返回类型），这是因为已知的限制，不影响使用箭头函数或不使用this的获取器：\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0,\n  &#125;),\n  getters: &#123;\n    &#x2F;&#x2F; automatically infers the return type as a number\n    &#x2F;&#x2F; 自动推断返回类型为数字\n    doubleCount(state) &#123;\n      return state.counter * 2\n    &#125;,\n    &#x2F;&#x2F; the return type **must** be explicitly set\n    &#x2F;&#x2F;  返回类型 **必须** 被显式设置\n    doublePlusOne(): number &#123;\n      &#x2F;&#x2F; autocompletion and typings for the whole store ✨\n      &#x2F;&#x2F; 对于整个store自动完成和类型推断 ✨\n      return this.doubleCount + 1\n    &#125;,\n  &#125;,\n&#125;)\n\nThen you can access the getter directly on the store instance:然后你可以直接在存储实例上访问获取器：\n&lt;template&gt;\n  &lt;p&gt;Double count is &#123;&#123; store.doubleCount &#125;&#125;&lt;&#x2F;p&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  setup() &#123;\n    const store &#x3D; useStore()\n\n    return &#123; store &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\nAccessing other gettersAs with computed properties, you can combine multiple getters. Access any other getter via this. Even if you are not using TypeScript, you can hint your IDE for types with the JSDoc:如同计算属性，你可以将多个获取器组合在一起。通过 this 访问其他获取器。即使你不使用TypeScript，你也可以通过JSDoc提示你的IDE类型：\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0,\n  &#125;),\n  getters: &#123;\n    &#x2F;&#x2F; type is automatically inferred because we are not using &#96;this&#96;\n    &#x2F;&#x2F; 类型自动推断，因为我们不使用&#96;this&#96;\n    doubleCount: (state) &#x3D;&gt; state.counter * 2,\n    &#x2F;&#x2F; here we need to add the type ourselves (using JSDoc in JS). We can also\n    &#x2F;&#x2F; use this to document the getter\n    &#x2F;&#x2F; 在这里我们需要自己添加类型（使用JSDoc在JS）。我们也可以用这个来描述获取器\n    &#x2F;**\n     * Returns the counter value times two plus one.\n     *\n     * @returns &#123;number&#125;\n     *&#x2F;\n    doubleCountPlusOne() &#123;\n      &#x2F;&#x2F; autocompletion ✨\n      return this.doubleCount + 1\n    &#125;,\n  &#125;,\n&#125;)\n\nPassing arguments to gettersGetters are just computed properties behind the scenes, so it’s not possible to pass any parameters to them. However, you can return a function from the getter to accept any arguments:获取器是组件的计算属性，因此不能传递任何参数。然而，你可以从获取器返回一个函数，接受任何参数：\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  getters: &#123;\n    getUserById: (state) &#x3D;&gt; &#123;\n      return (userId) &#x3D;&gt; state.users.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)\n    &#125;,\n  &#125;,\n&#125;)\n\nand use in component:在组件中使用：\n&lt;script&gt;\nexport default &#123;\n  setup() &#123;\n    const store &#x3D; useStore()\n\n    return &#123; getUserById: store.getUserById &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\n  &lt;p&gt;User 2: &#123;&#123; getUserById(2) &#125;&#125;&lt;&#x2F;p&gt;\n&lt;&#x2F;template&gt;\n\nNote that when doing this, getters are not cached anymore, they are simply functions that you invoke. You can however cache some results inside of the getter itself, which is uncommon but should prove more performant:注意，当这做的时候，获取器不再缓存了，它们是一个函数，你可以在获取器内部缓存一些结果，这是一种比较常见的情况，但是应该更有效率：\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  getters: &#123;\n    getActiveUserById(state) &#123;\n      const activeUsers &#x3D; state.users.filter((user) &#x3D;&gt; user.active)\n      return (userId) &#x3D;&gt; activeUsers.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)\n    &#125;,\n  &#125;,\n&#125;)\n\nAccessing other stores gettersTo use another store getters, you can directly use it inside of the getter:要使用另一个存储获取器，可以直接在获取器中_使用它_：\nimport &#123; useOtherStore &#125; from &#39;.&#x2F;other-store&#39;\n\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    &#x2F;&#x2F; ...\n  &#125;),\n  getters: &#123;\n    otherGetter(state) &#123;\n      const otherStore &#x3D; useOtherStore()\n      return state.localData + otherStore.data\n    &#125;,\n  &#125;,\n&#125;)\n\nUsage with setup()You can directly access any getter as a property of the store (exactly like state properties):你可以直接在存储中作为属性访问任何获取器（精准地如同状态属性）：\nexport default &#123;\n  setup() &#123;\n    const store &#x3D; useStore()\n\n    store.counter &#x3D; 3\n    store.doubleCount &#x2F;&#x2F; 6\n  &#125;,\n&#125;\n\nUsage with the Options API\nFor the following examples, you can assume the following store was created:对于下面的例子，你可以假设以下存储已创建：\n&#x2F;&#x2F; Example File Path:\n&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.js\n\nimport &#123; defineStore &#125; from &#39;pinia&#39;,\n\nconst useCounterStore &#x3D; defineStore(&#39;counterStore&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0\n  &#125;),\n  getters: &#123;\n    doubleCounter(state) &#123;\n      return state.counter * 2\n    &#125;\n  &#125;\n&#125;)\n\nWith setup()While Composition API is not for everyone, the setup() hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!而不是所有人都需要使用组合API，setup()钩子可以让Pinia更容易地在Options API中使用。没有额外的映射助手函数需要！\n这是一个优点import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;\n\nexport default &#123;\n  setup() &#123;\n    const counterStore &#x3D; useCounterStore()\n\n    return &#123; counterStore &#125;\n  &#125;,\n  computed: &#123;\n    quadrupleCounter() &#123;\n      return this.counterStore.doubleCounter * 2\n    &#125;,\n  &#125;,\n&#125;\n\nWithout setup()You can use the same mapState() function used in the previous section of state to map to getters:你可以使用在上一节状态中使用的mapState()函数来映射到获取器：\nimport &#123; mapState &#125; from &#39;pinia&#39;\nimport &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;\n\nexport default &#123;\n  computed: &#123;\n    &#x2F;&#x2F; gives access to this.doubleCounter inside the component\n    &#x2F;&#x2F; same as reading from store.doubleCounter\n    ...mapState(useCounterStore, [&#39;doubleCount&#39;])\n    &#x2F;&#x2F; same as above but registers it as this.myOwnName\n    ...mapState(useCounterStore, &#123;\n      myOwnName: &#39;doubleCounter&#39;,\n      &#x2F;&#x2F; you can also write a function that gets access to the store\n      double: store &#x3D;&gt; store.doubleCount,\n    &#125;),\n  &#125;,\n&#125;\n\nActions\nActions are the equivalent of methods in components. They can be defined with the actions property in defineStore() and they are perfect to define business logic:在defineStore()中定义的actions属性是组件的方法，它们可以用来定义业务逻辑：\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0,\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.counter++\n    &#125;,\n    randomizeCounter() &#123;\n      this.counter &#x3D; Math.round(100 * Math.random())\n    &#125;,\n  &#125;,\n&#125;)\n\nLike getters, actions get access to the whole store instance through this with full typing (and autocompletion ✨) support. Unlike getters, actions can be asynchronous, you can await inside of actions any API call or even other actions! Here is an example using Mande. Note the library you use doesn’t matter as long as you get a Promise, you could even use the native fetch function (browser only):像获取器一样，actions可以通过this访问整个存储实例，它们可以是异步的，你可以在actions中使用await任何API调用或者可以使用其他actions！这里是一个使用[Mande](\nimport &#123; mande &#125; from &#39;mande&#39;\n\nconst api &#x3D; mande(&#39;&#x2F;api&#x2F;users&#39;)\n\nexport const useUsers &#x3D; defineStore(&#39;users&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    userData: null,\n    &#x2F;&#x2F; ...\n  &#125;),\n\n  actions: &#123;\n    async registerUser(login, password) &#123;\n      try &#123;\n        this.userData &#x3D; await api.post(&#123; login, password &#125;)\n        showTooltip(&#96;Welcome back $&#123;this.userData.name&#125;!&#96;)\n      &#125; catch (error) &#123;\n        showTooltip(error)\n        &#x2F;&#x2F; let the form component display the error\n        return error\n      &#125;\n    &#125;,\n  &#125;,\n&#125;)\n\nYou are also completely free to set whatever arguments you want and return anything. When calling actions, everything will be automatically inferred!你可以设置任何参数和返回任何东西，当调用actions时，所有的东西都会自动推断！Actions are invoked like methods:actions像方法被调用：\nexport default defineComponent(&#123;\n  setup() &#123;\n    const main &#x3D; useMainStore()\n    &#x2F;&#x2F; call the action as a method of the store\n    main.randomizeCounter()\n\n    return &#123;&#125;\n  &#125;,\n&#125;)\n\nAccessing other stores actionsTo use another store, you can directly use it inside of the action:要使用另一个存储，你可以直接在_action_中使用它：\n这比react好用，可以嵌套import &#123; useAuthStore &#125; from &#39;.&#x2F;auth-store&#39;\n\nexport const useSettingsStore &#x3D; defineStore(&#39;settings&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    preferences: null,\n    &#x2F;&#x2F; ...\n  &#125;),\n  actions: &#123;\n    async fetchUserPreferences() &#123;\n      const auth &#x3D; useAuthStore()\n      if (auth.isAuthenticated) &#123;\n        this.preferences &#x3D; await fetchPreferences()\n      &#125; else &#123;\n        throw new Error(&#39;User must be authenticated&#39;)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;)\n\nUsage with setup()You can directly call any action as a method of the store:你可以直接调用任何action作为store的方法：\nexport default &#123;\n  setup() &#123;\n    const store &#x3D; useStore()\n\n    store.randomizeCounter()\n  &#125;,\n&#125;\n\nUsage with the Options API\nFor the following examples, you can assume the following store was created:对于下面的例子，你可以假设以下的存储已经创建：\n&#x2F;&#x2F; Example File Path:\n&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.js\n\nimport &#123; defineStore &#125; from &#39;pinia&#39;,\n\nconst useCounterStore &#x3D; defineStore(&#39;counterStore&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.counter++\n    &#125;\n  &#125;\n&#125;)\n\nWith setup()While Composition API is not for everyone, the setup() hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!Composition API不是所有人都能用，但是setup()钩子可以让Pinia更加简单地使用在Options API中，不需要额外的映射功能！\nimport &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;\n\nexport default &#123;\n  setup() &#123;\n    const counterStore &#x3D; useCounterStore()\n\n    return &#123; counterStore &#125;\n  &#125;,\n  methods: &#123;\n    incrementAndPrint() &#123;\n      this.counterStore.increment()\n      console.log(&#39;New Count:&#39;, this.counterStore.count)\n    &#125;,\n  &#125;,\n&#125;\n\nWithout setup()If you would prefer not to use Composition API at all, you can use the mapActions() helper to map actions properties as methods in your component:如果你想不使用Composition API，你可以使用mapActions()助手来将actions属性映射为组件的方法：\nimport &#123; mapActions &#125; from &#39;pinia&#39;\nimport &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;\n\nexport default &#123;\n  methods: &#123;\n    &#x2F;&#x2F; gives access to this.increment() inside the component\n    &#x2F;&#x2F; same as calling from store.increment()\n    ...mapActions(useCounterStore, [&#39;increment&#39;])\n    &#x2F;&#x2F; same as above but registers it as this.myOwnName()\n    ...mapActions(useCounterStore, &#123; myOwnName: &#39;doubleCounter&#39; &#125;),\n  &#125;,\n&#125;\n\nSubscribing to actionsIt is possible to observe actions and their outcome with store.$onAction(). The callback passed to it is executed before the action itself. after handle promises and allows you to execute a function after the action resolves. In a similar way, onError allows you execute a function if the action throws or rejects. These are useful for tracking errors at runtime, similar to this tip in the Vue docs.可以使用store.$onAction()来观察actions和它们的结果。传入的回调会在action自身之前执行。after处理promises，允许你在action解决之后执行一个函数。同样，onError允许你在action抛出或者reject之后执行一个函数。这些是用于跟踪运行时错误的好方法，类似于这个提示在Vue文档。Here is an example that logs before running actions and after they resolve&#x2F;reject.这是一个例子，它会在执行actions之前和之后解决&#x2F;reject。\nconst unsubscribe &#x3D; someStore.$onAction(\n  (&#123;\n    name, &#x2F;&#x2F; name of the action\n    store, &#x2F;&#x2F; store instance, same as &#96;someStore&#96;\n    args, &#x2F;&#x2F; array of parameters passed to the action\n    after, &#x2F;&#x2F; hook after the action returns or resolves\n    onError, &#x2F;&#x2F; hook if the action throws or rejects\n  &#125;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; a shared variable for this specific action call\n    &#x2F;&#x2F; 共享变量，这个特定的action调用\n    const startTime &#x3D; Date.now()\n    &#x2F;&#x2F; this will trigger before an action on &#96;store&#96; is executed\n    &#x2F;&#x2F; 这将触发在&#96;store&#96;上执行action之前\n    console.log(&#96;Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#39;, &#39;)&#125;].&#96;)\n\n    &#x2F;&#x2F; this will trigger if the action succeeds and after it has fully run.\n    &#x2F;&#x2F; 这将触发如果action成功并且完成运行。\n    &#x2F;&#x2F; it waits for any returned promised\n    &#x2F;&#x2F;  它等待任何返回的promised\n    after((result) &#x3D;&gt; &#123;\n      console.log(\n        &#96;Finished &quot;$&#123;name&#125;&quot; after $&#123;\n          Date.now() - startTime\n        &#125;ms.\\nResult: $&#123;result&#125;.&#96;\n      )\n    &#125;)\n\n    &#x2F;&#x2F; this will trigger if the action throws or returns a promise that rejects\n    &#x2F;&#x2F;  这将触发如果action抛出或者返回一个promise，reject\n    onError((error) &#x3D;&gt; &#123;\n      console.warn(\n        &#96;Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.&#96;\n      )\n    &#125;)\n  &#125;\n)\n\n&#x2F;&#x2F; manually remove the listener\n&#x2F;&#x2F; 手动移除监听器\nunsubscribe()\n\nBy default, action subscriptions are bound to the component where they are added (if the store is inside a component’s setup()). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass true as the second argument to detach the action subscription from the current component:默认情况下，action订阅是绑定到添加它们的组件（如果store在组件的setup中）。意思是，它们会在组件被卸载后自动移除。如果你想要保持它们在组件被卸载后，将第二个参数传递给_detach_action订阅_从当前组件：\nexport default &#123;\n  setup() &#123;\n    const someStore &#x3D; useSomeStore()\n\n    &#x2F;&#x2F; this subscription will be kept after the component is unmounted\n    someStore.$onAction(callback, true)\n\n    &#x2F;&#x2F; ...\n  &#125;,\n&#125;\n\n\nPluginsPinia stores can be fully extended thanks to a low level API. Here is a list of things you can do:Pinia stores可以完全扩展，通过一个低级API。这是一个列表，你可以做的事情：\n\nAdd new properties to stores 给stores添加新的属性\nAdd new options when defining stores 在定义stores时添加新的选项\nAdd new methods to stores 给stores添加新的方法\nWrap existing methods 包装现有的方法\nChange or even cancel actions 改变或取消actions\nImplement side effects like Local Storage 实现副作用效果，例如localStorage\nApply only to specific stores 只应用到特定的stores\n\nPlugins are added to the pinia instance with pinia.use(). The simplest example is adding a static property to all stores by returning an object:插件是添加到pinia实例的pinia.use()。最简单的例子是添加一个静态属性到所有stores，通过返回一个对象：\nimport &#123; createPinia &#125; from &#39;pinia&#39;\n\n&#x2F;&#x2F; add a property named &#96;secret&#96; to every store that is created after this plugin is installed\n&#x2F;&#x2F; this could be in a different file\nfunction SecretPiniaPlugin() &#123;\n  return &#123; secret: &#39;the cake is a lie&#39; &#125;\n&#125;\n\nconst pinia &#x3D; createPinia()\n&#x2F;&#x2F; give the plugin to pinia\npinia.use(SecretPiniaPlugin)\n\n&#x2F;&#x2F; in another file\nconst store &#x3D; useStore()\nstore.secret &#x2F;&#x2F; &#39;the cake is a lie&#39;\n\nThis is useful to add global objects like the router, modal, or toast managers.这是有用的，例如router、modal或toast管理器\nIntroductionA Pinia plugin is a function that optionally returns properties to be added to a store. It takes one optional argument, a context:一个Pinia插件是一个可选的返回属性的函数。它只接受一个可选的参数，一个_context_：\nexport function myPiniaPlugin(context) &#123;\n  context.pinia &#x2F;&#x2F; the pinia created with &#96;createPinia()&#96; \n  context.app &#x2F;&#x2F; the current app created with &#96;createApp()&#96; (Vue 3 only)\n  context.store &#x2F;&#x2F; the store the plugin is augmenting\n  context.options &#x2F;&#x2F; the options object defining the store passed to &#96;defineStore()&#96;\n  &#x2F;&#x2F; ...\n&#125;\n\nThis function is then passed to pinia with pinia.use():这个函数是通过pinia.use()传递给pinia：\npinia.use(myPiniaPlugin)\n\nPlugins are only applied to stores created after pinia is passed to the app, otherwise they won’t be applied.插件只应用到stores 在pinia被传递给app后创建，否则它们不会应用\nAugmenting a StoreYou can add properties to every store by simply returning an object of them in a plugin:你可以通过返回一个对象来给每个store添加属性\npinia.use(() &#x3D;&gt; (&#123; hello: &#39;world&#39; &#125;))\n\nYou can also set the property directly on the store but if possible use the return version so they can be automatically tracked by devtools:你也可以直接给store设置属性，但是如果可能，请使用返回版本，以便它们可以被自动追踪\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  store.hello &#x3D; &#39;world&#39;\n&#125;)\n\nAny property returned by a plugin will be automatically tracked by devtools so in order to make hello visible in devtools, make sure to add it to store._customProperties in dev mode only if you want to debug it in devtools:_任何插件返回的属性都会被自动追踪被devtools追踪，所以要让hello可见在devtools，请在dev模式下，如果你想要调试它在devtools，请在store.customProperties中添加它：\n&#x2F;&#x2F; from the example above\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  store.hello &#x3D; &#39;world&#39;\n  &#x2F;&#x2F; make sure your bundler handle this. webpack and vite should do it by default\n  &#x2F;&#x2F; 确定你的bundler处理这个。默认情况webpack和vite应该做它\n  if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;\n    &#x2F;&#x2F; add any keys you set on the store\n    &#x2F;&#x2F; 在store上添加任何你设置的键\n    store._customProperties.add(&#39;hello&#39;)\n  &#125;\n&#125;)\n\nNote that every store is wrapped with reactive, automatically unwrapping any Ref (ref(), computed(), …) it contains:注意，每个store都会被包裹在reactive，自动解开任何Ref（ref(), computed(), …）它包含：\nconst sharedRef &#x3D; ref(&#39;shared&#39;)\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; each store has its individual &#96;hello&#96; property\n  &#x2F;&#x2F; 每个store都有它自己的&#96;hello&#96;属性\n  store.hello &#x3D; ref(&#39;secret&#39;)\n  &#x2F;&#x2F; it gets automatically unwrapped\n  &#x2F;&#x2F; 这会被自动解开\n  store.hello &#x2F;&#x2F; &#39;secret&#39;\n\n  &#x2F;&#x2F; all stores are sharing the value &#96;shared&#96; property\n  &#x2F;&#x2F; 所有store共享&#96;shared&#96;属性\n  store.shared &#x3D; sharedRef\n  store.shared &#x2F;&#x2F; &#39;shared&#39;\n&#125;)\n\nThis is why you can access all computed properties without .value and why they are reactive.这是为什么你可以不使用.value来访问所有计算属性，并且它们是反应性的\nAdding new stateIf you want to add new state properties to a store or properties that are meant to be used during hydration, you will have to add it in two places:如果你想要给store或者想要在同构时使用的属性，你需要在两处添加：\n\nOn the store so you can access it with store.myState 在store上你可以通过store.myState访问它\nOn store.$state so it can be used in devtools and, be serialized during SSR. 在store.$state上你可以访问它在devtools和，在SSR时会被序列化\n\nOn top of that, you will certainly have to use a ref() (or other reactive API) in order to share the value across different accesses:在顶部，你必须使用ref()（或其他反应性API）来共享值：\nimport &#123; toRef, ref &#125; from &#39;vue&#39;\n\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; to correctly handle SSR, we need to make sure we are not overriding an\n  &#x2F;&#x2F; existing value\n  &#x2F;&#x2F; 为了正确处理SSR，我们需要确保我们不会覆盖现有值\n  if (!Object.prototype.hasOwnProperty(store.$state, &#39;hasError&#39;)) &#123;\n    &#x2F;&#x2F; hasError is defined within the plugin, so each store has their individual\n    &#x2F;&#x2F; state property\n    &#x2F;&#x2F; hasError是在插件中定义的，所以每个store都有它自己的状态属性\n    const hasError &#x3D; ref(false)\n    &#x2F;&#x2F; setting the variable on &#96;$state&#96;, allows it be serialized during SSR\n    &#x2F;&#x2F; 设置它在&#96;$state&#96;，这样它可以在SSR时被序列化\n    store.$state.hasError &#x3D; hasError\n  &#125;\n  &#x2F;&#x2F; we need to transfer the ref from the state to the store, this way\n  &#x2F;&#x2F; both accesses: store.hasError and store.$state.hasError will work\n  &#x2F;&#x2F; and share the same variable\n  &#x2F;&#x2F; 我们需要将ref从状态传递给store，这样两个访问：store.hasError和store.$state.hasError都可以使用，并且共享相同的变量\n  &#x2F;&#x2F; See https:&#x2F;&#x2F;vuejs.org&#x2F;api&#x2F;reactivity-utilities.html#toref\n  store.hasError &#x3D; toRef(store.$state, &#39;hasError&#39;)\n\n  &#x2F;&#x2F; in this case it&#39;s better not to return &#96;hasError&#96; since it\n  &#x2F;&#x2F; will be displayed in the &#96;state&#96; section in the devtools\n  &#x2F;&#x2F; anyway and if we return it, devtools will display it twice.\n  &#x2F;&#x2F; 在这种情况下，我们不应该返回&#96;hasError&#96;，因为它将在devtools的&#96;state&#96;部分显示两次\n&#125;)\n\nNote that state changes or additions that occur within a plugin (that includes calling store.$patch()) happen before the store is active and therefore do not trigger any subscriptions.注意，在插件中（包括调用store.$patch()）发生的状态变化或添加（包括调用store.$patch()）不会触发任何订阅。:::warningIf you are using Vue 2, Pinia is subject to the same reactivity caveats as Vue. You will need to use set from @vue/composition-api when creating new state properties like secret and hasError:如果你使用Vue 2，Pinia将受到同类型反应性问题。你需要使用set来创建新的状态属性，如secret和hasError：\nimport &#123; set, toRef &#125; from &#39;@vue&#x2F;composition-api&#39;\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  if (!Object.prototype.hasOwnProperty(store.$state, &#39;hello&#39;)) &#123;\n    const secretRef &#x3D; ref(&#39;secret&#39;)\n    &#x2F;&#x2F; If the data is meant to be used during SSR, you should\n    &#x2F;&#x2F; set it on the &#96;$state&#96; property so it is serialized and\n    &#x2F;&#x2F; picked up during hydration\n    &#x2F;&#x2F; 如果数据是在SSR时使用的，你应该将它设置在&#96;$state&#96;属性，这样它将被序列化并在同构时被提取\n    set(store.$state, &#39;secret&#39;, secretRef)\n  &#125;\n  &#x2F;&#x2F; set it directly on the store too so you can access it\n  &#x2F;&#x2F; both ways: &#96;store.$state.secret&#96; &#x2F; &#96;store.secret&#96;\n  &#x2F;&#x2F; 在store上直接设置它，这样你可以在两种方式：&#96;store.$state.secret&#96; &#x2F; &#96;store.secret&#96;\n  set(store, &#39;secret&#39;, toRef(store.$state, &#39;secret&#39;))\n  store.secret &#x2F;&#x2F; &#39;secret&#39;\n&#125;)\n\n:::\nAdding new external propertiesWhen adding external properties, class instances that come from other libraries, or simply things that are not reactive, you should wrap the object with markRaw() before passing it to pinia. Here is an example adding the router to every store:当添加外部属性时，类实例来自其他库，或者只是不反应性的东西，你应该在传递之前使用markRaw()。这是一个例子，将路由添加到每个store：\nimport &#123; markRaw &#125; from &#39;vue&#39;\n&#x2F;&#x2F; adapt this based on where your router is\n&#x2F;&#x2F; 基于你的路由在这里适配\nimport &#123; router &#125; from &#39;.&#x2F;router&#39;\n\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  store.router &#x3D; markRaw(router)\n&#125;)\n\nCalling $subscribe inside pluginsYou can use store.$subscribe and store.$onAction inside plugins too:你可以在插件中使用store.$subscribe和store.$onAction：\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  store.$subscribe(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; react to store changes\n    &#x2F;&#x2F; 响应store变化\n  &#125;)\n  store.$onAction(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; react to store actions\n    &#x2F;&#x2F; 响应store动作\n  &#125;)\n&#125;)\n\nAdding new optionsIt is possible to create new options when defining stores to later on consume them from plugins. For example, you could create a debounce option that allows you to debounce any action:可以在定义store时创建新的选项，以便以后从插件中消费。例如，你可以创建一个debounce选项，允许你将任何动作debounce：\ndefineStore(&#39;search&#39;, &#123;\n  actions: &#123;\n    searchContacts() &#123;\n      &#x2F;&#x2F; ...\n    &#125;,\n  &#125;,\n\n  &#x2F;&#x2F; this will be read by a plugin later on\n  &#x2F;&#x2F; 将被插件后面读取\n  debounce: &#123;\n    &#x2F;&#x2F; debounce the action searchContacts by 300ms\n    &#x2F;&#x2F; 延迟动作searchContacts 300ms\n    searchContacts: 300,\n  &#125;,\n&#125;)\n\nThe plugin can then read that option to wrap actions and replace the original ones:插件可以读取这个选项，以便包装动作并替换原始动作：\n&#x2F;&#x2F; use any debounce library\nimport debounce from &#39;lodash&#x2F;debounce&#39;\n\npinia.use((&#123; options, store &#125;) &#x3D;&gt; &#123;\n  if (options.debounce) &#123;\n    &#x2F;&#x2F; we are overriding the actions with new ones\n    &#x2F;&#x2F; 我们覆盖了动作 compose\n    return Object.keys(options.debounce).reduce((debouncedActions, action) &#x3D;&gt; &#123;\n      debouncedActions[action] &#x3D; debounce(\n        store[action],\n        options.debounce[action]\n      )\n      return debouncedActions\n    &#125;, &#123;&#125;)\n  &#125;\n&#125;)\n\nNote that custom options are passed as the 3rd argument when using the setup syntax:注意，自定义选项会作为第三个参数传递给setup语法：\ndefineStore(\n  &#39;search&#39;,\n  () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...\n  &#125;,\n  &#123;\n    &#x2F;&#x2F; this will be read by a plugin later on\n    &#x2F;&#x2F; 将被插件后面读取\n    debounce: &#123;\n      &#x2F;&#x2F; debounce the action searchContacts by 300ms\n      &#x2F;&#x2F; 延迟动作searchContacts 300ms\n      searchContacts: 300,\n    &#125;,\n  &#125;\n)\n\nTypeScriptEverything shown above can be done with typing support, so you don’t ever need to use any or @ts-ignore.所有上面的都可以使用类型支持，所以你永远不需要使用any或@ts-ignore。\nTyping pluginsA Pinia plugin can be typed as follows:一个Pinia插件可以如下类型：\nimport &#123; PiniaPluginContext &#125; from &#39;pinia&#39;\n\nexport function myPiniaPlugin(context: PiniaPluginContext) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nTyping new store propertiesWhen adding new properties to stores, you should also extend the PiniaCustomProperties interface.当添加新的属性到store时，你应该同时扩展PiniaCustomProperties接口。\nimport &#39;pinia&#39;\n\ndeclare module &#39;pinia&#39; &#123;\n  export interface PiniaCustomProperties &#123;\n    &#x2F;&#x2F; by using a setter we can allow both strings and refs\n    &#x2F;&#x2F; 使用setter，我们可以允许字符串和refs\n    set hello(value: string | Ref&lt;string&gt;)\n    get hello(): string\n\n    &#x2F;&#x2F; you can define simpler values too\n    &#x2F;&#x2F; 你也可以定义简单的值\n    simpleNumber: number\n  &#125;\n&#125;\n\nIt can then be written and read safely:然后可以安全的写和读：\npinia.use((&#123; store &#125;) &#x3D;&gt; &#123;\n  store.hello &#x3D; &#39;Hola&#39;\n  store.hello &#x3D; ref(&#39;Hola&#39;)\n\n  store.simpleNumber &#x3D; Math.random()\n  &#x2F;&#x2F; @ts-expect-error: we haven&#39;t typed this correctly\n  store.simpleNumber &#x3D; ref(Math.random())\n&#125;)\n\nPiniaCustomProperties is a generic type that allows you to reference properties of a store. Imagine the following example where we copy over the initial options as $options (this would only work for option stores):PiniaCustomProperties是一个泛型类型，允许你引用store的属性。假设我们将初始选项复制到$options（这只对选项store有效）：\npinia.use((&#123; options &#125;) &#x3D;&gt; (&#123; $options: options &#125;))\n\nWe can properly type this by using the 4 generic types of PiniaCustomProperties:我们可以通过使用PiniaCustomProperties的4个泛型类型来确定类型：\nimport &#39;pinia&#39;\n\ndeclare module &#39;pinia&#39; &#123;\n  export interface PiniaCustomProperties&lt;Id, S, G, A&gt; &#123;\n    $options: &#123;\n      id: Id\n      state?: () &#x3D;&gt; S\n      getters?: G\n      actions?: A\n    &#125;\n  &#125;\n&#125;\n\n\n\n\n\n\n\nTIP\nWhen extending types in generics, they must be named exactly as in the source code. Id cannot be named id or I, and S cannot be named State. Here is what every letter stands for:在泛型中扩展类型时，它们必须与源代码中的名称完全一致。Id不能命名为id或I，S不能命名为State。这里是每个字母的含义：\n\nS: State\nG: Getters\nA: Actions\nSS: Setup Store &#x2F; Store\n\n\n\nTyping new stateWhen adding new state properties (to both, the store and store.$state), you need to add the type to PiniaCustomStateProperties instead. Differently from PiniaCustomProperties, it only receives the State generic:当添加新的状态属性（到store和store.$state）时，你需要添加类型到PiniaCustomStateProperties，不同于PiniaCustomProperties，它只接收State泛型：\nimport &#39;pinia&#39;\n\ndeclare module &#39;pinia&#39; &#123;\n  export interface PiniaCustomStateProperties&lt;S&gt; &#123;\n    hello: string\n  &#125;\n&#125;\n\nTyping new creation optionsWhen creating new options for defineStore(), you should extend the DefineStoreOptionsBase. Differently from PiniaCustomProperties, it only exposes two generics: the State and the Store type, allowing you to limit what can be defined. For example, you can use the names of the actions:当创建新的选项fordefineStore()时，你应该扩展DefineStoreOptionsBase。不同于PiniaCustomProperties，它只公开两个泛型：状态和store类型，允许你限制可以定义。例如，你可以使用actions的名称：\nimport &#39;pinia&#39;\n\ndeclare module &#39;pinia&#39; &#123;\n  export interface DefineStoreOptionsBase&lt;S, Store&gt; &#123;\n    &#x2F;&#x2F; allow defining a number of ms for any of the actions\n    &#x2F;&#x2F; 允许定义任意的ms的任何一个actions\n    debounce?: Partial&lt;Record&lt;keyof StoreActions&lt;Store&gt;, number&gt;&gt;\n  &#125;\n&#125;\n\n\n\n\n\n\n\nTIP\nThere is also a StoreGetters type to extract the getters from a Store type. You can also extend the options of setup stores or option stores only by extending the types DefineStoreOptions and DefineSetupStoreOptions respectively.有一个StoreGetters类型来提取store的_getters_。你也可以扩展_setup stores_或_option stores_的选项，只需扩展typesDefineStoreOptions和DefineSetupStoreOptions。\n\nNuxt.jsWhen using pinia alongside Nuxt, you will have to create a Nuxt plugin first. This will give you access to the pinia instance:当使用pinia与Nuxt一起使用（ssr&#x2F;nuxt.md），你需要先创建一个Nuxt plugin。这将会给你访问pinia实例：\n&#x2F;&#x2F; plugins&#x2F;myPiniaPlugin.js\nimport &#123; PiniaPluginContext &#125; from &#39;pinia&#39;\nimport &#123; Plugin &#125; from &#39;@nuxt&#x2F;types&#39;\n\nfunction MyPiniaPlugin(&#123; store &#125;: PiniaPluginContext) &#123;\n  store.$subscribe((mutation) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; react to store changes\n    &#x2F;&#x2F; 响应store变化\n    console.log(&#96;[🍍 $&#123;mutation.storeId&#125;]: $&#123;mutation.type&#125;.&#96;)\n  &#125;)\n\n  &#x2F;&#x2F; Note this has to be typed if you are using TS\n  &#x2F;&#x2F; 注意，如果你使用TS，这必须是类型化的\n  return &#123; creationTime: new Date() &#125;\n&#125;\n\nconst myPlugin: Plugin &#x3D; (&#123; $pinia &#125;) &#x3D;&gt; &#123;\n  $pinia.use(MyPiniaPlugin)\n&#125;\n\nexport default myPlugin\n\nNote the above example is using TypeScript, you have to remove the type annotations PiniaPluginContext and Plugin as well as their imports if you are using a .js file.注意，上面的例子使用TypeScript，如果你使用了.js文件,你需要移除类型标注PiniaPluginContext和Plugin。\nUsing a store outside of a componentPinia stores rely on the pinia instance to share the same store instance across all calls. Most of the time, this works out of the box by just calling your useStore() function. For example, in setup(), you don’t need to do anything else. But things are a bit different outside of a component.Behind the scenes, useStore() injects the pinia instance you gave to your app. This means that if the pinia instance cannot be automatically injected, you have to manually provide it to the useStore() function.You can solve this differently depending on the kind of application you are writing.Pinia 存储依赖于pinia实例来共享同一个store实例。大多数时候，这是通过调用你的useStore()函数来实现的。例如，在setup()中，你不需要做任何其他事情。但是，在一个组件之外，事情是有所不同的。\nSingle Page ApplicationsIf you are not doing any SSR (Server Side Rendering), any call of useStore() after installing the pinia plugin with app.use(pinia) will work:如果你不是做任何SSR（服务器端渲染），在安装pinia插件后调用useStore()后，它将会工作：\nimport &#123; useUserStore &#125; from &#39;@&#x2F;stores&#x2F;user&#39;\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\n&#x2F;&#x2F; ❌  fails because it&#39;s called before the pinia is created\n&#x2F;&#x2F; ❌  因为它在pinia创建之前被调用\nconst userStore &#x3D; useUserStore()\n\nconst pinia &#x3D; createPinia()\nconst app &#x3D; createApp(App)\napp.use(pinia)\n\n&#x2F;&#x2F; ✅ works because the pinia instance is now active\n&#x2F;&#x2F; ✅ 因为pinia实例现在已经激活\nconst userStore &#x3D; useUserStore()\n\nThe easiest way to ensure this is always applied is to defer calls of useStore() by placing them inside functions that will always run after pinia is installed.最简单的方法是通过将useStore()函数放在函数中，来保证它总是在pinia安装后才被调用。Let’s take a look at this example of using a store inside of a navigation guard with Vue Router:看一下使用store在导航守卫中的例子：\nimport &#123; createRouter &#125; from &#39;vue-router&#39;\nconst router &#x3D; createRouter(&#123;\n  &#x2F;&#x2F; ...\n&#125;)\n\n&#x2F;&#x2F; ❌ Depending on the order of imports this will fail\n&#x2F;&#x2F; ❌ 取决于导入的顺序，这将会失败\nconst store &#x3D; useStore()\n\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; we wanted to use the store here\n  &#x2F;&#x2F; 我们想要使用store这里\n  if (store.isLoggedIn) next()\n  else next(&#39;&#x2F;login&#39;)\n&#125;)\n\nrouter.beforeEach((to) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ✅ This will work because the router starts its navigation after\n  &#x2F;&#x2F; the router is installed and pinia will be installed too\n  &#x2F;&#x2F; ✅ 这将会工作，因为路由开始导航之后，pinia也会被安装\n  const store &#x3D; useStore()\n\n  if (to.meta.requiresAuth &amp;&amp; !store.isLoggedIn) return &#39;&#x2F;login&#39;\n&#125;)\n\nSSR AppsWhen dealing with Server Side Rendering, you will have to pass the pinia instance to useStore(). This prevents pinia from sharing global state between different application instances.在服务器端渲染的应用中，你需要传递pinia实例给useStore()。这将阻止pinia在不同应用实例之间共享全局状态。There is a whole section dedicated to it in the SSR guide, this is just a short explanation:在SSR指南中有一个专门的章节，这只是一个简短的说明：\n手册Usage without setup()Pinia can be used even if you are not using the composition API (if you are using Vue 2, you still need to install the @vue/composition-api plugin though). While we recommend you to give the Composition API a try and learn it, it might not be the time for you and your team yet, you might be in the process of migrating an application, or any other reason. There are a few functions:Pinia可以被使用，即使你不使用组合API（如果你使用Vue 2，你仍然需要安装@vue/composition-api插件）。但是我们建议你试一试组合API，然后学习它，非团队合作，你可能正在迁移一个应用，或者其他任何原因。有一些函数：\n\nmapStores\nmapState\nmapWritableState\n⚠️ mapGetters (just for migration convenience, use mapState() instead)\nmapActions\n\nGiving access to the whole storeIf you need to access pretty much everything from the store, it might be too much to map every single property of the store… Instead you can get access to the whole store with mapStores():如果你需要访问整个store，可能会太多了，可以使用mapStores()来访问整个store：\nimport &#123; mapStores &#125; from &#39;pinia&#39;\n\n&#x2F;&#x2F; given two stores with the following ids\n&#x2F;&#x2F; 给定两个store，其id为：\nconst useUserStore &#x3D; defineStore(&#39;user&#39;, &#123;\n  &#x2F;&#x2F; ...\n&#125;)\nconst useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;\n  &#x2F;&#x2F; ...\n&#125;)\n\nexport default &#123;\n  computed: &#123;\n    &#x2F;&#x2F; note we are not passing an array, just one store after the other\n    &#x2F;&#x2F; each store will be accessible as its id + &#39;Store&#39;\n    &#x2F;&#x2F; 注意我们不传递数组，而是一个store一个store\n    ...mapStores(useCartStore, useUserStore)\n  &#125;,\n\n  methods: &#123;\n    async buyStuff() &#123;\n      &#x2F;&#x2F; use them anywhere!\n      &#x2F;&#x2F; 使用它们任何地方！\n      if (this.userStore.isAuthenticated()) &#123;\n        await this.cartStore.buy()\n        this.$router.push(&#39;&#x2F;purchased&#39;)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;\n\nBy default, Pinia will add the &quot;Store&quot; suffix to the id of each store. You can customize this behavior by calling the setMapStoreSuffix():默认情况下，Pinia将添加“Store”后缀到每个store的id。你可以通过调用setMapStoreSuffix()来自定义这个行为：\nimport &#123; createPinia, setMapStoreSuffix &#125; from &#39;pinia&#39;\n\n&#x2F;&#x2F; completely remove the suffix: this.user, this.cart\n&#x2F;&#x2F; 完全删除后缀：this.user, this.cart\nsetMapStoreSuffix(&#39;&#39;)\n&#x2F;&#x2F; this.user_store, this.cart_store (it&#39;s okay, I won&#39;t judge you)\n&#x2F;&#x2F; 这个user_store, this.cart_store（也是可以的）\n\nsetMapStoreSuffix(&#39;_store&#39;)\nexport const pinia &#x3D; createPinia()\n\nTypeScriptBy default, all map helpers support autocompletion and you don’t need to do anything. If you call setMapStoreSuffix() to change the &quot;Store&quot; suffix, you will need to also add it somewhere in a TS file or your global.d.ts file. The most convenient place would be the same place where you call setMapStoreSuffix():默认情况下，所有map helpers都支持自动完成，你不需要做任何事情。如果你调用setMapStoreSuffix()来改变“Store”后缀，你还需要在TS文件或你的global.d.ts文件中添加它。最方便的地方就是在你调用setMapStoreSuffix()的地方：\nimport &#123; createPinia, setMapStoreSuffix &#125; from &#39;pinia&#39;\n&#x2F;&#x2F; completely remove the suffix\n&#x2F;&#x2F; 完全删除后缀\nsetMapStoreSuffix(&#39;&#39;) \n\nexport const pinia &#x3D; createPinia()\n\ndeclare module &#39;pinia&#39; &#123;\n  export interface MapStoresCustomization &#123;\n    &#x2F;&#x2F; set it to the same value as above\n    &#x2F;&#x2F; 设置为上面的值\n    suffix: &#39;&#39;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\nWARNING\nIf you are using a TypeScript declaration file (like global.d.ts), make sure to import &#39;pinia&#39; at the top of it to expose all existing types.如果你使用了一个TypeScript声明文件（例如global.d.ts），请在它的顶部导入pinia来对所有现有类型进行暴露。\n\nComposing StoresComposing stores is about having stores that use each other and there is one rule to follow:组合store是关于有store使用另一个store的事情，有一条规则要遵守：If two or more stores use each other, they cannot create an infinite loop through getters or actions. They cannot both directly read each other state in their setup function:如果两个或多个store使用了另一个store，那么它们不能通过_getters_或_actions_创建无限循环。它们不能同时直接读取另一个store的状态：\nconst useX &#x3D; defineStore(&#39;x&#39;, () &#x3D;&gt; &#123;\n  const y &#x3D; useY()\n\n  &#x2F;&#x2F; ❌ This is not possible because y also tries to read x.name\n  &#x2F;&#x2F; ❌ 这是不可能的，因为y也试图读取x的name\n  y.name\n\n  function doSomething() &#123;\n    &#x2F;&#x2F; ✅ Read y properties in computed or actions\n    &#x2F;&#x2F; ✅ 读取y属性在computed或actions\n    const yName &#x3D; y.name\n    &#x2F;&#x2F; ...\n  &#125;\n\n  return &#123;\n    name: ref(&#39;I am X&#39;),\n  &#125;\n&#125;)\n\nconst useY &#x3D; defineStore(&#39;y&#39;, () &#x3D;&gt; &#123;\n  const x &#x3D; useX()\n\n  &#x2F;&#x2F; ❌ This is not possible because x also tries to read y.name\n  &#x2F;&#x2F; ❌ 这是不可能的，因为x也试图读取y的name\n  x.name\n\n  function doSomething() &#123;\n    &#x2F;&#x2F; ✅ Read x properties in computed or actions\n    &#x2F;&#x2F; ✅ 读取x属性在computed或actions\n    const xName &#x3D; x.name\n    &#x2F;&#x2F; ...\n  &#125;\n\n  return &#123;\n    name: ref(&#39;I am Y&#39;),\n  &#125;\n&#125;)\n\nNested storesNote that if one store uses another store, there is no need to create a new store in a separate file, you can directly import it. Think of it as nesting.如果一个store使用另一个store，不需要在一个单独的文件中创建一个新的store，你可以直接导入它。记住它是嵌套的。You can call useOtherStore() at the top of any getter or action:你可以在任何getter或action的顶部调用useOtherStore()：\nimport &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;\n\nexport const cartStore &#x3D; defineStore(&#39;cart&#39;, &#123;\n  getters: &#123;\n    &#x2F;&#x2F; ... other getters\n    summary(state) &#123;\n      const user &#x3D; useUserStore()\n\n      return &#96;Hi $&#123;user.name&#125;, you have $&#123;state.list.length&#125; items in your cart. It costs $&#123;state.price&#125;.&#96;\n    &#125;,\n  &#125;,\n\n  actions: &#123;\n    purchase() &#123;\n      const user &#x3D; useUserStore()\n\n      return apiPurchase(user.id, this.list)\n    &#125;,\n  &#125;,\n&#125;)\n\nShared GettersYou can simply call useOtherStore() inside a getter:你可以在_getter_中直接调用useOtherStore()：\nimport &#123; defineStore &#125; from &#39;pinia&#39;\nimport &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;\n\nexport const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;\n  getters: &#123;\n    summary(state) &#123;\n      const user &#x3D; useUserStore()\n\n      return &#96;Hi $&#123;user.name&#125;, you have $&#123;state.list.length&#125; items in your cart. It costs $&#123;state.price&#125;.&#96;\n    &#125;,\n  &#125;,\n&#125;)\n\nShared ActionsThe same applies to actions:同样适用于_actions_：\nimport &#123; defineStore &#125; from &#39;pinia&#39;\nimport &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;\n\nexport const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;\n  actions: &#123;\n    async orderCart() &#123;\n      const user &#x3D; useUserStore()\n\n      try &#123;\n        await apiOrderCart(user.token, this.items)\n        &#x2F;&#x2F; another action\n        this.emptyCart()\n      &#125; catch (err) &#123;\n        displayError(err)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;)","slug":"2022-06-10vue-pinia","date":"2022-06-10T09:21:00.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"57a999928e12a5391c5331208745c7af","title":"前端基础- 数组对象方法实现原理","content":"提前终止循环见：2022-10-16js\n哪些循环可以提前终止掉循环\n\nfor 循环\nfor...in\nsome\nevery\n\n\n\n\n序号\n方法\nbreak\ncontinue\nreturn\nreturn true\nreturn false\n提前终止循环\n\n\n\n1\nfor 循环\n成功\n跳出本次循环\n不合法\n不合法\n不合法\n√\n\n\n3\nfor…in\n成功\n跳出本次循环\n不合法\n不合法\n不合法\n√\n\n\n5\nArray.some()\n不合法\n不合法\n跳出本次循环\n成功\n跳出本次循环\n√\n\n\n6\nArray.every()\n不合法\n不合法\n成功\n跳出本次循环\n成功\n√\n\n\n2\nArray.forEach()\n不合法\n不合法\n跳出本次循环\n跳出本次循环\n跳出本次循环\n×\n\n\n4\nArray.map()\n不合法\n不合法\n跳出本次循环\n跳出本次循环\n跳出本次循环\n×\n\n\n7\nArray.filter()\n不合法\n不合法\n跳出本次循环\n跳出本次循环\n跳出本次循环\n×\n\n\nmap定义\n\nmap()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值\nmap()方法按照原始数组元素顺序一次处理元素\n\n注意\n\nmap()不会对空数组进行检测\nmap()方法返回的是一个新数组，而不是原始数组\n\n原理\nArray.proptotype.myMap &#x3D; function (fn) &#123;\n  let arr &#x3D; [];\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    arr.push(fn(this[i], i, this));\n  &#125;\n  return arr;\n&#125;;\n\n使用\n[1, 2, 3].myMap((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item * 2;\n&#125;);\n\n&#x2F;&#x2F; 1 0  [1, 2, 3]\n&#x2F;&#x2F; 2 1  [1, 2, 3]\n&#x2F;&#x2F; 3 2  [1, 2, 3]\n&#x2F;&#x2F; [2, 4, 6]\n\nfilter定义\n\nfilter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素\n\n注意\n\nfilter()方法不会对空数组进行遍历\nfilter()方法不会改变原始数组\n\n原理\nArray.prototype.myFilter &#x3D; function (fn) &#123;\n  let arr &#x3D; [];\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (fn(this[i], i, this)) &#123;\n      arr.push(this[i]);\n    &#125;\n  &#125;\n  return arr;\n&#125;;\n\n使用\n[1, 2, 3].myFilter((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);\n&#x2F;&#x2F; 1 0  [1, 2, 3]\n&#x2F;&#x2F; 2 1  [1, 2, 3]\n&#x2F;&#x2F; 3 2  [1, 2, 3]\n&#x2F;&#x2F; [2, 3]\n\nsome定义\n\nsome()方法用于检测数组中的元素是否满足指定条件\n\nsome()方法会一次执行数组的每个元素，直到找到符合条件的元素为止\n\n如果找到符合条件的元素，some()方法就会立即返回 true，剩余的元素不会再执行\n如果没有找到符合条件的元素，some()方法就会返回 false\n\n\n\n注意\n\nsome()方法不会对空数组进行遍历\nsome()方法不会改变原始数组\n\n原理\n\nsome 我们知道是如果找到就返回 true，没有返回 false,那么在 filter 上再改造一下，定义一个遍历为 false,当有一次会回调函数执行的时候返回 true,那么就跳出循环，直接返回。\n\nArray.prototype.mySome &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (fn(this[i], i, this)) &#123;\n      return true;\n    &#125;\n  &#125;\n  return false;\n&#125;;\n\n使用\n[1, 2, 3].mySome((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);\n\nfind定义\n\nfind()方法返回数组中满足条件的第一个元素\nfind()方法会一次执行数组的每个元素，直到找到符合条件的元素为止\n如果找到符合条件的元素，find()方法就会立即返回该元素，剩余的元素不会再执行\n如果没有找到符合条件的元素，find()方法就会返回 undefined\n\n\n\n注意\n\nfind()方法不会对空数组进行遍历\nfind()方法不会改变原始数组\n\n原理\n\n当回调函数有一个返回 ture，则赋值并且返回，否则会返回一个未定义的值，undefined。\n\nArray.prototype.myFind &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (fn(this[i], i, this)) &#123;\n      return this[i];\n    &#125;\n  &#125;\n  return undefined;\n&#125;;\n\n使用\n[1, 2, 3].myFind((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);\n\nevery定义\n\nevery()方法用于检测数组中的所有元素是否都满足指定条件\nevery()方法会一次执行数组的每个元素，直到找到不符合条件的元素为止\n如果找到不符合条件的元素，every()方法就会返回 false，剩余的元素不会再执行\n如果没有找到不符合条件的元素，every()方法就会返回 true\n\n\n\n注意\n\nevery()方法不会对空数组进行遍历\nevery()方法不会改变原始数组\n\n原理\n\n这个跟 some 其实只是反着来，初始化一个值为 true，只要回调函数有一个值返回 false，那么就会成立从而推出循环并且返回。\n\nArray.prototype.myEvery &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    if (!fn(this[i], i, this)) &#123;\n      return false;\n    &#125;\n  &#125;\n  return true;\n&#125;;\n\n使用\n[1, 2, 3].myEvery((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n  return item &gt; 1;\n&#125;);\n\nforEach定义\n\nforEach()方法用于遍历数组中的所有元素\n\n注意\n\nforEach()方法不会对空数组执行回调函数\n\n原理\n\n也是利用 for 循环直接遍历循环执行回调函数即可。\n\nArray.prototype.myForEach &#x3D; function (fn) &#123;\n  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;\n    fn(this[i], i, this);\n  &#125;\n&#125;;\n\n使用\n[1, 2, 3].myForEach((item, index, arr) &#x3D;&gt; &#123;\n  console.log(item, index, arr);\n&#125;);\n\nconcat定义\n\nconcat()方法用于连接两个或多个数组\nconcat()方法不会改变原始数组\n\n注意\n原理\n\n先判断是不是数组，是的话遍历 push，不是的话直接 push，最后返回复制的数组即可。\n\nArray.prototype.myConcat &#x3D; function (...args) &#123;\n  let arr &#x3D; [...this];\n  for (let i &#x3D; 0; i &lt; args.length; i++) &#123;\n    if (Array.isArray(args[i])) &#123;\n      arr &#x3D; arr.concat(args[i]);\n    &#125; else &#123;\n      arr.push(args[i]);\n    &#125;\n  &#125;\n  return arr;\n&#125;;\n\n使用\n[1, 2, 3].myConcat([4, 5, 6]);\n\ncopyWithin定义\n\ncopyWithin()方法用于将一个数组的元素复制到其他位置\ncopyWithin()方法会修改原始数组\n\n注意\n\ncopyWithin()方法会改变原始数组\n\n原理\n\nstart、 end 元素拷贝到 target 元素（end - start 有几位，会改变 target 及之后的几位）\n\nArray.prototype.myCopyWithin &#x3D; function (target, start &#x3D; 0, end &#x3D; this.length) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  target &#x3D; target &lt; 0 ? len + target : target;\n  start &#x3D; start &lt; 0 ? len + start : start;\n  end &#x3D; end &lt; 0 ? len + end : end;\n  for (let i &#x3D; start; i &lt; end; i++) &#123;\n    arr[target + i - start] &#x3D; arr[i];\n  &#125;\n  return arr;\n&#125;;\n\n使用\n[1, 2, 3, 4, 5].myCopyWithin(0, 3);\n&#x2F;&#x2F; 拷贝 4, 5，从0开始覆盖\n&#x2F;&#x2F; [4, 5, 3, 4, 5]\n\nreduce定义\n\nreduce()方法用于从一个数组中的元素求和\nreduce()可以作为一个高阶函数使用，用于函数的 compose\n\n注意\n\nreduce()方法不会对空数组执行回调函数\n\n原理\nArray.prototype.myReduce &#x3D; function (fn, init) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  let i &#x3D; 0;\n  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;\n    init &#x3D; arr[0];\n    i &#x3D; 1;\n  &#125;\n  for (; i &lt; len; i++) &#123;\n    init &#x3D; fn(init, arr[i], i, arr);\n  &#125;\n  return init;\n&#125;;\n\n使用\n[1, 2, 3].myReduce((prev, curr) &#x3D;&gt; &#123;\n  return prev + curr;\n&#125;, 0);\n\nreduceRight定义\n\nreduceRight()方法用于从一个数组中的元素求和\nreduceRight()可以作为一个高阶函数使用，用于函数的 compose注意\nreduceRight()方法不会对空数组执行回调函数原理\n\nArray.prototype.myReduceRight &#x3D; function (fn, init) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  let i &#x3D; len - 1;\n  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;\n    init &#x3D; arr[len - 1];\n    i &#x3D; len - 2;\n  &#125;\n  for (; i &gt;&#x3D; 0; i--) &#123;\n    init &#x3D; fn(init, arr[i], i, arr);\n  &#125;\n  return init;\n&#125;;\n\n使用\n[1, 2, 3].myReduceRight((prev, curr) &#x3D;&gt; &#123;\n  return prev + curr;\n&#125;, 0);\n\nsplice定义\n\nsplice()方法用于删除数组中的一段，并用新元素替代原来的元素\nsplice()方法会改变原始数组\nsplice()方法会返回被删除的元素\n并且返回被删除的元素的数组\n\n注意\n\nsplice()方法会改变原始数组\n\n原理\nArray.prototype.mySplice &#x3D; function (start, deleteCount, ...args) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  &#x2F;&#x2F; 找开始的位置\n  start &#x3D; start &lt; 0 ? len + start : start;\n  &#x2F;&#x2F; 找删除的数量\n  &#x2F;&#x2F; 如果deleteCount，没有值，则从start开始删除，直到数组结束\n  deleteCount &#x3D; deleteCount &#x3D;&#x3D;&#x3D; undefined ? len - start : deleteCount;\n\n  let newArr &#x3D; arr.slice(0, start); &#x2F;&#x2F; 左\n\n  newArr &#x3D; newArr.concat(args); &#x2F;&#x2F; 新\n\n  newArr &#x3D; newArr.concat(arr.slice(start + deleteCount)); &#x2F;&#x2F; 右\n\n  return newArr;\n&#125;;\n\n使用\n[1, 2, 3, 4, 5].mySplice(2, 2, 6, 7);\n\nslice定义\n\nslice()方法用于返回一个数组的一段，并且不会改变原始数组\nslice()方法会返回一个新数组\n\n原理\nArray.prototype.mySlice &#x3D; function (start, end) &#123;\n  let newarr &#x3D; [];\n\n  start &#x3D; start &#x3D;&#x3D;&#x3D; undefined ? 0 : start;\n  end &#x3D; end &#x3D;&#x3D;&#x3D; undefined ? this.length : end;\n\n  for (let i &#x3D; start; i &lt; end; i++) &#123;\n    newarr.push(this[i]);\n  &#125;\n\n  return newarr;\n&#125;;\n\n使用\nvar a &#x3D; [1, 2, 3, 4, 5];\nvar b &#x3D; a.splice(2, 2, 6, 7);\na;\n&#x2F;&#x2F; [1, 2, 6, 7, 5]\nb;\n&#x2F;&#x2F; [3, 4]\n\nsort定义\n\nsort()方法用于对数组进行排序\nsort()方法会改变原始数组\nsort()方法会返回一个新数组\n\n原理\nArray.prototype.mySort &#x3D; function (fn) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  &#x2F;&#x2F; 冒泡排序\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    for (let j &#x3D; i + 1; j &lt; len; j++) &#123;\n      if (fn(arr[i], arr[j]) &gt; 0) &#123;\n        &#x2F;&#x2F; 使用了解构赋值\n        [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];\n      &#125;\n    &#125;\n  &#125;\n  return arr;\n&#125;;\n\n使用\n[1, 2, 3, 4, 5].mySort((a, b) &#x3D;&gt; &#123;\n  return a - b;\n&#125;);\n\nreverse定义\n\nreverse()方法用于反转数组\nreverse()方法会改变原始数组\n\n原理\nArray.prototype.myReverse &#x3D; function () &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n\n  let i &#x3D; 0;\n  let j &#x3D; len - 1;\n\n  while (i &lt; j) &#123;\n    &#x2F;&#x2F; 使用了解构赋值\n    [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];\n    i++;\n    j--;\n  &#125;\n  return arr;\n&#125;;\n\n使用\n[1, 2, 3, 4, 5].myReverse();\n\nincludes定义\n\nincludes()方法用于判断数组是否包含某个值\nincludes()方法会返回一个布尔值\n如果数组包含某个值，则返回 true，否则返回 false\n\n原理\nArray.prototype.myIncludes &#x3D; function (value) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    if (arr[i] &#x3D;&#x3D;&#x3D; value) &#123;\n      return true;\n    &#125;\n  &#125;\n  return false;\n&#125;;\n\n使用\n[1, 2, 3, 4, 5].myIncludes(3);\n\nflat定义\n\nflat()方法用于将一个数组展开为多个数组\nflat()方法会返回一个新数组\nflat()方法会返回一个新数组，如果数组中的元素是数组，则将数组中的元素展开为一个数组\n\n原理\nArray.prototype.myFlat &#x3D; function (depth &#x3D; 1) &#123;\n  let arr &#x3D; [...this];\n  let len &#x3D; arr.length;\n\n  let newArr &#x3D; [];\n\n  if (depth &#x3D;&#x3D; 0) return arr; &#x2F;&#x2F; Copilot 这里写的不对\n\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    if (Array.isArray(arr[i])) &#123;\n      newArr &#x3D; newArr.concat(&#x2F;**&#x2F; arr[i].myFlat(depth - 1) &#x2F;*递归*&#x2F;);\n    &#125; else &#123;\n      newArr.push(arr[i]);\n    &#125;\n  &#125;\n  return newArr;\n&#125;;\n\n使用\n[1, 2, 3, 4, 5].myFlat();\n\n参考链接js 一些数组对象方法原理实现(手撕 map,filter,every,flat 等) 当前文章比此链接代码更精简\n","slug":"2022-06-10js-arr","date":"2022-06-10T07:06:40.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"3cfe5c81c087dc101db23ece3358d249","title":"前端基础-劫持(函数/数据)","content":"函数劫持函数劫持，在一个函数运行之前就把它劫持下来，添加我们想要的功能。 在函数运行之前，我们可以改变函数的参数，或者改变函数的返回值。\n\n\n\n\n\n\n\n\n\nJavaScript 中的函数劫持是一个增强原有函数的技巧，一般我们用来对原有的 JavaScript 全局方法做一些能力的增强。\n函数劫持原理\n函数劫持原理，是在函数运行之前，把函数的原型改变为新的函数，并且把原函数的执行代码放到新函数的执行代码之前。\n函数劫持实现\n\n使用新的变量保存被劫持函数\n新函数中写被劫持函数\n新函数中 调用原有的函数（保存在变量中的函数）\n\n基础：两个对象指向同一个地址的时候，修改某个对象的属性，另外一个对象也会随之变化\nlet a &#x3D; &#123;&#125;;\nlet b &#x3D; a;\na.name &#x3D; &quot;Gopal&quot;;\n&#x2F;&#x2F; ture &#123;name: &#39;Gopal&#39;&#125;  &#123;name: &#39;Gopal&#39;&#125;\nconsole.log(b &#x3D;&#x3D;&#x3D; a, a, b);\n\n基础：将新的对象赋值给对象变量的时候，该对象变量就指向了新对象的引用地址，跟旧引用切断关联\nlet a &#x3D; &#123;&#125;;\nlet b &#x3D; a;\na &#x3D; &#123; name: &quot;Gopal&quot; &#125;;\n&#x2F;&#x2F; false &#123;name: &#39;Gopal&#39;&#125; &#123;&#125;\nconsole.log(b &#x3D;&#x3D;&#x3D; a, a, b);\n\n应用场景\n\n增强你的函数功能\n如上面的第一个例子，在原有的函数之上，实现特定的逻辑。\n\n\n追踪 XSS 攻击\n一般 XSS 攻击会先利用 alert() 等方法输出信息进行测试，这个时候，我们可以对原先的 alert() 进行劫持，向其输入追踪信息的代码，最后才把原函数执行。function report(caller) &#123;\n  var img &#x3D; new Image();\n  img.src &#x3D; &#96;http:&#x2F;&#x2F;www.site.com&#x2F;getReport.php?caller&#x3D;$&#123;encodeURIComponent(\n    caller\n  )&#125;&#96;;\n&#125;\nvar _alert &#x3D; window.alert;\nwindow.alert &#x3D; function (s) &#123;\n  &#x2F;&#x2F; 拿到攻击者相关信息，并上报\n  report(alert.caller);\n  _alert(s);\n&#125;;\nalert(&quot;test&quot;);\n\n\n\n劫持 ajax 请求，实现 mock 功能\n\nmock.js 中，就是通过对原生的 XMLHttpRequest（或 ActiveXObject）进行劫持，判断有没有找到匹配的数据模板，如果找到，则拦截 XHR 请求逻辑，执行自身规则对应的逻辑。如果未找到匹配的数据模板，则采用原生 XHR 发送请求。详细代码看 这里 。\n\n数据劫持 definePropertyObject.defineProperty()通过设置对象属性 getter 和 setter 来监听属性的变化，可以实现数据劫持。getter 时候进行依赖收集，setter 时候进行数据变更时通知订阅者更新视图。\nfunction defineReactive(obj, key, value) &#123;\n  Object.defineProperty(obj, key, &#123;\n    enumerable: true,\n    configurable: true,\n    get() &#123;\n      collectDeps(); &#x2F;&#x2F; 收集依赖\n      return value;\n    &#125;,\n    set(newVal) &#123;\n      observe(newVal); &#x2F;&#x2F; 若是新值是对象，则递归子属性\n      if (value !&#x3D;&#x3D; newVal) &#123;\n        notify(); &#x2F;&#x2F; 通知订阅者更新视图\n        console.log(&quot;数据变更了&quot;);\n        value &#x3D; newVal;\n      &#125;\n    &#125;,\n  &#125;);\n  observe(value); &#x2F;&#x2F; 递归子属性\n&#125;\n\nfunction observe(obj) &#123;\n  if (!obj || typeof obj !&#x3D;&#x3D; &quot;object&quot;) &#123;\n    return;\n  &#125;\n  Object.keys(obj).forEach((key) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 有递归\n    defineReactive(obj, key, obj[key]);\n  &#125;);\n&#125;\n\nvar data &#x3D; &#123;\n  name: &quot;Gopal&quot;,\n  sex: &quot;male&quot;,\n&#125;;\n\n缺点\n\n无法检测到对象属性的新增或删除\n无法监听数组的变化\n\n由于 js 的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过 Object.defineProperty 方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性 或删除属性，这就需要另外处理。\nvue 在实现数组的响应式时，使用了一些 hack,把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的 push&#x2F;pop&#x2F;shift&#x2F;unshift&#x2F;splice&#x2F;sort&#x2F;reverse 7 个方法上，其他方法无法监听。目前没读过源码，不晓得这搬来文章内容是否正确\n数据劫持 ProxyProxy,字面意思是代理，是 ES6 提供的一个新的 API,用于修改某些操作的默认行为，可以理解为在目标对象之前做一层拦截，外部所有的访问都必须通过这层拦截，通过这层拦截可以做很多事情，比如对数据进行过滤、修改或者收集信息之类\nES6 原生提供的 Proxy 构造函数：\nvar proxy &#x3D; new Proxy(target, handler);\n\n其中 obj 为 Proxy 要拦截的对象，handler 用来定制拦截的操作，返回一个新的代理对象 proxy；Proxy 代理特点：\n\nProxy 的代理针对的是整个对象，而不是像 Object.defineProperty 针对某个属性。只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。\nProxy 也可以监听数组的变化。\n\nvar proxy &#x3D; new Proxy([1, 2, 3], &#123;\n  get: function (target, property) &#123;\n    console.log(target, property);\n    return target[property];\n  &#125;,\n&#125;);\nproxy[0] &#x3D; 4;\nproxy.push(5);\nproxy.length;\n\nlet handler &#x3D; &#123;\n  get: function (target, key) &#123;\n    if (target[key] &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; target[key] !&#x3D;&#x3D; null) &#123;\n      return new Proxy(target[key], handler);\n    &#125;\n    collectDeps(); &#x2F;&#x2F; 收集依赖\n\n    return Reflect.get(target, key);\n  &#125;,\n  set(target, key, value) &#123;\n    if (key &#x3D;&#x3D;&#x3D; &quot;length&quot;) return true;\n    notifyRender(); &#x2F;&#x2F; 通知订阅者更新视图\n    return Reflect.set(target, key, value);\n  &#125;,\n&#125;;\n\nlet proxy &#x3D; new Proxy(data, handler);\nproxy.age &#x3D; 18; &#x2F;&#x2F; 支持新增属性\n\nlet proxy1 &#x3D; new Proxy(&#123; arr: [] &#125;, handler);\nproxy1.arr[0] &#x3D; &quot;proxy&quot;;\n\n参考链接你还不知道 JavaScript 中的函数劫持么？数据劫持\n","slug":"2022-06-10js-数据劫持","date":"2022-06-10T07:05:21.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"c3d5408da05b02828c848a49ca35cf59","title":"修补node_modules下源码","content":"背景之前在简书上记录过，没迁移简书文章，所以重新记录\n由于hexo-theme-aurora代码配色不是很友好，需要自定义配色，又不想改其 github 上代码，直接处理node_modules下的配色文件\n安装 patch-packagepatch-package 包可以通过 npm 进行安装。\nnpm i patch-package --save-dev\n\n或者也可以通过 yarn 进行安装。\nyarn add patch-package -D\n\n修改包代码&#x2F;node_modules&#x2F;某包名下，按需修改\n\n创建补丁在修改依赖包内容后，就可以运行 patch-package 创建 patch 文件了。\nyarn patch-package 包名 # 使用 yarn\n\n运行后通常会在项目根目录下的 patches 目录中创建一个名为 包名+version.patch 的文件。将该 patch 文件提交至版本控制中，即可在之后应用该补丁了。例如：\n👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ yarn patch-package hexo-theme-aurora\nyarn run v1.4.0\n$ &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;.bin&#x2F;patch-package hexo-theme-aurora\npatch-package 6.4.7\n• Creating temporary folder\n• Installing hexo-theme-aurora@1.5.5 with yarn\n• Diffing your files with clean files\n✔ Created file patches&#x2F;hexo-theme-aurora+1.5.5.patch\n\n💡 hexo-theme-aurora is on GitHub! To draft an issue based on your patch run\n\n    yarn patch-package hexo-theme-aurora --create-issue\n\n✨  Done in 5.48s.\n\n配置 npm 脚本钩子完成上述操作后，最后还需要修改 package.json 的内容，在 scripts 中加入”postinstall”: “patch-package”。\n&quot;scripts&quot;: &#123;\n  &quot;postinstall&quot;: &quot;patch-package&quot;\n&#125;\n\n验证清理 node_modules项目根目录别搞错了,简单粗暴点，直接全清掉\nrm -rf node_modules &amp;&amp; yarn\n\n运行结果👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ yarn\nyarn install v1.4.0\n[1&#x2F;4] 🔍  Resolving packages...\n[2&#x2F;4] 🚚  Fetching packages...\n[3&#x2F;4] 🔗  Linking dependencies...\nwarning &quot;hexo &gt; nunjucks@3.2.3&quot; has unmet peer dependency &quot;chokidar@^3.3.0&quot;.\nwarning &quot;hexo-browsersync &gt; browser-sync &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.\nwarning &quot;hexo-browsersync &gt; browser-sync &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.\nwarning &quot;hexo-renderer-marked &gt; jsdom@19.0.0&quot; has unmet peer dependency &quot;canvas@^2.5.0&quot;.\nwarning &quot;hexo-renderer-marked &gt; jsdom &gt; ws@8.5.0&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.\nwarning &quot;hexo-renderer-marked &gt; jsdom &gt; ws@8.5.0&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.\nwarning &quot;hexo-theme-aurora &gt; pinia@2.0.13&quot; has unmet peer dependency &quot;@vue&#x2F;composition-api@^1.4.0&quot;.\nwarning &quot;hexo-theme-aurora &gt; pinia@2.0.13&quot; has unmet peer dependency &quot;typescript@&gt;&#x3D;4.4.4&quot;.\nwarning &quot;hexo-theme-aurora &gt; pinia &gt; vue-demi@0.12.5&quot; has unmet peer dependency &quot;@vue&#x2F;composition-api@^1.0.0-rc.1&quot;.\n[4&#x2F;4] 📃  Building fresh packages...\n$ yarn patch-package # 看这里，在运行修补\nyarn run v1.4.0\n$ &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;.bin&#x2F;patch-package\npatch-package 6.4.7\nApplying patches...\nhexo-theme-aurora@1.5.5 ✔\n✨  Done in 1.00s.\n✨  Done in 13.93s.\n\n\n提交代码将 patches 提交到代码仓库，以后在其他机器上，直接安装依赖包即可。\n注意事项npx patch-package hexo-theme-aurora\n\n这个命令使用 npm 运行的，可能不会成功，使用yarn patch-package hexo-theme-aurora\n👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ npx patch-package  hexo-theme-aurora\npatch-package 6.4.7\n• Creating temporary folder\n• Installing hexo-theme-aurora@1.5.5 with yarn\nwarning package.json: No license field\nwarning No license field\nerror An unexpected error occurred: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;axios: ETIMEDOUT&quot;.\nError: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;core-js: ETIMEDOUT\n    at Timeout._onTimeout (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;yarn&#x2F;lib&#x2F;cli.js:132130:19)\n    at listOnTimeout (node:internal&#x2F;timers:557:17)\n\n参考链接hexo-theme-aurora&#x2F;issues&#x2F;168patch-package\n","slug":"2022-06-09patch-package","date":"2022-06-09T01:51:48.000Z","categories_index":"工具","tags_index":"npm","author_index":"举手摘月亮"},{"id":"effcb24e596d83e2df5140f38213b656","title":"10.Typescript 工具类型","content":"TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.Typescript提供了一些帮助类型转换的工具类型，这些工具类型可以在全局范围内使用。\nPartialReleased: 2.1\nConstructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.构造一个具有所有属性类型的可选属性的类型。这个工具将返回一个表示给定类型的所有子集的类型。\n&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n&#125;\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;\n  return &#123; ...todo, ...fieldsToUpdate &#125;;\n&#125;\n\nconst todo1 &#x3D; &#123;\n  title: &quot;organize desk&quot;,\n  description: &quot;clear clutter&quot;,\n&#125;;\n\nconst todo2 &#x3D; updateTodo(todo1, &#123;\n  description: &quot;throw out trash&quot;,\n&#125;);\n\n原理使用映射类型（Mapped Types）\n\n首先通过 keyof T，遍历出类型 T 的所有属性，然后通过 in 操作符进行遍历，最后在属性后加上?，将属性变为可选属性。\n注意 这个 in 不是收缩类型操作符in ,而是映射类型中的in\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;HEAD&#x2F;src&#x2F;lib&#x2F;es5.d.ts#L1517\ntype Partial&lt;T&gt; &#x3D; &#123;\n  [P in keyof T]?: T[P];\n&#125;;\n\nRequiredReleased:2.8\nConstructs a type consisting of all properties of Type set to required. The opposite of Partial.构造一个具有所有属性类型的必需属性的类型。与Partial相反。\n&#x2F;&#x2F; Example\ninterface Props &#123;\na?: number;\nb?: string;\n&#125;\n\nconst obj: Props &#x3D; &#123; a: 5 &#125;;\n\nconst obj2: Required&lt;Props&gt; &#x3D; &#123; a: 5 &#125;;\nProperty &#39;b&#39; is missing in type &#39;&#123; a: number; &#125;&#39; but required in type &#39;Required&lt;Props&gt;&#39;.\n\n原理原理：使用映射类型（Mapped Types） 用于将 T 类型的所有属性设置为必选状态，首先通过 keyof T，取出类型 T 的所有属性， 然后通过 in 操作符进行遍历，最后在属性后的 ? 前加上 -，将属性变为必选属性。\n这里顺便讲下-这个符号的作用，这是 TypeScript 2.8 为映射类型增加了添加或删除特定修饰符的能力。具体来说，readonly 和?映射类型中的属性修饰符现在可以加上+或-前缀，以指示应该添加或删除该修饰符，当然一般+号是可以省略的。ts 官网 类型操作符&#x2F;映射类型\ntype Required&lt;T&gt; &#x3D; &#123;\n  [P in keyof T]-?: T[P];\n&#125;;\n\nReadonlyReleased:2.1\nConstructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.构造一个具有所有属性类型的只读属性的类型。\n&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n&#125;\n\nconst todo: Readonly&lt;Todo&gt; &#x3D; &#123;\n  title: &quot;Delete inactive users&quot;,\n&#125;;\n\ntodo.title &#x3D; &quot;Hello&quot;;\n&#x2F;&#x2F; Cannot assign to &#39;title&#39; because it is a read-only property.\n\nThis utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).这个工具是用来表示在运行时将失败的赋值表达式的用途（即尝试重新分配一个冻结对象的属性）。Object.freeze\nfunction freeze&lt;Type&gt;(obj: Type): Readonly&lt;Type&gt;;\n\n原理原理：使用映射类型（Mapped Types） 接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。\ntype Readonly&lt;T&gt; &#x3D; &#123;\n  readonly [P in keyof T]: T[P];\n&#125;;\n\nRecord&lt;Keys, Type&gt;Released:2.1\nConstructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。\n&#x2F;&#x2F; Example\ninterface CatInfo &#123;\n  age: number;\n  breed: string;\n&#125;\n\ntype CatName &#x3D; &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;;\n\nconst cats: Record&lt;CatName, CatInfo&gt; &#x3D; &#123;\n  miffy: &#123; age: 10, breed: &quot;Persian&quot; &#125;,\n  boris: &#123; age: 5, breed: &quot;Maine Coon&quot; &#125;,\n  mordred: &#123; age: 16, breed: &quot;British Shorthair&quot; &#125;,\n&#125;;\n\ncats.boris;\n\nconst cats: Record&lt;CatName, CatInfo&gt;;\n\n原理使用映射类型（Mapped Types）\n接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。\ntype Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;\n  [P in K]: T;\n&#125;;\n\nPick&lt;Type, Keys&gt;Released:2.1\nConstructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。\n&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n&#125;\n\ntype TodoPreview &#x3D; Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;\n\nconst todo: TodoPreview &#x3D; &#123;\n  title: &quot;Clean room&quot;,\n  completed: false,\n&#125;;\n\ntodo;\n\n&#x2F;&#x2F; const todo: TodoPreview;\n\n原理从 T 类型中提取部分属性，作为新的返回类型。\ntype Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;\n  [P in K]: T[P];\n&#125;;\n\nOmit&lt;Type, Keys&gt;Released:3.5\nConstructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).用于构造一个类型，它是从Type类型里面过滤了一些属性Keys(Keys是字符串字面量 或者 字符串字面量的联合类型)\n&#x2F;&#x2F; Example\ninterface Todo &#123;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n&#125;\n\ntype TodoPreview &#x3D; Omit&lt;Todo, &quot;description&quot;&gt;;\n\nconst todo: TodoPreview &#x3D; &#123;\n  title: &quot;Clean room&quot;,\n  completed: false,\n  createdAt: 1615544252770,\n&#125;;\n\ntodo;\n\n&#x2F;&#x2F; const todo: TodoPreview;\n\ntype TodoInfo &#x3D; Omit&lt;Todo, &quot;completed&quot; | &quot;createdAt&quot;&gt;;\n\nconst todoInfo: TodoInfo &#x3D; &#123;\n  title: &quot;Pick up kids&quot;,\n  description: &quot;Kindergarten closes at 5pm&quot;,\n&#125;;\n\ntodoInfo;\n\n&#x2F;&#x2F; const todoInfo: TodoInfo\n\n原理使用 keyof 类型操作符号、extends、类型操作符 Exclude、 类型操作符 Pick\n\n结合 Pick 和 Exclude 方法，提取出不含 K 属性的类型。\n1.keyof T 返回的是联合类型\n2.extends\n3.Exclude&lt;T, K&gt; 返回的是联合类型， 可以接收一个联合类型和一个联合类型，返回一个联合类型\n4.把 K 中的 key, 从 T 中排除掉，剩下的就是 Omit 的类型。\n\ntype Omit&lt;T, K extends keyof T&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;\n\nExclude&lt;UnionType, ExcludedMembers&gt;Released:2.8\nConstructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.用于构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型。\n&#x2F;&#x2F; Example;\ntype T0 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;\n&#x2F;&#x2F; type T0 &#x3D; &quot;b&quot; | &quot;c&quot;;\n\ntype T1 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;;\n&#x2F;&#x2F; type T1 &#x3D; &quot;c&quot;;\n\ntype T2 &#x3D; Exclude&lt;string | number | (() &#x3D;&gt; void), Function&gt;;\n&#x2F;&#x2F; type T2 &#x3D; string | number;\n\n原理\n源码很简单，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 never，否则返回 T\nnever 是一个特殊的类型，在这里可以表示为空的联合类型，在于与其他类型的联合后，结果为其他类型。\n没有遍历，怎么也能实现呢? 这里还涉及到extends条件类型的特殊情况，extends的前参T如果是一个泛型参数。对于使用extends关键字的条件类型（即上面的三元表达式类型），如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，两个类型会成为分配条件类型（Distributive Conditional Types）。分配条件类型是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。\n\ntype Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;\n\nExtract&lt;Type, Union&gt;Released:2.8\nConstructs a type by extracting from Type all union members that are assignable to Union.用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型。\n&#x2F;&#x2F; Example\ntype T0 &#x3D; Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;;\n&#x2F;&#x2F; type T0 &#x3D; &quot;a&quot;;\n\ntype T1 &#x3D; Extract&lt;string | number | (() &#x3D;&gt; void), Function&gt;;\n&#x2F;&#x2F; type T1 &#x3D; () &#x3D;&gt; void;\n\n原理(注意)type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;\n\n\n\n\n\n\n\nTIP\n需前置学习 extends 关键字\n\n\n原理：与 Exclude 相反，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 T，否则返回 never。\ntype Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;\n\nNonNullableReleased:2.8\nConstructs a type by excluding null and undefined from Type.用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型。\n&#x2F;&#x2F; Example\ntype T0 &#x3D; NonNullable&lt;string | number | undefined&gt;;\n\n&#x2F;&#x2F; type T0 &#x3D; string | number;\n\ntype T1 &#x3D; NonNullable&lt;string[] | null | undefined&gt;;\n\n&#x2F;&#x2F; type T1 &#x3D; string[];\n\n原理判断 T 是否可以赋值给 null 或者 undefined 类型，是则返回 never，否则返回 T，如果这段看不明白的可以再看下 Exclude 那段关于 extends 的补充说明。\ntype NonNullable&lt;T&gt; &#x3D; T extends null | undefined ? never : T;\n\nParametersReleased:3.1\nConstructs a tuple type from the types used in the parameters of a function type Type.用于根据所有Type中函数类型的参数构造一个元祖类型。\n&#x2F;&#x2F; Example\ndeclare function f1(arg: &#123; a: number; b: string &#125;): void;\n\ntype T0 &#x3D; Parameters&lt;() &#x3D;&gt; string&gt;;\n&#x2F;&#x2F; type T0 &#x3D; []\n\ntype T1 &#x3D; Parameters&lt;(s: string) &#x3D;&gt; void&gt;;\n&#x2F;&#x2F; type T1 &#x3D; [s: string]\n\ntype T2 &#x3D; Parameters&lt;&lt;T&gt;(arg: T) &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T2 &#x3D; [arg: unknown]\n\ntype T3 &#x3D; Parameters&lt;typeof f1&gt;;\n&#x2F;&#x2F; type T3 &#x3D; [arg: &#123;\n&#x2F;&#x2F;   a: number;\n&#x2F;&#x2F;   b: string;\n&#x2F;&#x2F; &#125;]\n\ntype T4 &#x3D; Parameters&lt;any&gt;;\n&#x2F;&#x2F; type T4 &#x3D; unknown[]\n\ntype T5 &#x3D; Parameters&lt;never&gt;;\n&#x2F;&#x2F; type T5 &#x3D; never\n\ntype T6 &#x3D; Parameters&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T6 &#x3D; never\n\ntype T7 &#x3D; Parameters&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.\n\ntype T7 &#x3D; never;\n\n原理：\nParameters 首先约束参数 T 必须是个函数类型\n判断 T 是否是函数类型，如果是则使用 infer P 暂时存一下函数的参数类型，直接用 P 即可得到这个类型并返回，否则就返回 never\n\ntype Parameters&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (\n  ...args: infer P\n) &#x3D;&gt; any\n  ? P\n  : never;\n\n这里用到了infer，infer P标记一个泛型，表示这个泛型是一个待推断的类型，并且可以直接使用。\nConstructorParameters构造参数类型Released:3.1\nConstructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).构造一个从构造函数类型Type中提取的元组或数组类型。如果Type不是函数，则生成never类型。\n&#x2F;&#x2F; Example\ntype T0 &#x3D; ConstructorParameters&lt;ErrorConstructor&gt;;\n&#x2F;&#x2F; type T0 &#x3D; [message?: string]\n\ntype T1 &#x3D; ConstructorParameters&lt;FunctionConstructor&gt;;\n&#x2F;&#x2F; type T1 &#x3D; string[]\n\ntype T2 &#x3D; ConstructorParameters&lt;RegExpConstructor&gt;;\n&#x2F;&#x2F; type T2 &#x3D; [pattern: string | RegExp, flags?: string]\n\ntype T3 &#x3D; ConstructorParameters&lt;any&gt;;\n&#x2F;&#x2F; type T3 &#x3D; unknown[]\n\ntype T4 &#x3D; ConstructorParameters&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.\n\n&#x2F;&#x2F; type T4 &#x3D; never\n\nReturnTypeReleased:2.8\nConstructs a type consisting of the return type of function Type.用于构造一个含有Type函数的返回值的类型。\n&#x2F;&#x2F; Example\ndeclare function f1(): &#123; a: number; b: string &#125;;\n\ntype T0 &#x3D; ReturnType&lt;() &#x3D;&gt; string&gt;;\n&#x2F;&#x2F; type T0 &#x3D; string\n\ntype T1 &#x3D; ReturnType&lt;(s: string) &#x3D;&gt; void&gt;;\n&#x2F;&#x2F; type T1 &#x3D; void\n\ntype T2 &#x3D; ReturnType&lt;&lt;T&gt;() &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T2 &#x3D; unknown\n\ntype T3 &#x3D; ReturnType&lt;&lt;T extends U, U extends number[]&gt;() &#x3D;&gt; T&gt;;\n&#x2F;&#x2F; type T3 &#x3D; number[]\n\ntype T4 &#x3D; ReturnType&lt;typeof f1&gt;;\n&#x2F;&#x2F; type T4 &#x3D; &#123;\n&#x2F;&#x2F; a: number;\n&#x2F;&#x2F; b: string;\n&#x2F;&#x2F; &#125;\n\ntype T5 &#x3D; ReturnType&lt;any&gt;;\n&#x2F;&#x2F; type T5 &#x3D; any\n\ntype T6 &#x3D; ReturnType&lt;never&gt;;\n&#x2F;&#x2F; type T6 &#x3D; never\n\ntype T7 &#x3D; ReturnType&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T7 &#x3D; any\n\ntype T8 &#x3D; ReturnType&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.\n\n&#x2F;&#x2F; type T8 &#x3D; any\n\n原理与 Parameters 类似\n\nReturnType 首先约束参数 T 必须是个函数类型\n判断 T 是否是函数类型，如果是则使用 infer R 暂时存一下函数的返回值类型，后面的语句直接用 R 即可得到这个类型并返回，否则就返回 any\n\ntype ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (\n  ...args: any\n) &#x3D;&gt; infer R\n  ? R\n  : any;\n\nInstanceTypeReleased:2.8\nConstructs a type consisting of the instance type of a constructor function in Type.返回构造函数类型T的实例类型\n&#x2F;&#x2F; Example\nclass C &#123;\n  x &#x3D; 0;\n  y &#x3D; 0;\n&#125;\n\ntype T0 &#x3D; InstanceType&lt;typeof C&gt;;\n&#x2F;&#x2F; type T0 &#x3D; C\n\ntype T1 &#x3D; InstanceType&lt;any&gt;;\n&#x2F;&#x2F; type T1 &#x3D; any\n\ntype T2 &#x3D; InstanceType&lt;never&gt;;\n&#x2F;&#x2F; type T2 &#x3D; never\n\ntype T3 &#x3D; InstanceType&lt;string&gt;;\n&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; type T3 &#x3D; any\n\ntype T4 &#x3D; InstanceType&lt;Function&gt;;\n&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.\n&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.\n\n&#x2F;&#x2F; type T4 &#x3D; any\n\n原理type InstanceType&lt;T extends abstract new (...args: any) &#x3D;&gt; any&gt; &#x3D;\n  T extends abstract new (...args: any) &#x3D;&gt; infer R ? R : any;\n\n与 ResultType 类似\ntype ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (\n  ...args: any\n) &#x3D;&gt; infer R\n  ? R\n  : any;\n\nThisParameterTypeReleased:3.3\nExtracts the type of the this parameter for a function type, or unknown if the function type has no this parameter.用于提取一个函数类型Type的this (opens new window)参数类型，返回unknown (opens new window)如果这个函数类型没有this参数。\n&#x2F;&#x2F; Example\nfunction toHex(this: Number) &#123;\n  return this.toString(16);\n&#125;\n\nfunction numberToString(n: ThisParameterType&lt;typeof toHex&gt;) &#123;\n  return toHex.apply(n);\n&#125;\n\nOmitThisParameterReleased:3.3\nRemoves the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type.\n\n用于移除一个函数类型 Type 的 this (opens new window)参数类型。\n如果 Type 没有明确的声明 this 类型，那么这个返回的结果就是 Type，\n不然的话，就返回一个新的函数类型，基于 Type，但不再有 this 参数。\n范型会被抹去，只有最后重载的签名被传播进了返回的新的函数类型。\n\n&#x2F;&#x2F; Example\nfunction toHex(this: Number) &#123;\n  return this.toString(16);\n&#125;\n\nconst fiveToHex: OmitThisParameter&lt;typeof toHex&gt; &#x3D; toHex.bind(5);\n\nconsole.log(fiveToHex());\n\nThisTypeReleased:2.3\nThis utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility.\n\n这个类型不返回一个转换过的类型，它被用作标记一个上下文的 this 类型。\n想使用这个工具类型，noImplicitThis 必须启用。\n\n&#x2F;&#x2F; Example\ntype ObjectDescriptor&lt;D, M&gt; &#x3D; &#123;\n  data?: D;\n  methods?: M &amp; ThisType&lt;D &amp; M&gt;; &#x2F;&#x2F; Type of &#39;this&#39; in methods is D &amp; M\n&#125;;\n\nfunction makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M &#123;\n  let data: object &#x3D; desc.data || &#123;&#125;;\n  let methods: object &#x3D; desc.methods || &#123;&#125;;\n  return &#123; ...data, ...methods &#125; as D &amp; M;\n&#125;\n\nlet obj &#x3D; makeObject(&#123;\n  data: &#123; x: 0, y: 0 &#125;,\n  methods: &#123;\n    moveBy(dx: number, dy: number) &#123;\n      this.x +&#x3D; dx; &#x2F;&#x2F; Strongly typed this\n      this.y +&#x3D; dy; &#x2F;&#x2F; Strongly typed this\n    &#125;,\n  &#125;,\n&#125;);\n\nobj.x &#x3D; 10;\nobj.y &#x3D; 20;\nobj.moveBy(5, 5);\n\nIn the example above, the methods object in the argument to makeObject has a contextual type that includes ThisType&lt;D &amp; M&gt; and therefore the type of this in methods within the methods object is { x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }. Notice how the type of the methods property simultaneously is an inference target and a source for the this type in methods.在上面的示例中，makeObject的参数中的methods对象包含了一个上下文类型，该类型包含了ThisType&lt;D &amp; M&gt;，因此methods对象中的this类型是&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;。请注意，methods属性的类型同时是一个推断目标和一个methods对象中的this类型的源。The ThisType marker interface is simply an empty interface declared in lib.d.ts. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.ThisType&lt;T&gt;标记接口是在lib.d.ts中声明的空接口。它只是在对象字面量的上下文类型中被识别而已，该接口的行为与空接口一样。\nIntrinsic String Manipulation Types内部字符串操作类型UppercaseLowercaseCapitalizeUncapitalize\nTo help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the Template Literal Types documentation.为了帮助模板字符串操作，TypeScript包含一组可以在字符串操作中使用的类型。你可以在模板字符串类型文档中找到它们。\nTypescript 中 extends 的作用1、接口继承可以继承父类接口的方法和属性\ninterface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n&#x2F;&#x2F; dog 具有 Animal 的 name 属性。\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\n2、普通条件判断用来判断一个类型是否可以分配给另外一个类型\nA extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。\ninterface Animal &#123;\n  name: string;\n&#125;\n\ninterface Dog extends Animal &#123;\n  sayHello: () &#x3D;&gt; void;\n&#125;\n\nconst dog: Dog &#x3D; &#123;\n  name: &quot;tom&quot;,\n  sayHello: function () &#123;&#125;,\n&#125;;\n\ntype bool &#x3D; Animal extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;\ntype bool1 &#x3D; Dog extends Animal ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;\n\n3、泛型条件判断对于使用 extends 关键字的条件类型，如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。\n分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。\n满足两个要点即可适用分配律：\n参数是泛型类型，\n代入参数的是联合类型在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。\ntype Animal&lt;T&gt; &#x3D; T;\ntype Animal1&lt;T&gt; &#x3D; [T];\ntype Dog &#x3D; Animal&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;\ntype Dog1 &#x3D; Animal1&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]\n\ntype A &#x3D; &quot;x&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;\ntype B &#x3D; &quot;x&quot; extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;\ntype C &#x3D; [&quot;x&quot; | &quot;y&quot;] extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;\ntype D &#x3D; &quot;x&quot; | &quot;y&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; D &#x3D; &#39;yse&#39;\n\n4、泛型约束在书写泛型时，往往需要对类型参数作一定对限制。\nfunction getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;\n  return obj[key];\n&#125;\n\nconst obj &#x3D; &#123;\n  name: &quot;tom&quot;,\n  age: 12,\n&#125;;\n\ngetInfo(obj, &quot;age&quot;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。\n\n参考链接typescript handbook utility-types工具类型Typescript 中的 extends 关键字Exclude 与 Extract 前置学习项Typescript Classes extends-clauses彻底搞懂 typescript 工具类型及其原理 该文有错误内容，要注意哦TypeScript 的 extends 条件类型\n","slug":"2022-06-09ts-util-type","date":"2022-06-08T14:49:28.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"29a670518a826389296f8915224ed71e","title":"9.Typescript手册 模块","content":"JavaScript has a long history of different ways to handle modularizing code. TypeScript having been around since 2012, has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the import&#x2F;export syntax.JavaScript 有很长的历史，不同的方式来处理代码的模块化。TypeScript 从 2012 年开始，就支持了大量的模块化格式，但是，在过去的时间，社区和 JavaScript 规范一致地聚合了一个模块化格式，叫做 ES Modules（或 ES6 模块）。你可能会知道它叫做 import/export 语法。\nES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes.ES Modules 在 2015 年添加到 JavaScript 规范，2020 年已经有广泛的支持在大部分的 web 浏览器和 JavaScript 运行时。For focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS module.exports &#x3D; syntax, and you can find information about the other module patterns in the reference section under Modules.为了获得焦点，本手册将介绍 ES Modules 和其常用的先行模块 CommonJS module.exports = 同义词，并且你可以在 Modules 下的参考节中找到其他模块模式的信息。\nHow JavaScript Modules are DefinedIn TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module.在 TypeScript 中，只要文件包含一个顶层的 import 或 export 就被视为一个模块。Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).反之，一个没有顶层的 import 或 export 声明的文件就被视为一个脚本，其内容可以在全局作用域中使用（并且也可以作为模块使用）。Modules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.模块是在自己的作用域中执行的，不是在全局作用域中执行的。这意味着在模块中声明的变量，函数，类，接口等等，只有在显式的使用 export 声明的时候才能在模块外被访问。反之，要从其他模块中消费一个变量，函数，类，接口等等，必须使用 import 声明来导入。\nNon-modules非模块Before we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an export or top-level await should be considered a script and not a module.在开始之前，我们需要明白 TypeScript 认为什么是模块。JavaScript 规范定义了任何没有 export 或 top-level await 的 JavaScript 文件都被视为脚本而不是模块。Inside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the outFile compiler option to join multiple input files into one output file, or use multiple  tags in your HTML to load these files (in the correct order!).在脚本文件中，变量和类型被声明为共享的全局作用域，并且我们假设你会使用 outFile 编译选项将多个输入文件合并成一个输出文件，或者使用多个 &lt;script&gt; 标签在你的 HTML 中加载这些文件（按照正确的顺序）。If you have a file that doesn’t currently have any imports or exports, but you want to be treated as a module, add the line:如果你有一个文件，它目前没有任何 import 或 export 声明，但是你想被视为一个模块，那么添加这一行：\nexport &#123;&#125;;\n\nwhich will change the file to be a module exporting nothing. This syntax works regardless of your module target.这种语法对于你的模块目标无论如何都是可行的。\nModules in TypeScriptTypeScript 中的模块Additional Reading:附加阅读：Impatient JS (Modules)不知道模块的 TypeScriptMDN: JavaScript ModulesMDN：JavaScript 模块There are three main things to consider when writing module-based code in TypeScript:在 TypeScript 中写模块基础的代码时，要考虑三个主要问题：Syntax: What syntax do I want to use to import and export things?语法：我想要使用什么语法来导入和导出东西？Module Resolution: What is the relationship between module names (or paths) and files on disk?模块解析：模块名（或路径）和磁盘上的文件之间的关系是什么？Module Output Target: What should my emitted JavaScript module look like?模块输出目标：我的输出的 JavaScript 模块应该怎样看？\nES Module SyntaxES 模块语法A file can declare a main export via export default:一个文件可以通过 export default 声明一个主要的导出：\n&#x2F;&#x2F; @filename: hello.ts\nexport default function helloWorld() &#123;\n  console.log(&quot;Hello, world!&quot;);\n&#125;\n\nThis is then imported via:这是通过以下方式导入的：\nimport helloWorld from &quot;.&#x2F;hello.js&quot;;\nhelloWorld();\n\nIn addition to the default export, you can have more than one export of variables and functions via the export by omitting default:除了默认导出，你还可以有多个导出的变量和函数，通过将 default 去掉：\n&#x2F;&#x2F; @filename: maths.ts\nexport var pi &#x3D; 3.14;\nexport let squareTwo &#x3D; 1.41;\nexport const phi &#x3D; 1.61;\n\nexport class RandomNumberGenerator &#123;&#125;\n\nexport function absolute(num: number) &#123;\nif (num &lt; 0) return num \\* -1;\n  return num;\n&#125;\n\nThese can be used in another file via the import syntax:这些可以在另一个文件中通过导入语法使用：\nimport &#123; pi, phi, absolute &#125; from &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(pi);\nconst absPhi &#x3D; absolute(phi);\n\n&#x2F;&#x2F; const absPhi: number;\n\nAdditional Import Syntax附加导入语法An import can be renamed using a format like import {old as new}:一个导入可以通过这样的格式：import &#123;old as new&#125;：\nimport &#123; pi as π &#125; from &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(π);\n\n&#x2F;&#x2F; (alias) var π: number\n&#x2F;&#x2F; import π\n\nYou can mix and match the above syntax into a single import:你可以混合这些语法到一个单独的导入：\n&#x2F;&#x2F; @filename: maths.ts\nexport const pi &#x3D; 3.14;\nexport default class RandomNumberGenerator &#123;&#125;\n\n&#x2F;&#x2F; @filename: app.ts\nimport RandomNumberGenerator, &#123; pi as π &#125; from &quot;.&#x2F;maths.js&quot;;\n\nRandomNumberGenerator;\n\n&#x2F;&#x2F; (alias) class RandomNumberGenerator\n&#x2F;&#x2F; import RandomNumberGenerator\n\nconsole.log(π);\n\n&#x2F;&#x2F; (alias) const π: 3.14\n&#x2F;&#x2F; import π\n\nYou can take all of the exported objects and put them into a single namespace using * as name:你可以将所有导出的对象放到一个单独的命名空间，使用 \\* as name：\n&#x2F;&#x2F; @filename: app.ts\nimport \\* as math from &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(math.pi);\nconst positivePhi &#x3D; math.absolute(math.phi);\n\n&#x2F;&#x2F; const positivePhi: number\n\nYou can import a file and not include any variables into your current module via import \"./file\":你可以通过 import &quot;./file&quot; 导入一个文件，并且不包含任何变量到当前模块：\n&#x2F;&#x2F; @filename: app.ts\nimport &quot;.&#x2F;maths.js&quot;;\n\nconsole.log(&quot;3.14&quot;);\n\nIn this case, the import does nothing. However, all of the code in maths.ts was evaluated, which could trigger side-effects which affect other objects.在这种情况下，导入并没有什么事情。但是，maths.ts 中的所有代码都会被评估，这可能会触发其他对象的副作用。\nTypeScript Specific ES Module SyntaxTypeScript 特定的 ES 模块语法Types can be exported and imported using the same syntax as JavaScript values:类型可以使用相同的语法来导出和导入 JavaScript 值：\n&#x2F;&#x2F; @filename: animal.ts\nexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;\n\nexport interface Dog &#123;\n  breeds: string[];\n  yearOfBirth: number;\n&#125;\n\n&#x2F;&#x2F; @filename: app.ts\nimport &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;\ntype Animals &#x3D; Cat | Dog;\n\nTypeScript has extended the import syntax with two concepts for declaring an import of a type:TypeScript 已经扩展了导入类型的语法，它有两个概念来声明导入类型：\nimport type\n&#x2F;&#x2F; Which is an import statement which can only import types:\n&#x2F;&#x2F; 只能导入类型的导入语句：\n&#x2F;&#x2F; @filename: animal.ts\nexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;\n&#x2F;&#x2F; &#39;createCatName&#39; cannot be used as a value because it was imported using &#39;import type&#39;.\n&#x2F;&#x2F; &#39;createCatName&#39; 不能被用作值，因为它被导入使用了 &#39;import type&#39;。\nexport type Dog &#x3D; &#123; breeds: string[]; yearOfBirth: number &#125;;\nexport const createCatName &#x3D; () &#x3D;&gt; &quot;fluffy&quot;;\n\n&#x2F;&#x2F; @filename: valid.ts\nimport type &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;\nexport type Animals &#x3D; Cat | Dog;\n\n&#x2F;&#x2F; @filename: app.ts\nimport type &#123; createCatName &#125; from &quot;.&#x2F;animal.js&quot;;\nconst name &#x3D; createCatName();\n\nInline type imports内联类型导入\nTypeScript 4.5 also allows for individual imports to be prefixed with type to indicate that the imported reference is a type:TypeScript 4.5 可以使用 type 前缀来声明导入的引用是一个类型：\n&#x2F;&#x2F; @filename: app.ts\nimport &#123; createCatName, type Cat, type Dog &#125; from &quot;.&#x2F;animal.js&quot;;\n\nexport type Animals &#x3D; Cat | Dog;\nconst name &#x3D; createCatName();\n\nTogether these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.这些同时允许一个非 TypeScript 编译器，如 Babel、swc 或 esbuild 知道哪些导入可以安全地移除。\nES Module Syntax with CommonJS BehaviorES 模块语法与 CommonJS 行为TypeScript has ES Module syntax which directly correlates to a CommonJS and AMD require. Imports using ES Module are for most cases the same as the require from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:TypeScript 有 ES 模块语法，它相对于 CommonJS 和 AMD require。使用 ES Module 的导入是为了大多数情况下与这些环境的 require 一致，但这种语法确保了你的 TypeScript 文件与 CommonJS 输出有一个 1 到 1 的匹配。\nimport fs &#x3D; require(&quot;fs&quot;);\nconst code &#x3D; fs.readFileSync(&quot;hello.ts&quot;, &quot;utf8&quot;);\n\nYou can learn more about this syntax in the modules reference page.你可以在模块参考页面了解更多关于这种语法。\nCommonJS SyntaxCommonJS 语法\nCommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.CommonJS 是 npm 上大多数模块的格式。即使你正在使用上面的 ES 模块语法，也会有一个简单的了解 CommonJS 语法的方式帮助你调试更容易。\nExporting导出\nIdentifiers are exported via setting the exports property on a global called module.标识符通过设置 module.exports 属性来导出。\nfunction absolute(num: number) &#123;\n    if (num &lt; 0) return num \\* -1;\n    return num;\n&#125;\n\nmodule.exports &#x3D; &#123;\n  pi: 3.14,\n  squareTwo: 1.41,\n  phi: 1.61,\n  absolute,\n&#125;;\n\nThen these files can be imported via a require statement:然后，这些文件可以通过 require 语句来导入：\nconst maths &#x3D; require(&quot;maths&quot;);\nmaths.pi;\n\n&#x2F;&#x2F; any;\n\nOr you can simplify a bit using the destructuring feature in JavaScript:或者，你可以使用 JavaScript 的解构特性来简化一些：\nconst &#123; squareTwo &#125; &#x3D; require(&quot;maths&quot;);\nsquareTwo;\n\n&#x2F;&#x2F; const squareTwo: any;\n\nCommonJS and ES Modules interopCommonJS 和 ES 模块的互操作\nThere is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop.在 CommonJS 和 ES 模块之间存在不匹配的特性，关于默认导入和模块命名空间对象导入的区别。TypeScript 有一个编译器标志来减少 CommonJS 和 ES 模块之间的摩擦。\nTypeScript’s Module Resolution OptionsTypeScript 的模块解析选项\nModule resolution is the process of taking a string from the import or require statement, and determining what file that string refers to.模块解析是从 import 或 require 语句中获取字符串，并确定该字符串所引用的文件。\nTypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option module is not commonjs, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for .ts and .d.ts.TypeScript 包含两种解析策略：经典和 Node。经典，默认情况下，当编译器选项 module 不是 commonjs 时，包含了向后兼容性。Node 策略重复了 Node.js 在 CommonJS 模式下工作的方式，并且添加了 .ts 和 .d.ts 的检查。There are many TSConfig flags which influence the module strategy within TypeScript: moduleResolution, baseUrl, paths, rootDirs.在 TypeScript 中，有很多 TSConfig 标志影响模块策略：moduleResolution、baseUrl、paths、rootDirs。For the full details on how these strategies work, you can consult the Module Resolution.关于如何工作的详细信息，你可以参考模块解析。\nTypeScript’s Module Output OptionsTypeScript 的模块输出选项There are two options which affect the emitted JavaScript output:有两个影响输出的 JavaScript 的选项：\n\ntarget which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intacttarget 是指定哪些 JS 特性被下游（转换为在旧的 JavaScript 运行时运行），哪些被保留。\nmodule which determines what code is used for modules to interact with each othermodule 是指定哪些代码用于模块交互。\n\nWhich target you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.哪个目标你使用是由你期望在 JavaScript 运行时运行 TypeScript 代码的功能决定的。这可能是：最旧的 web 浏览器，最低版本的 Node.js，或者来自你运行时的唯一约束 - 例如，Electron。All communication between modules happens via a module loader, the compiler option module determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.模块之间的通信都是通过模块加载器来完成的，编译器选项 module 是指定哪个被使用。在运行时，模块加载器负责定位并执行所有模块的依赖之前执行它。For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for module:例如，这里是一个使用 ES Modules 语法的 TypeScript 文件，展示了一些模块的选项：\nimport &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;\n\nexport const twoPi &#x3D; valueOfPi _ 2;\n\nES2020import &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;\nexport const twoPi &#x3D; valueOfPi _ 2;\n\nCommonJS&quot;use strict&quot;;\nObject.defineProperty(exports, &quot;\\_\\_esModule&quot;, &#123; value: true &#125;);\nexports.twoPi &#x3D; void 0;\nconst constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);\nexports.twoPi &#x3D; constants_js_1.valueOfPi \\* 2;\n\nUMD(function (factory) &#123;\n  if (typeof module &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof module.exports &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;\n    var v &#x3D; factory(require, exports);\n    if (v !&#x3D;&#x3D; undefined) module.exports &#x3D; v;\n  &#125;\n  else if (typeof define &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; define.amd) &#123;\n    define([&quot;require&quot;, &quot;exports&quot;, &quot;.&#x2F;constants.js&quot;], factory);\n  &#125;\n&#125;)(function (require, exports) &#123;\n  &quot;use strict&quot;;\n  Object.defineProperty(exports, &quot;\\_\\_esModule&quot;, &#123; value: true &#125;);\n  exports.twoPi &#x3D; void 0;\n  const constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);\n  exports.twoPi &#x3D; constants_js_1.valueOfPi \\* 2;\n&#125;);\n\n\nNote that ES2020 is effectively the same as the original index.ts.ES2020 是一样的于原始 index.ts。You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module.你可以看到所有可用的选项和他们的输出 JavaScript 代码的样子在 module 的 TSConfig 参考中。\nTypeScript namespacesTypeScript 命名空间TypeScript has its own module format called namespaces which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in the namespaces reference page.TypeScript 有自己的模块格式命名空间，它是先期的 ES Modules 标准。这种语法具有很多有用的功能创建复杂的定义文件，仍然在 DefinitelyTyped 中有活跃使用。尽管不被弃用，大多数的功能在命名空间中存在于 ES Modules，我们建议你使用它与 JavaScript 的方向对齐。你可以在命名空间参考页面上了解更多关于命名空间。\n","slug":"2022-06-08ts-modules","date":"2022-06-08T14:47:47.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"14464d0b7865c234ecdc15847ed605ff","title":"8.Typescript手册 类","content":"Background Reading:背景阅读 Classes (MDN)\nTypeScript offers full support for the class keyword introduced in ES2015.typescript 支持 ES2015 的 class 关键字。\nAs with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types. 像其他 JavaScript 语言特性一样，TypeScript 添加了类型注解和其他语法，以便您可以表达类和其他类型之间的关系。\nClass Members类成员Here’s the most basic class - an empty one:这是最基本的类 - 空的一个：\nclass Point &#123;&#125;\n\nThis class isn’t very useful yet, so let’s start adding some members.这个类还不是很有用，所以我们开始添加一些成员。\nFields字段A field declaration creates a public writeable property on a class:字段声明创建一个公共可写属性在类上：\nclass Point &#123;\n  x: number;\n  y: number;\n&#125;\n\nconst pt &#x3D; new Point();\npt.x &#x3D; 0;\npt.y &#x3D; 0;\n\nAs with other locations, the type annotation is optional, but will be an implicit any if not specified.与其他地方一样，类型注解是可选的，如果没有指定，将会是任意类型。Fields can also have initializers; these will run automatically when the class is instantiated:字段也可以有初始值，这会在类被实例化时自动运行：\nclass Point &#123;\n  x &#x3D; 0;\n  y &#x3D; 0;\n&#125;\n\nconst pt &#x3D; new Point();\n&#x2F;&#x2F; Prints 0, 0\nconsole.log(&#96;$&#123;pt.x&#125;, $&#123;pt.y&#125;&#96;);\n\nJust like with const, let, and var, the initializer of a class property will be used to infer its type:和 const，let，var 类型推断的初始值。\nconst pt &#x3D; new Point();\npt.x &#x3D; &quot;0&quot;;\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.\n\n–strictPropertyInitializationThe strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor.strictPropertyInitialization 设置控制类字段是否需要在构造函数中初始化。\nclass BadGreeter &#123;\n  name: string;\n  &#x2F;&#x2F; Property &#39;name&#39; has no initializer and is not definitely assigned in the constructor.\n&#125;\nclass GoodGreeter &#123;\n  name: string;\n\n  constructor() &#123;\n    this.name &#x3D; &quot;hello&quot;;\n  &#125;\n&#125;\n\nNote that the field needs to be initialized in the constructor itself. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.注意，字段需要在构造函数本身中初始化。TypeScript 不会分析调用构造函数的方法来检测初始化，因为继承的子类可能覆盖这些方法并且失败初始化成员。If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !:如果您愿意通过其他方式来确定初始化一个字段（例如，可能是外部库填充您的类的一部分），您可以使用确定赋值断言运算符：\nclass OKGreeter &#123;\n  &#x2F;&#x2F; Not initialized, but no error\n  name!: string;\n&#125;\n\nreadonlyFields may be prefixed with the readonly modifier. This prevents assignments to the field outside of the constructor.字段可以使用 readonly 前缀。这将阻止在构造函数之外赋值给字段。\nclass Greeter &#123;\n  readonly name: string &#x3D; &quot;world&quot;;\n\n  constructor(otherName?: string) &#123;\n    if (otherName !&#x3D;&#x3D; undefined) &#123;\n      this.name &#x3D; otherName;\n    &#125;\n  &#125;\n\n  err() &#123;\n    this.name &#x3D; &quot;not ok&quot;;\n    &#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.\n  &#125;\n&#125;\nconst g &#x3D; new Greeter();\ng.name &#x3D; &quot;also not ok&quot;;\n&#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.\n\nConstructors构造函数Background Reading:背景阅读： Constructor (MDN)\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:类构造函数和函数很相似。您可以添加参数，类型注解，默认值和重载。\nclass Point &#123;\n  x: number;\n  y: number;\n\n  &#x2F;&#x2F; Normal signature with defaults\n  constructor(x &#x3D; 0, y &#x3D; 0) &#123;\n    this.x &#x3D; x;\n    this.y &#x3D; y;\n  &#125;\n&#125;\n\nclass Point &#123;\n  &#x2F;&#x2F; Overloads\n  constructor(x: number, y: string);\n  constructor(s: string);\n  constructor(xs: any, y?: any) &#123;\n    &#x2F;&#x2F; TBD\n  &#125;\n&#125;\n\nThere are just a few differences between class constructor signatures and function signatures:类构造函数和函数签名有一些不同：\n\nConstructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later- 构造函数不能有类型参数，这些属于外部类声明，我们将会学习其他内容\nConstructors can’t have return type annotations - the class instance type is always what’s returned- 构造函数不能有返回类型注解，返回的类实例类型始终是返回的\n\nSuper Calls超类调用Just as in JavaScript, if you have a base class, you’ll need to call super(); in your constructor body before using any this. members:在 JavaScript 中，如果您有基类，您需要在构造函数体中调用 super(); 在使用任何 this. 成员之前：\nclass Base &#123;\nk &#x3D; 4;\n&#125;\n\nclass Derived extends Base &#123;\nconstructor() &#123;\n&#x2F;&#x2F; Prints a wrong value in ES5; throws exception in ES6\nconsole.log(this.k);\n&#39;super&#39; must be called before accessing &#39;this&#39; in the constructor of a derived class.\nsuper();\n&#125;\n&#125;\n\nForgetting to call super is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.在 JavaScript 中，忘记调用 super() 可能是一个很简单的错误，但 TypeScript 将告诉您当必要时。\nMethods方法Background Reading:背景阅读： Method (MDN)\nA function property on a class is called a method. Methods can use all the same type annotations as functions and constructors:类中的函数属性被称为方法。方法可以使用和函数和构造函数一样的类型注解：\nclass Point &#123;\n  x &#x3D; 10;\n  y &#x3D; 10;\n\n  scale(n: number): void &#123;\n    this.x *&#x3D; n;\n    this.y *&#x3D; n;\n  &#125;\n&#125;\n\nOther than the standard type annotations, TypeScript doesn’t add anything else new to methods.除了标准类型注解之外，TypeScript 不会添加任何其他东西到方法。Note that inside a method body, it is still mandatory to access fields and other methods via this.. An unqualified name in a method body will always refer to something in the enclosing scope:在方法体中，在方法体内部，您仍然必须通过 this 访问字段和其他方法。在方法体内部，未命名的名称将始终指向包含它的作用域内的东西：\nlet x: number &#x3D; 0;\n\nclass C &#123;\nx: string &#x3D; &quot;hello&quot;;\n\n  m() &#123;\n    &#x2F;&#x2F; This is trying to modify &#39;x&#39; from line 1, not the class property\n    &#x2F;&#x2F; 这是尝试从行 1 修改 &#39;x&#39;，而不是类属性\n    x &#x3D; &quot;world&quot;;\n    Type &#39;string&#39; is not assignable to type &#39;number&#39;.\n  &#125;\n&#125;\n\nGetters &#x2F; Setters获取器/设置器Classes can also have accessors:类也可以有访问器：\nclass C &#123;\n  _length &#x3D; 0;\n  get length() &#123;\n    return this._length;\n  &#125;\n  set length(value) &#123;\n    this._length &#x3D; value;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\nNote that a field-backed get&#x2F;set pair with no extra logic is very rarely useful in JavaScript. It’s fine to expose public fields if you don’t need to add additional logic during the get&#x2F;set operations.&gt;注意，没有额外逻辑的字段-获取/设置-对偶在 JavaScript 中很少是有用的。如果您不需要在获取/设置操作期间添加额外逻辑，则可以暴露公共字段。\nTypeScript has some special inference rules for accessors:TypeScript 有一些特殊的推断规则为访问器：\n\nIf get exists but no set, the property is automatically readonly- 如果 get 存在但没有 set，属性是自动只读的\nIf the type of the setter parameter is not specified, it is inferred from the return type of the getter- 如果设置器参数的类型没有指定，它会从 getter 的返回类型推断\nGetters and setters must have the same Member Visibility- 获取器和设置器必须具有相同的成员可见性Since TypeScript 4.3, it is possible to have accessors with different types for getting and setting.从 TypeScript 4.3 开始，可以有不同类型的访问器获取和设置。\n\nclass Thing &#123;\n  _size &#x3D; 0;\n\n  get size(): number &#123;\n    return this._size;\n  &#125;\n\n  set size(value: string | number | boolean) &#123;\n    let num &#x3D; Number(value);\n\n    &#x2F;&#x2F; Don&#39;t allow NaN, Infinity, etc\n\n    if (!Number.isFinite(num)) &#123;\n      this._size &#x3D; 0;\n      return;\n    &#125;\n\n    this._size &#x3D; num;\n  &#125;\n&#125;\n\nIndex Signatures索引签名Classes can declare index signatures; these work the same as Index Signatures for other object types:类可以声明索引签名；这类似于其他对象类型的索引签名：\nclass MyClass &#123;\n  [s: string]: boolean | ((s: string) &#x3D;&gt; boolean);\n\n  check(s: string) &#123;\n    return this[s] as boolean;\n  &#125;\n&#125;\n\nBecause the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself.因为索引签名类型也需要捕获方法的类型，这使得并不容易有效的使用这些类型。通常的来说，在其他地方存储索引数据而不是在类实例本身，会更好一些。\nClass Heritage类继承Like other languages with object-oriented features, classes in JavaScript can inherit from base classes.在 JavaScript 中，类可以从基类继承。\nimplements Clausesimplements 语句You can use an implements clause to check that a class satisfies a particular interface. An error will be issued if a class fails to correctly implement it:你可以使用 implements 语句检查一个类是否满足一个特定的 interface。如果一个类没有正确的实现(implement)它，TypeScript 会报错：\ninterface Pingable &#123;\n  ping(): void;\n&#125;\n\nclass Sonar implements Pingable &#123;\n  ping() &#123;\n    console.log(&quot;ping!&quot;);\n  &#125;\n&#125;\n\nclass Ball implements Pingable &#123;\n  &#x2F;&#x2F; Class &#39;Ball&#39; incorrectly implements interface &#39;Pingable&#39;.\n  &#x2F;&#x2F; 类 &#39;Ball&#39; 错误地实现了接口 &#39;Pingable&#39;。\n  &#x2F;&#x2F; Property &#39;ping&#39; is missing in type &#39;Ball&#39; but required in type &#39;Pingable&#39;.\n  &#x2F;&#x2F; 在类型 &#39;Ball&#39; 中缺少属性 &#39;ping&#39;，但是在类型 &#39;Pingable&#39; 中是必需的。\n  pong() &#123;\n    console.log(&quot;pong!&quot;);\n  &#125;\n&#125;\n\nClasses may also implement multiple interfaces, e.g. class C implements A, B {.类也可以实现多个接口，比如 class C implements A, B &#123;\nCautions\n注意事项\n大概意思：这是类型，不是 java 中的接口，不能当 js 类去用,与 js 的类不是一个概念\n\n\n\n\n\n\n\nWARNING\nIt’s important to understand that an implements clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods at all. A common source of error is to assume that an implements clause will change the class type - it doesn’t!implements 语句仅仅检查类是否按照接口类型实现，但它并不会改变类的类型或者方法的类型。一个常见的错误就是以为 implements 语句会改变类的类型,——然而实际上它并不会：\n\ninterface Checkable &#123;\n  check(name: string): boolean;\n&#125;\n\nclass NameChecker implements Checkable &#123;\n  check(s) &#123;\n    &#x2F;&#x2F; Parameter &#39;s&#39; implicitly has an &#39;any&#39; type.\n    &#x2F;&#x2F; Notice no error here\n    return s.toLowercse() &#x3D;&#x3D;&#x3D; &quot;ok&quot;;\n    &#x2F;&#x2F; any;\n  &#125;\n&#125;\n\nIn this example, we perhaps expected that s’s type would be influenced by the name: string parameter of check. It is not - implements clauses don’t change how the class body is checked or its type inferred.在这个例子中，我们可能会以为 s 的类型会被 check 的 name: string 参数影响。实际上并没有，implements 语句并不会影响类的内部是如何检查或者类型推断的。Similarly, implementing an interface with an optional property doesn’t create that property:类似的，实现一个有可选属性的接口，并不会创建这个属性：\ninterface A &#123;\n  x: number;\n  y?: number;\n&#125;\nclass C implements A &#123;\n  x &#x3D; 0;\n&#125;\nconst c &#x3D; new C();\nc.y &#x3D; 10;\n&#x2F;&#x2F; Property &#39;y&#39; does not exist on type &#39;C&#39;.\n\nextends Clausesextends 语句\nBackground Reading: Class Inheritance\n背景阅读：[类继承](https://www.typescriptlang.org/docs/handbook/classes.html#class-inheritance)\nClasses may extend from a base class. A derived class has all the properties and methods of its base class, and also define additional members.类可以从基类继承。一个派生类具有基类的所有属性和方法，并且还定义了一些额外的成员。\nclass Animal &#123;\n  move() &#123;\n    console.log(&quot;Moving along!&quot;);\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  woof(times: number) &#123;\n    for (let i &#x3D; 0; i &lt; times; i++) &#123;\n      console.log(&quot;woof!&quot;);\n    &#125;\n  &#125;\n&#125;\n\nconst d &#x3D; new Dog();\n&#x2F;&#x2F; Base class method\nd.move();\n&#x2F;&#x2F; Derived class method\nd.woof(3);\n\nOverriding Methods覆写方法\nBackground Reading: Overriding Methods\nA derived class can also override a base class field or property. You can use the super. syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.派生类可以覆写基类的属性或方法。可以使用 super. 语句访问基类的方法。注意，因为 JavaScript 的类是简单的查找对象，所以没有基类的“super 字段”。TypeScript enforces that a derived class is always a subtype of its base class.TypeScript 强制所有派生类都是基类的子类。For example, here’s a legal way to override a method:这里是一种合法的方式覆写方法：\nclass Base &#123;\n  greet() &#123;\n    console.log(&quot;Hello, world!&quot;);\n  &#125;\n&#125;\n\nclass Derived extends Base &#123;\n  greet(name?: string) &#123;\n    if (name &#x3D;&#x3D;&#x3D; undefined) &#123;\n      super.greet();\n    &#125; else &#123;\n      console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);\n    &#125;\n  &#125;\n&#125;\n\nconst d &#x3D; new Derived();\nd.greet();\nd.greet(&quot;reader&quot;);\n\nIt’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:派生类需要遵循着它的基类的实现。而且通过一个基类引用指向一个派生类实例，这是非常常见并合法的：\n&#x2F;&#x2F; Alias the derived instance through a base class reference\n&#x2F;&#x2F; 基类引用来访问派生类的实例\nconst b: Base &#x3D; d;\n&#x2F;&#x2F; No problem\n&#x2F;&#x2F; 没有问题\nb.greet();\n\nWhat if Derived didn’t follow Base’s contract?但是如果 Derived 不遵循 Base 的约定实现呢？\nclass Base &#123;\n  greet() &#123;\n    console.log(&quot;Hello, world!&quot;);\n  &#125;\n&#125;\n\nclass Derived extends Base &#123;\n  &#x2F;&#x2F; Make this parameter required\n  greet(name: string) &#123;\n    &#x2F;&#x2F; Property &#39;greet&#39; in type &#39;Derived&#39; is not assignable to the same property in base type &#39;Base&#39;.\n    &#x2F;&#x2F; Type &#39;(name: string) &#x3D;&gt; void&#39; is not assignable to type &#39;() &#x3D;&gt; void&#39;.\n    console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);\n  &#125;\n&#125;\n\nIf we compiled this code despite the error, this sample would then crash:如果我们编译这段代码，却没有报错，那么这个例子就会崩溃：\nconst b: Base &#x3D; new Derived();\n&#x2F;&#x2F; Crashes because &quot;name&quot; will be undefined\nb.greet();\n\nType-only Field Declarations只有字段申明的类型When target &gt;&#x3D; ES2022 or useDefineForClassFields is true, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write declare to indicate to TypeScript that there should be no runtime effect for this field declaration.当目标版本 &gt;= ES2022 或者 useDefineForClassFields 为 true 时，类字段在父类构造函数完成后初始化，并且会覆盖父类的设置。这种情况下，如果你只想重新定义一个更加准确的类型，你可以使用 declare 来指示给 TypeScript。\ninterface Animal &#123;\n  dateOfBirth: any;\n&#125;\n\ninterface Dog extends Animal &#123;\n  breed: any;\n&#125;\n\nclass AnimalHouse &#123;\n  resident: Animal;\n  constructor(animal: Animal) &#123;\n    this.resident &#x3D; animal;\n  &#125;\n&#125;\n\nclass DogHouse extends AnimalHouse &#123;\n  &#x2F;&#x2F; Does not emit JavaScript code,\n  &#x2F;&#x2F; 不能生成 JavaScript 代码\n  &#x2F;&#x2F; only ensures the types are correct\n  &#x2F;&#x2F; 只是确保类型正确\n  declare resident: Dog;\n  constructor(dog: Dog) &#123;\n    super(dog);\n  &#125;\n&#125;\n\n输出\n&#x2F;&#x2F; .d.ts\ninterface Animal &#123;\n  dateOfBirth: any;\n&#125;\ninterface Dog extends Animal &#123;\n  breed: any;\n&#125;\ndeclare class AnimalHouse &#123;\n  resident: Animal;\n  constructor(animal: Animal);\n&#125;\ndeclare class DogHouse extends AnimalHouse &#123;\n  resident: Dog;\n  constructor(dog: Dog);\n&#125;\n\nInitialization Order初始化顺序The order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:这段代码的初始化顺序可能会有些不同。\nclass Base &#123;\n  name &#x3D; &quot;base&quot;;\n  constructor() &#123;\n    console.log(&quot;My name is &quot; + this.name);\n  &#125;\n&#125;\n\nclass Derived extends Base &#123;\n  name &#x3D; &quot;derived&quot;;\n&#125;\n\n&#x2F;&#x2F; Prints &quot;base&quot;, not &quot;derived&quot;\nconst d &#x3D; new Derived();\n\nWhat happened here?这里发生了什么？ 先执行基类构造，this.name 值是“base”The order of class initialization, as defined by JavaScript, is:JavaScript 的初始化顺序：\n\nThe base class fields are initialized基类字段初始化\nThe base class constructor runs基类构造函数运行\nThe derived class fields are initialized派生类字段初始化\nThe derived class constructor runs派生类构造函数运行This means that the base class constructor saw its own value for name during its own constructor, because the derived class field initializations hadn’t run yet.\n\nclass Base &#123;\n  name &#x3D; &quot;base&quot;;\n  constructor() &#123;\n    console.log(&quot;My name is &quot; + this.name);\n  &#125;\n&#125;\n\nclass Derived extends Base &#123;\n  name &#x3D; &quot;derived&quot;;\n&#125;\n\n&#x2F;&#x2F; Prints &quot;base&quot;, not &quot;derived&quot;\nconst d &#x3D; new Derived();\nconsole.log(d.name); &#x2F;&#x2F; 加个日志看看\n\n点击 run 后，返回\n[LOG]: &quot;My name is base&quot;\n[LOG]: &quot;derived&quot;\n\nInheriting Built-in Types继承内置类型\n\n\n\n\n\n\n\n\n\nNote: If you don’t plan to inherit from built-in types like Array, Error, Map, etc. or your compilation target is explicitly set to ES6&#x2F;ES2015 or above, you may skip this section注意：如果你不打算继承内置的类型比如 Array、Error、Map 等或者你的编译目标是 ES6/ES2015 或者更新的版本，你可以跳过这个章节。\nIn ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(…). It is necessary for generated constructor code to capture any potential return value of super(…) and replace it with this.在 ES2015 中，当调用 super(...) 的时候，如果构造函数返回了一个对象，会隐式替换 this 的值。所以捕获 super() 可能的返回值并用 this 替换它是非常有必要的。As a result, subclassing Error, Array, and others may no longer work as expected. This is due to the fact that constructor functions for Error, Array, and the like use ECMAScript 6’s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.这就导致，像 Error、Array 等子类，也许不会再如你期望的那样运行。这是因为 Error、Array 等类似内置对象的构造函数，会使用 ECMAScript 6 的 new.target 调整原型链。然而，在 ECMAScript 5 中，当调用一个构造函数的时候，并没有方法可以确保 new.target 的值。 其他的降级编译器默认也会有同样的限制。For a subclass like the following:下面的子类：\nclass MsgError extends Error &#123;\n  constructor(m: string) &#123;\n    super(m);\n  &#125;\n  sayHello() &#123;\n    return &quot;hello &quot; + this.message;\n  &#125;\n&#125;\n\nyou may find that:你也许可以发现：methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error.对象的方法可能是 undefined ，所以调用 sayHello 会导致错误instanceof will be broken between instances of the subclass and their instances, so (new MsgError()) instanceof MsgError will return false.instanceof 失效， (new MsgError()) instanceof MsgError 会返回 false。As a recommendation, you can manually adjust the prototype immediately after any super(…) calls.我们推荐，手动的在 super(...) 调用后调整原型：\nclass MsgError extends Error &#123;\n  constructor(m: string) &#123;\n    super(m);\n\n    &#x2F;&#x2F; Set the prototype explicitly.\n    Object.setPrototypeOf(this, MsgError.prototype);\n  &#125;\n\n  sayHello() &#123;\n    return &quot;hello &quot; + this.message;\n  &#125;\n&#125;\n\nHowever, any subclass of MsgError will have to manually set the prototype as well. For runtimes that don’t support Object.setPrototypeOf, you may instead be able to use __proto__.不过，任何 MsgError 的子类也不得不手动设置原型。如果运行时不支持 Object.setPrototypeOf，你也许可以使用 __proto__ \nUnfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this), but the prototype chain itself cannot be fixed.不幸的是，这些方案并不会能在 IE 10 或者之前的版本正常运行。解决的一个方法是手动拷贝原型中的方法到实例中（就比如 MsgError.prototype 到 this），但是它自己的原型链依然没有被修复\nMember Visibility成员可见性You can use TypeScript to control whether certain methods or properties are visible to code outside the class.你可以使用 TypeScript 控制某个方法或者属性是否对类以外的代码可见。\npublicThe default visibility of class members is public. A public member can be accessed anywhere:因为 public 是默认的可见性修饰符，所以你不需要写它，除非处于格式或者可读性的原因。\nclass Greeter &#123;\n  public greet() &#123;\n    console.log(&quot;hi!&quot;);\n  &#125;\n&#125;\nconst g &#x3D; new Greeter();\ng.greet();\n\nBecause public is already the default visibility modifier, you don’t ever need to write it on a class member, but might choose to do so for style&#x2F;readability reasons.因为 public 是默认的可见性修饰符，所以你不需要写它，除非处于格式或者可读性的原因。\nprotectedprotected members are only visible to subclasses of the class they’re declared in.protected 成员仅仅对子类可见\nclass Greeter &#123;\n  public greet() &#123;\n    console.log(&quot;Hello, &quot; + this.getName());\n  &#125;\n  protected getName() &#123;\n    return &quot;hi&quot;;\n  &#125;\n&#125;\n\nclass SpecialGreeter extends Greeter &#123;\n  public howdy() &#123;\n    &#x2F;&#x2F; OK to access protected member here\n    console.log(&quot;Howdy, &quot; + this.getName());\n  &#125;\n&#125;\nconst g &#x3D; new SpecialGreeter();\ng.greet(); &#x2F;&#x2F; OK\ng.getName();\n&#x2F;&#x2F; Property &#39;getName&#39; is protected and only accessible within class &#39;Greeter&#39; and its subclasses.\n\nExposure of protected members受保护成员的公开\nDerived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making protected members public:派生类需要遵循基类的实现，但是依然可以选择公开拥有更多能力的基类子类型，这就包括让一个 protected 成员变成 public：\nclass Base &#123;\n  protected m &#x3D; 10;\n&#125;\nclass Derived extends Base &#123;\n  &#x2F;&#x2F; No modifier, so default is &#39;public&#39;\n  m &#x3D; 15;\n&#125;\nconst d &#x3D; new Derived();\nconsole.log(d.m); &#x2F;&#x2F; OK\n\nNote that Derived was already able to freely read and write m, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the protected modifier if this exposure isn’t intentional.这里需要注意的是，如果公开不是故意的，在这个派生类中，我们需要小心的拷贝 protected 修饰符。\nCross-hierarchy protected access交叉等级受保护成员访问\nDifferent OOP languages disagree about whether it’s legal to access a protected member through a base class reference:\n不同的 OOP 语言在通过一个基类引用是否可以合法的获取一个 protected 成员是有争议的。\nclass Base &#123;\n  protected x: number &#x3D; 1;\n&#125;\nclass Derived1 extends Base &#123;\n  protected x: number &#x3D; 5;\n&#125;\nclass Derived2 extends Base &#123;\n  f1(other: Derived2) &#123;\n    other.x &#x3D; 10;\n  &#125;\n  f2(other: Base) &#123;\n    other.x &#x3D; 10;\n    &#x2F;&#x2F; Property &#39;x&#39; is protected and only accessible through an instance of class &#39;Derived2&#39;. This is an instance of class &#39;Base&#39;.\n    &#x2F;&#x2F; 属性 &#39;x&#39; 受保护并且只能通过类 &#39;Derived2&#39; 的实例访问。这是一个类 &#39;Base&#39; 的实例。\n  &#125;\n&#125;\n\nJava, for example, considers this to be legal. On the other hand, C# and C++ chose that this code should be illegal.在 Java 中，这是合法的，而 C# 和 C++ 认为这段代码是不合法的。TypeScript sides with C# and C++ here, because accessing x in Derived2 should only be legal from Derived2’s subclasses, and Derived1 isn’t one of them. Moreover, if accessing x through a Derived1 reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.TypeScript 站在 C# 和 C++ 这边。因为 Derived2 的 x 应该只有从 Derived2 的子类访问才是合法的，而 Derived1 并不是它们中的一个。此外，如果通过 Derived1 访问 x 是不合法的，通过一个基类引用访问也应该是不合法的。See also Why Can’t I Access A Protected Member From A Derived Class? which explains more of C#‘s reasoning.看这篇《Why Can’t I Access A Protected Member From A Derived Class?》 (opens new window)，解释了更多 C# 这样做的原因。\nprivateprivate is like protected, but doesn’t allow access to the member even from subclasses:private 有点像 protected ，但是不允许访问成员，即便是子类。\nclass Base &#123;\n  private x &#x3D; 0;\n&#125;\nconst b &#x3D; new Base();\n&#x2F;&#x2F; Can&#39;t access from outside the class\n&#x2F;&#x2F; 不能从外部访问\nconsole.log(b.x);\n&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.\n&#x2F;&#x2F; 属性 &#39;x&#39; 是私有的，只能在类 &#39;Base&#39; 中访问。\n\nclass Derived extends Base &#123;\n  showX() &#123;\n    &#x2F;&#x2F; Can&#39;t access in subclasses\n    console.log(this.x);\n    &#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.\n    &#x2F;&#x2F; 属性 &#39;x&#39; 是私有的，只能在类 &#39;Base&#39; 中访问。\n  &#125;\n&#125;\n\nBecause private members aren’t visible to derived classes, a derived class can’t increase its visibility:因为 private 成员对派生类并不可见，所以一个派生类也不能增加它的可见性：\nclass Base &#123;\n  private x &#x3D; 0;\n&#125;\nclass Derived extends Base &#123;\n  &#x2F;&#x2F; Class &#39;Derived&#39; incorrectly extends base class &#39;Base&#39;.\n  &#x2F;&#x2F; 类 &#39;Derived&#39; 错误地继承了基类 &#39;Base&#39;。\n  &#x2F;&#x2F; Property &#39;x&#39; is private in type &#39;Base&#39; but not in type &#39;Derived&#39;.\n  &#x2F;&#x2F; 属性 &#39;x&#39; 在类 &#39;Base&#39; 中，但不在类 &#39;Derived&#39; 中。\n  x &#x3D; 1;\n&#125;\n\nCross-instance private access交叉等级受保护成员访问Different OOP languages disagree about whether different instances of the same class may access each others’ private members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.不同的 OOP 语言在通过一个基类引用是否可以合法的获取一个 protected 成员是有争议的。在 Java, C#, C++, Swift, and PHP 中，这是合法的，而 Ruby 认为这段代码是不合法的。TypeScript does allow cross-instance private access:允许交叉实例私有访问\nclass A &#123;\n  private x &#x3D; 10;\n\n  public sameAs(other: A) &#123;\n    &#x2F;&#x2F; No error\n    return other.x &#x3D;&#x3D;&#x3D; this.x;\n  &#125;\n&#125;\n\nCaveats警告\n\n\n\n\n\n\n\n\n\nLike other aspects of TypeScript’s type system, private and protected are only enforced during type checking.类型检查中，private 和 protected 只是类型检查的一部分。\nThis means that JavaScript runtime constructs like in or simple property lookup can still access a private or protected member:这意味着在 JavaScript 运行时，像 in 或者简单的属性查找，依然可以获取 private 或者 protected 成员。\nclass MySafe &#123;\n  private secretKey &#x3D; 12345;\n&#125;\n\n&#x2F;&#x2F; In a JavaScript file...\nconst s &#x3D; new MySafe();\n&#x2F;&#x2F; Will print 12345\nconsole.log(s.secretKey);\n\nprivate also allows access using bracket notation during type checking. This makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy.private 也允许使用方括号来访问，这使得 private-declared 字段可以轻松地访问，但是这些字段是软私有的，并不强制私密。\nclass MySafe &#123;\nprivate secretKey &#x3D; 12345;\n&#125;\n\nconst s &#x3D; new MySafe();\n\n&#x2F;&#x2F; Not allowed during type checking\nconsole.log(s.secretKey);\nProperty &#39;secretKey&#39; is private and only accessible within class &#39;MySafe&#39;.\n\n&#x2F;&#x2F; OK\nconsole.log(s[&quot;secretKey&quot;]);\n\nUnlike TypeScripts’s private, JavaScript’s private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private.不像 TypeScript 的 private，JavaScript 的私有字段 (opens new window)（#）即便是编译后依然保留私有性，并且不会提供像上面这种方括号获取的方法，这让它们变得强私有（hard private）。\nclass Dog &#123;\n  #barkAmount &#x3D; 0;\n  personality &#x3D; &quot;happy&quot;;\n\n  constructor() &#123;&#125;\n&#125;\n\n&quot;use strict&quot;;\nclass Dog &#123;\n  #barkAmount &#x3D; 0;\n  personality &#x3D; &quot;happy&quot;;\n  constructor() &#123;&#125;\n&#125;\n\nWhen compiling to ES2021 or less, TypeScript will use WeakMaps in place of #.在编译到 ES2021 或更低版本时，TypeScript 会使用 WeakMaps 替代 #。\n&quot;use strict&quot;;\nvar _Dog_barkAmount;\nclass Dog &#123;\n  constructor() &#123;\n    _Dog_barkAmount.set(this, 0);\n    this.personality &#x3D; &quot;happy&quot;;\n  &#125;\n&#125;\n_Dog_barkAmount &#x3D; new WeakMap();\n\nIf you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.如果你需要防止恶意攻击，保护类中的值，你应该使用强私有的机制比如闭包，WeakMaps ，或者私有字段。但是注意，这也会在运行时影响性能。\nStatic Members静态成员\nBackground Reading: Static Members (MDN)\nClasses may have static members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:类可以有静态成员，静态成员跟类实例没有关系，可以通过类本身访问到：\nclass MyClass &#123;\n  static x &#x3D; 0;\n  static printX() &#123;\n    console.log(MyClass.x);\n  &#125;\n&#125;\nconsole.log(MyClass.x);\nMyClass.printX();\n\nStatic members can also use the same public, protected, and private visibility modifiers:类可以有静态成员，静态成员跟类实例没有关系，可以通过类本身访问到：\nclass MyClass &#123;\n  private static x &#x3D; 0;\n&#125;\nconsole.log(MyClass.x);\n&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;MyClass&#39;.\n\nStatic members are also inherited:静态成员也可以被继承：\nclass Base &#123;\n  static getGreeting() &#123;\n    return &quot;Hello world&quot;;\n  &#125;\n&#125;\nclass Derived extends Base &#123;\n  myGreeting &#x3D; Derived.getGreeting();\n&#125;\n\nSpecial Static Names特殊静态类It’s generally not safe&#x2F;possible to overwrite properties from the Function prototype. Because classes are themselves functions that can be invoked with new, certain static names can’t be used. Function properties like name, length, and call aren’t valid to define as static members:类本身是函数，而覆写 Function 原型上的属性通常认为是不安全的，因此不能使用一些固定的静态名称，函数属性像 name、length、call 不能被用来定义 static 成员：\nclass S &#123;\n  static name &#x3D; &quot;S!&quot;;\n  &#x2F;&#x2F; Static property &#39;name&#39; conflicts with built-in property &#39;Function.name&#39; of constructor function &#39;S&#39;.\n&#125;\n\nWhy No Static Classes?为什么没有静态类？\nTypeScript (and JavaScript) don’t have a construct called static class the same way as, for example, C# does.TypeScript（和 JavaScript） 并没有名为静态类（static class）的结构，但是像 C# 和 Java 有。Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript&#x2F;TypeScript.所谓静态类，指的是作为类的静态成员存在于某个类的内部的类。比如这种：For example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:静态类之所以存在是因为这些语言强迫所有的数据和函数都要在一个类内部，但这个限制在 TypeScript 中并不存在，所以也没有静态类的需要。一个只有一个单独实例的类，在 JavaScript/TypeScript 中，完全可以使用普通的对象替代。\n&#x2F;&#x2F; Unnecessary &quot;static&quot; class\nclass MyStaticClass &#123;\n  static doSomething() &#123;&#125;\n&#125;\n\n&#x2F;&#x2F; Preferred (alternative 1)\nfunction doSomething() &#123;&#125;\n\n&#x2F;&#x2F; Preferred (alternative 2)\nconst MyHelperObject &#x3D; &#123;\n  dosomething() &#123;&#125;,\n&#125;;\n\nstatic Blocks in Classes类静态块Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.静态块允许你写一系列有自己作用域的语句，也可以获取类里的私有字段。这意味着我们可以安心的写初始化代码：正常书写语句，无变量泄漏，还可以完全获取类中的属性和方法。\nclass Foo &#123;\n  static #count &#x3D; 0;\n\n  get count() &#123;\n    return Foo.#count;\n  &#125;\n\n  static &#123;\n    try &#123;\n      const lastInstances &#x3D; loadLastInstances();\n      Foo.#count +&#x3D; lastInstances.length;\n    &#125; catch &#123;&#125;\n  &#125;\n&#125;\n\nGeneric Classes范型类\nClasses, much like interfaces, can be generic. When a generic class is instantiated with new, its type parameters are inferred the same way as in a function call:类跟接口一样，也可以写泛型。当使用 new 实例化一个泛型类，它的类型参数的推断跟函数调用是同样的方式：\nclass Box&lt;Type&gt; &#123;\n  contents: Type;\n  constructor(value: Type) &#123;\n    this.contents &#x3D; value;\n  &#125;\n&#125;\n\nconst b &#x3D; new Box(&quot;hello!&quot;);\n\nconst b: Box&lt;string&gt;;\n\nClasses can use generic constraints and defaults the same way as interfaces.类跟接口一样也可以使用泛型约束以及默认值。\nType Parameters in Static Members静态成员中的类型参数This code isn’t legal, and it may not be obvious why:这段代码不合法，并且可能不明白为什么：\nclass Box&lt;Type&gt; &#123;\nstatic defaultValue: Type;\nStatic members cannot reference class type parameters.\n&#125;\n\nRemember that types are always fully erased! At runtime, there’s only one Box.defaultValue property slot. This means that setting Box.defaultValue (if that were possible) would also change Box.defaultValue - not good. The static members of a generic class can never refer to the class’s type parameters.记住类型会被完全抹除，运行时，只有一个 Box.defaultValue 属性槽。这也意味着如果设置 Box&lt;string&gt;.defaultValue 是可以的话，这也会改变 Box&lt;number&gt;.defaultValue，而这样是不好的。\nthis at Runtime in ClassesBackground Reading:背景阅读：this keyword (MDN)It’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.TypeScript 并不会更改 JavaScript 运行时的行为，并且 JavaScript 有时会出现一些奇怪的运行时行为。JavaScript’s handling of this is indeed unusual:就比如 JavaScript 处理 this 就很奇怪：\nclass MyClass &#123;\n  name &#x3D; &quot;MyClass&quot;;\n  getName() &#123;\n    return this.name;\n  &#125;\n&#125;\nconst c &#x3D; new MyClass();\nconst obj &#x3D; &#123;\n  name: &quot;obj&quot;,\n  getName: c.getName,\n&#125;;\n&#x2F;&#x2F; Prints &quot;obj&quot;, not &quot;MyClass&quot;\nconsole.log(obj.getName());\n\nLong story short, by default, the value of this inside a function depends on how the function was called. In this example, because the function was called through the obj reference, its value of this was obj rather than the class instance.长篇大论，默认情况下，函数内部的 this 值取决于函数被调用的方式。在这个例子中，因为函数被 obj 引用调用，它的 this 值是 obj，而不是类实例。This is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.这很少是你想要的！TypeScript 提供了一些方法来解决这种错误。\nArrow FunctionsBackground Reading:背景阅读：Arrow functions (MDN)\nIf you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition:如果你有一个函数，经常在被调用的时候丢失 this 上下文，使用一个箭头函数或许更好些。\nclass MyClass &#123;\n  name &#x3D; &quot;MyClass&quot;;\n  getName &#x3D; () &#x3D;&gt; &#123;\n    return this.name;\n  &#125;;\n&#125;\nconst c &#x3D; new MyClass();\nconst g &#x3D; c.getName;\n&#x2F;&#x2F; Prints &quot;MyClass&quot; instead of crashing\nconsole.log(g());\n\nThis has some trade-offs:这里有几点需要注意下：\n\nThe this value is guaranteed to be correct at runtime, even for code not checked with TypeScript- 这个 this 值在运行时是一定的，即使没有 TypeScript 的检查\nThis will use more memory, because each class instance will have its own copy of each function defined this way- 这会使用更多的内存，因为每个类实例都会有自己的拷贝\nYou can’t use super.getName in a derived class, because there’s no entry in the prototype chain to fetch the base class method from- 你不能在子类中使用 super.getName，因为没有基类原型链来获取基类方法\n\nthis parametersIn a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation:在方法或函数定义中，一个初始参数名为 this 的特殊意义在 TypeScript 中。这些参数在编译期间会被抹除。\n&#x2F;&#x2F; TypeScript input with &#39;this&#39; parameter\nfunction fn(this: SomeType, x: number) &#123;\n  &#x2F;* ... *&#x2F;\n&#125;\n\n&#x2F;&#x2F; JavaScript output\nfunction fn(x) &#123;\n  &#x2F;* ... *&#x2F;\n&#125;\n\nTypeScript checks that calling a function with a this parameter is done so with a correct context. Instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly:TypeScript 会检查一个有 this 参数的函数在调用时是否有一个正确的上下文。不像上个例子使用箭头函数，我们可以给方法定义添加一个 this 参数，静态强制方法被正确调用：\nclass MyClass &#123;\n  name &#x3D; &quot;MyClass&quot;;\n  getName(this: MyClass) &#123;\n    return this.name;\n  &#125;\n&#125;\nconst c &#x3D; new MyClass();\n&#x2F;&#x2F; OK\nc.getName();\n\n&#x2F;&#x2F; Error, would crash\nconst g &#x3D; c.getName;\nconsole.log(g());\n&#x2F;&#x2F; The &#39;this&#39; context of type &#39;void&#39; is not assignable to method&#39;s &#39;this&#39; of type &#39;MyClass&#39;.\n\nThis method makes the opposite trade-offs of the arrow function approach:这个方法也有一些注意点，正好跟箭头函数相反：\n\nJavaScript callers might still use the class method incorrectly without realizing itJavaScript 调用者依然可能在没有意识到它的时候错误使用类方法\nOnly one function per class definition gets allocated, rather than one per class instance每个类一个函数，而不是每一个类实例一个函数\nBase method definitions can still be called via super.基类方法定义依然可以通过 super 调用\n\nthis TypesIn classes, a special type called this refers dynamically to the type of the current class. Let’s see how this is useful:在类中，一个特殊的类型叫做 this，它可以动态指向当前类的类型。\nclass Box &#123;\n  contents: string &#x3D; &quot;&quot;;\n  set(value: string) &#123;\n    &#x2F;&#x2F; (method) Box.set(value: string): this\n    this.contents &#x3D; value;\n    return this;\n  &#125;\n&#125;\n\nHere, TypeScript inferred the return type of set to be this, rather than Box. Now let’s make a subclass of Box:这里，TypeScript 推断 set 的返回类型为 this，而不是 Box。\nclass ClearableBox extends Box &#123;\n  clear() &#123;\n    this.contents &#x3D; &quot;&quot;;\n  &#125;\n&#125;\n\nconst a &#x3D; new ClearableBox();\nconst b &#x3D; a.set(&quot;hello&quot;);\n\n&#x2F;&#x2F; const b: ClearableBox\n\nYou can also use this in a parameter type annotation:你也可以在参数类型注解中使用 this：\nclass Box &#123;\n  content: string &#x3D; &quot;&quot;;\n  sameAs(other: this) &#123;\n    return other.content &#x3D;&#x3D;&#x3D; this.content;\n  &#125;\n&#125;\n\nThis is different from writing other: Box — if you have a derived class, its sameAs method will now only accept other instances of that same derived class:这与写其他：Box — 如果你有一个派生类，它的 sameAs 方法将只接受来自同一派生类的其他实例：\nclass Box &#123;\n  content: string &#x3D; &quot;&quot;;\n  sameAs(other: this) &#123;\n    return other.content &#x3D;&#x3D;&#x3D; this.content;\n  &#125;\n&#125;\n\nclass DerivedBox extends Box &#123;\n  otherContent: string &#x3D; &quot;?&quot;;\n&#125;\n\nconst base &#x3D; new Box();\nconst derived &#x3D; new DerivedBox();\nderived.sameAs(base);\n&#x2F;&#x2F; Argument of type &#39;Box&#39; is not assignable to parameter of type &#39;DerivedBox&#39;.\n&#x2F;&#x2F; Property &#39;otherContent&#39; is missing in type &#39;Box&#39; but required in type &#39;DerivedBox&#39;.\n\nthis -based type guardsYou can use this is Type in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type.你可以在类和接口中的方法的返回位置使用 this。当混入一个类型缩小（如 if 语句）的时候，目标对象的类型将被缩小到指定的类型。\nclass FileSystemObject &#123;\n  isFile(): this is FileRep &#123;\n    return this instanceof FileRep;\n  &#125;\n  isDirectory(): this is Directory &#123;\n    return this instanceof Directory;\n  &#125;\n  isNetworked(): this is Networked &amp; this &#123;\n    return this.networked;\n  &#125;\n  constructor(public path: string, private networked: boolean) &#123;&#125;\n&#125;\n\nclass FileRep extends FileSystemObject &#123;\n  constructor(path: string, public content: string) &#123;\n    super(path, false);\n  &#125;\n&#125;\n\nclass Directory extends FileSystemObject &#123;\n  children: FileSystemObject[];\n&#125;\n\ninterface Networked &#123;\n  host: string;\n&#125;\n\nconst fso: FileSystemObject &#x3D; new FileRep(&quot;foo&#x2F;bar.txt&quot;, &quot;foo&quot;);\n\nif (fso.isFile()) &#123;\n  fso.content;\n  &#x2F;&#x2F; const fso: FileRep;\n&#125; else if (fso.isDirectory()) &#123;\n  fso.children;\n  &#x2F;&#x2F; const fso: Directory;\n&#125; else if (fso.isNetworked()) &#123;\n  fso.host;\n  &#x2F;&#x2F; const fso: Networked &amp; FileSystemObject;\n&#125;\n\nA common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an undefined from the value held inside box when hasValue has been verified to be true:一个常见的基于 this 的类型保护的使用例子，会对一个特定的字段进行懒校验（lazy validation）。举个例子，在这个例子中，当 hasValue 被验证为 true 时，会从类型中移除 undefined：\nclass Box&lt;T&gt; &#123;\nvalue?: T;\n\nhasValue(): this is &#123; value: T &#125; &#123;\nreturn this.value !&#x3D;&#x3D; undefined;\n&#125;\n&#125;\n\nconst box &#x3D; new Box();\nbox.value &#x3D; &quot;Gameboy&quot;;\n\nbox.value;\n\n(property) Box&lt;unknown&gt;.value?: unknown\n\nif (box.hasValue()) &#123;\nbox.value;\n\n(property) value: unknown\n&#125;\n\nParameter Properties参数属性TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s):TypeScript 提供了特殊的语法，可以把一个构造函数参数转成一个同名同值的类属性。这些就被称为参数属性（parameter properties）。你可以通过在构造函数参数前添加一个可见性修饰符 public private protected 或者 readonly 来创建参数属性，最后这些类属性字段也会得到这些修饰符：\n之后我们 look 一下 flutter,太像\nclass Params &#123;\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) &#123;\n    &#x2F;&#x2F; No body necessary\n  &#125;\n&#125;\nconst a &#x3D; new Params(1, 2, 3);\nconsole.log(a.x);\n\n&#x2F;&#x2F; (property) Params.x: number\nconsole.log(a.z);\n&#x2F;&#x2F; Property &#39;z&#39; is private and only accessible within class &#39;Params&#39;.\n\nClass Expressions类表达式\nBackground Reading:背景阅读：Class expressions (MDN)\nClass expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:类表达式跟类声明非常类似，唯一不同的是类表达式不需要一个名字，尽管我们可以通过绑定的标识符进行引用：\nconst someClass &#x3D; class&lt;Type&gt; &#123;\n  content: Type;\n  constructor(value: Type) &#123;\n    this.content &#x3D; value;\n  &#125;\n&#125;;\n\nconst m &#x3D; new someClass(&quot;Hello, world&quot;);\n\n&#x2F;&#x2F; const m: someClass&lt;string&gt;;\n\nabstract Classes and Members抽象类和成员Classes, methods, and fields in TypeScript may be abstract.TypeScript 中，类、方法、字段都可以是抽象的（abstract）。An abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.抽象方法或者抽象字段是不提供实现的。这些成员必须存在在一个抽象类中，这个抽象类也不能直接被实例化。The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete.抽象类的作用是作为子类的基类，让子类实现所有的抽象成员。当一个类没有任何抽象成员，他就会被认为是具体的（concrete）。Let’s look at an example:让我们看个例子：\nabstract class Base &#123;\n  abstract getName(): string;\n\n  printName() &#123;\n    console.log(&quot;Hello, &quot; + this.getName());\n  &#125;\n&#125;\n\nconst b &#x3D; new Base();\n&#x2F;&#x2F; Cannot create an instance of an abstract class.\n\nWe can’t instantiate Base with new because it’s abstract. Instead, we need to make a derived class and implement the abstract members:我们不能使用 new 实例 Base 因为它是抽象类。我们需要写一个派生类，并且实现抽象成员。\nclass Derived extends Base &#123;\n  getName() &#123;\n    return &quot;world&quot;;\n  &#125;\n&#125;\n\nconst d &#x3D; new Derived();\nd.printName();\n\nNotice that if we forget to implement the base class’s abstract members, we’ll get an error:注意，如果我们忘记实现基类的抽象成员，我们会得到一个报错：\nclass Derived extends Base &#123;\n  &#x2F;&#x2F; Non-abstract class &#39;Derived&#39; does not implement inherited abstract member &#39;getName&#39; from class &#39;Base&#39;.\n  &#x2F;&#x2F; forgot to do anything\n&#125;\n\nAbstract Construct Signatures抽象构造签名\nSometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.有的时候，你希望接受传入可以继承一些抽象类产生一个类的实例的类构造函数。For example, you might want to write this code:举个例子，你也许会写这样的代码：\nfunction greet(ctor: typeof Base) &#123;\n  const instance &#x3D; new ctor();\n  &#x2F;&#x2F; Cannot create an instance of an abstract class.\n  instance.printName();\n&#125;\n\nTypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of greet, it’s perfectly legal to write this code, which would end up constructing an abstract class:TypeScript 会报错，告诉你正在尝试实例化一个抽象类。毕竟，根据 greet 的定义，这段代码应该是合法的：\n&#x2F;&#x2F; Bad!\ngreet(Base);\n\nInstead, you want to write a function that accepts something with a construct signature:但如果你写一个函数接受传入一个构造签名：\nfunction greet(ctor: new () &#x3D;&gt; Base) &#123;\n  const instance &#x3D; new ctor();\n  instance.printName();\n&#125;\ngreet(Derived);\ngreet(Base);\n&#x2F;&#x2F; Argument of type &#39;typeof Base&#39; is not assignable to parameter of type &#39;new () &#x3D;&gt; Base&#39;.\n&#x2F;&#x2F; 参数类型 &#39;typeof Base&#39; 不能赋值给参数类型 &#39;new () &#x3D;&gt; Base&#39;。\n&#x2F;&#x2F; Cannot assign an abstract constructor type to a non-abstract constructor type.\n&#x2F;&#x2F; 不能将一个抽象构造类型赋值给一个非抽象构造类型。\n\nNow TypeScript correctly tells you about which class constructor functions can be invoked - Derived can because it’s concrete, but Base cannot.现在 TypeScript 会正确的告诉你，哪一个类构造函数可以被调用，Derived 可以，因为它是具体的，而 Base 是不能的。\nRelationships Between Classes类之间的关系In most cases, classes in TypeScript are compared structurally, the same as other types.大部分时候，TypeScript 的类跟其他类型一样，会被结构性比较。For example, these two classes can be used in place of each other because they’re identical:举个例子，这两个类可以用于替代彼此，因为它们结构是相等的：\nclass Point1 &#123;\n  x &#x3D; 0;\n  y &#x3D; 0;\n&#125;\n\nclass Point2 &#123;\n  x &#x3D; 0;\n  y &#x3D; 0;\n&#125;\n\n&#x2F;&#x2F; OK\nconst p: Point1 &#x3D; new Point2();\n\nSimilarly, subtype relationships between classes exist even if there’s no explicit inheritance:类似的还有，类的子类型之间可以建立关系，即使没有明显的继承：\nclass Person &#123;\n  name: string;\n  age: number;\n&#125;\n\nclass Employee &#123;\n  name: string;\n  age: number;\n  salary: number;\n&#125;\n\n&#x2F;&#x2F; OK\nconst p: Person &#x3D; new Employee();\n\nThis sounds straightforward, but there are a few cases that seem stranger than others.这听起来有些简单，但还有一些例子可以看出奇怪的地方。\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:\n空类没有任何成员。在一个结构化类型系统中，没有成员的类型通常是任何其他类型的父类型。所以如果你写一个空类（只是举例，你可不要这样做），任何东西都可以用来替换它：\nclass Empty &#123;&#125;\n\nfunction fn(x: Empty) &#123;\n  &#x2F;&#x2F; can&#39;t do anything with &#39;x&#39;, so I won&#39;t\n&#125;\n\n&#x2F;&#x2F; All OK!\nfn(window);\nfn(&#123;&#125;);\nfn(fn);\n参考链接typescript官网 类类（Classes）\n","slug":"2022-06-08ts-classes","date":"2022-06-08T06:21:19.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"62218ddca7698d868da0d101af067d2c","title":"7.Typescript手册 类型操作","content":"ts 类型如何调试\n不是代码逻辑如何调试，没想到\n\nts 自定义类型如何打印\n不是 js 的结果如何打印，没想到\n\nCreating Types from Types从已有类型中创建类型\nTypeScript 的类型系统非常强大，因为它允许表达类型的另一种表达方式。最简单的方式是泛型，我们实际上有一大堆的类型操作符可用。还可以表达类型的另一种表达方式，就是把已有的值作为类型。通过合并多种类型操作符，我们可以表达复杂的操作和值，这里我们将介绍以另一个类型或值为基础如何表达一个新类型。\n简单来说：使用 范型 或 6种表达式 来创建新类型\n\n范型 - 类型需要参数\n\nKeyof Type Operator - 用 keyof 操作去创建新类型\n\nTypeof Type Operator - 用 typeof 操作去创建新类型\n\nIndexed Access Types - 使用 Type[‘a’]语法去访问一个类型的一部分\n\nConditional Types - 类型行为像 if 语句一样\n\nMapped Types - 通过映射已有类型的每个属性来创建新类型\n\nTemplate Literal Types - 通过模板字符串来改变属性的映射类型\n\n\nKeyof Type Operator\n这个操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：\n\ntype P1 &#x3D; keyof any; &#x2F;&#x2F; 提示：type P1 &#x3D; string | number | symbol\n\ntype Point &#x3D; &#123; x: number; y: number &#125;;\ntype P &#x3D; keyof Point; &#x2F;&#x2F; 提示：type P &#x3D; keyof Point，这个提示等于没提示\n\n\n如果这个类型有字符串或者数字索引，keyof 就会返回这个类型：\n\ntype Arrayish &#x3D; &#123; [n: number]: unknown &#125;;\ntype A &#x3D; keyof Arrayish; &#x2F;&#x2F;提示：type A &#x3D; number\n\ntype Mapish &#x3D; &#123; [k: string]: boolean &#125;;\ntype M &#x3D; keyof Mapish; &#x2F;&#x2F; 提示：type M &#x3D; string | number\n\n&#x2F;&#x2F; --------------------------------------------------------------\n&#x2F;&#x2F; 对于Arrayish\n\n&#x2F;&#x2F; 实例1:ok\nvar a: Arrayish &#x3D; &#123;\n  1: &quot;string&quot;,\n  2: false,\n&#125;;\n&#x2F;&#x2F; 实例2: ok\nvar a1: Arrayish &#x3D; [1, 2, 3, 4];\n\n&#x2F;&#x2F; 对于 Mapish\nvar b: Mapish &#x3D; &#123;\n  name: true,\n  age: false,\n&#125;;\n\n注意，这个例子中，M 是 string | number — 这是因为 JavaScript 对象键是总是被强制为字符串，所以 obj[0] 总是和 obj[“0”] 相同。\nkeyof 类型操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：\nTypeof type operatorJavaScript 也有一个 typeof 操作符，可以用在表达式中：\n&#x2F;&#x2F; Prints &quot;string&quot;\nconsole.log(typeof &quot;Hello world&quot;);\n\nTypeScript 增加了一个 typeof 操作符，可以用在类型上：\nlet s &#x3D; &quot;hello&quot;;\nlet n: typeof s; &#x2F;&#x2F; 提示：let n: string\n\nReturnType对于基本类型，typeof 操作符没有意义，但是与其他类型操作符结合使用，可以用 typeof 操作符来实现一些模式。例如，我们开始用 ReturnType 来表示函数的返回类型：\ntype Predicate &#x3D; (x: unknown) &#x3D;&gt; boolean;\ntype K &#x3D; ReturnType&lt;Predicate&gt;; &#x2F;&#x2F; 提示 type K &#x3D; boolean\n\n如果我们尝试使用 ReturnType 在函数名上，我们会看到一个指示性的错误：\nfunction f() &#123;\n  return &#123; x: 10, y: 3 &#125;;\n&#125;\ntype P &#x3D; ReturnType&lt;f&gt;;\n&#x2F;&#x2F; 提示：&#39;f&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof f&#39;?\n&#x2F;&#x2F; 提示：&#39;f&#39; 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof f&#39; 来代替 &#39;f&#39;？\n\n记住，值和类型不是一回事。要引用值 f 所拥有的类型，我们使用 typeof：\nfunction f() &#123;\n  return &#123; x: 10, y: 3 &#125;;\n&#125;\ntype P &#x3D; ReturnType&lt;typeof f&gt;;\n\n&#x2F;**\n * 提示\n * type P &#x3D; &#123;\n    x: number;\n    y: number;\n&#125;\n**&#x2F;\n\n限制\ntypescript 通常限制了 typeof 的表达式的类型。特殊的，typeof 的表达式只能用于标识符（即变量名）其属性。这个限制是为了避免写一些你认为是执行的代码，但实际上并不是的：\n&#x2F;&#x2F; Meant to use &#x3D; ReturnType&lt;typeof msgbox&gt;\nlet shouldContinue: typeof msgbox(&quot;Are you sure you want to continue?&quot;);\n&#x2F;&#x2F; &#39;,&#39; expected.\n\nIndexed Access Types我们可以使用索引访问类型来查找一个类型的特定属性：\ntype Person &#x3D; &#123; age: number; name: string; alive: boolean &#125;;\ntype Age &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示：type Age &#x3D; number\n\n这个索引类型本身是一个类型，所以我们可以使用联合，keyof 或者其他类型：\ntype I1 &#x3D; Person[&quot;age&quot; | &quot;name&quot;]; &#x2F;&#x2F; 提示：type I1 &#x3D; string | number\n\ntype I2 &#x3D; Person[keyof Person]; &#x2F;&#x2F; 提示：type I2 &#x3D; string | number | boolean\n\ntype AliveOrName &#x3D; &quot;alive&quot; | &quot;name&quot;;\ntype I3 &#x3D; Person[AliveOrName]; &#x2F;&#x2F; 提示：type I3 &#x3D; string | boolean\n\n你会看到一个错误，如果你尝试索引一个不存在的属性：\ntype I1 &#x3D; Person[&quot;alve&quot;];\nProperty &#39;alve&#39; does not exist on type &#39;Person&#39;.\n\n另一个例子是使用 number 来获取数组的元素类型。我们可以使用 typeof 来方便地捕获数组字面量的元素类型。\nconst MyArray &#x3D; [\n  &#123; name: &quot;Alice&quot;, age: 15 &#125;,\n  &#123; name: &quot;Bob&quot;, age: 23 &#125;,\n  &#123; name: &quot;Eve&quot;, age: 38 &#125;,\n];\n\ntype Person &#x3D; typeof MyArray[number];\n\n&#x2F;&#x2F; 提示：type Person &#x3D; &#123; name: string; age: number; &#125;\n\ntype Age &#x3D; typeof MyArray[number][&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age &#x3D; number;\n&#x2F;&#x2F; Or\ntype Age2 &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age2 &#x3D; number;\n\n你只能使用类型来索引，意味着你不能使用 const 来创建一个变量引用：\nconst key &#x3D; &quot;age&quot;;\ntype Age &#x3D; Person[key];\n&#x2F;&#x2F; Type &#39;key&#39; cannot be used as an index type.\n&#x2F;&#x2F; 这个错误是因为 key 是一个字面量，而不是一个变量。\n&#x2F;&#x2F; &#39;key&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof key&#39;?\n&#x2F;&#x2F; 这个错误是因为 key 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof key&#39; 来代替 &#39;key&#39;？\n\n然而，你可以使用一个类型别名来替换相同的风格的重构：\ntype key &#x3D; &quot;age&quot;;\ntype Age &#x3D; Person[key];\n\nConditional TypesAt the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. Conditional types help describe the relation between the types of inputs and outputs.在最常见的程序中，我们需要根据输入来做决策。 JavaScript 程序是不同的，但是给定了这个事实，那些决策是根据输入的类型来做的。条件类型帮助描述输入和输出类型之间的关系。\ninterface Animal &#123;\n  live(): void;\n&#125;\ninterface Dog extends Animal &#123;\n  woof(): void;\n&#125;\n\ntype Example1 &#x3D; Dog extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example1 &#x3D; number\n\ntype Example2 &#x3D; RegExp extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example2 &#x3D; string\n\n条件类型的表达式像 JavaScript 中的条件表达式一样：\nSomeType extends OtherType ? TrueType : FalseType;\n\n此段内容，原文保留When the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).\n当 extends 左边的类型可以赋值给右边的类型时，你会得到第一个分支的类型（“true”分支）；否则你会得到第二个分支的类型（“false”分支）。\nFrom the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not Dog extends Animal and pick number or string! But the power of conditional types comes from using them with generics.从上面的例子中可以看到条件类型可能不会立即看起来很有用，我们可以告诉自己 Dog 是否继承了 Animal，然后选择 number 或 string！但是条件类型的力量来自于使用它们与泛型。\nFor example, let’s take the following createLabel function:例如，我们可以把下面的 createLabel 函数拿来说说：\ninterface IdLabel &#123;\n  id: number &#x2F;* some fields *&#x2F;;\n&#125;\ninterface NameLabel &#123;\n  name: string &#x2F;* other fields *&#x2F;;\n&#125;\n\nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel &#123;\n  throw &quot;unimplemented&quot;;\n&#125;\n\nThese overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:这些 createLabel 的重载描述了一个单一的 JavaScript 函数，它根据输入的类型来做决策。请注意一些事情：\nIf a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.We have to create three overloads: one for each case when we’re sure of the type (one for string and one for number), and one for the most general case (taking a string | number). For every new type createLabel can handle, the number of overloads grows exponentially.如果一个库需要在其 API 中重复使用相同的选择，这就变得非常麻烦。我们需要创建三个重载：一个当我们知道类型时，一个当我们知道类型时，一个当我们不知道类型时。对于每个新的类型 createLabel 可以处理，重载的数量就会指数增长。Instead, we can encode that logic in a conditional type:反之，我们可以使用条件类型来表示逻辑：\ntype NameOrId&lt;T extends number | string&gt; &#x3D; T extends number\n  ? IdLabel\n  : NameLabel;\n\nWe can then use that conditional type to simplify our overloads down to a single function with no overloads.我们可以使用这个条件类型来简化我们的重载，只有一个函数。\nfunction createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; &#123;\n  throw &quot;unimplemented&quot;;\n&#125;\n\nlet a &#x3D; createLabel(&quot;typescript&quot;);\n\n&#x2F;&#x2F; 提示：let a: NameLabel;\n\nlet b &#x3D; createLabel(2.8);\n\n&#x2F;&#x2F; 提示：let b: IdLabel;\n\nlet c &#x3D; createLabel(Math.random() ? &quot;hello&quot; : 42);\n&#x2F;&#x2F; 提示：let c: NameLabel | IdLabel;\n\n\nConditional Type Constraints\n\n条件类型约束\nOften, the checks in a conditional type will provide us with some new information. Just like with narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.通常，在条件类型中的检查会提供我们一些新的信息。像类型检查一样，通过类型约束可以给我们更具体的类型，条件类型的 true 分支将通过我们检查的类型来约束泛型。For example, let’s take the following:例如，我们可以把下面的函数拿来说说：\ntype MessageOf&lt;T&gt; &#x3D; T[&quot;message&quot;];\n&#x2F;&#x2F; Type &#39;&quot;message&quot;&#39; cannot be used to index type &#39;T&#39;.\n\nIn this example, TypeScript errors because T isn’t known to have a property called message. We could constrain T, and TypeScript would no longer complain:\n在这个例子中，TypeScript 错误，因为 T 没有一个属性叫 message。我们可以约束 T，TypeScript 不会再报错了：\ntype MessageOf&lt;T extends &#123; message: unknown &#125;&gt; &#x3D; T[&quot;message&quot;];\n\ninterface Email &#123;\n  message: string;\n&#125;\n\ntype EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;\n\n&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string\n\nHowever, what if we wanted MessageOf to take any type, and default to something like never if a message property isn’t available? We can do this by moving the constraint out and introducing a conditional type:然而，如果我们想要 MessageOf 取任意类型，并且默认为没有 message 属性的情况，我们可以这样做：\ntype MessageOf&lt;T&gt; &#x3D; T extends &#123; message: unknown &#125; ? T[&quot;message&quot;] : never;\n\ninterface Email &#123;\n  message: string;\n&#125;\n\ninterface Dog &#123;\n  bark(): void;\n&#125;\n\ntype EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;\n\n&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string;\n\ntype DogMessageContents &#x3D; MessageOf&lt;Dog&gt;;\n\n&#x2F;&#x2F; 提示：type DogMessageContents &#x3D; never;\n\nWithin the true branch, TypeScript knows that T will have a message property.在 true 分支中，TypeScript 知道 T 有一个 message 属性。\nAs another example, we could also write a type called Flatten that flattens array types to their element types, but leaves them alone otherwise:作为另一个示例，我们还可以编写一个名为 Flatten 的类型，该类型将数组类型展平为其元素类型，但在其他情况下不使用它们：\ntype Flatten&lt;T&gt; &#x3D; T extends any[] ? T[number] : T;\n\n&#x2F;&#x2F; Extracts out the element type. 提取元素类型。\ntype Str &#x3D; Flatten&lt;string[]&gt;;\n\ntype Str &#x3D; string;\n\n&#x2F;&#x2F; Leaves the type alone. 保留该类型。\ntype Num &#x3D; Flatten&lt;number&gt;;\n\ntype Num &#x3D; number;\n\nWhen Flatten is given an array type, it uses an indexed access with number to fetch out string[]’s element type. Otherwise, it just returns the type it was given.当 Flatten 给定一个数组类型，它使用 number 下标得到 string[]元素类型，否则，仅返回所给类型\nInferring Within Conditional Types在条件类型内推断\nWe just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.\n我们只是发现自己使用条件类型来应用约束，然后提取出类型。这最终是一种常见的操作，条件类型使其更容易实现。\nConditional types provide us with a way to infer from types we compare against in the true branch using the infer keyword. For example, we could have inferred the element type in Flatten instead of fetching it out “manually” with an indexed access type:\n条件类型为我们提供了一种使用 infer 关键字从 true 分支中比较的类型推断的方法。例如，我们可以在 Flatten 中推断元素类型，而不是使用索引访问类型“手动”提取它：\ntype Flatten&lt;Type&gt; &#x3D; Type extends Array&lt;infer Item&gt; ? Item : Type;\n\nHere, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of T within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.\n在这里，我们使用 infer 关键字声明性地引入一个名为 Item 的新泛型类型变量，而不是指定如何在 true 分支中检索 T 的元素类型。这使我们不必思考如何挖掘和探索我们感兴趣的类型的结构。\nWe can write some useful helper type aliases using the infer keyword. For example, for simple cases, we can extract the return type out from function types:\n我们可以使用 infer 关键字编写一些有用的助手类型别名。例如，对于简单的情况，我们可以从函数类型中提取返回类型：\ntype GetReturnType&lt;Type&gt; &#x3D; Type extends (...args: never[]) &#x3D;&gt; infer Return\n  ? Return\n  : never;\n\ntype Num &#x3D; GetReturnType&lt;() &#x3D;&gt; number&gt;;\n\n&#x2F;&#x2F; 提示： type Num &#x3D; number\n\ntype Str &#x3D; GetReturnType&lt;(x: string) &#x3D;&gt; string&gt;;\n\n&#x2F;&#x2F; 提示：type Str &#x3D; string\n\ntype Bools &#x3D; GetReturnType&lt;(a: boolean, b: boolean) &#x3D;&gt; boolean[]&gt;;\n\n&#x2F;&#x2F; 提示： type Bools &#x3D; boolean[]\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，将从最后一个签名进行推断（这可能是最允许的一网打尽的情况）。无法基于参数类型列表执行重载解析。\ndeclare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n\ntype T1 &#x3D; ReturnType&lt;typeof stringOrNum&gt;;\n\n&#x2F;&#x2F; 提示：type T1 &#x3D; string | number;\n\nDistributive Conditional Types分布条件类型\nWhen conditional types act on a generic type, they become distributive when given a union type. For example, take the following:当条件类型作用于泛型类型时，当给定一个联合类型时，它们将成为分布式的。例如，以以下内容为例：\ntype ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;\n\nIf we plug a union type into ToArray, then the conditional type will be applied to each member of that union.如果我们将一个联合类型插入 ToArray，那么条件类型将应用于该联合的每个成员。\ntype ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;\n\ntype StrArrOrNumArr &#x3D; ToArray&lt;string | number&gt;;\n\n&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; string[] | number[];\n\nWhat happens here is that StrArrOrNumArr distributes on:这里发生了什么？\nstring | number;\n\nand maps over each member type of the union, to what is effectively:并映射到联合类型每个成员类型\nToArray&lt;string&gt; | ToArray&lt;number&gt;;\n\nwhich leaves us with:这给我们留下了：\nstring[] | number[];\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets.通常情况下，分布式是所需的行为。要避免这种行为，你可以在每边 extends 关键字之前使用方括号。\ntype ToArrayNonDist&lt;Type&gt; &#x3D; [Type] extends [any] ? Type[] : never;\n\n&#x2F;&#x2F; &#39;StrArrOrNumArr&#39; is no longer a union.\ntype StrArrOrNumArr &#x3D; ToArrayNonDist&lt;string | number&gt;;\n&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; (string | number)[];\n\nReturn模板字面量类型（Template Literal Types）模板字面量类型以字符串字面量类型为基础，可以通过联合类型扩展成多个字符串。\n它们跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。当使用模板字面量类型时，它会替换模板中的变量，返回一个新的字符串字面量：\ntype World &#x3D; &quot;world&quot;;\n\ntype Greeting &#x3D; &#96;hello $&#123;World&#125;&#96;;\n&#x2F;&#x2F; type Greeting &#x3D; &quot;hello world&quot;\n\n\n当模板中的变量是一个联合类型时，每一个可能的字符串字面量都会被表示：\n\ntype EmailLocaleIDs &#x3D; &quot;welcome_email&quot; | &quot;email_heading&quot;;\ntype FooterLocaleIDs &#x3D; &quot;footer_title&quot; | &quot;footer_sendoff&quot;;\n\ntype AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;\n&#x2F;&#x2F; type AllLocaleIDs &#x3D; &quot;welcome*email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;\n\n\n如果模板字面量里的多个变量都是联合类型，结果会交叉相乘，比如下面的例子就有 2 * 2 _ 3 一共 12 种结果：\n\ntype AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;\ntype Lang &#x3D; &quot;en&quot; | &quot;ja&quot; | &quot;pt&quot;;\n\ntype LocaleMessageIDs &#x3D; &#96;$&#123;Lang&#125;_$&#123;AllLocaleIDs&#125;&#96;;\n&#x2F;&#x2F; type LocaleMessageIDs &#x3D; &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot;\n\n\n如果真的是非常长的字符串联合类型，推荐提前生成，这种还是适用于短一些的情况。\n\n类型中的字符串联合类型（String Unions in Types）模板字面量最有用的地方在于你可以基于一个类型内部的信息，定义一个新的字符串，让我们举个例子：\n有这样一个函数 makeWatchedObject， 它会给传入的对象添加了一个 on 方法。在 JavaScript 中，它的调用看起来是这样：makeWatchedObject(baseObject)，我们假设这个传入对象为：\nconst passedObject &#x3D; &#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;;\n\n这个 on 方法会被添加到这个传入对象上，该方法接受两个参数，eventName （ string 类型） 和 callBack （function 类型）：\n&#x2F;&#x2F; 伪代码\nconst result &#x3D; makeWatchedObject(baseObject);\nresult.on(eventName, callBack);\n\n我们希望 eventName 是这种形式：attributeInThePassedObject + “Changed” ，举个例子，\n\npassedObject 有一个属性 firstName，对应产生的 eventName 为 firstNameChanged，\n同理，lastName 对应的是 lastNameChanged，\nage 对应的是 ageChanged。\n\n当这个 callBack 函数被调用的时候：\n\n应该被传入与 attributeInThePassedObject 相同类型的值。比如 passedObject 中，\nfirstName 的值的类型为 string , 对应 firstNameChanged 事件的回调函数，则接受传入一个 string 类型的值。\nage 的值的类型为 number，对应 ageChanged 事件的回调函数，则接受传入一个 number 类型的值。\n\n\n返回值类型为 void 类型。on() 方法的签名最一开始是这样的：on(eventName: string, callBack: (newValue: any) &#x3D;&gt; void)。 使用这样的签名，我们是不能实现上面所说的这些约束的，这个时候就可以使用模板字面量：\n\nconst person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\n&#x2F;&#x2F; makeWatchedObject has added &#96;on&#96; to the anonymous Object\nperson.on(&quot;firstNameChanged&quot;, (newValue) &#x3D;&gt; &#123;\n  console.log(&#96;firstName was changed to $&#123;newValue&#125;!&#96;);\n&#125;);\n\n注意这个例子里，on 方法添加的事件名为 “firstNameChanged”， 而不仅仅是 “firstName”，而回调函数传入的值 newValue ，我们希望约束为 string 类型。我们先实现第一点。\n在这个例子里，我们希望传入的事件名的类型，是对象属性名的联合，只是每个联合成员都还在最后拼接一个 Changed 字符，在 JavaScript 中，我们可以做这样一个计算：\nObject.keys(passedObject).map(x &#x3D;&gt; $&#123;x&#125;Changed)\n\n模板字面量提供了一个相似的字符串操作：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;string &amp; keyof Type&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n&#x2F;&#x2F;&#x2F; Create a &quot;watched object&quot; with an &#39;on&#39; method\n&#x2F;&#x2F;&#x2F; so that you can watch for changes to properties.\n\ndeclare function makeWatchedObject&lt;Type&gt;(\n  obj: Type\n): Type &amp; PropEventSource&lt;Type&gt;;\n\n注意，我们在这里例子中，模板字面量里我们写的是 string &amp; keyof Type，我们可不可以只写成 keyof Type 呢？如果我们这样写，会报错：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;keyof Type&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n&#x2F;&#x2F; Type &#39;keyof Type&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.\n&#x2F;&#x2F; Type &#39;string | number | symbol&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.\n&#x2F;&#x2F; ...\n\n从报错信息中，我们也可以看出报错原因，在 《TypeScript 系列之 Keyof 操作符》里，我们知道\n\nkeyof 操作符会返回 string | number | symbol 类型，\n但是模板字面量的变量要求的类型却是 string | number | bigint | boolean | null | undefined，\n\n比较一下，多了一个 symbol 类型，所以其实我们也可以这样写：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;Exclude&lt;keyof Type, symbol&gt;&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n再或者这样写：\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on(\n    eventName: &#96;$&#123;Extract&lt;keyof Type, string&gt;&#125;Changed&#96;,\n    callback: (newValue: any) &#x3D;&gt; void\n  ): void;\n&#125;;\n\n使用这种方式，在我们使用错误的事件名时，TypeScript 会给出报错：\nconst person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\nperson.on(&quot;firstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);\n\n&#x2F;&#x2F; Prevent easy human error (using the key instead of the event name)\nperson.on(&quot;firstName&quot;, () &#x3D;&gt; &#123;&#125;);\n&#x2F;&#x2F; Argument of type &#39;&quot;firstName&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.\n\n&#x2F;&#x2F; It&#39;s typo-resistant\nperson.on(&quot;frstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);\n&#x2F;&#x2F; Argument of type &#39;&quot;frstNameChanged&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.\n\n模板字面量的推断（Inference with Template Literals）现在我们来实现第二点，回调函数传入的值的类型与对应的属性值的类型相同。我们现在只是简单的对 callBack 的参数使用 any 类型。实现这个约束的关键在于借助泛型函数：\n捕获泛型函数第一个参数的字面量，生成一个字面量类型\n\n该字面量类型可以被对象属性构成的联合约束\n对象属性的类型可以通过索引访问获取\n应用此类型，确保回调函数的参数类型与对象属性的类型是同一个类型\n\ntype PropEventSource&lt;Type&gt; &#x3D; &#123;\n  on&lt;Key extends string &amp; keyof Type&gt;(\n    eventName: &#96;$&#123;Key&#125;Changed&#96;,\n    callback: (newValue: Type[Key]) &#x3D;&gt; void\n  ): void;\n&#125;;\n\ndeclare function makeWatchedObject&lt;Type&gt;(\n  obj: Type\n): Type &amp; PropEventSource&lt;Type&gt;;\n\nconst person &#x3D; makeWatchedObject(&#123;\n  firstName: &quot;Saoirse&quot;,\n  lastName: &quot;Ronan&quot;,\n  age: 26,\n&#125;);\n\nperson.on(&quot;firstNameChanged&quot;, (newName) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; (parameter) newName: string\n  console.log(&#96;new name is $&#123;newName.toUpperCase()&#125;&#96;);\n&#125;);\n\nperson.on(&quot;ageChanged&quot;, (newAge) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; (parameter) newAge: number\n  if (newAge &lt; 0) &#123;\n    console.warn(&quot;warning! negative age&quot;);\n  &#125;\n&#125;);\n\n这里我们把 on 改成了一个泛型函数。\n当一个用户调用的时候传入 “firstNameChanged”，TypeScript 会尝试着推断 Key 正确的类型。它会匹配 key 和 “Changed” 前的字符串 ，然后推断出字符串 “firstName” ，然后再获取原始对象的 firstName 属性的类型，在这个例子中，就是 string 类型。\n内置字符操作类型（Intrinsic String Manipulation Types）TypeScript 的一些类型可以用于字符操作，这些类型处于性能的考虑被内置在编译器中，你不能在 .d.ts 文件里找到它们。\nUppercase把每个字符转为大写形式：\ntype Greeting &#x3D; &quot;Hello, world&quot;;\ntype ShoutyGreeting &#x3D; Uppercase&lt;Greeting&gt;;\n&#x2F;&#x2F; type ShoutyGreeting &#x3D; &quot;HELLO, WORLD&quot;\n\ntype ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;ID-$&#123;Uppercase&lt;Str&gt;&#125;&#96;;\ntype MainID &#x3D; ASCIICacheKey&lt;&quot;my_app&quot;&gt;;\n&#x2F;&#x2F; type MainID &#x3D; &quot;ID-MY_APP&quot;\n\nLowercase把每个字符转为小写形式：\ntype Greeting &#x3D; &quot;Hello, world&quot;;\ntype QuietGreeting &#x3D; Lowercase&lt;Greeting&gt;;\n&#x2F;&#x2F; type QuietGreeting &#x3D; &quot;hello, world&quot;\n\ntype ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;id-$&#123;Lowercase&lt;Str&gt;&#125;&#96;;\ntype MainID &#x3D; ASCIICacheKey&lt;&quot;MY_APP&quot;&gt;;\n&#x2F;&#x2F; type MainID &#x3D; &quot;id-my_app&quot;\n\nCapitalize\n把字符串的第一个字符转为大写形式：\n\ntype LowercaseGreeting &#x3D; &quot;hello, world&quot;;\ntype Greeting &#x3D; Capitalize&lt;LowercaseGreeting&gt;;\n&#x2F;&#x2F; type Greeting &#x3D; &quot;Hello, world&quot;\n\nUncapitalize\n把字符串的第一个字符转换为小写形式：\n\ntype UppercaseGreeting &#x3D; &quot;HELLO WORLD&quot;;\ntype UncomfortableGreeting &#x3D; Uncapitalize&lt;UppercaseGreeting&gt;;\n&#x2F;&#x2F; type UncomfortableGreeting &#x3D; &quot;hELLO WORLD&quot;\n\n\n字符操作类型的技术细节从 TypeScript 4.1 起，这些内置函数会直接使用 JavaScript 字符串运行时函数，而不是本地化识别 (locale aware)。\n\nfunction applyStringMapping(symbol: Symbol, str: string) &#123;\n  switch (intrinsicTypeKinds.get(symbol.escapedName as string)) &#123;\n    case IntrinsicTypeKind.Uppercase:\n      return str.toUpperCase();\n    case IntrinsicTypeKind.Lowercase:\n      return str.toLowerCase();\n    case IntrinsicTypeKind.Capitalize:\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    case IntrinsicTypeKind.Uncapitalize:\n      return str.charAt(0).toLowerCase() + str.slice(1);\n  &#125;\n  return str;\n&#125;\n\n作者：冴羽链接：https://www.imooc.com/article/322215来源：慕课网本文原创发布于慕课网 ，转载请注明出处，谢谢合作\n在想一个问题为什么别人可以把文档翻译的那么准确，让读者一看就明白\n","slug":"2022-06-07ts-type-manipulation","date":"2022-06-08T03:20:35.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"f1faf548c4c61142a49eddcdf4aec1f6","title":"6.Typescript手册 对象类型","content":"In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types.在 JavaScript 中，我们通过对象来组织和传递数据。在 TypeScript 中，我们通过对象类型来表示这些对象。As we’ve seen, they can be anonymous:我们可以看到，它们可以是匿名的：\nfunction greet(person: &#123; name: string; age: number &#125;) &#123;\n  return &quot;Hello &quot; + person.name;\n&#125;\n\nor they can be named by using either an interface或者，它们可以使用接口来命名\ninterface Person &#123;\n  name: string;\n  age: number;\n&#125;\n\nfunction greet(person: Person) &#123;\n  return &quot;Hello &quot; + person.name;\n&#125;\n\nor a type alias.或者，它们可以使用类型别名\ntype Person &#x3D; &#123;\n  name: string;\n  age: number;\n&#125;;\n\nfunction greet(person: Person) &#123;\n  return &quot;Hello &quot; + person.name;\n&#125;\n\nIn all three examples above, we’ve written functions that take objects that contain the property name (which must be a string) and age (which must be a number).在上面三个例子中，我们已经写了一个函数，它接受包含属性 name（必须是字符串）和 age（必须是数字）的对象。\nProperty Modifiers属性修饰符Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.对象类型中的每个属性都可以指定一些东西：类型、是否是可选的，以及是否可以写入。\nOptional Properties可选属性Much of the time, we’ll find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark (?) to the end of their names.大多数时候，我们会发现我们在对对象进行操作的时候，可能会有属性被设置。在这些情况下，我们可以通过在属性名的末尾添加问号来标记这些属性为可选的。\ninterface PaintOptions &#123;\n  shape: Shape;\n  xPos?: number;\n  yPos?: number;\n&#125;\n\nfunction paintShape(opts: PaintOptions) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nconst shape &#x3D; getShape();\npaintShape(&#123; shape &#125;);\npaintShape(&#123; shape, xPos: 100 &#125;);\npaintShape(&#123; shape, yPos: 100 &#125;);\npaintShape(&#123; shape, xPos: 100, yPos: 100 &#125;);\n\nIn this example, both xPos and yPos are considered optional. We can choose to provide either of them, so every call above to paintShape is valid. All optionality really says is that if the property is set, it better have a specific type.在这个例子中，xPos和yPos都被认为是可选的。我们可以选择提供其中一个，因此每次调用paintShape都是有效的。所有的可选性都说是，如果属性被设置，它应该有一个特定的类型。We can also read from those properties - but when we do under strictNullChecks, TypeScript will tell us they’re potentially undefined.我们也可以读取这些属性，但是在严格的 null 检查下，TypeScript 将会告诉我们这些属性可能是 undefined。\nfunction paintShape(opts: PaintOptions) &#123;\n  let xPos &#x3D; opts.xPos;\n  &#x2F;&#x2F; (property) PaintOptions.xPos?: number | undefined\n\n  let yPos &#x3D; opts.yPos;\n  &#x2F;&#x2F; (property) PaintOptions.yPos?: number | undefined\n  &#x2F;&#x2F; ...\n&#125;\n\nIn JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value undefined. We can just handle undefined specially.在 JavaScript 中，即使属性没有被设置，我们仍然可以访问它，它只是给我们一个值 undefined。我们可以特别处理 undefined。\nfunction paintShape(opts: PaintOptions) &#123;\n  let xPos &#x3D; opts.xPos &#x3D;&#x3D;&#x3D; undefined ? 0 : opts.xPos;\n  &#x2F;&#x2F; let xPos: number;\n\n  let yPos &#x3D; opts.yPos &#x3D;&#x3D;&#x3D; undefined ? 0 : opts.yPos;\n  &#x2F;&#x2F; let yPos: number;\n  &#x2F;&#x2F; ...\n&#125;\n\nNote that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.注意，这种设置默认值的方式很常见，因此 JavaScript 有一种语法来支持它。\nfunction paintShape(&#123; shape, xPos &#x3D; 0, yPos &#x3D; 0 &#125;: PaintOptions) &#123;\n  console.log(&quot;x coordinate at&quot;, xPos);\n  &#x2F;&#x2F; (parameter) xPos: number\n\n  console.log(&quot;y coordinate at&quot;, yPos);\n  &#x2F;&#x2F; (parameter) yPos: number\n  &#x2F;&#x2F; ...\n&#125;\n\nHere we used a destructuring pattern for paintShape’s parameter, and provided default values for xPos and yPos. Now xPos and yPos are both definitely present within the body of paintShape, but optional for any callers to paintShape.在这里，我们使用了 paintShape 的参数的析构模式，并为 xPos 和 yPos 提供了默认值。现在 xPos 和 yPos 在 paintShape 的主体中都是必须的，但是任何调用者调用 paintShape 的值都是可选的。Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.注意，目前没有办法在析构模式中放置类型标注。因为这个语法已经在 JavaScript 中表示了不同的意思。\nfunction draw(&#123; shape: Shape, xPos: number &#x3D; 100 &#x2F;_..._&#x2F; &#125;) &#123;\nrender(shape);\n&#x2F;&#x2F; Cannot find name &#39;shape&#39;. Did you mean &#39;Shape&#39;?\nrender(xPos);\n&#x2F;&#x2F; Cannot find name &#39;xPos&#39;.\n&#125;\n\nIn an object destructuring pattern, shape: Shape means “grab the property shape and redefine it locally as a variable named Shape. Likewise xPos: number creates a variable named number whose value is based on the parameter’s xPos.在一个对象析构模式中，shape: Shape 表示“抓取属性 shape 并重新定义它作为名为 Shape 的变量。同样的，xPos: number 创建了一个名为 number 的变量，其值是基于参数的 xPos。Using mapping modifiers, you can remove optional attributes.使用映射修饰符，你可以移除可选属性。\nReadonly Properties只读属性Properties can also be marked as readonly for TypeScript. While it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking.只读属性\ninterface SomeType &#123;\n  readonly prop: string;\n&#125;\n\nfunction doSomething(obj: SomeType) &#123;\n  &#x2F;&#x2F; We can read from &#39;obj.prop&#39;.\n  console.log(&#96;prop has the value &#39;$&#123;obj.prop&#125;&#39;.&#96;);\n\n  &#x2F;&#x2F; But we can&#39;t re-assign it.\n  obj.prop &#x3D; &quot;hello&quot;;\n  &#x2F;&#x2F; Cannot assign to &#39;prop&#39; because it is a read-only property.\n&#125;\n\nUsing the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.使用 readonly 修饰符并不意味着一个值是完全不可变的，也就是说，它的内部内容不能被改变。它只是说，属性本身不能被重写。\ninterface Home &#123;\n  readonly resident: &#123; name: string; age: number &#125;;\n&#125;\n\nfunction visitForBirthday(home: Home) &#123;\n  &#x2F;&#x2F; We can read and update properties from &#39;home.resident&#39;.\n  &#x2F;&#x2F; 我们可以从 &#39;home.resident&#39; 中读取和更新属性。\n  console.log(&#96;Happy birthday $&#123;home.resident.name&#125;!&#96;);\n  home.resident.age++;\n&#125;\n\nfunction evict(home: Home) &#123;\n  &#x2F;&#x2F; But we can&#39;t write to the &#39;resident&#39; property itself on a &#39;Home&#39;.\n  &#x2F;&#x2F; 但是，我们不能在 &#39;Home&#39; 上写入 &#39;resident&#39; 属性。\n  home.resident &#x3D; &#123;\n    &#x2F;&#x2F; Cannot assign to &#39;resident&#39; because it is a read-only property.\n    name: &quot;Victor the Evictor&quot;,\n    age: 42,\n  &#125;;\n&#125;\n\nIt’s important to manage expectations of what readonly implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing.\n注意\nTypeScript 在检查两个类型是否兼容的时候，并不会考虑两个类型里的属性是否是 readonly，这就意味着，readonly 的值是可以通过别名修改的。\ninterface Person &#123;\n  name: string;\n  age: number;\n&#125;\n\ninterface ReadonlyPerson &#123;\n  readonly name: string;\n  readonly age: number;\n&#125;\n\nlet writablePerson: Person &#x3D; &#123;\n  name: &quot;Person McPersonface&quot;,\n  age: 42,\n&#125;;\n\n&#x2F;&#x2F; works\nlet readonlyPerson: ReadonlyPerson &#x3D; writablePerson;\n\nconsole.log(readonlyPerson.age); &#x2F;&#x2F; prints &#39;42&#39;\nwritablePerson.age++;\nconsole.log(readonlyPerson.age); &#x2F;&#x2F; prints &#39;43&#39;\n\nUsing mapping modifiers, you can remove readonly attributes.\nIndex Signatures索引签名Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.有时候，你不知道一个类型的所有属性的名字，但是你知道值的形状。\nIn those cases you can use an index signature to describe the types of possible values, for example:在这些情况下，你可以使用索引签名来描述可能的值的类型，例如：\ninterface StringArray &#123;\n  [index: number]: string;\n&#125;\n\nconst myArray: StringArray &#x3D; getStringArray();\nconst secondItem &#x3D; myArray[1];\n\nconst secondItem: string;\n\nAbove, we have a StringArray interface which has an index signature. This index signature states that when a StringArray is indexed with a number, it will return a string.上面，我们有一个 StringArray 接口，它有一个索引签名。这个索引签名说明，当一个 StringArray 被索引为一个数字时，它会返回一个字符串。An index signature property type must be either ‘string’ or ‘number’.索引签名属性类型必须是‘string’或‘number’。It is possible to support both types of indexers…可以支持两种类型的索引器...\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj[“property”]. In the following example, name’s type does not match the string index’s type, and the type checker gives an error:尽管字符串索引用来描述字典模式（dictionary pattern）非常的有效，但也会强制要求所有的属性要匹配索引签名的返回类型。这是因为一个声明类似于 obj.property 的字符串索引，跟 obj[&quot;property&quot;]是一样的。在下面的例子中，name 的类型并不匹配字符串索引的类型，所以类型检查器会给出报错：\ninterface NumberDictionary &#123;\n  [index: string]: number;\n\n  length: number; &#x2F;&#x2F; ok\n  name: string;\n  &#x2F;&#x2F; Property &#39;name&#39; of type &#39;string&#39; is not assignable to &#39;string&#39; index type &#39;number&#39;.\n&#125;\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:但是，不同类型的属性是可以接受的，如果索引签名是属性类型的联合：\ninterface NumberOrStringDictionary &#123;\n  [index: string]: number | string;\n  length: number; &#x2F;&#x2F; ok, length is a number\n  name: string; &#x2F;&#x2F; ok, name is a string\n&#125;\n\nFinally, you can make index signatures readonly in order to prevent assignment to their indices:最后，你可以使索引签名变成只读，以防止索引赋值：\ninterface ReadonlyStringArray &#123;\n  readonly [index: number]: string;\n&#125;\n\nlet myArray: ReadonlyStringArray &#x3D; getReadOnlyStringArray();\nmyArray[2] &#x3D; &quot;Mallory&quot;;\n&#x2F;&#x2F; Index signature in type &#39;ReadonlyStringArray&#39; only permits reading.\n\nYou can’t set myArray[2] because the index signature is readonly.你不能设置 myArray[2]，因为索引签名是只读的。\nExtending Types扩展类型It’s pretty common to have types that might be more specific versions of other types. For example, we might have a BasicAddress type that describes the fields necessary for sending letters and packages in the U.S.我们可能有一个基本的地址类型，它描述了在美国发送信件和包裹的必要字段。\ninterface BasicAddress &#123;\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n&#125;\n\nIn some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an AddressWithUnit.在某些情况下，这样就足够了，但是地址有时候会有单元号码，如果地址的建筑有多个单元。我们可以描述一个 AddressWithUnit。\ninterface AddressWithUnit &#123;\n  name?: string;\n  unit: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n&#125;\n\nThis does the job, but the downside here is that we had to repeat all the other fields from BasicAddress when our changes were purely additive. Instead, we can extend the original BasicAddress type and just add the new fields that are unique to AddressWithUnit.这样做就可以了，但是有一个缺点，就是我们必须重复所有的字段来自 BasicAddress，当我们的改动只是增加性的时候。我们可以扩展原来的 BasicAddress 类型，并且只需要增加 AddressWithUnit 的唯一字段。\ninterface BasicAddress &#123;\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n&#125;\n\ninterface AddressWithUnit extends BasicAddress &#123;\n  unit: string;\n&#125;\n\nThe extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, AddressWithUnit didn’t need to repeat the street property, and because street originates from BasicAddress, a reader will know that those two types are related in some way.在一个接口上使用 extends 关键字，我们可以从其他命名类型复制成员，并且添加我们想要的新成员。这可以用来缩短我们写的类型声明的热身，以及为同一属性的多个声明提供相关性的信号。例如，AddressWithUnit 不需要重复 street 属性，因为 street 来自 BasicAddress，读者知道这两个类型是相关的。interfaces can also extend from multiple types.接口也可以扩展多个类型。\ninterface Colorful &#123;\n  color: string;\n&#125;\n\ninterface Circle &#123;\n  radius: number;\n&#125;\n\ninterface ColorfulCircle extends Colorful, Circle &#123;&#125;\n\nconst cc: ColorfulCircle &#x3D; &#123;\n  color: &quot;red&quot;,\n  radius: 42,\n&#125;;\n\nIntersection Types交叉类型interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.接口允许我们从其他类型扩展新类型。TypeScript 提供了一种合并现有对象类型的交叉类型。An intersection type is defined using the &amp; operator.交叉类型用 &amp; 运算符定义。\ninterface Colorful &#123;\n  color: string;\n&#125;\ninterface Circle &#123;\n  radius: number;\n&#125;\n\ntype ColorfulCircle &#x3D; Colorful &amp; Circle;\n\nHere, we’ve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle.这里，我们将 Colorful 和 Circle 进行交叉，以生成一个新类型，它包含了 Colorful 和 Circle 的所有成员。\nfunction draw(circle: Colorful &amp; Circle) &#123;\n  console.log(&#96;Color was $&#123;circle.color&#125;&#96;);\n  console.log(&#96;Radius was $&#123;circle.radius&#125;&#96;);\n&#125;\n\n&#x2F;&#x2F; okay\ndraw(&#123; color: &quot;blue&quot;, radius: 42 &#125;);\n\n&#x2F;&#x2F; oops\ndraw(&#123; color: &quot;red&quot;, raidus: 42 &#125;);\n&#x2F;&#x2F; Argument of type &#39;&#123; color: string; raidus: number; &#125;&#39; is not assignable to parameter of type &#39;Colorful &amp; Circle&#39;.\n&#x2F;&#x2F; Object literal may only specify known properties, but &#39;raidus&#39; does not exist in type &#39;Colorful &amp; Circle&#39;. Did you mean to write &#39;radius&#39;?\n\nInterfaces vs. Intersections接口与交叉类型We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principle difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.我们只看到了两种方式来合并类型，但是实际上是有着微妙的区别。接口使用 extends 关键字扩展其他类型，而交叉类型使用类型别名定义。接口与交叉类型之间的主要区别是如何处理冲突，这个区别通常是在选择一个接口或者类型别名的时候，接口或者类型别名是否更好。\n这两种方式在合并类型上看起来很相似，但实际上还是有很大的不同。最原则性的不同就是在于冲突怎么处理，这也是你决定选择那种方式的主要原因。\ninterface Colorful &#123;\n  color: string;\n&#125;\n\ninterface ColorfulSub extends Colorful &#123;\n  color: number;\n&#125;\n&#x2F;&#x2F; Interface &#39;ColorfulSub&#39; incorrectly extends interface &#39;Colorful&#39;.\n&#x2F;&#x2F; Types of property &#39;color&#39; are incompatible.\n&#x2F;&#x2F; Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\n使用继承的方式，如果重写类型会导致编译错误，但交叉类型不会：\ninterface Colorful &#123;\n  color: string;\n&#125;\n\ntype ColorfulSub &#x3D; Colorful &amp; &#123;\n  color: number;\n&#125;;\n\n虽然不会报错，那 color 属性的类型是什么呢，答案是 never，取得是 string 和 number 的交集。\nGeneric Object Types泛型对象类型Let’s imagine a Box type that can contain any value - strings, numbers, Giraffes, whatever.想想一个可以包含任何值的盒子类型，例如字符串、数字、狮子等。\ninterface Box &#123;\n  contents: any;\n&#125;\n\nRight now, the contents property is typed as any, which works, but can lead to accidents down the line.现在，contents 属性是任意类型，这就可以工作，但是有可能会在未来出现意外。We could instead use unknown, but that would mean that in cases where we already know the type of contents, we’d need to do precautionary checks, or use error-prone type assertions.我们可以使用 unknown，但是这会导致在我们已经知道 contents 的类型的情况下，我们需要做一些预防性检查，或者使用错误性的类型断言。\ninterface Box &#123;\n  contents: unknown;\n&#125;\n\nlet x: Box &#x3D; &#123;\n  contents: &quot;hello world&quot;,\n&#125;;\n\n&#x2F;&#x2F; we could check &#39;x.contents&#39;\nif (typeof x.contents &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n  console.log(x.contents.toLowerCase());\n&#125;\n\n&#x2F;&#x2F; or we could use a type assertion\nconsole.log((x.contents as string).toLowerCase());\n\nOne type safe approach would be to instead scaffold out different Box types for every type of contents.一种安全的解决方案就是把不同的盒子类型用于不同的类型的内容。\ninterface NumberBox &#123;\n  contents: number;\n&#125;\n\ninterface StringBox &#123;\n  contents: string;\n&#125;\n\ninterface BooleanBox &#123;\n  contents: boolean;\n&#125;\n\nBut that means we’ll have to create different functions, or overloads of functions, to operate on these types.但是，这会导致我们需要创建不同的函数，或者重载函数，来操作这些类型。\nfunction setContents(box: StringBox, newContents: string): void;\nfunction setContents(box: NumberBox, newContents: number): void;\nfunction setContents(box: BooleanBox, newContents: boolean): void;\nfunction setContents(box: &#123; contents: any &#125;, newContents: any) &#123;\n  box.contents &#x3D; newContents;\n&#125;\n\nThat’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.这就是一大堆的烧饼，同时，我们可能需要在未来添加新的类型和重载。这是困难的，因为我们的盒子类型和重载都是一样的。Instead, we can make a generic Box type which declares a type parameter.而不是，我们可以把盒子类型变成泛型类型，它声明了一个类型参数。\ninterface Box&lt;Type&gt; &#123;\n  contents: Type;\n&#125;\n\nYou might read this as “A Box of Type is something whose contents have type Type”. Later on, when we refer to Box, we have to give a type argument in place of Type.你可以读这个为“一个类型为 Type 的盒子”。之后，当我们引用 Box 时，我们需要给它一个类型参数。\nlet box: Box&lt;string&gt;;\n\nThink of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type. When TypeScript sees Box, it will replace every instance of Type in Box with string, and end up working with something like { contents: string }. In other words, Box and our earlier StringBox work identically.想想 Box&lt;string&gt; 和 StringBox 类型，它们都是一样的。\ninterface Box&lt;Type&gt; &#123;\ncontents: Type;\n&#125;\ninterface StringBox &#123;\ncontents: string;\n&#125;\n\nlet boxA: Box&lt;string&gt; &#x3D; &#123; contents: &quot;hello&quot; &#125;;\nboxA.contents;\n\n(property) Box&lt;string&gt;.contents: string\n\nlet boxB: StringBox &#x3D; &#123; contents: &quot;world&quot; &#125;;\nboxB.contents;\n\n(property) StringBox.contents: string\n\nBox is reusable in that Type can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new Box type at all (though we certainly could if we wanted to).Box 可以重用，因为 Type 可以被替换成任何类型。\ninterface Box&lt;Type&gt; &#123;\n  contents: Type;\n&#125;\n\ninterface Apple &#123;\n  &#x2F;&#x2F; ....\n&#125;\n\n&#x2F;&#x2F; Same as &#39;&#123; contents: Apple &#125;&#39;.\ntype AppleBox &#x3D; Box&lt;Apple&gt;;\n\nThis also means that we can avoid overloads entirely by instead using generic functions.\nfunction setContents&lt;Type&gt;(box: Box&lt;Type&gt;, newContents: Type) &#123;\n  box.contents &#x3D; newContents;\n&#125;\n\nIt is worth noting that type aliases can also be generic. We could have defined our new Box interface, which was:我们可以定义一个新的盒子类型，它是：\ninterface Box&lt;Type&gt; &#123;\n  contents: Type;\n&#125;\n\nby using a type alias instead:使用类型别名来代替：\ntype Box&lt;Type&gt; &#x3D; &#123;\n  contents: Type;\n&#125;;\n\nSince type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.类型别名，跟接口不同，它可以描述除了对象类型之外的其他类型，我们也可以用它来写其他类型的辅助类型。\ntype OrNull&lt;Type&gt; &#x3D; Type | null;\n\ntype OneOrMany&lt;Type&gt; &#x3D; Type | Type[];\n\n&#x2F;&#x2F; 这组结果一样\ntype OneOrManyOrNull&lt;Type&gt; &#x3D; OrNull&lt;OneOrMany&lt;Type&gt;&gt;;\ntype OneOrManyOrNull&lt;Type&gt; &#x3D; OneOrMany&lt;Type&gt; | null;\n\n&#x2F;&#x2F; 这组结果一样\ntype OneOrManyOrNullStrings &#x3D; OneOrManyOrNull&lt;string&gt;;\ntype OneOrManyOrNullStrings &#x3D; OneOrMany&lt;string&gt; | null;\n\nWe’ll circle back to type aliases in just a little bit.我们会在稍后回到类型别名。\nThe Array Type数组类型Generic object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.泛型对象类型通常是一种可以独立于其包含元素的类型的容器类型。这样，它们可以在不同的数据类型之间重用。It turns out we’ve been working with a type just like that throughout this handbook: the Array type. Whenever we write out types like number[] or string[], that’s really just a shorthand for Array and Array.我们在这本手册中已经使用过一样的类型：数组类型。\nfunction doSomething(value: Array&lt;string&gt;) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nlet myArray: string[] &#x3D; [&quot;hello&quot;, &quot;world&quot;];\n\n&#x2F;&#x2F; either of these work!\ndoSomething(myArray);\ndoSomething(new Array(&quot;hello&quot;, &quot;world&quot;));\n\nMuch like the Box type above, Array itself is a generic type.数组本身是一个泛型类型。\ninterface Array&lt;Type&gt; &#123;\n  &#x2F;**\n   * Gets or sets the length of the array.\n   *&#x2F;\n  length: number;\n\n  &#x2F;**\n   * Removes the last element from an array and returns it.\n   *&#x2F;\n  pop(): Type | undefined;\n\n  &#x2F;**\n   * Appends new elements to an array, and returns the new length of the array.\n   *&#x2F;\n  push(...items: Type[]): number;\n\n  &#x2F;&#x2F; ...\n&#125;\n\nModern JavaScript also provides other data structures which are generic, like Map&lt;K, V&gt;, Set, and Promise. All this really means is that because of how Map, Set, and Promise behave, they can work with any sets of types.现代 JavaScript 也提供了其他的数据结构，比如 Map&lt;K, V&gt;, Set&lt;T&gt;, Promise&lt;T&gt;。\nThe ReadonlyArray Type只读数组类型\nThe ReadonlyArray is a special type that describes arrays that shouldn’t be changed.只读数组是一个描述不能被修改的数组的特殊类型。\nfunction doStuff(values: ReadonlyArray&lt;string&gt;) &#123;\n  &#x2F;&#x2F; We can read from &#39;values&#39;...\n  const copy &#x3D; values.slice();\n  console.log(&#96;The first value is $&#123;values[0]&#125;&#96;);\n\n  &#x2F;&#x2F; ...but we can&#39;t mutate &#39;values&#39;.\n  values.push(&quot;hello!&quot;);\n  &#x2F;&#x2F; Property &#39;push&#39; does not exist on type &#39;readonly string[]&#39;.\n&#125;\n\nMuch like the readonly modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us we’re not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents.ReadonlyArray 主要是用来做意图声明。当我们看到一个函数返回 ReadonlyArray，就是在告诉我们不能去更改其中的内容，当我们看到一个函数支持传入 ReadonlyArray ，这是在告诉我们我们可以放心的传入数组到函数中，而不用担心会改变数组的内容。Unlike Array, there isn’t a ReadonlyArray constructor that we can use.不像 Array，ReadonlyArray 并不是一个我们可以用的构造器函数。\nnew ReadonlyArray(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);\n&#39;ReadonlyArray&#39; only refers to a type, but is being used as a value here.\n\nInstead, we can assign regular Arrays to ReadonlyArrays.然而，我们可以直接把一个常规数组赋值给 ReadonlyArray。\nconst roArray: ReadonlyArray&lt;string&gt; &#x3D; [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n\nJust as TypeScript provides a shorthand syntax for Array with Type[], it also provides a shorthand syntax for ReadonlyArray with readonly Type[].TypeScript 也针对 ReadonlyArray&lt;Type&gt; 提供了更简短的写法 readonly Type[]。\nfunction doStuff(values: readonly string[]) &#123;\n  &#x2F;&#x2F; We can read from &#39;values&#39;...\n  const copy &#x3D; values.slice();\n  console.log(&#96;The first value is $&#123;values[0]&#125;&#96;);\n\n  &#x2F;&#x2F; ...but we can&#39;t mutate &#39;values&#39;.\n  values.push(&quot;hello!&quot;);\n  &#x2F;&#x2F; Property &#39;push&#39; does not exist on type &#39;readonly string[]&#39;.\n&#125;\n\nOne last thing to note is that unlike the readonly property modifier, assignability isn’t bidirectional between regular Arrays and ReadonlyArrays.最后有一点要注意，就是 Arrays 和 ReadonlyArray 并不能双向的赋值：\nlet x: readonly string[] &#x3D; [];\nlet y: string[] &#x3D; [];\n\nx &#x3D; y; &#x2F;&#x2F; ok\ny &#x3D; x;\n&#x2F;&#x2F; The type &#39;readonly string[]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;string[]&#39;.\n\nTuple TypesA tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.元组类型是另外一种 Array 类型，当你明确知道数组包含多少个元素，并且每个位置元素的类型都明确知道的时候，就适合使用元组类型。\ntype StringNumberPair &#x3D; [string, number];\n\nHere, StringNumberPair is a tuple type of string and number. Like ReadonlyArray, it has no representation at runtime, but is significant to TypeScript. To the type system, StringNumberPair describes arrays whose 0 index contains a string and whose 1 index contains a number.在这个例子中，StringNumberPair 就是 string 和 number 的元组类型。\n跟 ReadonlyArray 一样，它并不会在运行时产生影响，但是对 TypeScript 很有意义。因为对于类型系统，StringNumberPair 描述了一个数组，索引 0 的值的类型是 string，索引 1 的值的类型是 number。\nfunction doSomething(pair: [string, number]) &#123;\n  const a &#x3D; pair[0];\n\n  const a: string;\n  const b &#x3D; pair[1];\n\n  const b: number;\n  &#x2F;&#x2F; ...\n&#125;\n\ndoSomething([&quot;hello&quot;, 42]);\n\nIf we try to index past the number of elements, we’ll get an error.如果要获取元素数量之外的元素，TypeScript 会提示错误：\nfunction doSomething(pair: [string, number]) &#123;\n  &#x2F;&#x2F; ...\n\n  const c &#x3D; pair[2];\n  &#x2F;&#x2F; Tuple type &#39;[string, number]&#39; of length &#39;2&#39; has no element at index &#39;2&#39;.\n&#125;\n\nWe can also destructure tuples using JavaScript’s array destructuring.我们也可以使用 JavaScript 的数组解构语法解构元组：\nfunction doSomething(stringHash: [string, number]) &#123;\n  const [inputString, hash] &#x3D; stringHash;\n\n  console.log(inputString);\n\n  &#x2F;&#x2F; const inputString: string;\n\n  console.log(hash);\n\n  &#x2F;&#x2F; const hash: number;\n&#125;\n\n\n\n\n\n\n\n\n\n\nTuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements 0 and 1 to whatever we wanted.元组类型在重度依赖约定的 API 中很有用，因为它会让每个元素的意义都很明显。当我们解构的时候，元组给了我们命名变量的自由度。在上面的例子中，我们可以命名元素 0 和 1 为我们想要的名字。However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.然而，也不是每个用户都这样认为，所以有的时候，使用一个带有描述属性名字的对象也许是个更好的方式。Other than those length checks, simple tuple types like these are equivalent to types which are versions of Arrays that declare properties for specific indexes, and that declare length with a numeric literal type.除了长度检查，简单的元组类型跟声明了 length 属性和具体的索引属性的 Array 是一样的。\ninterface StringNumberPair &#123;\n  &#x2F;&#x2F; specialized properties\n  length: 2;\n  0: string;\n  1: number;\n\n  &#x2F;&#x2F; Other &#39;Array&lt;string | number&gt;&#39; members...\n  slice(start?: number, end?: number): Array&lt;string | number&gt;;\n&#125;\n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an element’s type). Optional tuple elements can only come at the end, and also affect the type of length.在元组类型中，你也可以写一个可选属性，但可选元素必须在最后面，而且也会影响类型的 length 。\ntype Either2dOr3d &#x3D; [number, number, number?];\n\nfunction setCoordinate(coord: Either2dOr3d) &#123;\n  const [x, y, z] &#x3D; coord;\n\n  const z: number | undefined;\n\n  console.log(&#96;Provided coordinates had $&#123;coord.length&#125; dimensions&#96;);\n\n  &#x2F;&#x2F; (property) length: 2 | 3\n&#125;\n\nTuples can also have rest elements, which have to be an array&#x2F;tuple type.Tuples 也可以使用剩余元素语法，但必须是 array/tuple 类型：\ntype StringNumberBooleans &#x3D; [string, number, ...boolean[]];\ntype StringBooleansNumber &#x3D; [string, ...boolean[], number];\ntype BooleansStringNumber &#x3D; [...boolean[], string, number];\n\n\nStringNumberBooleans describes a tuple whose first two elements are string and number respectively, but which may have any number of booleans following.描述一个元组，前两个是字符串和数值，后面是boolean\nStringBooleansNumber describes a tuple whose first element is string and then any number of booleans and ending with a number.描述一个元组，第一个是字符串，最后一个是数值，中间有任意多个boolean类型\nBooleansStringNumber describes a tuple whose starting elements are any number of booleans and ending with a string then a number.描述一个元组，最后两个是string、numberA tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.有剩余元素的元组并不会设置 length，因为它只知道在不同位置上的已知元素信息：\n\nconst a: StringNumberBooleans &#x3D; [&quot;hello&quot;, 1];\nconst b: StringNumberBooleans &#x3D; [&quot;beautiful&quot;, 2, true];\nconst c: StringNumberBooleans &#x3D; [&quot;world&quot;, 3, true, false, true, false, true];\n\nWhy might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:可选元素和剩余元素的存在，使得 TypeScript 可以在参数列表里使用元组，就像这样：\nfunction readButtonInput(...args: [string, number, ...boolean[]]) &#123;\n  const [name, version, ...input] &#x3D; args;\n  &#x2F;&#x2F; ...\n&#125;\n\nis basically equivalent to:基本等同于：\nfunction readButtonInput(name: string, version: number, ...input: boolean[]) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nThis is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.\nreadonly Tuple Types只读元组类型One final note about tuple types - tuples types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax.元组类型也是可以设置 readonly 的：\nfunction doSomething(pair: readonly [string, number]) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nAs you might expect, writing to any property of a readonly tuple isn’t allowed in TypeScript.这样 TypeScript 就不会允许写入readonly 元组的任何属性：\nfunction doSomething(pair: readonly [string, number]) &#123;\n  pair[0] &#x3D; &quot;hello!&quot;;\n  &#x2F;&#x2F; Cannot assign to &#39;0&#39; because it is a read-only property.\n&#125;\n\nTuples tend to be created and left un-modified in most code, so annotating types as readonly tuples when possible is a good default. This is also important given that array literals with const assertions will be inferred with readonly tuple types.在大部分的代码中，元组只是被创建，使用完后也不会被修改，所以尽可能的将元组设置为 readonly 是一个好习惯。如果我们给一个数组字面量 const 断言，也会被推断为 readonly 元组类型。\nlet point &#x3D; [3, 4] as const;\n\nfunction distanceFromOrigin([x, y]: [number, number]) &#123;\n  return Math.sqrt(x ** 2 + y ** 2);\n&#125;\n\ndistanceFromOrigin(point);\n&#x2F;&#x2F; Argument of type &#39;readonly [3, 4]&#39; is not assignable to parameter of type &#39;[number, number]&#39;.\n&#x2F;&#x2F; The type &#39;readonly [3, 4]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;[number, number]&#39;.\n\nHere, distanceFromOrigin never modifies its elements, but expects a mutable tuple. Since point’s type was inferred as readonly [3, 4], it won’t be compatible with [number, number] since that type can’t guarantee point’s elements won’t be mutated.尽管 distanceFromOrigin 并没有更改传入的元素，但函数希望传入一个可变元组。因为 point 的类型被推断为 readonly [3, 4]，它跟 [number number] 并不兼容，所以 TypeScript 给了一个报错。\n","slug":"2022-06-08ts-object-types","date":"2022-06-08T01:21:19.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"2af24e4e300095206fecfdff43a1494d","title":"5.Typescript手册 函数","content":"Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.\nFunction Type Expressions函数类型表达式The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:最简单描述一个函数的方式是使用函数类型表达式（function type expression）。**它的写法有点类似于箭头函数：\nfunction greeter(fn: (a: string) &#x3D;&gt; void) &#123;\n  fn(&quot;Hello, World&quot;);\n&#125;\n\nfunction printToConsole(s: string) &#123;\n  console.log(s);\n&#125;\n\ngreeter(printToConsole);\n\nThe syntax (a: string) &#x3D;&gt; void means “a function with one parameter, named a, of type string, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly any.这个函数类型表达式的语法（a: string）=&gt; void，意思是“一个参数，名为a，类型为string，没有返回值”。Note that the parameter name is required. The function type (string) &#x3D;&gt; void means “a function with a parameter named string of type any“!注意，参数名是必需的。函数类型（string）=&gt; void意思是“一个参数名为string，类型为any”！Of course, we can use a type alias to name a function type:类型别名，可以命名一个函数类型：\ntype GreetFunction &#x3D; (a: string) &#x3D;&gt; void;\nfunction greeter(fn: GreetFunction) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nCall Signatures调用签名\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type:在JavaScript中，函数可以有属性，但是函数类型表达式语法不允许声明属性。\ntype DescribableFunction &#x3D; &#123;\n  description: string;\n  (someArg: number): boolean;\n&#125;;\nfunction doSomething(fn: DescribableFunction) &#123;\n  console.log(fn.description + &quot; returned &quot; + fn(6));\n&#125;\n\nNote that the syntax is slightly different compared to a function type expression - use : between the parameter list and the return type rather than &#x3D;&gt;.注意，语法与函数类型表达式不同，使用:在参数列表和返回类型之间。\nConstruct Signatures构造签名JavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature:JavaScript函数也可以使用new操作符。TypeScript将它们称为构造函数，因为它们通常会创建一个新的对象。\ntype SomeConstructor &#x3D; &#123;\n  new (s: string): SomeObject;\n&#125;;\nfunction fn(ctor: SomeConstructor) &#123;\n  return new ctor(&quot;hello&quot;);\n&#125;\n\nSome objects, like JavaScript’s Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily:一些对象，如JavaScript的Date对象，可以使用或不使用new。你可以在同一类型中同时使用调用和构造签名：\ninterface CallOrConstruct &#123;\n  new (s: string): Date;\n  (n?: number): number;\n&#125;\n\nGeneric Functions泛型函数It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:我们经常需要写这种函数，即函数的输出类型依赖函数的输入类型，或者两个输入的类型以某种形式相互关联。让我们考虑这样一个函数，它返回数组的第一个元素：\nfunction firstElement(arr: any[]) &#123;\n  return arr[0];\n&#125;\n\nThis function does its job, but unfortunately has the return type any. It’d be better if the function returned the type of the array element.注意此时函数返回值的类型是 any，如果能返回第一个元素的具体类型就更好了。In TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature:在TypeScript中，我们可以使用泛型来描述两个值之间的关系。我们这样做的目的是为了描述函数的输入和输出之间的关系。\nfunction firstElement&lt;Type&gt;(arr: Type[]): Type | undefined &#123;\n  return arr[0];\n&#125;\n\nBy adding a type parameter Type to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:在此函数中添加一个类型参数Type，并在两处使用它，我们创建了一个函数的输入和输出之间的关系。\n&#x2F;&#x2F; s is of type &#39;string&#39;\nconst s &#x3D; firstElement([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);\n&#x2F;&#x2F; n is of type &#39;number&#39;\nconst n &#x3D; firstElement([1, 2, 3]);\n&#x2F;&#x2F; u is of type undefined\nconst u &#x3D; firstElement([]);\n\nInference接口Note that we didn’t have to specify Type in this sample. The type was inferred - chosen automatically - by TypeScript.注意，我们在这个例子中没有指定类型。TypeScript自动推断出来了。We can use multiple type parameters as well. For example, a standalone version of map would look like this:我们可以使用多个类型参数。例如，一个单独版本的map函数会如下所示：\nfunction map&lt;Input, Output&gt;(\n  arr: Input[],\n  func: (arg: Input) &#x3D;&gt; Output\n): Output[] &#123;\n  return arr.map(func);\n&#125;\n\n&#x2F;&#x2F; Parameter &#39;n&#39; is of type &#39;string&#39;\n&#x2F;&#x2F; &#39;parsed&#39; is of type &#39;number[]&#39;\nconst parsed &#x3D; map([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], (n) &#x3D;&gt; parseInt(n));\n\nNote that in this example, TypeScript could infer both the type of the Input type parameter (from the given string array), as well as the Output type parameter based on the return value of the function expression (number).在这个例子中，TypeScript可以推断出Input类型参数的类型（从给定的字符串数组），以及Output类型参数的类型，基于函数表达式的返回值（number）。\nConstraints约束We’ve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept.我们写了一些可以操作任意类型的函数。有时候，我们可以只操作一个特定的类型集合。在这种情况下，我们可以使用约束来限制类型参数可以接受的类型。Let’s write a function that returns the longer of two values. To do this, we need a length property that’s a number. We constrain the type parameter to that type by writing an extends clause:我们写一个函数，返回两个值的长度。我们需要一个length属性，它是一个数字。我们通过写一个extends子句来限制类型参数：\nfunction longest&lt;Type extends &#123; length: number &#125;&gt;(a: Type, b: Type) &#123;\n  if (a.length &gt;&#x3D; b.length) &#123;\n    return a;\n  &#125; else &#123;\n    return b;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; longerArray is of type &#39;number[]&#39;\nconst longerArray &#x3D; longest([1, 2], [1, 2, 3]);\n&#x2F;&#x2F; longerString is of type &#39;alice&#39; | &#39;bob&#39;\nconst longerString &#x3D; longest(&quot;alice&quot;, &quot;bob&quot;);\n&#x2F;&#x2F; Error! Numbers don&#39;t have a &#39;length&#39; property\nconst notOK &#x3D; longest(10, 100);\n&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;&#123; length: number; &#125;&#39;.\n\nThere are a few interesting things to note in this example. We allowed TypeScript to infer the return type of longest. Return type inference also works on generic functions.在这个例子中，我们允许TypeScript推断longest的返回类型。返回类型推断也可以在泛型函数中使用。Because we constrained Type to { length: number }, we were allowed to access the .length property of the a and b parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.因为我们限制了类型参数为&#123; length: number &#125;，所以我们可以访问a和b参数的.length属性。没有类型约束，我们不能访问这些属性，因为值可能是其他类型而没有length属性。The types of longerArray and longerString were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!longerArray和longerString的类型是根据参数的类型推断出来的。记住，泛型是关于两个或多个值具有相同类型的问题！Finally, just as we’d like, the call to longest(10, 100) is rejected because the number type doesn’t have a .length property.最后，我们想要，调用longest(10, 100)会被拒绝，因为数字类型没有.length属性。\nWorking with Constrained Values工作中的约束值Here’s a common error when working with generic constraints:这里是工作中常见的错误：\nfunction minimumLength&lt;Type extends &#123; length: number &#125;&gt;(\n  obj: Type,\n  minimum: number\n): Type &#123;\n  if (obj.length &gt;&#x3D; minimum) &#123;\n    return obj;\n  &#125; else &#123;\n    return &#123; length: minimum &#125;;\n    &#x2F;&#x2F; Type &#39;&#123; length: number; &#125;&#39; is not assignable to type &#39;Type&#39;.\n    &#x2F;&#x2F; &#39;&#123; length: number; &#125;&#39; is assignable to the constraint of type &#39;Type&#39;, but &#39;Type&#39; could be instantiated with a different subtype of constraint &#39;&#123; length: number; &#125;&#39;.\n  &#125;\n&#125;\n\nIt might look like this function is OK - Type is constrained to { length: number }, and the function either returns Type or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:这个函数看起来是可以的，因为Type是约束为&#123; length: number &#125;，函数可以返回Type或者匹配这个约束的值。问题是，函数承诺返回传入的同样类型的对象，而不是匹配约束的对象。如果这段代码是合法的，你可以写一段代码，它永远不会运行：\n&#x2F;&#x2F; &#39;arr&#39; gets value &#123; length: 6 &#125;\nconst arr &#x3D; minimumLength([1, 2, 3], 6);\n&#x2F;&#x2F; and crashes here because arrays have\n&#x2F;&#x2F; a &#39;slice&#39; method, but not the returned object!\nconsole.log(arr.slice(0));\n\nSpecifying Type Arguments明确指定类型参数TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:Typescript通常可以在泛型调用中推断出意图的类型参数，但不是所有的情况。例如，如果你写了一个函数，用来合并两个数组：\nfunction combine&lt;Type&gt;(arr1: Type[], arr2: Type[]): Type[] &#123;\n  return arr1.concat(arr2);\n&#125;\n\nNormally it would be an error to call this function with mismatched arrays:通常情况下，如果调用这个函数传入不匹配的数组，就会报错：\nconst arr &#x3D; combine([1, 2, 3], [&quot;hello&quot;]);\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.\n\nIf you intended to do this, however, you could manually specify Type:如果你想这样做，你可以手动指定Type：\nconst arr &#x3D; combine&lt;string | number&gt;([1, 2, 3], [&quot;hello&quot;]);\n\nGuidelines for Writing Good Generic Functions写好泛型函数的指南Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.写好泛型函数是很有趣的，也可以很容易地使用类型参数。有太多类型参数或者使用约束，而且这些约束不需要的话，推断就会更加不成功，使用者会困惑。\nPush Type Parameters Down推下类型参数Here are two ways of writing a function that appear similar:这里有两种方式写一个函数，看起来像是一样的：\nfunction firstElement1&lt;Type&gt;(arr: Type[]) &#123;\n  return arr[0];\n&#125;\n\nfunction firstElement2&lt;Type extends any[]&gt;(arr: Type) &#123;\n  return arr[0];\n&#125;\n\n&#x2F;&#x2F; a: number (good)\nconst a &#x3D; firstElement1([1, 2, 3]);\n&#x2F;&#x2F; b: any (bad)\nconst b &#x3D; firstElement2([1, 2, 3]);\n\nThese might seem identical at first glance, but firstElement1 is a much better way to write this function. Its inferred return type is Type, but firstElement2’s inferred return type is any because TypeScript has to resolve the arr[0] expression using the constraint type, rather than “waiting” to resolve the element during a call.这两个函数看起来像是一样的，但是firstElement1更好的写法。它的推断返回类型是Type，但firstElement2的推断返回类型是any，因为TypeScript要在调用时使用约束类型，而不是等待元素被解析。Rule: When possible, use the type parameter itself rather than constraining it当可能的话，尽量使用类型参数本身而不约束它Use Fewer Type Parameters使用更少的类型参数Here’s another pair of similar functions:这里有一对相似的函数：\nfunction filter1&lt;Type&gt;(arr: Type[], func: (arg: Type) &#x3D;&gt; boolean): Type[] &#123;\n  return arr.filter(func);\n&#125;\n\nfunction filter2&lt;Type, Func extends (arg: Type) &#x3D;&gt; boolean&gt;(\n  arr: Type[],\n  func: Func\n): Type[] &#123;\n  return arr.filter(func);\n&#125;\n\nWe’ve created a type parameter Func that doesn’t relate two values. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. Func doesn’t do anything but make the function harder to read and reason about!我们创建了一个类型参数Func，它不关联两个值。这是一个红线，因为它意味着调用者希望指定类型参数时，必须手动指定一个额外的类型参数。Func不做任何事情，只是让这个函数更难读，理解。Rule: Always use as few type parameters as possible总是使用最少的类型参数\nType Parameters Should Appear Twice类型参数应该出现两次Sometimes we forget that a function might not need to be generic:有时候我们忘记了一个函数可能不需要泛型：\nfunction greet&lt;Str extends string&gt;(s: Str) &#123;\n  console.log(&quot;Hello, &quot; + s);\n&#125;\n\ngreet(&quot;world&quot;);\n\nWe could just as easily have written a simpler version:我们可以简单的写一个更简单的版本：\nfunction greet(s: string) &#123;\n  console.log(&quot;Hello, &quot; + s);\n&#125;\n\nRemember, type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it’s not relating anything.记住，类型参数是用来关联多个值的类型的。如果一个类型参数只被一次使用在函数签名中，它不关联任何东西。Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it如果一个类型参数只出现在一个位置，强烈建议如果你实际上需要它的话，\nOptional Parameters可选参数Functions in JavaScript often take a variable number of arguments. For example, the toFixed method of number takes an optional digit count:在 JavaScript 中，函数通常会接受一个可变数量的参数。例如，number 的 toFixed 方法接受一个可选的位数：\nfunction f(n: number) &#123;\n  console.log(n.toFixed()); &#x2F;&#x2F; 0 arguments\n  console.log(n.toFixed(3)); &#x2F;&#x2F; 1 argument\n&#125;\n\nWe can model this in TypeScript by marking the parameter as optional with ?:我们可以在 TypeScript 中使用 ?: 来标记可选参数\nfunction f(x?: number) &#123;\n  &#x2F;&#x2F; ...\n&#125;\nf(); &#x2F;&#x2F; OK\nf(10); &#x2F;&#x2F; OK\n\nAlthough the parameter is specified as type number, the x parameter will actually have the type number | undefined because unspecified parameters in JavaScript get the value undefined.在 JavaScript 中，未指定参数的值会被设置为 undefined。You can also provide a parameter default:你也可以提供一个参数默认值：\nfunction f(x &#x3D; 10) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nNow in the body of f, x will have type number because any undefined argument will be replaced with 10. Note that when a parameter is optional, callers can always pass undefined, as this simply simulates a “missing” argument:在 f 中的 body 中，x 将有 number 类型，因为任何未定义的参数都会被替换为 10。\ndeclare function f(x?: number): void;\n&#x2F;&#x2F; cut\n&#x2F;&#x2F; All OK\nf();\nf(10);\nf(undefined);\n\nOptional Parameters in Callbacks回调函数中的可选参数Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:一旦你学会了可选参数和函数类型表达式，写函数调用回调函数时很容易出错：\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) &#x3D;&gt; void) &#123;\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    callback(arr[i], i);\n  &#125;\n&#125;\n\nWhat people usually intend when writing index? as an optional parameter is that they want both of these calls to be legal:人们常常希望写 index 作为可选参数，这意味着它们都是合法的：\nmyForEach([1, 2, 3], (a) &#x3D;&gt; console.log(a));\nmyForEach([1, 2, 3], (a, i) &#x3D;&gt; console.log(a, i));\n\nWhat this actually means is that callback might get invoked with one argument. In other words, the function definition says that the implementation might look like this:这实际上意味着回调函数可能会被调用一个参数。\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) &#x3D;&gt; void) &#123;\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    &#x2F;&#x2F; I don&#39;t feel like providing the index today\n    callback(arr[i]);\n  &#125;\n&#125;\n\nIn turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:在 TypeScript 中，会发出这些不可能的错误：\nmyForEach([1, 2, 3], (a, i) &#x3D;&gt; &#123;\n  console.log(i.toFixed());\n  &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.\n&#125;);\n\nIn JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.在 JavaScript 中，如果调用函数的参数多于参数，那么这些多余的参数将被忽略。TypeScript 也会像这样。函数可以接受多个参数，但是参数的类型必须是相同的。When writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument写一个回调函数类型时，如果你不想传递这个参数，就不要写可选参数。\nFunction Overloads函数重载Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a Date that takes either a timestamp (one argument) or a month&#x2F;day&#x2F;year specification (three arguments).在 JavaScript 中，可以调用一个函数，参数的数量和类型都不一样。例如，你可以写一个函数，用来生成一个 Date 对象，可以接受一个时间戳（一个参数）或一个月/日/年 的指定（三个参数）。In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function:在 TypeScript 中，我们可以写一个函数，它可以被调用不同的参数和类型，通过写出多个函数类型（通常是两个或多个），然后写出函数的 body：\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date &#123;\n  if (d !&#x3D;&#x3D; undefined &amp;&amp; y !&#x3D;&#x3D; undefined) &#123;\n    return new Date(y, mOrTimestamp, d);\n  &#125; else &#123;\n    return new Date(mOrTimestamp);\n  &#125;\n&#125;\nconst d1 &#x3D; makeDate(12345678);\nconst d2 &#x3D; makeDate(5, 5, 5);\nconst d3 &#x3D; makeDate(1, 3);\n&#x2F;&#x2F; No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.\n\nIn this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures.在这个例子中，我们写了两个函数类型：一个只接受一个参数，一个只接受三个参数。这两个第一个类型是函数类型。Then, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!然后，我们写了一个函数实现，这个函数类型不能直接调用。即使我们写了一个参数后，再写了一个可选参数，也不能调用两个参数。虽然我们写了两个参数，但是不能调用两个参数。\nOverload Signatures and the Implementation Signature重载签名和实现签名This is a common source of confusion. Often people will write code like this and not understand why there is an error:这是一个常见的混乱源。很多人写了这样的代码，但是不知道为什么会有错误。\nfunction fn(x: string): void;\nfunction fn() &#123;\n  &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F; Expected to be able to call with zero arguments\nfn();\n&#x2F;&#x2F; Expected 1 arguments, but got 0.\n\nAgain, the signature used to write the function body can’t be “seen” from the outside.再次，写出函数的 body 的签名不能被外部看到。The signature of the implementation is not visible from the outside. When writing an overloaded function, you should always have two or more signatures above the implementation of the function.在写一个重载函数时，你应该总是写两个或多个签名，在函数的实现之上。你应该总是写两个或多个签名，在函数的实现之上。The implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:实现签名必须与重载签名一致。例如，这些函数有错误，因为实现签名不正确。\nfunction fn(x: boolean): void;\n&#x2F;&#x2F; Argument type isn&#39;t right\nfunction fn(x: string): void;\n&#x2F;&#x2F; This overload signature is not compatible with its implementation signature.\nfunction fn(x: boolean) &#123;&#125;\n\nfunction fn(x: string): string;\n&#x2F;&#x2F; Return type isn&#39;t right\nfunction fn(x: number): boolean;\n&#x2F;&#x2F; This overload signature is not compatible with its implementation signature.\nfunction fn(x: string | number) &#123;\n  return &quot;oops&quot;;\n&#125;\n\nWriting Good Overloads写好重载Like generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.就像泛型一样，也有一些建议提供给你。遵循这些原则，可以让你的函数更方便调用、理解。Let’s consider a function that returns the length of a string or an array:我们来考虑一个函数，它返回一个字符串或数组的长度：\nfunction len(s: string): number;\nfunction len(arr: any[]): number;\nfunction len(x: any) &#123;\n  return x.length;\n&#125;\n\nThis function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload:这个函数代码功能实现了，也没有什么报错，但我们不能传入一个可能是字符串或者是数组的值，因为 TypeScript 只能一次用一个函数重载处理一次函数调用。\nlen(&quot;&quot;); &#x2F;&#x2F; OK\nlen([0]); &#x2F;&#x2F; OK\nlen(Math.random() &gt; 0.5 ? &quot;hello&quot; : [0]);\n&#x2F;&#x2F; No overload matches this call.\n&#x2F;&#x2F; 没有匹配的重载函数。\n&#x2F;&#x2F; Overload 1 of 2, &#39;(s: string): number&#39;, gave the following error.\n&#x2F;&#x2F; 重载 1 和 2 之间的函数调用报错。\n&#x2F;&#x2F; Argument of type &#39;number[] | &quot;hello&quot;&#39; is not assignable to parameter of type &#39;string&#39;.\n&#x2F;&#x2F;  参数类型 &#39;number[] | &quot;hello&quot;&#39; 不能赋值给参数类型 &#39;string&#39;。\n&#x2F;&#x2F; Type &#39;number[]&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F; 类型 &#39;number[]&#39; 不能赋值给类型 &#39;string&#39;。\n&#x2F;&#x2F; Overload 2 of 2, &#39;(arr: any[]): number&#39;, gave the following error.\n&#x2F;&#x2F; 重载 2 和 2 之间的函数调用报错。\n&#x2F;&#x2F; Argument of type &#39;number[] | &quot;hello&quot;&#39; is not assignable to parameter of type &#39;any[]&#39;.\n&#x2F;&#x2F; 参数类型 &#39;number[] | &quot;hello&quot;&#39; 不能赋值给参数类型 &#39;any[]&#39;。\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;any[]&#39;.\n&#x2F;&#x2F; 类型 &#39;string&#39; 不能赋值给类型 &#39;any[]&#39;。\n\nBecause both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:因为两个重载函数的参数数量和返回值类型都一样，我们可以写一个不重载的函数：\nfunction len(x: any[] | string) &#123;\n  return x.length;\n&#125;\n\nThis is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.这更好了！调用者可以传入任意类型的值，并且我们不需要再去找一个正确的实现签名。Always prefer parameters with union types instead of overloads when possible如果可以的话，尽量使用联合类型而不是重载函数。\nDeclaring this in a Function在函数中声明 thisTypeScript will infer what the this should be in a function via code flow analysis, for example in the following:TypeScript 会根据代码流分析来决定函数中 this 的值。例如，在下面的代码中：\nconst user &#x3D; &#123;\n  id: 123,\n\n  admin: false,\n  becomeAdmin: function () &#123;\n    this.admin &#x3D; true;\n  &#125;,\n&#125;;\n\nTypeScript understands that the function user.becomeAdmin has a corresponding this which is the outer object user. this, heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object this represents. The JavaScript specification states that you cannot have a parameter called this, and so TypeScript uses that syntax space to let you declare the type for this in the function body.TypeScript 知道函数 user.becomeAdmin 有一个对应的 this，这个 this 可以足够大部分的情况，但有很多情况需要更多的控制权。 JavaScript 规范禁止使用 this 参数，因此 TypeScript 使用这种语法空间来声明函数体中 this 的类型。\ninterface DB &#123;\n  filterUsers(filter: (this: User) &#x3D;&gt; boolean): User[];\n&#125;\n\nconst db &#x3D; getDB();\nconst admins &#x3D; db.filterUsers(function (this: User) &#123;\n  return this.admin;\n&#125;);\n\nThis pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use function and not arrow functions to get this behavior:这种模式通常出现在回调函数风格的 API 中，其中另一个对象通常控制函数调用的时机。请注意，你需要使用 function 而不是 arrow function 来获取这种行为。\ninterface DB &#123;\n  filterUsers(filter: (this: User) &#x3D;&gt; boolean): User[];\n&#125;\n\nconst db &#x3D; getDB();\nconst admins &#x3D; db.filterUsers(() &#x3D;&gt; this.admin);\n&#x2F;&#x2F; The containing arrow function captures the global value of &#39;this&#39;.\n&#x2F;&#x2F; 这个包含的箭头函数捕获了全局值 &#39;this&#39;。\n&#x2F;&#x2F; Element implicitly has an &#39;any&#39; type because type &#39;typeof globalThis&#39; has no index signature.\n&#x2F;&#x2F; 元素隐式有一个 &#39;any&#39; 类型，因为类型 &#39;typeof globalThis&#39; 没有索引签名。\n\nOther Types to Know About其他需要知道的类型There are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.这里介绍一些也会经常出现的类型。像其他的类型一样，你也可以在任何地方使用它们，但它们经常与函数搭配使用。void\nvoid represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any return statements, or doesn’t return any explicit value from those return statements:void 类型表示函数没有返回值的情况。它在函数没有返回值的情况下被推断为 any 类型。\n&#x2F;&#x2F; The inferred return type is void\nfunction noop() &#123;\n  return;\n&#125;\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript. There are further details at the end of this chapter.在 JavaScript 中，函数没有返回值的情况下，函数会自动返回 undefined。但是在 TypeScript 中，void 和 undefined 的类型不一样。有更多详情在本章末尾。void is not the same as undefined.void 类型不是 undefined 类型。\nobject\nThe special type object refers to any value that isn’t a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object. It’s very likely you will never use Object.这个特殊的类型 object 可以表示任何不是原始类型（primitive）的值 (string、number、bigint、boolean、symbol、null、undefined)。object 不同于空对象类型 &#123; &#125;，也不同于全局类型 Object。很有可能你也用不到 Object\n\n\n\n\n\n\n\n\n\nobject is not Object. Always use object!object 不同于 Object ，总是用 object!\nNote that in JavaScript, function values are objects: They have properties, have Object.prototype in their prototype chain, are instanceof Object, you can call Object.keys on them, and so on. For this reason, function types are considered to be objects in TypeScript.注意在 JavaScript 中，函数就是对象，他们可以有属性，在他们的原型链上有 Object.prototype，并且 instanceof Object。你可以对函数使用 Object.keys 等等。由于这些原因，在 TypeScript 中，函数也被认为是 object。\nunknown\nThe unknown type represents any value. This is similar to the any type, but is safer because it’s not legal to do anything with an unknown value:unknown 类型可以表示任何值。有点类似于 any，但是更安全，因为对 unknown 类型的值做任何事情都是不合法的：\nfunction f1(a: any) &#123;\n  a.b(); &#x2F;&#x2F; OK\n&#125;\nfunction f2(a: unknown) &#123;\n  a.b();\n  &#x2F;&#x2F; Object is of type &#39;unknown&#39;.\n&#125;\n\nThis is useful when describing function types because you can describe functions that accept any value without having any values in your function body.有的时候用来描述函数类型，还是蛮有用的。你可以描述一个函数可以接受传入任何值，但是在函数体内又不用到 any 类型的值。Conversely, you can describe a function that returns a value of unknown type:相反，你可以描述一个函数返回一个不知道什么类型的值，比如：\nfunction safeParse(s: string): unknown &#123;\n  return JSON.parse(s);\n&#125;\n\n&#x2F;&#x2F; Need to be careful with &#39;obj&#39;!\nconst obj &#x3D; safeParse(someRandomString);\n\nnever\nSome functions never return a value:一些函数从来不返回值：\nfunction fail(msg: string): never &#123;\n  throw new Error(msg);\n&#125;\n\nThe never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program.never 类型表示一个值不会再被观察到 (observed)。作为一个返回类型时，它表示这个函数会丢一个异常，或者会结束程序的执行。never also appears when TypeScript determines there’s nothing left in a union.当 TypeScript 确定在联合类型中已经没有可能是其中的类型的时候，never 类型也会出现：\nfunction fn(x: string | number) &#123;\n  if (typeof x &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    &#x2F;&#x2F; do something\n  &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n    &#x2F;&#x2F; do something else\n  &#125; else &#123;\n    x; &#x2F;&#x2F; has type &#39;never&#39;!\n  &#125;\n&#125;\n\nFunction\nThe global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any:Function 类型描述了所有函数值的属性，比如 bind、call、apply 等等。这个类型也有一个特殊的属性，可以被调用，这些调用会返回任何类型的值：\nfunction doSomething(f: Function) &#123;\n  return f(1, 2, 3);\n&#125;\n\nThis is an untyped function call and is generally best avoided because of the unsafe any return type.这是一个无类型函数调用 (untyped function call)，这种调用最好被避免，因为它返回的是一个不安全的 any类型。If you need to accept an arbitrary function but don’t intend to call it, the type () &#x3D;&gt; void is generally safer.如果你准备接受一个黑盒的函数，但是又不打算调用它，() =&gt; void 会更安全一些。\nRest Parameters and Arguments剩余参数Background Reading:\n\nRest Parameters\nSpread Syntax\n\nRest Parameters剩余参数In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters.除了用可选参数、重载能让函数接收不同数量的函数参数，我们也可以通过使用剩余参数语法（rest parameters），定义一个可以传入数量不受限制的函数参数的函数：A rest parameter appears after all other parameters, and uses the … syntax:剩余参数必须放在所有参数的最后面，并使用 ... 语法：\nfunction multiply(n: number, ...m: number[]) &#123;\n  return m.map((x) &#x3D;&gt; n \\* x);\n&#125;\n&#x2F;&#x2F; &#39;a&#39; gets value [10, 20, 30, 40]\nconst a &#x3D; multiply(10, 1, 2, 3, 4);\n\nIn TypeScript, the type annotation on these parameters is implicitly any[] instead of any, and any type annotation given must be of the form Arrayor T[], or a tuple type (which we’ll learn about later).在 TypeScript 中，剩余参数的类型会被隐式设置为 any[] 而不是 any，如果你要设置具体的类型，必须是 Array&lt;T&gt; 或者 T[]的形式，再或者就是元组类型（tuple type）。\nRest Arguments剩余参数Conversely, we can provide a variable number of arguments from an array using the spread syntax. For example, the push method of arrays takes any number of arguments:我们可以借助一个使用 ... 语法的数组，为函数提供不定数量的实参。举个例子，数组的 push 方法就可以接受任何数量的实参：\nconst arr1 &#x3D; [1, 2, 3];\nconst arr2 &#x3D; [4, 5, 6];\narr1.push(...arr2);\n\nNote that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:注意一般情况下，TypeScript 并不会假定数组是不变的(immutable)，这会导致一些意外的行为：\n&#x2F;&#x2F; Inferred type is number[] -- &quot;an array with zero or more numbers&quot;,\n&#x2F;&#x2F; not specifically two numbers\nconst args &#x3D; [8, 5];\nconst angle &#x3D; Math.atan2(...args);\n&#x2F;&#x2F; A spread argument must either have a tuple type or be passed to a rest parameter.\n\nThe best fix for this situation depends a bit on your code, but in general a const context is the most straightforward solution:这种情况的最佳解决方案可能是一个更简单的方案：\n&#x2F;&#x2F; Inferred as 2-length tuple\nconst args &#x3D; [8, 5] as const;\n&#x2F;&#x2F; OK\nconst angle &#x3D; Math.atan2(...args);\n\nUsing rest arguments may require turning on downlevelIteration when targeting older runtimes.使用剩余参数可能需要在更旧的运行时配合 downlevelIteration 参数。\nParameter Destructuring你可以使用参数解构方便的将作为参数提供的对象解构为函数体内一个或者多个局部变量，在 JavaScript 中，是这样的：\nBackground Reading:\n\nDestructuring Assignment\n\nYou can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:你可以使用参数解构来轻松地将一个作为参数提供的对象解构为函数体内一个或者多个局部变量。在 JavaScript 中，它的样子是这样的：\nfunction sum(&#123; a, b, c &#125;) &#123;\n  console.log(a + b + c);\n&#125;\nsum(&#123; a: 10, b: 3, c: 9 &#125;);\n&#x2F;&#x2F; The type annotation for the object goes after the destructuring syntax:\n\nfunction sum(&#123; a, b, c &#125;: &#123; a: number; b: number; c: number &#125;) &#123;\n  console.log(a + b + c);\n&#125;\n\nThis can look a bit verbose, but you can use a named type here as well:这可能会太长，但你可以使用一个命名类型：\n&#x2F;&#x2F; Same as prior example\ntype ABC &#x3D; &#123; a: number; b: number; c: number &#125;;\nfunction sum(&#123; a, b, c &#125;: ABC) &#123;\n  console.log(a + b + c);\n&#125;\n\nAssignability of Functions函数的可赋值性Return type void返回voidThe void return type for functions can produce some unusual, but expected behavior.函数的返回类型为void时，可能会产生一些有意想不到的行为。Contextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type (type vf &#x3D; () &#x3D;&gt; void), when implemented, can return any other value, but it will be ignored.在一个返回类型为void的函数中，不会强制函数不返回什么东西。另一种说法是一个上下文函数类型，它的返回类型为void，当实现的时候，可以返回任何值，但是它将被忽略。Thus, the following implementations of the type () &#x3D;&gt; void are valid:因此，下面的实现是有效的：\ntype voidFunc &#x3D; () &#x3D;&gt; void;\n\nconst f1: voidFunc &#x3D; () &#x3D;&gt; &#123;\n  return true;\n&#125;;\n\nconst f2: voidFunc &#x3D; () &#x3D;&gt; true;\n\nconst f3: voidFunc &#x3D; function () &#123;\n  return true;\n&#125;;\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of void:当一个函数的返回值被赋值给另一个变量时，它将保持返回类型为void的类型：\nconst v1 &#x3D; f1();\n\nconst v2 &#x3D; f2();\n\nconst v3 &#x3D; f3();\n\nThis behavior exists so that the following code is valid even though Array.prototype.push returns a number and the Array.prototype.forEach method expects a function with a return type of void.这种行为存在，这样就可以保证下面的代码是有效的，即使 Array.prototype.push 返回一个数字，Array.prototype.forEach 方法也期望一个返回类型为void的函数。\nconst src &#x3D; [1, 2, 3];\nconst dst &#x3D; [0];\n\nsrc.forEach((el) &#x3D;&gt; dst.push(el));\n\nThere is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything.当一个字面量函数定义有一个返回类型为void的函数，那么函数必须不返回任何东西。\nfunction f2(): void &#123;\n  &#x2F;&#x2F; @ts-expect-error\n  return true;\n&#125;\n\nconst f3 &#x3D; function (): void &#123;\n  &#x2F;&#x2F; @ts-expect-error , Type &#39;boolean&#39; is not assignable to type &#39;void&#39;.\n  return true;\n&#125;;\n\nFor more on void please refer to these other documentation entries:更多关于void的文档请参见这些其他文档条目：v1 handbookv2 handbookFAQ - “Why are functions returning non-void assignable to function returning void?”为什么函数返回非void类型可以赋值给函数返回void类型？\n参考链接TypeScript 手册 functions函数（More On Functions）\n","slug":"2022-06-08ts-more-on-functions","date":"2022-06-07T13:21:19.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"aab722f3fd65a7516918bd7fed1d7d01","title":"4.Typescript手册 收缩类型","content":"Narrowing缩小范围\nImagine we have a function called padLeft.试想我们有这样一个函数，函数名为 padLeft：\nfunction padLeft(padding: number | string, input: string): string &#123;\n  throw new Error(&quot;Not implemented yet!&quot;);\n&#125;\n\nIf padding is a number, it will treat that as the number of spaces we want to prepend to input. If padding is a string, it should just prepend padding to input. Let’s try to implement the logic for when padLeft is passed a number for padding.\n如果 padding 是数字，它将会将 padding 视为我们要添加的空格数量，如果 padding 是字符串，它将会添加 padding 到 input 的前面。\nfunction padLeft(padding: number | string, input: string) &#123;\n  return &quot; &quot;.repeat(padding) + input;\n  &#x2F;&#x2F; Argument of type &#39;string | number&#39; is not assignable to parameter of type &#39;number&#39;.\n  &#x2F;&#x2F; 参数类型 &#39;string | number&#39; 不能赋值给参数类型 &#39;number&#39;。\n  &#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.\n  &#x2F;&#x2F; 类型 &#39;string&#39; 不能赋值给类型 &#39;number&#39;。\n&#125;\n\nUh-oh, we’re getting an error on padding.哇，我们得到一个错误，padding。TypeScript is warning us that adding a number | string to a number might not give us what we want, and it’s right. In other words, we haven’t explicitly checked if padding is a number first, nor are we handling the case where it’s a string, so let’s do exactly that.这是 TypeScript 在警告我们，如果把一个 number 类型 (即例子里的数字 1 )和一个 number | string 类型相加，也许并不会达到我们想要的结果。换句话说，我们应该先检查下 padding 是否是一个 number，或者处理下当 padding 是 string 的情况，那我们可以这样做：\nfunction padLeft(padding: number | string, input: string) &#123;\n  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n    return &quot; &quot;.repeat(padding) + input;\n  &#125;\n  return padding + input;\n&#125;\n\nIf this mostly looks like uninteresting JavaScript code, that’s sort of the point. Apart from the annotations we put in place, this TypeScript code looks like JavaScript. The idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety.如果这个代码看起来没有什么意思，那就是 TypeScript 的类型系统希望我们能写出一些比较普通的 JavaScript 代码，而不是折腾至最后才知道类型安全。While it might not look like much, there’s actually a lot going under the covers here. Much like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs like if&#x2F;else, conditional ternaries, loops, truthiness checks, etc., which can all affect those types.这里的实现比较简单，但是它真的是一个类型检查器，它会在 JavaScript 中的 if/else、条件表达式、循环、真假值检查等控制流中进行类型检查。Within our if check, TypeScript sees typeof padding &#x3D;&#x3D;&#x3D; “number” and understands that as a special form of code called a type guard. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing. In many editors we can observe these types as they change, and we’ll even do so in our examples.在我们的 if 检查中，TypeScript 会看到 typeof padding === &quot;number&quot;，并且会解释这个表达式为一个特殊的代码，这个代码被称为类型检查。TypeScript 会根据我们的程序的执行流，来检查一个值的最具体的类型。这些特殊的检查（称为类型检查）和赋值，会影响到类型的精确性。在编辑器中，我们可以看到这些类型的变化，我们也会在我们的例子中看到。\nfunction padLeft(padding: number | string, input: string) &#123;\n  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n    return &quot; &quot;.repeat(padding) + input;\n\n    &#x2F;&#x2F; (parameter) padding: number\n  &#125;\n  return padding + input;\n\n  &#x2F;&#x2F; (parameter) padding: string\n&#125;\n\nThere are a couple of different constructs TypeScript understands for narrowing.TypeScript 会理解一些更加精确的构造。\ntypeof type guards类型保护\nAs we’ve seen, JavaScript supports a typeof operator which can give very basic information about the type of values we have at runtime. TypeScript expects this to return a certain set of strings:JavaScript 支持一个 typeof 操作符，它可以给我们的值返回一些基本的信息。TypeScript 期望这些信息是一个特定的集合：\n“string”“number”“bigint”“boolean”“symbol”“undefined”“object”“function”\nLike we saw with padLeft, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.和 padLeft 一样，这个操作符在 JavaScript 库中很常见，TypeScript 可以理解它来缩小不同的分支的类型。In TypeScript, checking against the value returned by typeof is a type guard. Because TypeScript encodes how typeof operates on different values, it knows about some of its quirks in JavaScript. For example, notice that in the list above, typeof doesn’t return the string null. Check out the following example:在 TypeScript 中，检查 typeof 返回的值就是一种类型保护。TypeScript 知道 typeof 不同值的结果，它也能识别 JavaScript 中一些怪异的地方，就比如在上面的列表中，typeof 并没有返回字符串 null，看下面这个例子：\nfunction printAll(strs: string | string[] | null) &#123;\n  if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;\n    for (const s of strs) &#123;\n      &#x2F;&#x2F; Object is possibly &#39;null&#39;.\n      console.log(s);\n    &#125;\n  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    console.log(strs);\n  &#125; else &#123;\n    &#x2F;&#x2F; do nothing\n  &#125;\n&#125;\n\nIn the printAll function, we try to check if strs is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript). But it turns out that in JavaScript, typeof null is actually “object”! This is one of those unfortunate accidents of history.在这个 printAll 函数中，我们尝试判断 strs 是否是一个对象，原本的目的是判断它是否是一个数组类型，但是在 JavaScript 中，typeof null 也会返回 object。而这是 JavaScript 一个不幸的历史事故。Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that strs was only narrowed down to string[] | null instead of just string[].熟练的用户自然不会感到惊讶，但也并不是所有人都如此熟练。不过幸运的是，TypeScript 会让我们知道 strs 被收窄为 strings[] | null ，而不仅仅是 string[]。This might be a good segue into what we’ll call “truthiness” checking.这可能是一个好的转折点。\nTruthiness narrowing真实性缩减\nTruthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.真实性可能不是在字典里面找到的，但是你会听到 JavaScript 中的真实性。In JavaScript, we can use any expression in conditionals, &amp;&amp;s, ||s, if statements, Boolean negations (!), and more. As an example, if statements don’t expect their condition to always have the type boolean.这是因为 JavaScript 会做隐式类型转换，像 0 、NaN、&quot;&quot;、0n、null undefined 这些值都会被转为 false，其他的值则会被转为 true。当然你也可以使用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!：\nfunction getUsersOnlineMessage(numUsersOnline: number) &#123;\n  if (numUsersOnline) &#123;\n    return &#96;There are $&#123;numUsersOnline&#125; online now!&#96;;\n  &#125;\n  return &quot;Nobody&#39;s here. :(&quot;;\n&#125;\n\nIn JavaScript, constructs like if first “coerce” their conditions to booleans to make sense of them, and then choose their branches depending on whether the result is true or false. Values like0、NaN、&quot;&quot;、0n、null undefined 这些值都会被转为 false，其他的值则会被转为 true。当然你也可以使用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!：\n\n0\nNaN\n“” (the empty string)\n0n (the bigint version of zero)\nnull\nundefined\n\nall coerce to false, and other values get coerced true. You can always coerce values to booleans by running them through the Boolean function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type true, while inferring the first as type boolean.)所有 这些值都会被转为 false，其他的值则会被转为 true。你可以通过调用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!。(这种情况下，TypeScript 会推断一个简单的布尔值类型 true，而不是类型 boolean。)\n&#x2F;&#x2F; both of these result in &#39;true&#39;\nBoolean(&quot;hello&quot;); &#x2F;&#x2F; type: boolean, value: true\n!!&quot;world&quot;; &#x2F;&#x2F; type: true,    value: true\n\nIt’s fairly popular to leverage this behavior, especially for guarding against values like null or undefined. As an example, let’s &#96;&#96;&#96;using it for our printAll function.这种使用方式非常流行，尤其适用于防范 null 和 undefiend 这种值的时候。举个例子，我们可以在 printAll 函数中这样使用：\nfunction printAll(strs: string | string[] | null) &#123;\n  if (strs &amp;&amp; typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;\n    for (const s of strs) &#123;\n      console.log(s);\n    &#125;\n  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    console.log(strs);\n  &#125;\n&#125;\n\nYou’ll notice that we’ve gotten rid of the error above by checking if strs is truthy. This at least prevents us from dreaded errors when we run our code like:这里我们获得了一个错误，因为我们检查了 strs 是否为真。这至少防止了我们在运行代码时出现的错误。\n&#x2F;&#x2F; TypeError: null is not iterable\n\nKeep in mind though that truthiness checking on primitives can often be error prone. As an example, consider a different attempt at writing printAll但还是要注意，在基本类型上的真值检查很容易导致错误，比如，如果我们这样写 printAll 函数：\nfunction printAll(strs: string | string[] | null) &#123;\n  &#x2F;&#x2F; !!!!!!!!!!!!!!!!\n  &#x2F;&#x2F; DON&#39;T DO THIS!\n  &#x2F;&#x2F; KEEP READING\n  &#x2F;&#x2F; !!!!!!!!!!!!!!!!\n  if (strs) &#123;\n    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;\n      for (const s of strs) &#123;\n        console.log(s);\n      &#125;\n    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n      console.log(strs);\n    &#125;\n  &#125;\n&#125;\n\nWe wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.我们将整个函数包裹在真值检查中，但这有一个潜在的问题：我们可能不再正确处理空字符串的情况。TypeScript doesn’t hurt us here at all, but this is behavior worth noting if you’re less familiar with JavaScript. TypeScript can often help you catch bugs early on, but if you choose to do nothing with a value, there’s only so much that it can do without being overly prescriptive. If you want, you can make sure you handle situations like these with a linter.TypeScript 不会给我们任何麻烦，但如果你不了解 JavaScript，这可能是一个很有用的技巧。TypeScript 可以帮助你提前发现错误，但如果你选择不做任何事情，那么只能是有限的。如果你想，你可以使用一个 linter 来确保你在这种情况下正确处理。One last word on narrowing by truthiness is that Boolean negations with ! filter out from negated branches.另外一个通过真值检查收窄类型的方式是通过!操作符。\nfunction multiplyAll(values: number[] | undefined, factor: number): number[] | undefined &#123;\n  if (!values) &#123;\n    return values;\n  &#125; else &#123;\n    return values.map((x) &#x3D;&gt; x \\* factor);\n  &#125;\n&#125;\n\nEquality narrowing等值缩减\nTypeScript also uses switch statements and equality checks like &#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;, &#x3D;&#x3D;, and !&#x3D; to narrow types. For example:TypeScript 也使用了 switch 语句和等值检查，比如 ===、!==、==、!=。\nfunction example(x: string | number, y: string | boolean) &#123;\n  if (x &#x3D;&#x3D;&#x3D; y) &#123;\n    &#x2F;&#x2F; We can now call any &#39;string&#39; method on &#39;x&#39; or &#39;y&#39;.\n    x.toUpperCase();\n\n    &#x2F;&#x2F; (method) String.toUpperCase(): string\n    y.toLowerCase();\n\n    &#x2F;&#x2F; (method) String.toLowerCase(): string\n  &#125; else &#123;\n    console.log(x);\n\n    &#x2F;&#x2F; (parameter) x: string | number\n    console.log(y);\n\n    &#x2F;&#x2F; (parameter) y: string | boolean\n  &#125;\n&#125;\n\nWhen we checked that x and y are both equal in the above example, TypeScript knew their types also had to be equal. Since string is the only common type that both x and y could take on, TypeScript knows that x and y must be a string in the first branch.在上面的例子中，我们检查了 x 和 y 是否相等。TypeScript 知道 x 和 y 的类型也必须相等。因为 string 是所有 x 和 y 可能取得的类型的共同类型，所以 TypeScript 知道 x 和 y 必须是 string 的第一个分支。Checking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a printAll function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out nulls, and TypeScript still correctly removes null from the type of strs.检查特定的字面值（而不是变量）也可以工作。在我们提到的真值收窄中，我们写了一个 printAll 函数，它错误地处理了空字符串，而不是通过检查 null 来做。可以通过检查 null 来阻止 null，TypeScript 仍然能正确地从 strs 的类型中去除 null。\nfunction printAll(strs: string | string[] | null) &#123;\n  if (strs !&#x3D;&#x3D; null) &#123;\n    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;\n      for (const s of strs) &#123;\n        &#x2F;&#x2F; (parameter) strs: string[]\n        console.log(s);\n      &#125;\n    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n      console.log(strs);\n\n      &#x2F;&#x2F; (parameter) strs: string\n    &#125;\n  &#125;\n&#125;\n\nJavaScript’s looser equality checks with &#x3D;&#x3D; and !&#x3D; also get narrowed correctly. If you’re unfamiliar, checking whether something &#x3D;&#x3D; null actually not only checks whether it is specifically the value null - it also checks whether it’s potentially undefined. The same applies to &#x3D;&#x3D; undefined: it checks whether a value is either null or undefined.JavaScript 的更粗糙的等值检查，比如 == 和 !=，也能正确收窄类型。如果你不了解，检查 something == null 是否不仅检查了 something 是否是特定的值 null，还检查了它是否可能是未定义的。同样的道理，检查 something == undefined 是否不仅检查了 something 是否是特定的值 undefined，还检查了它是否可能是未定义的。\ninterface Container &#123;\n  value: number | null | undefined;\n&#125;\n\nfunction multiplyValue(container: Container, factor: number) &#123;\n  &#x2F;&#x2F; Remove both &#39;null&#39; and &#39;undefined&#39; from the type.\n  if (container.value !&#x3D; null) &#123;\n    console.log(container.value);\n\n    &#x2F;&#x2F; (property) Container.value: number\n\n    &#x2F;&#x2F; Now we can safely multiply &#39;container.value&#39;.\n    container.value *&#x3D; factor;\n  &#125;\n&#125;\n\nThe in operator narrowingin操作符缩减\nJavaScript has an operator for determining if an object has a property with a name: the in operator. TypeScript takes this into account as a way to narrow down potential types.JavaScript 有一个操作符用来确定对象是否有一个属性名：in 操作符。TypeScript 使用这种方式来收窄可能的类型。For example, with the code: “value” in x. where “value” is a string literal and x is a union type. The “true” branch narrows x’s types which have either an optional or required property value, and the “false” branch narrows to types which have an optional or missing property value.例如，在 x 中，“value” 是一个字面量字符串，x 是一个联合类型。“true” 分支收窄 x 的类型，其中有一个可选或必须的属性值，而“false” 分支收窄到有一个可选或缺少的属性值。\ntype Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;\ntype Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;\n\nfunction move(animal: Fish | Bird) &#123;\n  if (&quot;swim&quot; in animal) &#123;\n    return animal.swim();\n  &#125;\n\n  return animal.fly();\n&#125;\n\nTo reiterate optional properties will exist in both sides for narrowing, for example a human could both swim and fly (with the right equipment) and thus should show up in both sides of the in check:为了收窄可选属性，人类可以同时飞行和游泳（有正确的装备），因此应该在 in 检查的两侧显示。\ntype Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;\ntype Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;\ntype Human &#x3D; &#123; swim?: () &#x3D;&gt; void; fly?: () &#x3D;&gt; void &#125;;\n\nfunction move(animal: Fish | Bird | Human) &#123;\n  if (&quot;swim&quot; in animal) &#123;\n    animal;\n\n    &#x2F;&#x2F; (parameter) animal: Fish | Human\n  &#125; else &#123;\n    animal;\n\n    &#x2F;&#x2F; (parameter) animal: Bird | Human\n  &#125;\n&#125;\n\ninstanceof narrowinginstanceof缩减\nJavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript x instanceof Foo checks whether the prototype chain of x contains Foo.prototype. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with new. As you might have guessed, instanceof is also a type guard, and TypeScript narrows in branches guarded by instanceofs.JavaScript 有一个操作符用来检查一个值是否是另一个值的实例：in 操作符。更详细的说，在 JavaScript x instanceof Foo 检查 x 的原型链是否包含 Foo.prototype。但我们这里不会深入，当我们接触到类时，它们仍然可以用于构造函数。你可能会猜到，instanceof 是一个类型检查，而 TypeScript 收窄在 instanceof 检查的分支。\nfunction logValue(x: Date | string) &#123;\n  if (x instanceof Date) &#123;\n    console.log(x.toUTCString());\n\n    &#x2F;&#x2F; (parameter) x: Date\n  &#125; else &#123;\n    console.log(x.toUpperCase());\n\n    &#x2F;&#x2F; (parameter) x: string\n  &#125;\n&#125;\n\nAssignments赋值\nAs we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.我们前面提到过，当我们给任何变量赋值时，TypeScript 会检查赋值右侧并收窄左侧适当的类型。\nlet x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;\n\nlet x: string | number;\nx &#x3D; 1;\n\nconsole.log(x);\n\nlet x: number;\nx &#x3D; &quot;goodbye!&quot;;\n\nconsole.log(x);\n\nlet x: string;\n\nNotice that each of these assignments is valid. Even though the observed type of x changed to number after our first assignment, we were still able to assign a string to x. This is because the declared type of x - the type that x started with - is string | number, and assignability is always checked against the declared type.注意，每一个赋值都是有效的。即使 x 的发现类型改变为 number 之后，我们仍然能够给 x 赋值一个字符串。这是因为 x 的声明类型是 string | number，而赋值时是检查赋值类型是否可以赋值给它。If we’d assigned a boolean to x, we’d have seen an error since that wasn’t part of the declared type.\nlet x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;\n\nlet x: string | number;\nx &#x3D; 1;\n\nconsole.log(x);\n\nlet x: number;\nx &#x3D; true;\n&#x2F;&#x2F; Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.\n\nconsole.log(x);\n\nlet x: string | number;\n\nControl flow analysis控制流分析\nUp until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in ifs, whiles, conditionals, etc. For example在这个点之前，我们已经探索了一些基本的例子，如何收窄在特定分支中。但这里有一些比较复杂的事情，比如从每个变量上来看，如果有一个 if 语句，while 语句，条件表达式等，都可以看到收窄。例如\nfunction padLeft(padding: number | string, input: string) &#123;\n  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;\n    return &quot; &quot;.repeat(padding) + input;\n  &#125;\n  return padding + input;\n&#125;\n\npadLeft returns from within its first if block. TypeScript was able to analyze this code and see that the rest of the body (return padding + input;) is unreachable in the case where padding is a number. As a result, it was able to remove number from the type of padding (narrowing from string | number to string) for the rest of the function.padLeft 返回在它的第一个 if 块中。TypeScript 可以分析这段代码，并且发现 rest of the body (return padding + input;) 是不可达的，在 padding 是一个 number 的情况下。因此，它可以移除 padding 的声明类型（收窄从 string | number 到 string），从而移除了 padding 的类型。This analysis of code based on reachability is called control flow analysis, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.这段代码基于可达性的分析是控制流分析，TypeScript 使用这个分析来收窄类型，当遇到类型检查和赋值时。当一个变量被分析时，控制流可以分裂和重新合并，并且这个变量在每个点都会有不同的类型。\nfunction example() &#123;\n  let x: string | number | boolean;\n\n  x &#x3D; Math.random() &lt; 0.5;\n\n  console.log(x);\n\n  let x: boolean;\n\n  if (Math.random() &lt; 0.5) &#123;\n    x &#x3D; &quot;hello&quot;;\n    console.log(x);\n\n    let x: string;\n  &#125; else &#123;\n    x &#x3D; 100;\n    console.log(x);\n\n    let x: number;\n  &#125;\n\n  return x;\n\n  let x: string | number;\n&#125;\n\nUsing type predicates使用类型断言\nWe’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.我们已经使用了现有的 JavaScript 工具来处理收窄，但有时候你想更加直接控制类型在你的代码中的变化。To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:定义一个用户定义的类型断言，我们只需要定义一个返回类型为类型断言的函数：\nfunction isFish(pet: Fish | Bird): pet is Fish &#123;\n  return (pet as Fish).swim !&#x3D;&#x3D; undefined;\n&#125;\n\npet is Fish is our type predicate in this example. A predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.pet is Fish 是我们的类型断言。一个断言的格式是 parameterName is Type，其中 parameterName 必须是当前函数签名中的一个参数名。Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.任何时候，isFish 被调用，TypeScript 将会收窄这个变量的类型，如果原始类型是兼容的。\n&#x2F;&#x2F; Both calls to &#39;swim&#39; and &#39;fly&#39; are now okay.\nlet pet &#x3D; getSmallPet();\n\nif (isFish(pet)) &#123;\n  pet.swim();\n&#125; else &#123;\n  pet.fly();\n&#125;\n\nNotice that TypeScript not only knows that pet is a Fish in the if branch; it also knows that in the else branch, you don’t have a Fish, so you must have a Bird.TypeScript 知道 pet 是一个 Fish 在 if 分支；它也知道在 else 分支，你没有一个 Fish，所以你必须有一个 Bird。You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish:你可以使用 isFish 来过滤 Fish | Bird 数组，并获得一个 Fish 数组。\nconst zoo: (Fish | Bird)[] &#x3D; [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] &#x3D; zoo.filter(isFish);\n&#x2F;&#x2F; or, equivalently\nconst underWater2: Fish[] &#x3D; zoo.filter(isFish) as Fish[];\n\n&#x2F;&#x2F; The predicate may need repeating for more complex examples\nconst underWater3: Fish[] &#x3D; zoo.filter((pet): pet is Fish &#x3D;&gt; &#123;\n  if (pet.name &#x3D;&#x3D;&#x3D; &quot;sharkey&quot;) return false;\n  return isFish(pet);\n&#125;);\n\nIn addition, classes can use this is Type to narrow their type.We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.类可以使用 is Type 来收窄类型。我们已经使用了现有的 JavaScript 工具来处理收窄，但有时候你想更加直接控制类型在你的代码中的变化。To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:定义一个用户定义的类型断言，我们只需要定义一个返回类型为类型断言的函数：\nfunction isFish(pet: Fish | Bird): pet is Fish &#123;\n  return (pet as Fish).swim !&#x3D;&#x3D; undefined;\n&#125;\n\npet is Fish is our type predicate in this example. A predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.pet is Fish 是我们的类型断言。一个断言的格式是 parameterName is Type，其中 parameterName 必须是当前函数签名中的一个参数名。Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.任何时候，isFish 被调用，TypeScript 将会收窄这个变量的类型，如果原始类型是兼容的。\n&#x2F;&#x2F; Both calls to &#39;swim&#39; and &#39;fly&#39; are now okay.\nlet pet &#x3D; getSmallPet();\n\nif (isFish(pet)) &#123;\n  pet.swim();\n&#125; else &#123;\n  pet.fly();\n&#125;\n\nNotice that TypeScript not only knows that pet is a Fish in the if branch; it also knows that in the else branch, you don’t have a Fish, so you must have a Bird.TypeScript 知道 pet 是一个 Fish 在 if 分支；它也知道在 else 分支，你没有一个 Fish，所以你必须有一个 Bird。You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish:你可以使用 isFish 来过滤 Fish | Bird 数组，并获得一个 Fish 数组。\nconst zoo: (Fish | Bird)[] &#x3D; [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] &#x3D; zoo.filter(isFish);\n&#x2F;&#x2F; or, equivalently\nconst underWater2: Fish[] &#x3D; zoo.filter(isFish) as Fish[];\n\n&#x2F;&#x2F; The predicate may need repeating for more complex examples\nconst underWater3: Fish[] &#x3D; zoo.filter((pet): pet is Fish &#x3D;&gt; &#123;\n  if (pet.name &#x3D;&#x3D;&#x3D; &quot;sharkey&quot;) return false;\n  return isFish(pet);\n&#125;);\n\nIn addition, classes can use this is Type to narrow their type.除此之外，类中可以使用this is Type来缩减类型。\nDiscriminated unions分区联合\nMost of the examples we’ve looked at so far have focused around narrowing single variables with simple types like string, boolean, and number. While this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures.For some motivation, let’s imagine we’re trying to encode shapes like circles and squares.Circles keep track of their radiuses and squares keep track of their side lengths. We’ll use a field called kind to tell which shape we’re dealing with. Here’s a first attempt at defining Shape.让我们试想有这样一个处理 Shape （比如 Circles、Squares ）的函数，Circles 会记录它的半径属性，Squares 会记录它的边长属性，我们使用一个 kind 字段来区分判断处理的是 Circles 还是 Squares，这是初始的 Shape 定义：\ninterface Shape &#123;\n  kind: &quot;circle&quot; | &quot;square&quot;;\n  radius?: number;\n  sideLength?: number;\n&#125;\n\nNotice we’re using a union of string literal types: “circle” and “square” to tell us whether we should treat the shape as a circle or square respectively. By using “circle” | “square” instead of string, we can avoid misspelling issues.我们使用一个字符串字面量类型的联合：&quot;circle&quot; 和 &quot;square&quot;，来告诉我们是处理一个圆形还是一个正方形。\nfunction handleShape(shape: Shape) &#123;\n  &#x2F;&#x2F; oops!\n  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;rect&quot;) &#123;\n    &#x2F;&#x2F; This condition will always return &#39;false&#39; since the types &#39;&quot;circle&quot; | &quot;square&quot;&#39; and &#39;&quot;rect&quot;&#39; have no overlap.\n    &#x2F;&#x2F; 此条件将总是返回 &#39;false&#39;，因为类型 &#39;&quot;circle&quot; | &quot;square&quot;&#39; 和 &#39;&quot;rect&quot;&#39; 没有重叠。\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\nWe can write a getArea function that applies the right logic based on if it’s dealing with a circle or square. We’ll first try dealing with circles.我们可以写一个 getArea 函数，用来处理圆形。\nfunction getArea(shape: Shape) &#123;\n  return Math.PI * shape.radius ** 2;\n  &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.\n&#125;\n\nUnder strictNullChecks that gives us an error - which is appropriate since radius might not be defined. But what if we perform the appropriate checks on the kind property?在严格的 null 检查下，我们会得到一个错误 - 因为 radius 可能不存在。但是如果我们对 kind 属性进行正确的检查，就不会出现错误。\nfunction getArea(shape: Shape) &#123;\n  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;\n    return Math.PI * shape.radius ** 2;\n    &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.\n  &#125;\n&#125;\n\nHmm, TypeScript still doesn’t know what to do here. We’ve hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a ! after shape.radius) to say that radius is definitely present.哇，TypeScript 还不知道怎么办。我们已经碰到了一个点，我们知道更多的信息了，比类型检查器更多。我们可以尝试使用一个非空断言（shape.radius 后面加一个 !）来告诉 TypeScript radius 是一定存在的。\nfunction getArea(shape: Shape) &#123;\n  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;\n    return Math.PI * shape.radius! ** 2;\n  &#125;\n&#125;\n\nBut this doesn’t feel ideal. We had to shout a bit at the type-checker with those non-null assertions (!) to convince it that shape.radius was defined, but those assertions are error-prone if we start to move code around. Additionally, outside of strictNullChecks we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them). We can definitely do better.但这不太好。我们必须向类型检查器发出一些非空断言（!）来告诉它 shape.radius 存在，但这些断言是错误的，如果我们开始移动代码。同时，在非严格的 null 检查下，我们还是可以随意访问这些字段（因为可选属性是被假定为总是存在的，当读取它们时）。我们可以很好地做。The problem with this encoding of Shape is that the type-checker doesn’t have any way to know whether or not radius or sideLength are present based on the kind property. We need to communicate what we know to the type checker. With that in mind, let’s take another swing at defining Shape.这个 Shape 的编码有点问题，因为类型检查器没有任何方式可以告诉我们 radius 或 sideLength 存在。我们需要向类型检查器通报我们知道的信息。\ninterface Circle &#123;\n  kind: &quot;circle&quot;;\n  radius: number;\n&#125;\n\ninterface Square &#123;\n  kind: &quot;square&quot;;\n  sideLength: number;\n&#125;\n\ntype Shape &#x3D; Circle | Square;\n\nHere, we’ve properly separated Shape out into two types with different values for the kind property, but radius and sideLength are declared as required properties in their respective types.这里，我们已经将 Shape 分成了两种类型，其中 kind 属性的值不同，radius 和 sideLength 在它们的类型中声明为必须的属性。Let’s see what happens here when we try to access the radius of a Shape.我们看看这里如何访问 Shape 的 radius。\nfunction getArea(shape: Shape) &#123;\n  return Math.PI * shape.radius ** 2;\n  &#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Shape&#39;.\n  &#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Square&#39;.\n&#125;\n\nLike with our first definition of Shape, this is still an error. When radius was optional, we got an error (with strictNullChecks enabled) because TypeScript couldn’t tell whether the property was present. Now that Shape is a union, TypeScript is telling us that shape might be a Square, and Squares don’t have radius defined on them! Both interpretations are correct, but only the union encoding of Shape will cause an error regardless of how strictNullChecks is configured.与我们第一次定义 Shape 的例子相同，这还是一个错误。当 radius 是可选的时，我们得到一个错误（与 strictNullChecks 启用时），因为 TypeScript 不能告诉我们这个属性是否存在。But what if we tried checking the kind property again?如果我们再次检查 kind 属性？\nfunction getArea(shape: Shape) &#123;\n  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;\n    return Math.PI * shape.radius ** 2;\n    &#x2F;&#x2F; (parameter) shape: Circle\n  &#125;\n&#125;\n\nThat got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a discriminated union, and can narrow out the members of the union.这消除了错误！当一个联合里的每个类型都包含常量类型的共同属性，TypeScript 认为这是一个分区联合，可以缩小联合的成员。In this case, kind was that common property (which is what’s considered a discriminant property of Shape). Checking whether the kind property was “circle” got rid of every type in Shape that didn’t have a kind property with the type “circle”. That narrowed shape down to the type Circle.在这种情况下，kind 属性是那个被认为是 Shape 的分区属性（这是被认为是 Shape 的分区属性）。检查 kind 属性是否是 &quot;circle&quot; 可以消除掉没有 kind 属性的类型。这缩小了 shape 到 Circle 类型。The same checking works with switch statements as well. Now we can try to write our complete getArea without any pesky ! non-null assertions.在这里，我们可以尝试写我们的完整 getArea 没有任何非空断言！\nfunction getArea(shape: Shape) &#123;\n  switch (shape.kind) &#123;\n    case &quot;circle&quot;:\n      return Math.PI * shape.radius ** 2;\n\n    &#x2F;&#x2F; (parameter) shape: Circle\n    case &quot;square&quot;:\n      return shape.sideLength ** 2;\n\n    &#x2F;&#x2F; (parameter) shape: Square\n  &#125;\n&#125;\n\nThe important thing here was the encoding of Shape. Communicating the right information to TypeScript - that Circle and Square were really two separate types with specific kind fields - was crucial. Doing that let us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise. From there, the type system was able to do the “right” thing and figure out the types in each branch of our switch statement.这里有重要的事情，需要通过编码 Shape 来告诉 TypeScript，Circle 和 Square 是真正的两个类型，具有特定的 kind 属性。这样就可以写出类型安全的 TypeScript 代码，看起来和 JavaScript 一样。As an aside, try playing around with the above example and remove some of the return keywords. You’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a switch statement.作为一个例子，试着玩一下上面的例子，并删除一些 return 关键字。你会发现，类型检查可以帮助避免在意外的情况下跳过不同的分支。Discriminated unions are useful for more than just talking about circles and squares. They’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client&#x2F;server communication), or encoding mutations in a state management framework.分区联合是用来表示任何类型的消息协议，比如在网络上发送消息（客户端/服务器通信），或者编码状态管理框架的变化。\nThe never typenever类型\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldn’t exist.在缩小联合的时候，你可以将联合的可能性降低到没有任何可能性的状态。在这种情况下，TypeScript 会使用 never 类型来表示不应该存在的状态。\nExhaustiveness checking推断性检查\nThe never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement.never类型可以赋值给所有类型，但是不可以赋值给 never（除了 never 本身）。这意味着你可以使用缩小，并且可以在 switch 语句中使用推断性检查。For example, adding a default to our getArea function which tries to assign the shape to never will raise when every possible case has not been handled.添加一个默认到 getArea 函数中，这样就会抛出异常，因为没有处理所有可能性。\ntype Shape &#x3D; Circle | Square;\n\nfunction getArea(shape: Shape) &#123;\n  switch (shape.kind) &#123;\n    case &quot;circle&quot;:\n      return Math.PI * shape.radius ** 2;\n    case &quot;square&quot;:\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never &#x3D; shape;\n      return _exhaustiveCheck;\n  &#125;\n&#125;\n\nAdding a new member to the Shape union, will cause a TypeScript error:添加一个新的成员到 Shape 联合，会导致一个 TypeScript 错误：\ninterface Triangle &#123;\n  kind: &quot;triangle&quot;;\n  sideLength: number;\n&#125;\n\ntype Shape &#x3D; Circle | Square | Triangle;\n\nfunction getArea(shape: Shape) &#123;\n  switch (shape.kind) &#123;\n    case &quot;circle&quot;:\n      return Math.PI * shape.radius ** 2;\n    case &quot;square&quot;:\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never &#x3D; shape;\n      &#x2F;&#x2F; Type &#39;Triangle&#39; is not assignable to type &#39;never&#39;.\n      &#x2F;&#x2F; 类型 &#39;Triangle&#39; 不能赋值给类型 &#39;never&#39;。\n      return _exhaustiveCheck;\n  &#125;\n&#125;\n\n因为 TypeScript 的收窄特性，执行到 default 的时候，类型被收窄为 Triangle，但因为任何类型都不能赋值给 never 类型，这就会产生一个编译错误。通过这种方式，你就可以确保 getArea 函数总是穷尽了所有 shape 的可能性。\n","slug":"2022-06-08ts-norrowing","date":"2022-06-07T01:21:19.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"746ca231a136437ea4011b4445608ad1","title":"3.Typescript 常见类型","content":"Everyday Types常见类型In this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isn’t an exhaustive list, and future chapters will describe more ways to name and use other types.在这一章中，我们将探讨一些 JavaScript 代码中的常见类型，并在 TypeScript 中说明这些类型的相应方式。这并不是一个完整的列表，而且未来的章节将说明更多的方法来命名和使用其他类型。Types can also appear in many more places than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.类型也可以出现在类型注释之外。我们学习类型本身时，我们也会学习到哪些地方可以引用这些类型来形成新的构造。We’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.我们将开始介绍最基本的 JavaScript 或 TypeScript 代码中可能遇到的常见类型。这些类型将作为更复杂的类型的基础建筑块。\nThe primitives: string,number, and booleanJavaScript has three very commonly used primitives: string, number, and boolean. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript typeof operator on a value of those types:JavaScript 有三个非常常见的原始类型：字符串，数字和布尔值。这三个类型在 TypeScript 中对应。如果你可以接受，这三个类型的名字都是相同的：\n\nstring represents string values like “Hello, world”string 表示字符串，比如 &quot;Hello, world&quot;\nnumber is for numbers like 42. JavaScript does not have a special runtime value for integers, so there’s no equivalent to int or float - everything is simply numbernumber 是数字，比如 42。JavaScript 不支持整数，所以没有相应的 int 或 float - 所有都是 number\nboolean is for the two values true and falseboolean 是布尔值，比如 true 和 false\n\n\n\n\n\n\n\n\nWARNING\nThe type names String, Number, and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string, number, or boolean for types.类型名 String ，Number 和 Boolean （首字母大写）也是合法的，但它们是一些非常少见的特殊内置类型。所以类型总是使用 string ，number 或者 boolean 。\n\nArrays数组To specify the type of an array like [1, 2, 3], you can use the syntax number[]; this syntax works for any type (e.g. string[] is an array of strings, and so on). You may also see this written as Array, which means the same thing. We’ll learn more about the syntax T when we cover generics.指定数组的类型，可以使用 number[] 的语法，这种语法可以用于任何类型（比如 string[] 是一个字符串数组，而 so on）。你也可以看到这种写法 Array&lt;number&gt;，它表示相同的意思。我们将在接下来的章节中学习更多关于语法 T&lt;U&gt; 的详细信息。:::warningNote that [number] is a different thing; refer to the section on Tuples.[number] 不是同一个东西，请参见关于元组的章节。:::\nanyTypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.TypeScript 也有一个特殊的类型 any，可以用于指定你不想要某个值导致类型检查错误的情况。When a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:当值是 any 类型时，你可以访问它的任何属性（这将导致它的类型为 any ），调用它，将它赋值给（或从）任何类型的值，或者其他任何合法的语法：\nlet obj: any &#x3D; &#123; x: 0 &#125;;\n&#x2F;&#x2F; None of the following lines of code will throw compiler errors.\n&#x2F;&#x2F; 以下代码行都不会引发编译器错误。\n&#x2F;&#x2F; Using &#96;any&#96; disables all further type checking, and it is assumed\n&#x2F;&#x2F; 使用“any”将禁用所有进一步的类型检查，并且假定\n&#x2F;&#x2F; you know the environment better than TypeScript.\n&#x2F;&#x2F; 你知道环境优于TypeScript。\nobj.foo();\nobj();\nobj.bar &#x3D; 100;\nobj &#x3D; &quot;hello&quot;;\nconst n: number &#x3D; obj;\n\nThe any type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.any 类型是用于指定你不想要写出一个长的类型来说明 TypeScript 对某一行代码是合法的。\nnoImplicitAnyWhen you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any.当你不指定类型，并且 TypeScript 不能从上下文中推断出来时，编译器默认使用 any。You usually want to avoid this, though, because any isn’t type-checked. Use the compiler flag noImplicitAny to flag any implicit any as an error.你通常想避免这种情况，但是 any 不会被类型检查。使用编译器标记 noImplicitAny 来标记 any 为错误。\nType Annotations on Variables变量上的类型注解\nWhen you declare a variable using const, var, or let, you can optionally add a type annotation to explicitly specify the type of the variable:使用 const ，var 或 let 声明变量时，可以添加一个类型注解来显式指定变量的类型：\nlet myName: string &#x3D; &quot;Alice&quot;;\n\nTypeScript doesn’t use “types on the left”-style declarations like int x &#x3D; 0; Type annotations will always go after the thing being typed.TypeScript 不使用“左边的类型”的声明方式，如 int x = 0; 类型注解将总是在被类型的东西后面。In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically infer the types in your code. For example, the type of a variable is inferred based on the type of its initializer:在大多数情况下，不需要这样做。在每个变量的初始值的类型可以被自动推断出来。\n&#x2F;&#x2F; No type annotation needed -- &#39;myName&#39; inferred as type &#39;string&#39;\n&#x2F;&#x2F; 没有类型注解需要 -- &#39;myName&#39; 类型被推断为 &#39;string&#39;\nlet myName &#x3D; &quot;Alice&quot;;\n\nFor the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.大多数情况下，你不需要显式地指定类型注解。如果你是新手，尝试使用比你认为更少的类型注解，你可能会意外地发现 TypeScript 可以完全理解你的代码。\nFunctions函数\nFunctions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.函数是 JavaScript 中传递数据的主要方式。TypeScript 允许你指定函数的输入和输出值的类型。\nParameter Type Annotations参数上的类型注解\nWhen you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:声明函数时，可以在每个参数后面添加类型注解来声明函数接受哪些类型的参数。参数类型注解在参数名后面：\n&#x2F;&#x2F; Parameter type annotation\nfunction greet(name: string) &#123;\n  console.log(&quot;Hello, &quot; + name.toUpperCase() + &quot;!!&quot;);\n&#125;\n\nWhen a parameter has a type annotation, arguments to that function will be checked:当参数有类型注解时，函数的参数会被检查：\n&#x2F;&#x2F; Would be a runtime error if executed!\n&#x2F;&#x2F; 如果执行，就会产生一个运行时错误！\ngreet(42);\n&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.\n&#x2F;&#x2F; 参数类型 &#39;number&#39; 不能赋值给参数类型 &#39;string&#39;。\n\nEven if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.即使你没有类型注解，TypeScript 也会检查你传入的参数是否正确。\nReturn Type Annotations返回值上的类型注解\nYou can also add return type annotations. Return type annotations appear after the parameter list:你也可以添加返回值类型注解。返回值类型注解出现在参数列表后面：\nfunction getFavoriteNumber(): number &#123;\n  return 26;\n&#125;\n\nMuch like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its return statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.和变量类型注解一样，你通常不需要返回值类型注解，因为 TypeScript 将基于返回语句的类型推断出来。上面的示例示例不会改变任何东西。一些代码库将显式指定一个返回值类型，以防止意外的改变，或者只是为了个人偏好。\nAnonymous Functions匿名函数\nAnonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.匿名函数和函数声明一样。当函数出现在 TypeScript 可以确定它会如何被调用时，函数的参数会被自动指定类型。Here’s an example:这里有一个示例：\n&#x2F;&#x2F; No type annotations here, but TypeScript can spot the bug\n&#x2F;&#x2F; 没有类型注解，但 TypeScript 可以检测到错误\nconst names &#x3D; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;];\n\n&#x2F;&#x2F; Contextual typing for function\n&#x2F;&#x2F; 函数上下文类型\nnames.forEach(function (s) &#123;\n  console.log(s.toUppercase());\n  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?\n  &#x2F;&#x2F; 属性 &#39;toUppercase&#39; 不存在于类型 &#39;string&#39; 中。你可能想用 &#39;toUpperCase&#39; 吗？\n&#125;);\n\n&#x2F;&#x2F; Contextual typing also applies to arrow functions\n&#x2F;&#x2F; 箭头函数上下文类型\nnames.forEach((s) &#x3D;&gt; &#123;\n  console.log(s.toUppercase());\n  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?\n  &#x2F;&#x2F; 属性 &#39;toUppercase&#39; 不存在于类型 &#39;string&#39; 中。你可能想用 &#39;toUpperCase&#39; 吗？\n&#125;);\n\nEven though the parameter s didn’t have a type annotation, TypeScript used the types of the forEach function, along with the inferred type of the array, to determine the type s will have.即使参数 s 没有类型注解，TypeScript 会使用 forEach 函数的类型，以及推断的数组类型，来确定 s 的类型。This process is called contextual typing because the context that the function occurred within informs what type it should have.这个过程是上下文类型的，因为函数发生在哪里的上下文，就会确定它应该有哪种类型。Similar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it does happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.与推断规则相似，你不需要显式学习这种过程，但是了解这种过程可以帮助你发现，当值不需要类型注解时，它会发生什么。之后，我们会看到更多的例子，如何值的上下文可以影响它的类型。\nObject Types对象类型\nApart from primitives, the most common sort of type you’ll encounter is an object type. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.除了原始类型，最常见的类型是对象类型。这指的是任何 JavaScript 值，它的属性都是很多的！为了定义对象类型，我们只需要列出它的属性和它们的类型。For example, here’s a function that takes a point-like object:这里有一个接受点类型对象的函数：\n&#x2F;&#x2F; The parameter&#39;s type annotation is an object type\nfunction printCoord(pt: &#123; x: number; y: number &#125;) &#123;\n  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);\n  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);\n&#125;\nprintCoord(&#123; x: 3, y: 7 &#125;);\n\nHere, we annotated the parameter with a type with two properties - x and y - which are both of type number. You can use , or ; to separate the properties, and the last separator is optional either way.这里，我们使用了一个有两个属性的类型，x 和 y，它们都是 number 类型。你可以使用 , 或 ; 分隔属性，最后的分隔符可以是任意的。The type part of each property is also optional. If you don’t specify a type, it will be assumed to be any.每个属性的类型部分都是可选的。如果你没有指定类型，它会被认为是 any 类型。\nOptional Properties可选属性\nObject types can also specify that some or all of their properties are optional. To do this, add a ? after the property name:对象类型可以指定一些或全部的属性是可选的。要做到这一点，只需要在属性名后面加上 ? 就可以了。\nfunction printName(obj: &#123; first: string; last?: string &#125;) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F; Both OK\nprintName(&#123; first: &quot;Bob&quot; &#125;);\nprintName(&#123; first: &quot;Alice&quot;, last: &quot;Alisson&quot; &#125;);\n\nIn JavaScript, if you access a property that doesn’t exist, you’ll get the value undefined rather than a runtime error. Because of this, when you read from an optional property, you’ll have to check for undefined before using it.\nfunction printName(obj: &#123; first: string; last?: string &#125;) &#123;\n  &#x2F;&#x2F; Error - might crash if &#39;obj.last&#39; wasn&#39;t provided!\n  console.log(obj.last.toUpperCase());\nObject is possibly &#39;undefined&#39;.\n  if (obj.last !&#x3D;&#x3D; undefined) &#123;\n    &#x2F;&#x2F; OK\n    console.log(obj.last.toUpperCase());\n  &#125;\n\n  &#x2F;&#x2F; A safe alternative using modern JavaScript syntax:\n  console.log(obj.last?.toUpperCase());\n&#125;\n\nUnion Types联合类型\nTypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start combining them in interesting ways.\nDefining a Union Type定义一个联合类型\nThe first way to combine types you might see is a union type. A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union’s members.\nLet’s write a function that can operate on strings or numbers:\nfunction printId(id: number | string) &#123;\n  console.log(&quot;Your ID is: &quot; + id);\n&#125;\n&#x2F;&#x2F; OK\nprintId(101);\n&#x2F;&#x2F; OK\nprintId(&quot;202&quot;);\n&#x2F;&#x2F; Error\nprintId(&#123; myID: 22342 &#125;);\n&#x2F;&#x2F; Argument of type &#39;&#123; myID: number; &#125;&#39; is not assignable to parameter of type &#39;string | number&#39;.\n\nWorking with Union Types使用联合类型\nIt’s easy to provide a value matching a union type - simply provide a type matching any of the union’s members. If you have a value of a union type, how do you work with it?\nTypeScript will only allow an operation if it is valid for every member of the union. For example, if you have the union string | number, you can’t use methods that are only available on string:\nfunction printId(id: number | string) &#123;\n  console.log(id.toUpperCase());\nProperty &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.\n  Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.\n&#125;\n\nThe solution is to narrow the union with code, the same as you would in JavaScript without type annotations. Narrowing occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.\nFor example, TypeScript knows that only a string value will have a typeof value “string”:\nfunction printId(id: number | string) &#123;\n  if (typeof id &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    &#x2F;&#x2F; In this branch, id is of type &#39;string&#39;\n    console.log(id.toUpperCase());\n  &#125; else &#123;\n    &#x2F;&#x2F; Here, id is of type &#39;number&#39;\n    console.log(id);\n  &#125;\n&#125;\n\nAnother example is to use a function like Array.isArray:\nfunction welcomePeople(x: string[] | string) &#123;\n  if (Array.isArray(x)) &#123;\n    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string[]&#39;\n    console.log(&quot;Hello, &quot; + x.join(&quot; and &quot;));\n  &#125; else &#123;\n    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string&#39;\n    console.log(&quot;Welcome lone traveler &quot; + x);\n  &#125;\n&#125;\n\nNotice that in the else branch, we don’t need to do anything special - if x wasn’t a string[], then it must have been a string.\nSometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a slice method. If every member in a union has a property in common, you can use that property without narrowing:\n&#x2F;&#x2F; Return type is inferred as number[] | string\nfunction getFirstThree(x: number[] | string) &#123;\n  return x.slice(0, 3);\n&#125;\n\nIt might be confusing that a union of types appears to have the intersection of those types’ properties. This is not an accident - the name union comes from type theory. The union number | string is composed by taking the union of the values from each type. Notice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about every person is that they must be wearing a hat.\nType Aliases类型别名\nWe’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.\nA type alias is exactly that - a name for any type. The syntax for a type alias is:\ntype Point &#x3D; &#123;\n  x: number;\n  y: number;\n&#125;;\n\n&#x2F;&#x2F; Exactly the same as the earlier example\nfunction printCoord(pt: Point) &#123;\n  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);\n  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);\n&#125;\n\nprintCoord(&#123; x: 100, y: 100 &#125;);\n\nYou can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:\ntype ID &#x3D; number | string;\n\nNote that aliases are only aliases - you cannot use type aliases to create different&#x2F;distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type:\ntype UserInputSanitizedString &#x3D; string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString &#123;\n  return sanitize(str);\n&#125;\n\n&#x2F;&#x2F; Create a sanitized input\nlet userInput &#x3D; sanitizeInput(getInput());\n\n&#x2F;&#x2F; Can still be re-assigned with a string though\nuserInput &#x3D; &quot;new input&quot;;\n\nInterfaces接口\nAn interface declaration is another way to name an object type:\ninterface Point &#123;\n  x: number;\n  y: number;\n&#125;\n\nfunction printCoord(pt: Point) &#123;\n  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);\n  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);\n&#125;\n\nprintCoord(&#123; x: 100, y: 100 &#125;);\n\nJust like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the structure of the value we passed to printCoord - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a structurally typed type system.\nDifferences Between Type Aliases and Interfaces类型别名和接口的区别\nType aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\nInterface\n&#x2F;&#x2F; Extending an interface\n\ninterface Animal &#123;\n  name: string;\n&#125;\n\ninterface Bear extends Animal &#123;\n  honey: boolean;\n&#125;\n\nconst bear &#x3D; getBear();\nbear.name;\nbear.honey;\n\nType\n&#x2F;&#x2F; Extending a type via intersections\n\ntype Animal &#x3D; &#123;\n  name: string;\n&#125;;\n\ntype Bear &#x3D; Animal &amp; &#123;\n  honey: boolean;\n&#125;;\n\nconst bear &#x3D; getBear();\nbear.name;\nbear.honey;\n\nAdding new fields to an existing interface\ninterface Window &#123;\n  title: string;\n&#125;\n\ninterface Window &#123;\n  ts: TypeScriptAPI;\n&#125;\n\nconst src &#x3D; &#39;const a &#x3D; &quot;Hello World&quot;&#39;;\nwindow.ts.transpileModule(src, &#123;&#125;);\n\nA type cannot be changed after being created\ntype Window &#x3D; &#123;\n  title: string;\n&#125;;\n\ntype Window &#x3D; &#123;\n  ts: TypeScriptAPI;\n&#125;;\n\n&#x2F;&#x2F; Error: Duplicate identifier &#39;Window&#39;.\n\nYou’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.\n\nPrior to TypeScript version 4.2, type alias names may appear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.\nType aliases may not participate in declaration merging, but interfaces can.\nInterfaces may only be used to declare the shapes of objects, not rename primitives.\nInterface names will always appear in their original form in error messages, but only when they are used by name.\n\nFor the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use interface until you need to use features from type.\nType Assertions类型断言\nSometimes you will have information about the type of a value that TypeScript can’t know about.\nFor example, if you’re using document.getElementById, TypeScript only knows that this will return some kind of HTMLElement, but you might know that your page will always have an HTMLCanvasElement with a given ID.\nIn this situation, you can use a type assertion to specify a more specific type:\nconst myCanvas &#x3D; document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;\n\nLike a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.\nYou can also use the angle-bracket syntax (except if the code is in a .tsx file), which is equivalent:\nconst myCanvas &#x3D; &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;);\n\nReminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There won’t be an exception or null generated if the type assertion is wrong.\nTypeScript only allows type assertions which convert to a more specific or less specific version of a type. This rule prevents “impossible” coercions like:\nconst x &#x3D; &quot;hello&quot; as number;\n&#x2F;&#x2F; Conversion of type &#39;string&#39; to type &#39;number&#39; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#39;unknown&#39; first.\n\nSometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to any (or unknown, which we’ll introduce later), then to the desired type:\nconst a &#x3D; expr as any as T;\n\nLiteral Types字面量类型\nIn addition to the general types string and number, we can refer to specific strings and numbers in type positions.\nOne way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both var and let allow for changing what is held inside the variable, and const does not. This is reflected in how TypeScript creates types for literals.\nlet changingString &#x3D; &quot;Hello World&quot;;\nchangingString &#x3D; &quot;Olá Mundo&quot;;\n&#x2F;&#x2F; Because &#96;changingString&#96; can represent any possible string, that\n&#x2F;&#x2F; is how TypeScript describes it in the type system\nchangingString;\n\nlet changingString: string;\n\nconst constantString &#x3D; &quot;Hello World&quot;;\n&#x2F;&#x2F; Because &#96;constantString&#96; can only represent 1 possible string, it\n&#x2F;&#x2F; has a literal type representation\nconstantString;\n\nconst constantString: &quot;Hello World&quot;;\n\nBy themselves, literal types aren’t very valuable:\nlet x: &quot;hello&quot; &#x3D; &quot;hello&quot;;\n&#x2F;&#x2F; OK\nx &#x3D; &quot;hello&quot;;\n&#x2F;&#x2F; ...\nx &#x3D; &quot;howdy&quot;;\n&#x2F;&#x2F; Type &#39;&quot;howdy&quot;&#39; is not assignable to type &#39;&quot;hello&quot;&#39;.\n\nIt’s not much use to have a variable that can only have one value!\nBut by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:\nfunction printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) &#123;\n  &#x2F;&#x2F; ...\n&#125;\nprintText(&quot;Hello, world&quot;, &quot;left&quot;);\nprintText(&quot;G&#39;day, mate&quot;, &quot;centre&quot;);\nArgument of type &#39;&quot;centre&quot;&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot; | &quot;center&quot;&#39;.\n\nNumeric literal types work the same way:\nfunction compare(a: string, b: string): -1 | 0 | 1 &#123;\n  return a &#x3D;&#x3D;&#x3D; b ? 0 : a &gt; b ? 1 : -1;\n&#125;\n\nOf course, you can combine these with non-literal types:\ninterface Options &#123;\n  width: number;\n&#125;\nfunction configure(x: Options | &quot;auto&quot;) &#123;\n  &#x2F;&#x2F; ...\n&#125;\nconfigure(&#123; width: 100 &#125;);\nconfigure(&quot;auto&quot;);\nconfigure(&quot;automatic&quot;);\nArgument of type &#39;&quot;automatic&quot;&#39; is not assignable to parameter of type &#39;Options | &quot;auto&quot;&#39;.\n\nThere’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types true and false. The type boolean itself is actually just an alias for the union true | false.\nLiteral Inference字面量推断When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:\nconst obj &#x3D; &#123; counter: 0 &#125;;\nif (someCondition) &#123;\n  obj.counter &#x3D; 1;\n&#125;\n\nTypeScript doesn’t assume the assignment of 1 to a field which previously had 0 is an error. Another way of saying this is that obj.counter must have the type number, not 0, because types are used to determine both reading and writing behavior.\nThe same applies to strings:\nconst req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125;;\nhandleRequest(req.url, req.method);\nArgument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;GET&quot; | &quot;POST&quot;&#39;.\n\nIn the above example req.method is inferred to be string, not “GET”. Because code can be evaluated between the creation of req and the call of handleRequest which could assign a new string like “GUESS” to req.method, TypeScript considers this code to have an error.\nThere are two ways to work around this.\nYou can change the inference by adding a type assertion in either location:\n&#x2F;&#x2F; Change 1:\nconst req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; &#125;;\n&#x2F;&#x2F; Change 2\nhandleRequest(req.url, req.method as &quot;GET&quot;);\n\nChange 1 means “I intend for req.method to always have the literal type “GET””, preventing the possible assignment of “GUESS” to that field after. Change 2 means “I know for other reasons that req.method has the value “GET”“.\nYou can use as const to convert the entire object to be type literals:\nconst req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125; as const;\nhandleRequest(req.url, req.method);\n\nThe as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number.\nnull and undefinednull和undefined\nJavaScript has two primitive values used to signal absent or uninitialized value: null and undefined.\nTypeScript has two corresponding types by the same names. How these types behave depends on whether you have the strictNullChecks option on.\nstrictNullChecks offstrictNullChecks关闭\nWith strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn strictNullChecks on if it’s practical to do so in their codebase.\nstrictNullChecks onstrictNullChecks开启\nWith strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value. Just like checking for undefined before using an optional property, we can use narrowing to check for values that might be null:\nfunction doSomething(x: string | null) &#123;\n  if (x &#x3D;&#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; do nothing\n  &#125; else &#123;\n    console.log(&quot;Hello, &quot; + x.toUpperCase());\n  &#125;\n&#125;\n\nNon-null Assertion Operator (Postfix !)非空断言运算符\nTypeScript also has a special syntax for removing null and undefined from a type without doing any explicit checking. Writing ! after any expression is effectively a type assertion that the value isn’t null or undefined:\nfunction liveDangerously(x?: number | null) &#123;\n  &#x2F;&#x2F; No error\n  console.log(x!.toFixed());\n&#125;\n\nJust like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use ! when you know that the value can’t be null or undefined.\nEnums枚举\nEnums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the Enum reference page.\nLess Common Primitives更少常见的原始类型It’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.\nbigintFrom ES2020 onwards, there is a primitive in JavaScript used for very large integers, BigInt:\n&#x2F;&#x2F; Creating a bigint via the BigInt function\nconst oneHundred: bigint &#x3D; BigInt(100);\n\n&#x2F;&#x2F; Creating a BigInt via the literal syntax\nconst anotherHundred: bigint &#x3D; 100n;\n\nYou can learn more about BigInt in the TypeScript 3.2 release notes.\nsymbolThere is a primitive in JavaScript used to create a globally unique reference via the function Symbol():\nconst firstName &#x3D; Symbol(&quot;name&quot;);\nconst secondName &#x3D; Symbol(&quot;name&quot;);\n\nif (firstName &#x3D;&#x3D;&#x3D; secondName) &#123;\nThis condition will always return &#39;false&#39; since the types &#39;typeof firstName&#39; and &#39;typeof secondName&#39; have no overlap.\n  &#x2F;&#x2F; Can&#39;t ever happen\n&#125;\n\nYou can learn more about them in Symbols reference page.\n参考链接Typescript 常见类型\n","slug":"2022-06-08ts-Everyday Types","date":"2022-06-06T08:40:41.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"3d6d9d5bd9a34b12b2d2da5941501c4f","title":"2.Typescript 基础","content":"The BasicsWelcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the ‘Getting Started’ guides欢迎来到 TypeScript 手册的第一页。如果您是第一次使用 TypeScript - 您可能想要开始一个&#39;Getting Started&#39;指南\nEach and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named message.每个和所有的值在 JavaScript 中都有一组行为可以观察从运行不同的操作。这会感觉很抽象，但是作为一个快速的例子，考虑一些我们可能运行的操作的变量名称 message。\n&#x2F;&#x2F; Accessing the property &#39;toLowerCase&#39;\n&#x2F;&#x2F; on &#39;message&#39; and then calling it\nmessage.toLowerCase();\n&#x2F;&#x2F; Calling &#39;message&#39;\nmessage();\n\nIf we break this down, the first runnable line of code accesses a property called toLowerCase and then calls it. The second one tries to call message directly.如果 我们将这个分解，第一个可运行的行代码访问一个属性叫做 toLowerCase 并且调用它。第二个尝试直接调用 message。But assuming we don’t know the value of message - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place.但是假设我们不知道 message 的值 - 并且这是很常见的 - 我们不可以可靠地说什么结果我们会得到运行这些代码。每个操作的行为取决于我们本身的值。\n\nIs message callable? message 是可调用的吗？\nDoes it have a property called toLowerCase on it? message 有一个属性叫做 toLowerCase 吗？\nIf it does, is toLowerCase even callable? 如果是，是否 toLowerCase 可调用？\nIf both of these values are callable, what do they return? 如果这两个值都是可调用的，它们会返回什么？\n\nThe answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.这些问题的答案通常是我们在写 JavaScript 时保留在我们的脑中，并且我们必须希望我们拿到所有的细节正确。Let’s say message was defined in the following way.让我们假设 message 被定义为以下的方式。\nconst message &#x3D; &quot;Hello World!&quot;;\n\nAs you can probably guess, if we try to run message.toLowerCase(), we’ll get the same string only in lower-case.如果我们试着运行 message.toLowerCase()，我们会得到一个只有小写字母的字符串。What about that second line of code? If you’re familiar with JavaScript, you’ll know this fails with an exception:如果您熟悉 JavaScript，您会知道这个失败了一个异常：\n&#x2F;&#x2F; TypeError: message is not a function\n\nIt’d be great if we could avoid mistakes like this.我们应该能避免这样的错误。When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts of behaviors and capabilities it has. That’s part of what that TypeError is alluding to - it’s saying that the string “Hello World!” cannot be called as a function.当我们运行我们的代码，我们的 JavaScript 运行时通过分析值的类型来决定如何做。这是它引用的 TypeError 的一部分 - 它说明 &quot;Hello World!&quot; 不能被调用作为函数。For some values, such as the primitives string and number, we can identify their type at runtime using the typeof operator. But for other things like functions, there’s no corresponding runtime mechanism to identify their types. For example, consider this function:对于某些值，如字符串和数字，我们可以在运行时通过 typeof 操作符来识别它的类型。但是对于其他的东西，没有相应的运行时机制来识别它们的类型。例如，让我们来看这个函数：\nfunction fn(x) &#123;\n  return x.flip();\n&#125;\n\nWe can observe by reading the code that this function will only work if given an object with a callable flip property, but JavaScript doesn’t surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what fn does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it.我们可以通过阅读代码, 看到这个函数只有在给定一个可调用 flip 属性的对象时才能工作，但 JavaScript 没有一种方式可以在运行代码时来识别 fn 的行为。只有在调用它时才能知道 fn 的行为，这种行为难以预测，这意味着在写代码时难以知道你的代码会做什么。Seen in this way, a type is the concept of describing which values can be passed to fn and which will crash. JavaScript only truly provides dynamic typing - running the code to see what happens.在这种方式中，一个类型是描述哪些值可以传给 fn，哪些会崩溃的概念。JavaScript 只是提供了动态类型定义 - 运行代码来看看会发生什么。The alternative is to use a static type system to make predictions about what code is expected before it runs.另一种方式是使用静态类型系统来预测在运行代码之前会发生什么。\nStatic type-checking静态类型检查Think back to that TypeError we got earlier from trying to call a string as a function. Most people don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.想起那个 TypeError 我们以前从尝试调用一个字符串作为函数时得到的。大多数人不喜欢在运行他们的代码时得到任何类型的错误，这些错误被称为 bug！而当我们写新代码时，我们尽可能地避免引入新的 bug。If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.如果我们添加些点代码，保存我们的文件，重新运行代码，并立即看到错误，我们可能会快速地发现问题；但这并不总是如此。我们可能没有测试特性的充分程度，所以我们可能没有真正发生可能会抛出的错误！或者如果我们能够看到错误，我们可能已经做了大量的重构和添加了很多不同的代码，我们被迫要探索它们。Ideally, we could have a tool that helps us find these bugs before our code runs. That’s what a static type-checker like TypeScript does. Static types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.最好的方式是我们可以在我们的代码运行之前，有一个工具帮我们找到这些 bug。这是 TypeScript 的静态类型检查器做的。静态类型系统描述了我们的值在运行我们的程序时的形状和行为。一个类型检查器像 TypeScript 使用这些信息，告诉我们当可能会出现问题时。\nconst message &#x3D; &quot;hello!&quot;;\n\nmessage();\n&#x2F;&#x2F; This expression is not callable.\n&#x2F;&#x2F;   Type &#39;String&#39; has no call signatures.\n\nRunning that last sample with TypeScript will give us an error message before we run the code in the first place.运行这个最后一个示例，TypeScript 将在第一个代码之前报错。\nNon-exception Failures非异常失败So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected.直到现在，我们都讨论了一些关于运行时错误的事情，比如说，当 JavaScript 运行时认为某些东西是无效的。这些情况出现的原因是 ECMAScript 规范明确指出了在运行时如何应该行为。For example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value undefined:比如说，规范指出了尝试调用不可调用的东西应该抛出一个错误。可能会认为这是“明显的行为”，但你可以想象一下，访问一个对象上不存在的属性应该抛出一个错误。而 JavaScript 给我们不同的行为，返回值 undefined：\nconst user &#x3D; &#123;\n  name: &quot;Daniel&quot;,\n  age: 26,\n&#125;;\nuser.location; &#x2F;&#x2F; returns undefined\n\nUltimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. In TypeScript, the following code produces an error about location not being defined:最终，一个静态类型系统必须要在它的系统中，告诉我们应该把哪些代码标记为错误的代码，即使它是“有效的 JavaScript”，也不会立即抛出错误。在 TypeScript 中，下面的代码会报错：\nconst user &#x3D; &#123;\n  name: &quot;Daniel&quot;,\n  age: 26,\n&#125;;\n\nuser.location;\n&#x2F;&#x2F; Property &#39;location&#39; does not exist on type &#39;&#123; name: string; age: number; &#125;&#39;.\n\nWhile sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches a lot of legitimate bugs.在某些情况下，这意味着一个交换，在你能表达的范围内，在你的程序中，你可以把一些有效的 JavaScript 抛出错误。而 TypeScript 捕获很多有效的错误。For example: typos,比如说，拼写错误，\nconst announcement &#x3D; &quot;Hello World!&quot;;\n\n&#x2F;&#x2F; How quickly can you spot the typos?\nannouncement.toLocaleLowercase();\nannouncement.toLocalLowerCase();\n\n&#x2F;&#x2F; We probably meant to write this...\nannouncement.toLocaleLowerCase();\n\nuncalled functions,未调用的函数，\nfunction flipCoin() &#123;\n  &#x2F;&#x2F; Meant to be Math.random()\n  return Math.random &lt; 0.5;\n  &#x2F;&#x2F; Operator &#39;&lt;&#39; cannot be applied to types &#39;() &#x3D;&gt; number&#39; and &#39;number&#39;.\n&#125;\n\nor basic logic errors.或基本的逻辑错误。\nconst value &#x3D; Math.random() &lt; 0.5 ? &quot;a&quot; : &quot;b&quot;;\nif (value !&#x3D;&#x3D; &quot;a&quot;) &#123;\n  &#x2F;&#x2F; ...\n&#125; else if (value &#x3D;&#x3D;&#x3D; &quot;b&quot;) &#123;\n  &#x2F;&#x2F; This condition will always return &#39;false&#39; since the types &#39;&quot;a&quot;&#39; and &#39;&quot;b&quot;&#39; have no overlap.\n  &#x2F;&#x2F; Oops, unreachable\n&#125;\n\nTypes for Tooling类型为工具TypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can also prevent us from making those mistakes in the first place.TypeScript 可以捕获我们在我们的代码中做错误的错误。这很好，但 TypeScript 可以防止我们做错误。The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use.类型检查器有信息来检查变量和其他属性是否正确。一旦有这些信息，它也可以开始提建议你应该使用哪些属性。That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.这意味着 TypeScript 可以用于编辑代码，并且核心类型检查器可以提供错误消息和代码补全。这是人们通常在说讨论工具时所提到的。\nimport express from &quot;express&quot;;\nconst app &#x3D; express();\n\napp.get(&quot;&#x2F;&quot;, function (req, res) &#123;\n  res.sen\n    &#x2F;&#x2F; send\n    &#x2F;&#x2F; sendDate\n    &#x2F;&#x2F; sendfile\n    &#x2F;&#x2F; sendFile\n    &#x2F;&#x2F; sendStatus\n&#125;);\n\napp.\n\nTypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that your favorite editor has TypeScript support available.TypeScript 也深深地认识到工具，并且这也包括了完成和错误的补全，你在输入时可以自动修复错误，重新组织代码，以及寻找变量的定义，或寻找所有引用的变量。这全部是基于类型检查器的，并且是完全的跨平台，所以你可能喜欢的编辑器有 TypeScript 的支持。\ntsc, the TypeScript compilertsc，TypeScript 编译器We’ve been talking about type-checking, but we haven’t yet used our type-checker. Let’s get acquainted with our new friend tsc, the TypeScript compiler. First we’ll need to grab it via npm.我们已经讲述了类型检查，但我们还没有使用我们的类型检查器。我们需要通过 npm 来获取 tsc，TypeScript 编译器。\nnpm install -g typescript\n\nThis installs the TypeScript Compiler tsc globally. You can use npx or similar tools if you’d prefer to run tsc from a local node_modules package instead.这将安装 TypeScript 编译器 tsc 在全局。如果你想从本地的 node_modules 包里运行 tsc，可以使用 npx 或类似的工具。Now let’s move to an empty folder and try writing our first TypeScript program: hello.ts:现在我们移动到一个空文件夹，并尝试写我们的第一个 TypeScript 程序：hello.ts：\n&#x2F;&#x2F; Greets the world.\nconsole.log(&quot;Hello world!&quot;);\n\nNotice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command tsc which was installed for us by the typescript package.通过运行 tsc 命令，我们可以检查我们的程序。\ntsc hello.ts\n\n\nTada!拍拍拍！Wait, “tada” what exactly? We ran tsc and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.等等，“拍拍拍”，什么意思？我们运行 tsc，没有任何事情发生！But check again - we got some file output instead. If we look in our current directory, we’ll see a hello.js file next to hello.ts. That’s the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a .ts file:但再检查一次，我们会看到一个 hello.js 文件，它在 hello.ts 后面。这是 tsc 编译或转换成一个纯 JavaScript 文件的 hello.ts 的输出。如果我们检查内容，我们会看到 TypeScript 在处理 .ts 文件后打印出来的内容：\n&#x2F;&#x2F; Greets the world.\nconsole.log(&quot;Hello world!&quot;);\n\nIn this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.在这种情况下，TypeScript 尝试输出一个清洁的可读代码，看起来像一个人写的代码。这并不总是如此简单，TypeScript 缩进一致，注意代码的不同行，并尝试保持注释在同一行。What about if we did introduce a type-checking error? Let’s rewrite hello.ts:如果我们把 hello.ts 中的 console.log 改成 console.logs，我们会发现什么？我们再次重写 hello.ts：\n&#x2F;&#x2F; This is an industrial-grade general-purpose greeter function:\nfunction greet(person, date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date&#125;!&#96;);\n&#125;\n\ngreet(&quot;Brendan&quot;);\n\nIf we run tsc hello.ts again, notice that we get an error on the command line!如果我们运行 tsc hello.ts 再次，我们会发现在命令行上出现一个错误！\nExpected 2 arguments, but got 1.\n\nTypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!TypeScript 提醒我们没有传递参数给 greet 函数，并且正确地。直到现在，我们只写了标准 JavaScript，然而类型检查仍然可以找到我们的代码的问题。感谢 TypeScript！\nEmitting with Errors发射错误One thing you might not have noticed from the last example was that our hello.js file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, you will know better than TypeScript.一个你可能没有注意到的事情是，我们的 hello.js 文件变了一次。如果我们打开这个文件，我们会看到它的内容仍然基本和我们的输入文件一样。这可能是一个很糟的情况，因为 tsc 报告了我们的代码的错误，但这是基于 TypeScript 的核心值：很多时候，你会更了解更多的事情。To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?重复上一段内容，类型检查代码限制了你可以运行的程序，因此有一个交换，如果你的类型检查器找到了可接受的东西，那么你可以运行它。但是，有时候，这些检查会拖慢你的程序。例如，假设你是一个 JavaScript 的移植者，并且你把类型检查错误插入到你的代码中。最终，你会把它们清理掉，但是原来的 JavaScript 代码已经已经正常运行了！为什么你会把它移植到 TypeScript 中，然后停止运行它？So TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. Try changing your hello.ts file and running tsc with that flag:因此，TypeScript 不会拖慢你。但是，随着时间的推移，你可能会想要更加安全，并且使 TypeScript 变得更严格。在这种情况下，你可以使用 noEmitOnError 编译器选项。试着把 hello.ts 文件中的代码改一下，然后运行 tsc 并且使用这个选项：\ntsc --noEmitOnError hello.ts\n\nYou’ll notice that hello.js never gets updated.hello.js 不会被更新。\nExplicit Types显式类型Up until now, we haven’t told TypeScript what person or date are. Let’s edit the code to tell TypeScript that person is a string, and that date should be a Date object. We’ll also use the toDateString() method on date.直到现在，我们都没有告诉 TypeScript 什么是人或日期。我们现在编辑代码，让 TypeScript 知道 person 是一个字符串，而 date 应该是一个 Date 对象。我们也使用 date 的 toDateString() 方法。\nfunction greet(person: string, date: Date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;\n\nWhat we did was add type annotations on person and date to describe what types of values greet can be called with. You can read that signature as ”greet takes a person of type string, and a date of type Date“.我们做了一个类型标注，让 TypeScript 知道 greet 可以被调用的时候，person 的类型是 string，而 date 的类型是 Date。With this, TypeScript can tell us about other cases where greet might have been called incorrectly. For example…这样，TypeScript 可以告诉我们其他情况下 greet 可能会被调用错误。例如…\nfunction greet(person: string, date: Date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;\ngreet(&quot;Maddison&quot;, Date());\n&#x2F;&#x2F; Argument of type &#39;string&#39; is not assignable to parameter of type &#39;Date&#39;.\n\nHuh? TypeScript reported an error on our second argument, but why?哎？TypeScript 在第二个参数上报错了，但是为什么？Perhaps surprisingly, calling Date() in JavaScript returns a string. On the other hand, constructing a Date with new Date() actually gives us what we were expecting.可能就是因为 JavaScript 中的 Date() 返回一个字符串，而 new Date() 则会返回我们期望的结果。Anyway, we can quickly fix up the error:然后，我们可以快速修复错误：\nfunction greet(person: string, date: Date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;\n\ngreet(&quot;Maddison&quot;, new Date());\n\nKeep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just infer (or “figure out”) the types for us even if we omit them.记住，我们不是总是要写明类型标注。在大多数情况下，TypeScript 也可以自动推断（或者说认为）类型，即使我们没有写明类型标注。\nlet msg &#x3D; &quot;hello there!&quot;;\n\nlet msg: string;\n\nEven though we didn’t tell TypeScript that msg had the type string it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.即使我们没有告诉 TypeScript msg 的类型是 string，它也能够自动推断出来。这是一个特性，并且当类型系统自动推断出相同类型的时候，不要写明类型标注。:::tip\nthe message bubble inside the code sample above. That is what your editor would show if you had hovered over the word.在上面的代码段中，你的编辑器会显示一个消息泡。如果你鼠标悬停在这个单词上，那么你的编辑器会显示这个消息泡。:::\nErased Types擦除类型Let’s take a look at what happens when we compile the above function greet with tsc to output JavaScript:我们看看如果我们用 tsc 编译上面的函数 greet，它会输出 JavaScript 代码：\n&quot;use strict&quot;;\nfunction greet(person, date) &#123;\n  console.log(\n    &quot;Hello &quot;.concat(person, &quot;, today is &quot;).concat(date.toDateString(), &quot;!&quot;)\n  );\n&#125;\ngreet(&quot;Maddison&quot;, new Date());\n\nNotice two things here:注意这里有两件事情：Our person and date parameters no longer have type annotations.我们的 person 和 date 参数没有类型标注。Our “template string” - that string that used backticks (the character) - was converted to plain strings with concatenations (+).我们的模板字符串（使用 字符）已经被转换成了纯字符串，并且使用了 + 字符串连接。More on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.TypeScript 不是 JavaScript（或者说 ECMAScript）的一部分，所以不会有浏览器或其他运行时可以直接运行 TypeScript 的情况。因此 TypeScript 需要一个编译器，以便我们可以去掉或转换 TypeScript 的任何特定代码，以便我们可以运行它。大多数 TypeScript 特定代码都会被去掉，反之，这里的类型标注也会被去掉。&#96;\n\n\n\n\n\n\nTIP\nRemember: Type annotations never change the runtime behavior of your program.记住：类型标注不会改变你的程序的运行时行为。\n\nDownleveling降级One other difference from the above was that our template string was rewritten from我们的模板字符串是从\n&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;;\n\nto\n&quot;Hello &quot; + person + &quot;, today is &quot; + date.toDateString() + &quot;!&quot;;\n\nWhy did this happen?为什么这样发生了？Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - don’t ask). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called downleveling.模板字符串是 ECMAScript 2015 的一个特性（或者说 ECMAScript 6，ES2015，ES6 等）。TypeScript 有能力将从更新的 ECMAScript 移到更旧的 ECMAScript，比如 ECMAScript 3 或 ECMAScript 5（或者说 ES3 和 ES5）。这种移动的过程称为降级。By default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with –target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running tsc –target es2015 hello.ts gives us the following output:默认情况下，TypeScript 目标 ES3，一个非常老的 ECMAScript 版本。我们可以选择一个更新的版本，使用 target 选项。运行 tsc --target es2015 hello.ts 就会得到以下的输出：\nfunction greet(person, date) &#123;\n  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);\n&#125;\ngreet(&quot;Maddison&quot;, new Date());\n\nWhile the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.默认目标是 ES3，大多数当前浏览器都支持 ES2015。大多数开发人员可以安全地指定 ES2015 或以上作为目标，除非需要与某些古老的浏览器兼容。\nStrictness严格Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially null&#x2F;undefined values. Much like how tsc emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating existing JavaScript, that might be a desirable first step.不同的用户到 TypeScript 上来看，有不同的意图。有人想要一个更宽松的选择，这可以帮助验证某些部分的程序，并且仍然有很好的工具。这是 TypeScript 默认的行为，其中类型是可选的，推断会接受更宽松的类型，并且没有检查可能 null/undefined 的值。和 tsc 在出现错误的时候一样，这些默认值被放在了你的脚跟上（兜底：这些默认选项并不会阻碍你的开发）。如果你正在迁移已有的 JavaScript，那么这可能是一个最佳的第一步。In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.不同的用户喜欢立刻验证程序，而不是等到最后。这是 TypeScript 的语言提供了严格性设置，这些设置可以改变静态类型检查的行为。这些设置可以改变静态类型检查的行为，而不是一个开关。这些设置越高，TypeScript 越会检查更多的信息。这可能需要一点额外的工作，但一般来说，这能提供更好的工具，并且能更好地支持你的代码。当可能的时候，一个新的代码应该总是开启这些严格性检查。TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The strict flag in the CLI, or “strict”: true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks.TypeScript 有多个严格性标志，可以开启或关闭，所有的示例都将使用所有的标志，除非特别说明。CLI 中的 strict 开关，或 tsconfig.json 中的 strict: true 开启了所有的标志，但是我们可以单独关闭它们。两个最大的，你应该知道的是 noImplicitAny 和 strictNullChecks。\nnoImplicitAny无隐式anyRecall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: any. This isn’t the worst thing that can happen - after all, falling back to any is just the plain JavaScript experience anyway.在某些地方，TypeScript 不会为我们自动推断类型，而是使用最宽松的类型：any。这并不是最差的情况，因为仍然是 JavaScript 的经验。However, using any often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code. Turning on the noImplicitAny flag will issue an error on any variables whose type is implicitly inferred as any.使用 any 很容易让你的程序变得更加不可靠。因为更加类型化的程序，你会发现更多的错误，并且更加容易地调试。开启 noImplicitAny 标志会在任何自动推断类型为 any 的变量上发出错误。\nstrictNullChecks严格nullBy default, values like null and undefined are assignable to any other type. This can make writing some code easier, but forgetting to handle null and undefined is the cause of countless bugs in the world - some consider it a billion dollar mistake! The strictNullChecks flag makes handling null and undefined more explicit, and spares us from worrying about whether we forgot to handle null and undefined.默认情况下，null 和 undefined 可以赋值给任何类型。这可以让写一些代码更容易，但是忘记处理 null 和 undefined 就会导致世界上的很多错误，有人认为这是一百亿美元错误！ strictNullChecks 可以让处理 null 和 undefined 更加明确，并且让我们不用担心是否忘记处理 null 和 undefined。\n参考链接Typescript The Basics\n","slug":"2022-06-07ts-basics","date":"2022-06-06T07:56:08.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"bb89616b2d7e7f4e050ed00ae2d71539","title":"1.Typescript起步","content":"说明此文及后续的几篇是对Typescript官方原文的翻译，方便阅读\nGet Startedtypescript 起步，分别针对 4 类不同的程序开发者进行引导， 对号入座\n\n新手程序猿，没有接触过任何开发语言\nJS 开发者\nJava&#x2F;C#开发 [跳过]\n函数式编程人员\n5 分钟内了解 Typescript\n\n新手程序猿Congratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!祝贺您选择了 TypeScript 作为您的第一种语言，您已经做出了优秀的决策！You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.你大概已经听说过，TypeScript 是 JavaScript 的一个变体。TypeScript 和 JavaScript 的关系是在现代编程语言中非常独特的，所以学习更多关于这个关系的知识将帮助你了解 TypeScript 和 JavaScript 的区别。\nWhat is JavaScript? A Brief History什么是 JavaScript？简单的历史\nJavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.JavaScript 是一种简单的脚本语言，用于浏览器。在创建时，它预期会被用于嵌入在网页中的短片代码 — 写入超过十几行代码会有点不便。Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich applications of all kinds.Web 浏览器开发者对这个增加了 JS 使用的响应，优化了他们的执行引擎（动态编译）和扩展了他们可以做的事情（添加 APIs），这使得 Web 开发者使用它来做更多的事情。在现代网站上，您的浏览器通常运行着一些应用程序，其中包括千万行代码的应用程序。这是一个非常长的“网”的发展，从一个简单的静态页面开始，并进入一个丰富的应用程序的平台。More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use only JavaScript to program their entire stack!不仅如此，JS 变得越来越受欢迎，并且可以在浏览器之外使用，比如使用 node.js 来实现 JS 服务器。JS 的“运行在任何地方”性质使得它一个极受欢迎的选择。有许多开发者今天只使用 JavaScript 来编程他们的整个堆栈！To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own quirks — oddities and surprises, and JavaScript’s humble beginning makes it have many of these. Some examples:概括，我们有一种语言，被设计为快速使用，然后扩展到一个具有千万行代码的应用程序的工具。每种语言都有自己的特性，有的有点不同，有的有点惊人，而 JavaScript 的轻重感使得它有许多这些。有些例子：\nJavaScript’s equality operator (&#x3D;&#x3D;) coerces its arguments, leading to unexpected behavior:JavaScript 的相等操作符（==）会强制转换它的参数，导致意外的行为：\nif (&quot;&quot; &#x3D;&#x3D; 0) &#123;\n  &#x2F;&#x2F; It is! But why??\n&#125;\nif (1 &lt; x &lt; 3) &#123;\n  &#x2F;&#x2F; True for *any* value of x!\n&#125;\n\nJavaScript also allows accessing properties which aren’t present:JavaScript 也允许访问不存在的属性：\nconst obj &#x3D; &#123; width: 10, height: 15 &#125;;\n&#x2F;&#x2F; Why is this NaN? Spelling is hard!\nconst area &#x3D; obj.width * obj.heigth;\n\nMost programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.大多数编程语言会抛出错误，当这些错误发生时，它们会抛出错误，而不是在编译时。当写小型程序时，这些惊人的惊喜是可接受的；当写大型应用程序时，这些惊喜是一个严重的问题。\n\nTypeScript: A Static Type Checker\n\nWe said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as static checking. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static type checking.我们说过，某些语言不允许运行那些错误的程序。检测代码中的错误，而不运行它, 是静态检查。确定哪些是错误的，哪些是正确的，是基于值的类型的静态检查。TypeScript checks a program for errors before execution, and does so based on the kinds of values, it’s a static type checker. For example, the last example above has an error because of the type of obj. Here’s the error TypeScript found:TypeScript 检测程序前，并且基于值的类型，它是一个静态类型检查器。例如，上面的最后一个例子有一个错误，因为 obj 的类型是 NaN。这里 TypeScript 发现了错误：\nconst obj &#x3D; &#123; width: 10, height: 15 &#125;;\nconst area &#x3D; obj.width * obj.heigth;\n&#x2F;&#x2F; Property &#39;heigth&#39; does not exist on type &#39;&#123; width: number; height: number; &#125;&#39;. Did you mean &#39;height&#39;?\n\nA Typed Superset of JavaScript一个类型定义的超集 JavaScript\nHow does TypeScript relate to JavaScript, though?TypeScript 的类型定义是什么，和 JavaScript 的类型定义有什么关系？\nSyntax 语法TypeScript is a language that is a superset of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a syntax error because it’s missing a ):Typescript 是 JavaScript 的一个子集：JS 语言的语法是合法的 TS。语法是指我们写程序的方式。例如，这段代码有一个语法错误，因为没有一个）。\nlet a &#x3D; (4\n&#39;)&#39; expected.\n\nTypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.TypeScript 不会认为任何 JavaScript 代码是错误的，因为它的语法。这意味着你可以把任何工作的 JavaScript 代码放在 TypeScript 文件中，而不用担心它的语法。\nTypes类型\nHowever, TypeScript is a typed superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about obj.heigth was not a syntax error: it is an error of using some kind of value (a type) in an incorrect way.\n然而，TypeScript 是一个类型的超集，意味着它添加了一些规则，如何使用不同类型的值。前面的错误，obj.heigth 是不是一个语法错误？它是一个错误的使用某种类型的值（一个类型）的方式。\nAs another example, this is JavaScript code that you can run in your browser, and it will log a value:\n另一个例子，这是你可以在浏览器中运行的 JavaScript 代码，它会记录一个值：\nconsole.log(4 &#x2F; []);\n&#x2F;&#x2F; The right-hand side of an arithmetic operation must be of type &#39;any&#39;, &#39;number&#39;, &#39;bigint&#39; or an enum type.\n\nIt’s possible you really did intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)\n之前一个数除以一个数组，可能仅仅是想看下会出现什么，尽管他是一个错误程序。Typescript 的类型检查器是设计的，让正确的程序通过，并且尽可能少的错误。(后面，我们会学习如何配置 TypeScript 检查你的代码。)\nIf you move some code from a JavaScript file to a TypeScript file, you might see type errors depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.\n如果你从一个 JavaScript 文件移动到一个 TypeScript 文件，你可能会看到一些类型错误，取决于你的代码如何写。这些可能是代码的正确性，或者 TypeScript 过于保守。本指南中，我们会演示如何添加各种 TypeScript 语法，以便消除这些错误。\nRuntime Behavior运行时行为TypeScript is also a programming language that preserves the runtime behavior of JavaScript. For example, dividing by zero in JavaScript produces Infinity instead of throwing a runtime exception. As a principle, TypeScript never changes the runtime behavior of JavaScript code.TypeScript 也是一个编程语言，它保留 JavaScript 的运行时行为。例如，在 JavaScript 中除以零会产生无穷，而不是抛出一个运行时异常。作为一个原则，TypeScript 不会改变 JavaScript 代码的运行时行为。This means that if you move code from JavaScript to TypeScript, it is guaranteed to run the same way, even if TypeScript thinks that the code has type errors.这意味着如果你从 JavaScript 移动到 TypeScript，它就保证会运行一样的，即使 TypeScript 认为代码有类型错误。Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.保持和 JavaScript 的运行时一致的行为是 TypeScript 的基础承诺，因为它意味着你可以很容易地从 JavaScript 到 TypeScript 过渡，而不用担心潜在的差异，可能会影响你的程序的正常运行。\nErased Types擦除类型Roughly speaking, once TypeScript’s compiler is done with checking your code, it erases the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.换句话说，一旦 TypeScript 编译器完成了检查你的代码，它会擦除类型，生成结果的“编译”代码。这意味着，一旦你的代码编译完成，结果的普通 JS 代码将没有类型信息。This also means that TypeScript never changes the behavior of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.这意味着，在编译时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。底线是，在运行时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。Finally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.最后，TypeScript 不提供任何额外的运行时库。你的程序将使用和 JavaScript 程序一样的标准库（或外部库），所以没有额外的 TypeScript-特定的框架来学习。\nLearning JavaScript and TypeScript学习 JavaScript 和 TypeScriptWe frequently see the question “Should I learn JavaScript or TypeScript?“.我们经常会看到这个问题：“我应该学习 JavaScript 还是 TypeScript？”The answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.答案是，你不能学习 TypeScript，除非你学习 JavaScript！TypeScript 和 JavaScript 共享语法和运行时行为，所以你学习 JavaScript 的任何内容都是帮助你学习 TypeScript 的同时。There are many, many resources available for programmers to learn JavaScript; you should not ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged javascript than typescript, but all of the javascript questions also apply to TypeScript.有很多，很多资源可供程序员学习 JavaScript；如果你写 TypeScript，你不应该忽略这些资源。例如，有 20 倍的 StackOverflow 问题标记了 javascript，而 typescript 问题也适用于 javascript。If you find yourself searching for something like “how to sort a list in TypeScript”, remember: TypeScript is JavaScript’s runtime with a compile-time type checker. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.如果你发现自己在搜索“如何排序一个列表”，记住：TypeScript 是 JavaScript 的运行时，同时还有一个编译时类型检查器。你在 TypeScript 中排序一个列表的方式和在 JavaScript 中一样。如果你找到一个使用 TypeScript 的资源，那也是很好的，但不要限制自己在每天的问题中想要使用 TypeScript-特定的答案来实现运行时任务。\nNext Steps下一步This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:这是一个简单的概述，从这里你可以：Learn some of the JavaScript fundamentals, we recommend either:学习 JavaScript 基本原理，我们建议：Microsoft’s JavaScript Resources orJavaScript guide at the Mozilla Web DocsContinue to TypeScript for JavaScript Programmers继续学习 TypeScript 为 JavaScript 程序员Read the full Handbook from start to finish (30m)阅读全部手册从头到尾（30 分钟）大佬就是大佬 30 分钟能搞定，我估计要搞 3 天，手册这地方内容还是很多的Explore the Playground examples探索 Playground 示例\nJS 开发者TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.TypeScript 与 JavaScript 的关系是不正常的。TypeScript 提供了 JavaScript 的所有功能，并且在这些功能的基础上添加了一层：TypeScript 的类型系统。For example, JavaScript provides language primitives like string and number, but it doesn’t check that you’ve consistently assigned these. TypeScript does.例如，JavaScript 提供了字符串和数字，但它不检查你是否按照一致的方式分配这些。TypeScript 也提供了。This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.这意味着你的已有的工作中的 JavaScript 代码也是 TypeScript 代码。TypeScript 的主要好处是它可以高亮你的代码中的意外行为，降低 bug 的可能性。This tutorial provides a brief overview of TypeScript, focusing on its type system.这个教程主要介绍 TypeScript 的类型系统。\nTypes by Inference类型推论\nTypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.TypeScript 知道 JavaScript 语言，并且会为你生成类型。例如，创建一个变量并为它赋值，TypeScript 就会使用值作为它的类型。\nlet helloWorld &#x3D; &quot;Hello World&quot;;\n\n&#x2F;&#x2F; let helloWorld: string\n\nBy understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that helloWorld is a string in the above example.通过了解 JavaScript 工作方式，TypeScript 可以建立一个接受 JavaScript 代码，但有类型的类型系统。这个类型系统没有需要在你的代码中添加额外的字符来明确类型。这就是 TypeScript 知道 helloWorld 是一个字符串的原因。\nYou may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.你可能在 Visual Studio Code 中写了 JavaScript，并且有自动补全。Visual Studio Code 使用 TypeScript 作为后台来更加方便地工作。（原来如此）\nDefining Types定义类型You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.你可以使用 JavaScript 的许多设计模式。_然而，有些设计模式使得类型无法被自动推断（例如，使用动态规划的模式_。为了解决这些情况，TypeScript 支持一个 JavaScript 的扩展，它提供了给你告诉 TypeScript 的类型应该是什么的地方。For example, to create an object with an inferred type which includes name: string and id: number, you can write:例如，创建一个具有推断类型的对象，它包含 name: string 和 id: number，你可以这样写：\nconst user &#x3D; &#123;\n  name: &quot;Hayes&quot;,\n  id: 0,\n&#125;;\n\nYou can explicitly describe this object’s shape using an interface declaration:你可以使用接口声明来明确地描述这个对象的形状：\ninterface User &#123;\n  name: string;\n  id: number;\n&#125;\n\nYou can then declare that a JavaScript object conforms to the shape of your new interface by using syntax like : TypeName after a variable declaration:你可以使用类型名称来告诉 JavaScript 你的变量是属于哪个类型：\nconst user: User &#x3D; &#123;\n  name: &quot;Hayes&quot;,\n  id: 0,\n&#125;;\n\nIf you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:如果你提供的对象不符合你提供的接口，TypeScript 就会警告你：\ninterface User &#123;\n  name: string;\n  id: number;\n&#125;\n\nconst user: User &#x3D; &#123;\n  username: &quot;Hayes&quot;,\n  &#x2F;&#x2F; Type &#39;&#123; username: string; id: number; &#125;&#39; is not assignable to type &#39;User&#39;.\n  &#x2F;&#x2F; Object literal may only specify known properties, and &#39;username&#39; does not exist in type &#39;User&#39;.\n  id: 0,\n&#125;;\n\nSince JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:因为 JavaScript 支持类和对象-面向对象编程，所以 TypeScript 也支持。你可以使用接口声明类：\ninterface User &#123;\n  name: string;\n  id: number;\n&#125;\n\nclass UserAccount &#123;\n  name: string;\n  id: number;\n\n  constructor(name: string, id: number) &#123;\n    this.name &#x3D; name;\n    this.id &#x3D; id;\n  &#125;\n&#125;\n\nconst user: User &#x3D; new UserAccount(&quot;Murphy&quot;, 1);\n\nYou can use interfaces to annotate parameters and return values to functions:你可以使用接口来标注函数的参数和返回值：\nfunction getAdminUser(): User &#123;\n  &#x2F;&#x2F;...\n&#125;\n\nfunction deleteUser(user: User) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\nThere is already a small set of primitive types available in JavaScript: boolean, bigint, null, number, string, symbol, and undefined, which you can use in an interface. TypeScript extends this list with a few more, such as any (allow anything), unknown (ensure someone using this type declares what the type is), never (it’s not possible that this type could happen), and void (a function which returns undefined or has no return value).已经有一些简单的原始类型可用于 JavaScript：boolean, bigint, null, number, string, symbol, 和 undefined，你可以在接口中使用它们。TypeScript 将这些类型扩展了一些，如 any（允许任何东西），unknown（确保使用者使用这个类型时声明了它的类型），never（不可能发生的类型），和 void（函数返回 undefined 或没有返回值）。\nYou’ll see that there are two syntaxes for building types: Interfaces and Types. You should prefer interface. Use type when you need specific features.你会看到有两种编写类型的语法：接口和类型。当你需要特定的功能时，你应该使用接口。使用类型时，你需要特定的功能。\nComposing Types组合类型With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.通过使用联合类型，或者通过使用泛型来组合复杂的类型。\nUnions联合类型With a union, you can declare that a type could be one of many types. For example, you can describe a boolean type as being either true or false:通过使用联合类型，你可以声明一个类型是可能是 true 或 false 的类型。\ntype MyBool &#x3D; true | false;\n\nNote: If you hover over MyBool above, you’ll see that it is classed as boolean. That’s a property of the Structural Type System. More on this below.请注意，如果你将鼠标移到 MyBool 上，你会看到它是一个 boolean 类型。这是结构类型系统的一个属性。更多内容在下面。A popular use-case for union types is to describe the set of string or number literals that a value is allowed to be:联合类型的一个常见用例是描述一个值可以是一个字符串或数字的集合：\ntype WindowStates &#x3D; &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;\ntype LockStates &#x3D; &quot;locked&quot; | &quot;unlocked&quot;;\ntype PositiveOddNumbersUnderTen &#x3D; 1 | 3 | 5 | 7 | 9;\n\nUnions provide a way to handle different types too. For example, you may have a function that takes an array or a string:联合类型可以用来处理不同类型的参数。例如，你可以有一个函数可以接受一个数组或字符串类型的参数：\nfunction getLength(obj: string | string[]) &#123;\n  return obj.length;\n&#125;\n\nTo learn the type of a variable, use typeof:使用 typeof 来查看一个变量的类型：\nType Predicate类型断言\nstring typeof s &#x3D;&#x3D;&#x3D; &quot;string&quot;\nnumber typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot;\nboolean typeof b &#x3D;&#x3D;&#x3D; &quot;boolean&quot;\nundefined typeof undefined &#x3D;&#x3D;&#x3D; &quot;undefined&quot;\nfunction typeof f &#x3D;&#x3D;&#x3D; &quot;function&quot;\narray Array.isArray(a)\n\nFor example, you can make a function return different values depending on whether it is passed a string or an array:例如，你可以用来返回不同的值，根据传入的参数是字符串还是数组：\nfunction wrapInArray(obj: string | string[]) &#123;\n  if (typeof obj &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    return [obj];\n\n    (parameter) obj: string\n  &#125;\n  return obj;\n&#125;\n\nGenerics泛型\nGenerics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.泛型可以提供类型变量。例如，数组。数组没有泛型可以包含任何东西。数组有泛型可以描述数组中包含的值。\ntype StringArray &#x3D; Array&lt;string&gt;;\ntype NumberArray &#x3D; Array&lt;number&gt;;\ntype ObjectWithNameArray &#x3D; Array&lt;&#123; name: string &#125;&gt;;\nYou can declare your own types that use generics:\n\n你可以声明自己的类型，使用泛型。\ninterface Backpack&lt;Type&gt; &#123;\n  add: (obj: Type) &#x3D;&gt; void;\n  get: () &#x3D;&gt; Type;\n&#125;\n\n&#x2F;&#x2F; This line is a shortcut to tell TypeScript there is a\n&#x2F;&#x2F; constant called &#96;backpack&#96;, and to not worry about where it came from.\ndeclare const backpack: Backpack&lt;string&gt;;\n\n&#x2F;&#x2F; object is a string, because we declared it above as the variable part of Backpack.\nconst object &#x3D; backpack.get();\n\n&#x2F;&#x2F; Since the backpack variable is a string, you can&#39;t pass a number to the add function.\nbackpack.add(23);\nArgument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.\n\nStructural Type System结构类型系统\nOne of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.结构类型系统的一个核心原则是，类型检查只关注值的形状。这称为“鸭子类型”或“结构类型”。In a structural type system, if two objects have the same shape, they are considered to be of the same type.在结构类型系统中，如果两个对象具有相同的形状，则被视为相同的类型。\ninterface Point &#123;\n  x: number;\n  y: number;\n&#125;\n\nfunction logPoint(p: Point) &#123;\n  console.log(&#96;$&#123;p.x&#125;, $&#123;p.y&#125;&#96;);\n&#125;\n\n&#x2F;&#x2F; logs &quot;12, 26&quot;\nconst point &#x3D; &#123; x: 12, y: 26 &#125;;\nlogPoint(point);\n\nThe point variable is never declared to be a Point type. However, TypeScript compares the shape of point to the shape of Point in the type-check. They have the same shape, so the code passes.point 变量没有被声明为 Point 类型。但是，TypeScript 对比 point 和 Point 的形状，它们具有相同的形状，所以代码通过。The shape-matching only requires a subset of the object’s fields to match.结构类型系统只需要对象的一部分字段匹配。\nconst point3 &#x3D; &#123; x: 12, y: 26, z: 89 &#125;;\nlogPoint(point3); &#x2F;&#x2F; logs &quot;12, 26&quot;\n\nconst rect &#x3D; &#123; x: 33, y: 3, width: 30, height: 80 &#125;;\nlogPoint(rect); &#x2F;&#x2F; logs &quot;33, 3&quot;\n\nconst color &#x3D; &#123; hex: &quot;#187ABF&quot; &#125;;\nlogPoint(color);\n&#x2F;&#x2F; Argument of type &#39;&#123; hex: string; &#125;&#39; is not assignable to parameter of type &#39;Point&#39;.\n&#x2F;&#x2F; Type &#39;&#123; hex: string; &#125;&#39; is missing the following properties from type &#39;Point&#39;: x, y\n\nThere is no difference between how classes and objects conform to shapes:类和对象都遵循结构类型系统。\nclass VirtualPoint &#123;\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) &#123;\n    this.x &#x3D; x;\n    this.y &#x3D; y;\n  &#125;\n&#125;\n\nconst newVPoint &#x3D; new VirtualPoint(13, 56);\nlogPoint(newVPoint); &#x2F;&#x2F; logs &quot;13, 56&quot;\n\nIf the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.如果对象或类有所有必要的属性，TypeScript将认为它们匹配，无论实现细节。\nNext Steps下一步This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:从这里开始，你可以：Read the full Handbook from start to finish (30m)阅读完整手册（30分钟）Explore the Playground examples探索 Playground 示例\nJava&#x2F;C#开发虽然 Java&#x2F;C#也接触过，但这不是我本次的重点，之后会补上\n函数式编程人员TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.TypeScript 开始于一个尝试，将传统对象-对象类型的编程语言转换为 JavaScript，这样的编程人员可以将传统的对象-对象编程程序转换为 Web 端的程序。This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell’s type system. It also describes unique features of TypeScript’s type system that arise from its modelling of JavaScript code.这个介绍是为了工作 Haskell 或 ML 程序员而设计的，它描述了 TypeScript 的类型系统与 Haskell 的类型系统之间的不同。This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.这个介绍不会讲到对象-对象编程。实际上，在 TypeScript 中的对象-对象编程程序与其他流行语言的对象-对象编程程序相似。\nPrerequisites先决条件In this introduction, I assume you know the following:在这个介绍中，我假设你知道了以下内容：How to program in JavaScript, the good parts.如何编写 JavaScript 程序，好的部分。Type syntax of a C-descended language.C-descended 语言的类型语法。If you need to learn the good parts of JavaScript, read JavaScript: The Good Parts. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. R4RS Scheme is a good example.如果你需要学习 JavaScript，请阅读 JavaScript：The Good Parts。如果你知道如何编写基于值词法的词法作用域语言，并且拥有大量可变性和不多的其他特性，你可以跳过这本书。R4RS Scheme 是一个好例子。The C++ Programming Language is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: x: string instead of string x.C++ 编程语言是一个好的地方学习 C-style 类型语法。\nConcepts not in Haskell在 Haskell 中不存在的概念\nBuilt-in types内置类型JavaScript defines 8 built-in types:JavaScript 定义了 8 个内置类型： 这里是包装类型Type Explanation类型说明Number a double-precision IEEE 754 floating point.数字，双精度 IEEE 754 浮点数。String an immutable UTF-16 string.字符串，不可变的 UTF-16 字符串。BigInt integers in the arbitrary precision format.大整数，任意精度格式。Boolean true and false.布尔值，true 和 false。Symbol a unique value usually used as a key.符号，通常用作键。Null equivalent to the unit type.空，等同于单元类型。Undefined also equivalent to the unit type.未定义，也等同于单元类型。Object similar to records.对象，类似于记录。See the MDN page for more detail.参见 MDN 页面。\nTypeScript has corresponding primitive types for the built-in types:TypeScript 有对应的内置类型的原始类型：numberstringbigintbooleansymbolnullundefinedobject\nOther important TypeScript types其他重要的 TypeScript 类型Type Explanation类型说明unknown the top type.未知类型，顶级类型。never the bottom type.永远不会是类型，底级类型。object literal eg { property: Type }对象字面量，例如 &#123; property: 类型 &#125;。void a subtype of undefined intended for use as a return type.void 类型，作为返回类型。T[] mutable arrays, also written ArrayT[] 可变数组，也称为 Array&lt;T&gt;。[T, T] tuples, which are fixed-length but mutable[T, T] 元组，固定长度但可变。(t: T) &#x3D;&gt; U functions(t: T) =&gt; U 函数。Notes:注意：Function syntax includes parameter names. This is pretty hard to get used to!函数语法包括参数名。这很难使用！\nlet fst: (a: any, b: any) &#x3D;&gt; any &#x3D; (a, b) &#x3D;&gt; a;\n&#x2F;&#x2F; or more precisely: 或者更准确地：\nlet fst: &lt;T, U&gt;(a: T, b: U) &#x3D;&gt; T &#x3D; (a, b) &#x3D;&gt; a;\n&#x2F;&#x2F; Object literal type syntax closely mirrors object literal value syntax:\n&#x2F;&#x2F; 模式匹配字面量类型语法与对象字面量值语法类似。\n\nlet o: &#123; n: number; xs: object[] &#125; &#x3D; &#123; n: 1, xs: [] &#125;;\n[T, T] is a subtype of T[].\n&#x2F;&#x2F; This is different than Haskell, where tuples are not related to lists.\n&#x2F;&#x2F; 此外，这是不同于 Haskell 的，元组不和列表相关。\n\nBoxed types包装类型JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type number and the boxed type Number. The boxed types are rarely needed, since their methods return primitives.JavaScript 有对应的包装类型，包含与这些类型相关的方法。\n(1).toExponential();\n&#x2F;&#x2F; equivalent to\nNumber.prototype.toExponential.call(1);\n\nNote that calling a method on a numeric literal requires it to be in parentheses to aid the parser.调用方法在数字字面量上需要在括号中，以帮助解析器。\nGradual typing渐进类型TypeScript uses the type any whenever it can’t tell what the type of an expression should be. Compared to Dynamic, calling any a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an any[] without marking the value in any way:TypeScript 使用 any 时，当它不能确定表达式的类型时。&#x2F;&#x2F; with “noImplicitAny”: false in tsconfig.json, anys: any[]在 tsconfig.json 中，加入 &quot;noImplicitAny&quot;: false 可以禁用 anys: any[]。\nconst anys &#x3D; [];\nanys.push(1);\nanys.push(&quot;oh no&quot;);\nanys.push(&#123; anything: &quot;goes&quot; &#125;);\n\nAnd you can use an expression of type any anywhere:你可以在任何地方使用 any 类型表达式。\nanys.map(anys[1]); &#x2F;&#x2F; oh no, &quot;oh no&quot; is not a function\n\nany is contagious, too — if you initialize a variable with an expression of type any, the variable has type any too.any 类型是传播的， 如果初始化一个变量为 any 类型，变量的类型也是 any。\nlet sepsis &#x3D; anys[0] + anys[1]; &#x2F;&#x2F; this could mean anything\n\nTo get an error when TypeScript produces an any, use “noImplicitAny”: true, or “strict”: true in tsconfig.json.为了在 TypeScript 生成 any 时得到错误提示，使用 &quot;noImplicitAny&quot;: true 或 &quot;strict&quot;: true 在 tsconfig.json 中。\nStructural typing结构类型Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:结构性类型是大多数函数编程程序员熟悉的概念，尽管 Haskell 和大多数 ML 不是结构性类型。\n&#x2F;&#x2F; @strict: false\nlet o &#x3D; &#123; x: &quot;hi&quot;, extra: 1 &#125;; &#x2F;&#x2F; ok\nlet o2: &#123; x: string &#125; &#x3D; o; &#x2F;&#x2F; ok\n\nHere, the object literal { x: “hi”, extra: 1 } has a matching literal type { x: string, extra: number }. That type is assignable to { x: string } since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of { x: string }.这里，对象字面量 &#123; x: &quot;hi&quot;, extra: 1 &#125; 有一个匹配的字面量类型 &#123; x: string, extra: number &#125;。Named types just give a name to a type; for assignability purposes there’s no difference between the type alias One and the interface type Two below. They both have a property p: string. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)命名类型只是给一个类型命名；用于类型赋值的目的不同于接口下面的类型别名和类型参数，但是它们都有属性 p: string。 (类型别名和接口的递归定义和类型参数有所不同。)\ntype One &#x3D; &#123; p: string &#125;;\ninterface Two &#123;\n  p: string;\n&#125;\nclass Three &#123;\n  p &#x3D; &quot;Hello&quot;;\n&#125;\n\nlet x: One &#x3D; &#123; p: &quot;hi&quot; &#125;;\nlet two: Two &#x3D; x;\ntwo &#x3D; new Three();\n\nUnions联合类型\nIn TypeScript, union types are untagged. In other words, they are not discriminated unions like data in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.在 TypeScript 中，联合类型是无标签的。 在其他语言中，联合类型是标签化的。\nfunction start(\n  arg: string | string[] | (() &#x3D;&gt; string) | &#123; s: string &#125;\n): string &#123;\n  &#x2F;&#x2F; this is super common in JavaScript\n  if (typeof arg &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n    return commonCase(arg);\n  &#125; else if (Array.isArray(arg)) &#123;\n    return arg.map(commonCase).join(&quot;,&quot;);\n  &#125; else if (typeof arg &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n    return commonCase(arg());\n  &#125; else &#123;\n    return commonCase(arg.s);\n  &#125;\n\n  function commonCase(s: string): string &#123;\n    &#x2F;&#x2F; finally, just convert a string to another string\n    return s;\n  &#125;\n&#125;\n\nstring, Array and Function have built-in type predicates, conveniently leaving the object type for the else branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.字符串、数组和函数有内置类型推断， 可以在 else 分支中推断出对象类型。The following types have built-in predicates:下面的类型有内置推断：Type Predicate类型推断&#96;\nstring typeof s &#x3D;&#x3D;&#x3D; “string”number typeof n &#x3D;&#x3D;&#x3D; “number”bigint typeof m &#x3D;&#x3D;&#x3D; “bigint”boolean typeof b &#x3D;&#x3D;&#x3D; “boolean”symbol typeof g &#x3D;&#x3D;&#x3D; “symbol”undefined typeof undefined &#x3D;&#x3D;&#x3D; “undefined”function typeof f &#x3D;&#x3D;&#x3D; “function”array Array.isArray(a)object typeof o &#x3D;&#x3D;&#x3D; “object”\nNote that functions and arrays are objects at runtime, but have their own predicates.函数和数组在运行时是对象， 但是有自己的推断。&#96;\nIntersections交叉类型\nIn addition to unions, TypeScript also has intersections:在 TypeScript 中，还有交叉类型：\ntype Combined &#x3D; &#123; a: number &#125; &amp; &#123; b: string &#125;;\ntype Conflicting &#x3D; &#123; a: number &#125; &amp; &#123; a: string &#125;;\n\nCombined has two properties, a and b, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so Conflicting.a: number &amp; string.Combined 有两个属性，a 和 b， 如果写成一个对象字面量类型， 则 a 和 b 都是 number 和 string 类型。\nUnit types单元类型Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string “foo” has the type “foo”. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:单元类型是原始类型的子类型， 它们包含一个原始值。\ndeclare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;\npad(&quot;hi&quot;, 10, &quot;left&quot;);\n\nWhen needed, the compiler widens — converts to a supertype — the unit type to the primitive type, such as “foo” to string. This happens when using mutability, which can hamper some uses of mutable variables:当需要时，编译器会扩展， 将单元类型转换为原始类型， 例如 &quot;foo&quot; 转换为 string。\nlet s &#x3D; &quot;right&quot;;\npad(&quot;hi&quot;, 10, s); &#x2F;&#x2F; error: &#39;string&#39; is not assignable to &#39;&quot;left&quot; | &quot;right&quot;&#39;\nArgument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot;&#39;.\n\nHere’s how the error happens:这里有一个错误：“right”: “right”\ns: string because “right” widens to string on assignment to a mutable variable.string is not assignable to “left” | “right”\nYou can work around this with a type annotation for s, but that in turn prevents assignments to s of variables that are not of type “left” | “right”.你可以使用类型注解来解决这个问题， 但是这会导致 s 的赋值， 只能赋值给 &quot;left&quot; | &quot;right&quot; 类型的变量。\nlet s: &quot;left&quot; | &quot;right&quot; &#x3D; &quot;right&quot;;\npad(&quot;hi&quot;, 10, s);\n\nConcepts similar to Haskell与 Haskell 类似的概念\nContextual typing上下文类型\nTypeScript has some obvious places where it can infer types, like variable declarations:TypeScript 有一些明显的地方， 可以推断类型， 如变量声明。\nlet s &#x3D; &quot;I&#39;m a string!&quot;;\n\nBut it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:TypeScript 也可以推断在某些地方没有声明类型的情况下， 如果你已经使用其他 C-语言语法：\ndeclare function map&lt;T, U&gt;(f: (t: T) &#x3D;&gt; U, ts: T[]): U[];\nlet sns &#x3D; map((n) &#x3D;&gt; n.toString(), [1, 2, 3]);\n\nHere, n: number in this example also, despite the fact that T and U have not been inferred before the call. In fact, after [1,2,3] has been used to infer T&#x3D;number, the return type of n &#x3D;&gt; n.toString() is used to infer U&#x3D;string, causing sns to have the type string[].这里， n: number 在这个例子中也， 即使在调用之前没有推断 T 和 U 的类型。 在实际上， 在 [1,2,3] 被用来推断 T=number 的时候， n =&gt; n.toString() 的返回类型会被用来推断 U=string， 导致 sns 的类型为 string[]。Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare map with the array first:注意， 推断会工作在任何顺序， 但是 intellisense 只会从左到右， 因此 TypeScript 只会优先声明 map 函数， 先声明数组。\ndeclare function map&lt;T, U&gt;(ts: T[], f: (t: T) &#x3D;&gt; U): U[];\n\nContextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as string or number. And it can infer return types from context:上下文类型也可以递归地通过对象字面量， 和单元类型， 如果没有声明类型， 则会被推断为 string 或 number。 并且可以从上下文中推断函数的返回类型。\ndeclare function run&lt;T&gt;(thunk: (t: T) &#x3D;&gt; void): T;\nlet i: &#123; inference: string &#125; &#x3D; run((o) &#x3D;&gt; &#123;\n  o.inference &#x3D; &quot;INSERT STATE HERE&quot;;\n&#125;);\n\nThe type of o is determined to be { inference: string } because这个 o 的类型是由 run 函数的参数类型决定的， 因为Declaration initializers are contextually typed by the declaration’s type: { inference: string }.声明初始值是由声明的类型决定的The return type of a call uses the contextual type for inferences, so the compiler infers that T&#x3D;{ inference: string }.调用的返回类型是由上下文类型决定的， 因此编译器会推断 T=&#123; inference: string &#125;。Arrow functions use the contextual type to type their parameters, so the compiler gives o: { inference: string }.箭头函数使用上下文类型来类型参数， 因此编译器会给 o: &#123; inference: string &#125;。And it does so while you are typing, so that after typing o., you get completions for the property inference, along with any other properties you’d have in a real program.而且这样， 在你输入 o. 的时候， 你会得到 inference 的属性的完整补全， 同时也会有其他实际程序中的属性。Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.这个功能可以让 TypeScript 的推断看起来像一个统一类型推断引擎， 但是它不是。\nType aliases类型别名\nType aliases are mere aliases, just like type in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.类型别名是类型别名， 像 Haskell 中的类型。 编译器会尝试使用别名名称在源代码中使用， 但不一定成功。\ntype Size &#x3D; [number, number];\nlet x: Size &#x3D; [101.1, 999.9];\n\nThe closest equivalent to newtype is a tagged intersection:最接近的等价是标记交集：\ntype FString &#x3D; string &amp; &#123; **compileTimeOnly: any &#125;;\n\n\nAn FString is just like a normal string, except that the compiler thinks it has a property named **compileTimeOnly that doesn’t actually exist. This means that FString can still be assigned to string, but not the other way round.FString 是一个普通字符串， 但是编译器认为它有一个名为 **compileTimeOnly 的属性， 这个属性并不存在。 这意味着 FString 仍然可以被赋值给 string， 但是不能被赋值给其他类型。\nDiscriminated Unions可识别联合\nThe closest equivalent to data is a union of types with discriminant properties, normally called discriminated unions in TypeScript:最接近的等价是数据的一个联合类型， 常见的是 TypeScript 中的分层联合：\ntype Shape &#x3D;\n  | &#123; kind: &quot;circle&quot;; radius: number &#125;\n  | &#123; kind: &quot;square&quot;; x: number &#125;\n  | &#123; kind: &quot;triangle&quot;; x: number; y: number &#125;;\n\nUnlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading | is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:与 Haskell 不同， 标记， 或者说分层联合的标记， 在每个对象类型中都是一个属性。 每个变体都有一个相同的属性， 并且它的单元类型不同。 这仍然是一个联合类型； 前面的 | 是联合类型的可选部分。 你可以使用普通的 JavaScript 代码来区分联合成员：\ntype Shape &#x3D;\n| &#123; kind: &quot;circle&quot;; radius: number &#125;\n| &#123; kind: &quot;square&quot;; x: number &#125;\n| &#123; kind: &quot;triangle&quot;; x: number; y: number &#125;;\n\nfunction area(s: Shape) &#123;\n  if (s.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;\n    return Math.PI _ s.radius _ s.radius;\n  &#125; else if (s.kind &#x3D;&#x3D;&#x3D; &quot;square&quot;) &#123;\n    return s.x _ s.x;\n  &#125; else &#123;\n  r eturn (s.x _ s.y) &#x2F; 2;\n  &#125;\n&#125;\n\nNote that the return type of area is inferred to be number because TypeScript knows the function is total. If some variant is not covered, the return type of area will be number | undefined instead.注意， area 的返回类型被推断为 number， 因为 TypeScript 知道函数是完全的。 如果某个变体没有被覆盖， area 的返回类型将会是 number | undefined。Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:与 Haskell 不同， 共有属性在联合中显示， 你可以使用有效的方式来区分联合成员：\nfunction height(s: Shape) &#123;\n  if (s.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;\n    return 2 \\* s.radius;\n  &#125; else &#123;\n  &#x2F;&#x2F; s.kind: &quot;square&quot; | &quot;triangle&quot;\n    return s.x;\n  &#125;\n&#125;\n\nType Parameters参数类型Like most C-descended languages, TypeScript requires declaration of type parameters:类似于大多数 C-descended 语言， TypeScript 需要声明类型参数：\nfunction liftArray&lt;T&gt;(t: T): Array&lt;T&gt; &#123;\n  return [t];\n&#125;\n\nThere is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:没有要求， 但是类型参数是一个惯例， 单大写字母。 类型参数可以被限制为一个类型， 这个类型行为类似于类型约束：\nfunction firstish&lt;T extends &#123; length: number &#125;&gt;(t1: T, t2: T): T &#123;\n  return t1.length &gt; t2.length ? t1 : t2;\n&#125;\n\nTypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.TypeScript 可以通过调用参数的类型推断出类型参数， 因此通常不需要指定类型参数。Because TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to propagate type information, such as constraining parameters to be the same type:TypeScript 是结构性的， 不需要类型参数， 因为它们不需要使一个函数多态。 类型参数只是用来传递类型信息， 如限制参数为相同类型：\nfunction length&lt;T extends ArrayLike&lt;unknown&gt;&gt;(t: T): number &#123;&#125;\nfunction length(t: ArrayLike&lt;unknown&gt;): number &#123;&#125;\n\nIn the first length, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.在第一个 length， T 没有必要； 可以注意， 它只被引用一次， 因此它不会被用来限制返回值或其他参数的类型。\nHigher-kinded types高阶类型\nTypeScript does not have higher kinded types, so the following is not legal:TypeScript 不支持高阶类型， 因此下面的不合法：\nfunction length&lt;T extends ArrayLike&lt;unknown&gt;, U&gt;(m: T&lt;U&gt;) &#123;&#125;\n\nPoint-free programmingPoint-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.点-free 编程 — 重量级的使用 curry 和函数组合 — 在 JavaScript 中可以， 但是可能会很多。 在 TypeScript 中， 类型推断对点-free 编程失败， 因此你会指定类型参数而不是值参数。 结果是这样的多， 因此比较适合避免点-free 编程。\nModule system模块系统\nJavaScript’s modern module syntax is a bit like Haskell’s, except that any file with import or export is implicitly a module:JavaScript 的现代模块语法和 Haskell 类似， 只是任何带有 import 或 export 的文件都是隐式的模块：\nimport &#123; value, Type &#125; from &quot;npm-package&quot;;\nimport &#123; other, Types &#125; from &quot;.&#x2F;local-package&quot;;\nimport \\* as prefix from &quot;..&#x2F;lib&#x2F;third-package&quot;;\n\n\nYou can also import commonjs modules — modules written using node.js’ module system:你也可以导入 commonjs 模块 — 使用 node.js 的模块系统写的模块：\nimport f &#x3D; require(&quot;single-function-package&quot;);\n\nYou can export with an export list:你可以使用 export 列表导出：\nexport &#123; f &#125;;\nfunction f() &#123;\n  return g();\n&#125;\nfunction g() &#123;&#125; &#x2F;&#x2F; g is not exported\n\nOr by marking each export individually:或者通过单独标记每个导出：\nexport function f &#123; return g() &#125;\nfunction g() &#123; &#125;\n\nThe latter style is more common but both are allowed, even in the same file.后者更常见， 但是都可以， 即使在同一个文件中。\nreadonly and constIn JavaScript, mutability is the default, although it allows variable declarations with const to declare that the reference is immutable. The referent is still mutable:在 JavaScript 中， 可变性是默认的， 即使它允许使用 const 声明的变量声明引用是不可变的。 引用仍然可变：\nconst a &#x3D; [1, 2, 3];\na.push(102); &#x2F;&#x2F; ):\na[0] &#x3D; 101; &#x2F;&#x2F; D:\n\nTypeScript additionally has a readonly modifier for properties.TypeScript 还有一个 readonly 属性修饰符。\ninterface Rx &#123;\n  readonly x: number;\n&#125;\nlet rx: Rx &#x3D; &#123; x: 1 &#125;;\nrx.x &#x3D; 12; &#x2F;&#x2F; error\n\nIt also ships with a mapped type Readonly that makes all properties readonly:它还有一个映射类型 Readonly&lt;T&gt;， 让所有属性都变成只读的：\ninterface X &#123;\n  x: number;\n&#125;\nlet rx: Readonly&lt;X&gt; &#x3D; &#123; x: 1 &#125;;\nrx.x &#x3D; 12; &#x2F;&#x2F; error\n\nAnd it has a specific ReadonlyArray type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:它还有一个特殊的 ReadonlyArray&lt;T&gt; 类型， 去除了侧影响的方法和防止写入数组索引， 同时还有这种类型的特殊语法：\nlet a: ReadonlyArray&lt;number&gt; &#x3D; [1, 2, 3];\nlet b: readonly number[] &#x3D; [1, 2, 3];\na.push(102); &#x2F;&#x2F; error\nb[0] &#x3D; 101; &#x2F;&#x2F; error\n\nYou can also use a const-assertion, which operates on arrays and object literals:你也可以使用 const 断言， 它操作了数组和对象字面量：\nlet a &#x3D; [1, 2, 3] as const;\na.push(102); &#x2F;&#x2F; error\na[0] &#x3D; 101; &#x2F;&#x2F; error\n\nHowever, none of these options are the default, so they are not consistently used in TypeScript code.但是， 没有这些选项是默认的， 因此它们不是一致地使用在 TypeScript 代码中。\nNext Steps下一步\nThis doc is a high level overview of the syntax and types you would use in everyday code. From here you should:此文档是日常代码中的语法和类型一个高级的概览， 从这里你应该：Read the full Handbook from start to finish (30m)阅读完整的手册（30分钟）Explore the Playground examples探索 Playground 示例\n5 分钟内了解 Typescript跳过，这部分比较简单，看原文吧，之后重点放到手册里。\n","slug":"2022-06-08ts-start","date":"2022-06-06T01:58:32.000Z","categories_index":"TypeScript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"ddb7ac9f9b94448e902641cf7e936ac1","title":"前端基础-HTTPS","content":"吐槽掘金\n后台有定时器在运行，一直发送请求，打开多个 web 标签页面，cpu 直接飙升到 100% +，鉴于掘金太卡，所以转载\n\n为什么要有 HTTPS在 HTTPS 出现之前，所有请求都是以明文方式送出的，那么如果有人在传输途中偷听或者抓包的话，你的所有通信内容都会泄漏。比较安全的方法是将通信内容加密在发送给对方。加密方法有两种，对称加密和非对称加密。\n对称加密\n对称加密指的是加密和解密用同一个密钥。\n但是在通信之前，客户端和服务端是不会有这样同一把密钥的。需要其中一方将密钥发送给对方。\n在整个传输过程没有任何验证操作，所以黑客也可以截取到这把密钥从而破译出加密的内容。所以纯对称加密是不安全的。\n\n非对称加密非对称加密指的是加密和解密用不同的密钥。可以是用私钥加密，公钥解密，也可以是用公钥加密，私钥解密。但是会有这种情况。\n\n服务端拥有私钥和公钥，将公钥发给客户端。既然客户端可以获得公钥，黑客也可以获得公钥。那么服务端发送给客户端的所有内容黑客也是可以解读的。\n客户端用公钥加密发送给服务端不受影响，因为黑客手上没有服务器的私钥。所以纯非对称加密也是不安全的。\n\n传输密钥的过程\n图解传输密钥的过程HTTPS 采用对称加密来加密通信内容，所用的密钥称为 A。用非对称加密来加密密钥 A 再发送给对方（有点绕）。只要密钥 A 不落入他人手中，那传输的数据就不会被别人破译。\n那么问题来了，要如何安全的将这把密钥送到对方手上呢？\n我们来看密钥的传输过程\n为什么 HTTPS 是可靠的？HTTPS 是可靠的，因为它解决了三个问题。\n\n加密通信，即使别人获取到了信息也没法复原成原来的信息。\n防止中间人攻击。黑客没法冒充服务端。因为在第 2 步，服务端给了客户端一个 CA 证书。\n\n\n如果客户端验证了这个证书，说明这个证书和公钥是由服务端发来的且真实可靠。\n如果客户端验证不了这个证书，就说明这个证书不可靠，有可能是假的。\n\n\nCA 证书的公信力CA 证书需要由公司或者个人发出申请，再通过邮箱验证等方法验证域名存在。避免了黑客冒充网站获取证书的可能。在技术层面上，CA 机构的公钥是写在操作系统或者浏览器里的。只有用 CA 机构的私钥加密的内容才能完成解密。确保了证书的确是 CA 机构发行的。\n\n密钥的作用最后让我们再来回顾一下每一把密钥的作用\nHTTPS 一定安全吗非全站 HTTPS 并不安全\n登录页面支持 HTTPS 不就行了，首页又没有涉及账户信息其实这是非常不安全的行为，黑客会利用这一点进行攻击，一般是以下流程：\n1.用户在首页点击「登录」，页面跳转到有 htps 的网银页面，但此时由于首页是 htp 请求，所以是明文的，这就会被黑客劫持 2.黑客劫持用户的跳转请求，将 https 网银页面地址转换为 http 的地址再发送给银行\n用户&lt;&#x3D;&#x3D;HTTP&#x3D;&#x3D;&gt;黑客&lt;&#x3D;&#x3D;HTTPS&#x3D;&#x3D;&gt;银行\n1.此时如果用户输入账户信息，那么会被中间的黑客获取，此时的账号密码就被泄露了\n好在是银行的网银页面,只支持 htps,因此上述攻击暂时是无效的\n参考资料【web 安全 3】【硬核】HTTPS 原理全解析\n作者：站在书脊之上链接：https://juejin.cn/post/6844904160089882631来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","slug":"2022-06-05https","date":"2022-06-05T03:55:17.000Z","categories_index":"前端基础","tags_index":"前端基础,面试,http","author_index":"举手摘月亮"},{"id":"e33992d78838483e28879a1cdf87c45e","title":"再学Vue3-7 最佳实践","content":"概览\n\n\n性能\n安全\n","slug":"2022-06-02vue-7","date":"2022-06-02T12:05:05.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"9392b2f9395b41b1da45c31165be4e75","title":"再学Vue3-8 typescript","content":"概览\n\n\n组合式\n选项式\n","slug":"2022-06-02vue-8","date":"2022-06-02T12:05:05.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"f63d02067666595ede9bc0ebd108b1ee","title":"再学Vue3-6 升级规模","content":"概览\n\n\n状态管理\n","slug":"2022-06-02vue-6","date":"2022-06-02T11:53:33.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"24ee6bb08e318ca140f4cc0224000a69","title":"再学Vue3-5 内置组件","content":"概览\n\n\nKeepAlive\nteleport·传送门\nSuspense\n过渡 \n","slug":"2022-06-02vue-5","date":"2022-06-02T11:45:19.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"2dcf5d3fa228390b9a53cb50e779c427","title":"再学Vue3-4 可重用性","content":"概览\n\n\n可重用性\n组合函数\n自定义指令\n插件","slug":"2022-06-02vue-4","date":"2022-06-02T10:49:24.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"64389360ee809707debd2fd41c5138f2","title":"再学Vue3-3 深入组件","content":"概览\n\n\n深入组件\n注册prop\n事件\n透传 Attribute\n插槽\n依赖注入\n异步组件\n可重用性\n组合函数\n自定义指令\n插件","slug":"2022-06-02vue-3","date":"2022-06-02T10:49:23.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"f9fd2a8578c770321fc9e0db644f4563","title":"再学Vue3-2 v3","content":"v3\n\n\n响应式基础\n计算属性\n生命周期\n侦听器\n模版 ref\n组件基础\n","slug":"2022-06-02vue-2","date":"2022-06-02T10:49:22.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"2620e5e38d0a5713fc7f864f91b17d5f","title":"再学Vue3-1 基础","content":"概览\n\nv2\n模版语法\n\n\n数据绑定\n\n\n事件绑定\n表单输入绑定\n插件\n","slug":"2022-06-02vue-1","date":"2022-06-02T10:49:21.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"98cc42407c73e25079ab5c02aa5f251b","title":"再学Vue3-0 概览","content":"vue3\n使用 proxy 重写了 vue2，并增加了组合式 api\n以下思维导图以vue3 文档内容为依据，在学习过程中绘制\n学习过程中对比了 vue3 和 react\n很长一段时间没看vue了，vue3一直没接触，媳妇不学。万一哪天媳妇需要用vue3了，没人带岂不是要失业，赶紧学起来～\n\n概览\n\n\n\n问题\n念叨着 渐进式 依赖收集 去学习vue指南\n\n\n","slug":"2022-06-02vue-0","date":"2022-06-02T10:49:20.000Z","categories_index":"vue","tags_index":"vue","author_index":"举手摘月亮"},{"id":"e7a12532b015cb78e0adb01f9bc03b9e","title":"react useState 错误使用","content":"Shareconst Share: FC&lt;ShareProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; entityType, entityCode &#125; &#x3D; props\n\n  const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;\n    value: props.value,\n    title: props.title,\n    shareId: props.shareId,\n    mappingPassword: props.mappingPassword,\n    passwordEnable: props.passwordEnable,\n    mappingState: props.mappingState,\n    expireTime: props.expireTime,\n    shortCode: props.shortCode,\n  &#125;)\n\n\n  const &#123; value &#125; &#x3D; state\n\n  ...\n\n  return (\n    &lt;div&gt;\n      &#123;renderBtn&#125;\n      &lt;ShareModal\n        entityType&#x3D;&#123;entityType&#125;\n        entityCode&#x3D;&#123;entityCode&#125;\n        &#123;...modalProps&#125;\n        state&#x3D;&#123;state&#125;\n        setState&#x3D;&#123;setState&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\n\nexport default Share\n\n\n\nShareModal\ninterface ShareModalProps extends ModalFuncProps &#123;\n  entityType: EntityType\n  entityCode: string\n  className?: string\n  state: StateProps\n  setState: (state: StateProps) &#x3D;&gt; void\n&#125;\n\nconst Copy &#x3D; (&#123; text, children &#125;: &#123; text: string; children: string &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;CopyToClipboard\n      text&#x3D;&#123;text&#125;\n      onCopy&#x3D;&#123;() &#x3D;&gt; &#123;\n        message.success(&#39;链接已复制&#39;)\n      &#125;&#125;\n    &gt;\n      &lt;span&gt;&#123;children&#125;&lt;&#x2F;span&gt;\n    &lt;&#x2F;CopyToClipboard&gt;\n  )\n&#125;\n\nconst ShareModal: FC&lt;ShareModalProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const [form] &#x3D; HookForm.useForm()\n\n  const &#123; state, setState, entityType, entityCode, ...restProps &#125; &#x3D; props\n\n  const &#123; value, title, mappingPassword, shortCode, expireTime &#125; &#x3D; state\n\n  const &#123;\n    onChange: toggle,\n    resetPassword: reset,\n    update,\n  &#125; &#x3D; useShare(&#123;\n    entityCode,\n    entityType,\n    state,\n    setState,\n  &#125;)\n\n\n  ....\n\n  return (\n    &lt;Modal\n      &#123;...restProps&#125;\n      className&#x3D;&#123;styles[&#39;share-modal-wrap&#39;]&#125;\n      title&#x3D;&quot;链接分享&quot;\n      destroyOnClose\n      width&#x3D;&#123;420&#125;\n      footer&#x3D;&#123;null&#125;\n    &gt;\n      &lt;ConditionComponent isShow&#x3D;&#123;value&#125;&gt;\n        ....\n        &lt;HookForm form&#x3D;&#123;form&#125; style&#x3D;&#123;&#123; marginBottom: 10, width: &#39;100%&#39; &#125;&#125; layout&#x3D;&quot;vertical&quot;&gt;\n          &lt;HookForm.Item noStyle shouldUpdate&gt;\n            &#123;() &#x3D;&gt; &#123;\n              const &#123; url, mappingPassword, expireTime &#125; &#x3D; form.getFieldsValue()\n              const text &#x3D; &#96;$&#123;url&#125;（密码：$&#123;mappingPassword&#125;）《$&#123;title&#125;》$&#123;moment(\n                expireTime,\n              ).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)&#125;过期&#96;\n              return (\n                &lt;HookForm.Item name&#x3D;&quot;url&quot; label&#x3D;&quot;&quot;&gt;\n                  &lt;Input\n                    className&#x3D;&#123;styles[&#39;share-copy&#39;]&#125;\n                    addonAfter&#x3D;&#123;&lt;Copy text&#x3D;&#123;text&#125;&gt;复制链接和密码&lt;&#x2F;Copy&gt;&#125;\n                    disabled\n                  &#x2F;&gt;\n                &lt;&#x2F;HookForm.Item&gt;\n              )\n            &#125;&#125;\n          &lt;&#x2F;HookForm.Item&gt;\n        &lt;&#x2F;HookForm&gt;\n      &lt;&#x2F;ConditionComponent&gt;\n    &lt;&#x2F;Modal&gt;\n  )\n&#125;\n\nexport default ShareModal\n\n\n用户反馈为什么分享的链接与要分享的链接对不上？\nuseCallbackuseCallback 受依赖项的影响，不更新，之前改过同事的代码，这次扫了一样，没有 callback，就这问题修改几个了\nuseState\n找了下数据ShareModal组件,看到两个入参state, setState ，我艹\n\n继续往上层找\n&lt;ShareModal\n  entityType&#x3D;&#123;entityType&#125;\n  entityCode&#x3D;&#123;entityCode&#125;\n  &#123;...modalProps&#125;\n  state&#x3D;&#123;state&#125; &#x2F;&#x2F; 😓\n  setState&#x3D;&#123;setState&#125; &#x2F;&#x2F;😓\n&#x2F;&gt;\n\n再往上找，useState 内部只执行一次，数据初始化完成不再改变\n\n\nconst [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;\n  value: props.value,\n  title: props.title,\n  shareId: props.shareId,\n  mappingPassword: props.mappingPassword,\n  passwordEnable: props.passwordEnable,\n  mappingState: props.mappingState,\n  expireTime: props.expireTime,\n  shortCode: props.shortCode,\n&#125;);\n\nconst &#123; value &#125; &#x3D; state;\n\n\n这里代码这么写，其他地方肯定也有这样的写法，😓\n\n改一下const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;&#125;);\n\nuseEffect(() &#x3D;&gt; &#123;\n  setState(&#123; ...props &#125;);\n&#125;, [props.shareId]);\n","slug":"2022-05-31bug","date":"2022-05-31T02:30:47.000Z","categories_index":"bug","tags_index":"React,bug","author_index":"举手摘月亮"},{"id":"f35528e9b34223f99b96c0561880d949","title":"前端基础-编程范式-函数式编程简单了解","content":"为什么要用函数编程\njs 为了实现面向对象的思想，做了很多事情，导致大家在学习 js 的时候，会遇到复杂的原型、原型链、继承，还有对人不友好的this ；\n而当我们用这些东西组合起来模拟面向对象的特性的时候，就更加痛苦了。但我们可以使用一种更友好的方式，函数式编程。\n\n简单来说就是：面向对象的思想在 js 中不是很好用\n什么是函数式编程函数式编程（functional programing）是编程范式之一。我们常见的范式还有面向过程、面向行为、面向对象等。\n范式：简单说就是编程的方法论。\n\n面向函数式编程：它的思维方式是把现实世界中的事物和事物之间的联系，抽象到程序世界中。\n面向对象编程：它的思维方式是把现实世界中的事物抽象成程序世界中的类和对象，然后通过封装，继承和多态来演示事物之间的联系。\n面向过程编程：简单解释就是按照步骤来实现。\n面向行为编程：它是函数式编程的衍生范型，将电脑运算平展为一系列的变化，并且避免使用程序指令以及堆叠的对象。\n\n函数式编程特点：\n程序的本质：就是利用计算机的计算能力将输入转化成对应的输出。\n函数式编程中的函数：指的不是编程语言里的函数，而是数学意义上的映射关系。比如 y&#x3D;sin(x) 中 x 和 y 值的映射关系。\n纯函数：相同的输入获得相同的输出（无副作用）。\n函数式编程：就是对数据(函数)映射关系的抽象。\n\n使用场景\n高阶函数\n闭包\n纯函数\n柯里化\n组合函数\n\n三大编程范式编程范式有以下三种：\n面向对象编程\n面向过程编程\n面向函数编程\n\n区别：\n面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性。\n面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离。\n函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。\n不过，它跟面向过程编程的区别在于，它的函数是无状态的。\n\n何为无状态？\n简单点讲就是，函数内部涉及的变量都是局部变量\n不会像面向对象编程那样，共享类成员变量\n也不会像面向过程编程那样，共享全局变量\n函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。\n\n总结：\n不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。\n比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念，\n最顶层都要有 main 函数执行入口，来组装编程单元（类、函数等）。\n只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数。\n\n参考三大编程范式\n","slug":"2022-05-28func","date":"2022-05-28T07:25:33.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"2e69f09f2b5424b80304135ea166c436","title":"wiki Laser Pen","content":"Laser PenLaser Pen 是一套用来在 web canvas 上绘制鼠标轨迹的工具集。\n使用场景wiki全屏演示时候，为了便于听众跟随演讲者进度，给鼠标轨迹加上标记。\n\n注：公司项目由于版权问题，不便演示\n初步上手首先在你的项目中添加对 Laser Pen 的依赖：\nyarn add laser-pen\n或者\nnpm i laser-pen\n\n然后监听鼠标的 move 事件，获取鼠标移动轨迹的坐标，并同时记录 move 事件触发时的时间戳。\n&#x2F;&#x2F; 获取 canvas 元素的坐标\nconst canvasDom &#x3D; document.querySelector(&#39;canvas&#39;)\nconst canvasPos &#x3D; canvasDom.getBoundingClientRect()\nconst ctx &#x3D; canvas.getContext(&#39;2d&#39;)\n&#x2F;&#x2F; 用来存储所有鼠标轨迹数据\nlet mouseTrack &#x3D; []\n&#x2F;&#x2F; 监听鼠标事件\ndocument.addEventListener(&#39;mousemove&#39;, (event) &#x3D;&gt; &#123;\n  mouseTrack.push(&#123;\n    x: event.clientX - canvasPos.x,\n    y: event.clientY - canvasPos.y,\n    time: Date.now(),\n  &#125;)\n&#125;)\n\n最后在调用 drawLaserPen 方法绘制鼠标轨迹\nimport &#123; drainPoints, drawLaserPen &#125; from &#39;laser-pen&#39;\n\nfunction draw() &#123;\n  &#x2F;&#x2F; 过滤掉一些失效的轨迹坐标\n  mouseTrack &#x3D; drainPoints(mouseTrack)\n  if (mouseTrack.length &gt;&#x3D; 3) &#123;\n    &#x2F;&#x2F; 绘制鼠标轨迹\n    drawLaserPen(ctx, mouseTrack)\n  &#125;\n  requestAnimation(draw)\n&#125;\n\n\n到这里，你应该已经可以在 canvas 上实现鼠标轨迹的绘制了。\n参数配置如果默认的轨迹效果不能满足你的要求，Laser Pen 还提供了一些接口让你可以方便的修改鼠标轨迹的样式。\n&#x2F;&#x2F; 设置延迟时间，mousemove 事件产生的坐标点在超过延迟时间后就不会被绘制，会直接影响轨迹的长度\nsetDelay: (millisecond: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最大宽度，轨迹是一条由粗变细的曲线，maxWidth 表示粗的那一头的线宽\nsetMaxWidth: (width: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最小宽度，轨迹是一条由粗变细的曲线，minWidth 表示细的那一头的线宽\nsetMinWidth: (width: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置曲线张力大小，张力越大拐点处越平滑，反之越尖锐\nsetTension: (t: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的最小透明度，轨迹是一条由不透明变透明的曲线，opacity 表示轨迹末尾的不透明度\nsetOpacity: (o: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹的颜色\nsetColor: (r: number, g: number, b: number) &#x3D;&gt; void;\n&#x2F;&#x2F; 设置轨迹头部是否是圆形\nsetRoundCap: (b: boolean) &#x3D;&gt; void;\n\n在任何时候调用上述接口修改鼠标轨迹的样式，都会在紧接着的下一次绘制中生效。所以如果你想实现一个类似 RGB 跑马灯的鼠标轨迹也是可以的。\n定制化开发如果上面的接口都不能满足你的要求，那么你就需要做一些定制化的开发了。\n绘制鼠标轨迹的过程大概分为 5 个步骤：\n清洗轨迹坐标数据根据轨迹坐标计算每个坐标的控制点通过坐标点和控制点数据生成 Bezier 曲线将上一步生成的曲线分割为更短的 Bezier 曲线，并计算每条曲线的绘制样式依次绘制每条 Bezier 曲线这 5 个步骤对应下面的第 1 到第 5 个接口，最后的 drawLaserPen 接口是对前面 5 个接口的组合。 如果直接调用 drawLaserPen 不能满足你的要求，你可以在前 5 个接口的基础上自行组合，实现你想要的效果。\n&#x2F;&#x2F; 去掉原始鼠标坐标数据中不合理的数据，包括超过延迟时间的坐标，和一些排列不合法的坐标\ndrainPoints: (originalPoints: IOriginalPointData[]) &#x3D;&gt; IOriginalPointData[];\n&#x2F;&#x2F; 根据鼠标坐标数据计算每个坐标点的前后控制点\ncalControlPoints: (points: IPoint[]) &#x3D;&gt; IControlPoint[];\n&#x2F;&#x2F; 将鼠标坐标数据和控制点数据组合为贝塞尔曲线\ntransformPointToBezier: (\n  points: IPoint[],\n  controlPoints: IControlPoint[]\n) &#x3D;&gt; Bezier[];\n&#x2F;&#x2F; 根据原始的贝塞尔曲线数据，计算出用于绘制的数据结构\ncalDrawingData: (\n  bzArray: Bezier[],\n  totalLength: number\n) &#x3D;&gt; IDrawingBezierData[];\n&#x2F;&#x2F; 根据计算出的绘制数据，将曲线绘制到画布上\ndrawDrawingBezierData: (\n  ctx: CanvasRenderingContext2D,\n  data: IDrawingBezierData[]\n) &#x3D;&gt; void;\n&#x2F;&#x2F; 一个方便简单使用的入口方法，直接通过处理好的鼠标坐标数据，绘制鼠标轨迹\ndrawLaserPen: (ctx: CanvasRenderingContext2D, points: IPoint[]) &#x3D;&gt; void;\n\n其他\nlaser-pen\n突然有个想法：王者荣耀的拖尾效果实现原理，是不是和这个类似？\n\n","slug":"2022-05-27wiki-laserPen","date":"2022-05-27T08:07:33.000Z","categories_index":"wiki","tags_index":"wiki","author_index":"举手摘月亮"},{"id":"8b8288a2a8637d5beee93bb6d37a8ba8","title":"redux-logger源码","content":"redux 日志中间件.\n├── core.js\n├── defaults.js\n├── diff.js\n├── helpers.js &#x2F;&#x2F; 一些帮助函数\n└── index.js\n\n0 directories, 5 files\ndefaultLoggerv3 版本，破坏性变更\n之前\nimport createLogger from &quot;redux-logger&quot;;\n\n之后\nimport &#123; createLogger &#125; from &quot;redux-logger&quot;;\n\n源码\n&#x2F;&#x2F; src&#x2F;index.js\n\nconst defaultLogger &#x3D; (&#123; dispatch, getState &#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n  if (typeof dispatch &#x3D;&#x3D;&#x3D; &quot;function&quot; || typeof getState &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n    &#x2F;&#x2F; createLogger，柯里化 工厂模式\n    return createLogger()(&#123; dispatch, getState &#125;);\n  &#125;\n  &#x2F;&#x2F; 如果没有传递dispatch和getState，打印错误信息\n  &#x2F;&#x2F; v3版本，破坏性变更, 根据《语义化版本》不看内容也知道有破坏性变更\n  &#x2F;&#x2F; Since 3.0.0 redux-logger exports by default logger with default settings\n  &#x2F;&#x2F; import createLogger from &#39;redux-logger&#39; &#x3D;&gt; import &#123; createLogger &#125; from &#39;redux-logger&#39;\n  console.error(&#96;\n[redux-logger v3] BREAKING CHANGE\n[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.\n[redux-logger v3] Change\n[redux-logger v3] import createLogger from &#39;redux-logger&#39;\n[redux-logger v3] to\n[redux-logger v3] import &#123; createLogger &#125; from &#39;redux-logger&#39;\n&#96;);\n&#125;;\n\nexport &#123; defaults, createLogger, defaultLogger as logger &#125;;\n\nexport default defaultLogger;\n\ncreateLogger\n使用传入的 options， 创建日志记录器\n\n&#x2F;**\n * Creates logger with following options\n * 创建日志记录器，配置如下：\n * @namespace\n * @param &#123;object&#125; options - options for logger\n * @param &#123;string | function | object&#125; options.level - console[level] 日志级别\n * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间\n * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳\n * @param &#123;object&#125; options.colors - custom colors 定制颜色\n * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现\n * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出\n * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组\n * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为\n * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换\n * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换\n * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换\n *\n * @returns &#123;function&#125; logger middleware 返回中间件\n *&#x2F;\nfunction createLogger(options &#x3D; &#123;&#125;) &#123;\n  const loggerOptions &#x3D; Object.assign(&#123;&#125;, defaults, options);\n\n  const &#123;\n    logger,\n    stateTransformer,\n    errorTransformer,\n    predicate,\n    logErrors,\n    diffPredicate,\n  &#125; &#x3D; loggerOptions;\n\n  &#x2F;&#x2F; Return if &#39;console&#39; object is not defined\n  &#x2F;&#x2F; 如果&#39;console&#39;对象未定义，返回\n  if (typeof logger &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);\n  &#125;\n\n  &#x2F;&#x2F; Detect if &#39;createLogger&#39; was passed directly to &#39;applyMiddleware&#39;.\n  &#x2F;&#x2F; 判断是否传递给applyMiddleware\n  if (options.getState &amp;&amp; options.dispatch) &#123;\n    &#x2F;&#x2F; eslint-disable-next-line no-console\n    console.error(&#96;[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n&#x2F;&#x2F; Logger with default options\nimport &#123; logger &#125; from &#39;redux-logger&#39;\nconst store &#x3D; createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n&#x2F;&#x2F; Or you can create your own logger with custom options http:&#x2F;&#x2F;bit.ly&#x2F;redux-logger-options\nimport &#123; createLogger &#125; from &#39;redux-logger&#39;\nconst logger &#x3D; createLogger(&#123;\n  &#x2F;&#x2F; ...options\n&#125;);\nconst store &#x3D; createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n&#96;);\n    &#x2F;&#x2F; 中间件书写套路\n    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);\n  &#125;\n\n  const logBuffer &#x3D; [];\n\n  return (&#123; getState &#125;) &#x3D;&gt;\n    (next) &#x3D;&gt;\n    (action) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; Exit early if predicate function returns &#39;false&#39; 如果predicate函数返回false，退出\n      if (typeof predicate &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; !predicate(getState, action)) &#123;\n        return next(action);\n      &#125;\n\n      const logEntry &#x3D; &#123;&#125;;\n\n      logBuffer.push(logEntry);\n\n      logEntry.started &#x3D; timer.now();\n      logEntry.startedTime &#x3D; new Date();\n      logEntry.prevState &#x3D; stateTransformer(getState());\n      logEntry.action &#x3D; action;\n\n      let returnedValue;\n      if (logErrors) &#123;\n        try &#123;\n          returnedValue &#x3D; next(action);\n        &#125; catch (e) &#123;\n          logEntry.error &#x3D; errorTransformer(e);\n        &#125;\n      &#125; else &#123;\n        returnedValue &#x3D; next(action);\n      &#125;\n\n      logEntry.took &#x3D; timer.now() - logEntry.started;\n      logEntry.nextState &#x3D; stateTransformer(getState());\n\n      const diff &#x3D;\n        loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;\n          ? diffPredicate(getState, action)\n          : loggerOptions.diff;\n\n      printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;));\n      logBuffer.length &#x3D; 0;\n\n      if (logEntry.error) throw logEntry.error;\n      return returnedValue;\n    &#125;;\n&#125;\n\ndefaults 默认配置\n&#x2F;&#x2F; src&#x2F;default.js\nexport default &#123;\n  level: &quot;log&quot;,\n  logger: console,\n  logErrors: true,\n  collapsed: undefined,\n  predicate: undefined,\n  duration: false,\n  timestamp: true,\n  stateTransformer: (state) &#x3D;&gt; state,\n  actionTransformer: (action) &#x3D;&gt; action,\n  errorTransformer: (error) &#x3D;&gt; error,\n  colors: &#123;\n    title: () &#x3D;&gt; &quot;inherit&quot;,\n    prevState: () &#x3D;&gt; &quot;#9E9E9E&quot;,\n    action: () &#x3D;&gt; &quot;#03A9F4&quot;,\n    nextState: () &#x3D;&gt; &quot;#4CAF50&quot;,\n    error: () &#x3D;&gt; &quot;#F20404&quot;,\n  &#125;,\n  diff: false,\n  diffPredicate: undefined,\n\n  &#x2F;&#x2F; Deprecated options 已废弃配置\n  transformer: undefined,\n&#125;;\n&#x2F;&#x2F; 字段释义\n&#x2F;**\n * Creates logger with following options\n * 创建日志记录器，配置如下：\n * @namespace\n * @param &#123;object&#125; options - options for logger\n * @param &#123;string | function | object&#125; options.level - console[level] 日志级别\n * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间\n * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳\n * @param &#123;object&#125; options.colors - custom colors 定制颜色\n * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现\n * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出\n * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组\n * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为\n * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换\n * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换\n * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换\n *\n * @returns &#123;function&#125; logger middleware 返回中间件\n *&#x2F;\n\n奇怪\n\n这两个配置在测试文件中，没找到相关测试代码\n\n &#x2F;&#x2F; 配置\n diff: false, &#x2F;&#x2F;\n diffPredicate: undefined,\n\n &#x2F;&#x2F; ...\n\n const diff &#x3D;\n       loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;\n         ? diffPredicate(getState, action)\n         : loggerOptions.diff;\n &#x2F;&#x2F; 打印日志中\n printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;));\n\n &#x2F;&#x2F; src&#x2F;core.js printBuffer的定义\nfunction printBuffer(buffer, options) &#123;\n   const &#123;\n     &#x2F;&#x2F; ...\n       diff,\n   &#125; &#x3D; options;\n   &#x2F;&#x2F; 如果开启\n   if (diff) &#123;\n     &#x2F;&#x2F; 执行了 diffLogger\n     diffLogger(prevState, nextState, logger, isCollapsed);\n   &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;diff.js\nexport default function diffLogger(prevState, newState, logger, isCollapsed) &#123;\n  &#x2F;&#x2F; import differ from &#39;deep-diff&#39;;计算对象差异化的包\n  const diff &#x3D; differ(prevState, newState);\n\n  try &#123;\n    if (isCollapsed) &#123;\n      logger.groupCollapsed(&#39;diff&#39;);\n    &#125; else &#123;\n      logger.group(&#39;diff&#39;);\n    &#125;\n  &#125; catch (e) &#123;\n    logger.log(&#39;diff&#39;);\n  &#125;\n  &#x2F;&#x2F; 有差异执行输出，这个差异包含类型kind E:编辑 N:新增 D:删除 A:数组\n  &#x2F;&#x2F; dictionary为对象，对kind值进行枚举\n  &#x2F;&#x2F; 遍历输出\n  if (diff) &#123;\n    diff.forEach((elem) &#x3D;&gt; &#123;\n      const &#123; kind &#125; &#x3D; elem;\n      const output &#x3D; render(elem);\n\n      logger.log(&#96;%c $&#123;dictionary[kind].text&#125;&#96;, style(kind), ...output);\n    &#125;);\n  &#125; else &#123;\n    logger.log(&#39;—— no diff ——&#39;);\n  &#125;\n\n  try &#123;\n    logger.groupEnd();\n  &#125; catch (e) &#123;\n    logger.log(&#39;—— diff end —— &#39;);\n  &#125;\n&#125;\n\n\nhelpers&#x2F;&#x2F; repeat + pad &#x3D; padLeft 左侧补零， es多少有个api\nexport const repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);\n\nexport const pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;\n&#x2F;&#x2F; 时间格式化\nexport const formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;\n\n&#x2F;&#x2F; Use performance API if it&#39;s available in order to get better precision\nexport const timer &#x3D;\n(typeof performance !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; performance !&#x3D;&#x3D; null) &amp;&amp; typeof performance.now &#x3D;&#x3D;&#x3D; &#39;function&#39; ?\n  performance :\n  Date;\n运行测试下\nconst repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);\n\nconst pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;\n\nconst formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;\n\nconsole.log(formatTime(new Date()))\n&#x2F;&#x2F; 输出\n18:58:15.667\n\n\n源码图\ndeep-diff\n看下两个对象比较的事例\n\nvar lhs &#x3D; &#123;\n\tname: &#39;my object&#39;,\n\tdescription: &#39;it\\&#39;s an object!&#39;,\n\tdetails: &#123;\n\t\tit: &#39;has&#39;,\n\t\tan: &#39;array&#39;,\n\t\twith: [&#39;a&#39;, &#39;few&#39;, &#39;elements&#39;]\n\t&#125;\n&#125;;\n\nvar rhs &#x3D; &#123;\n\tname: &#39;updated object&#39;,\n\tdescription: &#39;it\\&#39;s an object!&#39;,\n\tdetails: &#123;\n\t\tit: &#39;has&#39;,\n\t\tan: &#39;array&#39;,\n\t\twith: [&#39;a&#39;, &#39;few&#39;, &#39;more&#39;, &#39;elements&#39;, &#123; than: &#39;before&#39; &#125;]\n\t&#125;\n&#125;;\n\nvar differences &#x3D; deep.diff(lhs, rhs);\n\n\n&#x2F;&#x2F; 输出\n\n\n27 May 17:27:12 - [\n  DiffEdit &#123;\n    kind: &#39;E&#39;,\n    path: [ &#39;name&#39; ],\n    lhs: &#39;my object&#39;,\n    rhs: &#39;updated object&#39;\n  &#125;,\n  DiffArray &#123;\n    kind: &#39;A&#39;,\n    path: [ &#39;details&#39;, &#39;with&#39; ],\n    index: 4,\n    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#123; than: &#39;before&#39; &#125; &#125;\n  &#125;,\n  DiffArray &#123;\n    kind: &#39;A&#39;,\n    path: [ &#39;details&#39;, &#39;with&#39; ],\n    index: 3,\n    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#39;elements&#39; &#125;\n  &#125;,\n  DiffEdit &#123;\n    kind: &#39;E&#39;,\n    path: [ &#39;details&#39;, &#39;with&#39;, 2 ],\n    lhs: &#39;elements&#39;,\n    rhs: &#39;more&#39;\n  &#125;\n]\n","slug":"2022-05-27redux-logger","date":"2022-05-27T05:52:01.000Z","categories_index":"React","tags_index":"redux,源码","author_index":"举手摘月亮"},{"id":"98e904a0d3e9702a10dc20a22eaad4dd","title":"vscode i18n-ally","content":"国际化\n大型公司的国际化需求很高，需要支持多语言，比如中文、英文、日文等等。\ni18n-ally 是一个基于 vscode 的国际化工具，可以帮助你快速的实现国际化。\n\n背景\n如果经常做国际化的研发，应该很清楚，代码中写多语言，然而，多语言在项目中维护是非常困难的。\n当遇到大型项目，业务要做拆分成为微前端架构，多语言要在多个项目中维护，浪费时间不说，还可能造成不一致问题\n处理方式：\n将对应的多语言开发为 npm 包，在项目中引入\n拆多语言为一个应用平台，实现多项目共享，实现可视化交互（我们目前使用，自研 localize 平台，实现多语言管理）\n\n\n\n题外话应用平台\n\n动态生效： 修改多语言不需要重启、发布服务\n翻译管理：多人协同在线翻译\n版本管理： 记录翻译变更记录以及对应的操作人，方便定位与排错\n自动多区同步：只需在中国区修改，系统会自动同步到国外 5 区\n\n优点\n提示优雅，未处理的多语言会有提示\n编辑方便\n\n\n\n\n\n\nEnglish | 简体中文\n\n\n\n\n\n\n\n\n\n\n\n\nv2.0 is released with new Editor UI and Review System 🎉\n\n\n\nMigrate from v1.x\n\n\n\n\n\n\n\n\n\nMaintained by\n\n\nLokalise is the fastest growing language cloud technology made by developers, for developers.\nAs a collaborative productivity platform, it helps structure and automate the translation and localization process for any company in the world.\nLokalise是开发人员为开发人员开发的增长最快的语言云技术\n作为一个协作生产力平台，它可以帮助世界上任何公司构建和自动化翻译和本地化过程。\nLearn more\n\n\n\n\n\n\n\n📖 Docs 文档\n|\n💭 FAQ 问答\n|\n⚙️ Configs 配置\n|\n📜 Supported Formats 支持格式\n|\n🧱 Contribute 贡献\n\n\n\n\n\nInline Annotations 行内提示\n\n\nHover and Direct Actions 悬停和直接操作\n\n\nManage All Translations in One Place 在一个位置管理所有翻译\n\n\nEditor UI编辑界面 & Review System 预览系统\n\n\nExtract Translations from Code 从代码中提取翻译\n\n\nReport Missing Translations 报告缺失的翻译\n\n\nMachine Translation 机器翻译\n\n\nAnnotations for JSON and YAML 来源于JSON 和 YAML的提示\n\n\nGeneral Features\n\n\nSupports multi-root workspaces 支持多个工作空间\nSupports remote development 支持远程开发\nSupports numerous popular frameworks 支持多种流行框架\nSupports linked locale messages 链接的区域设置消息\nUses i18n for the extension itself, of course. 当然，将 i18n 用于扩展本身。 Translation List 翻译列表\n\n🌍 Multilingual Support 多语言支持This extension itself supports i18n as well. It will be auto-matched to the display language you use in your VS Code editor. We currently support the following languages.这个扩展支持多语言。它将自动匹配到你在 VS Code 编辑器中使用的语言。我们目前支持的语言有：\n\n\n\nLanguage\nMaintainer\nContributors\n\n\n\nEnglish 英语\n@antfu\n@rubjo, @EdRands\n\n\nSimplified Chinese (简体中文)\n@antfu\n\n\n\nTraditional Chinese (繁體中文)\n@antfu\n\n\n\nNorwegian (Norsk) 挪威语\n\n@rubjo\n\n\nSpanish (Español) 西班牙的\n\n@Baltimer\n\n\nJapanese (日本語) 日语\n\n@isdh\n\n\nDutch (Nederlands) 荷兰语\n\n@Niekvdm, @Excalibaard\n\n\nPortuguese (Brazilian) 葡萄牙语\n\n@Ibcs16\n\n\nFrench (Français) 法语\n\n@Nicoxx45, @eri\n\n\nSwedish (Svenska)瑞典语\n@vladdeSV\n\n\n\nUkrainian (Українська) 乌克兰语\n\n@uhodav\n\n\nRussian (Русский) 俄语\n\n@uhodav\n\n\nGerman (Deutsch) 德语\n@alexanderniebuhr\n\n\n\nTurkish (Türkçe) 土耳其语\n\n@eri\n\n\n帮忙翻译\n\n\n\n\n\n\n\n\n\n👨‍💻 如果您想帮助一种语言的翻译更新，请在维护者字段中输入您的姓名。我会在需要的时候提到你。非常感谢。\n❤️ 感谢此插件的灵感来源于think2011&#x2F;vscode-vue-i18n. 如果没有@think2011,i18n-ally 不会存在\n对 Vue 单文件组件（SFC）的支持由[kazupon&#x2F;Vue-i18n-locale-message]提供支持(https://github.com/kazupon/vue-i18n-locale-message)，它是由vue-i18n的作者创建的。谢谢你做这个！\n代码共享者非常感谢所有杰出的贡献者：\n协议MIT License © 2019-PRESENT Anthony Fu\nMIT License © 2018-2019 think2011\n安装Visual Studio Code&gt;Other&gt;i18n Ally\n使用参考资料github 官网\n","slug":"2022-05-27i18n","date":"2022-05-27T02:47:24.000Z","categories_index":"工具","tags_index":"工具,增效,vscode","author_index":"举手摘月亮"},{"id":"ef136ce7ac94dd6f9c2f35712eef1e47","title":"redux-thunk源码","content":"源码版本v2.4.1\n用途\n通过redux源码applyMiddleware了解到，是对store.dispatch进行增强\n可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。\n可以在这个函数中执行一些异步的操作\n\nexport function addCount() &#123;\n  return &#123;type: ADD_COUNT&#125;\n&#125; \nexport function addCountAsync() &#123;\n  return dispatch &#x3D;&gt; &#123; &#x2F;&#x2F; dispatch对应源码的 ： action(dispatch, getState, extraArgument);的第一个参数\n    setTimeout( () &#x3D;&gt; &#123;\n      dispatch(addCount())\n    &#125;,2000)\n  &#125;\n&#125;\n\n\naddCountAsync函数就返回了一个函数，将dispatch作为函数的第一个参数传递进去，在函数内进行异步操作就可以了。\n\npackage.json\n这个文件结构与redux、react-redux相比，没有什么特别之处，这里及以后如无必要不在进行阅读\n简单扫一眼就好\n\n源码&#x2F;** A function that accepts a potential &quot;extra argument&quot; value to be injected later,\n * and returns an instance of the thunk middleware that uses that value\n *&#x2F;\n&#x2F;** 一个函数接收一个可能的&quot;extra argument&quot;值，并返回一个thunk中间件，它使用这个值 *&#x2F;\nfunction createThunkMiddleware&lt;\n  State &#x3D; any,\n  BasicAction extends Action &#x3D; AnyAction,\n  ExtraThunkArg &#x3D; undefined\n&gt;(extraArgument?: ExtraThunkArg) &#123;\n  &#x2F;&#x2F; Standard Redux middleware definition pattern:\n  &#x2F;&#x2F; 标准Redux中间件定义模式:\n  &#x2F;&#x2F; See: https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#writing-custom-middleware\n  const middleware: ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt; &#x3D;\n    (&#123; dispatch, getState &#125;) &#x3D;&gt; (next) &#x3D;&gt;  (action) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; The thunk middleware looks for any functions that were passed to &#96;store.dispatch&#96;.\n      &#x2F;&#x2F; If this &quot;action&quot; is really a function, call it and return the result.\n      &#x2F;&#x2F; 这个thunk中间件会查找store.dispatch传入的任何函数。如果这个&quot;action&quot;是一个函数，调用它并返回结果。\n      if (typeof action &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n        &#x2F;&#x2F; Inject the store&#39;s &#96;dispatch&#96; and &#96;getState&#96; methods, as well as any &quot;extra arg&quot;\n        &#x2F;&#x2F; 注入store的dispatch和getState方法，以及任意的&quot;extra arg&quot;\n        return action(dispatch, getState, extraArgument);\n      &#125;\n      &#x2F;&#x2F; 否则，像往常一样将操作传递给中间件链\n      &#x2F;&#x2F; Otherwise, pass the action down the middleware chain as usual\n      return next(action);\n    &#125;;\n  return middleware;\n&#125;\n中间件模式\n柯里化：将一个函数的参数分解成多个参数，并且返回一个新的函数，这个新的函数可以被调用，并且返回原函数的结果。\nconst anotherExampleMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;\n  &#x2F;&#x2F; Do something in here, when each action is dispatched\n\n  return next(action)\n&#125;\nstoreAPI\n&#x2F;&#x2F; storeAPI\n\nconst store &#x3D; &#123;\n  dispatch: dispatch as Dispatch&lt;A&gt;,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n工厂模式\n\nconst thunk &#x3D; createThunkMiddleware() as ThunkMiddleware &amp; &#123;\n  withExtraArgument&lt;\n    ExtraThunkArg,\n    State &#x3D; any,\n    BasicAction extends Action &#x3D; AnyAction\n  &gt;(\n    extraArgument: ExtraThunkArg\n  ): ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt;\n&#125;\n\n&#x2F;&#x2F; Attach the factory function so users can create a customized version\n&#x2F;&#x2F; with whatever &quot;extra arg&quot; they want to inject into their thunks\n&#x2F;&#x2F; 尝试将工厂函数附加到用户可以创建任何额外的&quot;extra arg&quot;的thunk中间件\nthunk.withExtraArgument &#x3D; createThunkMiddleware\n\nexport default thunk\n参考redux-thunk源码Redux中间件之redux-thunk使用详解\n","slug":"2022-05-27redux-thunk","date":"2022-05-27T01:21:50.000Z","categories_index":"React","tags_index":"redux,源码,redux-thunk","author_index":"举手摘月亮"},{"id":"5df43a7a7d0a76be0dcfbc13fca3f3d6","title":"js 代码注释","content":"代码注释//这种js注释代码在vscode其他地方引用时候，没有提示， 如果需要有提示，需要写成/** 提示 **/\n写法1\nexport enum ELeaveType &#123;\n  MATERNITY_ &#x3D; 17, &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),\n&#125;\n写法2\nexport enum ELeaveType &#123;\n  &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),\n  MATERNITY_ &#x3D; 17, \n&#125;\n\n有提示注释写法export enum ELeaveType &#123;\n...\n  &#x2F;**&quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),**&#x2F;\n  MATERNITY_ &#x3D; 17, \n...\n&#125;\n\n\n","slug":"2022-05-26code","date":"2022-05-26T07:31:20.000Z","categories_index":"code","tags_index":"code","author_index":"举手摘月亮"},{"id":"da6549350c9a9d927d67bdb10bc76a3c","title":"redux 源码 2","content":"redux 简介Predictable state container for JavaScript apps\n字面意思\njs 应用可预测状态容器\n\n\n怎么用，为什么用看官网。。。\ncreateStore代码注释如下\n\nredux store 持有 state 树，唯一可以改变 store 中数据的方式是 dispatch\n在你的 app 中应该有唯一一个 store.为了区分不同部分响应操作的的状态树，可以将几个 reducer 通过 combinereducers 合并为一个 reducer\n一个根据当前 state 和行为返回新 state 的函数\n初始 state，\nstore 中间件。可以使用第三方中间件增强 store\nredux store 可以读取 state，dispatch 行为，订阅改变\n\n&#x2F;**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call &#96;dispatch()&#96; on it.\n *\n * redux store持有state树，唯一可以改变store中数据的方式是dispatch\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using &#96;combineReducers&#96;.\n *\n * 在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer\n *\n * @param reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * 一个根据当前state和行为返回新state的函数\n *\n * @param preloadedState The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use &#96;combineReducers&#96; to produce the root reducer function, this must be\n * an object with the same shape as &#96;combineReducers&#96; keys.\n *\n * 初始state，\n *\n * @param enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is &#96;applyMiddleware()&#96;.\n *\n * store中间件。可以使用第三方中间件增强store\n *\n * @returns A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n *\n * redux store 可以读取state，dispatch行为，订阅改变\n *&#x2F;\n\n函数声明\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext;\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt;, &#x2F;&#x2F; &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext;\n\nexport default function createStore&lt;\n  S,\n  A extends Action,\n  Ext &#x3D; &#123;&#125;,\n  StateExt &#x3D; never\n&gt;(\n  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer\n  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;, &#x2F;&#x2F;初始状态\n  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件\n\n  &#x2F;&#x2F; 这里可以看到 preloadedState的参数| StoreEnhancer&lt;Ext, StateExt&gt; 与 enhancer类型一致， 这里处理第二参数可能是 enhancer\n  &#x2F;&#x2F; 代码主体分有做判断：\n  &#x2F;&#x2F; if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  &#x2F;&#x2F;   enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  &#x2F;&#x2F;   preloadedState &#x3D; undefined\n  &#x2F;&#x2F; &#125;\n): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;&#125;\n\ncreateStore 主体代码\n\n一些入参校验\n\nif (\n  (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||\n  (typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof arguments[3] &#x3D;&#x3D;&#x3D; &#39;function&#39;)\n) &#123;\n  throw new Error(\n    &#39;It looks like you are passing several store enhancers to &#39; +\n      &#39;createStore(). This is not supported. Instead, compose them &#39; +\n      &#39;together to a single function. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#creating-a-store-with-enhancers for an example.&#39;\n  )\n&#125;\n\nif (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;\n  preloadedState &#x3D; undefined\n&#125;\n\nif (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  if (typeof enhancer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new Error(\n      &#96;Expected the enhancer to be a function. Instead, received: &#39;$&#123;kindOf(\n        enhancer\n      )&#125;&#39;&#96;\n    )\n  &#125;\n\n  return enhancer(createStore)(\n    reducer,\n    preloadedState as PreloadedState&lt;S&gt;\n  ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n&#125;\n\nif (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n  throw new Error(\n    &#96;Expected the root reducer to be a function. Instead, received: &#39;$&#123;kindOf(\n      reducer\n    )&#125;&#39;&#96;\n  )\n&#125;\n\n&#x2F;&#x2F; 当前reducer\nlet currentReducer &#x3D; reducer\n&#x2F;&#x2F; 当前状态\nlet currentState &#x3D; preloadedState as S\n&#x2F;&#x2F; 当前订阅\nlet currentListeners: (() &#x3D;&gt; void)[] | null &#x3D; []\n&#x2F;&#x2F; 新的订阅\nlet nextListeners &#x3D; currentListeners\nlet isDispatching &#x3D; false\n\n\n\n&#x2F;**\n * This makes a shallow copy of currentListeners so we can use\n * nextListeners as a temporary list while dispatching.\n *\n * This prevents any bugs around consumers calling\n * subscribe&#x2F;unsubscribe in the middle of a dispatch.\n *&#x2F;\n&#x2F;&#x2F; 浅拷贝当前currentListeners得到 nextListeners 用于 dispatching\n\n&#x2F;&#x2F; 确定新的可变监听\nfunction ensureCanMutateNextListeners() &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 获取store的状态\nfunction getState(): S &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 传入监听，返回监听移除的函数\nfunction subscribe(listener: () &#x3D;&gt; void) &#123;\n  。。。\n\n  return function unsubscribe() &#123;\n    。。。。\n  &#125;\n&#125;\n\n\nfunction dispatch(action: A) &#123;\n  。。。\n&#125;\n\n&#x2F;&#x2F; 用于同构更新reducer\nfunction replaceReducer&lt;NewState, NewActions extends A&gt;(\n  nextReducer: Reducer&lt;NewState, NewActions&gt;\n): Store&lt;ExtendState&lt;NewState, StateExt&gt;, NewActions, StateExt, Ext&gt; &amp; Ext &#123;\n  。。。\n&#125;\n\n&#x2F;**\n * Interoperability point for observable&#x2F;reactive libraries.\n * @returns A minimal observable of state changes.\n * For more information, see the observable proposal:\n * https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-observable\n *&#x2F;\n&#x2F;&#x2F; 实现小型观察状态变更\nfunction observable() &#123;\n  。。。\n&#125;\n&#x2F;&#x2F; 当store被创建，初始化操作会被dispatch，，每个reducer会返回最初的state. 有效地填充初始状态树。\ndispatch(&#123; type: ActionTypes.INIT &#125; as A)\n\n\nconst store &#x3D; &#123;\n  dispatch: dispatch as Dispatch&lt;A&gt;,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext\n\nreturn store &#x2F;&#x2F; store上的api我们又熟悉了\n\n\n\nensureCanMutateNextListeners\n\n浅拷贝当前 currentListeners 得到 nextListeners 用于 dispatching\n\nfunction ensureCanMutateNextListeners() &#123;\n  if (nextListeners &#x3D;&#x3D;&#x3D; currentListeners) &#123;\n    nextListeners &#x3D; currentListeners.slice();\n  &#125;\n&#125;\n\ngetState\n\n获取 store 的状态\n\nfunction getState(): S &#123;\n  if (isDispatching) &#123;\n    throw new Error(\n      &quot;You may not call store.getState() while the reducer is executing. &quot; +\n        &quot;The reducer has already received the state as an argument. &quot; +\n        &quot;Pass it down from the top reducer instead of reading it from the store.&quot;\n    );\n  &#125;\n\n  return currentState as S;\n&#125;\n\nsubscribe\n&#x2F;**\n * Adds a change listener. It will be called any time an action is dispatched,\n * and some part of the state tree may potentially have changed. You may then\n * call &#96;getState()&#96; to read the current state tree inside the callback.\n *\n * You may call &#96;dispatch()&#96; from a change listener, with the following\n * caveats:\n *\n * 1. The subscriptions are snapshotted just before every &#96;dispatch()&#96; call.\n * If you subscribe or unsubscribe while the listeners are being invoked, this\n * will not have any effect on the &#96;dispatch()&#96; that is currently in progress.\n * However, the next &#96;dispatch()&#96; call, whether nested or not, will use a more\n * recent snapshot of the subscription list.\n *\n * 2. The listener should not expect to see all state changes, as the state\n * might have been updated multiple times during a nested &#96;dispatch()&#96; before\n * the listener is called. It is, however, guaranteed that all subscribers\n * registered before the &#96;dispatch()&#96; started will be called with the latest\n * state by the time it exits.\n *\n * @param listener A callback to be invoked on every dispatch.\n * @returns A function to remove this change listener.\n *&#x2F;\n&#x2F;&#x2F; 上述注释\n&#x2F;** 添加一个监听，在action被触发时候会调用，state会进行更新，在回调中可以用getState方法获取当前状态树\n * 两个注意：订阅的是在每个dispatch之前的快照，\n * 1.\n * 订阅是在每次&#39;dispatch（）&#39;调用之前进行快照的。\n * 如果在调用侦听器时订阅或取消订阅，这将不会对当前正在进行的“dispatch（）”产生任何影响。\n * 但是，下一个&#39;dispatch（）&#39;调用（无论是否嵌套）将使用订阅列表的最新快照。\n * 2。\n * 监听器不应该期望看到所有的状态更改，因为在调用监听器之前，状态可能在嵌套的&#39;dispatch（）&#39;期间被多次更新。\n * 但是，可以保证在“dispatch（）”启动之前注册的所有订阅者在退出时都将以最新状态调用。\n * *&#x2F;\nfunction subscribe(listener: () &#x3D;&gt; void) &#123;\n  if (typeof listener !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(\n      &#96;Expected the listener to be a function. Instead, received: &#39;$&#123;kindOf(\n        listener\n      )&#125;&#39;&#96;\n    );\n  &#125;\n\n  if (isDispatching) &#123;\n    throw new Error(\n      &quot;You may not call store.subscribe() while the reducer is executing. &quot; +\n        &quot;If you would like to be notified after the store has been updated, subscribe from a &quot; +\n        &quot;component and invoke store.getState() in the callback to access the latest state. &quot; +\n        &quot;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&quot;\n    );\n  &#125;\n\n  let isSubscribed &#x3D; true;\n\n  ensureCanMutateNextListeners();\n  nextListeners.push(listener); &#x2F;&#x2F; 增加\n\n  return function unsubscribe() &#123;\n    if (!isSubscribed) &#123;\n      return;\n    &#125;\n\n    if (isDispatching) &#123;\n      throw new Error(\n        &quot;You may not unsubscribe from a store listener while the reducer is executing. &quot; +\n          &quot;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&quot;\n      );\n    &#125;\n\n    isSubscribed &#x3D; false;\n\n    ensureCanMutateNextListeners();\n    const index &#x3D; nextListeners.indexOf(listener);\n    nextListeners.splice(index, 1); &#x2F;&#x2F; 移除\n    currentListeners &#x3D; null;\n  &#125;;\n&#125;\n\ndispatch\n&#x2F;**\n * Dispatches an action. It is the only way to trigger a state change.\n *\n * The &#96;reducer&#96; function, used to create the store, will be called with the\n * current state tree and the given &#96;action&#96;. Its return value will\n * be considered the **next** state of the tree, and the change listeners\n * will be notified.\n *\n * The base implementation only supports plain object actions. If you want to\n * dispatch a Promise, an Observable, a thunk, or something else, you need to\n * wrap your store creating function into the corresponding middleware. For\n * example, see the documentation for the &#96;redux-thunk&#96; package. Even the\n * middleware will eventually dispatch plain object actions using this method.\n *\n * @param action A plain object representing “what changed”. It is\n * a good idea to keep actions serializable so you can record and replay user\n * sessions, or use the time travelling &#96;redux-devtools&#96;. An action must have\n * a &#96;type&#96; property which may not be &#96;undefined&#96;. It is a good idea to use\n * string constants for action types.\n *\n * @returns For convenience, the same action object you dispatched.\n *\n * Note that, if you use a custom middleware, it may wrap &#96;dispatch()&#96; to\n * return something else (for example, a Promise you can await).\n *&#x2F;\nfunction dispatch(action: A) &#123;\n  if (!isPlainObject(action)) &#123;\n    &#x2F;&#x2F; 只能是简单的对象\n    throw new Error(\n      &#96;Actions must be plain objects. Instead, the actual type was: &#39;$&#123;kindOf(\n        action\n      )&#125;&#39;. You may need to add middleware to your store setup to handle dispatching other values, such as &#39;redux-thunk&#39; to handle dispatching functions. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#middleware and https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-6-async-logic#using-the-redux-thunk-middleware for examples.&#96;\n    );\n  &#125;\n\n  if (typeof action.type &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n    throw new Error(\n      &#39;Actions may not have an undefined &quot;type&quot; property. You may have misspelled an action type string constant.&#39;\n    );\n  &#125;\n\n  if (isDispatching) &#123;\n    throw new Error(&quot;Reducers may not dispatch actions.&quot;);\n  &#125;\n\n  try &#123;\n    isDispatching &#x3D; true;\n    currentState &#x3D; currentReducer(currentState, action); &#x2F;&#x2F; 传入当前状态和操作，返回新的状态\n  &#125; finally &#123;\n    isDispatching &#x3D; false;\n  &#125;\n\n  const listeners &#x3D; (currentListeners &#x3D; nextListeners); &#x2F;&#x2F; 触发更新\n  for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;\n    const listener &#x3D; listeners[i];\n    listener();\n  &#125;\n\n  return action;\n&#125;\n\ncombineReducers\n使用时候以键值对形式存在使用\n\nimport useInfoReducer from &quot;.&#x2F;userInfo&quot;;\nimport recordReducer from &quot;.&#x2F;record&quot;;\n\nconst rootReducer &#x3D; combineReducers(&#123;\n  useInfoReducer,\n  recordReducer,\n&#125;);\n\nconst store &#x3D; createStore(rootReducer);\n\n源码\n\n返回不期望的 state 型警告信息\n\nfunction getUnexpectedStateShapeWarningMessage(\n  inputState: object,\n  reducers: ReducersMapObject,\n  action: Action,\n  unexpectedKeyCache: &#123; [key: string]: true &#125;\n) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers);\n  const argumentName &#x3D;\n    action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.INIT\n      ? &quot;preloadedState argument passed to createStore&quot;\n      : &quot;previous state received by the reducer&quot;;\n\n  if (reducerKeys.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return (\n      &quot;Store does not have a valid reducer. Make sure the argument passed &quot; +\n      &quot;to combineReducers is an object whose values are reducers.&quot;\n    );\n  &#125;\n\n  if (!isPlainObject(inputState)) &#123;\n    return (\n      &#96;The $&#123;argumentName&#125; has unexpected type of &quot;$&#123;kindOf(\n        inputState\n      )&#125;&quot;. Expected argument to be an object with the following &#96; +\n      &#96;keys: &quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;&#96;\n    );\n  &#125;\n\n  const unexpectedKeys &#x3D; Object.keys(inputState).filter(\n    (key) &#x3D;&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]\n  );\n\n  unexpectedKeys.forEach((key) &#x3D;&gt; &#123;\n    unexpectedKeyCache[key] &#x3D; true;\n  &#125;);\n\n  if (action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length &gt; 0) &#123;\n    return (\n      &#96;Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &quot;keys&quot; : &quot;key&quot;&#125; &#96; +\n      &#96;&quot;$&#123;unexpectedKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot; found in $&#123;argumentName&#125;. &#96; +\n      &#96;Expected to find one of the known reducer keys instead: &#96; +\n      &#96;&quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;. Unexpected keys will be ignored.&#96;\n    );\n  &#125;\n&#125;\n&#x2F;&#x2F; 对 reducer型进行断言\nfunction assertReducerShape(reducers: ReducersMapObject) &#123;\n  Object.keys(reducers).forEach((key) &#x3D;&gt; &#123;\n    const reducer &#x3D; reducers[key];\n    const initialState &#x3D; reducer(undefined, &#123; type: ActionTypes.INIT &#125;);\n\n    if (typeof initialState &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n      throw new Error(\n        &#x2F;&#x2F; 初始化initialState时候可以用null,但是不可以用undefined\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined during initialization. &#96; +\n          &#96;If the state passed to the reducer is undefined, you must &#96; +\n          &#96;explicitly return the initial state. The initial state may &#96; +\n          &#96;not be undefined. If you don&#39;t want to set a value for this reducer, &#96; +\n          &#96;you can use null instead of undefined.&#96;\n      );\n    &#125;\n\n    if (\n      typeof reducer(undefined, &#123;\n        type: ActionTypes.PROBE_UNKNOWN_ACTION(),\n      &#125;) &#x3D;&#x3D;&#x3D; &quot;undefined&quot;\n    ) &#123;\n      throw new Error(\n        &#x2F;&#x2F; 1.随机类型&#x2F; redux&#x2F;*类型 的操作类型为redux私有，不允许使用\n        &#x2F;&#x2F; 2.初始化状态不可以是undefined,\n        &#x2F;&#x2F; 3.新状态如果是undefined的，必须返回初始状态\n        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. &#96; +\n          &#96;Don&#39;t try to handle &#39;$&#123;ActionTypes.INIT&#125;&#39; or other actions in &quot;redux&#x2F;*&quot; &#96; +\n          &#96;namespace. They are considered private. Instead, you must return the &#96; +\n          &#96;current state for any unknown actions, unless it is undefined, &#96; +\n          &#96;in which case you must return the initial state, regardless of the &#96; +\n          &#96;action type. The initial state may not be undefined, but can be null.&#96;\n      );\n    &#125;\n  &#125;);\n&#125;\n\n&#x2F;&#x2F; combineReducers的实现，其实就是将多个值，合并在一个对象中\nexport default function combineReducers(reducers: ReducersMapObject) &#123;\n  const reducerKeys &#x3D; Object.keys(reducers);\n  const finalReducers: ReducersMapObject &#x3D; &#123;&#125;;\n  for (let i &#x3D; 0; i &lt; reducerKeys.length; i++) &#123;\n    const key &#x3D; reducerKeys[i];\n\n    if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n      finalReducers[key] &#x3D; reducers[key];\n    &#125;\n  &#125;\n  const finalReducerKeys &#x3D; Object.keys(finalReducers);\n\n  &#x2F;&#x2F; This is used to make sure we don&#39;t warn about the same\n  &#x2F;&#x2F; keys multiple times.\n  &#x2F;&#x2F;这用于确保我们不会多次警告相同的key。\n  let unexpectedKeyCache: &#123; [key: string]: true &#125;;\n\n  return function combination(\n    state: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;,\n    action: AnyAction\n  ) &#123;\n    &#x2F;&#x2F;校验信息...\n\n    let hasChanged &#x3D; false;\n    const nextState: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;;\n    for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;\n      const key &#x3D; finalReducerKeys[i];\n      &#x2F;&#x2F; reducer\n      const reducer &#x3D; finalReducers[key];\n      &#x2F;&#x2F; 之前状态\n      const previousStateForKey &#x3D; state[key];\n      &#x2F;&#x2F; 新状态\n      const nextStateForKey &#x3D; reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n        const actionType &#x3D; action &amp;&amp; action.type;\n        throw new Error(\n          &#96;When called with an action of type $&#123;\n            actionType ? &#96;&quot;$&#123;String(actionType)&#125;&quot;&#96; : &quot;(unknown type)&quot;\n          &#125;, the slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined. &#96; +\n            &#96;To ignore an action, you must explicitly return the previous state. &#96; +\n            &#96;If you want this reducer to hold no value, you can return null instead of undefined.&#96;\n        );\n      &#125;\n      nextState[key] &#x3D; nextStateForKey;\n      &#x2F;&#x2F; 判断是否发生更新\n      hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey;\n    &#125;\n    hasChanged &#x3D;\n      hasChanged || finalReducerKeys.length !&#x3D;&#x3D; Object.keys(state).length;\n    &#x2F;&#x2F; 更新返回新的状态，否则返回之前状态\n    return hasChanged ? nextState : state;\n  &#125;;\n&#125;\n\nbindActionCreators\n给 action 包裹层 dispatch\naction 有两种类型： 函数、键值对\n\nexport default function bindActionCreators(\n  actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject,\n  dispatch: Dispatch\n) &#123;\n  &#x2F;&#x2F; 函数类型直接bindActionCreator返回\n  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n    return bindActionCreator(actionCreators, dispatch);\n  &#125;\n\n  if (typeof actionCreators !&#x3D;&#x3D; &quot;object&quot; || actionCreators &#x3D;&#x3D;&#x3D; null) &#123;\n    throw new Error(\n      &#96;bindActionCreators expected an object or a function, but instead received: &#39;$&#123;kindOf(\n        actionCreators\n      )&#125;&#39;. &#96; +\n        &#96;Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?&#96;\n    );\n  &#125;\n\n  const boundActionCreators: ActionCreatorsMapObject &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 对象遍历调用bindActionCreator\n  for (const key in actionCreators) &#123;\n    const actionCreator &#x3D; actionCreators[key];\n    if (typeof actionCreator &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;\n      boundActionCreators[key] &#x3D; bindActionCreator(actionCreator, dispatch);\n    &#125;\n  &#125;\n  return boundActionCreators;\n&#125;\n\n使用及测试代码见\nredux/test/typescript/actionCreators.ts\nbindActionCreator\n&#x2F;&#x2F; 作用是每个actionCreator增加一个dispatch包裹\nfunction bindActionCreator&lt;A extends AnyAction &#x3D; AnyAction&gt;(\n  actionCreator: ActionCreator&lt;A&gt;,\n  dispatch: Dispatch\n) &#123;\n  return function (this: any, ...args: any[]) &#123;\n    return dispatch(actionCreator.apply(this, args)); &#x2F;&#x2F; 主要代码\n  &#125;;\n&#125;\n\napplyMiddleware\n中间件\n对 store 能力进行增强\n\nexport default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer&lt;any&gt; &#123;\n  return (createStore: StoreEnhancerStoreCreator) &#x3D;&gt;\n    &lt;S, A extends AnyAction&gt;(\n      reducer: Reducer&lt;S, A&gt;,\n      preloadedState?: PreloadedState&lt;S&gt;\n    ) &#x3D;&gt; &#123;\n      const store &#x3D; createStore(reducer, preloadedState)\n\n\n      &#x2F;&#x2F; 声明\n      let dispatch: Dispatch &#x3D; () &#x3D;&gt; &#123;\n        throw new Error(\n          &#39;Dispatching while constructing your middleware is not allowed. &#39; +\n            &#39;Other middleware would not be applied to this dispatch.&#39;\n        )\n      &#125;\n\n      const middlewareAPI: MiddlewareAPI &#x3D; &#123;\n        getState: store.getState,\n                                      &#x2F;&#x2F;使用上述函数进行\n        dispatch: (action, ...args) &#x3D;&gt; dispatch(action, ...args)\n      &#125;\n      &#x2F;&#x2F; 中间件数组\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n\n\n      &#x2F;&#x2F; 增强的是dispatch\n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;\n\n\n&#96;&#96;&#96;ts\n\n      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n\n      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)\n\n      return &#123;\n        ...store,\n        dispatch\n      &#125;\n    &#125;\n&#125;\n\ncompose\n洋葱模型使用\n\ncompose(f, g, h)\n(...args) &#x3D;&gt; f(g(h(...args)))\n\n\n源码\nexport default function compose(...funcs: Function[]) &#123;\n  &#x2F;&#x2F; 参数长度判断\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line\n    return &lt;T&gt;(arg: T) &#x3D;&gt; arg;\n  &#125;\n  &#x2F;&#x2F; 长度为1\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0];\n  &#125;\n  &#x2F;&#x2F; 主要代码一行\n  return funcs.reduce(\n    (a, b) &#x3D;&gt;\n      (...args: any) &#x3D;&gt;\n        a(b(...args))\n  );\n&#125;\n\n讲 compose 的文章\n这里有一篇非常好\nDO_NOT_USEActionTypes\n一些私有的 action 被 redux 保留，对于不明确的 action，必须返回当前 state.\n如果当前状态是 undefined,必须返回初始状态\n不要在代码中直接涉及这些 action\n\nconst ActionTypes &#x3D; &#123;\n  INIT: &#96;@@redux&#x2F;INIT$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  REPLACE: &#96;@@redux&#x2F;REPLACE$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,\n  PROBE_UNKNOWN_ACTION: () &#x3D;&gt; &#96;@@redux&#x2F;PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;&#96;,\n&#125;;\n\n总结\n\n回顾\n巩固\n参考最精简的 Redux 源码解析，看完从此再也不怕面试官Redux 源码解析github 源码\n","slug":"2022-05-25.redux2","date":"2022-05-25T13:32:54.000Z","categories_index":"React","tags_index":"redux,源码","author_index":"举手摘月亮"},{"id":"af1b42282a210ca45f834a49b50349c6","title":"redux 源码 1","content":"介绍A Predictable State Container for JS Apps\npackage.json&#123;\n  &quot;name&quot;: &quot;redux&quot;,\n  &quot;version&quot;: &quot;5.0.0-alpha.0&quot;,\n  &quot;description&quot;: &quot;Predictable state container for JavaScript apps&quot;,\n\n\n  &quot;keywords&quot;: [\n    &quot;redux&quot;,\n    &quot;reducer&quot;,  &#x2F;&#x2F; reducer, redux构成组成之一\n    &quot;state&quot;,    &#x2F;&#x2F; 状态管理\n    &quot;predictable&quot;,   &#x2F;&#x2F; 可预测的\n    &quot;functional&quot;,    &#x2F;&#x2F; 纯函数的\n    &quot;immutable&quot;,     &#x2F;&#x2F; 不可变的\n    &quot;hot&quot;,\n    &quot;live&quot;,\n    &quot;replay&quot;,        &#x2F;&#x2F; 回放\n    &quot;flux&quot;,          &#x2F;&#x2F; redux对flux的改进\n    &quot;elm&quot;            &#x2F;&#x2F; Elm 是一门专注于Web前端的纯函数式语言, reducer受elm启发\n  ],\n\n\n  &#x2F;&#x2F; 入口\n  &quot;main&quot;: &quot;lib&#x2F;redux.js&quot;,\n\n\n  &#x2F;&#x2F; unpkg 是一个内容源自 npm 的全球快速 CDN, 它能以快速而简单的方式提供任意包、任意文件，通过类似这样的 URL ：unpkg.com&#x2F;:package@:version&#x2F;:file\n  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.3&#x2F;dist&#x2F;redux.min.js 是对应redux@4.0.3版本的压缩后的js文件\n  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux ——根据package.json配置的unpkg, 重定向为--—&gt; https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.4&#x2F;dist&#x2F;redux.js , 做了两次重定向\n  &#x2F;&#x2F; 如何你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux&#x2F; (注意redux后有&#x2F;), 是一个页面\n  &quot;unpkg&quot;: &quot;dist&#x2F;redux.js&quot;, &#x2F;&#x2F; 用unpkg的裸url访问时, 指定到该文件\n\n\n  &#x2F;**\n    module\n      点击 Setting up multi-platform npm packages 查看相关介绍。\n\n      就像 main 字段一样，定义一个针对 es6 模块及语法的入口文件。\n\n      构建工具在构建项目的时候，如果发现了这个字段，会首先使用这个字段指向的文件，如果未定义，则回退到 main 字段指向的文件。\n\n      支持的工具：\n\n      rollup\n      webpack\n  **&#x2F;\n  &quot;module&quot;: &quot;es&#x2F;redux.js&quot;,\n\n\n\n&#x2F;&#x2F; TypeScript是javascript 的超集, typings&#x2F;types字段, 定义了TypeScript的入口文件\n  &quot;types&quot;: &quot;types&#x2F;index.d.ts&quot;,\n\n\n\n  &#x2F;&#x2F; 发布上传内容\n  &#x2F;&#x2F; 是一个可选字段, 用来描述作将软件包作为依赖项安装时要包含的条目, 相当于白名单, 类似.gitignore类似的语法, files字段中包含的文件不能通过.npmignore或.gitignore排除\n  &quot;files&quot;: [\n    &quot;dist&quot;,\n    &quot;lib&quot;,\n    &quot;es&quot;,\n    &quot;src&quot;,\n    &quot;types&quot;\n  ],\n  &quot;scripts&quot;: &#123;\n    ...\n  &#125;,\n  &#x2F;&#x2F; 表示在生产环境下使用该依赖, 对应 npm install xx -S 或 npm install xx --save\n  &quot;dependencies&quot;: &#123;\n    &quot;@babel&#x2F;runtime&quot;: &quot;^7.16.7&quot;\n  &#125;,\n  &#x2F;&#x2F; 表示仅在开发环境下使用, 不会在生产环境中使用的依赖, 对应 npm install xx -D 或 npm install xx --save-dev\n  &quot;devDependencies&quot;: &#123;\n   ...\n  &#125;,\n  &quot;npmName&quot;: &quot;redux&quot;,\n\n\n  &#x2F;&#x2F; npm文件映射。把需要同步到 cdnjs 的文件配置在这里。\n  &quot;npmFileMap&quot;: [\n    &#123;\n      &quot;basePath&quot;: &quot;&#x2F;dist&#x2F;&quot;,\n      &quot;files&quot;: [\n        &quot;*.js&quot;\n      ]\n    &#125;\n  ],\n\n  &#x2F;&#x2F; webpack相关字段, 声明该模块是否包含 sideEffects（副作用），从而可以为 tree-shaking 提供更大的优化空间。\n  &quot;sideEffects&quot;: false\n&#125;\n\nversion字段包的版本, 必须有, 要符合semantic versioning guidelines, 参考 语义化版本控制规范, 建议仔细通读\n参考配合redux项目深度了解package.jsonsemantic versioning guidelines语义化版本控制规范\n源码目录.\n├── applyMiddleware.ts\n├── bindActionCreators.ts\n├── combineReducers.ts\n├── compose.ts\n├── createStore.ts\n├── index.ts\n├── types\n│   ├── actions.ts\n│   ├── middleware.ts\n│   ├── reducers.ts\n│   └── store.ts\n└── utils\n    ├── actionTypes.ts\n    ├── formatProdErrorMessage.ts\n    ├── isPlainObject.ts\n    ├── kindOf.ts\n    ├── symbol-observable.ts\n    └── warning.ts\n\n2 directories, 16 files\n\nindex.tsexport &#123;\n  createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose,\n  __DO_NOT_USE__ActionTypes\n&#125;","slug":"2022-05-25.redux","date":"2022-05-25T05:48:17.000Z","categories_index":"React","tags_index":"redux,源码","author_index":"举手摘月亮"},{"id":"d512c56f4cbf1792b4d8bab0668985ad","title":"react-redux  源码2","content":"源码版本&quot;version&quot;: &quot;8.0.2&quot;,\nProvider\n主要作用通过subscription调用redux中store的subscription产生订阅，订阅内容是onStateChange的回调\n通过react的Provider功能，提供传递给根的store和根的subscription给后续使用了connect的组件\n\n&#x2F;* provider 组件代码 *&#x2F;\nfunction Provider(&#123; store, context, children &#125;) &#123;\n   &#x2F;* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  *&#x2F; \n  const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n      &#x2F;* 创建了一个根 Subscription 订阅器 *&#x2F;\n    const subscription &#x3D; new Subscription(store)\n    &#x2F;* subscription 的 notifyNestedSubs 方法 ，赋值给  onStateChange方法 *&#x2F;\n    &#x2F;&#x2F;onStateChange就是之后触发的listenr\n    subscription.onStateChange &#x3D; subscription.notifyNestedSubs  \n    return &#123;\n      store,\n      subscription\n    &#125; &#x2F;*  store 改变创建新的contextValue *&#x2F;\n  &#125;, [store])\n  &#x2F;*  获取更新之前的state值 ，函数组件里面的上下文要优先于组件更新渲染  *&#x2F;\n  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])\n\n  useEffect(() &#x3D;&gt; &#123;\n    const &#123; subscription &#125; &#x3D; contextValue\n    &#x2F;* 触发trySubscribe方法执行，创建listens *&#x2F;\n    subscription.trySubscribe() &#x2F;&#x2F; 发起订阅\n    if (previousState !&#x3D;&#x3D; store.getState()) &#123;\n        &#x2F;* 组件更新渲染之后，如果此时state发生改变，那么立即触发 subscription.notifyNestedSubs 方法  *&#x2F;\n        &#x2F;&#x2F;触发所有的listener\n      subscription.notifyNestedSubs() \n    &#125;\n    &#x2F;*   *&#x2F;\n    return () &#x3D;&gt; &#123;\n      subscription.tryUnsubscribe()  &#x2F;&#x2F; 卸载订阅\n      subscription.onStateChange &#x3D; null\n    &#125;\n    &#x2F;*  contextValue state 改变出发新的 effect *&#x2F;\n  &#125;, [contextValue, previousState])\n\n  &#x2F;&#x2F;若Provider没有显示传入context，则为使用React.createContext创建的上下文\n  const Context &#x3D; context || ReactReduxContext\n\n  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt;\n&#125;\n\nSubscription\n订阅消息、发起更新\n在根的Provider的作用是调用redux中store的订阅方法，将根的onStateChange进行订阅\n在子代中是收集所有被 connect 包裹的组件中的Subscription的更新函数 onstatechange，然后形成一个 callback 链表，再由父级 Subscription 统一派发执行更新，只会往上传递一层，不会一直传递使得每一个上级都有自身的更新函数\n\n&#x2F;* 发布订阅者模式 *&#x2F;\nexport default class Subscription &#123;\n  constructor(store, parentSub) &#123;\n    this.store &#x3D; store\n    this.parentSub &#x3D; parentSub\n    this.unsubscribe &#x3D; null\n    this.listeners &#x3D; nullListeners\n\n    this.handleChangeWrapper &#x3D; this.handleChangeWrapper.bind(this)\n  &#125;\n  &#x2F;* 负责检测是否该组件订阅，然后添加订阅者也就是listener *&#x2F;  \n  &#x2F;&#x2F;当父代调用过trySubscribe后，子代再调用，因为this.unsubscribe有值，所以并不会实际执行父代的trySubscribe，而只是将listener放进父代中管理\n  addNestedSub(listener) &#123;\n    this.trySubscribe()\n    return this.listeners.subscribe(listener)\n  &#125;\n  &#x2F;* 向listeners发布通知 *&#x2F;\n  notifyNestedSubs() &#123;\n    this.listeners.notify()\n  &#125;\n  &#x2F;* 对于 Provide onStateChange 就是 notifyNestedSubs 方法，\n  对于 connect 包裹接受更新的组件 ，onStateChange 就是 负责更新组件的函数 。   *&#x2F;\n  handleChangeWrapper() &#123;\n    if (this.onStateChange) &#123;\n      this.onStateChange()\n    &#125;\n  &#125;\n   &#x2F;* 判断有没有开启订阅 *&#x2F;\n  isSubscribed() &#123;\n    return Boolean(this.unsubscribe)\n  &#125;\n  &#x2F;* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 *&#x2F;\n  trySubscribe() &#123;\n    &#x2F;*\n    \tparentSub即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription\n    *&#x2F;\n    &#x2F;&#x2F;当Subscription执行过一次改方法后，再调用因为this.unsubscribe有值\n    &#x2F;&#x2F;所以该方法调用一次后就不会再被调用了\n    &#x2F;&#x2F;意味着addNestedSub中只会添加listener，而不会再调用trySubscribe，使得listener不会往上传递\n    if (!this.unsubscribe) &#123;\n      this.unsubscribe &#x3D; this.parentSub\n        ? this.parentSub.addNestedSub(this.handleChangeWrapper)\n        &#x2F;* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   *&#x2F;\n        : this.store.subscribe(this.handleChangeWrapper)\n      this.listeners &#x3D; createListenerCollection()\n    &#125;\n  &#125;\n  &#x2F;* 取消订阅 *&#x2F;\n  tryUnsubscribe() &#123;\n    if (this.unsubscribe) &#123;\n      this.unsubscribe()\n      this.unsubscribe &#x3D; null\n      this.listeners.clear()\n\n      this.listeners &#x3D; nullListeners\n    &#125;\n  &#125;\n&#125;\n\n\n\n首先Provider创建 Subscription 时候没有第二个参数，就说明provider 中的Subscription 不存在 parentSub 。\n那么再调用Provider组件中useEffect钩子中trySubscribe的时候,会触发this.store.subscribe , subscribe 就是 redux 的 subscribe ,此时真正发起了订阅\n订阅的内容是notifyNestedSubs，即通知根管理的listeners触发subscription.onStateChange &#x3D; subscription.notifyNestedSubs \n\n&#x2F;* 向listeners发布通知 *&#x2F;\nnotifyNestedSubs() &#123;\n  this.listeners.notify()\n&#125;\n\n\ncreateListenerCollection通过双向链表的结构管理每一个listener以链表的形式收集对应的 listeners (每一个Subscription) 的handleChangeWrapper函数即onStateChange。通过 batch 方法( react-dom 中的 unstable_batchedUpdates ) 来进行批量更新，许将一次事件循环中的所有 React 更新都一起批量处理到一个渲染过程中。\nimport &#123; unstable_batchedUpdates as batch &#125; from &#39;.&#x2F;utils&#x2F;reactBatchedUpdates&#39;\nsetBatch(batch)\n\n\nfunction createListenerCollection() &#123;\n   &#x2F;* batch 由getBatch得到的 unstable_batchedUpdates 方法 *&#x2F;\n  const batch &#x3D; getBatch()\n  let first &#x3D; null\n  let last &#x3D; null\n\n  return &#123;\n    &#x2F;* 清除当前listeners的所有listener *&#x2F;\n    clear() &#123;\n      first &#x3D; null\n      last &#x3D; null\n    &#125;,\n    &#x2F;* 派发更新 *&#x2F;\n    notify() &#123;\n      batch(() &#x3D;&gt; &#123;\n        let listener &#x3D; first\n        while (listener) &#123;\n          listener.callback()\n          listener &#x3D; listener.next\n        &#125;\n      &#125;)\n    &#125;,\n    &#x2F;* 获取listeners的所有listener *&#x2F;\n    get() &#123;\n      let listeners &#x3D; []\n      let listener &#x3D; first\n      while (listener) &#123;\n        listeners.push(listener)\n        listener &#x3D; listener.next\n      &#125;\n      return listeners\n    &#125;,\n     &#x2F;* 接收订阅，将当前的callback（handleChangeWrapper）存到当前的链表中  *&#x2F;\n    subscribe(callback) &#123;\n      let isSubscribed &#x3D; true\n\n      let listener &#x3D; (last &#x3D; &#123;\n        callback,\n        next: null,\n        prev: last &#x2F;&#x2F;首次last为空\n      &#125;)\n\t   \t\n      if (listener.prev) &#123;\n        listener.prev.next &#x3D; listener\n      &#125; else &#123;\n        first &#x3D; listener\n      &#125;\n      &#x2F;* 取消当前 handleChangeWrapper 的订阅*&#x2F;\n      return function unsubscribe() &#123;\n        if (!isSubscribed || first &#x3D;&#x3D;&#x3D; null) return\n        isSubscribed &#x3D; false\n\t\t\n\t\t&#x2F;&#x2F;双向链表删除节点的操作\n        if (listener.next) &#123;\n          listener.next.prev &#x3D; listener.prev\n        &#125; else &#123;\n          last &#x3D; listener.prev\n        &#125;\n        if (listener.prev) &#123;\n          listener.prev.next &#x3D; listener.next\n        &#125; else &#123;\n          first &#x3D; listener.next\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nconnect基本使用\nfunction connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)\n\nconst mapStateToProps &#x3D; state &#x3D;&gt; (&#123; todos: state.todos &#125;)\nconst mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;\n  return &#123;\n    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),\n    decrement: () &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;),\n    reset: () &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39; &#125;)\n  &#125;\n&#125;\n&#x2F;*\n* stateProps , state 映射到 props 中的内容\n* dispatchProps， dispatch 映射到 props 中的内容。\n* ownProps 组件本身的 props\n当未传递时，默认的合并规则为\n&#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n\n*&#x2F;\nmergeProps&#x3D;(stateProps, dispatchProps, ownProps) &#x3D;&gt; Object\n\noptions&#x3D;&#123;\n  context?: Object,   &#x2F;&#x2F; 自定义上下文\n  pure?: boolean, &#x2F;&#x2F; 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。\n  areStatesEqual?: Function, &#x2F;&#x2F; 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean\n  areOwnPropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean\n  areStatePropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) &#x3D;&gt; boolean\n  areMergedPropsEqual?: Function, &#x2F;&#x2F; 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) &#x3D;&gt; boolean\n  forwardRef?: boolean, &#x2F;&#x2F;当为true 时候,可以通过ref 获取被connect包裹的组件实例。\n&#125;\n\n\n&#x2F;**\n * Connects a React component to a Redux store.\n *\n * - Without arguments, just wraps the component, without changing the behavior &#x2F; props\n *\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\n * is to override ownProps (as stated in the docs), so what remains is everything that&#39;s\n * not a state or dispatch prop\n *\n * - When 3rd param is passed, we don&#39;t know if ownProps propagate and whether they\n * should be valid component props, because it depends on mergeProps implementation.\n * As such, it is the user&#39;s responsibility to extend ownProps interface from state or\n * dispatch props or both when applicable\n *\n * @param mapStateToProps A function that extracts values from state\n * @param mapDispatchToProps Setup for dispatching actions\n * @param mergeProps Optional callback to merge state and dispatch props together\n * @param options Options for configuring the connection\n *\n *&#x2F;\nfunction connect&lt;\n  TStateProps &#x3D; &#123;&#125;,\n  TDispatchProps &#x3D; &#123;&#125;,\n  TOwnProps &#x3D; &#123;&#125;,\n  TMergedProps &#x3D; &#123;&#125;,\n  State &#x3D; unknown\n&gt;(\n  mapStateToProps?: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;,\n  mapDispatchToProps?: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;,\n  mergeProps?: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;,\n  &#123;\n    &#x2F;&#x2F; The &#96;pure&#96; option has been removed, so TS doesn&#39;t like us destructuring this to check its existence.\n    &#x2F;&#x2F; @ts-ignore\n    pure,\n    areStatesEqual &#x3D; strictEqual,\n    areOwnPropsEqual &#x3D; shallowEqual,\n    areStatePropsEqual &#x3D; shallowEqual,\n    areMergedPropsEqual &#x3D; shallowEqual,\n\n    &#x2F;&#x2F; use React&#39;s forwardRef to expose a ref of the wrapped component\n    forwardRef &#x3D; false,\n\n    &#x2F;&#x2F; the context consumer to use\n    context &#x3D; ReactReduxContext,\n  &#125;: ConnectOptions&lt;unknown, unknown, unknown, unknown&gt; &#x3D; &#123;&#125;\n): unknown &#123;\n  \n\n  const Context &#x3D; context\n\n  &#x2F;*\n  * stateProps , state 映射到 props 中的内容\n  * dispatchProps， dispatch 映射到 props 中的内容。\n  * ownProps 组件本身的 props\n  当未传递时，默认的合并规则为\n  &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n\n  *&#x2F;\n &#x2F;* 经过代理包装后的 mapStateToProps,完成传入store等操作*&#x2F;\n  const initMapStateToProps &#x3D; mapStateToPropsFactory(mapStateToProps)\n  &#x2F;* 经过代理包装后的 mapDispatchToProps，完成传入store.dispatch等操作*&#x2F;\n  const initMapDispatchToProps &#x3D; mapDispatchToPropsFactory(mapDispatchToProps)\n  &#x2F;* 经过代理包装后的 mergeProps，用于形成真正的 mergeProps函数，合并业务组件的 props , state 映射的 props , dispatch 映射的 props *&#x2F;\n  const initMergeProps &#x3D; mergePropsFactory(mergeProps)\n\n  const shouldHandleStateChanges &#x3D; Boolean(mapStateToProps)\n\n  &#x2F;&#x2F;默认的高阶组件connectAdvanced，实际渲染的组件是其中返回的一个ConnectFunction\n\t&#x2F;&#x2F;selectorFactory为整合connect更新过程中的形成新props的主要函数\n\t&#x2F;&#x2F;selectorFactory为后面的finalPropsSelectorFactory\n  const wrapWithConnect: AdvancedComponentDecorator&lt;\n    TOwnProps,\n    WrappedComponentProps\n  &gt; &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n    ...\n  &#125;\n&#125;\n\n\n当我们不向connect传递第三个参数mergeProps 的时候，默认的defaultMergeProps如下，作为新的 props 传递给了业务组件\n\nexport function defaultMergeProps(stateProps, dispatchProps, ownProps) &#123;\n  return &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;\n&#125;\n\n\n\nselectorFactory\n\n首先得到真正connect 经过一层代理函数 mapStateToProps ,mapDispatchToProps ,mergeProps\n然后调用selectorFactory (在pure模式下，selectorFactory 就是 pureFinalPropsSelectorFactory )export default function finalPropsSelectorFactory(\n  dispatch,\n  &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options &#125;\n) &#123;\n  &#x2F;&#x2F; mapStateToProps mapDispatchToProps mergeProps 为真正connect 经过一层代理的 proxy 函数\n  const mapStateToProps &#x3D; initMapStateToProps(dispatch, options)\n  const mapDispatchToProps &#x3D; initMapDispatchToProps(dispatch, options)\n  const mergeProps &#x3D; initMergeProps(dispatch, options)\n\n  &#x2F;&#x2F;默认pure为true，selectorFactory默认为pureFinalPropsSelectorFactory\n  const selectorFactory &#x3D; options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory\n   &#x2F;&#x2F; 返回一个 函数用于生成新的 props \n  return selectorFactory(\n    mapStateToProps,\n    mapDispatchToProps,\n    mergeProps,\n    dispatch,\n    options\n  )\n&#125;\n\n\npureFinalPropsSelectorFactory\n\n如果是第一次，那么直接调用mergeProps合并ownProps,stateProps,dispatchProps 形成最终的props。\n如果不是第一次，那么判断到底是props还是 store.state 发生改变，然后针对那里变化，重新生成对应的props，最终合并到真正的props\n整个 selectorFactory 逻辑就是形成新的props传递给我们的业务组件。\n\n&#x2F;** pure组件处理 ， 对比 props 是否发生变化 然后 合并props *&#x2F;\nexport function pureFinalPropsSelectorFactory(\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  dispatch,\n  &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125; &#x2F;&#x2F;判断 state prop 是否相等\n) &#123;\n  let hasRunAtLeastOnce &#x3D; false\n  let state\n  let ownProps\n  let stateProps\n  let dispatchProps\n  let mergedProps\n \n  &#x2F;* 第一次 直接形成 ownProps  stateProps  dispatchProps 合并  形成新的 props *&#x2F;\n  function handleFirstCall(firstState, firstOwnProps) &#123;\n    state &#x3D; firstState\n    ownProps &#x3D; firstOwnProps\n    &#x2F;&#x2F;获取业务组件中mapStateToProps函数的返回值\n    stateProps &#x3D; mapStateToProps(state, ownProps)\n    &#x2F;&#x2F;获取业务组件中mapDispatchToProps函数的返回值\n    dispatchProps &#x3D; mapDispatchToProps(dispatch, ownProps)\n    &#x2F;&#x2F;合并state、dispatch、组件自身的props，形成最终传递给组件的props\n    mergedProps &#x3D; mergeProps(stateProps, dispatchProps, ownProps)\n    hasRunAtLeastOnce &#x3D; true\n    return mergedProps\n  &#125;\n  \n  function handleNewPropsAndNewState() &#123;\n    &#x2F;&#x2F;  props 和 state 都改变  mergeProps \n  &#125;\n\n  function handleNewProps() &#123;\n    &#x2F;&#x2F; props 改变  mergeProps\n  &#125;\n\n  function handleNewState() &#123;\n     &#x2F;&#x2F; state 改变 mergeProps\n  &#125;\n\n  &#x2F;*  不是第一次的情况 props 或者 store.state 发生改变的情况。 *&#x2F;\n  function handleSubsequentCalls(nextState, nextOwnProps) &#123;\n      &#x2F;* 判断两次 props 是否相等 *&#x2F;\n    const propsChanged &#x3D; !areOwnPropsEqual(nextOwnProps, ownProps) \n      &#x2F;* 判断两次 store.state 是否相等 *&#x2F;\n    const stateChanged &#x3D; !areStatesEqual(nextState, state)\n    state &#x3D; nextState\n    ownProps &#x3D; nextOwnProps\n    \n    &#x2F;&#x2F;根据改变的类型不同，返回对应合并策略下的props\n    if (propsChanged &amp;&amp; stateChanged) return handleNewPropsAndNewState()\n    if (propsChanged) return handleNewProps()\n    if (stateChanged) return handleNewState()\n    return mergedProps\n  &#125;\n  \n  &#x2F;&#x2F;根据是否第一次形成props，执行对应方法\n  return function pureFinalPropsSelector(nextState, nextOwnProps) &#123;\n    return hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  &#125;\n&#125;\n\nconnectHOCconst mapStateToProp &#x3D; (store) &#x3D;&gt; (&#123; userInfo: store.root.userInfo &#125;)\n\nfunction Index()&#123;\n    &#x2F;* ..... *&#x2F;\n    return &lt;div&gt; &#123; &#x2F;* .... *&#x2F; &#125; &lt;&#x2F;div&gt;\n&#125;\nexport default connect(mapStateToProp)(Index)\n\n\n\nconnect(mapStateToProp)&#x3D;&#x3D;&#x3D;connectAdvanced()\n\n\n点击查看更多\n\n这部分代码，在8.x.x版本在conncet中直接处理，并没有拆分为单独函数\n\nexport default function connectAdvanced(\n  selectorFactory, &#x2F;&#x2F; 每次 props,state改变执行 ，用于生成新的 props。\n  &#123;\n    getDisplayName &#x3D; name &#x3D;&gt; &#96;ConnectAdvanced($&#123;name&#125;)&#96;,\n    &#x2F;&#x2F;可能被包装函数（如connect（））重写\n    methodName &#x3D; &#39;connectAdvanced&#39;,\n    &#x2F;&#x2F;如果定义了，则传递给包装元素的属性的名称，指示要呈现的调用。用于监视react devtools中不必要的重新渲染。\n    renderCountProp &#x3D; undefined,\n    shouldHandleStateChanges &#x3D; true,  &#x2F;&#x2F;确定此HOC是否订阅存储更改\n    storeKey &#x3D; &#39;store&#39;,\n    withRef &#x3D; false,\n    forwardRef &#x3D; false, &#x2F;&#x2F; 是否 用 forwarRef 模式\n    context &#x3D; ReactReduxContext,&#x2F;&#x2F; Provider 保存的上下文\n    ...connectOptions\n  &#125; &#x3D; &#123;&#125;\n) &#123;\n  &#x2F;* ReactReduxContext 就是store存在的context *&#x2F;\n  const Context &#x3D; context\n   &#x2F;* WrappedComponent 为connect 包裹的组件本身  *&#x2F;   \n  return  function wrapWithConnect(WrappedComponent)&#123;\n      &#x2F;&#x2F; WrappedComponent 被 connect 的业务组件本身\n  &#125;\n&#125;\n\n拿到Provider提供的context上下文\n\n\n\nwrapWithConnectwrapWithConnect作为高阶组件，会返回一个组件，这个组件会对原有的业务组件，进行一系列增强等工作判断是否是 pure 纯组件模式，如果是用react.memo包裹,这样做的好处是，会向 pureComponent 一样对 props 进行浅比较如果 connect 有forwardRef配置项，用React.forwardRef处理\nfunction wrapWithConnect(WrappedComponent) &#123;\n\t&#x2F;&#x2F;WrappedComponent为实际传递的业务组件\n    const wrappedComponentName &#x3D;\n      WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;\n  \n    const displayName &#x3D; getDisplayName(wrappedComponentName)\n    \n    &#x2F;&#x2F;要合并都内容，connectOptions为上一步闭包拿到的内容\n    const selectorFactoryOptions &#x3D; &#123;\n      ...connectOptions,\n      getDisplayName,\n      methodName,\n      renderCountProp,\n      shouldHandleStateChanges,\n      storeKey,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent\n    &#125;\n    const &#123; pure &#125; &#x3D; connectOptions\n    \n    &#x2F;&#x2F;selectorFactory为finalPropsSelectorFactory\n    function createChildSelector(store) &#123;\n      &#x2F;&#x2F; 合并函数 mergeprops 得到最新的props\n      &#x2F;&#x2F; 及默认返回pureFinalPropsSelectorFactory，会根据是否第一次合并、修改类型等进行不同策略等合并以及返回最终都props\n      return selectorFactory(store.dispatch, selectorFactoryOptions)\n    &#125;\n    &#x2F;&#x2F;判断是否是pure纯组件模式 如果是将用 useMemo 缓存组件提升性能\n    const usePureOnlyMemo &#x3D; pure ? useMemo : callback &#x3D;&gt; callback()\n    &#x2F;&#x2F; 负责更新的容器子组件，可以看作是实际渲染的类组件\n    function ConnectFunction (props)&#123;\n        &#x2F;&#x2F; props 为 业务组件 真正的 props \n    &#125;\n    &#x2F;&#x2F;如果\n    const Connect &#x3D; pure ? React.memo(ConnectFunction) : ConnectFunction\n  \n    Connect.WrappedComponent &#x3D; WrappedComponent\n    Connect.displayName &#x3D; displayName\n    &#x2F;* forwardRef *&#x2F;\n    if (forwardRef) &#123;\n      const forwarded &#x3D; React.forwardRef(function forwardConnectRef(\n        props,\n        ref\n      ) &#123;\n      \t&#x2F;&#x2F;connect中是否传递了forwardRef选项\n        return &lt;Connect &#123;...props&#125; reactReduxForwardedRef&#x3D;&#123;ref&#125; &#x2F;&gt;\n      &#125;)\n  \n      forwarded.displayName &#x3D; displayName\n      forwarded.WrappedComponent &#x3D; WrappedComponent\n      &#x2F;&#x2F;hoistStatics为一个第三方库，负责把一个类中的静态属性拷贝到另一个类中\n      return hoistStatics(forwarded, WrappedComponent)\n    &#125;\n  \n    return hoistStatics(Connect, WrappedComponent)\n  &#125;\n&#125;\n\n为何要传递forwardRef？connect(mapStateToProp,mapDispatchToProps,mergeProps,&#123; forwardRef:true  &#125;)(Child)\n\n如果不传递，而是在其他组件中直接放ref到使用了connect的组件，则ref实际应用到的是ConncectFunction组件，而非真正的WrappedComponent组件所以react-redux提供forwardRef选项，使用React.forwardRef，将ref实际放到真正的WrappedComponent上\nConnectFunction\n实际渲染的组件\nfunction ConnectFunction(props) &#123;\n    &#x2F;* TODO:  第一步 把 context ForwardedRef props 取出来 *&#x2F;\n    &#x2F;&#x2F;取出forwardRef和传递给ConnectFunction的所有除forwardRef的props\n    &#x2F;&#x2F;除了forwardRef以外的props也就是实际业务代码中传递给conncec包裹组件都props\n    const [\n      reactReduxForwardedRef,\n      wrapperProps &#x2F;&#x2F; props 传递的props\n    ] &#x3D; useMemo(() &#x3D;&gt; &#123;\n      const &#123; reactReduxForwardedRef, ...wrapperProps &#125; &#x3D; props\n      return [reactReduxForwardedRef, wrapperProps]\n    &#125;, [props])\n \n\t  &#x2F;&#x2F; 获取上层Provider提供的context，多个Provider只会取最近的Provider\n    &#x2F;&#x2F; 获取 context内容 里面含有  redux 中store 和 subscription\n    const contextValue &#x3D; useContext(Context)\n\n    &#x2F;&#x2F;TODO: 判断 store 是否来自props  didStoreComeFromProps ,正常情况下 ，prop 中是不存在 store 所以  didStoreComeFromProps &#x3D; false\n    const didStoreComeFromProps &#x3D;\n      Boolean(props.store) &amp;&amp;\n      Boolean(props.store.getState) &amp;&amp;\n      Boolean(props.store.dispatch)\n    &#x2F;&#x2F;store是否来自Provider提供的上下文\n    const didStoreComeFromContext &#x3D;\n      Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)\n\n    &#x2F;&#x2F;根据两种情况获取store\n    const store &#x3D; didStoreComeFromProps ? props.store : contextValue.store\n     \n     &#x2F;&#x2F;返回merge函数 用于生成真正传给子组件 props\n    const childPropsSelector &#x3D; useMemo(() &#x3D;&gt; &#123;\n    \t&#x2F;&#x2F;默认情况下pure为true，返回的是pureFinalPropsSelectorFactory\n      return createChildSelector(store)\n    &#125;, [store])\n\n\n    &#x2F;&#x2F; TODO:  第二步  创建connect组件自身的subscription 监听者实例  \n    const [subscription, notifyNestedSubs] &#x3D; useMemo(() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 如果没有订阅更新，那么直接返回，默认情况下开启了订阅\n      if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY\n\t\t&#x2F;&#x2F;为每一个conncet的组件创建订阅器，获取上层Provider提供的contextValue.subscription\n\t\t&#x2F;&#x2F;connct的组件获取的是上层的Provder提供的subscription，有多个Provider，只会取层级最近的一个\n\t\t&#x2F;&#x2F;所以connect中的connect组件，获取到的是离它最近的Provider中的订阅器，通过它来管理自身的listener更新函数\n      const subscription &#x3D; new Subscription(\n        store,\n        didStoreComeFromProps ? null : contextValue.subscription &#x2F;&#x2F; 和 上级 &#96;subscription&#96; 建立起关系。 this.parentSub &#x3D; contextValue.subscription\n      )\n      &#x2F;&#x2F; notifyNestedSubs 触发 noticy 所有子代 listener 监听者 -&gt; 触发batch方法,触发 batchupdate方法 ,批量更新\n      &#x2F;&#x2F;并更新一下this指向\n      const notifyNestedSubs &#x3D; subscription.notifyNestedSubs.bind(\n        subscription\n      )\n\n      return [subscription, notifyNestedSubs]\n    &#125;, [store, didStoreComeFromProps, contextValue])\n\n    &#x2F;*  创建出一个新的contextValue ,把父级的 subscription 换成自己的 subscription   *&#x2F;\n    const overriddenContextValue &#x3D; useMemo(() &#x3D;&gt; &#123;   \n      if (didStoreComeFromProps) &#123; \n        return contextValue\n      &#125;\n      &#x2F;&#x2F;默认情况下，返回自身的订阅器以及redux中的store给自身的子代connect中获取\n      return &#123;\n        ...contextValue,\n        subscription\n      &#125;\n    &#125;, [didStoreComeFromProps, contextValue, subscription])\n    \n    &#x2F;&#x2F;定义了一个useReducer，当actualChildProps变化时，调用dispatch方法forceComponentUpdateDispatch进行组件更新\n    const [\n      [previousStateUpdateResult], &#x2F;&#x2F;调用dispatch更新后的内容\n      forceComponentUpdateDispatch  &#x2F;*  *&#x2F;\n    ] &#x3D; useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)\n\n\n    &#x2F;&#x2F; TODO: 第三步缓存组件本次的props等内容，在下一次组件更新时做比较\n    const lastChildProps &#x3D; useRef() &#x2F;&#x2F;保存上一次 合并过的 props信息（经过 ownprops ,stateProps , dispatchProps 合并过的 ）\n    const lastWrapperProps &#x3D; useRef(wrapperProps) &#x2F;&#x2F;保存本次业务组件的 props \n    const childPropsFromStoreUpdate &#x3D; useRef() &#x2F;&#x2F;用来保存更新后的最新的props\n    const renderIsScheduled &#x3D; useRef(false) &#x2F;&#x2F; 当前组件是否处于渲染阶段\n    \n    &#x2F;&#x2F; actualChildProps 为当前真正处理过后，经过合并的 props\n    const actualChildProps &#x3D; usePureOnlyMemo(() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 调用 mergeProps 进行合并，返回合并后的最新 porps\n        &#x2F;&#x2F;及调用pureFinalPropsSelectorFactory后的合并结果\n      return childPropsSelector(store.getState(), wrapperProps)\n    \n    \t &#x2F;&#x2F;会在store、调用了checkForUpdates、传递给组建的props发生变化后，重新计算获取合并后的props \n    &#125;, [store, previousStateUpdateResult, wrapperProps])\n\n   &#x2F;* 负责更新缓存变量，方便下一次更新的时候比较 *&#x2F;\n    useEffect(()&#x3D;&gt;&#123;\n      captureWrapperProps(...[\n          lastWrapperProps,\n          lastChildProps,\n          renderIsScheduled,\n          wrapperProps,\n          actualChildProps,\n          childPropsFromStoreUpdate,\n          notifyNestedSubs\n       ])\n    &#125;)\n    \n    &#x2F;&#x2F;实际订阅更新组件的地方\n    useEffect(()&#x3D;&gt;&#123;\n        subscribeUpdates(...[\n        shouldHandleStateChanges,\n        store,\n        subscription,\n        childPropsSelector,\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs,\n        forceComponentUpdateDispatch\n       ])\n    &#125;,[store, subscription, childPropsSelector])\n\n\n\n    &#x2F;&#x2F; TODO: 第四步：渲染实际挂载的组件，通过useMemo进行组件的缓存\n    const renderedWrappedComponent &#x3D; useMemo(\n      () &#x3D;&gt; (\n        &lt;WrappedComponent\n          &#123;...actualChildProps&#125;\n          ref&#x3D;&#123;reactReduxForwardedRef&#125;\n        &#x2F;&gt;\n      ),\n      &#x2F;&#x2F;当actualChildProps发生变化的时候重新渲染组件\n      &#x2F;&#x2F;这里就是组件重新渲染的原因：主要通过监听actualChildProps的变化\n      [reactReduxForwardedRef, WrappedComponent, actualChildProps]\n    )\n    &#x2F;&#x2F; 将上一步的renderedWrappedComponent包裹一层Provider\n    &#x2F;&#x2F; 提供该connect组件自身的订阅器、store给子代中的connect组件获取\n    const renderedChild &#x3D; useMemo(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F;shouldHandleStateChanges 来源 connect是否有第一个参数\n      if (shouldHandleStateChanges) &#123;\n        return (\n          &#x2F;&#x2F; ContextToUse 传递 context \n          &lt;ContextToUse.Provider value&#x3D;&#123;overriddenContextValue&#125;&gt;\n            &#123;renderedWrappedComponent&#125;\n          &lt;&#x2F;ContextToUse.Provider&gt;\n        )\n      &#125;\n\n      return renderedWrappedComponent\n    &#125;, [ContextToUse, renderedWrappedComponent, overriddenContextValue])\n\n    return renderedChild\n  &#125;\n\n\n\n创建该connect组件自身的subscription, 并使用Provider包裹，层层传递新的context(很重要)\n\n所以connect组件的子代connect组件，获取到的都是其上层最近的connect提供的Provider中的订阅器，然后将更新函数checkForUpdates放进其中管理\n\n然后通过 useMemo 创建出一个新的 contextValue ,把父级的 subscription 换成自己的 subscription。用于通过 Provider 传递新的 context\n\n接下来通过useReducer制造出真正触发更新的forceComponentUpdateDispatch 这个dispatch函数。也就是整个 state 或者是 props改变，触发组件更新的函数，这个函数放进checkForUpdates中执行\n\n\ncaptureWrapperProps\n进行内容缓存，为了下次组件更新进行比较&#x2F;&#x2F;获取包装的props \nfunction captureWrapperProps(\n  lastWrapperProps,\n  lastChildProps,\n  renderIsScheduled,\n  wrapperProps,\n  actualChildProps,\n  childPropsFromStoreUpdate,\n  notifyNestedSubs\n) &#123;\n  lastWrapperProps.current &#x3D; wrapperProps  &#x2F;&#x2F;子props \n  lastChildProps.current &#x3D; actualChildProps &#x2F;&#x2F;经过 megeprops 之后形成的新prop\n  renderIsScheduled.current &#x3D; false  &#x2F;&#x2F; 当前组件渲染完成\n&#125;\n\n\nsubscribeUpdates\n实际添加更新回调的地方\nfunction subscribeUpdates(\n  shouldHandleStateChanges,\n  store,\n  subscription,\n  childPropsSelector,\n  lastWrapperProps,  &#x2F;&#x2F;子props \n  lastChildProps, &#x2F;&#x2F;经过 megeprops 之后形成的 prop\n  renderIsScheduled,\n  childPropsFromStoreUpdate,\n  notifyNestedSubs,\n  forceComponentUpdateDispatch\n) &#123;\n  if (!shouldHandleStateChanges) return\n\n   &#x2F;&#x2F; 捕获值以检查此组件是否卸载以及何时卸载\n  let didUnsubscribe &#x3D; false\n  let lastThrownError &#x3D; null\n   &#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调\n  const checkForUpdates &#x3D; ()&#x3D;&gt;&#123;\n      &#x2F;&#x2F;....\n  &#125;\n  &#x2F;&#x2F;将checkForUpdates作为listener\n  subscription.onStateChange &#x3D; checkForUpdates\n  &#x2F;&#x2F;开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中。\n  subscription.trySubscribe()\n  &#x2F;&#x2F;在第一次呈现之后从存储中提取数据，以防存储从我们开始就改变了。\n  &#x2F;&#x2F;确保获取到的最新的store.getState,然后判断是否更新组件\n  checkForUpdates()\n  &#x2F;* 卸载订阅起 *&#x2F;\n  const unsubscribeWrapper &#x3D; () &#x3D;&gt; &#123;\n    didUnsubscribe &#x3D; true\n    subscription.tryUnsubscribe()\n    subscription.onStateChange &#x3D; null\n  &#125;\n\n  return unsubscribeWrapper\n&#125;\n\n\n首先声明 store 更新订阅传播到此组件时的回调函数checkForUpdates把它赋值给onStateChange,如果store中的state发生改变，那么在组件订阅了state内容之后，相关联的state改变就会触发当前组件的onStateChange,来合并得到新的props\n\nsubscription.trySubscribe()把订阅函数onStateChange绑定给父级subscription,进行了层层订阅\n\n为了确保拿到的store内容是最新的，所以首先执行了一次checkForUpdates\n\n\ncheckForUpdates\n判断是否需要更新的函数\n&#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调\nconst checkForUpdates &#x3D; () &#x3D;&gt; &#123;\n  if (didUnsubscribe) &#123;\n    &#x2F;&#x2F;如果取消订阅了\n    return\n  &#125;\n   &#x2F;&#x2F; 获取 store 里state\n  const latestStoreState &#x3D; store.getState()q\n  let newChildProps, error\n  try &#123;\n    &#x2F;* 得到最新的 props *&#x2F;\n    newChildProps &#x3D; childPropsSelector(\n      latestStoreState,\n      lastWrapperProps.current\n    )\n  &#125; \n  &#x2F;&#x2F;如果新的合并的 props没有更改，则此处不做任何操作-层叠订阅更新\n  if (newChildProps &#x3D;&#x3D;&#x3D; lastChildProps.current) &#123; \n    if (!renderIsScheduled.current) &#123;  \n      notifyNestedSubs() &#x2F;* 通知子代 subscription 触发 checkForUpdates 来检查是否需要更新。 *&#x2F;\n    &#125;\n  &#125; else &#123;\n    lastChildProps.current &#x3D; newChildProps\n    childPropsFromStoreUpdate.current &#x3D; newChildProps\n    renderIsScheduled.current &#x3D; true\n    &#x2F;&#x2F; 触发useReducer的dispatch来进行更新，该dispatch会改变useReducer返回的previousStateUpdateResult\n    &#x2F;&#x2F; 而previousStateUpdateResult是作为actualChildProps的依赖项引发actualChildProps的改变\n    &#x2F;&#x2F; actualChildProps又是实际渲染组件的依赖性，从而引发组件的重新渲染更新\n    forceComponentUpdateDispatch(&#123;\n      type: &#39;STORE_UPDATED&#39;,\n      payload: &#123;\n        error\n      &#125;\n    &#125;)\n  &#125;\n&#125;\n\ncheckForUpdates 通过调用 childPropsSelector来形成新的props,然后判断之前的 prop 和当前新的 prop 是否相等。如果相等，证明没有发生变化,无须更新当前组件，那么通过调用notifyNestedSubs来通知子代容器组件，检查是否需要更新。如果不相等证明订阅的store.state发生变化，那么立即执行forceComponentUpdateDispatch来触发组件的更新\n\n\n整个订阅流程整个订阅的流程是，如果被connect包裹，并且具有第一个参数。首先通过context获取最近的 subscription，然后创建一个新的subscription,并且和父级的subscription建立起关联。当第一次hoc容器组件挂在完成后，在useEffect里，进行订阅，将自己的订阅函数checkForUpdates,作为回调函数，通过trySubscribe 和this.parentSub.addNestedSub ,加入到父级subscription的listeners中。由此完成整个订阅流程\n整个发布流程整个更新流程是，当组件中调用dispatch触发了redux的state改变和redux的订阅器，从而触发根订阅器的触发listeners.notify ,也就是checkForUpdates函数，然后checkForUpdates函数首先根据mapStoretoprops，mergeprops等操作，验证该组件是否发起订阅，props 是否改变，并更新，如果发生改变，那么触发useReducer的forceComponentUpdateDispatch函数，来更新业务组件，如果没有发生更新，那么通过调用notifyNestedSubs,来通知当前subscription的listeners检查是否更新，然后尽心层层checkForUpdates,逐级向下，借此完成整个更新流程。\n总结\nconnect使用柯里化\nuseMemo缓存渲染组件的操作\n发布订阅模式以及通过双向链表来管理\n如何通过Provider进行层层订阅\nreact-redux触发更新的依据是actualChildProps是否改变\n\n参考react-redux源码解析github 源码React-redux源码解析–准备知识React-redux源码解析\n","slug":"2022-05-24react-redux2","date":"2022-05-24T13:15:31.000Z","categories_index":"React","tags_index":"react-redux,redux,源码","author_index":"举手摘月亮"},{"id":"83401137c3fcd92a859b6d9e289c2c88","title":"react-redux 源码1","content":"react-redux官方介绍\n官方UI绑定层。 React Redux is the official React UI bindings layer for Redux. \n从redux的store读数据。 It lets your React components read data from a Redux store,\n触发行为给store来更新状态。and dispatch actions to the store to update state.\n\nreact-redux 源码.\n├── alternate-renderers.ts\n├── components\n│   ├── Context.ts\n│   ├── Provider.tsx\n│   └── connect.tsx # 大部分代码都在这里\n├── connect # 给 connect.tsx使用\n│   ├── invalidArgFactory.ts\n│   ├── mapDispatchToProps.ts\n│   ├── mapStateToProps.ts\n│   ├── mergeProps.ts\n│   ├── selectorFactory.ts\n│   ├── verifySubselectors.ts\n│   └── wrapMapToProps.ts\n├── exports.ts\n├── hooks\n│   ├── useDispatch.ts\n│   ├── useReduxContext.ts\n│   ├── useSelector.ts\n│   └── useStore.ts\n├── index.ts\n├── next.ts\n├── types.ts\n└── utils\n    ├── Subscription.ts\n    ├── batch.ts\n    ├── bindActionCreators.ts\n    ├── isPlainObject.ts\n    ├── reactBatchedUpdates.native.ts\n    ├── reactBatchedUpdates.ts\n    ├── shallowEqual.ts\n    ├── useIsomorphicLayoutEffect.native.ts\n    ├── useIsomorphicLayoutEffect.ts\n    ├── useSyncExternalStore.ts\n    ├── verifyPlainObject.ts\n    └── warning.ts\npackge.json&#x2F;&#x2F; packge.json\n&#123;\n  &quot;name&quot;: &quot;react-redux&quot;,\n  &quot;version&quot;: &quot;8.0.2&quot;,\n  &quot;description&quot;: &quot;Official React bindings for Redux&quot;,\n  &quot;keywords&quot;: [\n    &quot;react&quot;,\n    &quot;reactjs&quot;,\n    &quot;redux&quot;\n  ],\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;author&quot;: &quot;Dan Abramov &lt;dan.abramov@me.com&gt; (https:&#x2F;&#x2F;github.com&#x2F;gaearon)&quot;,\n  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&quot;,\n  &quot;repository&quot;: &quot;github:reduxjs&#x2F;react-redux&quot;,\n  &quot;bugs&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&#x2F;issues&quot;,\n  &#x2F;&#x2F; 找找入口，入口有3种：\n  &quot;main&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;, &#x2F;&#x2F; 常规操作入口\n  &quot;types&quot;: &quot;.&#x2F;es&#x2F;index.d.ts&quot;, &#x2F;&#x2F; 类型入口\n  &quot;unpkg&quot;: &quot;dist&#x2F;react-redux.js&quot;, &#x2F;&#x2F; cdn入口\n  &quot;module&quot;: &quot;es&#x2F;index.js&quot;,&#x2F;&#x2F;esm入口\n  &#x2F;&#x2F; npm发布上传的文件\n  &quot;files&quot;: [\n    &quot;dist&quot;,\n    &quot;lib&quot;,\n    &quot;src&quot;, &#x2F;&#x2F; 一般用于开发阶段代码调试,soucemap\n    &quot;es&quot;\n  ],\n  &quot;scripts&quot;: &#123;\n    &#x2F;&#x2F; 脚本不看了...\n  &#125;,\n  &#x2F;&#x2F; 配置了依赖项，这些依赖项不需要在本包安装，在项目中安装即可\n  &quot;peerDependencies&quot;: &#123;\n    &quot;@types&#x2F;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;@types&#x2F;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,\n    &quot;react-native&quot;: &quot;&gt;&#x3D;0.59&quot;,\n    &quot;redux&quot;: &quot;^4&quot;\n  &#125;,\n  &quot;peerDependenciesMeta&quot;: &#123;\n    &quot;@types&#x2F;react&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;@types&#x2F;react-dom&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;react-dom&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;react-native&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;,\n    &quot;redux&quot;: &#123;\n      &quot;optional&quot;: true\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; 发布后，业务开发者使用，需要安装，&#x2F;&#x2F;自动安装\n  &quot;dependencies&quot;: &#123;\n    &quot;@babel&#x2F;runtime&quot;: &quot;^7.12.1&quot;,\n    &quot;@types&#x2F;hoist-non-react-statics&quot;: &quot;^3.3.1&quot;,\n    &quot;@types&#x2F;use-sync-external-store&quot;: &quot;^0.0.3&quot;,\n    &quot;hoist-non-react-statics&quot;: &quot;^3.3.2&quot;,\n    &quot;react-is&quot;: &quot;^18.0.0&quot;,\n    &quot;use-sync-external-store&quot;: &quot;^1.0.0&quot;\n  &#125;,\n  &#x2F;&#x2F; 开发阶段需要用到的，一般是examples中demo使用\n  &quot;devDependencies&quot;: &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\nexports.tsexport &#123;\n  Provider, &#x2F;&#x2F; import Provider from &#39;.&#x2F;components&#x2F;Provider&#39;\n\n  ReactReduxContext, &#x2F;&#x2F; import &#123; ReactReduxContext &#125; from &#39;.&#x2F;components&#x2F;Context&#39;\n\n  connect, &#x2F;&#x2F; import connect from &#39;.&#x2F;components&#x2F;connect&#39;\n\n  useDispatch, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;\n  createDispatchHook, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;\n\n  useSelector, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;\n  createSelectorHook, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;\n\n  useStore, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;\n  createStoreHook, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;\n\n  shallowEqual, &#x2F;&#x2F; import shallowEqual from &#39;.&#x2F;utils&#x2F;shallowEqual&#39;\n&#125;\n\n\nProvider先看下 ，最熟悉的api\n&#x2F;&#x2F; components&#x2F;Provider.tsx\n&#x2F;&#x2F; 这个组件做的事情\n&#x2F;&#x2F; 1. 合并浏览器和服务器的状态\n&#x2F;&#x2F; 2. 对于同构的应用，处理subscription订阅\nfunction Provider&lt;A extends Action &#x3D; AnyAction&gt;(&#123;\n  store,\n  context,\n  children,\n  serverState,\n&#125;: ProviderProps&lt;A&gt;) &#123;\n  &#x2F;&#x2F; 1.useMemo，对入参进行格式化「处理了store和 服务端的 serverState」\n  const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n    const subscription &#x3D; createSubscription(store)\n    return &#123;\n      store,\n      subscription,\n      getServerState: serverState ? () &#x3D;&gt; serverState : undefined,\n    &#125;\n  &#125;, [store, serverState])\n  &#x2F;&#x2F; 2.之前的state状态从store中直接获取\n  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])\n  &#x2F;&#x2F; 3.同构相关，跳过\n  useIsomorphicLayoutEffect(() &#x3D;&gt; &#123;\n    const &#123; subscription &#125; &#x3D; contextValue\n    subscription.onStateChange &#x3D; subscription.notifyNestedSubs\n    subscription.trySubscribe()\n\n    if (previousState !&#x3D;&#x3D; store.getState()) &#123;\n      subscription.notifyNestedSubs()\n    &#125;\n    return () &#x3D;&gt; &#123;\n      subscription.tryUnsubscribe()\n      subscription.onStateChange &#x3D; undefined\n    &#125;\n  &#125;, [contextValue, previousState])\n  &#x2F;&#x2F; 4.react-redux上下文\n  const Context &#x3D; context || ReactReduxContext\n\n  &#x2F;&#x2F; @ts-ignore &#39;AnyAction&#39; is assignable to the constraint of type &#39;A&#39;, but &#39;A&#39; could be instantiated with a different subtype\n  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt; &#x2F;&#x2F; 这行代码是不是非常熟悉了\n&#125;\n\nexport default Provider\n\nReactReduxContext&#x2F;&#x2F; .&#x2F;components&#x2F;Context.tsx\n&#x2F;&#x2F; 这个组件做的事情\n&#x2F;&#x2F; 1.创建个createContext\n&#x2F;&#x2F; 2.给个名字displayName\n\n&#x2F;&#x2F; ...类型代码不关注\nexport const ReactReduxContext &#x3D;&#x2F;*#__PURE__*&#x2F; React.createContext&lt;ReactReduxContextValue&gt;(null as any)\n\n&#x2F;&#x2F; ...类型代码不关注\n\nif (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;\n  ReactReduxContext.displayName &#x3D; &#39;ReactRedux&#39;\n&#125;\n\nexport default ReactReduxContext\nconnect&#x2F;&#x2F; .&#x2F;components&#x2F;connect.tsx\n&#x2F;&#x2F; 这个文件比较长，先不看\n&#x2F;&#x2F; hoist-non-react-statics这个依赖可以帮助我们自动拷贝非React的静态方法\nuseDispatch、createDispatchHook把ts类型删删，看上去更简单了\n&#x2F;&#x2F; .&#x2F;hooks&#x2F;useDispatch\n&#x2F;&#x2F; 用createDispatchHook钩子工厂创建了个钩子useDispatch\nexport function createDispatchHook(context) &#123;\n  &#x2F;&#x2F; TODO: createStoreHook下面再看，先跳过\n  const useStore &#x3D; context &#x3D;&#x3D;&#x3D; ReactReduxContext ? useDefaultStore : createStoreHook(context)\n  return function useDispatch() &#123;\n    const store &#x3D; useStore()\n    &#x2F;&#x2F; @ts-ignore\n    return store.dispatch\n  &#125;\n&#125;\n&#x2F;**\n * A hook to access the redux &#96;dispatch&#96; function.\n *\n * @returns &#123;any|function&#125; redux store&#39;s &#96;dispatch&#96; function\n *\n * @example\n *\n * import React, &#123; useCallback &#125; from &#39;react&#39;\n * import &#123; useDispatch &#125; from &#39;react-redux&#39;\n *\n * export const CounterComponent &#x3D; (&#123; value &#125;) &#x3D;&gt; &#123;\n *   const dispatch &#x3D; useDispatch()\n *   const increaseCounter &#x3D; useCallback(() &#x3D;&gt; dispatch(&#123; type: &#39;increase-counter&#39; &#125;), [])\n *   return (\n *     &lt;div&gt;\n *       &lt;span&gt;&#123;value&#125;&lt;&#x2F;span&gt;\n *       &lt;button onClick&#x3D;&#123;increaseCounter&#125;&gt;Increase counter&lt;&#x2F;button&gt;\n *     &lt;&#x2F;div&gt;\n *   )\n * &#125;\n *&#x2F;\nexport const useDispatch &#x3D; &#x2F;*#__PURE__*&#x2F; createDispatchHook()\n\nuseSelector、createSelectorHook&#x2F;&#x2F; .&#x2F;hooks&#x2F;useSelector\n&#x2F;&#x2F; 用 createSelectorHook 钩子工厂创建了个钩子 useSelector\n\nlet useSyncExternalStoreWithSelector &#x3D; notInitialized as uSESWS\nexport const initializeUseSelector &#x3D; (fn: uSESWS) &#x3D;&gt; &#123;\n  useSyncExternalStoreWithSelector &#x3D; fn\n&#125;\n\nconst refEquality: EqualityFn&lt;any&gt; &#x3D; (a, b) &#x3D;&gt; a &#x3D;&#x3D;&#x3D; b\n\n&#x2F;&#x2F; 下面的代码保留范型，Selected\nexport function createSelectorHook(\n  context &#x3D; ReactReduxContext\n): &lt;TState &#x3D; unknown, Selected &#x3D; unknown&gt;(\n  selector: (state: TState) &#x3D;&gt; Selected,\n  equalityFn?: EqualityFn&lt;Selected&gt;\n) &#x3D;&gt; Selected &#123;\n  const useReduxContext &#x3D;\n    context &#x3D;&#x3D;&#x3D; ReactReduxContext\n      ? useDefaultReduxContext\n      : () &#x3D;&gt; useContext(context)\n\n  return function useSelector(\n    selector,\n    equalityFn &#x3D; refEquality\n  ) &#123;\n\n    const &#123; store, subscription, getServerState &#125; &#x3D; useReduxContext()!\n\n    const selectedState &#x3D; useSyncExternalStoreWithSelector(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      selector,\n      equalityFn\n    )\n\n    useDebugValue(selectedState) &#x2F;&#x2F; 标记\n\n    return selectedState\n  &#125;\n&#125;\n\n&#x2F;**\n * A hook to access the redux store&#39;s state. This hook takes a selector function\n * as an argument. The selector is called with the store state.\n *\n * This hook takes an optional equality comparison function as the second parameter\n * that allows you to customize the way the selected state is compared to determine\n * whether the component needs to be re-rendered.\n *\n * @param &#123;Function&#125; selector the selector function\n * @param &#123;Function&#x3D;&#125; equalityFn the function that will be used to determine equality\n *\n * @returns &#123;any&#125; the selected state\n *\n * @example\n *\n * import React from &#39;react&#39;\n * import &#123; useSelector &#125; from &#39;react-redux&#39;\n *\n * export const CounterComponent &#x3D; () &#x3D;&gt; &#123;\n *   const counter &#x3D; useSelector(state &#x3D;&gt; state.counter)\n *   return &lt;div&gt;&#123;counter&#125;&lt;&#x2F;div&gt;\n * &#125;\n *&#x2F;\nexport const useSelector &#x3D; &#x2F;*#__PURE__*&#x2F; createSelectorHook()\nuseStore、createStoreHook\n&#x2F;&#x2F; 1.用钩子工厂创建了个钩子\n&#x2F;&#x2F; 2.从   const &#123; store &#125; &#x3D; useReduxContext()! 获取store\n\n&#x2F;**\n * Hook factory, which creates a &#96;useStore&#96; hook bound to a given context.\n *\n * @param &#123;React.Context&#125; [context&#x3D;ReactReduxContext] Context passed to your &#96;&lt;Provider&gt;&#96;.\n * @returns &#123;Function&#125; A &#96;useStore&#96; hook bound to the specified context.\n *&#x2F;\nexport function createStoreHook&lt;\n  S &#x3D; unknown,\n  A extends BasicAction &#x3D; AnyAction\n  &#x2F;&#x2F; @ts-ignore\n&gt;(context?: Context&lt;ReactReduxContextValue&lt;S, A&gt;&gt; &#x3D; ReactReduxContext) &#123;\n  const useReduxContext &#x3D;\n    &#x2F;&#x2F; @ts-ignore\n    context &#x3D;&#x3D;&#x3D; ReactReduxContext\n      ? useDefaultReduxContext\n      : () &#x3D;&gt; useContext(context)\n  return function useStore&lt;\n    State &#x3D; S,\n    Action extends BasicAction &#x3D; A\n    &#x2F;&#x2F; @ts-ignore\n  &gt;() &#123;\n    const &#123; store &#125; &#x3D; useReduxContext()!\n    &#x2F;&#x2F; @ts-ignore\n    return store as Store&lt;State, Action&gt;\n  &#125;\n&#125;\n\n&#x2F;**\n * A hook to access the redux store.\n *\n * @returns &#123;any&#125; the redux store\n *\n * @example\n *\n * import React from &#39;react&#39;\n * import &#123; useStore &#125; from &#39;react-redux&#39;\n *\n * export const ExampleComponent &#x3D; () &#x3D;&gt; &#123;\n *   const store &#x3D; useStore()\n *   return &lt;div&gt;&#123;store.getState()&#125;&lt;&#x2F;div&gt;\n * &#125;\n *&#x2F;\nexport const useStore &#x3D; &#x2F;*#__PURE__*&#x2F; createStoreHook()\n\nconnect 见：react-redux 源码2\n","slug":"2022-05-24react-redux","date":"2022-05-24T05:58:32.000Z","categories_index":"React","tags_index":"react-redux,redux,源码","author_index":"举手摘月亮"},{"id":"eb38c4ce852a081263435b4198b57084","title":"flex width:0","content":"flex 嵌套内部元素宽度默认 100%，撑开父元素，父元素的根元素限制最大宽度，子元素并不受 flex 控制\n遇到多次了，这次是维护其他同事的代码，又撞见了，说明这个问题很常见，一个不留神，就踩到了\n根元素\n  ……\n  - 父元素flex\n  …… flex\n   - 子元素flex(默认宽度100%)\n\n\n.doc-tree-base-title-node .doc-tree-base-title-text &gt; a &#123;\n  display: flex;\n  align-items: center;\n  color: #777;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex: 1;\n&#125;\n\n问题\n观察下发现，flex 是嵌套的，最外层的还是 flex，一层一层，最外层的宽度，却是由最内层的宽度决定（这个调试可以看到）\n调试\n图 1\n\n\n\n图 2\n\n\n\n图 3\n\n\n分析图 1 元素没有宽度，宽度默认是100%\n图 1 到图 3 是由 a 标签子元素撑开的，宽度是100%,加上操作按钮，元素宽度超 100%\n而在侧边树结构的最外层设置了max-width: 500px,而内部子元素尺寸却是599.48 x 36\n显然是不合理的\n修复根元素\n ……\n - 父元素flex\n …… flex\n  - 子元素flex(默认宽度设置宽度0 或者其他小点的宽度，越小越好)\n\n\n\n什么原因导致的知识点回顾MDN flex\nflex 的特点语法\n&#x2F;* 关键字值 *&#x2F;\nflex: auto;\nflex: initial;\nflex: none;\n\n&#x2F;* 一个值, 无单位数字: flex-grow *&#x2F;\nflex: 2;\n\n&#x2F;* 一个值, width&#x2F;height: flex-basis *&#x2F;\nflex: 10em;\nflex: 30px;\nflex: min-content;\n\n&#x2F;* 两个值: flex-grow | flex-basis *&#x2F;\nflex: 1 30px;\n\n&#x2F;* 两个值: flex-grow | flex-shrink *&#x2F;\nflex: 2 2;\n\n&#x2F;* 三个值: flex-grow | flex-shrink | flex-basis *&#x2F;\nflex: 2 2 10%;\n\n&#x2F;*全局属性值 *&#x2F;\nflex: inherit;\nflex: initial;\nflex: unset;\n\n\n可以使用一个，两个或三个值来指定 flex 属性。\n单值语法单值语法: 值必须为以下其中之一:\n\n一个无单位数(&lt;number&gt;): 它会被当作 flex:&lt;number&gt; 1 0; 解释：&lt;flex-shrink&gt;的值被假定为 1，然后&lt;flex-basis&gt; 的值被假定为 0。\n一个有效的宽度(width)值: 它会被当作 &lt;flex-basis&gt;的值。\n关键字 none，auto 或 initial.\n\n双值语法双值语法: 第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。第二个值必须为以下之一：\n\n一个无单位数：它会被当作 &lt;flex-shrink&gt; 的值。\n一个有效的宽度值: 它会被当作 &lt;flex-basis&gt; 的值。\n\n三值语法三值语法:\n\n第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。\n第二个值必须为一个无单位数，并且它会被当作 &lt;flex-shrink&gt; 的值。\n第三个值必须为一个有效的宽度值， 并且它会被当作 &lt;flex-basis&gt; 的值。\n\n可以看到单值，作为双值处理\nflex-shrink: 1;\nflex-basis: 0;\n\nflex-basis自来看下 flex-base\n查看文档后发现，文档上没说关于flex-basic: 0 的事情,给了个演示，也看不出来想表达什么\nflex-basis 属性的含义\nw3c flex-basis-property\nflex 布局一般由 flex 容器（display 属性值为 flex 或 inline-flex）和其子元素（后文亦称 flex 子项或 flex item）构成。flex-basis 属性一般作用在 flex 子项上，它定义了：在 flex 容器分配剩余空间前 flex 子项在主轴方向上的初始尺寸。flex 子项在主轴方向上的实际尺寸是根据元素自身尺寸、flex-basis、flex-grow、flex-shrink 等属性共同决定的。如何计算实际尺寸不是本文重点，不继续展开。\nflex-basis:0px 与 0%如果 flex-basis 的值为百分数，且它 flex 容器的尺寸没有被显式设置，此时 flex-basis 的值会被解析为 content\ncontent 值会根据 flex 子项的内容（指 flex 子项的子元素尺寸）来计算实际尺寸，多数情况下效果与 max-content 值一致，就是说 flex 子项的子元素有多长其主轴初始值就有多长\nflex: 1在浏览器中，flex: 1 的 flex-basis 值为什么不是 W3C 文档中提到的 0 ？\n当使用 flex 属性但又省略不写它其中的 flex-basis 值时，会将 flex-basis 设置为 0.\n这里的 0 单位是 px 还是 % 我们在 Chrome 浏览器里就能验证：\n\n\n答案是 px.\n这段是 2015 年修正日志里的，意思是将之前 flex 简写语法里的 flex-basis 的解析值从 0% 恢复为原来的 0.\n注意： 这个值的解析规则经历了 0px -&gt; 0% -&gt; 0px 的变化，这是 W3C flex 标准文档的视角。\n简而言之就是有兼容性问题。现在已有很多网页都利用了 flex 属性的这个特性来开发。如果简写语法里 flex-basis 的解析从 0% 变为 0px 会导致部分情况下 flex 容器塌陷，致使很多网页异常\n建议看原文\n","slug":"2022-05-23width0","date":"2022-05-23T09:16:21.000Z","categories_index":"CSS","tags_index":"bug,CSS","author_index":"举手摘月亮"},{"id":"98f521cd056816f8a9831692e48a6839","title":"monorepo","content":"背景\n调试源码时候，总会遇到多包的仓库，遇到了不晓得如何调试\n开发个库或者是插件之类的开发的比较混乱\n经历多个项目的毒打，终于有时间学下monorepo\n\nlerna、yarn workspace\n和java微服务架构代码很像\n很多项目是 lerna+yarn workspace，如果不懂，或者了解了一点lerna。上去一顿操作，各种报错，在所难免（亲身经历）\n\nmonorepo管理对于维护过多个package(功能相近)的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护。Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块&#x2F;包 (package)，不同于常见的每个模块建一个 repo。\n目前有不少大型开源项目采用了这种方式，如 Babel，React, Meteor, Ember, Angular,Jest, Umijs, Vue, 还有 create-react-app, react-router 等。几乎我们熟知的仓库，都无一例外的采用了monorepo 的方式，可以看到这些项目的第一级目录的内容以脚手架为主，主要内容都在 packages目录中、分多个 package 进行管理。\n目录结构如下:\n├── packages\n|   ├── pkg1\n|   |   ├── package.json\n|   ├── pkg2\n|   |   ├── package.json\n├── package.json\n\nmonorepo 最主要的好处是统一的工作流和Code Sharing。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。\n一图胜千言:\n前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。\n虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。\n结合shop-service门户的实际场景和业务需要，天然的 MonoRepo ! 一个理想的开发环境可以抽象成这样：\n\n\n\n\n\n\n\n\n\n“只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”\n在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。\n上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna是业界知名度最高的 Monorepo 管理工具，功能完整。\nLernaLerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。\n2.1 安装推荐全局安装，因为会经常用到 lerna 命令\nnpm i -g lerna\n2.2 初始化项目\nlerna init\n\n其中 package.json &amp; lerna.json 如下:\n&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true, &#x2F;&#x2F; 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦\n  &quot;devDependencies&quot;: &#123;\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;\n \n&#x2F;&#x2F; lerna.json\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;version&quot;: &quot;0.0.0&quot;\n&#125;\n\n\n2.3 创建npm包增加两个 packages\n\n2.4 增加模块依赖分别给相应的 package 增加依赖模块\nlerna add chalk &#x2F;&#x2F; 为所有 package 增加 chalk 模块 \nlerna add semver --scope @mo-demo&#x2F;cli-shared-utils &#x2F;&#x2F; 为 @mo-demo&#x2F;cli-shared-utils 增加 semver 模块 \nlerna add @mo-demo&#x2F;cli-shared-utils --scope @mo-demo&#x2F;cli &#x2F;&#x2F; 增加内部模块之间的依赖\n\n2.5 发布\nlerna publish\n\n2.6 依赖包管理上述1-5步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。\n我们在第4步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 node_modules 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 node_modules ，也不清爽。于是我们使用 –hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本。\nlerna bootstrap --hoist\n\n为了省去每次都输入 –hoist 参数的麻烦，可以在 lerna.json 配置：\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;command&quot;: &#123;\n    &quot;bootstrap&quot;: &#123;\n      &quot;hoist&quot;: true\n    &#125;\n  &#125;,\n  &quot;version&quot;: &quot;0.0.1-alpha.0&quot;\n&#125;\n配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：\nlerna clean\n\n然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 `node_modules` 中了。\n\nLerna + Monorepo 最佳实践\n\n\n\n\n\n\n\n\nlerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。\n目前最常见的 monorepo 解决方案是 Lerna 和 yarn 的 workspaces 特性，基于lerna和yarn workspace的monorepo工作流。由于yarn和lerna在功能上有较多的重叠,我们采用yarn官方推荐的做法,用yarn来处理依赖问题，用lerna来处理发布问题。能用yarn做的就用yarn做吧\nyarn workspace3.1.1 搭建环境普通项目：clone下来后通过yarn install,即可搭建完项目，有时需要配合postinstall hooks,来进行自动编译，或者其他设置。\nmonorepo: 各个库之间存在依赖，如A依赖于B，因此我们通常需要将B link到A的node_module里，一旦仓库很多的话，手动的管理这些link操作负担很大，因此需要自动化的link操作，按照拓扑排序将各个依赖进行link\n解决方式：通过使用workspace，yarn install会自动的帮忙解决安装和link问题\nyarn install # 等价于 lerna bootstrap --npm-client yarn --use-workspaces\n\n3.1.2 清理环境在依赖乱掉或者工程混乱的情况下，清理依赖\n普通项目： 直接删除node_modules以及编译后的产物。\nmonorepo： 不仅需要删除root的node_modules的编译产物还需要删除各个package里的node_modules以及编译产物\n解决方式：使用lerna clean来删除所有的node_modules，使用yarn workspaces run clean来执行所有package的清理工作\nlerna clean # 清理所有的node_modules\nyarn workspaces run clean # 执行所有package的clean操作\n\n3.1.3 安装|删除依赖普通项目： 通过yarn add和yarn remove即可简单姐解决依赖库的安装和删除问题\nmonorepo: 一般分为三种场景\n给某个package安装依赖：yarn workspace packageB add packageA 将packageA作为packageB的依赖进行安装\n给所有的package安装依赖: 使用yarn workspaces add lodash 给所有的package安装依赖\n给root 安装依赖：一般的公用的开发工具都是安装在root里，如typescript,我们使用yarn add -W -D typescript来给root安装依赖\n对应的三种场景删除依赖如下\nyarn workspace packageB remove packageA\nyarn workspaces remove lodash\nyarn remove -W -D typescript\n\n\n3.1.4 项目构建普通项目：建立一个build的npm script，使用yarn build即可完成项目构建\nmonorepo:区别于普通项目之处在于各个package之间存在相互依赖，如packageB只有在packageA构建完之后才能进行构建，否则就会出错，这实际上要求我们以一种拓扑排序的规则进行构建。\n我们可以自己构建拓扑排序规则，很不幸的是yarn的workspace暂时并未支持按照拓扑排序规则执行命令,虽然该 rfc已经被accepted，但是尚未实现, 幸运的是lerna支持按照拓扑排序规则执行命令, –sort参数可以控制以拓扑排序规则执行命令\nlerna run --stream --sort build\n3.1.5 版本升级及发包项目测试完成后，就涉及到版本发布，版本发布一般涉及到如下一些步骤\n条件验证: 如验证测试是否通过，是否存在未提交的代码，是否在主分支上进行版本发布操作\nversion_bump:发版的时候需要更新版本号，这时候如何更新版本号就是个问题，一般大家都会遵循 semVer语义，\n生成changelog: 为了方便查看每个package每个版本解决了哪些功能，我们需要给每个package都生成一份changelog方便用户查看各个版本的功能变化。\n生成git tag：为了方便后续回滚问题及问题排查通常需要给每个版本创建一个git tag\ngit 发布版本：每次发版我们都需要单独生成一个commit记录来标记milestone\n发布npm包：发布完git后我们还需要将更新的版本发布到npm上，以便外部用户使用\n我们发现手动的执行这些操作是很麻烦的且及其容易出错，幸运的是lerna可以帮助我们解决这些问题\nyarn官方并不打算支持发布流程，只是想做好包管理工具，因此这部分还是需要通过lerna支持\nlerna提供了publish和version来支持版本的升级和发布, publish的功能可以即包含version的工作，也可以单纯的只做发布操作。\n3.2 优雅的提交3.2.1 commitizen &amp;&amp; cz-lerna-changelogcommitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。\ncz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：\n\n我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。\n因为这是整个工程的开发依赖，所以在根目录安装：\nyarn add  -D commitizen\nyarn add  -D cz-lerna-changelog\n\n安装完成后，在 package.json 中增加 config 字段，把 cz-lerna-changelog 配置给 commitizen。同时因为commitizen不是全局安全的，所以需要添加 scripts 脚本来执行 git-cz\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;commit&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;\n\n\n之后在常规的开发中就可以使用 yarn run commit 来根据提示一步一步输入，来完成代码的提交。\n3.2.2 commitlint &amp;&amp; husky上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用yarn run commit 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。\n安装 commitlint 以及要遵守的规范\nyarn add -D @commitlint&#x2F;cli @commitlint&#x2F;config-conventional\n\n在工程根目录为 commitlint 增加配置文件 commitlint.config.js 为commitlint 指定相应的规范\nmodule.exports &#x3D; &#123; \n\textends: [&#39;@commitlint&#x2F;config-conventional&#39;] \n&#125;\n\n安装 husky\nyarn add -D husky\n\n\n在 package.json 中增加如下配置\n&quot;husky&quot;: &#123; \n\t\t&quot;hooks&quot;: &#123; \n   \t\t&quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot; \n    &#125;\n&#125;\n\n\n“commit-msg”是git提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 yarn run commit 来提交。\n3.2.3 eslint &amp;&amp; lint-staged除了规范提交信息，代码本身肯定也少了靠规范来统一风格。\n安装\nyarn add  -D standard lint-staged\n\n\neslint就是完整的一套 JavaScript（typescript） 代码规范，自带 linter &amp; 代码自动修正。自动格式化代码并修正，提前发现风格以及程序问题, 同时也支持typescript的代码规范校验，eslintrc.json配置：\n&#123;\n    &quot;extends&quot;: [\n        &quot;yayajing&quot;,\n        &quot;plugin:@typescript-eslint&#x2F;recommended&quot;\n    ],\n    &quot;parser&quot;: &quot;typescript-eslint-parser&quot;,\n    &quot;plugins&quot;: [&quot;@typescript-eslint&quot;],\n    &quot;rules&quot;: &#123;\n        &quot;eqeqeq&quot;:&quot;off&quot;,\n        &quot;@typescript-eslint&#x2F;explicit-function-return-type&quot;: &quot;off&quot;,\n        &quot;no-template-curly-in-string&quot;: &quot;off&quot;\n    &#125;\n  &#125;\n\n\nlint-staged staged 是 Git 里的概念，表示暂存区，lint-staged 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。package.json配置\n&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;c&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;husky&quot;: &#123;\n    &quot;hooks&quot;: &#123;\n      &quot;pre-commit&quot;: &quot;lint-staged&quot;,\n      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;\n    &#125;\n  &#125;,\n  &quot;lint-staged&quot;: &#123;\n    &quot;*.ts&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@commitlint&#x2F;cli&quot;: &quot;^8.1.0&quot;,\n    &quot;@commitlint&#x2F;config-conventional&quot;: &quot;^8.1.0&quot;,\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;husky&quot;: &quot;^3.0.0&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;,\n    &quot;lint-staged&quot;: &quot;^9.2.0&quot;\n  &#125;\n&#125;\n\n\n安装完成后，在 package.json 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 eslint –fix 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky的配置中增加pre-commit的钩子用来执行 lint-staged 的校验操作。\n此时提交 ts 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。\n3.3 发布自动生成日志有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：\n3.3.1 lerna version 更新版本\n\n找出从上一个版本发布以来有过变更的 package\n\n提示开发者确定要发布的版本号\n\n将所有更新过的的 package 中的package.json的version字段更新\n\n将依赖更新过的 package 的 包中的依赖版本号更新\n\n更新 lerna.json 中的 version 字段\n\n提交上述修改，并打一个 tag\n\n推送到 git 仓库\n\n\n3.3.2 使用 npm publish 将新版本推送到 npmCHANGELOG 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数 --conventional-commits。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 lerna.json中，如下：\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;command&quot;: &#123;\n    &quot;bootstrap&quot;: &#123;\n      &quot;hoist&quot;: true\n    &#125;,\n    &quot;version&quot;: &#123;\n      &quot;conventionalCommits&quot;: true\n    &#125;\n  &#125;,\n  &quot;ignoreChanges&quot;: [\n    &quot;**&#x2F;*.md&quot;\n  ],\n  &quot;version&quot;: &quot;0.0.1-alpha.1&quot;\n&#125;\n\n\nlerna version 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 ignoreChanges 配置排除。如上。\n实际 lerna version很少直接使用，因为它包含在 lerna publish 中了，直接使用 lerna publish就好了。\n3.4 完善的测试用例monorepo项目：测试有两种方式\n\n使用统一的jest测试配置这样方便全局的跑jest即可，好处是可以方便统计所有代码的测试覆盖率，坏处是如果package比较异构（如小程序，前端，node 服务端等），统一的测试配置不太好编写\n\n每个package单独支持test命令，使用yarn workspace run test，坏处是不好统一收集所有代码的测试覆盖率\n\n\n如果采用jest编写测试用例，支持typescript的话，需要初始化配置jest.config.js：\nmodule.exports &#x3D; &#123;\n  preset: &#39;ts-jest&#39;,\n  moduleFileExtensions: [&#39;ts&#39;],\n  testEnvironment: &#39;node&#39;\n&#125;\n\n4 实践总结到这里，基本上已经构建了基于lerna和yarn workspace的monorepo项目的最佳实践了，该有的功能都有：\n\n完善的工作流\n\ntypescript支持\n\n风格统一的编码\n\n完整的单元测试\n\n一键式的发布机制\n\n完美的更新日志\n\n\n……\n当然，构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。\n参考lerna+yarn workspace+monorepo项目的最佳实践5分钟搞懂Monorepo2021年管理Monorepo代码库的11种出色工具\n","slug":"2022-05-23monorepo","date":"2022-05-23T06:45:12.000Z","categories_index":"npm","tags_index":"增效,npm,monorepo","author_index":"举手摘月亮"},{"id":"a8dbdf02ab5e598ef229ef514965f17c","title":"信标（Beacon ）","content":"Beacon  特点\n接口用于将异步和非阻塞请求发送到服务器。\n请求使用HTTP协议中的POST方法，请求通常不需要响应。\n这个请求被保证在，页面的unload状态从发起到完成之前，被发送。而并不需要一个阻塞请求，例如 XMLHttpRequest 。\n\nBeacon  场景发送异步非阻塞数据到服务端\n为什么是信标？Beacon 接口满足了分析和诊断代码的需要，这些代码通常会尝试在卸载文档之前将数据发送到 web服务器。发送数据的任何过早时机都可能导致错失收集数据的机会。但是，确保在卸载文档期间发送数据是开发人员难以做到的。\n用户代理通常会忽略卸载文档处理程序中的异步 XMLHttpRequests 请求。若要解决此问题，为了分析和诊断代码，通常会在 unload (en-US) 事件或 beforeunload (en-US) 事件中创建同步 XMLHttpRequest 请求以提交数据。同步 XMLHttpRequest 请求强制浏览器延迟卸载文档，并使下一个页面跳转看起来较慢。下一页面没有任何办法来避免这种页面加载性能不佳的感觉。\n其他技术其中一种技术是通过创建 Image 元素并在卸载文档处理程序中设置其 src 属性来延迟卸载以提交数据。由于大多数用户代理会延迟文档卸载，以完成挂起的图片加载，因此可以在卸载过程中提交数据。另一种方法是在卸载处理程序中创建一个无操作循环，花费数秒以延迟卸载并将数据提交到服务器。\n但是上述技术不仅代表了较差的编码模式，其中一些还是不可靠的，会导致下一个导航的页面加载性能较差的感觉。信标 API 提供了解决这些问题的标准方法。\n全局环境Beacon API 的 Navigator.sendBeacon() 方法用于在全局浏览上下文中向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。\n生产环境Beacon API的 WorkerNavigator.sendBeacon() 方法用于从 worker global scope 向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或 FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。\n优点\nAPI 提供了解决这些问题的标准方法\n\n缺点\n浏览器兼容性Navigator.sendBeacon().Browser_compatibility表说明了该方法具有相对广泛地实现。但是，WorkerNavigator.sendBeacon().Browser_compatibility数据显示该方法没有被实现。\n\n","slug":"2022-05-23beacon","date":"2022-05-23T03:12:16.000Z","categories_index":"浏览器","tags_index":"浏览器","author_index":"举手摘月亮"},{"id":"2ed8e0ec0aaa29d8d085170a13236bf8","title":"flutter Bruno","content":"BrunoBruno 是由贝壳「用户体验中心 &amp; 移动端作业组」联合打造的一套企业级移动端 Flutter 组件库，于 12 月 10 日正式开源:\n官网\nPub 地址\nGitHub 仓库\n背景贝壳自 2018 年底开始对 Flutter 的探索和实践，Flutter 落地业务有效地提升了产研效率。但跨业务线协同效率较低，重复劳动力大，代码维护成本高等问题依旧凸显。Bruno 是贝壳针对上述问题在公司内发起的提效专项，致力于打造贝壳标准 Flutter 生态。经过两年的打磨和沉淀，Bruno 现已服务贝壳 B 端全线业务，涵盖 30 多种类型 100+  组件，为近 18 个 App 服务，新增页面组件覆盖率平均达到 80% 以上。\n相信贝壳遇到的问题也是大型团队或者个人开发者不可避免的问题，目前针对该类问题的中后台解决方案层出不穷，但在 Flutter 生态中类似成熟解决方案匮乏。我们希望将贝壳在 Flutter 领域的实践经验回馈给社区，更加完善 Flutter 生态，因此 Bruno 正式开源。\n设计理念Bruno 基于生长、包容、联接的设计理念，赋予组件轻巧灵活、拥抱变化、包容万物的品质。\nBruno 的优势\n适度灵活、充分可扩展\n\nBruno 倡导标准化下的自由、简单、灵活，基于 Flutter 基础组件的封装，使其具备适度灵活，使用组件提效尤为重要。同时组件支持充分可扩展，既可满足多产品的快速接入又能包容特殊场景。\n经过两年的业务实践，我们最终产出了 102 个组件，覆盖类型有 图表、导航、数据录入、操作反馈、内容展示 等。\n2. 连接设计&lt;–&gt;开发\nBruno 基于 Sketch MeaXure 二次开发，实现组件自动识别和标注。开发者可以从设计侧产出的标注稿中清晰的看到页面涵盖的组件，信息无缝传达，高效连接设计与开发。\n3. 主题定制、品牌风格自定义\nBruno 不仅支持全局色号的替换，还支持组件圆角、字体大小、内部间距等属性的定制。在定制全局样式打造自有品牌风格的同时，支持单个组件自定义满足特异化场景需求。\n\n默认基础规范\n\n\n\n\n\n全局样式定制\n\n\n\n单组件样式定制\n\nBruno 还可支持单业务的全局配置，也就是说如果你是组件化工程结构，那么你可以定义每个业务组件的特有风格。\n\n物料承载、教程指引\n\nBruno 官网承载产品设计物料、组件配套文档、Demo 下载、搜索等基础能力，同时配有教程指引开发也可操作 Sketch 插件设计页面，实现零设计资源介入。\nBruno 官网: https://bruno.ke.com\n未来展望\n丰富和完善组件\n\n目前 Bruno 组件涵盖种类可以覆盖常见使用场景，满足企业建立自有品牌形象 App 需求。未来我们会根据业务发展和产品升级不断迭代组件，丰富产品内容提升视觉体验。\n\n提升落地效率\n\n我们不止关注组件的设计与研发，组件落地也是提升产研效率至关重要的环节，因此我们对 Sketch MeaXure 做了二次改造，实现组件自动化标注。同时贝壳产研团队把自动化标注能力线上化，进一步提升组件落地效率。\n3、UI 自动化走查\n贝壳产研团队也在探索 UI 自动化走查方向，期望解放设计侧走查人力，让设计师更多投入对产品的洞察理解，创造优质设计，提升视觉体验。\n","slug":"2022-05-20fluter-bruno","date":"2022-05-20T02:52:49.000Z","categories_index":"flutter","tags_index":"增效,flutter,mobile","author_index":"举手摘月亮"},{"id":"4250bd0ddd67048179ff9fddd5b6e876","title":"npm开发wiki编辑器问题总结","content":"原架构\n重构后\ntsconfig.ts&#123;\n  &#x2F;&#x2F; 编译选项\n  &quot;compilerOptions&quot;: &#123;\n    &#x2F;&#x2F; 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码\n    &quot;target&quot;: &quot;es5&quot;,\n    &#x2F;&#x2F; 指定要包含在编译中的 library\n    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;90e83adb44&#x2F;lib&#x2F;lib.dom.iterable.d.ts\n    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],\n    &#x2F;&#x2F; 允许 ts 编译器编译 js 文件\n    &quot;allowJs&quot;: true,\n    &#x2F;&#x2F; 跳过类型声明文件的类型检查\n    &quot;skipLibCheck&quot;: true,\n    &#x2F;&#x2F; es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异\n    &quot;esModuleInterop&quot;: true,\n    &#x2F;&#x2F; 允许通过 import x from &#39;y&#39; 即使模块没有显式指定 default 导出\n    &quot;allowSyntheticDefaultImports&quot;: true,\n    &#x2F;&#x2F; 开启严格模式\n    &quot;strict&quot;: true,\n    &#x2F;&#x2F; 对文件名称强制区分大小写\n    &quot;forceConsistentCasingInFileNames&quot;: true,\n    &#x2F;&#x2F; 为 switch 语句启用错误报告\n    &quot;noFallthroughCasesInSwitch&quot;: true,\n    &#x2F;&#x2F; 生成代码的模块化标准\n    &quot;module&quot;: &quot;esnext&quot;,\n    &#x2F;&#x2F; 模块解析（查找）策略\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &#x2F;&#x2F; 允许导入扩展名为.json的模块\n    &quot;resolveJsonModule&quot;: true,\n    &#x2F;&#x2F; 是否将没有 import&#x2F;export 的文件视为旧（全局而非模块化）脚本文件\n    &quot;isolatedModules&quot;: true,\n    &#x2F;&#x2F; 编译时不生成任何JS文件（只进行类型检查）\n    &quot;noEmit&quot;: true,\n    &#x2F;&#x2F; 指定将 JSX 编译成什么形式\n    &quot;jsx&quot;: &quot;react-jsx&quot;\n  &#125;,\n  &#x2F;&#x2F; 指定允许 ts 处理的目录\n  &quot;include&quot;: [&quot;src&quot;]\n&#125;\n&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_62118859&#x2F;article&#x2F;details&#x2F;124543485\n\nCannot read properties of nullreact.development.js:1621 Uncaught TypeError: Cannot read properties of null\n\n\n\nahooks 版本\nuseControlledValue\n\nUncaught SyntaxError: The requested module &#39;&#x2F;node_modules&#x2F;.vite&#x2F;deps&#x2F;ahooks.js?v&#x3D;a7b43f7a&#39; does not provide an export named &#39;useControlledValue&#39; (at index.tsx:2:1)\n\n\n\n\n\n\n\n\n\n\nDeprecated the useControlledValue naming left over from 1.0, please use useControllableValue insteadv3.0.0-alpha.4\n\n\nuseRequest\n\nreact_devtools_backend.js:4026 Warning: Failed prop type: The prop &#96;loadMore&#96; is marked as required in &#96;InfiniteScroll&#96;, but its value is &#96;undefined&#96;.\n\n\n\n\n\n\n\n\n\n\n\nRemoved loadMore related attributes, it is recommended to use useInfiniteScroll to achieve unlimited loading capacity.v3.0.0-alpha.4\n除了 dependencies 和 devDependencies，其他的依赖有什么作用呢\nPre-bundling dependencies:\nreact\nrecoil\nreact-dom\nreact-router-dom\nantd\n(...and 29 more)\n\n本地npm link处理不了依赖冲突\n老版本可以运行\n\n\n\n新版本报错\n原因 ahooks^3.x.x 没有 v2 版本 api\n\n\n\n发布安装到项目中测试\n发布\n\n\nnpm 脚本\n\n&quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;vite --port 3004&quot;,\n    &quot;start&quot;: &quot;yarn build:css &amp;&amp; webpack serve --config config&#x2F;webpack.dev.config.js&quot;,\n    &quot;copy:css&quot;: &quot;cp src&#x2F;**&#x2F;*.css dist&#x2F; &amp;&amp; rsync src&#x2F;styles&#x2F;*.css dist&#x2F;styles&#x2F;&quot;,\n    &quot;build&quot;: &quot;tsc&quot;,\n    &quot;build:css&quot;: &quot;node-sass src&#x2F; -o src&#x2F; &quot;,\n    &quot;prepublishOnly&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,\n    &quot;t&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,\n    &quot;push:beta&quot;: &quot;npm publish --tag beta&quot;\n  &#125;,\n\n\n执行脚本$ yarn push:beta\n发布结果\n\n\n## Current Tags\n\n\n*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           beta (a few seconds ago)\n*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           latest (a few seconds ago)\n\n\n\n\n图片没有渲染，修改，打包重新发布0.0.1-220519beta版本测试slate-wiki@0.0.1-220519beta\n\nnpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D;\nnpm notice name:          @ty-fe&#x2F;slate-wiki\nnpm notice version:       0.0.1-220519beta\nnpm notice filename:      @ty-fe&#x2F;slate-wiki-0.0.1-220519beta.tgz\nnpm notice package size:  228.0 kB\nnpm notice unpacked size: 1.2 MB\nnpm notice shasum:        a2991de4933a9e5039ceb7082c5e0a80c2db828c\nnpm notice integrity:     sha512-iHQKpR2LM+F6Z[...]XDN40tHfwMxNg&#x3D;&#x3D;\nnpm notice total files:   417\nnpm notice\n+ @ty-fe&#x2F;slate-wiki@0.0.1-220519beta\n✨  Done in 16.36s.\n\n\nslate-wiki-pro@0.0.1-220519beta\n\nnpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D;\nnpm notice name:          @ty-fe&#x2F;slate-wiki-pro\nnpm notice version:       0.0.1-220519beta\nnpm notice filename:      @ty-fe&#x2F;slate-wiki-pro-0.0.1-220519beta.tgz\nnpm notice package size:  83.5 kB\nnpm notice unpacked size: 413.7 kB\nnpm notice shasum:        85cbe6fbffafc75db16e02427d1eac9b6a906ec3\nnpm notice integrity:     sha512-3viVco6ssb2N3[...]xxisHN9+qYnCA&#x3D;&#x3D;\nnpm notice total files:   205\nnpm notice\n+ @ty-fe&#x2F;slate-wiki-pro@0.0.1-220519beta\n✨  Done in 14.68s.\n\n\n\n问题\n传染性slate-wiki-pro,依赖于 slate-wiki。slate-wiki 改动，项目依赖 slate-wiki-pro，需要发 slate-wiki 和 slate-wiki-pro，项目要安装 slate-wiki-pro\n\n是否可以让项目直接依赖slate-wiki、slate-wiki-pro改动哪个发布哪个，互不影响？\n\n项目很卡\n\n将slate、slate-wiki、slate-wiki-pro使用umd资源，避免重复编译是否可以？\n\n依赖贼多\n\n[######--------------------------------------------------] 49992&#x2F;102014\n\n\n启动没有想象中那么快了\n\nvite 预编译时间过长 130262ms &#x2F; 1000 &#x2F; 60 大概两分钟，加载编译大概几分钟，慢的吓人\n\nvite v2.7.1 dev server running at:\n\n&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;\n&gt; Network: use &#96;--host&#96; to expose\n\nready in 130262ms.  #首次编译\n\n\n\nvite v2.7.1 dev server running at:\n\n&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;\n&gt; Network: use &#96;--host&#96; to expose\n\nready in 43312ms. #非首次编译\n\n\n\n代码放仓库\nslate-wiki\n\n\nCommand line instructionsYou can also upload existing files from your computer using the instructions below.\nGit global setup\ngit config --global user.name &quot;陈海龙&quot;\ngit config --global user.email &quot;haotian.chen@ty.com&quot;\n\nCreate a new repository\ngit clone ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git\ncd slate-wiki\ntouch README.md\ngit add README.md\ngit commit -m &quot;add README&quot;\n\nPush an existing folder\ncd existing_folder\ngit init\ngit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git\ngit add .\ngit commit -m &quot;Initial commit&quot;\n\nPush an existing Git repository\ncd existing_repo\ngit remote rename origin old-origin\ngit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git\n\n\nslate-wiki-pro略\n\n深入了解打包，本站请搜npm 版本的依赖\nreact-codemirror 使用版本 react16,插件及项目使用 react18react-dom.development.js:22738 Uncaught TypeError: cm is not a function\n    at UnControlled.componentDidMount (react-codemirror.tsx:718:19)\n    at commitLayoutEffectOnFiber (react-dom.development.js:23204:30)\n    at commitLayoutMountEffects_complete (react-dom.development.js:24578:9)\n    at commitLayoutEffects_begin (react-dom.development.js:24564:7)\n    at commitLayoutEffects (react-dom.development.js:24502:3)\n    at commitRootImpl (react-dom.development.js:26779:5)\n    at commitRoot (react-dom.development.js:26638:5)\n    at performSyncWorkOnRoot (react-dom.development.js:26073:3)\n    at flushSyncCallbacks (react-dom.development.js:12009:22)\n    at flushSyncCallbacksOnlyInLegacyMode (react-dom.development.js:11988:5)\n\n\n\nvite 关于 global is not defined 问题react-codemirror2 源码\ndeclare let global: any;\ndeclare let require: any;\n\nconst SERVER_RENDERED &#x3D;\n  typeof navigator &#x3D;&#x3D;&#x3D; &quot;undefined&quot; ||\n  (typeof global !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;\n    global[&quot;PREVENT_CODEMIRROR_RENDER&quot;] &#x3D;&#x3D;&#x3D; true);\n\nlet cm;\nif (!SERVER_RENDERED) &#123;\n  cm &#x3D; require(&quot;codemirror&quot;);\n&#125;\n\nvite 404Could not load content for http:&#x2F;&#x2F;localhost:3005&#x2F;node_modules&#x2F;@ty-fe&#x2F;slate-wiki&#x2F;src&#x2F;slate&#x2F;3rd&#x2F;react-codemirror.tsx\n\n(HTTP error: status code 404, net::ERR_HTTP_RESPONSE_CODE_FAILURE)\n\ntodo\ncodemirror 在 vite 中运行报错，codemirror 找不到，webpack 打包正常\n\n","slug":"2022-05-19npm-pkg","date":"2022-05-19T10:34:53.000Z","categories_index":"npm","tags_index":"npm,wiki","author_index":"举手摘月亮"},{"id":"2bd0e979bc9d9166a8f1986cef49a4e4","title":"npm 版本的依赖","content":"前言提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。\nnpm 安装机制A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。\nA 和 B 同时依赖 C，这个包会被安装在哪里呢？假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。\b执行完毕后，我们会看到 ./node_modules 这层目录只含有这两个子目录：\nnode_modules&#x2F; \n├─┬ A \n│ ├── C \n├─┬ B \n│ └── C \n如果使用 npm 3 来进行安装的话，./node_modules 下的目录将会包含三个子目录：\nnode_modules&#x2F; \n├─┬ A \n├─┬ B \n├─┬ C \n为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：\nnpm 2 和 npm 3 模块安装机制的差异虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异。\nnpm 2 在安装依赖包时，采用\b简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。\b执行完毕后，我们会看到 .&#x2F;node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：\n\n这样的目录有较为明显的好处：\n1）层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录；\n2）在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置；\n3）如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录；\n但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 npm install 后，D 会被重复下载三次，而随着我们的项目越来越复杂，node_modules 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；\n为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。\nnpm 3 对于同一依赖的不同版本会怎么处理呢？npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):\n\n但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：\n\n由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。\n为什么会出现 package-lock.json 呢？为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。\npackage.json 的不足之处npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因：\n1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 A: &#39;^1.0.5&#39; ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug；\n2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 A: &#39;1.0.5&#39; 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。\n针对 package.json 不足的解决方法为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。\npackage-lock.json 文件的结构package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 package-lock-json官方文档，主要的结构如下：\n\nversion ：包版本，即这个包当前安装在 node_modules 中的版本\n\nresolved ：包具体的安装来源\n\nintegrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效\n\nrequires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同\n\ndependencies ：结构和外层的 dependencies 结构相同，存储安装在子依赖 node_modules 中的依赖包\n\n\n需要注意的是，并不是所有的子依赖都有 dependencies 属性，只有子依赖的依赖和当前已安装在根目录的 node_modules 中的依赖冲突之后，才会有这个属性。\npackage-lock.json 文件的作用在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；\nnode_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。\n由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。\n在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。\n依赖的区别与使用场景npm 目前支持以下几类依赖包管理包括\ndependencies\n\ndevDependencies\n\noptionalDependencies 可选择的依赖包\n\npeerDependencies 同等依赖\n\nbundledDependencies 捆绑依赖包\n\n\n下面我们来看一下这几种依赖的区别以及各自的应用场景：\ndependenciesdependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 npm install XXX --save 下载 dependencies 中的包；\n&quot;devDependencies&quot;:&#123;\n  &quot;eslint&quot;: &quot;^5.0.0&quot;,\n  &quot;debug&quot;: &quot;^3.1.0&quot;,\n&#125;\n\n\ndevDependenciesdevDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 npm install packageName --save-dev 下载的包都会在 devDependencies 对象中；\ndependencies 和 devDependencies 最大的区别是在打包运行时，执行 npm install 时默认会把所有依赖全部安装，但是如果使用 npm install --production 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。\noptionalDependenciesoptionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。\noptionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。\ntry &#123; \n  var axios &#x3D; require(&#39;axios&#39;) \n  var fooVersion &#x3D; require(&#39;axios&#x2F;package.json&#39;).version \n&#125; catch (er) &#123; \n  foo &#x3D; null \n&#125; \n&#x2F;&#x2F; .. then later in your program .. \nif (foo) &#123; \n  foo.doFooThings() \n&#125; \n\n\npeerDependenciespeerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 ant-design@3.x 的 package.json 中的配置如下：\n&quot;peerDependencies&quot;: &#123; \n  &quot;react&quot;: &quot;&gt;&#x3D;16.9.0&quot;, \n  &quot;react-dom&quot;: &quot;&gt;&#x3D;16.9.0&quot; \n &#125;, \n假设我们创建了一个名为 project 的项目，在此项目中我们要使用 ant-design@3.x 这个插件，此时我们的项目就必须先安装 React &gt;&#x3D; 16.9.0 和 React-dom &gt;&#x3D; 16.9.0 的版本。\n在 npm 2 中，当我们下载 ant-design@3.x 时，peerDependencies 中指定的依赖会随着 ant-design@3.x 一起被强制安装，所以我们不需要在宿主项目的 package.json 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖；\nbundledDependencies这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：\n&#123; \n  &quot;name&quot;: &quot;project&quot;, \n  &quot;version&quot;: &quot;1.0.0&quot;, \n  &quot;bundleDependencies&quot;: [ \n    &quot;axios&quot;,  \n    &quot;lodash&quot; \n  ] \n&#125; \n当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 npm install project-1.0.0.tgz 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。\n&quot;bundleDependencies&quot;: [ \n    &quot;axios&quot;, \n    &quot;lodash&quot; \n  ], \n&quot;dependencies&quot;: &#123; \n  &quot;axios&quot;: &quot;*&quot;, \n  &quot;lodash&quot;: &quot;*&quot; \n&#125;, \n如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。\n总结本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。\n参考文献\n原文\npackage.json官方文档\npackage-lock-json官方文档\nnpm文档总结\nnpm-pack\n\n","slug":"2022-05-19npm","date":"2022-05-19T10:10:47.000Z","categories_index":"npm","tags_index":"工具,npm","author_index":"举手摘月亮"},{"id":"72e60ad0a93fafff72edb1b0852502a0","title":"TypeScript noEmit","content":"No Emit -noEmitDo not emit compiler output files like JavaScript source code, source-maps or declarations.不要发出编译器输出文件，如JavaScript源代码、源映射或声明。\nThis makes room for another tool like Babel, or swc to handle converting the TypeScript file to a file which can run inside a JavaScript environment.\nYou can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.\n导致outDir不输出\n","slug":"2022-05-18ts","date":"2022-05-18T08:55:53.000Z","categories_index":"Typescript","tags_index":"TypeScript","author_index":"举手摘月亮"},{"id":"38b6e3ab42ce78e34a964ff2e90b3a7d","title":"Slate 学习","content":"文档slate 中文文档slate 英文文档\n是什么\n\n\n\n\n\n\n\n\nSlate 是一个 完全 可定制的富文本编辑框架。通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。\n能做什么\n\n\n\n\n\n\n\n\n通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。Slate 之所以能做到这一点，是因为它的所有逻辑都是通过一系列的插件实现的。这样，你就再也不会被某项特性 在 或 不在 编辑器【核心】边界之内的问题所困扰了。你可以将它理解为在 React 和 Immutable 基础上，一种可插拔的 contenteditable 实现。另外，它的灵感来自于 Draft.js，Prosemirror 和 Quill 等类库。\n产生的背景\n\n\n\n\n\n\n\n\n为什么发明 Slate 呢？好吧…（注意，这部分内容包含了一些我的个人观点！）\n\n\n\n\n\n\n\n\n\n在发明 Slate 之前，我尝试了许多不同的富文本编辑器。我发现虽然它们在编写简单示例时基本没有问题，但一旦想要构建一些类似 Medium、Dropbox Paper 或者 Google Docs 这样的内容，你就会发现一些深层次的问题，比如…\n\n\n\n\n\n\n\n\n\n编辑器硬编码了文档的结构规范，难以定制。类似加粗和斜体的结构可以开箱即用，但评论、嵌入内容以及更多的定制性需求呢？\n\n\n\n\n\n\n\n\n\n对文档的编程式变换非常错综复杂。用户的编写体验可能不错，但在执行编程式变更时却不必要地复杂，而这对于构建高级的编辑行为至关重要。\n\n\n\n\n\n\n\n\n\n对 HTML、Markdown 等内容的序列化支持看起来像是事后加上的。这是一个非常常见的使用场景，但要实现将文档转换为 HTML 或 Markdown 的简单功能都需要编写大量的模板代码。\n\n\n\n\n\n\n\n\n\n重新学习一个新的视图层效率不高且十分受限。各种编辑器在重新发明视图层的轮子，而非使用 React 这样已有的技术方案。你必须学习一套带着自有限制和陷阱的新系统。\n\n\n\n\n\n\n\n\n\n**对协同编辑没有预先设计好的支持**。编辑器内部的数据结构使其无法用于实时、协作的编辑场景中，除非重写编辑器。\n\n\n\n\n\n\n\n\n\n代码仓库是单体的，而非小而可复用的。许多编辑器没有对外开放本应为开发者所复用的内部工具，以至于不得不重新发明轮子。\n\n\n\n\n\n\n\n\n\n无法构建复杂而存在嵌套关系的文档。不少编辑器是围绕简单的【扁平】文档结构设计的，这使得表格、嵌入内容和字幕等内容难以理解，有时甚至无法实现。\n\n\n\n\n\n\n\n\n\n当然，并非所有的编辑器都存在以上的问题，但如果你已经尝试过一些编辑器，你可能已经踩过类似的坑了。为了摆脱它们在 API 上的限制来达到你期望的用户体验，你得使用各种奇技淫巧，有些体验甚至是完全无法实现的。\n\n\n\n\n\n\n\n\n\n如果你遇到了相似的问题，那么也许你会喜欢上 Slate。让我来介绍一下 Slate 是如何解决这些问题的吧…\n提供了什么能力\n\n\n\n\n\n\n\n\nSlate 尝试通过一些原则来解决 “Why?” 这一节中\b的问题：\n\n\n\n\n\n\n\n\n\n作为一等公民的插件。 在 Slate 中最重要的一点是，插件是一等公民（first-class）的实体——甚至连编辑器的核心逻辑都是通过插件实现的。这意味着你能够 完全地 定制编辑体验，构建出对标 Medium 和 Canvas 那样的复杂编辑器，而无需对抗各种类库的预设条件。\n\n\n\n\n\n\n\n\n\n精简 Schema 的核心。 Slate 的核心逻辑并不对你所编辑的数据结构做任何假设，这意味着你在需要应对复杂场景时不会被编辑器预置的内容所束缚（译者注：此处 Schema 可理解为类似 XML Schema 的文档结构规范）。\n\n\n\n\n\n\n\n\n\n支持嵌套的文档模型。 Slate 所使用的文档模型是一棵嵌套的、递归的树，和 DOM 本身十分接近。这使得构建表格和嵌套引用等能够满足进阶需求的复杂组件成为了可能。当然，你同样可以使用单一的层级关系以保证简单性。\n\n\n\n\n\n\n\n\n\n无状态、不可变的数据。 通过使用 React 和 Immutable.js，我们是基于不可变数据结构，以无状态的方式构建 Slate 编辑器的。这大大降低了理解代码的难度，也节约了大量开发插件的时间。\n\n\n\n\n\n\n\n\n\n直观的 changes。 Slate 中的内容是通过 “change” 来编辑的，这是一种被设计为支持高阶使用，且极其符合直觉的概念。这样，我们就能够通过它来尽可能简单地编写插件和自定义功能了。\n\n\n\n\n\n\n\n\n\n**为协同编辑准备的数据模型**。 Slate 使用的数据模型——尤其是由 change 更改文档的方式——在设计时就已考虑到对协同编辑的支持。所以，如果你决定为编辑器添加协作功能，你不需要进行彻底的重构。（当然，这还需要你投入更多的努力！）\n\n\n\n\n\n\n\n\n\n明确的【核心】边界划分。 通过插件优先的架构与精简 Schema 的内核，Slate 对于【核心】和【自定义】有着明确得多的划分，从而保证核心的编辑体验不会为各种边缘情况所困扰。\n协同编辑，这个后面会持续关注slate-yjsyjs\nslate 文档不是很多，半小时看完主要内容 \n\n插件定制化\n渲染节点定制化\n按键监听处理\n数据格式编码、反编码\n数据存储\n\n就这点东西😱竟然有些同学凭借slate的使用拿了3.75,赶紧学～\n","slug":"2022-04-29slate-lean","date":"2022-05-16T13:00:00.000Z","categories_index":"wiki","tags_index":"wiki","author_index":"举手摘月亮"},{"id":"deffdaaa2a24a19ee257667b3b36743c","title":"设计模式","content":"先聊用到过哪些，背后的设计模式是什么\n实例化一个 axios 实例，全局都来使用它 单例模式\n兄弟组件通信,事件监听 观察者模式\n构造函数继承、类的继承 构造函数模式\n实例化不同的实例 工厂模式\n优化中的事件代理代理模式\nesm、commonjs模块模式\n\n熟悉而又陌生：熟悉的是一直在用，陌生的是学名竟然是这些。我都有点怀疑了，这是真的吗？是真的吗？～～～\n\n   来～来～来～，我们继续。。。\n\n啥呀\n\n\n\n\n\n\n\n\n“设计模式(英语 design pattern)是对面向对象设计中反复出现的问题的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的。”\n策略模式代理模式\n作用：访问控制\n场景：事件代理、Proxy、Object.defineProperty\n\n单例模式\n定义：唯一实例，全局可访问\n场景：请求实例、全局缓存、线程池、window 对象、登录浮框\n实现：已经创建过的直接返回，不重复创建\n\n工厂模式\n作用：创建同一类对象\n分类：简单工厂_、_方法工厂\n\n1. 简单工厂\n例如：项目中根据用户权限渲染不同的页面，在不同权限等级用户的构造函数中，保存用户可以看到的页面\n优点：一个正确的参数，就可以获取到所需要的对象，无需知道其创建的具体细节\n缺点：函数会成为一个超级函数，难以维护，简单工厂适用于创建少量对象，对象的逻辑不能复杂\n\n2. 工厂方法\n本质：将创建对象的工作，推迟到子类中，这样核心类就变成抽象类\n\nlet UserFactory &#x3D; function (type) &#123;\n  if (this instanceof UserFactory) &#123;\n    return new this[type]();\n  &#125; else &#123;\n    return new UserFactory(type);\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 工厂方法，函数的原型中设置所有对象的构造函数\n\nUserFactory.prototype &#x3D; &#123;\n  SuperAdmin: function () &#123;\n    this.name &#x3D; &quot;超级管理员&quot;;\n    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;, &quot;应用管理&quot;, &quot;权限管理&quot;];\n  &#125;,\n  Admin: function () &#123;\n    this.name &#x3D; &quot;管理员&quot;;\n    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;];\n  &#125;,\n  NormalUser: function () &#123;\n    this.name &#x3D; &quot;普通用户&quot;;\n    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;];\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 调用\nlet superAdmin &#x3D; new UserFactory(&quot;SuperAdmin&quot;);\nlet admin &#x3D; new UserFactory(&quot;Admin&quot;);\nlet normalUser &#x3D; new UserFactory(&quot;NormalUser&quot;);\n\n3. 抽象工厂\n\n\n构造函数模式👀 观察者模式\n定义： 对象间的一种一对多的依赖关系\n作用：一个对象状态发生变化时，所有依赖他的对象，都将得到通知\n优点：解耦\n组成：发布者、订阅者\n场景：事件监听、eventBus\n\ndocument.body.addEventListener(&quot;click&quot;, function () &#123;&#125;, false);\n\n混合模式模块模式\n作用：避免全局污染，按需暴露\n实现：多采用闭包\n\nvar Person &#x3D; (function () &#123;\n  var name &#x3D; &quot;xxx&quot;;\n  function sayName(params) &#123;\n    console.log(name);\n  &#125;\n  return &#123;\n    name,\n    sayName,\n  &#125;;\n&#125;)();\n","slug":"2022-05-13design_mode","date":"2022-05-13T09:01:15.000Z","categories_index":"前端","tags_index":"设计模式,前端","author_index":"举手摘月亮"},{"id":"e2b55be84d65cc914ce2f0d3a3e083d3","title":"ant design form设置值 !== 获取值","content":"有意思的事\n今天维护项目遇到一个有意思的事，直观感受，设置值，再取出来，貌似没毛病  &#x2F;&#x2F; ...\n  const [values, setValues] &#x3D; useState&lt;Record&lt;string, any&gt;&gt;()\n\n  const &#123; applyStartTime, applyEndTime, attendanceType, staffId &#125; &#x3D; values || &#123;&#125;\n\n  const getDetail &#x3D; usePersistFn(async () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ...略\n    const obj: Record&lt;string, any&gt; &#x3D; &#123;\n      staffId: applyStaff.staffId,\n      attendanceType: res.result.attendanceType,\n      applyStartTime: &#123;\n        value: moment(res.result.applyStartTime),\n        half: res.result.startDayType,\n      &#125;,\n      applyEndTime: &#123;\n        value: moment(res.result.applyEndTime),\n        half: res.result.endDayType,\n      &#125;,\n      applyReason,\n      applyAttachments,\n    &#125;\n    &#x2F;&#x2F; ...略\n    form.setFieldsValue(obj)\n    setValues(form.getFieldsValue())\n  &#125;)\n\n  &#x2F;&#x2F; ...略\n  const &#123; total, loading: totalLoading &#125; &#x3D; useCaculateDays(\n    &#123;\n      start: applyStartTime,\n      end: applyEndTime,\n    &#125;,\n    staffId,\n    attendanceType,\n  )\n  &#x2F;&#x2F; ...略\n\n  &#x2F;&#x2F; AnualForm组件\n  &lt;Form.Item name&#x3D;&quot;applyStartTime&quot; label&#x3D;&quot;起始日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;\n      &lt;HalftDatePicker predict&#x3D;&#123;&#123; lessThan: end?.value &#125;&#125; &#x2F;&gt;\n    &lt;&#x2F;Form.Item&gt;\n  &lt;Form.Item name&#x3D;&quot;applyEndTime&quot; label&#x3D;&quot;结束日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;\n    &lt;HalftDatePicker predict&#x3D;&#123;&#123; moreThan: start?.value &#125;&#125; &#x2F;&gt;\n  &lt;&#x2F;Form.Item&gt;\n\n\n  type IValue &#x3D; &#123;\n    value?: moment.Moment\n    half: 1 | 2\n  &#125;\n &#x2F;&#x2F; HalftDatePicker组件\nconst HalftDatePicker: React.ForwardRefRenderFunction&lt;any, PickerProps&lt;moment.Moment&gt; &amp; &#123;\n  value?: IValue\n  onChange?: (v?: IValue) &#x3D;&gt; void\n  predict?: &#123;\n    lessThan?: moment.Moment\n    moreThan?: moment.Moment\n    holiday?: boolean\n  &#125;\n&#125;&gt; &#x3D; (props, ref) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...略\n&#125;\n\n代码的目的是： \n\n请求详情\n装配数据，更新values\nuseCaculateDays 通过后台动态计算有效工作日，返回total请假天数，\n渲染total到表单对应位置\n\n调试经过一点一点回溯调试，发现 useCaculateDays 没请求，被判断拦截掉了，往上找找，\nform.setFieldsValue(obj)\nsetValues(form.getFieldsValue())\n\n打上日志&#x2F;&#x2F; ...略\nconsole.log(&quot;obj&quot;,obj);\nform.setFieldsValue(obj)\nconsole.log(&quot;obj1&quot;,form.getFieldsValue());\nsetValues(obj)\n\n发现obj键值内容不等于obj1\n\nobj\n\n&#123;\n    &quot;staffId&quot;: &quot;02333&quot;,\n    &quot;attendanceType&quot;: 11,\n    &quot;applyStartTime&quot;: &#123;\n        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,\n        &quot;half&quot;: 1\n    &#125;,\n    &quot;applyEndTime&quot;: &#123;\n        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,\n        &quot;half&quot;: 2\n    &#125;,\n    &quot;applyReason&quot;: &quot;&quot;,\n    &quot;applyAttachments&quot;: []\n&#125;\n\n\nobj1&#123;\n    &quot;staffId&quot;: &quot;02333&quot;,\n    &quot;attendanceType&quot;: 11,\n    &quot;applyReason&quot;: &quot;&quot;,\n    &quot;applyAttachments&quot;: []\n&#125;\n\n猜想\n\n会不会form.setFieldsValue异步？查了下api是同步的排除这种可能\n断点调试过程中，也会遇到表单渲染一半的情况，AnualForm组件是条件渲染，如果这块表单没有渲染出来，通过form.getFieldsValue就拿不到\n\n修改代码验证下猜想console.log(&quot;obj&quot;,obj);\nform.setFieldsValue(obj)\nconsole.log(&quot;obj1&quot;,form.getFieldsValue());\nsetTimeout(() &#x3D;&gt; &#123;\n  setValues(form.getFieldsValue())\n  &#125;, 5000);\n&#125;\n\n\n最终修改form.setFieldsValue(obj)\nsetValues(obj)","slug":"2022-05-13react","date":"2022-05-13T07:39:33.000Z","categories_index":"React","tags_index":"React,bug","author_index":"举手摘月亮"},{"id":"f31094f49d8642b9a610a9630bcdbff8","title":"ModHeader","content":"通过不同请求头字段标识请求不同的环境\n\nRequesr HeadersAccept: *&#x2F;*\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,zh-TW;q&#x3D;0.7\nCache-Control: no-cache\nConnection: keep-alive\ncontent-type: application&#x2F;json; charset&#x3D;utf-8\nCookie: perfLang&#x3D;zh; \nenvtag: ladon-1        \nHost: localhost:3119\nPragma: no-cache\nReferer: http:&#x2F;&#x2F;localhost:3119&#x2F;\nsec-ch-ua: &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Chromium&quot;;v&#x3D;&quot;101&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;101&quot;\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: &quot;macOS&quot;\n不生效了理论上是没问题，应该是由于某些原因导致这个插件内部运行出了问题，具体什么问题不知处理：将浏览器重启动后,请求头envtag: ladon-1增加成功\n","slug":"2022-05-13modeheader","date":"2022-05-13T06:59:19.000Z","categories_index":"工具","tags_index":"工具,Chrome","author_index":"举手摘月亮"},{"id":"efb20c5240686fa74a28eb245753ea20","title":"前端基础-性能优化1","content":"优化的指标\n白屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器出现第一个元素\n首屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器第一屏渲染完成\n影响白屏时间的因素：网络，服务端性能，前端页面结构设计。\n影响首屏时间的因素：白屏时间，资源下载执行时间。\n通常在 head 解析完，body 开始渲染，此时是白屏结束\n白屏时间= firstPaint - performance.timing.navigationStart || pageStartTime\n\n常用方法\n首屏模块标签标记， 首屏完成的地方插入脚本\n同级首屏内加载最慢的图片&#x2F;iframe\n\n这个图看不懂没关系，往下看，后面会以简书代码和掘金来验证这幅图的正确性\n官方图\n\n非官方图\n\n缺失部分：secureConnectionStart\nchrome 时间说明chrome timing explanation\nView the timing breakdown of a request\nTiming breakdown phases explained\n直观感受下\n\n注意下面的一行小字： the Server Timing API\n输入 url 发生了什么\n当浏览器地址中输入 url 后，navigationStart如果之前有前一个网页（与当前页面不一定同域）unload 的时间戳,如果无前一个网页 unload ，则与 fetchStart 值相等,\n\n接着，是否有重定向（redirect ）\n\n接着，准备用 HTTP 抓取文档的内容（fetchStart）查看APP Cache\n\n域名查询（domainLookupStart、domainLookupEnd）\nTCP 连接（connectStart、connectEnd）,如果是安全链接，在 connectEnd 之前，会有 SSL 连接(secureConnectionStart)\n\n\n接着，HTTP 请求（requestStart、responseStart、responseEnd）,如果有缓存，在 responseStart 之前，会有 cacheStart，如果之前有网页，还涉及到网页的 unload，在 cacheStart 之前，会有unloadStart、unloadEnd\n\n接着，dom 解析\n说明：\n\ndom 解析过程，HTML 生成 dom 树，\n解析 CSS 文件生成 CSSOM 树，\nDOM 树和 CSSOM 树生成 render 树，也就是渲染树，\nrender 树中对每个节点进行布局，计算每个元素的大小，确定其在屏幕中的位置，绘制。\n根据 render 树和布局将显示页面\n\n\ndom 解析 过程中会触发一系列事件\n\ndomLoadingDocument.readyState 变为 loading，并将抛出 readystatechange 相关事件\ndomInteractiveDocument.readyState 变为 interactive，并将抛出 readystatechange 相关事件\ndomContentLoadedEventStart、domContentLoadedEventEnd DOM 解析完成后，\n网页内资源加载开始，并将抛出 readystatechange 相关事件\n网页内资源加载完成，并将抛出 readystatechange 相关事件\n\n\ndomCompleteDocument.readyState 变为 complete，并将抛出 readystatechange 相关事件\nloadEventStartload 事件发送给文档，也即 load 回调函数开始执行\nloadEventEndload 事件的回调函数执行完毕的时间\n\n\n\n加载阶段左边红线代表的是网络传输层面的过程，右边红线代表了服务器传输回字节后浏览器的各种事件状态，这个阶段包含了浏览器对文档的解析，DOM 树构建，布局，绘制等等。\n1. prompt for unload\n\nnavigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。2. 前一个网页卸载\nunloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。\nunloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。3. 重定向\nredirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。\nredirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。4. 使用 HTTP 请求\nfetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。5. 域名解析\ndomainLookupStart&#x2F;domainLookupEnd: DNS 域名查询开始&#x2F;结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等6. tcp 链接\nconnectStart: HTTP（TCP）开始&#x2F;重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。7. ssl 建立\nsecureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。\nconnectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。8. 读取文档\nrequestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。9. 响应\nresponseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。\nresponseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。10. 解析 dom\ndomLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。11. dom 可交互\ndomInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。12. 页面内资源加载\ndomContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。\ndomContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。13. dom 树解析完成\ndomComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。14. load 事件\nloadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。\nloadEventEnd: load 事件的回调函数执行完毕的时间。\n\nPerformance 接口Performance 接口可以获取到当前页面与性能相关的信息。\n\n\n\n\n\n\nTIP\n数据先不要关注时间循序，后面我们会从多个角度来验证顺序\n\n&#123;\n  &quot;timeOrigin&quot;: 1652338539312.5,\n  &#x2F;&#x2F; 顺序已经排好了\n  &quot;timing&quot;: &#123;\n    &#x2F;&#x2F; 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等\n    &quot;navigationStart&quot;: 1652338539312,\n    &#x2F;&#x2F; 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0\n    &quot;redirectStart&quot;: 0,\n    &#x2F;&#x2F; 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0\n    &quot;redirectEnd&quot;: 0,\n    &#x2F;&#x2F; 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前\n    &quot;fetchStart&quot;: 1652338539316,\n    &#x2F;&#x2F; DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n    &quot;domainLookupStart&quot;: 1652338539353,\n    &#x2F;&#x2F; DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n    &quot;domainLookupEnd&quot;: 1652338539353,\n    &#x2F;&#x2F; HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等\n    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间\n    &quot;connectStart&quot;: 1652338539353,\n    &#x2F;&#x2F; HTTPS 连接开始的时间，如果不是安全连接，则值为 0\n    &quot;secureConnectionStart&quot;: 1652338539401,\n    &#x2F;&#x2F; HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等\n    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间\n    &#x2F;&#x2F; 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过\n    &quot;connectEnd&quot;: 1652338539504,\n    &#x2F;&#x2F; HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存\n    &#x2F;&#x2F; 连接错误重连时，这里显示的也是新建立连接的时间\n    &quot;requestStart&quot;: 1652338539505,\n    &#x2F;&#x2F; HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存\n    &quot;responseStart&quot;: 1652338539807,\n    &#x2F;&#x2F; 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0\n    &quot;unloadEventStart&quot;: 0,\n    &#x2F;&#x2F; 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳\n    &quot;unloadEventEnd&quot;: 0,\n    &#x2F;&#x2F; HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存\n    &quot;responseEnd&quot;: 1652338539828,\n    &#x2F;&#x2F; 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件\n    &quot;domLoading&quot;: 1652338539823,\n    &#x2F;&#x2F; 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件\n    &#x2F;&#x2F; 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源\n    &quot;domInteractive&quot;: 1652338540574,\n    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载开始的时间\n    &#x2F;&#x2F; 在 DOMContentLoaded 事件抛出前发生\n    &quot;domContentLoadedEventStart&quot;: 1652338540574,\n    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）\n    &quot;domContentLoadedEventEnd&quot;: 1652338540575,\n    &#x2F;&#x2F; DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件\n    &quot;domComplete&quot;: 1652338542489\n    &#x2F;&#x2F; load 事件发送给文档，也即 load 回调函数开始执行的时间\n    &#x2F;&#x2F; 注意如果没有绑定 load 事件，值为 0\n    &quot;loadEventStart&quot;: 1652338542489,\n    &#x2F;&#x2F; load 事件的回调函数执行完毕的时间\n    &quot;loadEventEnd&quot;: 1652338542492,\n  &#125;,\n  &quot;navigation&quot;: &#123;\n    &#x2F;&#x2F; 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）\n    &#x2F;&#x2F; 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面\n    &#x2F;&#x2F; 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）\n    &#x2F;&#x2F; 255 即 TYPE_UNDEFINED    非以上方式进入的页面\n    &quot;type&quot;: 0,\n    &quot;redirectCount&quot;: 0 &#x2F;&#x2F; &#x2F;&#x2F; 如果有重定向的话，页面通过几次重定向跳转而来\n  &#125;\n&#125;\n\nfunction getPerfermanceTiming() &#123;\n  let t &#x3D; performance.timing;\n\n  &#x2F;&#x2F; 重定向结束时间 - 重定向开始时间\n  let redirect &#x3D; t.redirectEnd - t.redirectStart;\n  &#x2F;&#x2F; DNS 查询开始时间 - fetech start 时间\n  let appCache &#x3D; t.domainLookupStart - t.fetchStart;\n  &#x2F;&#x2F; DNS 查询结束时间 - DNS 查询开始时间\n  let dns &#x3D; t.domainLookupEnd - t.domainLookupStart;\n  &#x2F;&#x2F; 完成 TCP 连接握手时间 - TCP 连接开始时间\n  let tcp &#x3D; t.connectEnd - t.connectStart;\n  &#x2F;&#x2F; 从请求开始到接收到第一个响应字符的时间\n  let ttfb &#x3D; t.responseStart - t.requestStart;\n  &#x2F;&#x2F; 资源下载时间，响应结束时间 - 响应开始时间\n  let contentDL &#x3D; t.responseEnd - t.responseStart;\n  &#x2F;&#x2F; 从请求开始到响应结束的时间\n  let httpTotal &#x3D; t.responseEnd - t.requestStart;\n  &#x2F;&#x2F; 从页面开始到 domContentLoadedEventEnd\n  let domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;\n  &#x2F;&#x2F; 从页面开始到 loadEventEnd\n  let loaded &#x3D; t.loadEventEnd - t.navigationStart;\n\n  let result &#x3D; [\n    &#123; key: &quot;Redirect&quot;, desc: &quot;网页重定向的耗时&quot;, value: redirect &#125;,\n    &#123; key: &quot;AppCache&quot;, desc: &quot;检查本地缓存的耗时&quot;, value: appCache &#125;,\n    &#123; key: &quot;DNS&quot;, desc: &quot;DNS查询的耗时&quot;, value: dns &#125;,\n    &#123; key: &quot;TCP&quot;, desc: &quot;TCP连接的耗时&quot;, value: tcp &#125;,\n    &#123;\n      key: &quot;Waiting(TTFB)&quot;,\n      desc: &quot;从客户端发起请求到接收到响应的时间 &#x2F; Time To First Byte&quot;,\n      value: ttfb,\n    &#125;,\n    &#123;\n      key: &quot;Content Download&quot;,\n      desc: &quot;下载服务端返回数据的时间&quot;,\n      value: contentDL,\n    &#125;,\n    &#123; key: &quot;HTTP Total Time&quot;, desc: &quot;http请求总耗时&quot;, value: httpTotal &#125;,\n    &#123;\n      key: &quot;DOMContentLoaded&quot;,\n      desc: &quot;dom加载完成的时间&quot;,\n      value: domContentloaded,\n    &#125;,\n    &#123; key: &quot;Loaded&quot;, desc: &quot;页面load的总耗时&quot;, value: loaded &#125;,\n  ];\n  return result;\n&#125;\ngetPerfermanceTiming();\n\n\n\n聊下性能计算&#x2F;&#x2F; 计算加载时间\nfunction getPerformanceTiming() &#123;\n  var performance &#x3D; window.performance;\n\n  if (!performance) &#123;\n    &#x2F;&#x2F; 当前浏览器不支持\n    console.log(&quot;你的浏览器不支持 performance 接口&quot;);\n    return;\n  &#125;\n\n  var t &#x3D; performance.timing;\n  var times &#x3D; &#123;&#125;;\n\n  &#x2F;&#x2F;【重要】重定向的时间\n  &#x2F;&#x2F;【原因】拒绝重定向！比如，http:&#x2F;&#x2F;example.com&#x2F; 就不该写成 http:&#x2F;&#x2F;example.com\n  times.redirect &#x3D; t.redirectEnd - t.redirectStart;\n\n  &#x2F;&#x2F; DNS 缓存时间\n  times.appcache &#x3D; t.domainLookupStart - t.fetchStart;\n\n  &#x2F;&#x2F;【重要】DNS 查询时间\n  &#x2F;&#x2F;【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？\n  &#x2F;&#x2F; 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000000633364)\n  times.lookupDomain &#x3D; t.domainLookupEnd - t.domainLookupStart;\n\n  &#x2F;&#x2F; TCP 建立连接完成握手的时间\n  times.connect &#x3D; t.connectEnd - t.connectStart;\n\n  &#x2F;&#x2F;【重要】读取页面第一个字节的时间\n  &#x2F;&#x2F;【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？\n  &#x2F;&#x2F; TTFB 即 Time To First Byte 的意思\n  &#x2F;&#x2F; 维基百科：https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Time_To_First_Byte\n  times.ttfb &#x3D; t.responseStart - t.navigationStart;\n\n  &#x2F;&#x2F;【重要】解析 DOM 树结构的时间\n  &#x2F;&#x2F;【原因】反省下你的 DOM 树嵌套是不是太多了！\n  times.domReady &#x3D; t.domComplete - t.responseEnd;\n\n  &#x2F;&#x2F;【重要】内容加载完成的时间\n  &#x2F;&#x2F;【原因】页面内容经过 gzip 压缩了么，静态资源 css&#x2F;js 等压缩了么？\n  times.request &#x3D; t.responseEnd - t.requestStart;\n\n  &#x2F;&#x2F;【重要】页面加载完成的时间\n  &#x2F;&#x2F;【原因】这几乎代表了用户等待页面可用的时间\n  times.loadPage &#x3D; t.loadEventEnd - t.navigationStart;\n\n  &#x2F;&#x2F;【重要】执行 onload 回调函数的时间\n  &#x2F;&#x2F;【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？\n  times.loadEvent &#x3D; t.loadEventEnd - t.loadEventStart;\n\n  &#x2F;&#x2F; 卸载页面的时间\n  times.unloadEvent &#x3D; t.unloadEventEnd - t.unloadEventStart;\n\n  return times;\n&#125;\n\n聊下性能优化假设你对 performance API 很熟悉\n\n减少重定向次数\nDNS 查询时间：HTML5 Prefetch 预查询\nTCP 连接: http1.1 开启 connect: keep-alive, http2.0， 如果可以的话 http3.0 可以看本站另一篇文章\n资源压缩：gzip、brotli、图片压缩、tree-shaking、console、CDN 移除\n资源整合：减少请求次数、减少网络请求，雪碧图（虽然 http2 提供了多路复用[多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制,单个连接上可以并行交错的请求和响应，之间互不干扰,但是数量猛增，服务器要处理，多多少少也耗性能]的能力，而且现在还有使用的常见，比聊天表情，飞书也在用）\n资源加载：CDN、强缓存和协商缓存、按需加载\nDOM 解析：自上而下，script 标签放在底部，css 放在上面，无论是 html 还是 css 的层级，应尽量少的解析，解析消耗性能\n渲染时候：回流和重绘、懒加载、虚拟列表\n\n两个事例飞书雪碧图\n\n为什么拿飞书桌端数据来说（之前开发桌面端 Electron，扒拉过飞书应用包的数据)\n\n\n\n百度每个表情单独一个图\nchrome 调试 看请求\n\n\n京东移动端 dns-prefetch\n\n为什么拿京东数据来说（之前爬取过京东移动端数据开发 RN)\n\n\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    window.alert &#x3D; console.log;\n  &lt;&#x2F;script&gt;\n  &lt;script&gt;\n    window._PFM_TIMING &#x3D; [[1351, new Date()]]; &#x2F;&#x2F;TODO\n  &lt;&#x2F;script&gt;\n  &lt;meta\n    name&#x3D;&quot;viewport&quot;\n    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0&quot;\n  &#x2F;&gt;\n  &lt;title&gt;多快好省，购物上京东！&lt;&#x2F;title&gt;\n  &lt;!-- 强缓存Cache-Control --&gt;\n  &lt;meta http-equiv&#x3D;&quot;Cache-Control&quot; content&#x3D;&quot;max-age&#x3D;180&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;\n  &lt;!-- 京东 &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt; 写重复了 --&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;m.360buyimg.com&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;\n  &lt;meta\n    name&#x3D;&quot;viewport&quot;\n    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0, shrink-to-fit&#x3D;no, viewport-fit&#x3D;cover&quot;\n  &#x2F;&gt;\n  &lt;!-- X-DNS-Prefetch-Control 头控制着浏览器的 DNS 预读取功能  DNS 预读取是一项使浏览器主动去执行域名解析的功能--&gt;\n  &lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot; &#x2F;&gt;\n\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img11.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img10.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img12.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img13.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img14.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img20.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img30.360buyimg.com&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;wq.360buyimg.com&quot; &#x2F;&gt;\n&lt;&#x2F;head&gt;\n\nperformance 数据能干啥用？（开发者）熟悉 Chrome 开发者工具的朋友应该知道：在开发环境下，其实我们自己打开 Chrome 的开发者工具，切换到网络面板，就能很详细的看到网页性能相关的数据。\n（网站用户）但当我们需要统计分析用户打开我们网页时的性能如何时，我们将 performance 原始信息或通过简单计算后的信息 (如上面写到的 getPerformanceTiming()) 上传到服务器，配合其他信息（如 HTTP 请求头信息），就完美啦~\n来看下简书\n链接 简书 ,打开控制台可以看到输出结果一个数组（如果简书没将此日志去除）\n简书代码\n\nwindow.addEventListener(&quot;load&quot;, function () &#123;\n  setTimeout(function () &#123;\n    var e &#x3D; window.performance;\n    if (e) &#123;\n      var t &#x3D; e.getEntriesByType(&quot;navigation&quot;)[0],\n        r &#x3D; 0;\n      t || (r &#x3D; (t &#x3D; e.timing).navigationStart);\n      var n &#x3D; [\n        &#123;\n          key: &quot;Redirect&quot;,\n          desc: &quot;\\u7f51\\u9875\\u91cd\\u5b9a\\u5411\\u7684\\u8017\\u65f6&quot;,\n          value: t.redirectEnd - t.redirectStart,\n        &#125;,\n        &#123;\n          key: &quot;AppCache&quot;,\n          desc: &quot;\\u68c0\\u67e5\\u672c\\u5730\\u7f13\\u5b58\\u7684\\u8017\\u65f6&quot;,\n          value: t.domainLookupStart - t.fetchStart,\n        &#125;,\n        &#123;\n          key: &quot;DNS&quot;,\n          desc: &quot;DNS\\u67e5\\u8be2\\u7684\\u8017\\u65f6&quot;,\n          value: t.domainLookupEnd - t.domainLookupStart,\n        &#125;,\n        &#123;\n          key: &quot;TCP&quot;,\n          desc: &quot;TCP\\u8fde\\u63a5\\u7684\\u8017\\u65f6&quot;,\n          value: t.connectEnd - t.connectStart,\n        &#125;,\n        &#123;\n          key: &quot;Waiting(TTFB)&quot;, &#x2F;&#x2F; TTFB：Time To First Byte\n          desc: &quot;\\u4ece\\u5ba2\\u6237\\u7aef\\u53d1\\u8d77\\u8bf7\\u6c42\\u5230\\u63a5\\u6536\\u5230\\u54cd\\u5e94\\u7684\\u65f6\\u95f4 &#x2F; Time To First Byte&quot;,\n          value: t.responseStart - t.requestStart,\n        &#125;,\n        &#123;\n          key: &quot;Content Download&quot;,\n          desc: &quot;\\u4e0b\\u8f7d\\u670d\\u52a1\\u7aef\\u8fd4\\u56de\\u6570\\u636e\\u7684\\u65f6\\u95f4&quot;,\n          value: t.responseEnd - t.responseStart,\n        &#125;,\n        &#123;\n          key: &quot;HTTP Total Time&quot;,\n          desc: &quot;http\\u8bf7\\u6c42\\u603b\\u8017\\u65f6&quot;,\n          value: t.responseEnd - t.requestStart,\n        &#125;,\n        &#123;\n          key: &quot;DOMContentLoaded&quot;,\n          desc: &quot;dom\\u52a0\\u8f7d\\u5b8c\\u6210\\u7684\\u65f6\\u95f4&quot;,\n          value: t.domContentLoadedEventEnd - r,\n        &#125;,\n        &#123;\n          key: &quot;Loaded&quot;,\n          desc: &quot;\\u9875\\u9762load\\u7684\\u603b\\u8017\\u65f6&quot;,\n          value: t.loadEventEnd - r,\n        &#125;,\n      ];\n      if (Math.random() &gt; 0.75) &#123;\n        var s &#x3D; window.location,\n          i &#x3D; s.href,\n          c &#x3D; s.pathname,\n          u &#x3D; navigator.userAgent,\n          d &#x3D; i.split(&quot;?&quot;)[0];\n        o.a\n          .post(&quot;https:&#x2F;&#x2F;tr.jianshu.com&#x2F;fe&#x2F;1&#x2F;mon&#x2F;atf&quot;, &#123;\n            app: &quot;shakespeare-performance&quot;,\n            url: d,\n            ua: u,\n            path: c,\n            stats_ttfb: t.responseStart - t.requestStart,\n            stats_domLoaded: t.domContentLoadedEventEnd - r,\n            stats_loaded: t.loadEventEnd - r,\n          &#125;)\n          .then(a.a)\n          .catch(a.a);\n      &#125;\n      console &amp;&amp; console.log &amp;&amp; console.log(n);\n    &#125;\n  &#125;, 0);\n&#125;);\n\n简书截图\ndomContentLoaded 与 loaded&#x2F;&#x2F; 从页面开始到 domContentLoadedEventEnd\nlet domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;\n&#x2F;&#x2F; 从页面开始到 loadEventEnd\nlet loaded &#x3D; t.loadEventEnd - t.navigationStart;\n\ndomContentLoadedEventEnd 比 loaded 先触发\n\n\n\n掘金页面\n话说已经到了 6 月 6 号，闲逛掘金，遇到面试题：从输入url到页面展示发生了什么，突然想起个 performance,就拿掘金的一个页面来验证这幅图\n\n\n\n\n\n\n\n\n\n\nWARNING\n注意：此代码放到 dayjs 网站的 Sources&#x2F;Snippets 中执行，利用全局的 dayjs，无需引入 dayjs\n\ndayjs 网站\n\n\n代码是为了对 performance.timing 按照时间值进行排序，排序结果大致是执行的顺序，稍微有出入，会手动做调整\n代码如下：\n\nvar timing &#x3D; &#123;\n  connectStart: 1654499041800,\n  navigationStart: 1654499041744,\n  loadEventEnd: 1654499043641,\n  domLoading: 1654499042279,\n  secureConnectionStart: 1654499041820,\n  fetchStart: 1654499041746,\n  domContentLoadedEventStart: 1654499042718,\n  responseStart: 1654499042247,\n  responseEnd: 1654499042304,\n  domInteractive: 1654499042495,\n  domainLookupEnd: 1654499041800,\n  redirectStart: 0,\n  requestStart: 1654499041849,\n  unloadEventEnd: 1654499042267,\n  unloadEventStart: 1654499042267,\n  domComplete: 1654499043640,\n  domainLookupStart: 1654499041750,\n  loadEventStart: 1654499043641,\n  domContentLoadedEventEnd: 1654499042718,\n  redirectEnd: 0,\n  connectEnd: 1654499041849,\n&#125;;\n&#x2F;&#x2F; YYYY-MM-DD HH:一定一致，这个就不看了\nvar fmt &#x3D; &quot;mm:ss:SSS&quot;;\nvar arr &#x3D; [];\nvar sort_obj &#x3D; &#123;&#125;;\n\nfunction fmt_sort_key(obj) &#123;\n  for (let [key, value] of Object.entries(obj)) &#123;\n    arr.push(&#123;\n      key,\n      value,\n    &#125;);\n  &#125;\n\n  const sortArr &#x3D; arr.sort((a, b) &#x3D;&gt; a.value - b.value);\n\n  const fmtSortArr &#x3D; sortArr.map((item) &#x3D;&gt; &#123;\n    if (!item.value) return item;\n    return &#123;\n      ...item,\n      value: dayjs(item.value).format(fmt),\n    &#125;;\n  &#125;);\n\n  console.log(fmtSortArr);\n&#125;\nfmt_sort_key(timing);\n\n非无痕首次访问const timing &#x3D; &#123;\n  connectStart: 1654391072118,\n  navigationStart: 1654391071928,\n  loadEventEnd: 1654391076402,\n  domLoading: 1654391072670,\n  secureConnectionStart: 1654391072118,\n  fetchStart: 1654391071969,\n  domContentLoadedEventStart: 1654391074189,\n  responseStart: 1654391072621,\n  responseEnd: 1654391072664,\n  domInteractive: 1654391073865,\n  domainLookupEnd: 1654391072118,\n  redirectStart: 0,\n  requestStart: 1654391072199,\n  &#x2F;&#x2F; 没有之前页面的卸载\n  unloadEventEnd: 0,\n  unloadEventStart: 0,\n\n  domComplete: 1654391076400,\n  domainLookupStart: 1654391072118,\n  loadEventStart: 1654391076400,\n  domContentLoadedEventEnd: 1654391074189,\n  redirectEnd: 0,\n  connectEnd: 1654391072199,\n&#125;;\n\n&#x2F;&#x2F; 时间戳 1654391072118： connectStart、secureConnectionStart、domainLookupStart、domainLookupEnd ，这个值是相同的\n\n&#x2F;&#x2F; 把上述 timing 使用dayjs进行转化，看下每个key对应的time,对于0是没有进行的操作，我们跳过不处理（知道没进行）\n\nvar timingfmt &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;04:31:928&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;04:31:969&quot; &#125;,\n  &#123; key: &quot;connectStart&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;04:32:118&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;04:32:199&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;04:32:199&quot; &#125;,\n\n  &#123; key: &quot;responseStart&quot;, value: &quot;04:32:621&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;04:32:664&quot; &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;04:32:670&quot; &#125;,\n  &#123; key: &quot;domInteractive&quot;, value: &quot;04:33:865&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;04:34:189&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;04:34:189&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;04:36:400&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;04:36:400&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;04:36:402&quot; &#125;,\n];\n\n我们看下结果 2022-06-05 09:04，年月日时分都是一致的，我们只关心三位的毫秒数\n非无痕第二次访问const timing2 &#x3D; &#123;\n  connectStart: 1654494048918,\n  navigationStart: 1654494048902,\n  loadEventEnd: 1654494054146,\n  domLoading: 1654494049851,\n  secureConnectionStart: 0, &#x2F;&#x2F; 走缓存\n  fetchStart: 1654494048918,\n  domContentLoadedEventStart: 1654494051380,\n  responseStart: 1654494049430,\n  responseEnd: 1654494049514,\n  domInteractive: 1654494051115,\n  domainLookupEnd: 1654494048918,\n  redirectStart: 0,\n  requestStart: 1654494048942,\n  &#x2F;&#x2F; 有之前页面卸载\n  unloadEventEnd: 1654494049537,\n  unloadEventStart: 1654494049536,\n\n  domComplete: 1654494054143,\n  domainLookupStart: 1654494048918,\n  loadEventStart: 1654494054143,\n  domContentLoadedEventEnd: 1654494051381,\n  redirectEnd: 0,\n  connectEnd: 1654494048918,\n&#125;;\n\nvar timingfmt2 &#x3D; [\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;40:48:902&quot; &#125;,\n\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;40:48:918&quot; &#125;,\n\n  &#123; key: &quot;connectStart&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;40:48:918&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;40:48:942&quot; &#125;,\n  &#123; key: &quot;responseStart&quot;, value: &quot;40:49:430&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;40:49:514&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;40:49:536&quot; &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;40:49:537&quot; &#125;,\n  &#123; key: &quot;domLoading&quot;, value: &quot;40:49:851&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;40:51:115&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;40:51:380&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;40:51:381&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;40:54:143&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;40:54:143&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;40:54:146&quot; &#125;,\n];\n\n非无痕 f5 手动刷新var timing3 &#x3D; &#123;\n  connectStart: 1654495600379,\n  navigationStart: 1654495600360,\n  loadEventEnd: 1654495604101,\n  domLoading: 1654495601005,\n  secureConnectionStart: 1654495600389,\n  fetchStart: 1654495600364,\n  domContentLoadedEventStart: 1654495601947,\n  responseStart: 1654495600935,\n  responseEnd: 1654495600989,\n  domInteractive: 1654495601794,\n  domainLookupEnd: 1654495600379,\n  redirectStart: 0,\n  requestStart: 1654495600404,\n  unloadEventEnd: 1654495600971,\n  unloadEventStart: 1654495600970,\n  domComplete: 1654495604099,\n  domainLookupStart: 1654495600379,\n  loadEventStart: 1654495604099,\n  domContentLoadedEventEnd: 1654495601947,\n  redirectEnd: 0,\n  connectEnd: 1654495600403,\n&#125;;\n\nvar timingfmt3 &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;06:40:360&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;06:40:364&quot; &#125;,\n\n  &#123; key: &quot;connectStart&quot;, value: &quot;06:40:379&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;06:40:379&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;06:40:379&quot; &#125;,\n\n  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;06:40:389&quot; &#125;,\n\n  &#123; key: &quot;connectEnd&quot;, value: &quot;06:40:403&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;06:40:404&quot; &#125;,\n\n  &#123; key: &quot;responseStart&quot;, value: &quot;06:40:935&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;06:40:970&quot; &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;06:40:971&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;06:40:989&quot; &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;06:41:005&quot; &#125;,\n  &#123; key: &quot;domInteractive&quot;, value: &quot;06:41:794&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;06:41:947&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;06:41:947&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;06:44:099&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;06:44:099&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;06:44:101&quot; &#125;,\n];\n\n无痕模式首次var timing4 &#x3D; &#123;\n  connectStart: 1654496795083,\n  navigationStart: 1654496795041,\n  loadEventEnd: 1654496799718,\n  domLoading: 1654496795428,\n  secureConnectionStart: 1654496795093,\n  fetchStart: 1654496795050,\n  domContentLoadedEventStart: 1654496796111,\n  responseStart: 1654496795420,\n  responseEnd: 1654496795469,\n  domInteractive: 1654496795680,\n  domainLookupEnd: 1654496795083,\n  redirectStart: 0,\n  requestStart: 1654496795123,\n  unloadEventEnd: 0,\n  unloadEventStart: 0,\n  domComplete: 1654496799718,\n  domainLookupStart: 1654496795057,\n  loadEventStart: 1654496799718,\n  domContentLoadedEventEnd: 1654496796111,\n  redirectEnd: 0,\n  connectEnd: 1654496795123,\n&#125;;\n\nvar timing4fmt &#x3D; [\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;26:35:041&quot; &#125;,\n\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;26:35:050&quot; &#125;,\n\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;26:35:057&quot; &#125;,\n\n  &#123; key: &quot;connectStart&quot;, value: &quot;26:35:083&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;26:35:083&quot; &#125;,\n  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;26:35:093&quot; &#125;,\n  &#123; key: &quot;requestStart&quot;, value: &quot;26:35:123&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;26:35:123&quot; &#125;,\n\n  &#123; key: &quot;responseStart&quot;, value: &quot;26:35:420&quot; &#125;,\n\n  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;26:35:428&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;26:35:469&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;26:35:680&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;26:36:111&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;26:36:111&quot; &#125;,\n\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;26:39:718&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;26:39:718&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;26:39:718&quot; &#125;,\n];\n\n无痕模式刷新var timing5 &#x3D; &#123;\n  connectStart: 1654496848681,\n  navigationStart: 1654496848679,\n  loadEventEnd: 1654496850263,\n  domLoading: 1654496848983,\n  secureConnectionStart: 0,\n  fetchStart: 1654496848681,\n  domContentLoadedEventStart: 1654496849277,\n  responseStart: 1654496848959,\n  responseEnd: 1654496849017,\n  domInteractive: 1654496849096,\n  domainLookupEnd: 1654496848681,\n  redirectStart: 0,\n  requestStart: 1654496848702,\n  unloadEventEnd: 1654496848979,\n  unloadEventStart: 1654496848979,\n  domComplete: 1654496850262,\n  domainLookupStart: 1654496848681,\n  loadEventStart: 1654496850262,\n  domContentLoadedEventEnd: 1654496849277,\n  redirectEnd: 0,\n  connectEnd: 1654496848681,\n&#125;;\n\nvar timing5fmt &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;27:28:679&quot; &#125;,\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;connectStart&quot;, value: &quot;27:28:681&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;27:28:681&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;requestStart&quot;, value: &quot;27:28:702&quot; &#125;,\n  &#123; key: &quot;responseStart&quot;, value: &quot;27:28:959&quot; &#125;,\n\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;27:28:979&quot; &#125;,\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;27:28:979&quot; &#125;,\n\n  &#123; key: &quot;domLoading&quot;, value: &quot;27:28:983&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;27:29:017&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;27:29:096&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;27:29:277&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;27:29:277&quot; &#125;,\n\n  &#123; key: &quot;domComplete&quot;, value: &quot;27:30:262&quot; &#125;,\n\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;27:30:262&quot; &#125;,\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;27:30:263&quot; &#125;,\n];\n\n无痕模式刷新 + disable-cachevar timing6 &#x3D; &#123;\n  connectStart: 1654496917781,\n  navigationStart: 1654496917780,\n  loadEventEnd: 1654496921224,\n  domLoading: 1654496918186,\n  secureConnectionStart: 0,\n  fetchStart: 1654496917781,\n  domContentLoadedEventStart: 1654496918836,\n  responseStart: 1654496918156,\n  responseEnd: 1654496918293,\n  domInteractive: 1654496918654,\n  domainLookupEnd: 1654496917781,\n  redirectStart: 0,\n  requestStart: 1654496917784,\n  unloadEventEnd: 1654496918182,\n  unloadEventStart: 1654496918182,\n  domComplete: 1654496921224,\n  domainLookupStart: 1654496917781,\n  loadEventStart: 1654496921224,\n  domContentLoadedEventEnd: 1654496918836,\n  redirectEnd: 0,\n  connectEnd: 1654496917781,\n&#125;;\nvar timing6fmt &#x3D; [\n  &#x2F;&#x2F; 以下按照时间排序\n  &#123; key: &quot;navigationStart&quot;, value: &quot;28:37:780&quot; &#125;,\n\n  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理\n  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,\n  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;fetchStart&quot;, value: &quot;28:37:781&quot; &#125;,\n\n  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;28:37:781&quot; &#125;,\n  &#123; key: &quot;domainLookupStart&quot;, value: &quot;28:37:781&quot; &#125;,\n  &#123; key: &quot;connectStart&quot;, value: &quot;28:37:781&quot; &#125;,\n  &#123; key: &quot;connectEnd&quot;, value: &quot;28:37:781&quot; &#125;,\n\n  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,\n\n  &#123; key: &quot;requestStart&quot;, value: &quot;28:37:784&quot; &#125;,\n  &#123; key: &quot;responseStart&quot;, value: &quot;28:38:156&quot; &#125;,\n  &#x2F;&#x2F; 和 timing5fmt比较，之前页面的卸载，非常快\n  &#123; key: &quot;unloadEventStart&quot;, value: &quot;28:38:182&quot; &#125;,\n  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;28:38:182&quot; &#125;,\n  &#x2F;&#x2F; 注意 domLoading 和 responseEnd,这两个，顺序不定\n  &#123; key: &quot;domLoading&quot;, value: &quot;28:38:186&quot; &#125;,\n  &#123; key: &quot;responseEnd&quot;, value: &quot;28:38:293&quot; &#125;,\n\n  &#123; key: &quot;domInteractive&quot;, value: &quot;28:38:654&quot; &#125;,\n\n  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;28:38:836&quot; &#125;,\n  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;28:38:836&quot; &#125;,\n\n  &#123; key: &quot;loadEventEnd&quot;, value: &quot;28:41:224&quot; &#125;,\n  &#123; key: &quot;domComplete&quot;, value: &quot;28:41:224&quot; &#125;,\n  &#123; key: &quot;loadEventStart&quot;, value: &quot;28:41:224&quot; &#125;,\n];\n\n这个操作竟然有一个 base64 编码图片依然被缓存了,浏览器 disable-cache 对于有些内存缓存的图片竟然是无效的.\nRequest URL: data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC\nRequest Method: GET\nStatus Code: 200 OK (from memory cache)\nReferrer Policy: strict-origin-when-cross-origin\n\n\nDNS 缓存在实际的解析过程中，并不是客户端的每一次访问都需要委托递归服务器进行迭代查询，\n\n而是先搜索浏览器自身的 DNS 缓存，如果有，解析到此为止；\n如果 DNS 缓存中没有结果就会读取操作系统中的 HOSTS 文件查找对应的映射关系，如果有到此完成；\n如果没有，再请求递归服务器，进行全球递归查询。从中我们可以看出 DNS 缓存是获取域名解析记录的第一步骤。\n\n性能优化策略见\nhttp3WebTransport_API\n参考资料Web 性能优化-首屏和白屏时间\n初探 performance – 监控网页与程序性能\n简述浏览器渲染机制\n浅谈 DNS 缓存的作用和影响\nTTFB\n什么是网站 TTFB？以及 6 个优化 TTFB 的方法\nWeb 开发技术&gt;Web API 接口参考&gt;Resource Timing API&gt;Using the Resource Timing API\nPerformance#各种术语\nView the timing breakdown of a request\nTiming breakdown phases explained\n","slug":"2022-05-12performance","date":"2022-05-12T10:27:05.000Z","categories_index":"性能优化","tags_index":"前端基础,性能优化,浏览器原理","author_index":"举手摘月亮"},{"id":"832da5e8309651301e718ddb27ca95fd","title":"vscode插件 paste code to snippets","content":"粘贴代码，生成用户代码片段背景\n其他插件具有共性，而不具特性 ，每次写代码，要么用第三方插件，现成的代码片段，时常不能满足日常开发需要\n自定义代码片段，手写 费时费力，一般步骤，粘贴、修改、格式化\n其他插件类似 vscode 宏变量的使用少之又少， 要么将开源插件定制化，要么重新开发\n快捷变量记不住\n\npaste code to snippets 优点：\n高度定制化\n跨语言（任何 vscode 支持的语言，都可在对应类型片段文件中进行增加）\n使用简单 （复制、唤起命令、挖孔）\n快捷提示完全自定义（想怎么写就怎么写）\n\n使用\n\n复制要生成的代码片段\ncmd + shift + p\n找到要生成代码片段的文件后缀\n执行 paste code to snippets\n下次使用\n\n问题\n如果配置了代码片段，没有提示, 查看settings.json对应\n打开 settings.json 命令： command + shift + p, 搜 &gt;settings以 markdown 为例 默认只读配置在升级后变成了 false\n\n&#x2F;&#x2F; Configure settings to be overridden for the markdown language.\n&quot;[markdown]&quot;:  &#123;\n\t&quot;editor.unicodeHighlight.ambiguousCharacters&quot;: false,\n\t&quot;editor.unicodeHighlight.invisibleCharacters&quot;: false,\n\t&quot;editor.wordWrap&quot;: &quot;on&quot;,\n\t&quot;editor.quickSuggestions&quot;: false  &#x2F;&#x2F; 改为true\n&#125;,\n\n\n修改\n\n有想法TODO: 之前代码片段复制之后是手动粘贴到对应的片段文件中的，我有个想法，既然我复制文件的文件类型我已经知道了，我复制的代码和输出的片段代码也已经处理了，那么之后我就能实现复制某个文件的代码，自动同步到对应的片段文件中，如果不需要定制化，也不用打开片段文件修改了\nTODO:想到这里我又有一个想法，既然我每次要命令，然后再找啊找，我可以用一个快捷键&quot;复制&quot;的同时，唤起要定制的代码片段对应的类型文件，直接进去，不用弯弯绕绕的\nTODO: github copilot 收费了，我们是不是可以把这个代码功能生成片段仓库，进行团队共享，类似 github copilot，我们不做 AI,做匹配是不是也可以\n","slug":"2022-05-11vscode","date":"2022-05-11T01:38:30.000Z","categories_index":"工具","tags_index":"增效,vscode","author_index":"举手摘月亮"},{"id":"93abbea43ed2a379b0063e5e30a44a58","title":"前端基础-HTTP3","content":"现状\n\n\n\n\n\n\n\n\n\nHTTP/3 的基础即谷歌多年探索的基于 UDP 的 QUIC 协议。与 TCP 相比，使用 UDP 可以提供更大的灵活性，并且可以使 QUIC 完全于用户空间中实现——对协议实现的更新不像 TCP 那样需要绑定到操作系统更新。使用 QUIC，可以简单地将 HTTP 级别的流映射到 QUIC 流的顶部，从而继承 HTTP/2 的所有优点，而不会产生队头阻塞。HTTP/3 虽仍处于草案状态，但很多用户已经跃跃欲试。\n优势\nHTTP&#x2F;3 利用 QUIC 加速 HTTP 请求，QUIC 提供比 TCP 和 TLS 更高的加密和性能\nQUIC 是一种默认加密的新传输协议，旨在加快 HTTP 传输速度以及使其更加安全\nHTTP&#x2F;3 基于 UDP，如果数据包丢失，只会中断一个流，而不会中断所有流，提高了同时获取多个对象的性能\n支持 0-RTT，消除服务器的 TLS 确认，使后续连接的启动速度更快\n\n演示下图表示 HTTP&#x2F;2 和 HTTP&#x2F;3 多路复用两个请求时，数据包丢失及其影响（请求及其相关的响应分别为深蓝和浅蓝色）\nHTTP&#x2F;2 多路复用 2 个请求。响应被分解为多个数据包，一旦一个数据包丢失了，两个请求都被阻止。HTTP&#x2F;3 复用 2 个请求。虽然浅色的数据包丢失了，但是深色的数据包传输得很好。在相同丢包率的条件下，HTTP&#x2F;3 和 HTTP&#x2F;2 性能测试对比如下测试环境：服务端（HTTP&#x2F;3 with cubic &amp; HTTP&#x2F;2 with bbr）、客户端（cubic）\n更多查看更多\nHTTP&#x2F;3\nQUIC\n","slug":"2022-05-11http","date":"2022-05-11T01:26:00.000Z","categories_index":"前端基础","tags_index":"前端基础,面试,http","author_index":"举手摘月亮"},{"id":"f5ccfd5f1ce5f78727a64a19669811c7","title":"Slate wiki-ui评论功能光标乱跳","content":"bug 复现bug复现 (node:29) UnhandledPromiseRejectionWarning: Error: Forbidden at &amp;#x2F;code&amp;#x2F;client&amp;#x2F;.next&amp;#x2F;server&amp;#x2F;pages&amp;#x2F;_app-a05...\n\n\n在 vite react 项目上，输入汉字的同时按住删除键，光标会乱跳\n排查 1:wiki（esm）组件问题，检查 wiki-ui 组件库，运行正常\n&quot;react&quot;: &quot;^16.8.0&quot;,\n&quot;react-dom&quot;: &quot;^16.8.0&quot;,\n\n排查 2:vite 加载 wiki-ui 组件时候，因为 vite 只能处理 esm，在 vite.config.ts, esbuildOptions 自定义插件进行处理wiki-ui，不是很懂，换个角度\nesbuildOptions: &#123;\n  plugins: [\n    &#123;\n      name: &#39;originjs:commonjs&#39;,\n      setup(build) &#123;\n        build.onLoad(\n          &#123;\n            filter: &#x2F;@敏感数据-fe\\&#x2F;wiki-ui\\&#x2F;dist&#x2F;,\n            namespace: &#39;file&#39;,\n          &#125;,\n          async (&#123; path: id &#125;) &#x3D;&gt; &#123;\n            const code &#x3D; readFileSync(id).toString()\n            const result &#x3D; transformRequire(code, id)\n\n            return &#123;\n              contents: result,\n              loader: &#39;js&#39;,\n            &#125;\n          &#125;,\n        ),\n          build.onLoad(\n            &#123;\n              filter: &#x2F;@敏感数据-fe\\&#x2F;wiki-ui\\&#x2F;dist\\&#x2F;components\\&#x2F;iconfont&#x2F;,\n              namespace: &#39;file&#39;,\n            &#125;,\n            async (&#123; path: id &#125;) &#x3D;&gt; &#123;\n              const code &#x3D; readFileSync(id).toString()\n              const result &#x3D; transformRequire(code, id)\n\n              return &#123;\n                contents: result,\n                loader: &#39;js&#39;,\n              &#125;\n            &#125;,\n          )\n      &#125;,\n    &#125;,\n    esbuildPluginMonacoEditorNls(&#123;\n      locale: Languages.zh_hans,\n    &#125;),\n  ],\n&#125;,\n\n排查 3:将 wiki-ui 组件放到 umijs 应用中运行\n# 搭建个项目\n# 移动demo组件到新项目\n# 运行，发现有相同的问题\n\n分析：1.dom输入过程中点击删除操作，那么在这个过程中，输入的内容是在contenteditable=&quot;true&quot; 中运行\n&lt;div data-gramm&#x3D;&quot;false&quot; role&#x3D;&quot;textbox&quot; spellcheck&#x3D;&quot;false&quot; class&#x3D;&quot;slash-slate-core&quot; id&#x3D;&quot;SLASH_SLATE_CORE&quot; data-app-id&#x3D;&quot;5A9BEA&quot; autocorrect&#x3D;&quot;false&quot; autocapitalize&#x3D;&quot;false&quot; data-slate-editor&#x3D;&quot;true&quot; data-slate-node&#x3D;&quot;value&quot; contenteditable&#x3D;&quot;true&quot; style&#x3D;&quot;position: relative; outline: none; white-space: pre-wrap; overflow-wrap: break-word;&quot;&gt;&lt;p data-slate-node&#x3D;&quot;element&quot;&gt;&lt;span data-slate-node&#x3D;&quot;text&quot;&gt;&lt;span data-slate-leaf&#x3D;&quot;true&quot;&gt;&lt;span data-slate-string&#x3D;&quot;true&quot;&gt;12121212哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈h h h h h h h h h h h h hs f s d f&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;\n\n2.合成事件应该会走合成事件，合成事件之后会执行渲染，web 端走的是 react-dom，比对正常运行的项目，和新项目的版本\n# react 17版本\n# react-dom 17版本\n\n3.react先进行react降版本 16.14.0，检查合成事件是否有问题，降版本后，运行，问题同样存在，大概可以断定是react-dom渲染出了问题，\n4.react-dom对react-dom降低版本到16.14.0, 后运行正常，那么问题应该在react-dom上\n5.github 版本 16.14.0两个版本有什么不同：查看react发布日志，16.14.0 之后的一个版本是17.0.0 (October 20, 2020) 看上去与事件和渲染相关的东西不多\nUse browser focusin and focusout for onFocus and onBlur. (@trueadm in #19186)\nMake all Capture events use the browser capture phase. (@trueadm in #19221)\nThrow if forwardRef or memo component returns undefined. (@gaearon in #19550)\nRemove event pooling. (@trueadm in #18969)\nFix onBeforeInput reporting an incorrect event.type. (@eps1lon in #19561)\nFix event.relatedTarget reported as undefined in Firefox. (@claytercek in #19607)\nFix rendering into a shadow root. (@Jack-Works in #15894)\nFix movementX&#x2F;Y polyfill with capture events. (@gaearon in #19672)\nArtifacts\nreact: https:&#x2F;&#x2F;unpkg.com&#x2F;react@17.0.1&#x2F;umd&#x2F;\nreact-art: https:&#x2F;&#x2F;unpkg.com&#x2F;react-art@17.0.1&#x2F;umd&#x2F;\nreact-dom: https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@17.0.1&#x2F;umd&#x2F;\nreact-is: https:&#x2F;&#x2F;unpkg.com&#x2F;react-is@17.0.1&#x2F;umd&#x2F;\nreact-test-renderer: https:&#x2F;&#x2F;unpkg.com&#x2F;react-test-renderer@17.0.1&#x2F;umd&#x2F;\nscheduler: https:&#x2F;&#x2F;unpkg.com&#x2F;scheduler@0.20.1&#x2F;umd&#x2F;\n\n6.github 版本 18.1.0在往后找最新的版本，发现在18.1.0 (April 26, 2022)，改了一堆react-dom的 bug,看上去也没相关的\nFix the false positive warning about react-dom&#x2F;client when using UMD bundle. (@alireza-molaee in #24274)\nFix suppressHydrationWarning to work in production too. (@gaearon in #24271)\nFix componentWillUnmount firing twice inside of Suspense. (@acdlite in #24308)\nFix some transition updates being ignored. (@acdlite in #24353)\nFix useDeferredValue causing an infinite loop when passed an unmemoized value. (@acdlite in #24247)\nFix throttling of revealing Suspense fallbacks. (@sunderls in #24253)\nFix an inconsistency in whether the props object is the same between renders. (@Andarist and @acdlite in #24421)\nFix a missing warning about a setState loop in useEffect. (@gaearon in #24298)\nFix a spurious hydration error. (@gnoff in #24404)\nWarn when calling setState in useInsertionEffect. (@gaearon in #24295)\nEnsure the reason for hydration errors is always displayed. (@gaearon in #24276)\n\n可用版本&quot;react&quot;: &quot;^16.14.0&quot;,\n&quot;react-dom&quot;: &quot;16.14.0&quot;,\n\n\n这个演示代码正常&lt;embed\n  type&#x3D;&quot;text&#x2F;html&quot;\n  src&#x3D;&quot;https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview&quot;\n  width&#x3D;&quot;100%&quot;\n  height&#x3D;&quot;200&quot;\n&#x2F;&gt;\n&lt;!--加载太慢，复制地址查看吧--&gt;\n&lt;!--https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview--&gt;\n\n懵逼。。。从头开始\n待办事项中的评论功能（组件问题）光标乱跳的问题；\n0. 项目 + wiki-ui 异常\n1. 单运行wiki-ui demo 正常\n2. 运行slate + umijs 正常\n3. 运行wiki-ui  + umijs 异常\n4. slate 与  wiki-ui  不一样在于slate版本\n5. wiki-ui 做了什么事情： 定制化一些节点展示，光标的渲染和wiki-ui无关\n\n贫僧先去 slate 官网化缘，回来再战slate-lean\n化缘归来问题怎么解决\n","slug":"2022-04-29slate","date":"2022-05-10T05:00:00.000Z","categories_index":"wiki","tags_index":"wiki","author_index":"举手摘月亮"},{"id":"097419cee069b6e2fdfe8a3b19f9ef54","title":"前端基础-跨域问题","content":"为什么会产生跨域浏览器安全策略限制跨域访问\n内容安全策略\n内容安全策略是一个额外的安全层，用于检测并削弱某些特定类型的攻击。\n包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。\n\n维基百科：\n内容安全策略（英语：Content Security Policy，简称 CSP）\n\n是一种计算机安全标准，\n目的是: 防御跨站脚本、点击劫持等代码注入攻击，阻止恶意内容在受信网页环境中执行。\n这一标准是 W3C 网络应用安全工作组的候选推荐标准，被现代网页浏览器广泛支持\n\n使用方式为使 CSP 可用, 你需要配置你的网络服务器返回 Content-Security-Policy，或者在 HTML  元素种也可配置该策略, 例如：\n&lt;meta\n  http-equiv&#x3D;&quot;Content-Security-Policy&quot;\n  content&#x3D;&quot;default-src &#39;self&#39;; img-src https:&#x2F;&#x2F;*; child-src &#39;none&#39;;&quot;\n&#x2F;&gt;\n\n配置示例1. 一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)\n&#x2F;&#x2F; Content-Security-Policy: default-src &#39;self&#39;\n\n2. 一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)\n&#x2F;&#x2F; Content-Security-Policy: default-src &#39;self&#39; *.trusted.com\n\n3. 一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码。\n&#x2F;&#x2F; Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com\n\n&#x2F;&#x2F; 在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:\n\n&#x2F;&#x2F; 1. 图片可以从任何地方加载(注意 &#96;*&#96; 通配符)。\n&#x2F;&#x2F; 2. 多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。\n&#x2F;&#x2F; 3. 可运行脚本仅允许来自于 userscripts.example.com。\n\n作者：菜鸡前端链接：https://www.jianshu.com/p/a45924e99a6d来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n处理方式nginx\n脚本\n\n\nlisten 80; # 监听的端⼝\n   add_header &#39;Access-Control-Allow-Origin&#39; &#39;$http_origin&#39; ;\n   add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,Content-Length,Authorization,Accept,X-Requested-With&#39; ;\n   add_header &#39;Access-Control-Allow-Methods&#39; &#39;PUT,POST,GET,DELETE,OPTIONS&#39; ;\n   add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39; ;\n   add_header &#39;Access-Control-Max-Age&#39; &#39;60&#39; ; # 秒\n\n\n实际操作\n\n\n服务端设置，类似 nginxcors 是⽬前主流的跨域解决⽅案，跨域资源共享(CORS) 是⼀种机制，它使⽤额外的 HTTP 头来告诉浏览器 让运⾏在⼀ 个 origin (domain) 上的 Web 应⽤被准许访问来⾃不同源服务器上的指定的资源。当⼀个资源从与该资源本身所在的服 务器不同的域、协议或端⼝请求⼀个资源时，资源会发起⼀个跨域 HTTP 请求。 如果你⽤ express，可以这样在后端设置\n&#x2F;&#x2F;CORS middleware\nvar allowCrossDomain &#x3D; function (req, res, next) &#123;\n  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http:&#x2F;&#x2F;example.com&quot;);\n  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET,PUT,POST,DELETE&quot;);\n  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);\n  &#x2F;&#x2F; 预检的存活时间\n  res.setHeader(&quot;Access-Control-Max-Age&quot;, 60);\n  next();\n&#125;;\n&#x2F;&#x2F;...\napp.configure(function () &#123;\n  app.use(express.bodyParser());\n  app.use(express.cookieParser());\n  app.use(express.session(&#123; secret: &quot;cool beans&quot; &#125;));\n  app.use(express.methodOverride());\n  app.use(allowCrossDomain);\n  app.use(app.router);\n  app.use(express.static(__dirname + &quot;&#x2F;public&quot;));\n&#125;);\n\n在⽣产环境中建议⽤成熟的开源中间件解决问题。\n不同的 nodejs 框架设置方式不同，一般跨域问题几乎框架官网必备，查下就晓得如何配置了，但本质都是改变相应头\njsonp 方式 &lt;动态 script&gt;最经典的跨域⽅案 jsonp, 本质上是⼀个 Hack，利⽤ &lt;script&gt; 标签不受同源策略限制的特性进⾏跨域操作。\njsonp 优点：实现简单 兼容性⾮常好\njsonp 的缺点：\n只⽀持 get 请求（因为 &lt;script&gt; 标签只能 get）\n有安全性问题，容易遭受 xss 攻击\n需要服务端配合 jsonp 进⾏⼀定程度的改造\n\njsonp 的实现：function JSONP(&#123; url, params, callbackKey, callback &#125;) &#123;\n  &#x2F;&#x2F; 在参数⾥制定 callback 的名字\n  params &#x3D; params || &#123;&#125;;\n  params[callbackKey] &#x3D; &quot;callback&quot;;\n  &#x2F;&#x2F; 预留 callback\n  window.callback &#x3D; callback;\n  &#x2F;&#x2F; 拼接参数字符串\n  const paramKeys &#x3D; Object.keys(params);\n  const paramString &#x3D; paramKeys.map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;).join(&quot;&amp;&quot;);\n  &#x2F;&#x2F; 插⼊ DOM 元素\n  const script &#x3D; document.createElement(&quot;script&quot;);\n  script.setAttribute(&quot;src&quot;, &#96;$&#123;url&#125;?$&#123;paramString&#125;&#96;);\n  document.body.appendChild(script);\n\n  &#x2F;&#x2F; 监听script标签的onload事件，当script标签执行后将其删除，避免代码结构的冗余\n  script.onload &#x3D; function () &#123;\n    &#x2F;&#x2F; 从body的删除掉添加的script标签\n    document.body.removeChild(script);\n  &#125;;\n&#125;\n\nJSONP(&#123;\n  url: &quot;http:&#x2F;&#x2F;s.weibo.com&#x2F;ajax&#x2F;jsonp&#x2F;suggestion&quot;,\n  params: &#123;\n    key: &quot;test&quot;,\n  &#125;,\n  callbackKey: &quot;callback&quot;,\n  callback(result) &#123;\n    console.log(result.data);\n  &#125;,\n&#125;);\n\njsonp 服务端改造var http &#x3D; require(&quot;http&quot;);\nvar urllib &#x3D; require(&quot;url&quot;);\n\nvar port &#x3D; 10011;\nvar data &#x3D; &#123; name: &quot;jifeng&quot;, company: &quot;tb&quot; &#125;;\n\nhttp\n  .createServer(function (req, res) &#123;\n    var params &#x3D; urllib.parse(req.url, true);\n    console.log(params);\n    if (params.query &amp;&amp; params.query.callback &#x2F;**对应客户端 *&#x2F;) &#123;\n      &#x2F;&#x2F;console.log(params.query.callback);\n      var str &#x3D; params.query.callback + &quot;(&quot; + JSON.stringify(data) + &quot;)&quot;; &#x2F;&#x2F;jsonp\n      res.end(str);\n    &#125; else &#123;\n      res.end(JSON.stringify(data)); &#x2F;&#x2F;普通的json\n    &#125;\n  &#125;)\n  .listen(port, function () &#123;\n    console.log(&quot;server is listening on port &quot; + port);\n  &#125;);\n\n其他（不常用）见：2022-09-19qa\npostMessage\nwindow.postMessage⽅法允许来⾃不同源的脚本采⽤异步⽅式进⾏有限的通信， 可以实现跨⽂本档、多窗⼝、跨域消息传递。\nwindow.postMessage() 方法提供了一种受控机制来规避同源策略的限制，只要正确的使用，这种方法就很安全。\n如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的 targetOrigin，而不是 *。\n不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。\n\notherWindow.postMessage(message, targetOrigin, [transfer]);\n\n\nDetails\n&#x2F;&#x2F; a.html\n  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;frame&quot; onload&#x3D;&quot;load()&quot;&gt;&lt;&#x2F;iframe&gt; &#x2F;&#x2F;等它加载完触发一个事件\n  &#x2F;&#x2F;内嵌在http:&#x2F;&#x2F;localhost:3000&#x2F;a.html\n    &lt;script&gt;\n      function load() &#123;\n        let frame &#x3D; document.getElementById(&#39;frame&#39;)\n        frame.contentWindow.postMessage(&#39;我爱你&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#39;) &#x2F;&#x2F;发送数据\n        window.onmessage &#x3D; function(e) &#123; &#x2F;&#x2F;接受返回数据\n          console.log(e.data) &#x2F;&#x2F;我不爱你\n        &#125;\n      &#125;\n    &lt;&#x2F;script&gt;\n\n\n&#x2F;&#x2F; b.html\nwindow.onmessage &#x3D; function (e) &#123;\n  console.log(e.data); &#x2F;&#x2F;我爱你\n  e.source.postMessage(&quot;我不爱你&quot;, e.origin);\n&#125;;\n\n\n\nWebSocketWebSocket 是⼀种双向通信协议，在建⽴连接之后，WebSocket 的 server 与 client 都能主动向对⽅发送或接收数 据，连接建⽴好了之后 client 与 server 之间的双向通信就与 HTTP ⽆关了，因此可以跨域。\ndocument.domain + iframedocument.domain + iframe：\n该⽅式只能⽤于⼆级域名相同的情况下，⽐如 a.test.com 和 b.test.com 适⽤于该⽅式，我们只需要给⻚⾯添加 document.domain &#x3D;’test.com’ 表示⼆级域名都相同就可以实现跨域，两个⻚⾯都通过 js 强制设置 document.domain 为基础主域，就实现了同域。\n\nDetails\n&#x2F;&#x2F; a.html\n&lt;body&gt;\n helloa\n  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;b.zf1.cn:3000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; onload&#x3D;&quot;load()&quot; id&#x3D;&quot;frame&quot;&gt;&lt;&#x2F;iframe&gt;\n  &lt;script&gt;\n    document.domain &#x3D; &#39;zf1.cn&#39;\n    function load() &#123;\n      console.log(frame.contentWindow.a);\n    &#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n&#x2F;&#x2F; b.html\n&lt;body&gt;\n  hellob\n  &lt;script&gt;document.domain &#x3D; &#39;zf1.cn&#39; var a &#x3D; 100;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\nlocation.hash + iframelocation.hash + iframe：a.html 欲与 c.html 跨域相互通信，通过中间⻚ b.html 来实现。 三个⻚⾯，不同域之间利⽤ iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。\n\n动态创建 iframe\n具体实现步骤：\n\n一开始 a.html 给 c.html 传一个 hash 值，\n然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，\n最后 b.html 将结果放到 a.html 的 hash 值中。\n同样的，a.html 和 b.html 是同域的，都是 http://localhost:3000; 而 c.html 是 http://localhost:4000\n\n&#x2F;&#x2F; a.html http:&#x2F;&#x2F;localhost:3000\n &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;c.html#iloveyou&quot;&gt;&lt;&#x2F;iframe&gt;\n &lt;script&gt;\n   window.onhashchange &#x3D; function () &#123; &#x2F;&#x2F;检测hash的变化\n     console.log(location.hash);\n   &#125;\n &lt;&#x2F;script&gt;\n\n\n&#x2F;&#x2F; b.html http:&#x2F;&#x2F;localhost:3000\n&lt;script&gt;\n  window.parent.parent.location.hash &#x3D; location.hash\n  &#x2F;&#x2F;b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面\n&lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; c.html http:&#x2F;&#x2F;localhost:4000\nconsole.log(location.hash);\nlet iframe &#x3D; document.createElement(&quot;iframe&quot;);\niframe.src &#x3D; &quot;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html#idontloveyou&quot;;\ndocument.body.appendChild(iframe);\n\n\n\nwindow.name + iframewindow.name + iframe：window.name 属性值在不同的⻚⾯（甚⾄不同域名）加载后依旧存在，并且可以⽀持⾮常 ⻓的 name 值，我们可以利⽤这个特点进⾏跨域。\n\nDetails\n&#x2F;&#x2F; a.html(http:&#x2F;&#x2F;localhost:3000&#x2F;b.html)\n &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;c.html&quot; frameborder&#x3D;&quot;0&quot; onload&#x3D;&quot;load()&quot; id&#x3D;&quot;iframe&quot;&gt;&lt;&#x2F;iframe&gt;\n &lt;script&gt;\n   let first &#x3D; true\n   &#x2F;&#x2F; onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n   function load() &#123;\n     if(first)&#123;\n     &#x2F;&#x2F; 第1次onload(跨域页)成功后，切换到同域代理页面\n       let iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n       iframe.src &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html&#39;;\n       first &#x3D; false;\n     &#125;else&#123;\n     &#x2F;&#x2F; 第2次onload(同域b.html页)成功后，读取同域window.name中数据\n       console.log(iframe.contentWindow.name);\n     &#125;\n   &#125;\n &lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; c.html(http:&#x2F;&#x2F;localhost:4000&#x2F;c.html)\n&lt;script&gt;window.name &#x3D; &#39;我不爱你&#39;&lt;&#x2F;script&gt;\n\n通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n\n参考链接九种跨域方式实现原理（完整版）\nContent Security Policy 入门教程\n","slug":"2022-05-09cors","date":"2022-05-09T13:30:47.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"99460a2013287be2d51642da6dd169f8","title":"面试题汇总","content":"值得收藏的链接\n码上通天\n\n面试完 50 个人后我写下这篇总结\n\nif 我是前端团队 Leader，怎么制定前端协作规范?\n\n做了一份前端面试复习计划，保熟～\n\nurl 解析过程\n\nzoomdong 面经\n\n见\n\n\n","slug":"2022-05-08interview","date":"2022-05-08T08:27:00.000Z","categories_index":"面试","tags_index":"面试","author_index":"举手摘月亮"},{"id":"b231170e726e8d41c02587c56363e3ce","title":"前端基础-js变量和作用域","content":"变量var let const 区别\n版本： var 是 es6 之前， const、let es6 之后，\n分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域\n提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行到声明处，提前使用会报错\n重复：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值\n存储：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的\n默认： 默认情况下是 var 声明\n函数：函数声明提升优先于 var\n\n补充说明： const 和不变性。\n\nconst 创建一个变量名绑定，该绑定在创建后不能重新分配。\nconst 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。\n\n见：2022-09-19qa\n变量分类 &amp; 执行结果输出\njs 中的变量分为两种：\n\n\n全局变量和局部变量。\n全局变量很好理解，就是在 js 任何地方都能够调用的变量；\n而局部变量就只能在函数的内部才能够调用的变量。\n\nvar a &#x3D; 10;\nfunction show() &#123;\n  console.log(&quot;a:&quot; + a); &#x2F;&#x2F;a:10\n  var b &#x3D; 2;\n  console.log(&quot;inside b:&quot; + b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&quot;outside b:&quot; + b); &#x2F;&#x2F;b is no defined\n\n在上面的程序中，\n\n变量 a 就是一个全局变量，在函数的内部能够调用。\n但是这里的变量 b 就是局部变量，\n当函数结束调用后，变量 b 就被回收了，因此在函数外部调用失败。\n\n另外需要特别注意的是：\n\n\n\n\n\n\n\n\n\n如果在声明局部变量时不用 var 声明，那么这个变量自动“提升”为全局变量。\nvar a &#x3D; 10;\nfunction show() &#123;\n  console.log(&quot;a:&quot; + a); &#x2F;&#x2F;a:10\n  b &#x3D; 2;\n  console.log(&quot;inside b:&quot; + b); &#x2F;&#x2F;inside b:2\n&#125;\nshow();\nconsole.log(&quot;outside b:&quot; + b); &#x2F;&#x2F;outside b:2\n\n对比两段代码，\n\n如果你在声明 b&#x3D;2 时没有写 var，那么 b 就隐式地声明为全局变量，在函数外面还是能够被调用到的。\n虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了缺点：\n一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。\n影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，\n可移植性: 同时也降低了函数的可移植性。\n\n\n\n因此我们在定义变量时一般要尽可能少的定义全局变量。\n变量声明函数声明优先于变量声明 (这句话的意思是：如果有一样的变量标识符，会先进性函数声明，忽略掉变量声明)\n下面我们通过一段代码来说明.\nvar a;\nfunction a() &#123;&#125;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 或许有人是认为函数声明在后面的原因，那么调换一下位置。\n\nfunction a() &#123;&#125;\nvar a;\nconsole.log(typeof a); &#x2F;&#x2F;function\n&#x2F;&#x2F; 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。\n&#x2F;&#x2F; 因此函数声明优先于变量的声明。\n&#x2F;&#x2F; 但是如果我们在声明的同时给a进行赋值。\n\nfunction a() &#123;&#125;\nvar a &#x3D; &quot;xyf&quot;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 我们将其调换一下位置再次进行验证。\n\nvar a &#x3D; &quot;xyf&quot;;\nfunction a() &#123;&#125;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：\n\nfunction a() &#123;&#125;\nvar a;\na &#x3D; &quot;xyf&quot;;\nconsole.log(typeof a); &#x2F;&#x2F;string\n&#x2F;&#x2F; a最后被赋值为字符串，因此a的类型自然是字符串\n\n作用域全局作用域js 中作用域只有函数作用域和全局作用域，\n函数作用域js 中作用域只有函数作用域和全局作用域，\n块级作用域let const有块级作用域。函数作用域是比较容易理解的，那么什么是块级作用域呢？\n&#123;var a &#x3D; 1&#125;\n\nconsole.log(a)\nVM2355:1 1\n\n\n&#123;let a &#x3D;1&#125;\n\nconsole.log(a)\nVM2079:1 Uncaught ReferenceError: a is not defined\n\n\n\n\n\n\n\n\n\n\n任何一对花括号&#123;&#125;中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。\n理解了块级作用域，来看一下下面的小例子。\nconsole.log(v); &#x2F;&#x2F;undefined\nvar v &#x3D; &quot;world&quot;; &#x2F;&#x2F; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。\n\n当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明\n由于 js 作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：\nvar v;\nconsole.log(v); &#x2F;&#x2F;undefined\nv &#x3D; &quot;world&quot;;\n&#x2F;&#x2F; 这样就能很清晰地理解为什么变量v是undefined的了。\n&#x2F;&#x2F;下面我们把变量v放到一个方法中去：\n\nif (true) &#123;\n  var v &#x3D; &quot;hello&quot;;\n&#125;\nconsole.log(v); &#x2F;&#x2F;hello\n&#x2F;&#x2F; 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，\n&#x2F;&#x2F; 并不能够“阻挡”外面的代码获取里面的变量。\n\n函数作用域实例我们再把变量 v 放到函数中去：\nfunction show() &#123;\n  var v &#x3D; &quot;world&quot;;\n&#125;\nshow();\nconsole.log(v); &#x2F;&#x2F;undefined\n\n由于 show 函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量 v。因此证明了 js 中只有函数作用域，没有块级作用域。　　再来看下面的一段代码：\nvar v &#x3D; &quot;hello&quot;;\nfunction show() &#123;\n  console.log(v); &#x2F;&#x2F;undefined\n  var v &#x3D; &quot;world&quot;;\n&#125;\nshow();\n\n很多人看到这边都会很疑惑，不是说这边 show 函数中能够获取到函数外面的变量的么？\n但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：\nvar v &#x3D; &quot;hello&quot;;\nfunction show() &#123;\n  var v;\n  console.log(v); &#x2F;&#x2F;undefined\n  v &#x3D; &quot;world&quot;;\n&#125;\nshow();\n\n这里把变量 v 的声明放到了整个函数作用域的最前面，因此显示为 undefined。理解了上面的代码，相信下面的代码也不难理解了。\nvar v &#x3D; &quot;hello&quot;;\n(function () &#123;\n  console.log(v);\n  var v &#x3D; &quot;world&quot;;\n&#125;)();\n\n在这里自执行函数形成了函数作用域\n需要注意的是\n变量提升只提升函数的声明，并不提升函数的定义\nshow(); &#x2F;&#x2F;show is not a function\nvar show &#x3D; function () &#123;\n  &#x2F;&#x2F;...\n&#125;;\nshow(); &#x2F;&#x2F;成功运行\n\n或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在 js 中是如何进行定义的。\n\n\n\n\n\n\n\n\n\n函数有两种定义方式，一种是函数声明，另一种是函数表达式。那么什么是函数声明什么是函数表达式呢？\n&#x2F;&#x2F;函数声明\nfunction show() &#123;\n  &#x2F;&#x2F;....\n&#125;\n&#x2F;&#x2F;函数表达式\nvar show &#x3D; function () &#123;\n  &#x2F;&#x2F;...\n&#125;;\n\n乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。\n\njs 的解析器对函数声明和函数表达式并不是一视同仁的对待的，有点“种族歧视”的意思在里面。\n函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。\n而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，因此，调用函数表达式要在定义后进行使用。\n\n\n\n见\n立即执行函数var b &#x3D; 10;\n(function b() &#123;\n  b &#x3D; 20;\n  console.log(b);\n&#125;)();\n\n\n代码进入预解析状态，将 var b 进行变量提升，此时 b 没有被赋值(b&#x3D;undefined) (这里有人会说这里明明有个函数表达式呀，为什么没有进入变量提升，因为 IIFE 自带有词法作用域(我们常理解得作用域))\n发现没有可以变量提升得时候将 b 赋值为 10，此时会将 b 赋值为 10(b&#x3D;10)\n碰到了立即执行函数，会执行其内边的函数 function b()\nIIFE 作用域中定义 b = function b()&#123;&#125;\n碰到了 b &#x3D; 20，会顺着作用域链寻找是否存在 b，发现 IIFE 作用域中存在 b，将 IIFE 作用域中的 b 赋值为 20(b=20)(因为函数表达式特性，标识符无法被修改，所以这里执行失败)\n执行 console.log(b)，此时的 b 会找 IIFE 中的作用域看看是否存在 b，发现其内边存在，将其返回\n\n解析 var b &#x3D; 10； (function b(){ b &#x3D; 20 console.log(b) })()\notherhttps://juejin.cn/post/6844904019165446158\n见\ntypeof nullnull 作为一个基本数据类型为什么会被 typeof 运算符识别为 object 类型呢？\n这个 bug 是第一版 Javascript 留下来的，javascript 中不同对象在底层都表示为二进制，而 javascript 中会把二进制前三位都为 0 的判断为 object 类型，而  null 的二进制表示全都是 0，自然前三位也是 0，所以执行 typeof 时会返回 ‘object’。 \n—-引用自《你不知道的 javascript（上卷）》\n事件循环async function async1() &#123;\n  console.log(&quot;1&quot;);\n  await async2();\n  console.log(&quot;2&quot;);\n&#125;\n\nasync function async2() &#123;\n  console.log(&quot;3&quot;);\n&#125;\n\nconsole.log(&quot;4&quot;);\n\nsetTimeout(function () &#123;\n  console.log(&quot;5&quot;);\n&#125;, 0);\n\nasync1();\n\nnew Promise(function (resolve) &#123;\n  console.log(&quot;6&quot;);\n  resolve();\n&#125;).then(function () &#123;\n  console.log(&quot;7&quot;);\n&#125;);\n\nconsole.log(&quot;8&quot;);\n\n\nasync 内部到 await 之前都是同步执行的\n遇到 await 会转交控制权\n同步任务执行完成后，await 会重新获得执行的控制权，继续执行往下执行\n\n&#x2F;&#x2F; 4, 1, 3, 6, 8, 2, 7, 5\n\nthis 指向var name &#x3D; &quot;123&quot;;\n\nvar obj &#x3D; &#123;\n  name: &quot;456&quot;,\n  print: function () &#123;\n    function a() &#123;\n      console.log(this.name);\n    &#125;\n    a();\n  &#125;,\n&#125;;\n\nobj.print();\n\n见\nvar 变量运行for (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(() &#x3D;&gt; console.log(i), 1);\n&#125;\nconsole.log(i); &#x2F;&#x2F; 输出3\n\n1. let 方案for (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(() &#x3D;&gt; console.log(i), i); &#x2F;&#x2F; 输出0,1,2\n&#125;\nconsole.log(i); &#x2F;&#x2F;报错\n\n2. iife 方案原理： 立即执行函数会形成对立的作用域\nfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  setTimeout(((i) &#x3D;&gt; console.log(i))(i) &#x2F;**输出0,1,2 *&#x2F;, 1);\n&#125;\n\nconsole.log(i); &#x2F;&#x2F; 输出3\n\nPromise 运行原理：浏览器事件循环\nPromise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&quot;Promise1&quot;);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&quot;setTimeout2&quot;);\n  &#125;, 0);\n&#125;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;setTimeout1&quot;);\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&quot;Promise2&quot;);\n  &#125;);\n&#125;, 0);\n&#x2F;&#x2F; 打印结果为：Promise1 -&gt; setTimeout1 -&gt; Promise2 -&gt;setTimeout2\n\n其他&#x2F;#&#x2F;post&#x2F;2022-05-08varible\n","slug":"2022-05-08varible","date":"2022-05-08T02:00:00.000Z","categories_index":"前端基础","tags_index":"前端基础,结果输出","author_index":"举手摘月亮"},{"id":"39b06ee79b8fd96256d44a33e065e573","title":"如何更好的沉淀","content":"背景\n工作日常经验性总结放哪？\n存电脑，电脑坏了重做系统没了，\n放到电脑备忘录，卧槽，怎么没及时更新\n放自己的服务器，没时间打理，服务器到期，嗝屁了，没来的及迁移\n\nhexo\nhexo 由于有丰富的插件和主题，使用及部署方便，备受欢迎\n自己购买服务器部署，服务器到期后续费很贵\n放到第三方博客上，好一点的像简书，每天发布限制两篇，可控性太差\n\nhexo 主题这里使用 aurora\ntheme: aurora\n\ntridiamondAlphaHinex\n阿里云 oss\n图片资源放到 github 上，访问较慢，为了提升体验，将资源放到 oss 上，权限配置为公开，可被任何用户访问\n\n阿里云域名\n域名访问比较方便，图片资源只有在使用域名的情况下，各资源可以预览，而不仅仅是下载\n\nPicGo 图床「贼好用，\n思考：除此之外，因为其开源我们可以学习下作者是如何处理插件的」\n为博客中 md 文档提供图片链接，放到阿里云 oss 上\n上传成功\n因为开发过 electron，第一想到的是我要 debug,打开控制台\n域名配错不可访问\n遇到图片,作为程序猿第一反应要优化「压缩」compress\n插件下载\n插件启用\n插件是否生效了\n插件列表github 链接\n\n书写文章 hexo 页面不热重载？yarn add global browser-sync\nyarn add hexo-browsersync\n\n启用评论# For local development only!\ngitalk:\n  enable: false\n  autoExpand: true\n  clientID: &quot;&quot;\n  clientSecret: &quot;&quot;\n  repo: &quot;dev-blog-comments&quot;\n  owner: &quot;TriDiamond&quot;\n  admin: [&quot;TriDiamond&quot;]\n  id: uid\n  language: en\n  distractionFreeMode: true\n  recentComment: true\n  proxy: &quot;&quot;\n\n# Valine comment plugin (recommended!)\n# see https:&#x2F;&#x2F;valine.js.org&#x2F;quickstart.html\nvaline:\n  enable: true\n  app_id: 去申请\n  app_key: 去申请\n  avatar: &quot;http:&#x2F;&#x2F;t-blog-images.aijs.top&#x2F;img&#x2F;avatar.jpeg&quot;\n  placeholder: Leave your thoughts behind~\n  visitor: true\n  lang: en\n  avatarForce: false\n  meta: [&quot;nick&quot;, &quot;mail&quot;]\n  requiredFields: []\n  admin: &quot;海龙&quot;\n  recentComment: true\n\n图片增加水印配置及效果\npicgo 生成代码\n可选不同的代码方式\n\n常见问题\n每次发布后，github page 自定义域名会丢失\n\n\n\n\n\n\n\n\n\n在_posts 目录下建立 CNAME 文件 填写上自己的域名\n\n图床 picGo，上传了图片，在 oss 上查看也成功了，但是 picGo 相册中没有展示\n\n\n\n\n\n\n\n\n\n/Users/chenhailong/Library/Application Support/picgo目录下，删除 rm picgo.db,重新启动见issue #781\n\n调整博客文件时间，运行后文章排序并没有改变，需要清理根目录下db.json\n\n部分 tag 找不到相关[tagName].json\n本地\n\n\n**线上**\n\n\n\nHexo 改变 tag 因为大小写问题而 404 的解决方法\n\nrelease 失败\n\n致命错误：无法访问 &#39;https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io&#x2F;&#39;：LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443\nFATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html\nError: Spawn failed\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js:51:21)\n    at ChildProcess.emit (node:events:369:20)\n    at Process.ChildProcess._handle.onexit (node:internal&#x2F;child_process:290:12)\nINFO Thanks for using Aurora v1.5.5\nINFO Check out the repo at: https:&#x2F;&#x2F;github.com&#x2F;auroral-ui&#x2F;hexo-theme-aurora\n ELIFECYCLE  Command failed with exit code 2.\n\n有个空的 shell 文件夹，导致打包报错\naurora 主题 bug作者是没空修改的\n\n文章详情categories，无法点击\n首页categories不展示\ncategories 路由找不到\n当代码类似的东西很长很长时，样式错乱\n\n源码\n见 hexo-theme-aurora 源码修改\nhexo toc 有误toc 链接 hash\n\n\n接口返回\n\n\n编译结果\n\n\nhexo 源代码\nfor (let i &#x3D; 0, len &#x3D; data.length; i &lt; len; i++) &#123;\n    const el &#x3D; data[i];\n    const &#123; level, id, text &#125; &#x3D; el;\n    const href &#x3D; id ? &#96;#$&#123;encodeURL(id)&#125;&#96; : null; &#x2F;&#x2F; href被编码了，而markdown标题没有编码，导致url的hash无法使用\n....\n    result +&#x3D; &#96;&lt;li class&#x3D;&quot;$&#123;className&#125;-item $&#123;className&#125;-level-$&#123;level&#125;&quot;&gt;&#96;;\n    if (href) &#123;\n      result +&#x3D; &#96;&lt;a class&#x3D;&quot;$&#123;className&#125;-link&quot; href&#x3D;&quot;$&#123;href&#125;&quot;&gt;&#96;;\n    &#125; else &#123;\n      result +&#x3D; &#96;&lt;a class&#x3D;&quot;$&#123;className&#125;-link&quot;&gt;&#96;;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 编译输出：&lt;ol class&#x3D;&quot;toc&quot;&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack-%E4%B8%8E-grunt%E3%80%81gulp-%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack 与 grunt、gulp 的不同？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack%E3%80%81rollup%E3%80%81parcel%E3%80%81vite-%E4%BC%98%E5%8A%A3%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack、rollup、parcel、vite 优劣？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84-Loader%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;有哪些常⻅的 Loader？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84-Plugin%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;有哪些常⻅的 Plugin？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D-bundle%EF%BC%8Cchunk%EF%BC%8Cmodule-%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;分别介绍 bundle，chunk，module 是什么&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#Loader-%E5%92%8C-Plugin-%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;Loader 和 Plugin 的不同？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack 的构建流程是什么?&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%8F%8F%E8%BF%B0%E2%BC%80%E4%B8%8B%E7%BC%96%E5%86%99-loader-%E6%88%96-plugin-%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;描述⼀下编写 loader 或 plugin 的思路？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack 的热更新原理？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E2%BD%A4-webpack-%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;⽤ webpack 来优化前端性能&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%A6%82%E4%BD%95%E6%8F%90%E2%BE%BC-webpack-%E7%9A%84%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;如何提⾼ webpack 的打包速度?&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%A6%82%E4%BD%95%E6%8F%90%E2%BE%BC-webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;如何提⾼ webpack 的构建速度？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%8D%95%E2%BB%9A%E5%BA%94%E2%BD%A4%EF%BC%9F%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%A4%9A%E2%BB%9A%E5%BA%94%E2%BD%A4%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;怎么配置单⻚应⽤？怎么配置多⻚应⽤？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#source-map-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;source map 是什么？生产环境怎么用？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;模块打包原理知道吗？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;参考链接&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt;\n\n\n问题是找到了，先不改，没得空～\n去除编码可行性\n以 webpack 官网为例：有中文妥妥滴，hexo 官方编了个码，整了个 bug\n\n\naurora 使用 history 模式我的想法：不同页面使用 history 模式，页面内标题滚动使用 hash。router.beforeEach在 hash 改变时候也能检测到，这个地方会触发 loading，但没有重新发送请求，也需要做调整\nvscode md 自动格式化issue\n\n\n日志输出\n[&quot;INFO&quot; - 10:08:24 AM] Prettier Options:\n&#123;\n  &quot;arrowParens&quot;: &quot;always&quot;,\n  &quot;bracketSpacing&quot;: true,\n  &quot;endOfLine&quot;: &quot;lf&quot;,\n  &quot;htmlWhitespaceSensitivity&quot;: &quot;css&quot;,\n  &quot;insertPragma&quot;: false,\n  &quot;singleAttributePerLine&quot;: false,\n  &quot;bracketSameLine&quot;: false,\n  &quot;jsxBracketSameLine&quot;: false,\n  &quot;jsxSingleQuote&quot;: false,\n  &quot;printWidth&quot;: 80,\n  &quot;proseWrap&quot;: &quot;preserve&quot;,\n  &quot;quoteProps&quot;: &quot;as-needed&quot;,\n  &quot;requirePragma&quot;: false,\n  &quot;semi&quot;: true,\n  &quot;singleQuote&quot;: false,\n  &quot;tabWidth&quot;: 2,\n  &quot;trailingComma&quot;: &quot;es5&quot;,\n  &quot;useTabs&quot;: false,\n  &quot;vueIndentScriptAndStyle&quot;: false,\n  &quot;filepath&quot;: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;source&#x2F;_posts&#x2F;2022-04-28博客创建.md&quot;,\n  &quot;parser&quot;: &quot;markdown&quot;\n&#125;\n[&quot;INFO&quot; - 10:08:24 AM] Formatting completed in 71ms.\n\n\n总结：总体而言 picgo 已经很好了，有几点可以优化\n\n已有图片二次重新上传压缩功能\n窗口实在是太小了，正常情况下可以手动拖拽改变大小\n插件列表插件卡片部分重叠\n\n文章书写参照AlphaHinex.github.io-develop\n隐藏一些文章见：2023-02-17hexo-secret\n","slug":"2022-04-28博客创建","date":"2022-05-06T01:17:27.000Z","categories_index":"工具","tags_index":"hexo","author_index":"举手摘月亮"},{"id":"4e47b6e9bf7ea41cfbf0d4f0a3fe5d3c","title":"Lerna调试开源库遇到的问题","content":"yarn install --mutex network:42424 --non-interactive\n\n👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ lerna --version\n4.0.0\n\n\n👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn global add lerna@3.19.0    \nUsage Error: The &#39;yarn global&#39; commands have been removed in 2.x - consider using &#39;yarn dlx&#39; or a third-party plugin instead\n\n$ yarn run [--inspect] [--inspect-brk] &lt;scriptName&gt; ...\n👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn --version              \n3.0.1","slug":"2022-05-05lerna","date":"2022-05-05T13:30:47.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"80947b2a66ed033838be54dc8f90264b","title":"MAC存储空间不足问题","content":"\n","slug":"2022-05-05mac","date":"2022-05-05T13:30:47.000Z","categories_index":"工具","tags_index":"工具","author_index":"举手摘月亮"},{"id":"33e5a22f0411954db88ba4aade9e1620","title":"前端基础-String","content":"转化为驼峰命名\n\n\n\n\n\n\n\n\nvar s1 = &quot;get-element-by-id&quot;\nvar f &#x3D; function (s) &#123;\n  return s.replace(&#x2F;-\\w&#x2F;g, function (x) &#123;\n    return x.splice(1).toUpperCase();\n  &#125;);\n&#125;;\n\n模版引擎实现let template &#x3D; &quot;我是&#123;&#123;name&#125;&#125;,年龄&#123;&#123;age&#125;&#125;,性别&#123;&#123;sex&#125;&#125;&quot;;\nlet data &#x3D; &#123;\n  name: &quot;姓名&quot;,\n  age: 18,\n&#125;;\n\nrender(template, data); &#x2F;&#x2F;我是姓名,年龄18,性别undefined\n\nfunction render(template, data) &#123;\n  &#x2F;&#x2F; 模版字符串正则\n  const reg &#x3D; &#x2F;\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;&#x2F;;\n  &#x2F;&#x2F; 判断模版里是否有模版字符串\n  if (reg.test(template)) &#123;\n    &#x2F;&#x2F; 查找当前模版里第一个模版字符串的字符\n    const name &#x3D; reg.exec(template)[1];\n    &#x2F;&#x2F; 将第一个模版字符串渲染\n    template &#x3D; template.replace(reg, data[name]);\n    &#x2F;&#x2F; 递归的渲染并返回渲染后的结构\n    return render(template, data);\n  &#125;\n  return template;\n&#125;\n\n解析 URL Params 为对象let url &#x3D;\n  &quot;http:&#x2F;&#x2F;www.domain.com&#x2F;?user&#x3D;anonymouse&amp;id&#x3D;123&amp;id&#x3D;456&amp;city&#x3D;%E5%8C%97%E4%BA%AC&amp;enabled&quot;;\n\n&#x2F;**\n * 结果\n * &#123;\n *  user: &#39;anonymouse&#39;,\n *  id: [123,456], &#x2F;&#x2F; 重复出现的key，要转化成数组\n *  city: &#39;北京&#39;, &#x2F;&#x2F; 中文需要解码\n *  enabled: true &#x2F;&#x2F; 未指定值的key，约定为true\n *\n *\n * &#125;\n *\n **&#x2F;\nfunction parseParam(url) &#123;\n  const paramsStr &#x3D; &#x2F;.+\\?(.+)$&#x2F;.exec(url)[1];\n  const paramsArr &#x3D; paramsArr.split(&quot;&amp;&quot;);\n  let paramsObj &#x3D; &#123;&#125;;\n\n  paramsArr.forEach((param) &#x3D;&gt; &#123;\n    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;\n      let [key, val] &#x3D; param.split(&quot;&#x3D;&quot;); &#x2F;&#x2F; 拆分键&#x2F;值\n      val &#x3D; decodeURLComponent(val); &#x2F;&#x2F; 汉字解码\n      val &#x3D; &#x2F;^\\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 数字转化\n      if (paramsObj.hasOwnProperty(key)) &#123;\n        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 重复key转数组\n      &#125; else &#123;\n        paramsObj[key] &#x3D; val;\n      &#125;\n    &#125; else &#123;\n      paramsObj[key] &#x3D; true; &#x2F;&#x2F; 处理约定\n    &#125;\n  &#125;);\n&#125;\n\n查找字符串中，出现最多的字符和个数let str &#x3D; &quot;abcabcabcbbcccc&quot;;\nlet num &#x3D; 0;\nlet char &#x3D; &quot;&quot;;\n\n&#x2F;&#x2F; 先排序，后用正则处理个数\n\nstr &#x3D; str.split(&quot;&quot;).sort().join(&quot;&quot;);\n\nlet re &#x3D; &#x2F;(\\w)\\1+&#x2F;g;\n\nstr.replace(re, ($0, $1) &#x3D;&gt; &#123;\n  if (num &lt; $0.length) &#123;\n    num &#x3D; $0.length;\n    char &#x3D; $1;\n  &#125;\n&#125;);\n\n字符串查找a &#x3D; &quot;34&quot;;\nb &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回2\na &#x3D; &quot;35&quot;;\nb &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回 -1\na &#x3D; &quot;355&quot;;\nb &#x3D; &quot;1234355&quot;; &#x2F;&#x2F; 返回5\n\nfunction isContain(a, b) &#123;\n  for (let i in b) &#123;\n    if (a[0] &#x3D;&#x3D;&#x3D; b[i]) &#123;\n      let tmp &#x3D; true; &#x2F;&#x2F; 标记：满足\n      for (let j in a) &#123;\n        if (a[j] !&#x3D;&#x3D; b[~~i + ~~j]) &#123;\n          tmp &#x3D; false; &#x2F;&#x2F; 标记：不满足\n        &#125;\n      &#125;\n      if (tmp) &#123;\n        return i;\n      &#125;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n\n实现千分位分隔符&#x2F;&#x2F; 保留三位小数\nparaseToMoney(1234.56); &#x2F;&#x2F; return &#39;1,234.56&#39;\nparaseToMoney(123456789); &#x2F;&#x2F; return 123,456,789\nparaseToMoney(1087654.321); &#x2F;&#x2F; return 1,087,654.321\n\nfunction paraseToMoney(params) &#123;\n  num &#x3D; parseFloat(num.toFixed(3));\n  let [integer, decimal] &#x3D; String.prototype.split.call(num, &quot;.&quot;);\n  integer &#x3D; integer.replace(&#x2F;\\d(?&#x3D;(\\d&#123;3&#125;))+$&#x2F;, &quot;$&amp;,&quot;);\n  return integer + &quot;.&quot; + (decimal ?? &quot;&quot;);\n&#125;\n\n判断是否是电话号码function isPhone(str) &#123;\n  let regx &#x3D; &#x2F;^1[34578]\\d&#123;9&#125;$&#x2F;;\n  return regx.test(str);\n&#125;\n\n判断是否是邮箱&#x2F;&#x2F; @之前必须有内容只能是 数字、字母(大小写)、下划线(_)、减号(-)、点（.）\n&#x2F;&#x2F; @之后和最后一个点（.）之间必须有内容且只能是 数字、字母(大小写)、下划线(_)、减号(-)，\n&#x2F;&#x2F; 两个点不能挨着\n&#x2F;&#x2F; 最后一个点（.）之后，必须有内容只能是 数字、字母（大小写），长度大于等于两个字节，小于等于6个字节\n\n&#x2F;&#x2F; 按照规则写\n\nfunction isEmail(email) &#123;\n  var regx &#x3D;\n    &#x2F;^[a-zA-Z0-9_.\\-]+@[a-zA-Z0-9\\-]+(\\.[a-zA-Z0-9\\-]+)*\\.[a-zA-Z0-9]&#123;2,6&#125;$&#x2F;;\n\n  return regx.test(email);\n&#125;\nisEmail(&quot;841660202@qq.com&quot;); &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 简写优化\n\nfunction isEmail2(email) &#123;\n  var regx &#x3D; &#x2F;^[\\w_.\\-]+@[\\w\\-]+(\\.[\\w\\-]+)*\\.[\\w]&#123;2,6&#125;$&#x2F;;\n\n  return regx.test(email);\n&#125;\nisEmail2(&quot;841660202@qq.com&quot;); &#x2F;&#x2F; true\n\n参考\n\\w 查找单词字符，等价于[a-zA-Z0-9]\n校验身份证&#x2F;&#x2F; 15位数字 或者是17+1位(数字，大小x)\nfunction isCard(number) &#123;\n  var regx &#x3D; &#x2F;(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)&#x2F;;\n\n  return regx.test(number);\n&#125;\n","slug":"2022-05-03string","date":"2022-05-04T00:00:00.000Z","categories_index":"前端基础","tags_index":"前端基础,面试","author_index":"举手摘月亮"},{"id":"be2d536c56c87a429a3dc062a6c5cd1f","title":"架构设计引发的血案","content":"记录个bug,并在此文中规避此处记下 hexo-theme-aurora 源码bug，有空时候帮他改\n.article .article-content p &#123;\n    font-size: .875rem;\n    line-height: 1.25rem;\n    margin-bottom: 0.5rem;\n    padding-bottom: 1rem;\n    word-break: break-all;\n&#125;\nbug复现\n(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)\n    at async Promise.all (index 3)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\n(Use &#96;node --trace-warnings ...&#96; to show where the warning was created)\n(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 19)\n(node:29) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\n(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)\n    at async Promise.all (index 3)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\n(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 44)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)\n    at async Promise.all (index 2)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)\n    at async Promise.all (index 3)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\nError: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)\n    at async Promise.all (index 2)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)\n\n\n源代码const [resp] &#x3D; await Promise.all([\n  getLoginInfo(ctx),\n  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),\n  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),\n  CommonModel.effects.getDataReport(req, ctx),\n])\n\nif (resp.success) &#123;\n  UserModal.actions.setUser(resp.result, req)\n&#125;\n增加异常捕获const [resp] &#x3D; await Promise.all([\n  getLoginInfo(ctx),\n  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),\n  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),\n  CommonModel.effects.getDataReport(req, ctx),\n]).catch(e&#x3D;&gt;&#123;\n  console.log(&quot;发生错误&quot;)\n  console.log(e)\n&#125;)\n日志日志仅 Forbidden 有效信息，大概是接口\n发生错误\nError: Forbidden\n    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:13144:29\n    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)\n    at async Promise.all (index 0)\n    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:12208:22)\n\n\n\n总结：\n因为acl 企业权限整了180天（顶配），时不时就出现系统瘫痪的情况，日常、线上都有此问题这架构设计的，估计没谁了。完全可以改成离职后，系统自动将用户禁权即可\n除此之外，sso也有个通病，三个月没改过密码，用户账户无法登录，需要重新密码方可登录\n\n","slug":"2022-04-29nextjs","date":"2022-04-29T02:56:00.000Z","categories_index":"bug","tags_index":"bug","author_index":"举手摘月亮"},{"id":"0539c4f1e60b889c5708d72373a67061","title":"企业微信： 图片附件无法预览的问题","content":"\n\n背景：安卓预览正常，部分iOS预览有问题（大部分手机都是正常的）downloadAttachment(downloadUrl).then(res &#x3D;&gt; &#123;\n      if (getWechatUserAgent(navigator.userAgent)) &#123; &#x2F;&#x2F; 判断是企业微信\n        const blob &#x3D; new Blob([res]);\n        wx.previewFile(&#123;\n          url: location.origin + downloadUrl, &#x2F;&#x2F; 需要预览文件的地址(必填，可以使用相对路径)\n          name: attachment.name, &#x2F;&#x2F; 需要预览文件的文件名，必须有带文件格式的后缀，例如.doc(不填的话取url的最后部分，最后部分是个包含格式后缀的文件名)\n          size: blob.size &#x2F;&#x2F; 需要预览文件的字节大小(必填，而且大小必须正确，否则会打开失败)\n        &#125;);\n        Toast.loading(i18n.loading, false)\n        return\n      &#125;\n      var reader &#x3D; new FileReader();\n      reader.readAsDataURL(res);   &#x2F;&#x2F; 转换为base64，可以直接放入a标签href\n      reader.onload &#x3D; function (e) &#123;\n        const anchorEle &#x3D; document.createElement(&#39;a&#39;)\n        document.body.appendChild(anchorEle)\n        anchorEle.href &#x3D; e?.target?.result as any\n        anchorEle.download &#x3D; attachment.name\n        anchorEle.click()\n        document.body.removeChild(anchorEle)\n      &#125;\n      Toast.loading(i18n.loading, false)\n    &#125;).catch(() &#x3D;&gt; &#123;\n      Toast.loading(i18n.loading, false)\n    &#125;)\n自研移动端、web端、企业微信桌面端都没问题，当然喽，每一个端展示效果是不一样的，代码也不一样。排查了耗费一定时间。\n\n\n排查 企业微信版本， 比对后发现，和正常使用的微信版本一致\n排查手机版本不一致，客户iphone12和 系统版本15.1，我们开发人员是14.+，所以我把我的手机升级到最新，我的手机升级后是正常的，那么可能是数据问题，数据\n排查数据，这是老系统的数据，和新系统数据走不同的业务代码，经排查也没问题\n排查size如果不准确也会出现上述问题，由于预发环境获取票据的信息与线上是不一致的，所以无法在预发进行排查，能做的事保证代码执行到 const blob = new Blob([res]);，并且能够获取到正确的size，所以进行了alert调试，这个在手机上比较直观，当然也可以vconsole【暂不考虑,因为之前开发人员没加，部门被砍掉，很多人被裁员了，所有项目都我来维护，没时间，不整了】，调试结果是size: 88214,各个手机都一样，用户手机也是88214，故排除size\n最后可能问题在于，用户手机上版本与手机不匹配，有兼容性bug，尝试升级企业微信，最后解决\n\n\n\n总结：如果考虑直接升级用户app版本，或许在第三步就解决问题了，我的iphoneX也不用升级到15.3了\n","slug":"2022-04-19wework-preview","date":"2022-04-19T13:30:47.000Z","categories_index":"企业微信","tags_index":"企业微信","author_index":"举手摘月亮"},{"id":"ea6c6af45eb8fb66a729fbe0ec8cd8f3","title":"Nestjs 结合 knife4j","content":"nest-knife4jknife4j githubknife4j 文档knife4j可以理解为一套swagger皮肤，不使用knife4j默认是swagger 1版本的样式\n","slug":"2022-02-29node","date":"2022-03-01T11:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"举手摘月亮"},{"id":"0523d16168244c5c50ce4e647b1f2e1c","title":"Nestjs文件上传","content":"文件上传Nestjs 上传文件Nestjs 上传文件\n","slug":"2022-02-28node","date":"2022-02-28T12:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"举手摘月亮"},{"id":"517bb0f5aa3a9a70442efc92a9ecc4e8","title":"React 拖拽兼容","content":"拖拽在web pc 端、iframe、h5移动端存在差异\nweb pc 端支持：onMouseDown、onMouseUp、onMousemove、onDragStart、onDragEnd、nDragOver\niframe web pc 端支持：onMouseDown、onMouseUp、onMousemove\nh5移动端支持：onTouchStart、onTouchEnd、onTouchmove\n\n代码export default function Draggable(props: Props) &#123;\n  const &#123; children, style, className, onDragFinish, onDraggingStart, onPositionGet, boundary &#x3D; &#123; x: MARGIN_TO_PAGE, y: MARGIN_TO_PAGE &#125; &#125; &#x3D; props\n  const [dragging, setDragging] &#x3D; useState(false)\n  const [attaching, setAttaching] &#x3D; useState(false)\n  const [top, setTop] &#x3D; useState(0)\n  const [left, setLeft] &#x3D; useState(0)\n  const ghostRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()\n  const elRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()\n\n  const onDragStart &#x3D; useCallback((e: DragEvent&lt;HTMLDivElement&gt; | TouchEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123;\n    let x\n    let y\n    if (isDrag(e)) &#123;\n      if (e.target !&#x3D;&#x3D; elRef.current) &#123;\n        return\n      &#125;\n      e.dataTransfer.setDragImage(emptyImg, 0, 0)\n      x &#x3D; e.clientX\n      y &#x3D; e.clientY\n    &#125; else &#123;\n      if (!e.target || !(e.target instanceof HTMLElement)) &#123;\n        return\n      &#125;\n      if (!parentHasClass(e.target, [rootStyles.feedbackRoot])) &#123;\n        return\n      &#125;\n      x &#x3D; e.touches[0].clientX\n      y &#x3D; e.touches[0].clientY\n    &#125;\n    e.stopPropagation()\n\n\n    const rect &#x3D; e.currentTarget.getBoundingClientRect()\n    const offsetX &#x3D; x - rect.x\n    const offsetY &#x3D; y - rect.y\n    setTop(rect.y)\n    setLeft(rect.x)\n    setDragging(true)\n\n    if (isDrag(e)) &#123;\n      dragoverHandle &#x3D; (event: DragEvent) &#x3D;&gt; &#123;\n        if (event.clientX || event.clientY) &#123;\n          setTop(event.clientY - offsetY)\n          setLeft(event.clientX - offsetX)\n        &#125;\n      &#125;\n      &#x2F;&#x2F; firefox 中，ondrag 拿不到鼠标的坐标，所以这里使用 document 的 dragover\n      document.addEventListener(&#39;dragover&#39;, dragoverHandle)\n    &#125; else &#123;\n      dragoverHandle &#x3D; (event: TouchEvent) &#x3D;&gt; &#123;\n        const touch &#x3D; event.touches[0]\n        if (touch.clientX || touch.clientY) &#123;\n          setTop(touch.clientY - offsetY)\n          setLeft(touch.clientX - offsetX)\n        &#125;\n      &#125;\n      document.addEventListener(&#39;touchmove&#39;, dragoverHandle)\n    &#125;\n    onDraggingStart()\n  &#125;, [])\n\n  const onDragEnd &#x3D; useCallback((event) &#x3D;&gt; &#123;\n    if (!ghostRef.current) &#123;\n      setDragging(false)\n      return\n    &#125;\n    const rect &#x3D; ghostRef.current.getBoundingClientRect()\n    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)\n\n    setTop(abs.top)\n    setLeft(abs.left)\n    setAttaching(true)\n\n    if (isDrag(event)) &#123;\n      document.removeEventListener(&#39;dragover&#39;, dragoverHandle)\n    &#125; else &#123;\n      document.removeEventListener(&#39;touchmove&#39;, dragoverHandle)\n    &#125;\n\n    &#x2F;&#x2F; onPosition &amp;&amp; onPosition(rel) &#x2F;&#x2F; 其他业务\n\n\n    dragoverHandle &#x3D; null\n\n    setTimeout(() &#x3D;&gt; &#123;\n      onDragFinish(rel)\n      setAttaching(false)\n      setDragging(false)\n    &#125;, 300)\n  &#125;, [])\n\n  const onMousedown &#x3D; useCallback((e) &#x3D;&gt; &#123;\n    const x &#x3D; e.clientX\n    const y &#x3D; e.clientY\n    const rect &#x3D; e.currentTarget.getBoundingClientRect()\n    const offsetX &#x3D; x - rect.x\n    const offsetY &#x3D; y - rect.y\n    setTop(rect.y)\n    setLeft(rect.x)\n    setDragging(true)\n    if (e.preventDefault) &#123;\n      e.preventDefault()\n    &#125; else &#123;\n      e.returnValue &#x3D; false\n    &#125;\n    document.onmousemove &#x3D; function (ev: any) &#123;\n      const _event &#x3D; ev || window.event\n      const endx &#x3D; _event.clientX - offsetX\n      const endy &#x3D; _event.clientY - offsetY\n      setTop(endy)\n      setLeft(endx)\n    &#125;\n  &#125;, [])\n\n  const onMouseup &#x3D; useCallback((e) &#x3D;&gt; &#123;\n    if (!ghostRef.current) &#123;\n      setDragging(false)\n      return\n    &#125;\n    const rect &#x3D; ghostRef.current.getBoundingClientRect()\n    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)\n\n    setTop(abs.top)\n    setLeft(abs.left)\n    setAttaching(true)\n\n    document.onmousemove &#x3D; null\n    onPositionGet &amp;&amp; onPositionGet(rel)\n    setTimeout(() &#x3D;&gt; &#123;\n      onDragFinish(rel)\n      setAttaching(false)\n      setDragging(false)\n    &#125;, 300)\n  &#125;, [])\n &#x2F;&#x2F; 能力检测\n  if (&#39;dragover&#39; in document.documentElement || &#39;ontouchstart&#39; in document.documentElement) &#123;\n    return (\n      &lt;div\n        style&#x3D;&#123;style&#125;\n        className&#x3D;&#123;className&#125;\n        draggable\n        onTouchStart&#x3D;&#123;onDragStart&#125;\n        onTouchEnd&#x3D;&#123;onDragEnd&#125;\n        onDragStart&#x3D;&#123;onDragStart&#125;\n        onDragEnd&#x3D;&#123;onDragEnd&#125;\n        onDragOver&#x3D;&#123;prevent&#125;\n        ref&#x3D;&#123;elRef&#125;\n      &gt;\n        &lt;div\n          style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;\n          className&#x3D;&#123;cn(&#123;\n            [styles.dragging]: dragging,\n            [styles.attaching]: attaching,\n          &#125;)&#125;\n          ref&#x3D;&#123;ghostRef&#125;\n        &gt;\n          &#123;children&#125;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n  return (\n    &lt;div\n      style&#x3D;&#123;style&#125;\n      className&#x3D;&#123;className&#125;\n      draggable\n      onMouseDown&#x3D;&#123;onMousedown&#125;\n      onMouseUp&#x3D;&#123;onMouseup&#125;\n      ref&#x3D;&#123;elRef&#125;\n    &gt;\n      &lt;div\n        style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;\n        className&#x3D;&#123;cn(&#123;\n          [styles.dragging]: dragging,\n          [styles.attaching]: attaching,\n        &#125;)&#125;\n        ref&#x3D;&#123;ghostRef&#125;\n      &gt;\n        &#123;children&#125;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;","slug":"2022-02-27react","date":"2022-02-27T13:30:47.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"4bcdaa6034eed07b809bf3bc6eec819f","title":"React DOM","content":"17.0.0 (October 20, 2020)\n\n\n\n\n\n\n\n\nDelegate events to roots instead of document来看下原因\n\n\n\n\n\n\n\n\n\nReact自首次发布以来一直在自动执行事件委派。它直接在文档节点上为每个事件类型附加一个处理程序。\n\n\n\n\n\n\n\n\n\n虽然它提高了应用程序的性能，但由于文档节点上的事件委派，已经报告了许多问题。\n\n\n\n\n\n\n\n\n\n为了演示其中一个问题，让我们以select下拉列表为例。下面示例中的CountryDropDown是用于国家选择的React组件，它将被呈现给id为React root的div。react DOM容器封装在id为main的div中，该div有一个包含stopPropagation（）的更改事件。\n&lt;!--Div&#39;s change event contains stopPropagation()--&gt;\n&lt;div id&#x3D;&quot;main&quot;&gt;\n  &lt;!--Div where react component will be rendered --&gt;\n  &lt;div id&#x3D;&quot;react-root&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\nclass CountryDropDown extends React.Component &#123;\n  state &#x3D; &#123;\n    country: &#39;&#39;,\n  &#125;\n  const handleChange &#x3D; e &#x3D;&gt; &#123;\n    this.setState(&#123; country: e.target.value &#125;);\n  &#125;\n  render() &#123;\n    return (\n      &lt;table class&#x3D;&quot;table table-striped table-condensed&quot;&gt;\n        &lt;thead&gt;\n          &lt;tr&gt;\n            &lt;th&gt;Country&lt;&#x2F;th&gt;\n            &lt;th&gt;Selected country&lt;&#x2F;th&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;thead&gt;\n        &lt;tbody&gt;\n          &lt;tr&gt;\n            &lt;td&gt;\n              &lt;select value&#x3D;&#123;this.state.country&#125;\n                onChange&#x3D;&#123;this.handleChange&#125;\n              &gt;\n                &lt;option value&#x3D;&quot;&quot;&gt;--Select--&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;India&quot;&gt;India&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;US&quot;&gt;US&lt;&#x2F;option&gt;\n                &lt;option value&#x3D;&quot;Dubai&quot;&gt;Dubai&lt;&#x2F;option&gt;\n              &lt;&#x2F;select&gt;\n            &lt;&#x2F;td&gt;\n            &lt;td&gt;\n              &#123;this.state.country&#125;\n            &lt;&#x2F;td&gt;\n          &lt;&#x2F;tr&gt;\n        &lt;&#x2F;tbody&gt;\n      &lt;&#x2F;table&gt;\n    );\n  &#125;\n&#125;\nReactDOM.render(&lt;CountryDropDown &#x2F;&gt;, document.getElementById(&#39;react-root&#39;));\n\n\n\n\n\n\n\n\n\n\n将更改事件附加到主div\ndocument.getElementById(&quot;main&quot;).addEventListener(\n  &quot;change&quot;,\n  function (e) &#123;\n    e.stopPropagation();\n  &#125;,\n  false\n);\n\n\n\n\n\n\n\n\n\n当选择一个国家时，我们无法看到所选的国家\n\n\n\n\n\n\n\n\n\n此意外行为的原因是附加到文档节点的onChange dropdown事件。包含e.stopPropagation（）的主div的change事件阻止了下拉菜单的onChange事件。\n\n\n\n\n\n\n\n\n\n为了解决此类问题，React 17不再在文档级别附加事件处理程序。相反，它将它们附加到根DOM容器中，React树将被渲染到该容器中。\n\n\n\n\n\n\n\n\n\n在React 17中进行更改后，事件被附加到根DOM容器，React树被呈现到该容器中。在我们的示例中，onChange事件的下拉列表将附加到id为react root的div。当选择任何国家&#x2F;地区呈现预期行为时，将触发此事件。\n","slug":"2022-05-04react","date":"2022-02-27T13:30:47.000Z","categories_index":"React","tags_index":"React","author_index":"举手摘月亮"},{"id":"0fe71bf4ca9007e9b607927107758aa8","title":"Sentry错误日志获取","content":"\n先上图\n\n\n\nThis is a quick getting started guide. For in-depth instructions on integrating Sentry with React, view our complete documentation.\nTo instrument your React application with Sentry, first install the @sentry/react and @sentry/tracing packages:\n# Using yarn\nyarn add @sentry&#x2F;react @sentry&#x2F;tracing\n\n# Using npm\nnpm install --save @sentry&#x2F;react @sentry&#x2F;tracing\n\nNext, import and initialize the Sentry module as early as possible, before initializing React:\nimport React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport * as Sentry from &quot;@sentry&#x2F;react&quot;;\nimport &#123; Integrations &#125; from &quot;@sentry&#x2F;tracing&quot;;\nimport App from &quot;.&#x2F;App&quot;;\n\nSentry.init(&#123;\n  dsn: &quot;https:&#x2F;&#x2F;a5f1c39789b24bb7a434868b677e0c65@&#x2F;1063&quot;,\n  integrations: [new Integrations.BrowserTracing()],\n\n  &#x2F;&#x2F; Set tracesSampleRate to 1.0 to capture 100%\n  &#x2F;&#x2F; of transactions for performance monitoring.\n  &#x2F;&#x2F; We recommend adjusting this value in production\n  tracesSampleRate: 1.0,\n&#125;);\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&quot;root&quot;));\n\n&#x2F;&#x2F; Can also use with React Concurrent Mode\n&#x2F;&#x2F; ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App &#x2F;&gt;);\n\nThe above configuration captures both error and performance data. To reduce the volume of performance data captured, change tracesSampleRate to a value between 0 and 1.\nAfter this step, Sentry will report any uncaught exceptions triggered by your application.\nYou can trigger your first event from your development environment by raising an exception somewhere within your application. An example of this would be rendering a button whose onClick handler attempts to invoke a method that does not exist:\nreturn &lt;button onClick&#x3D;&#123;methodDoesNotExist&#125;&gt;Break the world&lt;&#x2F;button&gt;;\n\nOnce you’ve verified the library is initialized properly and sent a test event, consider visiting our complete React docs. There you’ll find additional instructions for surfacing valuable context from React error boundaries, React Router, Redux, and more.\n","slug":"2021-06-20sentry","date":"2021-06-20T12:12:47.000Z","categories_index":"工具","tags_index":"Web","author_index":"举手摘月亮"},{"id":"40c248981d4dc9431fe8a0d461ef29a9","title":"CSS 自动生成 .d.ts","content":"CSS Module Typedvscode 插件列表中有好多个，不要安装错了\n\naddresslink\nInstallInstall deps first:\nrequirenpm install typed-css-modules\nif you need lessnpm install less\nif you need scss&#x2F;sassnpm install sass\nif you need stylusnpm install stylus\n\n\n\n\n\n\n\n\n\nModules can be installed globally. yarn is supported.\n\n\n\n\n\n\n\n\n\nTo switch the package manager (npm or yarn), you need to change the settings npm.packageManager of the built-in module vscode.npm.\nConfiguringBy default, the option to automatically format .d.ts files using eslint is enabled. You can disable this feature through the setting “typed-css-modules.eslint.enable”: false.\nUsageput\n// @type\nor\n/* @type */\nahead of your .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl file, and save, you will get a d.ts file in same directory.\npreview\ndemo&#x2F;* @type *&#x2F;\n\n.root &#123;\n  padding: 16px;\n  min-height: 100%;\n\n  .empty-wrapper &#123;\n    height: 380px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n  &#125;\n\n  &gt; h3 &#123;\n    font-size: inherit;\n    margin-bottom: 4px;\n  &#125;\n\n  .toolbar-wrapper &#123;\n    position: relative;\n\n    .toolbar &#123;\n      position: absolute;\n      margin: 12px 0;\n      z-index: 1;\n\n      &amp;.static &#123;\n        position: static;\n      &#125;\n\n      &gt; *:not(:first-child) &#123;\n        margin-left: 8px;\n      &#125;\n    &#125;\n  &#125;\n  .buttons &#123;\n    button &#123;\n      margin-right: 8px;\n    &#125;\n  &#125;\n&#125;\n.use-select &#123;\n  width: 300px;\n&#125;\n\ndeclare const styles: &#123;\n  readonly root: string;\n  readonly &quot;empty-wrapper&quot;: string;\n  readonly &quot;toolbar-wrapper&quot;: string;\n  readonly toolbar: string;\n  readonly static: string;\n  readonly buttons: string;\n  readonly &quot;use-select&quot;: string;\n&#125;;\nexport &#x3D; styles;\n\nproblem\n\n\n\n\n\n\n\n\nCreates .d.ts files from css-modules .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl files.\n\n\n\n\n\n\n\n\n\nError: vscode-typed-css-modules: Cannot find global module ‘typed-css-modules’\nnpm install -g typed-css-modules\n","slug":"2021-06-10scss2type","date":"2021-06-10T13:30:47.000Z","categories_index":"工具","tags_index":"工具,增效,vscode","author_index":"举手摘月亮"},{"id":"862ecabae65544f00e4a4f42f663a791","title":"Hexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"2021-03-20hexo","date":"2021-03-19T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"举手摘月亮"},{"id":"33a4c09d5b272c8b61a9dda679d7a5e9","title":"npm 包发布相关","content":"npm 包发布npm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; \nnpm notice name:          @tutu-fe&#x2F;wiki-ui                        \nnpm notice version:       0.1.1-beta                              \nnpm notice filename:      @tutu-fe&#x2F;wiki-ui-0.1.1-beta.tgz         \nnpm notice package size:  85.7 kB                                 \nnpm notice unpacked size: 449.9 kB                                \nnpm notice shasum:        973f5eb8d74de04c34b8e9c94536f8924b1f9570\nnpm notice integrity:     sha512-Uyo3zS0eaMOYE[...]60Ywmrmb&#x2F;brxQ&#x3D;&#x3D;\nnpm notice total files:   205                                     \nnpm notice \nnpm ERR! code E403\nnpm ERR! 403 403 Forbidden - PUT https:&#x2F;&#x2F;registry- - [maintainers_error] haotian.chen does not in maintainer list\nnpm ERR! 403 In most cases, you or one of your dependencies are requesting\nnpm ERR! 403 a package version that is forbidden by your security policy, or\nnpm ERR! 403 on a server you do not have access to.\n\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     &#x2F;Users&#x2F;haotian&#x2F;.npm&#x2F;_logs&#x2F;2022-04-28T09_58_10_365Z-debug.log\n\n\n配置package.json&quot;maintainers&quot;: [\n  &quot;davishua&quot;,å\n  &quot;haotian.chen&quot;\n],\n\n\n结果\n","slug":"2022-04-28npm","date":"2020-04-28T01:20:00.000Z","categories_index":"npm","tags_index":"npm","author_index":"举手摘月亮"},{"id":"8fa718ac5651ee524192868a31e6e820","title":"钉钉授权-单token刷新","content":"钉钉授权 钉钉小程序，单token防止进行token刷新\n&#x2F;&#x2F; 刷新token\nfunction refreshToken(corpId, cb) &#123;\n  dd.getAuthCode(&#123;\n    success: async (res) &#x3D;&gt; &#123;\n      const params &#x3D; &#123;\n        authCode: res.authCode,\n        corpId,\n      &#125;;\n      dd.stopPullDownRefresh();\n      const resAuth &#x3D; await authDing(params);\n      &#x2F;&#x2F; 只有授权成功情况下才可以\n      if (resAuth.code &#x3D;&#x3D;&#x3D; &quot;000000&quot;) &#123;\n        saveToken(resAuth.data.token);\n        setLastTokenTime(new Date().getTime().toString());\n        if (cb) &#123;\n          cb();\n        &#125;\n      &#125; else &#123;\n        showToastFail(JSON.stringify(resAuth));\n      &#125;\n    &#125;,\n    fail: (err) &#x3D;&gt; &#123;\n      showToastFail(JSON.stringify(err));\n    &#125;,\n  &#125;);\n&#125;\n&#x2F;**\n * 钉钉授权\n * corpId 企业钉钉组织id\n * callBack 授权成功后的回调\n * *&#x2F;\nexport function ddAuth(corpId, callBack) &#123;\n  const currentTime &#x3D; new Date().getTime();\n  const lastTokenTime &#x3D; getLastTokenTime() || 0;\n  &#x2F;&#x2F; 发布\n  if (config.release) &#123;\n    try &#123;\n      &#x2F;&#x2F; 大于23小时，重新授权\n      if (currentTime - +lastTokenTime &gt; 23 * 60 * 60 * 1000) &#123;\n        refreshToken(corpId, callBack);\n        console.log(&quot;重新授权&quot;);\n      &#125; else &#123;\n        &#x2F;&#x2F; 小于23小时，大于6小时，刷新\n        callBack();\n        &#x2F;&#x2F; 刷新token\n        if (currentTime - +lastTokenTime &gt; 6 * 60 * 60 * 1000) &#123;\n          refreshToken(corpId);\n        &#125;\n      &#125;\n    &#125; catch (error) &#123;\n      showToastFail(error);\n    &#125;\n    &#x2F;&#x2F; 开发调试\n  &#125; else &#123;\n    callBack();\n    &#x2F;&#x2F; showToastFail(&quot;开发登录超时，重新登录&quot;)\n  &#125;\n&#125;\n","slug":"2019-10-31dd-auth","date":"2019-10-31T12:49:53.000Z","categories_index":"钉钉小程序","tags_index":"钉钉小程序,token","author_index":"举手摘月亮"},{"id":"e8f86794a8b73abb4c26e162bb1c7550","title":"Git public key","content":"[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.name &quot;hailong.chen&quot;\n[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.email &quot;841660202@qq.com&quot;\n\n\n\n\n\n\n\n\n\n\nSSHSSH keysSSH key 可以让你在你的电脑和 Code 服务器之间建立安全的加密连接。 先执行以下语句来判断是否已经存在本地公钥：cat ~/.ssh/id_rsa.pub如果你看到一长串以  ssh-rsa 或  ssh-dsa 开头的字符串, 你可以跳过  ssh-keygen 的步骤。提示: 最好的情况是一个密码对应一个 ssh key，但是那不是必须的。你完全可以跳过创建密码这个步骤。请记住设置的密码并不能被修改或获取。你可以按如下命令来生成 ssh keyssh-keygen -t rsa -C &quot;841660202@qq.com&quot;这个指令会要求你提供一个位置和文件名去存放键值对和密码，你可以点击 Enter 键去使用默认值。用以下命令获取你生成的公钥：cat ~/.ssh/id_rsa.pub复制这个公钥放到你的个人设置中的 SSH&#x2F;My SSH Keys 下，请完整拷贝从 ssh-开始直到你的用户名和主机名为止的内容。如果打算拷贝你的公钥到你的粘贴板下，请参考你的操作系统使用以下的命令：Windows:clip &lt; ~/.ssh/id_rsa.pubMac:pbcopy &lt; ~/.ssh/id_rsa.pubGNU&#x2F;Linux (requires xclip):xclip -sel clip &lt; ~/.ssh/id_rsa.pubApplicationsEclipse如何在 Eclipse 中添加 ssh key: https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_ConfigurationTip: Non-default OpenSSH key file names or locations如果，不管你有什么理由，当你决定去用一个非默认的位置或文件名去存放你的 ssh key。你必须配置好你的 ssh 客户端以找到你的 ssh 私钥去连接 Code 服务器，对于 OpenSSH 客户端，这个通常是在~&#x2F;.ssh&#x2F;config 类似的位置配置的：Host my-git.company.comRSAAuthentication yesIdentityFile ~&#x2F;my-ssh-key-directory&#x2F;company-com-private-key-filename\nLast login: Sun Apr 17 16:06:15 on console\nN&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.\n\nYou need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.\nN&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.\n\nYou need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.\n\nThe default interactive shell is now zsh.\nTo update your account to use zsh, please run &#96;chsh -s &#x2F;bin&#x2F;zsh&#96;.\nFor more details, please visit https:&#x2F;&#x2F;support.apple.com&#x2F;kb&#x2F;HT208050.\nchenhailong@chenhailongdeMacBook-Pro:~$ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop\n-bash: &#x2F;Users&#x2F;chenhailong&#x2F;Desktop: is a directory\nchenhailong@chenhailongdeMacBook-Pro:~$ cd &#x2F;Users&#x2F;chenhailong&#x2F;Desktop\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.git\nCloning into &#39;841660202.github.io&#39;...\nThe authenticity of host &#39;github.com (20.205.243.166)&#39; can&#39;t be established.\nED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF&#x2F;zLDA0zPMSvHdkr4UvCOqU.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes\nWarning: Permanently added &#39;github.com&#39; (ED25519) to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.git\nCloning into &#39;841660202.github.io&#39;...\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub\n-bash: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub\ncat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.name &quot;hailong.chen&quot;\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.email &quot;841660202@qq.com&quot;\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub\ncat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ ssh-keygen -t rsa -C &quot;841660202@qq.com&quot;\nGenerating public&#x2F;private rsa key pair.\nEnter file in which to save the key (&#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa\nYour public key has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub\nThe key fingerprint is:\nSHA256:bdtIDeRXGKxGTEa&#x2F;Ex3QdPtVoOUiwuiq7YKjKrLakbU 841660202@qq.com\nThe key&#39;s randomart image is:\n+---[RSA 3072]----+\n|         +&#x3D;.o**.o|\n|       o +o.o*.oo|\n|      . o.+.* o..|\n|     .   oo&#x3D; +  o|\n|    . . S.+ +   .|\n|   o o   o + .   |\n| .o E     o .    |\n|&#x3D;..+             |\n|@oooo            |\n+----[SHA256]-----+\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.git\nCloning into &#39;841660202.github.io&#39;...\nremote: Enumerating objects: 441, done.\nremote: Counting objects: 100% (441&#x2F;441), done.\nremote: Compressing objects: 100% (216&#x2F;216), done.\nremote: Total 441 (delta 208), reused 401 (delta 168), pack-reused 0\nReceiving objects: 100% (441&#x2F;441), 1.34 MiB | 1.05 MiB&#x2F;s, done.\nResolving deltas: 100% (208&#x2F;208), done.\nchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$\n\n\n\n设置 github SSH keyshttps://github.com/settings/keys\n问题及解决图 1\n\n\n图 2\n\n\n\ngit config --global user.email &lt;&gt;\n删除重新配置 如图2\n清理 git 缓存git clean -f\n重新提交\n\n","slug":"2016-06-20git","date":"2019-10-30T13:30:47.000Z","categories_index":"git","tags_index":"git","author_index":"举手摘月亮"},{"id":"2f05eb6cd7f25d74fcf01b828267389c","title":"MAC Iterm2美化终端","content":"MAC 环境注意：以下内容仅限 MAC,其他环境，请自行谷歌\noh-my-zsh 插件推荐 :\nautojump 这个没用起来，使用没什么效果 🥹\nzsh-autosuggestion 命令行输入有提示，（命令下载失败，手动下载，拷贝到 ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions）\nzsh-syntax-highlighting\n\n安装 zsh1.使用 brew 安装\nbrew install oh-my-zsh\n\n2. 手动安装\ngit clone git:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh.git ~&#x2F;.oh-my-zsh\n\ncp ~&#x2F;.oh-my-zsh&#x2F;templates&#x2F;zshrc.zsh-template ~&#x2F;.zshrc\n\n\n安装 autojump1.安装\nbrew install autojump\n\n2.配置code ~/.zshrc，把以下代码加到尾部\n# 使用brew安装的\n\n[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh\nsource $ZSH&#x2F;oh-my-zsh.sh\n\n# 使用git安装的\n\n[[ -s ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh\n\n3.刷新配置\nsource ~&#x2F;.zshrc\n\n安装 zsh-autosuggestiongit clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestions\n\n安装 zsh-syntax-highlightinggit clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting\n\n\n刷新配置最后用 source ~/.zshrc 命令更新配置文件\n.zshrc 配置如下：\n自己电脑配置，下面截图是办公电脑截图\n\n# If you come from bash you might have to change your $PATH.\n# export PATH&#x3D;$HOME&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:$PATH\n\n# Path to your oh-my-zsh installation.\nexport ZSH&#x3D;&quot;$HOME&#x2F;.oh-my-zsh&quot;\n\n# Set name of the theme to load --- if set to &quot;random&quot;, it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;Themes\nZSH_THEME&#x3D;&quot;robbyrussell&quot;\n\n# Set list of themes to pick from when loading at random\n# Setting this variable when ZSH_THEME&#x3D;random will cause zsh to load\n# a theme from this variable instead of looking in $ZSH&#x2F;themes&#x2F;\n# If set to an empty array, this variable will have no effect.\n# ZSH_THEME_RANDOM_CANDIDATES&#x3D;( &quot;robbyrussell&quot; &quot;agnoster&quot; )\n\n# Uncomment the following line to use case-sensitive completion.\n# CASE_SENSITIVE&#x3D;&quot;true&quot;\n\n# Uncomment the following line to use hyphen-insensitive completion.\n# Case-sensitive completion must be off. _ and - will be interchangeable.\n# HYPHEN_INSENSITIVE&#x3D;&quot;true&quot;\n\n# Uncomment one of the following lines to change the auto-update behavior\n# zstyle &#39;:omz:update&#39; mode disabled  # disable automatic updates\n# zstyle &#39;:omz:update&#39; mode auto      # update automatically without asking\n# zstyle &#39;:omz:update&#39; mode reminder  # just remind me to update when it&#39;s time\n\n# Uncomment the following line to change how often to auto-update (in days).\n# zstyle &#39;:omz:update&#39; frequency 13\n\n# Uncomment the following line if pasting URLs and other text is messed up.\n# DISABLE_MAGIC_FUNCTIONS&#x3D;&quot;true&quot;\n\n# Uncomment the following line to disable colors in ls.\n# DISABLE_LS_COLORS&#x3D;&quot;true&quot;\n\n# Uncomment the following line to disable auto-setting terminal title.\n# DISABLE_AUTO_TITLE&#x3D;&quot;true&quot;\n\n# Uncomment the following line to enable command auto-correction.\n# ENABLE_CORRECTION&#x3D;&quot;true&quot;\n\n# Uncomment the following line to display red dots whilst waiting for completion.\n# You can also set it to another string to have that shown instead of the default red dots.\n# e.g. COMPLETION_WAITING_DOTS&#x3D;&quot;%F&#123;yellow&#125;waiting...%f&quot;\n# Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)\n# COMPLETION_WAITING_DOTS&#x3D;&quot;true&quot;\n\n# Uncomment the following line if you want to disable marking untracked files\n# under VCS as dirty. This makes repository status check for large repositories\n# much, much faster.\n# DISABLE_UNTRACKED_FILES_DIRTY&#x3D;&quot;true&quot;\n\n# Uncomment the following line if you want to change the command execution time\n# stamp shown in the history command output.\n# You can set one of the optional three formats:\n# &quot;mm&#x2F;dd&#x2F;yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;\n# or set a custom format using the strftime function format specifications,\n# see &#39;man strftime&#39; for details.\n# HIST_STAMPS&#x3D;&quot;mm&#x2F;dd&#x2F;yyyy&quot;\n\n# Would you like to use another custom folder than $ZSH&#x2F;custom?\n# ZSH_CUSTOM&#x3D;&#x2F;path&#x2F;to&#x2F;new-custom-folder\n\n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH&#x2F;plugins&#x2F;\n# Custom plugins may be added to $ZSH_CUSTOM&#x2F;plugins&#x2F;\n# Example format: plugins&#x3D;(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\n# 插件信息\nplugins&#x3D;(\n  git\n  zsh-syntax-highlighting\n  zsh-autosuggestions\n  autojump\n)\n\nsource $ZSH&#x2F;oh-my-zsh.sh\n\n[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh\nsource $ZSH&#x2F;oh-my-zsh.sh\n\n# User configuration\nPROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d $ &quot;\n# PROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[magenta]%&#125;$ &quot;\nPROMPT+&#x3D;&#39;%&#123;$reset_color%&#125;&#39;\n\nZSH_THEME_GIT_PROMPT_PREFIX&#x3D;&quot;%&#123;$fg_bold[blue]%&#125;&quot;\nZSH_THEME_GIT_PROMPT_SUFFIX&#x3D;&quot;%&#123;$reset_color%&#125; &quot;\nZSH_THEME_GIT_PROMPT_DIRTY&#x3D;&quot;%&#123;$fg[blue]%&#125;) %&#123;$fg[yellow]%&#125;✗&quot;\nZSH_THEME_GIT_PROMPT_CLEAN&#x3D;&quot;%&#123;$fg[blue]%&#125;)&quot;\n\n# 参考 https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b84d8b7b134e\n\n# code\tvalue\n# %T\t系统时间（时：分）\n# %*\t系统时间（时：分：秒）\n# %D\t系统日期（年-月-日）\n# %n\t用户名\n# %B - %b\t开始到结束使用粗体打印\n# %U - %u\t开始到结束使用下划线打印\n# %c\t仅当前文件夹路径\n# %d\t当前目录路径完整\n# %~\t当前目录相对于～的相对路径\n# %M\t计算机的主机名\n# %m\t计算机的主机名（在第一个句号之前截断\n# %l\t当前的tty\n\n\n\n# export MANPATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;man:$MANPATH&quot;\n\n# You may need to manually set your language environment\n# export LANG&#x3D;en_US.UTF-8\n\n# Preferred editor for local and remote sessions\n# if [[ -n $SSH_CONNECTION ]]; then\n#   export EDITOR&#x3D;&#39;vim&#39;\n# else\n#   export EDITOR&#x3D;&#39;mvim&#39;\n# fi\n\n# Compilation flags\n# export ARCHFLAGS&#x3D;&quot;-arch x86_64&quot;\n\n# Set personal aliases, overriding those provided by oh-my-zsh libs,\n# plugins, and themes. Aliases can be placed here, though oh-my-zsh\n# users are encouraged to define aliases within the ZSH_CUSTOM folder.\n# For a full list of active aliases, run &#96;alias&#96;.\n#\n# Example aliases\n# alias zshconfig&#x3D;&quot;mate ~&#x2F;.zshrc&quot;\n# alias ohmyzsh&#x3D;&quot;mate ~&#x2F;.oh-my-zsh&quot;\n\n\n问题\n\n根目录执行完,只能规避提示，不能解决问题\ncompaudit | xargs chmod g-w,o-w\n\n\n\n重新安装 zsh 解决问题fixed： 重新安装 zsh\nbrew install zsh\n\n\n\n使用效果\ncode 对应码见\n","slug":"2017-07-09item2","date":"2019-10-30T13:30:47.000Z","categories_index":"工具","tags_index":"工具,增效","author_index":"举手摘月亮"},{"id":"9898e57ef559824ae32861e6fc17d4db","title":"Layoffs","content":"一家上市公司近期「B业」人数变化\n","slug":"2022-03-25Layoffs","date":"2019-10-30T13:30:47.000Z","categories_index":"其他","tags_index":"Layoffs","author_index":"举手摘月亮"},{"id":"fa6ca4165b8b582ff1a69b1ccf9de547","title":"Nestjs服务端技术栈","content":"NestJS中文文档NestJS中文文档NestJS中文文档github 42.2K\n\n\n\n\n\n\n\n\n\nA progressive Node.js framework for building efficient, scalable, and enterprise-grade server-side applications on top of TypeScript &amp; JavaScript (ES6, ES7, ES8) 🚀\nTypeORMTypeORM中文文档github地址 26.3K\n\n\n\n\n\n\n\n\n\nORM for TypeScript and JavaScript (ES7, ES6, ES5). Supports MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, SAP Hana, WebSQL databases. Works in NodeJS, Browser, Ionic, Cordova and Electron platforms.\n","slug":"2021-06-30node","date":"2015-11-12T02:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"举手摘月亮"},{"id":"6f9f700e5a026be1d86747100cd27059","title":"Web office预览","content":"第一步将文件上传到你的服务器里，并支持url下载这个文件。第二步访问：http://view.officeapps.live.com/op/view.aspx?src=要预览文件的url地址（记得url编码哦）第三步可以使用iframe嵌入你的系统更多详情查看：https://www.microsoft.com/en-us/microsoft-365/blog/2013/04/10/office-web-viewer-view-office-documents-in-a-browser/?eu=true\n","slug":"2021-09-07web","date":"2015-11-12T02:55:47.000Z","categories_index":"工具","tags_index":"Web","author_index":"举手摘月亮"},{"id":"038636b617c3d3d43c65b95b558e1735","title":"node-dev","content":"在幕后用ts-node调整node-dev\n作用：在幕后用ts-node调整node-dev\n优点：\n任意依赖的文件改变时候，重启node process，但是共享ts编译线程。\n因为不需要每次ts-node编译的实例化，而提升性能\n\n\n配置项：\n注意事项：\n截图：\n\n","slug":"2021-11-02node","date":"2015-11-12T02:55:47.000Z","categories_index":"Node","tags_index":"Node","author_index":"举手摘月亮"},{"id":"c15b0fd9b66d6749d042b7d88c5bcd12","title":"简书迁移到OSS","content":"命令cat .&#x2F;* |grep uploadimages.jianshu.io &gt; image.txt\nmkdir img3d\ncd img3d\nwget -i ..&#x2F;image.txt\nsed -i&#39;&#39; -e &#39;s&#x2F;!\\[image.png\\](&#x2F;&#x2F;g&#39; image.txt\nsed -i&#39;&#39; -e &#39;s&#x2F;)&#x2F;&#x2F;g&#39; image.txt\n迁移简书图片下载后重命名#! &#x2F;bin&#x2F;sh\n\nfor eachfile in &#96;ls -B&#96;\ndo  \n  # echo $&#123;eachfile%%\\%3F*&#125; # 截掉最后.txt    # $ % https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b3bdc3b3968e\n  filename&#x3D;$&#123;eachfile%%\\%3F*&#125;\n  filehead&#x3D;&#96;echo $eachfile | awk -F \\%3F &#39;&#123;print $1 &#125;&#39;&#96;\n  filelast&#x3D;&#96;echo $eachfile | awk -F \\%3F &#39;&#123;print $2 &#125;&#39;&#96;\n  # mv $filename.txt $&#123;filelast&#125;_$filehead.txt\n  # https:&#x2F;&#x2F;baijiahao.baidu.com&#x2F;s?id&#x3D;1726788915185806701&amp;wfr&#x3D;spider&amp;for&#x3D;pc\n  echo &#39;--&#39;\n  # echo $filename\n  echo $filehead #分割字符左边部分\n  echo $filelast #分割字符右边部分\n  # 右边文件存在的情况下才处理\n  if [ &quot;$filelast&quot; !&#x3D; &quot;&quot; ]\n  then\n    echo &#39;执行rename &#39;\n    mv $eachfile $filehead\n  fi\n\ndone\n","slug":"2022-04-27mv-blog-jianshu","date":"2015-11-12T02:55:47.000Z","categories_index":"工具","tags_index":"Shell","author_index":"举手摘月亮"}]