{"title":"","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"1. compose题目描述:实现一个 compose 函数 &#x2F;&#x2F; 用法如下: function fn1(x) &#123; return x + 1; &#125; function fn2(x) &#123; return x + 2; &#125; fu...","date":"2022-09-16T13:54:56.369Z","updated":"2022-09-16T13:54:56.369Z","comments":true,"path":"api/pages/test/code.json","covers":null,"excerpt":"","content":"<h2 id=\"1-compose\"><a href=\"#1-compose\" class=\"headerlink\" title=\"1. compose\"></a>1. compose</h2><p>题目描述:实现一个 compose 函数</p>\n<p>&#x2F;&#x2F; 用法如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function fn1(x) &#123;\n  return x + 1;\n&#125;\nfunction fn2(x) &#123;\n  return x + 2;\n&#125;\nfunction fn3(x) &#123;\n  return x + 3;\n&#125;\nfunction fn4(x) &#123;\n  return x + 4;\n&#125;\nconst a &#x3D; compose(fn1, fn2, fn3, fn4);\nconsole.log(a(1)); &#x2F;&#x2F; 1+4+3+2+1&#x3D;11</code></pre>\n\n<p>答案：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function compose(...fn) &#123;\n  if (!fn.length) return (v) &#x3D;&gt; v;\n  if (fn.length &#x3D;&#x3D;&#x3D; 1) return fn[0];\n  return fn.reduce(\n    (pre, cur) &#x3D;&gt;\n      (...args) &#x3D;&gt;\n        pre(cur(...args))\n  );\n&#125;</code></pre>\n\n<h2 id=\"2-1-settimeout-模拟实现-setinterval-带清除定时器的版本\"><a href=\"#2-1-settimeout-模拟实现-setinterval-带清除定时器的版本\" class=\"headerlink\" title=\"2.1 settimeout 模拟实现 setinterval(带清除定时器的版本)\"></a>2.1 settimeout 模拟实现 setinterval(带清除定时器的版本)</h2><p>题目描述:setinterval 用来实现循环定时调用 可能会存在一定的问题 能用 settimeout 解决吗</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function mySettimeout(fn, t) &#123;\n  let timer &#x3D; null;\n\n  function interval() &#123;\n    fn();\n    timer &#x3D; setTimeout(interval &#x2F;**间隔时间调用自己 *&#x2F;, t);\n  &#125;\n  interval();\n  return &#123;\n    cancel: () &#x3D;&gt; &#123;\n      clearTimeout(timer);\n    &#125;,\n  &#125;;\n&#125;\n&#x2F;&#x2F; let a&#x3D;mySettimeout(()&#x3D;&gt;&#123;\n&#x2F;&#x2F;   console.log(111);\n&#x2F;&#x2F; &#125;,1000)\n&#x2F;&#x2F; let b&#x3D;mySettimeout(() &#x3D;&gt; &#123;\n&#x2F;&#x2F;   console.log(222)\n&#x2F;&#x2F; &#125;, 1000)</code></pre>\n\n<h2 id=\"2-2-setinterval-模拟实现-settimeout-吗？\"><a href=\"#2-2-setinterval-模拟实现-settimeout-吗？\" class=\"headerlink\" title=\"2.2 setinterval 模拟实现 settimeout 吗？\"></a>2.2 setinterval 模拟实现 settimeout 吗？</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const mySetTimeout &#x3D; (fn, time) &#x3D;&gt; &#123;\n  const timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n    clearInterval(timer); &#x2F;&#x2F; 执行完清理\n    fn();\n  &#125;, time);\n&#125;;\n&#x2F;&#x2F; mySetTimeout(()&#x3D;&gt;&#123;\n&#x2F;&#x2F;   console.log(1);\n&#x2F;&#x2F; &#125;,1000)</code></pre>\n\n<h2 id=\"3-发布订阅模式\"><a href=\"#3-发布订阅模式\" class=\"headerlink\" title=\"3 发布订阅模式\"></a>3 发布订阅模式</h2><p>题目描述:实现一个发布订阅模式拥有 on emit once off 方法</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class EventEmitter &#123;\n  constructor() &#123;\n    this.events &#x3D; &#123;&#125;;\n  &#125;\n  &#x2F;&#x2F; 实现订阅\n  on(type, callBack) &#123;\n    if (!this.events[type]) &#123;\n      this.events[type] &#x3D; [callBack];\n    &#125; else &#123;\n      this.events[type].push(callBack);\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 删除订阅\n  off(type, callBack) &#123;\n    if (!this.events[type]) return;\n    this.events[type] &#x3D; this.events[type].filter((item) &#x3D;&gt; &#123;\n      return item !&#x3D;&#x3D; callBack;\n    &#125;);\n  &#125;\n  &#x2F;&#x2F; 只执行一次订阅事件\n  once(type, callBack) &#123;\n    function fn() &#123;\n      callBack();\n      this.off(type, fn);\n    &#125;\n    this.on(type, fn);\n  &#125;\n  &#x2F;&#x2F; 触发事件\n  emit(type, ...rest) &#123;\n    this.events[type] &amp;&amp;\n      this.events[type].forEach((fn) &#x3D;&gt; fn.apply(this, rest));\n  &#125;\n&#125;\n&#x2F;&#x2F; 使用如下\n&#x2F;&#x2F; const event &#x3D; new EventEmitter();\n\n&#x2F;&#x2F; const handle &#x3D; (...rest) &#x3D;&gt; &#123;\n&#x2F;&#x2F;   console.log(rest);\n&#x2F;&#x2F; &#125;;\n\n&#x2F;&#x2F; event.on(&quot;click&quot;, handle);\n\n&#x2F;&#x2F; event.emit(&quot;click&quot;, 1, 2, 3, 4);\n\n&#x2F;&#x2F; event.off(&quot;click&quot;, handle);\n\n&#x2F;&#x2F; event.emit(&quot;click&quot;, 1, 2);\n\n&#x2F;&#x2F; event.once(&quot;dbClick&quot;, () &#x3D;&gt; &#123;\n&#x2F;&#x2F;   console.log(123456);\n&#x2F;&#x2F; &#125;);\n&#x2F;&#x2F; event.emit(&quot;dbClick&quot;);\n&#x2F;&#x2F; event.emit(&quot;dbClick&quot;);</code></pre>\n\n<h2 id=\"4-数组去重\"><a href=\"#4-数组去重\" class=\"headerlink\" title=\"4 数组去重\"></a>4 数组去重</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function uniqueArr(arr) &#123;\n  return [...new Set(arr)];\n&#125;</code></pre>\n\n<h2 id=\"5-数组扁平化\"><a href=\"#5-数组扁平化\" class=\"headerlink\" title=\"5 数组扁平化\"></a>5 数组扁平化</h2><p>题目描述:实现一个方法使多维数组变成一维数组</p>\n<p>最常见的递归版本如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function flatter(arr) &#123;\n  if (!arr.length) return;\n  return arr.reduce(\n    (pre, cur) &#x3D;&gt;\n      Array.isArray(cur) ? [...pre, ...flatter(cur)] : [...pre, cur],\n    []\n  );\n&#125;\n&#x2F;&#x2F; console.log(flatter([1, 2, [1, [2, 3, [4, 5, [6]]]]]));</code></pre>\n\n<p>扩展思考：能用迭代的思路去实现吗?</p>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function flatter(arr) &#123;\n  if (!arr.length) return;\n  while (arr.some((item) &#x3D;&gt; Array.isArray(item))) &#123;\n    &#x2F;&#x2F; 子项有数组，则展开\n    arr &#x3D; [].concat(...arr);\n  &#125;\n  return arr;\n&#125;\n&#x2F;&#x2F; console.log(flatter([1, 2, [1, [2, 3, [4, 5, [6]]]]]));</code></pre>\n\n<h2 id=\"6-寄生组合继承-不懂\"><a href=\"#6-寄生组合继承-不懂\" class=\"headerlink\" title=\"6 寄生组合继承 [不懂]\"></a>6 寄生组合继承 [不懂]</h2><p>题目描述:实现一个你认为不错的 js 继承方式</p>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Parent(name) &#123;\n  this.name &#x3D; name;\n  this.say &#x3D; () &#x3D;&gt; &#123;\n    console.log(111);\n  &#125;;\n&#125;\nParent.prototype.play &#x3D; () &#x3D;&gt; &#123;\n  console.log(222);\n&#125;;\nfunction Children(name) &#123;\n  Parent.call(this);\n  this.name &#x3D; name;\n&#125;\n\nChildren.prototype &#x3D; Object.create(Parent.prototype);\nChildren.prototype.constructor &#x3D; Children;\n&#x2F;&#x2F; let child &#x3D; new Children(&quot;111&quot;);\n&#x2F;&#x2F; &#x2F;&#x2F; console.log(child.name);\n&#x2F;&#x2F; &#x2F;&#x2F; child.say();\n&#x2F;&#x2F; &#x2F;&#x2F; child.play();</code></pre>\n\n<h2 id=\"7-实现有并行限制的-Promise-调度器\"><a href=\"#7-实现有并行限制的-Promise-调度器\" class=\"headerlink\" title=\"7 实现有并行限制的 Promise 调度器\"></a>7 实现有并行限制的 Promise 调度器</h2><p>题目描述:JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"> addTask(1000,&quot;1&quot;);\n addTask(500,&quot;2&quot;);\n addTask(300,&quot;3&quot;);\n addTask(400,&quot;4&quot;);\n 的输出顺序是：2 3 1 4\n\n 整个的完整执行流程：\n\n一开始1、2两个任务开始执行\n500ms时，2任务执行完毕，输出2，任务3开始执行\n800ms时，3任务执行完毕，输出3，任务4开始执行\n1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行\n1200ms时，4任务执行完毕，输出4\n</code></pre>\n\n<p>实现代码如下:</p>\n<ul>\n<li>任务生成器： 放任务到任务队列中</li>\n<li>启动任务：最大执行次数</li>\n<li>执行循环：任务出队列执行，执行完成后调用自身，直至任务结束</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Scheduler &#123;\n  constructor(limit) &#123;\n    this.queue &#x3D; []; &#x2F;&#x2F; 任务队列\n    this.maxCount &#x3D; limit; &#x2F;&#x2F; 最大并发数\n    this.runCounts &#x3D; 0; &#x2F;&#x2F; 运行数量\n  &#125;\n\n  add(time, order) &#123;\n    &#x2F;&#x2F; promise 生成器\n    const promiseCreator &#x3D; () &#x3D;&gt; &#123;\n      return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n          console.log(order);\n          resolve();\n        &#125;, time);\n      &#125;);\n    &#125;;\n\n    this.queue.push(promiseCreator &#x2F;**放置的是 promiseCreator 函数 *&#x2F;);\n  &#125;\n\n  &#x2F;&#x2F; 启动任务\n  taskStart() &#123;\n    for (let i &#x3D; 0; i &lt; this.maxCount; i++) &#123;\n      this.request();\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 任务循环结束\n  request() &#123;\n    &#x2F;&#x2F; 执行完停止\n    if (!this.queue || !this.queue.length || this.runCounts &gt;&#x3D; this.maxCount) &#123;\n      return;\n    &#125;\n    &#x2F;&#x2F; 执行的数量+1\n    this.runCounts++;\n\n    &#x2F;&#x2F; 执行之后的任务\n    this.queue\n      .shift()() &#x2F;**取出来执行 *&#x2F;\n      .then(() &#x3D;&gt; &#123;\n        this.runCounts--; &#x2F;&#x2F; 运行数量减少\n        this.request(); &#x2F;&#x2F; 循环调用，直到runCounts饱和或者this.queue被清空\n      &#125;);\n  &#125;\n&#125;\n\nconst scheduler &#x3D; new Scheduler(2);\n\n&#x2F;&#x2F; 给schedule增加一些任务\nconst addTask &#x3D; (time, order) &#x3D;&gt; &#123;\n  scheduler.add(time, order);\n&#125;;\n\naddTask(1000, &quot;1&quot;);\naddTask(500, &quot;2&quot;);\naddTask(300, &quot;3&quot;);\naddTask(400, &quot;4&quot;);\n\n&#x2F;&#x2F; 开始执行任务\nscheduler.taskStart();</code></pre>\n\n<h2 id=\"8-new-操作符\"><a href=\"#8-new-操作符\" class=\"headerlink\" title=\"8 new 操作符\"></a>8 new 操作符</h2><p>题目描述:手写 new 操作符实现<br>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 它创建了⼀个全新的对象\n&#x2F;&#x2F; 它会被执⾏[[Prototype]]（也就是proto）链接\n&#x2F;&#x2F; 它使this指向新创建的对象\n&#x2F;&#x2F; 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上\n&#x2F;&#x2F; 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调⽤将返 回该对象引⽤\n&#x2F;&#x2F; function myNew() &#123;\n&#x2F;&#x2F;   let obj &#x3D; &#123;&#125;\n\n&#x2F;&#x2F;   let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数\n\n&#x2F;&#x2F;   obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型\n\n&#x2F;&#x2F;   func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数\n\n&#x2F;&#x2F;   return obj;\n&#x2F;&#x2F; &#125;\n\nfunction myNew(fn, ...args) &#123;\n  let obj &#x3D; Object.create(fn.prototype);\n\n  let res &#x3D; fn.call(obj, ...args);\n\n  if (res &amp;&amp; (typeof res &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof res &#x3D;&#x3D;&#x3D; &quot;function&quot;)) &#123;\n    return res;\n  &#125;\n  return obj;\n&#125;\n\n&#x2F;&#x2F; 用法如下：\n&#x2F;&#x2F; function Person(name, age) &#123;\n&#x2F;&#x2F;   this.name &#x3D; name;\n&#x2F;&#x2F;   this.age &#x3D; age;\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; Person.prototype.say &#x3D; function() &#123;\n&#x2F;&#x2F;   console.log(this.age);\n&#x2F;&#x2F; &#125;;\n&#x2F;&#x2F; let p1 &#x3D; myNew(Person, &quot;lihua&quot;, 18);\n&#x2F;&#x2F; console.log(p1.name);\n&#x2F;&#x2F; console.log(p1);\n&#x2F;&#x2F; p1.say();</code></pre>\n\n<h2 id=\"9-call-apply-bind\"><a href=\"#9-call-apply-bind\" class=\"headerlink\" title=\"9 call apply bind\"></a>9 call apply bind</h2><p>题目描述:手写 call apply bind 实现</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;  Product.call(this, name, price);\nFunction.prototype.myCall &#x3D; function (context, ...args) &#123;\n  if (!context || context &#x3D;&#x3D;&#x3D; null) &#123;\n    context &#x3D; window;\n  &#125;\n  &#x2F;&#x2F; 创造唯一的key值  作为我们构造的context内部方法名\n  let fn &#x3D; Symbol();\n  context[fn] &#x3D; this; &#x2F;&#x2F;this指向调用call的函数\n  &#x2F;&#x2F; 执行函数并返回结果 相当于把自身作为传入的context的方法进行调用了\n  return context[fn](...args);\n&#125;;</code></pre>\n\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; apply原理一致  只是第二个参数是传入的数组\nFunction.prototype.myApply &#x3D; function (context, args) &#123;\n  if (!context || context &#x3D;&#x3D;&#x3D; null) &#123;\n    context &#x3D; window;\n  &#125;\n  &#x2F;&#x2F; 创造唯一的key值  作为我们构造的context内部方法名\n  let fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  &#x2F;&#x2F; 执行函数并返回结果\n  return context[fn](...args);\n&#125;;</code></pre>\n\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;bind实现要复杂一点  因为他考虑的情况比较多 还要涉及到参数合并(类似函数柯里化)\n\nFunction.prototype.myBind &#x3D; function (context, ...args) &#123;\n  if (!context || context &#x3D;&#x3D;&#x3D; null) &#123;\n    context &#x3D; window;\n  &#125;\n  &#x2F;&#x2F; 创造唯一的key值  作为我们构造的context内部方法名\n  let fn &#x3D; Symbol();\n  context[fn] &#x3D; this;\n  let _this &#x3D; this;\n  &#x2F;&#x2F;  bind情况要复杂一点\n  const result &#x3D; function (...innerArgs) &#123;\n    &#x2F;&#x2F; 第一种情况 :若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象\n    &#x2F;&#x2F; 此时由于new操作符作用  this指向result实例对象  而result又继承自传入的_this 根据原型链知识可得出以下结论\n    &#x2F;&#x2F; this.__proto__ &#x3D;&#x3D;&#x3D; result.prototype   &#x2F;&#x2F;this instanceof result &#x3D;&gt;true\n    &#x2F;&#x2F; this.__proto__.__proto__ &#x3D;&#x3D;&#x3D; result.prototype.__proto__ &#x3D;&#x3D;&#x3D; _this.prototype; &#x2F;&#x2F;this instanceof _this &#x3D;&gt;true\n    if (this instanceof _this &#x3D;&#x3D;&#x3D; true) &#123;\n      &#x2F;&#x2F; 此时this指向指向result的实例  这时候不需要改变this指向\n      this[fn] &#x3D; _this;\n      this[fn](...[...args, ...innerArgs]); &#x2F;&#x2F;这里使用es6的方法让bind支持参数合并\n    &#125; else &#123;\n      &#x2F;&#x2F; 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context\n      context[fn](...[...args, ...innerArgs]);\n    &#125;\n  &#125;;\n  &#x2F;&#x2F; 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法\n  &#x2F;&#x2F; 实现继承的方式: 使用Object.create\n  result.prototype &#x3D; Object.create(this.prototype);\n  return result;\n&#125;;\n\n&#x2F;&#x2F;用法如下\n\n&#x2F;&#x2F; function Person(name, age) &#123;\n&#x2F;&#x2F;   console.log(name); &#x2F;&#x2F;&#39;我是参数传进来的name&#39;\n&#x2F;&#x2F;   console.log(age); &#x2F;&#x2F;&#39;我是参数传进来的age&#39;\n&#x2F;&#x2F;   console.log(this); &#x2F;&#x2F;构造函数this指向实例对象\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; &#x2F;&#x2F; 构造函数原型的方法\n&#x2F;&#x2F; Person.prototype.say &#x3D; function() &#123;\n&#x2F;&#x2F;   console.log(123);\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; let obj &#x3D; &#123;\n&#x2F;&#x2F;   objName: &#39;我是obj传进来的name&#39;,\n&#x2F;&#x2F;   objAge: &#39;我是obj传进来的age&#39;\n&#x2F;&#x2F; &#125;\n&#x2F;&#x2F; &#x2F;&#x2F; 普通函数\n&#x2F;&#x2F; function normalFun(name, age) &#123;\n&#x2F;&#x2F;   console.log(name);   &#x2F;&#x2F;&#39;我是参数传进来的name&#39;\n&#x2F;&#x2F;   console.log(age);   &#x2F;&#x2F;&#39;我是参数传进来的age&#39;\n&#x2F;&#x2F;   console.log(this); &#x2F;&#x2F;普通函数this指向绑定bind的第一个参数 也就是例子中的obj\n&#x2F;&#x2F;   console.log(this.objName); &#x2F;&#x2F;&#39;我是obj传进来的name&#39;\n&#x2F;&#x2F;   console.log(this.objAge); &#x2F;&#x2F;&#39;我是obj传进来的age&#39;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; 先测试作为构造函数调用\n&#x2F;&#x2F; let bindFun &#x3D; Person.myBind(obj, &#39;我是参数传进来的name&#39;)\n&#x2F;&#x2F; let a &#x3D; new bindFun(&#39;我是参数传进来的age&#39;)\n&#x2F;&#x2F; a.say() &#x2F;&#x2F;123\n\n&#x2F;&#x2F; 再测试作为普通函数调用\n&#x2F;&#x2F; let bindFun &#x3D; normalFun.myBind(obj, &#39;我是参数传进来的name&#39;)\n&#x2F;&#x2F;  bindFun(&#39;我是参数传进来的age&#39;)</code></pre>\n\n<h2 id=\"10-深拷贝（考虑到复制-Symbol-类型）\"><a href=\"#10-深拷贝（考虑到复制-Symbol-类型）\" class=\"headerlink\" title=\"10 深拷贝（考虑到复制 Symbol 类型）\"></a>10 深拷贝（考虑到复制 Symbol 类型）</h2><p>题目描述:手写 new 操作符实现<br>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function isObject(val) &#123;\n  return typeof val &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; val !&#x3D;&#x3D; null;\n&#125;\n\nfunction deepClone(obj, hash &#x3D; new WeakMap()) &#123;\n  if (!isObject(obj)) return obj;\n\n  &#x2F;&#x2F; if (hash.has(obj)) &#123;\n  &#x2F;&#x2F;   return hash.get(obj);\n  &#x2F;&#x2F; &#125;\n\n  let target &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\n\n  &#x2F;&#x2F; hash.set(obj, target);\n\n  Reflect.ownKeys(obj).forEach((item) &#x3D;&gt; &#123;\n    if (isObject(obj[item])) &#123;\n      &#x2F;&#x2F; 递归的点\n      target[item] &#x3D; deepClone(obj[item], hash);\n    &#125; else &#123;\n      target[item] &#x3D; obj[item];\n    &#125;\n  &#125;);\n\n  return target;\n&#125;\n\n&#x2F;&#x2F; var obj1 &#x3D; &#123;\n&#x2F;&#x2F;   a: 1,\n&#x2F;&#x2F;   b: &#123; a: 2 &#125;,\n&#x2F;&#x2F; &#125;;\n&#x2F;&#x2F; var obj2 &#x3D; deepClone(obj1);\n&#x2F;&#x2F; console.log(obj1);</code></pre>\n\n<h2 id=\"11-instanceof\"><a href=\"#11-instanceof\" class=\"headerlink\" title=\"11 instanceof\"></a>11 instanceof</h2><p>题目描述:手写 instanceof 操作符实现</p>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function myInstanceof(left, right) &#123;\n  while (true) &#123;\n    &#x2F;&#x2F; 没找到结束条件\n    if (left &#x3D;&#x3D;&#x3D; null) &#123;\n      return false;\n    &#125;\n    &#x2F;&#x2F; 找到了结束条件\n    if (left.__proto__ &#x3D;&#x3D;&#x3D; right.prototype) &#123;\n      return true;\n    &#125;\n    left &#x3D; left.__proto__;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"12-柯里化-不懂\"><a href=\"#12-柯里化-不懂\" class=\"headerlink\" title=\"12 柯里化[不懂]\"></a>12 柯里化[不懂]</h2><p>题目描述:柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。<br>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function currying(fn, ...args) &#123;\n  const length &#x3D; fn.length; &#x2F;&#x2F; 函数参数长度\n\n  let allArgs &#x3D; [...args]; &#x2F;&#x2F; 外层参数\n\n  const res &#x3D; (...newArgs) &#x3D;&gt; &#123;\n    console.log(&quot;newArgs&quot;, newArgs);\n    allArgs &#x3D; [...allArgs, ...newArgs]; &#x2F;&#x2F; 外层、内层参数合并\n\n    if (allArgs.length &#x3D;&#x3D;&#x3D; length) &#123;\n      &#x2F;&#x2F; 参数长度&#x3D;&#x3D;函数参数长度，执行调用\n      return fn(...allArgs);\n    &#125; else &#123;\n      return res;\n    &#125;\n  &#125;;\n\n  return res;\n&#125;\n\n&#x2F;&#x2F; 用法如下：\nconst add &#x3D; (a, b, c) &#x3D;&gt; a + b + c;\nconst a &#x3D; currying(add, 1);\nconsole.log(a(2, 3));</code></pre>\n\n<h2 id=\"20-防抖节流\"><a href=\"#20-防抖节流\" class=\"headerlink\" title=\"20 防抖节流\"></a>20 防抖节流</h2><p>题目描述:手写防抖节流<br>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 防抖\n&#x2F;&#x2F; 存有之前时间标记的，清理掉，\nfunction debounce(fn, delay &#x3D; 300) &#123;\n  &#x2F;&#x2F;默认300毫秒\n  let timer;\n  return function () &#123;\n    const args &#x3D; arguments;\n    &#x2F;&#x2F; 再次执行，清理之前的\n    timer &amp;&amp; clearTimeout(timer);\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn.apply(this, args); &#x2F;&#x2F; 改变this指向为调用debounce所指的对象\n    &#125;, delay);\n  &#125;;\n&#125;\n\nwindow.addEventListener(\n  &quot;scroll&quot;,\n  debounce(() &#x3D;&gt; &#123;\n    console.log(111);\n  &#125;, 1000)\n);\n\n&#x2F;&#x2F; 节流\n&#x2F;&#x2F; 间隔delay执行一次\n&#x2F;&#x2F; 设置一个标志\nfunction throttle(fn, delay) &#123;\n  let canrun &#x3D; true;\n  return () &#x3D;&gt; &#123;\n    if (!canrun) return;\n\n    canrun &#x3D; false;\n\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn();\n      canrun &#x3D; true;\n    &#125;, delay);\n  &#125;;\n&#125;\n\nwindow.addEventListener(\n  &quot;scroll&quot;,\n  throttle(() &#x3D;&gt; &#123;\n    console.log(111);\n  &#125;, 1000)\n);</code></pre>\n\n<h2 id=\"24-实现一个-add-方法\"><a href=\"#24-实现一个-add-方法\" class=\"headerlink\" title=\"24 实现一个 add 方法\"></a>24 实现一个 add 方法</h2><p>题目描述:实现一个 add 方法 使计算结果能够满足如下预期：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">add(1)(2)(3)()&#x3D;6\nadd(1,2,3)(4)()&#x3D;10</code></pre>\n\n<p>其实就是考函数柯里化</p>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function add(...args) &#123;\n  let allArgs &#x3D; [...args];\n\n  function fn(...newArgs) &#123;\n    allArgs &#x3D; [...allArgs, ...newArgs];\n    return fn;\n  &#125;\n\n  fn.toString &#x3D; function () &#123;\n    if (!allArgs.length) &#123;\n      return;\n    &#125;\n    return allArgs.reduce((sum, cur) &#x3D;&gt; sum + cur);\n  &#125;;\n\n  return fn;\n&#125;</code></pre>\n\n<h2 id=\"25-动态规划\"><a href=\"#25-动态规划\" class=\"headerlink\" title=\"25 动态规划\"></a>25 动态规划</h2><h3 id=\"动态规划求解硬币找零问题\"><a href=\"#动态规划求解硬币找零问题\" class=\"headerlink\" title=\"动态规划求解硬币找零问题\"></a>动态规划求解硬币找零问题</h3><p>题目描述:给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。</p>\n<p>如果没有任何一种硬币组合能组成总金额，返回 -1</p>\n<p>示例 1：<br>输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出: 3<br>解释: 11 &#x3D; 5 + 5 + 1</p>\n<p>示例 2：<br>输入: coins &#x3D; [2], amount &#x3D; 3<br>输出: -1</p>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; const coinChange &#x3D; function (coins, amount) &#123;\n&#x2F;&#x2F;   &#x2F;&#x2F; 用于保存每个目标总额对应的最小硬币个数\n&#x2F;&#x2F;   const f &#x3D; [];\n&#x2F;&#x2F;   &#x2F;&#x2F; 提前定义已知情况\n&#x2F;&#x2F;   f[0] &#x3D; 0;\n\n&#x2F;&#x2F;   &#x2F;&#x2F; 遍历 [1, amount] 这个区间的硬币总额\n&#x2F;&#x2F;   &#x2F;&#x2F; -- 先遍历的钱\n&#x2F;&#x2F;   for (let i &#x3D; 1; i &lt;&#x3D; amount; i++) &#123;\n&#x2F;&#x2F;     &#x2F;&#x2F; 求的是最小值，因此我们预设为无穷大，确保它一定会被更小的数更新\n&#x2F;&#x2F;     &#x2F;&#x2F; -- 假设非最优用了无数个\n&#x2F;&#x2F;     f[i] &#x3D; Infinity;\n&#x2F;&#x2F;     &#x2F;&#x2F; 循环遍历每个可用硬币的面额\n&#x2F;&#x2F;     for (let j &#x3D; 0; j &lt; coins.length; j++) &#123;\n&#x2F;&#x2F;       &#x2F;&#x2F; 若硬币面额小于目标总额，则问题成立\n&#x2F;&#x2F;       if (i&#x2F;**总额 *&#x2F; - coins[j]&#x2F;**硬币面值 *&#x2F; &gt;&#x3D; 0) &#123;\n\n&#x2F;&#x2F;         &#x2F;&#x2F; 状态转移方程\n&#x2F;&#x2F;         f[i] &#x3D; Math.min(f[i], f[i - coins[j]] + 1);\n&#x2F;&#x2F;       &#125;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F;   &#x2F;&#x2F; 若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1\n&#x2F;&#x2F;   if (f[amount] &#x3D;&#x3D;&#x3D; Infinity) &#123;\n&#x2F;&#x2F;     return -1;\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F;   &#x2F;&#x2F; 若有解，直接返回解的内容\n&#x2F;&#x2F;   return f[amount];\n&#x2F;&#x2F; &#125;;\n\n&#x2F;&#x2F; 动态规划\nfunction assembleCoinDP(coins, amount) &#123;\n  &#x2F;&#x2F; dp 表最多包含 amount + 1 种情况（包括0）\n  const dp &#x3D; Array(amount + 1).fill(Infinity);\n  &#x2F;&#x2F; 最简单（自底向上的底）的情况：\n  dp[0] &#x3D; 0;\n  &#x2F;&#x2F; 从 1 开始填充 dp 表的过程即自底向上逐渐求解的过程\n  for (let i &#x3D; 1; i &lt; dp.length; i++) &#123;\n    &#x2F;&#x2F; 内层 for 循环求所有子问题 + 1（种硬币） 的最小值\n    &#x2F;&#x2F; 比如 i &#x3D; 1，我们即求解：1元+dp[0]，2元+dp[-1]，5元+dp[-4] 等3种情况，\n    &#x2F;&#x2F; 其中后两种被 continue 直接过滤了，所以 dp[1] 很容易得到为 1；\n    &#x2F;&#x2F; 随着 i 增大，我们最终总可以得到所有的 d[i]，且必然 d[x]（x &lt; i）是已经计算\n    &#x2F;&#x2F; 有结果的（保持 Infinity的最大值即代表amount 为该值时无可用的硬币排布，返回 -1）\n    for (let c of coins.values()) &#123;\n      if (i - c &lt; 0) &#123;\n        continue;\n      &#125;\n      dp[i] &#x3D; Math.min(dp[i], 1 + dp[i - c]);\n    &#125;\n  &#125;\n  return dp[amount] &#x3D;&#x3D;&#x3D; Infinity ? -1 : dp[amount];\n&#125;\n\n输入: (coins &#x3D; [2]), (amount &#x3D; 3);\n输出: -1;</code></pre>\n\n<h3 id=\"动态规划-爬楼梯\"><a href=\"#动态规划-爬楼梯\" class=\"headerlink\" title=\"动态规划 - 爬楼梯\"></a>动态规划 - 爬楼梯</h3><p><a href=\"https://blog.csdn.net/weixin_45771601/article/details/126337096\" target=\"_blank\" >见</a></p>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>题目描述：假设正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？其中 n 是一个正整数。</p>\n<p>本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。</p>\n<p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p>\n<p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p>\n<p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p>\n<p>这道题有两个关键特征：</p>\n<p>要求给出达成某个目的的解法个数；<br>不要求给出每一种解法对应的具体路径。<br>对于这个问题，每次爬楼梯只有两种情况：</p>\n<p>最后一步爬 1 级台阶，前面有 n - 1 级台阶，这种情况下共有 f(n - 1)种方法；<br>最后一步爬 2 级台阶，前面有 n - 2 级台阶，这种情况下共有 f(n - 2)种方法；</p>\n<p>f(n) 为以上两种情况之和，即 f(n)&#x3D;f(n-1)+f(n-2)，这就是本题用到的递推关系。下面就根据动态规划的四个步骤来看那一下：</p>\n<ul>\n<li>状态定义：初始化一个 f 数组，f[i]表示爬到 i 级台阶的方法数量；</li>\n<li>状态转移方程：f(n)&#x3D;f(n-1)+f(n-2)；</li>\n<li>初始状态：一级台阶时，共 1 种爬法；两级台阶时，可以一级一级爬，也可以一次爬两级，共有 2 种爬法。即 f[1] &#x3D; 1，f[2] &#x3D; 2；</li>\n<li>返回值：f[n] ，即 n 级台阶共有多少种爬法</li>\n</ul>\n<p>动态规划实现代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">p[0] &#x3D; 0;\np[1] &#x3D; 1;\np[2] &#x3D; 2;\np[3] &#x3D; 3; &#x2F;&#x2F; p[3] &#x2F;**(1-&gt;3)**&#x2F; + p[3]; &#x2F;**(2-&gt;3)**&#x2F;\np[4] &#x3D; 5; &#x2F;&#x2F;  &#x2F;**(2-&gt;4)**&#x2F; + p[3]; &#x2F;**(3-&gt;4)**&#x2F;\n\n&#x2F;**\n * @param &#123;number&#125; n\n * @return &#123;number&#125;\n *&#x2F;\nconst climbStairs &#x3D; function (n) &#123;\n  &#x2F;&#x2F; 初始化状态数组\n  const f &#x3D; [];\n  &#x2F;&#x2F; 初始化已知值\n  f[1] &#x3D; 1;\n  f[2] &#x3D; 2;\n  &#x2F;&#x2F; 动态更新每一层楼梯对应的结果\n  for (let i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;\n    f[i] &#x3D; f[i - 2] + f[i - 1];\n  &#125;\n  &#x2F;&#x2F; 返回目标值\n  return f[n];\n&#125;;</code></pre>\n\n<p>上面用动态规划的思想解决了爬楼梯的问题，当然我们的目的并不是为了解决这个问题，而是通过这个问题来看动态规划，下面就来重新认识一下动态规划。</p>\n<p>动态规划的思想和“分治”有点相似（把一个问题分解为相互独立的子问题，逐个解决子问题后，再组合子问题的答案，就得到了问题的最终解）。不同之处在于，“分治”思想中，各个子问题之间是独立的：比如说归并排序中，子数组之间的排序并不互相影响。而动态规划划分出的子问题，往往是相互依赖、相互影响的。</p>\n<p>那什么样的题应该用动态规划来做？要抓以下关键特征：</p>\n<ul>\n<li><p><strong>最优子结构</strong>，它指的是问题的最优解包含着子问题的最优解——不管前面的决策如何，此后的状态必须是基于当前状态（由上次决策产生）的最优决策。就这道题来说，f(n)和 f(n-1)、f(n-2)之间的关系（状态转移方程）印证了这一点。</p>\n</li>\n<li><p><strong>重叠子问题</strong>，在递归的过程中，出现了反复计算的情况。</p>\n</li>\n<li><p><strong>无后效性</strong>，无后效性有两层含义，</p>\n<ul>\n<li>第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。</li>\n<li>第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。</li>\n</ul>\n<p>无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p>\n</li>\n</ul>\n<p>所以，只要需要解决的问题符合这三个关键特征，就可以使用动态规划来求解。</p>\n<h2 id=\"27-类数组转化为数组的方法\"><a href=\"#27-类数组转化为数组的方法\" class=\"headerlink\" title=\"27 类数组转化为数组的方法\"></a>27 类数组转化为数组的方法</h2><p>题目描述:类数组拥有 length 属性 可以使用下标来访问元素 但是不能使用数组的方法 如何把类数组转化为数组?</p>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arrayLike&#x3D;document.querySelectorAll(&#39;div&#39;)\n\n&#x2F;&#x2F; 1.扩展运算符\n[...arrayLike]\n&#x2F;&#x2F; 2.Array.from\nArray.from(arrayLike)\n&#x2F;&#x2F; 3.Array.prototype.slice\nArray.prototype.slice.call(arrayLike)\n&#x2F;&#x2F; 4.Array.apply\nArray.apply(null, arrayLike)\n&#x2F;&#x2F; 5.Array.prototype.concat\nArray.prototype.concat.apply([], arrayLike)</code></pre>\n\n<h2 id=\"28-Object-is-实现\"><a href=\"#28-Object-is-实现\" class=\"headerlink\" title=\"28 Object.is 实现\"></a>28 Object.is 实现</h2><p>特点： 1. 能判断正负零 2. NaN 相等</p>\n<p>题目描述:</p>\n<p>Object.is 不会转换被比较的两个值的类型，这点和&#x3D;&#x3D;&#x3D;更为相似，他们之间也存在一些区别。</p>\n<ol>\n<li><p>NaN 在&#x3D;&#x3D;&#x3D;中是不相等的，而在 Object.is 中是相等的</p>\n</li>\n<li><p>+0 和-0 在&#x3D;&#x3D;&#x3D;中是相等的，而在 Object.is 中是不相等的</p>\n</li>\n</ol>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.is &#x3D; function (x, y) &#123;\n  if (x &#x3D;&#x3D;&#x3D; y) &#123;\n    &#x2F;&#x2F; 当前情况下，只有一种情况是特殊的，即 +0 -0\n    &#x2F;&#x2F; 如果 x !&#x3D;&#x3D; 0，则返回true\n    &#x2F;&#x2F; 如果 x &#x3D;&#x3D;&#x3D; 0，则需要判断+0和-0，则可以直接使用 1&#x2F;+0 &#x3D;&#x3D;&#x3D; Infinity 和 1&#x2F;-0 &#x3D;&#x3D;&#x3D; -Infinity来进行判断\n    return x !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;\n  &#125;\n\n  &#x2F;&#x2F; x !&#x3D;&#x3D; y 的情况下，只需要判断是否为NaN，如果x!&#x3D;&#x3D;x，则说明x是NaN，同理y也一样\n  &#x2F;&#x2F; x和y同时为NaN时，返回true\n  return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;\n&#125;;</code></pre>\n\n<h2 id=\"29-AJAX\"><a href=\"#29-AJAX\" class=\"headerlink\" title=\"29 AJAX\"></a>29 AJAX</h2><p>题目描述:利用 XMLHttpRequest 手写 AJAX 实现<br>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const getJSON &#x3D; function (url) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const xhr &#x3D; new XMLHttpRequest();\n    xhr.open(&quot;GET&quot;, url, false &#x2F;**否异步执行操作，默认为 true *&#x2F;);\n    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);\n    xhr.onreadystatechange &#x3D; function () &#123;\n      if (xhr.readyState !&#x3D;&#x3D; 4) return;\n      if (xhr.status &#x3D;&#x3D;&#x3D; 200 || xhr.status &#x3D;&#x3D;&#x3D; 304) &#123;\n        resolve(xhr.responseText);\n      &#125; else &#123;\n        reject(new Error(xhr.responseText));\n      &#125;\n    &#125;;\n    xhr.send();\n  &#125;);\n&#125;;</code></pre>\n\n<h2 id=\"30-分片思想解决大数据量渲染问题\"><a href=\"#30-分片思想解决大数据量渲染问题\" class=\"headerlink\" title=\"30 分片思想解决大数据量渲染问题\"></a>30 分片思想解决大数据量渲染问题</h2><p>题目描述:渲染百万条结构简单的大数据时 怎么使用分片思想优化渲染</p>\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let ul &#x3D; document.getElementById(&quot;container&quot;);\n&#x2F;&#x2F; 插入十万条数据\nlet total &#x3D; 100000;\n&#x2F;&#x2F; 一次插入 20 条\nlet once &#x3D; 20;\n&#x2F;&#x2F;总页数\nlet page &#x3D; total &#x2F; once;\n&#x2F;&#x2F;每条记录的索引\nlet index &#x3D; 0;\n&#x2F;&#x2F;循环加载数据\nfunction loop(curTotal, curIndex) &#123;\n  if (curTotal &lt;&#x3D; 0) &#123;\n    return false;\n  &#125;\n  &#x2F;&#x2F;每页多少条\n  let pageCount &#x3D; Math.min(curTotal, once);\n  window.requestAnimationFrame(function () &#123;\n    for (let i &#x3D; 0; i &lt; pageCount; i++) &#123;\n      let li &#x3D; document.createElement(&quot;li&quot;);\n      li.innerText &#x3D; curIndex + i + &quot; : &quot; + ~~(Math.random() * total);\n      ul.appendChild(li);\n    &#125;\n    loop(curTotal - pageCount, curIndex + pageCount);\n  &#125;);\n&#125;\nloop(total, index);</code></pre>\n\n<p>扩展思考：对于大数据量的简单 dom 结构渲染可以用分片思想解决 如果是复杂的 dom 结构渲染如何处理？</p>\n<p>这时候就需要使用虚拟列表了 大家自行百度哈 虚拟列表和虚拟表格在日常项目使用还是很频繁的</p>\n<h2 id=\"32-实现模板字符串解析功能\"><a href=\"#32-实现模板字符串解析功能\" class=\"headerlink\" title=\"32 实现模板字符串解析功能\"></a>32 实现模板字符串解析功能</h2><p>这个玩意，在多语言中，挖空，替换值特别有用</p>\n<p>记录个点：目前 localize 多语言平台会把空格抹掉，代码中需要用空格的存在问题</p>\n<p>题目描述:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let template &#x3D; &quot;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&quot;;\nlet data &#x3D; &#123;\n  name: &quot;姓名&quot;,\n  age: 18,\n&#125;;\nrender(template, data); &#x2F;&#x2F; 我是姓名，年龄 18，性别 undefined</code></pre>\n\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function render(template, data) &#123;\n  let computed &#x3D; template.replace(&#x2F;\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;&#x2F;g, function (match, key) &#123;\n    return data[key] || &quot; __ &quot;;\n  &#125;);\n  return computed;\n&#125;</code></pre>\n\n<h2 id=\"33-实现一个对象的-flatten-方法\"><a href=\"#33-实现一个对象的-flatten-方法\" class=\"headerlink\" title=\"33 实现一个对象的 flatten 方法\"></a>33 实现一个对象的 flatten 方法</h2><p>题目描述:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n a: &#123;\n        b: 1,\n        c: 2,\n        d: &#123;e: 5&#125;\n    &#125;,\n b: [1, 3, &#123;a: 2, b: 3&#125;],\n c: 3\n&#125;\n\nflatten(obj) 结果返回如下\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;  &#39;a.b&#39;: 1,\n&#x2F;&#x2F;  &#39;a.c&#39;: 2,\n&#x2F;&#x2F;  &#39;a.d.e&#39;: 5,\n&#x2F;&#x2F;  &#39;b[0]&#39;: 1,\n&#x2F;&#x2F;  &#39;b[1]&#39;: 3,\n&#x2F;&#x2F;  &#39;b[2].a&#39;: 2,\n&#x2F;&#x2F;  &#39;b[2].b&#39;: 3\n&#x2F;&#x2F;   c: 3\n&#x2F;&#x2F; &#125;</code></pre>\n\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function isObject(val) &#123;\n  return typeof val &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; val !&#x3D;&#x3D; null;\n&#125;\n\nfunction flatten(obj) &#123;\n  if (!isObject(obj)) &#123;\n    return;\n  &#125;\n\n  let res &#x3D; &#123;&#125;;\n\n  const dfs &#x3D; (cur, prefix) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 是不是对象\n    if (isObject(cur)) &#123;\n      &#x2F;&#x2F; 数组\n      if (Array.isArray(cur)) &#123;\n        cur.forEach((item, index) &#x3D;&gt; &#123;\n          dfs(item, &#96;$&#123;prefix&#125;[$&#123;index&#125;]&#96;);\n        &#125;);\n        &#x2F;&#x2F; 对象\n      &#125; else &#123;\n        for (let k in cur) &#123;\n          dfs(cur[k], &#96;$&#123;prefix&#125;$&#123;prefix ? &quot;.&quot; : &quot;&quot;&#125;$&#123;k&#125;&#96;);\n        &#125;\n      &#125;\n    &#125; else &#123;\n      res[prefix] &#x3D; cur;\n    &#125;\n  &#125;;\n\n  dfs(obj, &quot;&quot;);\n\n  return res;\n&#125;\nflatten();</code></pre>\n\n<h2 id=\"34-列表转成树形结构\"><a href=\"#34-列表转成树形结构\" class=\"headerlink\" title=\"34 列表转成树形结构\"></a>34 列表转成树形结构</h2><p>题目描述:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[\n    &#123;\n        id: 1,\n        text: &#39;节点1&#39;,\n        parentId: 0 &#x2F;&#x2F;这里用0表示为顶级节点\n    &#125;,\n    &#123;\n        id: 2,\n        text: &#39;节点1_1&#39;,\n        parentId: 1 &#x2F;&#x2F;通过这个字段来确定子父级\n    &#125;\n    ...\n]\n\n&#x2F;&#x2F; 转成\n[\n    &#123;\n        id: 1,\n        text: &#39;节点1&#39;,\n        parentId: 0,\n        children: [\n            &#123;\n                id:2,\n                text: &#39;节点1_1&#39;,\n                parentId:1\n            &#125;\n        ]\n    &#125;\n]\n</code></pre>\n\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function listToTree(data) &#123;\n  let temp &#x3D; &#123;&#125;;\n  let treeData &#x3D; [];\n  &#x2F;&#x2F; 转化成对象\n  for (let i &#x3D; 0; i &lt; data.length; i++) &#123;\n    temp[data[i].id] &#x3D; data[i];\n  &#125;\n\n  for (let i in temp) &#123;\n    &#x2F;&#x2F; 临时中有元素\n    if (+temp[i].parentId !&#x3D; 0) &#123;\n      &#x2F;&#x2F; 有数组直接push,无数组先 进行初始化，然后push\n      if (!temp[temp[i].parentId].children) &#123;\n        temp[temp[i].parentId].children &#x3D; [];\n      &#125;\n      temp[temp[i].parentId].children.push(temp[i]);\n      &#x2F;&#x2F; 根节点情况\n    &#125; else &#123;\n      treeData.push(temp[i]);\n    &#125;\n  &#125;\n  return treeData;\n&#125;</code></pre>\n\n<h2 id=\"35-树形结构转成列表\"><a href=\"#35-树形结构转成列表\" class=\"headerlink\" title=\"35 树形结构转成列表\"></a>35 树形结构转成列表</h2><p>题目描述:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[\n    &#123;\n        id: 1,\n        text: &#39;节点1&#39;,\n        parentId: 0,\n        children: [\n            &#123;\n                id:2,\n                text: &#39;节点1_1&#39;,\n                parentId:1\n            &#125;\n        ]\n    &#125;\n]\n&#x2F;&#x2F; 转成\n[\n    &#123;\n        id: 1,\n        text: &#39;节点1&#39;,\n        parentId: 0 &#x2F;&#x2F;这里用0表示为顶级节点\n    &#125;,\n    &#123;\n        id: 2,\n        text: &#39;节点1_1&#39;,\n        parentId: 1 &#x2F;&#x2F;通过这个字段来确定子父级\n    &#125;\n    ...\n]</code></pre>\n\n<p>实现代码如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function treeToList(data) &#123;\n  let res &#x3D; [];\n\n  const dfs &#x3D; (tree) &#x3D;&gt; &#123;\n    tree.forEach((item) &#x3D;&gt; &#123;\n      if (item.children) &#123;\n        dfs(item.children);\n        delete item.children;\n      &#125;\n      res.push(item);\n    &#125;);\n  &#125;;\n\n  dfs(data);\n  return res;\n&#125;</code></pre>\n\n<h2 id=\"36-大数相加\"><a href=\"#36-大数相加\" class=\"headerlink\" title=\"36 大数相加\"></a>36 大数相加</h2><p>题目描述:实现一个 add 方法完成两个大数相加</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let a &#x3D; &quot;9007199254740991&quot;;\nlet b &#x3D; &quot;1234567899999999999&quot;;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function add(a, b) &#123;\n  &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p>实现代码如下:&#96;</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function add(a, b) &#123;\n  &#x2F;&#x2F;取两个数字的最大长度\n  let maxLength &#x3D; Math.max(a.length, b.length);\n  &#x2F;&#x2F;用0去补齐长度\n  a &#x3D; a.padStart(maxLength, 0); &#x2F;&#x2F;&quot;0009007199254740991&quot;\n  b &#x3D; b.padStart(maxLength, 0); &#x2F;&#x2F;&quot;1234567899999999999&quot;\n  &#x2F;&#x2F;定义加法过程中需要用到的变量\n  let t &#x3D; 0;\n  let f &#x3D; 0; &#x2F;&#x2F;&quot;进位&quot;\n  let sum &#x3D; &quot;&quot;;\n  for (let i &#x3D; maxLength - 1; i &gt;&#x3D; 0; i--) &#123;\n    &#x2F;&#x2F; 计算当前位对应的值\n    t &#x3D; parseInt(a[i]) + parseInt(b[i]) + f;\n    &#x2F;&#x2F; 当前位对应值取进位\n    f &#x3D; Math.floor(t &#x2F; 10);\n    &#x2F;&#x2F; 取的模拼接到sum之前\n    sum &#x3D; (t % 10) + sum;\n  &#125;\n  &#x2F;&#x2F; 结束时候如果有进位，拼到前面\n  if (f !&#x3D;&#x3D; 0) &#123;\n    sum &#x3D; &quot;&quot; + f + sum;\n  &#125;\n  &#x2F;&#x2F; 最终返回结果\n  return sum;\n&#125;</code></pre>\n\n<h2 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h2><p>通过构造函数</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  constructor() &#123;\n    console.log(&quot;this&quot;, this);\n    if (!Singleton.instance) &#123;\n      &#x2F;&#x2F; 将 this 挂载到单例上\n      Singleton.instance &#x3D; this;\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"通过静态方法\"><a href=\"#通过静态方法\" class=\"headerlink\" title=\"通过静态方法\"></a>通过静态方法</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null;\n\n  static getInstance() &#123;\n    if (!Singleton.instance) &#123;\n      Singleton.instance &#x3D; new Singleton();\n    &#125;\n    return Singleton.instance;\n  &#125;\n&#125;\nconst a &#x3D; new Singleton();\nconst b &#x3D; new Singleton();\nconsole.log(a &#x3D;&#x3D;&#x3D; b);</code></pre>\n\n<h2 id=\"上传进度\"><a href=\"#上传进度\" class=\"headerlink\" title=\"上传进度\"></a>上传进度</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">export default function upload(option: UploadRequestOption) &#123;\n  &#x2F;&#x2F; eslint-disable-next-line no-undef\n  const xhr &#x3D; new XMLHttpRequest();\n  &#x2F;&#x2F; debugger\n\n  if (option.onProgress &amp;&amp; xhr.upload) &#123;\n    xhr.upload.onprogress &#x3D; function progress(e: any) &#123;\n      if (e.total &gt; 0) &#123;\n        e.percent &#x3D; (e.loaded &#x2F; e.total) * 100;\n      &#125;\n      option.onProgress?.(e);\n    &#125;;\n  &#125;\n\n  &#x2F;&#x2F; eslint-disable-next-line no-undef\n  &#x2F;&#x2F; const formData &#x3D; new FormData();\n\n  &#x2F;&#x2F; if (option.data) &#123;\n  &#x2F;&#x2F;   Object.keys(option.data).forEach((key) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;     const value &#x3D; option.data[key];\n  &#x2F;&#x2F;     &#x2F;&#x2F; support key-value array data\n  &#x2F;&#x2F;     if (Array.isArray(value)) &#123;\n  &#x2F;&#x2F;       value.forEach((item) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;         &#x2F;&#x2F; &#123; list: [ 11, 22 ] &#125;\n  &#x2F;&#x2F;         &#x2F;&#x2F; formData.append(&#39;list[]&#39;, 11);\n  &#x2F;&#x2F;         formData.append(&#96;$&#123;key&#125;[]&#96;, item);\n  &#x2F;&#x2F;       &#125;);\n  &#x2F;&#x2F;       return;\n  &#x2F;&#x2F;     &#125;\n\n  &#x2F;&#x2F;     formData.append(key, option.data[key]);\n  &#x2F;&#x2F;   &#125;);\n  &#x2F;&#x2F; &#125;\n\n  &#x2F;&#x2F; eslint-disable-next-line no-undef\n  &#x2F;&#x2F; if (option.file instanceof Blob) &#123;\n  &#x2F;&#x2F;   formData.append(option.filename, option.file, (option.file as any).name);\n  &#x2F;&#x2F; &#125; else &#123;\n  &#x2F;&#x2F;   formData.append(option.filename, option.file);\n  &#x2F;&#x2F; &#125;\n\n  xhr.onerror &#x3D; function error(e) &#123;\n    option.onError?.(e);\n  &#125;;\n\n  xhr.onload &#x3D; function onload() &#123;\n    &#x2F;&#x2F; allow success when 2xx status\n    &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;react-component&#x2F;upload&#x2F;issues&#x2F;34\n    if (xhr.status &lt; 200 || xhr.status &gt;&#x3D; 300) &#123;\n      return option.onError?.(getError(option, xhr), getBody(xhr));\n    &#125;\n\n    return option.onSuccess?.(getBody(xhr), xhr);\n  &#125;;\n\n  xhr.open(option.method, option.action, true);\n\n  &#x2F;&#x2F; Has to be after &#96;.open()&#96;. See https:&#x2F;&#x2F;github.com&#x2F;enyo&#x2F;dropzone&#x2F;issues&#x2F;179\n  if (option.withCredentials &amp;&amp; &quot;withCredentials&quot; in xhr) &#123;\n    xhr.withCredentials &#x3D; true;\n  &#125;\n\n  const headers &#x3D; option.headers || &#123;&#125;;\n\n  &#x2F;&#x2F; when set headers[&#39;X-Requested-With&#39;] &#x3D; null , can close default XHR header\n  &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;react-component&#x2F;upload&#x2F;issues&#x2F;33\n  if (headers[&quot;X-Requested-With&quot;] !&#x3D;&#x3D; null) &#123;\n    xhr.setRequestHeader(&quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;);\n  &#125;\n\n  Object.keys(headers).forEach((h) &#x3D;&gt; &#123;\n    if (headers[h] !&#x3D;&#x3D; null) &#123;\n      xhr.setRequestHeader(h, headers[h]);\n    &#125;\n  &#125;);\n\n  xhr.send(option.file);\n\n  return &#123;\n    abort() &#123;\n      xhr.abort();\n    &#125;,\n  &#125;;\n&#125;</code></pre>\n\n<h2 id=\"下载进度\"><a href=\"#下载进度\" class=\"headerlink\" title=\"下载进度\"></a>下载进度</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 待补充</code></pre>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://juejin.cn/column/7004656346549207077\" target=\"_blank\" >前端面试集合</a></p>\n<p><a href=\"https://juejin.cn/post/6965029626598948894\" target=\"_blank\" >前端管理</a></p>\n","count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-compose\"><span class=\"toc-text\">1. compose</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-settimeout-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-setinterval-%E5%B8%A6%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">2.1 settimeout 模拟实现 setinterval(带清除定时器的版本)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-setinterval-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-settimeout-%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">2.2 setinterval 模拟实现 settimeout 吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3 发布订阅模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D\"><span class=\"toc-text\">4 数组去重</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96\"><span class=\"toc-text\">5 数组扁平化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF-%E4%B8%8D%E6%87%82\"><span class=\"toc-text\">6 寄生组合继承 [不懂]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%B9%B6%E8%A1%8C%E9%99%90%E5%88%B6%E7%9A%84-Promise-%E8%B0%83%E5%BA%A6%E5%99%A8\"><span class=\"toc-text\">7 实现有并行限制的 Promise 调度器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-new-%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">8 new 操作符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-call-apply-bind\"><span class=\"toc-text\">9 call apply bind</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#apply\"><span class=\"toc-text\">apply</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bind\"><span class=\"toc-text\">bind</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88%E8%80%83%E8%99%91%E5%88%B0%E5%A4%8D%E5%88%B6-Symbol-%E7%B1%BB%E5%9E%8B%EF%BC%89\"><span class=\"toc-text\">10 深拷贝（考虑到复制 Symbol 类型）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-instanceof\"><span class=\"toc-text\">11 instanceof</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E6%9F%AF%E9%87%8C%E5%8C%96-%E4%B8%8D%E6%87%82\"><span class=\"toc-text\">12 柯里化[不懂]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81\"><span class=\"toc-text\">20 防抖节流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-add-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">24 实现一个 add 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">25 动态规划</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E8%A7%A3%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">动态规划求解硬币找零问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%88%AC%E6%A5%BC%E6%A2%AF\"><span class=\"toc-text\">动态规划 - 爬楼梯</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27-%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">27 类数组转化为数组的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28-Object-is-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">28 Object.is 实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#29-AJAX\"><span class=\"toc-text\">29 AJAX</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#30-%E5%88%86%E7%89%87%E6%80%9D%E6%83%B3%E8%A7%A3%E5%86%B3%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">30 分片思想解决大数据量渲染问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">32 实现模板字符串解析功能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#33-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84-flatten-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">33 实现一个对象的 flatten 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#34-%E5%88%97%E8%A1%A8%E8%BD%AC%E6%88%90%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">34 列表转成树形结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#35-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E8%BD%AC%E6%88%90%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">35 树形结构转成列表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#36-%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0\"><span class=\"toc-text\">36 大数相加</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B\"><span class=\"toc-text\">单例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">通过静态方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6\"><span class=\"toc-text\">上传进度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BD%E8%BF%9B%E5%BA%A6\"><span class=\"toc-text\">下载进度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>"}