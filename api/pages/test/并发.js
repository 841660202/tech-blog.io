{"title":"","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"// 原理：将在用数量，限制在最大数量内的异步直接发， // 限制外的现存到数组中，当在用数量减少时一个一个取出来运行 class LimitPromise { limit; // 最大限制数 count; // 目前并发的数量 taskQueue; // 如果并发数等于最大限制...","date":"2022-09-15T14:26:11.120Z","updated":"2022-09-15T14:26:11.120Z","comments":true,"path":"api/pages/test/并发.js","covers":null,"excerpt":"","content":"// 原理：将在用数量，限制在最大数量内的异步直接发，\n// 限制外的现存到数组中，当在用数量减少时一个一个取出来运行\nclass LimitPromise {\n  limit; // 最大限制数\n  count; // 目前并发的数量\n  taskQueue; // 如果并发数等于最大限制，则把新加的异步操作用数组存起来\n\n  constructor(limit) {\n    this.limit = limit;\n    this.count = 0;\n    this.taskQueue = [];\n  }\n  // 管理任务执行\n  createTask(asyncFn, args, resolve, reject) {\n    return () => {\n      asyncFn(...args)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          this.count--; // 任务结束后，对任务队列进行出列，执行\n          if (this.taskQueue.length) {\n            let task = this.taskQueue.shift();\n            task();\n          }\n        });\n\n      this.count++; // 在执行的数量\n    };\n  }\n  // 管理队列\n  call(asyncFn, ...args) {\n    return new Promise((resolve, reject) => {\n      const task = this.createTask(asyncFn, args, resolve, reject);\n      if (this.count >= this.limit) {\n        // 大于限制的存起来\n        this.taskQueue.push(task);\n      } else {\n        // 否则直接执行\n        task();\n      }\n    });\n  }\n}\n\nlet limitP = new LimitPromise(3);\n\n// 测试\nfunction sleep(sec) {\n  console.log(\"..............\");\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(\"等待了\" + sec + \"秒\");\n      resolve(\"\");\n    }, sec * 1000);\n  });\n}\n\nlimitP.call(sleep, 1);\nlimitP.call(sleep, 2);\nlimitP.call(sleep, 3);\nlimitP.call(sleep, 4);\nlimitP.call(sleep, 5);\nlimitP.call(sleep, 6);\n","count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"toc":""}