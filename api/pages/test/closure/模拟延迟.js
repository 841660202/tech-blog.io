{"title":"","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"/** * * @description 用promise封装倒计时 * @param {number} ms 倒计时毫秒 * @param {any} arg 可选|倒计时结束返回的数据 * @return {any} */ const sleep = (ms, arg) =>...","date":"2023-02-20T21:20:56.509Z","updated":"2023-02-20T21:20:56.509Z","comments":true,"path":"api/pages/test/closure/模拟延迟.js","covers":null,"excerpt":"","content":"/**\n *\n * @description 用promise封装倒计时\n * @param {number} ms 倒计时毫秒\n * @param {any} arg 可选|倒计时结束返回的数据\n * @return {any}\n */\nconst sleep = (ms, arg) =>\n  new Promise((resolve) => setTimeout(resolve, ms, arg));\n// ————————————————\n// 版权声明：本文为CSDN博主「RYAN・L：」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n// 原文链接：https://blog.csdn.net/weixin_45132729/article/details/113339750\n\n// 利用Promise对象进行二次封装setTimeout函数。 然后就可以完美结合async await来实现倒计时的功能，甚至还能等待一个预设返回值！是不是觉得那个被“用烂”的setTimeout一下子就不香了！\n\n(async function () {\n  // await sleep(200);\n  // console.log(\"hey guys\"); // 200 毫秒后打印 \"hey guys\"\n  console.log(\"请求中...\");\n  console.log(await sleep(1000, { data: { result: \"xxxxxxxx\" } })); // 1200毫秒后打印 { data: { result: 'xxxxxxxx' } }\n})();\n","count_time":{"symbolsCount":720,"symbolsTime":"1 mins."},"toc":""}