{"title":"","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"// @link: https://blog.csdn.net/dingshao1114/article/details/105340579 /** * 双向链表节点 * 包含三个值：当前节点的值和分别指向前后节点的链接 */ class Node { constructor(e...","date":"2022-09-16T13:54:56.372Z","updated":"2022-09-16T13:54:56.372Z","comments":true,"path":"api/pages/test/l链表/双向链表.js","covers":null,"excerpt":"","content":"// @link: https://blog.csdn.net/dingshao1114/article/details/105340579\n/**\n * 双向链表节点\n * 包含三个值：当前节点的值和分别指向前后节点的链接\n */\n\nclass Node {\n  constructor(element) {\n    this.element = element;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\n/**双向链表*/\n\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n  }\n  /**在链表末尾添加一个元素 */\n  add(element) {\n    const node = new Node(element);\n    if (this.head === null) {\n      // 一个节点不会有双向，最少两个节点才会有双向\n      this.head = node;\n      return;\n    }\n    let current = this.head;\n    while (current.next) {\n      // 两个以上节点\n      current = current.next;\n    }\n    current.next = node; // （当前遍历到的节点）的下一个节点为新增的节点\n    node.prev = current; // 新增节点的上一个节点为（当前遍历到的节点）\n  }\n  /**删除 */\n  remove(element) {\n    if (this.head === null) {\n      return false;\n    }\n    let current = this.head;\n    if (current.element === element) {\n      if (this.head.next) {\n        // 如果是首部，之后有节点，则需要调整第二个节点，指针\n        this.head = this.head.next;\n        this.head.prev = null;\n      } else {\n        this.head = null; // 之后没有节点，直接令head = null,相当于回到初始化\n      }\n      return true;\n    }\n\n    let prev;\n    // 当找到要删除的节点时候，while的body没有执行，此时 【prev节点】=【current节点】=【next节点】\n    while (current !== null && current.element !== element) {\n      prev = current;\n      current = current.next;\n    }\n\n    if (current) {\n      prev.next = current.next || null; // 删除操作\n      if (current.next) { // 将下一个节点的prev接到prev节点\n        current.next.prev = prev;\n      }\n      return true\n    }\n    return false\n  }\n}\n","count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"toc":""}