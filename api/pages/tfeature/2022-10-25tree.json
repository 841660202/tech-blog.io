{"title":"数据结构","uid":"676aee73b09ef61d32d3123be90efb57","text":"线性表(一对一)数据与数据之间一一联系，前一个数据和后一个数据相连，这种数据结构最后会像线一样连成一串 ，这种数据结构也因此得名为线性表 顺序表实现线性表的最简单的方式，就是在一片连续的内存中按照顺序填充数据，这样每个数据都会像排队一样在内存空间里有一定的位置。要访问数据的前一个...","date":"2022-10-25T01:36:18.000Z","updated":"2022-10-25T12:09:37.235Z","comments":true,"path":"api/pages/tfeature/2022-10-25tree.json","covers":[],"excerpt":"","content":"<h2 id=\"线性表-一对一\"><a href=\"#线性表-一对一\" class=\"headerlink\" title=\"线性表(一对一)\"></a>线性表(一对一)</h2><p>数据与数据之间一一联系，<em>前一个数据和后一个数据相连，这种数据结构最后会像线一样连成一串</em> ，这种数据结构也因此得名为线性表</p>\n<h3 id=\"顺序表\"><a href=\"#顺序表\" class=\"headerlink\" title=\"顺序表\"></a>顺序表</h3><p>实现线性表的最简单的方式，就是在一片连续的内存中按照顺序填充数据，这样每个数据都会像排队一样在内存空间里有一定的位置。要访问数据的前一个数据，只要在内存中相应偏移一定的量（通常是一个数据的长度），就能访问到相应的数据，访问后一个数据也可以使用相同的方式。（数组）</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>不能确定分配的空间大小</li>\n<li>在顺序表中间或者开头插入一个数据， 要在要插入的位置开始，将所有的数据后移一位，才能将新数据填充进去，删除也有同样的情况</li>\n<li>内存的使用并不是有规律的，不能在支零破碎的内存中利用好每个空隙</li>\n</ul>\n<h3 id=\"链式表\"><a href=\"#链式表\" class=\"headerlink\" title=\"链式表\"></a>链式表</h3><p>一个 node 就是一个数据，也就是一个数据节点，每个节点由数据域和指针域构成，数据域用来存放数据，而指针域用来指定下一个目标节点。</p>\n<p>由于链表的这种特性，要在中间插入一个数据，只需要新建一个数据节点，然后将前一个数据的指针域指向这个新数据，然后将这个新数据指向后一个指针域即可。删除也很简单，我们只需要将前一个数据的指针域指向下一个数据，然后删除这个数据即可（在 c 语言中线性表需要自行实现，或者使用相应的库，而在 python 中列表具有相应的功能，但列表并不只是单纯的链式表，你可以看做他是链式表的升级版或者超集）</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>长度不易获取</li>\n<li>不易查找某个节点</li>\n</ul>\n<h4 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h4><h4 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h4><h4 id=\"环状链表\"><a href=\"#环状链表\" class=\"headerlink\" title=\"环状链表\"></a>环状链表</h4><h3 id=\"顺序表和链式表的优缺点比较\"><a href=\"#顺序表和链式表的优缺点比较\" class=\"headerlink\" title=\"顺序表和链式表的优缺点比较\"></a>顺序表和链式表的优缺点比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">比较点</th>\n<th align=\"left\">顺序表</th>\n<th align=\"left\">链式表</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">内存使用</td>\n<td align=\"left\">连续的一块空间，数据相邻，通过物理相邻的方式实现数据之间的联系 。<em>因此不能动态调整长度（内存使用率较低）</em></td>\n<td align=\"left\">每个数据节点不一定相邻，通过指针的方式实现数据之间的联系. <em>因此可以调整动态长度</em></td>\n</tr>\n<tr>\n<td align=\"center\">删除</td>\n<td align=\"left\">可以删除最后一个数据，删除其他位置的数据的时候需要将相应的数据前移 <em>（删除成本高）</em></td>\n<td align=\"left\">_数据可以随意删除_，只需要将前一个节点的指针指向后一个节点</td>\n</tr>\n<tr>\n<td align=\"center\">插入</td>\n<td align=\"left\">可以在顺序表最后添加一个新的数据，在其他位置插入数据的时候需要将相应的数据后移再插入 <em>（插入成本高）</em></td>\n<td align=\"left\"><em>数据可以随意插入</em> ，只需要将前一个节点的指针指向新的节点，再将新的节点的指针指向下一个节点</td>\n</tr>\n<tr>\n<td align=\"center\">查询</td>\n<td align=\"left\">索引与内存偏移正相关，只需要知道索引就可以得到相应的内存地址，只需要执行一次数据访问就可以得到数据</td>\n<td align=\"left\">需要一个节点一个节点的查找才能得到数据，当节点在末尾的时候需要遍历整个链表才能得到数据。 <em>（查询成本高）</em></td>\n</tr>\n</tbody></table>\n<h2 id=\"树（一对多）\"><a href=\"#树（一对多）\" class=\"headerlink\" title=\"树（一对多）\"></a>树（一对多）</h2><img src=\"https://atts.w3cschool.cn/attachments/day_220312/202203121603255786.jpg\" />\n\n<p>树状图是一种数据结构，它是由 n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它<em>看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的</em>。</p>\n<img src=\"http://t-blog-images.aijs.top/img/202210251011620.webp\" />\n\n<div style=\"font-size: 14px\">\n\n<p>1、<code>结点(Node)</code>：表示树中的数据元素，由数据项和数据元素之间的关系组成。在图中，共有 10 个结点。</p>\n<p>2、<code>结点的度(Degree of Node)</code>：结点所拥有的子树的个数，在图中，结点 A 的度为 3（注意，E,F 也符合树的定义（树的定义见下文）所以 B 的度为 2）。</p>\n<p>3、<code>树的度(Degree of Tree)</code>：树中各结点度的最大值（节点 A 和 D 的度都为最大值 3）。上图中树的度为 3。</p>\n<p>4、<code>叶子结点(Leaf Node)</code>：度为 0 的结点，也叫终端结点。上图中，结点 E、F、G、H、I、J 都是叶子结点。</p>\n<p>5、<code>分支结点(Branch Node)</code>：度不为 0 的结点，也叫非终端结点或内部结点。上图中，结点 A、B、C、D 是分支结点。</p>\n<p>6、<code>孩子(Child)</code>：结点子树的根。上图中，结点 B、C、D 是结点 A 的孩子。</p>\n<p>7、<code>双亲(Parent)</code>：结点的上层结点叫该结点的双亲。上图中，结点 B、C、D 的双亲是结点 A。</p>\n<p>8、<code>祖先(Ancestor)</code>：从根到该结点所经分支上的所有结点。上图中，结点 E 的祖先是 A 和 B。</p>\n<p>9、<code>子孙(Descendant)</code>：以某结点为根的子树中的任一结点。上图中，除 A 之外的所有结点都是 A 的子孙。</p>\n<p>10、<code>兄弟(Brother)</code>：同一双亲的孩子。上图中，结点 B、C、D 互为兄弟。</p>\n<p>11、<code>结点的层次(Level of Node)</code>：从根结点到树中某结点所经路径上的分支数称为该结点的层次。根结点的层次规定为 1，其余结点的层次等于其双亲结点的层次加 1。</p>\n<p>12、<code>堂兄弟(Sibling)</code>：同一层的双亲不同的结点。上图中，G 和 H 互为堂兄弟。</p>\n<p>13、<code>树的深度(Depth of Tree)</code>：树中结点的最大层次数。上图中，树的深度为 3。</p>\n<p>14、<code>无序树(Unordered Tree)</code>：树中任意一个结点的各孩子结点之间的次序构成无关紧要的树。通常树指无序树。</p>\n<p>15、<code>有序树(Ordered Tree)</code>：树中任意一个结点的各孩子结点有严格排列次序的树。二叉树是有序树，因为二叉树中每个孩子结点都确切定义为是该结点的左孩子结点还是右孩子结点。</p>\n<p>16、<code>森林(Forest)</code>：m(m≥0)棵树的集合。自然界中的树和森林的概念差别很大，但在数据结构中树和森林的概念差别很小。从定义可知，一棵树由根结点和 m 个子树构成，若把树的根结点删除，则树变成了包含 m 棵树的森林。当然，根据定义，一棵树也可以称为森林。</p>\n</div>\n\n<h3 id=\"无序树\"><a href=\"#无序树\" class=\"headerlink\" title=\"无序树\"></a>无序树</h3><p>树的任意节点的子节点没有顺序关系。</p>\n<h3 id=\"有序树\"><a href=\"#有序树\" class=\"headerlink\" title=\"有序树\"></a>有序树</h3><p>树的任意节点的子节点有顺序关系。</p>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>树的任意节点至多包含两棵子树。</p>\n<p>二叉树遍历:二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。</p>\n<p>二叉树的访问次序可以分为四种：<code>前序遍历</code> <code>中序遍历</code> <code>后序遍历</code> <code>层次遍历</code> <a href=\"https://www.cnblogs.com/du001011/p/11229170.html\" target=\"_blank\" >见</a></p>\n<img src=\"http://t-blog-images.aijs.top/img/202210251018109.webp\" />\n\n<h3 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h3><p>额，怎么会保证这样呢，想不到场景（计划生育也做不到吧）</p>\n<p>叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。</p>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><p>对于一颗二叉树，假设其深度为 d（d&gt;1）。除第 d 层外的所有节点构成满二叉树，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p>\n<h3 id=\"霍夫曼树\"><a href=\"#霍夫曼树\" class=\"headerlink\" title=\"霍夫曼树\"></a>霍夫曼树</h3><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。</p>\n<p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p>\n<p><a href=\"http://c.biancheng.net/view/3398.html\" target=\"_blank\" >见</a></p>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p><em>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1</em> ，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。</p>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><h3 id=\"伸展树\"><a href=\"#伸展树\" class=\"headerlink\" title=\"伸展树\"></a>伸展树</h3><h3 id=\"替罪羊树\"><a href=\"#替罪羊树\" class=\"headerlink\" title=\"替罪羊树\"></a>替罪羊树</h3><h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B-树\"></a>B-树</h3><h3 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><h3 id=\"B-树-2\"><a href=\"#B-树-2\" class=\"headerlink\" title=\"B*树\"></a>B*树</h3><h3 id=\"字典树\"><a href=\"#字典树\" class=\"headerlink\" title=\"字典树\"></a>字典树</h3><p>又称单词查找树，Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。它有 3 个基本性质：根节点不包含字符，除根节点外每一个节点都只包含一个字符；从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；每个节点的所有子节点包含的字符都不相同。</p>\n<p><a href=\"https://blog.csdn.net/qq_49688477/article/details/118879270\" target=\"_blank\" >见</a></p>\n<h3 id=\"浅索二叉树\"><a href=\"#浅索二叉树\" class=\"headerlink\" title=\"浅索二叉树\"></a>浅索二叉树</h3><p>线索化的实质： 是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树的时候才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。<br><a href=\"https://blog.csdn.net/m0_61886762/article/details/124541056\" target=\"_blank\" >见</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.w3cschool.cn/article/27791711.html\" target=\"_blank\" >什么是线性表？数据结构之线性表讲解!</a><br><a href=\"https://www.w3cschool.cn/article/38266355.html\" target=\"_blank\" >什么是树？数据结构之树讲解!</a></p>\n","count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8-%E4%B8%80%E5%AF%B9%E4%B8%80\"><span class=\"toc-text\">线性表(一对一)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8\"><span class=\"toc-text\">顺序表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E5%BC%8F%E8%A1%A8\"><span class=\"toc-text\">链式表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单向链表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双向链表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E7%8A%B6%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">环状链表</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">顺序表和链式表的优缺点比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89\"><span class=\"toc-text\">树（一对多）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A0%E5%BA%8F%E6%A0%91\"><span class=\"toc-text\">无序树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%BA%8F%E6%A0%91\"><span class=\"toc-text\">有序树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">满二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">完全二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91\"><span class=\"toc-text\">霍夫曼树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">平衡二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%A2%E9%BB%91%E6%A0%91\"><span class=\"toc-text\">红黑树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%B8%E5%B1%95%E6%A0%91\"><span class=\"toc-text\">伸展树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91\"><span class=\"toc-text\">替罪羊树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91\"><span class=\"toc-text\">B-树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91-1\"><span class=\"toc-text\">B+树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91-2\"><span class=\"toc-text\">B*树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E5%85%B8%E6%A0%91\"><span class=\"toc-text\">字典树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%85%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">浅索二叉树</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>"}